
sched.pfprr_quantum_static.global.sched:     file format elf64-x86-64


Disassembly of section .text:

0000000000400000 <printc>:
	return cos_print_str(s, strlen(s));
}

static int  __attribute__((format(printf, 1, 2)))
printc(char *fmt, ...)
{
  400000:	55                   	push   rbp
  400001:	49 89 fa             	mov    r10,rdi
  400004:	48 89 e5             	mov    rbp,rsp
  400007:	48 81 ec 90 01 00 00 	sub    rsp,0x190
  40000e:	48 89 b5 58 ff ff ff 	mov    QWORD PTR [rbp-0xa8],rsi
  400015:	48 89 95 60 ff ff ff 	mov    QWORD PTR [rbp-0xa0],rdx
  40001c:	48 89 8d 68 ff ff ff 	mov    QWORD PTR [rbp-0x98],rcx
  400023:	4c 89 85 70 ff ff ff 	mov    QWORD PTR [rbp-0x90],r8
  40002a:	4c 89 8d 78 ff ff ff 	mov    QWORD PTR [rbp-0x88],r9
  400031:	84 c0                	test   al,al
  400033:	74 20                	je     400055 <printc+0x55>
  400035:	0f 29 45 80          	movaps XMMWORD PTR [rbp-0x80],xmm0
  400039:	0f 29 4d 90          	movaps XMMWORD PTR [rbp-0x70],xmm1
  40003d:	0f 29 55 a0          	movaps XMMWORD PTR [rbp-0x60],xmm2
  400041:	0f 29 5d b0          	movaps XMMWORD PTR [rbp-0x50],xmm3
  400045:	0f 29 65 c0          	movaps XMMWORD PTR [rbp-0x40],xmm4
  400049:	0f 29 6d d0          	movaps XMMWORD PTR [rbp-0x30],xmm5
  40004d:	0f 29 75 e0          	movaps XMMWORD PTR [rbp-0x20],xmm6
  400051:	0f 29 7d f0          	movaps XMMWORD PTR [rbp-0x10],xmm7
	char    s[180];
	va_list arg_ptr;
	size_t  ret;

	va_start(arg_ptr, fmt);
  400055:	48 8d 45 10          	lea    rax,[rbp+0x10]
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  400059:	48 8d 8d 78 fe ff ff 	lea    rcx,[rbp-0x188]
  400060:	4c 89 d2             	mov    rdx,r10
  400063:	be b4 00 00 00       	mov    esi,0xb4
	va_start(arg_ptr, fmt);
  400068:	48 89 85 80 fe ff ff 	mov    QWORD PTR [rbp-0x180],rax
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40006f:	48 8d bd 90 fe ff ff 	lea    rdi,[rbp-0x170]
	va_start(arg_ptr, fmt);
  400076:	48 8d 85 50 ff ff ff 	lea    rax,[rbp-0xb0]
  40007d:	c7 85 78 fe ff ff 08 	mov    DWORD PTR [rbp-0x188],0x8
  400084:	00 00 00 
  400087:	c7 85 7c fe ff ff 30 	mov    DWORD PTR [rbp-0x184],0x30
  40008e:	00 00 00 
  400091:	48 89 85 88 fe ff ff 	mov    QWORD PTR [rbp-0x178],rax
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  400098:	e8 03 53 01 00       	call   4153a0 <vsnprintf>
	va_end(arg_ptr);
	ret = cos_print_str(s, ret);
  40009d:	48 8d bd 90 fe ff ff 	lea    rdi,[rbp-0x170]
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  4000a4:	89 c6                	mov    esi,eax
	ret = cos_print_str(s, ret);
  4000a6:	e8 25 a0 00 00       	call   40a0d0 <cos_print_str>

	return ret;
}
  4000ab:	c9                   	leave  
  4000ac:	c3                   	ret    
  4000ad:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004000b0 <exit_init_thd>:

struct slm_thd *slm_thd_current_extern(void);

static __attribute__((noreturn)) void
exit_init_thd(void)
{
  4000b0:	55                   	push   rbp
  4000b1:	48 89 e5             	mov    rbp,rsp
  4000b4:	41 54                	push   r12
  4000b6:	48 83 ec 08          	sub    rsp,0x8
	struct slm_thd *current = slm_thd_current_extern();
  4000ba:	e8 81 18 00 00       	call   401940 <slm_thd_current_extern>

	if (cos_coreid() == 0) printc("\tScheduler %ld: Exiting thread %ld from component %ld\n", cos_compid(), cos_thdid(), (compid_t)cos_inv_token());
  4000bf:	48 8b 35 7a 6f 02 00 	mov    rsi,QWORD PTR [rip+0x26f7a]        # 427040 <__cosrt_comp_info+0x40>
  4000c6:	bf c0 b0 41 00       	mov    edi,0x41b0c0
	struct slm_thd *current = slm_thd_current_extern();
  4000cb:	49 89 c4             	mov    r12,rax
static inline long
get_stk_data(int offset)
{
	unsigned long curr_stk_pointer;

	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  4000ce:	48 89 e0             	mov    rax,rsp
	 * access.  We want to find the struct cos_stk (see the stkmgr
	 * interface) so that we can then offset into it and get the
	 * cpu_id.  This struct is at the _top_ of the current stack,
	 * and cpu_id is at the top of the struct (it is a u32_t).
	 */
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  4000d1:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
	if (cos_coreid() == 0) printc("\tScheduler %ld: Exiting thread %ld from component %ld\n", cos_compid(), cos_thdid(), (compid_t)cos_inv_token());
  4000d7:	48 8b 88 e8 1f 00 00 	mov    rcx,QWORD PTR [rax+0x1fe8]
typedef u16_t cos_thdid_t;

static thdid_t
cos_thdid(void)
{
	return cos_get_thd_id();
  4000de:	0f b7 90 f0 1f 00 00 	movzx  edx,WORD PTR [rax+0x1ff0]
  4000e5:	31 c0                	xor    eax,eax
  4000e7:	e8 14 ff ff ff       	call   400000 <printc>
	slm_cs_cached_t cached;
	sched_tok_t     tok;
	struct slm_thd  *owner;
	int             contended;

	assert(current);
  4000ec:	4d 85 e4             	test   r12,r12
  4000ef:	0f 84 09 01 00 00    	je     4001fe <exit_init_thd+0x14e>
	cs = &(slm_global()->lock);

	while (1) {
		tok    = cos_sched_sync();
  4000f5:	e8 06 12 01 00       	call   411300 <cos_sched_sync>
  4000fa:	41 89 c1             	mov    r9d,eax
 * - @ret - a *cached* version of the critical section metadata to be passed into `__slm_cs_cas`.
 */
static inline slm_cs_cached_t
__slm_cs_data(struct slm_cs *cs, struct slm_thd **thd, int *contention)
{
	unsigned long oc = ps_load(&cs->owner_contention);
  4000fd:	48 8b 05 7c 1d 1a 00 	mov    rax,QWORD PTR [rip+0x1a1d7c]        # 5a1e80 <__slm_global>
		cached = __slm_cs_data(cs, &owner, &contended);

		if (unlikely(owner)) {
  400104:	48 89 c1             	mov    rcx,rax
  400107:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  40010b:	0f 85 b1 00 00 00    	jne    4001c2 <exit_init_thd+0x112>
 */
static inline int
ps_cas(unsigned long *target, unsigned long old, unsigned long updated)
{
        char z;
        __asm__ __volatile__("lock " PS_CAS_STR
  400111:	f0 4c 0f b1 25 66 1d 	lock cmpxchg QWORD PTR [rip+0x1a1d66],r12        # 5a1e80 <__slm_global>
  400118:	1a 00 
  40011a:	0f 94 c0             	sete   al

			continue;
		}

		/* success! common case */
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  40011d:	84 c0                	test   al,al
  40011f:	74 d4                	je     4000f5 <exit_init_thd+0x45>

	slm_cs_enter(current, SLM_CS_NONE);
	slm_thd_deinit(current);		/* I'm out! */
  400121:	4c 89 e7             	mov    rdi,r12
  400124:	e8 b7 36 01 00       	call   4137e0 <slm_thd_deinit>
slm_cs_exit(struct slm_thd *switchto, slm_cs_flags_t flags)
{
	int ret = 1;
	struct slm_cs *cs = &(slm_global()->lock);

	while (ret != 0) {
  400129:	eb 15                	jmp    400140 <exit_init_thd+0x90>
  40012b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  400130:	f0 48 0f b1 15 47 1d 	lock cmpxchg QWORD PTR [rip+0x1a1d47],rdx        # 5a1e80 <__slm_global>
  400137:	1a 00 
  400139:	0f 94 c0             	sete   al
  40013c:	84 c0                	test   al,al
  40013e:	75 2e                	jne    40016e <exit_init_thd+0xbe>
		int             contention;
		sched_tok_t     tok;
		slm_cs_cached_t cached;
		struct slm_thd *current;

		tok    = cos_sched_sync();
  400140:	e8 bb 11 01 00       	call   411300 <cos_sched_sync>
  400145:	89 c1                	mov    ecx,eax
  400147:	48 8b 05 32 1d 1a 00 	mov    rax,QWORD PTR [rip+0x1a1d32]        # 5a1e80 <__slm_global>
		cached = __slm_cs_data(cs, &current, &contention);
		/* Another thread attempted to enter the critical section */
		if (unlikely(contention)) {
  40014e:	48 89 c2             	mov    rdx,rax
  400151:	83 e2 01             	and    edx,0x1
  400154:	74 da                	je     400130 <exit_init_thd+0x80>
	/* least significant bit signifies contention */
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  400156:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  400159:	48 89 c2             	mov    rdx,rax
  40015c:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  400161:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  400165:	e8 f6 36 01 00       	call   413860 <slm_cs_exit_contention>
  40016a:	85 c0                	test   eax,eax
  40016c:	75 d2                	jne    400140 <exit_init_thd+0x90>
	slm_cs_exit(NULL, SLM_CS_NONE);

	/* Switch to the scheduler thread */
	if (cos_defswitch(BOOT_CAPTBL_SELF_INITTHD_CPU_BASE, TCAP_PRIO_MAX, TCAP_RES_INF, cos_sched_sync())) BUG();
  40016e:	e8 8d 11 01 00       	call   411300 <cos_sched_sync>
  400173:	be 01 00 00 00       	mov    esi,0x1
  400178:	bf 28 00 00 00       	mov    edi,0x28
  40017d:	48 c7 c2 ff ff ff ff 	mov    rdx,0xffffffffffffffff
  400184:	89 c1                	mov    ecx,eax
  400186:	e8 d5 c5 00 00       	call   40c760 <cos_defswitch>
	return cos_print_str(s, strlen(s));
  40018b:	be 11 00 00 00       	mov    esi,0x11
  400190:	85 c0                	test   eax,eax
  400192:	75 17                	jne    4001ab <exit_init_thd+0xfb>
  400194:	bf c4 b1 41 00       	mov    edi,0x41b1c4
  400199:	e8 32 9f 00 00       	call   40a0d0 <cos_print_str>

	BUG();
  40019e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4001a5:	00 00 00 00 
  4001a9:	0f 0b                	ud2    
  4001ab:	bf b2 b1 41 00       	mov    edi,0x41b1b2
  4001b0:	e8 1b 9f 00 00       	call   40a0d0 <cos_print_str>
	if (cos_defswitch(BOOT_CAPTBL_SELF_INITTHD_CPU_BASE, TCAP_PRIO_MAX, TCAP_RES_INF, cos_sched_sync())) BUG();
  4001b5:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4001bc:	00 00 00 00 
  4001c0:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  4001c2:	41 89 c0             	mov    r8d,eax
  4001c5:	4c 89 e2             	mov    rdx,r12
  4001c8:	48 89 c6             	mov    rsi,rax
  4001cb:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  4001d0:	41 83 e0 01          	and    r8d,0x1
  4001d4:	e8 37 36 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  4001d9:	83 f8 f0             	cmp    eax,0xfffffff0
  4001dc:	0f 85 13 ff ff ff    	jne    4000f5 <exit_init_thd+0x45>
  4001e2:	be 59 00 00 00       	mov    esi,0x59
  4001e7:	bf 58 b1 41 00       	mov    edi,0x41b158
  4001ec:	e8 df 9e 00 00       	call   40a0d0 <cos_print_str>
  4001f1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4001f8:	00 00 00 00 
  4001fc:	0f 0b                	ud2    
  4001fe:	be 59 00 00 00       	mov    esi,0x59
  400203:	bf f8 b0 41 00       	mov    edi,0x41b0f8
  400208:	e8 c3 9e 00 00       	call   40a0d0 <cos_print_str>
	assert(current);
  40020d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400214:	00 00 00 00 
  400218:	0f 0b                	ud2    
  40021a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000400220 <calculate_initialization_schedule>:
{
  400220:	f3 0f 1e fa          	endbr64 
  400224:	55                   	push   rbp
	ret = args_get_entry("execute", &exec_entries);
  400225:	bf d6 b1 41 00       	mov    edi,0x41b1d6
{
  40022a:	48 89 e5             	mov    rbp,rsp
  40022d:	41 54                	push   r12
  40022f:	53                   	push   rbx
	ret = args_get_entry("execute", &exec_entries);
  400230:	48 8d 75 90          	lea    rsi,[rbp-0x70]
{
  400234:	48 83 ec 70          	sub    rsp,0x70
	ret = args_get_entry("execute", &exec_entries);
  400238:	e8 43 ae 00 00       	call   40b080 <args_get_entry>
	assert(!ret);
  40023d:	85 c0                	test   eax,eax
  40023f:	0f 85 9b 01 00 00    	jne    4003e0 <calculate_initialization_schedule+0x1c0>
	printc("\tSched %ld: %d components that need execution\n", cos_compid(), args_len(&exec_entries));
  400245:	48 8d 7d 90          	lea    rdi,[rbp-0x70]
  400249:	e8 32 a8 00 00       	call   40aa80 <args_len>
  40024e:	48 8b 35 eb 6d 02 00 	mov    rsi,QWORD PTR [rip+0x26deb]        # 427040 <__cosrt_comp_info+0x40>
  400255:	bf 08 b2 41 00       	mov    edi,0x41b208
  40025a:	89 c2                	mov    edx,eax
  40025c:	31 c0                	xor    eax,eax
  40025e:	e8 9d fd ff ff       	call   400000 <printc>
	for (cont = args_iter(&exec_entries, &i, &curr) ; cont ; cont = args_iter_next(&i, &curr)) {
  400263:	48 8d 55 b0          	lea    rdx,[rbp-0x50]
  400267:	48 8d 75 d0          	lea    rsi,[rbp-0x30]
  40026b:	48 8d 7d 90          	lea    rdi,[rbp-0x70]
  40026f:	e8 cc a8 00 00       	call   40ab40 <args_iter>
  400274:	85 c0                	test   eax,eax
  400276:	0f 84 ea 00 00 00    	je     400366 <calculate_initialization_schedule+0x146>
		compid_t id        = atoi(args_key(&curr, &keylen));
  40027c:	48 8d 75 8c          	lea    rsi,[rbp-0x74]
  400280:	48 8d 7d b0          	lea    rdi,[rbp-0x50]
  400284:	e8 57 a7 00 00       	call   40a9e0 <args_key>
  400289:	48 89 c7             	mov    rdi,rax
  40028c:	e8 1f 52 01 00       	call   4154b0 <atoi>
		char    *exec_type = args_value(&curr);
  400291:	48 8d 7d b0          	lea    rdi,[rbp-0x50]
		compid_t id        = atoi(args_key(&curr, &keylen));
  400295:	48 63 d8             	movsxd rbx,eax
		char    *exec_type = args_value(&curr);
  400298:	e8 a3 a7 00 00       	call   40aa40 <args_value>
  40029d:	48 89 c7             	mov    rdi,rax
		assert(exec_type);
  4002a0:	48 85 c0             	test   rax,rax
  4002a3:	0f 84 e3 00 00 00    	je     40038c <calculate_initialization_schedule+0x16c>
	} while (0)

static inline long
cos_spd_id(void)
{
	return __cosrt_comp_info.cos_this_spd_id;
  4002a9:	4c 8b 25 90 6d 02 00 	mov    r12,QWORD PTR [rip+0x26d90]        # 427040 <__cosrt_comp_info+0x40>
		assert(id != cos_compid());
  4002b0:	4c 39 e3             	cmp    rbx,r12
  4002b3:	0f 84 ef 00 00 00    	je     4003a8 <calculate_initialization_schedule+0x188>
		if (strcmp(exec_type, "init")) BUG();	/* TODO: no support for hierarchical scheduling yet */
  4002b9:	be 85 b2 41 00       	mov    esi,0x41b285
  4002be:	e8 6d 54 01 00       	call   415730 <strcmp>
  4002c3:	85 c0                	test   eax,eax
  4002c5:	0f 85 a5 00 00 00    	jne    400370 <calculate_initialization_schedule+0x150>
	printc("\tSched %ld: %ld is the %ldth component to initialize\n", cos_compid(), cid, init_schedule_off);
  4002cb:	48 8b 0d 2e dd 05 00 	mov    rcx,QWORD PTR [rip+0x5dd2e]        # 45e000 <init_schedule_off>
  4002d2:	48 89 da             	mov    rdx,rbx
  4002d5:	4c 89 e6             	mov    rsi,r12
  4002d8:	31 c0                	xor    eax,eax
  4002da:	bf a0 b2 41 00       	mov    edi,0x41b2a0
	assert(s->status == SCHEDINIT_FREE);
  4002df:	4c 8d 24 9b          	lea    r12,[rbx+rbx*4]
	printc("\tSched %ld: %ld is the %ldth component to initialize\n", cos_compid(), cid, init_schedule_off);
  4002e3:	e8 18 fd ff ff       	call   400000 <printc>
	init_schedule[init_schedule_off] = cid;
  4002e8:	48 8b 05 11 dd 05 00 	mov    rax,QWORD PTR [rip+0x5dd11]        # 45e000 <init_schedule_off>
  4002ef:	48 89 1c c5 00 de 45 	mov    QWORD PTR [rax*8+0x45de00],rbx
  4002f6:	00 
	init_schedule_off++;
  4002f7:	48 83 c0 01          	add    rax,0x1
	assert(s->status == SCHEDINIT_FREE);
  4002fb:	4a 8d 1c e5 00 d4 45 	lea    rbx,[r12*8+0x45d400]
  400302:	00 
	init_schedule_off++;
  400303:	48 89 05 f6 dc 05 00 	mov    QWORD PTR [rip+0x5dcf6],rax        # 45e000 <init_schedule_off>
	assert(s->status == SCHEDINIT_FREE);
  40030a:	8b 43 10             	mov    eax,DWORD PTR [rbx+0x10]
  40030d:	85 c0                	test   eax,eax
  40030f:	0f 85 af 00 00 00    	jne    4003c4 <calculate_initialization_schedule+0x1a4>
	*s = (struct schedinit_status) {
  400315:	66 0f ef c0          	pxor   xmm0,xmm0
  400319:	42 0f 11 04 e5 00 d4 	movups XMMWORD PTR [r12*8+0x45d400],xmm0
  400320:	45 00 
  400322:	0f 11 43 10          	movups XMMWORD PTR [rbx+0x10],xmm0
  400326:	48 c7 43 20 00 00 00 	mov    QWORD PTR [rbx+0x20],0x0
  40032d:	00 
  40032e:	c7 43 10 01 00 00 00 	mov    DWORD PTR [rbx+0x10],0x1
  400335:	48 c7 43 18 ff ff ff 	mov    QWORD PTR [rbx+0x18],0xffffffffffffffff
  40033c:	ff 
	simple_barrier_init(&s->barrier, init_parallelism());
  40033d:	e8 de 99 00 00       	call   409d20 <init_parallelism>
	for (cont = args_iter(&exec_entries, &i, &curr) ; cont ; cont = args_iter_next(&i, &curr)) {
  400342:	48 8d 75 b0          	lea    rsi,[rbp-0x50]
  400346:	48 8d 7d d0          	lea    rdi,[rbp-0x30]
}

static inline void
simple_barrier_init(struct simple_barrier *b, unsigned int ncores)
{
	*b = (struct simple_barrier) {
  40034a:	4a c7 04 e5 00 d4 45 	mov    QWORD PTR [r12*8+0x45d400],0x0
  400351:	00 00 00 00 00 
  400356:	89 43 08             	mov    DWORD PTR [rbx+0x8],eax
  400359:	e8 72 a7 00 00       	call   40aad0 <args_iter_next>
  40035e:	85 c0                	test   eax,eax
  400360:	0f 85 16 ff ff ff    	jne    40027c <calculate_initialization_schedule+0x5c>
}
  400366:	48 83 c4 70          	add    rsp,0x70
  40036a:	5b                   	pop    rbx
  40036b:	41 5c                	pop    r12
  40036d:	5d                   	pop    rbp
  40036e:	c3                   	ret    
  40036f:	90                   	nop
  400370:	be 11 00 00 00       	mov    esi,0x11
  400375:	bf 8a b2 41 00       	mov    edi,0x41b28a
  40037a:	e8 51 9d 00 00       	call   40a0d0 <cos_print_str>
		if (strcmp(exec_type, "init")) BUG();	/* TODO: no support for hierarchical scheduling yet */
  40037f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400386:	00 00 00 00 
  40038a:	0f 0b                	ud2    
  40038c:	be 24 00 00 00       	mov    esi,0x24
  400391:	bf 38 b2 41 00       	mov    edi,0x41b238
  400396:	e8 35 9d 00 00       	call   40a0d0 <cos_print_str>
		assert(exec_type);
  40039b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4003a2:	00 00 00 00 
  4003a6:	0f 0b                	ud2    
  4003a8:	be 24 00 00 00       	mov    esi,0x24
  4003ad:	bf 60 b2 41 00       	mov    edi,0x41b260
  4003b2:	e8 19 9d 00 00       	call   40a0d0 <cos_print_str>
		assert(id != cos_compid());
  4003b7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4003be:	00 00 00 00 
  4003c2:	0f 0b                	ud2    
  4003c4:	be 23 00 00 00       	mov    esi,0x23
  4003c9:	bf d8 b2 41 00       	mov    edi,0x41b2d8
  4003ce:	e8 fd 9c 00 00       	call   40a0d0 <cos_print_str>
	assert(s->status == SCHEDINIT_FREE);
  4003d3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4003da:	00 00 00 00 
  4003de:	0f 0b                	ud2    
  4003e0:	be 23 00 00 00       	mov    esi,0x23
  4003e5:	bf e0 b1 41 00       	mov    edi,0x41b1e0
  4003ea:	e8 e1 9c 00 00       	call   40a0d0 <cos_print_str>
	assert(!ret);
  4003ef:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4003f6:	00 00 00 00 
  4003fa:	0f 0b                	ud2    
  4003fc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000400400 <init_done>:
	while (1) ;
}

void
init_done(int parallel_init, init_main_t cont)
{
  400400:	f3 0f 1e fa          	endbr64 
  400404:	55                   	push   rbp
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  400405:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  400408:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  40040e:	48 89 e5             	mov    rbp,rsp
  400411:	41 54                	push   r12
  400413:	53                   	push   rbx
	return get_stk_data(INVTOKEN_OFFSET);
  400414:	48 8b b8 e8 1f 00 00 	mov    rdi,QWORD PTR [rax+0x1fe8]
	compid_t client = (compid_t)cos_inv_token();
	struct schedinit_status *s;

	s = &initialization_state[client];
	assert(s->status != SCHEDINIT_FREE);
  40041b:	48 8d 14 bf          	lea    rdx,[rdi+rdi*4]
  40041f:	48 c1 e2 03          	shl    rdx,0x3
  400423:	8b 82 10 d4 45 00    	mov    eax,DWORD PTR [rdx+0x45d410]
  400429:	85 c0                	test   eax,eax
  40042b:	0f 84 a3 00 00 00    	je     4004d4 <init_done+0xd4>
  400431:	89 f3                	mov    ebx,esi
  400433:	48 8d 8a 00 d4 45 00 	lea    rcx,[rdx+0x45d400]
  40043a:	31 f6                	xor    esi,esi
  40043c:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
  400443:	f0 48 0f b1 b2 18 d4 	lock cmpxchg QWORD PTR [rdx+0x45d418],rsi
  40044a:	45 00 
  40044c:	0f 94 c0             	sete   al

	/*
	 * `init_done` should not be called once initialization is
	 * completed. This is an error.
	 */
	if (s->status == SCHEDINIT_MAIN) {
  40044f:	8b 41 10             	mov    eax,DWORD PTR [rcx+0x10]
  400452:	83 f8 03             	cmp    eax,0x3
  400455:	0f 84 b1 00 00 00    	je     40050c <init_done+0x10c>

	/*
	 * This should *ONLY* happen for the initialization thread
	 * *after* it executes `cos_init`.
	 */
	if (s->status == SCHEDINIT_INITING) {
  40045b:	83 f8 01             	cmp    eax,0x1
  40045e:	74 68                	je     4004c8 <init_done+0xc8>
	assert(*barrier <= ncore);
  400460:	8b 71 08             	mov    esi,DWORD PTR [rcx+0x8]
  400463:	48 39 b2 00 d4 45 00 	cmp    QWORD PTR [rdx+0x45d400],rsi
  40046a:	0f 87 80 00 00 00    	ja     4004f0 <init_done+0xf0>
ps_faa(unsigned long *target, long inc)
{
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Warray-bounds"
/* GCC has bug of processing a warning(-Warray-bounds) and not get fixed, thus close the warning in this function */
        __asm__ __volatile__("lock " PS_FAA_STR
  400470:	b8 01 00 00 00       	mov    eax,0x1
  400475:	f0 48 0f c1 82 00 d4 	lock xadd QWORD PTR [rdx+0x45d400],rax
  40047c:	45 00 
                             : "+m" (*target), "+q" (inc)
                             : : "memory", "cc");
        return inc;
  40047e:	66 90                	xchg   ax,ax
	while (ps_load(barrier) < ncore) ;
  400480:	48 8b 01             	mov    rax,QWORD PTR [rcx]
  400483:	48 39 c6             	cmp    rsi,rax
  400486:	77 f8                	ja     400480 <init_done+0x80>
 	 * If this barrier is hit *after* the parallel initialization
	 * has finished, no blocking will occur as its count has
	 * already been hit.
	 */
	simple_barrier(&s->barrier);
	s->status = SCHEDINIT_MAIN;
  400488:	48 8d 04 bf          	lea    rax,[rdi+rdi*4]
  40048c:	4c 8d 24 c5 00 d4 45 	lea    r12,[rax*8+0x45d400]
  400493:	00 
  400494:	41 c7 44 24 10 03 00 	mov    DWORD PTR [r12+0x10],0x3
  40049b:	00 00 

	s->initialization_thds[cos_coreid()] = slm_thd_current_extern();
  40049d:	e8 9e 14 00 00       	call   401940 <slm_thd_current_extern>
  4004a2:	49 89 44 24 20       	mov    QWORD PTR [r12+0x20],rax
	extern int thd_block(void);
	thd_block(); 		/* block until initialization is completed */
  4004a7:	e8 04 1f 00 00       	call   4023b0 <thd_block>

 	/*
	 * After initialization, we're done with the parallel threads
	 * in some cases.
	 */
	if ((cos_coreid() != s->init_core && cont == INIT_MAIN_SINGLE) || cont == INIT_MAIN_NONE) {
  4004ac:	49 83 7c 24 18 00    	cmp    QWORD PTR [r12+0x18],0x0
  4004b2:	74 05                	je     4004b9 <init_done+0xb9>
  4004b4:	83 fb 01             	cmp    ebx,0x1
  4004b7:	74 53                	je     40050c <init_done+0x10c>
  4004b9:	85 db                	test   ebx,ebx
  4004bb:	74 4f                	je     40050c <init_done+0x10c>
	 * main execution. We'd expect the next API call here to be
	 * `init_exit`.
	 */

	return;
}
  4004bd:	5b                   	pop    rbx
  4004be:	41 5c                	pop    r12
  4004c0:	5d                   	pop    rbp
  4004c1:	c3                   	ret    
  4004c2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
		ps_store(&s->status, SCHEDINIT_PARINIT);
  4004c8:	c7 41 10 02 00 00 00 	mov    DWORD PTR [rcx+0x10],0x2
}
  4004cf:	5b                   	pop    rbx
  4004d0:	41 5c                	pop    r12
  4004d2:	5d                   	pop    rbp
  4004d3:	c3                   	ret    
  4004d4:	be 24 00 00 00       	mov    esi,0x24
  4004d9:	bf 00 b3 41 00       	mov    edi,0x41b300
  4004de:	e8 ed 9b 00 00       	call   40a0d0 <cos_print_str>
	assert(s->status != SCHEDINIT_FREE);
  4004e3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4004ea:	00 00 00 00 
  4004ee:	0f 0b                	ud2    
  4004f0:	be 5d 00 00 00       	mov    esi,0x5d
  4004f5:	bf 28 b3 41 00       	mov    edi,0x41b328
  4004fa:	e8 d1 9b 00 00       	call   40a0d0 <cos_print_str>
	assert(*barrier <= ncore);
  4004ff:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400506:	00 00 00 00 
  40050a:	0f 0b                	ud2    
		exit_init_thd();
  40050c:	e8 9f fb ff ff       	call   4000b0 <exit_init_thd>
  400511:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  400518:	00 00 00 00 
  40051c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000400520 <init_exit>:

void
init_exit(int retval)
{
  400520:	f3 0f 1e fa          	endbr64 
  400524:	55                   	push   rbp
  400525:	48 89 e5             	mov    rbp,rsp
	exit_init_thd();
  400528:	e8 83 fb ff ff       	call   4000b0 <exit_init_thd>
  40052d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000400530 <slm_idle_comp_initialization>:
	return;
}

void
slm_idle_comp_initialization(void)
{
  400530:	f3 0f 1e fa          	endbr64 
  400534:	55                   	push   rbp
	if (cos_coreid() == 0) printc("Scheduler %ld: Running initialization thread.\n", cos_compid());
  400535:	bf 88 b3 41 00       	mov    edi,0x41b388
  40053a:	31 c0                	xor    eax,eax
{
  40053c:	48 89 e5             	mov    rbp,rsp
  40053f:	41 56                	push   r14
  400541:	41 55                	push   r13
  400543:	41 54                	push   r12
  400545:	53                   	push   rbx
  400546:	31 db                	xor    ebx,ebx
  400548:	48 83 ec 10          	sub    rsp,0x10
	if (cos_coreid() == 0) printc("Scheduler %ld: Running initialization thread.\n", cos_compid());
  40054c:	48 8b 35 ed 6a 02 00 	mov    rsi,QWORD PTR [rip+0x26aed]        # 427040 <__cosrt_comp_info+0x40>
  400553:	e8 a8 fa ff ff       	call   400000 <printc>
	while (init_schedule_current != ps_load(&init_schedule_off)) {
  400558:	48 8b 05 a1 da 05 00 	mov    rax,QWORD PTR [rip+0x5daa1]        # 45e000 <init_schedule_off>
  40055f:	4c 8b 25 b2 b0 01 00 	mov    r12,QWORD PTR [rip+0x1b0b2]        # 41b618 <__unlock+0x5e8>
  400566:	48 85 c0             	test   rax,rax
  400569:	74 72                	je     4005dd <slm_idle_comp_initialization+0xad>
  40056b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		t = thd_alloc_in(client, 0, param, 1);
  400570:	31 f6                	xor    esi,esi
  400572:	b9 01 00 00 00       	mov    ecx,0x1
  400577:	48 8d 55 d8          	lea    rdx,[rbp-0x28]
		param[0] = sched_param_pack(SCHEDP_INIT, 0);
  40057b:	4c 89 65 d8          	mov    QWORD PTR [rbp-0x28],r12
		compid_t client = init_schedule[init_schedule_current];
  40057f:	4c 8b 2c dd 00 de 45 	mov    r13,QWORD PTR [rbx*8+0x45de00]
  400586:	00 
		t = thd_alloc_in(client, 0, param, 1);
  400587:	4c 89 ef             	mov    rdi,r13
  40058a:	e8 d1 47 00 00       	call   404d60 <thd_alloc_in>
		assert(t);
  40058f:	48 85 c0             	test   rax,rax
  400592:	0f 84 f4 00 00 00    	je     40068c <slm_idle_comp_initialization+0x15c>
		if (cos_coreid() == 0)	printc("\tScheduler %ld: initializing component %ld with thread %ld.\n", cos_compid(), client, t->tid);
  400598:	48 8b 48 18          	mov    rcx,QWORD PTR [rax+0x18]
  40059c:	48 8b 35 9d 6a 02 00 	mov    rsi,QWORD PTR [rip+0x26a9d]        # 427040 <__cosrt_comp_info+0x40>
  4005a3:	4c 89 ea             	mov    rdx,r13
  4005a6:	31 c0                	xor    eax,eax
  4005a8:	bf 10 b4 41 00       	mov    edi,0x41b410
		init_schedule_current++;
  4005ad:	48 83 c3 01          	add    rbx,0x1
		if (cos_coreid() == 0)	printc("\tScheduler %ld: initializing component %ld with thread %ld.\n", cos_compid(), client, t->tid);
  4005b1:	e8 4a fa ff ff       	call   400000 <printc>
		while (ps_load(&n->initialization_thds[cos_coreid()]) == NULL) ;
  4005b6:	4b 8d 44 ad 00       	lea    rax,[r13+r13*4+0x0]
  4005bb:	48 8d 14 c5 00 d4 45 	lea    rdx,[rax*8+0x45d400]
  4005c2:	00 
  4005c3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  4005c8:	48 8b 42 20          	mov    rax,QWORD PTR [rdx+0x20]
  4005cc:	48 85 c0             	test   rax,rax
  4005cf:	74 f7                	je     4005c8 <slm_idle_comp_initialization+0x98>
	while (init_schedule_current != ps_load(&init_schedule_off)) {
  4005d1:	48 8b 05 28 da 05 00 	mov    rax,QWORD PTR [rip+0x5da28]        # 45e000 <init_schedule_off>
  4005d8:	48 39 c3             	cmp    rbx,rax
  4005db:	75 93                	jne    400570 <slm_idle_comp_initialization+0x40>
	if (cos_coreid() == 0) printc("Scheduler %ld, initialization completed.\n", cos_compid());
  4005dd:	48 8b 35 5c 6a 02 00 	mov    rsi,QWORD PTR [rip+0x26a5c]        # 427040 <__cosrt_comp_info+0x40>
  4005e4:	bf b8 b3 41 00       	mov    edi,0x41b3b8
  4005e9:	31 c0                	xor    eax,eax
  4005eb:	e8 10 fa ff ff       	call   400000 <printc>
	slm_cs_enter(slm_thd_special(), SLM_CS_NONE);
  4005f0:	e8 db 30 01 00       	call   4136d0 <slm_thd_special>
  4005f5:	48 89 c3             	mov    rbx,rax
  4005f8:	48 85 c0             	test   rax,rax
  4005fb:	0f 84 ab 01 00 00    	je     4007ac <slm_idle_comp_initialization+0x27c>
		tok    = cos_sched_sync();
  400601:	e8 fa 0c 01 00       	call   411300 <cos_sched_sync>
  400606:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  400609:	48 8b 05 70 18 1a 00 	mov    rax,QWORD PTR [rip+0x1a1870]        # 5a1e80 <__slm_global>
		if (unlikely(owner)) {
  400610:	48 89 c1             	mov    rcx,rax
  400613:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  400617:	0f 85 53 01 00 00    	jne    400770 <slm_idle_comp_initialization+0x240>
        __asm__ __volatile__("lock " PS_CAS_STR
  40061d:	f0 48 0f b1 1d 5a 18 	lock cmpxchg QWORD PTR [rip+0x1a185a],rbx        # 5a1e80 <__slm_global>
  400624:	1a 00 
  400626:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  400629:	84 c0                	test   al,al
  40062b:	74 d4                	je     400601 <slm_idle_comp_initialization+0xd1>
	for (i = 0; i < ps_load(&init_schedule_off); i++) {
  40062d:	48 8b 05 cc d9 05 00 	mov    rax,QWORD PTR [rip+0x5d9cc]        # 45e000 <init_schedule_off>
  400634:	31 db                	xor    ebx,ebx
  400636:	48 85 c0             	test   rax,rax
  400639:	75 1c                	jne    400657 <slm_idle_comp_initialization+0x127>
  40063b:	eb 6b                	jmp    4006a8 <slm_idle_comp_initialization+0x178>
  40063d:	0f 1f 00             	nop    DWORD PTR [rax]
		slm_thd_wakeup(t, 0);
  400640:	31 f6                	xor    esi,esi
	for (i = 0; i < ps_load(&init_schedule_off); i++) {
  400642:	48 83 c3 01          	add    rbx,0x1
		slm_thd_wakeup(t, 0);
  400646:	e8 e5 37 01 00       	call   413e30 <slm_thd_wakeup>
	for (i = 0; i < ps_load(&init_schedule_off); i++) {
  40064b:	48 8b 05 ae d9 05 00 	mov    rax,QWORD PTR [rip+0x5d9ae]        # 45e000 <init_schedule_off>
  400652:	48 39 c3             	cmp    rbx,rax
  400655:	73 51                	jae    4006a8 <slm_idle_comp_initialization+0x178>
		t = initialization_state[client].initialization_thds[cos_coreid()];
  400657:	48 8b 04 dd 00 de 45 	mov    rax,QWORD PTR [rbx*8+0x45de00]
  40065e:	00 
  40065f:	48 8d 04 80          	lea    rax,[rax+rax*4]
  400663:	48 8b 3c c5 20 d4 45 	mov    rdi,QWORD PTR [rax*8+0x45d420]
  40066a:	00 
		assert(t != NULL);
  40066b:	48 85 ff             	test   rdi,rdi
  40066e:	75 d0                	jne    400640 <slm_idle_comp_initialization+0x110>
  400670:	be 24 00 00 00       	mov    esi,0x24
  400675:	bf 50 b4 41 00       	mov    edi,0x41b450
  40067a:	e8 51 9a 00 00       	call   40a0d0 <cos_print_str>
  40067f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400686:	00 00 00 00 
  40068a:	0f 0b                	ud2    
  40068c:	be 24 00 00 00       	mov    esi,0x24
  400691:	bf e8 b3 41 00       	mov    edi,0x41b3e8
  400696:	e8 35 9a 00 00       	call   40a0d0 <cos_print_str>
		assert(t);
  40069b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4006a2:	00 00 00 00 
  4006a6:	0f 0b                	ud2    
	slm_cs_exit_reschedule(slm_thd_special(), SLM_CS_NONE);
  4006a8:	e8 23 30 01 00       	call   4136d0 <slm_thd_special>
		}
	}

	/* Make a policy decision! */
	t = slm_sched_schedule();
	if (unlikely(!t)) t = &g->idle_thd;
  4006ad:	41 be 00 1f 5a 00    	mov    r14d,0x5a1f00
  4006b3:	49 89 c5             	mov    r13,rax
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  4006b6:	e8 a5 b1 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	tok  = cos_sched_sync();
  4006bb:	e8 40 0c 01 00       	call   411300 <cos_sched_sync>
  4006c0:	41 89 c4             	mov    r12d,eax
	t = slm_sched_schedule();
  4006c3:	e8 d8 10 00 00       	call   4017a0 <slm_sched_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  4006c8:	48 85 c0             	test   rax,rax
	t = slm_sched_schedule();
  4006cb:	48 89 c3             	mov    rbx,rax
	if (unlikely(!t)) t = &g->idle_thd;
  4006ce:	49 0f 44 de          	cmove  rbx,r14
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  4006d2:	8b 43 04             	mov    eax,DWORD PTR [rbx+0x4]
  4006d5:	83 e8 02             	sub    eax,0x2

	assert(slm_state_is_runnable(t->state));
  4006d8:	83 f8 01             	cmp    eax,0x1
  4006db:	76 1b                	jbe    4006f8 <slm_idle_comp_initialization+0x1c8>
  4006dd:	e9 e6 00 00 00       	jmp    4007c8 <slm_idle_comp_initialization+0x298>
  4006e2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4006e8:	f0 48 0f b1 15 8f 17 	lock cmpxchg QWORD PTR [rip+0x1a178f],rdx        # 5a1e80 <__slm_global>
  4006ef:	1a 00 
  4006f1:	0f 94 c0             	sete   al
	while (ret != 0) {
  4006f4:	84 c0                	test   al,al
  4006f6:	75 2e                	jne    400726 <slm_idle_comp_initialization+0x1f6>
		tok    = cos_sched_sync();
  4006f8:	e8 03 0c 01 00       	call   411300 <cos_sched_sync>
  4006fd:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4006ff:	48 8b 05 7a 17 1a 00 	mov    rax,QWORD PTR [rip+0x1a177a]        # 5a1e80 <__slm_global>
		if (unlikely(contention)) {
  400706:	48 89 c2             	mov    rdx,rax
  400709:	83 e2 01             	and    edx,0x1
  40070c:	74 da                	je     4006e8 <slm_idle_comp_initialization+0x1b8>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  40070e:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  400711:	48 89 c2             	mov    rdx,rax
  400714:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  400719:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  40071d:	e8 3e 31 01 00       	call   413860 <slm_cs_exit_contention>
  400722:	85 c0                	test   eax,eax
  400724:	75 d2                	jne    4006f8 <slm_idle_comp_initialization+0x1c8>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  400726:	e8 35 b1 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  40072b:	8b 03                	mov    eax,DWORD PTR [rbx]
	timeout = g->timeout_next;
  40072d:	48 8b 35 54 18 1a 00 	mov    rsi,QWORD PTR [rip+0x1a1854]        # 5a1f88 <__slm_global+0x108>
	prio = inherit_prio ? curr->priority : t->priority;
  400734:	4c 8b 53 30          	mov    r10,QWORD PTR [rbx+0x30]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  400738:	a8 0b                	test   al,0xb
  40073a:	0f 85 da 00 00 00    	jne    40081a <slm_idle_comp_initialization+0x2ea>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  400740:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  400744:	48 89 f2             	mov    rdx,rsi
  400747:	44 89 e1             	mov    ecx,r12d
  40074a:	4c 89 d6             	mov    rsi,r10
  40074d:	e8 0e c0 00 00       	call   40c760 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  400752:	83 f8 ff             	cmp    eax,0xffffffff
  400755:	0f 84 89 00 00 00    	je     4007e4 <slm_idle_comp_initialization+0x2b4>
	slm_cs_exit(NULL, flags);

	ret = slm_thd_activate(curr, t, tok, 0);
	
	if (unlikely(ret != 0)) {
  40075b:	85 c0                	test   eax,eax
  40075d:	0f 85 01 01 00 00    	jne    400864 <slm_idle_comp_initialization+0x334>
	slm_comp_init_loop();
}
  400763:	48 83 c4 10          	add    rsp,0x10
  400767:	5b                   	pop    rbx
  400768:	41 5c                	pop    r12
  40076a:	41 5d                	pop    r13
  40076c:	41 5e                	pop    r14
  40076e:	5d                   	pop    rbp
  40076f:	c3                   	ret    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  400770:	41 89 c0             	mov    r8d,eax
  400773:	48 89 da             	mov    rdx,rbx
  400776:	48 89 c6             	mov    rsi,rax
  400779:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  40077e:	41 83 e0 01          	and    r8d,0x1
  400782:	e8 89 30 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  400787:	83 f8 f0             	cmp    eax,0xfffffff0
  40078a:	0f 85 71 fe ff ff    	jne    400601 <slm_idle_comp_initialization+0xd1>
  400790:	be 59 00 00 00       	mov    esi,0x59
  400795:	bf 58 b1 41 00       	mov    edi,0x41b158
  40079a:	e8 31 99 00 00       	call   40a0d0 <cos_print_str>
  40079f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4007a6:	00 00 00 00 
  4007aa:	0f 0b                	ud2    
  4007ac:	be 59 00 00 00       	mov    esi,0x59
  4007b1:	bf f8 b0 41 00       	mov    edi,0x41b0f8
  4007b6:	e8 15 99 00 00       	call   40a0d0 <cos_print_str>
	assert(current);
  4007bb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4007c2:	00 00 00 00 
  4007c6:	0f 0b                	ud2    
  4007c8:	be 61 00 00 00       	mov    esi,0x61
  4007cd:	bf 78 b4 41 00       	mov    edi,0x41b478
  4007d2:	e8 f9 98 00 00       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  4007d7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4007de:	00 00 00 00 
  4007e2:	0f 0b                	ud2    
	return t != &g->idle_thd && t != &g->sched_thd;
  4007e4:	48 81 fb 00 1f 5a 00 	cmp    rbx,0x5a1f00
  4007eb:	0f 84 d3 00 00 00    	je     4008c4 <slm_idle_comp_initialization+0x394>
  4007f1:	48 81 fb 88 1e 5a 00 	cmp    rbx,0x5a1e88
  4007f8:	0f 84 c6 00 00 00    	je     4008c4 <slm_idle_comp_initialization+0x394>
  4007fe:	be 61 00 00 00       	mov    esi,0x61
  400803:	bf e0 b4 41 00       	mov    edi,0x41b4e0
  400808:	e8 c3 98 00 00       	call   40a0d0 <cos_print_str>
		/* Assuming only the single tcap with infinite budget...should not get EPERM */
		assert(ret != -EPERM);
  40080d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400814:	00 00 00 00 
  400818:	0f 0b                	ud2    
	timeout = g->timeout_next;
  40081a:	48 89 f1             	mov    rcx,rsi
		if (t == &g->sched_thd) {
  40081d:	48 81 fb 88 1e 5a 00 	cmp    rbx,0x5a1e88
  400824:	0f 84 8f 00 00 00    	je     4008b9 <slm_idle_comp_initialization+0x389>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  40082a:	a8 02                	test   al,0x2
  40082c:	0f 85 b5 00 00 00    	jne    4008e7 <slm_idle_comp_initialization+0x3b7>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  400832:	48 89 ce             	mov    rsi,rcx
  400835:	a8 01                	test   al,0x1
  400837:	0f 84 03 ff ff ff    	je     400740 <slm_idle_comp_initialization+0x210>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  40083d:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
  400841:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  400845:	45 89 e1             	mov    r9d,r12d
  400848:	4c 89 d2             	mov    rdx,r10
  40084b:	4c 8b 05 56 16 1a 00 	mov    r8,QWORD PTR [rip+0x1a1656]        # 5a1ea8 <__slm_global+0x28>
  400852:	e8 c9 0a 01 00       	call   411320 <cos_switch>
	if (unlikely(ret != 0)) {
  400857:	85 c0                	test   eax,eax
  400859:	0f 84 04 ff ff ff    	je     400763 <slm_idle_comp_initialization+0x233>
		assert(ret != -EPERM);
  40085f:	83 f8 ff             	cmp    eax,0xffffffff
  400862:	74 9a                	je     4007fe <slm_idle_comp_initialization+0x2ce>
		assert(ret != -EINVAL);
  400864:	83 f8 ea             	cmp    eax,0xffffffea
  400867:	0f 84 d0 00 00 00    	je     40093d <slm_idle_comp_initialization+0x40d>

		/*
		 * If the slm_thd_activate returns -EBUSY, this means we are trying to switch to the scheduler thread,
		 * and scheduler thread still has pending events. Directly return to process pending events.
		 */
		if (ret == -EBUSY) return ret;
  40086d:	83 f8 f0             	cmp    eax,0xfffffff0
  400870:	0f 84 ed fe ff ff    	je     400763 <slm_idle_comp_initialization+0x233>
		/* If the slm_thd_activate returns -EAGAIN, this means this scheduling token is outdated, try again */
		assert(ret == -EAGAIN);
  400876:	83 f8 f5             	cmp    eax,0xfffffff5
  400879:	0f 85 a2 00 00 00    	jne    400921 <slm_idle_comp_initialization+0x3f1>
  40087f:	4d 85 ed             	test   r13,r13
  400882:	0f 84 24 ff ff ff    	je     4007ac <slm_idle_comp_initialization+0x27c>
		tok    = cos_sched_sync();
  400888:	e8 73 0a 01 00       	call   411300 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  40088d:	48 8b 35 ec 15 1a 00 	mov    rsi,QWORD PTR [rip+0x1a15ec]        # 5a1e80 <__slm_global>
  400894:	41 89 c1             	mov    r9d,eax
		if (unlikely(owner)) {
  400897:	48 89 f1             	mov    rcx,rsi
  40089a:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  40089e:	75 5f                	jne    4008ff <slm_idle_comp_initialization+0x3cf>
  4008a0:	48 89 f0             	mov    rax,rsi
  4008a3:	f0 4c 0f b1 2d d4 15 	lock cmpxchg QWORD PTR [rip+0x1a15d4],r13        # 5a1e80 <__slm_global>
  4008aa:	1a 00 
  4008ac:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4008af:	84 c0                	test   al,al
  4008b1:	0f 85 04 fe ff ff    	jne    4006bb <slm_idle_comp_initialization+0x18b>
  4008b7:	eb cf                	jmp    400888 <slm_idle_comp_initialization+0x358>
			prio    = curr->priority;
  4008b9:	4d 8b 55 30          	mov    r10,QWORD PTR [r13+0x30]
			timeout = TCAP_TIME_NIL;
  4008bd:	31 c9                	xor    ecx,ecx
  4008bf:	e9 66 ff ff ff       	jmp    40082a <slm_idle_comp_initialization+0x2fa>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  4008c4:	49 8b 55 30          	mov    rdx,QWORD PTR [r13+0x30]
  4008c8:	4c 8b 05 d9 15 1a 00 	mov    r8,QWORD PTR [rip+0x1a15d9]        # 5a1ea8 <__slm_global+0x28>
  4008cf:	45 89 e1             	mov    r9d,r12d
  4008d2:	31 c9                	xor    ecx,ecx
  4008d4:	48 8b 3d bd 15 1a 00 	mov    rdi,QWORD PTR [rip+0x1a15bd]        # 5a1e98 <__slm_global+0x18>
  4008db:	31 f6                	xor    esi,esi
  4008dd:	e8 3e 0a 01 00       	call   411320 <cos_switch>
  4008e2:	e9 70 ff ff ff       	jmp    400857 <slm_idle_comp_initialization+0x327>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  4008e7:	48 8b 7b 28          	mov    rdi,QWORD PTR [rbx+0x28]
  4008eb:	48 8b 15 b6 15 1a 00 	mov    rdx,QWORD PTR [rip+0x1a15b6]        # 5a1ea8 <__slm_global+0x28>
  4008f2:	44 89 e1             	mov    ecx,r12d
  4008f5:	e8 96 0a 01 00       	call   411390 <cos_sched_asnd>
  4008fa:	e9 58 ff ff ff       	jmp    400857 <slm_idle_comp_initialization+0x327>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  4008ff:	41 89 f0             	mov    r8d,esi
  400902:	4c 89 ea             	mov    rdx,r13
  400905:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  40090a:	41 83 e0 01          	and    r8d,0x1
  40090e:	e8 fd 2e 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  400913:	83 f8 f0             	cmp    eax,0xfffffff0
  400916:	0f 85 6c ff ff ff    	jne    400888 <slm_idle_comp_initialization+0x358>
  40091c:	e9 6f fe ff ff       	jmp    400790 <slm_idle_comp_initialization+0x260>
  400921:	be 61 00 00 00       	mov    esi,0x61
  400926:	bf b0 b5 41 00       	mov    edi,0x41b5b0
  40092b:	e8 a0 97 00 00       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  400930:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400937:	00 00 00 00 
  40093b:	0f 0b                	ud2    
  40093d:	be 61 00 00 00       	mov    esi,0x61
  400942:	bf 48 b5 41 00       	mov    edi,0x41b548
  400947:	e8 84 97 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  40094c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400953:	00 00 00 00 
  400957:	0f 0b                	ud2    
  400959:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000400960 <printc.constprop.0>:
printc(char *fmt, ...)
  400960:	55                   	push   rbp
  400961:	48 89 e5             	mov    rbp,rsp
  400964:	48 81 ec 90 01 00 00 	sub    rsp,0x190
  40096b:	48 89 b5 58 ff ff ff 	mov    QWORD PTR [rbp-0xa8],rsi
  400972:	48 89 95 60 ff ff ff 	mov    QWORD PTR [rbp-0xa0],rdx
  400979:	48 89 8d 68 ff ff ff 	mov    QWORD PTR [rbp-0x98],rcx
  400980:	4c 89 85 70 ff ff ff 	mov    QWORD PTR [rbp-0x90],r8
  400987:	4c 89 8d 78 ff ff ff 	mov    QWORD PTR [rbp-0x88],r9
  40098e:	84 c0                	test   al,al
  400990:	74 20                	je     4009b2 <printc.constprop.0+0x52>
  400992:	0f 29 45 80          	movaps XMMWORD PTR [rbp-0x80],xmm0
  400996:	0f 29 4d 90          	movaps XMMWORD PTR [rbp-0x70],xmm1
  40099a:	0f 29 55 a0          	movaps XMMWORD PTR [rbp-0x60],xmm2
  40099e:	0f 29 5d b0          	movaps XMMWORD PTR [rbp-0x50],xmm3
  4009a2:	0f 29 65 c0          	movaps XMMWORD PTR [rbp-0x40],xmm4
  4009a6:	0f 29 6d d0          	movaps XMMWORD PTR [rbp-0x30],xmm5
  4009aa:	0f 29 75 e0          	movaps XMMWORD PTR [rbp-0x20],xmm6
  4009ae:	0f 29 7d f0          	movaps XMMWORD PTR [rbp-0x10],xmm7
	va_start(arg_ptr, fmt);
  4009b2:	48 8d 45 10          	lea    rax,[rbp+0x10]
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  4009b6:	ba 20 b6 41 00       	mov    edx,0x41b620
  4009bb:	be b4 00 00 00       	mov    esi,0xb4
	va_start(arg_ptr, fmt);
  4009c0:	c7 85 78 fe ff ff 08 	mov    DWORD PTR [rbp-0x188],0x8
  4009c7:	00 00 00 
  4009ca:	48 89 85 80 fe ff ff 	mov    QWORD PTR [rbp-0x180],rax
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  4009d1:	48 8d 8d 78 fe ff ff 	lea    rcx,[rbp-0x188]
	va_start(arg_ptr, fmt);
  4009d8:	48 8d 85 50 ff ff ff 	lea    rax,[rbp-0xb0]
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  4009df:	48 8d bd 90 fe ff ff 	lea    rdi,[rbp-0x170]
	va_start(arg_ptr, fmt);
  4009e6:	48 89 85 88 fe ff ff 	mov    QWORD PTR [rbp-0x178],rax
  4009ed:	c7 85 7c fe ff ff 30 	mov    DWORD PTR [rbp-0x184],0x30
  4009f4:	00 00 00 
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  4009f7:	e8 a4 49 01 00       	call   4153a0 <vsnprintf>
	ret = cos_print_str(s, ret);
  4009fc:	48 8d bd 90 fe ff ff 	lea    rdi,[rbp-0x170]
  400a03:	be 1b 00 00 00       	mov    esi,0x1b
  400a08:	e8 c3 96 00 00       	call   40a0d0 <cos_print_str>
}
  400a0d:	c9                   	leave  
  400a0e:	c3                   	ret    
  400a0f:	90                   	nop

0000000000400a10 <slm_ipi_process>:
	goto done;
}

void
slm_ipi_process(void *d)
{
  400a10:	f3 0f 1e fa          	endbr64 
  400a14:	55                   	push   rbp
	int rcvd, ret;
	struct slm_ipi_percore *ipi_data = slm_ipi_percore_get(cos_cpuid());
  400a15:	31 ff                	xor    edi,edi
{
  400a17:	48 89 e5             	mov    rbp,rsp
  400a1a:	41 55                	push   r13
  400a1c:	41 54                	push   r12
  400a1e:	53                   	push   rbx
  400a1f:	48 83 ec 18          	sub    rsp,0x18
	struct slm_ipi_percore *ipi_data = slm_ipi_percore_get(cos_cpuid());
  400a23:	e8 88 2c 01 00       	call   4136b0 <slm_ipi_percore_get>
	struct slm_ipi_thd     *r        = &ipi_data->ipi_thd;
	struct slm_ipi_event    event    = { 0 };
  400a28:	48 c7 45 d8 00 00 00 	mov    QWORD PTR [rbp-0x28],0x0
  400a2f:	00 
	struct slm_ipi_percore *ipi_data = slm_ipi_percore_get(cos_cpuid());
  400a30:	49 89 c4             	mov    r12,rax
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  400a33:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  400a36:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  400a3c:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  400a43:	48 85 c0             	test   rax,rax
  400a46:	0f 84 c0 01 00 00    	je     400c0c <slm_ipi_process+0x1fc>
  400a4c:	83 e8 01             	sub    eax,0x1
  400a4f:	83 f8 18             	cmp    eax,0x18
  400a52:	0f 87 b4 01 00 00    	ja     400c0c <slm_ipi_process+0x1fc>
  400a58:	48 8b 14 c5 c0 e6 45 	mov    rdx,QWORD PTR [rax*8+0x45e6c0]
  400a5f:	00 
  400a60:	31 db                	xor    ebx,ebx
}

static inline int
ss_state_is_allocated(ss_state_t state)
{
	return ((state & ~1) != 0) && ((state & 1) == SS_STATE_ALLOC);
  400a62:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  400a69:	0f 85 65 01 00 00    	jne    400bd4 <slm_ipi_process+0x1c4>
  400a6f:	90                   	nop
	struct slm_thd         *current  = slm_thd_current();
	struct slm_thd         *thd;

	while (1) {
		cos_rcv(r->rcv, RCV_ALL_PENDING, &rcvd);
  400a70:	49 8b 3c 24          	mov    rdi,QWORD PTR [r12]
  400a74:	48 8d 55 d4          	lea    rdx,[rbp-0x2c]
  400a78:	be 02 00 00 00       	mov    esi,0x2
  400a7d:	e8 7e 0a 01 00       	call   411500 <cos_rcv>

		while (!slm_ipi_event_empty(cos_cpuid())) {
  400a82:	31 ff                	xor    edi,edi
  400a84:	e8 f7 2b 01 00       	call   413680 <slm_ipi_event_empty>
  400a89:	85 c0                	test   eax,eax
  400a8b:	75 e3                	jne    400a70 <slm_ipi_process+0x60>
			slm_ipi_event_dequeue(&event, cos_cpuid());
  400a8d:	31 f6                	xor    esi,esi
  400a8f:	48 8d 7d d8          	lea    rdi,[rbp-0x28]
  400a93:	e8 88 2b 01 00       	call   413620 <slm_ipi_event_dequeue>
	return &ss_thd_get(id)->thd;
  400a98:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  400a9c:	85 c0                	test   eax,eax
  400a9e:	0f 84 cc 00 00 00    	je     400b70 <slm_ipi_process+0x160>
  400aa4:	83 e8 01             	sub    eax,0x1
  400aa7:	83 f8 18             	cmp    eax,0x18
  400aaa:	0f 87 c0 00 00 00    	ja     400b70 <slm_ipi_process+0x160>
  400ab0:	48 8b 14 c5 c0 e6 45 	mov    rdx,QWORD PTR [rax*8+0x45e6c0]
  400ab7:	00 
  400ab8:	45 31 ed             	xor    r13d,r13d
  400abb:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  400ac2:	74 18                	je     400adc <slm_ipi_process+0xcc>
  400ac4:	83 e2 01             	and    edx,0x1
  400ac7:	75 13                	jne    400adc <slm_ipi_process+0xcc>
  400ac9:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  400acd:	4c 8d 2c 50          	lea    r13,[rax+rdx*2]
  400ad1:	49 c1 e5 04          	shl    r13,0x4
  400ad5:	49 81 c5 88 e7 45 00 	add    r13,0x45e788
	assert(current);
  400adc:	48 85 db             	test   rbx,rbx
  400adf:	0f 84 97 00 00 00    	je     400b7c <slm_ipi_process+0x16c>
		tok    = cos_sched_sync();
  400ae5:	e8 16 08 01 00       	call   411300 <cos_sched_sync>
  400aea:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  400aed:	48 8b 05 8c 13 1a 00 	mov    rax,QWORD PTR [rip+0x1a138c]        # 5a1e80 <__slm_global>
		if (unlikely(owner)) {
  400af4:	48 89 c1             	mov    rcx,rax
  400af7:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  400afb:	0f 85 97 00 00 00    	jne    400b98 <slm_ipi_process+0x188>
  400b01:	f0 48 0f b1 1d 76 13 	lock cmpxchg QWORD PTR [rip+0x1a1376],rbx        # 5a1e80 <__slm_global>
  400b08:	1a 00 
  400b0a:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  400b0d:	84 c0                	test   al,al
  400b0f:	74 d4                	je     400ae5 <slm_ipi_process+0xd5>

			thd = slm_thd_static_cm_lookup(event.tid);
			slm_cs_enter(current, SLM_CS_NONE);
			ret = slm_thd_wakeup(thd, 0);
  400b11:	31 f6                	xor    esi,esi
  400b13:	4c 89 ef             	mov    rdi,r13
  400b16:	e8 15 33 01 00       	call   413e30 <slm_thd_wakeup>
			/*
			 * Return "0" means the thread is woken up in this call.
			 * Return "1" means the thread is already `RUNNABLE`.
			 */
			assert(ret == 0 || ret == 1);
  400b1b:	83 f8 01             	cmp    eax,0x1
  400b1e:	76 1c                	jbe    400b3c <slm_ipi_process+0x12c>
  400b20:	e9 cb 00 00 00       	jmp    400bf0 <slm_ipi_process+0x1e0>
  400b25:	0f 1f 00             	nop    DWORD PTR [rax]
  400b28:	f0 48 0f b1 15 4f 13 	lock cmpxchg QWORD PTR [rip+0x1a134f],rdx        # 5a1e80 <__slm_global>
  400b2f:	1a 00 
  400b31:	0f 94 c0             	sete   al
	while (ret != 0) {
  400b34:	84 c0                	test   al,al
  400b36:	0f 85 46 ff ff ff    	jne    400a82 <slm_ipi_process+0x72>
		tok    = cos_sched_sync();
  400b3c:	e8 bf 07 01 00       	call   411300 <cos_sched_sync>
  400b41:	89 c1                	mov    ecx,eax
  400b43:	48 8b 05 36 13 1a 00 	mov    rax,QWORD PTR [rip+0x1a1336]        # 5a1e80 <__slm_global>
		if (unlikely(contention)) {
  400b4a:	48 89 c2             	mov    rdx,rax
  400b4d:	83 e2 01             	and    edx,0x1
  400b50:	74 d6                	je     400b28 <slm_ipi_process+0x118>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  400b52:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  400b55:	48 89 c2             	mov    rdx,rax
  400b58:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  400b5d:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  400b61:	e8 fa 2c 01 00       	call   413860 <slm_cs_exit_contention>
  400b66:	85 c0                	test   eax,eax
  400b68:	0f 84 14 ff ff ff    	je     400a82 <slm_ipi_process+0x72>
  400b6e:	eb cc                	jmp    400b3c <slm_ipi_process+0x12c>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  400b70:	45 31 ed             	xor    r13d,r13d
	assert(current);
  400b73:	48 85 db             	test   rbx,rbx
  400b76:	0f 85 69 ff ff ff    	jne    400ae5 <slm_ipi_process+0xd5>
	return cos_print_str(s, strlen(s));
  400b7c:	be 59 00 00 00       	mov    esi,0x59
  400b81:	bf 40 b6 41 00       	mov    edi,0x41b640
  400b86:	e8 45 95 00 00       	call   40a0d0 <cos_print_str>
  400b8b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400b92:	00 00 00 00 
  400b96:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  400b98:	41 89 c0             	mov    r8d,eax
  400b9b:	48 89 da             	mov    rdx,rbx
  400b9e:	48 89 c6             	mov    rsi,rax
  400ba1:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  400ba6:	41 83 e0 01          	and    r8d,0x1
  400baa:	e8 61 2c 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  400baf:	83 f8 f0             	cmp    eax,0xfffffff0
  400bb2:	0f 85 2d ff ff ff    	jne    400ae5 <slm_ipi_process+0xd5>
  400bb8:	be 59 00 00 00       	mov    esi,0x59
  400bbd:	bf a0 b6 41 00       	mov    edi,0x41b6a0
  400bc2:	e8 09 95 00 00       	call   40a0d0 <cos_print_str>
  400bc7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400bce:	00 00 00 00 
  400bd2:	0f 0b                	ud2    
  400bd4:	80 e2 01             	and    dl,0x1
  400bd7:	0f 85 93 fe ff ff    	jne    400a70 <slm_ipi_process+0x60>
  400bdd:	48 69 c0 b0 00 00 00 	imul   rax,rax,0xb0
  400be4:	48 8d 98 88 e7 45 00 	lea    rbx,[rax+0x45e788]
  400beb:	e9 80 fe ff ff       	jmp    400a70 <slm_ipi_process+0x60>
  400bf0:	be 24 00 00 00       	mov    esi,0x24
  400bf5:	bf 00 b7 41 00       	mov    edi,0x41b700
  400bfa:	e8 d1 94 00 00       	call   40a0d0 <cos_print_str>
			assert(ret == 0 || ret == 1);
  400bff:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400c06:	00 00 00 00 
  400c0a:	0f 0b                	ud2    
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  400c0c:	31 db                	xor    ebx,ebx
  400c0e:	e9 5d fe ff ff       	jmp    400a70 <slm_ipi_process+0x60>
  400c13:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  400c1a:	00 00 00 00 
  400c1e:	66 90                	xchg   ax,ax

0000000000400c20 <slm_blkpt_alloc>:
	return &__blkpts[id-1];
}

sched_blkpt_id_t
slm_blkpt_alloc(struct slm_thd *current)
{
  400c20:	f3 0f 1e fa          	endbr64 
  400c24:	55                   	push   rbp
  400c25:	48 89 e5             	mov    rbp,rsp
  400c28:	41 54                	push   r12
  400c2a:	49 89 fc             	mov    r12,rdi
  400c2d:	48 83 ec 08          	sub    rsp,0x8
	assert(current);
  400c31:	48 85 ff             	test   rdi,rdi
  400c34:	0f 84 12 01 00 00    	je     400d4c <slm_blkpt_alloc+0x12c>
		tok    = cos_sched_sync();
  400c3a:	e8 c1 06 01 00       	call   411300 <cos_sched_sync>
  400c3f:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  400c42:	48 8b 05 37 12 1a 00 	mov    rax,QWORD PTR [rip+0x1a1237]        # 5a1e80 <__slm_global>
		if (unlikely(owner)) {
  400c49:	48 89 c1             	mov    rcx,rax
  400c4c:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  400c50:	0f 85 ba 00 00 00    	jne    400d10 <slm_blkpt_alloc+0xf0>
  400c56:	f0 4c 0f b1 25 21 12 	lock cmpxchg QWORD PTR [rip+0x1a1221],r12        # 5a1e80 <__slm_global>
  400c5d:	1a 00 
  400c5f:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  400c62:	84 c0                	test   al,al
  400c64:	74 d4                	je     400c3a <slm_blkpt_alloc+0x1a>
	struct blkpt_mem *m;
	sched_blkpt_id_t ret = SCHED_BLKPT_NULL;

	slm_cs_enter(current, SLM_CS_NONE);

	id = (sched_blkpt_id_t)__blkpt_offset;
  400c66:	44 8b 25 93 33 02 00 	mov    r12d,DWORD PTR [rip+0x23393]        # 424000 <__blkpt_offset>
	if (id - 1 == NBLKPTS) return NULL;
  400c6d:	41 81 fc 01 a0 00 00 	cmp    r12d,0xa001
  400c74:	0f 84 ee 00 00 00    	je     400d68 <slm_blkpt_alloc+0x148>
	return &__blkpts[id-1];
  400c7a:	41 8d 44 24 ff       	lea    eax,[r12-0x1]
  400c7f:	48 c1 e0 05          	shl    rax,0x5
	m  = blkpt_get(id);
	if (!m) ERR_THROW(SCHED_BLKPT_NULL, unlock);

	m->id    = id;
  400c83:	44 89 a0 c0 f8 45 00 	mov    DWORD PTR [rax+0x45f8c0],r12d
	ret      = id;
	m->epoch = 0;
  400c8a:	48 c7 80 c8 f8 45 00 	mov    QWORD PTR [rax+0x45f8c8],0x0
  400c91:	00 00 00 00 
};

static inline void
stacklist_init(struct stacklist_head *h)
{
	h->head = NULL;
  400c95:	48 c7 80 d0 f8 45 00 	mov    QWORD PTR [rax+0x45f8d0],0x0
  400c9c:	00 00 00 00 
ps_lock_release(struct ps_lock *l)
{ l->o = 0; }

static inline void
ps_lock_init(struct ps_lock *l)
{ l->o = 0; }
  400ca0:	48 c7 80 d8 f8 45 00 	mov    QWORD PTR [rax+0x45f8d8],0x0
  400ca7:	00 00 00 00 
	stacklist_init(&m->blocked);
	ps_lock_init(&m->lock);
	__blkpt_offset++;
  400cab:	41 8d 44 24 01       	lea    eax,[r12+0x1]
  400cb0:	89 05 4a 33 02 00    	mov    DWORD PTR [rip+0x2334a],eax        # 424000 <__blkpt_offset>
  400cb6:	eb 18                	jmp    400cd0 <slm_blkpt_alloc+0xb0>
  400cb8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  400cbf:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  400cc0:	f0 48 0f b1 15 b7 11 	lock cmpxchg QWORD PTR [rip+0x1a11b7],rdx        # 5a1e80 <__slm_global>
  400cc7:	1a 00 
  400cc9:	0f 94 c0             	sete   al
	while (ret != 0) {
  400ccc:	84 c0                	test   al,al
  400cce:	75 2e                	jne    400cfe <slm_blkpt_alloc+0xde>
		tok    = cos_sched_sync();
  400cd0:	e8 2b 06 01 00       	call   411300 <cos_sched_sync>
  400cd5:	89 c1                	mov    ecx,eax
  400cd7:	48 8b 05 a2 11 1a 00 	mov    rax,QWORD PTR [rip+0x1a11a2]        # 5a1e80 <__slm_global>
		if (unlikely(contention)) {
  400cde:	48 89 c2             	mov    rdx,rax
  400ce1:	83 e2 01             	and    edx,0x1
  400ce4:	74 da                	je     400cc0 <slm_blkpt_alloc+0xa0>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  400ce6:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  400ce9:	48 89 c2             	mov    rdx,rax
  400cec:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  400cf1:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  400cf5:	e8 66 2b 01 00       	call   413860 <slm_cs_exit_contention>
  400cfa:	85 c0                	test   eax,eax
  400cfc:	75 d2                	jne    400cd0 <slm_blkpt_alloc+0xb0>
unlock:
	slm_cs_exit(NULL, SLM_CS_NONE);

	return ret;
}
  400cfe:	44 89 e0             	mov    eax,r12d
  400d01:	4c 8b 65 f8          	mov    r12,QWORD PTR [rbp-0x8]
  400d05:	c9                   	leave  
  400d06:	c3                   	ret    
  400d07:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  400d0e:	00 00 
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  400d10:	41 89 c0             	mov    r8d,eax
  400d13:	4c 89 e2             	mov    rdx,r12
  400d16:	48 89 c6             	mov    rsi,rax
  400d19:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  400d1e:	41 83 e0 01          	and    r8d,0x1
  400d22:	e8 e9 2a 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  400d27:	83 f8 f0             	cmp    eax,0xfffffff0
  400d2a:	0f 85 0a ff ff ff    	jne    400c3a <slm_blkpt_alloc+0x1a>
  400d30:	be 59 00 00 00       	mov    esi,0x59
  400d35:	bf a0 b6 41 00       	mov    edi,0x41b6a0
  400d3a:	e8 91 93 00 00       	call   40a0d0 <cos_print_str>
  400d3f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400d46:	00 00 00 00 
  400d4a:	0f 0b                	ud2    
  400d4c:	be 59 00 00 00       	mov    esi,0x59
  400d51:	bf 40 b6 41 00       	mov    edi,0x41b640
  400d56:	e8 75 93 00 00       	call   40a0d0 <cos_print_str>
	assert(current);
  400d5b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400d62:	00 00 00 00 
  400d66:	0f 0b                	ud2    
	if (!m) ERR_THROW(SCHED_BLKPT_NULL, unlock);
  400d68:	45 31 e4             	xor    r12d,r12d
	while (ret != 0) {
  400d6b:	e9 60 ff ff ff       	jmp    400cd0 <slm_blkpt_alloc+0xb0>

0000000000400d70 <slm_blkpt_free>:

int
slm_blkpt_free(sched_blkpt_id_t id)
{
  400d70:	f3 0f 1e fa          	endbr64 
	/* alloc only for now */
	return 0;
}
  400d74:	31 c0                	xor    eax,eax
  400d76:	c3                   	ret    
  400d77:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  400d7e:	00 00 

0000000000400d80 <slm_blkpt_trigger>:

int
slm_blkpt_trigger(sched_blkpt_id_t blkpt, struct slm_thd *current, sched_blkpt_epoch_t epoch, int single)
{
  400d80:	f3 0f 1e fa          	endbr64 
  400d84:	55                   	push   rbp
  400d85:	48 89 e5             	mov    rbp,rsp
  400d88:	41 57                	push   r15
  400d8a:	41 56                	push   r14
  400d8c:	41 89 fe             	mov    r14d,edi
  400d8f:	41 55                	push   r13
  400d91:	49 89 d5             	mov    r13,rdx
  400d94:	41 54                	push   r12
  400d96:	41 89 cc             	mov    r12d,ecx
  400d99:	53                   	push   rbx
  400d9a:	48 89 f3             	mov    rbx,rsi
  400d9d:	48 83 ec 08          	sub    rsp,0x8
	assert(current);
  400da1:	48 85 f6             	test   rsi,rsi
  400da4:	0f 84 5a 02 00 00    	je     401004 <slm_blkpt_trigger+0x284>
		tok    = cos_sched_sync();
  400daa:	e8 51 05 01 00       	call   411300 <cos_sched_sync>
  400daf:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  400db2:	48 8b 05 c7 10 1a 00 	mov    rax,QWORD PTR [rip+0x1a10c7]        # 5a1e80 <__slm_global>
		if (unlikely(owner)) {
  400db9:	48 89 c1             	mov    rcx,rax
  400dbc:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  400dc0:	0f 85 02 02 00 00    	jne    400fc8 <slm_blkpt_trigger+0x248>
  400dc6:	f0 48 0f b1 1d b1 10 	lock cmpxchg QWORD PTR [rip+0x1a10b1],rbx        # 5a1e80 <__slm_global>
  400dcd:	1a 00 
  400dcf:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  400dd2:	84 c0                	test   al,al
  400dd4:	74 d4                	je     400daa <slm_blkpt_trigger+0x2a>
	if (id - 1 == NBLKPTS) return NULL;
  400dd6:	41 81 fe 01 a0 00 00 	cmp    r14d,0xa001
  400ddd:	0f 84 3d 02 00 00    	je     401020 <slm_blkpt_trigger+0x2a0>
	return &__blkpts[id-1];
  400de3:	41 8d 7e ff          	lea    edi,[r14-0x1]
  400de7:	be 01 00 00 00       	mov    esi,0x1
  400dec:	31 c9                	xor    ecx,ecx
  400dee:	49 89 fe             	mov    r14,rdi
  400df1:	49 c1 e6 05          	shl    r14,0x5
  400df5:	4d 8d be c0 f8 45 00 	lea    r15,[r14+0x45f8c0]
{ while (!ps_cas(&l->o, 0, 1)) ; }
  400dfc:	49 8d 96 d8 f8 45 00 	lea    rdx,[r14+0x45f8d8]
  400e03:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  400e08:	48 89 c8             	mov    rax,rcx
  400e0b:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  400e10:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  400e13:	84 c0                	test   al,al
  400e15:	74 f1                	je     400e08 <slm_blkpt_trigger+0x88>

		if (!blkpt_epoch_is_higher(pre, epoch)) {
			ps_lock_release(&m->lock);
			ERR_THROW(0, unlock); 
		}
		if (ps_cas(&m->epoch, pre, epoch)) break;
  400e17:	49 8d 96 c8 f8 45 00 	lea    rdx,[r14+0x45f8c8]
  400e1e:	eb 0c                	jmp    400e2c <slm_blkpt_trigger+0xac>
        __asm__ __volatile__("lock " PS_CAS_STR
  400e20:	f0 4c 0f b1 2a       	lock cmpxchg QWORD PTR [rdx],r13
  400e25:	0f 94 c0             	sete   al
  400e28:	84 c0                	test   al,al
  400e2a:	75 74                	jne    400ea0 <slm_blkpt_trigger+0x120>
		sched_blkpt_epoch_t pre = ps_load(&m->epoch);
  400e2c:	49 8b 47 08          	mov    rax,QWORD PTR [r15+0x8]
		if (!blkpt_epoch_is_higher(pre, epoch)) {
  400e30:	4c 39 e8             	cmp    rax,r13
  400e33:	76 eb                	jbe    400e20 <slm_blkpt_trigger+0xa0>
{ l->o = 0; }
  400e35:	49 c7 47 18 00 00 00 	mov    QWORD PTR [r15+0x18],0x0
  400e3c:	00 
			ERR_THROW(0, unlock); 
  400e3d:	45 31 e4             	xor    r12d,r12d
  400e40:	eb 16                	jmp    400e58 <slm_blkpt_trigger+0xd8>
  400e42:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  400e48:	f0 48 0f b1 15 2f 10 	lock cmpxchg QWORD PTR [rip+0x1a102f],rdx        # 5a1e80 <__slm_global>
  400e4f:	1a 00 
  400e51:	0f 94 c0             	sete   al
	while (ret != 0) {
  400e54:	84 c0                	test   al,al
  400e56:	75 2e                	jne    400e86 <slm_blkpt_trigger+0x106>
		tok    = cos_sched_sync();
  400e58:	e8 a3 04 01 00       	call   411300 <cos_sched_sync>
  400e5d:	89 c1                	mov    ecx,eax
  400e5f:	48 8b 05 1a 10 1a 00 	mov    rax,QWORD PTR [rip+0x1a101a]        # 5a1e80 <__slm_global>
		if (unlikely(contention)) {
  400e66:	48 89 c2             	mov    rdx,rax
  400e69:	83 e2 01             	and    edx,0x1
  400e6c:	74 da                	je     400e48 <slm_blkpt_trigger+0xc8>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  400e6e:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  400e71:	48 89 c2             	mov    rdx,rax
  400e74:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  400e79:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  400e7d:	e8 de 29 01 00       	call   413860 <slm_cs_exit_contention>
  400e82:	85 c0                	test   eax,eax
  400e84:	75 d2                	jne    400e58 <slm_blkpt_trigger+0xd8>
	return 0;
unlock:
	slm_cs_exit(NULL, SLM_CS_NONE);

	return ret;
}
  400e86:	48 83 c4 08          	add    rsp,0x8
  400e8a:	44 89 e0             	mov    eax,r12d
  400e8d:	5b                   	pop    rbx
  400e8e:	41 5c                	pop    r12
  400e90:	41 5d                	pop    r13
  400e92:	41 5e                	pop    r14
  400e94:	41 5f                	pop    r15
  400e96:	5d                   	pop    rbp
  400e97:	c3                   	ret    
  400e98:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  400e9f:	00 
	 * threads, but we'll implement this conservatively. Given
	 * this, please note that this should *not* iterate more than
	 * once.
	 */
	while (1) {
		sl = ps_load(&h->head);
  400ea0:	48 c1 e7 05          	shl    rdi,0x5
		/*
		 * Check sl again in case other thread updating the head,
		 * which might causes dereferencing a NULL pointer.
		 */
		if (!sl) return NULL;
		if (ps_cas((unsigned long *)&h->head, (unsigned long)sl, (unsigned long)sl->next)) break;
  400ea4:	49 81 c6 d0 f8 45 00 	add    r14,0x45f8d0
		sl = ps_load(&h->head);
  400eab:	49 89 fd             	mov    r13,rdi
  400eae:	66 90                	xchg   ax,ax
	if (!h->head) return NULL;
  400eb0:	49 83 7f 10 00       	cmp    QWORD PTR [r15+0x10],0x0
  400eb5:	74 28                	je     400edf <slm_blkpt_trigger+0x15f>
		sl = ps_load(&h->head);
  400eb7:	49 8d b5 c0 f8 45 00 	lea    rsi,[r13+0x45f8c0]
  400ebe:	eb 16                	jmp    400ed6 <slm_blkpt_trigger+0x156>
  400ec0:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
  400ec3:	48 89 d0             	mov    rax,rdx
  400ec6:	f0 49 0f b1 0e       	lock cmpxchg QWORD PTR [r14],rcx
  400ecb:	0f 94 c0             	sete   al
		if (ps_cas((unsigned long *)&h->head, (unsigned long)sl, (unsigned long)sl->next)) break;
  400ece:	84 c0                	test   al,al
  400ed0:	0f 85 d2 00 00 00    	jne    400fa8 <slm_blkpt_trigger+0x228>
		sl = ps_load(&h->head);
  400ed6:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
		if (!sl) return NULL;
  400eda:	48 85 d2             	test   rdx,rdx
  400edd:	75 e1                	jne    400ec0 <slm_blkpt_trigger+0x140>
{ l->o = 0; }
  400edf:	49 c7 47 18 00 00 00 	mov    QWORD PTR [r15+0x18],0x0
  400ee6:	00 
	if (unlikely(!t)) t = &g->idle_thd;
  400ee7:	41 bd 00 1f 5a 00    	mov    r13d,0x5a1f00
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  400eed:	e8 6e a9 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	tok  = cos_sched_sync();
  400ef2:	e8 09 04 01 00       	call   411300 <cos_sched_sync>
  400ef7:	41 89 c6             	mov    r14d,eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  400efa:	e8 91 15 01 00       	call   412490 <slm_sched_fprr_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  400eff:	48 85 c0             	test   rax,rax
  400f02:	49 89 c4             	mov    r12,rax
  400f05:	4d 0f 44 e5          	cmove  r12,r13
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  400f09:	41 8b 44 24 04       	mov    eax,DWORD PTR [r12+0x4]
  400f0e:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  400f11:	83 f8 01             	cmp    eax,0x1
  400f14:	76 1a                	jbe    400f30 <slm_blkpt_trigger+0x1b0>
  400f16:	e9 10 01 00 00       	jmp    40102b <slm_blkpt_trigger+0x2ab>
  400f1b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  400f20:	f0 48 0f b1 15 57 0f 	lock cmpxchg QWORD PTR [rip+0x1a0f57],rdx        # 5a1e80 <__slm_global>
  400f27:	1a 00 
  400f29:	0f 94 c0             	sete   al
	while (ret != 0) {
  400f2c:	84 c0                	test   al,al
  400f2e:	75 2e                	jne    400f5e <slm_blkpt_trigger+0x1de>
		tok    = cos_sched_sync();
  400f30:	e8 cb 03 01 00       	call   411300 <cos_sched_sync>
  400f35:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  400f37:	48 8b 05 42 0f 1a 00 	mov    rax,QWORD PTR [rip+0x1a0f42]        # 5a1e80 <__slm_global>
		if (unlikely(contention)) {
  400f3e:	48 89 c2             	mov    rdx,rax
  400f41:	83 e2 01             	and    edx,0x1
  400f44:	74 da                	je     400f20 <slm_blkpt_trigger+0x1a0>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  400f46:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  400f49:	48 89 c2             	mov    rdx,rax
  400f4c:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  400f51:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  400f55:	e8 06 29 01 00       	call   413860 <slm_cs_exit_contention>
  400f5a:	85 c0                	test   eax,eax
  400f5c:	75 d2                	jne    400f30 <slm_blkpt_trigger+0x1b0>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  400f5e:	e8 fd a8 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  400f63:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
	prio = inherit_prio ? curr->priority : t->priority;
  400f67:	49 8b 74 24 30       	mov    rsi,QWORD PTR [r12+0x30]
	timeout = g->timeout_next;
  400f6c:	4c 8b 05 15 10 1a 00 	mov    r8,QWORD PTR [rip+0x1a1015]        # 5a1f88 <__slm_global+0x108>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  400f73:	a8 0b                	test   al,0xb
  400f75:	0f 85 cc 00 00 00    	jne    401047 <slm_blkpt_trigger+0x2c7>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  400f7b:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  400f80:	44 89 f1             	mov    ecx,r14d
  400f83:	4c 89 c2             	mov    rdx,r8
  400f86:	e8 d5 b7 00 00       	call   40c760 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  400f8b:	83 f8 ff             	cmp    eax,0xffffffff
  400f8e:	0f 84 5c 01 00 00    	je     4010f0 <slm_blkpt_trigger+0x370>
	if (unlikely(ret != 0)) {
  400f94:	85 c0                	test   eax,eax
  400f96:	0f 85 fa 00 00 00    	jne    401096 <slm_blkpt_trigger+0x316>
	return 0;
  400f9c:	45 31 e4             	xor    r12d,r12d
  400f9f:	e9 e2 fe ff ff       	jmp    400e86 <slm_blkpt_trigger+0x106>
  400fa4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	}
	sl->next = NULL;
  400fa8:	48 c7 02 00 00 00 00 	mov    QWORD PTR [rdx],0x0
		slm_thd_wakeup(t, 0); /* ignore retval: process next thread */
  400faf:	48 8b 7a 08          	mov    rdi,QWORD PTR [rdx+0x8]
  400fb3:	31 f6                	xor    esi,esi
  400fb5:	e8 76 2e 01 00       	call   413e30 <slm_thd_wakeup>
		if (single) break;
  400fba:	45 85 e4             	test   r12d,r12d
  400fbd:	0f 84 ed fe ff ff    	je     400eb0 <slm_blkpt_trigger+0x130>
  400fc3:	e9 17 ff ff ff       	jmp    400edf <slm_blkpt_trigger+0x15f>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  400fc8:	41 89 c0             	mov    r8d,eax
  400fcb:	48 89 da             	mov    rdx,rbx
  400fce:	48 89 c6             	mov    rsi,rax
  400fd1:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  400fd6:	41 83 e0 01          	and    r8d,0x1
  400fda:	e8 31 28 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  400fdf:	83 f8 f0             	cmp    eax,0xfffffff0
  400fe2:	0f 85 c2 fd ff ff    	jne    400daa <slm_blkpt_trigger+0x2a>
  400fe8:	be 59 00 00 00       	mov    esi,0x59
  400fed:	bf a0 b6 41 00       	mov    edi,0x41b6a0
  400ff2:	e8 d9 90 00 00       	call   40a0d0 <cos_print_str>
  400ff7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400ffe:	00 00 00 00 
  401002:	0f 0b                	ud2    
  401004:	be 59 00 00 00       	mov    esi,0x59
  401009:	bf 40 b6 41 00       	mov    edi,0x41b640
  40100e:	e8 bd 90 00 00       	call   40a0d0 <cos_print_str>
	assert(current);
  401013:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40101a:	00 00 00 00 
  40101e:	0f 0b                	ud2    
	if (!m) ERR_THROW(-1, unlock);
  401020:	41 bc ff ff ff ff    	mov    r12d,0xffffffff
	while (ret != 0) {
  401026:	e9 2d fe ff ff       	jmp    400e58 <slm_blkpt_trigger+0xd8>
  40102b:	be 61 00 00 00       	mov    esi,0x61
  401030:	bf 28 b7 41 00       	mov    edi,0x41b728
  401035:	e8 96 90 00 00       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  40103a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401041:	00 00 00 00 
  401045:	0f 0b                	ud2    
	timeout = g->timeout_next;
  401047:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  40104a:	49 81 fc 88 1e 5a 00 	cmp    r12,0x5a1e88
  401051:	0f 84 c7 00 00 00    	je     40111e <slm_blkpt_trigger+0x39e>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  401057:	a8 02                	test   al,0x2
  401059:	0f 85 ca 00 00 00    	jne    401129 <slm_blkpt_trigger+0x3a9>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  40105f:	49 89 c8             	mov    r8,rcx
  401062:	a8 01                	test   al,0x1
  401064:	0f 84 11 ff ff ff    	je     400f7b <slm_blkpt_trigger+0x1fb>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  40106a:	4d 8b 54 24 08       	mov    r10,QWORD PTR [r12+0x8]
  40106f:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  401074:	48 89 f2             	mov    rdx,rsi
  401077:	45 89 f1             	mov    r9d,r14d
  40107a:	4c 8b 05 27 0e 1a 00 	mov    r8,QWORD PTR [rip+0x1a0e27]        # 5a1ea8 <__slm_global+0x28>
  401081:	4c 89 d6             	mov    rsi,r10
  401084:	e8 97 02 01 00       	call   411320 <cos_switch>
	if (unlikely(ret != 0)) {
  401089:	85 c0                	test   eax,eax
  40108b:	0f 84 0b ff ff ff    	je     400f9c <slm_blkpt_trigger+0x21c>
		assert(ret != -EPERM);
  401091:	83 f8 ff             	cmp    eax,0xffffffff
  401094:	74 6c                	je     401102 <slm_blkpt_trigger+0x382>
		assert(ret != -EINVAL);
  401096:	83 f8 ea             	cmp    eax,0xffffffea
  401099:	0f 84 0d 01 00 00    	je     4011ac <slm_blkpt_trigger+0x42c>
		if (ret == -EBUSY) return ret;
  40109f:	83 f8 f0             	cmp    eax,0xfffffff0
  4010a2:	0f 84 f4 fe ff ff    	je     400f9c <slm_blkpt_trigger+0x21c>
		assert(ret == -EAGAIN);
  4010a8:	83 f8 f5             	cmp    eax,0xfffffff5
  4010ab:	0f 85 df 00 00 00    	jne    401190 <slm_blkpt_trigger+0x410>
		tok    = cos_sched_sync();
  4010b1:	e8 4a 02 01 00       	call   411300 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  4010b6:	48 8b 35 c3 0d 1a 00 	mov    rsi,QWORD PTR [rip+0x1a0dc3]        # 5a1e80 <__slm_global>
  4010bd:	41 89 c1             	mov    r9d,eax
		if (unlikely(owner)) {
  4010c0:	48 89 f1             	mov    rcx,rsi
  4010c3:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  4010c7:	0f 85 9b 00 00 00    	jne    401168 <slm_blkpt_trigger+0x3e8>
  4010cd:	48 89 f0             	mov    rax,rsi
  4010d0:	f0 48 0f b1 1d a7 0d 	lock cmpxchg QWORD PTR [rip+0x1a0da7],rbx        # 5a1e80 <__slm_global>
  4010d7:	1a 00 
  4010d9:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4010dc:	84 c0                	test   al,al
  4010de:	0f 85 0e fe ff ff    	jne    400ef2 <slm_blkpt_trigger+0x172>
  4010e4:	eb cb                	jmp    4010b1 <slm_blkpt_trigger+0x331>
  4010e6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4010ed:	00 00 00 
	return t != &g->idle_thd && t != &g->sched_thd;
  4010f0:	49 81 fc 00 1f 5a 00 	cmp    r12,0x5a1f00
  4010f7:	74 4c                	je     401145 <slm_blkpt_trigger+0x3c5>
  4010f9:	49 81 fc 88 1e 5a 00 	cmp    r12,0x5a1e88
  401100:	74 43                	je     401145 <slm_blkpt_trigger+0x3c5>
  401102:	be 61 00 00 00       	mov    esi,0x61
  401107:	bf 90 b7 41 00       	mov    edi,0x41b790
  40110c:	e8 bf 8f 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EPERM);
  401111:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401118:	00 00 00 00 
  40111c:	0f 0b                	ud2    
			prio    = curr->priority;
  40111e:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
			timeout = TCAP_TIME_NIL;
  401122:	31 c9                	xor    ecx,ecx
  401124:	e9 2e ff ff ff       	jmp    401057 <slm_blkpt_trigger+0x2d7>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  401129:	49 8b 7c 24 28       	mov    rdi,QWORD PTR [r12+0x28]
  40112e:	48 8b 15 73 0d 1a 00 	mov    rdx,QWORD PTR [rip+0x1a0d73]        # 5a1ea8 <__slm_global+0x28>
  401135:	44 89 f1             	mov    ecx,r14d
  401138:	4c 89 c6             	mov    rsi,r8
  40113b:	e8 50 02 01 00       	call   411390 <cos_sched_asnd>
  401140:	e9 44 ff ff ff       	jmp    401089 <slm_blkpt_trigger+0x309>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  401145:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]
  401149:	4c 8b 05 58 0d 1a 00 	mov    r8,QWORD PTR [rip+0x1a0d58]        # 5a1ea8 <__slm_global+0x28>
  401150:	45 89 f1             	mov    r9d,r14d
  401153:	31 c9                	xor    ecx,ecx
  401155:	48 8b 3d 3c 0d 1a 00 	mov    rdi,QWORD PTR [rip+0x1a0d3c]        # 5a1e98 <__slm_global+0x18>
  40115c:	31 f6                	xor    esi,esi
  40115e:	e8 bd 01 01 00       	call   411320 <cos_switch>
  401163:	e9 21 ff ff ff       	jmp    401089 <slm_blkpt_trigger+0x309>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  401168:	41 89 f0             	mov    r8d,esi
  40116b:	48 89 da             	mov    rdx,rbx
  40116e:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  401173:	41 83 e0 01          	and    r8d,0x1
  401177:	e8 94 26 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  40117c:	83 f8 f0             	cmp    eax,0xfffffff0
  40117f:	0f 85 2c ff ff ff    	jne    4010b1 <slm_blkpt_trigger+0x331>
  401185:	e9 5e fe ff ff       	jmp    400fe8 <slm_blkpt_trigger+0x268>
  40118a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  401190:	be 61 00 00 00       	mov    esi,0x61
  401195:	bf 60 b8 41 00       	mov    edi,0x41b860
  40119a:	e8 31 8f 00 00       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  40119f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4011a6:	00 00 00 00 
  4011aa:	0f 0b                	ud2    
  4011ac:	be 61 00 00 00       	mov    esi,0x61
  4011b1:	bf f8 b7 41 00       	mov    edi,0x41b7f8
  4011b6:	e8 15 8f 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  4011bb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4011c2:	00 00 00 00 
  4011c6:	0f 0b                	ud2    
  4011c8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4011cf:	00 

00000000004011d0 <slm_blkpt_block>:

int
slm_blkpt_block(sched_blkpt_id_t blkpt, struct slm_thd *current, sched_blkpt_epoch_t epoch, thdid_t dependency)
{
  4011d0:	f3 0f 1e fa          	endbr64 
  4011d4:	55                   	push   rbp
  4011d5:	48 89 e5             	mov    rbp,rsp
  4011d8:	41 57                	push   r15
  4011da:	41 56                	push   r14
  4011dc:	41 55                	push   r13
  4011de:	41 89 fd             	mov    r13d,edi
  4011e1:	41 54                	push   r12
  4011e3:	49 89 d4             	mov    r12,rdx
  4011e6:	53                   	push   rbx
  4011e7:	48 89 f3             	mov    rbx,rsi
  4011ea:	48 83 ec 18          	sub    rsp,0x18
	assert(current);
  4011ee:	48 85 f6             	test   rsi,rsi
  4011f1:	0f 84 05 02 00 00    	je     4013fc <slm_blkpt_block+0x22c>
		tok    = cos_sched_sync();
  4011f7:	e8 04 01 01 00       	call   411300 <cos_sched_sync>
  4011fc:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4011ff:	48 8b 05 7a 0c 1a 00 	mov    rax,QWORD PTR [rip+0x1a0c7a]        # 5a1e80 <__slm_global>
		if (unlikely(owner)) {
  401206:	48 89 c1             	mov    rcx,rax
  401209:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  40120d:	0f 85 ad 01 00 00    	jne    4013c0 <slm_blkpt_block+0x1f0>
  401213:	f0 48 0f b1 1d 64 0c 	lock cmpxchg QWORD PTR [rip+0x1a0c64],rbx        # 5a1e80 <__slm_global>
  40121a:	1a 00 
  40121c:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  40121f:	84 c0                	test   al,al
  401221:	74 d4                	je     4011f7 <slm_blkpt_block+0x27>
	if (id - 1 == NBLKPTS) return NULL;
  401223:	41 81 fd 01 a0 00 00 	cmp    r13d,0xa001
  40122a:	0f 84 e8 01 00 00    	je     401418 <slm_blkpt_block+0x248>
	return &__blkpts[id-1];
  401230:	45 8d 45 ff          	lea    r8d,[r13-0x1]
  401234:	be 01 00 00 00       	mov    esi,0x1
  401239:	31 c9                	xor    ecx,ecx
  40123b:	4c 89 c7             	mov    rdi,r8
  40123e:	48 c1 e7 05          	shl    rdi,0x5
  401242:	4c 8d af c0 f8 45 00 	lea    r13,[rdi+0x45f8c0]
{ while (!ps_cas(&l->o, 0, 1)) ; }
  401249:	48 8d 97 d8 f8 45 00 	lea    rdx,[rdi+0x45f8d8]
        __asm__ __volatile__("lock " PS_CAS_STR
  401250:	48 89 c8             	mov    rax,rcx
  401253:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  401258:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40125b:	84 c0                	test   al,al
  40125d:	74 f1                	je     401250 <slm_blkpt_block+0x80>
		ERR_THROW(-1, unlock);
	}

	ps_lock_take(&m->lock);
	/* Outdated event? don't block! */
	pre = ps_load(&m->epoch);
  40125f:	49 8b 75 08          	mov    rsi,QWORD PTR [r13+0x8]
	if (!blkpt_epoch_is_higher(pre, epoch)) {
  401263:	4c 39 e6             	cmp    rsi,r12
  401266:	76 68                	jbe    4012d0 <slm_blkpt_block+0x100>
{ l->o = 0; }
  401268:	49 c7 45 18 00 00 00 	mov    QWORD PTR [r13+0x18],0x0
  40126f:	00 
			 */
			assert(_sl == &sl);
		}
		assert(stacklist_is_removed(&sl));
		ps_lock_release(&m->lock);
		ERR_THROW(0, unlock);
  401270:	45 31 e4             	xor    r12d,r12d
  401273:	eb 13                	jmp    401288 <slm_blkpt_block+0xb8>
  401275:	0f 1f 00             	nop    DWORD PTR [rax]
        __asm__ __volatile__("lock " PS_CAS_STR
  401278:	f0 48 0f b1 15 ff 0b 	lock cmpxchg QWORD PTR [rip+0x1a0bff],rdx        # 5a1e80 <__slm_global>
  40127f:	1a 00 
  401281:	0f 94 c0             	sete   al
	while (ret != 0) {
  401284:	84 c0                	test   al,al
  401286:	75 2e                	jne    4012b6 <slm_blkpt_block+0xe6>
		tok    = cos_sched_sync();
  401288:	e8 73 00 01 00       	call   411300 <cos_sched_sync>
  40128d:	89 c1                	mov    ecx,eax
  40128f:	48 8b 05 ea 0b 1a 00 	mov    rax,QWORD PTR [rip+0x1a0bea]        # 5a1e80 <__slm_global>
		if (unlikely(contention)) {
  401296:	48 89 c2             	mov    rdx,rax
  401299:	83 e2 01             	and    edx,0x1
  40129c:	74 da                	je     401278 <slm_blkpt_block+0xa8>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  40129e:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  4012a1:	48 89 c2             	mov    rdx,rax
  4012a4:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  4012a9:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  4012ad:	e8 ae 25 01 00       	call   413860 <slm_cs_exit_contention>
  4012b2:	85 c0                	test   eax,eax
  4012b4:	75 d2                	jne    401288 <slm_blkpt_block+0xb8>
	return 0;
unlock:
	slm_cs_exit(NULL, SLM_CS_NONE);

	return ret;
}
  4012b6:	48 83 c4 18          	add    rsp,0x18
  4012ba:	44 89 e0             	mov    eax,r12d
  4012bd:	5b                   	pop    rbx
  4012be:	41 5c                	pop    r12
  4012c0:	41 5d                	pop    r13
  4012c2:	41 5e                	pop    r14
  4012c4:	41 5f                	pop    r15
  4012c6:	5d                   	pop    rbp
  4012c7:	c3                   	ret    
  4012c8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4012cf:	00 
		struct stacklist *n = ps_load(&h->head);
  4012d0:	4c 89 c1             	mov    rcx,r8
	l->data = data;
  4012d3:	48 89 5d c8          	mov    QWORD PTR [rbp-0x38],rbx
		if (ps_cas((unsigned long *)&h->head, (unsigned long)n, (unsigned long)l)) break;
  4012d7:	48 8d 97 d0 f8 45 00 	lea    rdx,[rdi+0x45f8d0]
  4012de:	48 8d 7d c0          	lea    rdi,[rbp-0x40]
		struct stacklist *n = ps_load(&h->head);
  4012e2:	48 c1 e1 05          	shl    rcx,0x5
  4012e6:	48 81 c1 c0 f8 45 00 	add    rcx,0x45f8c0
  4012ed:	0f 1f 00             	nop    DWORD PTR [rax]
  4012f0:	48 8b 41 10          	mov    rax,QWORD PTR [rcx+0x10]
		l->next = n;
  4012f4:	48 89 45 c0          	mov    QWORD PTR [rbp-0x40],rax
  4012f8:	f0 48 0f b1 3a       	lock cmpxchg QWORD PTR [rdx],rdi
  4012fd:	0f 94 c0             	sete   al
		if (ps_cas((unsigned long *)&h->head, (unsigned long)n, (unsigned long)l)) break;
  401300:	84 c0                	test   al,al
  401302:	74 ec                	je     4012f0 <slm_blkpt_block+0x120>
	if (!blkpt_epoch_is_higher(ps_load(&m->epoch), pre)) {
  401304:	49 8b 45 08          	mov    rax,QWORD PTR [r13+0x8]
  401308:	48 39 f0             	cmp    rax,rsi
  40130b:	0f 86 8f 00 00 00    	jbe    4013a0 <slm_blkpt_block+0x1d0>
	if (!h->head) return NULL;
  401311:	49 83 7d 10 00       	cmp    QWORD PTR [r13+0x10],0x0
  401316:	74 2b                	je     401343 <slm_blkpt_block+0x173>
		sl = ps_load(&h->head);
  401318:	49 c1 e0 05          	shl    r8,0x5
  40131c:	49 81 c0 c0 f8 45 00 	add    r8,0x45f8c0
  401323:	eb 15                	jmp    40133a <slm_blkpt_block+0x16a>
  401325:	0f 1f 00             	nop    DWORD PTR [rax]
  401328:	48 8b 31             	mov    rsi,QWORD PTR [rcx]
  40132b:	48 89 c8             	mov    rax,rcx
  40132e:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  401333:	0f 94 c0             	sete   al
		if (ps_cas((unsigned long *)&h->head, (unsigned long)sl, (unsigned long)sl->next)) break;
  401336:	84 c0                	test   al,al
  401338:	75 36                	jne    401370 <slm_blkpt_block+0x1a0>
		sl = ps_load(&h->head);
  40133a:	49 8b 48 10          	mov    rcx,QWORD PTR [r8+0x10]
		if (!sl) return NULL;
  40133e:	48 85 c9             	test   rcx,rcx
  401341:	75 e5                	jne    401328 <slm_blkpt_block+0x158>
		assert(stacklist_is_removed(&sl));
  401343:	48 83 7d c0 00       	cmp    QWORD PTR [rbp-0x40],0x0
  401348:	0f 84 1a ff ff ff    	je     401268 <slm_blkpt_block+0x98>
  40134e:	be 5f 00 00 00       	mov    esi,0x5f
  401353:	bf 28 b9 41 00       	mov    edi,0x41b928
  401358:	e8 73 8d 00 00       	call   40a0d0 <cos_print_str>
  40135d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401364:	00 00 00 00 
  401368:	0f 0b                	ud2    
  40136a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	sl->next = NULL;
  401370:	48 c7 01 00 00 00 00 	mov    QWORD PTR [rcx],0x0
			assert(_sl == &sl);
  401377:	48 39 f9             	cmp    rcx,rdi
  40137a:	74 c7                	je     401343 <slm_blkpt_block+0x173>
  40137c:	be 5f 00 00 00       	mov    esi,0x5f
  401381:	bf c8 b8 41 00       	mov    edi,0x41b8c8
  401386:	e8 45 8d 00 00       	call   40a0d0 <cos_print_str>
  40138b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401392:	00 00 00 00 
  401396:	0f 0b                	ud2    
  401398:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40139f:	00 
	if (slm_thd_block(current)) {
  4013a0:	48 89 df             	mov    rdi,rbx
  4013a3:	e8 18 25 01 00       	call   4138c0 <slm_thd_block>
{ l->o = 0; }
  4013a8:	49 c7 45 18 00 00 00 	mov    QWORD PTR [r13+0x18],0x0
  4013af:	00 
  4013b0:	41 89 c4             	mov    r12d,eax
  4013b3:	85 c0                	test   eax,eax
  4013b5:	74 6c                	je     401423 <slm_blkpt_block+0x253>
		ERR_THROW(0, unlock);
  4013b7:	45 31 e4             	xor    r12d,r12d
  4013ba:	e9 c9 fe ff ff       	jmp    401288 <slm_blkpt_block+0xb8>
  4013bf:	90                   	nop
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  4013c0:	41 89 c0             	mov    r8d,eax
  4013c3:	48 89 da             	mov    rdx,rbx
  4013c6:	48 89 c6             	mov    rsi,rax
  4013c9:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  4013ce:	41 83 e0 01          	and    r8d,0x1
  4013d2:	e8 39 24 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  4013d7:	83 f8 f0             	cmp    eax,0xfffffff0
  4013da:	0f 85 17 fe ff ff    	jne    4011f7 <slm_blkpt_block+0x27>
  4013e0:	be 59 00 00 00       	mov    esi,0x59
  4013e5:	bf a0 b6 41 00       	mov    edi,0x41b6a0
  4013ea:	e8 e1 8c 00 00       	call   40a0d0 <cos_print_str>
  4013ef:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4013f6:	00 00 00 00 
  4013fa:	0f 0b                	ud2    
  4013fc:	be 59 00 00 00       	mov    esi,0x59
  401401:	bf 40 b6 41 00       	mov    edi,0x41b640
  401406:	e8 c5 8c 00 00       	call   40a0d0 <cos_print_str>
	assert(current);
  40140b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401412:	00 00 00 00 
  401416:	0f 0b                	ud2    
		ERR_THROW(-1, unlock);
  401418:	41 bc ff ff ff ff    	mov    r12d,0xffffffff
	while (ret != 0) {
  40141e:	e9 65 fe ff ff       	jmp    401288 <slm_blkpt_block+0xb8>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  401423:	e8 38 a4 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(!t)) t = &g->idle_thd;
  401428:	41 bf 00 1f 5a 00    	mov    r15d,0x5a1f00
	tok  = cos_sched_sync();
  40142e:	e8 cd fe 00 00       	call   411300 <cos_sched_sync>
  401433:	41 89 c6             	mov    r14d,eax
  401436:	e8 55 10 01 00       	call   412490 <slm_sched_fprr_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  40143b:	48 85 c0             	test   rax,rax
  40143e:	49 89 c5             	mov    r13,rax
  401441:	4d 0f 44 ef          	cmove  r13,r15
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  401445:	41 8b 45 04          	mov    eax,DWORD PTR [r13+0x4]
  401449:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  40144c:	83 f8 01             	cmp    eax,0x1
  40144f:	76 1f                	jbe    401470 <slm_blkpt_block+0x2a0>
  401451:	e9 7a 01 00 00       	jmp    4015d0 <slm_blkpt_block+0x400>
  401456:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40145d:	00 00 00 
        __asm__ __volatile__("lock " PS_CAS_STR
  401460:	f0 48 0f b1 15 17 0a 	lock cmpxchg QWORD PTR [rip+0x1a0a17],rdx        # 5a1e80 <__slm_global>
  401467:	1a 00 
  401469:	0f 94 c0             	sete   al
  40146c:	84 c0                	test   al,al
  40146e:	75 2e                	jne    40149e <slm_blkpt_block+0x2ce>
		tok    = cos_sched_sync();
  401470:	e8 8b fe 00 00       	call   411300 <cos_sched_sync>
  401475:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  401477:	48 8b 05 02 0a 1a 00 	mov    rax,QWORD PTR [rip+0x1a0a02]        # 5a1e80 <__slm_global>
		if (unlikely(contention)) {
  40147e:	48 89 c2             	mov    rdx,rax
  401481:	83 e2 01             	and    edx,0x1
  401484:	74 da                	je     401460 <slm_blkpt_block+0x290>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  401486:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  401489:	48 89 c2             	mov    rdx,rax
  40148c:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  401491:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  401495:	e8 c6 23 01 00       	call   413860 <slm_cs_exit_contention>
  40149a:	85 c0                	test   eax,eax
  40149c:	75 d2                	jne    401470 <slm_blkpt_block+0x2a0>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  40149e:	e8 bd a3 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4014a3:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
	timeout = g->timeout_next;
  4014a7:	4c 8b 05 da 0a 1a 00 	mov    r8,QWORD PTR [rip+0x1a0ada]        # 5a1f88 <__slm_global+0x108>
	prio = inherit_prio ? curr->priority : t->priority;
  4014ae:	49 8b 75 30          	mov    rsi,QWORD PTR [r13+0x30]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4014b2:	a8 0b                	test   al,0xb
  4014b4:	75 79                	jne    40152f <slm_blkpt_block+0x35f>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  4014b6:	49 8b 7d 10          	mov    rdi,QWORD PTR [r13+0x10]
  4014ba:	44 89 f1             	mov    ecx,r14d
  4014bd:	4c 89 c2             	mov    rdx,r8
  4014c0:	e8 9b b2 00 00       	call   40c760 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  4014c5:	83 f8 ff             	cmp    eax,0xffffffff
  4014c8:	74 2f                	je     4014f9 <slm_blkpt_block+0x329>
	if (unlikely(ret != 0)) {
  4014ca:	85 c0                	test   eax,eax
  4014cc:	0f 85 aa 00 00 00    	jne    40157c <slm_blkpt_block+0x3ac>
	assert(stacklist_is_removed(&sl));
  4014d2:	48 83 7d c0 00       	cmp    QWORD PTR [rbp-0x40],0x0
  4014d7:	0f 84 d9 fd ff ff    	je     4012b6 <slm_blkpt_block+0xe6>
  4014dd:	be 5f 00 00 00       	mov    esi,0x5f
  4014e2:	bf 88 b9 41 00       	mov    edi,0x41b988
  4014e7:	e8 e4 8b 00 00       	call   40a0d0 <cos_print_str>
  4014ec:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4014f3:	00 00 00 00 
  4014f7:	0f 0b                	ud2    
	return t != &g->idle_thd && t != &g->sched_thd;
  4014f9:	49 81 fd 88 1e 5a 00 	cmp    r13,0x5a1e88
  401500:	0f 84 0c 01 00 00    	je     401612 <slm_blkpt_block+0x442>
  401506:	49 81 fd 00 1f 5a 00 	cmp    r13,0x5a1f00
  40150d:	0f 84 ff 00 00 00    	je     401612 <slm_blkpt_block+0x442>
  401513:	be 61 00 00 00       	mov    esi,0x61
  401518:	bf 90 b7 41 00       	mov    edi,0x41b790
  40151d:	e8 ae 8b 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EPERM);
  401522:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401529:	00 00 00 00 
  40152d:	0f 0b                	ud2    
	timeout = g->timeout_next;
  40152f:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  401532:	49 81 fd 88 1e 5a 00 	cmp    r13,0x5a1e88
  401539:	0f 84 ad 00 00 00    	je     4015ec <slm_blkpt_block+0x41c>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  40153f:	a8 02                	test   al,0x2
  401541:	0f 85 b0 00 00 00    	jne    4015f7 <slm_blkpt_block+0x427>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  401547:	49 89 c8             	mov    r8,rcx
  40154a:	a8 01                	test   al,0x1
  40154c:	0f 84 64 ff ff ff    	je     4014b6 <slm_blkpt_block+0x2e6>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  401552:	4d 8b 55 08          	mov    r10,QWORD PTR [r13+0x8]
  401556:	49 8b 7d 10          	mov    rdi,QWORD PTR [r13+0x10]
  40155a:	48 89 f2             	mov    rdx,rsi
  40155d:	45 89 f1             	mov    r9d,r14d
  401560:	4c 8b 05 41 09 1a 00 	mov    r8,QWORD PTR [rip+0x1a0941]        # 5a1ea8 <__slm_global+0x28>
  401567:	4c 89 d6             	mov    rsi,r10
  40156a:	e8 b1 fd 00 00       	call   411320 <cos_switch>
	if (unlikely(ret != 0)) {
  40156f:	85 c0                	test   eax,eax
  401571:	0f 84 5b ff ff ff    	je     4014d2 <slm_blkpt_block+0x302>
		assert(ret != -EPERM);
  401577:	83 f8 ff             	cmp    eax,0xffffffff
  40157a:	74 97                	je     401513 <slm_blkpt_block+0x343>
		assert(ret != -EINVAL);
  40157c:	83 f8 ea             	cmp    eax,0xffffffea
  40157f:	0f 84 ee 00 00 00    	je     401673 <slm_blkpt_block+0x4a3>
		if (ret == -EBUSY) return ret;
  401585:	83 f8 f0             	cmp    eax,0xfffffff0
  401588:	0f 84 44 ff ff ff    	je     4014d2 <slm_blkpt_block+0x302>
		assert(ret == -EAGAIN);
  40158e:	83 f8 f5             	cmp    eax,0xfffffff5
  401591:	0f 85 c0 00 00 00    	jne    401657 <slm_blkpt_block+0x487>
		tok    = cos_sched_sync();
  401597:	e8 64 fd 00 00       	call   411300 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  40159c:	48 8b 35 dd 08 1a 00 	mov    rsi,QWORD PTR [rip+0x1a08dd]        # 5a1e80 <__slm_global>
  4015a3:	41 89 c1             	mov    r9d,eax
		if (unlikely(owner)) {
  4015a6:	48 89 f1             	mov    rcx,rsi
  4015a9:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  4015ad:	0f 85 82 00 00 00    	jne    401635 <slm_blkpt_block+0x465>
  4015b3:	48 89 f0             	mov    rax,rsi
  4015b6:	f0 48 0f b1 1d c1 08 	lock cmpxchg QWORD PTR [rip+0x1a08c1],rbx        # 5a1e80 <__slm_global>
  4015bd:	1a 00 
  4015bf:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4015c2:	84 c0                	test   al,al
  4015c4:	0f 85 64 fe ff ff    	jne    40142e <slm_blkpt_block+0x25e>
  4015ca:	eb cb                	jmp    401597 <slm_blkpt_block+0x3c7>
  4015cc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  4015d0:	be 61 00 00 00       	mov    esi,0x61
  4015d5:	bf 28 b7 41 00       	mov    edi,0x41b728
  4015da:	e8 f1 8a 00 00       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  4015df:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4015e6:	00 00 00 00 
  4015ea:	0f 0b                	ud2    
			prio    = curr->priority;
  4015ec:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
			timeout = TCAP_TIME_NIL;
  4015f0:	31 c9                	xor    ecx,ecx
  4015f2:	e9 48 ff ff ff       	jmp    40153f <slm_blkpt_block+0x36f>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  4015f7:	49 8b 7d 28          	mov    rdi,QWORD PTR [r13+0x28]
  4015fb:	48 8b 15 a6 08 1a 00 	mov    rdx,QWORD PTR [rip+0x1a08a6]        # 5a1ea8 <__slm_global+0x28>
  401602:	44 89 f1             	mov    ecx,r14d
  401605:	4c 89 c6             	mov    rsi,r8
  401608:	e8 83 fd 00 00       	call   411390 <cos_sched_asnd>
  40160d:	e9 5d ff ff ff       	jmp    40156f <slm_blkpt_block+0x39f>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  401612:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]
  401616:	4c 8b 05 8b 08 1a 00 	mov    r8,QWORD PTR [rip+0x1a088b]        # 5a1ea8 <__slm_global+0x28>
  40161d:	45 89 f1             	mov    r9d,r14d
  401620:	31 c9                	xor    ecx,ecx
  401622:	48 8b 3d 6f 08 1a 00 	mov    rdi,QWORD PTR [rip+0x1a086f]        # 5a1e98 <__slm_global+0x18>
  401629:	31 f6                	xor    esi,esi
  40162b:	e8 f0 fc 00 00       	call   411320 <cos_switch>
  401630:	e9 3a ff ff ff       	jmp    40156f <slm_blkpt_block+0x39f>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  401635:	41 89 f0             	mov    r8d,esi
  401638:	48 89 da             	mov    rdx,rbx
  40163b:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  401640:	41 83 e0 01          	and    r8d,0x1
  401644:	e8 c7 21 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  401649:	83 f8 f0             	cmp    eax,0xfffffff0
  40164c:	0f 85 45 ff ff ff    	jne    401597 <slm_blkpt_block+0x3c7>
  401652:	e9 89 fd ff ff       	jmp    4013e0 <slm_blkpt_block+0x210>
  401657:	be 61 00 00 00       	mov    esi,0x61
  40165c:	bf 60 b8 41 00       	mov    edi,0x41b860
  401661:	e8 6a 8a 00 00       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  401666:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40166d:	00 00 00 00 
  401671:	0f 0b                	ud2    
  401673:	be 61 00 00 00       	mov    esi,0x61
  401678:	bf f8 b7 41 00       	mov    edi,0x41b7f8
  40167d:	e8 4e 8a 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  401682:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401689:	00 00 00 00 
  40168d:	0f 0b                	ud2    
  40168f:	90                   	nop

0000000000401690 <slm_thd_timer_policy>:
SLM_MODULES_COMPOSE_DATA();
  401690:	f3 0f 1e fa          	endbr64 
  401694:	48 8d 87 88 00 00 00 	lea    rax,[rdi+0x88]
  40169b:	c3                   	ret    
  40169c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

00000000004016a0 <slm_thd_sched_policy>:
  4016a0:	f3 0f 1e fa          	endbr64 
  4016a4:	48 8d 47 78          	lea    rax,[rdi+0x78]
  4016a8:	c3                   	ret    
  4016a9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

00000000004016b0 <slm_thd_from_timer>:
  4016b0:	f3 0f 1e fa          	endbr64 
  4016b4:	48 8d 87 78 ff ff ff 	lea    rax,[rdi-0x88]
  4016bb:	c3                   	ret    
  4016bc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

00000000004016c0 <slm_thd_from_sched>:
  4016c0:	f3 0f 1e fa          	endbr64 
  4016c4:	48 8d 47 88          	lea    rax,[rdi-0x78]
  4016c8:	c3                   	ret    
  4016c9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

00000000004016d0 <slm_timer_expire>:
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  4016d0:	f3 0f 1e fa          	endbr64 
  4016d4:	e9 e7 13 01 00       	jmp    412ac0 <slm_timer_quantum_expire>
  4016d9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

00000000004016e0 <slm_timer_thd_init>:
  4016e0:	f3 0f 1e fa          	endbr64 
  4016e4:	e9 77 16 01 00       	jmp    412d60 <slm_timer_quantum_thd_init>
  4016e9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

00000000004016f0 <slm_timer_thd_deinit>:
  4016f0:	f3 0f 1e fa          	endbr64 
  4016f4:	e9 87 16 01 00       	jmp    412d80 <slm_timer_quantum_thd_deinit>
  4016f9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401700 <slm_timer_add>:
  401700:	f3 0f 1e fa          	endbr64 
  401704:	e9 47 15 01 00       	jmp    412c50 <slm_timer_quantum_add>
  401709:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401710 <slm_timer_cancel>:
  401710:	f3 0f 1e fa          	endbr64 
  401714:	e9 c7 15 01 00       	jmp    412ce0 <slm_timer_quantum_cancel>
  401719:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401720 <slm_timer_init>:
  401720:	f3 0f 1e fa          	endbr64 
  401724:	e9 67 16 01 00       	jmp    412d90 <slm_timer_quantum_init>
  401729:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401730 <slm_sched_init>:
  401730:	f3 0f 1e fa          	endbr64 
  401734:	e9 47 10 01 00       	jmp    412780 <slm_sched_fprr_init>
  401739:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401740 <slm_sched_thd_init>:
  401740:	f3 0f 1e fa          	endbr64 
  401744:	e9 a7 0e 01 00       	jmp    4125f0 <slm_sched_fprr_thd_init>
  401749:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401750 <slm_sched_thd_deinit>:
  401750:	f3 0f 1e fa          	endbr64 
  401754:	e9 c7 0e 01 00       	jmp    412620 <slm_sched_fprr_thd_deinit>
  401759:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401760 <slm_sched_thd_update>:
  401760:	f3 0f 1e fa          	endbr64 
  401764:	e9 e7 0e 01 00       	jmp    412650 <slm_sched_fprr_thd_update>
  401769:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401770 <slm_sched_block>:
  401770:	f3 0f 1e fa          	endbr64 
  401774:	e9 77 0d 01 00       	jmp    4124f0 <slm_sched_fprr_block>
  401779:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401780 <slm_sched_wakeup>:
  401780:	f3 0f 1e fa          	endbr64 
  401784:	e9 97 0d 01 00       	jmp    412520 <slm_sched_fprr_wakeup>
  401789:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401790 <slm_sched_yield>:
  401790:	f3 0f 1e fa          	endbr64 
  401794:	e9 f7 0d 01 00       	jmp    412590 <slm_sched_fprr_yield>
  401799:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

00000000004017a0 <slm_sched_schedule>:
  4017a0:	f3 0f 1e fa          	endbr64 
  4017a4:	e9 e7 0c 01 00       	jmp    412490 <slm_sched_fprr_schedule>
  4017a9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

00000000004017b0 <slm_sched_execution>:
  4017b0:	f3 0f 1e fa          	endbr64 
  4017b4:	e9 c7 0c 01 00       	jmp    412480 <slm_sched_fprr_execution>
  4017b9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

00000000004017c0 <slm_thd_lookup>:
  4017c0:	f3 0f 1e fa          	endbr64 
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  4017c4:	85 ff                	test   edi,edi
  4017c6:	74 38                	je     401800 <slm_thd_lookup+0x40>
  4017c8:	83 ef 01             	sub    edi,0x1
  4017cb:	83 ff 18             	cmp    edi,0x18
  4017ce:	77 30                	ja     401800 <slm_thd_lookup+0x40>
  4017d0:	48 8b 14 fd c0 e6 45 	mov    rdx,QWORD PTR [rdi*8+0x45e6c0]
  4017d7:	00 
  4017d8:	31 c0                	xor    eax,eax
  4017da:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  4017e1:	74 1f                	je     401802 <slm_thd_lookup+0x42>
  4017e3:	83 e2 01             	and    edx,0x1
  4017e6:	75 1a                	jne    401802 <slm_thd_lookup+0x42>
  4017e8:	48 8d 04 bf          	lea    rax,[rdi+rdi*4]
  4017ec:	48 8d 04 47          	lea    rax,[rdi+rax*2]
  4017f0:	48 c1 e0 04          	shl    rax,0x4
  4017f4:	48 05 88 e7 45 00    	add    rax,0x45e788
  4017fa:	c3                   	ret    
  4017fb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  401800:	31 c0                	xor    eax,eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  401802:	c3                   	ret    
  401803:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40180a:	00 00 00 00 
  40180e:	66 90                	xchg   ax,ax

0000000000401810 <ss_thd_intern_is_allocated>:
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  401810:	f3 0f 1e fa          	endbr64 
  401814:	48 8d 87 c8 00 00 00 	lea    rax,[rdi+0xc8]
  40181b:	48 39 c6             	cmp    rsi,rax
  40181e:	72 32                	jb     401852 <ss_thd_intern_is_allocated+0x42>
  401820:	48 8d 97 48 11 00 00 	lea    rdx,[rdi+0x1148]
  401827:	48 39 d6             	cmp    rsi,rdx
  40182a:	77 26                	ja     401852 <ss_thd_intern_is_allocated+0x42>
  40182c:	48 29 c6             	sub    rsi,rax
  40182f:	48 c1 fe 04          	sar    rsi,0x4
  401833:	69 c6 a3 8b 2e ba    	imul   eax,esi,0xba2e8ba3
  401839:	48 8b 04 c7          	mov    rax,QWORD PTR [rdi+rax*8]
  40183d:	48 89 c2             	mov    rdx,rax
  401840:	83 e2 01             	and    edx,0x1
  401843:	48 a9 fe ff ff ff    	test   rax,0xfffffffffffffffe
  401849:	b8 01 00 00 00       	mov    eax,0x1
  40184e:	0f 45 c2             	cmovne eax,edx
  401851:	c3                   	ret    
  401852:	55                   	push   rbp
  401853:	be 23 00 00 00       	mov    esi,0x23
  401858:	bf e8 b9 41 00       	mov    edi,0x41b9e8
  40185d:	48 89 e5             	mov    rbp,rsp
  401860:	e8 6b 88 00 00       	call   40a0d0 <cos_print_str>
  401865:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40186c:	00 00 00 00 
  401870:	0f 0b                	ud2    
  401872:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  401879:	00 00 00 00 
  40187d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000401880 <ss_thd_is_allocated>:
  401880:	f3 0f 1e fa          	endbr64 
  401884:	48 81 ff 08 f8 45 00 	cmp    rdi,0x45f808
  40188b:	77 37                	ja     4018c4 <ss_thd_is_allocated+0x44>
  40188d:	48 81 ff 88 e7 45 00 	cmp    rdi,0x45e788
  401894:	72 2e                	jb     4018c4 <ss_thd_is_allocated+0x44>
  401896:	48 81 ef 88 e7 45 00 	sub    rdi,0x45e788
  40189d:	48 c1 ff 04          	sar    rdi,0x4
  4018a1:	69 c7 a3 8b 2e ba    	imul   eax,edi,0xba2e8ba3
  4018a7:	48 8b 04 c5 c0 e6 45 	mov    rax,QWORD PTR [rax*8+0x45e6c0]
  4018ae:	00 
  4018af:	48 89 c2             	mov    rdx,rax
  4018b2:	83 e2 01             	and    edx,0x1
  4018b5:	48 a9 fe ff ff ff    	test   rax,0xfffffffffffffffe
  4018bb:	b8 01 00 00 00       	mov    eax,0x1
  4018c0:	0f 45 c2             	cmovne eax,edx
  4018c3:	c3                   	ret    
  4018c4:	55                   	push   rbp
  4018c5:	be 23 00 00 00       	mov    esi,0x23
  4018ca:	bf e8 b9 41 00       	mov    edi,0x41b9e8
  4018cf:	48 89 e5             	mov    rbp,rsp
  4018d2:	e8 f9 87 00 00       	call   40a0d0 <cos_print_str>
  4018d7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4018de:	00 00 00 00 
  4018e2:	0f 0b                	ud2    
  4018e4:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4018eb:	00 00 00 00 
  4018ef:	90                   	nop

00000000004018f0 <slm_thd_static_cm_lookup>:
  4018f0:	f3 0f 1e fa          	endbr64 
  4018f4:	85 ff                	test   edi,edi
  4018f6:	74 38                	je     401930 <slm_thd_static_cm_lookup+0x40>
  4018f8:	83 ef 01             	sub    edi,0x1
  4018fb:	83 ff 18             	cmp    edi,0x18
  4018fe:	77 30                	ja     401930 <slm_thd_static_cm_lookup+0x40>
  401900:	48 8b 14 fd c0 e6 45 	mov    rdx,QWORD PTR [rdi*8+0x45e6c0]
  401907:	00 
  401908:	31 c0                	xor    eax,eax
  40190a:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  401911:	74 1f                	je     401932 <slm_thd_static_cm_lookup+0x42>
  401913:	83 e2 01             	and    edx,0x1
  401916:	75 1a                	jne    401932 <slm_thd_static_cm_lookup+0x42>
  401918:	48 8d 04 bf          	lea    rax,[rdi+rdi*4]
  40191c:	48 8d 04 47          	lea    rax,[rdi+rax*2]
  401920:	48 c1 e0 04          	shl    rax,0x4
  401924:	48 05 88 e7 45 00    	add    rax,0x45e788
  40192a:	c3                   	ret    
  40192b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  401930:	31 c0                	xor    eax,eax
  401932:	c3                   	ret    
  401933:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40193a:	00 00 00 00 
  40193e:	66 90                	xchg   ax,ax

0000000000401940 <slm_thd_current_extern>:
{
  401940:	f3 0f 1e fa          	endbr64 
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  401944:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  401947:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  40194d:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  401954:	48 85 c0             	test   rax,rax
  401957:	74 3f                	je     401998 <slm_thd_current_extern+0x58>
  401959:	83 e8 01             	sub    eax,0x1
  40195c:	83 f8 18             	cmp    eax,0x18
  40195f:	77 37                	ja     401998 <slm_thd_current_extern+0x58>
  401961:	48 8b 14 c5 c0 e6 45 	mov    rdx,QWORD PTR [rax*8+0x45e6c0]
  401968:	00 
  401969:	45 31 c0             	xor    r8d,r8d
  40196c:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  401973:	74 18                	je     40198d <slm_thd_current_extern+0x4d>
  401975:	83 e2 01             	and    edx,0x1
  401978:	75 13                	jne    40198d <slm_thd_current_extern+0x4d>
  40197a:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  40197e:	4c 8d 04 50          	lea    r8,[rax+rdx*2]
  401982:	49 c1 e0 04          	shl    r8,0x4
  401986:	49 81 c0 88 e7 45 00 	add    r8,0x45e788
}
  40198d:	4c 89 c0             	mov    rax,r8
  401990:	c3                   	ret    
  401991:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  401998:	45 31 c0             	xor    r8d,r8d
}
  40199b:	4c 89 c0             	mov    rax,r8
  40199e:	c3                   	ret    
  40199f:	90                   	nop

00000000004019a0 <slm_thd_from_container>:
slm_thd_from_container(struct slm_thd_container *c) {
  4019a0:	f3 0f 1e fa          	endbr64 
  4019a4:	48 89 f8             	mov    rax,rdi
}
  4019a7:	c3                   	ret    
  4019a8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4019af:	00 

00000000004019b0 <slm_thd_mem_alloc>:
{
  4019b0:	f3 0f 1e fa          	endbr64 
  4019b4:	55                   	push   rbp
  4019b5:	66 48 0f 6e c7       	movq   xmm0,rdi
  4019ba:	66 48 0f 6e ce       	movq   xmm1,rsi
  4019bf:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  4019c3:	48 89 e5             	mov    rbp,rsp
  4019c6:	53                   	push   rbx
  4019c7:	48 83 ec 08          	sub    rsp,0x8
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  4019cb:	85 f6                	test   esi,esi
  4019cd:	0f 84 85 00 00 00    	je     401a58 <slm_thd_mem_alloc+0xa8>
  4019d3:	49 89 d2             	mov    r10,rdx
  4019d6:	8d 56 ff             	lea    edx,[rsi-0x1]
  4019d9:	83 fa 18             	cmp    edx,0x18
  4019dc:	77 7a                	ja     401a58 <slm_thd_mem_alloc+0xa8>
	if (*state != SS_STATE_FREE ||
  4019de:	48 83 3c d5 c0 e6 45 	cmp    QWORD PTR [rdx*8+0x45e6c0],0x0
  4019e5:	00 00 
  4019e7:	75 6f                	jne    401a58 <slm_thd_mem_alloc+0xa8>
  4019e9:	31 db                	xor    ebx,ebx
  4019eb:	49 89 c9             	mov    r9,rcx
  4019ee:	b9 01 00 00 00       	mov    ecx,0x1
  4019f3:	48 89 d8             	mov    rax,rbx
  4019f6:	f0 48 0f b1 0c d5 c0 	lock cmpxchg QWORD PTR [rdx*8+0x45e6c0],rcx
  4019fd:	e6 45 00 
  401a00:	0f 94 c0             	sete   al
  401a03:	84 c0                	test   al,al
  401a05:	74 51                	je     401a58 <slm_thd_mem_alloc+0xa8>
  401a07:	48 8d 04 92          	lea    rax,[rdx+rdx*4]
  401a0b:	49 89 f8             	mov    r8,rdi
  401a0e:	b9 16 00 00 00       	mov    ecx,0x16
  401a13:	48 8d 14 42          	lea    rdx,[rdx+rax*2]
  401a17:	48 89 d8             	mov    rax,rbx
  401a1a:	48 c1 e2 04          	shl    rdx,0x4
  401a1e:	4c 8d 9a 88 e7 45 00 	lea    r11,[rdx+0x45e788]
  401a25:	4c 89 df             	mov    rdi,r11
  401a28:	f3 48 ab             	rep stos QWORD PTR es:[rdi],rax
	assert(_cap != 0 && _tid != 0);
  401a2b:	4d 85 c0             	test   r8,r8
  401a2e:	74 44                	je     401a74 <slm_thd_mem_alloc+0xc4>
	t->resources = (struct slm_resources_thd) {
  401a30:	48 8b 05 09 56 02 00 	mov    rax,QWORD PTR [rip+0x25609]        # 427040 <__cosrt_comp_info+0x40>
  401a37:	0f 29 82 20 e8 45 00 	movaps XMMWORD PTR [rdx+0x45e820],xmm0
}
  401a3e:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
	t->resources = (struct slm_resources_thd) {
  401a42:	48 89 82 30 e8 45 00 	mov    QWORD PTR [rdx+0x45e830],rax
}
  401a49:	4c 89 d8             	mov    rax,r11
	*thd = _cap;
  401a4c:	4d 89 02             	mov    QWORD PTR [r10],r8
	*tid = _tid;
  401a4f:	49 89 31             	mov    QWORD PTR [r9],rsi
}
  401a52:	c9                   	leave  
  401a53:	c3                   	ret    
  401a54:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  401a58:	be 23 00 00 00       	mov    esi,0x23
  401a5d:	bf 10 ba 41 00       	mov    edi,0x41ba10
  401a62:	e8 69 86 00 00       	call   40a0d0 <cos_print_str>
	if (!t) assert(0);
  401a67:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401a6e:	00 00 00 00 
  401a72:	0f 0b                	ud2    
  401a74:	be 23 00 00 00       	mov    esi,0x23
  401a79:	bf 38 ba 41 00       	mov    edi,0x41ba38
  401a7e:	e8 4d 86 00 00       	call   40a0d0 <cos_print_str>
	assert(_cap != 0 && _tid != 0);
  401a83:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401a8a:	00 00 00 00 
  401a8e:	0f 0b                	ud2    

0000000000401a90 <slm_thd_mem_activate>:
void slm_thd_mem_activate(struct slm_thd_container *t) { ss_thd_activate(t); }
  401a90:	f3 0f 1e fa          	endbr64 
  401a94:	55                   	push   rbp
  401a95:	48 89 e5             	mov    rbp,rsp
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  401a98:	48 81 ff 88 e7 45 00 	cmp    rdi,0x45e788
  401a9f:	72 50                	jb     401af1 <slm_thd_mem_activate+0x61>
  401aa1:	48 81 ff 08 f8 45 00 	cmp    rdi,0x45f808
  401aa8:	77 47                	ja     401af1 <slm_thd_mem_activate+0x61>
  401aaa:	48 81 ef 88 e7 45 00 	sub    rdi,0x45e788
  401ab1:	48 c1 ff 04          	sar    rdi,0x4
 */
static inline void
ss_state_activate_with(ss_state_t *state, word_t val)
{
	assert(val != 0);
	*state = val | (*state & 1);
  401ab5:	69 c7 a3 8b 2e ba    	imul   eax,edi,0xba2e8ba3
  401abb:	48 8b 14 c5 c0 e6 45 	mov    rdx,QWORD PTR [rax*8+0x45e6c0]
  401ac2:	00 
  401ac3:	48 83 ca fe          	or     rdx,0xfffffffffffffffe
  401ac7:	48 89 14 c5 c0 e6 45 	mov    QWORD PTR [rax*8+0x45e6c0],rdx
  401ace:	00 
	assert((*state & 1) == SS_STATE_CONS);
  401acf:	48 83 fa ff          	cmp    rdx,0xffffffffffffffff
  401ad3:	75 38                	jne    401b0d <slm_thd_mem_activate+0x7d>
	*state &= ~SS_STATE_CONS;
  401ad5:	48 c7 04 c5 c0 e6 45 	mov    QWORD PTR [rax*8+0x45e6c0],0xfffffffffffffffe
  401adc:	00 fe ff ff ff 
{ __asm__ __volatile__("mfence" ::: "memory"); }
  401ae1:	0f ae f0             	mfence 
	assert(*state != 0);
  401ae4:	48 83 3c c5 c0 e6 45 	cmp    QWORD PTR [rax*8+0x45e6c0],0x0
  401aeb:	00 00 
  401aed:	74 3a                	je     401b29 <slm_thd_mem_activate+0x99>
void slm_thd_mem_activate(struct slm_thd_container *t) { ss_thd_activate(t); }
  401aef:	5d                   	pop    rbp
  401af0:	c3                   	ret    
  401af1:	be 23 00 00 00       	mov    esi,0x23
  401af6:	bf e8 b9 41 00       	mov    edi,0x41b9e8
  401afb:	e8 d0 85 00 00       	call   40a0d0 <cos_print_str>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  401b00:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401b07:	00 00 00 00 
  401b0b:	0f 0b                	ud2    
  401b0d:	be 61 00 00 00       	mov    esi,0x61
  401b12:	bf 60 ba 41 00       	mov    edi,0x41ba60
  401b17:	e8 b4 85 00 00       	call   40a0d0 <cos_print_str>
	assert((*state & 1) == SS_STATE_CONS);
  401b1c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401b23:	00 00 00 00 
  401b27:	0f 0b                	ud2    
  401b29:	be 61 00 00 00       	mov    esi,0x61
  401b2e:	bf c8 ba 41 00       	mov    edi,0x41bac8
  401b33:	e8 98 85 00 00       	call   40a0d0 <cos_print_str>
	assert(*state != 0);
  401b38:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401b3f:	00 00 00 00 
  401b43:	0f 0b                	ud2    
  401b45:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  401b4c:	00 00 00 00 

0000000000401b50 <slm_thd_mem_free>:
void slm_thd_mem_free(struct slm_thd_container *t) { return; }
  401b50:	f3 0f 1e fa          	endbr64 
  401b54:	c3                   	ret    
  401b55:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  401b5c:	00 00 00 00 

0000000000401b60 <sched_thd_create_closure>:
{
  401b60:	f3 0f 1e fa          	endbr64 
  401b64:	55                   	push   rbp
  401b65:	89 fe                	mov    esi,edi
	struct slm_thd *t = thd_alloc_in(cos_inv_token(), idx, &p, 0);
  401b67:	31 c9                	xor    ecx,ecx
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  401b69:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  401b6c:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
{
  401b72:	48 89 e5             	mov    rbp,rsp
  401b75:	48 83 ec 10          	sub    rsp,0x10
	struct slm_thd *t = thd_alloc_in(cos_inv_token(), idx, &p, 0);
  401b79:	48 8b b8 e8 1f 00 00 	mov    rdi,QWORD PTR [rax+0x1fe8]
  401b80:	48 8d 55 fc          	lea    rdx,[rbp-0x4]
	sched_param_t p = 0;
  401b84:	c7 45 fc 00 00 00 00 	mov    DWORD PTR [rbp-0x4],0x0
	struct slm_thd *t = thd_alloc_in(cos_inv_token(), idx, &p, 0);
  401b8b:	e8 d0 31 00 00       	call   404d60 <thd_alloc_in>
	if (!t) return 0;
  401b90:	48 85 c0             	test   rax,rax
  401b93:	74 0b                	je     401ba0 <sched_thd_create_closure+0x40>
	return t->tid;
  401b95:	48 8b 40 18          	mov    rax,QWORD PTR [rax+0x18]
}
  401b99:	c9                   	leave  
  401b9a:	c3                   	ret    
  401b9b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  401ba0:	c9                   	leave  
	if (!t) return 0;
  401ba1:	31 c0                	xor    eax,eax
}
  401ba3:	c3                   	ret    
  401ba4:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  401bab:	00 00 00 00 
  401baf:	90                   	nop

0000000000401bb0 <sched_thd_param_set>:
{
  401bb0:	f3 0f 1e fa          	endbr64 

static inline void
sched_param_get(sched_param_t sp, sched_param_type_t *type, unsigned int *value)
{
	if (type)  *type  = (sched_param_type_t)(sp &  SCHED_PARAM_TYPE_MASK);
	if (value) *value = (unsigned int)      (sp >> SCHED_PARAM_TYPE_BITS);
  401bb4:	89 f2                	mov    edx,esi
	if (type)  *type  = (sched_param_type_t)(sp &  SCHED_PARAM_TYPE_MASK);
  401bb6:	83 e6 3f             	and    esi,0x3f
	if (value) *value = (unsigned int)      (sp >> SCHED_PARAM_TYPE_BITS);
  401bb9:	c1 ea 06             	shr    edx,0x6
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  401bbc:	85 ff                	test   edi,edi
  401bbe:	74 38                	je     401bf8 <sched_thd_param_set+0x48>
  401bc0:	83 ef 01             	sub    edi,0x1
  401bc3:	83 ff 18             	cmp    edi,0x18
  401bc6:	77 30                	ja     401bf8 <sched_thd_param_set+0x48>
  401bc8:	48 8b 04 fd c0 e6 45 	mov    rax,QWORD PTR [rdi*8+0x45e6c0]
  401bcf:	00 
	return ((state & ~1) != 0) && ((state & 1) == SS_STATE_ALLOC);
  401bd0:	48 a9 fe ff ff ff    	test   rax,0xfffffffffffffffe
  401bd6:	74 20                	je     401bf8 <sched_thd_param_set+0x48>
  401bd8:	a8 01                	test   al,0x1
  401bda:	75 1c                	jne    401bf8 <sched_thd_param_set+0x48>
	return &ss_thd_get(id)->thd;
  401bdc:	48 8d 04 bf          	lea    rax,[rdi+rdi*4]
  401be0:	48 8d 3c 47          	lea    rdi,[rdi+rax*2]
  401be4:	48 c1 e7 04          	shl    rdi,0x4
  401be8:	48 81 c7 88 e7 45 00 	add    rdi,0x45e788
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  401bef:	e9 5c 0a 01 00       	jmp    412650 <slm_sched_fprr_thd_update>
  401bf4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
}
  401bf8:	b8 ff ff ff ff       	mov    eax,0xffffffff
  401bfd:	c3                   	ret    
  401bfe:	66 90                	xchg   ax,ax

0000000000401c00 <sched_thd_delete>:
{
  401c00:	f3 0f 1e fa          	endbr64 
}
  401c04:	31 c0                	xor    eax,eax
  401c06:	c3                   	ret    
  401c07:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  401c0e:	00 00 

0000000000401c10 <sched_thd_exit>:
{
  401c10:	f3 0f 1e fa          	endbr64 
  401c14:	55                   	push   rbp
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  401c15:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  401c18:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  401c1e:	48 89 e5             	mov    rbp,rsp
  401c21:	41 57                	push   r15
  401c23:	41 56                	push   r14
  401c25:	41 55                	push   r13
  401c27:	41 54                	push   r12
  401c29:	53                   	push   rbx
  401c2a:	48 83 ec 08          	sub    rsp,0x8
  401c2e:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  401c35:	48 85 c0             	test   rax,rax
  401c38:	0f 84 22 02 00 00    	je     401e60 <sched_thd_exit+0x250>
  401c3e:	83 e8 01             	sub    eax,0x1
  401c41:	83 f8 18             	cmp    eax,0x18
  401c44:	0f 87 16 02 00 00    	ja     401e60 <sched_thd_exit+0x250>
  401c4a:	48 8b 14 c5 c0 e6 45 	mov    rdx,QWORD PTR [rax*8+0x45e6c0]
  401c51:	00 
  401c52:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  401c59:	0f 84 01 02 00 00    	je     401e60 <sched_thd_exit+0x250>
  401c5f:	80 e2 01             	and    dl,0x1
  401c62:	0f 85 f8 01 00 00    	jne    401e60 <sched_thd_exit+0x250>
  401c68:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  401c6c:	4c 8d 34 50          	lea    r14,[rax+rdx*2]
  401c70:	49 c1 e6 04          	shl    r14,0x4
  401c74:	49 81 c6 88 e7 45 00 	add    r14,0x45e788
		tok    = cos_sched_sync();
  401c7b:	e8 80 f6 00 00       	call   411300 <cos_sched_sync>
  401c80:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  401c83:	48 8b 05 f6 01 1a 00 	mov    rax,QWORD PTR [rip+0x1a01f6]        # 5a1e80 <__slm_global>
		if (unlikely(owner)) {
  401c8a:	48 89 c1             	mov    rcx,rax
  401c8d:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  401c91:	0f 85 03 02 00 00    	jne    401e9a <sched_thd_exit+0x28a>
        __asm__ __volatile__("lock " PS_CAS_STR
  401c97:	f0 4c 0f b1 35 e0 01 	lock cmpxchg QWORD PTR [rip+0x1a01e0],r14        # 5a1e80 <__slm_global>
  401c9e:	1a 00 
  401ca0:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  401ca3:	84 c0                	test   al,al
  401ca5:	74 d4                	je     401c7b <sched_thd_exit+0x6b>
	slm_thd_deinit(current);
  401ca7:	4c 89 f7             	mov    rdi,r14
	for (i = 0; slm_cs_exit_reschedule(current, SLM_CS_NONE) && i < 16; i++) ;
  401caa:	41 bd 11 00 00 00    	mov    r13d,0x11
	if (unlikely(!t)) t = &g->idle_thd;
  401cb0:	41 bf 00 1f 5a 00    	mov    r15d,0x5a1f00
	slm_thd_deinit(current);
  401cb6:	e8 25 1b 01 00       	call   4137e0 <slm_thd_deinit>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  401cbb:	e8 a0 9b 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	tok  = cos_sched_sync();
  401cc0:	e8 3b f6 00 00       	call   411300 <cos_sched_sync>
  401cc5:	41 89 c4             	mov    r12d,eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  401cc8:	e8 c3 07 01 00       	call   412490 <slm_sched_fprr_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  401ccd:	48 85 c0             	test   rax,rax
  401cd0:	48 89 c3             	mov    rbx,rax
  401cd3:	49 0f 44 df          	cmove  rbx,r15
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  401cd7:	8b 43 04             	mov    eax,DWORD PTR [rbx+0x4]
  401cda:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  401cdd:	83 f8 01             	cmp    eax,0x1
  401ce0:	76 1e                	jbe    401d00 <sched_thd_exit+0xf0>
  401ce2:	e9 95 00 00 00       	jmp    401d7c <sched_thd_exit+0x16c>
  401ce7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  401cee:	00 00 
  401cf0:	f0 48 0f b1 15 87 01 	lock cmpxchg QWORD PTR [rip+0x1a0187],rdx        # 5a1e80 <__slm_global>
  401cf7:	1a 00 
  401cf9:	0f 94 c0             	sete   al
	while (ret != 0) {
  401cfc:	84 c0                	test   al,al
  401cfe:	75 2e                	jne    401d2e <sched_thd_exit+0x11e>
		tok    = cos_sched_sync();
  401d00:	e8 fb f5 00 00       	call   411300 <cos_sched_sync>
  401d05:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  401d07:	48 8b 05 72 01 1a 00 	mov    rax,QWORD PTR [rip+0x1a0172]        # 5a1e80 <__slm_global>
		if (unlikely(contention)) {
  401d0e:	48 89 c2             	mov    rdx,rax
  401d11:	83 e2 01             	and    edx,0x1
  401d14:	74 da                	je     401cf0 <sched_thd_exit+0xe0>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  401d16:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  401d19:	48 89 c2             	mov    rdx,rax
  401d1c:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  401d21:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  401d25:	e8 36 1b 01 00       	call   413860 <slm_cs_exit_contention>
  401d2a:	85 c0                	test   eax,eax
  401d2c:	75 d2                	jne    401d00 <sched_thd_exit+0xf0>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  401d2e:	e8 2d 9b 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  401d33:	8b 03                	mov    eax,DWORD PTR [rbx]
	timeout = g->timeout_next;
  401d35:	4c 8b 05 4c 02 1a 00 	mov    r8,QWORD PTR [rip+0x1a024c]        # 5a1f88 <__slm_global+0x108>
	prio = inherit_prio ? curr->priority : t->priority;
  401d3c:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  401d40:	a8 0b                	test   al,0xb
  401d42:	75 54                	jne    401d98 <sched_thd_exit+0x188>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  401d44:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  401d48:	44 89 e1             	mov    ecx,r12d
  401d4b:	4c 89 c2             	mov    rdx,r8
  401d4e:	e8 0d aa 00 00       	call   40c760 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  401d53:	83 f8 ff             	cmp    eax,0xffffffff
  401d56:	0f 84 ce 00 00 00    	je     401e2a <sched_thd_exit+0x21a>
	if (unlikely(ret != 0)) {
  401d5c:	85 c0                	test   eax,eax
  401d5e:	75 7d                	jne    401ddd <sched_thd_exit+0x1cd>
  401d60:	be 11 00 00 00       	mov    esi,0x11
  401d65:	bf 2a bb 41 00       	mov    edi,0x41bb2a
  401d6a:	e8 61 83 00 00       	call   40a0d0 <cos_print_str>
	BUG();
  401d6f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401d76:	00 00 00 00 
  401d7a:	0f 0b                	ud2    
  401d7c:	be 61 00 00 00       	mov    esi,0x61
  401d81:	bf 28 b7 41 00       	mov    edi,0x41b728
  401d86:	e8 45 83 00 00       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  401d8b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401d92:	00 00 00 00 
  401d96:	0f 0b                	ud2    
	timeout = g->timeout_next;
  401d98:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  401d9b:	48 81 fb 88 1e 5a 00 	cmp    rbx,0x5a1e88
  401da2:	0f 84 e7 00 00 00    	je     401e8f <sched_thd_exit+0x27f>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  401da8:	a8 02                	test   al,0x2
  401daa:	0f 85 26 01 00 00    	jne    401ed6 <sched_thd_exit+0x2c6>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  401db0:	49 89 c8             	mov    r8,rcx
  401db3:	a8 01                	test   al,0x1
  401db5:	74 8d                	je     401d44 <sched_thd_exit+0x134>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  401db7:	4c 8b 53 08          	mov    r10,QWORD PTR [rbx+0x8]
  401dbb:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  401dbf:	48 89 f2             	mov    rdx,rsi
  401dc2:	45 89 e1             	mov    r9d,r12d
  401dc5:	4c 8b 05 dc 00 1a 00 	mov    r8,QWORD PTR [rip+0x1a00dc]        # 5a1ea8 <__slm_global+0x28>
  401dcc:	4c 89 d6             	mov    rsi,r10
  401dcf:	e8 4c f5 00 00       	call   411320 <cos_switch>
	if (unlikely(ret != 0)) {
  401dd4:	85 c0                	test   eax,eax
  401dd6:	74 88                	je     401d60 <sched_thd_exit+0x150>
		assert(ret != -EPERM);
  401dd8:	83 f8 ff             	cmp    eax,0xffffffff
  401ddb:	74 67                	je     401e44 <sched_thd_exit+0x234>
		assert(ret != -EINVAL);
  401ddd:	83 f8 ea             	cmp    eax,0xffffffea
  401de0:	0f 84 2e 01 00 00    	je     401f14 <sched_thd_exit+0x304>
		if (ret == -EBUSY) return ret;
  401de6:	83 f8 f0             	cmp    eax,0xfffffff0
  401de9:	0f 84 91 00 00 00    	je     401e80 <sched_thd_exit+0x270>
		assert(ret == -EAGAIN);
  401def:	83 f8 f5             	cmp    eax,0xfffffff5
  401df2:	0f 85 5d 01 00 00    	jne    401f55 <sched_thd_exit+0x345>
		tok    = cos_sched_sync();
  401df8:	e8 03 f5 00 00       	call   411300 <cos_sched_sync>
  401dfd:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  401e00:	48 8b 05 79 00 1a 00 	mov    rax,QWORD PTR [rip+0x1a0079]        # 5a1e80 <__slm_global>
		if (unlikely(owner)) {
  401e07:	48 89 c1             	mov    rcx,rax
  401e0a:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  401e0e:	0f 85 1c 01 00 00    	jne    401f30 <sched_thd_exit+0x320>
  401e14:	f0 4c 0f b1 35 63 00 	lock cmpxchg QWORD PTR [rip+0x1a0063],r14        # 5a1e80 <__slm_global>
  401e1b:	1a 00 
  401e1d:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  401e20:	84 c0                	test   al,al
  401e22:	0f 85 98 fe ff ff    	jne    401cc0 <sched_thd_exit+0xb0>
  401e28:	eb ce                	jmp    401df8 <sched_thd_exit+0x1e8>
	return t != &g->idle_thd && t != &g->sched_thd;
  401e2a:	48 81 fb 00 1f 5a 00 	cmp    rbx,0x5a1f00
  401e31:	0f 84 ba 00 00 00    	je     401ef1 <sched_thd_exit+0x2e1>
  401e37:	48 81 fb 88 1e 5a 00 	cmp    rbx,0x5a1e88
  401e3e:	0f 84 ad 00 00 00    	je     401ef1 <sched_thd_exit+0x2e1>
  401e44:	be 61 00 00 00       	mov    esi,0x61
  401e49:	bf 90 b7 41 00       	mov    edi,0x41b790
  401e4e:	e8 7d 82 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EPERM);
  401e53:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401e5a:	00 00 00 00 
  401e5e:	0f 0b                	ud2    
  401e60:	be 59 00 00 00       	mov    esi,0x59
  401e65:	bf 40 b6 41 00       	mov    edi,0x41b640
  401e6a:	e8 61 82 00 00       	call   40a0d0 <cos_print_str>
	assert(current);
  401e6f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401e76:	00 00 00 00 
  401e7a:	0f 0b                	ud2    
  401e7c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	for (i = 0; slm_cs_exit_reschedule(current, SLM_CS_NONE) && i < 16; i++) ;
  401e80:	41 83 ed 01          	sub    r13d,0x1
  401e84:	0f 85 31 fe ff ff    	jne    401cbb <sched_thd_exit+0xab>
  401e8a:	e9 d1 fe ff ff       	jmp    401d60 <sched_thd_exit+0x150>
			prio    = curr->priority;
  401e8f:	49 8b 76 30          	mov    rsi,QWORD PTR [r14+0x30]
			timeout = TCAP_TIME_NIL;
  401e93:	31 c9                	xor    ecx,ecx
  401e95:	e9 0e ff ff ff       	jmp    401da8 <sched_thd_exit+0x198>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  401e9a:	41 89 c0             	mov    r8d,eax
  401e9d:	4c 89 f2             	mov    rdx,r14
  401ea0:	48 89 c6             	mov    rsi,rax
  401ea3:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  401ea8:	41 83 e0 01          	and    r8d,0x1
  401eac:	e8 5f 19 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  401eb1:	83 f8 f0             	cmp    eax,0xfffffff0
  401eb4:	0f 85 c1 fd ff ff    	jne    401c7b <sched_thd_exit+0x6b>
  401eba:	be 59 00 00 00       	mov    esi,0x59
  401ebf:	bf a0 b6 41 00       	mov    edi,0x41b6a0
  401ec4:	e8 07 82 00 00       	call   40a0d0 <cos_print_str>
  401ec9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401ed0:	00 00 00 00 
  401ed4:	0f 0b                	ud2    
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  401ed6:	48 8b 7b 28          	mov    rdi,QWORD PTR [rbx+0x28]
  401eda:	48 8b 15 c7 ff 19 00 	mov    rdx,QWORD PTR [rip+0x19ffc7]        # 5a1ea8 <__slm_global+0x28>
  401ee1:	44 89 e1             	mov    ecx,r12d
  401ee4:	4c 89 c6             	mov    rsi,r8
  401ee7:	e8 a4 f4 00 00       	call   411390 <cos_sched_asnd>
  401eec:	e9 e3 fe ff ff       	jmp    401dd4 <sched_thd_exit+0x1c4>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  401ef1:	49 8b 56 30          	mov    rdx,QWORD PTR [r14+0x30]
  401ef5:	4c 8b 05 ac ff 19 00 	mov    r8,QWORD PTR [rip+0x19ffac]        # 5a1ea8 <__slm_global+0x28>
  401efc:	45 89 e1             	mov    r9d,r12d
  401eff:	31 c9                	xor    ecx,ecx
  401f01:	48 8b 3d 90 ff 19 00 	mov    rdi,QWORD PTR [rip+0x19ff90]        # 5a1e98 <__slm_global+0x18>
  401f08:	31 f6                	xor    esi,esi
  401f0a:	e8 11 f4 00 00       	call   411320 <cos_switch>
  401f0f:	e9 c0 fe ff ff       	jmp    401dd4 <sched_thd_exit+0x1c4>
  401f14:	be 61 00 00 00       	mov    esi,0x61
  401f19:	bf f8 b7 41 00       	mov    edi,0x41b7f8
  401f1e:	e8 ad 81 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  401f23:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401f2a:	00 00 00 00 
  401f2e:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  401f30:	41 89 c0             	mov    r8d,eax
  401f33:	4c 89 f2             	mov    rdx,r14
  401f36:	48 89 c6             	mov    rsi,rax
  401f39:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  401f3e:	41 83 e0 01          	and    r8d,0x1
  401f42:	e8 c9 18 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  401f47:	83 f8 f0             	cmp    eax,0xfffffff0
  401f4a:	0f 85 a8 fe ff ff    	jne    401df8 <sched_thd_exit+0x1e8>
  401f50:	e9 65 ff ff ff       	jmp    401eba <sched_thd_exit+0x2aa>
  401f55:	be 61 00 00 00       	mov    esi,0x61
  401f5a:	bf 60 b8 41 00       	mov    edi,0x41b860
  401f5f:	e8 6c 81 00 00       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  401f64:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401f6b:	00 00 00 00 
  401f6f:	0f 0b                	ud2    
  401f71:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  401f78:	00 00 00 00 
  401f7c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000401f80 <sched_thd_yield_to>:
{
  401f80:	f3 0f 1e fa          	endbr64 
  401f84:	55                   	push   rbp
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  401f85:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  401f88:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  401f8e:	48 89 e5             	mov    rbp,rsp
  401f91:	41 56                	push   r14
  401f93:	41 55                	push   r13
  401f95:	41 54                	push   r12
  401f97:	53                   	push   rbx
  401f98:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  401f9f:	48 85 c0             	test   rax,rax
  401fa2:	0f 84 b0 01 00 00    	je     402158 <sched_thd_yield_to+0x1d8>
  401fa8:	83 e8 01             	sub    eax,0x1
  401fab:	83 f8 18             	cmp    eax,0x18
  401fae:	0f 87 a4 01 00 00    	ja     402158 <sched_thd_yield_to+0x1d8>
  401fb4:	48 8b 14 c5 c0 e6 45 	mov    rdx,QWORD PTR [rax*8+0x45e6c0]
  401fbb:	00 
  401fbc:	45 31 e4             	xor    r12d,r12d
  401fbf:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  401fc6:	0f 85 44 01 00 00    	jne    402110 <sched_thd_yield_to+0x190>
  401fcc:	85 ff                	test   edi,edi
  401fce:	0f 84 64 01 00 00    	je     402138 <sched_thd_yield_to+0x1b8>
  401fd4:	83 ef 01             	sub    edi,0x1
  401fd7:	83 ff 18             	cmp    edi,0x18
  401fda:	0f 87 58 01 00 00    	ja     402138 <sched_thd_yield_to+0x1b8>
  401fe0:	89 f8                	mov    eax,edi
  401fe2:	48 8b 14 c5 c0 e6 45 	mov    rdx,QWORD PTR [rax*8+0x45e6c0]
  401fe9:	00 
  401fea:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  401ff1:	0f 84 41 01 00 00    	je     402138 <sched_thd_yield_to+0x1b8>
  401ff7:	83 e2 01             	and    edx,0x1
  401ffa:	0f 85 38 01 00 00    	jne    402138 <sched_thd_yield_to+0x1b8>
	return &ss_thd_get(id)->thd;
  402000:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  402004:	48 8d 04 50          	lea    rax,[rax+rdx*2]
  402008:	48 c1 e0 04          	shl    rax,0x4
  40200c:	4c 8d a8 88 e7 45 00 	lea    r13,[rax+0x45e788]
	assert(current);
  402013:	4d 85 e4             	test   r12,r12
  402016:	0f 84 80 01 00 00    	je     40219c <sched_thd_yield_to+0x21c>
		tok    = cos_sched_sync();
  40201c:	e8 df f2 00 00       	call   411300 <cos_sched_sync>
  402021:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  402024:	48 8b 05 55 fe 19 00 	mov    rax,QWORD PTR [rip+0x19fe55]        # 5a1e80 <__slm_global>
		if (unlikely(owner)) {
  40202b:	48 89 c1             	mov    rcx,rax
  40202e:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  402032:	0f 85 28 01 00 00    	jne    402160 <sched_thd_yield_to+0x1e0>
  402038:	f0 4c 0f b1 25 3f fe 	lock cmpxchg QWORD PTR [rip+0x19fe3f],r12        # 5a1e80 <__slm_global>
  40203f:	19 00 
  402041:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  402044:	84 c0                	test   al,al
  402046:	74 d4                	je     40201c <sched_thd_yield_to+0x9c>
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  402048:	4c 89 ee             	mov    rsi,r13
  40204b:	4c 89 e7             	mov    rdi,r12
	if (unlikely(!t)) t = &g->idle_thd;
  40204e:	41 be 00 1f 5a 00    	mov    r14d,0x5a1f00
  402054:	e8 37 05 01 00       	call   412590 <slm_sched_fprr_yield>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  402059:	e8 02 98 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	tok  = cos_sched_sync();
  40205e:	e8 9d f2 00 00       	call   411300 <cos_sched_sync>
  402063:	41 89 c5             	mov    r13d,eax
  402066:	e8 25 04 01 00       	call   412490 <slm_sched_fprr_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  40206b:	48 85 c0             	test   rax,rax
  40206e:	48 89 c3             	mov    rbx,rax
  402071:	49 0f 44 de          	cmove  rbx,r14
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  402075:	8b 43 04             	mov    eax,DWORD PTR [rbx+0x4]
  402078:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  40207b:	83 f8 01             	cmp    eax,0x1
  40207e:	76 18                	jbe    402098 <sched_thd_yield_to+0x118>
  402080:	e9 33 01 00 00       	jmp    4021b8 <sched_thd_yield_to+0x238>
  402085:	0f 1f 00             	nop    DWORD PTR [rax]
  402088:	f0 48 0f b1 15 ef fd 	lock cmpxchg QWORD PTR [rip+0x19fdef],rdx        # 5a1e80 <__slm_global>
  40208f:	19 00 
  402091:	0f 94 c0             	sete   al
	while (ret != 0) {
  402094:	84 c0                	test   al,al
  402096:	75 2e                	jne    4020c6 <sched_thd_yield_to+0x146>
		tok    = cos_sched_sync();
  402098:	e8 63 f2 00 00       	call   411300 <cos_sched_sync>
  40209d:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  40209f:	48 8b 05 da fd 19 00 	mov    rax,QWORD PTR [rip+0x19fdda]        # 5a1e80 <__slm_global>
		if (unlikely(contention)) {
  4020a6:	48 89 c2             	mov    rdx,rax
  4020a9:	83 e2 01             	and    edx,0x1
  4020ac:	74 da                	je     402088 <sched_thd_yield_to+0x108>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  4020ae:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  4020b1:	48 89 c2             	mov    rdx,rax
  4020b4:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  4020b9:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  4020bd:	e8 9e 17 01 00       	call   413860 <slm_cs_exit_contention>
  4020c2:	85 c0                	test   eax,eax
  4020c4:	75 d2                	jne    402098 <sched_thd_yield_to+0x118>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  4020c6:	e8 95 97 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4020cb:	8b 03                	mov    eax,DWORD PTR [rbx]
	timeout = g->timeout_next;
  4020cd:	4c 8b 05 b4 fe 19 00 	mov    r8,QWORD PTR [rip+0x19feb4]        # 5a1f88 <__slm_global+0x108>
	prio = inherit_prio ? curr->priority : t->priority;
  4020d4:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4020d8:	a8 0b                	test   al,0xb
  4020da:	0f 85 f4 00 00 00    	jne    4021d4 <sched_thd_yield_to+0x254>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  4020e0:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  4020e4:	44 89 e9             	mov    ecx,r13d
  4020e7:	4c 89 c2             	mov    rdx,r8
  4020ea:	e8 71 a6 00 00       	call   40c760 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  4020ef:	83 f8 ff             	cmp    eax,0xffffffff
  4020f2:	0f 84 1e 01 00 00    	je     402216 <sched_thd_yield_to+0x296>
	if (unlikely(ret != 0)) {
  4020f8:	85 c0                	test   eax,eax
  4020fa:	0f 85 70 01 00 00    	jne    402270 <sched_thd_yield_to+0x2f0>
  402100:	31 c0                	xor    eax,eax
}
  402102:	5b                   	pop    rbx
  402103:	41 5c                	pop    r12
  402105:	41 5d                	pop    r13
  402107:	41 5e                	pop    r14
  402109:	5d                   	pop    rbp
  40210a:	c3                   	ret    
  40210b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  402110:	83 e2 01             	and    edx,0x1
  402113:	0f 85 b3 fe ff ff    	jne    401fcc <sched_thd_yield_to+0x4c>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  402119:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  40211d:	4c 8d 24 50          	lea    r12,[rax+rdx*2]
  402121:	49 c1 e4 04          	shl    r12,0x4
  402125:	49 81 c4 88 e7 45 00 	add    r12,0x45e788
  40212c:	85 ff                	test   edi,edi
  40212e:	0f 85 a0 fe ff ff    	jne    401fd4 <sched_thd_yield_to+0x54>
  402134:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  402138:	be 24 00 00 00       	mov    esi,0x24
  40213d:	bf 40 bb 41 00       	mov    edi,0x41bb40
  402142:	e8 89 7f 00 00       	call   40a0d0 <cos_print_str>
	assert(to);
  402147:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40214e:	00 00 00 00 
  402152:	0f 0b                	ud2    
  402154:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  402158:	45 31 e4             	xor    r12d,r12d
  40215b:	e9 6c fe ff ff       	jmp    401fcc <sched_thd_yield_to+0x4c>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  402160:	41 89 c0             	mov    r8d,eax
  402163:	4c 89 e2             	mov    rdx,r12
  402166:	48 89 c6             	mov    rsi,rax
  402169:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  40216e:	41 83 e0 01          	and    r8d,0x1
  402172:	e8 99 16 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  402177:	83 f8 f0             	cmp    eax,0xfffffff0
  40217a:	0f 85 9c fe ff ff    	jne    40201c <sched_thd_yield_to+0x9c>
  402180:	be 59 00 00 00       	mov    esi,0x59
  402185:	bf a0 b6 41 00       	mov    edi,0x41b6a0
  40218a:	e8 41 7f 00 00       	call   40a0d0 <cos_print_str>
  40218f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402196:	00 00 00 00 
  40219a:	0f 0b                	ud2    
  40219c:	be 59 00 00 00       	mov    esi,0x59
  4021a1:	bf 40 b6 41 00       	mov    edi,0x41b640
  4021a6:	e8 25 7f 00 00       	call   40a0d0 <cos_print_str>
	assert(current);
  4021ab:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4021b2:	00 00 00 00 
  4021b6:	0f 0b                	ud2    
  4021b8:	be 61 00 00 00       	mov    esi,0x61
  4021bd:	bf 28 b7 41 00       	mov    edi,0x41b728
  4021c2:	e8 09 7f 00 00       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  4021c7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4021ce:	00 00 00 00 
  4021d2:	0f 0b                	ud2    
	timeout = g->timeout_next;
  4021d4:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  4021d7:	48 81 fb 88 1e 5a 00 	cmp    rbx,0x5a1e88
  4021de:	0f 84 d1 00 00 00    	je     4022b5 <sched_thd_yield_to+0x335>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  4021e4:	a8 02                	test   al,0x2
  4021e6:	0f 85 d5 00 00 00    	jne    4022c1 <sched_thd_yield_to+0x341>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  4021ec:	49 89 c8             	mov    r8,rcx
  4021ef:	a8 01                	test   al,0x1
  4021f1:	0f 84 e9 fe ff ff    	je     4020e0 <sched_thd_yield_to+0x160>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  4021f7:	4c 8b 53 08          	mov    r10,QWORD PTR [rbx+0x8]
  4021fb:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  4021ff:	48 89 f2             	mov    rdx,rsi
  402202:	45 89 e9             	mov    r9d,r13d
  402205:	4c 8b 05 9c fc 19 00 	mov    r8,QWORD PTR [rip+0x19fc9c]        # 5a1ea8 <__slm_global+0x28>
  40220c:	4c 89 d6             	mov    rsi,r10
  40220f:	e8 0c f1 00 00       	call   411320 <cos_switch>
  402214:	eb 4d                	jmp    402263 <sched_thd_yield_to+0x2e3>
	return t != &g->idle_thd && t != &g->sched_thd;
  402216:	48 81 fb 88 1e 5a 00 	cmp    rbx,0x5a1e88
  40221d:	74 25                	je     402244 <sched_thd_yield_to+0x2c4>
  40221f:	48 81 fb 00 1f 5a 00 	cmp    rbx,0x5a1f00
  402226:	74 1c                	je     402244 <sched_thd_yield_to+0x2c4>
  402228:	be 61 00 00 00       	mov    esi,0x61
  40222d:	bf 90 b7 41 00       	mov    edi,0x41b790
  402232:	e8 99 7e 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EPERM);
  402237:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40223e:	00 00 00 00 
  402242:	0f 0b                	ud2    
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  402244:	49 8b 54 24 30       	mov    rdx,QWORD PTR [r12+0x30]
  402249:	4c 8b 05 58 fc 19 00 	mov    r8,QWORD PTR [rip+0x19fc58]        # 5a1ea8 <__slm_global+0x28>
  402250:	31 c9                	xor    ecx,ecx
  402252:	31 f6                	xor    esi,esi
  402254:	48 8b 3d 3d fc 19 00 	mov    rdi,QWORD PTR [rip+0x19fc3d]        # 5a1e98 <__slm_global+0x18>
  40225b:	45 89 e9             	mov    r9d,r13d
  40225e:	e8 bd f0 00 00       	call   411320 <cos_switch>
	if (unlikely(ret != 0)) {
  402263:	85 c0                	test   eax,eax
  402265:	0f 84 95 fe ff ff    	je     402100 <sched_thd_yield_to+0x180>
		assert(ret != -EPERM);
  40226b:	83 f8 ff             	cmp    eax,0xffffffff
  40226e:	74 b8                	je     402228 <sched_thd_yield_to+0x2a8>
		assert(ret != -EINVAL);
  402270:	83 f8 ea             	cmp    eax,0xffffffea
  402273:	74 64                	je     4022d9 <sched_thd_yield_to+0x359>
		if (ret == -EBUSY) return ret;
  402275:	83 f8 f0             	cmp    eax,0xfffffff0
  402278:	0f 84 84 fe ff ff    	je     402102 <sched_thd_yield_to+0x182>
		assert(ret == -EAGAIN);
  40227e:	83 f8 f5             	cmp    eax,0xfffffff5
  402281:	0f 85 99 00 00 00    	jne    402320 <sched_thd_yield_to+0x3a0>
		tok    = cos_sched_sync();
  402287:	e8 74 f0 00 00       	call   411300 <cos_sched_sync>
  40228c:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  40228f:	48 8b 05 ea fb 19 00 	mov    rax,QWORD PTR [rip+0x19fbea]        # 5a1e80 <__slm_global>
		if (unlikely(owner)) {
  402296:	48 89 c1             	mov    rcx,rax
  402299:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  40229d:	75 56                	jne    4022f5 <sched_thd_yield_to+0x375>
  40229f:	f0 4c 0f b1 25 d8 fb 	lock cmpxchg QWORD PTR [rip+0x19fbd8],r12        # 5a1e80 <__slm_global>
  4022a6:	19 00 
  4022a8:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4022ab:	84 c0                	test   al,al
  4022ad:	0f 85 ab fd ff ff    	jne    40205e <sched_thd_yield_to+0xde>
  4022b3:	eb d2                	jmp    402287 <sched_thd_yield_to+0x307>
			prio    = curr->priority;
  4022b5:	49 8b 74 24 30       	mov    rsi,QWORD PTR [r12+0x30]
			timeout = TCAP_TIME_NIL;
  4022ba:	31 c9                	xor    ecx,ecx
  4022bc:	e9 23 ff ff ff       	jmp    4021e4 <sched_thd_yield_to+0x264>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  4022c1:	48 8b 7b 28          	mov    rdi,QWORD PTR [rbx+0x28]
  4022c5:	48 8b 15 dc fb 19 00 	mov    rdx,QWORD PTR [rip+0x19fbdc]        # 5a1ea8 <__slm_global+0x28>
  4022cc:	44 89 e9             	mov    ecx,r13d
  4022cf:	4c 89 c6             	mov    rsi,r8
  4022d2:	e8 b9 f0 00 00       	call   411390 <cos_sched_asnd>
  4022d7:	eb 8a                	jmp    402263 <sched_thd_yield_to+0x2e3>
  4022d9:	be 61 00 00 00       	mov    esi,0x61
  4022de:	bf f8 b7 41 00       	mov    edi,0x41b7f8
  4022e3:	e8 e8 7d 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  4022e8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4022ef:	00 00 00 00 
  4022f3:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  4022f5:	41 89 c0             	mov    r8d,eax
  4022f8:	4c 89 e2             	mov    rdx,r12
  4022fb:	48 89 c6             	mov    rsi,rax
  4022fe:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  402303:	41 83 e0 01          	and    r8d,0x1
  402307:	e8 04 15 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  40230c:	83 f8 f0             	cmp    eax,0xfffffff0
  40230f:	0f 85 72 ff ff ff    	jne    402287 <sched_thd_yield_to+0x307>
  402315:	e9 66 fe ff ff       	jmp    402180 <sched_thd_yield_to+0x200>
  40231a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  402320:	be 61 00 00 00       	mov    esi,0x61
  402325:	bf 60 b8 41 00       	mov    edi,0x41b860
  40232a:	e8 a1 7d 00 00       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  40232f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402336:	00 00 00 00 
  40233a:	0f 0b                	ud2    
  40233c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000402340 <sched_set_tls>:
{
  402340:	f3 0f 1e fa          	endbr64 
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  402344:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  402347:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  40234d:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  402354:	48 85 c0             	test   rax,rax
  402357:	0f 84 03 2b 01 00    	je     414e60 <sched_set_tls.cold>
  40235d:	83 e8 01             	sub    eax,0x1
  402360:	83 f8 18             	cmp    eax,0x18
  402363:	0f 87 f7 2a 01 00    	ja     414e60 <sched_set_tls.cold>
  402369:	48 8b 14 c5 c0 e6 45 	mov    rdx,QWORD PTR [rax*8+0x45e6c0]
  402370:	00 
  402371:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  402378:	0f 84 e2 2a 01 00    	je     414e60 <sched_set_tls.cold>
  40237e:	83 e2 01             	and    edx,0x1
  402381:	0f 85 d9 2a 01 00    	jne    414e60 <sched_set_tls.cold>
	thdcap_t thdcap = current->thd;
  402387:	48 8d 14 80          	lea    rdx,[rax+rax*4]
	capmgr_set_tls(thdcap, tls_addr);
  40238b:	48 89 fe             	mov    rsi,rdi
	thdcap_t thdcap = current->thd;
  40238e:	48 8d 04 50          	lea    rax,[rax+rdx*2]
  402392:	48 c1 e0 04          	shl    rax,0x4
	capmgr_set_tls(thdcap, tls_addr);
  402396:	4c 8b 80 98 e7 45 00 	mov    r8,QWORD PTR [rax+0x45e798]
  40239d:	4c 89 c7             	mov    rdi,r8
  4023a0:	e9 3b 50 00 00       	jmp    4073e0 <__cosrt_extern_capmgr_set_tls>
  4023a5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4023ac:	00 00 00 00 

00000000004023b0 <thd_block>:
{
  4023b0:	f3 0f 1e fa          	endbr64 
  4023b4:	55                   	push   rbp
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  4023b5:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  4023b8:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  4023be:	48 89 e5             	mov    rbp,rsp
  4023c1:	41 57                	push   r15
  4023c3:	41 56                	push   r14
  4023c5:	41 55                	push   r13
  4023c7:	41 54                	push   r12
  4023c9:	53                   	push   rbx
  4023ca:	48 83 ec 08          	sub    rsp,0x8
  4023ce:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  4023d5:	48 85 c0             	test   rax,rax
  4023d8:	0f 84 82 01 00 00    	je     402560 <thd_block+0x1b0>
  4023de:	83 e8 01             	sub    eax,0x1
  4023e1:	83 f8 18             	cmp    eax,0x18
  4023e4:	0f 87 76 01 00 00    	ja     402560 <thd_block+0x1b0>
  4023ea:	48 8b 14 c5 c0 e6 45 	mov    rdx,QWORD PTR [rax*8+0x45e6c0]
  4023f1:	00 
  4023f2:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  4023f9:	0f 84 61 01 00 00    	je     402560 <thd_block+0x1b0>
  4023ff:	83 e2 01             	and    edx,0x1
  402402:	0f 85 58 01 00 00    	jne    402560 <thd_block+0x1b0>
  402408:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  40240c:	48 8d 1c 50          	lea    rbx,[rax+rdx*2]
  402410:	48 c1 e3 04          	shl    rbx,0x4
  402414:	48 81 c3 88 e7 45 00 	add    rbx,0x45e788
		tok    = cos_sched_sync();
  40241b:	e8 e0 ee 00 00       	call   411300 <cos_sched_sync>
  402420:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  402423:	48 8b 05 56 fa 19 00 	mov    rax,QWORD PTR [rip+0x19fa56]        # 5a1e80 <__slm_global>
		if (unlikely(owner)) {
  40242a:	48 89 c1             	mov    rcx,rax
  40242d:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  402431:	0f 85 49 01 00 00    	jne    402580 <thd_block+0x1d0>
  402437:	f0 48 0f b1 1d 40 fa 	lock cmpxchg QWORD PTR [rip+0x19fa40],rbx        # 5a1e80 <__slm_global>
  40243e:	19 00 
  402440:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  402443:	84 c0                	test   al,al
  402445:	74 d4                	je     40241b <thd_block+0x6b>
        ret = slm_thd_block(current);
  402447:	48 89 df             	mov    rdi,rbx
  40244a:	e8 71 14 01 00       	call   4138c0 <slm_thd_block>
  40244f:	41 89 c5             	mov    r13d,eax
	if (!ret) ret = slm_cs_exit_reschedule(current, SLM_CS_NONE);
  402452:	85 c0                	test   eax,eax
  402454:	0f 85 d6 00 00 00    	jne    402530 <thd_block+0x180>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  40245a:	e8 01 94 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(!t)) t = &g->idle_thd;
  40245f:	41 bf 00 1f 5a 00    	mov    r15d,0x5a1f00
	tok  = cos_sched_sync();
  402465:	e8 96 ee 00 00       	call   411300 <cos_sched_sync>
  40246a:	41 89 c6             	mov    r14d,eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  40246d:	e8 1e 00 01 00       	call   412490 <slm_sched_fprr_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  402472:	48 85 c0             	test   rax,rax
  402475:	49 89 c4             	mov    r12,rax
  402478:	4d 0f 44 e7          	cmove  r12,r15
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  40247c:	41 8b 44 24 04       	mov    eax,DWORD PTR [r12+0x4]
  402481:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  402484:	83 f8 01             	cmp    eax,0x1
  402487:	76 17                	jbe    4024a0 <thd_block+0xf0>
  402489:	e9 82 01 00 00       	jmp    402610 <thd_block+0x260>
  40248e:	66 90                	xchg   ax,ax
  402490:	f0 48 0f b1 15 e7 f9 	lock cmpxchg QWORD PTR [rip+0x19f9e7],rdx        # 5a1e80 <__slm_global>
  402497:	19 00 
  402499:	0f 94 c0             	sete   al
	while (ret != 0) {
  40249c:	84 c0                	test   al,al
  40249e:	75 2e                	jne    4024ce <thd_block+0x11e>
		tok    = cos_sched_sync();
  4024a0:	e8 5b ee 00 00       	call   411300 <cos_sched_sync>
  4024a5:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4024a7:	48 8b 05 d2 f9 19 00 	mov    rax,QWORD PTR [rip+0x19f9d2]        # 5a1e80 <__slm_global>
		if (unlikely(contention)) {
  4024ae:	48 89 c2             	mov    rdx,rax
  4024b1:	83 e2 01             	and    edx,0x1
  4024b4:	74 da                	je     402490 <thd_block+0xe0>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  4024b6:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  4024b9:	48 89 c2             	mov    rdx,rax
  4024bc:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  4024c1:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  4024c5:	e8 96 13 01 00       	call   413860 <slm_cs_exit_contention>
  4024ca:	85 c0                	test   eax,eax
  4024cc:	75 d2                	jne    4024a0 <thd_block+0xf0>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  4024ce:	e8 8d 93 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4024d3:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
	prio = inherit_prio ? curr->priority : t->priority;
  4024d7:	49 8b 74 24 30       	mov    rsi,QWORD PTR [r12+0x30]
	timeout = g->timeout_next;
  4024dc:	4c 8b 05 a5 fa 19 00 	mov    r8,QWORD PTR [rip+0x19faa5]        # 5a1f88 <__slm_global+0x108>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4024e3:	a8 0b                	test   al,0xb
  4024e5:	0f 85 41 01 00 00    	jne    40262c <thd_block+0x27c>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  4024eb:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  4024f0:	44 89 f1             	mov    ecx,r14d
  4024f3:	4c 89 c2             	mov    rdx,r8
  4024f6:	e8 65 a2 00 00       	call   40c760 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  4024fb:	83 f8 ff             	cmp    eax,0xffffffff
  4024fe:	0f 84 97 01 00 00    	je     40269b <thd_block+0x2eb>
	if (unlikely(ret != 0)) {
  402504:	85 c0                	test   eax,eax
  402506:	0f 85 b0 00 00 00    	jne    4025bc <thd_block+0x20c>
}
  40250c:	48 83 c4 08          	add    rsp,0x8
  402510:	44 89 e8             	mov    eax,r13d
  402513:	5b                   	pop    rbx
  402514:	41 5c                	pop    r12
  402516:	41 5d                	pop    r13
  402518:	41 5e                	pop    r14
  40251a:	41 5f                	pop    r15
  40251c:	5d                   	pop    rbp
  40251d:	c3                   	ret    
  40251e:	66 90                	xchg   ax,ax
  402520:	f0 48 0f b1 15 57 f9 	lock cmpxchg QWORD PTR [rip+0x19f957],rdx        # 5a1e80 <__slm_global>
  402527:	19 00 
  402529:	0f 94 c0             	sete   al
	while (ret != 0) {
  40252c:	84 c0                	test   al,al
  40252e:	75 dc                	jne    40250c <thd_block+0x15c>
		tok    = cos_sched_sync();
  402530:	e8 cb ed 00 00       	call   411300 <cos_sched_sync>
  402535:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  402537:	48 8b 05 42 f9 19 00 	mov    rax,QWORD PTR [rip+0x19f942]        # 5a1e80 <__slm_global>
		if (unlikely(contention)) {
  40253e:	48 89 c2             	mov    rdx,rax
  402541:	83 e2 01             	and    edx,0x1
  402544:	74 da                	je     402520 <thd_block+0x170>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  402546:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  402549:	48 89 c2             	mov    rdx,rax
  40254c:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  402551:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  402555:	e8 06 13 01 00       	call   413860 <slm_cs_exit_contention>
  40255a:	85 c0                	test   eax,eax
  40255c:	74 ae                	je     40250c <thd_block+0x15c>
  40255e:	eb d0                	jmp    402530 <thd_block+0x180>
  402560:	be 59 00 00 00       	mov    esi,0x59
  402565:	bf 40 b6 41 00       	mov    edi,0x41b640
  40256a:	e8 61 7b 00 00       	call   40a0d0 <cos_print_str>
	assert(current);
  40256f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402576:	00 00 00 00 
  40257a:	0f 0b                	ud2    
  40257c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  402580:	41 89 c0             	mov    r8d,eax
  402583:	48 89 da             	mov    rdx,rbx
  402586:	48 89 c6             	mov    rsi,rax
  402589:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  40258e:	41 83 e0 01          	and    r8d,0x1
  402592:	e8 79 12 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  402597:	83 f8 f0             	cmp    eax,0xfffffff0
  40259a:	0f 85 7b fe ff ff    	jne    40241b <thd_block+0x6b>
  4025a0:	be 59 00 00 00       	mov    esi,0x59
  4025a5:	bf a0 b6 41 00       	mov    edi,0x41b6a0
  4025aa:	e8 21 7b 00 00       	call   40a0d0 <cos_print_str>
  4025af:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4025b6:	00 00 00 00 
  4025ba:	0f 0b                	ud2    
		assert(ret != -EINVAL);
  4025bc:	83 f8 ea             	cmp    eax,0xffffffea
  4025bf:	0f 84 2f 01 00 00    	je     4026f4 <thd_block+0x344>
		if (ret == -EBUSY) return ret;
  4025c5:	83 f8 f0             	cmp    eax,0xfffffff0
  4025c8:	0f 84 86 01 00 00    	je     402754 <thd_block+0x3a4>
		assert(ret == -EAGAIN);
  4025ce:	83 f8 f5             	cmp    eax,0xfffffff5
  4025d1:	0f 85 61 01 00 00    	jne    402738 <thd_block+0x388>
		tok    = cos_sched_sync();
  4025d7:	e8 24 ed 00 00       	call   411300 <cos_sched_sync>
  4025dc:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4025df:	48 8b 05 9a f8 19 00 	mov    rax,QWORD PTR [rip+0x19f89a]        # 5a1e80 <__slm_global>
		if (unlikely(owner)) {
  4025e6:	48 89 c1             	mov    rcx,rax
  4025e9:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  4025ed:	0f 85 1d 01 00 00    	jne    402710 <thd_block+0x360>
  4025f3:	f0 48 0f b1 1d 84 f8 	lock cmpxchg QWORD PTR [rip+0x19f884],rbx        # 5a1e80 <__slm_global>
  4025fa:	19 00 
  4025fc:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4025ff:	84 c0                	test   al,al
  402601:	0f 85 5e fe ff ff    	jne    402465 <thd_block+0xb5>
  402607:	eb ce                	jmp    4025d7 <thd_block+0x227>
  402609:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  402610:	be 61 00 00 00       	mov    esi,0x61
  402615:	bf 28 b7 41 00       	mov    edi,0x41b728
  40261a:	e8 b1 7a 00 00       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  40261f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402626:	00 00 00 00 
  40262a:	0f 0b                	ud2    
	timeout = g->timeout_next;
  40262c:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  40262f:	49 81 fc 88 1e 5a 00 	cmp    r12,0x5a1e88
  402636:	0f 84 91 00 00 00    	je     4026cd <thd_block+0x31d>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  40263c:	a8 02                	test   al,0x2
  40263e:	0f 85 94 00 00 00    	jne    4026d8 <thd_block+0x328>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  402644:	49 89 c8             	mov    r8,rcx
  402647:	a8 01                	test   al,0x1
  402649:	0f 84 9c fe ff ff    	je     4024eb <thd_block+0x13b>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  40264f:	4d 8b 54 24 08       	mov    r10,QWORD PTR [r12+0x8]
  402654:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  402659:	48 89 f2             	mov    rdx,rsi
  40265c:	45 89 f1             	mov    r9d,r14d
  40265f:	4c 8b 05 42 f8 19 00 	mov    r8,QWORD PTR [rip+0x19f842]        # 5a1ea8 <__slm_global+0x28>
  402666:	4c 89 d6             	mov    rsi,r10
  402669:	e8 b2 ec 00 00       	call   411320 <cos_switch>
	if (unlikely(ret != 0)) {
  40266e:	85 c0                	test   eax,eax
  402670:	0f 84 96 fe ff ff    	je     40250c <thd_block+0x15c>
		assert(ret != -EPERM);
  402676:	83 f8 ff             	cmp    eax,0xffffffff
  402679:	0f 85 3d ff ff ff    	jne    4025bc <thd_block+0x20c>
  40267f:	be 61 00 00 00       	mov    esi,0x61
  402684:	bf 90 b7 41 00       	mov    edi,0x41b790
  402689:	e8 42 7a 00 00       	call   40a0d0 <cos_print_str>
  40268e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402695:	00 00 00 00 
  402699:	0f 0b                	ud2    
	return t != &g->idle_thd && t != &g->sched_thd;
  40269b:	49 81 fc 00 1f 5a 00 	cmp    r12,0x5a1f00
  4026a2:	74 09                	je     4026ad <thd_block+0x2fd>
  4026a4:	49 81 fc 88 1e 5a 00 	cmp    r12,0x5a1e88
  4026ab:	75 d2                	jne    40267f <thd_block+0x2cf>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  4026ad:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]
  4026b1:	4c 8b 05 f0 f7 19 00 	mov    r8,QWORD PTR [rip+0x19f7f0]        # 5a1ea8 <__slm_global+0x28>
  4026b8:	45 89 f1             	mov    r9d,r14d
  4026bb:	31 c9                	xor    ecx,ecx
  4026bd:	48 8b 3d d4 f7 19 00 	mov    rdi,QWORD PTR [rip+0x19f7d4]        # 5a1e98 <__slm_global+0x18>
  4026c4:	31 f6                	xor    esi,esi
  4026c6:	e8 55 ec 00 00       	call   411320 <cos_switch>
  4026cb:	eb a1                	jmp    40266e <thd_block+0x2be>
			prio    = curr->priority;
  4026cd:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
			timeout = TCAP_TIME_NIL;
  4026d1:	31 c9                	xor    ecx,ecx
  4026d3:	e9 64 ff ff ff       	jmp    40263c <thd_block+0x28c>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  4026d8:	49 8b 7c 24 28       	mov    rdi,QWORD PTR [r12+0x28]
  4026dd:	48 8b 15 c4 f7 19 00 	mov    rdx,QWORD PTR [rip+0x19f7c4]        # 5a1ea8 <__slm_global+0x28>
  4026e4:	44 89 f1             	mov    ecx,r14d
  4026e7:	4c 89 c6             	mov    rsi,r8
  4026ea:	e8 a1 ec 00 00       	call   411390 <cos_sched_asnd>
  4026ef:	e9 7a ff ff ff       	jmp    40266e <thd_block+0x2be>
  4026f4:	be 61 00 00 00       	mov    esi,0x61
  4026f9:	bf f8 b7 41 00       	mov    edi,0x41b7f8
  4026fe:	e8 cd 79 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  402703:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40270a:	00 00 00 00 
  40270e:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  402710:	41 89 c0             	mov    r8d,eax
  402713:	48 89 da             	mov    rdx,rbx
  402716:	48 89 c6             	mov    rsi,rax
  402719:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  40271e:	41 83 e0 01          	and    r8d,0x1
  402722:	e8 e9 10 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  402727:	83 f8 f0             	cmp    eax,0xfffffff0
  40272a:	0f 85 a7 fe ff ff    	jne    4025d7 <thd_block+0x227>
  402730:	e9 6b fe ff ff       	jmp    4025a0 <thd_block+0x1f0>
  402735:	0f 1f 00             	nop    DWORD PTR [rax]
  402738:	be 61 00 00 00       	mov    esi,0x61
  40273d:	bf 60 b8 41 00       	mov    edi,0x41b860
  402742:	e8 89 79 00 00       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  402747:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40274e:	00 00 00 00 
  402752:	0f 0b                	ud2    
	ret = slm_thd_activate(curr, t, tok, 0);
  402754:	41 bd f0 ff ff ff    	mov    r13d,0xfffffff0
	return ret;
  40275a:	e9 ad fd ff ff       	jmp    40250c <thd_block+0x15c>
  40275f:	90                   	nop

0000000000402760 <sched_thd_block>:
{
  402760:	f3 0f 1e fa          	endbr64 
  402764:	55                   	push   rbp
  402765:	48 89 e5             	mov    rbp,rsp
  402768:	41 57                	push   r15
  40276a:	41 56                	push   r14
  40276c:	41 55                	push   r13
  40276e:	41 54                	push   r12
  402770:	53                   	push   rbx
  402771:	48 83 ec 08          	sub    rsp,0x8
	if (dep_id) return -1;
  402775:	48 85 ff             	test   rdi,rdi
  402778:	0f 85 0f 03 00 00    	jne    402a8d <sched_thd_block+0x32d>
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  40277e:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  402781:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  402787:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  40278e:	48 85 c0             	test   rax,rax
  402791:	0f 84 89 01 00 00    	je     402920 <sched_thd_block+0x1c0>
  402797:	83 e8 01             	sub    eax,0x1
  40279a:	83 f8 18             	cmp    eax,0x18
  40279d:	0f 87 7d 01 00 00    	ja     402920 <sched_thd_block+0x1c0>
  4027a3:	48 8b 14 c5 c0 e6 45 	mov    rdx,QWORD PTR [rax*8+0x45e6c0]
  4027aa:	00 
  4027ab:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  4027b2:	0f 84 68 01 00 00    	je     402920 <sched_thd_block+0x1c0>
  4027b8:	83 e2 01             	and    edx,0x1
  4027bb:	0f 85 5f 01 00 00    	jne    402920 <sched_thd_block+0x1c0>
  4027c1:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  4027c5:	48 8d 1c 50          	lea    rbx,[rax+rdx*2]
  4027c9:	48 c1 e3 04          	shl    rbx,0x4
  4027cd:	48 81 c3 88 e7 45 00 	add    rbx,0x45e788
		tok    = cos_sched_sync();
  4027d4:	e8 27 eb 00 00       	call   411300 <cos_sched_sync>
  4027d9:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4027dc:	48 8b 05 9d f6 19 00 	mov    rax,QWORD PTR [rip+0x19f69d]        # 5a1e80 <__slm_global>
		if (unlikely(owner)) {
  4027e3:	48 89 c1             	mov    rcx,rax
  4027e6:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  4027ea:	0f 85 50 01 00 00    	jne    402940 <sched_thd_block+0x1e0>
  4027f0:	f0 48 0f b1 1d 87 f6 	lock cmpxchg QWORD PTR [rip+0x19f687],rbx        # 5a1e80 <__slm_global>
  4027f7:	19 00 
  4027f9:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4027fc:	84 c0                	test   al,al
  4027fe:	74 d4                	je     4027d4 <sched_thd_block+0x74>
        ret = slm_thd_block(current);
  402800:	48 89 df             	mov    rdi,rbx
  402803:	e8 b8 10 01 00       	call   4138c0 <slm_thd_block>
  402808:	41 89 c5             	mov    r13d,eax
	if (!ret) ret = slm_cs_exit_reschedule(current, SLM_CS_NONE);
  40280b:	85 c0                	test   eax,eax
  40280d:	0f 85 dd 00 00 00    	jne    4028f0 <sched_thd_block+0x190>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  402813:	e8 48 90 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(!t)) t = &g->idle_thd;
  402818:	41 bf 00 1f 5a 00    	mov    r15d,0x5a1f00
	tok  = cos_sched_sync();
  40281e:	e8 dd ea 00 00       	call   411300 <cos_sched_sync>
  402823:	41 89 c6             	mov    r14d,eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  402826:	e8 65 fc 00 00       	call   412490 <slm_sched_fprr_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  40282b:	48 85 c0             	test   rax,rax
  40282e:	49 89 c4             	mov    r12,rax
  402831:	4d 0f 44 e7          	cmove  r12,r15
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  402835:	41 8b 44 24 04       	mov    eax,DWORD PTR [r12+0x4]
  40283a:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  40283d:	83 f8 01             	cmp    eax,0x1
  402840:	76 1e                	jbe    402860 <sched_thd_block+0x100>
  402842:	e9 89 01 00 00       	jmp    4029d0 <sched_thd_block+0x270>
  402847:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40284e:	00 00 
  402850:	f0 48 0f b1 15 27 f6 	lock cmpxchg QWORD PTR [rip+0x19f627],rdx        # 5a1e80 <__slm_global>
  402857:	19 00 
  402859:	0f 94 c0             	sete   al
	while (ret != 0) {
  40285c:	84 c0                	test   al,al
  40285e:	75 2e                	jne    40288e <sched_thd_block+0x12e>
		tok    = cos_sched_sync();
  402860:	e8 9b ea 00 00       	call   411300 <cos_sched_sync>
  402865:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  402867:	48 8b 05 12 f6 19 00 	mov    rax,QWORD PTR [rip+0x19f612]        # 5a1e80 <__slm_global>
		if (unlikely(contention)) {
  40286e:	48 89 c2             	mov    rdx,rax
  402871:	83 e2 01             	and    edx,0x1
  402874:	74 da                	je     402850 <sched_thd_block+0xf0>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  402876:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  402879:	48 89 c2             	mov    rdx,rax
  40287c:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  402881:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  402885:	e8 d6 0f 01 00       	call   413860 <slm_cs_exit_contention>
  40288a:	85 c0                	test   eax,eax
  40288c:	75 d2                	jne    402860 <sched_thd_block+0x100>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  40288e:	e8 cd 8f 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  402893:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
	prio = inherit_prio ? curr->priority : t->priority;
  402897:	49 8b 74 24 30       	mov    rsi,QWORD PTR [r12+0x30]
	timeout = g->timeout_next;
  40289c:	4c 8b 05 e5 f6 19 00 	mov    r8,QWORD PTR [rip+0x19f6e5]        # 5a1f88 <__slm_global+0x108>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4028a3:	a8 0b                	test   al,0xb
  4028a5:	0f 85 41 01 00 00    	jne    4029ec <sched_thd_block+0x28c>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  4028ab:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  4028b0:	44 89 f1             	mov    ecx,r14d
  4028b3:	4c 89 c2             	mov    rdx,r8
  4028b6:	e8 a5 9e 00 00       	call   40c760 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  4028bb:	83 f8 ff             	cmp    eax,0xffffffff
  4028be:	0f 84 97 01 00 00    	je     402a5b <sched_thd_block+0x2fb>
	if (unlikely(ret != 0)) {
  4028c4:	85 c0                	test   eax,eax
  4028c6:	0f 85 b0 00 00 00    	jne    40297c <sched_thd_block+0x21c>
}
  4028cc:	48 83 c4 08          	add    rsp,0x8
  4028d0:	44 89 e8             	mov    eax,r13d
  4028d3:	5b                   	pop    rbx
  4028d4:	41 5c                	pop    r12
  4028d6:	41 5d                	pop    r13
  4028d8:	41 5e                	pop    r14
  4028da:	41 5f                	pop    r15
  4028dc:	5d                   	pop    rbp
  4028dd:	c3                   	ret    
  4028de:	66 90                	xchg   ax,ax
  4028e0:	f0 48 0f b1 15 97 f5 	lock cmpxchg QWORD PTR [rip+0x19f597],rdx        # 5a1e80 <__slm_global>
  4028e7:	19 00 
  4028e9:	0f 94 c0             	sete   al
	while (ret != 0) {
  4028ec:	84 c0                	test   al,al
  4028ee:	75 dc                	jne    4028cc <sched_thd_block+0x16c>
		tok    = cos_sched_sync();
  4028f0:	e8 0b ea 00 00       	call   411300 <cos_sched_sync>
  4028f5:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4028f7:	48 8b 05 82 f5 19 00 	mov    rax,QWORD PTR [rip+0x19f582]        # 5a1e80 <__slm_global>
		if (unlikely(contention)) {
  4028fe:	48 89 c2             	mov    rdx,rax
  402901:	83 e2 01             	and    edx,0x1
  402904:	74 da                	je     4028e0 <sched_thd_block+0x180>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  402906:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  402909:	48 89 c2             	mov    rdx,rax
  40290c:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  402911:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  402915:	e8 46 0f 01 00       	call   413860 <slm_cs_exit_contention>
  40291a:	85 c0                	test   eax,eax
  40291c:	74 ae                	je     4028cc <sched_thd_block+0x16c>
  40291e:	eb d0                	jmp    4028f0 <sched_thd_block+0x190>
  402920:	be 59 00 00 00       	mov    esi,0x59
  402925:	bf 40 b6 41 00       	mov    edi,0x41b640
  40292a:	e8 a1 77 00 00       	call   40a0d0 <cos_print_str>
	assert(current);
  40292f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402936:	00 00 00 00 
  40293a:	0f 0b                	ud2    
  40293c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  402940:	41 89 c0             	mov    r8d,eax
  402943:	48 89 da             	mov    rdx,rbx
  402946:	48 89 c6             	mov    rsi,rax
  402949:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  40294e:	41 83 e0 01          	and    r8d,0x1
  402952:	e8 b9 0e 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  402957:	83 f8 f0             	cmp    eax,0xfffffff0
  40295a:	0f 85 74 fe ff ff    	jne    4027d4 <sched_thd_block+0x74>
  402960:	be 59 00 00 00       	mov    esi,0x59
  402965:	bf a0 b6 41 00       	mov    edi,0x41b6a0
  40296a:	e8 61 77 00 00       	call   40a0d0 <cos_print_str>
  40296f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402976:	00 00 00 00 
  40297a:	0f 0b                	ud2    
		assert(ret != -EINVAL);
  40297c:	83 f8 ea             	cmp    eax,0xffffffea
  40297f:	0f 84 3a 01 00 00    	je     402abf <sched_thd_block+0x35f>
		if (ret == -EBUSY) return ret;
  402985:	83 f8 f0             	cmp    eax,0xfffffff0
  402988:	0f 84 8e 01 00 00    	je     402b1c <sched_thd_block+0x3bc>
		assert(ret == -EAGAIN);
  40298e:	83 f8 f5             	cmp    eax,0xfffffff5
  402991:	0f 85 69 01 00 00    	jne    402b00 <sched_thd_block+0x3a0>
		tok    = cos_sched_sync();
  402997:	e8 64 e9 00 00       	call   411300 <cos_sched_sync>
  40299c:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  40299f:	48 8b 05 da f4 19 00 	mov    rax,QWORD PTR [rip+0x19f4da]        # 5a1e80 <__slm_global>
		if (unlikely(owner)) {
  4029a6:	48 89 c1             	mov    rcx,rax
  4029a9:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  4029ad:	0f 85 28 01 00 00    	jne    402adb <sched_thd_block+0x37b>
  4029b3:	f0 48 0f b1 1d c4 f4 	lock cmpxchg QWORD PTR [rip+0x19f4c4],rbx        # 5a1e80 <__slm_global>
  4029ba:	19 00 
  4029bc:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4029bf:	84 c0                	test   al,al
  4029c1:	0f 85 57 fe ff ff    	jne    40281e <sched_thd_block+0xbe>
  4029c7:	eb ce                	jmp    402997 <sched_thd_block+0x237>
  4029c9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  4029d0:	be 61 00 00 00       	mov    esi,0x61
  4029d5:	bf 28 b7 41 00       	mov    edi,0x41b728
  4029da:	e8 f1 76 00 00       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  4029df:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4029e6:	00 00 00 00 
  4029ea:	0f 0b                	ud2    
	timeout = g->timeout_next;
  4029ec:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  4029ef:	49 81 fc 88 1e 5a 00 	cmp    r12,0x5a1e88
  4029f6:	0f 84 9c 00 00 00    	je     402a98 <sched_thd_block+0x338>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  4029fc:	a8 02                	test   al,0x2
  4029fe:	0f 85 9f 00 00 00    	jne    402aa3 <sched_thd_block+0x343>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  402a04:	49 89 c8             	mov    r8,rcx
  402a07:	a8 01                	test   al,0x1
  402a09:	0f 84 9c fe ff ff    	je     4028ab <sched_thd_block+0x14b>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  402a0f:	4d 8b 54 24 08       	mov    r10,QWORD PTR [r12+0x8]
  402a14:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  402a19:	48 89 f2             	mov    rdx,rsi
  402a1c:	45 89 f1             	mov    r9d,r14d
  402a1f:	4c 8b 05 82 f4 19 00 	mov    r8,QWORD PTR [rip+0x19f482]        # 5a1ea8 <__slm_global+0x28>
  402a26:	4c 89 d6             	mov    rsi,r10
  402a29:	e8 f2 e8 00 00       	call   411320 <cos_switch>
	if (unlikely(ret != 0)) {
  402a2e:	85 c0                	test   eax,eax
  402a30:	0f 84 96 fe ff ff    	je     4028cc <sched_thd_block+0x16c>
		assert(ret != -EPERM);
  402a36:	83 f8 ff             	cmp    eax,0xffffffff
  402a39:	0f 85 3d ff ff ff    	jne    40297c <sched_thd_block+0x21c>
  402a3f:	be 61 00 00 00       	mov    esi,0x61
  402a44:	bf 90 b7 41 00       	mov    edi,0x41b790
  402a49:	e8 82 76 00 00       	call   40a0d0 <cos_print_str>
  402a4e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402a55:	00 00 00 00 
  402a59:	0f 0b                	ud2    
	return t != &g->idle_thd && t != &g->sched_thd;
  402a5b:	49 81 fc 00 1f 5a 00 	cmp    r12,0x5a1f00
  402a62:	74 09                	je     402a6d <sched_thd_block+0x30d>
  402a64:	49 81 fc 88 1e 5a 00 	cmp    r12,0x5a1e88
  402a6b:	75 d2                	jne    402a3f <sched_thd_block+0x2df>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  402a6d:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]
  402a71:	4c 8b 05 30 f4 19 00 	mov    r8,QWORD PTR [rip+0x19f430]        # 5a1ea8 <__slm_global+0x28>
  402a78:	45 89 f1             	mov    r9d,r14d
  402a7b:	31 c9                	xor    ecx,ecx
  402a7d:	48 8b 3d 14 f4 19 00 	mov    rdi,QWORD PTR [rip+0x19f414]        # 5a1e98 <__slm_global+0x18>
  402a84:	31 f6                	xor    esi,esi
  402a86:	e8 95 e8 00 00       	call   411320 <cos_switch>
  402a8b:	eb a1                	jmp    402a2e <sched_thd_block+0x2ce>
	if (dep_id) return -1;
  402a8d:	41 bd ff ff ff ff    	mov    r13d,0xffffffff
  402a93:	e9 34 fe ff ff       	jmp    4028cc <sched_thd_block+0x16c>
			prio    = curr->priority;
  402a98:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
			timeout = TCAP_TIME_NIL;
  402a9c:	31 c9                	xor    ecx,ecx
  402a9e:	e9 59 ff ff ff       	jmp    4029fc <sched_thd_block+0x29c>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  402aa3:	49 8b 7c 24 28       	mov    rdi,QWORD PTR [r12+0x28]
  402aa8:	48 8b 15 f9 f3 19 00 	mov    rdx,QWORD PTR [rip+0x19f3f9]        # 5a1ea8 <__slm_global+0x28>
  402aaf:	44 89 f1             	mov    ecx,r14d
  402ab2:	4c 89 c6             	mov    rsi,r8
  402ab5:	e8 d6 e8 00 00       	call   411390 <cos_sched_asnd>
  402aba:	e9 6f ff ff ff       	jmp    402a2e <sched_thd_block+0x2ce>
  402abf:	be 61 00 00 00       	mov    esi,0x61
  402ac4:	bf f8 b7 41 00       	mov    edi,0x41b7f8
  402ac9:	e8 02 76 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  402ace:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402ad5:	00 00 00 00 
  402ad9:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  402adb:	41 89 c0             	mov    r8d,eax
  402ade:	48 89 da             	mov    rdx,rbx
  402ae1:	48 89 c6             	mov    rsi,rax
  402ae4:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  402ae9:	41 83 e0 01          	and    r8d,0x1
  402aed:	e8 1e 0d 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  402af2:	83 f8 f0             	cmp    eax,0xfffffff0
  402af5:	0f 85 9c fe ff ff    	jne    402997 <sched_thd_block+0x237>
  402afb:	e9 60 fe ff ff       	jmp    402960 <sched_thd_block+0x200>
  402b00:	be 61 00 00 00       	mov    esi,0x61
  402b05:	bf 60 b8 41 00       	mov    edi,0x41b860
  402b0a:	e8 c1 75 00 00       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  402b0f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402b16:	00 00 00 00 
  402b1a:	0f 0b                	ud2    
	ret = slm_thd_activate(curr, t, tok, 0);
  402b1c:	41 bd f0 ff ff ff    	mov    r13d,0xfffffff0
  402b22:	e9 a5 fd ff ff       	jmp    4028cc <sched_thd_block+0x16c>
  402b27:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  402b2e:	00 00 

0000000000402b30 <thd_wakeup>:
{
  402b30:	f3 0f 1e fa          	endbr64 
  402b34:	55                   	push   rbp
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  402b35:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  402b38:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  402b3e:	48 89 e5             	mov    rbp,rsp
  402b41:	41 57                	push   r15
  402b43:	41 56                	push   r14
  402b45:	41 55                	push   r13
  402b47:	41 54                	push   r12
  402b49:	53                   	push   rbx
  402b4a:	48 83 ec 08          	sub    rsp,0x8
  402b4e:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  402b55:	48 85 c0             	test   rax,rax
  402b58:	0f 84 92 01 00 00    	je     402cf0 <thd_wakeup+0x1c0>
  402b5e:	83 e8 01             	sub    eax,0x1
  402b61:	83 f8 18             	cmp    eax,0x18
  402b64:	0f 87 86 01 00 00    	ja     402cf0 <thd_wakeup+0x1c0>
  402b6a:	48 8b 14 c5 c0 e6 45 	mov    rdx,QWORD PTR [rax*8+0x45e6c0]
  402b71:	00 
  402b72:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  402b79:	0f 84 71 01 00 00    	je     402cf0 <thd_wakeup+0x1c0>
  402b7f:	83 e2 01             	and    edx,0x1
  402b82:	0f 85 68 01 00 00    	jne    402cf0 <thd_wakeup+0x1c0>
  402b88:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  402b8c:	49 89 fd             	mov    r13,rdi
  402b8f:	4c 8d 24 50          	lea    r12,[rax+rdx*2]
  402b93:	49 c1 e4 04          	shl    r12,0x4
  402b97:	49 81 c4 88 e7 45 00 	add    r12,0x45e788
		tok    = cos_sched_sync();
  402b9e:	e8 5d e7 00 00       	call   411300 <cos_sched_sync>
  402ba3:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  402ba6:	48 8b 05 d3 f2 19 00 	mov    rax,QWORD PTR [rip+0x19f2d3]        # 5a1e80 <__slm_global>
		if (unlikely(owner)) {
  402bad:	48 89 c1             	mov    rcx,rax
  402bb0:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  402bb4:	0f 85 56 01 00 00    	jne    402d10 <thd_wakeup+0x1e0>
  402bba:	f0 4c 0f b1 25 bd f2 	lock cmpxchg QWORD PTR [rip+0x19f2bd],r12        # 5a1e80 <__slm_global>
  402bc1:	19 00 
  402bc3:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  402bc6:	84 c0                	test   al,al
  402bc8:	74 d4                	je     402b9e <thd_wakeup+0x6e>
	ret = slm_thd_wakeup(t, 0);
  402bca:	31 f6                	xor    esi,esi
  402bcc:	4c 89 ef             	mov    rdi,r13
  402bcf:	e8 5c 12 01 00       	call   413e30 <slm_thd_wakeup>
  402bd4:	41 89 c7             	mov    r15d,eax
	if (ret < 0) {
  402bd7:	85 c0                	test   eax,eax
  402bd9:	0f 88 e1 00 00 00    	js     402cc0 <thd_wakeup+0x190>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  402bdf:	e8 7c 8c 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(!t)) t = &g->idle_thd;
  402be4:	41 be 00 1f 5a 00    	mov    r14d,0x5a1f00
	tok  = cos_sched_sync();
  402bea:	e8 11 e7 00 00       	call   411300 <cos_sched_sync>
  402bef:	41 89 c5             	mov    r13d,eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  402bf2:	e8 99 f8 00 00       	call   412490 <slm_sched_fprr_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  402bf7:	48 85 c0             	test   rax,rax
  402bfa:	48 89 c3             	mov    rbx,rax
  402bfd:	49 0f 44 de          	cmove  rbx,r14
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  402c01:	8b 43 04             	mov    eax,DWORD PTR [rbx+0x4]
  402c04:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  402c07:	83 f8 01             	cmp    eax,0x1
  402c0a:	76 1c                	jbe    402c28 <thd_wakeup+0xf8>
  402c0c:	e9 3b 01 00 00       	jmp    402d4c <thd_wakeup+0x21c>
  402c11:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  402c18:	f0 48 0f b1 15 5f f2 	lock cmpxchg QWORD PTR [rip+0x19f25f],rdx        # 5a1e80 <__slm_global>
  402c1f:	19 00 
  402c21:	0f 94 c0             	sete   al
	while (ret != 0) {
  402c24:	84 c0                	test   al,al
  402c26:	75 2e                	jne    402c56 <thd_wakeup+0x126>
		tok    = cos_sched_sync();
  402c28:	e8 d3 e6 00 00       	call   411300 <cos_sched_sync>
  402c2d:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  402c2f:	48 8b 05 4a f2 19 00 	mov    rax,QWORD PTR [rip+0x19f24a]        # 5a1e80 <__slm_global>
		if (unlikely(contention)) {
  402c36:	48 89 c2             	mov    rdx,rax
  402c39:	83 e2 01             	and    edx,0x1
  402c3c:	74 da                	je     402c18 <thd_wakeup+0xe8>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  402c3e:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  402c41:	48 89 c2             	mov    rdx,rax
  402c44:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  402c49:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  402c4d:	e8 0e 0c 01 00       	call   413860 <slm_cs_exit_contention>
  402c52:	85 c0                	test   eax,eax
  402c54:	75 d2                	jne    402c28 <thd_wakeup+0xf8>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  402c56:	e8 05 8c 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  402c5b:	8b 03                	mov    eax,DWORD PTR [rbx]
	timeout = g->timeout_next;
  402c5d:	4c 8b 05 24 f3 19 00 	mov    r8,QWORD PTR [rip+0x19f324]        # 5a1f88 <__slm_global+0x108>
	prio = inherit_prio ? curr->priority : t->priority;
  402c64:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  402c68:	a8 0b                	test   al,0xb
  402c6a:	0f 85 f8 00 00 00    	jne    402d68 <thd_wakeup+0x238>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  402c70:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  402c74:	44 89 e9             	mov    ecx,r13d
  402c77:	4c 89 c2             	mov    rdx,r8
  402c7a:	e8 e1 9a 00 00       	call   40c760 <cos_defswitch>
  402c7f:	41 89 c7             	mov    r15d,eax
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  402c82:	83 f8 ff             	cmp    eax,0xffffffff
  402c85:	0f 84 85 01 00 00    	je     402e10 <thd_wakeup+0x2e0>
	if (unlikely(ret != 0)) {
  402c8b:	85 c0                	test   eax,eax
  402c8d:	0f 85 27 01 00 00    	jne    402dba <thd_wakeup+0x28a>
  402c93:	45 31 ff             	xor    r15d,r15d
}
  402c96:	48 83 c4 08          	add    rsp,0x8
  402c9a:	44 89 f8             	mov    eax,r15d
  402c9d:	5b                   	pop    rbx
  402c9e:	41 5c                	pop    r12
  402ca0:	41 5d                	pop    r13
  402ca2:	41 5e                	pop    r14
  402ca4:	41 5f                	pop    r15
  402ca6:	5d                   	pop    rbp
  402ca7:	c3                   	ret    
  402ca8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  402caf:	00 
  402cb0:	f0 48 0f b1 15 c7 f1 	lock cmpxchg QWORD PTR [rip+0x19f1c7],rdx        # 5a1e80 <__slm_global>
  402cb7:	19 00 
  402cb9:	0f 94 c0             	sete   al
	while (ret != 0) {
  402cbc:	84 c0                	test   al,al
  402cbe:	75 d6                	jne    402c96 <thd_wakeup+0x166>
		tok    = cos_sched_sync();
  402cc0:	e8 3b e6 00 00       	call   411300 <cos_sched_sync>
  402cc5:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  402cc7:	48 8b 05 b2 f1 19 00 	mov    rax,QWORD PTR [rip+0x19f1b2]        # 5a1e80 <__slm_global>
		if (unlikely(contention)) {
  402cce:	48 89 c2             	mov    rdx,rax
  402cd1:	83 e2 01             	and    edx,0x1
  402cd4:	74 da                	je     402cb0 <thd_wakeup+0x180>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  402cd6:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  402cd9:	48 89 c2             	mov    rdx,rax
  402cdc:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  402ce1:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  402ce5:	e8 76 0b 01 00       	call   413860 <slm_cs_exit_contention>
  402cea:	85 c0                	test   eax,eax
  402cec:	74 a8                	je     402c96 <thd_wakeup+0x166>
  402cee:	eb d0                	jmp    402cc0 <thd_wakeup+0x190>
  402cf0:	be 59 00 00 00       	mov    esi,0x59
  402cf5:	bf 40 b6 41 00       	mov    edi,0x41b640
  402cfa:	e8 d1 73 00 00       	call   40a0d0 <cos_print_str>
	assert(current);
  402cff:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402d06:	00 00 00 00 
  402d0a:	0f 0b                	ud2    
  402d0c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  402d10:	41 89 c0             	mov    r8d,eax
  402d13:	4c 89 e2             	mov    rdx,r12
  402d16:	48 89 c6             	mov    rsi,rax
  402d19:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  402d1e:	41 83 e0 01          	and    r8d,0x1
  402d22:	e8 e9 0a 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  402d27:	83 f8 f0             	cmp    eax,0xfffffff0
  402d2a:	0f 85 6e fe ff ff    	jne    402b9e <thd_wakeup+0x6e>
  402d30:	be 59 00 00 00       	mov    esi,0x59
  402d35:	bf a0 b6 41 00       	mov    edi,0x41b6a0
  402d3a:	e8 91 73 00 00       	call   40a0d0 <cos_print_str>
  402d3f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402d46:	00 00 00 00 
  402d4a:	0f 0b                	ud2    
  402d4c:	be 61 00 00 00       	mov    esi,0x61
  402d51:	bf 28 b7 41 00       	mov    edi,0x41b728
  402d56:	e8 75 73 00 00       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  402d5b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402d62:	00 00 00 00 
  402d66:	0f 0b                	ud2    
	timeout = g->timeout_next;
  402d68:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  402d6b:	48 81 fb 88 1e 5a 00 	cmp    rbx,0x5a1e88
  402d72:	0f 84 c6 00 00 00    	je     402e3e <thd_wakeup+0x30e>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  402d78:	a8 02                	test   al,0x2
  402d7a:	0f 85 f1 00 00 00    	jne    402e71 <thd_wakeup+0x341>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  402d80:	49 89 c8             	mov    r8,rcx
  402d83:	a8 01                	test   al,0x1
  402d85:	0f 84 e5 fe ff ff    	je     402c70 <thd_wakeup+0x140>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  402d8b:	4c 8b 53 08          	mov    r10,QWORD PTR [rbx+0x8]
  402d8f:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  402d93:	48 89 f2             	mov    rdx,rsi
  402d96:	45 89 e9             	mov    r9d,r13d
  402d99:	4c 8b 05 08 f1 19 00 	mov    r8,QWORD PTR [rip+0x19f108]        # 5a1ea8 <__slm_global+0x28>
  402da0:	4c 89 d6             	mov    rsi,r10
  402da3:	e8 78 e5 00 00       	call   411320 <cos_switch>
  402da8:	41 89 c7             	mov    r15d,eax
	if (unlikely(ret != 0)) {
  402dab:	45 85 ff             	test   r15d,r15d
  402dae:	0f 84 df fe ff ff    	je     402c93 <thd_wakeup+0x163>
		assert(ret != -EPERM);
  402db4:	41 83 ff ff          	cmp    r15d,0xffffffff
  402db8:	74 68                	je     402e22 <thd_wakeup+0x2f2>
		assert(ret != -EINVAL);
  402dba:	41 83 ff ea          	cmp    r15d,0xffffffea
  402dbe:	0f 84 cb 00 00 00    	je     402e8f <thd_wakeup+0x35f>
		if (ret == -EBUSY) return ret;
  402dc4:	41 83 ff f0          	cmp    r15d,0xfffffff0
  402dc8:	0f 84 c8 fe ff ff    	je     402c96 <thd_wakeup+0x166>
		assert(ret == -EAGAIN);
  402dce:	41 83 ff f5          	cmp    r15d,0xfffffff5
  402dd2:	0f 85 f8 00 00 00    	jne    402ed0 <thd_wakeup+0x3a0>
		tok    = cos_sched_sync();
  402dd8:	e8 23 e5 00 00       	call   411300 <cos_sched_sync>
  402ddd:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  402de0:	48 8b 05 99 f0 19 00 	mov    rax,QWORD PTR [rip+0x19f099]        # 5a1e80 <__slm_global>
		if (unlikely(owner)) {
  402de7:	48 89 c1             	mov    rcx,rax
  402dea:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  402dee:	0f 85 b7 00 00 00    	jne    402eab <thd_wakeup+0x37b>
  402df4:	f0 4c 0f b1 25 83 f0 	lock cmpxchg QWORD PTR [rip+0x19f083],r12        # 5a1e80 <__slm_global>
  402dfb:	19 00 
  402dfd:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  402e00:	84 c0                	test   al,al
  402e02:	0f 85 e2 fd ff ff    	jne    402bea <thd_wakeup+0xba>
  402e08:	eb ce                	jmp    402dd8 <thd_wakeup+0x2a8>
  402e0a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	return t != &g->idle_thd && t != &g->sched_thd;
  402e10:	48 81 fb 00 1f 5a 00 	cmp    rbx,0x5a1f00
  402e17:	74 31                	je     402e4a <thd_wakeup+0x31a>
  402e19:	48 81 fb 88 1e 5a 00 	cmp    rbx,0x5a1e88
  402e20:	74 28                	je     402e4a <thd_wakeup+0x31a>
  402e22:	be 61 00 00 00       	mov    esi,0x61
  402e27:	bf 90 b7 41 00       	mov    edi,0x41b790
  402e2c:	e8 9f 72 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EPERM);
  402e31:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402e38:	00 00 00 00 
  402e3c:	0f 0b                	ud2    
			prio    = curr->priority;
  402e3e:	49 8b 74 24 30       	mov    rsi,QWORD PTR [r12+0x30]
			timeout = TCAP_TIME_NIL;
  402e43:	31 c9                	xor    ecx,ecx
  402e45:	e9 2e ff ff ff       	jmp    402d78 <thd_wakeup+0x248>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  402e4a:	49 8b 54 24 30       	mov    rdx,QWORD PTR [r12+0x30]
  402e4f:	4c 8b 05 52 f0 19 00 	mov    r8,QWORD PTR [rip+0x19f052]        # 5a1ea8 <__slm_global+0x28>
  402e56:	31 c9                	xor    ecx,ecx
  402e58:	31 f6                	xor    esi,esi
  402e5a:	48 8b 3d 37 f0 19 00 	mov    rdi,QWORD PTR [rip+0x19f037]        # 5a1e98 <__slm_global+0x18>
  402e61:	45 89 e9             	mov    r9d,r13d
  402e64:	e8 b7 e4 00 00       	call   411320 <cos_switch>
  402e69:	41 89 c7             	mov    r15d,eax
  402e6c:	e9 3a ff ff ff       	jmp    402dab <thd_wakeup+0x27b>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  402e71:	48 8b 7b 28          	mov    rdi,QWORD PTR [rbx+0x28]
  402e75:	48 8b 15 2c f0 19 00 	mov    rdx,QWORD PTR [rip+0x19f02c]        # 5a1ea8 <__slm_global+0x28>
  402e7c:	44 89 e9             	mov    ecx,r13d
  402e7f:	4c 89 c6             	mov    rsi,r8
  402e82:	e8 09 e5 00 00       	call   411390 <cos_sched_asnd>
  402e87:	41 89 c7             	mov    r15d,eax
  402e8a:	e9 1c ff ff ff       	jmp    402dab <thd_wakeup+0x27b>
  402e8f:	be 61 00 00 00       	mov    esi,0x61
  402e94:	bf f8 b7 41 00       	mov    edi,0x41b7f8
  402e99:	e8 32 72 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  402e9e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402ea5:	00 00 00 00 
  402ea9:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  402eab:	41 89 c0             	mov    r8d,eax
  402eae:	4c 89 e2             	mov    rdx,r12
  402eb1:	48 89 c6             	mov    rsi,rax
  402eb4:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  402eb9:	41 83 e0 01          	and    r8d,0x1
  402ebd:	e8 4e 09 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  402ec2:	83 f8 f0             	cmp    eax,0xfffffff0
  402ec5:	0f 85 0d ff ff ff    	jne    402dd8 <thd_wakeup+0x2a8>
  402ecb:	e9 60 fe ff ff       	jmp    402d30 <thd_wakeup+0x200>
  402ed0:	be 61 00 00 00       	mov    esi,0x61
  402ed5:	bf 60 b8 41 00       	mov    edi,0x41b860
  402eda:	e8 f1 71 00 00       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  402edf:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402ee6:	00 00 00 00 
  402eea:	0f 0b                	ud2    
  402eec:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000402ef0 <sched_thd_wakeup>:
{
  402ef0:	f3 0f 1e fa          	endbr64 
  402ef4:	55                   	push   rbp
  402ef5:	48 89 e5             	mov    rbp,rsp
  402ef8:	41 57                	push   r15
  402efa:	41 56                	push   r14
  402efc:	41 55                	push   r13
  402efe:	41 54                	push   r12
  402f00:	53                   	push   rbx
  402f01:	48 83 ec 08          	sub    rsp,0x8
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  402f05:	85 ff                	test   edi,edi
  402f07:	74 1b                	je     402f24 <sched_thd_wakeup+0x34>
  402f09:	83 ef 01             	sub    edi,0x1
  402f0c:	83 ff 18             	cmp    edi,0x18
  402f0f:	77 13                	ja     402f24 <sched_thd_wakeup+0x34>
  402f11:	89 f8                	mov    eax,edi
  402f13:	48 8b 14 c5 c0 e6 45 	mov    rdx,QWORD PTR [rax*8+0x45e6c0]
  402f1a:	00 
  402f1b:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  402f22:	75 1c                	jne    402f40 <sched_thd_wakeup+0x50>
	if (!t) return -1;
  402f24:	41 bf ff ff ff ff    	mov    r15d,0xffffffff
}
  402f2a:	48 83 c4 08          	add    rsp,0x8
  402f2e:	44 89 f8             	mov    eax,r15d
  402f31:	5b                   	pop    rbx
  402f32:	41 5c                	pop    r12
  402f34:	41 5d                	pop    r13
  402f36:	41 5e                	pop    r14
  402f38:	41 5f                	pop    r15
  402f3a:	5d                   	pop    rbp
  402f3b:	c3                   	ret    
  402f3c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  402f40:	83 e2 01             	and    edx,0x1
  402f43:	75 df                	jne    402f24 <sched_thd_wakeup+0x34>
	return &ss_thd_get(id)->thd;
  402f45:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  402f49:	4c 8d 2c 50          	lea    r13,[rax+rdx*2]
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  402f4d:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  402f50:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  402f56:	49 c1 e5 04          	shl    r13,0x4
  402f5a:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
  402f61:	49 81 c5 88 e7 45 00 	add    r13,0x45e788
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  402f68:	48 85 c0             	test   rax,rax
  402f6b:	74 19                	je     402f86 <sched_thd_wakeup+0x96>
  402f6d:	83 e8 01             	sub    eax,0x1
  402f70:	83 f8 18             	cmp    eax,0x18
  402f73:	77 11                	ja     402f86 <sched_thd_wakeup+0x96>
  402f75:	48 8b 14 c5 c0 e6 45 	mov    rdx,QWORD PTR [rax*8+0x45e6c0]
  402f7c:	00 
  402f7d:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  402f84:	75 22                	jne    402fa8 <sched_thd_wakeup+0xb8>
  402f86:	be 59 00 00 00       	mov    esi,0x59
  402f8b:	bf 40 b6 41 00       	mov    edi,0x41b640
  402f90:	e8 3b 71 00 00       	call   40a0d0 <cos_print_str>
	assert(current);
  402f95:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402f9c:	00 00 00 00 
  402fa0:	0f 0b                	ud2    
  402fa2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  402fa8:	83 e2 01             	and    edx,0x1
  402fab:	75 d9                	jne    402f86 <sched_thd_wakeup+0x96>
  402fad:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  402fb1:	4c 8d 24 50          	lea    r12,[rax+rdx*2]
  402fb5:	49 c1 e4 04          	shl    r12,0x4
  402fb9:	49 81 c4 88 e7 45 00 	add    r12,0x45e788
		tok    = cos_sched_sync();
  402fc0:	e8 3b e3 00 00       	call   411300 <cos_sched_sync>
  402fc5:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  402fc8:	48 8b 05 b1 ee 19 00 	mov    rax,QWORD PTR [rip+0x19eeb1]        # 5a1e80 <__slm_global>
		if (unlikely(owner)) {
  402fcf:	48 89 c1             	mov    rcx,rax
  402fd2:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  402fd6:	0f 85 34 01 00 00    	jne    403110 <sched_thd_wakeup+0x220>
  402fdc:	f0 4c 0f b1 25 9b ee 	lock cmpxchg QWORD PTR [rip+0x19ee9b],r12        # 5a1e80 <__slm_global>
  402fe3:	19 00 
  402fe5:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  402fe8:	84 c0                	test   al,al
  402fea:	74 d4                	je     402fc0 <sched_thd_wakeup+0xd0>
	ret = slm_thd_wakeup(t, 0);
  402fec:	31 f6                	xor    esi,esi
  402fee:	4c 89 ef             	mov    rdi,r13
  402ff1:	e8 3a 0e 01 00       	call   413e30 <slm_thd_wakeup>
  402ff6:	41 89 c7             	mov    r15d,eax
	if (ret < 0) {
  402ff9:	85 c0                	test   eax,eax
  402ffb:	0f 88 d3 00 00 00    	js     4030d4 <sched_thd_wakeup+0x1e4>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  403001:	e8 5a 88 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(!t)) t = &g->idle_thd;
  403006:	41 be 00 1f 5a 00    	mov    r14d,0x5a1f00
	tok  = cos_sched_sync();
  40300c:	e8 ef e2 00 00       	call   411300 <cos_sched_sync>
  403011:	41 89 c5             	mov    r13d,eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  403014:	e8 77 f4 00 00       	call   412490 <slm_sched_fprr_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  403019:	48 85 c0             	test   rax,rax
  40301c:	48 89 c3             	mov    rbx,rax
  40301f:	49 0f 44 de          	cmove  rbx,r14
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  403023:	8b 43 04             	mov    eax,DWORD PTR [rbx+0x4]
  403026:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  403029:	83 f8 01             	cmp    eax,0x1
  40302c:	76 1a                	jbe    403048 <sched_thd_wakeup+0x158>
  40302e:	e9 19 01 00 00       	jmp    40314c <sched_thd_wakeup+0x25c>
  403033:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  403038:	f0 48 0f b1 15 3f ee 	lock cmpxchg QWORD PTR [rip+0x19ee3f],rdx        # 5a1e80 <__slm_global>
  40303f:	19 00 
  403041:	0f 94 c0             	sete   al
	while (ret != 0) {
  403044:	84 c0                	test   al,al
  403046:	75 2e                	jne    403076 <sched_thd_wakeup+0x186>
		tok    = cos_sched_sync();
  403048:	e8 b3 e2 00 00       	call   411300 <cos_sched_sync>
  40304d:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  40304f:	48 8b 05 2a ee 19 00 	mov    rax,QWORD PTR [rip+0x19ee2a]        # 5a1e80 <__slm_global>
		if (unlikely(contention)) {
  403056:	48 89 c2             	mov    rdx,rax
  403059:	83 e2 01             	and    edx,0x1
  40305c:	74 da                	je     403038 <sched_thd_wakeup+0x148>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  40305e:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  403061:	48 89 c2             	mov    rdx,rax
  403064:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  403069:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  40306d:	e8 ee 07 01 00       	call   413860 <slm_cs_exit_contention>
  403072:	85 c0                	test   eax,eax
  403074:	75 d2                	jne    403048 <sched_thd_wakeup+0x158>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  403076:	e8 e5 87 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  40307b:	8b 03                	mov    eax,DWORD PTR [rbx]
	timeout = g->timeout_next;
  40307d:	4c 8b 05 04 ef 19 00 	mov    r8,QWORD PTR [rip+0x19ef04]        # 5a1f88 <__slm_global+0x108>
	prio = inherit_prio ? curr->priority : t->priority;
  403084:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  403088:	a8 0b                	test   al,0xb
  40308a:	0f 85 d8 00 00 00    	jne    403168 <sched_thd_wakeup+0x278>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  403090:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  403094:	44 89 e9             	mov    ecx,r13d
  403097:	4c 89 c2             	mov    rdx,r8
  40309a:	e8 c1 96 00 00       	call   40c760 <cos_defswitch>
  40309f:	41 89 c7             	mov    r15d,eax
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  4030a2:	83 f8 ff             	cmp    eax,0xffffffff
  4030a5:	0f 84 65 01 00 00    	je     403210 <sched_thd_wakeup+0x320>
	if (unlikely(ret != 0)) {
  4030ab:	85 c0                	test   eax,eax
  4030ad:	0f 85 07 01 00 00    	jne    4031ba <sched_thd_wakeup+0x2ca>
	if (!t) return -1;
  4030b3:	45 31 ff             	xor    r15d,r15d
  4030b6:	e9 6f fe ff ff       	jmp    402f2a <sched_thd_wakeup+0x3a>
  4030bb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  4030c0:	f0 48 0f b1 15 b7 ed 	lock cmpxchg QWORD PTR [rip+0x19edb7],rdx        # 5a1e80 <__slm_global>
  4030c7:	19 00 
  4030c9:	0f 94 c0             	sete   al
	while (ret != 0) {
  4030cc:	84 c0                	test   al,al
  4030ce:	0f 85 56 fe ff ff    	jne    402f2a <sched_thd_wakeup+0x3a>
		tok    = cos_sched_sync();
  4030d4:	e8 27 e2 00 00       	call   411300 <cos_sched_sync>
  4030d9:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4030db:	48 8b 05 9e ed 19 00 	mov    rax,QWORD PTR [rip+0x19ed9e]        # 5a1e80 <__slm_global>
		if (unlikely(contention)) {
  4030e2:	48 89 c2             	mov    rdx,rax
  4030e5:	83 e2 01             	and    edx,0x1
  4030e8:	74 d6                	je     4030c0 <sched_thd_wakeup+0x1d0>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  4030ea:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  4030ed:	48 89 c2             	mov    rdx,rax
  4030f0:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  4030f5:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  4030f9:	e8 62 07 01 00       	call   413860 <slm_cs_exit_contention>
  4030fe:	85 c0                	test   eax,eax
  403100:	0f 84 24 fe ff ff    	je     402f2a <sched_thd_wakeup+0x3a>
  403106:	eb cc                	jmp    4030d4 <sched_thd_wakeup+0x1e4>
  403108:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40310f:	00 
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  403110:	41 89 c0             	mov    r8d,eax
  403113:	4c 89 e2             	mov    rdx,r12
  403116:	48 89 c6             	mov    rsi,rax
  403119:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  40311e:	41 83 e0 01          	and    r8d,0x1
  403122:	e8 e9 06 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  403127:	83 f8 f0             	cmp    eax,0xfffffff0
  40312a:	0f 85 90 fe ff ff    	jne    402fc0 <sched_thd_wakeup+0xd0>
  403130:	be 59 00 00 00       	mov    esi,0x59
  403135:	bf a0 b6 41 00       	mov    edi,0x41b6a0
  40313a:	e8 91 6f 00 00       	call   40a0d0 <cos_print_str>
  40313f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403146:	00 00 00 00 
  40314a:	0f 0b                	ud2    
  40314c:	be 61 00 00 00       	mov    esi,0x61
  403151:	bf 28 b7 41 00       	mov    edi,0x41b728
  403156:	e8 75 6f 00 00       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  40315b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403162:	00 00 00 00 
  403166:	0f 0b                	ud2    
	timeout = g->timeout_next;
  403168:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  40316b:	48 81 fb 88 1e 5a 00 	cmp    rbx,0x5a1e88
  403172:	0f 84 c6 00 00 00    	je     40323e <sched_thd_wakeup+0x34e>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  403178:	a8 02                	test   al,0x2
  40317a:	0f 85 f1 00 00 00    	jne    403271 <sched_thd_wakeup+0x381>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  403180:	49 89 c8             	mov    r8,rcx
  403183:	a8 01                	test   al,0x1
  403185:	0f 84 05 ff ff ff    	je     403090 <sched_thd_wakeup+0x1a0>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  40318b:	4c 8b 53 08          	mov    r10,QWORD PTR [rbx+0x8]
  40318f:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  403193:	48 89 f2             	mov    rdx,rsi
  403196:	45 89 e9             	mov    r9d,r13d
  403199:	4c 8b 05 08 ed 19 00 	mov    r8,QWORD PTR [rip+0x19ed08]        # 5a1ea8 <__slm_global+0x28>
  4031a0:	4c 89 d6             	mov    rsi,r10
  4031a3:	e8 78 e1 00 00       	call   411320 <cos_switch>
  4031a8:	41 89 c7             	mov    r15d,eax
	if (unlikely(ret != 0)) {
  4031ab:	45 85 ff             	test   r15d,r15d
  4031ae:	0f 84 ff fe ff ff    	je     4030b3 <sched_thd_wakeup+0x1c3>
		assert(ret != -EPERM);
  4031b4:	41 83 ff ff          	cmp    r15d,0xffffffff
  4031b8:	74 68                	je     403222 <sched_thd_wakeup+0x332>
		assert(ret != -EINVAL);
  4031ba:	41 83 ff ea          	cmp    r15d,0xffffffea
  4031be:	0f 84 cb 00 00 00    	je     40328f <sched_thd_wakeup+0x39f>
		if (ret == -EBUSY) return ret;
  4031c4:	41 83 ff f0          	cmp    r15d,0xfffffff0
  4031c8:	0f 84 5c fd ff ff    	je     402f2a <sched_thd_wakeup+0x3a>
		assert(ret == -EAGAIN);
  4031ce:	41 83 ff f5          	cmp    r15d,0xfffffff5
  4031d2:	0f 85 f8 00 00 00    	jne    4032d0 <sched_thd_wakeup+0x3e0>
		tok    = cos_sched_sync();
  4031d8:	e8 23 e1 00 00       	call   411300 <cos_sched_sync>
  4031dd:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4031e0:	48 8b 05 99 ec 19 00 	mov    rax,QWORD PTR [rip+0x19ec99]        # 5a1e80 <__slm_global>
		if (unlikely(owner)) {
  4031e7:	48 89 c1             	mov    rcx,rax
  4031ea:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  4031ee:	0f 85 b7 00 00 00    	jne    4032ab <sched_thd_wakeup+0x3bb>
  4031f4:	f0 4c 0f b1 25 83 ec 	lock cmpxchg QWORD PTR [rip+0x19ec83],r12        # 5a1e80 <__slm_global>
  4031fb:	19 00 
  4031fd:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  403200:	84 c0                	test   al,al
  403202:	0f 85 04 fe ff ff    	jne    40300c <sched_thd_wakeup+0x11c>
  403208:	eb ce                	jmp    4031d8 <sched_thd_wakeup+0x2e8>
  40320a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	return t != &g->idle_thd && t != &g->sched_thd;
  403210:	48 81 fb 00 1f 5a 00 	cmp    rbx,0x5a1f00
  403217:	74 31                	je     40324a <sched_thd_wakeup+0x35a>
  403219:	48 81 fb 88 1e 5a 00 	cmp    rbx,0x5a1e88
  403220:	74 28                	je     40324a <sched_thd_wakeup+0x35a>
  403222:	be 61 00 00 00       	mov    esi,0x61
  403227:	bf 90 b7 41 00       	mov    edi,0x41b790
  40322c:	e8 9f 6e 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EPERM);
  403231:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403238:	00 00 00 00 
  40323c:	0f 0b                	ud2    
			prio    = curr->priority;
  40323e:	49 8b 74 24 30       	mov    rsi,QWORD PTR [r12+0x30]
			timeout = TCAP_TIME_NIL;
  403243:	31 c9                	xor    ecx,ecx
  403245:	e9 2e ff ff ff       	jmp    403178 <sched_thd_wakeup+0x288>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  40324a:	49 8b 54 24 30       	mov    rdx,QWORD PTR [r12+0x30]
  40324f:	4c 8b 05 52 ec 19 00 	mov    r8,QWORD PTR [rip+0x19ec52]        # 5a1ea8 <__slm_global+0x28>
  403256:	31 c9                	xor    ecx,ecx
  403258:	31 f6                	xor    esi,esi
  40325a:	48 8b 3d 37 ec 19 00 	mov    rdi,QWORD PTR [rip+0x19ec37]        # 5a1e98 <__slm_global+0x18>
  403261:	45 89 e9             	mov    r9d,r13d
  403264:	e8 b7 e0 00 00       	call   411320 <cos_switch>
  403269:	41 89 c7             	mov    r15d,eax
  40326c:	e9 3a ff ff ff       	jmp    4031ab <sched_thd_wakeup+0x2bb>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  403271:	48 8b 7b 28          	mov    rdi,QWORD PTR [rbx+0x28]
  403275:	48 8b 15 2c ec 19 00 	mov    rdx,QWORD PTR [rip+0x19ec2c]        # 5a1ea8 <__slm_global+0x28>
  40327c:	44 89 e9             	mov    ecx,r13d
  40327f:	4c 89 c6             	mov    rsi,r8
  403282:	e8 09 e1 00 00       	call   411390 <cos_sched_asnd>
  403287:	41 89 c7             	mov    r15d,eax
  40328a:	e9 1c ff ff ff       	jmp    4031ab <sched_thd_wakeup+0x2bb>
  40328f:	be 61 00 00 00       	mov    esi,0x61
  403294:	bf f8 b7 41 00       	mov    edi,0x41b7f8
  403299:	e8 32 6e 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  40329e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4032a5:	00 00 00 00 
  4032a9:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  4032ab:	41 89 c0             	mov    r8d,eax
  4032ae:	4c 89 e2             	mov    rdx,r12
  4032b1:	48 89 c6             	mov    rsi,rax
  4032b4:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  4032b9:	41 83 e0 01          	and    r8d,0x1
  4032bd:	e8 4e 05 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  4032c2:	83 f8 f0             	cmp    eax,0xfffffff0
  4032c5:	0f 85 0d ff ff ff    	jne    4031d8 <sched_thd_wakeup+0x2e8>
  4032cb:	e9 60 fe ff ff       	jmp    403130 <sched_thd_wakeup+0x240>
  4032d0:	be 61 00 00 00       	mov    esi,0x61
  4032d5:	bf 60 b8 41 00       	mov    edi,0x41b860
  4032da:	e8 f1 6d 00 00       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  4032df:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4032e6:	00 00 00 00 
  4032ea:	0f 0b                	ud2    
  4032ec:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

00000000004032f0 <sched_debug_thd_state>:
{
  4032f0:	f3 0f 1e fa          	endbr64 
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  4032f4:	85 ff                	test   edi,edi
  4032f6:	0f 84 6e 1b 01 00    	je     414e6a <sched_debug_thd_state.cold>
  4032fc:	83 ef 01             	sub    edi,0x1
  4032ff:	83 ff 18             	cmp    edi,0x18
  403302:	0f 87 62 1b 01 00    	ja     414e6a <sched_debug_thd_state.cold>
  403308:	48 8b 04 fd c0 e6 45 	mov    rax,QWORD PTR [rdi*8+0x45e6c0]
  40330f:	00 
  403310:	48 a9 fe ff ff ff    	test   rax,0xfffffffffffffffe
  403316:	0f 84 4e 1b 01 00    	je     414e6a <sched_debug_thd_state.cold>
  40331c:	a8 01                	test   al,0x1
  40331e:	0f 85 46 1b 01 00    	jne    414e6a <sched_debug_thd_state.cold>
	return t->state;
  403324:	48 8d 04 bf          	lea    rax,[rdi+rdi*4]
  403328:	48 8d 04 47          	lea    rax,[rdi+rax*2]
  40332c:	48 c1 e0 04          	shl    rax,0x4
  403330:	8b 80 8c e7 45 00    	mov    eax,DWORD PTR [rax+0x45e78c]
}
  403336:	c3                   	ret    
  403337:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40333e:	00 00 

0000000000403340 <sched_thd_block_timeout>:
{
  403340:	f3 0f 1e fa          	endbr64 
	if (dep_id) return 0;
  403344:	48 85 ff             	test   rdi,rdi
  403347:	74 07                	je     403350 <sched_thd_block_timeout+0x10>
  403349:	31 c0                	xor    eax,eax
}
  40334b:	c3                   	ret    
  40334c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
{
  403350:	55                   	push   rbp
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  403351:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  403354:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  40335a:	48 89 e5             	mov    rbp,rsp
  40335d:	41 57                	push   r15
  40335f:	41 56                	push   r14
  403361:	41 55                	push   r13
  403363:	49 89 f5             	mov    r13,rsi
  403366:	41 54                	push   r12
  403368:	53                   	push   rbx
  403369:	48 83 ec 08          	sub    rsp,0x8
  40336d:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403374:	48 85 c0             	test   rax,rax
  403377:	0f 84 bb 01 00 00    	je     403538 <sched_thd_block_timeout+0x1f8>
  40337d:	83 e8 01             	sub    eax,0x1
  403380:	83 f8 18             	cmp    eax,0x18
  403383:	0f 87 af 01 00 00    	ja     403538 <sched_thd_block_timeout+0x1f8>
  403389:	48 8b 14 c5 c0 e6 45 	mov    rdx,QWORD PTR [rax*8+0x45e6c0]
  403390:	00 
  403391:	45 31 e4             	xor    r12d,r12d
  403394:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  40339b:	0f 85 5f 01 00 00    	jne    403500 <sched_thd_block_timeout+0x1c0>
static inline ps_tsc_t
ps_tsc(void)
{
	unsigned long a, d, c;

	__asm__ __volatile__("rdtsc" : "=a" (a), "=d" (d), "=c" (c) : : );
  4033a1:	0f 31                	rdtsc  

	return ((u64_t)d << 32) | (u64_t)a;
  4033a3:	48 c1 e2 20          	shl    rdx,0x20
  4033a7:	48 09 c2             	or     rdx,rax
 * more than 2^63 into the future.
 */
static inline int
cycles_greater_than(cycles_t g, cycles_t l)
{
	return (s64_t)(g - l) > 0;
  4033aa:	4c 89 e8             	mov    rax,r13
  4033ad:	48 29 d0             	sub    rax,rdx
	while (cycles_greater_than(timeout, slm_now())) {
  4033b0:	48 85 c0             	test   rax,rax
  4033b3:	0f 8e a7 02 00 00    	jle    403660 <sched_thd_block_timeout+0x320>
	assert(current);
  4033b9:	4d 85 e4             	test   r12,r12
  4033bc:	0f 84 ba 01 00 00    	je     40357c <sched_thd_block_timeout+0x23c>
		tok    = cos_sched_sync();
  4033c2:	e8 39 df 00 00       	call   411300 <cos_sched_sync>
  4033c7:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4033ca:	48 8b 05 af ea 19 00 	mov    rax,QWORD PTR [rip+0x19eaaf]        # 5a1e80 <__slm_global>
		if (unlikely(owner)) {
  4033d1:	48 89 c1             	mov    rcx,rax
  4033d4:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  4033d8:	0f 85 62 01 00 00    	jne    403540 <sched_thd_block_timeout+0x200>
        __asm__ __volatile__("lock " PS_CAS_STR
  4033de:	f0 4c 0f b1 25 99 ea 	lock cmpxchg QWORD PTR [rip+0x19ea99],r12        # 5a1e80 <__slm_global>
  4033e5:	19 00 
  4033e7:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4033ea:	84 c0                	test   al,al
  4033ec:	74 d4                	je     4033c2 <sched_thd_block_timeout+0x82>
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  4033ee:	4c 89 ee             	mov    rsi,r13
  4033f1:	4c 89 e7             	mov    rdi,r12
  4033f4:	e8 57 f8 00 00       	call   412c50 <slm_timer_quantum_add>
		if (slm_timer_add(current, timeout)) goto done;
  4033f9:	85 c0                	test   eax,eax
  4033fb:	75 10                	jne    40340d <sched_thd_block_timeout+0xcd>
		if (slm_thd_block(current)) {
  4033fd:	4c 89 e7             	mov    rdi,r12
  403400:	e8 bb 04 01 00       	call   4138c0 <slm_thd_block>
  403405:	85 c0                	test   eax,eax
  403407:	0f 85 1b 01 00 00    	jne    403528 <sched_thd_block_timeout+0x1e8>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  40340d:	e8 4e 84 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	tok  = cos_sched_sync();
  403412:	e8 e9 de 00 00       	call   411300 <cos_sched_sync>
  403417:	41 89 c6             	mov    r14d,eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  40341a:	e8 71 f0 00 00       	call   412490 <slm_sched_fprr_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  40341f:	48 85 c0             	test   rax,rax
  403422:	48 89 c3             	mov    rbx,rax
  403425:	b8 00 1f 5a 00       	mov    eax,0x5a1f00
  40342a:	48 0f 44 d8          	cmove  rbx,rax
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  40342e:	8b 43 04             	mov    eax,DWORD PTR [rbx+0x4]
  403431:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  403434:	83 f8 01             	cmp    eax,0x1
  403437:	76 17                	jbe    403450 <sched_thd_block_timeout+0x110>
  403439:	e9 5a 01 00 00       	jmp    403598 <sched_thd_block_timeout+0x258>
  40343e:	66 90                	xchg   ax,ax
  403440:	f0 48 0f b1 15 37 ea 	lock cmpxchg QWORD PTR [rip+0x19ea37],rdx        # 5a1e80 <__slm_global>
  403447:	19 00 
  403449:	0f 94 c0             	sete   al
	while (ret != 0) {
  40344c:	84 c0                	test   al,al
  40344e:	75 2e                	jne    40347e <sched_thd_block_timeout+0x13e>
		tok    = cos_sched_sync();
  403450:	e8 ab de 00 00       	call   411300 <cos_sched_sync>
  403455:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  403457:	48 8b 05 22 ea 19 00 	mov    rax,QWORD PTR [rip+0x19ea22]        # 5a1e80 <__slm_global>
		if (unlikely(contention)) {
  40345e:	48 89 c2             	mov    rdx,rax
  403461:	83 e2 01             	and    edx,0x1
  403464:	74 da                	je     403440 <sched_thd_block_timeout+0x100>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  403466:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  403469:	48 89 c2             	mov    rdx,rax
  40346c:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  403471:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  403475:	e8 e6 03 01 00       	call   413860 <slm_cs_exit_contention>
  40347a:	85 c0                	test   eax,eax
  40347c:	75 d2                	jne    403450 <sched_thd_block_timeout+0x110>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  40347e:	e8 dd 83 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  403483:	8b 03                	mov    eax,DWORD PTR [rbx]
	timeout = g->timeout_next;
  403485:	4c 8b 05 fc ea 19 00 	mov    r8,QWORD PTR [rip+0x19eafc]        # 5a1f88 <__slm_global+0x108>
	prio = inherit_prio ? curr->priority : t->priority;
  40348c:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  403490:	a8 0b                	test   al,0xb
  403492:	0f 85 1c 01 00 00    	jne    4035b4 <sched_thd_block_timeout+0x274>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  403498:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  40349c:	44 89 f1             	mov    ecx,r14d
  40349f:	4c 89 c2             	mov    rdx,r8
  4034a2:	e8 b9 92 00 00       	call   40c760 <cos_defswitch>
  4034a7:	41 89 c7             	mov    r15d,eax
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  4034aa:	83 f8 ff             	cmp    eax,0xffffffff
  4034ad:	0f 84 e5 01 00 00    	je     403698 <sched_thd_block_timeout+0x358>
	if (unlikely(ret != 0)) {
  4034b3:	85 c0                	test   eax,eax
  4034b5:	0f 85 4f 01 00 00    	jne    40360a <sched_thd_block_timeout+0x2ca>
  4034bb:	45 31 ff             	xor    r15d,r15d
  4034be:	4c 89 e7             	mov    rdi,r12
  4034c1:	e8 1a f8 00 00       	call   412ce0 <slm_timer_quantum_cancel>
	__asm__ __volatile__("rdtsc" : "=a" (a), "=d" (d), "=c" (c) : : );
  4034c6:	0f 31                	rdtsc  
	return ((u64_t)d << 32) | (u64_t)a;
  4034c8:	48 c1 e2 20          	shl    rdx,0x20
  4034cc:	48 09 c2             	or     rdx,rax
  4034cf:	4c 89 e8             	mov    rax,r13
  4034d2:	48 29 d0             	sub    rax,rdx
	while (cycles_greater_than(timeout, slm_now())) {
  4034d5:	48 85 c0             	test   rax,rax
  4034d8:	0f 8f e4 fe ff ff    	jg     4033c2 <sched_thd_block_timeout+0x82>
	if (dep_id) return 0;
  4034de:	31 c0                	xor    eax,eax
	if (thd_block_until(abs_timeout)) return 0;
  4034e0:	45 85 ff             	test   r15d,r15d
  4034e3:	0f 84 77 01 00 00    	je     403660 <sched_thd_block_timeout+0x320>
}
  4034e9:	48 83 c4 08          	add    rsp,0x8
  4034ed:	5b                   	pop    rbx
  4034ee:	41 5c                	pop    r12
  4034f0:	41 5d                	pop    r13
  4034f2:	41 5e                	pop    r14
  4034f4:	41 5f                	pop    r15
  4034f6:	5d                   	pop    rbp
  4034f7:	c3                   	ret    
  4034f8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4034ff:	00 
  403500:	83 e2 01             	and    edx,0x1
  403503:	0f 85 98 fe ff ff    	jne    4033a1 <sched_thd_block_timeout+0x61>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403509:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  40350d:	4c 8d 24 50          	lea    r12,[rax+rdx*2]
  403511:	49 c1 e4 04          	shl    r12,0x4
  403515:	49 81 c4 88 e7 45 00 	add    r12,0x45e788
  40351c:	e9 80 fe ff ff       	jmp    4033a1 <sched_thd_block_timeout+0x61>
  403521:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  403528:	4c 89 e7             	mov    rdi,r12
  40352b:	e8 b0 f7 00 00       	call   412ce0 <slm_timer_quantum_cancel>
  403530:	e9 d8 fe ff ff       	jmp    40340d <sched_thd_block_timeout+0xcd>
  403535:	0f 1f 00             	nop    DWORD PTR [rax]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403538:	45 31 e4             	xor    r12d,r12d
  40353b:	e9 61 fe ff ff       	jmp    4033a1 <sched_thd_block_timeout+0x61>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  403540:	41 89 c0             	mov    r8d,eax
  403543:	4c 89 e2             	mov    rdx,r12
  403546:	48 89 c6             	mov    rsi,rax
  403549:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  40354e:	41 83 e0 01          	and    r8d,0x1
  403552:	e8 b9 02 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  403557:	83 f8 f0             	cmp    eax,0xfffffff0
  40355a:	0f 85 62 fe ff ff    	jne    4033c2 <sched_thd_block_timeout+0x82>
  403560:	be 59 00 00 00       	mov    esi,0x59
  403565:	bf a0 b6 41 00       	mov    edi,0x41b6a0
  40356a:	e8 61 6b 00 00       	call   40a0d0 <cos_print_str>
  40356f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403576:	00 00 00 00 
  40357a:	0f 0b                	ud2    
  40357c:	be 59 00 00 00       	mov    esi,0x59
  403581:	bf 40 b6 41 00       	mov    edi,0x41b640
  403586:	e8 45 6b 00 00       	call   40a0d0 <cos_print_str>
	assert(current);
  40358b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403592:	00 00 00 00 
  403596:	0f 0b                	ud2    
  403598:	be 61 00 00 00       	mov    esi,0x61
  40359d:	bf 28 b7 41 00       	mov    edi,0x41b728
  4035a2:	e8 29 6b 00 00       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  4035a7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4035ae:	00 00 00 00 
  4035b2:	0f 0b                	ud2    
	timeout = g->timeout_next;
  4035b4:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  4035b7:	48 81 fb 88 1e 5a 00 	cmp    rbx,0x5a1e88
  4035be:	0f 84 02 01 00 00    	je     4036c6 <sched_thd_block_timeout+0x386>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  4035c4:	a8 02                	test   al,0x2
  4035c6:	0f 85 06 01 00 00    	jne    4036d2 <sched_thd_block_timeout+0x392>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  4035cc:	49 89 c8             	mov    r8,rcx
  4035cf:	a8 01                	test   al,0x1
  4035d1:	0f 84 c1 fe ff ff    	je     403498 <sched_thd_block_timeout+0x158>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  4035d7:	4c 8b 53 08          	mov    r10,QWORD PTR [rbx+0x8]
  4035db:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  4035df:	48 89 f2             	mov    rdx,rsi
  4035e2:	45 89 f1             	mov    r9d,r14d
  4035e5:	4c 8b 05 bc e8 19 00 	mov    r8,QWORD PTR [rip+0x19e8bc]        # 5a1ea8 <__slm_global+0x28>
  4035ec:	4c 89 d6             	mov    rsi,r10
  4035ef:	e8 2c dd 00 00       	call   411320 <cos_switch>
  4035f4:	41 89 c7             	mov    r15d,eax
	if (unlikely(ret != 0)) {
  4035f7:	45 85 ff             	test   r15d,r15d
  4035fa:	0f 84 bb fe ff ff    	je     4034bb <sched_thd_block_timeout+0x17b>
		assert(ret != -EPERM);
  403600:	41 83 ff ff          	cmp    r15d,0xffffffff
  403604:	0f 84 a0 00 00 00    	je     4036aa <sched_thd_block_timeout+0x36a>
		assert(ret != -EINVAL);
  40360a:	41 83 ff ea          	cmp    r15d,0xffffffea
  40360e:	0f 84 03 01 00 00    	je     403717 <sched_thd_block_timeout+0x3d7>
		if (ret == -EBUSY) return ret;
  403614:	41 83 ff f0          	cmp    r15d,0xfffffff0
  403618:	0f 84 a0 fe ff ff    	je     4034be <sched_thd_block_timeout+0x17e>
		assert(ret == -EAGAIN);
  40361e:	41 83 ff f5          	cmp    r15d,0xfffffff5
  403622:	0f 85 0b 01 00 00    	jne    403733 <sched_thd_block_timeout+0x3f3>
		tok    = cos_sched_sync();
  403628:	e8 d3 dc 00 00       	call   411300 <cos_sched_sync>
  40362d:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  403630:	48 8b 05 49 e8 19 00 	mov    rax,QWORD PTR [rip+0x19e849]        # 5a1e80 <__slm_global>
		if (unlikely(owner)) {
  403637:	48 89 c1             	mov    rcx,rax
  40363a:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  40363e:	0f 85 0b 01 00 00    	jne    40374f <sched_thd_block_timeout+0x40f>
        __asm__ __volatile__("lock " PS_CAS_STR
  403644:	f0 4c 0f b1 25 33 e8 	lock cmpxchg QWORD PTR [rip+0x19e833],r12        # 5a1e80 <__slm_global>
  40364b:	19 00 
  40364d:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  403650:	84 c0                	test   al,al
  403652:	0f 85 ba fd ff ff    	jne    403412 <sched_thd_block_timeout+0xd2>
  403658:	eb ce                	jmp    403628 <sched_thd_block_timeout+0x2e8>
  40365a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	__asm__ __volatile__("rdtsc" : "=a" (a), "=d" (d), "=c" (c) : : );
  403660:	0f 31                	rdtsc  
	return ((u64_t)d << 32) | (u64_t)a;
  403662:	48 c1 e2 20          	shl    rdx,0x20
  403666:	48 09 d0             	or     rax,rdx
  403669:	48 89 c2             	mov    rdx,rax
  40366c:	4c 29 ea             	sub    rdx,r13
	assert(cycles_greater_than(now, abs_timeout));
  40366f:	48 85 d2             	test   rdx,rdx
  403672:	0f 8f 71 fe ff ff    	jg     4034e9 <sched_thd_block_timeout+0x1a9>
  403678:	be 24 00 00 00       	mov    esi,0x24
  40367d:	bf 68 bb 41 00       	mov    edi,0x41bb68
  403682:	e8 49 6a 00 00       	call   40a0d0 <cos_print_str>
  403687:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40368e:	00 00 00 00 
  403692:	0f 0b                	ud2    
  403694:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	return t != &g->idle_thd && t != &g->sched_thd;
  403698:	48 81 fb 00 1f 5a 00 	cmp    rbx,0x5a1f00
  40369f:	74 4f                	je     4036f0 <sched_thd_block_timeout+0x3b0>
  4036a1:	48 81 fb 88 1e 5a 00 	cmp    rbx,0x5a1e88
  4036a8:	74 46                	je     4036f0 <sched_thd_block_timeout+0x3b0>
  4036aa:	be 61 00 00 00       	mov    esi,0x61
  4036af:	bf 90 b7 41 00       	mov    edi,0x41b790
  4036b4:	e8 17 6a 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EPERM);
  4036b9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4036c0:	00 00 00 00 
  4036c4:	0f 0b                	ud2    
			prio    = curr->priority;
  4036c6:	49 8b 74 24 30       	mov    rsi,QWORD PTR [r12+0x30]
			timeout = TCAP_TIME_NIL;
  4036cb:	31 c9                	xor    ecx,ecx
  4036cd:	e9 f2 fe ff ff       	jmp    4035c4 <sched_thd_block_timeout+0x284>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  4036d2:	48 8b 7b 28          	mov    rdi,QWORD PTR [rbx+0x28]
  4036d6:	48 8b 15 cb e7 19 00 	mov    rdx,QWORD PTR [rip+0x19e7cb]        # 5a1ea8 <__slm_global+0x28>
  4036dd:	44 89 f1             	mov    ecx,r14d
  4036e0:	4c 89 c6             	mov    rsi,r8
  4036e3:	e8 a8 dc 00 00       	call   411390 <cos_sched_asnd>
  4036e8:	41 89 c7             	mov    r15d,eax
  4036eb:	e9 07 ff ff ff       	jmp    4035f7 <sched_thd_block_timeout+0x2b7>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  4036f0:	49 8b 54 24 30       	mov    rdx,QWORD PTR [r12+0x30]
  4036f5:	4c 8b 05 ac e7 19 00 	mov    r8,QWORD PTR [rip+0x19e7ac]        # 5a1ea8 <__slm_global+0x28>
  4036fc:	31 c9                	xor    ecx,ecx
  4036fe:	31 f6                	xor    esi,esi
  403700:	48 8b 3d 91 e7 19 00 	mov    rdi,QWORD PTR [rip+0x19e791]        # 5a1e98 <__slm_global+0x18>
  403707:	45 89 f1             	mov    r9d,r14d
  40370a:	e8 11 dc 00 00       	call   411320 <cos_switch>
  40370f:	41 89 c7             	mov    r15d,eax
  403712:	e9 e0 fe ff ff       	jmp    4035f7 <sched_thd_block_timeout+0x2b7>
  403717:	be 61 00 00 00       	mov    esi,0x61
  40371c:	bf f8 b7 41 00       	mov    edi,0x41b7f8
  403721:	e8 aa 69 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  403726:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40372d:	00 00 00 00 
  403731:	0f 0b                	ud2    
  403733:	be 61 00 00 00       	mov    esi,0x61
  403738:	bf 60 b8 41 00       	mov    edi,0x41b860
  40373d:	e8 8e 69 00 00       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  403742:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403749:	00 00 00 00 
  40374d:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  40374f:	41 89 c0             	mov    r8d,eax
  403752:	4c 89 e2             	mov    rdx,r12
  403755:	48 89 c6             	mov    rsi,rax
  403758:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  40375d:	41 83 e0 01          	and    r8d,0x1
  403761:	e8 aa 00 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  403766:	83 f8 f0             	cmp    eax,0xfffffff0
  403769:	0f 85 b9 fe ff ff    	jne    403628 <sched_thd_block_timeout+0x2e8>
  40376f:	be 59 00 00 00       	mov    esi,0x59
  403774:	bf a0 b6 41 00       	mov    edi,0x41b6a0
  403779:	e8 52 69 00 00       	call   40a0d0 <cos_print_str>
  40377e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403785:	00 00 00 00 
  403789:	0f 0b                	ud2    
  40378b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000403790 <thd_sleep>:
{
  403790:	f3 0f 1e fa          	endbr64 
  403794:	55                   	push   rbp
  403795:	48 89 e5             	mov    rbp,rsp
  403798:	41 57                	push   r15
  40379a:	41 56                	push   r14
  40379c:	41 55                	push   r13
  40379e:	41 54                	push   r12
  4037a0:	53                   	push   rbx
  4037a1:	48 83 ec 08          	sub    rsp,0x8
	__asm__ __volatile__("rdtsc" : "=a" (a), "=d" (d), "=c" (c) : : );
  4037a5:	0f 31                	rdtsc  
	return ((u64_t)d << 32) | (u64_t)a;
  4037a7:	48 c1 e2 20          	shl    rdx,0x20
  4037ab:	48 09 c2             	or     rdx,rax
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  4037ae:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  4037b1:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
	cycles_t timeout = c + slm_now();
  4037b7:	4c 8d 2c 3a          	lea    r13,[rdx+rdi*1]
  4037bb:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  4037c2:	48 85 c0             	test   rax,rax
  4037c5:	0f 84 ad 01 00 00    	je     403978 <thd_sleep+0x1e8>
  4037cb:	83 e8 01             	sub    eax,0x1
  4037ce:	83 f8 18             	cmp    eax,0x18
  4037d1:	0f 87 a1 01 00 00    	ja     403978 <thd_sleep+0x1e8>
  4037d7:	48 8b 14 c5 c0 e6 45 	mov    rdx,QWORD PTR [rax*8+0x45e6c0]
  4037de:	00 
  4037df:	45 31 e4             	xor    r12d,r12d
  4037e2:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  4037e9:	0f 85 51 01 00 00    	jne    403940 <thd_sleep+0x1b0>
	__asm__ __volatile__("rdtsc" : "=a" (a), "=d" (d), "=c" (c) : : );
  4037ef:	0f 31                	rdtsc  
	return ((u64_t)d << 32) | (u64_t)a;
  4037f1:	48 c1 e2 20          	shl    rdx,0x20
  4037f5:	48 09 c2             	or     rdx,rax
  4037f8:	4c 89 e8             	mov    rax,r13
  4037fb:	48 29 d0             	sub    rax,rdx
	while (cycles_greater_than(timeout, slm_now())) {
  4037fe:	48 85 c0             	test   rax,rax
  403801:	0f 8e da 02 00 00    	jle    403ae1 <thd_sleep+0x351>
	assert(current);
  403807:	4d 85 e4             	test   r12,r12
  40380a:	0f 84 ac 01 00 00    	je     4039bc <thd_sleep+0x22c>
		tok    = cos_sched_sync();
  403810:	e8 eb da 00 00       	call   411300 <cos_sched_sync>
  403815:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  403818:	48 8b 05 61 e6 19 00 	mov    rax,QWORD PTR [rip+0x19e661]        # 5a1e80 <__slm_global>
		if (unlikely(owner)) {
  40381f:	48 89 c1             	mov    rcx,rax
  403822:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  403826:	0f 85 54 01 00 00    	jne    403980 <thd_sleep+0x1f0>
        __asm__ __volatile__("lock " PS_CAS_STR
  40382c:	f0 4c 0f b1 25 4b e6 	lock cmpxchg QWORD PTR [rip+0x19e64b],r12        # 5a1e80 <__slm_global>
  403833:	19 00 
  403835:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  403838:	84 c0                	test   al,al
  40383a:	74 d4                	je     403810 <thd_sleep+0x80>
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  40383c:	4c 89 ee             	mov    rsi,r13
  40383f:	4c 89 e7             	mov    rdi,r12
  403842:	e8 09 f4 00 00       	call   412c50 <slm_timer_quantum_add>
		if (slm_timer_add(current, timeout)) goto done;
  403847:	85 c0                	test   eax,eax
  403849:	75 10                	jne    40385b <thd_sleep+0xcb>
		if (slm_thd_block(current)) {
  40384b:	4c 89 e7             	mov    rdi,r12
  40384e:	e8 6d 00 01 00       	call   4138c0 <slm_thd_block>
  403853:	85 c0                	test   eax,eax
  403855:	0f 85 0d 01 00 00    	jne    403968 <thd_sleep+0x1d8>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  40385b:	e8 00 80 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	tok  = cos_sched_sync();
  403860:	e8 9b da 00 00       	call   411300 <cos_sched_sync>
  403865:	41 89 c6             	mov    r14d,eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  403868:	e8 23 ec 00 00       	call   412490 <slm_sched_fprr_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  40386d:	48 85 c0             	test   rax,rax
  403870:	48 89 c3             	mov    rbx,rax
  403873:	b8 00 1f 5a 00       	mov    eax,0x5a1f00
  403878:	48 0f 44 d8          	cmove  rbx,rax
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  40387c:	8b 43 04             	mov    eax,DWORD PTR [rbx+0x4]
  40387f:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  403882:	83 f8 01             	cmp    eax,0x1
  403885:	76 19                	jbe    4038a0 <thd_sleep+0x110>
  403887:	e9 4c 01 00 00       	jmp    4039d8 <thd_sleep+0x248>
  40388c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  403890:	f0 48 0f b1 15 e7 e5 	lock cmpxchg QWORD PTR [rip+0x19e5e7],rdx        # 5a1e80 <__slm_global>
  403897:	19 00 
  403899:	0f 94 c0             	sete   al
	while (ret != 0) {
  40389c:	84 c0                	test   al,al
  40389e:	75 2e                	jne    4038ce <thd_sleep+0x13e>
		tok    = cos_sched_sync();
  4038a0:	e8 5b da 00 00       	call   411300 <cos_sched_sync>
  4038a5:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4038a7:	48 8b 05 d2 e5 19 00 	mov    rax,QWORD PTR [rip+0x19e5d2]        # 5a1e80 <__slm_global>
		if (unlikely(contention)) {
  4038ae:	48 89 c2             	mov    rdx,rax
  4038b1:	83 e2 01             	and    edx,0x1
  4038b4:	74 da                	je     403890 <thd_sleep+0x100>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  4038b6:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  4038b9:	48 89 c2             	mov    rdx,rax
  4038bc:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  4038c1:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  4038c5:	e8 96 ff 00 00       	call   413860 <slm_cs_exit_contention>
  4038ca:	85 c0                	test   eax,eax
  4038cc:	75 d2                	jne    4038a0 <thd_sleep+0x110>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  4038ce:	e8 8d 7f 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4038d3:	8b 03                	mov    eax,DWORD PTR [rbx]
	timeout = g->timeout_next;
  4038d5:	4c 8b 05 ac e6 19 00 	mov    r8,QWORD PTR [rip+0x19e6ac]        # 5a1f88 <__slm_global+0x108>
	prio = inherit_prio ? curr->priority : t->priority;
  4038dc:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4038e0:	a8 0b                	test   al,0xb
  4038e2:	0f 85 0c 01 00 00    	jne    4039f4 <thd_sleep+0x264>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  4038e8:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  4038ec:	44 89 f1             	mov    ecx,r14d
  4038ef:	4c 89 c2             	mov    rdx,r8
  4038f2:	e8 69 8e 00 00       	call   40c760 <cos_defswitch>
  4038f7:	41 89 c7             	mov    r15d,eax
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  4038fa:	83 f8 ff             	cmp    eax,0xffffffff
  4038fd:	0f 84 32 01 00 00    	je     403a35 <thd_sleep+0x2a5>
	if (unlikely(ret != 0)) {
  403903:	85 c0                	test   eax,eax
  403905:	0f 85 92 01 00 00    	jne    403a9d <thd_sleep+0x30d>
  40390b:	45 31 ff             	xor    r15d,r15d
  40390e:	4c 89 e7             	mov    rdi,r12
  403911:	e8 ca f3 00 00       	call   412ce0 <slm_timer_quantum_cancel>
	__asm__ __volatile__("rdtsc" : "=a" (a), "=d" (d), "=c" (c) : : );
  403916:	0f 31                	rdtsc  
	return ((u64_t)d << 32) | (u64_t)a;
  403918:	48 c1 e2 20          	shl    rdx,0x20
  40391c:	48 09 c2             	or     rdx,rax
  40391f:	4c 89 e8             	mov    rax,r13
  403922:	48 29 d0             	sub    rax,rdx
	while (cycles_greater_than(timeout, slm_now())) {
  403925:	48 85 c0             	test   rax,rax
  403928:	0f 8f e2 fe ff ff    	jg     403810 <thd_sleep+0x80>
}
  40392e:	48 83 c4 08          	add    rsp,0x8
  403932:	44 89 f8             	mov    eax,r15d
  403935:	5b                   	pop    rbx
  403936:	41 5c                	pop    r12
  403938:	41 5d                	pop    r13
  40393a:	41 5e                	pop    r14
  40393c:	41 5f                	pop    r15
  40393e:	5d                   	pop    rbp
  40393f:	c3                   	ret    
  403940:	83 e2 01             	and    edx,0x1
  403943:	0f 85 a6 fe ff ff    	jne    4037ef <thd_sleep+0x5f>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403949:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  40394d:	4c 8d 24 50          	lea    r12,[rax+rdx*2]
  403951:	49 c1 e4 04          	shl    r12,0x4
  403955:	49 81 c4 88 e7 45 00 	add    r12,0x45e788
  40395c:	e9 8e fe ff ff       	jmp    4037ef <thd_sleep+0x5f>
  403961:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  403968:	4c 89 e7             	mov    rdi,r12
  40396b:	e8 70 f3 00 00       	call   412ce0 <slm_timer_quantum_cancel>
  403970:	e9 e6 fe ff ff       	jmp    40385b <thd_sleep+0xcb>
  403975:	0f 1f 00             	nop    DWORD PTR [rax]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403978:	45 31 e4             	xor    r12d,r12d
  40397b:	e9 6f fe ff ff       	jmp    4037ef <thd_sleep+0x5f>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  403980:	41 89 c0             	mov    r8d,eax
  403983:	4c 89 e2             	mov    rdx,r12
  403986:	48 89 c6             	mov    rsi,rax
  403989:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  40398e:	41 83 e0 01          	and    r8d,0x1
  403992:	e8 79 fe 00 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  403997:	83 f8 f0             	cmp    eax,0xfffffff0
  40399a:	0f 85 70 fe ff ff    	jne    403810 <thd_sleep+0x80>
  4039a0:	be 59 00 00 00       	mov    esi,0x59
  4039a5:	bf a0 b6 41 00       	mov    edi,0x41b6a0
  4039aa:	e8 21 67 00 00       	call   40a0d0 <cos_print_str>
  4039af:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4039b6:	00 00 00 00 
  4039ba:	0f 0b                	ud2    
  4039bc:	be 59 00 00 00       	mov    esi,0x59
  4039c1:	bf 40 b6 41 00       	mov    edi,0x41b640
  4039c6:	e8 05 67 00 00       	call   40a0d0 <cos_print_str>
	assert(current);
  4039cb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4039d2:	00 00 00 00 
  4039d6:	0f 0b                	ud2    
  4039d8:	be 61 00 00 00       	mov    esi,0x61
  4039dd:	bf 28 b7 41 00       	mov    edi,0x41b728
  4039e2:	e8 e9 66 00 00       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  4039e7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4039ee:	00 00 00 00 
  4039f2:	0f 0b                	ud2    
	timeout = g->timeout_next;
  4039f4:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  4039f7:	48 81 fb 88 1e 5a 00 	cmp    rbx,0x5a1e88
  4039fe:	74 63                	je     403a63 <thd_sleep+0x2d3>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  403a00:	a8 02                	test   al,0x2
  403a02:	0f 85 e1 00 00 00    	jne    403ae9 <thd_sleep+0x359>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  403a08:	49 89 c8             	mov    r8,rcx
  403a0b:	a8 01                	test   al,0x1
  403a0d:	0f 84 d5 fe ff ff    	je     4038e8 <thd_sleep+0x158>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  403a13:	4c 8b 53 08          	mov    r10,QWORD PTR [rbx+0x8]
  403a17:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  403a1b:	48 89 f2             	mov    rdx,rsi
  403a1e:	45 89 f1             	mov    r9d,r14d
  403a21:	4c 8b 05 80 e4 19 00 	mov    r8,QWORD PTR [rip+0x19e480]        # 5a1ea8 <__slm_global+0x28>
  403a28:	4c 89 d6             	mov    rsi,r10
  403a2b:	e8 f0 d8 00 00       	call   411320 <cos_switch>
  403a30:	41 89 c7             	mov    r15d,eax
  403a33:	eb 59                	jmp    403a8e <thd_sleep+0x2fe>
	return t != &g->idle_thd && t != &g->sched_thd;
  403a35:	48 81 fb 00 1f 5a 00 	cmp    rbx,0x5a1f00
  403a3c:	74 2e                	je     403a6c <thd_sleep+0x2dc>
  403a3e:	48 81 fb 88 1e 5a 00 	cmp    rbx,0x5a1e88
  403a45:	74 25                	je     403a6c <thd_sleep+0x2dc>
  403a47:	be 61 00 00 00       	mov    esi,0x61
  403a4c:	bf 90 b7 41 00       	mov    edi,0x41b790
  403a51:	e8 7a 66 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EPERM);
  403a56:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403a5d:	00 00 00 00 
  403a61:	0f 0b                	ud2    
			prio    = curr->priority;
  403a63:	49 8b 74 24 30       	mov    rsi,QWORD PTR [r12+0x30]
			timeout = TCAP_TIME_NIL;
  403a68:	31 c9                	xor    ecx,ecx
  403a6a:	eb 94                	jmp    403a00 <thd_sleep+0x270>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  403a6c:	49 8b 54 24 30       	mov    rdx,QWORD PTR [r12+0x30]
  403a71:	4c 8b 05 30 e4 19 00 	mov    r8,QWORD PTR [rip+0x19e430]        # 5a1ea8 <__slm_global+0x28>
  403a78:	31 c9                	xor    ecx,ecx
  403a7a:	31 f6                	xor    esi,esi
  403a7c:	48 8b 3d 15 e4 19 00 	mov    rdi,QWORD PTR [rip+0x19e415]        # 5a1e98 <__slm_global+0x18>
  403a83:	45 89 f1             	mov    r9d,r14d
  403a86:	e8 95 d8 00 00       	call   411320 <cos_switch>
  403a8b:	41 89 c7             	mov    r15d,eax
	if (unlikely(ret != 0)) {
  403a8e:	45 85 ff             	test   r15d,r15d
  403a91:	0f 84 74 fe ff ff    	je     40390b <thd_sleep+0x17b>
		assert(ret != -EPERM);
  403a97:	41 83 ff ff          	cmp    r15d,0xffffffff
  403a9b:	74 aa                	je     403a47 <thd_sleep+0x2b7>
		assert(ret != -EINVAL);
  403a9d:	41 83 ff ea          	cmp    r15d,0xffffffea
  403aa1:	74 61                	je     403b04 <thd_sleep+0x374>
		if (ret == -EBUSY) return ret;
  403aa3:	41 83 ff f0          	cmp    r15d,0xfffffff0
  403aa7:	0f 84 61 fe ff ff    	je     40390e <thd_sleep+0x17e>
		assert(ret == -EAGAIN);
  403aad:	41 83 ff f5          	cmp    r15d,0xfffffff5
  403ab1:	75 6d                	jne    403b20 <thd_sleep+0x390>
		tok    = cos_sched_sync();
  403ab3:	e8 48 d8 00 00       	call   411300 <cos_sched_sync>
  403ab8:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  403abb:	48 8b 05 be e3 19 00 	mov    rax,QWORD PTR [rip+0x19e3be]        # 5a1e80 <__slm_global>
		if (unlikely(owner)) {
  403ac2:	48 89 c1             	mov    rcx,rax
  403ac5:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  403ac9:	75 71                	jne    403b3c <thd_sleep+0x3ac>
        __asm__ __volatile__("lock " PS_CAS_STR
  403acb:	f0 4c 0f b1 25 ac e3 	lock cmpxchg QWORD PTR [rip+0x19e3ac],r12        # 5a1e80 <__slm_global>
  403ad2:	19 00 
  403ad4:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  403ad7:	84 c0                	test   al,al
  403ad9:	0f 85 81 fd ff ff    	jne    403860 <thd_sleep+0xd0>
  403adf:	eb d2                	jmp    403ab3 <thd_sleep+0x323>
	int ret = 0;
  403ae1:	45 31 ff             	xor    r15d,r15d
	return thd_block_until(timeout);
  403ae4:	e9 45 fe ff ff       	jmp    40392e <thd_sleep+0x19e>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  403ae9:	48 8b 7b 28          	mov    rdi,QWORD PTR [rbx+0x28]
  403aed:	48 8b 15 b4 e3 19 00 	mov    rdx,QWORD PTR [rip+0x19e3b4]        # 5a1ea8 <__slm_global+0x28>
  403af4:	44 89 f1             	mov    ecx,r14d
  403af7:	4c 89 c6             	mov    rsi,r8
  403afa:	e8 91 d8 00 00       	call   411390 <cos_sched_asnd>
  403aff:	41 89 c7             	mov    r15d,eax
  403b02:	eb 8a                	jmp    403a8e <thd_sleep+0x2fe>
  403b04:	be 61 00 00 00       	mov    esi,0x61
  403b09:	bf f8 b7 41 00       	mov    edi,0x41b7f8
  403b0e:	e8 bd 65 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  403b13:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403b1a:	00 00 00 00 
  403b1e:	0f 0b                	ud2    
  403b20:	be 61 00 00 00       	mov    esi,0x61
  403b25:	bf 60 b8 41 00       	mov    edi,0x41b860
  403b2a:	e8 a1 65 00 00       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  403b2f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403b36:	00 00 00 00 
  403b3a:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  403b3c:	41 89 c0             	mov    r8d,eax
  403b3f:	4c 89 e2             	mov    rdx,r12
  403b42:	48 89 c6             	mov    rsi,rax
  403b45:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  403b4a:	41 83 e0 01          	and    r8d,0x1
  403b4e:	e8 bd fc 00 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  403b53:	83 f8 f0             	cmp    eax,0xfffffff0
  403b56:	0f 85 57 ff ff ff    	jne    403ab3 <thd_sleep+0x323>
  403b5c:	e9 3f fe ff ff       	jmp    4039a0 <thd_sleep+0x210>
  403b61:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  403b68:	00 00 00 00 
  403b6c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000403b70 <sched_blkpt_alloc>:
{
  403b70:	f3 0f 1e fa          	endbr64 
  403b74:	55                   	push   rbp
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  403b75:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  403b78:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  403b7e:	48 89 e5             	mov    rbp,rsp
  403b81:	41 54                	push   r12
  403b83:	48 83 ec 08          	sub    rsp,0x8
  403b87:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403b8e:	48 85 c0             	test   rax,rax
  403b91:	0f 84 09 01 00 00    	je     403ca0 <sched_blkpt_alloc+0x130>
  403b97:	83 e8 01             	sub    eax,0x1
  403b9a:	83 f8 18             	cmp    eax,0x18
  403b9d:	0f 87 fd 00 00 00    	ja     403ca0 <sched_blkpt_alloc+0x130>
  403ba3:	48 8b 14 c5 c0 e6 45 	mov    rdx,QWORD PTR [rax*8+0x45e6c0]
  403baa:	00 
  403bab:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  403bb2:	0f 84 e8 00 00 00    	je     403ca0 <sched_blkpt_alloc+0x130>
  403bb8:	83 e2 01             	and    edx,0x1
  403bbb:	0f 85 df 00 00 00    	jne    403ca0 <sched_blkpt_alloc+0x130>
	return &ss_thd_get(cos_thdid())->thd;
  403bc1:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  403bc5:	4c 8d 24 50          	lea    r12,[rax+rdx*2]
  403bc9:	49 c1 e4 04          	shl    r12,0x4
  403bcd:	49 81 c4 88 e7 45 00 	add    r12,0x45e788
		tok    = cos_sched_sync();
  403bd4:	e8 27 d7 00 00       	call   411300 <cos_sched_sync>
  403bd9:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  403bdc:	48 8b 05 9d e2 19 00 	mov    rax,QWORD PTR [rip+0x19e29d]        # 5a1e80 <__slm_global>
		if (unlikely(owner)) {
  403be3:	48 89 c1             	mov    rcx,rax
  403be6:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  403bea:	0f 85 d0 00 00 00    	jne    403cc0 <sched_blkpt_alloc+0x150>
  403bf0:	f0 4c 0f b1 25 87 e2 	lock cmpxchg QWORD PTR [rip+0x19e287],r12        # 5a1e80 <__slm_global>
  403bf7:	19 00 
  403bf9:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  403bfc:	84 c0                	test   al,al
  403bfe:	74 d4                	je     403bd4 <sched_blkpt_alloc+0x64>
	id = (sched_blkpt_id_t)__blkpt_offset;
  403c00:	44 8b 25 f9 03 02 00 	mov    r12d,DWORD PTR [rip+0x203f9]        # 424000 <__blkpt_offset>
	if (id - 1 == NBLKPTS) return NULL;
  403c07:	41 81 fc 01 a0 00 00 	cmp    r12d,0xa001
  403c0e:	0f 84 e8 00 00 00    	je     403cfc <sched_blkpt_alloc+0x18c>
	return &__blkpts[id-1];
  403c14:	41 8d 44 24 ff       	lea    eax,[r12-0x1]
  403c19:	48 c1 e0 05          	shl    rax,0x5
	m->id    = id;
  403c1d:	44 89 a0 c0 f8 45 00 	mov    DWORD PTR [rax+0x45f8c0],r12d
	m->epoch = 0;
  403c24:	48 c7 80 c8 f8 45 00 	mov    QWORD PTR [rax+0x45f8c8],0x0
  403c2b:	00 00 00 00 
	h->head = NULL;
  403c2f:	48 c7 80 d0 f8 45 00 	mov    QWORD PTR [rax+0x45f8d0],0x0
  403c36:	00 00 00 00 
{ l->o = 0; }
  403c3a:	48 c7 80 d8 f8 45 00 	mov    QWORD PTR [rax+0x45f8d8],0x0
  403c41:	00 00 00 00 
	__blkpt_offset++;
  403c45:	41 8d 44 24 01       	lea    eax,[r12+0x1]
  403c4a:	89 05 b0 03 02 00    	mov    DWORD PTR [rip+0x203b0],eax        # 424000 <__blkpt_offset>
  403c50:	eb 16                	jmp    403c68 <sched_blkpt_alloc+0xf8>
  403c52:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  403c58:	f0 48 0f b1 15 1f e2 	lock cmpxchg QWORD PTR [rip+0x19e21f],rdx        # 5a1e80 <__slm_global>
  403c5f:	19 00 
  403c61:	0f 94 c0             	sete   al
	while (ret != 0) {
  403c64:	84 c0                	test   al,al
  403c66:	75 2e                	jne    403c96 <sched_blkpt_alloc+0x126>
		tok    = cos_sched_sync();
  403c68:	e8 93 d6 00 00       	call   411300 <cos_sched_sync>
  403c6d:	89 c1                	mov    ecx,eax
  403c6f:	48 8b 05 0a e2 19 00 	mov    rax,QWORD PTR [rip+0x19e20a]        # 5a1e80 <__slm_global>
		if (unlikely(contention)) {
  403c76:	48 89 c2             	mov    rdx,rax
  403c79:	83 e2 01             	and    edx,0x1
  403c7c:	74 da                	je     403c58 <sched_blkpt_alloc+0xe8>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  403c7e:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  403c81:	48 89 c2             	mov    rdx,rax
  403c84:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  403c89:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  403c8d:	e8 ce fb 00 00       	call   413860 <slm_cs_exit_contention>
  403c92:	85 c0                	test   eax,eax
  403c94:	75 d2                	jne    403c68 <sched_blkpt_alloc+0xf8>
}
  403c96:	44 89 e0             	mov    eax,r12d
  403c99:	4c 8b 65 f8          	mov    r12,QWORD PTR [rbp-0x8]
  403c9d:	c9                   	leave  
  403c9e:	c3                   	ret    
  403c9f:	90                   	nop
  403ca0:	be 59 00 00 00       	mov    esi,0x59
  403ca5:	bf 40 b6 41 00       	mov    edi,0x41b640
  403caa:	e8 21 64 00 00       	call   40a0d0 <cos_print_str>
	assert(current);
  403caf:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403cb6:	00 00 00 00 
  403cba:	0f 0b                	ud2    
  403cbc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  403cc0:	41 89 c0             	mov    r8d,eax
  403cc3:	4c 89 e2             	mov    rdx,r12
  403cc6:	48 89 c6             	mov    rsi,rax
  403cc9:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  403cce:	41 83 e0 01          	and    r8d,0x1
  403cd2:	e8 39 fb 00 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  403cd7:	83 f8 f0             	cmp    eax,0xfffffff0
  403cda:	0f 85 f4 fe ff ff    	jne    403bd4 <sched_blkpt_alloc+0x64>
  403ce0:	be 59 00 00 00       	mov    esi,0x59
  403ce5:	bf a0 b6 41 00       	mov    edi,0x41b6a0
  403cea:	e8 e1 63 00 00       	call   40a0d0 <cos_print_str>
  403cef:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403cf6:	00 00 00 00 
  403cfa:	0f 0b                	ud2    
	if (!m) ERR_THROW(SCHED_BLKPT_NULL, unlock);
  403cfc:	45 31 e4             	xor    r12d,r12d
	while (ret != 0) {
  403cff:	e9 64 ff ff ff       	jmp    403c68 <sched_blkpt_alloc+0xf8>
  403d04:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  403d0b:	00 00 00 00 
  403d0f:	90                   	nop

0000000000403d10 <sched_blkpt_free>:
  403d10:	f3 0f 1e fa          	endbr64 
  403d14:	31 c0                	xor    eax,eax
  403d16:	c3                   	ret    
  403d17:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  403d1e:	00 00 

0000000000403d20 <sched_blkpt_trigger>:
{
  403d20:	f3 0f 1e fa          	endbr64 
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  403d24:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  403d27:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  403d2d:	49 89 f0             	mov    r8,rsi
  403d30:	89 d1                	mov    ecx,edx
  403d32:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403d39:	48 85 c0             	test   rax,rax
  403d3c:	74 42                	je     403d80 <sched_blkpt_trigger+0x60>
  403d3e:	83 e8 01             	sub    eax,0x1
  403d41:	83 f8 18             	cmp    eax,0x18
  403d44:	77 3a                	ja     403d80 <sched_blkpt_trigger+0x60>
  403d46:	48 8b 14 c5 c0 e6 45 	mov    rdx,QWORD PTR [rax*8+0x45e6c0]
  403d4d:	00 
  403d4e:	31 f6                	xor    esi,esi
  403d50:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  403d57:	74 18                	je     403d71 <sched_blkpt_trigger+0x51>
  403d59:	83 e2 01             	and    edx,0x1
  403d5c:	75 13                	jne    403d71 <sched_blkpt_trigger+0x51>
  403d5e:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  403d62:	48 8d 34 50          	lea    rsi,[rax+rdx*2]
  403d66:	48 c1 e6 04          	shl    rsi,0x4
  403d6a:	48 81 c6 88 e7 45 00 	add    rsi,0x45e788
	return slm_blkpt_trigger(blkpt, current, epoch, single);
  403d71:	4c 89 c2             	mov    rdx,r8
  403d74:	e9 07 d0 ff ff       	jmp    400d80 <slm_blkpt_trigger>
  403d79:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403d80:	31 f6                	xor    esi,esi
	return slm_blkpt_trigger(blkpt, current, epoch, single);
  403d82:	4c 89 c2             	mov    rdx,r8
  403d85:	e9 f6 cf ff ff       	jmp    400d80 <slm_blkpt_trigger>
  403d8a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000403d90 <sched_blkpt_block>:
{
  403d90:	f3 0f 1e fa          	endbr64 
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  403d94:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  403d97:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  403d9d:	49 89 f0             	mov    r8,rsi
  403da0:	48 89 d1             	mov    rcx,rdx
  403da3:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403daa:	48 85 c0             	test   rax,rax
  403dad:	74 41                	je     403df0 <sched_blkpt_block+0x60>
  403daf:	83 e8 01             	sub    eax,0x1
  403db2:	83 f8 18             	cmp    eax,0x18
  403db5:	77 39                	ja     403df0 <sched_blkpt_block+0x60>
  403db7:	48 8b 14 c5 c0 e6 45 	mov    rdx,QWORD PTR [rax*8+0x45e6c0]
  403dbe:	00 
  403dbf:	31 f6                	xor    esi,esi
  403dc1:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  403dc8:	74 18                	je     403de2 <sched_blkpt_block+0x52>
  403dca:	83 e2 01             	and    edx,0x1
  403dcd:	75 13                	jne    403de2 <sched_blkpt_block+0x52>
  403dcf:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  403dd3:	48 8d 34 50          	lea    rsi,[rax+rdx*2]
  403dd7:	48 c1 e6 04          	shl    rsi,0x4
  403ddb:	48 81 c6 88 e7 45 00 	add    rsi,0x45e788
	return slm_blkpt_block(blkpt, current, epoch, dependency);
  403de2:	4c 89 c2             	mov    rdx,r8
  403de5:	e9 e6 d3 ff ff       	jmp    4011d0 <slm_blkpt_block>
  403dea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403df0:	31 f6                	xor    esi,esi
	return slm_blkpt_block(blkpt, current, epoch, dependency);
  403df2:	4c 89 c2             	mov    rdx,r8
  403df5:	e9 d6 d3 ff ff       	jmp    4011d0 <slm_blkpt_block>
  403dfa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000403e00 <syncipc_call>:
{
  403e00:	f3 0f 1e fa          	endbr64 
  403e04:	55                   	push   rbp
  403e05:	66 48 0f 6e ce       	movq   xmm1,rsi
  403e0a:	66 48 0f 6e d2       	movq   xmm2,rdx
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  403e0f:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  403e12:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  403e18:	66 0f 6c ca          	punpcklqdq xmm1,xmm2
  403e1c:	48 89 e5             	mov    rbp,rsp
  403e1f:	41 57                	push   r15
  403e21:	41 56                	push   r14
  403e23:	49 89 ce             	mov    r14,rcx
  403e26:	41 55                	push   r13
  403e28:	4d 89 c5             	mov    r13,r8
  403e2b:	41 54                	push   r12
  403e2d:	53                   	push   rbx
  403e2e:	48 83 ec 38          	sub    rsp,0x38
  403e32:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
  403e39:	0f 29 4d a0          	movaps XMMWORD PTR [rbp-0x60],xmm1
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403e3d:	48 85 c0             	test   rax,rax
  403e40:	0f 84 62 01 00 00    	je     403fa8 <syncipc_call+0x1a8>
  403e46:	83 e8 01             	sub    eax,0x1
  403e49:	83 f8 18             	cmp    eax,0x18
  403e4c:	0f 87 56 01 00 00    	ja     403fa8 <syncipc_call+0x1a8>
  403e52:	48 8b 14 c5 c0 e6 45 	mov    rdx,QWORD PTR [rax*8+0x45e6c0]
  403e59:	00 
  403e5a:	31 db                	xor    ebx,ebx
  403e5c:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  403e63:	0f 85 17 01 00 00    	jne    403f80 <syncipc_call+0x180>
	counts[type]++;
  403e69:	48 83 05 4f a2 05 00 	add    QWORD PTR [rip+0x5a24f],0x1        # 45e0c0 <counts>
  403e70:	01 
	struct ipc_retvals retvals = { .ready = 0 };
  403e71:	66 0f ef c0          	pxor   xmm0,xmm0
	if (ep->server == NULL) return -EAGAIN;
  403e75:	48 83 3d 8b a2 05 00 	cmp    QWORD PTR [rip+0x5a28b],0x0        # 45e108 <eps+0x8>
  403e7c:	00 
	struct ipc_retvals retvals = { .ready = 0 };
  403e7d:	48 c7 45 c0 00 00 00 	mov    QWORD PTR [rbp-0x40],0x0
  403e84:	00 
  403e85:	0f 29 45 b0          	movaps XMMWORD PTR [rbp-0x50],xmm0
	if (ep->server == NULL) return -EAGAIN;
  403e89:	0f 84 29 02 00 00    	je     4040b8 <syncipc_call+0x2b8>
		tok      = cos_sched_sync();
  403e8f:	e8 6c d4 00 00       	call   411300 <cos_sched_sync>
		switchto = ps_load(&ep->server);
  403e94:	4c 8b 3d 6d a2 05 00 	mov    r15,QWORD PTR [rip+0x5a26d]        # 45e108 <eps+0x8>
		tok      = cos_sched_sync();
  403e9b:	41 89 c4             	mov    r12d,eax
  403e9e:	31 c0                	xor    eax,eax
  403ea0:	f0 48 0f b1 1d 57 a2 	lock cmpxchg QWORD PTR [rip+0x5a257],rbx        # 45e100 <eps>
  403ea7:	05 00 
  403ea9:	0f 94 c0             	sete   al
		if (likely(ps_cas((unsigned long *)&ep->client, 0, (unsigned long)t))) {
  403eac:	84 c0                	test   al,al
  403eae:	0f 84 fc 00 00 00    	je     403fb0 <syncipc_call+0x1b0>
			ep->retvals = &retvals;
  403eb4:	48 8d 45 b0          	lea    rax,[rbp-0x50]
			ep->a0      = arg0;
  403eb8:	66 0f 6f 5d a0       	movdqa xmm3,XMMWORD PTR [rbp-0x60]
			ep->retvals = &retvals;
  403ebd:	48 89 05 5c a2 05 00 	mov    QWORD PTR [rip+0x5a25c],rax        # 45e120 <eps+0x20>
			assert(ps_load(&ep->client) == t);
  403ec4:	48 8b 05 35 a2 05 00 	mov    rax,QWORD PTR [rip+0x5a235]        # 45e100 <eps>
			ep->a0      = arg0;
  403ecb:	0f 29 1d 3e a2 05 00 	movaps XMMWORD PTR [rip+0x5a23e],xmm3        # 45e110 <eps+0x10>
			assert(ps_load(&ep->client) == t);
  403ed2:	48 39 d8             	cmp    rax,rbx
  403ed5:	0f 85 0f 01 00 00    	jne    403fea <syncipc_call+0x1ea>
		client = ps_load(&ep->client);
  403edb:	48 8b 05 1e a2 05 00 	mov    rax,QWORD PTR [rip+0x5a21e]        # 45e100 <eps>
	__asm__ __volatile__("rdtsc" : "=a" (a), "=d" (d), "=c" (c) : : );
  403ee2:	0f 31                	rdtsc  
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  403ee4:	41 8b 47 04          	mov    eax,DWORD PTR [r15+0x4]
  403ee8:	83 e8 02             	sub    eax,0x2
 * - `inherit_prio` - should `to` inherit `curr`'s priority?
 */
static inline int
slm_switch_to(struct slm_thd *curr, struct slm_thd *to, sched_tok_t tok, int inherit_prio)
{
	if (unlikely(!slm_state_is_runnable(to->state))) return 1;
  403eeb:	83 f8 01             	cmp    eax,0x1
  403eee:	0f 87 e4 00 00 00    	ja     403fd8 <syncipc_call+0x1d8>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  403ef4:	e8 67 79 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  403ef9:	41 8b 07             	mov    eax,DWORD PTR [r15]
	timeout = g->timeout_next;
  403efc:	4c 8b 05 85 e0 19 00 	mov    r8,QWORD PTR [rip+0x19e085]        # 5a1f88 <__slm_global+0x108>
	prio = inherit_prio ? curr->priority : t->priority;
  403f03:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  403f07:	a8 0b                	test   al,0xb
  403f09:	0f 85 f7 00 00 00    	jne    404006 <syncipc_call+0x206>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  403f0f:	49 8b 7f 10          	mov    rdi,QWORD PTR [r15+0x10]
  403f13:	4c 89 c2             	mov    rdx,r8
  403f16:	44 89 e1             	mov    ecx,r12d
  403f19:	e8 42 88 00 00       	call   40c760 <cos_defswitch>
  403f1e:	41 89 c0             	mov    r8d,eax
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  403f21:	83 f8 ff             	cmp    eax,0xffffffff
  403f24:	0f 84 21 01 00 00    	je     40404b <syncipc_call+0x24b>
		if (unlikely(ret)) {
  403f2a:	45 85 c0             	test   r8d,r8d
  403f2d:	40 0f 95 c6          	setne  sil
			if (ret != -EAGAIN) return ret;
  403f31:	41 83 f8 f5          	cmp    r8d,0xfffffff5
  403f35:	0f 95 c0             	setne  al
  403f38:	21 c6                	and    esi,eax
  403f3a:	0f 31                	rdtsc  
	counts[type]++;
  403f3c:	48 83 05 84 a1 05 00 	add    QWORD PTR [rip+0x5a184],0x1        # 45e0c8 <counts+0x8>
  403f43:	01 
			if (ret != -EAGAIN) return ret;
  403f44:	40 84 f6             	test   sil,sil
  403f47:	75 25                	jne    403f6e <syncipc_call+0x16e>
		if (likely(ps_load(&retvals.ready))) break;
  403f49:	8b 45 b0             	mov    eax,DWORD PTR [rbp-0x50]
  403f4c:	85 c0                	test   eax,eax
  403f4e:	0f 84 3b ff ff ff    	je     403e8f <syncipc_call+0x8f>
	*ret0 = ps_load(&retvals.r0);
  403f54:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
	counts[type]++;
  403f58:	48 83 05 70 a1 05 00 	add    QWORD PTR [rip+0x5a170],0x1        # 45e0d0 <counts+0x10>
  403f5f:	01 
	return 0;
  403f60:	45 31 c0             	xor    r8d,r8d
	*ret0 = ps_load(&retvals.r0);
  403f63:	49 89 06             	mov    QWORD PTR [r14],rax
	*ret1 = ps_load(&retvals.r1);
  403f66:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
  403f6a:	49 89 45 00          	mov    QWORD PTR [r13+0x0],rax
}
  403f6e:	48 83 c4 38          	add    rsp,0x38
  403f72:	44 89 c0             	mov    eax,r8d
  403f75:	5b                   	pop    rbx
  403f76:	41 5c                	pop    r12
  403f78:	41 5d                	pop    r13
  403f7a:	41 5e                	pop    r14
  403f7c:	41 5f                	pop    r15
  403f7e:	5d                   	pop    rbp
  403f7f:	c3                   	ret    
  403f80:	83 e2 01             	and    edx,0x1
  403f83:	0f 85 e0 fe ff ff    	jne    403e69 <syncipc_call+0x69>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403f89:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  403f8d:	48 8d 1c 50          	lea    rbx,[rax+rdx*2]
  403f91:	48 c1 e3 04          	shl    rbx,0x4
  403f95:	48 81 c3 88 e7 45 00 	add    rbx,0x45e788
  403f9c:	e9 c8 fe ff ff       	jmp    403e69 <syncipc_call+0x69>
  403fa1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  403fa8:	31 db                	xor    ebx,ebx
  403faa:	e9 ba fe ff ff       	jmp    403e69 <syncipc_call+0x69>
  403faf:	90                   	nop
		if (unlikely(ep->client != t && ep->retvals == NULL)) switchto = client;
  403fb0:	48 39 1d 49 a1 05 00 	cmp    QWORD PTR [rip+0x5a149],rbx        # 45e100 <eps>
		client = ps_load(&ep->client);
  403fb7:	48 8b 05 42 a1 05 00 	mov    rax,QWORD PTR [rip+0x5a142]        # 45e100 <eps>
		if (unlikely(ep->client != t && ep->retvals == NULL)) switchto = client;
  403fbe:	0f 84 1e ff ff ff    	je     403ee2 <syncipc_call+0xe2>
		client = ps_load(&ep->client);
  403fc4:	48 83 3d 54 a1 05 00 	cmp    QWORD PTR [rip+0x5a154],0x0        # 45e120 <eps+0x20>
  403fcb:	00 
  403fcc:	4c 0f 44 f8          	cmove  r15,rax
  403fd0:	e9 0d ff ff ff       	jmp    403ee2 <syncipc_call+0xe2>
  403fd5:	0f 1f 00             	nop    DWORD PTR [rax]
  403fd8:	0f 31                	rdtsc  
	counts[type]++;
  403fda:	48 83 05 e6 a0 05 00 	add    QWORD PTR [rip+0x5a0e6],0x1        # 45e0c8 <counts+0x8>
  403fe1:	01 
  403fe2:	41 b8 01 00 00 00    	mov    r8d,0x1
  403fe8:	eb 84                	jmp    403f6e <syncipc_call+0x16e>
  403fea:	be 24 00 00 00       	mov    esi,0x24
  403fef:	bf 90 bb 41 00       	mov    edi,0x41bb90
  403ff4:	e8 d7 60 00 00       	call   40a0d0 <cos_print_str>
			assert(ps_load(&ep->client) == t);
  403ff9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404000:	00 00 00 00 
  404004:	0f 0b                	ud2    
			timeout = TCAP_TIME_NIL;
  404006:	31 c9                	xor    ecx,ecx
  404008:	49 81 ff 88 1e 5a 00 	cmp    r15,0x5a1e88
  40400f:	49 0f 45 c8          	cmovne rcx,r8
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  404013:	a8 02                	test   al,0x2
  404015:	0f 85 85 00 00 00    	jne    4040a0 <syncipc_call+0x2a0>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  40401b:	49 89 c8             	mov    r8,rcx
  40401e:	a8 01                	test   al,0x1
  404020:	0f 84 e9 fe ff ff    	je     403f0f <syncipc_call+0x10f>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  404026:	4d 8b 57 08          	mov    r10,QWORD PTR [r15+0x8]
  40402a:	49 8b 7f 10          	mov    rdi,QWORD PTR [r15+0x10]
  40402e:	48 89 f2             	mov    rdx,rsi
  404031:	45 89 e1             	mov    r9d,r12d
  404034:	4c 8b 05 6d de 19 00 	mov    r8,QWORD PTR [rip+0x19de6d]        # 5a1ea8 <__slm_global+0x28>
  40403b:	4c 89 d6             	mov    rsi,r10
  40403e:	e8 dd d2 00 00       	call   411320 <cos_switch>
  404043:	41 89 c0             	mov    r8d,eax
  404046:	e9 df fe ff ff       	jmp    403f2a <syncipc_call+0x12a>
	return t != &g->idle_thd && t != &g->sched_thd;
  40404b:	49 81 ff 00 1f 5a 00 	cmp    r15,0x5a1f00
  404052:	74 18                	je     40406c <syncipc_call+0x26c>
  404054:	49 81 ff 88 1e 5a 00 	cmp    r15,0x5a1e88
  40405b:	74 0f                	je     40406c <syncipc_call+0x26c>
  40405d:	0f 31                	rdtsc  
	counts[type]++;
  40405f:	48 83 05 61 a0 05 00 	add    QWORD PTR [rip+0x5a061],0x1        # 45e0c8 <counts+0x8>
  404066:	01 
			if (ret != -EAGAIN) return ret;
  404067:	e9 02 ff ff ff       	jmp    403f6e <syncipc_call+0x16e>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  40406c:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]
  404070:	4c 8b 05 31 de 19 00 	mov    r8,QWORD PTR [rip+0x19de31]        # 5a1ea8 <__slm_global+0x28>
  404077:	45 89 e1             	mov    r9d,r12d
  40407a:	31 c9                	xor    ecx,ecx
  40407c:	48 8b 3d 15 de 19 00 	mov    rdi,QWORD PTR [rip+0x19de15]        # 5a1e98 <__slm_global+0x18>
  404083:	31 f6                	xor    esi,esi
  404085:	e8 96 d2 00 00       	call   411320 <cos_switch>
  40408a:	83 f8 f5             	cmp    eax,0xfffffff5
  40408d:	41 89 c0             	mov    r8d,eax
  404090:	40 0f 95 c6          	setne  sil
		if (unlikely(ret)) {
  404094:	85 c0                	test   eax,eax
  404096:	0f 95 c0             	setne  al
			if (ret != -EAGAIN) return ret;
  404099:	21 c6                	and    esi,eax
  40409b:	e9 9a fe ff ff       	jmp    403f3a <syncipc_call+0x13a>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  4040a0:	49 8b 7f 28          	mov    rdi,QWORD PTR [r15+0x28]
  4040a4:	48 8b 15 fd dd 19 00 	mov    rdx,QWORD PTR [rip+0x19ddfd]        # 5a1ea8 <__slm_global+0x28>
  4040ab:	44 89 e1             	mov    ecx,r12d
  4040ae:	4c 89 c6             	mov    rsi,r8
  4040b1:	e8 da d2 00 00       	call   411390 <cos_sched_asnd>
  4040b6:	eb d2                	jmp    40408a <syncipc_call+0x28a>
	if (ep->server == NULL) return -EAGAIN;
  4040b8:	41 b8 f5 ff ff ff    	mov    r8d,0xfffffff5
  4040be:	e9 ab fe ff ff       	jmp    403f6e <syncipc_call+0x16e>
  4040c3:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4040ca:	00 00 00 00 
  4040ce:	66 90                	xchg   ax,ax

00000000004040d0 <syncipc_reply_wait>:
{
  4040d0:	f3 0f 1e fa          	endbr64 
  4040d4:	55                   	push   rbp
  4040d5:	66 48 0f 6e c6       	movq   xmm0,rsi
  4040da:	66 48 0f 6e ca       	movq   xmm1,rdx
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  4040df:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  4040e2:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  4040e8:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  4040ec:	48 89 e5             	mov    rbp,rsp
  4040ef:	41 57                	push   r15
  4040f1:	4d 89 c7             	mov    r15,r8
  4040f4:	41 56                	push   r14
  4040f6:	41 55                	push   r13
  4040f8:	41 54                	push   r12
  4040fa:	53                   	push   rbx
  4040fb:	48 83 ec 18          	sub    rsp,0x18
  4040ff:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
  404106:	48 89 4d c8          	mov    QWORD PTR [rbp-0x38],rcx
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  40410a:	48 85 c0             	test   rax,rax
  40410d:	0f 84 7d 02 00 00    	je     404390 <syncipc_reply_wait+0x2c0>
  404113:	83 e8 01             	sub    eax,0x1
  404116:	83 f8 18             	cmp    eax,0x18
  404119:	0f 87 71 02 00 00    	ja     404390 <syncipc_reply_wait+0x2c0>
  40411f:	48 8b 14 c5 c0 e6 45 	mov    rdx,QWORD PTR [rax*8+0x45e6c0]
  404126:	00 
  404127:	45 31 ed             	xor    r13d,r13d
  40412a:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  404131:	0f 85 b9 01 00 00    	jne    4042f0 <syncipc_reply_wait+0x220>
	if (unlikely(ep->server != t)) {
  404137:	48 8b 05 ca 9f 05 00 	mov    rax,QWORD PTR [rip+0x59fca]        # 45e108 <eps+0x8>
  40413e:	4c 39 e8             	cmp    rax,r13
  404141:	0f 85 d5 01 00 00    	jne    40431c <syncipc_reply_wait+0x24c>
	client             = ps_load(&ep->client);
  404147:	48 8b 1d b2 9f 05 00 	mov    rbx,QWORD PTR [rip+0x59fb2]        # 45e100 <eps>
	ep->retvals->r0    = arg0;
  40414e:	48 8b 05 cb 9f 05 00 	mov    rax,QWORD PTR [rip+0x59fcb]        # 45e120 <eps+0x20>
	counts[type]++;
  404155:	48 83 05 7b 9f 05 00 	add    QWORD PTR [rip+0x59f7b],0x1        # 45e0d8 <counts+0x18>
  40415c:	01 
	return t != &g->idle_thd && t != &g->sched_thd;
  40415d:	48 81 fb 00 1f 5a 00 	cmp    rbx,0x5a1f00
	ep->retvals->ready = 1;
  404164:	c7 00 01 00 00 00    	mov    DWORD PTR [rax],0x1
	ep->retvals->r0    = arg0;
  40416a:	0f 11 40 08          	movups XMMWORD PTR [rax+0x8],xmm0
  40416e:	41 0f 95 c6          	setne  r14b
  404172:	48 81 fb 88 1e 5a 00 	cmp    rbx,0x5a1e88
	ep->retvals       = NULL;
  404179:	48 c7 05 9c 9f 05 00 	mov    QWORD PTR [rip+0x59f9c],0x0        # 45e120 <eps+0x20>
  404180:	00 00 00 00 
  404184:	0f 95 c0             	setne  al
	ep->client        = NULL;
  404187:	48 c7 05 6e 9f 05 00 	mov    QWORD PTR [rip+0x59f6e],0x0        # 45e100 <eps>
  40418e:	00 00 00 00 
  404192:	41 21 c6             	and    r14d,eax
  404195:	0f 31                	rdtsc  
		ret = slm_switch_to(t, client, cos_sched_sync(), 1);
  404197:	e8 64 d1 00 00       	call   411300 <cos_sched_sync>
  40419c:	41 89 c4             	mov    r12d,eax
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  40419f:	8b 43 04             	mov    eax,DWORD PTR [rbx+0x4]
  4041a2:	83 e8 02             	sub    eax,0x2
  4041a5:	83 f8 01             	cmp    eax,0x1
  4041a8:	0f 87 a2 00 00 00    	ja     404250 <syncipc_reply_wait+0x180>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  4041ae:	e8 ad 76 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4041b3:	8b 03                	mov    eax,DWORD PTR [rbx]
	timeout = g->timeout_next;
  4041b5:	4c 8b 05 cc dd 19 00 	mov    r8,QWORD PTR [rip+0x19ddcc]        # 5a1f88 <__slm_global+0x108>
	prio = inherit_prio ? curr->priority : t->priority;
  4041bc:	49 8b 75 30          	mov    rsi,QWORD PTR [r13+0x30]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4041c0:	a8 0b                	test   al,0xb
  4041c2:	0f 85 a8 00 00 00    	jne    404270 <syncipc_reply_wait+0x1a0>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  4041c8:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  4041cc:	4c 89 c2             	mov    rdx,r8
  4041cf:	44 89 e1             	mov    ecx,r12d
  4041d2:	e8 89 85 00 00       	call   40c760 <cos_defswitch>
  4041d7:	41 89 c0             	mov    r8d,eax
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  4041da:	83 f8 ff             	cmp    eax,0xffffffff
  4041dd:	0f 84 d5 00 00 00    	je     4042b8 <syncipc_reply_wait+0x1e8>
  4041e3:	0f 31                	rdtsc  
		if (unlikely(ret) && ret != -EAGAIN) return ret;
  4041e5:	45 85 c0             	test   r8d,r8d
  4041e8:	75 70                	jne    40425a <syncipc_reply_wait+0x18a>
	counts[type]++;
  4041ea:	66 0f 6f 05 3e 7a 01 	movdqa xmm0,XMMWORD PTR [rip+0x17a3e]        # 41bc30 <__unlock+0xc00>
  4041f1:	00 
  4041f2:	66 0f d4 05 e6 9e 05 	paddq  xmm0,XMMWORD PTR [rip+0x59ee6]        # 45e0e0 <counts+0x20>
  4041f9:	00 
  4041fa:	0f 29 05 df 9e 05 00 	movaps XMMWORD PTR [rip+0x59edf],xmm0        # 45e0e0 <counts+0x20>
  404201:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	while (ps_load(&ep->client) == NULL) ;
  404208:	48 8b 05 f1 9e 05 00 	mov    rax,QWORD PTR [rip+0x59ef1]        # 45e100 <eps>
  40420f:	48 85 c0             	test   rax,rax
  404212:	74 f4                	je     404208 <syncipc_reply_wait+0x138>
	*ret0 = ep->a0;
  404214:	48 8b 05 f5 9e 05 00 	mov    rax,QWORD PTR [rip+0x59ef5]        # 45e110 <eps+0x10>
  40421b:	48 8b 7d c8          	mov    rdi,QWORD PTR [rbp-0x38]
  40421f:	48 89 07             	mov    QWORD PTR [rdi],rax
	*ret1 = ep->a1;
  404222:	48 8b 05 ef 9e 05 00 	mov    rax,QWORD PTR [rip+0x59eef]        # 45e118 <eps+0x18>
  404229:	49 89 07             	mov    QWORD PTR [r15],rax
	counts[type]++;
  40422c:	48 83 05 bc 9e 05 00 	add    QWORD PTR [rip+0x59ebc],0x1        # 45e0f0 <counts+0x30>
  404233:	01 
}
  404234:	48 83 c4 18          	add    rsp,0x18
  404238:	44 89 c0             	mov    eax,r8d
  40423b:	5b                   	pop    rbx
  40423c:	41 5c                	pop    r12
  40423e:	41 5d                	pop    r13
  404240:	41 5e                	pop    r14
  404242:	41 5f                	pop    r15
  404244:	5d                   	pop    rbp
  404245:	c3                   	ret    
  404246:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40424d:	00 00 00 
  404250:	0f 31                	rdtsc  
  404252:	41 b8 01 00 00 00    	mov    r8d,0x1
  404258:	eb da                	jmp    404234 <syncipc_reply_wait+0x164>
		if (unlikely(ret) && ret != -EAGAIN) return ret;
  40425a:	41 83 f8 f5          	cmp    r8d,0xfffffff5
  40425e:	75 d4                	jne    404234 <syncipc_reply_wait+0x164>
	counts[type]++;
  404260:	48 83 05 78 9e 05 00 	add    QWORD PTR [rip+0x59e78],0x1        # 45e0e0 <counts+0x20>
  404267:	01 
	} while (ret == -EAGAIN);
  404268:	e9 28 ff ff ff       	jmp    404195 <syncipc_reply_wait+0xc5>
  40426d:	0f 1f 00             	nop    DWORD PTR [rax]
			timeout = TCAP_TIME_NIL;
  404270:	31 c9                	xor    ecx,ecx
  404272:	48 81 fb 88 1e 5a 00 	cmp    rbx,0x5a1e88
  404279:	49 0f 45 c8          	cmovne rcx,r8
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  40427d:	a8 02                	test   al,0x2
  40427f:	0f 85 1b 01 00 00    	jne    4043a0 <syncipc_reply_wait+0x2d0>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  404285:	49 89 c8             	mov    r8,rcx
  404288:	a8 01                	test   al,0x1
  40428a:	0f 84 38 ff ff ff    	je     4041c8 <syncipc_reply_wait+0xf8>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  404290:	4c 8b 53 08          	mov    r10,QWORD PTR [rbx+0x8]
  404294:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  404298:	48 89 f2             	mov    rdx,rsi
  40429b:	45 89 e1             	mov    r9d,r12d
  40429e:	4c 8b 05 03 dc 19 00 	mov    r8,QWORD PTR [rip+0x19dc03]        # 5a1ea8 <__slm_global+0x28>
  4042a5:	4c 89 d6             	mov    rsi,r10
  4042a8:	e8 73 d0 00 00       	call   411320 <cos_switch>
  4042ad:	41 89 c0             	mov    r8d,eax
  4042b0:	e9 2e ff ff ff       	jmp    4041e3 <syncipc_reply_wait+0x113>
  4042b5:	0f 1f 00             	nop    DWORD PTR [rax]
	return t != &g->idle_thd && t != &g->sched_thd;
  4042b8:	45 84 f6             	test   r14b,r14b
  4042bb:	75 2b                	jne    4042e8 <syncipc_reply_wait+0x218>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  4042bd:	4c 8b 05 e4 db 19 00 	mov    r8,QWORD PTR [rip+0x19dbe4]        # 5a1ea8 <__slm_global+0x28>
  4042c4:	49 8b 55 30          	mov    rdx,QWORD PTR [r13+0x30]
  4042c8:	45 89 e1             	mov    r9d,r12d
  4042cb:	31 c9                	xor    ecx,ecx
  4042cd:	48 8b 3d c4 db 19 00 	mov    rdi,QWORD PTR [rip+0x19dbc4]        # 5a1e98 <__slm_global+0x18>
  4042d4:	31 f6                	xor    esi,esi
  4042d6:	e8 45 d0 00 00       	call   411320 <cos_switch>
  4042db:	41 89 c0             	mov    r8d,eax
  4042de:	e9 00 ff ff ff       	jmp    4041e3 <syncipc_reply_wait+0x113>
  4042e3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  4042e8:	0f 31                	rdtsc  
		if (unlikely(ret) && ret != -EAGAIN) return ret;
  4042ea:	e9 45 ff ff ff       	jmp    404234 <syncipc_reply_wait+0x164>
  4042ef:	90                   	nop
  4042f0:	83 e2 01             	and    edx,0x1
  4042f3:	0f 85 3e fe ff ff    	jne    404137 <syncipc_reply_wait+0x67>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  4042f9:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  4042fd:	4c 8d 2c 50          	lea    r13,[rax+rdx*2]
	if (unlikely(ep->server != t)) {
  404301:	48 8b 05 00 9e 05 00 	mov    rax,QWORD PTR [rip+0x59e00]        # 45e108 <eps+0x8>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  404308:	49 c1 e5 04          	shl    r13,0x4
  40430c:	49 81 c5 88 e7 45 00 	add    r13,0x45e788
	if (unlikely(ep->server != t)) {
  404313:	4c 39 e8             	cmp    rax,r13
  404316:	0f 84 2b fe ff ff    	je     404147 <syncipc_reply_wait+0x77>
		if (ep->server != NULL)         return -1;
  40431c:	48 85 c0             	test   rax,rax
  40431f:	0f 85 d1 00 00 00    	jne    4043f6 <syncipc_reply_wait+0x326>
        __asm__ __volatile__("lock " PS_CAS_STR
  404325:	f0 4c 0f b1 2d da 9d 	lock cmpxchg QWORD PTR [rip+0x59dda],r13        # 45e108 <eps+0x8>
  40432c:	05 00 
  40432e:	0f 94 c0             	sete   al
		if (!ps_cas((unsigned long *)&ep->server, 0, (unsigned long)t)) return -1;
  404331:	84 c0                	test   al,al
  404333:	0f 84 bd 00 00 00    	je     4043f6 <syncipc_reply_wait+0x326>
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  404339:	31 d2                	xor    edx,edx
  40433b:	be 0b 00 00 00       	mov    esi,0xb
  404340:	4c 89 ef             	mov    rdi,r13
  404343:	e8 08 e3 00 00       	call   412650 <slm_sched_fprr_thd_update>
  404348:	41 89 c0             	mov    r8d,eax
		assert(ret == 0);
  40434b:	85 c0                	test   eax,eax
  40434d:	75 6f                	jne    4043be <syncipc_reply_wait+0x2ee>
		assert(ep->server == t);
  40434f:	4c 39 2d b2 9d 05 00 	cmp    QWORD PTR [rip+0x59db2],r13        # 45e108 <eps+0x8>
  404356:	0f 85 7e 00 00 00    	jne    4043da <syncipc_reply_wait+0x30a>
  40435c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		while (ps_load(&ep->client) == NULL) ;
  404360:	48 8b 05 99 9d 05 00 	mov    rax,QWORD PTR [rip+0x59d99]        # 45e100 <eps>
  404367:	48 85 c0             	test   rax,rax
  40436a:	74 f4                	je     404360 <syncipc_reply_wait+0x290>
		*ret0 = ep->a0;
  40436c:	48 8b 05 9d 9d 05 00 	mov    rax,QWORD PTR [rip+0x59d9d]        # 45e110 <eps+0x10>
  404373:	48 8b 7d c8          	mov    rdi,QWORD PTR [rbp-0x38]
  404377:	48 89 07             	mov    QWORD PTR [rdi],rax
		*ret1 = ep->a1;
  40437a:	48 8b 05 97 9d 05 00 	mov    rax,QWORD PTR [rip+0x59d97]        # 45e118 <eps+0x18>
  404381:	49 89 07             	mov    QWORD PTR [r15],rax
		return 0;
  404384:	e9 ab fe ff ff       	jmp    404234 <syncipc_reply_wait+0x164>
  404389:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  404390:	45 31 ed             	xor    r13d,r13d
  404393:	e9 9f fd ff ff       	jmp    404137 <syncipc_reply_wait+0x67>
  404398:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40439f:	00 
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  4043a0:	48 8b 7b 28          	mov    rdi,QWORD PTR [rbx+0x28]
  4043a4:	48 8b 15 fd da 19 00 	mov    rdx,QWORD PTR [rip+0x19dafd]        # 5a1ea8 <__slm_global+0x28>
  4043ab:	4c 89 c6             	mov    rsi,r8
  4043ae:	44 89 e1             	mov    ecx,r12d
  4043b1:	e8 da cf 00 00       	call   411390 <cos_sched_asnd>
  4043b6:	41 89 c0             	mov    r8d,eax
  4043b9:	e9 25 fe ff ff       	jmp    4041e3 <syncipc_reply_wait+0x113>
  4043be:	be 24 00 00 00       	mov    esi,0x24
  4043c3:	bf b8 bb 41 00       	mov    edi,0x41bbb8
  4043c8:	e8 03 5d 00 00       	call   40a0d0 <cos_print_str>
		assert(ret == 0);
  4043cd:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4043d4:	00 00 00 00 
  4043d8:	0f 0b                	ud2    
  4043da:	be 24 00 00 00       	mov    esi,0x24
  4043df:	bf e0 bb 41 00       	mov    edi,0x41bbe0
  4043e4:	e8 e7 5c 00 00       	call   40a0d0 <cos_print_str>
		assert(ep->server == t);
  4043e9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4043f0:	00 00 00 00 
  4043f4:	0f 0b                	ud2    
		if (ep->server != NULL)         return -1;
  4043f6:	41 b8 ff ff ff ff    	mov    r8d,0xffffffff
  4043fc:	e9 33 fe ff ff       	jmp    404234 <syncipc_reply_wait+0x164>
  404401:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  404408:	00 00 00 00 
  40440c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000404410 <sched_aep_create_closure>:
{
  404410:	f3 0f 1e fa          	endbr64 
}
  404414:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
  40441b:	c3                   	ret    
  40441c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000404420 <sched_get_cpu_freq>:
{
  404420:	f3 0f 1e fa          	endbr64 
	return slm_get_cycs_per_usec();
  404424:	e9 f7 ff 00 00       	jmp    414420 <slm_get_cycs_per_usec>
  404429:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000404430 <slm_ipithd_create>:
{
  404430:	f3 0f 1e fa          	endbr64 
  404434:	55                   	push   rbp
  404435:	48 89 e5             	mov    rbp,rsp
  404438:	41 57                	push   r15
  40443a:	49 89 f7             	mov    r15,rsi
  40443d:	41 56                	push   r14
  40443f:	49 89 fe             	mov    r14,rdi
	struct slm_ipi_percore   *ipi_data = slm_ipi_percore_get(cos_cpuid());
  404442:	31 ff                	xor    edi,edi
{
  404444:	41 55                	push   r13
  404446:	49 89 cd             	mov    r13,rcx
  404449:	41 54                	push   r12
  40444b:	4d 89 c4             	mov    r12,r8
  40444e:	53                   	push   rbx
  40444f:	48 83 ec 28          	sub    rsp,0x28
  404453:	89 55 bc             	mov    DWORD PTR [rbp-0x44],edx
	struct slm_ipi_percore   *ipi_data = slm_ipi_percore_get(cos_cpuid());
  404456:	e8 55 f2 00 00       	call   4136b0 <slm_ipi_percore_get>
	r->rcv = capmgr_rcv_alloc(fn, data, flags, &r->asnd, &_thd, &_tid);
  40445b:	8b 55 bc             	mov    edx,DWORD PTR [rbp-0x44]
  40445e:	4c 8d 45 c0          	lea    r8,[rbp-0x40]
  404462:	4c 89 fe             	mov    rsi,r15
  404465:	48 8d 48 08          	lea    rcx,[rax+0x8]
  404469:	4c 8d 4d c8          	lea    r9,[rbp-0x38]
  40446d:	4c 89 f7             	mov    rdi,r14
	struct slm_ipi_percore   *ipi_data = slm_ipi_percore_get(cos_cpuid());
  404470:	48 89 c3             	mov    rbx,rax
	r->rcv = capmgr_rcv_alloc(fn, data, flags, &r->asnd, &_thd, &_tid);
  404473:	e8 a8 59 00 00       	call   409e20 <capmgr_rcv_alloc>
	r->tid = _tid;
  404478:	48 8b 75 c8          	mov    rsi,QWORD PTR [rbp-0x38]
	t = slm_thd_mem_alloc(_thd, _tid, thdcap, tid);
  40447c:	4c 8b 45 c0          	mov    r8,QWORD PTR [rbp-0x40]
	r->cpuid = cos_cpuid();
  404480:	c7 43 10 00 00 00 00 	mov    DWORD PTR [rbx+0x10],0x0
	r->rcv = capmgr_rcv_alloc(fn, data, flags, &r->asnd, &_thd, &_tid);
  404487:	48 89 03             	mov    QWORD PTR [rbx],rax
	r->tid = _tid;
  40448a:	66 49 0f 6e c0       	movq   xmm0,r8
  40448f:	66 48 0f 6e ce       	movq   xmm1,rsi
  404494:	48 89 73 18          	mov    QWORD PTR [rbx+0x18],rsi
	t = slm_thd_mem_alloc(_thd, _tid, thdcap, tid);
  404498:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  40449c:	85 f6                	test   esi,esi
  40449e:	0f 84 8c 01 00 00    	je     404630 <slm_ipithd_create+0x200>
  4044a4:	8d 56 ff             	lea    edx,[rsi-0x1]
  4044a7:	83 fa 18             	cmp    edx,0x18
  4044aa:	0f 87 80 01 00 00    	ja     404630 <slm_ipithd_create+0x200>
	if (*state != SS_STATE_FREE ||
  4044b0:	48 83 3c d5 c0 e6 45 	cmp    QWORD PTR [rdx*8+0x45e6c0],0x0
  4044b7:	00 00 
  4044b9:	0f 85 71 01 00 00    	jne    404630 <slm_ipithd_create+0x200>
  4044bf:	45 31 c9             	xor    r9d,r9d
  4044c2:	b9 01 00 00 00       	mov    ecx,0x1
  4044c7:	4c 89 c8             	mov    rax,r9
  4044ca:	f0 48 0f b1 0c d5 c0 	lock cmpxchg QWORD PTR [rdx*8+0x45e6c0],rcx
  4044d1:	e6 45 00 
  4044d4:	0f 94 c0             	sete   al
  4044d7:	84 c0                	test   al,al
  4044d9:	0f 84 51 01 00 00    	je     404630 <slm_ipithd_create+0x200>
  4044df:	48 8d 04 92          	lea    rax,[rdx+rdx*4]
  4044e3:	b9 16 00 00 00       	mov    ecx,0x16
  4044e8:	48 8d 14 42          	lea    rdx,[rdx+rax*2]
  4044ec:	4c 89 c8             	mov    rax,r9
  4044ef:	48 c1 e2 04          	shl    rdx,0x4
  4044f3:	4c 8d b2 88 e7 45 00 	lea    r14,[rdx+0x45e788]
  4044fa:	4c 89 f7             	mov    rdi,r14
  4044fd:	f3 48 ab             	rep stos QWORD PTR es:[rdi],rax
	assert(_cap != 0 && _tid != 0);
  404500:	4d 85 c0             	test   r8,r8
  404503:	0f 84 64 01 00 00    	je     40466d <slm_ipithd_create+0x23d>
	t->resources = (struct slm_resources_thd) {
  404509:	48 8b 05 30 2b 02 00 	mov    rax,QWORD PTR [rip+0x22b30]        # 427040 <__cosrt_comp_info+0x40>
  404510:	0f 29 82 20 e8 45 00 	movaps XMMWORD PTR [rdx+0x45e820],xmm0
  404517:	bb 88 1e 5a 00       	mov    ebx,0x5a1e88
  40451c:	48 89 82 30 e8 45 00 	mov    QWORD PTR [rdx+0x45e830],rax
	*thd = _cap;
  404523:	4d 89 45 00          	mov    QWORD PTR [r13+0x0],r8
	*tid = _tid;
  404527:	49 89 34 24          	mov    QWORD PTR [r12],rsi
		tok    = cos_sched_sync();
  40452b:	e8 d0 cd 00 00       	call   411300 <cos_sched_sync>
  404530:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  404533:	48 8b 05 46 d9 19 00 	mov    rax,QWORD PTR [rip+0x19d946]        # 5a1e80 <__slm_global>
		if (unlikely(owner)) {
  40453a:	48 89 c1             	mov    rcx,rax
  40453d:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  404541:	0f 85 42 01 00 00    	jne    404689 <slm_ipithd_create+0x259>
  404547:	f0 48 0f b1 1d 30 d9 	lock cmpxchg QWORD PTR [rip+0x19d930],rbx        # 5a1e80 <__slm_global>
  40454e:	19 00 
  404550:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  404553:	84 c0                	test   al,al
  404555:	74 d4                	je     40452b <slm_ipithd_create+0xfb>
	if (slm_thd_init(thd, _thd, _tid)) ERR_THROW(NULL, free);
  404557:	48 8b 55 c8          	mov    rdx,QWORD PTR [rbp-0x38]
  40455b:	48 8b 75 c0          	mov    rsi,QWORD PTR [rbp-0x40]
  40455f:	4c 89 f7             	mov    rdi,r14
  404562:	e8 a9 f1 00 00       	call   413710 <slm_thd_init>
  404567:	85 c0                	test   eax,eax
  404569:	0f 85 dd 00 00 00    	jne    40464c <slm_ipithd_create+0x21c>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  40456f:	49 81 fe 88 e7 45 00 	cmp    r14,0x45e788
  404576:	0f 82 d5 00 00 00    	jb     404651 <slm_ipithd_create+0x221>
  40457c:	49 81 fe 08 f8 45 00 	cmp    r14,0x45f808
  404583:	0f 87 c8 00 00 00    	ja     404651 <slm_ipithd_create+0x221>
  404589:	4c 89 f0             	mov    rax,r14
  40458c:	48 2d 88 e7 45 00    	sub    rax,0x45e788
  404592:	48 c1 f8 04          	sar    rax,0x4
	*state = val | (*state & 1);
  404596:	69 c0 a3 8b 2e ba    	imul   eax,eax,0xba2e8ba3
  40459c:	48 8b 14 c5 c0 e6 45 	mov    rdx,QWORD PTR [rax*8+0x45e6c0]
  4045a3:	00 
  4045a4:	48 83 ca fe          	or     rdx,0xfffffffffffffffe
  4045a8:	48 89 14 c5 c0 e6 45 	mov    QWORD PTR [rax*8+0x45e6c0],rdx
  4045af:	00 
	assert((*state & 1) == SS_STATE_CONS);
  4045b0:	48 83 fa ff          	cmp    rdx,0xffffffffffffffff
  4045b4:	0f 85 29 01 00 00    	jne    4046e3 <slm_ipithd_create+0x2b3>
	*state &= ~SS_STATE_CONS;
  4045ba:	48 c7 04 c5 c0 e6 45 	mov    QWORD PTR [rax*8+0x45e6c0],0xfffffffffffffffe
  4045c1:	00 fe ff ff ff 
{ __asm__ __volatile__("mfence" ::: "memory"); }
  4045c6:	0f ae f0             	mfence 
	assert(*state != 0);
  4045c9:	48 83 3c c5 c0 e6 45 	cmp    QWORD PTR [rax*8+0x45e6c0],0x0
  4045d0:	00 00 
  4045d2:	75 1c                	jne    4045f0 <slm_ipithd_create+0x1c0>
  4045d4:	e9 ee 00 00 00       	jmp    4046c7 <slm_ipithd_create+0x297>
  4045d9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  4045e0:	f0 48 0f b1 15 97 d8 	lock cmpxchg QWORD PTR [rip+0x19d897],rdx        # 5a1e80 <__slm_global>
  4045e7:	19 00 
  4045e9:	0f 94 c0             	sete   al
	while (ret != 0) {
  4045ec:	84 c0                	test   al,al
  4045ee:	75 2e                	jne    40461e <slm_ipithd_create+0x1ee>
		tok    = cos_sched_sync();
  4045f0:	e8 0b cd 00 00       	call   411300 <cos_sched_sync>
  4045f5:	89 c1                	mov    ecx,eax
  4045f7:	48 8b 05 82 d8 19 00 	mov    rax,QWORD PTR [rip+0x19d882]        # 5a1e80 <__slm_global>
		if (unlikely(contention)) {
  4045fe:	48 89 c2             	mov    rdx,rax
  404601:	83 e2 01             	and    edx,0x1
  404604:	74 da                	je     4045e0 <slm_ipithd_create+0x1b0>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  404606:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  404609:	48 89 c2             	mov    rdx,rax
  40460c:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  404611:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  404615:	e8 46 f2 00 00       	call   413860 <slm_cs_exit_contention>
  40461a:	85 c0                	test   eax,eax
  40461c:	75 d2                	jne    4045f0 <slm_ipithd_create+0x1c0>
}
  40461e:	48 83 c4 28          	add    rsp,0x28
  404622:	4c 89 f0             	mov    rax,r14
  404625:	5b                   	pop    rbx
  404626:	41 5c                	pop    r12
  404628:	41 5d                	pop    r13
  40462a:	41 5e                	pop    r14
  40462c:	41 5f                	pop    r15
  40462e:	5d                   	pop    rbp
  40462f:	c3                   	ret    
  404630:	be 23 00 00 00       	mov    esi,0x23
  404635:	bf 10 ba 41 00       	mov    edi,0x41ba10
  40463a:	e8 91 5a 00 00       	call   40a0d0 <cos_print_str>
	if (!t) assert(0);
  40463f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404646:	00 00 00 00 
  40464a:	0f 0b                	ud2    
	ret = NULL;
  40464c:	45 31 f6             	xor    r14d,r14d
	return ret;
  40464f:	eb cd                	jmp    40461e <slm_ipithd_create+0x1ee>
  404651:	be 23 00 00 00       	mov    esi,0x23
  404656:	bf e8 b9 41 00       	mov    edi,0x41b9e8
  40465b:	e8 70 5a 00 00       	call   40a0d0 <cos_print_str>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  404660:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404667:	00 00 00 00 
  40466b:	0f 0b                	ud2    
  40466d:	be 23 00 00 00       	mov    esi,0x23
  404672:	bf 38 ba 41 00       	mov    edi,0x41ba38
  404677:	e8 54 5a 00 00       	call   40a0d0 <cos_print_str>
	assert(_cap != 0 && _tid != 0);
  40467c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404683:	00 00 00 00 
  404687:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  404689:	41 89 c0             	mov    r8d,eax
  40468c:	ba 88 1e 5a 00       	mov    edx,0x5a1e88
  404691:	48 89 c6             	mov    rsi,rax
  404694:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  404699:	41 83 e0 01          	and    r8d,0x1
  40469d:	e8 6e f1 00 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  4046a2:	83 f8 f0             	cmp    eax,0xfffffff0
  4046a5:	0f 85 80 fe ff ff    	jne    40452b <slm_ipithd_create+0xfb>
  4046ab:	be 59 00 00 00       	mov    esi,0x59
  4046b0:	bf a0 b6 41 00       	mov    edi,0x41b6a0
  4046b5:	e8 16 5a 00 00       	call   40a0d0 <cos_print_str>
  4046ba:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4046c1:	00 00 00 00 
  4046c5:	0f 0b                	ud2    
  4046c7:	be 61 00 00 00       	mov    esi,0x61
  4046cc:	bf c8 ba 41 00       	mov    edi,0x41bac8
  4046d1:	e8 fa 59 00 00       	call   40a0d0 <cos_print_str>
  4046d6:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4046dd:	00 00 00 00 
  4046e1:	0f 0b                	ud2    
  4046e3:	be 61 00 00 00       	mov    esi,0x61
  4046e8:	bf 60 ba 41 00       	mov    edi,0x41ba60
  4046ed:	e8 de 59 00 00       	call   40a0d0 <cos_print_str>
	assert((*state & 1) == SS_STATE_CONS);
  4046f2:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4046f9:	00 00 00 00 
  4046fd:	0f 0b                	ud2    
  4046ff:	90                   	nop

0000000000404700 <parallel_main>:

static coreid_t _init_core_id = 0;

void
parallel_main(coreid_t cid)
{
  404700:	f3 0f 1e fa          	endbr64 
	if (cid == _init_core_id) printc("Starting scheduler loop...\n");
  404704:	66 39 3d 9d 9f 05 00 	cmp    WORD PTR [rip+0x59f9d],di        # 45e6a8 <_init_core_id>
  40470b:	74 0b                	je     404718 <parallel_main+0x18>
	slm_sched_loop_nonblock();
  40470d:	e9 2e fd 00 00       	jmp    414440 <slm_sched_loop_nonblock>
  404712:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
{
  404718:	55                   	push   rbp
	if (cid == _init_core_id) printc("Starting scheduler loop...\n");
  404719:	bf 20 b6 41 00       	mov    edi,0x41b620
  40471e:	31 c0                	xor    eax,eax
{
  404720:	48 89 e5             	mov    rbp,rsp
	if (cid == _init_core_id) printc("Starting scheduler loop...\n");
  404723:	e8 38 c2 ff ff       	call   400960 <printc.constprop.0>
}
  404728:	5d                   	pop    rbp
	slm_sched_loop_nonblock();
  404729:	e9 12 fd 00 00       	jmp    414440 <slm_sched_loop_nonblock>
  40472e:	66 90                	xchg   ax,ax

0000000000404730 <cos_parallel_init>:

void
cos_parallel_init(coreid_t cid, int init_core, int ncores)
{
  404730:	f3 0f 1e fa          	endbr64 
  404734:	55                   	push   rbp
  404735:	48 89 e5             	mov    rbp,rsp
  404738:	53                   	push   rbx
  404739:	48 83 ec 28          	sub    rsp,0x28
	struct slm_thd_container *t;
	struct slm_thd *r;
	thdcap_t thdcap, ipithdcap;
	arcvcap_t rcvcap;
	thdid_t tid, ipitid;
	if (init_core) {
  40473d:	85 f6                	test   esi,esi
  40473f:	74 07                	je     404748 <cos_parallel_init+0x18>
		_init_core_id = cid;
  404741:	66 89 3d 60 9f 05 00 	mov    WORD PTR [rip+0x59f60],di        # 45e6a8 <_init_core_id>
	} 
	struct slm_ipi_percore *ipi_data = slm_ipi_percore_get(cos_cpuid());
  404748:	31 ff                	xor    edi,edi
  40474a:	e8 61 ef 00 00       	call   4136b0 <slm_ipi_percore_get>
  40474f:	48 89 c3             	mov    rbx,rax

	cos_defcompinfo_sched_init();
  404752:	e8 89 73 00 00       	call   40bae0 <cos_defcompinfo_sched_init>

	t = slm_thd_alloc(slm_idle, NULL, &thdcap, &tid);
  404757:	31 f6                	xor    esi,esi
  404759:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  40475d:	48 8d 55 d0          	lea    rdx,[rbp-0x30]
  404761:	bf 50 2a 41 00       	mov    edi,0x412a50
  404766:	e8 35 01 00 00       	call   4048a0 <slm_thd_alloc>
	if (!t) BUG();
  40476b:	48 85 c0             	test   rax,rax
  40476e:	0f 84 bc 00 00 00    	je     404830 <cos_parallel_init+0x100>

	slm_init(thdcap, tid);
  404774:	48 8b 75 e0          	mov    rsi,QWORD PTR [rbp-0x20]
  404778:	48 8b 7d d0          	mov    rdi,QWORD PTR [rbp-0x30]
  40477c:	e8 df fc 00 00       	call   414460 <slm_init>

	r = slm_ipithd_create(slm_ipi_process, NULL, 0, &ipithdcap, &ipitid);
  404781:	31 d2                	xor    edx,edx
  404783:	31 f6                	xor    esi,esi
  404785:	4c 8d 45 e8          	lea    r8,[rbp-0x18]
  404789:	48 8d 4d d8          	lea    rcx,[rbp-0x28]
  40478d:	bf 10 0a 40 00       	mov    edi,0x400a10
  404792:	e8 99 fc ff ff       	call   404430 <slm_ipithd_create>
	if (!r) BUG();
  404797:	48 85 c0             	test   rax,rax
  40479a:	74 74                	je     404810 <cos_parallel_init+0xe0>
	return &ss_thd_get(id)->thd;
  40479c:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  4047a0:	85 c0                	test   eax,eax
  4047a2:	74 40                	je     4047e4 <cos_parallel_init+0xb4>
  4047a4:	83 e8 01             	sub    eax,0x1
  4047a7:	83 f8 18             	cmp    eax,0x18
  4047aa:	77 38                	ja     4047e4 <cos_parallel_init+0xb4>
  4047ac:	48 8b 14 c5 c0 e6 45 	mov    rdx,QWORD PTR [rax*8+0x45e6c0]
  4047b3:	00 
	return ((state & ~1) != 0) && ((state & 1) == SS_STATE_ALLOC);
  4047b4:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  4047bb:	74 27                	je     4047e4 <cos_parallel_init+0xb4>
  4047bd:	83 e2 01             	and    edx,0x1
  4047c0:	75 22                	jne    4047e4 <cos_parallel_init+0xb4>
	return &ss_thd_get(id)->thd;
  4047c2:	48 8d 14 80          	lea    rdx,[rax+rax*4]
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  4047c6:	be 01 00 00 00       	mov    esi,0x1
	return &ss_thd_get(id)->thd;
  4047cb:	48 8d 3c 50          	lea    rdi,[rax+rdx*2]
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  4047cf:	ba 14 00 00 00       	mov    edx,0x14
	return &ss_thd_get(id)->thd;
  4047d4:	48 c1 e7 04          	shl    rdi,0x4
  4047d8:	48 81 c7 88 e7 45 00 	add    rdi,0x45e788
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  4047df:	e8 6c de 00 00       	call   412650 <slm_sched_fprr_thd_update>

CK_CC_INLINE static void
ck_ring_init(struct ck_ring *ring, unsigned int size)
{

	ring->size = size;
  4047e4:	48 8b 05 55 74 01 00 	mov    rax,QWORD PTR [rip+0x17455]        # 41bc40 <__unlock+0xc10>
	ring->mask = size - 1;
	ring->p_tail = 0;
  4047eb:	48 c7 43 60 00 00 00 	mov    QWORD PTR [rbx+0x60],0x0
  4047f2:	00 
	ring->p_head = 0;
	ring->c_head = 0;
  4047f3:	c7 43 20 00 00 00 00 	mov    DWORD PTR [rbx+0x20],0x0
	ring->size = size;
  4047fa:	48 89 83 a0 00 00 00 	mov    QWORD PTR [rbx+0xa0],rax
	sched_thd_param_set(ipitid, sched_param_pack(SCHEDP_PRIO, SLM_IPI_THD_PRIO));
	ck_ring_init(&ipi_data->ring, PAGE_SIZE / sizeof(struct slm_ipi_event));
}
  404801:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
  404805:	c9                   	leave  
  404806:	c3                   	ret    
  404807:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40480e:	00 00 
  404810:	be 11 00 00 00       	mov    esi,0x11
  404815:	bf 17 bc 41 00       	mov    edi,0x41bc17
  40481a:	e8 b1 58 00 00       	call   40a0d0 <cos_print_str>
	if (!r) BUG();
  40481f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404826:	00 00 00 00 
  40482a:	0f 0b                	ud2    
  40482c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  404830:	be 11 00 00 00       	mov    esi,0x11
  404835:	bf 05 bc 41 00       	mov    edi,0x41bc05
  40483a:	e8 91 58 00 00       	call   40a0d0 <cos_print_str>
	if (!t) BUG();
  40483f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404846:	00 00 00 00 
  40484a:	0f 0b                	ud2    
  40484c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000404850 <cos_init>:

void
cos_init(void)
{
  404850:	f3 0f 1e fa          	endbr64 
  404854:	55                   	push   rbp
  404855:	48 89 e5             	mov    rbp,rsp
	struct cos_compinfo *boot_info = cos_compinfo_get(cos_defcompinfo_curr_get());
  404858:	e8 03 70 00 00       	call   40b860 <cos_defcompinfo_curr_get>
  40485d:	48 89 c7             	mov    rdi,rax
  404860:	e8 0b 70 00 00       	call   40b870 <cos_compinfo_get>

	cos_meminfo_init(&(boot_info->mi), BOOT_MEM_KM_BASE, COS_MEM_KERN_PA_SZ, BOOT_CAPTBL_SELF_UNTYPED_PT);
  404865:	b9 14 00 00 00       	mov    ecx,0x14
  40486a:	48 ba 00 00 00 fc 01 	movabs rdx,0x1fc000000
  404871:	00 00 00 
  404874:	48 be 00 00 00 00 80 	movabs rsi,0x8000000000
  40487b:	00 00 00 
  40487e:	48 8d 78 68          	lea    rdi,[rax+0x68]
  404882:	e8 69 8e 00 00       	call   40d6f0 <cos_meminfo_init>
	extern void calculate_initialization_schedule(void);
	calculate_initialization_schedule();
  404887:	e8 94 b9 ff ff       	call   400220 <calculate_initialization_schedule>
	cos_defcompinfo_init();
}
  40488c:	5d                   	pop    rbp
	cos_defcompinfo_init();
  40488d:	e9 4e 70 00 00       	jmp    40b8e0 <cos_defcompinfo_init>
  404892:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  404899:	00 00 00 
  40489c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

00000000004048a0 <slm_thd_alloc>:
#include <slm_modules.h>
#include <capmgr.h>

struct slm_thd_container *
slm_thd_alloc(thd_fn_t fn, void *data, thdcap_t *thd, thdid_t *tid)
{
  4048a0:	f3 0f 1e fa          	endbr64 
  4048a4:	55                   	push   rbp
  4048a5:	48 89 e5             	mov    rbp,rsp
  4048a8:	41 55                	push   r13
  4048aa:	49 89 cd             	mov    r13,rcx
  4048ad:	41 54                	push   r12
  4048af:	49 89 d4             	mov    r12,rdx
	thdid_t _tid;
	thdcap_t _cap;
	struct slm_thd_container *ret = NULL;

	_cap = capmgr_thd_create(fn, data, &_tid);
  4048b2:	48 8d 55 e8          	lea    rdx,[rbp-0x18]
{
  4048b6:	48 83 ec 10          	sub    rsp,0x10
	_cap = capmgr_thd_create(fn, data, &_tid);
  4048ba:	e8 b1 54 00 00       	call   409d70 <capmgr_thd_create>
  4048bf:	48 89 c7             	mov    rdi,rax
	if (_cap <= 0) return NULL;
  4048c2:	31 c0                	xor    eax,eax
  4048c4:	48 85 ff             	test   rdi,rdi
  4048c7:	74 0f                	je     4048d8 <slm_thd_alloc+0x38>

	return slm_thd_mem_alloc(_cap, _tid, thd, tid);
  4048c9:	48 8b 75 e8          	mov    rsi,QWORD PTR [rbp-0x18]
  4048cd:	4c 89 e9             	mov    rcx,r13
  4048d0:	4c 89 e2             	mov    rdx,r12
  4048d3:	e8 d8 d0 ff ff       	call   4019b0 <slm_thd_mem_alloc>
}
  4048d8:	48 83 c4 10          	add    rsp,0x10
  4048dc:	41 5c                	pop    r12
  4048de:	41 5d                	pop    r13
  4048e0:	5d                   	pop    rbp
  4048e1:	c3                   	ret    
  4048e2:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4048e9:	00 00 00 00 
  4048ed:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004048f0 <slm_thd_alloc_in>:

struct slm_thd_container *
slm_thd_alloc_in(compid_t cid, thdclosure_index_t idx, thdcap_t *thd, thdid_t *tid)
{
  4048f0:	f3 0f 1e fa          	endbr64 
  4048f4:	55                   	push   rbp
	struct slm_thd_container *ret = NULL;
	thdid_t _tid;
	thdcap_t _cap;

	_cap = capmgr_thd_create_ext(cid, idx, &_tid);
  4048f5:	0f b7 ff             	movzx  edi,di
{
  4048f8:	48 89 e5             	mov    rbp,rsp
  4048fb:	41 55                	push   r13
  4048fd:	49 89 cd             	mov    r13,rcx
  404900:	41 54                	push   r12
  404902:	49 89 d4             	mov    r12,rdx
	_cap = capmgr_thd_create_ext(cid, idx, &_tid);
  404905:	48 8d 55 e8          	lea    rdx,[rbp-0x18]
{
  404909:	48 83 ec 10          	sub    rsp,0x10
	_cap = capmgr_thd_create_ext(cid, idx, &_tid);
  40490d:	e8 5e 22 00 00       	call   406b70 <__cosrt_extern_capmgr_thd_create_ext>
  404912:	48 89 c7             	mov    rdi,rax
	if (_cap <= 0) return NULL;
  404915:	31 c0                	xor    eax,eax
  404917:	48 85 ff             	test   rdi,rdi
  40491a:	74 0f                	je     40492b <slm_thd_alloc_in+0x3b>

	return slm_thd_mem_alloc(_cap, _tid, thd, tid);
  40491c:	48 8b 75 e8          	mov    rsi,QWORD PTR [rbp-0x18]
  404920:	4c 89 e9             	mov    rcx,r13
  404923:	4c 89 e2             	mov    rdx,r12
  404926:	e8 85 d0 ff ff       	call   4019b0 <slm_thd_mem_alloc>
}
  40492b:	48 83 c4 10          	add    rsp,0x10
  40492f:	41 5c                	pop    r12
  404931:	41 5d                	pop    r13
  404933:	5d                   	pop    rbp
  404934:	c3                   	ret    
  404935:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40493c:	00 00 00 00 

0000000000404940 <thd_alloc>:
extern struct slm_thd *slm_thd_current_extern(void);
extern struct slm_thd *slm_thd_from_container(struct slm_thd_container *c);

struct slm_thd *
thd_alloc(thd_fn_t fn, void *data, sched_param_t *parameters, int reschedule)
{
  404940:	f3 0f 1e fa          	endbr64 
  404944:	55                   	push   rbp
  404945:	48 89 e5             	mov    rbp,rsp
  404948:	41 57                	push   r15
  40494a:	41 89 cf             	mov    r15d,ecx
  40494d:	41 56                	push   r14
  40494f:	49 89 d6             	mov    r14,rdx
  404952:	41 55                	push   r13
  404954:	49 89 f5             	mov    r13,rsi
  404957:	41 54                	push   r12
  404959:	49 89 fc             	mov    r12,rdi
  40495c:	53                   	push   rbx
  40495d:	48 83 ec 28          	sub    rsp,0x28
	struct slm_thd_container *t;
	struct slm_thd *thd;
	struct slm_thd *ret     = NULL;
	struct slm_thd *current = slm_thd_current_extern();
  404961:	e8 da cf ff ff       	call   401940 <slm_thd_current_extern>

	/*
	 * If this condition is true, we are likely in the
	 * initialization sequence in the idle or scheduler threads...
	 */
	if (!current) {
  404966:	48 89 c3             	mov    rbx,rax
  404969:	48 85 c0             	test   rax,rax
  40496c:	0f 84 3e 02 00 00    	je     404bb0 <thd_alloc+0x270>
	_cap = capmgr_thd_create(fn, data, &_tid);
  404972:	4c 89 e7             	mov    rdi,r12
  404975:	48 8d 55 c8          	lea    rdx,[rbp-0x38]
  404979:	4c 89 ee             	mov    rsi,r13
  40497c:	e8 ef 53 00 00       	call   409d70 <capmgr_thd_create>
  404981:	48 89 c7             	mov    rdi,rax
	if (_cap <= 0) return NULL;
  404984:	48 85 c0             	test   rax,rax
  404987:	0f 84 a2 00 00 00    	je     404a2f <thd_alloc+0xef>
	return slm_thd_mem_alloc(_cap, _tid, thd, tid);
  40498d:	48 8b 75 c8          	mov    rsi,QWORD PTR [rbp-0x38]
  404991:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  404995:	48 8d 55 b8          	lea    rdx,[rbp-0x48]
  404999:	e8 12 d0 ff ff       	call   4019b0 <slm_thd_mem_alloc>
  40499e:	49 89 c5             	mov    r13,rax
		current = slm_thd_special();
		assert(current);
	}

	t = slm_thd_alloc(fn, data, &thdcap, &tid);
	if (!t) ERR_THROW(NULL, done);
  4049a1:	48 85 c0             	test   rax,rax
  4049a4:	0f 84 85 00 00 00    	je     404a2f <thd_alloc+0xef>
	thd = slm_thd_from_container(t);
  4049aa:	48 89 c7             	mov    rdi,rax
  4049ad:	e8 ee cf ff ff       	call   4019a0 <slm_thd_from_container>
  4049b2:	49 89 c4             	mov    r12,rax
		tok    = cos_sched_sync();
  4049b5:	e8 46 c9 00 00       	call   411300 <cos_sched_sync>
  4049ba:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4049bd:	48 8b 05 bc d4 19 00 	mov    rax,QWORD PTR [rip+0x19d4bc]        # 5a1e80 <__slm_global>
		if (unlikely(owner)) {
  4049c4:	48 89 c1             	mov    rcx,rax
  4049c7:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  4049cb:	0f 85 0f 02 00 00    	jne    404be0 <thd_alloc+0x2a0>
  4049d1:	f0 48 0f b1 1d a6 d4 	lock cmpxchg QWORD PTR [rip+0x19d4a6],rbx        # 5a1e80 <__slm_global>
  4049d8:	19 00 
  4049da:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4049dd:	84 c0                	test   al,al
  4049df:	74 d4                	je     4049b5 <thd_alloc+0x75>

	slm_cs_enter(current, SLM_CS_NONE);
	if (slm_thd_init(thd, thdcap, tid)) ERR_THROW(NULL, free);
  4049e1:	48 8b 55 c0          	mov    rdx,QWORD PTR [rbp-0x40]
  4049e5:	48 8b 75 b8          	mov    rsi,QWORD PTR [rbp-0x48]
  4049e9:	4c 89 e7             	mov    rdi,r12
  4049ec:	e8 1f ed 00 00       	call   413710 <slm_thd_init>
  4049f1:	85 c0                	test   eax,eax
  4049f3:	75 32                	jne    404a27 <thd_alloc+0xe7>

	for (i = 0; parameters[i] != 0; i++) {
  4049f5:	41 8b 36             	mov    esi,DWORD PTR [r14]
  4049f8:	49 83 c6 04          	add    r14,0x4
  4049fc:	85 f6                	test   esi,esi
  4049fe:	75 13                	jne    404a13 <thd_alloc+0xd3>
  404a00:	eb 46                	jmp    404a48 <thd_alloc+0x108>
  404a02:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  404a08:	41 8b 36             	mov    esi,DWORD PTR [r14]
  404a0b:	49 83 c6 04          	add    r14,0x4
  404a0f:	85 f6                	test   esi,esi
  404a11:	74 35                	je     404a48 <thd_alloc+0x108>
  404a13:	89 f2                	mov    edx,esi
		sched_param_type_t type;
		unsigned int value;

		sched_param_get(parameters[i], &type, &value);
		if (slm_sched_thd_update(thd, type, value)) ERR_THROW(NULL, free);
  404a15:	4c 89 e7             	mov    rdi,r12
	if (type)  *type  = (sched_param_type_t)(sp &  SCHED_PARAM_TYPE_MASK);
  404a18:	83 e6 3f             	and    esi,0x3f
	if (value) *value = (unsigned int)      (sp >> SCHED_PARAM_TYPE_BITS);
  404a1b:	c1 ea 06             	shr    edx,0x6
  404a1e:	e8 3d cd ff ff       	call   401760 <slm_sched_thd_update>
  404a23:	85 c0                	test   eax,eax
  404a25:	74 e1                	je     404a08 <thd_alloc+0xc8>

	ret = thd;
done:
	return ret;
free:
	slm_thd_mem_free(t);
  404a27:	4c 89 ef             	mov    rdi,r13
  404a2a:	e8 21 d1 ff ff       	call   401b50 <slm_thd_mem_free>
	ret = NULL;
  404a2f:	45 31 e4             	xor    r12d,r12d
	goto done;
}
  404a32:	48 83 c4 28          	add    rsp,0x28
  404a36:	4c 89 e0             	mov    rax,r12
  404a39:	5b                   	pop    rbx
  404a3a:	41 5c                	pop    r12
  404a3c:	41 5d                	pop    r13
  404a3e:	41 5e                	pop    r14
  404a40:	41 5f                	pop    r15
  404a42:	5d                   	pop    rbp
  404a43:	c3                   	ret    
  404a44:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	slm_thd_mem_activate(t);
  404a48:	4c 89 ef             	mov    rdi,r13
  404a4b:	e8 40 d0 ff ff       	call   401a90 <slm_thd_mem_activate>
	if (reschedule) {
  404a50:	45 85 ff             	test   r15d,r15d
  404a53:	0f 84 1b 01 00 00    	je     404b74 <thd_alloc+0x234>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  404a59:	e8 02 6e 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	tok  = cos_sched_sync();
  404a5e:	e8 9d c8 00 00       	call   411300 <cos_sched_sync>
  404a63:	41 89 c7             	mov    r15d,eax
	t = slm_sched_schedule();
  404a66:	e8 35 cd ff ff       	call   4017a0 <slm_sched_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  404a6b:	48 85 c0             	test   rax,rax
	t = slm_sched_schedule();
  404a6e:	49 89 c6             	mov    r14,rax
	if (unlikely(!t)) t = &g->idle_thd;
  404a71:	b8 00 1f 5a 00       	mov    eax,0x5a1f00
  404a76:	4c 0f 44 f0          	cmove  r14,rax
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  404a7a:	41 8b 46 04          	mov    eax,DWORD PTR [r14+0x4]
  404a7e:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  404a81:	83 f8 01             	cmp    eax,0x1
  404a84:	76 1a                	jbe    404aa0 <thd_alloc+0x160>
  404a86:	e9 91 01 00 00       	jmp    404c1c <thd_alloc+0x2dc>
  404a8b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  404a90:	f0 48 0f b1 15 e7 d3 	lock cmpxchg QWORD PTR [rip+0x19d3e7],rdx        # 5a1e80 <__slm_global>
  404a97:	19 00 
  404a99:	0f 94 c0             	sete   al
	while (ret != 0) {
  404a9c:	84 c0                	test   al,al
  404a9e:	75 2e                	jne    404ace <thd_alloc+0x18e>
		tok    = cos_sched_sync();
  404aa0:	e8 5b c8 00 00       	call   411300 <cos_sched_sync>
  404aa5:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  404aa7:	48 8b 05 d2 d3 19 00 	mov    rax,QWORD PTR [rip+0x19d3d2]        # 5a1e80 <__slm_global>
		if (unlikely(contention)) {
  404aae:	48 89 c2             	mov    rdx,rax
  404ab1:	83 e2 01             	and    edx,0x1
  404ab4:	74 da                	je     404a90 <thd_alloc+0x150>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  404ab6:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  404ab9:	48 89 c2             	mov    rdx,rax
  404abc:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  404ac1:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  404ac5:	e8 96 ed 00 00       	call   413860 <slm_cs_exit_contention>
  404aca:	85 c0                	test   eax,eax
  404acc:	75 d2                	jne    404aa0 <thd_alloc+0x160>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  404ace:	e8 8d 6d 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  404ad3:	41 8b 06             	mov    eax,DWORD PTR [r14]
	timeout = g->timeout_next;
  404ad6:	4c 8b 05 ab d4 19 00 	mov    r8,QWORD PTR [rip+0x19d4ab]        # 5a1f88 <__slm_global+0x108>
	prio = inherit_prio ? curr->priority : t->priority;
  404add:	49 8b 76 30          	mov    rsi,QWORD PTR [r14+0x30]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  404ae1:	a8 0b                	test   al,0xb
  404ae3:	0f 85 4f 01 00 00    	jne    404c38 <thd_alloc+0x2f8>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  404ae9:	49 8b 7e 10          	mov    rdi,QWORD PTR [r14+0x10]
  404aed:	44 89 f9             	mov    ecx,r15d
  404af0:	4c 89 c2             	mov    rdx,r8
  404af3:	e8 68 7c 00 00       	call   40c760 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  404af8:	83 f8 ff             	cmp    eax,0xffffffff
  404afb:	0f 84 a4 01 00 00    	je     404ca5 <thd_alloc+0x365>
	if (unlikely(ret != 0)) {
  404b01:	85 c0                	test   eax,eax
  404b03:	0f 84 29 ff ff ff    	je     404a32 <thd_alloc+0xf2>
		assert(ret != -EINVAL);
  404b09:	83 f8 ea             	cmp    eax,0xffffffea
  404b0c:	0f 84 eb 01 00 00    	je     404cfd <thd_alloc+0x3bd>
		if (ret == -EBUSY) return ret;
  404b12:	83 f8 f0             	cmp    eax,0xfffffff0
  404b15:	0f 84 0c ff ff ff    	je     404a27 <thd_alloc+0xe7>
		assert(ret == -EAGAIN);
  404b1b:	83 f8 f5             	cmp    eax,0xfffffff5
  404b1e:	0f 85 1c 02 00 00    	jne    404d40 <thd_alloc+0x400>
		tok    = cos_sched_sync();
  404b24:	e8 d7 c7 00 00       	call   411300 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  404b29:	48 8b 35 50 d3 19 00 	mov    rsi,QWORD PTR [rip+0x19d350]        # 5a1e80 <__slm_global>
  404b30:	41 89 c1             	mov    r9d,eax
		if (unlikely(owner)) {
  404b33:	48 89 f1             	mov    rcx,rsi
  404b36:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  404b3a:	0f 85 d9 01 00 00    	jne    404d19 <thd_alloc+0x3d9>
  404b40:	48 89 f0             	mov    rax,rsi
  404b43:	f0 48 0f b1 1d 34 d3 	lock cmpxchg QWORD PTR [rip+0x19d334],rbx        # 5a1e80 <__slm_global>
  404b4a:	19 00 
  404b4c:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  404b4f:	84 c0                	test   al,al
  404b51:	0f 85 07 ff ff ff    	jne    404a5e <thd_alloc+0x11e>
  404b57:	eb cb                	jmp    404b24 <thd_alloc+0x1e4>
  404b59:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  404b60:	f0 48 0f b1 15 17 d3 	lock cmpxchg QWORD PTR [rip+0x19d317],rdx        # 5a1e80 <__slm_global>
  404b67:	19 00 
  404b69:	0f 94 c0             	sete   al
	while (ret != 0) {
  404b6c:	84 c0                	test   al,al
  404b6e:	0f 85 be fe ff ff    	jne    404a32 <thd_alloc+0xf2>
		tok    = cos_sched_sync();
  404b74:	e8 87 c7 00 00       	call   411300 <cos_sched_sync>
  404b79:	89 c1                	mov    ecx,eax
  404b7b:	48 8b 05 fe d2 19 00 	mov    rax,QWORD PTR [rip+0x19d2fe]        # 5a1e80 <__slm_global>
		if (unlikely(contention)) {
  404b82:	48 89 c2             	mov    rdx,rax
  404b85:	83 e2 01             	and    edx,0x1
  404b88:	74 d6                	je     404b60 <thd_alloc+0x220>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  404b8a:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  404b8d:	48 89 c2             	mov    rdx,rax
  404b90:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  404b95:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  404b99:	e8 c2 ec 00 00       	call   413860 <slm_cs_exit_contention>
  404b9e:	85 c0                	test   eax,eax
  404ba0:	0f 84 8c fe ff ff    	je     404a32 <thd_alloc+0xf2>
  404ba6:	eb cc                	jmp    404b74 <thd_alloc+0x234>
  404ba8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  404baf:	00 
		current = slm_thd_special();
  404bb0:	e8 1b eb 00 00       	call   4136d0 <slm_thd_special>
  404bb5:	48 89 c3             	mov    rbx,rax
		assert(current);
  404bb8:	48 85 c0             	test   rax,rax
  404bbb:	0f 85 b1 fd ff ff    	jne    404972 <thd_alloc+0x32>
  404bc1:	be 28 00 00 00       	mov    esi,0x28
  404bc6:	bf 48 bc 41 00       	mov    edi,0x41bc48
  404bcb:	e8 00 55 00 00       	call   40a0d0 <cos_print_str>
  404bd0:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404bd7:	00 00 00 00 
  404bdb:	0f 0b                	ud2    
  404bdd:	0f 1f 00             	nop    DWORD PTR [rax]
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  404be0:	41 89 c0             	mov    r8d,eax
  404be3:	48 89 da             	mov    rdx,rbx
  404be6:	48 89 c6             	mov    rsi,rax
  404be9:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  404bee:	41 83 e0 01          	and    r8d,0x1
  404bf2:	e8 19 ec 00 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  404bf7:	83 f8 f0             	cmp    eax,0xfffffff0
  404bfa:	0f 85 b5 fd ff ff    	jne    4049b5 <thd_alloc+0x75>
  404c00:	be 59 00 00 00       	mov    esi,0x59
  404c05:	bf 78 bc 41 00       	mov    edi,0x41bc78
  404c0a:	e8 c1 54 00 00       	call   40a0d0 <cos_print_str>
  404c0f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404c16:	00 00 00 00 
  404c1a:	0f 0b                	ud2    
  404c1c:	be 61 00 00 00       	mov    esi,0x61
  404c21:	bf d8 bc 41 00       	mov    edi,0x41bcd8
  404c26:	e8 a5 54 00 00       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  404c2b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404c32:	00 00 00 00 
  404c36:	0f 0b                	ud2    
	timeout = g->timeout_next;
  404c38:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  404c3b:	49 81 fe 88 1e 5a 00 	cmp    r14,0x5a1e88
  404c42:	0f 84 8f 00 00 00    	je     404cd7 <thd_alloc+0x397>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  404c48:	a8 02                	test   al,0x2
  404c4a:	0f 85 92 00 00 00    	jne    404ce2 <thd_alloc+0x3a2>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  404c50:	49 89 c8             	mov    r8,rcx
  404c53:	a8 01                	test   al,0x1
  404c55:	0f 84 8e fe ff ff    	je     404ae9 <thd_alloc+0x1a9>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  404c5b:	4d 8b 56 08          	mov    r10,QWORD PTR [r14+0x8]
  404c5f:	49 8b 7e 10          	mov    rdi,QWORD PTR [r14+0x10]
  404c63:	48 89 f2             	mov    rdx,rsi
  404c66:	45 89 f9             	mov    r9d,r15d
  404c69:	4c 8b 05 38 d2 19 00 	mov    r8,QWORD PTR [rip+0x19d238]        # 5a1ea8 <__slm_global+0x28>
  404c70:	4c 89 d6             	mov    rsi,r10
  404c73:	e8 a8 c6 00 00       	call   411320 <cos_switch>
	if (unlikely(ret != 0)) {
  404c78:	85 c0                	test   eax,eax
  404c7a:	0f 84 b2 fd ff ff    	je     404a32 <thd_alloc+0xf2>
		assert(ret != -EPERM);
  404c80:	83 f8 ff             	cmp    eax,0xffffffff
  404c83:	0f 85 80 fe ff ff    	jne    404b09 <thd_alloc+0x1c9>
  404c89:	be 61 00 00 00       	mov    esi,0x61
  404c8e:	bf 40 bd 41 00       	mov    edi,0x41bd40
  404c93:	e8 38 54 00 00       	call   40a0d0 <cos_print_str>
  404c98:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404c9f:	00 00 00 00 
  404ca3:	0f 0b                	ud2    
	return t != &g->idle_thd && t != &g->sched_thd;
  404ca5:	49 81 fe 00 1f 5a 00 	cmp    r14,0x5a1f00
  404cac:	74 09                	je     404cb7 <thd_alloc+0x377>
  404cae:	49 81 fe 88 1e 5a 00 	cmp    r14,0x5a1e88
  404cb5:	75 d2                	jne    404c89 <thd_alloc+0x349>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  404cb7:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]
  404cbb:	4c 8b 05 e6 d1 19 00 	mov    r8,QWORD PTR [rip+0x19d1e6]        # 5a1ea8 <__slm_global+0x28>
  404cc2:	45 89 f9             	mov    r9d,r15d
  404cc5:	31 c9                	xor    ecx,ecx
  404cc7:	48 8b 3d ca d1 19 00 	mov    rdi,QWORD PTR [rip+0x19d1ca]        # 5a1e98 <__slm_global+0x18>
  404cce:	31 f6                	xor    esi,esi
  404cd0:	e8 4b c6 00 00       	call   411320 <cos_switch>
  404cd5:	eb a1                	jmp    404c78 <thd_alloc+0x338>
			prio    = curr->priority;
  404cd7:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
			timeout = TCAP_TIME_NIL;
  404cdb:	31 c9                	xor    ecx,ecx
  404cdd:	e9 66 ff ff ff       	jmp    404c48 <thd_alloc+0x308>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  404ce2:	49 8b 7e 28          	mov    rdi,QWORD PTR [r14+0x28]
  404ce6:	48 8b 15 bb d1 19 00 	mov    rdx,QWORD PTR [rip+0x19d1bb]        # 5a1ea8 <__slm_global+0x28>
  404ced:	44 89 f9             	mov    ecx,r15d
  404cf0:	4c 89 c6             	mov    rsi,r8
  404cf3:	e8 98 c6 00 00       	call   411390 <cos_sched_asnd>
  404cf8:	e9 7b ff ff ff       	jmp    404c78 <thd_alloc+0x338>
  404cfd:	be 61 00 00 00       	mov    esi,0x61
  404d02:	bf a8 bd 41 00       	mov    edi,0x41bda8
  404d07:	e8 c4 53 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  404d0c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404d13:	00 00 00 00 
  404d17:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  404d19:	41 89 f0             	mov    r8d,esi
  404d1c:	48 89 da             	mov    rdx,rbx
  404d1f:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  404d24:	41 83 e0 01          	and    r8d,0x1
  404d28:	e8 e3 ea 00 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  404d2d:	83 f8 f0             	cmp    eax,0xfffffff0
  404d30:	0f 85 ee fd ff ff    	jne    404b24 <thd_alloc+0x1e4>
  404d36:	e9 c5 fe ff ff       	jmp    404c00 <thd_alloc+0x2c0>
  404d3b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  404d40:	be 61 00 00 00       	mov    esi,0x61
  404d45:	bf 10 be 41 00       	mov    edi,0x41be10
  404d4a:	e8 81 53 00 00       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  404d4f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404d56:	00 00 00 00 
  404d5a:	0f 0b                	ud2    
  404d5c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000404d60 <thd_alloc_in>:

struct slm_thd *
thd_alloc_in(compid_t id, thdclosure_index_t idx, sched_param_t *parameters, int reschedule)
{
  404d60:	f3 0f 1e fa          	endbr64 
  404d64:	55                   	push   rbp
  404d65:	48 89 e5             	mov    rbp,rsp
  404d68:	41 57                	push   r15
  404d6a:	41 89 cf             	mov    r15d,ecx
  404d6d:	41 56                	push   r14
  404d6f:	41 89 f6             	mov    r14d,esi
  404d72:	41 55                	push   r13
  404d74:	41 54                	push   r12
  404d76:	49 89 fc             	mov    r12,rdi
  404d79:	53                   	push   rbx
  404d7a:	48 89 d3             	mov    rbx,rdx
  404d7d:	48 83 ec 28          	sub    rsp,0x28
	struct slm_thd_container *t;
	struct slm_thd *ret     = NULL, *thd;
	struct slm_thd *current = slm_thd_current_extern();
  404d81:	e8 ba cb ff ff       	call   401940 <slm_thd_current_extern>

	/*
	 * If this condition is true, we are likely in the
	 * initialization sequence in the idle or scheduler threads...
	 */
	if (!current) {
  404d86:	49 89 c5             	mov    r13,rax
  404d89:	48 85 c0             	test   rax,rax
  404d8c:	0f 84 2e 02 00 00    	je     404fc0 <thd_alloc_in+0x260>
	_cap = capmgr_thd_create_ext(cid, idx, &_tid);
  404d92:	41 0f b7 fc          	movzx  edi,r12w
  404d96:	48 8d 55 c8          	lea    rdx,[rbp-0x38]
  404d9a:	44 89 f6             	mov    esi,r14d
  404d9d:	e8 ce 1d 00 00       	call   406b70 <__cosrt_extern_capmgr_thd_create_ext>
  404da2:	48 89 c7             	mov    rdi,rax
	if (_cap <= 0) return NULL;
  404da5:	48 85 c0             	test   rax,rax
  404da8:	0f 84 98 00 00 00    	je     404e46 <thd_alloc_in+0xe6>
	return slm_thd_mem_alloc(_cap, _tid, thd, tid);
  404dae:	48 8b 75 c8          	mov    rsi,QWORD PTR [rbp-0x38]
  404db2:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  404db6:	48 8d 55 b8          	lea    rdx,[rbp-0x48]
  404dba:	e8 f1 cb ff ff       	call   4019b0 <slm_thd_mem_alloc>
  404dbf:	49 89 c6             	mov    r14,rax
		current = slm_thd_special();
		assert(current);
	}

	t = slm_thd_alloc_in(id, idx, &thdcap, &tid);
	if (!t) ERR_THROW(NULL, done);
  404dc2:	48 85 c0             	test   rax,rax
  404dc5:	74 7f                	je     404e46 <thd_alloc_in+0xe6>
	thd = slm_thd_from_container(t);
  404dc7:	48 89 c7             	mov    rdi,rax
  404dca:	e8 d1 cb ff ff       	call   4019a0 <slm_thd_from_container>
  404dcf:	49 89 c4             	mov    r12,rax
		tok    = cos_sched_sync();
  404dd2:	e8 29 c5 00 00       	call   411300 <cos_sched_sync>
  404dd7:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  404dda:	48 8b 05 9f d0 19 00 	mov    rax,QWORD PTR [rip+0x19d09f]        # 5a1e80 <__slm_global>
		if (unlikely(owner)) {
  404de1:	48 89 c1             	mov    rcx,rax
  404de4:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  404de8:	0f 85 02 02 00 00    	jne    404ff0 <thd_alloc_in+0x290>
  404dee:	f0 4c 0f b1 2d 89 d0 	lock cmpxchg QWORD PTR [rip+0x19d089],r13        # 5a1e80 <__slm_global>
  404df5:	19 00 
  404df7:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  404dfa:	84 c0                	test   al,al
  404dfc:	74 d4                	je     404dd2 <thd_alloc_in+0x72>

	slm_cs_enter(current, SLM_CS_NONE);
	if (slm_thd_init(thd, thdcap, tid)) ERR_THROW(NULL, free);
  404dfe:	48 8b 55 c0          	mov    rdx,QWORD PTR [rbp-0x40]
  404e02:	48 8b 75 b8          	mov    rsi,QWORD PTR [rbp-0x48]
  404e06:	4c 89 e7             	mov    rdi,r12
  404e09:	e8 02 e9 00 00       	call   413710 <slm_thd_init>
  404e0e:	85 c0                	test   eax,eax
  404e10:	75 2c                	jne    404e3e <thd_alloc_in+0xde>

	for (i = 0; parameters[i] != 0; i++) {
  404e12:	8b 33                	mov    esi,DWORD PTR [rbx]
  404e14:	48 83 c3 04          	add    rbx,0x4
  404e18:	85 f6                	test   esi,esi
  404e1a:	75 0e                	jne    404e2a <thd_alloc_in+0xca>
  404e1c:	eb 42                	jmp    404e60 <thd_alloc_in+0x100>
  404e1e:	66 90                	xchg   ax,ax
  404e20:	8b 33                	mov    esi,DWORD PTR [rbx]
  404e22:	48 83 c3 04          	add    rbx,0x4
  404e26:	85 f6                	test   esi,esi
  404e28:	74 36                	je     404e60 <thd_alloc_in+0x100>
  404e2a:	89 f2                	mov    edx,esi
		sched_param_type_t type;
		unsigned int value;

		sched_param_get(parameters[i], &type, &value);
		if (slm_sched_thd_update(thd, type, value)) ERR_THROW(NULL, free);
  404e2c:	4c 89 e7             	mov    rdi,r12
	if (type)  *type  = (sched_param_type_t)(sp &  SCHED_PARAM_TYPE_MASK);
  404e2f:	83 e6 3f             	and    esi,0x3f
	if (value) *value = (unsigned int)      (sp >> SCHED_PARAM_TYPE_BITS);
  404e32:	c1 ea 06             	shr    edx,0x6
  404e35:	e8 26 c9 ff ff       	call   401760 <slm_sched_thd_update>
  404e3a:	85 c0                	test   eax,eax
  404e3c:	74 e2                	je     404e20 <thd_alloc_in+0xc0>

	ret = thd;
done:
	return ret;
free:
	slm_thd_mem_free(t);
  404e3e:	4c 89 f7             	mov    rdi,r14
  404e41:	e8 0a cd ff ff       	call   401b50 <slm_thd_mem_free>
	ret = NULL;
  404e46:	45 31 e4             	xor    r12d,r12d
	goto done;
}
  404e49:	48 83 c4 28          	add    rsp,0x28
  404e4d:	4c 89 e0             	mov    rax,r12
  404e50:	5b                   	pop    rbx
  404e51:	41 5c                	pop    r12
  404e53:	41 5d                	pop    r13
  404e55:	41 5e                	pop    r14
  404e57:	41 5f                	pop    r15
  404e59:	5d                   	pop    rbp
  404e5a:	c3                   	ret    
  404e5b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	slm_thd_mem_activate(t);
  404e60:	4c 89 f7             	mov    rdi,r14
  404e63:	e8 28 cc ff ff       	call   401a90 <slm_thd_mem_activate>
	if (reschedule) {
  404e68:	45 85 ff             	test   r15d,r15d
  404e6b:	0f 84 13 01 00 00    	je     404f84 <thd_alloc_in+0x224>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  404e71:	e8 ea 69 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(!t)) t = &g->idle_thd;
  404e76:	41 bf 00 1f 5a 00    	mov    r15d,0x5a1f00
	tok  = cos_sched_sync();
  404e7c:	e8 7f c4 00 00       	call   411300 <cos_sched_sync>
  404e81:	41 89 c6             	mov    r14d,eax
	t = slm_sched_schedule();
  404e84:	e8 17 c9 ff ff       	call   4017a0 <slm_sched_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  404e89:	48 85 c0             	test   rax,rax
	t = slm_sched_schedule();
  404e8c:	48 89 c3             	mov    rbx,rax
	if (unlikely(!t)) t = &g->idle_thd;
  404e8f:	49 0f 44 df          	cmove  rbx,r15
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  404e93:	8b 43 04             	mov    eax,DWORD PTR [rbx+0x4]
  404e96:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  404e99:	83 f8 01             	cmp    eax,0x1
  404e9c:	76 1a                	jbe    404eb8 <thd_alloc_in+0x158>
  404e9e:	e9 89 01 00 00       	jmp    40502c <thd_alloc_in+0x2cc>
  404ea3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  404ea8:	f0 48 0f b1 15 cf cf 	lock cmpxchg QWORD PTR [rip+0x19cfcf],rdx        # 5a1e80 <__slm_global>
  404eaf:	19 00 
  404eb1:	0f 94 c0             	sete   al
	while (ret != 0) {
  404eb4:	84 c0                	test   al,al
  404eb6:	75 2e                	jne    404ee6 <thd_alloc_in+0x186>
		tok    = cos_sched_sync();
  404eb8:	e8 43 c4 00 00       	call   411300 <cos_sched_sync>
  404ebd:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  404ebf:	48 8b 05 ba cf 19 00 	mov    rax,QWORD PTR [rip+0x19cfba]        # 5a1e80 <__slm_global>
		if (unlikely(contention)) {
  404ec6:	48 89 c2             	mov    rdx,rax
  404ec9:	83 e2 01             	and    edx,0x1
  404ecc:	74 da                	je     404ea8 <thd_alloc_in+0x148>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  404ece:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  404ed1:	48 89 c2             	mov    rdx,rax
  404ed4:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  404ed9:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  404edd:	e8 7e e9 00 00       	call   413860 <slm_cs_exit_contention>
  404ee2:	85 c0                	test   eax,eax
  404ee4:	75 d2                	jne    404eb8 <thd_alloc_in+0x158>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  404ee6:	e8 75 69 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  404eeb:	8b 03                	mov    eax,DWORD PTR [rbx]
	timeout = g->timeout_next;
  404eed:	4c 8b 05 94 d0 19 00 	mov    r8,QWORD PTR [rip+0x19d094]        # 5a1f88 <__slm_global+0x108>
	prio = inherit_prio ? curr->priority : t->priority;
  404ef4:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  404ef8:	a8 0b                	test   al,0xb
  404efa:	0f 85 48 01 00 00    	jne    405048 <thd_alloc_in+0x2e8>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  404f00:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  404f04:	44 89 f1             	mov    ecx,r14d
  404f07:	4c 89 c2             	mov    rdx,r8
  404f0a:	e8 51 78 00 00       	call   40c760 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  404f0f:	83 f8 ff             	cmp    eax,0xffffffff
  404f12:	0f 84 9d 01 00 00    	je     4050b5 <thd_alloc_in+0x355>
	if (unlikely(ret != 0)) {
  404f18:	85 c0                	test   eax,eax
  404f1a:	0f 84 29 ff ff ff    	je     404e49 <thd_alloc_in+0xe9>
		assert(ret != -EINVAL);
  404f20:	83 f8 ea             	cmp    eax,0xffffffea
  404f23:	0f 84 e4 01 00 00    	je     40510d <thd_alloc_in+0x3ad>
		if (ret == -EBUSY) return ret;
  404f29:	83 f8 f0             	cmp    eax,0xfffffff0
  404f2c:	0f 84 14 ff ff ff    	je     404e46 <thd_alloc_in+0xe6>
		assert(ret == -EAGAIN);
  404f32:	83 f8 f5             	cmp    eax,0xfffffff5
  404f35:	0f 85 15 02 00 00    	jne    405150 <thd_alloc_in+0x3f0>
		tok    = cos_sched_sync();
  404f3b:	e8 c0 c3 00 00       	call   411300 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  404f40:	48 8b 35 39 cf 19 00 	mov    rsi,QWORD PTR [rip+0x19cf39]        # 5a1e80 <__slm_global>
  404f47:	41 89 c1             	mov    r9d,eax
		if (unlikely(owner)) {
  404f4a:	48 89 f1             	mov    rcx,rsi
  404f4d:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  404f51:	0f 85 d2 01 00 00    	jne    405129 <thd_alloc_in+0x3c9>
  404f57:	48 89 f0             	mov    rax,rsi
  404f5a:	f0 4c 0f b1 2d 1d cf 	lock cmpxchg QWORD PTR [rip+0x19cf1d],r13        # 5a1e80 <__slm_global>
  404f61:	19 00 
  404f63:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  404f66:	84 c0                	test   al,al
  404f68:	0f 85 0e ff ff ff    	jne    404e7c <thd_alloc_in+0x11c>
  404f6e:	eb cb                	jmp    404f3b <thd_alloc_in+0x1db>
  404f70:	f0 48 0f b1 15 07 cf 	lock cmpxchg QWORD PTR [rip+0x19cf07],rdx        # 5a1e80 <__slm_global>
  404f77:	19 00 
  404f79:	0f 94 c0             	sete   al
	while (ret != 0) {
  404f7c:	84 c0                	test   al,al
  404f7e:	0f 85 c5 fe ff ff    	jne    404e49 <thd_alloc_in+0xe9>
		tok    = cos_sched_sync();
  404f84:	e8 77 c3 00 00       	call   411300 <cos_sched_sync>
  404f89:	89 c1                	mov    ecx,eax
  404f8b:	48 8b 05 ee ce 19 00 	mov    rax,QWORD PTR [rip+0x19ceee]        # 5a1e80 <__slm_global>
		if (unlikely(contention)) {
  404f92:	48 89 c2             	mov    rdx,rax
  404f95:	83 e2 01             	and    edx,0x1
  404f98:	74 d6                	je     404f70 <thd_alloc_in+0x210>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  404f9a:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  404f9d:	48 89 c2             	mov    rdx,rax
  404fa0:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  404fa5:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  404fa9:	e8 b2 e8 00 00       	call   413860 <slm_cs_exit_contention>
  404fae:	85 c0                	test   eax,eax
  404fb0:	0f 84 93 fe ff ff    	je     404e49 <thd_alloc_in+0xe9>
  404fb6:	eb cc                	jmp    404f84 <thd_alloc_in+0x224>
  404fb8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  404fbf:	00 
		current = slm_thd_special();
  404fc0:	e8 0b e7 00 00       	call   4136d0 <slm_thd_special>
  404fc5:	49 89 c5             	mov    r13,rax
		assert(current);
  404fc8:	48 85 c0             	test   rax,rax
  404fcb:	0f 85 c1 fd ff ff    	jne    404d92 <thd_alloc_in+0x32>
  404fd1:	be 29 00 00 00       	mov    esi,0x29
  404fd6:	bf 78 be 41 00       	mov    edi,0x41be78
  404fdb:	e8 f0 50 00 00       	call   40a0d0 <cos_print_str>
  404fe0:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404fe7:	00 00 00 00 
  404feb:	0f 0b                	ud2    
  404fed:	0f 1f 00             	nop    DWORD PTR [rax]
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  404ff0:	41 89 c0             	mov    r8d,eax
  404ff3:	4c 89 ea             	mov    rdx,r13
  404ff6:	48 89 c6             	mov    rsi,rax
  404ff9:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  404ffe:	41 83 e0 01          	and    r8d,0x1
  405002:	e8 09 e8 00 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  405007:	83 f8 f0             	cmp    eax,0xfffffff0
  40500a:	0f 85 c2 fd ff ff    	jne    404dd2 <thd_alloc_in+0x72>
  405010:	be 59 00 00 00       	mov    esi,0x59
  405015:	bf 78 bc 41 00       	mov    edi,0x41bc78
  40501a:	e8 b1 50 00 00       	call   40a0d0 <cos_print_str>
  40501f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  405026:	00 00 00 00 
  40502a:	0f 0b                	ud2    
  40502c:	be 61 00 00 00       	mov    esi,0x61
  405031:	bf d8 bc 41 00       	mov    edi,0x41bcd8
  405036:	e8 95 50 00 00       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  40503b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  405042:	00 00 00 00 
  405046:	0f 0b                	ud2    
	timeout = g->timeout_next;
  405048:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  40504b:	48 81 fb 88 1e 5a 00 	cmp    rbx,0x5a1e88
  405052:	0f 84 8f 00 00 00    	je     4050e7 <thd_alloc_in+0x387>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  405058:	a8 02                	test   al,0x2
  40505a:	0f 85 92 00 00 00    	jne    4050f2 <thd_alloc_in+0x392>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  405060:	49 89 c8             	mov    r8,rcx
  405063:	a8 01                	test   al,0x1
  405065:	0f 84 95 fe ff ff    	je     404f00 <thd_alloc_in+0x1a0>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  40506b:	4c 8b 53 08          	mov    r10,QWORD PTR [rbx+0x8]
  40506f:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  405073:	48 89 f2             	mov    rdx,rsi
  405076:	45 89 f1             	mov    r9d,r14d
  405079:	4c 8b 05 28 ce 19 00 	mov    r8,QWORD PTR [rip+0x19ce28]        # 5a1ea8 <__slm_global+0x28>
  405080:	4c 89 d6             	mov    rsi,r10
  405083:	e8 98 c2 00 00       	call   411320 <cos_switch>
	if (unlikely(ret != 0)) {
  405088:	85 c0                	test   eax,eax
  40508a:	0f 84 b9 fd ff ff    	je     404e49 <thd_alloc_in+0xe9>
		assert(ret != -EPERM);
  405090:	83 f8 ff             	cmp    eax,0xffffffff
  405093:	0f 85 87 fe ff ff    	jne    404f20 <thd_alloc_in+0x1c0>
  405099:	be 61 00 00 00       	mov    esi,0x61
  40509e:	bf 40 bd 41 00       	mov    edi,0x41bd40
  4050a3:	e8 28 50 00 00       	call   40a0d0 <cos_print_str>
  4050a8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4050af:	00 00 00 00 
  4050b3:	0f 0b                	ud2    
	return t != &g->idle_thd && t != &g->sched_thd;
  4050b5:	48 81 fb 00 1f 5a 00 	cmp    rbx,0x5a1f00
  4050bc:	74 09                	je     4050c7 <thd_alloc_in+0x367>
  4050be:	48 81 fb 88 1e 5a 00 	cmp    rbx,0x5a1e88
  4050c5:	75 d2                	jne    405099 <thd_alloc_in+0x339>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  4050c7:	49 8b 55 30          	mov    rdx,QWORD PTR [r13+0x30]
  4050cb:	4c 8b 05 d6 cd 19 00 	mov    r8,QWORD PTR [rip+0x19cdd6]        # 5a1ea8 <__slm_global+0x28>
  4050d2:	45 89 f1             	mov    r9d,r14d
  4050d5:	31 c9                	xor    ecx,ecx
  4050d7:	48 8b 3d ba cd 19 00 	mov    rdi,QWORD PTR [rip+0x19cdba]        # 5a1e98 <__slm_global+0x18>
  4050de:	31 f6                	xor    esi,esi
  4050e0:	e8 3b c2 00 00       	call   411320 <cos_switch>
  4050e5:	eb a1                	jmp    405088 <thd_alloc_in+0x328>
			prio    = curr->priority;
  4050e7:	49 8b 75 30          	mov    rsi,QWORD PTR [r13+0x30]
			timeout = TCAP_TIME_NIL;
  4050eb:	31 c9                	xor    ecx,ecx
  4050ed:	e9 66 ff ff ff       	jmp    405058 <thd_alloc_in+0x2f8>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  4050f2:	48 8b 7b 28          	mov    rdi,QWORD PTR [rbx+0x28]
  4050f6:	48 8b 15 ab cd 19 00 	mov    rdx,QWORD PTR [rip+0x19cdab]        # 5a1ea8 <__slm_global+0x28>
  4050fd:	44 89 f1             	mov    ecx,r14d
  405100:	4c 89 c6             	mov    rsi,r8
  405103:	e8 88 c2 00 00       	call   411390 <cos_sched_asnd>
  405108:	e9 7b ff ff ff       	jmp    405088 <thd_alloc_in+0x328>
  40510d:	be 61 00 00 00       	mov    esi,0x61
  405112:	bf a8 bd 41 00       	mov    edi,0x41bda8
  405117:	e8 b4 4f 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  40511c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  405123:	00 00 00 00 
  405127:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  405129:	41 89 f0             	mov    r8d,esi
  40512c:	4c 89 ea             	mov    rdx,r13
  40512f:	bf 80 1e 5a 00       	mov    edi,0x5a1e80
  405134:	41 83 e0 01          	and    r8d,0x1
  405138:	e8 d3 e6 00 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  40513d:	83 f8 f0             	cmp    eax,0xfffffff0
  405140:	0f 85 f5 fd ff ff    	jne    404f3b <thd_alloc_in+0x1db>
  405146:	e9 c5 fe ff ff       	jmp    405010 <thd_alloc_in+0x2b0>
  40514b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  405150:	be 61 00 00 00       	mov    esi,0x61
  405155:	bf 10 be 41 00       	mov    edi,0x41be10
  40515a:	e8 71 4f 00 00       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  40515f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  405166:	00 00 00 00 
  40516a:	0f 0b                	ud2    
  40516c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000405170 <__cosrt_s_sched_get_cpu_freq>:
  405170:	48 b9 7f 51 40 00 00 	movabs rcx,0x40517f
  405177:	00 00 00 
  40517a:	e9 31 57 00 00       	jmp    40a8b0 <custom_acquire_stack>
  40517f:	52                   	push   rdx
  405180:	50                   	push   rax
  405181:	55                   	push   rbp
  405182:	4c 89 e1             	mov    rcx,r12
  405185:	48 31 ed             	xor    rbp,rbp
  405188:	48 89 f8             	mov    rax,rdi
  40518b:	48 89 df             	mov    rdi,rbx
  40518e:	48 89 c2             	mov    rdx,rax
  405191:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405195:	e8 86 f2 ff ff       	call   404420 <sched_get_cpu_freq>
  40519a:	49 89 c0             	mov    r8,rax
  40519d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  4051a4:	0f 05                	syscall 
  4051a6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4051ad:	00 00 00 

00000000004051b0 <__cosrt_alts_sched_get_cpu_freq>:
  4051b0:	4c 89 e8             	mov    rax,r13
  4051b3:	48 b9 c2 51 40 00 00 	movabs rcx,0x4051c2
  4051ba:	00 00 00 
  4051bd:	e9 ee 56 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4051c2:	52                   	push   rdx
  4051c3:	50                   	push   rax
  4051c4:	55                   	push   rbp
  4051c5:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4051c9:	48 31 ed             	xor    rbp,rbp
  4051cc:	51                   	push   rcx
  4051cd:	51                   	push   rcx
  4051ce:	4c 89 c1             	mov    rcx,r8
  4051d1:	4c 89 ca             	mov    rdx,r9
  4051d4:	e8 47 f2 ff ff       	call   404420 <sched_get_cpu_freq>
  4051d9:	59                   	pop    rcx
  4051da:	c3                   	ret    
  4051db:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000004051e0 <__cosrt_s_sched_thd_yield_to>:
  4051e0:	48 b9 ef 51 40 00 00 	movabs rcx,0x4051ef
  4051e7:	00 00 00 
  4051ea:	e9 c1 56 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4051ef:	52                   	push   rdx
  4051f0:	50                   	push   rax
  4051f1:	55                   	push   rbp
  4051f2:	4c 89 e1             	mov    rcx,r12
  4051f5:	48 31 ed             	xor    rbp,rbp
  4051f8:	48 89 f8             	mov    rax,rdi
  4051fb:	48 89 df             	mov    rdi,rbx
  4051fe:	48 89 c2             	mov    rdx,rax
  405201:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405205:	e8 76 cd ff ff       	call   401f80 <sched_thd_yield_to>
  40520a:	49 89 c0             	mov    r8,rax
  40520d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  405214:	0f 05                	syscall 
  405216:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40521d:	00 00 00 

0000000000405220 <__cosrt_alts_sched_thd_yield_to>:
  405220:	4c 89 e8             	mov    rax,r13
  405223:	48 b9 32 52 40 00 00 	movabs rcx,0x405232
  40522a:	00 00 00 
  40522d:	e9 7e 56 00 00       	jmp    40a8b0 <custom_acquire_stack>
  405232:	52                   	push   rdx
  405233:	50                   	push   rax
  405234:	55                   	push   rbp
  405235:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405239:	48 31 ed             	xor    rbp,rbp
  40523c:	51                   	push   rcx
  40523d:	51                   	push   rcx
  40523e:	4c 89 c1             	mov    rcx,r8
  405241:	4c 89 ca             	mov    rdx,r9
  405244:	e8 37 cd ff ff       	call   401f80 <sched_thd_yield_to>
  405249:	59                   	pop    rcx
  40524a:	c3                   	ret    
  40524b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000405250 <__cosrt_s_sched_thd_wakeup>:
  405250:	48 b9 5f 52 40 00 00 	movabs rcx,0x40525f
  405257:	00 00 00 
  40525a:	e9 51 56 00 00       	jmp    40a8b0 <custom_acquire_stack>
  40525f:	52                   	push   rdx
  405260:	50                   	push   rax
  405261:	55                   	push   rbp
  405262:	4c 89 e1             	mov    rcx,r12
  405265:	48 31 ed             	xor    rbp,rbp
  405268:	48 89 f8             	mov    rax,rdi
  40526b:	48 89 df             	mov    rdi,rbx
  40526e:	48 89 c2             	mov    rdx,rax
  405271:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405275:	e8 76 dc ff ff       	call   402ef0 <sched_thd_wakeup>
  40527a:	49 89 c0             	mov    r8,rax
  40527d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  405284:	0f 05                	syscall 
  405286:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40528d:	00 00 00 

0000000000405290 <__cosrt_alts_sched_thd_wakeup>:
  405290:	4c 89 e8             	mov    rax,r13
  405293:	48 b9 a2 52 40 00 00 	movabs rcx,0x4052a2
  40529a:	00 00 00 
  40529d:	e9 0e 56 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4052a2:	52                   	push   rdx
  4052a3:	50                   	push   rax
  4052a4:	55                   	push   rbp
  4052a5:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4052a9:	48 31 ed             	xor    rbp,rbp
  4052ac:	51                   	push   rcx
  4052ad:	51                   	push   rcx
  4052ae:	4c 89 c1             	mov    rcx,r8
  4052b1:	4c 89 ca             	mov    rdx,r9
  4052b4:	e8 37 dc ff ff       	call   402ef0 <sched_thd_wakeup>
  4052b9:	59                   	pop    rcx
  4052ba:	c3                   	ret    
  4052bb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000004052c0 <__cosrt_s_sched_debug_thd_state>:
  4052c0:	48 b9 cf 52 40 00 00 	movabs rcx,0x4052cf
  4052c7:	00 00 00 
  4052ca:	e9 e1 55 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4052cf:	52                   	push   rdx
  4052d0:	50                   	push   rax
  4052d1:	55                   	push   rbp
  4052d2:	4c 89 e1             	mov    rcx,r12
  4052d5:	48 31 ed             	xor    rbp,rbp
  4052d8:	48 89 f8             	mov    rax,rdi
  4052db:	48 89 df             	mov    rdi,rbx
  4052de:	48 89 c2             	mov    rdx,rax
  4052e1:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4052e5:	e8 06 e0 ff ff       	call   4032f0 <sched_debug_thd_state>
  4052ea:	49 89 c0             	mov    r8,rax
  4052ed:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  4052f4:	0f 05                	syscall 
  4052f6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4052fd:	00 00 00 

0000000000405300 <__cosrt_alts_sched_debug_thd_state>:
  405300:	4c 89 e8             	mov    rax,r13
  405303:	48 b9 12 53 40 00 00 	movabs rcx,0x405312
  40530a:	00 00 00 
  40530d:	e9 9e 55 00 00       	jmp    40a8b0 <custom_acquire_stack>
  405312:	52                   	push   rdx
  405313:	50                   	push   rax
  405314:	55                   	push   rbp
  405315:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405319:	48 31 ed             	xor    rbp,rbp
  40531c:	51                   	push   rcx
  40531d:	51                   	push   rcx
  40531e:	4c 89 c1             	mov    rcx,r8
  405321:	4c 89 ca             	mov    rdx,r9
  405324:	e8 c7 df ff ff       	call   4032f0 <sched_debug_thd_state>
  405329:	59                   	pop    rcx
  40532a:	c3                   	ret    
  40532b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000405330 <__cosrt_s_sched_thd_block>:
  405330:	48 b9 3f 53 40 00 00 	movabs rcx,0x40533f
  405337:	00 00 00 
  40533a:	e9 71 55 00 00       	jmp    40a8b0 <custom_acquire_stack>
  40533f:	52                   	push   rdx
  405340:	50                   	push   rax
  405341:	55                   	push   rbp
  405342:	4c 89 e1             	mov    rcx,r12
  405345:	48 31 ed             	xor    rbp,rbp
  405348:	48 89 f8             	mov    rax,rdi
  40534b:	48 89 df             	mov    rdi,rbx
  40534e:	48 89 c2             	mov    rdx,rax
  405351:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405355:	e8 06 d4 ff ff       	call   402760 <sched_thd_block>
  40535a:	49 89 c0             	mov    r8,rax
  40535d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  405364:	0f 05                	syscall 
  405366:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40536d:	00 00 00 

0000000000405370 <__cosrt_alts_sched_thd_block>:
  405370:	4c 89 e8             	mov    rax,r13
  405373:	48 b9 82 53 40 00 00 	movabs rcx,0x405382
  40537a:	00 00 00 
  40537d:	e9 2e 55 00 00       	jmp    40a8b0 <custom_acquire_stack>
  405382:	52                   	push   rdx
  405383:	50                   	push   rax
  405384:	55                   	push   rbp
  405385:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405389:	48 31 ed             	xor    rbp,rbp
  40538c:	51                   	push   rcx
  40538d:	51                   	push   rcx
  40538e:	4c 89 c1             	mov    rcx,r8
  405391:	4c 89 ca             	mov    rdx,r9
  405394:	e8 c7 d3 ff ff       	call   402760 <sched_thd_block>
  405399:	59                   	pop    rcx
  40539a:	c3                   	ret    
  40539b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000004053a0 <__cosrt_s_sched_blkpt_alloc>:
  4053a0:	48 b9 af 53 40 00 00 	movabs rcx,0x4053af
  4053a7:	00 00 00 
  4053aa:	e9 01 55 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4053af:	52                   	push   rdx
  4053b0:	50                   	push   rax
  4053b1:	55                   	push   rbp
  4053b2:	4c 89 e1             	mov    rcx,r12
  4053b5:	48 31 ed             	xor    rbp,rbp
  4053b8:	48 89 f8             	mov    rax,rdi
  4053bb:	48 89 df             	mov    rdi,rbx
  4053be:	48 89 c2             	mov    rdx,rax
  4053c1:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4053c5:	e8 a6 e7 ff ff       	call   403b70 <sched_blkpt_alloc>
  4053ca:	49 89 c0             	mov    r8,rax
  4053cd:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  4053d4:	0f 05                	syscall 
  4053d6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4053dd:	00 00 00 

00000000004053e0 <__cosrt_alts_sched_blkpt_alloc>:
  4053e0:	4c 89 e8             	mov    rax,r13
  4053e3:	48 b9 f2 53 40 00 00 	movabs rcx,0x4053f2
  4053ea:	00 00 00 
  4053ed:	e9 be 54 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4053f2:	52                   	push   rdx
  4053f3:	50                   	push   rax
  4053f4:	55                   	push   rbp
  4053f5:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4053f9:	48 31 ed             	xor    rbp,rbp
  4053fc:	51                   	push   rcx
  4053fd:	51                   	push   rcx
  4053fe:	4c 89 c1             	mov    rcx,r8
  405401:	4c 89 ca             	mov    rdx,r9
  405404:	e8 67 e7 ff ff       	call   403b70 <sched_blkpt_alloc>
  405409:	59                   	pop    rcx
  40540a:	c3                   	ret    
  40540b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000405410 <__cosrt_s_sched_blkpt_free>:
  405410:	48 b9 1f 54 40 00 00 	movabs rcx,0x40541f
  405417:	00 00 00 
  40541a:	e9 91 54 00 00       	jmp    40a8b0 <custom_acquire_stack>
  40541f:	52                   	push   rdx
  405420:	50                   	push   rax
  405421:	55                   	push   rbp
  405422:	4c 89 e1             	mov    rcx,r12
  405425:	48 31 ed             	xor    rbp,rbp
  405428:	48 89 f8             	mov    rax,rdi
  40542b:	48 89 df             	mov    rdi,rbx
  40542e:	48 89 c2             	mov    rdx,rax
  405431:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405435:	e8 d6 e8 ff ff       	call   403d10 <sched_blkpt_free>
  40543a:	49 89 c0             	mov    r8,rax
  40543d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  405444:	0f 05                	syscall 
  405446:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40544d:	00 00 00 

0000000000405450 <__cosrt_alts_sched_blkpt_free>:
  405450:	4c 89 e8             	mov    rax,r13
  405453:	48 b9 62 54 40 00 00 	movabs rcx,0x405462
  40545a:	00 00 00 
  40545d:	e9 4e 54 00 00       	jmp    40a8b0 <custom_acquire_stack>
  405462:	52                   	push   rdx
  405463:	50                   	push   rax
  405464:	55                   	push   rbp
  405465:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405469:	48 31 ed             	xor    rbp,rbp
  40546c:	51                   	push   rcx
  40546d:	51                   	push   rcx
  40546e:	4c 89 c1             	mov    rcx,r8
  405471:	4c 89 ca             	mov    rdx,r9
  405474:	e8 97 e8 ff ff       	call   403d10 <sched_blkpt_free>
  405479:	59                   	pop    rcx
  40547a:	c3                   	ret    
  40547b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000405480 <__cosrt_s_sched_blkpt_trigger>:
  405480:	48 b9 8f 54 40 00 00 	movabs rcx,0x40548f
  405487:	00 00 00 
  40548a:	e9 21 54 00 00       	jmp    40a8b0 <custom_acquire_stack>
  40548f:	52                   	push   rdx
  405490:	50                   	push   rax
  405491:	55                   	push   rbp
  405492:	4c 89 e1             	mov    rcx,r12
  405495:	48 31 ed             	xor    rbp,rbp
  405498:	48 89 f8             	mov    rax,rdi
  40549b:	48 89 df             	mov    rdi,rbx
  40549e:	48 89 c2             	mov    rdx,rax
  4054a1:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4054a5:	e8 76 e8 ff ff       	call   403d20 <sched_blkpt_trigger>
  4054aa:	49 89 c0             	mov    r8,rax
  4054ad:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  4054b4:	0f 05                	syscall 
  4054b6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4054bd:	00 00 00 

00000000004054c0 <__cosrt_alts_sched_blkpt_trigger>:
  4054c0:	4c 89 e8             	mov    rax,r13
  4054c3:	48 b9 d2 54 40 00 00 	movabs rcx,0x4054d2
  4054ca:	00 00 00 
  4054cd:	e9 de 53 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4054d2:	52                   	push   rdx
  4054d3:	50                   	push   rax
  4054d4:	55                   	push   rbp
  4054d5:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4054d9:	48 31 ed             	xor    rbp,rbp
  4054dc:	51                   	push   rcx
  4054dd:	51                   	push   rcx
  4054de:	4c 89 c1             	mov    rcx,r8
  4054e1:	4c 89 ca             	mov    rdx,r9
  4054e4:	e8 37 e8 ff ff       	call   403d20 <sched_blkpt_trigger>
  4054e9:	59                   	pop    rcx
  4054ea:	c3                   	ret    
  4054eb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000004054f0 <__cosrt_s_sched_blkpt_block>:
  4054f0:	48 b9 ff 54 40 00 00 	movabs rcx,0x4054ff
  4054f7:	00 00 00 
  4054fa:	e9 b1 53 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4054ff:	52                   	push   rdx
  405500:	50                   	push   rax
  405501:	55                   	push   rbp
  405502:	4c 89 e1             	mov    rcx,r12
  405505:	48 31 ed             	xor    rbp,rbp
  405508:	48 89 f8             	mov    rax,rdi
  40550b:	48 89 df             	mov    rdi,rbx
  40550e:	48 89 c2             	mov    rdx,rax
  405511:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405515:	e8 76 e8 ff ff       	call   403d90 <sched_blkpt_block>
  40551a:	49 89 c0             	mov    r8,rax
  40551d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  405524:	0f 05                	syscall 
  405526:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40552d:	00 00 00 

0000000000405530 <__cosrt_alts_sched_blkpt_block>:
  405530:	4c 89 e8             	mov    rax,r13
  405533:	48 b9 42 55 40 00 00 	movabs rcx,0x405542
  40553a:	00 00 00 
  40553d:	e9 6e 53 00 00       	jmp    40a8b0 <custom_acquire_stack>
  405542:	52                   	push   rdx
  405543:	50                   	push   rax
  405544:	55                   	push   rbp
  405545:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405549:	48 31 ed             	xor    rbp,rbp
  40554c:	51                   	push   rcx
  40554d:	51                   	push   rcx
  40554e:	4c 89 c1             	mov    rcx,r8
  405551:	4c 89 ca             	mov    rdx,r9
  405554:	e8 37 e8 ff ff       	call   403d90 <sched_blkpt_block>
  405559:	59                   	pop    rcx
  40555a:	c3                   	ret    
  40555b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000405560 <__cosrt_s_sched_thd_block_timeout>:
  405560:	48 b9 6f 55 40 00 00 	movabs rcx,0x40556f
  405567:	00 00 00 
  40556a:	e9 41 53 00 00       	jmp    40a8b0 <custom_acquire_stack>
  40556f:	52                   	push   rdx
  405570:	50                   	push   rax
  405571:	55                   	push   rbp
  405572:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405576:	6a 00                	push   0x0
  405578:	49 89 e0             	mov    r8,rsp
  40557b:	6a 00                	push   0x0
  40557d:	49 89 e1             	mov    r9,rsp
  405580:	4c 89 e1             	mov    rcx,r12
  405583:	48 31 ed             	xor    rbp,rbp
  405586:	49 89 fc             	mov    r12,rdi
  405589:	48 89 df             	mov    rdi,rbx
  40558c:	4c 89 e2             	mov    rdx,r12
  40558f:	e8 1c 03 00 00       	call   4058b0 <__cosrt_s_cstub_sched_thd_block_timeout>
  405594:	5f                   	pop    rdi
  405595:	5e                   	pop    rsi
  405596:	49 89 c0             	mov    r8,rax
  405599:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  4055a0:	0f 05                	syscall 
  4055a2:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4055a9:	00 00 00 00 
  4055ad:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004055b0 <__cosrt_alts_sched_thd_block_timeout>:
  4055b0:	4c 89 e8             	mov    rax,r13
  4055b3:	48 b9 c2 55 40 00 00 	movabs rcx,0x4055c2
  4055ba:	00 00 00 
  4055bd:	e9 ee 52 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4055c2:	52                   	push   rdx
  4055c3:	50                   	push   rax
  4055c4:	55                   	push   rbp
  4055c5:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4055c9:	48 31 ed             	xor    rbp,rbp
  4055cc:	51                   	push   rcx
  4055cd:	51                   	push   rcx
  4055ce:	4c 89 c1             	mov    rcx,r8
  4055d1:	4c 89 ca             	mov    rdx,r9
  4055d4:	6a 00                	push   0x0
  4055d6:	49 89 e0             	mov    r8,rsp
  4055d9:	6a 00                	push   0x0
  4055db:	49 89 e1             	mov    r9,rsp
  4055de:	e8 cd 02 00 00       	call   4058b0 <__cosrt_s_cstub_sched_thd_block_timeout>
  4055e3:	5f                   	pop    rdi
  4055e4:	5e                   	pop    rsi
  4055e5:	59                   	pop    rcx
  4055e6:	c3                   	ret    
  4055e7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  4055ee:	00 00 

00000000004055f0 <__cosrt_s_sched_thd_create_closure>:
  4055f0:	48 b9 ff 55 40 00 00 	movabs rcx,0x4055ff
  4055f7:	00 00 00 
  4055fa:	e9 b1 52 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4055ff:	52                   	push   rdx
  405600:	50                   	push   rax
  405601:	55                   	push   rbp
  405602:	4c 89 e1             	mov    rcx,r12
  405605:	48 31 ed             	xor    rbp,rbp
  405608:	48 89 f8             	mov    rax,rdi
  40560b:	48 89 df             	mov    rdi,rbx
  40560e:	48 89 c2             	mov    rdx,rax
  405611:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405615:	e8 46 c5 ff ff       	call   401b60 <sched_thd_create_closure>
  40561a:	49 89 c0             	mov    r8,rax
  40561d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  405624:	0f 05                	syscall 
  405626:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40562d:	00 00 00 

0000000000405630 <__cosrt_alts_sched_thd_create_closure>:
  405630:	4c 89 e8             	mov    rax,r13
  405633:	48 b9 42 56 40 00 00 	movabs rcx,0x405642
  40563a:	00 00 00 
  40563d:	e9 6e 52 00 00       	jmp    40a8b0 <custom_acquire_stack>
  405642:	52                   	push   rdx
  405643:	50                   	push   rax
  405644:	55                   	push   rbp
  405645:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405649:	48 31 ed             	xor    rbp,rbp
  40564c:	51                   	push   rcx
  40564d:	51                   	push   rcx
  40564e:	4c 89 c1             	mov    rcx,r8
  405651:	4c 89 ca             	mov    rdx,r9
  405654:	e8 07 c5 ff ff       	call   401b60 <sched_thd_create_closure>
  405659:	59                   	pop    rcx
  40565a:	c3                   	ret    
  40565b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000405660 <__cosrt_s_sched_aep_create_closure>:
  405660:	48 b9 6f 56 40 00 00 	movabs rcx,0x40566f
  405667:	00 00 00 
  40566a:	e9 41 52 00 00       	jmp    40a8b0 <custom_acquire_stack>
  40566f:	52                   	push   rdx
  405670:	50                   	push   rax
  405671:	55                   	push   rbp
  405672:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405676:	6a 00                	push   0x0
  405678:	49 89 e0             	mov    r8,rsp
  40567b:	6a 00                	push   0x0
  40567d:	49 89 e1             	mov    r9,rsp
  405680:	4c 89 e1             	mov    rcx,r12
  405683:	48 31 ed             	xor    rbp,rbp
  405686:	49 89 fc             	mov    r12,rdi
  405689:	48 89 df             	mov    rdi,rbx
  40568c:	4c 89 e2             	mov    rdx,r12
  40568f:	e8 4c 02 00 00       	call   4058e0 <__cosrt_s_cstub_sched_aep_create_closure>
  405694:	5f                   	pop    rdi
  405695:	5e                   	pop    rsi
  405696:	49 89 c0             	mov    r8,rax
  405699:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  4056a0:	0f 05                	syscall 
  4056a2:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4056a9:	00 00 00 00 
  4056ad:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004056b0 <__cosrt_alts_sched_aep_create_closure>:
  4056b0:	4c 89 e8             	mov    rax,r13
  4056b3:	48 b9 c2 56 40 00 00 	movabs rcx,0x4056c2
  4056ba:	00 00 00 
  4056bd:	e9 ee 51 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4056c2:	52                   	push   rdx
  4056c3:	50                   	push   rax
  4056c4:	55                   	push   rbp
  4056c5:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4056c9:	48 31 ed             	xor    rbp,rbp
  4056cc:	51                   	push   rcx
  4056cd:	51                   	push   rcx
  4056ce:	4c 89 c1             	mov    rcx,r8
  4056d1:	4c 89 ca             	mov    rdx,r9
  4056d4:	6a 00                	push   0x0
  4056d6:	49 89 e0             	mov    r8,rsp
  4056d9:	6a 00                	push   0x0
  4056db:	49 89 e1             	mov    r9,rsp
  4056de:	e8 fd 01 00 00       	call   4058e0 <__cosrt_s_cstub_sched_aep_create_closure>
  4056e3:	5f                   	pop    rdi
  4056e4:	5e                   	pop    rsi
  4056e5:	59                   	pop    rcx
  4056e6:	c3                   	ret    
  4056e7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  4056ee:	00 00 

00000000004056f0 <__cosrt_s_sched_thd_param_set>:
  4056f0:	48 b9 ff 56 40 00 00 	movabs rcx,0x4056ff
  4056f7:	00 00 00 
  4056fa:	e9 b1 51 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4056ff:	52                   	push   rdx
  405700:	50                   	push   rax
  405701:	55                   	push   rbp
  405702:	4c 89 e1             	mov    rcx,r12
  405705:	48 31 ed             	xor    rbp,rbp
  405708:	48 89 f8             	mov    rax,rdi
  40570b:	48 89 df             	mov    rdi,rbx
  40570e:	48 89 c2             	mov    rdx,rax
  405711:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405715:	e8 96 c4 ff ff       	call   401bb0 <sched_thd_param_set>
  40571a:	49 89 c0             	mov    r8,rax
  40571d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  405724:	0f 05                	syscall 
  405726:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40572d:	00 00 00 

0000000000405730 <__cosrt_alts_sched_thd_param_set>:
  405730:	4c 89 e8             	mov    rax,r13
  405733:	48 b9 42 57 40 00 00 	movabs rcx,0x405742
  40573a:	00 00 00 
  40573d:	e9 6e 51 00 00       	jmp    40a8b0 <custom_acquire_stack>
  405742:	52                   	push   rdx
  405743:	50                   	push   rax
  405744:	55                   	push   rbp
  405745:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405749:	48 31 ed             	xor    rbp,rbp
  40574c:	51                   	push   rcx
  40574d:	51                   	push   rcx
  40574e:	4c 89 c1             	mov    rcx,r8
  405751:	4c 89 ca             	mov    rdx,r9
  405754:	e8 57 c4 ff ff       	call   401bb0 <sched_thd_param_set>
  405759:	59                   	pop    rcx
  40575a:	c3                   	ret    
  40575b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000405760 <__cosrt_s_sched_thd_exit>:
  405760:	48 b9 6f 57 40 00 00 	movabs rcx,0x40576f
  405767:	00 00 00 
  40576a:	e9 41 51 00 00       	jmp    40a8b0 <custom_acquire_stack>
  40576f:	52                   	push   rdx
  405770:	50                   	push   rax
  405771:	55                   	push   rbp
  405772:	4c 89 e1             	mov    rcx,r12
  405775:	48 31 ed             	xor    rbp,rbp
  405778:	48 89 f8             	mov    rax,rdi
  40577b:	48 89 df             	mov    rdi,rbx
  40577e:	48 89 c2             	mov    rdx,rax
  405781:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405785:	e8 86 c4 ff ff       	call   401c10 <sched_thd_exit>
  40578a:	49 89 c0             	mov    r8,rax
  40578d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  405794:	0f 05                	syscall 
  405796:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40579d:	00 00 00 

00000000004057a0 <__cosrt_alts_sched_thd_exit>:
  4057a0:	4c 89 e8             	mov    rax,r13
  4057a3:	48 b9 b2 57 40 00 00 	movabs rcx,0x4057b2
  4057aa:	00 00 00 
  4057ad:	e9 fe 50 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4057b2:	52                   	push   rdx
  4057b3:	50                   	push   rax
  4057b4:	55                   	push   rbp
  4057b5:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4057b9:	48 31 ed             	xor    rbp,rbp
  4057bc:	51                   	push   rcx
  4057bd:	51                   	push   rcx
  4057be:	4c 89 c1             	mov    rcx,r8
  4057c1:	4c 89 ca             	mov    rdx,r9
  4057c4:	e8 47 c4 ff ff       	call   401c10 <sched_thd_exit>
  4057c9:	59                   	pop    rcx
  4057ca:	c3                   	ret    
  4057cb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000004057d0 <__cosrt_s_sched_thd_delete>:
  4057d0:	48 b9 df 57 40 00 00 	movabs rcx,0x4057df
  4057d7:	00 00 00 
  4057da:	e9 d1 50 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4057df:	52                   	push   rdx
  4057e0:	50                   	push   rax
  4057e1:	55                   	push   rbp
  4057e2:	4c 89 e1             	mov    rcx,r12
  4057e5:	48 31 ed             	xor    rbp,rbp
  4057e8:	48 89 f8             	mov    rax,rdi
  4057eb:	48 89 df             	mov    rdi,rbx
  4057ee:	48 89 c2             	mov    rdx,rax
  4057f1:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4057f5:	e8 06 c4 ff ff       	call   401c00 <sched_thd_delete>
  4057fa:	49 89 c0             	mov    r8,rax
  4057fd:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  405804:	0f 05                	syscall 
  405806:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40580d:	00 00 00 

0000000000405810 <__cosrt_alts_sched_thd_delete>:
  405810:	4c 89 e8             	mov    rax,r13
  405813:	48 b9 22 58 40 00 00 	movabs rcx,0x405822
  40581a:	00 00 00 
  40581d:	e9 8e 50 00 00       	jmp    40a8b0 <custom_acquire_stack>
  405822:	52                   	push   rdx
  405823:	50                   	push   rax
  405824:	55                   	push   rbp
  405825:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405829:	48 31 ed             	xor    rbp,rbp
  40582c:	51                   	push   rcx
  40582d:	51                   	push   rcx
  40582e:	4c 89 c1             	mov    rcx,r8
  405831:	4c 89 ca             	mov    rdx,r9
  405834:	e8 c7 c3 ff ff       	call   401c00 <sched_thd_delete>
  405839:	59                   	pop    rcx
  40583a:	c3                   	ret    
  40583b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000405840 <__cosrt_s_sched_set_tls>:
  405840:	48 b9 4f 58 40 00 00 	movabs rcx,0x40584f
  405847:	00 00 00 
  40584a:	e9 61 50 00 00       	jmp    40a8b0 <custom_acquire_stack>
  40584f:	52                   	push   rdx
  405850:	50                   	push   rax
  405851:	55                   	push   rbp
  405852:	4c 89 e1             	mov    rcx,r12
  405855:	48 31 ed             	xor    rbp,rbp
  405858:	48 89 f8             	mov    rax,rdi
  40585b:	48 89 df             	mov    rdi,rbx
  40585e:	48 89 c2             	mov    rdx,rax
  405861:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405865:	e8 d6 ca ff ff       	call   402340 <sched_set_tls>
  40586a:	49 89 c0             	mov    r8,rax
  40586d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  405874:	0f 05                	syscall 
  405876:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40587d:	00 00 00 

0000000000405880 <__cosrt_alts_sched_set_tls>:
  405880:	4c 89 e8             	mov    rax,r13
  405883:	48 b9 92 58 40 00 00 	movabs rcx,0x405892
  40588a:	00 00 00 
  40588d:	e9 1e 50 00 00       	jmp    40a8b0 <custom_acquire_stack>
  405892:	52                   	push   rdx
  405893:	50                   	push   rax
  405894:	55                   	push   rbp
  405895:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405899:	48 31 ed             	xor    rbp,rbp
  40589c:	51                   	push   rcx
  40589d:	51                   	push   rcx
  40589e:	4c 89 c1             	mov    rcx,r8
  4058a1:	4c 89 ca             	mov    rdx,r9
  4058a4:	e8 97 ca ff ff       	call   402340 <sched_set_tls>
  4058a9:	59                   	pop    rcx
  4058aa:	c3                   	ret    
  4058ab:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000004058b0 <__cosrt_s_cstub_sched_thd_block_timeout>:
#include <cos_stubs.h>
#include <sched.h>

COS_SERVER_3RET_STUB(int, sched_thd_block_timeout)
{
  4058b0:	f3 0f 1e fa          	endbr64 
  4058b4:	55                   	push   rbp
  4058b5:	48 89 e5             	mov    rbp,rsp
  4058b8:	41 54                	push   r12
  4058ba:	4d 89 c4             	mov    r12,r8
  4058bd:	53                   	push   rbx
  4058be:	4c 89 cb             	mov    rbx,r9
	cycles_t elapsed = 0, abs_timeout;

	/* works on armv7a too, as we control where hi and lo are passed for timeout */
	COS_ARG_WORDS_TO_DWORD(p1, p2, abs_timeout);
	elapsed = sched_thd_block_timeout((thdid_t)p0, abs_timeout);
  4058c1:	e8 7a da ff ff       	call   403340 <sched_thd_block_timeout>
	*r1 = (elapsed >> 32);
  4058c6:	48 89 c2             	mov    rdx,rax
	*r2 = (elapsed << 32) >> 32;
  4058c9:	83 e0 ff             	and    eax,0xffffffff
	*r1 = (elapsed >> 32);
  4058cc:	48 c1 ea 20          	shr    rdx,0x20
  4058d0:	49 89 14 24          	mov    QWORD PTR [r12],rdx
	*r2 = (elapsed << 32) >> 32;
  4058d4:	48 89 03             	mov    QWORD PTR [rbx],rax

	return 0;
}
  4058d7:	5b                   	pop    rbx
  4058d8:	31 c0                	xor    eax,eax
  4058da:	41 5c                	pop    r12
  4058dc:	5d                   	pop    rbp
  4058dd:	c3                   	ret    
  4058de:	66 90                	xchg   ax,ax

00000000004058e0 <__cosrt_s_cstub_sched_aep_create_closure>:

COS_SERVER_3RET_STUB(thdid_t, sched_aep_create_closure)
{
  4058e0:	f3 0f 1e fa          	endbr64 
  4058e4:	55                   	push   rbp
  4058e5:	48 89 f8             	mov    rax,rdi
  4058e8:	48 89 d1             	mov    rcx,rdx
	u32_t               ipimax = (p1 << 16) >> 16;
	cos_channelkey_t    key    = (p1 >> 16);
	arcvcap_t rcv;
	thdid_t ret;

	ret = sched_aep_create_closure(idx, owntc, key, ipiwin, ipimax, &rcv);
  4058eb:	89 f2                	mov    edx,esi
  4058ed:	c1 ea 10             	shr    edx,0x10
	thdclosure_index_t  idx    = (p0 >> 16);
  4058f0:	48 c1 ef 10          	shr    rdi,0x10
{
  4058f4:	48 89 e5             	mov    rbp,rsp
  4058f7:	41 54                	push   r12
  4058f9:	4d 89 c4             	mov    r12,r8
	ret = sched_aep_create_closure(idx, owntc, key, ipiwin, ipimax, &rcv);
  4058fc:	41 89 f0             	mov    r8d,esi
{
  4058ff:	53                   	push   rbx
	ret = sched_aep_create_closure(idx, owntc, key, ipiwin, ipimax, &rcv);
  405900:	89 c6                	mov    esi,eax
{
  405902:	4c 89 cb             	mov    rbx,r9
	ret = sched_aep_create_closure(idx, owntc, key, ipiwin, ipimax, &rcv);
  405905:	4c 8d 4d e8          	lea    r9,[rbp-0x18]
{
  405909:	48 83 ec 10          	sub    rsp,0x10
	ret = sched_aep_create_closure(idx, owntc, key, ipiwin, ipimax, &rcv);
  40590d:	e8 fe ea ff ff       	call   404410 <sched_aep_create_closure>

	*r1 = rcv;
  405912:	48 8b 55 e8          	mov    rdx,QWORD PTR [rbp-0x18]
  405916:	49 89 14 24          	mov    QWORD PTR [r12],rdx
	*r2 = 0;
  40591a:	48 c7 03 00 00 00 00 	mov    QWORD PTR [rbx],0x0

	return ret;
}
  405921:	48 83 c4 10          	add    rsp,0x10
  405925:	5b                   	pop    rbx
  405926:	41 5c                	pop    r12
  405928:	5d                   	pop    rbp
  405929:	c3                   	ret    
  40592a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000405930 <__cosrt_s_init_done>:
  405930:	48 b9 3f 59 40 00 00 	movabs rcx,0x40593f
  405937:	00 00 00 
  40593a:	e9 71 4f 00 00       	jmp    40a8b0 <custom_acquire_stack>
  40593f:	52                   	push   rdx
  405940:	50                   	push   rax
  405941:	55                   	push   rbp
  405942:	4c 89 e1             	mov    rcx,r12
  405945:	48 31 ed             	xor    rbp,rbp
  405948:	48 89 f8             	mov    rax,rdi
  40594b:	48 89 df             	mov    rdi,rbx
  40594e:	48 89 c2             	mov    rdx,rax
  405951:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405955:	e8 a6 aa ff ff       	call   400400 <init_done>
  40595a:	49 89 c0             	mov    r8,rax
  40595d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  405964:	0f 05                	syscall 
  405966:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40596d:	00 00 00 

0000000000405970 <__cosrt_alts_init_done>:
  405970:	4c 89 e8             	mov    rax,r13
  405973:	48 b9 82 59 40 00 00 	movabs rcx,0x405982
  40597a:	00 00 00 
  40597d:	e9 2e 4f 00 00       	jmp    40a8b0 <custom_acquire_stack>
  405982:	52                   	push   rdx
  405983:	50                   	push   rax
  405984:	55                   	push   rbp
  405985:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405989:	48 31 ed             	xor    rbp,rbp
  40598c:	51                   	push   rcx
  40598d:	51                   	push   rcx
  40598e:	4c 89 c1             	mov    rcx,r8
  405991:	4c 89 ca             	mov    rdx,r9
  405994:	e8 67 aa ff ff       	call   400400 <init_done>
  405999:	59                   	pop    rcx
  40599a:	c3                   	ret    
  40599b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000004059a0 <__cosrt_s_init_exit>:
  4059a0:	48 b9 af 59 40 00 00 	movabs rcx,0x4059af
  4059a7:	00 00 00 
  4059aa:	e9 01 4f 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4059af:	52                   	push   rdx
  4059b0:	50                   	push   rax
  4059b1:	55                   	push   rbp
  4059b2:	4c 89 e1             	mov    rcx,r12
  4059b5:	48 31 ed             	xor    rbp,rbp
  4059b8:	48 89 f8             	mov    rax,rdi
  4059bb:	48 89 df             	mov    rdi,rbx
  4059be:	48 89 c2             	mov    rdx,rax
  4059c1:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4059c5:	e8 56 ab ff ff       	call   400520 <init_exit>
  4059ca:	49 89 c0             	mov    r8,rax
  4059cd:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  4059d4:	0f 05                	syscall 
  4059d6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4059dd:	00 00 00 

00000000004059e0 <__cosrt_alts_init_exit>:
  4059e0:	4c 89 e8             	mov    rax,r13
  4059e3:	48 b9 f2 59 40 00 00 	movabs rcx,0x4059f2
  4059ea:	00 00 00 
  4059ed:	e9 be 4e 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4059f2:	52                   	push   rdx
  4059f3:	50                   	push   rax
  4059f4:	55                   	push   rbp
  4059f5:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4059f9:	48 31 ed             	xor    rbp,rbp
  4059fc:	51                   	push   rcx
  4059fd:	51                   	push   rcx
  4059fe:	4c 89 c1             	mov    rcx,r8
  405a01:	4c 89 ca             	mov    rdx,r9
  405a04:	e8 17 ab ff ff       	call   400520 <init_exit>
  405a09:	59                   	pop    rcx
  405a0a:	c3                   	ret    
  405a0b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000405a10 <__cosrt_c_init_done>:
 * to serialize and deserialize arguments. In contrast, this code
 * doesn't have a corresponding client-side stub as it only
 * orchestrates the coordination with the await_init function.
 */
COS_CLIENT_STUB(int, init_done, int parallel_init, init_main_t cont)
{
  405a10:	f3 0f 1e fa          	endbr64 
  405a14:	55                   	push   rbp
	COS_CLIENT_INVCAP;
	int ret;

	ret = cos_sinv(uc, parallel_init, cont, 0, 0);
  405a15:	89 f6                	mov    esi,esi
  405a17:	4c 63 d7             	movsxd r10,edi
{
  405a1a:	48 89 e5             	mov    rbp,rsp
  405a1d:	41 55                	push   r13
  405a1f:	41 54                	push   r12
  405a21:	53                   	push   rbx
  405a22:	48 83 ec 28          	sub    rsp,0x28
  405a26:	4c 8b 68 10          	mov    r13,QWORD PTR [rax+0x10]
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, &r1, &r2);
  405a2a:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  405a2e:	4d 85 ed             	test   r13,r13
  405a31:	74 2d                	je     405a60 <__cosrt_c_init_done+0x50>
  405a33:	4c 8d 4d d0          	lea    r9,[rbp-0x30]
  405a37:	4c 8d 45 c8          	lea    r8,[rbp-0x38]
  405a3b:	31 c9                	xor    ecx,ecx
  405a3d:	31 d2                	xor    edx,edx
  405a3f:	4c 89 d7             	mov    rdi,r10
  405a42:	41 ff d5             	call   r13
	ps_store(&awaiting_init, 0);
  405a45:	c7 05 b5 e5 01 00 00 	mov    DWORD PTR [rip+0x1e5b5],0x0        # 424004 <awaiting_init>
  405a4c:	00 00 00 

	return ret;
}
  405a4f:	48 83 c4 28          	add    rsp,0x28
  405a53:	5b                   	pop    rbx
  405a54:	41 5c                	pop    r12
  405a56:	41 5d                	pop    r13
  405a58:	5d                   	pop    rbp
  405a59:	c3                   	ret    
  405a5a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  405a60:	8d 42 01             	lea    eax,[rdx+0x1]
	__asm__ __volatile__(
  405a63:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  405a67:	4c 89 d3             	mov    rbx,r10
  405a6a:	4c 89 ef             	mov    rdi,r13
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  405a6d:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  405a70:	4c 89 ea             	mov    rdx,r13
  405a73:	48 89 29             	mov    QWORD PTR [rcx],rbp
  405a76:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  405a7a:	48 89 cd             	mov    rbp,rcx
  405a7d:	49 b8 98 5a 40 00 00 	movabs r8,0x405a98
  405a84:	00 00 00 
  405a87:	0f 05                	syscall 
  405a89:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  405a90:	eb 0d                	jmp    405a9f <__cosrt_c_init_done+0x8f>
  405a92:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  405a98:	b9 00 00 00 00       	mov    ecx,0x0
  405a9d:	eb 05                	jmp    405aa4 <__cosrt_c_init_done+0x94>
  405a9f:	b9 01 00 00 00       	mov    ecx,0x1
  405aa4:	5d                   	pop    rbp
  405aa5:	5c                   	pop    rsp
	return call_cap_op(uc->cap_no, 0, arg1, arg2, arg3, arg4);
  405aa6:	eb 9d                	jmp    405a45 <__cosrt_c_init_done+0x35>
  405aa8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  405aaf:	00 

0000000000405ab0 <__cosrt_extern_init_parallel_await_init>:
 * This function is implemented as a library compiled directly into
 * the client component.
 */
void
COS_STUB_LIBFN(init_parallel_await_init)(void)
{
  405ab0:	f3 0f 1e fa          	endbr64 
  405ab4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	while (ps_load(&awaiting_init)) ;
  405ab8:	8b 05 46 e5 01 00    	mov    eax,DWORD PTR [rip+0x1e546]        # 424004 <awaiting_init>
  405abe:	85 c0                	test   eax,eax
  405ac0:	75 f6                	jne    405ab8 <__cosrt_extern_init_parallel_await_init+0x8>
}
  405ac2:	c3                   	ret    
  405ac3:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  405aca:	00 00 00 
  405acd:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000405ad0 <__cosrt_extern_init_done>:
  405ad0:	48 b8 cc c0 45 00 00 	movabs rax,0x45c0cc
  405ad7:	00 00 00 
  405ada:	ff 10                	call   QWORD PTR [rax]
  405adc:	c3                   	ret    
  405add:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000405ae0 <__cosrt_fast_callgate_init_done>:
  405ae0:	55                   	push   rbp
  405ae1:	41 55                	push   r13
  405ae3:	41 56                	push   r14
  405ae5:	41 57                	push   r15
  405ae7:	49 89 c8             	mov    r8,rcx
  405aea:	49 89 d1             	mov    r9,rdx
  405aed:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  405af4:	be ad de 
  405af7:	0f 01 f9             	rdtscp 
  405afa:	48 89 c8             	mov    rax,rcx
  405afd:	48 25 ff 0f 00 00    	and    rax,0xfff
  405b03:	48 89 e2             	mov    rdx,rsp
  405b06:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  405b0d:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  405b14:	00 
  405b15:	48 c1 e0 10          	shl    rax,0x10
  405b19:	49 09 c5             	or     r13,rax
  405b1c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  405b23:	7f 00 00 
  405b26:	4c 89 e8             	mov    rax,r13
  405b29:	48 25 ff ff 00 00    	and    rax,0xffff
  405b2f:	48 c1 e0 08          	shl    rax,0x8
  405b33:	49 01 c6             	add    r14,rax
  405b36:	b9 01 00 00 00       	mov    ecx,0x1
  405b3b:	01 c9                	add    ecx,ecx
  405b3d:	b8 03 00 00 00       	mov    eax,0x3
  405b42:	d3 e0                	shl    eax,cl
  405b44:	f7 d0                	not    eax
  405b46:	83 e0 fc             	and    eax,0xfffffffc
  405b49:	48 31 c9             	xor    rcx,rcx
  405b4c:	48 31 d2             	xor    rdx,rdx
  405b4f:	0f 01 ef             	wrpkru 
  405b52:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  405b55:	48 83 c2 01          	add    rdx,0x1
  405b59:	48 c1 e2 04          	shl    rdx,0x4
  405b5d:	4c 01 f2             	add    rdx,r14
  405b60:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  405b67:	45 23 01 
  405b6a:	48 89 02             	mov    QWORD PTR [rdx],rax
  405b6d:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  405b71:	49 8b 06             	mov    rax,QWORD PTR [r14]
  405b74:	48 83 c0 01          	add    rax,0x1
  405b78:	49 89 06             	mov    QWORD PTR [r14],rax
  405b7b:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  405b80:	01 c9                	add    ecx,ecx
  405b82:	b8 03 00 00 00       	mov    eax,0x3
  405b87:	d3 e0                	shl    eax,cl
  405b89:	f7 d0                	not    eax
  405b8b:	83 e0 fc             	and    eax,0xfffffffc
  405b8e:	48 31 c9             	xor    rcx,rcx
  405b91:	48 31 d2             	xor    rdx,rdx
  405b94:	0f 01 ef             	wrpkru 
  405b97:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  405b9e:	45 23 01 
  405ba1:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  405ba8:	be ad de 
  405bab:	49 39 c7             	cmp    r15,rax
  405bae:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  405bb5:	12 12 12 
  405bb8:	48 b9 c4 5b 40 00 00 	movabs rcx,0x405bc4
  405bbf:	00 00 00 
  405bc2:	ff e0                	jmp    rax

0000000000405bc4 <srv_call_ret_init_done>:
  405bc4:	49 89 c0             	mov    r8,rax
  405bc7:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  405bce:	be ad de 
  405bd1:	48 89 e2             	mov    rdx,rsp
  405bd4:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  405bdb:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  405be2:	00 
  405be3:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  405bea:	7f 00 00 
  405bed:	4c 89 e8             	mov    rax,r13
  405bf0:	48 25 ff ff 00 00    	and    rax,0xffff
  405bf6:	48 c1 e0 08          	shl    rax,0x8
  405bfa:	49 01 c6             	add    r14,rax
  405bfd:	b9 01 00 00 00       	mov    ecx,0x1
  405c02:	01 c9                	add    ecx,ecx
  405c04:	b8 03 00 00 00       	mov    eax,0x3
  405c09:	d3 e0                	shl    eax,cl
  405c0b:	f7 d0                	not    eax
  405c0d:	83 e0 fc             	and    eax,0xfffffffc
  405c10:	48 31 c9             	xor    rcx,rcx
  405c13:	48 31 d2             	xor    rdx,rdx
  405c16:	0f 01 ef             	wrpkru 
  405c19:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  405c1c:	48 c1 e2 04          	shl    rdx,0x4
  405c20:	4c 01 f2             	add    rdx,r14
  405c23:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  405c27:	49 8b 06             	mov    rax,QWORD PTR [r14]
  405c2a:	48 83 e8 01          	sub    rax,0x1
  405c2e:	49 89 06             	mov    QWORD PTR [r14],rax
  405c31:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  405c36:	01 c9                	add    ecx,ecx
  405c38:	b8 03 00 00 00       	mov    eax,0x3
  405c3d:	d3 e0                	shl    eax,cl
  405c3f:	f7 d0                	not    eax
  405c41:	83 e0 fc             	and    eax,0xfffffffc
  405c44:	48 31 c9             	xor    rcx,rcx
  405c47:	48 31 d2             	xor    rdx,rdx
  405c4a:	0f 01 ef             	wrpkru 
  405c4d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  405c54:	be ad de 
  405c57:	49 39 c7             	cmp    r15,rax
  405c5a:	4c 89 c0             	mov    rax,r8
  405c5d:	41 5f                	pop    r15
  405c5f:	41 5e                	pop    r14
  405c61:	41 5d                	pop    r13
  405c63:	5d                   	pop    rbp
  405c64:	c3                   	ret    
  405c65:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  405c6c:	00 00 00 00 

0000000000405c70 <__cosrt_extern_init_exit>:
  405c70:	48 b8 e4 c0 45 00 00 	movabs rax,0x45c0e4
  405c77:	00 00 00 
  405c7a:	ff 10                	call   QWORD PTR [rax]
  405c7c:	c3                   	ret    
  405c7d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000405c80 <__cosrt_fast_callgate_init_exit>:
  405c80:	55                   	push   rbp
  405c81:	41 55                	push   r13
  405c83:	41 56                	push   r14
  405c85:	41 57                	push   r15
  405c87:	49 89 c8             	mov    r8,rcx
  405c8a:	49 89 d1             	mov    r9,rdx
  405c8d:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  405c94:	be ad de 
  405c97:	0f 01 f9             	rdtscp 
  405c9a:	48 89 c8             	mov    rax,rcx
  405c9d:	48 25 ff 0f 00 00    	and    rax,0xfff
  405ca3:	48 89 e2             	mov    rdx,rsp
  405ca6:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  405cad:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  405cb4:	00 
  405cb5:	48 c1 e0 10          	shl    rax,0x10
  405cb9:	49 09 c5             	or     r13,rax
  405cbc:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  405cc3:	7f 00 00 
  405cc6:	4c 89 e8             	mov    rax,r13
  405cc9:	48 25 ff ff 00 00    	and    rax,0xffff
  405ccf:	48 c1 e0 08          	shl    rax,0x8
  405cd3:	49 01 c6             	add    r14,rax
  405cd6:	b9 01 00 00 00       	mov    ecx,0x1
  405cdb:	01 c9                	add    ecx,ecx
  405cdd:	b8 03 00 00 00       	mov    eax,0x3
  405ce2:	d3 e0                	shl    eax,cl
  405ce4:	f7 d0                	not    eax
  405ce6:	83 e0 fc             	and    eax,0xfffffffc
  405ce9:	48 31 c9             	xor    rcx,rcx
  405cec:	48 31 d2             	xor    rdx,rdx
  405cef:	0f 01 ef             	wrpkru 
  405cf2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  405cf5:	48 83 c2 01          	add    rdx,0x1
  405cf9:	48 c1 e2 04          	shl    rdx,0x4
  405cfd:	4c 01 f2             	add    rdx,r14
  405d00:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  405d07:	45 23 01 
  405d0a:	48 89 02             	mov    QWORD PTR [rdx],rax
  405d0d:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  405d11:	49 8b 06             	mov    rax,QWORD PTR [r14]
  405d14:	48 83 c0 01          	add    rax,0x1
  405d18:	49 89 06             	mov    QWORD PTR [r14],rax
  405d1b:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  405d20:	01 c9                	add    ecx,ecx
  405d22:	b8 03 00 00 00       	mov    eax,0x3
  405d27:	d3 e0                	shl    eax,cl
  405d29:	f7 d0                	not    eax
  405d2b:	83 e0 fc             	and    eax,0xfffffffc
  405d2e:	48 31 c9             	xor    rcx,rcx
  405d31:	48 31 d2             	xor    rdx,rdx
  405d34:	0f 01 ef             	wrpkru 
  405d37:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  405d3e:	45 23 01 
  405d41:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  405d48:	be ad de 
  405d4b:	49 39 c7             	cmp    r15,rax
  405d4e:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  405d55:	12 12 12 
  405d58:	48 b9 64 5d 40 00 00 	movabs rcx,0x405d64
  405d5f:	00 00 00 
  405d62:	ff e0                	jmp    rax

0000000000405d64 <srv_call_ret_init_exit>:
  405d64:	49 89 c0             	mov    r8,rax
  405d67:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  405d6e:	be ad de 
  405d71:	48 89 e2             	mov    rdx,rsp
  405d74:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  405d7b:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  405d82:	00 
  405d83:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  405d8a:	7f 00 00 
  405d8d:	4c 89 e8             	mov    rax,r13
  405d90:	48 25 ff ff 00 00    	and    rax,0xffff
  405d96:	48 c1 e0 08          	shl    rax,0x8
  405d9a:	49 01 c6             	add    r14,rax
  405d9d:	b9 01 00 00 00       	mov    ecx,0x1
  405da2:	01 c9                	add    ecx,ecx
  405da4:	b8 03 00 00 00       	mov    eax,0x3
  405da9:	d3 e0                	shl    eax,cl
  405dab:	f7 d0                	not    eax
  405dad:	83 e0 fc             	and    eax,0xfffffffc
  405db0:	48 31 c9             	xor    rcx,rcx
  405db3:	48 31 d2             	xor    rdx,rdx
  405db6:	0f 01 ef             	wrpkru 
  405db9:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  405dbc:	48 c1 e2 04          	shl    rdx,0x4
  405dc0:	4c 01 f2             	add    rdx,r14
  405dc3:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  405dc7:	49 8b 06             	mov    rax,QWORD PTR [r14]
  405dca:	48 83 e8 01          	sub    rax,0x1
  405dce:	49 89 06             	mov    QWORD PTR [r14],rax
  405dd1:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  405dd6:	01 c9                	add    ecx,ecx
  405dd8:	b8 03 00 00 00       	mov    eax,0x3
  405ddd:	d3 e0                	shl    eax,cl
  405ddf:	f7 d0                	not    eax
  405de1:	83 e0 fc             	and    eax,0xfffffffc
  405de4:	48 31 c9             	xor    rcx,rcx
  405de7:	48 31 d2             	xor    rdx,rdx
  405dea:	0f 01 ef             	wrpkru 
  405ded:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  405df4:	be ad de 
  405df7:	49 39 c7             	cmp    r15,rax
  405dfa:	4c 89 c0             	mov    rax,r8
  405dfd:	41 5f                	pop    r15
  405dff:	41 5e                	pop    r14
  405e01:	41 5d                	pop    r13
  405e03:	5d                   	pop    rbp
  405e04:	c3                   	ret    
  405e05:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  405e0c:	00 00 00 
  405e0f:	90                   	nop

0000000000405e10 <__cosrt_c_capmgr_rcv_create>:
#include <cos_thd_init.h>
#include <cos_defkernel_api.h>
#include <cos_stubs.h>

COS_CLIENT_STUB(arcvcap_t, capmgr_rcv_create, thdclosure_index_t idx, int flags, asndcap_t *asnd, thdcap_t *thdcap, thdid_t *tid)
{
  405e10:	f3 0f 1e fa          	endbr64 
  405e14:	55                   	push   rbp
	COS_CLIENT_INVCAP;
	word_t thdret, asnd_ret;
	arcvcap_t ret;

	ret = cos_sinv_2rets(uc, idx, flags, 0, 0, &asnd_ret, &thdret);
  405e15:	48 63 f6             	movsxd rsi,esi
{
  405e18:	48 89 e5             	mov    rbp,rsp
  405e1b:	41 57                	push   r15
  405e1d:	41 56                	push   r14
  405e1f:	49 89 d6             	mov    r14,rdx
  405e22:	41 55                	push   r13
  405e24:	49 89 cd             	mov    r13,rcx
  405e27:	41 54                	push   r12
  405e29:	53                   	push   rbx
	ret = cos_sinv_2rets(uc, idx, flags, 0, 0, &asnd_ret, &thdret);
  405e2a:	48 63 df             	movsxd rbx,edi
{
  405e2d:	48 83 ec 38          	sub    rsp,0x38
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  405e31:	4c 8b 78 10          	mov    r15,QWORD PTR [rax+0x10]
  405e35:	4c 89 45 a8          	mov    QWORD PTR [rbp-0x58],r8
  405e39:	4d 85 ff             	test   r15,r15
  405e3c:	74 4a                	je     405e88 <__cosrt_c_capmgr_rcv_create+0x78>
  405e3e:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  405e42:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  405e46:	31 c9                	xor    ecx,ecx
  405e48:	31 d2                	xor    edx,edx
  405e4a:	48 89 df             	mov    rdi,rbx
  405e4d:	41 ff d7             	call   r15
	*asnd   = asnd_ret;
  405e50:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
	*thdcap = (thdcap_t)thdret >> 16;
	*tid    = (thdid_t)thdret & 0xFFFF;
  405e54:	48 8b 5d a8          	mov    rbx,QWORD PTR [rbp-0x58]
	ret = cos_sinv_2rets(uc, idx, flags, 0, 0, &asnd_ret, &thdret);
  405e58:	48 98                	cdqe   
	*asnd   = asnd_ret;
  405e5a:	49 89 16             	mov    QWORD PTR [r14],rdx
	*thdcap = (thdcap_t)thdret >> 16;
  405e5d:	48 8b 55 b0          	mov    rdx,QWORD PTR [rbp-0x50]
  405e61:	48 89 d1             	mov    rcx,rdx
	*tid    = (thdid_t)thdret & 0xFFFF;
  405e64:	81 e2 ff ff 00 00    	and    edx,0xffff
	*thdcap = (thdcap_t)thdret >> 16;
  405e6a:	48 c1 e9 10          	shr    rcx,0x10
  405e6e:	49 89 4d 00          	mov    QWORD PTR [r13+0x0],rcx
	*tid    = (thdid_t)thdret & 0xFFFF;
  405e72:	48 89 13             	mov    QWORD PTR [rbx],rdx

	return ret;
}
  405e75:	48 83 c4 38          	add    rsp,0x38
  405e79:	5b                   	pop    rbx
  405e7a:	41 5c                	pop    r12
  405e7c:	41 5d                	pop    r13
  405e7e:	41 5e                	pop    r14
  405e80:	41 5f                	pop    r15
  405e82:	5d                   	pop    rbp
  405e83:	c3                   	ret    
  405e84:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  405e88:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  405e8c:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  405e90:	4c 89 ff             	mov    rdi,r15
  405e93:	4c 89 fa             	mov    rdx,r15
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  405e96:	83 c0 01             	add    eax,0x1
  405e99:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  405e9c:	48 89 29             	mov    QWORD PTR [rcx],rbp
  405e9f:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  405ea3:	48 89 cd             	mov    rbp,rcx
  405ea6:	49 b8 c0 5e 40 00 00 	movabs r8,0x405ec0
  405ead:	00 00 00 
  405eb0:	0f 05                	syscall 
  405eb2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  405eb8:	eb 0f                	jmp    405ec9 <__cosrt_c_capmgr_rcv_create+0xb9>
  405eba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  405ec0:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  405ec7:	eb 07                	jmp    405ed0 <__cosrt_c_capmgr_rcv_create+0xc0>
  405ec9:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  405ed0:	5d                   	pop    rbp
  405ed1:	5c                   	pop    rsp
  405ed2:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
  405ed6:	48 89 7d b0          	mov    QWORD PTR [rbp-0x50],rdi
	return ret;
  405eda:	e9 71 ff ff ff       	jmp    405e50 <__cosrt_c_capmgr_rcv_create+0x40>
  405edf:	90                   	nop

0000000000405ee0 <__cosrt_c_capmgr_shared_kernel_page_create>:

COS_CLIENT_STUB(vaddr_t, capmgr_shared_kernel_page_create, vaddr_t *resource)
{
  405ee0:	f3 0f 1e fa          	endbr64 
  405ee4:	55                   	push   rbp
  405ee5:	48 89 e5             	mov    rbp,rsp
  405ee8:	41 55                	push   r13
  405eea:	49 89 fd             	mov    r13,rdi
  405eed:	41 54                	push   r12
  405eef:	53                   	push   rbx
  405ef0:	48 83 ec 28          	sub    rsp,0x28
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  405ef4:	48 8b 58 10          	mov    rbx,QWORD PTR [rax+0x10]
  405ef8:	48 85 db             	test   rbx,rbx
  405efb:	74 2b                	je     405f28 <__cosrt_c_capmgr_shared_kernel_page_create+0x48>
  405efd:	4c 8d 4d c8          	lea    r9,[rbp-0x38]
  405f01:	4c 8d 45 c0          	lea    r8,[rbp-0x40]
  405f05:	31 c9                	xor    ecx,ecx
  405f07:	31 d2                	xor    edx,edx
  405f09:	31 f6                	xor    esi,esi
  405f0b:	31 ff                	xor    edi,edi
  405f0d:	ff d3                	call   rbx
	COS_CLIENT_INVCAP;
	word_t ret1, ret2;
	vaddr_t ret;

	ret = cos_sinv_2rets(uc, 0, 0, 0, 0, &ret1, &ret2);
	*resource   = ret1;
  405f0f:	48 8b 55 c0          	mov    rdx,QWORD PTR [rbp-0x40]
	ret = cos_sinv_2rets(uc, 0, 0, 0, 0, &ret1, &ret2);
  405f13:	48 98                	cdqe   
	*resource   = ret1;
  405f15:	49 89 55 00          	mov    QWORD PTR [r13+0x0],rdx

	return ret;
}
  405f19:	48 83 c4 28          	add    rsp,0x28
  405f1d:	5b                   	pop    rbx
  405f1e:	41 5c                	pop    r12
  405f20:	41 5d                	pop    r13
  405f22:	5d                   	pop    rbp
  405f23:	c3                   	ret    
  405f24:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  405f28:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  405f2c:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  405f30:	48 89 de             	mov    rsi,rbx
  405f33:	48 89 df             	mov    rdi,rbx
  405f36:	48 89 da             	mov    rdx,rbx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  405f39:	83 c0 01             	add    eax,0x1
  405f3c:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  405f3f:	48 89 29             	mov    QWORD PTR [rcx],rbp
  405f42:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  405f46:	48 89 cd             	mov    rbp,rcx
  405f49:	49 b8 60 5f 40 00 00 	movabs r8,0x405f60
  405f50:	00 00 00 
  405f53:	0f 05                	syscall 
  405f55:	0f 1f 00             	nop    DWORD PTR [rax]
  405f58:	eb 0f                	jmp    405f69 <__cosrt_c_capmgr_shared_kernel_page_create+0x89>
  405f5a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  405f60:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  405f67:	eb 07                	jmp    405f70 <__cosrt_c_capmgr_shared_kernel_page_create+0x90>
  405f69:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  405f70:	5d                   	pop    rbp
  405f71:	5c                   	pop    rsp
  405f72:	48 89 75 c0          	mov    QWORD PTR [rbp-0x40],rsi
	return ret;
  405f76:	eb 97                	jmp    405f0f <__cosrt_c_capmgr_shared_kernel_page_create+0x2f>
  405f78:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  405f7f:	00 

0000000000405f80 <__cosrt_c_capmgr_vm_lapic_create>:
  405f80:	f3 0f 1e fa          	endbr64 
  405f84:	55                   	push   rbp
  405f85:	48 89 e5             	mov    rbp,rsp
  405f88:	41 55                	push   r13
  405f8a:	49 89 fd             	mov    r13,rdi
  405f8d:	41 54                	push   r12
  405f8f:	53                   	push   rbx
  405f90:	48 83 ec 28          	sub    rsp,0x28
  405f94:	48 8b 58 10          	mov    rbx,QWORD PTR [rax+0x10]
  405f98:	48 85 db             	test   rbx,rbx
  405f9b:	74 2b                	je     405fc8 <__cosrt_c_capmgr_vm_lapic_create+0x48>
  405f9d:	4c 8d 4d c8          	lea    r9,[rbp-0x38]
  405fa1:	4c 8d 45 c0          	lea    r8,[rbp-0x40]
  405fa5:	31 c9                	xor    ecx,ecx
  405fa7:	31 d2                	xor    edx,edx
  405fa9:	31 f6                	xor    esi,esi
  405fab:	31 ff                	xor    edi,edi
  405fad:	ff d3                	call   rbx
  405faf:	48 8b 55 c0          	mov    rdx,QWORD PTR [rbp-0x40]
  405fb3:	48 98                	cdqe   
  405fb5:	49 89 55 00          	mov    QWORD PTR [r13+0x0],rdx
  405fb9:	48 83 c4 28          	add    rsp,0x28
  405fbd:	5b                   	pop    rbx
  405fbe:	41 5c                	pop    r12
  405fc0:	41 5d                	pop    r13
  405fc2:	5d                   	pop    rbp
  405fc3:	c3                   	ret    
  405fc4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  405fc8:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  405fcc:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  405fd0:	48 89 de             	mov    rsi,rbx
  405fd3:	48 89 df             	mov    rdi,rbx
  405fd6:	48 89 da             	mov    rdx,rbx
  405fd9:	83 c0 01             	add    eax,0x1
  405fdc:	c1 e0 10             	shl    eax,0x10
  405fdf:	48 89 29             	mov    QWORD PTR [rcx],rbp
  405fe2:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  405fe6:	48 89 cd             	mov    rbp,rcx
  405fe9:	49 b8 00 60 40 00 00 	movabs r8,0x406000
  405ff0:	00 00 00 
  405ff3:	0f 05                	syscall 
  405ff5:	0f 1f 00             	nop    DWORD PTR [rax]
  405ff8:	eb 0f                	jmp    406009 <__cosrt_c_capmgr_vm_lapic_create+0x89>
  405ffa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  406000:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  406007:	eb 07                	jmp    406010 <__cosrt_c_capmgr_vm_lapic_create+0x90>
  406009:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  406010:	5d                   	pop    rbp
  406011:	5c                   	pop    rsp
  406012:	48 89 75 c0          	mov    QWORD PTR [rbp-0x40],rsi
  406016:	eb 97                	jmp    405faf <__cosrt_c_capmgr_vm_lapic_create+0x2f>
  406018:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40601f:	00 

0000000000406020 <__cosrt_c_capmgr_vm_shared_region_create>:
  406020:	f3 0f 1e fa          	endbr64 
  406024:	55                   	push   rbp
  406025:	48 89 e5             	mov    rbp,rsp
  406028:	41 55                	push   r13
  40602a:	49 89 fd             	mov    r13,rdi
  40602d:	41 54                	push   r12
  40602f:	53                   	push   rbx
  406030:	48 83 ec 28          	sub    rsp,0x28
  406034:	48 8b 58 10          	mov    rbx,QWORD PTR [rax+0x10]
  406038:	48 85 db             	test   rbx,rbx
  40603b:	74 2b                	je     406068 <__cosrt_c_capmgr_vm_shared_region_create+0x48>
  40603d:	4c 8d 4d c8          	lea    r9,[rbp-0x38]
  406041:	4c 8d 45 c0          	lea    r8,[rbp-0x40]
  406045:	31 c9                	xor    ecx,ecx
  406047:	31 d2                	xor    edx,edx
  406049:	31 f6                	xor    esi,esi
  40604b:	31 ff                	xor    edi,edi
  40604d:	ff d3                	call   rbx
  40604f:	48 8b 55 c0          	mov    rdx,QWORD PTR [rbp-0x40]
  406053:	48 98                	cdqe   
  406055:	49 89 55 00          	mov    QWORD PTR [r13+0x0],rdx
  406059:	48 83 c4 28          	add    rsp,0x28
  40605d:	5b                   	pop    rbx
  40605e:	41 5c                	pop    r12
  406060:	41 5d                	pop    r13
  406062:	5d                   	pop    rbp
  406063:	c3                   	ret    
  406064:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  406068:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  40606c:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  406070:	48 89 de             	mov    rsi,rbx
  406073:	48 89 df             	mov    rdi,rbx
  406076:	48 89 da             	mov    rdx,rbx
  406079:	83 c0 01             	add    eax,0x1
  40607c:	c1 e0 10             	shl    eax,0x10
  40607f:	48 89 29             	mov    QWORD PTR [rcx],rbp
  406082:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  406086:	48 89 cd             	mov    rbp,rcx
  406089:	49 b8 a0 60 40 00 00 	movabs r8,0x4060a0
  406090:	00 00 00 
  406093:	0f 05                	syscall 
  406095:	0f 1f 00             	nop    DWORD PTR [rax]
  406098:	eb 0f                	jmp    4060a9 <__cosrt_c_capmgr_vm_shared_region_create+0x89>
  40609a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4060a0:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  4060a7:	eb 07                	jmp    4060b0 <__cosrt_c_capmgr_vm_shared_region_create+0x90>
  4060a9:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  4060b0:	5d                   	pop    rbp
  4060b1:	5c                   	pop    rsp
  4060b2:	48 89 75 c0          	mov    QWORD PTR [rbp-0x40],rsi
  4060b6:	eb 97                	jmp    40604f <__cosrt_c_capmgr_vm_shared_region_create+0x2f>
  4060b8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4060bf:	00 

00000000004060c0 <__cosrt_c_capmgr_vm_vcpu_create>:

	return ret;
}

COS_CLIENT_STUB(thdcap_t, capmgr_vm_vcpu_create, compid_t vm_comp, vm_vmcb_t vmcb_cap, thdid_t *tid)
{
  4060c0:	f3 0f 1e fa          	endbr64 
  4060c4:	55                   	push   rbp
  4060c5:	48 89 e5             	mov    rbp,rsp
  4060c8:	41 57                	push   r15
  4060ca:	49 89 d7             	mov    r15,rdx
  4060cd:	41 56                	push   r14
  4060cf:	41 55                	push   r13
  4060d1:	41 54                	push   r12
  4060d3:	53                   	push   rbx
  4060d4:	48 83 ec 28          	sub    rsp,0x28
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  4060d8:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  4060dc:	4d 85 f6             	test   r14,r14
  4060df:	74 2f                	je     406110 <__cosrt_c_capmgr_vm_vcpu_create+0x50>
  4060e1:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  4060e5:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  4060e9:	31 c9                	xor    ecx,ecx
  4060eb:	31 d2                	xor    edx,edx
  4060ed:	41 ff d6             	call   r14
	COS_CLIENT_INVCAP;
	word_t unused, tid_ret;
	thdcap_t ret;

	ret = cos_sinv_2rets(uc, vm_comp, vmcb_cap, 0, 0, &tid_ret, &unused);
	*tid = tid_ret;
  4060f0:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
	ret = cos_sinv_2rets(uc, vm_comp, vmcb_cap, 0, 0, &tid_ret, &unused);
  4060f4:	48 98                	cdqe   
	*tid = tid_ret;
  4060f6:	49 89 17             	mov    QWORD PTR [r15],rdx

	return ret;
}
  4060f9:	48 83 c4 28          	add    rsp,0x28
  4060fd:	5b                   	pop    rbx
  4060fe:	41 5c                	pop    r12
  406100:	41 5d                	pop    r13
  406102:	41 5e                	pop    r14
  406104:	41 5f                	pop    r15
  406106:	5d                   	pop    rbp
  406107:	c3                   	ret    
  406108:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40610f:	00 
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  406110:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  406114:	48 89 fb             	mov    rbx,rdi
  406117:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  40611b:	4c 89 f7             	mov    rdi,r14
  40611e:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  406121:	83 c0 01             	add    eax,0x1
  406124:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  406127:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40612a:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40612e:	48 89 cd             	mov    rbp,rcx
  406131:	49 b8 48 61 40 00 00 	movabs r8,0x406148
  406138:	00 00 00 
  40613b:	0f 05                	syscall 
  40613d:	0f 1f 00             	nop    DWORD PTR [rax]
  406140:	eb 0f                	jmp    406151 <__cosrt_c_capmgr_vm_vcpu_create+0x91>
  406142:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  406148:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  40614f:	eb 07                	jmp    406158 <__cosrt_c_capmgr_vm_vcpu_create+0x98>
  406151:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  406158:	5d                   	pop    rbp
  406159:	5c                   	pop    rsp
  40615a:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  40615e:	eb 90                	jmp    4060f0 <__cosrt_c_capmgr_vm_vcpu_create+0x30>

0000000000406160 <__cosrt_c_capmgr_initthd_create>:

COS_CLIENT_STUB(thdcap_t, capmgr_initthd_create, spdid_t child, thdid_t *tid)
{
  406160:	f3 0f 1e fa          	endbr64 
  406164:	55                   	push   rbp
  406165:	48 89 e5             	mov    rbp,rsp
  406168:	41 57                	push   r15
	COS_CLIENT_INVCAP;
	word_t unused, tid_ret;
	thdcap_t ret;

	ret = cos_sinv_2rets(uc, child, 0, 0, 0, &tid_ret, &unused);
  40616a:	44 0f b7 ff          	movzx  r15d,di
{
  40616e:	41 56                	push   r14
  406170:	41 55                	push   r13
  406172:	49 89 f5             	mov    r13,rsi
  406175:	41 54                	push   r12
  406177:	53                   	push   rbx
  406178:	48 83 ec 28          	sub    rsp,0x28
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  40617c:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  406180:	4d 85 f6             	test   r14,r14
  406183:	74 33                	je     4061b8 <__cosrt_c_capmgr_initthd_create+0x58>
  406185:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  406189:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  40618d:	31 c9                	xor    ecx,ecx
  40618f:	31 d2                	xor    edx,edx
  406191:	31 f6                	xor    esi,esi
  406193:	4c 89 ff             	mov    rdi,r15
  406196:	41 ff d6             	call   r14
	*tid = tid_ret;
  406199:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
	ret = cos_sinv_2rets(uc, child, 0, 0, 0, &tid_ret, &unused);
  40619d:	48 98                	cdqe   
	*tid = tid_ret;
  40619f:	49 89 55 00          	mov    QWORD PTR [r13+0x0],rdx

	return ret;
}
  4061a3:	48 83 c4 28          	add    rsp,0x28
  4061a7:	5b                   	pop    rbx
  4061a8:	41 5c                	pop    r12
  4061aa:	41 5d                	pop    r13
  4061ac:	41 5e                	pop    r14
  4061ae:	41 5f                	pop    r15
  4061b0:	5d                   	pop    rbp
  4061b1:	c3                   	ret    
  4061b2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  4061b8:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  4061bc:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  4061c0:	4c 89 fb             	mov    rbx,r15
  4061c3:	4c 89 f6             	mov    rsi,r14
  4061c6:	4c 89 f7             	mov    rdi,r14
  4061c9:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4061cc:	83 c0 01             	add    eax,0x1
  4061cf:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  4061d2:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4061d5:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4061d9:	48 89 cd             	mov    rbp,rcx
  4061dc:	49 b8 f0 61 40 00 00 	movabs r8,0x4061f0
  4061e3:	00 00 00 
  4061e6:	0f 05                	syscall 
  4061e8:	eb 0f                	jmp    4061f9 <__cosrt_c_capmgr_initthd_create+0x99>
  4061ea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4061f0:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  4061f7:	eb 07                	jmp    406200 <__cosrt_c_capmgr_initthd_create+0xa0>
  4061f9:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  406200:	5d                   	pop    rbp
  406201:	5c                   	pop    rsp
  406202:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  406206:	eb 91                	jmp    406199 <__cosrt_c_capmgr_initthd_create+0x39>
  406208:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40620f:	00 

0000000000406210 <__cosrt_c_capmgr_thd_create_thunk>:

COS_CLIENT_STUB(thdcap_t, capmgr_thd_create_thunk, thdclosure_index_t id, thdid_t *tid)
{
  406210:	f3 0f 1e fa          	endbr64 
  406214:	55                   	push   rbp
  406215:	48 89 e5             	mov    rbp,rsp
  406218:	41 57                	push   r15
	COS_CLIENT_INVCAP;
	word_t unused, tid_ret;
	thdcap_t ret;

	ret = cos_sinv_2rets(uc, id, 0, 0, 0, &tid_ret, &unused);
  40621a:	4c 63 ff             	movsxd r15,edi
{
  40621d:	41 56                	push   r14
  40621f:	41 55                	push   r13
  406221:	49 89 f5             	mov    r13,rsi
  406224:	41 54                	push   r12
  406226:	53                   	push   rbx
  406227:	48 83 ec 28          	sub    rsp,0x28
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  40622b:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  40622f:	4d 85 f6             	test   r14,r14
  406232:	74 34                	je     406268 <__cosrt_c_capmgr_thd_create_thunk+0x58>
  406234:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  406238:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  40623c:	31 c9                	xor    ecx,ecx
  40623e:	31 d2                	xor    edx,edx
  406240:	31 f6                	xor    esi,esi
  406242:	4c 89 ff             	mov    rdi,r15
  406245:	41 ff d6             	call   r14
	*tid = tid_ret;
  406248:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
	ret = cos_sinv_2rets(uc, id, 0, 0, 0, &tid_ret, &unused);
  40624c:	48 98                	cdqe   
	*tid = tid_ret;
  40624e:	49 89 55 00          	mov    QWORD PTR [r13+0x0],rdx

	return ret;
}
  406252:	48 83 c4 28          	add    rsp,0x28
  406256:	5b                   	pop    rbx
  406257:	41 5c                	pop    r12
  406259:	41 5d                	pop    r13
  40625b:	41 5e                	pop    r14
  40625d:	41 5f                	pop    r15
  40625f:	5d                   	pop    rbp
  406260:	c3                   	ret    
  406261:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  406268:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  40626c:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  406270:	4c 89 fb             	mov    rbx,r15
  406273:	4c 89 f6             	mov    rsi,r14
  406276:	4c 89 f7             	mov    rdi,r14
  406279:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40627c:	83 c0 01             	add    eax,0x1
  40627f:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  406282:	48 89 29             	mov    QWORD PTR [rcx],rbp
  406285:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  406289:	48 89 cd             	mov    rbp,rcx
  40628c:	49 b8 a0 62 40 00 00 	movabs r8,0x4062a0
  406293:	00 00 00 
  406296:	0f 05                	syscall 
  406298:	eb 0f                	jmp    4062a9 <__cosrt_c_capmgr_thd_create_thunk+0x99>
  40629a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4062a0:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  4062a7:	eb 07                	jmp    4062b0 <__cosrt_c_capmgr_thd_create_thunk+0xa0>
  4062a9:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  4062b0:	5d                   	pop    rbp
  4062b1:	5c                   	pop    rsp
  4062b2:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  4062b6:	eb 90                	jmp    406248 <__cosrt_c_capmgr_thd_create_thunk+0x38>
  4062b8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4062bf:	00 

00000000004062c0 <__cosrt_c_capmgr_thd_create_ext>:

COS_CLIENT_STUB(thdcap_t, capmgr_thd_create_ext, spdid_t child, thdclosure_index_t idx, thdid_t *tid)
{
  4062c0:	f3 0f 1e fa          	endbr64 
  4062c4:	55                   	push   rbp
	COS_CLIENT_INVCAP;
	word_t unused, tid_ret;
	thdcap_t ret;

	ret = cos_sinv_2rets(uc, child, idx, 0, 0, &tid_ret, &unused);
  4062c5:	48 63 f6             	movsxd rsi,esi
{
  4062c8:	48 89 e5             	mov    rbp,rsp
  4062cb:	41 57                	push   r15
  4062cd:	49 89 d7             	mov    r15,rdx
  4062d0:	41 56                	push   r14
  4062d2:	41 55                	push   r13
	ret = cos_sinv_2rets(uc, child, idx, 0, 0, &tid_ret, &unused);
  4062d4:	44 0f b7 ef          	movzx  r13d,di
{
  4062d8:	41 54                	push   r12
  4062da:	53                   	push   rbx
  4062db:	48 83 ec 28          	sub    rsp,0x28
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  4062df:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  4062e3:	4d 85 f6             	test   r14,r14
  4062e6:	74 30                	je     406318 <__cosrt_c_capmgr_thd_create_ext+0x58>
  4062e8:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  4062ec:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  4062f0:	31 c9                	xor    ecx,ecx
  4062f2:	31 d2                	xor    edx,edx
  4062f4:	4c 89 ef             	mov    rdi,r13
  4062f7:	41 ff d6             	call   r14
	*tid = tid_ret;
  4062fa:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
	ret = cos_sinv_2rets(uc, child, idx, 0, 0, &tid_ret, &unused);
  4062fe:	48 98                	cdqe   
	*tid = tid_ret;
  406300:	49 89 17             	mov    QWORD PTR [r15],rdx

	return ret;
}
  406303:	48 83 c4 28          	add    rsp,0x28
  406307:	5b                   	pop    rbx
  406308:	41 5c                	pop    r12
  40630a:	41 5d                	pop    r13
  40630c:	41 5e                	pop    r14
  40630e:	41 5f                	pop    r15
  406310:	5d                   	pop    rbp
  406311:	c3                   	ret    
  406312:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  406318:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  40631c:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  406320:	4c 89 eb             	mov    rbx,r13
  406323:	4c 89 f7             	mov    rdi,r14
  406326:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  406329:	83 c0 01             	add    eax,0x1
  40632c:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40632f:	48 89 29             	mov    QWORD PTR [rcx],rbp
  406332:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  406336:	48 89 cd             	mov    rbp,rcx
  406339:	49 b8 50 63 40 00 00 	movabs r8,0x406350
  406340:	00 00 00 
  406343:	0f 05                	syscall 
  406345:	0f 1f 00             	nop    DWORD PTR [rax]
  406348:	eb 0f                	jmp    406359 <__cosrt_c_capmgr_thd_create_ext+0x99>
  40634a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  406350:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  406357:	eb 07                	jmp    406360 <__cosrt_c_capmgr_thd_create_ext+0xa0>
  406359:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  406360:	5d                   	pop    rbp
  406361:	5c                   	pop    rsp
  406362:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  406366:	eb 92                	jmp    4062fa <__cosrt_c_capmgr_thd_create_ext+0x3a>
  406368:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40636f:	00 

0000000000406370 <__cosrt_c_capmgr_aep_create_thunk>:

COS_CLIENT_STUB(thdcap_t, capmgr_aep_create_thunk, struct cos_aep_info *aep, thdclosure_index_t idx, int owntc, cos_channelkey_t key, microsec_t ipiwin, u32_t ipimax)
{
  406370:	f3 0f 1e fa          	endbr64 
  406374:	55                   	push   rbp
  406375:	48 89 e5             	mov    rbp,rsp
  406378:	41 57                	push   r15
  40637a:	41 56                	push   r14
  40637c:	41 55                	push   r13
  40637e:	41 54                	push   r12
  406380:	53                   	push   rbx
  406381:	48 83 ec 28          	sub    rsp,0x28
	COS_CLIENT_INVCAP;
	word_t tcrcvret   = 0;
  406385:	48 c7 45 b0 00 00 00 	mov    QWORD PTR [rbp-0x50],0x0
  40638c:	00 
	thdcap_t thd     = 0;
	thdid_t tid      = 0;
  40638d:	48 c7 45 b8 00 00 00 	mov    QWORD PTR [rbp-0x48],0x0
  406394:	00 
	u32_t owntc_idx  = (owntc << 16) | idx;
	u32_t key_ipimax = (key << 16) | ((ipimax << 16) >> 16);
	u32_t ipiwin32b  = (u32_t)ipiwin;

	if (idx < 1) return 0;
  406395:	85 f6                	test   esi,esi
  406397:	0f 8e 93 00 00 00    	jle    406430 <__cosrt_c_capmgr_aep_create_thunk+0xc0>
  40639d:	41 89 d5             	mov    r13d,edx
	u32_t key_ipimax = (key << 16) | ((ipimax << 16) >> 16);
  4063a0:	c1 e1 10             	shl    ecx,0x10
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  4063a3:	4c 8b 78 10          	mov    r15,QWORD PTR [rax+0x10]
  4063a7:	41 89 f2             	mov    r10d,esi
  4063aa:	45 0f b7 c9          	movzx  r9d,r9w

	thd = cos_sinv_2rets(uc, owntc_idx, key_ipimax, ipiwin32b, 0, &tid, &tcrcvret);
  4063ae:	89 ce                	mov    esi,ecx
	u32_t owntc_idx  = (owntc << 16) | idx;
  4063b0:	41 c1 e5 10          	shl    r13d,0x10
  4063b4:	49 89 fe             	mov    r14,rdi
	thd = cos_sinv_2rets(uc, owntc_idx, key_ipimax, ipiwin32b, 0, &tid, &tcrcvret);
  4063b7:	44 09 ce             	or     esi,r9d
  4063ba:	44 89 c7             	mov    edi,r8d
  4063bd:	45 09 d5             	or     r13d,r10d
  4063c0:	4d 85 ff             	test   r15,r15
  4063c3:	0f 84 7f 00 00 00    	je     406448 <__cosrt_c_capmgr_aep_create_thunk+0xd8>
  4063c9:	48 89 fa             	mov    rdx,rdi
  4063cc:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  4063d0:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  4063d4:	31 c9                	xor    ecx,ecx
  4063d6:	4c 89 ef             	mov    rdi,r13
  4063d9:	41 ff d7             	call   r15
  4063dc:	48 98                	cdqe   
	if (!thd) return 0;
  4063de:	48 85 c0             	test   rax,rax
  4063e1:	74 3a                	je     40641d <__cosrt_c_capmgr_aep_create_thunk+0xad>

	aep->thd  = thd;
	aep->rcv  = (tcrcvret << 16) >> 16;
  4063e3:	48 8b 55 b0          	mov    rdx,QWORD PTR [rbp-0x50]
	aep->tc   = (tcrcvret >> 16);
	aep->tid  = tid;
  4063e7:	f3 0f 7e 4d b8       	movq   xmm1,QWORD PTR [rbp-0x48]
	aep->tc   = (tcrcvret >> 16);
  4063ec:	66 48 0f 6e d8       	movq   xmm3,rax
	aep->rcv  = (tcrcvret << 16) >> 16;
  4063f1:	48 b9 ff ff ff ff ff 	movabs rcx,0xffffffffffff
  4063f8:	ff 00 00 
  4063fb:	48 21 d1             	and    rcx,rdx
	aep->tc   = (tcrcvret >> 16);
  4063fe:	48 c1 ea 10          	shr    rdx,0x10
  406402:	66 48 0f 6e d1       	movq   xmm2,rcx
  406407:	66 48 0f 6e c2       	movq   xmm0,rdx
  40640c:	66 0f 6c ca          	punpcklqdq xmm1,xmm2
  406410:	66 0f 6c c3          	punpcklqdq xmm0,xmm3
  406414:	41 0f 11 06          	movups XMMWORD PTR [r14],xmm0
  406418:	41 0f 11 4e 10       	movups XMMWORD PTR [r14+0x10],xmm1

	return thd;
}
  40641d:	48 83 c4 28          	add    rsp,0x28
  406421:	5b                   	pop    rbx
  406422:	41 5c                	pop    r12
  406424:	41 5d                	pop    r13
  406426:	41 5e                	pop    r14
  406428:	41 5f                	pop    r15
  40642a:	5d                   	pop    rbp
  40642b:	c3                   	ret    
  40642c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  406430:	48 83 c4 28          	add    rsp,0x28
	if (idx < 1) return 0;
  406434:	31 c0                	xor    eax,eax
}
  406436:	5b                   	pop    rbx
  406437:	41 5c                	pop    r12
  406439:	41 5d                	pop    r13
  40643b:	41 5e                	pop    r14
  40643d:	41 5f                	pop    r15
  40643f:	5d                   	pop    rbp
  406440:	c3                   	ret    
  406441:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  406448:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  40644c:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  406450:	4c 89 eb             	mov    rbx,r13
  406453:	4c 89 fa             	mov    rdx,r15
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  406456:	83 c0 01             	add    eax,0x1
  406459:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40645c:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40645f:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  406463:	48 89 cd             	mov    rbp,rcx
  406466:	49 b8 80 64 40 00 00 	movabs r8,0x406480
  40646d:	00 00 00 
  406470:	0f 05                	syscall 
  406472:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  406478:	eb 0f                	jmp    406489 <__cosrt_c_capmgr_aep_create_thunk+0x119>
  40647a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  406480:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  406487:	eb 07                	jmp    406490 <__cosrt_c_capmgr_aep_create_thunk+0x120>
  406489:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  406490:	5d                   	pop    rbp
  406491:	5c                   	pop    rsp
  406492:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
  406496:	48 89 7d b0          	mov    QWORD PTR [rbp-0x50],rdi
	return ret;
  40649a:	e9 3d ff ff ff       	jmp    4063dc <__cosrt_c_capmgr_aep_create_thunk+0x6c>
  40649f:	90                   	nop

00000000004064a0 <__cosrt_c_capmgr_aep_create_ext>:

COS_CLIENT_STUB(thdcap_t, capmgr_aep_create_ext, spdid_t child, struct cos_aep_info *aep, thdclosure_index_t idx, int owntc, cos_channelkey_t key, microsec_t ipiwin, u32_t ipimax, arcvcap_t *extrcv)
{
  4064a0:	f3 0f 1e fa          	endbr64 
  4064a4:	55                   	push   rbp
	COS_CLIENT_INVCAP;
	word_t drcvtidret  = 0;
	word_t tcrcvret    = 0;
	thdcap_t thd       = 0;
	u32_t spdid_thdidx = (child << 16) | ((idx << 16) >> 16);
	u32_t key_ipimax   = (key << 16) | ((ipimax << 16) >> 16);
  4064a5:	41 c1 e0 10          	shl    r8d,0x10
	u32_t spdid_thdidx = (child << 16) | ((idx << 16) >> 16);
  4064a9:	c1 e7 10             	shl    edi,0x10
{
  4064ac:	48 89 e5             	mov    rbp,rsp
  4064af:	41 57                	push   r15
  4064b1:	41 89 d7             	mov    r15d,edx
  4064b4:	44 89 ca             	mov    edx,r9d
  4064b7:	41 56                	push   r14
	u32_t spdid_thdidx = (child << 16) | ((idx << 16) >> 16);
  4064b9:	45 0f bf ff          	movsx  r15d,r15w
	u32_t ipiwin32b    = (u32_t)ipiwin;

	thd = cos_sinv_2rets(uc, spdid_thdidx, owntc, key_ipimax, ipiwin32b, &drcvtidret, &tcrcvret);
  4064bd:	45 89 c6             	mov    r14d,r8d
{
  4064c0:	41 55                	push   r13
  4064c2:	49 89 f5             	mov    r13,rsi
	thd = cos_sinv_2rets(uc, spdid_thdidx, owntc, key_ipimax, ipiwin32b, &drcvtidret, &tcrcvret);
  4064c5:	41 09 ff             	or     r15d,edi
{
  4064c8:	41 54                	push   r12
  4064ca:	53                   	push   rbx
  4064cb:	48 83 ec 28          	sub    rsp,0x28
	u32_t key_ipimax   = (key << 16) | ((ipimax << 16) >> 16);
  4064cf:	0f b7 75 10          	movzx  esi,WORD PTR [rbp+0x10]
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  4064d3:	4c 8b 50 10          	mov    r10,QWORD PTR [rax+0x10]
	word_t drcvtidret  = 0;
  4064d7:	48 c7 45 b0 00 00 00 	mov    QWORD PTR [rbp-0x50],0x0
  4064de:	00 
	word_t tcrcvret    = 0;
  4064df:	48 c7 45 b8 00 00 00 	mov    QWORD PTR [rbp-0x48],0x0
  4064e6:	00 
	thd = cos_sinv_2rets(uc, spdid_thdidx, owntc, key_ipimax, ipiwin32b, &drcvtidret, &tcrcvret);
  4064e7:	41 09 f6             	or     r14d,esi
  4064ea:	48 63 f1             	movsxd rsi,ecx
  4064ed:	4d 85 d2             	test   r10,r10
  4064f0:	0f 84 8a 00 00 00    	je     406580 <__cosrt_c_capmgr_aep_create_ext+0xe0>
  4064f6:	48 89 d1             	mov    rcx,rdx
  4064f9:	4c 8d 4d b8          	lea    r9,[rbp-0x48]
  4064fd:	4c 8d 45 b0          	lea    r8,[rbp-0x50]
  406501:	4c 89 f2             	mov    rdx,r14
  406504:	4c 89 ff             	mov    rdi,r15
  406507:	41 ff d2             	call   r10
  40650a:	48 98                	cdqe   
	if (!thd) return thd;
  40650c:	48 85 c0             	test   rax,rax
  40650f:	74 60                	je     406571 <__cosrt_c_capmgr_aep_create_ext+0xd1>

	aep->fn   = NULL;
	aep->data = NULL;
	aep->thd  = thd;
	aep->tid  = (drcvtidret << 16) >> 16;
	aep->rcv  = tcrcvret >> 16;
  406511:	48 8b 75 b8          	mov    rsi,QWORD PTR [rbp-0x48]
	aep->tid  = (drcvtidret << 16) >> 16;
  406515:	48 8b 4d b0          	mov    rcx,QWORD PTR [rbp-0x50]
	aep->tc   = (tcrcvret << 16) >> 16;
  406519:	48 ba ff ff ff ff ff 	movabs rdx,0xffffffffffff
  406520:	ff 00 00 
  406523:	66 48 0f 6e c8       	movq   xmm1,rax
	aep->fn   = NULL;
  406528:	49 c7 45 20 00 00 00 	mov    QWORD PTR [r13+0x20],0x0
  40652f:	00 
	aep->tc   = (tcrcvret << 16) >> 16;
  406530:	48 89 f3             	mov    rbx,rsi
	aep->rcv  = tcrcvret >> 16;
  406533:	48 c1 ee 10          	shr    rsi,0x10
	aep->data = NULL;
  406537:	49 c7 45 28 00 00 00 	mov    QWORD PTR [r13+0x28],0x0
  40653e:	00 
	aep->tc   = (tcrcvret << 16) >> 16;
  40653f:	48 21 d3             	and    rbx,rdx
	aep->tid  = (drcvtidret << 16) >> 16;
  406542:	48 21 ca             	and    rdx,rcx
	aep->tc   = (tcrcvret << 16) >> 16;
  406545:	66 48 0f 6e d6       	movq   xmm2,rsi
	*extrcv   = drcvtidret >> 16;
  40654a:	48 c1 e9 10          	shr    rcx,0x10
	aep->tc   = (tcrcvret << 16) >> 16;
  40654e:	66 48 0f 6e c3       	movq   xmm0,rbx
  406553:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  406557:	41 0f 11 45 00       	movups XMMWORD PTR [r13+0x0],xmm0
  40655c:	66 48 0f 6e c2       	movq   xmm0,rdx
	*extrcv   = drcvtidret >> 16;
  406561:	48 8b 55 18          	mov    rdx,QWORD PTR [rbp+0x18]
	aep->tc   = (tcrcvret << 16) >> 16;
  406565:	66 0f 6c c2          	punpcklqdq xmm0,xmm2
  406569:	41 0f 11 45 10       	movups XMMWORD PTR [r13+0x10],xmm0
	*extrcv   = drcvtidret >> 16;
  40656e:	48 89 0a             	mov    QWORD PTR [rdx],rcx

	return thd;
}
  406571:	48 83 c4 28          	add    rsp,0x28
  406575:	5b                   	pop    rbx
  406576:	41 5c                	pop    r12
  406578:	41 5d                	pop    r13
  40657a:	41 5e                	pop    r14
  40657c:	41 5f                	pop    r15
  40657e:	5d                   	pop    rbp
  40657f:	c3                   	ret    
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  406580:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  406584:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  406588:	4c 89 fb             	mov    rbx,r15
  40658b:	4c 89 f7             	mov    rdi,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40658e:	83 c0 01             	add    eax,0x1
  406591:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  406594:	48 89 29             	mov    QWORD PTR [rcx],rbp
  406597:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40659b:	48 89 cd             	mov    rbp,rcx
  40659e:	49 b8 b8 65 40 00 00 	movabs r8,0x4065b8
  4065a5:	00 00 00 
  4065a8:	0f 05                	syscall 
  4065aa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4065b0:	eb 0f                	jmp    4065c1 <__cosrt_c_capmgr_aep_create_ext+0x121>
  4065b2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4065b8:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  4065bf:	eb 07                	jmp    4065c8 <__cosrt_c_capmgr_aep_create_ext+0x128>
  4065c1:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  4065c8:	5d                   	pop    rbp
  4065c9:	5c                   	pop    rsp
  4065ca:	48 89 75 b0          	mov    QWORD PTR [rbp-0x50],rsi
  4065ce:	48 89 7d b8          	mov    QWORD PTR [rbp-0x48],rdi
	return ret;
  4065d2:	e9 33 ff ff ff       	jmp    40650a <__cosrt_c_capmgr_aep_create_ext+0x6a>
  4065d7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  4065de:	00 00 

00000000004065e0 <__cosrt_c_capmgr_vm_vmcb_create>:

COS_CLIENT_STUB(capid_t, capmgr_vm_vmcb_create, vm_vmcscap_t vmcs_cap, vm_msrbitmapcap_t msr_bitmap_cap, vm_lapicaccesscap_t lapic_access_cap, vm_lapiccap_t lapic_cap, vm_shared_mem_t shared_mem_cap, thdid_t handler_thd_id, word_t vpid)
{
  4065e0:	f3 0f 1e fa          	endbr64 
  4065e4:	55                   	push   rbp

	/* FIXME: MPK call gate make indirect call complicated, arguments passed via stack gets wrong, walk around now by avoiding pass that argument */
	vpid = handler_thd_id & 0xFFFF;
	handler_thd_id = (handler_thd_id >> 16) & 0xFFFF;

	arg1 = 0 | vmcs_cap << (16 * 1) | msr_bitmap_cap << (16 * 2) |  lapic_access_cap << (16 * 3);
  4065e5:	48 c1 e2 30          	shl    rdx,0x30
  4065e9:	48 c1 e6 20          	shl    rsi,0x20
  4065ed:	48 c1 e7 10          	shl    rdi,0x10
  4065f1:	48 09 d6             	or     rsi,rdx
	arg2 = lapic_cap | shared_mem_cap << (16 * 1) | handler_thd_id << (16 * 2) | vpid << (16 * 3);
  4065f4:	49 c1 e0 10          	shl    r8,0x10
  4065f8:	4c 89 ca             	mov    rdx,r9
  4065fb:	48 c1 e2 30          	shl    rdx,0x30
	arg1 = 0 | vmcs_cap << (16 * 1) | msr_bitmap_cap << (16 * 2) |  lapic_access_cap << (16 * 3);
  4065ff:	48 09 fe             	or     rsi,rdi
	arg2 = lapic_cap | shared_mem_cap << (16 * 1) | handler_thd_id << (16 * 2) | vpid << (16 * 3);
  406602:	49 09 c8             	or     r8,rcx
  406605:	49 c1 e1 10          	shl    r9,0x10
{
  406609:	48 89 e5             	mov    rbp,rsp
  40660c:	41 56                	push   r14
  40660e:	41 55                	push   r13
	arg1 = 0 | vmcs_cap << (16 * 1) | msr_bitmap_cap << (16 * 2) |  lapic_access_cap << (16 * 3);
  406610:	49 89 f5             	mov    r13,rsi
	arg2 = lapic_cap | shared_mem_cap << (16 * 1) | handler_thd_id << (16 * 2) | vpid << (16 * 3);
  406613:	4c 89 c6             	mov    rsi,r8
{
  406616:	41 54                	push   r12
	arg2 = lapic_cap | shared_mem_cap << (16 * 1) | handler_thd_id << (16 * 2) | vpid << (16 * 3);
  406618:	48 09 d6             	or     rsi,rdx
  40661b:	48 ba 00 00 00 00 ff 	movabs rdx,0xffff00000000
  406622:	ff 00 00 
{
  406625:	53                   	push   rbx
	arg2 = lapic_cap | shared_mem_cap << (16 * 1) | handler_thd_id << (16 * 2) | vpid << (16 * 3);
  406626:	49 21 d1             	and    r9,rdx
  406629:	4c 09 ce             	or     rsi,r9
{
  40662c:	48 83 ec 20          	sub    rsp,0x20
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  406630:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
	word_t ret1 = 0;
  406634:	48 c7 45 c0 00 00 00 	mov    QWORD PTR [rbp-0x40],0x0
  40663b:	00 
	word_t ret2 = 0;
  40663c:	48 c7 45 c8 00 00 00 	mov    QWORD PTR [rbp-0x38],0x0
  406643:	00 
  406644:	4d 85 f6             	test   r14,r14
  406647:	74 27                	je     406670 <__cosrt_c_capmgr_vm_vmcb_create+0x90>
  406649:	4c 8d 4d c8          	lea    r9,[rbp-0x38]
  40664d:	4c 8d 45 c0          	lea    r8,[rbp-0x40]
  406651:	4c 89 ef             	mov    rdi,r13
  406654:	31 c9                	xor    ecx,ecx
  406656:	31 d2                	xor    edx,edx
  406658:	41 ff d6             	call   r14
	cap = cos_sinv_2rets(uc, arg1, arg2, 0, 0, &ret1, &ret2);

	return cap;
}
  40665b:	48 83 c4 20          	add    rsp,0x20
  40665f:	5b                   	pop    rbx
	cap = cos_sinv_2rets(uc, arg1, arg2, 0, 0, &ret1, &ret2);
  406660:	48 98                	cdqe   
}
  406662:	41 5c                	pop    r12
  406664:	41 5d                	pop    r13
  406666:	41 5e                	pop    r14
  406668:	5d                   	pop    rbp
  406669:	c3                   	ret    
  40666a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  406670:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  406674:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  406678:	4c 89 eb             	mov    rbx,r13
  40667b:	4c 89 f7             	mov    rdi,r14
  40667e:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  406681:	83 c0 01             	add    eax,0x1
  406684:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  406687:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40668a:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40668e:	48 89 cd             	mov    rbp,rcx
  406691:	49 b8 a8 66 40 00 00 	movabs r8,0x4066a8
  406698:	00 00 00 
  40669b:	0f 05                	syscall 
  40669d:	0f 1f 00             	nop    DWORD PTR [rax]
  4066a0:	eb 0f                	jmp    4066b1 <__cosrt_c_capmgr_vm_vmcb_create+0xd1>
  4066a2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4066a8:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  4066af:	eb 07                	jmp    4066b8 <__cosrt_c_capmgr_vm_vmcb_create+0xd8>
  4066b1:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  4066b8:	5d                   	pop    rbp
  4066b9:	5c                   	pop    rsp
  4066ba:	48 83 c4 20          	add    rsp,0x20
	cap = cos_sinv_2rets(uc, arg1, arg2, 0, 0, &ret1, &ret2);
  4066be:	48 98                	cdqe   
}
  4066c0:	5b                   	pop    rbx
  4066c1:	41 5c                	pop    r12
  4066c3:	41 5d                	pop    r13
  4066c5:	41 5e                	pop    r14
  4066c7:	5d                   	pop    rbp
  4066c8:	c3                   	ret    
  4066c9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

00000000004066d0 <__cosrt_c_capmgr_initaep_create>:

COS_CLIENT_STUB(thdcap_t, capmgr_initaep_create, spdid_t child, struct cos_aep_info *aep, int owntc, cos_channelkey_t key, microsec_t ipiwin, u32_t ipimax, asndcap_t *snd)
{
  4066d0:	f3 0f 1e fa          	endbr64 
  4066d4:	55                   	push   rbp
	COS_CLIENT_INVCAP;
	u32_t child_owntc = (child << 16) | owntc;
	u32_t key_ipimax  = (key << 16) >> ipimax;
  4066d5:	c1 e1 10             	shl    ecx,0x10
	u32_t child_owntc = (child << 16) | owntc;
  4066d8:	c1 e7 10             	shl    edi,0x10
{
  4066db:	48 89 e5             	mov    rbp,rsp
  4066de:	41 57                	push   r15
  4066e0:	41 56                	push   r14
	u32_t child_owntc = (child << 16) | owntc;
  4066e2:	41 89 fe             	mov    r14d,edi
{
  4066e5:	41 55                	push   r13
  4066e7:	49 89 f5             	mov    r13,rsi
	u32_t key_ipimax  = (key << 16) >> ipimax;
  4066ea:	89 ce                	mov    esi,ecx
	u32_t ipiwin32b   = (u32_t)ipiwin;
	thdcap_t thd = 0;
	word_t sndtidret = 0, rcvtcret = 0;

	thd = cos_sinv_2rets(uc, child_owntc, key_ipimax, ipiwin32b, 0, &sndtidret, &rcvtcret);
  4066ec:	44 89 c9             	mov    ecx,r9d
{
  4066ef:	41 54                	push   r12
	thd = cos_sinv_2rets(uc, child_owntc, key_ipimax, ipiwin32b, 0, &sndtidret, &rcvtcret);
  4066f1:	d3 fe                	sar    esi,cl
  4066f3:	41 09 d6             	or     r14d,edx
{
  4066f6:	53                   	push   rbx
  4066f7:	44 89 c3             	mov    ebx,r8d
  4066fa:	48 83 ec 28          	sub    rsp,0x28
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  4066fe:	4c 8b 78 10          	mov    r15,QWORD PTR [rax+0x10]
	word_t sndtidret = 0, rcvtcret = 0;
  406702:	48 c7 45 b0 00 00 00 	mov    QWORD PTR [rbp-0x50],0x0
  406709:	00 
  40670a:	48 c7 45 b8 00 00 00 	mov    QWORD PTR [rbp-0x48],0x0
  406711:	00 
  406712:	4d 85 ff             	test   r15,r15
  406715:	0f 84 95 00 00 00    	je     4067b0 <__cosrt_c_capmgr_initaep_create+0xe0>
  40671b:	4c 8d 4d b8          	lea    r9,[rbp-0x48]
  40671f:	4c 8d 45 b0          	lea    r8,[rbp-0x50]
  406723:	31 c9                	xor    ecx,ecx
  406725:	48 89 da             	mov    rdx,rbx
  406728:	4c 89 f7             	mov    rdi,r14
  40672b:	41 ff d7             	call   r15
	thd = cos_sinv_2rets(uc, child_owntc, key_ipimax, ipiwin32b, 0, &sndtidret, &rcvtcret);
  40672e:	48 98                	cdqe   
	if (!thd) return thd;
  406730:	48 85 c0             	test   rax,rax
  406733:	74 64                	je     406799 <__cosrt_c_capmgr_initaep_create+0xc9>

	aep->fn   = NULL;
	aep->data = NULL;
	aep->thd  = thd;
	aep->tid  = (sndtidret << 16) >> 16;
	aep->rcv  = rcvtcret >> 16;
  406735:	48 8b 75 b8          	mov    rsi,QWORD PTR [rbp-0x48]
	aep->tid  = (sndtidret << 16) >> 16;
  406739:	48 8b 4d b0          	mov    rcx,QWORD PTR [rbp-0x50]
	aep->tc   = (rcvtcret << 16) >> 16;
  40673d:	48 ba ff ff ff ff ff 	movabs rdx,0xffffffffffff
  406744:	ff 00 00 
  406747:	66 48 0f 6e c8       	movq   xmm1,rax
	*snd      = sndtidret >> 16;
  40674c:	48 8b 45 10          	mov    rax,QWORD PTR [rbp+0x10]
	aep->fn   = NULL;
  406750:	49 c7 45 20 00 00 00 	mov    QWORD PTR [r13+0x20],0x0
  406757:	00 
	aep->tc   = (rcvtcret << 16) >> 16;
  406758:	48 89 f3             	mov    rbx,rsi
	aep->rcv  = rcvtcret >> 16;
  40675b:	48 c1 ee 10          	shr    rsi,0x10
	aep->data = NULL;
  40675f:	49 c7 45 28 00 00 00 	mov    QWORD PTR [r13+0x28],0x0
  406766:	00 
	aep->tc   = (rcvtcret << 16) >> 16;
  406767:	48 21 d3             	and    rbx,rdx
	aep->tid  = (sndtidret << 16) >> 16;
  40676a:	48 21 ca             	and    rdx,rcx
	aep->tc   = (rcvtcret << 16) >> 16;
  40676d:	66 48 0f 6e d6       	movq   xmm2,rsi
	*snd      = sndtidret >> 16;
  406772:	48 c1 e9 10          	shr    rcx,0x10
	aep->tc   = (rcvtcret << 16) >> 16;
  406776:	66 48 0f 6e c3       	movq   xmm0,rbx
  40677b:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  40677f:	41 0f 11 45 00       	movups XMMWORD PTR [r13+0x0],xmm0
  406784:	66 48 0f 6e c2       	movq   xmm0,rdx
  406789:	66 0f 6c c2          	punpcklqdq xmm0,xmm2
  40678d:	41 0f 11 45 10       	movups XMMWORD PTR [r13+0x10],xmm0
	*snd      = sndtidret >> 16;
  406792:	48 89 08             	mov    QWORD PTR [rax],rcx

	/* initcaps are copied to INITXXX offsets in the dst component */
	return aep->thd;
  406795:	49 8b 45 08          	mov    rax,QWORD PTR [r13+0x8]
}
  406799:	48 83 c4 28          	add    rsp,0x28
  40679d:	5b                   	pop    rbx
  40679e:	41 5c                	pop    r12
  4067a0:	41 5d                	pop    r13
  4067a2:	41 5e                	pop    r14
  4067a4:	41 5f                	pop    r15
  4067a6:	5d                   	pop    rbp
  4067a7:	c3                   	ret    
  4067a8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4067af:	00 
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  4067b0:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  4067b4:	49 89 da             	mov    r10,rbx
	__asm__ __volatile__(
  4067b7:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  4067bb:	4c 89 f3             	mov    rbx,r14
  4067be:	4c 89 d7             	mov    rdi,r10
  4067c1:	4c 89 fa             	mov    rdx,r15
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4067c4:	83 c0 01             	add    eax,0x1
  4067c7:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  4067ca:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4067cd:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4067d1:	48 89 cd             	mov    rbp,rcx
  4067d4:	49 b8 e8 67 40 00 00 	movabs r8,0x4067e8
  4067db:	00 00 00 
  4067de:	0f 05                	syscall 
  4067e0:	eb 0f                	jmp    4067f1 <__cosrt_c_capmgr_initaep_create+0x121>
  4067e2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4067e8:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  4067ef:	eb 07                	jmp    4067f8 <__cosrt_c_capmgr_initaep_create+0x128>
  4067f1:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  4067f8:	5d                   	pop    rbp
  4067f9:	5c                   	pop    rsp
  4067fa:	48 89 75 b0          	mov    QWORD PTR [rbp-0x50],rsi
  4067fe:	48 89 7d b8          	mov    QWORD PTR [rbp-0x48],rdi
	return ret;
  406802:	e9 27 ff ff ff       	jmp    40672e <__cosrt_c_capmgr_initaep_create+0x5e>
  406807:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40680e:	00 00 

0000000000406810 <__cosrt_extern_capmgr_initthd_create>:
  406810:	48 b8 fc c0 45 00 00 	movabs rax,0x45c0fc
  406817:	00 00 00 
  40681a:	ff 10                	call   QWORD PTR [rax]
  40681c:	c3                   	ret    
  40681d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000406820 <__cosrt_fast_callgate_capmgr_initthd_create>:
  406820:	55                   	push   rbp
  406821:	53                   	push   rbx
  406822:	41 54                	push   r12
  406824:	41 55                	push   r13
  406826:	41 56                	push   r14
  406828:	41 57                	push   r15
  40682a:	4d 89 c4             	mov    r12,r8
  40682d:	4c 89 cb             	mov    rbx,r9
  406830:	49 89 c8             	mov    r8,rcx
  406833:	49 89 d1             	mov    r9,rdx
  406836:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40683d:	be ad de 
  406840:	0f 01 f9             	rdtscp 
  406843:	48 89 ca             	mov    rdx,rcx
  406846:	48 25 ff 0f 00 00    	and    rax,0xfff
  40684c:	48 89 e2             	mov    rdx,rsp
  40684f:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  406856:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40685d:	00 
  40685e:	48 c1 e0 10          	shl    rax,0x10
  406862:	49 09 c5             	or     r13,rax
  406865:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40686c:	7f 00 00 
  40686f:	4c 89 e8             	mov    rax,r13
  406872:	48 25 ff ff 00 00    	and    rax,0xffff
  406878:	48 c1 e0 08          	shl    rax,0x8
  40687c:	49 01 c6             	add    r14,rax
  40687f:	b9 01 00 00 00       	mov    ecx,0x1
  406884:	01 c9                	add    ecx,ecx
  406886:	b8 03 00 00 00       	mov    eax,0x3
  40688b:	d3 e0                	shl    eax,cl
  40688d:	f7 d0                	not    eax
  40688f:	83 e0 fc             	and    eax,0xfffffffc
  406892:	48 31 c9             	xor    rcx,rcx
  406895:	48 31 d2             	xor    rdx,rdx
  406898:	0f 01 ef             	wrpkru 
  40689b:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40689e:	48 83 c2 01          	add    rdx,0x1
  4068a2:	48 c1 e2 04          	shl    rdx,0x4
  4068a6:	4c 01 f2             	add    rdx,r14
  4068a9:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  4068b0:	45 23 01 
  4068b3:	48 89 02             	mov    QWORD PTR [rdx],rax
  4068b6:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  4068ba:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4068bd:	48 83 c0 01          	add    rax,0x1
  4068c1:	49 89 06             	mov    QWORD PTR [r14],rax
  4068c4:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4068c9:	01 c9                	add    ecx,ecx
  4068cb:	b8 03 00 00 00       	mov    eax,0x3
  4068d0:	d3 e0                	shl    eax,cl
  4068d2:	f7 d0                	not    eax
  4068d4:	83 e0 fc             	and    eax,0xfffffffc
  4068d7:	48 31 c9             	xor    rcx,rcx
  4068da:	48 31 d2             	xor    rdx,rdx
  4068dd:	0f 01 ef             	wrpkru 
  4068e0:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  4068e7:	45 23 01 
  4068ea:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4068f1:	be ad de 
  4068f4:	49 39 c7             	cmp    r15,rax
  4068f7:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  4068fe:	12 12 12 
  406901:	48 b9 0d 69 40 00 00 	movabs rcx,0x40690d
  406908:	00 00 00 
  40690b:	ff e0                	jmp    rax

000000000040690d <srv_call_ret_capmgr_initthd_create>:
  40690d:	49 89 c0             	mov    r8,rax
  406910:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  406917:	be ad de 
  40691a:	48 89 e2             	mov    rdx,rsp
  40691d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  406924:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40692b:	00 
  40692c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  406933:	7f 00 00 
  406936:	4c 89 e8             	mov    rax,r13
  406939:	48 25 ff ff 00 00    	and    rax,0xffff
  40693f:	48 c1 e0 08          	shl    rax,0x8
  406943:	49 01 c6             	add    r14,rax
  406946:	b9 01 00 00 00       	mov    ecx,0x1
  40694b:	01 c9                	add    ecx,ecx
  40694d:	b8 03 00 00 00       	mov    eax,0x3
  406952:	d3 e0                	shl    eax,cl
  406954:	f7 d0                	not    eax
  406956:	83 e0 fc             	and    eax,0xfffffffc
  406959:	48 31 c9             	xor    rcx,rcx
  40695c:	48 31 d2             	xor    rdx,rdx
  40695f:	0f 01 ef             	wrpkru 
  406962:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  406965:	48 c1 e2 04          	shl    rdx,0x4
  406969:	4c 01 f2             	add    rdx,r14
  40696c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  406970:	49 8b 06             	mov    rax,QWORD PTR [r14]
  406973:	48 83 e8 01          	sub    rax,0x1
  406977:	49 89 06             	mov    QWORD PTR [r14],rax
  40697a:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40697f:	01 c9                	add    ecx,ecx
  406981:	b8 03 00 00 00       	mov    eax,0x3
  406986:	d3 e0                	shl    eax,cl
  406988:	f7 d0                	not    eax
  40698a:	83 e0 fc             	and    eax,0xfffffffc
  40698d:	48 31 c9             	xor    rcx,rcx
  406990:	48 31 d2             	xor    rdx,rdx
  406993:	0f 01 ef             	wrpkru 
  406996:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40699d:	be ad de 
  4069a0:	49 39 c7             	cmp    r15,rax
  4069a3:	4c 89 c0             	mov    rax,r8
  4069a6:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  4069aa:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  4069ad:	41 5f                	pop    r15
  4069af:	41 5e                	pop    r14
  4069b1:	41 5d                	pop    r13
  4069b3:	41 5c                	pop    r12
  4069b5:	5b                   	pop    rbx
  4069b6:	5d                   	pop    rbp
  4069b7:	c3                   	ret    
  4069b8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4069bf:	00 

00000000004069c0 <__cosrt_extern_capmgr_thd_create_thunk>:
  4069c0:	48 b8 14 c1 45 00 00 	movabs rax,0x45c114
  4069c7:	00 00 00 
  4069ca:	ff 10                	call   QWORD PTR [rax]
  4069cc:	c3                   	ret    
  4069cd:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004069d0 <__cosrt_fast_callgate_capmgr_thd_create_thunk>:
  4069d0:	55                   	push   rbp
  4069d1:	53                   	push   rbx
  4069d2:	41 54                	push   r12
  4069d4:	41 55                	push   r13
  4069d6:	41 56                	push   r14
  4069d8:	41 57                	push   r15
  4069da:	4d 89 c4             	mov    r12,r8
  4069dd:	4c 89 cb             	mov    rbx,r9
  4069e0:	49 89 c8             	mov    r8,rcx
  4069e3:	49 89 d1             	mov    r9,rdx
  4069e6:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4069ed:	be ad de 
  4069f0:	0f 01 f9             	rdtscp 
  4069f3:	48 89 ca             	mov    rdx,rcx
  4069f6:	48 25 ff 0f 00 00    	and    rax,0xfff
  4069fc:	48 89 e2             	mov    rdx,rsp
  4069ff:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  406a06:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  406a0d:	00 
  406a0e:	48 c1 e0 10          	shl    rax,0x10
  406a12:	49 09 c5             	or     r13,rax
  406a15:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  406a1c:	7f 00 00 
  406a1f:	4c 89 e8             	mov    rax,r13
  406a22:	48 25 ff ff 00 00    	and    rax,0xffff
  406a28:	48 c1 e0 08          	shl    rax,0x8
  406a2c:	49 01 c6             	add    r14,rax
  406a2f:	b9 01 00 00 00       	mov    ecx,0x1
  406a34:	01 c9                	add    ecx,ecx
  406a36:	b8 03 00 00 00       	mov    eax,0x3
  406a3b:	d3 e0                	shl    eax,cl
  406a3d:	f7 d0                	not    eax
  406a3f:	83 e0 fc             	and    eax,0xfffffffc
  406a42:	48 31 c9             	xor    rcx,rcx
  406a45:	48 31 d2             	xor    rdx,rdx
  406a48:	0f 01 ef             	wrpkru 
  406a4b:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  406a4e:	48 83 c2 01          	add    rdx,0x1
  406a52:	48 c1 e2 04          	shl    rdx,0x4
  406a56:	4c 01 f2             	add    rdx,r14
  406a59:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  406a60:	45 23 01 
  406a63:	48 89 02             	mov    QWORD PTR [rdx],rax
  406a66:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  406a6a:	49 8b 06             	mov    rax,QWORD PTR [r14]
  406a6d:	48 83 c0 01          	add    rax,0x1
  406a71:	49 89 06             	mov    QWORD PTR [r14],rax
  406a74:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  406a79:	01 c9                	add    ecx,ecx
  406a7b:	b8 03 00 00 00       	mov    eax,0x3
  406a80:	d3 e0                	shl    eax,cl
  406a82:	f7 d0                	not    eax
  406a84:	83 e0 fc             	and    eax,0xfffffffc
  406a87:	48 31 c9             	xor    rcx,rcx
  406a8a:	48 31 d2             	xor    rdx,rdx
  406a8d:	0f 01 ef             	wrpkru 
  406a90:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  406a97:	45 23 01 
  406a9a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  406aa1:	be ad de 
  406aa4:	49 39 c7             	cmp    r15,rax
  406aa7:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  406aae:	12 12 12 
  406ab1:	48 b9 bd 6a 40 00 00 	movabs rcx,0x406abd
  406ab8:	00 00 00 
  406abb:	ff e0                	jmp    rax

0000000000406abd <srv_call_ret_capmgr_thd_create_thunk>:
  406abd:	49 89 c0             	mov    r8,rax
  406ac0:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  406ac7:	be ad de 
  406aca:	48 89 e2             	mov    rdx,rsp
  406acd:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  406ad4:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  406adb:	00 
  406adc:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  406ae3:	7f 00 00 
  406ae6:	4c 89 e8             	mov    rax,r13
  406ae9:	48 25 ff ff 00 00    	and    rax,0xffff
  406aef:	48 c1 e0 08          	shl    rax,0x8
  406af3:	49 01 c6             	add    r14,rax
  406af6:	b9 01 00 00 00       	mov    ecx,0x1
  406afb:	01 c9                	add    ecx,ecx
  406afd:	b8 03 00 00 00       	mov    eax,0x3
  406b02:	d3 e0                	shl    eax,cl
  406b04:	f7 d0                	not    eax
  406b06:	83 e0 fc             	and    eax,0xfffffffc
  406b09:	48 31 c9             	xor    rcx,rcx
  406b0c:	48 31 d2             	xor    rdx,rdx
  406b0f:	0f 01 ef             	wrpkru 
  406b12:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  406b15:	48 c1 e2 04          	shl    rdx,0x4
  406b19:	4c 01 f2             	add    rdx,r14
  406b1c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  406b20:	49 8b 06             	mov    rax,QWORD PTR [r14]
  406b23:	48 83 e8 01          	sub    rax,0x1
  406b27:	49 89 06             	mov    QWORD PTR [r14],rax
  406b2a:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  406b2f:	01 c9                	add    ecx,ecx
  406b31:	b8 03 00 00 00       	mov    eax,0x3
  406b36:	d3 e0                	shl    eax,cl
  406b38:	f7 d0                	not    eax
  406b3a:	83 e0 fc             	and    eax,0xfffffffc
  406b3d:	48 31 c9             	xor    rcx,rcx
  406b40:	48 31 d2             	xor    rdx,rdx
  406b43:	0f 01 ef             	wrpkru 
  406b46:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  406b4d:	be ad de 
  406b50:	49 39 c7             	cmp    r15,rax
  406b53:	4c 89 c0             	mov    rax,r8
  406b56:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  406b5a:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  406b5d:	41 5f                	pop    r15
  406b5f:	41 5e                	pop    r14
  406b61:	41 5d                	pop    r13
  406b63:	41 5c                	pop    r12
  406b65:	5b                   	pop    rbx
  406b66:	5d                   	pop    rbp
  406b67:	c3                   	ret    
  406b68:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  406b6f:	00 

0000000000406b70 <__cosrt_extern_capmgr_thd_create_ext>:
  406b70:	48 b8 2c c1 45 00 00 	movabs rax,0x45c12c
  406b77:	00 00 00 
  406b7a:	ff 10                	call   QWORD PTR [rax]
  406b7c:	c3                   	ret    
  406b7d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000406b80 <__cosrt_fast_callgate_capmgr_thd_create_ext>:
  406b80:	55                   	push   rbp
  406b81:	53                   	push   rbx
  406b82:	41 54                	push   r12
  406b84:	41 55                	push   r13
  406b86:	41 56                	push   r14
  406b88:	41 57                	push   r15
  406b8a:	4d 89 c4             	mov    r12,r8
  406b8d:	4c 89 cb             	mov    rbx,r9
  406b90:	49 89 c8             	mov    r8,rcx
  406b93:	49 89 d1             	mov    r9,rdx
  406b96:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  406b9d:	be ad de 
  406ba0:	0f 01 f9             	rdtscp 
  406ba3:	48 89 ca             	mov    rdx,rcx
  406ba6:	48 25 ff 0f 00 00    	and    rax,0xfff
  406bac:	48 89 e2             	mov    rdx,rsp
  406baf:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  406bb6:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  406bbd:	00 
  406bbe:	48 c1 e0 10          	shl    rax,0x10
  406bc2:	49 09 c5             	or     r13,rax
  406bc5:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  406bcc:	7f 00 00 
  406bcf:	4c 89 e8             	mov    rax,r13
  406bd2:	48 25 ff ff 00 00    	and    rax,0xffff
  406bd8:	48 c1 e0 08          	shl    rax,0x8
  406bdc:	49 01 c6             	add    r14,rax
  406bdf:	b9 01 00 00 00       	mov    ecx,0x1
  406be4:	01 c9                	add    ecx,ecx
  406be6:	b8 03 00 00 00       	mov    eax,0x3
  406beb:	d3 e0                	shl    eax,cl
  406bed:	f7 d0                	not    eax
  406bef:	83 e0 fc             	and    eax,0xfffffffc
  406bf2:	48 31 c9             	xor    rcx,rcx
  406bf5:	48 31 d2             	xor    rdx,rdx
  406bf8:	0f 01 ef             	wrpkru 
  406bfb:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  406bfe:	48 83 c2 01          	add    rdx,0x1
  406c02:	48 c1 e2 04          	shl    rdx,0x4
  406c06:	4c 01 f2             	add    rdx,r14
  406c09:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  406c10:	45 23 01 
  406c13:	48 89 02             	mov    QWORD PTR [rdx],rax
  406c16:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  406c1a:	49 8b 06             	mov    rax,QWORD PTR [r14]
  406c1d:	48 83 c0 01          	add    rax,0x1
  406c21:	49 89 06             	mov    QWORD PTR [r14],rax
  406c24:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  406c29:	01 c9                	add    ecx,ecx
  406c2b:	b8 03 00 00 00       	mov    eax,0x3
  406c30:	d3 e0                	shl    eax,cl
  406c32:	f7 d0                	not    eax
  406c34:	83 e0 fc             	and    eax,0xfffffffc
  406c37:	48 31 c9             	xor    rcx,rcx
  406c3a:	48 31 d2             	xor    rdx,rdx
  406c3d:	0f 01 ef             	wrpkru 
  406c40:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  406c47:	45 23 01 
  406c4a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  406c51:	be ad de 
  406c54:	49 39 c7             	cmp    r15,rax
  406c57:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  406c5e:	12 12 12 
  406c61:	48 b9 6d 6c 40 00 00 	movabs rcx,0x406c6d
  406c68:	00 00 00 
  406c6b:	ff e0                	jmp    rax

0000000000406c6d <srv_call_ret_capmgr_thd_create_ext>:
  406c6d:	49 89 c0             	mov    r8,rax
  406c70:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  406c77:	be ad de 
  406c7a:	48 89 e2             	mov    rdx,rsp
  406c7d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  406c84:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  406c8b:	00 
  406c8c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  406c93:	7f 00 00 
  406c96:	4c 89 e8             	mov    rax,r13
  406c99:	48 25 ff ff 00 00    	and    rax,0xffff
  406c9f:	48 c1 e0 08          	shl    rax,0x8
  406ca3:	49 01 c6             	add    r14,rax
  406ca6:	b9 01 00 00 00       	mov    ecx,0x1
  406cab:	01 c9                	add    ecx,ecx
  406cad:	b8 03 00 00 00       	mov    eax,0x3
  406cb2:	d3 e0                	shl    eax,cl
  406cb4:	f7 d0                	not    eax
  406cb6:	83 e0 fc             	and    eax,0xfffffffc
  406cb9:	48 31 c9             	xor    rcx,rcx
  406cbc:	48 31 d2             	xor    rdx,rdx
  406cbf:	0f 01 ef             	wrpkru 
  406cc2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  406cc5:	48 c1 e2 04          	shl    rdx,0x4
  406cc9:	4c 01 f2             	add    rdx,r14
  406ccc:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  406cd0:	49 8b 06             	mov    rax,QWORD PTR [r14]
  406cd3:	48 83 e8 01          	sub    rax,0x1
  406cd7:	49 89 06             	mov    QWORD PTR [r14],rax
  406cda:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  406cdf:	01 c9                	add    ecx,ecx
  406ce1:	b8 03 00 00 00       	mov    eax,0x3
  406ce6:	d3 e0                	shl    eax,cl
  406ce8:	f7 d0                	not    eax
  406cea:	83 e0 fc             	and    eax,0xfffffffc
  406ced:	48 31 c9             	xor    rcx,rcx
  406cf0:	48 31 d2             	xor    rdx,rdx
  406cf3:	0f 01 ef             	wrpkru 
  406cf6:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  406cfd:	be ad de 
  406d00:	49 39 c7             	cmp    r15,rax
  406d03:	4c 89 c0             	mov    rax,r8
  406d06:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  406d0a:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  406d0d:	41 5f                	pop    r15
  406d0f:	41 5e                	pop    r14
  406d11:	41 5d                	pop    r13
  406d13:	41 5c                	pop    r12
  406d15:	5b                   	pop    rbx
  406d16:	5d                   	pop    rbp
  406d17:	c3                   	ret    
  406d18:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  406d1f:	00 

0000000000406d20 <__cosrt_extern_capmgr_initaep_create>:
  406d20:	48 b8 44 c1 45 00 00 	movabs rax,0x45c144
  406d27:	00 00 00 
  406d2a:	ff 10                	call   QWORD PTR [rax]
  406d2c:	c3                   	ret    
  406d2d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000406d30 <__cosrt_fast_callgate_capmgr_initaep_create>:
  406d30:	55                   	push   rbp
  406d31:	53                   	push   rbx
  406d32:	41 54                	push   r12
  406d34:	41 55                	push   r13
  406d36:	41 56                	push   r14
  406d38:	41 57                	push   r15
  406d3a:	4d 89 c4             	mov    r12,r8
  406d3d:	4c 89 cb             	mov    rbx,r9
  406d40:	49 89 c8             	mov    r8,rcx
  406d43:	49 89 d1             	mov    r9,rdx
  406d46:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  406d4d:	be ad de 
  406d50:	0f 01 f9             	rdtscp 
  406d53:	48 89 ca             	mov    rdx,rcx
  406d56:	48 25 ff 0f 00 00    	and    rax,0xfff
  406d5c:	48 89 e2             	mov    rdx,rsp
  406d5f:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  406d66:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  406d6d:	00 
  406d6e:	48 c1 e0 10          	shl    rax,0x10
  406d72:	49 09 c5             	or     r13,rax
  406d75:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  406d7c:	7f 00 00 
  406d7f:	4c 89 e8             	mov    rax,r13
  406d82:	48 25 ff ff 00 00    	and    rax,0xffff
  406d88:	48 c1 e0 08          	shl    rax,0x8
  406d8c:	49 01 c6             	add    r14,rax
  406d8f:	b9 01 00 00 00       	mov    ecx,0x1
  406d94:	01 c9                	add    ecx,ecx
  406d96:	b8 03 00 00 00       	mov    eax,0x3
  406d9b:	d3 e0                	shl    eax,cl
  406d9d:	f7 d0                	not    eax
  406d9f:	83 e0 fc             	and    eax,0xfffffffc
  406da2:	48 31 c9             	xor    rcx,rcx
  406da5:	48 31 d2             	xor    rdx,rdx
  406da8:	0f 01 ef             	wrpkru 
  406dab:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  406dae:	48 83 c2 01          	add    rdx,0x1
  406db2:	48 c1 e2 04          	shl    rdx,0x4
  406db6:	4c 01 f2             	add    rdx,r14
  406db9:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  406dc0:	45 23 01 
  406dc3:	48 89 02             	mov    QWORD PTR [rdx],rax
  406dc6:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  406dca:	49 8b 06             	mov    rax,QWORD PTR [r14]
  406dcd:	48 83 c0 01          	add    rax,0x1
  406dd1:	49 89 06             	mov    QWORD PTR [r14],rax
  406dd4:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  406dd9:	01 c9                	add    ecx,ecx
  406ddb:	b8 03 00 00 00       	mov    eax,0x3
  406de0:	d3 e0                	shl    eax,cl
  406de2:	f7 d0                	not    eax
  406de4:	83 e0 fc             	and    eax,0xfffffffc
  406de7:	48 31 c9             	xor    rcx,rcx
  406dea:	48 31 d2             	xor    rdx,rdx
  406ded:	0f 01 ef             	wrpkru 
  406df0:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  406df7:	45 23 01 
  406dfa:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  406e01:	be ad de 
  406e04:	49 39 c7             	cmp    r15,rax
  406e07:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  406e0e:	12 12 12 
  406e11:	48 b9 1d 6e 40 00 00 	movabs rcx,0x406e1d
  406e18:	00 00 00 
  406e1b:	ff e0                	jmp    rax

0000000000406e1d <srv_call_ret_capmgr_initaep_create>:
  406e1d:	49 89 c0             	mov    r8,rax
  406e20:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  406e27:	be ad de 
  406e2a:	48 89 e2             	mov    rdx,rsp
  406e2d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  406e34:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  406e3b:	00 
  406e3c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  406e43:	7f 00 00 
  406e46:	4c 89 e8             	mov    rax,r13
  406e49:	48 25 ff ff 00 00    	and    rax,0xffff
  406e4f:	48 c1 e0 08          	shl    rax,0x8
  406e53:	49 01 c6             	add    r14,rax
  406e56:	b9 01 00 00 00       	mov    ecx,0x1
  406e5b:	01 c9                	add    ecx,ecx
  406e5d:	b8 03 00 00 00       	mov    eax,0x3
  406e62:	d3 e0                	shl    eax,cl
  406e64:	f7 d0                	not    eax
  406e66:	83 e0 fc             	and    eax,0xfffffffc
  406e69:	48 31 c9             	xor    rcx,rcx
  406e6c:	48 31 d2             	xor    rdx,rdx
  406e6f:	0f 01 ef             	wrpkru 
  406e72:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  406e75:	48 c1 e2 04          	shl    rdx,0x4
  406e79:	4c 01 f2             	add    rdx,r14
  406e7c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  406e80:	49 8b 06             	mov    rax,QWORD PTR [r14]
  406e83:	48 83 e8 01          	sub    rax,0x1
  406e87:	49 89 06             	mov    QWORD PTR [r14],rax
  406e8a:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  406e8f:	01 c9                	add    ecx,ecx
  406e91:	b8 03 00 00 00       	mov    eax,0x3
  406e96:	d3 e0                	shl    eax,cl
  406e98:	f7 d0                	not    eax
  406e9a:	83 e0 fc             	and    eax,0xfffffffc
  406e9d:	48 31 c9             	xor    rcx,rcx
  406ea0:	48 31 d2             	xor    rdx,rdx
  406ea3:	0f 01 ef             	wrpkru 
  406ea6:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  406ead:	be ad de 
  406eb0:	49 39 c7             	cmp    r15,rax
  406eb3:	4c 89 c0             	mov    rax,r8
  406eb6:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  406eba:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  406ebd:	41 5f                	pop    r15
  406ebf:	41 5e                	pop    r14
  406ec1:	41 5d                	pop    r13
  406ec3:	41 5c                	pop    r12
  406ec5:	5b                   	pop    rbx
  406ec6:	5d                   	pop    rbp
  406ec7:	c3                   	ret    
  406ec8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  406ecf:	00 

0000000000406ed0 <__cosrt_extern_capmgr_aep_create_thunk>:
  406ed0:	48 b8 5c c1 45 00 00 	movabs rax,0x45c15c
  406ed7:	00 00 00 
  406eda:	ff 10                	call   QWORD PTR [rax]
  406edc:	c3                   	ret    
  406edd:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000406ee0 <__cosrt_fast_callgate_capmgr_aep_create_thunk>:
  406ee0:	55                   	push   rbp
  406ee1:	53                   	push   rbx
  406ee2:	41 54                	push   r12
  406ee4:	41 55                	push   r13
  406ee6:	41 56                	push   r14
  406ee8:	41 57                	push   r15
  406eea:	4d 89 c4             	mov    r12,r8
  406eed:	4c 89 cb             	mov    rbx,r9
  406ef0:	49 89 c8             	mov    r8,rcx
  406ef3:	49 89 d1             	mov    r9,rdx
  406ef6:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  406efd:	be ad de 
  406f00:	0f 01 f9             	rdtscp 
  406f03:	48 89 ca             	mov    rdx,rcx
  406f06:	48 25 ff 0f 00 00    	and    rax,0xfff
  406f0c:	48 89 e2             	mov    rdx,rsp
  406f0f:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  406f16:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  406f1d:	00 
  406f1e:	48 c1 e0 10          	shl    rax,0x10
  406f22:	49 09 c5             	or     r13,rax
  406f25:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  406f2c:	7f 00 00 
  406f2f:	4c 89 e8             	mov    rax,r13
  406f32:	48 25 ff ff 00 00    	and    rax,0xffff
  406f38:	48 c1 e0 08          	shl    rax,0x8
  406f3c:	49 01 c6             	add    r14,rax
  406f3f:	b9 01 00 00 00       	mov    ecx,0x1
  406f44:	01 c9                	add    ecx,ecx
  406f46:	b8 03 00 00 00       	mov    eax,0x3
  406f4b:	d3 e0                	shl    eax,cl
  406f4d:	f7 d0                	not    eax
  406f4f:	83 e0 fc             	and    eax,0xfffffffc
  406f52:	48 31 c9             	xor    rcx,rcx
  406f55:	48 31 d2             	xor    rdx,rdx
  406f58:	0f 01 ef             	wrpkru 
  406f5b:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  406f5e:	48 83 c2 01          	add    rdx,0x1
  406f62:	48 c1 e2 04          	shl    rdx,0x4
  406f66:	4c 01 f2             	add    rdx,r14
  406f69:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  406f70:	45 23 01 
  406f73:	48 89 02             	mov    QWORD PTR [rdx],rax
  406f76:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  406f7a:	49 8b 06             	mov    rax,QWORD PTR [r14]
  406f7d:	48 83 c0 01          	add    rax,0x1
  406f81:	49 89 06             	mov    QWORD PTR [r14],rax
  406f84:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  406f89:	01 c9                	add    ecx,ecx
  406f8b:	b8 03 00 00 00       	mov    eax,0x3
  406f90:	d3 e0                	shl    eax,cl
  406f92:	f7 d0                	not    eax
  406f94:	83 e0 fc             	and    eax,0xfffffffc
  406f97:	48 31 c9             	xor    rcx,rcx
  406f9a:	48 31 d2             	xor    rdx,rdx
  406f9d:	0f 01 ef             	wrpkru 
  406fa0:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  406fa7:	45 23 01 
  406faa:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  406fb1:	be ad de 
  406fb4:	49 39 c7             	cmp    r15,rax
  406fb7:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  406fbe:	12 12 12 
  406fc1:	48 b9 cd 6f 40 00 00 	movabs rcx,0x406fcd
  406fc8:	00 00 00 
  406fcb:	ff e0                	jmp    rax

0000000000406fcd <srv_call_ret_capmgr_aep_create_thunk>:
  406fcd:	49 89 c0             	mov    r8,rax
  406fd0:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  406fd7:	be ad de 
  406fda:	48 89 e2             	mov    rdx,rsp
  406fdd:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  406fe4:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  406feb:	00 
  406fec:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  406ff3:	7f 00 00 
  406ff6:	4c 89 e8             	mov    rax,r13
  406ff9:	48 25 ff ff 00 00    	and    rax,0xffff
  406fff:	48 c1 e0 08          	shl    rax,0x8
  407003:	49 01 c6             	add    r14,rax
  407006:	b9 01 00 00 00       	mov    ecx,0x1
  40700b:	01 c9                	add    ecx,ecx
  40700d:	b8 03 00 00 00       	mov    eax,0x3
  407012:	d3 e0                	shl    eax,cl
  407014:	f7 d0                	not    eax
  407016:	83 e0 fc             	and    eax,0xfffffffc
  407019:	48 31 c9             	xor    rcx,rcx
  40701c:	48 31 d2             	xor    rdx,rdx
  40701f:	0f 01 ef             	wrpkru 
  407022:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  407025:	48 c1 e2 04          	shl    rdx,0x4
  407029:	4c 01 f2             	add    rdx,r14
  40702c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  407030:	49 8b 06             	mov    rax,QWORD PTR [r14]
  407033:	48 83 e8 01          	sub    rax,0x1
  407037:	49 89 06             	mov    QWORD PTR [r14],rax
  40703a:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40703f:	01 c9                	add    ecx,ecx
  407041:	b8 03 00 00 00       	mov    eax,0x3
  407046:	d3 e0                	shl    eax,cl
  407048:	f7 d0                	not    eax
  40704a:	83 e0 fc             	and    eax,0xfffffffc
  40704d:	48 31 c9             	xor    rcx,rcx
  407050:	48 31 d2             	xor    rdx,rdx
  407053:	0f 01 ef             	wrpkru 
  407056:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40705d:	be ad de 
  407060:	49 39 c7             	cmp    r15,rax
  407063:	4c 89 c0             	mov    rax,r8
  407066:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  40706a:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  40706d:	41 5f                	pop    r15
  40706f:	41 5e                	pop    r14
  407071:	41 5d                	pop    r13
  407073:	41 5c                	pop    r12
  407075:	5b                   	pop    rbx
  407076:	5d                   	pop    rbp
  407077:	c3                   	ret    
  407078:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40707f:	00 

0000000000407080 <__cosrt_extern_capmgr_aep_create_ext>:
  407080:	48 b8 74 c1 45 00 00 	movabs rax,0x45c174
  407087:	00 00 00 
  40708a:	ff 10                	call   QWORD PTR [rax]
  40708c:	c3                   	ret    
  40708d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000407090 <__cosrt_fast_callgate_capmgr_aep_create_ext>:
  407090:	55                   	push   rbp
  407091:	53                   	push   rbx
  407092:	41 54                	push   r12
  407094:	41 55                	push   r13
  407096:	41 56                	push   r14
  407098:	41 57                	push   r15
  40709a:	4d 89 c4             	mov    r12,r8
  40709d:	4c 89 cb             	mov    rbx,r9
  4070a0:	49 89 c8             	mov    r8,rcx
  4070a3:	49 89 d1             	mov    r9,rdx
  4070a6:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4070ad:	be ad de 
  4070b0:	0f 01 f9             	rdtscp 
  4070b3:	48 89 ca             	mov    rdx,rcx
  4070b6:	48 25 ff 0f 00 00    	and    rax,0xfff
  4070bc:	48 89 e2             	mov    rdx,rsp
  4070bf:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4070c6:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4070cd:	00 
  4070ce:	48 c1 e0 10          	shl    rax,0x10
  4070d2:	49 09 c5             	or     r13,rax
  4070d5:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4070dc:	7f 00 00 
  4070df:	4c 89 e8             	mov    rax,r13
  4070e2:	48 25 ff ff 00 00    	and    rax,0xffff
  4070e8:	48 c1 e0 08          	shl    rax,0x8
  4070ec:	49 01 c6             	add    r14,rax
  4070ef:	b9 01 00 00 00       	mov    ecx,0x1
  4070f4:	01 c9                	add    ecx,ecx
  4070f6:	b8 03 00 00 00       	mov    eax,0x3
  4070fb:	d3 e0                	shl    eax,cl
  4070fd:	f7 d0                	not    eax
  4070ff:	83 e0 fc             	and    eax,0xfffffffc
  407102:	48 31 c9             	xor    rcx,rcx
  407105:	48 31 d2             	xor    rdx,rdx
  407108:	0f 01 ef             	wrpkru 
  40710b:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40710e:	48 83 c2 01          	add    rdx,0x1
  407112:	48 c1 e2 04          	shl    rdx,0x4
  407116:	4c 01 f2             	add    rdx,r14
  407119:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  407120:	45 23 01 
  407123:	48 89 02             	mov    QWORD PTR [rdx],rax
  407126:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  40712a:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40712d:	48 83 c0 01          	add    rax,0x1
  407131:	49 89 06             	mov    QWORD PTR [r14],rax
  407134:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407139:	01 c9                	add    ecx,ecx
  40713b:	b8 03 00 00 00       	mov    eax,0x3
  407140:	d3 e0                	shl    eax,cl
  407142:	f7 d0                	not    eax
  407144:	83 e0 fc             	and    eax,0xfffffffc
  407147:	48 31 c9             	xor    rcx,rcx
  40714a:	48 31 d2             	xor    rdx,rdx
  40714d:	0f 01 ef             	wrpkru 
  407150:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  407157:	45 23 01 
  40715a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407161:	be ad de 
  407164:	49 39 c7             	cmp    r15,rax
  407167:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  40716e:	12 12 12 
  407171:	48 b9 7d 71 40 00 00 	movabs rcx,0x40717d
  407178:	00 00 00 
  40717b:	ff e0                	jmp    rax

000000000040717d <srv_call_ret_capmgr_aep_create_ext>:
  40717d:	49 89 c0             	mov    r8,rax
  407180:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  407187:	be ad de 
  40718a:	48 89 e2             	mov    rdx,rsp
  40718d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  407194:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40719b:	00 
  40719c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4071a3:	7f 00 00 
  4071a6:	4c 89 e8             	mov    rax,r13
  4071a9:	48 25 ff ff 00 00    	and    rax,0xffff
  4071af:	48 c1 e0 08          	shl    rax,0x8
  4071b3:	49 01 c6             	add    r14,rax
  4071b6:	b9 01 00 00 00       	mov    ecx,0x1
  4071bb:	01 c9                	add    ecx,ecx
  4071bd:	b8 03 00 00 00       	mov    eax,0x3
  4071c2:	d3 e0                	shl    eax,cl
  4071c4:	f7 d0                	not    eax
  4071c6:	83 e0 fc             	and    eax,0xfffffffc
  4071c9:	48 31 c9             	xor    rcx,rcx
  4071cc:	48 31 d2             	xor    rdx,rdx
  4071cf:	0f 01 ef             	wrpkru 
  4071d2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4071d5:	48 c1 e2 04          	shl    rdx,0x4
  4071d9:	4c 01 f2             	add    rdx,r14
  4071dc:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  4071e0:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4071e3:	48 83 e8 01          	sub    rax,0x1
  4071e7:	49 89 06             	mov    QWORD PTR [r14],rax
  4071ea:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4071ef:	01 c9                	add    ecx,ecx
  4071f1:	b8 03 00 00 00       	mov    eax,0x3
  4071f6:	d3 e0                	shl    eax,cl
  4071f8:	f7 d0                	not    eax
  4071fa:	83 e0 fc             	and    eax,0xfffffffc
  4071fd:	48 31 c9             	xor    rcx,rcx
  407200:	48 31 d2             	xor    rdx,rdx
  407203:	0f 01 ef             	wrpkru 
  407206:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40720d:	be ad de 
  407210:	49 39 c7             	cmp    r15,rax
  407213:	4c 89 c0             	mov    rax,r8
  407216:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  40721a:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  40721d:	41 5f                	pop    r15
  40721f:	41 5e                	pop    r14
  407221:	41 5d                	pop    r13
  407223:	41 5c                	pop    r12
  407225:	5b                   	pop    rbx
  407226:	5d                   	pop    rbp
  407227:	c3                   	ret    
  407228:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40722f:	00 

0000000000407230 <__cosrt_extern_capmgr_rcv_create>:
  407230:	48 b8 8c c1 45 00 00 	movabs rax,0x45c18c
  407237:	00 00 00 
  40723a:	ff 10                	call   QWORD PTR [rax]
  40723c:	c3                   	ret    
  40723d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000407240 <__cosrt_fast_callgate_capmgr_rcv_create>:
  407240:	55                   	push   rbp
  407241:	53                   	push   rbx
  407242:	41 54                	push   r12
  407244:	41 55                	push   r13
  407246:	41 56                	push   r14
  407248:	41 57                	push   r15
  40724a:	4d 89 c4             	mov    r12,r8
  40724d:	4c 89 cb             	mov    rbx,r9
  407250:	49 89 c8             	mov    r8,rcx
  407253:	49 89 d1             	mov    r9,rdx
  407256:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40725d:	be ad de 
  407260:	0f 01 f9             	rdtscp 
  407263:	48 89 ca             	mov    rdx,rcx
  407266:	48 25 ff 0f 00 00    	and    rax,0xfff
  40726c:	48 89 e2             	mov    rdx,rsp
  40726f:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  407276:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40727d:	00 
  40727e:	48 c1 e0 10          	shl    rax,0x10
  407282:	49 09 c5             	or     r13,rax
  407285:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40728c:	7f 00 00 
  40728f:	4c 89 e8             	mov    rax,r13
  407292:	48 25 ff ff 00 00    	and    rax,0xffff
  407298:	48 c1 e0 08          	shl    rax,0x8
  40729c:	49 01 c6             	add    r14,rax
  40729f:	b9 01 00 00 00       	mov    ecx,0x1
  4072a4:	01 c9                	add    ecx,ecx
  4072a6:	b8 03 00 00 00       	mov    eax,0x3
  4072ab:	d3 e0                	shl    eax,cl
  4072ad:	f7 d0                	not    eax
  4072af:	83 e0 fc             	and    eax,0xfffffffc
  4072b2:	48 31 c9             	xor    rcx,rcx
  4072b5:	48 31 d2             	xor    rdx,rdx
  4072b8:	0f 01 ef             	wrpkru 
  4072bb:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4072be:	48 83 c2 01          	add    rdx,0x1
  4072c2:	48 c1 e2 04          	shl    rdx,0x4
  4072c6:	4c 01 f2             	add    rdx,r14
  4072c9:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  4072d0:	45 23 01 
  4072d3:	48 89 02             	mov    QWORD PTR [rdx],rax
  4072d6:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  4072da:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4072dd:	48 83 c0 01          	add    rax,0x1
  4072e1:	49 89 06             	mov    QWORD PTR [r14],rax
  4072e4:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4072e9:	01 c9                	add    ecx,ecx
  4072eb:	b8 03 00 00 00       	mov    eax,0x3
  4072f0:	d3 e0                	shl    eax,cl
  4072f2:	f7 d0                	not    eax
  4072f4:	83 e0 fc             	and    eax,0xfffffffc
  4072f7:	48 31 c9             	xor    rcx,rcx
  4072fa:	48 31 d2             	xor    rdx,rdx
  4072fd:	0f 01 ef             	wrpkru 
  407300:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  407307:	45 23 01 
  40730a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407311:	be ad de 
  407314:	49 39 c7             	cmp    r15,rax
  407317:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  40731e:	12 12 12 
  407321:	48 b9 2d 73 40 00 00 	movabs rcx,0x40732d
  407328:	00 00 00 
  40732b:	ff e0                	jmp    rax

000000000040732d <srv_call_ret_capmgr_rcv_create>:
  40732d:	49 89 c0             	mov    r8,rax
  407330:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  407337:	be ad de 
  40733a:	48 89 e2             	mov    rdx,rsp
  40733d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  407344:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40734b:	00 
  40734c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  407353:	7f 00 00 
  407356:	4c 89 e8             	mov    rax,r13
  407359:	48 25 ff ff 00 00    	and    rax,0xffff
  40735f:	48 c1 e0 08          	shl    rax,0x8
  407363:	49 01 c6             	add    r14,rax
  407366:	b9 01 00 00 00       	mov    ecx,0x1
  40736b:	01 c9                	add    ecx,ecx
  40736d:	b8 03 00 00 00       	mov    eax,0x3
  407372:	d3 e0                	shl    eax,cl
  407374:	f7 d0                	not    eax
  407376:	83 e0 fc             	and    eax,0xfffffffc
  407379:	48 31 c9             	xor    rcx,rcx
  40737c:	48 31 d2             	xor    rdx,rdx
  40737f:	0f 01 ef             	wrpkru 
  407382:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  407385:	48 c1 e2 04          	shl    rdx,0x4
  407389:	4c 01 f2             	add    rdx,r14
  40738c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  407390:	49 8b 06             	mov    rax,QWORD PTR [r14]
  407393:	48 83 e8 01          	sub    rax,0x1
  407397:	49 89 06             	mov    QWORD PTR [r14],rax
  40739a:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40739f:	01 c9                	add    ecx,ecx
  4073a1:	b8 03 00 00 00       	mov    eax,0x3
  4073a6:	d3 e0                	shl    eax,cl
  4073a8:	f7 d0                	not    eax
  4073aa:	83 e0 fc             	and    eax,0xfffffffc
  4073ad:	48 31 c9             	xor    rcx,rcx
  4073b0:	48 31 d2             	xor    rdx,rdx
  4073b3:	0f 01 ef             	wrpkru 
  4073b6:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4073bd:	be ad de 
  4073c0:	49 39 c7             	cmp    r15,rax
  4073c3:	4c 89 c0             	mov    rax,r8
  4073c6:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  4073ca:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  4073cd:	41 5f                	pop    r15
  4073cf:	41 5e                	pop    r14
  4073d1:	41 5d                	pop    r13
  4073d3:	41 5c                	pop    r12
  4073d5:	5b                   	pop    rbx
  4073d6:	5d                   	pop    rbp
  4073d7:	c3                   	ret    
  4073d8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4073df:	00 

00000000004073e0 <__cosrt_extern_capmgr_set_tls>:
  4073e0:	48 b8 a4 c1 45 00 00 	movabs rax,0x45c1a4
  4073e7:	00 00 00 
  4073ea:	ff 10                	call   QWORD PTR [rax]
  4073ec:	c3                   	ret    
  4073ed:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004073f0 <__cosrt_fast_callgate_capmgr_set_tls>:
  4073f0:	55                   	push   rbp
  4073f1:	41 55                	push   r13
  4073f3:	41 56                	push   r14
  4073f5:	41 57                	push   r15
  4073f7:	49 89 c8             	mov    r8,rcx
  4073fa:	49 89 d1             	mov    r9,rdx
  4073fd:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  407404:	be ad de 
  407407:	0f 01 f9             	rdtscp 
  40740a:	48 89 c8             	mov    rax,rcx
  40740d:	48 25 ff 0f 00 00    	and    rax,0xfff
  407413:	48 89 e2             	mov    rdx,rsp
  407416:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40741d:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  407424:	00 
  407425:	48 c1 e0 10          	shl    rax,0x10
  407429:	49 09 c5             	or     r13,rax
  40742c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  407433:	7f 00 00 
  407436:	4c 89 e8             	mov    rax,r13
  407439:	48 25 ff ff 00 00    	and    rax,0xffff
  40743f:	48 c1 e0 08          	shl    rax,0x8
  407443:	49 01 c6             	add    r14,rax
  407446:	b9 01 00 00 00       	mov    ecx,0x1
  40744b:	01 c9                	add    ecx,ecx
  40744d:	b8 03 00 00 00       	mov    eax,0x3
  407452:	d3 e0                	shl    eax,cl
  407454:	f7 d0                	not    eax
  407456:	83 e0 fc             	and    eax,0xfffffffc
  407459:	48 31 c9             	xor    rcx,rcx
  40745c:	48 31 d2             	xor    rdx,rdx
  40745f:	0f 01 ef             	wrpkru 
  407462:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  407465:	48 83 c2 01          	add    rdx,0x1
  407469:	48 c1 e2 04          	shl    rdx,0x4
  40746d:	4c 01 f2             	add    rdx,r14
  407470:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  407477:	45 23 01 
  40747a:	48 89 02             	mov    QWORD PTR [rdx],rax
  40747d:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  407481:	49 8b 06             	mov    rax,QWORD PTR [r14]
  407484:	48 83 c0 01          	add    rax,0x1
  407488:	49 89 06             	mov    QWORD PTR [r14],rax
  40748b:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407490:	01 c9                	add    ecx,ecx
  407492:	b8 03 00 00 00       	mov    eax,0x3
  407497:	d3 e0                	shl    eax,cl
  407499:	f7 d0                	not    eax
  40749b:	83 e0 fc             	and    eax,0xfffffffc
  40749e:	48 31 c9             	xor    rcx,rcx
  4074a1:	48 31 d2             	xor    rdx,rdx
  4074a4:	0f 01 ef             	wrpkru 
  4074a7:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  4074ae:	45 23 01 
  4074b1:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4074b8:	be ad de 
  4074bb:	49 39 c7             	cmp    r15,rax
  4074be:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  4074c5:	12 12 12 
  4074c8:	48 b9 d4 74 40 00 00 	movabs rcx,0x4074d4
  4074cf:	00 00 00 
  4074d2:	ff e0                	jmp    rax

00000000004074d4 <srv_call_ret_capmgr_set_tls>:
  4074d4:	49 89 c0             	mov    r8,rax
  4074d7:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4074de:	be ad de 
  4074e1:	48 89 e2             	mov    rdx,rsp
  4074e4:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4074eb:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4074f2:	00 
  4074f3:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4074fa:	7f 00 00 
  4074fd:	4c 89 e8             	mov    rax,r13
  407500:	48 25 ff ff 00 00    	and    rax,0xffff
  407506:	48 c1 e0 08          	shl    rax,0x8
  40750a:	49 01 c6             	add    r14,rax
  40750d:	b9 01 00 00 00       	mov    ecx,0x1
  407512:	01 c9                	add    ecx,ecx
  407514:	b8 03 00 00 00       	mov    eax,0x3
  407519:	d3 e0                	shl    eax,cl
  40751b:	f7 d0                	not    eax
  40751d:	83 e0 fc             	and    eax,0xfffffffc
  407520:	48 31 c9             	xor    rcx,rcx
  407523:	48 31 d2             	xor    rdx,rdx
  407526:	0f 01 ef             	wrpkru 
  407529:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40752c:	48 c1 e2 04          	shl    rdx,0x4
  407530:	4c 01 f2             	add    rdx,r14
  407533:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  407537:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40753a:	48 83 e8 01          	sub    rax,0x1
  40753e:	49 89 06             	mov    QWORD PTR [r14],rax
  407541:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407546:	01 c9                	add    ecx,ecx
  407548:	b8 03 00 00 00       	mov    eax,0x3
  40754d:	d3 e0                	shl    eax,cl
  40754f:	f7 d0                	not    eax
  407551:	83 e0 fc             	and    eax,0xfffffffc
  407554:	48 31 c9             	xor    rcx,rcx
  407557:	48 31 d2             	xor    rdx,rdx
  40755a:	0f 01 ef             	wrpkru 
  40755d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407564:	be ad de 
  407567:	49 39 c7             	cmp    r15,rax
  40756a:	4c 89 c0             	mov    rax,r8
  40756d:	41 5f                	pop    r15
  40756f:	41 5e                	pop    r14
  407571:	41 5d                	pop    r13
  407573:	5d                   	pop    rbp
  407574:	c3                   	ret    
  407575:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40757c:	00 00 00 00 

0000000000407580 <__cosrt_extern_capmgr_asnd_create>:
  407580:	48 b8 bc c1 45 00 00 	movabs rax,0x45c1bc
  407587:	00 00 00 
  40758a:	ff 10                	call   QWORD PTR [rax]
  40758c:	c3                   	ret    
  40758d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000407590 <__cosrt_fast_callgate_capmgr_asnd_create>:
  407590:	55                   	push   rbp
  407591:	41 55                	push   r13
  407593:	41 56                	push   r14
  407595:	41 57                	push   r15
  407597:	49 89 c8             	mov    r8,rcx
  40759a:	49 89 d1             	mov    r9,rdx
  40759d:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4075a4:	be ad de 
  4075a7:	0f 01 f9             	rdtscp 
  4075aa:	48 89 c8             	mov    rax,rcx
  4075ad:	48 25 ff 0f 00 00    	and    rax,0xfff
  4075b3:	48 89 e2             	mov    rdx,rsp
  4075b6:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4075bd:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4075c4:	00 
  4075c5:	48 c1 e0 10          	shl    rax,0x10
  4075c9:	49 09 c5             	or     r13,rax
  4075cc:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4075d3:	7f 00 00 
  4075d6:	4c 89 e8             	mov    rax,r13
  4075d9:	48 25 ff ff 00 00    	and    rax,0xffff
  4075df:	48 c1 e0 08          	shl    rax,0x8
  4075e3:	49 01 c6             	add    r14,rax
  4075e6:	b9 01 00 00 00       	mov    ecx,0x1
  4075eb:	01 c9                	add    ecx,ecx
  4075ed:	b8 03 00 00 00       	mov    eax,0x3
  4075f2:	d3 e0                	shl    eax,cl
  4075f4:	f7 d0                	not    eax
  4075f6:	83 e0 fc             	and    eax,0xfffffffc
  4075f9:	48 31 c9             	xor    rcx,rcx
  4075fc:	48 31 d2             	xor    rdx,rdx
  4075ff:	0f 01 ef             	wrpkru 
  407602:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  407605:	48 83 c2 01          	add    rdx,0x1
  407609:	48 c1 e2 04          	shl    rdx,0x4
  40760d:	4c 01 f2             	add    rdx,r14
  407610:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  407617:	45 23 01 
  40761a:	48 89 02             	mov    QWORD PTR [rdx],rax
  40761d:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  407621:	49 8b 06             	mov    rax,QWORD PTR [r14]
  407624:	48 83 c0 01          	add    rax,0x1
  407628:	49 89 06             	mov    QWORD PTR [r14],rax
  40762b:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407630:	01 c9                	add    ecx,ecx
  407632:	b8 03 00 00 00       	mov    eax,0x3
  407637:	d3 e0                	shl    eax,cl
  407639:	f7 d0                	not    eax
  40763b:	83 e0 fc             	and    eax,0xfffffffc
  40763e:	48 31 c9             	xor    rcx,rcx
  407641:	48 31 d2             	xor    rdx,rdx
  407644:	0f 01 ef             	wrpkru 
  407647:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  40764e:	45 23 01 
  407651:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407658:	be ad de 
  40765b:	49 39 c7             	cmp    r15,rax
  40765e:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  407665:	12 12 12 
  407668:	48 b9 74 76 40 00 00 	movabs rcx,0x407674
  40766f:	00 00 00 
  407672:	ff e0                	jmp    rax

0000000000407674 <srv_call_ret_capmgr_asnd_create>:
  407674:	49 89 c0             	mov    r8,rax
  407677:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40767e:	be ad de 
  407681:	48 89 e2             	mov    rdx,rsp
  407684:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40768b:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  407692:	00 
  407693:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40769a:	7f 00 00 
  40769d:	4c 89 e8             	mov    rax,r13
  4076a0:	48 25 ff ff 00 00    	and    rax,0xffff
  4076a6:	48 c1 e0 08          	shl    rax,0x8
  4076aa:	49 01 c6             	add    r14,rax
  4076ad:	b9 01 00 00 00       	mov    ecx,0x1
  4076b2:	01 c9                	add    ecx,ecx
  4076b4:	b8 03 00 00 00       	mov    eax,0x3
  4076b9:	d3 e0                	shl    eax,cl
  4076bb:	f7 d0                	not    eax
  4076bd:	83 e0 fc             	and    eax,0xfffffffc
  4076c0:	48 31 c9             	xor    rcx,rcx
  4076c3:	48 31 d2             	xor    rdx,rdx
  4076c6:	0f 01 ef             	wrpkru 
  4076c9:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4076cc:	48 c1 e2 04          	shl    rdx,0x4
  4076d0:	4c 01 f2             	add    rdx,r14
  4076d3:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  4076d7:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4076da:	48 83 e8 01          	sub    rax,0x1
  4076de:	49 89 06             	mov    QWORD PTR [r14],rax
  4076e1:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4076e6:	01 c9                	add    ecx,ecx
  4076e8:	b8 03 00 00 00       	mov    eax,0x3
  4076ed:	d3 e0                	shl    eax,cl
  4076ef:	f7 d0                	not    eax
  4076f1:	83 e0 fc             	and    eax,0xfffffffc
  4076f4:	48 31 c9             	xor    rcx,rcx
  4076f7:	48 31 d2             	xor    rdx,rdx
  4076fa:	0f 01 ef             	wrpkru 
  4076fd:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407704:	be ad de 
  407707:	49 39 c7             	cmp    r15,rax
  40770a:	4c 89 c0             	mov    rax,r8
  40770d:	41 5f                	pop    r15
  40770f:	41 5e                	pop    r14
  407711:	41 5d                	pop    r13
  407713:	5d                   	pop    rbp
  407714:	c3                   	ret    
  407715:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40771c:	00 00 00 00 

0000000000407720 <__cosrt_extern_capmgr_asnd_rcv_create>:
  407720:	48 b8 d4 c1 45 00 00 	movabs rax,0x45c1d4
  407727:	00 00 00 
  40772a:	ff 10                	call   QWORD PTR [rax]
  40772c:	c3                   	ret    
  40772d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000407730 <__cosrt_fast_callgate_capmgr_asnd_rcv_create>:
  407730:	55                   	push   rbp
  407731:	41 55                	push   r13
  407733:	41 56                	push   r14
  407735:	41 57                	push   r15
  407737:	49 89 c8             	mov    r8,rcx
  40773a:	49 89 d1             	mov    r9,rdx
  40773d:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  407744:	be ad de 
  407747:	0f 01 f9             	rdtscp 
  40774a:	48 89 c8             	mov    rax,rcx
  40774d:	48 25 ff 0f 00 00    	and    rax,0xfff
  407753:	48 89 e2             	mov    rdx,rsp
  407756:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40775d:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  407764:	00 
  407765:	48 c1 e0 10          	shl    rax,0x10
  407769:	49 09 c5             	or     r13,rax
  40776c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  407773:	7f 00 00 
  407776:	4c 89 e8             	mov    rax,r13
  407779:	48 25 ff ff 00 00    	and    rax,0xffff
  40777f:	48 c1 e0 08          	shl    rax,0x8
  407783:	49 01 c6             	add    r14,rax
  407786:	b9 01 00 00 00       	mov    ecx,0x1
  40778b:	01 c9                	add    ecx,ecx
  40778d:	b8 03 00 00 00       	mov    eax,0x3
  407792:	d3 e0                	shl    eax,cl
  407794:	f7 d0                	not    eax
  407796:	83 e0 fc             	and    eax,0xfffffffc
  407799:	48 31 c9             	xor    rcx,rcx
  40779c:	48 31 d2             	xor    rdx,rdx
  40779f:	0f 01 ef             	wrpkru 
  4077a2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4077a5:	48 83 c2 01          	add    rdx,0x1
  4077a9:	48 c1 e2 04          	shl    rdx,0x4
  4077ad:	4c 01 f2             	add    rdx,r14
  4077b0:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  4077b7:	45 23 01 
  4077ba:	48 89 02             	mov    QWORD PTR [rdx],rax
  4077bd:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  4077c1:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4077c4:	48 83 c0 01          	add    rax,0x1
  4077c8:	49 89 06             	mov    QWORD PTR [r14],rax
  4077cb:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4077d0:	01 c9                	add    ecx,ecx
  4077d2:	b8 03 00 00 00       	mov    eax,0x3
  4077d7:	d3 e0                	shl    eax,cl
  4077d9:	f7 d0                	not    eax
  4077db:	83 e0 fc             	and    eax,0xfffffffc
  4077de:	48 31 c9             	xor    rcx,rcx
  4077e1:	48 31 d2             	xor    rdx,rdx
  4077e4:	0f 01 ef             	wrpkru 
  4077e7:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  4077ee:	45 23 01 
  4077f1:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4077f8:	be ad de 
  4077fb:	49 39 c7             	cmp    r15,rax
  4077fe:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  407805:	12 12 12 
  407808:	48 b9 14 78 40 00 00 	movabs rcx,0x407814
  40780f:	00 00 00 
  407812:	ff e0                	jmp    rax

0000000000407814 <srv_call_ret_capmgr_asnd_rcv_create>:
  407814:	49 89 c0             	mov    r8,rax
  407817:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40781e:	be ad de 
  407821:	48 89 e2             	mov    rdx,rsp
  407824:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40782b:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  407832:	00 
  407833:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40783a:	7f 00 00 
  40783d:	4c 89 e8             	mov    rax,r13
  407840:	48 25 ff ff 00 00    	and    rax,0xffff
  407846:	48 c1 e0 08          	shl    rax,0x8
  40784a:	49 01 c6             	add    r14,rax
  40784d:	b9 01 00 00 00       	mov    ecx,0x1
  407852:	01 c9                	add    ecx,ecx
  407854:	b8 03 00 00 00       	mov    eax,0x3
  407859:	d3 e0                	shl    eax,cl
  40785b:	f7 d0                	not    eax
  40785d:	83 e0 fc             	and    eax,0xfffffffc
  407860:	48 31 c9             	xor    rcx,rcx
  407863:	48 31 d2             	xor    rdx,rdx
  407866:	0f 01 ef             	wrpkru 
  407869:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40786c:	48 c1 e2 04          	shl    rdx,0x4
  407870:	4c 01 f2             	add    rdx,r14
  407873:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  407877:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40787a:	48 83 e8 01          	sub    rax,0x1
  40787e:	49 89 06             	mov    QWORD PTR [r14],rax
  407881:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407886:	01 c9                	add    ecx,ecx
  407888:	b8 03 00 00 00       	mov    eax,0x3
  40788d:	d3 e0                	shl    eax,cl
  40788f:	f7 d0                	not    eax
  407891:	83 e0 fc             	and    eax,0xfffffffc
  407894:	48 31 c9             	xor    rcx,rcx
  407897:	48 31 d2             	xor    rdx,rdx
  40789a:	0f 01 ef             	wrpkru 
  40789d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4078a4:	be ad de 
  4078a7:	49 39 c7             	cmp    r15,rax
  4078aa:	4c 89 c0             	mov    rax,r8
  4078ad:	41 5f                	pop    r15
  4078af:	41 5e                	pop    r14
  4078b1:	41 5d                	pop    r13
  4078b3:	5d                   	pop    rbp
  4078b4:	c3                   	ret    
  4078b5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4078bc:	00 00 00 00 

00000000004078c0 <__cosrt_extern_capmgr_asnd_key_create>:
  4078c0:	48 b8 ec c1 45 00 00 	movabs rax,0x45c1ec
  4078c7:	00 00 00 
  4078ca:	ff 10                	call   QWORD PTR [rax]
  4078cc:	c3                   	ret    
  4078cd:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004078d0 <__cosrt_fast_callgate_capmgr_asnd_key_create>:
  4078d0:	55                   	push   rbp
  4078d1:	41 55                	push   r13
  4078d3:	41 56                	push   r14
  4078d5:	41 57                	push   r15
  4078d7:	49 89 c8             	mov    r8,rcx
  4078da:	49 89 d1             	mov    r9,rdx
  4078dd:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4078e4:	be ad de 
  4078e7:	0f 01 f9             	rdtscp 
  4078ea:	48 89 c8             	mov    rax,rcx
  4078ed:	48 25 ff 0f 00 00    	and    rax,0xfff
  4078f3:	48 89 e2             	mov    rdx,rsp
  4078f6:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4078fd:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  407904:	00 
  407905:	48 c1 e0 10          	shl    rax,0x10
  407909:	49 09 c5             	or     r13,rax
  40790c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  407913:	7f 00 00 
  407916:	4c 89 e8             	mov    rax,r13
  407919:	48 25 ff ff 00 00    	and    rax,0xffff
  40791f:	48 c1 e0 08          	shl    rax,0x8
  407923:	49 01 c6             	add    r14,rax
  407926:	b9 01 00 00 00       	mov    ecx,0x1
  40792b:	01 c9                	add    ecx,ecx
  40792d:	b8 03 00 00 00       	mov    eax,0x3
  407932:	d3 e0                	shl    eax,cl
  407934:	f7 d0                	not    eax
  407936:	83 e0 fc             	and    eax,0xfffffffc
  407939:	48 31 c9             	xor    rcx,rcx
  40793c:	48 31 d2             	xor    rdx,rdx
  40793f:	0f 01 ef             	wrpkru 
  407942:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  407945:	48 83 c2 01          	add    rdx,0x1
  407949:	48 c1 e2 04          	shl    rdx,0x4
  40794d:	4c 01 f2             	add    rdx,r14
  407950:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  407957:	45 23 01 
  40795a:	48 89 02             	mov    QWORD PTR [rdx],rax
  40795d:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  407961:	49 8b 06             	mov    rax,QWORD PTR [r14]
  407964:	48 83 c0 01          	add    rax,0x1
  407968:	49 89 06             	mov    QWORD PTR [r14],rax
  40796b:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407970:	01 c9                	add    ecx,ecx
  407972:	b8 03 00 00 00       	mov    eax,0x3
  407977:	d3 e0                	shl    eax,cl
  407979:	f7 d0                	not    eax
  40797b:	83 e0 fc             	and    eax,0xfffffffc
  40797e:	48 31 c9             	xor    rcx,rcx
  407981:	48 31 d2             	xor    rdx,rdx
  407984:	0f 01 ef             	wrpkru 
  407987:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  40798e:	45 23 01 
  407991:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407998:	be ad de 
  40799b:	49 39 c7             	cmp    r15,rax
  40799e:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  4079a5:	12 12 12 
  4079a8:	48 b9 b4 79 40 00 00 	movabs rcx,0x4079b4
  4079af:	00 00 00 
  4079b2:	ff e0                	jmp    rax

00000000004079b4 <srv_call_ret_capmgr_asnd_key_create>:
  4079b4:	49 89 c0             	mov    r8,rax
  4079b7:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4079be:	be ad de 
  4079c1:	48 89 e2             	mov    rdx,rsp
  4079c4:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4079cb:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4079d2:	00 
  4079d3:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4079da:	7f 00 00 
  4079dd:	4c 89 e8             	mov    rax,r13
  4079e0:	48 25 ff ff 00 00    	and    rax,0xffff
  4079e6:	48 c1 e0 08          	shl    rax,0x8
  4079ea:	49 01 c6             	add    r14,rax
  4079ed:	b9 01 00 00 00       	mov    ecx,0x1
  4079f2:	01 c9                	add    ecx,ecx
  4079f4:	b8 03 00 00 00       	mov    eax,0x3
  4079f9:	d3 e0                	shl    eax,cl
  4079fb:	f7 d0                	not    eax
  4079fd:	83 e0 fc             	and    eax,0xfffffffc
  407a00:	48 31 c9             	xor    rcx,rcx
  407a03:	48 31 d2             	xor    rdx,rdx
  407a06:	0f 01 ef             	wrpkru 
  407a09:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  407a0c:	48 c1 e2 04          	shl    rdx,0x4
  407a10:	4c 01 f2             	add    rdx,r14
  407a13:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  407a17:	49 8b 06             	mov    rax,QWORD PTR [r14]
  407a1a:	48 83 e8 01          	sub    rax,0x1
  407a1e:	49 89 06             	mov    QWORD PTR [r14],rax
  407a21:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407a26:	01 c9                	add    ecx,ecx
  407a28:	b8 03 00 00 00       	mov    eax,0x3
  407a2d:	d3 e0                	shl    eax,cl
  407a2f:	f7 d0                	not    eax
  407a31:	83 e0 fc             	and    eax,0xfffffffc
  407a34:	48 31 c9             	xor    rcx,rcx
  407a37:	48 31 d2             	xor    rdx,rdx
  407a3a:	0f 01 ef             	wrpkru 
  407a3d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407a44:	be ad de 
  407a47:	49 39 c7             	cmp    r15,rax
  407a4a:	4c 89 c0             	mov    rax,r8
  407a4d:	41 5f                	pop    r15
  407a4f:	41 5e                	pop    r14
  407a51:	41 5d                	pop    r13
  407a53:	5d                   	pop    rbp
  407a54:	c3                   	ret    
  407a55:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  407a5c:	00 00 00 00 

0000000000407a60 <__cosrt_extern_capmgr_vm_comp_create>:
  407a60:	48 b8 04 c2 45 00 00 	movabs rax,0x45c204
  407a67:	00 00 00 
  407a6a:	ff 10                	call   QWORD PTR [rax]
  407a6c:	c3                   	ret    
  407a6d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000407a70 <__cosrt_fast_callgate_capmgr_vm_comp_create>:
  407a70:	55                   	push   rbp
  407a71:	41 55                	push   r13
  407a73:	41 56                	push   r14
  407a75:	41 57                	push   r15
  407a77:	49 89 c8             	mov    r8,rcx
  407a7a:	49 89 d1             	mov    r9,rdx
  407a7d:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  407a84:	be ad de 
  407a87:	0f 01 f9             	rdtscp 
  407a8a:	48 89 c8             	mov    rax,rcx
  407a8d:	48 25 ff 0f 00 00    	and    rax,0xfff
  407a93:	48 89 e2             	mov    rdx,rsp
  407a96:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  407a9d:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  407aa4:	00 
  407aa5:	48 c1 e0 10          	shl    rax,0x10
  407aa9:	49 09 c5             	or     r13,rax
  407aac:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  407ab3:	7f 00 00 
  407ab6:	4c 89 e8             	mov    rax,r13
  407ab9:	48 25 ff ff 00 00    	and    rax,0xffff
  407abf:	48 c1 e0 08          	shl    rax,0x8
  407ac3:	49 01 c6             	add    r14,rax
  407ac6:	b9 01 00 00 00       	mov    ecx,0x1
  407acb:	01 c9                	add    ecx,ecx
  407acd:	b8 03 00 00 00       	mov    eax,0x3
  407ad2:	d3 e0                	shl    eax,cl
  407ad4:	f7 d0                	not    eax
  407ad6:	83 e0 fc             	and    eax,0xfffffffc
  407ad9:	48 31 c9             	xor    rcx,rcx
  407adc:	48 31 d2             	xor    rdx,rdx
  407adf:	0f 01 ef             	wrpkru 
  407ae2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  407ae5:	48 83 c2 01          	add    rdx,0x1
  407ae9:	48 c1 e2 04          	shl    rdx,0x4
  407aed:	4c 01 f2             	add    rdx,r14
  407af0:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  407af7:	45 23 01 
  407afa:	48 89 02             	mov    QWORD PTR [rdx],rax
  407afd:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  407b01:	49 8b 06             	mov    rax,QWORD PTR [r14]
  407b04:	48 83 c0 01          	add    rax,0x1
  407b08:	49 89 06             	mov    QWORD PTR [r14],rax
  407b0b:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407b10:	01 c9                	add    ecx,ecx
  407b12:	b8 03 00 00 00       	mov    eax,0x3
  407b17:	d3 e0                	shl    eax,cl
  407b19:	f7 d0                	not    eax
  407b1b:	83 e0 fc             	and    eax,0xfffffffc
  407b1e:	48 31 c9             	xor    rcx,rcx
  407b21:	48 31 d2             	xor    rdx,rdx
  407b24:	0f 01 ef             	wrpkru 
  407b27:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  407b2e:	45 23 01 
  407b31:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407b38:	be ad de 
  407b3b:	49 39 c7             	cmp    r15,rax
  407b3e:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  407b45:	12 12 12 
  407b48:	48 b9 54 7b 40 00 00 	movabs rcx,0x407b54
  407b4f:	00 00 00 
  407b52:	ff e0                	jmp    rax

0000000000407b54 <srv_call_ret_capmgr_vm_comp_create>:
  407b54:	49 89 c0             	mov    r8,rax
  407b57:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  407b5e:	be ad de 
  407b61:	48 89 e2             	mov    rdx,rsp
  407b64:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  407b6b:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  407b72:	00 
  407b73:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  407b7a:	7f 00 00 
  407b7d:	4c 89 e8             	mov    rax,r13
  407b80:	48 25 ff ff 00 00    	and    rax,0xffff
  407b86:	48 c1 e0 08          	shl    rax,0x8
  407b8a:	49 01 c6             	add    r14,rax
  407b8d:	b9 01 00 00 00       	mov    ecx,0x1
  407b92:	01 c9                	add    ecx,ecx
  407b94:	b8 03 00 00 00       	mov    eax,0x3
  407b99:	d3 e0                	shl    eax,cl
  407b9b:	f7 d0                	not    eax
  407b9d:	83 e0 fc             	and    eax,0xfffffffc
  407ba0:	48 31 c9             	xor    rcx,rcx
  407ba3:	48 31 d2             	xor    rdx,rdx
  407ba6:	0f 01 ef             	wrpkru 
  407ba9:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  407bac:	48 c1 e2 04          	shl    rdx,0x4
  407bb0:	4c 01 f2             	add    rdx,r14
  407bb3:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  407bb7:	49 8b 06             	mov    rax,QWORD PTR [r14]
  407bba:	48 83 e8 01          	sub    rax,0x1
  407bbe:	49 89 06             	mov    QWORD PTR [r14],rax
  407bc1:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407bc6:	01 c9                	add    ecx,ecx
  407bc8:	b8 03 00 00 00       	mov    eax,0x3
  407bcd:	d3 e0                	shl    eax,cl
  407bcf:	f7 d0                	not    eax
  407bd1:	83 e0 fc             	and    eax,0xfffffffc
  407bd4:	48 31 c9             	xor    rcx,rcx
  407bd7:	48 31 d2             	xor    rdx,rdx
  407bda:	0f 01 ef             	wrpkru 
  407bdd:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407be4:	be ad de 
  407be7:	49 39 c7             	cmp    r15,rax
  407bea:	4c 89 c0             	mov    rax,r8
  407bed:	41 5f                	pop    r15
  407bef:	41 5e                	pop    r14
  407bf1:	41 5d                	pop    r13
  407bf3:	5d                   	pop    rbp
  407bf4:	c3                   	ret    
  407bf5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  407bfc:	00 00 00 00 

0000000000407c00 <__cosrt_extern_capmgr_vm_shared_kernel_page_create_at>:
  407c00:	48 b8 1c c2 45 00 00 	movabs rax,0x45c21c
  407c07:	00 00 00 
  407c0a:	ff 10                	call   QWORD PTR [rax]
  407c0c:	c3                   	ret    
  407c0d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000407c10 <__cosrt_fast_callgate_capmgr_vm_shared_kernel_page_create_at>:
  407c10:	55                   	push   rbp
  407c11:	41 55                	push   r13
  407c13:	41 56                	push   r14
  407c15:	41 57                	push   r15
  407c17:	49 89 c8             	mov    r8,rcx
  407c1a:	49 89 d1             	mov    r9,rdx
  407c1d:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  407c24:	be ad de 
  407c27:	0f 01 f9             	rdtscp 
  407c2a:	48 89 c8             	mov    rax,rcx
  407c2d:	48 25 ff 0f 00 00    	and    rax,0xfff
  407c33:	48 89 e2             	mov    rdx,rsp
  407c36:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  407c3d:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  407c44:	00 
  407c45:	48 c1 e0 10          	shl    rax,0x10
  407c49:	49 09 c5             	or     r13,rax
  407c4c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  407c53:	7f 00 00 
  407c56:	4c 89 e8             	mov    rax,r13
  407c59:	48 25 ff ff 00 00    	and    rax,0xffff
  407c5f:	48 c1 e0 08          	shl    rax,0x8
  407c63:	49 01 c6             	add    r14,rax
  407c66:	b9 01 00 00 00       	mov    ecx,0x1
  407c6b:	01 c9                	add    ecx,ecx
  407c6d:	b8 03 00 00 00       	mov    eax,0x3
  407c72:	d3 e0                	shl    eax,cl
  407c74:	f7 d0                	not    eax
  407c76:	83 e0 fc             	and    eax,0xfffffffc
  407c79:	48 31 c9             	xor    rcx,rcx
  407c7c:	48 31 d2             	xor    rdx,rdx
  407c7f:	0f 01 ef             	wrpkru 
  407c82:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  407c85:	48 83 c2 01          	add    rdx,0x1
  407c89:	48 c1 e2 04          	shl    rdx,0x4
  407c8d:	4c 01 f2             	add    rdx,r14
  407c90:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  407c97:	45 23 01 
  407c9a:	48 89 02             	mov    QWORD PTR [rdx],rax
  407c9d:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  407ca1:	49 8b 06             	mov    rax,QWORD PTR [r14]
  407ca4:	48 83 c0 01          	add    rax,0x1
  407ca8:	49 89 06             	mov    QWORD PTR [r14],rax
  407cab:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407cb0:	01 c9                	add    ecx,ecx
  407cb2:	b8 03 00 00 00       	mov    eax,0x3
  407cb7:	d3 e0                	shl    eax,cl
  407cb9:	f7 d0                	not    eax
  407cbb:	83 e0 fc             	and    eax,0xfffffffc
  407cbe:	48 31 c9             	xor    rcx,rcx
  407cc1:	48 31 d2             	xor    rdx,rdx
  407cc4:	0f 01 ef             	wrpkru 
  407cc7:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  407cce:	45 23 01 
  407cd1:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407cd8:	be ad de 
  407cdb:	49 39 c7             	cmp    r15,rax
  407cde:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  407ce5:	12 12 12 
  407ce8:	48 b9 f4 7c 40 00 00 	movabs rcx,0x407cf4
  407cef:	00 00 00 
  407cf2:	ff e0                	jmp    rax

0000000000407cf4 <srv_call_ret_capmgr_vm_shared_kernel_page_create_at>:
  407cf4:	49 89 c0             	mov    r8,rax
  407cf7:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  407cfe:	be ad de 
  407d01:	48 89 e2             	mov    rdx,rsp
  407d04:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  407d0b:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  407d12:	00 
  407d13:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  407d1a:	7f 00 00 
  407d1d:	4c 89 e8             	mov    rax,r13
  407d20:	48 25 ff ff 00 00    	and    rax,0xffff
  407d26:	48 c1 e0 08          	shl    rax,0x8
  407d2a:	49 01 c6             	add    r14,rax
  407d2d:	b9 01 00 00 00       	mov    ecx,0x1
  407d32:	01 c9                	add    ecx,ecx
  407d34:	b8 03 00 00 00       	mov    eax,0x3
  407d39:	d3 e0                	shl    eax,cl
  407d3b:	f7 d0                	not    eax
  407d3d:	83 e0 fc             	and    eax,0xfffffffc
  407d40:	48 31 c9             	xor    rcx,rcx
  407d43:	48 31 d2             	xor    rdx,rdx
  407d46:	0f 01 ef             	wrpkru 
  407d49:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  407d4c:	48 c1 e2 04          	shl    rdx,0x4
  407d50:	4c 01 f2             	add    rdx,r14
  407d53:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  407d57:	49 8b 06             	mov    rax,QWORD PTR [r14]
  407d5a:	48 83 e8 01          	sub    rax,0x1
  407d5e:	49 89 06             	mov    QWORD PTR [r14],rax
  407d61:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407d66:	01 c9                	add    ecx,ecx
  407d68:	b8 03 00 00 00       	mov    eax,0x3
  407d6d:	d3 e0                	shl    eax,cl
  407d6f:	f7 d0                	not    eax
  407d71:	83 e0 fc             	and    eax,0xfffffffc
  407d74:	48 31 c9             	xor    rcx,rcx
  407d77:	48 31 d2             	xor    rdx,rdx
  407d7a:	0f 01 ef             	wrpkru 
  407d7d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407d84:	be ad de 
  407d87:	49 39 c7             	cmp    r15,rax
  407d8a:	4c 89 c0             	mov    rax,r8
  407d8d:	41 5f                	pop    r15
  407d8f:	41 5e                	pop    r14
  407d91:	41 5d                	pop    r13
  407d93:	5d                   	pop    rbp
  407d94:	c3                   	ret    
  407d95:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  407d9c:	00 00 00 00 

0000000000407da0 <__cosrt_extern_capmgr_vm_vmcs_create>:
  407da0:	48 b8 34 c2 45 00 00 	movabs rax,0x45c234
  407da7:	00 00 00 
  407daa:	ff 10                	call   QWORD PTR [rax]
  407dac:	c3                   	ret    
  407dad:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000407db0 <__cosrt_fast_callgate_capmgr_vm_vmcs_create>:
  407db0:	55                   	push   rbp
  407db1:	41 55                	push   r13
  407db3:	41 56                	push   r14
  407db5:	41 57                	push   r15
  407db7:	49 89 c8             	mov    r8,rcx
  407dba:	49 89 d1             	mov    r9,rdx
  407dbd:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  407dc4:	be ad de 
  407dc7:	0f 01 f9             	rdtscp 
  407dca:	48 89 c8             	mov    rax,rcx
  407dcd:	48 25 ff 0f 00 00    	and    rax,0xfff
  407dd3:	48 89 e2             	mov    rdx,rsp
  407dd6:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  407ddd:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  407de4:	00 
  407de5:	48 c1 e0 10          	shl    rax,0x10
  407de9:	49 09 c5             	or     r13,rax
  407dec:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  407df3:	7f 00 00 
  407df6:	4c 89 e8             	mov    rax,r13
  407df9:	48 25 ff ff 00 00    	and    rax,0xffff
  407dff:	48 c1 e0 08          	shl    rax,0x8
  407e03:	49 01 c6             	add    r14,rax
  407e06:	b9 01 00 00 00       	mov    ecx,0x1
  407e0b:	01 c9                	add    ecx,ecx
  407e0d:	b8 03 00 00 00       	mov    eax,0x3
  407e12:	d3 e0                	shl    eax,cl
  407e14:	f7 d0                	not    eax
  407e16:	83 e0 fc             	and    eax,0xfffffffc
  407e19:	48 31 c9             	xor    rcx,rcx
  407e1c:	48 31 d2             	xor    rdx,rdx
  407e1f:	0f 01 ef             	wrpkru 
  407e22:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  407e25:	48 83 c2 01          	add    rdx,0x1
  407e29:	48 c1 e2 04          	shl    rdx,0x4
  407e2d:	4c 01 f2             	add    rdx,r14
  407e30:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  407e37:	45 23 01 
  407e3a:	48 89 02             	mov    QWORD PTR [rdx],rax
  407e3d:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  407e41:	49 8b 06             	mov    rax,QWORD PTR [r14]
  407e44:	48 83 c0 01          	add    rax,0x1
  407e48:	49 89 06             	mov    QWORD PTR [r14],rax
  407e4b:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407e50:	01 c9                	add    ecx,ecx
  407e52:	b8 03 00 00 00       	mov    eax,0x3
  407e57:	d3 e0                	shl    eax,cl
  407e59:	f7 d0                	not    eax
  407e5b:	83 e0 fc             	and    eax,0xfffffffc
  407e5e:	48 31 c9             	xor    rcx,rcx
  407e61:	48 31 d2             	xor    rdx,rdx
  407e64:	0f 01 ef             	wrpkru 
  407e67:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  407e6e:	45 23 01 
  407e71:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407e78:	be ad de 
  407e7b:	49 39 c7             	cmp    r15,rax
  407e7e:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  407e85:	12 12 12 
  407e88:	48 b9 94 7e 40 00 00 	movabs rcx,0x407e94
  407e8f:	00 00 00 
  407e92:	ff e0                	jmp    rax

0000000000407e94 <srv_call_ret_capmgr_vm_vmcs_create>:
  407e94:	49 89 c0             	mov    r8,rax
  407e97:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  407e9e:	be ad de 
  407ea1:	48 89 e2             	mov    rdx,rsp
  407ea4:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  407eab:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  407eb2:	00 
  407eb3:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  407eba:	7f 00 00 
  407ebd:	4c 89 e8             	mov    rax,r13
  407ec0:	48 25 ff ff 00 00    	and    rax,0xffff
  407ec6:	48 c1 e0 08          	shl    rax,0x8
  407eca:	49 01 c6             	add    r14,rax
  407ecd:	b9 01 00 00 00       	mov    ecx,0x1
  407ed2:	01 c9                	add    ecx,ecx
  407ed4:	b8 03 00 00 00       	mov    eax,0x3
  407ed9:	d3 e0                	shl    eax,cl
  407edb:	f7 d0                	not    eax
  407edd:	83 e0 fc             	and    eax,0xfffffffc
  407ee0:	48 31 c9             	xor    rcx,rcx
  407ee3:	48 31 d2             	xor    rdx,rdx
  407ee6:	0f 01 ef             	wrpkru 
  407ee9:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  407eec:	48 c1 e2 04          	shl    rdx,0x4
  407ef0:	4c 01 f2             	add    rdx,r14
  407ef3:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  407ef7:	49 8b 06             	mov    rax,QWORD PTR [r14]
  407efa:	48 83 e8 01          	sub    rax,0x1
  407efe:	49 89 06             	mov    QWORD PTR [r14],rax
  407f01:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407f06:	01 c9                	add    ecx,ecx
  407f08:	b8 03 00 00 00       	mov    eax,0x3
  407f0d:	d3 e0                	shl    eax,cl
  407f0f:	f7 d0                	not    eax
  407f11:	83 e0 fc             	and    eax,0xfffffffc
  407f14:	48 31 c9             	xor    rcx,rcx
  407f17:	48 31 d2             	xor    rdx,rdx
  407f1a:	0f 01 ef             	wrpkru 
  407f1d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407f24:	be ad de 
  407f27:	49 39 c7             	cmp    r15,rax
  407f2a:	4c 89 c0             	mov    rax,r8
  407f2d:	41 5f                	pop    r15
  407f2f:	41 5e                	pop    r14
  407f31:	41 5d                	pop    r13
  407f33:	5d                   	pop    rbp
  407f34:	c3                   	ret    
  407f35:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  407f3c:	00 00 00 00 

0000000000407f40 <__cosrt_extern_capmgr_vm_msr_bitmap_create>:
  407f40:	48 b8 4c c2 45 00 00 	movabs rax,0x45c24c
  407f47:	00 00 00 
  407f4a:	ff 10                	call   QWORD PTR [rax]
  407f4c:	c3                   	ret    
  407f4d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000407f50 <__cosrt_fast_callgate_capmgr_vm_msr_bitmap_create>:
  407f50:	55                   	push   rbp
  407f51:	41 55                	push   r13
  407f53:	41 56                	push   r14
  407f55:	41 57                	push   r15
  407f57:	49 89 c8             	mov    r8,rcx
  407f5a:	49 89 d1             	mov    r9,rdx
  407f5d:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  407f64:	be ad de 
  407f67:	0f 01 f9             	rdtscp 
  407f6a:	48 89 c8             	mov    rax,rcx
  407f6d:	48 25 ff 0f 00 00    	and    rax,0xfff
  407f73:	48 89 e2             	mov    rdx,rsp
  407f76:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  407f7d:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  407f84:	00 
  407f85:	48 c1 e0 10          	shl    rax,0x10
  407f89:	49 09 c5             	or     r13,rax
  407f8c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  407f93:	7f 00 00 
  407f96:	4c 89 e8             	mov    rax,r13
  407f99:	48 25 ff ff 00 00    	and    rax,0xffff
  407f9f:	48 c1 e0 08          	shl    rax,0x8
  407fa3:	49 01 c6             	add    r14,rax
  407fa6:	b9 01 00 00 00       	mov    ecx,0x1
  407fab:	01 c9                	add    ecx,ecx
  407fad:	b8 03 00 00 00       	mov    eax,0x3
  407fb2:	d3 e0                	shl    eax,cl
  407fb4:	f7 d0                	not    eax
  407fb6:	83 e0 fc             	and    eax,0xfffffffc
  407fb9:	48 31 c9             	xor    rcx,rcx
  407fbc:	48 31 d2             	xor    rdx,rdx
  407fbf:	0f 01 ef             	wrpkru 
  407fc2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  407fc5:	48 83 c2 01          	add    rdx,0x1
  407fc9:	48 c1 e2 04          	shl    rdx,0x4
  407fcd:	4c 01 f2             	add    rdx,r14
  407fd0:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  407fd7:	45 23 01 
  407fda:	48 89 02             	mov    QWORD PTR [rdx],rax
  407fdd:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  407fe1:	49 8b 06             	mov    rax,QWORD PTR [r14]
  407fe4:	48 83 c0 01          	add    rax,0x1
  407fe8:	49 89 06             	mov    QWORD PTR [r14],rax
  407feb:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407ff0:	01 c9                	add    ecx,ecx
  407ff2:	b8 03 00 00 00       	mov    eax,0x3
  407ff7:	d3 e0                	shl    eax,cl
  407ff9:	f7 d0                	not    eax
  407ffb:	83 e0 fc             	and    eax,0xfffffffc
  407ffe:	48 31 c9             	xor    rcx,rcx
  408001:	48 31 d2             	xor    rdx,rdx
  408004:	0f 01 ef             	wrpkru 
  408007:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  40800e:	45 23 01 
  408011:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408018:	be ad de 
  40801b:	49 39 c7             	cmp    r15,rax
  40801e:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  408025:	12 12 12 
  408028:	48 b9 34 80 40 00 00 	movabs rcx,0x408034
  40802f:	00 00 00 
  408032:	ff e0                	jmp    rax

0000000000408034 <srv_call_ret_capmgr_vm_msr_bitmap_create>:
  408034:	49 89 c0             	mov    r8,rax
  408037:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40803e:	be ad de 
  408041:	48 89 e2             	mov    rdx,rsp
  408044:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40804b:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  408052:	00 
  408053:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40805a:	7f 00 00 
  40805d:	4c 89 e8             	mov    rax,r13
  408060:	48 25 ff ff 00 00    	and    rax,0xffff
  408066:	48 c1 e0 08          	shl    rax,0x8
  40806a:	49 01 c6             	add    r14,rax
  40806d:	b9 01 00 00 00       	mov    ecx,0x1
  408072:	01 c9                	add    ecx,ecx
  408074:	b8 03 00 00 00       	mov    eax,0x3
  408079:	d3 e0                	shl    eax,cl
  40807b:	f7 d0                	not    eax
  40807d:	83 e0 fc             	and    eax,0xfffffffc
  408080:	48 31 c9             	xor    rcx,rcx
  408083:	48 31 d2             	xor    rdx,rdx
  408086:	0f 01 ef             	wrpkru 
  408089:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40808c:	48 c1 e2 04          	shl    rdx,0x4
  408090:	4c 01 f2             	add    rdx,r14
  408093:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  408097:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40809a:	48 83 e8 01          	sub    rax,0x1
  40809e:	49 89 06             	mov    QWORD PTR [r14],rax
  4080a1:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4080a6:	01 c9                	add    ecx,ecx
  4080a8:	b8 03 00 00 00       	mov    eax,0x3
  4080ad:	d3 e0                	shl    eax,cl
  4080af:	f7 d0                	not    eax
  4080b1:	83 e0 fc             	and    eax,0xfffffffc
  4080b4:	48 31 c9             	xor    rcx,rcx
  4080b7:	48 31 d2             	xor    rdx,rdx
  4080ba:	0f 01 ef             	wrpkru 
  4080bd:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4080c4:	be ad de 
  4080c7:	49 39 c7             	cmp    r15,rax
  4080ca:	4c 89 c0             	mov    rax,r8
  4080cd:	41 5f                	pop    r15
  4080cf:	41 5e                	pop    r14
  4080d1:	41 5d                	pop    r13
  4080d3:	5d                   	pop    rbp
  4080d4:	c3                   	ret    
  4080d5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4080dc:	00 00 00 00 

00000000004080e0 <__cosrt_extern_capmgr_vm_lapic_access_create>:
  4080e0:	48 b8 64 c2 45 00 00 	movabs rax,0x45c264
  4080e7:	00 00 00 
  4080ea:	ff 10                	call   QWORD PTR [rax]
  4080ec:	c3                   	ret    
  4080ed:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004080f0 <__cosrt_fast_callgate_capmgr_vm_lapic_access_create>:
  4080f0:	55                   	push   rbp
  4080f1:	41 55                	push   r13
  4080f3:	41 56                	push   r14
  4080f5:	41 57                	push   r15
  4080f7:	49 89 c8             	mov    r8,rcx
  4080fa:	49 89 d1             	mov    r9,rdx
  4080fd:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  408104:	be ad de 
  408107:	0f 01 f9             	rdtscp 
  40810a:	48 89 c8             	mov    rax,rcx
  40810d:	48 25 ff 0f 00 00    	and    rax,0xfff
  408113:	48 89 e2             	mov    rdx,rsp
  408116:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40811d:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  408124:	00 
  408125:	48 c1 e0 10          	shl    rax,0x10
  408129:	49 09 c5             	or     r13,rax
  40812c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  408133:	7f 00 00 
  408136:	4c 89 e8             	mov    rax,r13
  408139:	48 25 ff ff 00 00    	and    rax,0xffff
  40813f:	48 c1 e0 08          	shl    rax,0x8
  408143:	49 01 c6             	add    r14,rax
  408146:	b9 01 00 00 00       	mov    ecx,0x1
  40814b:	01 c9                	add    ecx,ecx
  40814d:	b8 03 00 00 00       	mov    eax,0x3
  408152:	d3 e0                	shl    eax,cl
  408154:	f7 d0                	not    eax
  408156:	83 e0 fc             	and    eax,0xfffffffc
  408159:	48 31 c9             	xor    rcx,rcx
  40815c:	48 31 d2             	xor    rdx,rdx
  40815f:	0f 01 ef             	wrpkru 
  408162:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  408165:	48 83 c2 01          	add    rdx,0x1
  408169:	48 c1 e2 04          	shl    rdx,0x4
  40816d:	4c 01 f2             	add    rdx,r14
  408170:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  408177:	45 23 01 
  40817a:	48 89 02             	mov    QWORD PTR [rdx],rax
  40817d:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  408181:	49 8b 06             	mov    rax,QWORD PTR [r14]
  408184:	48 83 c0 01          	add    rax,0x1
  408188:	49 89 06             	mov    QWORD PTR [r14],rax
  40818b:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  408190:	01 c9                	add    ecx,ecx
  408192:	b8 03 00 00 00       	mov    eax,0x3
  408197:	d3 e0                	shl    eax,cl
  408199:	f7 d0                	not    eax
  40819b:	83 e0 fc             	and    eax,0xfffffffc
  40819e:	48 31 c9             	xor    rcx,rcx
  4081a1:	48 31 d2             	xor    rdx,rdx
  4081a4:	0f 01 ef             	wrpkru 
  4081a7:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  4081ae:	45 23 01 
  4081b1:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4081b8:	be ad de 
  4081bb:	49 39 c7             	cmp    r15,rax
  4081be:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  4081c5:	12 12 12 
  4081c8:	48 b9 d4 81 40 00 00 	movabs rcx,0x4081d4
  4081cf:	00 00 00 
  4081d2:	ff e0                	jmp    rax

00000000004081d4 <srv_call_ret_capmgr_vm_lapic_access_create>:
  4081d4:	49 89 c0             	mov    r8,rax
  4081d7:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4081de:	be ad de 
  4081e1:	48 89 e2             	mov    rdx,rsp
  4081e4:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4081eb:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4081f2:	00 
  4081f3:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4081fa:	7f 00 00 
  4081fd:	4c 89 e8             	mov    rax,r13
  408200:	48 25 ff ff 00 00    	and    rax,0xffff
  408206:	48 c1 e0 08          	shl    rax,0x8
  40820a:	49 01 c6             	add    r14,rax
  40820d:	b9 01 00 00 00       	mov    ecx,0x1
  408212:	01 c9                	add    ecx,ecx
  408214:	b8 03 00 00 00       	mov    eax,0x3
  408219:	d3 e0                	shl    eax,cl
  40821b:	f7 d0                	not    eax
  40821d:	83 e0 fc             	and    eax,0xfffffffc
  408220:	48 31 c9             	xor    rcx,rcx
  408223:	48 31 d2             	xor    rdx,rdx
  408226:	0f 01 ef             	wrpkru 
  408229:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40822c:	48 c1 e2 04          	shl    rdx,0x4
  408230:	4c 01 f2             	add    rdx,r14
  408233:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  408237:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40823a:	48 83 e8 01          	sub    rax,0x1
  40823e:	49 89 06             	mov    QWORD PTR [r14],rax
  408241:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  408246:	01 c9                	add    ecx,ecx
  408248:	b8 03 00 00 00       	mov    eax,0x3
  40824d:	d3 e0                	shl    eax,cl
  40824f:	f7 d0                	not    eax
  408251:	83 e0 fc             	and    eax,0xfffffffc
  408254:	48 31 c9             	xor    rcx,rcx
  408257:	48 31 d2             	xor    rdx,rdx
  40825a:	0f 01 ef             	wrpkru 
  40825d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408264:	be ad de 
  408267:	49 39 c7             	cmp    r15,rax
  40826a:	4c 89 c0             	mov    rax,r8
  40826d:	41 5f                	pop    r15
  40826f:	41 5e                	pop    r14
  408271:	41 5d                	pop    r13
  408273:	5d                   	pop    rbp
  408274:	c3                   	ret    
  408275:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40827c:	00 00 00 00 

0000000000408280 <__cosrt_extern_capmgr_shared_kernel_page_create>:
  408280:	48 b8 7c c2 45 00 00 	movabs rax,0x45c27c
  408287:	00 00 00 
  40828a:	ff 10                	call   QWORD PTR [rax]
  40828c:	c3                   	ret    
  40828d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000408290 <__cosrt_fast_callgate_capmgr_shared_kernel_page_create>:
  408290:	55                   	push   rbp
  408291:	53                   	push   rbx
  408292:	41 54                	push   r12
  408294:	41 55                	push   r13
  408296:	41 56                	push   r14
  408298:	41 57                	push   r15
  40829a:	4d 89 c4             	mov    r12,r8
  40829d:	4c 89 cb             	mov    rbx,r9
  4082a0:	49 89 c8             	mov    r8,rcx
  4082a3:	49 89 d1             	mov    r9,rdx
  4082a6:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4082ad:	be ad de 
  4082b0:	0f 01 f9             	rdtscp 
  4082b3:	48 89 ca             	mov    rdx,rcx
  4082b6:	48 25 ff 0f 00 00    	and    rax,0xfff
  4082bc:	48 89 e2             	mov    rdx,rsp
  4082bf:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4082c6:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4082cd:	00 
  4082ce:	48 c1 e0 10          	shl    rax,0x10
  4082d2:	49 09 c5             	or     r13,rax
  4082d5:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4082dc:	7f 00 00 
  4082df:	4c 89 e8             	mov    rax,r13
  4082e2:	48 25 ff ff 00 00    	and    rax,0xffff
  4082e8:	48 c1 e0 08          	shl    rax,0x8
  4082ec:	49 01 c6             	add    r14,rax
  4082ef:	b9 01 00 00 00       	mov    ecx,0x1
  4082f4:	01 c9                	add    ecx,ecx
  4082f6:	b8 03 00 00 00       	mov    eax,0x3
  4082fb:	d3 e0                	shl    eax,cl
  4082fd:	f7 d0                	not    eax
  4082ff:	83 e0 fc             	and    eax,0xfffffffc
  408302:	48 31 c9             	xor    rcx,rcx
  408305:	48 31 d2             	xor    rdx,rdx
  408308:	0f 01 ef             	wrpkru 
  40830b:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40830e:	48 83 c2 01          	add    rdx,0x1
  408312:	48 c1 e2 04          	shl    rdx,0x4
  408316:	4c 01 f2             	add    rdx,r14
  408319:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  408320:	45 23 01 
  408323:	48 89 02             	mov    QWORD PTR [rdx],rax
  408326:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  40832a:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40832d:	48 83 c0 01          	add    rax,0x1
  408331:	49 89 06             	mov    QWORD PTR [r14],rax
  408334:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  408339:	01 c9                	add    ecx,ecx
  40833b:	b8 03 00 00 00       	mov    eax,0x3
  408340:	d3 e0                	shl    eax,cl
  408342:	f7 d0                	not    eax
  408344:	83 e0 fc             	and    eax,0xfffffffc
  408347:	48 31 c9             	xor    rcx,rcx
  40834a:	48 31 d2             	xor    rdx,rdx
  40834d:	0f 01 ef             	wrpkru 
  408350:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  408357:	45 23 01 
  40835a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408361:	be ad de 
  408364:	49 39 c7             	cmp    r15,rax
  408367:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  40836e:	12 12 12 
  408371:	48 b9 7d 83 40 00 00 	movabs rcx,0x40837d
  408378:	00 00 00 
  40837b:	ff e0                	jmp    rax

000000000040837d <srv_call_ret_capmgr_shared_kernel_page_create>:
  40837d:	49 89 c0             	mov    r8,rax
  408380:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  408387:	be ad de 
  40838a:	48 89 e2             	mov    rdx,rsp
  40838d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  408394:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40839b:	00 
  40839c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4083a3:	7f 00 00 
  4083a6:	4c 89 e8             	mov    rax,r13
  4083a9:	48 25 ff ff 00 00    	and    rax,0xffff
  4083af:	48 c1 e0 08          	shl    rax,0x8
  4083b3:	49 01 c6             	add    r14,rax
  4083b6:	b9 01 00 00 00       	mov    ecx,0x1
  4083bb:	01 c9                	add    ecx,ecx
  4083bd:	b8 03 00 00 00       	mov    eax,0x3
  4083c2:	d3 e0                	shl    eax,cl
  4083c4:	f7 d0                	not    eax
  4083c6:	83 e0 fc             	and    eax,0xfffffffc
  4083c9:	48 31 c9             	xor    rcx,rcx
  4083cc:	48 31 d2             	xor    rdx,rdx
  4083cf:	0f 01 ef             	wrpkru 
  4083d2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4083d5:	48 c1 e2 04          	shl    rdx,0x4
  4083d9:	4c 01 f2             	add    rdx,r14
  4083dc:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  4083e0:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4083e3:	48 83 e8 01          	sub    rax,0x1
  4083e7:	49 89 06             	mov    QWORD PTR [r14],rax
  4083ea:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4083ef:	01 c9                	add    ecx,ecx
  4083f1:	b8 03 00 00 00       	mov    eax,0x3
  4083f6:	d3 e0                	shl    eax,cl
  4083f8:	f7 d0                	not    eax
  4083fa:	83 e0 fc             	and    eax,0xfffffffc
  4083fd:	48 31 c9             	xor    rcx,rcx
  408400:	48 31 d2             	xor    rdx,rdx
  408403:	0f 01 ef             	wrpkru 
  408406:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40840d:	be ad de 
  408410:	49 39 c7             	cmp    r15,rax
  408413:	4c 89 c0             	mov    rax,r8
  408416:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  40841a:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  40841d:	41 5f                	pop    r15
  40841f:	41 5e                	pop    r14
  408421:	41 5d                	pop    r13
  408423:	41 5c                	pop    r12
  408425:	5b                   	pop    rbx
  408426:	5d                   	pop    rbp
  408427:	c3                   	ret    
  408428:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40842f:	00 

0000000000408430 <__cosrt_extern_capmgr_vm_lapic_create>:
  408430:	48 b8 94 c2 45 00 00 	movabs rax,0x45c294
  408437:	00 00 00 
  40843a:	ff 10                	call   QWORD PTR [rax]
  40843c:	c3                   	ret    
  40843d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000408440 <__cosrt_fast_callgate_capmgr_vm_lapic_create>:
  408440:	55                   	push   rbp
  408441:	53                   	push   rbx
  408442:	41 54                	push   r12
  408444:	41 55                	push   r13
  408446:	41 56                	push   r14
  408448:	41 57                	push   r15
  40844a:	4d 89 c4             	mov    r12,r8
  40844d:	4c 89 cb             	mov    rbx,r9
  408450:	49 89 c8             	mov    r8,rcx
  408453:	49 89 d1             	mov    r9,rdx
  408456:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40845d:	be ad de 
  408460:	0f 01 f9             	rdtscp 
  408463:	48 89 ca             	mov    rdx,rcx
  408466:	48 25 ff 0f 00 00    	and    rax,0xfff
  40846c:	48 89 e2             	mov    rdx,rsp
  40846f:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  408476:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40847d:	00 
  40847e:	48 c1 e0 10          	shl    rax,0x10
  408482:	49 09 c5             	or     r13,rax
  408485:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40848c:	7f 00 00 
  40848f:	4c 89 e8             	mov    rax,r13
  408492:	48 25 ff ff 00 00    	and    rax,0xffff
  408498:	48 c1 e0 08          	shl    rax,0x8
  40849c:	49 01 c6             	add    r14,rax
  40849f:	b9 01 00 00 00       	mov    ecx,0x1
  4084a4:	01 c9                	add    ecx,ecx
  4084a6:	b8 03 00 00 00       	mov    eax,0x3
  4084ab:	d3 e0                	shl    eax,cl
  4084ad:	f7 d0                	not    eax
  4084af:	83 e0 fc             	and    eax,0xfffffffc
  4084b2:	48 31 c9             	xor    rcx,rcx
  4084b5:	48 31 d2             	xor    rdx,rdx
  4084b8:	0f 01 ef             	wrpkru 
  4084bb:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4084be:	48 83 c2 01          	add    rdx,0x1
  4084c2:	48 c1 e2 04          	shl    rdx,0x4
  4084c6:	4c 01 f2             	add    rdx,r14
  4084c9:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  4084d0:	45 23 01 
  4084d3:	48 89 02             	mov    QWORD PTR [rdx],rax
  4084d6:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  4084da:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4084dd:	48 83 c0 01          	add    rax,0x1
  4084e1:	49 89 06             	mov    QWORD PTR [r14],rax
  4084e4:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4084e9:	01 c9                	add    ecx,ecx
  4084eb:	b8 03 00 00 00       	mov    eax,0x3
  4084f0:	d3 e0                	shl    eax,cl
  4084f2:	f7 d0                	not    eax
  4084f4:	83 e0 fc             	and    eax,0xfffffffc
  4084f7:	48 31 c9             	xor    rcx,rcx
  4084fa:	48 31 d2             	xor    rdx,rdx
  4084fd:	0f 01 ef             	wrpkru 
  408500:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  408507:	45 23 01 
  40850a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408511:	be ad de 
  408514:	49 39 c7             	cmp    r15,rax
  408517:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  40851e:	12 12 12 
  408521:	48 b9 2d 85 40 00 00 	movabs rcx,0x40852d
  408528:	00 00 00 
  40852b:	ff e0                	jmp    rax

000000000040852d <srv_call_ret_capmgr_vm_lapic_create>:
  40852d:	49 89 c0             	mov    r8,rax
  408530:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  408537:	be ad de 
  40853a:	48 89 e2             	mov    rdx,rsp
  40853d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  408544:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40854b:	00 
  40854c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  408553:	7f 00 00 
  408556:	4c 89 e8             	mov    rax,r13
  408559:	48 25 ff ff 00 00    	and    rax,0xffff
  40855f:	48 c1 e0 08          	shl    rax,0x8
  408563:	49 01 c6             	add    r14,rax
  408566:	b9 01 00 00 00       	mov    ecx,0x1
  40856b:	01 c9                	add    ecx,ecx
  40856d:	b8 03 00 00 00       	mov    eax,0x3
  408572:	d3 e0                	shl    eax,cl
  408574:	f7 d0                	not    eax
  408576:	83 e0 fc             	and    eax,0xfffffffc
  408579:	48 31 c9             	xor    rcx,rcx
  40857c:	48 31 d2             	xor    rdx,rdx
  40857f:	0f 01 ef             	wrpkru 
  408582:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  408585:	48 c1 e2 04          	shl    rdx,0x4
  408589:	4c 01 f2             	add    rdx,r14
  40858c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  408590:	49 8b 06             	mov    rax,QWORD PTR [r14]
  408593:	48 83 e8 01          	sub    rax,0x1
  408597:	49 89 06             	mov    QWORD PTR [r14],rax
  40859a:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40859f:	01 c9                	add    ecx,ecx
  4085a1:	b8 03 00 00 00       	mov    eax,0x3
  4085a6:	d3 e0                	shl    eax,cl
  4085a8:	f7 d0                	not    eax
  4085aa:	83 e0 fc             	and    eax,0xfffffffc
  4085ad:	48 31 c9             	xor    rcx,rcx
  4085b0:	48 31 d2             	xor    rdx,rdx
  4085b3:	0f 01 ef             	wrpkru 
  4085b6:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4085bd:	be ad de 
  4085c0:	49 39 c7             	cmp    r15,rax
  4085c3:	4c 89 c0             	mov    rax,r8
  4085c6:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  4085ca:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  4085cd:	41 5f                	pop    r15
  4085cf:	41 5e                	pop    r14
  4085d1:	41 5d                	pop    r13
  4085d3:	41 5c                	pop    r12
  4085d5:	5b                   	pop    rbx
  4085d6:	5d                   	pop    rbp
  4085d7:	c3                   	ret    
  4085d8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4085df:	00 

00000000004085e0 <__cosrt_extern_capmgr_vm_shared_region_create>:
  4085e0:	48 b8 ac c2 45 00 00 	movabs rax,0x45c2ac
  4085e7:	00 00 00 
  4085ea:	ff 10                	call   QWORD PTR [rax]
  4085ec:	c3                   	ret    
  4085ed:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004085f0 <__cosrt_fast_callgate_capmgr_vm_shared_region_create>:
  4085f0:	55                   	push   rbp
  4085f1:	53                   	push   rbx
  4085f2:	41 54                	push   r12
  4085f4:	41 55                	push   r13
  4085f6:	41 56                	push   r14
  4085f8:	41 57                	push   r15
  4085fa:	4d 89 c4             	mov    r12,r8
  4085fd:	4c 89 cb             	mov    rbx,r9
  408600:	49 89 c8             	mov    r8,rcx
  408603:	49 89 d1             	mov    r9,rdx
  408606:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40860d:	be ad de 
  408610:	0f 01 f9             	rdtscp 
  408613:	48 89 ca             	mov    rdx,rcx
  408616:	48 25 ff 0f 00 00    	and    rax,0xfff
  40861c:	48 89 e2             	mov    rdx,rsp
  40861f:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  408626:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40862d:	00 
  40862e:	48 c1 e0 10          	shl    rax,0x10
  408632:	49 09 c5             	or     r13,rax
  408635:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40863c:	7f 00 00 
  40863f:	4c 89 e8             	mov    rax,r13
  408642:	48 25 ff ff 00 00    	and    rax,0xffff
  408648:	48 c1 e0 08          	shl    rax,0x8
  40864c:	49 01 c6             	add    r14,rax
  40864f:	b9 01 00 00 00       	mov    ecx,0x1
  408654:	01 c9                	add    ecx,ecx
  408656:	b8 03 00 00 00       	mov    eax,0x3
  40865b:	d3 e0                	shl    eax,cl
  40865d:	f7 d0                	not    eax
  40865f:	83 e0 fc             	and    eax,0xfffffffc
  408662:	48 31 c9             	xor    rcx,rcx
  408665:	48 31 d2             	xor    rdx,rdx
  408668:	0f 01 ef             	wrpkru 
  40866b:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40866e:	48 83 c2 01          	add    rdx,0x1
  408672:	48 c1 e2 04          	shl    rdx,0x4
  408676:	4c 01 f2             	add    rdx,r14
  408679:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  408680:	45 23 01 
  408683:	48 89 02             	mov    QWORD PTR [rdx],rax
  408686:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  40868a:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40868d:	48 83 c0 01          	add    rax,0x1
  408691:	49 89 06             	mov    QWORD PTR [r14],rax
  408694:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  408699:	01 c9                	add    ecx,ecx
  40869b:	b8 03 00 00 00       	mov    eax,0x3
  4086a0:	d3 e0                	shl    eax,cl
  4086a2:	f7 d0                	not    eax
  4086a4:	83 e0 fc             	and    eax,0xfffffffc
  4086a7:	48 31 c9             	xor    rcx,rcx
  4086aa:	48 31 d2             	xor    rdx,rdx
  4086ad:	0f 01 ef             	wrpkru 
  4086b0:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  4086b7:	45 23 01 
  4086ba:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4086c1:	be ad de 
  4086c4:	49 39 c7             	cmp    r15,rax
  4086c7:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  4086ce:	12 12 12 
  4086d1:	48 b9 dd 86 40 00 00 	movabs rcx,0x4086dd
  4086d8:	00 00 00 
  4086db:	ff e0                	jmp    rax

00000000004086dd <srv_call_ret_capmgr_vm_shared_region_create>:
  4086dd:	49 89 c0             	mov    r8,rax
  4086e0:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4086e7:	be ad de 
  4086ea:	48 89 e2             	mov    rdx,rsp
  4086ed:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4086f4:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4086fb:	00 
  4086fc:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  408703:	7f 00 00 
  408706:	4c 89 e8             	mov    rax,r13
  408709:	48 25 ff ff 00 00    	and    rax,0xffff
  40870f:	48 c1 e0 08          	shl    rax,0x8
  408713:	49 01 c6             	add    r14,rax
  408716:	b9 01 00 00 00       	mov    ecx,0x1
  40871b:	01 c9                	add    ecx,ecx
  40871d:	b8 03 00 00 00       	mov    eax,0x3
  408722:	d3 e0                	shl    eax,cl
  408724:	f7 d0                	not    eax
  408726:	83 e0 fc             	and    eax,0xfffffffc
  408729:	48 31 c9             	xor    rcx,rcx
  40872c:	48 31 d2             	xor    rdx,rdx
  40872f:	0f 01 ef             	wrpkru 
  408732:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  408735:	48 c1 e2 04          	shl    rdx,0x4
  408739:	4c 01 f2             	add    rdx,r14
  40873c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  408740:	49 8b 06             	mov    rax,QWORD PTR [r14]
  408743:	48 83 e8 01          	sub    rax,0x1
  408747:	49 89 06             	mov    QWORD PTR [r14],rax
  40874a:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40874f:	01 c9                	add    ecx,ecx
  408751:	b8 03 00 00 00       	mov    eax,0x3
  408756:	d3 e0                	shl    eax,cl
  408758:	f7 d0                	not    eax
  40875a:	83 e0 fc             	and    eax,0xfffffffc
  40875d:	48 31 c9             	xor    rcx,rcx
  408760:	48 31 d2             	xor    rdx,rdx
  408763:	0f 01 ef             	wrpkru 
  408766:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40876d:	be ad de 
  408770:	49 39 c7             	cmp    r15,rax
  408773:	4c 89 c0             	mov    rax,r8
  408776:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  40877a:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  40877d:	41 5f                	pop    r15
  40877f:	41 5e                	pop    r14
  408781:	41 5d                	pop    r13
  408783:	41 5c                	pop    r12
  408785:	5b                   	pop    rbx
  408786:	5d                   	pop    rbp
  408787:	c3                   	ret    
  408788:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40878f:	00 

0000000000408790 <__cosrt_extern_capmgr_vm_vmcb_create>:
  408790:	48 b8 c4 c2 45 00 00 	movabs rax,0x45c2c4
  408797:	00 00 00 
  40879a:	ff 10                	call   QWORD PTR [rax]
  40879c:	c3                   	ret    
  40879d:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004087a0 <__cosrt_fast_callgate_capmgr_vm_vmcb_create>:
  4087a0:	55                   	push   rbp
  4087a1:	53                   	push   rbx
  4087a2:	41 54                	push   r12
  4087a4:	41 55                	push   r13
  4087a6:	41 56                	push   r14
  4087a8:	41 57                	push   r15
  4087aa:	4d 89 c4             	mov    r12,r8
  4087ad:	4c 89 cb             	mov    rbx,r9
  4087b0:	49 89 c8             	mov    r8,rcx
  4087b3:	49 89 d1             	mov    r9,rdx
  4087b6:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4087bd:	be ad de 
  4087c0:	0f 01 f9             	rdtscp 
  4087c3:	48 89 ca             	mov    rdx,rcx
  4087c6:	48 25 ff 0f 00 00    	and    rax,0xfff
  4087cc:	48 89 e2             	mov    rdx,rsp
  4087cf:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4087d6:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4087dd:	00 
  4087de:	48 c1 e0 10          	shl    rax,0x10
  4087e2:	49 09 c5             	or     r13,rax
  4087e5:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4087ec:	7f 00 00 
  4087ef:	4c 89 e8             	mov    rax,r13
  4087f2:	48 25 ff ff 00 00    	and    rax,0xffff
  4087f8:	48 c1 e0 08          	shl    rax,0x8
  4087fc:	49 01 c6             	add    r14,rax
  4087ff:	b9 01 00 00 00       	mov    ecx,0x1
  408804:	01 c9                	add    ecx,ecx
  408806:	b8 03 00 00 00       	mov    eax,0x3
  40880b:	d3 e0                	shl    eax,cl
  40880d:	f7 d0                	not    eax
  40880f:	83 e0 fc             	and    eax,0xfffffffc
  408812:	48 31 c9             	xor    rcx,rcx
  408815:	48 31 d2             	xor    rdx,rdx
  408818:	0f 01 ef             	wrpkru 
  40881b:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40881e:	48 83 c2 01          	add    rdx,0x1
  408822:	48 c1 e2 04          	shl    rdx,0x4
  408826:	4c 01 f2             	add    rdx,r14
  408829:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  408830:	45 23 01 
  408833:	48 89 02             	mov    QWORD PTR [rdx],rax
  408836:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  40883a:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40883d:	48 83 c0 01          	add    rax,0x1
  408841:	49 89 06             	mov    QWORD PTR [r14],rax
  408844:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  408849:	01 c9                	add    ecx,ecx
  40884b:	b8 03 00 00 00       	mov    eax,0x3
  408850:	d3 e0                	shl    eax,cl
  408852:	f7 d0                	not    eax
  408854:	83 e0 fc             	and    eax,0xfffffffc
  408857:	48 31 c9             	xor    rcx,rcx
  40885a:	48 31 d2             	xor    rdx,rdx
  40885d:	0f 01 ef             	wrpkru 
  408860:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  408867:	45 23 01 
  40886a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408871:	be ad de 
  408874:	49 39 c7             	cmp    r15,rax
  408877:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  40887e:	12 12 12 
  408881:	48 b9 8d 88 40 00 00 	movabs rcx,0x40888d
  408888:	00 00 00 
  40888b:	ff e0                	jmp    rax

000000000040888d <srv_call_ret_capmgr_vm_vmcb_create>:
  40888d:	49 89 c0             	mov    r8,rax
  408890:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  408897:	be ad de 
  40889a:	48 89 e2             	mov    rdx,rsp
  40889d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4088a4:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4088ab:	00 
  4088ac:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4088b3:	7f 00 00 
  4088b6:	4c 89 e8             	mov    rax,r13
  4088b9:	48 25 ff ff 00 00    	and    rax,0xffff
  4088bf:	48 c1 e0 08          	shl    rax,0x8
  4088c3:	49 01 c6             	add    r14,rax
  4088c6:	b9 01 00 00 00       	mov    ecx,0x1
  4088cb:	01 c9                	add    ecx,ecx
  4088cd:	b8 03 00 00 00       	mov    eax,0x3
  4088d2:	d3 e0                	shl    eax,cl
  4088d4:	f7 d0                	not    eax
  4088d6:	83 e0 fc             	and    eax,0xfffffffc
  4088d9:	48 31 c9             	xor    rcx,rcx
  4088dc:	48 31 d2             	xor    rdx,rdx
  4088df:	0f 01 ef             	wrpkru 
  4088e2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4088e5:	48 c1 e2 04          	shl    rdx,0x4
  4088e9:	4c 01 f2             	add    rdx,r14
  4088ec:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  4088f0:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4088f3:	48 83 e8 01          	sub    rax,0x1
  4088f7:	49 89 06             	mov    QWORD PTR [r14],rax
  4088fa:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4088ff:	01 c9                	add    ecx,ecx
  408901:	b8 03 00 00 00       	mov    eax,0x3
  408906:	d3 e0                	shl    eax,cl
  408908:	f7 d0                	not    eax
  40890a:	83 e0 fc             	and    eax,0xfffffffc
  40890d:	48 31 c9             	xor    rcx,rcx
  408910:	48 31 d2             	xor    rdx,rdx
  408913:	0f 01 ef             	wrpkru 
  408916:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40891d:	be ad de 
  408920:	49 39 c7             	cmp    r15,rax
  408923:	4c 89 c0             	mov    rax,r8
  408926:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  40892a:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  40892d:	41 5f                	pop    r15
  40892f:	41 5e                	pop    r14
  408931:	41 5d                	pop    r13
  408933:	41 5c                	pop    r12
  408935:	5b                   	pop    rbx
  408936:	5d                   	pop    rbp
  408937:	c3                   	ret    
  408938:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40893f:	00 

0000000000408940 <__cosrt_extern_capmgr_vm_vcpu_create>:
  408940:	48 b8 dc c2 45 00 00 	movabs rax,0x45c2dc
  408947:	00 00 00 
  40894a:	ff 10                	call   QWORD PTR [rax]
  40894c:	c3                   	ret    
  40894d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000408950 <__cosrt_fast_callgate_capmgr_vm_vcpu_create>:
  408950:	55                   	push   rbp
  408951:	53                   	push   rbx
  408952:	41 54                	push   r12
  408954:	41 55                	push   r13
  408956:	41 56                	push   r14
  408958:	41 57                	push   r15
  40895a:	4d 89 c4             	mov    r12,r8
  40895d:	4c 89 cb             	mov    rbx,r9
  408960:	49 89 c8             	mov    r8,rcx
  408963:	49 89 d1             	mov    r9,rdx
  408966:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40896d:	be ad de 
  408970:	0f 01 f9             	rdtscp 
  408973:	48 89 ca             	mov    rdx,rcx
  408976:	48 25 ff 0f 00 00    	and    rax,0xfff
  40897c:	48 89 e2             	mov    rdx,rsp
  40897f:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  408986:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40898d:	00 
  40898e:	48 c1 e0 10          	shl    rax,0x10
  408992:	49 09 c5             	or     r13,rax
  408995:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40899c:	7f 00 00 
  40899f:	4c 89 e8             	mov    rax,r13
  4089a2:	48 25 ff ff 00 00    	and    rax,0xffff
  4089a8:	48 c1 e0 08          	shl    rax,0x8
  4089ac:	49 01 c6             	add    r14,rax
  4089af:	b9 01 00 00 00       	mov    ecx,0x1
  4089b4:	01 c9                	add    ecx,ecx
  4089b6:	b8 03 00 00 00       	mov    eax,0x3
  4089bb:	d3 e0                	shl    eax,cl
  4089bd:	f7 d0                	not    eax
  4089bf:	83 e0 fc             	and    eax,0xfffffffc
  4089c2:	48 31 c9             	xor    rcx,rcx
  4089c5:	48 31 d2             	xor    rdx,rdx
  4089c8:	0f 01 ef             	wrpkru 
  4089cb:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4089ce:	48 83 c2 01          	add    rdx,0x1
  4089d2:	48 c1 e2 04          	shl    rdx,0x4
  4089d6:	4c 01 f2             	add    rdx,r14
  4089d9:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  4089e0:	45 23 01 
  4089e3:	48 89 02             	mov    QWORD PTR [rdx],rax
  4089e6:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  4089ea:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4089ed:	48 83 c0 01          	add    rax,0x1
  4089f1:	49 89 06             	mov    QWORD PTR [r14],rax
  4089f4:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4089f9:	01 c9                	add    ecx,ecx
  4089fb:	b8 03 00 00 00       	mov    eax,0x3
  408a00:	d3 e0                	shl    eax,cl
  408a02:	f7 d0                	not    eax
  408a04:	83 e0 fc             	and    eax,0xfffffffc
  408a07:	48 31 c9             	xor    rcx,rcx
  408a0a:	48 31 d2             	xor    rdx,rdx
  408a0d:	0f 01 ef             	wrpkru 
  408a10:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  408a17:	45 23 01 
  408a1a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408a21:	be ad de 
  408a24:	49 39 c7             	cmp    r15,rax
  408a27:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  408a2e:	12 12 12 
  408a31:	48 b9 3d 8a 40 00 00 	movabs rcx,0x408a3d
  408a38:	00 00 00 
  408a3b:	ff e0                	jmp    rax

0000000000408a3d <srv_call_ret_capmgr_vm_vcpu_create>:
  408a3d:	49 89 c0             	mov    r8,rax
  408a40:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  408a47:	be ad de 
  408a4a:	48 89 e2             	mov    rdx,rsp
  408a4d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  408a54:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  408a5b:	00 
  408a5c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  408a63:	7f 00 00 
  408a66:	4c 89 e8             	mov    rax,r13
  408a69:	48 25 ff ff 00 00    	and    rax,0xffff
  408a6f:	48 c1 e0 08          	shl    rax,0x8
  408a73:	49 01 c6             	add    r14,rax
  408a76:	b9 01 00 00 00       	mov    ecx,0x1
  408a7b:	01 c9                	add    ecx,ecx
  408a7d:	b8 03 00 00 00       	mov    eax,0x3
  408a82:	d3 e0                	shl    eax,cl
  408a84:	f7 d0                	not    eax
  408a86:	83 e0 fc             	and    eax,0xfffffffc
  408a89:	48 31 c9             	xor    rcx,rcx
  408a8c:	48 31 d2             	xor    rdx,rdx
  408a8f:	0f 01 ef             	wrpkru 
  408a92:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  408a95:	48 c1 e2 04          	shl    rdx,0x4
  408a99:	4c 01 f2             	add    rdx,r14
  408a9c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  408aa0:	49 8b 06             	mov    rax,QWORD PTR [r14]
  408aa3:	48 83 e8 01          	sub    rax,0x1
  408aa7:	49 89 06             	mov    QWORD PTR [r14],rax
  408aaa:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  408aaf:	01 c9                	add    ecx,ecx
  408ab1:	b8 03 00 00 00       	mov    eax,0x3
  408ab6:	d3 e0                	shl    eax,cl
  408ab8:	f7 d0                	not    eax
  408aba:	83 e0 fc             	and    eax,0xfffffffc
  408abd:	48 31 c9             	xor    rcx,rcx
  408ac0:	48 31 d2             	xor    rdx,rdx
  408ac3:	0f 01 ef             	wrpkru 
  408ac6:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408acd:	be ad de 
  408ad0:	49 39 c7             	cmp    r15,rax
  408ad3:	4c 89 c0             	mov    rax,r8
  408ad6:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  408ada:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  408add:	41 5f                	pop    r15
  408adf:	41 5e                	pop    r14
  408ae1:	41 5d                	pop    r13
  408ae3:	41 5c                	pop    r12
  408ae5:	5b                   	pop    rbx
  408ae6:	5d                   	pop    rbp
  408ae7:	c3                   	ret    
  408ae8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  408aef:	00 

0000000000408af0 <__cosrt_c_memmgr_shared_page_allocn>:
#include <cos_component.h>
#include <cos_stubs.h>
#include <memmgr.h>

COS_CLIENT_STUB(cbuf_t, memmgr_shared_page_allocn, unsigned long num_pages, vaddr_t *pgaddr)
{
  408af0:	f3 0f 1e fa          	endbr64 
  408af4:	55                   	push   rbp
  408af5:	48 89 e5             	mov    rbp,rsp
  408af8:	41 57                	push   r15
  408afa:	41 56                	push   r14
  408afc:	41 55                	push   r13
  408afe:	49 89 f5             	mov    r13,rsi
  408b01:	41 54                	push   r12
  408b03:	53                   	push   rbx
  408b04:	48 83 ec 28          	sub    rsp,0x28
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  408b08:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  408b0c:	4d 85 f6             	test   r14,r14
  408b0f:	74 2f                	je     408b40 <__cosrt_c_memmgr_shared_page_allocn+0x50>
  408b11:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  408b15:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  408b19:	31 c9                	xor    ecx,ecx
  408b1b:	31 d2                	xor    edx,edx
  408b1d:	31 f6                	xor    esi,esi
  408b1f:	41 ff d6             	call   r14
	COS_CLIENT_INVCAP;
	word_t unused, addrret;
	cbuf_t ret;

	ret = cos_sinv_2rets(uc, num_pages, 0, 0, 0, &addrret, &unused);
	*pgaddr = addrret;
  408b22:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
  408b26:	49 89 55 00          	mov    QWORD PTR [r13+0x0],rdx

	return ret;
}
  408b2a:	48 83 c4 28          	add    rsp,0x28
  408b2e:	5b                   	pop    rbx
  408b2f:	41 5c                	pop    r12
  408b31:	41 5d                	pop    r13
  408b33:	41 5e                	pop    r14
  408b35:	41 5f                	pop    r15
  408b37:	5d                   	pop    rbp
  408b38:	c3                   	ret    
  408b39:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  408b40:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  408b44:	48 89 fb             	mov    rbx,rdi
  408b47:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  408b4b:	4c 89 f6             	mov    rsi,r14
  408b4e:	4c 89 f7             	mov    rdi,r14
  408b51:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  408b54:	83 c0 01             	add    eax,0x1
  408b57:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  408b5a:	48 89 29             	mov    QWORD PTR [rcx],rbp
  408b5d:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  408b61:	48 89 cd             	mov    rbp,rcx
  408b64:	49 b8 78 8b 40 00 00 	movabs r8,0x408b78
  408b6b:	00 00 00 
  408b6e:	0f 05                	syscall 
  408b70:	eb 0f                	jmp    408b81 <__cosrt_c_memmgr_shared_page_allocn+0x91>
  408b72:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  408b78:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  408b7f:	eb 07                	jmp    408b88 <__cosrt_c_memmgr_shared_page_allocn+0x98>
  408b81:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  408b88:	5d                   	pop    rbp
  408b89:	5c                   	pop    rsp
  408b8a:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  408b8e:	eb 92                	jmp    408b22 <__cosrt_c_memmgr_shared_page_allocn+0x32>

0000000000408b90 <__cosrt_c_memmgr_shared_page_map>:

COS_CLIENT_STUB(unsigned long, memmgr_shared_page_map, cbuf_t id, vaddr_t *pgaddr)
{
  408b90:	f3 0f 1e fa          	endbr64 
  408b94:	55                   	push   rbp
  408b95:	48 89 e5             	mov    rbp,rsp
  408b98:	41 57                	push   r15
	COS_CLIENT_INVCAP;
	word_t unused, addrret;
	unsigned long ret;

	ret = cos_sinv_2rets(uc, id, 0, 0, 0, &addrret, &unused);
  408b9a:	41 89 ff             	mov    r15d,edi
{
  408b9d:	41 56                	push   r14
  408b9f:	41 55                	push   r13
  408ba1:	49 89 f5             	mov    r13,rsi
  408ba4:	41 54                	push   r12
  408ba6:	53                   	push   rbx
  408ba7:	48 83 ec 28          	sub    rsp,0x28
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  408bab:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  408baf:	4d 85 f6             	test   r14,r14
  408bb2:	74 34                	je     408be8 <__cosrt_c_memmgr_shared_page_map+0x58>
  408bb4:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  408bb8:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  408bbc:	31 c9                	xor    ecx,ecx
  408bbe:	31 d2                	xor    edx,edx
  408bc0:	31 f6                	xor    esi,esi
  408bc2:	4c 89 ff             	mov    rdi,r15
  408bc5:	41 ff d6             	call   r14
	*pgaddr = addrret;
  408bc8:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
	ret = cos_sinv_2rets(uc, id, 0, 0, 0, &addrret, &unused);
  408bcc:	48 98                	cdqe   
	*pgaddr = addrret;
  408bce:	49 89 55 00          	mov    QWORD PTR [r13+0x0],rdx

	return ret;
}
  408bd2:	48 83 c4 28          	add    rsp,0x28
  408bd6:	5b                   	pop    rbx
  408bd7:	41 5c                	pop    r12
  408bd9:	41 5d                	pop    r13
  408bdb:	41 5e                	pop    r14
  408bdd:	41 5f                	pop    r15
  408bdf:	5d                   	pop    rbp
  408be0:	c3                   	ret    
  408be1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  408be8:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  408bec:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  408bf0:	4c 89 fb             	mov    rbx,r15
  408bf3:	4c 89 f6             	mov    rsi,r14
  408bf6:	4c 89 f7             	mov    rdi,r14
  408bf9:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  408bfc:	83 c0 01             	add    eax,0x1
  408bff:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  408c02:	48 89 29             	mov    QWORD PTR [rcx],rbp
  408c05:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  408c09:	48 89 cd             	mov    rbp,rcx
  408c0c:	49 b8 20 8c 40 00 00 	movabs r8,0x408c20
  408c13:	00 00 00 
  408c16:	0f 05                	syscall 
  408c18:	eb 0f                	jmp    408c29 <__cosrt_c_memmgr_shared_page_map+0x99>
  408c1a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  408c20:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  408c27:	eb 07                	jmp    408c30 <__cosrt_c_memmgr_shared_page_map+0xa0>
  408c29:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  408c30:	5d                   	pop    rbp
  408c31:	5c                   	pop    rsp
  408c32:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  408c36:	eb 90                	jmp    408bc8 <__cosrt_c_memmgr_shared_page_map+0x38>
  408c38:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  408c3f:	00 

0000000000408c40 <__cosrt_c_memmgr_shared_page_allocn_aligned>:

COS_CLIENT_STUB(cbuf_t, memmgr_shared_page_allocn_aligned, unsigned long num_pages, unsigned long align, vaddr_t *pgaddr)
{
  408c40:	f3 0f 1e fa          	endbr64 
  408c44:	55                   	push   rbp
  408c45:	48 89 e5             	mov    rbp,rsp
  408c48:	41 57                	push   r15
  408c4a:	49 89 d7             	mov    r15,rdx
  408c4d:	41 56                	push   r14
  408c4f:	41 55                	push   r13
  408c51:	41 54                	push   r12
  408c53:	53                   	push   rbx
  408c54:	48 83 ec 28          	sub    rsp,0x28
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  408c58:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  408c5c:	4d 85 f6             	test   r14,r14
  408c5f:	74 2f                	je     408c90 <__cosrt_c_memmgr_shared_page_allocn_aligned+0x50>
  408c61:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  408c65:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  408c69:	31 c9                	xor    ecx,ecx
  408c6b:	31 d2                	xor    edx,edx
  408c6d:	41 ff d6             	call   r14
	COS_CLIENT_INVCAP;
	word_t unused, addrret;
	cbuf_t ret;

	ret = cos_sinv_2rets(uc, num_pages, align, 0, 0, &addrret, &unused);
	*pgaddr = addrret;
  408c70:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
  408c74:	49 89 17             	mov    QWORD PTR [r15],rdx

	return ret;
}
  408c77:	48 83 c4 28          	add    rsp,0x28
  408c7b:	5b                   	pop    rbx
  408c7c:	41 5c                	pop    r12
  408c7e:	41 5d                	pop    r13
  408c80:	41 5e                	pop    r14
  408c82:	41 5f                	pop    r15
  408c84:	5d                   	pop    rbp
  408c85:	c3                   	ret    
  408c86:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  408c8d:	00 00 00 
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  408c90:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  408c94:	48 89 fb             	mov    rbx,rdi
  408c97:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  408c9b:	4c 89 f7             	mov    rdi,r14
  408c9e:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  408ca1:	83 c0 01             	add    eax,0x1
  408ca4:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  408ca7:	48 89 29             	mov    QWORD PTR [rcx],rbp
  408caa:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  408cae:	48 89 cd             	mov    rbp,rcx
  408cb1:	49 b8 c8 8c 40 00 00 	movabs r8,0x408cc8
  408cb8:	00 00 00 
  408cbb:	0f 05                	syscall 
  408cbd:	0f 1f 00             	nop    DWORD PTR [rax]
  408cc0:	eb 0f                	jmp    408cd1 <__cosrt_c_memmgr_shared_page_allocn_aligned+0x91>
  408cc2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  408cc8:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  408ccf:	eb 07                	jmp    408cd8 <__cosrt_c_memmgr_shared_page_allocn_aligned+0x98>
  408cd1:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  408cd8:	5d                   	pop    rbp
  408cd9:	5c                   	pop    rsp
  408cda:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  408cde:	eb 90                	jmp    408c70 <__cosrt_c_memmgr_shared_page_allocn_aligned+0x30>

0000000000408ce0 <__cosrt_c_memmgr_shared_page_map_aligned>:

COS_CLIENT_STUB(unsigned long, memmgr_shared_page_map_aligned, cbuf_t id, unsigned long align, vaddr_t *pgaddr)
{
  408ce0:	f3 0f 1e fa          	endbr64 
  408ce4:	55                   	push   rbp
  408ce5:	48 89 e5             	mov    rbp,rsp
  408ce8:	41 57                	push   r15
  408cea:	49 89 d7             	mov    r15,rdx
  408ced:	41 56                	push   r14
  408cef:	41 55                	push   r13
	COS_CLIENT_INVCAP;
	word_t unused, addrret;
	unsigned long ret;

	ret = cos_sinv_2rets(uc, id, align, 0, 0, &addrret, &unused);
  408cf1:	41 89 fd             	mov    r13d,edi
{
  408cf4:	41 54                	push   r12
  408cf6:	53                   	push   rbx
  408cf7:	48 83 ec 28          	sub    rsp,0x28
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  408cfb:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  408cff:	4d 85 f6             	test   r14,r14
  408d02:	74 2c                	je     408d30 <__cosrt_c_memmgr_shared_page_map_aligned+0x50>
  408d04:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  408d08:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  408d0c:	31 c9                	xor    ecx,ecx
  408d0e:	31 d2                	xor    edx,edx
  408d10:	4c 89 ef             	mov    rdi,r13
  408d13:	41 ff d6             	call   r14
	*pgaddr = addrret;
  408d16:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
	ret = cos_sinv_2rets(uc, id, align, 0, 0, &addrret, &unused);
  408d1a:	48 98                	cdqe   
	*pgaddr = addrret;
  408d1c:	49 89 17             	mov    QWORD PTR [r15],rdx

	return ret;
}
  408d1f:	48 83 c4 28          	add    rsp,0x28
  408d23:	5b                   	pop    rbx
  408d24:	41 5c                	pop    r12
  408d26:	41 5d                	pop    r13
  408d28:	41 5e                	pop    r14
  408d2a:	41 5f                	pop    r15
  408d2c:	5d                   	pop    rbp
  408d2d:	c3                   	ret    
  408d2e:	66 90                	xchg   ax,ax
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  408d30:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  408d34:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  408d38:	4c 89 eb             	mov    rbx,r13
  408d3b:	4c 89 f7             	mov    rdi,r14
  408d3e:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  408d41:	83 c0 01             	add    eax,0x1
  408d44:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  408d47:	48 89 29             	mov    QWORD PTR [rcx],rbp
  408d4a:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  408d4e:	48 89 cd             	mov    rbp,rcx
  408d51:	49 b8 68 8d 40 00 00 	movabs r8,0x408d68
  408d58:	00 00 00 
  408d5b:	0f 05                	syscall 
  408d5d:	0f 1f 00             	nop    DWORD PTR [rax]
  408d60:	eb 0f                	jmp    408d71 <__cosrt_c_memmgr_shared_page_map_aligned+0x91>
  408d62:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  408d68:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  408d6f:	eb 07                	jmp    408d78 <__cosrt_c_memmgr_shared_page_map_aligned+0x98>
  408d71:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  408d78:	5d                   	pop    rbp
  408d79:	5c                   	pop    rsp
  408d7a:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  408d7e:	eb 96                	jmp    408d16 <__cosrt_c_memmgr_shared_page_map_aligned+0x36>

0000000000408d80 <__cosrt_c_memmgr_shared_page_map_aligned_in_vm>:

COS_CLIENT_STUB(unsigned long, memmgr_shared_page_map_aligned_in_vm, cbuf_t id, unsigned long align, vaddr_t *pgaddr, compid_t cid)
{
  408d80:	f3 0f 1e fa          	endbr64 
  408d84:	55                   	push   rbp
  408d85:	48 89 e5             	mov    rbp,rsp
  408d88:	41 57                	push   r15
	COS_CLIENT_INVCAP;
	word_t unused, addrret;
	unsigned long ret;

	ret = cos_sinv_2rets(uc, id, align, cid, 0, &addrret, &unused);
  408d8a:	41 89 ff             	mov    r15d,edi
{
  408d8d:	41 56                	push   r14
  408d8f:	41 55                	push   r13
  408d91:	49 89 cd             	mov    r13,rcx
  408d94:	41 54                	push   r12
  408d96:	53                   	push   rbx
  408d97:	48 83 ec 38          	sub    rsp,0x38
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  408d9b:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  408d9f:	48 89 55 a8          	mov    QWORD PTR [rbp-0x58],rdx
  408da3:	4d 85 f6             	test   r14,r14
  408da6:	74 38                	je     408de0 <__cosrt_c_memmgr_shared_page_map_aligned_in_vm+0x60>
  408da8:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  408dac:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  408db0:	31 c9                	xor    ecx,ecx
  408db2:	4c 89 ea             	mov    rdx,r13
  408db5:	4c 89 ff             	mov    rdi,r15
  408db8:	41 ff d6             	call   r14
	*pgaddr = addrret;
  408dbb:	48 8b 5d a8          	mov    rbx,QWORD PTR [rbp-0x58]
  408dbf:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
	ret = cos_sinv_2rets(uc, id, align, cid, 0, &addrret, &unused);
  408dc3:	48 98                	cdqe   
	*pgaddr = addrret;
  408dc5:	48 89 13             	mov    QWORD PTR [rbx],rdx

	return ret;
}
  408dc8:	48 83 c4 38          	add    rsp,0x38
  408dcc:	5b                   	pop    rbx
  408dcd:	41 5c                	pop    r12
  408dcf:	41 5d                	pop    r13
  408dd1:	41 5e                	pop    r14
  408dd3:	41 5f                	pop    r15
  408dd5:	5d                   	pop    rbp
  408dd6:	c3                   	ret    
  408dd7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  408dde:	00 00 
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  408de0:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  408de4:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  408de8:	4c 89 fb             	mov    rbx,r15
  408deb:	4c 89 ef             	mov    rdi,r13
  408dee:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  408df1:	83 c0 01             	add    eax,0x1
  408df4:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  408df7:	48 89 29             	mov    QWORD PTR [rcx],rbp
  408dfa:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  408dfe:	48 89 cd             	mov    rbp,rcx
  408e01:	49 b8 18 8e 40 00 00 	movabs r8,0x408e18
  408e08:	00 00 00 
  408e0b:	0f 05                	syscall 
  408e0d:	0f 1f 00             	nop    DWORD PTR [rax]
  408e10:	eb 0f                	jmp    408e21 <__cosrt_c_memmgr_shared_page_map_aligned_in_vm+0xa1>
  408e12:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  408e18:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  408e1f:	eb 07                	jmp    408e28 <__cosrt_c_memmgr_shared_page_map_aligned_in_vm+0xa8>
  408e21:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  408e28:	5d                   	pop    rbp
  408e29:	5c                   	pop    rsp
  408e2a:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  408e2e:	eb 8b                	jmp    408dbb <__cosrt_c_memmgr_shared_page_map_aligned_in_vm+0x3b>

0000000000408e30 <__cosrt_extern_memmgr_heap_page_allocn>:
  408e30:	48 b8 f4 c2 45 00 00 	movabs rax,0x45c2f4
  408e37:	00 00 00 
  408e3a:	ff 10                	call   QWORD PTR [rax]
  408e3c:	c3                   	ret    
  408e3d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000408e40 <__cosrt_fast_callgate_memmgr_heap_page_allocn>:
  408e40:	55                   	push   rbp
  408e41:	41 55                	push   r13
  408e43:	41 56                	push   r14
  408e45:	41 57                	push   r15
  408e47:	49 89 c8             	mov    r8,rcx
  408e4a:	49 89 d1             	mov    r9,rdx
  408e4d:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  408e54:	be ad de 
  408e57:	0f 01 f9             	rdtscp 
  408e5a:	48 89 c8             	mov    rax,rcx
  408e5d:	48 25 ff 0f 00 00    	and    rax,0xfff
  408e63:	48 89 e2             	mov    rdx,rsp
  408e66:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  408e6d:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  408e74:	00 
  408e75:	48 c1 e0 10          	shl    rax,0x10
  408e79:	49 09 c5             	or     r13,rax
  408e7c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  408e83:	7f 00 00 
  408e86:	4c 89 e8             	mov    rax,r13
  408e89:	48 25 ff ff 00 00    	and    rax,0xffff
  408e8f:	48 c1 e0 08          	shl    rax,0x8
  408e93:	49 01 c6             	add    r14,rax
  408e96:	b9 01 00 00 00       	mov    ecx,0x1
  408e9b:	01 c9                	add    ecx,ecx
  408e9d:	b8 03 00 00 00       	mov    eax,0x3
  408ea2:	d3 e0                	shl    eax,cl
  408ea4:	f7 d0                	not    eax
  408ea6:	83 e0 fc             	and    eax,0xfffffffc
  408ea9:	48 31 c9             	xor    rcx,rcx
  408eac:	48 31 d2             	xor    rdx,rdx
  408eaf:	0f 01 ef             	wrpkru 
  408eb2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  408eb5:	48 83 c2 01          	add    rdx,0x1
  408eb9:	48 c1 e2 04          	shl    rdx,0x4
  408ebd:	4c 01 f2             	add    rdx,r14
  408ec0:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  408ec7:	45 23 01 
  408eca:	48 89 02             	mov    QWORD PTR [rdx],rax
  408ecd:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  408ed1:	49 8b 06             	mov    rax,QWORD PTR [r14]
  408ed4:	48 83 c0 01          	add    rax,0x1
  408ed8:	49 89 06             	mov    QWORD PTR [r14],rax
  408edb:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  408ee0:	01 c9                	add    ecx,ecx
  408ee2:	b8 03 00 00 00       	mov    eax,0x3
  408ee7:	d3 e0                	shl    eax,cl
  408ee9:	f7 d0                	not    eax
  408eeb:	83 e0 fc             	and    eax,0xfffffffc
  408eee:	48 31 c9             	xor    rcx,rcx
  408ef1:	48 31 d2             	xor    rdx,rdx
  408ef4:	0f 01 ef             	wrpkru 
  408ef7:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  408efe:	45 23 01 
  408f01:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408f08:	be ad de 
  408f0b:	49 39 c7             	cmp    r15,rax
  408f0e:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  408f15:	12 12 12 
  408f18:	48 b9 24 8f 40 00 00 	movabs rcx,0x408f24
  408f1f:	00 00 00 
  408f22:	ff e0                	jmp    rax

0000000000408f24 <srv_call_ret_memmgr_heap_page_allocn>:
  408f24:	49 89 c0             	mov    r8,rax
  408f27:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  408f2e:	be ad de 
  408f31:	48 89 e2             	mov    rdx,rsp
  408f34:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  408f3b:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  408f42:	00 
  408f43:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  408f4a:	7f 00 00 
  408f4d:	4c 89 e8             	mov    rax,r13
  408f50:	48 25 ff ff 00 00    	and    rax,0xffff
  408f56:	48 c1 e0 08          	shl    rax,0x8
  408f5a:	49 01 c6             	add    r14,rax
  408f5d:	b9 01 00 00 00       	mov    ecx,0x1
  408f62:	01 c9                	add    ecx,ecx
  408f64:	b8 03 00 00 00       	mov    eax,0x3
  408f69:	d3 e0                	shl    eax,cl
  408f6b:	f7 d0                	not    eax
  408f6d:	83 e0 fc             	and    eax,0xfffffffc
  408f70:	48 31 c9             	xor    rcx,rcx
  408f73:	48 31 d2             	xor    rdx,rdx
  408f76:	0f 01 ef             	wrpkru 
  408f79:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  408f7c:	48 c1 e2 04          	shl    rdx,0x4
  408f80:	4c 01 f2             	add    rdx,r14
  408f83:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  408f87:	49 8b 06             	mov    rax,QWORD PTR [r14]
  408f8a:	48 83 e8 01          	sub    rax,0x1
  408f8e:	49 89 06             	mov    QWORD PTR [r14],rax
  408f91:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  408f96:	01 c9                	add    ecx,ecx
  408f98:	b8 03 00 00 00       	mov    eax,0x3
  408f9d:	d3 e0                	shl    eax,cl
  408f9f:	f7 d0                	not    eax
  408fa1:	83 e0 fc             	and    eax,0xfffffffc
  408fa4:	48 31 c9             	xor    rcx,rcx
  408fa7:	48 31 d2             	xor    rdx,rdx
  408faa:	0f 01 ef             	wrpkru 
  408fad:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408fb4:	be ad de 
  408fb7:	49 39 c7             	cmp    r15,rax
  408fba:	4c 89 c0             	mov    rax,r8
  408fbd:	41 5f                	pop    r15
  408fbf:	41 5e                	pop    r14
  408fc1:	41 5d                	pop    r13
  408fc3:	5d                   	pop    rbp
  408fc4:	c3                   	ret    
  408fc5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  408fcc:	00 00 00 00 

0000000000408fd0 <__cosrt_extern_memmgr_heap_page_allocn_aligned>:
  408fd0:	48 b8 0c c3 45 00 00 	movabs rax,0x45c30c
  408fd7:	00 00 00 
  408fda:	ff 10                	call   QWORD PTR [rax]
  408fdc:	c3                   	ret    
  408fdd:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000408fe0 <__cosrt_fast_callgate_memmgr_heap_page_allocn_aligned>:
  408fe0:	55                   	push   rbp
  408fe1:	41 55                	push   r13
  408fe3:	41 56                	push   r14
  408fe5:	41 57                	push   r15
  408fe7:	49 89 c8             	mov    r8,rcx
  408fea:	49 89 d1             	mov    r9,rdx
  408fed:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  408ff4:	be ad de 
  408ff7:	0f 01 f9             	rdtscp 
  408ffa:	48 89 c8             	mov    rax,rcx
  408ffd:	48 25 ff 0f 00 00    	and    rax,0xfff
  409003:	48 89 e2             	mov    rdx,rsp
  409006:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40900d:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  409014:	00 
  409015:	48 c1 e0 10          	shl    rax,0x10
  409019:	49 09 c5             	or     r13,rax
  40901c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  409023:	7f 00 00 
  409026:	4c 89 e8             	mov    rax,r13
  409029:	48 25 ff ff 00 00    	and    rax,0xffff
  40902f:	48 c1 e0 08          	shl    rax,0x8
  409033:	49 01 c6             	add    r14,rax
  409036:	b9 01 00 00 00       	mov    ecx,0x1
  40903b:	01 c9                	add    ecx,ecx
  40903d:	b8 03 00 00 00       	mov    eax,0x3
  409042:	d3 e0                	shl    eax,cl
  409044:	f7 d0                	not    eax
  409046:	83 e0 fc             	and    eax,0xfffffffc
  409049:	48 31 c9             	xor    rcx,rcx
  40904c:	48 31 d2             	xor    rdx,rdx
  40904f:	0f 01 ef             	wrpkru 
  409052:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  409055:	48 83 c2 01          	add    rdx,0x1
  409059:	48 c1 e2 04          	shl    rdx,0x4
  40905d:	4c 01 f2             	add    rdx,r14
  409060:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  409067:	45 23 01 
  40906a:	48 89 02             	mov    QWORD PTR [rdx],rax
  40906d:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  409071:	49 8b 06             	mov    rax,QWORD PTR [r14]
  409074:	48 83 c0 01          	add    rax,0x1
  409078:	49 89 06             	mov    QWORD PTR [r14],rax
  40907b:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  409080:	01 c9                	add    ecx,ecx
  409082:	b8 03 00 00 00       	mov    eax,0x3
  409087:	d3 e0                	shl    eax,cl
  409089:	f7 d0                	not    eax
  40908b:	83 e0 fc             	and    eax,0xfffffffc
  40908e:	48 31 c9             	xor    rcx,rcx
  409091:	48 31 d2             	xor    rdx,rdx
  409094:	0f 01 ef             	wrpkru 
  409097:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  40909e:	45 23 01 
  4090a1:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4090a8:	be ad de 
  4090ab:	49 39 c7             	cmp    r15,rax
  4090ae:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  4090b5:	12 12 12 
  4090b8:	48 b9 c4 90 40 00 00 	movabs rcx,0x4090c4
  4090bf:	00 00 00 
  4090c2:	ff e0                	jmp    rax

00000000004090c4 <srv_call_ret_memmgr_heap_page_allocn_aligned>:
  4090c4:	49 89 c0             	mov    r8,rax
  4090c7:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4090ce:	be ad de 
  4090d1:	48 89 e2             	mov    rdx,rsp
  4090d4:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4090db:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4090e2:	00 
  4090e3:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4090ea:	7f 00 00 
  4090ed:	4c 89 e8             	mov    rax,r13
  4090f0:	48 25 ff ff 00 00    	and    rax,0xffff
  4090f6:	48 c1 e0 08          	shl    rax,0x8
  4090fa:	49 01 c6             	add    r14,rax
  4090fd:	b9 01 00 00 00       	mov    ecx,0x1
  409102:	01 c9                	add    ecx,ecx
  409104:	b8 03 00 00 00       	mov    eax,0x3
  409109:	d3 e0                	shl    eax,cl
  40910b:	f7 d0                	not    eax
  40910d:	83 e0 fc             	and    eax,0xfffffffc
  409110:	48 31 c9             	xor    rcx,rcx
  409113:	48 31 d2             	xor    rdx,rdx
  409116:	0f 01 ef             	wrpkru 
  409119:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40911c:	48 c1 e2 04          	shl    rdx,0x4
  409120:	4c 01 f2             	add    rdx,r14
  409123:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  409127:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40912a:	48 83 e8 01          	sub    rax,0x1
  40912e:	49 89 06             	mov    QWORD PTR [r14],rax
  409131:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  409136:	01 c9                	add    ecx,ecx
  409138:	b8 03 00 00 00       	mov    eax,0x3
  40913d:	d3 e0                	shl    eax,cl
  40913f:	f7 d0                	not    eax
  409141:	83 e0 fc             	and    eax,0xfffffffc
  409144:	48 31 c9             	xor    rcx,rcx
  409147:	48 31 d2             	xor    rdx,rdx
  40914a:	0f 01 ef             	wrpkru 
  40914d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409154:	be ad de 
  409157:	49 39 c7             	cmp    r15,rax
  40915a:	4c 89 c0             	mov    rax,r8
  40915d:	41 5f                	pop    r15
  40915f:	41 5e                	pop    r14
  409161:	41 5d                	pop    r13
  409163:	5d                   	pop    rbp
  409164:	c3                   	ret    
  409165:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40916c:	00 00 00 00 

0000000000409170 <__cosrt_extern_memmgr_virt_to_phys>:
  409170:	48 b8 24 c3 45 00 00 	movabs rax,0x45c324
  409177:	00 00 00 
  40917a:	ff 10                	call   QWORD PTR [rax]
  40917c:	c3                   	ret    
  40917d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000409180 <__cosrt_fast_callgate_memmgr_virt_to_phys>:
  409180:	55                   	push   rbp
  409181:	41 55                	push   r13
  409183:	41 56                	push   r14
  409185:	41 57                	push   r15
  409187:	49 89 c8             	mov    r8,rcx
  40918a:	49 89 d1             	mov    r9,rdx
  40918d:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  409194:	be ad de 
  409197:	0f 01 f9             	rdtscp 
  40919a:	48 89 c8             	mov    rax,rcx
  40919d:	48 25 ff 0f 00 00    	and    rax,0xfff
  4091a3:	48 89 e2             	mov    rdx,rsp
  4091a6:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4091ad:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4091b4:	00 
  4091b5:	48 c1 e0 10          	shl    rax,0x10
  4091b9:	49 09 c5             	or     r13,rax
  4091bc:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4091c3:	7f 00 00 
  4091c6:	4c 89 e8             	mov    rax,r13
  4091c9:	48 25 ff ff 00 00    	and    rax,0xffff
  4091cf:	48 c1 e0 08          	shl    rax,0x8
  4091d3:	49 01 c6             	add    r14,rax
  4091d6:	b9 01 00 00 00       	mov    ecx,0x1
  4091db:	01 c9                	add    ecx,ecx
  4091dd:	b8 03 00 00 00       	mov    eax,0x3
  4091e2:	d3 e0                	shl    eax,cl
  4091e4:	f7 d0                	not    eax
  4091e6:	83 e0 fc             	and    eax,0xfffffffc
  4091e9:	48 31 c9             	xor    rcx,rcx
  4091ec:	48 31 d2             	xor    rdx,rdx
  4091ef:	0f 01 ef             	wrpkru 
  4091f2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4091f5:	48 83 c2 01          	add    rdx,0x1
  4091f9:	48 c1 e2 04          	shl    rdx,0x4
  4091fd:	4c 01 f2             	add    rdx,r14
  409200:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  409207:	45 23 01 
  40920a:	48 89 02             	mov    QWORD PTR [rdx],rax
  40920d:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  409211:	49 8b 06             	mov    rax,QWORD PTR [r14]
  409214:	48 83 c0 01          	add    rax,0x1
  409218:	49 89 06             	mov    QWORD PTR [r14],rax
  40921b:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  409220:	01 c9                	add    ecx,ecx
  409222:	b8 03 00 00 00       	mov    eax,0x3
  409227:	d3 e0                	shl    eax,cl
  409229:	f7 d0                	not    eax
  40922b:	83 e0 fc             	and    eax,0xfffffffc
  40922e:	48 31 c9             	xor    rcx,rcx
  409231:	48 31 d2             	xor    rdx,rdx
  409234:	0f 01 ef             	wrpkru 
  409237:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  40923e:	45 23 01 
  409241:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409248:	be ad de 
  40924b:	49 39 c7             	cmp    r15,rax
  40924e:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  409255:	12 12 12 
  409258:	48 b9 64 92 40 00 00 	movabs rcx,0x409264
  40925f:	00 00 00 
  409262:	ff e0                	jmp    rax

0000000000409264 <srv_call_ret_memmgr_virt_to_phys>:
  409264:	49 89 c0             	mov    r8,rax
  409267:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40926e:	be ad de 
  409271:	48 89 e2             	mov    rdx,rsp
  409274:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40927b:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  409282:	00 
  409283:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40928a:	7f 00 00 
  40928d:	4c 89 e8             	mov    rax,r13
  409290:	48 25 ff ff 00 00    	and    rax,0xffff
  409296:	48 c1 e0 08          	shl    rax,0x8
  40929a:	49 01 c6             	add    r14,rax
  40929d:	b9 01 00 00 00       	mov    ecx,0x1
  4092a2:	01 c9                	add    ecx,ecx
  4092a4:	b8 03 00 00 00       	mov    eax,0x3
  4092a9:	d3 e0                	shl    eax,cl
  4092ab:	f7 d0                	not    eax
  4092ad:	83 e0 fc             	and    eax,0xfffffffc
  4092b0:	48 31 c9             	xor    rcx,rcx
  4092b3:	48 31 d2             	xor    rdx,rdx
  4092b6:	0f 01 ef             	wrpkru 
  4092b9:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4092bc:	48 c1 e2 04          	shl    rdx,0x4
  4092c0:	4c 01 f2             	add    rdx,r14
  4092c3:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  4092c7:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4092ca:	48 83 e8 01          	sub    rax,0x1
  4092ce:	49 89 06             	mov    QWORD PTR [r14],rax
  4092d1:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4092d6:	01 c9                	add    ecx,ecx
  4092d8:	b8 03 00 00 00       	mov    eax,0x3
  4092dd:	d3 e0                	shl    eax,cl
  4092df:	f7 d0                	not    eax
  4092e1:	83 e0 fc             	and    eax,0xfffffffc
  4092e4:	48 31 c9             	xor    rcx,rcx
  4092e7:	48 31 d2             	xor    rdx,rdx
  4092ea:	0f 01 ef             	wrpkru 
  4092ed:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4092f4:	be ad de 
  4092f7:	49 39 c7             	cmp    r15,rax
  4092fa:	4c 89 c0             	mov    rax,r8
  4092fd:	41 5f                	pop    r15
  4092ff:	41 5e                	pop    r14
  409301:	41 5d                	pop    r13
  409303:	5d                   	pop    rbp
  409304:	c3                   	ret    
  409305:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40930c:	00 00 00 00 

0000000000409310 <__cosrt_extern_memmgr_map_phys_to_virt>:
  409310:	48 b8 3c c3 45 00 00 	movabs rax,0x45c33c
  409317:	00 00 00 
  40931a:	ff 10                	call   QWORD PTR [rax]
  40931c:	c3                   	ret    
  40931d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000409320 <__cosrt_fast_callgate_memmgr_map_phys_to_virt>:
  409320:	55                   	push   rbp
  409321:	41 55                	push   r13
  409323:	41 56                	push   r14
  409325:	41 57                	push   r15
  409327:	49 89 c8             	mov    r8,rcx
  40932a:	49 89 d1             	mov    r9,rdx
  40932d:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  409334:	be ad de 
  409337:	0f 01 f9             	rdtscp 
  40933a:	48 89 c8             	mov    rax,rcx
  40933d:	48 25 ff 0f 00 00    	and    rax,0xfff
  409343:	48 89 e2             	mov    rdx,rsp
  409346:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40934d:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  409354:	00 
  409355:	48 c1 e0 10          	shl    rax,0x10
  409359:	49 09 c5             	or     r13,rax
  40935c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  409363:	7f 00 00 
  409366:	4c 89 e8             	mov    rax,r13
  409369:	48 25 ff ff 00 00    	and    rax,0xffff
  40936f:	48 c1 e0 08          	shl    rax,0x8
  409373:	49 01 c6             	add    r14,rax
  409376:	b9 01 00 00 00       	mov    ecx,0x1
  40937b:	01 c9                	add    ecx,ecx
  40937d:	b8 03 00 00 00       	mov    eax,0x3
  409382:	d3 e0                	shl    eax,cl
  409384:	f7 d0                	not    eax
  409386:	83 e0 fc             	and    eax,0xfffffffc
  409389:	48 31 c9             	xor    rcx,rcx
  40938c:	48 31 d2             	xor    rdx,rdx
  40938f:	0f 01 ef             	wrpkru 
  409392:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  409395:	48 83 c2 01          	add    rdx,0x1
  409399:	48 c1 e2 04          	shl    rdx,0x4
  40939d:	4c 01 f2             	add    rdx,r14
  4093a0:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  4093a7:	45 23 01 
  4093aa:	48 89 02             	mov    QWORD PTR [rdx],rax
  4093ad:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  4093b1:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4093b4:	48 83 c0 01          	add    rax,0x1
  4093b8:	49 89 06             	mov    QWORD PTR [r14],rax
  4093bb:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4093c0:	01 c9                	add    ecx,ecx
  4093c2:	b8 03 00 00 00       	mov    eax,0x3
  4093c7:	d3 e0                	shl    eax,cl
  4093c9:	f7 d0                	not    eax
  4093cb:	83 e0 fc             	and    eax,0xfffffffc
  4093ce:	48 31 c9             	xor    rcx,rcx
  4093d1:	48 31 d2             	xor    rdx,rdx
  4093d4:	0f 01 ef             	wrpkru 
  4093d7:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  4093de:	45 23 01 
  4093e1:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4093e8:	be ad de 
  4093eb:	49 39 c7             	cmp    r15,rax
  4093ee:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  4093f5:	12 12 12 
  4093f8:	48 b9 04 94 40 00 00 	movabs rcx,0x409404
  4093ff:	00 00 00 
  409402:	ff e0                	jmp    rax

0000000000409404 <srv_call_ret_memmgr_map_phys_to_virt>:
  409404:	49 89 c0             	mov    r8,rax
  409407:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40940e:	be ad de 
  409411:	48 89 e2             	mov    rdx,rsp
  409414:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40941b:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  409422:	00 
  409423:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40942a:	7f 00 00 
  40942d:	4c 89 e8             	mov    rax,r13
  409430:	48 25 ff ff 00 00    	and    rax,0xffff
  409436:	48 c1 e0 08          	shl    rax,0x8
  40943a:	49 01 c6             	add    r14,rax
  40943d:	b9 01 00 00 00       	mov    ecx,0x1
  409442:	01 c9                	add    ecx,ecx
  409444:	b8 03 00 00 00       	mov    eax,0x3
  409449:	d3 e0                	shl    eax,cl
  40944b:	f7 d0                	not    eax
  40944d:	83 e0 fc             	and    eax,0xfffffffc
  409450:	48 31 c9             	xor    rcx,rcx
  409453:	48 31 d2             	xor    rdx,rdx
  409456:	0f 01 ef             	wrpkru 
  409459:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40945c:	48 c1 e2 04          	shl    rdx,0x4
  409460:	4c 01 f2             	add    rdx,r14
  409463:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  409467:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40946a:	48 83 e8 01          	sub    rax,0x1
  40946e:	49 89 06             	mov    QWORD PTR [r14],rax
  409471:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  409476:	01 c9                	add    ecx,ecx
  409478:	b8 03 00 00 00       	mov    eax,0x3
  40947d:	d3 e0                	shl    eax,cl
  40947f:	f7 d0                	not    eax
  409481:	83 e0 fc             	and    eax,0xfffffffc
  409484:	48 31 c9             	xor    rcx,rcx
  409487:	48 31 d2             	xor    rdx,rdx
  40948a:	0f 01 ef             	wrpkru 
  40948d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409494:	be ad de 
  409497:	49 39 c7             	cmp    r15,rax
  40949a:	4c 89 c0             	mov    rax,r8
  40949d:	41 5f                	pop    r15
  40949f:	41 5e                	pop    r14
  4094a1:	41 5d                	pop    r13
  4094a3:	5d                   	pop    rbp
  4094a4:	c3                   	ret    
  4094a5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4094ac:	00 00 00 00 

00000000004094b0 <__cosrt_extern_memmgr_shared_page_allocn>:
  4094b0:	48 b8 54 c3 45 00 00 	movabs rax,0x45c354
  4094b7:	00 00 00 
  4094ba:	ff 10                	call   QWORD PTR [rax]
  4094bc:	c3                   	ret    
  4094bd:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004094c0 <__cosrt_fast_callgate_memmgr_shared_page_allocn>:
  4094c0:	55                   	push   rbp
  4094c1:	53                   	push   rbx
  4094c2:	41 54                	push   r12
  4094c4:	41 55                	push   r13
  4094c6:	41 56                	push   r14
  4094c8:	41 57                	push   r15
  4094ca:	4d 89 c4             	mov    r12,r8
  4094cd:	4c 89 cb             	mov    rbx,r9
  4094d0:	49 89 c8             	mov    r8,rcx
  4094d3:	49 89 d1             	mov    r9,rdx
  4094d6:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4094dd:	be ad de 
  4094e0:	0f 01 f9             	rdtscp 
  4094e3:	48 89 ca             	mov    rdx,rcx
  4094e6:	48 25 ff 0f 00 00    	and    rax,0xfff
  4094ec:	48 89 e2             	mov    rdx,rsp
  4094ef:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4094f6:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4094fd:	00 
  4094fe:	48 c1 e0 10          	shl    rax,0x10
  409502:	49 09 c5             	or     r13,rax
  409505:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40950c:	7f 00 00 
  40950f:	4c 89 e8             	mov    rax,r13
  409512:	48 25 ff ff 00 00    	and    rax,0xffff
  409518:	48 c1 e0 08          	shl    rax,0x8
  40951c:	49 01 c6             	add    r14,rax
  40951f:	b9 01 00 00 00       	mov    ecx,0x1
  409524:	01 c9                	add    ecx,ecx
  409526:	b8 03 00 00 00       	mov    eax,0x3
  40952b:	d3 e0                	shl    eax,cl
  40952d:	f7 d0                	not    eax
  40952f:	83 e0 fc             	and    eax,0xfffffffc
  409532:	48 31 c9             	xor    rcx,rcx
  409535:	48 31 d2             	xor    rdx,rdx
  409538:	0f 01 ef             	wrpkru 
  40953b:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40953e:	48 83 c2 01          	add    rdx,0x1
  409542:	48 c1 e2 04          	shl    rdx,0x4
  409546:	4c 01 f2             	add    rdx,r14
  409549:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  409550:	45 23 01 
  409553:	48 89 02             	mov    QWORD PTR [rdx],rax
  409556:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  40955a:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40955d:	48 83 c0 01          	add    rax,0x1
  409561:	49 89 06             	mov    QWORD PTR [r14],rax
  409564:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  409569:	01 c9                	add    ecx,ecx
  40956b:	b8 03 00 00 00       	mov    eax,0x3
  409570:	d3 e0                	shl    eax,cl
  409572:	f7 d0                	not    eax
  409574:	83 e0 fc             	and    eax,0xfffffffc
  409577:	48 31 c9             	xor    rcx,rcx
  40957a:	48 31 d2             	xor    rdx,rdx
  40957d:	0f 01 ef             	wrpkru 
  409580:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  409587:	45 23 01 
  40958a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409591:	be ad de 
  409594:	49 39 c7             	cmp    r15,rax
  409597:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  40959e:	12 12 12 
  4095a1:	48 b9 ad 95 40 00 00 	movabs rcx,0x4095ad
  4095a8:	00 00 00 
  4095ab:	ff e0                	jmp    rax

00000000004095ad <srv_call_ret_memmgr_shared_page_allocn>:
  4095ad:	49 89 c0             	mov    r8,rax
  4095b0:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4095b7:	be ad de 
  4095ba:	48 89 e2             	mov    rdx,rsp
  4095bd:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4095c4:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4095cb:	00 
  4095cc:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4095d3:	7f 00 00 
  4095d6:	4c 89 e8             	mov    rax,r13
  4095d9:	48 25 ff ff 00 00    	and    rax,0xffff
  4095df:	48 c1 e0 08          	shl    rax,0x8
  4095e3:	49 01 c6             	add    r14,rax
  4095e6:	b9 01 00 00 00       	mov    ecx,0x1
  4095eb:	01 c9                	add    ecx,ecx
  4095ed:	b8 03 00 00 00       	mov    eax,0x3
  4095f2:	d3 e0                	shl    eax,cl
  4095f4:	f7 d0                	not    eax
  4095f6:	83 e0 fc             	and    eax,0xfffffffc
  4095f9:	48 31 c9             	xor    rcx,rcx
  4095fc:	48 31 d2             	xor    rdx,rdx
  4095ff:	0f 01 ef             	wrpkru 
  409602:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  409605:	48 c1 e2 04          	shl    rdx,0x4
  409609:	4c 01 f2             	add    rdx,r14
  40960c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  409610:	49 8b 06             	mov    rax,QWORD PTR [r14]
  409613:	48 83 e8 01          	sub    rax,0x1
  409617:	49 89 06             	mov    QWORD PTR [r14],rax
  40961a:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40961f:	01 c9                	add    ecx,ecx
  409621:	b8 03 00 00 00       	mov    eax,0x3
  409626:	d3 e0                	shl    eax,cl
  409628:	f7 d0                	not    eax
  40962a:	83 e0 fc             	and    eax,0xfffffffc
  40962d:	48 31 c9             	xor    rcx,rcx
  409630:	48 31 d2             	xor    rdx,rdx
  409633:	0f 01 ef             	wrpkru 
  409636:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40963d:	be ad de 
  409640:	49 39 c7             	cmp    r15,rax
  409643:	4c 89 c0             	mov    rax,r8
  409646:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  40964a:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  40964d:	41 5f                	pop    r15
  40964f:	41 5e                	pop    r14
  409651:	41 5d                	pop    r13
  409653:	41 5c                	pop    r12
  409655:	5b                   	pop    rbx
  409656:	5d                   	pop    rbp
  409657:	c3                   	ret    
  409658:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40965f:	00 

0000000000409660 <__cosrt_extern_memmgr_shared_page_allocn_aligned>:
  409660:	48 b8 6c c3 45 00 00 	movabs rax,0x45c36c
  409667:	00 00 00 
  40966a:	ff 10                	call   QWORD PTR [rax]
  40966c:	c3                   	ret    
  40966d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000409670 <__cosrt_fast_callgate_memmgr_shared_page_allocn_aligned>:
  409670:	55                   	push   rbp
  409671:	53                   	push   rbx
  409672:	41 54                	push   r12
  409674:	41 55                	push   r13
  409676:	41 56                	push   r14
  409678:	41 57                	push   r15
  40967a:	4d 89 c4             	mov    r12,r8
  40967d:	4c 89 cb             	mov    rbx,r9
  409680:	49 89 c8             	mov    r8,rcx
  409683:	49 89 d1             	mov    r9,rdx
  409686:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40968d:	be ad de 
  409690:	0f 01 f9             	rdtscp 
  409693:	48 89 ca             	mov    rdx,rcx
  409696:	48 25 ff 0f 00 00    	and    rax,0xfff
  40969c:	48 89 e2             	mov    rdx,rsp
  40969f:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4096a6:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4096ad:	00 
  4096ae:	48 c1 e0 10          	shl    rax,0x10
  4096b2:	49 09 c5             	or     r13,rax
  4096b5:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4096bc:	7f 00 00 
  4096bf:	4c 89 e8             	mov    rax,r13
  4096c2:	48 25 ff ff 00 00    	and    rax,0xffff
  4096c8:	48 c1 e0 08          	shl    rax,0x8
  4096cc:	49 01 c6             	add    r14,rax
  4096cf:	b9 01 00 00 00       	mov    ecx,0x1
  4096d4:	01 c9                	add    ecx,ecx
  4096d6:	b8 03 00 00 00       	mov    eax,0x3
  4096db:	d3 e0                	shl    eax,cl
  4096dd:	f7 d0                	not    eax
  4096df:	83 e0 fc             	and    eax,0xfffffffc
  4096e2:	48 31 c9             	xor    rcx,rcx
  4096e5:	48 31 d2             	xor    rdx,rdx
  4096e8:	0f 01 ef             	wrpkru 
  4096eb:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4096ee:	48 83 c2 01          	add    rdx,0x1
  4096f2:	48 c1 e2 04          	shl    rdx,0x4
  4096f6:	4c 01 f2             	add    rdx,r14
  4096f9:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  409700:	45 23 01 
  409703:	48 89 02             	mov    QWORD PTR [rdx],rax
  409706:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  40970a:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40970d:	48 83 c0 01          	add    rax,0x1
  409711:	49 89 06             	mov    QWORD PTR [r14],rax
  409714:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  409719:	01 c9                	add    ecx,ecx
  40971b:	b8 03 00 00 00       	mov    eax,0x3
  409720:	d3 e0                	shl    eax,cl
  409722:	f7 d0                	not    eax
  409724:	83 e0 fc             	and    eax,0xfffffffc
  409727:	48 31 c9             	xor    rcx,rcx
  40972a:	48 31 d2             	xor    rdx,rdx
  40972d:	0f 01 ef             	wrpkru 
  409730:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  409737:	45 23 01 
  40973a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409741:	be ad de 
  409744:	49 39 c7             	cmp    r15,rax
  409747:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  40974e:	12 12 12 
  409751:	48 b9 5d 97 40 00 00 	movabs rcx,0x40975d
  409758:	00 00 00 
  40975b:	ff e0                	jmp    rax

000000000040975d <srv_call_ret_memmgr_shared_page_allocn_aligned>:
  40975d:	49 89 c0             	mov    r8,rax
  409760:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  409767:	be ad de 
  40976a:	48 89 e2             	mov    rdx,rsp
  40976d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  409774:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40977b:	00 
  40977c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  409783:	7f 00 00 
  409786:	4c 89 e8             	mov    rax,r13
  409789:	48 25 ff ff 00 00    	and    rax,0xffff
  40978f:	48 c1 e0 08          	shl    rax,0x8
  409793:	49 01 c6             	add    r14,rax
  409796:	b9 01 00 00 00       	mov    ecx,0x1
  40979b:	01 c9                	add    ecx,ecx
  40979d:	b8 03 00 00 00       	mov    eax,0x3
  4097a2:	d3 e0                	shl    eax,cl
  4097a4:	f7 d0                	not    eax
  4097a6:	83 e0 fc             	and    eax,0xfffffffc
  4097a9:	48 31 c9             	xor    rcx,rcx
  4097ac:	48 31 d2             	xor    rdx,rdx
  4097af:	0f 01 ef             	wrpkru 
  4097b2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4097b5:	48 c1 e2 04          	shl    rdx,0x4
  4097b9:	4c 01 f2             	add    rdx,r14
  4097bc:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  4097c0:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4097c3:	48 83 e8 01          	sub    rax,0x1
  4097c7:	49 89 06             	mov    QWORD PTR [r14],rax
  4097ca:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4097cf:	01 c9                	add    ecx,ecx
  4097d1:	b8 03 00 00 00       	mov    eax,0x3
  4097d6:	d3 e0                	shl    eax,cl
  4097d8:	f7 d0                	not    eax
  4097da:	83 e0 fc             	and    eax,0xfffffffc
  4097dd:	48 31 c9             	xor    rcx,rcx
  4097e0:	48 31 d2             	xor    rdx,rdx
  4097e3:	0f 01 ef             	wrpkru 
  4097e6:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4097ed:	be ad de 
  4097f0:	49 39 c7             	cmp    r15,rax
  4097f3:	4c 89 c0             	mov    rax,r8
  4097f6:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  4097fa:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  4097fd:	41 5f                	pop    r15
  4097ff:	41 5e                	pop    r14
  409801:	41 5d                	pop    r13
  409803:	41 5c                	pop    r12
  409805:	5b                   	pop    rbx
  409806:	5d                   	pop    rbp
  409807:	c3                   	ret    
  409808:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40980f:	00 

0000000000409810 <__cosrt_extern_memmgr_shared_page_map>:
  409810:	48 b8 84 c3 45 00 00 	movabs rax,0x45c384
  409817:	00 00 00 
  40981a:	ff 10                	call   QWORD PTR [rax]
  40981c:	c3                   	ret    
  40981d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000409820 <__cosrt_fast_callgate_memmgr_shared_page_map>:
  409820:	55                   	push   rbp
  409821:	53                   	push   rbx
  409822:	41 54                	push   r12
  409824:	41 55                	push   r13
  409826:	41 56                	push   r14
  409828:	41 57                	push   r15
  40982a:	4d 89 c4             	mov    r12,r8
  40982d:	4c 89 cb             	mov    rbx,r9
  409830:	49 89 c8             	mov    r8,rcx
  409833:	49 89 d1             	mov    r9,rdx
  409836:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40983d:	be ad de 
  409840:	0f 01 f9             	rdtscp 
  409843:	48 89 ca             	mov    rdx,rcx
  409846:	48 25 ff 0f 00 00    	and    rax,0xfff
  40984c:	48 89 e2             	mov    rdx,rsp
  40984f:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  409856:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40985d:	00 
  40985e:	48 c1 e0 10          	shl    rax,0x10
  409862:	49 09 c5             	or     r13,rax
  409865:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40986c:	7f 00 00 
  40986f:	4c 89 e8             	mov    rax,r13
  409872:	48 25 ff ff 00 00    	and    rax,0xffff
  409878:	48 c1 e0 08          	shl    rax,0x8
  40987c:	49 01 c6             	add    r14,rax
  40987f:	b9 01 00 00 00       	mov    ecx,0x1
  409884:	01 c9                	add    ecx,ecx
  409886:	b8 03 00 00 00       	mov    eax,0x3
  40988b:	d3 e0                	shl    eax,cl
  40988d:	f7 d0                	not    eax
  40988f:	83 e0 fc             	and    eax,0xfffffffc
  409892:	48 31 c9             	xor    rcx,rcx
  409895:	48 31 d2             	xor    rdx,rdx
  409898:	0f 01 ef             	wrpkru 
  40989b:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40989e:	48 83 c2 01          	add    rdx,0x1
  4098a2:	48 c1 e2 04          	shl    rdx,0x4
  4098a6:	4c 01 f2             	add    rdx,r14
  4098a9:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  4098b0:	45 23 01 
  4098b3:	48 89 02             	mov    QWORD PTR [rdx],rax
  4098b6:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  4098ba:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4098bd:	48 83 c0 01          	add    rax,0x1
  4098c1:	49 89 06             	mov    QWORD PTR [r14],rax
  4098c4:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4098c9:	01 c9                	add    ecx,ecx
  4098cb:	b8 03 00 00 00       	mov    eax,0x3
  4098d0:	d3 e0                	shl    eax,cl
  4098d2:	f7 d0                	not    eax
  4098d4:	83 e0 fc             	and    eax,0xfffffffc
  4098d7:	48 31 c9             	xor    rcx,rcx
  4098da:	48 31 d2             	xor    rdx,rdx
  4098dd:	0f 01 ef             	wrpkru 
  4098e0:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  4098e7:	45 23 01 
  4098ea:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4098f1:	be ad de 
  4098f4:	49 39 c7             	cmp    r15,rax
  4098f7:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  4098fe:	12 12 12 
  409901:	48 b9 0d 99 40 00 00 	movabs rcx,0x40990d
  409908:	00 00 00 
  40990b:	ff e0                	jmp    rax

000000000040990d <srv_call_ret_memmgr_shared_page_map>:
  40990d:	49 89 c0             	mov    r8,rax
  409910:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  409917:	be ad de 
  40991a:	48 89 e2             	mov    rdx,rsp
  40991d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  409924:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40992b:	00 
  40992c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  409933:	7f 00 00 
  409936:	4c 89 e8             	mov    rax,r13
  409939:	48 25 ff ff 00 00    	and    rax,0xffff
  40993f:	48 c1 e0 08          	shl    rax,0x8
  409943:	49 01 c6             	add    r14,rax
  409946:	b9 01 00 00 00       	mov    ecx,0x1
  40994b:	01 c9                	add    ecx,ecx
  40994d:	b8 03 00 00 00       	mov    eax,0x3
  409952:	d3 e0                	shl    eax,cl
  409954:	f7 d0                	not    eax
  409956:	83 e0 fc             	and    eax,0xfffffffc
  409959:	48 31 c9             	xor    rcx,rcx
  40995c:	48 31 d2             	xor    rdx,rdx
  40995f:	0f 01 ef             	wrpkru 
  409962:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  409965:	48 c1 e2 04          	shl    rdx,0x4
  409969:	4c 01 f2             	add    rdx,r14
  40996c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  409970:	49 8b 06             	mov    rax,QWORD PTR [r14]
  409973:	48 83 e8 01          	sub    rax,0x1
  409977:	49 89 06             	mov    QWORD PTR [r14],rax
  40997a:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40997f:	01 c9                	add    ecx,ecx
  409981:	b8 03 00 00 00       	mov    eax,0x3
  409986:	d3 e0                	shl    eax,cl
  409988:	f7 d0                	not    eax
  40998a:	83 e0 fc             	and    eax,0xfffffffc
  40998d:	48 31 c9             	xor    rcx,rcx
  409990:	48 31 d2             	xor    rdx,rdx
  409993:	0f 01 ef             	wrpkru 
  409996:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40999d:	be ad de 
  4099a0:	49 39 c7             	cmp    r15,rax
  4099a3:	4c 89 c0             	mov    rax,r8
  4099a6:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  4099aa:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  4099ad:	41 5f                	pop    r15
  4099af:	41 5e                	pop    r14
  4099b1:	41 5d                	pop    r13
  4099b3:	41 5c                	pop    r12
  4099b5:	5b                   	pop    rbx
  4099b6:	5d                   	pop    rbp
  4099b7:	c3                   	ret    
  4099b8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4099bf:	00 

00000000004099c0 <__cosrt_extern_memmgr_shared_page_map_aligned>:
  4099c0:	48 b8 9c c3 45 00 00 	movabs rax,0x45c39c
  4099c7:	00 00 00 
  4099ca:	ff 10                	call   QWORD PTR [rax]
  4099cc:	c3                   	ret    
  4099cd:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004099d0 <__cosrt_fast_callgate_memmgr_shared_page_map_aligned>:
  4099d0:	55                   	push   rbp
  4099d1:	53                   	push   rbx
  4099d2:	41 54                	push   r12
  4099d4:	41 55                	push   r13
  4099d6:	41 56                	push   r14
  4099d8:	41 57                	push   r15
  4099da:	4d 89 c4             	mov    r12,r8
  4099dd:	4c 89 cb             	mov    rbx,r9
  4099e0:	49 89 c8             	mov    r8,rcx
  4099e3:	49 89 d1             	mov    r9,rdx
  4099e6:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4099ed:	be ad de 
  4099f0:	0f 01 f9             	rdtscp 
  4099f3:	48 89 ca             	mov    rdx,rcx
  4099f6:	48 25 ff 0f 00 00    	and    rax,0xfff
  4099fc:	48 89 e2             	mov    rdx,rsp
  4099ff:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  409a06:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  409a0d:	00 
  409a0e:	48 c1 e0 10          	shl    rax,0x10
  409a12:	49 09 c5             	or     r13,rax
  409a15:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  409a1c:	7f 00 00 
  409a1f:	4c 89 e8             	mov    rax,r13
  409a22:	48 25 ff ff 00 00    	and    rax,0xffff
  409a28:	48 c1 e0 08          	shl    rax,0x8
  409a2c:	49 01 c6             	add    r14,rax
  409a2f:	b9 01 00 00 00       	mov    ecx,0x1
  409a34:	01 c9                	add    ecx,ecx
  409a36:	b8 03 00 00 00       	mov    eax,0x3
  409a3b:	d3 e0                	shl    eax,cl
  409a3d:	f7 d0                	not    eax
  409a3f:	83 e0 fc             	and    eax,0xfffffffc
  409a42:	48 31 c9             	xor    rcx,rcx
  409a45:	48 31 d2             	xor    rdx,rdx
  409a48:	0f 01 ef             	wrpkru 
  409a4b:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  409a4e:	48 83 c2 01          	add    rdx,0x1
  409a52:	48 c1 e2 04          	shl    rdx,0x4
  409a56:	4c 01 f2             	add    rdx,r14
  409a59:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  409a60:	45 23 01 
  409a63:	48 89 02             	mov    QWORD PTR [rdx],rax
  409a66:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  409a6a:	49 8b 06             	mov    rax,QWORD PTR [r14]
  409a6d:	48 83 c0 01          	add    rax,0x1
  409a71:	49 89 06             	mov    QWORD PTR [r14],rax
  409a74:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  409a79:	01 c9                	add    ecx,ecx
  409a7b:	b8 03 00 00 00       	mov    eax,0x3
  409a80:	d3 e0                	shl    eax,cl
  409a82:	f7 d0                	not    eax
  409a84:	83 e0 fc             	and    eax,0xfffffffc
  409a87:	48 31 c9             	xor    rcx,rcx
  409a8a:	48 31 d2             	xor    rdx,rdx
  409a8d:	0f 01 ef             	wrpkru 
  409a90:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  409a97:	45 23 01 
  409a9a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409aa1:	be ad de 
  409aa4:	49 39 c7             	cmp    r15,rax
  409aa7:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  409aae:	12 12 12 
  409ab1:	48 b9 bd 9a 40 00 00 	movabs rcx,0x409abd
  409ab8:	00 00 00 
  409abb:	ff e0                	jmp    rax

0000000000409abd <srv_call_ret_memmgr_shared_page_map_aligned>:
  409abd:	49 89 c0             	mov    r8,rax
  409ac0:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  409ac7:	be ad de 
  409aca:	48 89 e2             	mov    rdx,rsp
  409acd:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  409ad4:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  409adb:	00 
  409adc:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  409ae3:	7f 00 00 
  409ae6:	4c 89 e8             	mov    rax,r13
  409ae9:	48 25 ff ff 00 00    	and    rax,0xffff
  409aef:	48 c1 e0 08          	shl    rax,0x8
  409af3:	49 01 c6             	add    r14,rax
  409af6:	b9 01 00 00 00       	mov    ecx,0x1
  409afb:	01 c9                	add    ecx,ecx
  409afd:	b8 03 00 00 00       	mov    eax,0x3
  409b02:	d3 e0                	shl    eax,cl
  409b04:	f7 d0                	not    eax
  409b06:	83 e0 fc             	and    eax,0xfffffffc
  409b09:	48 31 c9             	xor    rcx,rcx
  409b0c:	48 31 d2             	xor    rdx,rdx
  409b0f:	0f 01 ef             	wrpkru 
  409b12:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  409b15:	48 c1 e2 04          	shl    rdx,0x4
  409b19:	4c 01 f2             	add    rdx,r14
  409b1c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  409b20:	49 8b 06             	mov    rax,QWORD PTR [r14]
  409b23:	48 83 e8 01          	sub    rax,0x1
  409b27:	49 89 06             	mov    QWORD PTR [r14],rax
  409b2a:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  409b2f:	01 c9                	add    ecx,ecx
  409b31:	b8 03 00 00 00       	mov    eax,0x3
  409b36:	d3 e0                	shl    eax,cl
  409b38:	f7 d0                	not    eax
  409b3a:	83 e0 fc             	and    eax,0xfffffffc
  409b3d:	48 31 c9             	xor    rcx,rcx
  409b40:	48 31 d2             	xor    rdx,rdx
  409b43:	0f 01 ef             	wrpkru 
  409b46:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409b4d:	be ad de 
  409b50:	49 39 c7             	cmp    r15,rax
  409b53:	4c 89 c0             	mov    rax,r8
  409b56:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  409b5a:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  409b5d:	41 5f                	pop    r15
  409b5f:	41 5e                	pop    r14
  409b61:	41 5d                	pop    r13
  409b63:	41 5c                	pop    r12
  409b65:	5b                   	pop    rbx
  409b66:	5d                   	pop    rbp
  409b67:	c3                   	ret    
  409b68:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  409b6f:	00 

0000000000409b70 <__cosrt_extern_memmgr_shared_page_map_aligned_in_vm>:
  409b70:	48 b8 b4 c3 45 00 00 	movabs rax,0x45c3b4
  409b77:	00 00 00 
  409b7a:	ff 10                	call   QWORD PTR [rax]
  409b7c:	c3                   	ret    
  409b7d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000409b80 <__cosrt_fast_callgate_memmgr_shared_page_map_aligned_in_vm>:
  409b80:	55                   	push   rbp
  409b81:	53                   	push   rbx
  409b82:	41 54                	push   r12
  409b84:	41 55                	push   r13
  409b86:	41 56                	push   r14
  409b88:	41 57                	push   r15
  409b8a:	4d 89 c4             	mov    r12,r8
  409b8d:	4c 89 cb             	mov    rbx,r9
  409b90:	49 89 c8             	mov    r8,rcx
  409b93:	49 89 d1             	mov    r9,rdx
  409b96:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  409b9d:	be ad de 
  409ba0:	0f 01 f9             	rdtscp 
  409ba3:	48 89 ca             	mov    rdx,rcx
  409ba6:	48 25 ff 0f 00 00    	and    rax,0xfff
  409bac:	48 89 e2             	mov    rdx,rsp
  409baf:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  409bb6:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  409bbd:	00 
  409bbe:	48 c1 e0 10          	shl    rax,0x10
  409bc2:	49 09 c5             	or     r13,rax
  409bc5:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  409bcc:	7f 00 00 
  409bcf:	4c 89 e8             	mov    rax,r13
  409bd2:	48 25 ff ff 00 00    	and    rax,0xffff
  409bd8:	48 c1 e0 08          	shl    rax,0x8
  409bdc:	49 01 c6             	add    r14,rax
  409bdf:	b9 01 00 00 00       	mov    ecx,0x1
  409be4:	01 c9                	add    ecx,ecx
  409be6:	b8 03 00 00 00       	mov    eax,0x3
  409beb:	d3 e0                	shl    eax,cl
  409bed:	f7 d0                	not    eax
  409bef:	83 e0 fc             	and    eax,0xfffffffc
  409bf2:	48 31 c9             	xor    rcx,rcx
  409bf5:	48 31 d2             	xor    rdx,rdx
  409bf8:	0f 01 ef             	wrpkru 
  409bfb:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  409bfe:	48 83 c2 01          	add    rdx,0x1
  409c02:	48 c1 e2 04          	shl    rdx,0x4
  409c06:	4c 01 f2             	add    rdx,r14
  409c09:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  409c10:	45 23 01 
  409c13:	48 89 02             	mov    QWORD PTR [rdx],rax
  409c16:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  409c1a:	49 8b 06             	mov    rax,QWORD PTR [r14]
  409c1d:	48 83 c0 01          	add    rax,0x1
  409c21:	49 89 06             	mov    QWORD PTR [r14],rax
  409c24:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  409c29:	01 c9                	add    ecx,ecx
  409c2b:	b8 03 00 00 00       	mov    eax,0x3
  409c30:	d3 e0                	shl    eax,cl
  409c32:	f7 d0                	not    eax
  409c34:	83 e0 fc             	and    eax,0xfffffffc
  409c37:	48 31 c9             	xor    rcx,rcx
  409c3a:	48 31 d2             	xor    rdx,rdx
  409c3d:	0f 01 ef             	wrpkru 
  409c40:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  409c47:	45 23 01 
  409c4a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409c51:	be ad de 
  409c54:	49 39 c7             	cmp    r15,rax
  409c57:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  409c5e:	12 12 12 
  409c61:	48 b9 6d 9c 40 00 00 	movabs rcx,0x409c6d
  409c68:	00 00 00 
  409c6b:	ff e0                	jmp    rax

0000000000409c6d <srv_call_ret_memmgr_shared_page_map_aligned_in_vm>:
  409c6d:	49 89 c0             	mov    r8,rax
  409c70:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  409c77:	be ad de 
  409c7a:	48 89 e2             	mov    rdx,rsp
  409c7d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  409c84:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  409c8b:	00 
  409c8c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  409c93:	7f 00 00 
  409c96:	4c 89 e8             	mov    rax,r13
  409c99:	48 25 ff ff 00 00    	and    rax,0xffff
  409c9f:	48 c1 e0 08          	shl    rax,0x8
  409ca3:	49 01 c6             	add    r14,rax
  409ca6:	b9 01 00 00 00       	mov    ecx,0x1
  409cab:	01 c9                	add    ecx,ecx
  409cad:	b8 03 00 00 00       	mov    eax,0x3
  409cb2:	d3 e0                	shl    eax,cl
  409cb4:	f7 d0                	not    eax
  409cb6:	83 e0 fc             	and    eax,0xfffffffc
  409cb9:	48 31 c9             	xor    rcx,rcx
  409cbc:	48 31 d2             	xor    rdx,rdx
  409cbf:	0f 01 ef             	wrpkru 
  409cc2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  409cc5:	48 c1 e2 04          	shl    rdx,0x4
  409cc9:	4c 01 f2             	add    rdx,r14
  409ccc:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  409cd0:	49 8b 06             	mov    rax,QWORD PTR [r14]
  409cd3:	48 83 e8 01          	sub    rax,0x1
  409cd7:	49 89 06             	mov    QWORD PTR [r14],rax
  409cda:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  409cdf:	01 c9                	add    ecx,ecx
  409ce1:	b8 03 00 00 00       	mov    eax,0x3
  409ce6:	d3 e0                	shl    eax,cl
  409ce8:	f7 d0                	not    eax
  409cea:	83 e0 fc             	and    eax,0xfffffffc
  409ced:	48 31 c9             	xor    rcx,rcx
  409cf0:	48 31 d2             	xor    rdx,rdx
  409cf3:	0f 01 ef             	wrpkru 
  409cf6:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409cfd:	be ad de 
  409d00:	49 39 c7             	cmp    r15,rax
  409d03:	4c 89 c0             	mov    rax,r8
  409d06:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  409d0a:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  409d0d:	41 5f                	pop    r15
  409d0f:	41 5e                	pop    r14
  409d11:	41 5d                	pop    r13
  409d13:	41 5c                	pop    r12
  409d15:	5b                   	pop    rbx
  409d16:	5d                   	pop    rbp
  409d17:	c3                   	ret    
  409d18:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  409d1f:	00 

0000000000409d20 <init_parallelism>:
 * functions) are found in the c files in this directory. They
 * generate a .a static library that is linked on-demand.
 */
int
init_parallelism(void)
{
  409d20:	f3 0f 1e fa          	endbr64 
	return NUM_CPU;
}
  409d24:	b8 01 00 00 00       	mov    eax,0x1
  409d29:	c3                   	ret    
  409d2a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000409d30 <cos_aepthd_fn>:
	struct cos_aep_info sched_aep[NUM_CPU];
};

static void
cos_aepthd_fn(void *data)
{
  409d30:	f3 0f 1e fa          	endbr64 
  409d34:	55                   	push   rbp
  409d35:	48 89 f8             	mov    rax,rdi
	struct cos_aep_info *aep_info = (struct cos_aep_info *)data;
	cos_aepthd_fn_t      aep_fn   = aep_info->fn;
	void *               fn_data  = aep_info->data;

	(aep_fn)(aep_info->rcv, fn_data);
  409d38:	48 8b 77 28          	mov    rsi,QWORD PTR [rdi+0x28]
  409d3c:	48 8b 7f 18          	mov    rdi,QWORD PTR [rdi+0x18]
{
  409d40:	48 89 e5             	mov    rbp,rsp
	(aep_fn)(aep_info->rcv, fn_data);
  409d43:	ff 50 20             	call   QWORD PTR [rax+0x20]
  409d46:	be 69 00 00 00       	mov    esi,0x69
  409d4b:	bf d0 be 41 00       	mov    edi,0x41bed0
  409d50:	e8 7b 03 00 00       	call   40a0d0 <cos_print_str>

	/* TODO: handling destruction */
	assert(0);
  409d55:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  409d5c:	00 00 00 00 
  409d60:	0f 0b                	ud2    
  409d62:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  409d69:	00 00 00 00 
  409d6d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000409d70 <capmgr_thd_create>:
#include <capmgr.h>
#include <cos_thd_init.h>

thdcap_t
capmgr_thd_create(cos_thd_fn_t fn, void *data, thdid_t *tid)
{
  409d70:	f3 0f 1e fa          	endbr64 

/* See comments of cos_thd_create_remote. */
static thdclosure_index_t
cos_thd_init_alloc(void *fn, void *data)
{
	if (!fn) return -1;
  409d74:	48 85 ff             	test   rdi,rdi
  409d77:	0f 84 95 00 00 00    	je     409e12 <capmgr_thd_create+0xa2>
  409d7d:	49 89 f1             	mov    r9,rsi
  409d80:	49 89 f8             	mov    r8,rdi
  409d83:	48 89 d6             	mov    rsi,rdx
  409d86:	41 ba 02 00 00 00    	mov    r10d,0x2
static inline int
cos_cas(unsigned long *target, unsigned long old, unsigned long updated)
{
	char z;
	#if defined(__x86_64__)
	__asm__ __volatile__("lock cmpxchgq %2, %0; setz %1"
  409d8c:	31 d2                	xor    edx,edx
	for (i = 0; i < COS_THD_INIT_REGION_SIZE; i++) {
  409d8e:	b9 00 f9 59 00       	mov    ecx,0x59f900
  409d93:	31 ff                	xor    edi,edi
		if (__thd_init_data[i].fn == NULL) {
  409d95:	48 83 39 00          	cmp    QWORD PTR [rcx],0x0
  409d99:	74 25                	je     409dc0 <capmgr_thd_create+0x50>
	for (i = 0; i < COS_THD_INIT_REGION_SIZE; i++) {
  409d9b:	83 c7 01             	add    edi,0x1
  409d9e:	48 83 c1 10          	add    rcx,0x10
  409da2:	81 ff 00 01 00 00    	cmp    edi,0x100
  409da8:	75 eb                	jne    409d95 <capmgr_thd_create+0x25>
	if (!tried) {
  409daa:	41 83 fa 01          	cmp    r10d,0x1
  409dae:	74 62                	je     409e12 <capmgr_thd_create+0xa2>
  409db0:	41 ba 01 00 00 00    	mov    r10d,0x1
  409db6:	eb d6                	jmp    409d8e <capmgr_thd_create+0x1e>
  409db8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  409dbf:	00 
  409dc0:	48 89 d0             	mov    rax,rdx
  409dc3:	f0 4c 0f b1 01       	lock cmpxchg QWORD PTR [rcx],r8
  409dc8:	0f 94 c0             	sete   al
			if (!ret) continue;
  409dcb:	84 c0                	test   al,al
  409dcd:	74 cc                	je     409d9b <capmgr_thd_create+0x2b>
			assert(__thd_init_data[i].fn == fn);
  409dcf:	48 63 c7             	movsxd rax,edi
  409dd2:	48 c1 e0 04          	shl    rax,0x4
  409dd6:	48 8d 90 00 f9 59 00 	lea    rdx,[rax+0x59f900]
  409ddd:	4c 3b 80 00 f9 59 00 	cmp    r8,QWORD PTR [rax+0x59f900]
  409de4:	75 0c                	jne    409df2 <capmgr_thd_create+0x82>
			__thd_init_data[i].data = data;
  409de6:	4c 89 4a 08          	mov    QWORD PTR [rdx+0x8],r9
			return i + 1;
  409dea:	83 c7 01             	add    edi,0x1
	thdclosure_index_t idx = cos_thd_init_alloc(fn, data);

	if (idx < 1) return 0;

	return capmgr_thd_create_thunk(idx, tid);
  409ded:	e9 ce cb ff ff       	jmp    4069c0 <__cosrt_extern_capmgr_thd_create_thunk>
{
  409df2:	55                   	push   rbp
  409df3:	be 67 00 00 00       	mov    esi,0x67
  409df8:	bf 40 bf 41 00       	mov    edi,0x41bf40
  409dfd:	48 89 e5             	mov    rbp,rsp
  409e00:	e8 cb 02 00 00       	call   40a0d0 <cos_print_str>
			assert(__thd_init_data[i].fn == fn);
  409e05:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  409e0c:	00 00 00 00 
  409e10:	0f 0b                	ud2    
}
  409e12:	31 c0                	xor    eax,eax
  409e14:	c3                   	ret    
  409e15:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  409e1c:	00 00 00 00 

0000000000409e20 <capmgr_rcv_alloc>:

arcvcap_t
capmgr_rcv_alloc(cos_thd_fn_t fn, void *data, int flags, asndcap_t *asnd, thdcap_t *thdcap, thdid_t *tid)
{
  409e20:	f3 0f 1e fa          	endbr64 
	if (!fn) return -1;
  409e24:	48 85 ff             	test   rdi,rdi
  409e27:	0f 84 af 00 00 00    	je     409edc <capmgr_rcv_alloc+0xbc>
  409e2d:	55                   	push   rbp
  409e2e:	49 89 cb             	mov    r11,rcx
  409e31:	49 89 fa             	mov    r10,rdi
  409e34:	4c 89 c1             	mov    rcx,r8
  409e37:	4d 89 c8             	mov    r8,r9
  409e3a:	41 b9 02 00 00 00    	mov    r9d,0x2
  409e40:	48 89 e5             	mov    rbp,rsp
  409e43:	41 54                	push   r12
  409e45:	45 31 e4             	xor    r12d,r12d
  409e48:	53                   	push   rbx
  409e49:	48 89 f3             	mov    rbx,rsi
  409e4c:	89 d6                	mov    esi,edx
	for (i = 0; i < COS_THD_INIT_REGION_SIZE; i++) {
  409e4e:	ba 00 f9 59 00       	mov    edx,0x59f900
  409e53:	31 ff                	xor    edi,edi
		if (__thd_init_data[i].fn == NULL) {
  409e55:	48 83 3a 00          	cmp    QWORD PTR [rdx],0x0
  409e59:	74 25                	je     409e80 <capmgr_rcv_alloc+0x60>
	for (i = 0; i < COS_THD_INIT_REGION_SIZE; i++) {
  409e5b:	83 c7 01             	add    edi,0x1
  409e5e:	48 83 c2 10          	add    rdx,0x10
  409e62:	81 ff 00 01 00 00    	cmp    edi,0x100
  409e68:	75 eb                	jne    409e55 <capmgr_rcv_alloc+0x35>
	if (!tried) {
  409e6a:	41 83 f9 01          	cmp    r9d,0x1
  409e6e:	74 65                	je     409ed5 <capmgr_rcv_alloc+0xb5>
  409e70:	41 b9 01 00 00 00    	mov    r9d,0x1
  409e76:	eb d6                	jmp    409e4e <capmgr_rcv_alloc+0x2e>
  409e78:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  409e7f:	00 
  409e80:	4c 89 e0             	mov    rax,r12
  409e83:	f0 4c 0f b1 12       	lock cmpxchg QWORD PTR [rdx],r10
  409e88:	0f 94 c0             	sete   al
			if (!ret) continue;
  409e8b:	84 c0                	test   al,al
  409e8d:	74 cc                	je     409e5b <capmgr_rcv_alloc+0x3b>
			assert(__thd_init_data[i].fn == fn);
  409e8f:	48 63 c7             	movsxd rax,edi
  409e92:	48 c1 e0 04          	shl    rax,0x4
  409e96:	48 8d 90 00 f9 59 00 	lea    rdx,[rax+0x59f900]
  409e9d:	4c 3b 90 00 f9 59 00 	cmp    r10,QWORD PTR [rax+0x59f900]
  409ea4:	75 13                	jne    409eb9 <capmgr_rcv_alloc+0x99>
			__thd_init_data[i].data = data;
  409ea6:	48 89 5a 08          	mov    QWORD PTR [rdx+0x8],rbx
			return i + 1;
  409eaa:	83 c7 01             	add    edi,0x1
	thdclosure_index_t idx = cos_thd_init_alloc(fn, data);

	if (idx < 1) return 0;

	return capmgr_rcv_create(idx, flags, asnd, thdcap, tid);
}
  409ead:	5b                   	pop    rbx
	return capmgr_rcv_create(idx, flags, asnd, thdcap, tid);
  409eae:	4c 89 da             	mov    rdx,r11
}
  409eb1:	41 5c                	pop    r12
  409eb3:	5d                   	pop    rbp
	return capmgr_rcv_create(idx, flags, asnd, thdcap, tid);
  409eb4:	e9 77 d3 ff ff       	jmp    407230 <__cosrt_extern_capmgr_rcv_create>
  409eb9:	be 67 00 00 00       	mov    esi,0x67
  409ebe:	bf 40 bf 41 00       	mov    edi,0x41bf40
  409ec3:	e8 08 02 00 00       	call   40a0d0 <cos_print_str>
			assert(__thd_init_data[i].fn == fn);
  409ec8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  409ecf:	00 00 00 00 
  409ed3:	0f 0b                	ud2    
}
  409ed5:	5b                   	pop    rbx
  409ed6:	31 c0                	xor    eax,eax
  409ed8:	41 5c                	pop    r12
  409eda:	5d                   	pop    rbp
  409edb:	c3                   	ret    
  409edc:	31 c0                	xor    eax,eax
  409ede:	c3                   	ret    
  409edf:	90                   	nop

0000000000409ee0 <capmgr_aep_create>:

thdcap_t
capmgr_aep_create(struct cos_aep_info *a, cos_aepthd_fn_t fn, void *data, int owntc, cos_channelkey_t key, microsec_t ipiwin, u32_t ipimax)
{
  409ee0:	f3 0f 1e fa          	endbr64 
  409ee4:	55                   	push   rbp
  409ee5:	41 89 ca             	mov    r10d,ecx
  409ee8:	44 89 c1             	mov    ecx,r8d
  409eeb:	4d 89 c8             	mov    r8,r9
  409eee:	49 89 f3             	mov    r11,rsi
  409ef1:	48 89 e5             	mov    rbp,rsp
  409ef4:	41 56                	push   r14
again:
  409ef6:	41 be 02 00 00 00    	mov    r14d,0x2
  409efc:	44 8b 4d 10          	mov    r9d,DWORD PTR [rbp+0x10]
  409f00:	41 55                	push   r13
  409f02:	41 bd 30 9d 40 00    	mov    r13d,0x409d30
  409f08:	41 54                	push   r12
  409f0a:	45 31 e4             	xor    r12d,r12d
  409f0d:	53                   	push   rbx
  409f0e:	48 89 d3             	mov    rbx,rdx
	for (i = 0; i < COS_THD_INIT_REGION_SIZE; i++) {
  409f11:	ba 00 f9 59 00       	mov    edx,0x59f900
  409f16:	31 f6                	xor    esi,esi
		if (__thd_init_data[i].fn == NULL) {
  409f18:	48 83 3a 00          	cmp    QWORD PTR [rdx],0x0
  409f1c:	74 22                	je     409f40 <capmgr_aep_create+0x60>
	for (i = 0; i < COS_THD_INIT_REGION_SIZE; i++) {
  409f1e:	83 c6 01             	add    esi,0x1
  409f21:	48 83 c2 10          	add    rdx,0x10
  409f25:	81 fe 00 01 00 00    	cmp    esi,0x100
  409f2b:	75 eb                	jne    409f18 <capmgr_aep_create+0x38>
	if (!tried) {
  409f2d:	41 83 fe 01          	cmp    r14d,0x1
  409f31:	75 75                	jne    409fa8 <capmgr_aep_create+0xc8>
	if (idx < 1) return 0;
	a->fn   = fn;
	a->data = data;

	return capmgr_aep_create_thunk(a, idx, owntc, key, ipiwin, ipimax);
}
  409f33:	5b                   	pop    rbx
  409f34:	31 c0                	xor    eax,eax
  409f36:	41 5c                	pop    r12
  409f38:	41 5d                	pop    r13
  409f3a:	41 5e                	pop    r14
  409f3c:	5d                   	pop    rbp
  409f3d:	c3                   	ret    
  409f3e:	66 90                	xchg   ax,ax
  409f40:	4c 89 e0             	mov    rax,r12
  409f43:	f0 4c 0f b1 2a       	lock cmpxchg QWORD PTR [rdx],r13
  409f48:	0f 94 c0             	sete   al
			if (!ret) continue;
  409f4b:	84 c0                	test   al,al
  409f4d:	74 cf                	je     409f1e <capmgr_aep_create+0x3e>
			assert(__thd_init_data[i].fn == fn);
  409f4f:	48 63 c6             	movsxd rax,esi
  409f52:	48 c1 e0 04          	shl    rax,0x4
  409f56:	48 8d 90 00 f9 59 00 	lea    rdx,[rax+0x59f900]
  409f5d:	48 81 b8 00 f9 59 00 	cmp    QWORD PTR [rax+0x59f900],0x409d30
  409f64:	30 9d 40 00 
  409f68:	75 22                	jne    409f8c <capmgr_aep_create+0xac>
			__thd_init_data[i].data = data;
  409f6a:	48 89 7a 08          	mov    QWORD PTR [rdx+0x8],rdi
	return capmgr_aep_create_thunk(a, idx, owntc, key, ipiwin, ipimax);
  409f6e:	0f b7 c9             	movzx  ecx,cx
			return i + 1;
  409f71:	83 c6 01             	add    esi,0x1
  409f74:	44 89 d2             	mov    edx,r10d
	a->fn   = fn;
  409f77:	4c 89 5f 20          	mov    QWORD PTR [rdi+0x20],r11
	a->data = data;
  409f7b:	48 89 5f 28          	mov    QWORD PTR [rdi+0x28],rbx
}
  409f7f:	5b                   	pop    rbx
  409f80:	41 5c                	pop    r12
  409f82:	41 5d                	pop    r13
  409f84:	41 5e                	pop    r14
  409f86:	5d                   	pop    rbp
	return capmgr_aep_create_thunk(a, idx, owntc, key, ipiwin, ipimax);
  409f87:	e9 44 cf ff ff       	jmp    406ed0 <__cosrt_extern_capmgr_aep_create_thunk>
  409f8c:	be 67 00 00 00       	mov    esi,0x67
  409f91:	bf 40 bf 41 00       	mov    edi,0x41bf40
  409f96:	e8 35 01 00 00       	call   40a0d0 <cos_print_str>
			assert(__thd_init_data[i].fn == fn);
  409f9b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  409fa2:	00 00 00 00 
  409fa6:	0f 0b                	ud2    
  409fa8:	41 be 01 00 00 00    	mov    r14d,0x1
  409fae:	e9 5e ff ff ff       	jmp    409f11 <capmgr_aep_create+0x31>
  409fb3:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  409fba:	00 00 00 
  409fbd:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000409fc0 <main>:
 * __crt_main is just used to identify if the user has defined their
 * own main (thus overriding the weak place-holder below)
 */
static int
__crt_main(void)
{
  409fc0:	f3 0f 1e fa          	endbr64 
	return 0;
}
  409fc4:	31 c0                	xor    eax,eax
  409fc6:	c3                   	ret    
  409fc7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  409fce:	00 00 

0000000000409fd0 <__crt_parallel_main>:
	return;
}

static void
__crt_parallel_main(coreid_t cid, int init_core, int ncores)
{
  409fd0:	f3 0f 1e fa          	endbr64 
	return;
}
  409fd4:	c3                   	ret    
  409fd5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  409fdc:	00 00 00 00 

0000000000409fe0 <__crt_cos_parallel_init>:
  409fe0:	f3 0f 1e fa          	endbr64 
  409fe4:	c3                   	ret    
  409fe5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  409fec:	00 00 00 00 
{
  409ff0:	f3 0f 1e fa          	endbr64 
}
  409ff4:	c3                   	ret    
  409ff5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  409ffc:	00 00 00 00 

000000000040a000 <cos_main_defined>:
}
COS_FN_WEAKALIAS(cos_parallel_init, __crt_cos_parallel_init);

int
cos_main_defined(void)
{
  40a000:	f3 0f 1e fa          	endbr64 
	return __crt_main != main;
  40a004:	b8 c0 9f 40 00       	mov    eax,0x409fc0
  40a009:	48 3d c0 9f 40 00    	cmp    rax,0x409fc0
  40a00f:	0f 95 c0             	setne  al
  40a012:	0f b6 c0             	movzx  eax,al
}
  40a015:	c3                   	ret    
  40a016:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40a01d:	00 00 00 

000000000040a020 <pre_syscall_default_setup>:
  40a020:	f3 0f 1e fa          	endbr64 
  40a024:	c3                   	ret    
  40a025:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a02c:	00 00 00 00 

000000000040a030 <pre_syscall_setup>:
}

/* Intended to be overriden by components */
CWEAKSYMB void
pre_syscall_setup()
{
  40a030:	f3 0f 1e fa          	endbr64 
	pre_syscall_default_setup();
  40a034:	31 c0                	xor    eax,eax
  40a036:	e9 e5 ff ff ff       	jmp    40a020 <pre_syscall_default_setup>
  40a03b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000040a040 <syscall_emulation_setup>:
  40a040:	f3 0f 1e fa          	endbr64 
  40a044:	c3                   	ret    
  40a045:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a04c:	00 00 00 00 

000000000040a050 <libc_initialization_handler>:
  40a050:	f3 0f 1e fa          	endbr64 
  40a054:	c3                   	ret    
  40a055:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a05c:	00 00 00 00 

000000000040a060 <libc_posixcap_initialization_handler>:
  40a060:	f3 0f 1e fa          	endbr64 
  40a064:	c3                   	ret    
  40a065:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a06c:	00 00 00 00 

000000000040a070 <libc_posixsched_initialization_handler>:
  40a070:	f3 0f 1e fa          	endbr64 
  40a074:	c3                   	ret    
  40a075:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a07c:	00 00 00 00 

000000000040a080 <libc_tls_init>:
{
}

CWEAKSYMB void
libc_tls_init(unsigned int cpuid)
{
  40a080:	f3 0f 1e fa          	endbr64 

}
  40a084:	c3                   	ret    
  40a085:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a08c:	00 00 00 00 

000000000040a090 <libc_init>:
/* TODO: Make this a weak symbol (currently doing so makes this fail) */
void __init_libc(char **envp, char *pn);

void
libc_init()
{
  40a090:	f3 0f 1e fa          	endbr64 
                               (char *)AT_SECURE,
                               (char *)0, /* Whether the program is being run under sudo */
                               NULL
	};
	char *program_name = "composite component";
	__init_libc(envp, program_name);
  40a094:	be a8 bf 41 00       	mov    esi,0x41bfa8
  40a099:	bf 20 60 42 00       	mov    edi,0x426020
  40a09e:	e9 1d ae 00 00       	jmp    414ec0 <__init_libc>
  40a0a3:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a0aa:	00 00 00 00 
  40a0ae:	66 90                	xchg   ax,ax

000000000040a0b0 <cos_upcall_exec>:
}

CWEAKSYMB void
cos_upcall_exec(void *arg)
{
  40a0b0:	f3 0f 1e fa          	endbr64 
}
  40a0b4:	c3                   	ret    
  40a0b5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a0bc:	00 00 00 00 

000000000040a0c0 <cos_async_inv>:

CWEAKSYMB int
cos_async_inv(struct usr_inv_cap *ucap, int *params)
{
  40a0c0:	f3 0f 1e fa          	endbr64 
	return 0;
}
  40a0c4:	31 c0                	xor    eax,eax
  40a0c6:	c3                   	ret    
  40a0c7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40a0ce:	00 00 

000000000040a0d0 <cos_print_str>:
	return 0;
}

CWEAKSYMB int
cos_print_str(char *s, int len)
{
  40a0d0:	f3 0f 1e fa          	endbr64 
	int written = 0;

	while (written < len) {
  40a0d4:	85 f6                	test   esi,esi
  40a0d6:	0f 8e a4 00 00 00    	jle    40a180 <cos_print_str+0xb0>
{
  40a0dc:	55                   	push   rbp
	int written = 0;
  40a0dd:	45 31 d2             	xor    r10d,r10d
{
  40a0e0:	48 89 e5             	mov    rbp,rsp
  40a0e3:	41 57                	push   r15
  40a0e5:	41 56                	push   r14
  40a0e7:	4c 8d 7d c0          	lea    r15,[rbp-0x40]
  40a0eb:	49 89 fe             	mov    r14,rdi
  40a0ee:	41 55                	push   r13
  40a0f0:	41 89 f5             	mov    r13d,esi
  40a0f3:	41 54                	push   r12
  40a0f5:	53                   	push   rbx
  40a0f6:	eb 10                	jmp    40a108 <cos_print_str+0x38>
  40a0f8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40a0ff:	00 
		int ret;

		ret = call_cap(PRINT_CAP_TEMP, s_ints[0], s_ints[1], s_ints[2], len - written);
		/* Bomb out. Can't use a print out here as we must avoid recursion. */
		if (ret < 0) written = *(int *)NULL;
		written += ret;
  40a100:	41 01 c2             	add    r10d,eax
	while (written < len) {
  40a103:	45 39 d5             	cmp    r13d,r10d
  40a106:	7e 60                	jle    40a168 <cos_print_str+0x98>
		u32_t *s_ints = (u32_t *)&s[written];
  40a108:	49 63 c2             	movsxd rax,r10d
		ret = call_cap(PRINT_CAP_TEMP, s_ints[0], s_ints[1], s_ints[2], len - written);
  40a10b:	44 89 ea             	mov    edx,r13d
	__asm__ __volatile__(
  40a10e:	4c 89 f9             	mov    rcx,r15
		u32_t *s_ints = (u32_t *)&s[written];
  40a111:	4c 01 f0             	add    rax,r14
		ret = call_cap(PRINT_CAP_TEMP, s_ints[0], s_ints[1], s_ints[2], len - written);
  40a114:	44 29 d2             	sub    edx,r10d
  40a117:	8b 18                	mov    ebx,DWORD PTR [rax]
  40a119:	8b 70 04             	mov    esi,DWORD PTR [rax+0x4]
  40a11c:	48 63 d2             	movsxd rdx,edx
  40a11f:	8b 78 08             	mov    edi,DWORD PTR [rax+0x8]
  40a122:	b8 00 00 03 00       	mov    eax,0x30000
  40a127:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40a12a:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40a12e:	48 89 cd             	mov    rbp,rcx
  40a131:	49 b8 48 a1 40 00 00 	movabs r8,0x40a148
  40a138:	00 00 00 
  40a13b:	0f 05                	syscall 
  40a13d:	0f 1f 00             	nop    DWORD PTR [rax]
  40a140:	eb 0d                	jmp    40a14f <cos_print_str+0x7f>
  40a142:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40a148:	b9 00 00 00 00       	mov    ecx,0x0
  40a14d:	eb 05                	jmp    40a154 <cos_print_str+0x84>
  40a14f:	b9 01 00 00 00       	mov    ecx,0x1
  40a154:	5d                   	pop    rbp
  40a155:	5c                   	pop    rsp
		if (ret < 0) written = *(int *)NULL;
  40a156:	85 c0                	test   eax,eax
  40a158:	79 a6                	jns    40a100 <cos_print_str+0x30>
  40a15a:	8b 04 25 00 00 00 00 	mov    eax,DWORD PTR ds:0x0
  40a161:	0f 0b                	ud2    
  40a163:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	}

	return written;
}
  40a168:	44 89 d0             	mov    eax,r10d
  40a16b:	5b                   	pop    rbx
  40a16c:	41 5c                	pop    r12
  40a16e:	41 5d                	pop    r13
  40a170:	41 5e                	pop    r14
  40a172:	41 5f                	pop    r15
  40a174:	5d                   	pop    rbp
  40a175:	c3                   	ret    
  40a176:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40a17d:	00 00 00 
  40a180:	31 c0                	xor    eax,eax
  40a182:	c3                   	ret    
  40a183:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a18a:	00 00 00 00 
  40a18e:	66 90                	xchg   ax,ax

000000000040a190 <printc.constprop.0>:
printc(char *fmt, ...)
  40a190:	55                   	push   rbp
  40a191:	48 89 e5             	mov    rbp,rsp
  40a194:	48 81 ec 90 01 00 00 	sub    rsp,0x190
  40a19b:	48 89 b5 58 ff ff ff 	mov    QWORD PTR [rbp-0xa8],rsi
  40a1a2:	48 89 95 60 ff ff ff 	mov    QWORD PTR [rbp-0xa0],rdx
  40a1a9:	48 89 8d 68 ff ff ff 	mov    QWORD PTR [rbp-0x98],rcx
  40a1b0:	4c 89 85 70 ff ff ff 	mov    QWORD PTR [rbp-0x90],r8
  40a1b7:	4c 89 8d 78 ff ff ff 	mov    QWORD PTR [rbp-0x88],r9
  40a1be:	84 c0                	test   al,al
  40a1c0:	74 20                	je     40a1e2 <printc.constprop.0+0x52>
  40a1c2:	0f 29 45 80          	movaps XMMWORD PTR [rbp-0x80],xmm0
  40a1c6:	0f 29 4d 90          	movaps XMMWORD PTR [rbp-0x70],xmm1
  40a1ca:	0f 29 55 a0          	movaps XMMWORD PTR [rbp-0x60],xmm2
  40a1ce:	0f 29 5d b0          	movaps XMMWORD PTR [rbp-0x50],xmm3
  40a1d2:	0f 29 65 c0          	movaps XMMWORD PTR [rbp-0x40],xmm4
  40a1d6:	0f 29 6d d0          	movaps XMMWORD PTR [rbp-0x30],xmm5
  40a1da:	0f 29 75 e0          	movaps XMMWORD PTR [rbp-0x20],xmm6
  40a1de:	0f 29 7d f0          	movaps XMMWORD PTR [rbp-0x10],xmm7
	va_start(arg_ptr, fmt);
  40a1e2:	48 8d 45 10          	lea    rax,[rbp+0x10]
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40a1e6:	ba c0 bf 41 00       	mov    edx,0x41bfc0
  40a1eb:	be b4 00 00 00       	mov    esi,0xb4
	va_start(arg_ptr, fmt);
  40a1f0:	c7 85 78 fe ff ff 08 	mov    DWORD PTR [rbp-0x188],0x8
  40a1f7:	00 00 00 
  40a1fa:	48 89 85 80 fe ff ff 	mov    QWORD PTR [rbp-0x180],rax
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40a201:	48 8d 8d 78 fe ff ff 	lea    rcx,[rbp-0x188]
	va_start(arg_ptr, fmt);
  40a208:	48 8d 85 50 ff ff ff 	lea    rax,[rbp-0xb0]
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40a20f:	48 8d bd 90 fe ff ff 	lea    rdi,[rbp-0x170]
	va_start(arg_ptr, fmt);
  40a216:	48 89 85 88 fe ff ff 	mov    QWORD PTR [rbp-0x178],rax
  40a21d:	c7 85 7c fe ff ff 30 	mov    DWORD PTR [rbp-0x184],0x30
  40a224:	00 00 00 
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40a227:	e8 74 b1 00 00       	call   4153a0 <vsnprintf>
	ret = cos_print_str(s, ret);
  40a22c:	48 8d bd 90 fe ff ff 	lea    rdi,[rbp-0x170]
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40a233:	89 c6                	mov    esi,eax
	ret = cos_print_str(s, ret);
  40a235:	e8 96 fe ff ff       	call   40a0d0 <cos_print_str>
}
  40a23a:	c9                   	leave  
  40a23b:	c3                   	ret    
  40a23c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000040a240 <prints.isra.0>:
prints(char *s)
  40a240:	55                   	push   rbp
  40a241:	48 89 e5             	mov    rbp,rsp
  40a244:	41 54                	push   r12
  40a246:	49 89 fc             	mov    r12,rdi
  40a249:	48 83 ec 08          	sub    rsp,0x8
	return cos_print_str(s, strlen(s));
  40a24d:	e8 1e b5 00 00       	call   415770 <strlen>
  40a252:	4c 89 e7             	mov    rdi,r12
}
  40a255:	4c 8b 65 f8          	mov    r12,QWORD PTR [rbp-0x8]
  40a259:	c9                   	leave  
	return cos_print_str(s, strlen(s));
  40a25a:	89 c6                	mov    esi,eax
  40a25c:	e9 6f fe ff ff       	jmp    40a0d0 <cos_print_str>
  40a261:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a268:	00 00 00 00 
  40a26c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000040a270 <cos_thd_entry_static>:
{
  40a270:	f3 0f 1e fa          	endbr64 
  40a274:	55                   	push   rbp
  40a275:	be 2d 00 00 00       	mov    esi,0x2d
  40a27a:	bf 08 c0 41 00       	mov    edi,0x41c008
  40a27f:	48 89 e5             	mov    rbp,rsp
  40a282:	e8 49 fe ff ff       	call   40a0d0 <cos_print_str>
	assert(0);
  40a287:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40a28e:	00 00 00 00 
  40a292:	0f 0b                	ud2    
  40a294:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a29b:	00 00 00 00 
  40a29f:	90                   	nop

000000000040a2a0 <cos_syscall_handler>:
{
  40a2a0:	f3 0f 1e fa          	endbr64 
  40a2a4:	55                   	push   rbp
  40a2a5:	48 89 f2             	mov    rdx,rsi
	printc("Default syscall handler called (syscall: %d, first arg: %ld), faulting!", syscall_num, a);
  40a2a8:	31 c0                	xor    eax,eax
  40a2aa:	89 fe                	mov    esi,edi
  40a2ac:	bf c0 bf 41 00       	mov    edi,0x41bfc0
{
  40a2b1:	48 89 e5             	mov    rbp,rsp
	printc("Default syscall handler called (syscall: %d, first arg: %ld), faulting!", syscall_num, a);
  40a2b4:	e8 d7 fe ff ff       	call   40a190 <printc.constprop.0>
  40a2b9:	be 2c 00 00 00       	mov    esi,0x2c
  40a2be:	bf 38 c0 41 00       	mov    edi,0x41c038
  40a2c3:	e8 08 fe ff ff       	call   40a0d0 <cos_print_str>
	assert(0);
  40a2c8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40a2cf:	00 00 00 00 
  40a2d3:	0f 0b                	ud2    
  40a2d5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a2dc:	00 00 00 00 

000000000040a2e0 <__cos_syscall>:
{
  40a2e0:	f3 0f 1e fa          	endbr64 
	return cos_syscall_handler(syscall_num, a, b, c, d, e, f, g);
  40a2e4:	e9 b7 ff ff ff       	jmp    40a2a0 <cos_syscall_handler>
  40a2e9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000040a2f0 <cos_main>:
{
  40a2f0:	f3 0f 1e fa          	endbr64 
	assert(cos_main_defined());
  40a2f4:	b8 c0 9f 40 00       	mov    eax,0x409fc0
  40a2f9:	48 3d c0 9f 40 00    	cmp    rax,0x409fc0
  40a2ff:	74 05                	je     40a306 <cos_main+0x16>
	return main();
  40a301:	e9 ba fc ff ff       	jmp    409fc0 <main>
{
  40a306:	55                   	push   rbp
  40a307:	be 2c 00 00 00       	mov    esi,0x2c
  40a30c:	bf 68 c0 41 00       	mov    edi,0x41c068
  40a311:	48 89 e5             	mov    rbp,rsp
  40a314:	e8 b7 fd ff ff       	call   40a0d0 <cos_print_str>
	assert(cos_main_defined());
  40a319:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40a320:	00 00 00 00 
  40a324:	0f 0b                	ud2    
  40a326:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40a32d:	00 00 00 

000000000040a330 <cos_print_level_set>:
int cos_print_level   = PRINT_ERROR;
int cos_print_lvl_str = 0;

CWEAKSYMB void
cos_print_level_set(cos_print_level_t lvl, int print_str)
{
  40a330:	f3 0f 1e fa          	endbr64 
	cos_print_level   = lvl;
  40a334:	89 3d ca 65 19 00    	mov    DWORD PTR [rip+0x1965ca],edi        # 5a0904 <cos_print_level>
	cos_print_lvl_str = print_str;
  40a33a:	89 35 c0 65 19 00    	mov    DWORD PTR [rip+0x1965c0],esi        # 5a0900 <cos_print_lvl_str>
}
  40a340:	c3                   	ret    
  40a341:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a348:	00 00 00 00 
  40a34c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000040a350 <cos_upcall_fn>:
}
#endif

CWEAKSYMB void
cos_upcall_fn(upcall_type_t t, void *arg1, void *arg2, void *arg3)
{
  40a350:	f3 0f 1e fa          	endbr64 
  40a354:	55                   	push   rbp
  40a355:	b9 01 00 00 00       	mov    ecx,0x1
  40a35a:	31 d2                	xor    edx,edx
  40a35c:	48 89 e5             	mov    rbp,rsp
  40a35f:	41 55                	push   r13
  40a361:	41 54                	push   r12
  40a363:	41 89 fc             	mov    r12d,edi
  40a366:	53                   	push   rbx
  40a367:	48 89 f3             	mov    rbx,rsi
  40a36a:	48 83 ec 08          	sub    rsp,0x8
  40a36e:	66 90                	xchg   ax,ax
  40a370:	48 89 d0             	mov    rax,rdx
  40a373:	f0 48 0f b1 0d 94 65 	lock cmpxchg QWORD PTR [rip+0x196594],rcx        # 5a0910 <_lock.1>
  40a37a:	19 00 
  40a37c:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40a37f:	84 c0                	test   al,al
  40a381:	74 ed                	je     40a370 <cos_upcall_fn+0x20>
	 * There should be no concurrency at initialization (the init
	 * interface ensures this), so atomic operations aren't
	 * required here to update first.
	 */
	ps_lock_take(&_lock);
	libc_tls_init(cos_cpuid());
  40a383:	31 ff                	xor    edi,edi
  40a385:	e8 f6 fc ff ff       	call   40a080 <libc_tls_init>
	if (first) {
  40a38a:	8b 05 78 bc 01 00    	mov    eax,DWORD PTR [rip+0x1bc78]        # 426008 <first.2>
  40a390:	85 c0                	test   eax,eax
  40a392:	0f 84 a5 00 00 00    	je     40a43d <cos_upcall_fn+0xed>
		/*
		 * Use the heap pointer as calculated from the linker
		 * script *if* the loader doesn't pass in its own
		 * value.
		 */
		if (__cosrt_comp_info.cos_heap_ptr == 0) {
  40a398:	48 83 3d b8 cc 01 00 	cmp    QWORD PTR [rip+0x1ccb8],0x0        # 427058 <__cosrt_comp_info+0x58>
  40a39f:	00 
		first = 0;
  40a3a0:	c7 05 5e bc 01 00 00 	mov    DWORD PTR [rip+0x1bc5e],0x0        # 426008 <first.2>
  40a3a7:	00 00 00 
		if (__cosrt_comp_info.cos_heap_ptr == 0) {
  40a3aa:	75 12                	jne    40a3be <cos_upcall_fn+0x6e>
			extern const vaddr_t __crt_static_heap_ptr;

			__cosrt_comp_info.cos_heap_ptr = round_up_to_page((vaddr_t)&__crt_static_heap_ptr);
  40a3ac:	b8 47 32 5a 00       	mov    eax,0x5a3247
  40a3b1:	48 25 00 f0 ff ff    	and    rax,0xfffffffffffff000
  40a3b7:	48 89 05 9a cc 01 00 	mov    QWORD PTR [rip+0x1cc9a],rax        # 427058 <__cosrt_comp_info+0x58>
		}

		cos_print_level_set(PRINT_DEBUG, 1);
  40a3be:	be 01 00 00 00       	mov    esi,0x1
  40a3c3:	bf 02 00 00 00       	mov    edi,0x2
static inline void
section_fnptrs_execute(long *list)
{
	int i;

	for (i = 0; i < list[0]; i++) {
  40a3c8:	45 31 ed             	xor    r13d,r13d
  40a3cb:	e8 60 ff ff ff       	call   40a330 <cos_print_level_set>
		/* The syscall enumlator might need something to be setup before it can work */
		pre_syscall_setup();
  40a3d0:	31 c0                	xor    eax,eax
  40a3d2:	e8 59 fc ff ff       	call   40a030 <pre_syscall_setup>
		/* libc needs syscall emulation to work */
		syscall_emulation_setup();
  40a3d7:	31 c0                	xor    eax,eax
  40a3d9:	e8 62 fc ff ff       	call   40a040 <syscall_emulation_setup>
		/* With all that setup, we can invoke the libc_initialization_handler */
		libc_initialization_handler();
  40a3de:	31 c0                	xor    eax,eax
  40a3e0:	e8 6b fc ff ff       	call   40a050 <libc_initialization_handler>
		/* init lib posix variants */
		libc_posixcap_initialization_handler();
  40a3e5:	31 c0                	xor    eax,eax
  40a3e7:	e8 74 fc ff ff       	call   40a060 <libc_posixcap_initialization_handler>
		libc_posixsched_initialization_handler();
  40a3ec:	31 c0                	xor    eax,eax
  40a3ee:	e8 7d fc ff ff       	call   40a070 <libc_posixsched_initialization_handler>
  40a3f3:	48 83 3d 05 7c 01 00 	cmp    QWORD PTR [rip+0x17c05],0x0        # 422000 <__CTOR_LIST__>
  40a3fa:	00 
  40a3fb:	7e 18                	jle    40a415 <cos_upcall_fn+0xc5>
  40a3fd:	0f 1f 00             	nop    DWORD PTR [rax]
		typedef void (*ctors_t)(void);
		ctors_t ctors = (ctors_t)list[i + 1];
		ctors();
  40a400:	42 ff 14 ed 08 20 42 	call   QWORD PTR [r13*8+0x422008]
  40a407:	00 
	for (i = 0; i < list[0]; i++) {
  40a408:	49 83 c5 01          	add    r13,0x1
  40a40c:	4c 3b 2d ed 7b 01 00 	cmp    r13,QWORD PTR [rip+0x17bed]        # 422000 <__CTOR_LIST__>
  40a413:	7c eb                	jl     40a400 <cos_upcall_fn+0xb0>
  40a415:	45 31 ed             	xor    r13d,r13d
  40a418:	48 83 3d 00 7c 01 00 	cmp    QWORD PTR [rip+0x17c00],0x0        # 422020 <__DTOR_END__>
  40a41f:	00 
  40a420:	7e 1b                	jle    40a43d <cos_upcall_fn+0xed>
  40a422:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
		ctors();
  40a428:	42 ff 14 ed 28 20 42 	call   QWORD PTR [r13*8+0x422028]
  40a42f:	00 
	for (i = 0; i < list[0]; i++) {
  40a430:	49 83 c5 01          	add    r13,0x1
  40a434:	4c 39 2d e5 7b 01 00 	cmp    QWORD PTR [rip+0x17be5],r13        # 422020 <__DTOR_END__>
  40a43b:	7f eb                	jg     40a428 <cos_upcall_fn+0xd8>
	ps_lock_release(&_lock);
	/*
	 * if it's the first component.. wait for timer calibration.
	 * NOTE: for "fork"ing components and not updating "spdid"s, this call will just fail and should be fine.
	 */
	if (cos_compid_uninitialized()) { /* we must be in the initial booter! */
  40a43d:	48 83 3d fb cb 01 00 	cmp    QWORD PTR [rip+0x1cbfb],0x0        # 427040 <__cosrt_comp_info+0x40>
  40a444:	00 
{ l->o = 0; }
  40a445:	48 c7 05 c0 64 19 00 	mov    QWORD PTR [rip+0x1964c0],0x0        # 5a0910 <_lock.1>
  40a44c:	00 00 00 00 
  40a450:	74 58                	je     40a4aa <cos_upcall_fn+0x15a>
		cos_hw_cycles_per_usec(BOOT_CAPTBL_SELF_INITHW_BASE);
		perfcntr_init();
	}

	switch (t) {
  40a452:	45 85 e4             	test   r12d,r12d
  40a455:	75 62                	jne    40a4b9 <cos_upcall_fn+0x169>
	{
		/* A new thread is created in this comp. */

		/* arg1 is the thread init data. 0 means
		 * bootstrap. */
		if (arg1 == 0) {
  40a457:	48 85 db             	test   rbx,rbx
  40a45a:	0f 84 82 00 00 00    	je     40a4e2 <cos_upcall_fn+0x192>
			static unsigned long first_core = 1;

			/* FIXME: assume that core 0 is the initial core for now */
			start_execution(cos_coreid(), ps_cas(&first_core, 1, 0), init_parallelism());
		} else {
			word_t idx = (word_t)arg1 - 1;
  40a460:	48 83 eb 01          	sub    rbx,0x1
			if (idx >= COS_THD_INIT_REGION_SIZE) {
  40a464:	48 81 fb ff 00 00 00 	cmp    rbx,0xff
  40a46b:	77 68                	ja     40a4d5 <cos_upcall_fn+0x185>
	fn   = __thd_init_data[idx].fn;
  40a46d:	89 db                	mov    ebx,ebx
	__thd_init_data[idx].fn   = NULL;
  40a46f:	66 0f ef c0          	pxor   xmm0,xmm0
	fn   = __thd_init_data[idx].fn;
  40a473:	48 c1 e3 04          	shl    rbx,0x4
  40a477:	48 8b 83 00 f9 59 00 	mov    rax,QWORD PTR [rbx+0x59f900]
	data = __thd_init_data[idx].data;
  40a47e:	48 8b bb 08 f9 59 00 	mov    rdi,QWORD PTR [rbx+0x59f908]
	__thd_init_data[idx].fn   = NULL;
  40a485:	0f 29 83 00 f9 59 00 	movaps XMMWORD PTR [rbx+0x59f900],xmm0
	(fn)(data);
  40a48c:	ff d0                	call   rax
  40a48e:	be 2d 00 00 00       	mov    esi,0x2d
  40a493:	bf 58 c1 41 00       	mov    edi,0x41c158
  40a498:	e8 33 fc ff ff       	call   40a0d0 <cos_print_str>
	}
	default:
		/* fault! */
		assert(0);
	}
	assert(0); 		/* should *not* return from threads */
  40a49d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40a4a4:	00 00 00 00 
  40a4a8:	0f 0b                	ud2    
		cos_hw_cycles_per_usec(BOOT_CAPTBL_SELF_INITHW_BASE);
  40a4aa:	bf 24 00 00 00       	mov    edi,0x24
  40a4af:	e8 6c 7a 00 00       	call   411f20 <cos_hw_cycles_per_usec>
	switch (t) {
  40a4b4:	45 85 e4             	test   r12d,r12d
  40a4b7:	74 9e                	je     40a457 <cos_upcall_fn+0x107>
  40a4b9:	be 2d 00 00 00       	mov    esi,0x2d
  40a4be:	bf 28 c1 41 00       	mov    edi,0x41c128
  40a4c3:	e8 08 fc ff ff       	call   40a0d0 <cos_print_str>
		assert(0);
  40a4c8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40a4cf:	00 00 00 00 
  40a4d3:	0f 0b                	ud2    
				cos_thd_entry_static(idx - COS_THD_INIT_REGION_SIZE);
  40a4d5:	8d bb 00 ff ff ff    	lea    edi,[rbx-0x100]
  40a4db:	e8 90 fd ff ff       	call   40a270 <cos_thd_entry_static>
  40a4e0:	eb ac                	jmp    40a48e <cos_upcall_fn+0x13e>
			start_execution(cos_coreid(), ps_cas(&first_core, 1, 0), init_parallelism());
  40a4e2:	e8 39 f8 ff ff       	call   409d20 <init_parallelism>
        __asm__ __volatile__("lock " PS_CAS_STR
  40a4e7:	b8 01 00 00 00       	mov    eax,0x1
  40a4ec:	f0 48 0f b1 1d 0b bb 	lock cmpxchg QWORD PTR [rip+0x1bb0b],rbx        # 426000 <first_core.3>
  40a4f3:	01 00 
  40a4f5:	0f 94 c0             	sete   al
        return (int)z;
  40a4f8:	44 0f be e8          	movsx  r13d,al
	if (parallel_main != __crt_parallel_main) {
  40a4fc:	b8 00 47 40 00       	mov    eax,0x404700
  40a501:	48 3d d0 9f 40 00    	cmp    rax,0x409fd0
  40a507:	0f 84 9b 00 00 00    	je     40a5a8 <cos_upcall_fn+0x258>
	if (initialization_completed == 0) {
  40a50d:	8b 05 f9 63 19 00    	mov    eax,DWORD PTR [rip+0x1963f9]        # 5a090c <initialization_completed.4>
  40a513:	85 c0                	test   eax,eax
  40a515:	75 79                	jne    40a590 <cos_upcall_fn+0x240>
		main_type = INIT_MAIN_PARALLEL;
  40a517:	41 bc 02 00 00 00    	mov    r12d,0x2
		if (init_core) {
  40a51d:	45 85 ed             	test   r13d,r13d
  40a520:	0f 85 a4 00 00 00    	jne    40a5ca <cos_upcall_fn+0x27a>
  40a526:	bb 30 47 40 00       	mov    ebx,0x404730
		COS_EXTERN_INV(init_parallel_await_init)();
  40a52b:	e8 80 b5 ff ff       	call   405ab0 <__cosrt_extern_init_parallel_await_init>
		if (parallel_init) {
  40a530:	48 81 fb e0 9f 40 00 	cmp    rbx,0x409fe0
  40a537:	74 11                	je     40a54a <cos_upcall_fn+0x1fa>
			cos_parallel_init(cid, init_core, init_parallelism());
  40a539:	e8 e2 f7 ff ff       	call   409d20 <init_parallelism>
  40a53e:	44 89 ee             	mov    esi,r13d
  40a541:	31 ff                	xor    edi,edi
  40a543:	89 c2                	mov    edx,eax
  40a545:	e8 e6 a1 ff ff       	call   404730 <cos_parallel_init>
		COS_EXTERN_INV(init_done)(0, main_type);
  40a54a:	44 89 e6             	mov    esi,r12d
  40a54d:	31 ff                	xor    edi,edi
  40a54f:	e8 7c b5 ff ff       	call   405ad0 <__cosrt_extern_init_done>
		initialization_completed = 1;
  40a554:	c7 05 ae 63 19 00 01 	mov    DWORD PTR [rip+0x1963ae],0x1        # 5a090c <initialization_completed.4>
  40a55b:	00 00 00 
	assert(main_type != INIT_MAIN_NONE);
  40a55e:	45 85 e4             	test   r12d,r12d
  40a561:	0f 84 89 00 00 00    	je     40a5f0 <cos_upcall_fn+0x2a0>
	assert(main_type == INIT_MAIN_PARALLEL || (main_type == INIT_MAIN_SINGLE && init_core));
  40a567:	41 83 fc 02          	cmp    r12d,0x2
  40a56b:	74 23                	je     40a590 <cos_upcall_fn+0x240>
  40a56d:	45 85 ed             	test   r13d,r13d
  40a570:	0f 84 ff 00 00 00    	je     40a675 <cos_upcall_fn+0x325>
	assert(cos_main_defined());
  40a576:	b8 c0 9f 40 00       	mov    eax,0x409fc0
  40a57b:	48 3d c0 9f 40 00    	cmp    rax,0x409fc0
  40a581:	0f 84 d7 00 00 00    	je     40a65e <cos_upcall_fn+0x30e>
	return main();
  40a587:	e8 34 fa ff ff       	call   409fc0 <main>
  40a58c:	89 c7                	mov    edi,eax
  40a58e:	eb 13                	jmp    40a5a3 <cos_upcall_fn+0x253>
		parallel_main(cid, init_core, init_parallelism());
  40a590:	e8 8b f7 ff ff       	call   409d20 <init_parallelism>
  40a595:	31 ff                	xor    edi,edi
  40a597:	44 89 ee             	mov    esi,r13d
  40a59a:	89 c2                	mov    edx,eax
  40a59c:	e8 5f a1 ff ff       	call   404700 <parallel_main>
	int ret = 0;
  40a5a1:	31 ff                	xor    edi,edi
	COS_EXTERN_INV(init_exit)(ret);
  40a5a3:	e8 c8 b6 ff ff       	call   405c70 <__cosrt_extern_init_exit>
	} else if (cos_main_defined()) {
  40a5a8:	b8 c0 9f 40 00       	mov    eax,0x409fc0
  40a5ad:	48 3d c0 9f 40 00    	cmp    rax,0x409fc0
  40a5b3:	74 52                	je     40a607 <cos_upcall_fn+0x2b7>
	if (initialization_completed == 0) {
  40a5b5:	8b 05 51 63 19 00    	mov    eax,DWORD PTR [rip+0x196351]        # 5a090c <initialization_completed.4>
  40a5bb:	85 c0                	test   eax,eax
  40a5bd:	75 ae                	jne    40a56d <cos_upcall_fn+0x21d>
		main_type = INIT_MAIN_SINGLE;
  40a5bf:	41 bc 01 00 00 00    	mov    r12d,0x1
  40a5c5:	e9 53 ff ff ff       	jmp    40a51d <cos_upcall_fn+0x1cd>
			cos_init();
  40a5ca:	31 c0                	xor    eax,eax
	const int parallel_init = cos_parallel_init != __crt_cos_parallel_init;
  40a5cc:	bb 30 47 40 00       	mov    ebx,0x404730
			cos_init();
  40a5d1:	e8 7a a2 ff ff       	call   404850 <cos_init>
	const int parallel_init = cos_parallel_init != __crt_cos_parallel_init;
  40a5d6:	31 ff                	xor    edi,edi
  40a5d8:	48 81 fb e0 9f 40 00 	cmp    rbx,0x409fe0
			COS_EXTERN_INV(init_done)(parallel_init, main_type);
  40a5df:	44 89 e6             	mov    esi,r12d
	const int parallel_init = cos_parallel_init != __crt_cos_parallel_init;
  40a5e2:	40 0f 95 c7          	setne  dil
			COS_EXTERN_INV(init_done)(parallel_init, main_type);
  40a5e6:	e8 e5 b4 ff ff       	call   405ad0 <__cosrt_extern_init_done>
			assert(parallel_init || main_type != INIT_MAIN_NONE);
  40a5eb:	e9 3b ff ff ff       	jmp    40a52b <cos_upcall_fn+0x1db>
	assert(main_type != INIT_MAIN_NONE);
  40a5f0:	bf c8 c0 41 00       	mov    edi,0x41c0c8
  40a5f5:	e8 46 fc ff ff       	call   40a240 <prints.isra.0>
  40a5fa:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40a601:	00 00 00 00 
  40a605:	0f 0b                	ud2    
	if (initialization_completed == 0) {
  40a607:	8b 05 ff 62 19 00    	mov    eax,DWORD PTR [rip+0x1962ff]        # 5a090c <initialization_completed.4>
  40a60d:	85 c0                	test   eax,eax
  40a60f:	75 df                	jne    40a5f0 <cos_upcall_fn+0x2a0>
		if (init_core) {
  40a611:	45 85 ed             	test   r13d,r13d
  40a614:	0f 84 0c ff ff ff    	je     40a526 <cos_upcall_fn+0x1d6>
			cos_init();
  40a61a:	31 c0                	xor    eax,eax
	const int parallel_init = cos_parallel_init != __crt_cos_parallel_init;
  40a61c:	bb 30 47 40 00       	mov    ebx,0x404730
			cos_init();
  40a621:	e8 2a a2 ff ff       	call   404850 <cos_init>
	const int parallel_init = cos_parallel_init != __crt_cos_parallel_init;
  40a626:	31 ff                	xor    edi,edi
  40a628:	48 81 fb e0 9f 40 00 	cmp    rbx,0x409fe0
  40a62f:	40 0f 95 c7          	setne  dil
			COS_EXTERN_INV(init_done)(parallel_init, main_type);
  40a633:	31 f6                	xor    esi,esi
  40a635:	e8 96 b4 ff ff       	call   405ad0 <__cosrt_extern_init_done>
			assert(parallel_init || main_type != INIT_MAIN_NONE);
  40a63a:	48 81 fb e0 9f 40 00 	cmp    rbx,0x409fe0
  40a641:	0f 85 e4 fe ff ff    	jne    40a52b <cos_upcall_fn+0x1db>
  40a647:	bf 98 c0 41 00       	mov    edi,0x41c098
  40a64c:	e8 ef fb ff ff       	call   40a240 <prints.isra.0>
  40a651:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40a658:	00 00 00 00 
  40a65c:	0f 0b                	ud2    
	assert(cos_main_defined());
  40a65e:	bf 68 c0 41 00       	mov    edi,0x41c068
  40a663:	e8 d8 fb ff ff       	call   40a240 <prints.isra.0>
  40a668:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40a66f:	00 00 00 00 
  40a673:	0f 0b                	ud2    
	assert(main_type == INIT_MAIN_PARALLEL || (main_type == INIT_MAIN_SINGLE && init_core));
  40a675:	bf f8 c0 41 00       	mov    edi,0x41c0f8
  40a67a:	e8 c1 fb ff ff       	call   40a240 <prints.isra.0>
  40a67f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40a686:	00 00 00 00 
  40a68a:	0f 0b                	ud2    
  40a68c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000040a690 <cos_get_vas_page>:
	return;
}

CWEAKSYMB void *
cos_get_vas_page(void)
{
  40a690:	f3 0f 1e fa          	endbr64 
  40a694:	55                   	push   rbp
  40a695:	48 89 e5             	mov    rbp,rsp
  40a698:	53                   	push   rbx
  40a699:	bb 58 70 42 00       	mov    ebx,0x427058
  40a69e:	66 90                	xchg   ax,ax
	return (void *)__cosrt_comp_info.cos_heap_ptr;
  40a6a0:	48 8b 05 b1 c9 01 00 	mov    rax,QWORD PTR [rip+0x1c9b1]        # 427058 <__cosrt_comp_info+0x58>
	char *h;
	long  r;
	do {
		h = cos_get_heap_ptr();
		r = (long)h + PAGE_SIZE;
  40a6a7:	48 8d 88 00 10 00 00 	lea    rcx,[rax+0x1000]
	__asm__ __volatile__("call cos_atomic_cmpxchg"
  40a6ae:	e8 7d 02 00 00       	call   40a930 <cos_atomic_cmpxchg>
	} while (cos_cmpxchg(&__cosrt_comp_info.cos_heap_ptr, (long)h, r) != r);
  40a6b3:	48 39 ca             	cmp    rdx,rcx
  40a6b6:	75 e8                	jne    40a6a0 <cos_get_vas_page+0x10>
	return h;
}
  40a6b8:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
  40a6bc:	c9                   	leave  
  40a6bd:	c3                   	ret    
  40a6be:	66 90                	xchg   ax,ax

000000000040a6c0 <cos_release_vas_page>:

CWEAKSYMB void
cos_release_vas_page(void *p)
{
  40a6c0:	f3 0f 1e fa          	endbr64 
  40a6c4:	55                   	push   rbp
  40a6c5:	48 89 f9             	mov    rcx,rdi
	cos_set_heap_ptr_conditional(p + PAGE_SIZE, p);
  40a6c8:	48 8d 87 00 10 00 00 	lea    rax,[rdi+0x1000]
{
  40a6cf:	48 89 e5             	mov    rbp,rsp
  40a6d2:	53                   	push   rbx
  40a6d3:	bb 58 70 42 00       	mov    ebx,0x427058
  40a6d8:	e8 53 02 00 00       	call   40a930 <cos_atomic_cmpxchg>
}
  40a6dd:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
  40a6e1:	c9                   	leave  
  40a6e2:	c3                   	ret    
  40a6e3:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a6ea:	00 00 00 00 
  40a6ee:	66 90                	xchg   ax,ax

000000000040a6f0 <cos_initargs_tar>:
CWEAKSYMB long _binary_tar_binary_start = 0;
CWEAKSYMB long _binary_tar_binary_end = 0;

char *
cos_initargs_tar(void)
{
  40a6f0:	f3 0f 1e fa          	endbr64 
	/* Tar files are at least one record, which is 512 bytes */
	if (_binary_tar_binary_end - _binary_tar_binary_start < 512) return NULL;
  40a6f4:	48 8b 05 cd 51 19 00 	mov    rax,QWORD PTR [rip+0x1951cd]        # 59f8c8 <_binary_tar_binary_start>
  40a6fb:	48 8b 15 be 51 19 00 	mov    rdx,QWORD PTR [rip+0x1951be]        # 59f8c0 <_binary_tar_binary_end>
  40a702:	48 29 c2             	sub    rdx,rax
  40a705:	48 81 fa ff 01 00 00 	cmp    rdx,0x1ff
  40a70c:	ba 00 00 00 00       	mov    edx,0x0
  40a711:	48 0f 4e c2          	cmovle rax,rdx
	return (char *)_binary_tar_binary_start;
}
  40a715:	c3                   	ret    
  40a716:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40a71d:	00 00 00 

000000000040a720 <__cosrt_c_cosrtdefault>:
#include <cos_kernel_api.h>
#include <cos_types.h>
#include <c_stub.h>

COS_CLIENT_STUB(int, cosrtdefault, word_t p0, word_t p1, word_t p2, word_t p3)
{
  40a720:	f3 0f 1e fa          	endbr64 
  40a724:	55                   	push   rbp
  40a725:	48 89 e5             	mov    rbp,rsp
  40a728:	41 56                	push   r14
  40a72a:	49 89 ce             	mov    r14,rcx
  40a72d:	41 55                	push   r13
  40a72f:	41 54                	push   r12
  40a731:	53                   	push   rbx
  40a732:	48 83 ec 20          	sub    rsp,0x20
  40a736:	4c 8b 40 08          	mov    r8,QWORD PTR [rax+0x8]
  40a73a:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, &r1, &r2);
  40a73e:	48 85 c0             	test   rax,rax
  40a741:	74 1d                	je     40a760 <__cosrt_c_cosrtdefault+0x40>
  40a743:	4c 8d 4d d0          	lea    r9,[rbp-0x30]
  40a747:	4c 8d 45 c8          	lea    r8,[rbp-0x38]
  40a74b:	ff d0                	call   rax
	COS_CLIENT_INVCAP;
	return cos_sinv(uc, p0, p1, p2, p3);
}
  40a74d:	48 83 c4 20          	add    rsp,0x20
  40a751:	5b                   	pop    rbx
  40a752:	41 5c                	pop    r12
  40a754:	41 5d                	pop    r13
  40a756:	41 5e                	pop    r14
  40a758:	5d                   	pop    rbp
  40a759:	c3                   	ret    
  40a75a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40a760:	41 8d 40 01          	lea    eax,[r8+0x1]
	__asm__ __volatile__(
  40a764:	48 89 fb             	mov    rbx,rdi
  40a767:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  40a76b:	48 89 d7             	mov    rdi,rdx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40a76e:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40a771:	4c 89 f2             	mov    rdx,r14
  40a774:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40a777:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40a77b:	48 89 cd             	mov    rbp,rcx
  40a77e:	49 b8 98 a7 40 00 00 	movabs r8,0x40a798
  40a785:	00 00 00 
  40a788:	0f 05                	syscall 
  40a78a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40a790:	eb 0d                	jmp    40a79f <__cosrt_c_cosrtdefault+0x7f>
  40a792:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40a798:	b9 00 00 00 00       	mov    ecx,0x0
  40a79d:	eb 05                	jmp    40a7a4 <__cosrt_c_cosrtdefault+0x84>
  40a79f:	b9 01 00 00 00       	mov    ecx,0x1
  40a7a4:	5d                   	pop    rbp
  40a7a5:	5c                   	pop    rsp
  40a7a6:	48 83 c4 20          	add    rsp,0x20
  40a7aa:	5b                   	pop    rbx
  40a7ab:	41 5c                	pop    r12
  40a7ad:	41 5d                	pop    r13
  40a7af:	41 5e                	pop    r14
  40a7b1:	5d                   	pop    rbp
  40a7b2:	c3                   	ret    
  40a7b3:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a7ba:	00 00 00 00 
  40a7be:	66 90                	xchg   ax,ax

000000000040a7c0 <__cosrt_c_cosrtretdefault>:

COS_CLIENT_STUB(int, cosrtretdefault, word_t p0, word_t p1, word_t p2, word_t p3, word_t *r1, word_t *r2)
{
  40a7c0:	f3 0f 1e fa          	endbr64 
  40a7c4:	55                   	push   rbp
  40a7c5:	48 89 e5             	mov    rbp,rsp
  40a7c8:	41 57                	push   r15
  40a7ca:	4d 89 c7             	mov    r15,r8
  40a7cd:	41 56                	push   r14
  40a7cf:	4d 89 ce             	mov    r14,r9
  40a7d2:	41 55                	push   r13
  40a7d4:	49 89 d5             	mov    r13,rdx
  40a7d7:	48 89 ca             	mov    rdx,rcx
  40a7da:	41 54                	push   r12
  40a7dc:	53                   	push   rbx
  40a7dd:	48 89 fb             	mov    rbx,rdi
  40a7e0:	4c 8b 50 10          	mov    r10,QWORD PTR [rax+0x10]
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  40a7e4:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  40a7e8:	4d 85 d2             	test   r10,r10
  40a7eb:	74 13                	je     40a800 <__cosrt_c_cosrtretdefault+0x40>
  40a7ed:	48 89 d1             	mov    rcx,rdx
  40a7f0:	4c 89 ea             	mov    rdx,r13
	COS_CLIENT_INVCAP;

	return cos_sinv_2rets(uc, p0, p1, p2, p3, r1, r2);
}
  40a7f3:	5b                   	pop    rbx
  40a7f4:	41 5c                	pop    r12
  40a7f6:	41 5d                	pop    r13
  40a7f8:	41 5e                	pop    r14
  40a7fa:	41 5f                	pop    r15
  40a7fc:	5d                   	pop    rbp
  40a7fd:	41 ff e2             	jmp    r10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40a800:	8d 41 01             	lea    eax,[rcx+0x1]
	__asm__ __volatile__(
  40a803:	4c 89 ef             	mov    rdi,r13
  40a806:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40a80a:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40a80d:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40a810:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40a814:	48 89 cd             	mov    rbp,rcx
  40a817:	49 b8 30 a8 40 00 00 	movabs r8,0x40a830
  40a81e:	00 00 00 
  40a821:	0f 05                	syscall 
  40a823:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40a828:	eb 0f                	jmp    40a839 <__cosrt_c_cosrtretdefault+0x79>
  40a82a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40a830:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  40a837:	eb 07                	jmp    40a840 <__cosrt_c_cosrtretdefault+0x80>
  40a839:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  40a840:	5d                   	pop    rbp
  40a841:	5c                   	pop    rsp
  40a842:	49 89 37             	mov    QWORD PTR [r15],rsi
  40a845:	49 89 3e             	mov    QWORD PTR [r14],rdi
  40a848:	5b                   	pop    rbx
  40a849:	41 5c                	pop    r12
  40a84b:	41 5d                	pop    r13
  40a84d:	41 5e                	pop    r14
  40a84f:	41 5f                	pop    r15
  40a851:	5d                   	pop    rbp
  40a852:	c3                   	ret    
  40a853:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40a85a:	00 00 00 
  40a85d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040a860 <cos_ainv_entry>:
  40a860:	53                   	push   rbx
  40a861:	56                   	push   rsi
  40a862:	57                   	push   rdi
  40a863:	52                   	push   rdx
  40a864:	55                   	push   rbp
  40a865:	89 e3                	mov    ebx,esp
  40a867:	83 c3 18             	add    ebx,0x18
  40a86a:	53                   	push   rbx
  40a86b:	50                   	push   rax
  40a86c:	e8 4f f8 ff ff       	call   40a0c0 <cos_async_inv>
  40a871:	83 c4 08             	add    esp,0x8
  40a874:	83 f8 00             	cmp    eax,0x0
  40a877:	74 22                	je     40a89b <ainv_ret>
  40a879:	67 8b 5c 24 18       	mov    ebx,DWORD PTR [esp+0x18]
  40a87e:	67 8b 74 24 1c       	mov    esi,DWORD PTR [esp+0x1c]
  40a883:	67 8b 7c 24 20       	mov    edi,DWORD PTR [esp+0x20]
  40a888:	67 8b 54 24 24       	mov    edx,DWORD PTR [esp+0x24]
  40a88d:	89 e5                	mov    ebp,esp
  40a88f:	48 b9 9b a8 40 00 00 	movabs rcx,0x40a89b
  40a896:	00 00 00 
  40a899:	0f 34                	sysenter 

000000000040a89b <ainv_ret>:
  40a89b:	5d                   	pop    rbp
  40a89c:	5a                   	pop    rdx
  40a89d:	5f                   	pop    rdi
  40a89e:	5e                   	pop    rsi
  40a89f:	5b                   	pop    rbx
  40a8a0:	c3                   	ret    
  40a8a1:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40a8a8:	00 00 00 
  40a8ab:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000040a8b0 <custom_acquire_stack>:
  40a8b0:	48 89 c2             	mov    rdx,rax
  40a8b3:	48 bc 00 a0 42 00 00 	movabs rsp,0x42a000
  40a8ba:	00 00 00 
  40a8bd:	48 25 ff ff 00 00    	and    rax,0xffff
  40a8c3:	48 c1 e0 0d          	shl    rax,0xd
  40a8c7:	48 01 c4             	add    rsp,rax
  40a8ca:	48 c1 e8 0d          	shr    rax,0xd
  40a8ce:	48 c1 ea 10          	shr    rdx,0x10
  40a8d2:	ff e1                	jmp    rcx
  40a8d4:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a8db:	00 00 00 00 
  40a8df:	90                   	nop

000000000040a8e0 <__cosrt_upcall_entry>:
  40a8e0:	48 b9 ef a8 40 00 00 	movabs rcx,0x40a8ef
  40a8e7:	00 00 00 
  40a8ea:	e9 c1 ff ff ff       	jmp    40a8b0 <custom_acquire_stack>
  40a8ef:	52                   	push   rdx
  40a8f0:	50                   	push   rax
  40a8f1:	6a 00                	push   0x0
  40a8f3:	6a 00                	push   0x0
  40a8f5:	48 89 64 24 f0       	mov    QWORD PTR [rsp-0x10],rsp
  40a8fa:	6a 00                	push   0x0
  40a8fc:	48 89 64 24 f0       	mov    QWORD PTR [rsp-0x10],rsp
  40a901:	48 83 ec 10          	sub    rsp,0x10
  40a905:	48 89 f1             	mov    rcx,rsi
  40a908:	48 89 fa             	mov    rdx,rdi
  40a90b:	48 89 de             	mov    rsi,rbx
  40a90e:	48 31 ed             	xor    rbp,rbp
  40a911:	4c 89 e7             	mov    rdi,r12
  40a914:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  40a918:	e8 33 fa ff ff       	call   40a350 <cos_upcall_fn>
  40a91d:	83 c4 18             	add    esp,0x18
  40a920:	5e                   	pop    rsi
  40a921:	5f                   	pop    rdi
  40a922:	89 c1                	mov    ecx,eax
  40a924:	b8 00 00 01 00       	mov    eax,0x10000
  40a929:	0f 34                	sysenter 
  40a92b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000040a930 <cos_atomic_cmpxchg>:
  40a930:	c3                   	ret    

000000000040a931 <cos_atomic_user1>:
  40a931:	b8 00 00 00 00       	mov    eax,0x0
  40a936:	67 8b 00             	mov    eax,DWORD PTR [eax]
  40a939:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000040a940 <args_iter.part.0.isra.0>:

/* Length of the K/V map (= 1 for a K/V with a string value) */
static int
kv_len(struct kv_entry *kv)
{
	if (!kv) return 0;
  40a940:	48 85 ff             	test   rdi,rdi
  40a943:	74 73                	je     40a9b8 <args_iter.part.0.isra.0+0x78>
	switch (kv->vtype) {
  40a945:	8b 47 08             	mov    eax,DWORD PTR [rdi+0x8]
  40a948:	85 c0                	test   eax,eax
  40a94a:	74 54                	je     40a9a0 <args_iter.part.0.isra.0+0x60>
  40a94c:	83 f8 01             	cmp    eax,0x1
  40a94f:	74 0f                	je     40a960 <args_iter.part.0.isra.0+0x20>
 * this returns the first item in the K/V store
 */
static int
kv_iter(struct kv_entry *kv, struct kv_iter *i, struct kv_entry **ent)
{
	*i = (struct kv_iter){
  40a951:	48 89 7e 08          	mov    QWORD PTR [rsi+0x8],rdi
	if (i->start->vtype != VTYPE_ARR) return 0;
  40a955:	31 c0                	xor    eax,eax
	*i = (struct kv_iter){
  40a957:	48 c7 46 10 00 00 00 	mov    QWORD PTR [rsi+0x10],0x0
  40a95e:	00 
	if (i->start->vtype != VTYPE_ARR) return 0;
  40a95f:	c3                   	ret    
	case VTYPE_ARR: return kv->val.arr.sz;
  40a960:	8b 47 10             	mov    eax,DWORD PTR [rdi+0x10]
	*i = (struct kv_iter){
  40a963:	48 89 7e 08          	mov    QWORD PTR [rsi+0x8],rdi
  40a967:	c7 46 10 00 00 00 00 	mov    DWORD PTR [rsi+0x10],0x0
  40a96e:	89 46 14             	mov    DWORD PTR [rsi+0x14],eax
	if (i->curr == i->len) return 0;
  40a971:	85 c0                	test   eax,eax
  40a973:	75 0b                	jne    40a980 <args_iter.part.0.isra.0+0x40>
	switch (arg->type) {
	case ARGS_IMPL_KV:  return kv_iter(arg->d.kv_ent, &i->i.kv_i, &ent->d.kv_ent);
	case ARGS_IMPL_TAR: return tar_iter(&arg->d.tar_ent, &i->i.tar_i, &ent->d.tar_ent);
	default:            return 0;
	}
}
  40a975:	c3                   	ret    
  40a976:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40a97d:	00 00 00 
	*ent = __kv_index(i->start, i->curr++);
  40a980:	c7 46 10 01 00 00 00 	mov    DWORD PTR [rsi+0x10],0x1
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  40a987:	7e 47                	jle    40a9d0 <args_iter.part.0.isra.0+0x90>
	return kv->val.arr.kvs[idx];
  40a989:	48 8b 47 18          	mov    rax,QWORD PTR [rdi+0x18]
  40a98d:	48 8b 00             	mov    rax,QWORD PTR [rax]
	*ent = __kv_index(i->start, i->curr++);
  40a990:	48 89 42 08          	mov    QWORD PTR [rdx+0x8],rax
	return 1;
  40a994:	b8 01 00 00 00       	mov    eax,0x1
  40a999:	c3                   	ret    
  40a99a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	*i = (struct kv_iter){
  40a9a0:	48 8b 05 51 18 01 00 	mov    rax,QWORD PTR [rip+0x11851]        # 41c1f8 <__unlock+0x11c8>
  40a9a7:	48 89 7e 08          	mov    QWORD PTR [rsi+0x8],rdi
  40a9ab:	48 89 46 10          	mov    QWORD PTR [rsi+0x10],rax
	if (i->start->vtype != VTYPE_ARR) return 0;
  40a9af:	31 c0                	xor    eax,eax
  40a9b1:	c3                   	ret    
  40a9b2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	*i = (struct kv_iter){
  40a9b8:	48 c7 46 08 00 00 00 	mov    QWORD PTR [rsi+0x8],0x0
  40a9bf:	00 
	if (i->start->vtype != VTYPE_ARR) return 0;
  40a9c0:	31 c0                	xor    eax,eax
	*i = (struct kv_iter){
  40a9c2:	48 c7 46 10 00 00 00 	mov    QWORD PTR [rsi+0x10],0x0
  40a9c9:	00 
	if (i->start->vtype != VTYPE_ARR) return 0;
  40a9ca:	c3                   	ret    
  40a9cb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  40a9d0:	31 c0                	xor    eax,eax
  40a9d2:	eb bc                	jmp    40a990 <args_iter.part.0.isra.0+0x50>
  40a9d4:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a9db:	00 00 00 00 
  40a9df:	90                   	nop

000000000040a9e0 <args_key>:
{
  40a9e0:	f3 0f 1e fa          	endbr64 
  40a9e4:	55                   	push   rbp
  40a9e5:	48 89 e5             	mov    rbp,rsp
  40a9e8:	41 55                	push   r13
  40a9ea:	49 89 f5             	mov    r13,rsi
  40a9ed:	41 54                	push   r12
	switch (arg->type) {
  40a9ef:	8b 07                	mov    eax,DWORD PTR [rdi]
  40a9f1:	85 c0                	test   eax,eax
  40a9f3:	74 1b                	je     40aa10 <args_key+0x30>
  40a9f5:	45 31 e4             	xor    r12d,r12d
  40a9f8:	83 f8 01             	cmp    eax,0x1
  40a9fb:	75 2c                	jne    40aa29 <args_key+0x49>
}
  40a9fd:	41 5c                	pop    r12
	case ARGS_IMPL_TAR: return tar_key(&arg->d.tar_ent, arg_len);
  40a9ff:	48 83 c7 08          	add    rdi,0x8
}
  40aa03:	41 5d                	pop    r13
  40aa05:	5d                   	pop    rbp
	case ARGS_IMPL_TAR: return tar_key(&arg->d.tar_ent, arg_len);
  40aa06:	e9 a5 07 00 00       	jmp    40b1b0 <tar_key>
  40aa0b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40aa10:	4c 8b 67 08          	mov    r12,QWORD PTR [rdi+0x8]
	if (!kv) return NULL;
  40aa14:	4d 85 e4             	test   r12,r12
  40aa17:	74 10                	je     40aa29 <args_key+0x49>
	*key_len = strlen(kv->key);
  40aa19:	4d 8b 24 24          	mov    r12,QWORD PTR [r12]
  40aa1d:	4c 89 e7             	mov    rdi,r12
  40aa20:	e8 4b ad 00 00       	call   415770 <strlen>
  40aa25:	41 89 45 00          	mov    DWORD PTR [r13+0x0],eax
}
  40aa29:	4c 89 e0             	mov    rax,r12
  40aa2c:	41 5c                	pop    r12
  40aa2e:	41 5d                	pop    r13
  40aa30:	5d                   	pop    rbp
  40aa31:	c3                   	ret    
  40aa32:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40aa39:	00 00 00 00 
  40aa3d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040aa40 <args_value>:
{
  40aa40:	f3 0f 1e fa          	endbr64 
	switch (arg->type) {
  40aa44:	8b 07                	mov    eax,DWORD PTR [rdi]
  40aa46:	85 c0                	test   eax,eax
  40aa48:	74 1e                	je     40aa68 <args_value+0x28>
  40aa4a:	83 f8 01             	cmp    eax,0x1
  40aa4d:	75 11                	jne    40aa60 <args_value+0x20>
	case ARGS_IMPL_TAR: return tar_value(&arg->d.tar_ent);
  40aa4f:	48 83 c7 08          	add    rdi,0x8
  40aa53:	e9 08 08 00 00       	jmp    40b260 <tar_value>
  40aa58:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40aa5f:	00 
	if (!kv) return NULL;
  40aa60:	31 c0                	xor    eax,eax
}
  40aa62:	c3                   	ret    
  40aa63:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40aa68:	48 8b 47 08          	mov    rax,QWORD PTR [rdi+0x8]
	if (!kv) return NULL;
  40aa6c:	48 85 c0             	test   rax,rax
  40aa6f:	74 f1                	je     40aa62 <args_value+0x22>
	switch (kv->vtype) {
  40aa71:	8b 50 08             	mov    edx,DWORD PTR [rax+0x8]
  40aa74:	85 d2                	test   edx,edx
  40aa76:	75 e8                	jne    40aa60 <args_value+0x20>
	case VTYPE_STR: return kv->val.str;
  40aa78:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
  40aa7c:	c3                   	ret    
  40aa7d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040aa80 <args_len>:
{
  40aa80:	f3 0f 1e fa          	endbr64 
	switch (arg->type) {
  40aa84:	8b 07                	mov    eax,DWORD PTR [rdi]
  40aa86:	85 c0                	test   eax,eax
  40aa88:	74 1e                	je     40aaa8 <args_len+0x28>
  40aa8a:	83 f8 01             	cmp    eax,0x1
  40aa8d:	75 11                	jne    40aaa0 <args_len+0x20>
	case ARGS_IMPL_TAR: return tar_len(&arg->d.tar_ent);
  40aa8f:	48 83 c7 08          	add    rdi,0x8
  40aa93:	e9 b8 0c 00 00       	jmp    40b750 <tar_len>
  40aa98:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40aa9f:	00 
	if (!kv) return 0;
  40aaa0:	31 c0                	xor    eax,eax
}
  40aaa2:	c3                   	ret    
  40aaa3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	case ARGS_IMPL_KV:  return kv_len(arg->d.kv_ent);
  40aaa8:	48 8b 57 08          	mov    rdx,QWORD PTR [rdi+0x8]
	if (!kv) return 0;
  40aaac:	48 85 d2             	test   rdx,rdx
  40aaaf:	74 ef                	je     40aaa0 <args_len+0x20>
	switch (kv->vtype) {
  40aab1:	8b 4a 08             	mov    ecx,DWORD PTR [rdx+0x8]
  40aab4:	b8 01 00 00 00       	mov    eax,0x1
  40aab9:	85 c9                	test   ecx,ecx
  40aabb:	74 e5                	je     40aaa2 <args_len+0x22>
	default:        return 0;
  40aabd:	31 c0                	xor    eax,eax
	switch (kv->vtype) {
  40aabf:	83 f9 01             	cmp    ecx,0x1
  40aac2:	75 de                	jne    40aaa2 <args_len+0x22>
	case VTYPE_ARR: return kv->val.arr.sz;
  40aac4:	8b 42 10             	mov    eax,DWORD PTR [rdx+0x10]
  40aac7:	c3                   	ret    
  40aac8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40aacf:	00 

000000000040aad0 <args_iter_next>:
{
  40aad0:	f3 0f 1e fa          	endbr64 
	arg->type = i->type;
  40aad4:	8b 07                	mov    eax,DWORD PTR [rdi]
  40aad6:	89 06                	mov    DWORD PTR [rsi],eax
	switch (i->type) {
  40aad8:	85 c0                	test   eax,eax
  40aada:	74 1c                	je     40aaf8 <args_iter_next+0x28>
  40aadc:	83 f8 01             	cmp    eax,0x1
  40aadf:	75 0f                	jne    40aaf0 <args_iter_next+0x20>
	case ARGS_IMPL_TAR: return tar_iter_next(&i->i.tar_i, &arg->d.tar_ent);
  40aae1:	48 83 c6 08          	add    rsi,0x8
  40aae5:	48 83 c7 08          	add    rdi,0x8
  40aae9:	e9 f2 08 00 00       	jmp    40b3e0 <tar_iter_next>
  40aaee:	66 90                	xchg   ax,ax
	switch (i->type) {
  40aaf0:	31 c0                	xor    eax,eax
  40aaf2:	c3                   	ret    
  40aaf3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	if (i->start->vtype != VTYPE_ARR) return 0;
  40aaf8:	48 8b 4f 08          	mov    rcx,QWORD PTR [rdi+0x8]
  40aafc:	31 c0                	xor    eax,eax
  40aafe:	83 79 08 01          	cmp    DWORD PTR [rcx+0x8],0x1
  40ab02:	75 2c                	jne    40ab30 <args_iter_next+0x60>
	if (i->curr == i->len) return 0;
  40ab04:	48 63 57 10          	movsxd rdx,DWORD PTR [rdi+0x10]
  40ab08:	3b 57 14             	cmp    edx,DWORD PTR [rdi+0x14]
  40ab0b:	74 23                	je     40ab30 <args_iter_next+0x60>
	*ent = __kv_index(i->start, i->curr++);
  40ab0d:	8d 42 01             	lea    eax,[rdx+0x1]
  40ab10:	89 47 10             	mov    DWORD PTR [rdi+0x10],eax
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  40ab13:	3b 51 10             	cmp    edx,DWORD PTR [rcx+0x10]
  40ab16:	7d 20                	jge    40ab38 <args_iter_next+0x68>
  40ab18:	85 d2                	test   edx,edx
  40ab1a:	78 1c                	js     40ab38 <args_iter_next+0x68>
	return kv->val.arr.kvs[idx];
  40ab1c:	48 8b 41 18          	mov    rax,QWORD PTR [rcx+0x18]
  40ab20:	48 8b 04 d0          	mov    rax,QWORD PTR [rax+rdx*8]
	*ent = __kv_index(i->start, i->curr++);
  40ab24:	48 89 46 08          	mov    QWORD PTR [rsi+0x8],rax
	return 1;
  40ab28:	b8 01 00 00 00       	mov    eax,0x1
  40ab2d:	c3                   	ret    
  40ab2e:	66 90                	xchg   ax,ax
}
  40ab30:	c3                   	ret    
  40ab31:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  40ab38:	31 c0                	xor    eax,eax
  40ab3a:	eb e8                	jmp    40ab24 <args_iter_next+0x54>
  40ab3c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000040ab40 <args_iter>:
{
  40ab40:	f3 0f 1e fa          	endbr64 
	i->type = ent->type = arg->type;
  40ab44:	8b 07                	mov    eax,DWORD PTR [rdi]
  40ab46:	89 02                	mov    DWORD PTR [rdx],eax
  40ab48:	89 06                	mov    DWORD PTR [rsi],eax
	switch (arg->type) {
  40ab4a:	85 c0                	test   eax,eax
  40ab4c:	74 32                	je     40ab80 <args_iter+0x40>
  40ab4e:	83 f8 01             	cmp    eax,0x1
  40ab51:	75 25                	jne    40ab78 <args_iter+0x38>
	case ARGS_IMPL_TAR: return tar_iter(&arg->d.tar_ent, &i->i.tar_i, &ent->d.tar_ent);
  40ab53:	48 83 c2 08          	add    rdx,0x8
  40ab57:	48 83 c6 08          	add    rsi,0x8
  40ab5b:	48 83 c7 08          	add    rdi,0x8
  40ab5f:	e9 7c 0b 00 00       	jmp    40b6e0 <tar_iter>
  40ab64:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	*i = (struct kv_iter){
  40ab68:	48 c7 46 08 00 00 00 	mov    QWORD PTR [rsi+0x8],0x0
  40ab6f:	00 
  40ab70:	48 c7 46 10 00 00 00 	mov    QWORD PTR [rsi+0x10],0x0
  40ab77:	00 
	if (i->start->vtype != VTYPE_ARR) return 0;
  40ab78:	31 c0                	xor    eax,eax
  40ab7a:	c3                   	ret    
  40ab7b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40ab80:	48 8b 4f 08          	mov    rcx,QWORD PTR [rdi+0x8]
	if (!kv) return 0;
  40ab84:	48 85 c9             	test   rcx,rcx
  40ab87:	74 df                	je     40ab68 <args_iter+0x28>
	switch (kv->vtype) {
  40ab89:	8b 41 08             	mov    eax,DWORD PTR [rcx+0x8]
  40ab8c:	85 c0                	test   eax,eax
  40ab8e:	74 30                	je     40abc0 <args_iter+0x80>
  40ab90:	83 f8 01             	cmp    eax,0x1
  40ab93:	74 13                	je     40aba8 <args_iter+0x68>
	*i = (struct kv_iter){
  40ab95:	48 89 4e 08          	mov    QWORD PTR [rsi+0x8],rcx
	if (i->start->vtype != VTYPE_ARR) return 0;
  40ab99:	31 c0                	xor    eax,eax
	*i = (struct kv_iter){
  40ab9b:	48 c7 46 10 00 00 00 	mov    QWORD PTR [rsi+0x10],0x0
  40aba2:	00 
	if (i->start->vtype != VTYPE_ARR) return 0;
  40aba3:	c3                   	ret    
  40aba4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	case VTYPE_ARR: return kv->val.arr.sz;
  40aba8:	8b 41 10             	mov    eax,DWORD PTR [rcx+0x10]
	*i = (struct kv_iter){
  40abab:	48 89 4e 08          	mov    QWORD PTR [rsi+0x8],rcx
  40abaf:	c7 46 10 00 00 00 00 	mov    DWORD PTR [rsi+0x10],0x0
  40abb6:	89 46 14             	mov    DWORD PTR [rsi+0x14],eax
	if (i->curr == i->len) return 0;
  40abb9:	85 c0                	test   eax,eax
  40abbb:	75 1b                	jne    40abd8 <args_iter+0x98>
}
  40abbd:	c3                   	ret    
  40abbe:	66 90                	xchg   ax,ax
	*i = (struct kv_iter){
  40abc0:	48 8b 05 31 16 01 00 	mov    rax,QWORD PTR [rip+0x11631]        # 41c1f8 <__unlock+0x11c8>
  40abc7:	48 89 4e 08          	mov    QWORD PTR [rsi+0x8],rcx
  40abcb:	48 89 46 10          	mov    QWORD PTR [rsi+0x10],rax
	if (i->start->vtype != VTYPE_ARR) return 0;
  40abcf:	31 c0                	xor    eax,eax
  40abd1:	c3                   	ret    
  40abd2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	*ent = __kv_index(i->start, i->curr++);
  40abd8:	c7 46 10 01 00 00 00 	mov    DWORD PTR [rsi+0x10],0x1
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  40abdf:	7e 17                	jle    40abf8 <args_iter+0xb8>
	return kv->val.arr.kvs[idx];
  40abe1:	48 8b 41 18          	mov    rax,QWORD PTR [rcx+0x18]
  40abe5:	48 8b 00             	mov    rax,QWORD PTR [rax]
	*ent = __kv_index(i->start, i->curr++);
  40abe8:	48 89 42 08          	mov    QWORD PTR [rdx+0x8],rax
	return 1;
  40abec:	b8 01 00 00 00       	mov    eax,0x1
  40abf1:	c3                   	ret    
  40abf2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  40abf8:	31 c0                	xor    eax,eax
  40abfa:	eb ec                	jmp    40abe8 <args_iter+0xa8>
  40abfc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000040ac00 <args_foreach>:

typedef void (*args_visitor_fn_t)(struct initargs *ent, void *data);

int
args_foreach(struct initargs *ent, args_visitor_fn_t fn, void *data)
{
  40ac00:	f3 0f 1e fa          	endbr64 
	struct initargs_iter i;
	struct initargs curr;
	int cont;

	if (!ent) return -1;
  40ac04:	48 85 ff             	test   rdi,rdi
  40ac07:	0f 84 d7 00 00 00    	je     40ace4 <args_foreach+0xe4>
{
  40ac0d:	55                   	push   rbp
  40ac0e:	48 89 e5             	mov    rbp,rsp
  40ac11:	41 55                	push   r13
  40ac13:	41 54                	push   r12
  40ac15:	49 89 d4             	mov    r12,rdx
  40ac18:	53                   	push   rbx
  40ac19:	48 89 f3             	mov    rbx,rsi
  40ac1c:	48 83 ec 48          	sub    rsp,0x48
	i->type = ent->type = arg->type;
  40ac20:	8b 07                	mov    eax,DWORD PTR [rdi]
  40ac22:	89 45 a0             	mov    DWORD PTR [rbp-0x60],eax
  40ac25:	89 45 c0             	mov    DWORD PTR [rbp-0x40],eax
	switch (arg->type) {
  40ac28:	85 c0                	test   eax,eax
  40ac2a:	0f 84 90 00 00 00    	je     40acc0 <args_foreach+0xc0>
  40ac30:	83 f8 01             	cmp    eax,0x1
  40ac33:	75 43                	jne    40ac78 <args_foreach+0x78>
	case ARGS_IMPL_TAR: return tar_iter(&arg->d.tar_ent, &i->i.tar_i, &ent->d.tar_ent);
  40ac35:	48 83 c7 08          	add    rdi,0x8
  40ac39:	48 8d 55 a8          	lea    rdx,[rbp-0x58]
  40ac3d:	48 8d 75 c8          	lea    rsi,[rbp-0x38]
  40ac41:	e8 9a 0a 00 00       	call   40b6e0 <tar_iter>
	for (cont = args_iter(ent, &i, &curr); cont; cont = args_iter_next(&i, &curr)) {
  40ac46:	85 c0                	test   eax,eax
  40ac48:	74 2e                	je     40ac78 <args_foreach+0x78>
  40ac4a:	4c 8d 6d a0          	lea    r13,[rbp-0x60]
  40ac4e:	66 90                	xchg   ax,ax
		fn(&curr, data);
  40ac50:	4c 89 e6             	mov    rsi,r12
  40ac53:	4c 89 ef             	mov    rdi,r13
  40ac56:	ff d3                	call   rbx
	arg->type = i->type;
  40ac58:	8b 45 c0             	mov    eax,DWORD PTR [rbp-0x40]
  40ac5b:	89 45 a0             	mov    DWORD PTR [rbp-0x60],eax
	switch (i->type) {
  40ac5e:	85 c0                	test   eax,eax
  40ac60:	74 26                	je     40ac88 <args_foreach+0x88>
  40ac62:	83 f8 01             	cmp    eax,0x1
  40ac65:	75 11                	jne    40ac78 <args_foreach+0x78>
	case ARGS_IMPL_TAR: return tar_iter_next(&i->i.tar_i, &arg->d.tar_ent);
  40ac67:	48 8d 75 a8          	lea    rsi,[rbp-0x58]
  40ac6b:	48 8d 7d c8          	lea    rdi,[rbp-0x38]
  40ac6f:	e8 6c 07 00 00       	call   40b3e0 <tar_iter_next>
	for (cont = args_iter(ent, &i, &curr); cont; cont = args_iter_next(&i, &curr)) {
  40ac74:	85 c0                	test   eax,eax
  40ac76:	75 d8                	jne    40ac50 <args_foreach+0x50>
	}

	return 0;
}
  40ac78:	48 83 c4 48          	add    rsp,0x48
	return 0;
  40ac7c:	31 c0                	xor    eax,eax
}
  40ac7e:	5b                   	pop    rbx
  40ac7f:	41 5c                	pop    r12
  40ac81:	41 5d                	pop    r13
  40ac83:	5d                   	pop    rbp
  40ac84:	c3                   	ret    
  40ac85:	0f 1f 00             	nop    DWORD PTR [rax]
	if (i->start->vtype != VTYPE_ARR) return 0;
  40ac88:	48 8b 55 c8          	mov    rdx,QWORD PTR [rbp-0x38]
  40ac8c:	83 7a 08 01          	cmp    DWORD PTR [rdx+0x8],0x1
  40ac90:	75 e6                	jne    40ac78 <args_foreach+0x78>
	if (i->curr == i->len) return 0;
  40ac92:	48 63 45 d0          	movsxd rax,DWORD PTR [rbp-0x30]
  40ac96:	3b 45 d4             	cmp    eax,DWORD PTR [rbp-0x2c]
  40ac99:	74 dd                	je     40ac78 <args_foreach+0x78>
	*ent = __kv_index(i->start, i->curr++);
  40ac9b:	8d 48 01             	lea    ecx,[rax+0x1]
  40ac9e:	89 4d d0             	mov    DWORD PTR [rbp-0x30],ecx
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  40aca1:	3b 42 10             	cmp    eax,DWORD PTR [rdx+0x10]
  40aca4:	7d 3a                	jge    40ace0 <args_foreach+0xe0>
  40aca6:	85 c0                	test   eax,eax
  40aca8:	78 36                	js     40ace0 <args_foreach+0xe0>
	return kv->val.arr.kvs[idx];
  40acaa:	48 8b 52 18          	mov    rdx,QWORD PTR [rdx+0x18]
  40acae:	48 8b 04 c2          	mov    rax,QWORD PTR [rdx+rax*8]
	*ent = __kv_index(i->start, i->curr++);
  40acb2:	48 89 45 a8          	mov    QWORD PTR [rbp-0x58],rax
	for (cont = args_iter(ent, &i, &curr); cont; cont = args_iter_next(&i, &curr)) {
  40acb6:	eb 98                	jmp    40ac50 <args_foreach+0x50>
  40acb8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40acbf:	00 
  40acc0:	4c 8d 6d a0          	lea    r13,[rbp-0x60]
  40acc4:	48 8b 7f 08          	mov    rdi,QWORD PTR [rdi+0x8]
  40acc8:	48 8d 75 c0          	lea    rsi,[rbp-0x40]
  40accc:	4c 89 ea             	mov    rdx,r13
  40accf:	e8 6c fc ff ff       	call   40a940 <args_iter.part.0.isra.0>
  40acd4:	e9 6d ff ff ff       	jmp    40ac46 <args_foreach+0x46>
  40acd9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  40ace0:	31 c0                	xor    eax,eax
  40ace2:	eb ce                	jmp    40acb2 <args_foreach+0xb2>
	if (!ent) return -1;
  40ace4:	b8 ff ff ff ff       	mov    eax,0xffffffff
}
  40ace9:	c3                   	ret    
  40acea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000040acf0 <args_lkup_entry>:
 * not including a '/').  This enables this function to be used to
 * walk through the data-structure guided by a path through the k/v.
 */
int
args_lkup_entry(struct initargs *arg, char *path, struct initargs *ret)
{
  40acf0:	f3 0f 1e fa          	endbr64 
  40acf4:	55                   	push   rbp
  40acf5:	48 89 e5             	mov    rbp,rsp
  40acf8:	41 57                	push   r15
  40acfa:	41 56                	push   r14
  40acfc:	41 55                	push   r13
  40acfe:	41 54                	push   r12
  40ad00:	53                   	push   rbx
  40ad01:	48 81 ec 88 00 00 00 	sub    rsp,0x88
	struct initargs_iter i;
	struct initargs curr, start;
	unsigned int len, cont;
	char *slash, *key = path;

	if (!arg || !key || !ret) return -1;
  40ad08:	48 85 ff             	test   rdi,rdi
{
  40ad0b:	48 89 95 58 ff ff ff 	mov    QWORD PTR [rbp-0xa8],rdx
	if (!arg || !key || !ret) return -1;
  40ad12:	0f 94 c0             	sete   al
  40ad15:	48 85 d2             	test   rdx,rdx
  40ad18:	0f 94 c2             	sete   dl
  40ad1b:	08 d0                	or     al,dl
  40ad1d:	0f 85 4d 01 00 00    	jne    40ae70 <args_lkup_entry+0x180>
  40ad23:	49 89 f4             	mov    r12,rsi
  40ad26:	48 85 f6             	test   rsi,rsi
  40ad29:	0f 84 41 01 00 00    	je     40ae70 <args_lkup_entry+0x180>
	start = *arg;
  40ad2f:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  40ad33:	f3 0f 6f 07          	movdqu xmm0,XMMWORD PTR [rdi]
  40ad37:	48 89 45 a0          	mov    QWORD PTR [rbp-0x60],rax
  40ad3b:	0f 29 45 90          	movaps XMMWORD PTR [rbp-0x70],xmm0
	/* Iterate through the path... */
	do {
		int found = 0;

		slash = strchr(key, '/');
  40ad3f:	be 2f 00 00 00       	mov    esi,0x2f
  40ad44:	4c 89 e7             	mov    rdi,r12
  40ad47:	e8 d4 a8 00 00       	call   415620 <strchr>
  40ad4c:	49 89 c5             	mov    r13,rax
		len = slash ? (unsigned int)(slash - key) : strlen(key);
  40ad4f:	48 85 c0             	test   rax,rax
  40ad52:	0f 84 d8 01 00 00    	je     40af30 <args_lkup_entry+0x240>
  40ad58:	89 c3                	mov    ebx,eax
  40ad5a:	44 29 e3             	sub    ebx,r12d
	i->type = ent->type = arg->type;
  40ad5d:	8b 45 90             	mov    eax,DWORD PTR [rbp-0x70]
  40ad60:	89 85 70 ff ff ff    	mov    DWORD PTR [rbp-0x90],eax
  40ad66:	89 45 b0             	mov    DWORD PTR [rbp-0x50],eax
	switch (arg->type) {
  40ad69:	85 c0                	test   eax,eax
  40ad6b:	0f 84 4f 01 00 00    	je     40aec0 <args_lkup_entry+0x1d0>
  40ad71:	83 f8 01             	cmp    eax,0x1
  40ad74:	0f 85 f6 00 00 00    	jne    40ae70 <args_lkup_entry+0x180>
	case ARGS_IMPL_TAR: return tar_iter(&arg->d.tar_ent, &i->i.tar_i, &ent->d.tar_ent);
  40ad7a:	48 8d 95 78 ff ff ff 	lea    rdx,[rbp-0x88]
  40ad81:	48 8d 75 b8          	lea    rsi,[rbp-0x48]
  40ad85:	48 8d 7d 98          	lea    rdi,[rbp-0x68]
  40ad89:	e8 52 09 00 00       	call   40b6e0 <tar_iter>

		/* ...and look the key up in the KV */
		for (cont = args_iter(&start, &i, &curr) ; cont ; cont = args_iter_next(&i, &curr)) {
  40ad8e:	85 c0                	test   eax,eax
  40ad90:	0f 84 da 00 00 00    	je     40ae70 <args_lkup_entry+0x180>
  40ad96:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40ad9d:	00 00 00 
	switch (arg->type) {
  40ada0:	8b 85 70 ff ff ff    	mov    eax,DWORD PTR [rbp-0x90]
  40ada6:	85 c0                	test   eax,eax
  40ada8:	74 79                	je     40ae23 <args_lkup_entry+0x133>
  40adaa:	83 f8 01             	cmp    eax,0x1
  40adad:	0f 84 dd 00 00 00    	je     40ae90 <args_lkup_entry+0x1a0>
			int key_len;
			char *k = args_key(&curr, &key_len);

			if ((unsigned int)key_len == len && strncmp(k, key, len) == 0) {
  40adb3:	8b 95 6c ff ff ff    	mov    edx,DWORD PTR [rbp-0x94]
	default:            return NULL;
  40adb9:	45 31 f6             	xor    r14d,r14d
			if ((unsigned int)key_len == len && strncmp(k, key, len) == 0) {
  40adbc:	39 da                	cmp    edx,ebx
  40adbe:	75 19                	jne    40add9 <args_lkup_entry+0xe9>
  40adc0:	41 89 d7             	mov    r15d,edx
  40adc3:	4c 89 e6             	mov    rsi,r12
  40adc6:	4c 89 f7             	mov    rdi,r14
  40adc9:	4c 89 fa             	mov    rdx,r15
  40adcc:	e8 1f aa 00 00       	call   4157f0 <strncmp>
  40add1:	85 c0                	test   eax,eax
  40add3:	0f 84 07 01 00 00    	je     40aee0 <args_lkup_entry+0x1f0>
	arg->type = i->type;
  40add9:	8b 45 b0             	mov    eax,DWORD PTR [rbp-0x50]
  40addc:	89 85 70 ff ff ff    	mov    DWORD PTR [rbp-0x90],eax
	switch (i->type) {
  40ade2:	85 c0                	test   eax,eax
  40ade4:	75 6a                	jne    40ae50 <args_lkup_entry+0x160>
	if (i->start->vtype != VTYPE_ARR) return 0;
  40ade6:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
  40adea:	83 7a 08 01          	cmp    DWORD PTR [rdx+0x8],0x1
  40adee:	0f 85 7c 00 00 00    	jne    40ae70 <args_lkup_entry+0x180>
	if (i->curr == i->len) return 0;
  40adf4:	48 63 45 c0          	movsxd rax,DWORD PTR [rbp-0x40]
  40adf8:	3b 45 c4             	cmp    eax,DWORD PTR [rbp-0x3c]
  40adfb:	74 73                	je     40ae70 <args_lkup_entry+0x180>
	*ent = __kv_index(i->start, i->curr++);
  40adfd:	8d 48 01             	lea    ecx,[rax+0x1]
  40ae00:	89 4d c0             	mov    DWORD PTR [rbp-0x40],ecx
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  40ae03:	3b 42 10             	cmp    eax,DWORD PTR [rdx+0x10]
  40ae06:	0f 8d ac 00 00 00    	jge    40aeb8 <args_lkup_entry+0x1c8>
  40ae0c:	85 c0                	test   eax,eax
  40ae0e:	0f 88 a4 00 00 00    	js     40aeb8 <args_lkup_entry+0x1c8>
	return kv->val.arr.kvs[idx];
  40ae14:	48 8b 52 18          	mov    rdx,QWORD PTR [rdx+0x18]
  40ae18:	48 8b 04 c2          	mov    rax,QWORD PTR [rdx+rax*8]
	*ent = __kv_index(i->start, i->curr++);
  40ae1c:	48 89 85 78 ff ff ff 	mov    QWORD PTR [rbp-0x88],rax
	switch (arg->type) {
  40ae23:	4c 8b b5 78 ff ff ff 	mov    r14,QWORD PTR [rbp-0x88]
	if (!kv) return NULL;
  40ae2a:	4d 85 f6             	test   r14,r14
  40ae2d:	74 77                	je     40aea6 <args_lkup_entry+0x1b6>
	*key_len = strlen(kv->key);
  40ae2f:	4d 8b 36             	mov    r14,QWORD PTR [r14]
  40ae32:	4c 89 f7             	mov    rdi,r14
  40ae35:	e8 36 a9 00 00       	call   415770 <strlen>
  40ae3a:	89 c2                	mov    edx,eax
  40ae3c:	89 85 6c ff ff ff    	mov    DWORD PTR [rbp-0x94],eax
			if ((unsigned int)key_len == len && strncmp(k, key, len) == 0) {
  40ae42:	39 da                	cmp    edx,ebx
  40ae44:	0f 84 76 ff ff ff    	je     40adc0 <args_lkup_entry+0xd0>
  40ae4a:	eb 8d                	jmp    40add9 <args_lkup_entry+0xe9>
  40ae4c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	switch (i->type) {
  40ae50:	83 f8 01             	cmp    eax,0x1
  40ae53:	75 1b                	jne    40ae70 <args_lkup_entry+0x180>
	case ARGS_IMPL_TAR: return tar_iter_next(&i->i.tar_i, &arg->d.tar_ent);
  40ae55:	48 8d b5 78 ff ff ff 	lea    rsi,[rbp-0x88]
  40ae5c:	48 8d 7d b8          	lea    rdi,[rbp-0x48]
  40ae60:	e8 7b 05 00 00       	call   40b3e0 <tar_iter_next>
		for (cont = args_iter(&start, &i, &curr) ; cont ; cont = args_iter_next(&i, &curr)) {
  40ae65:	85 c0                	test   eax,eax
  40ae67:	0f 85 33 ff ff ff    	jne    40ada0 <args_lkup_entry+0xb0>
  40ae6d:	0f 1f 00             	nop    DWORD PTR [rax]
				start = curr;
				found = 1;
				break;
			}
		}
		if (!found) return -1;
  40ae70:	41 b8 ff ff ff ff    	mov    r8d,0xffffffff

		if (slash) key = slash + 1;
	} while (slash && *key != '\0');

	return -1;
}
  40ae76:	48 81 c4 88 00 00 00 	add    rsp,0x88
  40ae7d:	44 89 c0             	mov    eax,r8d
  40ae80:	5b                   	pop    rbx
  40ae81:	41 5c                	pop    r12
  40ae83:	41 5d                	pop    r13
  40ae85:	41 5e                	pop    r14
  40ae87:	41 5f                	pop    r15
  40ae89:	5d                   	pop    rbp
  40ae8a:	c3                   	ret    
  40ae8b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	case ARGS_IMPL_TAR: return tar_key(&arg->d.tar_ent, arg_len);
  40ae90:	48 8d b5 6c ff ff ff 	lea    rsi,[rbp-0x94]
  40ae97:	48 8d bd 78 ff ff ff 	lea    rdi,[rbp-0x88]
  40ae9e:	e8 0d 03 00 00       	call   40b1b0 <tar_key>
  40aea3:	49 89 c6             	mov    r14,rax
			if ((unsigned int)key_len == len && strncmp(k, key, len) == 0) {
  40aea6:	8b 95 6c ff ff ff    	mov    edx,DWORD PTR [rbp-0x94]
	case ARGS_IMPL_TAR: return tar_key(&arg->d.tar_ent, arg_len);
  40aeac:	e9 0b ff ff ff       	jmp    40adbc <args_lkup_entry+0xcc>
  40aeb1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  40aeb8:	31 c0                	xor    eax,eax
  40aeba:	e9 5d ff ff ff       	jmp    40ae1c <args_lkup_entry+0x12c>
  40aebf:	90                   	nop
  40aec0:	48 8b 7d 98          	mov    rdi,QWORD PTR [rbp-0x68]
  40aec4:	48 8d 95 70 ff ff ff 	lea    rdx,[rbp-0x90]
  40aecb:	48 8d 75 b0          	lea    rsi,[rbp-0x50]
  40aecf:	e8 6c fa ff ff       	call   40a940 <args_iter.part.0.isra.0>
  40aed4:	e9 b5 fe ff ff       	jmp    40ad8e <args_lkup_entry+0x9e>
  40aed9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
				if (strlen(key) == len) {
  40aee0:	4c 89 e7             	mov    rdi,r12
  40aee3:	89 85 54 ff ff ff    	mov    DWORD PTR [rbp-0xac],eax
  40aee9:	e8 82 a8 00 00       	call   415770 <strlen>
  40aeee:	44 8b 85 54 ff ff ff 	mov    r8d,DWORD PTR [rbp-0xac]
  40aef5:	49 39 c7             	cmp    r15,rax
  40aef8:	74 45                	je     40af3f <args_lkup_entry+0x24f>
				start = curr;
  40aefa:	66 0f 6f 8d 70 ff ff 	movdqa xmm1,XMMWORD PTR [rbp-0x90]
  40af01:	ff 
  40af02:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  40af06:	0f 29 4d 90          	movaps XMMWORD PTR [rbp-0x70],xmm1
  40af0a:	48 89 45 a0          	mov    QWORD PTR [rbp-0x60],rax
		if (slash) key = slash + 1;
  40af0e:	4d 85 ed             	test   r13,r13
  40af11:	0f 84 59 ff ff ff    	je     40ae70 <args_lkup_entry+0x180>
	} while (slash && *key != '\0');
  40af17:	41 80 7d 01 00       	cmp    BYTE PTR [r13+0x1],0x0
		if (slash) key = slash + 1;
  40af1c:	4d 8d 65 01          	lea    r12,[r13+0x1]
	} while (slash && *key != '\0');
  40af20:	0f 85 19 fe ff ff    	jne    40ad3f <args_lkup_entry+0x4f>
  40af26:	e9 45 ff ff ff       	jmp    40ae70 <args_lkup_entry+0x180>
  40af2b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		len = slash ? (unsigned int)(slash - key) : strlen(key);
  40af30:	4c 89 e7             	mov    rdi,r12
  40af33:	e8 38 a8 00 00       	call   415770 <strlen>
  40af38:	89 c3                	mov    ebx,eax
  40af3a:	e9 1e fe ff ff       	jmp    40ad5d <args_lkup_entry+0x6d>
					*ret = curr;
  40af3f:	48 8b 8d 58 ff ff ff 	mov    rcx,QWORD PTR [rbp-0xa8]
  40af46:	66 0f 6f 95 70 ff ff 	movdqa xmm2,XMMWORD PTR [rbp-0x90]
  40af4d:	ff 
  40af4e:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  40af52:	0f 11 11             	movups XMMWORD PTR [rcx],xmm2
  40af55:	48 89 41 10          	mov    QWORD PTR [rcx+0x10],rax
					return 0;
  40af59:	e9 18 ff ff ff       	jmp    40ae76 <args_lkup_entry+0x186>
  40af5e:	66 90                	xchg   ax,ax

000000000040af60 <args_type>:

args_type_t
args_type(struct initargs *ent)
{
  40af60:	f3 0f 1e fa          	endbr64 
  40af64:	55                   	push   rbp
  40af65:	48 89 e5             	mov    rbp,rsp
  40af68:	41 54                	push   r12
  40af6a:	48 83 ec 08          	sub    rsp,0x8
	switch (ent->type) {
  40af6e:	44 8b 27             	mov    r12d,DWORD PTR [rdi]
  40af71:	45 85 e4             	test   r12d,r12d
  40af74:	74 3a                	je     40afb0 <args_type+0x50>
  40af76:	41 83 fc 01          	cmp    r12d,0x1
  40af7a:	75 24                	jne    40afa0 <args_type+0x40>
	case ARGS_IMPL_KV:  return kv_type(ent->d.kv_ent);
	case ARGS_IMPL_TAR: return tar_is_value(&ent->d.tar_ent) ? ARGS_VAL : ARGS_MAP;
  40af7c:	48 83 c7 08          	add    rdi,0x8
  40af80:	e8 fb 03 00 00       	call   40b380 <tar_is_value>
  40af85:	85 c0                	test   eax,eax
  40af87:	b8 02 00 00 00       	mov    eax,0x2
  40af8c:	44 0f 45 e0          	cmovne r12d,eax
	default:            return ARGS_ERR;
	}
}
  40af90:	44 89 e0             	mov    eax,r12d
  40af93:	4c 8b 65 f8          	mov    r12,QWORD PTR [rbp-0x8]
  40af97:	c9                   	leave  
  40af98:	c3                   	ret    
  40af99:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	switch (ent->type) {
  40afa0:	45 31 e4             	xor    r12d,r12d
}
  40afa3:	44 89 e0             	mov    eax,r12d
  40afa6:	4c 8b 65 f8          	mov    r12,QWORD PTR [rbp-0x8]
  40afaa:	c9                   	leave  
  40afab:	c3                   	ret    
  40afac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	switch (kv->vtype) {
  40afb0:	48 8b 47 08          	mov    rax,QWORD PTR [rdi+0x8]
	case VTYPE_STR: return ARGS_VAL;
  40afb4:	41 bc 02 00 00 00    	mov    r12d,0x2
	switch (kv->vtype) {
  40afba:	8b 40 08             	mov    eax,DWORD PTR [rax+0x8]
  40afbd:	85 c0                	test   eax,eax
  40afbf:	74 cf                	je     40af90 <args_type+0x30>
  40afc1:	45 31 e4             	xor    r12d,r12d
  40afc4:	83 f8 01             	cmp    eax,0x1
  40afc7:	41 0f 94 c4          	sete   r12b
}
  40afcb:	44 89 e0             	mov    eax,r12d
  40afce:	4c 8b 65 f8          	mov    r12,QWORD PTR [rbp-0x8]
  40afd2:	c9                   	leave  
  40afd3:	c3                   	ret    
  40afd4:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40afdb:	00 00 00 00 
  40afdf:	90                   	nop

000000000040afe0 <args_get_entry_from>:

int
args_get_entry_from(char *path, struct initargs *from, struct initargs *ent)
{
  40afe0:	f3 0f 1e fa          	endbr64 
  40afe4:	49 89 f8             	mov    r8,rdi
  40afe7:	48 89 f7             	mov    rdi,rsi
	return args_lkup_entry(from, path, ent);
  40afea:	4c 89 c6             	mov    rsi,r8
  40afed:	e9 fe fc ff ff       	jmp    40acf0 <args_lkup_entry>
  40aff2:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40aff9:	00 00 00 00 
  40affd:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040b000 <args_get_from>:
}

char *
args_get_from(char *path, struct initargs *from)
{
  40b000:	f3 0f 1e fa          	endbr64 
  40b004:	55                   	push   rbp
  40b005:	49 89 f8             	mov    r8,rdi
  40b008:	48 89 f7             	mov    rdi,rsi
	return args_lkup_entry(from, path, ent);
  40b00b:	4c 89 c6             	mov    rsi,r8
{
  40b00e:	48 89 e5             	mov    rbp,rsp
  40b011:	48 83 ec 20          	sub    rsp,0x20
	return args_lkup_entry(from, path, ent);
  40b015:	48 8d 55 e0          	lea    rdx,[rbp-0x20]
  40b019:	e8 d2 fc ff ff       	call   40acf0 <args_lkup_entry>
  40b01e:	41 89 c0             	mov    r8d,eax
	struct initargs ent;

	if (args_get_entry_from(path, from, &ent)) return NULL;
  40b021:	31 c0                	xor    eax,eax
  40b023:	45 85 c0             	test   r8d,r8d
  40b026:	75 0c                	jne    40b034 <args_get_from+0x34>
	switch (arg->type) {
  40b028:	8b 55 e0             	mov    edx,DWORD PTR [rbp-0x20]
  40b02b:	85 d2                	test   edx,edx
  40b02d:	74 21                	je     40b050 <args_get_from+0x50>
  40b02f:	83 fa 01             	cmp    edx,0x1
  40b032:	74 0c                	je     40b040 <args_get_from+0x40>

	return args_value(&ent);
}
  40b034:	c9                   	leave  
  40b035:	c3                   	ret    
  40b036:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40b03d:	00 00 00 
	case ARGS_IMPL_TAR: return tar_value(&arg->d.tar_ent);
  40b040:	48 8d 7d e8          	lea    rdi,[rbp-0x18]
  40b044:	e8 17 02 00 00       	call   40b260 <tar_value>
}
  40b049:	c9                   	leave  
  40b04a:	c3                   	ret    
  40b04b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40b050:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
	if (!kv) return NULL;
  40b054:	48 85 c0             	test   rax,rax
  40b057:	74 db                	je     40b034 <args_get_from+0x34>
	switch (kv->vtype) {
  40b059:	8b 50 08             	mov    edx,DWORD PTR [rax+0x8]
  40b05c:	85 d2                	test   edx,edx
  40b05e:	75 10                	jne    40b070 <args_get_from+0x70>
	case VTYPE_STR: return kv->val.str;
  40b060:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
}
  40b064:	c9                   	leave  
  40b065:	c3                   	ret    
  40b066:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40b06d:	00 00 00 
  40b070:	c9                   	leave  
	if (args_get_entry_from(path, from, &ent)) return NULL;
  40b071:	31 c0                	xor    eax,eax
}
  40b073:	c3                   	ret    
  40b074:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40b07b:	00 00 00 00 
  40b07f:	90                   	nop

000000000040b080 <args_get_entry>:
 * structure, which is just a /-separated set of keys used to lookup
 * in the corresponding maps.
 */
int
args_get_entry(char *path, struct initargs *ent)
{
  40b080:	f3 0f 1e fa          	endbr64 
  40b084:	55                   	push   rbp
	return args_lkup_entry(from, path, ent);
  40b085:	48 89 f2             	mov    rdx,rsi
{
  40b088:	48 89 e5             	mov    rbp,rsp
  40b08b:	41 55                	push   r13
  40b08d:	49 89 f5             	mov    r13,rsi
	return args_lkup_entry(from, path, ent);
  40b090:	48 89 fe             	mov    rsi,rdi
{
  40b093:	41 54                	push   r12
  40b095:	49 89 fc             	mov    r12,rdi
	return args_lkup_entry(from, path, ent);
  40b098:	bf 20 40 42 00       	mov    edi,0x424020
{
  40b09d:	48 83 ec 20          	sub    rsp,0x20
	return args_lkup_entry(from, path, ent);
  40b0a1:	e8 4a fc ff ff       	call   40acf0 <args_lkup_entry>
	struct initargs tarroot;
	struct tar_entry *tarent;

	if (!args_get_entry_from(path, &__initargs_root, ent)) return 0;
  40b0a6:	85 c0                	test   eax,eax
  40b0a8:	75 0e                	jne    40b0b8 <args_get_entry+0x38>
		.type = ARGS_IMPL_TAR,
		.d.tar_ent = *tarent
	};

	return args_get_entry_from(path, &tarroot, ent);
}
  40b0aa:	48 83 c4 20          	add    rsp,0x20
  40b0ae:	41 5c                	pop    r12
  40b0b0:	41 5d                	pop    r13
  40b0b2:	5d                   	pop    rbp
  40b0b3:	c3                   	ret    
  40b0b4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	tarent = tar_root();
  40b0b8:	e8 33 07 00 00       	call   40b7f0 <tar_root>
	if (!tarent) return -1;
  40b0bd:	48 85 c0             	test   rax,rax
  40b0c0:	74 2d                	je     40b0ef <args_get_entry+0x6f>
		.d.tar_ent = *tarent
  40b0c2:	8b 10                	mov    edx,DWORD PTR [rax]
  40b0c4:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	return args_lkup_entry(from, path, ent);
  40b0c8:	4c 89 e6             	mov    rsi,r12
  40b0cb:	48 8d 7d d0          	lea    rdi,[rbp-0x30]
	tarroot = (struct initargs) {
  40b0cf:	c7 45 d0 01 00 00 00 	mov    DWORD PTR [rbp-0x30],0x1
  40b0d6:	89 55 d8             	mov    DWORD PTR [rbp-0x28],edx
	return args_lkup_entry(from, path, ent);
  40b0d9:	4c 89 ea             	mov    rdx,r13
	tarroot = (struct initargs) {
  40b0dc:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax
	return args_lkup_entry(from, path, ent);
  40b0e0:	e8 0b fc ff ff       	call   40acf0 <args_lkup_entry>
}
  40b0e5:	48 83 c4 20          	add    rsp,0x20
  40b0e9:	41 5c                	pop    r12
  40b0eb:	41 5d                	pop    r13
  40b0ed:	5d                   	pop    rbp
  40b0ee:	c3                   	ret    
	if (!tarent) return -1;
  40b0ef:	b8 ff ff ff ff       	mov    eax,0xffffffff
  40b0f4:	eb b4                	jmp    40b0aa <args_get_entry+0x2a>
  40b0f6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40b0fd:	00 00 00 

000000000040b100 <args_get>:

char *
args_get(char *path)
{
  40b100:	f3 0f 1e fa          	endbr64 
  40b104:	55                   	push   rbp
	return args_lkup_entry(from, path, ent);
  40b105:	48 89 fe             	mov    rsi,rdi
{
  40b108:	48 89 e5             	mov    rbp,rsp
  40b10b:	41 54                	push   r12
  40b10d:	49 89 fc             	mov    r12,rdi
	return args_lkup_entry(from, path, ent);
  40b110:	bf 20 40 42 00       	mov    edi,0x424020
  40b115:	48 8d 55 b0          	lea    rdx,[rbp-0x50]
{
  40b119:	48 83 ec 48          	sub    rsp,0x48
	return args_lkup_entry(from, path, ent);
  40b11d:	e8 ce fb ff ff       	call   40acf0 <args_lkup_entry>
	if (!args_get_entry_from(path, &__initargs_root, ent)) return 0;
  40b122:	85 c0                	test   eax,eax
  40b124:	75 4a                	jne    40b170 <args_get+0x70>
	switch (arg->type) {
  40b126:	8b 45 b0             	mov    eax,DWORD PTR [rbp-0x50]
  40b129:	85 c0                	test   eax,eax
  40b12b:	74 23                	je     40b150 <args_get+0x50>
  40b12d:	83 f8 01             	cmp    eax,0x1
  40b130:	74 0e                	je     40b140 <args_get+0x40>
	struct initargs ent;

	if (args_get_entry(path, &ent)) return NULL;
  40b132:	31 c0                	xor    eax,eax

	return args_value(&ent);
}
  40b134:	4c 8b 65 f8          	mov    r12,QWORD PTR [rbp-0x8]
  40b138:	c9                   	leave  
  40b139:	c3                   	ret    
  40b13a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	case ARGS_IMPL_TAR: return tar_value(&arg->d.tar_ent);
  40b140:	48 8d 7d b8          	lea    rdi,[rbp-0x48]
  40b144:	e8 17 01 00 00       	call   40b260 <tar_value>
}
  40b149:	4c 8b 65 f8          	mov    r12,QWORD PTR [rbp-0x8]
  40b14d:	c9                   	leave  
  40b14e:	c3                   	ret    
  40b14f:	90                   	nop
  40b150:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
	if (!kv) return NULL;
  40b154:	48 85 c0             	test   rax,rax
  40b157:	74 d9                	je     40b132 <args_get+0x32>
	switch (kv->vtype) {
  40b159:	8b 50 08             	mov    edx,DWORD PTR [rax+0x8]
  40b15c:	85 d2                	test   edx,edx
  40b15e:	75 d2                	jne    40b132 <args_get+0x32>
	case VTYPE_STR: return kv->val.str;
  40b160:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
}
  40b164:	4c 8b 65 f8          	mov    r12,QWORD PTR [rbp-0x8]
  40b168:	c9                   	leave  
  40b169:	c3                   	ret    
  40b16a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	tarent = tar_root();
  40b170:	e8 7b 06 00 00       	call   40b7f0 <tar_root>
	if (!tarent) return -1;
  40b175:	48 85 c0             	test   rax,rax
  40b178:	74 ba                	je     40b134 <args_get+0x34>
		.d.tar_ent = *tarent
  40b17a:	8b 10                	mov    edx,DWORD PTR [rax]
  40b17c:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	return args_lkup_entry(from, path, ent);
  40b180:	4c 89 e6             	mov    rsi,r12
  40b183:	48 8d 7d d0          	lea    rdi,[rbp-0x30]
	tarroot = (struct initargs) {
  40b187:	c7 45 d0 01 00 00 00 	mov    DWORD PTR [rbp-0x30],0x1
  40b18e:	89 55 d8             	mov    DWORD PTR [rbp-0x28],edx
	return args_lkup_entry(from, path, ent);
  40b191:	48 8d 55 b0          	lea    rdx,[rbp-0x50]
	tarroot = (struct initargs) {
  40b195:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax
	return args_lkup_entry(from, path, ent);
  40b199:	e8 52 fb ff ff       	call   40acf0 <args_lkup_entry>
	if (args_get_entry(path, &ent)) return NULL;
  40b19e:	85 c0                	test   eax,eax
  40b1a0:	75 90                	jne    40b132 <args_get+0x32>
  40b1a2:	eb 82                	jmp    40b126 <args_get+0x26>
  40b1a4:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40b1ab:	00 00 00 
  40b1ae:	66 90                	xchg   ax,ax

000000000040b1b0 <tar_key>:
	return r;
}

char *
tar_key(struct tar_entry *ent, int *str_len)
{
  40b1b0:	f3 0f 1e fa          	endbr64 
  40b1b4:	55                   	push   rbp
  40b1b5:	48 89 f8             	mov    rax,rdi
  40b1b8:	48 89 e5             	mov    rbp,rsp
  40b1bb:	41 55                	push   r13
  40b1bd:	49 89 f5             	mov    r13,rsi
  40b1c0:	41 54                	push   r12
  40b1c2:	53                   	push   rbx
  40b1c3:	48 83 ec 18          	sub    rsp,0x18
	return tar_nesting(ent->nesting_lvl, ent->record->name, str_len);
  40b1c7:	44 8b 20             	mov    r12d,DWORD PTR [rax]
  40b1ca:	48 8b 7f 08          	mov    rdi,QWORD PTR [rdi+0x8]
	for (i = 0 ; i < nesting_lvl ; i++) {
  40b1ce:	45 85 e4             	test   r12d,r12d
  40b1d1:	7e 3d                	jle    40b210 <tar_key+0x60>
  40b1d3:	31 db                	xor    ebx,ebx
  40b1d5:	eb 15                	jmp    40b1ec <tar_key+0x3c>
  40b1d7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40b1de:	00 00 
  40b1e0:	83 c3 01             	add    ebx,0x1
		key++;		/* one past the / */
  40b1e3:	48 83 c7 01          	add    rdi,0x1
	for (i = 0 ; i < nesting_lvl ; i++) {
  40b1e7:	41 39 dc             	cmp    r12d,ebx
  40b1ea:	74 24                	je     40b210 <tar_key+0x60>
		key = strchr(key, '/');
  40b1ec:	be 2f 00 00 00       	mov    esi,0x2f
  40b1f1:	e8 2a a4 00 00       	call   415620 <strchr>
  40b1f6:	48 89 c7             	mov    rdi,rax
		if (!key) return NULL;
  40b1f9:	48 85 c0             	test   rax,rax
  40b1fc:	75 e2                	jne    40b1e0 <tar_key+0x30>
}
  40b1fe:	48 83 c4 18          	add    rsp,0x18
  40b202:	48 89 f8             	mov    rax,rdi
  40b205:	5b                   	pop    rbx
  40b206:	41 5c                	pop    r12
  40b208:	41 5d                	pop    r13
  40b20a:	5d                   	pop    rbp
  40b20b:	c3                   	ret    
  40b20c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	end = strchr(key, '/');
  40b210:	be 2f 00 00 00       	mov    esi,0x2f
  40b215:	48 89 7d d8          	mov    QWORD PTR [rbp-0x28],rdi
  40b219:	e8 02 a4 00 00       	call   415620 <strchr>
	if (!end) *key_len = strlen(key);
  40b21e:	48 8b 7d d8          	mov    rdi,QWORD PTR [rbp-0x28]
  40b222:	48 85 c0             	test   rax,rax
  40b225:	74 19                	je     40b240 <tar_key+0x90>
	else      *key_len = end - key;
  40b227:	48 29 f8             	sub    rax,rdi
  40b22a:	41 89 45 00          	mov    DWORD PTR [r13+0x0],eax
}
  40b22e:	48 83 c4 18          	add    rsp,0x18
  40b232:	48 89 f8             	mov    rax,rdi
  40b235:	5b                   	pop    rbx
  40b236:	41 5c                	pop    r12
  40b238:	41 5d                	pop    r13
  40b23a:	5d                   	pop    rbp
  40b23b:	c3                   	ret    
  40b23c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	if (!end) *key_len = strlen(key);
  40b240:	e8 2b a5 00 00       	call   415770 <strlen>
  40b245:	48 8b 7d d8          	mov    rdi,QWORD PTR [rbp-0x28]
  40b249:	41 89 45 00          	mov    DWORD PTR [r13+0x0],eax
}
  40b24d:	48 83 c4 18          	add    rsp,0x18
  40b251:	5b                   	pop    rbx
  40b252:	48 89 f8             	mov    rax,rdi
  40b255:	41 5c                	pop    r12
  40b257:	41 5d                	pop    r13
  40b259:	5d                   	pop    rbp
  40b25a:	c3                   	ret    
  40b25b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000040b260 <tar_value>:

char *
tar_value(struct tar_entry *ent)
{
  40b260:	f3 0f 1e fa          	endbr64 
	if (!tar_valid(ent)) return NULL;
  40b264:	45 31 c0             	xor    r8d,r8d
	return !(!ent || !ent->record || tar_end(ent->record));
  40b267:	48 85 ff             	test   rdi,rdi
  40b26a:	74 41                	je     40b2ad <tar_value+0x4d>
  40b26c:	4c 8b 47 08          	mov    r8,QWORD PTR [rdi+0x8]
  40b270:	4d 85 c0             	test   r8,r8
  40b273:	74 38                	je     40b2ad <tar_value+0x4d>
  40b275:	4c 89 c0             	mov    rax,r8
  40b278:	49 8d 90 00 04 00 00 	lea    rdx,[r8+0x400]
  40b27f:	eb 10                	jmp    40b291 <tar_value+0x31>
  40b281:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40b288:	48 83 c0 01          	add    rax,0x1
  40b28c:	48 39 d0             	cmp    rax,rdx
  40b28f:	74 27                	je     40b2b8 <tar_value+0x58>
		if (((char *)r)[i]) return 0;
  40b291:	80 38 00             	cmp    BYTE PTR [rax],0x0
  40b294:	74 f2                	je     40b288 <tar_value+0x28>
	return *r->linkflag == '0' || *r->linkflag == '\0';
  40b296:	41 0f b6 80 9c 00 00 	movzx  eax,BYTE PTR [r8+0x9c]
  40b29d:	00 
	if (!tar_is_file(ent->record)) return NULL;
  40b29e:	3c 30                	cmp    al,0x30
  40b2a0:	74 04                	je     40b2a6 <tar_value+0x46>
  40b2a2:	84 c0                	test   al,al
  40b2a4:	75 12                	jne    40b2b8 <tar_value+0x58>

	return (char *)&ent->record[1];
  40b2a6:	49 81 c0 00 02 00 00 	add    r8,0x200
}
  40b2ad:	4c 89 c0             	mov    rax,r8
  40b2b0:	c3                   	ret    
  40b2b1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	if (!tar_valid(ent)) return NULL;
  40b2b8:	45 31 c0             	xor    r8d,r8d
}
  40b2bb:	4c 89 c0             	mov    rax,r8
  40b2be:	c3                   	ret    
  40b2bf:	90                   	nop

000000000040b2c0 <tar_value_sz>:

int
tar_value_sz(struct tar_entry *ent)
{
  40b2c0:	f3 0f 1e fa          	endbr64 
	if (!tar_valid(ent)) return 0;
  40b2c4:	45 31 c0             	xor    r8d,r8d
	return !(!ent || !ent->record || tar_end(ent->record));
  40b2c7:	48 85 ff             	test   rdi,rdi
  40b2ca:	74 54                	je     40b320 <tar_value_sz+0x60>
{
  40b2cc:	55                   	push   rbp
  40b2cd:	48 89 e5             	mov    rbp,rsp
  40b2d0:	53                   	push   rbx
  40b2d1:	48 83 ec 08          	sub    rsp,0x8
	return !(!ent || !ent->record || tar_end(ent->record));
  40b2d5:	48 8b 5f 08          	mov    rbx,QWORD PTR [rdi+0x8]
  40b2d9:	48 85 db             	test   rbx,rbx
  40b2dc:	74 32                	je     40b310 <tar_value_sz+0x50>
  40b2de:	48 89 d8             	mov    rax,rbx
  40b2e1:	48 8d 93 00 04 00 00 	lea    rdx,[rbx+0x400]
  40b2e8:	eb 0f                	jmp    40b2f9 <tar_value_sz+0x39>
  40b2ea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40b2f0:	48 83 c0 01          	add    rax,0x1
  40b2f4:	48 39 d0             	cmp    rax,rdx
  40b2f7:	74 14                	je     40b30d <tar_value_sz+0x4d>
		if (((char *)r)[i]) return 0;
  40b2f9:	80 38 00             	cmp    BYTE PTR [rax],0x0
  40b2fc:	74 f2                	je     40b2f0 <tar_value_sz+0x30>
	return *r->linkflag == '0' || *r->linkflag == '\0';
  40b2fe:	0f b6 83 9c 00 00 00 	movzx  eax,BYTE PTR [rbx+0x9c]
	if (!tar_is_file(ent->record)) return 0;
  40b305:	3c 30                	cmp    al,0x30
  40b307:	74 1f                	je     40b328 <tar_value_sz+0x68>
  40b309:	84 c0                	test   al,al
  40b30b:	74 1b                	je     40b328 <tar_value_sz+0x68>
	if (!tar_valid(ent)) return 0;
  40b30d:	45 31 c0             	xor    r8d,r8d

	return oct2dec(ent->record->size);
}
  40b310:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
  40b314:	44 89 c0             	mov    eax,r8d
  40b317:	c9                   	leave  
  40b318:	c3                   	ret    
  40b319:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  40b320:	44 89 c0             	mov    eax,r8d
  40b323:	c3                   	ret    
  40b324:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	i = strnlen(oct, TAR_SZ) - 1;
  40b328:	48 8d 7b 7c          	lea    rdi,[rbx+0x7c]
  40b32c:	be 0c 00 00 00       	mov    esi,0xc
  40b331:	e8 3a a5 00 00       	call   415870 <strnlen>
  40b336:	8d 50 ff             	lea    edx,[rax-0x1]
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40b339:	85 c0                	test   eax,eax
  40b33b:	74 d0                	je     40b30d <tar_value_sz+0x4d>
  40b33d:	48 63 d2             	movsxd rdx,edx
  40b340:	45 31 c0             	xor    r8d,r8d
  40b343:	b9 01 00 00 00       	mov    ecx,0x1
  40b348:	eb 1a                	jmp    40b364 <tar_value_sz+0xa4>
  40b34a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
		tot = tot + (val * base);
  40b350:	0f b6 c0             	movzx  eax,al
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40b353:	48 83 ea 01          	sub    rdx,0x1
		tot = tot + (val * base);
  40b357:	0f af c1             	imul   eax,ecx
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40b35a:	c1 e1 03             	shl    ecx,0x3
		tot = tot + (val * base);
  40b35d:	41 01 c0             	add    r8d,eax
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40b360:	85 d2                	test   edx,edx
  40b362:	78 ac                	js     40b310 <tar_value_sz+0x50>
		if (val > '7' || val < '0') return -1;
  40b364:	0f b6 44 13 7c       	movzx  eax,BYTE PTR [rbx+rdx*1+0x7c]
  40b369:	83 e8 30             	sub    eax,0x30
  40b36c:	3c 07                	cmp    al,0x7
  40b36e:	76 e0                	jbe    40b350 <tar_value_sz+0x90>
	if (i == TAR_RECORD_SIZE) return -1;
  40b370:	41 b8 ff ff ff ff    	mov    r8d,0xffffffff
  40b376:	eb 98                	jmp    40b310 <tar_value_sz+0x50>
  40b378:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40b37f:	00 

000000000040b380 <tar_is_value>:

int
tar_is_value(struct tar_entry *ent)
{
  40b380:	f3 0f 1e fa          	endbr64 
	if (!tar_valid(ent)) return 0;
  40b384:	31 c0                	xor    eax,eax
	return !(!ent || !ent->record || tar_end(ent->record));
  40b386:	48 85 ff             	test   rdi,rdi
  40b389:	74 3a                	je     40b3c5 <tar_is_value+0x45>
  40b38b:	48 8b 4f 08          	mov    rcx,QWORD PTR [rdi+0x8]
  40b38f:	48 85 c9             	test   rcx,rcx
  40b392:	74 31                	je     40b3c5 <tar_is_value+0x45>
  40b394:	48 89 c8             	mov    rax,rcx
  40b397:	48 8d 91 00 04 00 00 	lea    rdx,[rcx+0x400]
  40b39e:	eb 09                	jmp    40b3a9 <tar_is_value+0x29>
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40b3a0:	48 83 c0 01          	add    rax,0x1
  40b3a4:	48 39 d0             	cmp    rax,rdx
  40b3a7:	74 27                	je     40b3d0 <tar_is_value+0x50>
		if (((char *)r)[i]) return 0;
  40b3a9:	80 38 00             	cmp    BYTE PTR [rax],0x0
  40b3ac:	74 f2                	je     40b3a0 <tar_is_value+0x20>
	return *r->linkflag == '0' || *r->linkflag == '\0';
  40b3ae:	0f b6 91 9c 00 00 00 	movzx  edx,BYTE PTR [rcx+0x9c]
  40b3b5:	80 fa 30             	cmp    dl,0x30
  40b3b8:	0f 94 c0             	sete   al
  40b3bb:	84 d2                	test   dl,dl
  40b3bd:	0f 94 c2             	sete   dl
  40b3c0:	09 d0                	or     eax,edx
  40b3c2:	0f b6 c0             	movzx  eax,al

	return tar_is_file(ent->record);
}
  40b3c5:	c3                   	ret    
  40b3c6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40b3cd:	00 00 00 
	if (!tar_valid(ent)) return 0;
  40b3d0:	31 c0                	xor    eax,eax
  40b3d2:	c3                   	ret    
  40b3d3:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40b3da:	00 00 00 00 
  40b3de:	66 90                	xchg   ax,ax

000000000040b3e0 <tar_iter_next>:

int
tar_iter_next(struct tar_iter *i, struct tar_entry *next)
{
  40b3e0:	f3 0f 1e fa          	endbr64 
  40b3e4:	55                   	push   rbp
  40b3e5:	48 89 e5             	mov    rbp,rsp
  40b3e8:	41 57                	push   r15
  40b3ea:	41 56                	push   r14
  40b3ec:	41 55                	push   r13
  40b3ee:	41 54                	push   r12
  40b3f0:	53                   	push   rbx
  40b3f1:	48 83 ec 28          	sub    rsp,0x28
  40b3f5:	48 89 75 c8          	mov    QWORD PTR [rbp-0x38],rsi
	struct tar_record *r;

	if (!i || !tar_valid(&i->entry)) return 0;
  40b3f9:	48 85 ff             	test   rdi,rdi
  40b3fc:	0f 84 ee 00 00 00    	je     40b4f0 <tar_iter_next+0x110>
	return !(!ent || !ent->record || tar_end(ent->record));
  40b402:	4c 8b 67 08          	mov    r12,QWORD PTR [rdi+0x8]
  40b406:	49 89 fe             	mov    r14,rdi
	if (!i || !tar_valid(&i->entry)) return 0;
  40b409:	31 c0                	xor    eax,eax
	return !(!ent || !ent->record || tar_end(ent->record));
  40b40b:	4d 85 e4             	test   r12,r12
  40b40e:	0f 84 de 00 00 00    	je     40b4f2 <tar_iter_next+0x112>
  40b414:	4d 8d ac 24 00 04 00 	lea    r13,[r12+0x400]
  40b41b:	00 
  40b41c:	4c 89 e0             	mov    rax,r12
  40b41f:	eb 14                	jmp    40b435 <tar_iter_next+0x55>
  40b421:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40b428:	48 83 c0 01          	add    rax,0x1
  40b42c:	4c 39 e8             	cmp    rax,r13
  40b42f:	0f 84 bb 00 00 00    	je     40b4f0 <tar_iter_next+0x110>
		if (((char *)r)[i]) return 0;
  40b435:	80 38 00             	cmp    BYTE PTR [rax],0x0
  40b438:	74 ee                	je     40b428 <tar_iter_next+0x48>
  40b43a:	4c 89 e0             	mov    rax,r12
  40b43d:	eb 0e                	jmp    40b44d <tar_iter_next+0x6d>
  40b43f:	90                   	nop
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40b440:	48 83 c0 01          	add    rax,0x1
  40b444:	4c 39 e8             	cmp    rax,r13
  40b447:	0f 84 a3 00 00 00    	je     40b4f0 <tar_iter_next+0x110>
		if (((char *)r)[i]) return 0;
  40b44d:	80 38 00             	cmp    BYTE PTR [rax],0x0
  40b450:	74 ee                	je     40b440 <tar_iter_next+0x60>
	if (!tar_valid(path) || iter == NULL || *iter == NULL) return NULL;
  40b452:	4d 8b 7e 10          	mov    r15,QWORD PTR [r14+0x10]
  40b456:	4d 85 ff             	test   r15,r15
  40b459:	0f 84 91 00 00 00    	je     40b4f0 <tar_iter_next+0x110>
  40b45f:	90                   	nop
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40b460:	4c 89 fb             	mov    rbx,r15
  40b463:	4d 8d 8f 00 04 00 00 	lea    r9,[r15+0x400]
  40b46a:	4c 89 f8             	mov    rax,r15
  40b46d:	eb 0a                	jmp    40b479 <tar_iter_next+0x99>
  40b46f:	90                   	nop
  40b470:	48 83 c0 01          	add    rax,0x1
  40b474:	49 39 c1             	cmp    r9,rax
  40b477:	74 57                	je     40b4d0 <tar_iter_next+0xf0>
		if (((char *)r)[i]) return 0;
  40b479:	80 38 00             	cmp    BYTE PTR [rax],0x0
  40b47c:	74 f2                	je     40b470 <tar_iter_next+0x90>
  40b47e:	4c 89 e0             	mov    rax,r12
  40b481:	eb 12                	jmp    40b495 <tar_iter_next+0xb5>
  40b483:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40b488:	48 83 c0 01          	add    rax,0x1
  40b48c:	4c 39 e8             	cmp    rax,r13
  40b48f:	0f 84 7c 00 00 00    	je     40b511 <tar_iter_next+0x131>
		if (((char *)r)[i]) return 0;
  40b495:	80 38 00             	cmp    BYTE PTR [rax],0x0
  40b498:	74 ee                	je     40b488 <tar_iter_next+0xa8>
	if (ent->nesting_lvl == 0) {
  40b49a:	41 8b 06             	mov    eax,DWORD PTR [r14]
	end = strchr(key, '/');
  40b49d:	be 2f 00 00 00       	mov    esi,0x2f
  40b4a2:	4c 89 ff             	mov    rdi,r15
  40b4a5:	4c 89 4d c0          	mov    QWORD PTR [rbp-0x40],r9
	if (ent->nesting_lvl == 0) {
  40b4a9:	89 45 b4             	mov    DWORD PTR [rbp-0x4c],eax
	end = strchr(key, '/');
  40b4ac:	e8 6f a1 00 00       	call   415620 <strchr>
	if (ent->nesting_lvl == 0) {
  40b4b1:	8b 55 b4             	mov    edx,DWORD PTR [rbp-0x4c]
  40b4b4:	4c 8b 4d c0          	mov    r9,QWORD PTR [rbp-0x40]
  40b4b8:	85 d2                	test   edx,edx
  40b4ba:	0f 85 65 01 00 00    	jne    40b625 <tar_iter_next+0x245>
	return !((cmp == 0) && (end == NULL || end[1] == '\0'));
  40b4c0:	48 85 c0             	test   rax,rax
  40b4c3:	74 0b                	je     40b4d0 <tar_iter_next+0xf0>
  40b4c5:	80 78 01 00          	cmp    BYTE PTR [rax+0x1],0x0
  40b4c9:	75 46                	jne    40b511 <tar_iter_next+0x131>
  40b4cb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40b4d0:	4c 89 f8             	mov    rax,r15
  40b4d3:	eb 0c                	jmp    40b4e1 <tar_iter_next+0x101>
  40b4d5:	0f 1f 00             	nop    DWORD PTR [rax]
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40b4d8:	48 83 c0 01          	add    rax,0x1
  40b4dc:	49 39 c1             	cmp    r9,rax
  40b4df:	74 0f                	je     40b4f0 <tar_iter_next+0x110>
		if (((char *)r)[i]) return 0;
  40b4e1:	80 38 00             	cmp    BYTE PTR [rax],0x0
  40b4e4:	74 f2                	je     40b4d8 <tar_iter_next+0xf8>
  40b4e6:	e9 9a 00 00 00       	jmp    40b585 <tar_iter_next+0x1a5>
  40b4eb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	if (!i || !tar_valid(&i->entry)) return 0;
  40b4f0:	31 c0                	xor    eax,eax

	next->nesting_lvl = i->entry.nesting_lvl;
	next->record = r;

	return 1;
}
  40b4f2:	48 83 c4 28          	add    rsp,0x28
  40b4f6:	5b                   	pop    rbx
  40b4f7:	41 5c                	pop    r12
  40b4f9:	41 5d                	pop    r13
  40b4fb:	41 5e                	pop    r14
  40b4fd:	41 5f                	pop    r15
  40b4ff:	5d                   	pop    rbp
  40b500:	c3                   	ret    
  40b501:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40b508:	48 83 c3 01          	add    rbx,0x1
  40b50c:	49 39 d9             	cmp    r9,rbx
  40b50f:	74 df                	je     40b4f0 <tar_iter_next+0x110>
		if (((char *)r)[i]) return 0;
  40b511:	80 3b 00             	cmp    BYTE PTR [rbx],0x0
  40b514:	74 f2                	je     40b508 <tar_iter_next+0x128>
	i = strnlen(oct, TAR_SZ) - 1;
  40b516:	49 8d 7f 7c          	lea    rdi,[r15+0x7c]
  40b51a:	be 0c 00 00 00       	mov    esi,0xc
  40b51f:	e8 4c a3 00 00       	call   415870 <strnlen>
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40b524:	31 ff                	xor    edi,edi
  40b526:	be 01 00 00 00       	mov    esi,0x1
	i = strnlen(oct, TAR_SZ) - 1;
  40b52b:	83 e8 01             	sub    eax,0x1
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40b52e:	48 63 d0             	movsxd rdx,eax
  40b531:	83 f8 ff             	cmp    eax,0xffffffff
  40b534:	75 21                	jne    40b557 <tar_iter_next+0x177>
  40b536:	eb 2c                	jmp    40b564 <tar_iter_next+0x184>
  40b538:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40b53f:	00 
		tot = tot + (val * base);
  40b540:	0f b6 c0             	movzx  eax,al
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40b543:	48 83 ea 01          	sub    rdx,0x1
		tot = tot + (val * base);
  40b547:	0f af c6             	imul   eax,esi
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40b54a:	c1 e6 03             	shl    esi,0x3
		tot = tot + (val * base);
  40b54d:	01 c7                	add    edi,eax
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40b54f:	85 d2                	test   edx,edx
  40b551:	0f 88 b1 00 00 00    	js     40b608 <tar_iter_next+0x228>
		if (val > '7' || val < '0') return -1;
  40b557:	41 0f b6 44 17 7c    	movzx  eax,BYTE PTR [r15+rdx*1+0x7c]
  40b55d:	83 e8 30             	sub    eax,0x30
  40b560:	3c 07                	cmp    al,0x7
  40b562:	76 dc                	jbe    40b540 <tar_iter_next+0x160>
  40b564:	b8 00 02 00 00       	mov    eax,0x200
	return &r[n_records + 1];
  40b569:	49 01 c7             	add    r15,rax
	for (r = *iter; r && !tar_end(r) && tar_pathcmp(path, r->name); r = tar_next_record(r)) ;
  40b56c:	e9 ef fe ff ff       	jmp    40b460 <tar_iter_next+0x80>
  40b571:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40b578:	48 83 c3 01          	add    rbx,0x1
  40b57c:	49 39 d9             	cmp    r9,rbx
  40b57f:	0f 84 45 01 00 00    	je     40b6ca <tar_iter_next+0x2ea>
		if (((char *)r)[i]) return 0;
  40b585:	80 3b 00             	cmp    BYTE PTR [rbx],0x0
  40b588:	74 ee                	je     40b578 <tar_iter_next+0x198>
	i = strnlen(oct, TAR_SZ) - 1;
  40b58a:	be 0c 00 00 00       	mov    esi,0xc
  40b58f:	49 8d 7f 7c          	lea    rdi,[r15+0x7c]
  40b593:	e8 d8 a2 00 00       	call   415870 <strnlen>
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40b598:	31 f6                	xor    esi,esi
  40b59a:	b9 01 00 00 00       	mov    ecx,0x1
	i = strnlen(oct, TAR_SZ) - 1;
  40b59f:	83 e8 01             	sub    eax,0x1
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40b5a2:	48 63 d0             	movsxd rdx,eax
  40b5a5:	83 f8 ff             	cmp    eax,0xffffffff
  40b5a8:	75 1d                	jne    40b5c7 <tar_iter_next+0x1e7>
  40b5aa:	eb 28                	jmp    40b5d4 <tar_iter_next+0x1f4>
  40b5ac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		tot = tot + (val * base);
  40b5b0:	0f b6 c0             	movzx  eax,al
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40b5b3:	48 83 ea 01          	sub    rdx,0x1
		tot = tot + (val * base);
  40b5b7:	0f af c1             	imul   eax,ecx
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40b5ba:	c1 e1 03             	shl    ecx,0x3
		tot = tot + (val * base);
  40b5bd:	01 c6                	add    esi,eax
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40b5bf:	85 d2                	test   edx,edx
  40b5c1:	0f 88 e9 00 00 00    	js     40b6b0 <tar_iter_next+0x2d0>
		if (val > '7' || val < '0') return -1;
  40b5c7:	41 0f b6 44 17 7c    	movzx  eax,BYTE PTR [r15+rdx*1+0x7c]
  40b5cd:	83 e8 30             	sub    eax,0x30
  40b5d0:	3c 07                	cmp    al,0x7
  40b5d2:	76 dc                	jbe    40b5b0 <tar_iter_next+0x1d0>
  40b5d4:	b8 00 02 00 00       	mov    eax,0x200
	return &r[n_records + 1];
  40b5d9:	4c 01 f8             	add    rax,r15
	*iter = tar_next_record(r);
  40b5dc:	49 89 46 10          	mov    QWORD PTR [r14+0x10],rax
	next->nesting_lvl = i->entry.nesting_lvl;
  40b5e0:	48 8b 4d c8          	mov    rcx,QWORD PTR [rbp-0x38]
  40b5e4:	41 8b 06             	mov    eax,DWORD PTR [r14]
	next->record = r;
  40b5e7:	4c 89 79 08          	mov    QWORD PTR [rcx+0x8],r15
	next->nesting_lvl = i->entry.nesting_lvl;
  40b5eb:	89 01                	mov    DWORD PTR [rcx],eax
}
  40b5ed:	48 83 c4 28          	add    rsp,0x28
	return 1;
  40b5f1:	b8 01 00 00 00       	mov    eax,0x1
}
  40b5f6:	5b                   	pop    rbx
  40b5f7:	41 5c                	pop    r12
  40b5f9:	41 5d                	pop    r13
  40b5fb:	41 5e                	pop    r14
  40b5fd:	41 5f                	pop    r15
  40b5ff:	5d                   	pop    rbp
  40b600:	c3                   	ret    
  40b601:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	n_records = round_up_to_pow2(sz, TAR_RECORD_SIZE) / TAR_RECORD_SIZE;
  40b608:	48 63 ff             	movsxd rdi,edi
  40b60b:	48 81 c7 ff 01 00 00 	add    rdi,0x1ff
	return &r[n_records + 1];
  40b612:	48 81 e7 00 fe ff ff 	and    rdi,0xfffffffffffffe00
  40b619:	48 8d 87 00 02 00 00 	lea    rax,[rdi+0x200]
  40b620:	e9 44 ff ff ff       	jmp    40b569 <tar_iter_next+0x189>
	for (i = 0 ; i < nesting_lvl ; i++) {
  40b625:	0f 8e a6 00 00 00    	jle    40b6d1 <tar_iter_next+0x2f1>
  40b62b:	4d 89 fa             	mov    r10,r15
  40b62e:	31 d2                	xor    edx,edx
		key = strchr(key, '/');
  40b630:	be 2f 00 00 00       	mov    esi,0x2f
  40b635:	4c 89 d7             	mov    rdi,r10
  40b638:	4c 89 4d c0          	mov    QWORD PTR [rbp-0x40],r9
  40b63c:	89 55 b8             	mov    DWORD PTR [rbp-0x48],edx
  40b63f:	e8 dc 9f 00 00       	call   415620 <strchr>
		if (!key) return NULL;
  40b644:	4c 8b 4d c0          	mov    r9,QWORD PTR [rbp-0x40]
  40b648:	48 85 c0             	test   rax,rax
  40b64b:	0f 84 c0 fe ff ff    	je     40b511 <tar_iter_next+0x131>
	for (i = 0 ; i < nesting_lvl ; i++) {
  40b651:	8b 55 b8             	mov    edx,DWORD PTR [rbp-0x48]
		key++;		/* one past the / */
  40b654:	4c 8d 50 01          	lea    r10,[rax+0x1]
	for (i = 0 ; i < nesting_lvl ; i++) {
  40b658:	83 c2 01             	add    edx,0x1
  40b65b:	39 55 b4             	cmp    DWORD PTR [rbp-0x4c],edx
  40b65e:	75 d0                	jne    40b630 <tar_iter_next+0x250>
	if (*key == '\0') return 1; /* if we have the actual directory, avoid it */
  40b660:	80 78 01 00          	cmp    BYTE PTR [rax+0x1],0x0
  40b664:	0f 84 a7 fe ff ff    	je     40b511 <tar_iter_next+0x131>
	len = (int)(key - path);
  40b66a:	4c 89 d2             	mov    rdx,r10
	cmp = strncmp(p, path, len);
  40b66d:	4c 89 fe             	mov    rsi,r15
  40b670:	4c 89 e7             	mov    rdi,r12
  40b673:	4c 89 4d b8          	mov    QWORD PTR [rbp-0x48],r9
	len = (int)(key - path);
  40b677:	4c 29 fa             	sub    rdx,r15
  40b67a:	4c 89 55 c0          	mov    QWORD PTR [rbp-0x40],r10
  40b67e:	48 63 d2             	movsxd rdx,edx
	cmp = strncmp(p, path, len);
  40b681:	e8 6a a1 00 00       	call   4157f0 <strncmp>
	return !((cmp == 0) && (end == NULL || end[1] == '\0'));
  40b686:	4c 8b 55 c0          	mov    r10,QWORD PTR [rbp-0x40]
  40b68a:	4c 8b 4d b8          	mov    r9,QWORD PTR [rbp-0x48]
  40b68e:	85 c0                	test   eax,eax
  40b690:	0f 85 7b fe ff ff    	jne    40b511 <tar_iter_next+0x131>
	end = strchr(key, '/');
  40b696:	be 2f 00 00 00       	mov    esi,0x2f
  40b69b:	4c 89 d7             	mov    rdi,r10
  40b69e:	4c 89 4d c0          	mov    QWORD PTR [rbp-0x40],r9
  40b6a2:	e8 79 9f 00 00       	call   415620 <strchr>
  40b6a7:	4c 8b 4d c0          	mov    r9,QWORD PTR [rbp-0x40]
  40b6ab:	e9 10 fe ff ff       	jmp    40b4c0 <tar_iter_next+0xe0>
	n_records = round_up_to_pow2(sz, TAR_RECORD_SIZE) / TAR_RECORD_SIZE;
  40b6b0:	48 63 c6             	movsxd rax,esi
  40b6b3:	48 05 ff 01 00 00    	add    rax,0x1ff
	return &r[n_records + 1];
  40b6b9:	48 25 00 fe ff ff    	and    rax,0xfffffffffffffe00
  40b6bf:	48 05 00 02 00 00    	add    rax,0x200
  40b6c5:	e9 0f ff ff ff       	jmp    40b5d9 <tar_iter_next+0x1f9>
	if (tar_end(r)) return NULL;
  40b6ca:	31 c0                	xor    eax,eax
  40b6cc:	e9 0b ff ff ff       	jmp    40b5dc <tar_iter_next+0x1fc>
	if (*key == '\0') return 1; /* if we have the actual directory, avoid it */
  40b6d1:	41 80 3f 00          	cmp    BYTE PTR [r15],0x0
  40b6d5:	0f 85 e5 fd ff ff    	jne    40b4c0 <tar_iter_next+0xe0>
  40b6db:	e9 31 fe ff ff       	jmp    40b511 <tar_iter_next+0x131>

000000000040b6e0 <tar_iter>:
 * assumptions is wrong, we will skip all of those entries in a
 * directory that come *before* the directory record.
 */
int
tar_iter(struct tar_entry *ent, struct tar_iter *i, struct tar_entry *first)
{
  40b6e0:	f3 0f 1e fa          	endbr64 
  40b6e4:	49 89 f8             	mov    r8,rdi
  40b6e7:	48 89 f7             	mov    rdi,rsi
	return !(!ent || !ent->record || tar_end(ent->record));
  40b6ea:	4d 85 c0             	test   r8,r8
  40b6ed:	74 30                	je     40b71f <tar_iter+0x3f>
  40b6ef:	49 8b 70 08          	mov    rsi,QWORD PTR [r8+0x8]
  40b6f3:	48 85 f6             	test   rsi,rsi
  40b6f6:	74 27                	je     40b71f <tar_iter+0x3f>
  40b6f8:	48 89 f0             	mov    rax,rsi
  40b6fb:	48 8d 8e 00 04 00 00 	lea    rcx,[rsi+0x400]
  40b702:	eb 0d                	jmp    40b711 <tar_iter+0x31>
  40b704:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40b708:	48 83 c0 01          	add    rax,0x1
  40b70c:	48 39 c1             	cmp    rcx,rax
  40b70f:	74 0e                	je     40b71f <tar_iter+0x3f>
		if (((char *)r)[i]) return 0;
  40b711:	80 38 00             	cmp    BYTE PTR [rax],0x0
  40b714:	74 f2                	je     40b708 <tar_iter+0x28>
	if (!tar_valid(ent)) return 0;
	if (!tar_is_dir(ent->record)) return 0;
  40b716:	80 be 9c 00 00 00 35 	cmp    BYTE PTR [rsi+0x9c],0x35
  40b71d:	74 09                	je     40b728 <tar_iter+0x48>
	i->entry    = *ent;
	i->iter_rec = ent->record;
	i->entry.nesting_lvl++;	/* look *in* the entry */

	return tar_iter_next(i, first);
}
  40b71f:	31 c0                	xor    eax,eax
  40b721:	c3                   	ret    
  40b722:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	i->entry    = *ent;
  40b728:	f3 41 0f 6f 00       	movdqu xmm0,XMMWORD PTR [r8]
	return tar_iter_next(i, first);
  40b72d:	48 89 d6             	mov    rsi,rdx
	i->entry    = *ent;
  40b730:	0f 11 07             	movups XMMWORD PTR [rdi],xmm0
	i->iter_rec = ent->record;
  40b733:	49 8b 40 08          	mov    rax,QWORD PTR [r8+0x8]
	i->entry.nesting_lvl++;	/* look *in* the entry */
  40b737:	83 07 01             	add    DWORD PTR [rdi],0x1
	i->iter_rec = ent->record;
  40b73a:	48 89 47 10          	mov    QWORD PTR [rdi+0x10],rax
	return tar_iter_next(i, first);
  40b73e:	e9 9d fc ff ff       	jmp    40b3e0 <tar_iter_next>
  40b743:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40b74a:	00 00 00 00 
  40b74e:	66 90                	xchg   ax,ax

000000000040b750 <tar_len>:

int
tar_len(struct tar_entry *start)
{
  40b750:	f3 0f 1e fa          	endbr64 
  40b754:	55                   	push   rbp
  40b755:	48 89 e5             	mov    rbp,rsp
  40b758:	41 54                	push   r12
  40b75a:	48 83 ec 38          	sub    rsp,0x38
	return !(!ent || !ent->record || tar_end(ent->record));
  40b75e:	48 85 ff             	test   rdi,rdi
  40b761:	74 34                	je     40b797 <tar_len+0x47>
  40b763:	48 8b 4f 08          	mov    rcx,QWORD PTR [rdi+0x8]
  40b767:	48 85 c9             	test   rcx,rcx
  40b76a:	74 2b                	je     40b797 <tar_len+0x47>
  40b76c:	48 89 c8             	mov    rax,rcx
  40b76f:	48 8d 91 00 04 00 00 	lea    rdx,[rcx+0x400]
  40b776:	eb 11                	jmp    40b789 <tar_len+0x39>
  40b778:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40b77f:	00 
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40b780:	48 83 c0 01          	add    rax,0x1
  40b784:	48 39 d0             	cmp    rax,rdx
  40b787:	74 0e                	je     40b797 <tar_len+0x47>
		if (((char *)r)[i]) return 0;
  40b789:	80 38 00             	cmp    BYTE PTR [rax],0x0
  40b78c:	74 f2                	je     40b780 <tar_len+0x30>
	if (!tar_is_dir(ent->record)) return 0;
  40b78e:	80 b9 9c 00 00 00 35 	cmp    BYTE PTR [rcx+0x9c],0x35
  40b795:	74 0c                	je     40b7a3 <tar_len+0x53>
	int cont = 0, cnt = 0;
	struct tar_iter i;
	struct tar_entry entry;	/* data placed in here; don't care about it for calculating len */
	for (cont = tar_iter(start, &i, &entry); cont ; cont = tar_iter_next(&i, &entry)) {
  40b797:	45 31 e4             	xor    r12d,r12d
		cnt++;
	}

	return cnt;
}
  40b79a:	44 89 e0             	mov    eax,r12d
  40b79d:	4c 8b 65 f8          	mov    r12,QWORD PTR [rbp-0x8]
  40b7a1:	c9                   	leave  
  40b7a2:	c3                   	ret    
	i->entry    = *ent;
  40b7a3:	f3 0f 6f 07          	movdqu xmm0,XMMWORD PTR [rdi]
	return tar_iter_next(i, first);
  40b7a7:	48 8d 75 c0          	lea    rsi,[rbp-0x40]
  40b7ab:	48 8d 7d d0          	lea    rdi,[rbp-0x30]
	i->iter_rec = ent->record;
  40b7af:	48 89 4d e0          	mov    QWORD PTR [rbp-0x20],rcx
	i->entry    = *ent;
  40b7b3:	0f 29 45 d0          	movaps XMMWORD PTR [rbp-0x30],xmm0
	i->entry.nesting_lvl++;	/* look *in* the entry */
  40b7b7:	83 45 d0 01          	add    DWORD PTR [rbp-0x30],0x1
	return tar_iter_next(i, first);
  40b7bb:	e8 20 fc ff ff       	call   40b3e0 <tar_iter_next>
	for (cont = tar_iter(start, &i, &entry); cont ; cont = tar_iter_next(&i, &entry)) {
  40b7c0:	85 c0                	test   eax,eax
  40b7c2:	74 d3                	je     40b797 <tar_len+0x47>
  40b7c4:	45 31 e4             	xor    r12d,r12d
  40b7c7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40b7ce:	00 00 
  40b7d0:	48 8d 75 c0          	lea    rsi,[rbp-0x40]
  40b7d4:	48 8d 7d d0          	lea    rdi,[rbp-0x30]
		cnt++;
  40b7d8:	41 83 c4 01          	add    r12d,0x1
	for (cont = tar_iter(start, &i, &entry); cont ; cont = tar_iter_next(&i, &entry)) {
  40b7dc:	e8 ff fb ff ff       	call   40b3e0 <tar_iter_next>
  40b7e1:	85 c0                	test   eax,eax
  40b7e3:	75 eb                	jne    40b7d0 <tar_len+0x80>
  40b7e5:	eb b3                	jmp    40b79a <tar_len+0x4a>
  40b7e7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40b7ee:	00 00 

000000000040b7f0 <tar_root>:
	return (unsigned int)((char *)_binary_crt_init_tar_end - (char *)_binary_crt_init_tar_start);
}

struct tar_entry *
tar_root(void)
{
  40b7f0:	f3 0f 1e fa          	endbr64 
	if ((char *)_binary_crt_init_tar_end - (char *)_binary_crt_init_tar_start < 512) return NULL;
  40b7f4:	b8 18 09 5a 00       	mov    eax,0x5a0918
  40b7f9:	ba 00 00 00 00       	mov    edx,0x0
  40b7fe:	48 2d 19 09 5a 00    	sub    rax,0x5a0919
  40b804:	48 3d ff 01 00 00    	cmp    rax,0x1ff
  40b80a:	b8 40 c0 45 00       	mov    eax,0x45c040
  40b80f:	48 0f 4e c2          	cmovle rax,rdx

	return &__tar_root;
}
  40b813:	c3                   	ret    
  40b814:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40b81b:	00 00 00 
  40b81e:	66 90                	xchg   ax,ax

000000000040b820 <cos_aepthd_fn>:
{
  40b820:	f3 0f 1e fa          	endbr64 
  40b824:	55                   	push   rbp
  40b825:	48 89 f8             	mov    rax,rdi
	(aep_fn)(aep_info->rcv, fn_data);
  40b828:	48 8b 77 28          	mov    rsi,QWORD PTR [rdi+0x28]
  40b82c:	48 8b 7f 18          	mov    rdi,QWORD PTR [rdi+0x18]
{
  40b830:	48 89 e5             	mov    rbp,rsp
	(aep_fn)(aep_info->rcv, fn_data);
  40b833:	ff 50 20             	call   QWORD PTR [rax+0x20]
  40b836:	be 32 00 00 00       	mov    esi,0x32
  40b83b:	bf 00 c2 41 00       	mov    edi,0x41c200
  40b840:	e8 8b e8 ff ff       	call   40a0d0 <cos_print_str>
	assert(0);
  40b845:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40b84c:	00 00 00 00 
  40b850:	0f 0b                	ud2    
  40b852:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40b859:	00 00 00 00 
  40b85d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040b860 <cos_defcompinfo_curr_get>:
static int                    curr_defci_init_status;
static struct cos_defcompinfo curr_defci;

struct cos_defcompinfo *
cos_defcompinfo_curr_get(void)
{
  40b860:	f3 0f 1e fa          	endbr64 
	return &curr_defci;
}
  40b864:	b8 20 09 5a 00       	mov    eax,0x5a0920
  40b869:	c3                   	ret    
  40b86a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000040b870 <cos_compinfo_get>:

struct cos_compinfo *
cos_compinfo_get(struct cos_defcompinfo *defci)
{
  40b870:	f3 0f 1e fa          	endbr64 
	assert(defci);
  40b874:	48 85 ff             	test   rdi,rdi
  40b877:	74 04                	je     40b87d <cos_compinfo_get+0xd>
  40b879:	48 89 f8             	mov    rax,rdi
	return &(defci->ci);
}
  40b87c:	c3                   	ret    
{
  40b87d:	55                   	push   rbp
  40b87e:	be 30 00 00 00       	mov    esi,0x30
  40b883:	bf 38 c2 41 00       	mov    edi,0x41c238
  40b888:	48 89 e5             	mov    rbp,rsp
  40b88b:	e8 40 e8 ff ff       	call   40a0d0 <cos_print_str>
	assert(defci);
  40b890:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40b897:	00 00 00 00 
  40b89b:	0f 0b                	ud2    
  40b89d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040b8a0 <cos_sched_aep_get>:

struct cos_aep_info *
cos_sched_aep_get(struct cos_defcompinfo *defci)
{
  40b8a0:	f3 0f 1e fa          	endbr64 
	assert(defci);
  40b8a4:	48 85 ff             	test   rdi,rdi
  40b8a7:	74 08                	je     40b8b1 <cos_sched_aep_get+0x11>
	return &(defci->sched_aep[cos_cpuid()]);
  40b8a9:	48 8d 87 e0 00 00 00 	lea    rax,[rdi+0xe0]
}
  40b8b0:	c3                   	ret    
{
  40b8b1:	55                   	push   rbp
  40b8b2:	be 30 00 00 00       	mov    esi,0x30
  40b8b7:	bf 70 c2 41 00       	mov    edi,0x41c270
  40b8bc:	48 89 e5             	mov    rbp,rsp
  40b8bf:	e8 0c e8 ff ff       	call   40a0d0 <cos_print_str>
	assert(defci);
  40b8c4:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40b8cb:	00 00 00 00 
  40b8cf:	0f 0b                	ud2    
  40b8d1:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40b8d8:	00 00 00 00 
  40b8dc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000040b8e0 <cos_defcompinfo_init>:

void
cos_defcompinfo_init(void)
{
  40b8e0:	f3 0f 1e fa          	endbr64 
  40b8e4:	55                   	push   rbp
	capid_t cap_frontier = atol(args_get("captbl_end"));
  40b8e5:	bf a1 c2 41 00       	mov    edi,0x41c2a1
{
  40b8ea:	48 89 e5             	mov    rbp,rsp
	capid_t cap_frontier = atol(args_get("captbl_end"));
  40b8ed:	e8 0e f8 ff ff       	call   40b100 <args_get>
  40b8f2:	48 89 c7             	mov    rdi,rax
  40b8f5:	e8 66 9c 00 00       	call   415560 <atol>

	assert(cap_frontier > 0);
  40b8fa:	48 85 c0             	test   rax,rax
  40b8fd:	0f 84 91 00 00 00    	je     40b994 <cos_defcompinfo_init+0xb4>
	if (curr_defci_init_status == INITIALIZED) return;
  40b903:	83 3d 26 51 19 00 01 	cmp    DWORD PTR [rip+0x195126],0x1        # 5a0a30 <curr_defci_init_status>
  40b90a:	0f 84 82 00 00 00    	je     40b992 <cos_defcompinfo_init+0xb2>
	struct cos_defcompinfo *defci = cos_defcompinfo_curr_get();
	struct cos_compinfo    *ci    = cos_compinfo_get(defci);

	if (curr_defci_init_status == INITIALIZED) return;

	cos_compinfo_init(ci, pgtbl_cap, captbl_cap, comp_cap, heap_ptr, cap_frontier, ci);
  40b910:	48 83 ec 08          	sub    rsp,0x8
  40b914:	4c 8b 05 3d b7 01 00 	mov    r8,QWORD PTR [rip+0x1b73d]        # 427058 <__cosrt_comp_info+0x58>
  40b91b:	49 89 c1             	mov    r9,rax
  40b91e:	b9 0c 00 00 00       	mov    ecx,0xc
  40b923:	68 20 09 5a 00       	push   0x5a0920
  40b928:	ba 04 00 00 00       	mov    edx,0x4
  40b92d:	be 08 00 00 00       	mov    esi,0x8
  40b932:	bf 20 09 5a 00       	mov    edi,0x5a0920
  40b937:	e8 e4 1d 00 00       	call   40d720 <cos_compinfo_init>
	struct cos_compinfo    *ci        = cos_compinfo_get(defci);
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);

	assert(curr_defci_init_status == INITIALIZED);

	sched_aep->tc   = sched_tc;
  40b93c:	66 0f 6f 05 4c 0c 01 	movdqa xmm0,XMMWORD PTR [rip+0x10c4c]        # 41c590 <__unlock+0x1560>
  40b943:	00 
	sched_aep->thd  = sched_thd;
	sched_aep->rcv  = sched_rcv;
	sched_aep->fn   = NULL;
	sched_aep->data = NULL;
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40b944:	31 d2                	xor    edx,edx
  40b946:	be 28 00 00 00       	mov    esi,0x28
	curr_defci_init_status = INITIALIZED;
  40b94b:	c7 05 db 50 19 00 01 	mov    DWORD PTR [rip+0x1950db],0x1        # 5a0a30 <curr_defci_init_status>
  40b952:	00 00 00 
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40b955:	bf 20 09 5a 00       	mov    edi,0x5a0920
	sched_aep->rcv  = sched_rcv;
  40b95a:	48 c7 05 b3 50 19 00 	mov    QWORD PTR [rip+0x1950b3],0x30        # 5a0a18 <curr_defci+0xf8>
  40b961:	30 00 00 00 
	sched_aep->fn   = NULL;
  40b965:	48 c7 05 b0 50 19 00 	mov    QWORD PTR [rip+0x1950b0],0x0        # 5a0a20 <curr_defci+0x100>
  40b96c:	00 00 00 00 
	sched_aep->data = NULL;
  40b970:	48 c7 05 ad 50 19 00 	mov    QWORD PTR [rip+0x1950ad],0x0        # 5a0a28 <curr_defci+0x108>
  40b977:	00 00 00 00 
	sched_aep->tc   = sched_tc;
  40b97b:	0f 29 05 7e 50 19 00 	movaps XMMWORD PTR [rip+0x19507e],xmm0        # 5a0a00 <curr_defci+0xe0>
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40b982:	e8 b9 61 00 00       	call   411b40 <cos_introspect>
  40b987:	48 98                	cdqe   
  40b989:	48 89 05 80 50 19 00 	mov    QWORD PTR [rip+0x195080],rax        # 5a0a10 <curr_defci+0xf0>
}
  40b990:	58                   	pop    rax
  40b991:	5a                   	pop    rdx
}
  40b992:	c9                   	leave  
  40b993:	c3                   	ret    
  40b994:	be 30 00 00 00       	mov    esi,0x30
  40b999:	bf b0 c2 41 00       	mov    edi,0x41c2b0
  40b99e:	e8 2d e7 ff ff       	call   40a0d0 <cos_print_str>
	assert(cap_frontier > 0);
  40b9a3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40b9aa:	00 00 00 00 
  40b9ae:	0f 0b                	ud2    

000000000040b9b0 <cos_defcompinfo_init_ext>:
{
  40b9b0:	f3 0f 1e fa          	endbr64 
  40b9b4:	55                   	push   rbp
  40b9b5:	66 48 0f 6e c7       	movq   xmm0,rdi
  40b9ba:	66 48 0f 6e ce       	movq   xmm1,rsi
  40b9bf:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  40b9c3:	48 89 e5             	mov    rbp,rsp
  40b9c6:	41 54                	push   r12
  40b9c8:	49 89 f4             	mov    r12,rsi
  40b9cb:	53                   	push   rbx
  40b9cc:	48 83 ec 10          	sub    rsp,0x10
	if (curr_defci_init_status == INITIALIZED) return;
  40b9d0:	83 3d 59 50 19 00 01 	cmp    DWORD PTR [rip+0x195059],0x1        # 5a0a30 <curr_defci_init_status>
  40b9d7:	0f 29 45 e0          	movaps XMMWORD PTR [rbp-0x20],xmm0
  40b9db:	74 74                	je     40ba51 <cos_defcompinfo_init_ext+0xa1>
	cos_compinfo_init(ci, pgtbl_cap, captbl_cap, comp_cap, heap_ptr, cap_frontier, ci);
  40b9dd:	48 83 ec 08          	sub    rsp,0x8
  40b9e1:	48 89 ce             	mov    rsi,rcx
  40b9e4:	48 89 d3             	mov    rbx,rdx
  40b9e7:	4c 89 c9             	mov    rcx,r9
  40b9ea:	68 20 09 5a 00       	push   0x5a0920
  40b9ef:	4c 89 c2             	mov    rdx,r8
  40b9f2:	4c 8b 4d 18          	mov    r9,QWORD PTR [rbp+0x18]
  40b9f6:	bf 20 09 5a 00       	mov    edi,0x5a0920
  40b9fb:	4c 8b 45 10          	mov    r8,QWORD PTR [rbp+0x10]
  40b9ff:	e8 1c 1d 00 00       	call   40d720 <cos_compinfo_init>
	sched_aep->tc   = sched_tc;
  40ba04:	66 0f 6f 45 e0       	movdqa xmm0,XMMWORD PTR [rbp-0x20]
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40ba09:	31 d2                	xor    edx,edx
  40ba0b:	4c 89 e6             	mov    rsi,r12
  40ba0e:	bf 20 09 5a 00       	mov    edi,0x5a0920
	curr_defci_init_status = INITIALIZED;
  40ba13:	c7 05 13 50 19 00 01 	mov    DWORD PTR [rip+0x195013],0x1        # 5a0a30 <curr_defci_init_status>
  40ba1a:	00 00 00 
	sched_aep->rcv  = sched_rcv;
  40ba1d:	48 89 1d f4 4f 19 00 	mov    QWORD PTR [rip+0x194ff4],rbx        # 5a0a18 <curr_defci+0xf8>
	sched_aep->fn   = NULL;
  40ba24:	48 c7 05 f1 4f 19 00 	mov    QWORD PTR [rip+0x194ff1],0x0        # 5a0a20 <curr_defci+0x100>
  40ba2b:	00 00 00 00 
	sched_aep->data = NULL;
  40ba2f:	48 c7 05 ee 4f 19 00 	mov    QWORD PTR [rip+0x194fee],0x0        # 5a0a28 <curr_defci+0x108>
  40ba36:	00 00 00 00 
	sched_aep->tc   = sched_tc;
  40ba3a:	0f 29 05 bf 4f 19 00 	movaps XMMWORD PTR [rip+0x194fbf],xmm0        # 5a0a00 <curr_defci+0xe0>
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40ba41:	e8 fa 60 00 00       	call   411b40 <cos_introspect>
  40ba46:	48 98                	cdqe   
  40ba48:	48 89 05 c1 4f 19 00 	mov    QWORD PTR [rip+0x194fc1],rax        # 5a0a10 <curr_defci+0xf0>
}
  40ba4f:	58                   	pop    rax
  40ba50:	5a                   	pop    rdx
}
  40ba51:	48 8d 65 f0          	lea    rsp,[rbp-0x10]
  40ba55:	5b                   	pop    rbx
  40ba56:	41 5c                	pop    r12
  40ba58:	5d                   	pop    rbp
  40ba59:	c3                   	ret    
  40ba5a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000040ba60 <cos_defcompinfo_sched_init_ext>:
{
  40ba60:	f3 0f 1e fa          	endbr64 
  40ba64:	55                   	push   rbp
  40ba65:	66 48 0f 6e c7       	movq   xmm0,rdi
  40ba6a:	66 48 0f 6e ce       	movq   xmm1,rsi
	assert(curr_defci_init_status == INITIALIZED);
  40ba6f:	83 3d ba 4f 19 00 01 	cmp    DWORD PTR [rip+0x194fba],0x1        # 5a0a30 <curr_defci_init_status>
  40ba76:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
{
  40ba7a:	48 89 e5             	mov    rbp,rsp
	assert(curr_defci_init_status == INITIALIZED);
  40ba7d:	75 3b                	jne    40baba <cos_defcompinfo_sched_init_ext+0x5a>
	sched_aep->rcv  = sched_rcv;
  40ba7f:	48 89 15 92 4f 19 00 	mov    QWORD PTR [rip+0x194f92],rdx        # 5a0a18 <curr_defci+0xf8>
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40ba86:	bf 20 09 5a 00       	mov    edi,0x5a0920
  40ba8b:	31 d2                	xor    edx,edx
	sched_aep->fn   = NULL;
  40ba8d:	48 c7 05 88 4f 19 00 	mov    QWORD PTR [rip+0x194f88],0x0        # 5a0a20 <curr_defci+0x100>
  40ba94:	00 00 00 00 
	sched_aep->data = NULL;
  40ba98:	48 c7 05 85 4f 19 00 	mov    QWORD PTR [rip+0x194f85],0x0        # 5a0a28 <curr_defci+0x108>
  40ba9f:	00 00 00 00 
	sched_aep->tc   = sched_tc;
  40baa3:	0f 29 05 56 4f 19 00 	movaps XMMWORD PTR [rip+0x194f56],xmm0        # 5a0a00 <curr_defci+0xe0>
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40baaa:	e8 91 60 00 00       	call   411b40 <cos_introspect>
}
  40baaf:	5d                   	pop    rbp
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40bab0:	48 98                	cdqe   
  40bab2:	48 89 05 57 4f 19 00 	mov    QWORD PTR [rip+0x194f57],rax        # 5a0a10 <curr_defci+0xf0>
}
  40bab9:	c3                   	ret    
  40baba:	be 30 00 00 00       	mov    esi,0x30
  40babf:	bf e8 c2 41 00       	mov    edi,0x41c2e8
  40bac4:	e8 07 e6 ff ff       	call   40a0d0 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40bac9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40bad0:	00 00 00 00 
  40bad4:	0f 0b                	ud2    
  40bad6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40badd:	00 00 00 

000000000040bae0 <cos_defcompinfo_sched_init>:

void
cos_defcompinfo_sched_init(void)
{
  40bae0:	f3 0f 1e fa          	endbr64 
  40bae4:	55                   	push   rbp
	assert(curr_defci_init_status == INITIALIZED);
  40bae5:	83 3d 44 4f 19 00 01 	cmp    DWORD PTR [rip+0x194f44],0x1        # 5a0a30 <curr_defci_init_status>
{
  40baec:	48 89 e5             	mov    rbp,rsp
	assert(curr_defci_init_status == INITIALIZED);
  40baef:	75 4c                	jne    40bb3d <cos_defcompinfo_sched_init+0x5d>
	sched_aep->tc   = sched_tc;
  40baf1:	66 0f 6f 05 97 0a 01 	movdqa xmm0,XMMWORD PTR [rip+0x10a97]        # 41c590 <__unlock+0x1560>
  40baf8:	00 
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40baf9:	31 d2                	xor    edx,edx
  40bafb:	be 28 00 00 00       	mov    esi,0x28
  40bb00:	bf 20 09 5a 00       	mov    edi,0x5a0920
	sched_aep->rcv  = sched_rcv;
  40bb05:	48 c7 05 08 4f 19 00 	mov    QWORD PTR [rip+0x194f08],0x30        # 5a0a18 <curr_defci+0xf8>
  40bb0c:	30 00 00 00 
	sched_aep->fn   = NULL;
  40bb10:	48 c7 05 05 4f 19 00 	mov    QWORD PTR [rip+0x194f05],0x0        # 5a0a20 <curr_defci+0x100>
  40bb17:	00 00 00 00 
	sched_aep->data = NULL;
  40bb1b:	48 c7 05 02 4f 19 00 	mov    QWORD PTR [rip+0x194f02],0x0        # 5a0a28 <curr_defci+0x108>
  40bb22:	00 00 00 00 
	sched_aep->tc   = sched_tc;
  40bb26:	0f 29 05 d3 4e 19 00 	movaps XMMWORD PTR [rip+0x194ed3],xmm0        # 5a0a00 <curr_defci+0xe0>
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40bb2d:	e8 0e 60 00 00       	call   411b40 <cos_introspect>

	cos_defcompinfo_sched_init_ext(BOOT_CAPTBL_SELF_INITTCAP_CPU_BASE, BOOT_CAPTBL_SELF_INITTHD_CPU_BASE,
				       BOOT_CAPTBL_SELF_INITRCV_CPU_BASE);
}
  40bb32:	5d                   	pop    rbp
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40bb33:	48 98                	cdqe   
  40bb35:	48 89 05 d4 4e 19 00 	mov    QWORD PTR [rip+0x194ed4],rax        # 5a0a10 <curr_defci+0xf0>
}
  40bb3c:	c3                   	ret    
  40bb3d:	be 30 00 00 00       	mov    esi,0x30
  40bb42:	bf 20 c3 41 00       	mov    edi,0x41c320
  40bb47:	e8 84 e5 ff ff       	call   40a0d0 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40bb4c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40bb53:	00 00 00 00 
  40bb57:	0f 0b                	ud2    
  40bb59:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000040bb60 <cos_defcompinfo_child_alloc>:
}

int
cos_defcompinfo_child_alloc(struct cos_defcompinfo *child_defci, vaddr_t entry, vaddr_t heap_ptr, capid_t cap_frontier,
                            int is_sched)
{
  40bb60:	f3 0f 1e fa          	endbr64 
  40bb64:	55                   	push   rbp
  40bb65:	48 89 e5             	mov    rbp,rsp
  40bb68:	41 55                	push   r13
  40bb6a:	41 54                	push   r12
  40bb6c:	53                   	push   rbx
  40bb6d:	48 83 ec 08          	sub    rsp,0x8
	assert(defci);
  40bb71:	48 85 ff             	test   rdi,rdi
  40bb74:	0f 84 18 01 00 00    	je     40bc92 <cos_defcompinfo_child_alloc+0x132>
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);
	struct cos_compinfo    *ci        = cos_compinfo_get(defci);
	struct cos_compinfo    *child_ci  = cos_compinfo_get(child_defci);
	struct cos_aep_info    *child_aep = cos_sched_aep_get(child_defci);

	assert(curr_defci_init_status == INITIALIZED);
  40bb7a:	83 3d af 4e 19 00 01 	cmp    DWORD PTR [rip+0x194eaf],0x1        # 5a0a30 <curr_defci_init_status>
  40bb81:	0f 85 27 01 00 00    	jne    40bcae <cos_defcompinfo_child_alloc+0x14e>
  40bb87:	49 89 f2             	mov    r10,rsi
  40bb8a:	45 89 c5             	mov    r13d,r8d
	ret = cos_compinfo_alloc(child_ci, heap_ptr, cap_frontier, entry, ci, 0);
  40bb8d:	48 89 d6             	mov    rsi,rdx
  40bb90:	45 31 c9             	xor    r9d,r9d
  40bb93:	48 89 ca             	mov    rdx,rcx
  40bb96:	41 b8 20 09 5a 00    	mov    r8d,0x5a0920
  40bb9c:	4c 89 d1             	mov    rcx,r10
  40bb9f:	48 89 fb             	mov    rbx,rdi
  40bba2:	e8 99 4b 00 00       	call   410740 <cos_compinfo_alloc>
  40bba7:	41 89 c4             	mov    r12d,eax
	if (ret) return ret;
  40bbaa:	85 c0                	test   eax,eax
  40bbac:	0f 85 d2 00 00 00    	jne    40bc84 <cos_defcompinfo_child_alloc+0x124>
	ret = cos_aep_alloc_intern(child_aep, child_defci, 0, is_sched ? sched_aep : NULL, NULL, NULL, 0);
  40bbb2:	45 85 ed             	test   r13d,r13d
  40bbb5:	b8 00 00 00 00       	mov    eax,0x0
  40bbba:	41 bd 00 0a 5a 00    	mov    r13d,0x5a0a00
  40bbc0:	4c 0f 44 e8          	cmove  r13,rax
	assert(curr_defci_init_status == INITIALIZED);
  40bbc4:	83 3d 65 4e 19 00 01 	cmp    DWORD PTR [rip+0x194e65],0x1        # 5a0a30 <curr_defci_init_status>
  40bbcb:	0f 85 f9 00 00 00    	jne    40bcca <cos_defcompinfo_child_alloc+0x16a>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40bbd1:	66 0f ef c0          	pxor   xmm0,xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40bbd5:	48 8b 73 10          	mov    rsi,QWORD PTR [rbx+0x10]
  40bbd9:	bf 20 09 5a 00       	mov    edi,0x5a0920
	memset(aep, 0, sizeof(struct cos_aep_info));
  40bbde:	0f 11 83 e0 00 00 00 	movups XMMWORD PTR [rbx+0xe0],xmm0
  40bbe5:	0f 11 83 f0 00 00 00 	movups XMMWORD PTR [rbx+0xf0],xmm0
  40bbec:	0f 11 83 00 01 00 00 	movups XMMWORD PTR [rbx+0x100],xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40bbf3:	e8 d8 3b 00 00       	call   40f7d0 <cos_initthd_alloc>
  40bbf8:	48 89 83 e8 00 00 00 	mov    QWORD PTR [rbx+0xe8],rax
  40bbff:	48 89 c6             	mov    rsi,rax
	assert(aep->thd);
  40bc02:	48 85 c0             	test   rax,rax
  40bc05:	0f 84 db 00 00 00    	je     40bce6 <cos_defcompinfo_child_alloc+0x186>
	aep->tid  = cos_introspect(ci, aep->thd, THD_GET_TID);
  40bc0b:	31 d2                	xor    edx,edx
  40bc0d:	bf 20 09 5a 00       	mov    edi,0x5a0920
  40bc12:	e8 29 5f 00 00       	call   411b40 <cos_introspect>
  40bc17:	48 98                	cdqe   
  40bc19:	48 89 83 f0 00 00 00 	mov    QWORD PTR [rbx+0xf0],rax
	if (!sched && is_init) return 0;
  40bc20:	4d 85 ed             	test   r13,r13
  40bc23:	74 5f                	je     40bc84 <cos_defcompinfo_child_alloc+0x124>
		aep->tc = cos_tcap_alloc(ci);
  40bc25:	bf 20 09 5a 00       	mov    edi,0x5a0920
  40bc2a:	e8 71 5f 00 00       	call   411ba0 <cos_tcap_alloc>
  40bc2f:	48 89 83 e0 00 00 00 	mov    QWORD PTR [rbx+0xe0],rax
  40bc36:	48 89 c2             	mov    rdx,rax
		assert(aep->tc);
  40bc39:	48 85 c0             	test   rax,rax
  40bc3c:	0f 84 c0 00 00 00    	je     40bd02 <cos_defcompinfo_child_alloc+0x1a2>
	aep->rcv  = cos_arcv_alloc(ci, aep->thd, aep->tc, ci->comp_cap, sched->rcv);
  40bc42:	48 8b b3 e8 00 00 00 	mov    rsi,QWORD PTR [rbx+0xe8]
  40bc49:	4d 8b 45 18          	mov    r8,QWORD PTR [r13+0x18]
  40bc4d:	bf 20 09 5a 00       	mov    edi,0x5a0920
  40bc52:	48 8b 0d d7 4c 19 00 	mov    rcx,QWORD PTR [rip+0x194cd7]        # 5a0930 <curr_defci+0x10>
  40bc59:	e8 52 4e 00 00       	call   410ab0 <cos_arcv_alloc>
  40bc5e:	48 89 83 f8 00 00 00 	mov    QWORD PTR [rbx+0xf8],rax
	assert(aep->rcv);
  40bc65:	48 85 c0             	test   rax,rax
  40bc68:	0f 84 b0 00 00 00    	je     40bd1e <cos_defcompinfo_child_alloc+0x1be>
	aep->fn   = fn;
  40bc6e:	48 c7 83 00 01 00 00 	mov    QWORD PTR [rbx+0x100],0x0
  40bc75:	00 00 00 00 
	aep->data = data;
  40bc79:	48 c7 83 08 01 00 00 	mov    QWORD PTR [rbx+0x108],0x0
  40bc80:	00 00 00 00 

	return ret;
}
  40bc84:	48 83 c4 08          	add    rsp,0x8
  40bc88:	44 89 e0             	mov    eax,r12d
  40bc8b:	5b                   	pop    rbx
  40bc8c:	41 5c                	pop    r12
  40bc8e:	41 5d                	pop    r13
  40bc90:	5d                   	pop    rbp
  40bc91:	c3                   	ret    
  40bc92:	be 30 00 00 00       	mov    esi,0x30
  40bc97:	bf 38 c2 41 00       	mov    edi,0x41c238
  40bc9c:	e8 2f e4 ff ff       	call   40a0d0 <cos_print_str>
	assert(defci);
  40bca1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40bca8:	00 00 00 00 
  40bcac:	0f 0b                	ud2    
  40bcae:	be 31 00 00 00       	mov    esi,0x31
  40bcb3:	bf 58 c3 41 00       	mov    edi,0x41c358
  40bcb8:	e8 13 e4 ff ff       	call   40a0d0 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40bcbd:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40bcc4:	00 00 00 00 
  40bcc8:	0f 0b                	ud2    
  40bcca:	be 31 00 00 00       	mov    esi,0x31
  40bccf:	bf 90 c3 41 00       	mov    edi,0x41c390
  40bcd4:	e8 f7 e3 ff ff       	call   40a0d0 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40bcd9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40bce0:	00 00 00 00 
  40bce4:	0f 0b                	ud2    
  40bce6:	be 31 00 00 00       	mov    esi,0x31
  40bceb:	bf c8 c3 41 00       	mov    edi,0x41c3c8
  40bcf0:	e8 db e3 ff ff       	call   40a0d0 <cos_print_str>
	assert(aep->thd);
  40bcf5:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40bcfc:	00 00 00 00 
  40bd00:	0f 0b                	ud2    
  40bd02:	be 31 00 00 00       	mov    esi,0x31
  40bd07:	bf 00 c4 41 00       	mov    edi,0x41c400
  40bd0c:	e8 bf e3 ff ff       	call   40a0d0 <cos_print_str>
		assert(aep->tc);
  40bd11:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40bd18:	00 00 00 00 
  40bd1c:	0f 0b                	ud2    
  40bd1e:	be 31 00 00 00       	mov    esi,0x31
  40bd23:	bf 38 c4 41 00       	mov    edi,0x41c438
  40bd28:	e8 a3 e3 ff ff       	call   40a0d0 <cos_print_str>
	assert(aep->rcv);
  40bd2d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40bd34:	00 00 00 00 
  40bd38:	0f 0b                	ud2    
  40bd3a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000040bd40 <cos_defcompinfo_childid_init>:

void
cos_defcompinfo_childid_init(struct cos_defcompinfo *child_defci, spdid_t c)
{
  40bd40:	f3 0f 1e fa          	endbr64 
	assert(child_defci != cos_defcompinfo_curr_get());
  40bd44:	48 81 ff 20 09 5a 00 	cmp    rdi,0x5a0920
  40bd4b:	74 04                	je     40bd51 <cos_defcompinfo_childid_init+0x11>

	child_defci->id = c;
  40bd4d:	66 89 37             	mov    WORD PTR [rdi],si
  40bd50:	c3                   	ret    
{
  40bd51:	55                   	push   rbp
  40bd52:	be 31 00 00 00       	mov    esi,0x31
  40bd57:	bf 70 c4 41 00       	mov    edi,0x41c470
  40bd5c:	48 89 e5             	mov    rbp,rsp
  40bd5f:	e8 6c e3 ff ff       	call   40a0d0 <cos_print_str>
	assert(child_defci != cos_defcompinfo_curr_get());
  40bd64:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40bd6b:	00 00 00 00 
  40bd6f:	0f 0b                	ud2    
  40bd71:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40bd78:	00 00 00 00 
  40bd7c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000040bd80 <cos_initaep_alloc>:
}

int
cos_initaep_alloc(struct cos_defcompinfo *dst_dci, struct cos_aep_info *sched, int is_sched)
{
  40bd80:	f3 0f 1e fa          	endbr64 
  40bd84:	55                   	push   rbp
  40bd85:	48 89 e5             	mov    rbp,rsp
  40bd88:	41 54                	push   r12
  40bd8a:	53                   	push   rbx
	assert(defci);
  40bd8b:	48 85 ff             	test   rdi,rdi
  40bd8e:	0f 84 f0 00 00 00    	je     40be84 <cos_initaep_alloc+0x104>
  40bd94:	48 89 fb             	mov    rbx,rdi
	return &(defci->sched_aep[cos_cpuid()]);
  40bd97:	48 8d 87 e0 00 00 00 	lea    rax,[rdi+0xe0]
	struct cos_defcompinfo *defci     = cos_defcompinfo_curr_get();
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);
	struct cos_aep_info    *child_aep = cos_sched_aep_get(dst_dci);
	struct cos_aep_info    *sched_use = is_sched ? (sched ? sched : sched_aep) : NULL;
  40bd9e:	45 31 e4             	xor    r12d,r12d
  40bda1:	85 d2                	test   edx,edx
  40bda3:	0f 85 c7 00 00 00    	jne    40be70 <cos_initaep_alloc+0xf0>
	assert(curr_defci_init_status == INITIALIZED);
  40bda9:	83 3d 80 4c 19 00 01 	cmp    DWORD PTR [rip+0x194c80],0x1        # 5a0a30 <curr_defci_init_status>
  40bdb0:	0f 85 ea 00 00 00    	jne    40bea0 <cos_initaep_alloc+0x120>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40bdb6:	66 0f ef c0          	pxor   xmm0,xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40bdba:	bf 20 09 5a 00       	mov    edi,0x5a0920
	memset(aep, 0, sizeof(struct cos_aep_info));
  40bdbf:	0f 11 83 e0 00 00 00 	movups XMMWORD PTR [rbx+0xe0],xmm0
  40bdc6:	0f 11 40 10          	movups XMMWORD PTR [rax+0x10],xmm0
  40bdca:	0f 11 40 20          	movups XMMWORD PTR [rax+0x20],xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40bdce:	48 8b 73 10          	mov    rsi,QWORD PTR [rbx+0x10]
  40bdd2:	e8 f9 39 00 00       	call   40f7d0 <cos_initthd_alloc>
  40bdd7:	48 89 83 e8 00 00 00 	mov    QWORD PTR [rbx+0xe8],rax
  40bdde:	48 89 c6             	mov    rsi,rax
	assert(aep->thd);
  40bde1:	48 85 c0             	test   rax,rax
  40bde4:	0f 84 d2 00 00 00    	je     40bebc <cos_initaep_alloc+0x13c>
	aep->tid  = cos_introspect(ci, aep->thd, THD_GET_TID);
  40bdea:	31 d2                	xor    edx,edx
  40bdec:	bf 20 09 5a 00       	mov    edi,0x5a0920
  40bdf1:	e8 4a 5d 00 00       	call   411b40 <cos_introspect>
  40bdf6:	48 98                	cdqe   
  40bdf8:	48 89 83 f0 00 00 00 	mov    QWORD PTR [rbx+0xf0],rax
	if (!sched && is_init) return 0;
  40bdff:	4d 85 e4             	test   r12,r12
  40be02:	74 60                	je     40be64 <cos_initaep_alloc+0xe4>
		aep->tc = cos_tcap_alloc(ci);
  40be04:	bf 20 09 5a 00       	mov    edi,0x5a0920
  40be09:	e8 92 5d 00 00       	call   411ba0 <cos_tcap_alloc>
  40be0e:	48 89 83 e0 00 00 00 	mov    QWORD PTR [rbx+0xe0],rax
  40be15:	48 89 c2             	mov    rdx,rax
		assert(aep->tc);
  40be18:	48 85 c0             	test   rax,rax
  40be1b:	0f 84 b7 00 00 00    	je     40bed8 <cos_initaep_alloc+0x158>
	aep->rcv  = cos_arcv_alloc(ci, aep->thd, aep->tc, ci->comp_cap, sched->rcv);
  40be21:	48 8b b3 e8 00 00 00 	mov    rsi,QWORD PTR [rbx+0xe8]
  40be28:	4d 8b 44 24 18       	mov    r8,QWORD PTR [r12+0x18]
  40be2d:	bf 20 09 5a 00       	mov    edi,0x5a0920
  40be32:	48 8b 0d f7 4a 19 00 	mov    rcx,QWORD PTR [rip+0x194af7]        # 5a0930 <curr_defci+0x10>
  40be39:	e8 72 4c 00 00       	call   410ab0 <cos_arcv_alloc>
  40be3e:	48 89 83 f8 00 00 00 	mov    QWORD PTR [rbx+0xf8],rax
	assert(aep->rcv);
  40be45:	48 85 c0             	test   rax,rax
  40be48:	0f 84 a6 00 00 00    	je     40bef4 <cos_initaep_alloc+0x174>
	aep->fn   = fn;
  40be4e:	48 c7 83 00 01 00 00 	mov    QWORD PTR [rbx+0x100],0x0
  40be55:	00 00 00 00 
	aep->data = data;
  40be59:	48 c7 83 08 01 00 00 	mov    QWORD PTR [rbx+0x108],0x0
  40be60:	00 00 00 00 

	return cos_aep_alloc_intern(child_aep, dst_dci, 0, sched_use, NULL, NULL, 0);
}
  40be64:	5b                   	pop    rbx
  40be65:	31 c0                	xor    eax,eax
  40be67:	41 5c                	pop    r12
  40be69:	5d                   	pop    rbp
  40be6a:	c3                   	ret    
  40be6b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40be70:	49 89 f4             	mov    r12,rsi
	struct cos_aep_info    *sched_use = is_sched ? (sched ? sched : sched_aep) : NULL;
  40be73:	48 85 f6             	test   rsi,rsi
  40be76:	ba 00 0a 5a 00       	mov    edx,0x5a0a00
  40be7b:	4c 0f 44 e2          	cmove  r12,rdx
  40be7f:	e9 25 ff ff ff       	jmp    40bda9 <cos_initaep_alloc+0x29>
  40be84:	be 30 00 00 00       	mov    esi,0x30
  40be89:	bf 70 c2 41 00       	mov    edi,0x41c270
  40be8e:	e8 3d e2 ff ff       	call   40a0d0 <cos_print_str>
	assert(defci);
  40be93:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40be9a:	00 00 00 00 
  40be9e:	0f 0b                	ud2    
  40bea0:	be 31 00 00 00       	mov    esi,0x31
  40bea5:	bf 90 c3 41 00       	mov    edi,0x41c390
  40beaa:	e8 21 e2 ff ff       	call   40a0d0 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40beaf:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40beb6:	00 00 00 00 
  40beba:	0f 0b                	ud2    
  40bebc:	be 31 00 00 00       	mov    esi,0x31
  40bec1:	bf c8 c3 41 00       	mov    edi,0x41c3c8
  40bec6:	e8 05 e2 ff ff       	call   40a0d0 <cos_print_str>
	assert(aep->thd);
  40becb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40bed2:	00 00 00 00 
  40bed6:	0f 0b                	ud2    
  40bed8:	be 31 00 00 00       	mov    esi,0x31
  40bedd:	bf 00 c4 41 00       	mov    edi,0x41c400
  40bee2:	e8 e9 e1 ff ff       	call   40a0d0 <cos_print_str>
		assert(aep->tc);
  40bee7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40beee:	00 00 00 00 
  40bef2:	0f 0b                	ud2    
  40bef4:	be 31 00 00 00       	mov    esi,0x31
  40bef9:	bf 38 c4 41 00       	mov    edi,0x41c438
  40befe:	e8 cd e1 ff ff       	call   40a0d0 <cos_print_str>
	assert(aep->rcv);
  40bf03:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40bf0a:	00 00 00 00 
  40bf0e:	0f 0b                	ud2    

000000000040bf10 <cos_initaep_tcap_alloc>:

int
cos_initaep_tcap_alloc(struct cos_defcompinfo *dst_dci, tcap_t tc, struct cos_aep_info *sched)
{
  40bf10:	f3 0f 1e fa          	endbr64 
  40bf14:	55                   	push   rbp
  40bf15:	48 89 e5             	mov    rbp,rsp
  40bf18:	41 55                	push   r13
  40bf1a:	41 54                	push   r12
  40bf1c:	53                   	push   rbx
  40bf1d:	48 83 ec 08          	sub    rsp,0x8
	assert(defci);
  40bf21:	48 85 ff             	test   rdi,rdi
  40bf24:	0f 84 0b 01 00 00    	je     40c035 <cos_initaep_tcap_alloc+0x125>
	struct cos_defcompinfo *defci     = cos_defcompinfo_curr_get();
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);
	struct cos_aep_info    *child_aep = cos_sched_aep_get(dst_dci);
	struct cos_aep_info    *sched_use = sched ? sched : sched_aep;
  40bf2a:	48 85 d2             	test   rdx,rdx
  40bf2d:	49 89 d4             	mov    r12,rdx
  40bf30:	ba 00 0a 5a 00       	mov    edx,0x5a0a00
  40bf35:	48 89 fb             	mov    rbx,rdi
  40bf38:	4c 0f 44 e2          	cmove  r12,rdx
	assert(curr_defci_init_status == INITIALIZED);
  40bf3c:	83 3d ed 4a 19 00 01 	cmp    DWORD PTR [rip+0x194aed],0x1        # 5a0a30 <curr_defci_init_status>
	return &(defci->sched_aep[cos_cpuid()]);
  40bf43:	48 8d 87 e0 00 00 00 	lea    rax,[rdi+0xe0]
	assert(curr_defci_init_status == INITIALIZED);
  40bf4a:	0f 85 01 01 00 00    	jne    40c051 <cos_initaep_tcap_alloc+0x141>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40bf50:	66 0f ef c0          	pxor   xmm0,xmm0
  40bf54:	49 89 f5             	mov    r13,rsi
  40bf57:	0f 11 87 e0 00 00 00 	movups XMMWORD PTR [rdi+0xe0],xmm0
  40bf5e:	0f 11 40 10          	movups XMMWORD PTR [rax+0x10],xmm0
  40bf62:	0f 11 40 20          	movups XMMWORD PTR [rax+0x20],xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40bf66:	48 8b 77 10          	mov    rsi,QWORD PTR [rdi+0x10]
  40bf6a:	bf 20 09 5a 00       	mov    edi,0x5a0920
  40bf6f:	e8 5c 38 00 00       	call   40f7d0 <cos_initthd_alloc>
  40bf74:	48 89 83 e8 00 00 00 	mov    QWORD PTR [rbx+0xe8],rax
  40bf7b:	48 89 c6             	mov    rsi,rax
	assert(aep->thd);
  40bf7e:	48 85 c0             	test   rax,rax
  40bf81:	0f 84 e6 00 00 00    	je     40c06d <cos_initaep_tcap_alloc+0x15d>
	aep->tid  = cos_introspect(ci, aep->thd, THD_GET_TID);
  40bf87:	31 d2                	xor    edx,edx
  40bf89:	bf 20 09 5a 00       	mov    edi,0x5a0920
  40bf8e:	e8 ad 5b 00 00       	call   411b40 <cos_introspect>
  40bf93:	48 98                	cdqe   
  40bf95:	48 89 83 f0 00 00 00 	mov    QWORD PTR [rbx+0xf0],rax
	if (tc) {
  40bf9c:	4d 85 ed             	test   r13,r13
  40bf9f:	74 5f                	je     40c000 <cos_initaep_tcap_alloc+0xf0>
		aep->tc = tc;
  40bfa1:	4c 89 ab e0 00 00 00 	mov    QWORD PTR [rbx+0xe0],r13
	aep->rcv  = cos_arcv_alloc(ci, aep->thd, aep->tc, ci->comp_cap, sched->rcv);
  40bfa8:	48 8b b3 e8 00 00 00 	mov    rsi,QWORD PTR [rbx+0xe8]
  40bfaf:	4d 8b 44 24 18       	mov    r8,QWORD PTR [r12+0x18]
  40bfb4:	4c 89 ea             	mov    rdx,r13
  40bfb7:	bf 20 09 5a 00       	mov    edi,0x5a0920
  40bfbc:	48 8b 0d 6d 49 19 00 	mov    rcx,QWORD PTR [rip+0x19496d]        # 5a0930 <curr_defci+0x10>
  40bfc3:	e8 e8 4a 00 00       	call   410ab0 <cos_arcv_alloc>
  40bfc8:	48 89 83 f8 00 00 00 	mov    QWORD PTR [rbx+0xf8],rax
	assert(aep->rcv);
  40bfcf:	48 85 c0             	test   rax,rax
  40bfd2:	0f 84 b1 00 00 00    	je     40c089 <cos_initaep_tcap_alloc+0x179>
	aep->fn   = fn;
  40bfd8:	48 c7 83 00 01 00 00 	mov    QWORD PTR [rbx+0x100],0x0
  40bfdf:	00 00 00 00 

	return cos_aep_alloc_intern(child_aep, dst_dci, tc, sched_use, NULL, NULL, 0);
}
  40bfe3:	31 c0                	xor    eax,eax
	aep->data = data;
  40bfe5:	48 c7 83 08 01 00 00 	mov    QWORD PTR [rbx+0x108],0x0
  40bfec:	00 00 00 00 
}
  40bff0:	48 83 c4 08          	add    rsp,0x8
  40bff4:	5b                   	pop    rbx
  40bff5:	41 5c                	pop    r12
  40bff7:	41 5d                	pop    r13
  40bff9:	5d                   	pop    rbp
  40bffa:	c3                   	ret    
  40bffb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		aep->tc = cos_tcap_alloc(ci);
  40c000:	bf 20 09 5a 00       	mov    edi,0x5a0920
  40c005:	e8 96 5b 00 00       	call   411ba0 <cos_tcap_alloc>
  40c00a:	48 89 83 e0 00 00 00 	mov    QWORD PTR [rbx+0xe0],rax
  40c011:	49 89 c5             	mov    r13,rax
		assert(aep->tc);
  40c014:	48 85 c0             	test   rax,rax
  40c017:	75 8f                	jne    40bfa8 <cos_initaep_tcap_alloc+0x98>
  40c019:	be 31 00 00 00       	mov    esi,0x31
  40c01e:	bf 00 c4 41 00       	mov    edi,0x41c400
  40c023:	e8 a8 e0 ff ff       	call   40a0d0 <cos_print_str>
  40c028:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c02f:	00 00 00 00 
  40c033:	0f 0b                	ud2    
  40c035:	be 30 00 00 00       	mov    esi,0x30
  40c03a:	bf 70 c2 41 00       	mov    edi,0x41c270
  40c03f:	e8 8c e0 ff ff       	call   40a0d0 <cos_print_str>
	assert(defci);
  40c044:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c04b:	00 00 00 00 
  40c04f:	0f 0b                	ud2    
  40c051:	be 31 00 00 00       	mov    esi,0x31
  40c056:	bf 90 c3 41 00       	mov    edi,0x41c390
  40c05b:	e8 70 e0 ff ff       	call   40a0d0 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40c060:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c067:	00 00 00 00 
  40c06b:	0f 0b                	ud2    
  40c06d:	be 31 00 00 00       	mov    esi,0x31
  40c072:	bf c8 c3 41 00       	mov    edi,0x41c3c8
  40c077:	e8 54 e0 ff ff       	call   40a0d0 <cos_print_str>
	assert(aep->thd);
  40c07c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c083:	00 00 00 00 
  40c087:	0f 0b                	ud2    
  40c089:	be 31 00 00 00       	mov    esi,0x31
  40c08e:	bf 38 c4 41 00       	mov    edi,0x41c438
  40c093:	e8 38 e0 ff ff       	call   40a0d0 <cos_print_str>
	assert(aep->rcv);
  40c098:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c09f:	00 00 00 00 
  40c0a3:	0f 0b                	ud2    
  40c0a5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40c0ac:	00 00 00 00 

000000000040c0b0 <cos_aep_alloc_ext>:

int
cos_aep_alloc_ext(struct cos_aep_info *aep, struct cos_defcompinfo *dst_dci, struct cos_aep_info *sched, thdclosure_index_t idx)
{
  40c0b0:	f3 0f 1e fa          	endbr64 
  40c0b4:	55                   	push   rbp
  40c0b5:	48 89 e5             	mov    rbp,rsp
  40c0b8:	41 54                	push   r12
  40c0ba:	53                   	push   rbx
	struct cos_defcompinfo *defci     = cos_defcompinfo_curr_get();
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);

	assert(aep && idx > 0);
  40c0bb:	48 85 ff             	test   rdi,rdi
  40c0be:	0f 84 ef 00 00 00    	je     40c1b3 <cos_aep_alloc_ext+0x103>
  40c0c4:	49 89 d4             	mov    r12,rdx
  40c0c7:	89 ca                	mov    edx,ecx
  40c0c9:	85 c9                	test   ecx,ecx
  40c0cb:	0f 8e e2 00 00 00    	jle    40c1b3 <cos_aep_alloc_ext+0x103>
  40c0d1:	48 89 fb             	mov    rbx,rdi
	if (!sched) sched_aep = cos_sched_aep_get(dst_dci);
  40c0d4:	4d 85 e4             	test   r12,r12
  40c0d7:	74 27                	je     40c100 <cos_aep_alloc_ext+0x50>
	assert(defci);
  40c0d9:	48 85 f6             	test   rsi,rsi
  40c0dc:	75 32                	jne    40c110 <cos_aep_alloc_ext+0x60>
  40c0de:	be 30 00 00 00       	mov    esi,0x30
  40c0e3:	bf 38 c2 41 00       	mov    edi,0x41c238
  40c0e8:	e8 e3 df ff ff       	call   40a0d0 <cos_print_str>
  40c0ed:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c0f4:	00 00 00 00 
  40c0f8:	0f 0b                	ud2    
  40c0fa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	return &(defci->sched_aep[cos_cpuid()]);
  40c100:	4c 8d a6 e0 00 00 00 	lea    r12,[rsi+0xe0]
	assert(defci);
  40c107:	48 85 f6             	test   rsi,rsi
  40c10a:	0f 84 18 01 00 00    	je     40c228 <cos_aep_alloc_ext+0x178>
	assert(curr_defci_init_status == INITIALIZED);
  40c110:	83 3d 19 49 19 00 01 	cmp    DWORD PTR [rip+0x194919],0x1        # 5a0a30 <curr_defci_init_status>
  40c117:	0f 85 b3 00 00 00    	jne    40c1d0 <cos_aep_alloc_ext+0x120>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c11d:	66 0f ef c0          	pxor   xmm0,xmm0
	else if (idx > 0) aep->thd = cos_thd_alloc_ext(ci, dst_ci->comp_cap, idx);
  40c121:	bf 20 09 5a 00       	mov    edi,0x5a0920
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c126:	0f 11 03             	movups XMMWORD PTR [rbx],xmm0
  40c129:	0f 11 43 10          	movups XMMWORD PTR [rbx+0x10],xmm0
  40c12d:	0f 11 43 20          	movups XMMWORD PTR [rbx+0x20],xmm0
	else if (idx > 0) aep->thd = cos_thd_alloc_ext(ci, dst_ci->comp_cap, idx);
  40c131:	48 8b 76 10          	mov    rsi,QWORD PTR [rsi+0x10]
  40c135:	e8 b6 29 00 00       	call   40eaf0 <cos_thd_alloc_ext>
  40c13a:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  40c13e:	48 89 c6             	mov    rsi,rax
	assert(aep->thd);
  40c141:	48 85 c0             	test   rax,rax
  40c144:	0f 84 a6 00 00 00    	je     40c1f0 <cos_aep_alloc_ext+0x140>
	aep->tid  = cos_introspect(ci, aep->thd, THD_GET_TID);
  40c14a:	31 d2                	xor    edx,edx
  40c14c:	bf 20 09 5a 00       	mov    edi,0x5a0920
  40c151:	e8 ea 59 00 00       	call   411b40 <cos_introspect>
		aep->tc = cos_tcap_alloc(ci);
  40c156:	bf 20 09 5a 00       	mov    edi,0x5a0920
	aep->tid  = cos_introspect(ci, aep->thd, THD_GET_TID);
  40c15b:	48 98                	cdqe   
  40c15d:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
		aep->tc = cos_tcap_alloc(ci);
  40c161:	e8 3a 5a 00 00       	call   411ba0 <cos_tcap_alloc>
  40c166:	48 89 03             	mov    QWORD PTR [rbx],rax
  40c169:	48 89 c2             	mov    rdx,rax
		assert(aep->tc);
  40c16c:	48 85 c0             	test   rax,rax
  40c16f:	0f 84 97 00 00 00    	je     40c20c <cos_aep_alloc_ext+0x15c>
	aep->rcv  = cos_arcv_alloc(ci, aep->thd, aep->tc, ci->comp_cap, sched->rcv);
  40c175:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
  40c179:	4d 8b 44 24 18       	mov    r8,QWORD PTR [r12+0x18]
  40c17e:	bf 20 09 5a 00       	mov    edi,0x5a0920
  40c183:	48 8b 0d a6 47 19 00 	mov    rcx,QWORD PTR [rip+0x1947a6]        # 5a0930 <curr_defci+0x10>
  40c18a:	e8 21 49 00 00       	call   410ab0 <cos_arcv_alloc>
  40c18f:	48 89 43 18          	mov    QWORD PTR [rbx+0x18],rax
	assert(aep->rcv);
  40c193:	48 85 c0             	test   rax,rax
  40c196:	0f 84 a8 00 00 00    	je     40c244 <cos_aep_alloc_ext+0x194>
	aep->fn   = fn;
  40c19c:	48 c7 43 20 00 00 00 	mov    QWORD PTR [rbx+0x20],0x0
  40c1a3:	00 
	else        sched_aep = sched;

	return cos_aep_alloc_intern(aep, dst_dci, 0, sched_aep, NULL, NULL, idx);
}
  40c1a4:	31 c0                	xor    eax,eax
	aep->data = data;
  40c1a6:	48 c7 43 28 00 00 00 	mov    QWORD PTR [rbx+0x28],0x0
  40c1ad:	00 
}
  40c1ae:	5b                   	pop    rbx
  40c1af:	41 5c                	pop    r12
  40c1b1:	5d                   	pop    rbp
  40c1b2:	c3                   	ret    
  40c1b3:	be 31 00 00 00       	mov    esi,0x31
  40c1b8:	bf a8 c4 41 00       	mov    edi,0x41c4a8
  40c1bd:	e8 0e df ff ff       	call   40a0d0 <cos_print_str>
	assert(aep && idx > 0);
  40c1c2:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c1c9:	00 00 00 00 
  40c1cd:	0f 0b                	ud2    
  40c1cf:	90                   	nop
  40c1d0:	be 31 00 00 00       	mov    esi,0x31
  40c1d5:	bf 90 c3 41 00       	mov    edi,0x41c390
  40c1da:	e8 f1 de ff ff       	call   40a0d0 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40c1df:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c1e6:	00 00 00 00 
  40c1ea:	0f 0b                	ud2    
  40c1ec:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  40c1f0:	be 31 00 00 00       	mov    esi,0x31
  40c1f5:	bf c8 c3 41 00       	mov    edi,0x41c3c8
  40c1fa:	e8 d1 de ff ff       	call   40a0d0 <cos_print_str>
	assert(aep->thd);
  40c1ff:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c206:	00 00 00 00 
  40c20a:	0f 0b                	ud2    
  40c20c:	be 31 00 00 00       	mov    esi,0x31
  40c211:	bf 00 c4 41 00       	mov    edi,0x41c400
  40c216:	e8 b5 de ff ff       	call   40a0d0 <cos_print_str>
		assert(aep->tc);
  40c21b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c222:	00 00 00 00 
  40c226:	0f 0b                	ud2    
  40c228:	be 30 00 00 00       	mov    esi,0x30
  40c22d:	bf 70 c2 41 00       	mov    edi,0x41c270
  40c232:	e8 99 de ff ff       	call   40a0d0 <cos_print_str>
	assert(defci);
  40c237:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c23e:	00 00 00 00 
  40c242:	0f 0b                	ud2    
  40c244:	be 31 00 00 00       	mov    esi,0x31
  40c249:	bf 38 c4 41 00       	mov    edi,0x41c438
  40c24e:	e8 7d de ff ff       	call   40a0d0 <cos_print_str>
	assert(aep->rcv);
  40c253:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c25a:	00 00 00 00 
  40c25e:	0f 0b                	ud2    

000000000040c260 <cos_aep_tcap_alloc_ext>:

int
cos_aep_tcap_alloc_ext(struct cos_aep_info *aep, struct cos_defcompinfo *dst_dci, struct cos_aep_info *sched, tcap_t tc, thdclosure_index_t idx)
{
  40c260:	f3 0f 1e fa          	endbr64 
  40c264:	55                   	push   rbp
  40c265:	48 89 e5             	mov    rbp,rsp
  40c268:	41 55                	push   r13
  40c26a:	41 54                	push   r12
  40c26c:	53                   	push   rbx
  40c26d:	48 83 ec 08          	sub    rsp,0x8
	struct cos_defcompinfo *defci     = cos_defcompinfo_curr_get();
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);

	assert(aep);
  40c271:	48 85 ff             	test   rdi,rdi
  40c274:	0f 84 2b 01 00 00    	je     40c3a5 <cos_aep_tcap_alloc_ext+0x145>
	assert(idx > 0);
  40c27a:	45 85 c0             	test   r8d,r8d
  40c27d:	0f 8e 3e 01 00 00    	jle    40c3c1 <cos_aep_tcap_alloc_ext+0x161>
  40c283:	48 89 fb             	mov    rbx,rdi
  40c286:	49 89 d5             	mov    r13,rdx
  40c289:	49 89 cc             	mov    r12,rcx
	if (!sched) sched_aep = cos_sched_aep_get(dst_dci);
  40c28c:	48 85 d2             	test   rdx,rdx
  40c28f:	0f 84 ab 00 00 00    	je     40c340 <cos_aep_tcap_alloc_ext+0xe0>
	assert(defci);
  40c295:	48 85 f6             	test   rsi,rsi
  40c298:	0f 84 3f 01 00 00    	je     40c3dd <cos_aep_tcap_alloc_ext+0x17d>
	assert(curr_defci_init_status == INITIALIZED);
  40c29e:	83 3d 8b 47 19 00 01 	cmp    DWORD PTR [rip+0x19478b],0x1        # 5a0a30 <curr_defci_init_status>
  40c2a5:	0f 85 4e 01 00 00    	jne    40c3f9 <cos_aep_tcap_alloc_ext+0x199>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c2ab:	66 0f ef c0          	pxor   xmm0,xmm0
	else if (idx > 0) aep->thd = cos_thd_alloc_ext(ci, dst_ci->comp_cap, idx);
  40c2af:	44 89 c2             	mov    edx,r8d
  40c2b2:	bf 20 09 5a 00       	mov    edi,0x5a0920
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c2b7:	0f 11 03             	movups XMMWORD PTR [rbx],xmm0
  40c2ba:	0f 11 43 10          	movups XMMWORD PTR [rbx+0x10],xmm0
  40c2be:	0f 11 43 20          	movups XMMWORD PTR [rbx+0x20],xmm0
	else if (idx > 0) aep->thd = cos_thd_alloc_ext(ci, dst_ci->comp_cap, idx);
  40c2c2:	48 8b 76 10          	mov    rsi,QWORD PTR [rsi+0x10]
  40c2c6:	e8 25 28 00 00       	call   40eaf0 <cos_thd_alloc_ext>
  40c2cb:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  40c2cf:	48 89 c6             	mov    rsi,rax
	assert(aep->thd);
  40c2d2:	48 85 c0             	test   rax,rax
  40c2d5:	0f 84 3a 01 00 00    	je     40c415 <cos_aep_tcap_alloc_ext+0x1b5>
	aep->tid  = cos_introspect(ci, aep->thd, THD_GET_TID);
  40c2db:	31 d2                	xor    edx,edx
  40c2dd:	bf 20 09 5a 00       	mov    edi,0x5a0920
  40c2e2:	e8 59 58 00 00       	call   411b40 <cos_introspect>
  40c2e7:	48 98                	cdqe   
  40c2e9:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
	if (tc) {
  40c2ed:	4d 85 e4             	test   r12,r12
  40c2f0:	74 7e                	je     40c370 <cos_aep_tcap_alloc_ext+0x110>
		aep->tc = tc;
  40c2f2:	4c 89 23             	mov    QWORD PTR [rbx],r12
	aep->rcv  = cos_arcv_alloc(ci, aep->thd, aep->tc, ci->comp_cap, sched->rcv);
  40c2f5:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
  40c2f9:	4d 8b 45 18          	mov    r8,QWORD PTR [r13+0x18]
  40c2fd:	4c 89 e2             	mov    rdx,r12
  40c300:	bf 20 09 5a 00       	mov    edi,0x5a0920
  40c305:	48 8b 0d 24 46 19 00 	mov    rcx,QWORD PTR [rip+0x194624]        # 5a0930 <curr_defci+0x10>
  40c30c:	e8 9f 47 00 00       	call   410ab0 <cos_arcv_alloc>
  40c311:	48 89 43 18          	mov    QWORD PTR [rbx+0x18],rax
	assert(aep->rcv);
  40c315:	48 85 c0             	test   rax,rax
  40c318:	0f 84 13 01 00 00    	je     40c431 <cos_aep_tcap_alloc_ext+0x1d1>
	aep->fn   = fn;
  40c31e:	48 c7 43 20 00 00 00 	mov    QWORD PTR [rbx+0x20],0x0
  40c325:	00 
	else        sched_aep = sched;

	return cos_aep_alloc_intern(aep, dst_dci, tc, sched_aep, NULL, NULL, idx);
}
  40c326:	31 c0                	xor    eax,eax
	aep->data = data;
  40c328:	48 c7 43 28 00 00 00 	mov    QWORD PTR [rbx+0x28],0x0
  40c32f:	00 
}
  40c330:	48 83 c4 08          	add    rsp,0x8
  40c334:	5b                   	pop    rbx
  40c335:	41 5c                	pop    r12
  40c337:	41 5d                	pop    r13
  40c339:	5d                   	pop    rbp
  40c33a:	c3                   	ret    
  40c33b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	return &(defci->sched_aep[cos_cpuid()]);
  40c340:	4c 8d ae e0 00 00 00 	lea    r13,[rsi+0xe0]
	assert(defci);
  40c347:	48 85 f6             	test   rsi,rsi
  40c34a:	0f 85 4e ff ff ff    	jne    40c29e <cos_aep_tcap_alloc_ext+0x3e>
  40c350:	be 30 00 00 00       	mov    esi,0x30
  40c355:	bf 70 c2 41 00       	mov    edi,0x41c270
  40c35a:	e8 71 dd ff ff       	call   40a0d0 <cos_print_str>
  40c35f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c366:	00 00 00 00 
  40c36a:	0f 0b                	ud2    
  40c36c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		aep->tc = cos_tcap_alloc(ci);
  40c370:	bf 20 09 5a 00       	mov    edi,0x5a0920
  40c375:	e8 26 58 00 00       	call   411ba0 <cos_tcap_alloc>
  40c37a:	48 89 03             	mov    QWORD PTR [rbx],rax
  40c37d:	49 89 c4             	mov    r12,rax
		assert(aep->tc);
  40c380:	48 85 c0             	test   rax,rax
  40c383:	0f 85 6c ff ff ff    	jne    40c2f5 <cos_aep_tcap_alloc_ext+0x95>
  40c389:	be 31 00 00 00       	mov    esi,0x31
  40c38e:	bf 00 c4 41 00       	mov    edi,0x41c400
  40c393:	e8 38 dd ff ff       	call   40a0d0 <cos_print_str>
  40c398:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c39f:	00 00 00 00 
  40c3a3:	0f 0b                	ud2    
  40c3a5:	be 31 00 00 00       	mov    esi,0x31
  40c3aa:	bf e0 c4 41 00       	mov    edi,0x41c4e0
  40c3af:	e8 1c dd ff ff       	call   40a0d0 <cos_print_str>
	assert(aep);
  40c3b4:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c3bb:	00 00 00 00 
  40c3bf:	0f 0b                	ud2    
  40c3c1:	be 31 00 00 00       	mov    esi,0x31
  40c3c6:	bf 18 c5 41 00       	mov    edi,0x41c518
  40c3cb:	e8 00 dd ff ff       	call   40a0d0 <cos_print_str>
	assert(idx > 0);
  40c3d0:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c3d7:	00 00 00 00 
  40c3db:	0f 0b                	ud2    
  40c3dd:	be 30 00 00 00       	mov    esi,0x30
  40c3e2:	bf 38 c2 41 00       	mov    edi,0x41c238
  40c3e7:	e8 e4 dc ff ff       	call   40a0d0 <cos_print_str>
	assert(defci);
  40c3ec:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c3f3:	00 00 00 00 
  40c3f7:	0f 0b                	ud2    
  40c3f9:	be 31 00 00 00       	mov    esi,0x31
  40c3fe:	bf 90 c3 41 00       	mov    edi,0x41c390
  40c403:	e8 c8 dc ff ff       	call   40a0d0 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40c408:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c40f:	00 00 00 00 
  40c413:	0f 0b                	ud2    
  40c415:	be 31 00 00 00       	mov    esi,0x31
  40c41a:	bf c8 c3 41 00       	mov    edi,0x41c3c8
  40c41f:	e8 ac dc ff ff       	call   40a0d0 <cos_print_str>
	assert(aep->thd);
  40c424:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c42b:	00 00 00 00 
  40c42f:	0f 0b                	ud2    
  40c431:	be 31 00 00 00       	mov    esi,0x31
  40c436:	bf 38 c4 41 00       	mov    edi,0x41c438
  40c43b:	e8 90 dc ff ff       	call   40a0d0 <cos_print_str>
	assert(aep->rcv);
  40c440:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c447:	00 00 00 00 
  40c44b:	0f 0b                	ud2    
  40c44d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040c450 <cos_aep_alloc>:

int
cos_aep_alloc(struct cos_aep_info *aep, cos_aepthd_fn_t fn, void *data)
{
  40c450:	f3 0f 1e fa          	endbr64 
  40c454:	55                   	push   rbp
	int                     is_init = (!fn && !data && !idx);
  40c455:	48 89 d1             	mov    rcx,rdx
{
  40c458:	48 89 e5             	mov    rbp,rsp
  40c45b:	41 55                	push   r13
  40c45d:	49 89 d5             	mov    r13,rdx
  40c460:	41 54                	push   r12
  40c462:	49 89 f4             	mov    r12,rsi
  40c465:	53                   	push   rbx
  40c466:	48 89 fb             	mov    rbx,rdi
  40c469:	48 83 ec 08          	sub    rsp,0x8
	int                     is_init = (!fn && !data && !idx);
  40c46d:	48 09 f1             	or     rcx,rsi
	assert(curr_defci_init_status == INITIALIZED);
  40c470:	8b 05 ba 45 19 00    	mov    eax,DWORD PTR [rip+0x1945ba]        # 5a0a30 <curr_defci_init_status>
	int                     is_init = (!fn && !data && !idx);
  40c476:	0f 85 a4 00 00 00    	jne    40c520 <cos_aep_alloc+0xd0>
	assert(curr_defci_init_status == INITIALIZED);
  40c47c:	83 f8 01             	cmp    eax,0x1
  40c47f:	0f 85 d3 00 00 00    	jne    40c558 <cos_aep_alloc+0x108>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c485:	66 0f ef c0          	pxor   xmm0,xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40c489:	bf 20 09 5a 00       	mov    edi,0x5a0920
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c48e:	0f 11 03             	movups XMMWORD PTR [rbx],xmm0
  40c491:	0f 11 43 10          	movups XMMWORD PTR [rbx+0x10],xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40c495:	48 8b 35 94 44 19 00 	mov    rsi,QWORD PTR [rip+0x194494]        # 5a0930 <curr_defci+0x10>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c49c:	0f 11 43 20          	movups XMMWORD PTR [rbx+0x20],xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40c4a0:	e8 2b 33 00 00       	call   40f7d0 <cos_initthd_alloc>
  40c4a5:	48 89 c6             	mov    rsi,rax
  40c4a8:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
	assert(aep->thd);
  40c4ac:	48 85 f6             	test   rsi,rsi
  40c4af:	0f 84 bf 00 00 00    	je     40c574 <cos_aep_alloc+0x124>
	aep->tid  = cos_introspect(ci, aep->thd, THD_GET_TID);
  40c4b5:	31 d2                	xor    edx,edx
  40c4b7:	bf 20 09 5a 00       	mov    edi,0x5a0920
  40c4bc:	e8 7f 56 00 00       	call   411b40 <cos_introspect>
		aep->tc = cos_tcap_alloc(ci);
  40c4c1:	bf 20 09 5a 00       	mov    edi,0x5a0920
	aep->tid  = cos_introspect(ci, aep->thd, THD_GET_TID);
  40c4c6:	48 98                	cdqe   
  40c4c8:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
		aep->tc = cos_tcap_alloc(ci);
  40c4cc:	e8 cf 56 00 00       	call   411ba0 <cos_tcap_alloc>
  40c4d1:	48 89 03             	mov    QWORD PTR [rbx],rax
  40c4d4:	48 89 c2             	mov    rdx,rax
		assert(aep->tc);
  40c4d7:	48 85 c0             	test   rax,rax
  40c4da:	0f 84 b0 00 00 00    	je     40c590 <cos_aep_alloc+0x140>
	aep->rcv  = cos_arcv_alloc(ci, aep->thd, aep->tc, ci->comp_cap, sched->rcv);
  40c4e0:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
  40c4e4:	4c 8b 05 2d 45 19 00 	mov    r8,QWORD PTR [rip+0x19452d]        # 5a0a18 <curr_defci+0xf8>
  40c4eb:	bf 20 09 5a 00       	mov    edi,0x5a0920
  40c4f0:	48 8b 0d 39 44 19 00 	mov    rcx,QWORD PTR [rip+0x194439]        # 5a0930 <curr_defci+0x10>
  40c4f7:	e8 b4 45 00 00       	call   410ab0 <cos_arcv_alloc>
  40c4fc:	48 89 43 18          	mov    QWORD PTR [rbx+0x18],rax
	assert(aep->rcv);
  40c500:	48 85 c0             	test   rax,rax
  40c503:	0f 84 a3 00 00 00    	je     40c5ac <cos_aep_alloc+0x15c>
	aep->fn   = fn;
  40c509:	4c 89 63 20          	mov    QWORD PTR [rbx+0x20],r12
	struct cos_defcompinfo *defci     = cos_defcompinfo_curr_get();
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);

	return cos_aep_alloc_intern(aep, defci, 0, sched_aep, fn, data, 0);
}
  40c50d:	31 c0                	xor    eax,eax
	aep->data = data;
  40c50f:	4c 89 6b 28          	mov    QWORD PTR [rbx+0x28],r13
}
  40c513:	48 83 c4 08          	add    rsp,0x8
  40c517:	5b                   	pop    rbx
  40c518:	41 5c                	pop    r12
  40c51a:	41 5d                	pop    r13
  40c51c:	5d                   	pop    rbp
  40c51d:	c3                   	ret    
  40c51e:	66 90                	xchg   ax,ax
	assert(curr_defci_init_status == INITIALIZED);
  40c520:	83 f8 01             	cmp    eax,0x1
  40c523:	75 33                	jne    40c558 <cos_aep_alloc+0x108>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c525:	66 0f ef c0          	pxor   xmm0,xmm0
	else              aep->thd = cos_thd_alloc(ci, dst_ci->comp_cap, cos_aepthd_fn, (void *)aep);
  40c529:	48 89 d9             	mov    rcx,rbx
  40c52c:	ba 20 b8 40 00       	mov    edx,0x40b820
  40c531:	bf 20 09 5a 00       	mov    edi,0x5a0920
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c536:	0f 11 03             	movups XMMWORD PTR [rbx],xmm0
  40c539:	0f 11 43 10          	movups XMMWORD PTR [rbx+0x10],xmm0
	else              aep->thd = cos_thd_alloc(ci, dst_ci->comp_cap, cos_aepthd_fn, (void *)aep);
  40c53d:	48 8b 35 ec 43 19 00 	mov    rsi,QWORD PTR [rip+0x1943ec]        # 5a0930 <curr_defci+0x10>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c544:	0f 11 43 20          	movups XMMWORD PTR [rbx+0x20],xmm0
	else              aep->thd = cos_thd_alloc(ci, dst_ci->comp_cap, cos_aepthd_fn, (void *)aep);
  40c548:	e8 d3 25 00 00       	call   40eb20 <cos_thd_alloc>
  40c54d:	48 89 c6             	mov    rsi,rax
  40c550:	e9 53 ff ff ff       	jmp    40c4a8 <cos_aep_alloc+0x58>
  40c555:	0f 1f 00             	nop    DWORD PTR [rax]
  40c558:	be 31 00 00 00       	mov    esi,0x31
  40c55d:	bf 90 c3 41 00       	mov    edi,0x41c390
  40c562:	e8 69 db ff ff       	call   40a0d0 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40c567:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c56e:	00 00 00 00 
  40c572:	0f 0b                	ud2    
  40c574:	be 31 00 00 00       	mov    esi,0x31
  40c579:	bf c8 c3 41 00       	mov    edi,0x41c3c8
  40c57e:	e8 4d db ff ff       	call   40a0d0 <cos_print_str>
	assert(aep->thd);
  40c583:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c58a:	00 00 00 00 
  40c58e:	0f 0b                	ud2    
  40c590:	be 31 00 00 00       	mov    esi,0x31
  40c595:	bf 00 c4 41 00       	mov    edi,0x41c400
  40c59a:	e8 31 db ff ff       	call   40a0d0 <cos_print_str>
		assert(aep->tc);
  40c59f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c5a6:	00 00 00 00 
  40c5aa:	0f 0b                	ud2    
  40c5ac:	be 31 00 00 00       	mov    esi,0x31
  40c5b1:	bf 38 c4 41 00       	mov    edi,0x41c438
  40c5b6:	e8 15 db ff ff       	call   40a0d0 <cos_print_str>
	assert(aep->rcv);
  40c5bb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c5c2:	00 00 00 00 
  40c5c6:	0f 0b                	ud2    
  40c5c8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40c5cf:	00 

000000000040c5d0 <cos_aep_tcap_alloc>:

int
cos_aep_tcap_alloc(struct cos_aep_info *aep, tcap_t tc, cos_aepthd_fn_t fn, void *data)
{
  40c5d0:	f3 0f 1e fa          	endbr64 
  40c5d4:	55                   	push   rbp
	assert(curr_defci_init_status == INITIALIZED);
  40c5d5:	8b 05 55 44 19 00    	mov    eax,DWORD PTR [rip+0x194455]        # 5a0a30 <curr_defci_init_status>
{
  40c5db:	48 89 e5             	mov    rbp,rsp
  40c5de:	41 56                	push   r14
  40c5e0:	49 89 ce             	mov    r14,rcx
	int                     is_init = (!fn && !data && !idx);
  40c5e3:	48 09 d1             	or     rcx,rdx
{
  40c5e6:	41 55                	push   r13
  40c5e8:	49 89 d5             	mov    r13,rdx
  40c5eb:	41 54                	push   r12
  40c5ed:	49 89 f4             	mov    r12,rsi
  40c5f0:	53                   	push   rbx
  40c5f1:	48 89 fb             	mov    rbx,rdi
	int                     is_init = (!fn && !data && !idx);
  40c5f4:	0f 85 96 00 00 00    	jne    40c690 <cos_aep_tcap_alloc+0xc0>
	assert(curr_defci_init_status == INITIALIZED);
  40c5fa:	83 f8 01             	cmp    eax,0x1
  40c5fd:	0f 85 c5 00 00 00    	jne    40c6c8 <cos_aep_tcap_alloc+0xf8>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c603:	66 0f ef c0          	pxor   xmm0,xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40c607:	bf 20 09 5a 00       	mov    edi,0x5a0920
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c60c:	0f 11 03             	movups XMMWORD PTR [rbx],xmm0
  40c60f:	0f 11 43 10          	movups XMMWORD PTR [rbx+0x10],xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40c613:	48 8b 35 16 43 19 00 	mov    rsi,QWORD PTR [rip+0x194316]        # 5a0930 <curr_defci+0x10>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c61a:	0f 11 43 20          	movups XMMWORD PTR [rbx+0x20],xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40c61e:	e8 ad 31 00 00       	call   40f7d0 <cos_initthd_alloc>
  40c623:	48 89 c6             	mov    rsi,rax
  40c626:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
	assert(aep->thd);
  40c62a:	48 85 f6             	test   rsi,rsi
  40c62d:	0f 84 ea 00 00 00    	je     40c71d <cos_aep_tcap_alloc+0x14d>
	aep->tid  = cos_introspect(ci, aep->thd, THD_GET_TID);
  40c633:	31 d2                	xor    edx,edx
  40c635:	bf 20 09 5a 00       	mov    edi,0x5a0920
  40c63a:	e8 01 55 00 00       	call   411b40 <cos_introspect>
  40c63f:	48 98                	cdqe   
  40c641:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
	if (tc) {
  40c645:	4d 85 e4             	test   r12,r12
  40c648:	0f 84 9a 00 00 00    	je     40c6e8 <cos_aep_tcap_alloc+0x118>
		aep->tc = tc;
  40c64e:	4c 89 23             	mov    QWORD PTR [rbx],r12
	aep->rcv  = cos_arcv_alloc(ci, aep->thd, aep->tc, ci->comp_cap, sched->rcv);
  40c651:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
  40c655:	4c 8b 05 bc 43 19 00 	mov    r8,QWORD PTR [rip+0x1943bc]        # 5a0a18 <curr_defci+0xf8>
  40c65c:	4c 89 e2             	mov    rdx,r12
  40c65f:	bf 20 09 5a 00       	mov    edi,0x5a0920
  40c664:	48 8b 0d c5 42 19 00 	mov    rcx,QWORD PTR [rip+0x1942c5]        # 5a0930 <curr_defci+0x10>
  40c66b:	e8 40 44 00 00       	call   410ab0 <cos_arcv_alloc>
  40c670:	48 89 43 18          	mov    QWORD PTR [rbx+0x18],rax
	assert(aep->rcv);
  40c674:	48 85 c0             	test   rax,rax
  40c677:	0f 84 bc 00 00 00    	je     40c739 <cos_aep_tcap_alloc+0x169>
	aep->fn   = fn;
  40c67d:	4c 89 6b 20          	mov    QWORD PTR [rbx+0x20],r13
	struct cos_defcompinfo *defci     = cos_defcompinfo_curr_get();
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);

	return cos_aep_alloc_intern(aep, defci, tc, sched_aep, fn, data, 0);
}
  40c681:	31 c0                	xor    eax,eax
	aep->data = data;
  40c683:	4c 89 73 28          	mov    QWORD PTR [rbx+0x28],r14
}
  40c687:	5b                   	pop    rbx
  40c688:	41 5c                	pop    r12
  40c68a:	41 5d                	pop    r13
  40c68c:	41 5e                	pop    r14
  40c68e:	5d                   	pop    rbp
  40c68f:	c3                   	ret    
	assert(curr_defci_init_status == INITIALIZED);
  40c690:	83 f8 01             	cmp    eax,0x1
  40c693:	75 33                	jne    40c6c8 <cos_aep_tcap_alloc+0xf8>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c695:	66 0f ef c0          	pxor   xmm0,xmm0
	else              aep->thd = cos_thd_alloc(ci, dst_ci->comp_cap, cos_aepthd_fn, (void *)aep);
  40c699:	48 89 d9             	mov    rcx,rbx
  40c69c:	ba 20 b8 40 00       	mov    edx,0x40b820
  40c6a1:	bf 20 09 5a 00       	mov    edi,0x5a0920
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c6a6:	0f 11 03             	movups XMMWORD PTR [rbx],xmm0
  40c6a9:	0f 11 43 10          	movups XMMWORD PTR [rbx+0x10],xmm0
	else              aep->thd = cos_thd_alloc(ci, dst_ci->comp_cap, cos_aepthd_fn, (void *)aep);
  40c6ad:	48 8b 35 7c 42 19 00 	mov    rsi,QWORD PTR [rip+0x19427c]        # 5a0930 <curr_defci+0x10>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c6b4:	0f 11 43 20          	movups XMMWORD PTR [rbx+0x20],xmm0
	else              aep->thd = cos_thd_alloc(ci, dst_ci->comp_cap, cos_aepthd_fn, (void *)aep);
  40c6b8:	e8 63 24 00 00       	call   40eb20 <cos_thd_alloc>
  40c6bd:	48 89 c6             	mov    rsi,rax
  40c6c0:	e9 61 ff ff ff       	jmp    40c626 <cos_aep_tcap_alloc+0x56>
  40c6c5:	0f 1f 00             	nop    DWORD PTR [rax]
  40c6c8:	be 31 00 00 00       	mov    esi,0x31
  40c6cd:	bf 90 c3 41 00       	mov    edi,0x41c390
  40c6d2:	e8 f9 d9 ff ff       	call   40a0d0 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40c6d7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c6de:	00 00 00 00 
  40c6e2:	0f 0b                	ud2    
  40c6e4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		aep->tc = cos_tcap_alloc(ci);
  40c6e8:	bf 20 09 5a 00       	mov    edi,0x5a0920
  40c6ed:	e8 ae 54 00 00       	call   411ba0 <cos_tcap_alloc>
  40c6f2:	48 89 03             	mov    QWORD PTR [rbx],rax
  40c6f5:	49 89 c4             	mov    r12,rax
		assert(aep->tc);
  40c6f8:	48 85 c0             	test   rax,rax
  40c6fb:	0f 85 50 ff ff ff    	jne    40c651 <cos_aep_tcap_alloc+0x81>
  40c701:	be 31 00 00 00       	mov    esi,0x31
  40c706:	bf 00 c4 41 00       	mov    edi,0x41c400
  40c70b:	e8 c0 d9 ff ff       	call   40a0d0 <cos_print_str>
  40c710:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c717:	00 00 00 00 
  40c71b:	0f 0b                	ud2    
  40c71d:	be 31 00 00 00       	mov    esi,0x31
  40c722:	bf c8 c3 41 00       	mov    edi,0x41c3c8
  40c727:	e8 a4 d9 ff ff       	call   40a0d0 <cos_print_str>
	assert(aep->thd);
  40c72c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c733:	00 00 00 00 
  40c737:	0f 0b                	ud2    
  40c739:	be 31 00 00 00       	mov    esi,0x31
  40c73e:	bf 38 c4 41 00       	mov    edi,0x41c438
  40c743:	e8 88 d9 ff ff       	call   40a0d0 <cos_print_str>
	assert(aep->rcv);
  40c748:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c74f:	00 00 00 00 
  40c753:	0f 0b                	ud2    
  40c755:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40c75c:	00 00 00 00 

000000000040c760 <cos_defswitch>:

int
cos_defswitch(thdcap_t c, tcap_prio_t p, tcap_time_t r, sched_tok_t stok)
{
  40c760:	f3 0f 1e fa          	endbr64 
	struct cos_defcompinfo *defci     = cos_defcompinfo_curr_get();
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);

	assert(curr_defci_init_status == INITIALIZED);
  40c764:	83 3d c5 42 19 00 01 	cmp    DWORD PTR [rip+0x1942c5],0x1        # 5a0a30 <curr_defci_init_status>
  40c76b:	75 1c                	jne    40c789 <cos_defswitch+0x29>
  40c76d:	41 89 c9             	mov    r9d,ecx

	return cos_switch(c, sched_aep->tc, p, r, sched_aep->rcv, stok);
  40c770:	4c 8b 05 a1 42 19 00 	mov    r8,QWORD PTR [rip+0x1942a1]        # 5a0a18 <curr_defci+0xf8>
  40c777:	48 89 d1             	mov    rcx,rdx
  40c77a:	48 89 f2             	mov    rdx,rsi
  40c77d:	48 8b 35 7c 42 19 00 	mov    rsi,QWORD PTR [rip+0x19427c]        # 5a0a00 <curr_defci+0xe0>
  40c784:	e9 97 4b 00 00       	jmp    411320 <cos_switch>
{
  40c789:	55                   	push   rbp
  40c78a:	be 31 00 00 00       	mov    esi,0x31
  40c78f:	bf 50 c5 41 00       	mov    edi,0x41c550
  40c794:	48 89 e5             	mov    rbp,rsp
  40c797:	e8 34 d9 ff ff       	call   40a0d0 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40c79c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c7a3:	00 00 00 00 
  40c7a7:	0f 0b                	ud2    
  40c7a9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000040c7b0 <printc.constprop.0>:
printc(char *fmt, ...)
  40c7b0:	55                   	push   rbp
  40c7b1:	48 89 e5             	mov    rbp,rsp
  40c7b4:	48 81 ec 90 01 00 00 	sub    rsp,0x190
  40c7bb:	48 89 b5 58 ff ff ff 	mov    QWORD PTR [rbp-0xa8],rsi
  40c7c2:	48 89 95 60 ff ff ff 	mov    QWORD PTR [rbp-0xa0],rdx
  40c7c9:	48 89 8d 68 ff ff ff 	mov    QWORD PTR [rbp-0x98],rcx
  40c7d0:	4c 89 85 70 ff ff ff 	mov    QWORD PTR [rbp-0x90],r8
  40c7d7:	4c 89 8d 78 ff ff ff 	mov    QWORD PTR [rbp-0x88],r9
  40c7de:	84 c0                	test   al,al
  40c7e0:	74 20                	je     40c802 <printc.constprop.0+0x52>
  40c7e2:	0f 29 45 80          	movaps XMMWORD PTR [rbp-0x80],xmm0
  40c7e6:	0f 29 4d 90          	movaps XMMWORD PTR [rbp-0x70],xmm1
  40c7ea:	0f 29 55 a0          	movaps XMMWORD PTR [rbp-0x60],xmm2
  40c7ee:	0f 29 5d b0          	movaps XMMWORD PTR [rbp-0x50],xmm3
  40c7f2:	0f 29 65 c0          	movaps XMMWORD PTR [rbp-0x40],xmm4
  40c7f6:	0f 29 6d d0          	movaps XMMWORD PTR [rbp-0x30],xmm5
  40c7fa:	0f 29 75 e0          	movaps XMMWORD PTR [rbp-0x20],xmm6
  40c7fe:	0f 29 7d f0          	movaps XMMWORD PTR [rbp-0x10],xmm7
	va_start(arg_ptr, fmt);
  40c802:	48 8d 45 10          	lea    rax,[rbp+0x10]
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40c806:	ba a0 c5 41 00       	mov    edx,0x41c5a0
  40c80b:	be b4 00 00 00       	mov    esi,0xb4
	va_start(arg_ptr, fmt);
  40c810:	c7 85 78 fe ff ff 08 	mov    DWORD PTR [rbp-0x188],0x8
  40c817:	00 00 00 
  40c81a:	48 89 85 80 fe ff ff 	mov    QWORD PTR [rbp-0x180],rax
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40c821:	48 8d 8d 78 fe ff ff 	lea    rcx,[rbp-0x188]
	va_start(arg_ptr, fmt);
  40c828:	48 8d 85 50 ff ff ff 	lea    rax,[rbp-0xb0]
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40c82f:	48 8d bd 90 fe ff ff 	lea    rdi,[rbp-0x170]
	va_start(arg_ptr, fmt);
  40c836:	48 89 85 88 fe ff ff 	mov    QWORD PTR [rbp-0x178],rax
  40c83d:	c7 85 7c fe ff ff 30 	mov    DWORD PTR [rbp-0x184],0x30
  40c844:	00 00 00 
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40c847:	e8 54 8b 00 00       	call   4153a0 <vsnprintf>
	ret = cos_print_str(s, ret);
  40c84c:	48 8d bd 90 fe ff ff 	lea    rdi,[rbp-0x170]
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40c853:	89 c6                	mov    esi,eax
	ret = cos_print_str(s, ret);
  40c855:	e8 76 d8 ff ff       	call   40a0d0 <cos_print_str>
}
  40c85a:	c9                   	leave  
  40c85b:	c3                   	ret    
  40c85c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000040c860 <__mem_bump_alloc.constprop.0>:
}

/**************** [Memory Capability Allocation Functions] ***************/

static vaddr_t
__mem_bump_alloc(struct cos_compinfo *__ci, int km, int retype)
  40c860:	55                   	push   rbp
  40c861:	48 89 e5             	mov    rbp,rsp
  40c864:	41 55                	push   r13
  40c866:	41 54                	push   r12
  40c868:	53                   	push   rbx
  40c869:	48 83 ec 18          	sub    rsp,0x18
	struct cos_compinfo *ci;
	vaddr_t *            ptr, *frontier;

	printd("__mem_bump_alloc\n");

	assert(__ci);
  40c86d:	48 85 ff             	test   rdi,rdi
  40c870:	0f 84 2f 01 00 00    	je     40c9a5 <__mem_bump_alloc.constprop.0+0x145>
	return ci->memsrc;
  40c876:	4c 8b 57 60          	mov    r10,QWORD PTR [rdi+0x60]
        __asm__ __volatile__("lock " PS_CAS_STR
  40c87a:	be 01 00 00 00       	mov    esi,0x1
  40c87f:	31 c9                	xor    ecx,ecx
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40c881:	49 8d 92 b8 00 00 00 	lea    rdx,[r10+0xb8]
	ci = __compinfo_metacap(__ci);
	assert(ci && ci == __compinfo_metacap(__ci));
  40c888:	4d 85 d2             	test   r10,r10
  40c88b:	0f 84 30 01 00 00    	je     40c9c1 <__mem_bump_alloc.constprop.0+0x161>
  40c891:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  40c898:	48 89 c8             	mov    rax,rcx
  40c89b:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40c8a0:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40c8a3:	84 c0                	test   al,al
  40c8a5:	74 f1                	je     40c898 <__mem_bump_alloc.constprop.0+0x38>
        __asm__ __volatile__("lock " PS_FAA_STR
  40c8a7:	41 bd 00 10 00 00    	mov    r13d,0x1000
  40c8ad:	f0 4d 0f c1 6a 78    	lock xadd QWORD PTR [r10+0x78],r13
		frontier = &ci->mi.umem_frontier;
	}

	ret = ps_faa(ptr, PAGE_SIZE);

	if (ret >= *frontier || *frontier - ret > RETYPE_MEM_SIZE) {
  40c8b3:	49 8b 92 90 00 00 00 	mov    rdx,QWORD PTR [r10+0x90]
  40c8ba:	49 39 d5             	cmp    r13,rdx
  40c8bd:	0f 82 bd 00 00 00    	jb     40c980 <__mem_bump_alloc.constprop.0+0x120>
		vaddr_t ptr_tmp = *ptr, front_tmp = *frontier;
  40c8c3:	49 8b 42 78          	mov    rax,QWORD PTR [r10+0x78]

		/* TODO: expand frontier if introspection says there is more memory */
		if (ci->mi.untyped_ptr == ci->mi.untyped_frontier) goto error;
  40c8c7:	49 8b 9a 80 00 00 00 	mov    rbx,QWORD PTR [r10+0x80]
  40c8ce:	49 39 5a 68          	cmp    QWORD PTR [r10+0x68],rbx
  40c8d2:	0f 84 c8 00 00 00    	je     40c9a0 <__mem_bump_alloc.constprop.0+0x140>
  40c8d8:	41 bd 00 10 00 00    	mov    r13d,0x1000
  40c8de:	f0 4d 0f c1 6a 68    	lock xadd QWORD PTR [r10+0x68],r13
		/* this is the overall frontier, so we know we can use this value... */
		ret = ps_faa(&ci->mi.untyped_ptr, RETYPE_MEM_SIZE);
		/* failure here means that someone else already advanced the frontier/ptr */
		if (ps_cas(ptr, ptr_tmp, ret + PAGE_SIZE)) {
  40c8e4:	49 8d 8d 00 10 00 00 	lea    rcx,[r13+0x1000]
        __asm__ __volatile__("lock " PS_CAS_STR
  40c8eb:	f0 49 0f b1 4a 78    	lock cmpxchg QWORD PTR [r10+0x78],rcx
  40c8f1:	0f 94 c0             	sete   al
  40c8f4:	84 c0                	test   al,al
  40c8f6:	74 0f                	je     40c907 <__mem_bump_alloc.constprop.0+0xa7>
  40c8f8:	48 89 d0             	mov    rax,rdx
  40c8fb:	f0 49 0f b1 8a 90 00 	lock cmpxchg QWORD PTR [r10+0x90],rcx
  40c902:	00 00 
  40c904:	0f 94 c0             	sete   al
			ps_cas(frontier, front_tmp, ret + RETYPE_MEM_SIZE);
		}
	}

	if (retype && (ret % RETYPE_MEM_SIZE == 0)) {
  40c907:	4c 89 ea             	mov    rdx,r13
  40c90a:	81 e2 ff 0f 00 00    	and    edx,0xfff
  40c910:	75 50                	jne    40c962 <__mem_bump_alloc.constprop.0+0x102>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40c912:	41 8b 82 98 00 00 00 	mov    eax,DWORD PTR [r10+0x98]
	__asm__ __volatile__(
  40c919:	4c 89 eb             	mov    rbx,r13
  40c91c:	48 89 d6             	mov    rsi,rdx
  40c91f:	48 89 d7             	mov    rdi,rdx
  40c922:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40c926:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40c929:	05 1a 00 01 00       	add    eax,0x1001a
	__asm__ __volatile__(
  40c92e:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40c931:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40c935:	48 89 cd             	mov    rbp,rcx
  40c938:	49 b8 50 c9 40 00 00 	movabs r8,0x40c950
  40c93f:	00 00 00 
  40c942:	0f 05                	syscall 
  40c944:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  40c948:	eb 0d                	jmp    40c957 <__mem_bump_alloc.constprop.0+0xf7>
  40c94a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40c950:	b9 00 00 00 00       	mov    ecx,0x0
  40c955:	eb 05                	jmp    40c95c <__mem_bump_alloc.constprop.0+0xfc>
  40c957:	b9 01 00 00 00       	mov    ecx,0x1
  40c95c:	5d                   	pop    rbp
  40c95d:	5c                   	pop    rsp
		/* are we dealing with a kernel memory allocation? */
		syscall_op_t op = km ? CAPTBL_OP_MEM_RETYPE2KERN : CAPTBL_OP_MEM_RETYPE2USER;
		if (call_cap_op(ci->mi.pgtbl_cap, op, ret, 0, 0, 0)) goto error;
  40c95e:	85 c0                	test   eax,eax
  40c960:	75 3e                	jne    40c9a0 <__mem_bump_alloc.constprop.0+0x140>
  40c962:	49 c7 82 b8 00 00 00 	mov    QWORD PTR [r10+0xb8],0x0
  40c969:	00 00 00 00 
	return ret;
error:
	ps_lock_release(&ci->mem_lock);

	return 0;
}
  40c96d:	48 83 c4 18          	add    rsp,0x18
  40c971:	4c 89 e8             	mov    rax,r13
  40c974:	5b                   	pop    rbx
  40c975:	41 5c                	pop    r12
  40c977:	41 5d                	pop    r13
  40c979:	5d                   	pop    rbp
  40c97a:	c3                   	ret    
  40c97b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	if (ret >= *frontier || *frontier - ret > RETYPE_MEM_SIZE) {
  40c980:	48 89 d0             	mov    rax,rdx
  40c983:	4c 29 e8             	sub    rax,r13
  40c986:	48 3d 00 10 00 00    	cmp    rax,0x1000
  40c98c:	0f 86 75 ff ff ff    	jbe    40c907 <__mem_bump_alloc.constprop.0+0xa7>
  40c992:	e9 2c ff ff ff       	jmp    40c8c3 <__mem_bump_alloc.constprop.0+0x63>
  40c997:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40c99e:	00 00 
	return 0;
  40c9a0:	45 31 ed             	xor    r13d,r13d
  40c9a3:	eb bd                	jmp    40c962 <__mem_bump_alloc.constprop.0+0x102>
	return cos_print_str(s, strlen(s));
  40c9a5:	be 2e 00 00 00       	mov    esi,0x2e
  40c9aa:	bf b0 c5 41 00       	mov    edi,0x41c5b0
  40c9af:	e8 1c d7 ff ff       	call   40a0d0 <cos_print_str>
	assert(__ci);
  40c9b4:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c9bb:	00 00 00 00 
  40c9bf:	0f 0b                	ud2    
  40c9c1:	be 2e 00 00 00       	mov    esi,0x2e
  40c9c6:	bf e0 c5 41 00       	mov    edi,0x41c5e0
  40c9cb:	e8 00 d7 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci && ci == __compinfo_metacap(__ci));
  40c9d0:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c9d7:	00 00 00 00 
  40c9db:	0f 0b                	ud2    
  40c9dd:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040c9e0 <__capid_captbl_check_expand>:

static capid_t __capid_bump_alloc(struct cos_compinfo *ci, cap_t cap);

static int
__capid_captbl_check_expand(struct cos_compinfo *ci)
{
  40c9e0:	55                   	push   rbp
  40c9e1:	48 89 e5             	mov    rbp,rsp
  40c9e4:	41 57                	push   r15
  40c9e6:	41 56                	push   r14
  40c9e8:	41 55                	push   r13
  40c9ea:	41 54                	push   r12
  40c9ec:	53                   	push   rbx
  40c9ed:	48 83 ec 28          	sub    rsp,0x28
	return ci->memsrc;
  40c9f1:	4c 8b 67 60          	mov    r12,QWORD PTR [rdi+0x60]
	capid_t captblcap;
	capid_t captblid_add;
	vaddr_t kmem;

	/* ensure that we have bounded structure, and bounded recursion */
	assert(__compinfo_metacap(meta) == meta);
  40c9f5:	4d 39 64 24 60       	cmp    QWORD PTR [r12+0x60],r12
  40c9fa:	75 32                	jne    40ca2e <__capid_captbl_check_expand+0x4e>
	 * rest of the entry (internal fragmentation WRT the captbl
	 * capability).  Oh well.
	 */

	if (self_resources) {
		frontier = ps_load(&ci->caprange_frontier) - CAPMAX_ENTRY_SZ;
  40c9fc:	48 8b 5f 20          	mov    rbx,QWORD PTR [rdi+0x20]
  40ca00:	49 89 fd             	mov    r13,rdi
	if (self_resources) {
  40ca03:	4c 39 e7             	cmp    rdi,r12
  40ca06:	74 20                	je     40ca28 <__capid_captbl_check_expand+0x48>
	} else {
		frontier = ps_load(&ci->caprange_frontier);
	}
	assert(ci->cap_frontier <= frontier);
  40ca08:	49 39 5d 18          	cmp    QWORD PTR [r13+0x18],rbx
  40ca0c:	77 3c                	ja     40ca4a <__capid_captbl_check_expand+0x6a>

	/* Common case: */
	if (likely(ci->cap_frontier != frontier)) return 0;
  40ca0e:	74 56                	je     40ca66 <__capid_captbl_check_expand+0x86>
	frontier       = ps_load(&ci->cap_frontier);
	range_frontier = ps_faa(&ci->caprange_frontier, CAPTBL_EXPAND_SZ * 2);
	ps_cas(&ci->cap_frontier, frontier, range_frontier);

	return 0;
}
  40ca10:	48 83 c4 28          	add    rsp,0x28
  40ca14:	31 c0                	xor    eax,eax
  40ca16:	5b                   	pop    rbx
  40ca17:	41 5c                	pop    r12
  40ca19:	41 5d                	pop    r13
  40ca1b:	41 5e                	pop    r14
  40ca1d:	41 5f                	pop    r15
  40ca1f:	5d                   	pop    rbp
  40ca20:	c3                   	ret    
  40ca21:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		frontier = ps_load(&ci->caprange_frontier) - CAPMAX_ENTRY_SZ;
  40ca28:	48 83 eb 04          	sub    rbx,0x4
  40ca2c:	eb da                	jmp    40ca08 <__capid_captbl_check_expand+0x28>
  40ca2e:	be 2e 00 00 00       	mov    esi,0x2e
  40ca33:	bf 10 c6 41 00       	mov    edi,0x41c610
  40ca38:	e8 93 d6 ff ff       	call   40a0d0 <cos_print_str>
	assert(__compinfo_metacap(meta) == meta);
  40ca3d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ca44:	00 00 00 00 
  40ca48:	0f 0b                	ud2    
  40ca4a:	be 2e 00 00 00       	mov    esi,0x2e
  40ca4f:	bf 40 c6 41 00       	mov    edi,0x41c640
  40ca54:	e8 77 d6 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci->cap_frontier <= frontier);
  40ca59:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ca60:	00 00 00 00 
  40ca64:	0f 0b                	ud2    
	return __mem_bump_alloc(ci, 1, 1);
  40ca66:	4c 89 ef             	mov    rdi,r13
  40ca69:	e8 f2 fd ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40ca6e:	49 89 c6             	mov    r14,rax
	assert(kmem); /* FIXME: should have a failure semantics for capids */
  40ca71:	48 85 c0             	test   rax,rax
  40ca74:	0f 84 9f 01 00 00    	je     40cc19 <__capid_captbl_check_expand+0x239>
	if (self_resources) {
  40ca7a:	4d 39 e5             	cmp    r13,r12
  40ca7d:	74 69                	je     40cae8 <__capid_captbl_check_expand+0x108>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40ca7f:	49 8d 94 24 b0 00 00 	lea    rdx,[r12+0xb0]
  40ca86:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  40ca87:	be 01 00 00 00       	mov    esi,0x1
  40ca8c:	31 c9                	xor    ecx,ecx
  40ca8e:	66 90                	xchg   ax,ax
  40ca90:	48 89 c8             	mov    rax,rcx
  40ca93:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40ca98:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40ca9b:	84 c0                	test   al,al
  40ca9d:	74 f1                	je     40ca90 <__capid_captbl_check_expand+0xb0>
	ps_lock_take(&ci->cap_lock);
	/*
	 * Do we need a new cache-line in the capability table for
	 * this size of capability?
	 */
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40ca9f:	41 f6 44 24 38 03    	test   BYTE PTR [r12+0x38],0x3
  40caa5:	0f 84 4c 01 00 00    	je     40cbf7 <__capid_captbl_check_expand+0x217>
        __asm__ __volatile__("lock " PS_FAA_STR
  40caab:	bb 04 00 00 00       	mov    ebx,0x4
  40cab0:	f0 49 0f c1 5c 24 38 	lock xadd QWORD PTR [r12+0x38],rbx
{ l->o = 0; }
  40cab7:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40cabe:	00 00 00 00 00 
		assert(captblcap);
  40cac3:	48 85 db             	test   rbx,rbx
  40cac6:	75 20                	jne    40cae8 <__capid_captbl_check_expand+0x108>
  40cac8:	be 2e 00 00 00       	mov    esi,0x2e
  40cacd:	bf a0 c6 41 00       	mov    edi,0x41c6a0
  40cad2:	e8 f9 d5 ff ff       	call   40a0d0 <cos_print_str>
  40cad7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40cade:	00 00 00 00 
  40cae2:	0f 0b                	ud2    
  40cae4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	captblid_add = ps_load(&ci->caprange_frontier);
  40cae8:	4d 8b 7d 20          	mov    r15,QWORD PTR [r13+0x20]
	assert(captblid_add % CAPTBL_EXPAND_SZ == 0);
  40caec:	4c 89 f8             	mov    rax,r15
  40caef:	83 e0 7f             	and    eax,0x7f
  40caf2:	48 89 45 b8          	mov    QWORD PTR [rbp-0x48],rax
  40caf6:	0f 85 39 01 00 00    	jne    40cc35 <__capid_captbl_check_expand+0x255>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40cafc:	41 8b 44 24 08       	mov    eax,DWORD PTR [r12+0x8]
	__asm__ __volatile__(
  40cb01:	4c 8d 55 c0          	lea    r10,[rbp-0x40]
  40cb05:	ba 01 00 00 00       	mov    edx,0x1
  40cb0a:	4c 89 f7             	mov    rdi,r14
  40cb0d:	49 8b b4 24 98 00 00 	mov    rsi,QWORD PTR [r12+0x98]
  40cb14:	00 
  40cb15:	4c 89 d1             	mov    rcx,r10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40cb18:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40cb1b:	05 1e 00 01 00       	add    eax,0x1001e
	__asm__ __volatile__(
  40cb20:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40cb23:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40cb27:	48 89 cd             	mov    rbp,rcx
  40cb2a:	49 b8 40 cb 40 00 00 	movabs r8,0x40cb40
  40cb31:	00 00 00 
  40cb34:	0f 05                	syscall 
  40cb36:	66 90                	xchg   ax,ax
  40cb38:	eb 0d                	jmp    40cb47 <__capid_captbl_check_expand+0x167>
  40cb3a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40cb40:	b9 00 00 00 00       	mov    ecx,0x0
  40cb45:	eb 05                	jmp    40cb4c <__capid_captbl_check_expand+0x16c>
  40cb47:	b9 01 00 00 00       	mov    ecx,0x1
  40cb4c:	5d                   	pop    rbp
  40cb4d:	5c                   	pop    rsp
	if (call_cap_op(meta->captbl_cap, CAPTBL_OP_CAPTBLACTIVATE, captblcap, meta->mi.pgtbl_cap, kmem, 1)) {
  40cb4e:	85 c0                	test   eax,eax
  40cb50:	75 6d                	jne    40cbbf <__capid_captbl_check_expand+0x1df>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40cb52:	41 8b 45 08          	mov    eax,DWORD PTR [r13+0x8]
	__asm__ __volatile__(
  40cb56:	48 8b 7d b8          	mov    rdi,QWORD PTR [rbp-0x48]
  40cb5a:	4c 89 fe             	mov    rsi,r15
  40cb5d:	4c 89 d1             	mov    rcx,r10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40cb60:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40cb63:	48 89 fa             	mov    rdx,rdi
	cap_no += op;
  40cb66:	05 01 00 01 00       	add    eax,0x10001
	__asm__ __volatile__(
  40cb6b:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40cb6e:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40cb72:	48 89 cd             	mov    rbp,rcx
  40cb75:	49 b8 90 cb 40 00 00 	movabs r8,0x40cb90
  40cb7c:	00 00 00 
  40cb7f:	0f 05                	syscall 
  40cb81:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  40cb88:	eb 0d                	jmp    40cb97 <__capid_captbl_check_expand+0x1b7>
  40cb8a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40cb90:	b9 00 00 00 00       	mov    ecx,0x0
  40cb95:	eb 05                	jmp    40cb9c <__capid_captbl_check_expand+0x1bc>
  40cb97:	b9 01 00 00 00       	mov    ecx,0x1
  40cb9c:	5d                   	pop    rbp
  40cb9d:	5c                   	pop    rsp
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_CONS, captblcap, captblid_add, 0, 0)) {
  40cb9e:	85 c0                	test   eax,eax
  40cba0:	75 39                	jne    40cbdb <__capid_captbl_check_expand+0x1fb>
	frontier       = ps_load(&ci->cap_frontier);
  40cba2:	49 8b 45 18          	mov    rax,QWORD PTR [r13+0x18]
        __asm__ __volatile__("lock " PS_FAA_STR
  40cba6:	ba 00 01 00 00       	mov    edx,0x100
  40cbab:	f0 49 0f c1 55 20    	lock xadd QWORD PTR [r13+0x20],rdx
        __asm__ __volatile__("lock " PS_CAS_STR
  40cbb1:	f0 49 0f b1 55 18    	lock cmpxchg QWORD PTR [r13+0x18],rdx
  40cbb7:	0f 94 c0             	sete   al
	return 0;
  40cbba:	e9 51 fe ff ff       	jmp    40ca10 <__capid_captbl_check_expand+0x30>
  40cbbf:	be 2e 00 00 00       	mov    esi,0x2e
  40cbc4:	bf 00 c7 41 00       	mov    edi,0x41c700
  40cbc9:	e8 02 d5 ff ff       	call   40a0d0 <cos_print_str>
		assert(0); /* race condition? */
  40cbce:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40cbd5:	00 00 00 00 
  40cbd9:	0f 0b                	ud2    
  40cbdb:	be 2e 00 00 00       	mov    esi,0x2e
  40cbe0:	bf 30 c7 41 00       	mov    edi,0x41c730
  40cbe5:	e8 e6 d4 ff ff       	call   40a0d0 <cos_print_str>
		assert(0); /* race? */
  40cbea:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40cbf1:	00 00 00 00 
  40cbf5:	0f 0b                	ud2    
		if (__capid_captbl_check_expand(ci)) goto error;
  40cbf7:	4c 89 e7             	mov    rdi,r12
  40cbfa:	e8 e1 fd ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40cbff:	85 c0                	test   eax,eax
  40cc01:	75 4e                	jne    40cc51 <__capid_captbl_check_expand+0x271>
        __asm__ __volatile__("lock " PS_FAA_STR
  40cc03:	b8 04 00 00 00       	mov    eax,0x4
  40cc08:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40cc0f:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  40cc14:	e9 92 fe ff ff       	jmp    40caab <__capid_captbl_check_expand+0xcb>
  40cc19:	be 2e 00 00 00       	mov    esi,0x2e
  40cc1e:	bf 70 c6 41 00       	mov    edi,0x41c670
  40cc23:	e8 a8 d4 ff ff       	call   40a0d0 <cos_print_str>
	assert(kmem); /* FIXME: should have a failure semantics for capids */
  40cc28:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40cc2f:	00 00 00 00 
  40cc33:	0f 0b                	ud2    
  40cc35:	be 2e 00 00 00       	mov    esi,0x2e
  40cc3a:	bf d0 c6 41 00       	mov    edi,0x41c6d0
  40cc3f:	e8 8c d4 ff ff       	call   40a0d0 <cos_print_str>
	assert(captblid_add % CAPTBL_EXPAND_SZ == 0);
  40cc44:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40cc4b:	00 00 00 00 
  40cc4f:	0f 0b                	ud2    
{ l->o = 0; }
  40cc51:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40cc58:	00 00 00 00 00 
		assert(captblcap);
  40cc5d:	e9 66 fe ff ff       	jmp    40cac8 <__capid_captbl_check_expand+0xe8>
  40cc62:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40cc69:	00 00 00 00 
  40cc6d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040cc70 <__bump_mem_expand_range>:
	return pte_cap;
}

static vaddr_t
__bump_mem_expand_range(struct cos_compinfo *meta, pgtblcap_t cipgtbl, vaddr_t mem_ptr, unsigned long mem_sz, u32_t pgtbl_lvl)
{
  40cc70:	55                   	push   rbp
  40cc71:	48 89 e5             	mov    rbp,rsp
  40cc74:	41 57                	push   r15
  40cc76:	41 56                	push   r14
  40cc78:	41 55                	push   r13
  40cc7a:	41 54                	push   r12
  40cc7c:	53                   	push   rbx
  40cc7d:	48 83 ec 48          	sub    rsp,0x48
  40cc81:	48 89 55 b8          	mov    QWORD PTR [rbp-0x48],rdx
	vaddr_t addr, range;
	u8_t lvl = (u8_t)pgtbl_lvl;
	assert(lvl >= 0 && lvl < COS_PGTBL_DEPTH - 1);
  40cc85:	41 80 f8 02          	cmp    r8b,0x2
  40cc89:	0f 87 6f 02 00 00    	ja     40cefe <__bump_mem_expand_range+0x28e>
  40cc8f:	45 89 c7             	mov    r15d,r8d


#if defined(__x86_64__)
	vaddr_t tmp_frontier;
	range		 = cos_pgtbl_get_range(lvl);
  40cc92:	41 0f b6 d0          	movzx  edx,r8b
  40cc96:	76 18                	jbe    40ccb0 <__bump_mem_expand_range+0x40>
	}
	assert(round_up_to_pgd_page(addr) == round_up_to_pgd_page(mem_ptr + mem_sz));
#endif

	return mem_ptr;
}
  40cc98:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  40cc9c:	48 83 c4 48          	add    rsp,0x48
  40cca0:	5b                   	pop    rbx
  40cca1:	41 5c                	pop    r12
  40cca3:	41 5d                	pop    r13
  40cca5:	41 5e                	pop    r14
  40cca7:	41 5f                	pop    r15
  40cca9:	5d                   	pop    rbp
  40ccaa:	c3                   	ret    
  40ccab:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40ccb0:	49 89 fe             	mov    r14,rdi
  40ccb3:	48 89 f0             	mov    rax,rsi
	tmp_frontier = cos_pgtbl_round_up_to_page(lvl, mem_ptr + mem_sz);
  40ccb6:	48 03 4d b8          	add    rcx,QWORD PTR [rbp-0x48]
	switch (pgtbl_lvl)
  40ccba:	83 fa 01             	cmp    edx,0x1
  40ccbd:	0f 84 ae 01 00 00    	je     40ce71 <__bump_mem_expand_range+0x201>
  40ccc3:	83 fa 02             	cmp    edx,0x2
  40ccc6:	75 1f                	jne    40cce7 <__bump_mem_expand_range+0x77>
		return round_up_to_pgt2_page(vaddr);
  40ccc8:	48 81 c1 ff ff 1f 00 	add    rcx,0x1fffff
  40cccf:	48 c7 45 98 00 00 20 	mov    QWORD PTR [rbp-0x68],0x200000
  40ccd6:	00 
  40ccd7:	48 81 e1 00 00 e0 ff 	and    rcx,0xffffffffffe00000
  40ccde:	48 89 4d b0          	mov    QWORD PTR [rbp-0x50],rcx
  40cce2:	48 89 cf             	mov    rdi,rcx
  40cce5:	eb 33                	jmp    40cd1a <__bump_mem_expand_range+0xaa>
	switch (pgtbl_lvl)
  40cce7:	85 d2                	test   edx,edx
  40cce9:	75 ad                	jne    40cc98 <__bump_mem_expand_range+0x28>
		return round_up_to_pgt0_page(vaddr);
  40cceb:	48 ba ff ff ff ff 7f 	movabs rdx,0x7fffffffff
  40ccf2:	00 00 00 
  40ccf5:	48 bb 00 00 00 00 80 	movabs rbx,0x8000000000
  40ccfc:	00 00 00 
  40ccff:	48 01 d1             	add    rcx,rdx
  40cd02:	48 89 5d 98          	mov    QWORD PTR [rbp-0x68],rbx
  40cd06:	48 ba 00 00 00 00 80 	movabs rdx,0xffffff8000000000
  40cd0d:	ff ff ff 
  40cd10:	48 21 d1             	and    rcx,rdx
  40cd13:	48 89 4d b0          	mov    QWORD PTR [rbp-0x50],rcx
  40cd17:	48 89 cf             	mov    rdi,rcx
	for (addr = mem_ptr; addr < tmp_frontier; addr += range) {
  40cd1a:	48 8b 5d b8          	mov    rbx,QWORD PTR [rbp-0x48]
  40cd1e:	48 39 fb             	cmp    rbx,rdi
  40cd21:	0f 83 71 ff ff ff    	jae    40cc98 <__bump_mem_expand_range+0x28>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40cd27:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40cd2a:	48 89 5d a8          	mov    QWORD PTR [rbp-0x58],rbx
        __asm__ __volatile__("lock " PS_CAS_STR
  40cd2e:	41 bd 01 00 00 00    	mov    r13d,0x1
  40cd34:	05 01 00 01 00       	add    eax,0x10001
  40cd39:	89 45 a4             	mov    DWORD PTR [rbp-0x5c],eax
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  40cd3c:	4d 3b 76 60          	cmp    r14,QWORD PTR [r14+0x60]
  40cd40:	0f 85 0f 01 00 00    	jne    40ce55 <__bump_mem_expand_range+0x1e5>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40cd46:	49 8d 96 b0 00 00 00 	lea    rdx,[r14+0xb0]
        __asm__ __volatile__("lock " PS_CAS_STR
  40cd4d:	31 c9                	xor    ecx,ecx
  40cd4f:	90                   	nop
  40cd50:	48 89 c8             	mov    rax,rcx
  40cd53:	f0 4c 0f b1 2a       	lock cmpxchg QWORD PTR [rdx],r13
  40cd58:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40cd5b:	84 c0                	test   al,al
  40cd5d:	74 f1                	je     40cd50 <__bump_mem_expand_range+0xe0>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40cd5f:	41 f6 46 38 03       	test   BYTE PTR [r14+0x38],0x3
  40cd64:	0f 84 29 01 00 00    	je     40ce93 <__bump_mem_expand_range+0x223>
        __asm__ __volatile__("lock " PS_FAA_STR
  40cd6a:	bb 04 00 00 00       	mov    ebx,0x4
  40cd6f:	f0 49 0f c1 5e 38    	lock xadd QWORD PTR [r14+0x38],rbx
{ l->o = 0; }
  40cd75:	49 c7 86 b0 00 00 00 	mov    QWORD PTR [r14+0xb0],0x0
  40cd7c:	00 00 00 00 
	return __mem_bump_alloc(ci, 1, 1);
  40cd80:	4c 89 f7             	mov    rdi,r14
  40cd83:	e8 d8 fa ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40cd88:	48 89 c7             	mov    rdi,rax
		if (pte_cap == 0 || ptemem_cap == 0) {
  40cd8b:	48 85 db             	test   rbx,rbx
  40cd8e:	0f 84 1e 01 00 00    	je     40ceb2 <__bump_mem_expand_range+0x242>
  40cd94:	48 85 c0             	test   rax,rax
  40cd97:	0f 84 15 01 00 00    	je     40ceb2 <__bump_mem_expand_range+0x242>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40cd9d:	41 8b 46 08          	mov    eax,DWORD PTR [r14+0x8]
	__asm__ __volatile__(
  40cda1:	4c 8d 55 c0          	lea    r10,[rbp-0x40]
  40cda5:	49 8b b6 98 00 00 00 	mov    rsi,QWORD PTR [r14+0x98]
		if (call_cap_op(meta->captbl_cap, CAPTBL_OP_PGTBLACTIVATE, pte_cap, meta->mi.pgtbl_cap, ptemem_cap,
  40cdac:	41 8d 57 01          	lea    edx,[r15+0x1]
  40cdb0:	4c 89 d1             	mov    rcx,r10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40cdb3:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40cdb6:	05 1c 00 01 00       	add    eax,0x1001c
	__asm__ __volatile__(
  40cdbb:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40cdbe:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40cdc2:	48 89 cd             	mov    rbp,rcx
  40cdc5:	49 b8 e0 cd 40 00 00 	movabs r8,0x40cde0
  40cdcc:	00 00 00 
  40cdcf:	0f 05                	syscall 
  40cdd1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  40cdd8:	eb 0d                	jmp    40cde7 <__bump_mem_expand_range+0x177>
  40cdda:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40cde0:	b9 00 00 00 00       	mov    ecx,0x0
  40cde5:	eb 05                	jmp    40cdec <__bump_mem_expand_range+0x17c>
  40cde7:	b9 01 00 00 00       	mov    ecx,0x1
  40cdec:	5d                   	pop    rbp
  40cded:	5c                   	pop    rsp
  40cdee:	85 c0                	test   eax,eax
  40cdf0:	0f 85 d8 00 00 00    	jne    40cece <__bump_mem_expand_range+0x25e>
  40cdf6:	31 d2                	xor    edx,edx
  40cdf8:	8b 45 a4             	mov    eax,DWORD PTR [rbp-0x5c]
  40cdfb:	48 8b 75 a8          	mov    rsi,QWORD PTR [rbp-0x58]
  40cdff:	4c 89 d1             	mov    rcx,r10
  40ce02:	48 89 d7             	mov    rdi,rdx
  40ce05:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40ce08:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40ce0c:	48 89 cd             	mov    rbp,rcx
  40ce0f:	49 b8 28 ce 40 00 00 	movabs r8,0x40ce28
  40ce16:	00 00 00 
  40ce19:	0f 05                	syscall 
  40ce1b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40ce20:	eb 0d                	jmp    40ce2f <__bump_mem_expand_range+0x1bf>
  40ce22:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40ce28:	b9 00 00 00 00       	mov    ecx,0x0
  40ce2d:	eb 05                	jmp    40ce34 <__bump_mem_expand_range+0x1c4>
  40ce2f:	b9 01 00 00 00       	mov    ecx,0x1
  40ce34:	5d                   	pop    rbp
  40ce35:	5c                   	pop    rsp
	for (addr = mem_ptr; addr < tmp_frontier; addr += range) {
  40ce36:	48 8b 45 98          	mov    rax,QWORD PTR [rbp-0x68]
  40ce3a:	48 01 c6             	add    rsi,rax
  40ce3d:	48 89 75 a8          	mov    QWORD PTR [rbp-0x58],rsi
  40ce41:	48 3b 75 b0          	cmp    rsi,QWORD PTR [rbp-0x50]
  40ce45:	0f 83 4d fe ff ff    	jae    40cc98 <__bump_mem_expand_range+0x28>
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  40ce4b:	4d 3b 76 60          	cmp    r14,QWORD PTR [r14+0x60]
  40ce4f:	0f 84 f1 fe ff ff    	je     40cd46 <__bump_mem_expand_range+0xd6>
  40ce55:	be 2e 00 00 00       	mov    esi,0x2e
  40ce5a:	bf 90 c7 41 00       	mov    edi,0x41c790
  40ce5f:	e8 6c d2 ff ff       	call   40a0d0 <cos_print_str>
  40ce64:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ce6b:	00 00 00 00 
  40ce6f:	0f 0b                	ud2    
		return round_up_to_pgt1_page(vaddr);
  40ce71:	48 81 c1 ff ff ff 3f 	add    rcx,0x3fffffff
  40ce78:	48 c7 45 98 00 00 00 	mov    QWORD PTR [rbp-0x68],0x40000000
  40ce7f:	40 
  40ce80:	48 81 e1 00 00 00 c0 	and    rcx,0xffffffffc0000000
  40ce87:	48 89 4d b0          	mov    QWORD PTR [rbp-0x50],rcx
  40ce8b:	48 89 cf             	mov    rdi,rcx
  40ce8e:	e9 87 fe ff ff       	jmp    40cd1a <__bump_mem_expand_range+0xaa>
		if (__capid_captbl_check_expand(ci)) goto error;
  40ce93:	4c 89 f7             	mov    rdi,r14
  40ce96:	e8 45 fb ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40ce9b:	85 c0                	test   eax,eax
  40ce9d:	74 4b                	je     40ceea <__bump_mem_expand_range+0x27a>
  40ce9f:	49 c7 86 b0 00 00 00 	mov    QWORD PTR [r14+0xb0],0x0
  40cea6:	00 00 00 00 
	return __mem_bump_alloc(ci, 1, 1);
  40ceaa:	4c 89 f7             	mov    rdi,r14
  40cead:	e8 ae f9 ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40ceb2:	be 2e 00 00 00       	mov    esi,0x2e
  40ceb7:	bf c0 c7 41 00       	mov    edi,0x41c7c0
  40cebc:	e8 0f d2 ff ff       	call   40a0d0 <cos_print_str>
			assert(0);
  40cec1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40cec8:	00 00 00 00 
  40cecc:	0f 0b                	ud2    
  40cece:	be 2e 00 00 00       	mov    esi,0x2e
  40ced3:	bf f0 c7 41 00       	mov    edi,0x41c7f0
  40ced8:	e8 f3 d1 ff ff       	call   40a0d0 <cos_print_str>
				assert(0); /* race? */
  40cedd:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40cee4:	00 00 00 00 
  40cee8:	0f 0b                	ud2    
        __asm__ __volatile__("lock " PS_FAA_STR
  40ceea:	b8 04 00 00 00       	mov    eax,0x4
  40ceef:	f0 49 0f c1 46 18    	lock xadd QWORD PTR [r14+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40cef5:	49 89 46 38          	mov    QWORD PTR [r14+0x38],rax
  40cef9:	e9 6c fe ff ff       	jmp    40cd6a <__bump_mem_expand_range+0xfa>
  40cefe:	be 2e 00 00 00       	mov    esi,0x2e
  40cf03:	bf 60 c7 41 00       	mov    edi,0x41c760
  40cf08:	e8 c3 d1 ff ff       	call   40a0d0 <cos_print_str>
	assert(lvl >= 0 && lvl < COS_PGTBL_DEPTH - 1);
  40cf0d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40cf14:	00 00 00 00 
  40cf18:	0f 0b                	ud2    
  40cf1a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000040cf20 <__page_bump_valloc>:
	return heap_vaddr;
}

static vaddr_t
__page_bump_valloc(struct cos_compinfo *ci, size_t sz, size_t align)
{
  40cf20:	55                   	push   rbp
        __asm__ __volatile__("lock " PS_CAS_STR
  40cf21:	31 c9                	xor    ecx,ecx
  40cf23:	48 89 e5             	mov    rbp,rsp
  40cf26:	41 57                	push   r15
  40cf28:	49 89 d7             	mov    r15,rdx
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40cf2b:	48 8d 97 c0 00 00 00 	lea    rdx,[rdi+0xc0]
  40cf32:	41 56                	push   r14
  40cf34:	41 55                	push   r13
  40cf36:	41 54                	push   r12
  40cf38:	49 89 f4             	mov    r12,rsi
        __asm__ __volatile__("lock " PS_CAS_STR
  40cf3b:	be 01 00 00 00       	mov    esi,0x1
  40cf40:	53                   	push   rbx
  40cf41:	48 89 fb             	mov    rbx,rdi
  40cf44:	48 83 ec 38          	sub    rsp,0x38
  40cf48:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40cf4f:	00 
  40cf50:	48 89 c8             	mov    rax,rcx
  40cf53:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40cf58:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40cf5b:	84 c0                	test   al,al
  40cf5d:	74 f1                	je     40cf50 <__page_bump_valloc+0x30>
	vaddr_t ret_addr = 0;
	vaddr_t rounding; // how much we need to round up sz to handle alignment

	ps_lock_take(&ci->va_lock);
	rounding = round_up_to_pow2(ci->vas_frontier, align) - ci->vas_frontier;
  40cf5f:	48 8b 53 40          	mov    rdx,QWORD PTR [rbx+0x40]
  40cf63:	4c 89 f9             	mov    rcx,r15
	return ci->memsrc;
  40cf66:	48 8b 7b 60          	mov    rdi,QWORD PTR [rbx+0x60]
	rounding = round_up_to_pow2(ci->vas_frontier, align) - ci->vas_frontier;
  40cf6a:	48 f7 d9             	neg    rcx
  40cf6d:	4a 8d 44 3a ff       	lea    rax,[rdx+r15*1-0x1]
  40cf72:	48 21 c8             	and    rax,rcx
  40cf75:	48 29 d0             	sub    rax,rdx
	sz += rounding;
  40cf78:	49 01 c4             	add    r12,rax
	rounding = round_up_to_pow2(ci->vas_frontier, align) - ci->vas_frontier;
  40cf7b:	49 89 c3             	mov    r11,rax
	assert(sz % PAGE_SIZE == 0);
  40cf7e:	4d 89 e6             	mov    r14,r12
  40cf81:	41 81 e6 ff 0f 00 00 	and    r14d,0xfff
  40cf88:	0f 85 32 01 00 00    	jne    40d0c0 <__page_bump_valloc+0x1a0>
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  40cf8e:	48 3b 7f 60          	cmp    rdi,QWORD PTR [rdi+0x60]
  40cf92:	0f 85 44 01 00 00    	jne    40d0dc <__page_bump_valloc+0x1bc>
        __asm__ __volatile__("lock " PS_FAA_STR
  40cf98:	4c 89 e2             	mov    rdx,r12
  40cf9b:	f0 48 0f c1 53 40    	lock xadd QWORD PTR [rbx+0x40],rdx
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) pgtbl_flag = PGTBL_LVL_FLAG_VM;
  40cfa1:	31 c0                	xor    eax,eax
		if (heap_vaddr + sz > ci->vasrange_frontier[pgtbl_lvl]) {
  40cfa3:	4d 8d 0c 14          	lea    r9,[r12+rdx*1]
		return round_up_to_pgt0_page(vaddr);
  40cfa7:	48 89 7d b8          	mov    QWORD PTR [rbp-0x48],rdi
  40cfab:	4c 8d 6b 48          	lea    r13,[rbx+0x48]
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) pgtbl_flag = PGTBL_LVL_FLAG_VM;
  40cfaf:	80 bb d8 00 00 00 01 	cmp    BYTE PTR [rbx+0xd8],0x1
		return round_up_to_pgt0_page(vaddr);
  40cfb6:	48 b9 00 00 00 00 80 	movabs rcx,0xffffff8000000000
  40cfbd:	ff ff ff 
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) pgtbl_flag = PGTBL_LVL_FLAG_VM;
  40cfc0:	0f 94 c0             	sete   al
  40cfc3:	c1 e0 1f             	shl    eax,0x1f
  40cfc6:	89 45 c4             	mov    DWORD PTR [rbp-0x3c],eax
		return round_up_to_pgt0_page(vaddr);
  40cfc9:	48 b8 ff ff ff ff 7f 	movabs rax,0x7fffffffff
  40cfd0:	00 00 00 
  40cfd3:	4c 01 c8             	add    rax,r9
  40cfd6:	48 21 c8             	and    rax,rcx
  40cfd9:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
		if (heap_vaddr + sz > ci->vasrange_frontier[pgtbl_lvl]) {
  40cfdd:	4d 39 4d 00          	cmp    QWORD PTR [r13+0x0],r9
  40cfe1:	72 45                	jb     40d028 <__page_bump_valloc+0x108>
	for (pgtbl_lvl = 0; pgtbl_lvl < COS_PGTBL_DEPTH - 1; pgtbl_lvl++) {
  40cfe3:	49 83 c6 01          	add    r14,0x1
  40cfe7:	49 83 c5 08          	add    r13,0x8
  40cfeb:	49 83 fe 03          	cmp    r14,0x3
  40cfef:	75 ec                	jne    40cfdd <__page_bump_valloc+0xbd>
{ l->o = 0; }
  40cff1:	48 c7 83 c0 00 00 00 	mov    QWORD PTR [rbx+0xc0],0x0
  40cff8:	00 00 00 00 
	ret_addr = __page_bump_mem_alloc(ci, &ci->vas_frontier, &ci->vasrange_frontier[0], sz);
	ret_addr += rounding;
  40cffc:	4d 8d 04 13          	lea    r8,[r11+rdx*1]
	ps_lock_release(&ci->va_lock);
	assert(ret_addr % align == 0);
  40d000:	31 d2                	xor    edx,edx
  40d002:	4c 89 c0             	mov    rax,r8
  40d005:	49 f7 f7             	div    r15
  40d008:	48 85 d2             	test   rdx,rdx
  40d00b:	0f 85 e7 00 00 00    	jne    40d0f8 <__page_bump_valloc+0x1d8>

	return ret_addr;
}
  40d011:	48 83 c4 38          	add    rsp,0x38
  40d015:	4c 89 c0             	mov    rax,r8
  40d018:	5b                   	pop    rbx
  40d019:	41 5c                	pop    r12
  40d01b:	41 5d                	pop    r13
  40d01d:	41 5e                	pop    r14
  40d01f:	41 5f                	pop    r15
  40d021:	5d                   	pop    rbp
  40d022:	c3                   	ret    
  40d023:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
			retaddr = __bump_mem_expand_range(meta, ci->pgtbl_cap, heap_vaddr, sz, pgtbl_lvl | pgtbl_flag);
  40d028:	44 8b 45 c4          	mov    r8d,DWORD PTR [rbp-0x3c]
  40d02c:	48 8b 33             	mov    rsi,QWORD PTR [rbx]
  40d02f:	4c 89 e1             	mov    rcx,r12
  40d032:	4c 89 4d a0          	mov    QWORD PTR [rbp-0x60],r9
  40d036:	48 8b 7d b8          	mov    rdi,QWORD PTR [rbp-0x48]
  40d03a:	4c 89 5d a8          	mov    QWORD PTR [rbp-0x58],r11
  40d03e:	45 09 f0             	or     r8d,r14d
  40d041:	48 89 55 b0          	mov    QWORD PTR [rbp-0x50],rdx
  40d045:	e8 26 fc ff ff       	call   40cc70 <__bump_mem_expand_range>
			assert(retaddr);
  40d04a:	48 85 c0             	test   rax,rax
  40d04d:	0f 84 c1 00 00 00    	je     40d114 <__page_bump_valloc+0x1f4>
		return round_up_to_pgt1_page(vaddr);
  40d053:	4c 8b 4d a0          	mov    r9,QWORD PTR [rbp-0x60]
  40d057:	4d 8d 56 08          	lea    r10,[r14+0x8]
  40d05b:	4c 8b 5d a8          	mov    r11,QWORD PTR [rbp-0x58]
				tmp_frontier = cos_pgtbl_round_up_to_page(pgtbl_lvl, heap_vaddr + sz);
  40d05f:	45 89 f0             	mov    r8d,r14d
  40d062:	48 8b 55 b0          	mov    rdx,QWORD PTR [rbp-0x50]
		return round_up_to_pgt1_page(vaddr);
  40d066:	49 8d 81 ff ff ff 3f 	lea    rax,[r9+0x3fffffff]
		return round_up_to_pgt2_page(vaddr);
  40d06d:	49 8d b1 ff ff 1f 00 	lea    rsi,[r9+0x1fffff]
		return round_up_to_pgt1_page(vaddr);
  40d074:	48 25 00 00 00 c0    	and    rax,0xffffffffc0000000
		return round_up_to_pgt2_page(vaddr);
  40d07a:	48 81 e6 00 00 e0 ff 	and    rsi,0xffffffffffe00000
		return round_up_to_pgt1_page(vaddr);
  40d081:	48 89 c7             	mov    rdi,rax
				vaddr_t tmp = ps_load(&ci->vasrange_frontier[pgtbl_lvl]);
  40d084:	4a 8b 44 d3 08       	mov    rax,QWORD PTR [rbx+r10*8+0x8]
		return round_up_to_pgt1_page(vaddr);
  40d089:	48 89 f9             	mov    rcx,rdi
	switch (pgtbl_lvl)
  40d08c:	49 83 fe 01          	cmp    r14,0x1
  40d090:	74 0c                	je     40d09e <__page_bump_valloc+0x17e>
		return round_up_to_pgt0_page(vaddr);
  40d092:	48 8b 4d c8          	mov    rcx,QWORD PTR [rbp-0x38]
	switch (pgtbl_lvl)
  40d096:	41 83 f8 02          	cmp    r8d,0x2
		return round_up_to_pgt0_page(vaddr);
  40d09a:	48 0f 44 ce          	cmove  rcx,rsi
				if (tmp >= heap_vaddr + sz) break;
  40d09e:	49 39 c1             	cmp    r9,rax
  40d0a1:	0f 86 3c ff ff ff    	jbe    40cfe3 <__page_bump_valloc+0xc3>
        __asm__ __volatile__("lock " PS_CAS_STR
  40d0a7:	f0 49 0f b1 4d 00    	lock cmpxchg QWORD PTR [r13+0x0],rcx
  40d0ad:	0f 94 c0             	sete   al
				vaddr_t tmp = ps_load(&ci->vasrange_frontier[pgtbl_lvl]);
  40d0b0:	4a 8b 44 d3 08       	mov    rax,QWORD PTR [rbx+r10*8+0x8]
		return round_up_to_pgt1_page(vaddr);
  40d0b5:	48 89 f9             	mov    rcx,rdi
	switch (pgtbl_lvl)
  40d0b8:	49 83 fe 01          	cmp    r14,0x1
  40d0bc:	75 d4                	jne    40d092 <__page_bump_valloc+0x172>
  40d0be:	eb de                	jmp    40d09e <__page_bump_valloc+0x17e>
  40d0c0:	be 2e 00 00 00       	mov    esi,0x2e
  40d0c5:	bf 20 c8 41 00       	mov    edi,0x41c820
  40d0ca:	e8 01 d0 ff ff       	call   40a0d0 <cos_print_str>
	assert(sz % PAGE_SIZE == 0);
  40d0cf:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d0d6:	00 00 00 00 
  40d0da:	0f 0b                	ud2    
  40d0dc:	be 2e 00 00 00       	mov    esi,0x2e
  40d0e1:	bf 50 c8 41 00       	mov    edi,0x41c850
  40d0e6:	e8 e5 cf ff ff       	call   40a0d0 <cos_print_str>
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  40d0eb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d0f2:	00 00 00 00 
  40d0f6:	0f 0b                	ud2    
  40d0f8:	be 2e 00 00 00       	mov    esi,0x2e
  40d0fd:	bf b0 c8 41 00       	mov    edi,0x41c8b0
  40d102:	e8 c9 cf ff ff       	call   40a0d0 <cos_print_str>
	assert(ret_addr % align == 0);
  40d107:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d10e:	00 00 00 00 
  40d112:	0f 0b                	ud2    
  40d114:	be 2e 00 00 00       	mov    esi,0x2e
  40d119:	bf 80 c8 41 00       	mov    edi,0x41c880
  40d11e:	e8 ad cf ff ff       	call   40a0d0 <cos_print_str>
			assert(retaddr);
  40d123:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d12a:	00 00 00 00 
  40d12e:	0f 0b                	ud2    

000000000040d130 <__page_bump_alloc>:

static vaddr_t
__page_bump_alloc(struct cos_compinfo *ci, size_t sz, size_t align)
{
  40d130:	55                   	push   rbp
  40d131:	48 89 e5             	mov    rbp,rsp
  40d134:	41 57                	push   r15
  40d136:	49 89 ff             	mov    r15,rdi
  40d139:	41 56                	push   r14
  40d13b:	41 55                	push   r13
  40d13d:	41 54                	push   r12
  40d13f:	53                   	push   rbx
  40d140:	48 89 f3             	mov    rbx,rsi
  40d143:	48 83 ec 48          	sub    rsp,0x48
	return ci->memsrc;
  40d147:	48 8b 47 60          	mov    rax,QWORD PTR [rdi+0x60]
  40d14b:	48 89 45 a8          	mov    QWORD PTR [rbp-0x58],rax

	/*
	 * Allocate the virtual address range to map into.  This is
	 * atomic, so we will get a contiguous range of sz.
	 */
	heap_vaddr = __page_bump_valloc(ci, sz, align);
  40d14f:	e8 cc fd ff ff       	call   40cf20 <__page_bump_valloc>
  40d154:	48 89 45 98          	mov    QWORD PTR [rbp-0x68],rax
	if (unlikely(!heap_vaddr)) return 0;
  40d158:	48 85 c0             	test   rax,rax
  40d15b:	0f 84 ea 01 00 00    	je     40d34b <__page_bump_alloc+0x21b>
  40d161:	48 89 c7             	mov    rdi,rax
	heap_limit = heap_vaddr + sz;
  40d164:	48 89 d8             	mov    rax,rbx
  40d167:	48 01 f8             	add    rax,rdi
  40d16a:	48 89 7d b8          	mov    QWORD PTR [rbp-0x48],rdi
  40d16e:	48 89 45 a0          	mov    QWORD PTR [rbp-0x60],rax
	assert(heap_limit > heap_vaddr);
  40d172:	48 39 c7             	cmp    rdi,rax
  40d175:	0f 83 eb 01 00 00    	jae    40d366 <__page_bump_alloc+0x236>
	return ci->memsrc;
  40d17b:	4d 8b 77 60          	mov    r14,QWORD PTR [r15+0x60]
  40d17f:	41 bd 01 00 00 00    	mov    r13d,0x1
  40d185:	45 31 d2             	xor    r10d,r10d
	assert(ci && ci == __compinfo_metacap(__ci));
  40d188:	4d 85 f6             	test   r14,r14
  40d18b:	0f 84 7c 01 00 00    	je     40d30d <__page_bump_alloc+0x1dd>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40d191:	49 8d 96 b8 00 00 00 	lea    rdx,[r14+0xb8]
  40d198:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40d19f:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  40d1a0:	4c 89 d0             	mov    rax,r10
  40d1a3:	f0 4c 0f b1 2a       	lock cmpxchg QWORD PTR [rdx],r13
  40d1a8:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40d1ab:	84 c0                	test   al,al
  40d1ad:	74 f1                	je     40d1a0 <__page_bump_alloc+0x70>
        __asm__ __volatile__("lock " PS_FAA_STR
  40d1af:	bb 00 10 00 00       	mov    ebx,0x1000
  40d1b4:	f0 49 0f c1 5e 70    	lock xadd QWORD PTR [r14+0x70],rbx
	if (ret >= *frontier || *frontier - ret > RETYPE_MEM_SIZE) {
  40d1ba:	49 8b 96 88 00 00 00 	mov    rdx,QWORD PTR [r14+0x88]
  40d1c1:	48 39 d3             	cmp    rbx,rdx
  40d1c4:	73 0e                	jae    40d1d4 <__page_bump_alloc+0xa4>
  40d1c6:	48 89 d0             	mov    rax,rdx
  40d1c9:	48 29 d8             	sub    rax,rbx
  40d1cc:	48 3d 00 10 00 00    	cmp    rax,0x1000
  40d1d2:	76 43                	jbe    40d217 <__page_bump_alloc+0xe7>
		vaddr_t ptr_tmp = *ptr, front_tmp = *frontier;
  40d1d4:	49 8b 46 70          	mov    rax,QWORD PTR [r14+0x70]
		if (ci->mi.untyped_ptr == ci->mi.untyped_frontier) goto error;
  40d1d8:	49 8b 8e 80 00 00 00 	mov    rcx,QWORD PTR [r14+0x80]
  40d1df:	49 39 4e 68          	cmp    QWORD PTR [r14+0x68],rcx
  40d1e3:	0f 84 57 01 00 00    	je     40d340 <__page_bump_alloc+0x210>
  40d1e9:	bb 00 10 00 00       	mov    ebx,0x1000
  40d1ee:	f0 49 0f c1 5e 68    	lock xadd QWORD PTR [r14+0x68],rbx
		if (ps_cas(ptr, ptr_tmp, ret + PAGE_SIZE)) {
  40d1f4:	48 8d 8b 00 10 00 00 	lea    rcx,[rbx+0x1000]
        __asm__ __volatile__("lock " PS_CAS_STR
  40d1fb:	f0 49 0f b1 4e 70    	lock cmpxchg QWORD PTR [r14+0x70],rcx
  40d201:	0f 94 c0             	sete   al
  40d204:	84 c0                	test   al,al
  40d206:	74 0f                	je     40d217 <__page_bump_alloc+0xe7>
  40d208:	48 89 d0             	mov    rax,rdx
  40d20b:	f0 49 0f b1 8e 88 00 	lock cmpxchg QWORD PTR [r14+0x88],rcx
  40d212:	00 00 
  40d214:	0f 94 c0             	sete   al
	if (retype && (ret % RETYPE_MEM_SIZE == 0)) {
  40d217:	48 89 da             	mov    rdx,rbx
  40d21a:	81 e2 ff 0f 00 00    	and    edx,0xfff
  40d220:	0f 85 0a 01 00 00    	jne    40d330 <__page_bump_alloc+0x200>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40d226:	41 8b 86 98 00 00 00 	mov    eax,DWORD PTR [r14+0x98]
	__asm__ __volatile__(
  40d22d:	48 89 d6             	mov    rsi,rdx
  40d230:	48 89 d7             	mov    rdi,rdx
  40d233:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40d237:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40d23a:	05 19 00 01 00       	add    eax,0x10019
	__asm__ __volatile__(
  40d23f:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40d242:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40d246:	48 89 cd             	mov    rbp,rcx
  40d249:	49 b8 60 d2 40 00 00 	movabs r8,0x40d260
  40d250:	00 00 00 
  40d253:	0f 05                	syscall 
  40d255:	0f 1f 00             	nop    DWORD PTR [rax]
  40d258:	eb 0d                	jmp    40d267 <__page_bump_alloc+0x137>
  40d25a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40d260:	b9 00 00 00 00       	mov    ecx,0x0
  40d265:	eb 05                	jmp    40d26c <__page_bump_alloc+0x13c>
  40d267:	b9 01 00 00 00       	mov    ecx,0x1
  40d26c:	5d                   	pop    rbp
  40d26d:	5c                   	pop    rsp
		if (call_cap_op(ci->mi.pgtbl_cap, op, ret, 0, 0, 0)) goto error;
  40d26e:	85 c0                	test   eax,eax
  40d270:	0f 85 ca 00 00 00    	jne    40d340 <__page_bump_alloc+0x210>
{ l->o = 0; }
  40d276:	49 c7 86 b8 00 00 00 	mov    QWORD PTR [r14+0xb8],0x0
  40d27d:	00 00 00 00 
	 */
	for (heap_cursor = heap_vaddr; heap_cursor < heap_limit; heap_cursor += PAGE_SIZE) {
		vaddr_t umem;

		umem = __umem_bump_alloc(ci);
		if (!umem) return 0;
  40d281:	48 85 db             	test   rbx,rbx
  40d284:	0f 84 c1 00 00 00    	je     40d34b <__page_bump_alloc+0x21b>

		/* Actually map in the memory. */
		if (call_cap_op(meta->mi.pgtbl_cap, CAPTBL_OP_MEMACTIVATE, umem, ci->pgtbl_cap, heap_cursor, PAGE_ORDER)) {
  40d28a:	48 8b 45 a8          	mov    rax,QWORD PTR [rbp-0x58]
  40d28e:	49 8b 37             	mov    rsi,QWORD PTR [r15]
  40d291:	ba 0c 00 00 00       	mov    edx,0xc
  40d296:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  40d29a:	48 8b 7d b8          	mov    rdi,QWORD PTR [rbp-0x48]
  40d29e:	48 8b 80 98 00 00 00 	mov    rax,QWORD PTR [rax+0x98]
  40d2a5:	48 89 45 b0          	mov    QWORD PTR [rbp-0x50],rax
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40d2a9:	8b 45 b0             	mov    eax,DWORD PTR [rbp-0x50]
  40d2ac:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40d2af:	05 17 00 01 00       	add    eax,0x10017
	__asm__ __volatile__(
  40d2b4:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40d2b7:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40d2bb:	48 89 cd             	mov    rbp,rcx
  40d2be:	49 b8 d8 d2 40 00 00 	movabs r8,0x40d2d8
  40d2c5:	00 00 00 
  40d2c8:	0f 05                	syscall 
  40d2ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40d2d0:	eb 0d                	jmp    40d2df <__page_bump_alloc+0x1af>
  40d2d2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40d2d8:	b9 00 00 00 00       	mov    ecx,0x0
  40d2dd:	eb 05                	jmp    40d2e4 <__page_bump_alloc+0x1b4>
  40d2df:	b9 01 00 00 00       	mov    ecx,0x1
  40d2e4:	5d                   	pop    rbp
  40d2e5:	5c                   	pop    rsp
  40d2e6:	85 c0                	test   eax,eax
  40d2e8:	0f 85 94 00 00 00    	jne    40d382 <__page_bump_alloc+0x252>
	for (heap_cursor = heap_vaddr; heap_cursor < heap_limit; heap_cursor += PAGE_SIZE) {
  40d2ee:	48 81 45 b8 00 10 00 	add    QWORD PTR [rbp-0x48],0x1000
  40d2f5:	00 
  40d2f6:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  40d2fa:	48 39 45 a0          	cmp    QWORD PTR [rbp-0x60],rax
  40d2fe:	76 53                	jbe    40d353 <__page_bump_alloc+0x223>
	return ci->memsrc;
  40d300:	4d 8b 77 60          	mov    r14,QWORD PTR [r15+0x60]
	assert(ci && ci == __compinfo_metacap(__ci));
  40d304:	4d 85 f6             	test   r14,r14
  40d307:	0f 85 84 fe ff ff    	jne    40d191 <__page_bump_alloc+0x61>
  40d30d:	be 2e 00 00 00       	mov    esi,0x2e
  40d312:	bf e0 c5 41 00       	mov    edi,0x41c5e0
  40d317:	e8 b4 cd ff ff       	call   40a0d0 <cos_print_str>
  40d31c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d323:	00 00 00 00 
  40d327:	0f 0b                	ud2    
  40d329:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  40d330:	49 c7 86 b8 00 00 00 	mov    QWORD PTR [r14+0xb8],0x0
  40d337:	00 00 00 00 
		if (!umem) return 0;
  40d33b:	e9 4a ff ff ff       	jmp    40d28a <__page_bump_alloc+0x15a>
  40d340:	49 c7 86 b8 00 00 00 	mov    QWORD PTR [r14+0xb8],0x0
  40d347:	00 00 00 00 
  40d34b:	48 c7 45 98 00 00 00 	mov    QWORD PTR [rbp-0x68],0x0
  40d352:	00 
			return 0;
		}
	}

	return heap_vaddr;
}
  40d353:	48 8b 45 98          	mov    rax,QWORD PTR [rbp-0x68]
  40d357:	48 83 c4 48          	add    rsp,0x48
  40d35b:	5b                   	pop    rbx
  40d35c:	41 5c                	pop    r12
  40d35e:	41 5d                	pop    r13
  40d360:	41 5e                	pop    r14
  40d362:	41 5f                	pop    r15
  40d364:	5d                   	pop    rbp
  40d365:	c3                   	ret    
  40d366:	be 2e 00 00 00       	mov    esi,0x2e
  40d36b:	bf e0 c8 41 00       	mov    edi,0x41c8e0
  40d370:	e8 5b cd ff ff       	call   40a0d0 <cos_print_str>
	assert(heap_limit > heap_vaddr);
  40d375:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d37c:	00 00 00 00 
  40d380:	0f 0b                	ud2    
  40d382:	be 2e 00 00 00       	mov    esi,0x2e
  40d387:	bf 10 c9 41 00       	mov    edi,0x41c910
  40d38c:	e8 3f cd ff ff       	call   40a0d0 <cos_print_str>
			assert(0);
  40d391:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d398:	00 00 00 00 
  40d39c:	0f 0b                	ud2    
  40d39e:	66 90                	xchg   ax,ax

000000000040d3a0 <__bump_mem_expand_intern>:
{
  40d3a0:	55                   	push   rbp
  40d3a1:	48 89 e5             	mov    rbp,rsp
  40d3a4:	41 57                	push   r15
  40d3a6:	41 56                	push   r14
  40d3a8:	41 55                	push   r13
  40d3aa:	41 54                	push   r12
  40d3ac:	53                   	push   rbx
  40d3ad:	48 83 ec 28          	sub    rsp,0x28
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  40d3b1:	48 3b 7f 60          	cmp    rdi,QWORD PTR [rdi+0x60]
  40d3b5:	0f 85 b3 01 00 00    	jne    40d56e <__bump_mem_expand_intern+0x1ce>
  40d3bb:	49 89 f6             	mov    r14,rsi
  40d3be:	49 89 d7             	mov    r15,rdx
  40d3c1:	4c 8d 55 c0          	lea    r10,[rbp-0x40]
  40d3c5:	49 89 cd             	mov    r13,rcx
	if (!intern) {
  40d3c8:	48 85 c9             	test   rcx,rcx
  40d3cb:	0f 85 c9 00 00 00    	jne    40d49a <__bump_mem_expand_intern+0xfa>
  40d3d1:	49 89 fc             	mov    r12,rdi
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40d3d4:	48 8d 97 b0 00 00 00 	lea    rdx,[rdi+0xb0]
        __asm__ __volatile__("lock " PS_CAS_STR
  40d3db:	be 01 00 00 00       	mov    esi,0x1
  40d3e0:	31 c9                	xor    ecx,ecx
  40d3e2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40d3e8:	48 89 c8             	mov    rax,rcx
  40d3eb:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40d3f0:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40d3f3:	84 c0                	test   al,al
  40d3f5:	74 f1                	je     40d3e8 <__bump_mem_expand_intern+0x48>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40d3f7:	41 f6 44 24 38 03    	test   BYTE PTR [r12+0x38],0x3
  40d3fd:	0f 84 41 01 00 00    	je     40d544 <__bump_mem_expand_intern+0x1a4>
  40d403:	4c 89 45 b8          	mov    QWORD PTR [rbp-0x48],r8
        __asm__ __volatile__("lock " PS_FAA_STR
  40d407:	bb 04 00 00 00       	mov    ebx,0x4
  40d40c:	f0 49 0f c1 5c 24 38 	lock xadd QWORD PTR [r12+0x38],rbx
{ l->o = 0; }
  40d413:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40d41a:	00 00 00 00 00 
	return __mem_bump_alloc(ci, 1, 1);
  40d41f:	4c 89 e7             	mov    rdi,r12
	ret = ps_faa(capsz_frontier, sz);
  40d422:	49 89 dd             	mov    r13,rbx
	return __mem_bump_alloc(ci, 1, 1);
  40d425:	e8 36 f4 ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40d42a:	48 89 c7             	mov    rdi,rax
		if (pte_cap == 0 || ptemem_cap == 0) {
  40d42d:	48 85 db             	test   rbx,rbx
  40d430:	0f 84 f2 00 00 00    	je     40d528 <__bump_mem_expand_intern+0x188>
  40d436:	48 85 c0             	test   rax,rax
  40d439:	4c 8b 45 b8          	mov    r8,QWORD PTR [rbp-0x48]
  40d43d:	0f 84 e5 00 00 00    	je     40d528 <__bump_mem_expand_intern+0x188>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40d443:	41 8b 44 24 08       	mov    eax,DWORD PTR [r12+0x8]
	__asm__ __volatile__(
  40d448:	4c 8d 55 c0          	lea    r10,[rbp-0x40]
  40d44c:	49 8b b4 24 98 00 00 	mov    rsi,QWORD PTR [r12+0x98]
  40d453:	00 
		if (call_cap_op(meta->captbl_cap, CAPTBL_OP_PGTBLACTIVATE, pte_cap, meta->mi.pgtbl_cap, ptemem_cap,
  40d454:	49 8d 50 01          	lea    rdx,[r8+0x1]
  40d458:	4c 89 d1             	mov    rcx,r10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40d45b:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40d45e:	05 1c 00 01 00       	add    eax,0x1001c
	__asm__ __volatile__(
  40d463:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40d466:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40d46a:	48 89 cd             	mov    rbp,rcx
  40d46d:	49 b8 88 d4 40 00 00 	movabs r8,0x40d488
  40d474:	00 00 00 
  40d477:	0f 05                	syscall 
  40d479:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  40d480:	eb 0d                	jmp    40d48f <__bump_mem_expand_intern+0xef>
  40d482:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40d488:	b9 00 00 00 00       	mov    ecx,0x0
  40d48d:	eb 05                	jmp    40d494 <__bump_mem_expand_intern+0xf4>
  40d48f:	b9 01 00 00 00       	mov    ecx,0x1
  40d494:	5d                   	pop    rbp
  40d495:	5c                   	pop    rsp
  40d496:	85 c0                	test   eax,eax
  40d498:	75 5e                	jne    40d4f8 <__bump_mem_expand_intern+0x158>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40d49a:	41 c1 e6 10          	shl    r14d,0x10
	__asm__ __volatile__(
  40d49e:	31 d2                	xor    edx,edx
  40d4a0:	4c 89 eb             	mov    rbx,r13
  40d4a3:	4c 89 fe             	mov    rsi,r15
	cap_no += op;
  40d4a6:	41 8d 86 01 00 01 00 	lea    eax,[r14+0x10001]
	__asm__ __volatile__(
  40d4ad:	48 89 d7             	mov    rdi,rdx
  40d4b0:	4c 89 d1             	mov    rcx,r10
  40d4b3:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40d4b6:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40d4ba:	48 89 cd             	mov    rbp,rcx
  40d4bd:	49 b8 d8 d4 40 00 00 	movabs r8,0x40d4d8
  40d4c4:	00 00 00 
  40d4c7:	0f 05                	syscall 
  40d4c9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  40d4d0:	eb 0d                	jmp    40d4df <__bump_mem_expand_intern+0x13f>
  40d4d2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40d4d8:	b9 00 00 00 00       	mov    ecx,0x0
  40d4dd:	eb 05                	jmp    40d4e4 <__bump_mem_expand_intern+0x144>
  40d4df:	b9 01 00 00 00       	mov    ecx,0x1
  40d4e4:	5d                   	pop    rbp
  40d4e5:	5c                   	pop    rsp
}
  40d4e6:	48 83 c4 28          	add    rsp,0x28
  40d4ea:	4c 89 e8             	mov    rax,r13
  40d4ed:	5b                   	pop    rbx
  40d4ee:	41 5c                	pop    r12
  40d4f0:	41 5d                	pop    r13
  40d4f2:	41 5e                	pop    r14
  40d4f4:	41 5f                	pop    r15
  40d4f6:	5d                   	pop    rbp
  40d4f7:	c3                   	ret    
  40d4f8:	be 2e 00 00 00       	mov    esi,0x2e
  40d4fd:	bf f0 c7 41 00       	mov    edi,0x41c7f0
  40d502:	e8 c9 cb ff ff       	call   40a0d0 <cos_print_str>
				assert(0); /* race? */
  40d507:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d50e:	00 00 00 00 
  40d512:	0f 0b                	ud2    
  40d514:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40d51b:	00 00 00 00 00 
	return __mem_bump_alloc(ci, 1, 1);
  40d520:	4c 89 e7             	mov    rdi,r12
  40d523:	e8 38 f3 ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40d528:	be 2e 00 00 00       	mov    esi,0x2e
  40d52d:	bf c0 c7 41 00       	mov    edi,0x41c7c0
  40d532:	e8 99 cb ff ff       	call   40a0d0 <cos_print_str>
			assert(0);
  40d537:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d53e:	00 00 00 00 
  40d542:	0f 0b                	ud2    
		if (__capid_captbl_check_expand(ci)) goto error;
  40d544:	4c 89 e7             	mov    rdi,r12
  40d547:	4c 89 45 b8          	mov    QWORD PTR [rbp-0x48],r8
  40d54b:	e8 90 f4 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40d550:	4c 8b 45 b8          	mov    r8,QWORD PTR [rbp-0x48]
  40d554:	85 c0                	test   eax,eax
  40d556:	75 bc                	jne    40d514 <__bump_mem_expand_intern+0x174>
        __asm__ __volatile__("lock " PS_FAA_STR
  40d558:	b8 04 00 00 00       	mov    eax,0x4
  40d55d:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40d564:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  40d569:	e9 95 fe ff ff       	jmp    40d403 <__bump_mem_expand_intern+0x63>
  40d56e:	be 2e 00 00 00       	mov    esi,0x2e
  40d573:	bf 90 c7 41 00       	mov    edi,0x41c790
  40d578:	e8 53 cb ff ff       	call   40a0d0 <cos_print_str>
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  40d57d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d584:	00 00 00 00 
  40d588:	0f 0b                	ud2    
  40d58a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000040d590 <__round_to_pgt0_page>:
vaddr_t __round_to_pgt0_page(vaddr_t vaddr) { return round_to_pgt0_page(vaddr); }
  40d590:	f3 0f 1e fa          	endbr64 
  40d594:	48 b8 00 00 00 00 80 	movabs rax,0xffffff8000000000
  40d59b:	ff ff ff 
  40d59e:	48 21 f8             	and    rax,rdi
  40d5a1:	c3                   	ret    
  40d5a2:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40d5a9:	00 00 00 00 
  40d5ad:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040d5b0 <__round_up_to_pgt0_page>:
vaddr_t __round_up_to_pgt0_page(vaddr_t vaddr) { return round_up_to_pgt0_page(vaddr); }
  40d5b0:	f3 0f 1e fa          	endbr64 
  40d5b4:	48 b8 ff ff ff ff 7f 	movabs rax,0x7fffffffff
  40d5bb:	00 00 00 
  40d5be:	48 ba 00 00 00 00 80 	movabs rdx,0xffffff8000000000
  40d5c5:	ff ff ff 
  40d5c8:	48 01 f8             	add    rax,rdi
  40d5cb:	48 21 d0             	and    rax,rdx
  40d5ce:	c3                   	ret    
  40d5cf:	90                   	nop

000000000040d5d0 <__round_to_pgt1_page>:
vaddr_t __round_to_pgt1_page(vaddr_t vaddr) { return round_to_pgt1_page(vaddr); }
  40d5d0:	f3 0f 1e fa          	endbr64 
  40d5d4:	48 89 f8             	mov    rax,rdi
  40d5d7:	48 25 00 00 00 c0    	and    rax,0xffffffffc0000000
  40d5dd:	c3                   	ret    
  40d5de:	66 90                	xchg   ax,ax

000000000040d5e0 <__round_up_to_pgt1_page>:
vaddr_t __round_up_to_pgt1_page(vaddr_t vaddr) { return round_up_to_pgt1_page(vaddr); }
  40d5e0:	f3 0f 1e fa          	endbr64 
  40d5e4:	48 8d 87 ff ff ff 3f 	lea    rax,[rdi+0x3fffffff]
  40d5eb:	48 25 00 00 00 c0    	and    rax,0xffffffffc0000000
  40d5f1:	c3                   	ret    
  40d5f2:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40d5f9:	00 00 00 00 
  40d5fd:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040d600 <__round_to_pgt2_page>:
vaddr_t __round_to_pgt2_page(vaddr_t vaddr) { return round_to_pgt2_page(vaddr); }
  40d600:	f3 0f 1e fa          	endbr64 
  40d604:	48 89 f8             	mov    rax,rdi
  40d607:	48 25 00 00 e0 ff    	and    rax,0xffffffffffe00000
  40d60d:	c3                   	ret    
  40d60e:	66 90                	xchg   ax,ax

000000000040d610 <__round_up_to_pgt2_page>:
vaddr_t __round_up_to_pgt2_page(vaddr_t vaddr) { return round_up_to_pgt2_page(vaddr); }
  40d610:	f3 0f 1e fa          	endbr64 
  40d614:	48 8d 87 ff ff 1f 00 	lea    rax,[rdi+0x1fffff]
  40d61b:	48 25 00 00 e0 ff    	and    rax,0xffffffffffe00000
  40d621:	c3                   	ret    
  40d622:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40d629:	00 00 00 00 
  40d62d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040d630 <cos_pgtbl_get_range>:
{
  40d630:	f3 0f 1e fa          	endbr64 
  40d634:	31 c0                	xor    eax,eax
  40d636:	83 ff 02             	cmp    edi,0x2
  40d639:	77 0a                	ja     40d645 <cos_pgtbl_get_range+0x15>
  40d63b:	89 ff                	mov    edi,edi
  40d63d:	48 8b 04 fd 50 d9 41 	mov    rax,QWORD PTR [rdi*8+0x41d950]
  40d644:	00 
}
  40d645:	c3                   	ret    
  40d646:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40d64d:	00 00 00 

000000000040d650 <cos_pgtbl_round_to_page>:
{
  40d650:	f3 0f 1e fa          	endbr64 
		return round_to_pgt1_page(vaddr);
  40d654:	48 89 f0             	mov    rax,rsi
  40d657:	48 25 00 00 00 c0    	and    rax,0xffffffffc0000000
	switch (pgtbl_lvl)
  40d65d:	83 ff 01             	cmp    edi,0x1
  40d660:	74 14                	je     40d676 <cos_pgtbl_round_to_page+0x26>
		return round_to_pgt2_page(vaddr);
  40d662:	48 89 f0             	mov    rax,rsi
  40d665:	48 25 00 00 e0 ff    	and    rax,0xffffffffffe00000
	switch (pgtbl_lvl)
  40d66b:	83 ff 02             	cmp    edi,0x2
  40d66e:	74 06                	je     40d676 <cos_pgtbl_round_to_page+0x26>
  40d670:	31 c0                	xor    eax,eax
  40d672:	85 ff                	test   edi,edi
  40d674:	74 0a                	je     40d680 <cos_pgtbl_round_to_page+0x30>
}
  40d676:	c3                   	ret    
  40d677:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40d67e:	00 00 
		return round_to_pgt0_page(vaddr);
  40d680:	48 b8 00 00 00 00 80 	movabs rax,0xffffff8000000000
  40d687:	ff ff ff 
  40d68a:	48 21 f0             	and    rax,rsi
}
  40d68d:	c3                   	ret    
  40d68e:	66 90                	xchg   ax,ax

000000000040d690 <cos_pgtbl_round_up_to_page>:
{
  40d690:	f3 0f 1e fa          	endbr64 
	switch (pgtbl_lvl)
  40d694:	83 ff 01             	cmp    edi,0x1
  40d697:	74 47                	je     40d6e0 <cos_pgtbl_round_up_to_page+0x50>
  40d699:	83 ff 02             	cmp    edi,0x2
  40d69c:	74 2a                	je     40d6c8 <cos_pgtbl_round_up_to_page+0x38>
  40d69e:	31 c0                	xor    eax,eax
  40d6a0:	85 ff                	test   edi,edi
  40d6a2:	74 04                	je     40d6a8 <cos_pgtbl_round_up_to_page+0x18>
}
  40d6a4:	c3                   	ret    
  40d6a5:	0f 1f 00             	nop    DWORD PTR [rax]
		return round_up_to_pgt0_page(vaddr);
  40d6a8:	48 b8 ff ff ff ff 7f 	movabs rax,0x7fffffffff
  40d6af:	00 00 00 
  40d6b2:	48 ba 00 00 00 00 80 	movabs rdx,0xffffff8000000000
  40d6b9:	ff ff ff 
  40d6bc:	48 01 f0             	add    rax,rsi
  40d6bf:	48 21 d0             	and    rax,rdx
  40d6c2:	c3                   	ret    
  40d6c3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		return round_up_to_pgt2_page(vaddr);
  40d6c8:	48 8d 86 ff ff 1f 00 	lea    rax,[rsi+0x1fffff]
  40d6cf:	48 25 00 00 e0 ff    	and    rax,0xffffffffffe00000
}
  40d6d5:	c3                   	ret    
  40d6d6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40d6dd:	00 00 00 
		return round_up_to_pgt1_page(vaddr);
  40d6e0:	48 8d 86 ff ff ff 3f 	lea    rax,[rsi+0x3fffffff]
  40d6e7:	48 25 00 00 00 c0    	and    rax,0xffffffffc0000000
  40d6ed:	c3                   	ret    
  40d6ee:	66 90                	xchg   ax,ax

000000000040d6f0 <cos_meminfo_init>:
{
  40d6f0:	f3 0f 1e fa          	endbr64 
	mi->untyped_frontier = untyped_ptr + untyped_sz;
  40d6f4:	48 01 f2             	add    rdx,rsi
  40d6f7:	66 48 0f 6e ce       	movq   xmm1,rsi
	mi->untyped_ptr = mi->umem_ptr = mi->kmem_ptr = mi->umem_frontier = mi->kmem_frontier = untyped_ptr;
  40d6fc:	66 48 0f 6e c6       	movq   xmm0,rsi
	mi->pgtbl_cap        = pgtbl_cap;
  40d701:	48 89 4f 30          	mov    QWORD PTR [rdi+0x30],rcx
	mi->untyped_ptr = mi->umem_ptr = mi->kmem_ptr = mi->umem_frontier = mi->kmem_frontier = untyped_ptr;
  40d705:	66 48 0f 6e d2       	movq   xmm2,rdx
  40d70a:	66 0f 6c c9          	punpcklqdq xmm1,xmm1
  40d70e:	66 0f 6c c2          	punpcklqdq xmm0,xmm2
  40d712:	0f 11 0f             	movups XMMWORD PTR [rdi],xmm1
  40d715:	0f 11 47 10          	movups XMMWORD PTR [rdi+0x10],xmm0
  40d719:	0f 11 4f 20          	movups XMMWORD PTR [rdi+0x20],xmm1
}
  40d71d:	c3                   	ret    
  40d71e:	66 90                	xchg   ax,ax

000000000040d720 <cos_compinfo_init>:
{
  40d720:	f3 0f 1e fa          	endbr64 
  40d724:	55                   	push   rbp
  40d725:	49 89 d2             	mov    r10,rdx
  40d728:	66 48 0f 6e c6       	movq   xmm0,rsi
  40d72d:	66 49 0f 6e d2       	movq   xmm2,r10
  40d732:	66 0f 6c c2          	punpcklqdq xmm0,xmm2
  40d736:	48 89 e5             	mov    rbp,rsp
  40d739:	48 8b 55 10          	mov    rdx,QWORD PTR [rbp+0x10]
	assert(ci && ci_resources);
  40d73d:	48 85 ff             	test   rdi,rdi
  40d740:	0f 84 19 01 00 00    	je     40d85f <cos_compinfo_init+0x13f>
  40d746:	48 85 d2             	test   rdx,rdx
  40d749:	0f 84 10 01 00 00    	je     40d85f <cos_compinfo_init+0x13f>
	assert(cap_frontier % CAPMAX_ENTRY_SZ == 0);
  40d74f:	41 f6 c1 03          	test   r9b,0x3
  40d753:	0f 85 22 01 00 00    	jne    40d87b <cos_compinfo_init+0x15b>
	ci->memsrc = ci_resources;
  40d759:	48 89 57 60          	mov    QWORD PTR [rdi+0x60],rdx
  40d75d:	48 89 f8             	mov    rax,rdi
	assert(ci_resources->memsrc == ci_resources); /* prevent infinite data-structs */
  40d760:	48 39 52 60          	cmp    QWORD PTR [rdx+0x60],rdx
  40d764:	0f 85 2d 01 00 00    	jne    40d897 <cos_compinfo_init+0x177>
	vaddr_t last_page = round_to_page(heap_ptr - 1);
  40d76a:	49 8d 50 ff          	lea    rdx,[r8-0x1]
	ci->comp_cap     		= comp_cap;
  40d76e:	48 89 4f 10          	mov    QWORD PTR [rdi+0x10],rcx
		return round_up_to_pgt0_page(vaddr);
  40d772:	48 b9 ff ff ff ff 7f 	movabs rcx,0x7fffffffff
  40d779:	00 00 00 
  40d77c:	48 be 00 00 00 00 80 	movabs rsi,0xffffff8000000000
  40d783:	ff ff ff 
	vaddr_t last_page = round_to_page(heap_ptr - 1);
  40d786:	48 81 e2 00 f0 ff ff 	and    rdx,0xfffffffffffff000
	ci->pgtbl_cap    		= pgtbl_cap;
  40d78d:	0f 11 07             	movups XMMWORD PTR [rdi],xmm0
	ci->comp_cap_shared 	= 0;
  40d790:	66 0f ef c0          	pxor   xmm0,xmm0
		return round_up_to_pgt0_page(vaddr);
  40d794:	48 01 d1             	add    rcx,rdx
	ci->comp_cap_shared 	= 0;
  40d797:	0f 11 87 c8 00 00 00 	movups XMMWORD PTR [rdi+0xc8],xmm0
	ci->vas_frontier = heap_ptr;
  40d79e:	66 49 0f 6e c0       	movq   xmm0,r8
		return round_up_to_pgt0_page(vaddr);
  40d7a3:	48 21 f1             	and    rcx,rsi
	ci->cap_frontier 		= 0;
  40d7a6:	48 c7 47 18 00 00 00 	mov    QWORD PTR [rdi+0x18],0x0
  40d7ad:	00 
	ci->vas_frontier = heap_ptr;
  40d7ae:	66 48 0f 6e d9       	movq   xmm3,rcx
		return round_up_to_pgt1_page(vaddr);
  40d7b3:	48 8d 8a ff ff ff 3f 	lea    rcx,[rdx+0x3fffffff]
		return round_up_to_pgt2_page(vaddr);
  40d7ba:	48 81 c2 ff ff 1f 00 	add    rdx,0x1fffff
	ci->vas_frontier = heap_ptr;
  40d7c1:	66 0f 6c c3          	punpcklqdq xmm0,xmm3
		return round_up_to_pgt2_page(vaddr);
  40d7c5:	48 81 e2 00 00 e0 ff 	and    rdx,0xffffffffffe00000
		return round_up_to_pgt1_page(vaddr);
  40d7cc:	48 81 e1 00 00 00 c0 	and    rcx,0xffffffffc0000000
	ci->vas_frontier = heap_ptr;
  40d7d3:	66 48 0f 6e e2       	movq   xmm4,rdx
  40d7d8:	0f 11 47 40          	movups XMMWORD PTR [rdi+0x40],xmm0
	assert(round_up_to_pow2(cap_frontier, CAPMAX_ENTRY_SZ) == cap_frontier);
  40d7dc:	49 8d 51 03          	lea    rdx,[r9+0x3]
	ci->vas_frontier = heap_ptr;
  40d7e0:	66 48 0f 6e c1       	movq   xmm0,rcx
  40d7e5:	66 0f 6c c4          	punpcklqdq xmm0,xmm4
	assert(round_up_to_pow2(cap_frontier, CAPMAX_ENTRY_SZ) == cap_frontier);
  40d7e9:	48 83 e2 fc          	and    rdx,0xfffffffffffffffc
	ci->vas_frontier = heap_ptr;
  40d7ed:	0f 11 47 50          	movups XMMWORD PTR [rdi+0x50],xmm0
	assert(round_up_to_pow2(cap_frontier, CAPMAX_ENTRY_SZ) == cap_frontier);
  40d7f1:	49 39 d1             	cmp    r9,rdx
  40d7f4:	0f 85 b9 00 00 00    	jne    40d8b3 <cos_compinfo_init+0x193>
  40d7fa:	66 49 0f 6e c9       	movq   xmm1,r9
	ci->cap_frontier = cap_frontier;
  40d7ff:	4c 89 4f 18          	mov    QWORD PTR [rdi+0x18],r9
  40d803:	66 0f 6c c9          	punpcklqdq xmm1,xmm1
	if (cap_frontier < CAPTBL_EXPAND_SZ) {
  40d807:	49 83 f9 7f          	cmp    r9,0x7f
  40d80b:	76 43                	jbe    40d850 <cos_compinfo_init+0x130>
		ci->caprange_frontier = round_up_to_pow2(cap_frontier + CAPTBL_EXPAND_SZ, CAPTBL_EXPAND_SZ * 2) - CAPTBL_EXPAND_SZ;
  40d80d:	49 8d 91 7f 01 00 00 	lea    rdx,[r9+0x17f]
  40d814:	30 d2                	xor    dl,dl
  40d816:	48 8d 7a 80          	lea    rdi,[rdx-0x80]
  40d81a:	66 48 0f 6e c7       	movq   xmm0,rdi
		ci->cap16_frontier[i] = ci->cap32_frontier[i] = ci->cap64_frontier[i] = cap_frontier;
  40d81f:	66 49 0f 6e e9       	movq   xmm5,r9
  40d824:	0f 11 48 30          	movups XMMWORD PTR [rax+0x30],xmm1
{ l->o = 0; }
  40d828:	48 c7 80 c0 00 00 00 	mov    QWORD PTR [rax+0xc0],0x0
  40d82f:	00 00 00 00 
  40d833:	66 0f 6c c5          	punpcklqdq xmm0,xmm5
  40d837:	0f 11 40 20          	movups XMMWORD PTR [rax+0x20],xmm0
  40d83b:	66 0f ef c0          	pxor   xmm0,xmm0
  40d83f:	0f 11 80 b0 00 00 00 	movups XMMWORD PTR [rax+0xb0],xmm0
}
  40d846:	5d                   	pop    rbp
  40d847:	c3                   	ret    
  40d848:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40d84f:	00 
		ci->caprange_frontier = round_up_to_pow2(cap_frontier, CAPTBL_EXPAND_SZ);
  40d850:	49 8d 51 7f          	lea    rdx,[r9+0x7f]
  40d854:	48 83 e2 80          	and    rdx,0xffffffffffffff80
  40d858:	66 48 0f 6e c2       	movq   xmm0,rdx
  40d85d:	eb c0                	jmp    40d81f <cos_compinfo_init+0xff>
  40d85f:	be 2e 00 00 00       	mov    esi,0x2e
  40d864:	bf 40 c9 41 00       	mov    edi,0x41c940
  40d869:	e8 62 c8 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci && ci_resources);
  40d86e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d875:	00 00 00 00 
  40d879:	0f 0b                	ud2    
  40d87b:	be 2e 00 00 00       	mov    esi,0x2e
  40d880:	bf 70 c9 41 00       	mov    edi,0x41c970
  40d885:	e8 46 c8 ff ff       	call   40a0d0 <cos_print_str>
	assert(cap_frontier % CAPMAX_ENTRY_SZ == 0);
  40d88a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d891:	00 00 00 00 
  40d895:	0f 0b                	ud2    
  40d897:	be 2e 00 00 00       	mov    esi,0x2e
  40d89c:	bf a0 c9 41 00       	mov    edi,0x41c9a0
  40d8a1:	e8 2a c8 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci_resources->memsrc == ci_resources); /* prevent infinite data-structs */
  40d8a6:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d8ad:	00 00 00 00 
  40d8b1:	0f 0b                	ud2    
  40d8b3:	be 2e 00 00 00       	mov    esi,0x2e
  40d8b8:	bf d0 c9 41 00       	mov    edi,0x41c9d0
  40d8bd:	e8 0e c8 ff ff       	call   40a0d0 <cos_print_str>
	assert(round_up_to_pow2(cap_frontier, CAPMAX_ENTRY_SZ) == cap_frontier);
  40d8c2:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d8c9:	00 00 00 00 
  40d8cd:	0f 0b                	ud2    
  40d8cf:	90                   	nop

000000000040d8d0 <cos_capid_bump_alloc>:
{ return __capid_bump_alloc(ci, cap); }
  40d8d0:	f3 0f 1e fa          	endbr64 
  40d8d4:	55                   	push   rbp
  40d8d5:	48 89 e5             	mov    rbp,rsp
  40d8d8:	41 56                	push   r14
  40d8da:	41 55                	push   r13
  40d8dc:	41 54                	push   r12
  40d8de:	53                   	push   rbx
/* a function instead of a struct to enable inlining + constant prop */
static inline cap_sz_t
__captbl_cap2sz(cap_t c)
{
	/* TODO: optimize for invocation and return */
	switch (c) {
  40d8df:	83 fe 14             	cmp    esi,0x14
  40d8e2:	77 78                	ja     40d95c <cos_capid_bump_alloc+0x8c>
  40d8e4:	b8 01 00 00 00       	mov    eax,0x1
  40d8e9:	89 f1                	mov    ecx,esi
  40d8eb:	48 89 fb             	mov    rbx,rdi
		break;
  40d8ee:	41 bc 04 00 00 00    	mov    r12d,0x4
  40d8f4:	48 d3 e0             	shl    rax,cl
		frontier = &ci->cap64_frontier[cos_cpuid()];
  40d8f7:	4c 8d 77 38          	lea    r14,[rdi+0x38]
  40d8fb:	a9 da 81 1f 00       	test   eax,0x1f81da
  40d900:	74 4e                	je     40d950 <cos_capid_bump_alloc+0x80>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40d902:	48 8d 93 b0 00 00 00 	lea    rdx,[rbx+0xb0]
        __asm__ __volatile__("lock " PS_CAS_STR
  40d909:	be 01 00 00 00       	mov    esi,0x1
  40d90e:	31 c9                	xor    ecx,ecx
  40d910:	48 89 c8             	mov    rax,rcx
  40d913:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40d918:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40d91b:	84 c0                	test   al,al
  40d91d:	74 f1                	je     40d910 <cos_capid_bump_alloc+0x40>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40d91f:	4d 8b 2e             	mov    r13,QWORD PTR [r14]
  40d922:	41 83 e5 03          	and    r13d,0x3
  40d926:	74 68                	je     40d990 <cos_capid_bump_alloc+0xc0>
        __asm__ __volatile__("lock " PS_FAA_STR
  40d928:	4c 89 e0             	mov    rax,r12
  40d92b:	f0 49 0f c1 06       	lock xadd QWORD PTR [r14],rax
  40d930:	49 89 c5             	mov    r13,rax
{ l->o = 0; }
  40d933:	48 c7 83 b0 00 00 00 	mov    QWORD PTR [rbx+0xb0],0x0
  40d93a:	00 00 00 00 
{ return __capid_bump_alloc(ci, cap); }
  40d93e:	4c 89 e8             	mov    rax,r13
  40d941:	5b                   	pop    rbx
  40d942:	41 5c                	pop    r12
  40d944:	41 5d                	pop    r13
  40d946:	41 5e                	pop    r14
  40d948:	5d                   	pop    rbp
  40d949:	c3                   	ret    
  40d94a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40d950:	a9 24 10 00 00       	test   eax,0x1024
  40d955:	75 29                	jne    40d980 <cos_capid_bump_alloc+0xb0>
  40d957:	f6 c4 60             	test   ah,0x60
  40d95a:	75 14                	jne    40d970 <cos_capid_bump_alloc+0xa0>
  40d95c:	49 c7 c5 ff ff ff ff 	mov    r13,0xffffffffffffffff
  40d963:	5b                   	pop    rbx
  40d964:	41 5c                	pop    r12
  40d966:	4c 89 e8             	mov    rax,r13
  40d969:	41 5d                	pop    r13
  40d96b:	41 5e                	pop    r14
  40d96d:	5d                   	pop    rbp
  40d96e:	c3                   	ret    
  40d96f:	90                   	nop
		frontier = &ci->cap32_frontier[cos_cpuid()];
  40d970:	4c 8d 77 30          	lea    r14,[rdi+0x30]
		break;
  40d974:	41 bc 02 00 00 00    	mov    r12d,0x2
  40d97a:	eb 86                	jmp    40d902 <cos_capid_bump_alloc+0x32>
  40d97c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		frontier = &ci->cap16_frontier[cos_cpuid()];
  40d980:	4c 8d 77 28          	lea    r14,[rdi+0x28]
		break;
  40d984:	41 bc 01 00 00 00    	mov    r12d,0x1
  40d98a:	e9 73 ff ff ff       	jmp    40d902 <cos_capid_bump_alloc+0x32>
  40d98f:	90                   	nop
		if (__capid_captbl_check_expand(ci)) goto error;
  40d990:	48 89 df             	mov    rdi,rbx
  40d993:	e8 48 f0 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40d998:	85 c0                	test   eax,eax
  40d99a:	75 97                	jne    40d933 <cos_capid_bump_alloc+0x63>
        __asm__ __volatile__("lock " PS_FAA_STR
  40d99c:	b8 04 00 00 00       	mov    eax,0x4
  40d9a1:	f0 48 0f c1 43 18    	lock xadd QWORD PTR [rbx+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40d9a7:	49 89 06             	mov    QWORD PTR [r14],rax
  40d9aa:	e9 79 ff ff ff       	jmp    40d928 <cos_capid_bump_alloc+0x58>
  40d9af:	90                   	nop

000000000040d9b0 <cos_pgtbl_intern_alloc>:
{
  40d9b0:	f3 0f 1e fa          	endbr64 
  40d9b4:	55                   	push   rbp
  40d9b5:	48 89 e5             	mov    rbp,rsp
  40d9b8:	41 57                	push   r15
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  40d9ba:	45 31 ff             	xor    r15d,r15d
{
  40d9bd:	41 56                	push   r14
  40d9bf:	49 89 ce             	mov    r14,rcx
  40d9c2:	41 55                	push   r13
  40d9c4:	49 89 d5             	mov    r13,rdx
  40d9c7:	41 54                	push   r12
  40d9c9:	49 89 f4             	mov    r12,rsi
  40d9cc:	53                   	push   rbx
  40d9cd:	48 89 fb             	mov    rbx,rdi
  40d9d0:	48 83 ec 08          	sub    rsp,0x8
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  40d9d4:	80 bf d8 00 00 00 01 	cmp    BYTE PTR [rdi+0xd8],0x1
		ret = __bump_mem_expand_range(__compinfo_metacap(ci), cipgtbl, mem_ptr, mem_sz, i | pgtbl_lvl_flag);	
  40d9db:	48 8b 7f 60          	mov    rdi,QWORD PTR [rdi+0x60]
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  40d9df:	41 0f 94 c7          	sete   r15b
  40d9e3:	49 c1 e7 1f          	shl    r15,0x1f
		ret = __bump_mem_expand_range(__compinfo_metacap(ci), cipgtbl, mem_ptr, mem_sz, i | pgtbl_lvl_flag);	
  40d9e7:	45 89 f8             	mov    r8d,r15d
  40d9ea:	41 83 c8 01          	or     r8d,0x1
  40d9ee:	e8 7d f2 ff ff       	call   40cc70 <__bump_mem_expand_range>
  40d9f3:	48 8b 7b 60          	mov    rdi,QWORD PTR [rbx+0x60]
  40d9f7:	45 89 f8             	mov    r8d,r15d
}
  40d9fa:	48 83 c4 08          	add    rsp,0x8
  40d9fe:	5b                   	pop    rbx
		ret = __bump_mem_expand_range(__compinfo_metacap(ci), cipgtbl, mem_ptr, mem_sz, i | pgtbl_lvl_flag);	
  40d9ff:	4c 89 f1             	mov    rcx,r14
  40da02:	4c 89 ea             	mov    rdx,r13
  40da05:	4c 89 e6             	mov    rsi,r12
  40da08:	41 83 c8 02          	or     r8d,0x2
}
  40da0c:	41 5c                	pop    r12
  40da0e:	41 5d                	pop    r13
  40da10:	41 5e                	pop    r14
  40da12:	41 5f                	pop    r15
  40da14:	5d                   	pop    rbp
		ret = __bump_mem_expand_range(__compinfo_metacap(ci), cipgtbl, mem_ptr, mem_sz, i | pgtbl_lvl_flag);	
  40da15:	e9 56 f2 ff ff       	jmp    40cc70 <__bump_mem_expand_range>
  40da1a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000040da20 <cos_pgtbl_intern_expand>:
{
  40da20:	f3 0f 1e fa          	endbr64 
  40da24:	55                   	push   rbp
  40da25:	48 89 e5             	mov    rbp,rsp
  40da28:	41 56                	push   r14
  40da2a:	41 55                	push   r13
  40da2c:	41 54                	push   r12
  40da2e:	53                   	push   rbx
	assert(lvl > 0);
  40da2f:	85 d2                	test   edx,edx
  40da31:	0f 8e b0 00 00 00    	jle    40dae7 <cos_pgtbl_intern_expand+0xc7>
  40da37:	48 89 fb             	mov    rbx,rdi
  40da3a:	49 89 f4             	mov    r12,rsi
  40da3d:	48 8d 8f c0 00 00 00 	lea    rcx,[rdi+0xc0]
  40da44:	31 f6                	xor    esi,esi
  40da46:	bf 01 00 00 00       	mov    edi,0x1
  40da4b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  40da50:	48 89 f0             	mov    rax,rsi
  40da53:	f0 48 0f b1 39       	lock cmpxchg QWORD PTR [rcx],rdi
  40da58:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40da5b:	84 c0                	test   al,al
  40da5d:	74 f1                	je     40da50 <cos_pgtbl_intern_expand+0x30>
	if (ci->vasrange_frontier[lvl] != round_to_pgd_page(mem_ptr)) goto error;
  40da5f:	48 b8 00 00 00 00 80 	movabs rax,0xffffff8000000000
  40da66:	ff ff ff 
  40da69:	4c 63 ea             	movsxd r13,edx
  40da6c:	4e 8d 34 eb          	lea    r14,[rbx+r13*8]
  40da70:	4c 21 e0             	and    rax,r12
  40da73:	49 39 46 48          	cmp    QWORD PTR [r14+0x48],rax
  40da77:	74 1f                	je     40da98 <cos_pgtbl_intern_expand+0x78>
	return 0;
  40da79:	45 31 c0             	xor    r8d,r8d
{ l->o = 0; }
  40da7c:	48 c7 83 c0 00 00 00 	mov    QWORD PTR [rbx+0xc0],0x0
  40da83:	00 00 00 00 
}
  40da87:	4c 89 c0             	mov    rax,r8
  40da8a:	5b                   	pop    rbx
  40da8b:	41 5c                	pop    r12
  40da8d:	41 5d                	pop    r13
  40da8f:	41 5e                	pop    r14
  40da91:	5d                   	pop    rbp
  40da92:	c3                   	ret    
  40da93:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	cap = __bump_mem_expand_intern(__compinfo_metacap(ci), ci->pgtbl_cap, mem_ptr, 0, 0);
  40da98:	48 8b 7b 60          	mov    rdi,QWORD PTR [rbx+0x60]
  40da9c:	48 8b 33             	mov    rsi,QWORD PTR [rbx]
  40da9f:	45 31 c0             	xor    r8d,r8d
  40daa2:	31 c9                	xor    ecx,ecx
  40daa4:	4c 89 e2             	mov    rdx,r12
  40daa7:	e8 f4 f8 ff ff       	call   40d3a0 <__bump_mem_expand_intern>
  40daac:	49 89 c0             	mov    r8,rax
	if (!cap) goto error;
  40daaf:	48 85 c0             	test   rax,rax
  40dab2:	74 c5                	je     40da79 <cos_pgtbl_intern_expand+0x59>
		if (tmp >= mem_ptr + PGD_RANGE) break;
  40dab4:	48 be 00 00 00 00 80 	movabs rsi,0x8000000000
  40dabb:	00 00 00 
		vaddr_t tmp = ps_load(&ci->vasrange_frontier[lvl]);
  40dabe:	49 8b 46 48          	mov    rax,QWORD PTR [r14+0x48]
		ps_cas(&ci->vasrange_frontier[lvl], tmp, tmp + PGD_RANGE);
  40dac2:	4a 8d 4c eb 48       	lea    rcx,[rbx+r13*8+0x48]
		if (tmp >= mem_ptr + PGD_RANGE) break;
  40dac7:	49 01 f4             	add    r12,rsi
  40daca:	4c 39 e0             	cmp    rax,r12
  40dacd:	73 ad                	jae    40da7c <cos_pgtbl_intern_expand+0x5c>
  40dacf:	90                   	nop
		ps_cas(&ci->vasrange_frontier[lvl], tmp, tmp + PGD_RANGE);
  40dad0:	48 8d 14 30          	lea    rdx,[rax+rsi*1]
        __asm__ __volatile__("lock " PS_CAS_STR
  40dad4:	f0 48 0f b1 11       	lock cmpxchg QWORD PTR [rcx],rdx
  40dad9:	0f 94 c0             	sete   al
		vaddr_t tmp = ps_load(&ci->vasrange_frontier[lvl]);
  40dadc:	49 8b 46 48          	mov    rax,QWORD PTR [r14+0x48]
		if (tmp >= mem_ptr + PGD_RANGE) break;
  40dae0:	4c 39 e0             	cmp    rax,r12
  40dae3:	72 eb                	jb     40dad0 <cos_pgtbl_intern_expand+0xb0>
  40dae5:	eb 95                	jmp    40da7c <cos_pgtbl_intern_expand+0x5c>
  40dae7:	be 2e 00 00 00       	mov    esi,0x2e
  40daec:	bf 00 ca 41 00       	mov    edi,0x41ca00
  40daf1:	e8 da c5 ff ff       	call   40a0d0 <cos_print_str>
	assert(lvl > 0);
  40daf6:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40dafd:	00 00 00 00 
  40db01:	0f 0b                	ud2    
  40db03:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40db0a:	00 00 00 00 
  40db0e:	66 90                	xchg   ax,ax

000000000040db10 <cos_pgtbl_intern_expandwith>:
{
  40db10:	f3 0f 1e fa          	endbr64 
  40db14:	55                   	push   rbp
  40db15:	49 89 d1             	mov    r9,rdx
  40db18:	31 c9                	xor    ecx,ecx
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40db1a:	48 8d 97 c0 00 00 00 	lea    rdx,[rdi+0xc0]
  40db21:	48 89 e5             	mov    rbp,rsp
  40db24:	41 54                	push   r12
  40db26:	49 89 f4             	mov    r12,rsi
        __asm__ __volatile__("lock " PS_CAS_STR
  40db29:	be 01 00 00 00       	mov    esi,0x1
  40db2e:	53                   	push   rbx
  40db2f:	48 89 fb             	mov    rbx,rdi
  40db32:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40db38:	48 89 c8             	mov    rax,rcx
  40db3b:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40db40:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40db43:	84 c0                	test   al,al
  40db45:	74 f1                	je     40db38 <cos_pgtbl_intern_expandwith+0x28>
	if (ci->vasrange_frontier[0] != round_to_pgd_page(mem)) goto error;
  40db47:	48 b8 00 00 00 00 80 	movabs rax,0xffffff8000000000
  40db4e:	ff ff ff 
  40db51:	4c 21 c8             	and    rax,r9
  40db54:	48 39 43 48          	cmp    QWORD PTR [rbx+0x48],rax
  40db58:	75 23                	jne    40db7d <cos_pgtbl_intern_expandwith+0x6d>
        __asm__ __volatile__("lock " PS_FAA_STR
  40db5a:	48 ba 00 00 00 00 80 	movabs rdx,0x8000000000
  40db61:	00 00 00 
  40db64:	48 89 d1             	mov    rcx,rdx
  40db67:	f0 48 0f c1 4b 48    	lock xadd QWORD PTR [rbx+0x48],rcx
	if ((unsigned long)ps_faa(&ci->vasrange_frontier[0], PGD_RANGE) > round_to_pgd_page(mem)) goto error;
  40db6d:	48 39 c8             	cmp    rax,rcx
  40db70:	72 0b                	jb     40db7d <cos_pgtbl_intern_expandwith+0x6d>
  40db72:	f0 48 0f c1 53 40    	lock xadd QWORD PTR [rbx+0x40],rdx
	if ((unsigned long)ps_faa(&ci->vas_frontier, PGD_RANGE) > round_to_pgd_page(mem)) goto error;
  40db78:	48 39 d0             	cmp    rax,rdx
  40db7b:	73 1b                	jae    40db98 <cos_pgtbl_intern_expandwith+0x88>
{ l->o = 0; }
  40db7d:	48 c7 83 c0 00 00 00 	mov    QWORD PTR [rbx+0xc0],0x0
  40db84:	00 00 00 00 
	return -1;
  40db88:	b8 ff ff ff ff       	mov    eax,0xffffffff
}
  40db8d:	5b                   	pop    rbx
  40db8e:	41 5c                	pop    r12
  40db90:	5d                   	pop    rbp
  40db91:	c3                   	ret    
  40db92:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	if (__bump_mem_expand_intern(__compinfo_metacap(ci), ci->pgtbl_cap, mem, intern, 0) != intern) {
  40db98:	48 8b 7b 60          	mov    rdi,QWORD PTR [rbx+0x60]
  40db9c:	48 8b 33             	mov    rsi,QWORD PTR [rbx]
  40db9f:	45 31 c0             	xor    r8d,r8d
  40dba2:	4c 89 e1             	mov    rcx,r12
  40dba5:	4c 89 ca             	mov    rdx,r9
  40dba8:	e8 f3 f7 ff ff       	call   40d3a0 <__bump_mem_expand_intern>
  40dbad:	48 c7 83 c0 00 00 00 	mov    QWORD PTR [rbx+0xc0],0x0
  40dbb4:	00 00 00 00 
}
  40dbb8:	5b                   	pop    rbx
	if (__bump_mem_expand_intern(__compinfo_metacap(ci), ci->pgtbl_cap, mem, intern, 0) != intern) {
  40dbb9:	4c 39 e0             	cmp    rax,r12
}
  40dbbc:	41 5c                	pop    r12
  40dbbe:	5d                   	pop    rbp
	if (__bump_mem_expand_intern(__compinfo_metacap(ci), ci->pgtbl_cap, mem, intern, 0) != intern) {
  40dbbf:	0f 95 c0             	setne  al
  40dbc2:	0f b6 c0             	movzx  eax,al
}
  40dbc5:	c3                   	ret    
  40dbc6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40dbcd:	00 00 00 

000000000040dbd0 <cos_meminfo_alloc>:
{
  40dbd0:	f3 0f 1e fa          	endbr64 
	assert(untyped_ptr == round_up_to_pgd_page(untyped_ptr));
  40dbd4:	48 b8 ff ff ff ff 7f 	movabs rax,0x7fffffffff
  40dbdb:	00 00 00 
{
  40dbde:	55                   	push   rbp
	assert(untyped_ptr == round_up_to_pgd_page(untyped_ptr));
  40dbdf:	48 01 f0             	add    rax,rsi
{
  40dbe2:	48 89 e5             	mov    rbp,rsp
  40dbe5:	41 57                	push   r15
  40dbe7:	41 56                	push   r14
  40dbe9:	49 89 d6             	mov    r14,rdx
	assert(untyped_ptr == round_up_to_pgd_page(untyped_ptr));
  40dbec:	48 ba 00 00 00 00 80 	movabs rdx,0xffffff8000000000
  40dbf3:	ff ff ff 
{
  40dbf6:	41 55                	push   r13
	assert(untyped_ptr == round_up_to_pgd_page(untyped_ptr));
  40dbf8:	48 21 d0             	and    rax,rdx
{
  40dbfb:	41 54                	push   r12
  40dbfd:	53                   	push   rbx
  40dbfe:	48 83 ec 28          	sub    rsp,0x28
	return ci->memsrc;
  40dc02:	4c 8b 7f 60          	mov    r15,QWORD PTR [rdi+0x60]
	assert(untyped_ptr == round_up_to_pgd_page(untyped_ptr));
  40dc06:	48 39 c6             	cmp    rsi,rax
  40dc09:	0f 85 88 01 00 00    	jne    40dd97 <cos_meminfo_alloc+0x1c7>
  40dc0f:	49 89 fd             	mov    r13,rdi
  40dc12:	48 89 f3             	mov    rbx,rsi
  40dc15:	4c 89 ff             	mov    rdi,r15
  40dc18:	45 31 e4             	xor    r12d,r12d
		retaddr = __bump_mem_expand_range(__compinfo_metacap(ci), ci->mi.pgtbl_cap, untyped_ptr, untyped_sz, pgtbl_lvl);
  40dc1b:	49 8b b5 98 00 00 00 	mov    rsi,QWORD PTR [r13+0x98]
  40dc22:	45 89 e0             	mov    r8d,r12d
  40dc25:	4c 89 f1             	mov    rcx,r14
  40dc28:	48 89 da             	mov    rdx,rbx
  40dc2b:	e8 40 f0 ff ff       	call   40cc70 <__bump_mem_expand_range>
  40dc30:	49 89 c2             	mov    r10,rax
		assert(retaddr);
  40dc33:	48 85 c0             	test   rax,rax
  40dc36:	0f 84 3f 01 00 00    	je     40dd7b <cos_meminfo_alloc+0x1ab>
	for(pgtbl_lvl = 0; pgtbl_lvl < COS_PGTBL_DEPTH - 1; pgtbl_lvl++) {
  40dc3c:	49 83 c4 01          	add    r12,0x1
  40dc40:	49 83 fc 03          	cmp    r12,0x3
  40dc44:	74 0a                	je     40dc50 <cos_meminfo_alloc+0x80>
	return ci->memsrc;
  40dc46:	49 8b 7d 60          	mov    rdi,QWORD PTR [r13+0x60]
  40dc4a:	eb cf                	jmp    40dc1b <cos_meminfo_alloc+0x4b>
  40dc4c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  40dc50:	66 48 0f 6e c0       	movq   xmm0,rax
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40dc55:	49 8d 95 b8 00 00 00 	lea    rdx,[r13+0xb8]
        __asm__ __volatile__("lock " PS_CAS_STR
  40dc5c:	be 01 00 00 00       	mov    esi,0x1
  40dc61:	31 c9                	xor    ecx,ecx
  40dc63:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
	assert(retaddr == untyped_ptr);
  40dc67:	48 39 c3             	cmp    rbx,rax
  40dc6a:	0f 85 43 01 00 00    	jne    40ddb3 <cos_meminfo_alloc+0x1e3>
  40dc70:	48 89 c8             	mov    rax,rcx
  40dc73:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40dc78:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40dc7b:	84 c0                	test   al,al
  40dc7d:	74 f1                	je     40dc70 <cos_meminfo_alloc+0xa0>
        __asm__ __volatile__("lock " PS_FAA_STR
  40dc7f:	4c 89 f0             	mov    rax,r14
  40dc82:	f0 49 0f c1 47 68    	lock xadd QWORD PTR [r15+0x68],rax
  40dc88:	4c 89 f2             	mov    rdx,r14
  40dc8b:	f0 49 0f c1 97 80 00 	lock xadd QWORD PTR [r15+0x80],rdx
  40dc92:	00 00 
	for (addr = untyped_ptr; addr < untyped_ptr + untyped_sz; addr += PAGE_SIZE, start_addr += PAGE_SIZE) {
  40dc94:	4b 8d 1c 16          	lea    rbx,[r14+r10*1]
  40dc98:	66 49 0f 6e d2       	movq   xmm2,r10
  40dc9d:	4c 29 d0             	sub    rax,r10
  40dca0:	4c 89 d7             	mov    rdi,r10
  40dca3:	66 48 0f 6e cb       	movq   xmm1,rbx
  40dca8:	49 89 c6             	mov    r14,rax
  40dcab:	31 d2                	xor    edx,edx
{ l->o = 0; }
  40dcad:	49 c7 85 b8 00 00 00 	mov    QWORD PTR [r13+0xb8],0x0
  40dcb4:	00 00 00 00 
  40dcb8:	66 0f 6c ca          	punpcklqdq xmm1,xmm2
  40dcbc:	4c 39 d3             	cmp    rbx,r10
  40dcbf:	0f 86 8f 00 00 00    	jbe    40dd54 <cos_meminfo_alloc+0x184>
  40dcc5:	4c 89 55 b8          	mov    QWORD PTR [rbp-0x48],r10
  40dcc9:	49 89 da             	mov    r10,rbx
  40dccc:	eb 0e                	jmp    40dcdc <cos_meminfo_alloc+0x10c>
  40dcce:	66 90                	xchg   ax,ax
  40dcd0:	48 81 c7 00 10 00 00 	add    rdi,0x1000
  40dcd7:	49 39 fa             	cmp    r10,rdi
  40dcda:	76 74                	jbe    40dd50 <cos_meminfo_alloc+0x180>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40dcdc:	41 8b 87 98 00 00 00 	mov    eax,DWORD PTR [r15+0x98]
	__asm__ __volatile__(
  40dce3:	49 8b b5 98 00 00 00 	mov    rsi,QWORD PTR [r13+0x98]
  40dcea:	49 8d 1c 3e          	lea    rbx,[r14+rdi*1]
  40dcee:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40dcf2:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40dcf5:	05 24 00 01 00       	add    eax,0x10024
	__asm__ __volatile__(
  40dcfa:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40dcfd:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40dd01:	48 89 cd             	mov    rbp,rcx
  40dd04:	49 b8 18 dd 40 00 00 	movabs r8,0x40dd18
  40dd0b:	00 00 00 
  40dd0e:	0f 05                	syscall 
  40dd10:	eb 0d                	jmp    40dd1f <cos_meminfo_alloc+0x14f>
  40dd12:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40dd18:	b9 00 00 00 00       	mov    ecx,0x0
  40dd1d:	eb 05                	jmp    40dd24 <cos_meminfo_alloc+0x154>
  40dd1f:	b9 01 00 00 00       	mov    ecx,0x1
  40dd24:	5d                   	pop    rbp
  40dd25:	5c                   	pop    rsp
		if (call_cap_op(meta->mi.pgtbl_cap, CAPTBL_OP_MEMMOVE, start_addr, ci->mi.pgtbl_cap, addr, 0)) BUG();
  40dd26:	85 c0                	test   eax,eax
  40dd28:	74 a6                	je     40dcd0 <cos_meminfo_alloc+0x100>
  40dd2a:	be 1b 00 00 00       	mov    esi,0x1b
  40dd2f:	bf bf ca 41 00       	mov    edi,0x41cabf
  40dd34:	e8 97 c3 ff ff       	call   40a0d0 <cos_print_str>
  40dd39:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40dd40:	00 00 00 00 
  40dd44:	0f 0b                	ud2    
  40dd46:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40dd4d:	00 00 00 
  40dd50:	4c 8b 55 b8          	mov    r10,QWORD PTR [rbp-0x48]
	ci->mi.untyped_ptr = ci->mi.umem_ptr = ci->mi.kmem_ptr = ci->mi.umem_frontier = ci->mi.kmem_frontier =
  40dd54:	4d 89 95 90 00 00 00 	mov    QWORD PTR [r13+0x90],r10
  40dd5b:	4d 89 55 78          	mov    QWORD PTR [r13+0x78],r10
  40dd5f:	41 0f 11 45 68       	movups XMMWORD PTR [r13+0x68],xmm0
	ci->mi.untyped_frontier = untyped_ptr + untyped_sz;
  40dd64:	41 0f 11 8d 80 00 00 	movups XMMWORD PTR [r13+0x80],xmm1
  40dd6b:	00 
}
  40dd6c:	48 83 c4 28          	add    rsp,0x28
  40dd70:	5b                   	pop    rbx
  40dd71:	41 5c                	pop    r12
  40dd73:	41 5d                	pop    r13
  40dd75:	41 5e                	pop    r14
  40dd77:	41 5f                	pop    r15
  40dd79:	5d                   	pop    rbp
  40dd7a:	c3                   	ret    
  40dd7b:	be 2e 00 00 00       	mov    esi,0x2e
  40dd80:	bf 60 ca 41 00       	mov    edi,0x41ca60
  40dd85:	e8 46 c3 ff ff       	call   40a0d0 <cos_print_str>
		assert(retaddr);
  40dd8a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40dd91:	00 00 00 00 
  40dd95:	0f 0b                	ud2    
  40dd97:	be 2e 00 00 00       	mov    esi,0x2e
  40dd9c:	bf 30 ca 41 00       	mov    edi,0x41ca30
  40dda1:	e8 2a c3 ff ff       	call   40a0d0 <cos_print_str>
	assert(untyped_ptr == round_up_to_pgd_page(untyped_ptr));
  40dda6:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ddad:	00 00 00 00 
  40ddb1:	0f 0b                	ud2    
  40ddb3:	be 2e 00 00 00       	mov    esi,0x2e
  40ddb8:	bf 90 ca 41 00       	mov    edi,0x41ca90
  40ddbd:	e8 0e c3 ff ff       	call   40a0d0 <cos_print_str>
	assert(retaddr == untyped_ptr);
  40ddc2:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ddc9:	00 00 00 00 
  40ddcd:	0f 0b                	ud2    
  40ddcf:	90                   	nop

000000000040ddd0 <missing_captbl_node_expand>:

void
missing_captbl_node_expand(struct cos_compinfo *ci)
{
  40ddd0:	f3 0f 1e fa          	endbr64 
  40ddd4:	55                   	push   rbp
  40ddd5:	48 89 e5             	mov    rbp,rsp
  40ddd8:	41 57                	push   r15
  40ddda:	41 56                	push   r14
  40dddc:	41 55                	push   r13
  40ddde:	41 54                	push   r12
  40dde0:	53                   	push   rbx
  40dde1:	48 83 ec 38          	sub    rsp,0x38
	return ci->memsrc;
  40dde5:	4c 8b 7f 60          	mov    r15,QWORD PTR [rdi+0x60]
	int self_resource = (root_source == ci);
	vaddr_t kmem;
	int ret;

	cap_frontier = root_source->cap_frontier;
	caprange_frontier = root_source->caprange_frontier;
  40dde9:	49 8b 77 20          	mov    rsi,QWORD PTR [r15+0x20]
	cap_frontier = root_source->cap_frontier;
  40dded:	49 8b 47 18          	mov    rax,QWORD PTR [r15+0x18]
	caprange_frontier = root_source->caprange_frontier;
  40ddf1:	48 89 75 b0          	mov    QWORD PTR [rbp-0x50],rsi

	test_cap = CAPTBL_EXPAND_SZ;
	if (self_resource) {
  40ddf5:	4c 39 ff             	cmp    rdi,r15
  40ddf8:	0f 84 a2 02 00 00    	je     40e0a0 <missing_captbl_node_expand+0x2d0>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40ddfe:	41 8b 47 08          	mov    eax,DWORD PTR [r15+0x8]
	__asm__ __volatile__(
  40de02:	31 d2                	xor    edx,edx
  40de04:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  40de08:	48 8b 5f 08          	mov    rbx,QWORD PTR [rdi+0x8]
  40de0c:	49 89 fa             	mov    r10,rdi
  40de0f:	48 89 4d b8          	mov    QWORD PTR [rbp-0x48],rcx
  40de13:	bf 01 00 00 00       	mov    edi,0x1
  40de18:	48 89 d6             	mov    rsi,rdx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40de1b:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40de1e:	05 03 00 01 00       	add    eax,0x10003
	__asm__ __volatile__(
  40de23:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40de26:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40de2a:	48 89 cd             	mov    rbp,rcx
  40de2d:	49 b8 48 de 40 00 00 	movabs r8,0x40de48
  40de34:	00 00 00 
  40de37:	0f 05                	syscall 
  40de39:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  40de40:	eb 0d                	jmp    40de4f <missing_captbl_node_expand+0x7f>
  40de42:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40de48:	b9 00 00 00 00       	mov    ecx,0x0
  40de4d:	eb 05                	jmp    40de54 <missing_captbl_node_expand+0x84>
  40de4f:	b9 01 00 00 00       	mov    ecx,0x1
  40de54:	5d                   	pop    rbp
  40de55:	5c                   	pop    rsp
	} else {
		printd("cap check before:%d\n", ci->captbl_cap);
		ret = call_cap_op(root_source->captbl_cap, CAPTBL_OP_CAPCHECK, ci->captbl_cap, 0, 1, 0);
		// printc("after cap check:%d\n", ret);
		/* make sure the sub captbl exists */
		assert(!ret);
  40de56:	85 c0                	test   eax,eax
  40de58:	0f 85 e8 03 00 00    	jne    40e246 <missing_captbl_node_expand+0x476>
		cap_frontier = ci->cap_frontier;
		caprange_frontier = ci->caprange_frontier;
  40de5e:	49 8b 42 20          	mov    rax,QWORD PTR [r10+0x20]
		/* we make sure before expanding the missing node of sub captbl, we make sure its root captbl is in a good state */
		printd("begin to expanding a SUB source:%d, %d\n", cap_frontier, caprange_frontier);
		missing_captbl_node_expand(root_source);
  40de62:	4c 89 ff             	mov    rdi,r15
		caprange_frontier = ci->caprange_frontier;
  40de65:	4c 89 55 a8          	mov    QWORD PTR [rbp-0x58],r10
  40de69:	48 89 c3             	mov    rbx,rax
  40de6c:	48 89 45 b0          	mov    QWORD PTR [rbp-0x50],rax
		missing_captbl_node_expand(root_source);
  40de70:	e8 5b ff ff ff       	call   40ddd0 <missing_captbl_node_expand>
		while (test_cap < caprange_frontier) {
  40de75:	48 81 fb 80 00 00 00 	cmp    rbx,0x80
  40de7c:	0f 86 24 02 00 00    	jbe    40e0a6 <missing_captbl_node_expand+0x2d6>
  40de82:	4c 8b 55 a8          	mov    r10,QWORD PTR [rbp-0x58]
	test_cap = CAPTBL_EXPAND_SZ;
  40de86:	41 be 80 00 00 00    	mov    r14d,0x80
  40de8c:	45 31 ed             	xor    r13d,r13d
  40de8f:	eb 18                	jmp    40dea9 <missing_captbl_node_expand+0xd9>
  40de91:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
					printc("assert ret:%d\n", ret);
					assert(0); /* race? */
				}
				printd("try to expand a SUB node: DONE once\n");
			}
			test_cap += CAPTBL_EXPAND_SZ * 2;
  40de98:	49 81 c6 00 01 00 00 	add    r14,0x100
		while (test_cap < caprange_frontier) {
  40de9f:	4c 39 75 b0          	cmp    QWORD PTR [rbp-0x50],r14
  40dea3:	0f 86 fd 01 00 00    	jbe    40e0a6 <missing_captbl_node_expand+0x2d6>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40dea9:	41 8b 47 08          	mov    eax,DWORD PTR [r15+0x8]
	__asm__ __volatile__(
  40dead:	49 8b 5a 08          	mov    rbx,QWORD PTR [r10+0x8]
  40deb1:	4c 89 f6             	mov    rsi,r14
  40deb4:	4c 89 ef             	mov    rdi,r13
  40deb7:	48 8b 4d b8          	mov    rcx,QWORD PTR [rbp-0x48]
  40debb:	4c 89 ea             	mov    rdx,r13
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40debe:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40dec1:	05 03 00 01 00       	add    eax,0x10003
	__asm__ __volatile__(
  40dec6:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40dec9:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40decd:	48 89 cd             	mov    rbp,rcx
  40ded0:	49 b8 e8 de 40 00 00 	movabs r8,0x40dee8
  40ded7:	00 00 00 
  40deda:	0f 05                	syscall 
  40dedc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  40dee0:	eb 0d                	jmp    40deef <missing_captbl_node_expand+0x11f>
  40dee2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40dee8:	b9 00 00 00 00       	mov    ecx,0x0
  40deed:	eb 05                	jmp    40def4 <missing_captbl_node_expand+0x124>
  40deef:	b9 01 00 00 00       	mov    ecx,0x1
  40def4:	5d                   	pop    rbp
  40def5:	5c                   	pop    rsp
			if (ret) {
  40def6:	85 c0                	test   eax,eax
  40def8:	74 9e                	je     40de98 <missing_captbl_node_expand+0xc8>
	return __mem_bump_alloc(ci, 1, 1);
  40defa:	4c 89 ff             	mov    rdi,r15
  40defd:	4c 89 55 a8          	mov    QWORD PTR [rbp-0x58],r10
  40df01:	e8 5a e9 ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
				assert(kmem); /* FIXME: should have a failure semantics for capids */
  40df06:	4c 8b 55 a8          	mov    r10,QWORD PTR [rbp-0x58]
  40df0a:	48 85 c0             	test   rax,rax
	return __mem_bump_alloc(ci, 1, 1);
  40df0d:	49 89 c4             	mov    r12,rax
				assert(kmem); /* FIXME: should have a failure semantics for capids */
  40df10:	0f 84 9f 01 00 00    	je     40e0b5 <missing_captbl_node_expand+0x2e5>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40df16:	49 8d 97 b0 00 00 00 	lea    rdx,[r15+0xb0]
        __asm__ __volatile__("lock " PS_CAS_STR
  40df1d:	b9 01 00 00 00       	mov    ecx,0x1
  40df22:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40df28:	4c 89 e8             	mov    rax,r13
  40df2b:	f0 48 0f b1 0a       	lock cmpxchg QWORD PTR [rdx],rcx
  40df30:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40df33:	84 c0                	test   al,al
  40df35:	74 f1                	je     40df28 <missing_captbl_node_expand+0x158>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40df37:	49 8b 5f 38          	mov    rbx,QWORD PTR [r15+0x38]
  40df3b:	83 e3 03             	and    ebx,0x3
  40df3e:	0f 84 2c 01 00 00    	je     40e070 <missing_captbl_node_expand+0x2a0>
        __asm__ __volatile__("lock " PS_FAA_STR
  40df44:	bb 04 00 00 00       	mov    ebx,0x4
  40df49:	f0 49 0f c1 5f 38    	lock xadd QWORD PTR [r15+0x38],rbx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40df4f:	41 8b 47 08          	mov    eax,DWORD PTR [r15+0x8]
	__asm__ __volatile__(
  40df53:	48 8b 4d b8          	mov    rcx,QWORD PTR [rbp-0x48]
  40df57:	ba 01 00 00 00       	mov    edx,0x1
  40df5c:	4c 89 e7             	mov    rdi,r12
{ l->o = 0; }
  40df5f:	49 c7 87 b0 00 00 00 	mov    QWORD PTR [r15+0xb0],0x0
  40df66:	00 00 00 00 
  40df6a:	49 8b b7 98 00 00 00 	mov    rsi,QWORD PTR [r15+0x98]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40df71:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40df74:	05 1e 00 01 00       	add    eax,0x1001e
	__asm__ __volatile__(
  40df79:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40df7c:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40df80:	48 89 cd             	mov    rbp,rcx
  40df83:	49 b8 98 df 40 00 00 	movabs r8,0x40df98
  40df8a:	00 00 00 
  40df8d:	0f 05                	syscall 
  40df8f:	90                   	nop
  40df90:	eb 0d                	jmp    40df9f <missing_captbl_node_expand+0x1cf>
  40df92:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40df98:	b9 00 00 00 00       	mov    ecx,0x0
  40df9d:	eb 05                	jmp    40dfa4 <missing_captbl_node_expand+0x1d4>
  40df9f:	b9 01 00 00 00       	mov    ecx,0x1
  40dfa4:	5d                   	pop    rbp
  40dfa5:	5c                   	pop    rsp
				if (call_cap_op(root_source->captbl_cap, CAPTBL_OP_CAPTBLACTIVATE, frontier, root_source->mi.pgtbl_cap, kmem, 1)) {
  40dfa6:	85 c0                	test   eax,eax
  40dfa8:	0f 85 b4 02 00 00    	jne    40e262 <missing_captbl_node_expand+0x492>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40dfae:	41 8b 42 08          	mov    eax,DWORD PTR [r10+0x8]
	__asm__ __volatile__(
  40dfb2:	48 8b 4d b8          	mov    rcx,QWORD PTR [rbp-0x48]
  40dfb6:	4c 89 f6             	mov    rsi,r14
  40dfb9:	4c 89 ef             	mov    rdi,r13
  40dfbc:	4c 89 ea             	mov    rdx,r13
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40dfbf:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40dfc2:	05 01 00 01 00       	add    eax,0x10001
	__asm__ __volatile__(
  40dfc7:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40dfca:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40dfce:	48 89 cd             	mov    rbp,rcx
  40dfd1:	49 b8 e8 df 40 00 00 	movabs r8,0x40dfe8
  40dfd8:	00 00 00 
  40dfdb:	0f 05                	syscall 
  40dfdd:	0f 1f 00             	nop    DWORD PTR [rax]
  40dfe0:	eb 0d                	jmp    40dfef <missing_captbl_node_expand+0x21f>
  40dfe2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40dfe8:	b9 00 00 00 00       	mov    ecx,0x0
  40dfed:	eb 05                	jmp    40dff4 <missing_captbl_node_expand+0x224>
  40dfef:	b9 01 00 00 00       	mov    ecx,0x1
  40dff4:	5d                   	pop    rbp
  40dff5:	5c                   	pop    rsp
				if (call_cap_op(ci->captbl_cap, CAPTBL_OP_CONS, frontier, test_cap, 0, 0)) {
  40dff6:	85 c0                	test   eax,eax
  40dff8:	0f 84 9a fe ff ff    	je     40de98 <missing_captbl_node_expand+0xc8>
					ret = call_cap_op(root_source->captbl_cap, CAPTBL_OP_CAPCHECK, ci->captbl_cap, 384, 0, 0);
  40dffe:	49 8b 47 08          	mov    rax,QWORD PTR [r15+0x8]
  40e002:	49 8b 5a 08          	mov    rbx,QWORD PTR [r10+0x8]
  40e006:	be 80 01 00 00       	mov    esi,0x180
  40e00b:	48 8b 4d b8          	mov    rcx,QWORD PTR [rbp-0x48]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e00f:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40e012:	05 03 00 01 00       	add    eax,0x10003
	__asm__ __volatile__(
  40e017:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40e01a:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40e01e:	48 89 cd             	mov    rbp,rcx
  40e021:	49 b8 38 e0 40 00 00 	movabs r8,0x40e038
  40e028:	00 00 00 
  40e02b:	0f 05                	syscall 
  40e02d:	0f 1f 00             	nop    DWORD PTR [rax]
  40e030:	eb 0d                	jmp    40e03f <missing_captbl_node_expand+0x26f>
  40e032:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e038:	b9 00 00 00 00       	mov    ecx,0x0
  40e03d:	eb 05                	jmp    40e044 <missing_captbl_node_expand+0x274>
  40e03f:	b9 01 00 00 00       	mov    ecx,0x1
  40e044:	5d                   	pop    rbp
  40e045:	5c                   	pop    rsp
					printc("assert ret:%d\n", ret);
  40e046:	bf a0 c5 41 00       	mov    edi,0x41c5a0
  40e04b:	89 c6                	mov    esi,eax
  40e04d:	31 c0                	xor    eax,eax
  40e04f:	e8 5c e7 ff ff       	call   40c7b0 <printc.constprop.0>
  40e054:	be 2e 00 00 00       	mov    esi,0x2e
  40e059:	bf 00 cc 41 00       	mov    edi,0x41cc00
  40e05e:	e8 6d c0 ff ff       	call   40a0d0 <cos_print_str>
					assert(0); /* race? */
  40e063:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e06a:	00 00 00 00 
  40e06e:	0f 0b                	ud2    
		if (__capid_captbl_check_expand(ci)) goto error;
  40e070:	4c 89 ff             	mov    rdi,r15
  40e073:	4c 89 55 a8          	mov    QWORD PTR [rbp-0x58],r10
  40e077:	e8 64 e9 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40e07c:	4c 8b 55 a8          	mov    r10,QWORD PTR [rbp-0x58]
  40e080:	85 c0                	test   eax,eax
  40e082:	0f 85 c7 fe ff ff    	jne    40df4f <missing_captbl_node_expand+0x17f>
        __asm__ __volatile__("lock " PS_FAA_STR
  40e088:	b8 04 00 00 00       	mov    eax,0x4
  40e08d:	f0 49 0f c1 47 18    	lock xadd QWORD PTR [r15+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40e093:	49 89 47 38          	mov    QWORD PTR [r15+0x38],rax
  40e097:	e9 a8 fe ff ff       	jmp    40df44 <missing_captbl_node_expand+0x174>
  40e09c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		if (cap_frontier >= CAPTBL_EXPAND_SZ) {
  40e0a0:	48 83 f8 7f          	cmp    rax,0x7f
  40e0a4:	76 2b                	jbe    40e0d1 <missing_captbl_node_expand+0x301>
		}
		printd("begin to expanding a SUB source:%d, %d, done\n", cap_frontier, caprange_frontier);
	}
}
  40e0a6:	48 83 c4 38          	add    rsp,0x38
  40e0aa:	5b                   	pop    rbx
  40e0ab:	41 5c                	pop    r12
  40e0ad:	41 5d                	pop    r13
  40e0af:	41 5e                	pop    r14
  40e0b1:	41 5f                	pop    r15
  40e0b3:	5d                   	pop    rbp
  40e0b4:	c3                   	ret    
  40e0b5:	be 2e 00 00 00       	mov    esi,0x2e
  40e0ba:	bf a0 cb 41 00       	mov    edi,0x41cba0
  40e0bf:	e8 0c c0 ff ff       	call   40a0d0 <cos_print_str>
				assert(kmem); /* FIXME: should have a failure semantics for capids */
  40e0c4:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e0cb:	00 00 00 00 
  40e0cf:	0f 0b                	ud2    
		while (test_cap < caprange_frontier) {
  40e0d1:	48 81 fe 80 00 00 00 	cmp    rsi,0x80
  40e0d8:	76 cc                	jbe    40e0a6 <missing_captbl_node_expand+0x2d6>
  40e0da:	48 8d 45 c0          	lea    rax,[rbp-0x40]
	test_cap = CAPTBL_EXPAND_SZ;
  40e0de:	41 bd 80 00 00 00    	mov    r13d,0x80
  40e0e4:	45 31 d2             	xor    r10d,r10d
  40e0e7:	48 89 45 b8          	mov    QWORD PTR [rbp-0x48],rax
  40e0eb:	eb 10                	jmp    40e0fd <missing_captbl_node_expand+0x32d>
  40e0ed:	0f 1f 00             	nop    DWORD PTR [rax]
			test_cap += CAPTBL_EXPAND_SZ * 2;
  40e0f0:	49 81 c5 00 01 00 00 	add    r13,0x100
		while (test_cap < caprange_frontier) {
  40e0f7:	4c 39 6d b0          	cmp    QWORD PTR [rbp-0x50],r13
  40e0fb:	76 a9                	jbe    40e0a6 <missing_captbl_node_expand+0x2d6>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e0fd:	41 8b 47 08          	mov    eax,DWORD PTR [r15+0x8]
	__asm__ __volatile__(
  40e101:	41 be 01 00 00 00    	mov    r14d,0x1
  40e107:	4c 89 eb             	mov    rbx,r13
  40e10a:	4c 89 d6             	mov    rsi,r10
  40e10d:	48 8b 4d b8          	mov    rcx,QWORD PTR [rbp-0x48]
  40e111:	4c 89 f7             	mov    rdi,r14
  40e114:	4c 89 d2             	mov    rdx,r10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e117:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40e11a:	05 03 00 01 00       	add    eax,0x10003
	__asm__ __volatile__(
  40e11f:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40e122:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40e126:	48 89 cd             	mov    rbp,rcx
  40e129:	49 b8 40 e1 40 00 00 	movabs r8,0x40e140
  40e130:	00 00 00 
  40e133:	0f 05                	syscall 
  40e135:	0f 1f 00             	nop    DWORD PTR [rax]
  40e138:	eb 0d                	jmp    40e147 <missing_captbl_node_expand+0x377>
  40e13a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e140:	b9 00 00 00 00       	mov    ecx,0x0
  40e145:	eb 05                	jmp    40e14c <missing_captbl_node_expand+0x37c>
  40e147:	b9 01 00 00 00       	mov    ecx,0x1
  40e14c:	5d                   	pop    rbp
  40e14d:	5c                   	pop    rsp
			if (ret) {
  40e14e:	85 c0                	test   eax,eax
  40e150:	74 9e                	je     40e0f0 <missing_captbl_node_expand+0x320>
	return __mem_bump_alloc(ci, 1, 1);
  40e152:	4c 89 ff             	mov    rdi,r15
				frontier = test_cap - CAPMAX_ENTRY_SZ;
  40e155:	49 8d 5d fc          	lea    rbx,[r13-0x4]
	return __mem_bump_alloc(ci, 1, 1);
  40e159:	e8 02 e7 ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
				assert(kmem); /* FIXME: should have a failure semantics for capids */
  40e15e:	45 31 d2             	xor    r10d,r10d
	return __mem_bump_alloc(ci, 1, 1);
  40e161:	48 89 c7             	mov    rdi,rax
				assert(kmem); /* FIXME: should have a failure semantics for capids */
  40e164:	48 85 c0             	test   rax,rax
  40e167:	0f 84 bd 00 00 00    	je     40e22a <missing_captbl_node_expand+0x45a>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e16d:	41 8b 47 08          	mov    eax,DWORD PTR [r15+0x8]
	__asm__ __volatile__(
  40e171:	49 8b b7 98 00 00 00 	mov    rsi,QWORD PTR [r15+0x98]
  40e178:	4c 89 f2             	mov    rdx,r14
  40e17b:	48 8b 4d b8          	mov    rcx,QWORD PTR [rbp-0x48]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e17f:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40e182:	05 1e 00 01 00       	add    eax,0x1001e
	__asm__ __volatile__(
  40e187:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40e18a:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40e18e:	48 89 cd             	mov    rbp,rcx
  40e191:	49 b8 a8 e1 40 00 00 	movabs r8,0x40e1a8
  40e198:	00 00 00 
  40e19b:	0f 05                	syscall 
  40e19d:	0f 1f 00             	nop    DWORD PTR [rax]
  40e1a0:	eb 0d                	jmp    40e1af <missing_captbl_node_expand+0x3df>
  40e1a2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e1a8:	b9 00 00 00 00       	mov    ecx,0x0
  40e1ad:	eb 05                	jmp    40e1b4 <missing_captbl_node_expand+0x3e4>
  40e1af:	b9 01 00 00 00       	mov    ecx,0x1
  40e1b4:	5d                   	pop    rbp
  40e1b5:	5c                   	pop    rsp
				if (call_cap_op(root_source->captbl_cap, CAPTBL_OP_CAPTBLACTIVATE, frontier, root_source->mi.pgtbl_cap, kmem, 1)) {
  40e1b6:	85 c0                	test   eax,eax
  40e1b8:	0f 85 c0 00 00 00    	jne    40e27e <missing_captbl_node_expand+0x4ae>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e1be:	41 8b 47 08          	mov    eax,DWORD PTR [r15+0x8]
	__asm__ __volatile__(
  40e1c2:	48 8b 4d b8          	mov    rcx,QWORD PTR [rbp-0x48]
  40e1c6:	4c 89 ee             	mov    rsi,r13
  40e1c9:	4c 89 d7             	mov    rdi,r10
  40e1cc:	4c 89 d2             	mov    rdx,r10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e1cf:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40e1d2:	05 01 00 01 00       	add    eax,0x10001
	__asm__ __volatile__(
  40e1d7:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40e1da:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40e1de:	48 89 cd             	mov    rbp,rcx
  40e1e1:	49 b8 f8 e1 40 00 00 	movabs r8,0x40e1f8
  40e1e8:	00 00 00 
  40e1eb:	0f 05                	syscall 
  40e1ed:	0f 1f 00             	nop    DWORD PTR [rax]
  40e1f0:	eb 0d                	jmp    40e1ff <missing_captbl_node_expand+0x42f>
  40e1f2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e1f8:	b9 00 00 00 00       	mov    ecx,0x0
  40e1fd:	eb 05                	jmp    40e204 <missing_captbl_node_expand+0x434>
  40e1ff:	b9 01 00 00 00       	mov    ecx,0x1
  40e204:	5d                   	pop    rbp
  40e205:	5c                   	pop    rsp
				if (call_cap_op(root_source->captbl_cap, CAPTBL_OP_CONS, frontier, test_cap, 0, 0)) {
  40e206:	85 c0                	test   eax,eax
  40e208:	0f 84 e2 fe ff ff    	je     40e0f0 <missing_captbl_node_expand+0x320>
  40e20e:	be 2e 00 00 00       	mov    esi,0x2e
  40e213:	bf 40 cb 41 00       	mov    edi,0x41cb40
  40e218:	e8 b3 be ff ff       	call   40a0d0 <cos_print_str>
					assert(0); /* race? */
  40e21d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e224:	00 00 00 00 
  40e228:	0f 0b                	ud2    
  40e22a:	be 2e 00 00 00       	mov    esi,0x2e
  40e22f:	bf e0 ca 41 00       	mov    edi,0x41cae0
  40e234:	e8 97 be ff ff       	call   40a0d0 <cos_print_str>
				assert(kmem); /* FIXME: should have a failure semantics for capids */
  40e239:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e240:	00 00 00 00 
  40e244:	0f 0b                	ud2    
  40e246:	be 2e 00 00 00       	mov    esi,0x2e
  40e24b:	bf 70 cb 41 00       	mov    edi,0x41cb70
  40e250:	e8 7b be ff ff       	call   40a0d0 <cos_print_str>
		assert(!ret);
  40e255:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e25c:	00 00 00 00 
  40e260:	0f 0b                	ud2    
  40e262:	be 2e 00 00 00       	mov    esi,0x2e
  40e267:	bf d0 cb 41 00       	mov    edi,0x41cbd0
  40e26c:	e8 5f be ff ff       	call   40a0d0 <cos_print_str>
					assert(0); /* race condition? */
  40e271:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e278:	00 00 00 00 
  40e27c:	0f 0b                	ud2    
  40e27e:	be 2e 00 00 00       	mov    esi,0x2e
  40e283:	bf 10 cb 41 00       	mov    edi,0x41cb10
  40e288:	e8 43 be ff ff       	call   40a0d0 <cos_print_str>
					assert(0); /* race condition? */
  40e28d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e294:	00 00 00 00 
  40e298:	0f 0b                	ud2    
  40e29a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000040e2a0 <cos_comp_capfrontier_update>:

void
cos_comp_capfrontier_update(struct cos_compinfo *ci, capid_t cap_frontier, int try_expand)
{
  40e2a0:	f3 0f 1e fa          	endbr64 
  40e2a4:	55                   	push   rbp
  40e2a5:	66 48 0f 6e ce       	movq   xmm1,rsi
  40e2aa:	66 0f 6c c9          	punpcklqdq xmm1,xmm1
  40e2ae:	48 89 e5             	mov    rbp,rsp
  40e2b1:	41 57                	push   r15
  40e2b3:	41 89 d7             	mov    r15d,edx
  40e2b6:	41 56                	push   r14
  40e2b8:	49 89 f6             	mov    r14,rsi
  40e2bb:	41 55                	push   r13
  40e2bd:	49 89 fd             	mov    r13,rdi
  40e2c0:	41 54                	push   r12
  40e2c2:	53                   	push   rbx
  40e2c3:	48 83 ec 38          	sub    rsp,0x38
  40e2c7:	0f 29 4d b0          	movaps XMMWORD PTR [rbp-0x50],xmm1
	missing_captbl_node_expand(ci);
  40e2cb:	e8 00 fb ff ff       	call   40ddd0 <missing_captbl_node_expand>
	// printc("mmp???:cap_frontier:%d, ci->cap_frontier:%d, ci->caprange_frontier:%d\n", cap_frontier, ci->cap_frontier, ci->caprange_frontier);
	if (cap_frontier <= ci->cap_frontier) return;
  40e2d0:	4d 39 75 18          	cmp    QWORD PTR [r13+0x18],r14
  40e2d4:	0f 83 1b 01 00 00    	jae    40e3f5 <cos_comp_capfrontier_update+0x155>

	if (try_expand) {
  40e2da:	45 85 ff             	test   r15d,r15d
  40e2dd:	0f 84 cd 00 00 00    	je     40e3b0 <cos_comp_capfrontier_update+0x110>
        __asm__ __volatile__("lock " PS_CAS_STR
  40e2e3:	41 bf 01 00 00 00    	mov    r15d,0x1
		while (cap_frontier > ci->caprange_frontier) {
  40e2e9:	49 8b 45 20          	mov    rax,QWORD PTR [r13+0x20]
  40e2ed:	4c 39 f0             	cmp    rax,r14
  40e2f0:	0f 83 ba 00 00 00    	jae    40e3b0 <cos_comp_capfrontier_update+0x110>
  40e2f6:	4d 8b 65 60          	mov    r12,QWORD PTR [r13+0x60]
	return ci->memsrc;
  40e2fa:	49 8b 54 24 60       	mov    rdx,QWORD PTR [r12+0x60]
			ci->cap_frontier = ci->caprange_frontier;	
  40e2ff:	49 89 45 18          	mov    QWORD PTR [r13+0x18],rax
	assert(__compinfo_metacap(meta) == meta);
  40e303:	4c 39 e2             	cmp    rdx,r12
  40e306:	0f 85 f7 01 00 00    	jne    40e503 <cos_comp_capfrontier_update+0x263>
		frontier = ps_load(&ci->caprange_frontier) - CAPMAX_ENTRY_SZ;
  40e30c:	49 8b 5d 20          	mov    rbx,QWORD PTR [r13+0x20]
	if (self_resources) {
  40e310:	49 39 d5             	cmp    r13,rdx
  40e313:	0f 84 ef 00 00 00    	je     40e408 <cos_comp_capfrontier_update+0x168>
	assert(ci->cap_frontier <= frontier);
  40e319:	48 39 d8             	cmp    rax,rbx
  40e31c:	0f 87 fd 01 00 00    	ja     40e51f <cos_comp_capfrontier_update+0x27f>
	if (likely(ci->cap_frontier != frontier)) return 0;
  40e322:	75 db                	jne    40e2ff <cos_comp_capfrontier_update+0x5f>
	return __mem_bump_alloc(ci, 1, 1);
  40e324:	4c 89 ef             	mov    rdi,r13
  40e327:	e8 34 e5 ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40e32c:	49 89 c2             	mov    r10,rax
	assert(kmem); /* FIXME: should have a failure semantics for capids */
  40e32f:	48 85 c0             	test   rax,rax
  40e332:	0f 84 81 02 00 00    	je     40e5b9 <cos_comp_capfrontier_update+0x319>
	if (self_resources) {
  40e338:	4d 39 e5             	cmp    r13,r12
  40e33b:	0f 84 e6 00 00 00    	je     40e427 <cos_comp_capfrontier_update+0x187>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40e341:	49 8d 94 24 b0 00 00 	lea    rdx,[r12+0xb0]
  40e348:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  40e349:	31 c9                	xor    ecx,ecx
  40e34b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40e350:	48 89 c8             	mov    rax,rcx
  40e353:	f0 4c 0f b1 3a       	lock cmpxchg QWORD PTR [rdx],r15
  40e358:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40e35b:	84 c0                	test   al,al
  40e35d:	74 f1                	je     40e350 <cos_comp_capfrontier_update+0xb0>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40e35f:	41 f6 44 24 38 03    	test   BYTE PTR [r12+0x38],0x3
  40e365:	0f 84 24 02 00 00    	je     40e58f <cos_comp_capfrontier_update+0x2ef>
        __asm__ __volatile__("lock " PS_FAA_STR
  40e36b:	bb 04 00 00 00       	mov    ebx,0x4
  40e370:	f0 49 0f c1 5c 24 38 	lock xadd QWORD PTR [r12+0x38],rbx
{ l->o = 0; }
  40e377:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40e37e:	00 00 00 00 00 
		assert(captblcap);
  40e383:	48 85 db             	test   rbx,rbx
  40e386:	0f 85 9b 00 00 00    	jne    40e427 <cos_comp_capfrontier_update+0x187>
  40e38c:	be 2e 00 00 00       	mov    esi,0x2e
  40e391:	bf a0 c6 41 00       	mov    edi,0x41c6a0
  40e396:	e8 35 bd ff ff       	call   40a0d0 <cos_print_str>
  40e39b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e3a2:	00 00 00 00 
  40e3a6:	0f 0b                	ud2    
  40e3a8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40e3af:	00 
	assert(round_up_to_pow2(cap_frontier, CAPMAX_ENTRY_SZ) == cap_frontier);
  40e3b0:	49 8d 46 03          	lea    rax,[r14+0x3]
  40e3b4:	48 83 e0 fc          	and    rax,0xfffffffffffffffc
  40e3b8:	49 39 c6             	cmp    r14,rax
  40e3bb:	0f 85 96 01 00 00    	jne    40e557 <cos_comp_capfrontier_update+0x2b7>
	ci->cap_frontier = cap_frontier;
  40e3c1:	4d 89 75 18          	mov    QWORD PTR [r13+0x18],r14
	if (cap_frontier < CAPTBL_EXPAND_SZ) {
  40e3c5:	49 83 fe 7f          	cmp    r14,0x7f
  40e3c9:	76 4d                	jbe    40e418 <cos_comp_capfrontier_update+0x178>
		ci->caprange_frontier = round_up_to_pow2(cap_frontier + CAPTBL_EXPAND_SZ, CAPTBL_EXPAND_SZ * 2) - CAPTBL_EXPAND_SZ;
  40e3cb:	49 8d 86 7f 01 00 00 	lea    rax,[r14+0x17f]
  40e3d2:	30 c0                	xor    al,al
  40e3d4:	48 83 c0 80          	add    rax,0xffffffffffffff80
  40e3d8:	66 48 0f 6e c0       	movq   xmm0,rax
		ci->cap16_frontier[i] = ci->cap32_frontier[i] = ci->cap64_frontier[i] = cap_frontier;
  40e3dd:	66 0f 6f 5d b0       	movdqa xmm3,XMMWORD PTR [rbp-0x50]
  40e3e2:	66 49 0f 6e d6       	movq   xmm2,r14
  40e3e7:	66 0f 6c c2          	punpcklqdq xmm0,xmm2
  40e3eb:	41 0f 11 45 20       	movups XMMWORD PTR [r13+0x20],xmm0
  40e3f0:	41 0f 11 5d 30       	movups XMMWORD PTR [r13+0x30],xmm3
			__capid_captbl_check_expand(ci);
		}
	}

	cos_capfrontier_init(ci, cap_frontier);
}
  40e3f5:	48 83 c4 38          	add    rsp,0x38
  40e3f9:	5b                   	pop    rbx
  40e3fa:	41 5c                	pop    r12
  40e3fc:	41 5d                	pop    r13
  40e3fe:	41 5e                	pop    r14
  40e400:	41 5f                	pop    r15
  40e402:	5d                   	pop    rbp
  40e403:	c3                   	ret    
  40e404:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		frontier = ps_load(&ci->caprange_frontier) - CAPMAX_ENTRY_SZ;
  40e408:	48 83 eb 04          	sub    rbx,0x4
  40e40c:	e9 08 ff ff ff       	jmp    40e319 <cos_comp_capfrontier_update+0x79>
  40e411:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		ci->caprange_frontier = round_up_to_pow2(cap_frontier, CAPTBL_EXPAND_SZ);
  40e418:	49 8d 46 7f          	lea    rax,[r14+0x7f]
  40e41c:	48 83 e0 80          	and    rax,0xffffffffffffff80
  40e420:	66 48 0f 6e c0       	movq   xmm0,rax
  40e425:	eb b6                	jmp    40e3dd <cos_comp_capfrontier_update+0x13d>
	captblid_add = ps_load(&ci->caprange_frontier);
  40e427:	49 8b 45 20          	mov    rax,QWORD PTR [r13+0x20]
  40e42b:	48 89 45 a8          	mov    QWORD PTR [rbp-0x58],rax
	assert(captblid_add % CAPTBL_EXPAND_SZ == 0);
  40e42f:	83 e0 7f             	and    eax,0x7f
  40e432:	48 89 45 a0          	mov    QWORD PTR [rbp-0x60],rax
  40e436:	0f 85 99 01 00 00    	jne    40e5d5 <cos_comp_capfrontier_update+0x335>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e43c:	41 8b 44 24 08       	mov    eax,DWORD PTR [r12+0x8]
	__asm__ __volatile__(
  40e441:	4c 89 d7             	mov    rdi,r10
  40e444:	4c 89 fa             	mov    rdx,r15
  40e447:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  40e44b:	49 8b b4 24 98 00 00 	mov    rsi,QWORD PTR [r12+0x98]
  40e452:	00 
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e453:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40e456:	05 1e 00 01 00       	add    eax,0x1001e
	__asm__ __volatile__(
  40e45b:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40e45e:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40e462:	48 89 cd             	mov    rbp,rcx
  40e465:	49 b8 80 e4 40 00 00 	movabs r8,0x40e480
  40e46c:	00 00 00 
  40e46f:	0f 05                	syscall 
  40e471:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  40e478:	eb 0d                	jmp    40e487 <cos_comp_capfrontier_update+0x1e7>
  40e47a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e480:	b9 00 00 00 00       	mov    ecx,0x0
  40e485:	eb 05                	jmp    40e48c <cos_comp_capfrontier_update+0x1ec>
  40e487:	b9 01 00 00 00       	mov    ecx,0x1
  40e48c:	5d                   	pop    rbp
  40e48d:	5c                   	pop    rsp
	if (call_cap_op(meta->captbl_cap, CAPTBL_OP_CAPTBLACTIVATE, captblcap, meta->mi.pgtbl_cap, kmem, 1)) {
  40e48e:	85 c0                	test   eax,eax
  40e490:	0f 85 a5 00 00 00    	jne    40e53b <cos_comp_capfrontier_update+0x29b>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e496:	41 8b 45 08          	mov    eax,DWORD PTR [r13+0x8]
	__asm__ __volatile__(
  40e49a:	48 8b 7d a0          	mov    rdi,QWORD PTR [rbp-0x60]
  40e49e:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  40e4a2:	48 8b 75 a8          	mov    rsi,QWORD PTR [rbp-0x58]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e4a6:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40e4a9:	48 89 fa             	mov    rdx,rdi
	cap_no += op;
  40e4ac:	05 01 00 01 00       	add    eax,0x10001
	__asm__ __volatile__(
  40e4b1:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40e4b4:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40e4b8:	48 89 cd             	mov    rbp,rcx
  40e4bb:	49 b8 d0 e4 40 00 00 	movabs r8,0x40e4d0
  40e4c2:	00 00 00 
  40e4c5:	0f 05                	syscall 
  40e4c7:	90                   	nop
  40e4c8:	eb 0d                	jmp    40e4d7 <cos_comp_capfrontier_update+0x237>
  40e4ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e4d0:	b9 00 00 00 00       	mov    ecx,0x0
  40e4d5:	eb 05                	jmp    40e4dc <cos_comp_capfrontier_update+0x23c>
  40e4d7:	b9 01 00 00 00       	mov    ecx,0x1
  40e4dc:	5d                   	pop    rbp
  40e4dd:	5c                   	pop    rsp
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_CONS, captblcap, captblid_add, 0, 0)) {
  40e4de:	85 c0                	test   eax,eax
  40e4e0:	0f 85 8d 00 00 00    	jne    40e573 <cos_comp_capfrontier_update+0x2d3>
	frontier       = ps_load(&ci->cap_frontier);
  40e4e6:	49 8b 45 18          	mov    rax,QWORD PTR [r13+0x18]
        __asm__ __volatile__("lock " PS_FAA_STR
  40e4ea:	ba 00 01 00 00       	mov    edx,0x100
  40e4ef:	f0 49 0f c1 55 20    	lock xadd QWORD PTR [r13+0x20],rdx
        __asm__ __volatile__("lock " PS_CAS_STR
  40e4f5:	f0 49 0f b1 55 18    	lock cmpxchg QWORD PTR [r13+0x18],rdx
  40e4fb:	0f 94 c0             	sete   al
	return 0;
  40e4fe:	e9 e6 fd ff ff       	jmp    40e2e9 <cos_comp_capfrontier_update+0x49>
  40e503:	be 2e 00 00 00       	mov    esi,0x2e
  40e508:	bf 10 c6 41 00       	mov    edi,0x41c610
  40e50d:	e8 be bb ff ff       	call   40a0d0 <cos_print_str>
	assert(__compinfo_metacap(meta) == meta);
  40e512:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e519:	00 00 00 00 
  40e51d:	0f 0b                	ud2    
  40e51f:	be 2e 00 00 00       	mov    esi,0x2e
  40e524:	bf 40 c6 41 00       	mov    edi,0x41c640
  40e529:	e8 a2 bb ff ff       	call   40a0d0 <cos_print_str>
	assert(ci->cap_frontier <= frontier);
  40e52e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e535:	00 00 00 00 
  40e539:	0f 0b                	ud2    
  40e53b:	be 2e 00 00 00       	mov    esi,0x2e
  40e540:	bf 00 c7 41 00       	mov    edi,0x41c700
  40e545:	e8 86 bb ff ff       	call   40a0d0 <cos_print_str>
		assert(0); /* race condition? */
  40e54a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e551:	00 00 00 00 
  40e555:	0f 0b                	ud2    
  40e557:	be 2e 00 00 00       	mov    esi,0x2e
  40e55c:	bf d0 c9 41 00       	mov    edi,0x41c9d0
  40e561:	e8 6a bb ff ff       	call   40a0d0 <cos_print_str>
	assert(round_up_to_pow2(cap_frontier, CAPMAX_ENTRY_SZ) == cap_frontier);
  40e566:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e56d:	00 00 00 00 
  40e571:	0f 0b                	ud2    
  40e573:	be 2e 00 00 00       	mov    esi,0x2e
  40e578:	bf 30 c7 41 00       	mov    edi,0x41c730
  40e57d:	e8 4e bb ff ff       	call   40a0d0 <cos_print_str>
		assert(0); /* race? */
  40e582:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e589:	00 00 00 00 
  40e58d:	0f 0b                	ud2    
		if (__capid_captbl_check_expand(ci)) goto error;
  40e58f:	4c 89 e7             	mov    rdi,r12
  40e592:	4c 89 55 a8          	mov    QWORD PTR [rbp-0x58],r10
  40e596:	e8 45 e4 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40e59b:	4c 8b 55 a8          	mov    r10,QWORD PTR [rbp-0x58]
  40e59f:	85 c0                	test   eax,eax
  40e5a1:	75 4e                	jne    40e5f1 <cos_comp_capfrontier_update+0x351>
        __asm__ __volatile__("lock " PS_FAA_STR
  40e5a3:	b8 04 00 00 00       	mov    eax,0x4
  40e5a8:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40e5af:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  40e5b4:	e9 b2 fd ff ff       	jmp    40e36b <cos_comp_capfrontier_update+0xcb>
  40e5b9:	be 2e 00 00 00       	mov    esi,0x2e
  40e5be:	bf 70 c6 41 00       	mov    edi,0x41c670
  40e5c3:	e8 08 bb ff ff       	call   40a0d0 <cos_print_str>
	assert(kmem); /* FIXME: should have a failure semantics for capids */
  40e5c8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e5cf:	00 00 00 00 
  40e5d3:	0f 0b                	ud2    
  40e5d5:	be 2e 00 00 00       	mov    esi,0x2e
  40e5da:	bf d0 c6 41 00       	mov    edi,0x41c6d0
  40e5df:	e8 ec ba ff ff       	call   40a0d0 <cos_print_str>
	assert(captblid_add % CAPTBL_EXPAND_SZ == 0);
  40e5e4:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e5eb:	00 00 00 00 
  40e5ef:	0f 0b                	ud2    
{ l->o = 0; }
  40e5f1:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40e5f8:	00 00 00 00 00 
		assert(captblcap);
  40e5fd:	e9 8a fd ff ff       	jmp    40e38c <cos_comp_capfrontier_update+0xec>
  40e602:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40e609:	00 00 00 00 
  40e60d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040e610 <cos_thd_id_alloc>:
 */
unsigned long __thdid_alloc = NUM_CPU + 2;

thdid_t
cos_thd_id_alloc(void)
{
  40e610:	f3 0f 1e fa          	endbr64 
        __asm__ __volatile__("lock " PS_FAA_STR
  40e614:	b8 01 00 00 00       	mov    eax,0x1
  40e619:	f0 48 0f c1 05 5e da 	lock xadd QWORD PTR [rip+0x4da5e],rax        # 45c080 <__thdid_alloc>
  40e620:	04 00 
  thdid_t assignment = (thdid_t)id;

  assert((unsigned long)assignment == id);

  return assignment;
}
  40e622:	c3                   	ret    
  40e623:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40e62a:	00 00 00 00 
  40e62e:	66 90                	xchg   ax,ax

000000000040e630 <cos_ulk_page_alloc>:
	return toplvl;
}

ulkcap_t
cos_ulk_page_alloc(struct cos_compinfo *ci, pgtblcap_t ulkpt, vaddr_t uaddr)
{
  40e630:	f3 0f 1e fa          	endbr64 
  40e634:	55                   	push   rbp
  40e635:	48 89 e5             	mov    rbp,rsp
  40e638:	41 57                	push   r15
  40e63a:	41 56                	push   r14
  40e63c:	41 55                	push   r13
  40e63e:	41 54                	push   r12
  40e640:	53                   	push   rbx
  40e641:	48 83 ec 28          	sub    rsp,0x28
	return livenessid_frontier++;
  40e645:	44 8b 0d 74 da 04 00 	mov    r9d,DWORD PTR [rip+0x4da74]        # 45c0c0 <livenessid_frontier>
	return ci->memsrc;
  40e64c:	4c 8b 67 60          	mov    r12,QWORD PTR [rdi+0x60]
{
  40e650:	48 89 55 b0          	mov    QWORD PTR [rbp-0x50],rdx
	return livenessid_frontier++;
  40e654:	41 8d 41 01          	lea    eax,[r9+0x1]
  40e658:	89 05 62 da 04 00    	mov    DWORD PTR [rip+0x4da62],eax        # 45c0c0 <livenessid_frontier>
	vaddr_t kmem;
	capid_t cap;
	u32_t   lid = livenessid_bump_alloc();

	printd("cos_ulk_pgtbl_create\n");
	assert(ci_resources && ulkpt);
  40e65e:	4d 85 e4             	test   r12,r12
  40e661:	0f 84 7f 01 00 00    	je     40e7e6 <cos_ulk_page_alloc+0x1b6>
  40e667:	49 89 f5             	mov    r13,rsi
  40e66a:	48 85 f6             	test   rsi,rsi
  40e66d:	0f 84 73 01 00 00    	je     40e7e6 <cos_ulk_page_alloc+0x1b6>
	return __mem_bump_alloc(ci, 1, 1);
  40e673:	4c 89 e7             	mov    rdi,r12
  40e676:	44 89 4d bc          	mov    DWORD PTR [rbp-0x44],r9d
  40e67a:	e8 e1 e1 ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40e67f:	49 89 c6             	mov    r14,rax
	if (!*kmem) return -1;
  40e682:	48 85 c0             	test   rax,rax
  40e685:	0f 84 77 01 00 00    	je     40e802 <cos_ulk_page_alloc+0x1d2>
        __asm__ __volatile__("lock " PS_CAS_STR
  40e68b:	44 8b 4d bc          	mov    r9d,DWORD PTR [rbp-0x44]
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40e68f:	49 8d 8c 24 b0 00 00 	lea    rcx,[r12+0xb0]
  40e696:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  40e697:	ba 01 00 00 00       	mov    edx,0x1
  40e69c:	45 31 c0             	xor    r8d,r8d
  40e69f:	90                   	nop
  40e6a0:	4c 89 c0             	mov    rax,r8
  40e6a3:	f0 48 0f b1 11       	lock cmpxchg QWORD PTR [rcx],rdx
  40e6a8:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40e6ab:	84 c0                	test   al,al
  40e6ad:	74 f1                	je     40e6a0 <cos_ulk_page_alloc+0x70>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40e6af:	4d 8b 7c 24 30       	mov    r15,QWORD PTR [r12+0x30]
  40e6b4:	41 83 e7 03          	and    r15d,0x3
  40e6b8:	0f 84 b2 00 00 00    	je     40e770 <cos_ulk_page_alloc+0x140>
        __asm__ __volatile__("lock " PS_FAA_STR
  40e6be:	bb 02 00 00 00       	mov    ebx,0x2
  40e6c3:	f0 49 0f c1 5c 24 30 	lock xadd QWORD PTR [r12+0x30],rbx
{ l->o = 0; }
  40e6ca:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40e6d1:	00 00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  40e6d6:	49 89 df             	mov    r15,rbx
	if (!*cap) return -1;
  40e6d9:	48 85 db             	test   rbx,rbx
  40e6dc:	0f 84 20 01 00 00    	je     40e802 <cos_ulk_page_alloc+0x1d2>

	if (__alloc_mem_cap(ci_resources, CAP_ULK, &kmem, &cap)) return 0;
	assert(kmem && (round_to_page(kmem) == kmem));
  40e6e2:	41 f7 c6 ff 0f 00 00 	test   r14d,0xfff
  40e6e9:	0f 85 db 00 00 00    	jne    40e7ca <cos_ulk_page_alloc+0x19a>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e6ef:	41 8b 44 24 08       	mov    eax,DWORD PTR [r12+0x8]
	if (call_cap_op(ci_resources->captbl_cap, CAPTBL_OP_ULK_MEMACTIVATE, cap << 16 | lid, ci_resources->mi.pgtbl_cap << 16 | ulkpt, kmem, uaddr))
  40e6f4:	48 c1 e3 10          	shl    rbx,0x10
  40e6f8:	45 89 c9             	mov    r9d,r9d
	__asm__ __volatile__(
  40e6fb:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  40e6ff:	49 8b 94 24 98 00 00 	mov    rdx,QWORD PTR [r12+0x98]
  40e706:	00 
  40e707:	4c 09 cb             	or     rbx,r9
  40e70a:	4c 89 f7             	mov    rdi,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e70d:	c1 e0 10             	shl    eax,0x10
  40e710:	48 c1 e2 10          	shl    rdx,0x10
	cap_no += op;
  40e714:	05 38 00 01 00       	add    eax,0x10038
  40e719:	48 89 d6             	mov    rsi,rdx
	__asm__ __volatile__(
  40e71c:	48 8b 55 b0          	mov    rdx,QWORD PTR [rbp-0x50]
  40e720:	4c 09 ee             	or     rsi,r13
  40e723:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40e726:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40e72a:	48 89 cd             	mov    rbp,rcx
  40e72d:	49 b8 48 e7 40 00 00 	movabs r8,0x40e748
  40e734:	00 00 00 
  40e737:	0f 05                	syscall 
  40e739:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  40e740:	eb 0d                	jmp    40e74f <cos_ulk_page_alloc+0x11f>
  40e742:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e748:	b9 00 00 00 00       	mov    ecx,0x0
  40e74d:	eb 05                	jmp    40e754 <cos_ulk_page_alloc+0x124>
  40e74f:	b9 01 00 00 00       	mov    ecx,0x1
  40e754:	5d                   	pop    rbp
  40e755:	5c                   	pop    rsp
  40e756:	85 c0                	test   eax,eax
  40e758:	75 46                	jne    40e7a0 <cos_ulk_page_alloc+0x170>
		BUG();

	return cap;
}
  40e75a:	48 83 c4 28          	add    rsp,0x28
  40e75e:	4c 89 f8             	mov    rax,r15
  40e761:	5b                   	pop    rbx
  40e762:	41 5c                	pop    r12
  40e764:	41 5d                	pop    r13
  40e766:	41 5e                	pop    r14
  40e768:	41 5f                	pop    r15
  40e76a:	5d                   	pop    rbp
  40e76b:	c3                   	ret    
  40e76c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  40e770:	4c 89 e7             	mov    rdi,r12
  40e773:	44 89 4d bc          	mov    DWORD PTR [rbp-0x44],r9d
  40e777:	e8 64 e2 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40e77c:	44 8b 4d bc          	mov    r9d,DWORD PTR [rbp-0x44]
  40e780:	85 c0                	test   eax,eax
  40e782:	75 38                	jne    40e7bc <cos_ulk_page_alloc+0x18c>
        __asm__ __volatile__("lock " PS_FAA_STR
  40e784:	b8 04 00 00 00       	mov    eax,0x4
  40e789:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40e790:	49 89 44 24 30       	mov    QWORD PTR [r12+0x30],rax
  40e795:	e9 24 ff ff ff       	jmp    40e6be <cos_ulk_page_alloc+0x8e>
  40e79a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e7a0:	be 1b 00 00 00       	mov    esi,0x1b
  40e7a5:	bf 8f cc 41 00       	mov    edi,0x41cc8f
  40e7aa:	e8 21 b9 ff ff       	call   40a0d0 <cos_print_str>
		BUG();
  40e7af:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e7b6:	00 00 00 00 
  40e7ba:	0f 0b                	ud2    
{ l->o = 0; }
  40e7bc:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40e7c3:	00 00 00 00 00 
	if (!*cap) return -1;
  40e7c8:	eb 90                	jmp    40e75a <cos_ulk_page_alloc+0x12a>
  40e7ca:	be 2e 00 00 00       	mov    esi,0x2e
  40e7cf:	bf 60 cc 41 00       	mov    edi,0x41cc60
  40e7d4:	e8 f7 b8 ff ff       	call   40a0d0 <cos_print_str>
	assert(kmem && (round_to_page(kmem) == kmem));
  40e7d9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e7e0:	00 00 00 00 
  40e7e4:	0f 0b                	ud2    
  40e7e6:	be 2e 00 00 00       	mov    esi,0x2e
  40e7eb:	bf 30 cc 41 00       	mov    edi,0x41cc30
  40e7f0:	e8 db b8 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci_resources && ulkpt);
  40e7f5:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e7fc:	00 00 00 00 
  40e800:	0f 0b                	ud2    
	if (__alloc_mem_cap(ci_resources, CAP_ULK, &kmem, &cap)) return 0;
  40e802:	45 31 ff             	xor    r15d,r15d
  40e805:	e9 50 ff ff ff       	jmp    40e75a <cos_ulk_page_alloc+0x12a>
  40e80a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000040e810 <__cos_thd_alloc>:
	return __cos_ulk_info.curr_pg;
}

static thdcap_t
__cos_thd_alloc(struct cos_compinfo *ci, compcap_t comp, thdclosure_index_t init_data, thdid_t tid)
{
  40e810:	55                   	push   rbp
  40e811:	48 89 e5             	mov    rbp,rsp
  40e814:	41 57                	push   r15
  40e816:	41 56                	push   r14
  40e818:	41 55                	push   r13
  40e81a:	41 54                	push   r12
  40e81c:	53                   	push   rbx
  40e81d:	48 83 ec 28          	sub    rsp,0x28
  40e821:	48 89 4d b8          	mov    QWORD PTR [rbp-0x48],rcx
	capid_t  cap;
	int      ret;

	printd("cos_thd_alloc\n");

	assert(ci && comp > 0);
  40e825:	48 85 ff             	test   rdi,rdi
  40e828:	0f 84 bb 01 00 00    	je     40e9e9 <__cos_thd_alloc+0x1d9>
  40e82e:	49 89 f7             	mov    r15,rsi
  40e831:	48 85 f6             	test   rsi,rsi
  40e834:	0f 84 af 01 00 00    	je     40e9e9 <__cos_thd_alloc+0x1d9>
	if (!__cos_ulk_info.toplvl) return 0;
  40e83a:	4c 8b 25 ff 21 19 00 	mov    r12,QWORD PTR [rip+0x1921ff]        # 5a0a40 <__cos_ulk_info>
  40e841:	49 89 fd             	mov    r13,rdi
  40e844:	89 d3                	mov    ebx,edx
  40e846:	4d 85 e4             	test   r12,r12
  40e849:	74 46                	je     40e891 <__cos_thd_alloc+0x81>
	if (!__cos_ulk_info.curr_pg || tid % ULK_STACKS_PER_PAGE == 0) {
  40e84b:	48 8b 05 fe 21 19 00 	mov    rax,QWORD PTR [rip+0x1921fe]        # 5a0a50 <__cos_ulk_info+0x10>
  40e852:	48 85 c0             	test   rax,rax
  40e855:	74 0a                	je     40e861 <__cos_thd_alloc+0x51>
  40e857:	f6 45 b8 0f          	test   BYTE PTR [rbp-0x48],0xf
  40e85b:	0f 85 4f 01 00 00    	jne    40e9b0 <__cos_thd_alloc+0x1a0>
		__cos_ulk_info.curr_pg = cos_ulk_page_alloc(ci, __cos_ulk_info.toplvl, __cos_ulk_info.pg_frontier);
  40e861:	48 8b 15 f0 21 19 00 	mov    rdx,QWORD PTR [rip+0x1921f0]        # 5a0a58 <__cos_ulk_info+0x18>
  40e868:	4c 89 e6             	mov    rsi,r12
  40e86b:	4c 89 ef             	mov    rdi,r13
  40e86e:	e8 bd fd ff ff       	call   40e630 <cos_ulk_page_alloc>
  40e873:	48 89 05 d6 21 19 00 	mov    QWORD PTR [rip+0x1921d6],rax        # 5a0a50 <__cos_ulk_info+0x10>
  40e87a:	49 89 c4             	mov    r12,rax
		assert(__cos_ulk_info.curr_pg);
  40e87d:	48 85 c0             	test   rax,rax
  40e880:	0f 84 9b 01 00 00    	je     40ea21 <__cos_thd_alloc+0x211>
		__cos_ulk_info.pg_frontier += PAGE_SIZE;
  40e886:	48 81 05 c7 21 19 00 	add    QWORD PTR [rip+0x1921c7],0x1000        # 5a0a58 <__cos_ulk_info+0x18>
  40e88d:	00 10 00 00 
	return __mem_bump_alloc(ci, 1, 1);
  40e891:	4c 89 ef             	mov    rdi,r13
  40e894:	e8 c7 df ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40e899:	49 89 c2             	mov    r10,rax
	if (!*kmem) return -1;
  40e89c:	48 85 c0             	test   rax,rax
  40e89f:	0f 84 98 01 00 00    	je     40ea3d <__cos_thd_alloc+0x22d>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40e8a5:	49 8d 8d b0 00 00 00 	lea    rcx,[r13+0xb0]
        __asm__ __volatile__("lock " PS_CAS_STR
  40e8ac:	ba 01 00 00 00       	mov    edx,0x1
  40e8b1:	31 f6                	xor    esi,esi
  40e8b3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40e8b8:	48 89 f0             	mov    rax,rsi
  40e8bb:	f0 48 0f b1 11       	lock cmpxchg QWORD PTR [rcx],rdx
  40e8c0:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40e8c3:	84 c0                	test   al,al
  40e8c5:	74 f1                	je     40e8b8 <__cos_thd_alloc+0xa8>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40e8c7:	4d 8b 75 28          	mov    r14,QWORD PTR [r13+0x28]
  40e8cb:	41 83 e6 03          	and    r14d,0x3
  40e8cf:	0f 84 b3 00 00 00    	je     40e988 <__cos_thd_alloc+0x178>
        __asm__ __volatile__("lock " PS_FAA_STR
  40e8d5:	ba 01 00 00 00       	mov    edx,0x1
  40e8da:	f0 49 0f c1 55 28    	lock xadd QWORD PTR [r13+0x28],rdx
{ l->o = 0; }
  40e8e0:	49 c7 85 b0 00 00 00 	mov    QWORD PTR [r13+0xb0],0x0
  40e8e7:	00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  40e8eb:	49 89 d6             	mov    r14,rdx
	if (!*cap) return -1;
  40e8ee:	48 85 d2             	test   rdx,rdx
  40e8f1:	0f 84 46 01 00 00    	je     40ea3d <__cos_thd_alloc+0x22d>

	ulkcap = __cos_thd_ulk_page_alloc(ci, tid);

	if (__alloc_mem_cap(ci, CAP_THD, &kmem, &cap)) return 0;
	assert(!(init_data & ~((1 << 16) - 1)));
  40e8f7:	f7 c3 00 00 ff ff    	test   ebx,0xffff0000
  40e8fd:	0f 85 02 01 00 00    	jne    40ea05 <__cos_thd_alloc+0x1f5>
	/* TODO: Add cap size checking */
	ret = call_cap_op(ci->captbl_cap, CAPTBL_OP_THDACTIVATE, (init_data << 16) | cap,
  40e903:	c1 e3 10             	shl    ebx,0x10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e906:	41 8b 45 08          	mov    eax,DWORD PTR [r13+0x8]
	__asm__ __volatile__(
  40e90a:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  40e90e:	4c 89 d7             	mov    rdi,r10
  40e911:	48 63 db             	movsxd rbx,ebx
  40e914:	48 09 d3             	or     rbx,rdx
			  __compinfo_metacap(ci)->mi.pgtbl_cap << 16 | comp, kmem, ulkcap << 16 | tid);
  40e917:	49 8b 55 60          	mov    rdx,QWORD PTR [r13+0x60]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e91b:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40e91e:	05 04 00 01 00       	add    eax,0x10004
  40e923:	48 8b b2 98 00 00 00 	mov    rsi,QWORD PTR [rdx+0x98]
  40e92a:	4c 89 e2             	mov    rdx,r12
  40e92d:	48 c1 e2 10          	shl    rdx,0x10
	ret = call_cap_op(ci->captbl_cap, CAPTBL_OP_THDACTIVATE, (init_data << 16) | cap,
  40e931:	48 0b 55 b8          	or     rdx,QWORD PTR [rbp-0x48]
			  __compinfo_metacap(ci)->mi.pgtbl_cap << 16 | comp, kmem, ulkcap << 16 | tid);
  40e935:	48 c1 e6 10          	shl    rsi,0x10
	ret = call_cap_op(ci->captbl_cap, CAPTBL_OP_THDACTIVATE, (init_data << 16) | cap,
  40e939:	4c 09 fe             	or     rsi,r15
	__asm__ __volatile__(
  40e93c:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40e93f:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40e943:	48 89 cd             	mov    rbp,rcx
  40e946:	49 b8 60 e9 40 00 00 	movabs r8,0x40e960
  40e94d:	00 00 00 
  40e950:	0f 05                	syscall 
  40e952:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e958:	eb 0d                	jmp    40e967 <__cos_thd_alloc+0x157>
  40e95a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e960:	b9 00 00 00 00       	mov    ecx,0x0
  40e965:	eb 05                	jmp    40e96c <__cos_thd_alloc+0x15c>
  40e967:	b9 01 00 00 00       	mov    ecx,0x1
  40e96c:	5d                   	pop    rbp
  40e96d:	5c                   	pop    rsp
	if (ret) BUG();
  40e96e:	85 c0                	test   eax,eax
  40e970:	75 4e                	jne    40e9c0 <__cos_thd_alloc+0x1b0>

	return cap;
}
  40e972:	48 83 c4 28          	add    rsp,0x28
  40e976:	4c 89 f0             	mov    rax,r14
  40e979:	5b                   	pop    rbx
  40e97a:	41 5c                	pop    r12
  40e97c:	41 5d                	pop    r13
  40e97e:	41 5e                	pop    r14
  40e980:	41 5f                	pop    r15
  40e982:	5d                   	pop    rbp
  40e983:	c3                   	ret    
  40e984:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  40e988:	4c 89 ef             	mov    rdi,r13
  40e98b:	4c 89 55 b0          	mov    QWORD PTR [rbp-0x50],r10
  40e98f:	e8 4c e0 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40e994:	4c 8b 55 b0          	mov    r10,QWORD PTR [rbp-0x50]
  40e998:	85 c0                	test   eax,eax
  40e99a:	75 40                	jne    40e9dc <__cos_thd_alloc+0x1cc>
        __asm__ __volatile__("lock " PS_FAA_STR
  40e99c:	b8 04 00 00 00       	mov    eax,0x4
  40e9a1:	f0 49 0f c1 45 18    	lock xadd QWORD PTR [r13+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40e9a7:	49 89 45 28          	mov    QWORD PTR [r13+0x28],rax
  40e9ab:	e9 25 ff ff ff       	jmp    40e8d5 <__cos_thd_alloc+0xc5>
  40e9b0:	49 89 c4             	mov    r12,rax
	return __cos_ulk_info.curr_pg;
  40e9b3:	e9 d9 fe ff ff       	jmp    40e891 <__cos_thd_alloc+0x81>
  40e9b8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40e9bf:	00 
  40e9c0:	be 1b 00 00 00       	mov    esi,0x1b
  40e9c5:	bf 3f cd 41 00       	mov    edi,0x41cd3f
  40e9ca:	e8 01 b7 ff ff       	call   40a0d0 <cos_print_str>
	if (ret) BUG();
  40e9cf:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e9d6:	00 00 00 00 
  40e9da:	0f 0b                	ud2    
{ l->o = 0; }
  40e9dc:	49 c7 85 b0 00 00 00 	mov    QWORD PTR [r13+0xb0],0x0
  40e9e3:	00 00 00 00 
	if (!*cap) return -1;
  40e9e7:	eb 89                	jmp    40e972 <__cos_thd_alloc+0x162>
  40e9e9:	be 2e 00 00 00       	mov    esi,0x2e
  40e9ee:	bf b0 cc 41 00       	mov    edi,0x41ccb0
  40e9f3:	e8 d8 b6 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci && comp > 0);
  40e9f8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e9ff:	00 00 00 00 
  40ea03:	0f 0b                	ud2    
  40ea05:	be 2e 00 00 00       	mov    esi,0x2e
  40ea0a:	bf 10 cd 41 00       	mov    edi,0x41cd10
  40ea0f:	e8 bc b6 ff ff       	call   40a0d0 <cos_print_str>
	assert(!(init_data & ~((1 << 16) - 1)));
  40ea14:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ea1b:	00 00 00 00 
  40ea1f:	0f 0b                	ud2    
  40ea21:	be 2e 00 00 00       	mov    esi,0x2e
  40ea26:	bf e0 cc 41 00       	mov    edi,0x41cce0
  40ea2b:	e8 a0 b6 ff ff       	call   40a0d0 <cos_print_str>
		assert(__cos_ulk_info.curr_pg);
  40ea30:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ea37:	00 00 00 00 
  40ea3b:	0f 0b                	ud2    
	if (__alloc_mem_cap(ci, CAP_THD, &kmem, &cap)) return 0;
  40ea3d:	45 31 f6             	xor    r14d,r14d
  40ea40:	e9 2d ff ff ff       	jmp    40e972 <__cos_thd_alloc+0x162>
  40ea45:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40ea4c:	00 00 00 00 

000000000040ea50 <cos_ulk_map_in>:
{
  40ea50:	f3 0f 1e fa          	endbr64 
  40ea54:	55                   	push   rbp
  40ea55:	48 89 e5             	mov    rbp,rsp
  40ea58:	41 54                	push   r12
  40ea5a:	53                   	push   rbx
  40ea5b:	48 83 ec 10          	sub    rsp,0x10
	assert(ptc && __cos_ulk_info.secondlvl);
  40ea5f:	48 85 ff             	test   rdi,rdi
  40ea62:	74 67                	je     40eacb <cos_ulk_map_in+0x7b>
  40ea64:	48 8b 1d dd 1f 19 00 	mov    rbx,QWORD PTR [rip+0x191fdd]        # 5a0a48 <__cos_ulk_info+0x8>
  40ea6b:	48 85 db             	test   rbx,rbx
  40ea6e:	74 5b                	je     40eacb <cos_ulk_map_in+0x7b>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40ea70:	c1 e7 10             	shl    edi,0x10
	__asm__ __volatile__(
  40ea73:	31 d2                	xor    edx,edx
  40ea75:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  40ea79:	48 be 00 00 00 00 80 	movabs rsi,0x7f8000000000
  40ea80:	7f 00 00 
	cap_no += op;
  40ea83:	8d 87 01 00 01 00    	lea    eax,[rdi+0x10001]
	__asm__ __volatile__(
  40ea89:	48 89 d7             	mov    rdi,rdx
  40ea8c:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40ea8f:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40ea93:	48 89 cd             	mov    rbp,rcx
  40ea96:	49 b8 b0 ea 40 00 00 	movabs r8,0x40eab0
  40ea9d:	00 00 00 
  40eaa0:	0f 05                	syscall 
  40eaa2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40eaa8:	eb 0d                	jmp    40eab7 <cos_ulk_map_in+0x67>
  40eaaa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40eab0:	b9 00 00 00 00       	mov    ecx,0x0
  40eab5:	eb 05                	jmp    40eabc <cos_ulk_map_in+0x6c>
  40eab7:	b9 01 00 00 00       	mov    ecx,0x1
  40eabc:	5d                   	pop    rbp
  40eabd:	5c                   	pop    rsp
	if (call_cap_op(ptc, CAPTBL_OP_CONS, __cos_ulk_info.secondlvl, ULK_BASE_ADDR, 0, 0)) {
  40eabe:	f7 d8                	neg    eax
  40eac0:	19 c0                	sbb    eax,eax
}
  40eac2:	48 83 c4 10          	add    rsp,0x10
  40eac6:	5b                   	pop    rbx
  40eac7:	41 5c                	pop    r12
  40eac9:	5d                   	pop    rbp
  40eaca:	c3                   	ret    
  40eacb:	be 2e 00 00 00       	mov    esi,0x2e
  40ead0:	bf 60 cd 41 00       	mov    edi,0x41cd60
  40ead5:	e8 f6 b5 ff ff       	call   40a0d0 <cos_print_str>
	assert(ptc && __cos_ulk_info.secondlvl);
  40eada:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40eae1:	00 00 00 00 
  40eae5:	0f 0b                	ud2    
  40eae7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40eaee:	00 00 

000000000040eaf0 <cos_thd_alloc_ext>:

#include <cos_thd_init.h>

thdcap_t
cos_thd_alloc_ext(struct cos_compinfo *ci, compcap_t comp, thdclosure_index_t idx)
{
  40eaf0:	f3 0f 1e fa          	endbr64 
        __asm__ __volatile__("lock " PS_FAA_STR
  40eaf4:	b9 01 00 00 00       	mov    ecx,0x1
  40eaf9:	f0 48 0f c1 0d 7e d5 	lock xadd QWORD PTR [rip+0x4d57e],rcx        # 45c080 <__thdid_alloc>
  40eb00:	04 00 
	thdid_t tid = cos_thd_id_alloc();

	if (idx < 1) return 0;
  40eb02:	85 d2                	test   edx,edx
  40eb04:	7e 0a                	jle    40eb10 <cos_thd_alloc_ext+0x20>

	return __cos_thd_alloc(ci, comp, idx, tid);
  40eb06:	e9 05 fd ff ff       	jmp    40e810 <__cos_thd_alloc>
  40eb0b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
}
  40eb10:	31 c0                	xor    eax,eax
  40eb12:	c3                   	ret    
  40eb13:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40eb1a:	00 00 00 00 
  40eb1e:	66 90                	xchg   ax,ax

000000000040eb20 <cos_thd_alloc>:

thdcap_t
cos_thd_alloc(struct cos_compinfo *ci, compcap_t comp, cos_thd_fn_t fn, void *data)
{
  40eb20:	f3 0f 1e fa          	endbr64 
  40eb24:	49 89 ca             	mov    r10,rcx
  40eb27:	b9 01 00 00 00       	mov    ecx,0x1
  40eb2c:	f0 48 0f c1 0d 4b d5 	lock xadd QWORD PTR [rip+0x4d54b],rcx        # 45c080 <__thdid_alloc>
  40eb33:	04 00 
	if (!fn) return -1;
  40eb35:	48 85 d2             	test   rdx,rdx
  40eb38:	0f 84 c9 00 00 00    	je     40ec07 <cos_thd_alloc+0xe7>
  40eb3e:	55                   	push   rbp
  40eb3f:	49 89 f8             	mov    r8,rdi
  40eb42:	49 89 f1             	mov    r9,rsi
  40eb45:	48 89 d7             	mov    rdi,rdx
  40eb48:	45 31 db             	xor    r11d,r11d
  40eb4b:	48 89 e5             	mov    rbp,rsp
  40eb4e:	41 54                	push   r12
  40eb50:	53                   	push   rbx
  40eb51:	bb 02 00 00 00       	mov    ebx,0x2
	for (i = 0; i < COS_THD_INIT_REGION_SIZE; i++) {
  40eb56:	ba 00 f9 59 00       	mov    edx,0x59f900
  40eb5b:	31 f6                	xor    esi,esi
		if (__thd_init_data[i].fn == NULL) {
  40eb5d:	48 83 3a 00          	cmp    QWORD PTR [rdx],0x0
  40eb61:	74 1d                	je     40eb80 <cos_thd_alloc+0x60>
	for (i = 0; i < COS_THD_INIT_REGION_SIZE; i++) {
  40eb63:	83 c6 01             	add    esi,0x1
  40eb66:	48 83 c2 10          	add    rdx,0x10
  40eb6a:	81 fe 00 01 00 00    	cmp    esi,0x100
  40eb70:	75 eb                	jne    40eb5d <cos_thd_alloc+0x3d>
	if (!tried) {
  40eb72:	83 fb 01             	cmp    ebx,0x1
  40eb75:	74 6d                	je     40ebe4 <cos_thd_alloc+0xc4>
  40eb77:	bb 01 00 00 00       	mov    ebx,0x1
  40eb7c:	eb d8                	jmp    40eb56 <cos_thd_alloc+0x36>
  40eb7e:	66 90                	xchg   ax,ax
  40eb80:	4c 89 d8             	mov    rax,r11
  40eb83:	f0 48 0f b1 3a       	lock cmpxchg QWORD PTR [rdx],rdi
  40eb88:	0f 94 c0             	sete   al
			if (!ret) continue;
  40eb8b:	84 c0                	test   al,al
  40eb8d:	74 d4                	je     40eb63 <cos_thd_alloc+0x43>
			assert(__thd_init_data[i].fn == fn);
  40eb8f:	4c 63 e6             	movsxd r12,esi
  40eb92:	49 c1 e4 04          	shl    r12,0x4
  40eb96:	49 8d 84 24 00 f9 59 	lea    rax,[r12+0x59f900]
  40eb9d:	00 
  40eb9e:	49 3b bc 24 00 f9 59 	cmp    rdi,QWORD PTR [r12+0x59f900]
  40eba5:	00 
  40eba6:	75 43                	jne    40ebeb <cos_thd_alloc+0xcb>
			__thd_init_data[i].data = data;
  40eba8:	4c 89 50 08          	mov    QWORD PTR [rax+0x8],r10
			return i + 1;
  40ebac:	8d 5e 01             	lea    ebx,[rsi+0x1]
	thdid_t  tid = cos_thd_id_alloc();
	int      idx = cos_thd_init_alloc(fn, data);
	thdcap_t ret;

	if (idx < 1) return 0;
	ret = __cos_thd_alloc(ci, comp, idx, tid);
  40ebaf:	4c 89 c7             	mov    rdi,r8
  40ebb2:	4c 89 ce             	mov    rsi,r9
  40ebb5:	89 da                	mov    edx,ebx
  40ebb7:	e8 54 fc ff ff       	call   40e810 <__cos_thd_alloc>
	if (!ret) cos_thd_init_free(idx);
  40ebbc:	48 85 c0             	test   rax,rax
  40ebbf:	75 1e                	jne    40ebdf <cos_thd_alloc+0xbf>
 * thread creation failed for some reason.
 */
static void
cos_thd_init_free(thdclosure_index_t idx)
{
	if (idx > COS_THD_INIT_REGION_SIZE || idx <= 0 || !__thd_init_data[idx].fn) return;
  40ebc1:	48 63 f3             	movsxd rsi,ebx
  40ebc4:	48 c1 e6 04          	shl    rsi,0x4
  40ebc8:	48 83 be 00 f9 59 00 	cmp    QWORD PTR [rsi+0x59f900],0x0
  40ebcf:	00 
  40ebd0:	74 12                	je     40ebe4 <cos_thd_alloc+0xc4>
	__thd_init_data[idx].fn   = NULL;
  40ebd2:	66 0f ef c0          	pxor   xmm0,xmm0
  40ebd6:	41 0f 11 84 24 00 f9 	movups XMMWORD PTR [r12+0x59f900],xmm0
  40ebdd:	59 00 

	return ret;
}
  40ebdf:	5b                   	pop    rbx
  40ebe0:	41 5c                	pop    r12
  40ebe2:	5d                   	pop    rbp
  40ebe3:	c3                   	ret    
  40ebe4:	5b                   	pop    rbx
	if (idx < 1) return 0;
  40ebe5:	31 c0                	xor    eax,eax
}
  40ebe7:	41 5c                	pop    r12
  40ebe9:	5d                   	pop    rbp
  40ebea:	c3                   	ret    
  40ebeb:	be 67 00 00 00       	mov    esi,0x67
  40ebf0:	bf 90 cd 41 00       	mov    edi,0x41cd90
  40ebf5:	e8 d6 b4 ff ff       	call   40a0d0 <cos_print_str>
			assert(__thd_init_data[i].fn == fn);
  40ebfa:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ec01:	00 00 00 00 
  40ec05:	0f 0b                	ud2    
	if (idx < 1) return 0;
  40ec07:	31 c0                	xor    eax,eax
}
  40ec09:	c3                   	ret    
  40ec0a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000040ec10 <cos_shared_kernel_page_alloc_at>:

vaddr_t
cos_shared_kernel_page_alloc_at(struct cos_compinfo *ci, vaddr_t mem_ptr)
{
  40ec10:	f3 0f 1e fa          	endbr64 
  40ec14:	55                   	push   rbp
  40ec15:	48 89 e5             	mov    rbp,rsp
  40ec18:	41 55                	push   r13
  40ec1a:	41 54                	push   r12
  40ec1c:	53                   	push   rbx
  40ec1d:	48 83 ec 18          	sub    rsp,0x18
	return ci->memsrc;
  40ec21:	4c 8b 67 60          	mov    r12,QWORD PTR [rdi+0x60]
	vaddr_t ptemem_cap;
	int ret;

	struct cos_compinfo *meta = __compinfo_metacap(ci);

	assert(meta == __compinfo_metacap(meta));
  40ec25:	4d 39 64 24 60       	cmp    QWORD PTR [r12+0x60],r12
  40ec2a:	0f 85 9c 00 00 00    	jne    40eccc <cos_shared_kernel_page_alloc_at+0xbc>
  40ec30:	48 89 fb             	mov    rbx,rdi
	return __mem_bump_alloc(ci, 1, 1);
  40ec33:	4c 89 e7             	mov    rdi,r12
  40ec36:	49 89 f5             	mov    r13,rsi
  40ec39:	e8 22 dc ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40ec3e:	49 89 c2             	mov    r10,rax

	ptemem_cap = __kmem_bump_alloc(meta);

	assert(ptemem_cap != 0);
  40ec41:	48 85 c0             	test   rax,rax
  40ec44:	0f 84 9e 00 00 00    	je     40ece8 <cos_shared_kernel_page_alloc_at+0xd8>
  40ec4a:	48 8b 33             	mov    rsi,QWORD PTR [rbx]
  40ec4d:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  40ec51:	ba 0c 00 00 00       	mov    edx,0xc
  40ec56:	4c 89 d3             	mov    rbx,r10

	/* Actually map in the memory. */
	ret = call_cap_op(meta->mi.pgtbl_cap, CAPTBL_OP_MEMACTIVATE, ptemem_cap, ci->pgtbl_cap, mem_ptr, PAGE_ORDER);
  40ec59:	49 8b 84 24 98 00 00 	mov    rax,QWORD PTR [r12+0x98]
  40ec60:	00 
  40ec61:	4c 89 ef             	mov    rdi,r13
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40ec64:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40ec67:	05 17 00 01 00       	add    eax,0x10017
	__asm__ __volatile__(
  40ec6c:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40ec6f:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40ec73:	48 89 cd             	mov    rbp,rcx
  40ec76:	49 b8 90 ec 40 00 00 	movabs r8,0x40ec90
  40ec7d:	00 00 00 
  40ec80:	0f 05                	syscall 
  40ec82:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40ec88:	eb 0d                	jmp    40ec97 <cos_shared_kernel_page_alloc_at+0x87>
  40ec8a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40ec90:	b9 00 00 00 00       	mov    ecx,0x0
  40ec95:	eb 05                	jmp    40ec9c <cos_shared_kernel_page_alloc_at+0x8c>
  40ec97:	b9 01 00 00 00       	mov    ecx,0x1
  40ec9c:	5d                   	pop    rbp
  40ec9d:	5c                   	pop    rsp
	if (ret) {
  40ec9e:	85 c0                	test   eax,eax
  40eca0:	75 0e                	jne    40ecb0 <cos_shared_kernel_page_alloc_at+0xa0>
		BUG();
	}

	return ptemem_cap;
}
  40eca2:	48 83 c4 18          	add    rsp,0x18
  40eca6:	4c 89 d0             	mov    rax,r10
  40eca9:	5b                   	pop    rbx
  40ecaa:	41 5c                	pop    r12
  40ecac:	41 5d                	pop    r13
  40ecae:	5d                   	pop    rbp
  40ecaf:	c3                   	ret    
  40ecb0:	be 1c 00 00 00       	mov    esi,0x1c
  40ecb5:	bf 58 ce 41 00       	mov    edi,0x41ce58
  40ecba:	e8 11 b4 ff ff       	call   40a0d0 <cos_print_str>
		BUG();
  40ecbf:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ecc6:	00 00 00 00 
  40ecca:	0f 0b                	ud2    
  40eccc:	be 2f 00 00 00       	mov    esi,0x2f
  40ecd1:	bf f8 cd 41 00       	mov    edi,0x41cdf8
  40ecd6:	e8 f5 b3 ff ff       	call   40a0d0 <cos_print_str>
	assert(meta == __compinfo_metacap(meta));
  40ecdb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ece2:	00 00 00 00 
  40ece6:	0f 0b                	ud2    
  40ece8:	be 2f 00 00 00       	mov    esi,0x2f
  40eced:	bf 28 ce 41 00       	mov    edi,0x41ce28
  40ecf2:	e8 d9 b3 ff ff       	call   40a0d0 <cos_print_str>
	assert(ptemem_cap != 0);
  40ecf7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ecfe:	00 00 00 00 
  40ed02:	0f 0b                	ud2    
  40ed04:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40ed0b:	00 00 00 00 
  40ed0f:	90                   	nop

000000000040ed10 <cos_shared_kernel_page_alloc>:

vaddr_t
cos_shared_kernel_page_alloc(struct cos_compinfo *ci, vaddr_t *resource)
{
  40ed10:	f3 0f 1e fa          	endbr64 
  40ed14:	55                   	push   rbp
  40ed15:	48 89 e5             	mov    rbp,rsp
  40ed18:	41 56                	push   r14
  40ed1a:	41 55                	push   r13
  40ed1c:	41 54                	push   r12
  40ed1e:	53                   	push   rbx
  40ed1f:	48 83 ec 10          	sub    rsp,0x10
	return ci->memsrc;
  40ed23:	4c 8b 77 60          	mov    r14,QWORD PTR [rdi+0x60]
	int ret;
	vaddr_t heap_vaddr = 0;
	vaddr_t kmem = 0;
	struct cos_compinfo *meta = __compinfo_metacap(ci);

	assert(meta == __compinfo_metacap(meta));
  40ed27:	4d 39 76 60          	cmp    QWORD PTR [r14+0x60],r14
  40ed2b:	0f 85 bb 00 00 00    	jne    40edec <cos_shared_kernel_page_alloc+0xdc>
  40ed31:	49 89 fc             	mov    r12,rdi
  40ed34:	49 89 f5             	mov    r13,rsi
	return __mem_bump_alloc(ci, 1, 1);
  40ed37:	e8 24 db ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40ed3c:	48 89 c3             	mov    rbx,rax

	kmem = __kmem_bump_alloc(ci);
	assert(kmem);
  40ed3f:	48 85 c0             	test   rax,rax
  40ed42:	0f 84 c0 00 00 00    	je     40ee08 <cos_shared_kernel_page_alloc+0xf8>

	heap_vaddr = __page_bump_valloc(ci, PAGE_SIZE, PAGE_SIZE);
  40ed48:	ba 00 10 00 00       	mov    edx,0x1000
  40ed4d:	be 00 10 00 00       	mov    esi,0x1000
  40ed52:	4c 89 e7             	mov    rdi,r12
  40ed55:	e8 c6 e1 ff ff       	call   40cf20 <__page_bump_valloc>
  40ed5a:	49 89 c2             	mov    r10,rax
	assert(heap_vaddr);
  40ed5d:	48 85 c0             	test   rax,rax
  40ed60:	0f 84 be 00 00 00    	je     40ee24 <cos_shared_kernel_page_alloc+0x114>
  40ed66:	49 8b 34 24          	mov    rsi,QWORD PTR [r12]
  40ed6a:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  40ed6e:	ba 0c 00 00 00       	mov    edx,0xc
  40ed73:	4c 89 d7             	mov    rdi,r10

	ret = call_cap_op(meta->mi.pgtbl_cap, CAPTBL_OP_MEMACTIVATE, kmem, ci->pgtbl_cap, heap_vaddr, PAGE_ORDER);
  40ed76:	49 8b 86 98 00 00 00 	mov    rax,QWORD PTR [r14+0x98]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40ed7d:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40ed80:	05 17 00 01 00       	add    eax,0x10017
	__asm__ __volatile__(
  40ed85:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40ed88:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40ed8c:	48 89 cd             	mov    rbp,rcx
  40ed8f:	49 b8 a8 ed 40 00 00 	movabs r8,0x40eda8
  40ed96:	00 00 00 
  40ed99:	0f 05                	syscall 
  40ed9b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40eda0:	eb 0d                	jmp    40edaf <cos_shared_kernel_page_alloc+0x9f>
  40eda2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40eda8:	b9 00 00 00 00       	mov    ecx,0x0
  40edad:	eb 05                	jmp    40edb4 <cos_shared_kernel_page_alloc+0xa4>
  40edaf:	b9 01 00 00 00       	mov    ecx,0x1
  40edb4:	5d                   	pop    rbp
  40edb5:	5c                   	pop    rsp
	if (ret) {
  40edb6:	85 c0                	test   eax,eax
  40edb8:	75 16                	jne    40edd0 <cos_shared_kernel_page_alloc+0xc0>
		BUG();
	}

	*resource = kmem;
  40edba:	49 89 5d 00          	mov    QWORD PTR [r13+0x0],rbx

	return heap_vaddr;
}
  40edbe:	48 83 c4 10          	add    rsp,0x10
  40edc2:	4c 89 d0             	mov    rax,r10
  40edc5:	5b                   	pop    rbx
  40edc6:	41 5c                	pop    r12
  40edc8:	41 5d                	pop    r13
  40edca:	41 5e                	pop    r14
  40edcc:	5d                   	pop    rbp
  40edcd:	c3                   	ret    
  40edce:	66 90                	xchg   ax,ax
  40edd0:	be 1c 00 00 00       	mov    esi,0x1c
  40edd5:	bf 08 cf 41 00       	mov    edi,0x41cf08
  40edda:	e8 f1 b2 ff ff       	call   40a0d0 <cos_print_str>
		BUG();
  40eddf:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ede6:	00 00 00 00 
  40edea:	0f 0b                	ud2    
  40edec:	be 2f 00 00 00       	mov    esi,0x2f
  40edf1:	bf 78 ce 41 00       	mov    edi,0x41ce78
  40edf6:	e8 d5 b2 ff ff       	call   40a0d0 <cos_print_str>
	assert(meta == __compinfo_metacap(meta));
  40edfb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ee02:	00 00 00 00 
  40ee06:	0f 0b                	ud2    
  40ee08:	be 2f 00 00 00       	mov    esi,0x2f
  40ee0d:	bf a8 ce 41 00       	mov    edi,0x41cea8
  40ee12:	e8 b9 b2 ff ff       	call   40a0d0 <cos_print_str>
	assert(kmem);
  40ee17:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ee1e:	00 00 00 00 
  40ee22:	0f 0b                	ud2    
  40ee24:	be 2f 00 00 00       	mov    esi,0x2f
  40ee29:	bf d8 ce 41 00       	mov    edi,0x41ced8
  40ee2e:	e8 9d b2 ff ff       	call   40a0d0 <cos_print_str>
	assert(heap_vaddr);
  40ee33:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ee3a:	00 00 00 00 
  40ee3e:	0f 0b                	ud2    

000000000040ee40 <cos_vm_kernel_page_create>:

vaddr_t
cos_vm_kernel_page_create(struct cos_compinfo *ci)
{
  40ee40:	f3 0f 1e fa          	endbr64 
  40ee44:	55                   	push   rbp
  40ee45:	48 89 e5             	mov    rbp,rsp
  40ee48:	41 55                	push   r13
  40ee4a:	41 54                	push   r12
  40ee4c:	53                   	push   rbx
  40ee4d:	48 83 ec 18          	sub    rsp,0x18
	assert(__ci);
  40ee51:	48 85 ff             	test   rdi,rdi
  40ee54:	0f 84 6f 01 00 00    	je     40efc9 <cos_vm_kernel_page_create+0x189>
	return ci->memsrc;
  40ee5a:	4c 8b 57 60          	mov    r10,QWORD PTR [rdi+0x60]
        __asm__ __volatile__("lock " PS_CAS_STR
  40ee5e:	be 01 00 00 00       	mov    esi,0x1
  40ee63:	31 c9                	xor    ecx,ecx
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40ee65:	49 8d 92 b8 00 00 00 	lea    rdx,[r10+0xb8]
	assert(ci && ci == __compinfo_metacap(__ci));
  40ee6c:	4d 85 d2             	test   r10,r10
  40ee6f:	0f 84 70 01 00 00    	je     40efe5 <cos_vm_kernel_page_create+0x1a5>
  40ee75:	0f 1f 00             	nop    DWORD PTR [rax]
        __asm__ __volatile__("lock " PS_CAS_STR
  40ee78:	48 89 c8             	mov    rax,rcx
  40ee7b:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40ee80:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40ee83:	84 c0                	test   al,al
  40ee85:	74 f1                	je     40ee78 <cos_vm_kernel_page_create+0x38>
        __asm__ __volatile__("lock " PS_FAA_STR
  40ee87:	41 bd 00 10 00 00    	mov    r13d,0x1000
  40ee8d:	f0 4d 0f c1 6a 78    	lock xadd QWORD PTR [r10+0x78],r13
	if (ret >= *frontier || *frontier - ret > RETYPE_MEM_SIZE) {
  40ee93:	49 8b 92 90 00 00 00 	mov    rdx,QWORD PTR [r10+0x90]
  40ee9a:	49 39 d5             	cmp    r13,rdx
  40ee9d:	0f 82 bd 00 00 00    	jb     40ef60 <cos_vm_kernel_page_create+0x120>
		vaddr_t ptr_tmp = *ptr, front_tmp = *frontier;
  40eea3:	49 8b 42 78          	mov    rax,QWORD PTR [r10+0x78]
		if (ci->mi.untyped_ptr == ci->mi.untyped_frontier) goto error;
  40eea7:	49 8b 9a 80 00 00 00 	mov    rbx,QWORD PTR [r10+0x80]
  40eeae:	49 39 5a 68          	cmp    QWORD PTR [r10+0x68],rbx
  40eeb2:	0f 84 c8 00 00 00    	je     40ef80 <cos_vm_kernel_page_create+0x140>
  40eeb8:	41 bd 00 10 00 00    	mov    r13d,0x1000
  40eebe:	f0 4d 0f c1 6a 68    	lock xadd QWORD PTR [r10+0x68],r13
		if (ps_cas(ptr, ptr_tmp, ret + PAGE_SIZE)) {
  40eec4:	49 8d 8d 00 10 00 00 	lea    rcx,[r13+0x1000]
        __asm__ __volatile__("lock " PS_CAS_STR
  40eecb:	f0 49 0f b1 4a 78    	lock cmpxchg QWORD PTR [r10+0x78],rcx
  40eed1:	0f 94 c0             	sete   al
  40eed4:	84 c0                	test   al,al
  40eed6:	74 0f                	je     40eee7 <cos_vm_kernel_page_create+0xa7>
  40eed8:	48 89 d0             	mov    rax,rdx
  40eedb:	f0 49 0f b1 8a 90 00 	lock cmpxchg QWORD PTR [r10+0x90],rcx
  40eee2:	00 00 
  40eee4:	0f 94 c0             	sete   al
	if (retype && (ret % RETYPE_MEM_SIZE == 0)) {
  40eee7:	4c 89 ea             	mov    rdx,r13
  40eeea:	81 e2 ff 0f 00 00    	and    edx,0xfff
  40eef0:	0f 85 ba 00 00 00    	jne    40efb0 <cos_vm_kernel_page_create+0x170>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40eef6:	41 8b 82 98 00 00 00 	mov    eax,DWORD PTR [r10+0x98]
	__asm__ __volatile__(
  40eefd:	4c 89 eb             	mov    rbx,r13
  40ef00:	48 89 d6             	mov    rsi,rdx
  40ef03:	48 89 d7             	mov    rdi,rdx
  40ef06:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40ef0a:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40ef0d:	05 1a 00 01 00       	add    eax,0x1001a
	__asm__ __volatile__(
  40ef12:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40ef15:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40ef19:	48 89 cd             	mov    rbp,rcx
  40ef1c:	49 b8 30 ef 40 00 00 	movabs r8,0x40ef30
  40ef23:	00 00 00 
  40ef26:	0f 05                	syscall 
  40ef28:	eb 0d                	jmp    40ef37 <cos_vm_kernel_page_create+0xf7>
  40ef2a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40ef30:	b9 00 00 00 00       	mov    ecx,0x0
  40ef35:	eb 05                	jmp    40ef3c <cos_vm_kernel_page_create+0xfc>
  40ef37:	b9 01 00 00 00       	mov    ecx,0x1
  40ef3c:	5d                   	pop    rbp
  40ef3d:	5c                   	pop    rsp
		if (call_cap_op(ci->mi.pgtbl_cap, op, ret, 0, 0, 0)) goto error;
  40ef3e:	85 c0                	test   eax,eax
  40ef40:	75 3e                	jne    40ef80 <cos_vm_kernel_page_create+0x140>
{ l->o = 0; }
  40ef42:	49 c7 82 b8 00 00 00 	mov    QWORD PTR [r10+0xb8],0x0
  40ef49:	00 00 00 00 
	vaddr_t kmem = 0;

	kmem = __kmem_bump_alloc(ci);
	assert(kmem);
  40ef4d:	4d 85 ed             	test   r13,r13
  40ef50:	74 39                	je     40ef8b <cos_vm_kernel_page_create+0x14b>

	return kmem;
}
  40ef52:	48 83 c4 18          	add    rsp,0x18
  40ef56:	4c 89 e8             	mov    rax,r13
  40ef59:	5b                   	pop    rbx
  40ef5a:	41 5c                	pop    r12
  40ef5c:	41 5d                	pop    r13
  40ef5e:	5d                   	pop    rbp
  40ef5f:	c3                   	ret    
	if (ret >= *frontier || *frontier - ret > RETYPE_MEM_SIZE) {
  40ef60:	48 89 d0             	mov    rax,rdx
  40ef63:	4c 29 e8             	sub    rax,r13
  40ef66:	48 3d 00 10 00 00    	cmp    rax,0x1000
  40ef6c:	0f 86 75 ff ff ff    	jbe    40eee7 <cos_vm_kernel_page_create+0xa7>
  40ef72:	e9 2c ff ff ff       	jmp    40eea3 <cos_vm_kernel_page_create+0x63>
  40ef77:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40ef7e:	00 00 
  40ef80:	49 c7 82 b8 00 00 00 	mov    QWORD PTR [r10+0xb8],0x0
  40ef87:	00 00 00 00 
  40ef8b:	be 2f 00 00 00       	mov    esi,0x2f
  40ef90:	bf 28 cf 41 00       	mov    edi,0x41cf28
  40ef95:	e8 36 b1 ff ff       	call   40a0d0 <cos_print_str>
	assert(kmem);
  40ef9a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40efa1:	00 00 00 00 
  40efa5:	0f 0b                	ud2    
  40efa7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40efae:	00 00 
  40efb0:	49 c7 82 b8 00 00 00 	mov    QWORD PTR [r10+0xb8],0x0
  40efb7:	00 00 00 00 
}
  40efbb:	48 83 c4 18          	add    rsp,0x18
  40efbf:	4c 89 e8             	mov    rax,r13
  40efc2:	5b                   	pop    rbx
  40efc3:	41 5c                	pop    r12
  40efc5:	41 5d                	pop    r13
  40efc7:	5d                   	pop    rbp
  40efc8:	c3                   	ret    
  40efc9:	be 2e 00 00 00       	mov    esi,0x2e
  40efce:	bf b0 c5 41 00       	mov    edi,0x41c5b0
  40efd3:	e8 f8 b0 ff ff       	call   40a0d0 <cos_print_str>
	assert(__ci);
  40efd8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40efdf:	00 00 00 00 
  40efe3:	0f 0b                	ud2    
  40efe5:	be 2e 00 00 00       	mov    esi,0x2e
  40efea:	bf e0 c5 41 00       	mov    edi,0x41c5e0
  40efef:	e8 dc b0 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci && ci == __compinfo_metacap(__ci));
  40eff4:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40effb:	00 00 00 00 
  40efff:	0f 0b                	ud2    
  40f001:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40f008:	00 00 00 00 
  40f00c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000040f010 <cos_vm_vmcs_alloc>:

capid_t
cos_vm_vmcs_alloc(struct cos_compinfo *ci, vaddr_t kmem)
{
  40f010:	f3 0f 1e fa          	endbr64 
  40f014:	55                   	push   rbp
        __asm__ __volatile__("lock " PS_CAS_STR
  40f015:	31 c9                	xor    ecx,ecx
  40f017:	48 89 e5             	mov    rbp,rsp
  40f01a:	41 55                	push   r13
  40f01c:	49 89 fd             	mov    r13,rdi
  40f01f:	41 54                	push   r12
  40f021:	53                   	push   rbx
  40f022:	48 89 f3             	mov    rbx,rsi
  40f025:	be 01 00 00 00       	mov    esi,0x1
  40f02a:	48 83 ec 18          	sub    rsp,0x18
	return ci->memsrc;
  40f02e:	4c 8b 67 60          	mov    r12,QWORD PTR [rdi+0x60]
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f032:	49 8d 94 24 b0 00 00 	lea    rdx,[r12+0xb0]
  40f039:	00 
  40f03a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  40f040:	48 89 c8             	mov    rax,rcx
  40f043:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40f048:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f04b:	84 c0                	test   al,al
  40f04d:	74 f1                	je     40f040 <cos_vm_vmcs_alloc+0x30>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40f04f:	41 f6 44 24 38 03    	test   BYTE PTR [r12+0x38],0x3
  40f055:	0f 84 a1 00 00 00    	je     40f0fc <cos_vm_vmcs_alloc+0xec>
        __asm__ __volatile__("lock " PS_FAA_STR
  40f05b:	bf 04 00 00 00       	mov    edi,0x4
  40f060:	f0 49 0f c1 7c 24 38 	lock xadd QWORD PTR [r12+0x38],rdi
{ l->o = 0; }
  40f067:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40f06e:	00 00 00 00 00 
	capid_t cap = 0;

	cap = __capid_bump_alloc(__compinfo_metacap(ci), CAP_VM_VMCS);

	if (cap == 0 || kmem == 0) {
  40f073:	48 85 ff             	test   rdi,rdi
  40f076:	0f 84 98 00 00 00    	je     40f114 <cos_vm_vmcs_alloc+0x104>
  40f07c:	48 85 db             	test   rbx,rbx
  40f07f:	0f 84 8f 00 00 00    	je     40f114 <cos_vm_vmcs_alloc+0x104>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f085:	41 8b 45 08          	mov    eax,DWORD PTR [r13+0x8]
		assert(0);
	}

	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_VMCS_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  40f089:	49 8b 55 60          	mov    rdx,QWORD PTR [r13+0x60]
	__asm__ __volatile__(
  40f08d:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f091:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40f094:	48 8b b2 98 00 00 00 	mov    rsi,QWORD PTR [rdx+0x98]
  40f09b:	31 d2                	xor    edx,edx
	cap_no += op;
  40f09d:	05 07 00 01 00       	add    eax,0x10007
	__asm__ __volatile__(
  40f0a2:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40f0a5:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40f0a9:	48 89 cd             	mov    rbp,rcx
  40f0ac:	49 b8 c0 f0 40 00 00 	movabs r8,0x40f0c0
  40f0b3:	00 00 00 
  40f0b6:	0f 05                	syscall 
  40f0b8:	eb 0d                	jmp    40f0c7 <cos_vm_vmcs_alloc+0xb7>
  40f0ba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40f0c0:	b9 00 00 00 00       	mov    ecx,0x0
  40f0c5:	eb 05                	jmp    40f0cc <cos_vm_vmcs_alloc+0xbc>
  40f0c7:	b9 01 00 00 00       	mov    ecx,0x1
  40f0cc:	5d                   	pop    rbp
  40f0cd:	5c                   	pop    rsp
  40f0ce:	85 c0                	test   eax,eax
  40f0d0:	75 0e                	jne    40f0e0 <cos_vm_vmcs_alloc+0xd0>

	return cap;
}
  40f0d2:	48 83 c4 18          	add    rsp,0x18
  40f0d6:	48 89 f8             	mov    rax,rdi
  40f0d9:	5b                   	pop    rbx
  40f0da:	41 5c                	pop    r12
  40f0dc:	41 5d                	pop    r13
  40f0de:	5d                   	pop    rbp
  40f0df:	c3                   	ret    
  40f0e0:	be 1c 00 00 00       	mov    esi,0x1c
  40f0e5:	bf 88 cf 41 00       	mov    edi,0x41cf88
  40f0ea:	e8 e1 af ff ff       	call   40a0d0 <cos_print_str>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_VMCS_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  40f0ef:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f0f6:	00 00 00 00 
  40f0fa:	0f 0b                	ud2    
		if (__capid_captbl_check_expand(ci)) goto error;
  40f0fc:	4c 89 e7             	mov    rdi,r12
  40f0ff:	e8 dc d8 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40f104:	85 c0                	test   eax,eax
  40f106:	74 28                	je     40f130 <cos_vm_vmcs_alloc+0x120>
  40f108:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40f10f:	00 00 00 00 00 
  40f114:	be 2f 00 00 00       	mov    esi,0x2f
  40f119:	bf 58 cf 41 00       	mov    edi,0x41cf58
  40f11e:	e8 ad af ff ff       	call   40a0d0 <cos_print_str>
		assert(0);
  40f123:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f12a:	00 00 00 00 
  40f12e:	0f 0b                	ud2    
        __asm__ __volatile__("lock " PS_FAA_STR
  40f130:	b8 04 00 00 00       	mov    eax,0x4
  40f135:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40f13c:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  40f141:	e9 15 ff ff ff       	jmp    40f05b <cos_vm_vmcs_alloc+0x4b>
  40f146:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40f14d:	00 00 00 

000000000040f150 <cos_vm_msr_bitmap_alloc>:

capid_t
cos_vm_msr_bitmap_alloc(struct cos_compinfo *ci, vaddr_t kmem)
{
  40f150:	f3 0f 1e fa          	endbr64 
  40f154:	55                   	push   rbp
        __asm__ __volatile__("lock " PS_CAS_STR
  40f155:	31 c9                	xor    ecx,ecx
  40f157:	48 89 e5             	mov    rbp,rsp
  40f15a:	41 55                	push   r13
  40f15c:	49 89 fd             	mov    r13,rdi
  40f15f:	41 54                	push   r12
  40f161:	53                   	push   rbx
  40f162:	48 89 f3             	mov    rbx,rsi
  40f165:	be 01 00 00 00       	mov    esi,0x1
  40f16a:	48 83 ec 18          	sub    rsp,0x18
	return ci->memsrc;
  40f16e:	4c 8b 67 60          	mov    r12,QWORD PTR [rdi+0x60]
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f172:	49 8d 94 24 b0 00 00 	lea    rdx,[r12+0xb0]
  40f179:	00 
  40f17a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  40f180:	48 89 c8             	mov    rax,rcx
  40f183:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40f188:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f18b:	84 c0                	test   al,al
  40f18d:	74 f1                	je     40f180 <cos_vm_msr_bitmap_alloc+0x30>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40f18f:	41 f6 44 24 38 03    	test   BYTE PTR [r12+0x38],0x3
  40f195:	0f 84 a1 00 00 00    	je     40f23c <cos_vm_msr_bitmap_alloc+0xec>
        __asm__ __volatile__("lock " PS_FAA_STR
  40f19b:	bf 04 00 00 00       	mov    edi,0x4
  40f1a0:	f0 49 0f c1 7c 24 38 	lock xadd QWORD PTR [r12+0x38],rdi
{ l->o = 0; }
  40f1a7:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40f1ae:	00 00 00 00 00 
	capid_t cap = 0;

	cap = __capid_bump_alloc(__compinfo_metacap(ci), CAP_VM_MSR_BITMAP);

	if (cap == 0 || kmem == 0) {
  40f1b3:	48 85 ff             	test   rdi,rdi
  40f1b6:	0f 84 98 00 00 00    	je     40f254 <cos_vm_msr_bitmap_alloc+0x104>
  40f1bc:	48 85 db             	test   rbx,rbx
  40f1bf:	0f 84 8f 00 00 00    	je     40f254 <cos_vm_msr_bitmap_alloc+0x104>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f1c5:	41 8b 45 08          	mov    eax,DWORD PTR [r13+0x8]
		assert(0);
	}

	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_MSR_BITMAP_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  40f1c9:	49 8b 55 60          	mov    rdx,QWORD PTR [r13+0x60]
	__asm__ __volatile__(
  40f1cd:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f1d1:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40f1d4:	48 8b b2 98 00 00 00 	mov    rsi,QWORD PTR [rdx+0x98]
  40f1db:	31 d2                	xor    edx,edx
	cap_no += op;
  40f1dd:	05 08 00 01 00       	add    eax,0x10008
	__asm__ __volatile__(
  40f1e2:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40f1e5:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40f1e9:	48 89 cd             	mov    rbp,rcx
  40f1ec:	49 b8 00 f2 40 00 00 	movabs r8,0x40f200
  40f1f3:	00 00 00 
  40f1f6:	0f 05                	syscall 
  40f1f8:	eb 0d                	jmp    40f207 <cos_vm_msr_bitmap_alloc+0xb7>
  40f1fa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40f200:	b9 00 00 00 00       	mov    ecx,0x0
  40f205:	eb 05                	jmp    40f20c <cos_vm_msr_bitmap_alloc+0xbc>
  40f207:	b9 01 00 00 00       	mov    ecx,0x1
  40f20c:	5d                   	pop    rbp
  40f20d:	5c                   	pop    rsp
  40f20e:	85 c0                	test   eax,eax
  40f210:	75 0e                	jne    40f220 <cos_vm_msr_bitmap_alloc+0xd0>

	return cap;
}
  40f212:	48 83 c4 18          	add    rsp,0x18
  40f216:	48 89 f8             	mov    rax,rdi
  40f219:	5b                   	pop    rbx
  40f21a:	41 5c                	pop    r12
  40f21c:	41 5d                	pop    r13
  40f21e:	5d                   	pop    rbp
  40f21f:	c3                   	ret    
  40f220:	be 1c 00 00 00       	mov    esi,0x1c
  40f225:	bf d8 cf 41 00       	mov    edi,0x41cfd8
  40f22a:	e8 a1 ae ff ff       	call   40a0d0 <cos_print_str>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_MSR_BITMAP_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  40f22f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f236:	00 00 00 00 
  40f23a:	0f 0b                	ud2    
		if (__capid_captbl_check_expand(ci)) goto error;
  40f23c:	4c 89 e7             	mov    rdi,r12
  40f23f:	e8 9c d7 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40f244:	85 c0                	test   eax,eax
  40f246:	74 28                	je     40f270 <cos_vm_msr_bitmap_alloc+0x120>
  40f248:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40f24f:	00 00 00 00 00 
  40f254:	be 2f 00 00 00       	mov    esi,0x2f
  40f259:	bf a8 cf 41 00       	mov    edi,0x41cfa8
  40f25e:	e8 6d ae ff ff       	call   40a0d0 <cos_print_str>
		assert(0);
  40f263:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f26a:	00 00 00 00 
  40f26e:	0f 0b                	ud2    
        __asm__ __volatile__("lock " PS_FAA_STR
  40f270:	b8 04 00 00 00       	mov    eax,0x4
  40f275:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40f27c:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  40f281:	e9 15 ff ff ff       	jmp    40f19b <cos_vm_msr_bitmap_alloc+0x4b>
  40f286:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40f28d:	00 00 00 

000000000040f290 <cos_vm_lapic_alloc>:

capid_t
cos_vm_lapic_alloc(struct cos_compinfo *ci, vaddr_t kmem)
{
  40f290:	f3 0f 1e fa          	endbr64 
  40f294:	55                   	push   rbp
        __asm__ __volatile__("lock " PS_CAS_STR
  40f295:	31 c9                	xor    ecx,ecx
  40f297:	48 89 e5             	mov    rbp,rsp
  40f29a:	41 55                	push   r13
  40f29c:	49 89 fd             	mov    r13,rdi
  40f29f:	41 54                	push   r12
  40f2a1:	53                   	push   rbx
  40f2a2:	48 89 f3             	mov    rbx,rsi
  40f2a5:	be 01 00 00 00       	mov    esi,0x1
  40f2aa:	48 83 ec 18          	sub    rsp,0x18
	return ci->memsrc;
  40f2ae:	4c 8b 67 60          	mov    r12,QWORD PTR [rdi+0x60]
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f2b2:	49 8d 94 24 b0 00 00 	lea    rdx,[r12+0xb0]
  40f2b9:	00 
  40f2ba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  40f2c0:	48 89 c8             	mov    rax,rcx
  40f2c3:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40f2c8:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f2cb:	84 c0                	test   al,al
  40f2cd:	74 f1                	je     40f2c0 <cos_vm_lapic_alloc+0x30>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40f2cf:	41 f6 44 24 38 03    	test   BYTE PTR [r12+0x38],0x3
  40f2d5:	0f 84 a1 00 00 00    	je     40f37c <cos_vm_lapic_alloc+0xec>
        __asm__ __volatile__("lock " PS_FAA_STR
  40f2db:	bf 04 00 00 00       	mov    edi,0x4
  40f2e0:	f0 49 0f c1 7c 24 38 	lock xadd QWORD PTR [r12+0x38],rdi
{ l->o = 0; }
  40f2e7:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40f2ee:	00 00 00 00 00 
	capid_t cap = 0;

	cap = __capid_bump_alloc(__compinfo_metacap(ci), CAP_VM_LAPIC);
	if (cap == 0 || kmem == 0) {
  40f2f3:	48 85 ff             	test   rdi,rdi
  40f2f6:	0f 84 98 00 00 00    	je     40f394 <cos_vm_lapic_alloc+0x104>
  40f2fc:	48 85 db             	test   rbx,rbx
  40f2ff:	0f 84 8f 00 00 00    	je     40f394 <cos_vm_lapic_alloc+0x104>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f305:	41 8b 45 08          	mov    eax,DWORD PTR [r13+0x8]
		assert(0);
	}

	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_LAPIC_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  40f309:	49 8b 55 60          	mov    rdx,QWORD PTR [r13+0x60]
	__asm__ __volatile__(
  40f30d:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f311:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40f314:	48 8b b2 98 00 00 00 	mov    rsi,QWORD PTR [rdx+0x98]
  40f31b:	31 d2                	xor    edx,edx
	cap_no += op;
  40f31d:	05 0a 00 01 00       	add    eax,0x1000a
	__asm__ __volatile__(
  40f322:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40f325:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40f329:	48 89 cd             	mov    rbp,rcx
  40f32c:	49 b8 40 f3 40 00 00 	movabs r8,0x40f340
  40f333:	00 00 00 
  40f336:	0f 05                	syscall 
  40f338:	eb 0d                	jmp    40f347 <cos_vm_lapic_alloc+0xb7>
  40f33a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40f340:	b9 00 00 00 00       	mov    ecx,0x0
  40f345:	eb 05                	jmp    40f34c <cos_vm_lapic_alloc+0xbc>
  40f347:	b9 01 00 00 00       	mov    ecx,0x1
  40f34c:	5d                   	pop    rbp
  40f34d:	5c                   	pop    rsp
  40f34e:	85 c0                	test   eax,eax
  40f350:	75 0e                	jne    40f360 <cos_vm_lapic_alloc+0xd0>

	return cap;

}
  40f352:	48 83 c4 18          	add    rsp,0x18
  40f356:	48 89 f8             	mov    rax,rdi
  40f359:	5b                   	pop    rbx
  40f35a:	41 5c                	pop    r12
  40f35c:	41 5d                	pop    r13
  40f35e:	5d                   	pop    rbp
  40f35f:	c3                   	ret    
  40f360:	be 1c 00 00 00       	mov    esi,0x1c
  40f365:	bf 28 d0 41 00       	mov    edi,0x41d028
  40f36a:	e8 61 ad ff ff       	call   40a0d0 <cos_print_str>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_LAPIC_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  40f36f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f376:	00 00 00 00 
  40f37a:	0f 0b                	ud2    
		if (__capid_captbl_check_expand(ci)) goto error;
  40f37c:	4c 89 e7             	mov    rdi,r12
  40f37f:	e8 5c d6 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40f384:	85 c0                	test   eax,eax
  40f386:	74 28                	je     40f3b0 <cos_vm_lapic_alloc+0x120>
  40f388:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40f38f:	00 00 00 00 00 
  40f394:	be 2f 00 00 00       	mov    esi,0x2f
  40f399:	bf f8 cf 41 00       	mov    edi,0x41cff8
  40f39e:	e8 2d ad ff ff       	call   40a0d0 <cos_print_str>
		assert(0);
  40f3a3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f3aa:	00 00 00 00 
  40f3ae:	0f 0b                	ud2    
        __asm__ __volatile__("lock " PS_FAA_STR
  40f3b0:	b8 04 00 00 00       	mov    eax,0x4
  40f3b5:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40f3bc:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  40f3c1:	e9 15 ff ff ff       	jmp    40f2db <cos_vm_lapic_alloc+0x4b>
  40f3c6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40f3cd:	00 00 00 

000000000040f3d0 <cos_vm_shared_region_alloc>:

capid_t
cos_vm_shared_region_alloc(struct cos_compinfo *ci, vaddr_t kmem)
{
  40f3d0:	f3 0f 1e fa          	endbr64 
  40f3d4:	55                   	push   rbp
        __asm__ __volatile__("lock " PS_CAS_STR
  40f3d5:	31 c9                	xor    ecx,ecx
  40f3d7:	48 89 e5             	mov    rbp,rsp
  40f3da:	41 55                	push   r13
  40f3dc:	49 89 fd             	mov    r13,rdi
  40f3df:	41 54                	push   r12
  40f3e1:	53                   	push   rbx
  40f3e2:	48 89 f3             	mov    rbx,rsi
  40f3e5:	be 01 00 00 00       	mov    esi,0x1
  40f3ea:	48 83 ec 18          	sub    rsp,0x18
	return ci->memsrc;
  40f3ee:	4c 8b 67 60          	mov    r12,QWORD PTR [rdi+0x60]
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f3f2:	49 8d 94 24 b0 00 00 	lea    rdx,[r12+0xb0]
  40f3f9:	00 
  40f3fa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  40f400:	48 89 c8             	mov    rax,rcx
  40f403:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40f408:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f40b:	84 c0                	test   al,al
  40f40d:	74 f1                	je     40f400 <cos_vm_shared_region_alloc+0x30>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40f40f:	41 f6 44 24 38 03    	test   BYTE PTR [r12+0x38],0x3
  40f415:	0f 84 a1 00 00 00    	je     40f4bc <cos_vm_shared_region_alloc+0xec>
        __asm__ __volatile__("lock " PS_FAA_STR
  40f41b:	bf 04 00 00 00       	mov    edi,0x4
  40f420:	f0 49 0f c1 7c 24 38 	lock xadd QWORD PTR [r12+0x38],rdi
{ l->o = 0; }
  40f427:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40f42e:	00 00 00 00 00 
	capid_t cap = 0;

	cap = __capid_bump_alloc(__compinfo_metacap(ci), CAP_VM_SHARED_MEM);
	if (cap == 0 || kmem == 0) {
  40f433:	48 85 ff             	test   rdi,rdi
  40f436:	0f 84 98 00 00 00    	je     40f4d4 <cos_vm_shared_region_alloc+0x104>
  40f43c:	48 85 db             	test   rbx,rbx
  40f43f:	0f 84 8f 00 00 00    	je     40f4d4 <cos_vm_shared_region_alloc+0x104>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f445:	41 8b 45 08          	mov    eax,DWORD PTR [r13+0x8]
		assert(0);
	}

	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_SHARED_MEM_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  40f449:	49 8b 55 60          	mov    rdx,QWORD PTR [r13+0x60]
	__asm__ __volatile__(
  40f44d:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f451:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40f454:	48 8b b2 98 00 00 00 	mov    rsi,QWORD PTR [rdx+0x98]
  40f45b:	31 d2                	xor    edx,edx
	cap_no += op;
  40f45d:	05 0b 00 01 00       	add    eax,0x1000b
	__asm__ __volatile__(
  40f462:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40f465:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40f469:	48 89 cd             	mov    rbp,rcx
  40f46c:	49 b8 80 f4 40 00 00 	movabs r8,0x40f480
  40f473:	00 00 00 
  40f476:	0f 05                	syscall 
  40f478:	eb 0d                	jmp    40f487 <cos_vm_shared_region_alloc+0xb7>
  40f47a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40f480:	b9 00 00 00 00       	mov    ecx,0x0
  40f485:	eb 05                	jmp    40f48c <cos_vm_shared_region_alloc+0xbc>
  40f487:	b9 01 00 00 00       	mov    ecx,0x1
  40f48c:	5d                   	pop    rbp
  40f48d:	5c                   	pop    rsp
  40f48e:	85 c0                	test   eax,eax
  40f490:	75 0e                	jne    40f4a0 <cos_vm_shared_region_alloc+0xd0>

	return cap;

}
  40f492:	48 83 c4 18          	add    rsp,0x18
  40f496:	48 89 f8             	mov    rax,rdi
  40f499:	5b                   	pop    rbx
  40f49a:	41 5c                	pop    r12
  40f49c:	41 5d                	pop    r13
  40f49e:	5d                   	pop    rbp
  40f49f:	c3                   	ret    
  40f4a0:	be 1c 00 00 00       	mov    esi,0x1c
  40f4a5:	bf 78 d0 41 00       	mov    edi,0x41d078
  40f4aa:	e8 21 ac ff ff       	call   40a0d0 <cos_print_str>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_SHARED_MEM_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  40f4af:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f4b6:	00 00 00 00 
  40f4ba:	0f 0b                	ud2    
		if (__capid_captbl_check_expand(ci)) goto error;
  40f4bc:	4c 89 e7             	mov    rdi,r12
  40f4bf:	e8 1c d5 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40f4c4:	85 c0                	test   eax,eax
  40f4c6:	74 28                	je     40f4f0 <cos_vm_shared_region_alloc+0x120>
  40f4c8:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40f4cf:	00 00 00 00 00 
  40f4d4:	be 2f 00 00 00       	mov    esi,0x2f
  40f4d9:	bf 48 d0 41 00       	mov    edi,0x41d048
  40f4de:	e8 ed ab ff ff       	call   40a0d0 <cos_print_str>
		assert(0);
  40f4e3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f4ea:	00 00 00 00 
  40f4ee:	0f 0b                	ud2    
        __asm__ __volatile__("lock " PS_FAA_STR
  40f4f0:	b8 04 00 00 00       	mov    eax,0x4
  40f4f5:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40f4fc:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  40f501:	e9 15 ff ff ff       	jmp    40f41b <cos_vm_shared_region_alloc+0x4b>
  40f506:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40f50d:	00 00 00 

000000000040f510 <cos_vm_lapic_access_alloc>:

capid_t
cos_vm_lapic_access_alloc(struct cos_compinfo *ci, vaddr_t kmem)
{
  40f510:	f3 0f 1e fa          	endbr64 
  40f514:	55                   	push   rbp
        __asm__ __volatile__("lock " PS_CAS_STR
  40f515:	31 c9                	xor    ecx,ecx
  40f517:	48 89 e5             	mov    rbp,rsp
  40f51a:	41 55                	push   r13
  40f51c:	49 89 fd             	mov    r13,rdi
  40f51f:	41 54                	push   r12
  40f521:	53                   	push   rbx
  40f522:	48 89 f3             	mov    rbx,rsi
  40f525:	be 01 00 00 00       	mov    esi,0x1
  40f52a:	48 83 ec 18          	sub    rsp,0x18
	return ci->memsrc;
  40f52e:	4c 8b 67 60          	mov    r12,QWORD PTR [rdi+0x60]
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f532:	49 8d 94 24 b0 00 00 	lea    rdx,[r12+0xb0]
  40f539:	00 
  40f53a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  40f540:	48 89 c8             	mov    rax,rcx
  40f543:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40f548:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f54b:	84 c0                	test   al,al
  40f54d:	74 f1                	je     40f540 <cos_vm_lapic_access_alloc+0x30>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40f54f:	41 f6 44 24 38 03    	test   BYTE PTR [r12+0x38],0x3
  40f555:	0f 84 a1 00 00 00    	je     40f5fc <cos_vm_lapic_access_alloc+0xec>
        __asm__ __volatile__("lock " PS_FAA_STR
  40f55b:	bf 04 00 00 00       	mov    edi,0x4
  40f560:	f0 49 0f c1 7c 24 38 	lock xadd QWORD PTR [r12+0x38],rdi
{ l->o = 0; }
  40f567:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40f56e:	00 00 00 00 00 
	capid_t cap = 0;

	cap = __capid_bump_alloc(__compinfo_metacap(ci), CAP_VM_LAPIC_ACCESS);
	if (cap == 0 || kmem == 0) {
  40f573:	48 85 ff             	test   rdi,rdi
  40f576:	0f 84 98 00 00 00    	je     40f614 <cos_vm_lapic_access_alloc+0x104>
  40f57c:	48 85 db             	test   rbx,rbx
  40f57f:	0f 84 8f 00 00 00    	je     40f614 <cos_vm_lapic_access_alloc+0x104>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f585:	41 8b 45 08          	mov    eax,DWORD PTR [r13+0x8]
		assert(0);
	}

	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_LAPIC_ACCESS_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  40f589:	49 8b 55 60          	mov    rdx,QWORD PTR [r13+0x60]
	__asm__ __volatile__(
  40f58d:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f591:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40f594:	48 8b b2 98 00 00 00 	mov    rsi,QWORD PTR [rdx+0x98]
  40f59b:	31 d2                	xor    edx,edx
	cap_no += op;
  40f59d:	05 09 00 01 00       	add    eax,0x10009
	__asm__ __volatile__(
  40f5a2:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40f5a5:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40f5a9:	48 89 cd             	mov    rbp,rcx
  40f5ac:	49 b8 c0 f5 40 00 00 	movabs r8,0x40f5c0
  40f5b3:	00 00 00 
  40f5b6:	0f 05                	syscall 
  40f5b8:	eb 0d                	jmp    40f5c7 <cos_vm_lapic_access_alloc+0xb7>
  40f5ba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40f5c0:	b9 00 00 00 00       	mov    ecx,0x0
  40f5c5:	eb 05                	jmp    40f5cc <cos_vm_lapic_access_alloc+0xbc>
  40f5c7:	b9 01 00 00 00       	mov    ecx,0x1
  40f5cc:	5d                   	pop    rbp
  40f5cd:	5c                   	pop    rsp
  40f5ce:	85 c0                	test   eax,eax
  40f5d0:	75 0e                	jne    40f5e0 <cos_vm_lapic_access_alloc+0xd0>

	return cap;

}
  40f5d2:	48 83 c4 18          	add    rsp,0x18
  40f5d6:	48 89 f8             	mov    rax,rdi
  40f5d9:	5b                   	pop    rbx
  40f5da:	41 5c                	pop    r12
  40f5dc:	41 5d                	pop    r13
  40f5de:	5d                   	pop    rbp
  40f5df:	c3                   	ret    
  40f5e0:	be 1c 00 00 00       	mov    esi,0x1c
  40f5e5:	bf c8 d0 41 00       	mov    edi,0x41d0c8
  40f5ea:	e8 e1 aa ff ff       	call   40a0d0 <cos_print_str>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_LAPIC_ACCESS_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  40f5ef:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f5f6:	00 00 00 00 
  40f5fa:	0f 0b                	ud2    
		if (__capid_captbl_check_expand(ci)) goto error;
  40f5fc:	4c 89 e7             	mov    rdi,r12
  40f5ff:	e8 dc d3 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40f604:	85 c0                	test   eax,eax
  40f606:	74 28                	je     40f630 <cos_vm_lapic_access_alloc+0x120>
  40f608:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40f60f:	00 00 00 00 00 
  40f614:	be 2f 00 00 00       	mov    esi,0x2f
  40f619:	bf 98 d0 41 00       	mov    edi,0x41d098
  40f61e:	e8 ad aa ff ff       	call   40a0d0 <cos_print_str>
		assert(0);
  40f623:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f62a:	00 00 00 00 
  40f62e:	0f 0b                	ud2    
        __asm__ __volatile__("lock " PS_FAA_STR
  40f630:	b8 04 00 00 00       	mov    eax,0x4
  40f635:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40f63c:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  40f641:	e9 15 ff ff ff       	jmp    40f55b <cos_vm_lapic_access_alloc+0x4b>
  40f646:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40f64d:	00 00 00 

000000000040f650 <cos_vm_vmcb_alloc>:

capid_t
cos_vm_vmcb_alloc(struct cos_compinfo *ci, vm_vmcscap_t vmcs_cap, vm_msrbitmapcap_t msr_bitmap_cap, vm_lapicaccesscap_t lapic_access_cap, vm_lapiccap_t lapic_cap, vm_shared_mem_t shared_mem_cap, thdcap_t handler_cap, word_t vpid)
{
  40f650:	f3 0f 1e fa          	endbr64 
  40f654:	55                   	push   rbp
  40f655:	48 89 e5             	mov    rbp,rsp
  40f658:	41 57                	push   r15
  40f65a:	4d 89 c7             	mov    r15,r8
  40f65d:	41 56                	push   r14
  40f65f:	49 89 ce             	mov    r14,rcx
        __asm__ __volatile__("lock " PS_CAS_STR
  40f662:	31 c9                	xor    ecx,ecx
  40f664:	41 55                	push   r13
  40f666:	49 89 f5             	mov    r13,rsi
  40f669:	41 54                	push   r12
  40f66b:	49 89 fc             	mov    r12,rdi
  40f66e:	53                   	push   rbx
  40f66f:	48 89 d3             	mov    rbx,rdx
  40f672:	48 83 ec 28          	sub    rsp,0x28
	return ci->memsrc;
  40f676:	48 8b 77 60          	mov    rsi,QWORD PTR [rdi+0x60]
  40f67a:	bf 01 00 00 00       	mov    edi,0x1
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f67f:	48 8d 96 b0 00 00 00 	lea    rdx,[rsi+0xb0]
  40f686:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40f68d:	00 00 00 
        __asm__ __volatile__("lock " PS_CAS_STR
  40f690:	48 89 c8             	mov    rax,rcx
  40f693:	f0 48 0f b1 3a       	lock cmpxchg QWORD PTR [rdx],rdi
  40f698:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f69b:	84 c0                	test   al,al
  40f69d:	74 f1                	je     40f690 <cos_vm_vmcb_alloc+0x40>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40f69f:	f6 46 38 03          	test   BYTE PTR [rsi+0x38],0x3
  40f6a3:	0f 84 ab 00 00 00    	je     40f754 <cos_vm_vmcb_alloc+0x104>
        __asm__ __volatile__("lock " PS_FAA_STR
  40f6a9:	41 ba 04 00 00 00    	mov    r10d,0x4
  40f6af:	f0 4c 0f c1 56 38    	lock xadd QWORD PTR [rsi+0x38],r10
{ l->o = 0; }
  40f6b5:	48 c7 86 b0 00 00 00 	mov    QWORD PTR [rsi+0xb0],0x0
  40f6bc:	00 00 00 00 
	capid_t cap = 0;
	word_t arg1 = 0;
	word_t arg2 = 0;

	cap = __capid_bump_alloc(__compinfo_metacap(ci), CAP_VM_VMCB);
	if (cap == 0) {
  40f6c0:	4d 85 d2             	test   r10,r10
  40f6c3:	0f 84 e2 00 00 00    	je     40f7ab <cos_vm_vmcb_alloc+0x15b>
		assert(0);
	}

	arg1 = cap | vmcs_cap << (16 * 1) | msr_bitmap_cap << (16 * 2) |  lapic_access_cap << (16 * 3);
	arg2 = lapic_cap | shared_mem_cap << (16 * 1) | handler_cap << (16 * 2) | vpid << (16 * 3);
  40f6c9:	48 8b 75 10          	mov    rsi,QWORD PTR [rbp+0x10]
  40f6cd:	48 8b 55 18          	mov    rdx,QWORD PTR [rbp+0x18]
	arg1 = cap | vmcs_cap << (16 * 1) | msr_bitmap_cap << (16 * 2) |  lapic_access_cap << (16 * 3);
  40f6d1:	48 c1 e3 20          	shl    rbx,0x20
  40f6d5:	49 c1 e6 30          	shl    r14,0x30

	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_VMCB_ACTIVATE, arg1, arg2, 0, 0)) BUG();
  40f6d9:	49 8b 44 24 08       	mov    rax,QWORD PTR [r12+0x8]
	arg1 = cap | vmcs_cap << (16 * 1) | msr_bitmap_cap << (16 * 2) |  lapic_access_cap << (16 * 3);
  40f6de:	4c 09 f3             	or     rbx,r14
  40f6e1:	49 c1 e5 10          	shl    r13,0x10
  40f6e5:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
	arg2 = lapic_cap | shared_mem_cap << (16 * 1) | handler_cap << (16 * 2) | vpid << (16 * 3);
  40f6e9:	48 c1 e6 20          	shl    rsi,0x20
  40f6ed:	48 c1 e2 30          	shl    rdx,0x30
	arg1 = cap | vmcs_cap << (16 * 1) | msr_bitmap_cap << (16 * 2) |  lapic_access_cap << (16 * 3);
  40f6f1:	4c 09 eb             	or     rbx,r13
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f6f4:	c1 e0 10             	shl    eax,0x10
	arg2 = lapic_cap | shared_mem_cap << (16 * 1) | handler_cap << (16 * 2) | vpid << (16 * 3);
  40f6f7:	4c 09 fe             	or     rsi,r15
  40f6fa:	49 c1 e1 10          	shl    r9,0x10
	arg1 = cap | vmcs_cap << (16 * 1) | msr_bitmap_cap << (16 * 2) |  lapic_access_cap << (16 * 3);
  40f6fe:	4c 09 d3             	or     rbx,r10
	arg2 = lapic_cap | shared_mem_cap << (16 * 1) | handler_cap << (16 * 2) | vpid << (16 * 3);
  40f701:	48 09 d6             	or     rsi,rdx
	__asm__ __volatile__(
  40f704:	31 d2                	xor    edx,edx
	cap_no += op;
  40f706:	05 0c 00 01 00       	add    eax,0x1000c
  40f70b:	4c 09 ce             	or     rsi,r9
	__asm__ __volatile__(
  40f70e:	48 89 d7             	mov    rdi,rdx
  40f711:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40f714:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40f718:	48 89 cd             	mov    rbp,rcx
  40f71b:	49 b8 30 f7 40 00 00 	movabs r8,0x40f730
  40f722:	00 00 00 
  40f725:	0f 05                	syscall 
  40f727:	90                   	nop
  40f728:	eb 0d                	jmp    40f737 <cos_vm_vmcb_alloc+0xe7>
  40f72a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40f730:	b9 00 00 00 00       	mov    ecx,0x0
  40f735:	eb 05                	jmp    40f73c <cos_vm_vmcb_alloc+0xec>
  40f737:	b9 01 00 00 00       	mov    ecx,0x1
  40f73c:	5d                   	pop    rbp
  40f73d:	5c                   	pop    rsp
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_VMCB_ACTIVATE, arg1, arg2, 0, 0)) BUG();
  40f73e:	85 c0                	test   eax,eax
  40f740:	75 42                	jne    40f784 <cos_vm_vmcb_alloc+0x134>

	return cap;

}
  40f742:	48 83 c4 28          	add    rsp,0x28
  40f746:	4c 89 d0             	mov    rax,r10
  40f749:	5b                   	pop    rbx
  40f74a:	41 5c                	pop    r12
  40f74c:	41 5d                	pop    r13
  40f74e:	41 5e                	pop    r14
  40f750:	41 5f                	pop    r15
  40f752:	5d                   	pop    rbp
  40f753:	c3                   	ret    
		if (__capid_captbl_check_expand(ci)) goto error;
  40f754:	48 89 f7             	mov    rdi,rsi
  40f757:	4c 89 4d b0          	mov    QWORD PTR [rbp-0x50],r9
  40f75b:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
  40f75f:	e8 7c d2 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40f764:	48 8b 75 b8          	mov    rsi,QWORD PTR [rbp-0x48]
  40f768:	4c 8b 4d b0          	mov    r9,QWORD PTR [rbp-0x50]
  40f76c:	85 c0                	test   eax,eax
  40f76e:	75 30                	jne    40f7a0 <cos_vm_vmcb_alloc+0x150>
        __asm__ __volatile__("lock " PS_FAA_STR
  40f770:	b8 04 00 00 00       	mov    eax,0x4
  40f775:	f0 48 0f c1 46 18    	lock xadd QWORD PTR [rsi+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40f77b:	48 89 46 38          	mov    QWORD PTR [rsi+0x38],rax
  40f77f:	e9 25 ff ff ff       	jmp    40f6a9 <cos_vm_vmcb_alloc+0x59>
  40f784:	be 1c 00 00 00       	mov    esi,0x1c
  40f789:	bf 18 d1 41 00       	mov    edi,0x41d118
  40f78e:	e8 3d a9 ff ff       	call   40a0d0 <cos_print_str>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_VMCB_ACTIVATE, arg1, arg2, 0, 0)) BUG();
  40f793:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f79a:	00 00 00 00 
  40f79e:	0f 0b                	ud2    
{ l->o = 0; }
  40f7a0:	48 c7 86 b0 00 00 00 	mov    QWORD PTR [rsi+0xb0],0x0
  40f7a7:	00 00 00 00 
  40f7ab:	be 2f 00 00 00       	mov    esi,0x2f
  40f7b0:	bf e8 d0 41 00       	mov    edi,0x41d0e8
  40f7b5:	e8 16 a9 ff ff       	call   40a0d0 <cos_print_str>
		assert(0);
  40f7ba:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f7c1:	00 00 00 00 
  40f7c5:	0f 0b                	ud2    
  40f7c7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40f7ce:	00 00 

000000000040f7d0 <cos_initthd_alloc>:

thdcap_t
cos_initthd_alloc(struct cos_compinfo *ci, compcap_t comp)
{
  40f7d0:	f3 0f 1e fa          	endbr64 
  40f7d4:	55                   	push   rbp
  40f7d5:	48 89 e5             	mov    rbp,rsp
  40f7d8:	41 57                	push   r15
  40f7da:	41 56                	push   r14
  40f7dc:	41 55                	push   r13
        __asm__ __volatile__("lock " PS_FAA_STR
  40f7de:	41 bd 01 00 00 00    	mov    r13d,0x1
  40f7e4:	41 54                	push   r12
  40f7e6:	53                   	push   rbx
  40f7e7:	48 83 ec 28          	sub    rsp,0x28
  40f7eb:	f0 4c 0f c1 2d 8c c8 	lock xadd QWORD PTR [rip+0x4c88c],r13        # 45c080 <__thdid_alloc>
  40f7f2:	04 00 
	assert(ci && comp > 0);
  40f7f4:	48 85 ff             	test   rdi,rdi
  40f7f7:	0f 84 b7 01 00 00    	je     40f9b4 <cos_initthd_alloc+0x1e4>
  40f7fd:	49 89 f4             	mov    r12,rsi
  40f800:	48 85 f6             	test   rsi,rsi
  40f803:	0f 84 ab 01 00 00    	je     40f9b4 <cos_initthd_alloc+0x1e4>
	if (!__cos_ulk_info.toplvl) return 0;
  40f809:	4c 8b 1d 30 12 19 00 	mov    r11,QWORD PTR [rip+0x191230]        # 5a0a40 <__cos_ulk_info>
  40f810:	49 89 fe             	mov    r14,rdi
  40f813:	4d 85 db             	test   r11,r11
  40f816:	74 46                	je     40f85e <cos_initthd_alloc+0x8e>
	if (!__cos_ulk_info.curr_pg || tid % ULK_STACKS_PER_PAGE == 0) {
  40f818:	48 8b 05 31 12 19 00 	mov    rax,QWORD PTR [rip+0x191231]        # 5a0a50 <__cos_ulk_info+0x10>
  40f81f:	48 85 c0             	test   rax,rax
  40f822:	74 0a                	je     40f82e <cos_initthd_alloc+0x5e>
  40f824:	41 f6 c5 0f          	test   r13b,0xf
  40f828:	0f 85 52 01 00 00    	jne    40f980 <cos_initthd_alloc+0x1b0>
		__cos_ulk_info.curr_pg = cos_ulk_page_alloc(ci, __cos_ulk_info.toplvl, __cos_ulk_info.pg_frontier);
  40f82e:	48 8b 15 23 12 19 00 	mov    rdx,QWORD PTR [rip+0x191223]        # 5a0a58 <__cos_ulk_info+0x18>
  40f835:	4c 89 de             	mov    rsi,r11
  40f838:	4c 89 f7             	mov    rdi,r14
  40f83b:	e8 f0 ed ff ff       	call   40e630 <cos_ulk_page_alloc>
  40f840:	48 89 05 09 12 19 00 	mov    QWORD PTR [rip+0x191209],rax        # 5a0a50 <__cos_ulk_info+0x10>
  40f847:	49 89 c3             	mov    r11,rax
		assert(__cos_ulk_info.curr_pg);
  40f84a:	48 85 c0             	test   rax,rax
  40f84d:	0f 84 7d 01 00 00    	je     40f9d0 <cos_initthd_alloc+0x200>
		__cos_ulk_info.pg_frontier += PAGE_SIZE;
  40f853:	48 81 05 fa 11 19 00 	add    QWORD PTR [rip+0x1911fa],0x1000        # 5a0a58 <__cos_ulk_info+0x18>
  40f85a:	00 10 00 00 
	return __mem_bump_alloc(ci, 1, 1);
  40f85e:	4c 89 f7             	mov    rdi,r14
  40f861:	4c 89 5d b8          	mov    QWORD PTR [rbp-0x48],r11
  40f865:	e8 f6 cf ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40f86a:	49 89 c2             	mov    r10,rax
	if (!*kmem) return -1;
  40f86d:	48 85 c0             	test   rax,rax
  40f870:	0f 84 76 01 00 00    	je     40f9ec <cos_initthd_alloc+0x21c>
        __asm__ __volatile__("lock " PS_CAS_STR
  40f876:	4c 8b 5d b8          	mov    r11,QWORD PTR [rbp-0x48]
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f87a:	49 8d 8e b0 00 00 00 	lea    rcx,[r14+0xb0]
        __asm__ __volatile__("lock " PS_CAS_STR
  40f881:	41 b9 01 00 00 00    	mov    r9d,0x1
  40f887:	45 31 c0             	xor    r8d,r8d
  40f88a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40f890:	4c 89 c0             	mov    rax,r8
  40f893:	f0 4c 0f b1 09       	lock cmpxchg QWORD PTR [rcx],r9
  40f898:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f89b:	84 c0                	test   al,al
  40f89d:	74 f1                	je     40f890 <cos_initthd_alloc+0xc0>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40f89f:	4d 8b 7e 28          	mov    r15,QWORD PTR [r14+0x28]
  40f8a3:	41 83 e7 03          	and    r15d,0x3
  40f8a7:	0f 84 9b 00 00 00    	je     40f948 <cos_initthd_alloc+0x178>
        __asm__ __volatile__("lock " PS_FAA_STR
  40f8ad:	bb 01 00 00 00       	mov    ebx,0x1
  40f8b2:	f0 49 0f c1 5e 28    	lock xadd QWORD PTR [r14+0x28],rbx
{ l->o = 0; }
  40f8b8:	49 c7 86 b0 00 00 00 	mov    QWORD PTR [r14+0xb0],0x0
  40f8bf:	00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  40f8c3:	49 89 df             	mov    r15,rbx
	if (!*cap) return -1;
  40f8c6:	48 85 db             	test   rbx,rbx
  40f8c9:	0f 84 1d 01 00 00    	je     40f9ec <cos_initthd_alloc+0x21c>
			  __compinfo_metacap(ci)->mi.pgtbl_cap << 16 | comp, kmem, ulkcap << 16 | tid);
  40f8cf:	49 8b 56 60          	mov    rdx,QWORD PTR [r14+0x60]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f8d3:	41 8b 46 08          	mov    eax,DWORD PTR [r14+0x8]
	__asm__ __volatile__(
  40f8d7:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  40f8db:	4c 89 d7             	mov    rdi,r10
  40f8de:	48 8b b2 98 00 00 00 	mov    rsi,QWORD PTR [rdx+0x98]
  40f8e5:	4c 89 da             	mov    rdx,r11
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f8e8:	c1 e0 10             	shl    eax,0x10
  40f8eb:	48 c1 e2 10          	shl    rdx,0x10
	cap_no += op;
  40f8ef:	05 04 00 01 00       	add    eax,0x10004
  40f8f4:	48 c1 e6 10          	shl    rsi,0x10
	ret = call_cap_op(ci->captbl_cap, CAPTBL_OP_THDACTIVATE, (init_data << 16) | cap,
  40f8f8:	4c 09 ea             	or     rdx,r13
  40f8fb:	4c 09 e6             	or     rsi,r12
	__asm__ __volatile__(
  40f8fe:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40f901:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40f905:	48 89 cd             	mov    rbp,rcx
  40f908:	49 b8 20 f9 40 00 00 	movabs r8,0x40f920
  40f90f:	00 00 00 
  40f912:	0f 05                	syscall 
  40f914:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  40f918:	eb 0d                	jmp    40f927 <cos_initthd_alloc+0x157>
  40f91a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40f920:	b9 00 00 00 00       	mov    ecx,0x0
  40f925:	eb 05                	jmp    40f92c <cos_initthd_alloc+0x15c>
  40f927:	b9 01 00 00 00       	mov    ecx,0x1
  40f92c:	5d                   	pop    rbp
  40f92d:	5c                   	pop    rsp
	if (ret) BUG();
  40f92e:	85 c0                	test   eax,eax
  40f930:	75 66                	jne    40f998 <cos_initthd_alloc+0x1c8>
	thdid_t tid = cos_thd_id_alloc();

	return __cos_thd_alloc(ci, comp, 0, tid);
}
  40f932:	48 83 c4 28          	add    rsp,0x28
  40f936:	4c 89 f8             	mov    rax,r15
  40f939:	5b                   	pop    rbx
  40f93a:	41 5c                	pop    r12
  40f93c:	41 5d                	pop    r13
  40f93e:	41 5e                	pop    r14
  40f940:	41 5f                	pop    r15
  40f942:	5d                   	pop    rbp
  40f943:	c3                   	ret    
  40f944:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  40f948:	4c 89 f7             	mov    rdi,r14
  40f94b:	4c 89 5d b0          	mov    QWORD PTR [rbp-0x50],r11
  40f94f:	4c 89 55 b8          	mov    QWORD PTR [rbp-0x48],r10
  40f953:	e8 88 d0 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40f958:	4c 8b 55 b8          	mov    r10,QWORD PTR [rbp-0x48]
  40f95c:	4c 8b 5d b0          	mov    r11,QWORD PTR [rbp-0x50]
  40f960:	85 c0                	test   eax,eax
  40f962:	75 24                	jne    40f988 <cos_initthd_alloc+0x1b8>
        __asm__ __volatile__("lock " PS_FAA_STR
  40f964:	b8 04 00 00 00       	mov    eax,0x4
  40f969:	f0 49 0f c1 46 18    	lock xadd QWORD PTR [r14+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40f96f:	49 89 46 28          	mov    QWORD PTR [r14+0x28],rax
  40f973:	e9 35 ff ff ff       	jmp    40f8ad <cos_initthd_alloc+0xdd>
  40f978:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40f97f:	00 
  40f980:	49 89 c3             	mov    r11,rax
	return __cos_ulk_info.curr_pg;
  40f983:	e9 d6 fe ff ff       	jmp    40f85e <cos_initthd_alloc+0x8e>
{ l->o = 0; }
  40f988:	49 c7 86 b0 00 00 00 	mov    QWORD PTR [r14+0xb0],0x0
  40f98f:	00 00 00 00 
	if (!*cap) return -1;
  40f993:	eb 9d                	jmp    40f932 <cos_initthd_alloc+0x162>
  40f995:	0f 1f 00             	nop    DWORD PTR [rax]
  40f998:	be 1b 00 00 00       	mov    esi,0x1b
  40f99d:	bf 3f cd 41 00       	mov    edi,0x41cd3f
  40f9a2:	e8 29 a7 ff ff       	call   40a0d0 <cos_print_str>
	if (ret) BUG();
  40f9a7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f9ae:	00 00 00 00 
  40f9b2:	0f 0b                	ud2    
  40f9b4:	be 2e 00 00 00       	mov    esi,0x2e
  40f9b9:	bf b0 cc 41 00       	mov    edi,0x41ccb0
  40f9be:	e8 0d a7 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci && comp > 0);
  40f9c3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f9ca:	00 00 00 00 
  40f9ce:	0f 0b                	ud2    
  40f9d0:	be 2e 00 00 00       	mov    esi,0x2e
  40f9d5:	bf e0 cc 41 00       	mov    edi,0x41cce0
  40f9da:	e8 f1 a6 ff ff       	call   40a0d0 <cos_print_str>
		assert(__cos_ulk_info.curr_pg);
  40f9df:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f9e6:	00 00 00 00 
  40f9ea:	0f 0b                	ud2    
	if (__alloc_mem_cap(ci, CAP_THD, &kmem, &cap)) return 0;
  40f9ec:	45 31 ff             	xor    r15d,r15d
	return __cos_thd_alloc(ci, comp, 0, tid);
  40f9ef:	e9 3e ff ff ff       	jmp    40f932 <cos_initthd_alloc+0x162>
  40f9f4:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40f9fb:	00 00 00 00 
  40f9ff:	90                   	nop

000000000040fa00 <cos_captbl_alloc>:

captblcap_t
cos_captbl_alloc(struct cos_compinfo *ci)
{
  40fa00:	f3 0f 1e fa          	endbr64 
  40fa04:	55                   	push   rbp
  40fa05:	48 89 e5             	mov    rbp,rsp
  40fa08:	41 56                	push   r14
  40fa0a:	41 55                	push   r13
  40fa0c:	41 54                	push   r12
  40fa0e:	53                   	push   rbx
  40fa0f:	48 83 ec 10          	sub    rsp,0x10
	vaddr_t kmem;
	capid_t cap;

	printd("cos_captbl_alloc\n");

	assert(ci);
  40fa13:	48 85 ff             	test   rdi,rdi
  40fa16:	0f 84 20 01 00 00    	je     40fb3c <cos_captbl_alloc+0x13c>
  40fa1c:	49 89 fc             	mov    r12,rdi
	return __mem_bump_alloc(ci, 1, 1);
  40fa1f:	e8 3c ce ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40fa24:	49 89 c5             	mov    r13,rax
	if (!*kmem) return -1;
  40fa27:	48 85 c0             	test   rax,rax
  40fa2a:	0f 84 28 01 00 00    	je     40fb58 <cos_captbl_alloc+0x158>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40fa30:	49 8d 94 24 b0 00 00 	lea    rdx,[r12+0xb0]
  40fa37:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  40fa38:	be 01 00 00 00       	mov    esi,0x1
  40fa3d:	31 c9                	xor    ecx,ecx
  40fa3f:	90                   	nop
  40fa40:	48 89 c8             	mov    rax,rcx
  40fa43:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40fa48:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40fa4b:	84 c0                	test   al,al
  40fa4d:	74 f1                	je     40fa40 <cos_captbl_alloc+0x40>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40fa4f:	4d 8b 74 24 38       	mov    r14,QWORD PTR [r12+0x38]
  40fa54:	41 83 e6 03          	and    r14d,0x3
  40fa58:	0f 84 92 00 00 00    	je     40faf0 <cos_captbl_alloc+0xf0>
        __asm__ __volatile__("lock " PS_FAA_STR
  40fa5e:	bb 04 00 00 00       	mov    ebx,0x4
  40fa63:	f0 49 0f c1 5c 24 38 	lock xadd QWORD PTR [r12+0x38],rbx
{ l->o = 0; }
  40fa6a:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40fa71:	00 00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  40fa76:	49 89 de             	mov    r14,rbx
	if (!*cap) return -1;
  40fa79:	48 85 db             	test   rbx,rbx
  40fa7c:	0f 84 d6 00 00 00    	je     40fb58 <cos_captbl_alloc+0x158>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40fa82:	41 8b 44 24 08       	mov    eax,DWORD PTR [r12+0x8]

	if (__alloc_mem_cap(ci, CAP_CAPTBL, &kmem, &cap)) return 0;
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_CAPTBLACTIVATE, cap, __compinfo_metacap(ci)->mi.pgtbl_cap, kmem, 0))
  40fa87:	49 8b 54 24 60       	mov    rdx,QWORD PTR [r12+0x60]
	__asm__ __volatile__(
  40fa8c:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  40fa90:	4c 89 ef             	mov    rdi,r13
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40fa93:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40fa96:	48 8b b2 98 00 00 00 	mov    rsi,QWORD PTR [rdx+0x98]
  40fa9d:	31 d2                	xor    edx,edx
	cap_no += op;
  40fa9f:	05 1e 00 01 00       	add    eax,0x1001e
	__asm__ __volatile__(
  40faa4:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40faa7:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40faab:	48 89 cd             	mov    rbp,rcx
  40faae:	49 b8 c8 fa 40 00 00 	movabs r8,0x40fac8
  40fab5:	00 00 00 
  40fab8:	0f 05                	syscall 
  40faba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40fac0:	eb 0d                	jmp    40facf <cos_captbl_alloc+0xcf>
  40fac2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40fac8:	b9 00 00 00 00       	mov    ecx,0x0
  40facd:	eb 05                	jmp    40fad4 <cos_captbl_alloc+0xd4>
  40facf:	b9 01 00 00 00       	mov    ecx,0x1
  40fad4:	5d                   	pop    rbp
  40fad5:	5c                   	pop    rsp
  40fad6:	85 c0                	test   eax,eax
  40fad8:	75 46                	jne    40fb20 <cos_captbl_alloc+0x120>
		BUG();

	return cap;
}
  40fada:	48 83 c4 10          	add    rsp,0x10
  40fade:	4c 89 f0             	mov    rax,r14
  40fae1:	5b                   	pop    rbx
  40fae2:	41 5c                	pop    r12
  40fae4:	41 5d                	pop    r13
  40fae6:	41 5e                	pop    r14
  40fae8:	5d                   	pop    rbp
  40fae9:	c3                   	ret    
  40faea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  40faf0:	4c 89 e7             	mov    rdi,r12
  40faf3:	e8 e8 ce ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40faf8:	85 c0                	test   eax,eax
  40fafa:	75 16                	jne    40fb12 <cos_captbl_alloc+0x112>
        __asm__ __volatile__("lock " PS_FAA_STR
  40fafc:	b8 04 00 00 00       	mov    eax,0x4
  40fb01:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40fb08:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  40fb0d:	e9 4c ff ff ff       	jmp    40fa5e <cos_captbl_alloc+0x5e>
{ l->o = 0; }
  40fb12:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40fb19:	00 00 00 00 00 
	if (!*cap) return -1;
  40fb1e:	eb ba                	jmp    40fada <cos_captbl_alloc+0xda>
  40fb20:	be 1c 00 00 00       	mov    esi,0x1c
  40fb25:	bf 68 d1 41 00       	mov    edi,0x41d168
  40fb2a:	e8 a1 a5 ff ff       	call   40a0d0 <cos_print_str>
		BUG();
  40fb2f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40fb36:	00 00 00 00 
  40fb3a:	0f 0b                	ud2    
  40fb3c:	be 2f 00 00 00       	mov    esi,0x2f
  40fb41:	bf 38 d1 41 00       	mov    edi,0x41d138
  40fb46:	e8 85 a5 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci);
  40fb4b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40fb52:	00 00 00 00 
  40fb56:	0f 0b                	ud2    
	if (__alloc_mem_cap(ci, CAP_CAPTBL, &kmem, &cap)) return 0;
  40fb58:	45 31 f6             	xor    r14d,r14d
  40fb5b:	e9 7a ff ff ff       	jmp    40fada <cos_captbl_alloc+0xda>

000000000040fb60 <cos_pgtbl_alloc>:

pgtblcap_t
cos_pgtbl_alloc(struct cos_compinfo *ci, u8_t type)
{
  40fb60:	f3 0f 1e fa          	endbr64 
  40fb64:	55                   	push   rbp
  40fb65:	48 89 e5             	mov    rbp,rsp
  40fb68:	41 57                	push   r15
  40fb6a:	41 56                	push   r14
  40fb6c:	41 55                	push   r13
  40fb6e:	41 54                	push   r12
  40fb70:	53                   	push   rbx
  40fb71:	48 83 ec 18          	sub    rsp,0x18
	capid_t cap;
	word_t lvl = 0;

	printd("cos_pgtbl_alloc\n");

	assert(ci);
  40fb75:	48 85 ff             	test   rdi,rdi
  40fb78:	0f 84 26 01 00 00    	je     40fca4 <cos_pgtbl_alloc+0x144>
  40fb7e:	49 89 fe             	mov    r14,rdi
  40fb81:	41 89 f4             	mov    r12d,esi
	return __mem_bump_alloc(ci, 1, 1);
  40fb84:	e8 d7 cc ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40fb89:	49 89 c5             	mov    r13,rax
	if (!*kmem) return -1;
  40fb8c:	48 85 c0             	test   rax,rax
  40fb8f:	0f 84 2b 01 00 00    	je     40fcc0 <cos_pgtbl_alloc+0x160>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40fb95:	49 8d 96 b0 00 00 00 	lea    rdx,[r14+0xb0]
        __asm__ __volatile__("lock " PS_CAS_STR
  40fb9c:	be 01 00 00 00       	mov    esi,0x1
  40fba1:	31 c9                	xor    ecx,ecx
  40fba3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40fba8:	48 89 c8             	mov    rax,rcx
  40fbab:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40fbb0:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40fbb3:	84 c0                	test   al,al
  40fbb5:	74 f1                	je     40fba8 <cos_pgtbl_alloc+0x48>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40fbb7:	4d 8b 7e 38          	mov    r15,QWORD PTR [r14+0x38]
  40fbbb:	41 83 e7 03          	and    r15d,0x3
  40fbbf:	0f 84 93 00 00 00    	je     40fc58 <cos_pgtbl_alloc+0xf8>
        __asm__ __volatile__("lock " PS_FAA_STR
  40fbc5:	bb 04 00 00 00       	mov    ebx,0x4
  40fbca:	f0 49 0f c1 5e 38    	lock xadd QWORD PTR [r14+0x38],rbx
{ l->o = 0; }
  40fbd0:	49 c7 86 b0 00 00 00 	mov    QWORD PTR [r14+0xb0],0x0
  40fbd7:	00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  40fbdb:	49 89 df             	mov    r15,rbx
	if (!*cap) return -1;
  40fbde:	48 85 db             	test   rbx,rbx
  40fbe1:	0f 84 d9 00 00 00    	je     40fcc0 <cos_pgtbl_alloc+0x160>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40fbe7:	41 8b 46 08          	mov    eax,DWORD PTR [r14+0x8]

	if (__alloc_mem_cap(ci, CAP_PGTBL, &kmem, &cap)) return 0;

	if (unlikely(type)) lvl |= PGTBL_LVL_FLAG_VM;
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_PGTBLACTIVATE, cap, __compinfo_metacap(ci)->mi.pgtbl_cap, kmem, lvl))
  40fbeb:	49 8b 56 60          	mov    rdx,QWORD PTR [r14+0x60]
	__asm__ __volatile__(
  40fbef:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  40fbf3:	4c 89 ef             	mov    rdi,r13
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40fbf6:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40fbf9:	48 8b b2 98 00 00 00 	mov    rsi,QWORD PTR [rdx+0x98]
	if (unlikely(type)) lvl |= PGTBL_LVL_FLAG_VM;
  40fc00:	31 d2                	xor    edx,edx
	cap_no += op;
  40fc02:	05 1c 00 01 00       	add    eax,0x1001c
  40fc07:	45 84 e4             	test   r12b,r12b
  40fc0a:	0f 95 c2             	setne  dl
  40fc0d:	48 c1 e2 1f          	shl    rdx,0x1f
	__asm__ __volatile__(
  40fc11:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40fc14:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40fc18:	48 89 cd             	mov    rbp,rcx
  40fc1b:	49 b8 30 fc 40 00 00 	movabs r8,0x40fc30
  40fc22:	00 00 00 
  40fc25:	0f 05                	syscall 
  40fc27:	90                   	nop
  40fc28:	eb 0d                	jmp    40fc37 <cos_pgtbl_alloc+0xd7>
  40fc2a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40fc30:	b9 00 00 00 00       	mov    ecx,0x0
  40fc35:	eb 05                	jmp    40fc3c <cos_pgtbl_alloc+0xdc>
  40fc37:	b9 01 00 00 00       	mov    ecx,0x1
  40fc3c:	5d                   	pop    rbp
  40fc3d:	5c                   	pop    rsp
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_PGTBLACTIVATE, cap, __compinfo_metacap(ci)->mi.pgtbl_cap, kmem, lvl))
  40fc3e:	85 c0                	test   eax,eax
  40fc40:	75 46                	jne    40fc88 <cos_pgtbl_alloc+0x128>
		BUG();

	return cap;
}
  40fc42:	48 83 c4 18          	add    rsp,0x18
  40fc46:	4c 89 f8             	mov    rax,r15
  40fc49:	5b                   	pop    rbx
  40fc4a:	41 5c                	pop    r12
  40fc4c:	41 5d                	pop    r13
  40fc4e:	41 5e                	pop    r14
  40fc50:	41 5f                	pop    r15
  40fc52:	5d                   	pop    rbp
  40fc53:	c3                   	ret    
  40fc54:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  40fc58:	4c 89 f7             	mov    rdi,r14
  40fc5b:	e8 80 cd ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40fc60:	85 c0                	test   eax,eax
  40fc62:	75 14                	jne    40fc78 <cos_pgtbl_alloc+0x118>
        __asm__ __volatile__("lock " PS_FAA_STR
  40fc64:	b8 04 00 00 00       	mov    eax,0x4
  40fc69:	f0 49 0f c1 46 18    	lock xadd QWORD PTR [r14+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40fc6f:	49 89 46 38          	mov    QWORD PTR [r14+0x38],rax
  40fc73:	e9 4d ff ff ff       	jmp    40fbc5 <cos_pgtbl_alloc+0x65>
{ l->o = 0; }
  40fc78:	49 c7 86 b0 00 00 00 	mov    QWORD PTR [r14+0xb0],0x0
  40fc7f:	00 00 00 00 
	if (!*cap) return -1;
  40fc83:	eb bd                	jmp    40fc42 <cos_pgtbl_alloc+0xe2>
  40fc85:	0f 1f 00             	nop    DWORD PTR [rax]
  40fc88:	be 1c 00 00 00       	mov    esi,0x1c
  40fc8d:	bf b8 d1 41 00       	mov    edi,0x41d1b8
  40fc92:	e8 39 a4 ff ff       	call   40a0d0 <cos_print_str>
		BUG();
  40fc97:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40fc9e:	00 00 00 00 
  40fca2:	0f 0b                	ud2    
  40fca4:	be 2f 00 00 00       	mov    esi,0x2f
  40fca9:	bf 88 d1 41 00       	mov    edi,0x41d188
  40fcae:	e8 1d a4 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci);
  40fcb3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40fcba:	00 00 00 00 
  40fcbe:	0f 0b                	ud2    
	if (__alloc_mem_cap(ci, CAP_PGTBL, &kmem, &cap)) return 0;
  40fcc0:	45 31 ff             	xor    r15d,r15d
  40fcc3:	e9 7a ff ff ff       	jmp    40fc42 <cos_pgtbl_alloc+0xe2>
  40fcc8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40fccf:	00 

000000000040fcd0 <cos_ulk_pgtbl_create>:
{
  40fcd0:	f3 0f 1e fa          	endbr64 
  40fcd4:	55                   	push   rbp
  40fcd5:	48 89 e5             	mov    rbp,rsp
  40fcd8:	41 57                	push   r15
  40fcda:	41 56                	push   r14
  40fcdc:	41 55                	push   r13
  40fcde:	41 54                	push   r12
  40fce0:	53                   	push   rbx
  40fce1:	48 83 ec 58          	sub    rsp,0x58
	assert(ci && secondlvl);
  40fce5:	48 85 ff             	test   rdi,rdi
  40fce8:	0f 84 22 02 00 00    	je     40ff10 <cos_ulk_pgtbl_create+0x240>
  40fcee:	49 89 f7             	mov    r15,rsi
  40fcf1:	48 85 f6             	test   rsi,rsi
  40fcf4:	0f 84 16 02 00 00    	je     40ff10 <cos_ulk_pgtbl_create+0x240>
  40fcfa:	49 89 fd             	mov    r13,rdi
	toplvl = cos_pgtbl_alloc(__compinfo_metacap(ci), PGTBL_TYPE_DEF);
  40fcfd:	48 8b 7f 60          	mov    rdi,QWORD PTR [rdi+0x60]
  40fd01:	31 f6                	xor    esi,esi
  40fd03:	e8 58 fe ff ff       	call   40fb60 <cos_pgtbl_alloc>
	*secondlvl = __bump_mem_expand_intern(__compinfo_metacap(ci), toplvl, ULK_BASE_ADDR, 0, 0);
  40fd08:	49 8b 7d 60          	mov    rdi,QWORD PTR [r13+0x60]
  40fd0c:	45 31 c0             	xor    r8d,r8d
  40fd0f:	31 c9                	xor    ecx,ecx
  40fd11:	48 ba 00 00 00 00 80 	movabs rdx,0x7f8000000000
  40fd18:	7f 00 00 
  40fd1b:	48 89 c6             	mov    rsi,rax
	toplvl = cos_pgtbl_alloc(__compinfo_metacap(ci), PGTBL_TYPE_DEF);
  40fd1e:	49 89 c6             	mov    r14,rax
	*secondlvl = __bump_mem_expand_intern(__compinfo_metacap(ci), toplvl, ULK_BASE_ADDR, 0, 0);
  40fd21:	e8 7a d6 ff ff       	call   40d3a0 <__bump_mem_expand_intern>
  40fd26:	49 89 07             	mov    QWORD PTR [r15],rax
	if (!*secondlvl) return 0;
  40fd29:	48 85 c0             	test   rax,rax
  40fd2c:	75 1a                	jne    40fd48 <cos_ulk_pgtbl_create+0x78>
  40fd2e:	45 31 f6             	xor    r14d,r14d
}
  40fd31:	48 83 c4 58          	add    rsp,0x58
  40fd35:	4c 89 f0             	mov    rax,r14
  40fd38:	5b                   	pop    rbx
  40fd39:	41 5c                	pop    r12
  40fd3b:	41 5d                	pop    r13
  40fd3d:	41 5e                	pop    r14
  40fd3f:	41 5f                	pop    r15
  40fd41:	5d                   	pop    rbp
  40fd42:	c3                   	ret    
  40fd43:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		if (__bump_mem_expand_intern(meta, cipgtbl, addr, 0, pgtbl_lvl) == 0) return 0;
  40fd48:	49 8b 7d 60          	mov    rdi,QWORD PTR [r13+0x60]
  40fd4c:	45 31 c0             	xor    r8d,r8d
  40fd4f:	31 c9                	xor    ecx,ecx
  40fd51:	4c 89 f6             	mov    rsi,r14
  40fd54:	48 ba 00 10 00 00 80 	movabs rdx,0x7f8000001000
  40fd5b:	7f 00 00 
  40fd5e:	e8 3d d6 ff ff       	call   40d3a0 <__bump_mem_expand_intern>
  40fd63:	48 85 c0             	test   rax,rax
  40fd66:	74 c6                	je     40fd2e <cos_ulk_pgtbl_create+0x5e>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40fd68:	44 89 f0             	mov    eax,r14d
	cap_no += op;
  40fd6b:	48 c7 45 b8 01 00 00 	mov    QWORD PTR [rbp-0x48],0x1
  40fd72:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  40fd73:	41 ba 01 00 00 00    	mov    r10d,0x1
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40fd79:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40fd7c:	05 01 00 01 00       	add    eax,0x10001
  40fd81:	89 45 b4             	mov    DWORD PTR [rbp-0x4c],eax
	return ci->memsrc;
  40fd84:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  40fd88:	4d 8b 7d 60          	mov    r15,QWORD PTR [r13+0x60]
	for (addr = mem_ptr; addr < tmp_frontier; addr += range) {
  40fd8c:	4c 89 75 90          	mov    QWORD PTR [rbp-0x70],r14
  40fd90:	4c 89 6d 88          	mov    QWORD PTR [rbp-0x78],r13
  40fd94:	48 8b 1c c5 50 d9 41 	mov    rbx,QWORD PTR [rax*8+0x41d950]
  40fd9b:	00 
		return round_up_to_pgt2_page(vaddr);
  40fd9c:	48 83 f8 02          	cmp    rax,0x2
  40fda0:	48 b8 00 00 20 00 80 	movabs rax,0x7f8000200000
  40fda7:	7f 00 00 
  40fdaa:	48 89 5d 98          	mov    QWORD PTR [rbp-0x68],rbx
  40fdae:	48 bb 00 00 00 40 80 	movabs rbx,0x7f8040000000
  40fdb5:	7f 00 00 
  40fdb8:	48 0f 45 c3          	cmovne rax,rbx
  40fdbc:	48 89 45 a0          	mov    QWORD PTR [rbp-0x60],rax
	for (addr = mem_ptr; addr < tmp_frontier; addr += range) {
  40fdc0:	48 b8 00 00 00 00 80 	movabs rax,0x7f8000000000
  40fdc7:	7f 00 00 
  40fdca:	48 89 45 a8          	mov    QWORD PTR [rbp-0x58],rax
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  40fdce:	4d 3b 7f 60          	cmp    r15,QWORD PTR [r15+0x60]
  40fdd2:	0f 85 bf 01 00 00    	jne    40ff97 <cos_ulk_pgtbl_create+0x2c7>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40fdd8:	49 8d 97 b0 00 00 00 	lea    rdx,[r15+0xb0]
        __asm__ __volatile__("lock " PS_CAS_STR
  40fddf:	31 c9                	xor    ecx,ecx
  40fde1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  40fde8:	48 89 c8             	mov    rax,rcx
  40fdeb:	f0 4c 0f b1 12       	lock cmpxchg QWORD PTR [rdx],r10
  40fdf0:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40fdf3:	84 c0                	test   al,al
  40fdf5:	74 f1                	je     40fde8 <cos_ulk_pgtbl_create+0x118>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40fdf7:	41 f6 47 38 03       	test   BYTE PTR [r15+0x38],0x3
  40fdfc:	0f 84 2a 01 00 00    	je     40ff2c <cos_ulk_pgtbl_create+0x25c>
        __asm__ __volatile__("lock " PS_FAA_STR
  40fe02:	bb 04 00 00 00       	mov    ebx,0x4
  40fe07:	f0 49 0f c1 5f 38    	lock xadd QWORD PTR [r15+0x38],rbx
{ l->o = 0; }
  40fe0d:	49 c7 87 b0 00 00 00 	mov    QWORD PTR [r15+0xb0],0x0
  40fe14:	00 00 00 00 
	return __mem_bump_alloc(ci, 1, 1);
  40fe18:	4c 89 ff             	mov    rdi,r15
  40fe1b:	e8 40 ca ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40fe20:	48 89 c7             	mov    rdi,rax
		if (pte_cap == 0 || ptemem_cap == 0) {
  40fe23:	48 85 db             	test   rbx,rbx
  40fe26:	0f 84 1f 01 00 00    	je     40ff4b <cos_ulk_pgtbl_create+0x27b>
  40fe2c:	48 85 c0             	test   rax,rax
  40fe2f:	41 ba 01 00 00 00    	mov    r10d,0x1
  40fe35:	0f 84 10 01 00 00    	je     40ff4b <cos_ulk_pgtbl_create+0x27b>
		if (call_cap_op(meta->captbl_cap, CAPTBL_OP_PGTBLACTIVATE, pte_cap, meta->mi.pgtbl_cap, ptemem_cap,
  40fe3b:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
	__asm__ __volatile__(
  40fe3f:	4c 8d 75 c0          	lea    r14,[rbp-0x40]
  40fe43:	49 8b b7 98 00 00 00 	mov    rsi,QWORD PTR [r15+0x98]
  40fe4a:	4c 89 f1             	mov    rcx,r14
  40fe4d:	4c 8d 68 01          	lea    r13,[rax+0x1]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40fe51:	41 8b 47 08          	mov    eax,DWORD PTR [r15+0x8]
	__asm__ __volatile__(
  40fe55:	4c 89 ea             	mov    rdx,r13
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40fe58:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40fe5b:	05 1c 00 01 00       	add    eax,0x1001c
	__asm__ __volatile__(
  40fe60:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40fe63:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40fe67:	48 89 cd             	mov    rbp,rcx
  40fe6a:	49 b8 80 fe 40 00 00 	movabs r8,0x40fe80
  40fe71:	00 00 00 
  40fe74:	0f 05                	syscall 
  40fe76:	66 90                	xchg   ax,ax
  40fe78:	eb 0d                	jmp    40fe87 <cos_ulk_pgtbl_create+0x1b7>
  40fe7a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40fe80:	b9 00 00 00 00       	mov    ecx,0x0
  40fe85:	eb 05                	jmp    40fe8c <cos_ulk_pgtbl_create+0x1bc>
  40fe87:	b9 01 00 00 00       	mov    ecx,0x1
  40fe8c:	5d                   	pop    rbp
  40fe8d:	5c                   	pop    rsp
  40fe8e:	85 c0                	test   eax,eax
  40fe90:	0f 85 e5 00 00 00    	jne    40ff7b <cos_ulk_pgtbl_create+0x2ab>
  40fe96:	31 d2                	xor    edx,edx
  40fe98:	8b 45 b4             	mov    eax,DWORD PTR [rbp-0x4c]
  40fe9b:	48 8b 75 a8          	mov    rsi,QWORD PTR [rbp-0x58]
  40fe9f:	4c 89 f1             	mov    rcx,r14
  40fea2:	48 89 d7             	mov    rdi,rdx
  40fea5:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40fea8:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40feac:	48 89 cd             	mov    rbp,rcx
  40feaf:	49 b8 c8 fe 40 00 00 	movabs r8,0x40fec8
  40feb6:	00 00 00 
  40feb9:	0f 05                	syscall 
  40febb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40fec0:	eb 0d                	jmp    40fecf <cos_ulk_pgtbl_create+0x1ff>
  40fec2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40fec8:	b9 00 00 00 00       	mov    ecx,0x0
  40fecd:	eb 05                	jmp    40fed4 <cos_ulk_pgtbl_create+0x204>
  40fecf:	b9 01 00 00 00       	mov    ecx,0x1
  40fed4:	5d                   	pop    rbp
  40fed5:	5c                   	pop    rsp
	for (addr = mem_ptr; addr < tmp_frontier; addr += range) {
  40fed6:	48 8b 45 98          	mov    rax,QWORD PTR [rbp-0x68]
  40feda:	48 01 c6             	add    rsi,rax
  40fedd:	48 89 75 a8          	mov    QWORD PTR [rbp-0x58],rsi
  40fee1:	48 39 75 a0          	cmp    QWORD PTR [rbp-0x60],rsi
  40fee5:	0f 87 e3 fe ff ff    	ja     40fdce <cos_ulk_pgtbl_create+0xfe>
  40feeb:	4c 89 ea             	mov    rdx,r13
  40feee:	48 c7 45 b8 02 00 00 	mov    QWORD PTR [rbp-0x48],0x2
  40fef5:	00 
  40fef6:	4c 8b 75 90          	mov    r14,QWORD PTR [rbp-0x70]
  40fefa:	4c 8b 6d 88          	mov    r13,QWORD PTR [rbp-0x78]
	for (pgtbl_lvl = 1; pgtbl_lvl < COS_PGTBL_DEPTH - 1; pgtbl_lvl++) {
  40fefe:	48 83 fa 03          	cmp    rdx,0x3
  40ff02:	0f 84 29 fe ff ff    	je     40fd31 <cos_ulk_pgtbl_create+0x61>
  40ff08:	e9 77 fe ff ff       	jmp    40fd84 <cos_ulk_pgtbl_create+0xb4>
  40ff0d:	0f 1f 00             	nop    DWORD PTR [rax]
  40ff10:	be 2e 00 00 00       	mov    esi,0x2e
  40ff15:	bf d8 d1 41 00       	mov    edi,0x41d1d8
  40ff1a:	e8 b1 a1 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci && secondlvl);
  40ff1f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ff26:	00 00 00 00 
  40ff2a:	0f 0b                	ud2    
		if (__capid_captbl_check_expand(ci)) goto error;
  40ff2c:	4c 89 ff             	mov    rdi,r15
  40ff2f:	e8 ac ca ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40ff34:	85 c0                	test   eax,eax
  40ff36:	74 2f                	je     40ff67 <cos_ulk_pgtbl_create+0x297>
  40ff38:	49 c7 87 b0 00 00 00 	mov    QWORD PTR [r15+0xb0],0x0
  40ff3f:	00 00 00 00 
	return __mem_bump_alloc(ci, 1, 1);
  40ff43:	4c 89 ff             	mov    rdi,r15
  40ff46:	e8 15 c9 ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40ff4b:	be 2e 00 00 00       	mov    esi,0x2e
  40ff50:	bf c0 c7 41 00       	mov    edi,0x41c7c0
  40ff55:	e8 76 a1 ff ff       	call   40a0d0 <cos_print_str>
			assert(0);
  40ff5a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ff61:	00 00 00 00 
  40ff65:	0f 0b                	ud2    
        __asm__ __volatile__("lock " PS_FAA_STR
  40ff67:	b8 04 00 00 00       	mov    eax,0x4
  40ff6c:	f0 49 0f c1 47 18    	lock xadd QWORD PTR [r15+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40ff72:	49 89 47 38          	mov    QWORD PTR [r15+0x38],rax
  40ff76:	e9 87 fe ff ff       	jmp    40fe02 <cos_ulk_pgtbl_create+0x132>
  40ff7b:	be 2e 00 00 00       	mov    esi,0x2e
  40ff80:	bf f0 c7 41 00       	mov    edi,0x41c7f0
  40ff85:	e8 46 a1 ff ff       	call   40a0d0 <cos_print_str>
				assert(0); /* race? */
  40ff8a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ff91:	00 00 00 00 
  40ff95:	0f 0b                	ud2    
  40ff97:	be 2e 00 00 00       	mov    esi,0x2e
  40ff9c:	bf 90 c7 41 00       	mov    edi,0x41c790
  40ffa1:	e8 2a a1 ff ff       	call   40a0d0 <cos_print_str>
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  40ffa6:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ffad:	00 00 00 00 
  40ffb1:	0f 0b                	ud2    
  40ffb3:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40ffba:	00 00 00 00 
  40ffbe:	66 90                	xchg   ax,ax

000000000040ffc0 <cos_ulk_info_init>:
{
  40ffc0:	f3 0f 1e fa          	endbr64 
  40ffc4:	55                   	push   rbp
  40ffc5:	48 89 e5             	mov    rbp,rsp
  40ffc8:	41 57                	push   r15
  40ffca:	41 56                	push   r14
  40ffcc:	41 55                	push   r13
  40ffce:	41 54                	push   r12
  40ffd0:	53                   	push   rbx
  40ffd1:	48 83 ec 58          	sub    rsp,0x58
	assert(ci && secondlvl);
  40ffd5:	48 85 ff             	test   rdi,rdi
  40ffd8:	0f 84 7d 02 00 00    	je     41025b <cos_ulk_info_init+0x29b>
  40ffde:	49 89 fd             	mov    r13,rdi
	toplvl = cos_pgtbl_alloc(__compinfo_metacap(ci), PGTBL_TYPE_DEF);
  40ffe1:	48 8b 7f 60          	mov    rdi,QWORD PTR [rdi+0x60]
  40ffe5:	31 f6                	xor    esi,esi
  40ffe7:	e8 74 fb ff ff       	call   40fb60 <cos_pgtbl_alloc>
	*secondlvl = __bump_mem_expand_intern(__compinfo_metacap(ci), toplvl, ULK_BASE_ADDR, 0, 0);
  40ffec:	49 8b 7d 60          	mov    rdi,QWORD PTR [r13+0x60]
  40fff0:	45 31 c0             	xor    r8d,r8d
  40fff3:	31 c9                	xor    ecx,ecx
  40fff5:	48 ba 00 00 00 00 80 	movabs rdx,0x7f8000000000
  40fffc:	7f 00 00 
  40ffff:	48 89 c6             	mov    rsi,rax
	toplvl = cos_pgtbl_alloc(__compinfo_metacap(ci), PGTBL_TYPE_DEF);
  410002:	49 89 c7             	mov    r15,rax
	*secondlvl = __bump_mem_expand_intern(__compinfo_metacap(ci), toplvl, ULK_BASE_ADDR, 0, 0);
  410005:	e8 96 d3 ff ff       	call   40d3a0 <__bump_mem_expand_intern>
  41000a:	48 89 05 37 0a 19 00 	mov    QWORD PTR [rip+0x190a37],rax        # 5a0a48 <__cos_ulk_info+0x8>
	if (!*secondlvl) return 0;
  410011:	48 85 c0             	test   rax,rax
  410014:	75 4a                	jne    410060 <cos_ulk_info_init+0xa0>
	__cos_ulk_info.pg_frontier = ULK_BASE_ADDR + __thdid_alloc * sizeof(struct ulk_invstk);
  410016:	48 b8 00 00 00 80 7f 	movabs rax,0x7f80000000
  41001d:	00 00 00 
  410020:	48 03 05 59 c0 04 00 	add    rax,QWORD PTR [rip+0x4c059]        # 45c080 <__thdid_alloc>
	__cos_ulk_info.toplvl = cos_ulk_pgtbl_create(ci, &__cos_ulk_info.secondlvl);
  410027:	48 c7 05 0e 0a 19 00 	mov    QWORD PTR [rip+0x190a0e],0x0        # 5a0a40 <__cos_ulk_info>
  41002e:	00 00 00 00 
	__cos_ulk_info.pg_frontier = ULK_BASE_ADDR + __thdid_alloc * sizeof(struct ulk_invstk);
  410032:	48 c1 e0 08          	shl    rax,0x8
  410036:	48 89 05 1b 0a 19 00 	mov    QWORD PTR [rip+0x190a1b],rax        # 5a0a58 <__cos_ulk_info+0x18>
  41003d:	be 2e 00 00 00       	mov    esi,0x2e
  410042:	bf 08 d2 41 00       	mov    edi,0x41d208
  410047:	e8 84 a0 ff ff       	call   40a0d0 <cos_print_str>
	assert(__cos_ulk_info.toplvl);
  41004c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410053:	00 00 00 00 
  410057:	0f 0b                	ud2    
  410059:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		if (__bump_mem_expand_intern(meta, cipgtbl, addr, 0, pgtbl_lvl) == 0) return 0;
  410060:	49 8b 7d 60          	mov    rdi,QWORD PTR [r13+0x60]
  410064:	45 31 c0             	xor    r8d,r8d
  410067:	31 c9                	xor    ecx,ecx
  410069:	4c 89 fe             	mov    rsi,r15
  41006c:	48 ba 00 10 00 00 80 	movabs rdx,0x7f8000001000
  410073:	7f 00 00 
  410076:	e8 25 d3 ff ff       	call   40d3a0 <__bump_mem_expand_intern>
  41007b:	48 85 c0             	test   rax,rax
  41007e:	74 96                	je     410016 <cos_ulk_info_init+0x56>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  410080:	44 89 f8             	mov    eax,r15d
	cap_no += op;
  410083:	48 c7 45 b8 01 00 00 	mov    QWORD PTR [rbp-0x48],0x1
  41008a:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  41008b:	41 ba 01 00 00 00    	mov    r10d,0x1
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  410091:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  410094:	05 01 00 01 00       	add    eax,0x10001
  410099:	89 45 b4             	mov    DWORD PTR [rbp-0x4c],eax
	return ci->memsrc;
  41009c:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  4100a0:	4d 8b 75 60          	mov    r14,QWORD PTR [r13+0x60]
	for (addr = mem_ptr; addr < tmp_frontier; addr += range) {
  4100a4:	4c 89 7d 90          	mov    QWORD PTR [rbp-0x70],r15
  4100a8:	4c 89 6d 88          	mov    QWORD PTR [rbp-0x78],r13
  4100ac:	48 8b 1c c5 50 d9 41 	mov    rbx,QWORD PTR [rax*8+0x41d950]
  4100b3:	00 
		return round_up_to_pgt2_page(vaddr);
  4100b4:	48 83 f8 02          	cmp    rax,0x2
  4100b8:	48 b8 00 00 20 00 80 	movabs rax,0x7f8000200000
  4100bf:	7f 00 00 
  4100c2:	48 89 5d 98          	mov    QWORD PTR [rbp-0x68],rbx
  4100c6:	48 bb 00 00 00 40 80 	movabs rbx,0x7f8040000000
  4100cd:	7f 00 00 
  4100d0:	48 0f 45 c3          	cmovne rax,rbx
  4100d4:	48 89 45 a0          	mov    QWORD PTR [rbp-0x60],rax
	for (addr = mem_ptr; addr < tmp_frontier; addr += range) {
  4100d8:	48 b8 00 00 00 00 80 	movabs rax,0x7f8000000000
  4100df:	7f 00 00 
  4100e2:	48 89 45 a8          	mov    QWORD PTR [rbp-0x58],rax
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  4100e6:	4d 3b 76 60          	cmp    r14,QWORD PTR [r14+0x60]
  4100ea:	0f 85 f2 01 00 00    	jne    4102e2 <cos_ulk_info_init+0x322>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  4100f0:	49 8d 96 b0 00 00 00 	lea    rdx,[r14+0xb0]
        __asm__ __volatile__("lock " PS_CAS_STR
  4100f7:	31 c9                	xor    ecx,ecx
  4100f9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  410100:	48 89 c8             	mov    rax,rcx
  410103:	f0 4c 0f b1 12       	lock cmpxchg QWORD PTR [rdx],r10
  410108:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  41010b:	84 c0                	test   al,al
  41010d:	74 f1                	je     410100 <cos_ulk_info_init+0x140>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  41010f:	41 f6 46 38 03       	test   BYTE PTR [r14+0x38],0x3
  410114:	0f 84 5d 01 00 00    	je     410277 <cos_ulk_info_init+0x2b7>
        __asm__ __volatile__("lock " PS_FAA_STR
  41011a:	bb 04 00 00 00       	mov    ebx,0x4
  41011f:	f0 49 0f c1 5e 38    	lock xadd QWORD PTR [r14+0x38],rbx
{ l->o = 0; }
  410125:	49 c7 86 b0 00 00 00 	mov    QWORD PTR [r14+0xb0],0x0
  41012c:	00 00 00 00 
	return __mem_bump_alloc(ci, 1, 1);
  410130:	4c 89 f7             	mov    rdi,r14
  410133:	e8 28 c7 ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  410138:	48 89 c7             	mov    rdi,rax
		if (pte_cap == 0 || ptemem_cap == 0) {
  41013b:	48 85 db             	test   rbx,rbx
  41013e:	0f 84 52 01 00 00    	je     410296 <cos_ulk_info_init+0x2d6>
  410144:	48 85 c0             	test   rax,rax
  410147:	41 ba 01 00 00 00    	mov    r10d,0x1
  41014d:	0f 84 43 01 00 00    	je     410296 <cos_ulk_info_init+0x2d6>
		if (call_cap_op(meta->captbl_cap, CAPTBL_OP_PGTBLACTIVATE, pte_cap, meta->mi.pgtbl_cap, ptemem_cap,
  410153:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
	__asm__ __volatile__(
  410157:	4c 8d 7d c0          	lea    r15,[rbp-0x40]
  41015b:	49 8b b6 98 00 00 00 	mov    rsi,QWORD PTR [r14+0x98]
  410162:	4c 89 f9             	mov    rcx,r15
  410165:	4c 8d 68 01          	lea    r13,[rax+0x1]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  410169:	41 8b 46 08          	mov    eax,DWORD PTR [r14+0x8]
	__asm__ __volatile__(
  41016d:	4c 89 ea             	mov    rdx,r13
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  410170:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  410173:	05 1c 00 01 00       	add    eax,0x1001c
	__asm__ __volatile__(
  410178:	48 89 29             	mov    QWORD PTR [rcx],rbp
  41017b:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  41017f:	48 89 cd             	mov    rbp,rcx
  410182:	49 b8 98 01 41 00 00 	movabs r8,0x410198
  410189:	00 00 00 
  41018c:	0f 05                	syscall 
  41018e:	66 90                	xchg   ax,ax
  410190:	eb 0d                	jmp    41019f <cos_ulk_info_init+0x1df>
  410192:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410198:	b9 00 00 00 00       	mov    ecx,0x0
  41019d:	eb 05                	jmp    4101a4 <cos_ulk_info_init+0x1e4>
  41019f:	b9 01 00 00 00       	mov    ecx,0x1
  4101a4:	5d                   	pop    rbp
  4101a5:	5c                   	pop    rsp
  4101a6:	85 c0                	test   eax,eax
  4101a8:	0f 85 18 01 00 00    	jne    4102c6 <cos_ulk_info_init+0x306>
  4101ae:	31 d2                	xor    edx,edx
  4101b0:	8b 45 b4             	mov    eax,DWORD PTR [rbp-0x4c]
  4101b3:	48 8b 75 a8          	mov    rsi,QWORD PTR [rbp-0x58]
  4101b7:	4c 89 f9             	mov    rcx,r15
  4101ba:	48 89 d7             	mov    rdi,rdx
  4101bd:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4101c0:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4101c4:	48 89 cd             	mov    rbp,rcx
  4101c7:	49 b8 e0 01 41 00 00 	movabs r8,0x4101e0
  4101ce:	00 00 00 
  4101d1:	0f 05                	syscall 
  4101d3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  4101d8:	eb 0d                	jmp    4101e7 <cos_ulk_info_init+0x227>
  4101da:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4101e0:	b9 00 00 00 00       	mov    ecx,0x0
  4101e5:	eb 05                	jmp    4101ec <cos_ulk_info_init+0x22c>
  4101e7:	b9 01 00 00 00       	mov    ecx,0x1
  4101ec:	5d                   	pop    rbp
  4101ed:	5c                   	pop    rsp
	for (addr = mem_ptr; addr < tmp_frontier; addr += range) {
  4101ee:	48 8b 45 98          	mov    rax,QWORD PTR [rbp-0x68]
  4101f2:	48 01 c6             	add    rsi,rax
  4101f5:	48 89 75 a8          	mov    QWORD PTR [rbp-0x58],rsi
  4101f9:	48 39 75 a0          	cmp    QWORD PTR [rbp-0x60],rsi
  4101fd:	0f 87 e3 fe ff ff    	ja     4100e6 <cos_ulk_info_init+0x126>
  410203:	4c 89 ea             	mov    rdx,r13
  410206:	48 c7 45 b8 02 00 00 	mov    QWORD PTR [rbp-0x48],0x2
  41020d:	00 
  41020e:	4c 8b 7d 90          	mov    r15,QWORD PTR [rbp-0x70]
  410212:	4c 8b 6d 88          	mov    r13,QWORD PTR [rbp-0x78]
	for (pgtbl_lvl = 1; pgtbl_lvl < COS_PGTBL_DEPTH - 1; pgtbl_lvl++) {
  410216:	48 83 fa 03          	cmp    rdx,0x3
  41021a:	0f 85 7c fe ff ff    	jne    41009c <cos_ulk_info_init+0xdc>
	__cos_ulk_info.pg_frontier = ULK_BASE_ADDR + __thdid_alloc * sizeof(struct ulk_invstk);
  410220:	48 b8 00 00 00 80 7f 	movabs rax,0x7f80000000
  410227:	00 00 00 
  41022a:	48 03 05 4f be 04 00 	add    rax,QWORD PTR [rip+0x4be4f]        # 45c080 <__thdid_alloc>
	__cos_ulk_info.toplvl = cos_ulk_pgtbl_create(ci, &__cos_ulk_info.secondlvl);
  410231:	4c 89 3d 08 08 19 00 	mov    QWORD PTR [rip+0x190808],r15        # 5a0a40 <__cos_ulk_info>
	__cos_ulk_info.pg_frontier = ULK_BASE_ADDR + __thdid_alloc * sizeof(struct ulk_invstk);
  410238:	48 c1 e0 08          	shl    rax,0x8
  41023c:	48 89 05 15 08 19 00 	mov    QWORD PTR [rip+0x190815],rax        # 5a0a58 <__cos_ulk_info+0x18>
	assert(__cos_ulk_info.toplvl);
  410243:	4d 85 ff             	test   r15,r15
  410246:	0f 84 f1 fd ff ff    	je     41003d <cos_ulk_info_init+0x7d>
}
  41024c:	48 83 c4 58          	add    rsp,0x58
  410250:	5b                   	pop    rbx
  410251:	41 5c                	pop    r12
  410253:	41 5d                	pop    r13
  410255:	41 5e                	pop    r14
  410257:	41 5f                	pop    r15
  410259:	5d                   	pop    rbp
  41025a:	c3                   	ret    
  41025b:	be 2e 00 00 00       	mov    esi,0x2e
  410260:	bf d8 d1 41 00       	mov    edi,0x41d1d8
  410265:	e8 66 9e ff ff       	call   40a0d0 <cos_print_str>
	assert(ci && secondlvl);
  41026a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410271:	00 00 00 00 
  410275:	0f 0b                	ud2    
		if (__capid_captbl_check_expand(ci)) goto error;
  410277:	4c 89 f7             	mov    rdi,r14
  41027a:	e8 61 c7 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  41027f:	85 c0                	test   eax,eax
  410281:	74 2f                	je     4102b2 <cos_ulk_info_init+0x2f2>
  410283:	49 c7 86 b0 00 00 00 	mov    QWORD PTR [r14+0xb0],0x0
  41028a:	00 00 00 00 
	return __mem_bump_alloc(ci, 1, 1);
  41028e:	4c 89 f7             	mov    rdi,r14
  410291:	e8 ca c5 ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  410296:	be 2e 00 00 00       	mov    esi,0x2e
  41029b:	bf c0 c7 41 00       	mov    edi,0x41c7c0
  4102a0:	e8 2b 9e ff ff       	call   40a0d0 <cos_print_str>
			assert(0);
  4102a5:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4102ac:	00 00 00 00 
  4102b0:	0f 0b                	ud2    
        __asm__ __volatile__("lock " PS_FAA_STR
  4102b2:	b8 04 00 00 00       	mov    eax,0x4
  4102b7:	f0 49 0f c1 46 18    	lock xadd QWORD PTR [r14+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  4102bd:	49 89 46 38          	mov    QWORD PTR [r14+0x38],rax
  4102c1:	e9 54 fe ff ff       	jmp    41011a <cos_ulk_info_init+0x15a>
  4102c6:	be 2e 00 00 00       	mov    esi,0x2e
  4102cb:	bf f0 c7 41 00       	mov    edi,0x41c7f0
  4102d0:	e8 fb 9d ff ff       	call   40a0d0 <cos_print_str>
				assert(0); /* race? */
  4102d5:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4102dc:	00 00 00 00 
  4102e0:	0f 0b                	ud2    
  4102e2:	be 2e 00 00 00       	mov    esi,0x2e
  4102e7:	bf 90 c7 41 00       	mov    edi,0x41c790
  4102ec:	e8 df 9d ff ff       	call   40a0d0 <cos_print_str>
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  4102f1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4102f8:	00 00 00 00 
  4102fc:	0f 0b                	ud2    
  4102fe:	66 90                	xchg   ax,ax

0000000000410300 <cos_comp_alloc_with>:

int
cos_comp_alloc_with(struct cos_compinfo *ci, compcap_t comp, u32_t lid, captblcap_t ctc, pgtblcap_t ptc, vaddr_t entry, prot_domain_t protdom)
{
  410300:	f3 0f 1e fa          	endbr64 
  410304:	55                   	push   rbp
  410305:	41 89 d3             	mov    r11d,edx
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_COMPACTIVATE, comp, (ctc << 16) | ptc, ((unsigned long)lid << 32) | protdom, entry)) return 1;
  410308:	48 c1 e1 10          	shl    rcx,0x10
{
  41030c:	49 89 f2             	mov    r10,rsi
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_COMPACTIVATE, comp, (ctc << 16) | ptc, ((unsigned long)lid << 32) | protdom, entry)) return 1;
  41030f:	48 89 ce             	mov    rsi,rcx
{
  410312:	4c 89 ca             	mov    rdx,r9
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_COMPACTIVATE, comp, (ctc << 16) | ptc, ((unsigned long)lid << 32) | protdom, entry)) return 1;
  410315:	4c 09 c6             	or     rsi,r8
{
  410318:	48 89 e5             	mov    rbp,rsp
  41031b:	41 54                	push   r12
  41031d:	53                   	push   rbx
  41031e:	4c 89 d3             	mov    rbx,r10
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_COMPACTIVATE, comp, (ctc << 16) | ptc, ((unsigned long)lid << 32) | protdom, entry)) return 1;
  410321:	48 8b 47 08          	mov    rax,QWORD PTR [rdi+0x8]
  410325:	8b 4d 10             	mov    ecx,DWORD PTR [rbp+0x10]
  410328:	4c 89 df             	mov    rdi,r11
  41032b:	48 c1 e7 20          	shl    rdi,0x20
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  41032f:	c1 e0 10             	shl    eax,0x10
  410332:	48 09 cf             	or     rdi,rcx
	__asm__ __volatile__(
  410335:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
	cap_no += op;
  410339:	05 0d 00 01 00       	add    eax,0x1000d
	__asm__ __volatile__(
  41033e:	48 89 29             	mov    QWORD PTR [rcx],rbp
  410341:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  410345:	48 89 cd             	mov    rbp,rcx
  410348:	49 b8 60 03 41 00 00 	movabs r8,0x410360
  41034f:	00 00 00 
  410352:	0f 05                	syscall 
  410354:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  410358:	eb 0d                	jmp    410367 <cos_comp_alloc_with+0x67>
  41035a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410360:	b9 00 00 00 00       	mov    ecx,0x0
  410365:	eb 05                	jmp    41036c <cos_comp_alloc_with+0x6c>
  410367:	b9 01 00 00 00       	mov    ecx,0x1
  41036c:	5d                   	pop    rbp
  41036d:	5c                   	pop    rsp
  41036e:	85 c0                	test   eax,eax
  410370:	0f 95 c0             	setne  al

	return 0;
}
  410373:	5b                   	pop    rbx
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_COMPACTIVATE, comp, (ctc << 16) | ptc, ((unsigned long)lid << 32) | protdom, entry)) return 1;
  410374:	0f b6 c0             	movzx  eax,al
}
  410377:	41 5c                	pop    r12
  410379:	5d                   	pop    rbp
  41037a:	c3                   	ret    
  41037b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000410380 <cos_comp_alloc>:

compcap_t
cos_comp_alloc(struct cos_compinfo *ci, captblcap_t ctc, pgtblcap_t ptc, vaddr_t entry, prot_domain_t protdom)
{
  410380:	f3 0f 1e fa          	endbr64 
  410384:	55                   	push   rbp
  410385:	48 89 e5             	mov    rbp,rsp
  410388:	41 57                	push   r15
  41038a:	41 56                	push   r14
  41038c:	41 55                	push   r13
  41038e:	41 54                	push   r12
  410390:	53                   	push   rbx
  410391:	48 83 ec 28          	sub    rsp,0x28
	return livenessid_frontier++;
  410395:	44 8b 15 24 bd 04 00 	mov    r10d,DWORD PTR [rip+0x4bd24]        # 45c0c0 <livenessid_frontier>
  41039c:	41 8d 42 01          	lea    eax,[r10+0x1]
  4103a0:	89 05 1a bd 04 00    	mov    DWORD PTR [rip+0x4bd1a],eax        # 45c0c0 <livenessid_frontier>
	capid_t cap;
	u32_t   lid = livenessid_bump_alloc();

	printd("cos_comp_alloc\n");

	assert(ci && ctc && ptc && lid);
  4103a6:	48 85 ff             	test   rdi,rdi
  4103a9:	0f 84 59 01 00 00    	je     410508 <cos_comp_alloc+0x188>
  4103af:	49 89 f7             	mov    r15,rsi
  4103b2:	48 85 f6             	test   rsi,rsi
  4103b5:	0f 84 4d 01 00 00    	je     410508 <cos_comp_alloc+0x188>
  4103bb:	49 89 d1             	mov    r9,rdx
  4103be:	48 85 d2             	test   rdx,rdx
  4103c1:	0f 84 41 01 00 00    	je     410508 <cos_comp_alloc+0x188>
  4103c7:	45 85 d2             	test   r10d,r10d
  4103ca:	49 89 cd             	mov    r13,rcx
  4103cd:	49 89 fc             	mov    r12,rdi
        __asm__ __volatile__("lock " PS_CAS_STR
  4103d0:	be 01 00 00 00       	mov    esi,0x1
  4103d5:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  4103d8:	48 8d 97 b0 00 00 00 	lea    rdx,[rdi+0xb0]
        __asm__ __volatile__("lock " PS_CAS_STR
  4103df:	31 c9                	xor    ecx,ecx
  4103e1:	84 c0                	test   al,al
  4103e3:	0f 85 1f 01 00 00    	jne    410508 <cos_comp_alloc+0x188>
  4103e9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  4103f0:	48 89 c8             	mov    rax,rcx
  4103f3:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  4103f8:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  4103fb:	84 c0                	test   al,al
  4103fd:	74 f1                	je     4103f0 <cos_comp_alloc+0x70>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  4103ff:	4d 8b 74 24 38       	mov    r14,QWORD PTR [r12+0x38]
  410404:	41 83 e6 03          	and    r14d,0x3
  410408:	0f 84 b2 00 00 00    	je     4104c0 <cos_comp_alloc+0x140>
        __asm__ __volatile__("lock " PS_FAA_STR
  41040e:	bb 04 00 00 00       	mov    ebx,0x4
  410413:	f0 49 0f c1 5c 24 38 	lock xadd QWORD PTR [r12+0x38],rbx
{ l->o = 0; }
  41041a:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  410421:	00 00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  410426:	49 89 de             	mov    r14,rbx

	cap = __capid_bump_alloc(ci, CAP_COMP);
	if (!cap) return 0;
  410429:	48 85 db             	test   rbx,rbx
  41042c:	74 5c                	je     41048a <cos_comp_alloc+0x10a>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_COMPACTIVATE, comp, (ctc << 16) | ptc, ((unsigned long)lid << 32) | protdom, entry)) return 1;
  41042e:	49 8b 44 24 08       	mov    rax,QWORD PTR [r12+0x8]
  410433:	49 c1 e7 10          	shl    r15,0x10
  410437:	4c 89 d7             	mov    rdi,r10
  41043a:	45 89 c0             	mov    r8d,r8d
  41043d:	4c 89 fe             	mov    rsi,r15
  410440:	48 c1 e7 20          	shl    rdi,0x20
  410444:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  410448:	4c 89 ea             	mov    rdx,r13
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  41044b:	c1 e0 10             	shl    eax,0x10
  41044e:	4c 09 ce             	or     rsi,r9
  410451:	4c 09 c7             	or     rdi,r8
	cap_no += op;
  410454:	05 0d 00 01 00       	add    eax,0x1000d
	__asm__ __volatile__(
  410459:	48 89 29             	mov    QWORD PTR [rcx],rbp
  41045c:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  410460:	48 89 cd             	mov    rbp,rcx
  410463:	49 b8 78 04 41 00 00 	movabs r8,0x410478
  41046a:	00 00 00 
  41046d:	0f 05                	syscall 
  41046f:	90                   	nop
  410470:	eb 0d                	jmp    41047f <cos_comp_alloc+0xff>
  410472:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410478:	b9 00 00 00 00       	mov    ecx,0x0
  41047d:	eb 05                	jmp    410484 <cos_comp_alloc+0x104>
  41047f:	b9 01 00 00 00       	mov    ecx,0x1
  410484:	5d                   	pop    rbp
  410485:	5c                   	pop    rsp
  410486:	85 c0                	test   eax,eax
  410488:	75 16                	jne    4104a0 <cos_comp_alloc+0x120>
	if (cos_comp_alloc_with(ci, cap, lid, ctc, ptc, entry, protdom)) BUG();

	return cap;
}
  41048a:	48 83 c4 28          	add    rsp,0x28
  41048e:	4c 89 f0             	mov    rax,r14
  410491:	5b                   	pop    rbx
  410492:	41 5c                	pop    r12
  410494:	41 5d                	pop    r13
  410496:	41 5e                	pop    r14
  410498:	41 5f                	pop    r15
  41049a:	5d                   	pop    rbp
  41049b:	c3                   	ret    
  41049c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  4104a0:	be 1c 00 00 00       	mov    esi,0x1c
  4104a5:	bf 68 d2 41 00       	mov    edi,0x41d268
  4104aa:	e8 21 9c ff ff       	call   40a0d0 <cos_print_str>
	if (cos_comp_alloc_with(ci, cap, lid, ctc, ptc, entry, protdom)) BUG();
  4104af:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4104b6:	00 00 00 00 
  4104ba:	0f 0b                	ud2    
  4104bc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  4104c0:	4c 89 e7             	mov    rdi,r12
  4104c3:	44 89 45 b8          	mov    DWORD PTR [rbp-0x48],r8d
  4104c7:	4c 89 4d b0          	mov    QWORD PTR [rbp-0x50],r9
  4104cb:	44 89 55 bc          	mov    DWORD PTR [rbp-0x44],r10d
  4104cf:	e8 0c c5 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  4104d4:	44 8b 55 bc          	mov    r10d,DWORD PTR [rbp-0x44]
  4104d8:	4c 8b 4d b0          	mov    r9,QWORD PTR [rbp-0x50]
  4104dc:	85 c0                	test   eax,eax
  4104de:	44 8b 45 b8          	mov    r8d,DWORD PTR [rbp-0x48]
  4104e2:	75 16                	jne    4104fa <cos_comp_alloc+0x17a>
        __asm__ __volatile__("lock " PS_FAA_STR
  4104e4:	b8 04 00 00 00       	mov    eax,0x4
  4104e9:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  4104f0:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  4104f5:	e9 14 ff ff ff       	jmp    41040e <cos_comp_alloc+0x8e>
{ l->o = 0; }
  4104fa:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  410501:	00 00 00 00 00 
	if (!cap) return 0;
  410506:	eb 82                	jmp    41048a <cos_comp_alloc+0x10a>
  410508:	be 2f 00 00 00       	mov    esi,0x2f
  41050d:	bf 38 d2 41 00       	mov    edi,0x41d238
  410512:	e8 b9 9b ff ff       	call   40a0d0 <cos_print_str>
	assert(ci && ctc && ptc && lid);
  410517:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41051e:	00 00 00 00 
  410522:	0f 0b                	ud2    
  410524:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41052b:	00 00 00 00 
  41052f:	90                   	nop

0000000000410530 <cos_comp_alloc_shared>:

int
cos_comp_alloc_shared(struct cos_compinfo *ci, pgtblcap_t ptc, vaddr_t entry, struct cos_compinfo *ci_resources, prot_domain_t protdom)
{
  410530:	f3 0f 1e fa          	endbr64 
  410534:	55                   	push   rbp
  410535:	48 89 e5             	mov    rbp,rsp
  410538:	41 57                	push   r15
  41053a:	49 89 f7             	mov    r15,rsi
  41053d:	41 56                	push   r14
  41053f:	41 55                	push   r13
  410541:	41 54                	push   r12
  410543:	53                   	push   rbx
  410544:	48 83 ec 28          	sub    rsp,0x28
	compcap_t   compc;
	captblcap_t ctc = ci->captbl_cap;
  410548:	48 8b 77 08          	mov    rsi,QWORD PTR [rdi+0x8]

	printd("cos_compinfo_alloc_shared\n");
	assert(ptc);
  41054c:	4d 85 ff             	test   r15,r15
  41054f:	0f 84 7f 01 00 00    	je     4106d4 <cos_comp_alloc_shared+0x1a4>
	assert(ctc);
  410555:	48 85 f6             	test   rsi,rsi
  410558:	0f 84 92 01 00 00    	je     4106f0 <cos_comp_alloc_shared+0x1c0>
  41055e:	49 89 d6             	mov    r14,rdx
	return livenessid_frontier++;
  410561:	8b 15 59 bb 04 00    	mov    edx,DWORD PTR [rip+0x4bb59]        # 45c0c0 <livenessid_frontier>
  410567:	49 89 cc             	mov    r12,rcx
  41056a:	8d 42 01             	lea    eax,[rdx+0x1]
  41056d:	89 05 4d bb 04 00    	mov    DWORD PTR [rip+0x4bb4d],eax        # 45c0c0 <livenessid_frontier>
	assert(ci && ctc && ptc && lid);
  410573:	48 85 c9             	test   rcx,rcx
  410576:	0f 84 3c 01 00 00    	je     4106b8 <cos_comp_alloc_shared+0x188>
  41057c:	49 89 fd             	mov    r13,rdi
{ while (!ps_cas(&l->o, 0, 1)) ; }
  41057f:	48 8d 89 b0 00 00 00 	lea    rcx,[rcx+0xb0]
        __asm__ __volatile__("lock " PS_CAS_STR
  410586:	41 ba 01 00 00 00    	mov    r10d,0x1
  41058c:	45 31 c9             	xor    r9d,r9d
  41058f:	85 d2                	test   edx,edx
  410591:	0f 84 21 01 00 00    	je     4106b8 <cos_comp_alloc_shared+0x188>
  410597:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41059e:	00 00 
  4105a0:	4c 89 c8             	mov    rax,r9
  4105a3:	f0 4c 0f b1 11       	lock cmpxchg QWORD PTR [rcx],r10
  4105a8:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  4105ab:	84 c0                	test   al,al
  4105ad:	74 f1                	je     4105a0 <cos_comp_alloc_shared+0x70>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  4105af:	41 f6 44 24 38 03    	test   BYTE PTR [r12+0x38],0x3
  4105b5:	0f 84 c5 00 00 00    	je     410680 <cos_comp_alloc_shared+0x150>
        __asm__ __volatile__("lock " PS_FAA_STR
  4105bb:	bb 04 00 00 00       	mov    ebx,0x4
  4105c0:	f0 49 0f c1 5c 24 38 	lock xadd QWORD PTR [r12+0x38],rbx
        return inc;
  4105c7:	66 48 0f 6e c3       	movq   xmm0,rbx
  4105cc:	66 49 0f 6e cf       	movq   xmm1,r15
{ l->o = 0; }
  4105d1:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  4105d8:	00 00 00 00 00 
  4105dd:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
	if (!cap) return 0;
  4105e1:	48 85 db             	test   rbx,rbx
  4105e4:	0f 84 2e 01 00 00    	je     410718 <cos_comp_alloc_shared+0x1e8>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_COMPACTIVATE, comp, (ctc << 16) | ptc, ((unsigned long)lid << 32) | protdom, entry)) return 1;
  4105ea:	49 8b 44 24 08       	mov    rax,QWORD PTR [r12+0x8]
  4105ef:	48 c1 e2 20          	shl    rdx,0x20
  4105f3:	48 c1 e6 10          	shl    rsi,0x10
  4105f7:	45 89 c0             	mov    r8d,r8d
  4105fa:	48 89 d7             	mov    rdi,rdx
  4105fd:	4c 09 fe             	or     rsi,r15
  410600:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  410604:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  410607:	c1 e0 10             	shl    eax,0x10
  41060a:	4c 09 c7             	or     rdi,r8
	cap_no += op;
  41060d:	05 0d 00 01 00       	add    eax,0x1000d
	__asm__ __volatile__(
  410612:	48 89 29             	mov    QWORD PTR [rcx],rbp
  410615:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  410619:	48 89 cd             	mov    rbp,rcx
  41061c:	49 b8 30 06 41 00 00 	movabs r8,0x410630
  410623:	00 00 00 
  410626:	0f 05                	syscall 
  410628:	eb 0d                	jmp    410637 <cos_comp_alloc_shared+0x107>
  41062a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410630:	b9 00 00 00 00       	mov    ecx,0x0
  410635:	eb 05                	jmp    41063c <cos_comp_alloc_shared+0x10c>
  410637:	b9 01 00 00 00       	mov    ecx,0x1
  41063c:	5d                   	pop    rbp
  41063d:	5c                   	pop    rsp
  41063e:	85 c0                	test   eax,eax
  410640:	75 1e                	jne    410660 <cos_comp_alloc_shared+0x130>
	compc = cos_comp_alloc(ci_resources, ctc, ptc, entry, protdom);
	assert(compc);

	ci->comp_cap_shared = compc;
  410642:	41 0f 11 85 c8 00 00 	movups XMMWORD PTR [r13+0xc8],xmm0
  410649:	00 
	ci->pgtbl_cap_shared = ptc;

	return 0;
}
  41064a:	48 83 c4 28          	add    rsp,0x28
  41064e:	31 c0                	xor    eax,eax
  410650:	5b                   	pop    rbx
  410651:	41 5c                	pop    r12
  410653:	41 5d                	pop    r13
  410655:	41 5e                	pop    r14
  410657:	41 5f                	pop    r15
  410659:	5d                   	pop    rbp
  41065a:	c3                   	ret    
  41065b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  410660:	be 1c 00 00 00       	mov    esi,0x1c
  410665:	bf 68 d2 41 00       	mov    edi,0x41d268
  41066a:	e8 61 9a ff ff       	call   40a0d0 <cos_print_str>
	if (cos_comp_alloc_with(ci, cap, lid, ctc, ptc, entry, protdom)) BUG();
  41066f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410676:	00 00 00 00 
  41067a:	0f 0b                	ud2    
  41067c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  410680:	4c 89 e7             	mov    rdi,r12
  410683:	44 89 45 b0          	mov    DWORD PTR [rbp-0x50],r8d
  410687:	89 55 b4             	mov    DWORD PTR [rbp-0x4c],edx
  41068a:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
  41068e:	e8 4d c3 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  410693:	48 8b 75 b8          	mov    rsi,QWORD PTR [rbp-0x48]
  410697:	8b 55 b4             	mov    edx,DWORD PTR [rbp-0x4c]
  41069a:	85 c0                	test   eax,eax
  41069c:	44 8b 45 b0          	mov    r8d,DWORD PTR [rbp-0x50]
  4106a0:	75 6a                	jne    41070c <cos_comp_alloc_shared+0x1dc>
        __asm__ __volatile__("lock " PS_FAA_STR
  4106a2:	b8 04 00 00 00       	mov    eax,0x4
  4106a7:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  4106ae:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  4106b3:	e9 03 ff ff ff       	jmp    4105bb <cos_comp_alloc_shared+0x8b>
  4106b8:	be 2f 00 00 00       	mov    esi,0x2f
  4106bd:	bf 38 d2 41 00       	mov    edi,0x41d238
  4106c2:	e8 09 9a ff ff       	call   40a0d0 <cos_print_str>
	assert(ci && ctc && ptc && lid);
  4106c7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4106ce:	00 00 00 00 
  4106d2:	0f 0b                	ud2    
  4106d4:	be 2f 00 00 00       	mov    esi,0x2f
  4106d9:	bf 88 d2 41 00       	mov    edi,0x41d288
  4106de:	e8 ed 99 ff ff       	call   40a0d0 <cos_print_str>
	assert(ptc);
  4106e3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4106ea:	00 00 00 00 
  4106ee:	0f 0b                	ud2    
  4106f0:	be 2f 00 00 00       	mov    esi,0x2f
  4106f5:	bf b8 d2 41 00       	mov    edi,0x41d2b8
  4106fa:	e8 d1 99 ff ff       	call   40a0d0 <cos_print_str>
	assert(ctc);
  4106ff:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410706:	00 00 00 00 
  41070a:	0f 0b                	ud2    
{ l->o = 0; }
  41070c:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  410713:	00 00 00 00 00 
  410718:	be 2f 00 00 00       	mov    esi,0x2f
  41071d:	bf e8 d2 41 00       	mov    edi,0x41d2e8
  410722:	e8 a9 99 ff ff       	call   40a0d0 <cos_print_str>
	assert(compc);
  410727:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41072e:	00 00 00 00 
  410732:	0f 0b                	ud2    
  410734:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41073b:	00 00 00 00 
  41073f:	90                   	nop

0000000000410740 <cos_compinfo_alloc>:
}

int
cos_compinfo_alloc(struct cos_compinfo *ci, vaddr_t heap_ptr, capid_t cap_frontier, vaddr_t entry,
                   struct cos_compinfo *ci_resources, prot_domain_t protdom)
{
  410740:	f3 0f 1e fa          	endbr64 
  410744:	55                   	push   rbp
	vaddr_t     last_page;
	word_t      pgtbl_lvl;
	u8_t        mem_type = PGTBL_TYPE_DEF;
	word_t      pgtbl_lvl_flag = 0;

	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  410745:	b8 01 00 00 80       	mov    eax,0x80000001
{
  41074a:	48 89 e5             	mov    rbp,rsp
  41074d:	41 57                	push   r15
  41074f:	41 56                	push   r14
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  410751:	41 be 01 00 00 00    	mov    r14d,0x1
{
  410757:	41 55                	push   r13
  410759:	49 89 fd             	mov    r13,rdi
  41075c:	41 54                	push   r12
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  41075e:	41 bc 00 00 00 00    	mov    r12d,0x0
{
  410764:	53                   	push   rbx
  410765:	4c 89 c3             	mov    rbx,r8
  410768:	48 83 ec 38          	sub    rsp,0x38
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  41076c:	80 bf d8 00 00 00 01 	cmp    BYTE PTR [rdi+0xd8],0x1
{
  410773:	48 89 55 a8          	mov    QWORD PTR [rbp-0x58],rdx
		pgtbl_lvl_flag = PGTBL_LVL_FLAG_VM;
	}

	printd("cos_compinfo_alloc\n");

	ptc = cos_pgtbl_alloc(ci_resources, mem_type);
  410777:	4c 89 c7             	mov    rdi,r8
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  41077a:	4c 0f 44 f0          	cmove  r14,rax
  41077e:	ba 02 00 00 00       	mov    edx,0x2
  410783:	48 8d 40 01          	lea    rax,[rax+0x1]
{
  410787:	48 89 75 b0          	mov    QWORD PTR [rbp-0x50],rsi
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  41078b:	48 0f 45 c2          	cmovne rax,rdx
  41078f:	40 0f 94 c6          	sete   sil
{
  410793:	48 89 4d c8          	mov    QWORD PTR [rbp-0x38],rcx
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  410797:	40 0f b6 f6          	movzx  esi,sil
{
  41079b:	44 89 4d c4          	mov    DWORD PTR [rbp-0x3c],r9d
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  41079f:	48 89 45 b8          	mov    QWORD PTR [rbp-0x48],rax
  4107a3:	b8 00 00 00 80       	mov    eax,0x80000000
  4107a8:	4c 0f 44 e0          	cmove  r12,rax
	ptc = cos_pgtbl_alloc(ci_resources, mem_type);
  4107ac:	e8 af f3 ff ff       	call   40fb60 <cos_pgtbl_alloc>
	assert(ptc);
  4107b1:	48 85 c0             	test   rax,rax
  4107b4:	0f 84 28 01 00 00    	je     4108e2 <cos_compinfo_alloc+0x1a2>
	ctc = cos_captbl_alloc(ci_resources);
  4107ba:	48 89 df             	mov    rdi,rbx
  4107bd:	49 89 c7             	mov    r15,rax
  4107c0:	e8 3b f2 ff ff       	call   40fa00 <cos_captbl_alloc>
	assert(ctc);
  4107c5:	48 85 c0             	test   rax,rax
  4107c8:	0f 84 30 01 00 00    	je     4108fe <cos_compinfo_alloc+0x1be>
	compc = cos_comp_alloc(ci_resources, ctc, ptc, entry, protdom);
  4107ce:	48 8b 4d c8          	mov    rcx,QWORD PTR [rbp-0x38]
  4107d2:	44 8b 45 c4          	mov    r8d,DWORD PTR [rbp-0x3c]
  4107d6:	4c 89 fa             	mov    rdx,r15
  4107d9:	48 89 c6             	mov    rsi,rax
  4107dc:	48 89 df             	mov    rdi,rbx
  4107df:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
  4107e3:	e8 98 fb ff ff       	call   410380 <cos_comp_alloc>
	assert(compc);
  4107e8:	4c 8b 55 c8          	mov    r10,QWORD PTR [rbp-0x38]
  4107ec:	48 85 c0             	test   rax,rax
	compc = cos_comp_alloc(ci_resources, ctc, ptc, entry, protdom);
  4107ef:	48 89 c1             	mov    rcx,rax
	assert(compc);
  4107f2:	0f 84 22 01 00 00    	je     41091a <cos_compinfo_alloc+0x1da>

	cos_compinfo_init(ci, ptc, ctc, compc, heap_ptr, cap_frontier, ci_resources);
  4107f8:	48 83 ec 08          	sub    rsp,0x8
  4107fc:	4c 8b 4d a8          	mov    r9,QWORD PTR [rbp-0x58]
  410800:	4c 89 d2             	mov    rdx,r10
  410803:	4c 89 fe             	mov    rsi,r15
  410806:	53                   	push   rbx
  410807:	48 8b 5d b0          	mov    rbx,QWORD PTR [rbp-0x50]
  41080b:	4c 89 ef             	mov    rdi,r13
  41080e:	49 89 d8             	mov    r8,rbx
  410811:	e8 0a cf ff ff       	call   40d720 <cos_compinfo_init>

	ci->mi.second_lvl_pgtbl_cap  = __bump_mem_expand_intern(__compinfo_metacap(ci), ci->pgtbl_cap, heap_ptr, 0, 0 | pgtbl_lvl_flag);
  410816:	49 8b 7d 60          	mov    rdi,QWORD PTR [r13+0x60]
  41081a:	49 8b 75 00          	mov    rsi,QWORD PTR [r13+0x0]
  41081e:	48 89 da             	mov    rdx,rbx
  410821:	31 c9                	xor    ecx,ecx
  410823:	4d 89 e0             	mov    r8,r12
  410826:	e8 75 cb ff ff       	call   40d3a0 <__bump_mem_expand_intern>
  41082b:	66 48 0f 6e cb       	movq   xmm1,rbx
  410830:	66 48 0f 6e c0       	movq   xmm0,rax

	/* 
	 * This is to make sure that "the address below vas_frontier has been allocated, 
	 * follow the assumption we put in cos_vasfrontier_init()"
	 */
	last_page = round_to_page(ci->vas_frontier - 1);
  410835:	49 8b 45 40          	mov    rax,QWORD PTR [r13+0x40]
	ci->mi.second_lvl_pgtbl_cap  = __bump_mem_expand_intern(__compinfo_metacap(ci), ci->pgtbl_cap, heap_ptr, 0, 0 | pgtbl_lvl_flag);
  410839:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
	last_page = round_to_page(ci->vas_frontier - 1);
  41083d:	48 8d 50 ff          	lea    rdx,[rax-0x1]
	ci->mi.second_lvl_pgtbl_cap  = __bump_mem_expand_intern(__compinfo_metacap(ci), ci->pgtbl_cap, heap_ptr, 0, 0 | pgtbl_lvl_flag);
  410841:	41 0f 11 85 a0 00 00 	movups XMMWORD PTR [r13+0xa0],xmm0
  410848:	00 
		return round_up_to_pgt0_page(vaddr);
  410849:	48 b8 ff ff ff ff 7f 	movabs rax,0x7fffffffff
  410850:	00 00 00 
	last_page = round_to_page(ci->vas_frontier - 1);
  410853:	48 81 e2 00 f0 ff ff 	and    rdx,0xfffffffffffff000
		return round_up_to_pgt0_page(vaddr);
  41085a:	48 01 c3             	add    rbx,rax
  41085d:	48 01 d0             	add    rax,rdx

	/* If previous page is in a different second level pagetable, need to allocate */
	if (cos_pgtbl_round_up_to_page(0, last_page) != cos_pgtbl_round_up_to_page(0, heap_ptr)) {
  410860:	48 31 c3             	xor    rbx,rax
  410863:	58                   	pop    rax
  410864:	59                   	pop    rcx
  410865:	48 b8 00 00 00 00 80 	movabs rax,0xffffff8000000000
  41086c:	ff ff ff 
  41086f:	48 85 c3             	test   rbx,rax
  410872:	75 4c                	jne    4108c0 <cos_compinfo_alloc+0x180>

	}

	/* Allocate the rest of the levels */
	for (pgtbl_lvl = 1; pgtbl_lvl < COS_PGTBL_DEPTH - 1; pgtbl_lvl++) {
		__bump_mem_expand_intern(__compinfo_metacap(ci), ptc, round_to_page(ci->vas_frontier - 1), 0, pgtbl_lvl | pgtbl_lvl_flag);	
  410874:	49 8b 7d 60          	mov    rdi,QWORD PTR [r13+0x60]
  410878:	4d 89 f0             	mov    r8,r14
  41087b:	4c 89 fe             	mov    rsi,r15
  41087e:	31 c9                	xor    ecx,ecx
  410880:	e8 1b cb ff ff       	call   40d3a0 <__bump_mem_expand_intern>
  410885:	49 8b 45 40          	mov    rax,QWORD PTR [r13+0x40]
  410889:	49 8b 7d 60          	mov    rdi,QWORD PTR [r13+0x60]
  41088d:	4c 89 fe             	mov    rsi,r15
  410890:	4c 8b 45 b8          	mov    r8,QWORD PTR [rbp-0x48]
  410894:	31 c9                	xor    ecx,ecx
  410896:	48 8d 50 ff          	lea    rdx,[rax-0x1]
  41089a:	48 81 e2 00 f0 ff ff 	and    rdx,0xfffffffffffff000
  4108a1:	e8 fa ca ff ff       	call   40d3a0 <__bump_mem_expand_intern>
	}

	return 0;
}
  4108a6:	48 8d 65 d8          	lea    rsp,[rbp-0x28]
  4108aa:	31 c0                	xor    eax,eax
  4108ac:	5b                   	pop    rbx
  4108ad:	41 5c                	pop    r12
  4108af:	41 5d                	pop    r13
  4108b1:	41 5e                	pop    r14
  4108b3:	41 5f                	pop    r15
  4108b5:	5d                   	pop    rbp
  4108b6:	c3                   	ret    
  4108b7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  4108be:	00 00 
		__bump_mem_expand_intern(__compinfo_metacap(ci), ptc, round_to_page(ci->vas_frontier - 1), 0, 0 | pgtbl_lvl_flag);
  4108c0:	49 8b 7d 60          	mov    rdi,QWORD PTR [r13+0x60]
  4108c4:	4d 89 e0             	mov    r8,r12
  4108c7:	31 c9                	xor    ecx,ecx
  4108c9:	4c 89 fe             	mov    rsi,r15
  4108cc:	e8 cf ca ff ff       	call   40d3a0 <__bump_mem_expand_intern>
		__bump_mem_expand_intern(__compinfo_metacap(ci), ptc, round_to_page(ci->vas_frontier - 1), 0, pgtbl_lvl | pgtbl_lvl_flag);	
  4108d1:	49 8b 45 40          	mov    rax,QWORD PTR [r13+0x40]
  4108d5:	48 8d 50 ff          	lea    rdx,[rax-0x1]
  4108d9:	48 81 e2 00 f0 ff ff 	and    rdx,0xfffffffffffff000
  4108e0:	eb 92                	jmp    410874 <cos_compinfo_alloc+0x134>
  4108e2:	be 2f 00 00 00       	mov    esi,0x2f
  4108e7:	bf 18 d3 41 00       	mov    edi,0x41d318
  4108ec:	e8 df 97 ff ff       	call   40a0d0 <cos_print_str>
	assert(ptc);
  4108f1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4108f8:	00 00 00 00 
  4108fc:	0f 0b                	ud2    
  4108fe:	be 2f 00 00 00       	mov    esi,0x2f
  410903:	bf 48 d3 41 00       	mov    edi,0x41d348
  410908:	e8 c3 97 ff ff       	call   40a0d0 <cos_print_str>
	assert(ctc);
  41090d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410914:	00 00 00 00 
  410918:	0f 0b                	ud2    
  41091a:	be 2f 00 00 00       	mov    esi,0x2f
  41091f:	bf 78 d3 41 00       	mov    edi,0x41d378
  410924:	e8 a7 97 ff ff       	call   40a0d0 <cos_print_str>
	assert(compc);
  410929:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410930:	00 00 00 00 
  410934:	0f 0b                	ud2    
  410936:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41093d:	00 00 00 

0000000000410940 <cos_sinv_alloc>:

sinvcap_t
cos_sinv_alloc(struct cos_compinfo *srcci, compcap_t dstcomp, vaddr_t entry, invtoken_t token)
{
  410940:	f3 0f 1e fa          	endbr64 
  410944:	55                   	push   rbp
  410945:	48 89 e5             	mov    rbp,rsp
  410948:	41 57                	push   r15
  41094a:	41 56                	push   r14
  41094c:	41 55                	push   r13
  41094e:	41 54                	push   r12
  410950:	53                   	push   rbx
  410951:	48 83 ec 28          	sub    rsp,0x28
	capid_t cap;

	printd("cos_sinv_alloc\n");

	assert(srcci && dstcomp);
  410955:	48 85 ff             	test   rdi,rdi
  410958:	0f 84 2c 01 00 00    	je     410a8a <cos_sinv_alloc+0x14a>
  41095e:	49 89 f7             	mov    r15,rsi
  410961:	48 85 f6             	test   rsi,rsi
  410964:	0f 84 20 01 00 00    	je     410a8a <cos_sinv_alloc+0x14a>
  41096a:	49 89 fc             	mov    r12,rdi
  41096d:	49 89 d5             	mov    r13,rdx
  410970:	49 89 ce             	mov    r14,rcx
	missing_captbl_node_expand(srcci);
  410973:	e8 58 d4 ff ff       	call   40ddd0 <missing_captbl_node_expand>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  410978:	49 8d 8c 24 b0 00 00 	lea    rcx,[r12+0xb0]
  41097f:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  410980:	be 01 00 00 00       	mov    esi,0x1
  410985:	31 d2                	xor    edx,edx
  410987:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41098e:	00 00 
  410990:	48 89 d0             	mov    rax,rdx
  410993:	f0 48 0f b1 31       	lock cmpxchg QWORD PTR [rcx],rsi
  410998:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  41099b:	84 c0                	test   al,al
  41099d:	74 f1                	je     410990 <cos_sinv_alloc+0x50>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  41099f:	4d 8b 54 24 38       	mov    r10,QWORD PTR [r12+0x38]
  4109a4:	41 83 e2 03          	and    r10d,0x3
  4109a8:	0f 84 82 00 00 00    	je     410a30 <cos_sinv_alloc+0xf0>
        __asm__ __volatile__("lock " PS_FAA_STR
  4109ae:	bb 04 00 00 00       	mov    ebx,0x4
  4109b3:	f0 49 0f c1 5c 24 38 	lock xadd QWORD PTR [r12+0x38],rbx
{ l->o = 0; }
  4109ba:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  4109c1:	00 00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  4109c6:	49 89 da             	mov    r10,rbx
	cap = __capid_bump_alloc(srcci, CAP_COMP);
	if (!cap) return 0;
  4109c9:	48 85 db             	test   rbx,rbx
  4109cc:	74 4c                	je     410a1a <cos_sinv_alloc+0xda>
	if (call_cap_op(srcci->captbl_cap, CAPTBL_OP_SINVACTIVATE, cap, dstcomp, entry, token)) BUG();
  4109ce:	49 8b 44 24 08       	mov    rax,QWORD PTR [r12+0x8]
  4109d3:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  4109d7:	4c 89 fe             	mov    rsi,r15
  4109da:	4c 89 ef             	mov    rdi,r13
  4109dd:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4109e0:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  4109e3:	05 0f 00 01 00       	add    eax,0x1000f
	__asm__ __volatile__(
  4109e8:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4109eb:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4109ef:	48 89 cd             	mov    rbp,rcx
  4109f2:	49 b8 08 0a 41 00 00 	movabs r8,0x410a08
  4109f9:	00 00 00 
  4109fc:	0f 05                	syscall 
  4109fe:	66 90                	xchg   ax,ax
  410a00:	eb 0d                	jmp    410a0f <cos_sinv_alloc+0xcf>
  410a02:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410a08:	b9 00 00 00 00       	mov    ecx,0x0
  410a0d:	eb 05                	jmp    410a14 <cos_sinv_alloc+0xd4>
  410a0f:	b9 01 00 00 00       	mov    ecx,0x1
  410a14:	5d                   	pop    rbp
  410a15:	5c                   	pop    rsp
  410a16:	85 c0                	test   eax,eax
  410a18:	75 46                	jne    410a60 <cos_sinv_alloc+0x120>

	return cap;
}
  410a1a:	48 83 c4 28          	add    rsp,0x28
  410a1e:	4c 89 d0             	mov    rax,r10
  410a21:	5b                   	pop    rbx
  410a22:	41 5c                	pop    r12
  410a24:	41 5d                	pop    r13
  410a26:	41 5e                	pop    r14
  410a28:	41 5f                	pop    r15
  410a2a:	5d                   	pop    rbp
  410a2b:	c3                   	ret    
  410a2c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  410a30:	4c 89 e7             	mov    rdi,r12
  410a33:	4c 89 55 b8          	mov    QWORD PTR [rbp-0x48],r10
  410a37:	e8 a4 bf ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  410a3c:	4c 8b 55 b8          	mov    r10,QWORD PTR [rbp-0x48]
  410a40:	85 c0                	test   eax,eax
  410a42:	75 38                	jne    410a7c <cos_sinv_alloc+0x13c>
        __asm__ __volatile__("lock " PS_FAA_STR
  410a44:	b8 04 00 00 00       	mov    eax,0x4
  410a49:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  410a50:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  410a55:	e9 54 ff ff ff       	jmp    4109ae <cos_sinv_alloc+0x6e>
  410a5a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410a60:	be 1c 00 00 00       	mov    esi,0x1c
  410a65:	bf d8 d3 41 00       	mov    edi,0x41d3d8
  410a6a:	e8 61 96 ff ff       	call   40a0d0 <cos_print_str>
	if (call_cap_op(srcci->captbl_cap, CAPTBL_OP_SINVACTIVATE, cap, dstcomp, entry, token)) BUG();
  410a6f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410a76:	00 00 00 00 
  410a7a:	0f 0b                	ud2    
{ l->o = 0; }
  410a7c:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  410a83:	00 00 00 00 00 
	if (!cap) return 0;
  410a88:	eb 90                	jmp    410a1a <cos_sinv_alloc+0xda>
  410a8a:	be 2f 00 00 00       	mov    esi,0x2f
  410a8f:	bf a8 d3 41 00       	mov    edi,0x41d3a8
  410a94:	e8 37 96 ff ff       	call   40a0d0 <cos_print_str>
	assert(srcci && dstcomp);
  410a99:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410aa0:	00 00 00 00 
  410aa4:	0f 0b                	ud2    
  410aa6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  410aad:	00 00 00 

0000000000410ab0 <cos_arcv_alloc>:
 * arcvcap: the rcv * endpoint that is the scheduler to be activated
 *          when the thread blocks on this endpoint.
 */
arcvcap_t
cos_arcv_alloc(struct cos_compinfo *ci, thdcap_t thdcap, tcap_t tcapcap, compcap_t compcap, arcvcap_t arcvcap)
{
  410ab0:	f3 0f 1e fa          	endbr64 
  410ab4:	55                   	push   rbp
  410ab5:	48 89 e5             	mov    rbp,rsp
  410ab8:	41 57                	push   r15
  410aba:	41 56                	push   r14
  410abc:	41 55                	push   r13
  410abe:	41 54                	push   r12
  410ac0:	53                   	push   rbx
  410ac1:	48 83 ec 28          	sub    rsp,0x28
	capid_t cap;
	int ret;

	assert(ci && thdcap && tcapcap && compcap);
  410ac5:	48 85 ff             	test   rdi,rdi
  410ac8:	0f 84 4c 01 00 00    	je     410c1a <cos_arcv_alloc+0x16a>
  410ace:	48 85 f6             	test   rsi,rsi
  410ad1:	0f 84 43 01 00 00    	je     410c1a <cos_arcv_alloc+0x16a>
  410ad7:	48 85 d2             	test   rdx,rdx
  410ada:	0f 84 3a 01 00 00    	je     410c1a <cos_arcv_alloc+0x16a>
  410ae0:	48 85 c9             	test   rcx,rcx
  410ae3:	49 89 cd             	mov    r13,rcx
  410ae6:	49 89 fc             	mov    r12,rdi
  410ae9:	4d 89 c6             	mov    r14,r8
  410aec:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  410aef:	48 8d 8f b0 00 00 00 	lea    rcx,[rdi+0xb0]
        __asm__ __volatile__("lock " PS_CAS_STR
  410af6:	41 ba 01 00 00 00    	mov    r10d,0x1
  410afc:	45 31 c9             	xor    r9d,r9d
  410aff:	84 c0                	test   al,al
  410b01:	0f 85 13 01 00 00    	jne    410c1a <cos_arcv_alloc+0x16a>
  410b07:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  410b0e:	00 00 
  410b10:	4c 89 c8             	mov    rax,r9
  410b13:	f0 4c 0f b1 11       	lock cmpxchg QWORD PTR [rcx],r10
  410b18:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  410b1b:	84 c0                	test   al,al
  410b1d:	74 f1                	je     410b10 <cos_arcv_alloc+0x60>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  410b1f:	4d 8b 7c 24 38       	mov    r15,QWORD PTR [r12+0x38]
  410b24:	41 83 e7 03          	and    r15d,0x3
  410b28:	0f 84 8a 00 00 00    	je     410bb8 <cos_arcv_alloc+0x108>
        __asm__ __volatile__("lock " PS_FAA_STR
  410b2e:	bb 04 00 00 00       	mov    ebx,0x4
  410b33:	f0 49 0f c1 5c 24 38 	lock xadd QWORD PTR [r12+0x38],rbx
{ l->o = 0; }
  410b3a:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  410b41:	00 00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  410b46:	49 89 df             	mov    r15,rbx

	printd("arcv_alloc: tcap cap %d\n", (int)tcapcap);

	cap = __capid_bump_alloc(ci, CAP_ARCV);
	if (!cap) return 0;
  410b49:	48 85 db             	test   rbx,rbx
  410b4c:	74 54                	je     410ba2 <cos_arcv_alloc+0xf2>
	if ((ret = call_cap_op(ci->captbl_cap, CAPTBL_OP_ARCVACTIVATE, cap, thdcap | (tcapcap << 16), compcap, arcvcap))) BUG();
  410b4e:	49 8b 44 24 08       	mov    rax,QWORD PTR [r12+0x8]
  410b53:	48 c1 e2 10          	shl    rdx,0x10
  410b57:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  410b5b:	4c 89 ef             	mov    rdi,r13
  410b5e:	48 09 d6             	or     rsi,rdx
  410b61:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  410b64:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  410b67:	05 15 00 01 00       	add    eax,0x10015
	__asm__ __volatile__(
  410b6c:	48 89 29             	mov    QWORD PTR [rcx],rbp
  410b6f:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  410b73:	48 89 cd             	mov    rbp,rcx
  410b76:	49 b8 90 0b 41 00 00 	movabs r8,0x410b90
  410b7d:	00 00 00 
  410b80:	0f 05                	syscall 
  410b82:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410b88:	eb 0d                	jmp    410b97 <cos_arcv_alloc+0xe7>
  410b8a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410b90:	b9 00 00 00 00       	mov    ecx,0x0
  410b95:	eb 05                	jmp    410b9c <cos_arcv_alloc+0xec>
  410b97:	b9 01 00 00 00       	mov    ecx,0x1
  410b9c:	5d                   	pop    rbp
  410b9d:	5c                   	pop    rsp
  410b9e:	85 c0                	test   eax,eax
  410ba0:	75 4e                	jne    410bf0 <cos_arcv_alloc+0x140>

	return cap;
}
  410ba2:	48 83 c4 28          	add    rsp,0x28
  410ba6:	4c 89 f8             	mov    rax,r15
  410ba9:	5b                   	pop    rbx
  410baa:	41 5c                	pop    r12
  410bac:	41 5d                	pop    r13
  410bae:	41 5e                	pop    r14
  410bb0:	41 5f                	pop    r15
  410bb2:	5d                   	pop    rbp
  410bb3:	c3                   	ret    
  410bb4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  410bb8:	4c 89 e7             	mov    rdi,r12
  410bbb:	48 89 55 b0          	mov    QWORD PTR [rbp-0x50],rdx
  410bbf:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
  410bc3:	e8 18 be ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  410bc8:	48 8b 75 b8          	mov    rsi,QWORD PTR [rbp-0x48]
  410bcc:	48 8b 55 b0          	mov    rdx,QWORD PTR [rbp-0x50]
  410bd0:	85 c0                	test   eax,eax
  410bd2:	75 38                	jne    410c0c <cos_arcv_alloc+0x15c>
        __asm__ __volatile__("lock " PS_FAA_STR
  410bd4:	b8 04 00 00 00       	mov    eax,0x4
  410bd9:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  410be0:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  410be5:	e9 44 ff ff ff       	jmp    410b2e <cos_arcv_alloc+0x7e>
  410bea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410bf0:	be 1c 00 00 00       	mov    esi,0x1c
  410bf5:	bf 28 d4 41 00       	mov    edi,0x41d428
  410bfa:	e8 d1 94 ff ff       	call   40a0d0 <cos_print_str>
	if ((ret = call_cap_op(ci->captbl_cap, CAPTBL_OP_ARCVACTIVATE, cap, thdcap | (tcapcap << 16), compcap, arcvcap))) BUG();
  410bff:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410c06:	00 00 00 00 
  410c0a:	0f 0b                	ud2    
{ l->o = 0; }
  410c0c:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  410c13:	00 00 00 00 00 
	if (!cap) return 0;
  410c18:	eb 88                	jmp    410ba2 <cos_arcv_alloc+0xf2>
  410c1a:	be 2f 00 00 00       	mov    esi,0x2f
  410c1f:	bf f8 d3 41 00       	mov    edi,0x41d3f8
  410c24:	e8 a7 94 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci && thdcap && tcapcap && compcap);
  410c29:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410c30:	00 00 00 00 
  410c34:	0f 0b                	ud2    
  410c36:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  410c3d:	00 00 00 

0000000000410c40 <cos_asnd_alloc>:

asndcap_t
cos_asnd_alloc(struct cos_compinfo *ci, arcvcap_t arcvcap, captblcap_t ctcap)
{
  410c40:	f3 0f 1e fa          	endbr64 
  410c44:	55                   	push   rbp
  410c45:	48 89 e5             	mov    rbp,rsp
  410c48:	41 57                	push   r15
  410c4a:	41 56                	push   r14
  410c4c:	49 89 d6             	mov    r14,rdx
  410c4f:	41 55                	push   r13
  410c51:	41 54                	push   r12
  410c53:	53                   	push   rbx
  410c54:	48 83 ec 18          	sub    rsp,0x18
	capid_t cap;

	assert(ci && arcvcap && ctcap);
  410c58:	48 85 f6             	test   rsi,rsi
  410c5b:	0f 94 c0             	sete   al
  410c5e:	48 85 d2             	test   rdx,rdx
  410c61:	0f 94 c2             	sete   dl
  410c64:	08 d0                	or     al,dl
  410c66:	0f 85 16 01 00 00    	jne    410d82 <cos_asnd_alloc+0x142>
  410c6c:	48 85 ff             	test   rdi,rdi
  410c6f:	49 89 fc             	mov    r12,rdi
  410c72:	49 89 f5             	mov    r13,rsi
        __asm__ __volatile__("lock " PS_CAS_STR
  410c75:	41 b8 01 00 00 00    	mov    r8d,0x1
  410c7b:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  410c7e:	48 8d 97 b0 00 00 00 	lea    rdx,[rdi+0xb0]
        __asm__ __volatile__("lock " PS_CAS_STR
  410c85:	31 c9                	xor    ecx,ecx
  410c87:	84 c0                	test   al,al
  410c89:	0f 85 f3 00 00 00    	jne    410d82 <cos_asnd_alloc+0x142>
  410c8f:	90                   	nop
  410c90:	48 89 c8             	mov    rax,rcx
  410c93:	f0 4c 0f b1 02       	lock cmpxchg QWORD PTR [rdx],r8
  410c98:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  410c9b:	84 c0                	test   al,al
  410c9d:	74 f1                	je     410c90 <cos_asnd_alloc+0x50>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  410c9f:	4d 8b 7c 24 38       	mov    r15,QWORD PTR [r12+0x38]
  410ca4:	41 83 e7 03          	and    r15d,0x3
  410ca8:	0f 84 82 00 00 00    	je     410d30 <cos_asnd_alloc+0xf0>
        __asm__ __volatile__("lock " PS_FAA_STR
  410cae:	bb 04 00 00 00       	mov    ebx,0x4
  410cb3:	f0 49 0f c1 5c 24 38 	lock xadd QWORD PTR [r12+0x38],rbx
{ l->o = 0; }
  410cba:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  410cc1:	00 00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  410cc6:	49 89 df             	mov    r15,rbx

	cap = __capid_bump_alloc(ci, CAP_ASND);
	if (!cap) return 0;
  410cc9:	48 85 db             	test   rbx,rbx
  410ccc:	74 4c                	je     410d1a <cos_asnd_alloc+0xda>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_ASNDACTIVATE, cap, ctcap, arcvcap, 0)) BUG();
  410cce:	49 8b 44 24 08       	mov    rax,QWORD PTR [r12+0x8]
  410cd3:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  410cd7:	31 d2                	xor    edx,edx
  410cd9:	4c 89 f6             	mov    rsi,r14
  410cdc:	4c 89 ef             	mov    rdi,r13
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  410cdf:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  410ce2:	05 13 00 01 00       	add    eax,0x10013
	__asm__ __volatile__(
  410ce7:	48 89 29             	mov    QWORD PTR [rcx],rbp
  410cea:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  410cee:	48 89 cd             	mov    rbp,rcx
  410cf1:	49 b8 08 0d 41 00 00 	movabs r8,0x410d08
  410cf8:	00 00 00 
  410cfb:	0f 05                	syscall 
  410cfd:	0f 1f 00             	nop    DWORD PTR [rax]
  410d00:	eb 0d                	jmp    410d0f <cos_asnd_alloc+0xcf>
  410d02:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410d08:	b9 00 00 00 00       	mov    ecx,0x0
  410d0d:	eb 05                	jmp    410d14 <cos_asnd_alloc+0xd4>
  410d0f:	b9 01 00 00 00       	mov    ecx,0x1
  410d14:	5d                   	pop    rbp
  410d15:	5c                   	pop    rsp
  410d16:	85 c0                	test   eax,eax
  410d18:	75 3e                	jne    410d58 <cos_asnd_alloc+0x118>

	return cap;
}
  410d1a:	48 83 c4 18          	add    rsp,0x18
  410d1e:	4c 89 f8             	mov    rax,r15
  410d21:	5b                   	pop    rbx
  410d22:	41 5c                	pop    r12
  410d24:	41 5d                	pop    r13
  410d26:	41 5e                	pop    r14
  410d28:	41 5f                	pop    r15
  410d2a:	5d                   	pop    rbp
  410d2b:	c3                   	ret    
  410d2c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  410d30:	4c 89 e7             	mov    rdi,r12
  410d33:	e8 a8 bc ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  410d38:	85 c0                	test   eax,eax
  410d3a:	75 38                	jne    410d74 <cos_asnd_alloc+0x134>
        __asm__ __volatile__("lock " PS_FAA_STR
  410d3c:	b8 04 00 00 00       	mov    eax,0x4
  410d41:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  410d48:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  410d4d:	e9 5c ff ff ff       	jmp    410cae <cos_asnd_alloc+0x6e>
  410d52:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410d58:	be 1c 00 00 00       	mov    esi,0x1c
  410d5d:	bf 78 d4 41 00       	mov    edi,0x41d478
  410d62:	e8 69 93 ff ff       	call   40a0d0 <cos_print_str>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_ASNDACTIVATE, cap, ctcap, arcvcap, 0)) BUG();
  410d67:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410d6e:	00 00 00 00 
  410d72:	0f 0b                	ud2    
{ l->o = 0; }
  410d74:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  410d7b:	00 00 00 00 00 
	if (!cap) return 0;
  410d80:	eb 98                	jmp    410d1a <cos_asnd_alloc+0xda>
  410d82:	be 2f 00 00 00       	mov    esi,0x2f
  410d87:	bf 48 d4 41 00       	mov    edi,0x41d448
  410d8c:	e8 3f 93 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci && arcvcap && ctcap);
  410d91:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410d98:	00 00 00 00 
  410d9c:	0f 0b                	ud2    
  410d9e:	66 90                	xchg   ax,ax

0000000000410da0 <cos_hw_alloc>:
 * TODO: bitmap must be a subset of existing one.
 *       but there is no such check now, violates access control policy.
 */
hwcap_t
cos_hw_alloc(struct cos_compinfo *ci, u32_t bitmap)
{
  410da0:	f3 0f 1e fa          	endbr64 
  410da4:	55                   	push   rbp
  410da5:	48 89 e5             	mov    rbp,rsp
  410da8:	41 56                	push   r14
  410daa:	41 55                	push   r13
  410dac:	41 54                	push   r12
  410dae:	53                   	push   rbx
  410daf:	48 83 ec 10          	sub    rsp,0x10
	capid_t cap;

	assert(ci);
  410db3:	48 85 ff             	test   rdi,rdi
  410db6:	0f 84 0e 01 00 00    	je     410eca <cos_hw_alloc+0x12a>
  410dbc:	49 89 fc             	mov    r12,rdi
  410dbf:	41 89 f6             	mov    r14d,esi
  410dc2:	48 8d 97 b0 00 00 00 	lea    rdx,[rdi+0xb0]
  410dc9:	31 c9                	xor    ecx,ecx
  410dcb:	41 b8 01 00 00 00    	mov    r8d,0x1
  410dd1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  410dd8:	48 89 c8             	mov    rax,rcx
  410ddb:	f0 4c 0f b1 02       	lock cmpxchg QWORD PTR [rdx],r8
  410de0:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  410de3:	84 c0                	test   al,al
  410de5:	74 f1                	je     410dd8 <cos_hw_alloc+0x38>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  410de7:	4d 8b 6c 24 30       	mov    r13,QWORD PTR [r12+0x30]
  410dec:	41 83 e5 03          	and    r13d,0x3
  410df0:	0f 84 82 00 00 00    	je     410e78 <cos_hw_alloc+0xd8>
        __asm__ __volatile__("lock " PS_FAA_STR
  410df6:	bb 02 00 00 00       	mov    ebx,0x2
  410dfb:	f0 49 0f c1 5c 24 30 	lock xadd QWORD PTR [r12+0x30],rbx
{ l->o = 0; }
  410e02:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  410e09:	00 00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  410e0e:	49 89 dd             	mov    r13,rbx

	cap = __capid_bump_alloc(ci, CAP_HW);
	if (!cap) return 0;
  410e11:	48 85 db             	test   rbx,rbx
  410e14:	74 4c                	je     410e62 <cos_hw_alloc+0xc2>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_HW_ACTIVATE, cap, bitmap, 0, 0)) BUG();
  410e16:	49 8b 44 24 08       	mov    rax,QWORD PTR [r12+0x8]
  410e1b:	31 d2                	xor    edx,edx
  410e1d:	44 89 f6             	mov    esi,r14d
  410e20:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  410e24:	48 89 d7             	mov    rdi,rdx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  410e27:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  410e2a:	05 2b 00 01 00       	add    eax,0x1002b
	__asm__ __volatile__(
  410e2f:	48 89 29             	mov    QWORD PTR [rcx],rbp
  410e32:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  410e36:	48 89 cd             	mov    rbp,rcx
  410e39:	49 b8 50 0e 41 00 00 	movabs r8,0x410e50
  410e40:	00 00 00 
  410e43:	0f 05                	syscall 
  410e45:	0f 1f 00             	nop    DWORD PTR [rax]
  410e48:	eb 0d                	jmp    410e57 <cos_hw_alloc+0xb7>
  410e4a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410e50:	b9 00 00 00 00       	mov    ecx,0x0
  410e55:	eb 05                	jmp    410e5c <cos_hw_alloc+0xbc>
  410e57:	b9 01 00 00 00       	mov    ecx,0x1
  410e5c:	5d                   	pop    rbp
  410e5d:	5c                   	pop    rsp
  410e5e:	85 c0                	test   eax,eax
  410e60:	75 3e                	jne    410ea0 <cos_hw_alloc+0x100>

	return cap;
}
  410e62:	48 83 c4 10          	add    rsp,0x10
  410e66:	4c 89 e8             	mov    rax,r13
  410e69:	5b                   	pop    rbx
  410e6a:	41 5c                	pop    r12
  410e6c:	41 5d                	pop    r13
  410e6e:	41 5e                	pop    r14
  410e70:	5d                   	pop    rbp
  410e71:	c3                   	ret    
  410e72:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  410e78:	4c 89 e7             	mov    rdi,r12
  410e7b:	e8 60 bb ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  410e80:	85 c0                	test   eax,eax
  410e82:	75 38                	jne    410ebc <cos_hw_alloc+0x11c>
        __asm__ __volatile__("lock " PS_FAA_STR
  410e84:	b8 04 00 00 00       	mov    eax,0x4
  410e89:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  410e90:	49 89 44 24 30       	mov    QWORD PTR [r12+0x30],rax
  410e95:	e9 5c ff ff ff       	jmp    410df6 <cos_hw_alloc+0x56>
  410e9a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410ea0:	be 1c 00 00 00       	mov    esi,0x1c
  410ea5:	bf c8 d4 41 00       	mov    edi,0x41d4c8
  410eaa:	e8 21 92 ff ff       	call   40a0d0 <cos_print_str>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_HW_ACTIVATE, cap, bitmap, 0, 0)) BUG();
  410eaf:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410eb6:	00 00 00 00 
  410eba:	0f 0b                	ud2    
{ l->o = 0; }
  410ebc:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  410ec3:	00 00 00 00 00 
	if (!cap) return 0;
  410ec8:	eb 98                	jmp    410e62 <cos_hw_alloc+0xc2>
  410eca:	be 2f 00 00 00       	mov    esi,0x2f
  410ecf:	bf 98 d4 41 00       	mov    edi,0x41d498
  410ed4:	e8 f7 91 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci);
  410ed9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410ee0:	00 00 00 00 
  410ee4:	0f 0b                	ud2    
  410ee6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  410eed:	00 00 00 

0000000000410ef0 <cos_page_bump_allocn>:

void *
cos_page_bump_allocn(struct cos_compinfo *ci, size_t sz)
{
  410ef0:	f3 0f 1e fa          	endbr64 
	assert(sz % PAGE_SIZE == 0);
  410ef4:	f7 c6 ff 0f 00 00    	test   esi,0xfff
  410efa:	75 0a                	jne    410f06 <cos_page_bump_allocn+0x16>
	return (void *)__page_bump_alloc(ci, sz, PAGE_SIZE);
  410efc:	ba 00 10 00 00       	mov    edx,0x1000
  410f01:	e9 2a c2 ff ff       	jmp    40d130 <__page_bump_alloc>
{
  410f06:	55                   	push   rbp
  410f07:	be 2f 00 00 00       	mov    esi,0x2f
  410f0c:	bf e8 d4 41 00       	mov    edi,0x41d4e8
  410f11:	48 89 e5             	mov    rbp,rsp
  410f14:	e8 b7 91 ff ff       	call   40a0d0 <cos_print_str>
	assert(sz % PAGE_SIZE == 0);
  410f19:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410f20:	00 00 00 00 
  410f24:	0f 0b                	ud2    
  410f26:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  410f2d:	00 00 00 

0000000000410f30 <cos_page_bump_allocn_aligned>:
}

void *
cos_page_bump_allocn_aligned(struct cos_compinfo *ci, size_t sz, size_t align)
{
  410f30:	f3 0f 1e fa          	endbr64 
  410f34:	55                   	push   rbp
  410f35:	48 89 e5             	mov    rbp,rsp
	assert(sz % PAGE_SIZE == 0);
  410f38:	f7 c6 ff 0f 00 00    	test   esi,0xfff
  410f3e:	75 0e                	jne    410f4e <cos_page_bump_allocn_aligned+0x1e>
	assert(align % PAGE_SIZE == 0);
  410f40:	f7 c2 ff 0f 00 00    	test   edx,0xfff
  410f46:	75 22                	jne    410f6a <cos_page_bump_allocn_aligned+0x3a>

	return (void *)__page_bump_alloc(ci, sz, align);
}
  410f48:	5d                   	pop    rbp
	return (void *)__page_bump_alloc(ci, sz, align);
  410f49:	e9 e2 c1 ff ff       	jmp    40d130 <__page_bump_alloc>
  410f4e:	be 2f 00 00 00       	mov    esi,0x2f
  410f53:	bf 18 d5 41 00       	mov    edi,0x41d518
  410f58:	e8 73 91 ff ff       	call   40a0d0 <cos_print_str>
	assert(sz % PAGE_SIZE == 0);
  410f5d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410f64:	00 00 00 00 
  410f68:	0f 0b                	ud2    
  410f6a:	be 2f 00 00 00       	mov    esi,0x2f
  410f6f:	bf 48 d5 41 00       	mov    edi,0x41d548
  410f74:	e8 57 91 ff ff       	call   40a0d0 <cos_print_str>
	assert(align % PAGE_SIZE == 0);
  410f79:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410f80:	00 00 00 00 
  410f84:	0f 0b                	ud2    
  410f86:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  410f8d:	00 00 00 

0000000000410f90 <cos_page_bump_alloc>:

void *
cos_page_bump_alloc(struct cos_compinfo *ci)
{
  410f90:	f3 0f 1e fa          	endbr64 
	return (void *)__page_bump_alloc(ci, sz, PAGE_SIZE);
  410f94:	ba 00 10 00 00       	mov    edx,0x1000
  410f99:	be 00 10 00 00       	mov    esi,0x1000
  410f9e:	e9 8d c1 ff ff       	jmp    40d130 <__page_bump_alloc>
  410fa3:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  410faa:	00 00 00 00 
  410fae:	66 90                	xchg   ax,ax

0000000000410fb0 <cos_cap_cpy>:

}

capid_t
cos_cap_cpy(struct cos_compinfo *dstci, struct cos_compinfo *srcci, cap_t srcctype, capid_t srccap)
{
  410fb0:	f3 0f 1e fa          	endbr64 
  410fb4:	55                   	push   rbp
  410fb5:	48 89 e5             	mov    rbp,rsp
  410fb8:	41 57                	push   r15
  410fba:	41 56                	push   r14
  410fbc:	41 55                	push   r13
  410fbe:	41 54                	push   r12
  410fc0:	53                   	push   rbx
  410fc1:	48 83 ec 28          	sub    rsp,0x28
	capid_t dstcap;

	assert(srcci && dstci);
  410fc5:	48 85 f6             	test   rsi,rsi
  410fc8:	0f 84 7f 01 00 00    	je     41114d <cos_cap_cpy+0x19d>
  410fce:	49 89 fc             	mov    r12,rdi
  410fd1:	48 85 ff             	test   rdi,rdi
  410fd4:	0f 84 73 01 00 00    	je     41114d <cos_cap_cpy+0x19d>
  410fda:	49 89 f6             	mov    r14,rsi
  410fdd:	48 89 cb             	mov    rbx,rcx
  410fe0:	83 fa 14             	cmp    edx,0x14
  410fe3:	0f 87 27 01 00 00    	ja     411110 <cos_cap_cpy+0x160>
  410fe9:	b8 01 00 00 00       	mov    eax,0x1
  410fee:	89 d1                	mov    ecx,edx
		frontier = &ci->cap64_frontier[cos_cpuid()];
  410ff0:	4c 8d 47 38          	lea    r8,[rdi+0x38]
		break;
  410ff4:	41 bf 04 00 00 00    	mov    r15d,0x4
  410ffa:	48 d3 e0             	shl    rax,cl
  410ffd:	a9 da 81 1f 00       	test   eax,0x1f81da
  411002:	0f 84 b0 00 00 00    	je     4110b8 <cos_cap_cpy+0x108>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  411008:	49 8d 94 24 b0 00 00 	lea    rdx,[r12+0xb0]
  41100f:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  411010:	be 01 00 00 00       	mov    esi,0x1
  411015:	31 c9                	xor    ecx,ecx
  411017:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41101e:	00 00 
  411020:	48 89 c8             	mov    rax,rcx
  411023:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  411028:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  41102b:	84 c0                	test   al,al
  41102d:	74 f1                	je     411020 <cos_cap_cpy+0x70>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  41102f:	4d 8b 28             	mov    r13,QWORD PTR [r8]
  411032:	41 83 e5 03          	and    r13d,0x3
  411036:	0f 84 9c 00 00 00    	je     4110d8 <cos_cap_cpy+0x128>
        __asm__ __volatile__("lock " PS_FAA_STR
  41103c:	4c 89 f8             	mov    rax,r15
  41103f:	f0 49 0f c1 00       	lock xadd QWORD PTR [r8],rax
{ l->o = 0; }
  411044:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  41104b:	00 00 00 00 00 
        __asm__ __volatile__("lock " PS_FAA_STR
  411050:	49 89 c5             	mov    r13,rax

	dstcap = __capid_bump_alloc(dstci, srcctype);
	if (!dstcap) return 0;
  411053:	48 85 c0             	test   rax,rax
  411056:	74 4a                	je     4110a2 <cos_cap_cpy+0xf2>

	if (call_cap_op(srcci->captbl_cap, CAPTBL_OP_CPY, srccap, dstci->captbl_cap, dstcap, 0)) BUG();
  411058:	49 8b 46 08          	mov    rax,QWORD PTR [r14+0x8]
  41105c:	49 8b 74 24 08       	mov    rsi,QWORD PTR [r12+0x8]
  411061:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  411065:	31 d2                	xor    edx,edx
  411067:	4c 89 ef             	mov    rdi,r13
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  41106a:	83 c0 01             	add    eax,0x1
  41106d:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  411070:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411073:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411077:	48 89 cd             	mov    rbp,rcx
  41107a:	49 b8 90 10 41 00 00 	movabs r8,0x411090
  411081:	00 00 00 
  411084:	0f 05                	syscall 
  411086:	66 90                	xchg   ax,ax
  411088:	eb 0d                	jmp    411097 <cos_cap_cpy+0xe7>
  41108a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411090:	b9 00 00 00 00       	mov    ecx,0x0
  411095:	eb 05                	jmp    41109c <cos_cap_cpy+0xec>
  411097:	b9 01 00 00 00       	mov    ecx,0x1
  41109c:	5d                   	pop    rbp
  41109d:	5c                   	pop    rsp
  41109e:	85 c0                	test   eax,eax
  4110a0:	75 7e                	jne    411120 <cos_cap_cpy+0x170>

	return dstcap;
}
  4110a2:	48 83 c4 28          	add    rsp,0x28
  4110a6:	4c 89 e8             	mov    rax,r13
  4110a9:	5b                   	pop    rbx
  4110aa:	41 5c                	pop    r12
  4110ac:	41 5d                	pop    r13
  4110ae:	41 5e                	pop    r14
  4110b0:	41 5f                	pop    r15
  4110b2:	5d                   	pop    rbp
  4110b3:	c3                   	ret    
  4110b4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  4110b8:	a9 24 10 00 00       	test   eax,0x1024
  4110bd:	75 41                	jne    411100 <cos_cap_cpy+0x150>
  4110bf:	f6 c4 60             	test   ah,0x60
  4110c2:	74 4c                	je     411110 <cos_cap_cpy+0x160>
		frontier = &ci->cap32_frontier[cos_cpuid()];
  4110c4:	4c 8d 47 30          	lea    r8,[rdi+0x30]
		break;
  4110c8:	41 bf 02 00 00 00    	mov    r15d,0x2
  4110ce:	e9 35 ff ff ff       	jmp    411008 <cos_cap_cpy+0x58>
  4110d3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  4110d8:	4c 89 e7             	mov    rdi,r12
  4110db:	4c 89 45 b8          	mov    QWORD PTR [rbp-0x48],r8
  4110df:	e8 fc b8 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  4110e4:	4c 8b 45 b8          	mov    r8,QWORD PTR [rbp-0x48]
  4110e8:	85 c0                	test   eax,eax
  4110ea:	75 50                	jne    41113c <cos_cap_cpy+0x18c>
  4110ec:	b8 04 00 00 00       	mov    eax,0x4
  4110f1:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  4110f8:	49 89 00             	mov    QWORD PTR [r8],rax
  4110fb:	e9 3c ff ff ff       	jmp    41103c <cos_cap_cpy+0x8c>
		frontier = &ci->cap16_frontier[cos_cpuid()];
  411100:	4c 8d 47 28          	lea    r8,[rdi+0x28]
		break;
  411104:	41 bf 01 00 00 00    	mov    r15d,0x1
  41110a:	e9 f9 fe ff ff       	jmp    411008 <cos_cap_cpy+0x58>
  41110f:	90                   	nop
  411110:	49 c7 c5 ff ff ff ff 	mov    r13,0xffffffffffffffff
  411117:	e9 3c ff ff ff       	jmp    411058 <cos_cap_cpy+0xa8>
  41111c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  411120:	be 1c 00 00 00       	mov    esi,0x1c
  411125:	bf a8 d5 41 00       	mov    edi,0x41d5a8
  41112a:	e8 a1 8f ff ff       	call   40a0d0 <cos_print_str>
	if (call_cap_op(srcci->captbl_cap, CAPTBL_OP_CPY, srccap, dstci->captbl_cap, dstcap, 0)) BUG();
  41112f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411136:	00 00 00 00 
  41113a:	0f 0b                	ud2    
{ l->o = 0; }
  41113c:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  411143:	00 00 00 00 00 
	if (!dstcap) return 0;
  411148:	e9 55 ff ff ff       	jmp    4110a2 <cos_cap_cpy+0xf2>
  41114d:	be 2f 00 00 00       	mov    esi,0x2f
  411152:	bf 78 d5 41 00       	mov    edi,0x41d578
  411157:	e8 74 8f ff ff       	call   40a0d0 <cos_print_str>
	assert(srcci && dstci);
  41115c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411163:	00 00 00 00 
  411167:	0f 0b                	ud2    
  411169:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000411170 <cos_cap_cpy_at>:

int
cos_cap_cpy_at(struct cos_compinfo *dstci, capid_t dstcap, struct cos_compinfo *srcci, capid_t srccap)
{
  411170:	f3 0f 1e fa          	endbr64 
  411174:	55                   	push   rbp
  411175:	48 89 e5             	mov    rbp,rsp
  411178:	41 54                	push   r12
  41117a:	53                   	push   rbx
  41117b:	48 83 ec 10          	sub    rsp,0x10
	assert(srcci && dstci);
  41117f:	48 85 d2             	test   rdx,rdx
  411182:	0f 84 84 00 00 00    	je     41120c <cos_cap_cpy_at+0x9c>
  411188:	49 89 f8             	mov    r8,rdi
  41118b:	48 85 ff             	test   rdi,rdi
  41118e:	74 7c                	je     41120c <cos_cap_cpy_at+0x9c>
  411190:	48 89 f7             	mov    rdi,rsi

	if (!dstcap) return 0;
  411193:	48 85 f6             	test   rsi,rsi
  411196:	74 4a                	je     4111e2 <cos_cap_cpy_at+0x72>

	if (call_cap_op(srcci->captbl_cap, CAPTBL_OP_CPY, srccap, dstci->captbl_cap, dstcap, 0)) BUG();
  411198:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  41119c:	48 89 cb             	mov    rbx,rcx
  41119f:	49 8b 70 08          	mov    rsi,QWORD PTR [r8+0x8]
  4111a3:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  4111a7:	31 d2                	xor    edx,edx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4111a9:	83 c0 01             	add    eax,0x1
  4111ac:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  4111af:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4111b2:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4111b6:	48 89 cd             	mov    rbp,rcx
  4111b9:	49 b8 d0 11 41 00 00 	movabs r8,0x4111d0
  4111c0:	00 00 00 
  4111c3:	0f 05                	syscall 
  4111c5:	0f 1f 00             	nop    DWORD PTR [rax]
  4111c8:	eb 0d                	jmp    4111d7 <cos_cap_cpy_at+0x67>
  4111ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4111d0:	b9 00 00 00 00       	mov    ecx,0x0
  4111d5:	eb 05                	jmp    4111dc <cos_cap_cpy_at+0x6c>
  4111d7:	b9 01 00 00 00       	mov    ecx,0x1
  4111dc:	5d                   	pop    rbp
  4111dd:	5c                   	pop    rsp
  4111de:	85 c0                	test   eax,eax
  4111e0:	75 0e                	jne    4111f0 <cos_cap_cpy_at+0x80>

	return 0;
}
  4111e2:	48 83 c4 10          	add    rsp,0x10
  4111e6:	31 c0                	xor    eax,eax
  4111e8:	5b                   	pop    rbx
  4111e9:	41 5c                	pop    r12
  4111eb:	5d                   	pop    rbp
  4111ec:	c3                   	ret    
  4111ed:	0f 1f 00             	nop    DWORD PTR [rax]
  4111f0:	be 1c 00 00 00       	mov    esi,0x1c
  4111f5:	bf f8 d5 41 00       	mov    edi,0x41d5f8
  4111fa:	e8 d1 8e ff ff       	call   40a0d0 <cos_print_str>
	if (call_cap_op(srcci->captbl_cap, CAPTBL_OP_CPY, srccap, dstci->captbl_cap, dstcap, 0)) BUG();
  4111ff:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411206:	00 00 00 00 
  41120a:	0f 0b                	ud2    
  41120c:	be 2f 00 00 00       	mov    esi,0x2f
  411211:	bf c8 d5 41 00       	mov    edi,0x41d5c8
  411216:	e8 b5 8e ff ff       	call   40a0d0 <cos_print_str>
	assert(srcci && dstci);
  41121b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411222:	00 00 00 00 
  411226:	0f 0b                	ud2    
  411228:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41122f:	00 

0000000000411230 <cos_thd_switch>:

/**************** [Kernel Object Operations] ****************/

int
cos_thd_switch(thdcap_t c)
{
  411230:	f3 0f 1e fa          	endbr64 
  411234:	55                   	push   rbp
  411235:	31 d2                	xor    edx,edx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411237:	8d 47 01             	lea    eax,[rdi+0x1]
  41123a:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  41123d:	48 89 d6             	mov    rsi,rdx
  411240:	48 89 d7             	mov    rdi,rdx
  411243:	48 89 e5             	mov    rbp,rsp
  411246:	41 54                	push   r12
  411248:	53                   	push   rbx
  411249:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  41124d:	48 89 d3             	mov    rbx,rdx
  411250:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411253:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411257:	48 89 cd             	mov    rbp,rcx
  41125a:	49 b8 70 12 41 00 00 	movabs r8,0x411270
  411261:	00 00 00 
  411264:	0f 05                	syscall 
  411266:	66 90                	xchg   ax,ax
  411268:	eb 0d                	jmp    411277 <cos_thd_switch+0x47>
  41126a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411270:	b9 00 00 00 00       	mov    ecx,0x0
  411275:	eb 05                	jmp    41127c <cos_thd_switch+0x4c>
  411277:	b9 01 00 00 00       	mov    ecx,0x1
  41127c:	5d                   	pop    rbp
  41127d:	5c                   	pop    rsp
	return call_cap_op(c, 0, 0, 0, 0, 0);
}
  41127e:	5b                   	pop    rbx
  41127f:	41 5c                	pop    r12
  411281:	5d                   	pop    rbp
  411282:	c3                   	ret    
  411283:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41128a:	00 00 00 00 
  41128e:	66 90                	xchg   ax,ax

0000000000411290 <cos_thd_wakeup>:

int
cos_thd_wakeup(thdcap_t thd, tcap_t tc, tcap_prio_t prio, tcap_res_t res)
{
  411290:	f3 0f 1e fa          	endbr64 
  411294:	55                   	push   rbp
  411295:	49 89 fa             	mov    r10,rdi
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411298:	c1 e6 10             	shl    esi,0x10
  41129b:	48 89 d7             	mov    rdi,rdx
	cap_no += op;
  41129e:	8d 86 2a 00 01 00    	lea    eax,[rsi+0x1002a]
	return call_cap_op(tc, CAPTBL_OP_TCAP_WAKEUP, thd, (prio << 32) >> 32, prio >> 32, res);
  4112a4:	48 c1 ef 20          	shr    rdi,0x20
  4112a8:	89 d6                	mov    esi,edx
{
  4112aa:	48 89 e5             	mov    rbp,rsp
  4112ad:	41 55                	push   r13
  4112af:	49 89 cd             	mov    r13,rcx
  4112b2:	41 54                	push   r12
	__asm__ __volatile__(
  4112b4:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  4112b8:	4c 89 ea             	mov    rdx,r13
  4112bb:	53                   	push   rbx
  4112bc:	4c 89 d3             	mov    rbx,r10
  4112bf:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4112c2:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4112c6:	48 89 cd             	mov    rbp,rcx
  4112c9:	49 b8 e0 12 41 00 00 	movabs r8,0x4112e0
  4112d0:	00 00 00 
  4112d3:	0f 05                	syscall 
  4112d5:	0f 1f 00             	nop    DWORD PTR [rax]
  4112d8:	eb 0d                	jmp    4112e7 <cos_thd_wakeup+0x57>
  4112da:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4112e0:	b9 00 00 00 00       	mov    ecx,0x0
  4112e5:	eb 05                	jmp    4112ec <cos_thd_wakeup+0x5c>
  4112e7:	b9 01 00 00 00       	mov    ecx,0x1
  4112ec:	5d                   	pop    rbp
  4112ed:	5c                   	pop    rsp
}
  4112ee:	5b                   	pop    rbx
  4112ef:	41 5c                	pop    r12
  4112f1:	41 5d                	pop    r13
  4112f3:	5d                   	pop    rbp
  4112f4:	c3                   	ret    
  4112f5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4112fc:	00 00 00 00 

0000000000411300 <cos_sched_sync>:

sched_tok_t
cos_sched_sync(void)
{
  411300:	f3 0f 1e fa          	endbr64 
        __asm__ __volatile__("lock " PS_FAA_STR
  411304:	b8 01 00 00 00       	mov    eax,0x1
  411309:	f0 48 0f c1 05 6e f7 	lock xadd QWORD PTR [rip+0x18f76e],rax        # 5a0a80 <stok.1>
  411310:	18 00 
	static sched_tok_t stok[NUM_CPU] CACHE_ALIGNED;

	return ps_faa((unsigned long *)&stok[cos_cpuid()], 1);
}
  411312:	c3                   	ret    
  411313:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41131a:	00 00 00 00 
  41131e:	66 90                	xchg   ax,ax

0000000000411320 <cos_switch>:

int
cos_switch(thdcap_t c, tcap_t tc, tcap_prio_t prio, tcap_time_t timeout, arcvcap_t rcv, sched_tok_t stok)
{
  411320:	f3 0f 1e fa          	endbr64 
  411324:	55                   	push   rbp
  411325:	49 89 fa             	mov    r10,rdi
  411328:	49 89 f3             	mov    r11,rsi
  41132b:	4c 89 c7             	mov    rdi,r8
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  41132e:	41 83 c2 01          	add    r10d,0x1
  411332:	48 89 d6             	mov    rsi,rdx
  411335:	48 89 ca             	mov    rdx,rcx
  411338:	41 c1 e2 10          	shl    r10d,0x10
  41133c:	48 89 e5             	mov    rbp,rsp
  41133f:	41 54                	push   r12
	cap_no += op;
  411341:	43 8d 04 1a          	lea    eax,[r10+r11*1]
  411345:	53                   	push   rbx
	__asm__ __volatile__(
  411346:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
#if defined(__x86_64__)
	return call_cap_op(c, tc, stok, prio, rcv, timeout);
  41134a:	44 89 cb             	mov    ebx,r9d
  41134d:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411350:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411354:	48 89 cd             	mov    rbp,rcx
  411357:	49 b8 70 13 41 00 00 	movabs r8,0x411370
  41135e:	00 00 00 
  411361:	0f 05                	syscall 
  411363:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  411368:	eb 0d                	jmp    411377 <cos_switch+0x57>
  41136a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411370:	b9 00 00 00 00       	mov    ecx,0x0
  411375:	eb 05                	jmp    41137c <cos_switch+0x5c>
  411377:	b9 01 00 00 00       	mov    ecx,0x1
  41137c:	5d                   	pop    rbp
  41137d:	5c                   	pop    rsp
#else
	return call_cap_op(c, (stok >> 16), tc << 16 | rcv, (prio << 32) >> 32,
	                   (((prio << 16) >> 48) << 16) | ((stok << 16) >> 16), timeout);
#endif
}
  41137e:	5b                   	pop    rbx
  41137f:	41 5c                	pop    r12
  411381:	5d                   	pop    rbp
  411382:	c3                   	ret    
  411383:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41138a:	00 00 00 00 
  41138e:	66 90                	xchg   ax,ax

0000000000411390 <cos_sched_asnd>:

int
cos_sched_asnd(asndcap_t snd, tcap_time_t timeout, arcvcap_t srcv, sched_tok_t stok)
{
  411390:	f3 0f 1e fa          	endbr64 
  411394:	55                   	push   rbp
  411395:	49 89 d2             	mov    r10,rdx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411398:	8d 47 01             	lea    eax,[rdi+0x1]
	__asm__ __volatile__(
  41139b:	31 d2                	xor    edx,edx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  41139d:	c1 e0 10             	shl    eax,0x10
  4113a0:	48 89 e5             	mov    rbp,rsp
  4113a3:	41 55                	push   r13
  4113a5:	49 89 f5             	mov    r13,rsi
	return call_cap_op(snd, 0, srcv, stok, timeout, 0);
  4113a8:	89 ce                	mov    esi,ecx
{
  4113aa:	41 54                	push   r12
	__asm__ __volatile__(
  4113ac:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  4113b0:	4c 89 ef             	mov    rdi,r13
  4113b3:	53                   	push   rbx
  4113b4:	4c 89 d3             	mov    rbx,r10
  4113b7:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4113ba:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4113be:	48 89 cd             	mov    rbp,rcx
  4113c1:	49 b8 d8 13 41 00 00 	movabs r8,0x4113d8
  4113c8:	00 00 00 
  4113cb:	0f 05                	syscall 
  4113cd:	0f 1f 00             	nop    DWORD PTR [rax]
  4113d0:	eb 0d                	jmp    4113df <cos_sched_asnd+0x4f>
  4113d2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4113d8:	b9 00 00 00 00       	mov    ecx,0x0
  4113dd:	eb 05                	jmp    4113e4 <cos_sched_asnd+0x54>
  4113df:	b9 01 00 00 00       	mov    ecx,0x1
  4113e4:	5d                   	pop    rbp
  4113e5:	5c                   	pop    rsp
}
  4113e6:	5b                   	pop    rbx
  4113e7:	41 5c                	pop    r12
  4113e9:	41 5d                	pop    r13
  4113eb:	5d                   	pop    rbp
  4113ec:	c3                   	ret    
  4113ed:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004113f0 <cos_asnd>:

int
cos_asnd(asndcap_t snd, int yield)
{
  4113f0:	f3 0f 1e fa          	endbr64 
  4113f4:	55                   	push   rbp
  4113f5:	48 63 d6             	movsxd rdx,esi
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4113f8:	8d 47 01             	lea    eax,[rdi+0x1]
	__asm__ __volatile__(
  4113fb:	31 f6                	xor    esi,esi
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4113fd:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  411400:	48 89 f7             	mov    rdi,rsi
  411403:	48 89 e5             	mov    rbp,rsp
  411406:	41 54                	push   r12
  411408:	53                   	push   rbx
  411409:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  41140d:	48 89 f3             	mov    rbx,rsi
  411410:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411413:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411417:	48 89 cd             	mov    rbp,rcx
  41141a:	49 b8 30 14 41 00 00 	movabs r8,0x411430
  411421:	00 00 00 
  411424:	0f 05                	syscall 
  411426:	66 90                	xchg   ax,ax
  411428:	eb 0d                	jmp    411437 <cos_asnd+0x47>
  41142a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411430:	b9 00 00 00 00       	mov    ecx,0x0
  411435:	eb 05                	jmp    41143c <cos_asnd+0x4c>
  411437:	b9 01 00 00 00       	mov    ecx,0x1
  41143c:	5d                   	pop    rbp
  41143d:	5c                   	pop    rsp
	return call_cap_op(snd, 0, 0, 0, 0, yield);
}
  41143e:	5b                   	pop    rbx
  41143f:	41 5c                	pop    r12
  411441:	5d                   	pop    rbp
  411442:	c3                   	ret    
  411443:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41144a:	00 00 00 00 
  41144e:	66 90                	xchg   ax,ax

0000000000411450 <cos_sched_rcv>:

int
cos_sched_rcv(arcvcap_t rcv, rcv_flags_t flags, tcap_time_t timeout,
	      int *rcvd, thdid_t *thdid, int *blocked, cycles_t *cycles, tcap_time_t *thd_timeout)
{
  411450:	f3 0f 1e fa          	endbr64 
  411454:	55                   	push   rbp
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411455:	8d 47 01             	lea    eax,[rdi+0x1]
	__asm__ __volatile__(
  411458:	31 ff                	xor    edi,edi
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  41145a:	c1 e0 10             	shl    eax,0x10
  41145d:	48 89 e5             	mov    rbp,rsp
  411460:	41 57                	push   r15
  411462:	49 89 cf             	mov    r15,rcx
  411465:	41 56                	push   r14
	__asm__ __volatile__(
  411467:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  41146b:	4d 89 c6             	mov    r14,r8
  41146e:	41 55                	push   r13
  411470:	4d 89 cd             	mov    r13,r9
  411473:	41 54                	push   r12
  411475:	53                   	push   rbx
  411476:	89 f3                	mov    ebx,esi
  411478:	48 89 d6             	mov    rsi,rdx
  41147b:	48 89 fa             	mov    rdx,rdi
  41147e:	49 89 da             	mov    r10,rbx
  411481:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411484:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411488:	48 89 cd             	mov    rbp,rcx
  41148b:	49 b8 a0 14 41 00 00 	movabs r8,0x4114a0
  411492:	00 00 00 
  411495:	0f 05                	syscall 
  411497:	90                   	nop
  411498:	eb 0f                	jmp    4114a9 <cos_sched_rcv+0x59>
  41149a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4114a0:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  4114a7:	eb 07                	jmp    4114b0 <cos_sched_rcv+0x60>
  4114a9:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  4114b0:	5d                   	pop    rbp
  4114b1:	5c                   	pop    rsp
  4114b2:	48 8b 55 18          	mov    rdx,QWORD PTR [rbp+0x18]
  4114b6:	48 89 1a             	mov    QWORD PTR [rdx],rbx
	unsigned long cyc       = 0;
	int           ret;

	ret = call_cap_retvals_asm(rcv, 0, flags, timeout, 0, 0, &thd_state, &cyc, thd_timeout);

	*blocked = (int)(thd_state >> (sizeof(thd_state) * 8 - 1));
  4114b9:	48 89 f2             	mov    rdx,rsi
	*thdid   = (thdid_t)(thd_state & ((1 << (sizeof(unsigned short int) * 8)) - 1));
  4114bc:	81 e6 ff ff 00 00    	and    esi,0xffff
	*blocked = (int)(thd_state >> (sizeof(thd_state) * 8 - 1));
  4114c2:	48 c1 ea 3f          	shr    rdx,0x3f
  4114c6:	41 89 55 00          	mov    DWORD PTR [r13+0x0],edx
	*cycles  = cyc;
  4114ca:	48 8b 55 10          	mov    rdx,QWORD PTR [rbp+0x10]
	*thdid   = (thdid_t)(thd_state & ((1 << (sizeof(unsigned short int) * 8)) - 1));
  4114ce:	49 89 36             	mov    QWORD PTR [r14],rsi
	*cycles  = cyc;
  4114d1:	48 89 3a             	mov    QWORD PTR [rdx],rdi

	if (ret >= 0 && flags & RCV_ALL_PENDING) {
  4114d4:	85 c0                	test   eax,eax
  4114d6:	78 10                	js     4114e8 <cos_sched_rcv+0x98>
  4114d8:	41 83 e2 02          	and    r10d,0x2
  4114dc:	74 0a                	je     4114e8 <cos_sched_rcv+0x98>
		*rcvd = (ret >> 1);
  4114de:	89 c2                	mov    edx,eax
		ret &= 1;
  4114e0:	83 e0 01             	and    eax,0x1
		*rcvd = (ret >> 1);
  4114e3:	d1 fa                	sar    edx,1
  4114e5:	41 89 17             	mov    DWORD PTR [r15],edx
	}

	return ret;
}
  4114e8:	5b                   	pop    rbx
  4114e9:	41 5c                	pop    r12
  4114eb:	41 5d                	pop    r13
  4114ed:	41 5e                	pop    r14
  4114ef:	41 5f                	pop    r15
  4114f1:	5d                   	pop    rbp
  4114f2:	c3                   	ret    
  4114f3:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4114fa:	00 00 00 00 
  4114fe:	66 90                	xchg   ax,ax

0000000000411500 <cos_rcv>:

int
cos_rcv(arcvcap_t rcv, rcv_flags_t flags, int *rcvd)
{
  411500:	f3 0f 1e fa          	endbr64 
  411504:	55                   	push   rbp
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411505:	8d 47 01             	lea    eax,[rdi+0x1]
	__asm__ __volatile__(
  411508:	31 ff                	xor    edi,edi
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  41150a:	c1 e0 10             	shl    eax,0x10
  41150d:	48 89 e5             	mov    rbp,rsp
  411510:	41 55                	push   r13
  411512:	49 89 d5             	mov    r13,rdx
	__asm__ __volatile__(
  411515:	48 89 fa             	mov    rdx,rdi
  411518:	41 54                	push   r12
  41151a:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  41151e:	53                   	push   rbx
  41151f:	89 f3                	mov    ebx,esi
  411521:	48 89 fe             	mov    rsi,rdi
  411524:	49 89 da             	mov    r10,rbx
  411527:	48 83 ec 18          	sub    rsp,0x18
  41152b:	48 89 29             	mov    QWORD PTR [rcx],rbp
  41152e:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411532:	48 89 cd             	mov    rbp,rcx
  411535:	49 b8 50 15 41 00 00 	movabs r8,0x411550
  41153c:	00 00 00 
  41153f:	0f 05                	syscall 
  411541:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  411548:	eb 0f                	jmp    411559 <cos_rcv+0x59>
  41154a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411550:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  411557:	eb 07                	jmp    411560 <cos_rcv+0x60>
  411559:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  411560:	5d                   	pop    rbp
  411561:	5c                   	pop    rsp
	*thdid   = (thdid_t)(thd_state & ((1 << (sizeof(unsigned short int) * 8)) - 1));
  411562:	0f b7 f6             	movzx  esi,si
	if (ret >= 0 && flags & RCV_ALL_PENDING) {
  411565:	85 c0                	test   eax,eax
  411567:	78 06                	js     41156f <cos_rcv+0x6f>
  411569:	41 83 e2 02          	and    r10d,0x2
  41156d:	75 11                	jne    411580 <cos_rcv+0x80>
	cycles_t    cyc;
	int         ret;
	tcap_time_t thd_timeout;

	ret = cos_sched_rcv(rcv, flags, 0, rcvd, &tid, &blocked, &cyc, &thd_timeout);
	assert(tid == 0);
  41156f:	48 85 f6             	test   rsi,rsi
  411572:	75 1c                	jne    411590 <cos_rcv+0x90>

	return ret;
}
  411574:	48 83 c4 18          	add    rsp,0x18
  411578:	5b                   	pop    rbx
  411579:	41 5c                	pop    r12
  41157b:	41 5d                	pop    r13
  41157d:	5d                   	pop    rbp
  41157e:	c3                   	ret    
  41157f:	90                   	nop
		*rcvd = (ret >> 1);
  411580:	89 c2                	mov    edx,eax
		ret &= 1;
  411582:	83 e0 01             	and    eax,0x1
		*rcvd = (ret >> 1);
  411585:	d1 fa                	sar    edx,1
  411587:	41 89 55 00          	mov    DWORD PTR [r13+0x0],edx
	assert(tid == 0);
  41158b:	48 85 f6             	test   rsi,rsi
  41158e:	74 e4                	je     411574 <cos_rcv+0x74>
  411590:	be 2f 00 00 00       	mov    esi,0x2f
  411595:	bf 18 d6 41 00       	mov    edi,0x41d618
  41159a:	e8 31 8b ff ff       	call   40a0d0 <cos_print_str>
  41159f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4115a6:	00 00 00 00 
  4115aa:	0f 0b                	ud2    
  4115ac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

00000000004115b0 <cos_mem_aliasn_aligned>:

vaddr_t
cos_mem_aliasn_aligned(struct cos_compinfo *dstci, struct cos_compinfo *srcci, vaddr_t src, size_t sz, size_t align, unsigned long perm_flags)
{
  4115b0:	f3 0f 1e fa          	endbr64 
  4115b4:	55                   	push   rbp
  4115b5:	48 89 e5             	mov    rbp,rsp
  4115b8:	41 57                	push   r15
  4115ba:	41 56                	push   r14
  4115bc:	41 55                	push   r13
  4115be:	41 54                	push   r12
  4115c0:	53                   	push   rbx
  4115c1:	48 83 ec 28          	sub    rsp,0x28
  4115c5:	48 89 55 b0          	mov    QWORD PTR [rbp-0x50],rdx
  4115c9:	48 89 4d b8          	mov    QWORD PTR [rbp-0x48],rcx
	size_t i;
	vaddr_t dst, first_dst;

	assert(srcci && dstci);
  4115cd:	48 85 f6             	test   rsi,rsi
  4115d0:	0f 84 f3 00 00 00    	je     4116c9 <cos_mem_aliasn_aligned+0x119>
  4115d6:	49 89 fd             	mov    r13,rdi
  4115d9:	48 85 ff             	test   rdi,rdi
  4115dc:	0f 84 e7 00 00 00    	je     4116c9 <cos_mem_aliasn_aligned+0x119>
	assert(sz && (sz % PAGE_SIZE == 0));
  4115e2:	48 85 c9             	test   rcx,rcx
  4115e5:	0f 84 c2 00 00 00    	je     4116ad <cos_mem_aliasn_aligned+0xfd>
  4115eb:	f7 c1 ff 0f 00 00    	test   ecx,0xfff
  4115f1:	0f 85 b6 00 00 00    	jne    4116ad <cos_mem_aliasn_aligned+0xfd>
  4115f7:	4c 89 c2             	mov    rdx,r8
	assert(align % PAGE_SIZE == 0);
  4115fa:	41 f7 c0 ff 0f 00 00 	test   r8d,0xfff
  411601:	0f 85 de 00 00 00    	jne    4116e5 <cos_mem_aliasn_aligned+0x135>
  411607:	49 89 f6             	mov    r14,rsi
  41160a:	48 89 ce             	mov    rsi,rcx
  41160d:	4c 89 cb             	mov    rbx,r9

	dst = __page_bump_valloc(dstci, sz, align);
  411610:	e8 0b b9 ff ff       	call   40cf20 <__page_bump_valloc>
  411615:	49 89 c7             	mov    r15,rax
	if (unlikely(!dst)) return 0;
  411618:	48 85 c0             	test   rax,rax
  41161b:	0f 84 87 00 00 00    	je     4116a8 <cos_mem_aliasn_aligned+0xf8>
	first_dst = dst;

	for (i = 0; i < sz; i += PAGE_SIZE, src += PAGE_SIZE, dst += PAGE_SIZE) {
  411621:	45 31 d2             	xor    r10d,r10d
  411624:	48 89 da             	mov    rdx,rbx
  411627:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41162e:	00 00 
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411630:	41 8b 06             	mov    eax,DWORD PTR [r14]
	__asm__ __volatile__(
  411633:	48 8b 5d b0          	mov    rbx,QWORD PTR [rbp-0x50]
  411637:	4b 8d 3c 3a          	lea    rdi,[r10+r15*1]
  41163b:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  41163f:	49 8b 75 00          	mov    rsi,QWORD PTR [r13+0x0]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411643:	83 c0 01             	add    eax,0x1
	__asm__ __volatile__(
  411646:	4c 01 d3             	add    rbx,r10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411649:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  41164c:	48 89 29             	mov    QWORD PTR [rcx],rbp
  41164f:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411653:	48 89 cd             	mov    rbp,rcx
  411656:	49 b8 70 16 41 00 00 	movabs r8,0x411670
  41165d:	00 00 00 
  411660:	0f 05                	syscall 
  411662:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411668:	eb 0d                	jmp    411677 <cos_mem_aliasn_aligned+0xc7>
  41166a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411670:	b9 00 00 00 00       	mov    ecx,0x0
  411675:	eb 05                	jmp    41167c <cos_mem_aliasn_aligned+0xcc>
  411677:	b9 01 00 00 00       	mov    ecx,0x1
  41167c:	5d                   	pop    rbp
  41167d:	5c                   	pop    rsp
		if (call_cap_op(srcci->pgtbl_cap, CAPTBL_OP_CPY, src, dstci->pgtbl_cap, dst, perm_flags)) return 0;
  41167e:	85 c0                	test   eax,eax
  411680:	75 26                	jne    4116a8 <cos_mem_aliasn_aligned+0xf8>
	for (i = 0; i < sz; i += PAGE_SIZE, src += PAGE_SIZE, dst += PAGE_SIZE) {
  411682:	49 81 c2 00 10 00 00 	add    r10,0x1000
  411689:	4c 39 55 b8          	cmp    QWORD PTR [rbp-0x48],r10
  41168d:	77 a1                	ja     411630 <cos_mem_aliasn_aligned+0x80>
	}

	return first_dst;
}
  41168f:	48 83 c4 28          	add    rsp,0x28
  411693:	4c 89 f8             	mov    rax,r15
  411696:	5b                   	pop    rbx
  411697:	41 5c                	pop    r12
  411699:	41 5d                	pop    r13
  41169b:	41 5e                	pop    r14
  41169d:	41 5f                	pop    r15
  41169f:	5d                   	pop    rbp
  4116a0:	c3                   	ret    
  4116a1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	if (unlikely(!dst)) return 0;
  4116a8:	45 31 ff             	xor    r15d,r15d
  4116ab:	eb e2                	jmp    41168f <cos_mem_aliasn_aligned+0xdf>
  4116ad:	be 2f 00 00 00       	mov    esi,0x2f
  4116b2:	bf 78 d6 41 00       	mov    edi,0x41d678
  4116b7:	e8 14 8a ff ff       	call   40a0d0 <cos_print_str>
	assert(sz && (sz % PAGE_SIZE == 0));
  4116bc:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4116c3:	00 00 00 00 
  4116c7:	0f 0b                	ud2    
  4116c9:	be 2f 00 00 00       	mov    esi,0x2f
  4116ce:	bf 48 d6 41 00       	mov    edi,0x41d648
  4116d3:	e8 f8 89 ff ff       	call   40a0d0 <cos_print_str>
	assert(srcci && dstci);
  4116d8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4116df:	00 00 00 00 
  4116e3:	0f 0b                	ud2    
  4116e5:	be 2f 00 00 00       	mov    esi,0x2f
  4116ea:	bf a8 d6 41 00       	mov    edi,0x41d6a8
  4116ef:	e8 dc 89 ff ff       	call   40a0d0 <cos_print_str>
	assert(align % PAGE_SIZE == 0);
  4116f4:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4116fb:	00 00 00 00 
  4116ff:	0f 0b                	ud2    
  411701:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  411708:	00 00 00 00 
  41170c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000411710 <cos_mem_aliasn>:

vaddr_t
cos_mem_aliasn(struct cos_compinfo *dstci, struct cos_compinfo *srcci, vaddr_t src, size_t sz, unsigned long perm_flags)
{
  411710:	f3 0f 1e fa          	endbr64 
	return cos_mem_aliasn_aligned(dstci, srcci, src, sz, PAGE_SIZE, perm_flags);
  411714:	4d 89 c1             	mov    r9,r8
  411717:	41 b8 00 10 00 00    	mov    r8d,0x1000
  41171d:	e9 8e fe ff ff       	jmp    4115b0 <cos_mem_aliasn_aligned>
  411722:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  411729:	00 00 00 00 
  41172d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000411730 <cos_mem_alias>:
}

vaddr_t
cos_mem_alias(struct cos_compinfo *dstci, struct cos_compinfo *srcci, vaddr_t src, unsigned long perm_flags)
{
  411730:	f3 0f 1e fa          	endbr64 
  411734:	49 89 c9             	mov    r9,rcx
	return cos_mem_aliasn_aligned(dstci, srcci, src, sz, PAGE_SIZE, perm_flags);
  411737:	41 b8 00 10 00 00    	mov    r8d,0x1000
  41173d:	b9 00 10 00 00       	mov    ecx,0x1000
  411742:	e9 69 fe ff ff       	jmp    4115b0 <cos_mem_aliasn_aligned>
  411747:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41174e:	00 00 

0000000000411750 <cos_mem_alias_at>:
	return cos_mem_aliasn(dstci, srcci, src, PAGE_SIZE, perm_flags);
}

int
cos_mem_alias_at(struct cos_compinfo *dstci, vaddr_t dst, struct cos_compinfo *srcci, vaddr_t src, unsigned long perm_flags)
{
  411750:	f3 0f 1e fa          	endbr64 
  411754:	55                   	push   rbp
  411755:	48 89 d0             	mov    rax,rdx
  411758:	48 89 e5             	mov    rbp,rsp
  41175b:	41 54                	push   r12
  41175d:	53                   	push   rbx
  41175e:	48 83 ec 10          	sub    rsp,0x10
	assert(srcci && dstci);
  411762:	48 85 d2             	test   rdx,rdx
  411765:	74 7d                	je     4117e4 <cos_mem_alias_at+0x94>
  411767:	49 89 f9             	mov    r9,rdi
  41176a:	48 85 ff             	test   rdi,rdi
  41176d:	74 75                	je     4117e4 <cos_mem_alias_at+0x94>

	if (call_cap_op(srcci->pgtbl_cap, CAPTBL_OP_CPY, src, dstci->pgtbl_cap, dst, perm_flags)) BUG();
  41176f:	48 8b 00             	mov    rax,QWORD PTR [rax]
  411772:	48 89 f7             	mov    rdi,rsi
  411775:	48 89 cb             	mov    rbx,rcx
  411778:	49 8b 31             	mov    rsi,QWORD PTR [r9]
  41177b:	4c 89 c2             	mov    rdx,r8
  41177e:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411782:	83 c0 01             	add    eax,0x1
  411785:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  411788:	48 89 29             	mov    QWORD PTR [rcx],rbp
  41178b:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  41178f:	48 89 cd             	mov    rbp,rcx
  411792:	49 b8 a8 17 41 00 00 	movabs r8,0x4117a8
  411799:	00 00 00 
  41179c:	0f 05                	syscall 
  41179e:	66 90                	xchg   ax,ax
  4117a0:	eb 0d                	jmp    4117af <cos_mem_alias_at+0x5f>
  4117a2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4117a8:	b9 00 00 00 00       	mov    ecx,0x0
  4117ad:	eb 05                	jmp    4117b4 <cos_mem_alias_at+0x64>
  4117af:	b9 01 00 00 00       	mov    ecx,0x1
  4117b4:	5d                   	pop    rbp
  4117b5:	5c                   	pop    rsp
  4117b6:	85 c0                	test   eax,eax
  4117b8:	75 0e                	jne    4117c8 <cos_mem_alias_at+0x78>

	return 0;
}
  4117ba:	48 83 c4 10          	add    rsp,0x10
  4117be:	31 c0                	xor    eax,eax
  4117c0:	5b                   	pop    rbx
  4117c1:	41 5c                	pop    r12
  4117c3:	5d                   	pop    rbp
  4117c4:	c3                   	ret    
  4117c5:	0f 1f 00             	nop    DWORD PTR [rax]
  4117c8:	be 1c 00 00 00       	mov    esi,0x1c
  4117cd:	bf 08 d7 41 00       	mov    edi,0x41d708
  4117d2:	e8 f9 88 ff ff       	call   40a0d0 <cos_print_str>
	if (call_cap_op(srcci->pgtbl_cap, CAPTBL_OP_CPY, src, dstci->pgtbl_cap, dst, perm_flags)) BUG();
  4117d7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4117de:	00 00 00 00 
  4117e2:	0f 0b                	ud2    
  4117e4:	be 2f 00 00 00       	mov    esi,0x2f
  4117e9:	bf d8 d6 41 00       	mov    edi,0x41d6d8
  4117ee:	e8 dd 88 ff ff       	call   40a0d0 <cos_print_str>
	assert(srcci && dstci);
  4117f3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4117fa:	00 00 00 00 
  4117fe:	0f 0b                	ud2    

0000000000411800 <cos_mem_alias_atn>:

int
cos_mem_alias_atn(struct cos_compinfo *dstci, vaddr_t dst, struct cos_compinfo *srcci, vaddr_t src, size_t sz, unsigned long perm_flags)
{
  411800:	f3 0f 1e fa          	endbr64 
  411804:	55                   	push   rbp
  411805:	48 89 e5             	mov    rbp,rsp
  411808:	41 57                	push   r15
  41180a:	41 56                	push   r14
  41180c:	49 89 d6             	mov    r14,rdx
  41180f:	41 55                	push   r13
  411811:	41 54                	push   r12
  411813:	53                   	push   rbx
  411814:	48 83 ec 18          	sub    rsp,0x18
	size_t i;
	size_t npages;

	assert(srcci && dstci);
  411818:	48 85 d2             	test   rdx,rdx
  41181b:	0f 84 c0 00 00 00    	je     4118e1 <cos_mem_alias_atn+0xe1>
  411821:	49 89 ff             	mov    r15,rdi
  411824:	48 85 ff             	test   rdi,rdi
  411827:	0f 84 b4 00 00 00    	je     4118e1 <cos_mem_alias_atn+0xe1>
	assert(sz % PAGE_SIZE == 0);
  41182d:	41 f7 c0 ff 0f 00 00 	test   r8d,0xfff
  411834:	0f 85 c3 00 00 00    	jne    4118fd <cos_mem_alias_atn+0xfd>

	npages = sz / PAGE_SIZE;
	for (i=0; i < npages; i++) {
  41183a:	49 c1 e8 0c          	shr    r8,0xc
  41183e:	0f 84 8c 00 00 00    	je     4118d0 <cos_mem_alias_atn+0xd0>
  411844:	49 89 f5             	mov    r13,rsi
  411847:	49 c1 e0 0c          	shl    r8,0xc
  41184b:	48 89 cb             	mov    rbx,rcx
  41184e:	4c 89 ca             	mov    rdx,r9
  411851:	4d 8d 14 08          	lea    r10,[r8+rcx*1]
  411855:	49 29 cd             	sub    r13,rcx
  411858:	eb 12                	jmp    41186c <cos_mem_alias_atn+0x6c>
  41185a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411860:	48 81 c3 00 10 00 00 	add    rbx,0x1000
  411867:	49 39 da             	cmp    r10,rbx
  41186a:	74 64                	je     4118d0 <cos_mem_alias_atn+0xd0>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  41186c:	41 8b 06             	mov    eax,DWORD PTR [r14]
	__asm__ __volatile__(
  41186f:	49 8b 37             	mov    rsi,QWORD PTR [r15]
  411872:	49 8d 7c 1d 00       	lea    rdi,[r13+rbx*1+0x0]
  411877:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  41187b:	83 c0 01             	add    eax,0x1
  41187e:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  411881:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411884:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411888:	48 89 cd             	mov    rbp,rcx
  41188b:	49 b8 a0 18 41 00 00 	movabs r8,0x4118a0
  411892:	00 00 00 
  411895:	0f 05                	syscall 
  411897:	90                   	nop
  411898:	eb 0d                	jmp    4118a7 <cos_mem_alias_atn+0xa7>
  41189a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4118a0:	b9 00 00 00 00       	mov    ecx,0x0
  4118a5:	eb 05                	jmp    4118ac <cos_mem_alias_atn+0xac>
  4118a7:	b9 01 00 00 00       	mov    ecx,0x1
  4118ac:	5d                   	pop    rbp
  4118ad:	5c                   	pop    rsp
		if (call_cap_op(srcci->pgtbl_cap, CAPTBL_OP_CPY, src + i * PAGE_SIZE, dstci->pgtbl_cap, dst + i * PAGE_SIZE, perm_flags)) BUG();
  4118ae:	85 c0                	test   eax,eax
  4118b0:	74 ae                	je     411860 <cos_mem_alias_atn+0x60>
  4118b2:	be 1c 00 00 00       	mov    esi,0x1c
  4118b7:	bf 88 d7 41 00       	mov    edi,0x41d788
  4118bc:	e8 0f 88 ff ff       	call   40a0d0 <cos_print_str>
  4118c1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4118c8:	00 00 00 00 
  4118cc:	0f 0b                	ud2    
  4118ce:	66 90                	xchg   ax,ax
	}

	return 0;
}
  4118d0:	48 83 c4 18          	add    rsp,0x18
  4118d4:	31 c0                	xor    eax,eax
  4118d6:	5b                   	pop    rbx
  4118d7:	41 5c                	pop    r12
  4118d9:	41 5d                	pop    r13
  4118db:	41 5e                	pop    r14
  4118dd:	41 5f                	pop    r15
  4118df:	5d                   	pop    rbp
  4118e0:	c3                   	ret    
  4118e1:	be 2f 00 00 00       	mov    esi,0x2f
  4118e6:	bf 28 d7 41 00       	mov    edi,0x41d728
  4118eb:	e8 e0 87 ff ff       	call   40a0d0 <cos_print_str>
	assert(srcci && dstci);
  4118f0:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4118f7:	00 00 00 00 
  4118fb:	0f 0b                	ud2    
  4118fd:	be 2f 00 00 00       	mov    esi,0x2f
  411902:	bf 58 d7 41 00       	mov    edi,0x41d758
  411907:	e8 c4 87 ff ff       	call   40a0d0 <cos_print_str>
	assert(sz % PAGE_SIZE == 0);
  41190c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411913:	00 00 00 00 
  411917:	0f 0b                	ud2    
  411919:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000411920 <cos_mem_remove>:

int
cos_mem_remove(pgtblcap_t pt, vaddr_t addr)
{
  411920:	f3 0f 1e fa          	endbr64 
  411924:	55                   	push   rbp
  411925:	be 2f 00 00 00       	mov    esi,0x2f
  41192a:	bf a8 d7 41 00       	mov    edi,0x41d7a8
  41192f:	48 89 e5             	mov    rbp,rsp
  411932:	e8 99 87 ff ff       	call   40a0d0 <cos_print_str>
	assert(0);
  411937:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41193e:	00 00 00 00 
  411942:	0f 0b                	ud2    
  411944:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41194b:	00 00 00 00 
  41194f:	90                   	nop

0000000000411950 <cos_mem_move>:
	return 0;
}

vaddr_t
cos_mem_move(struct cos_compinfo *dstci, struct cos_compinfo *srcci, vaddr_t src)
{
  411950:	f3 0f 1e fa          	endbr64 
  411954:	55                   	push   rbp
  411955:	48 89 e5             	mov    rbp,rsp
  411958:	41 55                	push   r13
  41195a:	41 54                	push   r12
  41195c:	53                   	push   rbx
  41195d:	48 83 ec 18          	sub    rsp,0x18
	vaddr_t dst;

	assert(srcci && dstci);
  411961:	48 85 f6             	test   rsi,rsi
  411964:	0f 84 a2 00 00 00    	je     411a0c <cos_mem_move+0xbc>
  41196a:	49 89 fc             	mov    r12,rdi
  41196d:	48 85 ff             	test   rdi,rdi
  411970:	0f 84 96 00 00 00    	je     411a0c <cos_mem_move+0xbc>
  411976:	49 89 f5             	mov    r13,rsi
  411979:	48 89 d3             	mov    rbx,rdx

	dst = __page_bump_valloc(dstci, PAGE_SIZE, PAGE_SIZE);
  41197c:	be 00 10 00 00       	mov    esi,0x1000
  411981:	ba 00 10 00 00       	mov    edx,0x1000
  411986:	e8 95 b5 ff ff       	call   40cf20 <__page_bump_valloc>
  41198b:	49 89 c2             	mov    r10,rax
	if (unlikely(!dst)) return 0;
  41198e:	48 85 c0             	test   rax,rax
  411991:	74 4f                	je     4119e2 <cos_mem_move+0x92>

	if (call_cap_op(srcci->pgtbl_cap, CAPTBL_OP_MEMMOVE, src, dstci->pgtbl_cap, dst, 0)) BUG();
  411993:	49 8b 45 00          	mov    rax,QWORD PTR [r13+0x0]
  411997:	49 8b 34 24          	mov    rsi,QWORD PTR [r12]
  41199b:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  41199f:	31 d2                	xor    edx,edx
  4119a1:	4c 89 d7             	mov    rdi,r10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4119a4:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  4119a7:	05 24 00 01 00       	add    eax,0x10024
	__asm__ __volatile__(
  4119ac:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4119af:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4119b3:	48 89 cd             	mov    rbp,rcx
  4119b6:	49 b8 d0 19 41 00 00 	movabs r8,0x4119d0
  4119bd:	00 00 00 
  4119c0:	0f 05                	syscall 
  4119c2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4119c8:	eb 0d                	jmp    4119d7 <cos_mem_move+0x87>
  4119ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4119d0:	b9 00 00 00 00       	mov    ecx,0x0
  4119d5:	eb 05                	jmp    4119dc <cos_mem_move+0x8c>
  4119d7:	b9 01 00 00 00       	mov    ecx,0x1
  4119dc:	5d                   	pop    rbp
  4119dd:	5c                   	pop    rsp
  4119de:	85 c0                	test   eax,eax
  4119e0:	75 0e                	jne    4119f0 <cos_mem_move+0xa0>

	return dst;
}
  4119e2:	48 83 c4 18          	add    rsp,0x18
  4119e6:	4c 89 d0             	mov    rax,r10
  4119e9:	5b                   	pop    rbx
  4119ea:	41 5c                	pop    r12
  4119ec:	41 5d                	pop    r13
  4119ee:	5d                   	pop    rbp
  4119ef:	c3                   	ret    
  4119f0:	be 1c 00 00 00       	mov    esi,0x1c
  4119f5:	bf 08 d8 41 00       	mov    edi,0x41d808
  4119fa:	e8 d1 86 ff ff       	call   40a0d0 <cos_print_str>
	if (call_cap_op(srcci->pgtbl_cap, CAPTBL_OP_MEMMOVE, src, dstci->pgtbl_cap, dst, 0)) BUG();
  4119ff:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411a06:	00 00 00 00 
  411a0a:	0f 0b                	ud2    
  411a0c:	be 2f 00 00 00       	mov    esi,0x2f
  411a11:	bf d8 d7 41 00       	mov    edi,0x41d7d8
  411a16:	e8 b5 86 ff ff       	call   40a0d0 <cos_print_str>
	assert(srcci && dstci);
  411a1b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411a22:	00 00 00 00 
  411a26:	0f 0b                	ud2    
  411a28:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  411a2f:	00 

0000000000411a30 <cos_mem_move_at>:

int
cos_mem_move_at(struct cos_compinfo *dstci, vaddr_t dst, struct cos_compinfo *srcci, vaddr_t src)
{
  411a30:	f3 0f 1e fa          	endbr64 
  411a34:	55                   	push   rbp
  411a35:	48 89 e5             	mov    rbp,rsp
  411a38:	41 54                	push   r12
  411a3a:	53                   	push   rbx
  411a3b:	48 83 ec 10          	sub    rsp,0x10
	assert(srcci && dstci);
  411a3f:	48 85 d2             	test   rdx,rdx
  411a42:	0f 84 7c 00 00 00    	je     411ac4 <cos_mem_move_at+0x94>
  411a48:	49 89 f8             	mov    r8,rdi
  411a4b:	48 85 ff             	test   rdi,rdi
  411a4e:	74 74                	je     411ac4 <cos_mem_move_at+0x94>

	/* TODO */
	if (call_cap_op(srcci->pgtbl_cap, CAPTBL_OP_MEMMOVE, src, dstci->pgtbl_cap, dst, 0)) BUG();
  411a50:	48 8b 02             	mov    rax,QWORD PTR [rdx]
  411a53:	48 89 f7             	mov    rdi,rsi
  411a56:	48 89 cb             	mov    rbx,rcx
  411a59:	49 8b 30             	mov    rsi,QWORD PTR [r8]
  411a5c:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  411a60:	31 d2                	xor    edx,edx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411a62:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  411a65:	05 24 00 01 00       	add    eax,0x10024
	__asm__ __volatile__(
  411a6a:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411a6d:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411a71:	48 89 cd             	mov    rbp,rcx
  411a74:	49 b8 88 1a 41 00 00 	movabs r8,0x411a88
  411a7b:	00 00 00 
  411a7e:	0f 05                	syscall 
  411a80:	eb 0d                	jmp    411a8f <cos_mem_move_at+0x5f>
  411a82:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411a88:	b9 00 00 00 00       	mov    ecx,0x0
  411a8d:	eb 05                	jmp    411a94 <cos_mem_move_at+0x64>
  411a8f:	b9 01 00 00 00       	mov    ecx,0x1
  411a94:	5d                   	pop    rbp
  411a95:	5c                   	pop    rsp
  411a96:	85 c0                	test   eax,eax
  411a98:	75 0e                	jne    411aa8 <cos_mem_move_at+0x78>

	return 0;
}
  411a9a:	48 83 c4 10          	add    rsp,0x10
  411a9e:	31 c0                	xor    eax,eax
  411aa0:	5b                   	pop    rbx
  411aa1:	41 5c                	pop    r12
  411aa3:	5d                   	pop    rbp
  411aa4:	c3                   	ret    
  411aa5:	0f 1f 00             	nop    DWORD PTR [rax]
  411aa8:	be 1c 00 00 00       	mov    esi,0x1c
  411aad:	bf 58 d8 41 00       	mov    edi,0x41d858
  411ab2:	e8 19 86 ff ff       	call   40a0d0 <cos_print_str>
	if (call_cap_op(srcci->pgtbl_cap, CAPTBL_OP_MEMMOVE, src, dstci->pgtbl_cap, dst, 0)) BUG();
  411ab7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411abe:	00 00 00 00 
  411ac2:	0f 0b                	ud2    
  411ac4:	be 2f 00 00 00       	mov    esi,0x2f
  411ac9:	bf 28 d8 41 00       	mov    edi,0x41d828
  411ace:	e8 fd 85 ff ff       	call   40a0d0 <cos_print_str>
	assert(srcci && dstci);
  411ad3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411ada:	00 00 00 00 
  411ade:	0f 0b                	ud2    

0000000000411ae0 <cos_thd_mod>:

/* TODO: generalize to modify all state */
int
cos_thd_mod(struct cos_compinfo *ci, thdcap_t tc, void *tlsaddr)
{
  411ae0:	f3 0f 1e fa          	endbr64 
  411ae4:	55                   	push   rbp
  411ae5:	49 89 f2             	mov    r10,rsi
  411ae8:	48 89 d6             	mov    rsi,rdx
  411aeb:	31 d2                	xor    edx,edx
  411aed:	48 89 e5             	mov    rbp,rsp
  411af0:	41 54                	push   r12
  411af2:	53                   	push   rbx
  411af3:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  411af7:	4c 89 d3             	mov    rbx,r10
	return call_cap_op(ci->captbl_cap, CAPTBL_OP_THDTLSSET, tc, (word_t)tlsaddr, 0, 0);
  411afa:	48 8b 47 08          	mov    rax,QWORD PTR [rdi+0x8]
  411afe:	48 89 d7             	mov    rdi,rdx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411b01:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  411b04:	05 06 00 01 00       	add    eax,0x10006
	__asm__ __volatile__(
  411b09:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411b0c:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411b10:	48 89 cd             	mov    rbp,rcx
  411b13:	49 b8 28 1b 41 00 00 	movabs r8,0x411b28
  411b1a:	00 00 00 
  411b1d:	0f 05                	syscall 
  411b1f:	90                   	nop
  411b20:	eb 0d                	jmp    411b2f <cos_thd_mod+0x4f>
  411b22:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411b28:	b9 00 00 00 00       	mov    ecx,0x0
  411b2d:	eb 05                	jmp    411b34 <cos_thd_mod+0x54>
  411b2f:	b9 01 00 00 00       	mov    ecx,0x1
  411b34:	5d                   	pop    rbp
  411b35:	5c                   	pop    rsp
}
  411b36:	5b                   	pop    rbx
  411b37:	41 5c                	pop    r12
  411b39:	5d                   	pop    rbp
  411b3a:	c3                   	ret    
  411b3b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000411b40 <cos_introspect>:

/* FIXME: problems when we got to 64 bit systems with the return value */
int
cos_introspect(struct cos_compinfo *ci, capid_t cap, unsigned long op)
{
  411b40:	f3 0f 1e fa          	endbr64 
  411b44:	55                   	push   rbp
  411b45:	49 89 f2             	mov    r10,rsi
	return call_cap_op(ci->captbl_cap, CAPTBL_OP_INTROSPECT, cap, (int)op, 0, 0);
  411b48:	48 63 f2             	movsxd rsi,edx
  411b4b:	31 d2                	xor    edx,edx
{
  411b4d:	48 89 e5             	mov    rbp,rsp
  411b50:	41 54                	push   r12
  411b52:	53                   	push   rbx
  411b53:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  411b57:	4c 89 d3             	mov    rbx,r10
	return call_cap_op(ci->captbl_cap, CAPTBL_OP_INTROSPECT, cap, (int)op, 0, 0);
  411b5a:	48 8b 47 08          	mov    rax,QWORD PTR [rdi+0x8]
  411b5e:	48 89 d7             	mov    rdi,rdx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411b61:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  411b64:	05 25 00 01 00       	add    eax,0x10025
	__asm__ __volatile__(
  411b69:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411b6c:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411b70:	48 89 cd             	mov    rbp,rcx
  411b73:	49 b8 88 1b 41 00 00 	movabs r8,0x411b88
  411b7a:	00 00 00 
  411b7d:	0f 05                	syscall 
  411b7f:	90                   	nop
  411b80:	eb 0d                	jmp    411b8f <cos_introspect+0x4f>
  411b82:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411b88:	b9 00 00 00 00       	mov    ecx,0x0
  411b8d:	eb 05                	jmp    411b94 <cos_introspect+0x54>
  411b8f:	b9 01 00 00 00       	mov    ecx,0x1
  411b94:	5d                   	pop    rbp
  411b95:	5c                   	pop    rsp
}
  411b96:	5b                   	pop    rbx
  411b97:	41 5c                	pop    r12
  411b99:	5d                   	pop    rbp
  411b9a:	c3                   	ret    
  411b9b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000411ba0 <cos_tcap_alloc>:

/***************** [Kernel Tcap Operations] *****************/

tcap_t
cos_tcap_alloc(struct cos_compinfo *ci)
{
  411ba0:	f3 0f 1e fa          	endbr64 
  411ba4:	55                   	push   rbp
  411ba5:	48 89 e5             	mov    rbp,rsp
  411ba8:	41 56                	push   r14
  411baa:	41 55                	push   r13
  411bac:	41 54                	push   r12
  411bae:	53                   	push   rbx
  411baf:	48 83 ec 10          	sub    rsp,0x10
	vaddr_t kmem;
	capid_t cap;

	printd("cos_tcap_alloc\n");
	assert(ci);
  411bb3:	48 85 ff             	test   rdi,rdi
  411bb6:	0f 84 30 01 00 00    	je     411cec <cos_tcap_alloc+0x14c>
  411bbc:	49 89 fc             	mov    r12,rdi
	return __mem_bump_alloc(ci, 1, 1);
  411bbf:	e8 9c ac ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  411bc4:	49 89 c5             	mov    r13,rax
	if (!*kmem) return -1;
  411bc7:	48 85 c0             	test   rax,rax
  411bca:	0f 84 38 01 00 00    	je     411d08 <cos_tcap_alloc+0x168>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  411bd0:	49 8d 94 24 b0 00 00 	lea    rdx,[r12+0xb0]
  411bd7:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  411bd8:	41 b8 01 00 00 00    	mov    r8d,0x1
  411bde:	31 c9                	xor    ecx,ecx
  411be0:	48 89 c8             	mov    rax,rcx
  411be3:	f0 4c 0f b1 02       	lock cmpxchg QWORD PTR [rdx],r8
  411be8:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  411beb:	84 c0                	test   al,al
  411bed:	74 f1                	je     411be0 <cos_tcap_alloc+0x40>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  411bef:	4d 8b 74 24 28       	mov    r14,QWORD PTR [r12+0x28]
  411bf4:	41 83 e6 03          	and    r14d,0x3
  411bf8:	0f 84 9a 00 00 00    	je     411c98 <cos_tcap_alloc+0xf8>
        __asm__ __volatile__("lock " PS_FAA_STR
  411bfe:	ba 01 00 00 00       	mov    edx,0x1
  411c03:	f0 49 0f c1 54 24 28 	lock xadd QWORD PTR [r12+0x28],rdx
{ l->o = 0; }
  411c0a:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  411c11:	00 00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  411c16:	49 89 d6             	mov    r14,rdx
	if (!*cap) return -1;
  411c19:	48 85 d2             	test   rdx,rdx
  411c1c:	0f 84 e6 00 00 00    	je     411d08 <cos_tcap_alloc+0x168>

	if (__alloc_mem_cap(ci, CAP_TCAP, &kmem, &cap)) return 0;
	/* TODO: Add cap size checking */
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_TCAP_ACTIVATE, (cap << 16) | __compinfo_metacap(ci)->mi.pgtbl_cap,
  411c22:	49 8b 4c 24 60       	mov    rcx,QWORD PTR [r12+0x60]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411c27:	41 8b 44 24 08       	mov    eax,DWORD PTR [r12+0x8]
  411c2c:	48 c1 e2 10          	shl    rdx,0x10
	__asm__ __volatile__(
  411c30:	4c 89 ee             	mov    rsi,r13
  411c33:	48 8b 99 98 00 00 00 	mov    rbx,QWORD PTR [rcx+0x98]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411c3a:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  411c3d:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
	cap_no += op;
  411c41:	05 26 00 01 00       	add    eax,0x10026
  411c46:	48 09 d3             	or     rbx,rdx
	__asm__ __volatile__(
  411c49:	31 d2                	xor    edx,edx
  411c4b:	48 89 d7             	mov    rdi,rdx
  411c4e:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411c51:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411c55:	48 89 cd             	mov    rbp,rcx
  411c58:	49 b8 70 1c 41 00 00 	movabs r8,0x411c70
  411c5f:	00 00 00 
  411c62:	0f 05                	syscall 
  411c64:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  411c68:	eb 0d                	jmp    411c77 <cos_tcap_alloc+0xd7>
  411c6a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411c70:	b9 00 00 00 00       	mov    ecx,0x0
  411c75:	eb 05                	jmp    411c7c <cos_tcap_alloc+0xdc>
  411c77:	b9 01 00 00 00       	mov    ecx,0x1
  411c7c:	5d                   	pop    rbp
  411c7d:	5c                   	pop    rsp
  411c7e:	85 c0                	test   eax,eax
  411c80:	75 4e                	jne    411cd0 <cos_tcap_alloc+0x130>
	                kmem, 0, 0))
		BUG();

	return cap;
}
  411c82:	48 83 c4 10          	add    rsp,0x10
  411c86:	4c 89 f0             	mov    rax,r14
  411c89:	5b                   	pop    rbx
  411c8a:	41 5c                	pop    r12
  411c8c:	41 5d                	pop    r13
  411c8e:	41 5e                	pop    r14
  411c90:	5d                   	pop    rbp
  411c91:	c3                   	ret    
  411c92:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  411c98:	4c 89 e7             	mov    rdi,r12
  411c9b:	e8 40 ad ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  411ca0:	85 c0                	test   eax,eax
  411ca2:	75 16                	jne    411cba <cos_tcap_alloc+0x11a>
        __asm__ __volatile__("lock " PS_FAA_STR
  411ca4:	b8 04 00 00 00       	mov    eax,0x4
  411ca9:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  411cb0:	49 89 44 24 28       	mov    QWORD PTR [r12+0x28],rax
  411cb5:	e9 44 ff ff ff       	jmp    411bfe <cos_tcap_alloc+0x5e>
{ l->o = 0; }
  411cba:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  411cc1:	00 00 00 00 00 
	if (!*cap) return -1;
  411cc6:	eb ba                	jmp    411c82 <cos_tcap_alloc+0xe2>
  411cc8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  411ccf:	00 
  411cd0:	be 1c 00 00 00       	mov    esi,0x1c
  411cd5:	bf a8 d8 41 00       	mov    edi,0x41d8a8
  411cda:	e8 f1 83 ff ff       	call   40a0d0 <cos_print_str>
		BUG();
  411cdf:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411ce6:	00 00 00 00 
  411cea:	0f 0b                	ud2    
  411cec:	be 2f 00 00 00       	mov    esi,0x2f
  411cf1:	bf 78 d8 41 00       	mov    edi,0x41d878
  411cf6:	e8 d5 83 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci);
  411cfb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411d02:	00 00 00 00 
  411d06:	0f 0b                	ud2    
	if (__alloc_mem_cap(ci, CAP_TCAP, &kmem, &cap)) return 0;
  411d08:	45 31 f6             	xor    r14d,r14d
  411d0b:	e9 72 ff ff ff       	jmp    411c82 <cos_tcap_alloc+0xe2>

0000000000411d10 <cos_tcap_transfer>:

int
cos_tcap_transfer(arcvcap_t dst, tcap_t src, tcap_res_t res, tcap_prio_t prio)
{
  411d10:	f3 0f 1e fa          	endbr64 
  411d14:	55                   	push   rbp
  411d15:	49 89 fa             	mov    r10,rdi
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411d18:	c1 e6 10             	shl    esi,0x10
	int prio_higher = (u32_t)(prio >> 32);
	int prio_lower  = (u32_t)((prio << 32) >> 32);

	return call_cap_op(src, CAPTBL_OP_TCAP_TRANSFER, dst, res, prio_higher, prio_lower);
  411d1b:	48 89 cf             	mov    rdi,rcx
	cap_no += op;
  411d1e:	8d 86 27 00 01 00    	lea    eax,[rsi+0x10027]
  411d24:	48 c1 ff 20          	sar    rdi,0x20
{
  411d28:	48 89 e5             	mov    rbp,rsp
  411d2b:	41 55                	push   r13
  411d2d:	49 89 d5             	mov    r13,rdx
	return call_cap_op(src, CAPTBL_OP_TCAP_TRANSFER, dst, res, prio_higher, prio_lower);
  411d30:	48 63 d1             	movsxd rdx,ecx
{
  411d33:	41 54                	push   r12
	__asm__ __volatile__(
  411d35:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  411d39:	4c 89 ee             	mov    rsi,r13
  411d3c:	53                   	push   rbx
  411d3d:	4c 89 d3             	mov    rbx,r10
  411d40:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411d43:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411d47:	48 89 cd             	mov    rbp,rcx
  411d4a:	49 b8 60 1d 41 00 00 	movabs r8,0x411d60
  411d51:	00 00 00 
  411d54:	0f 05                	syscall 
  411d56:	66 90                	xchg   ax,ax
  411d58:	eb 0d                	jmp    411d67 <cos_tcap_transfer+0x57>
  411d5a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411d60:	b9 00 00 00 00       	mov    ecx,0x0
  411d65:	eb 05                	jmp    411d6c <cos_tcap_transfer+0x5c>
  411d67:	b9 01 00 00 00       	mov    ecx,0x1
  411d6c:	5d                   	pop    rbp
  411d6d:	5c                   	pop    rsp
}
  411d6e:	5b                   	pop    rbx
  411d6f:	41 5c                	pop    r12
  411d71:	41 5d                	pop    r13
  411d73:	5d                   	pop    rbp
  411d74:	c3                   	ret    
  411d75:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  411d7c:	00 00 00 00 

0000000000411d80 <cos_tcap_delegate>:

int
cos_tcap_delegate(asndcap_t dst, tcap_t src, tcap_res_t res, tcap_prio_t prio, tcap_deleg_flags_t flags)
{
  411d80:	f3 0f 1e fa          	endbr64 
  411d84:	55                   	push   rbp
  411d85:	49 89 fa             	mov    r10,rdi
	u32_t yield = ((flags & TCAP_DELEG_YIELD) != 0);
  411d88:	44 89 c7             	mov    edi,r8d
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411d8b:	c1 e6 10             	shl    esi,0x10
  411d8e:	d1 ef                	shr    edi,1
	cap_no += op;
  411d90:	8d 86 28 00 01 00    	lea    eax,[rsi+0x10028]
	/* top bit is if we are dispatching or not */
	int prio_higher = (u32_t)(prio >> 32) | (yield << ((sizeof(yield) * 8) - 1));
  411d96:	c1 e7 1f             	shl    edi,0x1f
{
  411d99:	48 89 e5             	mov    rbp,rsp
  411d9c:	41 55                	push   r13
  411d9e:	49 89 d5             	mov    r13,rdx
	int prio_higher = (u32_t)(prio >> 32) | (yield << ((sizeof(yield) * 8) - 1));
  411da1:	48 89 ca             	mov    rdx,rcx
{
  411da4:	41 54                	push   r12
	int prio_higher = (u32_t)(prio >> 32) | (yield << ((sizeof(yield) * 8) - 1));
  411da6:	48 c1 ea 20          	shr    rdx,0x20
	__asm__ __volatile__(
  411daa:	4c 89 ee             	mov    rsi,r13
{
  411dad:	53                   	push   rbx
	int prio_higher = (u32_t)(prio >> 32) | (yield << ((sizeof(yield) * 8) - 1));
  411dae:	09 d7                	or     edi,edx
  411db0:	4c 89 d3             	mov    rbx,r10
	int prio_lower  = (u32_t)((prio << 32) >> 32);

	return call_cap_op(src, CAPTBL_OP_TCAP_DELEGATE, dst, res, prio_higher, prio_lower);
  411db3:	48 63 d1             	movsxd rdx,ecx
  411db6:	48 63 ff             	movsxd rdi,edi
  411db9:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  411dbd:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411dc0:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411dc4:	48 89 cd             	mov    rbp,rcx
  411dc7:	49 b8 e0 1d 41 00 00 	movabs r8,0x411de0
  411dce:	00 00 00 
  411dd1:	0f 05                	syscall 
  411dd3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  411dd8:	eb 0d                	jmp    411de7 <cos_tcap_delegate+0x67>
  411dda:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411de0:	b9 00 00 00 00       	mov    ecx,0x0
  411de5:	eb 05                	jmp    411dec <cos_tcap_delegate+0x6c>
  411de7:	b9 01 00 00 00       	mov    ecx,0x1
  411dec:	5d                   	pop    rbp
  411ded:	5c                   	pop    rsp
}
  411dee:	5b                   	pop    rbx
  411def:	41 5c                	pop    r12
  411df1:	41 5d                	pop    r13
  411df3:	5d                   	pop    rbp
  411df4:	c3                   	ret    
  411df5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  411dfc:	00 00 00 00 

0000000000411e00 <cos_tcap_merge>:

int
cos_tcap_merge(tcap_t dst, tcap_t rm)
{
  411e00:	f3 0f 1e fa          	endbr64 
  411e04:	55                   	push   rbp
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411e05:	c1 e7 10             	shl    edi,0x10
	__asm__ __volatile__(
  411e08:	31 d2                	xor    edx,edx
	cap_no += op;
  411e0a:	8d 87 29 00 01 00    	lea    eax,[rdi+0x10029]
	__asm__ __volatile__(
  411e10:	48 89 d7             	mov    rdi,rdx
  411e13:	48 89 e5             	mov    rbp,rsp
  411e16:	41 54                	push   r12
  411e18:	53                   	push   rbx
  411e19:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  411e1d:	48 89 f3             	mov    rbx,rsi
  411e20:	48 89 d6             	mov    rsi,rdx
  411e23:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411e26:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411e2a:	48 89 cd             	mov    rbp,rcx
  411e2d:	49 b8 48 1e 41 00 00 	movabs r8,0x411e48
  411e34:	00 00 00 
  411e37:	0f 05                	syscall 
  411e39:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  411e40:	eb 0d                	jmp    411e4f <cos_tcap_merge+0x4f>
  411e42:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411e48:	b9 00 00 00 00       	mov    ecx,0x0
  411e4d:	eb 05                	jmp    411e54 <cos_tcap_merge+0x54>
  411e4f:	b9 01 00 00 00       	mov    ecx,0x1
  411e54:	5d                   	pop    rbp
  411e55:	5c                   	pop    rsp
	return call_cap_op(dst, CAPTBL_OP_TCAP_MERGE, rm, 0, 0, 0);
}
  411e56:	5b                   	pop    rbx
  411e57:	41 5c                	pop    r12
  411e59:	5d                   	pop    rbp
  411e5a:	c3                   	ret    
  411e5b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000411e60 <cos_hw_attach>:

int
cos_hw_attach(hwcap_t hwc, hwid_t hwid, arcvcap_t arcv)
{
  411e60:	f3 0f 1e fa          	endbr64 
  411e64:	55                   	push   rbp
  411e65:	49 89 d2             	mov    r10,rdx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411e68:	c1 e7 10             	shl    edi,0x10
	__asm__ __volatile__(
  411e6b:	31 d2                	xor    edx,edx
	cap_no += op;
  411e6d:	8d 87 2d 00 01 00    	lea    eax,[rdi+0x1002d]
	__asm__ __volatile__(
  411e73:	48 89 d7             	mov    rdi,rdx
  411e76:	48 89 e5             	mov    rbp,rsp
  411e79:	41 54                	push   r12
  411e7b:	53                   	push   rbx
  411e7c:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
	return call_cap_op(hwc, CAPTBL_OP_HW_ATTACH, hwid, arcv, 0, 0);
  411e80:	89 f3                	mov    ebx,esi
  411e82:	4c 89 d6             	mov    rsi,r10
  411e85:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411e88:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411e8c:	48 89 cd             	mov    rbp,rcx
  411e8f:	49 b8 a8 1e 41 00 00 	movabs r8,0x411ea8
  411e96:	00 00 00 
  411e99:	0f 05                	syscall 
  411e9b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  411ea0:	eb 0d                	jmp    411eaf <cos_hw_attach+0x4f>
  411ea2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411ea8:	b9 00 00 00 00       	mov    ecx,0x0
  411ead:	eb 05                	jmp    411eb4 <cos_hw_attach+0x54>
  411eaf:	b9 01 00 00 00       	mov    ecx,0x1
  411eb4:	5d                   	pop    rbp
  411eb5:	5c                   	pop    rsp
}
  411eb6:	5b                   	pop    rbx
  411eb7:	41 5c                	pop    r12
  411eb9:	5d                   	pop    rbp
  411eba:	c3                   	ret    
  411ebb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000411ec0 <cos_hw_detach>:

int
cos_hw_detach(hwcap_t hwc, hwid_t hwid)
{
  411ec0:	f3 0f 1e fa          	endbr64 
  411ec4:	55                   	push   rbp
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411ec5:	c1 e7 10             	shl    edi,0x10
	__asm__ __volatile__(
  411ec8:	31 d2                	xor    edx,edx
	cap_no += op;
  411eca:	8d 87 2e 00 01 00    	lea    eax,[rdi+0x1002e]
	__asm__ __volatile__(
  411ed0:	48 89 d7             	mov    rdi,rdx
  411ed3:	48 89 e5             	mov    rbp,rsp
  411ed6:	41 54                	push   r12
  411ed8:	53                   	push   rbx
  411ed9:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
	return call_cap_op(hwc, CAPTBL_OP_HW_DETACH, hwid, 0, 0, 0);
  411edd:	89 f3                	mov    ebx,esi
  411edf:	48 89 d6             	mov    rsi,rdx
  411ee2:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411ee5:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411ee9:	48 89 cd             	mov    rbp,rcx
  411eec:	49 b8 00 1f 41 00 00 	movabs r8,0x411f00
  411ef3:	00 00 00 
  411ef6:	0f 05                	syscall 
  411ef8:	eb 0d                	jmp    411f07 <cos_hw_detach+0x47>
  411efa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411f00:	b9 00 00 00 00       	mov    ecx,0x0
  411f05:	eb 05                	jmp    411f0c <cos_hw_detach+0x4c>
  411f07:	b9 01 00 00 00       	mov    ecx,0x1
  411f0c:	5d                   	pop    rbp
  411f0d:	5c                   	pop    rsp
}
  411f0e:	5b                   	pop    rbx
  411f0f:	41 5c                	pop    r12
  411f11:	5d                   	pop    rbp
  411f12:	c3                   	ret    
  411f13:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  411f1a:	00 00 00 00 
  411f1e:	66 90                	xchg   ax,ax

0000000000411f20 <cos_hw_cycles_per_usec>:

int
cos_hw_cycles_per_usec(hwcap_t hwc)
{
  411f20:	f3 0f 1e fa          	endbr64 
	static int cycs = 0;

	while (cycs <= 0) cycs = call_cap_op(hwc, CAPTBL_OP_HW_CYC_USEC, 0, 0, 0, 0);
  411f24:	8b 05 36 eb 18 00    	mov    eax,DWORD PTR [rip+0x18eb36]        # 5a0a60 <cycs.0>
  411f2a:	85 c0                	test   eax,eax
  411f2c:	7f 72                	jg     411fa0 <cos_hw_cycles_per_usec+0x80>
{
  411f2e:	55                   	push   rbp
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411f2f:	c1 e7 10             	shl    edi,0x10
	__asm__ __volatile__(
  411f32:	31 d2                	xor    edx,edx
  411f34:	48 89 e5             	mov    rbp,rsp
  411f37:	41 55                	push   r13
	cap_no += op;
  411f39:	44 8d af 30 00 01 00 	lea    r13d,[rdi+0x10030]
  411f40:	41 54                	push   r12
  411f42:	4c 8d 55 d0          	lea    r10,[rbp-0x30]
  411f46:	53                   	push   rbx
  411f47:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  411f4e:	00 00 
	__asm__ __volatile__(
  411f50:	44 89 e8             	mov    eax,r13d
  411f53:	48 89 d3             	mov    rbx,rdx
  411f56:	48 89 d6             	mov    rsi,rdx
  411f59:	48 89 d7             	mov    rdi,rdx
  411f5c:	4c 89 d1             	mov    rcx,r10
  411f5f:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411f62:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411f66:	48 89 cd             	mov    rbp,rcx
  411f69:	49 b8 80 1f 41 00 00 	movabs r8,0x411f80
  411f70:	00 00 00 
  411f73:	0f 05                	syscall 
  411f75:	0f 1f 00             	nop    DWORD PTR [rax]
  411f78:	eb 0d                	jmp    411f87 <cos_hw_cycles_per_usec+0x67>
  411f7a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411f80:	b9 00 00 00 00       	mov    ecx,0x0
  411f85:	eb 05                	jmp    411f8c <cos_hw_cycles_per_usec+0x6c>
  411f87:	b9 01 00 00 00       	mov    ecx,0x1
  411f8c:	5d                   	pop    rbp
  411f8d:	5c                   	pop    rsp
	while (cycs <= 0) cycs = call_cap_op(hwc, CAPTBL_OP_HW_CYC_USEC, 0, 0, 0, 0);
  411f8e:	89 05 cc ea 18 00    	mov    DWORD PTR [rip+0x18eacc],eax        # 5a0a60 <cycs.0>
  411f94:	85 c0                	test   eax,eax
  411f96:	7e b8                	jle    411f50 <cos_hw_cycles_per_usec+0x30>

	return cycs;
}
  411f98:	5b                   	pop    rbx
  411f99:	41 5c                	pop    r12
  411f9b:	41 5d                	pop    r13
  411f9d:	5d                   	pop    rbp
  411f9e:	c3                   	ret    
  411f9f:	90                   	nop
  411fa0:	c3                   	ret    
  411fa1:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  411fa8:	00 00 00 00 
  411fac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000411fb0 <cos_hw_tlb_lockdown>:

int
cos_hw_tlb_lockdown(hwcap_t hwc, unsigned long entryid, unsigned long vaddr, unsigned long paddr)
{
  411fb0:	f3 0f 1e fa          	endbr64 
  411fb4:	55                   	push   rbp
  411fb5:	49 89 f2             	mov    r10,rsi
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411fb8:	c1 e7 10             	shl    edi,0x10
  411fbb:	48 89 d6             	mov    rsi,rdx
	cap_no += op;
  411fbe:	8d 87 33 00 01 00    	lea    eax,[rdi+0x10033]
	__asm__ __volatile__(
  411fc4:	31 d2                	xor    edx,edx
  411fc6:	48 89 e5             	mov    rbp,rsp
  411fc9:	41 55                	push   r13
  411fcb:	49 89 cd             	mov    r13,rcx
  411fce:	41 54                	push   r12
  411fd0:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  411fd4:	4c 89 ef             	mov    rdi,r13
  411fd7:	53                   	push   rbx
  411fd8:	4c 89 d3             	mov    rbx,r10
  411fdb:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411fde:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411fe2:	48 89 cd             	mov    rbp,rcx
  411fe5:	49 b8 00 20 41 00 00 	movabs r8,0x412000
  411fec:	00 00 00 
  411fef:	0f 05                	syscall 
  411ff1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  411ff8:	eb 0d                	jmp    412007 <cos_hw_tlb_lockdown+0x57>
  411ffa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  412000:	b9 00 00 00 00       	mov    ecx,0x0
  412005:	eb 05                	jmp    41200c <cos_hw_tlb_lockdown+0x5c>
  412007:	b9 01 00 00 00       	mov    ecx,0x1
  41200c:	5d                   	pop    rbp
  41200d:	5c                   	pop    rsp
	return call_cap_op(hwc, CAPTBL_OP_HW_TLB_LOCKDOWN, entryid, vaddr, paddr, 0);
}
  41200e:	5b                   	pop    rbx
  41200f:	41 5c                	pop    r12
  412011:	41 5d                	pop    r13
  412013:	5d                   	pop    rbp
  412014:	c3                   	ret    
  412015:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41201c:	00 00 00 00 

0000000000412020 <cos_hw_l1flush>:

int
cos_hw_l1flush(hwcap_t hwc)
{
  412020:	f3 0f 1e fa          	endbr64 
  412024:	55                   	push   rbp
  412025:	31 d2                	xor    edx,edx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  412027:	c1 e7 10             	shl    edi,0x10
	cap_no += op;
  41202a:	8d 87 34 00 01 00    	lea    eax,[rdi+0x10034]
	__asm__ __volatile__(
  412030:	48 89 d6             	mov    rsi,rdx
  412033:	48 89 d7             	mov    rdi,rdx
  412036:	48 89 e5             	mov    rbp,rsp
  412039:	41 54                	push   r12
  41203b:	53                   	push   rbx
  41203c:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  412040:	48 89 d3             	mov    rbx,rdx
  412043:	48 89 29             	mov    QWORD PTR [rcx],rbp
  412046:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  41204a:	48 89 cd             	mov    rbp,rcx
  41204d:	49 b8 68 20 41 00 00 	movabs r8,0x412068
  412054:	00 00 00 
  412057:	0f 05                	syscall 
  412059:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  412060:	eb 0d                	jmp    41206f <cos_hw_l1flush+0x4f>
  412062:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  412068:	b9 00 00 00 00       	mov    ecx,0x0
  41206d:	eb 05                	jmp    412074 <cos_hw_l1flush+0x54>
  41206f:	b9 01 00 00 00       	mov    ecx,0x1
  412074:	5d                   	pop    rbp
  412075:	5c                   	pop    rsp
	return call_cap_op(hwc, CAPTBL_OP_HW_L1FLUSH, 0, 0, 0, 0);
}
  412076:	5b                   	pop    rbx
  412077:	41 5c                	pop    r12
  412079:	5d                   	pop    rbp
  41207a:	c3                   	ret    
  41207b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000412080 <cos_hw_tlbflush>:

int
cos_hw_tlbflush(hwcap_t hwc)
{
  412080:	f3 0f 1e fa          	endbr64 
  412084:	55                   	push   rbp
  412085:	31 d2                	xor    edx,edx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  412087:	c1 e7 10             	shl    edi,0x10
	cap_no += op;
  41208a:	8d 87 35 00 01 00    	lea    eax,[rdi+0x10035]
	__asm__ __volatile__(
  412090:	48 89 d6             	mov    rsi,rdx
  412093:	48 89 d7             	mov    rdi,rdx
  412096:	48 89 e5             	mov    rbp,rsp
  412099:	41 54                	push   r12
  41209b:	53                   	push   rbx
  41209c:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  4120a0:	48 89 d3             	mov    rbx,rdx
  4120a3:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4120a6:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4120aa:	48 89 cd             	mov    rbp,rcx
  4120ad:	49 b8 c8 20 41 00 00 	movabs r8,0x4120c8
  4120b4:	00 00 00 
  4120b7:	0f 05                	syscall 
  4120b9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  4120c0:	eb 0d                	jmp    4120cf <cos_hw_tlbflush+0x4f>
  4120c2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4120c8:	b9 00 00 00 00       	mov    ecx,0x0
  4120cd:	eb 05                	jmp    4120d4 <cos_hw_tlbflush+0x54>
  4120cf:	b9 01 00 00 00       	mov    ecx,0x1
  4120d4:	5d                   	pop    rbp
  4120d5:	5c                   	pop    rsp
	return call_cap_op(hwc, CAPTBL_OP_HW_TLBFLUSH, 0, 0, 0, 0);
}
  4120d6:	5b                   	pop    rbx
  4120d7:	41 5c                	pop    r12
  4120d9:	5d                   	pop    rbp
  4120da:	c3                   	ret    
  4120db:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000004120e0 <cos_hw_tlbstall>:

int
cos_hw_tlbstall(hwcap_t hwc)
{
  4120e0:	f3 0f 1e fa          	endbr64 
  4120e4:	55                   	push   rbp
  4120e5:	31 d2                	xor    edx,edx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4120e7:	c1 e7 10             	shl    edi,0x10
	cap_no += op;
  4120ea:	8d 87 36 00 01 00    	lea    eax,[rdi+0x10036]
	__asm__ __volatile__(
  4120f0:	48 89 d6             	mov    rsi,rdx
  4120f3:	48 89 d7             	mov    rdi,rdx
  4120f6:	48 89 e5             	mov    rbp,rsp
  4120f9:	41 54                	push   r12
  4120fb:	53                   	push   rbx
  4120fc:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  412100:	48 89 d3             	mov    rbx,rdx
  412103:	48 89 29             	mov    QWORD PTR [rcx],rbp
  412106:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  41210a:	48 89 cd             	mov    rbp,rcx
  41210d:	49 b8 28 21 41 00 00 	movabs r8,0x412128
  412114:	00 00 00 
  412117:	0f 05                	syscall 
  412119:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  412120:	eb 0d                	jmp    41212f <cos_hw_tlbstall+0x4f>
  412122:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  412128:	b9 00 00 00 00       	mov    ecx,0x0
  41212d:	eb 05                	jmp    412134 <cos_hw_tlbstall+0x54>
  41212f:	b9 01 00 00 00       	mov    ecx,0x1
  412134:	5d                   	pop    rbp
  412135:	5c                   	pop    rsp
	return call_cap_op(hwc, CAPTBL_OP_HW_TLBSTALL, 0, 0, 0, 0);
}
  412136:	5b                   	pop    rbx
  412137:	41 5c                	pop    r12
  412139:	5d                   	pop    rbp
  41213a:	c3                   	ret    
  41213b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000412140 <cos_hw_tlbstall_recount>:

int
cos_hw_tlbstall_recount(hwcap_t hwc)
{
  412140:	f3 0f 1e fa          	endbr64 
  412144:	55                   	push   rbp
  412145:	31 d2                	xor    edx,edx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  412147:	c1 e7 10             	shl    edi,0x10
	cap_no += op;
  41214a:	8d 87 37 00 01 00    	lea    eax,[rdi+0x10037]
	__asm__ __volatile__(
  412150:	48 89 d6             	mov    rsi,rdx
  412153:	48 89 d7             	mov    rdi,rdx
  412156:	48 89 e5             	mov    rbp,rsp
  412159:	41 54                	push   r12
  41215b:	53                   	push   rbx
  41215c:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  412160:	48 89 d3             	mov    rbx,rdx
  412163:	48 89 29             	mov    QWORD PTR [rcx],rbp
  412166:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  41216a:	48 89 cd             	mov    rbp,rcx
  41216d:	49 b8 88 21 41 00 00 	movabs r8,0x412188
  412174:	00 00 00 
  412177:	0f 05                	syscall 
  412179:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  412180:	eb 0d                	jmp    41218f <cos_hw_tlbstall_recount+0x4f>
  412182:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  412188:	b9 00 00 00 00       	mov    ecx,0x0
  41218d:	eb 05                	jmp    412194 <cos_hw_tlbstall_recount+0x54>
  41218f:	b9 01 00 00 00       	mov    ecx,0x1
  412194:	5d                   	pop    rbp
  412195:	5c                   	pop    rsp
	return call_cap_op(hwc, CAPTBL_OP_HW_TLBSTALL_RECOUNT, 0, 0, 0, 0);
}
  412196:	5b                   	pop    rbx
  412197:	41 5c                	pop    r12
  412199:	5d                   	pop    rbp
  41219a:	c3                   	ret    
  41219b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000004121a0 <cos_hw_cycles_thresh>:

int
cos_hw_cycles_thresh(hwcap_t hwc)
{
  4121a0:	f3 0f 1e fa          	endbr64 
  4121a4:	55                   	push   rbp
  4121a5:	31 d2                	xor    edx,edx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4121a7:	c1 e7 10             	shl    edi,0x10
	cap_no += op;
  4121aa:	8d 87 31 00 01 00    	lea    eax,[rdi+0x10031]
	__asm__ __volatile__(
  4121b0:	48 89 d6             	mov    rsi,rdx
  4121b3:	48 89 d7             	mov    rdi,rdx
  4121b6:	48 89 e5             	mov    rbp,rsp
  4121b9:	41 54                	push   r12
  4121bb:	53                   	push   rbx
  4121bc:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  4121c0:	48 89 d3             	mov    rbx,rdx
  4121c3:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4121c6:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4121ca:	48 89 cd             	mov    rbp,rcx
  4121cd:	49 b8 e8 21 41 00 00 	movabs r8,0x4121e8
  4121d4:	00 00 00 
  4121d7:	0f 05                	syscall 
  4121d9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  4121e0:	eb 0d                	jmp    4121ef <cos_hw_cycles_thresh+0x4f>
  4121e2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4121e8:	b9 00 00 00 00       	mov    ecx,0x0
  4121ed:	eb 05                	jmp    4121f4 <cos_hw_cycles_thresh+0x54>
  4121ef:	b9 01 00 00 00       	mov    ecx,0x1
  4121f4:	5d                   	pop    rbp
  4121f5:	5c                   	pop    rsp
	return call_cap_op(hwc, CAPTBL_OP_HW_CYC_THRESH, 0, 0, 0, 0);
}
  4121f6:	5b                   	pop    rbx
  4121f7:	41 5c                	pop    r12
  4121f9:	5d                   	pop    rbp
  4121fa:	c3                   	ret    
  4121fb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000412200 <cos_hw_shutdown>:

void
cos_hw_shutdown(hwcap_t hwc)
{
  412200:	f3 0f 1e fa          	endbr64 
  412204:	55                   	push   rbp
  412205:	31 d2                	xor    edx,edx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  412207:	c1 e7 10             	shl    edi,0x10
	cap_no += op;
  41220a:	8d 87 32 00 01 00    	lea    eax,[rdi+0x10032]
	__asm__ __volatile__(
  412210:	48 89 d6             	mov    rsi,rdx
  412213:	48 89 d7             	mov    rdi,rdx
  412216:	48 89 e5             	mov    rbp,rsp
  412219:	41 54                	push   r12
  41221b:	53                   	push   rbx
  41221c:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  412220:	48 89 d3             	mov    rbx,rdx
  412223:	48 89 29             	mov    QWORD PTR [rcx],rbp
  412226:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  41222a:	48 89 cd             	mov    rbp,rcx
  41222d:	49 b8 48 22 41 00 00 	movabs r8,0x412248
  412234:	00 00 00 
  412237:	0f 05                	syscall 
  412239:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  412240:	eb 0d                	jmp    41224f <cos_hw_shutdown+0x4f>
  412242:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  412248:	b9 00 00 00 00       	mov    ecx,0x0
  41224d:	eb 05                	jmp    412254 <cos_hw_shutdown+0x54>
  41224f:	b9 01 00 00 00       	mov    ecx,0x1
  412254:	5d                   	pop    rbp
  412255:	5c                   	pop    rsp
	call_cap_op(hwc, CAPTBL_OP_HW_SHUTDOWN, 0, 0, 0, 0);
}
  412256:	5b                   	pop    rbx
  412257:	41 5c                	pop    r12
  412259:	5d                   	pop    rbp
  41225a:	c3                   	ret    
  41225b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000412260 <cos_hw_map>:

void *
cos_hw_map(struct cos_compinfo *ci, hwcap_t hwc, paddr_t pa, unsigned int len)
{
  412260:	f3 0f 1e fa          	endbr64 
  412264:	55                   	push   rbp
  412265:	48 89 e5             	mov    rbp,rsp
  412268:	41 57                	push   r15
  41226a:	41 56                	push   r14
  41226c:	41 55                	push   r13
  41226e:	41 54                	push   r12
  412270:	53                   	push   rbx
  412271:	48 83 ec 28          	sub    rsp,0x28
	size_t  sz, i;
	vaddr_t va;

	assert(ci && hwc && pa && len);
  412275:	48 85 ff             	test   rdi,rdi
  412278:	0f 84 f4 00 00 00    	je     412372 <cos_hw_map+0x112>
  41227e:	48 89 f3             	mov    rbx,rsi
  412281:	48 85 f6             	test   rsi,rsi
  412284:	0f 84 e8 00 00 00    	je     412372 <cos_hw_map+0x112>
  41228a:	49 89 d7             	mov    r15,rdx
  41228d:	48 85 d2             	test   rdx,rdx
  412290:	0f 84 dc 00 00 00    	je     412372 <cos_hw_map+0x112>
  412296:	85 c9                	test   ecx,ecx
  412298:	0f 84 d4 00 00 00    	je     412372 <cos_hw_map+0x112>

	sz = round_up_to_page(len);
  41229e:	89 c9                	mov    ecx,ecx
	va = __page_bump_valloc(ci, sz, PAGE_SIZE);
  4122a0:	ba 00 10 00 00       	mov    edx,0x1000
  4122a5:	49 89 fe             	mov    r14,rdi
	sz = round_up_to_page(len);
  4122a8:	48 81 c1 ff 0f 00 00 	add    rcx,0xfff
  4122af:	48 81 e1 00 f0 ff ff 	and    rcx,0xfffffffffffff000
  4122b6:	48 89 ce             	mov    rsi,rcx
  4122b9:	48 89 4d b8          	mov    QWORD PTR [rbp-0x48],rcx
	va = __page_bump_valloc(ci, sz, PAGE_SIZE);
  4122bd:	e8 5e ac ff ff       	call   40cf20 <__page_bump_valloc>
  4122c2:	49 89 c5             	mov    r13,rax
	if (unlikely(!va)) return NULL;
  4122c5:	48 85 c0             	test   rax,rax
  4122c8:	0f 84 c0 00 00 00    	je     41238e <cos_hw_map+0x12e>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4122ce:	c1 e3 10             	shl    ebx,0x10

	for (i = 0; i < sz; i += PAGE_SIZE) {
  4122d1:	45 31 d2             	xor    r10d,r10d
	__asm__ __volatile__(
  4122d4:	31 d2                	xor    edx,edx
	cap_no += op;
  4122d6:	8d 83 2f 00 01 00    	lea    eax,[rbx+0x1002f]
  4122dc:	89 45 b4             	mov    DWORD PTR [rbp-0x4c],eax
  4122df:	eb 14                	jmp    4122f5 <cos_hw_map+0x95>
  4122e1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  4122e8:	49 81 c2 00 10 00 00 	add    r10,0x1000
  4122ef:	4c 39 55 b8          	cmp    QWORD PTR [rbp-0x48],r10
  4122f3:	76 6b                	jbe    412360 <cos_hw_map+0x100>
	__asm__ __volatile__(
  4122f5:	49 8b 1e             	mov    rbx,QWORD PTR [r14]
  4122f8:	8b 45 b4             	mov    eax,DWORD PTR [rbp-0x4c]
  4122fb:	4b 8d 34 2a          	lea    rsi,[r10+r13*1]
  4122ff:	4b 8d 3c 3a          	lea    rdi,[r10+r15*1]
  412303:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  412307:	48 89 29             	mov    QWORD PTR [rcx],rbp
  41230a:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  41230e:	48 89 cd             	mov    rbp,rcx
  412311:	49 b8 28 23 41 00 00 	movabs r8,0x412328
  412318:	00 00 00 
  41231b:	0f 05                	syscall 
  41231d:	0f 1f 00             	nop    DWORD PTR [rax]
  412320:	eb 0d                	jmp    41232f <cos_hw_map+0xcf>
  412322:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  412328:	b9 00 00 00 00       	mov    ecx,0x0
  41232d:	eb 05                	jmp    412334 <cos_hw_map+0xd4>
  41232f:	b9 01 00 00 00       	mov    ecx,0x1
  412334:	5d                   	pop    rbp
  412335:	5c                   	pop    rsp
		if (call_cap_op(hwc, CAPTBL_OP_HW_MAP, ci->pgtbl_cap, va + i, pa + i, 0)) BUG();
  412336:	85 c0                	test   eax,eax
  412338:	74 ae                	je     4122e8 <cos_hw_map+0x88>
  41233a:	be 1c 00 00 00       	mov    esi,0x1c
  41233f:	bf f8 d8 41 00       	mov    edi,0x41d8f8
  412344:	e8 87 7d ff ff       	call   40a0d0 <cos_print_str>
  412349:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412350:	00 00 00 00 
  412354:	0f 0b                	ud2    
  412356:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41235d:	00 00 00 
	}

	return (void *)va;
  412360:	4c 89 e8             	mov    rax,r13
}
  412363:	48 83 c4 28          	add    rsp,0x28
  412367:	5b                   	pop    rbx
  412368:	41 5c                	pop    r12
  41236a:	41 5d                	pop    r13
  41236c:	41 5e                	pop    r14
  41236e:	41 5f                	pop    r15
  412370:	5d                   	pop    rbp
  412371:	c3                   	ret    
  412372:	be 2f 00 00 00       	mov    esi,0x2f
  412377:	bf c8 d8 41 00       	mov    edi,0x41d8c8
  41237c:	e8 4f 7d ff ff       	call   40a0d0 <cos_print_str>
	assert(ci && hwc && pa && len);
  412381:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412388:	00 00 00 00 
  41238c:	0f 0b                	ud2    
	if (unlikely(!va)) return NULL;
  41238e:	31 c0                	xor    eax,eax
  412390:	eb d1                	jmp    412363 <cos_hw_map+0x103>
  412392:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  412399:	00 00 00 00 
  41239d:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004123a0 <cos_get_second_lvl>:


/* ----- Shared Pgtbl ------ */
int
cos_get_second_lvl(struct cos_compinfo *ci, capid_t *pgtbl_cap, vaddr_t *pgtbl_addr)
{
  4123a0:	f3 0f 1e fa          	endbr64 
	if(ci->mi.second_lvl_pgtbl_cap == 0) {
  4123a4:	48 8b 87 a0 00 00 00 	mov    rax,QWORD PTR [rdi+0xa0]
  4123ab:	48 85 c0             	test   rax,rax
  4123ae:	74 10                	je     4123c0 <cos_get_second_lvl+0x20>
		return -1;
	}
	*pgtbl_cap = ci->mi.second_lvl_pgtbl_cap;
  4123b0:	48 89 06             	mov    QWORD PTR [rsi],rax
	*pgtbl_addr = ci->mi.second_lvl_pgtbl_addr;
  4123b3:	48 8b 87 a8 00 00 00 	mov    rax,QWORD PTR [rdi+0xa8]
  4123ba:	48 89 02             	mov    QWORD PTR [rdx],rax

	return 0;
  4123bd:	31 c0                	xor    eax,eax
  4123bf:	c3                   	ret    
		return -1;
  4123c0:	b8 ff ff ff ff       	mov    eax,0xffffffff
}
  4123c5:	c3                   	ret    
  4123c6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4123cd:	00 00 00 

00000000004123d0 <cos_cons_into_shared_pgtbl>:

u32_t
cos_cons_into_shared_pgtbl(struct cos_compinfo *ci, pgtblcap_t top_lvl)
{
  4123d0:	f3 0f 1e fa          	endbr64 
  4123d4:	55                   	push   rbp
  4123d5:	48 89 e5             	mov    rbp,rsp
  4123d8:	41 54                	push   r12
  4123da:	53                   	push   rbx
  4123db:	48 83 ec 10          	sub    rsp,0x10
	if(ci->mi.second_lvl_pgtbl_cap == 0) {
  4123df:	48 8b 9f a0 00 00 00 	mov    rbx,QWORD PTR [rdi+0xa0]
  4123e6:	48 85 db             	test   rbx,rbx
  4123e9:	0f 84 7d 00 00 00    	je     41246c <cos_cons_into_shared_pgtbl+0x9c>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4123ef:	c1 e6 10             	shl    esi,0x10
	__asm__ __volatile__(
  4123f2:	31 d2                	xor    edx,edx
  4123f4:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
	cap_no += op;
  4123f8:	8d 86 01 00 01 00    	lea    eax,[rsi+0x10001]
	__asm__ __volatile__(
  4123fe:	48 8b b7 a8 00 00 00 	mov    rsi,QWORD PTR [rdi+0xa8]
  412405:	48 89 d7             	mov    rdi,rdx
  412408:	48 89 29             	mov    QWORD PTR [rcx],rbp
  41240b:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  41240f:	48 89 cd             	mov    rbp,rcx
  412412:	49 b8 28 24 41 00 00 	movabs r8,0x412428
  412419:	00 00 00 
  41241c:	0f 05                	syscall 
  41241e:	66 90                	xchg   ax,ax
  412420:	eb 0d                	jmp    41242f <cos_cons_into_shared_pgtbl+0x5f>
  412422:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  412428:	b9 00 00 00 00       	mov    ecx,0x0
  41242d:	eb 05                	jmp    412434 <cos_cons_into_shared_pgtbl+0x64>
  41242f:	b9 01 00 00 00       	mov    ecx,0x1
  412434:	5d                   	pop    rbp
  412435:	5c                   	pop    rsp
	if (call_cap_op(top_lvl, CAPTBL_OP_CONS, pte_cap, pgtbl_addr, 0, 0)) {
		assert(0); /* race? */
		return -1;
	}

	return 0;
  412436:	45 31 c0             	xor    r8d,r8d
	if (call_cap_op(top_lvl, CAPTBL_OP_CONS, pte_cap, pgtbl_addr, 0, 0)) {
  412439:	85 c0                	test   eax,eax
  41243b:	75 13                	jne    412450 <cos_cons_into_shared_pgtbl+0x80>

}
  41243d:	48 83 c4 10          	add    rsp,0x10
  412441:	44 89 c0             	mov    eax,r8d
  412444:	5b                   	pop    rbx
  412445:	41 5c                	pop    r12
  412447:	5d                   	pop    rbp
  412448:	c3                   	ret    
  412449:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  412450:	be 2f 00 00 00       	mov    esi,0x2f
  412455:	bf 18 d9 41 00       	mov    edi,0x41d918
  41245a:	e8 71 7c ff ff       	call   40a0d0 <cos_print_str>
		assert(0); /* race? */
  41245f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412466:	00 00 00 00 
  41246a:	0f 0b                	ud2    
		return -1;
  41246c:	41 b8 ff ff ff ff    	mov    r8d,0xffffffff
  412472:	eb c9                	jmp    41243d <cos_cons_into_shared_pgtbl+0x6d>
  412474:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41247b:	00 00 00 
  41247e:	66 90                	xchg   ax,ax

0000000000412480 <slm_sched_fprr_execution>:
struct runqueue threads[NUM_CPU];

/* No RR based on execution, yet */
void
slm_sched_fprr_execution(struct slm_thd *t, cycles_t cycles)
{ return; }
  412480:	f3 0f 1e fa          	endbr64 
  412484:	c3                   	ret    
  412485:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41248c:	00 00 00 00 

0000000000412490 <slm_sched_fprr_schedule>:
	}
}

struct slm_thd *
slm_sched_fprr_schedule(void)
{
  412490:	f3 0f 1e fa          	endbr64 

#if ENABLE_DEBUG_INFO
	debug_dump_info();
#endif

	for (i = 0 ; i < SLM_FPRR_NPRIOS ; i++) {
  412494:	b8 c0 0a 5a 00       	mov    eax,0x5a0ac0
ps_list_head_init(struct ps_list_head *lh)
{ ps_list_ll_init(&lh->l); }

static inline int
ps_list_ll_empty(struct ps_list *l)
{ return l->n == l; }
  412499:	48 8b 38             	mov    rdi,QWORD PTR [rax]
		if (ps_list_head_empty(&prios[i])) continue;
  41249c:	48 39 f8             	cmp    rax,rdi
  41249f:	74 3f                	je     4124e0 <slm_sched_fprr_schedule+0x50>
}

static inline void
ps_list_ll_rem(struct ps_list *l)
{
	l->n->p = l->p;
  4124a1:	48 8b 0f             	mov    rcx,QWORD PTR [rdi]
  4124a4:	48 8b 57 08          	mov    rdx,QWORD PTR [rdi+0x8]
	l->p->n = l->n;
	l->p = l->n = l;
  4124a8:	66 48 0f 6e c7       	movq   xmm0,rdi
  4124ad:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
	l->n->p = l->p;
  4124b1:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
	l->p->n = l->n;
  4124b5:	48 89 0a             	mov    QWORD PTR [rdx],rcx
	l->p = l->n = l;
  4124b8:	0f 11 07             	movups XMMWORD PTR [rdi],xmm0
		/*
		 * We want to move the selected thread to the back of the list.
		 * Otherwise fprr won't be truly round robin
		 */
		ps_list_rem_d(t);
		ps_list_head_append_d(&prios[i], t);
  4124bb:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	new->n    = l->n;
  4124bf:	f3 0f 7e 00          	movq   xmm0,QWORD PTR [rax]
  4124c3:	66 48 0f 6e c8       	movq   xmm1,rax
  4124c8:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  4124cc:	0f 11 07             	movups XMMWORD PTR [rdi],xmm0
	l->n      = new;
  4124cf:	48 89 38             	mov    QWORD PTR [rax],rdi
	new->n->p = new;
  4124d2:	48 8b 07             	mov    rax,QWORD PTR [rdi]
  4124d5:	48 89 78 08          	mov    QWORD PTR [rax+0x8],rdi

//		printc("Schedule -> %ld\n", slm_thd_from_sched(t)->tid);
		return slm_thd_from_sched(t);
  4124d9:	e9 e2 f1 fe ff       	jmp    4016c0 <slm_thd_from_sched>
  4124de:	66 90                	xchg   ax,ax
	for (i = 0 ; i < SLM_FPRR_NPRIOS ; i++) {
  4124e0:	48 83 c0 10          	add    rax,0x10
  4124e4:	48 3d c0 0c 5a 00    	cmp    rax,0x5a0cc0
  4124ea:	75 ad                	jne    412499 <slm_sched_fprr_schedule+0x9>
	}
//	printc("Schedule -> idle\n");

	return NULL;
}
  4124ec:	31 c0                	xor    eax,eax
  4124ee:	c3                   	ret    
  4124ef:	90                   	nop

00000000004124f0 <slm_sched_fprr_block>:

int
slm_sched_fprr_block(struct slm_thd *t)
{
  4124f0:	f3 0f 1e fa          	endbr64 
  4124f4:	55                   	push   rbp
  4124f5:	48 89 e5             	mov    rbp,rsp
	struct slm_sched_thd *p = slm_thd_sched_policy(t);
  4124f8:	e8 a3 f1 fe ff       	call   4016a0 <slm_thd_sched_policy>
	l->n->p = l->p;
  4124fd:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  412500:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
	l->p = l->n = l;
  412504:	66 48 0f 6e c0       	movq   xmm0,rax
  412509:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
	l->n->p = l->p;
  41250d:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
	l->p->n = l->n;
  412511:	48 89 0a             	mov    QWORD PTR [rdx],rcx
	l->p = l->n = l;
  412514:	0f 11 00             	movups XMMWORD PTR [rax],xmm0

	ps_list_rem_d(p);

	return 0;
}
  412517:	31 c0                	xor    eax,eax
  412519:	5d                   	pop    rbp
  41251a:	c3                   	ret    
  41251b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000412520 <slm_sched_fprr_wakeup>:

int
slm_sched_fprr_wakeup(struct slm_thd *t)
{
  412520:	f3 0f 1e fa          	endbr64 
  412524:	55                   	push   rbp
  412525:	48 89 e5             	mov    rbp,rsp
  412528:	53                   	push   rbx
  412529:	48 89 fb             	mov    rbx,rdi
  41252c:	48 83 ec 08          	sub    rsp,0x8
	struct slm_sched_thd *p = slm_thd_sched_policy(t);
  412530:	e8 6b f1 fe ff       	call   4016a0 <slm_thd_sched_policy>

	assert(ps_list_singleton_d(p));
  412535:	48 3b 00             	cmp    rax,QWORD PTR [rax]
  412538:	75 31                	jne    41256b <slm_sched_fprr_wakeup+0x4b>

	ps_list_head_append_d(&threads[cos_cpuid()].prio[t->priority - 1], p);
  41253a:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]

	return 0;
}
  41253e:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
	ps_list_head_append_d(&threads[cos_cpuid()].prio[t->priority - 1], p);
  412542:	48 c1 e2 04          	shl    rdx,0x4
  412546:	48 8b 92 b8 0a 5a 00 	mov    rdx,QWORD PTR [rdx+0x5a0ab8]
	new->n    = l->n;
  41254d:	f3 0f 7e 02          	movq   xmm0,QWORD PTR [rdx]
  412551:	66 48 0f 6e ca       	movq   xmm1,rdx
  412556:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  41255a:	0f 11 00             	movups XMMWORD PTR [rax],xmm0
	l->n      = new;
  41255d:	48 89 02             	mov    QWORD PTR [rdx],rax
	new->n->p = new;
  412560:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  412563:	48 89 42 08          	mov    QWORD PTR [rdx+0x8],rax
}
  412567:	31 c0                	xor    eax,eax
  412569:	c9                   	leave  
  41256a:	c3                   	ret    
  41256b:	be 23 00 00 00       	mov    esi,0x23
  412570:	bf 68 d9 41 00       	mov    edi,0x41d968
  412575:	e8 56 7b ff ff       	call   40a0d0 <cos_print_str>
	assert(ps_list_singleton_d(p));
  41257a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412581:	00 00 00 00 
  412585:	0f 0b                	ud2    
  412587:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41258e:	00 00 

0000000000412590 <slm_sched_fprr_yield>:

void
slm_sched_fprr_yield(struct slm_thd *t, struct slm_thd *yield_to)
{
  412590:	f3 0f 1e fa          	endbr64 
  412594:	55                   	push   rbp
  412595:	48 89 e5             	mov    rbp,rsp
  412598:	53                   	push   rbx
  412599:	48 89 fb             	mov    rbx,rdi
  41259c:	48 83 ec 08          	sub    rsp,0x8
	struct slm_sched_thd *p = slm_thd_sched_policy(t);
  4125a0:	e8 fb f0 fe ff       	call   4016a0 <slm_thd_sched_policy>
	l->n->p = l->p;
  4125a5:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  4125a9:	48 8b 08             	mov    rcx,QWORD PTR [rax]
	l->p = l->n = l;
  4125ac:	66 48 0f 6e c0       	movq   xmm0,rax
  4125b1:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
	l->n->p = l->p;
  4125b5:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
	l->p->n = l->n;
  4125b9:	48 89 0a             	mov    QWORD PTR [rdx],rcx

	ps_list_rem_d(p);
	ps_list_head_append_d(&threads[cos_cpuid()].prio[t->priority], p);
  4125bc:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]
	l->p = l->n = l;
  4125c0:	0f 11 00             	movups XMMWORD PTR [rax],xmm0
}
  4125c3:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
	ps_list_head_append_d(&threads[cos_cpuid()].prio[t->priority], p);
  4125c7:	48 c1 e2 04          	shl    rdx,0x4
  4125cb:	48 8b 92 c8 0a 5a 00 	mov    rdx,QWORD PTR [rdx+0x5a0ac8]
	new->n    = l->n;
  4125d2:	f3 0f 7e 02          	movq   xmm0,QWORD PTR [rdx]
  4125d6:	66 48 0f 6e ca       	movq   xmm1,rdx
  4125db:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  4125df:	0f 11 00             	movups XMMWORD PTR [rax],xmm0
	l->n      = new;
  4125e2:	48 89 02             	mov    QWORD PTR [rdx],rax
	new->n->p = new;
  4125e5:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  4125e8:	48 89 42 08          	mov    QWORD PTR [rdx+0x8],rax
}
  4125ec:	c9                   	leave  
  4125ed:	c3                   	ret    
  4125ee:	66 90                	xchg   ax,ax

00000000004125f0 <slm_sched_fprr_thd_init>:

int
slm_sched_fprr_thd_init(struct slm_thd *t)
{
  4125f0:	f3 0f 1e fa          	endbr64 
  4125f4:	55                   	push   rbp
	t->priority = SLM_FPRR_PRIO_LOWEST;
  4125f5:	48 c7 47 30 1f 00 00 	mov    QWORD PTR [rdi+0x30],0x1f
  4125fc:	00 
{
  4125fd:	48 89 e5             	mov    rbp,rsp
	ps_list_init_d(slm_thd_sched_policy(t));
  412600:	e8 9b f0 fe ff       	call   4016a0 <slm_thd_sched_policy>
{ l->n = l->p = l; }
  412605:	66 48 0f 6e c0       	movq   xmm0,rax
  41260a:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  41260e:	0f 11 00             	movups XMMWORD PTR [rax],xmm0

	return 0;
}
  412611:	31 c0                	xor    eax,eax
  412613:	5d                   	pop    rbp
  412614:	c3                   	ret    
  412615:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41261c:	00 00 00 00 

0000000000412620 <slm_sched_fprr_thd_deinit>:

void
slm_sched_fprr_thd_deinit(struct slm_thd *t)
{
  412620:	f3 0f 1e fa          	endbr64 
  412624:	55                   	push   rbp
  412625:	48 89 e5             	mov    rbp,rsp
	ps_list_rem_d(slm_thd_sched_policy(t));
  412628:	e8 73 f0 fe ff       	call   4016a0 <slm_thd_sched_policy>
	l->n->p = l->p;
  41262d:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  412630:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
	l->p = l->n = l;
  412634:	66 48 0f 6e c0       	movq   xmm0,rax
  412639:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
	l->n->p = l->p;
  41263d:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
	l->p->n = l->n;
  412641:	48 89 0a             	mov    QWORD PTR [rdx],rcx
	l->p = l->n = l;
  412644:	0f 11 00             	movups XMMWORD PTR [rax],xmm0
}
  412647:	5d                   	pop    rbp
  412648:	c3                   	ret    
  412649:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000412650 <slm_sched_fprr_thd_update>:
	return;
}

int
slm_sched_fprr_thd_update(struct slm_thd *t, sched_param_type_t type, unsigned int v)
{
  412650:	f3 0f 1e fa          	endbr64 
  412654:	55                   	push   rbp
  412655:	48 89 e5             	mov    rbp,rsp
  412658:	41 54                	push   r12
  41265a:	49 89 fc             	mov    r12,rdi
  41265d:	53                   	push   rbx
	switch (type) {
  41265e:	83 fe 0a             	cmp    esi,0xa
  412661:	74 1d                	je     412680 <slm_sched_fprr_thd_update+0x30>
  412663:	83 fe 0b             	cmp    esi,0xb
  412666:	0f 84 b4 00 00 00    	je     412720 <slm_sched_fprr_thd_update+0xd0>
  41266c:	b8 ff ff ff ff       	mov    eax,0xffffffff
  412671:	83 fe 01             	cmp    esi,0x1
  412674:	74 5a                	je     4126d0 <slm_sched_fprr_thd_update+0x80>
	}
	/* Only support priority, for now */
	default:
		return -1;
	}
}
  412676:	5b                   	pop    rbx
  412677:	41 5c                	pop    r12
  412679:	5d                   	pop    rbp
  41267a:	c3                   	ret    
  41267b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	struct slm_sched_thd *p = slm_thd_sched_policy(t);
  412680:	e8 1b f0 fe ff       	call   4016a0 <slm_thd_sched_policy>
	t->priority = prio;
  412685:	49 c7 44 24 30 00 00 	mov    QWORD PTR [r12+0x30],0x0
  41268c:	00 00 
	l->n->p = l->p;
  41268e:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  412692:	48 8b 08             	mov    rcx,QWORD PTR [rax]
	l->p = l->n = l;
  412695:	66 48 0f 6e c0       	movq   xmm0,rax
  41269a:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
	l->n->p = l->p;
  41269e:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
	l->p->n = l->n;
  4126a2:	48 89 0a             	mov    QWORD PTR [rdx],rcx
	l->p = l->n = l;
  4126a5:	0f 11 00             	movups XMMWORD PTR [rax],xmm0
	ps_list_head_append_d(&threads[cos_cpuid()].prio[prio], p);
  4126a8:	48 8b 15 19 e4 18 00 	mov    rdx,QWORD PTR [rip+0x18e419]        # 5a0ac8 <threads+0x8>
	new->n    = l->n;
  4126af:	f3 0f 7e 02          	movq   xmm0,QWORD PTR [rdx]
  4126b3:	66 48 0f 6e ca       	movq   xmm1,rdx
  4126b8:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  4126bc:	0f 11 00             	movups XMMWORD PTR [rax],xmm0
	l->n      = new;
  4126bf:	48 89 02             	mov    QWORD PTR [rdx],rax
	new->n->p = new;
  4126c2:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  4126c5:	48 89 42 08          	mov    QWORD PTR [rdx+0x8],rax
		return 0;
  4126c9:	31 c0                	xor    eax,eax
}
  4126cb:	5b                   	pop    rbx
  4126cc:	41 5c                	pop    r12
  4126ce:	5d                   	pop    rbp
  4126cf:	c3                   	ret    
		assert(v >= SLM_FPRR_PRIO_HIGHEST && v <= SLM_FPRR_PRIO_LOWEST);
  4126d0:	8d 42 ff             	lea    eax,[rdx-0x1]
  4126d3:	83 f8 1e             	cmp    eax,0x1e
  4126d6:	0f 87 85 00 00 00    	ja     412761 <slm_sched_fprr_thd_update+0x111>
		update_queue(t, v);
  4126dc:	89 d3                	mov    ebx,edx
	struct slm_sched_thd *p = slm_thd_sched_policy(t);
  4126de:	e8 bd ef fe ff       	call   4016a0 <slm_thd_sched_policy>
	t->priority = prio;
  4126e3:	49 89 5c 24 30       	mov    QWORD PTR [r12+0x30],rbx
	ps_list_head_append_d(&threads[cos_cpuid()].prio[prio], p);
  4126e8:	48 c1 e3 04          	shl    rbx,0x4
	l->n->p = l->p;
  4126ec:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  4126f0:	48 8b 08             	mov    rcx,QWORD PTR [rax]
	l->p = l->n = l;
  4126f3:	66 48 0f 6e c0       	movq   xmm0,rax
  4126f8:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
	l->n->p = l->p;
  4126fc:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
	l->p->n = l->n;
  412700:	48 89 0a             	mov    QWORD PTR [rdx],rcx
	l->p = l->n = l;
  412703:	0f 11 00             	movups XMMWORD PTR [rax],xmm0
  412706:	48 8b 93 c8 0a 5a 00 	mov    rdx,QWORD PTR [rbx+0x5a0ac8]
	new->n    = l->n;
  41270d:	f3 0f 7e 02          	movq   xmm0,QWORD PTR [rdx]
  412711:	66 48 0f 6e da       	movq   xmm3,rdx
  412716:	66 0f 6c c3          	punpcklqdq xmm0,xmm3
  41271a:	eb a0                	jmp    4126bc <slm_sched_fprr_thd_update+0x6c>
  41271c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	struct slm_sched_thd *p = slm_thd_sched_policy(t);
  412720:	e8 7b ef fe ff       	call   4016a0 <slm_thd_sched_policy>
	t->priority = prio;
  412725:	49 c7 44 24 30 1f 00 	mov    QWORD PTR [r12+0x30],0x1f
  41272c:	00 00 
	l->n->p = l->p;
  41272e:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  412732:	48 8b 08             	mov    rcx,QWORD PTR [rax]
	l->p = l->n = l;
  412735:	66 48 0f 6e c0       	movq   xmm0,rax
  41273a:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
	l->n->p = l->p;
  41273e:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
	l->p->n = l->n;
  412742:	48 89 0a             	mov    QWORD PTR [rdx],rcx
	l->p = l->n = l;
  412745:	0f 11 00             	movups XMMWORD PTR [rax],xmm0
	ps_list_head_append_d(&threads[cos_cpuid()].prio[prio], p);
  412748:	48 8b 15 69 e5 18 00 	mov    rdx,QWORD PTR [rip+0x18e569]        # 5a0cb8 <threads+0x1f8>
	new->n    = l->n;
  41274f:	f3 0f 7e 02          	movq   xmm0,QWORD PTR [rdx]
  412753:	66 48 0f 6e d2       	movq   xmm2,rdx
  412758:	66 0f 6c c2          	punpcklqdq xmm0,xmm2
  41275c:	e9 5b ff ff ff       	jmp    4126bc <slm_sched_fprr_thd_update+0x6c>
  412761:	be 24 00 00 00       	mov    esi,0x24
  412766:	bf 90 d9 41 00       	mov    edi,0x41d990
  41276b:	e8 60 79 ff ff       	call   40a0d0 <cos_print_str>
		assert(v >= SLM_FPRR_PRIO_HIGHEST && v <= SLM_FPRR_PRIO_LOWEST);
  412770:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412777:	00 00 00 00 
  41277b:	0f 0b                	ud2    
  41277d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000412780 <slm_sched_fprr_init>:

void
slm_sched_fprr_init(void)
{
  412780:	f3 0f 1e fa          	endbr64 
{ l->n = l->p = l; }
  412784:	b8 c0 0a 5a 00       	mov    eax,0x5a0ac0
  412789:	66 48 0f 6e c0       	movq   xmm0,rax
	int i;

	for (i = 0 ; i < SLM_FPRR_NPRIOS ; i++) {
		ps_list_head_init(&threads[cos_cpuid()].prio[i]);
  41278e:	b8 d0 0a 5a 00       	mov    eax,0x5a0ad0
  412793:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  412797:	0f 29 05 22 e3 18 00 	movaps XMMWORD PTR [rip+0x18e322],xmm0        # 5a0ac0 <threads>
  41279e:	66 48 0f 6e c0       	movq   xmm0,rax
  4127a3:	b8 e0 0a 5a 00       	mov    eax,0x5a0ae0
  4127a8:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  4127ac:	0f 29 05 1d e3 18 00 	movaps XMMWORD PTR [rip+0x18e31d],xmm0        # 5a0ad0 <threads+0x10>
  4127b3:	66 48 0f 6e c0       	movq   xmm0,rax
  4127b8:	b8 f0 0a 5a 00       	mov    eax,0x5a0af0
  4127bd:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  4127c1:	0f 29 05 18 e3 18 00 	movaps XMMWORD PTR [rip+0x18e318],xmm0        # 5a0ae0 <threads+0x20>
  4127c8:	66 48 0f 6e c0       	movq   xmm0,rax
  4127cd:	b8 00 0b 5a 00       	mov    eax,0x5a0b00
  4127d2:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  4127d6:	0f 29 05 13 e3 18 00 	movaps XMMWORD PTR [rip+0x18e313],xmm0        # 5a0af0 <threads+0x30>
	for (i = 0 ; i < SLM_FPRR_NPRIOS ; i++) {
  4127dd:	66 48 0f 6e c0       	movq   xmm0,rax
		ps_list_head_init(&threads[cos_cpuid()].prio[i]);
  4127e2:	b8 10 0b 5a 00       	mov    eax,0x5a0b10
  4127e7:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  4127eb:	0f 29 05 0e e3 18 00 	movaps XMMWORD PTR [rip+0x18e30e],xmm0        # 5a0b00 <threads+0x40>
  4127f2:	66 48 0f 6e c0       	movq   xmm0,rax
  4127f7:	b8 20 0b 5a 00       	mov    eax,0x5a0b20
  4127fc:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  412800:	0f 29 05 09 e3 18 00 	movaps XMMWORD PTR [rip+0x18e309],xmm0        # 5a0b10 <threads+0x50>
  412807:	66 48 0f 6e c0       	movq   xmm0,rax
  41280c:	b8 30 0b 5a 00       	mov    eax,0x5a0b30
  412811:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  412815:	0f 29 05 04 e3 18 00 	movaps XMMWORD PTR [rip+0x18e304],xmm0        # 5a0b20 <threads+0x60>
  41281c:	66 48 0f 6e c0       	movq   xmm0,rax
  412821:	b8 40 0b 5a 00       	mov    eax,0x5a0b40
  412826:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  41282a:	0f 29 05 ff e2 18 00 	movaps XMMWORD PTR [rip+0x18e2ff],xmm0        # 5a0b30 <threads+0x70>
  412831:	66 48 0f 6e c0       	movq   xmm0,rax
  412836:	b8 50 0b 5a 00       	mov    eax,0x5a0b50
  41283b:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  41283f:	0f 29 05 fa e2 18 00 	movaps XMMWORD PTR [rip+0x18e2fa],xmm0        # 5a0b40 <threads+0x80>
  412846:	66 48 0f 6e c0       	movq   xmm0,rax
  41284b:	b8 60 0b 5a 00       	mov    eax,0x5a0b60
  412850:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  412854:	0f 29 05 f5 e2 18 00 	movaps XMMWORD PTR [rip+0x18e2f5],xmm0        # 5a0b50 <threads+0x90>
  41285b:	66 48 0f 6e c0       	movq   xmm0,rax
  412860:	b8 70 0b 5a 00       	mov    eax,0x5a0b70
  412865:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  412869:	0f 29 05 f0 e2 18 00 	movaps XMMWORD PTR [rip+0x18e2f0],xmm0        # 5a0b60 <threads+0xa0>
  412870:	66 48 0f 6e c0       	movq   xmm0,rax
  412875:	b8 80 0b 5a 00       	mov    eax,0x5a0b80
  41287a:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  41287e:	0f 29 05 eb e2 18 00 	movaps XMMWORD PTR [rip+0x18e2eb],xmm0        # 5a0b70 <threads+0xb0>
  412885:	66 48 0f 6e c0       	movq   xmm0,rax
  41288a:	b8 90 0b 5a 00       	mov    eax,0x5a0b90
  41288f:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  412893:	0f 29 05 e6 e2 18 00 	movaps XMMWORD PTR [rip+0x18e2e6],xmm0        # 5a0b80 <threads+0xc0>
  41289a:	66 48 0f 6e c0       	movq   xmm0,rax
  41289f:	b8 a0 0b 5a 00       	mov    eax,0x5a0ba0
  4128a4:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  4128a8:	0f 29 05 e1 e2 18 00 	movaps XMMWORD PTR [rip+0x18e2e1],xmm0        # 5a0b90 <threads+0xd0>
  4128af:	66 48 0f 6e c0       	movq   xmm0,rax
  4128b4:	b8 b0 0b 5a 00       	mov    eax,0x5a0bb0
  4128b9:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  4128bd:	0f 29 05 dc e2 18 00 	movaps XMMWORD PTR [rip+0x18e2dc],xmm0        # 5a0ba0 <threads+0xe0>
  4128c4:	66 48 0f 6e c0       	movq   xmm0,rax
  4128c9:	b8 c0 0b 5a 00       	mov    eax,0x5a0bc0
  4128ce:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  4128d2:	0f 29 05 d7 e2 18 00 	movaps XMMWORD PTR [rip+0x18e2d7],xmm0        # 5a0bb0 <threads+0xf0>
  4128d9:	66 48 0f 6e c0       	movq   xmm0,rax
  4128de:	b8 d0 0b 5a 00       	mov    eax,0x5a0bd0
  4128e3:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  4128e7:	0f 29 05 d2 e2 18 00 	movaps XMMWORD PTR [rip+0x18e2d2],xmm0        # 5a0bc0 <threads+0x100>
  4128ee:	66 48 0f 6e c0       	movq   xmm0,rax
  4128f3:	b8 e0 0b 5a 00       	mov    eax,0x5a0be0
  4128f8:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  4128fc:	0f 29 05 cd e2 18 00 	movaps XMMWORD PTR [rip+0x18e2cd],xmm0        # 5a0bd0 <threads+0x110>
  412903:	66 48 0f 6e c0       	movq   xmm0,rax
  412908:	b8 f0 0b 5a 00       	mov    eax,0x5a0bf0
  41290d:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  412911:	0f 29 05 c8 e2 18 00 	movaps XMMWORD PTR [rip+0x18e2c8],xmm0        # 5a0be0 <threads+0x120>
  412918:	66 48 0f 6e c0       	movq   xmm0,rax
  41291d:	b8 00 0c 5a 00       	mov    eax,0x5a0c00
  412922:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  412926:	0f 29 05 c3 e2 18 00 	movaps XMMWORD PTR [rip+0x18e2c3],xmm0        # 5a0bf0 <threads+0x130>
  41292d:	66 48 0f 6e c0       	movq   xmm0,rax
  412932:	b8 10 0c 5a 00       	mov    eax,0x5a0c10
  412937:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  41293b:	0f 29 05 be e2 18 00 	movaps XMMWORD PTR [rip+0x18e2be],xmm0        # 5a0c00 <threads+0x140>
  412942:	66 48 0f 6e c0       	movq   xmm0,rax
  412947:	b8 20 0c 5a 00       	mov    eax,0x5a0c20
  41294c:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  412950:	0f 29 05 b9 e2 18 00 	movaps XMMWORD PTR [rip+0x18e2b9],xmm0        # 5a0c10 <threads+0x150>
  412957:	66 48 0f 6e c0       	movq   xmm0,rax
  41295c:	b8 30 0c 5a 00       	mov    eax,0x5a0c30
  412961:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  412965:	0f 29 05 b4 e2 18 00 	movaps XMMWORD PTR [rip+0x18e2b4],xmm0        # 5a0c20 <threads+0x160>
  41296c:	66 48 0f 6e c0       	movq   xmm0,rax
  412971:	b8 40 0c 5a 00       	mov    eax,0x5a0c40
  412976:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  41297a:	0f 29 05 af e2 18 00 	movaps XMMWORD PTR [rip+0x18e2af],xmm0        # 5a0c30 <threads+0x170>
  412981:	66 48 0f 6e c0       	movq   xmm0,rax
  412986:	b8 50 0c 5a 00       	mov    eax,0x5a0c50
  41298b:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  41298f:	0f 29 05 aa e2 18 00 	movaps XMMWORD PTR [rip+0x18e2aa],xmm0        # 5a0c40 <threads+0x180>
  412996:	66 48 0f 6e c0       	movq   xmm0,rax
  41299b:	b8 60 0c 5a 00       	mov    eax,0x5a0c60
  4129a0:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  4129a4:	0f 29 05 a5 e2 18 00 	movaps XMMWORD PTR [rip+0x18e2a5],xmm0        # 5a0c50 <threads+0x190>
  4129ab:	66 48 0f 6e c0       	movq   xmm0,rax
  4129b0:	b8 70 0c 5a 00       	mov    eax,0x5a0c70
  4129b5:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  4129b9:	0f 29 05 a0 e2 18 00 	movaps XMMWORD PTR [rip+0x18e2a0],xmm0        # 5a0c60 <threads+0x1a0>
  4129c0:	66 48 0f 6e c0       	movq   xmm0,rax
  4129c5:	b8 80 0c 5a 00       	mov    eax,0x5a0c80
  4129ca:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  4129ce:	0f 29 05 9b e2 18 00 	movaps XMMWORD PTR [rip+0x18e29b],xmm0        # 5a0c70 <threads+0x1b0>
  4129d5:	66 48 0f 6e c0       	movq   xmm0,rax
  4129da:	b8 90 0c 5a 00       	mov    eax,0x5a0c90
  4129df:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  4129e3:	0f 29 05 96 e2 18 00 	movaps XMMWORD PTR [rip+0x18e296],xmm0        # 5a0c80 <threads+0x1c0>
  4129ea:	66 48 0f 6e c0       	movq   xmm0,rax
  4129ef:	b8 a0 0c 5a 00       	mov    eax,0x5a0ca0
  4129f4:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  4129f8:	0f 29 05 91 e2 18 00 	movaps XMMWORD PTR [rip+0x18e291],xmm0        # 5a0c90 <threads+0x1d0>
  4129ff:	66 48 0f 6e c0       	movq   xmm0,rax
  412a04:	b8 b0 0c 5a 00       	mov    eax,0x5a0cb0
  412a09:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  412a0d:	0f 29 05 8c e2 18 00 	movaps XMMWORD PTR [rip+0x18e28c],xmm0        # 5a0ca0 <threads+0x1e0>
  412a14:	66 48 0f 6e c0       	movq   xmm0,rax
  412a19:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  412a1d:	0f 29 05 8c e2 18 00 	movaps XMMWORD PTR [rip+0x18e28c],xmm0        # 5a0cb0 <threads+0x1f0>
	}
}
  412a24:	c3                   	ret    
  412a25:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  412a2c:	00 00 00 
  412a2f:	90                   	nop
#include <cos_debug.h>

/* Override this to do initialization before idle computation */
CWEAKSYMB void slm_idle_comp_initialization(void) { return; }
  412a30:	f3 0f 1e fa          	endbr64 
  412a34:	c3                   	ret    
  412a35:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  412a3c:	00 00 00 00 

0000000000412a40 <slm_idle_iteration>:
  412a40:	f3 0f 1e fa          	endbr64 
  412a44:	c3                   	ret    
  412a45:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  412a4c:	00 00 00 00 

0000000000412a50 <slm_idle>:
/* Override this to do repetitive computation in idle */
CWEAKSYMB void slm_idle_iteration(void) { return; }

void
slm_idle(void *d)
{
  412a50:	f3 0f 1e fa          	endbr64 
  412a54:	55                   	push   rbp
  412a55:	48 89 e5             	mov    rbp,rsp
	slm_idle_comp_initialization();
  412a58:	e8 d3 da fe ff       	call   400530 <slm_idle_comp_initialization>
  412a5d:	0f 1f 00             	nop    DWORD PTR [rax]

	while (1) {
		slm_idle_iteration();
  412a60:	e8 db ff ff ff       	call   412a40 <slm_idle_iteration>
	while (1) {
  412a65:	eb f9                	jmp    412a60 <slm_idle+0x10>
  412a67:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  412a6e:	00 00 

0000000000412a70 <__slm_timeout_update_idx>:
	return slm_thd_timer_policy((struct slm_thd *)a)->abs_wakeup <= slm_thd_timer_policy((struct slm_thd *)b)->abs_wakeup;
}

static void
__slm_timeout_update_idx(void *e, int pos)
{ slm_thd_timer_policy((struct slm_thd *)e)->timeout_idx = pos; }
  412a70:	f3 0f 1e fa          	endbr64 
  412a74:	55                   	push   rbp
  412a75:	48 89 e5             	mov    rbp,rsp
  412a78:	53                   	push   rbx
  412a79:	89 f3                	mov    ebx,esi
  412a7b:	48 83 ec 08          	sub    rsp,0x8
  412a7f:	e8 0c ec fe ff       	call   401690 <slm_thd_timer_policy>
  412a84:	89 18                	mov    DWORD PTR [rax],ebx
  412a86:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
  412a8a:	c9                   	leave  
  412a8b:	c3                   	ret    
  412a8c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000412a90 <__slm_timeout_compare_min>:
{
  412a90:	f3 0f 1e fa          	endbr64 
  412a94:	55                   	push   rbp
  412a95:	48 89 e5             	mov    rbp,rsp
  412a98:	41 54                	push   r12
  412a9a:	49 89 f4             	mov    r12,rsi
  412a9d:	53                   	push   rbx
	return slm_thd_timer_policy((struct slm_thd *)a)->abs_wakeup <= slm_thd_timer_policy((struct slm_thd *)b)->abs_wakeup;
  412a9e:	e8 ed eb fe ff       	call   401690 <slm_thd_timer_policy>
  412aa3:	4c 89 e7             	mov    rdi,r12
  412aa6:	48 8b 58 08          	mov    rbx,QWORD PTR [rax+0x8]
  412aaa:	e8 e1 eb fe ff       	call   401690 <slm_thd_timer_policy>
  412aaf:	48 3b 58 08          	cmp    rbx,QWORD PTR [rax+0x8]
}
  412ab3:	5b                   	pop    rbx
	return slm_thd_timer_policy((struct slm_thd *)a)->abs_wakeup <= slm_thd_timer_policy((struct slm_thd *)b)->abs_wakeup;
  412ab4:	0f 96 c0             	setbe  al
}
  412ab7:	41 5c                	pop    r12
  412ab9:	5d                   	pop    rbp
	return slm_thd_timer_policy((struct slm_thd *)a)->abs_wakeup <= slm_thd_timer_policy((struct slm_thd *)b)->abs_wakeup;
  412aba:	0f b6 c0             	movzx  eax,al
}
  412abd:	c3                   	ret    
  412abe:	66 90                	xchg   ax,ax

0000000000412ac0 <slm_timer_quantum_expire>:
{
  412ac0:	f3 0f 1e fa          	endbr64 
  412ac4:	55                   	push   rbp
  412ac5:	48 89 e5             	mov    rbp,rsp
  412ac8:	41 55                	push   r13
  412aca:	41 54                	push   r12
  412acc:	53                   	push   rbx
  412acd:	48 83 ec 08          	sub    rsp,0x8
	assert(now >= g->current_timeout);
  412ad1:	48 8b 15 d8 e2 18 00 	mov    rdx,QWORD PTR [rip+0x18e2d8]        # 5a0db0 <__timer_globals+0xf0>
  412ad8:	48 39 fa             	cmp    rdx,rdi
  412adb:	0f 87 2f 01 00 00    	ja     412c10 <slm_timer_quantum_expire+0x150>
	offset = (now - g->current_timeout) % g->period;
  412ae1:	48 8b 35 c0 e2 18 00 	mov    rsi,QWORD PTR [rip+0x18e2c0]        # 5a0da8 <__timer_globals+0xe8>
  412ae8:	48 89 f8             	mov    rax,rdi
  412aeb:	49 89 fd             	mov    r13,rdi
  412aee:	48 29 d0             	sub    rax,rdx
  412af1:	31 d2                	xor    edx,edx
  412af3:	48 f7 f6             	div    rsi
	next_timeout = now + (g->period - offset);
  412af6:	48 8d 0c 3e          	lea    rcx,[rsi+rdi*1]
  412afa:	48 89 c8             	mov    rax,rcx
  412afd:	48 29 d0             	sub    rax,rdx
	assert(next_timeout > now);
  412b00:	48 39 c7             	cmp    rdi,rax
  412b03:	0f 83 23 01 00 00    	jae    412c2c <slm_timer_quantum_expire+0x16c>
slm_timeout_set(cycles_t timeout)
{
	struct slm_global *g = slm_global();

	g->timeout_next = tcap_cyc2time(timeout);
	g->timer_next   = timeout;
  412b09:	48 85 c0             	test   rax,rax
  412b0c:	ba 01 00 00 00       	mov    edx,0x1
  412b11:	66 48 0f 6e c0       	movq   xmm0,rax
	while (heap_size(&g->h) > 0) {
  412b16:	bf c0 0c 5a 00       	mov    edi,0x5a0cc0
  412b1b:	48 0f 45 d0          	cmovne rdx,rax
	g->current_timeout = next_timeout;
  412b1f:	48 89 05 8a e2 18 00 	mov    QWORD PTR [rip+0x18e28a],rax        # 5a0db0 <__timer_globals+0xf0>
	g->timer_set    = 1;
  412b26:	c7 05 4c f4 18 00 01 	mov    DWORD PTR [rip+0x18f44c],0x1        # 5a1f7c <__slm_global+0xfc>
  412b2d:	00 00 00 
	g->timer_next   = timeout;
  412b30:	66 48 0f 6e ca       	movq   xmm1,rdx
  412b35:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  412b39:	0f 29 05 40 f4 18 00 	movaps XMMWORD PTR [rip+0x18f440],xmm0        # 5a1f80 <__slm_global+0x100>
	while (heap_size(&g->h) > 0) {
  412b40:	e8 0b 22 00 00       	call   414d50 <heap_size>
  412b45:	85 c0                	test   eax,eax
  412b47:	7e 68                	jle    412bb1 <slm_timer_quantum_expire+0xf1>
		tp = heap_peek(&g->h);
  412b49:	bf c0 0c 5a 00       	mov    edi,0x5a0cc0
  412b4e:	e8 0d 1f 00 00       	call   414a60 <heap_peek>
  412b53:	49 89 c4             	mov    r12,rax
		assert(tp);
  412b56:	48 85 c0             	test   rax,rax
  412b59:	74 7d                	je     412bd8 <slm_timer_quantum_expire+0x118>
		tt = slm_thd_timer_policy(tp);
  412b5b:	48 89 c7             	mov    rdi,rax
  412b5e:	e8 2d eb fe ff       	call   401690 <slm_thd_timer_policy>
  412b63:	48 89 c3             	mov    rbx,rax
		assert(tt && tt->timeout_idx > 0);
  412b66:	48 85 c0             	test   rax,rax
  412b69:	74 51                	je     412bbc <slm_timer_quantum_expire+0xfc>
  412b6b:	8b 00                	mov    eax,DWORD PTR [rax]
  412b6d:	85 c0                	test   eax,eax
  412b6f:	7e 4b                	jle    412bbc <slm_timer_quantum_expire+0xfc>
	return (s64_t)(g - l) > 0;
  412b71:	48 8b 43 08          	mov    rax,QWORD PTR [rbx+0x8]
  412b75:	4c 29 e8             	sub    rax,r13
		if (cycles_greater_than(tt->abs_wakeup, now)) break;
  412b78:	48 85 c0             	test   rax,rax
  412b7b:	7f 34                	jg     412bb1 <slm_timer_quantum_expire+0xf1>
		th = heap_highest(&g->h);
  412b7d:	bf c0 0c 5a 00       	mov    edi,0x5a0cc0
  412b82:	e8 59 1d 00 00       	call   4148e0 <heap_highest>
		assert(th == tp);
  412b87:	49 39 c4             	cmp    r12,rax
  412b8a:	75 68                	jne    412bf4 <slm_timer_quantum_expire+0x134>
		tt->timeout_idx = -1;
  412b8c:	c7 03 ff ff ff ff    	mov    DWORD PTR [rbx],0xffffffff
		slm_thd_wakeup(th, 1);
  412b92:	4c 89 e7             	mov    rdi,r12
  412b95:	be 01 00 00 00       	mov    esi,0x1
		tt->abs_wakeup  = now;
  412b9a:	4c 89 6b 08          	mov    QWORD PTR [rbx+0x8],r13
		slm_thd_wakeup(th, 1);
  412b9e:	e8 8d 12 00 00       	call   413e30 <slm_thd_wakeup>
	while (heap_size(&g->h) > 0) {
  412ba3:	bf c0 0c 5a 00       	mov    edi,0x5a0cc0
  412ba8:	e8 a3 21 00 00       	call   414d50 <heap_size>
  412bad:	85 c0                	test   eax,eax
  412baf:	7f 98                	jg     412b49 <slm_timer_quantum_expire+0x89>
}
  412bb1:	48 83 c4 08          	add    rsp,0x8
  412bb5:	5b                   	pop    rbx
  412bb6:	41 5c                	pop    r12
  412bb8:	41 5d                	pop    r13
  412bba:	5d                   	pop    rbp
  412bbb:	c3                   	ret    
  412bbc:	be 26 00 00 00       	mov    esi,0x26
  412bc1:	bf 30 da 41 00       	mov    edi,0x41da30
  412bc6:	e8 05 75 ff ff       	call   40a0d0 <cos_print_str>
		assert(tt && tt->timeout_idx > 0);
  412bcb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412bd2:	00 00 00 00 
  412bd6:	0f 0b                	ud2    
  412bd8:	be 26 00 00 00       	mov    esi,0x26
  412bdd:	bf 08 da 41 00       	mov    edi,0x41da08
  412be2:	e8 e9 74 ff ff       	call   40a0d0 <cos_print_str>
		assert(tp);
  412be7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412bee:	00 00 00 00 
  412bf2:	0f 0b                	ud2    
  412bf4:	be 26 00 00 00       	mov    esi,0x26
  412bf9:	bf 58 da 41 00       	mov    edi,0x41da58
  412bfe:	e8 cd 74 ff ff       	call   40a0d0 <cos_print_str>
		assert(th == tp);
  412c03:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412c0a:	00 00 00 00 
  412c0e:	0f 0b                	ud2    
  412c10:	be 26 00 00 00       	mov    esi,0x26
  412c15:	bf b8 d9 41 00       	mov    edi,0x41d9b8
  412c1a:	e8 b1 74 ff ff       	call   40a0d0 <cos_print_str>
	assert(now >= g->current_timeout);
  412c1f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412c26:	00 00 00 00 
  412c2a:	0f 0b                	ud2    
  412c2c:	be 26 00 00 00       	mov    esi,0x26
  412c31:	bf e0 d9 41 00       	mov    edi,0x41d9e0
  412c36:	e8 95 74 ff ff       	call   40a0d0 <cos_print_str>
	assert(next_timeout > now);
  412c3b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412c42:	00 00 00 00 
  412c46:	0f 0b                	ud2    
  412c48:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  412c4f:	00 

0000000000412c50 <slm_timer_quantum_add>:
{
  412c50:	f3 0f 1e fa          	endbr64 
  412c54:	55                   	push   rbp
  412c55:	48 89 e5             	mov    rbp,rsp
  412c58:	41 55                	push   r13
  412c5a:	49 89 f5             	mov    r13,rsi
  412c5d:	41 54                	push   r12
  412c5f:	49 89 fc             	mov    r12,rdi
  412c62:	53                   	push   rbx
  412c63:	48 83 ec 08          	sub    rsp,0x8
	struct slm_timer_thd *tt = slm_thd_timer_policy(t);
  412c67:	e8 24 ea fe ff       	call   401690 <slm_thd_timer_policy>
	assert(tt && tt->timeout_idx == -1);
  412c6c:	48 85 c0             	test   rax,rax
  412c6f:	74 35                	je     412ca6 <slm_timer_quantum_add+0x56>
  412c71:	83 38 ff             	cmp    DWORD PTR [rax],0xffffffff
  412c74:	48 89 c3             	mov    rbx,rax
  412c77:	75 2d                	jne    412ca6 <slm_timer_quantum_add+0x56>
	assert(heap_size(&g->h) < MAX_NUM_THREADS);
  412c79:	bf c0 0c 5a 00       	mov    edi,0x5a0cc0
  412c7e:	e8 cd 20 00 00       	call   414d50 <heap_size>
  412c83:	83 f8 18             	cmp    eax,0x18
  412c86:	7f 3a                	jg     412cc2 <slm_timer_quantum_add+0x72>
	tt->abs_wakeup = absolute_timeout;
  412c88:	4c 89 6b 08          	mov    QWORD PTR [rbx+0x8],r13
	heap_add(&g->h, t);
  412c8c:	4c 89 e6             	mov    rsi,r12
  412c8f:	bf c0 0c 5a 00       	mov    edi,0x5a0cc0
  412c94:	e8 17 1a 00 00       	call   4146b0 <heap_add>
}
  412c99:	48 83 c4 08          	add    rsp,0x8
  412c9d:	31 c0                	xor    eax,eax
  412c9f:	5b                   	pop    rbx
  412ca0:	41 5c                	pop    r12
  412ca2:	41 5d                	pop    r13
  412ca4:	5d                   	pop    rbp
  412ca5:	c3                   	ret    
  412ca6:	be 26 00 00 00       	mov    esi,0x26
  412cab:	bf 80 da 41 00       	mov    edi,0x41da80
  412cb0:	e8 1b 74 ff ff       	call   40a0d0 <cos_print_str>
	assert(tt && tt->timeout_idx == -1);
  412cb5:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412cbc:	00 00 00 00 
  412cc0:	0f 0b                	ud2    
  412cc2:	be 26 00 00 00       	mov    esi,0x26
  412cc7:	bf a8 da 41 00       	mov    edi,0x41daa8
  412ccc:	e8 ff 73 ff ff       	call   40a0d0 <cos_print_str>
	assert(heap_size(&g->h) < MAX_NUM_THREADS);
  412cd1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412cd8:	00 00 00 00 
  412cdc:	0f 0b                	ud2    
  412cde:	66 90                	xchg   ax,ax

0000000000412ce0 <slm_timer_quantum_cancel>:
{
  412ce0:	f3 0f 1e fa          	endbr64 
  412ce4:	55                   	push   rbp
  412ce5:	48 89 e5             	mov    rbp,rsp
  412ce8:	53                   	push   rbx
  412ce9:	48 83 ec 08          	sub    rsp,0x8
	struct slm_timer_thd *tt = slm_thd_timer_policy(t);
  412ced:	e8 9e e9 fe ff       	call   401690 <slm_thd_timer_policy>
	if (tt->timeout_idx == -1) return 0;
  412cf2:	83 38 ff             	cmp    DWORD PTR [rax],0xffffffff
  412cf5:	74 27                	je     412d1e <slm_timer_quantum_cancel+0x3e>
	assert(heap_size(&g->h));
  412cf7:	bf c0 0c 5a 00       	mov    edi,0x5a0cc0
  412cfc:	48 89 c3             	mov    rbx,rax
  412cff:	e8 4c 20 00 00       	call   414d50 <heap_size>
  412d04:	85 c0                	test   eax,eax
  412d06:	74 1e                	je     412d26 <slm_timer_quantum_cancel+0x46>
	assert(tt->timeout_idx > 0);
  412d08:	8b 33                	mov    esi,DWORD PTR [rbx]
  412d0a:	85 f6                	test   esi,esi
  412d0c:	7e 34                	jle    412d42 <slm_timer_quantum_cancel+0x62>
	heap_remove(&g->h, tt->timeout_idx);
  412d0e:	bf c0 0c 5a 00       	mov    edi,0x5a0cc0
  412d13:	e8 68 1f 00 00       	call   414c80 <heap_remove>
	tt->timeout_idx = -1;
  412d18:	c7 03 ff ff ff ff    	mov    DWORD PTR [rbx],0xffffffff
}
  412d1e:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
  412d22:	31 c0                	xor    eax,eax
  412d24:	c9                   	leave  
  412d25:	c3                   	ret    
  412d26:	be 27 00 00 00       	mov    esi,0x27
  412d2b:	bf d0 da 41 00       	mov    edi,0x41dad0
  412d30:	e8 9b 73 ff ff       	call   40a0d0 <cos_print_str>
	assert(heap_size(&g->h));
  412d35:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412d3c:	00 00 00 00 
  412d40:	0f 0b                	ud2    
  412d42:	be 27 00 00 00       	mov    esi,0x27
  412d47:	bf f8 da 41 00       	mov    edi,0x41daf8
  412d4c:	e8 7f 73 ff ff       	call   40a0d0 <cos_print_str>
	assert(tt->timeout_idx > 0);
  412d51:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412d58:	00 00 00 00 
  412d5c:	0f 0b                	ud2    
  412d5e:	66 90                	xchg   ax,ax

0000000000412d60 <slm_timer_quantum_thd_init>:
{
  412d60:	f3 0f 1e fa          	endbr64 
  412d64:	55                   	push   rbp
  412d65:	48 89 e5             	mov    rbp,rsp
	struct slm_timer_thd *tt = slm_thd_timer_policy(t);
  412d68:	e8 23 e9 fe ff       	call   401690 <slm_thd_timer_policy>
	*tt = (struct slm_timer_thd){
  412d6d:	c7 00 ff ff ff ff    	mov    DWORD PTR [rax],0xffffffff
  412d73:	48 c7 40 08 00 00 00 	mov    QWORD PTR [rax+0x8],0x0
  412d7a:	00 
}
  412d7b:	31 c0                	xor    eax,eax
  412d7d:	5d                   	pop    rbp
  412d7e:	c3                   	ret    
  412d7f:	90                   	nop

0000000000412d80 <slm_timer_quantum_thd_deinit>:
{
  412d80:	f3 0f 1e fa          	endbr64 
}
  412d84:	c3                   	ret    
  412d85:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  412d8c:	00 00 00 00 

0000000000412d90 <slm_timer_quantum_init>:
	slm_timeout_set(next_timeout);
}

int
slm_timer_quantum_init(void)
{
  412d90:	f3 0f 1e fa          	endbr64 
	memset(g, 0, sizeof(struct timer_global));
  412d94:	ba c0 0c 5a 00       	mov    edx,0x5a0cc0
  412d99:	31 c0                	xor    eax,eax
  412d9b:	b9 20 00 00 00       	mov    ecx,0x20
{
  412da0:	55                   	push   rbp
	memset(g, 0, sizeof(struct timer_global));
  412da1:	48 89 d7             	mov    rdi,rdx
	heap_init(&g->h, MAX_NUM_THREADS, __slm_timeout_compare_min, __slm_timeout_update_idx);
  412da4:	be 19 00 00 00       	mov    esi,0x19
  412da9:	ba 90 2a 41 00       	mov    edx,0x412a90
	memset(g, 0, sizeof(struct timer_global));
  412dae:	f3 48 ab             	rep stos QWORD PTR es:[rdi],rax
	return usec * slm_global()->cyc_per_usec;
  412db1:	48 63 05 c0 f1 18 00 	movsxd rax,DWORD PTR [rip+0x18f1c0]        # 5a1f78 <__slm_global+0xf8>
	heap_init(&g->h, MAX_NUM_THREADS, __slm_timeout_compare_min, __slm_timeout_update_idx);
  412db8:	b9 70 2a 41 00       	mov    ecx,0x412a70
  412dbd:	bf c0 0c 5a 00       	mov    edi,0x5a0cc0
{
  412dc2:	48 89 e5             	mov    rbp,rsp
  412dc5:	48 69 c0 10 27 00 00 	imul   rax,rax,0x2710
	g->period = slm_usec2cyc(period);
  412dcc:	48 89 05 d5 df 18 00 	mov    QWORD PTR [rip+0x18dfd5],rax        # 5a0da8 <__timer_globals+0xe8>
	heap_init(&g->h, MAX_NUM_THREADS, __slm_timeout_compare_min, __slm_timeout_update_idx);
  412dd3:	e8 38 18 00 00       	call   414610 <heap_init>
	__asm__ __volatile__("rdtsc" : "=a" (a), "=d" (d), "=c" (c) : : );
  412dd8:	0f 31                	rdtsc  
	g->timer_set    = 1;
  412dda:	c7 05 98 f1 18 00 01 	mov    DWORD PTR [rip+0x18f198],0x1        # 5a1f7c <__slm_global+0xfc>
  412de1:	00 00 00 
	return ((u64_t)d << 32) | (u64_t)a;
  412de4:	48 c1 e2 20          	shl    rdx,0x20
	/* 10ms */
	slm_policy_timer_init(10000);

	return 0;
}
  412de8:	5d                   	pop    rbp
  412de9:	48 09 c2             	or     rdx,rax
	next_timeout = slm_now() + g->period;
  412dec:	48 89 d0             	mov    rax,rdx
	g->timer_next   = timeout;
  412def:	ba 01 00 00 00       	mov    edx,0x1
  412df4:	48 03 05 ad df 18 00 	add    rax,QWORD PTR [rip+0x18dfad]        # 5a0da8 <__timer_globals+0xe8>
  412dfb:	48 0f 45 d0          	cmovne rdx,rax
  412dff:	66 48 0f 6e c0       	movq   xmm0,rax
	g->current_timeout = next_timeout;
  412e04:	48 89 05 a5 df 18 00 	mov    QWORD PTR [rip+0x18dfa5],rax        # 5a0db0 <__timer_globals+0xf0>
}
  412e0b:	31 c0                	xor    eax,eax
  412e0d:	66 48 0f 6e ca       	movq   xmm1,rdx
  412e12:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  412e16:	0f 29 05 63 f1 18 00 	movaps XMMWORD PTR [rip+0x18f163],xmm0        # 5a1f80 <__slm_global+0x100>
  412e1d:	c3                   	ret    
  412e1e:	66 90                	xchg   ax,ax

0000000000412e20 <prints.isra.0>:
prints(char *s)
  412e20:	55                   	push   rbp
  412e21:	48 89 e5             	mov    rbp,rsp
  412e24:	41 54                	push   r12
  412e26:	49 89 fc             	mov    r12,rdi
  412e29:	48 83 ec 08          	sub    rsp,0x8
	return cos_print_str(s, strlen(s));
  412e2d:	e8 3e 29 00 00       	call   415770 <strlen>
  412e32:	4c 89 e7             	mov    rdi,r12
}
  412e35:	4c 8b 65 f8          	mov    r12,QWORD PTR [rbp-0x8]
  412e39:	c9                   	leave  
	return cos_print_str(s, strlen(s));
  412e3a:	89 c6                	mov    esi,eax
  412e3c:	e9 8f 72 ff ff       	jmp    40a0d0 <cos_print_str>
  412e41:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  412e48:	00 00 00 00 
  412e4c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000412e50 <slm_sched_loop_intern>:
	return (unsigned long)g->cyc_per_usec;
}

static void
slm_sched_loop_intern(int non_block)
{
  412e50:	55                   	push   rbp
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  412e51:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  412e54:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  412e5a:	48 89 e5             	mov    rbp,rsp
  412e5d:	41 57                	push   r15
  412e5f:	41 56                	push   r14
  412e61:	41 55                	push   r13
  412e63:	41 54                	push   r12
  412e65:	53                   	push   rbx
  412e66:	48 83 ec 38          	sub    rsp,0x38
	return cos_get_thd_id();
  412e6a:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
	rcv_flags_t      rfl = (non_block ? RCV_NON_BLOCKING : 0) | RCV_ALL_PENDING;
	struct slm_thd   *us = &g->sched_thd;
	struct slm_thd *t = NULL, *tn = NULL;

	/* Only the scheduler thread should call this function. */
	assert(cos_thdid() == us->tid);
  412e71:	48 39 05 28 f0 18 00 	cmp    QWORD PTR [rip+0x18f028],rax        # 5a1ea0 <__slm_global+0x20>
  412e78:	0f 85 a9 04 00 00    	jne    413327 <slm_sched_loop_intern+0x4d7>
  412e7e:	44 8d 67 02          	lea    r12d,[rdi+0x2]
  412e82:	4c 8d 7d c8          	lea    r15,[rbp-0x38]
	return !ps_cas(&cs->owner_contention, (unsigned long)cached, ((unsigned long)thd | !!contention));
  412e86:	bb 88 1e 5a 00       	mov    ebx,0x5a1e88
			 * if `non_block` is `0`.
			 *
			 * Important that this is *not* in the CS due
			 * to the potential blocking.
			 */
			pending = cos_sched_rcv(us->rcv, rfl, g->timeout_next, &rcvd, &tid, &blocked, &cycles, &thd_timeout);
  412e8b:	48 8d 45 c0          	lea    rax,[rbp-0x40]
  412e8f:	41 57                	push   r15
  412e91:	48 8b 3d 10 f0 18 00 	mov    rdi,QWORD PTR [rip+0x18f010]        # 5a1ea8 <__slm_global+0x28>
  412e98:	44 89 e6             	mov    esi,r12d
  412e9b:	50                   	push   rax
  412e9c:	48 8b 15 e5 f0 18 00 	mov    rdx,QWORD PTR [rip+0x18f0e5]        # 5a1f88 <__slm_global+0x108>
  412ea3:	48 8d 4d b4          	lea    rcx,[rbp-0x4c]
  412ea7:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  412eab:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  412eaf:	e8 9c e5 ff ff       	call   411450 <cos_sched_rcv>
			if (!tid) goto pending_events;
  412eb4:	48 8b 7d b8          	mov    rdi,QWORD PTR [rbp-0x48]
  412eb8:	59                   	pop    rcx
			pending = cos_sched_rcv(us->rcv, rfl, g->timeout_next, &rcvd, &tid, &blocked, &cycles, &thd_timeout);
  412eb9:	89 45 ac             	mov    DWORD PTR [rbp-0x54],eax
			if (!tid) goto pending_events;
  412ebc:	5e                   	pop    rsi
  412ebd:	48 85 ff             	test   rdi,rdi
  412ec0:	74 51                	je     412f13 <slm_sched_loop_intern+0xc3>
			 * pointer back here that we can use instead
			 * of the tid. This is the only place where
			 * slm requires the thread id -> thread
			 * mapping ;-(
			 */
			t = slm_thd_lookup(tid);
  412ec2:	e8 f9 e8 fe ff       	call   4017c0 <slm_thd_lookup>
			assert(t);
  412ec7:	48 85 c0             	test   rax,rax
  412eca:	0f 84 85 04 00 00    	je     413355 <slm_sched_loop_intern+0x505>
			/* don't report the idle thread or a freed thread */
			if (unlikely(t == &g->idle_thd || slm_state_is_dead(t->state))) goto pending_events;
  412ed0:	48 3d 00 1f 5a 00    	cmp    rax,0x5a1f00
  412ed6:	74 3b                	je     412f13 <slm_sched_loop_intern+0xc3>
  412ed8:	f7 40 04 fb ff ff ff 	test   DWORD PTR [rax+0x4],0xfffffffb
  412edf:	74 32                	je     412f13 <slm_sched_loop_intern+0xc3>
			 * allow the scheduler thread to switch to the
			 * CS holder, and switch back when the CS
			 * holder releases the CS (thus allowing the
			 * events to be processed at that point.
			 */
			slm_thd_event_enqueue(t, blocked, cycles, thd_timeout);
  412ee1:	48 8b 75 c8          	mov    rsi,QWORD PTR [rbp-0x38]
  412ee5:	48 8b 55 c0          	mov    rdx,QWORD PTR [rbp-0x40]
	if (ps_list_singleton(t, thd_list)) ps_list_head_append(&g->event_head, t, thd_list);
  412ee9:	48 8d 48 58          	lea    rcx,[rax+0x58]
			slm_thd_event_enqueue(t, blocked, cycles, thd_timeout);
  412eed:	8b 7d b0             	mov    edi,DWORD PTR [rbp-0x50]
	if (ps_list_singleton(t, thd_list)) ps_list_head_append(&g->event_head, t, thd_list);
  412ef0:	48 3b 48 58          	cmp    rcx,QWORD PTR [rax+0x58]
  412ef4:	0f 84 3d 03 00 00    	je     413237 <slm_sched_loop_intern+0x3e7>
	t->event_info.cycles += cycles;
  412efa:	48 03 50 48          	add    rdx,QWORD PTR [rax+0x48]
  412efe:	66 48 0f 6e ce       	movq   xmm1,rsi
	t->event_info.blocked = blocked;
  412f03:	89 78 40             	mov    DWORD PTR [rax+0x40],edi
	t->event_info.cycles += cycles;
  412f06:	66 48 0f 6e c2       	movq   xmm0,rdx
  412f0b:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  412f0f:	0f 11 40 48          	movups XMMWORD PTR [rax+0x48],xmm0

pending_events:
			/* No events? make a scheduling decision */
			if (ps_list_head_empty(&g->event_head)) break;
  412f13:	48 81 3d 72 f0 18 00 	cmp    QWORD PTR [rip+0x18f072],0x5a1f90        # 5a1f90 <__slm_global+0x110>
  412f1a:	90 1f 5a 00 
  412f1e:	0f 84 8c 01 00 00    	je     4130b0 <slm_sched_loop_intern+0x260>
		tok    = cos_sched_sync();
  412f24:	e8 d7 e3 ff ff       	call   411300 <cos_sched_sync>
  412f29:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  412f2b:	48 8b 05 4e ef 18 00 	mov    rax,QWORD PTR [rip+0x18ef4e]        # 5a1e80 <__slm_global>
		if (unlikely(owner)) {
  412f32:	48 89 c2             	mov    rdx,rax
  412f35:	48 83 e2 fe          	and    rdx,0xfffffffffffffffe
  412f39:	0f 85 21 03 00 00    	jne    413260 <slm_sched_loop_intern+0x410>
        __asm__ __volatile__("lock " PS_CAS_STR
  412f3f:	f0 48 0f b1 1d 38 ef 	lock cmpxchg QWORD PTR [rip+0x18ef38],rbx        # 5a1e80 <__slm_global>
  412f46:	18 00 
  412f48:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  412f4b:	84 c0                	test   al,al
  412f4d:	74 d5                	je     412f24 <slm_sched_loop_intern+0xd4>
			 *
			 * Thus we process the events now, with the CS taken.
			 */
			if (slm_cs_enter(us, SLM_CS_SCHEDEVT)) continue;

			ps_list_foreach_del(&g->event_head, t, tn, thd_list) {
  412f4f:	48 8b 15 3a f0 18 00 	mov    rdx,QWORD PTR [rip+0x18f03a]        # 5a1f90 <__slm_global+0x110>
  412f56:	48 8b 02             	mov    rax,QWORD PTR [rdx]
  412f59:	4c 8d 72 a8          	lea    r14,[rdx-0x58]
  412f5d:	4c 8d 68 a8          	lea    r13,[rax-0x58]
  412f61:	48 81 fa 90 1f 5a 00 	cmp    rdx,0x5a1f90
  412f68:	0f 84 e5 00 00 00    	je     413053 <slm_sched_loop_intern+0x203>
	l->n->p = l->p;
  412f6e:	49 8b 56 60          	mov    rdx,QWORD PTR [r14+0x60]
	ps_list_rem(t, thd_list);
  412f72:	49 8d 4e 58          	lea    rcx,[r14+0x58]
	*cycles  = t->event_info.cycles;
  412f76:	49 8b 76 48          	mov    rsi,QWORD PTR [r14+0x48]
	ps_list_rem(t, thd_list);
  412f7a:	66 48 0f 6e c1       	movq   xmm0,rcx
  412f7f:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
	l->p = l->n = l;
  412f83:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
	l->p->n = l->n;
  412f87:	48 89 02             	mov    QWORD PTR [rdx],rax
	*blocked = t->event_info.blocked;
  412f8a:	41 8b 46 40          	mov    eax,DWORD PTR [r14+0x40]
	l->p = l->n = l;
  412f8e:	41 0f 11 46 58       	movups XMMWORD PTR [r14+0x58],xmm0
	memset(&t->event_info, 0, sizeof(struct event_info));
  412f93:	66 0f ef c0          	pxor   xmm0,xmm0
	*blocked = t->event_info.blocked;
  412f97:	89 45 b0             	mov    DWORD PTR [rbp-0x50],eax
	*timeout = t->event_info.timeout;
  412f9a:	49 8b 46 50          	mov    rax,QWORD PTR [r14+0x50]
	*cycles  = t->event_info.cycles;
  412f9e:	48 89 75 c0          	mov    QWORD PTR [rbp-0x40],rsi
	*timeout = t->event_info.timeout;
  412fa2:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
	memset(&t->event_info, 0, sizeof(struct event_info));
  412fa6:	49 c7 46 50 00 00 00 	mov    QWORD PTR [r14+0x50],0x0
  412fad:	00 
  412fae:	41 0f 11 46 40       	movups XMMWORD PTR [r14+0x40],xmm0
				/* remove the event from the list and get event info */
				slm_thd_event_dequeue(t, &blocked, &cycles, &thd_timeout);

				/* outdated event for a freed thread */
				if (unlikely(slm_state_is_dead(t->state))) continue;
  412fb3:	41 f7 46 04 fb ff ff 	test   DWORD PTR [r14+0x4],0xfffffffb
  412fba:	ff 
  412fbb:	74 64                	je     413021 <slm_sched_loop_intern+0x1d1>

				/* Notify the policy that some execution has happened. */
				slm_sched_execution(t, cycles);
  412fbd:	4c 89 f7             	mov    rdi,r14
  412fc0:	e8 eb e7 fe ff       	call   4017b0 <slm_sched_execution>

				if (blocked) {
  412fc5:	8b 55 b0             	mov    edx,DWORD PTR [rbp-0x50]
  412fc8:	85 d2                	test   edx,edx
  412fca:	0f 84 cd 01 00 00    	je     41319d <slm_sched_loop_intern+0x34d>
					assert(cycles);
  412fd0:	48 83 7d c0 00       	cmp    QWORD PTR [rbp-0x40],0x0
  412fd5:	0f 84 63 03 00 00    	je     41333e <slm_sched_loop_intern+0x4ee>
	assert(slm_state_is_runnable(t->state) || t->state == SLM_THD_BLOCKED);
  412fdb:	41 8b 46 04          	mov    eax,DWORD PTR [r14+0x4]
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  412fdf:	8d 50 fe             	lea    edx,[rax-0x2]
  412fe2:	83 e8 01             	sub    eax,0x1
  412fe5:	83 f8 02             	cmp    eax,0x2
  412fe8:	0f 87 82 04 00 00    	ja     413470 <slm_sched_loop_intern+0x620>
	return t != &g->idle_thd && t != &g->sched_thd;
  412fee:	49 81 fe 00 1f 5a 00 	cmp    r14,0x5a1f00
  412ff5:	0f 84 20 02 00 00    	je     41321b <slm_sched_loop_intern+0x3cb>
  412ffb:	49 81 fe 88 1e 5a 00 	cmp    r14,0x5a1e88
  413002:	0f 84 13 02 00 00    	je     41321b <slm_sched_loop_intern+0x3cb>
	if (likely(slm_state_is_runnable(t->state))) {
  413008:	83 fa 01             	cmp    edx,0x1
  41300b:	77 08                	ja     413015 <slm_sched_loop_intern+0x1c5>
		slm_sched_block(t);
  41300d:	4c 89 f7             	mov    rdi,r14
  413010:	e8 5b e7 fe ff       	call   401770 <slm_sched_block>
	t->properties |= SLM_THD_PROPERTY_SUSPENDED;
  413015:	41 83 0e 04          	or     DWORD PTR [r14],0x4
	t->state       = SLM_THD_BLOCKED;
  413019:	41 c7 46 04 01 00 00 	mov    DWORD PTR [r14+0x4],0x1
  413020:	00 
			ps_list_foreach_del(&g->event_head, t, tn, thd_list) {
  413021:	49 8b 45 58          	mov    rax,QWORD PTR [r13+0x58]
  413025:	4d 89 ee             	mov    r14,r13
  413028:	48 8d 50 a8          	lea    rdx,[rax-0x58]
  41302c:	49 81 fd 38 1f 5a 00 	cmp    r13,0x5a1f38
  413033:	74 1e                	je     413053 <slm_sched_loop_intern+0x203>
  413035:	49 89 d5             	mov    r13,rdx
  413038:	e9 31 ff ff ff       	jmp    412f6e <slm_sched_loop_intern+0x11e>
  41303d:	0f 1f 00             	nop    DWORD PTR [rax]
  413040:	48 89 d0             	mov    rax,rdx
  413043:	f0 48 0f b1 35 34 ee 	lock cmpxchg QWORD PTR [rip+0x18ee34],rsi        # 5a1e80 <__slm_global>
  41304a:	18 00 
  41304c:	0f 94 c0             	sete   al
	while (ret != 0) {
  41304f:	84 c0                	test   al,al
  413051:	75 4a                	jne    41309d <slm_sched_loop_intern+0x24d>
		tok    = cos_sched_sync();
  413053:	e8 a8 e2 ff ff       	call   411300 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  413058:	48 8b 15 21 ee 18 00 	mov    rdx,QWORD PTR [rip+0x18ee21]        # 5a1e80 <__slm_global>
  41305f:	89 c1                	mov    ecx,eax
		if (unlikely(contention)) {
  413061:	48 89 d6             	mov    rsi,rdx
  413064:	83 e6 01             	and    esi,0x1
  413067:	74 d7                	je     413040 <slm_sched_loop_intern+0x1f0>
  413069:	31 ff                	xor    edi,edi
  41306b:	48 89 d0             	mov    rax,rdx
  41306e:	f0 48 0f b1 3d 09 ee 	lock cmpxchg QWORD PTR [rip+0x18ee09],rdi        # 5a1e80 <__slm_global>
  413075:	18 00 
  413077:	0f 94 c0             	sete   al
	if (__slm_cs_cas(cs, cached, NULL, 0)) return 1;
  41307a:	84 c0                	test   al,al
  41307c:	74 d5                	je     413053 <slm_sched_loop_intern+0x203>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  41307e:	48 83 e2 fe          	and    rdx,0xfffffffffffffffe
	ret = cos_defswitch(s->thd, curr->priority, TCAP_TIME_NIL, tok);
  413082:	48 8b 3d 0f ee 18 00 	mov    rdi,QWORD PTR [rip+0x18ee0f]        # 5a1e98 <__slm_global+0x18>
  413089:	48 8b 72 30          	mov    rsi,QWORD PTR [rdx+0x30]
  41308d:	31 d2                	xor    edx,edx
  41308f:	e8 cc 96 ff ff       	call   40c760 <cos_defswitch>
	assert(ret != -EINVAL);
  413094:	83 f8 ea             	cmp    eax,0xffffffea
  413097:	0f 84 e4 00 00 00    	je     413181 <slm_sched_loop_intern+0x331>
					slm_thd_sched_wakeup(t);
				}
			}

			slm_cs_exit(us, SLM_CS_NONE);
		} while (pending > 0);
  41309d:	8b 45 ac             	mov    eax,DWORD PTR [rbp-0x54]
  4130a0:	85 c0                	test   eax,eax
  4130a2:	0f 8f e3 fd ff ff    	jg     412e8b <slm_sched_loop_intern+0x3b>
  4130a8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4130af:	00 
		tok    = cos_sched_sync();
  4130b0:	e8 4b e2 ff ff       	call   411300 <cos_sched_sync>
  4130b5:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4130b7:	48 8b 05 c2 ed 18 00 	mov    rax,QWORD PTR [rip+0x18edc2]        # 5a1e80 <__slm_global>
		if (unlikely(owner)) {
  4130be:	48 89 c2             	mov    rdx,rax
  4130c1:	48 83 e2 fe          	and    rdx,0xfffffffffffffffe
  4130c5:	0f 85 11 01 00 00    	jne    4131dc <slm_sched_loop_intern+0x38c>
  4130cb:	f0 48 0f b1 1d ac ed 	lock cmpxchg QWORD PTR [rip+0x18edac],rbx        # 5a1e80 <__slm_global>
  4130d2:	18 00 
  4130d4:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4130d7:	84 c0                	test   al,al
  4130d9:	74 d5                	je     4130b0 <slm_sched_loop_intern+0x260>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  4130db:	e8 80 87 ff ff       	call   40b860 <cos_defcompinfo_curr_get>
	tok  = cos_sched_sync();
  4130e0:	e8 1b e2 ff ff       	call   411300 <cos_sched_sync>
	if (flags & SLM_CS_CHECK_TIMEOUT && g->timer_set) {
  4130e5:	83 3d 90 ee 18 00 00 	cmp    DWORD PTR [rip+0x18ee90],0x0        # 5a1f7c <__slm_global+0xfc>
	tok  = cos_sched_sync();
  4130ec:	41 89 c6             	mov    r14d,eax
	if (flags & SLM_CS_CHECK_TIMEOUT && g->timer_set) {
  4130ef:	0f 85 77 02 00 00    	jne    41336c <slm_sched_loop_intern+0x51c>
	t = slm_sched_schedule();
  4130f5:	e8 a6 e6 fe ff       	call   4017a0 <slm_sched_schedule>
  4130fa:	49 89 c5             	mov    r13,rax
	if (unlikely(!t)) t = &g->idle_thd;
  4130fd:	48 85 c0             	test   rax,rax
  413100:	0f 84 de 02 00 00    	je     4133e4 <slm_sched_loop_intern+0x594>
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  413106:	41 8b 45 04          	mov    eax,DWORD PTR [r13+0x4]
  41310a:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  41310d:	83 f8 01             	cmp    eax,0x1
  413110:	76 25                	jbe    413137 <slm_sched_loop_intern+0x2e7>
  413112:	e9 b1 02 00 00       	jmp    4133c8 <slm_sched_loop_intern+0x578>
  413117:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41311e:	00 00 
  413120:	48 89 d0             	mov    rax,rdx
  413123:	f0 48 0f b1 35 54 ed 	lock cmpxchg QWORD PTR [rip+0x18ed54],rsi        # 5a1e80 <__slm_global>
  41312a:	18 00 
  41312c:	0f 94 c0             	sete   al
	while (ret != 0) {
  41312f:	84 c0                	test   al,al
  413131:	0f 85 68 01 00 00    	jne    41329f <slm_sched_loop_intern+0x44f>
		tok    = cos_sched_sync();
  413137:	e8 c4 e1 ff ff       	call   411300 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  41313c:	48 8b 15 3d ed 18 00 	mov    rdx,QWORD PTR [rip+0x18ed3d]        # 5a1e80 <__slm_global>
  413143:	89 c1                	mov    ecx,eax
		if (unlikely(contention)) {
  413145:	48 89 d6             	mov    rsi,rdx
  413148:	83 e6 01             	and    esi,0x1
  41314b:	74 d3                	je     413120 <slm_sched_loop_intern+0x2d0>
  41314d:	31 ff                	xor    edi,edi
  41314f:	48 89 d0             	mov    rax,rdx
  413152:	f0 48 0f b1 3d 25 ed 	lock cmpxchg QWORD PTR [rip+0x18ed25],rdi        # 5a1e80 <__slm_global>
  413159:	18 00 
  41315b:	0f 94 c0             	sete   al
	if (__slm_cs_cas(cs, cached, NULL, 0)) return 1;
  41315e:	84 c0                	test   al,al
  413160:	74 d5                	je     413137 <slm_sched_loop_intern+0x2e7>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  413162:	48 83 e2 fe          	and    rdx,0xfffffffffffffffe
	ret = cos_defswitch(s->thd, curr->priority, TCAP_TIME_NIL, tok);
  413166:	48 8b 3d 2b ed 18 00 	mov    rdi,QWORD PTR [rip+0x18ed2b]        # 5a1e98 <__slm_global+0x18>
  41316d:	48 8b 72 30          	mov    rsi,QWORD PTR [rdx+0x30]
  413171:	31 d2                	xor    edx,edx
  413173:	e8 e8 95 ff ff       	call   40c760 <cos_defswitch>
	assert(ret != -EINVAL);
  413178:	83 f8 ea             	cmp    eax,0xffffffea
  41317b:	0f 85 1e 01 00 00    	jne    41329f <slm_sched_loop_intern+0x44f>
  413181:	be 23 00 00 00       	mov    esi,0x23
  413186:	bf e8 db 41 00       	mov    edi,0x41dbe8
  41318b:	e8 40 6f ff ff       	call   40a0d0 <cos_print_str>
  413190:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413197:	00 00 00 00 
  41319b:	0f 0b                	ud2    
	if (unlikely(!(t->properties & SLM_THD_PROPERTY_SUSPENDED))) return 1;
  41319d:	41 8b 06             	mov    eax,DWORD PTR [r14]
  4131a0:	a8 04                	test   al,0x4
  4131a2:	0f 84 79 fe ff ff    	je     413021 <slm_sched_loop_intern+0x1d1>
	t->properties &= ~SLM_THD_PROPERTY_SUSPENDED;
  4131a8:	83 e0 fb             	and    eax,0xfffffffb
  4131ab:	41 89 06             	mov    DWORD PTR [r14],eax
	if (unlikely(slm_state_is_runnable(t->state))) {
  4131ae:	41 8b 46 04          	mov    eax,DWORD PTR [r14+0x4]
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  4131b2:	8d 50 fe             	lea    edx,[rax-0x2]
  4131b5:	83 fa 01             	cmp    edx,0x1
  4131b8:	0f 86 e1 01 00 00    	jbe    41339f <slm_sched_loop_intern+0x54f>
	assert(t->state == SLM_THD_BLOCKED);
  4131be:	83 e8 01             	sub    eax,0x1
  4131c1:	0f 85 e5 01 00 00    	jne    4133ac <slm_sched_loop_intern+0x55c>
	t->state = SLM_THD_RUNNABLE;
  4131c7:	41 c7 46 04 03 00 00 	mov    DWORD PTR [r14+0x4],0x3
  4131ce:	00 
	slm_sched_wakeup(t);
  4131cf:	4c 89 f7             	mov    rdi,r14
  4131d2:	e8 a9 e5 fe ff       	call   401780 <slm_sched_wakeup>
	return 0;
  4131d7:	e9 45 fe ff ff       	jmp    413021 <slm_sched_loop_intern+0x1d1>
	if (!contended) {
  4131dc:	a8 01                	test   al,0x1
  4131de:	75 1b                	jne    4131fb <slm_sched_loop_intern+0x3ab>
	return !ps_cas(&cs->owner_contention, (unsigned long)cached, ((unsigned long)thd | !!contention));
  4131e0:	48 89 d6             	mov    rsi,rdx
  4131e3:	48 83 ce 01          	or     rsi,0x1
  4131e7:	f0 48 0f b1 35 90 ec 	lock cmpxchg QWORD PTR [rip+0x18ec90],rsi        # 5a1e80 <__slm_global>
  4131ee:	18 00 
  4131f0:	0f 94 c0             	sete   al
		if (__slm_cs_cas(cs, cached, owner, 1)) return 1;
  4131f3:	84 c0                	test   al,al
  4131f5:	0f 84 b5 fe ff ff    	je     4130b0 <slm_sched_loop_intern+0x260>
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  4131fb:	48 8b 7a 10          	mov    rdi,QWORD PTR [rdx+0x10]
  4131ff:	48 8b 35 b2 ec 18 00 	mov    rsi,QWORD PTR [rip+0x18ecb2]        # 5a1eb8 <__slm_global+0x38>
  413206:	31 d2                	xor    edx,edx
  413208:	e8 53 95 ff ff       	call   40c760 <cos_defswitch>
			if (flags & SLM_CS_SCHEDEVT && ret == -EBUSY) return ret;
  41320d:	83 f8 f0             	cmp    eax,0xfffffff0
  413210:	0f 85 9a fe ff ff    	jne    4130b0 <slm_sched_loop_intern+0x260>
  413216:	e9 70 fc ff ff       	jmp    412e8b <slm_sched_loop_intern+0x3b>
  41321b:	be 23 00 00 00       	mov    esi,0x23
  413220:	bf f8 dc 41 00       	mov    edi,0x41dcf8
  413225:	e8 a6 6e ff ff       	call   40a0d0 <cos_print_str>
	assert(slm_thd_normal(t));
  41322a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413231:	00 00 00 00 
  413235:	0f 0b                	ud2    
	if (ps_list_singleton(t, thd_list)) ps_list_head_append(&g->event_head, t, thd_list);
  413237:	4c 8b 05 5a ed 18 00 	mov    r8,QWORD PTR [rip+0x18ed5a]        # 5a1f98 <__slm_global+0x118>
	new->n    = l->n;
  41323e:	f3 41 0f 7e 00       	movq   xmm0,QWORD PTR [r8]
  413243:	66 49 0f 6e d0       	movq   xmm2,r8
  413248:	66 0f 6c c2          	punpcklqdq xmm0,xmm2
  41324c:	0f 11 40 58          	movups XMMWORD PTR [rax+0x58],xmm0
	l->n      = new;
  413250:	49 89 08             	mov    QWORD PTR [r8],rcx
	new->n->p = new;
  413253:	4c 8b 40 58          	mov    r8,QWORD PTR [rax+0x58]
  413257:	49 89 48 08          	mov    QWORD PTR [r8+0x8],rcx
}
  41325b:	e9 9a fc ff ff       	jmp    412efa <slm_sched_loop_intern+0xaa>
	if (!contended) {
  413260:	a8 01                	test   al,0x1
  413262:	75 1b                	jne    41327f <slm_sched_loop_intern+0x42f>
  413264:	48 89 d6             	mov    rsi,rdx
  413267:	48 83 ce 01          	or     rsi,0x1
  41326b:	f0 48 0f b1 35 0c ec 	lock cmpxchg QWORD PTR [rip+0x18ec0c],rsi        # 5a1e80 <__slm_global>
  413272:	18 00 
  413274:	0f 94 c0             	sete   al
		if (__slm_cs_cas(cs, cached, owner, 1)) return 1;
  413277:	84 c0                	test   al,al
  413279:	0f 84 a5 fc ff ff    	je     412f24 <slm_sched_loop_intern+0xd4>
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  41327f:	48 8b 7a 10          	mov    rdi,QWORD PTR [rdx+0x10]
  413283:	48 8b 35 2e ec 18 00 	mov    rsi,QWORD PTR [rip+0x18ec2e]        # 5a1eb8 <__slm_global+0x38>
  41328a:	31 d2                	xor    edx,edx
  41328c:	e8 cf 94 ff ff       	call   40c760 <cos_defswitch>
  413291:	83 f8 f0             	cmp    eax,0xfffffff0
  413294:	0f 85 8a fc ff ff    	jne    412f24 <slm_sched_loop_intern+0xd4>
  41329a:	e9 fe fd ff ff       	jmp    41309d <slm_sched_loop_intern+0x24d>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  41329f:	e8 bc 85 ff ff       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4132a4:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
	timeout = g->timeout_next;
  4132a8:	4c 8b 05 d9 ec 18 00 	mov    r8,QWORD PTR [rip+0x18ecd9]        # 5a1f88 <__slm_global+0x108>
	prio = inherit_prio ? curr->priority : t->priority;
  4132af:	49 8b 75 30          	mov    rsi,QWORD PTR [r13+0x30]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4132b3:	a8 0b                	test   al,0xb
  4132b5:	0f 85 6a 01 00 00    	jne    413425 <slm_sched_loop_intern+0x5d5>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  4132bb:	49 8b 7d 10          	mov    rdi,QWORD PTR [r13+0x10]
  4132bf:	44 89 f1             	mov    ecx,r14d
  4132c2:	4c 89 c2             	mov    rdx,r8
  4132c5:	e8 96 94 ff ff       	call   40c760 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  4132ca:	83 f8 ff             	cmp    eax,0xffffffff
  4132cd:	0f 84 1c 01 00 00    	je     4133ef <slm_sched_loop_intern+0x59f>
	if (unlikely(ret != 0)) {
  4132d3:	85 c0                	test   eax,eax
  4132d5:	0f 84 b0 fb ff ff    	je     412e8b <slm_sched_loop_intern+0x3b>
		assert(ret != -EINVAL);
  4132db:	83 f8 ea             	cmp    eax,0xffffffea
  4132de:	0f 84 5b 02 00 00    	je     41353f <slm_sched_loop_intern+0x6ef>
		if (ret == -EBUSY) return ret;
  4132e4:	83 f8 f0             	cmp    eax,0xfffffff0
  4132e7:	0f 84 9e fb ff ff    	je     412e8b <slm_sched_loop_intern+0x3b>
		assert(ret == -EAGAIN);
  4132ed:	83 f8 f5             	cmp    eax,0xfffffff5
  4132f0:	0f 85 2d 02 00 00    	jne    413523 <slm_sched_loop_intern+0x6d3>
		tok    = cos_sched_sync();
  4132f6:	e8 05 e0 ff ff       	call   411300 <cos_sched_sync>
  4132fb:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4132fd:	48 8b 05 7c eb 18 00 	mov    rax,QWORD PTR [rip+0x18eb7c]        # 5a1e80 <__slm_global>
		if (unlikely(owner)) {
  413304:	48 89 c6             	mov    rsi,rax
  413307:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  41330b:	0f 85 c1 01 00 00    	jne    4134d2 <slm_sched_loop_intern+0x682>
  413311:	f0 48 0f b1 1d 66 eb 	lock cmpxchg QWORD PTR [rip+0x18eb66],rbx        # 5a1e80 <__slm_global>
  413318:	18 00 
  41331a:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  41331d:	84 c0                	test   al,al
  41331f:	0f 85 bb fd ff ff    	jne    4130e0 <slm_sched_loop_intern+0x290>
  413325:	eb cf                	jmp    4132f6 <slm_sched_loop_intern+0x4a6>
	assert(cos_thdid() == us->tid);
  413327:	bf 20 db 41 00       	mov    edi,0x41db20
  41332c:	e8 ef fa ff ff       	call   412e20 <prints.isra.0>
  413331:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413338:	00 00 00 00 
  41333c:	0f 0b                	ud2    
					assert(cycles);
  41333e:	bf 70 db 41 00       	mov    edi,0x41db70
  413343:	e8 d8 fa ff ff       	call   412e20 <prints.isra.0>
  413348:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41334f:	00 00 00 00 
  413353:	0f 0b                	ud2    
			assert(t);
  413355:	bf 48 db 41 00       	mov    edi,0x41db48
  41335a:	e8 c1 fa ff ff       	call   412e20 <prints.isra.0>
  41335f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413366:	00 00 00 00 
  41336a:	0f 0b                	ud2    
	__asm__ __volatile__("rdtsc" : "=a" (a), "=d" (d), "=c" (c) : : );
  41336c:	0f 31                	rdtsc  
	return ((u64_t)d << 32) | (u64_t)a;
  41336e:	48 c1 e2 20          	shl    rdx,0x20
  413372:	48 89 d7             	mov    rdi,rdx
  413375:	48 09 c7             	or     rdi,rax
  413378:	48 8b 05 01 ec 18 00 	mov    rax,QWORD PTR [rip+0x18ec01]        # 5a1f80 <__slm_global+0x100>
  41337f:	48 29 f8             	sub    rax,rdi
		if (!cycles_greater_than(g->timer_next, now)) {
  413382:	48 85 c0             	test   rax,rax
  413385:	0f 8f 6a fd ff ff    	jg     4130f5 <slm_sched_loop_intern+0x2a5>
			g->timer_set = 0;
  41338b:	c7 05 e7 eb 18 00 00 	mov    DWORD PTR [rip+0x18ebe7],0x0        # 5a1f7c <__slm_global+0xfc>
  413392:	00 00 00 
			slm_timer_expire(now);
  413395:	e8 36 e3 fe ff       	call   4016d0 <slm_timer_expire>
  41339a:	e9 56 fd ff ff       	jmp    4130f5 <slm_sched_loop_intern+0x2a5>
		t->state = SLM_THD_RUNNABLE;
  41339f:	41 c7 46 04 03 00 00 	mov    DWORD PTR [r14+0x4],0x3
  4133a6:	00 
		return 1;
  4133a7:	e9 75 fc ff ff       	jmp    413021 <slm_sched_loop_intern+0x1d1>
  4133ac:	be 23 00 00 00       	mov    esi,0x23
  4133b1:	bf c0 db 41 00       	mov    edi,0x41dbc0
  4133b6:	e8 15 6d ff ff       	call   40a0d0 <cos_print_str>
	assert(t->state == SLM_THD_BLOCKED);
  4133bb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4133c2:	00 00 00 00 
  4133c6:	0f 0b                	ud2    
  4133c8:	be 2d 00 00 00       	mov    esi,0x2d
  4133cd:	bf 10 dc 41 00       	mov    edi,0x41dc10
  4133d2:	e8 f9 6c ff ff       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  4133d7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4133de:	00 00 00 00 
  4133e2:	0f 0b                	ud2    
	if (unlikely(!t)) t = &g->idle_thd;
  4133e4:	41 bd 00 1f 5a 00    	mov    r13d,0x5a1f00
  4133ea:	e9 17 fd ff ff       	jmp    413106 <slm_sched_loop_intern+0x2b6>
	return t != &g->idle_thd && t != &g->sched_thd;
  4133ef:	49 81 fd 00 1f 5a 00 	cmp    r13,0x5a1f00
  4133f6:	0f 84 b3 00 00 00    	je     4134af <slm_sched_loop_intern+0x65f>
  4133fc:	49 81 fd 88 1e 5a 00 	cmp    r13,0x5a1e88
  413403:	0f 84 a6 00 00 00    	je     4134af <slm_sched_loop_intern+0x65f>
  413409:	be 2d 00 00 00       	mov    esi,0x2d
  41340e:	bf 40 dc 41 00       	mov    edi,0x41dc40
  413413:	e8 b8 6c ff ff       	call   40a0d0 <cos_print_str>
		assert(ret != -EPERM);
  413418:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41341f:	00 00 00 00 
  413423:	0f 0b                	ud2    
	timeout = g->timeout_next;
  413425:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  413428:	49 81 fd 88 1e 5a 00 	cmp    r13,0x5a1e88
  41342f:	74 73                	je     4134a4 <slm_sched_loop_intern+0x654>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  413431:	a8 02                	test   al,0x2
  413433:	75 57                	jne    41348c <slm_sched_loop_intern+0x63c>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  413435:	49 89 c8             	mov    r8,rcx
  413438:	a8 01                	test   al,0x1
  41343a:	0f 84 7b fe ff ff    	je     4132bb <slm_sched_loop_intern+0x46b>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  413440:	4d 8b 55 08          	mov    r10,QWORD PTR [r13+0x8]
  413444:	49 8b 7d 10          	mov    rdi,QWORD PTR [r13+0x10]
  413448:	48 89 f2             	mov    rdx,rsi
  41344b:	45 89 f1             	mov    r9d,r14d
  41344e:	4c 8b 05 53 ea 18 00 	mov    r8,QWORD PTR [rip+0x18ea53]        # 5a1ea8 <__slm_global+0x28>
  413455:	4c 89 d6             	mov    rsi,r10
  413458:	e8 c3 de ff ff       	call   411320 <cos_switch>
	if (unlikely(ret != 0)) {
  41345d:	85 c0                	test   eax,eax
  41345f:	0f 84 26 fa ff ff    	je     412e8b <slm_sched_loop_intern+0x3b>
		assert(ret != -EPERM);
  413465:	83 f8 ff             	cmp    eax,0xffffffff
  413468:	0f 85 6d fe ff ff    	jne    4132db <slm_sched_loop_intern+0x48b>
  41346e:	eb 99                	jmp    413409 <slm_sched_loop_intern+0x5b9>
  413470:	be 23 00 00 00       	mov    esi,0x23
  413475:	bf 98 db 41 00       	mov    edi,0x41db98
  41347a:	e8 51 6c ff ff       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state) || t->state == SLM_THD_BLOCKED);
  41347f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413486:	00 00 00 00 
  41348a:	0f 0b                	ud2    
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  41348c:	49 8b 7d 28          	mov    rdi,QWORD PTR [r13+0x28]
  413490:	48 8b 15 11 ea 18 00 	mov    rdx,QWORD PTR [rip+0x18ea11]        # 5a1ea8 <__slm_global+0x28>
  413497:	44 89 f1             	mov    ecx,r14d
  41349a:	4c 89 c6             	mov    rsi,r8
  41349d:	e8 ee de ff ff       	call   411390 <cos_sched_asnd>
  4134a2:	eb b9                	jmp    41345d <slm_sched_loop_intern+0x60d>
			prio    = curr->priority;
  4134a4:	48 8b 35 0d ea 18 00 	mov    rsi,QWORD PTR [rip+0x18ea0d]        # 5a1eb8 <__slm_global+0x38>
			timeout = TCAP_TIME_NIL;
  4134ab:	31 c9                	xor    ecx,ecx
  4134ad:	eb 82                	jmp    413431 <slm_sched_loop_intern+0x5e1>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  4134af:	4c 8b 05 f2 e9 18 00 	mov    r8,QWORD PTR [rip+0x18e9f2]        # 5a1ea8 <__slm_global+0x28>
  4134b6:	45 89 f1             	mov    r9d,r14d
  4134b9:	31 c9                	xor    ecx,ecx
  4134bb:	31 f6                	xor    esi,esi
  4134bd:	48 8b 15 f4 e9 18 00 	mov    rdx,QWORD PTR [rip+0x18e9f4]        # 5a1eb8 <__slm_global+0x38>
  4134c4:	48 8b 3d cd e9 18 00 	mov    rdi,QWORD PTR [rip+0x18e9cd]        # 5a1e98 <__slm_global+0x18>
  4134cb:	e8 50 de ff ff       	call   411320 <cos_switch>
  4134d0:	eb 8b                	jmp    41345d <slm_sched_loop_intern+0x60d>
	if (!contended) {
  4134d2:	a8 01                	test   al,0x1
  4134d4:	75 1b                	jne    4134f1 <slm_sched_loop_intern+0x6a1>
	return !ps_cas(&cs->owner_contention, (unsigned long)cached, ((unsigned long)thd | !!contention));
  4134d6:	48 89 f2             	mov    rdx,rsi
  4134d9:	48 83 ca 01          	or     rdx,0x1
        __asm__ __volatile__("lock " PS_CAS_STR
  4134dd:	f0 48 0f b1 15 9a e9 	lock cmpxchg QWORD PTR [rip+0x18e99a],rdx        # 5a1e80 <__slm_global>
  4134e4:	18 00 
  4134e6:	0f 94 c0             	sete   al
		if (__slm_cs_cas(cs, cached, owner, 1)) return 1;
  4134e9:	84 c0                	test   al,al
  4134eb:	0f 84 05 fe ff ff    	je     4132f6 <slm_sched_loop_intern+0x4a6>
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  4134f1:	48 8b 7e 10          	mov    rdi,QWORD PTR [rsi+0x10]
  4134f5:	48 8b 35 bc e9 18 00 	mov    rsi,QWORD PTR [rip+0x18e9bc]        # 5a1eb8 <__slm_global+0x38>
  4134fc:	31 d2                	xor    edx,edx
  4134fe:	e8 5d 92 ff ff       	call   40c760 <cos_defswitch>
			assert(ret != -EBUSY);
  413503:	83 f8 f0             	cmp    eax,0xfffffff0
  413506:	0f 85 ea fd ff ff    	jne    4132f6 <slm_sched_loop_intern+0x4a6>
  41350c:	bf d0 dc 41 00       	mov    edi,0x41dcd0
  413511:	e8 0a f9 ff ff       	call   412e20 <prints.isra.0>
  413516:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41351d:	00 00 00 00 
  413521:	0f 0b                	ud2    
  413523:	be 2d 00 00 00       	mov    esi,0x2d
  413528:	bf a0 dc 41 00       	mov    edi,0x41dca0
  41352d:	e8 9e 6b ff ff       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  413532:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413539:	00 00 00 00 
  41353d:	0f 0b                	ud2    
  41353f:	be 2d 00 00 00       	mov    esi,0x2d
  413544:	bf 70 dc 41 00       	mov    edi,0x41dc70
  413549:	e8 82 6b ff ff       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  41354e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413555:	00 00 00 00 
  413559:	0f 0b                	ud2    
  41355b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000413560 <slm_ipi_event_enqueue>:
{
  413560:	f3 0f 1e fa          	endbr64 
    return CK_RING_ENQUEUE_MPSC(slm_ipi_ringbuf, &ipi_data->ring, ipi_data->ringbuf, event);
  413564:	4c 63 d6             	movsxd r10,esi
{
  413567:	55                   	push   rbp
  413568:	4d 69 d2 c0 10 00 00 	imul   r10,r10,0x10c0
  41356f:	48 89 e5             	mov    rbp,rsp
  413572:	53                   	push   rbx
  413573:	48 89 fb             	mov    rbx,rdi
    void *buffer,
    const void *entry,
    unsigned int ts,
    unsigned int *size)
{
	const unsigned int mask = ring->mask;
  413576:	45 8b 82 64 0e 5a 00 	mov    r8d,DWORD PTR [r10+0x5a0e64]
  41357d:	4d 8d 9a a8 00 00 00 	lea    r11,[r10+0xa8]
	unsigned int producer, consumer, delta;
	bool r = true;

	producer = ck_pr_load_uint(&ring->p_head);
  413584:	49 8d 8a 24 0e 5a 00 	lea    rcx,[r10+0x5a0e24]
CK_PR_LOAD(ptr, void, void *, char, "movq")

#define CK_PR_LOAD_S(S, T, I) CK_PR_LOAD(S, T, T, T, I)

CK_PR_LOAD_S(char, char, "movb")
CK_PR_LOAD_S(uint, unsigned int, "movl")
  41358b:	41 8b 92 24 0e 5a 00 	mov    edx,DWORD PTR [r10+0x5a0e24]
		/*
		 * The snapshot of producer must be up to date with respect to
		 * consumer.
		 */
		ck_pr_fence_load();
		consumer = ck_pr_load_uint(&ring->c_head);
  413592:	4d 8d 8a e0 0d 5a 00 	lea    r9,[r10+0x5a0de0]
  413599:	eb 0f                	jmp    4135aa <slm_ipi_event_enqueue+0x4a>
  41359b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

#define CK_PR_CAS_S(S, T, I) CK_PR_CAS(S, T, T, T, I)

CK_PR_CAS_S(char, char, "cmpxchgb")
CK_PR_CAS_S(int, int, "cmpxchgl")
CK_PR_CAS_S(uint, unsigned int, "cmpxchgl")
  4135a0:	89 d0                	mov    eax,edx
  4135a2:	f0 0f b1 31          	lock cmpxchg DWORD PTR [rcx],esi
  4135a6:	89 c2                	mov    edx,eax
		/*
		 * Only try to CAS if the producer is not clearly stale (not
		 * less than consumer) and the buffer is definitely not full.
		 */
		if (CK_CC_LIKELY((producer - consumer) < mask)) {
			if (ck_pr_cas_uint_value(&ring->p_head,
  4135a8:	74 1e                	je     4135c8 <slm_ipi_event_enqueue+0x68>
CK_PR_LOAD_S(uint, unsigned int, "movl")
  4135aa:	41 8b 39             	mov    edi,DWORD PTR [r9]
		if (CK_CC_LIKELY((producer - consumer) < mask)) {
  4135ad:	89 d0                	mov    eax,edx
		delta = producer + 1;
  4135af:	8d 72 01             	lea    esi,[rdx+0x1]
		if (CK_CC_LIKELY((producer - consumer) < mask)) {
  4135b2:	29 f8                	sub    eax,edi
  4135b4:	41 39 c0             	cmp    r8d,eax
  4135b7:	77 e7                	ja     4135a0 <slm_ipi_event_enqueue+0x40>
  4135b9:	8b 01                	mov    eax,DWORD PTR [rcx]
			 * Only fail if we haven't made forward progress in
			 * production: the buffer must have been full when we
			 * read new_producer (or we wrapped around UINT_MAX
			 * during this iteration).
			 */
			if (producer == new_producer) {
  4135bb:	39 c2                	cmp    edx,eax
  4135bd:	74 52                	je     413611 <slm_ipi_event_enqueue+0xb1>
  4135bf:	89 c2                	mov    edx,eax
  4135c1:	eb e7                	jmp    4135aa <slm_ipi_event_enqueue+0x4a>
  4135c3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
			producer = new_producer;
		}
	}

	buffer = (char *)buffer + ts * (producer & mask);
	memcpy(buffer, entry, ts);
  4135c8:	48 8b 3b             	mov    rdi,QWORD PTR [rbx]
	buffer = (char *)buffer + ts * (producer & mask);
  4135cb:	41 21 c0             	and    r8d,eax
  4135ce:	42 8d 0c c5 00 00 00 	lea    ecx,[r8*8+0x0]
  4135d5:	00 
	memcpy(buffer, entry, ts);
  4135d6:	49 89 bc 0b c0 0d 5a 	mov    QWORD PTR [r11+rcx*1+0x5a0dc0],rdi
  4135dd:	00 

	/*
	 * Wait until all concurrent producers have completed writing
	 * their data into the ring buffer.
	 */
	while (ck_pr_load_uint(&ring->p_tail) != producer)
  4135de:	49 8d 7a 60          	lea    rdi,[r10+0x60]
  4135e2:	49 8d 8a 20 0e 5a 00 	lea    rcx,[r10+0x5a0e20]
  4135e9:	44 8b 87 c0 0d 5a 00 	mov    r8d,DWORD PTR [rdi+0x5a0dc0]
  4135f0:	41 39 c0             	cmp    r8d,eax
  4135f3:	74 0b                	je     413600 <slm_ipi_event_enqueue+0xa0>
  4135f5:	0f 1f 00             	nop    DWORD PTR [rax]
	__asm__ __volatile__("pause" ::: "memory");
  4135f8:	f3 90                	pause  
CK_PR_LOAD_S(uint, unsigned int, "movl")
  4135fa:	8b 11                	mov    edx,DWORD PTR [rcx]
  4135fc:	39 d0                	cmp    eax,edx
  4135fe:	75 f8                	jne    4135f8 <slm_ipi_event_enqueue+0x98>
CK_PR_STORE_S(uint, unsigned int, "movl", CK_CC_IMM_U32)
  413600:	89 b7 c0 0d 5a 00    	mov    DWORD PTR [rdi+0x5a0dc0],esi
  413606:	b8 01 00 00 00       	mov    eax,0x1
}
  41360b:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
  41360f:	c9                   	leave  
  413610:	c3                   	ret    
  413611:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
  413615:	31 c0                	xor    eax,eax
  413617:	c9                   	leave  
  413618:	c3                   	ret    
  413619:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000413620 <slm_ipi_event_dequeue>:
{
  413620:	f3 0f 1e fa          	endbr64 
    return CK_RING_DEQUEUE_MPSC(slm_ipi_ringbuf, &ipi_data->ring, ipi_data->ringbuf, event);
  413624:	48 63 f6             	movsxd rsi,esi
  413627:	48 69 f6 c0 10 00 00 	imul   rsi,rsi,0x10c0
	const unsigned int mask = ring->mask;
  41362e:	8b 86 64 0e 5a 00    	mov    eax,DWORD PTR [rsi+0x5a0e64]
	consumer = ring->c_head;
  413634:	8b 96 e0 0d 5a 00    	mov    edx,DWORD PTR [rsi+0x5a0de0]
  41363a:	4c 8d 86 a8 00 00 00 	lea    r8,[rsi+0xa8]
CK_PR_LOAD_S(uint, unsigned int, "movl")
  413641:	8b 8e 20 0e 5a 00    	mov    ecx,DWORD PTR [rsi+0x5a0e20]
	if (CK_CC_UNLIKELY(consumer == producer))
  413647:	39 ca                	cmp    edx,ecx
  413649:	74 25                	je     413670 <slm_ipi_event_dequeue+0x50>
	buffer = (const char *)buffer + size * (consumer & mask);
  41364b:	21 d0                	and    eax,edx
  41364d:	c1 e0 03             	shl    eax,0x3
  413650:	49 8b 84 00 c0 0d 5a 	mov    rax,QWORD PTR [r8+rax*1+0x5a0dc0]
  413657:	00 
	memcpy(target, buffer, size);
  413658:	48 89 07             	mov    QWORD PTR [rdi],rax
	ck_pr_store_uint(&ring->c_head, consumer + 1);
  41365b:	83 c2 01             	add    edx,0x1
CK_PR_STORE_S(uint, unsigned int, "movl", CK_CC_IMM_U32)
  41365e:	89 96 e0 0d 5a 00    	mov    DWORD PTR [rsi+0x5a0de0],edx
  413664:	b8 01 00 00 00       	mov    eax,0x1
  413669:	c3                   	ret    
  41366a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  413670:	31 c0                	xor    eax,eax
}
  413672:	c3                   	ret    
  413673:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41367a:	00 00 00 00 
  41367e:	66 90                	xchg   ax,ax

0000000000413680 <slm_ipi_event_empty>:
{
  413680:	f3 0f 1e fa          	endbr64 
	c = ck_pr_load_uint(&ring->c_head);
  413684:	48 63 ff             	movsxd rdi,edi
  413687:	48 69 ff c0 10 00 00 	imul   rdi,rdi,0x10c0
CK_PR_LOAD_S(uint, unsigned int, "movl")
  41368e:	8b 97 e0 0d 5a 00    	mov    edx,DWORD PTR [rdi+0x5a0de0]
  413694:	8b 87 20 0e 5a 00    	mov    eax,DWORD PTR [rdi+0x5a0e20]
	return (p - c) & ring->mask;
  41369a:	29 d0                	sub    eax,edx
  41369c:	23 87 64 0e 5a 00    	and    eax,DWORD PTR [rdi+0x5a0e64]
    return (!ck_ring_size(&ipi_data->ring));
  4136a2:	0f 94 c0             	sete   al
  4136a5:	0f b6 c0             	movzx  eax,al
}
  4136a8:	c3                   	ret    
  4136a9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

00000000004136b0 <slm_ipi_percore_get>:
{
  4136b0:	f3 0f 1e fa          	endbr64 
    return &slm_ipi_percore_data[id];
  4136b4:	48 63 c7             	movsxd rax,edi
  4136b7:	48 69 c0 c0 10 00 00 	imul   rax,rax,0x10c0
  4136be:	48 05 c0 0d 5a 00    	add    rax,0x5a0dc0
}
  4136c4:	c3                   	ret    
  4136c5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4136cc:	00 00 00 00 

00000000004136d0 <slm_thd_special>:
{
  4136d0:	f3 0f 1e fa          	endbr64 
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  4136d4:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  4136d7:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
	return cos_get_thd_id();
  4136dd:	0f b7 90 f0 1f 00 00 	movzx  edx,WORD PTR [rax+0x1ff0]
	if (me == g->sched_thd.tid)     return &g->sched_thd;
  4136e4:	48 39 15 b5 e7 18 00 	cmp    QWORD PTR [rip+0x18e7b5],rdx        # 5a1ea0 <__slm_global+0x20>
  4136eb:	b8 88 1e 5a 00       	mov    eax,0x5a1e88
  4136f0:	74 15                	je     413707 <slm_thd_special+0x37>
	else                            return NULL;
  4136f2:	48 39 15 1f e8 18 00 	cmp    QWORD PTR [rip+0x18e81f],rdx        # 5a1f18 <__slm_global+0x98>
  4136f9:	b8 00 1f 5a 00       	mov    eax,0x5a1f00
  4136fe:	ba 00 00 00 00       	mov    edx,0x0
  413703:	48 0f 45 c2          	cmovne rax,rdx
}
  413707:	c3                   	ret    
  413708:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41370f:	00 

0000000000413710 <slm_thd_init>:
{
  413710:	f3 0f 1e fa          	endbr64 
  413714:	55                   	push   rbp
  413715:	48 89 e5             	mov    rbp,rsp
  413718:	41 54                	push   r12
  41371a:	49 89 fc             	mov    r12,rdi
  41371d:	53                   	push   rbx
  41371e:	48 89 d3             	mov    rbx,rdx
  413721:	48 83 ec 10          	sub    rsp,0x10
  413725:	48 89 75 e8          	mov    QWORD PTR [rbp-0x18],rsi
	struct cos_defcompinfo *defci     = cos_defcompinfo_curr_get();
  413729:	e8 32 81 ff ff       	call   40b860 <cos_defcompinfo_curr_get>
  41372e:	48 89 c7             	mov    rdi,rax
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);
  413731:	e8 6a 81 ff ff       	call   40b8a0 <cos_sched_aep_get>
	memset(t, 0, sizeof(struct slm_thd));
  413736:	49 8d 7c 24 08       	lea    rdi,[r12+0x8]
  41373b:	4c 89 e1             	mov    rcx,r12
  41373e:	49 c7 04 24 00 00 00 	mov    QWORD PTR [r12],0x0
  413745:	00 
  413746:	49 c7 44 24 70 00 00 	mov    QWORD PTR [r12+0x70],0x0
  41374d:	00 00 
  41374f:	48 83 e7 f8          	and    rdi,0xfffffffffffffff8
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);
  413753:	49 89 c0             	mov    r8,rax
	memset(t, 0, sizeof(struct slm_thd));
  413756:	31 c0                	xor    eax,eax
  413758:	48 29 f9             	sub    rcx,rdi
  41375b:	83 c1 78             	add    ecx,0x78
  41375e:	c1 e9 03             	shr    ecx,0x3
  413761:	f3 48 ab             	rep stos QWORD PTR es:[rdi],rax
	if ((ret = slm_timer_thd_init(t))) return ret;
  413764:	4c 89 e7             	mov    rdi,r12
	*t = (struct slm_thd) {
  413767:	48 b8 ff ff ff ff ff 	movabs rax,0xffffffffffff
  41376e:	ff 00 00 
  413771:	f3 41 0f 7e 00       	movq   xmm0,QWORD PTR [r8]
  413776:	49 89 44 24 30       	mov    QWORD PTR [r12+0x30],rax
	ps_list_init(t, thd_list);
  41377b:	49 8d 44 24 58       	lea    rax,[r12+0x58]
  413780:	66 48 0f 6e c8       	movq   xmm1,rax
	ps_list_init(t, graveyard_list);
  413785:	49 8d 44 24 68       	lea    rax,[r12+0x68]
	*t = (struct slm_thd) {
  41378a:	49 89 5c 24 18       	mov    QWORD PTR [r12+0x18],rbx
  41378f:	41 c7 44 24 04 03 00 	mov    DWORD PTR [r12+0x4],0x3
  413796:	00 00 
{ l->n = l->p = l; }
  413798:	66 0f 6c c9          	punpcklqdq xmm1,xmm1
  41379c:	41 0f 11 4c 24 58    	movups XMMWORD PTR [r12+0x58],xmm1
  4137a2:	0f 16 45 e8          	movhps xmm0,QWORD PTR [rbp-0x18]
  4137a6:	41 0f 11 44 24 08    	movups XMMWORD PTR [r12+0x8],xmm0
	ps_list_init(t, graveyard_list);
  4137ac:	66 48 0f 6e c0       	movq   xmm0,rax
  4137b1:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  4137b5:	41 0f 11 44 24 68    	movups XMMWORD PTR [r12+0x68],xmm0
	if ((ret = slm_timer_thd_init(t))) return ret;
  4137bb:	e8 20 df fe ff       	call   4016e0 <slm_timer_thd_init>
  4137c0:	85 c0                	test   eax,eax
  4137c2:	74 0c                	je     4137d0 <slm_thd_init+0xc0>
}
  4137c4:	48 83 c4 10          	add    rsp,0x10
  4137c8:	5b                   	pop    rbx
  4137c9:	41 5c                	pop    r12
  4137cb:	5d                   	pop    rbp
  4137cc:	c3                   	ret    
  4137cd:	0f 1f 00             	nop    DWORD PTR [rax]
  4137d0:	48 83 c4 10          	add    rsp,0x10
	if ((ret = slm_sched_thd_init(t))) return ret;
  4137d4:	4c 89 e7             	mov    rdi,r12
}
  4137d7:	5b                   	pop    rbx
  4137d8:	41 5c                	pop    r12
  4137da:	5d                   	pop    rbp
	if ((ret = slm_sched_thd_init(t))) return ret;
  4137db:	e9 60 df fe ff       	jmp    401740 <slm_sched_thd_init>

00000000004137e0 <slm_thd_deinit>:
{
  4137e0:	f3 0f 1e fa          	endbr64 
  4137e4:	55                   	push   rbp
  4137e5:	48 89 e5             	mov    rbp,rsp
  4137e8:	53                   	push   rbx
  4137e9:	48 89 fb             	mov    rbx,rdi
  4137ec:	48 83 ec 08          	sub    rsp,0x8
	slm_sched_thd_deinit(t);
  4137f0:	e8 5b df fe ff       	call   401750 <slm_sched_thd_deinit>
	slm_timer_thd_deinit(t);
  4137f5:	48 89 df             	mov    rdi,rbx
  4137f8:	e8 f3 de fe ff       	call   4016f0 <slm_timer_thd_deinit>
	t->state = SLM_THD_DYING;
  4137fd:	c7 43 04 04 00 00 00 	mov    DWORD PTR [rbx+0x4],0x4
}
  413804:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
  413808:	c9                   	leave  
  413809:	c3                   	ret    
  41380a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000413810 <slm_cs_enter_contention>:
{
  413810:	f3 0f 1e fa          	endbr64 
  413814:	49 89 ca             	mov    r10,rcx
  413817:	44 89 c9             	mov    ecx,r9d
	if (!contended) {
  41381a:	45 85 c0             	test   r8d,r8d
  41381d:	75 16                	jne    413835 <slm_cs_enter_contention+0x25>
  41381f:	48 89 f0             	mov    rax,rsi
	return !ps_cas(&cs->owner_contention, (unsigned long)cached, ((unsigned long)thd | !!contention));
  413822:	4c 89 d6             	mov    rsi,r10
  413825:	48 83 ce 01          	or     rsi,0x1
  413829:	f0 48 0f b1 37       	lock cmpxchg QWORD PTR [rdi],rsi
  41382e:	0f 94 c0             	sete   al
		if (__slm_cs_cas(cs, cached, owner, 1)) return 1;
  413831:	84 c0                	test   al,al
  413833:	74 23                	je     413858 <slm_cs_enter_contention+0x48>
{
  413835:	55                   	push   rbp
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  413836:	49 8b 7a 10          	mov    rdi,QWORD PTR [r10+0x10]
  41383a:	48 8b 72 30          	mov    rsi,QWORD PTR [rdx+0x30]
  41383e:	31 d2                	xor    edx,edx
{
  413840:	48 89 e5             	mov    rbp,rsp
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  413843:	e8 18 8f ff ff       	call   40c760 <cos_defswitch>
	if (ret) return ret;
  413848:	85 c0                	test   eax,eax
  41384a:	75 05                	jne    413851 <slm_cs_enter_contention+0x41>
	return 1;
  41384c:	b8 01 00 00 00       	mov    eax,0x1
}
  413851:	5d                   	pop    rbp
  413852:	c3                   	ret    
  413853:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	return 1;
  413858:	b8 01 00 00 00       	mov    eax,0x1
}
  41385d:	c3                   	ret    
  41385e:	66 90                	xchg   ax,ax

0000000000413860 <slm_cs_exit_contention>:
{
  413860:	f3 0f 1e fa          	endbr64 
  413864:	49 89 f8             	mov    r8,rdi
  413867:	48 89 d0             	mov    rax,rdx
  41386a:	31 ff                	xor    edi,edi
  41386c:	f0 49 0f b1 38       	lock cmpxchg QWORD PTR [r8],rdi
  413871:	0f 94 c0             	sete   al
	if (__slm_cs_cas(cs, cached, NULL, 0)) return 1;
  413874:	84 c0                	test   al,al
  413876:	75 08                	jne    413880 <slm_cs_exit_contention+0x20>
}
  413878:	b8 01 00 00 00       	mov    eax,0x1
  41387d:	c3                   	ret    
  41387e:	66 90                	xchg   ax,ax
{
  413880:	55                   	push   rbp
	ret = cos_defswitch(s->thd, curr->priority, TCAP_TIME_NIL, tok);
  413881:	48 8b 3d 10 e6 18 00 	mov    rdi,QWORD PTR [rip+0x18e610]        # 5a1e98 <__slm_global+0x18>
  413888:	31 d2                	xor    edx,edx
  41388a:	48 8b 76 30          	mov    rsi,QWORD PTR [rsi+0x30]
{
  41388e:	48 89 e5             	mov    rbp,rsp
	ret = cos_defswitch(s->thd, curr->priority, TCAP_TIME_NIL, tok);
  413891:	e8 ca 8e ff ff       	call   40c760 <cos_defswitch>
	return 0;
  413896:	45 31 c0             	xor    r8d,r8d
	assert(ret != -EINVAL);
  413899:	83 f8 ea             	cmp    eax,0xffffffea
  41389c:	74 05                	je     4138a3 <slm_cs_exit_contention+0x43>
}
  41389e:	44 89 c0             	mov    eax,r8d
  4138a1:	5d                   	pop    rbp
  4138a2:	c3                   	ret    
  4138a3:	be 23 00 00 00       	mov    esi,0x23
  4138a8:	bf e8 db 41 00       	mov    edi,0x41dbe8
  4138ad:	e8 1e 68 ff ff       	call   40a0d0 <cos_print_str>
	assert(ret != -EINVAL);
  4138b2:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4138b9:	00 00 00 00 
  4138bd:	0f 0b                	ud2    
  4138bf:	90                   	nop

00000000004138c0 <slm_thd_block>:
{
  4138c0:	f3 0f 1e fa          	endbr64 
  4138c4:	55                   	push   rbp
  4138c5:	48 89 e5             	mov    rbp,rsp
	assert(t);
  4138c8:	48 85 ff             	test   rdi,rdi
  4138cb:	74 5f                	je     41392c <slm_thd_block+0x6c>
	return t != &g->idle_thd && t != &g->sched_thd;
  4138cd:	48 81 ff 88 1e 5a 00 	cmp    rdi,0x5a1e88
  4138d4:	74 3a                	je     413910 <slm_thd_block+0x50>
  4138d6:	48 81 ff 00 1f 5a 00 	cmp    rdi,0x5a1f00
  4138dd:	74 31                	je     413910 <slm_thd_block+0x50>
	if (unlikely(t->state == SLM_THD_WOKEN)) {
  4138df:	8b 47 04             	mov    eax,DWORD PTR [rdi+0x4]
  4138e2:	83 f8 02             	cmp    eax,0x2
  4138e5:	74 61                	je     413948 <slm_thd_block+0x88>
	assert(t->state == SLM_THD_RUNNABLE);
  4138e7:	83 f8 03             	cmp    eax,0x3
  4138ea:	75 6f                	jne    41395b <slm_thd_block+0x9b>
	if (t->properties & SLM_THD_PROPERTY_SUSPENDED) {
  4138ec:	8b 07                	mov    eax,DWORD PTR [rdi]
  4138ee:	a8 04                	test   al,0x4
  4138f0:	74 05                	je     4138f7 <slm_thd_block+0x37>
		t->properties &= ~SLM_THD_PROPERTY_SUSPENDED;
  4138f2:	83 e0 fb             	and    eax,0xfffffffb
  4138f5:	89 07                	mov    DWORD PTR [rdi],eax
	t->state = SLM_THD_BLOCKED;
  4138f7:	c7 47 04 01 00 00 00 	mov    DWORD PTR [rdi+0x4],0x1
	slm_sched_block(t);
  4138fe:	e8 6d de fe ff       	call   401770 <slm_sched_block>
	return 0;
  413903:	31 c0                	xor    eax,eax
}
  413905:	5d                   	pop    rbp
  413906:	c3                   	ret    
  413907:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41390e:	00 00 
  413910:	be 23 00 00 00       	mov    esi,0x23
  413915:	bf 98 dd 41 00       	mov    edi,0x41dd98
  41391a:	e8 b1 67 ff ff       	call   40a0d0 <cos_print_str>
	assert(slm_thd_normal(t));
  41391f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413926:	00 00 00 00 
  41392a:	0f 0b                	ud2    
  41392c:	be 23 00 00 00       	mov    esi,0x23
  413931:	bf 20 dd 41 00       	mov    edi,0x41dd20
  413936:	e8 95 67 ff ff       	call   40a0d0 <cos_print_str>
	assert(t);
  41393b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413942:	00 00 00 00 
  413946:	0f 0b                	ud2    
		assert(!(t->properties & SLM_THD_PROPERTY_SUSPENDED));
  413948:	f6 07 04             	test   BYTE PTR [rdi],0x4
  41394b:	75 2a                	jne    413977 <slm_thd_block+0xb7>
		t->state = SLM_THD_RUNNABLE;
  41394d:	c7 47 04 03 00 00 00 	mov    DWORD PTR [rdi+0x4],0x3
		return 1;
  413954:	b8 01 00 00 00       	mov    eax,0x1
}
  413959:	5d                   	pop    rbp
  41395a:	c3                   	ret    
  41395b:	be 23 00 00 00       	mov    esi,0x23
  413960:	bf 70 dd 41 00       	mov    edi,0x41dd70
  413965:	e8 66 67 ff ff       	call   40a0d0 <cos_print_str>
	assert(t->state == SLM_THD_RUNNABLE);
  41396a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413971:	00 00 00 00 
  413975:	0f 0b                	ud2    
  413977:	be 23 00 00 00       	mov    esi,0x23
  41397c:	bf 48 dd 41 00       	mov    edi,0x41dd48
  413981:	e8 4a 67 ff ff       	call   40a0d0 <cos_print_str>
		assert(!(t->properties & SLM_THD_PROPERTY_SUSPENDED));
  413986:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41398d:	00 00 00 00 
  413991:	0f 0b                	ud2    
  413993:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41399a:	00 00 00 00 
  41399e:	66 90                	xchg   ax,ax

00000000004139a0 <slm_thd_block_cs>:
{
  4139a0:	f3 0f 1e fa          	endbr64 
  4139a4:	55                   	push   rbp
  4139a5:	48 89 e5             	mov    rbp,rsp
  4139a8:	41 57                	push   r15
  4139aa:	41 56                	push   r14
  4139ac:	41 55                	push   r13
  4139ae:	41 54                	push   r12
  4139b0:	53                   	push   rbx
  4139b1:	48 89 fb             	mov    rbx,rdi
  4139b4:	48 83 ec 08          	sub    rsp,0x8
	assert(current);
  4139b8:	48 85 ff             	test   rdi,rdi
  4139bb:	0f 84 f2 01 00 00    	je     413bb3 <slm_thd_block_cs+0x213>
		tok    = cos_sched_sync();
  4139c1:	e8 3a d9 ff ff       	call   411300 <cos_sched_sync>
  4139c6:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4139c8:	48 8b 05 b1 e4 18 00 	mov    rax,QWORD PTR [rip+0x18e4b1]        # 5a1e80 <__slm_global>
		if (unlikely(owner)) {
  4139cf:	48 89 c2             	mov    rdx,rax
  4139d2:	48 83 e2 fe          	and    rdx,0xfffffffffffffffe
  4139d6:	0f 85 84 01 00 00    	jne    413b60 <slm_thd_block_cs+0x1c0>
  4139dc:	f0 48 0f b1 1d 9b e4 	lock cmpxchg QWORD PTR [rip+0x18e49b],rbx        # 5a1e80 <__slm_global>
  4139e3:	18 00 
  4139e5:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4139e8:	84 c0                	test   al,al
  4139ea:	74 d5                	je     4139c1 <slm_thd_block_cs+0x21>
	if (slm_thd_block(current)) {
  4139ec:	48 89 df             	mov    rdi,rbx
  4139ef:	e8 cc fe ff ff       	call   4138c0 <slm_thd_block>
  4139f4:	85 c0                	test   eax,eax
  4139f6:	0f 85 e4 00 00 00    	jne    413ae0 <slm_thd_block_cs+0x140>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  4139fc:	e8 5f 7e ff ff       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(!t)) t = &g->idle_thd;
  413a01:	41 bf 00 1f 5a 00    	mov    r15d,0x5a1f00
  413a07:	45 31 f6             	xor    r14d,r14d
	tok  = cos_sched_sync();
  413a0a:	e8 f1 d8 ff ff       	call   411300 <cos_sched_sync>
  413a0f:	41 89 c5             	mov    r13d,eax
	t = slm_sched_schedule();
  413a12:	e8 89 dd fe ff       	call   4017a0 <slm_sched_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  413a17:	48 85 c0             	test   rax,rax
	t = slm_sched_schedule();
  413a1a:	49 89 c4             	mov    r12,rax
	if (unlikely(!t)) t = &g->idle_thd;
  413a1d:	4d 0f 44 e7          	cmove  r12,r15
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  413a21:	41 8b 44 24 04       	mov    eax,DWORD PTR [r12+0x4]
  413a26:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  413a29:	83 f8 01             	cmp    eax,0x1
  413a2c:	76 1a                	jbe    413a48 <slm_thd_block_cs+0xa8>
  413a2e:	e9 ed 01 00 00       	jmp    413c20 <slm_thd_block_cs+0x280>
  413a33:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  413a38:	f0 48 0f b1 35 3f e4 	lock cmpxchg QWORD PTR [rip+0x18e43f],rsi        # 5a1e80 <__slm_global>
  413a3f:	18 00 
  413a41:	0f 94 c0             	sete   al
	while (ret != 0) {
  413a44:	84 c0                	test   al,al
  413a46:	75 48                	jne    413a90 <slm_thd_block_cs+0xf0>
		tok    = cos_sched_sync();
  413a48:	e8 b3 d8 ff ff       	call   411300 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  413a4d:	48 8b 15 2c e4 18 00 	mov    rdx,QWORD PTR [rip+0x18e42c]        # 5a1e80 <__slm_global>
  413a54:	89 c1                	mov    ecx,eax
		if (unlikely(contention)) {
  413a56:	48 89 d6             	mov    rsi,rdx
  413a59:	48 89 d0             	mov    rax,rdx
  413a5c:	83 e6 01             	and    esi,0x1
  413a5f:	74 d7                	je     413a38 <slm_thd_block_cs+0x98>
  413a61:	f0 4c 0f b1 35 16 e4 	lock cmpxchg QWORD PTR [rip+0x18e416],r14        # 5a1e80 <__slm_global>
  413a68:	18 00 
  413a6a:	0f 94 c0             	sete   al
	if (__slm_cs_cas(cs, cached, NULL, 0)) return 1;
  413a6d:	84 c0                	test   al,al
  413a6f:	74 d7                	je     413a48 <slm_thd_block_cs+0xa8>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  413a71:	48 83 e2 fe          	and    rdx,0xfffffffffffffffe
	ret = cos_defswitch(s->thd, curr->priority, TCAP_TIME_NIL, tok);
  413a75:	48 8b 3d 1c e4 18 00 	mov    rdi,QWORD PTR [rip+0x18e41c]        # 5a1e98 <__slm_global+0x18>
  413a7c:	48 8b 72 30          	mov    rsi,QWORD PTR [rdx+0x30]
  413a80:	31 d2                	xor    edx,edx
  413a82:	e8 d9 8c ff ff       	call   40c760 <cos_defswitch>
	assert(ret != -EINVAL);
  413a87:	83 f8 ea             	cmp    eax,0xffffffea
  413a8a:	0f 84 ac 00 00 00    	je     413b3c <slm_thd_block_cs+0x19c>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  413a90:	e8 cb 7d ff ff       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  413a95:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
	prio = inherit_prio ? curr->priority : t->priority;
  413a99:	49 8b 74 24 30       	mov    rsi,QWORD PTR [r12+0x30]
	timeout = g->timeout_next;
  413a9e:	4c 8b 05 e3 e4 18 00 	mov    r8,QWORD PTR [rip+0x18e4e3]        # 5a1f88 <__slm_global+0x108>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  413aa5:	a8 0b                	test   al,0xb
  413aa7:	0f 85 8f 01 00 00    	jne    413c3c <slm_thd_block_cs+0x29c>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  413aad:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  413ab2:	44 89 e9             	mov    ecx,r13d
  413ab5:	4c 89 c2             	mov    rdx,r8
  413ab8:	e8 a3 8c ff ff       	call   40c760 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  413abd:	83 f8 ff             	cmp    eax,0xffffffff
  413ac0:	0f 84 e5 01 00 00    	je     413cab <slm_thd_block_cs+0x30b>
	if (unlikely(ret != 0)) {
  413ac6:	85 c0                	test   eax,eax
  413ac8:	0f 85 01 01 00 00    	jne    413bcf <slm_thd_block_cs+0x22f>
}
  413ace:	48 83 c4 08          	add    rsp,0x8
  413ad2:	5b                   	pop    rbx
  413ad3:	41 5c                	pop    r12
  413ad5:	41 5d                	pop    r13
  413ad7:	41 5e                	pop    r14
  413ad9:	41 5f                	pop    r15
  413adb:	5d                   	pop    rbp
  413adc:	c3                   	ret    
  413add:	0f 1f 00             	nop    DWORD PTR [rax]
  413ae0:	31 db                	xor    ebx,ebx
  413ae2:	eb 14                	jmp    413af8 <slm_thd_block_cs+0x158>
  413ae4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  413ae8:	f0 48 0f b1 35 8f e3 	lock cmpxchg QWORD PTR [rip+0x18e38f],rsi        # 5a1e80 <__slm_global>
  413aef:	18 00 
  413af1:	0f 94 c0             	sete   al
	while (ret != 0) {
  413af4:	84 c0                	test   al,al
  413af6:	75 d6                	jne    413ace <slm_thd_block_cs+0x12e>
		tok    = cos_sched_sync();
  413af8:	e8 03 d8 ff ff       	call   411300 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  413afd:	48 8b 15 7c e3 18 00 	mov    rdx,QWORD PTR [rip+0x18e37c]        # 5a1e80 <__slm_global>
  413b04:	89 c1                	mov    ecx,eax
		if (unlikely(contention)) {
  413b06:	48 89 d6             	mov    rsi,rdx
  413b09:	48 89 d0             	mov    rax,rdx
  413b0c:	83 e6 01             	and    esi,0x1
  413b0f:	74 d7                	je     413ae8 <slm_thd_block_cs+0x148>
  413b11:	f0 48 0f b1 1d 66 e3 	lock cmpxchg QWORD PTR [rip+0x18e366],rbx        # 5a1e80 <__slm_global>
  413b18:	18 00 
  413b1a:	0f 94 c0             	sete   al
	if (__slm_cs_cas(cs, cached, NULL, 0)) return 1;
  413b1d:	84 c0                	test   al,al
  413b1f:	74 d7                	je     413af8 <slm_thd_block_cs+0x158>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  413b21:	48 83 e2 fe          	and    rdx,0xfffffffffffffffe
	ret = cos_defswitch(s->thd, curr->priority, TCAP_TIME_NIL, tok);
  413b25:	48 8b 3d 6c e3 18 00 	mov    rdi,QWORD PTR [rip+0x18e36c]        # 5a1e98 <__slm_global+0x18>
  413b2c:	48 8b 72 30          	mov    rsi,QWORD PTR [rdx+0x30]
  413b30:	31 d2                	xor    edx,edx
  413b32:	e8 29 8c ff ff       	call   40c760 <cos_defswitch>
	assert(ret != -EINVAL);
  413b37:	83 f8 ea             	cmp    eax,0xffffffea
  413b3a:	75 92                	jne    413ace <slm_thd_block_cs+0x12e>
  413b3c:	be 23 00 00 00       	mov    esi,0x23
  413b41:	bf e8 db 41 00       	mov    edi,0x41dbe8
  413b46:	e8 85 65 ff ff       	call   40a0d0 <cos_print_str>
  413b4b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413b52:	00 00 00 00 
  413b56:	0f 0b                	ud2    
  413b58:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  413b5f:	00 
	if (!contended) {
  413b60:	a8 01                	test   al,0x1
  413b62:	75 1b                	jne    413b7f <slm_thd_block_cs+0x1df>
	return !ps_cas(&cs->owner_contention, (unsigned long)cached, ((unsigned long)thd | !!contention));
  413b64:	48 89 d6             	mov    rsi,rdx
  413b67:	48 83 ce 01          	or     rsi,0x1
  413b6b:	f0 48 0f b1 35 0c e3 	lock cmpxchg QWORD PTR [rip+0x18e30c],rsi        # 5a1e80 <__slm_global>
  413b72:	18 00 
  413b74:	0f 94 c0             	sete   al
		if (__slm_cs_cas(cs, cached, owner, 1)) return 1;
  413b77:	84 c0                	test   al,al
  413b79:	0f 84 42 fe ff ff    	je     4139c1 <slm_thd_block_cs+0x21>
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  413b7f:	48 8b 7a 10          	mov    rdi,QWORD PTR [rdx+0x10]
  413b83:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
  413b87:	31 d2                	xor    edx,edx
  413b89:	e8 d2 8b ff ff       	call   40c760 <cos_defswitch>
			assert(ret != -EBUSY);
  413b8e:	83 f8 f0             	cmp    eax,0xfffffff0
  413b91:	0f 85 2a fe ff ff    	jne    4139c1 <slm_thd_block_cs+0x21>
  413b97:	be 25 00 00 00       	mov    esi,0x25
  413b9c:	bf d0 dc 41 00       	mov    edi,0x41dcd0
  413ba1:	e8 2a 65 ff ff       	call   40a0d0 <cos_print_str>
  413ba6:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413bad:	00 00 00 00 
  413bb1:	0f 0b                	ud2    
  413bb3:	be 25 00 00 00       	mov    esi,0x25
  413bb8:	bf c0 dd 41 00       	mov    edi,0x41ddc0
  413bbd:	e8 0e 65 ff ff       	call   40a0d0 <cos_print_str>
	assert(current);
  413bc2:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413bc9:	00 00 00 00 
  413bcd:	0f 0b                	ud2    
		assert(ret != -EINVAL);
  413bcf:	83 f8 ea             	cmp    eax,0xffffffea
  413bd2:	0f 84 2c 01 00 00    	je     413d04 <slm_thd_block_cs+0x364>
		if (ret == -EBUSY) return ret;
  413bd8:	83 f8 f0             	cmp    eax,0xfffffff0
  413bdb:	0f 84 ed fe ff ff    	je     413ace <slm_thd_block_cs+0x12e>
		assert(ret == -EAGAIN);
  413be1:	83 f8 f5             	cmp    eax,0xfffffff5
  413be4:	0f 85 8e 01 00 00    	jne    413d78 <slm_thd_block_cs+0x3d8>
		tok    = cos_sched_sync();
  413bea:	e8 11 d7 ff ff       	call   411300 <cos_sched_sync>
  413bef:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  413bf1:	48 8b 05 88 e2 18 00 	mov    rax,QWORD PTR [rip+0x18e288]        # 5a1e80 <__slm_global>
		if (unlikely(owner)) {
  413bf8:	48 89 c6             	mov    rsi,rax
  413bfb:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  413bff:	0f 85 1b 01 00 00    	jne    413d20 <slm_thd_block_cs+0x380>
  413c05:	f0 48 0f b1 1d 72 e2 	lock cmpxchg QWORD PTR [rip+0x18e272],rbx        # 5a1e80 <__slm_global>
  413c0c:	18 00 
  413c0e:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  413c11:	84 c0                	test   al,al
  413c13:	0f 85 f1 fd ff ff    	jne    413a0a <slm_thd_block_cs+0x6a>
  413c19:	eb cf                	jmp    413bea <slm_thd_block_cs+0x24a>
  413c1b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  413c20:	be 2d 00 00 00       	mov    esi,0x2d
  413c25:	bf 10 dc 41 00       	mov    edi,0x41dc10
  413c2a:	e8 a1 64 ff ff       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  413c2f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413c36:	00 00 00 00 
  413c3a:	0f 0b                	ud2    
	timeout = g->timeout_next;
  413c3c:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  413c3f:	49 81 fc 88 1e 5a 00 	cmp    r12,0x5a1e88
  413c46:	0f 84 91 00 00 00    	je     413cdd <slm_thd_block_cs+0x33d>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  413c4c:	a8 02                	test   al,0x2
  413c4e:	0f 85 94 00 00 00    	jne    413ce8 <slm_thd_block_cs+0x348>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  413c54:	49 89 c8             	mov    r8,rcx
  413c57:	a8 01                	test   al,0x1
  413c59:	0f 84 4e fe ff ff    	je     413aad <slm_thd_block_cs+0x10d>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  413c5f:	4d 8b 54 24 08       	mov    r10,QWORD PTR [r12+0x8]
  413c64:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  413c69:	48 89 f2             	mov    rdx,rsi
  413c6c:	45 89 e9             	mov    r9d,r13d
  413c6f:	4c 8b 05 32 e2 18 00 	mov    r8,QWORD PTR [rip+0x18e232]        # 5a1ea8 <__slm_global+0x28>
  413c76:	4c 89 d6             	mov    rsi,r10
  413c79:	e8 a2 d6 ff ff       	call   411320 <cos_switch>
	if (unlikely(ret != 0)) {
  413c7e:	85 c0                	test   eax,eax
  413c80:	0f 84 48 fe ff ff    	je     413ace <slm_thd_block_cs+0x12e>
		assert(ret != -EPERM);
  413c86:	83 f8 ff             	cmp    eax,0xffffffff
  413c89:	0f 85 40 ff ff ff    	jne    413bcf <slm_thd_block_cs+0x22f>
  413c8f:	be 2d 00 00 00       	mov    esi,0x2d
  413c94:	bf 40 dc 41 00       	mov    edi,0x41dc40
  413c99:	e8 32 64 ff ff       	call   40a0d0 <cos_print_str>
  413c9e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413ca5:	00 00 00 00 
  413ca9:	0f 0b                	ud2    
	return t != &g->idle_thd && t != &g->sched_thd;
  413cab:	49 81 fc 00 1f 5a 00 	cmp    r12,0x5a1f00
  413cb2:	74 09                	je     413cbd <slm_thd_block_cs+0x31d>
  413cb4:	49 81 fc 88 1e 5a 00 	cmp    r12,0x5a1e88
  413cbb:	75 d2                	jne    413c8f <slm_thd_block_cs+0x2ef>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  413cbd:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]
  413cc1:	4c 8b 05 e0 e1 18 00 	mov    r8,QWORD PTR [rip+0x18e1e0]        # 5a1ea8 <__slm_global+0x28>
  413cc8:	45 89 e9             	mov    r9d,r13d
  413ccb:	31 c9                	xor    ecx,ecx
  413ccd:	48 8b 3d c4 e1 18 00 	mov    rdi,QWORD PTR [rip+0x18e1c4]        # 5a1e98 <__slm_global+0x18>
  413cd4:	31 f6                	xor    esi,esi
  413cd6:	e8 45 d6 ff ff       	call   411320 <cos_switch>
  413cdb:	eb a1                	jmp    413c7e <slm_thd_block_cs+0x2de>
			prio    = curr->priority;
  413cdd:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
			timeout = TCAP_TIME_NIL;
  413ce1:	31 c9                	xor    ecx,ecx
  413ce3:	e9 64 ff ff ff       	jmp    413c4c <slm_thd_block_cs+0x2ac>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  413ce8:	49 8b 7c 24 28       	mov    rdi,QWORD PTR [r12+0x28]
  413ced:	48 8b 15 b4 e1 18 00 	mov    rdx,QWORD PTR [rip+0x18e1b4]        # 5a1ea8 <__slm_global+0x28>
  413cf4:	44 89 e9             	mov    ecx,r13d
  413cf7:	4c 89 c6             	mov    rsi,r8
  413cfa:	e8 91 d6 ff ff       	call   411390 <cos_sched_asnd>
  413cff:	e9 7a ff ff ff       	jmp    413c7e <slm_thd_block_cs+0x2de>
  413d04:	be 2d 00 00 00       	mov    esi,0x2d
  413d09:	bf 70 dc 41 00       	mov    edi,0x41dc70
  413d0e:	e8 bd 63 ff ff       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  413d13:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413d1a:	00 00 00 00 
  413d1e:	0f 0b                	ud2    
	if (!contended) {
  413d20:	a8 01                	test   al,0x1
  413d22:	75 1b                	jne    413d3f <slm_thd_block_cs+0x39f>
	return !ps_cas(&cs->owner_contention, (unsigned long)cached, ((unsigned long)thd | !!contention));
  413d24:	48 89 f2             	mov    rdx,rsi
  413d27:	48 83 ca 01          	or     rdx,0x1
  413d2b:	f0 48 0f b1 15 4c e1 	lock cmpxchg QWORD PTR [rip+0x18e14c],rdx        # 5a1e80 <__slm_global>
  413d32:	18 00 
  413d34:	0f 94 c0             	sete   al
		if (__slm_cs_cas(cs, cached, owner, 1)) return 1;
  413d37:	84 c0                	test   al,al
  413d39:	0f 84 ab fe ff ff    	je     413bea <slm_thd_block_cs+0x24a>
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  413d3f:	4c 8b 43 30          	mov    r8,QWORD PTR [rbx+0x30]
  413d43:	48 8b 7e 10          	mov    rdi,QWORD PTR [rsi+0x10]
  413d47:	31 d2                	xor    edx,edx
  413d49:	4c 89 c6             	mov    rsi,r8
  413d4c:	e8 0f 8a ff ff       	call   40c760 <cos_defswitch>
			assert(ret != -EBUSY);
  413d51:	83 f8 f0             	cmp    eax,0xfffffff0
  413d54:	0f 85 90 fe ff ff    	jne    413bea <slm_thd_block_cs+0x24a>
  413d5a:	bf d0 dc 41 00       	mov    edi,0x41dcd0
  413d5f:	e8 bc f0 ff ff       	call   412e20 <prints.isra.0>
  413d64:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413d6b:	00 00 00 00 
  413d6f:	0f 0b                	ud2    
  413d71:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  413d78:	be 2d 00 00 00       	mov    esi,0x2d
  413d7d:	bf a0 dc 41 00       	mov    edi,0x41dca0
  413d82:	e8 49 63 ff ff       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  413d87:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413d8e:	00 00 00 00 
  413d92:	0f 0b                	ud2    
  413d94:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  413d9b:	00 00 00 00 
  413d9f:	90                   	nop

0000000000413da0 <slm_thd_sched_wakeup>:
{
  413da0:	f3 0f 1e fa          	endbr64 
  413da4:	55                   	push   rbp
  413da5:	48 89 e5             	mov    rbp,rsp
	assert(t);
  413da8:	48 85 ff             	test   rdi,rdi
  413dab:	74 2b                	je     413dd8 <slm_thd_sched_wakeup+0x38>
	if (unlikely(!(t->properties & SLM_THD_PROPERTY_SUSPENDED))) return 1;
  413dad:	8b 07                	mov    eax,DWORD PTR [rdi]
  413daf:	a8 04                	test   al,0x4
  413db1:	74 41                	je     413df4 <slm_thd_sched_wakeup+0x54>
	t->properties &= ~SLM_THD_PROPERTY_SUSPENDED;
  413db3:	83 e0 fb             	and    eax,0xfffffffb
  413db6:	89 07                	mov    DWORD PTR [rdi],eax
	if (unlikely(slm_state_is_runnable(t->state))) {
  413db8:	8b 47 04             	mov    eax,DWORD PTR [rdi+0x4]
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  413dbb:	8d 50 fe             	lea    edx,[rax-0x2]
  413dbe:	83 fa 01             	cmp    edx,0x1
  413dc1:	76 38                	jbe    413dfb <slm_thd_sched_wakeup+0x5b>
	assert(t->state == SLM_THD_BLOCKED);
  413dc3:	83 f8 01             	cmp    eax,0x1
  413dc6:	75 41                	jne    413e09 <slm_thd_sched_wakeup+0x69>
	t->state = SLM_THD_RUNNABLE;
  413dc8:	c7 47 04 03 00 00 00 	mov    DWORD PTR [rdi+0x4],0x3
	slm_sched_wakeup(t);
  413dcf:	e8 ac d9 fe ff       	call   401780 <slm_sched_wakeup>
	return 0;
  413dd4:	31 c0                	xor    eax,eax
}
  413dd6:	5d                   	pop    rbp
  413dd7:	c3                   	ret    
  413dd8:	be 23 00 00 00       	mov    esi,0x23
  413ddd:	bf e8 dd 41 00       	mov    edi,0x41dde8
  413de2:	e8 e9 62 ff ff       	call   40a0d0 <cos_print_str>
	assert(t);
  413de7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413dee:	00 00 00 00 
  413df2:	0f 0b                	ud2    
	if (unlikely(!(t->properties & SLM_THD_PROPERTY_SUSPENDED))) return 1;
  413df4:	b8 01 00 00 00       	mov    eax,0x1
}
  413df9:	5d                   	pop    rbp
  413dfa:	c3                   	ret    
		t->state = SLM_THD_RUNNABLE;
  413dfb:	c7 47 04 03 00 00 00 	mov    DWORD PTR [rdi+0x4],0x3
		return 1;
  413e02:	b8 01 00 00 00       	mov    eax,0x1
}
  413e07:	5d                   	pop    rbp
  413e08:	c3                   	ret    
  413e09:	be 23 00 00 00       	mov    esi,0x23
  413e0e:	bf c0 db 41 00       	mov    edi,0x41dbc0
  413e13:	e8 b8 62 ff ff       	call   40a0d0 <cos_print_str>
	assert(t->state == SLM_THD_BLOCKED);
  413e18:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413e1f:	00 00 00 00 
  413e23:	0f 0b                	ud2    
  413e25:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  413e2c:	00 00 00 00 

0000000000413e30 <slm_thd_wakeup>:
{
  413e30:	f3 0f 1e fa          	endbr64 
  413e34:	55                   	push   rbp
  413e35:	48 89 e5             	mov    rbp,rsp
  413e38:	41 54                	push   r12
  413e3a:	53                   	push   rbx
	assert(t);
  413e3b:	48 85 ff             	test   rdi,rdi
  413e3e:	74 6e                	je     413eae <slm_thd_wakeup+0x7e>
	if (unlikely(t->cpuid != cos_cpuid())) {
  413e40:	4c 63 67 38          	movsxd r12,DWORD PTR [rdi+0x38]
  413e44:	48 89 fb             	mov    rbx,rdi
  413e47:	45 85 e4             	test   r12d,r12d
  413e4a:	75 7e                	jne    413eca <slm_thd_wakeup+0x9a>
	if (t->state == SLM_THD_WOKEN) return 1;
  413e4c:	8b 47 04             	mov    eax,DWORD PTR [rdi+0x4]
  413e4f:	83 f8 02             	cmp    eax,0x2
  413e52:	74 4c                	je     413ea0 <slm_thd_wakeup+0x70>
	if (unlikely(t->state == SLM_THD_RUNNABLE || (redundant && t->state == SLM_THD_WOKEN))) {
  413e54:	83 f8 03             	cmp    eax,0x3
  413e57:	0f 84 22 01 00 00    	je     413f7f <slm_thd_wakeup+0x14f>
	assert(t->state == SLM_THD_BLOCKED);
  413e5d:	83 f8 01             	cmp    eax,0x1
  413e60:	0f 85 2b 01 00 00    	jne    413f91 <slm_thd_wakeup+0x161>
	return t != &g->idle_thd && t != &g->sched_thd;
  413e66:	48 81 ff 88 1e 5a 00 	cmp    rdi,0x5a1e88
  413e6d:	0f 84 3d 01 00 00    	je     413fb0 <slm_thd_wakeup+0x180>
  413e73:	48 81 ff 00 1f 5a 00 	cmp    rdi,0x5a1f00
  413e7a:	0f 84 30 01 00 00    	je     413fb0 <slm_thd_wakeup+0x180>
	t->state = SLM_THD_RUNNABLE;
  413e80:	c7 47 04 03 00 00 00 	mov    DWORD PTR [rdi+0x4],0x3
	slm_sched_wakeup(t);
  413e87:	e8 f4 d8 fe ff       	call   401780 <slm_sched_wakeup>
	t->properties &= ~SLM_THD_PROPERTY_SUSPENDED;
  413e8c:	83 23 fb             	and    DWORD PTR [rbx],0xfffffffb
}
  413e8f:	44 89 e0             	mov    eax,r12d
  413e92:	5b                   	pop    rbx
  413e93:	41 5c                	pop    r12
  413e95:	5d                   	pop    rbp
  413e96:	c3                   	ret    
  413e97:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  413e9e:	00 00 
	if (t->state == SLM_THD_WOKEN) return 1;
  413ea0:	41 bc 01 00 00 00    	mov    r12d,0x1
}
  413ea6:	5b                   	pop    rbx
  413ea7:	44 89 e0             	mov    eax,r12d
  413eaa:	41 5c                	pop    r12
  413eac:	5d                   	pop    rbp
  413ead:	c3                   	ret    
  413eae:	be 23 00 00 00       	mov    esi,0x23
  413eb3:	bf 10 de 41 00       	mov    edi,0x41de10
  413eb8:	e8 13 62 ff ff       	call   40a0d0 <cos_print_str>
	assert(t);
  413ebd:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413ec4:	00 00 00 00 
  413ec8:	0f 0b                	ud2    
		event.tid = t->tid;
  413eca:	4d 69 cc c0 10 00 00 	imul   r9,r12,0x10c0
  413ed1:	4c 8b 57 18          	mov    r10,QWORD PTR [rdi+0x18]
	const unsigned int mask = ring->mask;
  413ed5:	45 8b 81 64 0e 5a 00 	mov    r8d,DWORD PTR [r9+0x5a0e64]
  413edc:	4d 8d 99 a8 00 00 00 	lea    r11,[r9+0xa8]
	producer = ck_pr_load_uint(&ring->p_head);
  413ee3:	49 8d b1 24 0e 5a 00 	lea    rsi,[r9+0x5a0e24]
  413eea:	41 8b 91 24 0e 5a 00 	mov    edx,DWORD PTR [r9+0x5a0e24]
		consumer = ck_pr_load_uint(&ring->c_head);
  413ef1:	49 8d 99 e0 0d 5a 00 	lea    rbx,[r9+0x5a0de0]
  413ef8:	eb 10                	jmp    413f0a <slm_thd_wakeup+0xda>
  413efa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
CK_PR_CAS_S(uint, unsigned int, "cmpxchgl")
  413f00:	89 d0                	mov    eax,edx
  413f02:	f0 0f b1 0e          	lock cmpxchg DWORD PTR [rsi],ecx
  413f06:	89 c2                	mov    edx,eax
			if (ck_pr_cas_uint_value(&ring->p_head,
  413f08:	74 1c                	je     413f26 <slm_thd_wakeup+0xf6>
CK_PR_LOAD_S(uint, unsigned int, "movl")
  413f0a:	8b 3b                	mov    edi,DWORD PTR [rbx]
		if (CK_CC_LIKELY((producer - consumer) < mask)) {
  413f0c:	89 d0                	mov    eax,edx
		delta = producer + 1;
  413f0e:	8d 4a 01             	lea    ecx,[rdx+0x1]
		if (CK_CC_LIKELY((producer - consumer) < mask)) {
  413f11:	29 f8                	sub    eax,edi
  413f13:	41 39 c0             	cmp    r8d,eax
  413f16:	77 e8                	ja     413f00 <slm_thd_wakeup+0xd0>
  413f18:	8b 06                	mov    eax,DWORD PTR [rsi]
			if (producer == new_producer) {
  413f1a:	39 c2                	cmp    edx,eax
  413f1c:	0f 84 aa 00 00 00    	je     413fcc <slm_thd_wakeup+0x19c>
  413f22:	89 c2                	mov    edx,eax
  413f24:	eb e4                	jmp    413f0a <slm_thd_wakeup+0xda>
	buffer = (char *)buffer + ts * (producer & mask);
  413f26:	41 21 c0             	and    r8d,eax
	while (ck_pr_load_uint(&ring->p_tail) != producer)
  413f29:	49 8d 79 60          	lea    rdi,[r9+0x60]
	buffer = (char *)buffer + ts * (producer & mask);
  413f2d:	42 8d 34 c5 00 00 00 	lea    esi,[r8*8+0x0]
  413f34:	00 
	memcpy(buffer, entry, ts);
  413f35:	4d 89 94 33 c0 0d 5a 	mov    QWORD PTR [r11+rsi*1+0x5a0dc0],r10
  413f3c:	00 
	while (ck_pr_load_uint(&ring->p_tail) != producer)
  413f3d:	49 8d b1 20 0e 5a 00 	lea    rsi,[r9+0x5a0e20]
  413f44:	44 8b 87 c0 0d 5a 00 	mov    r8d,DWORD PTR [rdi+0x5a0dc0]
  413f4b:	41 39 c0             	cmp    r8d,eax
  413f4e:	74 08                	je     413f58 <slm_thd_wakeup+0x128>
	__asm__ __volatile__("pause" ::: "memory");
  413f50:	f3 90                	pause  
CK_PR_LOAD_S(uint, unsigned int, "movl")
  413f52:	8b 16                	mov    edx,DWORD PTR [rsi]
  413f54:	39 d0                	cmp    eax,edx
  413f56:	75 f8                	jne    413f50 <slm_thd_wakeup+0x120>
CK_PR_STORE_S(uint, unsigned int, "movl", CK_CC_IMM_U32)
  413f58:	89 8f c0 0d 5a 00    	mov    DWORD PTR [rdi+0x5a0dc0],ecx
		cos_asnd(ipi_data->ipi_thd.asnd, 1);
  413f5e:	4d 69 e4 c0 10 00 00 	imul   r12,r12,0x10c0
  413f65:	be 01 00 00 00       	mov    esi,0x1
  413f6a:	49 8b bc 24 c8 0d 5a 	mov    rdi,QWORD PTR [r12+0x5a0dc8]
  413f71:	00 
		return 0;
  413f72:	45 31 e4             	xor    r12d,r12d
		cos_asnd(ipi_data->ipi_thd.asnd, 1);
  413f75:	e8 76 d4 ff ff       	call   4113f0 <cos_asnd>
		return 0;
  413f7a:	e9 10 ff ff ff       	jmp    413e8f <slm_thd_wakeup+0x5f>
		t->state = SLM_THD_WOKEN;
  413f7f:	c7 47 04 02 00 00 00 	mov    DWORD PTR [rdi+0x4],0x2
		return 1;
  413f86:	41 bc 01 00 00 00    	mov    r12d,0x1
  413f8c:	e9 fe fe ff ff       	jmp    413e8f <slm_thd_wakeup+0x5f>
  413f91:	be 23 00 00 00       	mov    esi,0x23
  413f96:	bf 38 de 41 00       	mov    edi,0x41de38
  413f9b:	e8 30 61 ff ff       	call   40a0d0 <cos_print_str>
	assert(t->state == SLM_THD_BLOCKED);
  413fa0:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413fa7:	00 00 00 00 
  413fab:	0f 0b                	ud2    
  413fad:	0f 1f 00             	nop    DWORD PTR [rax]
  413fb0:	be 23 00 00 00       	mov    esi,0x23
  413fb5:	bf 88 de 41 00       	mov    edi,0x41de88
  413fba:	e8 11 61 ff ff       	call   40a0d0 <cos_print_str>
	assert(slm_thd_normal(t));
  413fbf:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413fc6:	00 00 00 00 
  413fca:	0f 0b                	ud2    
  413fcc:	be 23 00 00 00       	mov    esi,0x23
  413fd1:	bf 60 de 41 00       	mov    edi,0x41de60
  413fd6:	e8 f5 60 ff ff       	call   40a0d0 <cos_print_str>
		assert(ret);
  413fdb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413fe2:	00 00 00 00 
  413fe6:	0f 0b                	ud2    
  413fe8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  413fef:	00 

0000000000413ff0 <slm_thd_wakeup_cs>:
{
  413ff0:	f3 0f 1e fa          	endbr64 
  413ff4:	55                   	push   rbp
  413ff5:	48 89 e5             	mov    rbp,rsp
  413ff8:	41 57                	push   r15
  413ffa:	41 56                	push   r14
  413ffc:	41 55                	push   r13
  413ffe:	41 54                	push   r12
  414000:	53                   	push   rbx
  414001:	48 83 ec 08          	sub    rsp,0x8
	assert(t);
  414005:	48 85 f6             	test   rsi,rsi
  414008:	0f 84 aa 01 00 00    	je     4141b8 <slm_thd_wakeup_cs+0x1c8>
  41400e:	48 89 fb             	mov    rbx,rdi
  414011:	49 89 f4             	mov    r12,rsi
	assert(current);
  414014:	48 85 ff             	test   rdi,rdi
  414017:	0f 84 0a 02 00 00    	je     414227 <slm_thd_wakeup_cs+0x237>
		tok    = cos_sched_sync();
  41401d:	e8 de d2 ff ff       	call   411300 <cos_sched_sync>
  414022:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  414024:	48 8b 05 55 de 18 00 	mov    rax,QWORD PTR [rip+0x18de55]        # 5a1e80 <__slm_global>
		if (unlikely(owner)) {
  41402b:	48 89 c2             	mov    rdx,rax
  41402e:	48 83 e2 fe          	and    rdx,0xfffffffffffffffe
  414032:	0f 85 9c 01 00 00    	jne    4141d4 <slm_thd_wakeup_cs+0x1e4>
  414038:	f0 48 0f b1 1d 3f de 	lock cmpxchg QWORD PTR [rip+0x18de3f],rbx        # 5a1e80 <__slm_global>
  41403f:	18 00 
  414041:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  414044:	84 c0                	test   al,al
  414046:	74 d5                	je     41401d <slm_thd_wakeup_cs+0x2d>
	if (slm_thd_wakeup(t, 0)) {
  414048:	31 f6                	xor    esi,esi
  41404a:	4c 89 e7             	mov    rdi,r12
  41404d:	e8 de fd ff ff       	call   413e30 <slm_thd_wakeup>
  414052:	85 c0                	test   eax,eax
  414054:	0f 85 e6 00 00 00    	jne    414140 <slm_thd_wakeup_cs+0x150>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  41405a:	e8 01 78 ff ff       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(!t)) t = &g->idle_thd;
  41405f:	41 bf 00 1f 5a 00    	mov    r15d,0x5a1f00
  414065:	45 31 f6             	xor    r14d,r14d
	tok  = cos_sched_sync();
  414068:	e8 93 d2 ff ff       	call   411300 <cos_sched_sync>
  41406d:	41 89 c5             	mov    r13d,eax
	t = slm_sched_schedule();
  414070:	e8 2b d7 fe ff       	call   4017a0 <slm_sched_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  414075:	48 85 c0             	test   rax,rax
	t = slm_sched_schedule();
  414078:	49 89 c4             	mov    r12,rax
	if (unlikely(!t)) t = &g->idle_thd;
  41407b:	4d 0f 44 e7          	cmove  r12,r15
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  41407f:	41 8b 44 24 04       	mov    eax,DWORD PTR [r12+0x4]
  414084:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  414087:	83 f8 01             	cmp    eax,0x1
  41408a:	76 1c                	jbe    4140a8 <slm_thd_wakeup_cs+0xb8>
  41408c:	e9 ff 01 00 00       	jmp    414290 <slm_thd_wakeup_cs+0x2a0>
  414091:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  414098:	f0 48 0f b1 35 df dd 	lock cmpxchg QWORD PTR [rip+0x18dddf],rsi        # 5a1e80 <__slm_global>
  41409f:	18 00 
  4140a1:	0f 94 c0             	sete   al
	while (ret != 0) {
  4140a4:	84 c0                	test   al,al
  4140a6:	75 48                	jne    4140f0 <slm_thd_wakeup_cs+0x100>
		tok    = cos_sched_sync();
  4140a8:	e8 53 d2 ff ff       	call   411300 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  4140ad:	48 8b 15 cc dd 18 00 	mov    rdx,QWORD PTR [rip+0x18ddcc]        # 5a1e80 <__slm_global>
  4140b4:	89 c1                	mov    ecx,eax
		if (unlikely(contention)) {
  4140b6:	48 89 d6             	mov    rsi,rdx
  4140b9:	48 89 d0             	mov    rax,rdx
  4140bc:	83 e6 01             	and    esi,0x1
  4140bf:	74 d7                	je     414098 <slm_thd_wakeup_cs+0xa8>
  4140c1:	f0 4c 0f b1 35 b6 dd 	lock cmpxchg QWORD PTR [rip+0x18ddb6],r14        # 5a1e80 <__slm_global>
  4140c8:	18 00 
  4140ca:	0f 94 c0             	sete   al
	if (__slm_cs_cas(cs, cached, NULL, 0)) return 1;
  4140cd:	84 c0                	test   al,al
  4140cf:	74 d7                	je     4140a8 <slm_thd_wakeup_cs+0xb8>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  4140d1:	48 83 e2 fe          	and    rdx,0xfffffffffffffffe
	ret = cos_defswitch(s->thd, curr->priority, TCAP_TIME_NIL, tok);
  4140d5:	48 8b 3d bc dd 18 00 	mov    rdi,QWORD PTR [rip+0x18ddbc]        # 5a1e98 <__slm_global+0x18>
  4140dc:	48 8b 72 30          	mov    rsi,QWORD PTR [rdx+0x30]
  4140e0:	31 d2                	xor    edx,edx
  4140e2:	e8 79 86 ff ff       	call   40c760 <cos_defswitch>
	assert(ret != -EINVAL);
  4140e7:	83 f8 ea             	cmp    eax,0xffffffea
  4140ea:	0f 84 ac 00 00 00    	je     41419c <slm_thd_wakeup_cs+0x1ac>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  4140f0:	e8 6b 77 ff ff       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4140f5:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
	prio = inherit_prio ? curr->priority : t->priority;
  4140f9:	49 8b 74 24 30       	mov    rsi,QWORD PTR [r12+0x30]
	timeout = g->timeout_next;
  4140fe:	4c 8b 05 83 de 18 00 	mov    r8,QWORD PTR [rip+0x18de83]        # 5a1f88 <__slm_global+0x108>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  414105:	a8 0b                	test   al,0xb
  414107:	0f 85 9f 01 00 00    	jne    4142ac <slm_thd_wakeup_cs+0x2bc>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  41410d:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  414112:	44 89 e9             	mov    ecx,r13d
  414115:	4c 89 c2             	mov    rdx,r8
  414118:	e8 43 86 ff ff       	call   40c760 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  41411d:	83 f8 ff             	cmp    eax,0xffffffff
  414120:	0f 84 f5 01 00 00    	je     41431b <slm_thd_wakeup_cs+0x32b>
	if (unlikely(ret != 0)) {
  414126:	85 c0                	test   eax,eax
  414128:	0f 85 15 01 00 00    	jne    414243 <slm_thd_wakeup_cs+0x253>
}
  41412e:	48 83 c4 08          	add    rsp,0x8
  414132:	5b                   	pop    rbx
  414133:	41 5c                	pop    r12
  414135:	41 5d                	pop    r13
  414137:	41 5e                	pop    r14
  414139:	41 5f                	pop    r15
  41413b:	5d                   	pop    rbp
  41413c:	c3                   	ret    
  41413d:	0f 1f 00             	nop    DWORD PTR [rax]
  414140:	31 db                	xor    ebx,ebx
  414142:	eb 14                	jmp    414158 <slm_thd_wakeup_cs+0x168>
  414144:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  414148:	f0 48 0f b1 35 2f dd 	lock cmpxchg QWORD PTR [rip+0x18dd2f],rsi        # 5a1e80 <__slm_global>
  41414f:	18 00 
  414151:	0f 94 c0             	sete   al
	while (ret != 0) {
  414154:	84 c0                	test   al,al
  414156:	75 d6                	jne    41412e <slm_thd_wakeup_cs+0x13e>
		tok    = cos_sched_sync();
  414158:	e8 a3 d1 ff ff       	call   411300 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  41415d:	48 8b 15 1c dd 18 00 	mov    rdx,QWORD PTR [rip+0x18dd1c]        # 5a1e80 <__slm_global>
  414164:	89 c1                	mov    ecx,eax
		if (unlikely(contention)) {
  414166:	48 89 d6             	mov    rsi,rdx
  414169:	48 89 d0             	mov    rax,rdx
  41416c:	83 e6 01             	and    esi,0x1
  41416f:	74 d7                	je     414148 <slm_thd_wakeup_cs+0x158>
  414171:	f0 48 0f b1 1d 06 dd 	lock cmpxchg QWORD PTR [rip+0x18dd06],rbx        # 5a1e80 <__slm_global>
  414178:	18 00 
  41417a:	0f 94 c0             	sete   al
	if (__slm_cs_cas(cs, cached, NULL, 0)) return 1;
  41417d:	84 c0                	test   al,al
  41417f:	74 d7                	je     414158 <slm_thd_wakeup_cs+0x168>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  414181:	48 83 e2 fe          	and    rdx,0xfffffffffffffffe
	ret = cos_defswitch(s->thd, curr->priority, TCAP_TIME_NIL, tok);
  414185:	48 8b 3d 0c dd 18 00 	mov    rdi,QWORD PTR [rip+0x18dd0c]        # 5a1e98 <__slm_global+0x18>
  41418c:	48 8b 72 30          	mov    rsi,QWORD PTR [rdx+0x30]
  414190:	31 d2                	xor    edx,edx
  414192:	e8 c9 85 ff ff       	call   40c760 <cos_defswitch>
	assert(ret != -EINVAL);
  414197:	83 f8 ea             	cmp    eax,0xffffffea
  41419a:	75 92                	jne    41412e <slm_thd_wakeup_cs+0x13e>
  41419c:	be 23 00 00 00       	mov    esi,0x23
  4141a1:	bf e8 db 41 00       	mov    edi,0x41dbe8
  4141a6:	e8 25 5f ff ff       	call   40a0d0 <cos_print_str>
  4141ab:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4141b2:	00 00 00 00 
  4141b6:	0f 0b                	ud2    
  4141b8:	be 23 00 00 00       	mov    esi,0x23
  4141bd:	bf b0 de 41 00       	mov    edi,0x41deb0
  4141c2:	e8 09 5f ff ff       	call   40a0d0 <cos_print_str>
	assert(t);
  4141c7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4141ce:	00 00 00 00 
  4141d2:	0f 0b                	ud2    
	if (!contended) {
  4141d4:	a8 01                	test   al,0x1
  4141d6:	75 1b                	jne    4141f3 <slm_thd_wakeup_cs+0x203>
	return !ps_cas(&cs->owner_contention, (unsigned long)cached, ((unsigned long)thd | !!contention));
  4141d8:	48 89 d6             	mov    rsi,rdx
  4141db:	48 83 ce 01          	or     rsi,0x1
  4141df:	f0 48 0f b1 35 98 dc 	lock cmpxchg QWORD PTR [rip+0x18dc98],rsi        # 5a1e80 <__slm_global>
  4141e6:	18 00 
  4141e8:	0f 94 c0             	sete   al
		if (__slm_cs_cas(cs, cached, owner, 1)) return 1;
  4141eb:	84 c0                	test   al,al
  4141ed:	0f 84 2a fe ff ff    	je     41401d <slm_thd_wakeup_cs+0x2d>
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  4141f3:	48 8b 7a 10          	mov    rdi,QWORD PTR [rdx+0x10]
  4141f7:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
  4141fb:	31 d2                	xor    edx,edx
  4141fd:	e8 5e 85 ff ff       	call   40c760 <cos_defswitch>
			assert(ret != -EBUSY);
  414202:	83 f8 f0             	cmp    eax,0xfffffff0
  414205:	0f 85 12 fe ff ff    	jne    41401d <slm_thd_wakeup_cs+0x2d>
  41420b:	be 25 00 00 00       	mov    esi,0x25
  414210:	bf d0 dc 41 00       	mov    edi,0x41dcd0
  414215:	e8 b6 5e ff ff       	call   40a0d0 <cos_print_str>
  41421a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414221:	00 00 00 00 
  414225:	0f 0b                	ud2    
  414227:	be 25 00 00 00       	mov    esi,0x25
  41422c:	bf c0 dd 41 00       	mov    edi,0x41ddc0
  414231:	e8 9a 5e ff ff       	call   40a0d0 <cos_print_str>
	assert(current);
  414236:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41423d:	00 00 00 00 
  414241:	0f 0b                	ud2    
		assert(ret != -EINVAL);
  414243:	83 f8 ea             	cmp    eax,0xffffffea
  414246:	0f 84 98 01 00 00    	je     4143e4 <slm_thd_wakeup_cs+0x3f4>
		if (ret == -EBUSY) return ret;
  41424c:	83 f8 f0             	cmp    eax,0xfffffff0
  41424f:	0f 84 d9 fe ff ff    	je     41412e <slm_thd_wakeup_cs+0x13e>
		assert(ret == -EAGAIN);
  414255:	83 f8 f5             	cmp    eax,0xfffffff5
  414258:	0f 85 6a 01 00 00    	jne    4143c8 <slm_thd_wakeup_cs+0x3d8>
		tok    = cos_sched_sync();
  41425e:	e8 9d d0 ff ff       	call   411300 <cos_sched_sync>
  414263:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  414265:	48 8b 05 14 dc 18 00 	mov    rax,QWORD PTR [rip+0x18dc14]        # 5a1e80 <__slm_global>
		if (unlikely(owner)) {
  41426c:	48 89 c6             	mov    rsi,rax
  41426f:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  414273:	0f 85 fb 00 00 00    	jne    414374 <slm_thd_wakeup_cs+0x384>
  414279:	f0 48 0f b1 1d fe db 	lock cmpxchg QWORD PTR [rip+0x18dbfe],rbx        # 5a1e80 <__slm_global>
  414280:	18 00 
  414282:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  414285:	84 c0                	test   al,al
  414287:	0f 85 db fd ff ff    	jne    414068 <slm_thd_wakeup_cs+0x78>
  41428d:	eb cf                	jmp    41425e <slm_thd_wakeup_cs+0x26e>
  41428f:	90                   	nop
  414290:	be 2d 00 00 00       	mov    esi,0x2d
  414295:	bf 10 dc 41 00       	mov    edi,0x41dc10
  41429a:	e8 31 5e ff ff       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  41429f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4142a6:	00 00 00 00 
  4142aa:	0f 0b                	ud2    
	timeout = g->timeout_next;
  4142ac:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  4142af:	49 81 fc 88 1e 5a 00 	cmp    r12,0x5a1e88
  4142b6:	0f 84 91 00 00 00    	je     41434d <slm_thd_wakeup_cs+0x35d>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  4142bc:	a8 02                	test   al,0x2
  4142be:	0f 85 94 00 00 00    	jne    414358 <slm_thd_wakeup_cs+0x368>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  4142c4:	49 89 c8             	mov    r8,rcx
  4142c7:	a8 01                	test   al,0x1
  4142c9:	0f 84 3e fe ff ff    	je     41410d <slm_thd_wakeup_cs+0x11d>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  4142cf:	4d 8b 54 24 08       	mov    r10,QWORD PTR [r12+0x8]
  4142d4:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  4142d9:	48 89 f2             	mov    rdx,rsi
  4142dc:	45 89 e9             	mov    r9d,r13d
  4142df:	4c 8b 05 c2 db 18 00 	mov    r8,QWORD PTR [rip+0x18dbc2]        # 5a1ea8 <__slm_global+0x28>
  4142e6:	4c 89 d6             	mov    rsi,r10
  4142e9:	e8 32 d0 ff ff       	call   411320 <cos_switch>
	if (unlikely(ret != 0)) {
  4142ee:	85 c0                	test   eax,eax
  4142f0:	0f 84 38 fe ff ff    	je     41412e <slm_thd_wakeup_cs+0x13e>
		assert(ret != -EPERM);
  4142f6:	83 f8 ff             	cmp    eax,0xffffffff
  4142f9:	0f 85 44 ff ff ff    	jne    414243 <slm_thd_wakeup_cs+0x253>
  4142ff:	be 2d 00 00 00       	mov    esi,0x2d
  414304:	bf 40 dc 41 00       	mov    edi,0x41dc40
  414309:	e8 c2 5d ff ff       	call   40a0d0 <cos_print_str>
  41430e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414315:	00 00 00 00 
  414319:	0f 0b                	ud2    
	return t != &g->idle_thd && t != &g->sched_thd;
  41431b:	49 81 fc 00 1f 5a 00 	cmp    r12,0x5a1f00
  414322:	74 09                	je     41432d <slm_thd_wakeup_cs+0x33d>
  414324:	49 81 fc 88 1e 5a 00 	cmp    r12,0x5a1e88
  41432b:	75 d2                	jne    4142ff <slm_thd_wakeup_cs+0x30f>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  41432d:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]
  414331:	4c 8b 05 70 db 18 00 	mov    r8,QWORD PTR [rip+0x18db70]        # 5a1ea8 <__slm_global+0x28>
  414338:	45 89 e9             	mov    r9d,r13d
  41433b:	31 c9                	xor    ecx,ecx
  41433d:	48 8b 3d 54 db 18 00 	mov    rdi,QWORD PTR [rip+0x18db54]        # 5a1e98 <__slm_global+0x18>
  414344:	31 f6                	xor    esi,esi
  414346:	e8 d5 cf ff ff       	call   411320 <cos_switch>
  41434b:	eb a1                	jmp    4142ee <slm_thd_wakeup_cs+0x2fe>
			prio    = curr->priority;
  41434d:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
			timeout = TCAP_TIME_NIL;
  414351:	31 c9                	xor    ecx,ecx
  414353:	e9 64 ff ff ff       	jmp    4142bc <slm_thd_wakeup_cs+0x2cc>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  414358:	49 8b 7c 24 28       	mov    rdi,QWORD PTR [r12+0x28]
  41435d:	48 8b 15 44 db 18 00 	mov    rdx,QWORD PTR [rip+0x18db44]        # 5a1ea8 <__slm_global+0x28>
  414364:	44 89 e9             	mov    ecx,r13d
  414367:	4c 89 c6             	mov    rsi,r8
  41436a:	e8 21 d0 ff ff       	call   411390 <cos_sched_asnd>
  41436f:	e9 7a ff ff ff       	jmp    4142ee <slm_thd_wakeup_cs+0x2fe>
	if (!contended) {
  414374:	a8 01                	test   al,0x1
  414376:	75 1b                	jne    414393 <slm_thd_wakeup_cs+0x3a3>
	return !ps_cas(&cs->owner_contention, (unsigned long)cached, ((unsigned long)thd | !!contention));
  414378:	48 89 f2             	mov    rdx,rsi
  41437b:	48 83 ca 01          	or     rdx,0x1
  41437f:	f0 48 0f b1 15 f8 da 	lock cmpxchg QWORD PTR [rip+0x18daf8],rdx        # 5a1e80 <__slm_global>
  414386:	18 00 
  414388:	0f 94 c0             	sete   al
		if (__slm_cs_cas(cs, cached, owner, 1)) return 1;
  41438b:	84 c0                	test   al,al
  41438d:	0f 84 cb fe ff ff    	je     41425e <slm_thd_wakeup_cs+0x26e>
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  414393:	4c 8b 43 30          	mov    r8,QWORD PTR [rbx+0x30]
  414397:	48 8b 7e 10          	mov    rdi,QWORD PTR [rsi+0x10]
  41439b:	31 d2                	xor    edx,edx
  41439d:	4c 89 c6             	mov    rsi,r8
  4143a0:	e8 bb 83 ff ff       	call   40c760 <cos_defswitch>
			assert(ret != -EBUSY);
  4143a5:	83 f8 f0             	cmp    eax,0xfffffff0
  4143a8:	0f 85 b0 fe ff ff    	jne    41425e <slm_thd_wakeup_cs+0x26e>
  4143ae:	bf d0 dc 41 00       	mov    edi,0x41dcd0
  4143b3:	e8 68 ea ff ff       	call   412e20 <prints.isra.0>
  4143b8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4143bf:	00 00 00 00 
  4143c3:	0f 0b                	ud2    
  4143c5:	0f 1f 00             	nop    DWORD PTR [rax]
  4143c8:	be 2d 00 00 00       	mov    esi,0x2d
  4143cd:	bf a0 dc 41 00       	mov    edi,0x41dca0
  4143d2:	e8 f9 5c ff ff       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  4143d7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4143de:	00 00 00 00 
  4143e2:	0f 0b                	ud2    
  4143e4:	be 2d 00 00 00       	mov    esi,0x2d
  4143e9:	bf 70 dc 41 00       	mov    edi,0x41dc70
  4143ee:	e8 dd 5c ff ff       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  4143f3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4143fa:	00 00 00 00 
  4143fe:	0f 0b                	ud2    

0000000000414400 <slm_thd_event_reset>:
{
  414400:	f3 0f 1e fa          	endbr64 
	memset(&t->event_info, 0, sizeof(struct event_info));
  414404:	66 0f ef c0          	pxor   xmm0,xmm0
  414408:	48 c7 47 50 00 00 00 	mov    QWORD PTR [rdi+0x50],0x0
  41440f:	00 
  414410:	0f 11 47 40          	movups XMMWORD PTR [rdi+0x40],xmm0
}
  414414:	c3                   	ret    
  414415:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41441c:	00 00 00 00 

0000000000414420 <slm_get_cycs_per_usec>:
{
  414420:	f3 0f 1e fa          	endbr64 
	return (unsigned long)g->cyc_per_usec;
  414424:	48 63 05 4d db 18 00 	movsxd rax,DWORD PTR [rip+0x18db4d]        # 5a1f78 <__slm_global+0xf8>
}
  41442b:	c3                   	ret    
  41442c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000414430 <slm_sched_loop>:
	}
}

void
slm_sched_loop(void)
{
  414430:	f3 0f 1e fa          	endbr64 
  414434:	55                   	push   rbp
	slm_sched_loop_intern(0);
  414435:	31 ff                	xor    edi,edi
{
  414437:	48 89 e5             	mov    rbp,rsp
	slm_sched_loop_intern(0);
  41443a:	e8 11 ea ff ff       	call   412e50 <slm_sched_loop_intern>
  41443f:	90                   	nop

0000000000414440 <slm_sched_loop_nonblock>:
}

void
slm_sched_loop_nonblock(void)
{
  414440:	f3 0f 1e fa          	endbr64 
  414444:	55                   	push   rbp
	slm_sched_loop_intern(1);
  414445:	bf 01 00 00 00       	mov    edi,0x1
{
  41444a:	48 89 e5             	mov    rbp,rsp
	slm_sched_loop_intern(1);
  41444d:	e8 fe e9 ff ff       	call   412e50 <slm_sched_loop_intern>
  414452:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  414459:	00 00 00 00 
  41445d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000414460 <slm_init>:
}

void
slm_init(thdcap_t thd, thdid_t tid)
{
  414460:	f3 0f 1e fa          	endbr64 
  414464:	55                   	push   rbp
  414465:	48 89 e5             	mov    rbp,rsp
  414468:	41 57                	push   r15
  41446a:	41 56                	push   r14
  41446c:	41 55                	push   r13
  41446e:	49 89 f5             	mov    r13,rsi
  414471:	41 54                	push   r12
  414473:	41 bc e0 1e 5a 00    	mov    r12d,0x5a1ee0
  414479:	53                   	push   rbx
  41447a:	bb f0 1e 5a 00       	mov    ebx,0x5a1ef0
  41447f:	48 83 ec 18          	sub    rsp,0x18
  414483:	48 89 7d c8          	mov    QWORD PTR [rbp-0x38],rdi
	struct slm_thd *s    = &g->sched_thd;
	struct slm_thd *i    = &g->idle_thd;
	struct cos_defcompinfo *defci;
	struct cos_aep_info    *sched_aep;

	defci = cos_defcompinfo_curr_get();
  414487:	e8 d4 73 ff ff       	call   40b860 <cos_defcompinfo_curr_get>
  41448c:	48 89 c7             	mov    rdi,rax
	sched_aep = cos_sched_aep_get(defci);
  41448f:	e8 0c 74 ff ff       	call   40b8a0 <cos_sched_aep_get>

	*s = (struct slm_thd) {
  414494:	66 0f ef c0          	pxor   xmm0,xmm0
  414498:	48 8b 0d 61 9a 00 00 	mov    rcx,QWORD PTR [rip+0x9a61]        # 41df00 <CSWTCH.186+0x5b0>
		.properties = SLM_THD_PROPERTY_SPECIAL,
		.state = SLM_THD_RUNNABLE,
		.tc  = sched_aep->tc,
  41449f:	f3 0f 6f 10          	movdqu xmm2,XMMWORD PTR [rax]
  4144a3:	f3 0f 6f 48 10       	movdqu xmm1,XMMWORD PTR [rax+0x10]
  4144a8:	48 8b 00             	mov    rax,QWORD PTR [rax]
	*s = (struct slm_thd) {
  4144ab:	0f 29 05 fe d9 18 00 	movaps XMMWORD PTR [rip+0x18d9fe],xmm0        # 5a1eb0 <__slm_global+0x30>
  4144b2:	0f 29 15 d7 d9 18 00 	movaps XMMWORD PTR [rip+0x18d9d7],xmm2        # 5a1e90 <__slm_global+0x10>
  4144b9:	66 49 0f 6e d4       	movq   xmm2,r12
  4144be:	66 0f 6c d2          	punpcklqdq xmm2,xmm2
  4144c2:	0f 29 05 f7 d9 18 00 	movaps XMMWORD PTR [rip+0x18d9f7],xmm0        # 5a1ec0 <__slm_global+0x40>
  4144c9:	66 48 0f 6e d8       	movq   xmm3,rax
		.cpuid = cos_cpuid(),
		.priority = TCAP_PRIO_MAX
	};
	ps_list_init(s, thd_list);
	ps_list_init(s, graveyard_list);
	assert(s->tid == cos_thdid());
  4144ce:	66 48 0f 7e c8       	movq   rax,xmm1
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  4144d3:	48 89 e2             	mov    rdx,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  4144d6:	48 81 e2 00 e0 ff ff 	and    rdx,0xffffffffffffe000
	*s = (struct slm_thd) {
  4144dd:	0f 29 05 ec d9 18 00 	movaps XMMWORD PTR [rip+0x18d9ec],xmm0        # 5a1ed0 <__slm_global+0x50>
  4144e4:	0f 16 5d c8          	movhps xmm3,QWORD PTR [rbp-0x38]
  4144e8:	0f 29 0d b1 d9 18 00 	movaps XMMWORD PTR [rip+0x18d9b1],xmm1        # 5a1ea0 <__slm_global+0x20>
	return cos_get_thd_id();
  4144ef:	0f b7 92 f0 1f 00 00 	movzx  edx,WORD PTR [rdx+0x1ff0]
  4144f6:	0f 29 15 e3 d9 18 00 	movaps XMMWORD PTR [rip+0x18d9e3],xmm2        # 5a1ee0 <__slm_global+0x60>
  4144fd:	66 48 0f 6e d3       	movq   xmm2,rbx
  414502:	66 0f 6c d2          	punpcklqdq xmm2,xmm2
  414506:	48 89 0d 7b d9 18 00 	mov    QWORD PTR [rip+0x18d97b],rcx        # 5a1e88 <__slm_global+0x8>
  41450d:	48 c7 05 a0 d9 18 00 	mov    QWORD PTR [rip+0x18d9a0],0x1        # 5a1eb8 <__slm_global+0x38>
  414514:	01 00 00 00 
  414518:	0f 29 15 d1 d9 18 00 	movaps XMMWORD PTR [rip+0x18d9d1],xmm2        # 5a1ef0 <__slm_global+0x70>
	assert(s->tid == cos_thdid());
  41451f:	48 39 d0             	cmp    rax,rdx
  414522:	0f 85 cb 00 00 00    	jne    4145f3 <slm_init+0x193>
  414528:	41 bf 58 1f 5a 00    	mov    r15d,0x5a1f58

	*i = (struct slm_thd) {
  41452e:	0f 29 05 fb d9 18 00 	movaps XMMWORD PTR [rip+0x18d9fb],xmm0        # 5a1f30 <__slm_global+0xb0>
  414535:	41 be 68 1f 5a 00    	mov    r14d,0x5a1f68
  41453b:	48 b8 ff ff ff ff ff 	movabs rax,0xffffffffffff
  414542:	ff 00 00 
  414545:	0f 29 05 d4 d9 18 00 	movaps XMMWORD PTR [rip+0x18d9d4],xmm0        # 5a1f20 <__slm_global+0xa0>
	ps_list_init(i, graveyard_list);

	ps_list_head_init(&g->event_head);
	ps_list_head_init(&g->graveyard_head);

	g->cyc_per_usec = cos_hw_cycles_per_usec(BOOT_CAPTBL_SELF_INITHW_BASE);
  41454c:	bf 24 00 00 00       	mov    edi,0x24
	*i = (struct slm_thd) {
  414551:	0f 29 05 e8 d9 18 00 	movaps XMMWORD PTR [rip+0x18d9e8],xmm0        # 5a1f40 <__slm_global+0xc0>
  414558:	66 49 0f 6e c7       	movq   xmm0,r15
  41455d:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  414561:	48 89 0d 98 d9 18 00 	mov    QWORD PTR [rip+0x18d998],rcx        # 5a1f00 <__slm_global+0x80>
  414568:	0f 11 05 e9 d9 18 00 	movups XMMWORD PTR [rip+0x18d9e9],xmm0        # 5a1f58 <__slm_global+0xd8>
  41456f:	66 49 0f 6e c6       	movq   xmm0,r14
  414574:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  414578:	4c 89 2d 99 d9 18 00 	mov    QWORD PTR [rip+0x18d999],r13        # 5a1f18 <__slm_global+0x98>
  41457f:	0f 11 05 e2 d9 18 00 	movups XMMWORD PTR [rip+0x18d9e2],xmm0        # 5a1f68 <__slm_global+0xe8>
  414586:	f3 0f 7e 05 7a 99 00 	movq   xmm0,QWORD PTR [rip+0x997a]        # 41df08 <CSWTCH.186+0x5b8>
  41458d:	00 
  41458e:	0f 11 1d 73 d9 18 00 	movups XMMWORD PTR [rip+0x18d973],xmm3        # 5a1f08 <__slm_global+0x88>
  414595:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  414599:	48 89 05 90 d9 18 00 	mov    QWORD PTR [rip+0x18d990],rax        # 5a1f30 <__slm_global+0xb0>
  4145a0:	0f 29 05 e9 d9 18 00 	movaps XMMWORD PTR [rip+0x18d9e9],xmm0        # 5a1f90 <__slm_global+0x110>
  4145a7:	f3 0f 7e 05 61 99 00 	movq   xmm0,QWORD PTR [rip+0x9961]        # 41df10 <CSWTCH.186+0x5c0>
  4145ae:	00 
  4145af:	48 c7 05 96 d9 18 00 	mov    QWORD PTR [rip+0x18d996],0x0        # 5a1f50 <__slm_global+0xd0>
  4145b6:	00 00 00 00 
  4145ba:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  4145be:	0f 29 05 db d9 18 00 	movaps XMMWORD PTR [rip+0x18d9db],xmm0        # 5a1fa0 <__slm_global+0x120>
	g->cyc_per_usec = cos_hw_cycles_per_usec(BOOT_CAPTBL_SELF_INITHW_BASE);
  4145c5:	e8 56 d9 ff ff       	call   411f20 <cos_hw_cycles_per_usec>
	g->lock.owner_contention = 0;
  4145ca:	48 c7 05 ab d8 18 00 	mov    QWORD PTR [rip+0x18d8ab],0x0        # 5a1e80 <__slm_global>
  4145d1:	00 00 00 00 
	g->cyc_per_usec = cos_hw_cycles_per_usec(BOOT_CAPTBL_SELF_INITHW_BASE);
  4145d5:	89 05 9d d9 18 00    	mov    DWORD PTR [rip+0x18d99d],eax        # 5a1f78 <__slm_global+0xf8>

	slm_sched_init();
  4145db:	e8 50 d1 fe ff       	call   401730 <slm_sched_init>
	slm_timer_init();
}
  4145e0:	48 83 c4 18          	add    rsp,0x18
  4145e4:	5b                   	pop    rbx
  4145e5:	41 5c                	pop    r12
  4145e7:	41 5d                	pop    r13
  4145e9:	41 5e                	pop    r14
  4145eb:	41 5f                	pop    r15
  4145ed:	5d                   	pop    rbp
	slm_timer_init();
  4145ee:	e9 2d d1 fe ff       	jmp    401720 <slm_timer_init>
  4145f3:	be 23 00 00 00       	mov    esi,0x23
  4145f8:	bf d8 de 41 00       	mov    edi,0x41ded8
  4145fd:	e8 ce 5a ff ff       	call   40a0d0 <cos_print_str>
	assert(s->tid == cos_thdid());
  414602:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414609:	00 00 00 00 
  41460d:	0f 0b                	ud2    
  41460f:	90                   	nop

0000000000414610 <heap_init>:
#endif

/* public functions */
void
heap_init(struct heap *h, int max_sz, cmp_fn_t c, update_fn_t u)
{
  414610:	f3 0f 1e fa          	endbr64 
  414614:	66 48 0f 6e c2       	movq   xmm0,rdx
  414619:	66 48 0f 6e c9       	movq   xmm1,rcx
  41461e:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
	assert(h);
  414622:	48 85 ff             	test   rdi,rdi
  414625:	74 19                	je     414640 <heap_init+0x30>

	h->max_sz = max_sz + 1;
  414627:	83 c6 01             	add    esi,0x1
	h->e      = 1;
	h->c      = c;
	h->u      = u;
	h->data   = (void *)&h[1];
  41462a:	48 8d 47 20          	lea    rax,[rdi+0x20]
	h->e      = 1;
  41462e:	c7 07 01 00 00 00    	mov    DWORD PTR [rdi],0x1
	h->max_sz = max_sz + 1;
  414634:	89 77 04             	mov    DWORD PTR [rdi+0x4],esi
	h->data   = (void *)&h[1];
  414637:	48 89 47 18          	mov    QWORD PTR [rdi+0x18],rax
	h->c      = c;
  41463b:	0f 11 47 08          	movups XMMWORD PTR [rdi+0x8],xmm0
	h->data   = (void *)&h[1];
  41463f:	c3                   	ret    
{
  414640:	55                   	push   rbp
  414641:	be 24 00 00 00       	mov    esi,0x24
  414646:	bf 18 df 41 00       	mov    edi,0x41df18
  41464b:	48 89 e5             	mov    rbp,rsp
  41464e:	e8 7d 5a ff ff       	call   40a0d0 <cos_print_str>
	assert(h);
  414653:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41465a:	00 00 00 00 
  41465e:	0f 0b                	ud2    

0000000000414660 <heap_alloc>:
	assert(!heap_verify(h));
}

struct heap *
heap_alloc(int max_sz, cmp_fn_t c, update_fn_t u)
{
  414660:	f3 0f 1e fa          	endbr64 

	heap_init(h, max_sz, c, u);
#endif

	return h;
}
  414664:	31 c0                	xor    eax,eax
  414666:	c3                   	ret    
  414667:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41466e:	00 00 

0000000000414670 <heap_destroy>:

void
heap_destroy(struct heap *h)
{
  414670:	f3 0f 1e fa          	endbr64 
	assert(h && h->data);
  414674:	48 85 ff             	test   rdi,rdi
  414677:	74 08                	je     414681 <heap_destroy+0x11>
  414679:	48 83 7f 18 00       	cmp    QWORD PTR [rdi+0x18],0x0
  41467e:	74 01                	je     414681 <heap_destroy+0x11>
  414680:	c3                   	ret    
{
  414681:	55                   	push   rbp
  414682:	be 24 00 00 00       	mov    esi,0x24
  414687:	bf 40 df 41 00       	mov    edi,0x41df40
  41468c:	48 89 e5             	mov    rbp,rsp
  41468f:	e8 3c 5a ff ff       	call   40a0d0 <cos_print_str>
	assert(h && h->data);
  414694:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41469b:	00 00 00 00 
  41469f:	0f 0b                	ud2    
  4146a1:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4146a8:	00 00 00 00 
  4146ac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

00000000004146b0 <heap_add>:
#endif
}

int
heap_add(struct heap *h, void *new)
{
  4146b0:	f3 0f 1e fa          	endbr64 
  4146b4:	55                   	push   rbp
  4146b5:	48 89 e5             	mov    rbp,rsp
  4146b8:	41 57                	push   r15
  4146ba:	41 56                	push   r14
  4146bc:	41 55                	push   r13
  4146be:	41 54                	push   r12
  4146c0:	53                   	push   rbx
  4146c1:	48 89 fb             	mov    rbx,rdi
  4146c4:	48 83 ec 18          	sub    rsp,0x18
	int c;

	if (h->max_sz == h->e) return -1;
  4146c8:	44 8b 37             	mov    r14d,DWORD PTR [rdi]
  4146cb:	44 39 77 04          	cmp    DWORD PTR [rdi+0x4],r14d
  4146cf:	0f 84 fd 01 00 00    	je     4148d2 <heap_add+0x222>

	debug("heap_add(%p,%d) %p\n", h, h->e, new);

	assert(!heap_verify(h));
	c          = h->e;
	h->data[c] = new;
  4146d5:	48 8b 53 18          	mov    rdx,QWORD PTR [rbx+0x18]
  4146d9:	49 63 c6             	movsxd rax,r14d
  4146dc:	48 89 f7             	mov    rdi,rsi
  4146df:	48 89 34 c2          	mov    QWORD PTR [rdx+rax*8],rsi
	h->u(new, c);
  4146e3:	44 89 f6             	mov    esi,r14d
  4146e6:	ff 53 10             	call   QWORD PTR [rbx+0x10]
	h->e++;
  4146e9:	8b 03                	mov    eax,DWORD PTR [rbx]
  4146eb:	83 c0 01             	add    eax,0x1
  4146ee:	89 03                	mov    DWORD PTR [rbx],eax
	assert(c <= h->e);
  4146f0:	41 39 c6             	cmp    r14d,eax
  4146f3:	0f 8f 85 01 00 00    	jg     41487e <heap_add+0x1ce>
	assert(c > 0);
  4146f9:	45 85 f6             	test   r14d,r14d
  4146fc:	0f 8e 98 01 00 00    	jle    41489a <heap_add+0x1ea>
	while (c > 1) {
  414702:	41 83 fe 01          	cmp    r14d,0x1
  414706:	75 43                	jne    41474b <heap_add+0x9b>
  414708:	e9 55 01 00 00       	jmp    414862 <heap_add+0x1b2>
  41470d:	0f 1f 00             	nop    DWORD PTR [rax]
	arr[a] = arr[b];
  414710:	4c 03 63 18          	add    r12,QWORD PTR [rbx+0x18]
	t      = arr[a];
  414714:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
	u(arr[a], a);
  414718:	44 89 f6             	mov    esi,r14d
	t      = arr[a];
  41471b:	48 03 43 18          	add    rax,QWORD PTR [rbx+0x18]
	arr[a] = arr[b];
  41471f:	49 8b 0c 24          	mov    rcx,QWORD PTR [r12]
	t      = arr[a];
  414723:	48 8b 10             	mov    rdx,QWORD PTR [rax]
		swap_entries(h->data, p, c, h->u);
  414726:	4c 8b 7b 10          	mov    r15,QWORD PTR [rbx+0x10]
	arr[a] = arr[b];
  41472a:	48 89 08             	mov    QWORD PTR [rax],rcx
	arr[b] = t;
  41472d:	49 89 14 24          	mov    QWORD PTR [r12],rdx
	u(arr[a], a);
  414731:	48 8b 38             	mov    rdi,QWORD PTR [rax]
  414734:	41 ff d7             	call   r15
	u(arr[b], b);
  414737:	49 8b 3c 24          	mov    rdi,QWORD PTR [r12]
  41473b:	44 89 ee             	mov    esi,r13d
  41473e:	41 ff d7             	call   r15
	while (c > 1) {
  414741:	41 83 fe 01          	cmp    r14d,0x1
  414745:	0f 84 15 01 00 00    	je     414860 <heap_add+0x1b0>
		p = c / 2;
  41474b:	49 63 ce             	movsxd rcx,r14d
		if (h->c(h->data[p], h->data[c])) break; /* done? */
  41474e:	48 8b 43 18          	mov    rax,QWORD PTR [rbx+0x18]
		p = c / 2;
  414752:	41 89 ce             	mov    r14d,ecx
  414755:	49 89 cd             	mov    r13,rcx
		if (h->c(h->data[p], h->data[c])) break; /* done? */
  414758:	4c 8d 24 cd 00 00 00 	lea    r12,[rcx*8+0x0]
  41475f:	00 
		p = c / 2;
  414760:	41 d1 fe             	sar    r14d,1
		if (h->c(h->data[p], h->data[c])) break; /* done? */
  414763:	48 8b 34 c8          	mov    rsi,QWORD PTR [rax+rcx*8]
  414767:	49 63 d6             	movsxd rdx,r14d
  41476a:	48 8d 3c d5 00 00 00 	lea    rdi,[rdx*8+0x0]
  414771:	00 
  414772:	48 89 7d c8          	mov    QWORD PTR [rbp-0x38],rdi
  414776:	48 8b 3c d0          	mov    rdi,QWORD PTR [rax+rdx*8]
  41477a:	ff 53 08             	call   QWORD PTR [rbx+0x8]
  41477d:	85 c0                	test   eax,eax
  41477f:	74 8f                	je     414710 <heap_add+0x60>
	assert(c <= h->e);
  414781:	8b 03                	mov    eax,DWORD PTR [rbx]
  414783:	41 39 c5             	cmp    r13d,eax
  414786:	0f 8f 2a 01 00 00    	jg     4148b6 <heap_add+0x206>
	l = h->e - 1;
  41478c:	83 e8 01             	sub    eax,0x1
  41478f:	89 45 c4             	mov    DWORD PTR [rbp-0x3c],eax
	while (c <= l / 2) { /* not a leaf? */
  414792:	d1 f8                	sar    eax,1
  414794:	89 45 c0             	mov    DWORD PTR [rbp-0x40],eax
  414797:	41 39 c5             	cmp    r13d,eax
  41479a:	7e 75                	jle    414811 <heap_add+0x161>
  41479c:	e9 cc 00 00 00       	jmp    41486d <heap_add+0x1bd>
  4147a1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		if (h->c(h->data[c], h->data[n])) break; /* done? */
  4147a8:	48 8b 43 18          	mov    rax,QWORD PTR [rbx+0x18]
  4147ac:	49 63 f7             	movsxd rsi,r15d
  4147af:	49 63 cd             	movsxd rcx,r13d
  4147b2:	4c 8d 24 f5 00 00 00 	lea    r12,[rsi*8+0x0]
  4147b9:	00 
  4147ba:	4c 8d 34 cd 00 00 00 	lea    r14,[rcx*8+0x0]
  4147c1:	00 
  4147c2:	48 8b 34 f0          	mov    rsi,QWORD PTR [rax+rsi*8]
  4147c6:	48 8b 3c c8          	mov    rdi,QWORD PTR [rax+rcx*8]
  4147ca:	ff 53 08             	call   QWORD PTR [rbx+0x8]
  4147cd:	85 c0                	test   eax,eax
  4147cf:	0f 85 98 00 00 00    	jne    41486d <heap_add+0x1bd>
	t      = arr[a];
  4147d5:	4c 03 63 18          	add    r12,QWORD PTR [rbx+0x18]
	arr[a] = arr[b];
  4147d9:	4c 03 73 18          	add    r14,QWORD PTR [rbx+0x18]
		swap_entries(h->data, n, c, h->u);
  4147dd:	48 8b 43 10          	mov    rax,QWORD PTR [rbx+0x10]
	arr[a] = arr[b];
  4147e1:	49 8b 36             	mov    rsi,QWORD PTR [r14]
	t      = arr[a];
  4147e4:	49 8b 0c 24          	mov    rcx,QWORD PTR [r12]
	u(arr[a], a);
  4147e8:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
	arr[a] = arr[b];
  4147ec:	49 89 34 24          	mov    QWORD PTR [r12],rsi
	u(arr[a], a);
  4147f0:	44 89 fe             	mov    esi,r15d
	arr[b] = t;
  4147f3:	49 89 0e             	mov    QWORD PTR [r14],rcx
	u(arr[a], a);
  4147f6:	49 8b 3c 24          	mov    rdi,QWORD PTR [r12]
  4147fa:	ff d0                	call   rax
	u(arr[b], b);
  4147fc:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  4147ff:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  414803:	44 89 ee             	mov    esi,r13d
  414806:	ff d0                	call   rax
	while (c <= l / 2) { /* not a leaf? */
  414808:	44 3b 7d c0          	cmp    r15d,DWORD PTR [rbp-0x40]
  41480c:	7f 5f                	jg     41486d <heap_add+0x1bd>
  41480e:	45 89 fd             	mov    r13d,r15d
		left  = 2 * c;
  414811:	47 8d 7c 2d 00       	lea    r15d,[r13+r13*1+0x0]
		right = 2 * c + 1;
  414816:	45 8d 67 01          	lea    r12d,[r15+0x1]
		if (right > l) {
  41481a:	44 39 65 c4          	cmp    DWORD PTR [rbp-0x3c],r12d
  41481e:	7c 1b                	jl     41483b <heap_add+0x18b>
		} else if (h->c(h->data[left], h->data[right])) {
  414820:	48 8b 43 18          	mov    rax,QWORD PTR [rbx+0x18]
  414824:	49 63 cc             	movsxd rcx,r12d
  414827:	48 8b 34 c8          	mov    rsi,QWORD PTR [rax+rcx*8]
  41482b:	49 63 cf             	movsxd rcx,r15d
  41482e:	48 8b 3c c8          	mov    rdi,QWORD PTR [rax+rcx*8]
  414832:	ff 53 08             	call   QWORD PTR [rbx+0x8]
  414835:	85 c0                	test   eax,eax
  414837:	45 0f 44 fc          	cmove  r15d,r12d
		assert(n < h->e);
  41483b:	44 39 3b             	cmp    DWORD PTR [rbx],r15d
  41483e:	0f 8f 64 ff ff ff    	jg     4147a8 <heap_add+0xf8>
  414844:	be 23 00 00 00       	mov    esi,0x23
  414849:	bf e0 df 41 00       	mov    edi,0x41dfe0
  41484e:	e8 7d 58 ff ff       	call   40a0d0 <cos_print_str>
  414853:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41485a:	00 00 00 00 
  41485e:	0f 0b                	ud2    
	assert(c <= h->e);
  414860:	8b 03                	mov    eax,DWORD PTR [rbx]
  414862:	41 bd 01 00 00 00    	mov    r13d,0x1
  414868:	e9 16 ff ff ff       	jmp    414783 <heap_add+0xd3>
	heapify(h, c);
	assert(!heap_verify(h));

	return 0;
  41486d:	31 c0                	xor    eax,eax
}
  41486f:	48 83 c4 18          	add    rsp,0x18
  414873:	5b                   	pop    rbx
  414874:	41 5c                	pop    r12
  414876:	41 5d                	pop    r13
  414878:	41 5e                	pop    r14
  41487a:	41 5f                	pop    r15
  41487c:	5d                   	pop    rbp
  41487d:	c3                   	ret    
  41487e:	be 23 00 00 00       	mov    esi,0x23
  414883:	bf 68 df 41 00       	mov    edi,0x41df68
  414888:	e8 43 58 ff ff       	call   40a0d0 <cos_print_str>
	assert(c <= h->e);
  41488d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414894:	00 00 00 00 
  414898:	0f 0b                	ud2    
  41489a:	be 23 00 00 00       	mov    esi,0x23
  41489f:	bf 90 df 41 00       	mov    edi,0x41df90
  4148a4:	e8 27 58 ff ff       	call   40a0d0 <cos_print_str>
	assert(c > 0);
  4148a9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4148b0:	00 00 00 00 
  4148b4:	0f 0b                	ud2    
  4148b6:	be 23 00 00 00       	mov    esi,0x23
  4148bb:	bf b8 df 41 00       	mov    edi,0x41dfb8
  4148c0:	e8 0b 58 ff ff       	call   40a0d0 <cos_print_str>
	assert(c <= h->e);
  4148c5:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4148cc:	00 00 00 00 
  4148d0:	0f 0b                	ud2    
	if (h->max_sz == h->e) return -1;
  4148d2:	b8 ff ff ff ff       	mov    eax,0xffffffff
  4148d7:	eb 96                	jmp    41486f <heap_add+0x1bf>
  4148d9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

00000000004148e0 <heap_highest>:

void *
heap_highest(struct heap *h)
{
  4148e0:	f3 0f 1e fa          	endbr64 
  4148e4:	55                   	push   rbp
  4148e5:	48 89 e5             	mov    rbp,rsp
  4148e8:	41 57                	push   r15
  4148ea:	41 56                	push   r14
  4148ec:	41 55                	push   r13
  4148ee:	41 54                	push   r12
  4148f0:	53                   	push   rbx
  4148f1:	48 83 ec 28          	sub    rsp,0x28
	void *r;

	if (h->e == 1) return NULL;
  4148f5:	8b 07                	mov    eax,DWORD PTR [rdi]
  4148f7:	83 f8 01             	cmp    eax,0x1
  4148fa:	0f 84 2d 01 00 00    	je     414a2d <heap_highest+0x14d>

	assert(!heap_verify(h));
	r = h->data[1];
  414900:	48 8b 57 18          	mov    rdx,QWORD PTR [rdi+0x18]
	debug("heap_highest(%p,%d) %p\n", h, h->e, r);

	h->e--;
  414904:	83 e8 01             	sub    eax,0x1
  414907:	49 89 ff             	mov    r15,rdi
	h->data[1] = h->data[h->e];
	h->u(h->data[1], 1);
  41490a:	be 01 00 00 00       	mov    esi,0x1
	r = h->data[1];
  41490f:	48 8b 4a 08          	mov    rcx,QWORD PTR [rdx+0x8]
	h->e--;
  414913:	89 07                	mov    DWORD PTR [rdi],eax
	h->data[1] = h->data[h->e];
  414915:	48 98                	cdqe   
  414917:	48 8b 04 c2          	mov    rax,QWORD PTR [rdx+rax*8]
	r = h->data[1];
  41491b:	48 89 4d b8          	mov    QWORD PTR [rbp-0x48],rcx
	h->data[1] = h->data[h->e];
  41491f:	48 89 42 08          	mov    QWORD PTR [rdx+0x8],rax
	h->u(h->data[1], 1);
  414923:	48 8b 47 18          	mov    rax,QWORD PTR [rdi+0x18]
  414927:	48 8b 78 08          	mov    rdi,QWORD PTR [rax+0x8]
  41492b:	41 ff 57 10          	call   QWORD PTR [r15+0x10]
	assert(c <= h->e);
  41492f:	45 8b 2f             	mov    r13d,DWORD PTR [r15]
  414932:	45 85 ed             	test   r13d,r13d
  414935:	0f 8e fc 00 00 00    	jle    414a37 <heap_highest+0x157>
	l = h->e - 1;
  41493b:	41 8d 45 ff          	lea    eax,[r13-0x1]
  41493f:	89 45 c4             	mov    DWORD PTR [rbp-0x3c],eax
	while (c <= l / 2) { /* not a leaf? */
  414942:	d1 f8                	sar    eax,1
  414944:	89 45 c0             	mov    DWORD PTR [rbp-0x40],eax
  414947:	0f 84 c3 00 00 00    	je     414a10 <heap_highest+0x130>
  41494d:	41 bc 01 00 00 00    	mov    r12d,0x1
  414953:	eb 6d                	jmp    4149c2 <heap_highest+0xe2>
  414955:	0f 1f 00             	nop    DWORD PTR [rax]
		if (h->c(h->data[c], h->data[n])) break; /* done? */
  414958:	49 8b 47 18          	mov    rax,QWORD PTR [r15+0x18]
  41495c:	49 63 fd             	movsxd rdi,r13d
  41495f:	49 63 f4             	movsxd rsi,r12d
  414962:	48 8d 1c fd 00 00 00 	lea    rbx,[rdi*8+0x0]
  414969:	00 
  41496a:	4c 8d 34 f5 00 00 00 	lea    r14,[rsi*8+0x0]
  414971:	00 
  414972:	4c 8b 04 f8          	mov    r8,QWORD PTR [rax+rdi*8]
  414976:	48 8b 3c f0          	mov    rdi,QWORD PTR [rax+rsi*8]
  41497a:	4c 89 c6             	mov    rsi,r8
  41497d:	41 ff 57 08          	call   QWORD PTR [r15+0x8]
  414981:	85 c0                	test   eax,eax
  414983:	0f 85 87 00 00 00    	jne    414a10 <heap_highest+0x130>
	t      = arr[a];
  414989:	49 03 5f 18          	add    rbx,QWORD PTR [r15+0x18]
	arr[a] = arr[b];
  41498d:	4d 03 77 18          	add    r14,QWORD PTR [r15+0x18]
		swap_entries(h->data, n, c, h->u);
  414991:	49 8b 47 10          	mov    rax,QWORD PTR [r15+0x10]
	t      = arr[a];
  414995:	48 8b 33             	mov    rsi,QWORD PTR [rbx]
	arr[a] = arr[b];
  414998:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
	u(arr[a], a);
  41499b:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
	arr[a] = arr[b];
  41499f:	48 89 3b             	mov    QWORD PTR [rbx],rdi
	arr[b] = t;
  4149a2:	49 89 36             	mov    QWORD PTR [r14],rsi
	u(arr[a], a);
  4149a5:	44 89 ee             	mov    esi,r13d
  4149a8:	48 8b 3b             	mov    rdi,QWORD PTR [rbx]
  4149ab:	ff d0                	call   rax
	u(arr[b], b);
  4149ad:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  4149b0:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  4149b4:	44 89 e6             	mov    esi,r12d
  4149b7:	ff d0                	call   rax
	while (c <= l / 2) { /* not a leaf? */
  4149b9:	44 3b 6d c0          	cmp    r13d,DWORD PTR [rbp-0x40]
  4149bd:	7f 51                	jg     414a10 <heap_highest+0x130>
  4149bf:	45 89 ec             	mov    r12d,r13d
		left  = 2 * c;
  4149c2:	47 8d 2c 24          	lea    r13d,[r12+r12*1]
		right = 2 * c + 1;
  4149c6:	41 8d 5d 01          	lea    ebx,[r13+0x1]
		if (right > l) {
  4149ca:	39 5d c4             	cmp    DWORD PTR [rbp-0x3c],ebx
  4149cd:	7c 1c                	jl     4149eb <heap_highest+0x10b>
		} else if (h->c(h->data[left], h->data[right])) {
  4149cf:	49 8b 47 18          	mov    rax,QWORD PTR [r15+0x18]
  4149d3:	49 63 fd             	movsxd rdi,r13d
  4149d6:	48 63 f3             	movsxd rsi,ebx
  4149d9:	48 8b 34 f0          	mov    rsi,QWORD PTR [rax+rsi*8]
  4149dd:	48 8b 3c f8          	mov    rdi,QWORD PTR [rax+rdi*8]
  4149e1:	41 ff 57 08          	call   QWORD PTR [r15+0x8]
  4149e5:	85 c0                	test   eax,eax
  4149e7:	44 0f 44 eb          	cmove  r13d,ebx
		assert(n < h->e);
  4149eb:	45 39 2f             	cmp    DWORD PTR [r15],r13d
  4149ee:	0f 8f 64 ff ff ff    	jg     414958 <heap_highest+0x78>
  4149f4:	be 23 00 00 00       	mov    esi,0x23
  4149f9:	bf e0 df 41 00       	mov    edi,0x41dfe0
  4149fe:	e8 cd 56 ff ff       	call   40a0d0 <cos_print_str>
  414a03:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414a0a:	00 00 00 00 
  414a0e:	0f 0b                	ud2    
	swap_down(h, 1);
	assert(!heap_verify(h));
	h->u(r, 0);
  414a10:	48 8b 7d b8          	mov    rdi,QWORD PTR [rbp-0x48]
  414a14:	31 f6                	xor    esi,esi
  414a16:	41 ff 57 10          	call   QWORD PTR [r15+0x10]

	return r;
}
  414a1a:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  414a1e:	48 83 c4 28          	add    rsp,0x28
  414a22:	5b                   	pop    rbx
  414a23:	41 5c                	pop    r12
  414a25:	41 5d                	pop    r13
  414a27:	41 5e                	pop    r14
  414a29:	41 5f                	pop    r15
  414a2b:	5d                   	pop    rbp
  414a2c:	c3                   	ret    
	if (h->e == 1) return NULL;
  414a2d:	48 c7 45 b8 00 00 00 	mov    QWORD PTR [rbp-0x48],0x0
  414a34:	00 
  414a35:	eb e3                	jmp    414a1a <heap_highest+0x13a>
  414a37:	be 23 00 00 00       	mov    esi,0x23
  414a3c:	bf b8 df 41 00       	mov    edi,0x41dfb8
  414a41:	e8 8a 56 ff ff       	call   40a0d0 <cos_print_str>
	assert(c <= h->e);
  414a46:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414a4d:	00 00 00 00 
  414a51:	0f 0b                	ud2    
  414a53:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  414a5a:	00 00 00 00 
  414a5e:	66 90                	xchg   ax,ax

0000000000414a60 <heap_peek>:

void *
heap_peek(struct heap *h)
{
  414a60:	f3 0f 1e fa          	endbr64 
	if (h->e == 1) return NULL;
  414a64:	83 3f 01             	cmp    DWORD PTR [rdi],0x1
  414a67:	74 0f                	je     414a78 <heap_peek+0x18>
	assert(!heap_verify(h));
	return h->data[1];
  414a69:	48 8b 47 18          	mov    rax,QWORD PTR [rdi+0x18]
  414a6d:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  414a71:	c3                   	ret    
  414a72:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	if (h->e == 1) return NULL;
  414a78:	31 c0                	xor    eax,eax
}
  414a7a:	c3                   	ret    
  414a7b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000414a80 <heap_adjust>:

void
heap_adjust(struct heap *h, int c)
{
  414a80:	f3 0f 1e fa          	endbr64 
  414a84:	55                   	push   rbp
  414a85:	48 89 e5             	mov    rbp,rsp
  414a88:	41 57                	push   r15
  414a8a:	41 56                	push   r14
  414a8c:	41 55                	push   r13
  414a8e:	41 54                	push   r12
  414a90:	53                   	push   rbx
  414a91:	48 83 ec 18          	sub    rsp,0x18
	assert(c < h->e);
  414a95:	8b 07                	mov    eax,DWORD PTR [rdi]
  414a97:	39 f0                	cmp    eax,esi
  414a99:	0f 8e 8d 01 00 00    	jle    414c2c <heap_adjust+0x1ac>
  414a9f:	41 89 f6             	mov    r14d,esi
	assert(c > 0);
  414aa2:	85 f6                	test   esi,esi
  414aa4:	0f 8e 9e 01 00 00    	jle    414c48 <heap_adjust+0x1c8>
  414aaa:	48 89 fb             	mov    rbx,rdi
	while (c > 1) {
  414aad:	83 fe 01             	cmp    esi,0x1
  414ab0:	75 49                	jne    414afb <heap_adjust+0x7b>
  414ab2:	e9 5b 01 00 00       	jmp    414c12 <heap_adjust+0x192>
  414ab7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  414abe:	00 00 
	arr[a] = arr[b];
  414ac0:	4c 03 63 18          	add    r12,QWORD PTR [rbx+0x18]
	t      = arr[a];
  414ac4:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
	u(arr[a], a);
  414ac8:	44 89 f6             	mov    esi,r14d
	t      = arr[a];
  414acb:	48 03 43 18          	add    rax,QWORD PTR [rbx+0x18]
	arr[a] = arr[b];
  414acf:	49 8b 0c 24          	mov    rcx,QWORD PTR [r12]
	t      = arr[a];
  414ad3:	48 8b 10             	mov    rdx,QWORD PTR [rax]
		swap_entries(h->data, p, c, h->u);
  414ad6:	4c 8b 7b 10          	mov    r15,QWORD PTR [rbx+0x10]
	arr[a] = arr[b];
  414ada:	48 89 08             	mov    QWORD PTR [rax],rcx
	arr[b] = t;
  414add:	49 89 14 24          	mov    QWORD PTR [r12],rdx
	u(arr[a], a);
  414ae1:	48 8b 38             	mov    rdi,QWORD PTR [rax]
  414ae4:	41 ff d7             	call   r15
	u(arr[b], b);
  414ae7:	49 8b 3c 24          	mov    rdi,QWORD PTR [r12]
  414aeb:	44 89 ee             	mov    esi,r13d
  414aee:	41 ff d7             	call   r15
	while (c > 1) {
  414af1:	41 83 fe 01          	cmp    r14d,0x1
  414af5:	0f 84 15 01 00 00    	je     414c10 <heap_adjust+0x190>
		p = c / 2;
  414afb:	49 63 ce             	movsxd rcx,r14d
		if (h->c(h->data[p], h->data[c])) break; /* done? */
  414afe:	48 8b 43 18          	mov    rax,QWORD PTR [rbx+0x18]
		p = c / 2;
  414b02:	41 89 ce             	mov    r14d,ecx
  414b05:	49 89 cd             	mov    r13,rcx
		if (h->c(h->data[p], h->data[c])) break; /* done? */
  414b08:	4c 8d 24 cd 00 00 00 	lea    r12,[rcx*8+0x0]
  414b0f:	00 
		p = c / 2;
  414b10:	41 d1 fe             	sar    r14d,1
		if (h->c(h->data[p], h->data[c])) break; /* done? */
  414b13:	48 8b 34 c8          	mov    rsi,QWORD PTR [rax+rcx*8]
  414b17:	49 63 d6             	movsxd rdx,r14d
  414b1a:	48 8d 3c d5 00 00 00 	lea    rdi,[rdx*8+0x0]
  414b21:	00 
  414b22:	48 89 7d c8          	mov    QWORD PTR [rbp-0x38],rdi
  414b26:	48 8b 3c d0          	mov    rdi,QWORD PTR [rax+rdx*8]
  414b2a:	ff 53 08             	call   QWORD PTR [rbx+0x8]
  414b2d:	85 c0                	test   eax,eax
  414b2f:	74 8f                	je     414ac0 <heap_adjust+0x40>
	assert(c <= h->e);
  414b31:	8b 03                	mov    eax,DWORD PTR [rbx]
  414b33:	44 39 e8             	cmp    eax,r13d
  414b36:	0f 8c 28 01 00 00    	jl     414c64 <heap_adjust+0x1e4>
	l = h->e - 1;
  414b3c:	83 e8 01             	sub    eax,0x1
  414b3f:	89 45 c4             	mov    DWORD PTR [rbp-0x3c],eax
	while (c <= l / 2) { /* not a leaf? */
  414b42:	d1 f8                	sar    eax,1
  414b44:	89 45 c0             	mov    DWORD PTR [rbp-0x40],eax
  414b47:	44 39 e8             	cmp    eax,r13d
  414b4a:	7d 75                	jge    414bc1 <heap_adjust+0x141>
  414b4c:	e9 cc 00 00 00       	jmp    414c1d <heap_adjust+0x19d>
  414b51:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		if (h->c(h->data[c], h->data[n])) break; /* done? */
  414b58:	48 8b 43 18          	mov    rax,QWORD PTR [rbx+0x18]
  414b5c:	49 63 f7             	movsxd rsi,r15d
  414b5f:	49 63 cd             	movsxd rcx,r13d
  414b62:	4c 8d 24 f5 00 00 00 	lea    r12,[rsi*8+0x0]
  414b69:	00 
  414b6a:	4c 8d 34 cd 00 00 00 	lea    r14,[rcx*8+0x0]
  414b71:	00 
  414b72:	48 8b 34 f0          	mov    rsi,QWORD PTR [rax+rsi*8]
  414b76:	48 8b 3c c8          	mov    rdi,QWORD PTR [rax+rcx*8]
  414b7a:	ff 53 08             	call   QWORD PTR [rbx+0x8]
  414b7d:	85 c0                	test   eax,eax
  414b7f:	0f 85 98 00 00 00    	jne    414c1d <heap_adjust+0x19d>
	t      = arr[a];
  414b85:	4c 03 63 18          	add    r12,QWORD PTR [rbx+0x18]
	arr[a] = arr[b];
  414b89:	4c 03 73 18          	add    r14,QWORD PTR [rbx+0x18]
		swap_entries(h->data, n, c, h->u);
  414b8d:	48 8b 43 10          	mov    rax,QWORD PTR [rbx+0x10]
	arr[a] = arr[b];
  414b91:	49 8b 36             	mov    rsi,QWORD PTR [r14]
	t      = arr[a];
  414b94:	49 8b 0c 24          	mov    rcx,QWORD PTR [r12]
	u(arr[a], a);
  414b98:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
	arr[a] = arr[b];
  414b9c:	49 89 34 24          	mov    QWORD PTR [r12],rsi
	u(arr[a], a);
  414ba0:	44 89 fe             	mov    esi,r15d
	arr[b] = t;
  414ba3:	49 89 0e             	mov    QWORD PTR [r14],rcx
	u(arr[a], a);
  414ba6:	49 8b 3c 24          	mov    rdi,QWORD PTR [r12]
  414baa:	ff d0                	call   rax
	u(arr[b], b);
  414bac:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  414baf:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  414bb3:	44 89 ee             	mov    esi,r13d
  414bb6:	ff d0                	call   rax
	while (c <= l / 2) { /* not a leaf? */
  414bb8:	44 39 7d c0          	cmp    DWORD PTR [rbp-0x40],r15d
  414bbc:	7c 5f                	jl     414c1d <heap_adjust+0x19d>
  414bbe:	45 89 fd             	mov    r13d,r15d
		left  = 2 * c;
  414bc1:	47 8d 7c 2d 00       	lea    r15d,[r13+r13*1+0x0]
		right = 2 * c + 1;
  414bc6:	45 8d 67 01          	lea    r12d,[r15+0x1]
		if (right > l) {
  414bca:	44 39 65 c4          	cmp    DWORD PTR [rbp-0x3c],r12d
  414bce:	7c 1b                	jl     414beb <heap_adjust+0x16b>
		} else if (h->c(h->data[left], h->data[right])) {
  414bd0:	48 8b 43 18          	mov    rax,QWORD PTR [rbx+0x18]
  414bd4:	49 63 cc             	movsxd rcx,r12d
  414bd7:	48 8b 34 c8          	mov    rsi,QWORD PTR [rax+rcx*8]
  414bdb:	49 63 cf             	movsxd rcx,r15d
  414bde:	48 8b 3c c8          	mov    rdi,QWORD PTR [rax+rcx*8]
  414be2:	ff 53 08             	call   QWORD PTR [rbx+0x8]
  414be5:	85 c0                	test   eax,eax
  414be7:	45 0f 44 fc          	cmove  r15d,r12d
		assert(n < h->e);
  414beb:	44 39 3b             	cmp    DWORD PTR [rbx],r15d
  414bee:	0f 8f 64 ff ff ff    	jg     414b58 <heap_adjust+0xd8>
  414bf4:	be 23 00 00 00       	mov    esi,0x23
  414bf9:	bf e0 df 41 00       	mov    edi,0x41dfe0
  414bfe:	e8 cd 54 ff ff       	call   40a0d0 <cos_print_str>
  414c03:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414c0a:	00 00 00 00 
  414c0e:	0f 0b                	ud2    
	assert(c <= h->e);
  414c10:	8b 03                	mov    eax,DWORD PTR [rbx]
  414c12:	41 bd 01 00 00 00    	mov    r13d,0x1
  414c18:	e9 16 ff ff ff       	jmp    414b33 <heap_adjust+0xb3>

	debug("heap_adjust(%p,%d) %p@%d\n", h, h->e, h->data[c], c);
	heapify(h, c);
	assert(!heap_verify(h));
}
  414c1d:	48 83 c4 18          	add    rsp,0x18
  414c21:	5b                   	pop    rbx
  414c22:	41 5c                	pop    r12
  414c24:	41 5d                	pop    r13
  414c26:	41 5e                	pop    r14
  414c28:	41 5f                	pop    r15
  414c2a:	5d                   	pop    rbp
  414c2b:	c3                   	ret    
  414c2c:	be 24 00 00 00       	mov    esi,0x24
  414c31:	bf 08 e0 41 00       	mov    edi,0x41e008
  414c36:	e8 95 54 ff ff       	call   40a0d0 <cos_print_str>
	assert(c < h->e);
  414c3b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414c42:	00 00 00 00 
  414c46:	0f 0b                	ud2    
  414c48:	be 24 00 00 00       	mov    esi,0x24
  414c4d:	bf 30 e0 41 00       	mov    edi,0x41e030
  414c52:	e8 79 54 ff ff       	call   40a0d0 <cos_print_str>
	assert(c > 0);
  414c57:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414c5e:	00 00 00 00 
  414c62:	0f 0b                	ud2    
  414c64:	be 23 00 00 00       	mov    esi,0x23
  414c69:	bf b8 df 41 00       	mov    edi,0x41dfb8
  414c6e:	e8 5d 54 ff ff       	call   40a0d0 <cos_print_str>
	assert(c <= h->e);
  414c73:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414c7a:	00 00 00 00 
  414c7e:	0f 0b                	ud2    

0000000000414c80 <heap_remove>:

void *
heap_remove(struct heap *h, int c)
{
  414c80:	f3 0f 1e fa          	endbr64 
  414c84:	55                   	push   rbp
  414c85:	48 89 e5             	mov    rbp,rsp
  414c88:	41 56                	push   r14
  414c8a:	41 55                	push   r13
  414c8c:	41 54                	push   r12
  414c8e:	53                   	push   rbx
	void *r;

	assert(c < h->e);
  414c8f:	8b 07                	mov    eax,DWORD PTR [rdi]
  414c91:	39 f0                	cmp    eax,esi
  414c93:	7e 6f                	jle    414d04 <heap_remove+0x84>
  414c95:	41 89 f5             	mov    r13d,esi
	assert(c >= 1);
  414c98:	85 f6                	test   esi,esi
  414c9a:	0f 8e 80 00 00 00    	jle    414d20 <heap_remove+0xa0>
	if (h->e == 1) return NULL;
  414ca0:	83 f8 01             	cmp    eax,0x1
  414ca3:	0f 84 93 00 00 00    	je     414d3c <heap_remove+0xbc>

	assert(!heap_verify(h));
	r = h->data[c];
  414ca9:	48 8b 57 18          	mov    rdx,QWORD PTR [rdi+0x18]
  414cad:	48 63 de             	movsxd rbx,esi
  414cb0:	49 89 fc             	mov    r12,rdi
	debug("heap_remove(%p,%d) %p@%d\n", h, h->e, h->data[c], c);
	h->e--;
  414cb3:	83 e8 01             	sub    eax,0x1
	h->u(r, 0);
  414cb6:	31 f6                	xor    esi,esi
	r = h->data[c];
  414cb8:	4c 8b 34 da          	mov    r14,QWORD PTR [rdx+rbx*8]
	h->e--;
  414cbc:	89 07                	mov    DWORD PTR [rdi],eax
	h->u(r, 0);
  414cbe:	4c 89 f7             	mov    rdi,r14
  414cc1:	41 ff 54 24 10       	call   QWORD PTR [r12+0x10]

	if (c == h->e) {
  414cc6:	49 63 04 24          	movsxd rax,DWORD PTR [r12]
  414cca:	44 39 e8             	cmp    eax,r13d
  414ccd:	74 29                	je     414cf8 <heap_remove+0x78>
		assert(!heap_verify(h));
		return r;
	}
	h->data[c] = h->data[h->e];
  414ccf:	49 8b 54 24 18       	mov    rdx,QWORD PTR [r12+0x18]
	h->u(h->data[c], c);
  414cd4:	44 89 ee             	mov    esi,r13d
	h->data[c] = h->data[h->e];
  414cd7:	48 8b 04 c2          	mov    rax,QWORD PTR [rdx+rax*8]
  414cdb:	48 89 04 da          	mov    QWORD PTR [rdx+rbx*8],rax
	h->u(h->data[c], c);
  414cdf:	49 8b 44 24 18       	mov    rax,QWORD PTR [r12+0x18]
  414ce4:	48 8b 3c d8          	mov    rdi,QWORD PTR [rax+rbx*8]
  414ce8:	41 ff 54 24 10       	call   QWORD PTR [r12+0x10]
	heap_adjust(h, c);
  414ced:	44 89 ee             	mov    esi,r13d
  414cf0:	4c 89 e7             	mov    rdi,r12
  414cf3:	e8 88 fd ff ff       	call   414a80 <heap_adjust>
	assert(!heap_verify(h));

	return r;
}
  414cf8:	5b                   	pop    rbx
  414cf9:	4c 89 f0             	mov    rax,r14
  414cfc:	41 5c                	pop    r12
  414cfe:	41 5d                	pop    r13
  414d00:	41 5e                	pop    r14
  414d02:	5d                   	pop    rbp
  414d03:	c3                   	ret    
  414d04:	be 24 00 00 00       	mov    esi,0x24
  414d09:	bf 58 e0 41 00       	mov    edi,0x41e058
  414d0e:	e8 bd 53 ff ff       	call   40a0d0 <cos_print_str>
	assert(c < h->e);
  414d13:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414d1a:	00 00 00 00 
  414d1e:	0f 0b                	ud2    
  414d20:	be 24 00 00 00       	mov    esi,0x24
  414d25:	bf 80 e0 41 00       	mov    edi,0x41e080
  414d2a:	e8 a1 53 ff ff       	call   40a0d0 <cos_print_str>
	assert(c >= 1);
  414d2f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414d36:	00 00 00 00 
  414d3a:	0f 0b                	ud2    
	if (h->e == 1) return NULL;
  414d3c:	45 31 f6             	xor    r14d,r14d
  414d3f:	eb b7                	jmp    414cf8 <heap_remove+0x78>
  414d41:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  414d48:	00 00 00 00 
  414d4c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000414d50 <heap_size>:

int
heap_size(struct heap *h)
{
  414d50:	f3 0f 1e fa          	endbr64 
	return h->e - 1;
  414d54:	8b 07                	mov    eax,DWORD PTR [rdi]
  414d56:	83 e8 01             	sub    eax,0x1
}
  414d59:	c3                   	ret    

0000000000414d5a <memcpy>:
.global __memcpy_fwd
.hidden __memcpy_fwd
.type memcpy,@function
memcpy:
__memcpy_fwd:
	mov %rdi,%rax
  414d5a:	48 89 f8             	mov    rax,rdi
	cmp $8,%rdx
  414d5d:	48 83 fa 08          	cmp    rdx,0x8
	jc 1f
  414d61:	72 14                	jb     414d77 <memcpy+0x1d>
	test $7,%edi
  414d63:	f7 c7 07 00 00 00    	test   edi,0x7
	jz 1f
  414d69:	74 0c                	je     414d77 <memcpy+0x1d>
2:	movsb
  414d6b:	a4                   	movs   BYTE PTR es:[rdi],BYTE PTR ds:[rsi]
	dec %rdx
  414d6c:	48 ff ca             	dec    rdx
	test $7,%edi
  414d6f:	f7 c7 07 00 00 00    	test   edi,0x7
	jnz 2b
  414d75:	75 f4                	jne    414d6b <memcpy+0x11>
1:	mov %rdx,%rcx
  414d77:	48 89 d1             	mov    rcx,rdx
	shr $3,%rcx
  414d7a:	48 c1 e9 03          	shr    rcx,0x3
	rep
  414d7e:	f3 48 a5             	rep movs QWORD PTR es:[rdi],QWORD PTR ds:[rsi]
	movsq
	and $7,%edx
  414d81:	83 e2 07             	and    edx,0x7
	jz 1f
  414d84:	74 05                	je     414d8b <memcpy+0x31>
2:	movsb
  414d86:	a4                   	movs   BYTE PTR es:[rdi],BYTE PTR ds:[rsi]
	dec %edx
  414d87:	ff ca                	dec    edx
	jnz 2b
  414d89:	75 fb                	jne    414d86 <memcpy+0x2c>
1:	ret
  414d8b:	c3                   	ret    

0000000000414d8c <memset>:
.global memset
.type memset,@function
memset:
	movzbq %sil,%rax
  414d8c:	48 0f b6 c6          	movzx  rax,sil
	mov $0x101010101010101,%r8
  414d90:	49 b8 01 01 01 01 01 	movabs r8,0x101010101010101
  414d97:	01 01 01 
	imul %r8,%rax
  414d9a:	49 0f af c0          	imul   rax,r8

	cmp $126,%rdx
  414d9e:	48 83 fa 7e          	cmp    rdx,0x7e
	ja 2f
  414da2:	77 78                	ja     414e1c <memset+0x90>

	test %edx,%edx
  414da4:	85 d2                	test   edx,edx
	jz 1f
  414da6:	74 70                	je     414e18 <memset+0x8c>

	mov %sil,(%rdi)
  414da8:	40 88 37             	mov    BYTE PTR [rdi],sil
	mov %sil,-1(%rdi,%rdx)
  414dab:	40 88 74 17 ff       	mov    BYTE PTR [rdi+rdx*1-0x1],sil
	cmp $2,%edx
  414db0:	83 fa 02             	cmp    edx,0x2
	jbe 1f
  414db3:	76 63                	jbe    414e18 <memset+0x8c>

	mov %ax,1(%rdi)
  414db5:	66 89 47 01          	mov    WORD PTR [rdi+0x1],ax
	mov %ax,(-1-2)(%rdi,%rdx)
  414db9:	66 89 44 17 fd       	mov    WORD PTR [rdi+rdx*1-0x3],ax
	cmp $6,%edx
  414dbe:	83 fa 06             	cmp    edx,0x6
	jbe 1f
  414dc1:	76 55                	jbe    414e18 <memset+0x8c>

	mov %eax,(1+2)(%rdi)
  414dc3:	89 47 03             	mov    DWORD PTR [rdi+0x3],eax
	mov %eax,(-1-2-4)(%rdi,%rdx)
  414dc6:	89 44 17 f9          	mov    DWORD PTR [rdi+rdx*1-0x7],eax
	cmp $14,%edx
  414dca:	83 fa 0e             	cmp    edx,0xe
	jbe 1f
  414dcd:	76 49                	jbe    414e18 <memset+0x8c>

	mov %rax,(1+2+4)(%rdi)
  414dcf:	48 89 47 07          	mov    QWORD PTR [rdi+0x7],rax
	mov %rax,(-1-2-4-8)(%rdi,%rdx)
  414dd3:	48 89 44 17 f1       	mov    QWORD PTR [rdi+rdx*1-0xf],rax
	cmp $30,%edx
  414dd8:	83 fa 1e             	cmp    edx,0x1e
	jbe 1f
  414ddb:	76 3b                	jbe    414e18 <memset+0x8c>

	mov %rax,(1+2+4+8)(%rdi)
  414ddd:	48 89 47 0f          	mov    QWORD PTR [rdi+0xf],rax
	mov %rax,(1+2+4+8+8)(%rdi)
  414de1:	48 89 47 17          	mov    QWORD PTR [rdi+0x17],rax
	mov %rax,(-1-2-4-8-16)(%rdi,%rdx)
  414de5:	48 89 44 17 e1       	mov    QWORD PTR [rdi+rdx*1-0x1f],rax
	mov %rax,(-1-2-4-8-8)(%rdi,%rdx)
  414dea:	48 89 44 17 e9       	mov    QWORD PTR [rdi+rdx*1-0x17],rax
	cmp $62,%edx
  414def:	83 fa 3e             	cmp    edx,0x3e
	jbe 1f
  414df2:	76 24                	jbe    414e18 <memset+0x8c>

	mov %rax,(1+2+4+8+16)(%rdi)
  414df4:	48 89 47 1f          	mov    QWORD PTR [rdi+0x1f],rax
	mov %rax,(1+2+4+8+16+8)(%rdi)
  414df8:	48 89 47 27          	mov    QWORD PTR [rdi+0x27],rax
	mov %rax,(1+2+4+8+16+16)(%rdi)
  414dfc:	48 89 47 2f          	mov    QWORD PTR [rdi+0x2f],rax
	mov %rax,(1+2+4+8+16+24)(%rdi)
  414e00:	48 89 47 37          	mov    QWORD PTR [rdi+0x37],rax
	mov %rax,(-1-2-4-8-16-32)(%rdi,%rdx)
  414e04:	48 89 44 17 c1       	mov    QWORD PTR [rdi+rdx*1-0x3f],rax
	mov %rax,(-1-2-4-8-16-24)(%rdi,%rdx)
  414e09:	48 89 44 17 c9       	mov    QWORD PTR [rdi+rdx*1-0x37],rax
	mov %rax,(-1-2-4-8-16-16)(%rdi,%rdx)
  414e0e:	48 89 44 17 d1       	mov    QWORD PTR [rdi+rdx*1-0x2f],rax
	mov %rax,(-1-2-4-8-16-8)(%rdi,%rdx)
  414e13:	48 89 44 17 d9       	mov    QWORD PTR [rdi+rdx*1-0x27],rax

1:	mov %rdi,%rax
  414e18:	48 89 f8             	mov    rax,rdi
	ret
  414e1b:	c3                   	ret    

2:	test $15,%edi
  414e1c:	f7 c7 0f 00 00 00    	test   edi,0xf
	mov %rdi,%r8
  414e22:	49 89 f8             	mov    r8,rdi
	mov %rax,-8(%rdi,%rdx)
  414e25:	48 89 44 17 f8       	mov    QWORD PTR [rdi+rdx*1-0x8],rax
	mov %rdx,%rcx
  414e2a:	48 89 d1             	mov    rcx,rdx
	jnz 2f
  414e2d:	75 0b                	jne    414e3a <memset+0xae>

1:	shr $3,%rcx
  414e2f:	48 c1 e9 03          	shr    rcx,0x3
	rep
  414e33:	f3 48 ab             	rep stos QWORD PTR es:[rdi],rax
	stosq
	mov %r8,%rax
  414e36:	4c 89 c0             	mov    rax,r8
	ret
  414e39:	c3                   	ret    

2:	xor %edx,%edx
  414e3a:	31 d2                	xor    edx,edx
	sub %edi,%edx
  414e3c:	29 fa                	sub    edx,edi
	and $15,%edx
  414e3e:	83 e2 0f             	and    edx,0xf
	mov %rax,(%rdi)
  414e41:	48 89 07             	mov    QWORD PTR [rdi],rax
	mov %rax,8(%rdi)
  414e44:	48 89 47 08          	mov    QWORD PTR [rdi+0x8],rax
	sub %rdx,%rcx
  414e48:	48 29 d1             	sub    rcx,rdx
	add %rdx,%rdi
  414e4b:	48 01 d7             	add    rdi,rdx
	jmp 1b
  414e4e:	eb df                	jmp    414e2f <memset+0xa3>

0000000000414e50 <__set_thread_area>:
.text
.global __set_thread_area
.hidden __set_thread_area
.type __set_thread_area,@function
__set_thread_area:
	mov %rdi,%rsi           /* shift for syscall */
  414e50:	48 89 fe             	mov    rsi,rdi
	movl $0x1002,%edi       /* SET_FS register */
  414e53:	bf 02 10 00 00       	mov    edi,0x1002
	movl $158,%eax          /* set fs segment to */
  414e58:	b8 9e 00 00 00       	mov    eax,0x9e
	syscall                 /* arch_prctl(SET_FS, arg)*/
  414e5d:	0f 05                	syscall 
	ret
  414e5f:	c3                   	ret    

0000000000414e60 <sched_set_tls.cold>:
	thdcap_t thdcap = current->thd;
  414e60:	48 8b 04 25 10 00 00 	mov    rax,QWORD PTR ds:0x10
  414e67:	00 
  414e68:	0f 0b                	ud2    

0000000000414e6a <sched_debug_thd_state.cold>:
	return t->state;
  414e6a:	8b 04 25 04 00 00 00 	mov    eax,DWORD PTR ds:0x4
  414e71:	0f 0b                	ud2    
  414e73:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  414e7a:	00 00 00 
  414e7d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000414e80 <_init>:
#include <unistd.h>
#include "syscall.h"
#include "atomic.h"
#include "libc.h"

static void dummy(void) {}
  414e80:	f3 0f 1e fa          	endbr64 
  414e84:	c3                   	ret    
  414e85:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  414e8c:	00 00 00 
  414e8f:	90                   	nop

0000000000414e90 <__funcs_on_exit>:
#include <stdlib.h>
#include <stdint.h>
#include "libc.h"

static void dummy()
{
  414e90:	f3 0f 1e fa          	endbr64 
}
  414e94:	c3                   	ret    
  414e95:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  414e9c:	00 00 00 
  414e9f:	90                   	nop

0000000000414ea0 <__lctrans_impl>:
#include <locale.h>
#include "locale_impl.h"

static const char *dummy(const char *msg, const struct __locale_map *lm)
{
  414ea0:	f3 0f 1e fa          	endbr64 
  414ea4:	48 89 f8             	mov    rax,rdi
	return msg;
}
  414ea7:	c3                   	ret    
  414ea8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  414eaf:	00 

0000000000414eb0 <__init_ssp>:
weak_alias(dummy, _init);

extern weak hidden void (*const __init_array_start)(void), (*const __init_array_end)(void);

static void dummy1(void *p) {}
  414eb0:	f3 0f 1e fa          	endbr64 
  414eb4:	c3                   	ret    
  414eb5:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  414ebc:	00 00 00 
  414ebf:	90                   	nop

0000000000414ec0 <__init_libc>:

#ifdef __GNUC__
__attribute__((__noinline__))
#endif
void __init_libc(char **envp, char *pn)
{
  414ec0:	f3 0f 1e fa          	endbr64 
  414ec4:	48 81 ec 58 01 00 00 	sub    rsp,0x158
  414ecb:	48 89 fa             	mov    rdx,rdi
	size_t i, *auxv, aux[AUX_CNT] = { 0 };
  414ece:	31 c0                	xor    eax,eax
  414ed0:	b9 26 00 00 00       	mov    ecx,0x26
  414ed5:	4c 8d 44 24 20       	lea    r8,[rsp+0x20]
	__environ = envp;
	for (i=0; envp[i]; i++);
  414eda:	48 83 3a 00          	cmp    QWORD PTR [rdx],0x0
	size_t i, *auxv, aux[AUX_CNT] = { 0 };
  414ede:	4c 89 c7             	mov    rdi,r8
  414ee1:	f3 48 ab             	rep stos QWORD PTR es:[rdi],rax
	__environ = envp;
  414ee4:	48 c7 c0 70 20 5a 00 	mov    rax,0x5a2070
  414eeb:	48 89 10             	mov    QWORD PTR [rax],rdx
	for (i=0; envp[i]; i++);
  414eee:	0f 84 a4 02 00 00    	je     415198 <__init_libc+0x2d8>
  414ef4:	31 c0                	xor    eax,eax
  414ef6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  414efd:	00 00 00 
  414f00:	48 89 c1             	mov    rcx,rax
  414f03:	48 83 c0 01          	add    rax,0x1
  414f07:	48 83 3c c2 00       	cmp    QWORD PTR [rdx+rax*8],0x0
  414f0c:	75 f2                	jne    414f00 <__init_libc+0x40>
	libc.auxv = auxv = (void *)(envp+i+1);
  414f0e:	48 8d 04 cd 10 00 00 	lea    rax,[rcx*8+0x10]
  414f15:	00 
  414f16:	48 01 d0             	add    rax,rdx
	for (i=0; auxv[i]; i+=2) if (auxv[i]<AUX_CNT) aux[auxv[i]] = auxv[i+1];
  414f19:	48 8b 10             	mov    rdx,QWORD PTR [rax]
	libc.auxv = auxv = (void *)(envp+i+1);
  414f1c:	48 89 05 ed d0 18 00 	mov    QWORD PTR [rip+0x18d0ed],rax        # 5a2010 <__libc+0x10>
	for (i=0; auxv[i]; i+=2) if (auxv[i]<AUX_CNT) aux[auxv[i]] = auxv[i+1];
  414f23:	48 83 c0 08          	add    rax,0x8
  414f27:	48 85 d2             	test   rdx,rdx
  414f2a:	0f 84 78 02 00 00    	je     4151a8 <__init_libc+0x2e8>
  414f30:	48 83 fa 25          	cmp    rdx,0x25
  414f34:	0f 87 3e 01 00 00    	ja     415078 <__init_libc+0x1b8>
  414f3a:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  414f3d:	48 83 c0 10          	add    rax,0x10
  414f41:	48 89 4c d4 20       	mov    QWORD PTR [rsp+rdx*8+0x20],rcx
  414f46:	48 8b 50 f8          	mov    rdx,QWORD PTR [rax-0x8]
  414f4a:	48 85 d2             	test   rdx,rdx
  414f4d:	75 e1                	jne    414f30 <__init_libc+0x70>
	__hwcap = aux[AT_HWCAP];
  414f4f:	48 8b 8c 24 a0 00 00 	mov    rcx,QWORD PTR [rsp+0xa0]
  414f56:	00 
	if (aux[AT_SYSINFO]) __sysinfo = aux[AT_SYSINFO];
  414f57:	48 8b 84 24 20 01 00 	mov    rax,QWORD PTR [rsp+0x120]
  414f5e:	00 
	libc.page_size = aux[AT_PAGESZ];
  414f5f:	48 8b 54 24 50       	mov    rdx,QWORD PTR [rsp+0x50]
	__hwcap = aux[AT_HWCAP];
  414f64:	48 89 0d 8d d0 18 00 	mov    QWORD PTR [rip+0x18d08d],rcx        # 5a1ff8 <__hwcap>
	if (aux[AT_SYSINFO]) __sysinfo = aux[AT_SYSINFO];
  414f6b:	48 85 c0             	test   rax,rax
  414f6e:	74 07                	je     414f77 <__init_libc+0xb7>
  414f70:	48 89 05 69 d0 18 00 	mov    QWORD PTR [rip+0x18d069],rax        # 5a1fe0 <__sysinfo>
	libc.page_size = aux[AT_PAGESZ];
  414f77:	48 89 15 ba d0 18 00 	mov    QWORD PTR [rip+0x18d0ba],rdx        # 5a2038 <__libc+0x38>

	if (!pn) pn = (void*)aux[AT_EXECFN];
  414f7e:	48 85 f6             	test   rsi,rsi
  414f81:	0f 84 c9 01 00 00    	je     415150 <__init_libc+0x290>
	if (!pn) pn = "";
	__progname = __progname_full = pn;
  414f87:	48 c7 c0 e8 1f 5a 00 	mov    rax,0x5a1fe8
  414f8e:	48 c7 c1 f0 1f 5a 00 	mov    rcx,0x5a1ff0
  414f95:	48 89 30             	mov    QWORD PTR [rax],rsi
  414f98:	48 89 31             	mov    QWORD PTR [rcx],rsi
	for (i=0; pn[i]; i++) if (pn[i]=='/') __progname = pn+i+1;
  414f9b:	0f b6 16             	movzx  edx,BYTE PTR [rsi]
  414f9e:	84 d2                	test   dl,dl
  414fa0:	74 22                	je     414fc4 <__init_libc+0x104>
  414fa2:	48 8d 46 01          	lea    rax,[rsi+0x1]
  414fa6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  414fad:	00 00 00 
  414fb0:	80 fa 2f             	cmp    dl,0x2f
  414fb3:	0f 84 d7 00 00 00    	je     415090 <__init_libc+0x1d0>
  414fb9:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  414fbc:	48 83 c0 01          	add    rax,0x1
  414fc0:	84 d2                	test   dl,dl
  414fc2:	75 ec                	jne    414fb0 <__init_libc+0xf0>

	__init_tls(aux);
  414fc4:	4c 89 c7             	mov    rdi,r8
  414fc7:	e8 34 0a 00 00       	call   415a00 <__init_tls>
	__init_ssp((void *)aux[AT_RANDOM]);
  414fcc:	48 8b bc 24 e8 00 00 	mov    rdi,QWORD PTR [rsp+0xe8]
  414fd3:	00 
  414fd4:	e8 d7 fe ff ff       	call   414eb0 <__init_ssp>

	if (aux[AT_UID]==aux[AT_EUID] && aux[AT_GID]==aux[AT_EGID]
  414fd9:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  414fe0:	00 
  414fe1:	48 39 44 24 78       	cmp    QWORD PTR [rsp+0x78],rax
  414fe6:	75 16                	jne    414ffe <__init_libc+0x13e>
  414fe8:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  414fef:	00 
  414ff0:	48 39 84 24 88 00 00 	cmp    QWORD PTR [rsp+0x88],rax
  414ff7:	00 
  414ff8:	0f 84 82 01 00 00    	je     415180 <__init_libc+0x2c0>
		&& !aux[AT_SECURE]) return;

	struct pollfd pfd[3] = { {.fd=0}, {.fd=1}, {.fd=2} };
  414ffe:	66 0f ef c0          	pxor   xmm0,xmm0
	int r =
#ifdef SYS_poll
	__syscall(SYS_poll, pfd, 3, 0);
  415002:	48 89 e6             	mov    rsi,rsp
	return __cos_syscall(n, a1, a2, 0, 0, 0, 0, 0);
}

static __inline long __syscall3(long n, long a1, long a2, long a3)
{
	return __cos_syscall(n, a1, a2, a3, 0, 0, 0, 0);
  415005:	45 31 c9             	xor    r9d,r9d
  415008:	45 31 c0             	xor    r8d,r8d
	struct pollfd pfd[3] = { {.fd=0}, {.fd=1}, {.fd=2} };
  41500b:	0f 29 04 24          	movaps XMMWORD PTR [rsp],xmm0
  41500f:	31 c9                	xor    ecx,ecx
  415011:	ba 03 00 00 00       	mov    edx,0x3
  415016:	bf 07 00 00 00       	mov    edi,0x7
  41501b:	48 c7 44 24 10 00 00 	mov    QWORD PTR [rsp+0x10],0x0
  415022:	00 00 
  415024:	c7 44 24 08 01 00 00 	mov    DWORD PTR [rsp+0x8],0x1
  41502b:	00 
  41502c:	c7 44 24 10 02 00 00 	mov    DWORD PTR [rsp+0x10],0x2
  415033:	00 
  415034:	6a 00                	push   0x0
  415036:	6a 00                	push   0x0
  415038:	e8 a3 52 ff ff       	call   40a2e0 <__cos_syscall>
#else
	__syscall(SYS_ppoll, pfd, 3, &(struct timespec){0}, 0, _NSIG/8);
#endif
	if (r<0) a_crash();
  41503d:	41 5a                	pop    r10
  41503f:	41 5b                	pop    r11
  415041:	85 c0                	test   eax,eax
  415043:	79 01                	jns    415046 <__init_libc+0x186>
}

#define a_crash a_crash
static inline void a_crash()
{
	__asm__ __volatile__( "hlt" : : : "memory" );
  415045:	f4                   	hlt    
	for (i=0; i<3; i++) if (pfd[i].revents&POLLNVAL)
  415046:	f6 44 24 06 20       	test   BYTE PTR [rsp+0x6],0x20
  41504b:	0f 85 c7 00 00 00    	jne    415118 <__init_libc+0x258>
  415051:	f6 44 24 0e 20       	test   BYTE PTR [rsp+0xe],0x20
  415056:	0f 85 84 00 00 00    	jne    4150e0 <__init_libc+0x220>
  41505c:	f6 44 24 16 20       	test   BYTE PTR [rsp+0x16],0x20
  415061:	75 4d                	jne    4150b0 <__init_libc+0x1f0>
		if (__sys_open("/dev/null", O_RDWR)<0)
			a_crash();
	libc.secure = 1;
  415063:	c7 05 9b cf 18 00 01 	mov    DWORD PTR [rip+0x18cf9b],0x1        # 5a2008 <__libc+0x8>
  41506a:	00 00 00 
}
  41506d:	48 81 c4 58 01 00 00 	add    rsp,0x158
  415074:	c3                   	ret    
  415075:	0f 1f 00             	nop    DWORD PTR [rax]
	for (i=0; auxv[i]; i+=2) if (auxv[i]<AUX_CNT) aux[auxv[i]] = auxv[i+1];
  415078:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  41507c:	48 83 c0 10          	add    rax,0x10
  415080:	48 85 d2             	test   rdx,rdx
  415083:	0f 85 a7 fe ff ff    	jne    414f30 <__init_libc+0x70>
  415089:	e9 c1 fe ff ff       	jmp    414f4f <__init_libc+0x8f>
  41508e:	66 90                	xchg   ax,ax
	for (i=0; pn[i]; i++) if (pn[i]=='/') __progname = pn+i+1;
  415090:	48 89 01             	mov    QWORD PTR [rcx],rax
  415093:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  415096:	48 83 c0 01          	add    rax,0x1
  41509a:	84 d2                	test   dl,dl
  41509c:	0f 85 0e ff ff ff    	jne    414fb0 <__init_libc+0xf0>
  4150a2:	e9 1d ff ff ff       	jmp    414fc4 <__init_libc+0x104>
  4150a7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  4150ae:	00 00 
	return __cos_syscall(n, a1, a2, 0, 0, 0, 0, 0);
  4150b0:	6a 00                	push   0x0
  4150b2:	31 c9                	xor    ecx,ecx
  4150b4:	ba 02 00 00 00       	mov    edx,0x2
  4150b9:	45 31 c9             	xor    r9d,r9d
  4150bc:	6a 00                	push   0x0
  4150be:	45 31 c0             	xor    r8d,r8d
  4150c1:	bf 02 00 00 00       	mov    edi,0x2
  4150c6:	48 8d 35 d8 8f 00 00 	lea    rsi,[rip+0x8fd8]        # 41e0a5 <CSWTCH.186+0x755>
  4150cd:	e8 0e 52 ff ff       	call   40a2e0 <__cos_syscall>
		if (__sys_open("/dev/null", O_RDWR)<0)
  4150d2:	5a                   	pop    rdx
  4150d3:	59                   	pop    rcx
  4150d4:	48 85 c0             	test   rax,rax
  4150d7:	79 8a                	jns    415063 <__init_libc+0x1a3>
  4150d9:	f4                   	hlt    
}
  4150da:	eb 87                	jmp    415063 <__init_libc+0x1a3>
  4150dc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  4150e0:	6a 00                	push   0x0
  4150e2:	48 8d 35 bc 8f 00 00 	lea    rsi,[rip+0x8fbc]        # 41e0a5 <CSWTCH.186+0x755>
  4150e9:	bf 02 00 00 00       	mov    edi,0x2
  4150ee:	31 c9                	xor    ecx,ecx
  4150f0:	6a 00                	push   0x0
  4150f2:	45 31 c9             	xor    r9d,r9d
  4150f5:	45 31 c0             	xor    r8d,r8d
  4150f8:	ba 02 00 00 00       	mov    edx,0x2
  4150fd:	e8 de 51 ff ff       	call   40a2e0 <__cos_syscall>
  415102:	5e                   	pop    rsi
  415103:	5f                   	pop    rdi
  415104:	48 85 c0             	test   rax,rax
  415107:	0f 89 4f ff ff ff    	jns    41505c <__init_libc+0x19c>
	__asm__ __volatile__( "hlt" : : : "memory" );
  41510d:	f4                   	hlt    
  41510e:	e9 49 ff ff ff       	jmp    41505c <__init_libc+0x19c>
  415113:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  415118:	6a 00                	push   0x0
  41511a:	45 31 c9             	xor    r9d,r9d
  41511d:	45 31 c0             	xor    r8d,r8d
  415120:	31 c9                	xor    ecx,ecx
  415122:	6a 00                	push   0x0
  415124:	ba 02 00 00 00       	mov    edx,0x2
  415129:	bf 02 00 00 00       	mov    edi,0x2
  41512e:	48 8d 35 70 8f 00 00 	lea    rsi,[rip+0x8f70]        # 41e0a5 <CSWTCH.186+0x755>
  415135:	e8 a6 51 ff ff       	call   40a2e0 <__cos_syscall>
  41513a:	41 58                	pop    r8
  41513c:	41 59                	pop    r9
  41513e:	48 85 c0             	test   rax,rax
  415141:	0f 89 0a ff ff ff    	jns    415051 <__init_libc+0x191>
  415147:	f4                   	hlt    
  415148:	e9 04 ff ff ff       	jmp    415051 <__init_libc+0x191>
  41514d:	0f 1f 00             	nop    DWORD PTR [rax]
	if (!pn) pn = (void*)aux[AT_EXECFN];
  415150:	48 8b 84 24 18 01 00 	mov    rax,QWORD PTR [rsp+0x118]
  415157:	00 
	if (!pn) pn = "";
  415158:	48 85 c0             	test   rax,rax
  41515b:	75 5b                	jne    4151b8 <__init_libc+0x2f8>
	__progname = __progname_full = pn;
  41515d:	48 c7 c2 e8 1f 5a 00 	mov    rdx,0x5a1fe8
  415164:	48 8d 05 c2 8f 00 00 	lea    rax,[rip+0x8fc2]        # 41e12d <CSWTCH.186+0x7dd>
  41516b:	48 89 02             	mov    QWORD PTR [rdx],rax
  41516e:	48 c7 c2 f0 1f 5a 00 	mov    rdx,0x5a1ff0
  415175:	48 89 02             	mov    QWORD PTR [rdx],rax
	for (i=0; pn[i]; i++) if (pn[i]=='/') __progname = pn+i+1;
  415178:	e9 47 fe ff ff       	jmp    414fc4 <__init_libc+0x104>
  41517d:	0f 1f 00             	nop    DWORD PTR [rax]
		&& !aux[AT_SECURE]) return;
  415180:	48 83 bc 24 d8 00 00 	cmp    QWORD PTR [rsp+0xd8],0x0
  415187:	00 00 
  415189:	0f 85 6f fe ff ff    	jne    414ffe <__init_libc+0x13e>
  41518f:	e9 d9 fe ff ff       	jmp    41506d <__init_libc+0x1ad>
  415194:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	for (i=0; envp[i]; i++);
  415198:	b8 08 00 00 00       	mov    eax,0x8
  41519d:	e9 74 fd ff ff       	jmp    414f16 <__init_libc+0x56>
  4151a2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	__hwcap = aux[AT_HWCAP];
  4151a8:	48 c7 05 45 ce 18 00 	mov    QWORD PTR [rip+0x18ce45],0x0        # 5a1ff8 <__hwcap>
  4151af:	00 00 00 00 
	if (aux[AT_SYSINFO]) __sysinfo = aux[AT_SYSINFO];
  4151b3:	e9 bf fd ff ff       	jmp    414f77 <__init_libc+0xb7>
	if (!pn) pn = (void*)aux[AT_EXECFN];
  4151b8:	48 89 c6             	mov    rsi,rax
  4151bb:	e9 c7 fd ff ff       	jmp    414f87 <__init_libc+0xc7>

00000000004151c0 <__libc_start_init>:

static void libc_start_init(void)
{
  4151c0:	f3 0f 1e fa          	endbr64 
  4151c4:	55                   	push   rbp
  4151c5:	53                   	push   rbx
  4151c6:	48 83 ec 08          	sub    rsp,0x8
	_init();
  4151ca:	e8 b1 fc ff ff       	call   414e80 <_init>
	uintptr_t a = (uintptr_t)&__init_array_start;
  4151cf:	48 c7 c3 20 20 42 00 	mov    rbx,0x422020
	for (; a<(uintptr_t)&__init_array_end; a+=sizeof(void(*)()))
  4151d6:	48 c7 c5 30 20 42 00 	mov    rbp,0x422030
  4151dd:	48 39 eb             	cmp    rbx,rbp
  4151e0:	73 11                	jae    4151f3 <__libc_start_init+0x33>
  4151e2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
		(*(void (**)(void))a)();
  4151e8:	ff 13                	call   QWORD PTR [rbx]
	for (; a<(uintptr_t)&__init_array_end; a+=sizeof(void(*)()))
  4151ea:	48 83 c3 08          	add    rbx,0x8
  4151ee:	48 39 eb             	cmp    rbx,rbp
  4151f1:	72 f5                	jb     4151e8 <__libc_start_init+0x28>
}
  4151f3:	48 83 c4 08          	add    rsp,0x8
  4151f7:	5b                   	pop    rbx
  4151f8:	5d                   	pop    rbp
  4151f9:	c3                   	ret    
  4151fa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000415200 <libc_start_main_stage2>:
	__asm__ ( "" : "+r"(stage2) : : "memory" );
	return stage2(main, argc, argv);
}

static int libc_start_main_stage2(int (*main)(int,char **,char **), int argc, char **argv)
{
  415200:	f3 0f 1e fa          	endbr64 
  415204:	41 55                	push   r13
  415206:	48 63 c6             	movsxd rax,esi
  415209:	41 54                	push   r12
	char **envp = argv+argc+1;
  41520b:	4c 8d 6c c2 08       	lea    r13,[rdx+rax*8+0x8]
{
  415210:	49 89 d4             	mov    r12,rdx
  415213:	55                   	push   rbp
  415214:	48 89 c5             	mov    rbp,rax
  415217:	53                   	push   rbx
  415218:	48 89 fb             	mov    rbx,rdi
  41521b:	48 83 ec 08          	sub    rsp,0x8
	__libc_start_init();
  41521f:	e8 9c ff ff ff       	call   4151c0 <__libc_start_init>

	/* Pass control to the application */
	exit(main(argc, argv, envp));
  415224:	89 ef                	mov    edi,ebp
  415226:	4c 89 ea             	mov    rdx,r13
  415229:	4c 89 e6             	mov    rsi,r12
  41522c:	ff d3                	call   rbx
  41522e:	89 c7                	mov    edi,eax
  415230:	e8 8b 00 00 00       	call   4152c0 <exit>
  415235:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41523c:	00 00 00 
  41523f:	90                   	nop

0000000000415240 <__libc_start_main>:
{
  415240:	f3 0f 1e fa          	endbr64 
  415244:	41 55                	push   r13
  415246:	48 63 c6             	movsxd rax,esi
  415249:	49 89 fd             	mov    r13,rdi
  41524c:	41 54                	push   r12
	char **envp = argv+argc+1;
  41524e:	48 8d 7c c2 08       	lea    rdi,[rdx+rax*8+0x8]
{
  415253:	49 89 d4             	mov    r12,rdx
  415256:	55                   	push   rbp
	__init_libc(envp, argv[0]);
  415257:	48 8b 32             	mov    rsi,QWORD PTR [rdx]
{
  41525a:	48 89 c5             	mov    rbp,rax
	__init_libc(envp, argv[0]);
  41525d:	e8 5e fc ff ff       	call   414ec0 <__init_libc>
	return stage2(main, argc, argv);
  415262:	4c 89 e2             	mov    rdx,r12
  415265:	89 ee                	mov    esi,ebp
  415267:	4c 89 ef             	mov    rdi,r13
	__asm__ ( "" : "+r"(stage2) : : "memory" );
  41526a:	48 8d 05 8f ff ff ff 	lea    rax,[rip+0xffffffffffffff8f]        # 415200 <libc_start_main_stage2>
}
  415271:	5d                   	pop    rbp
  415272:	41 5c                	pop    r12
  415274:	41 5d                	pop    r13
	return stage2(main, argc, argv);
  415276:	ff e0                	jmp    rax
  415278:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41527f:	00 

0000000000415280 <__libc_exit_fini>:
weak_alias(dummy, _fini);

extern weak hidden void (*const __fini_array_start)(void), (*const __fini_array_end)(void);

static void libc_exit_fini(void)
{
  415280:	f3 0f 1e fa          	endbr64 
  415284:	55                   	push   rbp
  415285:	53                   	push   rbx
  415286:	48 83 ec 08          	sub    rsp,0x8
	uintptr_t a = (uintptr_t)&__fini_array_end;
  41528a:	48 c7 c3 40 20 42 00 	mov    rbx,0x422040
	for (; a>(uintptr_t)&__fini_array_start; a-=sizeof(void(*)()))
  415291:	48 c7 c5 30 20 42 00 	mov    rbp,0x422030
  415298:	48 39 eb             	cmp    rbx,rbp
  41529b:	76 10                	jbe    4152ad <__libc_exit_fini+0x2d>
  41529d:	0f 1f 00             	nop    DWORD PTR [rax]
		(*(void (**)())(a-sizeof(void(*)())))();
  4152a0:	48 83 eb 08          	sub    rbx,0x8
  4152a4:	31 c0                	xor    eax,eax
  4152a6:	ff 13                	call   QWORD PTR [rbx]
	for (; a>(uintptr_t)&__fini_array_start; a-=sizeof(void(*)()))
  4152a8:	48 39 eb             	cmp    rbx,rbp
  4152ab:	77 f3                	ja     4152a0 <__libc_exit_fini+0x20>
	_fini();
}
  4152ad:	48 83 c4 08          	add    rsp,0x8
	_fini();
  4152b1:	31 c0                	xor    eax,eax
}
  4152b3:	5b                   	pop    rbx
  4152b4:	5d                   	pop    rbp
	_fini();
  4152b5:	e9 d6 fb ff ff       	jmp    414e90 <__funcs_on_exit>
  4152ba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000004152c0 <exit>:

weak_alias(libc_exit_fini, __libc_exit_fini);

_Noreturn void exit(int code)
{
  4152c0:	f3 0f 1e fa          	endbr64 
  4152c4:	55                   	push   rbp
  4152c5:	89 fd                	mov    ebp,edi
	__funcs_on_exit();
  4152c7:	e8 c4 fb ff ff       	call   414e90 <__funcs_on_exit>
	__libc_exit_fini();
  4152cc:	e8 af ff ff ff       	call   415280 <__libc_exit_fini>
	__stdio_exit();
  4152d1:	31 c0                	xor    eax,eax
  4152d3:	e8 18 59 00 00       	call   41abf0 <__stdio_exit>
	_Exit(code);
  4152d8:	89 ef                	mov    edi,ebp
  4152da:	e8 a1 0a 00 00       	call   415d80 <_Exit>
  4152df:	90                   	nop

00000000004152e0 <sn_write>:
};

#define MIN(a, b) ((a) < (b) ? (a) : (b))

static size_t sn_write(FILE *f, const unsigned char *s, size_t l)
{
  4152e0:	f3 0f 1e fa          	endbr64 
  4152e4:	41 56                	push   r14
  4152e6:	49 89 f6             	mov    r14,rsi
  4152e9:	41 55                	push   r13
  4152eb:	41 54                	push   r12
  4152ed:	49 89 d4             	mov    r12,rdx
  4152f0:	55                   	push   rbp
  4152f1:	48 89 fd             	mov    rbp,rdi
  4152f4:	53                   	push   rbx
	struct cookie *c = f->cookie;
  4152f5:	4c 8b af 98 00 00 00 	mov    r13,QWORD PTR [rdi+0x98]
	size_t k = MIN(c->n, f->wpos - f->wbase);
  4152fc:	48 8b 77 38          	mov    rsi,QWORD PTR [rdi+0x38]
  415300:	48 8b 4f 28          	mov    rcx,QWORD PTR [rdi+0x28]
  415304:	49 8b 45 08          	mov    rax,QWORD PTR [r13+0x8]
	if (k) {
		memcpy(c->s, f->wbase, k);
  415308:	49 8b 7d 00          	mov    rdi,QWORD PTR [r13+0x0]
	size_t k = MIN(c->n, f->wpos - f->wbase);
  41530c:	48 29 f1             	sub    rcx,rsi
  41530f:	48 39 c1             	cmp    rcx,rax
  415312:	48 89 cb             	mov    rbx,rcx
  415315:	48 0f 47 d8          	cmova  rbx,rax
	if (k) {
  415319:	48 85 db             	test   rbx,rbx
  41531c:	75 32                	jne    415350 <sn_write+0x70>
		c->s += k;
		c->n -= k;
	}
	k = MIN(c->n, l);
  41531e:	49 39 c4             	cmp    r12,rax
  415321:	49 0f 46 c4          	cmovbe rax,r12
  415325:	48 89 c3             	mov    rbx,rax
	if (k) {
  415328:	48 85 c0             	test   rax,rax
  41532b:	75 50                	jne    41537d <sn_write+0x9d>
		memcpy(c->s, s, k);
		c->s += k;
		c->n -= k;
	}
	*c->s = 0;
  41532d:	c6 07 00             	mov    BYTE PTR [rdi],0x0
	f->wpos = f->wbase = f->buf;
  415330:	48 8b 45 58          	mov    rax,QWORD PTR [rbp+0x58]
	/* pretend to succeed, even if we discarded extra data */
	return l;
}
  415334:	5b                   	pop    rbx
	f->wpos = f->wbase = f->buf;
  415335:	48 89 45 38          	mov    QWORD PTR [rbp+0x38],rax
  415339:	48 89 45 28          	mov    QWORD PTR [rbp+0x28],rax
}
  41533d:	5d                   	pop    rbp
  41533e:	4c 89 e0             	mov    rax,r12
  415341:	41 5c                	pop    r12
  415343:	41 5d                	pop    r13
  415345:	41 5e                	pop    r14
  415347:	c3                   	ret    
  415348:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41534f:	00 
		memcpy(c->s, f->wbase, k);
  415350:	48 89 da             	mov    rdx,rbx
  415353:	e8 02 fa ff ff       	call   414d5a <memcpy>
		c->n -= k;
  415358:	49 8b 45 08          	mov    rax,QWORD PTR [r13+0x8]
		c->s += k;
  41535c:	49 8b 7d 00          	mov    rdi,QWORD PTR [r13+0x0]
		c->n -= k;
  415360:	48 29 d8             	sub    rax,rbx
		c->s += k;
  415363:	48 01 df             	add    rdi,rbx
	k = MIN(c->n, l);
  415366:	49 39 c4             	cmp    r12,rax
		c->n -= k;
  415369:	49 89 45 08          	mov    QWORD PTR [r13+0x8],rax
	k = MIN(c->n, l);
  41536d:	49 0f 46 c4          	cmovbe rax,r12
		c->s += k;
  415371:	49 89 7d 00          	mov    QWORD PTR [r13+0x0],rdi
	k = MIN(c->n, l);
  415375:	48 89 c3             	mov    rbx,rax
	if (k) {
  415378:	48 85 c0             	test   rax,rax
  41537b:	74 b0                	je     41532d <sn_write+0x4d>
		memcpy(c->s, s, k);
  41537d:	48 89 c2             	mov    rdx,rax
  415380:	4c 89 f6             	mov    rsi,r14
  415383:	e8 d2 f9 ff ff       	call   414d5a <memcpy>
		c->s += k;
  415388:	49 8b 7d 00          	mov    rdi,QWORD PTR [r13+0x0]
		c->n -= k;
  41538c:	49 29 5d 08          	sub    QWORD PTR [r13+0x8],rbx
		c->s += k;
  415390:	48 01 df             	add    rdi,rbx
  415393:	49 89 7d 00          	mov    QWORD PTR [r13+0x0],rdi
		c->n -= k;
  415397:	eb 94                	jmp    41532d <sn_write+0x4d>
  415399:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

00000000004153a0 <vsnprintf>:

int vsnprintf(char *restrict s, size_t n, const char *restrict fmt, va_list ap)
{
  4153a0:	f3 0f 1e fa          	endbr64 
  4153a4:	49 89 f2             	mov    r10,rsi
  4153a7:	48 81 ec 18 01 00 00 	sub    rsp,0x118
  4153ae:	48 89 d6             	mov    rsi,rdx
  4153b1:	48 89 ca             	mov    rdx,rcx
	unsigned char buf[1];
	char dummy[1];
	struct cookie c = { .s = n ? s : dummy, .n = n ? n-1 : 0 };
  4153b4:	4d 85 d2             	test   r10,r10
  4153b7:	75 77                	jne    415430 <vsnprintf+0x90>
	FILE f = {
  4153b9:	4c 8d 4c 24 20       	lea    r9,[rsp+0x20]
  4153be:	4c 89 d0             	mov    rax,r10
  4153c1:	b9 1d 00 00 00       	mov    ecx,0x1d
	struct cookie c = { .s = n ? s : dummy, .n = n ? n-1 : 0 };
  4153c6:	48 c7 44 24 18 00 00 	mov    QWORD PTR [rsp+0x18],0x0
  4153cd:	00 00 
	FILE f = {
  4153cf:	4c 89 cf             	mov    rdi,r9
	struct cookie c = { .s = n ? s : dummy, .n = n ? n-1 : 0 };
  4153d2:	4c 8d 44 24 0f       	lea    r8,[rsp+0xf]
	FILE f = {
  4153d7:	f3 48 ab             	rep stos QWORD PTR es:[rdi],rax
  4153da:	48 8d 05 ff fe ff ff 	lea    rax,[rip+0xfffffffffffffeff]        # 4152e0 <sn_write>
	struct cookie c = { .s = n ? s : dummy, .n = n ? n-1 : 0 };
  4153e1:	4c 89 44 24 10       	mov    QWORD PTR [rsp+0x10],r8
	FILE f = {
  4153e6:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  4153eb:	48 8d 44 24 0e       	lea    rax,[rsp+0xe]
  4153f0:	48 89 44 24 78       	mov    QWORD PTR [rsp+0x78],rax
  4153f5:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  4153fa:	c7 84 24 ac 00 00 00 	mov    DWORD PTR [rsp+0xac],0xffffffff
  415401:	ff ff ff ff 
  415405:	c7 84 24 b0 00 00 00 	mov    DWORD PTR [rsp+0xb0],0xffffffff
  41540c:	ff ff ff ff 
  415410:	48 89 84 24 b8 00 00 	mov    QWORD PTR [rsp+0xb8],rax
  415417:	00 
	if (n > INT_MAX) {
		errno = EOVERFLOW;
		return -1;
	}

	*c.s = 0;
  415418:	41 c6 00 00          	mov    BYTE PTR [r8],0x0
	return vfprintf(&f, fmt, ap);
  41541c:	4c 89 cf             	mov    rdi,r9
  41541f:	e8 bc 4c 00 00       	call   41a0e0 <vfprintf>
}
  415424:	48 81 c4 18 01 00 00 	add    rsp,0x118
  41542b:	c3                   	ret    
  41542c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	struct cookie c = { .s = n ? s : dummy, .n = n ? n-1 : 0 };
  415430:	49 8d 42 ff          	lea    rax,[r10-0x1]
	FILE f = {
  415434:	4c 8d 4c 24 20       	lea    r9,[rsp+0x20]
	struct cookie c = { .s = n ? s : dummy, .n = n ? n-1 : 0 };
  415439:	48 89 7c 24 10       	mov    QWORD PTR [rsp+0x10],rdi
  41543e:	49 89 f8             	mov    r8,rdi
  415441:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
	FILE f = {
  415446:	b9 1d 00 00 00       	mov    ecx,0x1d
  41544b:	31 c0                	xor    eax,eax
  41544d:	4c 89 cf             	mov    rdi,r9
  415450:	f3 48 ab             	rep stos QWORD PTR es:[rdi],rax
  415453:	48 8d 05 86 fe ff ff 	lea    rax,[rip+0xfffffffffffffe86]        # 4152e0 <sn_write>
  41545a:	c7 84 24 ac 00 00 00 	mov    DWORD PTR [rsp+0xac],0xffffffff
  415461:	ff ff ff ff 
  415465:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  41546a:	48 8d 44 24 0e       	lea    rax,[rsp+0xe]
  41546f:	48 89 44 24 78       	mov    QWORD PTR [rsp+0x78],rax
  415474:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  415479:	c7 84 24 b0 00 00 00 	mov    DWORD PTR [rsp+0xb0],0xffffffff
  415480:	ff ff ff ff 
  415484:	48 89 84 24 b8 00 00 	mov    QWORD PTR [rsp+0xb8],rax
  41548b:	00 
	if (n > INT_MAX) {
  41548c:	49 81 fa ff ff ff 7f 	cmp    r10,0x7fffffff
  415493:	76 83                	jbe    415418 <vsnprintf+0x78>
		errno = EOVERFLOW;
  415495:	e8 d6 08 00 00       	call   415d70 <__errno_location>
  41549a:	c7 00 4b 00 00 00    	mov    DWORD PTR [rax],0x4b
		return -1;
  4154a0:	b8 ff ff ff ff       	mov    eax,0xffffffff
  4154a5:	e9 7a ff ff ff       	jmp    415424 <vsnprintf+0x84>
  4154aa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000004154b0 <atoi>:
#include <stdlib.h>
#include <ctype.h>

int atoi(const char *s)
{
  4154b0:	f3 0f 1e fa          	endbr64 
	int n=0, neg=0;
	while (isspace(*s)) s++;
  4154b4:	eb 0e                	jmp    4154c4 <atoi+0x14>
  4154b6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4154bd:	00 00 00 
  4154c0:	48 83 c7 01          	add    rdi,0x1
  4154c4:	0f be 07             	movsx  eax,BYTE PTR [rdi]
int   toupper(int);

#ifndef __cplusplus
static __inline int __isspace(int _c)
{
	return _c == ' ' || (unsigned)_c-'\t' < 5;
  4154c7:	8d 48 f7             	lea    ecx,[rax-0x9]
  4154ca:	89 c2                	mov    edx,eax
  4154cc:	83 f9 04             	cmp    ecx,0x4
  4154cf:	76 ef                	jbe    4154c0 <atoi+0x10>
  4154d1:	80 fa 20             	cmp    dl,0x20
  4154d4:	74 ea                	je     4154c0 <atoi+0x10>
	switch (*s) {
  4154d6:	80 fa 2b             	cmp    dl,0x2b
  4154d9:	74 4d                	je     415528 <atoi+0x78>
  4154db:	80 fa 2d             	cmp    dl,0x2d
  4154de:	74 68                	je     415548 <atoi+0x98>
	case '-': neg=1;
	case '+': s++;
	}
	/* Compute n as a negative number to avoid overflow on INT_MIN */
	while (isdigit(*s))
  4154e0:	8d 50 d0             	lea    edx,[rax-0x30]
  4154e3:	48 89 f9             	mov    rcx,rdi
	int n=0, neg=0;
  4154e6:	45 31 c9             	xor    r9d,r9d
	while (isdigit(*s))
  4154e9:	83 fa 09             	cmp    edx,0x9
  4154ec:	77 4d                	ja     41553b <atoi+0x8b>
	int n=0, neg=0;
  4154ee:	45 31 c0             	xor    r8d,r8d
  4154f1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		n = 10*n - (*s++ - '0');
  4154f8:	48 83 c1 01          	add    rcx,0x1
  4154fc:	43 8d 14 80          	lea    edx,[r8+r8*4]
  415500:	8d 70 d0             	lea    esi,[rax-0x30]
	while (isdigit(*s))
  415503:	0f be 01             	movsx  eax,BYTE PTR [rcx]
		n = 10*n - (*s++ - '0');
  415506:	01 d2                	add    edx,edx
  415508:	41 89 d0             	mov    r8d,edx
	while (isdigit(*s))
  41550b:	8d 78 d0             	lea    edi,[rax-0x30]
		n = 10*n - (*s++ - '0');
  41550e:	41 29 f0             	sub    r8d,esi
	while (isdigit(*s))
  415511:	83 ff 09             	cmp    edi,0x9
  415514:	76 e2                	jbe    4154f8 <atoi+0x48>
	return neg ? n : -n;
  415516:	29 d6                	sub    esi,edx
  415518:	45 85 c9             	test   r9d,r9d
  41551b:	44 0f 44 c6          	cmove  r8d,esi
}
  41551f:	44 89 c0             	mov    eax,r8d
  415522:	c3                   	ret    
  415523:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	while (isdigit(*s))
  415528:	0f be 47 01          	movsx  eax,BYTE PTR [rdi+0x1]
	case '+': s++;
  41552c:	48 8d 4f 01          	lea    rcx,[rdi+0x1]
	int n=0, neg=0;
  415530:	45 31 c9             	xor    r9d,r9d
	while (isdigit(*s))
  415533:	8d 50 d0             	lea    edx,[rax-0x30]
  415536:	83 fa 09             	cmp    edx,0x9
  415539:	76 b3                	jbe    4154ee <atoi+0x3e>
  41553b:	45 31 c0             	xor    r8d,r8d
}
  41553e:	44 89 c0             	mov    eax,r8d
  415541:	c3                   	ret    
  415542:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	while (isdigit(*s))
  415548:	0f be 47 01          	movsx  eax,BYTE PTR [rdi+0x1]
	case '+': s++;
  41554c:	48 8d 4f 01          	lea    rcx,[rdi+0x1]
	while (isdigit(*s))
  415550:	8d 50 d0             	lea    edx,[rax-0x30]
  415553:	83 fa 09             	cmp    edx,0x9
  415556:	77 e3                	ja     41553b <atoi+0x8b>
	case '-': neg=1;
  415558:	41 b9 01 00 00 00    	mov    r9d,0x1
  41555e:	eb 8e                	jmp    4154ee <atoi+0x3e>

0000000000415560 <atol>:
#include <stdlib.h>
#include <ctype.h>

long atol(const char *s)
{
  415560:	f3 0f 1e fa          	endbr64 
	long n=0;
	int neg=0;
	while (isspace(*s)) s++;
  415564:	eb 0e                	jmp    415574 <atol+0x14>
  415566:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41556d:	00 00 00 
  415570:	48 83 c7 01          	add    rdi,0x1
  415574:	0f be 07             	movsx  eax,BYTE PTR [rdi]
  415577:	8d 48 f7             	lea    ecx,[rax-0x9]
  41557a:	89 c2                	mov    edx,eax
  41557c:	83 f9 04             	cmp    ecx,0x4
  41557f:	76 ef                	jbe    415570 <atol+0x10>
  415581:	80 fa 20             	cmp    dl,0x20
  415584:	74 ea                	je     415570 <atol+0x10>
	switch (*s) {
  415586:	80 fa 2b             	cmp    dl,0x2b
  415589:	74 55                	je     4155e0 <atol+0x80>
  41558b:	80 fa 2d             	cmp    dl,0x2d
  41558e:	74 70                	je     415600 <atol+0xa0>
	case '-': neg=1;
	case '+': s++;
	}
	/* Compute n as a negative number to avoid overflow on LONG_MIN */
	while (isdigit(*s))
  415590:	8d 50 d0             	lea    edx,[rax-0x30]
  415593:	48 89 f9             	mov    rcx,rdi
	int neg=0;
  415596:	45 31 c9             	xor    r9d,r9d
	while (isdigit(*s))
  415599:	83 fa 09             	cmp    edx,0x9
  41559c:	77 55                	ja     4155f3 <atol+0x93>
	int neg=0;
  41559e:	45 31 c0             	xor    r8d,r8d
  4155a1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		n = 10*n - (*s++ - '0');
  4155a8:	83 e8 30             	sub    eax,0x30
  4155ab:	48 83 c1 01          	add    rcx,0x1
  4155af:	4b 8d 14 80          	lea    rdx,[r8+r8*4]
  4155b3:	48 63 f0             	movsxd rsi,eax
	while (isdigit(*s))
  4155b6:	0f be 01             	movsx  eax,BYTE PTR [rcx]
		n = 10*n - (*s++ - '0');
  4155b9:	48 01 d2             	add    rdx,rdx
  4155bc:	49 89 d0             	mov    r8,rdx
	while (isdigit(*s))
  4155bf:	8d 78 d0             	lea    edi,[rax-0x30]
		n = 10*n - (*s++ - '0');
  4155c2:	49 29 f0             	sub    r8,rsi
	while (isdigit(*s))
  4155c5:	83 ff 09             	cmp    edi,0x9
  4155c8:	76 de                	jbe    4155a8 <atol+0x48>
	return neg ? n : -n;
  4155ca:	48 29 d6             	sub    rsi,rdx
  4155cd:	45 85 c9             	test   r9d,r9d
  4155d0:	4c 0f 44 c6          	cmove  r8,rsi
}
  4155d4:	4c 89 c0             	mov    rax,r8
  4155d7:	c3                   	ret    
  4155d8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4155df:	00 
	while (isdigit(*s))
  4155e0:	0f be 47 01          	movsx  eax,BYTE PTR [rdi+0x1]
	case '+': s++;
  4155e4:	48 8d 4f 01          	lea    rcx,[rdi+0x1]
	int neg=0;
  4155e8:	45 31 c9             	xor    r9d,r9d
	while (isdigit(*s))
  4155eb:	8d 50 d0             	lea    edx,[rax-0x30]
  4155ee:	83 fa 09             	cmp    edx,0x9
  4155f1:	76 ab                	jbe    41559e <atol+0x3e>
  4155f3:	45 31 c0             	xor    r8d,r8d
}
  4155f6:	4c 89 c0             	mov    rax,r8
  4155f9:	c3                   	ret    
  4155fa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	while (isdigit(*s))
  415600:	0f be 47 01          	movsx  eax,BYTE PTR [rdi+0x1]
	case '+': s++;
  415604:	48 8d 4f 01          	lea    rcx,[rdi+0x1]
	while (isdigit(*s))
  415608:	8d 50 d0             	lea    edx,[rax-0x30]
  41560b:	83 fa 09             	cmp    edx,0x9
  41560e:	77 e3                	ja     4155f3 <atol+0x93>
	case '-': neg=1;
  415610:	41 b9 01 00 00 00    	mov    r9d,0x1
  415616:	eb 86                	jmp    41559e <atol+0x3e>
  415618:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41561f:	00 

0000000000415620 <strchr>:
#include <string.h>

char *strchr(const char *s, int c)
{
  415620:	f3 0f 1e fa          	endbr64 
  415624:	53                   	push   rbx
  415625:	89 f3                	mov    ebx,esi
	char *r = __strchrnul(s, c);
  415627:	e8 14 00 00 00       	call   415640 <__strchrnul>
	return *(unsigned char *)r == (unsigned char)c ? r : 0;
  41562c:	31 d2                	xor    edx,edx
  41562e:	38 18                	cmp    BYTE PTR [rax],bl
}
  415630:	5b                   	pop    rbx
	return *(unsigned char *)r == (unsigned char)c ? r : 0;
  415631:	48 0f 45 c2          	cmovne rax,rdx
}
  415635:	c3                   	ret    
  415636:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41563d:	00 00 00 

0000000000415640 <__strchrnul>:
#define ONES ((size_t)-1/UCHAR_MAX)
#define HIGHS (ONES * (UCHAR_MAX/2+1))
#define HASZERO(x) ((x)-ONES & ~(x) & HIGHS)

char *__strchrnul(const char *s, int c)
{
  415640:	f3 0f 1e fa          	endbr64 
	c = (unsigned char)c;
	if (!c) return (char *)s + strlen(s);
  415644:	89 f1                	mov    ecx,esi
{
  415646:	41 54                	push   r12
  415648:	49 89 fc             	mov    r12,rdi
	if (!c) return (char *)s + strlen(s);
  41564b:	81 e1 ff 00 00 00    	and    ecx,0xff
  415651:	75 26                	jne    415679 <__strchrnul+0x39>
  415653:	e9 c8 00 00 00       	jmp    415720 <__strchrnul+0xe0>
  415658:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41565f:	00 

#ifdef __GNUC__
	typedef size_t __attribute__((__may_alias__)) word;
	const word *w;
	for (; (uintptr_t)s % ALIGN; s++)
		if (!*s || *(unsigned char *)s == c) return (char *)s;
  415660:	41 0f b6 04 24       	movzx  eax,BYTE PTR [r12]
  415665:	84 c0                	test   al,al
  415667:	0f 84 ac 00 00 00    	je     415719 <__strchrnul+0xd9>
  41566d:	39 c8                	cmp    eax,ecx
  41566f:	0f 84 a4 00 00 00    	je     415719 <__strchrnul+0xd9>
	for (; (uintptr_t)s % ALIGN; s++)
  415675:	49 83 c4 01          	add    r12,0x1
  415679:	41 f6 c4 07          	test   r12b,0x7
  41567d:	75 e1                	jne    415660 <__strchrnul+0x20>
	size_t k = ONES * c;
  41567f:	48 bf 01 01 01 01 01 	movabs rdi,0x101010101010101
  415686:	01 01 01 
  415689:	4c 63 c1             	movsxd r8,ecx
	for (w = (void *)s; !HASZERO(*w) && !HASZERO(*w^k); w++);
  41568c:	49 8b 14 24          	mov    rdx,QWORD PTR [r12]
  415690:	49 b9 80 80 80 80 80 	movabs r9,0x8080808080808080
  415697:	80 80 80 
	size_t k = ONES * c;
  41569a:	4c 0f af c7          	imul   r8,rdi
	for (w = (void *)s; !HASZERO(*w) && !HASZERO(*w^k); w++);
  41569e:	48 89 d0             	mov    rax,rdx
  4156a1:	48 f7 d0             	not    rax
  4156a4:	4c 89 c6             	mov    rsi,r8
  4156a7:	48 31 d6             	xor    rsi,rdx
  4156aa:	48 29 fa             	sub    rdx,rdi
  4156ad:	48 21 d0             	and    rax,rdx
  4156b0:	48 89 f2             	mov    rdx,rsi
  4156b3:	48 f7 d6             	not    rsi
  4156b6:	48 29 fa             	sub    rdx,rdi
  4156b9:	48 21 f2             	and    rdx,rsi
  4156bc:	48 09 d0             	or     rax,rdx
  4156bf:	4c 85 c8             	test   rax,r9
  4156c2:	75 4c                	jne    415710 <__strchrnul+0xd0>
  4156c4:	48 bf ff fe fe fe fe 	movabs rdi,0xfefefefefefefeff
  4156cb:	fe fe fe 
  4156ce:	66 90                	xchg   ax,ax
  4156d0:	49 8b 54 24 08       	mov    rdx,QWORD PTR [r12+0x8]
  4156d5:	49 83 c4 08          	add    r12,0x8
  4156d9:	48 89 d6             	mov    rsi,rdx
  4156dc:	48 8d 04 3a          	lea    rax,[rdx+rdi*1]
  4156e0:	48 f7 d2             	not    rdx
  4156e3:	4c 31 c6             	xor    rsi,r8
  4156e6:	48 21 d0             	and    rax,rdx
  4156e9:	48 8d 14 3e          	lea    rdx,[rsi+rdi*1]
  4156ed:	48 f7 d6             	not    rsi
  4156f0:	48 21 f2             	and    rdx,rsi
  4156f3:	48 09 d0             	or     rax,rdx
  4156f6:	4c 85 c8             	test   rax,r9
  4156f9:	74 d5                	je     4156d0 <__strchrnul+0x90>
	s = (void *)w;
#endif
	for (; *s && *(unsigned char *)s != c; s++);
  4156fb:	41 0f b6 04 24       	movzx  eax,BYTE PTR [r12]
  415700:	84 c0                	test   al,al
  415702:	74 15                	je     415719 <__strchrnul+0xd9>
  415704:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  415708:	39 c8                	cmp    eax,ecx
  41570a:	74 0d                	je     415719 <__strchrnul+0xd9>
  41570c:	49 83 c4 01          	add    r12,0x1
  415710:	41 0f b6 04 24       	movzx  eax,BYTE PTR [r12]
  415715:	84 c0                	test   al,al
  415717:	75 ef                	jne    415708 <__strchrnul+0xc8>
	return (char *)s;
}
  415719:	4c 89 e0             	mov    rax,r12
  41571c:	41 5c                	pop    r12
  41571e:	c3                   	ret    
  41571f:	90                   	nop
	if (!c) return (char *)s + strlen(s);
  415720:	e8 4b 00 00 00       	call   415770 <strlen>
  415725:	49 01 c4             	add    r12,rax
}
  415728:	4c 89 e0             	mov    rax,r12
  41572b:	41 5c                	pop    r12
  41572d:	c3                   	ret    
  41572e:	66 90                	xchg   ax,ax

0000000000415730 <strcmp>:
#include <string.h>

int strcmp(const char *l, const char *r)
{
  415730:	f3 0f 1e fa          	endbr64 
	for (; *l==*r && *l; l++, r++);
  415734:	0f b6 17             	movzx  edx,BYTE PTR [rdi]
  415737:	0f b6 0e             	movzx  ecx,BYTE PTR [rsi]
  41573a:	b8 01 00 00 00       	mov    eax,0x1
  41573f:	38 d1                	cmp    cl,dl
  415741:	74 16                	je     415759 <strcmp+0x29>
  415743:	eb 23                	jmp    415768 <strcmp+0x38>
  415745:	0f 1f 00             	nop    DWORD PTR [rax]
  415748:	0f b6 14 07          	movzx  edx,BYTE PTR [rdi+rax*1]
  41574c:	48 83 c0 01          	add    rax,0x1
  415750:	0f b6 4c 06 ff       	movzx  ecx,BYTE PTR [rsi+rax*1-0x1]
  415755:	38 ca                	cmp    dl,cl
  415757:	75 0f                	jne    415768 <strcmp+0x38>
  415759:	84 d2                	test   dl,dl
  41575b:	75 eb                	jne    415748 <strcmp+0x18>
  41575d:	31 c0                	xor    eax,eax
	return *(unsigned char *)l - *(unsigned char *)r;
  41575f:	29 c8                	sub    eax,ecx
}
  415761:	c3                   	ret    
  415762:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	return *(unsigned char *)l - *(unsigned char *)r;
  415768:	0f b6 c2             	movzx  eax,dl
  41576b:	29 c8                	sub    eax,ecx
}
  41576d:	c3                   	ret    
  41576e:	66 90                	xchg   ax,ax

0000000000415770 <strlen>:
#define ONES ((size_t)-1/UCHAR_MAX)
#define HIGHS (ONES * (UCHAR_MAX/2+1))
#define HASZERO(x) ((x)-ONES & ~(x) & HIGHS)

size_t strlen(const char *s)
{
  415770:	f3 0f 1e fa          	endbr64 
	const char *a = s;
#ifdef __GNUC__
	typedef size_t __attribute__((__may_alias__)) word;
	const word *w;
	for (; (uintptr_t)s % ALIGN; s++) if (!*s) return s-a;
  415774:	48 89 f8             	mov    rax,rdi
  415777:	40 f6 c7 07          	test   dil,0x7
  41577b:	75 0b                	jne    415788 <strlen+0x18>
  41577d:	eb 19                	jmp    415798 <strlen+0x28>
  41577f:	90                   	nop
  415780:	48 83 c0 01          	add    rax,0x1
  415784:	a8 07                	test   al,0x7
  415786:	74 10                	je     415798 <strlen+0x28>
  415788:	80 38 00             	cmp    BYTE PTR [rax],0x0
  41578b:	75 f3                	jne    415780 <strlen+0x10>
	for (w = (const void *)s; !HASZERO(*w); w++);
	s = (const void *)w;
#endif
	for (; *s; s++);
	return s-a;
  41578d:	48 29 f8             	sub    rax,rdi
}
  415790:	c3                   	ret    
  415791:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (w = (const void *)s; !HASZERO(*w); w++);
  415798:	49 b8 ff fe fe fe fe 	movabs r8,0xfefefefefefefeff
  41579f:	fe fe fe 
  4157a2:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  4157a5:	48 be 80 80 80 80 80 	movabs rsi,0x8080808080808080
  4157ac:	80 80 80 
  4157af:	4a 8d 0c 02          	lea    rcx,[rdx+r8*1]
  4157b3:	48 f7 d2             	not    rdx
  4157b6:	48 21 ca             	and    rdx,rcx
  4157b9:	48 85 f2             	test   rdx,rsi
  4157bc:	75 26                	jne    4157e4 <strlen+0x74>
  4157be:	66 90                	xchg   ax,ax
  4157c0:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  4157c4:	48 83 c0 08          	add    rax,0x8
  4157c8:	4a 8d 0c 02          	lea    rcx,[rdx+r8*1]
  4157cc:	48 f7 d2             	not    rdx
  4157cf:	48 21 ca             	and    rdx,rcx
  4157d2:	48 85 f2             	test   rdx,rsi
  4157d5:	74 e9                	je     4157c0 <strlen+0x50>
  4157d7:	eb 0b                	jmp    4157e4 <strlen+0x74>
  4157d9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (; *s; s++);
  4157e0:	48 83 c0 01          	add    rax,0x1
  4157e4:	80 38 00             	cmp    BYTE PTR [rax],0x0
  4157e7:	75 f7                	jne    4157e0 <strlen+0x70>
	return s-a;
  4157e9:	48 29 f8             	sub    rax,rdi
}
  4157ec:	c3                   	ret    
  4157ed:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004157f0 <strncmp>:
#include <string.h>

int strncmp(const char *_l, const char *_r, size_t n)
{
  4157f0:	f3 0f 1e fa          	endbr64 
  4157f4:	49 89 f9             	mov    r9,rdi
  4157f7:	49 89 f2             	mov    r10,rsi
	const unsigned char *l=(void *)_l, *r=(void *)_r;
	if (!n--) return 0;
  4157fa:	31 c0                	xor    eax,eax
  4157fc:	48 85 d2             	test   rdx,rdx
  4157ff:	74 60                	je     415861 <strncmp+0x71>
	for (; *l && *r && n && *l == *r ; l++, r++, n--);
  415801:	0f b6 07             	movzx  eax,BYTE PTR [rdi]
  415804:	0f b6 3e             	movzx  edi,BYTE PTR [rsi]
  415807:	84 c0                	test   al,al
  415809:	74 5d                	je     415868 <strncmp+0x78>
  41580b:	48 83 ea 01          	sub    rdx,0x1
  41580f:	40 0f 95 c6          	setne  sil
  415813:	40 84 ff             	test   dil,dil
  415816:	0f 95 c1             	setne  cl
  415819:	40 84 ce             	test   sil,cl
  41581c:	74 41                	je     41585f <strncmp+0x6f>
  41581e:	b9 01 00 00 00       	mov    ecx,0x1
  415823:	40 38 f8             	cmp    al,dil
  415826:	75 37                	jne    41585f <strncmp+0x6f>
  415828:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41582f:	00 
  415830:	41 0f b6 04 09       	movzx  eax,BYTE PTR [r9+rcx*1]
  415835:	41 0f b6 3c 0a       	movzx  edi,BYTE PTR [r10+rcx*1]
  41583a:	84 c0                	test   al,al
  41583c:	74 2a                	je     415868 <strncmp+0x78>
  41583e:	40 84 ff             	test   dil,dil
  415841:	40 0f 95 c6          	setne  sil
  415845:	40 38 f8             	cmp    al,dil
  415848:	41 0f 94 c0          	sete   r8b
  41584c:	44 21 c6             	and    esi,r8d
  41584f:	48 39 ca             	cmp    rdx,rcx
  415852:	41 0f 95 c0          	setne  r8b
  415856:	48 83 c1 01          	add    rcx,0x1
  41585a:	44 84 c6             	test   sil,r8b
  41585d:	75 d1                	jne    415830 <strncmp+0x40>
	return *l - *r;
  41585f:	29 f8                	sub    eax,edi
}
  415861:	c3                   	ret    
  415862:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  415868:	31 c0                	xor    eax,eax
	return *l - *r;
  41586a:	29 f8                	sub    eax,edi
  41586c:	eb f3                	jmp    415861 <strncmp+0x71>
  41586e:	66 90                	xchg   ax,ax

0000000000415870 <strnlen>:
#include <string.h>

size_t strnlen(const char *s, size_t n)
{
  415870:	f3 0f 1e fa          	endbr64 
  415874:	55                   	push   rbp
	const char *p = memchr(s, 0, n);
  415875:	48 89 f2             	mov    rdx,rsi
{
  415878:	48 89 fd             	mov    rbp,rdi
  41587b:	53                   	push   rbx
  41587c:	48 89 f3             	mov    rbx,rsi
	const char *p = memchr(s, 0, n);
  41587f:	31 f6                	xor    esi,esi
{
  415881:	48 83 ec 08          	sub    rsp,0x8
	const char *p = memchr(s, 0, n);
  415885:	e8 36 4a 00 00       	call   41a2c0 <memchr>
	return p ? p-s : n;
  41588a:	48 89 c2             	mov    rdx,rax
  41588d:	48 29 ea             	sub    rdx,rbp
  415890:	48 85 c0             	test   rax,rax
  415893:	48 89 d8             	mov    rax,rbx
  415896:	48 0f 45 c2          	cmovne rax,rdx
}
  41589a:	48 83 c4 08          	add    rsp,0x8
  41589e:	5b                   	pop    rbx
  41589f:	5d                   	pop    rbp
  4158a0:	c3                   	ret    
  4158a1:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4158a8:	00 00 00 
  4158ab:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000004158b0 <__init_tp>:
#include "syscall.h"

volatile int __thread_list_lock;

int __init_tp(void *p)
{
  4158b0:	f3 0f 1e fa          	endbr64 
  4158b4:	53                   	push   rbx
  4158b5:	66 48 0f 6e c7       	movq   xmm0,rdi
  4158ba:	48 89 fb             	mov    rbx,rdi
  4158bd:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  4158c1:	48 83 ec 10          	sub    rsp,0x10
	pthread_t td = p;
	td->self = td;
  4158c5:	48 89 3f             	mov    QWORD PTR [rdi],rdi
  4158c8:	0f 29 04 24          	movaps XMMWORD PTR [rsp],xmm0
	int r = __set_thread_area(TP_ADJ(p));
  4158cc:	e8 7f f5 ff ff       	call   414e50 <__set_thread_area>
	if (r < 0) return -1;
  4158d1:	85 c0                	test   eax,eax
  4158d3:	78 77                	js     41594c <__init_tp+0x9c>
	if (!r) libc.can_do_threads = 1;
  4158d5:	74 69                	je     415940 <__init_tp+0x90>
	return __cos_syscall(n, a1, 0, 0, 0, 0, 0, 0);
  4158d7:	6a 00                	push   0x0
  4158d9:	31 d2                	xor    edx,edx
  4158db:	45 31 c9             	xor    r9d,r9d
  4158de:	45 31 c0             	xor    r8d,r8d
  4158e1:	6a 00                	push   0x0
  4158e3:	31 c9                	xor    ecx,ecx
  4158e5:	48 8d 35 3c c9 18 00 	lea    rsi,[rip+0x18c93c]        # 5a2228 <__thread_list_lock>
  4158ec:	bf da 00 00 00       	mov    edi,0xda
	td->detach_state = DT_JOINABLE;
  4158f1:	c7 43 40 01 00 00 00 	mov    DWORD PTR [rbx+0x40],0x1
  4158f8:	e8 e3 49 ff ff       	call   40a2e0 <__cos_syscall>
	td->tid = __syscall(SYS_set_tid_address, &__thread_list_lock);
	td->locale = &libc.global_locale;
	td->robust_list.head = &td->robust_list.head;
	td->sysinfo = __sysinfo;
	td->next = td->prev = td;
  4158fd:	66 0f 6f 4c 24 10    	movdqa xmm1,XMMWORD PTR [rsp+0x10]
	td->tid = __syscall(SYS_set_tid_address, &__thread_list_lock);
  415903:	89 43 38             	mov    DWORD PTR [rbx+0x38],eax
	td->locale = &libc.global_locale;
  415906:	48 8d 05 33 c7 18 00 	lea    rax,[rip+0x18c733]        # 5a2040 <__libc+0x40>
  41590d:	48 89 83 b0 00 00 00 	mov    QWORD PTR [rbx+0xb0],rax
	td->robust_list.head = &td->robust_list.head;
  415914:	48 8d 83 90 00 00 00 	lea    rax,[rbx+0x90]
  41591b:	48 89 83 90 00 00 00 	mov    QWORD PTR [rbx+0x90],rax
	td->sysinfo = __sysinfo;
  415922:	48 8b 05 b7 c6 18 00 	mov    rax,QWORD PTR [rip+0x18c6b7]        # 5a1fe0 <__sysinfo>
	td->next = td->prev = td;
  415929:	0f 11 4b 10          	movups XMMWORD PTR [rbx+0x10],xmm1
	td->sysinfo = __sysinfo;
  41592d:	48 89 43 20          	mov    QWORD PTR [rbx+0x20],rax
	return 0;
  415931:	58                   	pop    rax
  415932:	31 c0                	xor    eax,eax
  415934:	5a                   	pop    rdx
}
  415935:	48 83 c4 10          	add    rsp,0x10
  415939:	5b                   	pop    rbx
  41593a:	c3                   	ret    
  41593b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	if (!r) libc.can_do_threads = 1;
  415940:	c7 05 b6 c6 18 00 01 	mov    DWORD PTR [rip+0x18c6b6],0x1        # 5a2000 <__libc>
  415947:	00 00 00 
  41594a:	eb 8b                	jmp    4158d7 <__init_tp+0x27>
	if (r < 0) return -1;
  41594c:	b8 ff ff ff ff       	mov    eax,0xffffffff
  415951:	eb e2                	jmp    415935 <__init_tp+0x85>
  415953:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41595a:	00 00 00 
  41595d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000415960 <__copy_tls>:
#define MIN_TLS_ALIGN offsetof(struct builtin_tls, pt)

static struct tls_module main_tls;

void *__copy_tls(unsigned char *mem)
{
  415960:	f3 0f 1e fa          	endbr64 
  415964:	41 55                	push   r13
  415966:	49 89 fd             	mov    r13,rdi
  415969:	41 54                	push   r12
  41596b:	55                   	push   rbp
  41596c:	53                   	push   rbx
  41596d:	48 83 ec 08          	sub    rsp,0x8
		memcpy(mem + p->offset, p->image, p->len);
	}
#else
	dtv = (uintptr_t *)mem;

	mem += libc.tls_size - sizeof(struct pthread);
  415971:	48 8b 05 a8 c6 18 00 	mov    rax,QWORD PTR [rip+0x18c6a8]        # 5a2020 <__libc+0x20>
	mem -= (uintptr_t)mem & (libc.tls_align-1);
  415978:	4c 8b 25 a9 c6 18 00 	mov    r12,QWORD PTR [rip+0x18c6a9]        # 5a2028 <__libc+0x28>
	td = (pthread_t)mem;

	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
  41597f:	48 8b 1d 92 c6 18 00 	mov    rbx,QWORD PTR [rip+0x18c692]        # 5a2018 <__libc+0x18>
	mem += libc.tls_size - sizeof(struct pthread);
  415986:	48 8d 84 07 20 ff ff 	lea    rax,[rdi+rax*1-0xe0]
  41598d:	ff 
	mem -= (uintptr_t)mem & (libc.tls_align-1);
  41598e:	49 f7 dc             	neg    r12
  415991:	49 21 c4             	and    r12,rax
	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
  415994:	48 85 db             	test   rbx,rbx
  415997:	74 32                	je     4159cb <__copy_tls+0x6b>
  415999:	48 8d 6f 08          	lea    rbp,[rdi+0x8]
  41599d:	0f 1f 00             	nop    DWORD PTR [rax]
		dtv[i] = (uintptr_t)(mem - p->offset) + DTP_OFFSET;
  4159a0:	4c 89 e0             	mov    rax,r12
  4159a3:	48 2b 43 28          	sub    rax,QWORD PTR [rbx+0x28]
		memcpy(mem - p->offset, p->image, p->len);
  4159a7:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
  4159ab:	4c 89 e7             	mov    rdi,r12
		dtv[i] = (uintptr_t)(mem - p->offset) + DTP_OFFSET;
  4159ae:	48 89 45 00          	mov    QWORD PTR [rbp+0x0],rax
		memcpy(mem - p->offset, p->image, p->len);
  4159b2:	48 8b 53 10          	mov    rdx,QWORD PTR [rbx+0x10]
	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
  4159b6:	48 83 c5 08          	add    rbp,0x8
		memcpy(mem - p->offset, p->image, p->len);
  4159ba:	48 2b 7b 28          	sub    rdi,QWORD PTR [rbx+0x28]
  4159be:	e8 97 f3 ff ff       	call   414d5a <memcpy>
	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
  4159c3:	48 8b 1b             	mov    rbx,QWORD PTR [rbx]
  4159c6:	48 85 db             	test   rbx,rbx
  4159c9:	75 d5                	jne    4159a0 <__copy_tls+0x40>
	}
#endif
	dtv[0] = libc.tls_cnt;
  4159cb:	48 8b 05 5e c6 18 00 	mov    rax,QWORD PTR [rip+0x18c65e]        # 5a2030 <__libc+0x30>
  4159d2:	49 89 45 00          	mov    QWORD PTR [r13+0x0],rax
	td->dtv = td->dtv_copy = dtv;
	return td;
}
  4159d6:	4c 89 e0             	mov    rax,r12
	td->dtv = td->dtv_copy = dtv;
  4159d9:	4d 89 ac 24 d8 00 00 	mov    QWORD PTR [r12+0xd8],r13
  4159e0:	00 
  4159e1:	4d 89 6c 24 08       	mov    QWORD PTR [r12+0x8],r13
}
  4159e6:	48 83 c4 08          	add    rsp,0x8
  4159ea:	5b                   	pop    rbx
  4159eb:	5d                   	pop    rbp
  4159ec:	41 5c                	pop    r12
  4159ee:	41 5d                	pop    r13
  4159f0:	c3                   	ret    
  4159f1:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4159f8:	00 00 00 
  4159fb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000415a00 <__init_tls>:
#endif

extern weak hidden const size_t _DYNAMIC[];

static void static_init_tls(size_t *aux)
{
  415a00:	f3 0f 1e fa          	endbr64 
  415a04:	41 55                	push   r13
  415a06:	41 54                	push   r12
  415a08:	55                   	push   rbp
  415a09:	53                   	push   rbx
  415a0a:	48 83 ec 28          	sub    rsp,0x28
	size_t n;
	Phdr *phdr, *tls_phdr=0;
	size_t base = 0;
	void *mem;

	for (p=(void *)aux[AT_PHDR],n=aux[AT_PHNUM]; n; n--,p+=aux[AT_PHENT]) {
  415a0e:	48 8b 57 28          	mov    rdx,QWORD PTR [rdi+0x28]
  415a12:	48 8b 6f 18          	mov    rbp,QWORD PTR [rdi+0x18]
  415a16:	48 85 d2             	test   rdx,rdx
  415a19:	0f 84 31 03 00 00    	je     415d50 <__init_tls+0x350>
  415a1f:	49 c7 c1 00 00 00 00 	mov    r9,0x0
  415a26:	4c 8b 5f 20          	mov    r11,QWORD PTR [rdi+0x20]
  415a2a:	48 89 e8             	mov    rax,rbp
	size_t base = 0;
  415a2d:	31 c9                	xor    ecx,ecx
  415a2f:	44 8b 05 92 66 04 00 	mov    r8d,DWORD PTR [rip+0x46692]        # 45c0c8 <__default_stacksize>
	for (p=(void *)aux[AT_PHDR],n=aux[AT_PHNUM]; n; n--,p+=aux[AT_PHENT]) {
  415a36:	45 31 d2             	xor    r10d,r10d
	Phdr *phdr, *tls_phdr=0;
  415a39:	31 db                	xor    ebx,ebx
  415a3b:	4d 85 c9             	test   r9,r9
  415a3e:	75 26                	jne    415a66 <__init_tls+0x66>
  415a40:	e9 25 02 00 00       	jmp    415c6a <__init_tls+0x26a>
  415a45:	0f 1f 00             	nop    DWORD PTR [rax]
		phdr = (void *)p;
		if (phdr->p_type == PT_PHDR)
			base = aux[AT_PHDR] - phdr->p_vaddr;
		if (phdr->p_type == PT_DYNAMIC && _DYNAMIC)
  415a48:	83 fe 02             	cmp    esi,0x2
  415a4b:	0f 84 5f 02 00 00    	je     415cb0 <__init_tls+0x2b0>
			base = (size_t)_DYNAMIC - phdr->p_vaddr;
		if (phdr->p_type == PT_TLS)
  415a51:	83 fe 07             	cmp    esi,0x7
  415a54:	0f 85 20 02 00 00    	jne    415c7a <__init_tls+0x27a>
  415a5a:	48 89 c3             	mov    rbx,rax
	for (p=(void *)aux[AT_PHDR],n=aux[AT_PHNUM]; n; n--,p+=aux[AT_PHENT]) {
  415a5d:	4c 01 d8             	add    rax,r11
  415a60:	48 83 ea 01          	sub    rdx,0x1
  415a64:	74 17                	je     415a7d <__init_tls+0x7d>
		if (phdr->p_type == PT_PHDR)
  415a66:	8b 30                	mov    esi,DWORD PTR [rax]
  415a68:	83 fe 06             	cmp    esi,0x6
  415a6b:	75 db                	jne    415a48 <__init_tls+0x48>
			base = aux[AT_PHDR] - phdr->p_vaddr;
  415a6d:	48 89 e9             	mov    rcx,rbp
  415a70:	48 2b 48 10          	sub    rcx,QWORD PTR [rax+0x10]
	for (p=(void *)aux[AT_PHDR],n=aux[AT_PHNUM]; n; n--,p+=aux[AT_PHENT]) {
  415a74:	4c 01 d8             	add    rax,r11
  415a77:	48 83 ea 01          	sub    rdx,0x1
  415a7b:	75 e9                	jne    415a66 <__init_tls+0x66>
  415a7d:	45 84 d2             	test   r10b,r10b
  415a80:	74 07                	je     415a89 <__init_tls+0x89>
  415a82:	44 89 05 3f 66 04 00 	mov    DWORD PTR [rip+0x4663f],r8d        # 45c0c8 <__default_stacksize>
			__default_stacksize =
				phdr->p_memsz < DEFAULT_STACK_MAX ?
				phdr->p_memsz : DEFAULT_STACK_MAX;
	}

	if (tls_phdr) {
  415a89:	48 85 db             	test   rbx,rbx
  415a8c:	0f 84 be 02 00 00    	je     415d50 <__init_tls+0x350>
		main_tls.image = (void *)(base + tls_phdr->p_vaddr);
		main_tls.len = tls_phdr->p_filesz;
		main_tls.size = tls_phdr->p_memsz;
		main_tls.align = tls_phdr->p_align;
  415a92:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
		main_tls.image = (void *)(base + tls_phdr->p_vaddr);
  415a96:	48 03 4b 10          	add    rcx,QWORD PTR [rbx+0x10]
		libc.tls_cnt = 1;
		libc.tls_head = &main_tls;
  415a9a:	48 8d 05 df c5 18 00 	lea    rax,[rip+0x18c5df]        # 5a2080 <main_tls>
		main_tls.len = tls_phdr->p_filesz;
  415aa1:	f3 0f 6f 7b 20       	movdqu xmm7,XMMWORD PTR [rbx+0x20]
		main_tls.size = tls_phdr->p_memsz;
  415aa6:	48 8b 53 28          	mov    rdx,QWORD PTR [rbx+0x28]
		main_tls.image = (void *)(base + tls_phdr->p_vaddr);
  415aaa:	48 89 0d d7 c5 18 00 	mov    QWORD PTR [rip+0x18c5d7],rcx        # 5a2088 <main_tls+0x8>
		main_tls.align = tls_phdr->p_align;
  415ab1:	48 89 35 e8 c5 18 00 	mov    QWORD PTR [rip+0x18c5e8],rsi        # 5a20a0 <main_tls+0x20>
		libc.tls_cnt = 1;
  415ab8:	48 c7 05 6d c5 18 00 	mov    QWORD PTR [rip+0x18c56d],0x1        # 5a2030 <__libc+0x30>
  415abf:	01 00 00 00 
		libc.tls_head = &main_tls;
  415ac3:	48 89 05 4e c5 18 00 	mov    QWORD PTR [rip+0x18c54e],rax        # 5a2018 <__libc+0x18>
		main_tls.len = tls_phdr->p_filesz;
  415aca:	0f 29 3d bf c5 18 00 	movaps XMMWORD PTR [rip+0x18c5bf],xmm7        # 5a2090 <main_tls+0x10>
	}

	main_tls.size += (-main_tls.size - (uintptr_t)main_tls.image)
  415ad1:	48 01 d1             	add    rcx,rdx
		& (main_tls.align-1);
  415ad4:	48 8d 46 ff          	lea    rax,[rsi-0x1]
	main_tls.size += (-main_tls.size - (uintptr_t)main_tls.image)
  415ad8:	48 f7 d9             	neg    rcx
		& (main_tls.align-1);
  415adb:	48 21 c1             	and    rcx,rax
	main_tls.size += (-main_tls.size - (uintptr_t)main_tls.image)
  415ade:	48 01 ca             	add    rdx,rcx
  415ae1:	48 8d 8e f7 00 00 00 	lea    rcx,[rsi+0xf7]
  415ae8:	48 89 15 a9 c5 18 00 	mov    QWORD PTR [rip+0x18c5a9],rdx        # 5a2098 <main_tls+0x18>
#ifdef TLS_ABOVE_TP
	main_tls.offset = GAP_ABOVE_TP;
	main_tls.offset += (-GAP_ABOVE_TP + (uintptr_t)main_tls.image)
		& (main_tls.align-1);
#else
	main_tls.offset = main_tls.size;
  415aef:	48 89 15 b2 c5 18 00 	mov    QWORD PTR [rip+0x18c5b2],rdx        # 5a20a8 <main_tls+0x28>
#endif
	if (main_tls.align < MIN_TLS_ALIGN) main_tls.align = MIN_TLS_ALIGN;
  415af6:	48 83 fe 07          	cmp    rsi,0x7
  415afa:	77 1a                	ja     415b16 <__init_tls+0x116>
  415afc:	b8 07 00 00 00       	mov    eax,0x7
  415b01:	b9 ff 00 00 00       	mov    ecx,0xff
  415b06:	be 08 00 00 00       	mov    esi,0x8
  415b0b:	48 c7 05 8a c5 18 00 	mov    QWORD PTR [rip+0x18c58a],0x8        # 5a20a0 <main_tls+0x20>
  415b12:	08 00 00 00 
	libc.tls_size = 2*sizeof(void *) + sizeof(struct pthread)
#ifdef TLS_ABOVE_TP
		+ main_tls.offset
#endif
		+ main_tls.size + main_tls.align
		+ MIN_TLS_ALIGN-1 & -MIN_TLS_ALIGN;
  415b16:	48 01 ca             	add    rdx,rcx
	libc.tls_size = 2*sizeof(void *) + sizeof(struct pthread)
  415b19:	66 48 0f 6e de       	movq   xmm3,rsi
			MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);
		/* -4095...-1 cast to void * will crash on dereference anyway,
		 * so don't bloat the init code checking for error codes and
		 * explicitly calling a_crash(). */
	} else {
		mem = builtin_tls;
  415b1e:	4c 8d 2d 9b c5 18 00 	lea    r13,[rip+0x18c59b]        # 5a20c0 <builtin_tls>
		+ MIN_TLS_ALIGN-1 & -MIN_TLS_ALIGN;
  415b25:	48 83 e2 f8          	and    rdx,0xfffffffffffffff8
	libc.tls_size = 2*sizeof(void *) + sizeof(struct pthread)
  415b29:	66 48 0f 6e c2       	movq   xmm0,rdx
  415b2e:	66 0f 6c c3          	punpcklqdq xmm0,xmm3
  415b32:	0f 11 05 e7 c4 18 00 	movups XMMWORD PTR [rip+0x18c4e7],xmm0        # 5a2020 <__libc+0x20>
	if (libc.tls_size > sizeof builtin_tls) {
  415b39:	48 81 fa 68 01 00 00 	cmp    rdx,0x168
  415b40:	0f 87 ca 01 00 00    	ja     415d10 <__init_tls+0x310>
	mem += libc.tls_size - sizeof(struct pthread);
  415b46:	66 49 0f 6e e5       	movq   xmm4,r13
  415b4b:	49 8d ac 15 20 ff ff 	lea    rbp,[r13+rdx*1-0xe0]
  415b52:	ff 
	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
  415b53:	48 8b 1d be c4 18 00 	mov    rbx,QWORD PTR [rip+0x18c4be]        # 5a2018 <__libc+0x18>
  415b5a:	4d 8d 65 08          	lea    r12,[r13+0x8]
	mem -= (uintptr_t)mem & (libc.tls_align-1);
  415b5e:	48 21 e8             	and    rax,rbp
  415b61:	48 29 c5             	sub    rbp,rax
  415b64:	66 48 0f 6e cd       	movq   xmm1,rbp
  415b69:	66 48 0f 6e d5       	movq   xmm2,rbp
  415b6e:	66 0f 6c c9          	punpcklqdq xmm1,xmm1
  415b72:	66 0f 6c d4          	punpcklqdq xmm2,xmm4
  415b76:	0f 29 4c 24 10       	movaps XMMWORD PTR [rsp+0x10],xmm1
  415b7b:	0f 29 14 24          	movaps XMMWORD PTR [rsp],xmm2
	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
  415b7f:	48 85 db             	test   rbx,rbx
  415b82:	74 2f                	je     415bb3 <__init_tls+0x1b3>
  415b84:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		dtv[i] = (uintptr_t)(mem - p->offset) + DTP_OFFSET;
  415b88:	48 89 e8             	mov    rax,rbp
  415b8b:	48 2b 43 28          	sub    rax,QWORD PTR [rbx+0x28]
		memcpy(mem - p->offset, p->image, p->len);
  415b8f:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
  415b93:	48 89 ef             	mov    rdi,rbp
		dtv[i] = (uintptr_t)(mem - p->offset) + DTP_OFFSET;
  415b96:	49 89 04 24          	mov    QWORD PTR [r12],rax
		memcpy(mem - p->offset, p->image, p->len);
  415b9a:	48 8b 53 10          	mov    rdx,QWORD PTR [rbx+0x10]
	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
  415b9e:	49 83 c4 08          	add    r12,0x8
		memcpy(mem - p->offset, p->image, p->len);
  415ba2:	48 2b 7b 28          	sub    rdi,QWORD PTR [rbx+0x28]
  415ba6:	e8 af f1 ff ff       	call   414d5a <memcpy>
	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
  415bab:	48 8b 1b             	mov    rbx,QWORD PTR [rbx]
  415bae:	48 85 db             	test   rbx,rbx
  415bb1:	75 d5                	jne    415b88 <__init_tls+0x188>
	dtv[0] = libc.tls_cnt;
  415bb3:	48 8b 05 76 c4 18 00 	mov    rax,QWORD PTR [rip+0x18c476]        # 5a2030 <__libc+0x30>
	td->self = td;
  415bba:	66 0f 6f 2c 24       	movdqa xmm5,XMMWORD PTR [rsp]
	int r = __set_thread_area(TP_ADJ(p));
  415bbf:	48 89 ef             	mov    rdi,rbp
	dtv[0] = libc.tls_cnt;
  415bc2:	49 89 45 00          	mov    QWORD PTR [r13+0x0],rax
	td->dtv = td->dtv_copy = dtv;
  415bc6:	4c 89 ad d8 00 00 00 	mov    QWORD PTR [rbp+0xd8],r13
	td->self = td;
  415bcd:	0f 11 6d 00          	movups XMMWORD PTR [rbp+0x0],xmm5
	int r = __set_thread_area(TP_ADJ(p));
  415bd1:	e8 7a f2 ff ff       	call   414e50 <__set_thread_area>
	if (r < 0) return -1;
  415bd6:	85 c0                	test   eax,eax
  415bd8:	0f 88 21 01 00 00    	js     415cff <__init_tls+0x2ff>
	if (!r) libc.can_do_threads = 1;
  415bde:	0f 84 0c 01 00 00    	je     415cf0 <__init_tls+0x2f0>
	td->detach_state = DT_JOINABLE;
  415be4:	c7 45 40 01 00 00 00 	mov    DWORD PTR [rbp+0x40],0x1
  415beb:	31 d2                	xor    edx,edx
  415bed:	45 31 c9             	xor    r9d,r9d
  415bf0:	45 31 c0             	xor    r8d,r8d
  415bf3:	6a 00                	push   0x0
  415bf5:	31 c9                	xor    ecx,ecx
  415bf7:	48 8d 35 2a c6 18 00 	lea    rsi,[rip+0x18c62a]        # 5a2228 <__thread_list_lock>
  415bfe:	bf da 00 00 00       	mov    edi,0xda
  415c03:	6a 00                	push   0x0
  415c05:	e8 d6 46 ff ff       	call   40a2e0 <__cos_syscall>
	td->next = td->prev = td;
  415c0a:	66 0f 6f 74 24 20    	movdqa xmm6,XMMWORD PTR [rsp+0x20]
	td->tid = __syscall(SYS_set_tid_address, &__thread_list_lock);
  415c10:	89 45 38             	mov    DWORD PTR [rbp+0x38],eax
	td->locale = &libc.global_locale;
  415c13:	48 8d 05 26 c4 18 00 	lea    rax,[rip+0x18c426]        # 5a2040 <__libc+0x40>
  415c1a:	48 89 85 b0 00 00 00 	mov    QWORD PTR [rbp+0xb0],rax
	td->robust_list.head = &td->robust_list.head;
  415c21:	48 8d 85 90 00 00 00 	lea    rax,[rbp+0x90]
  415c28:	48 89 85 90 00 00 00 	mov    QWORD PTR [rbp+0x90],rax
	td->sysinfo = __sysinfo;
  415c2f:	48 8b 05 aa c3 18 00 	mov    rax,QWORD PTR [rip+0x18c3aa]        # 5a1fe0 <__sysinfo>
	td->next = td->prev = td;
  415c36:	0f 11 75 10          	movups XMMWORD PTR [rbp+0x10],xmm6
	td->sysinfo = __sysinfo;
  415c3a:	48 89 45 20          	mov    QWORD PTR [rbp+0x20],rax
	td->next = td->prev = td;
  415c3e:	58                   	pop    rax
  415c3f:	5a                   	pop    rdx
	}

	/* Failure to initialize thread pointer is always fatal. */
	if (__init_tp(__copy_tls(mem)) < 0)
		a_crash();
}
  415c40:	48 83 c4 28          	add    rsp,0x28
  415c44:	5b                   	pop    rbx
  415c45:	5d                   	pop    rbp
  415c46:	41 5c                	pop    r12
  415c48:	41 5d                	pop    r13
  415c4a:	c3                   	ret    
  415c4b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		if (phdr->p_type == PT_DYNAMIC && _DYNAMIC)
  415c50:	83 fe 02             	cmp    esi,0x2
  415c53:	74 08                	je     415c5d <__init_tls+0x25d>
		if (phdr->p_type == PT_TLS)
  415c55:	83 fe 07             	cmp    esi,0x7
  415c58:	75 62                	jne    415cbc <__init_tls+0x2bc>
  415c5a:	48 89 c3             	mov    rbx,rax
	for (p=(void *)aux[AT_PHDR],n=aux[AT_PHNUM]; n; n--,p+=aux[AT_PHENT]) {
  415c5d:	4c 01 d8             	add    rax,r11
  415c60:	48 83 ea 01          	sub    rdx,0x1
  415c64:	0f 84 13 fe ff ff    	je     415a7d <__init_tls+0x7d>
		if (phdr->p_type == PT_PHDR)
  415c6a:	8b 30                	mov    esi,DWORD PTR [rax]
  415c6c:	83 fe 06             	cmp    esi,0x6
  415c6f:	75 df                	jne    415c50 <__init_tls+0x250>
			base = aux[AT_PHDR] - phdr->p_vaddr;
  415c71:	48 89 e9             	mov    rcx,rbp
  415c74:	48 2b 48 10          	sub    rcx,QWORD PTR [rax+0x10]
		if (phdr->p_type == PT_GNU_STACK &&
  415c78:	eb e3                	jmp    415c5d <__init_tls+0x25d>
  415c7a:	81 fe 51 e5 74 64    	cmp    esi,0x6474e551
  415c80:	0f 85 d7 fd ff ff    	jne    415a5d <__init_tls+0x5d>
		    phdr->p_memsz > __default_stacksize)
  415c86:	48 8b 70 28          	mov    rsi,QWORD PTR [rax+0x28]
  415c8a:	44 89 c7             	mov    edi,r8d
		if (phdr->p_type == PT_GNU_STACK &&
  415c8d:	48 39 fe             	cmp    rsi,rdi
  415c90:	0f 86 c7 fd ff ff    	jbe    415a5d <__init_tls+0x5d>
			__default_stacksize =
  415c96:	41 b8 00 00 80 00    	mov    r8d,0x800000
  415c9c:	41 ba 01 00 00 00    	mov    r10d,0x1
  415ca2:	4c 39 c6             	cmp    rsi,r8
  415ca5:	4c 0f 46 c6          	cmovbe r8,rsi
  415ca9:	e9 af fd ff ff       	jmp    415a5d <__init_tls+0x5d>
  415cae:	66 90                	xchg   ax,ax
			base = (size_t)_DYNAMIC - phdr->p_vaddr;
  415cb0:	4c 89 c9             	mov    rcx,r9
  415cb3:	48 2b 48 10          	sub    rcx,QWORD PTR [rax+0x10]
		if (phdr->p_type == PT_GNU_STACK &&
  415cb7:	e9 a1 fd ff ff       	jmp    415a5d <__init_tls+0x5d>
  415cbc:	81 fe 51 e5 74 64    	cmp    esi,0x6474e551
  415cc2:	75 99                	jne    415c5d <__init_tls+0x25d>
		    phdr->p_memsz > __default_stacksize)
  415cc4:	48 8b 70 28          	mov    rsi,QWORD PTR [rax+0x28]
  415cc8:	44 89 c7             	mov    edi,r8d
		if (phdr->p_type == PT_GNU_STACK &&
  415ccb:	48 39 f7             	cmp    rdi,rsi
  415cce:	73 8d                	jae    415c5d <__init_tls+0x25d>
			__default_stacksize =
  415cd0:	41 b8 00 00 80 00    	mov    r8d,0x800000
  415cd6:	41 ba 01 00 00 00    	mov    r10d,0x1
  415cdc:	4c 39 c6             	cmp    rsi,r8
  415cdf:	4c 0f 46 c6          	cmovbe r8,rsi
  415ce3:	e9 75 ff ff ff       	jmp    415c5d <__init_tls+0x25d>
  415ce8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  415cef:	00 
	if (!r) libc.can_do_threads = 1;
  415cf0:	c7 05 06 c3 18 00 01 	mov    DWORD PTR [rip+0x18c306],0x1        # 5a2000 <__libc>
  415cf7:	00 00 00 
  415cfa:	e9 e5 fe ff ff       	jmp    415be4 <__init_tls+0x1e4>
  415cff:	f4                   	hlt    
}
  415d00:	48 83 c4 28          	add    rsp,0x28
  415d04:	5b                   	pop    rbx
  415d05:	5d                   	pop    rbp
  415d06:	41 5c                	pop    r12
  415d08:	41 5d                	pop    r13
  415d0a:	c3                   	ret    
  415d0b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	return __cos_syscall(n, a1, a2, a3, a4, a5, 0, 0);
}

static __inline long __syscall6(long n, long a1, long a2, long a3, long a4, long a5, long a6)
{
	return __cos_syscall(n, a1, a2, a3, a4, a5, a6, 0);
  415d10:	6a 00                	push   0x0
  415d12:	b9 03 00 00 00       	mov    ecx,0x3
  415d17:	31 f6                	xor    esi,esi
  415d19:	49 c7 c1 ff ff ff ff 	mov    r9,0xffffffffffffffff
  415d20:	6a 00                	push   0x0
  415d22:	41 b8 22 00 00 00    	mov    r8d,0x22
  415d28:	bf 09 00 00 00       	mov    edi,0x9
  415d2d:	e8 ae 45 ff ff       	call   40a2e0 <__cos_syscall>
  415d32:	59                   	pop    rcx
	mem += libc.tls_size - sizeof(struct pthread);
  415d33:	48 8b 15 e6 c2 18 00 	mov    rdx,QWORD PTR [rip+0x18c2e6]        # 5a2020 <__libc+0x20>
  415d3a:	49 89 c5             	mov    r13,rax
	mem -= (uintptr_t)mem & (libc.tls_align-1);
  415d3d:	48 8b 05 e4 c2 18 00 	mov    rax,QWORD PTR [rip+0x18c2e4]        # 5a2028 <__libc+0x28>
  415d44:	5e                   	pop    rsi
  415d45:	48 83 e8 01          	sub    rax,0x1
  415d49:	e9 f8 fd ff ff       	jmp    415b46 <__init_tls+0x146>
  415d4e:	66 90                	xchg   ax,ax
	main_tls.size += (-main_tls.size - (uintptr_t)main_tls.image)
  415d50:	48 8b 15 41 c3 18 00 	mov    rdx,QWORD PTR [rip+0x18c341]        # 5a2098 <main_tls+0x18>
  415d57:	48 8b 0d 2a c3 18 00 	mov    rcx,QWORD PTR [rip+0x18c32a]        # 5a2088 <main_tls+0x8>
		& (main_tls.align-1);
  415d5e:	48 8b 35 3b c3 18 00 	mov    rsi,QWORD PTR [rip+0x18c33b]        # 5a20a0 <main_tls+0x20>
  415d65:	e9 67 fd ff ff       	jmp    415ad1 <__init_tls+0xd1>
  415d6a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000415d70 <__errno_location>:
#include <errno.h>
#include "pthread_impl.h"

int *__errno_location(void)
{
  415d70:	f3 0f 1e fa          	endbr64 
	static int e;
	return &e;
  415d74:	48 8d 05 b1 c4 18 00 	lea    rax,[rip+0x18c4b1]        # 5a222c <e.0>
}
  415d7b:	c3                   	ret    
  415d7c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000415d80 <_Exit>:
#include <stdlib.h>
#include "syscall.h"

_Noreturn void _Exit(int ec)
{
  415d80:	f3 0f 1e fa          	endbr64 
  415d84:	53                   	push   rbx
	__syscall(SYS_exit_group, ec);
  415d85:	48 63 df             	movsxd rbx,edi
	return __cos_syscall(n, a1, 0, 0, 0, 0, 0, 0);
  415d88:	31 c9                	xor    ecx,ecx
  415d8a:	45 31 c9             	xor    r9d,r9d
  415d8d:	6a 00                	push   0x0
  415d8f:	48 89 de             	mov    rsi,rbx
  415d92:	45 31 c0             	xor    r8d,r8d
  415d95:	31 d2                	xor    edx,edx
  415d97:	6a 00                	push   0x0
  415d99:	bf e7 00 00 00       	mov    edi,0xe7
  415d9e:	e8 3d 45 ff ff       	call   40a2e0 <__cos_syscall>
  415da3:	59                   	pop    rcx
  415da4:	5e                   	pop    rsi
  415da5:	0f 1f 00             	nop    DWORD PTR [rax]
  415da8:	6a 00                	push   0x0
  415daa:	31 d2                	xor    edx,edx
  415dac:	45 31 c9             	xor    r9d,r9d
  415daf:	45 31 c0             	xor    r8d,r8d
  415db2:	6a 00                	push   0x0
  415db4:	31 c9                	xor    ecx,ecx
  415db6:	48 89 de             	mov    rsi,rbx
  415db9:	bf 3c 00 00 00       	mov    edi,0x3c
  415dbe:	e8 1d 45 ff ff       	call   40a2e0 <__cos_syscall>
  415dc3:	58                   	pop    rax
  415dc4:	5a                   	pop    rdx
  415dc5:	eb e1                	jmp    415da8 <_Exit+0x28>
  415dc7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  415dce:	00 00 

0000000000415dd0 <pop_arg>:
	void *p;
};

static void pop_arg(union arg *arg, int type, va_list *ap)
{
	switch (type) {
  415dd0:	83 ee 09             	sub    esi,0x9
{
  415dd3:	48 89 d0             	mov    rax,rdx
	switch (type) {
  415dd6:	83 fe 11             	cmp    esi,0x11
  415dd9:	77 4d                	ja     415e28 <pop_arg+0x58>
  415ddb:	48 8d 0d ce 82 00 00 	lea    rcx,[rip+0x82ce]        # 41e0b0 <CSWTCH.186+0x760>
  415de2:	48 63 14 b1          	movsxd rdx,DWORD PTR [rcx+rsi*4]
  415de6:	48 01 ca             	add    rdx,rcx
  415de9:	3e ff e2             	notrack jmp rdx
  415dec:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	break; case LLONG:	arg->i = va_arg(*ap, long long);
	break; case SIZET:	arg->i = va_arg(*ap, size_t);
	break; case IMAX:	arg->i = va_arg(*ap, intmax_t);
	break; case UMAX:	arg->i = va_arg(*ap, uintmax_t);
	break; case PDIFF:	arg->i = va_arg(*ap, ptrdiff_t);
	break; case UIPTR:	arg->i = (uintptr_t)va_arg(*ap, void *);
  415df0:	8b 10                	mov    edx,DWORD PTR [rax]
  415df2:	83 fa 2f             	cmp    edx,0x2f
  415df5:	77 39                	ja     415e30 <pop_arg+0x60>
  415df7:	89 d1                	mov    ecx,edx
  415df9:	83 c2 08             	add    edx,0x8
  415dfc:	48 03 48 10          	add    rcx,QWORD PTR [rax+0x10]
  415e00:	89 10                	mov    DWORD PTR [rax],edx
  415e02:	48 8b 01             	mov    rax,QWORD PTR [rcx]
  415e05:	48 89 07             	mov    QWORD PTR [rdi],rax
	break; case DBL:	arg->f = va_arg(*ap, double);
  415e08:	c3                   	ret    
  415e09:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	break; case LDBL:	arg->f = va_arg(*ap, long double);
  415e10:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  415e14:	48 8d 51 0f          	lea    rdx,[rcx+0xf]
  415e18:	48 83 e2 f0          	and    rdx,0xfffffffffffffff0
  415e1c:	48 8d 4a 10          	lea    rcx,[rdx+0x10]
  415e20:	48 89 48 08          	mov    QWORD PTR [rax+0x8],rcx
  415e24:	db 2a                	fld    TBYTE PTR [rdx]
  415e26:	db 3f                	fstp   TBYTE PTR [rdi]
	}
}
  415e28:	c3                   	ret    
  415e29:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	break; case UIPTR:	arg->i = (uintptr_t)va_arg(*ap, void *);
  415e30:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  415e34:	48 8d 51 08          	lea    rdx,[rcx+0x8]
  415e38:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  415e3c:	48 8b 01             	mov    rax,QWORD PTR [rcx]
  415e3f:	48 89 07             	mov    QWORD PTR [rdi],rax
	break; case DBL:	arg->f = va_arg(*ap, double);
  415e42:	c3                   	ret    
  415e43:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	break; case USHORT:	arg->i = (unsigned short)va_arg(*ap, int);
  415e48:	8b 10                	mov    edx,DWORD PTR [rax]
  415e4a:	83 fa 2f             	cmp    edx,0x2f
  415e4d:	0f 87 55 01 00 00    	ja     415fa8 <pop_arg+0x1d8>
  415e53:	89 d1                	mov    ecx,edx
  415e55:	83 c2 08             	add    edx,0x8
  415e58:	48 03 48 10          	add    rcx,QWORD PTR [rax+0x10]
  415e5c:	89 10                	mov    DWORD PTR [rax],edx
  415e5e:	0f b7 01             	movzx  eax,WORD PTR [rcx]
  415e61:	48 89 07             	mov    QWORD PTR [rdi],rax
	break; case CHAR:	arg->i = (signed char)va_arg(*ap, int);
  415e64:	c3                   	ret    
  415e65:	0f 1f 00             	nop    DWORD PTR [rax]
	break; case DBL:	arg->f = va_arg(*ap, double);
  415e68:	8b 50 04             	mov    edx,DWORD PTR [rax+0x4]
  415e6b:	81 fa af 00 00 00    	cmp    edx,0xaf
  415e71:	0f 87 19 01 00 00    	ja     415f90 <pop_arg+0x1c0>
  415e77:	89 d1                	mov    ecx,edx
  415e79:	83 c2 10             	add    edx,0x10
  415e7c:	48 03 48 10          	add    rcx,QWORD PTR [rax+0x10]
  415e80:	89 50 04             	mov    DWORD PTR [rax+0x4],edx
  415e83:	dd 01                	fld    QWORD PTR [rcx]
  415e85:	db 3f                	fstp   TBYTE PTR [rdi]
	break; case LDBL:	arg->f = va_arg(*ap, long double);
  415e87:	c3                   	ret    
  415e88:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  415e8f:	00 
	break; case INT:	arg->i = va_arg(*ap, int);
  415e90:	8b 10                	mov    edx,DWORD PTR [rax]
  415e92:	83 fa 2f             	cmp    edx,0x2f
  415e95:	0f 87 dd 00 00 00    	ja     415f78 <pop_arg+0x1a8>
  415e9b:	89 d1                	mov    ecx,edx
  415e9d:	83 c2 08             	add    edx,0x8
  415ea0:	48 03 48 10          	add    rcx,QWORD PTR [rax+0x10]
  415ea4:	89 10                	mov    DWORD PTR [rax],edx
  415ea6:	48 63 01             	movsxd rax,DWORD PTR [rcx]
  415ea9:	48 89 07             	mov    QWORD PTR [rdi],rax
	break; case UINT:	arg->i = va_arg(*ap, unsigned int);
  415eac:	c3                   	ret    
  415ead:	0f 1f 00             	nop    DWORD PTR [rax]
  415eb0:	8b 10                	mov    edx,DWORD PTR [rax]
  415eb2:	83 fa 2f             	cmp    edx,0x2f
  415eb5:	0f 87 a5 00 00 00    	ja     415f60 <pop_arg+0x190>
  415ebb:	89 d1                	mov    ecx,edx
  415ebd:	83 c2 08             	add    edx,0x8
  415ec0:	48 03 48 10          	add    rcx,QWORD PTR [rax+0x10]
  415ec4:	89 10                	mov    DWORD PTR [rax],edx
  415ec6:	8b 01                	mov    eax,DWORD PTR [rcx]
  415ec8:	48 89 07             	mov    QWORD PTR [rdi],rax
	break; case LONG:	arg->i = va_arg(*ap, long);
  415ecb:	c3                   	ret    
  415ecc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	break; case UCHAR:	arg->i = (unsigned char)va_arg(*ap, int);
  415ed0:	8b 10                	mov    edx,DWORD PTR [rax]
  415ed2:	83 fa 2f             	cmp    edx,0x2f
  415ed5:	77 79                	ja     415f50 <pop_arg+0x180>
  415ed7:	89 d1                	mov    ecx,edx
  415ed9:	83 c2 08             	add    edx,0x8
  415edc:	48 03 48 10          	add    rcx,QWORD PTR [rax+0x10]
  415ee0:	89 10                	mov    DWORD PTR [rax],edx
  415ee2:	0f b6 01             	movzx  eax,BYTE PTR [rcx]
  415ee5:	48 89 07             	mov    QWORD PTR [rdi],rax
	break; case LLONG:	arg->i = va_arg(*ap, long long);
  415ee8:	c3                   	ret    
  415ee9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	break; case CHAR:	arg->i = (signed char)va_arg(*ap, int);
  415ef0:	8b 10                	mov    edx,DWORD PTR [rax]
  415ef2:	83 fa 2f             	cmp    edx,0x2f
  415ef5:	77 49                	ja     415f40 <pop_arg+0x170>
  415ef7:	89 d1                	mov    ecx,edx
  415ef9:	83 c2 08             	add    edx,0x8
  415efc:	48 03 48 10          	add    rcx,QWORD PTR [rax+0x10]
  415f00:	89 10                	mov    DWORD PTR [rax],edx
  415f02:	48 0f be 01          	movsx  rax,BYTE PTR [rcx]
  415f06:	48 89 07             	mov    QWORD PTR [rdi],rax
	break; case UCHAR:	arg->i = (unsigned char)va_arg(*ap, int);
  415f09:	c3                   	ret    
  415f0a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	break; case SHORT:	arg->i = (short)va_arg(*ap, int);
  415f10:	8b 10                	mov    edx,DWORD PTR [rax]
  415f12:	83 fa 2f             	cmp    edx,0x2f
  415f15:	77 19                	ja     415f30 <pop_arg+0x160>
  415f17:	89 d1                	mov    ecx,edx
  415f19:	83 c2 08             	add    edx,0x8
  415f1c:	48 03 48 10          	add    rcx,QWORD PTR [rax+0x10]
  415f20:	89 10                	mov    DWORD PTR [rax],edx
  415f22:	48 0f bf 01          	movsx  rax,WORD PTR [rcx]
  415f26:	48 89 07             	mov    QWORD PTR [rdi],rax
	break; case USHORT:	arg->i = (unsigned short)va_arg(*ap, int);
  415f29:	c3                   	ret    
  415f2a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	break; case SHORT:	arg->i = (short)va_arg(*ap, int);
  415f30:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  415f34:	48 8d 51 08          	lea    rdx,[rcx+0x8]
  415f38:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  415f3c:	eb e4                	jmp    415f22 <pop_arg+0x152>
  415f3e:	66 90                	xchg   ax,ax
	break; case CHAR:	arg->i = (signed char)va_arg(*ap, int);
  415f40:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  415f44:	48 8d 51 08          	lea    rdx,[rcx+0x8]
  415f48:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  415f4c:	eb b4                	jmp    415f02 <pop_arg+0x132>
  415f4e:	66 90                	xchg   ax,ax
	break; case UCHAR:	arg->i = (unsigned char)va_arg(*ap, int);
  415f50:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  415f54:	48 8d 51 08          	lea    rdx,[rcx+0x8]
  415f58:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  415f5c:	eb 84                	jmp    415ee2 <pop_arg+0x112>
  415f5e:	66 90                	xchg   ax,ax
	break; case UINT:	arg->i = va_arg(*ap, unsigned int);
  415f60:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  415f64:	48 8d 51 08          	lea    rdx,[rcx+0x8]
  415f68:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  415f6c:	e9 55 ff ff ff       	jmp    415ec6 <pop_arg+0xf6>
  415f71:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	break; case INT:	arg->i = va_arg(*ap, int);
  415f78:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  415f7c:	48 8d 51 08          	lea    rdx,[rcx+0x8]
  415f80:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  415f84:	e9 1d ff ff ff       	jmp    415ea6 <pop_arg+0xd6>
  415f89:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	break; case DBL:	arg->f = va_arg(*ap, double);
  415f90:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  415f94:	48 8d 51 08          	lea    rdx,[rcx+0x8]
  415f98:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  415f9c:	e9 e2 fe ff ff       	jmp    415e83 <pop_arg+0xb3>
  415fa1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	break; case USHORT:	arg->i = (unsigned short)va_arg(*ap, int);
  415fa8:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  415fac:	48 8d 51 08          	lea    rdx,[rcx+0x8]
  415fb0:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  415fb4:	e9 a5 fe ff ff       	jmp    415e5e <pop_arg+0x8e>

0000000000415fb9 <fmt_fp.cold>:
  415fb9:	44 8d 83 00 ff ff ff 	lea    r8d,[rbx-0x100]
  415fc0:	66 0f 6e eb          	movd   xmm5,ebx
{
	char pad[256];
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
	l = w - l;
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
	for (; l >= sizeof pad; l -= sizeof pad)
  415fc4:	31 c9                	xor    ecx,ecx
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  415fc6:	41 89 d1             	mov    r9d,edx
  415fc9:	44 89 c0             	mov    eax,r8d
  415fcc:	66 0f 70 dd 00       	pshufd xmm3,xmm5,0x0
  415fd1:	66 0f 6f 15 f7 84 00 	movdqa xmm2,XMMWORD PTR [rip+0x84f7]        # 41e4d0 <states+0x290>
  415fd8:	00 
  415fd9:	66 0f fe 1d df 84 00 	paddd  xmm3,XMMWORD PTR [rip+0x84df]        # 41e4c0 <states+0x280>
  415fe0:	00 
  415fe1:	c1 e8 08             	shr    eax,0x8
  415fe4:	66 0f 6f 0d f4 84 00 	movdqa xmm1,XMMWORD PTR [rip+0x84f4]        # 41e4e0 <states+0x2a0>
  415feb:	00 
  415fec:	83 c0 01             	add    eax,0x1
  415fef:	89 c6                	mov    esi,eax
  415ff1:	c1 ee 02             	shr    esi,0x2
  415ff4:	66 0f 6f c3          	movdqa xmm0,xmm3
  415ff8:	83 c1 01             	add    ecx,0x1
  415ffb:	66 0f fe da          	paddd  xmm3,xmm2
  415fff:	44 89 ca             	mov    edx,r9d
	for (; l >= sizeof pad; l -= sizeof pad)
  416002:	66 0f fe c1          	paddd  xmm0,xmm1
  416006:	39 f1                	cmp    ecx,esi
  416008:	72 ea                	jb     415ff4 <fmt_fp.cold+0x3b>
  41600a:	41 89 c1             	mov    r9d,eax
  41600d:	66 0f 70 c0 ff       	pshufd xmm0,xmm0,0xff
  416012:	41 83 e1 fc          	and    r9d,0xfffffffc
  416016:	66 0f 7e c1          	movd   ecx,xmm0
  41601a:	41 69 f1 00 ff ff ff 	imul   esi,r9d,0xffffff00
  416021:	41 39 c1             	cmp    r9d,eax
  416024:	0f 84 92 0d 00 00    	je     416dbc <fmt_fp+0x86c>
  41602a:	42 8d 04 06          	lea    eax,[rsi+r8*1]
  41602e:	89 c1                	mov    ecx,eax
  416030:	3d ff 00 00 00       	cmp    eax,0xff
  416035:	0f 86 81 0d 00 00    	jbe    416dbc <fmt_fp+0x86c>
  41603b:	81 e9 00 01 00 00    	sub    ecx,0x100
  416041:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  416047:	0f 86 6f 0d 00 00    	jbe    416dbc <fmt_fp+0x86c>
  41604d:	8d 88 00 fe ff ff    	lea    ecx,[rax-0x200]
  416053:	e9 64 0d 00 00       	jmp    416dbc <fmt_fp+0x86c>
  416058:	8d b3 00 ff ff ff    	lea    esi,[rbx-0x100]
  41605e:	66 0f 6e f3          	movd   xmm6,ebx
  416062:	31 c9                	xor    ecx,ecx
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  416064:	41 89 d0             	mov    r8d,edx
  416067:	89 f0                	mov    eax,esi
  416069:	66 0f 70 de 00       	pshufd xmm3,xmm6,0x0
  41606e:	66 0f 6f 15 5a 84 00 	movdqa xmm2,XMMWORD PTR [rip+0x845a]        # 41e4d0 <states+0x290>
  416075:	00 
  416076:	66 0f fe 1d 42 84 00 	paddd  xmm3,XMMWORD PTR [rip+0x8442]        # 41e4c0 <states+0x280>
  41607d:	00 
  41607e:	c1 e8 08             	shr    eax,0x8
  416081:	66 0f 6f 0d 57 84 00 	movdqa xmm1,XMMWORD PTR [rip+0x8457]        # 41e4e0 <states+0x2a0>
  416088:	00 
  416089:	83 c0 01             	add    eax,0x1
  41608c:	41 89 c1             	mov    r9d,eax
  41608f:	41 c1 e9 02          	shr    r9d,0x2
  416093:	66 0f 6f c3          	movdqa xmm0,xmm3
  416097:	83 c1 01             	add    ecx,0x1
  41609a:	66 0f fe da          	paddd  xmm3,xmm2
  41609e:	44 89 c2             	mov    edx,r8d
	for (; l >= sizeof pad; l -= sizeof pad)
  4160a1:	66 0f fe c1          	paddd  xmm0,xmm1
  4160a5:	41 39 c9             	cmp    r9d,ecx
  4160a8:	77 e9                	ja     416093 <fmt_fp.cold+0xda>
  4160aa:	41 89 c0             	mov    r8d,eax
  4160ad:	66 0f 70 c0 ff       	pshufd xmm0,xmm0,0xff
  4160b2:	41 83 e0 fc          	and    r8d,0xfffffffc
  4160b6:	66 0f 7e c5          	movd   ebp,xmm0
  4160ba:	41 69 c8 00 ff ff ff 	imul   ecx,r8d,0xffffff00
  4160c1:	41 39 c0             	cmp    r8d,eax
  4160c4:	0f 84 78 0d 00 00    	je     416e42 <fmt_fp+0x8f2>
  4160ca:	8d 04 31             	lea    eax,[rcx+rsi*1]
  4160cd:	89 c5                	mov    ebp,eax
  4160cf:	3d ff 00 00 00       	cmp    eax,0xff
  4160d4:	0f 86 68 0d 00 00    	jbe    416e42 <fmt_fp+0x8f2>
  4160da:	81 ed 00 01 00 00    	sub    ebp,0x100
  4160e0:	81 fd ff 00 00 00    	cmp    ebp,0xff
  4160e6:	0f 86 56 0d 00 00    	jbe    416e42 <fmt_fp+0x8f2>
  4160ec:	8d a8 00 fe ff ff    	lea    ebp,[rax-0x200]
  4160f2:	e9 4b 0d 00 00       	jmp    416e42 <fmt_fp+0x8f2>
  4160f7:	8d 8b 00 ff ff ff    	lea    ecx,[rbx-0x100]
  4160fd:	66 0f 6e fb          	movd   xmm7,ebx
  416101:	45 31 c0             	xor    r8d,r8d
  416104:	66 0f 6f 15 c4 83 00 	movdqa xmm2,XMMWORD PTR [rip+0x83c4]        # 41e4d0 <states+0x290>
  41610b:	00 
  41610c:	89 ce                	mov    esi,ecx
  41610e:	66 0f 70 df 00       	pshufd xmm3,xmm7,0x0
  416113:	66 0f 6f 0d c5 83 00 	movdqa xmm1,XMMWORD PTR [rip+0x83c5]        # 41e4e0 <states+0x2a0>
  41611a:	00 
  41611b:	66 0f fe 1d 9d 83 00 	paddd  xmm3,XMMWORD PTR [rip+0x839d]        # 41e4c0 <states+0x280>
  416122:	00 
  416123:	c1 ee 08             	shr    esi,0x8
  416126:	83 c6 01             	add    esi,0x1
  416129:	41 89 f1             	mov    r9d,esi
  41612c:	41 c1 e9 02          	shr    r9d,0x2
  416130:	66 0f 6f c3          	movdqa xmm0,xmm3
  416134:	41 83 c0 01          	add    r8d,0x1
  416138:	66 0f fe da          	paddd  xmm3,xmm2
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41613c:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  41613e:	66 0f fe c1          	paddd  xmm0,xmm1
  416142:	45 39 c8             	cmp    r8d,r9d
  416145:	72 e9                	jb     416130 <fmt_fp.cold+0x177>
  416147:	89 f0                	mov    eax,esi
  416149:	66 0f 70 c0 ff       	pshufd xmm0,xmm0,0xff
  41614e:	83 e0 fc             	and    eax,0xfffffffc
  416151:	66 0f 7e c5          	movd   ebp,xmm0
  416155:	44 69 c0 00 ff ff ff 	imul   r8d,eax,0xffffff00
  41615c:	39 c6                	cmp    esi,eax
  41615e:	0f 84 99 0d 00 00    	je     416efd <fmt_fp+0x9ad>
  416164:	42 8d 04 01          	lea    eax,[rcx+r8*1]
  416168:	89 c5                	mov    ebp,eax
  41616a:	3d ff 00 00 00       	cmp    eax,0xff
  41616f:	0f 86 88 0d 00 00    	jbe    416efd <fmt_fp+0x9ad>
  416175:	81 ed 00 01 00 00    	sub    ebp,0x100
  41617b:	81 fd ff 00 00 00    	cmp    ebp,0xff
  416181:	0f 86 76 0d 00 00    	jbe    416efd <fmt_fp+0x9ad>
  416187:	8d a8 00 fe ff ff    	lea    ebp,[rax-0x200]
  41618d:	e9 6b 0d 00 00       	jmp    416efd <fmt_fp+0x9ad>
  416192:	8d bb 00 ff ff ff    	lea    edi,[rbx-0x100]
  416198:	66 0f 6e fb          	movd   xmm7,ebx
  41619c:	31 f6                	xor    esi,esi
  41619e:	66 0f 6f 15 2a 83 00 	movdqa xmm2,XMMWORD PTR [rip+0x832a]        # 41e4d0 <states+0x290>
  4161a5:	00 
  4161a6:	89 f9                	mov    ecx,edi
  4161a8:	66 0f 70 df 00       	pshufd xmm3,xmm7,0x0
  4161ad:	66 0f 6f 0d 2b 83 00 	movdqa xmm1,XMMWORD PTR [rip+0x832b]        # 41e4e0 <states+0x2a0>
  4161b4:	00 
  4161b5:	66 0f fe 1d 03 83 00 	paddd  xmm3,XMMWORD PTR [rip+0x8303]        # 41e4c0 <states+0x280>
  4161bc:	00 
  4161bd:	c1 e9 08             	shr    ecx,0x8
  4161c0:	83 c1 01             	add    ecx,0x1
  4161c3:	41 89 c8             	mov    r8d,ecx
  4161c6:	41 c1 e8 02          	shr    r8d,0x2
  4161ca:	66 0f 6f c3          	movdqa xmm0,xmm3
  4161ce:	83 c6 01             	add    esi,0x1
  4161d1:	66 0f fe da          	paddd  xmm3,xmm2
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4161d5:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  4161d7:	66 0f fe c1          	paddd  xmm0,xmm1
  4161db:	41 39 f0             	cmp    r8d,esi
  4161de:	77 ea                	ja     4161ca <fmt_fp.cold+0x211>
  4161e0:	89 ce                	mov    esi,ecx
  4161e2:	66 0f 70 c0 ff       	pshufd xmm0,xmm0,0xff
  4161e7:	83 e6 fc             	and    esi,0xfffffffc
  4161ea:	66 0f 7e c5          	movd   ebp,xmm0
  4161ee:	69 c6 00 ff ff ff    	imul   eax,esi,0xffffff00
  4161f4:	39 ce                	cmp    esi,ecx
  4161f6:	0f 84 a2 15 00 00    	je     41779e <fmt_fp+0x124e>
  4161fc:	01 f8                	add    eax,edi
  4161fe:	89 c5                	mov    ebp,eax
  416200:	3d ff 00 00 00       	cmp    eax,0xff
  416205:	0f 86 93 15 00 00    	jbe    41779e <fmt_fp+0x124e>
  41620b:	81 ed 00 01 00 00    	sub    ebp,0x100
  416211:	81 fd ff 00 00 00    	cmp    ebp,0xff
  416217:	0f 86 81 15 00 00    	jbe    41779e <fmt_fp+0x124e>
  41621d:	8d a8 00 fe ff ff    	lea    ebp,[rax-0x200]
  416223:	e9 76 15 00 00       	jmp    41779e <fmt_fp+0x124e>
  416228:	8d 8b 00 ff ff ff    	lea    ecx,[rbx-0x100]
  41622e:	66 0f 6e f3          	movd   xmm6,ebx
  416232:	45 31 c0             	xor    r8d,r8d
  416235:	66 0f 6f 15 93 82 00 	movdqa xmm2,XMMWORD PTR [rip+0x8293]        # 41e4d0 <states+0x290>
  41623c:	00 
  41623d:	89 ce                	mov    esi,ecx
  41623f:	66 0f 70 c6 00       	pshufd xmm0,xmm6,0x0
  416244:	66 0f 6f 0d 94 82 00 	movdqa xmm1,XMMWORD PTR [rip+0x8294]        # 41e4e0 <states+0x2a0>
  41624b:	00 
  41624c:	66 0f fe 05 6c 82 00 	paddd  xmm0,XMMWORD PTR [rip+0x826c]        # 41e4c0 <states+0x280>
  416253:	00 
  416254:	c1 ee 08             	shr    esi,0x8
  416257:	83 c6 01             	add    esi,0x1
  41625a:	41 89 f1             	mov    r9d,esi
  41625d:	41 c1 e9 02          	shr    r9d,0x2
  416261:	66 0f 6f d8          	movdqa xmm3,xmm0
  416265:	41 83 c0 01          	add    r8d,0x1
  416269:	66 0f fe c2          	paddd  xmm0,xmm2
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41626d:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  41626f:	66 0f fe d9          	paddd  xmm3,xmm1
  416273:	45 39 c8             	cmp    r8d,r9d
  416276:	72 e9                	jb     416261 <fmt_fp.cold+0x2a8>
  416278:	89 f0                	mov    eax,esi
  41627a:	66 0f 70 c3 ff       	pshufd xmm0,xmm3,0xff
  41627f:	83 e0 fc             	and    eax,0xfffffffc
  416282:	66 0f 7e c5          	movd   ebp,xmm0
  416286:	44 69 c0 00 ff ff ff 	imul   r8d,eax,0xffffff00
  41628d:	39 c6                	cmp    esi,eax
  41628f:	0f 84 90 0e 00 00    	je     417125 <fmt_fp+0xbd5>
  416295:	42 8d 04 01          	lea    eax,[rcx+r8*1]
  416299:	89 c5                	mov    ebp,eax
  41629b:	3d ff 00 00 00       	cmp    eax,0xff
  4162a0:	0f 86 7f 0e 00 00    	jbe    417125 <fmt_fp+0xbd5>
  4162a6:	81 ed 00 01 00 00    	sub    ebp,0x100
  4162ac:	81 fd ff 00 00 00    	cmp    ebp,0xff
  4162b2:	0f 86 6d 0e 00 00    	jbe    417125 <fmt_fp+0xbd5>
  4162b8:	8d a8 00 fe ff ff    	lea    ebp,[rax-0x200]
  4162be:	e9 62 0e 00 00       	jmp    417125 <fmt_fp+0xbd5>
  4162c3:	8d b1 00 ff ff ff    	lea    esi,[rcx-0x100]
  4162c9:	66 0f 6e f9          	movd   xmm7,ecx
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4162cd:	41 89 d1             	mov    r9d,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  4162d0:	31 c9                	xor    ecx,ecx
  4162d2:	89 f0                	mov    eax,esi
  4162d4:	66 0f 70 df 00       	pshufd xmm3,xmm7,0x0
  4162d9:	66 0f 6f 15 ef 81 00 	movdqa xmm2,XMMWORD PTR [rip+0x81ef]        # 41e4d0 <states+0x290>
  4162e0:	00 
  4162e1:	66 0f fe 1d d7 81 00 	paddd  xmm3,XMMWORD PTR [rip+0x81d7]        # 41e4c0 <states+0x280>
  4162e8:	00 
  4162e9:	c1 e8 08             	shr    eax,0x8
  4162ec:	66 0f 6f 0d ec 81 00 	movdqa xmm1,XMMWORD PTR [rip+0x81ec]        # 41e4e0 <states+0x2a0>
  4162f3:	00 
  4162f4:	83 c0 01             	add    eax,0x1
  4162f7:	41 89 c0             	mov    r8d,eax
  4162fa:	41 c1 e8 02          	shr    r8d,0x2
  4162fe:	66 0f 6f c3          	movdqa xmm0,xmm3
  416302:	83 c1 01             	add    ecx,0x1
  416305:	66 0f fe da          	paddd  xmm3,xmm2
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  416309:	44 89 ca             	mov    edx,r9d
	for (; l >= sizeof pad; l -= sizeof pad)
  41630c:	66 0f fe c1          	paddd  xmm0,xmm1
  416310:	44 39 c1             	cmp    ecx,r8d
  416313:	72 e9                	jb     4162fe <fmt_fp.cold+0x345>
  416315:	41 89 c1             	mov    r9d,eax
  416318:	66 0f 70 c0 ff       	pshufd xmm0,xmm0,0xff
  41631d:	41 83 e1 fc          	and    r9d,0xfffffffc
  416321:	66 41 0f 7e c0       	movd   r8d,xmm0
  416326:	41 69 c9 00 ff ff ff 	imul   ecx,r9d,0xffffff00
  41632d:	41 39 c1             	cmp    r9d,eax
  416330:	0f 84 c4 09 00 00    	je     416cfa <fmt_fp+0x7aa>
  416336:	8d 04 31             	lea    eax,[rcx+rsi*1]
  416339:	41 89 c0             	mov    r8d,eax
  41633c:	3d ff 00 00 00       	cmp    eax,0xff
  416341:	0f 86 b3 09 00 00    	jbe    416cfa <fmt_fp+0x7aa>
  416347:	41 81 e8 00 01 00 00 	sub    r8d,0x100
  41634e:	41 81 f8 ff 00 00 00 	cmp    r8d,0xff
  416355:	0f 86 9f 09 00 00    	jbe    416cfa <fmt_fp+0x7aa>
  41635b:	44 8d 80 00 fe ff ff 	lea    r8d,[rax-0x200]
  416362:	e9 93 09 00 00       	jmp    416cfa <fmt_fp+0x7aa>
  416367:	41 8d 86 00 ff ff ff 	lea    eax,[r14-0x100]
  41636e:	66 41 0f 6e ee       	movd   xmm5,r14d
  416373:	31 f6                	xor    esi,esi
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  416375:	41 89 d0             	mov    r8d,edx
  416378:	89 c1                	mov    ecx,eax
  41637a:	66 0f 70 c5 00       	pshufd xmm0,xmm5,0x0
  41637f:	66 0f 6f 15 49 81 00 	movdqa xmm2,XMMWORD PTR [rip+0x8149]        # 41e4d0 <states+0x290>
  416386:	00 
  416387:	66 0f fe 05 31 81 00 	paddd  xmm0,XMMWORD PTR [rip+0x8131]        # 41e4c0 <states+0x280>
  41638e:	00 
  41638f:	c1 e9 08             	shr    ecx,0x8
  416392:	66 0f 6f 0d 46 81 00 	movdqa xmm1,XMMWORD PTR [rip+0x8146]        # 41e4e0 <states+0x2a0>
  416399:	00 
  41639a:	83 c1 01             	add    ecx,0x1
  41639d:	41 89 c9             	mov    r9d,ecx
  4163a0:	41 c1 e9 02          	shr    r9d,0x2
  4163a4:	66 0f 6f d8          	movdqa xmm3,xmm0
  4163a8:	83 c6 01             	add    esi,0x1
  4163ab:	66 0f fe c2          	paddd  xmm0,xmm2
  4163af:	44 89 c2             	mov    edx,r8d
	for (; l >= sizeof pad; l -= sizeof pad)
  4163b2:	66 0f fe d9          	paddd  xmm3,xmm1
  4163b6:	41 39 f1             	cmp    r9d,esi
  4163b9:	77 e9                	ja     4163a4 <fmt_fp.cold+0x3eb>
  4163bb:	89 ce                	mov    esi,ecx
  4163bd:	66 0f 70 c3 ff       	pshufd xmm0,xmm3,0xff
  4163c2:	83 e6 fc             	and    esi,0xfffffffc
  4163c5:	66 41 0f 7e c1       	movd   r9d,xmm0
  4163ca:	44 69 c6 00 ff ff ff 	imul   r8d,esi,0xffffff00
  4163d1:	39 f1                	cmp    ecx,esi
  4163d3:	0f 84 9c 0c 00 00    	je     417075 <fmt_fp+0xb25>
  4163d9:	44 01 c0             	add    eax,r8d
  4163dc:	41 89 c1             	mov    r9d,eax
  4163df:	3d ff 00 00 00       	cmp    eax,0xff
  4163e4:	0f 86 8b 0c 00 00    	jbe    417075 <fmt_fp+0xb25>
  4163ea:	41 81 e9 00 01 00 00 	sub    r9d,0x100
  4163f1:	41 81 f9 ff 00 00 00 	cmp    r9d,0xff
  4163f8:	0f 86 77 0c 00 00    	jbe    417075 <fmt_fp+0xb25>
  4163fe:	44 8d 88 00 fe ff ff 	lea    r9d,[rax-0x200]
  416405:	e9 6b 0c 00 00       	jmp    417075 <fmt_fp+0xb25>
  41640a:	41 8d bd 00 ff ff ff 	lea    edi,[r13-0x100]
  416411:	66 41 0f 6e f5       	movd   xmm6,r13d
  416416:	31 c9                	xor    ecx,ecx
  416418:	66 0f 6f 15 b0 80 00 	movdqa xmm2,XMMWORD PTR [rip+0x80b0]        # 41e4d0 <states+0x290>
  41641f:	00 
  416420:	89 f8                	mov    eax,edi
  416422:	66 0f 70 de 00       	pshufd xmm3,xmm6,0x0
  416427:	66 0f 6f 0d b1 80 00 	movdqa xmm1,XMMWORD PTR [rip+0x80b1]        # 41e4e0 <states+0x2a0>
  41642e:	00 
  41642f:	66 0f fe 1d 89 80 00 	paddd  xmm3,XMMWORD PTR [rip+0x8089]        # 41e4c0 <states+0x280>
  416436:	00 
  416437:	c1 e8 08             	shr    eax,0x8
  41643a:	8d 70 01             	lea    esi,[rax+0x1]
  41643d:	41 89 f0             	mov    r8d,esi
  416440:	41 c1 e8 02          	shr    r8d,0x2
  416444:	66 0f 6f c3          	movdqa xmm0,xmm3
  416448:	83 c1 01             	add    ecx,0x1
  41644b:	66 0f fe da          	paddd  xmm3,xmm2
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41644f:	89 d0                	mov    eax,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  416451:	66 0f fe c1          	paddd  xmm0,xmm1
  416455:	41 39 c8             	cmp    r8d,ecx
  416458:	77 ea                	ja     416444 <fmt_fp.cold+0x48b>
  41645a:	89 f2                	mov    edx,esi
  41645c:	66 0f 70 c0 ff       	pshufd xmm0,xmm0,0xff
  416461:	83 e2 fc             	and    edx,0xfffffffc
  416464:	66 41 0f 7e c6       	movd   r14d,xmm0
  416469:	69 ca 00 ff ff ff    	imul   ecx,edx,0xffffff00
  41646f:	39 d6                	cmp    esi,edx
  416471:	0f 84 f0 10 00 00    	je     417567 <fmt_fp+0x1017>
  416477:	01 cf                	add    edi,ecx
  416479:	41 89 fe             	mov    r14d,edi
  41647c:	81 ff ff 00 00 00    	cmp    edi,0xff
  416482:	0f 86 df 10 00 00    	jbe    417567 <fmt_fp+0x1017>
  416488:	41 81 ee 00 01 00 00 	sub    r14d,0x100
  41648f:	41 81 fe ff 00 00 00 	cmp    r14d,0xff
  416496:	0f 86 cb 10 00 00    	jbe    417567 <fmt_fp+0x1017>
  41649c:	44 8d b7 00 fe ff ff 	lea    r14d,[rdi-0x200]
  4164a3:	e9 bf 10 00 00       	jmp    417567 <fmt_fp+0x1017>
  4164a8:	41 8d bd 00 ff ff ff 	lea    edi,[r13-0x100]
  4164af:	66 41 0f 6e ed       	movd   xmm5,r13d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4164b4:	89 c1                	mov    ecx,eax
  4164b6:	66 0f 6f 15 12 80 00 	movdqa xmm2,XMMWORD PTR [rip+0x8012]        # 41e4d0 <states+0x290>
  4164bd:	00 
  4164be:	89 fa                	mov    edx,edi
  4164c0:	66 0f 70 dd 00       	pshufd xmm3,xmm5,0x0
  4164c5:	66 0f 6f 0d 13 80 00 	movdqa xmm1,XMMWORD PTR [rip+0x8013]        # 41e4e0 <states+0x2a0>
  4164cc:	00 
  4164cd:	66 0f fe 1d eb 7f 00 	paddd  xmm3,XMMWORD PTR [rip+0x7feb]        # 41e4c0 <states+0x280>
  4164d4:	00 
  4164d5:	c1 ea 08             	shr    edx,0x8
  4164d8:	8d 72 01             	lea    esi,[rdx+0x1]
	for (; l >= sizeof pad; l -= sizeof pad)
  4164db:	31 d2                	xor    edx,edx
  4164dd:	41 89 f0             	mov    r8d,esi
  4164e0:	41 c1 e8 02          	shr    r8d,0x2
  4164e4:	66 0f 6f c3          	movdqa xmm0,xmm3
  4164e8:	83 c2 01             	add    edx,0x1
  4164eb:	66 0f fe da          	paddd  xmm3,xmm2
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4164ef:	89 c8                	mov    eax,ecx
	for (; l >= sizeof pad; l -= sizeof pad)
  4164f1:	66 0f fe c1          	paddd  xmm0,xmm1
  4164f5:	44 39 c2             	cmp    edx,r8d
  4164f8:	72 ea                	jb     4164e4 <fmt_fp.cold+0x52b>
  4164fa:	89 f2                	mov    edx,esi
  4164fc:	66 0f 70 c0 ff       	pshufd xmm0,xmm0,0xff
  416501:	83 e2 fc             	and    edx,0xfffffffc
  416504:	66 41 0f 7e c6       	movd   r14d,xmm0
  416509:	69 ca 00 ff ff ff    	imul   ecx,edx,0xffffff00
  41650f:	39 d6                	cmp    esi,edx
  416511:	0f 84 91 0f 00 00    	je     4174a8 <fmt_fp+0xf58>
  416517:	01 cf                	add    edi,ecx
  416519:	41 89 fe             	mov    r14d,edi
  41651c:	81 ff ff 00 00 00    	cmp    edi,0xff
  416522:	0f 86 80 0f 00 00    	jbe    4174a8 <fmt_fp+0xf58>
  416528:	41 81 ee 00 01 00 00 	sub    r14d,0x100
  41652f:	41 81 fe ff 00 00 00 	cmp    r14d,0xff
  416536:	0f 86 6c 0f 00 00    	jbe    4174a8 <fmt_fp+0xf58>
  41653c:	44 8d b7 00 fe ff ff 	lea    r14d,[rdi-0x200]
  416543:	e9 60 0f 00 00       	jmp    4174a8 <fmt_fp+0xf58>
  416548:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41654f:	00 

0000000000416550 <fmt_fp>:
#if LDBL_MANT_DIG == 53
typedef char compiler_defines_long_double_incorrectly[9-(int)sizeof(long double)];
#endif

static int fmt_fp(FILE *f, long double y, int w, int p, int fl, int t)
{
  416550:	41 57                	push   r15
  416552:	41 56                	push   r14
  416554:	41 55                	push   r13
  416556:	41 54                	push   r12
  416558:	55                   	push   rbp
  416559:	53                   	push   rbx
  41655a:	48 81 ec 00 10 00 00 	sub    rsp,0x1000
  416561:	48 83 0c 24 00       	or     QWORD PTR [rsp],0x0
  416566:	48 81 ec 38 0e 00 00 	sub    rsp,0xe38
  41656d:	89 74 24 48          	mov    DWORD PTR [rsp+0x48],esi
  416571:	49 89 fc             	mov    r12,rdi
  416574:	45 89 c7             	mov    r15d,r8d
  416577:	89 14 24             	mov    DWORD PTR [rsp],edx
  41657a:	89 4c 24 14          	mov    DWORD PTR [rsp+0x14],ecx
	uint32_t big[(LDBL_MANT_DIG+28)/29 + 1          // mantissa expansion
		+ (LDBL_MAX_EXP+LDBL_MANT_DIG+28+8)/9]; // exponent expansion
	uint32_t *a, *d, *r, *z;
	int e2=0, e, i, j, l;
  41657e:	c7 44 24 50 00 00 00 	mov    DWORD PTR [rsp+0x50],0x0
  416585:	00 
	const char *prefix="-0X+0X 0X-0x+0x 0x";
	int pl;
	char ebuf0[3*sizeof(int)], *ebuf=&ebuf0[3*sizeof(int)], *estr;

	pl=1;
	if (signbit(y)) {
  416586:	ff b4 24 78 1e 00 00 	push   QWORD PTR [rsp+0x1e78]
  41658d:	ff b4 24 78 1e 00 00 	push   QWORD PTR [rsp+0x1e78]
  416594:	e8 37 3f 00 00       	call   41a4d0 <__signbitl>
  416599:	5a                   	pop    rdx
  41659a:	59                   	pop    rcx
  41659b:	85 c0                	test   eax,eax
  41659d:	0f 84 f5 03 00 00    	je     416998 <fmt_fp+0x448>
		y=-y;
  4165a3:	db ac 24 70 1e 00 00 	fld    TBYTE PTR [rsp+0x1e70]
	const char *prefix="-0X+0X 0X-0x+0x 0x";
  4165aa:	48 8d 05 47 7b 00 00 	lea    rax,[rip+0x7b47]        # 41e0f8 <CSWTCH.186+0x7a8>
  4165b1:	48 c7 44 24 30 01 00 	mov    QWORD PTR [rsp+0x30],0x1
  4165b8:	00 00 
  4165ba:	bd 03 00 00 00       	mov    ebp,0x3
  4165bf:	48 89 44 24 20       	mov    QWORD PTR [rsp+0x20],rax
  4165c4:	bb 03 00 00 00       	mov    ebx,0x3
  4165c9:	41 bd 04 00 00 00    	mov    r13d,0x4
	pl=1;
  4165cf:	c7 44 24 28 01 00 00 	mov    DWORD PTR [rsp+0x28],0x1
  4165d6:	00 
		y=-y;
  4165d7:	d9 e0                	fchs   
  4165d9:	db bc 24 70 1e 00 00 	fstp   TBYTE PTR [rsp+0x1e70]
		prefix+=3;
	} else if (fl & PAD_POS) {
		prefix+=6;
	} else prefix++, pl=0;

	if (!isfinite(y)) {
  4165e0:	ff b4 24 78 1e 00 00 	push   QWORD PTR [rsp+0x1e78]
  4165e7:	ff b4 24 78 1e 00 00 	push   QWORD PTR [rsp+0x1e78]
  4165ee:	e8 7d 3e 00 00       	call   41a470 <__fpclassifyl>
  4165f3:	41 5b                	pop    r11
  4165f5:	41 5e                	pop    r14
  4165f7:	83 f8 01             	cmp    eax,0x1
  4165fa:	0f 8e 90 09 00 00    	jle    416f90 <fmt_fp+0xa40>
		out(f, s, 3);
		pad(f, ' ', w, 3+pl, fl^LEFT_ADJ);
		return MAX(w, 3+pl);
	}

	y = frexpl(y, &e2) * 2;
  416600:	48 8d 7c 24 50       	lea    rdi,[rsp+0x50]
  416605:	ff b4 24 78 1e 00 00 	push   QWORD PTR [rsp+0x1e78]
  41660c:	ff b4 24 78 1e 00 00 	push   QWORD PTR [rsp+0x1e78]
  416613:	e8 d8 3e 00 00       	call   41a4f0 <frexpl>
	if (y) e2--;
  416618:	41 59                	pop    r9
  41661a:	41 5a                	pop    r10
	y = frexpl(y, &e2) * 2;
  41661c:	d8 c0                	fadd   st,st(0)
	if (y) e2--;
  41661e:	d9 ee                	fldz   
  416620:	d9 c0                	fld    st(0)
  416622:	d9 ca                	fxch   st(2)
  416624:	db ea                	fucomi st,st(2)
  416626:	dd da                	fstp   st(2)
  416628:	0f 8a b2 03 00 00    	jp     4169e0 <fmt_fp+0x490>
  41662e:	0f 85 ac 03 00 00    	jne    4169e0 <fmt_fp+0x490>

	if ((t|32)=='a') {
  416634:	45 89 fe             	mov    r14d,r15d
	if (y) e2--;
  416637:	44 8b 4c 24 50       	mov    r9d,DWORD PTR [rsp+0x50]
	if ((t|32)=='a') {
  41663c:	41 83 ce 20          	or     r14d,0x20
  416640:	41 83 fe 61          	cmp    r14d,0x61
  416644:	0f 84 b4 03 00 00    	je     4169fe <fmt_fp+0x4ae>
		pad(f, '0', l-(ebuf-estr)-(s-buf), 0, 0);
		out(f, estr, ebuf-estr);
		pad(f, ' ', w, pl+l, fl^LEFT_ADJ);
		return MAX(w, pl+l);
	}
	if (p<0) p=6;
  41664a:	8b 3c 24             	mov    edi,DWORD PTR [rsp]
  41664d:	85 ff                	test   edi,edi
  41664f:	0f 88 42 15 00 00    	js     417b97 <fmt_fp+0x1647>

	if (a<z) for (i=10, e=9*(r-a); *a>=i; i*=10, e++);
	else e=0;

	/* Perform rounding: j is precision after the radix (possibly neg) */
	j = p - ((t|32)!='f')*e - ((t|32)=='g' && p);
  416655:	0f 95 44 24 38       	setne  BYTE PTR [rsp+0x38]
	if (y) y *= 0x1p28, e2-=28;
  41665a:	d9 c0                	fld    st(0)
  41665c:	d9 ca                	fxch   st(2)
  41665e:	db ea                	fucomi st,st(2)
  416660:	dd da                	fstp   st(2)
  416662:	0f 8a 39 0b 00 00    	jp     4171a1 <fmt_fp+0xc51>
  416668:	0f 85 3a 0b 00 00    	jne    4171a8 <fmt_fp+0xc58>
	if (e2<0) a=r=z=big;
  41666e:	d9 7c 24 4e          	fnstcw WORD PTR [rsp+0x4e]
  416672:	45 85 c9             	test   r9d,r9d
  416675:	48 8d 84 24 80 01 00 	lea    rax,[rsp+0x180]
  41667c:	00 
  41667d:	48 8d 94 24 28 1d 00 	lea    rdx,[rsp+0x1d28]
  416684:	00 
  416685:	48 0f 49 c2          	cmovns rax,rdx
  416689:	d9 05 d9 7d 00 00    	fld    DWORD PTR [rip+0x7dd9]        # 41e468 <states+0x228>
  41668f:	d9 ca                	fxch   st(2)
  416691:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
	else a=r=z=big+sizeof(big)/sizeof(*big) - LDBL_MANT_DIG - 1;
  416696:	48 89 c3             	mov    rbx,rax
  416699:	0f b7 44 24 4e       	movzx  eax,WORD PTR [rsp+0x4e]
  41669e:	80 cc 0c             	or     ah,0xc
  4166a1:	66 89 44 24 4c       	mov    WORD PTR [rsp+0x4c],ax
  4166a6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4166ad:	00 00 00 
		*z = y;
  4166b0:	d9 c0                	fld    st(0)
  4166b2:	d9 6c 24 4c          	fldcw  WORD PTR [rsp+0x4c]
  4166b6:	df 7c 24 08          	fistp  QWORD PTR [rsp+0x8]
  4166ba:	d9 6c 24 4e          	fldcw  WORD PTR [rsp+0x4e]
		y = 1000000000*(y-*z++);
  4166be:	48 83 c3 04          	add    rbx,0x4
		*z = y;
  4166c2:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
  4166c7:	89 43 fc             	mov    DWORD PTR [rbx-0x4],eax
		y = 1000000000*(y-*z++);
  4166ca:	89 c0                	mov    eax,eax
  4166cc:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  4166d1:	df 6c 24 08          	fild   QWORD PTR [rsp+0x8]
  4166d5:	de e9                	fsubp  st(1),st
  4166d7:	d8 ca                	fmul   st,st(2)
	} while (y);
  4166d9:	d9 c1                	fld    st(1)
  4166db:	d9 c9                	fxch   st(1)
  4166dd:	db e9                	fucomi st,st(1)
  4166df:	dd d9                	fstp   st(1)
  4166e1:	7a cd                	jp     4166b0 <fmt_fp+0x160>
  4166e3:	75 cb                	jne    4166b0 <fmt_fp+0x160>
  4166e5:	dd d8                	fstp   st(0)
  4166e7:	dd d8                	fstp   st(0)
  4166e9:	dd d8                	fstp   st(0)
	while (e2>0) {
  4166eb:	48 8b 6c 24 18       	mov    rbp,QWORD PTR [rsp+0x18]
  4166f0:	45 85 c9             	test   r9d,r9d
  4166f3:	0f 8e 8c 00 00 00    	jle    416785 <fmt_fp+0x235>
			*d = x % 1000000000;
  4166f9:	49 b8 53 5a 9b a0 2f 	movabs r8,0x44b82fa09b5a53
  416700:	b8 44 00 
  416703:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		int sh=MIN(29,e2);
  416708:	b9 1d 00 00 00       	mov    ecx,0x1d
		for (d=z-1; d>=a; d--) {
  41670d:	48 8d 7b fc          	lea    rdi,[rbx-0x4]
		int sh=MIN(29,e2);
  416711:	41 39 c9             	cmp    r9d,ecx
  416714:	41 0f 4e c9          	cmovle ecx,r9d
		for (d=z-1; d>=a; d--) {
  416718:	48 39 ef             	cmp    rdi,rbp
  41671b:	72 3f                	jb     41675c <fmt_fp+0x20c>
		uint32_t carry=0;
  41671d:	31 c0                	xor    eax,eax
  41671f:	90                   	nop
			uint64_t x = ((uint64_t)*d<<sh)+carry;
  416720:	8b 37                	mov    esi,DWORD PTR [rdi]
		for (d=z-1; d>=a; d--) {
  416722:	48 83 ef 04          	sub    rdi,0x4
			uint64_t x = ((uint64_t)*d<<sh)+carry;
  416726:	48 d3 e6             	shl    rsi,cl
  416729:	48 01 c6             	add    rsi,rax
			*d = x % 1000000000;
  41672c:	48 89 f2             	mov    rdx,rsi
  41672f:	48 c1 ea 09          	shr    rdx,0x9
  416733:	48 89 d0             	mov    rax,rdx
  416736:	49 f7 e0             	mul    r8
  416739:	48 c1 ea 0b          	shr    rdx,0xb
  41673d:	48 69 c2 00 ca 9a 3b 	imul   rax,rdx,0x3b9aca00
  416744:	48 29 c6             	sub    rsi,rax
			carry = x / 1000000000;
  416747:	89 d0                	mov    eax,edx
			*d = x % 1000000000;
  416749:	89 77 04             	mov    DWORD PTR [rdi+0x4],esi
		for (d=z-1; d>=a; d--) {
  41674c:	48 39 ef             	cmp    rdi,rbp
  41674f:	73 cf                	jae    416720 <fmt_fp+0x1d0>
		if (carry) *--a = carry;
  416751:	85 c0                	test   eax,eax
  416753:	74 07                	je     41675c <fmt_fp+0x20c>
  416755:	89 55 fc             	mov    DWORD PTR [rbp-0x4],edx
  416758:	48 83 ed 04          	sub    rbp,0x4
		while (z>a && !z[-1]) z--;
  41675c:	48 39 dd             	cmp    rbp,rbx
  41675f:	72 10                	jb     416771 <fmt_fp+0x221>
  416761:	eb 15                	jmp    416778 <fmt_fp+0x228>
  416763:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  416768:	48 83 eb 04          	sub    rbx,0x4
  41676c:	48 39 eb             	cmp    rbx,rbp
  41676f:	76 07                	jbe    416778 <fmt_fp+0x228>
  416771:	8b 73 fc             	mov    esi,DWORD PTR [rbx-0x4]
  416774:	85 f6                	test   esi,esi
  416776:	74 f0                	je     416768 <fmt_fp+0x218>
		e2-=sh;
  416778:	41 29 c9             	sub    r9d,ecx
	while (e2>0) {
  41677b:	45 85 c9             	test   r9d,r9d
  41677e:	7f 88                	jg     416708 <fmt_fp+0x1b8>
  416780:	44 89 4c 24 50       	mov    DWORD PTR [rsp+0x50],r9d
	while (e2<0) {
  416785:	45 85 c9             	test   r9d,r9d
  416788:	0f 84 d3 00 00 00    	je     416861 <fmt_fp+0x311>
		int sh=MIN(9,-e2), need=1+(p+LDBL_MANT_DIG/3U+8)/9;
  41678e:	8b 04 24             	mov    eax,DWORD PTR [rsp]
			carry = (1000000000>>sh) * rm;
  416791:	4c 89 64 24 08       	mov    QWORD PTR [rsp+0x8],r12
  416796:	4c 8b 64 24 18       	mov    r12,QWORD PTR [rsp+0x18]
		int sh=MIN(9,-e2), need=1+(p+LDBL_MANT_DIG/3U+8)/9;
  41679b:	83 c0 1d             	add    eax,0x1d
  41679e:	48 69 c0 39 8e e3 38 	imul   rax,rax,0x38e38e39
  4167a5:	48 c1 e8 21          	shr    rax,0x21
		if (z-b > need) z = b+need;
  4167a9:	4c 8d 58 01          	lea    r11,[rax+0x1]
  4167ad:	4e 8d 2c 9d 00 00 00 	lea    r13,[r11*4+0x0]
  4167b4:	00 
  4167b5:	0f 1f 00             	nop    DWORD PTR [rax]
		int sh=MIN(9,-e2), need=1+(p+LDBL_MANT_DIG/3U+8)/9;
  4167b8:	41 83 f9 f7          	cmp    r9d,0xfffffff7
  4167bc:	0f 8d a6 07 00 00    	jge    416f68 <fmt_fp+0xa18>
		if (!*a) a++;
  4167c2:	8b 45 00             	mov    eax,DWORD PTR [rbp+0x0]
		e2+=sh;
  4167c5:	41 83 c1 09          	add    r9d,0x9
		int sh=MIN(9,-e2), need=1+(p+LDBL_MANT_DIG/3U+8)/9;
  4167c9:	b9 09 00 00 00       	mov    ecx,0x9
		for (d=a; d<z; d++) {
  4167ce:	48 39 dd             	cmp    rbp,rbx
  4167d1:	0f 83 a5 07 00 00    	jae    416f7c <fmt_fp+0xa2c>
			uint32_t rm = *d & (1<<sh)-1;
  4167d7:	41 b8 01 00 00 00    	mov    r8d,0x1
			carry = (1000000000>>sh) * rm;
  4167dd:	41 ba 00 ca 9a 3b    	mov    r10d,0x3b9aca00
  4167e3:	48 89 ee             	mov    rsi,rbp
		uint32_t carry=0, *b;
  4167e6:	31 d2                	xor    edx,edx
			uint32_t rm = *d & (1<<sh)-1;
  4167e8:	41 d3 e0             	shl    r8d,cl
			carry = (1000000000>>sh) * rm;
  4167eb:	41 d3 fa             	sar    r10d,cl
			uint32_t rm = *d & (1<<sh)-1;
  4167ee:	41 83 e8 01          	sub    r8d,0x1
  4167f2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4167f8:	8b 06                	mov    eax,DWORD PTR [rsi]
		for (d=a; d<z; d++) {
  4167fa:	48 83 c6 04          	add    rsi,0x4
			*d = (*d>>sh) + carry;
  4167fe:	89 c7                	mov    edi,eax
			uint32_t rm = *d & (1<<sh)-1;
  416800:	44 21 c0             	and    eax,r8d
			carry = (1000000000>>sh) * rm;
  416803:	41 0f af c2          	imul   eax,r10d
			*d = (*d>>sh) + carry;
  416807:	d3 ef                	shr    edi,cl
  416809:	01 fa                	add    edx,edi
  41680b:	89 56 fc             	mov    DWORD PTR [rsi-0x4],edx
			carry = (1000000000>>sh) * rm;
  41680e:	89 c2                	mov    edx,eax
		for (d=a; d<z; d++) {
  416810:	48 39 de             	cmp    rsi,rbx
  416813:	72 e3                	jb     4167f8 <fmt_fp+0x2a8>
		if (!*a) a++;
  416815:	8b 4d 00             	mov    ecx,DWORD PTR [rbp+0x0]
  416818:	48 8d 45 04          	lea    rax,[rbp+0x4]
  41681c:	85 c9                	test   ecx,ecx
  41681e:	48 0f 44 e8          	cmove  rbp,rax
		if (carry) *z++ = carry;
  416822:	85 d2                	test   edx,edx
  416824:	74 06                	je     41682c <fmt_fp+0x2dc>
  416826:	89 13                	mov    DWORD PTR [rbx],edx
  416828:	48 83 c3 04          	add    rbx,0x4
		b = (t|32)=='f' ? r : a;
  41682c:	41 83 fe 66          	cmp    r14d,0x66
  416830:	4c 89 e0             	mov    rax,r12
		if (z-b > need) z = b+need;
  416833:	48 89 da             	mov    rdx,rbx
		b = (t|32)=='f' ? r : a;
  416836:	48 0f 45 c5          	cmovne rax,rbp
		if (z-b > need) z = b+need;
  41683a:	48 29 c2             	sub    rdx,rax
  41683d:	4c 01 e8             	add    rax,r13
  416840:	48 c1 fa 02          	sar    rdx,0x2
  416844:	4c 39 da             	cmp    rdx,r11
  416847:	48 0f 4f d8          	cmovg  rbx,rax
	while (e2<0) {
  41684b:	45 85 c9             	test   r9d,r9d
  41684e:	0f 85 64 ff ff ff    	jne    4167b8 <fmt_fp+0x268>
  416854:	c7 44 24 50 00 00 00 	mov    DWORD PTR [rsp+0x50],0x0
  41685b:	00 
  41685c:	4c 8b 64 24 08       	mov    r12,QWORD PTR [rsp+0x8]
	if (a<z) for (i=10, e=9*(r-a); *a>=i; i*=10, e++);
  416861:	48 39 eb             	cmp    rbx,rbp
  416864:	0f 87 f3 08 00 00    	ja     41715d <fmt_fp+0xc0d>
  41686a:	8b 04 24             	mov    eax,DWORD PTR [rsp]
	else e=0;
  41686d:	31 ff                	xor    edi,edi
	j = p - ((t|32)!='f')*e - ((t|32)=='g' && p);
  41686f:	31 d2                	xor    edx,edx
  416871:	41 83 fe 67          	cmp    r14d,0x67
	if (j < 9*(z-r-1)) {
  416875:	48 8b 74 24 18       	mov    rsi,QWORD PTR [rsp+0x18]
	j = p - ((t|32)!='f')*e - ((t|32)=='g' && p);
  41687a:	0f 94 c2             	sete   dl
  41687d:	23 54 24 38          	and    edx,DWORD PTR [rsp+0x38]
  416881:	29 d0                	sub    eax,edx
	if (j < 9*(z-r-1)) {
  416883:	48 89 da             	mov    rdx,rbx
  416886:	48 29 f2             	sub    rdx,rsi
  416889:	48 63 c8             	movsxd rcx,eax
  41688c:	48 c1 fa 02          	sar    rdx,0x2
  416890:	48 8d 54 d2 f7       	lea    rdx,[rdx+rdx*8-0x9]
  416895:	48 39 d1             	cmp    rcx,rdx
  416898:	0f 8d 38 0a 00 00    	jge    4172d6 <fmt_fp+0xd86>
		uint32_t x;
		/* We avoid C's broken division of negative numbers */
		d = r + 1 + ((j+9*LDBL_MAX_EXP)/9 - LDBL_MAX_EXP);
  41689e:	05 00 40 02 00       	add    eax,0x24000
  4168a3:	48 63 d0             	movsxd rdx,eax
  4168a6:	89 c1                	mov    ecx,eax
  4168a8:	48 69 d2 39 8e e3 38 	imul   rdx,rdx,0x38e38e39
  4168af:	c1 f9 1f             	sar    ecx,0x1f
  4168b2:	48 c1 fa 21          	sar    rdx,0x21
  4168b6:	29 ca                	sub    edx,ecx
  4168b8:	48 63 ca             	movsxd rcx,edx
		j += 9*LDBL_MAX_EXP;
		j %= 9;
  4168bb:	8d 14 d2             	lea    edx,[rdx+rdx*8]
  4168be:	29 d0                	sub    eax,edx
		d = r + 1 + ((j+9*LDBL_MAX_EXP)/9 - LDBL_MAX_EXP);
  4168c0:	48 8d b4 8e 04 00 ff 	lea    rsi,[rsi+rcx*4-0xfffc]
  4168c7:	ff 
		for (i=10, j++; j<9; i*=10, j++);
  4168c8:	83 f8 08             	cmp    eax,0x8
  4168cb:	0f 84 10 1f 00 00    	je     4187e1 <fmt_fp+0x2291>
  4168d1:	ba 08 00 00 00       	mov    edx,0x8
  4168d6:	29 c2                	sub    edx,eax
  4168d8:	41 89 d0             	mov    r8d,edx
  4168db:	83 f8 07             	cmp    eax,0x7
  4168de:	0f 84 25 1f 00 00    	je     418809 <fmt_fp+0x22b9>
  4168e4:	89 d0                	mov    eax,edx
  4168e6:	d1 e8                	shr    eax,1
  4168e8:	83 f8 01             	cmp    eax,0x1
  4168eb:	0f 84 cf 08 00 00    	je     4171c0 <fmt_fp+0xc70>
  4168f1:	83 f8 02             	cmp    eax,0x2
  4168f4:	0f 84 da 1e 00 00    	je     4187d4 <fmt_fp+0x2284>
  4168fa:	83 f8 03             	cmp    eax,0x3
  4168fd:	0f 84 3c 1f 00 00    	je     41883f <fmt_fp+0x22ef>
  416903:	83 f8 04             	cmp    eax,0x4
  416906:	0f 84 40 1f 00 00    	je     41884c <fmt_fp+0x22fc>
  41690c:	83 f8 05             	cmp    eax,0x5
  41690f:	0f 84 68 1f 00 00    	je     41887d <fmt_fp+0x232d>
  416915:	83 f8 06             	cmp    eax,0x6
  416918:	0f 84 52 1f 00 00    	je     418870 <fmt_fp+0x2320>
  41691e:	f3 0f 7e 05 4a 7b 00 	movq   xmm0,QWORD PTR [rip+0x7b4a]        # 41e470 <states+0x230>
  416925:	00 
  416926:	b9 00 00 8a 5d       	mov    ecx,0x5d8a0000
  41692b:	83 f8 08             	cmp    eax,0x8
  41692e:	0f 85 94 08 00 00    	jne    4171c8 <fmt_fp+0xc78>
  416934:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		x = *d % i;
  416938:	41 89 ca             	mov    r10d,ecx
  41693b:	44 8b 0e             	mov    r9d,DWORD PTR [rsi]
  41693e:	31 d2                	xor    edx,edx
  416940:	44 89 c8             	mov    eax,r9d
  416943:	41 f7 f2             	div    r10d
  416946:	41 89 d0             	mov    r8d,edx
		/* Are there any significant digits past j? */
		if (x || d+1!=z) {
  416949:	85 d2                	test   edx,edx
  41694b:	0f 85 11 09 00 00    	jne    417262 <fmt_fp+0xd12>
  416951:	48 8d 56 04          	lea    rdx,[rsi+0x4]
  416955:	48 39 d3             	cmp    rbx,rdx
  416958:	0f 84 4d 1e 00 00    	je     4187ab <fmt_fp+0x225b>
			long double round = 2/LDBL_EPSILON;
			long double small;
			if ((*d/i & 1) || (i==1000000000 && d>a && (d[-1]&1)))
  41695e:	a8 01                	test   al,0x1
  416960:	0f 85 85 1d 00 00    	jne    4186eb <fmt_fp+0x219b>
  416966:	81 f9 00 ca 9a 3b    	cmp    ecx,0x3b9aca00
  41696c:	75 09                	jne    416977 <fmt_fp+0x427>
  41696e:	48 39 ee             	cmp    rsi,rbp
  416971:	0f 87 47 1d 00 00    	ja     4186be <fmt_fp+0x216e>
  416977:	d9 05 d3 7a 00 00    	fld    DWORD PTR [rip+0x7ad3]        # 41e450 <states+0x210>
				round += 2;
			if (x<i/2) small=0x0.8p0;
  41697d:	d9 05 d1 7a 00 00    	fld    DWORD PTR [rip+0x7ad1]        # 41e454 <states+0x214>
			long double round = 2/LDBL_EPSILON;
  416983:	d9 05 c3 7a 00 00    	fld    DWORD PTR [rip+0x7ac3]        # 41e44c <states+0x20c>
  416989:	d9 ca                	fxch   st(2)
  41698b:	d9 c9                	fxch   st(1)
  41698d:	e9 fb 08 00 00       	jmp    41728d <fmt_fp+0xd3d>
  416992:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	} else if (fl & MARK_POS) {
  416998:	8b 5c 24 14          	mov    ebx,DWORD PTR [rsp+0x14]
  41699c:	f6 c7 08             	test   bh,0x8
  41699f:	0f 84 70 05 00 00    	je     416f15 <fmt_fp+0x9c5>
  4169a5:	bd 03 00 00 00       	mov    ebp,0x3
  4169aa:	bb 03 00 00 00       	mov    ebx,0x3
		prefix+=3;
  4169af:	48 8d 05 45 77 00 00 	lea    rax,[rip+0x7745]        # 41e0fb <CSWTCH.186+0x7ab>
  4169b6:	48 c7 44 24 30 01 00 	mov    QWORD PTR [rsp+0x30],0x1
  4169bd:	00 00 
	pl=1;
  4169bf:	c7 44 24 28 01 00 00 	mov    DWORD PTR [rsp+0x28],0x1
  4169c6:	00 
  4169c7:	41 bd 04 00 00 00    	mov    r13d,0x4
		prefix+=3;
  4169cd:	48 89 44 24 20       	mov    QWORD PTR [rsp+0x20],rax
  4169d2:	e9 09 fc ff ff       	jmp    4165e0 <fmt_fp+0x90>
  4169d7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  4169de:	00 00 
	if (y) e2--;
  4169e0:	8b 44 24 50          	mov    eax,DWORD PTR [rsp+0x50]
	if ((t|32)=='a') {
  4169e4:	45 89 fe             	mov    r14d,r15d
  4169e7:	41 83 ce 20          	or     r14d,0x20
	if (y) e2--;
  4169eb:	44 8d 48 ff          	lea    r9d,[rax-0x1]
  4169ef:	44 89 4c 24 50       	mov    DWORD PTR [rsp+0x50],r9d
	if ((t|32)=='a') {
  4169f4:	41 83 fe 61          	cmp    r14d,0x61
  4169f8:	0f 85 4c fc ff ff    	jne    41664a <fmt_fp+0xfa>
		if (t&32) prefix += 9;
  4169fe:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
  416a03:	41 f6 c7 20          	test   r15b,0x20
  416a07:	48 8d 41 09          	lea    rax,[rcx+0x9]
  416a0b:	48 0f 44 c1          	cmove  rax,rcx
  416a0f:	48 89 44 24 20       	mov    QWORD PTR [rsp+0x20],rax
		if (p<0 || p>=LDBL_MANT_DIG/4-1) re=0;
  416a14:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  416a17:	83 f8 0e             	cmp    eax,0xe
  416a1a:	0f 87 93 00 00 00    	ja     416ab3 <fmt_fp+0x563>
			while (re--) round*=16;
  416a20:	0f 84 3f 1e 00 00    	je     418865 <fmt_fp+0x2315>
  416a26:	83 f8 0d             	cmp    eax,0xd
  416a29:	0f 84 70 1e 00 00    	je     41889f <fmt_fp+0x234f>
  416a2f:	83 f8 0c             	cmp    eax,0xc
  416a32:	0f 84 a1 1e 00 00    	je     4188d9 <fmt_fp+0x2389>
  416a38:	83 f8 0b             	cmp    eax,0xb
  416a3b:	0f 84 8d 1e 00 00    	je     4188ce <fmt_fp+0x237e>
  416a41:	83 f8 0a             	cmp    eax,0xa
  416a44:	0f 84 9a 1e 00 00    	je     4188e4 <fmt_fp+0x2394>
  416a4a:	83 f8 09             	cmp    eax,0x9
  416a4d:	0f 84 bb 1c 00 00    	je     41870e <fmt_fp+0x21be>
  416a53:	83 f8 08             	cmp    eax,0x8
  416a56:	0f 84 9e 1e 00 00    	je     4188fa <fmt_fp+0x23aa>
  416a5c:	83 f8 07             	cmp    eax,0x7
  416a5f:	0f 84 8a 1e 00 00    	je     4188ef <fmt_fp+0x239f>
  416a65:	83 f8 06             	cmp    eax,0x6
  416a68:	0f 84 a9 1e 00 00    	je     418917 <fmt_fp+0x23c7>
  416a6e:	83 f8 05             	cmp    eax,0x5
  416a71:	0f 84 95 1e 00 00    	je     41890c <fmt_fp+0x23bc>
  416a77:	83 f8 04             	cmp    eax,0x4
  416a7a:	0f 84 c3 1e 00 00    	je     418943 <fmt_fp+0x23f3>
  416a80:	83 f8 03             	cmp    eax,0x3
  416a83:	0f 84 af 1e 00 00    	je     418938 <fmt_fp+0x23e8>
  416a89:	83 f8 02             	cmp    eax,0x2
  416a8c:	0f 84 9b 1e 00 00    	je     41892d <fmt_fp+0x23dd>
  416a92:	83 f8 01             	cmp    eax,0x1
  416a95:	0f 84 87 1e 00 00    	je     418922 <fmt_fp+0x23d2>
  416a9b:	d9 05 6f 79 00 00    	fld    DWORD PTR [rip+0x796f]        # 41e410 <states+0x1d0>
			if (*prefix=='-') {
  416aa1:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  416aa6:	80 38 2d             	cmp    BYTE PTR [rax],0x2d
  416aa9:	0f 84 c0 1c 00 00    	je     41876f <fmt_fp+0x221f>
				y+=round;
  416aaf:	dc c2                	fadd   st(2),st
				y-=round;
  416ab1:	de ea                	fsubp  st(2),st
		estr=fmt_u(e2<0 ? -e2 : e2, ebuf);
  416ab3:	44 89 c9             	mov    ecx,r9d
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  416ab6:	4c 8d 6c 24 60       	lea    r13,[rsp+0x60]
  416abb:	48 bf cd cc cc cc cc 	movabs rdi,0xcccccccccccccccd
  416ac2:	cc cc cc 
		estr=fmt_u(e2<0 ? -e2 : e2, ebuf);
  416ac5:	f7 d9                	neg    ecx
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  416ac7:	4c 89 ee             	mov    rsi,r13
		estr=fmt_u(e2<0 ? -e2 : e2, ebuf);
  416aca:	41 0f 48 c9          	cmovs  ecx,r9d
  416ace:	48 63 c9             	movsxd rcx,ecx
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  416ad1:	45 85 c9             	test   r9d,r9d
  416ad4:	0f 84 a1 1b 00 00    	je     41867b <fmt_fp+0x212b>
  416ada:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  416ae0:	48 89 c8             	mov    rax,rcx
  416ae3:	48 83 ee 01          	sub    rsi,0x1
  416ae7:	48 f7 e7             	mul    rdi
  416aea:	48 89 c8             	mov    rax,rcx
  416aed:	48 c1 ea 03          	shr    rdx,0x3
  416af1:	4c 8d 04 92          	lea    r8,[rdx+rdx*4]
  416af5:	4d 01 c0             	add    r8,r8
  416af8:	4c 29 c0             	sub    rax,r8
  416afb:	83 c0 30             	add    eax,0x30
  416afe:	88 06                	mov    BYTE PTR [rsi],al
  416b00:	48 89 c8             	mov    rax,rcx
  416b03:	48 89 d1             	mov    rcx,rdx
  416b06:	48 83 f8 09          	cmp    rax,0x9
  416b0a:	77 d4                	ja     416ae0 <fmt_fp+0x590>
		if (estr==ebuf) *--estr='0';
  416b0c:	4c 39 ee             	cmp    rsi,r13
  416b0f:	0f 84 66 1b 00 00    	je     41867b <fmt_fp+0x212b>
		*--estr = (e2<0 ? '-' : '+');
  416b15:	41 c1 f9 1f          	sar    r9d,0x1f
		*--estr = t+('p'-'a');
  416b19:	48 8d 46 fe          	lea    rax,[rsi-0x2]
		*--estr = (e2<0 ? '-' : '+');
  416b1d:	41 83 e1 02          	and    r9d,0x2
		*--estr = t+('p'-'a');
  416b21:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  416b26:	41 8d 47 0f          	lea    eax,[r15+0xf]
		*--estr = (e2<0 ? '-' : '+');
  416b2a:	41 83 c1 2b          	add    r9d,0x2b
		*--estr = t+('p'-'a');
  416b2e:	88 46 fe             	mov    BYTE PTR [rsi-0x2],al
		*--estr = (e2<0 ? '-' : '+');
  416b31:	44 88 4e ff          	mov    BYTE PTR [rsi-0x1],r9b
			*s++=xdigits[x]|(t&32);
  416b35:	44 89 fe             	mov    esi,r15d
  416b38:	83 e6 20             	and    esi,0x20
  416b3b:	f6 44 24 14 08       	test   BYTE PTR [rsp+0x14],0x8
  416b40:	0f 85 f3 15 00 00    	jne    418139 <fmt_fp+0x1be9>
  416b46:	d9 7c 24 4e          	fnstcw WORD PTR [rsp+0x4e]
  416b4a:	d9 05 10 79 00 00    	fld    DWORD PTR [rip+0x7910]        # 41e460 <states+0x220>
  416b50:	d9 ca                	fxch   st(2)
		s=buf;
  416b52:	4c 89 ea             	mov    rdx,r13
			if (s-buf==1 && (y||p>0||(fl&ALT_FORM))) *s++='.';
  416b55:	bf 01 00 00 00       	mov    edi,0x1
  416b5a:	48 8d 0d cf 76 00 00 	lea    rcx,[rip+0x76cf]        # 41e230 <xdigits>
  416b61:	0f b7 44 24 4e       	movzx  eax,WORD PTR [rsp+0x4e]
  416b66:	80 cc 0c             	or     ah,0xc
  416b69:	66 89 44 24 4c       	mov    WORD PTR [rsp+0x4c],ax
  416b6e:	eb 13                	jmp    416b83 <fmt_fp+0x633>
			*s++=xdigits[x]|(t&32);
  416b70:	48 89 c2             	mov    rdx,rax
		} while (y);
  416b73:	d9 c1                	fld    st(1)
  416b75:	d9 c9                	fxch   st(1)
  416b77:	db e9                	fucomi st,st(1)
  416b79:	dd d9                	fstp   st(1)
  416b7b:	7a 06                	jp     416b83 <fmt_fp+0x633>
  416b7d:	0f 84 43 1c 00 00    	je     4187c6 <fmt_fp+0x2276>
			int x=y;
  416b83:	d9 c0                	fld    st(0)
  416b85:	d9 6c 24 4c          	fldcw  WORD PTR [rsp+0x4c]
  416b89:	db 5c 24 08          	fistp  DWORD PTR [rsp+0x8]
  416b8d:	d9 6c 24 4e          	fldcw  WORD PTR [rsp+0x4e]
			y=16*(y-x);
  416b91:	db 44 24 08          	fild   DWORD PTR [rsp+0x8]
			*s++=xdigits[x]|(t&32);
  416b95:	48 63 44 24 08       	movsxd rax,DWORD PTR [rsp+0x8]
  416b9a:	44 0f b6 1c 01       	movzx  r11d,BYTE PTR [rcx+rax*1]
			if (s-buf==1 && (y||p>0||(fl&ALT_FORM))) *s++='.';
  416b9f:	48 8d 42 01          	lea    rax,[rdx+0x1]
			y=16*(y-x);
  416ba3:	de e9                	fsubp  st(1),st
			*s++=xdigits[x]|(t&32);
  416ba5:	41 09 f3             	or     r11d,esi
  416ba8:	44 88 1a             	mov    BYTE PTR [rdx],r11b
			y=16*(y-x);
  416bab:	d8 ca                	fmul   st,st(2)
			if (s-buf==1 && (y||p>0||(fl&ALT_FORM))) *s++='.';
  416bad:	4c 39 ea             	cmp    rdx,r13
  416bb0:	75 be                	jne    416b70 <fmt_fp+0x620>
  416bb2:	44 8b 04 24          	mov    r8d,DWORD PTR [rsp]
  416bb6:	45 85 c0             	test   r8d,r8d
  416bb9:	0f 8f df 0e 00 00    	jg     417a9e <fmt_fp+0x154e>
  416bbf:	d9 c1                	fld    st(1)
  416bc1:	df e9                	fucomip st,st(1)
  416bc3:	41 0f 9a c0          	setp   r8b
  416bc7:	44 0f 45 c7          	cmovne r8d,edi
  416bcb:	45 84 c0             	test   r8b,r8b
  416bce:	0f 85 ca 0e 00 00    	jne    417a9e <fmt_fp+0x154e>
  416bd4:	dd d8                	fstp   st(0)
  416bd6:	dd d8                	fstp   st(0)
  416bd8:	dd d8                	fstp   st(0)
  416bda:	eb 06                	jmp    416be2 <fmt_fp+0x692>
  416bdc:	dd d8                	fstp   st(0)
  416bde:	dd d8                	fstp   st(0)
  416be0:	dd d8                	fstp   st(0)
		if (p > INT_MAX-2-(ebuf-estr)-pl)
  416be2:	4c 89 ef             	mov    rdi,r13
  416be5:	ba fd ff ff 7f       	mov    edx,0x7ffffffd
  416bea:	48 2b 7c 24 28       	sub    rdi,QWORD PTR [rsp+0x28]
  416bef:	48 63 0c 24          	movsxd rcx,DWORD PTR [rsp]
  416bf3:	48 29 fa             	sub    rdx,rdi
  416bf6:	48 89 7c 24 18       	mov    QWORD PTR [rsp+0x18],rdi
  416bfb:	48 29 ea             	sub    rdx,rbp
  416bfe:	48 39 d1             	cmp    rcx,rdx
  416c01:	0f 8f 86 0f 00 00    	jg     417b8d <fmt_fp+0x163d>
		if (p && s-buf-2 < p)
  416c07:	4c 29 e8             	sub    rax,r13
  416c0a:	49 89 fb             	mov    r11,rdi
  416c0d:	8b 34 24             	mov    esi,DWORD PTR [rsp]
  416c10:	48 89 c7             	mov    rdi,rax
  416c13:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
			l = (s-buf) + (ebuf-estr);
  416c18:	44 89 d8             	mov    eax,r11d
  416c1b:	01 f8                	add    eax,edi
		if (p && s-buf-2 < p)
  416c1d:	85 f6                	test   esi,esi
  416c1f:	74 0d                	je     416c2e <fmt_fp+0x6de>
  416c21:	48 8d 57 ff          	lea    rdx,[rdi-0x1]
  416c25:	48 39 d1             	cmp    rcx,rdx
  416c28:	0f 8d a5 1a 00 00    	jge    4186d3 <fmt_fp+0x2183>
			l = (s-buf) + (ebuf-estr);
  416c2e:	c7 44 24 30 00 00 00 	mov    DWORD PTR [rsp+0x30],0x0
  416c35:	00 
  416c36:	31 ed                	xor    ebp,ebp
		pad(f, ' ', w, pl+l, fl);
  416c38:	44 8d 34 18          	lea    r14d,[rax+rbx*1]
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  416c3c:	44 3b 74 24 48       	cmp    r14d,DWORD PTR [rsp+0x48]
  416c41:	0f 9d 04 24          	setge  BYTE PTR [rsp]
  416c45:	0f b6 04 24          	movzx  eax,BYTE PTR [rsp]
  416c49:	f7 44 24 14 00 20 01 	test   DWORD PTR [rsp+0x14],0x12000
  416c50:	00 
  416c51:	0f 85 b5 00 00 00    	jne    416d0c <fmt_fp+0x7bc>
  416c57:	84 c0                	test   al,al
  416c59:	0f 85 ad 00 00 00    	jne    416d0c <fmt_fp+0x7bc>
	l = w - l;
  416c5f:	44 8b 44 24 48       	mov    r8d,DWORD PTR [rsp+0x48]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  416c64:	b8 00 01 00 00       	mov    eax,0x100
  416c69:	be 20 00 00 00       	mov    esi,0x20
  416c6e:	4c 8d bc 24 80 01 00 	lea    r15,[rsp+0x180]
  416c75:	00 
  416c76:	4c 89 ff             	mov    rdi,r15
	l = w - l;
  416c79:	45 29 f0             	sub    r8d,r14d
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  416c7c:	41 39 c0             	cmp    r8d,eax
  416c7f:	44 89 44 24 08       	mov    DWORD PTR [rsp+0x8],r8d
  416c84:	41 0f 4e c0          	cmovle eax,r8d
  416c88:	48 63 d0             	movsxd rdx,eax
  416c8b:	e8 fc e0 ff ff       	call   414d8c <memset>
	for (; l >= sizeof pad; l -= sizeof pad)
  416c90:	44 8b 44 24 08       	mov    r8d,DWORD PTR [rsp+0x8]
  416c95:	41 81 f8 ff 00 00 00 	cmp    r8d,0xff
  416c9c:	0f 8e 08 1c 00 00    	jle    4188aa <fmt_fp+0x235a>
  416ca2:	41 8d 88 00 ff ff ff 	lea    ecx,[r8-0x100]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  416ca9:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  416cad:	4c 89 6c 24 08       	mov    QWORD PTR [rsp+0x8],r13
  416cb2:	41 89 dd             	mov    r13d,ebx
  416cb5:	89 cb                	mov    ebx,ecx
  416cb7:	83 e0 20             	and    eax,0x20
  416cba:	89 c2                	mov    edx,eax
  416cbc:	0f 84 e9 0d 00 00    	je     417aab <fmt_fp+0x155b>
	for (; l >= sizeof pad; l -= sizeof pad)
  416cc2:	89 d9                	mov    ecx,ebx
  416cc4:	44 89 eb             	mov    ebx,r13d
  416cc7:	4c 8b 6c 24 08       	mov    r13,QWORD PTR [rsp+0x8]
  416ccc:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  416cd2:	7e 3f                	jle    416d13 <fmt_fp+0x7c3>
  416cd4:	8d 81 00 e9 ff ff    	lea    eax,[rcx-0x1700]
  416cda:	3d 00 e9 ff 7f       	cmp    eax,0x7fffe900
  416cdf:	0f 86 de f5 ff ff    	jbe    4162c3 <fmt_fp.cold+0x30a>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  416ce5:	89 d0                	mov    eax,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  416ce7:	81 e9 00 01 00 00    	sub    ecx,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  416ced:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  416cef:	41 89 c8             	mov    r8d,ecx
  416cf2:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  416cf8:	77 ed                	ja     416ce7 <fmt_fp+0x797>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  416cfa:	85 d2                	test   edx,edx
  416cfc:	75 1d                	jne    416d1b <fmt_fp+0x7cb>
	out(f, pad, l);
  416cfe:	49 63 f0             	movsxd rsi,r8d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  416d01:	4c 89 e2             	mov    rdx,r12
  416d04:	4c 89 ff             	mov    rdi,r15
  416d07:	e8 44 3b 00 00       	call   41a850 <__fwritex>
  416d0c:	41 8b 14 24          	mov    edx,DWORD PTR [r12]
  416d10:	83 e2 20             	and    edx,0x20
  416d13:	85 d2                	test   edx,edx
  416d15:	0f 84 46 15 00 00    	je     418261 <fmt_fp+0x1d11>
		pad(f, '0', w, pl+l, fl^ZERO_PAD);
  416d1b:	8b 44 24 14          	mov    eax,DWORD PTR [rsp+0x14]
  416d1f:	35 00 00 01 00       	xor    eax,0x10000
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  416d24:	a9 00 20 01 00       	test   eax,0x12000
  416d29:	0f 85 b9 0e 00 00    	jne    417be8 <fmt_fp+0x1698>
  416d2f:	80 3c 24 00          	cmp    BYTE PTR [rsp],0x0
  416d33:	0f 85 af 0e 00 00    	jne    417be8 <fmt_fp+0x1698>
	l = w - l;
  416d39:	8b 4c 24 48          	mov    ecx,DWORD PTR [rsp+0x48]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  416d3d:	b8 00 01 00 00       	mov    eax,0x100
  416d42:	be 30 00 00 00       	mov    esi,0x30
  416d47:	4c 8d bc 24 80 01 00 	lea    r15,[rsp+0x180]
  416d4e:	00 
  416d4f:	4c 89 ff             	mov    rdi,r15
	l = w - l;
  416d52:	44 29 f1             	sub    ecx,r14d
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  416d55:	39 c1                	cmp    ecx,eax
  416d57:	89 4c 24 08          	mov    DWORD PTR [rsp+0x8],ecx
  416d5b:	0f 4e c1             	cmovle eax,ecx
  416d5e:	48 63 d0             	movsxd rdx,eax
  416d61:	e8 26 e0 ff ff       	call   414d8c <memset>
	for (; l >= sizeof pad; l -= sizeof pad)
  416d66:	8b 4c 24 08          	mov    ecx,DWORD PTR [rsp+0x8]
  416d6a:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  416d70:	0f 8e 14 1b 00 00    	jle    41888a <fmt_fp+0x233a>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  416d76:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  416d7a:	8d 99 00 ff ff ff    	lea    ebx,[rcx-0x100]
  416d80:	83 e0 20             	and    eax,0x20
  416d83:	89 c2                	mov    edx,eax
  416d85:	0f 84 85 0d 00 00    	je     417b10 <fmt_fp+0x15c0>
	for (; l >= sizeof pad; l -= sizeof pad)
  416d8b:	81 fb ff 00 00 00    	cmp    ebx,0xff
  416d91:	0f 8e 58 0e 00 00    	jle    417bef <fmt_fp+0x169f>
  416d97:	8d 83 00 e9 ff ff    	lea    eax,[rbx-0x1700]
  416d9d:	3d 00 e9 ff 7f       	cmp    eax,0x7fffe900
  416da2:	0f 86 11 f2 ff ff    	jbe    415fb9 <fmt_fp.cold>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  416da8:	89 d0                	mov    eax,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  416daa:	81 eb 00 01 00 00    	sub    ebx,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  416db0:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  416db2:	89 d9                	mov    ecx,ebx
  416db4:	81 fb ff 00 00 00    	cmp    ebx,0xff
  416dba:	77 ee                	ja     416daa <fmt_fp+0x85a>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  416dbc:	85 d2                	test   edx,edx
  416dbe:	0f 84 16 0e 00 00    	je     417bda <fmt_fp+0x168a>
	for (; l >= sizeof pad; l -= sizeof pad)
  416dc4:	89 eb                	mov    ebx,ebp
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  416dc6:	85 ed                	test   ebp,ebp
  416dc8:	0f 8e a3 00 00 00    	jle    416e71 <fmt_fp+0x921>
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  416dce:	81 7c 24 30 01 01 00 	cmp    DWORD PTR [rsp+0x30],0x101
  416dd5:	00 
  416dd6:	ba 00 01 00 00       	mov    edx,0x100
  416ddb:	be 30 00 00 00       	mov    esi,0x30
  416de0:	48 0f 42 d5          	cmovb  rdx,rbp
  416de4:	4c 8d bc 24 80 01 00 	lea    r15,[rsp+0x180]
  416deb:	00 
  416dec:	4c 89 ff             	mov    rdi,r15
  416def:	e8 98 df ff ff       	call   414d8c <memset>
	for (; l >= sizeof pad; l -= sizeof pad)
  416df4:	81 fd ff 00 00 00    	cmp    ebp,0xff
  416dfa:	0f 8e 59 1a 00 00    	jle    418859 <fmt_fp+0x2309>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  416e00:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  416e04:	81 eb 00 01 00 00    	sub    ebx,0x100
  416e0a:	83 e0 20             	and    eax,0x20
  416e0d:	89 c2                	mov    edx,eax
  416e0f:	0f 84 c9 0c 00 00    	je     417ade <fmt_fp+0x158e>
	for (; l >= sizeof pad; l -= sizeof pad)
  416e15:	81 fb ff 00 00 00    	cmp    ebx,0xff
  416e1b:	7e 3e                	jle    416e5b <fmt_fp+0x90b>
  416e1d:	8d 83 00 e9 ff ff    	lea    eax,[rbx-0x1700]
  416e23:	3d 00 e9 ff 7f       	cmp    eax,0x7fffe900
  416e28:	0f 86 2a f2 ff ff    	jbe    416058 <fmt_fp.cold+0x9f>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  416e2e:	89 d0                	mov    eax,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  416e30:	81 eb 00 01 00 00    	sub    ebx,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  416e36:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  416e38:	89 dd                	mov    ebp,ebx
  416e3a:	81 fb ff 00 00 00    	cmp    ebx,0xff
  416e40:	77 ee                	ja     416e30 <fmt_fp+0x8e0>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  416e42:	85 d2                	test   edx,edx
  416e44:	75 2b                	jne    416e71 <fmt_fp+0x921>
	out(f, pad, l);
  416e46:	48 63 f5             	movsxd rsi,ebp
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  416e49:	4c 89 e2             	mov    rdx,r12
  416e4c:	4c 89 ff             	mov    rdi,r15
  416e4f:	e8 fc 39 00 00       	call   41a850 <__fwritex>
  416e54:	41 8b 14 24          	mov    edx,DWORD PTR [r12]
  416e58:	83 e2 20             	and    edx,0x20
  416e5b:	85 d2                	test   edx,edx
  416e5d:	75 12                	jne    416e71 <fmt_fp+0x921>
  416e5f:	48 8b 74 24 18       	mov    rsi,QWORD PTR [rsp+0x18]
  416e64:	48 8b 7c 24 28       	mov    rdi,QWORD PTR [rsp+0x28]
  416e69:	4c 89 e2             	mov    rdx,r12
  416e6c:	e8 df 39 00 00       	call   41a850 <__fwritex>
		pad(f, ' ', w, pl+l, fl^LEFT_ADJ);
  416e71:	8b 44 24 14          	mov    eax,DWORD PTR [rsp+0x14]
  416e75:	80 f4 20             	xor    ah,0x20
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  416e78:	a9 00 20 01 00       	test   eax,0x12000
  416e7d:	0f 85 82 00 00 00    	jne    416f05 <fmt_fp+0x9b5>
  416e83:	80 3c 24 00          	cmp    BYTE PTR [rsp],0x0
  416e87:	75 7c                	jne    416f05 <fmt_fp+0x9b5>
	l = w - l;
  416e89:	8b 6c 24 48          	mov    ebp,DWORD PTR [rsp+0x48]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  416e8d:	b8 00 01 00 00       	mov    eax,0x100
  416e92:	be 20 00 00 00       	mov    esi,0x20
  416e97:	4c 8d bc 24 80 01 00 	lea    r15,[rsp+0x180]
  416e9e:	00 
  416e9f:	4c 89 ff             	mov    rdi,r15
	l = w - l;
  416ea2:	44 29 f5             	sub    ebp,r14d
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  416ea5:	39 c5                	cmp    ebp,eax
  416ea7:	0f 4e c5             	cmovle eax,ebp
  416eaa:	48 63 d0             	movsxd rdx,eax
  416ead:	e8 da de ff ff       	call   414d8c <memset>
	for (; l >= sizeof pad; l -= sizeof pad)
  416eb2:	81 fd ff 00 00 00    	cmp    ebp,0xff
  416eb8:	0f 8e f8 19 00 00    	jle    4188b6 <fmt_fp+0x2366>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  416ebe:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  416ec2:	8d 9d 00 ff ff ff    	lea    ebx,[rbp-0x100]
  416ec8:	83 e0 20             	and    eax,0x20
  416ecb:	0f 84 71 0c 00 00    	je     417b42 <fmt_fp+0x15f2>
	for (; l >= sizeof pad; l -= sizeof pad)
  416ed1:	81 fb ff 00 00 00    	cmp    ebx,0xff
  416ed7:	7e 2c                	jle    416f05 <fmt_fp+0x9b5>
  416ed9:	8d 93 00 e9 ff ff    	lea    edx,[rbx-0x1700]
  416edf:	81 fa 00 e9 ff 7f    	cmp    edx,0x7fffe900
  416ee5:	0f 86 0c f2 ff ff    	jbe    4160f7 <fmt_fp.cold+0x13e>
  416eeb:	81 eb 00 01 00 00    	sub    ebx,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  416ef1:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  416ef3:	89 dd                	mov    ebp,ebx
  416ef5:	81 fb ff 00 00 00    	cmp    ebx,0xff
  416efb:	77 ee                	ja     416eeb <fmt_fp+0x99b>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  416efd:	85 d2                	test   edx,edx
  416eff:	0f 84 ae 18 00 00    	je     4187b3 <fmt_fp+0x2263>
		return MAX(w, pl+l);
  416f05:	8b 44 24 48          	mov    eax,DWORD PTR [rsp+0x48]
  416f09:	41 39 c6             	cmp    r14d,eax
  416f0c:	41 0f 4d c6          	cmovge eax,r14d
  416f10:	e9 36 02 00 00       	jmp    41714b <fmt_fp+0xbfb>
	} else if (fl & PAD_POS) {
  416f15:	89 d8                	mov    eax,ebx
  416f17:	89 d9                	mov    ecx,ebx
  416f19:	48 8d 15 de 71 00 00 	lea    rdx,[rip+0x71de]        # 41e0fe <CSWTCH.186+0x7ae>
  416f20:	83 e0 01             	and    eax,0x1
  416f23:	83 e1 01             	and    ecx,0x1
  416f26:	83 f8 01             	cmp    eax,0x1
  416f29:	48 89 4c 24 30       	mov    QWORD PTR [rsp+0x30],rcx
  416f2e:	48 19 ed             	sbb    rbp,rbp
  416f31:	48 83 c5 03          	add    rbp,0x3
  416f35:	83 f8 01             	cmp    eax,0x1
  416f38:	19 db                	sbb    ebx,ebx
  416f3a:	83 c3 03             	add    ebx,0x3
  416f3d:	83 f8 01             	cmp    eax,0x1
  416f40:	45 19 ed             	sbb    r13d,r13d
  416f43:	41 83 c5 04          	add    r13d,0x4
  416f47:	85 c0                	test   eax,eax
  416f49:	48 8d 42 fb          	lea    rax,[rdx-0x5]
  416f4d:	48 0f 45 c2          	cmovne rax,rdx
  416f51:	48 89 44 24 20       	mov    QWORD PTR [rsp+0x20],rax
  416f56:	0f 95 c0             	setne  al
  416f59:	0f b6 c0             	movzx  eax,al
  416f5c:	89 44 24 28          	mov    DWORD PTR [rsp+0x28],eax
  416f60:	e9 7b f6 ff ff       	jmp    4165e0 <fmt_fp+0x90>
  416f65:	0f 1f 00             	nop    DWORD PTR [rax]
		int sh=MIN(9,-e2), need=1+(p+LDBL_MANT_DIG/3U+8)/9;
  416f68:	44 89 c9             	mov    ecx,r9d
		if (!*a) a++;
  416f6b:	8b 45 00             	mov    eax,DWORD PTR [rbp+0x0]
  416f6e:	45 31 c9             	xor    r9d,r9d
		int sh=MIN(9,-e2), need=1+(p+LDBL_MANT_DIG/3U+8)/9;
  416f71:	f7 d9                	neg    ecx
		for (d=a; d<z; d++) {
  416f73:	48 39 dd             	cmp    rbp,rbx
  416f76:	0f 82 5b f8 ff ff    	jb     4167d7 <fmt_fp+0x287>
		if (!*a) a++;
  416f7c:	48 8d 55 04          	lea    rdx,[rbp+0x4]
  416f80:	85 c0                	test   eax,eax
  416f82:	48 0f 44 ea          	cmove  rbp,rdx
  416f86:	e9 a1 f8 ff ff       	jmp    41682c <fmt_fp+0x2dc>
  416f8b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		if (y!=y) s=(t&32)?"nan":"NAN";
  416f90:	db ac 24 70 1e 00 00 	fld    TBYTE PTR [rsp+0x1e70]
		char *s = (t&32)?"inf":"INF";
  416f97:	44 89 fa             	mov    edx,r15d
  416f9a:	48 8d 2d 6a 71 00 00 	lea    rbp,[rip+0x716a]        # 41e10b <CSWTCH.186+0x7bb>
  416fa1:	83 e2 20             	and    edx,0x20
  416fa4:	48 8d 05 64 71 00 00 	lea    rax,[rip+0x7164]        # 41e10f <CSWTCH.186+0x7bf>
  416fab:	48 0f 44 e8          	cmove  rbp,rax
		if (y!=y) s=(t&32)?"nan":"NAN";
  416faf:	df e8                	fucomip st,st(0)
  416fb1:	7b 14                	jnp    416fc7 <fmt_fp+0xa77>
  416fb3:	85 d2                	test   edx,edx
  416fb5:	48 8d 2d 5b 71 00 00 	lea    rbp,[rip+0x715b]        # 41e117 <CSWTCH.186+0x7c7>
  416fbc:	48 8d 05 50 71 00 00 	lea    rax,[rip+0x7150]        # 41e113 <CSWTCH.186+0x7c3>
  416fc3:	48 0f 44 e8          	cmove  rbp,rax
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  416fc7:	44 39 6c 24 48       	cmp    DWORD PTR [rsp+0x48],r13d
  416fcc:	0f 9e c3             	setle  bl
  416fcf:	f7 44 24 14 00 20 00 	test   DWORD PTR [rsp+0x14],0x2000
  416fd6:	00 
  416fd7:	0f 85 aa 00 00 00    	jne    417087 <fmt_fp+0xb37>
  416fdd:	84 db                	test   bl,bl
  416fdf:	0f 85 a2 00 00 00    	jne    417087 <fmt_fp+0xb37>
	l = w - l;
  416fe5:	44 8b 4c 24 48       	mov    r9d,DWORD PTR [rsp+0x48]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  416fea:	b8 00 01 00 00       	mov    eax,0x100
  416fef:	be 20 00 00 00       	mov    esi,0x20
  416ff4:	4c 8d bc 24 80 01 00 	lea    r15,[rsp+0x180]
  416ffb:	00 
  416ffc:	4c 89 ff             	mov    rdi,r15
	l = w - l;
  416fff:	45 29 e9             	sub    r9d,r13d
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  417002:	41 39 c1             	cmp    r9d,eax
  417005:	44 89 0c 24          	mov    DWORD PTR [rsp],r9d
  417009:	41 0f 4e c1          	cmovle eax,r9d
  41700d:	48 63 d0             	movsxd rdx,eax
  417010:	e8 77 dd ff ff       	call   414d8c <memset>
	for (; l >= sizeof pad; l -= sizeof pad)
  417015:	44 8b 0c 24          	mov    r9d,DWORD PTR [rsp]
  417019:	41 81 f9 ff 00 00 00 	cmp    r9d,0xff
  417020:	0f 8e cb 17 00 00    	jle    4187f1 <fmt_fp+0x22a1>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417026:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  41702a:	45 8d b1 00 ff ff ff 	lea    r14d,[r9-0x100]
  417031:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  417038:	83 e0 20             	and    eax,0x20
  41703b:	89 c2                	mov    edx,eax
  41703d:	0f 84 b5 01 00 00    	je     4171f8 <fmt_fp+0xca8>
	for (; l >= sizeof pad; l -= sizeof pad)
  417043:	41 81 fe ff 00 00 00 	cmp    r14d,0xff
  41704a:	7e 42                	jle    41708e <fmt_fp+0xb3e>
  41704c:	41 8d 86 00 e9 ff ff 	lea    eax,[r14-0x1700]
  417053:	3d 00 e9 ff 7f       	cmp    eax,0x7fffe900
  417058:	0f 86 09 f3 ff ff    	jbe    416367 <fmt_fp.cold+0x3ae>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41705e:	89 d0                	mov    eax,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  417060:	41 81 ee 00 01 00 00 	sub    r14d,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417067:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  417069:	45 89 f1             	mov    r9d,r14d
  41706c:	41 81 fe ff 00 00 00 	cmp    r14d,0xff
  417073:	77 eb                	ja     417060 <fmt_fp+0xb10>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417075:	85 d2                	test   edx,edx
  417077:	75 1d                	jne    417096 <fmt_fp+0xb46>
	out(f, pad, l);
  417079:	49 63 f1             	movsxd rsi,r9d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41707c:	4c 89 e2             	mov    rdx,r12
  41707f:	4c 89 ff             	mov    rdi,r15
  417082:	e8 c9 37 00 00       	call   41a850 <__fwritex>
  417087:	41 8b 14 24          	mov    edx,DWORD PTR [r12]
  41708b:	83 e2 20             	and    edx,0x20
  41708e:	85 d2                	test   edx,edx
  417090:	0f 84 12 0b 00 00    	je     417ba8 <fmt_fp+0x1658>
		pad(f, ' ', w, 3+pl, fl^LEFT_ADJ);
  417096:	8b 44 24 14          	mov    eax,DWORD PTR [rsp+0x14]
  41709a:	80 f4 20             	xor    ah,0x20
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41709d:	a9 00 20 01 00       	test   eax,0x12000
  4170a2:	0f 85 98 00 00 00    	jne    417140 <fmt_fp+0xbf0>
  4170a8:	84 db                	test   bl,bl
  4170aa:	0f 85 90 00 00 00    	jne    417140 <fmt_fp+0xbf0>
	l = w - l;
  4170b0:	8b 6c 24 48          	mov    ebp,DWORD PTR [rsp+0x48]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  4170b4:	b8 00 01 00 00       	mov    eax,0x100
  4170b9:	be 20 00 00 00       	mov    esi,0x20
  4170be:	4c 8d bc 24 80 01 00 	lea    r15,[rsp+0x180]
  4170c5:	00 
  4170c6:	4c 89 ff             	mov    rdi,r15
	l = w - l;
  4170c9:	44 29 ed             	sub    ebp,r13d
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  4170cc:	39 c5                	cmp    ebp,eax
  4170ce:	0f 4e c5             	cmovle eax,ebp
  4170d1:	48 63 d0             	movsxd rdx,eax
  4170d4:	e8 b3 dc ff ff       	call   414d8c <memset>
	for (; l >= sizeof pad; l -= sizeof pad)
  4170d9:	81 fd ff 00 00 00    	cmp    ebp,0xff
  4170df:	0f 8e 18 17 00 00    	jle    4187fd <fmt_fp+0x22ad>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4170e5:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  4170e9:	8d 9d 00 ff ff ff    	lea    ebx,[rbp-0x100]
  4170ef:	90                   	nop
  4170f0:	83 e0 20             	and    eax,0x20
  4170f3:	0f 84 37 01 00 00    	je     417230 <fmt_fp+0xce0>
	for (; l >= sizeof pad; l -= sizeof pad)
  4170f9:	81 fb ff 00 00 00    	cmp    ebx,0xff
  4170ff:	7e 3f                	jle    417140 <fmt_fp+0xbf0>
  417101:	8d 93 00 e9 ff ff    	lea    edx,[rbx-0x1700]
  417107:	81 fa 00 e9 ff 7f    	cmp    edx,0x7fffe900
  41710d:	0f 86 15 f1 ff ff    	jbe    416228 <fmt_fp.cold+0x26f>
  417113:	81 eb 00 01 00 00    	sub    ebx,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417119:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  41711b:	89 dd                	mov    ebp,ebx
  41711d:	81 fb ff 00 00 00    	cmp    ebx,0xff
  417123:	77 ee                	ja     417113 <fmt_fp+0xbc3>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417125:	85 d2                	test   edx,edx
  417127:	75 17                	jne    417140 <fmt_fp+0xbf0>
	out(f, pad, l);
  417129:	48 63 f5             	movsxd rsi,ebp
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41712c:	4c 89 e2             	mov    rdx,r12
  41712f:	4c 89 ff             	mov    rdi,r15
  417132:	e8 19 37 00 00       	call   41a850 <__fwritex>
  417137:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41713e:	00 00 
		return MAX(w, 3+pl);
  417140:	8b 44 24 48          	mov    eax,DWORD PTR [rsp+0x48]
  417144:	44 39 e8             	cmp    eax,r13d
  417147:	41 0f 4c c5          	cmovl  eax,r13d
	}

	pad(f, ' ', w, pl+l, fl^LEFT_ADJ);

	return MAX(w, pl+l);
}
  41714b:	48 81 c4 38 1e 00 00 	add    rsp,0x1e38
  417152:	5b                   	pop    rbx
  417153:	5d                   	pop    rbp
  417154:	41 5c                	pop    r12
  417156:	41 5d                	pop    r13
  417158:	41 5e                	pop    r14
  41715a:	41 5f                	pop    r15
  41715c:	c3                   	ret    
	if (a<z) for (i=10, e=9*(r-a); *a>=i; i*=10, e++);
  41715d:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
	j = p - ((t|32)!='f')*e - ((t|32)=='g' && p);
  417162:	31 c9                	xor    ecx,ecx
  417164:	41 83 fe 66          	cmp    r14d,0x66
	if (a<z) for (i=10, e=9*(r-a); *a>=i; i*=10, e++);
  417168:	8b 55 00             	mov    edx,DWORD PTR [rbp+0x0]
	j = p - ((t|32)!='f')*e - ((t|32)=='g' && p);
  41716b:	0f 95 c1             	setne  cl
	if (a<z) for (i=10, e=9*(r-a); *a>=i; i*=10, e++);
  41716e:	48 29 e8             	sub    rax,rbp
  417171:	48 c1 f8 02          	sar    rax,0x2
  417175:	8d 3c c0             	lea    edi,[rax+rax*8]
  417178:	b8 0a 00 00 00       	mov    eax,0xa
  41717d:	83 fa 09             	cmp    edx,0x9
  417180:	76 12                	jbe    417194 <fmt_fp+0xc44>
  417182:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  417188:	8d 04 80             	lea    eax,[rax+rax*4]
  41718b:	83 c7 01             	add    edi,0x1
  41718e:	01 c0                	add    eax,eax
  417190:	39 d0                	cmp    eax,edx
  417192:	76 f4                	jbe    417188 <fmt_fp+0xc38>
	j = p - ((t|32)!='f')*e - ((t|32)=='g' && p);
  417194:	0f af cf             	imul   ecx,edi
  417197:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  41719a:	29 c8                	sub    eax,ecx
  41719c:	e9 ce f6 ff ff       	jmp    41686f <fmt_fp+0x31f>
  4171a1:	d9 c9                	fxch   st(1)
  4171a3:	eb 05                	jmp    4171aa <fmt_fp+0xc5a>
  4171a5:	0f 1f 00             	nop    DWORD PTR [rax]
  4171a8:	d9 c9                	fxch   st(1)
	if (y) y *= 0x1p28, e2-=28;
  4171aa:	41 83 e9 1c          	sub    r9d,0x1c
  4171ae:	d8 0d b0 72 00 00    	fmul   DWORD PTR [rip+0x72b0]        # 41e464 <states+0x224>
  4171b4:	d9 c9                	fxch   st(1)
  4171b6:	44 89 4c 24 50       	mov    DWORD PTR [rsp+0x50],r9d
  4171bb:	e9 ae f4 ff ff       	jmp    41666e <fmt_fp+0x11e>
		for (i=10, j++; j<9; i*=10, j++);
  4171c0:	f3 0f 7e 05 b0 72 00 	movq   xmm0,QWORD PTR [rip+0x72b0]        # 41e478 <states+0x238>
  4171c7:	00 
  4171c8:	66 0f 7e c2          	movd   edx,xmm0
  4171cc:	66 0f 70 e0 e5       	pshufd xmm4,xmm0,0xe5
  4171d1:	66 0f 7e e0          	movd   eax,xmm4
  4171d5:	0f af d0             	imul   edx,eax
  4171d8:	8d 0c 92             	lea    ecx,[rdx+rdx*4]
  4171db:	01 c9                	add    ecx,ecx
  4171dd:	41 83 e0 01          	and    r8d,0x1
  4171e1:	0f 84 51 f7 ff ff    	je     416938 <fmt_fp+0x3e8>
  4171e7:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  4171ea:	01 c9                	add    ecx,ecx
  4171ec:	e9 47 f7 ff ff       	jmp    416938 <fmt_fp+0x3e8>
  4171f1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4171f8:	4c 89 e2             	mov    rdx,r12
  4171fb:	be 00 01 00 00       	mov    esi,0x100
  417200:	4c 89 ff             	mov    rdi,r15
  417203:	e8 48 36 00 00       	call   41a850 <__fwritex>
  417208:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
	for (; l >= sizeof pad; l -= sizeof pad)
  41720c:	45 89 f1             	mov    r9d,r14d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41720f:	89 c2                	mov    edx,eax
  417211:	83 e2 20             	and    edx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  417214:	41 81 fe ff 00 00 00 	cmp    r14d,0xff
  41721b:	0f 8e 54 fe ff ff    	jle    417075 <fmt_fp+0xb25>
  417221:	41 81 ee 00 01 00 00 	sub    r14d,0x100
  417228:	e9 0b fe ff ff       	jmp    417038 <fmt_fp+0xae8>
  41722d:	0f 1f 00             	nop    DWORD PTR [rax]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417230:	4c 89 e2             	mov    rdx,r12
  417233:	be 00 01 00 00       	mov    esi,0x100
  417238:	4c 89 ff             	mov    rdi,r15
	for (; l >= sizeof pad; l -= sizeof pad)
  41723b:	89 dd                	mov    ebp,ebx
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41723d:	e8 0e 36 00 00       	call   41a850 <__fwritex>
  417242:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  417246:	89 c2                	mov    edx,eax
  417248:	83 e2 20             	and    edx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41724b:	81 fb ff 00 00 00    	cmp    ebx,0xff
  417251:	0f 8e ce fe ff ff    	jle    417125 <fmt_fp+0xbd5>
  417257:	81 eb 00 01 00 00    	sub    ebx,0x100
  41725d:	e9 8e fe ff ff       	jmp    4170f0 <fmt_fp+0xba0>
			if ((*d/i & 1) || (i==1000000000 && d>a && (d[-1]&1)))
  417262:	a8 01                	test   al,0x1
  417264:	0f 84 47 14 00 00    	je     4186b1 <fmt_fp+0x2161>
				round += 2;
  41726a:	db 2d 40 72 00 00    	fld    TBYTE PTR [rip+0x7240]        # 41e4b0 <states+0x270>
			if (x<i/2) small=0x0.8p0;
  417270:	d1 f9                	sar    ecx,1
  417272:	44 39 c1             	cmp    ecx,r8d
  417275:	0f 87 07 15 00 00    	ja     418782 <fmt_fp+0x2232>
			else if (x==i/2 && d+1==z) small=0x1.0p0;
  41727b:	0f 84 12 15 00 00    	je     418793 <fmt_fp+0x2243>
  417281:	d9 05 d1 71 00 00    	fld    DWORD PTR [rip+0x71d1]        # 41e458 <states+0x218>
			else small=0x1.8p0;
  417287:	d9 05 cf 71 00 00    	fld    DWORD PTR [rip+0x71cf]        # 41e45c <states+0x21c>
			if (pl && *prefix=='-') round*=-1, small*=-1;
  41728d:	44 8b 5c 24 28       	mov    r11d,DWORD PTR [rsp+0x28]
  417292:	45 85 db             	test   r11d,r11d
  417295:	74 14                	je     4172ab <fmt_fp+0xd5b>
  417297:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  41729c:	80 38 2d             	cmp    BYTE PTR [rax],0x2d
  41729f:	75 0e                	jne    4172af <fmt_fp+0xd5f>
  4172a1:	dd d8                	fstp   st(0)
  4172a3:	d9 c9                	fxch   st(1)
  4172a5:	d9 e0                	fchs   
  4172a7:	d9 c9                	fxch   st(1)
  4172a9:	eb 06                	jmp    4172b1 <fmt_fp+0xd61>
  4172ab:	dd d9                	fstp   st(1)
  4172ad:	eb 02                	jmp    4172b1 <fmt_fp+0xd61>
  4172af:	dd d9                	fstp   st(1)
			if (round+small != round) {
  4172b1:	d8 c1                	fadd   st,st(1)
			*d -= x;
  4172b3:	44 89 c8             	mov    eax,r9d
  4172b6:	44 29 c0             	sub    eax,r8d
			if (round+small != round) {
  4172b9:	df e9                	fucomip st,st(1)
  4172bb:	dd d8                	fstp   st(0)
  4172bd:	0f 8a 11 0f 00 00    	jp     4181d4 <fmt_fp+0x1c84>
  4172c3:	0f 85 0b 0f 00 00    	jne    4181d4 <fmt_fp+0x1c84>
			*d -= x;
  4172c9:	89 06                	mov    DWORD PTR [rsi],eax
		if (x || d+1!=z) {
  4172cb:	48 83 c6 04          	add    rsi,0x4
		if (z>d+1) z=d+1;
  4172cf:	48 39 f3             	cmp    rbx,rsi
  4172d2:	48 0f 47 de          	cmova  rbx,rsi
	for (; z>a && !z[-1]; z--);
  4172d6:	48 39 dd             	cmp    rbp,rbx
  4172d9:	72 0e                	jb     4172e9 <fmt_fp+0xd99>
  4172db:	eb 15                	jmp    4172f2 <fmt_fp+0xda2>
  4172dd:	0f 1f 00             	nop    DWORD PTR [rax]
  4172e0:	48 83 eb 04          	sub    rbx,0x4
  4172e4:	48 39 eb             	cmp    rbx,rbp
  4172e7:	76 09                	jbe    4172f2 <fmt_fp+0xda2>
  4172e9:	44 8b 43 fc          	mov    r8d,DWORD PTR [rbx-0x4]
  4172ed:	45 85 c0             	test   r8d,r8d
  4172f0:	74 ee                	je     4172e0 <fmt_fp+0xd90>
	if ((t|32)=='g') {
  4172f2:	41 83 fe 67          	cmp    r14d,0x67
  4172f6:	0f 84 53 09 00 00    	je     417c4f <fmt_fp+0x16ff>
	if (p > INT_MAX-1-(p || (fl&ALT_FORM)))
  4172fc:	8b 34 24             	mov    esi,DWORD PTR [rsp]
  4172ff:	85 f6                	test   esi,esi
  417301:	0f 85 6d 08 00 00    	jne    417b74 <fmt_fp+0x1624>
	l = 1 + p + (p || (fl&ALT_FORM));
  417307:	44 8b 44 24 14       	mov    r8d,DWORD PTR [rsp+0x14]
  41730c:	b8 01 00 00 00       	mov    eax,0x1
  417311:	41 c1 e8 03          	shr    r8d,0x3
  417315:	41 83 e0 01          	and    r8d,0x1
  417319:	41 01 c0             	add    r8d,eax
	if ((t|32)=='f') {
  41731c:	44 89 f8             	mov    eax,r15d
		if (e > INT_MAX-l) return -1;
  41731f:	41 ba ff ff ff 7f    	mov    r10d,0x7fffffff
	if ((t|32)=='f') {
  417325:	83 c8 20             	or     eax,0x20
		if (e > INT_MAX-l) return -1;
  417328:	45 29 c2             	sub    r10d,r8d
	if ((t|32)=='f') {
  41732b:	89 44 24 08          	mov    DWORD PTR [rsp+0x8],eax
  41732f:	83 f8 66             	cmp    eax,0x66
  417332:	0f 84 b5 0d 00 00    	je     4180ed <fmt_fp+0x1b9d>
		estr=fmt_u(e<0 ? -e : e, ebuf);
  417338:	89 fe                	mov    esi,edi
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  41733a:	4c 8d 6c 24 60       	lea    r13,[rsp+0x60]
		estr=fmt_u(e<0 ? -e : e, ebuf);
  41733f:	f7 de                	neg    esi
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  417341:	4c 89 e9             	mov    rcx,r13
		estr=fmt_u(e<0 ? -e : e, ebuf);
  417344:	0f 48 f7             	cmovs  esi,edi
  417347:	48 63 f6             	movsxd rsi,esi
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  41734a:	85 ff                	test   edi,edi
  41734c:	74 52                	je     4173a0 <fmt_fp+0xe50>
  41734e:	49 b9 cd cc cc cc cc 	movabs r9,0xcccccccccccccccd
  417355:	cc cc cc 
  417358:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41735f:	00 
  417360:	48 89 f0             	mov    rax,rsi
  417363:	48 83 e9 01          	sub    rcx,0x1
  417367:	49 f7 e1             	mul    r9
  41736a:	48 89 f0             	mov    rax,rsi
  41736d:	48 c1 ea 03          	shr    rdx,0x3
  417371:	4c 8d 1c 92          	lea    r11,[rdx+rdx*4]
  417375:	4d 01 db             	add    r11,r11
  417378:	4c 29 d8             	sub    rax,r11
  41737b:	83 c0 30             	add    eax,0x30
  41737e:	88 01                	mov    BYTE PTR [rcx],al
  417380:	48 89 f0             	mov    rax,rsi
  417383:	48 89 d6             	mov    rsi,rdx
  417386:	48 83 f8 09          	cmp    rax,0x9
  41738a:	77 d4                	ja     417360 <fmt_fp+0xe10>
		while(ebuf-estr<2) *--estr='0';
  41738c:	4c 89 e8             	mov    rax,r13
  41738f:	48 29 c8             	sub    rax,rcx
  417392:	48 83 f8 01          	cmp    rax,0x1
  417396:	7f 1b                	jg     4173b3 <fmt_fp+0xe63>
  417398:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41739f:	00 
  4173a0:	48 83 e9 01          	sub    rcx,0x1
  4173a4:	4c 89 e8             	mov    rax,r13
  4173a7:	c6 01 30             	mov    BYTE PTR [rcx],0x30
  4173aa:	48 29 c8             	sub    rax,rcx
  4173ad:	48 83 f8 01          	cmp    rax,0x1
  4173b1:	7e ed                	jle    4173a0 <fmt_fp+0xe50>
		*--estr = (e<0 ? '-' : '+');
  4173b3:	c1 ff 1f             	sar    edi,0x1f
		*--estr = t;
  4173b6:	48 8d 41 fe          	lea    rax,[rcx-0x2]
		if (ebuf-estr > INT_MAX-l) return -1;
  4173ba:	4d 63 d2             	movsxd r10,r10d
		*--estr = t;
  4173bd:	44 88 79 fe          	mov    BYTE PTR [rcx-0x2],r15b
		*--estr = (e<0 ? '-' : '+');
  4173c1:	83 e7 02             	and    edi,0x2
		if (ebuf-estr > INT_MAX-l) return -1;
  4173c4:	49 29 c5             	sub    r13,rax
		*--estr = t;
  4173c7:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
		*--estr = (e<0 ? '-' : '+');
  4173cc:	83 c7 2b             	add    edi,0x2b
  4173cf:	40 88 79 ff          	mov    BYTE PTR [rcx-0x1],dil
		if (ebuf-estr > INT_MAX-l) return -1;
  4173d3:	4d 39 d5             	cmp    r13,r10
  4173d6:	0f 8f b1 07 00 00    	jg     417b8d <fmt_fp+0x163d>
		l += ebuf-estr;
  4173dc:	45 01 e8             	add    r8d,r13d
	if (l > INT_MAX-pl) return -1;
  4173df:	8b 4c 24 28          	mov    ecx,DWORD PTR [rsp+0x28]
  4173e3:	89 c8                	mov    eax,ecx
  4173e5:	f7 d8                	neg    eax
  4173e7:	19 c0                	sbb    eax,eax
  4173e9:	05 ff ff ff 7f       	add    eax,0x7fffffff
  4173ee:	44 39 c0             	cmp    eax,r8d
  4173f1:	0f 8c 96 07 00 00    	jl     417b8d <fmt_fp+0x163d>
	pad(f, ' ', w, pl+l, fl);
  4173f7:	41 01 c8             	add    r8d,ecx
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  4173fa:	44 3b 44 24 48       	cmp    r8d,DWORD PTR [rsp+0x48]
  4173ff:	0f 9d 44 24 28       	setge  BYTE PTR [rsp+0x28]
  417404:	0f b6 44 24 28       	movzx  eax,BYTE PTR [rsp+0x28]
	pad(f, ' ', w, pl+l, fl);
  417409:	44 89 44 24 38       	mov    DWORD PTR [rsp+0x38],r8d
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41740e:	f7 44 24 14 00 20 01 	test   DWORD PTR [rsp+0x14],0x12000
  417415:	00 
  417416:	0f 85 9e 00 00 00    	jne    4174ba <fmt_fp+0xf6a>
  41741c:	84 c0                	test   al,al
  41741e:	0f 85 96 00 00 00    	jne    4174ba <fmt_fp+0xf6a>
	l = w - l;
  417424:	44 8b 74 24 48       	mov    r14d,DWORD PTR [rsp+0x48]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  417429:	b8 00 01 00 00       	mov    eax,0x100
	l = w - l;
  41742e:	44 2b 74 24 38       	sub    r14d,DWORD PTR [rsp+0x38]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  417433:	4c 8d bc 24 80 00 00 	lea    r15,[rsp+0x80]
  41743a:	00 
  41743b:	41 39 c6             	cmp    r14d,eax
  41743e:	be 20 00 00 00       	mov    esi,0x20
  417443:	4c 89 ff             	mov    rdi,r15
  417446:	41 0f 4e c6          	cmovle eax,r14d
  41744a:	48 63 d0             	movsxd rdx,eax
  41744d:	e8 3a d9 ff ff       	call   414d8c <memset>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417452:	41 8b 14 24          	mov    edx,DWORD PTR [r12]
	for (; l >= sizeof pad; l -= sizeof pad)
  417456:	41 81 fe ff 00 00 00 	cmp    r14d,0xff
  41745d:	0f 8e ba 13 00 00    	jle    41881d <fmt_fp+0x22cd>
  417463:	45 8d ae 00 ff ff ff 	lea    r13d,[r14-0x100]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41746a:	89 d0                	mov    eax,edx
  41746c:	83 e0 20             	and    eax,0x20
  41746f:	0f 84 73 05 00 00    	je     4179e8 <fmt_fp+0x1498>
	for (; l >= sizeof pad; l -= sizeof pad)
  417475:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  41747c:	7e 43                	jle    4174c1 <fmt_fp+0xf71>
  41747e:	41 8d 95 00 e9 ff ff 	lea    edx,[r13-0x1700]
  417485:	81 fa 00 e9 ff 7f    	cmp    edx,0x7fffe900
  41748b:	0f 86 17 f0 ff ff    	jbe    4164a8 <fmt_fp.cold+0x4ef>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417491:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  417493:	41 81 ed 00 01 00 00 	sub    r13d,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41749a:	89 d0                	mov    eax,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  41749c:	45 89 ee             	mov    r14d,r13d
  41749f:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  4174a6:	77 eb                	ja     417493 <fmt_fp+0xf43>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4174a8:	85 c0                	test   eax,eax
  4174aa:	75 1d                	jne    4174c9 <fmt_fp+0xf79>
	out(f, pad, l);
  4174ac:	49 63 f6             	movsxd rsi,r14d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4174af:	4c 89 e2             	mov    rdx,r12
  4174b2:	4c 89 ff             	mov    rdi,r15
  4174b5:	e8 96 33 00 00       	call   41a850 <__fwritex>
  4174ba:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  4174be:	83 e0 20             	and    eax,0x20
  4174c1:	85 c0                	test   eax,eax
  4174c3:	0f 84 3c 0c 00 00    	je     418105 <fmt_fp+0x1bb5>
	pad(f, '0', w, pl+l, fl^ZERO_PAD);
  4174c9:	8b 44 24 14          	mov    eax,DWORD PTR [rsp+0x14]
  4174cd:	35 00 00 01 00       	xor    eax,0x10000
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  4174d2:	a9 00 20 01 00       	test   eax,0x12000
  4174d7:	0f 85 a3 00 00 00    	jne    417580 <fmt_fp+0x1030>
  4174dd:	80 7c 24 28 00       	cmp    BYTE PTR [rsp+0x28],0x0
  4174e2:	0f 85 98 00 00 00    	jne    417580 <fmt_fp+0x1030>
	l = w - l;
  4174e8:	44 8b 74 24 48       	mov    r14d,DWORD PTR [rsp+0x48]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  4174ed:	b8 00 01 00 00       	mov    eax,0x100
	l = w - l;
  4174f2:	44 2b 74 24 38       	sub    r14d,DWORD PTR [rsp+0x38]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  4174f7:	4c 8d bc 24 80 00 00 	lea    r15,[rsp+0x80]
  4174fe:	00 
  4174ff:	41 39 c6             	cmp    r14d,eax
  417502:	be 30 00 00 00       	mov    esi,0x30
  417507:	4c 89 ff             	mov    rdi,r15
  41750a:	41 0f 4e c6          	cmovle eax,r14d
  41750e:	48 63 d0             	movsxd rdx,eax
  417511:	e8 76 d8 ff ff       	call   414d8c <memset>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417516:	41 8b 14 24          	mov    edx,DWORD PTR [r12]
	for (; l >= sizeof pad; l -= sizeof pad)
  41751a:	41 81 fe ff 00 00 00 	cmp    r14d,0xff
  417521:	0f 8e ec 12 00 00    	jle    418813 <fmt_fp+0x22c3>
  417527:	45 8d ae 00 ff ff ff 	lea    r13d,[r14-0x100]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41752e:	83 e2 20             	and    edx,0x20
  417531:	0f 84 e9 04 00 00    	je     417a20 <fmt_fp+0x14d0>
	for (; l >= sizeof pad; l -= sizeof pad)
  417537:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  41753e:	7e 40                	jle    417580 <fmt_fp+0x1030>
  417540:	41 8d 85 00 e9 ff ff 	lea    eax,[r13-0x1700]
  417547:	3d 00 e9 ff 7f       	cmp    eax,0x7fffe900
  41754c:	0f 86 b8 ee ff ff    	jbe    41640a <fmt_fp.cold+0x451>
  417552:	41 81 ed 00 01 00 00 	sub    r13d,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417559:	89 d0                	mov    eax,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  41755b:	45 89 ee             	mov    r14d,r13d
  41755e:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  417565:	77 eb                	ja     417552 <fmt_fp+0x1002>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417567:	85 c0                	test   eax,eax
  417569:	75 15                	jne    417580 <fmt_fp+0x1030>
	out(f, pad, l);
  41756b:	49 63 f6             	movsxd rsi,r14d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41756e:	4c 89 e2             	mov    rdx,r12
  417571:	4c 89 ff             	mov    rdi,r15
  417574:	e8 d7 32 00 00       	call   41a850 <__fwritex>
  417579:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	if ((t|32)=='f') {
  417580:	83 7c 24 08 66       	cmp    DWORD PTR [rsp+0x8],0x66
  417585:	0f 84 88 07 00 00    	je     417d13 <fmt_fp+0x17c3>
		if (z<=a) z=a+1;
  41758b:	48 8d 45 04          	lea    rax,[rbp+0x4]
  41758f:	48 39 dd             	cmp    rbp,rbx
  417592:	48 0f 43 d8          	cmovae rbx,rax
		for (d=a; d<z && p>=0; d++) {
  417596:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  417599:	85 c0                	test   eax,eax
  41759b:	0f 88 e5 00 00 00    	js     417686 <fmt_fp+0x1136>
  4175a1:	48 39 eb             	cmp    rbx,rbp
  4175a4:	0f 86 dc 00 00 00    	jbe    417686 <fmt_fp+0x1136>
  4175aa:	4c 89 e7             	mov    rdi,r12
  4175ad:	48 8d 4c 24 69       	lea    rcx,[rsp+0x69]
  4175b2:	48 89 1c 24          	mov    QWORD PTR [rsp],rbx
  4175b6:	49 89 ec             	mov    r12,rbp
  4175b9:	66 0f 6f 05 2f 6f 00 	movdqa xmm0,XMMWORD PTR [rip+0x6f2f]        # 41e4f0 <states+0x2b0>
  4175c0:	00 
  4175c1:	48 89 6c 24 08       	mov    QWORD PTR [rsp+0x8],rbp
  4175c6:	89 c3                	mov    ebx,eax
  4175c8:	48 89 cd             	mov    rbp,rcx
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  4175cb:	49 be cd cc cc cc cc 	movabs r14,0xcccccccccccccccd
  4175d2:	cc cc cc 
  4175d5:	49 89 ff             	mov    r15,rdi
  4175d8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4175df:	00 
			char *s = fmt_u(*d, buf+9);
  4175e0:	41 8b 34 24          	mov    esi,DWORD PTR [r12]
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  4175e4:	48 89 ef             	mov    rdi,rbp
  4175e7:	48 85 f6             	test   rsi,rsi
  4175ea:	0f 84 24 03 00 00    	je     417914 <fmt_fp+0x13c4>
  4175f0:	48 89 f0             	mov    rax,rsi
  4175f3:	49 89 fd             	mov    r13,rdi
  4175f6:	48 8d 7f ff          	lea    rdi,[rdi-0x1]
  4175fa:	49 f7 e6             	mul    r14
  4175fd:	48 89 f0             	mov    rax,rsi
  417600:	48 c1 ea 03          	shr    rdx,0x3
  417604:	48 8d 0c 92          	lea    rcx,[rdx+rdx*4]
  417608:	48 01 c9             	add    rcx,rcx
  41760b:	48 29 c8             	sub    rax,rcx
  41760e:	83 c0 30             	add    eax,0x30
  417611:	41 88 45 ff          	mov    BYTE PTR [r13-0x1],al
  417615:	48 89 f0             	mov    rax,rsi
  417618:	48 89 d6             	mov    rsi,rdx
  41761b:	48 83 f8 09          	cmp    rax,0x9
  41761f:	77 cf                	ja     4175f0 <fmt_fp+0x10a0>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417621:	45 8b 0f             	mov    r9d,DWORD PTR [r15]
			if (s==buf+9) *--s='0';
  417624:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  417629:	48 39 ef             	cmp    rdi,rbp
  41762c:	0f 84 e5 02 00 00    	je     417917 <fmt_fp+0x13c7>
			if (d!=a) while (s>buf) *--s='0';
  417632:	4c 39 64 24 08       	cmp    QWORD PTR [rsp+0x8],r12
  417637:	0f 85 83 01 00 00    	jne    4177c0 <fmt_fp+0x1270>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41763d:	41 83 e1 20          	and    r9d,0x20
  417641:	0f 84 f2 02 00 00    	je     417939 <fmt_fp+0x13e9>
				if (p>0||(fl&ALT_FORM)) out(f, ".", 1);
  417647:	8b 44 24 14          	mov    eax,DWORD PTR [rsp+0x14]
  41764b:	41 89 da             	mov    r10d,ebx
  41764e:	83 e0 08             	and    eax,0x8
  417651:	09 d8                	or     eax,ebx
  417653:	0f 85 17 03 00 00    	jne    417970 <fmt_fp+0x1420>
			out(f, s, MIN(buf+9-s, p));
  417659:	49 89 eb             	mov    r11,rbp
  41765c:	45 31 d2             	xor    r10d,r10d
  41765f:	4d 29 eb             	sub    r11,r13
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417662:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
			p -= buf+9-s;
  417668:	44 89 d3             	mov    ebx,r10d
		for (d=a; d<z && p>=0; d++) {
  41766b:	49 83 c4 04          	add    r12,0x4
			p -= buf+9-s;
  41766f:	44 29 db             	sub    ebx,r11d
		for (d=a; d<z && p>=0; d++) {
  417672:	4c 39 24 24          	cmp    QWORD PTR [rsp],r12
  417676:	76 08                	jbe    417680 <fmt_fp+0x1130>
  417678:	85 db                	test   ebx,ebx
  41767a:	0f 89 60 ff ff ff    	jns    4175e0 <fmt_fp+0x1090>
  417680:	89 1c 24             	mov    DWORD PTR [rsp],ebx
  417683:	4d 89 fc             	mov    r12,r15
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  417686:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  417689:	85 c0                	test   eax,eax
  41768b:	0f 8e 95 05 00 00    	jle    417c26 <fmt_fp+0x16d6>
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  417691:	8b 1c 24             	mov    ebx,DWORD PTR [rsp]
  417694:	81 fb 00 01 00 00    	cmp    ebx,0x100
  41769a:	0f 8f 0a 0b 00 00    	jg     4181aa <fmt_fp+0x1c5a>
  4176a0:	48 63 eb             	movsxd rbp,ebx
  4176a3:	4c 8d bc 24 80 00 00 	lea    r15,[rsp+0x80]
  4176aa:	00 
  4176ab:	be 30 00 00 00       	mov    esi,0x30
  4176b0:	48 89 ea             	mov    rdx,rbp
  4176b3:	4c 89 ff             	mov    rdi,r15
  4176b6:	e8 d1 d6 ff ff       	call   414d8c <memset>
	for (; l >= sizeof pad; l -= sizeof pad)
  4176bb:	81 fb 00 01 00 00    	cmp    ebx,0x100
  4176c1:	0f 85 6c 11 00 00    	jne    418833 <fmt_fp+0x22e3>
  4176c7:	8b 1c 24             	mov    ebx,DWORD PTR [rsp]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4176ca:	41 8b 14 24          	mov    edx,DWORD PTR [r12]
  4176ce:	81 eb 00 01 00 00    	sub    ebx,0x100
  4176d4:	89 dd                	mov    ebp,ebx
  4176d6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4176dd:	00 00 00 
  4176e0:	89 d0                	mov    eax,edx
  4176e2:	83 e0 20             	and    eax,0x20
  4176e5:	0f 84 95 02 00 00    	je     417980 <fmt_fp+0x1430>
	for (; l >= sizeof pad; l -= sizeof pad)
  4176eb:	81 fd ff 00 00 00    	cmp    ebp,0xff
  4176f1:	76 12                	jbe    417705 <fmt_fp+0x11b5>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4176f3:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  4176f5:	81 ed 00 01 00 00    	sub    ebp,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4176fb:	89 d0                	mov    eax,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  4176fd:	81 fd ff 00 00 00    	cmp    ebp,0xff
  417703:	77 f0                	ja     4176f5 <fmt_fp+0x11a5>
	out(f, pad, l);
  417705:	0f b6 eb             	movzx  ebp,bl
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417708:	85 c0                	test   eax,eax
  41770a:	0f 84 08 05 00 00    	je     417c18 <fmt_fp+0x16c8>
	pad(f, ' ', w, pl+l, fl^LEFT_ADJ);
  417710:	8b 44 24 14          	mov    eax,DWORD PTR [rsp+0x14]
  417714:	80 f4 20             	xor    ah,0x20
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  417717:	a9 00 20 01 00       	test   eax,0x12000
  41771c:	0f 85 84 00 00 00    	jne    4177a6 <fmt_fp+0x1256>
  417722:	80 7c 24 28 00       	cmp    BYTE PTR [rsp+0x28],0x0
  417727:	75 7d                	jne    4177a6 <fmt_fp+0x1256>
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  417729:	b8 00 01 00 00       	mov    eax,0x100
	l = w - l;
  41772e:	8b 6c 24 48          	mov    ebp,DWORD PTR [rsp+0x48]
  417732:	2b 6c 24 38          	sub    ebp,DWORD PTR [rsp+0x38]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  417736:	4c 8d bc 24 80 00 00 	lea    r15,[rsp+0x80]
  41773d:	00 
  41773e:	39 c5                	cmp    ebp,eax
  417740:	be 20 00 00 00       	mov    esi,0x20
  417745:	4c 89 ff             	mov    rdi,r15
  417748:	0f 4e c5             	cmovle eax,ebp
  41774b:	48 63 d0             	movsxd rdx,eax
  41774e:	e8 39 d6 ff ff       	call   414d8c <memset>
	for (; l >= sizeof pad; l -= sizeof pad)
  417753:	81 fd ff 00 00 00    	cmp    ebp,0xff
  417759:	0f 8e c8 10 00 00    	jle    418827 <fmt_fp+0x22d7>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41775f:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  417763:	8d 9d 00 ff ff ff    	lea    ebx,[rbp-0x100]
  417769:	83 e0 20             	and    eax,0x20
  41776c:	0f 84 3e 02 00 00    	je     4179b0 <fmt_fp+0x1460>
	for (; l >= sizeof pad; l -= sizeof pad)
  417772:	81 fb ff 00 00 00    	cmp    ebx,0xff
  417778:	7e 2c                	jle    4177a6 <fmt_fp+0x1256>
  41777a:	8d 93 00 e9 ff ff    	lea    edx,[rbx-0x1700]
  417780:	81 fa 00 e9 ff 7f    	cmp    edx,0x7fffe900
  417786:	0f 86 06 ea ff ff    	jbe    416192 <fmt_fp.cold+0x1d9>
  41778c:	81 eb 00 01 00 00    	sub    ebx,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417792:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  417794:	89 dd                	mov    ebp,ebx
  417796:	81 fb ff 00 00 00    	cmp    ebx,0xff
  41779c:	77 ee                	ja     41778c <fmt_fp+0x123c>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41779e:	85 d2                	test   edx,edx
  4177a0:	0f 84 f8 0e 00 00    	je     41869e <fmt_fp+0x214e>
	return MAX(w, pl+l);
  4177a6:	8b 5c 24 38          	mov    ebx,DWORD PTR [rsp+0x38]
  4177aa:	8b 44 24 48          	mov    eax,DWORD PTR [rsp+0x48]
  4177ae:	39 c3                	cmp    ebx,eax
  4177b0:	0f 4d c3             	cmovge eax,ebx
  4177b3:	e9 93 f9 ff ff       	jmp    41714b <fmt_fp+0xbfb>
  4177b8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4177bf:	00 
			if (d!=a) while (s>buf) *--s='0';
  4177c0:	48 39 d7             	cmp    rdi,rdx
  4177c3:	0f 86 61 09 00 00    	jbe    41812a <fmt_fp+0x1bda>
  4177c9:	4c 8d 5f ff          	lea    r11,[rdi-0x1]
  4177cd:	48 89 f8             	mov    rax,rdi
  4177d0:	be 01 00 00 00       	mov    esi,0x1
  4177d5:	48 29 d0             	sub    rax,rdx
  4177d8:	49 39 d3             	cmp    r11,rdx
  4177db:	48 0f 43 f0          	cmovae rsi,rax
  4177df:	48 83 e8 01          	sub    rax,0x1
  4177e3:	48 83 f8 0e          	cmp    rax,0xe
  4177e7:	0f 86 dc 09 00 00    	jbe    4181c9 <fmt_fp+0x1c79>
  4177ed:	49 39 d3             	cmp    r11,rdx
  4177f0:	0f 82 d3 09 00 00    	jb     4181c9 <fmt_fp+0x1c79>
  4177f6:	48 89 f0             	mov    rax,rsi
  4177f9:	49 89 fa             	mov    r10,rdi
  4177fc:	48 83 e0 f0          	and    rax,0xfffffffffffffff0
  417800:	49 29 c2             	sub    r10,rax
			if (s==buf+9) *--s='0';
  417803:	48 89 f8             	mov    rax,rdi
  417806:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41780d:	00 00 00 
			if (d!=a) while (s>buf) *--s='0';
  417810:	0f 11 40 f0          	movups XMMWORD PTR [rax-0x10],xmm0
  417814:	48 83 e8 10          	sub    rax,0x10
  417818:	4c 39 d0             	cmp    rax,r10
  41781b:	75 f3                	jne    417810 <fmt_fp+0x12c0>
  41781d:	49 89 f2             	mov    r10,rsi
  417820:	48 89 f8             	mov    rax,rdi
  417823:	49 83 e2 f0          	and    r10,0xfffffffffffffff0
  417827:	4c 29 d0             	sub    rax,r10
  41782a:	4c 39 d6             	cmp    rsi,r10
  41782d:	74 7f                	je     4178ae <fmt_fp+0x135e>
  41782f:	4c 29 d6             	sub    rsi,r10
  417832:	4c 8d 6e ff          	lea    r13,[rsi-0x1]
  417836:	49 83 fd 06          	cmp    r13,0x6
  41783a:	76 20                	jbe    41785c <fmt_fp+0x130c>
  41783c:	49 89 fd             	mov    r13,rdi
  41783f:	48 8b 0d aa 6c 00 00 	mov    rcx,QWORD PTR [rip+0x6caa]        # 41e4f0 <states+0x2b0>
  417846:	4d 29 d5             	sub    r13,r10
  417849:	49 89 f2             	mov    r10,rsi
  41784c:	49 83 e2 f8          	and    r10,0xfffffffffffffff8
  417850:	49 89 4d f8          	mov    QWORD PTR [r13-0x8],rcx
  417854:	4c 29 d0             	sub    rax,r10
  417857:	4c 39 d6             	cmp    rsi,r10
  41785a:	74 52                	je     4178ae <fmt_fp+0x135e>
  41785c:	48 8d 70 ff          	lea    rsi,[rax-0x1]
  417860:	c6 40 ff 30          	mov    BYTE PTR [rax-0x1],0x30
  417864:	48 39 f2             	cmp    rdx,rsi
  417867:	73 45                	jae    4178ae <fmt_fp+0x135e>
  417869:	48 8d 70 fe          	lea    rsi,[rax-0x2]
  41786d:	c6 40 fe 30          	mov    BYTE PTR [rax-0x2],0x30
  417871:	48 39 f2             	cmp    rdx,rsi
  417874:	73 38                	jae    4178ae <fmt_fp+0x135e>
  417876:	48 8d 70 fd          	lea    rsi,[rax-0x3]
  41787a:	c6 40 fd 30          	mov    BYTE PTR [rax-0x3],0x30
  41787e:	48 39 f2             	cmp    rdx,rsi
  417881:	73 2b                	jae    4178ae <fmt_fp+0x135e>
  417883:	48 8d 70 fc          	lea    rsi,[rax-0x4]
  417887:	c6 40 fc 30          	mov    BYTE PTR [rax-0x4],0x30
  41788b:	48 39 f2             	cmp    rdx,rsi
  41788e:	73 1e                	jae    4178ae <fmt_fp+0x135e>
  417890:	48 8d 70 fb          	lea    rsi,[rax-0x5]
  417894:	c6 40 fb 30          	mov    BYTE PTR [rax-0x5],0x30
  417898:	48 39 f2             	cmp    rdx,rsi
  41789b:	73 11                	jae    4178ae <fmt_fp+0x135e>
  41789d:	48 8d 70 fa          	lea    rsi,[rax-0x6]
  4178a1:	c6 40 fa 30          	mov    BYTE PTR [rax-0x6],0x30
  4178a5:	48 39 f2             	cmp    rdx,rsi
  4178a8:	73 04                	jae    4178ae <fmt_fp+0x135e>
  4178aa:	c6 40 f9 30          	mov    BYTE PTR [rax-0x7],0x30
  4178ae:	49 89 d5             	mov    r13,rdx
  4178b1:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
  4178b8:	41 89 da             	mov    r10d,ebx
  4178bb:	49 29 fd             	sub    r13,rdi
  4178be:	49 39 d3             	cmp    r11,rdx
  4178c1:	4c 0f 42 e8          	cmovb  r13,rax
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4178c5:	41 83 e1 20          	and    r9d,0x20
			if (d!=a) while (s>buf) *--s='0';
  4178c9:	49 01 fd             	add    r13,rdi
			out(f, s, MIN(buf+9-s, p));
  4178cc:	49 89 eb             	mov    r11,rbp
  4178cf:	4d 29 eb             	sub    r11,r13
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4178d2:	45 85 c9             	test   r9d,r9d
  4178d5:	0f 85 8d fd ff ff    	jne    417668 <fmt_fp+0x1118>
			out(f, s, MIN(buf+9-s, p));
  4178db:	48 63 db             	movsxd rbx,ebx
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4178de:	4c 89 fa             	mov    rdx,r15
  4178e1:	4c 89 ef             	mov    rdi,r13
  4178e4:	44 89 54 24 20       	mov    DWORD PTR [rsp+0x20],r10d
			out(f, s, MIN(buf+9-s, p));
  4178e9:	4c 39 db             	cmp    rbx,r11
  4178ec:	4c 89 5c 24 18       	mov    QWORD PTR [rsp+0x18],r11
  4178f1:	49 0f 4f db          	cmovg  rbx,r11
  4178f5:	48 89 de             	mov    rsi,rbx
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4178f8:	e8 53 2f 00 00       	call   41a850 <__fwritex>
  4178fd:	44 8b 54 24 20       	mov    r10d,DWORD PTR [rsp+0x20]
  417902:	4c 8b 5c 24 18       	mov    r11,QWORD PTR [rsp+0x18]
  417907:	66 0f 6f 05 e1 6b 00 	movdqa xmm0,XMMWORD PTR [rip+0x6be1]        # 41e4f0 <states+0x2b0>
  41790e:	00 
  41790f:	e9 54 fd ff ff       	jmp    417668 <fmt_fp+0x1118>
  417914:	45 8b 0f             	mov    r9d,DWORD PTR [r15]
			if (s==buf+9) *--s='0';
  417917:	c6 44 24 68 30       	mov    BYTE PTR [rsp+0x68],0x30
			if (d!=a) while (s>buf) *--s='0';
  41791c:	4c 39 64 24 08       	cmp    QWORD PTR [rsp+0x8],r12
  417921:	0f 85 68 01 00 00    	jne    417a8f <fmt_fp+0x153f>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417927:	41 83 e1 20          	and    r9d,0x20
			if (d!=a) while (s>buf) *--s='0';
  41792b:	49 89 ed             	mov    r13,rbp
			if (s==buf+9) *--s='0';
  41792e:	48 8d 7c 24 68       	lea    rdi,[rsp+0x68]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417933:	0f 85 0e fd ff ff    	jne    417647 <fmt_fp+0x10f7>
  417939:	4c 89 fa             	mov    rdx,r15
  41793c:	be 01 00 00 00       	mov    esi,0x1
  417941:	e8 0a 2f 00 00       	call   41a850 <__fwritex>
				if (p>0||(fl&ALT_FORM)) out(f, ".", 1);
  417946:	8b 44 24 14          	mov    eax,DWORD PTR [rsp+0x14]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41794a:	45 8b 0f             	mov    r9d,DWORD PTR [r15]
  41794d:	41 89 da             	mov    r10d,ebx
				if (p>0||(fl&ALT_FORM)) out(f, ".", 1);
  417950:	66 0f 6f 05 98 6b 00 	movdqa xmm0,XMMWORD PTR [rip+0x6b98]        # 41e4f0 <states+0x2b0>
  417957:	00 
  417958:	83 e0 08             	and    eax,0x8
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41795b:	41 83 e1 20          	and    r9d,0x20
				if (p>0||(fl&ALT_FORM)) out(f, ".", 1);
  41795f:	09 d8                	or     eax,ebx
  417961:	0f 85 ee 00 00 00    	jne    417a55 <fmt_fp+0x1505>
  417967:	45 31 d2             	xor    r10d,r10d
  41796a:	e9 5d ff ff ff       	jmp    4178cc <fmt_fp+0x137c>
  41796f:	90                   	nop
			out(f, s, MIN(buf+9-s, p));
  417970:	49 89 eb             	mov    r11,rbp
  417973:	4d 29 eb             	sub    r11,r13
  417976:	e9 ed fc ff ff       	jmp    417668 <fmt_fp+0x1118>
  41797b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417980:	4c 89 e2             	mov    rdx,r12
  417983:	be 00 01 00 00       	mov    esi,0x100
  417988:	4c 89 ff             	mov    rdi,r15
  41798b:	e8 c0 2e 00 00       	call   41a850 <__fwritex>
  417990:	41 8b 14 24          	mov    edx,DWORD PTR [r12]
  417994:	89 d0                	mov    eax,edx
  417996:	83 e0 20             	and    eax,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  417999:	81 fd ff 00 00 00    	cmp    ebp,0xff
  41799f:	0f 86 60 fd ff ff    	jbe    417705 <fmt_fp+0x11b5>
  4179a5:	81 ed 00 01 00 00    	sub    ebp,0x100
  4179ab:	e9 30 fd ff ff       	jmp    4176e0 <fmt_fp+0x1190>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4179b0:	4c 89 e2             	mov    rdx,r12
  4179b3:	be 00 01 00 00       	mov    esi,0x100
  4179b8:	4c 89 ff             	mov    rdi,r15
	for (; l >= sizeof pad; l -= sizeof pad)
  4179bb:	89 dd                	mov    ebp,ebx
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4179bd:	e8 8e 2e 00 00       	call   41a850 <__fwritex>
  4179c2:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  4179c6:	89 c2                	mov    edx,eax
  4179c8:	83 e2 20             	and    edx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  4179cb:	81 fb ff 00 00 00    	cmp    ebx,0xff
  4179d1:	0f 8e c7 fd ff ff    	jle    41779e <fmt_fp+0x124e>
  4179d7:	81 eb 00 01 00 00    	sub    ebx,0x100
  4179dd:	e9 87 fd ff ff       	jmp    417769 <fmt_fp+0x1219>
  4179e2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4179e8:	4c 89 e2             	mov    rdx,r12
  4179eb:	be 00 01 00 00       	mov    esi,0x100
  4179f0:	4c 89 ff             	mov    rdi,r15
	for (; l >= sizeof pad; l -= sizeof pad)
  4179f3:	45 89 ee             	mov    r14d,r13d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4179f6:	e8 55 2e 00 00       	call   41a850 <__fwritex>
  4179fb:	41 8b 14 24          	mov    edx,DWORD PTR [r12]
  4179ff:	89 d0                	mov    eax,edx
  417a01:	83 e0 20             	and    eax,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  417a04:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  417a0b:	0f 8e 97 fa ff ff    	jle    4174a8 <fmt_fp+0xf58>
  417a11:	41 81 ed 00 01 00 00 	sub    r13d,0x100
  417a18:	e9 4d fa ff ff       	jmp    41746a <fmt_fp+0xf1a>
  417a1d:	0f 1f 00             	nop    DWORD PTR [rax]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417a20:	4c 89 e2             	mov    rdx,r12
  417a23:	be 00 01 00 00       	mov    esi,0x100
  417a28:	4c 89 ff             	mov    rdi,r15
	for (; l >= sizeof pad; l -= sizeof pad)
  417a2b:	45 89 ee             	mov    r14d,r13d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417a2e:	e8 1d 2e 00 00       	call   41a850 <__fwritex>
  417a33:	41 8b 14 24          	mov    edx,DWORD PTR [r12]
  417a37:	89 d0                	mov    eax,edx
  417a39:	83 e0 20             	and    eax,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  417a3c:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  417a43:	0f 8e 1e fb ff ff    	jle    417567 <fmt_fp+0x1017>
  417a49:	41 81 ed 00 01 00 00 	sub    r13d,0x100
  417a50:	e9 d9 fa ff ff       	jmp    41752e <fmt_fp+0xfde>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417a55:	45 85 c9             	test   r9d,r9d
  417a58:	0f 85 12 ff ff ff    	jne    417970 <fmt_fp+0x1420>
  417a5e:	4c 89 fa             	mov    rdx,r15
  417a61:	be 01 00 00 00       	mov    esi,0x1
  417a66:	48 8d 3d ae 66 00 00 	lea    rdi,[rip+0x66ae]        # 41e11b <CSWTCH.186+0x7cb>
  417a6d:	89 5c 24 18          	mov    DWORD PTR [rsp+0x18],ebx
  417a71:	e8 da 2d 00 00       	call   41a850 <__fwritex>
  417a76:	45 8b 0f             	mov    r9d,DWORD PTR [r15]
  417a79:	44 8b 54 24 18       	mov    r10d,DWORD PTR [rsp+0x18]
  417a7e:	66 0f 6f 05 6a 6a 00 	movdqa xmm0,XMMWORD PTR [rip+0x6a6a]        # 41e4f0 <states+0x2b0>
  417a85:	00 
  417a86:	41 83 e1 20          	and    r9d,0x20
  417a8a:	e9 3d fe ff ff       	jmp    4178cc <fmt_fp+0x137c>
			if (s==buf+9) *--s='0';
  417a8f:	48 8d 7c 24 68       	lea    rdi,[rsp+0x68]
  417a94:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  417a99:	e9 2b fd ff ff       	jmp    4177c9 <fmt_fp+0x1279>
			if (s-buf==1 && (y||p>0||(fl&ALT_FORM))) *s++='.';
  417a9e:	c6 42 01 2e          	mov    BYTE PTR [rdx+0x1],0x2e
  417aa2:	48 83 c2 02          	add    rdx,0x2
  417aa6:	e9 c8 f0 ff ff       	jmp    416b73 <fmt_fp+0x623>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417aab:	4c 89 e2             	mov    rdx,r12
  417aae:	be 00 01 00 00       	mov    esi,0x100
  417ab3:	4c 89 ff             	mov    rdi,r15
  417ab6:	e8 95 2d 00 00       	call   41a850 <__fwritex>
  417abb:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
	for (; l >= sizeof pad; l -= sizeof pad)
  417abf:	41 89 d8             	mov    r8d,ebx
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417ac2:	89 c2                	mov    edx,eax
  417ac4:	83 e2 20             	and    edx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  417ac7:	81 fb ff 00 00 00    	cmp    ebx,0xff
  417acd:	0f 8e 7b 0e 00 00    	jle    41894e <fmt_fp+0x23fe>
  417ad3:	81 eb 00 01 00 00    	sub    ebx,0x100
  417ad9:	e9 d9 f1 ff ff       	jmp    416cb7 <fmt_fp+0x767>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417ade:	4c 89 e2             	mov    rdx,r12
  417ae1:	be 00 01 00 00       	mov    esi,0x100
  417ae6:	4c 89 ff             	mov    rdi,r15
	for (; l >= sizeof pad; l -= sizeof pad)
  417ae9:	89 dd                	mov    ebp,ebx
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417aeb:	e8 60 2d 00 00       	call   41a850 <__fwritex>
  417af0:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  417af4:	89 c2                	mov    edx,eax
  417af6:	83 e2 20             	and    edx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  417af9:	81 fb ff 00 00 00    	cmp    ebx,0xff
  417aff:	0f 8f ff f2 ff ff    	jg     416e04 <fmt_fp+0x8b4>
  417b05:	e9 38 f3 ff ff       	jmp    416e42 <fmt_fp+0x8f2>
  417b0a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417b10:	4c 89 e2             	mov    rdx,r12
  417b13:	be 00 01 00 00       	mov    esi,0x100
  417b18:	4c 89 ff             	mov    rdi,r15
  417b1b:	e8 30 2d 00 00       	call   41a850 <__fwritex>
  417b20:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
	for (; l >= sizeof pad; l -= sizeof pad)
  417b24:	89 d9                	mov    ecx,ebx
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417b26:	89 c2                	mov    edx,eax
  417b28:	83 e2 20             	and    edx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  417b2b:	81 fb ff 00 00 00    	cmp    ebx,0xff
  417b31:	0f 8e 85 f2 ff ff    	jle    416dbc <fmt_fp+0x86c>
  417b37:	81 eb 00 01 00 00    	sub    ebx,0x100
  417b3d:	e9 3e f2 ff ff       	jmp    416d80 <fmt_fp+0x830>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417b42:	4c 89 e2             	mov    rdx,r12
  417b45:	be 00 01 00 00       	mov    esi,0x100
  417b4a:	4c 89 ff             	mov    rdi,r15
	for (; l >= sizeof pad; l -= sizeof pad)
  417b4d:	89 dd                	mov    ebp,ebx
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417b4f:	e8 fc 2c 00 00       	call   41a850 <__fwritex>
  417b54:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  417b58:	89 c2                	mov    edx,eax
  417b5a:	83 e2 20             	and    edx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  417b5d:	81 fb ff 00 00 00    	cmp    ebx,0xff
  417b63:	0f 8e 94 f3 ff ff    	jle    416efd <fmt_fp+0x9ad>
  417b69:	81 eb 00 01 00 00    	sub    ebx,0x100
  417b6f:	e9 54 f3 ff ff       	jmp    416ec8 <fmt_fp+0x978>
	l = 1 + p + (p || (fl&ALT_FORM));
  417b74:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  417b77:	41 b8 01 00 00 00    	mov    r8d,0x1
  417b7d:	83 c0 01             	add    eax,0x1
	if (p > INT_MAX-1-(p || (fl&ALT_FORM)))
  417b80:	81 3c 24 fd ff ff 7f 	cmp    DWORD PTR [rsp],0x7ffffffd
  417b87:	0f 8e 8c f7 ff ff    	jle    417319 <fmt_fp+0xdc9>
			return -1;
  417b8d:	b8 ff ff ff ff       	mov    eax,0xffffffff
  417b92:	e9 b4 f5 ff ff       	jmp    41714b <fmt_fp+0xbfb>
  417b97:	c6 44 24 38 01       	mov    BYTE PTR [rsp+0x38],0x1
	if (p<0) p=6;
  417b9c:	c7 04 24 06 00 00 00 	mov    DWORD PTR [rsp],0x6
  417ba3:	e9 b2 ea ff ff       	jmp    41665a <fmt_fp+0x10a>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417ba8:	48 8b 74 24 30       	mov    rsi,QWORD PTR [rsp+0x30]
  417bad:	48 8b 7c 24 20       	mov    rdi,QWORD PTR [rsp+0x20]
  417bb2:	4c 89 e2             	mov    rdx,r12
  417bb5:	e8 96 2c 00 00       	call   41a850 <__fwritex>
  417bba:	41 f6 04 24 20       	test   BYTE PTR [r12],0x20
  417bbf:	0f 85 d1 f4 ff ff    	jne    417096 <fmt_fp+0xb46>
  417bc5:	4c 89 e2             	mov    rdx,r12
  417bc8:	be 03 00 00 00       	mov    esi,0x3
  417bcd:	48 89 ef             	mov    rdi,rbp
  417bd0:	e8 7b 2c 00 00       	call   41a850 <__fwritex>
  417bd5:	e9 bc f4 ff ff       	jmp    417096 <fmt_fp+0xb46>
	out(f, pad, l);
  417bda:	48 63 f1             	movsxd rsi,ecx
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417bdd:	4c 89 e2             	mov    rdx,r12
  417be0:	4c 89 ff             	mov    rdi,r15
  417be3:	e8 68 2c 00 00       	call   41a850 <__fwritex>
  417be8:	41 8b 14 24          	mov    edx,DWORD PTR [r12]
  417bec:	83 e2 20             	and    edx,0x20
  417bef:	85 d2                	test   edx,edx
  417bf1:	0f 85 cd f1 ff ff    	jne    416dc4 <fmt_fp+0x874>
  417bf7:	48 8b 74 24 38       	mov    rsi,QWORD PTR [rsp+0x38]
  417bfc:	4c 89 e2             	mov    rdx,r12
  417bff:	4c 89 ef             	mov    rdi,r13
  417c02:	e8 49 2c 00 00       	call   41a850 <__fwritex>
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  417c07:	8b 5c 24 30          	mov    ebx,DWORD PTR [rsp+0x30]
  417c0b:	85 ed                	test   ebp,ebp
  417c0d:	0f 8f bb f1 ff ff    	jg     416dce <fmt_fp+0x87e>
  417c13:	e9 3c f2 ff ff       	jmp    416e54 <fmt_fp+0x904>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417c18:	4c 89 e2             	mov    rdx,r12
  417c1b:	48 89 ee             	mov    rsi,rbp
  417c1e:	4c 89 ff             	mov    rdi,r15
  417c21:	e8 2a 2c 00 00       	call   41a850 <__fwritex>
  417c26:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  417c2a:	83 e0 20             	and    eax,0x20
  417c2d:	85 c0                	test   eax,eax
  417c2f:	0f 85 db fa ff ff    	jne    417710 <fmt_fp+0x11c0>
		out(f, estr, ebuf-estr);
  417c35:	48 8b 7c 24 40       	mov    rdi,QWORD PTR [rsp+0x40]
  417c3a:	48 8d 74 24 60       	lea    rsi,[rsp+0x60]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417c3f:	4c 89 e2             	mov    rdx,r12
		out(f, estr, ebuf-estr);
  417c42:	48 29 fe             	sub    rsi,rdi
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417c45:	e8 06 2c 00 00       	call   41a850 <__fwritex>
  417c4a:	e9 c1 fa ff ff       	jmp    417710 <fmt_fp+0x11c0>
		if (!p) p++;
  417c4f:	8b 0c 24             	mov    ecx,DWORD PTR [rsp]
  417c52:	b8 01 00 00 00       	mov    eax,0x1
  417c57:	85 c9                	test   ecx,ecx
  417c59:	0f 45 c1             	cmovne eax,ecx
  417c5c:	89 04 24             	mov    DWORD PTR [rsp],eax
  417c5f:	89 c1                	mov    ecx,eax
		if (p>e && e>=-4) {
  417c61:	39 f8                	cmp    eax,edi
  417c63:	0f 8e 05 0a 00 00    	jle    41866e <fmt_fp+0x211e>
  417c69:	83 ff fc             	cmp    edi,0xfffffffc
  417c6c:	0f 8c fc 09 00 00    	jl     41866e <fmt_fp+0x211e>
			p-=e+1;
  417c72:	8d 47 01             	lea    eax,[rdi+0x1]
			t--;
  417c75:	41 83 ef 01          	sub    r15d,0x1
			p-=e+1;
  417c79:	29 c1                	sub    ecx,eax
  417c7b:	89 0c 24             	mov    DWORD PTR [rsp],ecx
		if (!(fl&ALT_FORM)) {
  417c7e:	f6 44 24 14 08       	test   BYTE PTR [rsp+0x14],0x8
  417c83:	0f 85 73 f6 ff ff    	jne    4172fc <fmt_fp+0xdac>
			if (z>a && z[-1]) for (i=10, j=0; z[-1]%i==0; i*=10, j++);
  417c89:	be 09 00 00 00       	mov    esi,0x9
  417c8e:	48 39 dd             	cmp    rbp,rbx
  417c91:	73 3a                	jae    417ccd <fmt_fp+0x177d>
  417c93:	44 8b 43 fc          	mov    r8d,DWORD PTR [rbx-0x4]
  417c97:	45 85 c0             	test   r8d,r8d
  417c9a:	74 31                	je     417ccd <fmt_fp+0x177d>
  417c9c:	41 69 c0 cd cc cc cc 	imul   eax,r8d,0xcccccccd
  417ca3:	d1 c8                	ror    eax,1
  417ca5:	3d 99 99 99 19       	cmp    eax,0x19999999
  417caa:	0f 87 55 0c 00 00    	ja     418905 <fmt_fp+0x23b5>
  417cb0:	31 f6                	xor    esi,esi
  417cb2:	b9 0a 00 00 00       	mov    ecx,0xa
  417cb7:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  417cba:	44 89 c0             	mov    eax,r8d
  417cbd:	31 d2                	xor    edx,edx
  417cbf:	83 c6 01             	add    esi,0x1
  417cc2:	01 c9                	add    ecx,ecx
  417cc4:	f7 f1                	div    ecx
  417cc6:	85 d2                	test   edx,edx
  417cc8:	74 ed                	je     417cb7 <fmt_fp+0x1767>
				p = MIN(p,MAX(0,9*(z-r-1)-j));
  417cca:	48 63 f6             	movsxd rsi,esi
  417ccd:	48 89 d8             	mov    rax,rbx
  417cd0:	48 2b 44 24 18       	sub    rax,QWORD PTR [rsp+0x18]
  417cd5:	48 63 14 24          	movsxd rdx,DWORD PTR [rsp]
  417cd9:	48 c1 f8 02          	sar    rax,0x2
  417cdd:	48 8d 4c c0 f7       	lea    rcx,[rax+rax*8-0x9]
			if ((t|32)=='f')
  417ce2:	44 89 f8             	mov    eax,r15d
  417ce5:	83 c8 20             	or     eax,0x20
  417ce8:	83 f8 66             	cmp    eax,0x66
  417ceb:	0f 84 15 0a 00 00    	je     418706 <fmt_fp+0x21b6>
				p = MIN(p,MAX(0,9*(z-r-1)+e-j));
  417cf1:	48 63 c7             	movsxd rax,edi
  417cf4:	48 01 c8             	add    rax,rcx
  417cf7:	48 29 f0             	sub    rax,rsi
  417cfa:	b9 00 00 00 00       	mov    ecx,0x0
  417cff:	48 0f 48 c1          	cmovs  rax,rcx
  417d03:	48 39 d0             	cmp    rax,rdx
  417d06:	48 0f 4e d0          	cmovle rdx,rax
  417d0a:	48 89 14 24          	mov    QWORD PTR [rsp],rdx
  417d0e:	e9 e9 f5 ff ff       	jmp    4172fc <fmt_fp+0xdac>
		if (a>r) a=r;
  417d13:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
			if (d!=a) while (s>buf) *--s='0';
  417d18:	4c 8d 7c 24 69       	lea    r15,[rsp+0x69]
  417d1d:	4c 8b 15 cc 67 00 00 	mov    r10,QWORD PTR [rip+0x67cc]        # 41e4f0 <states+0x2b0>
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  417d24:	49 bd cd cc cc cc cc 	movabs r13,0xcccccccccccccccd
  417d2b:	cc cc cc 
  417d2e:	66 0f 6f 05 ba 67 00 	movdqa xmm0,XMMWORD PTR [rip+0x67ba]        # 41e4f0 <states+0x2b0>
  417d35:	00 
  417d36:	4c 89 ff             	mov    rdi,r15
  417d39:	48 39 e8             	cmp    rax,rbp
  417d3c:	48 0f 46 e8          	cmovbe rbp,rax
	if ((t|32)=='f') {
  417d40:	49 89 ee             	mov    r14,rbp
			char *s = fmt_u(*d, buf+9);
  417d43:	41 8b 0e             	mov    ecx,DWORD PTR [r14]
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  417d46:	48 85 c9             	test   rcx,rcx
  417d49:	0f 84 8e 03 00 00    	je     4180dd <fmt_fp+0x1b8d>
  417d4f:	90                   	nop
  417d50:	48 89 c8             	mov    rax,rcx
  417d53:	48 83 ef 01          	sub    rdi,0x1
  417d57:	49 f7 e5             	mul    r13
  417d5a:	48 89 c8             	mov    rax,rcx
  417d5d:	48 c1 ea 03          	shr    rdx,0x3
  417d61:	48 8d 34 92          	lea    rsi,[rdx+rdx*4]
  417d65:	48 01 f6             	add    rsi,rsi
  417d68:	48 29 f0             	sub    rax,rsi
  417d6b:	83 c0 30             	add    eax,0x30
  417d6e:	88 07                	mov    BYTE PTR [rdi],al
  417d70:	48 89 c8             	mov    rax,rcx
  417d73:	48 89 d1             	mov    rcx,rdx
  417d76:	48 83 f8 09          	cmp    rax,0x9
  417d7a:	77 d4                	ja     417d50 <fmt_fp+0x1800>
			if (d!=a) while (s>buf) *--s='0';
  417d7c:	4c 39 f5             	cmp    rbp,r14
  417d7f:	0f 84 fb 02 00 00    	je     418080 <fmt_fp+0x1b30>
  417d85:	48 8d 74 24 60       	lea    rsi,[rsp+0x60]
  417d8a:	48 39 f7             	cmp    rdi,rsi
  417d8d:	0f 86 eb 00 00 00    	jbe    417e7e <fmt_fp+0x192e>
  417d93:	4c 8d 47 ff          	lea    r8,[rdi-0x1]
  417d97:	48 89 f8             	mov    rax,rdi
  417d9a:	b9 01 00 00 00       	mov    ecx,0x1
  417d9f:	48 29 f0             	sub    rax,rsi
  417da2:	49 39 f0             	cmp    r8,rsi
  417da5:	48 0f 43 c8          	cmovae rcx,rax
  417da9:	48 83 e8 01          	sub    rax,0x1
  417dad:	48 83 f8 0e          	cmp    rax,0xe
  417db1:	0f 86 d3 08 00 00    	jbe    41868a <fmt_fp+0x213a>
  417db7:	49 39 f0             	cmp    r8,rsi
  417dba:	0f 82 ca 08 00 00    	jb     41868a <fmt_fp+0x213a>
  417dc0:	48 89 c8             	mov    rax,rcx
  417dc3:	48 89 fa             	mov    rdx,rdi
  417dc6:	48 83 e0 f0          	and    rax,0xfffffffffffffff0
  417dca:	48 29 c2             	sub    rdx,rax
  417dcd:	48 89 f8             	mov    rax,rdi
  417dd0:	0f 11 40 f0          	movups XMMWORD PTR [rax-0x10],xmm0
  417dd4:	48 83 e8 10          	sub    rax,0x10
  417dd8:	48 39 c2             	cmp    rdx,rax
  417ddb:	75 f3                	jne    417dd0 <fmt_fp+0x1880>
  417ddd:	48 89 ca             	mov    rdx,rcx
  417de0:	48 89 f8             	mov    rax,rdi
  417de3:	48 83 e2 f0          	and    rdx,0xfffffffffffffff0
  417de7:	48 29 d0             	sub    rax,rdx
  417dea:	48 39 d1             	cmp    rcx,rdx
  417ded:	74 78                	je     417e67 <fmt_fp+0x1917>
  417def:	48 29 d1             	sub    rcx,rdx
  417df2:	4c 8d 49 ff          	lea    r9,[rcx-0x1]
  417df6:	49 83 f9 06          	cmp    r9,0x6
  417dfa:	76 19                	jbe    417e15 <fmt_fp+0x18c5>
  417dfc:	49 89 f9             	mov    r9,rdi
  417dff:	49 29 d1             	sub    r9,rdx
  417e02:	48 89 ca             	mov    rdx,rcx
  417e05:	48 83 e2 f8          	and    rdx,0xfffffffffffffff8
  417e09:	4d 89 51 f8          	mov    QWORD PTR [r9-0x8],r10
  417e0d:	48 29 d0             	sub    rax,rdx
  417e10:	48 39 d1             	cmp    rcx,rdx
  417e13:	74 52                	je     417e67 <fmt_fp+0x1917>
  417e15:	48 8d 50 ff          	lea    rdx,[rax-0x1]
  417e19:	c6 40 ff 30          	mov    BYTE PTR [rax-0x1],0x30
  417e1d:	48 39 d6             	cmp    rsi,rdx
  417e20:	73 45                	jae    417e67 <fmt_fp+0x1917>
  417e22:	48 8d 50 fe          	lea    rdx,[rax-0x2]
  417e26:	c6 40 fe 30          	mov    BYTE PTR [rax-0x2],0x30
  417e2a:	48 39 d6             	cmp    rsi,rdx
  417e2d:	73 38                	jae    417e67 <fmt_fp+0x1917>
  417e2f:	48 8d 50 fd          	lea    rdx,[rax-0x3]
  417e33:	c6 40 fd 30          	mov    BYTE PTR [rax-0x3],0x30
  417e37:	48 39 d6             	cmp    rsi,rdx
  417e3a:	73 2b                	jae    417e67 <fmt_fp+0x1917>
  417e3c:	48 8d 50 fc          	lea    rdx,[rax-0x4]
  417e40:	c6 40 fc 30          	mov    BYTE PTR [rax-0x4],0x30
  417e44:	48 39 d6             	cmp    rsi,rdx
  417e47:	73 1e                	jae    417e67 <fmt_fp+0x1917>
  417e49:	48 8d 50 fb          	lea    rdx,[rax-0x5]
  417e4d:	c6 40 fb 30          	mov    BYTE PTR [rax-0x5],0x30
  417e51:	48 39 d6             	cmp    rsi,rdx
  417e54:	73 11                	jae    417e67 <fmt_fp+0x1917>
  417e56:	48 8d 50 fa          	lea    rdx,[rax-0x6]
  417e5a:	c6 40 fa 30          	mov    BYTE PTR [rax-0x6],0x30
  417e5e:	48 39 d6             	cmp    rsi,rdx
  417e61:	73 04                	jae    417e67 <fmt_fp+0x1917>
  417e63:	c6 40 f9 30          	mov    BYTE PTR [rax-0x7],0x30
  417e67:	48 89 f0             	mov    rax,rsi
  417e6a:	48 c7 c2 ff ff ff ff 	mov    rdx,0xffffffffffffffff
  417e71:	48 29 f8             	sub    rax,rdi
  417e74:	49 39 f0             	cmp    r8,rsi
  417e77:	48 0f 42 c2          	cmovb  rax,rdx
  417e7b:	48 01 c7             	add    rdi,rax
			out(f, s, buf+9-s);
  417e7e:	4c 89 fe             	mov    rsi,r15
  417e81:	48 29 fe             	sub    rsi,rdi
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417e84:	41 f6 04 24 20       	test   BYTE PTR [r12],0x20
  417e89:	0f 84 19 02 00 00    	je     4180a8 <fmt_fp+0x1b58>
		for (d=a; d<=r; d++) {
  417e8f:	49 8d 7e 04          	lea    rdi,[r14+0x4]
  417e93:	48 3b 7c 24 18       	cmp    rdi,QWORD PTR [rsp+0x18]
  417e98:	0f 87 68 01 00 00    	ja     418006 <fmt_fp+0x1ab6>
			if (d!=a) while (s>buf) *--s='0';
  417e9e:	4c 8d 54 24 69       	lea    r10,[rsp+0x69]
  417ea3:	4c 8d 4c 24 60       	lea    r9,[rsp+0x60]
  417ea8:	4c 8b 3d 41 66 00 00 	mov    r15,QWORD PTR [rip+0x6641]        # 41e4f0 <states+0x2b0>
  417eaf:	66 0f 6f 05 39 66 00 	movdqa xmm0,XMMWORD PTR [rip+0x6639]        # 41e4f0 <states+0x2b0>
  417eb6:	00 
  417eb7:	41 be 01 00 00 00    	mov    r14d,0x1
  417ebd:	49 c7 c3 f8 ff ff ff 	mov    r11,0xfffffffffffffff8
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  417ec4:	49 b8 cd cc cc cc cc 	movabs r8,0xcccccccccccccccd
  417ecb:	cc cc cc 
			char *s = fmt_u(*d, buf+9);
  417ece:	8b 0f                	mov    ecx,DWORD PTR [rdi]
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  417ed0:	4c 89 d6             	mov    rsi,r10
  417ed3:	48 85 c9             	test   rcx,rcx
  417ed6:	0f 84 40 02 00 00    	je     41811c <fmt_fp+0x1bcc>
  417edc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  417ee0:	48 89 c8             	mov    rax,rcx
  417ee3:	48 83 ee 01          	sub    rsi,0x1
  417ee7:	49 f7 e0             	mul    r8
  417eea:	48 89 c8             	mov    rax,rcx
  417eed:	48 c1 ea 03          	shr    rdx,0x3
  417ef1:	4c 8d 2c 92          	lea    r13,[rdx+rdx*4]
  417ef5:	4d 01 ed             	add    r13,r13
  417ef8:	4c 29 e8             	sub    rax,r13
  417efb:	83 c0 30             	add    eax,0x30
  417efe:	88 06                	mov    BYTE PTR [rsi],al
  417f00:	48 89 c8             	mov    rax,rcx
  417f03:	48 89 d1             	mov    rcx,rdx
  417f06:	48 83 f8 09          	cmp    rax,0x9
  417f0a:	77 d4                	ja     417ee0 <fmt_fp+0x1990>
			if (d!=a) while (s>buf) *--s='0';
  417f0c:	48 39 fd             	cmp    rbp,rdi
  417f0f:	0f 84 5b 01 00 00    	je     418070 <fmt_fp+0x1b20>
  417f15:	4c 39 ce             	cmp    rsi,r9
  417f18:	0f 86 d9 00 00 00    	jbe    417ff7 <fmt_fp+0x1aa7>
  417f1e:	4c 8d 6e ff          	lea    r13,[rsi-0x1]
  417f22:	48 89 f1             	mov    rcx,rsi
  417f25:	4c 89 f2             	mov    rdx,r14
  417f28:	48 89 f0             	mov    rax,rsi
  417f2b:	4c 29 c9             	sub    rcx,r9
  417f2e:	4d 39 cd             	cmp    r13,r9
  417f31:	48 0f 43 d1          	cmovae rdx,rcx
  417f35:	48 83 e9 01          	sub    rcx,0x1
  417f39:	48 83 f9 0e          	cmp    rcx,0xe
  417f3d:	0f 86 51 07 00 00    	jbe    418694 <fmt_fp+0x2144>
  417f43:	4d 39 cd             	cmp    r13,r9
  417f46:	0f 82 48 07 00 00    	jb     418694 <fmt_fp+0x2144>
  417f4c:	49 89 d5             	mov    r13,rdx
  417f4f:	48 89 f1             	mov    rcx,rsi
  417f52:	49 83 e5 f0          	and    r13,0xfffffffffffffff0
  417f56:	4c 29 e9             	sub    rcx,r13
  417f59:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  417f60:	0f 11 40 f0          	movups XMMWORD PTR [rax-0x10],xmm0
  417f64:	48 83 e8 10          	sub    rax,0x10
  417f68:	48 39 c1             	cmp    rcx,rax
  417f6b:	75 f3                	jne    417f60 <fmt_fp+0x1a10>
  417f6d:	48 89 d1             	mov    rcx,rdx
  417f70:	48 89 f0             	mov    rax,rsi
  417f73:	48 83 e1 f0          	and    rcx,0xfffffffffffffff0
  417f77:	48 29 c8             	sub    rax,rcx
  417f7a:	48 39 d1             	cmp    rcx,rdx
  417f7d:	74 78                	je     417ff7 <fmt_fp+0x1aa7>
  417f7f:	48 29 ca             	sub    rdx,rcx
  417f82:	4c 8d 6a ff          	lea    r13,[rdx-0x1]
  417f86:	49 83 fd 06          	cmp    r13,0x6
  417f8a:	76 19                	jbe    417fa5 <fmt_fp+0x1a55>
  417f8c:	4d 89 dd             	mov    r13,r11
  417f8f:	49 29 cd             	sub    r13,rcx
  417f92:	48 89 d1             	mov    rcx,rdx
  417f95:	48 83 e1 f8          	and    rcx,0xfffffffffffffff8
  417f99:	4e 89 3c 2e          	mov    QWORD PTR [rsi+r13*1],r15
  417f9d:	48 29 c8             	sub    rax,rcx
  417fa0:	48 39 ca             	cmp    rdx,rcx
  417fa3:	74 52                	je     417ff7 <fmt_fp+0x1aa7>
  417fa5:	48 8d 50 ff          	lea    rdx,[rax-0x1]
  417fa9:	c6 40 ff 30          	mov    BYTE PTR [rax-0x1],0x30
  417fad:	49 39 d1             	cmp    r9,rdx
  417fb0:	73 45                	jae    417ff7 <fmt_fp+0x1aa7>
  417fb2:	48 8d 50 fe          	lea    rdx,[rax-0x2]
  417fb6:	c6 40 fe 30          	mov    BYTE PTR [rax-0x2],0x30
  417fba:	49 39 d1             	cmp    r9,rdx
  417fbd:	73 38                	jae    417ff7 <fmt_fp+0x1aa7>
  417fbf:	48 8d 50 fd          	lea    rdx,[rax-0x3]
  417fc3:	c6 40 fd 30          	mov    BYTE PTR [rax-0x3],0x30
  417fc7:	49 39 d1             	cmp    r9,rdx
  417fca:	73 2b                	jae    417ff7 <fmt_fp+0x1aa7>
  417fcc:	48 8d 50 fc          	lea    rdx,[rax-0x4]
  417fd0:	c6 40 fc 30          	mov    BYTE PTR [rax-0x4],0x30
  417fd4:	49 39 d1             	cmp    r9,rdx
  417fd7:	73 1e                	jae    417ff7 <fmt_fp+0x1aa7>
  417fd9:	48 8d 50 fb          	lea    rdx,[rax-0x5]
  417fdd:	c6 40 fb 30          	mov    BYTE PTR [rax-0x5],0x30
  417fe1:	49 39 d1             	cmp    r9,rdx
  417fe4:	73 11                	jae    417ff7 <fmt_fp+0x1aa7>
  417fe6:	48 8d 50 fa          	lea    rdx,[rax-0x6]
  417fea:	c6 40 fa 30          	mov    BYTE PTR [rax-0x6],0x30
  417fee:	49 39 d1             	cmp    r9,rdx
  417ff1:	73 04                	jae    417ff7 <fmt_fp+0x1aa7>
  417ff3:	c6 40 f9 30          	mov    BYTE PTR [rax-0x7],0x30
		for (d=a; d<=r; d++) {
  417ff7:	48 83 c7 04          	add    rdi,0x4
  417ffb:	48 39 7c 24 18       	cmp    QWORD PTR [rsp+0x18],rdi
  418000:	0f 83 c8 fe ff ff    	jae    417ece <fmt_fp+0x197e>
  418006:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  41800b:	48 89 c8             	mov    rax,rcx
  41800e:	48 83 c1 01          	add    rcx,0x1
  418012:	48 29 e8             	sub    rax,rbp
  418015:	48 c1 e8 02          	shr    rax,0x2
  418019:	4c 8d 0c 85 04 00 00 	lea    r9,[rax*4+0x4]
  418020:	00 
  418021:	48 8d 45 01          	lea    rax,[rbp+0x1]
  418025:	48 39 c1             	cmp    rcx,rax
  418028:	b8 04 00 00 00       	mov    eax,0x4
		if (p || (fl&ALT_FORM)) out(f, ".", 1);
  41802d:	8b 0c 24             	mov    ecx,DWORD PTR [rsp]
		for (d=a; d<=r; d++) {
  418030:	4c 0f 42 c8          	cmovb  r9,rax
  418034:	4e 8d 74 0d 00       	lea    r14,[rbp+r9*1+0x0]
		if (p || (fl&ALT_FORM)) out(f, ".", 1);
  418039:	85 c9                	test   ecx,ecx
  41803b:	0f 85 35 02 00 00    	jne    418276 <fmt_fp+0x1d26>
  418041:	f6 44 24 14 08       	test   BYTE PTR [rsp+0x14],0x8
  418046:	0f 84 c4 f6 ff ff    	je     417710 <fmt_fp+0x11c0>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41804c:	41 f6 04 24 20       	test   BYTE PTR [r12],0x20
  418051:	0f 85 b9 f6 ff ff    	jne    417710 <fmt_fp+0x11c0>
  418057:	4c 89 e2             	mov    rdx,r12
  41805a:	be 01 00 00 00       	mov    esi,0x1
  41805f:	48 8d 3d b5 60 00 00 	lea    rdi,[rip+0x60b5]        # 41e11b <CSWTCH.186+0x7cb>
  418066:	e8 e5 27 00 00       	call   41a850 <__fwritex>
  41806b:	e9 11 02 00 00       	jmp    418281 <fmt_fp+0x1d31>
			else if (s==buf+9) *--s='0';
  418070:	4c 39 d6             	cmp    rsi,r10
  418073:	75 82                	jne    417ff7 <fmt_fp+0x1aa7>
  418075:	c6 44 24 68 30       	mov    BYTE PTR [rsp+0x68],0x30
  41807a:	e9 78 ff ff ff       	jmp    417ff7 <fmt_fp+0x1aa7>
  41807f:	90                   	nop
  418080:	4c 39 ff             	cmp    rdi,r15
  418083:	0f 85 f5 fd ff ff    	jne    417e7e <fmt_fp+0x192e>
  418089:	c6 44 24 68 30       	mov    BYTE PTR [rsp+0x68],0x30
  41808e:	be 01 00 00 00       	mov    esi,0x1
  418093:	48 8d 7c 24 68       	lea    rdi,[rsp+0x68]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418098:	41 f6 04 24 20       	test   BYTE PTR [r12],0x20
  41809d:	0f 85 ec fd ff ff    	jne    417e8f <fmt_fp+0x193f>
  4180a3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  4180a8:	4c 89 e2             	mov    rdx,r12
		for (d=a; d<=r; d++) {
  4180ab:	49 83 c6 04          	add    r14,0x4
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4180af:	e8 9c 27 00 00       	call   41a850 <__fwritex>
		for (d=a; d<=r; d++) {
  4180b4:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  4180b9:	4c 8b 15 30 64 00 00 	mov    r10,QWORD PTR [rip+0x6430]        # 41e4f0 <states+0x2b0>
  4180c0:	66 0f 6f 05 28 64 00 	movdqa xmm0,XMMWORD PTR [rip+0x6428]        # 41e4f0 <states+0x2b0>
  4180c7:	00 
  4180c8:	0f 82 38 ff ff ff    	jb     418006 <fmt_fp+0x1ab6>
			char *s = fmt_u(*d, buf+9);
  4180ce:	41 8b 0e             	mov    ecx,DWORD PTR [r14]
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  4180d1:	4c 89 ff             	mov    rdi,r15
  4180d4:	48 85 c9             	test   rcx,rcx
  4180d7:	0f 85 73 fc ff ff    	jne    417d50 <fmt_fp+0x1800>
			if (d!=a) while (s>buf) *--s='0';
  4180dd:	48 8d 74 24 60       	lea    rsi,[rsp+0x60]
  4180e2:	4c 39 f5             	cmp    rbp,r14
  4180e5:	0f 85 a8 fc ff ff    	jne    417d93 <fmt_fp+0x1843>
  4180eb:	eb 9c                	jmp    418089 <fmt_fp+0x1b39>
		if (e > INT_MAX-l) return -1;
  4180ed:	44 39 d7             	cmp    edi,r10d
  4180f0:	0f 8f 97 fa ff ff    	jg     417b8d <fmt_fp+0x163d>
		if (e>0) l+=e;
  4180f6:	41 8d 04 38          	lea    eax,[r8+rdi*1]
  4180fa:	85 ff                	test   edi,edi
  4180fc:	44 0f 4f c0          	cmovg  r8d,eax
  418100:	e9 da f2 ff ff       	jmp    4173df <fmt_fp+0xe8f>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418105:	48 8b 74 24 30       	mov    rsi,QWORD PTR [rsp+0x30]
  41810a:	48 8b 7c 24 20       	mov    rdi,QWORD PTR [rsp+0x20]
  41810f:	4c 89 e2             	mov    rdx,r12
  418112:	e8 39 27 00 00       	call   41a850 <__fwritex>
  418117:	e9 ad f3 ff ff       	jmp    4174c9 <fmt_fp+0xf79>
			if (d!=a) while (s>buf) *--s='0';
  41811c:	48 39 fd             	cmp    rbp,rdi
  41811f:	0f 85 f9 fd ff ff    	jne    417f1e <fmt_fp+0x19ce>
  418125:	e9 4b ff ff ff       	jmp    418075 <fmt_fp+0x1b25>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41812a:	41 83 e1 20          	and    r9d,0x20
  41812e:	41 89 da             	mov    r10d,ebx
  418131:	49 89 fd             	mov    r13,rdi
  418134:	e9 93 f7 ff ff       	jmp    4178cc <fmt_fp+0x137c>
  418139:	d9 7c 24 4e          	fnstcw WORD PTR [rsp+0x4e]
  41813d:	d9 05 1d 63 00 00    	fld    DWORD PTR [rip+0x631d]        # 41e460 <states+0x220>
  418143:	d9 ca                	fxch   st(2)
		s=buf;
  418145:	4c 89 e8             	mov    rax,r13
  418148:	48 8d 0d e1 60 00 00 	lea    rcx,[rip+0x60e1]        # 41e230 <xdigits>
  41814f:	0f b7 54 24 4e       	movzx  edx,WORD PTR [rsp+0x4e]
  418154:	80 ce 0c             	or     dh,0xc
  418157:	66 89 54 24 4c       	mov    WORD PTR [rsp+0x4c],dx
  41815c:	eb 15                	jmp    418173 <fmt_fp+0x1c23>
  41815e:	66 90                	xchg   ax,ax
			*s++=xdigits[x]|(t&32);
  418160:	48 89 d0             	mov    rax,rdx
		} while (y);
  418163:	d9 c1                	fld    st(1)
  418165:	d9 c9                	fxch   st(1)
  418167:	db e9                	fucomi st,st(1)
  418169:	dd d9                	fstp   st(1)
  41816b:	7a 06                	jp     418173 <fmt_fp+0x1c23>
  41816d:	0f 84 69 ea ff ff    	je     416bdc <fmt_fp+0x68c>
			int x=y;
  418173:	d9 c0                	fld    st(0)
  418175:	d9 6c 24 4c          	fldcw  WORD PTR [rsp+0x4c]
  418179:	db 5c 24 08          	fistp  DWORD PTR [rsp+0x8]
  41817d:	d9 6c 24 4e          	fldcw  WORD PTR [rsp+0x4e]
			y=16*(y-x);
  418181:	db 44 24 08          	fild   DWORD PTR [rsp+0x8]
			*s++=xdigits[x]|(t&32);
  418185:	48 63 54 24 08       	movsxd rdx,DWORD PTR [rsp+0x8]
  41818a:	0f b6 3c 11          	movzx  edi,BYTE PTR [rcx+rdx*1]
			if (s-buf==1 && (y||p>0||(fl&ALT_FORM))) *s++='.';
  41818e:	48 8d 50 01          	lea    rdx,[rax+0x1]
			y=16*(y-x);
  418192:	de e9                	fsubp  st(1),st
			*s++=xdigits[x]|(t&32);
  418194:	09 f7                	or     edi,esi
  418196:	40 88 38             	mov    BYTE PTR [rax],dil
			y=16*(y-x);
  418199:	d8 ca                	fmul   st,st(2)
			if (s-buf==1 && (y||p>0||(fl&ALT_FORM))) *s++='.';
  41819b:	4c 39 e8             	cmp    rax,r13
  41819e:	75 c0                	jne    418160 <fmt_fp+0x1c10>
  4181a0:	c6 40 01 2e          	mov    BYTE PTR [rax+0x1],0x2e
  4181a4:	48 83 c0 02          	add    rax,0x2
  4181a8:	eb b9                	jmp    418163 <fmt_fp+0x1c13>
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  4181aa:	4c 8d bc 24 80 00 00 	lea    r15,[rsp+0x80]
  4181b1:	00 
  4181b2:	ba 00 01 00 00       	mov    edx,0x100
  4181b7:	be 30 00 00 00       	mov    esi,0x30
  4181bc:	4c 89 ff             	mov    rdi,r15
  4181bf:	e8 c8 cb ff ff       	call   414d8c <memset>
	for (; l >= sizeof pad; l -= sizeof pad)
  4181c4:	e9 fe f4 ff ff       	jmp    4176c7 <fmt_fp+0x1177>
			if (s==buf+9) *--s='0';
  4181c9:	48 89 f8             	mov    rax,rdi
  4181cc:	45 31 d2             	xor    r10d,r10d
  4181cf:	e9 5b f6 ff ff       	jmp    41782f <fmt_fp+0x12df>
				*d = *d + i;
  4181d4:	44 01 d0             	add    eax,r10d
  4181d7:	89 06                	mov    DWORD PTR [rsi],eax
				while (*d > 999999999) {
  4181d9:	3d ff c9 9a 3b       	cmp    eax,0x3b9ac9ff
  4181de:	77 2a                	ja     41820a <fmt_fp+0x1cba>
  4181e0:	e9 b1 06 00 00       	jmp    418896 <fmt_fp+0x2346>
  4181e5:	0f 1f 00             	nop    DWORD PTR [rax]
					if (d<a) *--a=0;
  4181e8:	c7 45 fc 00 00 00 00 	mov    DWORD PTR [rbp-0x4],0x0
					(*d)++;
  4181ef:	8b 7e fc             	mov    edi,DWORD PTR [rsi-0x4]
					if (d<a) *--a=0;
  4181f2:	48 8d 4d fc          	lea    rcx,[rbp-0x4]
  4181f6:	48 89 cd             	mov    rbp,rcx
					(*d)++;
  4181f9:	8d 57 01             	lea    edx,[rdi+0x1]
  4181fc:	89 56 fc             	mov    DWORD PTR [rsi-0x4],edx
				while (*d > 999999999) {
  4181ff:	81 fa ff c9 9a 3b    	cmp    edx,0x3b9ac9ff
  418205:	76 24                	jbe    41822b <fmt_fp+0x1cdb>
			if (pl && *prefix=='-') round*=-1, small*=-1;
  418207:	48 89 c6             	mov    rsi,rax
					*d--=0;
  41820a:	48 8d 46 fc          	lea    rax,[rsi-0x4]
  41820e:	c7 40 04 00 00 00 00 	mov    DWORD PTR [rax+0x4],0x0
					if (d<a) *--a=0;
  418215:	48 39 e8             	cmp    rax,rbp
  418218:	72 ce                	jb     4181e8 <fmt_fp+0x1c98>
					(*d)++;
  41821a:	8b 4e fc             	mov    ecx,DWORD PTR [rsi-0x4]
  41821d:	8d 51 01             	lea    edx,[rcx+0x1]
  418220:	89 56 fc             	mov    DWORD PTR [rsi-0x4],edx
				while (*d > 999999999) {
  418223:	81 fa ff c9 9a 3b    	cmp    edx,0x3b9ac9ff
  418229:	77 dc                	ja     418207 <fmt_fp+0x1cb7>
				for (i=10, e=9*(r-a); *a>=i; i*=10, e++);
  41822b:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  418230:	8b 55 00             	mov    edx,DWORD PTR [rbp+0x0]
  418233:	48 29 e8             	sub    rax,rbp
  418236:	48 c1 f8 02          	sar    rax,0x2
  41823a:	8d 3c c0             	lea    edi,[rax+rax*8]
  41823d:	83 fa 09             	cmp    edx,0x9
  418240:	0f 86 89 f0 ff ff    	jbe    4172cf <fmt_fp+0xd7f>
  418246:	b8 0a 00 00 00       	mov    eax,0xa
  41824b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  418250:	8d 04 80             	lea    eax,[rax+rax*4]
  418253:	83 c7 01             	add    edi,0x1
  418256:	01 c0                	add    eax,eax
  418258:	39 d0                	cmp    eax,edx
  41825a:	76 f4                	jbe    418250 <fmt_fp+0x1d00>
  41825c:	e9 6e f0 ff ff       	jmp    4172cf <fmt_fp+0xd7f>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418261:	48 8b 7c 24 20       	mov    rdi,QWORD PTR [rsp+0x20]
		out(f, prefix, pl);
  418266:	48 63 f3             	movsxd rsi,ebx
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418269:	4c 89 e2             	mov    rdx,r12
  41826c:	e8 df 25 00 00       	call   41a850 <__fwritex>
  418271:	e9 a5 ea ff ff       	jmp    416d1b <fmt_fp+0x7cb>
  418276:	41 f6 04 24 20       	test   BYTE PTR [r12],0x20
  41827b:	0f 84 d6 fd ff ff    	je     418057 <fmt_fp+0x1b07>
		for (; d<z && p>0; d++, p-=9) {
  418281:	8b 14 24             	mov    edx,DWORD PTR [rsp]
  418284:	85 d2                	test   edx,edx
  418286:	0f 8e 84 f4 ff ff    	jle    417710 <fmt_fp+0x11c0>
  41828c:	49 39 de             	cmp    r14,rbx
  41828f:	0f 83 dd 02 00 00    	jae    418572 <fmt_fp+0x2022>
  418295:	4c 8d 6c 24 60       	lea    r13,[rsp+0x60]
  41829a:	48 8d 4c 24 69       	lea    rcx,[rsp+0x69]
			while (s>buf) *--s='0';
  41829f:	4c 8b 15 4a 62 00 00 	mov    r10,QWORD PTR [rip+0x624a]        # 41e4f0 <states+0x2b0>
  4182a6:	66 0f 6f 05 42 62 00 	movdqa xmm0,XMMWORD PTR [rip+0x6242]        # 41e4f0 <states+0x2b0>
  4182ad:	00 
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  4182ae:	48 bd cd cc cc cc cc 	movabs rbp,0xcccccccccccccccd
  4182b5:	cc cc cc 
  4182b8:	41 bf 01 00 00 00    	mov    r15d,0x1
			char *s = fmt_u(*d, buf+9);
  4182be:	41 8b 36             	mov    esi,DWORD PTR [r14]
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  4182c1:	48 89 cf             	mov    rdi,rcx
  4182c4:	48 85 f6             	test   rsi,rsi
  4182c7:	74 3c                	je     418305 <fmt_fp+0x1db5>
  4182c9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  4182d0:	48 89 f0             	mov    rax,rsi
  4182d3:	48 83 ef 01          	sub    rdi,0x1
  4182d7:	48 f7 e5             	mul    rbp
  4182da:	48 89 f0             	mov    rax,rsi
  4182dd:	48 c1 ea 03          	shr    rdx,0x3
  4182e1:	4c 8d 04 92          	lea    r8,[rdx+rdx*4]
  4182e5:	4d 01 c0             	add    r8,r8
  4182e8:	4c 29 c0             	sub    rax,r8
  4182eb:	83 c0 30             	add    eax,0x30
  4182ee:	88 07                	mov    BYTE PTR [rdi],al
  4182f0:	48 89 f0             	mov    rax,rsi
  4182f3:	48 89 d6             	mov    rsi,rdx
  4182f6:	48 83 f8 09          	cmp    rax,0x9
  4182fa:	77 d4                	ja     4182d0 <fmt_fp+0x1d80>
			while (s>buf) *--s='0';
  4182fc:	4c 39 ef             	cmp    rdi,r13
  4182ff:	0f 86 e9 00 00 00    	jbe    4183ee <fmt_fp+0x1e9e>
  418305:	4c 8d 4f ff          	lea    r9,[rdi-0x1]
  418309:	48 89 f8             	mov    rax,rdi
  41830c:	4c 89 fa             	mov    rdx,r15
  41830f:	4c 29 e8             	sub    rax,r13
  418312:	4d 39 e9             	cmp    r9,r13
  418315:	48 0f 43 d0          	cmovae rdx,rax
  418319:	48 83 e8 01          	sub    rax,0x1
  41831d:	48 83 f8 0e          	cmp    rax,0xe
  418321:	0f 86 3d 03 00 00    	jbe    418664 <fmt_fp+0x2114>
  418327:	4d 39 e9             	cmp    r9,r13
  41832a:	0f 82 34 03 00 00    	jb     418664 <fmt_fp+0x2114>
  418330:	48 89 d0             	mov    rax,rdx
  418333:	48 89 fe             	mov    rsi,rdi
  418336:	48 83 e0 f0          	and    rax,0xfffffffffffffff0
  41833a:	48 29 c6             	sub    rsi,rax
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  41833d:	48 89 f8             	mov    rax,rdi
			while (s>buf) *--s='0';
  418340:	0f 11 40 f0          	movups XMMWORD PTR [rax-0x10],xmm0
  418344:	48 83 e8 10          	sub    rax,0x10
  418348:	48 39 f0             	cmp    rax,rsi
  41834b:	75 f3                	jne    418340 <fmt_fp+0x1df0>
  41834d:	48 89 d6             	mov    rsi,rdx
  418350:	48 89 f8             	mov    rax,rdi
  418353:	48 83 e6 f0          	and    rsi,0xfffffffffffffff0
  418357:	48 29 f0             	sub    rax,rsi
  41835a:	48 39 d6             	cmp    rsi,rdx
  41835d:	74 78                	je     4183d7 <fmt_fp+0x1e87>
  41835f:	48 29 f2             	sub    rdx,rsi
  418362:	4c 8d 5a ff          	lea    r11,[rdx-0x1]
  418366:	49 83 fb 06          	cmp    r11,0x6
  41836a:	76 19                	jbe    418385 <fmt_fp+0x1e35>
  41836c:	49 89 fb             	mov    r11,rdi
  41836f:	49 29 f3             	sub    r11,rsi
  418372:	48 89 d6             	mov    rsi,rdx
  418375:	48 83 e6 f8          	and    rsi,0xfffffffffffffff8
  418379:	4d 89 53 f8          	mov    QWORD PTR [r11-0x8],r10
  41837d:	48 29 f0             	sub    rax,rsi
  418380:	48 39 f2             	cmp    rdx,rsi
  418383:	74 52                	je     4183d7 <fmt_fp+0x1e87>
  418385:	48 8d 50 ff          	lea    rdx,[rax-0x1]
  418389:	c6 40 ff 30          	mov    BYTE PTR [rax-0x1],0x30
  41838d:	49 39 d5             	cmp    r13,rdx
  418390:	73 45                	jae    4183d7 <fmt_fp+0x1e87>
  418392:	48 8d 50 fe          	lea    rdx,[rax-0x2]
  418396:	c6 40 fe 30          	mov    BYTE PTR [rax-0x2],0x30
  41839a:	49 39 d5             	cmp    r13,rdx
  41839d:	73 38                	jae    4183d7 <fmt_fp+0x1e87>
  41839f:	48 8d 50 fd          	lea    rdx,[rax-0x3]
  4183a3:	c6 40 fd 30          	mov    BYTE PTR [rax-0x3],0x30
  4183a7:	49 39 d5             	cmp    r13,rdx
  4183aa:	73 2b                	jae    4183d7 <fmt_fp+0x1e87>
  4183ac:	48 8d 50 fc          	lea    rdx,[rax-0x4]
  4183b0:	c6 40 fc 30          	mov    BYTE PTR [rax-0x4],0x30
  4183b4:	49 39 d5             	cmp    r13,rdx
  4183b7:	73 1e                	jae    4183d7 <fmt_fp+0x1e87>
  4183b9:	48 8d 50 fb          	lea    rdx,[rax-0x5]
  4183bd:	c6 40 fb 30          	mov    BYTE PTR [rax-0x5],0x30
  4183c1:	49 39 d5             	cmp    r13,rdx
  4183c4:	73 11                	jae    4183d7 <fmt_fp+0x1e87>
  4183c6:	48 8d 50 fa          	lea    rdx,[rax-0x6]
  4183ca:	c6 40 fa 30          	mov    BYTE PTR [rax-0x6],0x30
  4183ce:	49 39 d5             	cmp    r13,rdx
  4183d1:	73 04                	jae    4183d7 <fmt_fp+0x1e87>
  4183d3:	c6 40 f9 30          	mov    BYTE PTR [rax-0x7],0x30
  4183d7:	4c 89 e8             	mov    rax,r13
  4183da:	48 c7 c2 ff ff ff ff 	mov    rdx,0xffffffffffffffff
  4183e1:	48 29 f8             	sub    rax,rdi
  4183e4:	4d 39 e9             	cmp    r9,r13
  4183e7:	48 0f 42 c2          	cmovb  rax,rdx
  4183eb:	48 01 c7             	add    rdi,rax
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4183ee:	41 f6 04 24 20       	test   BYTE PTR [r12],0x20
  4183f3:	0f 84 0f 02 00 00    	je     418608 <fmt_fp+0x20b8>
		for (; d<z && p>0; d++, p-=9) {
  4183f9:	4d 8d 4e 04          	lea    r9,[r14+0x4]
  4183fd:	83 2c 24 09          	sub    DWORD PTR [rsp],0x9
  418401:	8b 2c 24             	mov    ebp,DWORD PTR [rsp]
  418404:	49 39 d9             	cmp    r9,rbx
  418407:	0f 83 65 01 00 00    	jae    418572 <fmt_fp+0x2022>
  41840d:	85 ed                	test   ebp,ebp
  41840f:	0f 8e fb f2 ff ff    	jle    417710 <fmt_fp+0x11c0>
			while (s>buf) *--s='0';
  418415:	4c 8b 35 d4 60 00 00 	mov    r14,QWORD PTR [rip+0x60d4]        # 41e4f0 <states+0x2b0>
  41841c:	66 0f 6f 05 cc 60 00 	movdqa xmm0,XMMWORD PTR [rip+0x60cc]        # 41e4f0 <states+0x2b0>
  418423:	00 
  418424:	41 bb 01 00 00 00    	mov    r11d,0x1
  41842a:	49 c7 c2 f8 ff ff ff 	mov    r10,0xfffffffffffffff8
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  418431:	49 b8 cd cc cc cc cc 	movabs r8,0xcccccccccccccccd
  418438:	cc cc cc 
			char *s = fmt_u(*d, buf+9);
  41843b:	41 8b 31             	mov    esi,DWORD PTR [r9]
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  41843e:	48 89 cf             	mov    rdi,rcx
  418441:	48 85 f6             	test   rsi,rsi
  418444:	74 3f                	je     418485 <fmt_fp+0x1f35>
  418446:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41844d:	00 00 00 
  418450:	48 89 f0             	mov    rax,rsi
  418453:	48 83 ef 01          	sub    rdi,0x1
  418457:	49 f7 e0             	mul    r8
  41845a:	48 89 f0             	mov    rax,rsi
  41845d:	48 c1 ea 03          	shr    rdx,0x3
  418461:	4c 8d 3c 92          	lea    r15,[rdx+rdx*4]
  418465:	4d 01 ff             	add    r15,r15
  418468:	4c 29 f8             	sub    rax,r15
  41846b:	83 c0 30             	add    eax,0x30
  41846e:	88 07                	mov    BYTE PTR [rdi],al
  418470:	48 89 f0             	mov    rax,rsi
  418473:	48 89 d6             	mov    rsi,rdx
  418476:	48 83 f8 09          	cmp    rax,0x9
  41847a:	77 d4                	ja     418450 <fmt_fp+0x1f00>
			while (s>buf) *--s='0';
  41847c:	4c 39 ef             	cmp    rdi,r13
  41847f:	0f 86 d2 00 00 00    	jbe    418557 <fmt_fp+0x2007>
  418485:	4c 8d 7f ff          	lea    r15,[rdi-0x1]
  418489:	48 89 fe             	mov    rsi,rdi
  41848c:	4c 89 da             	mov    rdx,r11
  41848f:	48 89 f8             	mov    rax,rdi
  418492:	4c 29 ee             	sub    rsi,r13
  418495:	4d 39 ef             	cmp    r15,r13
  418498:	48 0f 43 d6          	cmovae rdx,rsi
  41849c:	48 83 ee 01          	sub    rsi,0x1
  4184a0:	48 83 fe 0e          	cmp    rsi,0xe
  4184a4:	0f 86 b0 01 00 00    	jbe    41865a <fmt_fp+0x210a>
  4184aa:	4d 39 ef             	cmp    r15,r13
  4184ad:	0f 82 a7 01 00 00    	jb     41865a <fmt_fp+0x210a>
  4184b3:	49 89 d7             	mov    r15,rdx
  4184b6:	48 89 fe             	mov    rsi,rdi
  4184b9:	49 83 e7 f0          	and    r15,0xfffffffffffffff0
  4184bd:	4c 29 fe             	sub    rsi,r15
  4184c0:	0f 11 40 f0          	movups XMMWORD PTR [rax-0x10],xmm0
  4184c4:	48 83 e8 10          	sub    rax,0x10
  4184c8:	48 39 f0             	cmp    rax,rsi
  4184cb:	75 f3                	jne    4184c0 <fmt_fp+0x1f70>
  4184cd:	48 89 d6             	mov    rsi,rdx
  4184d0:	48 89 f8             	mov    rax,rdi
  4184d3:	48 83 e6 f0          	and    rsi,0xfffffffffffffff0
  4184d7:	48 29 f0             	sub    rax,rsi
  4184da:	48 39 d6             	cmp    rsi,rdx
  4184dd:	74 78                	je     418557 <fmt_fp+0x2007>
  4184df:	48 29 f2             	sub    rdx,rsi
  4184e2:	4c 8d 7a ff          	lea    r15,[rdx-0x1]
  4184e6:	49 83 ff 06          	cmp    r15,0x6
  4184ea:	76 19                	jbe    418505 <fmt_fp+0x1fb5>
  4184ec:	4d 89 d7             	mov    r15,r10
  4184ef:	49 29 f7             	sub    r15,rsi
  4184f2:	48 89 d6             	mov    rsi,rdx
  4184f5:	48 83 e6 f8          	and    rsi,0xfffffffffffffff8
  4184f9:	4e 89 34 3f          	mov    QWORD PTR [rdi+r15*1],r14
  4184fd:	48 29 f0             	sub    rax,rsi
  418500:	48 39 d6             	cmp    rsi,rdx
  418503:	74 52                	je     418557 <fmt_fp+0x2007>
  418505:	48 8d 50 ff          	lea    rdx,[rax-0x1]
  418509:	c6 40 ff 30          	mov    BYTE PTR [rax-0x1],0x30
  41850d:	49 39 d5             	cmp    r13,rdx
  418510:	73 45                	jae    418557 <fmt_fp+0x2007>
  418512:	48 8d 50 fe          	lea    rdx,[rax-0x2]
  418516:	c6 40 fe 30          	mov    BYTE PTR [rax-0x2],0x30
  41851a:	49 39 d5             	cmp    r13,rdx
  41851d:	73 38                	jae    418557 <fmt_fp+0x2007>
  41851f:	48 8d 50 fd          	lea    rdx,[rax-0x3]
  418523:	c6 40 fd 30          	mov    BYTE PTR [rax-0x3],0x30
  418527:	49 39 d5             	cmp    r13,rdx
  41852a:	73 2b                	jae    418557 <fmt_fp+0x2007>
  41852c:	48 8d 50 fc          	lea    rdx,[rax-0x4]
  418530:	c6 40 fc 30          	mov    BYTE PTR [rax-0x4],0x30
  418534:	49 39 d5             	cmp    r13,rdx
  418537:	73 1e                	jae    418557 <fmt_fp+0x2007>
  418539:	48 8d 50 fb          	lea    rdx,[rax-0x5]
  41853d:	c6 40 fb 30          	mov    BYTE PTR [rax-0x5],0x30
  418541:	49 39 d5             	cmp    r13,rdx
  418544:	73 11                	jae    418557 <fmt_fp+0x2007>
  418546:	48 8d 50 fa          	lea    rdx,[rax-0x6]
  41854a:	c6 40 fa 30          	mov    BYTE PTR [rax-0x6],0x30
  41854e:	49 39 d5             	cmp    r13,rdx
  418551:	73 04                	jae    418557 <fmt_fp+0x2007>
  418553:	c6 40 f9 30          	mov    BYTE PTR [rax-0x7],0x30
		for (; d<z && p>0; d++, p-=9) {
  418557:	83 ed 09             	sub    ebp,0x9
  41855a:	49 83 c1 04          	add    r9,0x4
  41855e:	85 ed                	test   ebp,ebp
  418560:	0f 8e aa f1 ff ff    	jle    417710 <fmt_fp+0x11c0>
  418566:	4c 39 cb             	cmp    rbx,r9
  418569:	0f 87 cc fe ff ff    	ja     41843b <fmt_fp+0x1eeb>
  41856f:	89 2c 24             	mov    DWORD PTR [rsp],ebp
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  418572:	8b 1c 24             	mov    ebx,DWORD PTR [rsp]
  418575:	85 db                	test   ebx,ebx
  418577:	0f 8e 93 f1 ff ff    	jle    417710 <fmt_fp+0x11c0>
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41857d:	81 fb 00 01 00 00    	cmp    ebx,0x100
  418583:	0f 8f c7 01 00 00    	jg     418750 <fmt_fp+0x2200>
  418589:	48 63 eb             	movsxd rbp,ebx
  41858c:	4c 8d bc 24 80 00 00 	lea    r15,[rsp+0x80]
  418593:	00 
  418594:	be 30 00 00 00       	mov    esi,0x30
  418599:	48 89 ea             	mov    rdx,rbp
  41859c:	4c 89 ff             	mov    rdi,r15
  41859f:	e8 e8 c7 ff ff       	call   414d8c <memset>
	for (; l >= sizeof pad; l -= sizeof pad)
  4185a4:	81 fb 00 01 00 00    	cmp    ebx,0x100
  4185aa:	0f 85 12 03 00 00    	jne    4188c2 <fmt_fp+0x2372>
  4185b0:	8b 1c 24             	mov    ebx,DWORD PTR [rsp]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4185b3:	41 8b 14 24          	mov    edx,DWORD PTR [r12]
  4185b7:	81 eb 00 01 00 00    	sub    ebx,0x100
  4185bd:	89 dd                	mov    ebp,ebx
  4185bf:	90                   	nop
  4185c0:	89 d0                	mov    eax,edx
  4185c2:	83 e0 20             	and    eax,0x20
  4185c5:	0f 84 55 01 00 00    	je     418720 <fmt_fp+0x21d0>
	for (; l >= sizeof pad; l -= sizeof pad)
  4185cb:	81 fd ff 00 00 00    	cmp    ebp,0xff
  4185d1:	76 12                	jbe    4185e5 <fmt_fp+0x2095>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4185d3:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  4185d5:	81 ed 00 01 00 00    	sub    ebp,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4185db:	89 d0                	mov    eax,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  4185dd:	81 fd ff 00 00 00    	cmp    ebp,0xff
  4185e3:	77 f0                	ja     4185d5 <fmt_fp+0x2085>
	out(f, pad, l);
  4185e5:	0f b6 eb             	movzx  ebp,bl
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4185e8:	85 c0                	test   eax,eax
  4185ea:	0f 85 20 f1 ff ff    	jne    417710 <fmt_fp+0x11c0>
  4185f0:	4c 89 e2             	mov    rdx,r12
  4185f3:	48 89 ee             	mov    rsi,rbp
  4185f6:	4c 89 ff             	mov    rdi,r15
  4185f9:	e8 52 22 00 00       	call   41a850 <__fwritex>
  4185fe:	e9 0d f1 ff ff       	jmp    417710 <fmt_fp+0x11c0>
  418603:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  418608:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
			out(f, s, MIN(9,p));
  41860d:	8b 0c 24             	mov    ecx,DWORD PTR [rsp]
  418610:	b8 09 00 00 00       	mov    eax,0x9
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418615:	4c 89 e2             	mov    rdx,r12
			out(f, s, MIN(9,p));
  418618:	39 c1                	cmp    ecx,eax
  41861a:	0f 4e c1             	cmovle eax,ecx
		for (; d<z && p>0; d++, p-=9) {
  41861d:	49 83 c6 04          	add    r14,0x4
			out(f, s, MIN(9,p));
  418621:	48 63 f0             	movsxd rsi,eax
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418624:	e8 27 22 00 00       	call   41a850 <__fwritex>
		for (; d<z && p>0; d++, p-=9) {
  418629:	83 2c 24 09          	sub    DWORD PTR [rsp],0x9
  41862d:	8b 0c 24             	mov    ecx,DWORD PTR [rsp]
  418630:	85 c9                	test   ecx,ecx
  418632:	0f 8e d8 f0 ff ff    	jle    417710 <fmt_fp+0x11c0>
  418638:	49 39 de             	cmp    r14,rbx
  41863b:	4c 8b 15 ae 5e 00 00 	mov    r10,QWORD PTR [rip+0x5eae]        # 41e4f0 <states+0x2b0>
  418642:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
  418647:	66 0f 6f 05 a1 5e 00 	movdqa xmm0,XMMWORD PTR [rip+0x5ea1]        # 41e4f0 <states+0x2b0>
  41864e:	00 
  41864f:	0f 82 69 fc ff ff    	jb     4182be <fmt_fp+0x1d6e>
  418655:	e9 18 ff ff ff       	jmp    418572 <fmt_fp+0x2022>
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  41865a:	48 89 f8             	mov    rax,rdi
  41865d:	31 f6                	xor    esi,esi
  41865f:	e9 7b fe ff ff       	jmp    4184df <fmt_fp+0x1f8f>
  418664:	48 89 f8             	mov    rax,rdi
  418667:	31 f6                	xor    esi,esi
  418669:	e9 f1 fc ff ff       	jmp    41835f <fmt_fp+0x1e0f>
			p--;
  41866e:	83 2c 24 01          	sub    DWORD PTR [rsp],0x1
			t-=2;
  418672:	41 83 ef 02          	sub    r15d,0x2
			p--;
  418676:	e9 03 f6 ff ff       	jmp    417c7e <fmt_fp+0x172e>
		if (estr==ebuf) *--estr='0';
  41867b:	c6 44 24 5f 30       	mov    BYTE PTR [rsp+0x5f],0x30
  418680:	48 8d 74 24 5f       	lea    rsi,[rsp+0x5f]
  418685:	e9 8b e4 ff ff       	jmp    416b15 <fmt_fp+0x5c5>
			if (d!=a) while (s>buf) *--s='0';
  41868a:	48 89 f8             	mov    rax,rdi
  41868d:	31 d2                	xor    edx,edx
  41868f:	e9 5b f7 ff ff       	jmp    417def <fmt_fp+0x189f>
  418694:	48 89 f0             	mov    rax,rsi
  418697:	31 c9                	xor    ecx,ecx
  418699:	e9 e1 f8 ff ff       	jmp    417f7f <fmt_fp+0x1a2f>
	out(f, pad, l);
  41869e:	48 63 f5             	movsxd rsi,ebp
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4186a1:	4c 89 e2             	mov    rdx,r12
  4186a4:	4c 89 ff             	mov    rdi,r15
  4186a7:	e8 a4 21 00 00       	call   41a850 <__fwritex>
  4186ac:	e9 f5 f0 ff ff       	jmp    4177a6 <fmt_fp+0x1256>
			if ((*d/i & 1) || (i==1000000000 && d>a && (d[-1]&1)))
  4186b1:	81 f9 00 ca 9a 3b    	cmp    ecx,0x3b9aca00
  4186b7:	75 0f                	jne    4186c8 <fmt_fp+0x2178>
  4186b9:	48 39 ee             	cmp    rsi,rbp
  4186bc:	76 0a                	jbe    4186c8 <fmt_fp+0x2178>
  4186be:	f6 46 fc 01          	test   BYTE PTR [rsi-0x4],0x1
  4186c2:	0f 85 a2 eb ff ff    	jne    41726a <fmt_fp+0xd1a>
			long double round = 2/LDBL_EPSILON;
  4186c8:	d9 05 7e 5d 00 00    	fld    DWORD PTR [rip+0x5d7e]        # 41e44c <states+0x20c>
  4186ce:	e9 9d eb ff ff       	jmp    417270 <fmt_fp+0xd20>
			l = (p+2) + (ebuf-estr);
  4186d3:	83 c6 02             	add    esi,0x2
  4186d6:	44 89 d8             	mov    eax,r11d
  4186d9:	89 f2                	mov    edx,esi
  4186db:	01 f0                	add    eax,esi
		pad(f, '0', l-(ebuf-estr)-(s-buf), 0, 0);
  4186dd:	29 fa                	sub    edx,edi
  4186df:	89 54 24 30          	mov    DWORD PTR [rsp+0x30],edx
  4186e3:	48 63 ea             	movsxd rbp,edx
			l = (p+2) + (ebuf-estr);
  4186e6:	e9 4d e5 ff ff       	jmp    416c38 <fmt_fp+0x6e8>
			if ((*d/i & 1) || (i==1000000000 && d>a && (d[-1]&1)))
  4186eb:	d9 05 5f 5d 00 00    	fld    DWORD PTR [rip+0x5d5f]        # 41e450 <states+0x210>
			if (x<i/2) small=0x0.8p0;
  4186f1:	d9 05 5d 5d 00 00    	fld    DWORD PTR [rip+0x5d5d]        # 41e454 <states+0x214>
				round += 2;
  4186f7:	db 2d b3 5d 00 00    	fld    TBYTE PTR [rip+0x5db3]        # 41e4b0 <states+0x270>
  4186fd:	d9 ca                	fxch   st(2)
  4186ff:	d9 c9                	fxch   st(1)
  418701:	e9 87 eb ff ff       	jmp    41728d <fmt_fp+0xd3d>
				p = MIN(p,MAX(0,9*(z-r-1)-j));
  418706:	48 89 c8             	mov    rax,rcx
  418709:	e9 e9 f5 ff ff       	jmp    417cf7 <fmt_fp+0x17a7>
			while (re--) round*=16;
  41870e:	d9 05 14 5d 00 00    	fld    DWORD PTR [rip+0x5d14]        # 41e428 <states+0x1e8>
  418714:	e9 88 e3 ff ff       	jmp    416aa1 <fmt_fp+0x551>
  418719:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418720:	4c 89 e2             	mov    rdx,r12
  418723:	be 00 01 00 00       	mov    esi,0x100
  418728:	4c 89 ff             	mov    rdi,r15
  41872b:	e8 20 21 00 00       	call   41a850 <__fwritex>
  418730:	41 8b 14 24          	mov    edx,DWORD PTR [r12]
  418734:	89 d0                	mov    eax,edx
  418736:	83 e0 20             	and    eax,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  418739:	81 fd ff 00 00 00    	cmp    ebp,0xff
  41873f:	0f 86 a0 fe ff ff    	jbe    4185e5 <fmt_fp+0x2095>
  418745:	81 ed 00 01 00 00    	sub    ebp,0x100
  41874b:	e9 70 fe ff ff       	jmp    4185c0 <fmt_fp+0x2070>
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  418750:	4c 8d bc 24 80 00 00 	lea    r15,[rsp+0x80]
  418757:	00 
  418758:	ba 00 01 00 00       	mov    edx,0x100
  41875d:	be 30 00 00 00       	mov    esi,0x30
  418762:	4c 89 ff             	mov    rdi,r15
  418765:	e8 22 c6 ff ff       	call   414d8c <memset>
	for (; l >= sizeof pad; l -= sizeof pad)
  41876a:	e9 41 fe ff ff       	jmp    4185b0 <fmt_fp+0x2060>
  41876f:	d9 ca                	fxch   st(2)
				y=-y;
  418771:	d9 e0                	fchs   
				y-=round;
  418773:	d8 e2                	fsub   st,st(2)
				y+=round;
  418775:	de c2                	faddp  st(2),st
  418777:	d9 c9                	fxch   st(1)
				y=-y;
  418779:	d9 e0                	fchs   
  41877b:	d9 c9                	fxch   st(1)
  41877d:	e9 31 e3 ff ff       	jmp    416ab3 <fmt_fp+0x563>
  418782:	d9 05 c8 5c 00 00    	fld    DWORD PTR [rip+0x5cc8]        # 41e450 <states+0x210>
			if (x<i/2) small=0x0.8p0;
  418788:	d9 05 c6 5c 00 00    	fld    DWORD PTR [rip+0x5cc6]        # 41e454 <states+0x214>
  41878e:	e9 fa ea ff ff       	jmp    41728d <fmt_fp+0xd3d>
			else if (x==i/2 && d+1==z) small=0x1.0p0;
  418793:	48 8d 46 04          	lea    rax,[rsi+0x4]
  418797:	48 39 c3             	cmp    rbx,rax
  41879a:	0f 85 e1 ea ff ff    	jne    417281 <fmt_fp+0xd31>
  4187a0:	d9 e8                	fld1   
  4187a2:	d9 e0                	fchs   
  4187a4:	d9 e8                	fld1   
  4187a6:	e9 e2 ea ff ff       	jmp    41728d <fmt_fp+0xd3d>
  4187ab:	48 89 de             	mov    rsi,rbx
  4187ae:	e9 1c eb ff ff       	jmp    4172cf <fmt_fp+0xd7f>
	out(f, pad, l);
  4187b3:	48 63 f5             	movsxd rsi,ebp
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4187b6:	4c 89 e2             	mov    rdx,r12
  4187b9:	4c 89 ff             	mov    rdi,r15
  4187bc:	e8 8f 20 00 00       	call   41a850 <__fwritex>
  4187c1:	e9 3f e7 ff ff       	jmp    416f05 <fmt_fp+0x9b5>
  4187c6:	dd d8                	fstp   st(0)
  4187c8:	dd d8                	fstp   st(0)
  4187ca:	dd d8                	fstp   st(0)
		} while (y);
  4187cc:	48 89 d0             	mov    rax,rdx
  4187cf:	e9 0e e4 ff ff       	jmp    416be2 <fmt_fp+0x692>
		for (i=10, j++; j<9; i*=10, j++);
  4187d4:	f3 0f 7e 05 a4 5c 00 	movq   xmm0,QWORD PTR [rip+0x5ca4]        # 41e480 <states+0x240>
  4187db:	00 
  4187dc:	e9 e7 e9 ff ff       	jmp    4171c8 <fmt_fp+0xc78>
  4187e1:	41 ba 0a 00 00 00    	mov    r10d,0xa
  4187e7:	b9 0a 00 00 00       	mov    ecx,0xa
  4187ec:	e9 4a e1 ff ff       	jmp    41693b <fmt_fp+0x3eb>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4187f1:	41 8b 14 24          	mov    edx,DWORD PTR [r12]
  4187f5:	83 e2 20             	and    edx,0x20
  4187f8:	e9 78 e8 ff ff       	jmp    417075 <fmt_fp+0xb25>
  4187fd:	41 8b 14 24          	mov    edx,DWORD PTR [r12]
  418801:	83 e2 20             	and    edx,0x20
  418804:	e9 1c e9 ff ff       	jmp    417125 <fmt_fp+0xbd5>
		for (i=10, j++; j<9; i*=10, j++);
  418809:	b9 0a 00 00 00       	mov    ecx,0xa
  41880e:	e9 d4 e9 ff ff       	jmp    4171e7 <fmt_fp+0xc97>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418813:	89 d0                	mov    eax,edx
  418815:	83 e0 20             	and    eax,0x20
  418818:	e9 4a ed ff ff       	jmp    417567 <fmt_fp+0x1017>
  41881d:	89 d0                	mov    eax,edx
  41881f:	83 e0 20             	and    eax,0x20
  418822:	e9 81 ec ff ff       	jmp    4174a8 <fmt_fp+0xf58>
  418827:	41 8b 14 24          	mov    edx,DWORD PTR [r12]
  41882b:	83 e2 20             	and    edx,0x20
  41882e:	e9 6b ef ff ff       	jmp    41779e <fmt_fp+0x124e>
  418833:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  418837:	83 e0 20             	and    eax,0x20
  41883a:	e9 c9 ee ff ff       	jmp    417708 <fmt_fp+0x11b8>
		for (i=10, j++; j<9; i*=10, j++);
  41883f:	f3 0f 7e 05 41 5c 00 	movq   xmm0,QWORD PTR [rip+0x5c41]        # 41e488 <states+0x248>
  418846:	00 
  418847:	e9 7c e9 ff ff       	jmp    4171c8 <fmt_fp+0xc78>
  41884c:	f3 0f 7e 05 3c 5c 00 	movq   xmm0,QWORD PTR [rip+0x5c3c]        # 41e490 <states+0x250>
  418853:	00 
  418854:	e9 6f e9 ff ff       	jmp    4171c8 <fmt_fp+0xc78>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418859:	41 8b 14 24          	mov    edx,DWORD PTR [r12]
  41885d:	83 e2 20             	and    edx,0x20
  418860:	e9 dd e5 ff ff       	jmp    416e42 <fmt_fp+0x8f2>
			while (re--) round*=16;
  418865:	d9 05 a9 5b 00 00    	fld    DWORD PTR [rip+0x5ba9]        # 41e414 <states+0x1d4>
  41886b:	e9 31 e2 ff ff       	jmp    416aa1 <fmt_fp+0x551>
		for (i=10, j++; j<9; i*=10, j++);
  418870:	f3 0f 7e 05 28 5c 00 	movq   xmm0,QWORD PTR [rip+0x5c28]        # 41e4a0 <states+0x260>
  418877:	00 
  418878:	e9 4b e9 ff ff       	jmp    4171c8 <fmt_fp+0xc78>
  41887d:	f3 0f 7e 05 13 5c 00 	movq   xmm0,QWORD PTR [rip+0x5c13]        # 41e498 <states+0x258>
  418884:	00 
  418885:	e9 3e e9 ff ff       	jmp    4171c8 <fmt_fp+0xc78>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41888a:	41 8b 14 24          	mov    edx,DWORD PTR [r12]
  41888e:	83 e2 20             	and    edx,0x20
  418891:	e9 26 e5 ff ff       	jmp    416dbc <fmt_fp+0x86c>
		if (x || d+1!=z) {
  418896:	48 83 c6 04          	add    rsi,0x4
  41889a:	e9 8c f9 ff ff       	jmp    41822b <fmt_fp+0x1cdb>
			while (re--) round*=16;
  41889f:	d9 05 73 5b 00 00    	fld    DWORD PTR [rip+0x5b73]        # 41e418 <states+0x1d8>
  4188a5:	e9 f7 e1 ff ff       	jmp    416aa1 <fmt_fp+0x551>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4188aa:	41 8b 14 24          	mov    edx,DWORD PTR [r12]
  4188ae:	83 e2 20             	and    edx,0x20
  4188b1:	e9 44 e4 ff ff       	jmp    416cfa <fmt_fp+0x7aa>
  4188b6:	41 8b 14 24          	mov    edx,DWORD PTR [r12]
  4188ba:	83 e2 20             	and    edx,0x20
  4188bd:	e9 3b e6 ff ff       	jmp    416efd <fmt_fp+0x9ad>
  4188c2:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  4188c6:	83 e0 20             	and    eax,0x20
  4188c9:	e9 1a fd ff ff       	jmp    4185e8 <fmt_fp+0x2098>
			while (re--) round*=16;
  4188ce:	d9 05 4c 5b 00 00    	fld    DWORD PTR [rip+0x5b4c]        # 41e420 <states+0x1e0>
  4188d4:	e9 c8 e1 ff ff       	jmp    416aa1 <fmt_fp+0x551>
  4188d9:	d9 05 3d 5b 00 00    	fld    DWORD PTR [rip+0x5b3d]        # 41e41c <states+0x1dc>
  4188df:	e9 bd e1 ff ff       	jmp    416aa1 <fmt_fp+0x551>
  4188e4:	d9 05 3a 5b 00 00    	fld    DWORD PTR [rip+0x5b3a]        # 41e424 <states+0x1e4>
  4188ea:	e9 b2 e1 ff ff       	jmp    416aa1 <fmt_fp+0x551>
  4188ef:	d9 05 3b 5b 00 00    	fld    DWORD PTR [rip+0x5b3b]        # 41e430 <states+0x1f0>
  4188f5:	e9 a7 e1 ff ff       	jmp    416aa1 <fmt_fp+0x551>
  4188fa:	d9 05 2c 5b 00 00    	fld    DWORD PTR [rip+0x5b2c]        # 41e42c <states+0x1ec>
  418900:	e9 9c e1 ff ff       	jmp    416aa1 <fmt_fp+0x551>
			if (z>a && z[-1]) for (i=10, j=0; z[-1]%i==0; i*=10, j++);
  418905:	31 f6                	xor    esi,esi
  418907:	e9 c1 f3 ff ff       	jmp    417ccd <fmt_fp+0x177d>
			while (re--) round*=16;
  41890c:	d9 05 26 5b 00 00    	fld    DWORD PTR [rip+0x5b26]        # 41e438 <states+0x1f8>
  418912:	e9 8a e1 ff ff       	jmp    416aa1 <fmt_fp+0x551>
  418917:	d9 05 17 5b 00 00    	fld    DWORD PTR [rip+0x5b17]        # 41e434 <states+0x1f4>
  41891d:	e9 7f e1 ff ff       	jmp    416aa1 <fmt_fp+0x551>
  418922:	d9 05 20 5b 00 00    	fld    DWORD PTR [rip+0x5b20]        # 41e448 <states+0x208>
  418928:	e9 74 e1 ff ff       	jmp    416aa1 <fmt_fp+0x551>
  41892d:	d9 05 11 5b 00 00    	fld    DWORD PTR [rip+0x5b11]        # 41e444 <states+0x204>
  418933:	e9 69 e1 ff ff       	jmp    416aa1 <fmt_fp+0x551>
  418938:	d9 05 02 5b 00 00    	fld    DWORD PTR [rip+0x5b02]        # 41e440 <states+0x200>
  41893e:	e9 5e e1 ff ff       	jmp    416aa1 <fmt_fp+0x551>
  418943:	d9 05 f3 5a 00 00    	fld    DWORD PTR [rip+0x5af3]        # 41e43c <states+0x1fc>
  418949:	e9 53 e1 ff ff       	jmp    416aa1 <fmt_fp+0x551>
  41894e:	44 89 eb             	mov    ebx,r13d
  418951:	4c 8b 6c 24 08       	mov    r13,QWORD PTR [rsp+0x8]
  418956:	e9 9f e3 ff ff       	jmp    416cfa <fmt_fp+0x7aa>

000000000041895b <printf_core.cold>:
  41895b:	44 8d 85 00 ff ff ff 	lea    r8d,[rbp-0x100]
  418962:	66 0f 6e ed          	movd   xmm5,ebp
	for (; l >= sizeof pad; l -= sizeof pad)
  418966:	31 c9                	xor    ecx,ecx
  418968:	66 0f 6f 0d 60 5b 00 	movdqa xmm1,XMMWORD PTR [rip+0x5b60]        # 41e4d0 <states+0x290>
  41896f:	00 
  418970:	44 89 c0             	mov    eax,r8d
  418973:	66 0f 70 dd 00       	pshufd xmm3,xmm5,0x0
  418978:	66 0f 6f 05 60 5b 00 	movdqa xmm0,XMMWORD PTR [rip+0x5b60]        # 41e4e0 <states+0x2a0>
  41897f:	00 
  418980:	66 0f fe 1d 38 5b 00 	paddd  xmm3,XMMWORD PTR [rip+0x5b38]        # 41e4c0 <states+0x280>
  418987:	00 
  418988:	c1 e8 08             	shr    eax,0x8
  41898b:	8d 70 01             	lea    esi,[rax+0x1]
  41898e:	41 89 f1             	mov    r9d,esi
  418991:	41 c1 e9 02          	shr    r9d,0x2
  418995:	66 0f 6f d3          	movdqa xmm2,xmm3
  418999:	83 c1 01             	add    ecx,0x1
  41899c:	66 0f fe d9          	paddd  xmm3,xmm1
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4189a0:	89 d0                	mov    eax,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  4189a2:	66 0f fe d0          	paddd  xmm2,xmm0
  4189a6:	44 39 c9             	cmp    ecx,r9d
  4189a9:	72 ea                	jb     418995 <printf_core.cold+0x3a>
  4189ab:	89 f1                	mov    ecx,esi
  4189ad:	66 0f 70 c2 ff       	pshufd xmm0,xmm2,0xff
  4189b2:	83 e1 fc             	and    ecx,0xfffffffc
  4189b5:	66 41 0f 7e c5       	movd   r13d,xmm0
  4189ba:	69 d1 00 ff ff ff    	imul   edx,ecx,0xffffff00
  4189c0:	39 f1                	cmp    ecx,esi
  4189c2:	0f 84 47 0b 00 00    	je     41950f <printf_core+0x7bf>
  4189c8:	44 01 c2             	add    edx,r8d
  4189cb:	41 89 d5             	mov    r13d,edx
  4189ce:	81 fa ff 00 00 00    	cmp    edx,0xff
  4189d4:	0f 86 35 0b 00 00    	jbe    41950f <printf_core+0x7bf>
  4189da:	41 81 ed 00 01 00 00 	sub    r13d,0x100
  4189e1:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  4189e8:	0f 86 21 0b 00 00    	jbe    41950f <printf_core+0x7bf>
  4189ee:	44 8d aa 00 fe ff ff 	lea    r13d,[rdx-0x200]
  4189f5:	e9 15 0b 00 00       	jmp    41950f <printf_core+0x7bf>
  4189fa:	45 8d 93 00 ff ff ff 	lea    r10d,[r11-0x100]
  418a01:	66 41 0f 6e eb       	movd   xmm5,r11d
  418a06:	45 31 c0             	xor    r8d,r8d
  418a09:	66 0f 6f 0d bf 5a 00 	movdqa xmm1,XMMWORD PTR [rip+0x5abf]        # 41e4d0 <states+0x290>
  418a10:	00 
  418a11:	44 89 d6             	mov    esi,r10d
  418a14:	66 0f 70 dd 00       	pshufd xmm3,xmm5,0x0
  418a19:	66 0f 6f 05 bf 5a 00 	movdqa xmm0,XMMWORD PTR [rip+0x5abf]        # 41e4e0 <states+0x2a0>
  418a20:	00 
  418a21:	66 0f fe 1d 97 5a 00 	paddd  xmm3,XMMWORD PTR [rip+0x5a97]        # 41e4c0 <states+0x280>
  418a28:	00 
  418a29:	c1 ee 08             	shr    esi,0x8
  418a2c:	83 c6 01             	add    esi,0x1
  418a2f:	41 89 f1             	mov    r9d,esi
  418a32:	41 c1 e9 02          	shr    r9d,0x2
  418a36:	66 0f 6f d3          	movdqa xmm2,xmm3
  418a3a:	41 83 c0 01          	add    r8d,0x1
  418a3e:	66 0f fe d9          	paddd  xmm3,xmm1
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418a42:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  418a44:	66 0f fe d0          	paddd  xmm2,xmm0
  418a48:	45 39 c1             	cmp    r9d,r8d
  418a4b:	77 e9                	ja     418a36 <printf_core.cold+0xdb>
  418a4d:	41 89 f1             	mov    r9d,esi
  418a50:	66 0f 70 c2 ff       	pshufd xmm0,xmm2,0xff
  418a55:	41 83 e1 fc          	and    r9d,0xfffffffc
  418a59:	66 41 0f 7e c0       	movd   r8d,xmm0
  418a5e:	41 69 c1 00 ff ff ff 	imul   eax,r9d,0xffffff00
  418a65:	41 39 f1             	cmp    r9d,esi
  418a68:	0f 84 fa 0f 00 00    	je     419a68 <printf_core+0xd18>
  418a6e:	44 01 d0             	add    eax,r10d
  418a71:	41 89 c0             	mov    r8d,eax
  418a74:	3d ff 00 00 00       	cmp    eax,0xff
  418a79:	0f 86 e9 0f 00 00    	jbe    419a68 <printf_core+0xd18>
  418a7f:	41 81 e8 00 01 00 00 	sub    r8d,0x100
  418a86:	41 81 f8 ff 00 00 00 	cmp    r8d,0xff
  418a8d:	0f 86 d5 0f 00 00    	jbe    419a68 <printf_core+0xd18>
  418a93:	44 8d 80 00 fe ff ff 	lea    r8d,[rax-0x200]
  418a9a:	e9 c9 0f 00 00       	jmp    419a68 <printf_core+0xd18>
  418a9f:	44 8d 85 00 ff ff ff 	lea    r8d,[rbp-0x100]
  418aa6:	66 0f 6e fd          	movd   xmm7,ebp
  418aaa:	31 f6                	xor    esi,esi
  418aac:	44 89 c1             	mov    ecx,r8d
  418aaf:	66 0f 70 c7 00       	pshufd xmm0,xmm7,0x0
  418ab4:	66 0f fe 05 04 5a 00 	paddd  xmm0,XMMWORD PTR [rip+0x5a04]        # 41e4c0 <states+0x280>
  418abb:	00 
  418abc:	c1 e9 08             	shr    ecx,0x8
  418abf:	83 c1 01             	add    ecx,0x1
  418ac2:	41 89 c9             	mov    r9d,ecx
  418ac5:	41 c1 e9 02          	shr    r9d,0x2
  418ac9:	83 c6 01             	add    esi,0x1
  418acc:	66 0f 6f c8          	movdqa xmm1,xmm0
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418ad0:	89 c2                	mov    edx,eax
  418ad2:	66 0f fe 05 f6 59 00 	paddd  xmm0,XMMWORD PTR [rip+0x59f6]        # 41e4d0 <states+0x290>
  418ad9:	00 
	for (; l >= sizeof pad; l -= sizeof pad)
  418ada:	66 0f fe 0d fe 59 00 	paddd  xmm1,XMMWORD PTR [rip+0x59fe]        # 41e4e0 <states+0x2a0>
  418ae1:	00 
  418ae2:	44 39 ce             	cmp    esi,r9d
  418ae5:	72 e2                	jb     418ac9 <printf_core.cold+0x16e>
  418ae7:	89 ce                	mov    esi,ecx
  418ae9:	66 0f 70 c1 ff       	pshufd xmm0,xmm1,0xff
  418aee:	83 e6 fc             	and    esi,0xfffffffc
  418af1:	66 41 0f 7e c4       	movd   r12d,xmm0
  418af6:	69 c6 00 ff ff ff    	imul   eax,esi,0xffffff00
  418afc:	39 f1                	cmp    ecx,esi
  418afe:	0f 84 76 0b 00 00    	je     41967a <printf_core+0x92a>
  418b04:	44 01 c0             	add    eax,r8d
  418b07:	41 89 c4             	mov    r12d,eax
  418b0a:	3d ff 00 00 00       	cmp    eax,0xff
  418b0f:	0f 86 65 0b 00 00    	jbe    41967a <printf_core+0x92a>
  418b15:	41 81 ec 00 01 00 00 	sub    r12d,0x100
  418b1c:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  418b23:	0f 86 51 0b 00 00    	jbe    41967a <printf_core+0x92a>
  418b29:	44 8d a0 00 fe ff ff 	lea    r12d,[rax-0x200]
  418b30:	e9 45 0b 00 00       	jmp    41967a <printf_core+0x92a>
  418b35:	44 8d 85 00 ff ff ff 	lea    r8d,[rbp-0x100]
  418b3c:	66 0f 6e f5          	movd   xmm6,ebp
  418b40:	31 c9                	xor    ecx,ecx
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418b42:	89 c6                	mov    esi,eax
  418b44:	44 89 c2             	mov    edx,r8d
  418b47:	66 0f 70 de 00       	pshufd xmm3,xmm6,0x0
  418b4c:	66 0f 6f 0d 7c 59 00 	movdqa xmm1,XMMWORD PTR [rip+0x597c]        # 41e4d0 <states+0x290>
  418b53:	00 
  418b54:	66 0f fe 1d 64 59 00 	paddd  xmm3,XMMWORD PTR [rip+0x5964]        # 41e4c0 <states+0x280>
  418b5b:	00 
  418b5c:	c1 ea 08             	shr    edx,0x8
  418b5f:	66 0f 6f 05 79 59 00 	movdqa xmm0,XMMWORD PTR [rip+0x5979]        # 41e4e0 <states+0x2a0>
  418b66:	00 
  418b67:	83 c2 01             	add    edx,0x1
  418b6a:	41 89 d1             	mov    r9d,edx
  418b6d:	41 c1 e9 02          	shr    r9d,0x2
  418b71:	66 0f 6f d3          	movdqa xmm2,xmm3
  418b75:	83 c1 01             	add    ecx,0x1
  418b78:	66 0f fe d9          	paddd  xmm3,xmm1
  418b7c:	89 f0                	mov    eax,esi
	for (; l >= sizeof pad; l -= sizeof pad)
  418b7e:	66 0f fe d0          	paddd  xmm2,xmm0
  418b82:	44 39 c9             	cmp    ecx,r9d
  418b85:	72 ea                	jb     418b71 <printf_core.cold+0x216>
  418b87:	89 d6                	mov    esi,edx
  418b89:	66 0f 70 c2 ff       	pshufd xmm0,xmm2,0xff
  418b8e:	83 e6 fc             	and    esi,0xfffffffc
  418b91:	66 41 0f 7e c5       	movd   r13d,xmm0
  418b96:	69 ce 00 ff ff ff    	imul   ecx,esi,0xffffff00
  418b9c:	39 d6                	cmp    esi,edx
  418b9e:	0f 84 30 0a 00 00    	je     4195d4 <printf_core+0x884>
  418ba4:	44 01 c1             	add    ecx,r8d
  418ba7:	41 89 cd             	mov    r13d,ecx
  418baa:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  418bb0:	0f 86 1e 0a 00 00    	jbe    4195d4 <printf_core+0x884>
  418bb6:	41 81 ed 00 01 00 00 	sub    r13d,0x100
  418bbd:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  418bc4:	0f 86 0a 0a 00 00    	jbe    4195d4 <printf_core+0x884>
  418bca:	44 8d a9 00 fe ff ff 	lea    r13d,[rcx-0x200]
  418bd1:	e9 fe 09 00 00       	jmp    4195d4 <printf_core+0x884>
  418bd6:	41 8d 8c 24 00 e8 ff 	lea    ecx,[r12-0x1800]
  418bdd:	ff 
  418bde:	81 f9 00 e9 ff 7f    	cmp    ecx,0x7fffe900
  418be4:	0f 87 45 01 00 00    	ja     418d2f <printf_core.cold+0x3d4>
  418bea:	41 8d b4 24 00 fe ff 	lea    esi,[r12-0x200]
  418bf1:	ff 
  418bf2:	66 41 0f 6e f4       	movd   xmm6,r12d
  418bf7:	45 31 c9             	xor    r9d,r9d
  418bfa:	66 0f 6f 0d ce 58 00 	movdqa xmm1,XMMWORD PTR [rip+0x58ce]        # 41e4d0 <states+0x290>
  418c01:	00 
  418c02:	89 f2                	mov    edx,esi
  418c04:	66 0f 70 de 00       	pshufd xmm3,xmm6,0x0
  418c09:	66 0f 6f 05 cf 58 00 	movdqa xmm0,XMMWORD PTR [rip+0x58cf]        # 41e4e0 <states+0x2a0>
  418c10:	00 
  418c11:	66 0f fe 1d e7 58 00 	paddd  xmm3,XMMWORD PTR [rip+0x58e7]        # 41e500 <states+0x2c0>
  418c18:	00 
  418c19:	c1 ea 08             	shr    edx,0x8
  418c1c:	83 c2 01             	add    edx,0x1
  418c1f:	41 89 d0             	mov    r8d,edx
  418c22:	41 c1 e8 02          	shr    r8d,0x2
  418c26:	66 0f 6f d3          	movdqa xmm2,xmm3
  418c2a:	41 83 c1 01          	add    r9d,0x1
  418c2e:	66 0f fe d9          	paddd  xmm3,xmm1
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418c32:	89 c1                	mov    ecx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  418c34:	66 0f fe d0          	paddd  xmm2,xmm0
  418c38:	45 39 c8             	cmp    r8d,r9d
  418c3b:	77 e9                	ja     418c26 <printf_core.cold+0x2cb>
  418c3d:	41 89 d0             	mov    r8d,edx
  418c40:	66 0f 70 c2 ff       	pshufd xmm0,xmm2,0xff
  418c45:	41 83 e0 fc          	and    r8d,0xfffffffc
  418c49:	66 41 0f 7e c1       	movd   r9d,xmm0
  418c4e:	41 69 c0 00 ff ff ff 	imul   eax,r8d,0xffffff00
  418c55:	41 39 d0             	cmp    r8d,edx
  418c58:	0f 84 f3 11 00 00    	je     419e51 <printf_core+0x1101>
  418c5e:	01 f0                	add    eax,esi
  418c60:	41 89 c1             	mov    r9d,eax
  418c63:	3d ff 00 00 00       	cmp    eax,0xff
  418c68:	0f 86 e3 11 00 00    	jbe    419e51 <printf_core+0x1101>
  418c6e:	41 81 e9 00 01 00 00 	sub    r9d,0x100
  418c75:	41 81 f9 ff 00 00 00 	cmp    r9d,0xff
  418c7c:	0f 86 cf 11 00 00    	jbe    419e51 <printf_core+0x1101>
  418c82:	44 8d 88 00 fe ff ff 	lea    r9d,[rax-0x200]
  418c89:	e9 c3 11 00 00       	jmp    419e51 <printf_core+0x1101>
  418c8e:	44 8d 85 00 ff ff ff 	lea    r8d,[rbp-0x100]
  418c95:	66 0f 6e fd          	movd   xmm7,ebp
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418c99:	89 c1                	mov    ecx,eax
  418c9b:	66 0f 6f 0d 2d 58 00 	movdqa xmm1,XMMWORD PTR [rip+0x582d]        # 41e4d0 <states+0x290>
  418ca2:	00 
  418ca3:	44 89 c2             	mov    edx,r8d
  418ca6:	66 0f 70 df 00       	pshufd xmm3,xmm7,0x0
  418cab:	66 0f 6f 05 2d 58 00 	movdqa xmm0,XMMWORD PTR [rip+0x582d]        # 41e4e0 <states+0x2a0>
  418cb2:	00 
  418cb3:	66 0f fe 1d 05 58 00 	paddd  xmm3,XMMWORD PTR [rip+0x5805]        # 41e4c0 <states+0x280>
  418cba:	00 
  418cbb:	c1 ea 08             	shr    edx,0x8
  418cbe:	8d 72 01             	lea    esi,[rdx+0x1]
	for (; l >= sizeof pad; l -= sizeof pad)
  418cc1:	31 d2                	xor    edx,edx
  418cc3:	41 89 f1             	mov    r9d,esi
  418cc6:	41 c1 e9 02          	shr    r9d,0x2
  418cca:	66 0f 6f d3          	movdqa xmm2,xmm3
  418cce:	83 c2 01             	add    edx,0x1
  418cd1:	66 0f fe d9          	paddd  xmm3,xmm1
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418cd5:	89 c8                	mov    eax,ecx
	for (; l >= sizeof pad; l -= sizeof pad)
  418cd7:	66 0f fe d0          	paddd  xmm2,xmm0
  418cdb:	44 39 ca             	cmp    edx,r9d
  418cde:	72 ea                	jb     418cca <printf_core.cold+0x36f>
  418ce0:	89 f1                	mov    ecx,esi
  418ce2:	66 0f 70 c2 ff       	pshufd xmm0,xmm2,0xff
  418ce7:	83 e1 fc             	and    ecx,0xfffffffc
  418cea:	66 41 0f 7e c5       	movd   r13d,xmm0
  418cef:	69 d1 00 ff ff ff    	imul   edx,ecx,0xffffff00
  418cf5:	39 f1                	cmp    ecx,esi
  418cf7:	0f 84 27 07 00 00    	je     419424 <printf_core+0x6d4>
  418cfd:	44 01 c2             	add    edx,r8d
  418d00:	41 89 d5             	mov    r13d,edx
  418d03:	81 fa ff 00 00 00    	cmp    edx,0xff
  418d09:	0f 86 15 07 00 00    	jbe    419424 <printf_core+0x6d4>
  418d0f:	41 81 ed 00 01 00 00 	sub    r13d,0x100
  418d16:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  418d1d:	0f 86 01 07 00 00    	jbe    419424 <printf_core+0x6d4>
  418d23:	44 8d aa 00 fe ff ff 	lea    r13d,[rdx-0x200]
  418d2a:	e9 f5 06 00 00       	jmp    419424 <printf_core+0x6d4>
  418d2f:	81 ea 00 01 00 00    	sub    edx,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418d35:	89 c1                	mov    ecx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  418d37:	41 89 d1             	mov    r9d,edx
  418d3a:	81 fa ff 00 00 00    	cmp    edx,0xff
  418d40:	77 ed                	ja     418d2f <printf_core.cold+0x3d4>
  418d42:	e9 0a 11 00 00       	jmp    419e51 <printf_core+0x1101>
  418d47:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  418d4e:	00 00 

0000000000418d50 <printf_core>:
	}
	return i;
}

static int printf_core(FILE *f, const char *fmt, va_list *ap, union arg *nl_arg, int *nl_type)
{
  418d50:	41 57                	push   r15
  418d52:	49 89 f2             	mov    r10,rsi
  418d55:	41 56                	push   r14
  418d57:	49 89 fe             	mov    r14,rdi
  418d5a:	41 55                	push   r13
  418d5c:	41 54                	push   r12
  418d5e:	55                   	push   rbp
  418d5f:	53                   	push   rbx
  418d60:	48 81 ec b8 01 00 00 	sub    rsp,0x1b8
  418d67:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
  418d6c:	48 89 4c 24 28       	mov    QWORD PTR [rsp+0x28],rcx
  418d71:	4c 89 44 24 20       	mov    QWORD PTR [rsp+0x20],r8
	unsigned l10n=0, fl;
	int w, p, xp;
	union arg arg;
	int argpos;
	unsigned st, ps;
	int cnt=0, l=0;
  418d76:	c7 04 24 00 00 00 00 	mov    DWORD PTR [rsp],0x0
  418d7d:	c7 44 24 08 00 00 00 	mov    DWORD PTR [rsp+0x8],0x0
  418d84:	00 
	unsigned l10n=0, fl;
  418d85:	c7 44 24 0c 00 00 00 	mov    DWORD PTR [rsp+0xc],0x0
  418d8c:	00 
		 * on overflow; otherwise %n could produce wrong results. */
		if (l > INT_MAX - cnt) goto overflow;

		/* Update output count, end loop when fmt is exhausted */
		cnt += l;
		if (!*s) break;
  418d8d:	41 0f b6 02          	movzx  eax,BYTE PTR [r10]
		cnt += l;
  418d91:	8b 3c 24             	mov    edi,DWORD PTR [rsp]
  418d94:	01 7c 24 08          	add    DWORD PTR [rsp+0x8],edi
		if (!*s) break;
  418d98:	84 c0                	test   al,al
  418d9a:	0f 84 02 05 00 00    	je     4192a2 <printf_core+0x552>

		/* Handle literal text and %% format specifiers */
		for (a=s; *s && *s!='%'; s++);
  418da0:	4d 89 d7             	mov    r15,r10
  418da3:	eb 10                	jmp    418db5 <printf_core+0x65>
  418da5:	0f 1f 00             	nop    DWORD PTR [rax]
  418da8:	41 0f b6 47 01       	movzx  eax,BYTE PTR [r15+0x1]
  418dad:	49 83 c7 01          	add    r15,0x1
  418db1:	84 c0                	test   al,al
  418db3:	74 6b                	je     418e20 <printf_core+0xd0>
  418db5:	3c 25                	cmp    al,0x25
  418db7:	75 ef                	jne    418da8 <printf_core+0x58>
  418db9:	4c 89 fb             	mov    rbx,r15
  418dbc:	eb 0f                	jmp    418dcd <printf_core+0x7d>
  418dbe:	66 90                	xchg   ax,ax
		for (z=s; s[0]=='%' && s[1]=='%'; z++, s+=2);
  418dc0:	48 83 c3 02          	add    rbx,0x2
  418dc4:	49 83 c7 01          	add    r15,0x1
  418dc8:	80 3b 25             	cmp    BYTE PTR [rbx],0x25
  418dcb:	75 06                	jne    418dd3 <printf_core+0x83>
  418dcd:	80 7b 01 25          	cmp    BYTE PTR [rbx+0x1],0x25
  418dd1:	74 ed                	je     418dc0 <printf_core+0x70>
		if (z-a > INT_MAX-cnt) goto overflow;
  418dd3:	41 bd ff ff ff 7f    	mov    r13d,0x7fffffff
  418dd9:	44 2b 6c 24 08       	sub    r13d,DWORD PTR [rsp+0x8]
  418dde:	4d 29 d7             	sub    r15,r10
  418de1:	49 63 c5             	movsxd rax,r13d
  418de4:	49 39 c7             	cmp    r15,rax
  418de7:	0f 8f 2c 03 00 00    	jg     419119 <printf_core+0x3c9>
		l = z-a;
  418ded:	44 89 3c 24          	mov    DWORD PTR [rsp],r15d
		if (f) out(f, a, l);
  418df1:	4d 85 f6             	test   r14,r14
  418df4:	74 0a                	je     418e00 <printf_core+0xb0>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418df6:	41 f6 06 20          	test   BYTE PTR [r14],0x20
  418dfa:	0f 84 70 01 00 00    	je     418f70 <printf_core+0x220>
		if (l) continue;
  418e00:	45 85 ff             	test   r15d,r15d
  418e03:	74 2b                	je     418e30 <printf_core+0xe0>
		if (l > INT_MAX - cnt) goto overflow;
  418e05:	44 3b 2c 24          	cmp    r13d,DWORD PTR [rsp]
  418e09:	0f 8c 0a 03 00 00    	jl     419119 <printf_core+0x3c9>
{
  418e0f:	49 89 da             	mov    r10,rbx
  418e12:	e9 76 ff ff ff       	jmp    418d8d <printf_core+0x3d>
  418e17:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  418e1e:	00 00 
		for (a=s; *s && *s!='%'; s++);
  418e20:	4c 89 fb             	mov    rbx,r15
		for (z=s; s[0]=='%' && s[1]=='%'; z++, s+=2);
  418e23:	3c 25                	cmp    al,0x25
  418e25:	74 92                	je     418db9 <printf_core+0x69>
  418e27:	eb aa                	jmp    418dd3 <printf_core+0x83>
  418e29:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

		if (isdigit(s[1]) && s[2]=='$') {
  418e30:	0f be 4b 01          	movsx  ecx,BYTE PTR [rbx+0x1]
  418e34:	8d 71 d0             	lea    esi,[rcx-0x30]
  418e37:	89 c8                	mov    eax,ecx
  418e39:	83 fe 09             	cmp    esi,0x9
  418e3c:	77 0a                	ja     418e48 <printf_core+0xf8>
  418e3e:	80 7b 02 24          	cmp    BYTE PTR [rbx+0x2],0x24
  418e42:	0f 84 30 03 00 00    	je     419178 <printf_core+0x428>
			l10n=1;
			argpos = s[1]-'0';
			s+=3;
		} else {
			argpos = -1;
			s++;
  418e48:	48 83 c3 01          	add    rbx,0x1
			argpos = -1;
  418e4c:	be ff ff ff ff       	mov    esi,0xffffffff
		}

		/* Read modifier flags */
		for (fl=0; (unsigned)*s-' '<32 && (FLAGMASK&(1U<<*s-' ')); s++)
  418e51:	44 8d 41 e0          	lea    r8d,[rcx-0x20]
  418e55:	45 31 e4             	xor    r12d,r12d
  418e58:	ba 89 28 01 00       	mov    edx,0x12889
			fl |= 1U<<*s-' ';
  418e5d:	bf 01 00 00 00       	mov    edi,0x1
		for (fl=0; (unsigned)*s-' '<32 && (FLAGMASK&(1U<<*s-' ')); s++)
  418e62:	41 83 f8 1f          	cmp    r8d,0x1f
  418e66:	76 22                	jbe    418e8a <printf_core+0x13a>
  418e68:	eb 28                	jmp    418e92 <printf_core+0x142>
  418e6a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
			fl |= 1U<<*s-' ';
  418e70:	89 f8                	mov    eax,edi
		for (fl=0; (unsigned)*s-' '<32 && (FLAGMASK&(1U<<*s-' ')); s++)
  418e72:	48 83 c3 01          	add    rbx,0x1
			fl |= 1U<<*s-' ';
  418e76:	d3 e0                	shl    eax,cl
		for (fl=0; (unsigned)*s-' '<32 && (FLAGMASK&(1U<<*s-' ')); s++)
  418e78:	0f be 0b             	movsx  ecx,BYTE PTR [rbx]
			fl |= 1U<<*s-' ';
  418e7b:	41 09 c4             	or     r12d,eax
		for (fl=0; (unsigned)*s-' '<32 && (FLAGMASK&(1U<<*s-' ')); s++)
  418e7e:	44 8d 41 e0          	lea    r8d,[rcx-0x20]
  418e82:	89 c8                	mov    eax,ecx
  418e84:	41 83 f8 1f          	cmp    r8d,0x1f
  418e88:	77 08                	ja     418e92 <printf_core+0x142>
  418e8a:	83 e9 20             	sub    ecx,0x20
  418e8d:	0f a3 ca             	bt     edx,ecx
  418e90:	72 de                	jb     418e70 <printf_core+0x120>

		/* Read field width */
		if (*s=='*') {
  418e92:	3c 2a                	cmp    al,0x2a
  418e94:	0f 85 76 01 00 00    	jne    419010 <printf_core+0x2c0>
			if (isdigit(s[1]) && s[2]=='$') {
  418e9a:	48 0f be 43 01       	movsx  rax,BYTE PTR [rbx+0x1]
  418e9f:	48 89 c1             	mov    rcx,rax
  418ea2:	83 e8 30             	sub    eax,0x30
  418ea5:	83 f8 09             	cmp    eax,0x9
  418ea8:	0f 86 8a 02 00 00    	jbe    419138 <printf_core+0x3e8>
				l10n=1;
				nl_type[s[1]-'0'] = INT;
				w = nl_arg[s[1]-'0'].i;
				s+=3;
			} else if (!l10n) {
  418eae:	44 8b 44 24 0c       	mov    r8d,DWORD PTR [rsp+0xc]
  418eb3:	45 85 c0             	test   r8d,r8d
  418eb6:	0f 85 22 01 00 00    	jne    418fde <printf_core+0x28e>
				w = f ? va_arg(*ap, int) : 0;
				s++;
  418ebc:	48 83 c3 01          	add    rbx,0x1
				w = f ? va_arg(*ap, int) : 0;
  418ec0:	44 89 fd             	mov    ebp,r15d
  418ec3:	4d 85 f6             	test   r14,r14
  418ec6:	74 2d                	je     418ef5 <printf_core+0x1a5>
  418ec8:	48 8b 7c 24 10       	mov    rdi,QWORD PTR [rsp+0x10]
  418ecd:	8b 07                	mov    eax,DWORD PTR [rdi]
  418ecf:	83 f8 2f             	cmp    eax,0x2f
  418ed2:	0f 87 c8 02 00 00    	ja     4191a0 <printf_core+0x450>
  418ed8:	89 c2                	mov    edx,eax
  418eda:	83 c0 08             	add    eax,0x8
  418edd:	48 03 57 10          	add    rdx,QWORD PTR [rdi+0x10]
  418ee1:	89 07                	mov    DWORD PTR [rdi],eax
  418ee3:	8b 2a                	mov    ebp,DWORD PTR [rdx]
			} else goto inval;
			if (w<0) fl|=LEFT_ADJ, w=-w;
		} else if ((w=getint(&s))<0) goto overflow;

		/* Read precision */
		if (*s=='.' && s[1]=='*') {
  418ee5:	0f b6 0b             	movzx  ecx,BYTE PTR [rbx]
			if (w<0) fl|=LEFT_ADJ, w=-w;
  418ee8:	85 ed                	test   ebp,ebp
  418eea:	79 09                	jns    418ef5 <printf_core+0x1a5>
  418eec:	41 81 cc 00 20 00 00 	or     r12d,0x2000
  418ef3:	f7 dd                	neg    ebp
		if (*s=='.' && s[1]=='*') {
  418ef5:	80 f9 2e             	cmp    cl,0x2e
  418ef8:	0f 85 92 00 00 00    	jne    418f90 <printf_core+0x240>
  418efe:	0f be 43 01          	movsx  eax,BYTE PTR [rbx+0x1]
  418f02:	3c 2a                	cmp    al,0x2a
  418f04:	0f 85 ae 02 00 00    	jne    4191b8 <printf_core+0x468>
			if (isdigit(s[2]) && s[3]=='$') {
  418f0a:	48 0f be 43 02       	movsx  rax,BYTE PTR [rbx+0x2]
  418f0f:	48 89 c2             	mov    rdx,rax
  418f12:	83 e8 30             	sub    eax,0x30
  418f15:	83 f8 09             	cmp    eax,0x9
  418f18:	77 0a                	ja     418f24 <printf_core+0x1d4>
  418f1a:	80 7b 03 24          	cmp    BYTE PTR [rbx+0x3],0x24
  418f1e:	0f 84 33 03 00 00    	je     419257 <printf_core+0x507>
				nl_type[s[2]-'0'] = INT;
				p = nl_arg[s[2]-'0'].i;
				s+=4;
			} else if (!l10n) {
  418f24:	8b 7c 24 0c          	mov    edi,DWORD PTR [rsp+0xc]
  418f28:	85 ff                	test   edi,edi
  418f2a:	0f 85 ae 00 00 00    	jne    418fde <printf_core+0x28e>
				p = f ? va_arg(*ap, int) : 0;
  418f30:	4d 85 f6             	test   r14,r14
  418f33:	0f 84 59 03 00 00    	je     419292 <printf_core+0x542>
  418f39:	48 8b 7c 24 10       	mov    rdi,QWORD PTR [rsp+0x10]
  418f3e:	8b 07                	mov    eax,DWORD PTR [rdi]
  418f40:	83 f8 2f             	cmp    eax,0x2f
  418f43:	0f 87 de 02 00 00    	ja     419227 <printf_core+0x4d7>
  418f49:	89 c2                	mov    edx,eax
  418f4b:	83 c0 08             	add    eax,0x8
  418f4e:	48 03 57 10          	add    rdx,QWORD PTR [rdi+0x10]
  418f52:	89 07                	mov    DWORD PTR [rdi],eax
  418f54:	44 8b 1a             	mov    r11d,DWORD PTR [rdx]
				s+=2;
			} else goto inval;
			xp = (p>=0);
  418f57:	44 89 d8             	mov    eax,r11d
  418f5a:	f7 d0                	not    eax
  418f5c:	c1 e8 1f             	shr    eax,0x1f
  418f5f:	89 44 24 18          	mov    DWORD PTR [rsp+0x18],eax
				s+=2;
  418f63:	48 83 c3 02          	add    rbx,0x2
			xp = (p>=0);
  418f67:	eb 32                	jmp    418f9b <printf_core+0x24b>
  418f69:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418f70:	4c 89 d7             	mov    rdi,r10
		if (f) out(f, a, l);
  418f73:	49 63 f7             	movsxd rsi,r15d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418f76:	4c 89 f2             	mov    rdx,r14
  418f79:	4c 89 54 24 18       	mov    QWORD PTR [rsp+0x18],r10
  418f7e:	e8 cd 18 00 00       	call   41a850 <__fwritex>
  418f83:	4c 8b 54 24 18       	mov    r10,QWORD PTR [rsp+0x18]
  418f88:	e9 73 fe ff ff       	jmp    418e00 <printf_core+0xb0>
  418f8d:	0f 1f 00             	nop    DWORD PTR [rax]
			s++;
			p = getint(&s);
			xp = 1;
		} else {
			p = -1;
			xp = 0;
  418f90:	44 89 7c 24 18       	mov    DWORD PTR [rsp+0x18],r15d
			p = -1;
  418f95:	41 bb ff ff ff ff    	mov    r11d,0xffffffff
		}

		/* Format specifier state machine */
		st=0;
  418f9b:	45 31 c9             	xor    r9d,r9d
		do {
			if (OOB(*s)) goto inval;
			ps=st;
			st=states[st]S(*s++);
  418f9e:	48 8d 0d 9b 52 00 00 	lea    rcx,[rip+0x529b]        # 41e240 <states>
  418fa5:	eb 2c                	jmp    418fd3 <printf_core+0x283>
  418fa7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  418fae:	00 00 
  418fb0:	45 89 c8             	mov    r8d,r9d
  418fb3:	48 98                	cdqe   
  418fb5:	48 83 c3 01          	add    rbx,0x1
  418fb9:	49 6b d0 3a          	imul   rdx,r8,0x3a
  418fbd:	48 01 ca             	add    rdx,rcx
  418fc0:	0f b6 04 02          	movzx  eax,BYTE PTR [rdx+rax*1]
		} while (st-1<STOP);
  418fc4:	8d 50 ff             	lea    edx,[rax-0x1]
  418fc7:	83 fa 07             	cmp    edx,0x7
  418fca:	0f 87 b0 00 00 00    	ja     419080 <printf_core+0x330>
  418fd0:	41 89 c1             	mov    r9d,eax
			if (OOB(*s)) goto inval;
  418fd3:	0f be 03             	movsx  eax,BYTE PTR [rbx]
  418fd6:	83 e8 41             	sub    eax,0x41
  418fd9:	83 f8 39             	cmp    eax,0x39
  418fdc:	76 d2                	jbe    418fb0 <printf_core+0x260>
	for (; i<=NL_ARGMAX && !nl_type[i]; i++);
	if (i<=NL_ARGMAX) goto inval;
	return 1;

inval:
	errno = EINVAL;
  418fde:	e8 8d cd ff ff       	call   415d70 <__errno_location>
	return -1;
  418fe3:	c7 44 24 08 ff ff ff 	mov    DWORD PTR [rsp+0x8],0xffffffff
  418fea:	ff 
	errno = EINVAL;
  418feb:	c7 00 16 00 00 00    	mov    DWORD PTR [rax],0x16
overflow:
	errno = EOVERFLOW;
	return -1;
}
  418ff1:	8b 44 24 08          	mov    eax,DWORD PTR [rsp+0x8]
  418ff5:	48 81 c4 b8 01 00 00 	add    rsp,0x1b8
  418ffc:	5b                   	pop    rbx
  418ffd:	5d                   	pop    rbp
  418ffe:	41 5c                	pop    r12
  419000:	41 5d                	pop    r13
  419002:	41 5e                	pop    r14
  419004:	41 5f                	pop    r15
  419006:	c3                   	ret    
  419007:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41900e:	00 00 
	for (i=0; isdigit(**s); (*s)++) {
  419010:	0f be 03             	movsx  eax,BYTE PTR [rbx]
  419013:	44 89 fd             	mov    ebp,r15d
  419016:	89 c2                	mov    edx,eax
  419018:	83 e8 30             	sub    eax,0x30
  41901b:	89 d1                	mov    ecx,edx
  41901d:	83 f8 09             	cmp    eax,0x9
  419020:	76 31                	jbe    419053 <printf_core+0x303>
  419022:	e9 ce fe ff ff       	jmp    418ef5 <printf_core+0x1a5>
  419027:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41902e:	00 00 
		if (i > INT_MAX/10U || **s-'0' > INT_MAX-10*i) i = -1;
  419030:	6b fd f6             	imul   edi,ebp,0xfffffff6
  419033:	83 ea 30             	sub    edx,0x30
  419036:	44 8d 87 ff ff ff 7f 	lea    r8d,[rdi+0x7fffffff]
  41903d:	44 39 c2             	cmp    edx,r8d
  419040:	7f 26                	jg     419068 <printf_core+0x318>
		else i = 10*i + (**s-'0');
  419042:	29 fa                	sub    edx,edi
  419044:	89 d5                	mov    ebp,edx
	for (i=0; isdigit(**s); (*s)++) {
  419046:	83 f8 09             	cmp    eax,0x9
  419049:	0f 87 c1 00 00 00    	ja     419110 <printf_core+0x3c0>
  41904f:	90                   	nop
  419050:	0f be d1             	movsx  edx,cl
  419053:	0f be 43 01          	movsx  eax,BYTE PTR [rbx+0x1]
  419057:	48 83 c3 01          	add    rbx,0x1
  41905b:	89 c1                	mov    ecx,eax
  41905d:	83 e8 30             	sub    eax,0x30
		if (i > INT_MAX/10U || **s-'0' > INT_MAX-10*i) i = -1;
  419060:	81 fd cc cc cc 0c    	cmp    ebp,0xccccccc
  419066:	76 c8                	jbe    419030 <printf_core+0x2e0>
	for (i=0; isdigit(**s); (*s)++) {
  419068:	83 f8 09             	cmp    eax,0x9
  41906b:	0f 87 a8 00 00 00    	ja     419119 <printf_core+0x3c9>
  419071:	bd ff ff ff ff       	mov    ebp,0xffffffff
  419076:	eb d8                	jmp    419050 <printf_core+0x300>
  419078:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41907f:	00 
		if (!st) goto inval;
  419080:	85 c0                	test   eax,eax
  419082:	0f 84 56 ff ff ff    	je     418fde <printf_core+0x28e>
		if (st==NOARG) {
  419088:	83 f8 1b             	cmp    eax,0x1b
  41908b:	0f 84 fe 00 00 00    	je     41918f <printf_core+0x43f>
			if (argpos>=0) nl_type[argpos]=st, arg=nl_arg[argpos];
  419091:	83 fe ff             	cmp    esi,0xffffffff
  419094:	0f 84 9e 01 00 00    	je     419238 <printf_core+0x4e8>
  41909a:	48 8b 7c 24 20       	mov    rdi,QWORD PTR [rsp+0x20]
  41909f:	48 63 f6             	movsxd rsi,esi
  4190a2:	89 04 b7             	mov    DWORD PTR [rdi+rsi*4],eax
  4190a5:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  4190aa:	48 c1 e6 04          	shl    rsi,0x4
  4190ae:	66 0f 6f 24 30       	movdqa xmm4,XMMWORD PTR [rax+rsi*1]
  4190b3:	0f 29 64 24 70       	movaps XMMWORD PTR [rsp+0x70],xmm4
		if (!f) continue;
  4190b8:	4d 85 f6             	test   r14,r14
  4190bb:	0f 84 4e fd ff ff    	je     418e0f <printf_core+0xbf>
		t = s[-1];
  4190c1:	0f be 53 ff          	movsx  edx,BYTE PTR [rbx-0x1]
  4190c5:	89 d0                	mov    eax,edx
		if (ps && (t&15)==3) t&=~32;
  4190c7:	45 85 c9             	test   r9d,r9d
  4190ca:	74 11                	je     4190dd <printf_core+0x38d>
  4190cc:	89 d1                	mov    ecx,edx
  4190ce:	83 e0 df             	and    eax,0xffffffdf
  4190d1:	83 e1 0f             	and    ecx,0xf
  4190d4:	0f be c0             	movsx  eax,al
  4190d7:	80 f9 03             	cmp    cl,0x3
  4190da:	0f 44 d0             	cmove  edx,eax
		if (fl & LEFT_ADJ) fl &= ~ZERO_PAD;
  4190dd:	44 89 e0             	mov    eax,r12d
  4190e0:	25 ff ff fe ff       	and    eax,0xfffeffff
  4190e5:	41 f7 c4 00 20 00 00 	test   r12d,0x2000
  4190ec:	44 0f 45 e0          	cmovne r12d,eax
		switch(t) {
  4190f0:	8d 42 bf             	lea    eax,[rdx-0x41]
  4190f3:	83 f8 37             	cmp    eax,0x37
  4190f6:	0f 87 0c 02 00 00    	ja     419308 <printf_core+0x5b8>
  4190fc:	48 8d 0d 2d 50 00 00 	lea    rcx,[rip+0x502d]        # 41e130 <CSWTCH.186+0x7e0>
  419103:	48 63 04 81          	movsxd rax,DWORD PTR [rcx+rax*4]
  419107:	48 01 c8             	add    rax,rcx
  41910a:	3e ff e0             	notrack jmp rax
  41910d:	0f 1f 00             	nop    DWORD PTR [rax]
		} else if ((w=getint(&s))<0) goto overflow;
  419110:	83 fa ff             	cmp    edx,0xffffffff
  419113:	0f 85 dc fd ff ff    	jne    418ef5 <printf_core+0x1a5>
	errno = EOVERFLOW;
  419119:	e8 52 cc ff ff       	call   415d70 <__errno_location>
	return -1;
  41911e:	c7 44 24 08 ff ff ff 	mov    DWORD PTR [rsp+0x8],0xffffffff
  419125:	ff 
	errno = EOVERFLOW;
  419126:	c7 00 4b 00 00 00    	mov    DWORD PTR [rax],0x4b
	return -1;
  41912c:	e9 c0 fe ff ff       	jmp    418ff1 <printf_core+0x2a1>
  419131:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
			if (isdigit(s[1]) && s[2]=='$') {
  419138:	80 7b 02 24          	cmp    BYTE PTR [rbx+0x2],0x24
  41913c:	0f 85 6c fd ff ff    	jne    418eae <printf_core+0x15e>
				nl_type[s[1]-'0'] = INT;
  419142:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
				w = nl_arg[s[1]-'0'].i;
  419147:	48 8b 7c 24 28       	mov    rdi,QWORD PTR [rsp+0x28]
				l10n=1;
  41914c:	c7 44 24 0c 01 00 00 	mov    DWORD PTR [rsp+0xc],0x1
  419153:	00 
				s+=3;
  419154:	48 83 c3 03          	add    rbx,0x3
				nl_type[s[1]-'0'] = INT;
  419158:	c7 84 88 40 ff ff ff 	mov    DWORD PTR [rax+rcx*4-0xc0],0xa
  41915f:	0a 00 00 00 
				w = nl_arg[s[1]-'0'].i;
  419163:	48 0f be 43 fe       	movsx  rax,BYTE PTR [rbx-0x2]
  419168:	48 c1 e0 04          	shl    rax,0x4
  41916c:	8b ac 07 00 fd ff ff 	mov    ebp,DWORD PTR [rdi+rax*1-0x300]
				s+=3;
  419173:	e9 6d fd ff ff       	jmp    418ee5 <printf_core+0x195>
		for (fl=0; (unsigned)*s-' '<32 && (FLAGMASK&(1U<<*s-' ')); s++)
  419178:	0f be 4b 03          	movsx  ecx,BYTE PTR [rbx+0x3]
			l10n=1;
  41917c:	c7 44 24 0c 01 00 00 	mov    DWORD PTR [rsp+0xc],0x1
  419183:	00 
			s+=3;
  419184:	48 83 c3 03          	add    rbx,0x3
		for (fl=0; (unsigned)*s-' '<32 && (FLAGMASK&(1U<<*s-' ')); s++)
  419188:	89 c8                	mov    eax,ecx
			s+=3;
  41918a:	e9 c2 fc ff ff       	jmp    418e51 <printf_core+0x101>
			if (argpos>=0) goto inval;
  41918f:	83 fe ff             	cmp    esi,0xffffffff
  419192:	0f 84 20 ff ff ff    	je     4190b8 <printf_core+0x368>
  419198:	e9 41 fe ff ff       	jmp    418fde <printf_core+0x28e>
  41919d:	0f 1f 00             	nop    DWORD PTR [rax]
				w = f ? va_arg(*ap, int) : 0;
  4191a0:	48 8b 57 08          	mov    rdx,QWORD PTR [rdi+0x8]
  4191a4:	48 8d 42 08          	lea    rax,[rdx+0x8]
  4191a8:	48 89 47 08          	mov    QWORD PTR [rdi+0x8],rax
  4191ac:	e9 32 fd ff ff       	jmp    418ee3 <printf_core+0x193>
  4191b1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (i=0; isdigit(**s); (*s)++) {
  4191b8:	8d 50 d0             	lea    edx,[rax-0x30]
			s++;
  4191bb:	48 83 c3 01          	add    rbx,0x1
	for (i=0; isdigit(**s); (*s)++) {
  4191bf:	45 89 fb             	mov    r11d,r15d
  4191c2:	83 fa 09             	cmp    edx,0x9
  4191c5:	77 53                	ja     41921a <printf_core+0x4ca>
		if (i > INT_MAX/10U || **s-'0' > INT_MAX-10*i) i = -1;
  4191c7:	bf ff ff ff ff       	mov    edi,0xffffffff
  4191cc:	eb 2d                	jmp    4191fb <printf_core+0x4ab>
  4191ce:	66 90                	xchg   ax,ax
  4191d0:	45 6b db f6          	imul   r11d,r11d,0xfffffff6
  4191d4:	83 e8 30             	sub    eax,0x30
  4191d7:	89 c2                	mov    edx,eax
  4191d9:	41 8d 8b ff ff ff 7f 	lea    ecx,[r11+0x7fffffff]
  4191e0:	44 29 da             	sub    edx,r11d
  4191e3:	39 c8                	cmp    eax,ecx
  4191e5:	0f 4f d7             	cmovg  edx,edi
	for (i=0; isdigit(**s); (*s)++) {
  4191e8:	0f be 43 01          	movsx  eax,BYTE PTR [rbx+0x1]
  4191ec:	48 83 c3 01          	add    rbx,0x1
  4191f0:	41 89 d3             	mov    r11d,edx
  4191f3:	8d 50 d0             	lea    edx,[rax-0x30]
  4191f6:	83 fa 09             	cmp    edx,0x9
  4191f9:	77 1f                	ja     41921a <printf_core+0x4ca>
		if (i > INT_MAX/10U || **s-'0' > INT_MAX-10*i) i = -1;
  4191fb:	41 81 fb cc cc cc 0c 	cmp    r11d,0xccccccc
  419202:	76 cc                	jbe    4191d0 <printf_core+0x480>
	for (i=0; isdigit(**s); (*s)++) {
  419204:	0f be 43 01          	movsx  eax,BYTE PTR [rbx+0x1]
  419208:	48 83 c3 01          	add    rbx,0x1
		if (i > INT_MAX/10U || **s-'0' > INT_MAX-10*i) i = -1;
  41920c:	41 bb ff ff ff ff    	mov    r11d,0xffffffff
	for (i=0; isdigit(**s); (*s)++) {
  419212:	8d 50 d0             	lea    edx,[rax-0x30]
  419215:	83 fa 09             	cmp    edx,0x9
  419218:	76 e1                	jbe    4191fb <printf_core+0x4ab>
			xp = 1;
  41921a:	c7 44 24 18 01 00 00 	mov    DWORD PTR [rsp+0x18],0x1
  419221:	00 
  419222:	e9 74 fd ff ff       	jmp    418f9b <printf_core+0x24b>
				p = f ? va_arg(*ap, int) : 0;
  419227:	48 8b 57 08          	mov    rdx,QWORD PTR [rdi+0x8]
  41922b:	48 8d 42 08          	lea    rax,[rdx+0x8]
  41922f:	48 89 47 08          	mov    QWORD PTR [rdi+0x8],rax
  419233:	e9 1c fd ff ff       	jmp    418f54 <printf_core+0x204>
			else if (f) pop_arg(&arg, st, ap);
  419238:	4d 85 f6             	test   r14,r14
  41923b:	0f 84 0c 0d 00 00    	je     419f4d <printf_core+0x11fd>
  419241:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
  419246:	48 8d 7c 24 70       	lea    rdi,[rsp+0x70]
  41924b:	89 c6                	mov    esi,eax
  41924d:	e8 7e cb ff ff       	call   415dd0 <pop_arg>
		if (!f) continue;
  419252:	e9 6a fe ff ff       	jmp    4190c1 <printf_core+0x371>
				nl_type[s[2]-'0'] = INT;
  419257:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
				p = nl_arg[s[2]-'0'].i;
  41925c:	48 8b 7c 24 28       	mov    rdi,QWORD PTR [rsp+0x28]
				s+=4;
  419261:	48 83 c3 04          	add    rbx,0x4
				nl_type[s[2]-'0'] = INT;
  419265:	c7 84 90 40 ff ff ff 	mov    DWORD PTR [rax+rdx*4-0xc0],0xa
  41926c:	0a 00 00 00 
				p = nl_arg[s[2]-'0'].i;
  419270:	48 0f be 43 fe       	movsx  rax,BYTE PTR [rbx-0x2]
  419275:	48 c1 e0 04          	shl    rax,0x4
  419279:	48 8b 84 07 00 fd ff 	mov    rax,QWORD PTR [rdi+rax*1-0x300]
  419280:	ff 
  419281:	41 89 c3             	mov    r11d,eax
			xp = (p>=0);
  419284:	f7 d0                	not    eax
  419286:	c1 e8 1f             	shr    eax,0x1f
  419289:	89 44 24 18          	mov    DWORD PTR [rsp+0x18],eax
				s+=4;
  41928d:	e9 09 fd ff ff       	jmp    418f9b <printf_core+0x24b>
  419292:	c7 44 24 18 01 00 00 	mov    DWORD PTR [rsp+0x18],0x1
  419299:	00 
				p = f ? va_arg(*ap, int) : 0;
  41929a:	45 89 fb             	mov    r11d,r15d
  41929d:	e9 c1 fc ff ff       	jmp    418f63 <printf_core+0x213>
	if (f) return cnt;
  4192a2:	4d 85 f6             	test   r14,r14
  4192a5:	0f 85 46 fd ff ff    	jne    418ff1 <printf_core+0x2a1>
	if (!l10n) return 0;
  4192ab:	44 8b 64 24 0c       	mov    r12d,DWORD PTR [rsp+0xc]
  4192b0:	45 85 e4             	test   r12d,r12d
  4192b3:	0f 84 94 0c 00 00    	je     419f4d <printf_core+0x11fd>
  4192b9:	48 8b 7c 24 28       	mov    rdi,QWORD PTR [rsp+0x28]
	for (i=1; i<=NL_ARGMAX && nl_type[i]; i++)
  4192be:	4c 8b 4c 24 10       	mov    r9,QWORD PTR [rsp+0x10]
  4192c3:	41 b8 01 00 00 00    	mov    r8d,0x1
  4192c9:	4c 8b 54 24 20       	mov    r10,QWORD PTR [rsp+0x20]
  4192ce:	48 83 c7 10          	add    rdi,0x10
  4192d2:	43 8b 34 82          	mov    esi,DWORD PTR [r10+r8*4]
  4192d6:	85 f6                	test   esi,esi
  4192d8:	0f 84 ca 0c 00 00    	je     419fa8 <printf_core+0x1258>
		pop_arg(nl_arg+i, nl_type[i], ap);
  4192de:	4c 89 ca             	mov    rdx,r9
	for (i=1; i<=NL_ARGMAX && nl_type[i]; i++)
  4192e1:	49 83 c0 01          	add    r8,0x1
		pop_arg(nl_arg+i, nl_type[i], ap);
  4192e5:	e8 e6 ca ff ff       	call   415dd0 <pop_arg>
	for (i=1; i<=NL_ARGMAX && nl_type[i]; i++)
  4192ea:	48 83 c7 10          	add    rdi,0x10
  4192ee:	49 83 f8 0a          	cmp    r8,0xa
  4192f2:	75 de                	jne    4192d2 <printf_core+0x582>
	return 1;
  4192f4:	c7 44 24 08 01 00 00 	mov    DWORD PTR [rsp+0x8],0x1
  4192fb:	00 
  4192fc:	e9 f0 fc ff ff       	jmp    418ff1 <printf_core+0x2a1>
  419301:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		if (p < z-a) p = z-a;
  419308:	48 8d 84 24 ab 00 00 	lea    rax,[rsp+0xab]
  41930f:	00 
  419310:	4c 29 d0             	sub    rax,r10
  419313:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  419318:	48 8d 35 fe 4d 00 00 	lea    rsi,[rip+0x4dfe]        # 41e11d <CSWTCH.186+0x7cd>
  41931f:	44 89 7c 24 40       	mov    DWORD PTR [rsp+0x40],r15d
  419324:	49 63 c3             	movsxd rax,r11d
  419327:	ba ff ff ff 7f       	mov    edx,0x7fffffff
  41932c:	48 89 74 24 50       	mov    QWORD PTR [rsp+0x50],rsi
  419331:	48 39 44 24 30       	cmp    QWORD PTR [rsp+0x30],rax
  419336:	7e 0e                	jle    419346 <printf_core+0x5f6>
  419338:	44 8b 5c 24 30       	mov    r11d,DWORD PTR [rsp+0x30]
		if (p > INT_MAX-pl) goto overflow;
  41933d:	41 39 d3             	cmp    r11d,edx
  419340:	0f 8f d3 fd ff ff    	jg     419119 <printf_core+0x3c9>
		if (w < pl+p) w = pl+p;
  419346:	8b 44 24 40          	mov    eax,DWORD PTR [rsp+0x40]
  41934a:	44 01 d8             	add    eax,r11d
  41934d:	89 44 24 38          	mov    DWORD PTR [rsp+0x38],eax
  419351:	8b 44 24 38          	mov    eax,DWORD PTR [rsp+0x38]
  419355:	39 c5                	cmp    ebp,eax
  419357:	0f 4c e8             	cmovl  ebp,eax
  41935a:	89 2c 24             	mov    DWORD PTR [rsp],ebp
		if (w > INT_MAX-cnt) goto overflow;
  41935d:	41 39 ed             	cmp    r13d,ebp
  419360:	0f 8c b3 fd ff ff    	jl     419119 <printf_core+0x3c9>
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  419366:	39 c5                	cmp    ebp,eax
  419368:	0f 9e 44 24 18       	setle  BYTE PTR [rsp+0x18]
  41936d:	0f b6 44 24 18       	movzx  eax,BYTE PTR [rsp+0x18]
  419372:	41 f7 c4 00 20 01 00 	test   r12d,0x12000
  419379:	0f 85 90 09 00 00    	jne    419d0f <printf_core+0xfbf>
  41937f:	84 c0                	test   al,al
  419381:	0f 85 88 09 00 00    	jne    419d0f <printf_core+0xfbf>
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  419387:	b8 00 01 00 00       	mov    eax,0x100
  41938c:	41 89 ed             	mov    r13d,ebp
	l = w - l;
  41938f:	44 2b 6c 24 38       	sub    r13d,DWORD PTR [rsp+0x38]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  419394:	be 20 00 00 00       	mov    esi,0x20
  419399:	41 39 c5             	cmp    r13d,eax
  41939c:	4c 8d bc 24 b0 00 00 	lea    r15,[rsp+0xb0]
  4193a3:	00 
  4193a4:	4c 89 54 24 58       	mov    QWORD PTR [rsp+0x58],r10
  4193a9:	41 0f 4e c5          	cmovle eax,r13d
  4193ad:	4c 89 ff             	mov    rdi,r15
  4193b0:	44 89 5c 24 48       	mov    DWORD PTR [rsp+0x48],r11d
  4193b5:	48 63 d0             	movsxd rdx,eax
  4193b8:	e8 cf b9 ff ff       	call   414d8c <memset>
	for (; l >= sizeof pad; l -= sizeof pad)
  4193bd:	44 8b 5c 24 48       	mov    r11d,DWORD PTR [rsp+0x48]
  4193c2:	4c 8b 54 24 58       	mov    r10,QWORD PTR [rsp+0x58]
  4193c7:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  4193ce:	0f 8e 37 0b 00 00    	jle    419f0b <printf_core+0x11bb>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4193d4:	41 8b 16             	mov    edx,DWORD PTR [r14]
  4193d7:	41 8d ad 00 ff ff ff 	lea    ebp,[r13-0x100]
  4193de:	45 89 e5             	mov    r13d,r12d
  4193e1:	45 89 dc             	mov    r12d,r11d
  4193e4:	89 d0                	mov    eax,edx
  4193e6:	83 e0 20             	and    eax,0x20
  4193e9:	0f 84 b9 08 00 00    	je     419ca8 <printf_core+0xf58>
	for (; l >= sizeof pad; l -= sizeof pad)
  4193ef:	45 89 e3             	mov    r11d,r12d
  4193f2:	45 89 ec             	mov    r12d,r13d
  4193f5:	81 fd ff 00 00 00    	cmp    ebp,0xff
  4193fb:	7e 53                	jle    419450 <printf_core+0x700>
  4193fd:	8d 95 00 e9 ff ff    	lea    edx,[rbp-0x1700]
  419403:	81 fa 00 e9 ff 7f    	cmp    edx,0x7fffe900
  419409:	0f 86 7f f8 ff ff    	jbe    418c8e <printf_core.cold+0x333>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41940f:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  419411:	81 ed 00 01 00 00    	sub    ebp,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419417:	89 d0                	mov    eax,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  419419:	41 89 ed             	mov    r13d,ebp
  41941c:	81 fd ff 00 00 00    	cmp    ebp,0xff
  419422:	77 ed                	ja     419411 <printf_core+0x6c1>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419424:	85 c0                	test   eax,eax
  419426:	75 30                	jne    419458 <printf_core+0x708>
	out(f, pad, l);
  419428:	49 63 f5             	movsxd rsi,r13d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41942b:	4c 89 f2             	mov    rdx,r14
  41942e:	4c 89 ff             	mov    rdi,r15
  419431:	4c 89 54 24 58       	mov    QWORD PTR [rsp+0x58],r10
  419436:	44 89 5c 24 48       	mov    DWORD PTR [rsp+0x48],r11d
  41943b:	e8 10 14 00 00       	call   41a850 <__fwritex>
  419440:	41 8b 06             	mov    eax,DWORD PTR [r14]
  419443:	4c 8b 54 24 58       	mov    r10,QWORD PTR [rsp+0x58]
  419448:	44 8b 5c 24 48       	mov    r11d,DWORD PTR [rsp+0x48]
  41944d:	83 e0 20             	and    eax,0x20
  419450:	85 c0                	test   eax,eax
  419452:	0f 84 c5 08 00 00    	je     419d1d <printf_core+0xfcd>
		pad(f, '0', w, pl+p, fl^ZERO_PAD);
  419458:	44 89 e0             	mov    eax,r12d
  41945b:	35 00 00 01 00       	xor    eax,0x10000
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  419460:	a9 00 20 01 00       	test   eax,0x12000
  419465:	0f 85 cd 00 00 00    	jne    419538 <printf_core+0x7e8>
  41946b:	80 7c 24 18 00       	cmp    BYTE PTR [rsp+0x18],0x0
  419470:	0f 85 c2 00 00 00    	jne    419538 <printf_core+0x7e8>
	l = w - l;
  419476:	44 8b 2c 24          	mov    r13d,DWORD PTR [rsp]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41947a:	b8 00 01 00 00       	mov    eax,0x100
	l = w - l;
  41947f:	44 2b 6c 24 38       	sub    r13d,DWORD PTR [rsp+0x38]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  419484:	4c 8d bc 24 b0 00 00 	lea    r15,[rsp+0xb0]
  41948b:	00 
  41948c:	41 39 c5             	cmp    r13d,eax
  41948f:	be 30 00 00 00       	mov    esi,0x30
  419494:	4c 89 ff             	mov    rdi,r15
  419497:	4c 89 54 24 48       	mov    QWORD PTR [rsp+0x48],r10
  41949c:	41 0f 4e c5          	cmovle eax,r13d
  4194a0:	44 89 5c 24 40       	mov    DWORD PTR [rsp+0x40],r11d
  4194a5:	48 63 d0             	movsxd rdx,eax
  4194a8:	e8 df b8 ff ff       	call   414d8c <memset>
	for (; l >= sizeof pad; l -= sizeof pad)
  4194ad:	44 8b 5c 24 40       	mov    r11d,DWORD PTR [rsp+0x40]
  4194b2:	4c 8b 54 24 48       	mov    r10,QWORD PTR [rsp+0x48]
  4194b7:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  4194be:	0f 8e 52 0a 00 00    	jle    419f16 <printf_core+0x11c6>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4194c4:	41 8b 16             	mov    edx,DWORD PTR [r14]
  4194c7:	41 8d ad 00 ff ff ff 	lea    ebp,[r13-0x100]
  4194ce:	45 89 e5             	mov    r13d,r12d
  4194d1:	45 89 dc             	mov    r12d,r11d
  4194d4:	83 e2 20             	and    edx,0x20
  4194d7:	0f 84 8b 07 00 00    	je     419c68 <printf_core+0xf18>
	for (; l >= sizeof pad; l -= sizeof pad)
  4194dd:	45 89 e3             	mov    r11d,r12d
  4194e0:	45 89 ec             	mov    r12d,r13d
  4194e3:	81 fd ff 00 00 00    	cmp    ebp,0xff
  4194e9:	7e 4d                	jle    419538 <printf_core+0x7e8>
  4194eb:	8d 85 00 e9 ff ff    	lea    eax,[rbp-0x1700]
  4194f1:	3d 00 e9 ff 7f       	cmp    eax,0x7fffe900
  4194f6:	0f 86 5f f4 ff ff    	jbe    41895b <printf_core.cold>
  4194fc:	81 ed 00 01 00 00    	sub    ebp,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419502:	89 d0                	mov    eax,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  419504:	41 89 ed             	mov    r13d,ebp
  419507:	81 fd ff 00 00 00    	cmp    ebp,0xff
  41950d:	77 ed                	ja     4194fc <printf_core+0x7ac>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41950f:	85 c0                	test   eax,eax
  419511:	75 25                	jne    419538 <printf_core+0x7e8>
	out(f, pad, l);
  419513:	49 63 f5             	movsxd rsi,r13d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419516:	4c 89 f2             	mov    rdx,r14
  419519:	4c 89 ff             	mov    rdi,r15
  41951c:	4c 89 54 24 48       	mov    QWORD PTR [rsp+0x48],r10
  419521:	44 89 5c 24 40       	mov    DWORD PTR [rsp+0x40],r11d
  419526:	e8 25 13 00 00       	call   41a850 <__fwritex>
  41952b:	4c 8b 54 24 48       	mov    r10,QWORD PTR [rsp+0x48]
  419530:	44 8b 5c 24 40       	mov    r11d,DWORD PTR [rsp+0x40]
  419535:	0f 1f 00             	nop    DWORD PTR [rax]
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  419538:	44 39 5c 24 30       	cmp    DWORD PTR [rsp+0x30],r11d
  41953d:	0f 8d a9 07 00 00    	jge    419cec <printf_core+0xf9c>
	l = w - l;
  419543:	44 2b 5c 24 30       	sub    r11d,DWORD PTR [rsp+0x30]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  419548:	b8 00 01 00 00       	mov    eax,0x100
  41954d:	be 30 00 00 00       	mov    esi,0x30
  419552:	4c 89 54 24 40       	mov    QWORD PTR [rsp+0x40],r10
  419557:	41 39 c3             	cmp    r11d,eax
  41955a:	4c 8d bc 24 b0 00 00 	lea    r15,[rsp+0xb0]
  419561:	00 
	l = w - l;
  419562:	45 89 dd             	mov    r13d,r11d
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  419565:	41 0f 4e c3          	cmovle eax,r11d
  419569:	4c 89 ff             	mov    rdi,r15
  41956c:	48 63 d0             	movsxd rdx,eax
  41956f:	e8 18 b8 ff ff       	call   414d8c <memset>
	for (; l >= sizeof pad; l -= sizeof pad)
  419574:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  41957b:	4c 8b 54 24 40       	mov    r10,QWORD PTR [rsp+0x40]
  419580:	0f 8e 4a 09 00 00    	jle    419ed0 <printf_core+0x1180>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419586:	41 8b 16             	mov    edx,DWORD PTR [r14]
  419589:	41 8d ad 00 ff ff ff 	lea    ebp,[r13-0x100]
  419590:	4d 89 d5             	mov    r13,r10
  419593:	89 d0                	mov    eax,edx
  419595:	83 e0 20             	and    eax,0x20
  419598:	0f 84 62 06 00 00    	je     419c00 <printf_core+0xeb0>
	for (; l >= sizeof pad; l -= sizeof pad)
  41959e:	4d 89 ea             	mov    r10,r13
  4195a1:	81 fd ff 00 00 00    	cmp    ebp,0xff
  4195a7:	0f 8e 45 07 00 00    	jle    419cf2 <printf_core+0xfa2>
  4195ad:	8d 95 00 e9 ff ff    	lea    edx,[rbp-0x1700]
  4195b3:	81 fa 00 e9 ff 7f    	cmp    edx,0x7fffe900
  4195b9:	0f 86 76 f5 ff ff    	jbe    418b35 <printf_core.cold+0x1da>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4195bf:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  4195c1:	81 ed 00 01 00 00    	sub    ebp,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4195c7:	89 d0                	mov    eax,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  4195c9:	41 89 ed             	mov    r13d,ebp
  4195cc:	81 fd ff 00 00 00    	cmp    ebp,0xff
  4195d2:	77 ed                	ja     4195c1 <printf_core+0x871>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4195d4:	85 c0                	test   eax,eax
  4195d6:	0f 84 89 08 00 00    	je     419e65 <printf_core+0x1115>
		pad(f, ' ', w, pl+p, fl^LEFT_ADJ);
  4195dc:	41 81 f4 00 20 00 00 	xor    r12d,0x2000
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  4195e3:	41 81 e4 00 20 01 00 	and    r12d,0x12000
  4195ea:	0f 85 1f f8 ff ff    	jne    418e0f <printf_core+0xbf>
  4195f0:	80 7c 24 18 00       	cmp    BYTE PTR [rsp+0x18],0x0
  4195f5:	0f 85 14 f8 ff ff    	jne    418e0f <printf_core+0xbf>
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  4195fb:	b8 00 01 00 00       	mov    eax,0x100
	l = w - l;
  419600:	44 8b 24 24          	mov    r12d,DWORD PTR [rsp]
  419604:	44 2b 64 24 38       	sub    r12d,DWORD PTR [rsp+0x38]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  419609:	4c 8d bc 24 b0 00 00 	lea    r15,[rsp+0xb0]
  419610:	00 
  419611:	41 39 c4             	cmp    r12d,eax
  419614:	be 20 00 00 00       	mov    esi,0x20
  419619:	4c 89 ff             	mov    rdi,r15
  41961c:	41 0f 4e c4          	cmovle eax,r12d
  419620:	48 63 d0             	movsxd rdx,eax
  419623:	e8 64 b7 ff ff       	call   414d8c <memset>
	for (; l >= sizeof pad; l -= sizeof pad)
  419628:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  41962f:	0f 8e 0d 09 00 00    	jle    419f42 <printf_core+0x11f2>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419635:	41 8b 06             	mov    eax,DWORD PTR [r14]
  419638:	41 8d ac 24 00 ff ff 	lea    ebp,[r12-0x100]
  41963f:	ff 
  419640:	83 e0 20             	and    eax,0x20
  419643:	0f 84 e7 05 00 00    	je     419c30 <printf_core+0xee0>
	for (; l >= sizeof pad; l -= sizeof pad)
  419649:	81 fd ff 00 00 00    	cmp    ebp,0xff
  41964f:	0f 8e ba f7 ff ff    	jle    418e0f <printf_core+0xbf>
  419655:	8d 95 00 e9 ff ff    	lea    edx,[rbp-0x1700]
  41965b:	81 fa 00 e9 ff 7f    	cmp    edx,0x7fffe900
  419661:	0f 86 38 f4 ff ff    	jbe    418a9f <printf_core.cold+0x144>
  419667:	81 ed 00 01 00 00    	sub    ebp,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41966d:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  41966f:	41 89 ec             	mov    r12d,ebp
  419672:	81 fd ff 00 00 00    	cmp    ebp,0xff
  419678:	77 ed                	ja     419667 <printf_core+0x917>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41967a:	85 d2                	test   edx,edx
  41967c:	0f 85 8d f7 ff ff    	jne    418e0f <printf_core+0xbf>
	out(f, pad, l);
  419682:	49 63 f4             	movsxd rsi,r12d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419685:	4c 89 f2             	mov    rdx,r14
  419688:	4c 89 ff             	mov    rdi,r15
  41968b:	e8 c0 11 00 00       	call   41a850 <__fwritex>
  419690:	e9 7a f7 ff ff       	jmp    418e0f <printf_core+0xbf>
			if (xp && p<0) goto overflow;
  419695:	45 85 db             	test   r11d,r11d
  419698:	79 0b                	jns    4196a5 <printf_core+0x955>
  41969a:	f6 44 24 18 01       	test   BYTE PTR [rsp+0x18],0x1
  41969f:	0f 85 74 fa ff ff    	jne    419119 <printf_core+0x3c9>
			l = fmt_fp(f, arg.f, w, p, fl, t);
  4196a5:	ff 74 24 78          	push   QWORD PTR [rsp+0x78]
  4196a9:	41 89 d0             	mov    r8d,edx
  4196ac:	44 89 e1             	mov    ecx,r12d
  4196af:	44 89 da             	mov    edx,r11d
  4196b2:	ff 74 24 78          	push   QWORD PTR [rsp+0x78]
  4196b6:	89 ee                	mov    esi,ebp
  4196b8:	4c 89 f7             	mov    rdi,r14
  4196bb:	e8 90 ce ff ff       	call   416550 <fmt_fp>
  4196c0:	89 44 24 10          	mov    DWORD PTR [rsp+0x10],eax
			if (l<0) goto overflow;
  4196c4:	41 5f                	pop    r15
  4196c6:	5a                   	pop    rdx
  4196c7:	85 c0                	test   eax,eax
  4196c9:	0f 89 36 f7 ff ff    	jns    418e05 <printf_core+0xb5>
  4196cf:	e9 45 fa ff ff       	jmp    419119 <printf_core+0x3c9>
  4196d4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
			a = fmt_x(arg.i, z, t&32);
  4196d8:	89 d6                	mov    esi,edx
  4196da:	83 e6 20             	and    esi,0x20
  4196dd:	48 8b 44 24 70       	mov    rax,QWORD PTR [rsp+0x70]
	for (; x; x>>=4) *--s = xdigits[(x&15)]|lower;
  4196e2:	48 85 c0             	test   rax,rax
  4196e5:	0f 84 8c 08 00 00    	je     419f77 <printf_core+0x1227>
  4196eb:	4c 8d 84 24 ab 00 00 	lea    r8,[rsp+0xab]
  4196f2:	00 
  4196f3:	48 8d 3d 36 4b 00 00 	lea    rdi,[rip+0x4b36]        # 41e230 <xdigits>
  4196fa:	4d 89 c2             	mov    r10,r8
  4196fd:	0f 1f 00             	nop    DWORD PTR [rax]
  419700:	48 89 c1             	mov    rcx,rax
  419703:	49 83 ea 01          	sub    r10,0x1
  419707:	83 e1 0f             	and    ecx,0xf
  41970a:	44 0f b6 0c 0f       	movzx  r9d,BYTE PTR [rdi+rcx*1]
  41970f:	41 09 f1             	or     r9d,esi
  419712:	48 c1 e8 04          	shr    rax,0x4
  419716:	45 88 0a             	mov    BYTE PTR [r10],r9b
  419719:	75 e5                	jne    419700 <printf_core+0x9b0>
			if (arg.i && (fl & ALT_FORM)) prefix+=(t>>4), pl=2;
  41971b:	41 f6 c4 08          	test   r12b,0x8
  41971f:	0f 85 b6 07 00 00    	jne    419edb <printf_core+0x118b>
		prefix = "-+   0X0x";
  419725:	48 8d 05 f1 49 00 00 	lea    rax,[rip+0x49f1]        # 41e11d <CSWTCH.186+0x7cd>
		pl = 0;
  41972c:	44 89 7c 24 40       	mov    DWORD PTR [rsp+0x40],r15d
		prefix = "-+   0X0x";
  419731:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
			if (xp && p<0) goto overflow;
  419736:	45 85 db             	test   r11d,r11d
  419739:	79 0b                	jns    419746 <printf_core+0x9f6>
  41973b:	f6 44 24 18 01       	test   BYTE PTR [rsp+0x18],0x1
  419740:	0f 85 d3 f9 ff ff    	jne    419119 <printf_core+0x3c9>
			if (xp) fl &= ~ZERO_PAD;
  419746:	8b 4c 24 18          	mov    ecx,DWORD PTR [rsp+0x18]
  41974a:	44 89 e0             	mov    eax,r12d
  41974d:	25 ff ff fe ff       	and    eax,0xfffeffff
  419752:	85 c9                	test   ecx,ecx
  419754:	44 0f 45 e0          	cmovne r12d,eax
			if (!arg.i && !p) {
  419758:	48 83 7c 24 70 00    	cmp    QWORD PTR [rsp+0x70],0x0
  41975e:	0f 94 c0             	sete   al
  419761:	45 85 db             	test   r11d,r11d
  419764:	75 08                	jne    41976e <printf_core+0xa1e>
  419766:	84 c0                	test   al,al
  419768:	0f 85 1a 07 00 00    	jne    419e88 <printf_core+0x1138>
			p = MAX(p, z-a + !arg.i);
  41976e:	4c 89 c6             	mov    rsi,r8
  419771:	0f b6 c0             	movzx  eax,al
  419774:	49 63 d3             	movsxd rdx,r11d
  419777:	4c 29 d6             	sub    rsi,r10
  41977a:	48 01 f0             	add    rax,rsi
  41977d:	48 89 74 24 30       	mov    QWORD PTR [rsp+0x30],rsi
  419782:	48 39 d0             	cmp    rax,rdx
  419785:	48 0f 4c c2          	cmovl  rax,rdx
		if (p > INT_MAX-pl) goto overflow;
  419789:	ba ff ff ff 7f       	mov    edx,0x7fffffff
  41978e:	2b 54 24 40          	sub    edx,DWORD PTR [rsp+0x40]
			p = MAX(p, z-a + !arg.i);
  419792:	41 89 c3             	mov    r11d,eax
		if (p < z-a) p = z-a;
  419795:	48 98                	cdqe   
  419797:	48 39 c6             	cmp    rsi,rax
  41979a:	0f 8f 98 fb ff ff    	jg     419338 <printf_core+0x5e8>
  4197a0:	e9 98 fb ff ff       	jmp    41933d <printf_core+0x5ed>
			if (arg.i>INTMAX_MAX) {
  4197a5:	48 8b 4c 24 70       	mov    rcx,QWORD PTR [rsp+0x70]
  4197aa:	48 85 c9             	test   rcx,rcx
  4197ad:	0f 88 6e 07 00 00    	js     419f21 <printf_core+0x11d1>
			pl=1;
  4197b3:	be 01 00 00 00       	mov    esi,0x1
				prefix++;
  4197b8:	48 8d 05 5f 49 00 00 	lea    rax,[rip+0x495f]        # 41e11e <CSWTCH.186+0x7ce>
			pl=1;
  4197bf:	89 74 24 40          	mov    DWORD PTR [rsp+0x40],esi
				prefix++;
  4197c3:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
			} else if (fl & MARK_POS) {
  4197c8:	41 f7 c4 00 08 00 00 	test   r12d,0x800
  4197cf:	75 22                	jne    4197f3 <printf_core+0xaa3>
			} else pl=0;
  4197d1:	41 f6 c4 01          	test   r12b,0x1
  4197d5:	44 89 f8             	mov    eax,r15d
  4197d8:	48 8d 15 40 49 00 00 	lea    rdx,[rip+0x4940]        # 41e11f <CSWTCH.186+0x7cf>
  4197df:	0f 45 c6             	cmovne eax,esi
  4197e2:	89 44 24 40          	mov    DWORD PTR [rsp+0x40],eax
  4197e6:	48 8d 42 fe          	lea    rax,[rdx-0x2]
  4197ea:	48 0f 45 c2          	cmovne rax,rdx
  4197ee:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  4197f3:	48 85 c9             	test   rcx,rcx
  4197f6:	0f 84 9c 07 00 00    	je     419f98 <printf_core+0x1248>
		prefix = "-+   0X0x";
  4197fc:	4c 8d 84 24 ab 00 00 	lea    r8,[rsp+0xab]
  419803:	00 
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  419804:	48 be cd cc cc cc cc 	movabs rsi,0xcccccccccccccccd
  41980b:	cc cc cc 
		prefix = "-+   0X0x";
  41980e:	4d 89 c2             	mov    r10,r8
  419811:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  419818:	48 89 c8             	mov    rax,rcx
  41981b:	49 83 ea 01          	sub    r10,0x1
  41981f:	48 f7 e6             	mul    rsi
  419822:	48 89 c8             	mov    rax,rcx
  419825:	48 c1 ea 03          	shr    rdx,0x3
  419829:	48 8d 3c 92          	lea    rdi,[rdx+rdx*4]
  41982d:	48 01 ff             	add    rdi,rdi
  419830:	48 29 f8             	sub    rax,rdi
  419833:	83 c0 30             	add    eax,0x30
  419836:	41 88 02             	mov    BYTE PTR [r10],al
  419839:	48 89 c8             	mov    rax,rcx
  41983c:	48 89 d1             	mov    rcx,rdx
  41983f:	48 83 f8 09          	cmp    rax,0x9
  419843:	77 d3                	ja     419818 <printf_core+0xac8>
  419845:	e9 ec fe ff ff       	jmp    419736 <printf_core+0x9e6>
			a = fmt_o(arg.i, z);
  41984a:	48 8b 44 24 70       	mov    rax,QWORD PTR [rsp+0x70]
	for (; x; x>>=3) *--s = '0' + (x&7);
  41984f:	4c 8d 84 24 ab 00 00 	lea    r8,[rsp+0xab]
  419856:	00 
  419857:	4d 89 c2             	mov    r10,r8
  41985a:	48 85 c0             	test   rax,rax
  41985d:	74 16                	je     419875 <printf_core+0xb25>
  41985f:	90                   	nop
  419860:	89 c2                	mov    edx,eax
  419862:	49 83 ea 01          	sub    r10,0x1
  419866:	83 e2 07             	and    edx,0x7
  419869:	83 c2 30             	add    edx,0x30
  41986c:	48 c1 e8 03          	shr    rax,0x3
  419870:	41 88 12             	mov    BYTE PTR [r10],dl
  419873:	75 eb                	jne    419860 <printf_core+0xb10>
		prefix = "-+   0X0x";
  419875:	48 8d 05 a1 48 00 00 	lea    rax,[rip+0x48a1]        # 41e11d <CSWTCH.186+0x7cd>
		pl = 0;
  41987c:	44 89 7c 24 40       	mov    DWORD PTR [rsp+0x40],r15d
		prefix = "-+   0X0x";
  419881:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
			if ((fl&ALT_FORM) && p<z-a+1) p=z-a+1;
  419886:	41 f6 c4 08          	test   r12b,0x8
  41988a:	0f 84 a6 fe ff ff    	je     419736 <printf_core+0x9e6>
  419890:	4c 89 c6             	mov    rsi,r8
  419893:	49 63 cb             	movsxd rcx,r11d
  419896:	44 89 d8             	mov    eax,r11d
  419899:	4c 29 d6             	sub    rsi,r10
  41989c:	8d 56 01             	lea    edx,[rsi+0x1]
  41989f:	48 39 ce             	cmp    rsi,rcx
  4198a2:	0f 4d c2             	cmovge eax,edx
  4198a5:	41 89 c3             	mov    r11d,eax
  4198a8:	e9 89 fe ff ff       	jmp    419736 <printf_core+0x9e6>
			p = MAX(p, 2*sizeof(void*));
  4198ad:	b8 10 00 00 00       	mov    eax,0x10
			fl |= ALT_FORM;
  4198b2:	be 20 00 00 00       	mov    esi,0x20
			t = 'x';
  4198b7:	ba 78 00 00 00       	mov    edx,0x78
			p = MAX(p, 2*sizeof(void*));
  4198bc:	41 39 c3             	cmp    r11d,eax
  4198bf:	44 0f 42 d8          	cmovb  r11d,eax
			fl |= ALT_FORM;
  4198c3:	41 83 cc 08          	or     r12d,0x8
  4198c7:	e9 11 fe ff ff       	jmp    4196dd <printf_core+0x98d>
			a = arg.p ? arg.p : "(null)";
  4198cc:	4c 8b 54 24 70       	mov    r10,QWORD PTR [rsp+0x70]
  4198d1:	48 8d 05 4f 48 00 00 	lea    rax,[rip+0x484f]        # 41e127 <CSWTCH.186+0x7d7>
  4198d8:	4d 85 d2             	test   r10,r10
  4198db:	4c 0f 44 d0          	cmove  r10,rax
			z = a + strnlen(a, p<0 ? INT_MAX : p);
  4198df:	45 85 db             	test   r11d,r11d
  4198e2:	0f 88 b9 05 00 00    	js     419ea1 <printf_core+0x1151>
  4198e8:	4c 89 d7             	mov    rdi,r10
  4198eb:	49 63 f3             	movsxd rsi,r11d
  4198ee:	4c 89 14 24          	mov    QWORD PTR [rsp],r10
  4198f2:	e8 79 bf ff ff       	call   415870 <strnlen>
  4198f7:	4c 8b 14 24          	mov    r10,QWORD PTR [rsp]
  4198fb:	49 8d 14 02          	lea    rdx,[r10+rax*1]
		if (p < z-a) p = z-a;
  4198ff:	4c 29 d2             	sub    rdx,r10
			p = z-a;
  419902:	41 89 c3             	mov    r11d,eax
			fl &= ~ZERO_PAD;
  419905:	41 81 e4 ff ff fe ff 	and    r12d,0xfffeffff
		if (p < z-a) p = z-a;
  41990c:	48 89 54 24 30       	mov    QWORD PTR [rsp+0x30],rdx
			break;
  419911:	e9 02 fa ff ff       	jmp    419318 <printf_core+0x5c8>
			ws = arg.p;
  419916:	48 8b 44 24 70       	mov    rax,QWORD PTR [rsp+0x70]
  41991b:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
			for (i=l=0; i<p && *ws && (l=wctomb(mb, *ws++))>=0 && l<=p-i; i+=l);
  419920:	49 63 c3             	movsxd rax,r11d
  419923:	48 89 c7             	mov    rdi,rax
  419926:	48 85 c0             	test   rax,rax
  419929:	0f 84 67 07 00 00    	je     41a096 <printf_core+0x1346>
  41992f:	4c 8b 7c 24 30       	mov    r15,QWORD PTR [rsp+0x30]
  419934:	4c 89 f6             	mov    rsi,r14
  419937:	31 c9                	xor    ecx,ecx
  419939:	48 8d 44 24 64       	lea    rax,[rsp+0x64]
  41993e:	44 89 2c 24          	mov    DWORD PTR [rsp],r13d
  419942:	41 89 ee             	mov    r14d,ebp
  419945:	49 89 fd             	mov    r13,rdi
  419948:	48 89 5c 24 18       	mov    QWORD PTR [rsp+0x18],rbx
  41994d:	4c 89 fd             	mov    rbp,r15
  419950:	48 89 c3             	mov    rbx,rax
  419953:	49 89 f7             	mov    r15,rsi
  419956:	44 89 64 24 38       	mov    DWORD PTR [rsp+0x38],r12d
  41995b:	49 89 cc             	mov    r12,rcx
  41995e:	eb 29                	jmp    419989 <printf_core+0xc39>
  419960:	48 89 df             	mov    rdi,rbx
  419963:	48 83 c5 04          	add    rbp,0x4
  419967:	e8 c4 0c 00 00       	call   41a630 <wctomb>
  41996c:	85 c0                	test   eax,eax
  41996e:	0f 88 8a 05 00 00    	js     419efe <printf_core+0x11ae>
  419974:	4c 89 ee             	mov    rsi,r13
  419977:	48 98                	cdqe   
  419979:	4c 29 e6             	sub    rsi,r12
  41997c:	48 39 f0             	cmp    rax,rsi
  41997f:	77 0f                	ja     419990 <printf_core+0xc40>
  419981:	49 01 c4             	add    r12,rax
  419984:	4d 39 ec             	cmp    r12,r13
  419987:	73 07                	jae    419990 <printf_core+0xc40>
  419989:	8b 75 00             	mov    esi,DWORD PTR [rbp+0x0]
  41998c:	85 f6                	test   esi,esi
  41998e:	75 d0                	jne    419960 <printf_core+0xc10>
  419990:	4c 89 e1             	mov    rcx,r12
  419993:	44 89 f5             	mov    ebp,r14d
  419996:	44 8b 2c 24          	mov    r13d,DWORD PTR [rsp]
  41999a:	48 8b 5c 24 18       	mov    rbx,QWORD PTR [rsp+0x18]
  41999f:	44 8b 64 24 38       	mov    r12d,DWORD PTR [rsp+0x38]
  4199a4:	4d 89 fe             	mov    r14,r15
			if (i > INT_MAX) goto overflow;
  4199a7:	48 81 f9 ff ff ff 7f 	cmp    rcx,0x7fffffff
  4199ae:	0f 87 65 f7 ff ff    	ja     419119 <printf_core+0x3c9>
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  4199b4:	39 cd                	cmp    ebp,ecx
			p = i;
  4199b6:	89 0c 24             	mov    DWORD PTR [rsp],ecx
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  4199b9:	0f 9e 44 24 18       	setle  BYTE PTR [rsp+0x18]
  4199be:	0f b6 44 24 18       	movzx  eax,BYTE PTR [rsp+0x18]
  4199c3:	41 f7 c4 00 20 01 00 	test   r12d,0x12000
  4199ca:	0f 85 a5 00 00 00    	jne    419a75 <printf_core+0xd25>
  4199d0:	84 c0                	test   al,al
  4199d2:	0f 85 9d 00 00 00    	jne    419a75 <printf_core+0xd25>
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  4199d8:	b8 00 01 00 00       	mov    eax,0x100
	l = w - l;
  4199dd:	41 89 e8             	mov    r8d,ebp
  4199e0:	44 2b 04 24          	sub    r8d,DWORD PTR [rsp]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  4199e4:	be 20 00 00 00       	mov    esi,0x20
  4199e9:	41 39 c0             	cmp    r8d,eax
  4199ec:	4c 8d bc 24 b0 00 00 	lea    r15,[rsp+0xb0]
  4199f3:	00 
  4199f4:	48 89 4c 24 38       	mov    QWORD PTR [rsp+0x38],rcx
  4199f9:	41 0f 4e c0          	cmovle eax,r8d
  4199fd:	4c 89 ff             	mov    rdi,r15
  419a00:	44 89 44 24 18       	mov    DWORD PTR [rsp+0x18],r8d
  419a05:	48 63 d0             	movsxd rdx,eax
  419a08:	e8 7f b3 ff ff       	call   414d8c <memset>
	for (; l >= sizeof pad; l -= sizeof pad)
  419a0d:	44 8b 44 24 18       	mov    r8d,DWORD PTR [rsp+0x18]
  419a12:	48 8b 4c 24 38       	mov    rcx,QWORD PTR [rsp+0x38]
  419a17:	41 81 f8 ff 00 00 00 	cmp    r8d,0xff
  419a1e:	0f 8e 5c 06 00 00    	jle    41a080 <printf_core+0x1330>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419a24:	41 8b 06             	mov    eax,DWORD PTR [r14]
  419a27:	45 8d 98 00 ff ff ff 	lea    r11d,[r8-0x100]
  419a2e:	83 e0 20             	and    eax,0x20
  419a31:	0f 84 11 03 00 00    	je     419d48 <printf_core+0xff8>
	for (; l >= sizeof pad; l -= sizeof pad)
  419a37:	41 81 fb ff 00 00 00 	cmp    r11d,0xff
  419a3e:	7e 30                	jle    419a70 <printf_core+0xd20>
  419a40:	41 8d 93 00 e9 ff ff 	lea    edx,[r11-0x1700]
  419a47:	81 fa 00 e9 ff 7f    	cmp    edx,0x7fffe900
  419a4d:	0f 86 a7 ef ff ff    	jbe    4189fa <printf_core.cold+0x9f>
  419a53:	41 81 eb 00 01 00 00 	sub    r11d,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419a5a:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  419a5c:	45 89 d8             	mov    r8d,r11d
  419a5f:	41 81 fb ff 00 00 00 	cmp    r11d,0xff
  419a66:	77 eb                	ja     419a53 <printf_core+0xd03>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419a68:	85 d2                	test   edx,edx
  419a6a:	0f 84 ea 04 00 00    	je     419f5a <printf_core+0x120a>
  419a70:	c6 44 24 18 00       	mov    BYTE PTR [rsp+0x18],0x0
			for (i=0; i<0U+p && *ws && i+(l=wctomb(mb, *ws++))<=p; i+=l)
  419a75:	45 31 ff             	xor    r15d,r15d
  419a78:	48 8d 44 24 64       	lea    rax,[rsp+0x64]
  419a7d:	48 85 c9             	test   rcx,rcx
  419a80:	0f 84 18 03 00 00    	je     419d9e <printf_core+0x104e>
  419a86:	44 89 6c 24 38       	mov    DWORD PTR [rsp+0x38],r13d
  419a8b:	49 89 cd             	mov    r13,rcx
  419a8e:	48 89 5c 24 40       	mov    QWORD PTR [rsp+0x40],rbx
  419a93:	48 8b 5c 24 30       	mov    rbx,QWORD PTR [rsp+0x30]
  419a98:	89 6c 24 30          	mov    DWORD PTR [rsp+0x30],ebp
  419a9c:	4c 89 fd             	mov    rbp,r15
  419a9f:	49 89 c7             	mov    r15,rax
  419aa2:	eb 0d                	jmp    419ab1 <printf_core+0xd61>
  419aa4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  419aa8:	4c 39 ed             	cmp    rbp,r13
  419aab:	0f 83 df 02 00 00    	jae    419d90 <printf_core+0x1040>
  419ab1:	8b 33                	mov    esi,DWORD PTR [rbx]
  419ab3:	85 f6                	test   esi,esi
  419ab5:	0f 84 d5 02 00 00    	je     419d90 <printf_core+0x1040>
  419abb:	4c 89 ff             	mov    rdi,r15
  419abe:	48 83 c3 04          	add    rbx,0x4
  419ac2:	e8 69 0b 00 00       	call   41a630 <wctomb>
  419ac7:	48 63 f0             	movsxd rsi,eax
  419aca:	48 01 f5             	add    rbp,rsi
  419acd:	4c 39 ed             	cmp    rbp,r13
  419ad0:	0f 87 ba 02 00 00    	ja     419d90 <printf_core+0x1040>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419ad6:	41 f6 06 20          	test   BYTE PTR [r14],0x20
  419ada:	75 cc                	jne    419aa8 <printf_core+0xd58>
  419adc:	4c 89 f2             	mov    rdx,r14
  419adf:	4c 89 ff             	mov    rdi,r15
  419ae2:	e8 69 0d 00 00       	call   41a850 <__fwritex>
  419ae7:	eb bf                	jmp    419aa8 <printf_core+0xd58>
  419ae9:	44 89 1c 24          	mov    DWORD PTR [rsp],r11d
			if (1) a = strerror(errno); else
  419aed:	e8 7e c2 ff ff       	call   415d70 <__errno_location>
  419af2:	8b 38                	mov    edi,DWORD PTR [rax]
  419af4:	e8 27 09 00 00       	call   41a420 <strerror>
  419af9:	44 8b 1c 24          	mov    r11d,DWORD PTR [rsp]
  419afd:	49 89 c2             	mov    r10,rax
  419b00:	e9 da fd ff ff       	jmp    4198df <printf_core+0xb8f>
			switch(ps) {
  419b05:	41 83 f9 07          	cmp    r9d,0x7
  419b09:	0f 87 f6 f2 ff ff    	ja     418e05 <printf_core+0xb5>
  419b0f:	48 8d 15 fa 46 00 00 	lea    rdx,[rip+0x46fa]        # 41e210 <CSWTCH.186+0x8c0>
  419b16:	4a 63 04 82          	movsxd rax,DWORD PTR [rdx+r8*4]
  419b1a:	48 01 d0             	add    rax,rdx
  419b1d:	3e ff e0             	notrack jmp rax
			case JPRE: *(uintmax_t *)arg.p = cnt; break;
  419b20:	48 63 44 24 08       	movsxd rax,DWORD PTR [rsp+0x8]
  419b25:	48 8b 54 24 70       	mov    rdx,QWORD PTR [rsp+0x70]
  419b2a:	48 89 02             	mov    QWORD PTR [rdx],rax
  419b2d:	e9 dd f2 ff ff       	jmp    418e0f <printf_core+0xbf>
			wc[0] = arg.i;
  419b32:	48 8b 44 24 70       	mov    rax,QWORD PTR [rsp+0x70]
			wc[1] = 0;
  419b37:	c7 44 24 6c 00 00 00 	mov    DWORD PTR [rsp+0x6c],0x0
  419b3e:	00 
			for (i=l=0; i<p && *ws && (l=wctomb(mb, *ws++))>=0 && l<=p-i; i+=l);
  419b3f:	48 c7 c7 ff ff ff ff 	mov    rdi,0xffffffffffffffff
			wc[0] = arg.i;
  419b46:	89 44 24 68          	mov    DWORD PTR [rsp+0x68],eax
			arg.p = wc;
  419b4a:	48 8d 44 24 68       	lea    rax,[rsp+0x68]
  419b4f:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
			ws = arg.p;
  419b54:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  419b59:	e9 d1 fd ff ff       	jmp    41992f <printf_core+0xbdf>
			*(a=z-(p=1))=arg.i;
  419b5e:	48 8b 4c 24 70       	mov    rcx,QWORD PTR [rsp+0x70]
		prefix = "-+   0X0x";
  419b63:	48 8d 05 b3 45 00 00 	lea    rax,[rip+0x45b3]        # 41e11d <CSWTCH.186+0x7cd>
		pl = 0;
  419b6a:	44 89 7c 24 40       	mov    DWORD PTR [rsp+0x40],r15d
			fl &= ~ZERO_PAD;
  419b6f:	41 81 e4 ff ff fe ff 	and    r12d,0xfffeffff
			break;
  419b76:	c7 44 24 38 01 00 00 	mov    DWORD PTR [rsp+0x38],0x1
  419b7d:	00 
			*(a=z-(p=1))=arg.i;
  419b7e:	4c 8d 94 24 aa 00 00 	lea    r10,[rsp+0xaa]
  419b85:	00 
  419b86:	88 8c 24 aa 00 00 00 	mov    BYTE PTR [rsp+0xaa],cl
			break;
  419b8d:	48 c7 44 24 30 01 00 	mov    QWORD PTR [rsp+0x30],0x1
  419b94:	00 00 
		prefix = "-+   0X0x";
  419b96:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
			*(a=z-(p=1))=arg.i;
  419b9b:	c7 04 24 01 00 00 00 	mov    DWORD PTR [rsp],0x1
		if (p < z-a) p = z-a;
  419ba2:	44 8b 1c 24          	mov    r11d,DWORD PTR [rsp]
  419ba6:	e9 a6 f7 ff ff       	jmp    419351 <printf_core+0x601>
		switch(t) {
  419bab:	48 8d 05 6b 45 00 00 	lea    rax,[rip+0x456b]        # 41e11d <CSWTCH.186+0x7cd>
  419bb2:	44 89 7c 24 40       	mov    DWORD PTR [rsp+0x40],r15d
  419bb7:	48 8b 4c 24 70       	mov    rcx,QWORD PTR [rsp+0x70]
  419bbc:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
  419bc1:	e9 2d fc ff ff       	jmp    4197f3 <printf_core+0xaa3>
			case HPRE: *(unsigned short *)arg.p = cnt; break;
  419bc6:	48 8b 44 24 70       	mov    rax,QWORD PTR [rsp+0x70]
  419bcb:	0f b7 7c 24 08       	movzx  edi,WORD PTR [rsp+0x8]
  419bd0:	66 89 38             	mov    WORD PTR [rax],di
  419bd3:	e9 37 f2 ff ff       	jmp    418e0f <printf_core+0xbf>
			case HHPRE: *(unsigned char *)arg.p = cnt; break;
  419bd8:	48 8b 44 24 70       	mov    rax,QWORD PTR [rsp+0x70]
  419bdd:	0f b6 74 24 08       	movzx  esi,BYTE PTR [rsp+0x8]
  419be2:	40 88 30             	mov    BYTE PTR [rax],sil
  419be5:	e9 25 f2 ff ff       	jmp    418e0f <printf_core+0xbf>
			case BARE: *(int *)arg.p = cnt; break;
  419bea:	48 8b 44 24 70       	mov    rax,QWORD PTR [rsp+0x70]
  419bef:	8b 7c 24 08          	mov    edi,DWORD PTR [rsp+0x8]
  419bf3:	89 38                	mov    DWORD PTR [rax],edi
  419bf5:	e9 15 f2 ff ff       	jmp    418e0f <printf_core+0xbf>
  419bfa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419c00:	4c 89 f2             	mov    rdx,r14
  419c03:	be 00 01 00 00       	mov    esi,0x100
  419c08:	4c 89 ff             	mov    rdi,r15
  419c0b:	e8 40 0c 00 00       	call   41a850 <__fwritex>
  419c10:	41 8b 16             	mov    edx,DWORD PTR [r14]
  419c13:	89 d0                	mov    eax,edx
  419c15:	83 e0 20             	and    eax,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  419c18:	81 fd ff 00 00 00    	cmp    ebp,0xff
  419c1e:	0f 8e bd 00 00 00    	jle    419ce1 <printf_core+0xf91>
  419c24:	81 ed 00 01 00 00    	sub    ebp,0x100
  419c2a:	e9 64 f9 ff ff       	jmp    419593 <printf_core+0x843>
  419c2f:	90                   	nop
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419c30:	4c 89 f2             	mov    rdx,r14
  419c33:	be 00 01 00 00       	mov    esi,0x100
  419c38:	4c 89 ff             	mov    rdi,r15
	for (; l >= sizeof pad; l -= sizeof pad)
  419c3b:	41 89 ec             	mov    r12d,ebp
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419c3e:	e8 0d 0c 00 00       	call   41a850 <__fwritex>
  419c43:	41 8b 06             	mov    eax,DWORD PTR [r14]
  419c46:	89 c2                	mov    edx,eax
  419c48:	83 e2 20             	and    edx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  419c4b:	81 fd ff 00 00 00    	cmp    ebp,0xff
  419c51:	0f 8e 23 fa ff ff    	jle    41967a <printf_core+0x92a>
  419c57:	81 ed 00 01 00 00    	sub    ebp,0x100
  419c5d:	e9 de f9 ff ff       	jmp    419640 <printf_core+0x8f0>
  419c62:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419c68:	4c 89 f2             	mov    rdx,r14
  419c6b:	be 00 01 00 00       	mov    esi,0x100
  419c70:	4c 89 ff             	mov    rdi,r15
  419c73:	4c 89 54 24 40       	mov    QWORD PTR [rsp+0x40],r10
  419c78:	e8 d3 0b 00 00       	call   41a850 <__fwritex>
  419c7d:	41 8b 16             	mov    edx,DWORD PTR [r14]
	for (; l >= sizeof pad; l -= sizeof pad)
  419c80:	4c 8b 54 24 40       	mov    r10,QWORD PTR [rsp+0x40]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419c85:	89 d0                	mov    eax,edx
  419c87:	83 e0 20             	and    eax,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  419c8a:	81 fd ff 00 00 00    	cmp    ebp,0xff
  419c90:	0f 8e 33 04 00 00    	jle    41a0c9 <printf_core+0x1379>
  419c96:	81 ed 00 01 00 00    	sub    ebp,0x100
  419c9c:	e9 33 f8 ff ff       	jmp    4194d4 <printf_core+0x784>
  419ca1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419ca8:	4c 89 f2             	mov    rdx,r14
  419cab:	be 00 01 00 00       	mov    esi,0x100
  419cb0:	4c 89 ff             	mov    rdi,r15
  419cb3:	4c 89 54 24 48       	mov    QWORD PTR [rsp+0x48],r10
  419cb8:	e8 93 0b 00 00       	call   41a850 <__fwritex>
  419cbd:	41 8b 16             	mov    edx,DWORD PTR [r14]
	for (; l >= sizeof pad; l -= sizeof pad)
  419cc0:	4c 8b 54 24 48       	mov    r10,QWORD PTR [rsp+0x48]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419cc5:	89 d0                	mov    eax,edx
  419cc7:	83 e0 20             	and    eax,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  419cca:	81 fd ff 00 00 00    	cmp    ebp,0xff
  419cd0:	0f 8e e5 03 00 00    	jle    41a0bb <printf_core+0x136b>
  419cd6:	81 ed 00 01 00 00    	sub    ebp,0x100
  419cdc:	e9 03 f7 ff ff       	jmp    4193e4 <printf_core+0x694>
  419ce1:	4d 89 ea             	mov    r10,r13
  419ce4:	41 89 ed             	mov    r13d,ebp
  419ce7:	e9 e8 f8 ff ff       	jmp    4195d4 <printf_core+0x884>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419cec:	41 8b 06             	mov    eax,DWORD PTR [r14]
  419cef:	83 e0 20             	and    eax,0x20
  419cf2:	85 c0                	test   eax,eax
  419cf4:	0f 85 e2 f8 ff ff    	jne    4195dc <printf_core+0x88c>
  419cfa:	48 8b 74 24 30       	mov    rsi,QWORD PTR [rsp+0x30]
  419cff:	4c 89 f2             	mov    rdx,r14
  419d02:	4c 89 d7             	mov    rdi,r10
  419d05:	e8 46 0b 00 00       	call   41a850 <__fwritex>
  419d0a:	e9 cd f8 ff ff       	jmp    4195dc <printf_core+0x88c>
  419d0f:	41 8b 06             	mov    eax,DWORD PTR [r14]
  419d12:	83 e0 20             	and    eax,0x20
  419d15:	85 c0                	test   eax,eax
  419d17:	0f 85 3b f7 ff ff    	jne    419458 <printf_core+0x708>
		out(f, prefix, pl);
  419d1d:	48 63 74 24 40       	movsxd rsi,DWORD PTR [rsp+0x40]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419d22:	48 8b 7c 24 50       	mov    rdi,QWORD PTR [rsp+0x50]
  419d27:	4c 89 f2             	mov    rdx,r14
  419d2a:	4c 89 54 24 58       	mov    QWORD PTR [rsp+0x58],r10
  419d2f:	44 89 5c 24 48       	mov    DWORD PTR [rsp+0x48],r11d
  419d34:	e8 17 0b 00 00       	call   41a850 <__fwritex>
  419d39:	4c 8b 54 24 58       	mov    r10,QWORD PTR [rsp+0x58]
  419d3e:	44 8b 5c 24 48       	mov    r11d,DWORD PTR [rsp+0x48]
  419d43:	e9 10 f7 ff ff       	jmp    419458 <printf_core+0x708>
  419d48:	4c 89 f2             	mov    rdx,r14
  419d4b:	be 00 01 00 00       	mov    esi,0x100
  419d50:	4c 89 ff             	mov    rdi,r15
  419d53:	44 89 5c 24 38       	mov    DWORD PTR [rsp+0x38],r11d
  419d58:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
  419d5d:	e8 ee 0a 00 00       	call   41a850 <__fwritex>
  419d62:	41 8b 06             	mov    eax,DWORD PTR [r14]
	for (; l >= sizeof pad; l -= sizeof pad)
  419d65:	44 8b 5c 24 38       	mov    r11d,DWORD PTR [rsp+0x38]
  419d6a:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419d6f:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  419d71:	45 89 d8             	mov    r8d,r11d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419d74:	83 e2 20             	and    edx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  419d77:	41 81 fb ff 00 00 00 	cmp    r11d,0xff
  419d7e:	0f 8e e4 fc ff ff    	jle    419a68 <printf_core+0xd18>
  419d84:	41 81 eb 00 01 00 00 	sub    r11d,0x100
  419d8b:	e9 9e fc ff ff       	jmp    419a2e <printf_core+0xcde>
  419d90:	44 8b 6c 24 38       	mov    r13d,DWORD PTR [rsp+0x38]
  419d95:	48 8b 5c 24 40       	mov    rbx,QWORD PTR [rsp+0x40]
  419d9a:	8b 6c 24 30          	mov    ebp,DWORD PTR [rsp+0x30]
			pad(f, ' ', w, p, fl^LEFT_ADJ);
  419d9e:	41 81 f4 00 20 00 00 	xor    r12d,0x2000
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  419da5:	41 81 e4 00 20 01 00 	and    r12d,0x12000
  419dac:	75 68                	jne    419e16 <printf_core+0x10c6>
  419dae:	80 7c 24 18 00       	cmp    BYTE PTR [rsp+0x18],0x0
  419db3:	75 61                	jne    419e16 <printf_core+0x10c6>
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  419db5:	b8 00 01 00 00       	mov    eax,0x100
	l = w - l;
  419dba:	41 89 e9             	mov    r9d,ebp
  419dbd:	44 2b 0c 24          	sub    r9d,DWORD PTR [rsp]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  419dc1:	be 20 00 00 00       	mov    esi,0x20
  419dc6:	41 39 c1             	cmp    r9d,eax
  419dc9:	4c 8d bc 24 b0 00 00 	lea    r15,[rsp+0xb0]
  419dd0:	00 
  419dd1:	44 89 4c 24 18       	mov    DWORD PTR [rsp+0x18],r9d
  419dd6:	41 0f 4e c1          	cmovle eax,r9d
  419dda:	4c 89 ff             	mov    rdi,r15
  419ddd:	48 63 d0             	movsxd rdx,eax
  419de0:	e8 a7 af ff ff       	call   414d8c <memset>
	for (; l >= sizeof pad; l -= sizeof pad)
  419de5:	44 8b 4c 24 18       	mov    r9d,DWORD PTR [rsp+0x18]
  419dea:	45 89 cc             	mov    r12d,r9d
  419ded:	41 81 f9 ff 00 00 00 	cmp    r9d,0xff
  419df4:	0f 8e 91 02 00 00    	jle    41a08b <printf_core+0x133b>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419dfa:	41 8b 06             	mov    eax,DWORD PTR [r14]
  419dfd:	83 e0 20             	and    eax,0x20
  419e00:	74 24                	je     419e26 <printf_core+0x10d6>
	for (; l >= sizeof pad; l -= sizeof pad)
  419e02:	41 8d 94 24 00 ff ff 	lea    edx,[r12-0x100]
  419e09:	ff 
  419e0a:	81 fa ff 00 00 00    	cmp    edx,0xff
  419e10:	0f 87 c0 ed ff ff    	ja     418bd6 <printf_core.cold+0x27b>
			l = w>p ? w : p;
  419e16:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  419e19:	39 e8                	cmp    eax,ebp
  419e1b:	0f 4d e8             	cmovge ebp,eax
  419e1e:	89 2c 24             	mov    DWORD PTR [rsp],ebp
			continue;
  419e21:	e9 df ef ff ff       	jmp    418e05 <printf_core+0xb5>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419e26:	4c 89 f2             	mov    rdx,r14
  419e29:	be 00 01 00 00       	mov    esi,0x100
  419e2e:	4c 89 ff             	mov    rdi,r15
	for (; l >= sizeof pad; l -= sizeof pad)
  419e31:	41 81 ec 00 01 00 00 	sub    r12d,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419e38:	e8 13 0a 00 00       	call   41a850 <__fwritex>
  419e3d:	41 8b 06             	mov    eax,DWORD PTR [r14]
	for (; l >= sizeof pad; l -= sizeof pad)
  419e40:	45 89 e1             	mov    r9d,r12d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419e43:	89 c1                	mov    ecx,eax
  419e45:	83 e1 20             	and    ecx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  419e48:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  419e4f:	77 ac                	ja     419dfd <printf_core+0x10ad>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419e51:	85 c9                	test   ecx,ecx
  419e53:	75 c1                	jne    419e16 <printf_core+0x10c6>
	out(f, pad, l);
  419e55:	49 63 f1             	movsxd rsi,r9d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419e58:	4c 89 f2             	mov    rdx,r14
  419e5b:	4c 89 ff             	mov    rdi,r15
  419e5e:	e8 ed 09 00 00       	call   41a850 <__fwritex>
  419e63:	eb b1                	jmp    419e16 <printf_core+0x10c6>
	out(f, pad, l);
  419e65:	49 63 f5             	movsxd rsi,r13d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419e68:	4c 89 f2             	mov    rdx,r14
  419e6b:	4c 89 ff             	mov    rdi,r15
  419e6e:	4c 89 54 24 40       	mov    QWORD PTR [rsp+0x40],r10
  419e73:	e8 d8 09 00 00       	call   41a850 <__fwritex>
  419e78:	41 8b 06             	mov    eax,DWORD PTR [r14]
  419e7b:	4c 8b 54 24 40       	mov    r10,QWORD PTR [rsp+0x40]
  419e80:	83 e0 20             	and    eax,0x20
  419e83:	e9 6a fe ff ff       	jmp    419cf2 <printf_core+0xfa2>
  419e88:	48 c7 44 24 30 00 00 	mov    QWORD PTR [rsp+0x30],0x0
  419e8f:	00 00 
  419e91:	8b 44 24 40          	mov    eax,DWORD PTR [rsp+0x40]
				a=z;
  419e95:	4d 89 c2             	mov    r10,r8
  419e98:	89 44 24 38          	mov    DWORD PTR [rsp+0x38],eax
  419e9c:	e9 01 fd ff ff       	jmp    419ba2 <printf_core+0xe52>
			z = a + strnlen(a, p<0 ? INT_MAX : p);
  419ea1:	4c 89 d7             	mov    rdi,r10
  419ea4:	be ff ff ff 7f       	mov    esi,0x7fffffff
  419ea9:	4c 89 14 24          	mov    QWORD PTR [rsp],r10
  419ead:	e8 be b9 ff ff       	call   415870 <strnlen>
  419eb2:	4c 8b 14 24          	mov    r10,QWORD PTR [rsp]
  419eb6:	49 8d 14 02          	lea    rdx,[r10+rax*1]
			if (p<0 && *z) goto overflow;
  419eba:	80 3a 00             	cmp    BYTE PTR [rdx],0x0
  419ebd:	0f 84 3c fa ff ff    	je     4198ff <printf_core+0xbaf>
  419ec3:	e9 51 f2 ff ff       	jmp    419119 <printf_core+0x3c9>
  419ec8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  419ecf:	00 
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419ed0:	41 8b 06             	mov    eax,DWORD PTR [r14]
  419ed3:	83 e0 20             	and    eax,0x20
  419ed6:	e9 f9 f6 ff ff       	jmp    4195d4 <printf_core+0x884>
			if (arg.i && (fl & ALT_FORM)) prefix+=(t>>4), pl=2;
  419edb:	89 d0                	mov    eax,edx
  419edd:	48 8d 15 39 42 00 00 	lea    rdx,[rip+0x4239]        # 41e11d <CSWTCH.186+0x7cd>
  419ee4:	c7 44 24 40 02 00 00 	mov    DWORD PTR [rsp+0x40],0x2
  419eeb:	00 
  419eec:	c1 f8 04             	sar    eax,0x4
  419eef:	48 98                	cdqe   
  419ef1:	48 01 d0             	add    rax,rdx
  419ef4:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
  419ef9:	e9 38 f8 ff ff       	jmp    419736 <printf_core+0x9e6>
			if (l<0) return -1;
  419efe:	c7 44 24 08 ff ff ff 	mov    DWORD PTR [rsp+0x8],0xffffffff
  419f05:	ff 
  419f06:	e9 e6 f0 ff ff       	jmp    418ff1 <printf_core+0x2a1>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419f0b:	41 8b 06             	mov    eax,DWORD PTR [r14]
  419f0e:	83 e0 20             	and    eax,0x20
  419f11:	e9 0e f5 ff ff       	jmp    419424 <printf_core+0x6d4>
  419f16:	41 8b 06             	mov    eax,DWORD PTR [r14]
  419f19:	83 e0 20             	and    eax,0x20
  419f1c:	e9 ee f5 ff ff       	jmp    41950f <printf_core+0x7bf>
				arg.i=-arg.i;
  419f21:	48 f7 d9             	neg    rcx
		prefix = "-+   0X0x";
  419f24:	48 8d 05 f2 41 00 00 	lea    rax,[rip+0x41f2]        # 41e11d <CSWTCH.186+0x7cd>
			pl=1;
  419f2b:	c7 44 24 40 01 00 00 	mov    DWORD PTR [rsp+0x40],0x1
  419f32:	00 
				arg.i=-arg.i;
  419f33:	48 89 4c 24 70       	mov    QWORD PTR [rsp+0x70],rcx
		prefix = "-+   0X0x";
  419f38:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
  419f3d:	e9 ba f8 ff ff       	jmp    4197fc <printf_core+0xaac>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419f42:	41 8b 16             	mov    edx,DWORD PTR [r14]
  419f45:	83 e2 20             	and    edx,0x20
  419f48:	e9 2d f7 ff ff       	jmp    41967a <printf_core+0x92a>
			else return 0;
  419f4d:	c7 44 24 08 00 00 00 	mov    DWORD PTR [rsp+0x8],0x0
  419f54:	00 
  419f55:	e9 97 f0 ff ff       	jmp    418ff1 <printf_core+0x2a1>
	out(f, pad, l);
  419f5a:	49 63 f0             	movsxd rsi,r8d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419f5d:	4c 89 f2             	mov    rdx,r14
  419f60:	4c 89 ff             	mov    rdi,r15
  419f63:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
  419f68:	e8 e3 08 00 00       	call   41a850 <__fwritex>
  419f6d:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  419f72:	e9 f9 fa ff ff       	jmp    419a70 <printf_core+0xd20>
		prefix = "-+   0X0x";
  419f77:	48 8d 05 9f 41 00 00 	lea    rax,[rip+0x419f]        # 41e11d <CSWTCH.186+0x7cd>
	for (; x; x>>=4) *--s = xdigits[(x&15)]|lower;
  419f7e:	4c 8d 84 24 ab 00 00 	lea    r8,[rsp+0xab]
  419f85:	00 
		pl = 0;
  419f86:	44 89 7c 24 40       	mov    DWORD PTR [rsp+0x40],r15d
		prefix = "-+   0X0x";
  419f8b:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
	for (; x; x>>=4) *--s = xdigits[(x&15)]|lower;
  419f90:	4d 89 c2             	mov    r10,r8
  419f93:	e9 9e f7 ff ff       	jmp    419736 <printf_core+0x9e6>
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  419f98:	4c 8d 84 24 ab 00 00 	lea    r8,[rsp+0xab]
  419f9f:	00 
  419fa0:	4d 89 c2             	mov    r10,r8
  419fa3:	e9 8e f7 ff ff       	jmp    419736 <printf_core+0x9e6>
	for (; i<=NL_ARGMAX && !nl_type[i]; i++);
  419fa8:	49 8d 50 01          	lea    rdx,[r8+0x1]
  419fac:	49 83 f8 09          	cmp    r8,0x9
  419fb0:	0f 84 3e f3 ff ff    	je     4192f4 <printf_core+0x5a4>
  419fb6:	48 8b 74 24 20       	mov    rsi,QWORD PTR [rsp+0x20]
  419fbb:	48 8d 04 95 00 00 00 	lea    rax,[rdx*4+0x0]
  419fc2:	00 
  419fc3:	8b 2c 96             	mov    ebp,DWORD PTR [rsi+rdx*4]
  419fc6:	85 ed                	test   ebp,ebp
  419fc8:	0f 85 10 f0 ff ff    	jne    418fde <printf_core+0x28e>
  419fce:	49 83 f8 08          	cmp    r8,0x8
  419fd2:	0f 84 1c f3 ff ff    	je     4192f4 <printf_core+0x5a4>
  419fd8:	8b 5c 06 04          	mov    ebx,DWORD PTR [rsi+rax*1+0x4]
  419fdc:	85 db                	test   ebx,ebx
  419fde:	0f 85 fa ef ff ff    	jne    418fde <printf_core+0x28e>
  419fe4:	49 83 f8 07          	cmp    r8,0x7
  419fe8:	0f 84 06 f3 ff ff    	je     4192f4 <printf_core+0x5a4>
  419fee:	44 8b 5c 06 08       	mov    r11d,DWORD PTR [rsi+rax*1+0x8]
  419ff3:	45 85 db             	test   r11d,r11d
  419ff6:	0f 85 e2 ef ff ff    	jne    418fde <printf_core+0x28e>
  419ffc:	49 83 f8 06          	cmp    r8,0x6
  41a000:	0f 84 ee f2 ff ff    	je     4192f4 <printf_core+0x5a4>
  41a006:	44 8b 54 06 0c       	mov    r10d,DWORD PTR [rsi+rax*1+0xc]
  41a00b:	45 85 d2             	test   r10d,r10d
  41a00e:	0f 85 ca ef ff ff    	jne    418fde <printf_core+0x28e>
  41a014:	49 83 f8 05          	cmp    r8,0x5
  41a018:	0f 84 d6 f2 ff ff    	je     4192f4 <printf_core+0x5a4>
  41a01e:	44 8b 4c 06 10       	mov    r9d,DWORD PTR [rsi+rax*1+0x10]
  41a023:	45 85 c9             	test   r9d,r9d
  41a026:	0f 85 b2 ef ff ff    	jne    418fde <printf_core+0x28e>
  41a02c:	49 83 f8 04          	cmp    r8,0x4
  41a030:	0f 84 be f2 ff ff    	je     4192f4 <printf_core+0x5a4>
  41a036:	8b 7c 06 14          	mov    edi,DWORD PTR [rsi+rax*1+0x14]
  41a03a:	85 ff                	test   edi,edi
  41a03c:	0f 85 9c ef ff ff    	jne    418fde <printf_core+0x28e>
  41a042:	49 8d 50 07          	lea    rdx,[r8+0x7]
  41a046:	49 83 f8 03          	cmp    r8,0x3
  41a04a:	0f 84 a4 f2 ff ff    	je     4192f4 <printf_core+0x5a4>
  41a050:	8b 4c 06 18          	mov    ecx,DWORD PTR [rsi+rax*1+0x18]
  41a054:	85 c9                	test   ecx,ecx
  41a056:	0f 85 82 ef ff ff    	jne    418fde <printf_core+0x28e>
  41a05c:	48 83 fa 08          	cmp    rdx,0x8
  41a060:	0f 85 8e f2 ff ff    	jne    4192f4 <printf_core+0x5a4>
  41a066:	8b 44 06 1c          	mov    eax,DWORD PTR [rsi+rax*1+0x1c]
  41a06a:	85 c0                	test   eax,eax
  41a06c:	0f 84 82 f2 ff ff    	je     4192f4 <printf_core+0x5a4>
  41a072:	e9 67 ef ff ff       	jmp    418fde <printf_core+0x28e>
  41a077:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41a07e:	00 00 
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a080:	41 8b 16             	mov    edx,DWORD PTR [r14]
  41a083:	83 e2 20             	and    edx,0x20
  41a086:	e9 dd f9 ff ff       	jmp    419a68 <printf_core+0xd18>
  41a08b:	41 8b 0e             	mov    ecx,DWORD PTR [r14]
  41a08e:	83 e1 20             	and    ecx,0x20
  41a091:	e9 bb fd ff ff       	jmp    419e51 <printf_core+0x1101>
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41a096:	85 ed                	test   ebp,ebp
  41a098:	0f 9e c0             	setle  al
  41a09b:	88 44 24 18          	mov    BYTE PTR [rsp+0x18],al
  41a09f:	41 f7 c4 00 20 01 00 	test   r12d,0x12000
  41a0a6:	0f 85 f2 fc ff ff    	jne    419d9e <printf_core+0x104e>
			for (i=l=0; i<p && *ws && (l=wctomb(mb, *ws++))>=0 && l<=p-i; i+=l);
  41a0ac:	31 c9                	xor    ecx,ecx
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41a0ae:	84 c0                	test   al,al
  41a0b0:	0f 84 22 f9 ff ff    	je     4199d8 <printf_core+0xc88>
  41a0b6:	e9 e3 fc ff ff       	jmp    419d9e <printf_core+0x104e>
  41a0bb:	45 89 e3             	mov    r11d,r12d
  41a0be:	45 89 ec             	mov    r12d,r13d
  41a0c1:	41 89 ed             	mov    r13d,ebp
  41a0c4:	e9 5b f3 ff ff       	jmp    419424 <printf_core+0x6d4>
  41a0c9:	45 89 e3             	mov    r11d,r12d
  41a0cc:	45 89 ec             	mov    r12d,r13d
  41a0cf:	41 89 ed             	mov    r13d,ebp
  41a0d2:	e9 38 f4 ff ff       	jmp    41950f <printf_core+0x7bf>
  41a0d7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41a0de:	00 00 

000000000041a0e0 <vfprintf>:

int vfprintf(FILE *restrict f, const char *restrict fmt, va_list ap)
{
  41a0e0:	f3 0f 1e fa          	endbr64 
  41a0e4:	41 57                	push   r15
	va_list ap2;
	int nl_type[NL_ARGMAX+1] = {0};
  41a0e6:	66 0f ef c0          	pxor   xmm0,xmm0
{
  41a0ea:	41 56                	push   r14
  41a0ec:	41 55                	push   r13
  41a0ee:	49 89 f5             	mov    r13,rsi
  41a0f1:	41 54                	push   r12
  41a0f3:	55                   	push   rbp
  41a0f4:	48 89 fd             	mov    rbp,rdi
	int olderr;
	int ret;

	/* the copy allows passing va_list* even if va_list is an array */
	va_copy(ap2, ap);
	if (printf_core(0, fmt, &ap2, nl_arg, nl_type) < 0) {
  41a0f7:	31 ff                	xor    edi,edi
{
  41a0f9:	53                   	push   rbx
  41a0fa:	48 81 ec 68 01 00 00 	sub    rsp,0x168
	int nl_type[NL_ARGMAX+1] = {0};
  41a101:	0f 29 44 24 40       	movaps XMMWORD PTR [rsp+0x40],xmm0
	va_copy(ap2, ap);
  41a106:	4c 8d 74 24 28       	lea    r14,[rsp+0x28]
	if (printf_core(0, fmt, &ap2, nl_arg, nl_type) < 0) {
  41a10b:	4c 8d 44 24 40       	lea    r8,[rsp+0x40]
	int nl_type[NL_ARGMAX+1] = {0};
  41a110:	0f 29 44 24 50       	movaps XMMWORD PTR [rsp+0x50],xmm0
	if (printf_core(0, fmt, &ap2, nl_arg, nl_type) < 0) {
  41a115:	4c 8d bc 24 c0 00 00 	lea    r15,[rsp+0xc0]
  41a11c:	00 
	int nl_type[NL_ARGMAX+1] = {0};
  41a11d:	48 c7 44 24 60 00 00 	mov    QWORD PTR [rsp+0x60],0x0
  41a124:	00 00 
	va_copy(ap2, ap);
  41a126:	f3 0f 6f 0a          	movdqu xmm1,XMMWORD PTR [rdx]
	if (printf_core(0, fmt, &ap2, nl_arg, nl_type) < 0) {
  41a12a:	4c 89 f9             	mov    rcx,r15
	va_copy(ap2, ap);
  41a12d:	0f 11 4c 24 28       	movups XMMWORD PTR [rsp+0x28],xmm1
  41a132:	48 8b 42 10          	mov    rax,QWORD PTR [rdx+0x10]
	if (printf_core(0, fmt, &ap2, nl_arg, nl_type) < 0) {
  41a136:	4c 89 f2             	mov    rdx,r14
  41a139:	4c 89 44 24 10       	mov    QWORD PTR [rsp+0x10],r8
	va_copy(ap2, ap);
  41a13e:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
	if (printf_core(0, fmt, &ap2, nl_arg, nl_type) < 0) {
  41a143:	e8 08 ec ff ff       	call   418d50 <printf_core>
  41a148:	85 c0                	test   eax,eax
  41a14a:	0f 88 42 01 00 00    	js     41a292 <vfprintf+0x1b2>
		va_end(ap2);
		return -1;
	}

	FLOCK(f);
  41a150:	8b 85 8c 00 00 00    	mov    eax,DWORD PTR [rbp+0x8c]
  41a156:	c7 44 24 0c 00 00 00 	mov    DWORD PTR [rsp+0xc],0x0
  41a15d:	00 
  41a15e:	4c 8b 44 24 10       	mov    r8,QWORD PTR [rsp+0x10]
  41a163:	85 c0                	test   eax,eax
  41a165:	78 11                	js     41a178 <vfprintf+0x98>
  41a167:	48 89 ef             	mov    rdi,rbp
  41a16a:	e8 f1 04 00 00       	call   41a660 <__lockfile>
  41a16f:	4c 8b 44 24 10       	mov    r8,QWORD PTR [rsp+0x10]
  41a174:	89 44 24 0c          	mov    DWORD PTR [rsp+0xc],eax
	olderr = f->flags & F_ERR;
  41a178:	8b 45 00             	mov    eax,DWORD PTR [rbp+0x0]
	if (f->mode < 1) f->flags &= ~F_ERR;
  41a17b:	8b 95 88 00 00 00    	mov    edx,DWORD PTR [rbp+0x88]
	olderr = f->flags & F_ERR;
  41a181:	89 c1                	mov    ecx,eax
  41a183:	83 e1 20             	and    ecx,0x20
  41a186:	89 4c 24 10          	mov    DWORD PTR [rsp+0x10],ecx
	if (f->mode < 1) f->flags &= ~F_ERR;
  41a18a:	85 d2                	test   edx,edx
  41a18c:	7f 06                	jg     41a194 <vfprintf+0xb4>
  41a18e:	83 e0 df             	and    eax,0xffffffdf
  41a191:	89 45 00             	mov    DWORD PTR [rbp+0x0],eax
	if (!f->buf_size) {
  41a194:	48 83 7d 60 00       	cmp    QWORD PTR [rbp+0x60],0x0
  41a199:	0f 84 99 00 00 00    	je     41a238 <vfprintf+0x158>
		saved_buf = f->buf;
		f->buf = internal_buf;
		f->buf_size = sizeof internal_buf;
		f->wpos = f->wbase = f->wend = 0;
	}
	if (!f->wend && __towrite(f)) ret = -1;
  41a19f:	48 8b 5d 20          	mov    rbx,QWORD PTR [rbp+0x20]
  41a1a3:	48 85 db             	test   rbx,rbx
  41a1a6:	0f 84 ee 00 00 00    	je     41a29a <vfprintf+0x1ba>
	unsigned char internal_buf[80], *saved_buf = 0;
  41a1ac:	31 db                	xor    ebx,ebx
	else ret = printf_core(f, fmt, &ap2, nl_arg, nl_type);
  41a1ae:	4c 89 f9             	mov    rcx,r15
  41a1b1:	4c 89 f2             	mov    rdx,r14
  41a1b4:	4c 89 ee             	mov    rsi,r13
  41a1b7:	48 89 ef             	mov    rdi,rbp
  41a1ba:	e8 91 eb ff ff       	call   418d50 <printf_core>
  41a1bf:	41 89 c4             	mov    r12d,eax
	if (saved_buf) {
  41a1c2:	48 85 db             	test   rbx,rbx
  41a1c5:	74 34                	je     41a1fb <vfprintf+0x11b>
		f->write(f, 0, 0);
  41a1c7:	31 d2                	xor    edx,edx
  41a1c9:	31 f6                	xor    esi,esi
  41a1cb:	48 89 ef             	mov    rdi,rbp
  41a1ce:	ff 55 48             	call   QWORD PTR [rbp+0x48]
		if (!f->wpos) ret = -1;
  41a1d1:	48 83 7d 28 00       	cmp    QWORD PTR [rbp+0x28],0x0
		f->buf = saved_buf;
  41a1d6:	48 89 5d 58          	mov    QWORD PTR [rbp+0x58],rbx
		f->buf_size = 0;
		f->wpos = f->wbase = f->wend = 0;
  41a1da:	66 0f ef c0          	pxor   xmm0,xmm0
		if (!f->wpos) ret = -1;
  41a1de:	b8 ff ff ff ff       	mov    eax,0xffffffff
		f->buf_size = 0;
  41a1e3:	48 c7 45 60 00 00 00 	mov    QWORD PTR [rbp+0x60],0x0
  41a1ea:	00 
		f->wpos = f->wbase = f->wend = 0;
  41a1eb:	48 c7 45 38 00 00 00 	mov    QWORD PTR [rbp+0x38],0x0
  41a1f2:	00 
		if (!f->wpos) ret = -1;
  41a1f3:	44 0f 44 e0          	cmove  r12d,eax
		f->wpos = f->wbase = f->wend = 0;
  41a1f7:	0f 11 45 20          	movups XMMWORD PTR [rbp+0x20],xmm0
	}
	if (f->flags & F_ERR) ret = -1;
  41a1fb:	8b 45 00             	mov    eax,DWORD PTR [rbp+0x0]
	f->flags |= olderr;
  41a1fe:	44 8b 74 24 10       	mov    r14d,DWORD PTR [rsp+0x10]
	if (f->flags & F_ERR) ret = -1;
  41a203:	ba ff ff ff ff       	mov    edx,0xffffffff
  41a208:	a8 20                	test   al,0x20
  41a20a:	44 0f 45 e2          	cmovne r12d,edx
	f->flags |= olderr;
  41a20e:	41 09 c6             	or     r14d,eax
	FUNLOCK(f);
  41a211:	8b 44 24 0c          	mov    eax,DWORD PTR [rsp+0xc]
	f->flags |= olderr;
  41a215:	44 89 75 00          	mov    DWORD PTR [rbp+0x0],r14d
	FUNLOCK(f);
  41a219:	85 c0                	test   eax,eax
  41a21b:	75 6b                	jne    41a288 <vfprintf+0x1a8>
	va_end(ap2);
	return ret;
}
  41a21d:	48 81 c4 68 01 00 00 	add    rsp,0x168
  41a224:	44 89 e0             	mov    eax,r12d
  41a227:	5b                   	pop    rbx
  41a228:	5d                   	pop    rbp
  41a229:	41 5c                	pop    r12
  41a22b:	41 5d                	pop    r13
  41a22d:	41 5e                	pop    r14
  41a22f:	41 5f                	pop    r15
  41a231:	c3                   	ret    
  41a232:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
		f->buf = internal_buf;
  41a238:	48 8d 44 24 70       	lea    rax,[rsp+0x70]
		saved_buf = f->buf;
  41a23d:	48 8b 5d 58          	mov    rbx,QWORD PTR [rbp+0x58]
		f->wpos = f->wbase = f->wend = 0;
  41a241:	66 0f ef c0          	pxor   xmm0,xmm0
	if (!f->wend && __towrite(f)) ret = -1;
  41a245:	48 89 ef             	mov    rdi,rbp
		f->buf = internal_buf;
  41a248:	48 89 45 58          	mov    QWORD PTR [rbp+0x58],rax
	if (!f->wend && __towrite(f)) ret = -1;
  41a24c:	41 bc ff ff ff ff    	mov    r12d,0xffffffff
		f->buf_size = sizeof internal_buf;
  41a252:	48 c7 45 60 50 00 00 	mov    QWORD PTR [rbp+0x60],0x50
  41a259:	00 
		f->wpos = f->wbase = f->wend = 0;
  41a25a:	48 c7 45 38 00 00 00 	mov    QWORD PTR [rbp+0x38],0x0
  41a261:	00 
  41a262:	0f 11 45 20          	movups XMMWORD PTR [rbp+0x20],xmm0
  41a266:	4c 89 44 24 18       	mov    QWORD PTR [rsp+0x18],r8
	if (!f->wend && __towrite(f)) ret = -1;
  41a26b:	e8 70 05 00 00       	call   41a7e0 <__towrite>
  41a270:	85 c0                	test   eax,eax
  41a272:	0f 85 4a ff ff ff    	jne    41a1c2 <vfprintf+0xe2>
  41a278:	4c 8b 44 24 18       	mov    r8,QWORD PTR [rsp+0x18]
  41a27d:	e9 2c ff ff ff       	jmp    41a1ae <vfprintf+0xce>
  41a282:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	FUNLOCK(f);
  41a288:	48 89 ef             	mov    rdi,rbp
  41a28b:	e8 d0 04 00 00       	call   41a760 <__unlockfile>
	return ret;
  41a290:	eb 8b                	jmp    41a21d <vfprintf+0x13d>
		return -1;
  41a292:	41 bc ff ff ff ff    	mov    r12d,0xffffffff
  41a298:	eb 83                	jmp    41a21d <vfprintf+0x13d>
	if (!f->wend && __towrite(f)) ret = -1;
  41a29a:	48 89 ef             	mov    rdi,rbp
  41a29d:	4c 89 44 24 18       	mov    QWORD PTR [rsp+0x18],r8
  41a2a2:	41 83 cc ff          	or     r12d,0xffffffff
  41a2a6:	e8 35 05 00 00       	call   41a7e0 <__towrite>
  41a2ab:	85 c0                	test   eax,eax
  41a2ad:	0f 85 48 ff ff ff    	jne    41a1fb <vfprintf+0x11b>
  41a2b3:	eb c3                	jmp    41a278 <vfprintf+0x198>
  41a2b5:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41a2bc:	00 00 00 
  41a2bf:	90                   	nop

000000000041a2c0 <memchr>:
#define ONES ((size_t)-1/UCHAR_MAX)
#define HIGHS (ONES * (UCHAR_MAX/2+1))
#define HASZERO(x) ((x)-ONES & ~(x) & HIGHS)

void *memchr(const void *src, int c, size_t n)
{
  41a2c0:	f3 0f 1e fa          	endbr64 
  41a2c4:	48 89 f8             	mov    rax,rdi
	const unsigned char *s = src;
	c = (unsigned char)c;
  41a2c7:	44 0f b6 d6          	movzx  r10d,sil
#ifdef __GNUC__
	for (; ((uintptr_t)s & ALIGN) && n && *s != c; s++, n--);
  41a2cb:	a8 07                	test   al,0x7
  41a2cd:	75 21                	jne    41a2f0 <memchr+0x30>
  41a2cf:	eb 2f                	jmp    41a300 <memchr+0x40>
  41a2d1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  41a2d8:	0f b6 08             	movzx  ecx,BYTE PTR [rax]
  41a2db:	44 39 d1             	cmp    ecx,r10d
  41a2de:	0f 84 7f 00 00 00    	je     41a363 <memchr+0xa3>
  41a2e4:	48 83 c0 01          	add    rax,0x1
  41a2e8:	48 83 ea 01          	sub    rdx,0x1
  41a2ec:	a8 07                	test   al,0x7
  41a2ee:	74 10                	je     41a300 <memchr+0x40>
  41a2f0:	48 85 d2             	test   rdx,rdx
  41a2f3:	75 e3                	jne    41a2d8 <memchr+0x18>
		for (w = (const void *)s; n>=SS && !HASZERO(*w^k); w++, n-=SS);
		s = (const void *)w;
	}
#endif
	for (; n && *s != c; s++, n--);
	return n ? (void *)s : 0;
  41a2f5:	45 31 c0             	xor    r8d,r8d
}
  41a2f8:	4c 89 c0             	mov    rax,r8
  41a2fb:	c3                   	ret    
  41a2fc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	return n ? (void *)s : 0;
  41a300:	45 31 c0             	xor    r8d,r8d
	if (n && *s != c) {
  41a303:	48 85 d2             	test   rdx,rdx
  41a306:	74 f0                	je     41a2f8 <memchr+0x38>
  41a308:	0f b6 08             	movzx  ecx,BYTE PTR [rax]
  41a30b:	44 39 d1             	cmp    ecx,r10d
  41a30e:	74 53                	je     41a363 <memchr+0xa3>
		size_t k = ONES * c;
  41a310:	48 b9 01 01 01 01 01 	movabs rcx,0x101010101010101
  41a317:	01 01 01 
  41a31a:	49 63 fa             	movsxd rdi,r10d
		for (w = (const void *)s; n>=SS && !HASZERO(*w^k); w++, n-=SS);
  41a31d:	49 b9 ff fe fe fe fe 	movabs r9,0xfefefefefefefeff
  41a324:	fe fe fe 
  41a327:	49 b8 80 80 80 80 80 	movabs r8,0x8080808080808080
  41a32e:	80 80 80 
		size_t k = ONES * c;
  41a331:	48 0f af f9          	imul   rdi,rcx
		for (w = (const void *)s; n>=SS && !HASZERO(*w^k); w++, n-=SS);
  41a335:	48 83 fa 07          	cmp    rdx,0x7
  41a339:	77 13                	ja     41a34e <memchr+0x8e>
  41a33b:	eb 26                	jmp    41a363 <memchr+0xa3>
  41a33d:	0f 1f 00             	nop    DWORD PTR [rax]
  41a340:	48 83 ea 08          	sub    rdx,0x8
  41a344:	48 83 c0 08          	add    rax,0x8
  41a348:	48 83 fa 07          	cmp    rdx,0x7
  41a34c:	76 3d                	jbe    41a38b <memchr+0xcb>
  41a34e:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  41a351:	48 31 f9             	xor    rcx,rdi
  41a354:	4a 8d 34 09          	lea    rsi,[rcx+r9*1]
  41a358:	48 f7 d1             	not    rcx
  41a35b:	48 21 f1             	and    rcx,rsi
  41a35e:	4c 85 c1             	test   rcx,r8
  41a361:	74 dd                	je     41a340 <memchr+0x80>
{
  41a363:	49 89 c0             	mov    r8,rax
  41a366:	48 01 c2             	add    rdx,rax
  41a369:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (; n && *s != c; s++, n--);
  41a370:	41 0f b6 00          	movzx  eax,BYTE PTR [r8]
  41a374:	44 39 d0             	cmp    eax,r10d
  41a377:	0f 84 7b ff ff ff    	je     41a2f8 <memchr+0x38>
  41a37d:	49 83 c0 01          	add    r8,0x1
  41a381:	49 39 d0             	cmp    r8,rdx
  41a384:	75 ea                	jne    41a370 <memchr+0xb0>
  41a386:	e9 6a ff ff ff       	jmp    41a2f5 <memchr+0x35>
	return n ? (void *)s : 0;
  41a38b:	45 31 c0             	xor    r8d,r8d
	for (; n && *s != c; s++, n--);
  41a38e:	48 85 d2             	test   rdx,rdx
  41a391:	0f 84 61 ff ff ff    	je     41a2f8 <memchr+0x38>
  41a397:	eb ca                	jmp    41a363 <memchr+0xa3>
  41a399:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000041a3a0 <__strerror_l>:
static const char errmsg[] =
#include "__strerror.h"
;

char *__strerror_l(int e, locale_t loc)
{
  41a3a0:	f3 0f 1e fa          	endbr64 
	 * historical typo, so we just remap it. */
	if (EDQUOT==1133) {
		if (e==109) e=-1;
		else if (e==EDQUOT) e=109;
	}
	for (i=0; errid[i] && errid[i] != e; i++);
  41a3a4:	48 8d 0d 96 48 00 00 	lea    rcx,[rip+0x4896]        # 41ec41 <errid+0x1>
  41a3ab:	31 d2                	xor    edx,edx
  41a3ad:	b8 54 00 00 00       	mov    eax,0x54
  41a3b2:	eb 12                	jmp    41a3c6 <__strerror_l+0x26>
  41a3b4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  41a3b8:	0f b6 01             	movzx  eax,BYTE PTR [rcx]
  41a3bb:	48 83 c1 01          	add    rcx,0x1
  41a3bf:	83 c2 01             	add    edx,0x1
  41a3c2:	84 c0                	test   al,al
  41a3c4:	74 0f                	je     41a3d5 <__strerror_l+0x35>
  41a3c6:	39 f8                	cmp    eax,edi
  41a3c8:	75 ee                	jne    41a3b8 <__strerror_l+0x18>
	for (s=errmsg; i; s++, i--) for (; *s; s++);
  41a3ca:	48 8d 3d 4f 41 00 00 	lea    rdi,[rip+0x414f]        # 41e520 <errmsg>
  41a3d1:	85 d2                	test   edx,edx
  41a3d3:	74 3b                	je     41a410 <__strerror_l+0x70>
	for (i=0; errid[i] && errid[i] != e; i++);
  41a3d5:	b9 49 00 00 00       	mov    ecx,0x49
  41a3da:	48 8d 05 3f 41 00 00 	lea    rax,[rip+0x413f]        # 41e520 <errmsg>
  41a3e1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (s=errmsg; i; s++, i--) for (; *s; s++);
  41a3e8:	84 c9                	test   cl,cl
  41a3ea:	74 0d                	je     41a3f9 <__strerror_l+0x59>
  41a3ec:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  41a3f0:	48 83 c0 01          	add    rax,0x1
  41a3f4:	80 38 00             	cmp    BYTE PTR [rax],0x0
  41a3f7:	75 f7                	jne    41a3f0 <__strerror_l+0x50>
  41a3f9:	48 8d 78 01          	lea    rdi,[rax+0x1]
  41a3fd:	83 ea 01             	sub    edx,0x1
  41a400:	74 0e                	je     41a410 <__strerror_l+0x70>
  41a402:	0f b6 48 01          	movzx  ecx,BYTE PTR [rax+0x1]
  41a406:	48 89 f8             	mov    rax,rdi
  41a409:	eb dd                	jmp    41a3e8 <__strerror_l+0x48>
  41a40b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	return (char *)LCTRANS(s, LC_MESSAGES, loc);
  41a410:	48 8b 76 28          	mov    rsi,QWORD PTR [rsi+0x28]
  41a414:	e9 27 00 00 00       	jmp    41a440 <__lctrans>
  41a419:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000041a420 <strerror>:
}

char *strerror(int e)
{
  41a420:	f3 0f 1e fa          	endbr64 
static inline struct pthread *__pthread_self()
{
	struct pthread *self;
	__asm__ ("mov %%fs:0,%0" : "=r" (self) );
  41a424:	64 48 8b 04 25 00 00 	mov    rax,QWORD PTR fs:0x0
  41a42b:	00 00 
	return __strerror_l(e, CURRENT_LOCALE);
  41a42d:	48 8b b0 b0 00 00 00 	mov    rsi,QWORD PTR [rax+0xb0]
  41a434:	e9 67 ff ff ff       	jmp    41a3a0 <__strerror_l>
  41a439:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000041a440 <__lctrans>:

weak_alias(dummy, __lctrans_impl);

const char *__lctrans(const char *msg, const struct __locale_map *lm)
{
  41a440:	f3 0f 1e fa          	endbr64 
	return __lctrans_impl(msg, lm);
  41a444:	e9 57 aa ff ff       	jmp    414ea0 <__lctrans_impl>
  41a449:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000041a450 <__lctrans_cur>:
}

const char *__lctrans_cur(const char *msg)
{
  41a450:	f3 0f 1e fa          	endbr64 
  41a454:	64 48 8b 04 25 00 00 	mov    rax,QWORD PTR fs:0x0
  41a45b:	00 00 
	return __lctrans_impl(msg, CURRENT_LOCALE->cat[LC_MESSAGES]);
  41a45d:	48 8b 80 b0 00 00 00 	mov    rax,QWORD PTR [rax+0xb0]
  41a464:	48 8b 70 28          	mov    rsi,QWORD PTR [rax+0x28]
  41a468:	e9 33 aa ff ff       	jmp    414ea0 <__lctrans_impl>
  41a46d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000041a470 <__fpclassifyl>:
{
	return __fpclassify(x);
}
#elif LDBL_MANT_DIG == 64 && LDBL_MAX_EXP == 16384
int __fpclassifyl(long double x)
{
  41a470:	f3 0f 1e fa          	endbr64 
	union ldshape u = {x};
	int e = u.i.se & 0x7fff;
  41a474:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
  41a479:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
	int msb = u.i.m>>63;
  41a47e:	48 89 d1             	mov    rcx,rdx
  41a481:	89 c6                	mov    esi,eax
	int e = u.i.se & 0x7fff;
  41a483:	25 ff 7f 00 00       	and    eax,0x7fff
	int msb = u.i.m>>63;
  41a488:	48 c1 e9 3f          	shr    rcx,0x3f
  41a48c:	66 81 e6 ff 7f       	and    si,0x7fff
	if (!e && !msb)
  41a491:	09 c8                	or     eax,ecx
  41a493:	74 2b                	je     41a4c0 <__fpclassifyl+0x50>
		 * the version with it clear. */
		if (__BYTE_ORDER == __LITTLE_ENDIAN && !msb)
			return FP_NAN;
		return u.i.m << 1 ? FP_NAN : FP_INFINITE;
	}
	if (!msb)
  41a495:	8d 04 8d 00 00 00 00 	lea    eax,[rcx*4+0x0]
	if (e == 0x7fff) {
  41a49c:	66 81 fe ff 7f       	cmp    si,0x7fff
  41a4a1:	74 05                	je     41a4a8 <__fpclassifyl+0x38>
		return FP_NAN;
	return FP_NORMAL;
}
  41a4a3:	c3                   	ret    
  41a4a4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
			return FP_NAN;
  41a4a8:	31 c0                	xor    eax,eax
		if (__BYTE_ORDER == __LITTLE_ENDIAN && !msb)
  41a4aa:	48 85 c9             	test   rcx,rcx
  41a4ad:	74 f4                	je     41a4a3 <__fpclassifyl+0x33>
		return u.i.m << 1 ? FP_NAN : FP_INFINITE;
  41a4af:	31 c0                	xor    eax,eax
  41a4b1:	48 01 d2             	add    rdx,rdx
  41a4b4:	0f 94 c0             	sete   al
}
  41a4b7:	c3                   	ret    
  41a4b8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41a4bf:	00 
		return u.i.m ? FP_SUBNORMAL : FP_ZERO;
  41a4c0:	48 83 fa 01          	cmp    rdx,0x1
  41a4c4:	b8 02 00 00 00       	mov    eax,0x2
  41a4c9:	83 d8 ff             	sbb    eax,0xffffffff
  41a4cc:	c3                   	ret    
  41a4cd:	0f 1f 00             	nop    DWORD PTR [rax]

000000000041a4d0 <__signbitl>:
#include "libm.h"

#if (LDBL_MANT_DIG == 64 || LDBL_MANT_DIG == 113) && LDBL_MAX_EXP == 16384
int __signbitl(long double x)
{
  41a4d0:	f3 0f 1e fa          	endbr64 
	union ldshape u = {x};
	return u.i.se >> 15;
  41a4d4:	0f b7 44 24 10       	movzx  eax,WORD PTR [rsp+0x10]
  41a4d9:	66 c1 e8 0f          	shr    ax,0xf
  41a4dd:	0f b7 c0             	movzx  eax,ax
}
  41a4e0:	c3                   	ret    
  41a4e1:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41a4e8:	00 00 00 
  41a4eb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000041a4f0 <frexpl>:
{
	return frexp(x, e);
}
#elif (LDBL_MANT_DIG == 64 || LDBL_MANT_DIG == 113) && LDBL_MAX_EXP == 16384
long double frexpl(long double x, int *e)
{
  41a4f0:	f3 0f 1e fa          	endbr64 
  41a4f4:	48 83 ec 48          	sub    rsp,0x48
	union ldshape u = {x};
  41a4f8:	db 6c 24 50          	fld    TBYTE PTR [rsp+0x50]
  41a4fc:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
	int ee = u.i.se & 0x7fff;

	if (!ee) {
  41a501:	89 c2                	mov    edx,eax
	union ldshape u = {x};
  41a503:	d9 c0                	fld    st(0)
  41a505:	db 7c 24 20          	fstp   TBYTE PTR [rsp+0x20]
	if (!ee) {
  41a509:	66 81 e2 ff 7f       	and    dx,0x7fff
  41a50e:	74 40                	je     41a550 <frexpl+0x60>
  41a510:	dd d8                	fstp   st(0)
			x = frexpl(x*0x1p120, e);
			*e -= 120;
		} else *e = 0;
		return x;
	} else if (ee == 0x7fff) {
		return x;
  41a512:	db 6c 24 50          	fld    TBYTE PTR [rsp+0x50]
	int ee = u.i.se & 0x7fff;
  41a516:	0f b7 ca             	movzx  ecx,dx
		return x;
  41a519:	db 3c 24             	fstp   TBYTE PTR [rsp]
	} else if (ee == 0x7fff) {
  41a51c:	66 81 fa ff 7f       	cmp    dx,0x7fff
  41a521:	74 1c                	je     41a53f <frexpl+0x4f>
	}

	*e = ee - 0x3ffe;
	u.i.se &= 0x8000;
  41a523:	66 25 00 80          	and    ax,0x8000
	*e = ee - 0x3ffe;
  41a527:	81 e9 fe 3f 00 00    	sub    ecx,0x3ffe
	u.i.se |= 0x3ffe;
  41a52d:	66 0d fe 3f          	or     ax,0x3ffe
	*e = ee - 0x3ffe;
  41a531:	89 0f                	mov    DWORD PTR [rdi],ecx
	u.i.se |= 0x3ffe;
  41a533:	66 89 44 24 28       	mov    WORD PTR [rsp+0x28],ax
	return u.f;
  41a538:	db 6c 24 20          	fld    TBYTE PTR [rsp+0x20]
  41a53c:	db 3c 24             	fstp   TBYTE PTR [rsp]
}
  41a53f:	db 2c 24             	fld    TBYTE PTR [rsp]
  41a542:	48 83 c4 48          	add    rsp,0x48
  41a546:	c3                   	ret    
  41a547:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41a54e:	00 00 
		if (x) {
  41a550:	d9 ee                	fldz   
  41a552:	d9 c9                	fxch   st(1)
  41a554:	df e9                	fucomip st,st(1)
  41a556:	dd d8                	fstp   st(0)
  41a558:	7a 1e                	jp     41a578 <frexpl+0x88>
  41a55a:	75 1c                	jne    41a578 <frexpl+0x88>
		} else *e = 0;
  41a55c:	db 6c 24 50          	fld    TBYTE PTR [rsp+0x50]
  41a560:	c7 07 00 00 00 00    	mov    DWORD PTR [rdi],0x0
  41a566:	db 3c 24             	fstp   TBYTE PTR [rsp]
}
  41a569:	db 2c 24             	fld    TBYTE PTR [rsp]
  41a56c:	48 83 c4 48          	add    rsp,0x48
  41a570:	c3                   	ret    
  41a571:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
			x = frexpl(x*0x1p120, e);
  41a578:	db 6c 24 50          	fld    TBYTE PTR [rsp+0x50]
  41a57c:	d8 0d ea 3e 00 00    	fmul   DWORD PTR [rip+0x3eea]        # 41e46c <states+0x22c>
  41a582:	d9 c0                	fld    st(0)
  41a584:	db 3c 24             	fstp   TBYTE PTR [rsp]
	union ldshape u = {x};
  41a587:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
	if (!ee) {
  41a58c:	89 c1                	mov    ecx,eax
	union ldshape u = {x};
  41a58e:	db 7c 24 30          	fstp   TBYTE PTR [rsp+0x30]
	if (!ee) {
  41a592:	66 81 e1 ff 7f       	and    cx,0x7fff
  41a597:	74 37                	je     41a5d0 <frexpl+0xe0>
	int ee = u.i.se & 0x7fff;
  41a599:	0f b7 d1             	movzx  edx,cx
	} else if (ee == 0x7fff) {
  41a59c:	66 81 f9 ff 7f       	cmp    cx,0x7fff
  41a5a1:	74 75                	je     41a618 <frexpl+0x128>
	u.i.se &= 0x8000;
  41a5a3:	66 25 00 80          	and    ax,0x8000
	u.i.se |= 0x3ffe;
  41a5a7:	66 0d fe 3f          	or     ax,0x3ffe
  41a5ab:	66 89 44 24 38       	mov    WORD PTR [rsp+0x38],ax
	return u.f;
  41a5b0:	db 6c 24 30          	fld    TBYTE PTR [rsp+0x30]
			*e -= 120;
  41a5b4:	8d 82 8a bf ff ff    	lea    eax,[rdx-0x4076]
	return u.f;
  41a5ba:	db 3c 24             	fstp   TBYTE PTR [rsp]
			*e -= 120;
  41a5bd:	89 07                	mov    DWORD PTR [rdi],eax
}
  41a5bf:	db 2c 24             	fld    TBYTE PTR [rsp]
  41a5c2:	48 83 c4 48          	add    rsp,0x48
  41a5c6:	c3                   	ret    
  41a5c7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41a5ce:	00 00 
		if (x) {
  41a5d0:	d9 ee                	fldz   
  41a5d2:	db 2c 24             	fld    TBYTE PTR [rsp]
  41a5d5:	df e9                	fucomip st,st(1)
  41a5d7:	dd d8                	fstp   st(0)
  41a5d9:	7a 07                	jp     41a5e2 <frexpl+0xf2>
  41a5db:	b8 88 ff ff ff       	mov    eax,0xffffff88
  41a5e0:	74 db                	je     41a5bd <frexpl+0xcd>
			x = frexpl(x*0x1p120, e);
  41a5e2:	db 2c 24             	fld    TBYTE PTR [rsp]
  41a5e5:	d8 0d 81 3e 00 00    	fmul   DWORD PTR [rip+0x3e81]        # 41e46c <states+0x22c>
  41a5eb:	48 83 ec 10          	sub    rsp,0x10
  41a5ef:	48 89 7c 24 28       	mov    QWORD PTR [rsp+0x28],rdi
  41a5f4:	db 3c 24             	fstp   TBYTE PTR [rsp]
  41a5f7:	e8 f4 fe ff ff       	call   41a4f0 <frexpl>
			*e -= 120;
  41a5fc:	48 8b 7c 24 28       	mov    rdi,QWORD PTR [rsp+0x28]
			x = frexpl(x*0x1p120, e);
  41a601:	db 7c 24 10          	fstp   TBYTE PTR [rsp+0x10]
			*e -= 120;
  41a605:	5a                   	pop    rdx
  41a606:	59                   	pop    rcx
  41a607:	8b 07                	mov    eax,DWORD PTR [rdi]
  41a609:	2d f0 00 00 00       	sub    eax,0xf0
  41a60e:	89 07                	mov    DWORD PTR [rdi],eax
  41a610:	eb ad                	jmp    41a5bf <frexpl+0xcf>
  41a612:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  41a618:	8b 07                	mov    eax,DWORD PTR [rdi]
  41a61a:	83 e8 78             	sub    eax,0x78
  41a61d:	89 07                	mov    DWORD PTR [rdi],eax
  41a61f:	eb 9e                	jmp    41a5bf <frexpl+0xcf>
  41a621:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41a628:	00 00 00 
  41a62b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000041a630 <wctomb>:
#include <stdlib.h>
#include <wchar.h>

int wctomb(char *s, wchar_t wc)
{
  41a630:	f3 0f 1e fa          	endbr64 
	if (!s) return 0;
  41a634:	48 85 ff             	test   rdi,rdi
  41a637:	74 17                	je     41a650 <wctomb+0x20>
{
  41a639:	48 83 ec 08          	sub    rsp,0x8
	return wcrtomb(s, wc, 0);
  41a63d:	31 d2                	xor    edx,edx
  41a63f:	e8 6c 04 00 00       	call   41aab0 <wcrtomb>
}
  41a644:	48 83 c4 08          	add    rsp,0x8
  41a648:	c3                   	ret    
  41a649:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  41a650:	31 c0                	xor    eax,eax
  41a652:	c3                   	ret    
  41a653:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41a65a:	00 00 00 
  41a65d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000041a660 <__lockfile>:
#include "stdio_impl.h"
#include "pthread_impl.h"

int __lockfile(FILE *f)
{
  41a660:	f3 0f 1e fa          	endbr64 
  41a664:	41 55                	push   r13
	int owner = f->lock, tid = __pthread_self()->tid;
	if ((owner & ~MAYBE_WAITERS) == tid)
		return 0;
  41a666:	45 31 c0             	xor    r8d,r8d
{
  41a669:	41 54                	push   r12
  41a66b:	55                   	push   rbp
  41a66c:	53                   	push   rbx
  41a66d:	64 48 8b 14 25 00 00 	mov    rdx,QWORD PTR fs:0x0
  41a674:	00 00 
  41a676:	48 83 ec 08          	sub    rsp,0x8
	int owner = f->lock, tid = __pthread_self()->tid;
  41a67a:	8b 87 8c 00 00 00    	mov    eax,DWORD PTR [rdi+0x8c]
  41a680:	8b 5a 38             	mov    ebx,DWORD PTR [rdx+0x38]
	if ((owner & ~MAYBE_WAITERS) == tid)
  41a683:	25 ff ff ff bf       	and    eax,0xbfffffff
  41a688:	39 d8                	cmp    eax,ebx
  41a68a:	0f 84 b6 00 00 00    	je     41a746 <__lockfile+0xe6>
	owner = a_cas(&f->lock, 0, tid);
  41a690:	4c 8d af 8c 00 00 00 	lea    r13,[rdi+0x8c]
	__asm__ __volatile__ (
  41a697:	44 89 c0             	mov    eax,r8d
  41a69a:	f0 0f b1 9f 8c 00 00 	lock cmpxchg DWORD PTR [rdi+0x8c],ebx
  41a6a1:	00 
	if (!owner) return 1;
  41a6a2:	85 c0                	test   eax,eax
  41a6a4:	0f 84 96 00 00 00    	je     41a740 <__lockfile+0xe0>
	while ((owner = a_cas(&f->lock, 0, tid|MAYBE_WAITERS))) {
  41a6aa:	81 cb 00 00 00 40    	or     ebx,0x40000000
  41a6b0:	44 89 c0             	mov    eax,r8d
  41a6b3:	f0 0f b1 9f 8c 00 00 	lock cmpxchg DWORD PTR [rdi+0x8c],ebx
  41a6ba:	00 
  41a6bb:	89 c2                	mov    edx,eax
  41a6bd:	85 c0                	test   eax,eax
  41a6bf:	74 7f                	je     41a740 <__lockfile+0xe0>
  41a6c1:	31 ed                	xor    ebp,ebp
  41a6c3:	eb 1d                	jmp    41a6e2 <__lockfile+0x82>
  41a6c5:	0f 1f 00             	nop    DWORD PTR [rax]
  41a6c8:	89 d0                	mov    eax,edx
  41a6ca:	f0 41 0f b1 4d 00    	lock cmpxchg DWORD PTR [r13+0x0],ecx
		if ((owner & MAYBE_WAITERS) ||
  41a6d0:	39 d0                	cmp    eax,edx
  41a6d2:	74 1e                	je     41a6f2 <__lockfile+0x92>
  41a6d4:	89 e8                	mov    eax,ebp
  41a6d6:	f0 41 0f b1 5d 00    	lock cmpxchg DWORD PTR [r13+0x0],ebx
  41a6dc:	89 c2                	mov    edx,eax
	while ((owner = a_cas(&f->lock, 0, tid|MAYBE_WAITERS))) {
  41a6de:	85 c0                	test   eax,eax
  41a6e0:	74 5e                	je     41a740 <__lockfile+0xe0>
		    a_cas(&f->lock, owner, owner|MAYBE_WAITERS)==owner)
  41a6e2:	89 d1                	mov    ecx,edx
  41a6e4:	81 c9 00 00 00 40    	or     ecx,0x40000000
		if ((owner & MAYBE_WAITERS) ||
  41a6ea:	f7 c2 00 00 00 40    	test   edx,0x40000000
  41a6f0:	74 d6                	je     41a6c8 <__lockfile+0x68>
	return __cos_syscall(n, a1, a2, a3, a4, 0, 0, 0);
  41a6f2:	6a 00                	push   0x0
	__syscall(SYS_futex, addr, FUTEX_WAKE, cnt);
}
static inline void __futexwait(volatile void *addr, int val, int priv)
{
	if (priv) priv = FUTEX_PRIVATE;
	__syscall(SYS_futex, addr, FUTEX_WAIT|priv, val, 0) != -ENOSYS ||
  41a6f4:	4c 63 e1             	movsxd r12,ecx
  41a6f7:	4c 89 ee             	mov    rsi,r13
  41a6fa:	45 31 c9             	xor    r9d,r9d
  41a6fd:	6a 00                	push   0x0
  41a6ff:	4c 89 e1             	mov    rcx,r12
  41a702:	45 31 c0             	xor    r8d,r8d
  41a705:	ba 80 00 00 00       	mov    edx,0x80
  41a70a:	bf ca 00 00 00       	mov    edi,0xca
  41a70f:	e8 cc fb fe ff       	call   40a2e0 <__cos_syscall>
  41a714:	59                   	pop    rcx
  41a715:	5e                   	pop    rsi
  41a716:	48 83 f8 da          	cmp    rax,0xffffffffffffffda
  41a71a:	75 b8                	jne    41a6d4 <__lockfile+0x74>
  41a71c:	6a 00                	push   0x0
  41a71e:	31 d2                	xor    edx,edx
  41a720:	45 31 c9             	xor    r9d,r9d
  41a723:	45 31 c0             	xor    r8d,r8d
  41a726:	6a 00                	push   0x0
  41a728:	4c 89 e1             	mov    rcx,r12
  41a72b:	4c 89 ee             	mov    rsi,r13
  41a72e:	bf ca 00 00 00       	mov    edi,0xca
  41a733:	e8 a8 fb fe ff       	call   40a2e0 <__cos_syscall>
  41a738:	58                   	pop    rax
  41a739:	5a                   	pop    rdx
  41a73a:	eb 98                	jmp    41a6d4 <__lockfile+0x74>
  41a73c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	if (!owner) return 1;
  41a740:	41 b8 01 00 00 00    	mov    r8d,0x1
			__futexwait(&f->lock, owner|MAYBE_WAITERS, 1);
	}
	return 1;
}
  41a746:	48 83 c4 08          	add    rsp,0x8
  41a74a:	44 89 c0             	mov    eax,r8d
  41a74d:	5b                   	pop    rbx
  41a74e:	5d                   	pop    rbp
  41a74f:	41 5c                	pop    r12
  41a751:	41 5d                	pop    r13
  41a753:	c3                   	ret    
  41a754:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41a75b:	00 00 00 
  41a75e:	66 90                	xchg   ax,ax

000000000041a760 <__unlockfile>:

void __unlockfile(FILE *f)
{
  41a760:	f3 0f 1e fa          	endbr64 
	__asm__ __volatile__(
  41a764:	31 c0                	xor    eax,eax
  41a766:	87 87 8c 00 00 00    	xchg   DWORD PTR [rdi+0x8c],eax
	if (a_swap(&f->lock, 0) & MAYBE_WAITERS)
  41a76c:	a9 00 00 00 40       	test   eax,0x40000000
  41a771:	75 05                	jne    41a778 <__unlockfile+0x18>
  41a773:	c3                   	ret    
  41a774:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
{
  41a778:	55                   	push   rbp
  41a779:	48 8d af 8c 00 00 00 	lea    rbp,[rdi+0x8c]
	return __cos_syscall(n, a1, a2, a3, 0, 0, 0, 0);
  41a780:	b9 01 00 00 00       	mov    ecx,0x1
  41a785:	45 31 c9             	xor    r9d,r9d
  41a788:	6a 00                	push   0x0
  41a78a:	48 89 ee             	mov    rsi,rbp
  41a78d:	45 31 c0             	xor    r8d,r8d
  41a790:	ba 81 00 00 00       	mov    edx,0x81
  41a795:	6a 00                	push   0x0
  41a797:	bf ca 00 00 00       	mov    edi,0xca
  41a79c:	e8 3f fb fe ff       	call   40a2e0 <__cos_syscall>
	__syscall(SYS_futex, addr, FUTEX_WAKE|priv, cnt) != -ENOSYS ||
  41a7a1:	59                   	pop    rcx
  41a7a2:	5e                   	pop    rsi
  41a7a3:	48 83 f8 da          	cmp    rax,0xffffffffffffffda
  41a7a7:	74 07                	je     41a7b0 <__unlockfile+0x50>
		__wake(&f->lock, 1, 1);
}
  41a7a9:	5d                   	pop    rbp
  41a7aa:	c3                   	ret    
  41a7ab:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  41a7b0:	6a 00                	push   0x0
  41a7b2:	ba 01 00 00 00       	mov    edx,0x1
  41a7b7:	48 89 ee             	mov    rsi,rbp
  41a7ba:	45 31 c9             	xor    r9d,r9d
  41a7bd:	6a 00                	push   0x0
  41a7bf:	45 31 c0             	xor    r8d,r8d
  41a7c2:	b9 01 00 00 00       	mov    ecx,0x1
  41a7c7:	bf ca 00 00 00       	mov    edi,0xca
  41a7cc:	e8 0f fb fe ff       	call   40a2e0 <__cos_syscall>
  41a7d1:	58                   	pop    rax
  41a7d2:	5a                   	pop    rdx
  41a7d3:	5d                   	pop    rbp
  41a7d4:	c3                   	ret    
  41a7d5:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41a7dc:	00 00 00 
  41a7df:	90                   	nop

000000000041a7e0 <__towrite>:
#include "stdio_impl.h"

int __towrite(FILE *f)
{
  41a7e0:	f3 0f 1e fa          	endbr64 
	f->mode |= f->mode-1;
  41a7e4:	8b 97 88 00 00 00    	mov    edx,DWORD PTR [rdi+0x88]
  41a7ea:	8d 42 ff             	lea    eax,[rdx-0x1]
  41a7ed:	09 d0                	or     eax,edx
  41a7ef:	89 87 88 00 00 00    	mov    DWORD PTR [rdi+0x88],eax
	if (f->flags & F_NOWR) {
  41a7f5:	8b 07                	mov    eax,DWORD PTR [rdi]
  41a7f7:	a8 08                	test   al,0x8
  41a7f9:	75 35                	jne    41a830 <__towrite+0x50>
	}
	/* Clear read buffer (easier than summoning nasal demons) */
	f->rpos = f->rend = 0;

	/* Activate write through the buffer. */
	f->wpos = f->wbase = f->buf;
  41a7fb:	48 8b 47 58          	mov    rax,QWORD PTR [rdi+0x58]
	f->wend = f->buf + f->buf_size;
  41a7ff:	48 8b 4f 60          	mov    rcx,QWORD PTR [rdi+0x60]
	f->rpos = f->rend = 0;
  41a803:	66 0f ef c0          	pxor   xmm0,xmm0
  41a807:	0f 11 47 08          	movups XMMWORD PTR [rdi+0x8],xmm0
	f->wend = f->buf + f->buf_size;
  41a80b:	48 01 c1             	add    rcx,rax
  41a80e:	66 48 0f 6e c8       	movq   xmm1,rax
	f->wpos = f->wbase = f->buf;
  41a813:	48 89 47 38          	mov    QWORD PTR [rdi+0x38],rax

	return 0;
  41a817:	31 c0                	xor    eax,eax
	f->wend = f->buf + f->buf_size;
  41a819:	66 48 0f 6e c1       	movq   xmm0,rcx
  41a81e:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  41a822:	0f 11 47 20          	movups XMMWORD PTR [rdi+0x20],xmm0
}
  41a826:	c3                   	ret    
  41a827:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41a82e:	00 00 
		f->flags |= F_ERR;
  41a830:	83 c8 20             	or     eax,0x20
  41a833:	89 07                	mov    DWORD PTR [rdi],eax
		return EOF;
  41a835:	b8 ff ff ff ff       	mov    eax,0xffffffff
  41a83a:	c3                   	ret    
  41a83b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000041a840 <__towrite_needs_stdio_exit>:

hidden void __towrite_needs_stdio_exit()
{
  41a840:	f3 0f 1e fa          	endbr64 
	__stdio_exit_needed();
  41a844:	e9 a7 03 00 00       	jmp    41abf0 <__stdio_exit>
  41a849:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000041a850 <__fwritex>:
#include "stdio_impl.h"
#include <string.h>

size_t __fwritex(const unsigned char *restrict s, size_t l, FILE *restrict f)
{
  41a850:	f3 0f 1e fa          	endbr64 
  41a854:	41 56                	push   r14
  41a856:	41 55                	push   r13
  41a858:	49 89 f5             	mov    r13,rsi
  41a85b:	41 54                	push   r12
  41a85d:	49 89 d4             	mov    r12,rdx
  41a860:	55                   	push   rbp
  41a861:	48 89 fd             	mov    rbp,rdi
  41a864:	53                   	push   rbx
	size_t i=0;

	if (!f->wend && __towrite(f)) return 0;
  41a865:	48 8b 42 20          	mov    rax,QWORD PTR [rdx+0x20]
  41a869:	48 85 c0             	test   rax,rax
  41a86c:	0f 84 96 00 00 00    	je     41a908 <__fwritex+0xb8>

	if (l > f->wend - f->wpos) return f->write(f, s, l);
  41a872:	49 8b 7c 24 28       	mov    rdi,QWORD PTR [r12+0x28]
  41a877:	48 29 f8             	sub    rax,rdi
  41a87a:	4c 39 e8             	cmp    rax,r13
  41a87d:	72 49                	jb     41a8c8 <__fwritex+0x78>

	if (f->lbf >= 0) {
  41a87f:	41 8b 84 24 90 00 00 	mov    eax,DWORD PTR [r12+0x90]
  41a886:	00 
  41a887:	4c 89 eb             	mov    rbx,r13
  41a88a:	85 c0                	test   eax,eax
  41a88c:	79 30                	jns    41a8be <__fwritex+0x6e>
  41a88e:	4d 89 ee             	mov    r14,r13
			s += i;
			l -= i;
		}
	}

	memcpy(f->wpos, s, l);
  41a891:	4c 89 f2             	mov    rdx,r14
  41a894:	48 89 ee             	mov    rsi,rbp
  41a897:	e8 be a4 ff ff       	call   414d5a <memcpy>
	f->wpos += l;
  41a89c:	4d 01 74 24 28       	add    QWORD PTR [r12+0x28],r14
	return l+i;
  41a8a1:	4c 89 e8             	mov    rax,r13
}
  41a8a4:	5b                   	pop    rbx
  41a8a5:	5d                   	pop    rbp
  41a8a6:	41 5c                	pop    r12
  41a8a8:	41 5d                	pop    r13
  41a8aa:	41 5e                	pop    r14
  41a8ac:	c3                   	ret    
  41a8ad:	0f 1f 00             	nop    DWORD PTR [rax]
		for (i=l; i && s[i-1] != '\n'; i--);
  41a8b0:	80 7c 1d ff 0a       	cmp    BYTE PTR [rbp+rbx*1-0x1],0xa
  41a8b5:	48 8d 43 ff          	lea    rax,[rbx-0x1]
  41a8b9:	74 25                	je     41a8e0 <__fwritex+0x90>
  41a8bb:	48 89 c3             	mov    rbx,rax
  41a8be:	48 85 db             	test   rbx,rbx
  41a8c1:	75 ed                	jne    41a8b0 <__fwritex+0x60>
  41a8c3:	eb c9                	jmp    41a88e <__fwritex+0x3e>
  41a8c5:	0f 1f 00             	nop    DWORD PTR [rax]
}
  41a8c8:	5b                   	pop    rbx
	if (l > f->wend - f->wpos) return f->write(f, s, l);
  41a8c9:	49 8b 44 24 48       	mov    rax,QWORD PTR [r12+0x48]
  41a8ce:	4c 89 ea             	mov    rdx,r13
  41a8d1:	48 89 ee             	mov    rsi,rbp
  41a8d4:	4c 89 e7             	mov    rdi,r12
}
  41a8d7:	5d                   	pop    rbp
  41a8d8:	41 5c                	pop    r12
  41a8da:	41 5d                	pop    r13
  41a8dc:	41 5e                	pop    r14
	if (l > f->wend - f->wpos) return f->write(f, s, l);
  41a8de:	ff e0                	jmp    rax
			size_t n = f->write(f, s, i);
  41a8e0:	48 89 da             	mov    rdx,rbx
  41a8e3:	48 89 ee             	mov    rsi,rbp
  41a8e6:	4c 89 e7             	mov    rdi,r12
  41a8e9:	41 ff 54 24 48       	call   QWORD PTR [r12+0x48]
			if (n < i) return n;
  41a8ee:	48 39 c3             	cmp    rbx,rax
  41a8f1:	77 b1                	ja     41a8a4 <__fwritex+0x54>
			l -= i;
  41a8f3:	4d 89 ee             	mov    r14,r13
	memcpy(f->wpos, s, l);
  41a8f6:	49 8b 7c 24 28       	mov    rdi,QWORD PTR [r12+0x28]
			s += i;
  41a8fb:	48 01 dd             	add    rbp,rbx
			l -= i;
  41a8fe:	49 29 de             	sub    r14,rbx
  41a901:	eb 8e                	jmp    41a891 <__fwritex+0x41>
  41a903:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	if (!f->wend && __towrite(f)) return 0;
  41a908:	48 89 d7             	mov    rdi,rdx
  41a90b:	e8 d0 fe ff ff       	call   41a7e0 <__towrite>
  41a910:	85 c0                	test   eax,eax
  41a912:	75 0c                	jne    41a920 <__fwritex+0xd0>
	if (l > f->wend - f->wpos) return f->write(f, s, l);
  41a914:	49 8b 44 24 20       	mov    rax,QWORD PTR [r12+0x20]
  41a919:	e9 54 ff ff ff       	jmp    41a872 <__fwritex+0x22>
  41a91e:	66 90                	xchg   ax,ax
	if (!f->wend && __towrite(f)) return 0;
  41a920:	31 c0                	xor    eax,eax
  41a922:	eb 80                	jmp    41a8a4 <__fwritex+0x54>
  41a924:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41a92b:	00 00 00 
  41a92e:	66 90                	xchg   ax,ax

000000000041a930 <fwrite>:

size_t fwrite(const void *restrict src, size_t size, size_t nmemb, FILE *restrict f)
{
  41a930:	f3 0f 1e fa          	endbr64 
  41a934:	41 57                	push   r15
	size_t k, l = size*nmemb;
	if (!size) nmemb = 0;
  41a936:	31 c0                	xor    eax,eax
{
  41a938:	49 89 f8             	mov    r8,rdi
  41a93b:	41 56                	push   r14
	size_t k, l = size*nmemb;
  41a93d:	49 89 f6             	mov    r14,rsi
{
  41a940:	41 55                	push   r13
	size_t k, l = size*nmemb;
  41a942:	4c 0f af f2          	imul   r14,rdx
{
  41a946:	49 89 f5             	mov    r13,rsi
  41a949:	41 54                	push   r12
  41a94b:	49 89 d4             	mov    r12,rdx
  41a94e:	55                   	push   rbp
  41a94f:	48 89 cd             	mov    rbp,rcx
  41a952:	53                   	push   rbx
  41a953:	48 83 ec 18          	sub    rsp,0x18
	if (!size) nmemb = 0;
  41a957:	48 85 f6             	test   rsi,rsi
  41a95a:	4c 0f 44 e0          	cmove  r12,rax
	FLOCK(f);
  41a95e:	8b 81 8c 00 00 00    	mov    eax,DWORD PTR [rcx+0x8c]
  41a964:	45 31 ff             	xor    r15d,r15d
  41a967:	85 c0                	test   eax,eax
  41a969:	78 15                	js     41a980 <fwrite+0x50>
  41a96b:	48 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],rdi
  41a970:	48 89 cf             	mov    rdi,rcx
  41a973:	e8 e8 fc ff ff       	call   41a660 <__lockfile>
  41a978:	4c 8b 44 24 08       	mov    r8,QWORD PTR [rsp+0x8]
  41a97d:	41 89 c7             	mov    r15d,eax
	if (!f->wend && __towrite(f)) return 0;
  41a980:	48 8b 45 20          	mov    rax,QWORD PTR [rbp+0x20]
  41a984:	48 85 c0             	test   rax,rax
  41a987:	0f 84 f3 00 00 00    	je     41aa80 <fwrite+0x150>
	if (l > f->wend - f->wpos) return f->write(f, s, l);
  41a98d:	48 8b 7d 28          	mov    rdi,QWORD PTR [rbp+0x28]
  41a991:	48 29 f8             	sub    rax,rdi
  41a994:	49 39 c6             	cmp    r14,rax
  41a997:	77 67                	ja     41aa00 <fwrite+0xd0>
	if (f->lbf >= 0) {
  41a999:	8b 85 90 00 00 00    	mov    eax,DWORD PTR [rbp+0x90]
  41a99f:	4c 89 f3             	mov    rbx,r14
  41a9a2:	85 c0                	test   eax,eax
  41a9a4:	79 49                	jns    41a9ef <fwrite+0xbf>
  41a9a6:	4c 89 f2             	mov    rdx,r14
	memcpy(f->wpos, s, l);
  41a9a9:	4c 89 c6             	mov    rsi,r8
  41a9ac:	48 89 54 24 08       	mov    QWORD PTR [rsp+0x8],rdx
  41a9b1:	e8 a4 a3 ff ff       	call   414d5a <memcpy>
	f->wpos += l;
  41a9b6:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
  41a9bb:	48 01 55 28          	add    QWORD PTR [rbp+0x28],rdx
	k = __fwritex(src, l, f);
	FUNLOCK(f);
  41a9bf:	45 85 ff             	test   r15d,r15d
  41a9c2:	75 6c                	jne    41aa30 <fwrite+0x100>
	return k==l ? nmemb : k/size;
}
  41a9c4:	48 83 c4 18          	add    rsp,0x18
	return k==l ? nmemb : k/size;
  41a9c8:	4c 89 e0             	mov    rax,r12
}
  41a9cb:	5b                   	pop    rbx
  41a9cc:	5d                   	pop    rbp
  41a9cd:	41 5c                	pop    r12
  41a9cf:	41 5d                	pop    r13
  41a9d1:	41 5e                	pop    r14
  41a9d3:	41 5f                	pop    r15
  41a9d5:	c3                   	ret    
  41a9d6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41a9dd:	00 00 00 
		for (i=l; i && s[i-1] != '\n'; i--);
  41a9e0:	41 80 7c 18 ff 0a    	cmp    BYTE PTR [r8+rbx*1-0x1],0xa
  41a9e6:	48 8d 43 ff          	lea    rax,[rbx-0x1]
  41a9ea:	74 64                	je     41aa50 <fwrite+0x120>
  41a9ec:	48 89 c3             	mov    rbx,rax
  41a9ef:	48 85 db             	test   rbx,rbx
  41a9f2:	75 ec                	jne    41a9e0 <fwrite+0xb0>
  41a9f4:	eb b0                	jmp    41a9a6 <fwrite+0x76>
  41a9f6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41a9fd:	00 00 00 
	if (l > f->wend - f->wpos) return f->write(f, s, l);
  41aa00:	4c 89 f2             	mov    rdx,r14
  41aa03:	4c 89 c6             	mov    rsi,r8
  41aa06:	48 89 ef             	mov    rdi,rbp
  41aa09:	ff 55 48             	call   QWORD PTR [rbp+0x48]
	FUNLOCK(f);
  41aa0c:	45 85 ff             	test   r15d,r15d
  41aa0f:	75 22                	jne    41aa33 <fwrite+0x103>
	return k==l ? nmemb : k/size;
  41aa11:	49 39 c6             	cmp    r14,rax
  41aa14:	74 ae                	je     41a9c4 <fwrite+0x94>
}
  41aa16:	48 83 c4 18          	add    rsp,0x18
	return k==l ? nmemb : k/size;
  41aa1a:	31 d2                	xor    edx,edx
}
  41aa1c:	5b                   	pop    rbx
  41aa1d:	5d                   	pop    rbp
	return k==l ? nmemb : k/size;
  41aa1e:	49 f7 f5             	div    r13
}
  41aa21:	41 5c                	pop    r12
  41aa23:	41 5d                	pop    r13
  41aa25:	41 5e                	pop    r14
  41aa27:	41 5f                	pop    r15
  41aa29:	c3                   	ret    
  41aa2a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	FUNLOCK(f);
  41aa30:	4c 89 f0             	mov    rax,r14
  41aa33:	48 89 ef             	mov    rdi,rbp
  41aa36:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  41aa3b:	e8 20 fd ff ff       	call   41a760 <__unlockfile>
  41aa40:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
  41aa45:	eb ca                	jmp    41aa11 <fwrite+0xe1>
  41aa47:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41aa4e:	00 00 
			size_t n = f->write(f, s, i);
  41aa50:	4c 89 44 24 08       	mov    QWORD PTR [rsp+0x8],r8
  41aa55:	4c 89 c6             	mov    rsi,r8
  41aa58:	48 89 da             	mov    rdx,rbx
  41aa5b:	48 89 ef             	mov    rdi,rbp
  41aa5e:	ff 55 48             	call   QWORD PTR [rbp+0x48]
			if (n < i) return n;
  41aa61:	4c 8b 44 24 08       	mov    r8,QWORD PTR [rsp+0x8]
  41aa66:	48 39 c3             	cmp    rbx,rax
  41aa69:	77 a1                	ja     41aa0c <fwrite+0xdc>
			l -= i;
  41aa6b:	4c 89 f2             	mov    rdx,r14
	memcpy(f->wpos, s, l);
  41aa6e:	48 8b 7d 28          	mov    rdi,QWORD PTR [rbp+0x28]
			s += i;
  41aa72:	49 01 d8             	add    r8,rbx
			l -= i;
  41aa75:	48 29 da             	sub    rdx,rbx
  41aa78:	e9 2c ff ff ff       	jmp    41a9a9 <fwrite+0x79>
  41aa7d:	0f 1f 00             	nop    DWORD PTR [rax]
	if (!f->wend && __towrite(f)) return 0;
  41aa80:	48 89 ef             	mov    rdi,rbp
  41aa83:	4c 89 44 24 08       	mov    QWORD PTR [rsp+0x8],r8
  41aa88:	e8 53 fd ff ff       	call   41a7e0 <__towrite>
  41aa8d:	85 c0                	test   eax,eax
  41aa8f:	75 0f                	jne    41aaa0 <fwrite+0x170>
	if (l > f->wend - f->wpos) return f->write(f, s, l);
  41aa91:	48 8b 45 20          	mov    rax,QWORD PTR [rbp+0x20]
  41aa95:	4c 8b 44 24 08       	mov    r8,QWORD PTR [rsp+0x8]
  41aa9a:	e9 ee fe ff ff       	jmp    41a98d <fwrite+0x5d>
  41aa9f:	90                   	nop
	if (!f->wend && __towrite(f)) return 0;
  41aaa0:	31 c0                	xor    eax,eax
  41aaa2:	e9 65 ff ff ff       	jmp    41aa0c <fwrite+0xdc>
  41aaa7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41aaae:	00 00 

000000000041aab0 <wcrtomb>:
#include <wchar.h>
#include <errno.h>
#include "internal.h"

size_t wcrtomb(char *restrict s, wchar_t wc, mbstate_t *restrict st)
{
  41aab0:	f3 0f 1e fa          	endbr64 
	if (!s) return 1;
  41aab4:	48 85 ff             	test   rdi,rdi
  41aab7:	74 7a                	je     41ab33 <wcrtomb+0x83>
  41aab9:	48 89 fa             	mov    rdx,rdi
  41aabc:	89 f0                	mov    eax,esi
	if ((unsigned)wc < 0x80) {
  41aabe:	83 fe 7f             	cmp    esi,0x7f
  41aac1:	76 6d                	jbe    41ab30 <wcrtomb+0x80>
{
  41aac3:	48 83 ec 08          	sub    rsp,0x8
  41aac7:	64 48 8b 0c 25 00 00 	mov    rcx,QWORD PTR fs:0x0
  41aace:	00 00 
		*s = wc;
		return 1;
	} else if (MB_CUR_MAX == 1) {
  41aad0:	48 8b 89 b0 00 00 00 	mov    rcx,QWORD PTR [rcx+0xb0]
  41aad7:	48 83 39 00          	cmp    QWORD PTR [rcx],0x0
  41aadb:	74 63                	je     41ab40 <wcrtomb+0x90>
			errno = EILSEQ;
			return -1;
		}
		*s = wc;
		return 1;
	} else if ((unsigned)wc < 0x800) {
  41aadd:	81 fe ff 07 00 00    	cmp    esi,0x7ff
  41aae3:	0f 86 b7 00 00 00    	jbe    41aba0 <wcrtomb+0xf0>
		*s++ = 0xc0 | (wc>>6);
		*s = 0x80 | (wc&0x3f);
		return 2;
	} else if ((unsigned)wc < 0xd800 || (unsigned)wc-0xe000 < 0x2000) {
  41aae9:	8d 8e 00 20 ff ff    	lea    ecx,[rsi-0xe000]
  41aaef:	81 f9 ff 1f 00 00    	cmp    ecx,0x1fff
  41aaf5:	0f 86 c5 00 00 00    	jbe    41abc0 <wcrtomb+0x110>
  41aafb:	81 fe ff d7 00 00    	cmp    esi,0xd7ff
  41ab01:	0f 86 b9 00 00 00    	jbe    41abc0 <wcrtomb+0x110>
		*s++ = 0xe0 | (wc>>12);
		*s++ = 0x80 | ((wc>>6)&0x3f);
		*s = 0x80 | (wc&0x3f);
		return 3;
	} else if ((unsigned)wc-0x10000 < 0x100000) {
  41ab07:	8d 8e 00 00 ff ff    	lea    ecx,[rsi-0x10000]
  41ab0d:	81 f9 ff ff 0f 00    	cmp    ecx,0xfffff
  41ab13:	76 4b                	jbe    41ab60 <wcrtomb+0xb0>
		*s++ = 0x80 | ((wc>>12)&0x3f);
		*s++ = 0x80 | ((wc>>6)&0x3f);
		*s = 0x80 | (wc&0x3f);
		return 4;
	}
	errno = EILSEQ;
  41ab15:	e8 56 b2 ff ff       	call   415d70 <__errno_location>
  41ab1a:	c7 00 54 00 00 00    	mov    DWORD PTR [rax],0x54
	return -1;
  41ab20:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
}
  41ab27:	48 83 c4 08          	add    rsp,0x8
  41ab2b:	c3                   	ret    
  41ab2c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		*s = wc;
  41ab30:	40 88 32             	mov    BYTE PTR [rdx],sil
		return 1;
  41ab33:	b8 01 00 00 00       	mov    eax,0x1
}
  41ab38:	c3                   	ret    
  41ab39:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		if (!IS_CODEUNIT(wc)) {
  41ab40:	8d 8e 80 20 ff ff    	lea    ecx,[rsi-0xdf80]
  41ab46:	83 f9 7f             	cmp    ecx,0x7f
  41ab49:	77 ca                	ja     41ab15 <wcrtomb+0x65>
		*s = wc;
  41ab4b:	88 02                	mov    BYTE PTR [rdx],al
		return 1;
  41ab4d:	b8 01 00 00 00       	mov    eax,0x1
}
  41ab52:	48 83 c4 08          	add    rsp,0x8
  41ab56:	c3                   	ret    
  41ab57:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41ab5e:	00 00 
		*s++ = 0xf0 | (wc>>18);
  41ab60:	89 f1                	mov    ecx,esi
		*s = 0x80 | (wc&0x3f);
  41ab62:	83 e0 3f             	and    eax,0x3f
		*s++ = 0xf0 | (wc>>18);
  41ab65:	c1 f9 12             	sar    ecx,0x12
		*s = 0x80 | (wc&0x3f);
  41ab68:	83 c8 80             	or     eax,0xffffff80
		*s++ = 0xf0 | (wc>>18);
  41ab6b:	83 c9 f0             	or     ecx,0xfffffff0
		*s = 0x80 | (wc&0x3f);
  41ab6e:	88 47 03             	mov    BYTE PTR [rdi+0x3],al
		return 4;
  41ab71:	b8 04 00 00 00       	mov    eax,0x4
		*s++ = 0xf0 | (wc>>18);
  41ab76:	88 0f                	mov    BYTE PTR [rdi],cl
		*s++ = 0x80 | ((wc>>12)&0x3f);
  41ab78:	89 f1                	mov    ecx,esi
  41ab7a:	c1 f9 0c             	sar    ecx,0xc
  41ab7d:	83 e1 3f             	and    ecx,0x3f
  41ab80:	83 c9 80             	or     ecx,0xffffff80
  41ab83:	88 4f 01             	mov    BYTE PTR [rdi+0x1],cl
		*s++ = 0x80 | ((wc>>6)&0x3f);
  41ab86:	89 f1                	mov    ecx,esi
  41ab88:	c1 f9 06             	sar    ecx,0x6
  41ab8b:	83 e1 3f             	and    ecx,0x3f
  41ab8e:	83 c9 80             	or     ecx,0xffffff80
  41ab91:	88 4f 02             	mov    BYTE PTR [rdi+0x2],cl
		return 4;
  41ab94:	eb 91                	jmp    41ab27 <wcrtomb+0x77>
  41ab96:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41ab9d:	00 00 00 
		*s++ = 0xc0 | (wc>>6);
  41aba0:	89 f1                	mov    ecx,esi
		*s = 0x80 | (wc&0x3f);
  41aba2:	83 e0 3f             	and    eax,0x3f
		*s++ = 0xc0 | (wc>>6);
  41aba5:	c1 f9 06             	sar    ecx,0x6
		*s = 0x80 | (wc&0x3f);
  41aba8:	83 c8 80             	or     eax,0xffffff80
		*s++ = 0xc0 | (wc>>6);
  41abab:	83 c9 c0             	or     ecx,0xffffffc0
		*s = 0x80 | (wc&0x3f);
  41abae:	88 47 01             	mov    BYTE PTR [rdi+0x1],al
		return 2;
  41abb1:	b8 02 00 00 00       	mov    eax,0x2
		*s++ = 0xc0 | (wc>>6);
  41abb6:	88 0f                	mov    BYTE PTR [rdi],cl
		return 2;
  41abb8:	e9 6a ff ff ff       	jmp    41ab27 <wcrtomb+0x77>
  41abbd:	0f 1f 00             	nop    DWORD PTR [rax]
		*s++ = 0xe0 | (wc>>12);
  41abc0:	89 c1                	mov    ecx,eax
  41abc2:	c1 f9 0c             	sar    ecx,0xc
  41abc5:	83 c9 e0             	or     ecx,0xffffffe0
  41abc8:	88 0a                	mov    BYTE PTR [rdx],cl
		*s++ = 0x80 | ((wc>>6)&0x3f);
  41abca:	89 c1                	mov    ecx,eax
		*s = 0x80 | (wc&0x3f);
  41abcc:	83 e0 3f             	and    eax,0x3f
		*s++ = 0x80 | ((wc>>6)&0x3f);
  41abcf:	c1 f9 06             	sar    ecx,0x6
		*s = 0x80 | (wc&0x3f);
  41abd2:	83 c8 80             	or     eax,0xffffff80
		*s++ = 0x80 | ((wc>>6)&0x3f);
  41abd5:	83 e1 3f             	and    ecx,0x3f
		*s = 0x80 | (wc&0x3f);
  41abd8:	88 42 02             	mov    BYTE PTR [rdx+0x2],al
		return 3;
  41abdb:	b8 03 00 00 00       	mov    eax,0x3
		*s++ = 0x80 | ((wc>>6)&0x3f);
  41abe0:	83 c9 80             	or     ecx,0xffffff80
  41abe3:	88 4a 01             	mov    BYTE PTR [rdx+0x1],cl
		return 3;
  41abe6:	e9 3c ff ff ff       	jmp    41ab27 <wcrtomb+0x77>
  41abeb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000041abf0 <__stdio_exit>:
	if (f->wpos != f->wbase) f->write(f, 0, 0);
	if (f->rpos != f->rend) f->seek(f, f->rpos-f->rend, SEEK_CUR);
}

void __stdio_exit(void)
{
  41abf0:	f3 0f 1e fa          	endbr64 
  41abf4:	55                   	push   rbp
  41abf5:	53                   	push   rbx
  41abf6:	48 83 ec 08          	sub    rsp,0x8
	FILE *f;
	for (f=*__ofl_lock(); f; f=f->next) close_file(f);
  41abfa:	e8 a1 01 00 00       	call   41ada0 <__ofl_lock>
  41abff:	48 8b 18             	mov    rbx,QWORD PTR [rax]
  41ac02:	48 85 db             	test   rbx,rbx
  41ac05:	74 57                	je     41ac5e <__stdio_exit+0x6e>
  41ac07:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41ac0e:	00 00 
	FFINALLOCK(f);
  41ac10:	8b 83 8c 00 00 00    	mov    eax,DWORD PTR [rbx+0x8c]
  41ac16:	85 c0                	test   eax,eax
  41ac18:	78 08                	js     41ac22 <__stdio_exit+0x32>
  41ac1a:	48 89 df             	mov    rdi,rbx
  41ac1d:	e8 3e fa ff ff       	call   41a660 <__lockfile>
	if (f->wpos != f->wbase) f->write(f, 0, 0);
  41ac22:	48 8b 43 38          	mov    rax,QWORD PTR [rbx+0x38]
  41ac26:	48 39 43 28          	cmp    QWORD PTR [rbx+0x28],rax
  41ac2a:	74 0a                	je     41ac36 <__stdio_exit+0x46>
  41ac2c:	31 d2                	xor    edx,edx
  41ac2e:	31 f6                	xor    esi,esi
  41ac30:	48 89 df             	mov    rdi,rbx
  41ac33:	ff 53 48             	call   QWORD PTR [rbx+0x48]
	if (f->rpos != f->rend) f->seek(f, f->rpos-f->rend, SEEK_CUR);
  41ac36:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
  41ac3a:	48 8b 43 10          	mov    rax,QWORD PTR [rbx+0x10]
  41ac3e:	48 39 c6             	cmp    rsi,rax
  41ac41:	0f 84 01 01 00 00    	je     41ad48 <__stdio_exit+0x158>
  41ac47:	48 89 df             	mov    rdi,rbx
  41ac4a:	48 29 c6             	sub    rsi,rax
  41ac4d:	ba 01 00 00 00       	mov    edx,0x1
  41ac52:	ff 53 50             	call   QWORD PTR [rbx+0x50]
	for (f=*__ofl_lock(); f; f=f->next) close_file(f);
  41ac55:	48 8b 5b 70          	mov    rbx,QWORD PTR [rbx+0x70]
  41ac59:	48 85 db             	test   rbx,rbx
  41ac5c:	75 b2                	jne    41ac10 <__stdio_exit+0x20>
	close_file(__stdin_used);
  41ac5e:	48 8b 1d cb 75 18 00 	mov    rbx,QWORD PTR [rip+0x1875cb]        # 5a2230 <__stderr_used>
	if (!f) return;
  41ac65:	48 85 db             	test   rbx,rbx
  41ac68:	74 3d                	je     41aca7 <__stdio_exit+0xb7>
	FFINALLOCK(f);
  41ac6a:	8b 83 8c 00 00 00    	mov    eax,DWORD PTR [rbx+0x8c]
  41ac70:	85 c0                	test   eax,eax
  41ac72:	0f 89 08 01 00 00    	jns    41ad80 <__stdio_exit+0x190>
	if (f->wpos != f->wbase) f->write(f, 0, 0);
  41ac78:	48 8b 43 38          	mov    rax,QWORD PTR [rbx+0x38]
  41ac7c:	48 39 43 28          	cmp    QWORD PTR [rbx+0x28],rax
  41ac80:	74 0a                	je     41ac8c <__stdio_exit+0x9c>
  41ac82:	31 d2                	xor    edx,edx
  41ac84:	31 f6                	xor    esi,esi
  41ac86:	48 89 df             	mov    rdi,rbx
  41ac89:	ff 53 48             	call   QWORD PTR [rbx+0x48]
	if (f->rpos != f->rend) f->seek(f, f->rpos-f->rend, SEEK_CUR);
  41ac8c:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
  41ac90:	48 8b 43 10          	mov    rax,QWORD PTR [rbx+0x10]
  41ac94:	48 39 c6             	cmp    rsi,rax
  41ac97:	74 0e                	je     41aca7 <__stdio_exit+0xb7>
  41ac99:	48 29 c6             	sub    rsi,rax
  41ac9c:	ba 01 00 00 00       	mov    edx,0x1
  41aca1:	48 89 df             	mov    rdi,rbx
  41aca4:	ff 53 50             	call   QWORD PTR [rbx+0x50]
	close_file(__stdout_used);
  41aca7:	48 8b 1d 82 75 18 00 	mov    rbx,QWORD PTR [rip+0x187582]        # 5a2230 <__stderr_used>
	if (!f) return;
  41acae:	48 85 db             	test   rbx,rbx
  41acb1:	74 3d                	je     41acf0 <__stdio_exit+0x100>
	FFINALLOCK(f);
  41acb3:	8b 83 8c 00 00 00    	mov    eax,DWORD PTR [rbx+0x8c]
  41acb9:	85 c0                	test   eax,eax
  41acbb:	0f 89 af 00 00 00    	jns    41ad70 <__stdio_exit+0x180>
	if (f->wpos != f->wbase) f->write(f, 0, 0);
  41acc1:	48 8b 43 38          	mov    rax,QWORD PTR [rbx+0x38]
  41acc5:	48 39 43 28          	cmp    QWORD PTR [rbx+0x28],rax
  41acc9:	74 0a                	je     41acd5 <__stdio_exit+0xe5>
  41accb:	31 d2                	xor    edx,edx
  41accd:	31 f6                	xor    esi,esi
  41accf:	48 89 df             	mov    rdi,rbx
  41acd2:	ff 53 48             	call   QWORD PTR [rbx+0x48]
	if (f->rpos != f->rend) f->seek(f, f->rpos-f->rend, SEEK_CUR);
  41acd5:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
  41acd9:	48 8b 43 10          	mov    rax,QWORD PTR [rbx+0x10]
  41acdd:	48 39 c6             	cmp    rsi,rax
  41ace0:	74 0e                	je     41acf0 <__stdio_exit+0x100>
  41ace2:	48 29 c6             	sub    rsi,rax
  41ace5:	ba 01 00 00 00       	mov    edx,0x1
  41acea:	48 89 df             	mov    rdi,rbx
  41aced:	ff 53 50             	call   QWORD PTR [rbx+0x50]
	close_file(__stderr_used);
  41acf0:	48 8b 2d 39 75 18 00 	mov    rbp,QWORD PTR [rip+0x187539]        # 5a2230 <__stderr_used>
	if (!f) return;
  41acf7:	48 85 ed             	test   rbp,rbp
  41acfa:	0f 84 90 00 00 00    	je     41ad90 <__stdio_exit+0x1a0>
	FFINALLOCK(f);
  41ad00:	8b 85 8c 00 00 00    	mov    eax,DWORD PTR [rbp+0x8c]
  41ad06:	85 c0                	test   eax,eax
  41ad08:	79 56                	jns    41ad60 <__stdio_exit+0x170>
	if (f->wpos != f->wbase) f->write(f, 0, 0);
  41ad0a:	48 8b 45 38          	mov    rax,QWORD PTR [rbp+0x38]
  41ad0e:	48 39 45 28          	cmp    QWORD PTR [rbp+0x28],rax
  41ad12:	74 0a                	je     41ad1e <__stdio_exit+0x12e>
  41ad14:	31 d2                	xor    edx,edx
  41ad16:	31 f6                	xor    esi,esi
  41ad18:	48 89 ef             	mov    rdi,rbp
  41ad1b:	ff 55 48             	call   QWORD PTR [rbp+0x48]
	if (f->rpos != f->rend) f->seek(f, f->rpos-f->rend, SEEK_CUR);
  41ad1e:	48 8b 75 08          	mov    rsi,QWORD PTR [rbp+0x8]
  41ad22:	48 8b 45 10          	mov    rax,QWORD PTR [rbp+0x10]
  41ad26:	48 39 c6             	cmp    rsi,rax
  41ad29:	74 65                	je     41ad90 <__stdio_exit+0x1a0>
  41ad2b:	48 29 c6             	sub    rsi,rax
  41ad2e:	48 8b 45 50          	mov    rax,QWORD PTR [rbp+0x50]
}
  41ad32:	48 83 c4 08          	add    rsp,0x8
	if (f->rpos != f->rend) f->seek(f, f->rpos-f->rend, SEEK_CUR);
  41ad36:	48 89 ef             	mov    rdi,rbp
}
  41ad39:	5b                   	pop    rbx
	if (f->rpos != f->rend) f->seek(f, f->rpos-f->rend, SEEK_CUR);
  41ad3a:	ba 01 00 00 00       	mov    edx,0x1
}
  41ad3f:	5d                   	pop    rbp
	if (f->rpos != f->rend) f->seek(f, f->rpos-f->rend, SEEK_CUR);
  41ad40:	ff e0                	jmp    rax
  41ad42:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	for (f=*__ofl_lock(); f; f=f->next) close_file(f);
  41ad48:	48 8b 5b 70          	mov    rbx,QWORD PTR [rbx+0x70]
  41ad4c:	48 85 db             	test   rbx,rbx
  41ad4f:	0f 85 bb fe ff ff    	jne    41ac10 <__stdio_exit+0x20>
  41ad55:	e9 04 ff ff ff       	jmp    41ac5e <__stdio_exit+0x6e>
  41ad5a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	FFINALLOCK(f);
  41ad60:	48 89 ef             	mov    rdi,rbp
  41ad63:	e8 f8 f8 ff ff       	call   41a660 <__lockfile>
  41ad68:	eb a0                	jmp    41ad0a <__stdio_exit+0x11a>
  41ad6a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  41ad70:	48 89 df             	mov    rdi,rbx
  41ad73:	e8 e8 f8 ff ff       	call   41a660 <__lockfile>
  41ad78:	e9 44 ff ff ff       	jmp    41acc1 <__stdio_exit+0xd1>
  41ad7d:	0f 1f 00             	nop    DWORD PTR [rax]
  41ad80:	48 89 df             	mov    rdi,rbx
  41ad83:	e8 d8 f8 ff ff       	call   41a660 <__lockfile>
  41ad88:	e9 eb fe ff ff       	jmp    41ac78 <__stdio_exit+0x88>
  41ad8d:	0f 1f 00             	nop    DWORD PTR [rax]
}
  41ad90:	48 83 c4 08          	add    rsp,0x8
  41ad94:	5b                   	pop    rbx
  41ad95:	5d                   	pop    rbp
  41ad96:	c3                   	ret    
  41ad97:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41ad9e:	00 00 

000000000041ada0 <__ofl_lock>:

static FILE *ofl_head;
static volatile int ofl_lock[1];

FILE **__ofl_lock()
{
  41ada0:	f3 0f 1e fa          	endbr64 
  41ada4:	48 83 ec 08          	sub    rsp,0x8
	LOCK(ofl_lock);
  41ada8:	48 8d 3d 89 74 18 00 	lea    rdi,[rip+0x187489]        # 5a2238 <ofl_lock>
  41adaf:	e8 1c 00 00 00       	call   41add0 <__lock>
	return &ofl_head;
  41adb4:	48 8d 05 85 74 18 00 	lea    rax,[rip+0x187485]        # 5a2240 <ofl_head>
}
  41adbb:	48 83 c4 08          	add    rsp,0x8
  41adbf:	c3                   	ret    

000000000041adc0 <__ofl_unlock>:

void __ofl_unlock()
{
  41adc0:	f3 0f 1e fa          	endbr64 
	UNLOCK(ofl_lock);
  41adc4:	48 8d 3d 6d 74 18 00 	lea    rdi,[rip+0x18746d]        # 5a2238 <ofl_lock>
  41adcb:	e9 60 02 00 00       	jmp    41b030 <__unlock>

000000000041add0 <__lock>:
 * or in an equivalent formulation x is the congestion count or'ed
 * with INT_MIN as a lock flag.
 */

void __lock(volatile int *l)
{
  41add0:	f3 0f 1e fa          	endbr64 
	if (!libc.threads_minus_1) return;
  41add4:	8b 05 32 72 18 00    	mov    eax,DWORD PTR [rip+0x187232]        # 5a200c <__libc+0xc>
  41adda:	85 c0                	test   eax,eax
  41addc:	0f 84 c6 01 00 00    	je     41afa8 <__lock+0x1d8>
{
  41ade2:	41 54                	push   r12
	__asm__ __volatile__ (
  41ade4:	31 c0                	xor    eax,eax
  41ade6:	ba 01 00 00 80       	mov    edx,0x80000001
  41adeb:	55                   	push   rbp
  41adec:	48 89 fd             	mov    rbp,rdi
  41adef:	53                   	push   rbx
  41adf0:	f0 0f b1 17          	lock cmpxchg DWORD PTR [rdi],edx
  41adf4:	89 c2                	mov    edx,eax
	/* fast path: INT_MIN for the lock, +1 for the congestion */
	int current = a_cas(l, 0, INT_MIN + 1);
	if (!current) return;
  41adf6:	85 c0                	test   eax,eax
  41adf8:	0f 84 a2 01 00 00    	je     41afa0 <__lock+0x1d0>
	/* A first spin loop, for medium congestion. */
	for (unsigned i = 0; i < 10; ++i) {
		if (current < 0) current -= INT_MIN + 1;
		// assertion: current >= 0
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41adfe:	8d 88 01 00 00 80    	lea    ecx,[rax-0x7fffffff]
		if (current < 0) current -= INT_MIN + 1;
  41ae04:	79 08                	jns    41ae0e <__lock+0x3e>
  41ae06:	89 c1                	mov    ecx,eax
  41ae08:	81 c2 ff ff ff 7f    	add    edx,0x7fffffff
  41ae0e:	89 d0                	mov    eax,edx
  41ae10:	f0 0f b1 4d 00       	lock cmpxchg DWORD PTR [rbp+0x0],ecx
  41ae15:	89 c1                	mov    ecx,eax
		if (val == current) return;
  41ae17:	39 d0                	cmp    eax,edx
  41ae19:	0f 84 81 01 00 00    	je     41afa0 <__lock+0x1d0>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41ae1f:	8d 90 01 00 00 80    	lea    edx,[rax-0x7fffffff]
		if (current < 0) current -= INT_MIN + 1;
  41ae25:	85 c0                	test   eax,eax
  41ae27:	79 08                	jns    41ae31 <__lock+0x61>
  41ae29:	89 c2                	mov    edx,eax
  41ae2b:	81 c1 ff ff ff 7f    	add    ecx,0x7fffffff
  41ae31:	89 c8                	mov    eax,ecx
  41ae33:	f0 0f b1 55 00       	lock cmpxchg DWORD PTR [rbp+0x0],edx
  41ae38:	89 c2                	mov    edx,eax
		if (val == current) return;
  41ae3a:	39 c1                	cmp    ecx,eax
  41ae3c:	0f 84 5e 01 00 00    	je     41afa0 <__lock+0x1d0>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41ae42:	8d 88 01 00 00 80    	lea    ecx,[rax-0x7fffffff]
		if (current < 0) current -= INT_MIN + 1;
  41ae48:	85 c0                	test   eax,eax
  41ae4a:	79 08                	jns    41ae54 <__lock+0x84>
  41ae4c:	89 c1                	mov    ecx,eax
  41ae4e:	81 c2 ff ff ff 7f    	add    edx,0x7fffffff
  41ae54:	89 d0                	mov    eax,edx
  41ae56:	f0 0f b1 4d 00       	lock cmpxchg DWORD PTR [rbp+0x0],ecx
  41ae5b:	89 c1                	mov    ecx,eax
		if (val == current) return;
  41ae5d:	39 c2                	cmp    edx,eax
  41ae5f:	0f 84 3b 01 00 00    	je     41afa0 <__lock+0x1d0>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41ae65:	8d 90 01 00 00 80    	lea    edx,[rax-0x7fffffff]
		if (current < 0) current -= INT_MIN + 1;
  41ae6b:	85 c0                	test   eax,eax
  41ae6d:	79 08                	jns    41ae77 <__lock+0xa7>
  41ae6f:	89 c2                	mov    edx,eax
  41ae71:	81 c1 ff ff ff 7f    	add    ecx,0x7fffffff
  41ae77:	89 c8                	mov    eax,ecx
  41ae79:	f0 0f b1 55 00       	lock cmpxchg DWORD PTR [rbp+0x0],edx
  41ae7e:	89 c2                	mov    edx,eax
		if (val == current) return;
  41ae80:	39 c1                	cmp    ecx,eax
  41ae82:	0f 84 18 01 00 00    	je     41afa0 <__lock+0x1d0>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41ae88:	8d 88 01 00 00 80    	lea    ecx,[rax-0x7fffffff]
		if (current < 0) current -= INT_MIN + 1;
  41ae8e:	85 c0                	test   eax,eax
  41ae90:	79 08                	jns    41ae9a <__lock+0xca>
  41ae92:	89 c1                	mov    ecx,eax
  41ae94:	81 c2 ff ff ff 7f    	add    edx,0x7fffffff
  41ae9a:	89 d0                	mov    eax,edx
  41ae9c:	f0 0f b1 4d 00       	lock cmpxchg DWORD PTR [rbp+0x0],ecx
  41aea1:	89 c1                	mov    ecx,eax
		if (val == current) return;
  41aea3:	39 c2                	cmp    edx,eax
  41aea5:	0f 84 f5 00 00 00    	je     41afa0 <__lock+0x1d0>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41aeab:	8d 90 01 00 00 80    	lea    edx,[rax-0x7fffffff]
		if (current < 0) current -= INT_MIN + 1;
  41aeb1:	85 c0                	test   eax,eax
  41aeb3:	0f 88 f7 00 00 00    	js     41afb0 <__lock+0x1e0>
  41aeb9:	89 c8                	mov    eax,ecx
  41aebb:	f0 0f b1 55 00       	lock cmpxchg DWORD PTR [rbp+0x0],edx
  41aec0:	89 c2                	mov    edx,eax
		if (val == current) return;
  41aec2:	39 c1                	cmp    ecx,eax
  41aec4:	0f 84 d6 00 00 00    	je     41afa0 <__lock+0x1d0>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41aeca:	8d 88 01 00 00 80    	lea    ecx,[rax-0x7fffffff]
		if (current < 0) current -= INT_MIN + 1;
  41aed0:	85 c0                	test   eax,eax
  41aed2:	0f 88 e8 00 00 00    	js     41afc0 <__lock+0x1f0>
  41aed8:	89 d0                	mov    eax,edx
  41aeda:	f0 0f b1 4d 00       	lock cmpxchg DWORD PTR [rbp+0x0],ecx
  41aedf:	89 c1                	mov    ecx,eax
		if (val == current) return;
  41aee1:	39 c2                	cmp    edx,eax
  41aee3:	0f 84 b7 00 00 00    	je     41afa0 <__lock+0x1d0>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41aee9:	8d 90 01 00 00 80    	lea    edx,[rax-0x7fffffff]
		if (current < 0) current -= INT_MIN + 1;
  41aeef:	85 c0                	test   eax,eax
  41aef1:	0f 88 d9 00 00 00    	js     41afd0 <__lock+0x200>
  41aef7:	89 c8                	mov    eax,ecx
  41aef9:	f0 0f b1 55 00       	lock cmpxchg DWORD PTR [rbp+0x0],edx
  41aefe:	89 c2                	mov    edx,eax
		if (val == current) return;
  41af00:	39 c1                	cmp    ecx,eax
  41af02:	0f 84 98 00 00 00    	je     41afa0 <__lock+0x1d0>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41af08:	8d 88 01 00 00 80    	lea    ecx,[rax-0x7fffffff]
		if (current < 0) current -= INT_MIN + 1;
  41af0e:	85 c0                	test   eax,eax
  41af10:	0f 88 ca 00 00 00    	js     41afe0 <__lock+0x210>
  41af16:	89 d0                	mov    eax,edx
  41af18:	f0 0f b1 4d 00       	lock cmpxchg DWORD PTR [rbp+0x0],ecx
  41af1d:	89 c1                	mov    ecx,eax
		if (val == current) return;
  41af1f:	39 c2                	cmp    edx,eax
  41af21:	74 7d                	je     41afa0 <__lock+0x1d0>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41af23:	8d 90 01 00 00 80    	lea    edx,[rax-0x7fffffff]
		if (current < 0) current -= INT_MIN + 1;
  41af29:	85 c0                	test   eax,eax
  41af2b:	0f 88 bf 00 00 00    	js     41aff0 <__lock+0x220>
  41af31:	89 c8                	mov    eax,ecx
  41af33:	f0 0f b1 55 00       	lock cmpxchg DWORD PTR [rbp+0x0],edx
		if (val == current) return;
  41af38:	39 c1                	cmp    ecx,eax
  41af3a:	74 64                	je     41afa0 <__lock+0x1d0>
	__asm__ __volatile__(
  41af3c:	bb 01 00 00 00       	mov    ebx,0x1
  41af41:	f0 0f c1 5d 00       	lock xadd DWORD PTR [rbp+0x0],ebx
		current = val;
	}
	// Spinning failed, so mark ourselves as being inside the CS.
	current = a_fetch_add(l, 1) + 1;
  41af46:	83 c3 01             	add    ebx,0x1
  41af49:	eb 18                	jmp    41af63 <__lock+0x193>
  41af4b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		if (current < 0) {
			__futexwait(l, current, 1);
			current -= INT_MIN + 1;
		}
		/* assertion: current > 0, the count includes us already. */
		int val = a_cas(l, current, INT_MIN + current);
  41af50:	8d 9a 00 00 00 80    	lea    ebx,[rdx-0x80000000]
	__asm__ __volatile__ (
  41af56:	89 d0                	mov    eax,edx
  41af58:	f0 0f b1 5d 00       	lock cmpxchg DWORD PTR [rbp+0x0],ebx
  41af5d:	89 c3                	mov    ebx,eax
		if (val == current) return;
  41af5f:	39 c2                	cmp    edx,eax
  41af61:	74 3d                	je     41afa0 <__lock+0x1d0>
		if (current < 0) {
  41af63:	89 da                	mov    edx,ebx
  41af65:	85 db                	test   ebx,ebx
  41af67:	79 e7                	jns    41af50 <__lock+0x180>
	return __cos_syscall(n, a1, a2, a3, a4, 0, 0, 0);
  41af69:	6a 00                	push   0x0
	__syscall(SYS_futex, addr, FUTEX_WAIT|priv, val, 0) != -ENOSYS ||
  41af6b:	4c 63 e3             	movsxd r12,ebx
  41af6e:	48 89 ee             	mov    rsi,rbp
  41af71:	45 31 c9             	xor    r9d,r9d
  41af74:	6a 00                	push   0x0
  41af76:	4c 89 e1             	mov    rcx,r12
  41af79:	45 31 c0             	xor    r8d,r8d
  41af7c:	ba 80 00 00 00       	mov    edx,0x80
  41af81:	bf ca 00 00 00       	mov    edi,0xca
  41af86:	e8 55 f3 fe ff       	call   40a2e0 <__cos_syscall>
  41af8b:	59                   	pop    rcx
  41af8c:	5e                   	pop    rsi
  41af8d:	48 83 f8 da          	cmp    rax,0xffffffffffffffda
  41af91:	74 6d                	je     41b000 <__lock+0x230>
			current -= INT_MIN + 1;
  41af93:	8d 93 ff ff ff 7f    	lea    edx,[rbx+0x7fffffff]
  41af99:	eb b5                	jmp    41af50 <__lock+0x180>
  41af9b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		current = val;
	}
}
  41afa0:	5b                   	pop    rbx
  41afa1:	5d                   	pop    rbp
  41afa2:	41 5c                	pop    r12
  41afa4:	c3                   	ret    
  41afa5:	0f 1f 00             	nop    DWORD PTR [rax]
  41afa8:	c3                   	ret    
  41afa9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		if (current < 0) current -= INT_MIN + 1;
  41afb0:	89 c2                	mov    edx,eax
  41afb2:	81 c1 ff ff ff 7f    	add    ecx,0x7fffffff
  41afb8:	e9 fc fe ff ff       	jmp    41aeb9 <__lock+0xe9>
  41afbd:	0f 1f 00             	nop    DWORD PTR [rax]
  41afc0:	89 c1                	mov    ecx,eax
  41afc2:	81 c2 ff ff ff 7f    	add    edx,0x7fffffff
  41afc8:	e9 0b ff ff ff       	jmp    41aed8 <__lock+0x108>
  41afcd:	0f 1f 00             	nop    DWORD PTR [rax]
  41afd0:	89 c2                	mov    edx,eax
  41afd2:	81 c1 ff ff ff 7f    	add    ecx,0x7fffffff
  41afd8:	e9 1a ff ff ff       	jmp    41aef7 <__lock+0x127>
  41afdd:	0f 1f 00             	nop    DWORD PTR [rax]
  41afe0:	89 c1                	mov    ecx,eax
  41afe2:	81 c2 ff ff ff 7f    	add    edx,0x7fffffff
  41afe8:	e9 29 ff ff ff       	jmp    41af16 <__lock+0x146>
  41afed:	0f 1f 00             	nop    DWORD PTR [rax]
  41aff0:	89 c2                	mov    edx,eax
  41aff2:	81 c1 ff ff ff 7f    	add    ecx,0x7fffffff
  41aff8:	e9 34 ff ff ff       	jmp    41af31 <__lock+0x161>
  41affd:	0f 1f 00             	nop    DWORD PTR [rax]
  41b000:	6a 00                	push   0x0
  41b002:	31 d2                	xor    edx,edx
  41b004:	45 31 c9             	xor    r9d,r9d
  41b007:	45 31 c0             	xor    r8d,r8d
  41b00a:	6a 00                	push   0x0
  41b00c:	4c 89 e1             	mov    rcx,r12
  41b00f:	48 89 ee             	mov    rsi,rbp
  41b012:	bf ca 00 00 00       	mov    edi,0xca
  41b017:	e8 c4 f2 fe ff       	call   40a2e0 <__cos_syscall>
  41b01c:	58                   	pop    rax
  41b01d:	5a                   	pop    rdx
  41b01e:	e9 70 ff ff ff       	jmp    41af93 <__lock+0x1c3>
  41b023:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41b02a:	00 00 00 
  41b02d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000041b030 <__unlock>:

void __unlock(volatile int *l)
{
  41b030:	f3 0f 1e fa          	endbr64 
	/* Check l[0] to see if we are multi-threaded. */
	if (l[0] < 0) {
  41b034:	8b 07                	mov    eax,DWORD PTR [rdi]
  41b036:	85 c0                	test   eax,eax
  41b038:	78 06                	js     41b040 <__unlock+0x10>
  41b03a:	c3                   	ret    
  41b03b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
{
  41b040:	55                   	push   rbp
	__asm__ __volatile__(
  41b041:	b8 ff ff ff 7f       	mov    eax,0x7fffffff
  41b046:	48 89 fd             	mov    rbp,rdi
  41b049:	f0 0f c1 07          	lock xadd DWORD PTR [rdi],eax
		if (a_fetch_add(l, -(INT_MIN + 1)) != (INT_MIN + 1)) {
  41b04d:	3d 01 00 00 80       	cmp    eax,0x80000001
  41b052:	74 29                	je     41b07d <__unlock+0x4d>
	return __cos_syscall(n, a1, a2, a3, 0, 0, 0, 0);
  41b054:	6a 00                	push   0x0
  41b056:	48 89 fe             	mov    rsi,rdi
  41b059:	b9 01 00 00 00       	mov    ecx,0x1
  41b05e:	45 31 c9             	xor    r9d,r9d
  41b061:	6a 00                	push   0x0
  41b063:	45 31 c0             	xor    r8d,r8d
  41b066:	ba 81 00 00 00       	mov    edx,0x81
  41b06b:	bf ca 00 00 00       	mov    edi,0xca
  41b070:	e8 6b f2 fe ff       	call   40a2e0 <__cos_syscall>
	__syscall(SYS_futex, addr, FUTEX_WAKE|priv, cnt) != -ENOSYS ||
  41b075:	59                   	pop    rcx
  41b076:	5e                   	pop    rsi
  41b077:	48 83 f8 da          	cmp    rax,0xffffffffffffffda
  41b07b:	74 03                	je     41b080 <__unlock+0x50>
			__wake(l, 1, 1);
		}
	}
}
  41b07d:	5d                   	pop    rbp
  41b07e:	c3                   	ret    
  41b07f:	90                   	nop
  41b080:	6a 00                	push   0x0
  41b082:	ba 01 00 00 00       	mov    edx,0x1
  41b087:	48 89 ee             	mov    rsi,rbp
  41b08a:	45 31 c9             	xor    r9d,r9d
  41b08d:	6a 00                	push   0x0
  41b08f:	45 31 c0             	xor    r8d,r8d
  41b092:	b9 01 00 00 00       	mov    ecx,0x1
  41b097:	bf ca 00 00 00       	mov    edi,0xca
  41b09c:	e8 3f f2 fe ff       	call   40a2e0 <__cos_syscall>
  41b0a1:	58                   	pop    rax
  41b0a2:	5a                   	pop    rdx
  41b0a3:	5d                   	pop    rbp
  41b0a4:	c3                   	ret    
