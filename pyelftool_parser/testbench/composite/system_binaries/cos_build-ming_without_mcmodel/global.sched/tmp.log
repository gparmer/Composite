  40002a:	4c 89 8d 78 ff ff ff 	mov    QWORD PTR [rbp-0x88],r9
  400031:	84 c0                	test   al,al
  400033:	74 20                	je     400055 <printc+0x55>
  400035:	0f 29 45 80          	movaps XMMWORD PTR [rbp-0x80],xmm0
  400039:	0f 29 4d 90          	movaps XMMWORD PTR [rbp-0x70],xmm1
--
  400091:	48 89 85 88 fe ff ff 	mov    QWORD PTR [rbp-0x178],rax
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  400098:	e8 c3 54 01 00       	call   415560 <vsnprintf>
	va_end(arg_ptr);
	ret = cos_print_str(s, ret);
--
  4000a4:	89 c6                	mov    esi,eax
	ret = cos_print_str(s, ret);
  4000a6:	e8 25 a0 00 00       	call   40a0d0 <cos_print_str>

	return ret;
--
  4000b6:	48 83 ec 08          	sub    rsp,0x8
	struct slm_thd *current = slm_thd_current_extern();
  4000ba:	e8 81 18 00 00       	call   401940 <slm_thd_current_extern>

	if (cos_coreid() == 0) printc("\tScheduler %ld: Exiting thread %ld from component %ld\n", cos_compid(), cos_thdid(), (compid_t)cos_inv_token());
--
  4000de:	0f b7 90 f0 1f 00 00 	movzx  edx,WORD PTR [rax+0x1ff0]
  4000e5:	31 c0                	xor    eax,eax
  4000e7:	e8 14 ff ff ff       	call   400000 <printc>
	slm_cs_cached_t cached;
	sched_tok_t     tok;
--
	assert(current);
  4000ec:	4d 85 e4             	test   r12,r12
  4000ef:	0f 84 09 01 00 00    	je     4001fe <exit_init_thd+0x14e>
	cs = &(slm_global()->lock);

	while (1) {
		tok    = cos_sched_sync();
  4000f5:	e8 06 12 01 00       	call   411300 <cos_sched_sync>
  4000fa:	41 89 c1             	mov    r9d,eax
 * - @ret - a *cached* version of the critical section metadata to be passed into `__slm_cs_cas`.
--
  400104:	48 89 c1             	mov    rcx,rax
  400107:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  40010b:	0f 85 b1 00 00 00    	jne    4001c2 <exit_init_thd+0x112>
 */
static inline int
--
        char z;
        __asm__ __volatile__("lock " PS_CAS_STR
  400111:	f0 4c 0f b1 25 a6 1d 	lock cmpxchg QWORD PTR [rip+0x1a1da6],r12        # 5a1ec0 <__slm_global>
  400118:	1a 00 
  40011a:	0f 94 c0             	sete   al
--
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  40011d:	84 c0                	test   al,al
  40011f:	74 d4                	je     4000f5 <exit_init_thd+0x45>

	slm_cs_enter(current, SLM_CS_NONE);
	slm_thd_deinit(current);		/* I'm out! */
  400121:	4c 89 e7             	mov    rdi,r12
  400124:	e8 b7 36 01 00       	call   4137e0 <slm_thd_deinit>
slm_cs_exit(struct slm_thd *switchto, slm_cs_flags_t flags)
{
--

	while (ret != 0) {
  400129:	eb 15                	jmp    400140 <exit_init_thd+0x90>
  40012b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  400130:	f0 48 0f b1 15 87 1d 	lock cmpxchg QWORD PTR [rip+0x1a1d87],rdx        # 5a1ec0 <__slm_global>
  400137:	1a 00 
  400139:	0f 94 c0             	sete   al
  40013c:	84 c0                	test   al,al
  40013e:	75 2e                	jne    40016e <exit_init_thd+0xbe>
		int             contention;
		sched_tok_t     tok;
--

		tok    = cos_sched_sync();
  400140:	e8 bb 11 01 00       	call   411300 <cos_sched_sync>
  400145:	89 c1                	mov    ecx,eax
  400147:	48 8b 05 72 1d 1a 00 	mov    rax,QWORD PTR [rip+0x1a1d72]        # 5a1ec0 <__slm_global>
--
  40014e:	48 89 c2             	mov    rdx,rax
  400151:	83 e2 01             	and    edx,0x1
  400154:	74 da                	je     400130 <exit_init_thd+0x80>
	/* least significant bit signifies contention */
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
--
  40015c:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  400161:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  400165:	e8 f6 36 01 00       	call   413860 <slm_cs_exit_contention>
  40016a:	85 c0                	test   eax,eax
  40016c:	75 d2                	jne    400140 <exit_init_thd+0x90>
	slm_cs_exit(NULL, SLM_CS_NONE);

	/* Switch to the scheduler thread */
	if (cos_defswitch(BOOT_CAPTBL_SELF_INITTHD_CPU_BASE, TCAP_PRIO_MAX, TCAP_RES_INF, cos_sched_sync())) BUG();
  40016e:	e8 8d 11 01 00       	call   411300 <cos_sched_sync>
  400173:	be 01 00 00 00       	mov    esi,0x1
  400178:	bf 28 00 00 00       	mov    edi,0x28
  40017d:	48 c7 c2 ff ff ff ff 	mov    rdx,0xffffffffffffffff
  400184:	89 c1                	mov    ecx,eax
  400186:	e8 d5 c5 00 00       	call   40c760 <cos_defswitch>
	return cos_print_str(s, strlen(s));
  40018b:	be 11 00 00 00       	mov    esi,0x11
  400190:	85 c0                	test   eax,eax
  400192:	75 17                	jne    4001ab <exit_init_thd+0xfb>
  400194:	bf e4 c2 41 00       	mov    edi,0x41c2e4
  400199:	e8 32 9f 00 00       	call   40a0d0 <cos_print_str>

	BUG();
--
  4001a9:	0f 0b                	ud2    
  4001ab:	bf d2 c2 41 00       	mov    edi,0x41c2d2
  4001b0:	e8 1b 9f 00 00       	call   40a0d0 <cos_print_str>
	if (cos_defswitch(BOOT_CAPTBL_SELF_INITTHD_CPU_BASE, TCAP_PRIO_MAX, TCAP_RES_INF, cos_sched_sync())) BUG();
  4001b5:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  4001cb:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  4001d0:	41 83 e0 01          	and    r8d,0x1
  4001d4:	e8 37 36 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  4001d9:	83 f8 f0             	cmp    eax,0xfffffff0
  4001dc:	0f 85 13 ff ff ff    	jne    4000f5 <exit_init_thd+0x45>
  4001e2:	be 59 00 00 00       	mov    esi,0x59
  4001e7:	bf 78 c2 41 00       	mov    edi,0x41c278
  4001ec:	e8 df 9e 00 00       	call   40a0d0 <cos_print_str>
  4001f1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4001f8:	00 00 00 00 
--
  4001fe:	be 59 00 00 00       	mov    esi,0x59
  400203:	bf 18 c2 41 00       	mov    edi,0x41c218
  400208:	e8 c3 9e 00 00       	call   40a0d0 <cos_print_str>
	assert(current);
  40020d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  400234:	48 83 ec 70          	sub    rsp,0x70
	ret = args_get_entry("execute", &exec_entries);
  400238:	e8 43 ae 00 00       	call   40b080 <args_get_entry>
	assert(!ret);
  40023d:	85 c0                	test   eax,eax
  40023f:	0f 85 9b 01 00 00    	jne    4003e0 <calculate_initialization_schedule+0x1c0>
	printc("\tSched %ld: %d components that need execution\n", cos_compid(), args_len(&exec_entries));
  400245:	48 8d 7d 90          	lea    rdi,[rbp-0x70]
  400249:	e8 32 a8 00 00       	call   40aa80 <args_len>
  40024e:	48 8b 35 eb 6d 02 00 	mov    rsi,QWORD PTR [rip+0x26deb]        # 427040 <__cosrt_comp_info+0x40>
  400255:	bf 28 c3 41 00       	mov    edi,0x41c328
  40025a:	89 c2                	mov    edx,eax
  40025c:	31 c0                	xor    eax,eax
  40025e:	e8 9d fd ff ff       	call   400000 <printc>
	for (cont = args_iter(&exec_entries, &i, &curr) ; cont ; cont = args_iter_next(&i, &curr)) {
  400263:	48 8d 55 b0          	lea    rdx,[rbp-0x50]
  400267:	48 8d 75 d0          	lea    rsi,[rbp-0x30]
  40026b:	48 8d 7d 90          	lea    rdi,[rbp-0x70]
  40026f:	e8 cc a8 00 00       	call   40ab40 <args_iter>
  400274:	85 c0                	test   eax,eax
  400276:	0f 84 ea 00 00 00    	je     400366 <calculate_initialization_schedule+0x146>
		compid_t id        = atoi(args_key(&curr, &keylen));
  40027c:	48 8d 75 8c          	lea    rsi,[rbp-0x74]
  400280:	48 8d 7d b0          	lea    rdi,[rbp-0x50]
  400284:	e8 57 a7 00 00       	call   40a9e0 <args_key>
  400289:	48 89 c7             	mov    rdi,rax
  40028c:	e8 1f 54 01 00       	call   4156b0 <atoi>
		char    *exec_type = args_value(&curr);
  400291:	48 8d 7d b0          	lea    rdi,[rbp-0x50]
--
  400295:	48 63 d8             	movsxd rbx,eax
		char    *exec_type = args_value(&curr);
  400298:	e8 a3 a7 00 00       	call   40aa40 <args_value>
  40029d:	48 89 c7             	mov    rdi,rax
		assert(exec_type);
  4002a0:	48 85 c0             	test   rax,rax
  4002a3:	0f 84 e3 00 00 00    	je     40038c <calculate_initialization_schedule+0x16c>
	} while (0)

--
  4002a9:	4c 8b 25 90 6d 02 00 	mov    r12,QWORD PTR [rip+0x26d90]        # 427040 <__cosrt_comp_info+0x40>
		assert(id != cos_compid());
  4002b0:	4c 39 e3             	cmp    rbx,r12
  4002b3:	0f 84 ef 00 00 00    	je     4003a8 <calculate_initialization_schedule+0x188>
		if (strcmp(exec_type, "init")) BUG();	/* TODO: no support for hierarchical scheduling yet */
  4002b9:	be a5 c3 41 00       	mov    esi,0x41c3a5
  4002be:	e8 cd 56 01 00       	call   415990 <strcmp>
  4002c3:	85 c0                	test   eax,eax
  4002c5:	0f 85 a5 00 00 00    	jne    400370 <calculate_initialization_schedule+0x150>
	printc("\tSched %ld: %ld is the %ldth component to initialize\n", cos_compid(), cid, init_schedule_off);
  4002cb:	48 8b 0d 6e dd 05 00 	mov    rcx,QWORD PTR [rip+0x5dd6e]        # 45e040 <init_schedule_off>
--
  4002df:	4c 8d 24 9b          	lea    r12,[rbx+rbx*4]
	printc("\tSched %ld: %ld is the %ldth component to initialize\n", cos_compid(), cid, init_schedule_off);
  4002e3:	e8 18 fd ff ff       	call   400000 <printc>
	init_schedule[init_schedule_off] = cid;
  4002e8:	48 8b 05 51 dd 05 00 	mov    rax,QWORD PTR [rip+0x5dd51]        # 45e040 <init_schedule_off>
--
  40030a:	8b 43 10             	mov    eax,DWORD PTR [rbx+0x10]
  40030d:	85 c0                	test   eax,eax
  40030f:	0f 85 af 00 00 00    	jne    4003c4 <calculate_initialization_schedule+0x1a4>
	*s = (struct schedinit_status) {
  400315:	66 0f ef c0          	pxor   xmm0,xmm0
--
  40033c:	ff 
	simple_barrier_init(&s->barrier, init_parallelism());
  40033d:	e8 de 99 00 00       	call   409d20 <init_parallelism>
	for (cont = args_iter(&exec_entries, &i, &curr) ; cont ; cont = args_iter_next(&i, &curr)) {
  400342:	48 8d 75 b0          	lea    rsi,[rbp-0x50]
--
  400351:	00 00 00 00 00 
  400356:	89 43 08             	mov    DWORD PTR [rbx+0x8],eax
  400359:	e8 72 a7 00 00       	call   40aad0 <args_iter_next>
  40035e:	85 c0                	test   eax,eax
  400360:	0f 85 16 ff ff ff    	jne    40027c <calculate_initialization_schedule+0x5c>
}
  400366:	48 83 c4 70          	add    rsp,0x70
--
  400370:	be 11 00 00 00       	mov    esi,0x11
  400375:	bf aa c3 41 00       	mov    edi,0x41c3aa
  40037a:	e8 51 9d 00 00       	call   40a0d0 <cos_print_str>
		if (strcmp(exec_type, "init")) BUG();	/* TODO: no support for hierarchical scheduling yet */
  40037f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400386:	00 00 00 00 
--
  40038c:	be 24 00 00 00       	mov    esi,0x24
  400391:	bf 58 c3 41 00       	mov    edi,0x41c358
  400396:	e8 35 9d 00 00       	call   40a0d0 <cos_print_str>
		assert(exec_type);
  40039b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  4003a8:	be 24 00 00 00       	mov    esi,0x24
  4003ad:	bf 80 c3 41 00       	mov    edi,0x41c380
  4003b2:	e8 19 9d 00 00       	call   40a0d0 <cos_print_str>
		assert(id != cos_compid());
  4003b7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  4003c4:	be 23 00 00 00       	mov    esi,0x23
  4003c9:	bf f8 c3 41 00       	mov    edi,0x41c3f8
  4003ce:	e8 fd 9c 00 00       	call   40a0d0 <cos_print_str>
	assert(s->status == SCHEDINIT_FREE);
  4003d3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  4003e0:	be 23 00 00 00       	mov    esi,0x23
  4003e5:	bf 00 c3 41 00       	mov    edi,0x41c300
  4003ea:	e8 e1 9c 00 00       	call   40a0d0 <cos_print_str>
	assert(!ret);
  4003ef:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  400423:	8b 82 50 d4 45 00    	mov    eax,DWORD PTR [rdx+0x45d450]
  400429:	85 c0                	test   eax,eax
  40042b:	0f 84 a3 00 00 00    	je     4004d4 <init_done+0xd4>
  400431:	89 f3                	mov    ebx,esi
  400433:	48 8d 8a 40 d4 45 00 	lea    rcx,[rdx+0x45d440]
  40043a:	31 f6                	xor    esi,esi
  40043c:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
  400443:	f0 48 0f b1 b2 58 d4 	lock cmpxchg QWORD PTR [rdx+0x45d458],rsi
  40044a:	45 00 
  40044c:	0f 94 c0             	sete   al

	/*
	 * `init_done` should not be called once initialization is
	 * completed. This is an error.
	 */
	if (s->status == SCHEDINIT_MAIN) {
  40044f:	8b 41 10             	mov    eax,DWORD PTR [rcx+0x10]
  400452:	83 f8 03             	cmp    eax,0x3
  400455:	0f 84 b1 00 00 00    	je     40050c <init_done+0x10c>

	/*
--
	 */
	if (s->status == SCHEDINIT_INITING) {
  40045b:	83 f8 01             	cmp    eax,0x1
  40045e:	74 68                	je     4004c8 <init_done+0xc8>
	assert(*barrier <= ncore);
  400460:	8b 71 08             	mov    esi,DWORD PTR [rcx+0x8]
  400463:	48 39 b2 40 d4 45 00 	cmp    QWORD PTR [rdx+0x45d440],rsi
  40046a:	0f 87 80 00 00 00    	ja     4004f0 <init_done+0xf0>
ps_faa(unsigned long *target, long inc)
--
	while (ps_load(barrier) < ncore) ;
  400480:	48 8b 01             	mov    rax,QWORD PTR [rcx]
  400483:	48 39 c6             	cmp    rsi,rax
  400486:	77 f8                	ja     400480 <init_done+0x80>
 	 * If this barrier is hit *after* the parallel initialization
--

	s->initialization_thds[cos_coreid()] = slm_thd_current_extern();
  40049d:	e8 9e 14 00 00       	call   401940 <slm_thd_current_extern>
  4004a2:	49 89 44 24 20       	mov    QWORD PTR [r12+0x20],rax
	extern int thd_block(void);
	thd_block(); 		/* block until initialization is completed */
  4004a7:	e8 04 1f 00 00       	call   4023b0 <thd_block>

 	/*
--
	 */
	if ((cos_coreid() != s->init_core && cont == INIT_MAIN_SINGLE) || cont == INIT_MAIN_NONE) {
  4004ac:	49 83 7c 24 18 00    	cmp    QWORD PTR [r12+0x18],0x0
  4004b2:	74 05                	je     4004b9 <init_done+0xb9>
  4004b4:	83 fb 01             	cmp    ebx,0x1
  4004b7:	74 53                	je     40050c <init_done+0x10c>
  4004b9:	85 db                	test   ebx,ebx
  4004bb:	74 4f                	je     40050c <init_done+0x10c>
	 * main execution. We'd expect the next API call here to be
	 * `init_exit`.
	 */
--
  4004d4:	be 24 00 00 00       	mov    esi,0x24
  4004d9:	bf 20 c4 41 00       	mov    edi,0x41c420
  4004de:	e8 ed 9b 00 00       	call   40a0d0 <cos_print_str>
	assert(s->status != SCHEDINIT_FREE);
  4004e3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  4004f0:	be 5d 00 00 00       	mov    esi,0x5d
  4004f5:	bf 48 c4 41 00       	mov    edi,0x41c448
  4004fa:	e8 d1 9b 00 00       	call   40a0d0 <cos_print_str>
	assert(*barrier <= ncore);
  4004ff:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40050a:	0f 0b                	ud2    
		exit_init_thd();
  40050c:	e8 9f fb ff ff       	call   4000b0 <exit_init_thd>
  400511:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  400518:	00 00 00 00 
--
  400525:	48 89 e5             	mov    rbp,rsp
	exit_init_thd();
  400528:	e8 83 fb ff ff       	call   4000b0 <exit_init_thd>
  40052d:	0f 1f 00             	nop    DWORD PTR [rax]

--
	if (cos_coreid() == 0) printc("Scheduler %ld: Running initialization thread.\n", cos_compid());
  40054c:	48 8b 35 ed 6a 02 00 	mov    rsi,QWORD PTR [rip+0x26aed]        # 427040 <__cosrt_comp_info+0x40>
  400553:	e8 a8 fa ff ff       	call   400000 <printc>
	while (init_schedule_current != ps_load(&init_schedule_off)) {
  400558:	48 8b 05 e1 da 05 00 	mov    rax,QWORD PTR [rip+0x5dae1]        # 45e040 <init_schedule_off>
  40055f:	4c 8b 25 d2 c1 01 00 	mov    r12,QWORD PTR [rip+0x1c1d2]        # 41c738 <__unlock+0x608>
  400566:	48 85 c0             	test   rax,rax
  400569:	74 72                	je     4005dd <slm_idle_comp_initialization+0xad>
  40056b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		t = thd_alloc_in(client, 0, param, 1);
--
		t = thd_alloc_in(client, 0, param, 1);
  400587:	4c 89 ef             	mov    rdi,r13
  40058a:	e8 d1 47 00 00       	call   404d60 <thd_alloc_in>
		assert(t);
  40058f:	48 85 c0             	test   rax,rax
  400592:	0f 84 f4 00 00 00    	je     40068c <slm_idle_comp_initialization+0x15c>
		if (cos_coreid() == 0)	printc("\tScheduler %ld: initializing component %ld with thread %ld.\n", cos_compid(), client, t->tid);
  400598:	48 8b 48 18          	mov    rcx,QWORD PTR [rax+0x18]
--
  4005ad:	48 83 c3 01          	add    rbx,0x1
		if (cos_coreid() == 0)	printc("\tScheduler %ld: initializing component %ld with thread %ld.\n", cos_compid(), client, t->tid);
  4005b1:	e8 4a fa ff ff       	call   400000 <printc>
		while (ps_load(&n->initialization_thds[cos_coreid()]) == NULL) ;
  4005b6:	4b 8d 44 ad 00       	lea    rax,[r13+r13*4+0x0]
--
  4005c8:	48 8b 42 20          	mov    rax,QWORD PTR [rdx+0x20]
  4005cc:	48 85 c0             	test   rax,rax
  4005cf:	74 f7                	je     4005c8 <slm_idle_comp_initialization+0x98>
	while (init_schedule_current != ps_load(&init_schedule_off)) {
  4005d1:	48 8b 05 68 da 05 00 	mov    rax,QWORD PTR [rip+0x5da68]        # 45e040 <init_schedule_off>
  4005d8:	48 39 c3             	cmp    rbx,rax
  4005db:	75 93                	jne    400570 <slm_idle_comp_initialization+0x40>
	if (cos_coreid() == 0) printc("Scheduler %ld, initialization completed.\n", cos_compid());
  4005dd:	48 8b 35 5c 6a 02 00 	mov    rsi,QWORD PTR [rip+0x26a5c]        # 427040 <__cosrt_comp_info+0x40>
  4005e4:	bf d8 c4 41 00       	mov    edi,0x41c4d8
  4005e9:	31 c0                	xor    eax,eax
  4005eb:	e8 10 fa ff ff       	call   400000 <printc>
	slm_cs_enter(slm_thd_special(), SLM_CS_NONE);
  4005f0:	e8 db 30 01 00       	call   4136d0 <slm_thd_special>
  4005f5:	48 89 c3             	mov    rbx,rax
  4005f8:	48 85 c0             	test   rax,rax
  4005fb:	0f 84 ab 01 00 00    	je     4007ac <slm_idle_comp_initialization+0x27c>
		tok    = cos_sched_sync();
  400601:	e8 fa 0c 01 00       	call   411300 <cos_sched_sync>
  400606:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  400610:	48 89 c1             	mov    rcx,rax
  400613:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  400617:	0f 85 53 01 00 00    	jne    400770 <slm_idle_comp_initialization+0x240>
        __asm__ __volatile__("lock " PS_CAS_STR
  40061d:	f0 48 0f b1 1d 9a 18 	lock cmpxchg QWORD PTR [rip+0x1a189a],rbx        # 5a1ec0 <__slm_global>
  400624:	1a 00 
  400626:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  400629:	84 c0                	test   al,al
  40062b:	74 d4                	je     400601 <slm_idle_comp_initialization+0xd1>
	for (i = 0; i < ps_load(&init_schedule_off); i++) {
  40062d:	48 8b 05 0c da 05 00 	mov    rax,QWORD PTR [rip+0x5da0c]        # 45e040 <init_schedule_off>
  400634:	31 db                	xor    ebx,ebx
  400636:	48 85 c0             	test   rax,rax
  400639:	75 1c                	jne    400657 <slm_idle_comp_initialization+0x127>
  40063b:	eb 6b                	jmp    4006a8 <slm_idle_comp_initialization+0x178>
  40063d:	0f 1f 00             	nop    DWORD PTR [rax]
		slm_thd_wakeup(t, 0);
--
  400642:	48 83 c3 01          	add    rbx,0x1
		slm_thd_wakeup(t, 0);
  400646:	e8 e5 37 01 00       	call   413e30 <slm_thd_wakeup>
	for (i = 0; i < ps_load(&init_schedule_off); i++) {
  40064b:	48 8b 05 ee d9 05 00 	mov    rax,QWORD PTR [rip+0x5d9ee]        # 45e040 <init_schedule_off>
  400652:	48 39 c3             	cmp    rbx,rax
  400655:	73 51                	jae    4006a8 <slm_idle_comp_initialization+0x178>
		t = initialization_state[client].initialization_thds[cos_coreid()];
--
		assert(t != NULL);
  40066b:	48 85 ff             	test   rdi,rdi
  40066e:	75 d0                	jne    400640 <slm_idle_comp_initialization+0x110>
  400670:	be 24 00 00 00       	mov    esi,0x24
  400675:	bf 70 c5 41 00       	mov    edi,0x41c570
  40067a:	e8 51 9a 00 00       	call   40a0d0 <cos_print_str>
  40067f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400686:	00 00 00 00 
--
  40068c:	be 24 00 00 00       	mov    esi,0x24
  400691:	bf 08 c5 41 00       	mov    edi,0x41c508
  400696:	e8 35 9a 00 00       	call   40a0d0 <cos_print_str>
		assert(t);
  40069b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  4006a6:	0f 0b                	ud2    
	slm_cs_exit_reschedule(slm_thd_special(), SLM_CS_NONE);
  4006a8:	e8 23 30 01 00       	call   4136d0 <slm_thd_special>
		}
	}
--
  4006b3:	49 89 c5             	mov    r13,rax
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  4006b6:	e8 a5 b1 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	tok  = cos_sched_sync();
  4006bb:	e8 40 0c 01 00       	call   411300 <cos_sched_sync>
  4006c0:	41 89 c4             	mov    r12d,eax
	t = slm_sched_schedule();
  4006c3:	e8 d8 10 00 00       	call   4017a0 <slm_sched_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  4006c8:	48 85 c0             	test   rax,rax
--

	assert(slm_state_is_runnable(t->state));
  4006d8:	83 f8 01             	cmp    eax,0x1
  4006db:	76 1b                	jbe    4006f8 <slm_idle_comp_initialization+0x1c8>
  4006dd:	e9 e6 00 00 00       	jmp    4007c8 <slm_idle_comp_initialization+0x298>
  4006e2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4006e8:	f0 48 0f b1 15 cf 17 	lock cmpxchg QWORD PTR [rip+0x1a17cf],rdx        # 5a1ec0 <__slm_global>
  4006ef:	1a 00 
  4006f1:	0f 94 c0             	sete   al
	while (ret != 0) {
  4006f4:	84 c0                	test   al,al
  4006f6:	75 2e                	jne    400726 <slm_idle_comp_initialization+0x1f6>
		tok    = cos_sched_sync();
  4006f8:	e8 03 0c 01 00       	call   411300 <cos_sched_sync>
  4006fd:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  400706:	48 89 c2             	mov    rdx,rax
  400709:	83 e2 01             	and    edx,0x1
  40070c:	74 da                	je     4006e8 <slm_idle_comp_initialization+0x1b8>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  40070e:	48 89 c6             	mov    rsi,rax
--
  400714:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  400719:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  40071d:	e8 3e 31 01 00       	call   413860 <slm_cs_exit_contention>
  400722:	85 c0                	test   eax,eax
  400724:	75 d2                	jne    4006f8 <slm_idle_comp_initialization+0x1c8>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  400726:	e8 35 b1 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  40072b:	8b 03                	mov    eax,DWORD PTR [rbx]
--
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  400738:	a8 0b                	test   al,0xb
  40073a:	0f 85 da 00 00 00    	jne    40081a <slm_idle_comp_initialization+0x2ea>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  400740:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
--
  400747:	44 89 e1             	mov    ecx,r12d
  40074a:	4c 89 d6             	mov    rsi,r10
  40074d:	e8 0e c0 00 00       	call   40c760 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  400752:	83 f8 ff             	cmp    eax,0xffffffff
  400755:	0f 84 89 00 00 00    	je     4007e4 <slm_idle_comp_initialization+0x2b4>
	slm_cs_exit(NULL, flags);

--
	if (unlikely(ret != 0)) {
  40075b:	85 c0                	test   eax,eax
  40075d:	0f 85 01 01 00 00    	jne    400864 <slm_idle_comp_initialization+0x334>
	slm_comp_init_loop();
}
--
  400779:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  40077e:	41 83 e0 01          	and    r8d,0x1
  400782:	e8 89 30 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  400787:	83 f8 f0             	cmp    eax,0xfffffff0
  40078a:	0f 85 71 fe ff ff    	jne    400601 <slm_idle_comp_initialization+0xd1>
  400790:	be 59 00 00 00       	mov    esi,0x59
  400795:	bf 78 c2 41 00       	mov    edi,0x41c278
  40079a:	e8 31 99 00 00       	call   40a0d0 <cos_print_str>
  40079f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4007a6:	00 00 00 00 
--
  4007ac:	be 59 00 00 00       	mov    esi,0x59
  4007b1:	bf 18 c2 41 00       	mov    edi,0x41c218
  4007b6:	e8 15 99 00 00       	call   40a0d0 <cos_print_str>
	assert(current);
  4007bb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  4007c8:	be 61 00 00 00       	mov    esi,0x61
  4007cd:	bf 98 c5 41 00       	mov    edi,0x41c598
  4007d2:	e8 f9 98 00 00       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  4007d7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  4007e2:	0f 0b                	ud2    
	return t != &g->idle_thd && t != &g->sched_thd;
  4007e4:	48 81 fb 40 1f 5a 00 	cmp    rbx,0x5a1f40
  4007eb:	0f 84 d3 00 00 00    	je     4008c4 <slm_idle_comp_initialization+0x394>
  4007f1:	48 81 fb c8 1e 5a 00 	cmp    rbx,0x5a1ec8
  4007f8:	0f 84 c6 00 00 00    	je     4008c4 <slm_idle_comp_initialization+0x394>
  4007fe:	be 61 00 00 00       	mov    esi,0x61
  400803:	bf 00 c6 41 00       	mov    edi,0x41c600
  400808:	e8 c3 98 00 00       	call   40a0d0 <cos_print_str>
		/* Assuming only the single tcap with infinite budget...should not get EPERM */
		assert(ret != -EPERM);
--
  40081a:	48 89 f1             	mov    rcx,rsi
		if (t == &g->sched_thd) {
  40081d:	48 81 fb c8 1e 5a 00 	cmp    rbx,0x5a1ec8
  400824:	0f 84 8f 00 00 00    	je     4008b9 <slm_idle_comp_initialization+0x389>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  40082a:	a8 02                	test   al,0x2
  40082c:	0f 85 b5 00 00 00    	jne    4008e7 <slm_idle_comp_initialization+0x3b7>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  400832:	48 89 ce             	mov    rsi,rcx
  400835:	a8 01                	test   al,0x1
  400837:	0f 84 03 ff ff ff    	je     400740 <slm_idle_comp_initialization+0x210>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  40083d:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
--
  400848:	4c 89 d2             	mov    rdx,r10
  40084b:	4c 8b 05 96 16 1a 00 	mov    r8,QWORD PTR [rip+0x1a1696]        # 5a1ee8 <__slm_global+0x28>
  400852:	e8 c9 0a 01 00       	call   411320 <cos_switch>
	if (unlikely(ret != 0)) {
  400857:	85 c0                	test   eax,eax
  400859:	0f 84 04 ff ff ff    	je     400763 <slm_idle_comp_initialization+0x233>
		assert(ret != -EPERM);
  40085f:	83 f8 ff             	cmp    eax,0xffffffff
  400862:	74 9a                	je     4007fe <slm_idle_comp_initialization+0x2ce>
		assert(ret != -EINVAL);
  400864:	83 f8 ea             	cmp    eax,0xffffffea
  400867:	0f 84 d0 00 00 00    	je     40093d <slm_idle_comp_initialization+0x40d>

		/*
--
		 */
		if (ret == -EBUSY) return ret;
  40086d:	83 f8 f0             	cmp    eax,0xfffffff0
  400870:	0f 84 ed fe ff ff    	je     400763 <slm_idle_comp_initialization+0x233>
		/* If the slm_thd_activate returns -EAGAIN, this means this scheduling token is outdated, try again */
		assert(ret == -EAGAIN);
  400876:	83 f8 f5             	cmp    eax,0xfffffff5
  400879:	0f 85 a2 00 00 00    	jne    400921 <slm_idle_comp_initialization+0x3f1>
  40087f:	4d 85 ed             	test   r13,r13
  400882:	0f 84 24 ff ff ff    	je     4007ac <slm_idle_comp_initialization+0x27c>
		tok    = cos_sched_sync();
  400888:	e8 73 0a 01 00       	call   411300 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  40088d:	48 8b 35 2c 16 1a 00 	mov    rsi,QWORD PTR [rip+0x1a162c]        # 5a1ec0 <__slm_global>
--
  400897:	48 89 f1             	mov    rcx,rsi
  40089a:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  40089e:	75 5f                	jne    4008ff <slm_idle_comp_initialization+0x3cf>
  4008a0:	48 89 f0             	mov    rax,rsi
  4008a3:	f0 4c 0f b1 2d 14 16 	lock cmpxchg QWORD PTR [rip+0x1a1614],r13        # 5a1ec0 <__slm_global>
  4008aa:	1a 00 
  4008ac:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4008af:	84 c0                	test   al,al
  4008b1:	0f 85 04 fe ff ff    	jne    4006bb <slm_idle_comp_initialization+0x18b>
  4008b7:	eb cf                	jmp    400888 <slm_idle_comp_initialization+0x358>
			prio    = curr->priority;
  4008b9:	4d 8b 55 30          	mov    r10,QWORD PTR [r13+0x30]
			timeout = TCAP_TIME_NIL;
  4008bd:	31 c9                	xor    ecx,ecx
  4008bf:	e9 66 ff ff ff       	jmp    40082a <slm_idle_comp_initialization+0x2fa>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  4008c4:	49 8b 55 30          	mov    rdx,QWORD PTR [r13+0x30]
--
  4008d4:	48 8b 3d fd 15 1a 00 	mov    rdi,QWORD PTR [rip+0x1a15fd]        # 5a1ed8 <__slm_global+0x18>
  4008db:	31 f6                	xor    esi,esi
  4008dd:	e8 3e 0a 01 00       	call   411320 <cos_switch>
  4008e2:	e9 70 ff ff ff       	jmp    400857 <slm_idle_comp_initialization+0x327>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  4008e7:	48 8b 7b 28          	mov    rdi,QWORD PTR [rbx+0x28]
  4008eb:	48 8b 15 f6 15 1a 00 	mov    rdx,QWORD PTR [rip+0x1a15f6]        # 5a1ee8 <__slm_global+0x28>
  4008f2:	44 89 e1             	mov    ecx,r12d
  4008f5:	e8 96 0a 01 00       	call   411390 <cos_sched_asnd>
  4008fa:	e9 58 ff ff ff       	jmp    400857 <slm_idle_comp_initialization+0x327>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  4008ff:	41 89 f0             	mov    r8d,esi
--
  400905:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  40090a:	41 83 e0 01          	and    r8d,0x1
  40090e:	e8 fd 2e 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  400913:	83 f8 f0             	cmp    eax,0xfffffff0
  400916:	0f 85 6c ff ff ff    	jne    400888 <slm_idle_comp_initialization+0x358>
  40091c:	e9 6f fe ff ff       	jmp    400790 <slm_idle_comp_initialization+0x260>
  400921:	be 61 00 00 00       	mov    esi,0x61
  400926:	bf d0 c6 41 00       	mov    edi,0x41c6d0
  40092b:	e8 a0 97 00 00       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  400930:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40093d:	be 61 00 00 00       	mov    esi,0x61
  400942:	bf 68 c6 41 00       	mov    edi,0x41c668
  400947:	e8 84 97 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  40094c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  400987:	4c 89 8d 78 ff ff ff 	mov    QWORD PTR [rbp-0x88],r9
  40098e:	84 c0                	test   al,al
  400990:	74 20                	je     4009b2 <printc.constprop.0+0x52>
  400992:	0f 29 45 80          	movaps XMMWORD PTR [rbp-0x80],xmm0
  400996:	0f 29 4d 90          	movaps XMMWORD PTR [rbp-0x70],xmm1
--
  4009f4:	00 00 00 
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  4009f7:	e8 64 4b 01 00       	call   415560 <vsnprintf>
	ret = cos_print_str(s, ret);
  4009fc:	48 8d bd 90 fe ff ff 	lea    rdi,[rbp-0x170]
  400a03:	be 1b 00 00 00       	mov    esi,0x1b
  400a08:	e8 c3 96 00 00       	call   40a0d0 <cos_print_str>
}
  400a0d:	c9                   	leave  
--
  400a1f:	48 83 ec 18          	sub    rsp,0x18
	struct slm_ipi_percore *ipi_data = slm_ipi_percore_get(cos_cpuid());
  400a23:	e8 88 2c 01 00       	call   4136b0 <slm_ipi_percore_get>
	struct slm_ipi_thd     *r        = &ipi_data->ipi_thd;
	struct slm_ipi_event    event    = { 0 };
--
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  400a43:	48 85 c0             	test   rax,rax
  400a46:	0f 84 c0 01 00 00    	je     400c0c <slm_ipi_process+0x1fc>
  400a4c:	83 e8 01             	sub    eax,0x1
  400a4f:	83 f8 18             	cmp    eax,0x18
  400a52:	0f 87 b4 01 00 00    	ja     400c0c <slm_ipi_process+0x1fc>
  400a58:	48 8b 14 c5 00 e7 45 	mov    rdx,QWORD PTR [rax*8+0x45e700]
--
	return ((state & ~1) != 0) && ((state & 1) == SS_STATE_ALLOC);
  400a62:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  400a69:	0f 85 65 01 00 00    	jne    400bd4 <slm_ipi_process+0x1c4>
  400a6f:	90                   	nop
	struct slm_thd         *current  = slm_thd_current();
--
  400a74:	48 8d 55 d4          	lea    rdx,[rbp-0x2c]
  400a78:	be 02 00 00 00       	mov    esi,0x2
  400a7d:	e8 7e 0a 01 00       	call   411500 <cos_rcv>

		while (!slm_ipi_event_empty(cos_cpuid())) {
  400a82:	31 ff                	xor    edi,edi
  400a84:	e8 f7 2b 01 00       	call   413680 <slm_ipi_event_empty>
  400a89:	85 c0                	test   eax,eax
  400a8b:	75 e3                	jne    400a70 <slm_ipi_process+0x60>
			slm_ipi_event_dequeue(&event, cos_cpuid());
  400a8d:	31 f6                	xor    esi,esi
  400a8f:	48 8d 7d d8          	lea    rdi,[rbp-0x28]
  400a93:	e8 88 2b 01 00       	call   413620 <slm_ipi_event_dequeue>
	return &ss_thd_get(id)->thd;
  400a98:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  400a9c:	85 c0                	test   eax,eax
  400a9e:	0f 84 cc 00 00 00    	je     400b70 <slm_ipi_process+0x160>
  400aa4:	83 e8 01             	sub    eax,0x1
  400aa7:	83 f8 18             	cmp    eax,0x18
  400aaa:	0f 87 c0 00 00 00    	ja     400b70 <slm_ipi_process+0x160>
  400ab0:	48 8b 14 c5 00 e7 45 	mov    rdx,QWORD PTR [rax*8+0x45e700]
--
  400ab8:	45 31 ed             	xor    r13d,r13d
  400abb:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  400ac2:	74 18                	je     400adc <slm_ipi_process+0xcc>
  400ac4:	83 e2 01             	and    edx,0x1
  400ac7:	75 13                	jne    400adc <slm_ipi_process+0xcc>
  400ac9:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  400acd:	4c 8d 2c 50          	lea    r13,[rax+rdx*2]
--
	assert(current);
  400adc:	48 85 db             	test   rbx,rbx
  400adf:	0f 84 97 00 00 00    	je     400b7c <slm_ipi_process+0x16c>
		tok    = cos_sched_sync();
  400ae5:	e8 16 08 01 00       	call   411300 <cos_sched_sync>
  400aea:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  400af4:	48 89 c1             	mov    rcx,rax
  400af7:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  400afb:	0f 85 97 00 00 00    	jne    400b98 <slm_ipi_process+0x188>
  400b01:	f0 48 0f b1 1d b6 13 	lock cmpxchg QWORD PTR [rip+0x1a13b6],rbx        # 5a1ec0 <__slm_global>
  400b08:	1a 00 
  400b0a:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  400b0d:	84 c0                	test   al,al
  400b0f:	74 d4                	je     400ae5 <slm_ipi_process+0xd5>

			thd = slm_thd_static_cm_lookup(event.tid);
--
  400b11:	31 f6                	xor    esi,esi
  400b13:	4c 89 ef             	mov    rdi,r13
  400b16:	e8 15 33 01 00       	call   413e30 <slm_thd_wakeup>
			/*
			 * Return "0" means the thread is woken up in this call.
			 * Return "1" means the thread is already `RUNNABLE`.
			 */
			assert(ret == 0 || ret == 1);
  400b1b:	83 f8 01             	cmp    eax,0x1
  400b1e:	76 1c                	jbe    400b3c <slm_ipi_process+0x12c>
  400b20:	e9 cb 00 00 00       	jmp    400bf0 <slm_ipi_process+0x1e0>
  400b25:	0f 1f 00             	nop    DWORD PTR [rax]
  400b28:	f0 48 0f b1 15 8f 13 	lock cmpxchg QWORD PTR [rip+0x1a138f],rdx        # 5a1ec0 <__slm_global>
  400b2f:	1a 00 
  400b31:	0f 94 c0             	sete   al
	while (ret != 0) {
  400b34:	84 c0                	test   al,al
  400b36:	0f 85 46 ff ff ff    	jne    400a82 <slm_ipi_process+0x72>
		tok    = cos_sched_sync();
  400b3c:	e8 bf 07 01 00       	call   411300 <cos_sched_sync>
  400b41:	89 c1                	mov    ecx,eax
  400b43:	48 8b 05 76 13 1a 00 	mov    rax,QWORD PTR [rip+0x1a1376]        # 5a1ec0 <__slm_global>
--
  400b4a:	48 89 c2             	mov    rdx,rax
  400b4d:	83 e2 01             	and    edx,0x1
  400b50:	74 d6                	je     400b28 <slm_ipi_process+0x118>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  400b52:	48 89 c6             	mov    rsi,rax
--
  400b58:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  400b5d:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  400b61:	e8 fa 2c 01 00       	call   413860 <slm_cs_exit_contention>
  400b66:	85 c0                	test   eax,eax
  400b68:	0f 84 14 ff ff ff    	je     400a82 <slm_ipi_process+0x72>
  400b6e:	eb cc                	jmp    400b3c <slm_ipi_process+0x12c>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  400b70:	45 31 ed             	xor    r13d,r13d
	assert(current);
  400b73:	48 85 db             	test   rbx,rbx
  400b76:	0f 85 69 ff ff ff    	jne    400ae5 <slm_ipi_process+0xd5>
	return cos_print_str(s, strlen(s));
  400b7c:	be 59 00 00 00       	mov    esi,0x59
  400b81:	bf 60 c7 41 00       	mov    edi,0x41c760
  400b86:	e8 45 95 00 00       	call   40a0d0 <cos_print_str>
  400b8b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400b92:	00 00 00 00 
--
  400ba1:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  400ba6:	41 83 e0 01          	and    r8d,0x1
  400baa:	e8 61 2c 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  400baf:	83 f8 f0             	cmp    eax,0xfffffff0
  400bb2:	0f 85 2d ff ff ff    	jne    400ae5 <slm_ipi_process+0xd5>
  400bb8:	be 59 00 00 00       	mov    esi,0x59
  400bbd:	bf c0 c7 41 00       	mov    edi,0x41c7c0
  400bc2:	e8 09 95 00 00       	call   40a0d0 <cos_print_str>
  400bc7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400bce:	00 00 00 00 
  400bd2:	0f 0b                	ud2    
  400bd4:	80 e2 01             	and    dl,0x1
  400bd7:	0f 85 93 fe ff ff    	jne    400a70 <slm_ipi_process+0x60>
  400bdd:	48 69 c0 b0 00 00 00 	imul   rax,rax,0xb0
  400be4:	48 8d 98 c8 e7 45 00 	lea    rbx,[rax+0x45e7c8]
  400beb:	e9 80 fe ff ff       	jmp    400a70 <slm_ipi_process+0x60>
  400bf0:	be 24 00 00 00       	mov    esi,0x24
  400bf5:	bf 20 c8 41 00       	mov    edi,0x41c820
  400bfa:	e8 d1 94 00 00       	call   40a0d0 <cos_print_str>
			assert(ret == 0 || ret == 1);
  400bff:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  400c0c:	31 db                	xor    ebx,ebx
  400c0e:	e9 5d fe ff ff       	jmp    400a70 <slm_ipi_process+0x60>
  400c13:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  400c1a:	00 00 00 00 
--
	assert(current);
  400c31:	48 85 ff             	test   rdi,rdi
  400c34:	0f 84 12 01 00 00    	je     400d4c <slm_blkpt_alloc+0x12c>
		tok    = cos_sched_sync();
  400c3a:	e8 c1 06 01 00       	call   411300 <cos_sched_sync>
  400c3f:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  400c49:	48 89 c1             	mov    rcx,rax
  400c4c:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  400c50:	0f 85 ba 00 00 00    	jne    400d10 <slm_blkpt_alloc+0xf0>
  400c56:	f0 4c 0f b1 25 61 12 	lock cmpxchg QWORD PTR [rip+0x1a1261],r12        # 5a1ec0 <__slm_global>
  400c5d:	1a 00 
  400c5f:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  400c62:	84 c0                	test   al,al
  400c64:	74 d4                	je     400c3a <slm_blkpt_alloc+0x1a>
	struct blkpt_mem *m;
	sched_blkpt_id_t ret = SCHED_BLKPT_NULL;
--
  400c66:	44 8b 25 93 33 02 00 	mov    r12d,DWORD PTR [rip+0x23393]        # 424000 <__blkpt_offset>
	if (id - 1 == NBLKPTS) return NULL;
  400c6d:	41 81 fc 01 a0 00 00 	cmp    r12d,0xa001
  400c74:	0f 84 ee 00 00 00    	je     400d68 <slm_blkpt_alloc+0x148>
	return &__blkpts[id-1];
  400c7a:	41 8d 44 24 ff       	lea    eax,[r12-0x1]
--
  400cab:	41 8d 44 24 01       	lea    eax,[r12+0x1]
  400cb0:	89 05 4a 33 02 00    	mov    DWORD PTR [rip+0x2334a],eax        # 424000 <__blkpt_offset>
  400cb6:	eb 18                	jmp    400cd0 <slm_blkpt_alloc+0xb0>
  400cb8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  400cbf:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  400cc0:	f0 48 0f b1 15 f7 11 	lock cmpxchg QWORD PTR [rip+0x1a11f7],rdx        # 5a1ec0 <__slm_global>
  400cc7:	1a 00 
  400cc9:	0f 94 c0             	sete   al
	while (ret != 0) {
  400ccc:	84 c0                	test   al,al
  400cce:	75 2e                	jne    400cfe <slm_blkpt_alloc+0xde>
		tok    = cos_sched_sync();
  400cd0:	e8 2b 06 01 00       	call   411300 <cos_sched_sync>
  400cd5:	89 c1                	mov    ecx,eax
  400cd7:	48 8b 05 e2 11 1a 00 	mov    rax,QWORD PTR [rip+0x1a11e2]        # 5a1ec0 <__slm_global>
--
  400cde:	48 89 c2             	mov    rdx,rax
  400ce1:	83 e2 01             	and    edx,0x1
  400ce4:	74 da                	je     400cc0 <slm_blkpt_alloc+0xa0>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  400ce6:	48 89 c6             	mov    rsi,rax
--
  400cec:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  400cf1:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  400cf5:	e8 66 2b 01 00       	call   413860 <slm_cs_exit_contention>
  400cfa:	85 c0                	test   eax,eax
  400cfc:	75 d2                	jne    400cd0 <slm_blkpt_alloc+0xb0>
unlock:
	slm_cs_exit(NULL, SLM_CS_NONE);
--
  400d19:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  400d1e:	41 83 e0 01          	and    r8d,0x1
  400d22:	e8 e9 2a 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  400d27:	83 f8 f0             	cmp    eax,0xfffffff0
  400d2a:	0f 85 0a ff ff ff    	jne    400c3a <slm_blkpt_alloc+0x1a>
  400d30:	be 59 00 00 00       	mov    esi,0x59
  400d35:	bf c0 c7 41 00       	mov    edi,0x41c7c0
  400d3a:	e8 91 93 00 00       	call   40a0d0 <cos_print_str>
  400d3f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400d46:	00 00 00 00 
--
  400d4c:	be 59 00 00 00       	mov    esi,0x59
  400d51:	bf 60 c7 41 00       	mov    edi,0x41c760
  400d56:	e8 75 93 00 00       	call   40a0d0 <cos_print_str>
	assert(current);
  400d5b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  400d68:	45 31 e4             	xor    r12d,r12d
	while (ret != 0) {
  400d6b:	e9 60 ff ff ff       	jmp    400cd0 <slm_blkpt_alloc+0xb0>

0000000000400d70 <slm_blkpt_free>:
--
	assert(current);
  400da1:	48 85 f6             	test   rsi,rsi
  400da4:	0f 84 5a 02 00 00    	je     401004 <slm_blkpt_trigger+0x284>
		tok    = cos_sched_sync();
  400daa:	e8 51 05 01 00       	call   411300 <cos_sched_sync>
  400daf:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  400db9:	48 89 c1             	mov    rcx,rax
  400dbc:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  400dc0:	0f 85 02 02 00 00    	jne    400fc8 <slm_blkpt_trigger+0x248>
  400dc6:	f0 48 0f b1 1d f1 10 	lock cmpxchg QWORD PTR [rip+0x1a10f1],rbx        # 5a1ec0 <__slm_global>
  400dcd:	1a 00 
  400dcf:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  400dd2:	84 c0                	test   al,al
  400dd4:	74 d4                	je     400daa <slm_blkpt_trigger+0x2a>
	if (id - 1 == NBLKPTS) return NULL;
  400dd6:	41 81 fe 01 a0 00 00 	cmp    r14d,0xa001
  400ddd:	0f 84 3d 02 00 00    	je     401020 <slm_blkpt_trigger+0x2a0>
	return &__blkpts[id-1];
  400de3:	41 8d 7e ff          	lea    edi,[r14-0x1]
--
        __asm__ __volatile__("lock " PS_CAS_STR
  400e08:	48 89 c8             	mov    rax,rcx
  400e0b:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  400e10:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  400e13:	84 c0                	test   al,al
  400e15:	74 f1                	je     400e08 <slm_blkpt_trigger+0x88>

		if (!blkpt_epoch_is_higher(pre, epoch)) {
--
		if (ps_cas(&m->epoch, pre, epoch)) break;
  400e17:	49 8d 96 08 f9 45 00 	lea    rdx,[r14+0x45f908]
  400e1e:	eb 0c                	jmp    400e2c <slm_blkpt_trigger+0xac>
        __asm__ __volatile__("lock " PS_CAS_STR
  400e20:	f0 4c 0f b1 2a       	lock cmpxchg QWORD PTR [rdx],r13
  400e25:	0f 94 c0             	sete   al
  400e28:	84 c0                	test   al,al
  400e2a:	75 74                	jne    400ea0 <slm_blkpt_trigger+0x120>
		sched_blkpt_epoch_t pre = ps_load(&m->epoch);
  400e2c:	49 8b 47 08          	mov    rax,QWORD PTR [r15+0x8]
		if (!blkpt_epoch_is_higher(pre, epoch)) {
  400e30:	4c 39 e8             	cmp    rax,r13
  400e33:	76 eb                	jbe    400e20 <slm_blkpt_trigger+0xa0>
{ l->o = 0; }
--
			ERR_THROW(0, unlock); 
  400e3d:	45 31 e4             	xor    r12d,r12d
  400e40:	eb 16                	jmp    400e58 <slm_blkpt_trigger+0xd8>
  400e42:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  400e48:	f0 48 0f b1 15 6f 10 	lock cmpxchg QWORD PTR [rip+0x1a106f],rdx        # 5a1ec0 <__slm_global>
  400e4f:	1a 00 
  400e51:	0f 94 c0             	sete   al
	while (ret != 0) {
  400e54:	84 c0                	test   al,al
  400e56:	75 2e                	jne    400e86 <slm_blkpt_trigger+0x106>
		tok    = cos_sched_sync();
  400e58:	e8 a3 04 01 00       	call   411300 <cos_sched_sync>
  400e5d:	89 c1                	mov    ecx,eax
  400e5f:	48 8b 05 5a 10 1a 00 	mov    rax,QWORD PTR [rip+0x1a105a]        # 5a1ec0 <__slm_global>
--
  400e66:	48 89 c2             	mov    rdx,rax
  400e69:	83 e2 01             	and    edx,0x1
  400e6c:	74 da                	je     400e48 <slm_blkpt_trigger+0xc8>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  400e6e:	48 89 c6             	mov    rsi,rax
--
  400e74:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  400e79:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  400e7d:	e8 de 29 01 00       	call   413860 <slm_cs_exit_contention>
  400e82:	85 c0                	test   eax,eax
  400e84:	75 d2                	jne    400e58 <slm_blkpt_trigger+0xd8>
	return 0;
unlock:
--
  400eae:	66 90                	xchg   ax,ax
	if (!h->head) return NULL;
  400eb0:	49 83 7f 10 00       	cmp    QWORD PTR [r15+0x10],0x0
  400eb5:	74 28                	je     400edf <slm_blkpt_trigger+0x15f>
		sl = ps_load(&h->head);
  400eb7:	49 8d b5 00 f9 45 00 	lea    rsi,[r13+0x45f900]
  400ebe:	eb 16                	jmp    400ed6 <slm_blkpt_trigger+0x156>
  400ec0:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
  400ec3:	48 89 d0             	mov    rax,rdx
  400ec6:	f0 49 0f b1 0e       	lock cmpxchg QWORD PTR [r14],rcx
  400ecb:	0f 94 c0             	sete   al
		if (ps_cas((unsigned long *)&h->head, (unsigned long)sl, (unsigned long)sl->next)) break;
  400ece:	84 c0                	test   al,al
  400ed0:	0f 85 d2 00 00 00    	jne    400fa8 <slm_blkpt_trigger+0x228>
		sl = ps_load(&h->head);
  400ed6:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
		if (!sl) return NULL;
  400eda:	48 85 d2             	test   rdx,rdx
  400edd:	75 e1                	jne    400ec0 <slm_blkpt_trigger+0x140>
{ l->o = 0; }
  400edf:	49 c7 47 18 00 00 00 	mov    QWORD PTR [r15+0x18],0x0
--
  400ee7:	41 bd 40 1f 5a 00    	mov    r13d,0x5a1f40
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  400eed:	e8 6e a9 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	tok  = cos_sched_sync();
  400ef2:	e8 09 04 01 00       	call   411300 <cos_sched_sync>
  400ef7:	41 89 c6             	mov    r14d,eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  400efa:	e8 91 15 01 00       	call   412490 <slm_sched_fprr_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  400eff:	48 85 c0             	test   rax,rax
--
  400f0e:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  400f11:	83 f8 01             	cmp    eax,0x1
  400f14:	76 1a                	jbe    400f30 <slm_blkpt_trigger+0x1b0>
  400f16:	e9 10 01 00 00       	jmp    40102b <slm_blkpt_trigger+0x2ab>
  400f1b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  400f20:	f0 48 0f b1 15 97 0f 	lock cmpxchg QWORD PTR [rip+0x1a0f97],rdx        # 5a1ec0 <__slm_global>
  400f27:	1a 00 
  400f29:	0f 94 c0             	sete   al
	while (ret != 0) {
  400f2c:	84 c0                	test   al,al
  400f2e:	75 2e                	jne    400f5e <slm_blkpt_trigger+0x1de>
		tok    = cos_sched_sync();
  400f30:	e8 cb 03 01 00       	call   411300 <cos_sched_sync>
  400f35:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  400f3e:	48 89 c2             	mov    rdx,rax
  400f41:	83 e2 01             	and    edx,0x1
  400f44:	74 da                	je     400f20 <slm_blkpt_trigger+0x1a0>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  400f46:	48 89 c6             	mov    rsi,rax
--
  400f4c:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  400f51:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  400f55:	e8 06 29 01 00       	call   413860 <slm_cs_exit_contention>
  400f5a:	85 c0                	test   eax,eax
  400f5c:	75 d2                	jne    400f30 <slm_blkpt_trigger+0x1b0>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  400f5e:	e8 fd a8 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  400f63:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
--
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  400f73:	a8 0b                	test   al,0xb
  400f75:	0f 85 cc 00 00 00    	jne    401047 <slm_blkpt_trigger+0x2c7>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  400f7b:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  400f80:	44 89 f1             	mov    ecx,r14d
  400f83:	4c 89 c2             	mov    rdx,r8
  400f86:	e8 d5 b7 00 00       	call   40c760 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  400f8b:	83 f8 ff             	cmp    eax,0xffffffff
  400f8e:	0f 84 5c 01 00 00    	je     4010f0 <slm_blkpt_trigger+0x370>
	if (unlikely(ret != 0)) {
  400f94:	85 c0                	test   eax,eax
  400f96:	0f 85 fa 00 00 00    	jne    401096 <slm_blkpt_trigger+0x316>
	return 0;
  400f9c:	45 31 e4             	xor    r12d,r12d
  400f9f:	e9 e2 fe ff ff       	jmp    400e86 <slm_blkpt_trigger+0x106>
  400fa4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	}
--
  400faf:	48 8b 7a 08          	mov    rdi,QWORD PTR [rdx+0x8]
  400fb3:	31 f6                	xor    esi,esi
  400fb5:	e8 76 2e 01 00       	call   413e30 <slm_thd_wakeup>
		if (single) break;
  400fba:	45 85 e4             	test   r12d,r12d
  400fbd:	0f 84 ed fe ff ff    	je     400eb0 <slm_blkpt_trigger+0x130>
  400fc3:	e9 17 ff ff ff       	jmp    400edf <slm_blkpt_trigger+0x15f>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  400fc8:	41 89 c0             	mov    r8d,eax
--
  400fd1:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  400fd6:	41 83 e0 01          	and    r8d,0x1
  400fda:	e8 31 28 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  400fdf:	83 f8 f0             	cmp    eax,0xfffffff0
  400fe2:	0f 85 c2 fd ff ff    	jne    400daa <slm_blkpt_trigger+0x2a>
  400fe8:	be 59 00 00 00       	mov    esi,0x59
  400fed:	bf c0 c7 41 00       	mov    edi,0x41c7c0
  400ff2:	e8 d9 90 00 00       	call   40a0d0 <cos_print_str>
  400ff7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400ffe:	00 00 00 00 
--
  401004:	be 59 00 00 00       	mov    esi,0x59
  401009:	bf 60 c7 41 00       	mov    edi,0x41c760
  40100e:	e8 bd 90 00 00       	call   40a0d0 <cos_print_str>
	assert(current);
  401013:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  401020:	41 bc ff ff ff ff    	mov    r12d,0xffffffff
	while (ret != 0) {
  401026:	e9 2d fe ff ff       	jmp    400e58 <slm_blkpt_trigger+0xd8>
  40102b:	be 61 00 00 00       	mov    esi,0x61
  401030:	bf 48 c8 41 00       	mov    edi,0x41c848
  401035:	e8 96 90 00 00       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  40103a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  401047:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  40104a:	49 81 fc c8 1e 5a 00 	cmp    r12,0x5a1ec8
  401051:	0f 84 c7 00 00 00    	je     40111e <slm_blkpt_trigger+0x39e>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  401057:	a8 02                	test   al,0x2
  401059:	0f 85 ca 00 00 00    	jne    401129 <slm_blkpt_trigger+0x3a9>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  40105f:	49 89 c8             	mov    r8,rcx
  401062:	a8 01                	test   al,0x1
  401064:	0f 84 11 ff ff ff    	je     400f7b <slm_blkpt_trigger+0x1fb>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  40106a:	4d 8b 54 24 08       	mov    r10,QWORD PTR [r12+0x8]
--
  40107a:	4c 8b 05 67 0e 1a 00 	mov    r8,QWORD PTR [rip+0x1a0e67]        # 5a1ee8 <__slm_global+0x28>
  401081:	4c 89 d6             	mov    rsi,r10
  401084:	e8 97 02 01 00       	call   411320 <cos_switch>
	if (unlikely(ret != 0)) {
  401089:	85 c0                	test   eax,eax
  40108b:	0f 84 0b ff ff ff    	je     400f9c <slm_blkpt_trigger+0x21c>
		assert(ret != -EPERM);
  401091:	83 f8 ff             	cmp    eax,0xffffffff
  401094:	74 6c                	je     401102 <slm_blkpt_trigger+0x382>
		assert(ret != -EINVAL);
  401096:	83 f8 ea             	cmp    eax,0xffffffea
  401099:	0f 84 0d 01 00 00    	je     4011ac <slm_blkpt_trigger+0x42c>
		if (ret == -EBUSY) return ret;
  40109f:	83 f8 f0             	cmp    eax,0xfffffff0
  4010a2:	0f 84 f4 fe ff ff    	je     400f9c <slm_blkpt_trigger+0x21c>
		assert(ret == -EAGAIN);
  4010a8:	83 f8 f5             	cmp    eax,0xfffffff5
  4010ab:	0f 85 df 00 00 00    	jne    401190 <slm_blkpt_trigger+0x410>
		tok    = cos_sched_sync();
  4010b1:	e8 4a 02 01 00       	call   411300 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  4010b6:	48 8b 35 03 0e 1a 00 	mov    rsi,QWORD PTR [rip+0x1a0e03]        # 5a1ec0 <__slm_global>
--
  4010c0:	48 89 f1             	mov    rcx,rsi
  4010c3:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  4010c7:	0f 85 9b 00 00 00    	jne    401168 <slm_blkpt_trigger+0x3e8>
  4010cd:	48 89 f0             	mov    rax,rsi
  4010d0:	f0 48 0f b1 1d e7 0d 	lock cmpxchg QWORD PTR [rip+0x1a0de7],rbx        # 5a1ec0 <__slm_global>
  4010d7:	1a 00 
  4010d9:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4010dc:	84 c0                	test   al,al
  4010de:	0f 85 0e fe ff ff    	jne    400ef2 <slm_blkpt_trigger+0x172>
  4010e4:	eb cb                	jmp    4010b1 <slm_blkpt_trigger+0x331>
  4010e6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4010ed:	00 00 00 
	return t != &g->idle_thd && t != &g->sched_thd;
  4010f0:	49 81 fc 40 1f 5a 00 	cmp    r12,0x5a1f40
  4010f7:	74 4c                	je     401145 <slm_blkpt_trigger+0x3c5>
  4010f9:	49 81 fc c8 1e 5a 00 	cmp    r12,0x5a1ec8
  401100:	74 43                	je     401145 <slm_blkpt_trigger+0x3c5>
  401102:	be 61 00 00 00       	mov    esi,0x61
  401107:	bf b0 c8 41 00       	mov    edi,0x41c8b0
  40110c:	e8 bf 8f 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EPERM);
  401111:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
			timeout = TCAP_TIME_NIL;
  401122:	31 c9                	xor    ecx,ecx
  401124:	e9 2e ff ff ff       	jmp    401057 <slm_blkpt_trigger+0x2d7>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  401129:	49 8b 7c 24 28       	mov    rdi,QWORD PTR [r12+0x28]
--
  401135:	44 89 f1             	mov    ecx,r14d
  401138:	4c 89 c6             	mov    rsi,r8
  40113b:	e8 50 02 01 00       	call   411390 <cos_sched_asnd>
  401140:	e9 44 ff ff ff       	jmp    401089 <slm_blkpt_trigger+0x309>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  401145:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]
--
  401155:	48 8b 3d 7c 0d 1a 00 	mov    rdi,QWORD PTR [rip+0x1a0d7c]        # 5a1ed8 <__slm_global+0x18>
  40115c:	31 f6                	xor    esi,esi
  40115e:	e8 bd 01 01 00       	call   411320 <cos_switch>
  401163:	e9 21 ff ff ff       	jmp    401089 <slm_blkpt_trigger+0x309>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  401168:	41 89 f0             	mov    r8d,esi
--
  40116e:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  401173:	41 83 e0 01          	and    r8d,0x1
  401177:	e8 94 26 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  40117c:	83 f8 f0             	cmp    eax,0xfffffff0
  40117f:	0f 85 2c ff ff ff    	jne    4010b1 <slm_blkpt_trigger+0x331>
  401185:	e9 5e fe ff ff       	jmp    400fe8 <slm_blkpt_trigger+0x268>
  40118a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  401190:	be 61 00 00 00       	mov    esi,0x61
  401195:	bf 80 c9 41 00       	mov    edi,0x41c980
  40119a:	e8 31 8f 00 00       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  40119f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  4011ac:	be 61 00 00 00       	mov    esi,0x61
  4011b1:	bf 18 c9 41 00       	mov    edi,0x41c918
  4011b6:	e8 15 8f 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  4011bb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	assert(current);
  4011ee:	48 85 f6             	test   rsi,rsi
  4011f1:	0f 84 05 02 00 00    	je     4013fc <slm_blkpt_block+0x22c>
		tok    = cos_sched_sync();
  4011f7:	e8 04 01 01 00       	call   411300 <cos_sched_sync>
  4011fc:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  401206:	48 89 c1             	mov    rcx,rax
  401209:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  40120d:	0f 85 ad 01 00 00    	jne    4013c0 <slm_blkpt_block+0x1f0>
  401213:	f0 48 0f b1 1d a4 0c 	lock cmpxchg QWORD PTR [rip+0x1a0ca4],rbx        # 5a1ec0 <__slm_global>
  40121a:	1a 00 
  40121c:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  40121f:	84 c0                	test   al,al
  401221:	74 d4                	je     4011f7 <slm_blkpt_block+0x27>
	if (id - 1 == NBLKPTS) return NULL;
  401223:	41 81 fd 01 a0 00 00 	cmp    r13d,0xa001
  40122a:	0f 84 e8 01 00 00    	je     401418 <slm_blkpt_block+0x248>
	return &__blkpts[id-1];
  401230:	45 8d 45 ff          	lea    r8d,[r13-0x1]
--
        __asm__ __volatile__("lock " PS_CAS_STR
  401250:	48 89 c8             	mov    rax,rcx
  401253:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  401258:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40125b:	84 c0                	test   al,al
  40125d:	74 f1                	je     401250 <slm_blkpt_block+0x80>
		ERR_THROW(-1, unlock);
	}
--
  40125f:	49 8b 75 08          	mov    rsi,QWORD PTR [r13+0x8]
	if (!blkpt_epoch_is_higher(pre, epoch)) {
  401263:	4c 39 e6             	cmp    rsi,r12
  401266:	76 68                	jbe    4012d0 <slm_blkpt_block+0x100>
{ l->o = 0; }
--
		ERR_THROW(0, unlock);
  401270:	45 31 e4             	xor    r12d,r12d
  401273:	eb 13                	jmp    401288 <slm_blkpt_block+0xb8>
  401275:	0f 1f 00             	nop    DWORD PTR [rax]
        __asm__ __volatile__("lock " PS_CAS_STR
  401278:	f0 48 0f b1 15 3f 0c 	lock cmpxchg QWORD PTR [rip+0x1a0c3f],rdx        # 5a1ec0 <__slm_global>
  40127f:	1a 00 
  401281:	0f 94 c0             	sete   al
	while (ret != 0) {
  401284:	84 c0                	test   al,al
  401286:	75 2e                	jne    4012b6 <slm_blkpt_block+0xe6>
		tok    = cos_sched_sync();
  401288:	e8 73 00 01 00       	call   411300 <cos_sched_sync>
  40128d:	89 c1                	mov    ecx,eax
  40128f:	48 8b 05 2a 0c 1a 00 	mov    rax,QWORD PTR [rip+0x1a0c2a]        # 5a1ec0 <__slm_global>
--
  401296:	48 89 c2             	mov    rdx,rax
  401299:	83 e2 01             	and    edx,0x1
  40129c:	74 da                	je     401278 <slm_blkpt_block+0xa8>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  40129e:	48 89 c6             	mov    rsi,rax
--
  4012a4:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  4012a9:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  4012ad:	e8 ae 25 01 00       	call   413860 <slm_cs_exit_contention>
  4012b2:	85 c0                	test   eax,eax
  4012b4:	75 d2                	jne    401288 <slm_blkpt_block+0xb8>
	return 0;
unlock:
--
		l->next = n;
  4012f4:	48 89 45 c0          	mov    QWORD PTR [rbp-0x40],rax
  4012f8:	f0 48 0f b1 3a       	lock cmpxchg QWORD PTR [rdx],rdi
  4012fd:	0f 94 c0             	sete   al
		if (ps_cas((unsigned long *)&h->head, (unsigned long)n, (unsigned long)l)) break;
  401300:	84 c0                	test   al,al
  401302:	74 ec                	je     4012f0 <slm_blkpt_block+0x120>
	if (!blkpt_epoch_is_higher(ps_load(&m->epoch), pre)) {
  401304:	49 8b 45 08          	mov    rax,QWORD PTR [r13+0x8]
  401308:	48 39 f0             	cmp    rax,rsi
  40130b:	0f 86 8f 00 00 00    	jbe    4013a0 <slm_blkpt_block+0x1d0>
	if (!h->head) return NULL;
  401311:	49 83 7d 10 00       	cmp    QWORD PTR [r13+0x10],0x0
  401316:	74 2b                	je     401343 <slm_blkpt_block+0x173>
		sl = ps_load(&h->head);
  401318:	49 c1 e0 05          	shl    r8,0x5
  40131c:	49 81 c0 00 f9 45 00 	add    r8,0x45f900
  401323:	eb 15                	jmp    40133a <slm_blkpt_block+0x16a>
  401325:	0f 1f 00             	nop    DWORD PTR [rax]
  401328:	48 8b 31             	mov    rsi,QWORD PTR [rcx]
  40132b:	48 89 c8             	mov    rax,rcx
  40132e:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  401333:	0f 94 c0             	sete   al
		if (ps_cas((unsigned long *)&h->head, (unsigned long)sl, (unsigned long)sl->next)) break;
  401336:	84 c0                	test   al,al
  401338:	75 36                	jne    401370 <slm_blkpt_block+0x1a0>
		sl = ps_load(&h->head);
  40133a:	49 8b 48 10          	mov    rcx,QWORD PTR [r8+0x10]
		if (!sl) return NULL;
  40133e:	48 85 c9             	test   rcx,rcx
  401341:	75 e5                	jne    401328 <slm_blkpt_block+0x158>
		assert(stacklist_is_removed(&sl));
  401343:	48 83 7d c0 00       	cmp    QWORD PTR [rbp-0x40],0x0
  401348:	0f 84 1a ff ff ff    	je     401268 <slm_blkpt_block+0x98>
  40134e:	be 5f 00 00 00       	mov    esi,0x5f
  401353:	bf 48 ca 41 00       	mov    edi,0x41ca48
  401358:	e8 73 8d 00 00       	call   40a0d0 <cos_print_str>
  40135d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401364:	00 00 00 00 
--
  401370:	48 c7 01 00 00 00 00 	mov    QWORD PTR [rcx],0x0
			assert(_sl == &sl);
  401377:	48 39 f9             	cmp    rcx,rdi
  40137a:	74 c7                	je     401343 <slm_blkpt_block+0x173>
  40137c:	be 5f 00 00 00       	mov    esi,0x5f
  401381:	bf e8 c9 41 00       	mov    edi,0x41c9e8
  401386:	e8 45 8d 00 00       	call   40a0d0 <cos_print_str>
  40138b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401392:	00 00 00 00 
--
	if (slm_thd_block(current)) {
  4013a0:	48 89 df             	mov    rdi,rbx
  4013a3:	e8 18 25 01 00       	call   4138c0 <slm_thd_block>
{ l->o = 0; }
  4013a8:	49 c7 45 18 00 00 00 	mov    QWORD PTR [r13+0x18],0x0
--
  4013b0:	41 89 c4             	mov    r12d,eax
  4013b3:	85 c0                	test   eax,eax
  4013b5:	74 6c                	je     401423 <slm_blkpt_block+0x253>
		ERR_THROW(0, unlock);
  4013b7:	45 31 e4             	xor    r12d,r12d
  4013ba:	e9 c9 fe ff ff       	jmp    401288 <slm_blkpt_block+0xb8>
  4013bf:	90                   	nop
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
--
  4013c9:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  4013ce:	41 83 e0 01          	and    r8d,0x1
  4013d2:	e8 39 24 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  4013d7:	83 f8 f0             	cmp    eax,0xfffffff0
  4013da:	0f 85 17 fe ff ff    	jne    4011f7 <slm_blkpt_block+0x27>
  4013e0:	be 59 00 00 00       	mov    esi,0x59
  4013e5:	bf c0 c7 41 00       	mov    edi,0x41c7c0
  4013ea:	e8 e1 8c 00 00       	call   40a0d0 <cos_print_str>
  4013ef:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4013f6:	00 00 00 00 
--
  4013fc:	be 59 00 00 00       	mov    esi,0x59
  401401:	bf 60 c7 41 00       	mov    edi,0x41c760
  401406:	e8 c5 8c 00 00       	call   40a0d0 <cos_print_str>
	assert(current);
  40140b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  401418:	41 bc ff ff ff ff    	mov    r12d,0xffffffff
	while (ret != 0) {
  40141e:	e9 65 fe ff ff       	jmp    401288 <slm_blkpt_block+0xb8>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  401423:	e8 38 a4 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(!t)) t = &g->idle_thd;
  401428:	41 bf 40 1f 5a 00    	mov    r15d,0x5a1f40
	tok  = cos_sched_sync();
  40142e:	e8 cd fe 00 00       	call   411300 <cos_sched_sync>
  401433:	41 89 c6             	mov    r14d,eax
  401436:	e8 55 10 01 00       	call   412490 <slm_sched_fprr_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  40143b:	48 85 c0             	test   rax,rax
--
  401449:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  40144c:	83 f8 01             	cmp    eax,0x1
  40144f:	76 1f                	jbe    401470 <slm_blkpt_block+0x2a0>
  401451:	e9 7a 01 00 00       	jmp    4015d0 <slm_blkpt_block+0x400>
  401456:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40145d:	00 00 00 
        __asm__ __volatile__("lock " PS_CAS_STR
  401460:	f0 48 0f b1 15 57 0a 	lock cmpxchg QWORD PTR [rip+0x1a0a57],rdx        # 5a1ec0 <__slm_global>
  401467:	1a 00 
  401469:	0f 94 c0             	sete   al
  40146c:	84 c0                	test   al,al
  40146e:	75 2e                	jne    40149e <slm_blkpt_block+0x2ce>
		tok    = cos_sched_sync();
  401470:	e8 8b fe 00 00       	call   411300 <cos_sched_sync>
  401475:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  40147e:	48 89 c2             	mov    rdx,rax
  401481:	83 e2 01             	and    edx,0x1
  401484:	74 da                	je     401460 <slm_blkpt_block+0x290>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  401486:	48 89 c6             	mov    rsi,rax
--
  40148c:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  401491:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  401495:	e8 c6 23 01 00       	call   413860 <slm_cs_exit_contention>
  40149a:	85 c0                	test   eax,eax
  40149c:	75 d2                	jne    401470 <slm_blkpt_block+0x2a0>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  40149e:	e8 bd a3 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4014a3:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
--
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4014b2:	a8 0b                	test   al,0xb
  4014b4:	75 79                	jne    40152f <slm_blkpt_block+0x35f>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  4014b6:	49 8b 7d 10          	mov    rdi,QWORD PTR [r13+0x10]
  4014ba:	44 89 f1             	mov    ecx,r14d
  4014bd:	4c 89 c2             	mov    rdx,r8
  4014c0:	e8 9b b2 00 00       	call   40c760 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  4014c5:	83 f8 ff             	cmp    eax,0xffffffff
  4014c8:	74 2f                	je     4014f9 <slm_blkpt_block+0x329>
	if (unlikely(ret != 0)) {
  4014ca:	85 c0                	test   eax,eax
  4014cc:	0f 85 aa 00 00 00    	jne    40157c <slm_blkpt_block+0x3ac>
	assert(stacklist_is_removed(&sl));
  4014d2:	48 83 7d c0 00       	cmp    QWORD PTR [rbp-0x40],0x0
  4014d7:	0f 84 d9 fd ff ff    	je     4012b6 <slm_blkpt_block+0xe6>
  4014dd:	be 5f 00 00 00       	mov    esi,0x5f
  4014e2:	bf a8 ca 41 00       	mov    edi,0x41caa8
  4014e7:	e8 e4 8b 00 00       	call   40a0d0 <cos_print_str>
  4014ec:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4014f3:	00 00 00 00 
  4014f7:	0f 0b                	ud2    
	return t != &g->idle_thd && t != &g->sched_thd;
  4014f9:	49 81 fd c8 1e 5a 00 	cmp    r13,0x5a1ec8
  401500:	0f 84 0c 01 00 00    	je     401612 <slm_blkpt_block+0x442>
  401506:	49 81 fd 40 1f 5a 00 	cmp    r13,0x5a1f40
  40150d:	0f 84 ff 00 00 00    	je     401612 <slm_blkpt_block+0x442>
  401513:	be 61 00 00 00       	mov    esi,0x61
  401518:	bf b0 c8 41 00       	mov    edi,0x41c8b0
  40151d:	e8 ae 8b 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EPERM);
  401522:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40152f:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  401532:	49 81 fd c8 1e 5a 00 	cmp    r13,0x5a1ec8
  401539:	0f 84 ad 00 00 00    	je     4015ec <slm_blkpt_block+0x41c>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  40153f:	a8 02                	test   al,0x2
  401541:	0f 85 b0 00 00 00    	jne    4015f7 <slm_blkpt_block+0x427>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  401547:	49 89 c8             	mov    r8,rcx
  40154a:	a8 01                	test   al,0x1
  40154c:	0f 84 64 ff ff ff    	je     4014b6 <slm_blkpt_block+0x2e6>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  401552:	4d 8b 55 08          	mov    r10,QWORD PTR [r13+0x8]
--
  401560:	4c 8b 05 81 09 1a 00 	mov    r8,QWORD PTR [rip+0x1a0981]        # 5a1ee8 <__slm_global+0x28>
  401567:	4c 89 d6             	mov    rsi,r10
  40156a:	e8 b1 fd 00 00       	call   411320 <cos_switch>
	if (unlikely(ret != 0)) {
  40156f:	85 c0                	test   eax,eax
  401571:	0f 84 5b ff ff ff    	je     4014d2 <slm_blkpt_block+0x302>
		assert(ret != -EPERM);
  401577:	83 f8 ff             	cmp    eax,0xffffffff
  40157a:	74 97                	je     401513 <slm_blkpt_block+0x343>
		assert(ret != -EINVAL);
  40157c:	83 f8 ea             	cmp    eax,0xffffffea
  40157f:	0f 84 ee 00 00 00    	je     401673 <slm_blkpt_block+0x4a3>
		if (ret == -EBUSY) return ret;
  401585:	83 f8 f0             	cmp    eax,0xfffffff0
  401588:	0f 84 44 ff ff ff    	je     4014d2 <slm_blkpt_block+0x302>
		assert(ret == -EAGAIN);
  40158e:	83 f8 f5             	cmp    eax,0xfffffff5
  401591:	0f 85 c0 00 00 00    	jne    401657 <slm_blkpt_block+0x487>
		tok    = cos_sched_sync();
  401597:	e8 64 fd 00 00       	call   411300 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  40159c:	48 8b 35 1d 09 1a 00 	mov    rsi,QWORD PTR [rip+0x1a091d]        # 5a1ec0 <__slm_global>
--
  4015a6:	48 89 f1             	mov    rcx,rsi
  4015a9:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  4015ad:	0f 85 82 00 00 00    	jne    401635 <slm_blkpt_block+0x465>
  4015b3:	48 89 f0             	mov    rax,rsi
  4015b6:	f0 48 0f b1 1d 01 09 	lock cmpxchg QWORD PTR [rip+0x1a0901],rbx        # 5a1ec0 <__slm_global>
  4015bd:	1a 00 
  4015bf:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4015c2:	84 c0                	test   al,al
  4015c4:	0f 85 64 fe ff ff    	jne    40142e <slm_blkpt_block+0x25e>
  4015ca:	eb cb                	jmp    401597 <slm_blkpt_block+0x3c7>
  4015cc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  4015d0:	be 61 00 00 00       	mov    esi,0x61
  4015d5:	bf 48 c8 41 00       	mov    edi,0x41c848
  4015da:	e8 f1 8a 00 00       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  4015df:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
			timeout = TCAP_TIME_NIL;
  4015f0:	31 c9                	xor    ecx,ecx
  4015f2:	e9 48 ff ff ff       	jmp    40153f <slm_blkpt_block+0x36f>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  4015f7:	49 8b 7d 28          	mov    rdi,QWORD PTR [r13+0x28]
--
  401602:	44 89 f1             	mov    ecx,r14d
  401605:	4c 89 c6             	mov    rsi,r8
  401608:	e8 83 fd 00 00       	call   411390 <cos_sched_asnd>
  40160d:	e9 5d ff ff ff       	jmp    40156f <slm_blkpt_block+0x39f>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  401612:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]
--
  401622:	48 8b 3d af 08 1a 00 	mov    rdi,QWORD PTR [rip+0x1a08af]        # 5a1ed8 <__slm_global+0x18>
  401629:	31 f6                	xor    esi,esi
  40162b:	e8 f0 fc 00 00       	call   411320 <cos_switch>
  401630:	e9 3a ff ff ff       	jmp    40156f <slm_blkpt_block+0x39f>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  401635:	41 89 f0             	mov    r8d,esi
--
  40163b:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  401640:	41 83 e0 01          	and    r8d,0x1
  401644:	e8 c7 21 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  401649:	83 f8 f0             	cmp    eax,0xfffffff0
  40164c:	0f 85 45 ff ff ff    	jne    401597 <slm_blkpt_block+0x3c7>
  401652:	e9 89 fd ff ff       	jmp    4013e0 <slm_blkpt_block+0x210>
  401657:	be 61 00 00 00       	mov    esi,0x61
  40165c:	bf 80 c9 41 00       	mov    edi,0x41c980
  401661:	e8 6a 8a 00 00       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  401666:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  401673:	be 61 00 00 00       	mov    esi,0x61
  401678:	bf 18 c9 41 00       	mov    edi,0x41c918
  40167d:	e8 4e 8a 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  401682:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  4016d0:	f3 0f 1e fa          	endbr64 
  4016d4:	e9 e7 13 01 00       	jmp    412ac0 <slm_timer_quantum_expire>
  4016d9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

00000000004016e0 <slm_timer_thd_init>:
  4016e0:	f3 0f 1e fa          	endbr64 
  4016e4:	e9 77 16 01 00       	jmp    412d60 <slm_timer_quantum_thd_init>
  4016e9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

00000000004016f0 <slm_timer_thd_deinit>:
  4016f0:	f3 0f 1e fa          	endbr64 
  4016f4:	e9 87 16 01 00       	jmp    412d80 <slm_timer_quantum_thd_deinit>
  4016f9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401700 <slm_timer_add>:
  401700:	f3 0f 1e fa          	endbr64 
  401704:	e9 47 15 01 00       	jmp    412c50 <slm_timer_quantum_add>
  401709:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401710 <slm_timer_cancel>:
  401710:	f3 0f 1e fa          	endbr64 
  401714:	e9 c7 15 01 00       	jmp    412ce0 <slm_timer_quantum_cancel>
  401719:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401720 <slm_timer_init>:
  401720:	f3 0f 1e fa          	endbr64 
  401724:	e9 67 16 01 00       	jmp    412d90 <slm_timer_quantum_init>
  401729:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401730 <slm_sched_init>:
  401730:	f3 0f 1e fa          	endbr64 
  401734:	e9 47 10 01 00       	jmp    412780 <slm_sched_fprr_init>
  401739:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401740 <slm_sched_thd_init>:
  401740:	f3 0f 1e fa          	endbr64 
  401744:	e9 a7 0e 01 00       	jmp    4125f0 <slm_sched_fprr_thd_init>
  401749:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401750 <slm_sched_thd_deinit>:
  401750:	f3 0f 1e fa          	endbr64 
  401754:	e9 c7 0e 01 00       	jmp    412620 <slm_sched_fprr_thd_deinit>
  401759:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401760 <slm_sched_thd_update>:
  401760:	f3 0f 1e fa          	endbr64 
  401764:	e9 e7 0e 01 00       	jmp    412650 <slm_sched_fprr_thd_update>
  401769:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401770 <slm_sched_block>:
  401770:	f3 0f 1e fa          	endbr64 
  401774:	e9 77 0d 01 00       	jmp    4124f0 <slm_sched_fprr_block>
  401779:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401780 <slm_sched_wakeup>:
  401780:	f3 0f 1e fa          	endbr64 
  401784:	e9 97 0d 01 00       	jmp    412520 <slm_sched_fprr_wakeup>
  401789:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401790 <slm_sched_yield>:
  401790:	f3 0f 1e fa          	endbr64 
  401794:	e9 f7 0d 01 00       	jmp    412590 <slm_sched_fprr_yield>
  401799:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

00000000004017a0 <slm_sched_schedule>:
  4017a0:	f3 0f 1e fa          	endbr64 
  4017a4:	e9 e7 0c 01 00       	jmp    412490 <slm_sched_fprr_schedule>
  4017a9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

00000000004017b0 <slm_sched_execution>:
  4017b0:	f3 0f 1e fa          	endbr64 
  4017b4:	e9 c7 0c 01 00       	jmp    412480 <slm_sched_fprr_execution>
  4017b9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

--
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  4017c4:	85 ff                	test   edi,edi
  4017c6:	74 38                	je     401800 <slm_thd_lookup+0x40>
  4017c8:	83 ef 01             	sub    edi,0x1
  4017cb:	83 ff 18             	cmp    edi,0x18
  4017ce:	77 30                	ja     401800 <slm_thd_lookup+0x40>
  4017d0:	48 8b 14 fd 00 e7 45 	mov    rdx,QWORD PTR [rdi*8+0x45e700]
--
  4017d8:	31 c0                	xor    eax,eax
  4017da:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  4017e1:	74 1f                	je     401802 <slm_thd_lookup+0x42>
  4017e3:	83 e2 01             	and    edx,0x1
  4017e6:	75 1a                	jne    401802 <slm_thd_lookup+0x42>
  4017e8:	48 8d 04 bf          	lea    rax,[rdi+rdi*4]
  4017ec:	48 8d 04 47          	lea    rax,[rdi+rax*2]
--
  401810:	f3 0f 1e fa          	endbr64 
  401814:	48 8d 87 c8 00 00 00 	lea    rax,[rdi+0xc8]
  40181b:	48 39 c6             	cmp    rsi,rax
  40181e:	72 32                	jb     401852 <ss_thd_intern_is_allocated+0x42>
  401820:	48 8d 97 48 11 00 00 	lea    rdx,[rdi+0x1148]
  401827:	48 39 d6             	cmp    rsi,rdx
  40182a:	77 26                	ja     401852 <ss_thd_intern_is_allocated+0x42>
  40182c:	48 29 c6             	sub    rsi,rax
--
  401858:	bf 08 cb 41 00       	mov    edi,0x41cb08
  40185d:	48 89 e5             	mov    rbp,rsp
  401860:	e8 6b 88 00 00       	call   40a0d0 <cos_print_str>
  401865:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40186c:	00 00 00 00 
--
0000000000401880 <ss_thd_is_allocated>:
  401880:	f3 0f 1e fa          	endbr64 
  401884:	48 81 ff 48 f8 45 00 	cmp    rdi,0x45f848
  40188b:	77 37                	ja     4018c4 <ss_thd_is_allocated+0x44>
  40188d:	48 81 ff c8 e7 45 00 	cmp    rdi,0x45e7c8
  401894:	72 2e                	jb     4018c4 <ss_thd_is_allocated+0x44>
  401896:	48 81 ef c8 e7 45 00 	sub    rdi,0x45e7c8
--
  4018ca:	bf 08 cb 41 00       	mov    edi,0x41cb08
  4018cf:	48 89 e5             	mov    rbp,rsp
  4018d2:	e8 f9 87 00 00       	call   40a0d0 <cos_print_str>
  4018d7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4018de:	00 00 00 00 
--
  4018f0:	f3 0f 1e fa          	endbr64 
  4018f4:	85 ff                	test   edi,edi
  4018f6:	74 38                	je     401930 <slm_thd_static_cm_lookup+0x40>
  4018f8:	83 ef 01             	sub    edi,0x1
  4018fb:	83 ff 18             	cmp    edi,0x18
  4018fe:	77 30                	ja     401930 <slm_thd_static_cm_lookup+0x40>
  401900:	48 8b 14 fd 00 e7 45 	mov    rdx,QWORD PTR [rdi*8+0x45e700]
--
  401908:	31 c0                	xor    eax,eax
  40190a:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  401911:	74 1f                	je     401932 <slm_thd_static_cm_lookup+0x42>
  401913:	83 e2 01             	and    edx,0x1
  401916:	75 1a                	jne    401932 <slm_thd_static_cm_lookup+0x42>
  401918:	48 8d 04 bf          	lea    rax,[rdi+rdi*4]
  40191c:	48 8d 04 47          	lea    rax,[rdi+rax*2]
--
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  401954:	48 85 c0             	test   rax,rax
  401957:	74 3f                	je     401998 <slm_thd_current_extern+0x58>
  401959:	83 e8 01             	sub    eax,0x1
  40195c:	83 f8 18             	cmp    eax,0x18
  40195f:	77 37                	ja     401998 <slm_thd_current_extern+0x58>
  401961:	48 8b 14 c5 00 e7 45 	mov    rdx,QWORD PTR [rax*8+0x45e700]
--
  401969:	45 31 c0             	xor    r8d,r8d
  40196c:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  401973:	74 18                	je     40198d <slm_thd_current_extern+0x4d>
  401975:	83 e2 01             	and    edx,0x1
  401978:	75 13                	jne    40198d <slm_thd_current_extern+0x4d>
  40197a:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  40197e:	4c 8d 04 50          	lea    r8,[rax+rdx*2]
--
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  4019cb:	85 f6                	test   esi,esi
  4019cd:	0f 84 85 00 00 00    	je     401a58 <slm_thd_mem_alloc+0xa8>
  4019d3:	49 89 d2             	mov    r10,rdx
  4019d6:	8d 56 ff             	lea    edx,[rsi-0x1]
  4019d9:	83 fa 18             	cmp    edx,0x18
  4019dc:	77 7a                	ja     401a58 <slm_thd_mem_alloc+0xa8>
	if (*state != SS_STATE_FREE ||
  4019de:	48 83 3c d5 00 e7 45 	cmp    QWORD PTR [rdx*8+0x45e700],0x0
  4019e5:	00 00 
  4019e7:	75 6f                	jne    401a58 <slm_thd_mem_alloc+0xa8>
  4019e9:	31 db                	xor    ebx,ebx
  4019eb:	49 89 c9             	mov    r9,rcx
  4019ee:	b9 01 00 00 00       	mov    ecx,0x1
  4019f3:	48 89 d8             	mov    rax,rbx
  4019f6:	f0 48 0f b1 0c d5 00 	lock cmpxchg QWORD PTR [rdx*8+0x45e700],rcx
  4019fd:	e7 45 00 
  401a00:	0f 94 c0             	sete   al
  401a03:	84 c0                	test   al,al
  401a05:	74 51                	je     401a58 <slm_thd_mem_alloc+0xa8>
  401a07:	48 8d 04 92          	lea    rax,[rdx+rdx*4]
  401a0b:	49 89 f8             	mov    r8,rdi
--
	assert(_cap != 0 && _tid != 0);
  401a2b:	4d 85 c0             	test   r8,r8
  401a2e:	74 44                	je     401a74 <slm_thd_mem_alloc+0xc4>
	t->resources = (struct slm_resources_thd) {
  401a30:	48 8b 05 09 56 02 00 	mov    rax,QWORD PTR [rip+0x25609]        # 427040 <__cosrt_comp_info+0x40>
--
  401a58:	be 23 00 00 00       	mov    esi,0x23
  401a5d:	bf 30 cb 41 00       	mov    edi,0x41cb30
  401a62:	e8 69 86 00 00       	call   40a0d0 <cos_print_str>
	if (!t) assert(0);
  401a67:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  401a74:	be 23 00 00 00       	mov    esi,0x23
  401a79:	bf 58 cb 41 00       	mov    edi,0x41cb58
  401a7e:	e8 4d 86 00 00       	call   40a0d0 <cos_print_str>
	assert(_cap != 0 && _tid != 0);
  401a83:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  401a95:	48 89 e5             	mov    rbp,rsp
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  401a98:	48 81 ff c8 e7 45 00 	cmp    rdi,0x45e7c8
  401a9f:	72 50                	jb     401af1 <slm_thd_mem_activate+0x61>
  401aa1:	48 81 ff 48 f8 45 00 	cmp    rdi,0x45f848
  401aa8:	77 47                	ja     401af1 <slm_thd_mem_activate+0x61>
  401aaa:	48 81 ef c8 e7 45 00 	sub    rdi,0x45e7c8
--
  401ace:	00 
	assert((*state & 1) == SS_STATE_CONS);
  401acf:	48 83 fa ff          	cmp    rdx,0xffffffffffffffff
  401ad3:	75 38                	jne    401b0d <slm_thd_mem_activate+0x7d>
	*state &= ~SS_STATE_CONS;
  401ad5:	48 c7 04 c5 00 e7 45 	mov    QWORD PTR [rax*8+0x45e700],0xfffffffffffffffe
--
  401ae1:	0f ae f0             	mfence 
	assert(*state != 0);
  401ae4:	48 83 3c c5 00 e7 45 	cmp    QWORD PTR [rax*8+0x45e700],0x0
  401aeb:	00 00 
  401aed:	74 3a                	je     401b29 <slm_thd_mem_activate+0x99>
void slm_thd_mem_activate(struct slm_thd_container *t) { ss_thd_activate(t); }
  401aef:	5d                   	pop    rbp
--
  401af1:	be 23 00 00 00       	mov    esi,0x23
  401af6:	bf 08 cb 41 00       	mov    edi,0x41cb08
  401afb:	e8 d0 85 00 00       	call   40a0d0 <cos_print_str>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  401b00:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  401b0d:	be 61 00 00 00       	mov    esi,0x61
  401b12:	bf 80 cb 41 00       	mov    edi,0x41cb80
  401b17:	e8 b4 85 00 00       	call   40a0d0 <cos_print_str>
	assert((*state & 1) == SS_STATE_CONS);
  401b1c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  401b29:	be 61 00 00 00       	mov    esi,0x61
  401b2e:	bf e8 cb 41 00       	mov    edi,0x41cbe8
  401b33:	e8 98 85 00 00       	call   40a0d0 <cos_print_str>
	assert(*state != 0);
  401b38:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  401b84:	c7 45 fc 00 00 00 00 	mov    DWORD PTR [rbp-0x4],0x0
	struct slm_thd *t = thd_alloc_in(cos_inv_token(), idx, &p, 0);
  401b8b:	e8 d0 31 00 00       	call   404d60 <thd_alloc_in>
	if (!t) return 0;
  401b90:	48 85 c0             	test   rax,rax
  401b93:	74 0b                	je     401ba0 <sched_thd_create_closure+0x40>
	return t->tid;
  401b95:	48 8b 40 18          	mov    rax,QWORD PTR [rax+0x18]
--
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  401bbc:	85 ff                	test   edi,edi
  401bbe:	74 38                	je     401bf8 <sched_thd_param_set+0x48>
  401bc0:	83 ef 01             	sub    edi,0x1
  401bc3:	83 ff 18             	cmp    edi,0x18
  401bc6:	77 30                	ja     401bf8 <sched_thd_param_set+0x48>
  401bc8:	48 8b 04 fd 00 e7 45 	mov    rax,QWORD PTR [rdi*8+0x45e700]
--
	return ((state & ~1) != 0) && ((state & 1) == SS_STATE_ALLOC);
  401bd0:	48 a9 fe ff ff ff    	test   rax,0xfffffffffffffffe
  401bd6:	74 20                	je     401bf8 <sched_thd_param_set+0x48>
  401bd8:	a8 01                	test   al,0x1
  401bda:	75 1c                	jne    401bf8 <sched_thd_param_set+0x48>
	return &ss_thd_get(id)->thd;
  401bdc:	48 8d 04 bf          	lea    rax,[rdi+rdi*4]
--
  401be8:	48 81 c7 c8 e7 45 00 	add    rdi,0x45e7c8
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  401bef:	e9 5c 0a 01 00       	jmp    412650 <slm_sched_fprr_thd_update>
  401bf4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
}
--
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  401c35:	48 85 c0             	test   rax,rax
  401c38:	0f 84 22 02 00 00    	je     401e60 <sched_thd_exit+0x250>
  401c3e:	83 e8 01             	sub    eax,0x1
  401c41:	83 f8 18             	cmp    eax,0x18
  401c44:	0f 87 16 02 00 00    	ja     401e60 <sched_thd_exit+0x250>
  401c4a:	48 8b 14 c5 00 e7 45 	mov    rdx,QWORD PTR [rax*8+0x45e700]
  401c51:	00 
  401c52:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  401c59:	0f 84 01 02 00 00    	je     401e60 <sched_thd_exit+0x250>
  401c5f:	80 e2 01             	and    dl,0x1
  401c62:	0f 85 f8 01 00 00    	jne    401e60 <sched_thd_exit+0x250>
  401c68:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  401c6c:	4c 8d 34 50          	lea    r14,[rax+rdx*2]
--
  401c74:	49 81 c6 c8 e7 45 00 	add    r14,0x45e7c8
		tok    = cos_sched_sync();
  401c7b:	e8 80 f6 00 00       	call   411300 <cos_sched_sync>
  401c80:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  401c8a:	48 89 c1             	mov    rcx,rax
  401c8d:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  401c91:	0f 85 03 02 00 00    	jne    401e9a <sched_thd_exit+0x28a>
        __asm__ __volatile__("lock " PS_CAS_STR
  401c97:	f0 4c 0f b1 35 20 02 	lock cmpxchg QWORD PTR [rip+0x1a0220],r14        # 5a1ec0 <__slm_global>
  401c9e:	1a 00 
  401ca0:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  401ca3:	84 c0                	test   al,al
  401ca5:	74 d4                	je     401c7b <sched_thd_exit+0x6b>
	slm_thd_deinit(current);
  401ca7:	4c 89 f7             	mov    rdi,r14
--
  401cb0:	41 bf 40 1f 5a 00    	mov    r15d,0x5a1f40
	slm_thd_deinit(current);
  401cb6:	e8 25 1b 01 00       	call   4137e0 <slm_thd_deinit>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  401cbb:	e8 a0 9b 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	tok  = cos_sched_sync();
  401cc0:	e8 3b f6 00 00       	call   411300 <cos_sched_sync>
  401cc5:	41 89 c4             	mov    r12d,eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  401cc8:	e8 c3 07 01 00       	call   412490 <slm_sched_fprr_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  401ccd:	48 85 c0             	test   rax,rax
--
  401cda:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  401cdd:	83 f8 01             	cmp    eax,0x1
  401ce0:	76 1e                	jbe    401d00 <sched_thd_exit+0xf0>
  401ce2:	e9 95 00 00 00       	jmp    401d7c <sched_thd_exit+0x16c>
  401ce7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  401cee:	00 00 
  401cf0:	f0 48 0f b1 15 c7 01 	lock cmpxchg QWORD PTR [rip+0x1a01c7],rdx        # 5a1ec0 <__slm_global>
  401cf7:	1a 00 
  401cf9:	0f 94 c0             	sete   al
	while (ret != 0) {
  401cfc:	84 c0                	test   al,al
  401cfe:	75 2e                	jne    401d2e <sched_thd_exit+0x11e>
		tok    = cos_sched_sync();
  401d00:	e8 fb f5 00 00       	call   411300 <cos_sched_sync>
  401d05:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  401d0e:	48 89 c2             	mov    rdx,rax
  401d11:	83 e2 01             	and    edx,0x1
  401d14:	74 da                	je     401cf0 <sched_thd_exit+0xe0>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  401d16:	48 89 c6             	mov    rsi,rax
--
  401d1c:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  401d21:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  401d25:	e8 36 1b 01 00       	call   413860 <slm_cs_exit_contention>
  401d2a:	85 c0                	test   eax,eax
  401d2c:	75 d2                	jne    401d00 <sched_thd_exit+0xf0>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  401d2e:	e8 2d 9b 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  401d33:	8b 03                	mov    eax,DWORD PTR [rbx]
--
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  401d40:	a8 0b                	test   al,0xb
  401d42:	75 54                	jne    401d98 <sched_thd_exit+0x188>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  401d44:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  401d48:	44 89 e1             	mov    ecx,r12d
  401d4b:	4c 89 c2             	mov    rdx,r8
  401d4e:	e8 0d aa 00 00       	call   40c760 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  401d53:	83 f8 ff             	cmp    eax,0xffffffff
  401d56:	0f 84 ce 00 00 00    	je     401e2a <sched_thd_exit+0x21a>
	if (unlikely(ret != 0)) {
  401d5c:	85 c0                	test   eax,eax
  401d5e:	75 7d                	jne    401ddd <sched_thd_exit+0x1cd>
  401d60:	be 11 00 00 00       	mov    esi,0x11
  401d65:	bf 4a cc 41 00       	mov    edi,0x41cc4a
  401d6a:	e8 61 83 00 00       	call   40a0d0 <cos_print_str>
	BUG();
  401d6f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  401d7c:	be 61 00 00 00       	mov    esi,0x61
  401d81:	bf 48 c8 41 00       	mov    edi,0x41c848
  401d86:	e8 45 83 00 00       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  401d8b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  401d98:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  401d9b:	48 81 fb c8 1e 5a 00 	cmp    rbx,0x5a1ec8
  401da2:	0f 84 e7 00 00 00    	je     401e8f <sched_thd_exit+0x27f>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  401da8:	a8 02                	test   al,0x2
  401daa:	0f 85 26 01 00 00    	jne    401ed6 <sched_thd_exit+0x2c6>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  401db0:	49 89 c8             	mov    r8,rcx
  401db3:	a8 01                	test   al,0x1
  401db5:	74 8d                	je     401d44 <sched_thd_exit+0x134>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  401db7:	4c 8b 53 08          	mov    r10,QWORD PTR [rbx+0x8]
--
  401dc5:	4c 8b 05 1c 01 1a 00 	mov    r8,QWORD PTR [rip+0x1a011c]        # 5a1ee8 <__slm_global+0x28>
  401dcc:	4c 89 d6             	mov    rsi,r10
  401dcf:	e8 4c f5 00 00       	call   411320 <cos_switch>
	if (unlikely(ret != 0)) {
  401dd4:	85 c0                	test   eax,eax
  401dd6:	74 88                	je     401d60 <sched_thd_exit+0x150>
		assert(ret != -EPERM);
  401dd8:	83 f8 ff             	cmp    eax,0xffffffff
  401ddb:	74 67                	je     401e44 <sched_thd_exit+0x234>
		assert(ret != -EINVAL);
  401ddd:	83 f8 ea             	cmp    eax,0xffffffea
  401de0:	0f 84 2e 01 00 00    	je     401f14 <sched_thd_exit+0x304>
		if (ret == -EBUSY) return ret;
  401de6:	83 f8 f0             	cmp    eax,0xfffffff0
  401de9:	0f 84 91 00 00 00    	je     401e80 <sched_thd_exit+0x270>
		assert(ret == -EAGAIN);
  401def:	83 f8 f5             	cmp    eax,0xfffffff5
  401df2:	0f 85 5d 01 00 00    	jne    401f55 <sched_thd_exit+0x345>
		tok    = cos_sched_sync();
  401df8:	e8 03 f5 00 00       	call   411300 <cos_sched_sync>
  401dfd:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  401e07:	48 89 c1             	mov    rcx,rax
  401e0a:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  401e0e:	0f 85 1c 01 00 00    	jne    401f30 <sched_thd_exit+0x320>
  401e14:	f0 4c 0f b1 35 a3 00 	lock cmpxchg QWORD PTR [rip+0x1a00a3],r14        # 5a1ec0 <__slm_global>
  401e1b:	1a 00 
  401e1d:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  401e20:	84 c0                	test   al,al
  401e22:	0f 85 98 fe ff ff    	jne    401cc0 <sched_thd_exit+0xb0>
  401e28:	eb ce                	jmp    401df8 <sched_thd_exit+0x1e8>
	return t != &g->idle_thd && t != &g->sched_thd;
  401e2a:	48 81 fb 40 1f 5a 00 	cmp    rbx,0x5a1f40
  401e31:	0f 84 ba 00 00 00    	je     401ef1 <sched_thd_exit+0x2e1>
  401e37:	48 81 fb c8 1e 5a 00 	cmp    rbx,0x5a1ec8
  401e3e:	0f 84 ad 00 00 00    	je     401ef1 <sched_thd_exit+0x2e1>
  401e44:	be 61 00 00 00       	mov    esi,0x61
  401e49:	bf b0 c8 41 00       	mov    edi,0x41c8b0
  401e4e:	e8 7d 82 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EPERM);
  401e53:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  401e60:	be 59 00 00 00       	mov    esi,0x59
  401e65:	bf 60 c7 41 00       	mov    edi,0x41c760
  401e6a:	e8 61 82 00 00       	call   40a0d0 <cos_print_str>
	assert(current);
  401e6f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	for (i = 0; slm_cs_exit_reschedule(current, SLM_CS_NONE) && i < 16; i++) ;
  401e80:	41 83 ed 01          	sub    r13d,0x1
  401e84:	0f 85 31 fe ff ff    	jne    401cbb <sched_thd_exit+0xab>
  401e8a:	e9 d1 fe ff ff       	jmp    401d60 <sched_thd_exit+0x150>
			prio    = curr->priority;
  401e8f:	49 8b 76 30          	mov    rsi,QWORD PTR [r14+0x30]
			timeout = TCAP_TIME_NIL;
  401e93:	31 c9                	xor    ecx,ecx
  401e95:	e9 0e ff ff ff       	jmp    401da8 <sched_thd_exit+0x198>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  401e9a:	41 89 c0             	mov    r8d,eax
--
  401ea3:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  401ea8:	41 83 e0 01          	and    r8d,0x1
  401eac:	e8 5f 19 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  401eb1:	83 f8 f0             	cmp    eax,0xfffffff0
  401eb4:	0f 85 c1 fd ff ff    	jne    401c7b <sched_thd_exit+0x6b>
  401eba:	be 59 00 00 00       	mov    esi,0x59
  401ebf:	bf c0 c7 41 00       	mov    edi,0x41c7c0
  401ec4:	e8 07 82 00 00       	call   40a0d0 <cos_print_str>
  401ec9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401ed0:	00 00 00 00 
--
  401ee1:	44 89 e1             	mov    ecx,r12d
  401ee4:	4c 89 c6             	mov    rsi,r8
  401ee7:	e8 a4 f4 00 00       	call   411390 <cos_sched_asnd>
  401eec:	e9 e3 fe ff ff       	jmp    401dd4 <sched_thd_exit+0x1c4>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  401ef1:	49 8b 56 30          	mov    rdx,QWORD PTR [r14+0x30]
--
  401f01:	48 8b 3d d0 ff 19 00 	mov    rdi,QWORD PTR [rip+0x19ffd0]        # 5a1ed8 <__slm_global+0x18>
  401f08:	31 f6                	xor    esi,esi
  401f0a:	e8 11 f4 00 00       	call   411320 <cos_switch>
  401f0f:	e9 c0 fe ff ff       	jmp    401dd4 <sched_thd_exit+0x1c4>
  401f14:	be 61 00 00 00       	mov    esi,0x61
  401f19:	bf 18 c9 41 00       	mov    edi,0x41c918
  401f1e:	e8 ad 81 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  401f23:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  401f39:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  401f3e:	41 83 e0 01          	and    r8d,0x1
  401f42:	e8 c9 18 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  401f47:	83 f8 f0             	cmp    eax,0xfffffff0
  401f4a:	0f 85 a8 fe ff ff    	jne    401df8 <sched_thd_exit+0x1e8>
  401f50:	e9 65 ff ff ff       	jmp    401eba <sched_thd_exit+0x2aa>
  401f55:	be 61 00 00 00       	mov    esi,0x61
  401f5a:	bf 80 c9 41 00       	mov    edi,0x41c980
  401f5f:	e8 6c 81 00 00       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  401f64:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  401f9f:	48 85 c0             	test   rax,rax
  401fa2:	0f 84 b0 01 00 00    	je     402158 <sched_thd_yield_to+0x1d8>
  401fa8:	83 e8 01             	sub    eax,0x1
  401fab:	83 f8 18             	cmp    eax,0x18
  401fae:	0f 87 a4 01 00 00    	ja     402158 <sched_thd_yield_to+0x1d8>
  401fb4:	48 8b 14 c5 00 e7 45 	mov    rdx,QWORD PTR [rax*8+0x45e700]
--
  401fbc:	45 31 e4             	xor    r12d,r12d
  401fbf:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  401fc6:	0f 85 44 01 00 00    	jne    402110 <sched_thd_yield_to+0x190>
  401fcc:	85 ff                	test   edi,edi
  401fce:	0f 84 64 01 00 00    	je     402138 <sched_thd_yield_to+0x1b8>
  401fd4:	83 ef 01             	sub    edi,0x1
  401fd7:	83 ff 18             	cmp    edi,0x18
  401fda:	0f 87 58 01 00 00    	ja     402138 <sched_thd_yield_to+0x1b8>
  401fe0:	89 f8                	mov    eax,edi
--
  401fe9:	00 
  401fea:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  401ff1:	0f 84 41 01 00 00    	je     402138 <sched_thd_yield_to+0x1b8>
  401ff7:	83 e2 01             	and    edx,0x1
  401ffa:	0f 85 38 01 00 00    	jne    402138 <sched_thd_yield_to+0x1b8>
	return &ss_thd_get(id)->thd;
  402000:	48 8d 14 80          	lea    rdx,[rax+rax*4]
--
	assert(current);
  402013:	4d 85 e4             	test   r12,r12
  402016:	0f 84 80 01 00 00    	je     40219c <sched_thd_yield_to+0x21c>
		tok    = cos_sched_sync();
  40201c:	e8 df f2 00 00       	call   411300 <cos_sched_sync>
  402021:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  40202b:	48 89 c1             	mov    rcx,rax
  40202e:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  402032:	0f 85 28 01 00 00    	jne    402160 <sched_thd_yield_to+0x1e0>
  402038:	f0 4c 0f b1 25 7f fe 	lock cmpxchg QWORD PTR [rip+0x19fe7f],r12        # 5a1ec0 <__slm_global>
  40203f:	19 00 
  402041:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  402044:	84 c0                	test   al,al
  402046:	74 d4                	je     40201c <sched_thd_yield_to+0x9c>
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  402048:	4c 89 ee             	mov    rsi,r13
--
	if (unlikely(!t)) t = &g->idle_thd;
  40204e:	41 be 40 1f 5a 00    	mov    r14d,0x5a1f40
  402054:	e8 37 05 01 00       	call   412590 <slm_sched_fprr_yield>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  402059:	e8 02 98 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	tok  = cos_sched_sync();
  40205e:	e8 9d f2 00 00       	call   411300 <cos_sched_sync>
  402063:	41 89 c5             	mov    r13d,eax
  402066:	e8 25 04 01 00       	call   412490 <slm_sched_fprr_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  40206b:	48 85 c0             	test   rax,rax
--
  402078:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  40207b:	83 f8 01             	cmp    eax,0x1
  40207e:	76 18                	jbe    402098 <sched_thd_yield_to+0x118>
  402080:	e9 33 01 00 00       	jmp    4021b8 <sched_thd_yield_to+0x238>
  402085:	0f 1f 00             	nop    DWORD PTR [rax]
  402088:	f0 48 0f b1 15 2f fe 	lock cmpxchg QWORD PTR [rip+0x19fe2f],rdx        # 5a1ec0 <__slm_global>
  40208f:	19 00 
  402091:	0f 94 c0             	sete   al
	while (ret != 0) {
  402094:	84 c0                	test   al,al
  402096:	75 2e                	jne    4020c6 <sched_thd_yield_to+0x146>
		tok    = cos_sched_sync();
  402098:	e8 63 f2 00 00       	call   411300 <cos_sched_sync>
  40209d:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  4020a6:	48 89 c2             	mov    rdx,rax
  4020a9:	83 e2 01             	and    edx,0x1
  4020ac:	74 da                	je     402088 <sched_thd_yield_to+0x108>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  4020ae:	48 89 c6             	mov    rsi,rax
--
  4020b4:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  4020b9:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  4020bd:	e8 9e 17 01 00       	call   413860 <slm_cs_exit_contention>
  4020c2:	85 c0                	test   eax,eax
  4020c4:	75 d2                	jne    402098 <sched_thd_yield_to+0x118>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  4020c6:	e8 95 97 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4020cb:	8b 03                	mov    eax,DWORD PTR [rbx]
--
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4020d8:	a8 0b                	test   al,0xb
  4020da:	0f 85 f4 00 00 00    	jne    4021d4 <sched_thd_yield_to+0x254>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  4020e0:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  4020e4:	44 89 e9             	mov    ecx,r13d
  4020e7:	4c 89 c2             	mov    rdx,r8
  4020ea:	e8 71 a6 00 00       	call   40c760 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  4020ef:	83 f8 ff             	cmp    eax,0xffffffff
  4020f2:	0f 84 1e 01 00 00    	je     402216 <sched_thd_yield_to+0x296>
	if (unlikely(ret != 0)) {
  4020f8:	85 c0                	test   eax,eax
  4020fa:	0f 85 70 01 00 00    	jne    402270 <sched_thd_yield_to+0x2f0>
  402100:	31 c0                	xor    eax,eax
}
--
  40210b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  402110:	83 e2 01             	and    edx,0x1
  402113:	0f 85 b3 fe ff ff    	jne    401fcc <sched_thd_yield_to+0x4c>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  402119:	48 8d 14 80          	lea    rdx,[rax+rax*4]
--
  402125:	49 81 c4 c8 e7 45 00 	add    r12,0x45e7c8
  40212c:	85 ff                	test   edi,edi
  40212e:	0f 85 a0 fe ff ff    	jne    401fd4 <sched_thd_yield_to+0x54>
  402134:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  402138:	be 24 00 00 00       	mov    esi,0x24
  40213d:	bf 60 cc 41 00       	mov    edi,0x41cc60
  402142:	e8 89 7f 00 00       	call   40a0d0 <cos_print_str>
	assert(to);
  402147:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  402158:	45 31 e4             	xor    r12d,r12d
  40215b:	e9 6c fe ff ff       	jmp    401fcc <sched_thd_yield_to+0x4c>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  402160:	41 89 c0             	mov    r8d,eax
--
  402169:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  40216e:	41 83 e0 01          	and    r8d,0x1
  402172:	e8 99 16 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  402177:	83 f8 f0             	cmp    eax,0xfffffff0
  40217a:	0f 85 9c fe ff ff    	jne    40201c <sched_thd_yield_to+0x9c>
  402180:	be 59 00 00 00       	mov    esi,0x59
  402185:	bf c0 c7 41 00       	mov    edi,0x41c7c0
  40218a:	e8 41 7f 00 00       	call   40a0d0 <cos_print_str>
  40218f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402196:	00 00 00 00 
--
  40219c:	be 59 00 00 00       	mov    esi,0x59
  4021a1:	bf 60 c7 41 00       	mov    edi,0x41c760
  4021a6:	e8 25 7f 00 00       	call   40a0d0 <cos_print_str>
	assert(current);
  4021ab:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  4021b8:	be 61 00 00 00       	mov    esi,0x61
  4021bd:	bf 48 c8 41 00       	mov    edi,0x41c848
  4021c2:	e8 09 7f 00 00       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  4021c7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  4021d4:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  4021d7:	48 81 fb c8 1e 5a 00 	cmp    rbx,0x5a1ec8
  4021de:	0f 84 d1 00 00 00    	je     4022b5 <sched_thd_yield_to+0x335>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  4021e4:	a8 02                	test   al,0x2
  4021e6:	0f 85 d5 00 00 00    	jne    4022c1 <sched_thd_yield_to+0x341>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  4021ec:	49 89 c8             	mov    r8,rcx
  4021ef:	a8 01                	test   al,0x1
  4021f1:	0f 84 e9 fe ff ff    	je     4020e0 <sched_thd_yield_to+0x160>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  4021f7:	4c 8b 53 08          	mov    r10,QWORD PTR [rbx+0x8]
--
  402205:	4c 8b 05 dc fc 19 00 	mov    r8,QWORD PTR [rip+0x19fcdc]        # 5a1ee8 <__slm_global+0x28>
  40220c:	4c 89 d6             	mov    rsi,r10
  40220f:	e8 0c f1 00 00       	call   411320 <cos_switch>
  402214:	eb 4d                	jmp    402263 <sched_thd_yield_to+0x2e3>
	return t != &g->idle_thd && t != &g->sched_thd;
  402216:	48 81 fb c8 1e 5a 00 	cmp    rbx,0x5a1ec8
  40221d:	74 25                	je     402244 <sched_thd_yield_to+0x2c4>
  40221f:	48 81 fb 40 1f 5a 00 	cmp    rbx,0x5a1f40
  402226:	74 1c                	je     402244 <sched_thd_yield_to+0x2c4>
  402228:	be 61 00 00 00       	mov    esi,0x61
  40222d:	bf b0 c8 41 00       	mov    edi,0x41c8b0
  402232:	e8 99 7e 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EPERM);
  402237:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  402254:	48 8b 3d 7d fc 19 00 	mov    rdi,QWORD PTR [rip+0x19fc7d]        # 5a1ed8 <__slm_global+0x18>
  40225b:	45 89 e9             	mov    r9d,r13d
  40225e:	e8 bd f0 00 00       	call   411320 <cos_switch>
	if (unlikely(ret != 0)) {
  402263:	85 c0                	test   eax,eax
  402265:	0f 84 95 fe ff ff    	je     402100 <sched_thd_yield_to+0x180>
		assert(ret != -EPERM);
  40226b:	83 f8 ff             	cmp    eax,0xffffffff
  40226e:	74 b8                	je     402228 <sched_thd_yield_to+0x2a8>
		assert(ret != -EINVAL);
  402270:	83 f8 ea             	cmp    eax,0xffffffea
  402273:	74 64                	je     4022d9 <sched_thd_yield_to+0x359>
		if (ret == -EBUSY) return ret;
  402275:	83 f8 f0             	cmp    eax,0xfffffff0
  402278:	0f 84 84 fe ff ff    	je     402102 <sched_thd_yield_to+0x182>
		assert(ret == -EAGAIN);
  40227e:	83 f8 f5             	cmp    eax,0xfffffff5
  402281:	0f 85 99 00 00 00    	jne    402320 <sched_thd_yield_to+0x3a0>
		tok    = cos_sched_sync();
  402287:	e8 74 f0 00 00       	call   411300 <cos_sched_sync>
  40228c:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  402296:	48 89 c1             	mov    rcx,rax
  402299:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  40229d:	75 56                	jne    4022f5 <sched_thd_yield_to+0x375>
  40229f:	f0 4c 0f b1 25 18 fc 	lock cmpxchg QWORD PTR [rip+0x19fc18],r12        # 5a1ec0 <__slm_global>
  4022a6:	19 00 
  4022a8:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4022ab:	84 c0                	test   al,al
  4022ad:	0f 85 ab fd ff ff    	jne    40205e <sched_thd_yield_to+0xde>
  4022b3:	eb d2                	jmp    402287 <sched_thd_yield_to+0x307>
			prio    = curr->priority;
  4022b5:	49 8b 74 24 30       	mov    rsi,QWORD PTR [r12+0x30]
			timeout = TCAP_TIME_NIL;
  4022ba:	31 c9                	xor    ecx,ecx
  4022bc:	e9 23 ff ff ff       	jmp    4021e4 <sched_thd_yield_to+0x264>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  4022c1:	48 8b 7b 28          	mov    rdi,QWORD PTR [rbx+0x28]
--
  4022cc:	44 89 e9             	mov    ecx,r13d
  4022cf:	4c 89 c6             	mov    rsi,r8
  4022d2:	e8 b9 f0 00 00       	call   411390 <cos_sched_asnd>
  4022d7:	eb 8a                	jmp    402263 <sched_thd_yield_to+0x2e3>
  4022d9:	be 61 00 00 00       	mov    esi,0x61
  4022de:	bf 18 c9 41 00       	mov    edi,0x41c918
  4022e3:	e8 e8 7d 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  4022e8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  4022fe:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  402303:	41 83 e0 01          	and    r8d,0x1
  402307:	e8 04 15 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  40230c:	83 f8 f0             	cmp    eax,0xfffffff0
  40230f:	0f 85 72 ff ff ff    	jne    402287 <sched_thd_yield_to+0x307>
  402315:	e9 66 fe ff ff       	jmp    402180 <sched_thd_yield_to+0x200>
  40231a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  402320:	be 61 00 00 00       	mov    esi,0x61
  402325:	bf 80 c9 41 00       	mov    edi,0x41c980
  40232a:	e8 a1 7d 00 00       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  40232f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  402354:	48 85 c0             	test   rax,rax
  402357:	0f 84 03 2b 01 00    	je     414e60 <sched_set_tls.cold>
  40235d:	83 e8 01             	sub    eax,0x1
  402360:	83 f8 18             	cmp    eax,0x18
  402363:	0f 87 f7 2a 01 00    	ja     414e60 <sched_set_tls.cold>
  402369:	48 8b 14 c5 00 e7 45 	mov    rdx,QWORD PTR [rax*8+0x45e700]
  402370:	00 
  402371:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  402378:	0f 84 e2 2a 01 00    	je     414e60 <sched_set_tls.cold>
  40237e:	83 e2 01             	and    edx,0x1
  402381:	0f 85 d9 2a 01 00    	jne    414e60 <sched_set_tls.cold>
	thdcap_t thdcap = current->thd;
  402387:	48 8d 14 80          	lea    rdx,[rax+rax*4]
--
  402396:	4c 8b 80 d8 e7 45 00 	mov    r8,QWORD PTR [rax+0x45e7d8]
  40239d:	4c 89 c7             	mov    rdi,r8
  4023a0:	e9 3b 50 00 00       	jmp    4073e0 <__cosrt_extern_capmgr_set_tls>
  4023a5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4023ac:	00 00 00 00 
--
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  4023d5:	48 85 c0             	test   rax,rax
  4023d8:	0f 84 82 01 00 00    	je     402560 <thd_block+0x1b0>
  4023de:	83 e8 01             	sub    eax,0x1
  4023e1:	83 f8 18             	cmp    eax,0x18
  4023e4:	0f 87 76 01 00 00    	ja     402560 <thd_block+0x1b0>
  4023ea:	48 8b 14 c5 00 e7 45 	mov    rdx,QWORD PTR [rax*8+0x45e700]
  4023f1:	00 
  4023f2:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  4023f9:	0f 84 61 01 00 00    	je     402560 <thd_block+0x1b0>
  4023ff:	83 e2 01             	and    edx,0x1
  402402:	0f 85 58 01 00 00    	jne    402560 <thd_block+0x1b0>
  402408:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  40240c:	48 8d 1c 50          	lea    rbx,[rax+rdx*2]
--
  402414:	48 81 c3 c8 e7 45 00 	add    rbx,0x45e7c8
		tok    = cos_sched_sync();
  40241b:	e8 e0 ee 00 00       	call   411300 <cos_sched_sync>
  402420:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  40242a:	48 89 c1             	mov    rcx,rax
  40242d:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  402431:	0f 85 49 01 00 00    	jne    402580 <thd_block+0x1d0>
  402437:	f0 48 0f b1 1d 80 fa 	lock cmpxchg QWORD PTR [rip+0x19fa80],rbx        # 5a1ec0 <__slm_global>
  40243e:	19 00 
  402440:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  402443:	84 c0                	test   al,al
  402445:	74 d4                	je     40241b <thd_block+0x6b>
        ret = slm_thd_block(current);
  402447:	48 89 df             	mov    rdi,rbx
  40244a:	e8 71 14 01 00       	call   4138c0 <slm_thd_block>
  40244f:	41 89 c5             	mov    r13d,eax
	if (!ret) ret = slm_cs_exit_reschedule(current, SLM_CS_NONE);
  402452:	85 c0                	test   eax,eax
  402454:	0f 85 d6 00 00 00    	jne    402530 <thd_block+0x180>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  40245a:	e8 01 94 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(!t)) t = &g->idle_thd;
  40245f:	41 bf 40 1f 5a 00    	mov    r15d,0x5a1f40
	tok  = cos_sched_sync();
  402465:	e8 96 ee 00 00       	call   411300 <cos_sched_sync>
  40246a:	41 89 c6             	mov    r14d,eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  40246d:	e8 1e 00 01 00       	call   412490 <slm_sched_fprr_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  402472:	48 85 c0             	test   rax,rax
--
  402481:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  402484:	83 f8 01             	cmp    eax,0x1
  402487:	76 17                	jbe    4024a0 <thd_block+0xf0>
  402489:	e9 82 01 00 00       	jmp    402610 <thd_block+0x260>
  40248e:	66 90                	xchg   ax,ax
  402490:	f0 48 0f b1 15 27 fa 	lock cmpxchg QWORD PTR [rip+0x19fa27],rdx        # 5a1ec0 <__slm_global>
  402497:	19 00 
  402499:	0f 94 c0             	sete   al
	while (ret != 0) {
  40249c:	84 c0                	test   al,al
  40249e:	75 2e                	jne    4024ce <thd_block+0x11e>
		tok    = cos_sched_sync();
  4024a0:	e8 5b ee 00 00       	call   411300 <cos_sched_sync>
  4024a5:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  4024ae:	48 89 c2             	mov    rdx,rax
  4024b1:	83 e2 01             	and    edx,0x1
  4024b4:	74 da                	je     402490 <thd_block+0xe0>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  4024b6:	48 89 c6             	mov    rsi,rax
--
  4024bc:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  4024c1:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  4024c5:	e8 96 13 01 00       	call   413860 <slm_cs_exit_contention>
  4024ca:	85 c0                	test   eax,eax
  4024cc:	75 d2                	jne    4024a0 <thd_block+0xf0>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  4024ce:	e8 8d 93 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4024d3:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
--
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4024e3:	a8 0b                	test   al,0xb
  4024e5:	0f 85 41 01 00 00    	jne    40262c <thd_block+0x27c>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  4024eb:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  4024f0:	44 89 f1             	mov    ecx,r14d
  4024f3:	4c 89 c2             	mov    rdx,r8
  4024f6:	e8 65 a2 00 00       	call   40c760 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  4024fb:	83 f8 ff             	cmp    eax,0xffffffff
  4024fe:	0f 84 97 01 00 00    	je     40269b <thd_block+0x2eb>
	if (unlikely(ret != 0)) {
  402504:	85 c0                	test   eax,eax
  402506:	0f 85 b0 00 00 00    	jne    4025bc <thd_block+0x20c>
}
  40250c:	48 83 c4 08          	add    rsp,0x8
--
  40251d:	c3                   	ret    
  40251e:	66 90                	xchg   ax,ax
  402520:	f0 48 0f b1 15 97 f9 	lock cmpxchg QWORD PTR [rip+0x19f997],rdx        # 5a1ec0 <__slm_global>
  402527:	19 00 
  402529:	0f 94 c0             	sete   al
	while (ret != 0) {
  40252c:	84 c0                	test   al,al
  40252e:	75 dc                	jne    40250c <thd_block+0x15c>
		tok    = cos_sched_sync();
  402530:	e8 cb ed 00 00       	call   411300 <cos_sched_sync>
  402535:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  40253e:	48 89 c2             	mov    rdx,rax
  402541:	83 e2 01             	and    edx,0x1
  402544:	74 da                	je     402520 <thd_block+0x170>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  402546:	48 89 c6             	mov    rsi,rax
--
  40254c:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  402551:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  402555:	e8 06 13 01 00       	call   413860 <slm_cs_exit_contention>
  40255a:	85 c0                	test   eax,eax
  40255c:	74 ae                	je     40250c <thd_block+0x15c>
  40255e:	eb d0                	jmp    402530 <thd_block+0x180>
  402560:	be 59 00 00 00       	mov    esi,0x59
  402565:	bf 60 c7 41 00       	mov    edi,0x41c760
  40256a:	e8 61 7b 00 00       	call   40a0d0 <cos_print_str>
	assert(current);
  40256f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  402589:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  40258e:	41 83 e0 01          	and    r8d,0x1
  402592:	e8 79 12 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  402597:	83 f8 f0             	cmp    eax,0xfffffff0
  40259a:	0f 85 7b fe ff ff    	jne    40241b <thd_block+0x6b>
  4025a0:	be 59 00 00 00       	mov    esi,0x59
  4025a5:	bf c0 c7 41 00       	mov    edi,0x41c7c0
  4025aa:	e8 21 7b 00 00       	call   40a0d0 <cos_print_str>
  4025af:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4025b6:	00 00 00 00 
  4025ba:	0f 0b                	ud2    
		assert(ret != -EINVAL);
  4025bc:	83 f8 ea             	cmp    eax,0xffffffea
  4025bf:	0f 84 2f 01 00 00    	je     4026f4 <thd_block+0x344>
		if (ret == -EBUSY) return ret;
  4025c5:	83 f8 f0             	cmp    eax,0xfffffff0
  4025c8:	0f 84 86 01 00 00    	je     402754 <thd_block+0x3a4>
		assert(ret == -EAGAIN);
  4025ce:	83 f8 f5             	cmp    eax,0xfffffff5
  4025d1:	0f 85 61 01 00 00    	jne    402738 <thd_block+0x388>
		tok    = cos_sched_sync();
  4025d7:	e8 24 ed 00 00       	call   411300 <cos_sched_sync>
  4025dc:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  4025e6:	48 89 c1             	mov    rcx,rax
  4025e9:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  4025ed:	0f 85 1d 01 00 00    	jne    402710 <thd_block+0x360>
  4025f3:	f0 48 0f b1 1d c4 f8 	lock cmpxchg QWORD PTR [rip+0x19f8c4],rbx        # 5a1ec0 <__slm_global>
  4025fa:	19 00 
  4025fc:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4025ff:	84 c0                	test   al,al
  402601:	0f 85 5e fe ff ff    	jne    402465 <thd_block+0xb5>
  402607:	eb ce                	jmp    4025d7 <thd_block+0x227>
  402609:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  402610:	be 61 00 00 00       	mov    esi,0x61
  402615:	bf 48 c8 41 00       	mov    edi,0x41c848
  40261a:	e8 b1 7a 00 00       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  40261f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40262c:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  40262f:	49 81 fc c8 1e 5a 00 	cmp    r12,0x5a1ec8
  402636:	0f 84 91 00 00 00    	je     4026cd <thd_block+0x31d>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  40263c:	a8 02                	test   al,0x2
  40263e:	0f 85 94 00 00 00    	jne    4026d8 <thd_block+0x328>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  402644:	49 89 c8             	mov    r8,rcx
  402647:	a8 01                	test   al,0x1
  402649:	0f 84 9c fe ff ff    	je     4024eb <thd_block+0x13b>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  40264f:	4d 8b 54 24 08       	mov    r10,QWORD PTR [r12+0x8]
--
  40265f:	4c 8b 05 82 f8 19 00 	mov    r8,QWORD PTR [rip+0x19f882]        # 5a1ee8 <__slm_global+0x28>
  402666:	4c 89 d6             	mov    rsi,r10
  402669:	e8 b2 ec 00 00       	call   411320 <cos_switch>
	if (unlikely(ret != 0)) {
  40266e:	85 c0                	test   eax,eax
  402670:	0f 84 96 fe ff ff    	je     40250c <thd_block+0x15c>
		assert(ret != -EPERM);
  402676:	83 f8 ff             	cmp    eax,0xffffffff
  402679:	0f 85 3d ff ff ff    	jne    4025bc <thd_block+0x20c>
  40267f:	be 61 00 00 00       	mov    esi,0x61
  402684:	bf b0 c8 41 00       	mov    edi,0x41c8b0
  402689:	e8 42 7a 00 00       	call   40a0d0 <cos_print_str>
  40268e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402695:	00 00 00 00 
  402699:	0f 0b                	ud2    
	return t != &g->idle_thd && t != &g->sched_thd;
  40269b:	49 81 fc 40 1f 5a 00 	cmp    r12,0x5a1f40
  4026a2:	74 09                	je     4026ad <thd_block+0x2fd>
  4026a4:	49 81 fc c8 1e 5a 00 	cmp    r12,0x5a1ec8
  4026ab:	75 d2                	jne    40267f <thd_block+0x2cf>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  4026ad:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]
--
  4026bd:	48 8b 3d 14 f8 19 00 	mov    rdi,QWORD PTR [rip+0x19f814]        # 5a1ed8 <__slm_global+0x18>
  4026c4:	31 f6                	xor    esi,esi
  4026c6:	e8 55 ec 00 00       	call   411320 <cos_switch>
  4026cb:	eb a1                	jmp    40266e <thd_block+0x2be>
			prio    = curr->priority;
  4026cd:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
			timeout = TCAP_TIME_NIL;
  4026d1:	31 c9                	xor    ecx,ecx
  4026d3:	e9 64 ff ff ff       	jmp    40263c <thd_block+0x28c>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  4026d8:	49 8b 7c 24 28       	mov    rdi,QWORD PTR [r12+0x28]
--
  4026e4:	44 89 f1             	mov    ecx,r14d
  4026e7:	4c 89 c6             	mov    rsi,r8
  4026ea:	e8 a1 ec 00 00       	call   411390 <cos_sched_asnd>
  4026ef:	e9 7a ff ff ff       	jmp    40266e <thd_block+0x2be>
  4026f4:	be 61 00 00 00       	mov    esi,0x61
  4026f9:	bf 18 c9 41 00       	mov    edi,0x41c918
  4026fe:	e8 cd 79 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  402703:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  402719:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  40271e:	41 83 e0 01          	and    r8d,0x1
  402722:	e8 e9 10 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  402727:	83 f8 f0             	cmp    eax,0xfffffff0
  40272a:	0f 85 a7 fe ff ff    	jne    4025d7 <thd_block+0x227>
  402730:	e9 6b fe ff ff       	jmp    4025a0 <thd_block+0x1f0>
  402735:	0f 1f 00             	nop    DWORD PTR [rax]
  402738:	be 61 00 00 00       	mov    esi,0x61
  40273d:	bf 80 c9 41 00       	mov    edi,0x41c980
  402742:	e8 89 79 00 00       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  402747:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  402754:	41 bd f0 ff ff ff    	mov    r13d,0xfffffff0
	return ret;
  40275a:	e9 ad fd ff ff       	jmp    40250c <thd_block+0x15c>
  40275f:	90                   	nop

--
	if (dep_id) return -1;
  402775:	48 85 ff             	test   rdi,rdi
  402778:	0f 85 0f 03 00 00    	jne    402a8d <sched_thd_block+0x32d>
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  40277e:	48 89 e0             	mov    rax,rsp
--
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  40278e:	48 85 c0             	test   rax,rax
  402791:	0f 84 89 01 00 00    	je     402920 <sched_thd_block+0x1c0>
  402797:	83 e8 01             	sub    eax,0x1
  40279a:	83 f8 18             	cmp    eax,0x18
  40279d:	0f 87 7d 01 00 00    	ja     402920 <sched_thd_block+0x1c0>
  4027a3:	48 8b 14 c5 00 e7 45 	mov    rdx,QWORD PTR [rax*8+0x45e700]
  4027aa:	00 
  4027ab:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  4027b2:	0f 84 68 01 00 00    	je     402920 <sched_thd_block+0x1c0>
  4027b8:	83 e2 01             	and    edx,0x1
  4027bb:	0f 85 5f 01 00 00    	jne    402920 <sched_thd_block+0x1c0>
  4027c1:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  4027c5:	48 8d 1c 50          	lea    rbx,[rax+rdx*2]
--
  4027cd:	48 81 c3 c8 e7 45 00 	add    rbx,0x45e7c8
		tok    = cos_sched_sync();
  4027d4:	e8 27 eb 00 00       	call   411300 <cos_sched_sync>
  4027d9:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  4027e3:	48 89 c1             	mov    rcx,rax
  4027e6:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  4027ea:	0f 85 50 01 00 00    	jne    402940 <sched_thd_block+0x1e0>
  4027f0:	f0 48 0f b1 1d c7 f6 	lock cmpxchg QWORD PTR [rip+0x19f6c7],rbx        # 5a1ec0 <__slm_global>
  4027f7:	19 00 
  4027f9:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4027fc:	84 c0                	test   al,al
  4027fe:	74 d4                	je     4027d4 <sched_thd_block+0x74>
        ret = slm_thd_block(current);
  402800:	48 89 df             	mov    rdi,rbx
  402803:	e8 b8 10 01 00       	call   4138c0 <slm_thd_block>
  402808:	41 89 c5             	mov    r13d,eax
	if (!ret) ret = slm_cs_exit_reschedule(current, SLM_CS_NONE);
  40280b:	85 c0                	test   eax,eax
  40280d:	0f 85 dd 00 00 00    	jne    4028f0 <sched_thd_block+0x190>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  402813:	e8 48 90 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(!t)) t = &g->idle_thd;
  402818:	41 bf 40 1f 5a 00    	mov    r15d,0x5a1f40
	tok  = cos_sched_sync();
  40281e:	e8 dd ea 00 00       	call   411300 <cos_sched_sync>
  402823:	41 89 c6             	mov    r14d,eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  402826:	e8 65 fc 00 00       	call   412490 <slm_sched_fprr_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  40282b:	48 85 c0             	test   rax,rax
--
  40283a:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  40283d:	83 f8 01             	cmp    eax,0x1
  402840:	76 1e                	jbe    402860 <sched_thd_block+0x100>
  402842:	e9 89 01 00 00       	jmp    4029d0 <sched_thd_block+0x270>
  402847:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40284e:	00 00 
  402850:	f0 48 0f b1 15 67 f6 	lock cmpxchg QWORD PTR [rip+0x19f667],rdx        # 5a1ec0 <__slm_global>
  402857:	19 00 
  402859:	0f 94 c0             	sete   al
	while (ret != 0) {
  40285c:	84 c0                	test   al,al
  40285e:	75 2e                	jne    40288e <sched_thd_block+0x12e>
		tok    = cos_sched_sync();
  402860:	e8 9b ea 00 00       	call   411300 <cos_sched_sync>
  402865:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  40286e:	48 89 c2             	mov    rdx,rax
  402871:	83 e2 01             	and    edx,0x1
  402874:	74 da                	je     402850 <sched_thd_block+0xf0>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  402876:	48 89 c6             	mov    rsi,rax
--
  40287c:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  402881:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  402885:	e8 d6 0f 01 00       	call   413860 <slm_cs_exit_contention>
  40288a:	85 c0                	test   eax,eax
  40288c:	75 d2                	jne    402860 <sched_thd_block+0x100>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  40288e:	e8 cd 8f 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  402893:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
--
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4028a3:	a8 0b                	test   al,0xb
  4028a5:	0f 85 41 01 00 00    	jne    4029ec <sched_thd_block+0x28c>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  4028ab:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  4028b0:	44 89 f1             	mov    ecx,r14d
  4028b3:	4c 89 c2             	mov    rdx,r8
  4028b6:	e8 a5 9e 00 00       	call   40c760 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  4028bb:	83 f8 ff             	cmp    eax,0xffffffff
  4028be:	0f 84 97 01 00 00    	je     402a5b <sched_thd_block+0x2fb>
	if (unlikely(ret != 0)) {
  4028c4:	85 c0                	test   eax,eax
  4028c6:	0f 85 b0 00 00 00    	jne    40297c <sched_thd_block+0x21c>
}
  4028cc:	48 83 c4 08          	add    rsp,0x8
--
  4028dd:	c3                   	ret    
  4028de:	66 90                	xchg   ax,ax
  4028e0:	f0 48 0f b1 15 d7 f5 	lock cmpxchg QWORD PTR [rip+0x19f5d7],rdx        # 5a1ec0 <__slm_global>
  4028e7:	19 00 
  4028e9:	0f 94 c0             	sete   al
	while (ret != 0) {
  4028ec:	84 c0                	test   al,al
  4028ee:	75 dc                	jne    4028cc <sched_thd_block+0x16c>
		tok    = cos_sched_sync();
  4028f0:	e8 0b ea 00 00       	call   411300 <cos_sched_sync>
  4028f5:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  4028fe:	48 89 c2             	mov    rdx,rax
  402901:	83 e2 01             	and    edx,0x1
  402904:	74 da                	je     4028e0 <sched_thd_block+0x180>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  402906:	48 89 c6             	mov    rsi,rax
--
  40290c:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  402911:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  402915:	e8 46 0f 01 00       	call   413860 <slm_cs_exit_contention>
  40291a:	85 c0                	test   eax,eax
  40291c:	74 ae                	je     4028cc <sched_thd_block+0x16c>
  40291e:	eb d0                	jmp    4028f0 <sched_thd_block+0x190>
  402920:	be 59 00 00 00       	mov    esi,0x59
  402925:	bf 60 c7 41 00       	mov    edi,0x41c760
  40292a:	e8 a1 77 00 00       	call   40a0d0 <cos_print_str>
	assert(current);
  40292f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  402949:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  40294e:	41 83 e0 01          	and    r8d,0x1
  402952:	e8 b9 0e 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  402957:	83 f8 f0             	cmp    eax,0xfffffff0
  40295a:	0f 85 74 fe ff ff    	jne    4027d4 <sched_thd_block+0x74>
  402960:	be 59 00 00 00       	mov    esi,0x59
  402965:	bf c0 c7 41 00       	mov    edi,0x41c7c0
  40296a:	e8 61 77 00 00       	call   40a0d0 <cos_print_str>
  40296f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402976:	00 00 00 00 
  40297a:	0f 0b                	ud2    
		assert(ret != -EINVAL);
  40297c:	83 f8 ea             	cmp    eax,0xffffffea
  40297f:	0f 84 3a 01 00 00    	je     402abf <sched_thd_block+0x35f>
		if (ret == -EBUSY) return ret;
  402985:	83 f8 f0             	cmp    eax,0xfffffff0
  402988:	0f 84 8e 01 00 00    	je     402b1c <sched_thd_block+0x3bc>
		assert(ret == -EAGAIN);
  40298e:	83 f8 f5             	cmp    eax,0xfffffff5
  402991:	0f 85 69 01 00 00    	jne    402b00 <sched_thd_block+0x3a0>
		tok    = cos_sched_sync();
  402997:	e8 64 e9 00 00       	call   411300 <cos_sched_sync>
  40299c:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  4029a6:	48 89 c1             	mov    rcx,rax
  4029a9:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  4029ad:	0f 85 28 01 00 00    	jne    402adb <sched_thd_block+0x37b>
  4029b3:	f0 48 0f b1 1d 04 f5 	lock cmpxchg QWORD PTR [rip+0x19f504],rbx        # 5a1ec0 <__slm_global>
  4029ba:	19 00 
  4029bc:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4029bf:	84 c0                	test   al,al
  4029c1:	0f 85 57 fe ff ff    	jne    40281e <sched_thd_block+0xbe>
  4029c7:	eb ce                	jmp    402997 <sched_thd_block+0x237>
  4029c9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  4029d0:	be 61 00 00 00       	mov    esi,0x61
  4029d5:	bf 48 c8 41 00       	mov    edi,0x41c848
  4029da:	e8 f1 76 00 00       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  4029df:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  4029ec:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  4029ef:	49 81 fc c8 1e 5a 00 	cmp    r12,0x5a1ec8
  4029f6:	0f 84 9c 00 00 00    	je     402a98 <sched_thd_block+0x338>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  4029fc:	a8 02                	test   al,0x2
  4029fe:	0f 85 9f 00 00 00    	jne    402aa3 <sched_thd_block+0x343>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  402a04:	49 89 c8             	mov    r8,rcx
  402a07:	a8 01                	test   al,0x1
  402a09:	0f 84 9c fe ff ff    	je     4028ab <sched_thd_block+0x14b>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  402a0f:	4d 8b 54 24 08       	mov    r10,QWORD PTR [r12+0x8]
--
  402a1f:	4c 8b 05 c2 f4 19 00 	mov    r8,QWORD PTR [rip+0x19f4c2]        # 5a1ee8 <__slm_global+0x28>
  402a26:	4c 89 d6             	mov    rsi,r10
  402a29:	e8 f2 e8 00 00       	call   411320 <cos_switch>
	if (unlikely(ret != 0)) {
  402a2e:	85 c0                	test   eax,eax
  402a30:	0f 84 96 fe ff ff    	je     4028cc <sched_thd_block+0x16c>
		assert(ret != -EPERM);
  402a36:	83 f8 ff             	cmp    eax,0xffffffff
  402a39:	0f 85 3d ff ff ff    	jne    40297c <sched_thd_block+0x21c>
  402a3f:	be 61 00 00 00       	mov    esi,0x61
  402a44:	bf b0 c8 41 00       	mov    edi,0x41c8b0
  402a49:	e8 82 76 00 00       	call   40a0d0 <cos_print_str>
  402a4e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402a55:	00 00 00 00 
  402a59:	0f 0b                	ud2    
	return t != &g->idle_thd && t != &g->sched_thd;
  402a5b:	49 81 fc 40 1f 5a 00 	cmp    r12,0x5a1f40
  402a62:	74 09                	je     402a6d <sched_thd_block+0x30d>
  402a64:	49 81 fc c8 1e 5a 00 	cmp    r12,0x5a1ec8
  402a6b:	75 d2                	jne    402a3f <sched_thd_block+0x2df>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  402a6d:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]
--
  402a7d:	48 8b 3d 54 f4 19 00 	mov    rdi,QWORD PTR [rip+0x19f454]        # 5a1ed8 <__slm_global+0x18>
  402a84:	31 f6                	xor    esi,esi
  402a86:	e8 95 e8 00 00       	call   411320 <cos_switch>
  402a8b:	eb a1                	jmp    402a2e <sched_thd_block+0x2ce>
	if (dep_id) return -1;
  402a8d:	41 bd ff ff ff ff    	mov    r13d,0xffffffff
  402a93:	e9 34 fe ff ff       	jmp    4028cc <sched_thd_block+0x16c>
			prio    = curr->priority;
  402a98:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
			timeout = TCAP_TIME_NIL;
  402a9c:	31 c9                	xor    ecx,ecx
  402a9e:	e9 59 ff ff ff       	jmp    4029fc <sched_thd_block+0x29c>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  402aa3:	49 8b 7c 24 28       	mov    rdi,QWORD PTR [r12+0x28]
--
  402aaf:	44 89 f1             	mov    ecx,r14d
  402ab2:	4c 89 c6             	mov    rsi,r8
  402ab5:	e8 d6 e8 00 00       	call   411390 <cos_sched_asnd>
  402aba:	e9 6f ff ff ff       	jmp    402a2e <sched_thd_block+0x2ce>
  402abf:	be 61 00 00 00       	mov    esi,0x61
  402ac4:	bf 18 c9 41 00       	mov    edi,0x41c918
  402ac9:	e8 02 76 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  402ace:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  402ae4:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  402ae9:	41 83 e0 01          	and    r8d,0x1
  402aed:	e8 1e 0d 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  402af2:	83 f8 f0             	cmp    eax,0xfffffff0
  402af5:	0f 85 9c fe ff ff    	jne    402997 <sched_thd_block+0x237>
  402afb:	e9 60 fe ff ff       	jmp    402960 <sched_thd_block+0x200>
  402b00:	be 61 00 00 00       	mov    esi,0x61
  402b05:	bf 80 c9 41 00       	mov    edi,0x41c980
  402b0a:	e8 c1 75 00 00       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  402b0f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	ret = slm_thd_activate(curr, t, tok, 0);
  402b1c:	41 bd f0 ff ff ff    	mov    r13d,0xfffffff0
  402b22:	e9 a5 fd ff ff       	jmp    4028cc <sched_thd_block+0x16c>
  402b27:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  402b2e:	00 00 
--
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  402b55:	48 85 c0             	test   rax,rax
  402b58:	0f 84 92 01 00 00    	je     402cf0 <thd_wakeup+0x1c0>
  402b5e:	83 e8 01             	sub    eax,0x1
  402b61:	83 f8 18             	cmp    eax,0x18
  402b64:	0f 87 86 01 00 00    	ja     402cf0 <thd_wakeup+0x1c0>
  402b6a:	48 8b 14 c5 00 e7 45 	mov    rdx,QWORD PTR [rax*8+0x45e700]
  402b71:	00 
  402b72:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  402b79:	0f 84 71 01 00 00    	je     402cf0 <thd_wakeup+0x1c0>
  402b7f:	83 e2 01             	and    edx,0x1
  402b82:	0f 85 68 01 00 00    	jne    402cf0 <thd_wakeup+0x1c0>
  402b88:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  402b8c:	49 89 fd             	mov    r13,rdi
--
  402b97:	49 81 c4 c8 e7 45 00 	add    r12,0x45e7c8
		tok    = cos_sched_sync();
  402b9e:	e8 5d e7 00 00       	call   411300 <cos_sched_sync>
  402ba3:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  402bad:	48 89 c1             	mov    rcx,rax
  402bb0:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  402bb4:	0f 85 56 01 00 00    	jne    402d10 <thd_wakeup+0x1e0>
  402bba:	f0 4c 0f b1 25 fd f2 	lock cmpxchg QWORD PTR [rip+0x19f2fd],r12        # 5a1ec0 <__slm_global>
  402bc1:	19 00 
  402bc3:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  402bc6:	84 c0                	test   al,al
  402bc8:	74 d4                	je     402b9e <thd_wakeup+0x6e>
	ret = slm_thd_wakeup(t, 0);
  402bca:	31 f6                	xor    esi,esi
  402bcc:	4c 89 ef             	mov    rdi,r13
  402bcf:	e8 5c 12 01 00       	call   413e30 <slm_thd_wakeup>
  402bd4:	41 89 c7             	mov    r15d,eax
	if (ret < 0) {
--
  402bd9:	0f 88 e1 00 00 00    	js     402cc0 <thd_wakeup+0x190>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  402bdf:	e8 7c 8c 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(!t)) t = &g->idle_thd;
  402be4:	41 be 40 1f 5a 00    	mov    r14d,0x5a1f40
	tok  = cos_sched_sync();
  402bea:	e8 11 e7 00 00       	call   411300 <cos_sched_sync>
  402bef:	41 89 c5             	mov    r13d,eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  402bf2:	e8 99 f8 00 00       	call   412490 <slm_sched_fprr_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  402bf7:	48 85 c0             	test   rax,rax
--
  402c04:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  402c07:	83 f8 01             	cmp    eax,0x1
  402c0a:	76 1c                	jbe    402c28 <thd_wakeup+0xf8>
  402c0c:	e9 3b 01 00 00       	jmp    402d4c <thd_wakeup+0x21c>
  402c11:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  402c18:	f0 48 0f b1 15 9f f2 	lock cmpxchg QWORD PTR [rip+0x19f29f],rdx        # 5a1ec0 <__slm_global>
  402c1f:	19 00 
  402c21:	0f 94 c0             	sete   al
	while (ret != 0) {
  402c24:	84 c0                	test   al,al
  402c26:	75 2e                	jne    402c56 <thd_wakeup+0x126>
		tok    = cos_sched_sync();
  402c28:	e8 d3 e6 00 00       	call   411300 <cos_sched_sync>
  402c2d:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  402c36:	48 89 c2             	mov    rdx,rax
  402c39:	83 e2 01             	and    edx,0x1
  402c3c:	74 da                	je     402c18 <thd_wakeup+0xe8>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  402c3e:	48 89 c6             	mov    rsi,rax
--
  402c44:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  402c49:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  402c4d:	e8 0e 0c 01 00       	call   413860 <slm_cs_exit_contention>
  402c52:	85 c0                	test   eax,eax
  402c54:	75 d2                	jne    402c28 <thd_wakeup+0xf8>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  402c56:	e8 05 8c 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  402c5b:	8b 03                	mov    eax,DWORD PTR [rbx]
--
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  402c68:	a8 0b                	test   al,0xb
  402c6a:	0f 85 f8 00 00 00    	jne    402d68 <thd_wakeup+0x238>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  402c70:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  402c74:	44 89 e9             	mov    ecx,r13d
  402c77:	4c 89 c2             	mov    rdx,r8
  402c7a:	e8 e1 9a 00 00       	call   40c760 <cos_defswitch>
  402c7f:	41 89 c7             	mov    r15d,eax
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  402c82:	83 f8 ff             	cmp    eax,0xffffffff
  402c85:	0f 84 85 01 00 00    	je     402e10 <thd_wakeup+0x2e0>
	if (unlikely(ret != 0)) {
  402c8b:	85 c0                	test   eax,eax
  402c8d:	0f 85 27 01 00 00    	jne    402dba <thd_wakeup+0x28a>
  402c93:	45 31 ff             	xor    r15d,r15d
}
--
  402ca8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  402caf:	00 
  402cb0:	f0 48 0f b1 15 07 f2 	lock cmpxchg QWORD PTR [rip+0x19f207],rdx        # 5a1ec0 <__slm_global>
  402cb7:	19 00 
  402cb9:	0f 94 c0             	sete   al
	while (ret != 0) {
  402cbc:	84 c0                	test   al,al
  402cbe:	75 d6                	jne    402c96 <thd_wakeup+0x166>
		tok    = cos_sched_sync();
  402cc0:	e8 3b e6 00 00       	call   411300 <cos_sched_sync>
  402cc5:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  402cce:	48 89 c2             	mov    rdx,rax
  402cd1:	83 e2 01             	and    edx,0x1
  402cd4:	74 da                	je     402cb0 <thd_wakeup+0x180>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  402cd6:	48 89 c6             	mov    rsi,rax
--
  402cdc:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  402ce1:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  402ce5:	e8 76 0b 01 00       	call   413860 <slm_cs_exit_contention>
  402cea:	85 c0                	test   eax,eax
  402cec:	74 a8                	je     402c96 <thd_wakeup+0x166>
  402cee:	eb d0                	jmp    402cc0 <thd_wakeup+0x190>
  402cf0:	be 59 00 00 00       	mov    esi,0x59
  402cf5:	bf 60 c7 41 00       	mov    edi,0x41c760
  402cfa:	e8 d1 73 00 00       	call   40a0d0 <cos_print_str>
	assert(current);
  402cff:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  402d19:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  402d1e:	41 83 e0 01          	and    r8d,0x1
  402d22:	e8 e9 0a 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  402d27:	83 f8 f0             	cmp    eax,0xfffffff0
  402d2a:	0f 85 6e fe ff ff    	jne    402b9e <thd_wakeup+0x6e>
  402d30:	be 59 00 00 00       	mov    esi,0x59
  402d35:	bf c0 c7 41 00       	mov    edi,0x41c7c0
  402d3a:	e8 91 73 00 00       	call   40a0d0 <cos_print_str>
  402d3f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402d46:	00 00 00 00 
--
  402d4c:	be 61 00 00 00       	mov    esi,0x61
  402d51:	bf 48 c8 41 00       	mov    edi,0x41c848
  402d56:	e8 75 73 00 00       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  402d5b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  402d68:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  402d6b:	48 81 fb c8 1e 5a 00 	cmp    rbx,0x5a1ec8
  402d72:	0f 84 c6 00 00 00    	je     402e3e <thd_wakeup+0x30e>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  402d78:	a8 02                	test   al,0x2
  402d7a:	0f 85 f1 00 00 00    	jne    402e71 <thd_wakeup+0x341>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  402d80:	49 89 c8             	mov    r8,rcx
  402d83:	a8 01                	test   al,0x1
  402d85:	0f 84 e5 fe ff ff    	je     402c70 <thd_wakeup+0x140>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  402d8b:	4c 8b 53 08          	mov    r10,QWORD PTR [rbx+0x8]
--
  402d99:	4c 8b 05 48 f1 19 00 	mov    r8,QWORD PTR [rip+0x19f148]        # 5a1ee8 <__slm_global+0x28>
  402da0:	4c 89 d6             	mov    rsi,r10
  402da3:	e8 78 e5 00 00       	call   411320 <cos_switch>
  402da8:	41 89 c7             	mov    r15d,eax
	if (unlikely(ret != 0)) {
  402dab:	45 85 ff             	test   r15d,r15d
  402dae:	0f 84 df fe ff ff    	je     402c93 <thd_wakeup+0x163>
		assert(ret != -EPERM);
  402db4:	41 83 ff ff          	cmp    r15d,0xffffffff
  402db8:	74 68                	je     402e22 <thd_wakeup+0x2f2>
		assert(ret != -EINVAL);
  402dba:	41 83 ff ea          	cmp    r15d,0xffffffea
  402dbe:	0f 84 cb 00 00 00    	je     402e8f <thd_wakeup+0x35f>
		if (ret == -EBUSY) return ret;
  402dc4:	41 83 ff f0          	cmp    r15d,0xfffffff0
  402dc8:	0f 84 c8 fe ff ff    	je     402c96 <thd_wakeup+0x166>
		assert(ret == -EAGAIN);
  402dce:	41 83 ff f5          	cmp    r15d,0xfffffff5
  402dd2:	0f 85 f8 00 00 00    	jne    402ed0 <thd_wakeup+0x3a0>
		tok    = cos_sched_sync();
  402dd8:	e8 23 e5 00 00       	call   411300 <cos_sched_sync>
  402ddd:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  402de7:	48 89 c1             	mov    rcx,rax
  402dea:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  402dee:	0f 85 b7 00 00 00    	jne    402eab <thd_wakeup+0x37b>
  402df4:	f0 4c 0f b1 25 c3 f0 	lock cmpxchg QWORD PTR [rip+0x19f0c3],r12        # 5a1ec0 <__slm_global>
  402dfb:	19 00 
  402dfd:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  402e00:	84 c0                	test   al,al
  402e02:	0f 85 e2 fd ff ff    	jne    402bea <thd_wakeup+0xba>
  402e08:	eb ce                	jmp    402dd8 <thd_wakeup+0x2a8>
  402e0a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	return t != &g->idle_thd && t != &g->sched_thd;
  402e10:	48 81 fb 40 1f 5a 00 	cmp    rbx,0x5a1f40
  402e17:	74 31                	je     402e4a <thd_wakeup+0x31a>
  402e19:	48 81 fb c8 1e 5a 00 	cmp    rbx,0x5a1ec8
  402e20:	74 28                	je     402e4a <thd_wakeup+0x31a>
  402e22:	be 61 00 00 00       	mov    esi,0x61
  402e27:	bf b0 c8 41 00       	mov    edi,0x41c8b0
  402e2c:	e8 9f 72 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EPERM);
  402e31:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
			timeout = TCAP_TIME_NIL;
  402e43:	31 c9                	xor    ecx,ecx
  402e45:	e9 2e ff ff ff       	jmp    402d78 <thd_wakeup+0x248>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  402e4a:	49 8b 54 24 30       	mov    rdx,QWORD PTR [r12+0x30]
--
  402e5a:	48 8b 3d 77 f0 19 00 	mov    rdi,QWORD PTR [rip+0x19f077]        # 5a1ed8 <__slm_global+0x18>
  402e61:	45 89 e9             	mov    r9d,r13d
  402e64:	e8 b7 e4 00 00       	call   411320 <cos_switch>
  402e69:	41 89 c7             	mov    r15d,eax
  402e6c:	e9 3a ff ff ff       	jmp    402dab <thd_wakeup+0x27b>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  402e71:	48 8b 7b 28          	mov    rdi,QWORD PTR [rbx+0x28]
--
  402e7c:	44 89 e9             	mov    ecx,r13d
  402e7f:	4c 89 c6             	mov    rsi,r8
  402e82:	e8 09 e5 00 00       	call   411390 <cos_sched_asnd>
  402e87:	41 89 c7             	mov    r15d,eax
  402e8a:	e9 1c ff ff ff       	jmp    402dab <thd_wakeup+0x27b>
  402e8f:	be 61 00 00 00       	mov    esi,0x61
  402e94:	bf 18 c9 41 00       	mov    edi,0x41c918
  402e99:	e8 32 72 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  402e9e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  402eb4:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  402eb9:	41 83 e0 01          	and    r8d,0x1
  402ebd:	e8 4e 09 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  402ec2:	83 f8 f0             	cmp    eax,0xfffffff0
  402ec5:	0f 85 0d ff ff ff    	jne    402dd8 <thd_wakeup+0x2a8>
  402ecb:	e9 60 fe ff ff       	jmp    402d30 <thd_wakeup+0x200>
  402ed0:	be 61 00 00 00       	mov    esi,0x61
  402ed5:	bf 80 c9 41 00       	mov    edi,0x41c980
  402eda:	e8 f1 71 00 00       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  402edf:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  402f05:	85 ff                	test   edi,edi
  402f07:	74 1b                	je     402f24 <sched_thd_wakeup+0x34>
  402f09:	83 ef 01             	sub    edi,0x1
  402f0c:	83 ff 18             	cmp    edi,0x18
  402f0f:	77 13                	ja     402f24 <sched_thd_wakeup+0x34>
  402f11:	89 f8                	mov    eax,edi
--
  402f1a:	00 
  402f1b:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  402f22:	75 1c                	jne    402f40 <sched_thd_wakeup+0x50>
	if (!t) return -1;
  402f24:	41 bf ff ff ff ff    	mov    r15d,0xffffffff
--
  402f3c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  402f40:	83 e2 01             	and    edx,0x1
  402f43:	75 df                	jne    402f24 <sched_thd_wakeup+0x34>
	return &ss_thd_get(id)->thd;
  402f45:	48 8d 14 80          	lea    rdx,[rax+rax*4]
--
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  402f68:	48 85 c0             	test   rax,rax
  402f6b:	74 19                	je     402f86 <sched_thd_wakeup+0x96>
  402f6d:	83 e8 01             	sub    eax,0x1
  402f70:	83 f8 18             	cmp    eax,0x18
  402f73:	77 11                	ja     402f86 <sched_thd_wakeup+0x96>
  402f75:	48 8b 14 c5 00 e7 45 	mov    rdx,QWORD PTR [rax*8+0x45e700]
  402f7c:	00 
  402f7d:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  402f84:	75 22                	jne    402fa8 <sched_thd_wakeup+0xb8>
  402f86:	be 59 00 00 00       	mov    esi,0x59
  402f8b:	bf 60 c7 41 00       	mov    edi,0x41c760
  402f90:	e8 3b 71 00 00       	call   40a0d0 <cos_print_str>
	assert(current);
  402f95:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  402fa2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  402fa8:	83 e2 01             	and    edx,0x1
  402fab:	75 d9                	jne    402f86 <sched_thd_wakeup+0x96>
  402fad:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  402fb1:	4c 8d 24 50          	lea    r12,[rax+rdx*2]
--
  402fb9:	49 81 c4 c8 e7 45 00 	add    r12,0x45e7c8
		tok    = cos_sched_sync();
  402fc0:	e8 3b e3 00 00       	call   411300 <cos_sched_sync>
  402fc5:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  402fcf:	48 89 c1             	mov    rcx,rax
  402fd2:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  402fd6:	0f 85 34 01 00 00    	jne    403110 <sched_thd_wakeup+0x220>
  402fdc:	f0 4c 0f b1 25 db ee 	lock cmpxchg QWORD PTR [rip+0x19eedb],r12        # 5a1ec0 <__slm_global>
  402fe3:	19 00 
  402fe5:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  402fe8:	84 c0                	test   al,al
  402fea:	74 d4                	je     402fc0 <sched_thd_wakeup+0xd0>
	ret = slm_thd_wakeup(t, 0);
  402fec:	31 f6                	xor    esi,esi
  402fee:	4c 89 ef             	mov    rdi,r13
  402ff1:	e8 3a 0e 01 00       	call   413e30 <slm_thd_wakeup>
  402ff6:	41 89 c7             	mov    r15d,eax
	if (ret < 0) {
--
  402ffb:	0f 88 d3 00 00 00    	js     4030d4 <sched_thd_wakeup+0x1e4>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  403001:	e8 5a 88 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(!t)) t = &g->idle_thd;
  403006:	41 be 40 1f 5a 00    	mov    r14d,0x5a1f40
	tok  = cos_sched_sync();
  40300c:	e8 ef e2 00 00       	call   411300 <cos_sched_sync>
  403011:	41 89 c5             	mov    r13d,eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  403014:	e8 77 f4 00 00       	call   412490 <slm_sched_fprr_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  403019:	48 85 c0             	test   rax,rax
--
  403026:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  403029:	83 f8 01             	cmp    eax,0x1
  40302c:	76 1a                	jbe    403048 <sched_thd_wakeup+0x158>
  40302e:	e9 19 01 00 00       	jmp    40314c <sched_thd_wakeup+0x25c>
  403033:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  403038:	f0 48 0f b1 15 7f ee 	lock cmpxchg QWORD PTR [rip+0x19ee7f],rdx        # 5a1ec0 <__slm_global>
  40303f:	19 00 
  403041:	0f 94 c0             	sete   al
	while (ret != 0) {
  403044:	84 c0                	test   al,al
  403046:	75 2e                	jne    403076 <sched_thd_wakeup+0x186>
		tok    = cos_sched_sync();
  403048:	e8 b3 e2 00 00       	call   411300 <cos_sched_sync>
  40304d:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  403056:	48 89 c2             	mov    rdx,rax
  403059:	83 e2 01             	and    edx,0x1
  40305c:	74 da                	je     403038 <sched_thd_wakeup+0x148>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  40305e:	48 89 c6             	mov    rsi,rax
--
  403064:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  403069:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  40306d:	e8 ee 07 01 00       	call   413860 <slm_cs_exit_contention>
  403072:	85 c0                	test   eax,eax
  403074:	75 d2                	jne    403048 <sched_thd_wakeup+0x158>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  403076:	e8 e5 87 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  40307b:	8b 03                	mov    eax,DWORD PTR [rbx]
--
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  403088:	a8 0b                	test   al,0xb
  40308a:	0f 85 d8 00 00 00    	jne    403168 <sched_thd_wakeup+0x278>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  403090:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  403094:	44 89 e9             	mov    ecx,r13d
  403097:	4c 89 c2             	mov    rdx,r8
  40309a:	e8 c1 96 00 00       	call   40c760 <cos_defswitch>
  40309f:	41 89 c7             	mov    r15d,eax
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  4030a2:	83 f8 ff             	cmp    eax,0xffffffff
  4030a5:	0f 84 65 01 00 00    	je     403210 <sched_thd_wakeup+0x320>
	if (unlikely(ret != 0)) {
  4030ab:	85 c0                	test   eax,eax
  4030ad:	0f 85 07 01 00 00    	jne    4031ba <sched_thd_wakeup+0x2ca>
	if (!t) return -1;
  4030b3:	45 31 ff             	xor    r15d,r15d
  4030b6:	e9 6f fe ff ff       	jmp    402f2a <sched_thd_wakeup+0x3a>
  4030bb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  4030c0:	f0 48 0f b1 15 f7 ed 	lock cmpxchg QWORD PTR [rip+0x19edf7],rdx        # 5a1ec0 <__slm_global>
  4030c7:	19 00 
  4030c9:	0f 94 c0             	sete   al
	while (ret != 0) {
  4030cc:	84 c0                	test   al,al
  4030ce:	0f 85 56 fe ff ff    	jne    402f2a <sched_thd_wakeup+0x3a>
		tok    = cos_sched_sync();
  4030d4:	e8 27 e2 00 00       	call   411300 <cos_sched_sync>
  4030d9:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  4030e2:	48 89 c2             	mov    rdx,rax
  4030e5:	83 e2 01             	and    edx,0x1
  4030e8:	74 d6                	je     4030c0 <sched_thd_wakeup+0x1d0>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  4030ea:	48 89 c6             	mov    rsi,rax
--
  4030f0:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  4030f5:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  4030f9:	e8 62 07 01 00       	call   413860 <slm_cs_exit_contention>
  4030fe:	85 c0                	test   eax,eax
  403100:	0f 84 24 fe ff ff    	je     402f2a <sched_thd_wakeup+0x3a>
  403106:	eb cc                	jmp    4030d4 <sched_thd_wakeup+0x1e4>
  403108:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40310f:	00 
--
  403119:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  40311e:	41 83 e0 01          	and    r8d,0x1
  403122:	e8 e9 06 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  403127:	83 f8 f0             	cmp    eax,0xfffffff0
  40312a:	0f 85 90 fe ff ff    	jne    402fc0 <sched_thd_wakeup+0xd0>
  403130:	be 59 00 00 00       	mov    esi,0x59
  403135:	bf c0 c7 41 00       	mov    edi,0x41c7c0
  40313a:	e8 91 6f 00 00       	call   40a0d0 <cos_print_str>
  40313f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403146:	00 00 00 00 
--
  40314c:	be 61 00 00 00       	mov    esi,0x61
  403151:	bf 48 c8 41 00       	mov    edi,0x41c848
  403156:	e8 75 6f 00 00       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  40315b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  403168:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  40316b:	48 81 fb c8 1e 5a 00 	cmp    rbx,0x5a1ec8
  403172:	0f 84 c6 00 00 00    	je     40323e <sched_thd_wakeup+0x34e>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  403178:	a8 02                	test   al,0x2
  40317a:	0f 85 f1 00 00 00    	jne    403271 <sched_thd_wakeup+0x381>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  403180:	49 89 c8             	mov    r8,rcx
  403183:	a8 01                	test   al,0x1
  403185:	0f 84 05 ff ff ff    	je     403090 <sched_thd_wakeup+0x1a0>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  40318b:	4c 8b 53 08          	mov    r10,QWORD PTR [rbx+0x8]
--
  403199:	4c 8b 05 48 ed 19 00 	mov    r8,QWORD PTR [rip+0x19ed48]        # 5a1ee8 <__slm_global+0x28>
  4031a0:	4c 89 d6             	mov    rsi,r10
  4031a3:	e8 78 e1 00 00       	call   411320 <cos_switch>
  4031a8:	41 89 c7             	mov    r15d,eax
	if (unlikely(ret != 0)) {
  4031ab:	45 85 ff             	test   r15d,r15d
  4031ae:	0f 84 ff fe ff ff    	je     4030b3 <sched_thd_wakeup+0x1c3>
		assert(ret != -EPERM);
  4031b4:	41 83 ff ff          	cmp    r15d,0xffffffff
  4031b8:	74 68                	je     403222 <sched_thd_wakeup+0x332>
		assert(ret != -EINVAL);
  4031ba:	41 83 ff ea          	cmp    r15d,0xffffffea
  4031be:	0f 84 cb 00 00 00    	je     40328f <sched_thd_wakeup+0x39f>
		if (ret == -EBUSY) return ret;
  4031c4:	41 83 ff f0          	cmp    r15d,0xfffffff0
  4031c8:	0f 84 5c fd ff ff    	je     402f2a <sched_thd_wakeup+0x3a>
		assert(ret == -EAGAIN);
  4031ce:	41 83 ff f5          	cmp    r15d,0xfffffff5
  4031d2:	0f 85 f8 00 00 00    	jne    4032d0 <sched_thd_wakeup+0x3e0>
		tok    = cos_sched_sync();
  4031d8:	e8 23 e1 00 00       	call   411300 <cos_sched_sync>
  4031dd:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  4031e7:	48 89 c1             	mov    rcx,rax
  4031ea:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  4031ee:	0f 85 b7 00 00 00    	jne    4032ab <sched_thd_wakeup+0x3bb>
  4031f4:	f0 4c 0f b1 25 c3 ec 	lock cmpxchg QWORD PTR [rip+0x19ecc3],r12        # 5a1ec0 <__slm_global>
  4031fb:	19 00 
  4031fd:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  403200:	84 c0                	test   al,al
  403202:	0f 85 04 fe ff ff    	jne    40300c <sched_thd_wakeup+0x11c>
  403208:	eb ce                	jmp    4031d8 <sched_thd_wakeup+0x2e8>
  40320a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	return t != &g->idle_thd && t != &g->sched_thd;
  403210:	48 81 fb 40 1f 5a 00 	cmp    rbx,0x5a1f40
  403217:	74 31                	je     40324a <sched_thd_wakeup+0x35a>
  403219:	48 81 fb c8 1e 5a 00 	cmp    rbx,0x5a1ec8
  403220:	74 28                	je     40324a <sched_thd_wakeup+0x35a>
  403222:	be 61 00 00 00       	mov    esi,0x61
  403227:	bf b0 c8 41 00       	mov    edi,0x41c8b0
  40322c:	e8 9f 6e 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EPERM);
  403231:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
			timeout = TCAP_TIME_NIL;
  403243:	31 c9                	xor    ecx,ecx
  403245:	e9 2e ff ff ff       	jmp    403178 <sched_thd_wakeup+0x288>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  40324a:	49 8b 54 24 30       	mov    rdx,QWORD PTR [r12+0x30]
--
  40325a:	48 8b 3d 77 ec 19 00 	mov    rdi,QWORD PTR [rip+0x19ec77]        # 5a1ed8 <__slm_global+0x18>
  403261:	45 89 e9             	mov    r9d,r13d
  403264:	e8 b7 e0 00 00       	call   411320 <cos_switch>
  403269:	41 89 c7             	mov    r15d,eax
  40326c:	e9 3a ff ff ff       	jmp    4031ab <sched_thd_wakeup+0x2bb>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  403271:	48 8b 7b 28          	mov    rdi,QWORD PTR [rbx+0x28]
--
  40327c:	44 89 e9             	mov    ecx,r13d
  40327f:	4c 89 c6             	mov    rsi,r8
  403282:	e8 09 e1 00 00       	call   411390 <cos_sched_asnd>
  403287:	41 89 c7             	mov    r15d,eax
  40328a:	e9 1c ff ff ff       	jmp    4031ab <sched_thd_wakeup+0x2bb>
  40328f:	be 61 00 00 00       	mov    esi,0x61
  403294:	bf 18 c9 41 00       	mov    edi,0x41c918
  403299:	e8 32 6e 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  40329e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  4032b4:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  4032b9:	41 83 e0 01          	and    r8d,0x1
  4032bd:	e8 4e 05 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  4032c2:	83 f8 f0             	cmp    eax,0xfffffff0
  4032c5:	0f 85 0d ff ff ff    	jne    4031d8 <sched_thd_wakeup+0x2e8>
  4032cb:	e9 60 fe ff ff       	jmp    403130 <sched_thd_wakeup+0x240>
  4032d0:	be 61 00 00 00       	mov    esi,0x61
  4032d5:	bf 80 c9 41 00       	mov    edi,0x41c980
  4032da:	e8 f1 6d 00 00       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  4032df:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  4032f4:	85 ff                	test   edi,edi
  4032f6:	0f 84 6e 1b 01 00    	je     414e6a <sched_debug_thd_state.cold>
  4032fc:	83 ef 01             	sub    edi,0x1
  4032ff:	83 ff 18             	cmp    edi,0x18
  403302:	0f 87 62 1b 01 00    	ja     414e6a <sched_debug_thd_state.cold>
  403308:	48 8b 04 fd 00 e7 45 	mov    rax,QWORD PTR [rdi*8+0x45e700]
  40330f:	00 
  403310:	48 a9 fe ff ff ff    	test   rax,0xfffffffffffffffe
  403316:	0f 84 4e 1b 01 00    	je     414e6a <sched_debug_thd_state.cold>
  40331c:	a8 01                	test   al,0x1
  40331e:	0f 85 46 1b 01 00    	jne    414e6a <sched_debug_thd_state.cold>
	return t->state;
  403324:	48 8d 04 bf          	lea    rax,[rdi+rdi*4]
--
	if (dep_id) return 0;
  403344:	48 85 ff             	test   rdi,rdi
  403347:	74 07                	je     403350 <sched_thd_block_timeout+0x10>
  403349:	31 c0                	xor    eax,eax
}
--
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403374:	48 85 c0             	test   rax,rax
  403377:	0f 84 bb 01 00 00    	je     403538 <sched_thd_block_timeout+0x1f8>
  40337d:	83 e8 01             	sub    eax,0x1
  403380:	83 f8 18             	cmp    eax,0x18
  403383:	0f 87 af 01 00 00    	ja     403538 <sched_thd_block_timeout+0x1f8>
  403389:	48 8b 14 c5 00 e7 45 	mov    rdx,QWORD PTR [rax*8+0x45e700]
--
  403391:	45 31 e4             	xor    r12d,r12d
  403394:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  40339b:	0f 85 5f 01 00 00    	jne    403500 <sched_thd_block_timeout+0x1c0>
static inline ps_tsc_t
ps_tsc(void)
--
	assert(current);
  4033b9:	4d 85 e4             	test   r12,r12
  4033bc:	0f 84 ba 01 00 00    	je     40357c <sched_thd_block_timeout+0x23c>
		tok    = cos_sched_sync();
  4033c2:	e8 39 df 00 00       	call   411300 <cos_sched_sync>
  4033c7:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  4033d1:	48 89 c1             	mov    rcx,rax
  4033d4:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  4033d8:	0f 85 62 01 00 00    	jne    403540 <sched_thd_block_timeout+0x200>
        __asm__ __volatile__("lock " PS_CAS_STR
  4033de:	f0 4c 0f b1 25 d9 ea 	lock cmpxchg QWORD PTR [rip+0x19ead9],r12        # 5a1ec0 <__slm_global>
  4033e5:	19 00 
  4033e7:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4033ea:	84 c0                	test   al,al
  4033ec:	74 d4                	je     4033c2 <sched_thd_block_timeout+0x82>
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  4033ee:	4c 89 ee             	mov    rsi,r13
  4033f1:	4c 89 e7             	mov    rdi,r12
  4033f4:	e8 57 f8 00 00       	call   412c50 <slm_timer_quantum_add>
		if (slm_timer_add(current, timeout)) goto done;
  4033f9:	85 c0                	test   eax,eax
  4033fb:	75 10                	jne    40340d <sched_thd_block_timeout+0xcd>
		if (slm_thd_block(current)) {
  4033fd:	4c 89 e7             	mov    rdi,r12
  403400:	e8 bb 04 01 00       	call   4138c0 <slm_thd_block>
  403405:	85 c0                	test   eax,eax
  403407:	0f 85 1b 01 00 00    	jne    403528 <sched_thd_block_timeout+0x1e8>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  40340d:	e8 4e 84 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	tok  = cos_sched_sync();
  403412:	e8 e9 de 00 00       	call   411300 <cos_sched_sync>
  403417:	41 89 c6             	mov    r14d,eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  40341a:	e8 71 f0 00 00       	call   412490 <slm_sched_fprr_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  40341f:	48 85 c0             	test   rax,rax
--
  403431:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  403434:	83 f8 01             	cmp    eax,0x1
  403437:	76 17                	jbe    403450 <sched_thd_block_timeout+0x110>
  403439:	e9 5a 01 00 00       	jmp    403598 <sched_thd_block_timeout+0x258>
  40343e:	66 90                	xchg   ax,ax
  403440:	f0 48 0f b1 15 77 ea 	lock cmpxchg QWORD PTR [rip+0x19ea77],rdx        # 5a1ec0 <__slm_global>
  403447:	19 00 
  403449:	0f 94 c0             	sete   al
	while (ret != 0) {
  40344c:	84 c0                	test   al,al
  40344e:	75 2e                	jne    40347e <sched_thd_block_timeout+0x13e>
		tok    = cos_sched_sync();
  403450:	e8 ab de 00 00       	call   411300 <cos_sched_sync>
  403455:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  40345e:	48 89 c2             	mov    rdx,rax
  403461:	83 e2 01             	and    edx,0x1
  403464:	74 da                	je     403440 <sched_thd_block_timeout+0x100>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  403466:	48 89 c6             	mov    rsi,rax
--
  40346c:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  403471:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  403475:	e8 e6 03 01 00       	call   413860 <slm_cs_exit_contention>
  40347a:	85 c0                	test   eax,eax
  40347c:	75 d2                	jne    403450 <sched_thd_block_timeout+0x110>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  40347e:	e8 dd 83 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  403483:	8b 03                	mov    eax,DWORD PTR [rbx]
--
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  403490:	a8 0b                	test   al,0xb
  403492:	0f 85 1c 01 00 00    	jne    4035b4 <sched_thd_block_timeout+0x274>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  403498:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  40349c:	44 89 f1             	mov    ecx,r14d
  40349f:	4c 89 c2             	mov    rdx,r8
  4034a2:	e8 b9 92 00 00       	call   40c760 <cos_defswitch>
  4034a7:	41 89 c7             	mov    r15d,eax
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  4034aa:	83 f8 ff             	cmp    eax,0xffffffff
  4034ad:	0f 84 e5 01 00 00    	je     403698 <sched_thd_block_timeout+0x358>
	if (unlikely(ret != 0)) {
  4034b3:	85 c0                	test   eax,eax
  4034b5:	0f 85 4f 01 00 00    	jne    40360a <sched_thd_block_timeout+0x2ca>
  4034bb:	45 31 ff             	xor    r15d,r15d
  4034be:	4c 89 e7             	mov    rdi,r12
  4034c1:	e8 1a f8 00 00       	call   412ce0 <slm_timer_quantum_cancel>
	__asm__ __volatile__("rdtsc" : "=a" (a), "=d" (d), "=c" (c) : : );
  4034c6:	0f 31                	rdtsc  
--
	while (cycles_greater_than(timeout, slm_now())) {
  4034d5:	48 85 c0             	test   rax,rax
  4034d8:	0f 8f e4 fe ff ff    	jg     4033c2 <sched_thd_block_timeout+0x82>
	if (dep_id) return 0;
  4034de:	31 c0                	xor    eax,eax
	if (thd_block_until(abs_timeout)) return 0;
  4034e0:	45 85 ff             	test   r15d,r15d
  4034e3:	0f 84 77 01 00 00    	je     403660 <sched_thd_block_timeout+0x320>
}
  4034e9:	48 83 c4 08          	add    rsp,0x8
--
  4034ff:	00 
  403500:	83 e2 01             	and    edx,0x1
  403503:	0f 85 98 fe ff ff    	jne    4033a1 <sched_thd_block_timeout+0x61>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403509:	48 8d 14 80          	lea    rdx,[rax+rax*4]
--
  403511:	49 c1 e4 04          	shl    r12,0x4
  403515:	49 81 c4 c8 e7 45 00 	add    r12,0x45e7c8
  40351c:	e9 80 fe ff ff       	jmp    4033a1 <sched_thd_block_timeout+0x61>
  403521:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  403528:	4c 89 e7             	mov    rdi,r12
  40352b:	e8 b0 f7 00 00       	call   412ce0 <slm_timer_quantum_cancel>
  403530:	e9 d8 fe ff ff       	jmp    40340d <sched_thd_block_timeout+0xcd>
  403535:	0f 1f 00             	nop    DWORD PTR [rax]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403538:	45 31 e4             	xor    r12d,r12d
  40353b:	e9 61 fe ff ff       	jmp    4033a1 <sched_thd_block_timeout+0x61>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  403540:	41 89 c0             	mov    r8d,eax
--
  403549:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  40354e:	41 83 e0 01          	and    r8d,0x1
  403552:	e8 b9 02 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  403557:	83 f8 f0             	cmp    eax,0xfffffff0
  40355a:	0f 85 62 fe ff ff    	jne    4033c2 <sched_thd_block_timeout+0x82>
  403560:	be 59 00 00 00       	mov    esi,0x59
  403565:	bf c0 c7 41 00       	mov    edi,0x41c7c0
  40356a:	e8 61 6b 00 00       	call   40a0d0 <cos_print_str>
  40356f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403576:	00 00 00 00 
--
  40357c:	be 59 00 00 00       	mov    esi,0x59
  403581:	bf 60 c7 41 00       	mov    edi,0x41c760
  403586:	e8 45 6b 00 00       	call   40a0d0 <cos_print_str>
	assert(current);
  40358b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  403598:	be 61 00 00 00       	mov    esi,0x61
  40359d:	bf 48 c8 41 00       	mov    edi,0x41c848
  4035a2:	e8 29 6b 00 00       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  4035a7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  4035b4:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  4035b7:	48 81 fb c8 1e 5a 00 	cmp    rbx,0x5a1ec8
  4035be:	0f 84 02 01 00 00    	je     4036c6 <sched_thd_block_timeout+0x386>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  4035c4:	a8 02                	test   al,0x2
  4035c6:	0f 85 06 01 00 00    	jne    4036d2 <sched_thd_block_timeout+0x392>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  4035cc:	49 89 c8             	mov    r8,rcx
  4035cf:	a8 01                	test   al,0x1
  4035d1:	0f 84 c1 fe ff ff    	je     403498 <sched_thd_block_timeout+0x158>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  4035d7:	4c 8b 53 08          	mov    r10,QWORD PTR [rbx+0x8]
--
  4035e5:	4c 8b 05 fc e8 19 00 	mov    r8,QWORD PTR [rip+0x19e8fc]        # 5a1ee8 <__slm_global+0x28>
  4035ec:	4c 89 d6             	mov    rsi,r10
  4035ef:	e8 2c dd 00 00       	call   411320 <cos_switch>
  4035f4:	41 89 c7             	mov    r15d,eax
	if (unlikely(ret != 0)) {
  4035f7:	45 85 ff             	test   r15d,r15d
  4035fa:	0f 84 bb fe ff ff    	je     4034bb <sched_thd_block_timeout+0x17b>
		assert(ret != -EPERM);
  403600:	41 83 ff ff          	cmp    r15d,0xffffffff
  403604:	0f 84 a0 00 00 00    	je     4036aa <sched_thd_block_timeout+0x36a>
		assert(ret != -EINVAL);
  40360a:	41 83 ff ea          	cmp    r15d,0xffffffea
  40360e:	0f 84 03 01 00 00    	je     403717 <sched_thd_block_timeout+0x3d7>
		if (ret == -EBUSY) return ret;
  403614:	41 83 ff f0          	cmp    r15d,0xfffffff0
  403618:	0f 84 a0 fe ff ff    	je     4034be <sched_thd_block_timeout+0x17e>
		assert(ret == -EAGAIN);
  40361e:	41 83 ff f5          	cmp    r15d,0xfffffff5
  403622:	0f 85 0b 01 00 00    	jne    403733 <sched_thd_block_timeout+0x3f3>
		tok    = cos_sched_sync();
  403628:	e8 d3 dc 00 00       	call   411300 <cos_sched_sync>
  40362d:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  403637:	48 89 c1             	mov    rcx,rax
  40363a:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  40363e:	0f 85 0b 01 00 00    	jne    40374f <sched_thd_block_timeout+0x40f>
        __asm__ __volatile__("lock " PS_CAS_STR
  403644:	f0 4c 0f b1 25 73 e8 	lock cmpxchg QWORD PTR [rip+0x19e873],r12        # 5a1ec0 <__slm_global>
  40364b:	19 00 
  40364d:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  403650:	84 c0                	test   al,al
  403652:	0f 85 ba fd ff ff    	jne    403412 <sched_thd_block_timeout+0xd2>
  403658:	eb ce                	jmp    403628 <sched_thd_block_timeout+0x2e8>
  40365a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	__asm__ __volatile__("rdtsc" : "=a" (a), "=d" (d), "=c" (c) : : );
--
	assert(cycles_greater_than(now, abs_timeout));
  40366f:	48 85 d2             	test   rdx,rdx
  403672:	0f 8f 71 fe ff ff    	jg     4034e9 <sched_thd_block_timeout+0x1a9>
  403678:	be 24 00 00 00       	mov    esi,0x24
  40367d:	bf 88 cc 41 00       	mov    edi,0x41cc88
  403682:	e8 49 6a 00 00       	call   40a0d0 <cos_print_str>
  403687:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40368e:	00 00 00 00 
--
  403694:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	return t != &g->idle_thd && t != &g->sched_thd;
  403698:	48 81 fb 40 1f 5a 00 	cmp    rbx,0x5a1f40
  40369f:	74 4f                	je     4036f0 <sched_thd_block_timeout+0x3b0>
  4036a1:	48 81 fb c8 1e 5a 00 	cmp    rbx,0x5a1ec8
  4036a8:	74 46                	je     4036f0 <sched_thd_block_timeout+0x3b0>
  4036aa:	be 61 00 00 00       	mov    esi,0x61
  4036af:	bf b0 c8 41 00       	mov    edi,0x41c8b0
  4036b4:	e8 17 6a 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EPERM);
  4036b9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
			timeout = TCAP_TIME_NIL;
  4036cb:	31 c9                	xor    ecx,ecx
  4036cd:	e9 f2 fe ff ff       	jmp    4035c4 <sched_thd_block_timeout+0x284>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  4036d2:	48 8b 7b 28          	mov    rdi,QWORD PTR [rbx+0x28]
--
  4036dd:	44 89 f1             	mov    ecx,r14d
  4036e0:	4c 89 c6             	mov    rsi,r8
  4036e3:	e8 a8 dc 00 00       	call   411390 <cos_sched_asnd>
  4036e8:	41 89 c7             	mov    r15d,eax
  4036eb:	e9 07 ff ff ff       	jmp    4035f7 <sched_thd_block_timeout+0x2b7>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  4036f0:	49 8b 54 24 30       	mov    rdx,QWORD PTR [r12+0x30]
--
  403700:	48 8b 3d d1 e7 19 00 	mov    rdi,QWORD PTR [rip+0x19e7d1]        # 5a1ed8 <__slm_global+0x18>
  403707:	45 89 f1             	mov    r9d,r14d
  40370a:	e8 11 dc 00 00       	call   411320 <cos_switch>
  40370f:	41 89 c7             	mov    r15d,eax
  403712:	e9 e0 fe ff ff       	jmp    4035f7 <sched_thd_block_timeout+0x2b7>
  403717:	be 61 00 00 00       	mov    esi,0x61
  40371c:	bf 18 c9 41 00       	mov    edi,0x41c918
  403721:	e8 aa 69 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  403726:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  403733:	be 61 00 00 00       	mov    esi,0x61
  403738:	bf 80 c9 41 00       	mov    edi,0x41c980
  40373d:	e8 8e 69 00 00       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  403742:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  403758:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  40375d:	41 83 e0 01          	and    r8d,0x1
  403761:	e8 aa 00 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  403766:	83 f8 f0             	cmp    eax,0xfffffff0
  403769:	0f 85 b9 fe ff ff    	jne    403628 <sched_thd_block_timeout+0x2e8>
  40376f:	be 59 00 00 00       	mov    esi,0x59
  403774:	bf c0 c7 41 00       	mov    edi,0x41c7c0
  403779:	e8 52 69 00 00       	call   40a0d0 <cos_print_str>
  40377e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403785:	00 00 00 00 
--
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  4037c2:	48 85 c0             	test   rax,rax
  4037c5:	0f 84 ad 01 00 00    	je     403978 <thd_sleep+0x1e8>
  4037cb:	83 e8 01             	sub    eax,0x1
  4037ce:	83 f8 18             	cmp    eax,0x18
  4037d1:	0f 87 a1 01 00 00    	ja     403978 <thd_sleep+0x1e8>
  4037d7:	48 8b 14 c5 00 e7 45 	mov    rdx,QWORD PTR [rax*8+0x45e700]
--
  4037df:	45 31 e4             	xor    r12d,r12d
  4037e2:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  4037e9:	0f 85 51 01 00 00    	jne    403940 <thd_sleep+0x1b0>
	__asm__ __volatile__("rdtsc" : "=a" (a), "=d" (d), "=c" (c) : : );
  4037ef:	0f 31                	rdtsc  
--
	assert(current);
  403807:	4d 85 e4             	test   r12,r12
  40380a:	0f 84 ac 01 00 00    	je     4039bc <thd_sleep+0x22c>
		tok    = cos_sched_sync();
  403810:	e8 eb da 00 00       	call   411300 <cos_sched_sync>
  403815:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  40381f:	48 89 c1             	mov    rcx,rax
  403822:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  403826:	0f 85 54 01 00 00    	jne    403980 <thd_sleep+0x1f0>
        __asm__ __volatile__("lock " PS_CAS_STR
  40382c:	f0 4c 0f b1 25 8b e6 	lock cmpxchg QWORD PTR [rip+0x19e68b],r12        # 5a1ec0 <__slm_global>
  403833:	19 00 
  403835:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  403838:	84 c0                	test   al,al
  40383a:	74 d4                	je     403810 <thd_sleep+0x80>
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  40383c:	4c 89 ee             	mov    rsi,r13
  40383f:	4c 89 e7             	mov    rdi,r12
  403842:	e8 09 f4 00 00       	call   412c50 <slm_timer_quantum_add>
		if (slm_timer_add(current, timeout)) goto done;
  403847:	85 c0                	test   eax,eax
  403849:	75 10                	jne    40385b <thd_sleep+0xcb>
		if (slm_thd_block(current)) {
  40384b:	4c 89 e7             	mov    rdi,r12
  40384e:	e8 6d 00 01 00       	call   4138c0 <slm_thd_block>
  403853:	85 c0                	test   eax,eax
  403855:	0f 85 0d 01 00 00    	jne    403968 <thd_sleep+0x1d8>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  40385b:	e8 00 80 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	tok  = cos_sched_sync();
  403860:	e8 9b da 00 00       	call   411300 <cos_sched_sync>
  403865:	41 89 c6             	mov    r14d,eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  403868:	e8 23 ec 00 00       	call   412490 <slm_sched_fprr_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  40386d:	48 85 c0             	test   rax,rax
--
  40387f:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  403882:	83 f8 01             	cmp    eax,0x1
  403885:	76 19                	jbe    4038a0 <thd_sleep+0x110>
  403887:	e9 4c 01 00 00       	jmp    4039d8 <thd_sleep+0x248>
  40388c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  403890:	f0 48 0f b1 15 27 e6 	lock cmpxchg QWORD PTR [rip+0x19e627],rdx        # 5a1ec0 <__slm_global>
  403897:	19 00 
  403899:	0f 94 c0             	sete   al
	while (ret != 0) {
  40389c:	84 c0                	test   al,al
  40389e:	75 2e                	jne    4038ce <thd_sleep+0x13e>
		tok    = cos_sched_sync();
  4038a0:	e8 5b da 00 00       	call   411300 <cos_sched_sync>
  4038a5:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  4038ae:	48 89 c2             	mov    rdx,rax
  4038b1:	83 e2 01             	and    edx,0x1
  4038b4:	74 da                	je     403890 <thd_sleep+0x100>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  4038b6:	48 89 c6             	mov    rsi,rax
--
  4038bc:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  4038c1:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  4038c5:	e8 96 ff 00 00       	call   413860 <slm_cs_exit_contention>
  4038ca:	85 c0                	test   eax,eax
  4038cc:	75 d2                	jne    4038a0 <thd_sleep+0x110>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  4038ce:	e8 8d 7f 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4038d3:	8b 03                	mov    eax,DWORD PTR [rbx]
--
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4038e0:	a8 0b                	test   al,0xb
  4038e2:	0f 85 0c 01 00 00    	jne    4039f4 <thd_sleep+0x264>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  4038e8:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  4038ec:	44 89 f1             	mov    ecx,r14d
  4038ef:	4c 89 c2             	mov    rdx,r8
  4038f2:	e8 69 8e 00 00       	call   40c760 <cos_defswitch>
  4038f7:	41 89 c7             	mov    r15d,eax
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  4038fa:	83 f8 ff             	cmp    eax,0xffffffff
  4038fd:	0f 84 32 01 00 00    	je     403a35 <thd_sleep+0x2a5>
	if (unlikely(ret != 0)) {
  403903:	85 c0                	test   eax,eax
  403905:	0f 85 92 01 00 00    	jne    403a9d <thd_sleep+0x30d>
  40390b:	45 31 ff             	xor    r15d,r15d
  40390e:	4c 89 e7             	mov    rdi,r12
  403911:	e8 ca f3 00 00       	call   412ce0 <slm_timer_quantum_cancel>
	__asm__ __volatile__("rdtsc" : "=a" (a), "=d" (d), "=c" (c) : : );
  403916:	0f 31                	rdtsc  
--
	while (cycles_greater_than(timeout, slm_now())) {
  403925:	48 85 c0             	test   rax,rax
  403928:	0f 8f e2 fe ff ff    	jg     403810 <thd_sleep+0x80>
}
  40392e:	48 83 c4 08          	add    rsp,0x8
--
  40393f:	c3                   	ret    
  403940:	83 e2 01             	and    edx,0x1
  403943:	0f 85 a6 fe ff ff    	jne    4037ef <thd_sleep+0x5f>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403949:	48 8d 14 80          	lea    rdx,[rax+rax*4]
--
  403951:	49 c1 e4 04          	shl    r12,0x4
  403955:	49 81 c4 c8 e7 45 00 	add    r12,0x45e7c8
  40395c:	e9 8e fe ff ff       	jmp    4037ef <thd_sleep+0x5f>
  403961:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  403968:	4c 89 e7             	mov    rdi,r12
  40396b:	e8 70 f3 00 00       	call   412ce0 <slm_timer_quantum_cancel>
  403970:	e9 e6 fe ff ff       	jmp    40385b <thd_sleep+0xcb>
  403975:	0f 1f 00             	nop    DWORD PTR [rax]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403978:	45 31 e4             	xor    r12d,r12d
  40397b:	e9 6f fe ff ff       	jmp    4037ef <thd_sleep+0x5f>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  403980:	41 89 c0             	mov    r8d,eax
--
  403989:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  40398e:	41 83 e0 01          	and    r8d,0x1
  403992:	e8 79 fe 00 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  403997:	83 f8 f0             	cmp    eax,0xfffffff0
  40399a:	0f 85 70 fe ff ff    	jne    403810 <thd_sleep+0x80>
  4039a0:	be 59 00 00 00       	mov    esi,0x59
  4039a5:	bf c0 c7 41 00       	mov    edi,0x41c7c0
  4039aa:	e8 21 67 00 00       	call   40a0d0 <cos_print_str>
  4039af:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4039b6:	00 00 00 00 
--
  4039bc:	be 59 00 00 00       	mov    esi,0x59
  4039c1:	bf 60 c7 41 00       	mov    edi,0x41c760
  4039c6:	e8 05 67 00 00       	call   40a0d0 <cos_print_str>
	assert(current);
  4039cb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  4039d8:	be 61 00 00 00       	mov    esi,0x61
  4039dd:	bf 48 c8 41 00       	mov    edi,0x41c848
  4039e2:	e8 e9 66 00 00       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  4039e7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  4039f4:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  4039f7:	48 81 fb c8 1e 5a 00 	cmp    rbx,0x5a1ec8
  4039fe:	74 63                	je     403a63 <thd_sleep+0x2d3>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  403a00:	a8 02                	test   al,0x2
  403a02:	0f 85 e1 00 00 00    	jne    403ae9 <thd_sleep+0x359>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  403a08:	49 89 c8             	mov    r8,rcx
  403a0b:	a8 01                	test   al,0x1
  403a0d:	0f 84 d5 fe ff ff    	je     4038e8 <thd_sleep+0x158>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  403a13:	4c 8b 53 08          	mov    r10,QWORD PTR [rbx+0x8]
--
  403a21:	4c 8b 05 c0 e4 19 00 	mov    r8,QWORD PTR [rip+0x19e4c0]        # 5a1ee8 <__slm_global+0x28>
  403a28:	4c 89 d6             	mov    rsi,r10
  403a2b:	e8 f0 d8 00 00       	call   411320 <cos_switch>
  403a30:	41 89 c7             	mov    r15d,eax
  403a33:	eb 59                	jmp    403a8e <thd_sleep+0x2fe>
	return t != &g->idle_thd && t != &g->sched_thd;
  403a35:	48 81 fb 40 1f 5a 00 	cmp    rbx,0x5a1f40
  403a3c:	74 2e                	je     403a6c <thd_sleep+0x2dc>
  403a3e:	48 81 fb c8 1e 5a 00 	cmp    rbx,0x5a1ec8
  403a45:	74 25                	je     403a6c <thd_sleep+0x2dc>
  403a47:	be 61 00 00 00       	mov    esi,0x61
  403a4c:	bf b0 c8 41 00       	mov    edi,0x41c8b0
  403a51:	e8 7a 66 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EPERM);
  403a56:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
			timeout = TCAP_TIME_NIL;
  403a68:	31 c9                	xor    ecx,ecx
  403a6a:	eb 94                	jmp    403a00 <thd_sleep+0x270>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  403a6c:	49 8b 54 24 30       	mov    rdx,QWORD PTR [r12+0x30]
--
  403a7c:	48 8b 3d 55 e4 19 00 	mov    rdi,QWORD PTR [rip+0x19e455]        # 5a1ed8 <__slm_global+0x18>
  403a83:	45 89 f1             	mov    r9d,r14d
  403a86:	e8 95 d8 00 00       	call   411320 <cos_switch>
  403a8b:	41 89 c7             	mov    r15d,eax
	if (unlikely(ret != 0)) {
  403a8e:	45 85 ff             	test   r15d,r15d
  403a91:	0f 84 74 fe ff ff    	je     40390b <thd_sleep+0x17b>
		assert(ret != -EPERM);
  403a97:	41 83 ff ff          	cmp    r15d,0xffffffff
  403a9b:	74 aa                	je     403a47 <thd_sleep+0x2b7>
		assert(ret != -EINVAL);
  403a9d:	41 83 ff ea          	cmp    r15d,0xffffffea
  403aa1:	74 61                	je     403b04 <thd_sleep+0x374>
		if (ret == -EBUSY) return ret;
  403aa3:	41 83 ff f0          	cmp    r15d,0xfffffff0
  403aa7:	0f 84 61 fe ff ff    	je     40390e <thd_sleep+0x17e>
		assert(ret == -EAGAIN);
  403aad:	41 83 ff f5          	cmp    r15d,0xfffffff5
  403ab1:	75 6d                	jne    403b20 <thd_sleep+0x390>
		tok    = cos_sched_sync();
  403ab3:	e8 48 d8 00 00       	call   411300 <cos_sched_sync>
  403ab8:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  403ac2:	48 89 c1             	mov    rcx,rax
  403ac5:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  403ac9:	75 71                	jne    403b3c <thd_sleep+0x3ac>
        __asm__ __volatile__("lock " PS_CAS_STR
  403acb:	f0 4c 0f b1 25 ec e3 	lock cmpxchg QWORD PTR [rip+0x19e3ec],r12        # 5a1ec0 <__slm_global>
  403ad2:	19 00 
  403ad4:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  403ad7:	84 c0                	test   al,al
  403ad9:	0f 85 81 fd ff ff    	jne    403860 <thd_sleep+0xd0>
  403adf:	eb d2                	jmp    403ab3 <thd_sleep+0x323>
	int ret = 0;
  403ae1:	45 31 ff             	xor    r15d,r15d
	return thd_block_until(timeout);
  403ae4:	e9 45 fe ff ff       	jmp    40392e <thd_sleep+0x19e>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  403ae9:	48 8b 7b 28          	mov    rdi,QWORD PTR [rbx+0x28]
--
  403af4:	44 89 f1             	mov    ecx,r14d
  403af7:	4c 89 c6             	mov    rsi,r8
  403afa:	e8 91 d8 00 00       	call   411390 <cos_sched_asnd>
  403aff:	41 89 c7             	mov    r15d,eax
  403b02:	eb 8a                	jmp    403a8e <thd_sleep+0x2fe>
  403b04:	be 61 00 00 00       	mov    esi,0x61
  403b09:	bf 18 c9 41 00       	mov    edi,0x41c918
  403b0e:	e8 bd 65 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  403b13:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  403b20:	be 61 00 00 00       	mov    esi,0x61
  403b25:	bf 80 c9 41 00       	mov    edi,0x41c980
  403b2a:	e8 a1 65 00 00       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  403b2f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  403b45:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  403b4a:	41 83 e0 01          	and    r8d,0x1
  403b4e:	e8 bd fc 00 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  403b53:	83 f8 f0             	cmp    eax,0xfffffff0
  403b56:	0f 85 57 ff ff ff    	jne    403ab3 <thd_sleep+0x323>
  403b5c:	e9 3f fe ff ff       	jmp    4039a0 <thd_sleep+0x210>
  403b61:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  403b68:	00 00 00 00 
--
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403b8e:	48 85 c0             	test   rax,rax
  403b91:	0f 84 09 01 00 00    	je     403ca0 <sched_blkpt_alloc+0x130>
  403b97:	83 e8 01             	sub    eax,0x1
  403b9a:	83 f8 18             	cmp    eax,0x18
  403b9d:	0f 87 fd 00 00 00    	ja     403ca0 <sched_blkpt_alloc+0x130>
  403ba3:	48 8b 14 c5 00 e7 45 	mov    rdx,QWORD PTR [rax*8+0x45e700]
  403baa:	00 
  403bab:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  403bb2:	0f 84 e8 00 00 00    	je     403ca0 <sched_blkpt_alloc+0x130>
  403bb8:	83 e2 01             	and    edx,0x1
  403bbb:	0f 85 df 00 00 00    	jne    403ca0 <sched_blkpt_alloc+0x130>
	return &ss_thd_get(cos_thdid())->thd;
  403bc1:	48 8d 14 80          	lea    rdx,[rax+rax*4]
--
  403bcd:	49 81 c4 c8 e7 45 00 	add    r12,0x45e7c8
		tok    = cos_sched_sync();
  403bd4:	e8 27 d7 00 00       	call   411300 <cos_sched_sync>
  403bd9:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  403be3:	48 89 c1             	mov    rcx,rax
  403be6:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  403bea:	0f 85 d0 00 00 00    	jne    403cc0 <sched_blkpt_alloc+0x150>
  403bf0:	f0 4c 0f b1 25 c7 e2 	lock cmpxchg QWORD PTR [rip+0x19e2c7],r12        # 5a1ec0 <__slm_global>
  403bf7:	19 00 
  403bf9:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  403bfc:	84 c0                	test   al,al
  403bfe:	74 d4                	je     403bd4 <sched_blkpt_alloc+0x64>
	id = (sched_blkpt_id_t)__blkpt_offset;
  403c00:	44 8b 25 f9 03 02 00 	mov    r12d,DWORD PTR [rip+0x203f9]        # 424000 <__blkpt_offset>
	if (id - 1 == NBLKPTS) return NULL;
  403c07:	41 81 fc 01 a0 00 00 	cmp    r12d,0xa001
  403c0e:	0f 84 e8 00 00 00    	je     403cfc <sched_blkpt_alloc+0x18c>
	return &__blkpts[id-1];
  403c14:	41 8d 44 24 ff       	lea    eax,[r12-0x1]
--
  403c45:	41 8d 44 24 01       	lea    eax,[r12+0x1]
  403c4a:	89 05 b0 03 02 00    	mov    DWORD PTR [rip+0x203b0],eax        # 424000 <__blkpt_offset>
  403c50:	eb 16                	jmp    403c68 <sched_blkpt_alloc+0xf8>
  403c52:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  403c58:	f0 48 0f b1 15 5f e2 	lock cmpxchg QWORD PTR [rip+0x19e25f],rdx        # 5a1ec0 <__slm_global>
  403c5f:	19 00 
  403c61:	0f 94 c0             	sete   al
	while (ret != 0) {
  403c64:	84 c0                	test   al,al
  403c66:	75 2e                	jne    403c96 <sched_blkpt_alloc+0x126>
		tok    = cos_sched_sync();
  403c68:	e8 93 d6 00 00       	call   411300 <cos_sched_sync>
  403c6d:	89 c1                	mov    ecx,eax
  403c6f:	48 8b 05 4a e2 19 00 	mov    rax,QWORD PTR [rip+0x19e24a]        # 5a1ec0 <__slm_global>
--
  403c76:	48 89 c2             	mov    rdx,rax
  403c79:	83 e2 01             	and    edx,0x1
  403c7c:	74 da                	je     403c58 <sched_blkpt_alloc+0xe8>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  403c7e:	48 89 c6             	mov    rsi,rax
--
  403c84:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  403c89:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  403c8d:	e8 ce fb 00 00       	call   413860 <slm_cs_exit_contention>
  403c92:	85 c0                	test   eax,eax
  403c94:	75 d2                	jne    403c68 <sched_blkpt_alloc+0xf8>
}
  403c96:	44 89 e0             	mov    eax,r12d
--
  403ca0:	be 59 00 00 00       	mov    esi,0x59
  403ca5:	bf 60 c7 41 00       	mov    edi,0x41c760
  403caa:	e8 21 64 00 00       	call   40a0d0 <cos_print_str>
	assert(current);
  403caf:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  403cc9:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  403cce:	41 83 e0 01          	and    r8d,0x1
  403cd2:	e8 39 fb 00 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  403cd7:	83 f8 f0             	cmp    eax,0xfffffff0
  403cda:	0f 85 f4 fe ff ff    	jne    403bd4 <sched_blkpt_alloc+0x64>
  403ce0:	be 59 00 00 00       	mov    esi,0x59
  403ce5:	bf c0 c7 41 00       	mov    edi,0x41c7c0
  403cea:	e8 e1 63 00 00       	call   40a0d0 <cos_print_str>
  403cef:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403cf6:	00 00 00 00 
--
  403cfc:	45 31 e4             	xor    r12d,r12d
	while (ret != 0) {
  403cff:	e9 64 ff ff ff       	jmp    403c68 <sched_blkpt_alloc+0xf8>
  403d04:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  403d0b:	00 00 00 00 
--
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403d39:	48 85 c0             	test   rax,rax
  403d3c:	74 42                	je     403d80 <sched_blkpt_trigger+0x60>
  403d3e:	83 e8 01             	sub    eax,0x1
  403d41:	83 f8 18             	cmp    eax,0x18
  403d44:	77 3a                	ja     403d80 <sched_blkpt_trigger+0x60>
  403d46:	48 8b 14 c5 00 e7 45 	mov    rdx,QWORD PTR [rax*8+0x45e700]
--
  403d4e:	31 f6                	xor    esi,esi
  403d50:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  403d57:	74 18                	je     403d71 <sched_blkpt_trigger+0x51>
  403d59:	83 e2 01             	and    edx,0x1
  403d5c:	75 13                	jne    403d71 <sched_blkpt_trigger+0x51>
  403d5e:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  403d62:	48 8d 34 50          	lea    rsi,[rax+rdx*2]
--
	return slm_blkpt_trigger(blkpt, current, epoch, single);
  403d71:	4c 89 c2             	mov    rdx,r8
  403d74:	e9 07 d0 ff ff       	jmp    400d80 <slm_blkpt_trigger>
  403d79:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
--
	return slm_blkpt_trigger(blkpt, current, epoch, single);
  403d82:	4c 89 c2             	mov    rdx,r8
  403d85:	e9 f6 cf ff ff       	jmp    400d80 <slm_blkpt_trigger>
  403d8a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

--
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403daa:	48 85 c0             	test   rax,rax
  403dad:	74 41                	je     403df0 <sched_blkpt_block+0x60>
  403daf:	83 e8 01             	sub    eax,0x1
  403db2:	83 f8 18             	cmp    eax,0x18
  403db5:	77 39                	ja     403df0 <sched_blkpt_block+0x60>
  403db7:	48 8b 14 c5 00 e7 45 	mov    rdx,QWORD PTR [rax*8+0x45e700]
--
  403dbf:	31 f6                	xor    esi,esi
  403dc1:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  403dc8:	74 18                	je     403de2 <sched_blkpt_block+0x52>
  403dca:	83 e2 01             	and    edx,0x1
  403dcd:	75 13                	jne    403de2 <sched_blkpt_block+0x52>
  403dcf:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  403dd3:	48 8d 34 50          	lea    rsi,[rax+rdx*2]
--
	return slm_blkpt_block(blkpt, current, epoch, dependency);
  403de2:	4c 89 c2             	mov    rdx,r8
  403de5:	e9 e6 d3 ff ff       	jmp    4011d0 <slm_blkpt_block>
  403dea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
--
	return slm_blkpt_block(blkpt, current, epoch, dependency);
  403df2:	4c 89 c2             	mov    rdx,r8
  403df5:	e9 d6 d3 ff ff       	jmp    4011d0 <slm_blkpt_block>
  403dfa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000403e00 <syncipc_call>:
{
  403e00:	f3 0f 1e fa          	endbr64 
--
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403e3d:	48 85 c0             	test   rax,rax
  403e40:	0f 84 62 01 00 00    	je     403fa8 <syncipc_call+0x1a8>
  403e46:	83 e8 01             	sub    eax,0x1
  403e49:	83 f8 18             	cmp    eax,0x18
  403e4c:	0f 87 56 01 00 00    	ja     403fa8 <syncipc_call+0x1a8>
  403e52:	48 8b 14 c5 00 e7 45 	mov    rdx,QWORD PTR [rax*8+0x45e700]
  403e59:	00 
  403e5a:	31 db                	xor    ebx,ebx
  403e5c:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  403e63:	0f 85 17 01 00 00    	jne    403f80 <syncipc_call+0x180>
	counts[type]++;
  403e69:	48 83 05 8f a2 05 00 	add    QWORD PTR [rip+0x5a28f],0x1        # 45e100 <counts>
--
  403e71:	66 0f ef c0          	pxor   xmm0,xmm0
	if (ep->server == NULL) return -EAGAIN;
  403e75:	48 83 3d cb a2 05 00 	cmp    QWORD PTR [rip+0x5a2cb],0x0        # 45e148 <eps+0x8>
  403e7c:	00 
	struct ipc_retvals retvals = { .ready = 0 };
--
  403e85:	0f 29 45 b0          	movaps XMMWORD PTR [rbp-0x50],xmm0
	if (ep->server == NULL) return -EAGAIN;
  403e89:	0f 84 29 02 00 00    	je     4040b8 <syncipc_call+0x2b8>
		tok      = cos_sched_sync();
  403e8f:	e8 6c d4 00 00       	call   411300 <cos_sched_sync>
		switchto = ps_load(&ep->server);
  403e94:	4c 8b 3d ad a2 05 00 	mov    r15,QWORD PTR [rip+0x5a2ad]        # 45e148 <eps+0x8>
--
  403e9b:	41 89 c4             	mov    r12d,eax
  403e9e:	31 c0                	xor    eax,eax
  403ea0:	f0 48 0f b1 1d 97 a2 	lock cmpxchg QWORD PTR [rip+0x5a297],rbx        # 45e140 <eps>
  403ea7:	05 00 
  403ea9:	0f 94 c0             	sete   al
		if (likely(ps_cas((unsigned long *)&ep->client, 0, (unsigned long)t))) {
  403eac:	84 c0                	test   al,al
  403eae:	0f 84 fc 00 00 00    	je     403fb0 <syncipc_call+0x1b0>
			ep->retvals = &retvals;
  403eb4:	48 8d 45 b0          	lea    rax,[rbp-0x50]
--
  403ecb:	0f 29 1d 7e a2 05 00 	movaps XMMWORD PTR [rip+0x5a27e],xmm3        # 45e150 <eps+0x10>
			assert(ps_load(&ep->client) == t);
  403ed2:	48 39 d8             	cmp    rax,rbx
  403ed5:	0f 85 0f 01 00 00    	jne    403fea <syncipc_call+0x1ea>
		client = ps_load(&ep->client);
  403edb:	48 8b 05 5e a2 05 00 	mov    rax,QWORD PTR [rip+0x5a25e]        # 45e140 <eps>
--
{
	if (unlikely(!slm_state_is_runnable(to->state))) return 1;
  403eeb:	83 f8 01             	cmp    eax,0x1
  403eee:	0f 87 e4 00 00 00    	ja     403fd8 <syncipc_call+0x1d8>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  403ef4:	e8 67 79 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  403ef9:	41 8b 07             	mov    eax,DWORD PTR [r15]
--
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  403f07:	a8 0b                	test   al,0xb
  403f09:	0f 85 f7 00 00 00    	jne    404006 <syncipc_call+0x206>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  403f0f:	49 8b 7f 10          	mov    rdi,QWORD PTR [r15+0x10]
  403f13:	4c 89 c2             	mov    rdx,r8
  403f16:	44 89 e1             	mov    ecx,r12d
  403f19:	e8 42 88 00 00       	call   40c760 <cos_defswitch>
  403f1e:	41 89 c0             	mov    r8d,eax
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  403f21:	83 f8 ff             	cmp    eax,0xffffffff
  403f24:	0f 84 21 01 00 00    	je     40404b <syncipc_call+0x24b>
		if (unlikely(ret)) {
  403f2a:	45 85 c0             	test   r8d,r8d
  403f2d:	40 0f 95 c6          	setne  sil
			if (ret != -EAGAIN) return ret;
  403f31:	41 83 f8 f5          	cmp    r8d,0xfffffff5
  403f35:	0f 95 c0             	setne  al
  403f38:	21 c6                	and    esi,eax
--
			if (ret != -EAGAIN) return ret;
  403f44:	40 84 f6             	test   sil,sil
  403f47:	75 25                	jne    403f6e <syncipc_call+0x16e>
		if (likely(ps_load(&retvals.ready))) break;
  403f49:	8b 45 b0             	mov    eax,DWORD PTR [rbp-0x50]
  403f4c:	85 c0                	test   eax,eax
  403f4e:	0f 84 3b ff ff ff    	je     403e8f <syncipc_call+0x8f>
	*ret0 = ps_load(&retvals.r0);
  403f54:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
--
  403f7f:	c3                   	ret    
  403f80:	83 e2 01             	and    edx,0x1
  403f83:	0f 85 e0 fe ff ff    	jne    403e69 <syncipc_call+0x69>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403f89:	48 8d 14 80          	lea    rdx,[rax+rax*4]
--
  403f91:	48 c1 e3 04          	shl    rbx,0x4
  403f95:	48 81 c3 c8 e7 45 00 	add    rbx,0x45e7c8
  403f9c:	e9 c8 fe ff ff       	jmp    403e69 <syncipc_call+0x69>
  403fa1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  403fa8:	31 db                	xor    ebx,ebx
  403faa:	e9 ba fe ff ff       	jmp    403e69 <syncipc_call+0x69>
  403faf:	90                   	nop
		if (unlikely(ep->client != t && ep->retvals == NULL)) switchto = client;
  403fb0:	48 39 1d 89 a1 05 00 	cmp    QWORD PTR [rip+0x5a189],rbx        # 45e140 <eps>
		client = ps_load(&ep->client);
  403fb7:	48 8b 05 82 a1 05 00 	mov    rax,QWORD PTR [rip+0x5a182]        # 45e140 <eps>
		if (unlikely(ep->client != t && ep->retvals == NULL)) switchto = client;
  403fbe:	0f 84 1e ff ff ff    	je     403ee2 <syncipc_call+0xe2>
		client = ps_load(&ep->client);
  403fc4:	48 83 3d 94 a1 05 00 	cmp    QWORD PTR [rip+0x5a194],0x0        # 45e160 <eps+0x20>
  403fcb:	00 
  403fcc:	4c 0f 44 f8          	cmove  r15,rax
  403fd0:	e9 0d ff ff ff       	jmp    403ee2 <syncipc_call+0xe2>
  403fd5:	0f 1f 00             	nop    DWORD PTR [rax]
  403fd8:	0f 31                	rdtsc  
--
  403fe1:	01 
  403fe2:	41 b8 01 00 00 00    	mov    r8d,0x1
  403fe8:	eb 84                	jmp    403f6e <syncipc_call+0x16e>
  403fea:	be 24 00 00 00       	mov    esi,0x24
  403fef:	bf b0 cc 41 00       	mov    edi,0x41ccb0
  403ff4:	e8 d7 60 00 00       	call   40a0d0 <cos_print_str>
			assert(ps_load(&ep->client) == t);
  403ff9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
			timeout = TCAP_TIME_NIL;
  404006:	31 c9                	xor    ecx,ecx
  404008:	49 81 ff c8 1e 5a 00 	cmp    r15,0x5a1ec8
  40400f:	49 0f 45 c8          	cmovne rcx,r8
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  404013:	a8 02                	test   al,0x2
  404015:	0f 85 85 00 00 00    	jne    4040a0 <syncipc_call+0x2a0>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  40401b:	49 89 c8             	mov    r8,rcx
  40401e:	a8 01                	test   al,0x1
  404020:	0f 84 e9 fe ff ff    	je     403f0f <syncipc_call+0x10f>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  404026:	4d 8b 57 08          	mov    r10,QWORD PTR [r15+0x8]
--
  404034:	4c 8b 05 ad de 19 00 	mov    r8,QWORD PTR [rip+0x19dead]        # 5a1ee8 <__slm_global+0x28>
  40403b:	4c 89 d6             	mov    rsi,r10
  40403e:	e8 dd d2 00 00       	call   411320 <cos_switch>
  404043:	41 89 c0             	mov    r8d,eax
  404046:	e9 df fe ff ff       	jmp    403f2a <syncipc_call+0x12a>
	return t != &g->idle_thd && t != &g->sched_thd;
  40404b:	49 81 ff 40 1f 5a 00 	cmp    r15,0x5a1f40
  404052:	74 18                	je     40406c <syncipc_call+0x26c>
  404054:	49 81 ff c8 1e 5a 00 	cmp    r15,0x5a1ec8
  40405b:	74 0f                	je     40406c <syncipc_call+0x26c>
  40405d:	0f 31                	rdtsc  
	counts[type]++;
--
  404066:	01 
			if (ret != -EAGAIN) return ret;
  404067:	e9 02 ff ff ff       	jmp    403f6e <syncipc_call+0x16e>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  40406c:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]
--
  40407c:	48 8b 3d 55 de 19 00 	mov    rdi,QWORD PTR [rip+0x19de55]        # 5a1ed8 <__slm_global+0x18>
  404083:	31 f6                	xor    esi,esi
  404085:	e8 96 d2 00 00       	call   411320 <cos_switch>
  40408a:	83 f8 f5             	cmp    eax,0xfffffff5
  40408d:	41 89 c0             	mov    r8d,eax
  404090:	40 0f 95 c6          	setne  sil
--
			if (ret != -EAGAIN) return ret;
  404099:	21 c6                	and    esi,eax
  40409b:	e9 9a fe ff ff       	jmp    403f3a <syncipc_call+0x13a>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  4040a0:	49 8b 7f 28          	mov    rdi,QWORD PTR [r15+0x28]
--
  4040ab:	44 89 e1             	mov    ecx,r12d
  4040ae:	4c 89 c6             	mov    rsi,r8
  4040b1:	e8 da d2 00 00       	call   411390 <cos_sched_asnd>
  4040b6:	eb d2                	jmp    40408a <syncipc_call+0x28a>
	if (ep->server == NULL) return -EAGAIN;
  4040b8:	41 b8 f5 ff ff ff    	mov    r8d,0xfffffff5
  4040be:	e9 ab fe ff ff       	jmp    403f6e <syncipc_call+0x16e>
  4040c3:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4040ca:	00 00 00 00 
--
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  40410a:	48 85 c0             	test   rax,rax
  40410d:	0f 84 7d 02 00 00    	je     404390 <syncipc_reply_wait+0x2c0>
  404113:	83 e8 01             	sub    eax,0x1
  404116:	83 f8 18             	cmp    eax,0x18
  404119:	0f 87 71 02 00 00    	ja     404390 <syncipc_reply_wait+0x2c0>
  40411f:	48 8b 14 c5 00 e7 45 	mov    rdx,QWORD PTR [rax*8+0x45e700]
--
  404127:	45 31 ed             	xor    r13d,r13d
  40412a:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  404131:	0f 85 b9 01 00 00    	jne    4042f0 <syncipc_reply_wait+0x220>
	if (unlikely(ep->server != t)) {
  404137:	48 8b 05 0a a0 05 00 	mov    rax,QWORD PTR [rip+0x5a00a]        # 45e148 <eps+0x8>
  40413e:	4c 39 e8             	cmp    rax,r13
  404141:	0f 85 d5 01 00 00    	jne    40431c <syncipc_reply_wait+0x24c>
	client             = ps_load(&ep->client);
  404147:	48 8b 1d f2 9f 05 00 	mov    rbx,QWORD PTR [rip+0x59ff2]        # 45e140 <eps>
--
  40415c:	01 
	return t != &g->idle_thd && t != &g->sched_thd;
  40415d:	48 81 fb 40 1f 5a 00 	cmp    rbx,0x5a1f40
	ep->retvals->ready = 1;
  404164:	c7 00 01 00 00 00    	mov    DWORD PTR [rax],0x1
--
  40416a:	0f 11 40 08          	movups XMMWORD PTR [rax+0x8],xmm0
  40416e:	41 0f 95 c6          	setne  r14b
  404172:	48 81 fb c8 1e 5a 00 	cmp    rbx,0x5a1ec8
	ep->retvals       = NULL;
  404179:	48 c7 05 dc 9f 05 00 	mov    QWORD PTR [rip+0x59fdc],0x0        # 45e160 <eps+0x20>
--
  404195:	0f 31                	rdtsc  
		ret = slm_switch_to(t, client, cos_sched_sync(), 1);
  404197:	e8 64 d1 00 00       	call   411300 <cos_sched_sync>
  40419c:	41 89 c4             	mov    r12d,eax
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  40419f:	8b 43 04             	mov    eax,DWORD PTR [rbx+0x4]
  4041a2:	83 e8 02             	sub    eax,0x2
  4041a5:	83 f8 01             	cmp    eax,0x1
  4041a8:	0f 87 a2 00 00 00    	ja     404250 <syncipc_reply_wait+0x180>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  4041ae:	e8 ad 76 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4041b3:	8b 03                	mov    eax,DWORD PTR [rbx]
--
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4041c0:	a8 0b                	test   al,0xb
  4041c2:	0f 85 a8 00 00 00    	jne    404270 <syncipc_reply_wait+0x1a0>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  4041c8:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  4041cc:	4c 89 c2             	mov    rdx,r8
  4041cf:	44 89 e1             	mov    ecx,r12d
  4041d2:	e8 89 85 00 00       	call   40c760 <cos_defswitch>
  4041d7:	41 89 c0             	mov    r8d,eax
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  4041da:	83 f8 ff             	cmp    eax,0xffffffff
  4041dd:	0f 84 d5 00 00 00    	je     4042b8 <syncipc_reply_wait+0x1e8>
  4041e3:	0f 31                	rdtsc  
		if (unlikely(ret) && ret != -EAGAIN) return ret;
  4041e5:	45 85 c0             	test   r8d,r8d
  4041e8:	75 70                	jne    40425a <syncipc_reply_wait+0x18a>
	counts[type]++;
  4041ea:	66 0f 6f 05 5e 8b 01 	movdqa xmm0,XMMWORD PTR [rip+0x18b5e]        # 41cd50 <__unlock+0xc20>
--
  404208:	48 8b 05 31 9f 05 00 	mov    rax,QWORD PTR [rip+0x59f31]        # 45e140 <eps>
  40420f:	48 85 c0             	test   rax,rax
  404212:	74 f4                	je     404208 <syncipc_reply_wait+0x138>
	*ret0 = ep->a0;
  404214:	48 8b 05 35 9f 05 00 	mov    rax,QWORD PTR [rip+0x59f35]        # 45e150 <eps+0x10>
--
  404250:	0f 31                	rdtsc  
  404252:	41 b8 01 00 00 00    	mov    r8d,0x1
  404258:	eb da                	jmp    404234 <syncipc_reply_wait+0x164>
		if (unlikely(ret) && ret != -EAGAIN) return ret;
  40425a:	41 83 f8 f5          	cmp    r8d,0xfffffff5
  40425e:	75 d4                	jne    404234 <syncipc_reply_wait+0x164>
	counts[type]++;
  404260:	48 83 05 b8 9e 05 00 	add    QWORD PTR [rip+0x59eb8],0x1        # 45e120 <counts+0x20>
  404267:	01 
	} while (ret == -EAGAIN);
  404268:	e9 28 ff ff ff       	jmp    404195 <syncipc_reply_wait+0xc5>
  40426d:	0f 1f 00             	nop    DWORD PTR [rax]
			timeout = TCAP_TIME_NIL;
  404270:	31 c9                	xor    ecx,ecx
  404272:	48 81 fb c8 1e 5a 00 	cmp    rbx,0x5a1ec8
  404279:	49 0f 45 c8          	cmovne rcx,r8
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  40427d:	a8 02                	test   al,0x2
  40427f:	0f 85 1b 01 00 00    	jne    4043a0 <syncipc_reply_wait+0x2d0>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  404285:	49 89 c8             	mov    r8,rcx
  404288:	a8 01                	test   al,0x1
  40428a:	0f 84 38 ff ff ff    	je     4041c8 <syncipc_reply_wait+0xf8>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  404290:	4c 8b 53 08          	mov    r10,QWORD PTR [rbx+0x8]
--
  40429e:	4c 8b 05 43 dc 19 00 	mov    r8,QWORD PTR [rip+0x19dc43]        # 5a1ee8 <__slm_global+0x28>
  4042a5:	4c 89 d6             	mov    rsi,r10
  4042a8:	e8 73 d0 00 00       	call   411320 <cos_switch>
  4042ad:	41 89 c0             	mov    r8d,eax
  4042b0:	e9 2e ff ff ff       	jmp    4041e3 <syncipc_reply_wait+0x113>
  4042b5:	0f 1f 00             	nop    DWORD PTR [rax]
	return t != &g->idle_thd && t != &g->sched_thd;
  4042b8:	45 84 f6             	test   r14b,r14b
  4042bb:	75 2b                	jne    4042e8 <syncipc_reply_wait+0x218>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  4042bd:	4c 8b 05 24 dc 19 00 	mov    r8,QWORD PTR [rip+0x19dc24]        # 5a1ee8 <__slm_global+0x28>
--
  4042cd:	48 8b 3d 04 dc 19 00 	mov    rdi,QWORD PTR [rip+0x19dc04]        # 5a1ed8 <__slm_global+0x18>
  4042d4:	31 f6                	xor    esi,esi
  4042d6:	e8 45 d0 00 00       	call   411320 <cos_switch>
  4042db:	41 89 c0             	mov    r8d,eax
  4042de:	e9 00 ff ff ff       	jmp    4041e3 <syncipc_reply_wait+0x113>
  4042e3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  4042e8:	0f 31                	rdtsc  
		if (unlikely(ret) && ret != -EAGAIN) return ret;
  4042ea:	e9 45 ff ff ff       	jmp    404234 <syncipc_reply_wait+0x164>
  4042ef:	90                   	nop
  4042f0:	83 e2 01             	and    edx,0x1
  4042f3:	0f 85 3e fe ff ff    	jne    404137 <syncipc_reply_wait+0x67>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  4042f9:	48 8d 14 80          	lea    rdx,[rax+rax*4]
--
  40430c:	49 81 c5 c8 e7 45 00 	add    r13,0x45e7c8
	if (unlikely(ep->server != t)) {
  404313:	4c 39 e8             	cmp    rax,r13
  404316:	0f 84 2b fe ff ff    	je     404147 <syncipc_reply_wait+0x77>
		if (ep->server != NULL)         return -1;
  40431c:	48 85 c0             	test   rax,rax
  40431f:	0f 85 d1 00 00 00    	jne    4043f6 <syncipc_reply_wait+0x326>
        __asm__ __volatile__("lock " PS_CAS_STR
  404325:	f0 4c 0f b1 2d 1a 9e 	lock cmpxchg QWORD PTR [rip+0x59e1a],r13        # 45e148 <eps+0x8>
  40432c:	05 00 
  40432e:	0f 94 c0             	sete   al
		if (!ps_cas((unsigned long *)&ep->server, 0, (unsigned long)t)) return -1;
  404331:	84 c0                	test   al,al
  404333:	0f 84 bd 00 00 00    	je     4043f6 <syncipc_reply_wait+0x326>
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  404339:	31 d2                	xor    edx,edx
  40433b:	be 0b 00 00 00       	mov    esi,0xb
  404340:	4c 89 ef             	mov    rdi,r13
  404343:	e8 08 e3 00 00       	call   412650 <slm_sched_fprr_thd_update>
  404348:	41 89 c0             	mov    r8d,eax
		assert(ret == 0);
  40434b:	85 c0                	test   eax,eax
  40434d:	75 6f                	jne    4043be <syncipc_reply_wait+0x2ee>
		assert(ep->server == t);
  40434f:	4c 39 2d f2 9d 05 00 	cmp    QWORD PTR [rip+0x59df2],r13        # 45e148 <eps+0x8>
  404356:	0f 85 7e 00 00 00    	jne    4043da <syncipc_reply_wait+0x30a>
  40435c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		while (ps_load(&ep->client) == NULL) ;
  404360:	48 8b 05 d9 9d 05 00 	mov    rax,QWORD PTR [rip+0x59dd9]        # 45e140 <eps>
  404367:	48 85 c0             	test   rax,rax
  40436a:	74 f4                	je     404360 <syncipc_reply_wait+0x290>
		*ret0 = ep->a0;
  40436c:	48 8b 05 dd 9d 05 00 	mov    rax,QWORD PTR [rip+0x59ddd]        # 45e150 <eps+0x10>
--
  404381:	49 89 07             	mov    QWORD PTR [r15],rax
		return 0;
  404384:	e9 ab fe ff ff       	jmp    404234 <syncipc_reply_wait+0x164>
  404389:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  404390:	45 31 ed             	xor    r13d,r13d
  404393:	e9 9f fd ff ff       	jmp    404137 <syncipc_reply_wait+0x67>
  404398:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40439f:	00 
--
  4043ab:	4c 89 c6             	mov    rsi,r8
  4043ae:	44 89 e1             	mov    ecx,r12d
  4043b1:	e8 da cf 00 00       	call   411390 <cos_sched_asnd>
  4043b6:	41 89 c0             	mov    r8d,eax
  4043b9:	e9 25 fe ff ff       	jmp    4041e3 <syncipc_reply_wait+0x113>
  4043be:	be 24 00 00 00       	mov    esi,0x24
  4043c3:	bf d8 cc 41 00       	mov    edi,0x41ccd8
  4043c8:	e8 03 5d 00 00       	call   40a0d0 <cos_print_str>
		assert(ret == 0);
  4043cd:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  4043da:	be 24 00 00 00       	mov    esi,0x24
  4043df:	bf 00 cd 41 00       	mov    edi,0x41cd00
  4043e4:	e8 e7 5c 00 00       	call   40a0d0 <cos_print_str>
		assert(ep->server == t);
  4043e9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
		if (ep->server != NULL)         return -1;
  4043f6:	41 b8 ff ff ff ff    	mov    r8d,0xffffffff
  4043fc:	e9 33 fe ff ff       	jmp    404234 <syncipc_reply_wait+0x164>
  404401:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  404408:	00 00 00 00 
--
  404420:	f3 0f 1e fa          	endbr64 
	return slm_get_cycs_per_usec();
  404424:	e9 f7 ff 00 00       	jmp    414420 <slm_get_cycs_per_usec>
  404429:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

--
  404453:	89 55 bc             	mov    DWORD PTR [rbp-0x44],edx
	struct slm_ipi_percore   *ipi_data = slm_ipi_percore_get(cos_cpuid());
  404456:	e8 55 f2 00 00       	call   4136b0 <slm_ipi_percore_get>
	r->rcv = capmgr_rcv_alloc(fn, data, flags, &r->asnd, &_thd, &_tid);
  40445b:	8b 55 bc             	mov    edx,DWORD PTR [rbp-0x44]
--
  404470:	48 89 c3             	mov    rbx,rax
	r->rcv = capmgr_rcv_alloc(fn, data, flags, &r->asnd, &_thd, &_tid);
  404473:	e8 a8 59 00 00       	call   409e20 <capmgr_rcv_alloc>
	r->tid = _tid;
  404478:	48 8b 75 c8          	mov    rsi,QWORD PTR [rbp-0x38]
--
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  40449c:	85 f6                	test   esi,esi
  40449e:	0f 84 8c 01 00 00    	je     404630 <slm_ipithd_create+0x200>
  4044a4:	8d 56 ff             	lea    edx,[rsi-0x1]
  4044a7:	83 fa 18             	cmp    edx,0x18
  4044aa:	0f 87 80 01 00 00    	ja     404630 <slm_ipithd_create+0x200>
	if (*state != SS_STATE_FREE ||
  4044b0:	48 83 3c d5 00 e7 45 	cmp    QWORD PTR [rdx*8+0x45e700],0x0
  4044b7:	00 00 
  4044b9:	0f 85 71 01 00 00    	jne    404630 <slm_ipithd_create+0x200>
  4044bf:	45 31 c9             	xor    r9d,r9d
  4044c2:	b9 01 00 00 00       	mov    ecx,0x1
  4044c7:	4c 89 c8             	mov    rax,r9
  4044ca:	f0 48 0f b1 0c d5 00 	lock cmpxchg QWORD PTR [rdx*8+0x45e700],rcx
  4044d1:	e7 45 00 
  4044d4:	0f 94 c0             	sete   al
  4044d7:	84 c0                	test   al,al
  4044d9:	0f 84 51 01 00 00    	je     404630 <slm_ipithd_create+0x200>
  4044df:	48 8d 04 92          	lea    rax,[rdx+rdx*4]
  4044e3:	b9 16 00 00 00       	mov    ecx,0x16
--
	assert(_cap != 0 && _tid != 0);
  404500:	4d 85 c0             	test   r8,r8
  404503:	0f 84 64 01 00 00    	je     40466d <slm_ipithd_create+0x23d>
	t->resources = (struct slm_resources_thd) {
  404509:	48 8b 05 30 2b 02 00 	mov    rax,QWORD PTR [rip+0x22b30]        # 427040 <__cosrt_comp_info+0x40>
--
  404527:	49 89 34 24          	mov    QWORD PTR [r12],rsi
		tok    = cos_sched_sync();
  40452b:	e8 d0 cd 00 00       	call   411300 <cos_sched_sync>
  404530:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  40453a:	48 89 c1             	mov    rcx,rax
  40453d:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  404541:	0f 85 42 01 00 00    	jne    404689 <slm_ipithd_create+0x259>
  404547:	f0 48 0f b1 1d 70 d9 	lock cmpxchg QWORD PTR [rip+0x19d970],rbx        # 5a1ec0 <__slm_global>
  40454e:	19 00 
  404550:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  404553:	84 c0                	test   al,al
  404555:	74 d4                	je     40452b <slm_ipithd_create+0xfb>
	if (slm_thd_init(thd, _thd, _tid)) ERR_THROW(NULL, free);
  404557:	48 8b 55 c8          	mov    rdx,QWORD PTR [rbp-0x38]
  40455b:	48 8b 75 c0          	mov    rsi,QWORD PTR [rbp-0x40]
  40455f:	4c 89 f7             	mov    rdi,r14
  404562:	e8 a9 f1 00 00       	call   413710 <slm_thd_init>
  404567:	85 c0                	test   eax,eax
  404569:	0f 85 dd 00 00 00    	jne    40464c <slm_ipithd_create+0x21c>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  40456f:	49 81 fe c8 e7 45 00 	cmp    r14,0x45e7c8
  404576:	0f 82 d5 00 00 00    	jb     404651 <slm_ipithd_create+0x221>
  40457c:	49 81 fe 48 f8 45 00 	cmp    r14,0x45f848
  404583:	0f 87 c8 00 00 00    	ja     404651 <slm_ipithd_create+0x221>
  404589:	4c 89 f0             	mov    rax,r14
--
  4045af:	00 
	assert((*state & 1) == SS_STATE_CONS);
  4045b0:	48 83 fa ff          	cmp    rdx,0xffffffffffffffff
  4045b4:	0f 85 29 01 00 00    	jne    4046e3 <slm_ipithd_create+0x2b3>
	*state &= ~SS_STATE_CONS;
  4045ba:	48 c7 04 c5 00 e7 45 	mov    QWORD PTR [rax*8+0x45e700],0xfffffffffffffffe
--
  4045c6:	0f ae f0             	mfence 
	assert(*state != 0);
  4045c9:	48 83 3c c5 00 e7 45 	cmp    QWORD PTR [rax*8+0x45e700],0x0
  4045d0:	00 00 
  4045d2:	75 1c                	jne    4045f0 <slm_ipithd_create+0x1c0>
  4045d4:	e9 ee 00 00 00       	jmp    4046c7 <slm_ipithd_create+0x297>
  4045d9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  4045e0:	f0 48 0f b1 15 d7 d8 	lock cmpxchg QWORD PTR [rip+0x19d8d7],rdx        # 5a1ec0 <__slm_global>
  4045e7:	19 00 
  4045e9:	0f 94 c0             	sete   al
	while (ret != 0) {
  4045ec:	84 c0                	test   al,al
  4045ee:	75 2e                	jne    40461e <slm_ipithd_create+0x1ee>
		tok    = cos_sched_sync();
  4045f0:	e8 0b cd 00 00       	call   411300 <cos_sched_sync>
  4045f5:	89 c1                	mov    ecx,eax
  4045f7:	48 8b 05 c2 d8 19 00 	mov    rax,QWORD PTR [rip+0x19d8c2]        # 5a1ec0 <__slm_global>
--
  4045fe:	48 89 c2             	mov    rdx,rax
  404601:	83 e2 01             	and    edx,0x1
  404604:	74 da                	je     4045e0 <slm_ipithd_create+0x1b0>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  404606:	48 89 c6             	mov    rsi,rax
--
  40460c:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  404611:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  404615:	e8 46 f2 00 00       	call   413860 <slm_cs_exit_contention>
  40461a:	85 c0                	test   eax,eax
  40461c:	75 d2                	jne    4045f0 <slm_ipithd_create+0x1c0>
}
  40461e:	48 83 c4 28          	add    rsp,0x28
--
  404630:	be 23 00 00 00       	mov    esi,0x23
  404635:	bf 30 cb 41 00       	mov    edi,0x41cb30
  40463a:	e8 91 5a 00 00       	call   40a0d0 <cos_print_str>
	if (!t) assert(0);
  40463f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40464c:	45 31 f6             	xor    r14d,r14d
	return ret;
  40464f:	eb cd                	jmp    40461e <slm_ipithd_create+0x1ee>
  404651:	be 23 00 00 00       	mov    esi,0x23
  404656:	bf 08 cb 41 00       	mov    edi,0x41cb08
  40465b:	e8 70 5a 00 00       	call   40a0d0 <cos_print_str>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  404660:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40466d:	be 23 00 00 00       	mov    esi,0x23
  404672:	bf 58 cb 41 00       	mov    edi,0x41cb58
  404677:	e8 54 5a 00 00       	call   40a0d0 <cos_print_str>
	assert(_cap != 0 && _tid != 0);
  40467c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  404694:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  404699:	41 83 e0 01          	and    r8d,0x1
  40469d:	e8 6e f1 00 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  4046a2:	83 f8 f0             	cmp    eax,0xfffffff0
  4046a5:	0f 85 80 fe ff ff    	jne    40452b <slm_ipithd_create+0xfb>
  4046ab:	be 59 00 00 00       	mov    esi,0x59
  4046b0:	bf c0 c7 41 00       	mov    edi,0x41c7c0
  4046b5:	e8 16 5a 00 00       	call   40a0d0 <cos_print_str>
  4046ba:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4046c1:	00 00 00 00 
--
  4046c7:	be 61 00 00 00       	mov    esi,0x61
  4046cc:	bf e8 cb 41 00       	mov    edi,0x41cbe8
  4046d1:	e8 fa 59 00 00       	call   40a0d0 <cos_print_str>
  4046d6:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4046dd:	00 00 00 00 
--
  4046e3:	be 61 00 00 00       	mov    esi,0x61
  4046e8:	bf 80 cb 41 00       	mov    edi,0x41cb80
  4046ed:	e8 de 59 00 00       	call   40a0d0 <cos_print_str>
	assert((*state & 1) == SS_STATE_CONS);
  4046f2:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  404700:	f3 0f 1e fa          	endbr64 
	if (cid == _init_core_id) printc("Starting scheduler loop...\n");
  404704:	66 39 3d dd 9f 05 00 	cmp    WORD PTR [rip+0x59fdd],di        # 45e6e8 <_init_core_id>
  40470b:	74 0b                	je     404718 <parallel_main+0x18>
	slm_sched_loop_nonblock();
  40470d:	e9 2e fd 00 00       	jmp    414440 <slm_sched_loop_nonblock>
  404712:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
{
--
  404720:	48 89 e5             	mov    rbp,rsp
	if (cid == _init_core_id) printc("Starting scheduler loop...\n");
  404723:	e8 38 c2 ff ff       	call   400960 <printc.constprop.0>
}
  404728:	5d                   	pop    rbp
	slm_sched_loop_nonblock();
  404729:	e9 12 fd 00 00       	jmp    414440 <slm_sched_loop_nonblock>
  40472e:	66 90                	xchg   ax,ax

--
	if (init_core) {
  40473d:	85 f6                	test   esi,esi
  40473f:	74 07                	je     404748 <cos_parallel_init+0x18>
		_init_core_id = cid;
  404741:	66 89 3d a0 9f 05 00 	mov    WORD PTR [rip+0x59fa0],di        # 45e6e8 <_init_core_id>
--
	struct slm_ipi_percore *ipi_data = slm_ipi_percore_get(cos_cpuid());
  404748:	31 ff                	xor    edi,edi
  40474a:	e8 61 ef 00 00       	call   4136b0 <slm_ipi_percore_get>
  40474f:	48 89 c3             	mov    rbx,rax

	cos_defcompinfo_sched_init();
  404752:	e8 89 73 00 00       	call   40bae0 <cos_defcompinfo_sched_init>

	t = slm_thd_alloc(slm_idle, NULL, &thdcap, &tid);
--
  40475d:	48 8d 55 d0          	lea    rdx,[rbp-0x30]
  404761:	bf 50 2a 41 00       	mov    edi,0x412a50
  404766:	e8 35 01 00 00       	call   4048a0 <slm_thd_alloc>
	if (!t) BUG();
  40476b:	48 85 c0             	test   rax,rax
  40476e:	0f 84 bc 00 00 00    	je     404830 <cos_parallel_init+0x100>

	slm_init(thdcap, tid);
  404774:	48 8b 75 e0          	mov    rsi,QWORD PTR [rbp-0x20]
  404778:	48 8b 7d d0          	mov    rdi,QWORD PTR [rbp-0x30]
  40477c:	e8 df fc 00 00       	call   414460 <slm_init>

	r = slm_ipithd_create(slm_ipi_process, NULL, 0, &ipithdcap, &ipitid);
--
  404789:	48 8d 4d d8          	lea    rcx,[rbp-0x28]
  40478d:	bf 10 0a 40 00       	mov    edi,0x400a10
  404792:	e8 99 fc ff ff       	call   404430 <slm_ipithd_create>
	if (!r) BUG();
  404797:	48 85 c0             	test   rax,rax
  40479a:	74 74                	je     404810 <cos_parallel_init+0xe0>
	return &ss_thd_get(id)->thd;
  40479c:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  4047a0:	85 c0                	test   eax,eax
  4047a2:	74 40                	je     4047e4 <cos_parallel_init+0xb4>
  4047a4:	83 e8 01             	sub    eax,0x1
  4047a7:	83 f8 18             	cmp    eax,0x18
  4047aa:	77 38                	ja     4047e4 <cos_parallel_init+0xb4>
  4047ac:	48 8b 14 c5 00 e7 45 	mov    rdx,QWORD PTR [rax*8+0x45e700]
--
	return ((state & ~1) != 0) && ((state & 1) == SS_STATE_ALLOC);
  4047b4:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  4047bb:	74 27                	je     4047e4 <cos_parallel_init+0xb4>
  4047bd:	83 e2 01             	and    edx,0x1
  4047c0:	75 22                	jne    4047e4 <cos_parallel_init+0xb4>
	return &ss_thd_get(id)->thd;
  4047c2:	48 8d 14 80          	lea    rdx,[rax+rax*4]
--
  4047d8:	48 81 c7 c8 e7 45 00 	add    rdi,0x45e7c8
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  4047df:	e8 6c de 00 00       	call   412650 <slm_sched_fprr_thd_update>

CK_CC_INLINE static void
--
  404810:	be 11 00 00 00       	mov    esi,0x11
  404815:	bf 37 cd 41 00       	mov    edi,0x41cd37
  40481a:	e8 b1 58 00 00       	call   40a0d0 <cos_print_str>
	if (!r) BUG();
  40481f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  404830:	be 11 00 00 00       	mov    esi,0x11
  404835:	bf 25 cd 41 00       	mov    edi,0x41cd25
  40483a:	e8 91 58 00 00       	call   40a0d0 <cos_print_str>
	if (!t) BUG();
  40483f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  404855:	48 89 e5             	mov    rbp,rsp
	struct cos_compinfo *boot_info = cos_compinfo_get(cos_defcompinfo_curr_get());
  404858:	e8 03 70 00 00       	call   40b860 <cos_defcompinfo_curr_get>
  40485d:	48 89 c7             	mov    rdi,rax
  404860:	e8 0b 70 00 00       	call   40b870 <cos_compinfo_get>

	cos_meminfo_init(&(boot_info->mi), BOOT_MEM_KM_BASE, COS_MEM_KERN_PA_SZ, BOOT_CAPTBL_SELF_UNTYPED_PT);
--
  40487b:	00 00 00 
  40487e:	48 8d 78 68          	lea    rdi,[rax+0x68]
  404882:	e8 69 8e 00 00       	call   40d6f0 <cos_meminfo_init>
	extern void calculate_initialization_schedule(void);
	calculate_initialization_schedule();
  404887:	e8 94 b9 ff ff       	call   400220 <calculate_initialization_schedule>
	cos_defcompinfo_init();
}
  40488c:	5d                   	pop    rbp
	cos_defcompinfo_init();
  40488d:	e9 4e 70 00 00       	jmp    40b8e0 <cos_defcompinfo_init>
  404892:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  404899:	00 00 00 
--
  4048b6:	48 83 ec 10          	sub    rsp,0x10
	_cap = capmgr_thd_create(fn, data, &_tid);
  4048ba:	e8 b1 54 00 00       	call   409d70 <capmgr_thd_create>
  4048bf:	48 89 c7             	mov    rdi,rax
	if (_cap <= 0) return NULL;
  4048c2:	31 c0                	xor    eax,eax
  4048c4:	48 85 ff             	test   rdi,rdi
  4048c7:	74 0f                	je     4048d8 <slm_thd_alloc+0x38>

	return slm_thd_mem_alloc(_cap, _tid, thd, tid);
--
  4048cd:	4c 89 e9             	mov    rcx,r13
  4048d0:	4c 89 e2             	mov    rdx,r12
  4048d3:	e8 d8 d0 ff ff       	call   4019b0 <slm_thd_mem_alloc>
}
  4048d8:	48 83 c4 10          	add    rsp,0x10
--
  404909:	48 83 ec 10          	sub    rsp,0x10
	_cap = capmgr_thd_create_ext(cid, idx, &_tid);
  40490d:	e8 5e 22 00 00       	call   406b70 <__cosrt_extern_capmgr_thd_create_ext>
  404912:	48 89 c7             	mov    rdi,rax
	if (_cap <= 0) return NULL;
  404915:	31 c0                	xor    eax,eax
  404917:	48 85 ff             	test   rdi,rdi
  40491a:	74 0f                	je     40492b <slm_thd_alloc_in+0x3b>

	return slm_thd_mem_alloc(_cap, _tid, thd, tid);
--
  404920:	4c 89 e9             	mov    rcx,r13
  404923:	4c 89 e2             	mov    rdx,r12
  404926:	e8 85 d0 ff ff       	call   4019b0 <slm_thd_mem_alloc>
}
  40492b:	48 83 c4 10          	add    rsp,0x10
--
	struct slm_thd *ret     = NULL;
	struct slm_thd *current = slm_thd_current_extern();
  404961:	e8 da cf ff ff       	call   401940 <slm_thd_current_extern>

	/*
--
  404966:	48 89 c3             	mov    rbx,rax
  404969:	48 85 c0             	test   rax,rax
  40496c:	0f 84 3e 02 00 00    	je     404bb0 <thd_alloc+0x270>
	_cap = capmgr_thd_create(fn, data, &_tid);
  404972:	4c 89 e7             	mov    rdi,r12
  404975:	48 8d 55 c8          	lea    rdx,[rbp-0x38]
  404979:	4c 89 ee             	mov    rsi,r13
  40497c:	e8 ef 53 00 00       	call   409d70 <capmgr_thd_create>
  404981:	48 89 c7             	mov    rdi,rax
	if (_cap <= 0) return NULL;
  404984:	48 85 c0             	test   rax,rax
  404987:	0f 84 a2 00 00 00    	je     404a2f <thd_alloc+0xef>
	return slm_thd_mem_alloc(_cap, _tid, thd, tid);
  40498d:	48 8b 75 c8          	mov    rsi,QWORD PTR [rbp-0x38]
  404991:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  404995:	48 8d 55 b8          	lea    rdx,[rbp-0x48]
  404999:	e8 12 d0 ff ff       	call   4019b0 <slm_thd_mem_alloc>
  40499e:	49 89 c5             	mov    r13,rax
		current = slm_thd_special();
--
	if (!t) ERR_THROW(NULL, done);
  4049a1:	48 85 c0             	test   rax,rax
  4049a4:	0f 84 85 00 00 00    	je     404a2f <thd_alloc+0xef>
	thd = slm_thd_from_container(t);
  4049aa:	48 89 c7             	mov    rdi,rax
  4049ad:	e8 ee cf ff ff       	call   4019a0 <slm_thd_from_container>
  4049b2:	49 89 c4             	mov    r12,rax
		tok    = cos_sched_sync();
  4049b5:	e8 46 c9 00 00       	call   411300 <cos_sched_sync>
  4049ba:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  4049c4:	48 89 c1             	mov    rcx,rax
  4049c7:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  4049cb:	0f 85 0f 02 00 00    	jne    404be0 <thd_alloc+0x2a0>
  4049d1:	f0 48 0f b1 1d e6 d4 	lock cmpxchg QWORD PTR [rip+0x19d4e6],rbx        # 5a1ec0 <__slm_global>
  4049d8:	19 00 
  4049da:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4049dd:	84 c0                	test   al,al
  4049df:	74 d4                	je     4049b5 <thd_alloc+0x75>

	slm_cs_enter(current, SLM_CS_NONE);
--
  4049e5:	48 8b 75 b8          	mov    rsi,QWORD PTR [rbp-0x48]
  4049e9:	4c 89 e7             	mov    rdi,r12
  4049ec:	e8 1f ed 00 00       	call   413710 <slm_thd_init>
  4049f1:	85 c0                	test   eax,eax
  4049f3:	75 32                	jne    404a27 <thd_alloc+0xe7>

	for (i = 0; parameters[i] != 0; i++) {
--
  4049f8:	49 83 c6 04          	add    r14,0x4
  4049fc:	85 f6                	test   esi,esi
  4049fe:	75 13                	jne    404a13 <thd_alloc+0xd3>
  404a00:	eb 46                	jmp    404a48 <thd_alloc+0x108>
  404a02:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  404a08:	41 8b 36             	mov    esi,DWORD PTR [r14]
  404a0b:	49 83 c6 04          	add    r14,0x4
  404a0f:	85 f6                	test   esi,esi
  404a11:	74 35                	je     404a48 <thd_alloc+0x108>
  404a13:	89 f2                	mov    edx,esi
		sched_param_type_t type;
--
	if (value) *value = (unsigned int)      (sp >> SCHED_PARAM_TYPE_BITS);
  404a1b:	c1 ea 06             	shr    edx,0x6
  404a1e:	e8 3d cd ff ff       	call   401760 <slm_sched_thd_update>
  404a23:	85 c0                	test   eax,eax
  404a25:	74 e1                	je     404a08 <thd_alloc+0xc8>

	ret = thd;
--
	slm_thd_mem_free(t);
  404a27:	4c 89 ef             	mov    rdi,r13
  404a2a:	e8 21 d1 ff ff       	call   401b50 <slm_thd_mem_free>
	ret = NULL;
  404a2f:	45 31 e4             	xor    r12d,r12d
--
	slm_thd_mem_activate(t);
  404a48:	4c 89 ef             	mov    rdi,r13
  404a4b:	e8 40 d0 ff ff       	call   401a90 <slm_thd_mem_activate>
	if (reschedule) {
  404a50:	45 85 ff             	test   r15d,r15d
  404a53:	0f 84 1b 01 00 00    	je     404b74 <thd_alloc+0x234>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  404a59:	e8 02 6e 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	tok  = cos_sched_sync();
  404a5e:	e8 9d c8 00 00       	call   411300 <cos_sched_sync>
  404a63:	41 89 c7             	mov    r15d,eax
	t = slm_sched_schedule();
  404a66:	e8 35 cd ff ff       	call   4017a0 <slm_sched_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  404a6b:	48 85 c0             	test   rax,rax
--
  404a7e:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  404a81:	83 f8 01             	cmp    eax,0x1
  404a84:	76 1a                	jbe    404aa0 <thd_alloc+0x160>
  404a86:	e9 91 01 00 00       	jmp    404c1c <thd_alloc+0x2dc>
  404a8b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  404a90:	f0 48 0f b1 15 27 d4 	lock cmpxchg QWORD PTR [rip+0x19d427],rdx        # 5a1ec0 <__slm_global>
  404a97:	19 00 
  404a99:	0f 94 c0             	sete   al
	while (ret != 0) {
  404a9c:	84 c0                	test   al,al
  404a9e:	75 2e                	jne    404ace <thd_alloc+0x18e>
		tok    = cos_sched_sync();
  404aa0:	e8 5b c8 00 00       	call   411300 <cos_sched_sync>
  404aa5:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  404aae:	48 89 c2             	mov    rdx,rax
  404ab1:	83 e2 01             	and    edx,0x1
  404ab4:	74 da                	je     404a90 <thd_alloc+0x150>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  404ab6:	48 89 c6             	mov    rsi,rax
--
  404abc:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  404ac1:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  404ac5:	e8 96 ed 00 00       	call   413860 <slm_cs_exit_contention>
  404aca:	85 c0                	test   eax,eax
  404acc:	75 d2                	jne    404aa0 <thd_alloc+0x160>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  404ace:	e8 8d 6d 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  404ad3:	41 8b 06             	mov    eax,DWORD PTR [r14]
--
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  404ae1:	a8 0b                	test   al,0xb
  404ae3:	0f 85 4f 01 00 00    	jne    404c38 <thd_alloc+0x2f8>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  404ae9:	49 8b 7e 10          	mov    rdi,QWORD PTR [r14+0x10]
  404aed:	44 89 f9             	mov    ecx,r15d
  404af0:	4c 89 c2             	mov    rdx,r8
  404af3:	e8 68 7c 00 00       	call   40c760 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  404af8:	83 f8 ff             	cmp    eax,0xffffffff
  404afb:	0f 84 a4 01 00 00    	je     404ca5 <thd_alloc+0x365>
	if (unlikely(ret != 0)) {
  404b01:	85 c0                	test   eax,eax
  404b03:	0f 84 29 ff ff ff    	je     404a32 <thd_alloc+0xf2>
		assert(ret != -EINVAL);
  404b09:	83 f8 ea             	cmp    eax,0xffffffea
  404b0c:	0f 84 eb 01 00 00    	je     404cfd <thd_alloc+0x3bd>
		if (ret == -EBUSY) return ret;
  404b12:	83 f8 f0             	cmp    eax,0xfffffff0
  404b15:	0f 84 0c ff ff ff    	je     404a27 <thd_alloc+0xe7>
		assert(ret == -EAGAIN);
  404b1b:	83 f8 f5             	cmp    eax,0xfffffff5
  404b1e:	0f 85 1c 02 00 00    	jne    404d40 <thd_alloc+0x400>
		tok    = cos_sched_sync();
  404b24:	e8 d7 c7 00 00       	call   411300 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  404b29:	48 8b 35 90 d3 19 00 	mov    rsi,QWORD PTR [rip+0x19d390]        # 5a1ec0 <__slm_global>
--
  404b33:	48 89 f1             	mov    rcx,rsi
  404b36:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  404b3a:	0f 85 d9 01 00 00    	jne    404d19 <thd_alloc+0x3d9>
  404b40:	48 89 f0             	mov    rax,rsi
  404b43:	f0 48 0f b1 1d 74 d3 	lock cmpxchg QWORD PTR [rip+0x19d374],rbx        # 5a1ec0 <__slm_global>
  404b4a:	19 00 
  404b4c:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  404b4f:	84 c0                	test   al,al
  404b51:	0f 85 07 ff ff ff    	jne    404a5e <thd_alloc+0x11e>
  404b57:	eb cb                	jmp    404b24 <thd_alloc+0x1e4>
  404b59:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  404b60:	f0 48 0f b1 15 57 d3 	lock cmpxchg QWORD PTR [rip+0x19d357],rdx        # 5a1ec0 <__slm_global>
  404b67:	19 00 
  404b69:	0f 94 c0             	sete   al
	while (ret != 0) {
  404b6c:	84 c0                	test   al,al
  404b6e:	0f 85 be fe ff ff    	jne    404a32 <thd_alloc+0xf2>
		tok    = cos_sched_sync();
  404b74:	e8 87 c7 00 00       	call   411300 <cos_sched_sync>
  404b79:	89 c1                	mov    ecx,eax
  404b7b:	48 8b 05 3e d3 19 00 	mov    rax,QWORD PTR [rip+0x19d33e]        # 5a1ec0 <__slm_global>
--
  404b82:	48 89 c2             	mov    rdx,rax
  404b85:	83 e2 01             	and    edx,0x1
  404b88:	74 d6                	je     404b60 <thd_alloc+0x220>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  404b8a:	48 89 c6             	mov    rsi,rax
--
  404b90:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  404b95:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  404b99:	e8 c2 ec 00 00       	call   413860 <slm_cs_exit_contention>
  404b9e:	85 c0                	test   eax,eax
  404ba0:	0f 84 8c fe ff ff    	je     404a32 <thd_alloc+0xf2>
  404ba6:	eb cc                	jmp    404b74 <thd_alloc+0x234>
  404ba8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  404baf:	00 
		current = slm_thd_special();
  404bb0:	e8 1b eb 00 00       	call   4136d0 <slm_thd_special>
  404bb5:	48 89 c3             	mov    rbx,rax
		assert(current);
  404bb8:	48 85 c0             	test   rax,rax
  404bbb:	0f 85 b1 fd ff ff    	jne    404972 <thd_alloc+0x32>
  404bc1:	be 28 00 00 00       	mov    esi,0x28
  404bc6:	bf 68 cd 41 00       	mov    edi,0x41cd68
  404bcb:	e8 00 55 00 00       	call   40a0d0 <cos_print_str>
  404bd0:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404bd7:	00 00 00 00 
--
  404be9:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  404bee:	41 83 e0 01          	and    r8d,0x1
  404bf2:	e8 19 ec 00 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  404bf7:	83 f8 f0             	cmp    eax,0xfffffff0
  404bfa:	0f 85 b5 fd ff ff    	jne    4049b5 <thd_alloc+0x75>
  404c00:	be 59 00 00 00       	mov    esi,0x59
  404c05:	bf 98 cd 41 00       	mov    edi,0x41cd98
  404c0a:	e8 c1 54 00 00       	call   40a0d0 <cos_print_str>
  404c0f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404c16:	00 00 00 00 
--
  404c1c:	be 61 00 00 00       	mov    esi,0x61
  404c21:	bf f8 cd 41 00       	mov    edi,0x41cdf8
  404c26:	e8 a5 54 00 00       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  404c2b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  404c38:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  404c3b:	49 81 fe c8 1e 5a 00 	cmp    r14,0x5a1ec8
  404c42:	0f 84 8f 00 00 00    	je     404cd7 <thd_alloc+0x397>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  404c48:	a8 02                	test   al,0x2
  404c4a:	0f 85 92 00 00 00    	jne    404ce2 <thd_alloc+0x3a2>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  404c50:	49 89 c8             	mov    r8,rcx
  404c53:	a8 01                	test   al,0x1
  404c55:	0f 84 8e fe ff ff    	je     404ae9 <thd_alloc+0x1a9>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  404c5b:	4d 8b 56 08          	mov    r10,QWORD PTR [r14+0x8]
--
  404c69:	4c 8b 05 78 d2 19 00 	mov    r8,QWORD PTR [rip+0x19d278]        # 5a1ee8 <__slm_global+0x28>
  404c70:	4c 89 d6             	mov    rsi,r10
  404c73:	e8 a8 c6 00 00       	call   411320 <cos_switch>
	if (unlikely(ret != 0)) {
  404c78:	85 c0                	test   eax,eax
  404c7a:	0f 84 b2 fd ff ff    	je     404a32 <thd_alloc+0xf2>
		assert(ret != -EPERM);
  404c80:	83 f8 ff             	cmp    eax,0xffffffff
  404c83:	0f 85 80 fe ff ff    	jne    404b09 <thd_alloc+0x1c9>
  404c89:	be 61 00 00 00       	mov    esi,0x61
  404c8e:	bf 60 ce 41 00       	mov    edi,0x41ce60
  404c93:	e8 38 54 00 00       	call   40a0d0 <cos_print_str>
  404c98:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404c9f:	00 00 00 00 
  404ca3:	0f 0b                	ud2    
	return t != &g->idle_thd && t != &g->sched_thd;
  404ca5:	49 81 fe 40 1f 5a 00 	cmp    r14,0x5a1f40
  404cac:	74 09                	je     404cb7 <thd_alloc+0x377>
  404cae:	49 81 fe c8 1e 5a 00 	cmp    r14,0x5a1ec8
  404cb5:	75 d2                	jne    404c89 <thd_alloc+0x349>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  404cb7:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]
--
  404cc7:	48 8b 3d 0a d2 19 00 	mov    rdi,QWORD PTR [rip+0x19d20a]        # 5a1ed8 <__slm_global+0x18>
  404cce:	31 f6                	xor    esi,esi
  404cd0:	e8 4b c6 00 00       	call   411320 <cos_switch>
  404cd5:	eb a1                	jmp    404c78 <thd_alloc+0x338>
			prio    = curr->priority;
  404cd7:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
			timeout = TCAP_TIME_NIL;
  404cdb:	31 c9                	xor    ecx,ecx
  404cdd:	e9 66 ff ff ff       	jmp    404c48 <thd_alloc+0x308>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  404ce2:	49 8b 7e 28          	mov    rdi,QWORD PTR [r14+0x28]
--
  404ced:	44 89 f9             	mov    ecx,r15d
  404cf0:	4c 89 c6             	mov    rsi,r8
  404cf3:	e8 98 c6 00 00       	call   411390 <cos_sched_asnd>
  404cf8:	e9 7b ff ff ff       	jmp    404c78 <thd_alloc+0x338>
  404cfd:	be 61 00 00 00       	mov    esi,0x61
  404d02:	bf c8 ce 41 00       	mov    edi,0x41cec8
  404d07:	e8 c4 53 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  404d0c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  404d1f:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  404d24:	41 83 e0 01          	and    r8d,0x1
  404d28:	e8 e3 ea 00 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  404d2d:	83 f8 f0             	cmp    eax,0xfffffff0
  404d30:	0f 85 ee fd ff ff    	jne    404b24 <thd_alloc+0x1e4>
  404d36:	e9 c5 fe ff ff       	jmp    404c00 <thd_alloc+0x2c0>
  404d3b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  404d40:	be 61 00 00 00       	mov    esi,0x61
  404d45:	bf 30 cf 41 00       	mov    edi,0x41cf30
  404d4a:	e8 81 53 00 00       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  404d4f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	struct slm_thd *ret     = NULL, *thd;
	struct slm_thd *current = slm_thd_current_extern();
  404d81:	e8 ba cb ff ff       	call   401940 <slm_thd_current_extern>

	/*
--
  404d86:	49 89 c5             	mov    r13,rax
  404d89:	48 85 c0             	test   rax,rax
  404d8c:	0f 84 2e 02 00 00    	je     404fc0 <thd_alloc_in+0x260>
	_cap = capmgr_thd_create_ext(cid, idx, &_tid);
  404d92:	41 0f b7 fc          	movzx  edi,r12w
  404d96:	48 8d 55 c8          	lea    rdx,[rbp-0x38]
  404d9a:	44 89 f6             	mov    esi,r14d
  404d9d:	e8 ce 1d 00 00       	call   406b70 <__cosrt_extern_capmgr_thd_create_ext>
  404da2:	48 89 c7             	mov    rdi,rax
	if (_cap <= 0) return NULL;
  404da5:	48 85 c0             	test   rax,rax
  404da8:	0f 84 98 00 00 00    	je     404e46 <thd_alloc_in+0xe6>
	return slm_thd_mem_alloc(_cap, _tid, thd, tid);
  404dae:	48 8b 75 c8          	mov    rsi,QWORD PTR [rbp-0x38]
  404db2:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  404db6:	48 8d 55 b8          	lea    rdx,[rbp-0x48]
  404dba:	e8 f1 cb ff ff       	call   4019b0 <slm_thd_mem_alloc>
  404dbf:	49 89 c6             	mov    r14,rax
		current = slm_thd_special();
--
	if (!t) ERR_THROW(NULL, done);
  404dc2:	48 85 c0             	test   rax,rax
  404dc5:	74 7f                	je     404e46 <thd_alloc_in+0xe6>
	thd = slm_thd_from_container(t);
  404dc7:	48 89 c7             	mov    rdi,rax
  404dca:	e8 d1 cb ff ff       	call   4019a0 <slm_thd_from_container>
  404dcf:	49 89 c4             	mov    r12,rax
		tok    = cos_sched_sync();
  404dd2:	e8 29 c5 00 00       	call   411300 <cos_sched_sync>
  404dd7:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  404de1:	48 89 c1             	mov    rcx,rax
  404de4:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  404de8:	0f 85 02 02 00 00    	jne    404ff0 <thd_alloc_in+0x290>
  404dee:	f0 4c 0f b1 2d c9 d0 	lock cmpxchg QWORD PTR [rip+0x19d0c9],r13        # 5a1ec0 <__slm_global>
  404df5:	19 00 
  404df7:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  404dfa:	84 c0                	test   al,al
  404dfc:	74 d4                	je     404dd2 <thd_alloc_in+0x72>

	slm_cs_enter(current, SLM_CS_NONE);
--
  404e02:	48 8b 75 b8          	mov    rsi,QWORD PTR [rbp-0x48]
  404e06:	4c 89 e7             	mov    rdi,r12
  404e09:	e8 02 e9 00 00       	call   413710 <slm_thd_init>
  404e0e:	85 c0                	test   eax,eax
  404e10:	75 2c                	jne    404e3e <thd_alloc_in+0xde>

	for (i = 0; parameters[i] != 0; i++) {
--
  404e14:	48 83 c3 04          	add    rbx,0x4
  404e18:	85 f6                	test   esi,esi
  404e1a:	75 0e                	jne    404e2a <thd_alloc_in+0xca>
  404e1c:	eb 42                	jmp    404e60 <thd_alloc_in+0x100>
  404e1e:	66 90                	xchg   ax,ax
  404e20:	8b 33                	mov    esi,DWORD PTR [rbx]
  404e22:	48 83 c3 04          	add    rbx,0x4
  404e26:	85 f6                	test   esi,esi
  404e28:	74 36                	je     404e60 <thd_alloc_in+0x100>
  404e2a:	89 f2                	mov    edx,esi
		sched_param_type_t type;
--
	if (value) *value = (unsigned int)      (sp >> SCHED_PARAM_TYPE_BITS);
  404e32:	c1 ea 06             	shr    edx,0x6
  404e35:	e8 26 c9 ff ff       	call   401760 <slm_sched_thd_update>
  404e3a:	85 c0                	test   eax,eax
  404e3c:	74 e2                	je     404e20 <thd_alloc_in+0xc0>

	ret = thd;
--
	slm_thd_mem_free(t);
  404e3e:	4c 89 f7             	mov    rdi,r14
  404e41:	e8 0a cd ff ff       	call   401b50 <slm_thd_mem_free>
	ret = NULL;
  404e46:	45 31 e4             	xor    r12d,r12d
--
	slm_thd_mem_activate(t);
  404e60:	4c 89 f7             	mov    rdi,r14
  404e63:	e8 28 cc ff ff       	call   401a90 <slm_thd_mem_activate>
	if (reschedule) {
  404e68:	45 85 ff             	test   r15d,r15d
  404e6b:	0f 84 13 01 00 00    	je     404f84 <thd_alloc_in+0x224>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  404e71:	e8 ea 69 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(!t)) t = &g->idle_thd;
  404e76:	41 bf 40 1f 5a 00    	mov    r15d,0x5a1f40
	tok  = cos_sched_sync();
  404e7c:	e8 7f c4 00 00       	call   411300 <cos_sched_sync>
  404e81:	41 89 c6             	mov    r14d,eax
	t = slm_sched_schedule();
  404e84:	e8 17 c9 ff ff       	call   4017a0 <slm_sched_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  404e89:	48 85 c0             	test   rax,rax
--
  404e96:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  404e99:	83 f8 01             	cmp    eax,0x1
  404e9c:	76 1a                	jbe    404eb8 <thd_alloc_in+0x158>
  404e9e:	e9 89 01 00 00       	jmp    40502c <thd_alloc_in+0x2cc>
  404ea3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  404ea8:	f0 48 0f b1 15 0f d0 	lock cmpxchg QWORD PTR [rip+0x19d00f],rdx        # 5a1ec0 <__slm_global>
  404eaf:	19 00 
  404eb1:	0f 94 c0             	sete   al
	while (ret != 0) {
  404eb4:	84 c0                	test   al,al
  404eb6:	75 2e                	jne    404ee6 <thd_alloc_in+0x186>
		tok    = cos_sched_sync();
  404eb8:	e8 43 c4 00 00       	call   411300 <cos_sched_sync>
  404ebd:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  404ec6:	48 89 c2             	mov    rdx,rax
  404ec9:	83 e2 01             	and    edx,0x1
  404ecc:	74 da                	je     404ea8 <thd_alloc_in+0x148>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  404ece:	48 89 c6             	mov    rsi,rax
--
  404ed4:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  404ed9:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  404edd:	e8 7e e9 00 00       	call   413860 <slm_cs_exit_contention>
  404ee2:	85 c0                	test   eax,eax
  404ee4:	75 d2                	jne    404eb8 <thd_alloc_in+0x158>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  404ee6:	e8 75 69 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  404eeb:	8b 03                	mov    eax,DWORD PTR [rbx]
--
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  404ef8:	a8 0b                	test   al,0xb
  404efa:	0f 85 48 01 00 00    	jne    405048 <thd_alloc_in+0x2e8>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  404f00:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  404f04:	44 89 f1             	mov    ecx,r14d
  404f07:	4c 89 c2             	mov    rdx,r8
  404f0a:	e8 51 78 00 00       	call   40c760 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  404f0f:	83 f8 ff             	cmp    eax,0xffffffff
  404f12:	0f 84 9d 01 00 00    	je     4050b5 <thd_alloc_in+0x355>
	if (unlikely(ret != 0)) {
  404f18:	85 c0                	test   eax,eax
  404f1a:	0f 84 29 ff ff ff    	je     404e49 <thd_alloc_in+0xe9>
		assert(ret != -EINVAL);
  404f20:	83 f8 ea             	cmp    eax,0xffffffea
  404f23:	0f 84 e4 01 00 00    	je     40510d <thd_alloc_in+0x3ad>
		if (ret == -EBUSY) return ret;
  404f29:	83 f8 f0             	cmp    eax,0xfffffff0
  404f2c:	0f 84 14 ff ff ff    	je     404e46 <thd_alloc_in+0xe6>
		assert(ret == -EAGAIN);
  404f32:	83 f8 f5             	cmp    eax,0xfffffff5
  404f35:	0f 85 15 02 00 00    	jne    405150 <thd_alloc_in+0x3f0>
		tok    = cos_sched_sync();
  404f3b:	e8 c0 c3 00 00       	call   411300 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  404f40:	48 8b 35 79 cf 19 00 	mov    rsi,QWORD PTR [rip+0x19cf79]        # 5a1ec0 <__slm_global>
--
  404f4a:	48 89 f1             	mov    rcx,rsi
  404f4d:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  404f51:	0f 85 d2 01 00 00    	jne    405129 <thd_alloc_in+0x3c9>
  404f57:	48 89 f0             	mov    rax,rsi
  404f5a:	f0 4c 0f b1 2d 5d cf 	lock cmpxchg QWORD PTR [rip+0x19cf5d],r13        # 5a1ec0 <__slm_global>
  404f61:	19 00 
  404f63:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  404f66:	84 c0                	test   al,al
  404f68:	0f 85 0e ff ff ff    	jne    404e7c <thd_alloc_in+0x11c>
  404f6e:	eb cb                	jmp    404f3b <thd_alloc_in+0x1db>
  404f70:	f0 48 0f b1 15 47 cf 	lock cmpxchg QWORD PTR [rip+0x19cf47],rdx        # 5a1ec0 <__slm_global>
  404f77:	19 00 
  404f79:	0f 94 c0             	sete   al
	while (ret != 0) {
  404f7c:	84 c0                	test   al,al
  404f7e:	0f 85 c5 fe ff ff    	jne    404e49 <thd_alloc_in+0xe9>
		tok    = cos_sched_sync();
  404f84:	e8 77 c3 00 00       	call   411300 <cos_sched_sync>
  404f89:	89 c1                	mov    ecx,eax
  404f8b:	48 8b 05 2e cf 19 00 	mov    rax,QWORD PTR [rip+0x19cf2e]        # 5a1ec0 <__slm_global>
--
  404f92:	48 89 c2             	mov    rdx,rax
  404f95:	83 e2 01             	and    edx,0x1
  404f98:	74 d6                	je     404f70 <thd_alloc_in+0x210>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  404f9a:	48 89 c6             	mov    rsi,rax
--
  404fa0:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  404fa5:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  404fa9:	e8 b2 e8 00 00       	call   413860 <slm_cs_exit_contention>
  404fae:	85 c0                	test   eax,eax
  404fb0:	0f 84 93 fe ff ff    	je     404e49 <thd_alloc_in+0xe9>
  404fb6:	eb cc                	jmp    404f84 <thd_alloc_in+0x224>
  404fb8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  404fbf:	00 
		current = slm_thd_special();
  404fc0:	e8 0b e7 00 00       	call   4136d0 <slm_thd_special>
  404fc5:	49 89 c5             	mov    r13,rax
		assert(current);
  404fc8:	48 85 c0             	test   rax,rax
  404fcb:	0f 85 c1 fd ff ff    	jne    404d92 <thd_alloc_in+0x32>
  404fd1:	be 29 00 00 00       	mov    esi,0x29
  404fd6:	bf 98 cf 41 00       	mov    edi,0x41cf98
  404fdb:	e8 f0 50 00 00       	call   40a0d0 <cos_print_str>
  404fe0:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404fe7:	00 00 00 00 
--
  404ff9:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  404ffe:	41 83 e0 01          	and    r8d,0x1
  405002:	e8 09 e8 00 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  405007:	83 f8 f0             	cmp    eax,0xfffffff0
  40500a:	0f 85 c2 fd ff ff    	jne    404dd2 <thd_alloc_in+0x72>
  405010:	be 59 00 00 00       	mov    esi,0x59
  405015:	bf 98 cd 41 00       	mov    edi,0x41cd98
  40501a:	e8 b1 50 00 00       	call   40a0d0 <cos_print_str>
  40501f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  405026:	00 00 00 00 
--
  40502c:	be 61 00 00 00       	mov    esi,0x61
  405031:	bf f8 cd 41 00       	mov    edi,0x41cdf8
  405036:	e8 95 50 00 00       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  40503b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  405048:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  40504b:	48 81 fb c8 1e 5a 00 	cmp    rbx,0x5a1ec8
  405052:	0f 84 8f 00 00 00    	je     4050e7 <thd_alloc_in+0x387>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  405058:	a8 02                	test   al,0x2
  40505a:	0f 85 92 00 00 00    	jne    4050f2 <thd_alloc_in+0x392>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  405060:	49 89 c8             	mov    r8,rcx
  405063:	a8 01                	test   al,0x1
  405065:	0f 84 95 fe ff ff    	je     404f00 <thd_alloc_in+0x1a0>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  40506b:	4c 8b 53 08          	mov    r10,QWORD PTR [rbx+0x8]
--
  405079:	4c 8b 05 68 ce 19 00 	mov    r8,QWORD PTR [rip+0x19ce68]        # 5a1ee8 <__slm_global+0x28>
  405080:	4c 89 d6             	mov    rsi,r10
  405083:	e8 98 c2 00 00       	call   411320 <cos_switch>
	if (unlikely(ret != 0)) {
  405088:	85 c0                	test   eax,eax
  40508a:	0f 84 b9 fd ff ff    	je     404e49 <thd_alloc_in+0xe9>
		assert(ret != -EPERM);
  405090:	83 f8 ff             	cmp    eax,0xffffffff
  405093:	0f 85 87 fe ff ff    	jne    404f20 <thd_alloc_in+0x1c0>
  405099:	be 61 00 00 00       	mov    esi,0x61
  40509e:	bf 60 ce 41 00       	mov    edi,0x41ce60
  4050a3:	e8 28 50 00 00       	call   40a0d0 <cos_print_str>
  4050a8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4050af:	00 00 00 00 
  4050b3:	0f 0b                	ud2    
	return t != &g->idle_thd && t != &g->sched_thd;
  4050b5:	48 81 fb 40 1f 5a 00 	cmp    rbx,0x5a1f40
  4050bc:	74 09                	je     4050c7 <thd_alloc_in+0x367>
  4050be:	48 81 fb c8 1e 5a 00 	cmp    rbx,0x5a1ec8
  4050c5:	75 d2                	jne    405099 <thd_alloc_in+0x339>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  4050c7:	49 8b 55 30          	mov    rdx,QWORD PTR [r13+0x30]
--
  4050d7:	48 8b 3d fa cd 19 00 	mov    rdi,QWORD PTR [rip+0x19cdfa]        # 5a1ed8 <__slm_global+0x18>
  4050de:	31 f6                	xor    esi,esi
  4050e0:	e8 3b c2 00 00       	call   411320 <cos_switch>
  4050e5:	eb a1                	jmp    405088 <thd_alloc_in+0x328>
			prio    = curr->priority;
  4050e7:	49 8b 75 30          	mov    rsi,QWORD PTR [r13+0x30]
			timeout = TCAP_TIME_NIL;
  4050eb:	31 c9                	xor    ecx,ecx
  4050ed:	e9 66 ff ff ff       	jmp    405058 <thd_alloc_in+0x2f8>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  4050f2:	48 8b 7b 28          	mov    rdi,QWORD PTR [rbx+0x28]
--
  4050fd:	44 89 f1             	mov    ecx,r14d
  405100:	4c 89 c6             	mov    rsi,r8
  405103:	e8 88 c2 00 00       	call   411390 <cos_sched_asnd>
  405108:	e9 7b ff ff ff       	jmp    405088 <thd_alloc_in+0x328>
  40510d:	be 61 00 00 00       	mov    esi,0x61
  405112:	bf c8 ce 41 00       	mov    edi,0x41cec8
  405117:	e8 b4 4f 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  40511c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40512f:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  405134:	41 83 e0 01          	and    r8d,0x1
  405138:	e8 d3 e6 00 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  40513d:	83 f8 f0             	cmp    eax,0xfffffff0
  405140:	0f 85 f5 fd ff ff    	jne    404f3b <thd_alloc_in+0x1db>
  405146:	e9 c5 fe ff ff       	jmp    405010 <thd_alloc_in+0x2b0>
  40514b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  405150:	be 61 00 00 00       	mov    esi,0x61
  405155:	bf 30 cf 41 00       	mov    edi,0x41cf30
  40515a:	e8 71 4f 00 00       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  40515f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  405170:	48 b9 7f 51 40 00 00 	movabs rcx,0x40517f
  405177:	00 00 00 
  40517a:	e9 31 57 00 00       	jmp    40a8b0 <custom_acquire_stack>
  40517f:	52                   	push   rdx
  405180:	50                   	push   rax
--
  40518e:	48 89 c2             	mov    rdx,rax
  405191:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405195:	e8 86 f2 ff ff       	call   404420 <sched_get_cpu_freq>
  40519a:	49 89 c0             	mov    r8,rax
  40519d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  4051a4:	0f 05                	syscall 
  4051a6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4051ad:	00 00 00 
--
  4051b3:	48 b9 c2 51 40 00 00 	movabs rcx,0x4051c2
  4051ba:	00 00 00 
  4051bd:	e9 ee 56 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4051c2:	52                   	push   rdx
  4051c3:	50                   	push   rax
--
  4051ce:	4c 89 c1             	mov    rcx,r8
  4051d1:	4c 89 ca             	mov    rdx,r9
  4051d4:	e8 47 f2 ff ff       	call   404420 <sched_get_cpu_freq>
  4051d9:	59                   	pop    rcx
  4051da:	c3                   	ret    
--
  4051e0:	48 b9 ef 51 40 00 00 	movabs rcx,0x4051ef
  4051e7:	00 00 00 
  4051ea:	e9 c1 56 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4051ef:	52                   	push   rdx
  4051f0:	50                   	push   rax
--
  4051fe:	48 89 c2             	mov    rdx,rax
  405201:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405205:	e8 76 cd ff ff       	call   401f80 <sched_thd_yield_to>
  40520a:	49 89 c0             	mov    r8,rax
  40520d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  405214:	0f 05                	syscall 
  405216:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40521d:	00 00 00 
--
  405223:	48 b9 32 52 40 00 00 	movabs rcx,0x405232
  40522a:	00 00 00 
  40522d:	e9 7e 56 00 00       	jmp    40a8b0 <custom_acquire_stack>
  405232:	52                   	push   rdx
  405233:	50                   	push   rax
--
  40523e:	4c 89 c1             	mov    rcx,r8
  405241:	4c 89 ca             	mov    rdx,r9
  405244:	e8 37 cd ff ff       	call   401f80 <sched_thd_yield_to>
  405249:	59                   	pop    rcx
  40524a:	c3                   	ret    
--
  405250:	48 b9 5f 52 40 00 00 	movabs rcx,0x40525f
  405257:	00 00 00 
  40525a:	e9 51 56 00 00       	jmp    40a8b0 <custom_acquire_stack>
  40525f:	52                   	push   rdx
  405260:	50                   	push   rax
--
  40526e:	48 89 c2             	mov    rdx,rax
  405271:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405275:	e8 76 dc ff ff       	call   402ef0 <sched_thd_wakeup>
  40527a:	49 89 c0             	mov    r8,rax
  40527d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  405284:	0f 05                	syscall 
  405286:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40528d:	00 00 00 
--
  405293:	48 b9 a2 52 40 00 00 	movabs rcx,0x4052a2
  40529a:	00 00 00 
  40529d:	e9 0e 56 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4052a2:	52                   	push   rdx
  4052a3:	50                   	push   rax
--
  4052ae:	4c 89 c1             	mov    rcx,r8
  4052b1:	4c 89 ca             	mov    rdx,r9
  4052b4:	e8 37 dc ff ff       	call   402ef0 <sched_thd_wakeup>
  4052b9:	59                   	pop    rcx
  4052ba:	c3                   	ret    
--
  4052c0:	48 b9 cf 52 40 00 00 	movabs rcx,0x4052cf
  4052c7:	00 00 00 
  4052ca:	e9 e1 55 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4052cf:	52                   	push   rdx
  4052d0:	50                   	push   rax
--
  4052de:	48 89 c2             	mov    rdx,rax
  4052e1:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4052e5:	e8 06 e0 ff ff       	call   4032f0 <sched_debug_thd_state>
  4052ea:	49 89 c0             	mov    r8,rax
  4052ed:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  4052f4:	0f 05                	syscall 
  4052f6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4052fd:	00 00 00 
--
  405303:	48 b9 12 53 40 00 00 	movabs rcx,0x405312
  40530a:	00 00 00 
  40530d:	e9 9e 55 00 00       	jmp    40a8b0 <custom_acquire_stack>
  405312:	52                   	push   rdx
  405313:	50                   	push   rax
--
  40531e:	4c 89 c1             	mov    rcx,r8
  405321:	4c 89 ca             	mov    rdx,r9
  405324:	e8 c7 df ff ff       	call   4032f0 <sched_debug_thd_state>
  405329:	59                   	pop    rcx
  40532a:	c3                   	ret    
--
  405330:	48 b9 3f 53 40 00 00 	movabs rcx,0x40533f
  405337:	00 00 00 
  40533a:	e9 71 55 00 00       	jmp    40a8b0 <custom_acquire_stack>
  40533f:	52                   	push   rdx
  405340:	50                   	push   rax
--
  40534e:	48 89 c2             	mov    rdx,rax
  405351:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405355:	e8 06 d4 ff ff       	call   402760 <sched_thd_block>
  40535a:	49 89 c0             	mov    r8,rax
  40535d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  405364:	0f 05                	syscall 
  405366:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40536d:	00 00 00 
--
  405373:	48 b9 82 53 40 00 00 	movabs rcx,0x405382
  40537a:	00 00 00 
  40537d:	e9 2e 55 00 00       	jmp    40a8b0 <custom_acquire_stack>
  405382:	52                   	push   rdx
  405383:	50                   	push   rax
--
  40538e:	4c 89 c1             	mov    rcx,r8
  405391:	4c 89 ca             	mov    rdx,r9
  405394:	e8 c7 d3 ff ff       	call   402760 <sched_thd_block>
  405399:	59                   	pop    rcx
  40539a:	c3                   	ret    
--
  4053a0:	48 b9 af 53 40 00 00 	movabs rcx,0x4053af
  4053a7:	00 00 00 
  4053aa:	e9 01 55 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4053af:	52                   	push   rdx
  4053b0:	50                   	push   rax
--
  4053be:	48 89 c2             	mov    rdx,rax
  4053c1:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4053c5:	e8 a6 e7 ff ff       	call   403b70 <sched_blkpt_alloc>
  4053ca:	49 89 c0             	mov    r8,rax
  4053cd:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  4053d4:	0f 05                	syscall 
  4053d6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4053dd:	00 00 00 
--
  4053e3:	48 b9 f2 53 40 00 00 	movabs rcx,0x4053f2
  4053ea:	00 00 00 
  4053ed:	e9 be 54 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4053f2:	52                   	push   rdx
  4053f3:	50                   	push   rax
--
  4053fe:	4c 89 c1             	mov    rcx,r8
  405401:	4c 89 ca             	mov    rdx,r9
  405404:	e8 67 e7 ff ff       	call   403b70 <sched_blkpt_alloc>
  405409:	59                   	pop    rcx
  40540a:	c3                   	ret    
--
  405410:	48 b9 1f 54 40 00 00 	movabs rcx,0x40541f
  405417:	00 00 00 
  40541a:	e9 91 54 00 00       	jmp    40a8b0 <custom_acquire_stack>
  40541f:	52                   	push   rdx
  405420:	50                   	push   rax
--
  40542e:	48 89 c2             	mov    rdx,rax
  405431:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405435:	e8 d6 e8 ff ff       	call   403d10 <sched_blkpt_free>
  40543a:	49 89 c0             	mov    r8,rax
  40543d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  405444:	0f 05                	syscall 
  405446:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40544d:	00 00 00 
--
  405453:	48 b9 62 54 40 00 00 	movabs rcx,0x405462
  40545a:	00 00 00 
  40545d:	e9 4e 54 00 00       	jmp    40a8b0 <custom_acquire_stack>
  405462:	52                   	push   rdx
  405463:	50                   	push   rax
--
  40546e:	4c 89 c1             	mov    rcx,r8
  405471:	4c 89 ca             	mov    rdx,r9
  405474:	e8 97 e8 ff ff       	call   403d10 <sched_blkpt_free>
  405479:	59                   	pop    rcx
  40547a:	c3                   	ret    
--
  405480:	48 b9 8f 54 40 00 00 	movabs rcx,0x40548f
  405487:	00 00 00 
  40548a:	e9 21 54 00 00       	jmp    40a8b0 <custom_acquire_stack>
  40548f:	52                   	push   rdx
  405490:	50                   	push   rax
--
  40549e:	48 89 c2             	mov    rdx,rax
  4054a1:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4054a5:	e8 76 e8 ff ff       	call   403d20 <sched_blkpt_trigger>
  4054aa:	49 89 c0             	mov    r8,rax
  4054ad:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  4054b4:	0f 05                	syscall 
  4054b6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4054bd:	00 00 00 
--
  4054c3:	48 b9 d2 54 40 00 00 	movabs rcx,0x4054d2
  4054ca:	00 00 00 
  4054cd:	e9 de 53 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4054d2:	52                   	push   rdx
  4054d3:	50                   	push   rax
--
  4054de:	4c 89 c1             	mov    rcx,r8
  4054e1:	4c 89 ca             	mov    rdx,r9
  4054e4:	e8 37 e8 ff ff       	call   403d20 <sched_blkpt_trigger>
  4054e9:	59                   	pop    rcx
  4054ea:	c3                   	ret    
--
  4054f0:	48 b9 ff 54 40 00 00 	movabs rcx,0x4054ff
  4054f7:	00 00 00 
  4054fa:	e9 b1 53 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4054ff:	52                   	push   rdx
  405500:	50                   	push   rax
--
  40550e:	48 89 c2             	mov    rdx,rax
  405511:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405515:	e8 76 e8 ff ff       	call   403d90 <sched_blkpt_block>
  40551a:	49 89 c0             	mov    r8,rax
  40551d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  405524:	0f 05                	syscall 
  405526:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40552d:	00 00 00 
--
  405533:	48 b9 42 55 40 00 00 	movabs rcx,0x405542
  40553a:	00 00 00 
  40553d:	e9 6e 53 00 00       	jmp    40a8b0 <custom_acquire_stack>
  405542:	52                   	push   rdx
  405543:	50                   	push   rax
--
  40554e:	4c 89 c1             	mov    rcx,r8
  405551:	4c 89 ca             	mov    rdx,r9
  405554:	e8 37 e8 ff ff       	call   403d90 <sched_blkpt_block>
  405559:	59                   	pop    rcx
  40555a:	c3                   	ret    
--
  405560:	48 b9 6f 55 40 00 00 	movabs rcx,0x40556f
  405567:	00 00 00 
  40556a:	e9 41 53 00 00       	jmp    40a8b0 <custom_acquire_stack>
  40556f:	52                   	push   rdx
  405570:	50                   	push   rax
--
  405589:	48 89 df             	mov    rdi,rbx
  40558c:	4c 89 e2             	mov    rdx,r12
  40558f:	e8 1c 03 00 00       	call   4058b0 <__cosrt_s_cstub_sched_thd_block_timeout>
  405594:	5f                   	pop    rdi
  405595:	5e                   	pop    rsi
  405596:	49 89 c0             	mov    r8,rax
  405599:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  4055a0:	0f 05                	syscall 
  4055a2:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4055a9:	00 00 00 00 
--
  4055b3:	48 b9 c2 55 40 00 00 	movabs rcx,0x4055c2
  4055ba:	00 00 00 
  4055bd:	e9 ee 52 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4055c2:	52                   	push   rdx
  4055c3:	50                   	push   rax
--
  4055d9:	6a 00                	push   0x0
  4055db:	49 89 e1             	mov    r9,rsp
  4055de:	e8 cd 02 00 00       	call   4058b0 <__cosrt_s_cstub_sched_thd_block_timeout>
  4055e3:	5f                   	pop    rdi
  4055e4:	5e                   	pop    rsi
--
  4055f0:	48 b9 ff 55 40 00 00 	movabs rcx,0x4055ff
  4055f7:	00 00 00 
  4055fa:	e9 b1 52 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4055ff:	52                   	push   rdx
  405600:	50                   	push   rax
--
  40560e:	48 89 c2             	mov    rdx,rax
  405611:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405615:	e8 46 c5 ff ff       	call   401b60 <sched_thd_create_closure>
  40561a:	49 89 c0             	mov    r8,rax
  40561d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  405624:	0f 05                	syscall 
  405626:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40562d:	00 00 00 
--
  405633:	48 b9 42 56 40 00 00 	movabs rcx,0x405642
  40563a:	00 00 00 
  40563d:	e9 6e 52 00 00       	jmp    40a8b0 <custom_acquire_stack>
  405642:	52                   	push   rdx
  405643:	50                   	push   rax
--
  40564e:	4c 89 c1             	mov    rcx,r8
  405651:	4c 89 ca             	mov    rdx,r9
  405654:	e8 07 c5 ff ff       	call   401b60 <sched_thd_create_closure>
  405659:	59                   	pop    rcx
  40565a:	c3                   	ret    
--
  405660:	48 b9 6f 56 40 00 00 	movabs rcx,0x40566f
  405667:	00 00 00 
  40566a:	e9 41 52 00 00       	jmp    40a8b0 <custom_acquire_stack>
  40566f:	52                   	push   rdx
  405670:	50                   	push   rax
--
  405689:	48 89 df             	mov    rdi,rbx
  40568c:	4c 89 e2             	mov    rdx,r12
  40568f:	e8 4c 02 00 00       	call   4058e0 <__cosrt_s_cstub_sched_aep_create_closure>
  405694:	5f                   	pop    rdi
  405695:	5e                   	pop    rsi
  405696:	49 89 c0             	mov    r8,rax
  405699:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  4056a0:	0f 05                	syscall 
  4056a2:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4056a9:	00 00 00 00 
--
  4056b3:	48 b9 c2 56 40 00 00 	movabs rcx,0x4056c2
  4056ba:	00 00 00 
  4056bd:	e9 ee 51 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4056c2:	52                   	push   rdx
  4056c3:	50                   	push   rax
--
  4056d9:	6a 00                	push   0x0
  4056db:	49 89 e1             	mov    r9,rsp
  4056de:	e8 fd 01 00 00       	call   4058e0 <__cosrt_s_cstub_sched_aep_create_closure>
  4056e3:	5f                   	pop    rdi
  4056e4:	5e                   	pop    rsi
--
  4056f0:	48 b9 ff 56 40 00 00 	movabs rcx,0x4056ff
  4056f7:	00 00 00 
  4056fa:	e9 b1 51 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4056ff:	52                   	push   rdx
  405700:	50                   	push   rax
--
  40570e:	48 89 c2             	mov    rdx,rax
  405711:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405715:	e8 96 c4 ff ff       	call   401bb0 <sched_thd_param_set>
  40571a:	49 89 c0             	mov    r8,rax
  40571d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  405724:	0f 05                	syscall 
  405726:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40572d:	00 00 00 
--
  405733:	48 b9 42 57 40 00 00 	movabs rcx,0x405742
  40573a:	00 00 00 
  40573d:	e9 6e 51 00 00       	jmp    40a8b0 <custom_acquire_stack>
  405742:	52                   	push   rdx
  405743:	50                   	push   rax
--
  40574e:	4c 89 c1             	mov    rcx,r8
  405751:	4c 89 ca             	mov    rdx,r9
  405754:	e8 57 c4 ff ff       	call   401bb0 <sched_thd_param_set>
  405759:	59                   	pop    rcx
  40575a:	c3                   	ret    
--
  405760:	48 b9 6f 57 40 00 00 	movabs rcx,0x40576f
  405767:	00 00 00 
  40576a:	e9 41 51 00 00       	jmp    40a8b0 <custom_acquire_stack>
  40576f:	52                   	push   rdx
  405770:	50                   	push   rax
--
  40577e:	48 89 c2             	mov    rdx,rax
  405781:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405785:	e8 86 c4 ff ff       	call   401c10 <sched_thd_exit>
  40578a:	49 89 c0             	mov    r8,rax
  40578d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  405794:	0f 05                	syscall 
  405796:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40579d:	00 00 00 
--
  4057a3:	48 b9 b2 57 40 00 00 	movabs rcx,0x4057b2
  4057aa:	00 00 00 
  4057ad:	e9 fe 50 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4057b2:	52                   	push   rdx
  4057b3:	50                   	push   rax
--
  4057be:	4c 89 c1             	mov    rcx,r8
  4057c1:	4c 89 ca             	mov    rdx,r9
  4057c4:	e8 47 c4 ff ff       	call   401c10 <sched_thd_exit>
  4057c9:	59                   	pop    rcx
  4057ca:	c3                   	ret    
--
  4057d0:	48 b9 df 57 40 00 00 	movabs rcx,0x4057df
  4057d7:	00 00 00 
  4057da:	e9 d1 50 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4057df:	52                   	push   rdx
  4057e0:	50                   	push   rax
--
  4057ee:	48 89 c2             	mov    rdx,rax
  4057f1:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4057f5:	e8 06 c4 ff ff       	call   401c00 <sched_thd_delete>
  4057fa:	49 89 c0             	mov    r8,rax
  4057fd:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  405804:	0f 05                	syscall 
  405806:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40580d:	00 00 00 
--
  405813:	48 b9 22 58 40 00 00 	movabs rcx,0x405822
  40581a:	00 00 00 
  40581d:	e9 8e 50 00 00       	jmp    40a8b0 <custom_acquire_stack>
  405822:	52                   	push   rdx
  405823:	50                   	push   rax
--
  40582e:	4c 89 c1             	mov    rcx,r8
  405831:	4c 89 ca             	mov    rdx,r9
  405834:	e8 c7 c3 ff ff       	call   401c00 <sched_thd_delete>
  405839:	59                   	pop    rcx
  40583a:	c3                   	ret    
--
  405840:	48 b9 4f 58 40 00 00 	movabs rcx,0x40584f
  405847:	00 00 00 
  40584a:	e9 61 50 00 00       	jmp    40a8b0 <custom_acquire_stack>
  40584f:	52                   	push   rdx
  405850:	50                   	push   rax
--
  40585e:	48 89 c2             	mov    rdx,rax
  405861:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405865:	e8 d6 ca ff ff       	call   402340 <sched_set_tls>
  40586a:	49 89 c0             	mov    r8,rax
  40586d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  405874:	0f 05                	syscall 
  405876:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40587d:	00 00 00 
--
  405883:	48 b9 92 58 40 00 00 	movabs rcx,0x405892
  40588a:	00 00 00 
  40588d:	e9 1e 50 00 00       	jmp    40a8b0 <custom_acquire_stack>
  405892:	52                   	push   rdx
  405893:	50                   	push   rax
--
  40589e:	4c 89 c1             	mov    rcx,r8
  4058a1:	4c 89 ca             	mov    rdx,r9
  4058a4:	e8 97 ca ff ff       	call   402340 <sched_set_tls>
  4058a9:	59                   	pop    rcx
  4058aa:	c3                   	ret    
--
	COS_ARG_WORDS_TO_DWORD(p1, p2, abs_timeout);
	elapsed = sched_thd_block_timeout((thdid_t)p0, abs_timeout);
  4058c1:	e8 7a da ff ff       	call   403340 <sched_thd_block_timeout>
	*r1 = (elapsed >> 32);
  4058c6:	48 89 c2             	mov    rdx,rax
--
  405909:	48 83 ec 10          	sub    rsp,0x10
	ret = sched_aep_create_closure(idx, owntc, key, ipiwin, ipimax, &rcv);
  40590d:	e8 fe ea ff ff       	call   404410 <sched_aep_create_closure>

	*r1 = rcv;
--
  405930:	48 b9 3f 59 40 00 00 	movabs rcx,0x40593f
  405937:	00 00 00 
  40593a:	e9 71 4f 00 00       	jmp    40a8b0 <custom_acquire_stack>
  40593f:	52                   	push   rdx
  405940:	50                   	push   rax
--
  40594e:	48 89 c2             	mov    rdx,rax
  405951:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405955:	e8 a6 aa ff ff       	call   400400 <init_done>
  40595a:	49 89 c0             	mov    r8,rax
  40595d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  405964:	0f 05                	syscall 
  405966:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40596d:	00 00 00 
--
  405973:	48 b9 82 59 40 00 00 	movabs rcx,0x405982
  40597a:	00 00 00 
  40597d:	e9 2e 4f 00 00       	jmp    40a8b0 <custom_acquire_stack>
  405982:	52                   	push   rdx
  405983:	50                   	push   rax
--
  40598e:	4c 89 c1             	mov    rcx,r8
  405991:	4c 89 ca             	mov    rdx,r9
  405994:	e8 67 aa ff ff       	call   400400 <init_done>
  405999:	59                   	pop    rcx
  40599a:	c3                   	ret    
--
  4059a0:	48 b9 af 59 40 00 00 	movabs rcx,0x4059af
  4059a7:	00 00 00 
  4059aa:	e9 01 4f 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4059af:	52                   	push   rdx
  4059b0:	50                   	push   rax
--
  4059be:	48 89 c2             	mov    rdx,rax
  4059c1:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4059c5:	e8 56 ab ff ff       	call   400520 <init_exit>
  4059ca:	49 89 c0             	mov    r8,rax
  4059cd:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  4059d4:	0f 05                	syscall 
  4059d6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4059dd:	00 00 00 
--
  4059e3:	48 b9 f2 59 40 00 00 	movabs rcx,0x4059f2
  4059ea:	00 00 00 
  4059ed:	e9 be 4e 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4059f2:	52                   	push   rdx
  4059f3:	50                   	push   rax
--
  4059fe:	4c 89 c1             	mov    rcx,r8
  405a01:	4c 89 ca             	mov    rdx,r9
  405a04:	e8 17 ab ff ff       	call   400520 <init_exit>
  405a09:	59                   	pop    rcx
  405a0a:	c3                   	ret    
--
  405a2a:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  405a2e:	4d 85 ed             	test   r13,r13
  405a31:	74 2d                	je     405a60 <__cosrt_c_init_done+0x50>
  405a33:	4c 8d 4d d0          	lea    r9,[rbp-0x30]
  405a37:	4c 8d 45 c8          	lea    r8,[rbp-0x38]
--
  405a3d:	31 d2                	xor    edx,edx
  405a3f:	4c 89 d7             	mov    rdi,r10
  405a42:	41 ff d5             	call   r13
	ps_store(&awaiting_init, 0);
  405a45:	c7 05 b5 e5 01 00 00 	mov    DWORD PTR [rip+0x1e5b5],0x0        # 424004 <awaiting_init>
--
  405a7d:	49 b8 98 5a 40 00 00 	movabs r8,0x405a98
  405a84:	00 00 00 
  405a87:	0f 05                	syscall 
  405a89:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  405a90:	eb 0d                	jmp    405a9f <__cosrt_c_init_done+0x8f>
  405a92:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  405a98:	b9 00 00 00 00       	mov    ecx,0x0
  405a9d:	eb 05                	jmp    405aa4 <__cosrt_c_init_done+0x94>
  405a9f:	b9 01 00 00 00       	mov    ecx,0x1
  405aa4:	5d                   	pop    rbp
  405aa5:	5c                   	pop    rsp
	return call_cap_op(uc->cap_no, 0, arg1, arg2, arg3, arg4);
  405aa6:	eb 9d                	jmp    405a45 <__cosrt_c_init_done+0x35>
  405aa8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  405aaf:	00 
--
  405ab8:	8b 05 46 e5 01 00    	mov    eax,DWORD PTR [rip+0x1e546]        # 424004 <awaiting_init>
  405abe:	85 c0                	test   eax,eax
  405ac0:	75 f6                	jne    405ab8 <__cosrt_extern_init_parallel_await_init+0x8>
}
  405ac2:	c3                   	ret    
--
  405ad0:	48 b8 cc c0 45 00 00 	movabs rax,0x45c0cc
  405ad7:	00 00 00 
  405ada:	ff 10                	call   QWORD PTR [rax]
  405adc:	c3                   	ret    
  405add:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000405ae0 <__cosrt_fast_callgate_init_done>:
  405ae0:	55                   	push   rbp
  405ae1:	41 55                	push   r13
--
  405ba1:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  405ba8:	be ad de 
  405bab:	49 39 c7             	cmp    r15,rax
  405bae:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  405bb5:	12 12 12 
  405bb8:	48 b9 c4 5b 40 00 00 	movabs rcx,0x405bc4
  405bbf:	00 00 00 
  405bc2:	ff e0                	jmp    rax

0000000000405bc4 <srv_call_ret_init_done>:
  405bc4:	49 89 c0             	mov    r8,rax
  405bc7:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
--
  405c4d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  405c54:	be ad de 
  405c57:	49 39 c7             	cmp    r15,rax
  405c5a:	4c 89 c0             	mov    rax,r8
  405c5d:	41 5f                	pop    r15
--
  405c70:	48 b8 e4 c0 45 00 00 	movabs rax,0x45c0e4
  405c77:	00 00 00 
  405c7a:	ff 10                	call   QWORD PTR [rax]
  405c7c:	c3                   	ret    
  405c7d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000405c80 <__cosrt_fast_callgate_init_exit>:
  405c80:	55                   	push   rbp
  405c81:	41 55                	push   r13
--
  405d41:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  405d48:	be ad de 
  405d4b:	49 39 c7             	cmp    r15,rax
  405d4e:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  405d55:	12 12 12 
  405d58:	48 b9 64 5d 40 00 00 	movabs rcx,0x405d64
  405d5f:	00 00 00 
  405d62:	ff e0                	jmp    rax

0000000000405d64 <srv_call_ret_init_exit>:
  405d64:	49 89 c0             	mov    r8,rax
  405d67:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
--
  405ded:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  405df4:	be ad de 
  405df7:	49 39 c7             	cmp    r15,rax
  405dfa:	4c 89 c0             	mov    rax,r8
  405dfd:	41 5f                	pop    r15
--
  405e35:	4c 89 45 a8          	mov    QWORD PTR [rbp-0x58],r8
  405e39:	4d 85 ff             	test   r15,r15
  405e3c:	74 4a                	je     405e88 <__cosrt_c_capmgr_rcv_create+0x78>
  405e3e:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  405e42:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
--
  405e48:	31 d2                	xor    edx,edx
  405e4a:	48 89 df             	mov    rdi,rbx
  405e4d:	41 ff d7             	call   r15
	*asnd   = asnd_ret;
  405e50:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
--
  405e83:	c3                   	ret    
  405e84:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  405e88:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
--
  405ea6:	49 b8 c0 5e 40 00 00 	movabs r8,0x405ec0
  405ead:	00 00 00 
  405eb0:	0f 05                	syscall 
  405eb2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  405eb8:	eb 0f                	jmp    405ec9 <__cosrt_c_capmgr_rcv_create+0xb9>
  405eba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  405ec0:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  405ec7:	eb 07                	jmp    405ed0 <__cosrt_c_capmgr_rcv_create+0xc0>
  405ec9:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  405ed0:	5d                   	pop    rbp
--
  405ed6:	48 89 7d b0          	mov    QWORD PTR [rbp-0x50],rdi
	return ret;
  405eda:	e9 71 ff ff ff       	jmp    405e50 <__cosrt_c_capmgr_rcv_create+0x40>
  405edf:	90                   	nop

--
  405ef4:	48 8b 58 10          	mov    rbx,QWORD PTR [rax+0x10]
  405ef8:	48 85 db             	test   rbx,rbx
  405efb:	74 2b                	je     405f28 <__cosrt_c_capmgr_shared_kernel_page_create+0x48>
  405efd:	4c 8d 4d c8          	lea    r9,[rbp-0x38]
  405f01:	4c 8d 45 c0          	lea    r8,[rbp-0x40]
--
  405f09:	31 f6                	xor    esi,esi
  405f0b:	31 ff                	xor    edi,edi
  405f0d:	ff d3                	call   rbx
	COS_CLIENT_INVCAP;
	word_t ret1, ret2;
--
  405f23:	c3                   	ret    
  405f24:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  405f28:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
--
  405f49:	49 b8 60 5f 40 00 00 	movabs r8,0x405f60
  405f50:	00 00 00 
  405f53:	0f 05                	syscall 
  405f55:	0f 1f 00             	nop    DWORD PTR [rax]
  405f58:	eb 0f                	jmp    405f69 <__cosrt_c_capmgr_shared_kernel_page_create+0x89>
  405f5a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  405f60:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  405f67:	eb 07                	jmp    405f70 <__cosrt_c_capmgr_shared_kernel_page_create+0x90>
  405f69:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  405f70:	5d                   	pop    rbp
--
  405f72:	48 89 75 c0          	mov    QWORD PTR [rbp-0x40],rsi
	return ret;
  405f76:	eb 97                	jmp    405f0f <__cosrt_c_capmgr_shared_kernel_page_create+0x2f>
  405f78:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  405f7f:	00 
--
  405f94:	48 8b 58 10          	mov    rbx,QWORD PTR [rax+0x10]
  405f98:	48 85 db             	test   rbx,rbx
  405f9b:	74 2b                	je     405fc8 <__cosrt_c_capmgr_vm_lapic_create+0x48>
  405f9d:	4c 8d 4d c8          	lea    r9,[rbp-0x38]
  405fa1:	4c 8d 45 c0          	lea    r8,[rbp-0x40]
--
  405fa9:	31 f6                	xor    esi,esi
  405fab:	31 ff                	xor    edi,edi
  405fad:	ff d3                	call   rbx
  405faf:	48 8b 55 c0          	mov    rdx,QWORD PTR [rbp-0x40]
  405fb3:	48 98                	cdqe   
--
  405fe9:	49 b8 00 60 40 00 00 	movabs r8,0x406000
  405ff0:	00 00 00 
  405ff3:	0f 05                	syscall 
  405ff5:	0f 1f 00             	nop    DWORD PTR [rax]
  405ff8:	eb 0f                	jmp    406009 <__cosrt_c_capmgr_vm_lapic_create+0x89>
  405ffa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  406000:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  406007:	eb 07                	jmp    406010 <__cosrt_c_capmgr_vm_lapic_create+0x90>
  406009:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  406010:	5d                   	pop    rbp
  406011:	5c                   	pop    rsp
  406012:	48 89 75 c0          	mov    QWORD PTR [rbp-0x40],rsi
  406016:	eb 97                	jmp    405faf <__cosrt_c_capmgr_vm_lapic_create+0x2f>
  406018:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40601f:	00 
--
  406034:	48 8b 58 10          	mov    rbx,QWORD PTR [rax+0x10]
  406038:	48 85 db             	test   rbx,rbx
  40603b:	74 2b                	je     406068 <__cosrt_c_capmgr_vm_shared_region_create+0x48>
  40603d:	4c 8d 4d c8          	lea    r9,[rbp-0x38]
  406041:	4c 8d 45 c0          	lea    r8,[rbp-0x40]
--
  406049:	31 f6                	xor    esi,esi
  40604b:	31 ff                	xor    edi,edi
  40604d:	ff d3                	call   rbx
  40604f:	48 8b 55 c0          	mov    rdx,QWORD PTR [rbp-0x40]
  406053:	48 98                	cdqe   
--
  406089:	49 b8 a0 60 40 00 00 	movabs r8,0x4060a0
  406090:	00 00 00 
  406093:	0f 05                	syscall 
  406095:	0f 1f 00             	nop    DWORD PTR [rax]
  406098:	eb 0f                	jmp    4060a9 <__cosrt_c_capmgr_vm_shared_region_create+0x89>
  40609a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4060a0:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  4060a7:	eb 07                	jmp    4060b0 <__cosrt_c_capmgr_vm_shared_region_create+0x90>
  4060a9:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  4060b0:	5d                   	pop    rbp
  4060b1:	5c                   	pop    rsp
  4060b2:	48 89 75 c0          	mov    QWORD PTR [rbp-0x40],rsi
  4060b6:	eb 97                	jmp    40604f <__cosrt_c_capmgr_vm_shared_region_create+0x2f>
  4060b8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4060bf:	00 
--
  4060d8:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  4060dc:	4d 85 f6             	test   r14,r14
  4060df:	74 2f                	je     406110 <__cosrt_c_capmgr_vm_vcpu_create+0x50>
  4060e1:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  4060e5:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  4060e9:	31 c9                	xor    ecx,ecx
  4060eb:	31 d2                	xor    edx,edx
  4060ed:	41 ff d6             	call   r14
	COS_CLIENT_INVCAP;
	word_t unused, tid_ret;
--
  406108:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40610f:	00 
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  406110:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
--
  406131:	49 b8 48 61 40 00 00 	movabs r8,0x406148
  406138:	00 00 00 
  40613b:	0f 05                	syscall 
  40613d:	0f 1f 00             	nop    DWORD PTR [rax]
  406140:	eb 0f                	jmp    406151 <__cosrt_c_capmgr_vm_vcpu_create+0x91>
  406142:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  406148:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  40614f:	eb 07                	jmp    406158 <__cosrt_c_capmgr_vm_vcpu_create+0x98>
  406151:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  406158:	5d                   	pop    rbp
--
  40615a:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  40615e:	eb 90                	jmp    4060f0 <__cosrt_c_capmgr_vm_vcpu_create+0x30>

0000000000406160 <__cosrt_c_capmgr_initthd_create>:
--
  40617c:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  406180:	4d 85 f6             	test   r14,r14
  406183:	74 33                	je     4061b8 <__cosrt_c_capmgr_initthd_create+0x58>
  406185:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  406189:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
--
  406191:	31 f6                	xor    esi,esi
  406193:	4c 89 ff             	mov    rdi,r15
  406196:	41 ff d6             	call   r14
	*tid = tid_ret;
  406199:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
--
  4061b1:	c3                   	ret    
  4061b2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  4061b8:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
--
  4061dc:	49 b8 f0 61 40 00 00 	movabs r8,0x4061f0
  4061e3:	00 00 00 
  4061e6:	0f 05                	syscall 
  4061e8:	eb 0f                	jmp    4061f9 <__cosrt_c_capmgr_initthd_create+0x99>
  4061ea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4061f0:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  4061f7:	eb 07                	jmp    406200 <__cosrt_c_capmgr_initthd_create+0xa0>
  4061f9:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  406200:	5d                   	pop    rbp
--
  406202:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  406206:	eb 91                	jmp    406199 <__cosrt_c_capmgr_initthd_create+0x39>
  406208:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40620f:	00 
--
  40622b:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  40622f:	4d 85 f6             	test   r14,r14
  406232:	74 34                	je     406268 <__cosrt_c_capmgr_thd_create_thunk+0x58>
  406234:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  406238:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
--
  406240:	31 f6                	xor    esi,esi
  406242:	4c 89 ff             	mov    rdi,r15
  406245:	41 ff d6             	call   r14
	*tid = tid_ret;
  406248:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
--
  406260:	c3                   	ret    
  406261:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  406268:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
--
  40628c:	49 b8 a0 62 40 00 00 	movabs r8,0x4062a0
  406293:	00 00 00 
  406296:	0f 05                	syscall 
  406298:	eb 0f                	jmp    4062a9 <__cosrt_c_capmgr_thd_create_thunk+0x99>
  40629a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4062a0:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  4062a7:	eb 07                	jmp    4062b0 <__cosrt_c_capmgr_thd_create_thunk+0xa0>
  4062a9:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  4062b0:	5d                   	pop    rbp
--
  4062b2:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  4062b6:	eb 90                	jmp    406248 <__cosrt_c_capmgr_thd_create_thunk+0x38>
  4062b8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4062bf:	00 
--
  4062df:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  4062e3:	4d 85 f6             	test   r14,r14
  4062e6:	74 30                	je     406318 <__cosrt_c_capmgr_thd_create_ext+0x58>
  4062e8:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  4062ec:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
--
  4062f2:	31 d2                	xor    edx,edx
  4062f4:	4c 89 ef             	mov    rdi,r13
  4062f7:	41 ff d6             	call   r14
	*tid = tid_ret;
  4062fa:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
--
  406311:	c3                   	ret    
  406312:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  406318:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
--
  406339:	49 b8 50 63 40 00 00 	movabs r8,0x406350
  406340:	00 00 00 
  406343:	0f 05                	syscall 
  406345:	0f 1f 00             	nop    DWORD PTR [rax]
  406348:	eb 0f                	jmp    406359 <__cosrt_c_capmgr_thd_create_ext+0x99>
  40634a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  406350:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  406357:	eb 07                	jmp    406360 <__cosrt_c_capmgr_thd_create_ext+0xa0>
  406359:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  406360:	5d                   	pop    rbp
--
  406362:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  406366:	eb 92                	jmp    4062fa <__cosrt_c_capmgr_thd_create_ext+0x3a>
  406368:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40636f:	00 
--
  4063bd:	45 09 d5             	or     r13d,r10d
  4063c0:	4d 85 ff             	test   r15,r15
  4063c3:	0f 84 7f 00 00 00    	je     406448 <__cosrt_c_capmgr_aep_create_thunk+0xd8>
  4063c9:	48 89 fa             	mov    rdx,rdi
  4063cc:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
--
  4063d4:	31 c9                	xor    ecx,ecx
  4063d6:	4c 89 ef             	mov    rdi,r13
  4063d9:	41 ff d7             	call   r15
  4063dc:	48 98                	cdqe   
	if (!thd) return 0;
  4063de:	48 85 c0             	test   rax,rax
  4063e1:	74 3a                	je     40641d <__cosrt_c_capmgr_aep_create_thunk+0xad>

	aep->thd  = thd;
--
  406440:	c3                   	ret    
  406441:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  406448:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
--
  406466:	49 b8 80 64 40 00 00 	movabs r8,0x406480
  40646d:	00 00 00 
  406470:	0f 05                	syscall 
  406472:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  406478:	eb 0f                	jmp    406489 <__cosrt_c_capmgr_aep_create_thunk+0x119>
  40647a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  406480:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  406487:	eb 07                	jmp    406490 <__cosrt_c_capmgr_aep_create_thunk+0x120>
  406489:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  406490:	5d                   	pop    rbp
--
  406496:	48 89 7d b0          	mov    QWORD PTR [rbp-0x50],rdi
	return ret;
  40649a:	e9 3d ff ff ff       	jmp    4063dc <__cosrt_c_capmgr_aep_create_thunk+0x6c>
  40649f:	90                   	nop

--
  4064ea:	48 63 f1             	movsxd rsi,ecx
  4064ed:	4d 85 d2             	test   r10,r10
  4064f0:	0f 84 8a 00 00 00    	je     406580 <__cosrt_c_capmgr_aep_create_ext+0xe0>
  4064f6:	48 89 d1             	mov    rcx,rdx
  4064f9:	4c 8d 4d b8          	lea    r9,[rbp-0x48]
--
  406501:	4c 89 f2             	mov    rdx,r14
  406504:	4c 89 ff             	mov    rdi,r15
  406507:	41 ff d2             	call   r10
  40650a:	48 98                	cdqe   
	if (!thd) return thd;
  40650c:	48 85 c0             	test   rax,rax
  40650f:	74 60                	je     406571 <__cosrt_c_capmgr_aep_create_ext+0xd1>

	aep->fn   = NULL;
--
  40657e:	5d                   	pop    rbp
  40657f:	c3                   	ret    
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  406580:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
--
  40659e:	49 b8 b8 65 40 00 00 	movabs r8,0x4065b8
  4065a5:	00 00 00 
  4065a8:	0f 05                	syscall 
  4065aa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4065b0:	eb 0f                	jmp    4065c1 <__cosrt_c_capmgr_aep_create_ext+0x121>
  4065b2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4065b8:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  4065bf:	eb 07                	jmp    4065c8 <__cosrt_c_capmgr_aep_create_ext+0x128>
  4065c1:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  4065c8:	5d                   	pop    rbp
--
  4065ce:	48 89 7d b8          	mov    QWORD PTR [rbp-0x48],rdi
	return ret;
  4065d2:	e9 33 ff ff ff       	jmp    40650a <__cosrt_c_capmgr_aep_create_ext+0x6a>
  4065d7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  4065de:	00 00 
--
  4065e4:	55                   	push   rbp

	/* FIXME: MPK call gate make indirect call complicated, arguments passed via stack gets wrong, walk around now by avoiding pass that argument */
	vpid = handler_thd_id & 0xFFFF;
	handler_thd_id = (handler_thd_id >> 16) & 0xFFFF;
--
  406643:	00 
  406644:	4d 85 f6             	test   r14,r14
  406647:	74 27                	je     406670 <__cosrt_c_capmgr_vm_vmcb_create+0x90>
  406649:	4c 8d 4d c8          	lea    r9,[rbp-0x38]
  40664d:	4c 8d 45 c0          	lea    r8,[rbp-0x40]
--
  406654:	31 c9                	xor    ecx,ecx
  406656:	31 d2                	xor    edx,edx
  406658:	41 ff d6             	call   r14
	cap = cos_sinv_2rets(uc, arg1, arg2, 0, 0, &ret1, &ret2);

--
  406669:	c3                   	ret    
  40666a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  406670:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
--
  406691:	49 b8 a8 66 40 00 00 	movabs r8,0x4066a8
  406698:	00 00 00 
  40669b:	0f 05                	syscall 
  40669d:	0f 1f 00             	nop    DWORD PTR [rax]
  4066a0:	eb 0f                	jmp    4066b1 <__cosrt_c_capmgr_vm_vmcb_create+0xd1>
  4066a2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4066a8:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  4066af:	eb 07                	jmp    4066b8 <__cosrt_c_capmgr_vm_vmcb_create+0xd8>
  4066b1:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  4066b8:	5d                   	pop    rbp
--
  406711:	00 
  406712:	4d 85 ff             	test   r15,r15
  406715:	0f 84 95 00 00 00    	je     4067b0 <__cosrt_c_capmgr_initaep_create+0xe0>
  40671b:	4c 8d 4d b8          	lea    r9,[rbp-0x48]
  40671f:	4c 8d 45 b0          	lea    r8,[rbp-0x50]
--
  406725:	48 89 da             	mov    rdx,rbx
  406728:	4c 89 f7             	mov    rdi,r14
  40672b:	41 ff d7             	call   r15
	thd = cos_sinv_2rets(uc, child_owntc, key_ipimax, ipiwin32b, 0, &sndtidret, &rcvtcret);
  40672e:	48 98                	cdqe   
	if (!thd) return thd;
  406730:	48 85 c0             	test   rax,rax
  406733:	74 64                	je     406799 <__cosrt_c_capmgr_initaep_create+0xc9>

	aep->fn   = NULL;
--
  4067a8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4067af:	00 
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  4067b0:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  4067b4:	49 89 da             	mov    r10,rbx
--
  4067d4:	49 b8 e8 67 40 00 00 	movabs r8,0x4067e8
  4067db:	00 00 00 
  4067de:	0f 05                	syscall 
  4067e0:	eb 0f                	jmp    4067f1 <__cosrt_c_capmgr_initaep_create+0x121>
  4067e2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4067e8:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  4067ef:	eb 07                	jmp    4067f8 <__cosrt_c_capmgr_initaep_create+0x128>
  4067f1:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  4067f8:	5d                   	pop    rbp
--
  4067fe:	48 89 7d b8          	mov    QWORD PTR [rbp-0x48],rdi
	return ret;
  406802:	e9 27 ff ff ff       	jmp    40672e <__cosrt_c_capmgr_initaep_create+0x5e>
  406807:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40680e:	00 00 
--
  406810:	48 b8 fc c0 45 00 00 	movabs rax,0x45c0fc
  406817:	00 00 00 
  40681a:	ff 10                	call   QWORD PTR [rax]
  40681c:	c3                   	ret    
  40681d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000406820 <__cosrt_fast_callgate_capmgr_initthd_create>:
  406820:	55                   	push   rbp
  406821:	53                   	push   rbx
--
  4068ea:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4068f1:	be ad de 
  4068f4:	49 39 c7             	cmp    r15,rax
  4068f7:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  4068fe:	12 12 12 
  406901:	48 b9 0d 69 40 00 00 	movabs rcx,0x40690d
  406908:	00 00 00 
  40690b:	ff e0                	jmp    rax

000000000040690d <srv_call_ret_capmgr_initthd_create>:
  40690d:	49 89 c0             	mov    r8,rax
  406910:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
--
  406996:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40699d:	be ad de 
  4069a0:	49 39 c7             	cmp    r15,rax
  4069a3:	4c 89 c0             	mov    rax,r8
  4069a6:	49 89 34 24          	mov    QWORD PTR [r12],rsi
--
  4069c0:	48 b8 14 c1 45 00 00 	movabs rax,0x45c114
  4069c7:	00 00 00 
  4069ca:	ff 10                	call   QWORD PTR [rax]
  4069cc:	c3                   	ret    
  4069cd:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004069d0 <__cosrt_fast_callgate_capmgr_thd_create_thunk>:
  4069d0:	55                   	push   rbp
  4069d1:	53                   	push   rbx
--
  406a9a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  406aa1:	be ad de 
  406aa4:	49 39 c7             	cmp    r15,rax
  406aa7:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  406aae:	12 12 12 
  406ab1:	48 b9 bd 6a 40 00 00 	movabs rcx,0x406abd
  406ab8:	00 00 00 
  406abb:	ff e0                	jmp    rax

0000000000406abd <srv_call_ret_capmgr_thd_create_thunk>:
  406abd:	49 89 c0             	mov    r8,rax
  406ac0:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
--
  406b46:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  406b4d:	be ad de 
  406b50:	49 39 c7             	cmp    r15,rax
  406b53:	4c 89 c0             	mov    rax,r8
  406b56:	49 89 34 24          	mov    QWORD PTR [r12],rsi
--
  406b70:	48 b8 2c c1 45 00 00 	movabs rax,0x45c12c
  406b77:	00 00 00 
  406b7a:	ff 10                	call   QWORD PTR [rax]
  406b7c:	c3                   	ret    
  406b7d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000406b80 <__cosrt_fast_callgate_capmgr_thd_create_ext>:
  406b80:	55                   	push   rbp
  406b81:	53                   	push   rbx
--
  406c4a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  406c51:	be ad de 
  406c54:	49 39 c7             	cmp    r15,rax
  406c57:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  406c5e:	12 12 12 
  406c61:	48 b9 6d 6c 40 00 00 	movabs rcx,0x406c6d
  406c68:	00 00 00 
  406c6b:	ff e0                	jmp    rax

0000000000406c6d <srv_call_ret_capmgr_thd_create_ext>:
  406c6d:	49 89 c0             	mov    r8,rax
  406c70:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
--
  406cf6:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  406cfd:	be ad de 
  406d00:	49 39 c7             	cmp    r15,rax
  406d03:	4c 89 c0             	mov    rax,r8
  406d06:	49 89 34 24          	mov    QWORD PTR [r12],rsi
--
  406d20:	48 b8 44 c1 45 00 00 	movabs rax,0x45c144
  406d27:	00 00 00 
  406d2a:	ff 10                	call   QWORD PTR [rax]
  406d2c:	c3                   	ret    
  406d2d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000406d30 <__cosrt_fast_callgate_capmgr_initaep_create>:
  406d30:	55                   	push   rbp
  406d31:	53                   	push   rbx
--
  406dfa:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  406e01:	be ad de 
  406e04:	49 39 c7             	cmp    r15,rax
  406e07:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  406e0e:	12 12 12 
  406e11:	48 b9 1d 6e 40 00 00 	movabs rcx,0x406e1d
  406e18:	00 00 00 
  406e1b:	ff e0                	jmp    rax

0000000000406e1d <srv_call_ret_capmgr_initaep_create>:
  406e1d:	49 89 c0             	mov    r8,rax
  406e20:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
--
  406ea6:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  406ead:	be ad de 
  406eb0:	49 39 c7             	cmp    r15,rax
  406eb3:	4c 89 c0             	mov    rax,r8
  406eb6:	49 89 34 24          	mov    QWORD PTR [r12],rsi
--
  406ed0:	48 b8 5c c1 45 00 00 	movabs rax,0x45c15c
  406ed7:	00 00 00 
  406eda:	ff 10                	call   QWORD PTR [rax]
  406edc:	c3                   	ret    
  406edd:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000406ee0 <__cosrt_fast_callgate_capmgr_aep_create_thunk>:
  406ee0:	55                   	push   rbp
  406ee1:	53                   	push   rbx
--
  406faa:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  406fb1:	be ad de 
  406fb4:	49 39 c7             	cmp    r15,rax
  406fb7:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  406fbe:	12 12 12 
  406fc1:	48 b9 cd 6f 40 00 00 	movabs rcx,0x406fcd
  406fc8:	00 00 00 
  406fcb:	ff e0                	jmp    rax

0000000000406fcd <srv_call_ret_capmgr_aep_create_thunk>:
  406fcd:	49 89 c0             	mov    r8,rax
  406fd0:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
--
  407056:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40705d:	be ad de 
  407060:	49 39 c7             	cmp    r15,rax
  407063:	4c 89 c0             	mov    rax,r8
  407066:	49 89 34 24          	mov    QWORD PTR [r12],rsi
--
  407080:	48 b8 74 c1 45 00 00 	movabs rax,0x45c174
  407087:	00 00 00 
  40708a:	ff 10                	call   QWORD PTR [rax]
  40708c:	c3                   	ret    
  40708d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000407090 <__cosrt_fast_callgate_capmgr_aep_create_ext>:
  407090:	55                   	push   rbp
  407091:	53                   	push   rbx
--
  40715a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407161:	be ad de 
  407164:	49 39 c7             	cmp    r15,rax
  407167:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  40716e:	12 12 12 
  407171:	48 b9 7d 71 40 00 00 	movabs rcx,0x40717d
  407178:	00 00 00 
  40717b:	ff e0                	jmp    rax

000000000040717d <srv_call_ret_capmgr_aep_create_ext>:
  40717d:	49 89 c0             	mov    r8,rax
  407180:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
--
  407206:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40720d:	be ad de 
  407210:	49 39 c7             	cmp    r15,rax
  407213:	4c 89 c0             	mov    rax,r8
  407216:	49 89 34 24          	mov    QWORD PTR [r12],rsi
--
  407230:	48 b8 8c c1 45 00 00 	movabs rax,0x45c18c
  407237:	00 00 00 
  40723a:	ff 10                	call   QWORD PTR [rax]
  40723c:	c3                   	ret    
  40723d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000407240 <__cosrt_fast_callgate_capmgr_rcv_create>:
  407240:	55                   	push   rbp
  407241:	53                   	push   rbx
--
  40730a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407311:	be ad de 
  407314:	49 39 c7             	cmp    r15,rax
  407317:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  40731e:	12 12 12 
  407321:	48 b9 2d 73 40 00 00 	movabs rcx,0x40732d
  407328:	00 00 00 
  40732b:	ff e0                	jmp    rax

000000000040732d <srv_call_ret_capmgr_rcv_create>:
  40732d:	49 89 c0             	mov    r8,rax
  407330:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
--
  4073b6:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4073bd:	be ad de 
  4073c0:	49 39 c7             	cmp    r15,rax
  4073c3:	4c 89 c0             	mov    rax,r8
  4073c6:	49 89 34 24          	mov    QWORD PTR [r12],rsi
--
  4073e0:	48 b8 a4 c1 45 00 00 	movabs rax,0x45c1a4
  4073e7:	00 00 00 
  4073ea:	ff 10                	call   QWORD PTR [rax]
  4073ec:	c3                   	ret    
  4073ed:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004073f0 <__cosrt_fast_callgate_capmgr_set_tls>:
  4073f0:	55                   	push   rbp
  4073f1:	41 55                	push   r13
--
  4074b1:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4074b8:	be ad de 
  4074bb:	49 39 c7             	cmp    r15,rax
  4074be:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  4074c5:	12 12 12 
  4074c8:	48 b9 d4 74 40 00 00 	movabs rcx,0x4074d4
  4074cf:	00 00 00 
  4074d2:	ff e0                	jmp    rax

00000000004074d4 <srv_call_ret_capmgr_set_tls>:
  4074d4:	49 89 c0             	mov    r8,rax
  4074d7:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
--
  40755d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407564:	be ad de 
  407567:	49 39 c7             	cmp    r15,rax
  40756a:	4c 89 c0             	mov    rax,r8
  40756d:	41 5f                	pop    r15
--
  407580:	48 b8 bc c1 45 00 00 	movabs rax,0x45c1bc
  407587:	00 00 00 
  40758a:	ff 10                	call   QWORD PTR [rax]
  40758c:	c3                   	ret    
  40758d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000407590 <__cosrt_fast_callgate_capmgr_asnd_create>:
  407590:	55                   	push   rbp
  407591:	41 55                	push   r13
--
  407651:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407658:	be ad de 
  40765b:	49 39 c7             	cmp    r15,rax
  40765e:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  407665:	12 12 12 
  407668:	48 b9 74 76 40 00 00 	movabs rcx,0x407674
  40766f:	00 00 00 
  407672:	ff e0                	jmp    rax

0000000000407674 <srv_call_ret_capmgr_asnd_create>:
  407674:	49 89 c0             	mov    r8,rax
  407677:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
--
  4076fd:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407704:	be ad de 
  407707:	49 39 c7             	cmp    r15,rax
  40770a:	4c 89 c0             	mov    rax,r8
  40770d:	41 5f                	pop    r15
--
  407720:	48 b8 d4 c1 45 00 00 	movabs rax,0x45c1d4
  407727:	00 00 00 
  40772a:	ff 10                	call   QWORD PTR [rax]
  40772c:	c3                   	ret    
  40772d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000407730 <__cosrt_fast_callgate_capmgr_asnd_rcv_create>:
  407730:	55                   	push   rbp
  407731:	41 55                	push   r13
--
  4077f1:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4077f8:	be ad de 
  4077fb:	49 39 c7             	cmp    r15,rax
  4077fe:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  407805:	12 12 12 
  407808:	48 b9 14 78 40 00 00 	movabs rcx,0x407814
  40780f:	00 00 00 
  407812:	ff e0                	jmp    rax

0000000000407814 <srv_call_ret_capmgr_asnd_rcv_create>:
  407814:	49 89 c0             	mov    r8,rax
  407817:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
--
  40789d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4078a4:	be ad de 
  4078a7:	49 39 c7             	cmp    r15,rax
  4078aa:	4c 89 c0             	mov    rax,r8
  4078ad:	41 5f                	pop    r15
--
  4078c0:	48 b8 ec c1 45 00 00 	movabs rax,0x45c1ec
  4078c7:	00 00 00 
  4078ca:	ff 10                	call   QWORD PTR [rax]
  4078cc:	c3                   	ret    
  4078cd:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004078d0 <__cosrt_fast_callgate_capmgr_asnd_key_create>:
  4078d0:	55                   	push   rbp
  4078d1:	41 55                	push   r13
--
  407991:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407998:	be ad de 
  40799b:	49 39 c7             	cmp    r15,rax
  40799e:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  4079a5:	12 12 12 
  4079a8:	48 b9 b4 79 40 00 00 	movabs rcx,0x4079b4
  4079af:	00 00 00 
  4079b2:	ff e0                	jmp    rax

00000000004079b4 <srv_call_ret_capmgr_asnd_key_create>:
  4079b4:	49 89 c0             	mov    r8,rax
  4079b7:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
--
  407a3d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407a44:	be ad de 
  407a47:	49 39 c7             	cmp    r15,rax
  407a4a:	4c 89 c0             	mov    rax,r8
  407a4d:	41 5f                	pop    r15
--
  407a60:	48 b8 04 c2 45 00 00 	movabs rax,0x45c204
  407a67:	00 00 00 
  407a6a:	ff 10                	call   QWORD PTR [rax]
  407a6c:	c3                   	ret    
  407a6d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000407a70 <__cosrt_fast_callgate_capmgr_vm_comp_create>:
  407a70:	55                   	push   rbp
  407a71:	41 55                	push   r13
--
  407b31:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407b38:	be ad de 
  407b3b:	49 39 c7             	cmp    r15,rax
  407b3e:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  407b45:	12 12 12 
  407b48:	48 b9 54 7b 40 00 00 	movabs rcx,0x407b54
  407b4f:	00 00 00 
  407b52:	ff e0                	jmp    rax

0000000000407b54 <srv_call_ret_capmgr_vm_comp_create>:
  407b54:	49 89 c0             	mov    r8,rax
  407b57:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
--
  407bdd:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407be4:	be ad de 
  407be7:	49 39 c7             	cmp    r15,rax
  407bea:	4c 89 c0             	mov    rax,r8
  407bed:	41 5f                	pop    r15
--
  407c00:	48 b8 1c c2 45 00 00 	movabs rax,0x45c21c
  407c07:	00 00 00 
  407c0a:	ff 10                	call   QWORD PTR [rax]
  407c0c:	c3                   	ret    
  407c0d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000407c10 <__cosrt_fast_callgate_capmgr_vm_shared_kernel_page_create_at>:
  407c10:	55                   	push   rbp
  407c11:	41 55                	push   r13
--
  407cd1:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407cd8:	be ad de 
  407cdb:	49 39 c7             	cmp    r15,rax
  407cde:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  407ce5:	12 12 12 
  407ce8:	48 b9 f4 7c 40 00 00 	movabs rcx,0x407cf4
  407cef:	00 00 00 
  407cf2:	ff e0                	jmp    rax

0000000000407cf4 <srv_call_ret_capmgr_vm_shared_kernel_page_create_at>:
  407cf4:	49 89 c0             	mov    r8,rax
  407cf7:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
--
  407d7d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407d84:	be ad de 
  407d87:	49 39 c7             	cmp    r15,rax
  407d8a:	4c 89 c0             	mov    rax,r8
  407d8d:	41 5f                	pop    r15
--
  407da0:	48 b8 34 c2 45 00 00 	movabs rax,0x45c234
  407da7:	00 00 00 
  407daa:	ff 10                	call   QWORD PTR [rax]
  407dac:	c3                   	ret    
  407dad:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000407db0 <__cosrt_fast_callgate_capmgr_vm_vmcs_create>:
  407db0:	55                   	push   rbp
  407db1:	41 55                	push   r13
--
  407e71:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407e78:	be ad de 
  407e7b:	49 39 c7             	cmp    r15,rax
  407e7e:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  407e85:	12 12 12 
  407e88:	48 b9 94 7e 40 00 00 	movabs rcx,0x407e94
  407e8f:	00 00 00 
  407e92:	ff e0                	jmp    rax

0000000000407e94 <srv_call_ret_capmgr_vm_vmcs_create>:
  407e94:	49 89 c0             	mov    r8,rax
  407e97:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
--
  407f1d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407f24:	be ad de 
  407f27:	49 39 c7             	cmp    r15,rax
  407f2a:	4c 89 c0             	mov    rax,r8
  407f2d:	41 5f                	pop    r15
--
  407f40:	48 b8 4c c2 45 00 00 	movabs rax,0x45c24c
  407f47:	00 00 00 
  407f4a:	ff 10                	call   QWORD PTR [rax]
  407f4c:	c3                   	ret    
  407f4d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000407f50 <__cosrt_fast_callgate_capmgr_vm_msr_bitmap_create>:
  407f50:	55                   	push   rbp
  407f51:	41 55                	push   r13
--
  408011:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408018:	be ad de 
  40801b:	49 39 c7             	cmp    r15,rax
  40801e:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  408025:	12 12 12 
  408028:	48 b9 34 80 40 00 00 	movabs rcx,0x408034
  40802f:	00 00 00 
  408032:	ff e0                	jmp    rax

0000000000408034 <srv_call_ret_capmgr_vm_msr_bitmap_create>:
  408034:	49 89 c0             	mov    r8,rax
  408037:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
--
  4080bd:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4080c4:	be ad de 
  4080c7:	49 39 c7             	cmp    r15,rax
  4080ca:	4c 89 c0             	mov    rax,r8
  4080cd:	41 5f                	pop    r15
--
  4080e0:	48 b8 64 c2 45 00 00 	movabs rax,0x45c264
  4080e7:	00 00 00 
  4080ea:	ff 10                	call   QWORD PTR [rax]
  4080ec:	c3                   	ret    
  4080ed:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004080f0 <__cosrt_fast_callgate_capmgr_vm_lapic_access_create>:
  4080f0:	55                   	push   rbp
  4080f1:	41 55                	push   r13
--
  4081b1:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4081b8:	be ad de 
  4081bb:	49 39 c7             	cmp    r15,rax
  4081be:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  4081c5:	12 12 12 
  4081c8:	48 b9 d4 81 40 00 00 	movabs rcx,0x4081d4
  4081cf:	00 00 00 
  4081d2:	ff e0                	jmp    rax

00000000004081d4 <srv_call_ret_capmgr_vm_lapic_access_create>:
  4081d4:	49 89 c0             	mov    r8,rax
  4081d7:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
--
  40825d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408264:	be ad de 
  408267:	49 39 c7             	cmp    r15,rax
  40826a:	4c 89 c0             	mov    rax,r8
  40826d:	41 5f                	pop    r15
--
  408280:	48 b8 7c c2 45 00 00 	movabs rax,0x45c27c
  408287:	00 00 00 
  40828a:	ff 10                	call   QWORD PTR [rax]
  40828c:	c3                   	ret    
  40828d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000408290 <__cosrt_fast_callgate_capmgr_shared_kernel_page_create>:
  408290:	55                   	push   rbp
  408291:	53                   	push   rbx
--
  40835a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408361:	be ad de 
  408364:	49 39 c7             	cmp    r15,rax
  408367:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  40836e:	12 12 12 
  408371:	48 b9 7d 83 40 00 00 	movabs rcx,0x40837d
  408378:	00 00 00 
  40837b:	ff e0                	jmp    rax

000000000040837d <srv_call_ret_capmgr_shared_kernel_page_create>:
  40837d:	49 89 c0             	mov    r8,rax
  408380:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
--
  408406:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40840d:	be ad de 
  408410:	49 39 c7             	cmp    r15,rax
  408413:	4c 89 c0             	mov    rax,r8
  408416:	49 89 34 24          	mov    QWORD PTR [r12],rsi
--
  408430:	48 b8 94 c2 45 00 00 	movabs rax,0x45c294
  408437:	00 00 00 
  40843a:	ff 10                	call   QWORD PTR [rax]
  40843c:	c3                   	ret    
  40843d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000408440 <__cosrt_fast_callgate_capmgr_vm_lapic_create>:
  408440:	55                   	push   rbp
  408441:	53                   	push   rbx
--
  40850a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408511:	be ad de 
  408514:	49 39 c7             	cmp    r15,rax
  408517:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  40851e:	12 12 12 
  408521:	48 b9 2d 85 40 00 00 	movabs rcx,0x40852d
  408528:	00 00 00 
  40852b:	ff e0                	jmp    rax

000000000040852d <srv_call_ret_capmgr_vm_lapic_create>:
  40852d:	49 89 c0             	mov    r8,rax
  408530:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
--
  4085b6:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4085bd:	be ad de 
  4085c0:	49 39 c7             	cmp    r15,rax
  4085c3:	4c 89 c0             	mov    rax,r8
  4085c6:	49 89 34 24          	mov    QWORD PTR [r12],rsi
--
  4085e0:	48 b8 ac c2 45 00 00 	movabs rax,0x45c2ac
  4085e7:	00 00 00 
  4085ea:	ff 10                	call   QWORD PTR [rax]
  4085ec:	c3                   	ret    
  4085ed:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004085f0 <__cosrt_fast_callgate_capmgr_vm_shared_region_create>:
  4085f0:	55                   	push   rbp
  4085f1:	53                   	push   rbx
--
  4086ba:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4086c1:	be ad de 
  4086c4:	49 39 c7             	cmp    r15,rax
  4086c7:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  4086ce:	12 12 12 
  4086d1:	48 b9 dd 86 40 00 00 	movabs rcx,0x4086dd
  4086d8:	00 00 00 
  4086db:	ff e0                	jmp    rax

00000000004086dd <srv_call_ret_capmgr_vm_shared_region_create>:
  4086dd:	49 89 c0             	mov    r8,rax
  4086e0:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
--
  408766:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40876d:	be ad de 
  408770:	49 39 c7             	cmp    r15,rax
  408773:	4c 89 c0             	mov    rax,r8
  408776:	49 89 34 24          	mov    QWORD PTR [r12],rsi
--
  408790:	48 b8 c4 c2 45 00 00 	movabs rax,0x45c2c4
  408797:	00 00 00 
  40879a:	ff 10                	call   QWORD PTR [rax]
  40879c:	c3                   	ret    
  40879d:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004087a0 <__cosrt_fast_callgate_capmgr_vm_vmcb_create>:
  4087a0:	55                   	push   rbp
  4087a1:	53                   	push   rbx
--
  40886a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408871:	be ad de 
  408874:	49 39 c7             	cmp    r15,rax
  408877:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  40887e:	12 12 12 
  408881:	48 b9 8d 88 40 00 00 	movabs rcx,0x40888d
  408888:	00 00 00 
  40888b:	ff e0                	jmp    rax

000000000040888d <srv_call_ret_capmgr_vm_vmcb_create>:
  40888d:	49 89 c0             	mov    r8,rax
  408890:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
--
  408916:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40891d:	be ad de 
  408920:	49 39 c7             	cmp    r15,rax
  408923:	4c 89 c0             	mov    rax,r8
  408926:	49 89 34 24          	mov    QWORD PTR [r12],rsi
--
  408940:	48 b8 dc c2 45 00 00 	movabs rax,0x45c2dc
  408947:	00 00 00 
  40894a:	ff 10                	call   QWORD PTR [rax]
  40894c:	c3                   	ret    
  40894d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000408950 <__cosrt_fast_callgate_capmgr_vm_vcpu_create>:
  408950:	55                   	push   rbp
  408951:	53                   	push   rbx
--
  408a1a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408a21:	be ad de 
  408a24:	49 39 c7             	cmp    r15,rax
  408a27:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  408a2e:	12 12 12 
  408a31:	48 b9 3d 8a 40 00 00 	movabs rcx,0x408a3d
  408a38:	00 00 00 
  408a3b:	ff e0                	jmp    rax

0000000000408a3d <srv_call_ret_capmgr_vm_vcpu_create>:
  408a3d:	49 89 c0             	mov    r8,rax
  408a40:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
--
  408ac6:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408acd:	be ad de 
  408ad0:	49 39 c7             	cmp    r15,rax
  408ad3:	4c 89 c0             	mov    rax,r8
  408ad6:	49 89 34 24          	mov    QWORD PTR [r12],rsi
--
  408b08:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  408b0c:	4d 85 f6             	test   r14,r14
  408b0f:	74 2f                	je     408b40 <__cosrt_c_memmgr_shared_page_allocn+0x50>
  408b11:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  408b15:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
--
  408b1b:	31 d2                	xor    edx,edx
  408b1d:	31 f6                	xor    esi,esi
  408b1f:	41 ff d6             	call   r14
	COS_CLIENT_INVCAP;
	word_t unused, addrret;
--
  408b38:	c3                   	ret    
  408b39:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  408b40:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
--
  408b64:	49 b8 78 8b 40 00 00 	movabs r8,0x408b78
  408b6b:	00 00 00 
  408b6e:	0f 05                	syscall 
  408b70:	eb 0f                	jmp    408b81 <__cosrt_c_memmgr_shared_page_allocn+0x91>
  408b72:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  408b78:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  408b7f:	eb 07                	jmp    408b88 <__cosrt_c_memmgr_shared_page_allocn+0x98>
  408b81:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  408b88:	5d                   	pop    rbp
--
  408b8a:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  408b8e:	eb 92                	jmp    408b22 <__cosrt_c_memmgr_shared_page_allocn+0x32>

0000000000408b90 <__cosrt_c_memmgr_shared_page_map>:
--
  408bab:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  408baf:	4d 85 f6             	test   r14,r14
  408bb2:	74 34                	je     408be8 <__cosrt_c_memmgr_shared_page_map+0x58>
  408bb4:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  408bb8:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
--
  408bc0:	31 f6                	xor    esi,esi
  408bc2:	4c 89 ff             	mov    rdi,r15
  408bc5:	41 ff d6             	call   r14
	*pgaddr = addrret;
  408bc8:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
--
  408be0:	c3                   	ret    
  408be1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  408be8:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
--
  408c0c:	49 b8 20 8c 40 00 00 	movabs r8,0x408c20
  408c13:	00 00 00 
  408c16:	0f 05                	syscall 
  408c18:	eb 0f                	jmp    408c29 <__cosrt_c_memmgr_shared_page_map+0x99>
  408c1a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  408c20:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  408c27:	eb 07                	jmp    408c30 <__cosrt_c_memmgr_shared_page_map+0xa0>
  408c29:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  408c30:	5d                   	pop    rbp
--
  408c32:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  408c36:	eb 90                	jmp    408bc8 <__cosrt_c_memmgr_shared_page_map+0x38>
  408c38:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  408c3f:	00 
--
  408c58:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  408c5c:	4d 85 f6             	test   r14,r14
  408c5f:	74 2f                	je     408c90 <__cosrt_c_memmgr_shared_page_allocn_aligned+0x50>
  408c61:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  408c65:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  408c69:	31 c9                	xor    ecx,ecx
  408c6b:	31 d2                	xor    edx,edx
  408c6d:	41 ff d6             	call   r14
	COS_CLIENT_INVCAP;
	word_t unused, addrret;
--
  408c86:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  408c8d:	00 00 00 
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  408c90:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
--
  408cb1:	49 b8 c8 8c 40 00 00 	movabs r8,0x408cc8
  408cb8:	00 00 00 
  408cbb:	0f 05                	syscall 
  408cbd:	0f 1f 00             	nop    DWORD PTR [rax]
  408cc0:	eb 0f                	jmp    408cd1 <__cosrt_c_memmgr_shared_page_allocn_aligned+0x91>
  408cc2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  408cc8:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  408ccf:	eb 07                	jmp    408cd8 <__cosrt_c_memmgr_shared_page_allocn_aligned+0x98>
  408cd1:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  408cd8:	5d                   	pop    rbp
--
  408cda:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  408cde:	eb 90                	jmp    408c70 <__cosrt_c_memmgr_shared_page_allocn_aligned+0x30>

0000000000408ce0 <__cosrt_c_memmgr_shared_page_map_aligned>:
--
  408cfb:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  408cff:	4d 85 f6             	test   r14,r14
  408d02:	74 2c                	je     408d30 <__cosrt_c_memmgr_shared_page_map_aligned+0x50>
  408d04:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  408d08:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
--
  408d0e:	31 d2                	xor    edx,edx
  408d10:	4c 89 ef             	mov    rdi,r13
  408d13:	41 ff d6             	call   r14
	*pgaddr = addrret;
  408d16:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
--
  408d2d:	c3                   	ret    
  408d2e:	66 90                	xchg   ax,ax
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  408d30:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
--
  408d51:	49 b8 68 8d 40 00 00 	movabs r8,0x408d68
  408d58:	00 00 00 
  408d5b:	0f 05                	syscall 
  408d5d:	0f 1f 00             	nop    DWORD PTR [rax]
  408d60:	eb 0f                	jmp    408d71 <__cosrt_c_memmgr_shared_page_map_aligned+0x91>
  408d62:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  408d68:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  408d6f:	eb 07                	jmp    408d78 <__cosrt_c_memmgr_shared_page_map_aligned+0x98>
  408d71:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  408d78:	5d                   	pop    rbp
--
  408d7a:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  408d7e:	eb 96                	jmp    408d16 <__cosrt_c_memmgr_shared_page_map_aligned+0x36>

0000000000408d80 <__cosrt_c_memmgr_shared_page_map_aligned_in_vm>:
--
  408d9f:	48 89 55 a8          	mov    QWORD PTR [rbp-0x58],rdx
  408da3:	4d 85 f6             	test   r14,r14
  408da6:	74 38                	je     408de0 <__cosrt_c_memmgr_shared_page_map_aligned_in_vm+0x60>
  408da8:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  408dac:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
--
  408db2:	4c 89 ea             	mov    rdx,r13
  408db5:	4c 89 ff             	mov    rdi,r15
  408db8:	41 ff d6             	call   r14
	*pgaddr = addrret;
  408dbb:	48 8b 5d a8          	mov    rbx,QWORD PTR [rbp-0x58]
--
  408dd7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  408dde:	00 00 
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  408de0:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
--
  408e01:	49 b8 18 8e 40 00 00 	movabs r8,0x408e18
  408e08:	00 00 00 
  408e0b:	0f 05                	syscall 
  408e0d:	0f 1f 00             	nop    DWORD PTR [rax]
  408e10:	eb 0f                	jmp    408e21 <__cosrt_c_memmgr_shared_page_map_aligned_in_vm+0xa1>
  408e12:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  408e18:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  408e1f:	eb 07                	jmp    408e28 <__cosrt_c_memmgr_shared_page_map_aligned_in_vm+0xa8>
  408e21:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  408e28:	5d                   	pop    rbp
--
  408e2a:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  408e2e:	eb 8b                	jmp    408dbb <__cosrt_c_memmgr_shared_page_map_aligned_in_vm+0x3b>

0000000000408e30 <__cosrt_extern_memmgr_heap_page_allocn>:
  408e30:	48 b8 f4 c2 45 00 00 	movabs rax,0x45c2f4
  408e37:	00 00 00 
  408e3a:	ff 10                	call   QWORD PTR [rax]
  408e3c:	c3                   	ret    
  408e3d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000408e40 <__cosrt_fast_callgate_memmgr_heap_page_allocn>:
  408e40:	55                   	push   rbp
  408e41:	41 55                	push   r13
--
  408f01:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408f08:	be ad de 
  408f0b:	49 39 c7             	cmp    r15,rax
  408f0e:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  408f15:	12 12 12 
  408f18:	48 b9 24 8f 40 00 00 	movabs rcx,0x408f24
  408f1f:	00 00 00 
  408f22:	ff e0                	jmp    rax

0000000000408f24 <srv_call_ret_memmgr_heap_page_allocn>:
  408f24:	49 89 c0             	mov    r8,rax
  408f27:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
--
  408fad:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408fb4:	be ad de 
  408fb7:	49 39 c7             	cmp    r15,rax
  408fba:	4c 89 c0             	mov    rax,r8
  408fbd:	41 5f                	pop    r15
--
  408fd0:	48 b8 0c c3 45 00 00 	movabs rax,0x45c30c
  408fd7:	00 00 00 
  408fda:	ff 10                	call   QWORD PTR [rax]
  408fdc:	c3                   	ret    
  408fdd:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000408fe0 <__cosrt_fast_callgate_memmgr_heap_page_allocn_aligned>:
  408fe0:	55                   	push   rbp
  408fe1:	41 55                	push   r13
--
  4090a1:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4090a8:	be ad de 
  4090ab:	49 39 c7             	cmp    r15,rax
  4090ae:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  4090b5:	12 12 12 
  4090b8:	48 b9 c4 90 40 00 00 	movabs rcx,0x4090c4
  4090bf:	00 00 00 
  4090c2:	ff e0                	jmp    rax

00000000004090c4 <srv_call_ret_memmgr_heap_page_allocn_aligned>:
  4090c4:	49 89 c0             	mov    r8,rax
  4090c7:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
--
  40914d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409154:	be ad de 
  409157:	49 39 c7             	cmp    r15,rax
  40915a:	4c 89 c0             	mov    rax,r8
  40915d:	41 5f                	pop    r15
--
  409170:	48 b8 24 c3 45 00 00 	movabs rax,0x45c324
  409177:	00 00 00 
  40917a:	ff 10                	call   QWORD PTR [rax]
  40917c:	c3                   	ret    
  40917d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000409180 <__cosrt_fast_callgate_memmgr_virt_to_phys>:
  409180:	55                   	push   rbp
  409181:	41 55                	push   r13
--
  409241:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409248:	be ad de 
  40924b:	49 39 c7             	cmp    r15,rax
  40924e:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  409255:	12 12 12 
  409258:	48 b9 64 92 40 00 00 	movabs rcx,0x409264
  40925f:	00 00 00 
  409262:	ff e0                	jmp    rax

0000000000409264 <srv_call_ret_memmgr_virt_to_phys>:
  409264:	49 89 c0             	mov    r8,rax
  409267:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
--
  4092ed:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4092f4:	be ad de 
  4092f7:	49 39 c7             	cmp    r15,rax
  4092fa:	4c 89 c0             	mov    rax,r8
  4092fd:	41 5f                	pop    r15
--
  409310:	48 b8 3c c3 45 00 00 	movabs rax,0x45c33c
  409317:	00 00 00 
  40931a:	ff 10                	call   QWORD PTR [rax]
  40931c:	c3                   	ret    
  40931d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000409320 <__cosrt_fast_callgate_memmgr_map_phys_to_virt>:
  409320:	55                   	push   rbp
  409321:	41 55                	push   r13
--
  4093e1:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4093e8:	be ad de 
  4093eb:	49 39 c7             	cmp    r15,rax
  4093ee:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  4093f5:	12 12 12 
  4093f8:	48 b9 04 94 40 00 00 	movabs rcx,0x409404
  4093ff:	00 00 00 
  409402:	ff e0                	jmp    rax

0000000000409404 <srv_call_ret_memmgr_map_phys_to_virt>:
  409404:	49 89 c0             	mov    r8,rax
  409407:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
--
  40948d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409494:	be ad de 
  409497:	49 39 c7             	cmp    r15,rax
  40949a:	4c 89 c0             	mov    rax,r8
  40949d:	41 5f                	pop    r15
--
  4094b0:	48 b8 54 c3 45 00 00 	movabs rax,0x45c354
  4094b7:	00 00 00 
  4094ba:	ff 10                	call   QWORD PTR [rax]
  4094bc:	c3                   	ret    
  4094bd:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004094c0 <__cosrt_fast_callgate_memmgr_shared_page_allocn>:
  4094c0:	55                   	push   rbp
  4094c1:	53                   	push   rbx
--
  40958a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409591:	be ad de 
  409594:	49 39 c7             	cmp    r15,rax
  409597:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  40959e:	12 12 12 
  4095a1:	48 b9 ad 95 40 00 00 	movabs rcx,0x4095ad
  4095a8:	00 00 00 
  4095ab:	ff e0                	jmp    rax

00000000004095ad <srv_call_ret_memmgr_shared_page_allocn>:
  4095ad:	49 89 c0             	mov    r8,rax
  4095b0:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
--
  409636:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40963d:	be ad de 
  409640:	49 39 c7             	cmp    r15,rax
  409643:	4c 89 c0             	mov    rax,r8
  409646:	49 89 34 24          	mov    QWORD PTR [r12],rsi
--
  409660:	48 b8 6c c3 45 00 00 	movabs rax,0x45c36c
  409667:	00 00 00 
  40966a:	ff 10                	call   QWORD PTR [rax]
  40966c:	c3                   	ret    
  40966d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000409670 <__cosrt_fast_callgate_memmgr_shared_page_allocn_aligned>:
  409670:	55                   	push   rbp
  409671:	53                   	push   rbx
--
  40973a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409741:	be ad de 
  409744:	49 39 c7             	cmp    r15,rax
  409747:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  40974e:	12 12 12 
  409751:	48 b9 5d 97 40 00 00 	movabs rcx,0x40975d
  409758:	00 00 00 
  40975b:	ff e0                	jmp    rax

000000000040975d <srv_call_ret_memmgr_shared_page_allocn_aligned>:
  40975d:	49 89 c0             	mov    r8,rax
  409760:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
--
  4097e6:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4097ed:	be ad de 
  4097f0:	49 39 c7             	cmp    r15,rax
  4097f3:	4c 89 c0             	mov    rax,r8
  4097f6:	49 89 34 24          	mov    QWORD PTR [r12],rsi
--
  409810:	48 b8 84 c3 45 00 00 	movabs rax,0x45c384
  409817:	00 00 00 
  40981a:	ff 10                	call   QWORD PTR [rax]
  40981c:	c3                   	ret    
  40981d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000409820 <__cosrt_fast_callgate_memmgr_shared_page_map>:
  409820:	55                   	push   rbp
  409821:	53                   	push   rbx
--
  4098ea:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4098f1:	be ad de 
  4098f4:	49 39 c7             	cmp    r15,rax
  4098f7:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  4098fe:	12 12 12 
  409901:	48 b9 0d 99 40 00 00 	movabs rcx,0x40990d
  409908:	00 00 00 
  40990b:	ff e0                	jmp    rax

000000000040990d <srv_call_ret_memmgr_shared_page_map>:
  40990d:	49 89 c0             	mov    r8,rax
  409910:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
--
  409996:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40999d:	be ad de 
  4099a0:	49 39 c7             	cmp    r15,rax
  4099a3:	4c 89 c0             	mov    rax,r8
  4099a6:	49 89 34 24          	mov    QWORD PTR [r12],rsi
--
  4099c0:	48 b8 9c c3 45 00 00 	movabs rax,0x45c39c
  4099c7:	00 00 00 
  4099ca:	ff 10                	call   QWORD PTR [rax]
  4099cc:	c3                   	ret    
  4099cd:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004099d0 <__cosrt_fast_callgate_memmgr_shared_page_map_aligned>:
  4099d0:	55                   	push   rbp
  4099d1:	53                   	push   rbx
--
  409a9a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409aa1:	be ad de 
  409aa4:	49 39 c7             	cmp    r15,rax
  409aa7:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  409aae:	12 12 12 
  409ab1:	48 b9 bd 9a 40 00 00 	movabs rcx,0x409abd
  409ab8:	00 00 00 
  409abb:	ff e0                	jmp    rax

0000000000409abd <srv_call_ret_memmgr_shared_page_map_aligned>:
  409abd:	49 89 c0             	mov    r8,rax
  409ac0:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
--
  409b46:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409b4d:	be ad de 
  409b50:	49 39 c7             	cmp    r15,rax
  409b53:	4c 89 c0             	mov    rax,r8
  409b56:	49 89 34 24          	mov    QWORD PTR [r12],rsi
--
  409b70:	48 b8 b4 c3 45 00 00 	movabs rax,0x45c3b4
  409b77:	00 00 00 
  409b7a:	ff 10                	call   QWORD PTR [rax]
  409b7c:	c3                   	ret    
  409b7d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000409b80 <__cosrt_fast_callgate_memmgr_shared_page_map_aligned_in_vm>:
  409b80:	55                   	push   rbp
  409b81:	53                   	push   rbx
--
  409c4a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409c51:	be ad de 
  409c54:	49 39 c7             	cmp    r15,rax
  409c57:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  409c5e:	12 12 12 
  409c61:	48 b9 6d 9c 40 00 00 	movabs rcx,0x409c6d
  409c68:	00 00 00 
  409c6b:	ff e0                	jmp    rax

0000000000409c6d <srv_call_ret_memmgr_shared_page_map_aligned_in_vm>:
  409c6d:	49 89 c0             	mov    r8,rax
  409c70:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
--
  409cf6:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409cfd:	be ad de 
  409d00:	49 39 c7             	cmp    r15,rax
  409d03:	4c 89 c0             	mov    rax,r8
  409d06:	49 89 34 24          	mov    QWORD PTR [r12],rsi
--
  409d40:	48 89 e5             	mov    rbp,rsp
	(aep_fn)(aep_info->rcv, fn_data);
  409d43:	ff 50 20             	call   QWORD PTR [rax+0x20]
  409d46:	be 69 00 00 00       	mov    esi,0x69
  409d4b:	bf f0 cf 41 00       	mov    edi,0x41cff0
  409d50:	e8 7b 03 00 00       	call   40a0d0 <cos_print_str>

	/* TODO: handling destruction */
--
	if (!fn) return -1;
  409d74:	48 85 ff             	test   rdi,rdi
  409d77:	0f 84 95 00 00 00    	je     409e12 <capmgr_thd_create+0xa2>
  409d7d:	49 89 f1             	mov    r9,rsi
  409d80:	49 89 f8             	mov    r8,rdi
--
	char z;
	#if defined(__x86_64__)
	__asm__ __volatile__("lock cmpxchgq %2, %0; setz %1"
  409d8c:	31 d2                	xor    edx,edx
	for (i = 0; i < COS_THD_INIT_REGION_SIZE; i++) {
--
  409d93:	31 ff                	xor    edi,edi
		if (__thd_init_data[i].fn == NULL) {
  409d95:	48 83 39 00          	cmp    QWORD PTR [rcx],0x0
  409d99:	74 25                	je     409dc0 <capmgr_thd_create+0x50>
	for (i = 0; i < COS_THD_INIT_REGION_SIZE; i++) {
  409d9b:	83 c7 01             	add    edi,0x1
  409d9e:	48 83 c1 10          	add    rcx,0x10
  409da2:	81 ff 00 01 00 00    	cmp    edi,0x100
  409da8:	75 eb                	jne    409d95 <capmgr_thd_create+0x25>
	if (!tried) {
  409daa:	41 83 fa 01          	cmp    r10d,0x1
  409dae:	74 62                	je     409e12 <capmgr_thd_create+0xa2>
  409db0:	41 ba 01 00 00 00    	mov    r10d,0x1
  409db6:	eb d6                	jmp    409d8e <capmgr_thd_create+0x1e>
  409db8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  409dbf:	00 
  409dc0:	48 89 d0             	mov    rax,rdx
  409dc3:	f0 4c 0f b1 01       	lock cmpxchg QWORD PTR [rcx],r8
  409dc8:	0f 94 c0             	sete   al
			if (!ret) continue;
  409dcb:	84 c0                	test   al,al
  409dcd:	74 cc                	je     409d9b <capmgr_thd_create+0x2b>
			assert(__thd_init_data[i].fn == fn);
  409dcf:	48 63 c7             	movsxd rax,edi
  409dd2:	48 c1 e0 04          	shl    rax,0x4
  409dd6:	48 8d 90 40 f9 59 00 	lea    rdx,[rax+0x59f940]
  409ddd:	4c 3b 80 40 f9 59 00 	cmp    r8,QWORD PTR [rax+0x59f940]
  409de4:	75 0c                	jne    409df2 <capmgr_thd_create+0x82>
			__thd_init_data[i].data = data;
  409de6:	4c 89 4a 08          	mov    QWORD PTR [rdx+0x8],r9
--

	return capmgr_thd_create_thunk(idx, tid);
  409ded:	e9 ce cb ff ff       	jmp    4069c0 <__cosrt_extern_capmgr_thd_create_thunk>
{
  409df2:	55                   	push   rbp
--
  409df8:	bf 60 d0 41 00       	mov    edi,0x41d060
  409dfd:	48 89 e5             	mov    rbp,rsp
  409e00:	e8 cb 02 00 00       	call   40a0d0 <cos_print_str>
			assert(__thd_init_data[i].fn == fn);
  409e05:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	if (!fn) return -1;
  409e24:	48 85 ff             	test   rdi,rdi
  409e27:	0f 84 af 00 00 00    	je     409edc <capmgr_rcv_alloc+0xbc>
  409e2d:	55                   	push   rbp
  409e2e:	49 89 cb             	mov    r11,rcx
--
  409e53:	31 ff                	xor    edi,edi
		if (__thd_init_data[i].fn == NULL) {
  409e55:	48 83 3a 00          	cmp    QWORD PTR [rdx],0x0
  409e59:	74 25                	je     409e80 <capmgr_rcv_alloc+0x60>
	for (i = 0; i < COS_THD_INIT_REGION_SIZE; i++) {
  409e5b:	83 c7 01             	add    edi,0x1
  409e5e:	48 83 c2 10          	add    rdx,0x10
  409e62:	81 ff 00 01 00 00    	cmp    edi,0x100
  409e68:	75 eb                	jne    409e55 <capmgr_rcv_alloc+0x35>
	if (!tried) {
  409e6a:	41 83 f9 01          	cmp    r9d,0x1
  409e6e:	74 65                	je     409ed5 <capmgr_rcv_alloc+0xb5>
  409e70:	41 b9 01 00 00 00    	mov    r9d,0x1
  409e76:	eb d6                	jmp    409e4e <capmgr_rcv_alloc+0x2e>
  409e78:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  409e7f:	00 
  409e80:	4c 89 e0             	mov    rax,r12
  409e83:	f0 4c 0f b1 12       	lock cmpxchg QWORD PTR [rdx],r10
  409e88:	0f 94 c0             	sete   al
			if (!ret) continue;
  409e8b:	84 c0                	test   al,al
  409e8d:	74 cc                	je     409e5b <capmgr_rcv_alloc+0x3b>
			assert(__thd_init_data[i].fn == fn);
  409e8f:	48 63 c7             	movsxd rax,edi
  409e92:	48 c1 e0 04          	shl    rax,0x4
  409e96:	48 8d 90 40 f9 59 00 	lea    rdx,[rax+0x59f940]
  409e9d:	4c 3b 90 40 f9 59 00 	cmp    r10,QWORD PTR [rax+0x59f940]
  409ea4:	75 13                	jne    409eb9 <capmgr_rcv_alloc+0x99>
			__thd_init_data[i].data = data;
  409ea6:	48 89 5a 08          	mov    QWORD PTR [rdx+0x8],rbx
--
  409eb3:	5d                   	pop    rbp
	return capmgr_rcv_create(idx, flags, asnd, thdcap, tid);
  409eb4:	e9 77 d3 ff ff       	jmp    407230 <__cosrt_extern_capmgr_rcv_create>
  409eb9:	be 67 00 00 00       	mov    esi,0x67
  409ebe:	bf 60 d0 41 00       	mov    edi,0x41d060
  409ec3:	e8 08 02 00 00       	call   40a0d0 <cos_print_str>
			assert(__thd_init_data[i].fn == fn);
  409ec8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  409f16:	31 f6                	xor    esi,esi
		if (__thd_init_data[i].fn == NULL) {
  409f18:	48 83 3a 00          	cmp    QWORD PTR [rdx],0x0
  409f1c:	74 22                	je     409f40 <capmgr_aep_create+0x60>
	for (i = 0; i < COS_THD_INIT_REGION_SIZE; i++) {
  409f1e:	83 c6 01             	add    esi,0x1
  409f21:	48 83 c2 10          	add    rdx,0x10
  409f25:	81 fe 00 01 00 00    	cmp    esi,0x100
  409f2b:	75 eb                	jne    409f18 <capmgr_aep_create+0x38>
	if (!tried) {
  409f2d:	41 83 fe 01          	cmp    r14d,0x1
  409f31:	75 75                	jne    409fa8 <capmgr_aep_create+0xc8>
	if (idx < 1) return 0;
	a->fn   = fn;
--
  409f3e:	66 90                	xchg   ax,ax
  409f40:	4c 89 e0             	mov    rax,r12
  409f43:	f0 4c 0f b1 2a       	lock cmpxchg QWORD PTR [rdx],r13
  409f48:	0f 94 c0             	sete   al
			if (!ret) continue;
  409f4b:	84 c0                	test   al,al
  409f4d:	74 cf                	je     409f1e <capmgr_aep_create+0x3e>
			assert(__thd_init_data[i].fn == fn);
  409f4f:	48 63 c6             	movsxd rax,esi
  409f52:	48 c1 e0 04          	shl    rax,0x4
  409f56:	48 8d 90 40 f9 59 00 	lea    rdx,[rax+0x59f940]
  409f5d:	48 81 b8 40 f9 59 00 	cmp    QWORD PTR [rax+0x59f940],0x409d30
  409f64:	30 9d 40 00 
  409f68:	75 22                	jne    409f8c <capmgr_aep_create+0xac>
			__thd_init_data[i].data = data;
  409f6a:	48 89 7a 08          	mov    QWORD PTR [rdx+0x8],rdi
--
  409f86:	5d                   	pop    rbp
	return capmgr_aep_create_thunk(a, idx, owntc, key, ipiwin, ipimax);
  409f87:	e9 44 cf ff ff       	jmp    406ed0 <__cosrt_extern_capmgr_aep_create_thunk>
  409f8c:	be 67 00 00 00       	mov    esi,0x67
  409f91:	bf 60 d0 41 00       	mov    edi,0x41d060
  409f96:	e8 35 01 00 00       	call   40a0d0 <cos_print_str>
			assert(__thd_init_data[i].fn == fn);
  409f9b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  409fa6:	0f 0b                	ud2    
  409fa8:	41 be 01 00 00 00    	mov    r14d,0x1
  409fae:	e9 5e ff ff ff       	jmp    409f11 <capmgr_aep_create+0x31>
  409fb3:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  409fba:	00 00 00 
--
	return __crt_main != main;
  40a004:	b8 c0 9f 40 00       	mov    eax,0x409fc0
  40a009:	48 3d c0 9f 40 00    	cmp    rax,0x409fc0
  40a00f:	0f 95 c0             	setne  al
  40a012:	0f b6 c0             	movzx  eax,al
--
  40a01d:	00 00 00 

000000000040a020 <pre_syscall_default_setup>:
  40a020:	f3 0f 1e fa          	endbr64 
  40a024:	c3                   	ret    
--
  40a02c:	00 00 00 00 

000000000040a030 <pre_syscall_setup>:
}

/* Intended to be overriden by components */
CWEAKSYMB void
pre_syscall_setup()
{
  40a030:	f3 0f 1e fa          	endbr64 
	pre_syscall_default_setup();
  40a034:	31 c0                	xor    eax,eax
  40a036:	e9 e5 ff ff ff       	jmp    40a020 <pre_syscall_default_setup>
  40a03b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000040a040 <syscall_emulation_setup>:
  40a040:	f3 0f 1e fa          	endbr64 
  40a044:	c3                   	ret    
--
  40a094:	be c8 d0 41 00       	mov    esi,0x41d0c8
  40a099:	bf 20 60 42 00       	mov    edi,0x426020
  40a09e:	e9 1d ae 00 00       	jmp    414ec0 <__init_libc>
  40a0a3:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a0aa:	00 00 00 00 
  40a0ae:	66 90                	xchg   ax,ax

000000000040a0b0 <cos_upcall_exec>:
}

CWEAKSYMB void
cos_upcall_exec(void *arg)
{
  40a0b0:	f3 0f 1e fa          	endbr64 
--
  40a0f3:	41 54                	push   r12
  40a0f5:	53                   	push   rbx
  40a0f6:	eb 10                	jmp    40a108 <cos_print_str+0x38>
  40a0f8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40a0ff:	00 
		int ret;

		ret = call_cap(PRINT_CAP_TEMP, s_ints[0], s_ints[1], s_ints[2], len - written);
		/* Bomb out. Can't use a print out here as we must avoid recursion. */
		if (ret < 0) written = *(int *)NULL;
--
  40a100:	41 01 c2             	add    r10d,eax
	while (written < len) {
  40a103:	45 39 d5             	cmp    r13d,r10d
  40a106:	7e 60                	jle    40a168 <cos_print_str+0x98>
		u32_t *s_ints = (u32_t *)&s[written];
  40a108:	49 63 c2             	movsxd rax,r10d
		ret = call_cap(PRINT_CAP_TEMP, s_ints[0], s_ints[1], s_ints[2], len - written);
  40a10b:	44 89 ea             	mov    edx,r13d
	__asm__ __volatile__(
--
		u32_t *s_ints = (u32_t *)&s[written];
  40a111:	4c 01 f0             	add    rax,r14
		ret = call_cap(PRINT_CAP_TEMP, s_ints[0], s_ints[1], s_ints[2], len - written);
  40a114:	44 29 d2             	sub    edx,r10d
  40a117:	8b 18                	mov    ebx,DWORD PTR [rax]
--
  40a131:	49 b8 48 a1 40 00 00 	movabs r8,0x40a148
  40a138:	00 00 00 
  40a13b:	0f 05                	syscall 
  40a13d:	0f 1f 00             	nop    DWORD PTR [rax]
  40a140:	eb 0d                	jmp    40a14f <cos_print_str+0x7f>
  40a142:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40a148:	b9 00 00 00 00       	mov    ecx,0x0
  40a14d:	eb 05                	jmp    40a154 <cos_print_str+0x84>
  40a14f:	b9 01 00 00 00       	mov    ecx,0x1
  40a154:	5d                   	pop    rbp
--
  40a1b7:	4c 89 8d 78 ff ff ff 	mov    QWORD PTR [rbp-0x88],r9
  40a1be:	84 c0                	test   al,al
  40a1c0:	74 20                	je     40a1e2 <printc.constprop.0+0x52>
  40a1c2:	0f 29 45 80          	movaps XMMWORD PTR [rbp-0x80],xmm0
  40a1c6:	0f 29 4d 90          	movaps XMMWORD PTR [rbp-0x70],xmm1
--
  40a224:	00 00 00 
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40a227:	e8 34 b3 00 00       	call   415560 <vsnprintf>
	ret = cos_print_str(s, ret);
  40a22c:	48 8d bd 90 fe ff ff 	lea    rdi,[rbp-0x170]
--
  40a233:	89 c6                	mov    esi,eax
	ret = cos_print_str(s, ret);
  40a235:	e8 96 fe ff ff       	call   40a0d0 <cos_print_str>
}
  40a23a:	c9                   	leave  
--
  40a249:	48 83 ec 08          	sub    rsp,0x8
	return cos_print_str(s, strlen(s));
  40a24d:	e8 7e b7 00 00       	call   4159d0 <strlen>
  40a252:	4c 89 e7             	mov    rdi,r12
}
--
	return cos_print_str(s, strlen(s));
  40a25a:	89 c6                	mov    esi,eax
  40a25c:	e9 6f fe ff ff       	jmp    40a0d0 <cos_print_str>
  40a261:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a268:	00 00 00 00 
--
  40a27a:	bf 28 d1 41 00       	mov    edi,0x41d128
  40a27f:	48 89 e5             	mov    rbp,rsp
  40a282:	e8 49 fe ff ff       	call   40a0d0 <cos_print_str>
	assert(0);
  40a287:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40a29f:	90                   	nop

000000000040a2a0 <cos_syscall_handler>:
{
  40a2a0:	f3 0f 1e fa          	endbr64 
  40a2a4:	55                   	push   rbp
  40a2a5:	48 89 f2             	mov    rdx,rsi
	printc("Default syscall handler called (syscall: %d, first arg: %ld), faulting!", syscall_num, a);
  40a2a8:	31 c0                	xor    eax,eax
  40a2aa:	89 fe                	mov    esi,edi
--
{
  40a2b1:	48 89 e5             	mov    rbp,rsp
	printc("Default syscall handler called (syscall: %d, first arg: %ld), faulting!", syscall_num, a);
  40a2b4:	e8 d7 fe ff ff       	call   40a190 <printc.constprop.0>
  40a2b9:	be 2c 00 00 00       	mov    esi,0x2c
  40a2be:	bf 58 d1 41 00       	mov    edi,0x41d158
  40a2c3:	e8 08 fe ff ff       	call   40a0d0 <cos_print_str>
	assert(0);
  40a2c8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40a2dc:	00 00 00 00 

000000000040a2e0 <__cos_syscall>:
{
  40a2e0:	f3 0f 1e fa          	endbr64 
	return cos_syscall_handler(syscall_num, a, b, c, d, e, f, g);
  40a2e4:	e9 b7 ff ff ff       	jmp    40a2a0 <cos_syscall_handler>
  40a2e9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

--
	assert(cos_main_defined());
  40a2f4:	b8 c0 9f 40 00       	mov    eax,0x409fc0
  40a2f9:	48 3d c0 9f 40 00    	cmp    rax,0x409fc0
  40a2ff:	74 05                	je     40a306 <cos_main+0x16>
	return main();
  40a301:	e9 ba fc ff ff       	jmp    409fc0 <main>
{
  40a306:	55                   	push   rbp
--
  40a30c:	bf 88 d1 41 00       	mov    edi,0x41d188
  40a311:	48 89 e5             	mov    rbp,rsp
  40a314:	e8 b7 fd ff ff       	call   40a0d0 <cos_print_str>
	assert(cos_main_defined());
  40a319:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40a34c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000040a350 <cos_upcall_fn>:
}
#endif

CWEAKSYMB void
cos_upcall_fn(upcall_type_t t, void *arg1, void *arg2, void *arg3)
{
  40a350:	f3 0f 1e fa          	endbr64 
--
  40a36e:	66 90                	xchg   ax,ax
  40a370:	48 89 d0             	mov    rax,rdx
  40a373:	f0 48 0f b1 0d d4 65 	lock cmpxchg QWORD PTR [rip+0x1965d4],rcx        # 5a0950 <_lock.1>
  40a37a:	19 00 
  40a37c:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40a37f:	84 c0                	test   al,al
  40a381:	74 ed                	je     40a370 <cos_upcall_fn+0x20>
	 * There should be no concurrency at initialization (the init
	 * interface ensures this), so atomic operations aren't
--
	libc_tls_init(cos_cpuid());
  40a383:	31 ff                	xor    edi,edi
  40a385:	e8 f6 fc ff ff       	call   40a080 <libc_tls_init>
	if (first) {
  40a38a:	8b 05 78 bc 01 00    	mov    eax,DWORD PTR [rip+0x1bc78]        # 426008 <first.2>
  40a390:	85 c0                	test   eax,eax
  40a392:	0f 84 a5 00 00 00    	je     40a43d <cos_upcall_fn+0xed>
		/*
		 * Use the heap pointer as calculated from the linker
--
		 */
		if (__cosrt_comp_info.cos_heap_ptr == 0) {
  40a398:	48 83 3d b8 cc 01 00 	cmp    QWORD PTR [rip+0x1ccb8],0x0        # 427058 <__cosrt_comp_info+0x58>
  40a39f:	00 
		first = 0;
--
  40a3a7:	00 00 00 
		if (__cosrt_comp_info.cos_heap_ptr == 0) {
  40a3aa:	75 12                	jne    40a3be <cos_upcall_fn+0x6e>
			extern const vaddr_t __crt_static_heap_ptr;

--
	for (i = 0; i < list[0]; i++) {
  40a3c8:	45 31 ed             	xor    r13d,r13d
  40a3cb:	e8 60 ff ff ff       	call   40a330 <cos_print_level_set>
		/* The syscall enumlator might need something to be setup before it can work */
		pre_syscall_setup();
  40a3d0:	31 c0                	xor    eax,eax
  40a3d2:	e8 59 fc ff ff       	call   40a030 <pre_syscall_setup>
		/* libc needs syscall emulation to work */
		syscall_emulation_setup();
  40a3d7:	31 c0                	xor    eax,eax
  40a3d9:	e8 62 fc ff ff       	call   40a040 <syscall_emulation_setup>
		/* With all that setup, we can invoke the libc_initialization_handler */
		libc_initialization_handler();
  40a3de:	31 c0                	xor    eax,eax
  40a3e0:	e8 6b fc ff ff       	call   40a050 <libc_initialization_handler>
		/* init lib posix variants */
		libc_posixcap_initialization_handler();
  40a3e5:	31 c0                	xor    eax,eax
  40a3e7:	e8 74 fc ff ff       	call   40a060 <libc_posixcap_initialization_handler>
		libc_posixsched_initialization_handler();
  40a3ec:	31 c0                	xor    eax,eax
  40a3ee:	e8 7d fc ff ff       	call   40a070 <libc_posixsched_initialization_handler>
  40a3f3:	48 83 3d 05 8c 01 00 	cmp    QWORD PTR [rip+0x18c05],0x0        # 423000 <__CTOR_LIST__>
  40a3fa:	00 
  40a3fb:	7e 18                	jle    40a415 <cos_upcall_fn+0xc5>
  40a3fd:	0f 1f 00             	nop    DWORD PTR [rax]
		typedef void (*ctors_t)(void);
		ctors_t ctors = (ctors_t)list[i + 1];
		ctors();
  40a400:	42 ff 14 ed 08 30 42 	call   QWORD PTR [r13*8+0x423008]
  40a407:	00 
	for (i = 0; i < list[0]; i++) {
  40a408:	49 83 c5 01          	add    r13,0x1
  40a40c:	4c 3b 2d ed 8b 01 00 	cmp    r13,QWORD PTR [rip+0x18bed]        # 423000 <__CTOR_LIST__>
  40a413:	7c eb                	jl     40a400 <cos_upcall_fn+0xb0>
  40a415:	45 31 ed             	xor    r13d,r13d
  40a418:	48 83 3d 00 8c 01 00 	cmp    QWORD PTR [rip+0x18c00],0x0        # 423020 <__DTOR_END__>
  40a41f:	00 
  40a420:	7e 1b                	jle    40a43d <cos_upcall_fn+0xed>
  40a422:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
		ctors();
  40a428:	42 ff 14 ed 28 30 42 	call   QWORD PTR [r13*8+0x423028]
  40a42f:	00 
	for (i = 0; i < list[0]; i++) {
  40a430:	49 83 c5 01          	add    r13,0x1
  40a434:	4c 39 2d e5 8b 01 00 	cmp    QWORD PTR [rip+0x18be5],r13        # 423020 <__DTOR_END__>
  40a43b:	7f eb                	jg     40a428 <cos_upcall_fn+0xd8>
	ps_lock_release(&_lock);
	/*
	 * if it's the first component.. wait for timer calibration.
	 * NOTE: for "fork"ing components and not updating "spdid"s, this call will just fail and should be fine.
	 */
	if (cos_compid_uninitialized()) { /* we must be in the initial booter! */
  40a43d:	48 83 3d fb cb 01 00 	cmp    QWORD PTR [rip+0x1cbfb],0x0        # 427040 <__cosrt_comp_info+0x40>
  40a444:	00 
{ l->o = 0; }
  40a445:	48 c7 05 00 65 19 00 	mov    QWORD PTR [rip+0x196500],0x0        # 5a0950 <_lock.1>
  40a44c:	00 00 00 00 
  40a450:	74 58                	je     40a4aa <cos_upcall_fn+0x15a>
		cos_hw_cycles_per_usec(BOOT_CAPTBL_SELF_INITHW_BASE);
		perfcntr_init();
--
	switch (t) {
  40a452:	45 85 e4             	test   r12d,r12d
  40a455:	75 62                	jne    40a4b9 <cos_upcall_fn+0x169>
	{
		/* A new thread is created in this comp. */
--
		if (arg1 == 0) {
  40a457:	48 85 db             	test   rbx,rbx
  40a45a:	0f 84 82 00 00 00    	je     40a4e2 <cos_upcall_fn+0x192>
			static unsigned long first_core = 1;

--
  40a460:	48 83 eb 01          	sub    rbx,0x1
			if (idx >= COS_THD_INIT_REGION_SIZE) {
  40a464:	48 81 fb ff 00 00 00 	cmp    rbx,0xff
  40a46b:	77 68                	ja     40a4d5 <cos_upcall_fn+0x185>
	fn   = __thd_init_data[idx].fn;
  40a46d:	89 db                	mov    ebx,ebx
--
  40a485:	0f 29 83 40 f9 59 00 	movaps XMMWORD PTR [rbx+0x59f940],xmm0
	(fn)(data);
  40a48c:	ff d0                	call   rax
  40a48e:	be 2d 00 00 00       	mov    esi,0x2d
  40a493:	bf 78 d2 41 00       	mov    edi,0x41d278
  40a498:	e8 33 fc ff ff       	call   40a0d0 <cos_print_str>
	}
	default:
--
		cos_hw_cycles_per_usec(BOOT_CAPTBL_SELF_INITHW_BASE);
  40a4aa:	bf 24 00 00 00       	mov    edi,0x24
  40a4af:	e8 6c 7a 00 00       	call   411f20 <cos_hw_cycles_per_usec>
	switch (t) {
  40a4b4:	45 85 e4             	test   r12d,r12d
  40a4b7:	74 9e                	je     40a457 <cos_upcall_fn+0x107>
  40a4b9:	be 2d 00 00 00       	mov    esi,0x2d
  40a4be:	bf 48 d2 41 00       	mov    edi,0x41d248
  40a4c3:	e8 08 fc ff ff       	call   40a0d0 <cos_print_str>
		assert(0);
  40a4c8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
				cos_thd_entry_static(idx - COS_THD_INIT_REGION_SIZE);
  40a4d5:	8d bb 00 ff ff ff    	lea    edi,[rbx-0x100]
  40a4db:	e8 90 fd ff ff       	call   40a270 <cos_thd_entry_static>
  40a4e0:	eb ac                	jmp    40a48e <cos_upcall_fn+0x13e>
			start_execution(cos_coreid(), ps_cas(&first_core, 1, 0), init_parallelism());
  40a4e2:	e8 39 f8 ff ff       	call   409d20 <init_parallelism>
        __asm__ __volatile__("lock " PS_CAS_STR
  40a4e7:	b8 01 00 00 00       	mov    eax,0x1
  40a4ec:	f0 48 0f b1 1d 0b bb 	lock cmpxchg QWORD PTR [rip+0x1bb0b],rbx        # 426000 <first_core.3>
  40a4f3:	01 00 
  40a4f5:	0f 94 c0             	sete   al
--
	if (parallel_main != __crt_parallel_main) {
  40a4fc:	b8 00 47 40 00       	mov    eax,0x404700
  40a501:	48 3d d0 9f 40 00    	cmp    rax,0x409fd0
  40a507:	0f 84 9b 00 00 00    	je     40a5a8 <cos_upcall_fn+0x258>
	if (initialization_completed == 0) {
  40a50d:	8b 05 39 64 19 00    	mov    eax,DWORD PTR [rip+0x196439]        # 5a094c <initialization_completed.4>
  40a513:	85 c0                	test   eax,eax
  40a515:	75 79                	jne    40a590 <cos_upcall_fn+0x240>
		main_type = INIT_MAIN_PARALLEL;
  40a517:	41 bc 02 00 00 00    	mov    r12d,0x2
		if (init_core) {
  40a51d:	45 85 ed             	test   r13d,r13d
  40a520:	0f 85 a4 00 00 00    	jne    40a5ca <cos_upcall_fn+0x27a>
  40a526:	bb 30 47 40 00       	mov    ebx,0x404730
		COS_EXTERN_INV(init_parallel_await_init)();
  40a52b:	e8 80 b5 ff ff       	call   405ab0 <__cosrt_extern_init_parallel_await_init>
		if (parallel_init) {
  40a530:	48 81 fb e0 9f 40 00 	cmp    rbx,0x409fe0
  40a537:	74 11                	je     40a54a <cos_upcall_fn+0x1fa>
			cos_parallel_init(cid, init_core, init_parallelism());
  40a539:	e8 e2 f7 ff ff       	call   409d20 <init_parallelism>
  40a53e:	44 89 ee             	mov    esi,r13d
  40a541:	31 ff                	xor    edi,edi
  40a543:	89 c2                	mov    edx,eax
  40a545:	e8 e6 a1 ff ff       	call   404730 <cos_parallel_init>
		COS_EXTERN_INV(init_done)(0, main_type);
  40a54a:	44 89 e6             	mov    esi,r12d
  40a54d:	31 ff                	xor    edi,edi
  40a54f:	e8 7c b5 ff ff       	call   405ad0 <__cosrt_extern_init_done>
		initialization_completed = 1;
  40a554:	c7 05 ee 63 19 00 01 	mov    DWORD PTR [rip+0x1963ee],0x1        # 5a094c <initialization_completed.4>
--
	assert(main_type != INIT_MAIN_NONE);
  40a55e:	45 85 e4             	test   r12d,r12d
  40a561:	0f 84 89 00 00 00    	je     40a5f0 <cos_upcall_fn+0x2a0>
	assert(main_type == INIT_MAIN_PARALLEL || (main_type == INIT_MAIN_SINGLE && init_core));
  40a567:	41 83 fc 02          	cmp    r12d,0x2
  40a56b:	74 23                	je     40a590 <cos_upcall_fn+0x240>
  40a56d:	45 85 ed             	test   r13d,r13d
  40a570:	0f 84 ff 00 00 00    	je     40a675 <cos_upcall_fn+0x325>
	assert(cos_main_defined());
  40a576:	b8 c0 9f 40 00       	mov    eax,0x409fc0
  40a57b:	48 3d c0 9f 40 00    	cmp    rax,0x409fc0
  40a581:	0f 84 d7 00 00 00    	je     40a65e <cos_upcall_fn+0x30e>
	return main();
  40a587:	e8 34 fa ff ff       	call   409fc0 <main>
  40a58c:	89 c7                	mov    edi,eax
  40a58e:	eb 13                	jmp    40a5a3 <cos_upcall_fn+0x253>
		parallel_main(cid, init_core, init_parallelism());
  40a590:	e8 8b f7 ff ff       	call   409d20 <init_parallelism>
  40a595:	31 ff                	xor    edi,edi
  40a597:	44 89 ee             	mov    esi,r13d
  40a59a:	89 c2                	mov    edx,eax
  40a59c:	e8 5f a1 ff ff       	call   404700 <parallel_main>
	int ret = 0;
  40a5a1:	31 ff                	xor    edi,edi
	COS_EXTERN_INV(init_exit)(ret);
  40a5a3:	e8 c8 b6 ff ff       	call   405c70 <__cosrt_extern_init_exit>
	} else if (cos_main_defined()) {
  40a5a8:	b8 c0 9f 40 00       	mov    eax,0x409fc0
  40a5ad:	48 3d c0 9f 40 00    	cmp    rax,0x409fc0
  40a5b3:	74 52                	je     40a607 <cos_upcall_fn+0x2b7>
	if (initialization_completed == 0) {
  40a5b5:	8b 05 91 63 19 00    	mov    eax,DWORD PTR [rip+0x196391]        # 5a094c <initialization_completed.4>
  40a5bb:	85 c0                	test   eax,eax
  40a5bd:	75 ae                	jne    40a56d <cos_upcall_fn+0x21d>
		main_type = INIT_MAIN_SINGLE;
  40a5bf:	41 bc 01 00 00 00    	mov    r12d,0x1
  40a5c5:	e9 53 ff ff ff       	jmp    40a51d <cos_upcall_fn+0x1cd>
			cos_init();
  40a5ca:	31 c0                	xor    eax,eax
--
  40a5cc:	bb 30 47 40 00       	mov    ebx,0x404730
			cos_init();
  40a5d1:	e8 7a a2 ff ff       	call   404850 <cos_init>
	const int parallel_init = cos_parallel_init != __crt_cos_parallel_init;
  40a5d6:	31 ff                	xor    edi,edi
  40a5d8:	48 81 fb e0 9f 40 00 	cmp    rbx,0x409fe0
			COS_EXTERN_INV(init_done)(parallel_init, main_type);
  40a5df:	44 89 e6             	mov    esi,r12d
--
  40a5e2:	40 0f 95 c7          	setne  dil
			COS_EXTERN_INV(init_done)(parallel_init, main_type);
  40a5e6:	e8 e5 b4 ff ff       	call   405ad0 <__cosrt_extern_init_done>
			assert(parallel_init || main_type != INIT_MAIN_NONE);
  40a5eb:	e9 3b ff ff ff       	jmp    40a52b <cos_upcall_fn+0x1db>
	assert(main_type != INIT_MAIN_NONE);
  40a5f0:	bf e8 d1 41 00       	mov    edi,0x41d1e8
  40a5f5:	e8 46 fc ff ff       	call   40a240 <prints.isra.0>
  40a5fa:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40a601:	00 00 00 00 
--
  40a607:	8b 05 3f 63 19 00    	mov    eax,DWORD PTR [rip+0x19633f]        # 5a094c <initialization_completed.4>
  40a60d:	85 c0                	test   eax,eax
  40a60f:	75 df                	jne    40a5f0 <cos_upcall_fn+0x2a0>
		if (init_core) {
  40a611:	45 85 ed             	test   r13d,r13d
  40a614:	0f 84 0c ff ff ff    	je     40a526 <cos_upcall_fn+0x1d6>
			cos_init();
  40a61a:	31 c0                	xor    eax,eax
--
  40a61c:	bb 30 47 40 00       	mov    ebx,0x404730
			cos_init();
  40a621:	e8 2a a2 ff ff       	call   404850 <cos_init>
	const int parallel_init = cos_parallel_init != __crt_cos_parallel_init;
  40a626:	31 ff                	xor    edi,edi
  40a628:	48 81 fb e0 9f 40 00 	cmp    rbx,0x409fe0
  40a62f:	40 0f 95 c7          	setne  dil
			COS_EXTERN_INV(init_done)(parallel_init, main_type);
  40a633:	31 f6                	xor    esi,esi
  40a635:	e8 96 b4 ff ff       	call   405ad0 <__cosrt_extern_init_done>
			assert(parallel_init || main_type != INIT_MAIN_NONE);
  40a63a:	48 81 fb e0 9f 40 00 	cmp    rbx,0x409fe0
  40a641:	0f 85 e4 fe ff ff    	jne    40a52b <cos_upcall_fn+0x1db>
  40a647:	bf b8 d1 41 00       	mov    edi,0x41d1b8
  40a64c:	e8 ef fb ff ff       	call   40a240 <prints.isra.0>
  40a651:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40a658:	00 00 00 00 
--
	assert(cos_main_defined());
  40a65e:	bf 88 d1 41 00       	mov    edi,0x41d188
  40a663:	e8 d8 fb ff ff       	call   40a240 <prints.isra.0>
  40a668:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40a66f:	00 00 00 00 
--
	assert(main_type == INIT_MAIN_PARALLEL || (main_type == INIT_MAIN_SINGLE && init_core));
  40a675:	bf 18 d2 41 00       	mov    edi,0x41d218
  40a67a:	e8 c1 fb ff ff       	call   40a240 <prints.isra.0>
  40a67f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40a686:	00 00 00 00 
--
		r = (long)h + PAGE_SIZE;
  40a6a7:	48 8d 88 00 10 00 00 	lea    rcx,[rax+0x1000]
	__asm__ __volatile__("call cos_atomic_cmpxchg"
  40a6ae:	e8 7d 02 00 00       	call   40a930 <cos_atomic_cmpxchg>
	} while (cos_cmpxchg(&__cosrt_comp_info.cos_heap_ptr, (long)h, r) != r);
  40a6b3:	48 39 ca             	cmp    rdx,rcx
  40a6b6:	75 e8                	jne    40a6a0 <cos_get_vas_page+0x10>
	return h;
}
--
  40a6d2:	53                   	push   rbx
  40a6d3:	bb 58 70 42 00       	mov    ebx,0x427058
  40a6d8:	e8 53 02 00 00       	call   40a930 <cos_atomic_cmpxchg>
}
  40a6dd:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
--
  40a6fb:	48 8b 15 fe 51 19 00 	mov    rdx,QWORD PTR [rip+0x1951fe]        # 59f900 <_binary_tar_binary_end>
  40a702:	48 29 c2             	sub    rdx,rax
  40a705:	48 81 fa ff 01 00 00 	cmp    rdx,0x1ff
  40a70c:	ba 00 00 00 00       	mov    edx,0x0
  40a711:	48 0f 4e c2          	cmovle rax,rdx
--
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, &r1, &r2);
  40a73e:	48 85 c0             	test   rax,rax
  40a741:	74 1d                	je     40a760 <__cosrt_c_cosrtdefault+0x40>
  40a743:	4c 8d 4d d0          	lea    r9,[rbp-0x30]
  40a747:	4c 8d 45 c8          	lea    r8,[rbp-0x38]
  40a74b:	ff d0                	call   rax
	COS_CLIENT_INVCAP;
	return cos_sinv(uc, p0, p1, p2, p3);
--
  40a77e:	49 b8 98 a7 40 00 00 	movabs r8,0x40a798
  40a785:	00 00 00 
  40a788:	0f 05                	syscall 
  40a78a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40a790:	eb 0d                	jmp    40a79f <__cosrt_c_cosrtdefault+0x7f>
  40a792:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40a798:	b9 00 00 00 00       	mov    ecx,0x0
  40a79d:	eb 05                	jmp    40a7a4 <__cosrt_c_cosrtdefault+0x84>
  40a79f:	b9 01 00 00 00       	mov    ecx,0x1
  40a7a4:	5d                   	pop    rbp
--
  40a7e4:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  40a7e8:	4d 85 d2             	test   r10,r10
  40a7eb:	74 13                	je     40a800 <__cosrt_c_cosrtretdefault+0x40>
  40a7ed:	48 89 d1             	mov    rcx,rdx
  40a7f0:	4c 89 ea             	mov    rdx,r13
--
  40a7fa:	41 5f                	pop    r15
  40a7fc:	5d                   	pop    rbp
  40a7fd:	41 ff e2             	jmp    r10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40a800:	8d 41 01             	lea    eax,[rcx+0x1]
--
  40a817:	49 b8 30 a8 40 00 00 	movabs r8,0x40a830
  40a81e:	00 00 00 
  40a821:	0f 05                	syscall 
  40a823:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40a828:	eb 0f                	jmp    40a839 <__cosrt_c_cosrtretdefault+0x79>
  40a82a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40a830:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  40a837:	eb 07                	jmp    40a840 <__cosrt_c_cosrtretdefault+0x80>
  40a839:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  40a840:	5d                   	pop    rbp
--
  40a86a:	53                   	push   rbx
  40a86b:	50                   	push   rax
  40a86c:	e8 4f f8 ff ff       	call   40a0c0 <cos_async_inv>
  40a871:	83 c4 08             	add    esp,0x8
  40a874:	83 f8 00             	cmp    eax,0x0
  40a877:	74 22                	je     40a89b <ainv_ret>
  40a879:	67 8b 5c 24 18       	mov    ebx,DWORD PTR [esp+0x18]
  40a87e:	67 8b 74 24 1c       	mov    esi,DWORD PTR [esp+0x1c]
--
  40a8ca:	48 c1 e8 0d          	shr    rax,0xd
  40a8ce:	48 c1 ea 10          	shr    rdx,0x10
  40a8d2:	ff e1                	jmp    rcx
  40a8d4:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a8db:	00 00 00 00 
  40a8df:	90                   	nop

000000000040a8e0 <__cosrt_upcall_entry>:
  40a8e0:	48 b9 ef a8 40 00 00 	movabs rcx,0x40a8ef
  40a8e7:	00 00 00 
  40a8ea:	e9 c1 ff ff ff       	jmp    40a8b0 <custom_acquire_stack>
  40a8ef:	52                   	push   rdx
  40a8f0:	50                   	push   rax
--
  40a911:	4c 89 e7             	mov    rdi,r12
  40a914:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  40a918:	e8 33 fa ff ff       	call   40a350 <cos_upcall_fn>
  40a91d:	83 c4 18             	add    esp,0x18
  40a920:	5e                   	pop    rsi
--
  40a92b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000040a930 <cos_atomic_cmpxchg>:
  40a930:	c3                   	ret    

--
	if (!kv) return 0;
  40a940:	48 85 ff             	test   rdi,rdi
  40a943:	74 73                	je     40a9b8 <args_iter.part.0.isra.0+0x78>
	switch (kv->vtype) {
  40a945:	8b 47 08             	mov    eax,DWORD PTR [rdi+0x8]
  40a948:	85 c0                	test   eax,eax
  40a94a:	74 54                	je     40a9a0 <args_iter.part.0.isra.0+0x60>
  40a94c:	83 f8 01             	cmp    eax,0x1
  40a94f:	74 0f                	je     40a960 <args_iter.part.0.isra.0+0x20>
 * this returns the first item in the K/V store
 */
--
	if (i->curr == i->len) return 0;
  40a971:	85 c0                	test   eax,eax
  40a973:	75 0b                	jne    40a980 <args_iter.part.0.isra.0+0x40>
	switch (arg->type) {
	case ARGS_IMPL_KV:  return kv_iter(arg->d.kv_ent, &i->i.kv_i, &ent->d.kv_ent);
--
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  40a9d0:	31 c0                	xor    eax,eax
  40a9d2:	eb bc                	jmp    40a990 <args_iter.part.0.isra.0+0x50>
  40a9d4:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a9db:	00 00 00 00 
--
  40a9ef:	8b 07                	mov    eax,DWORD PTR [rdi]
  40a9f1:	85 c0                	test   eax,eax
  40a9f3:	74 1b                	je     40aa10 <args_key+0x30>
  40a9f5:	45 31 e4             	xor    r12d,r12d
  40a9f8:	83 f8 01             	cmp    eax,0x1
  40a9fb:	75 2c                	jne    40aa29 <args_key+0x49>
}
  40a9fd:	41 5c                	pop    r12
--
  40aa05:	5d                   	pop    rbp
	case ARGS_IMPL_TAR: return tar_key(&arg->d.tar_ent, arg_len);
  40aa06:	e9 a5 07 00 00       	jmp    40b1b0 <tar_key>
  40aa0b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40aa10:	4c 8b 67 08          	mov    r12,QWORD PTR [rdi+0x8]
	if (!kv) return NULL;
  40aa14:	4d 85 e4             	test   r12,r12
  40aa17:	74 10                	je     40aa29 <args_key+0x49>
	*key_len = strlen(kv->key);
  40aa19:	4d 8b 24 24          	mov    r12,QWORD PTR [r12]
  40aa1d:	4c 89 e7             	mov    rdi,r12
  40aa20:	e8 ab af 00 00       	call   4159d0 <strlen>
  40aa25:	41 89 45 00          	mov    DWORD PTR [r13+0x0],eax
}
--
  40aa44:	8b 07                	mov    eax,DWORD PTR [rdi]
  40aa46:	85 c0                	test   eax,eax
  40aa48:	74 1e                	je     40aa68 <args_value+0x28>
  40aa4a:	83 f8 01             	cmp    eax,0x1
  40aa4d:	75 11                	jne    40aa60 <args_value+0x20>
	case ARGS_IMPL_TAR: return tar_value(&arg->d.tar_ent);
  40aa4f:	48 83 c7 08          	add    rdi,0x8
  40aa53:	e9 08 08 00 00       	jmp    40b260 <tar_value>
  40aa58:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40aa5f:	00 
--
	if (!kv) return NULL;
  40aa6c:	48 85 c0             	test   rax,rax
  40aa6f:	74 f1                	je     40aa62 <args_value+0x22>
	switch (kv->vtype) {
  40aa71:	8b 50 08             	mov    edx,DWORD PTR [rax+0x8]
  40aa74:	85 d2                	test   edx,edx
  40aa76:	75 e8                	jne    40aa60 <args_value+0x20>
	case VTYPE_STR: return kv->val.str;
  40aa78:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
--
  40aa84:	8b 07                	mov    eax,DWORD PTR [rdi]
  40aa86:	85 c0                	test   eax,eax
  40aa88:	74 1e                	je     40aaa8 <args_len+0x28>
  40aa8a:	83 f8 01             	cmp    eax,0x1
  40aa8d:	75 11                	jne    40aaa0 <args_len+0x20>
	case ARGS_IMPL_TAR: return tar_len(&arg->d.tar_ent);
  40aa8f:	48 83 c7 08          	add    rdi,0x8
  40aa93:	e9 b8 0c 00 00       	jmp    40b750 <tar_len>
  40aa98:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40aa9f:	00 
--
	if (!kv) return 0;
  40aaac:	48 85 d2             	test   rdx,rdx
  40aaaf:	74 ef                	je     40aaa0 <args_len+0x20>
	switch (kv->vtype) {
  40aab1:	8b 4a 08             	mov    ecx,DWORD PTR [rdx+0x8]
  40aab4:	b8 01 00 00 00       	mov    eax,0x1
  40aab9:	85 c9                	test   ecx,ecx
  40aabb:	74 e5                	je     40aaa2 <args_len+0x22>
	default:        return 0;
  40aabd:	31 c0                	xor    eax,eax
	switch (kv->vtype) {
  40aabf:	83 f9 01             	cmp    ecx,0x1
  40aac2:	75 de                	jne    40aaa2 <args_len+0x22>
	case VTYPE_ARR: return kv->val.arr.sz;
  40aac4:	8b 42 10             	mov    eax,DWORD PTR [rdx+0x10]
--
	switch (i->type) {
  40aad8:	85 c0                	test   eax,eax
  40aada:	74 1c                	je     40aaf8 <args_iter_next+0x28>
  40aadc:	83 f8 01             	cmp    eax,0x1
  40aadf:	75 0f                	jne    40aaf0 <args_iter_next+0x20>
	case ARGS_IMPL_TAR: return tar_iter_next(&i->i.tar_i, &arg->d.tar_ent);
  40aae1:	48 83 c6 08          	add    rsi,0x8
  40aae5:	48 83 c7 08          	add    rdi,0x8
  40aae9:	e9 f2 08 00 00       	jmp    40b3e0 <tar_iter_next>
  40aaee:	66 90                	xchg   ax,ax
	switch (i->type) {
--
  40aaf8:	48 8b 4f 08          	mov    rcx,QWORD PTR [rdi+0x8]
  40aafc:	31 c0                	xor    eax,eax
  40aafe:	83 79 08 01          	cmp    DWORD PTR [rcx+0x8],0x1
  40ab02:	75 2c                	jne    40ab30 <args_iter_next+0x60>
	if (i->curr == i->len) return 0;
  40ab04:	48 63 57 10          	movsxd rdx,DWORD PTR [rdi+0x10]
  40ab08:	3b 57 14             	cmp    edx,DWORD PTR [rdi+0x14]
  40ab0b:	74 23                	je     40ab30 <args_iter_next+0x60>
	*ent = __kv_index(i->start, i->curr++);
  40ab0d:	8d 42 01             	lea    eax,[rdx+0x1]
  40ab10:	89 47 10             	mov    DWORD PTR [rdi+0x10],eax
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  40ab13:	3b 51 10             	cmp    edx,DWORD PTR [rcx+0x10]
  40ab16:	7d 20                	jge    40ab38 <args_iter_next+0x68>
  40ab18:	85 d2                	test   edx,edx
  40ab1a:	78 1c                	js     40ab38 <args_iter_next+0x68>
--
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  40ab38:	31 c0                	xor    eax,eax
  40ab3a:	eb e8                	jmp    40ab24 <args_iter_next+0x54>
  40ab3c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

--
	switch (arg->type) {
  40ab4a:	85 c0                	test   eax,eax
  40ab4c:	74 32                	je     40ab80 <args_iter+0x40>
  40ab4e:	83 f8 01             	cmp    eax,0x1
  40ab51:	75 25                	jne    40ab78 <args_iter+0x38>
	case ARGS_IMPL_TAR: return tar_iter(&arg->d.tar_ent, &i->i.tar_i, &ent->d.tar_ent);
  40ab53:	48 83 c2 08          	add    rdx,0x8
  40ab57:	48 83 c6 08          	add    rsi,0x8
  40ab5b:	48 83 c7 08          	add    rdi,0x8
  40ab5f:	e9 7c 0b 00 00       	jmp    40b6e0 <tar_iter>
  40ab64:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	*i = (struct kv_iter){
--
	if (!kv) return 0;
  40ab84:	48 85 c9             	test   rcx,rcx
  40ab87:	74 df                	je     40ab68 <args_iter+0x28>
	switch (kv->vtype) {
  40ab89:	8b 41 08             	mov    eax,DWORD PTR [rcx+0x8]
  40ab8c:	85 c0                	test   eax,eax
  40ab8e:	74 30                	je     40abc0 <args_iter+0x80>
  40ab90:	83 f8 01             	cmp    eax,0x1
  40ab93:	74 13                	je     40aba8 <args_iter+0x68>
	*i = (struct kv_iter){
  40ab95:	48 89 4e 08          	mov    QWORD PTR [rsi+0x8],rcx
--
	if (i->curr == i->len) return 0;
  40abb9:	85 c0                	test   eax,eax
  40abbb:	75 1b                	jne    40abd8 <args_iter+0x98>
}
  40abbd:	c3                   	ret    
--
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  40abf8:	31 c0                	xor    eax,eax
  40abfa:	eb ec                	jmp    40abe8 <args_iter+0xa8>
  40abfc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

--
	if (!ent) return -1;
  40ac04:	48 85 ff             	test   rdi,rdi
  40ac07:	0f 84 d7 00 00 00    	je     40ace4 <args_foreach+0xe4>
{
  40ac0d:	55                   	push   rbp
--
	switch (arg->type) {
  40ac28:	85 c0                	test   eax,eax
  40ac2a:	0f 84 90 00 00 00    	je     40acc0 <args_foreach+0xc0>
  40ac30:	83 f8 01             	cmp    eax,0x1
  40ac33:	75 43                	jne    40ac78 <args_foreach+0x78>
	case ARGS_IMPL_TAR: return tar_iter(&arg->d.tar_ent, &i->i.tar_i, &ent->d.tar_ent);
  40ac35:	48 83 c7 08          	add    rdi,0x8
  40ac39:	48 8d 55 a8          	lea    rdx,[rbp-0x58]
  40ac3d:	48 8d 75 c8          	lea    rsi,[rbp-0x38]
  40ac41:	e8 9a 0a 00 00       	call   40b6e0 <tar_iter>
	for (cont = args_iter(ent, &i, &curr); cont; cont = args_iter_next(&i, &curr)) {
  40ac46:	85 c0                	test   eax,eax
  40ac48:	74 2e                	je     40ac78 <args_foreach+0x78>
  40ac4a:	4c 8d 6d a0          	lea    r13,[rbp-0x60]
  40ac4e:	66 90                	xchg   ax,ax
--
  40ac50:	4c 89 e6             	mov    rsi,r12
  40ac53:	4c 89 ef             	mov    rdi,r13
  40ac56:	ff d3                	call   rbx
	arg->type = i->type;
  40ac58:	8b 45 c0             	mov    eax,DWORD PTR [rbp-0x40]
--
	switch (i->type) {
  40ac5e:	85 c0                	test   eax,eax
  40ac60:	74 26                	je     40ac88 <args_foreach+0x88>
  40ac62:	83 f8 01             	cmp    eax,0x1
  40ac65:	75 11                	jne    40ac78 <args_foreach+0x78>
	case ARGS_IMPL_TAR: return tar_iter_next(&i->i.tar_i, &arg->d.tar_ent);
  40ac67:	48 8d 75 a8          	lea    rsi,[rbp-0x58]
  40ac6b:	48 8d 7d c8          	lea    rdi,[rbp-0x38]
  40ac6f:	e8 6c 07 00 00       	call   40b3e0 <tar_iter_next>
	for (cont = args_iter(ent, &i, &curr); cont; cont = args_iter_next(&i, &curr)) {
  40ac74:	85 c0                	test   eax,eax
  40ac76:	75 d8                	jne    40ac50 <args_foreach+0x50>
	}

--
	if (i->start->vtype != VTYPE_ARR) return 0;
  40ac88:	48 8b 55 c8          	mov    rdx,QWORD PTR [rbp-0x38]
  40ac8c:	83 7a 08 01          	cmp    DWORD PTR [rdx+0x8],0x1
  40ac90:	75 e6                	jne    40ac78 <args_foreach+0x78>
	if (i->curr == i->len) return 0;
  40ac92:	48 63 45 d0          	movsxd rax,DWORD PTR [rbp-0x30]
  40ac96:	3b 45 d4             	cmp    eax,DWORD PTR [rbp-0x2c]
  40ac99:	74 dd                	je     40ac78 <args_foreach+0x78>
	*ent = __kv_index(i->start, i->curr++);
  40ac9b:	8d 48 01             	lea    ecx,[rax+0x1]
  40ac9e:	89 4d d0             	mov    DWORD PTR [rbp-0x30],ecx
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  40aca1:	3b 42 10             	cmp    eax,DWORD PTR [rdx+0x10]
  40aca4:	7d 3a                	jge    40ace0 <args_foreach+0xe0>
  40aca6:	85 c0                	test   eax,eax
  40aca8:	78 36                	js     40ace0 <args_foreach+0xe0>
--
  40acb2:	48 89 45 a8          	mov    QWORD PTR [rbp-0x58],rax
	for (cont = args_iter(ent, &i, &curr); cont; cont = args_iter_next(&i, &curr)) {
  40acb6:	eb 98                	jmp    40ac50 <args_foreach+0x50>
  40acb8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40acbf:	00 
--
  40acc8:	48 8d 75 c0          	lea    rsi,[rbp-0x40]
  40accc:	4c 89 ea             	mov    rdx,r13
  40accf:	e8 6c fc ff ff       	call   40a940 <args_iter.part.0.isra.0>
  40acd4:	e9 6d ff ff ff       	jmp    40ac46 <args_foreach+0x46>
  40acd9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  40ace0:	31 c0                	xor    eax,eax
  40ace2:	eb ce                	jmp    40acb2 <args_foreach+0xb2>
	if (!ent) return -1;
  40ace4:	b8 ff ff ff ff       	mov    eax,0xffffffff
--
  40ad18:	0f 94 c2             	sete   dl
  40ad1b:	08 d0                	or     al,dl
  40ad1d:	0f 85 4d 01 00 00    	jne    40ae70 <args_lkup_entry+0x180>
  40ad23:	49 89 f4             	mov    r12,rsi
  40ad26:	48 85 f6             	test   rsi,rsi
  40ad29:	0f 84 41 01 00 00    	je     40ae70 <args_lkup_entry+0x180>
	start = *arg;
  40ad2f:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
--
  40ad3f:	be 2f 00 00 00       	mov    esi,0x2f
  40ad44:	4c 89 e7             	mov    rdi,r12
  40ad47:	e8 d4 aa 00 00       	call   415820 <strchr>
  40ad4c:	49 89 c5             	mov    r13,rax
		len = slash ? (unsigned int)(slash - key) : strlen(key);
  40ad4f:	48 85 c0             	test   rax,rax
  40ad52:	0f 84 d8 01 00 00    	je     40af30 <args_lkup_entry+0x240>
  40ad58:	89 c3                	mov    ebx,eax
  40ad5a:	44 29 e3             	sub    ebx,r12d
--
	switch (arg->type) {
  40ad69:	85 c0                	test   eax,eax
  40ad6b:	0f 84 4f 01 00 00    	je     40aec0 <args_lkup_entry+0x1d0>
  40ad71:	83 f8 01             	cmp    eax,0x1
  40ad74:	0f 85 f6 00 00 00    	jne    40ae70 <args_lkup_entry+0x180>
	case ARGS_IMPL_TAR: return tar_iter(&arg->d.tar_ent, &i->i.tar_i, &ent->d.tar_ent);
  40ad7a:	48 8d 95 78 ff ff ff 	lea    rdx,[rbp-0x88]
  40ad81:	48 8d 75 b8          	lea    rsi,[rbp-0x48]
  40ad85:	48 8d 7d 98          	lea    rdi,[rbp-0x68]
  40ad89:	e8 52 09 00 00       	call   40b6e0 <tar_iter>

		/* ...and look the key up in the KV */
		for (cont = args_iter(&start, &i, &curr) ; cont ; cont = args_iter_next(&i, &curr)) {
  40ad8e:	85 c0                	test   eax,eax
  40ad90:	0f 84 da 00 00 00    	je     40ae70 <args_lkup_entry+0x180>
  40ad96:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40ad9d:	00 00 00 
--
  40ada0:	8b 85 70 ff ff ff    	mov    eax,DWORD PTR [rbp-0x90]
  40ada6:	85 c0                	test   eax,eax
  40ada8:	74 79                	je     40ae23 <args_lkup_entry+0x133>
  40adaa:	83 f8 01             	cmp    eax,0x1
  40adad:	0f 84 dd 00 00 00    	je     40ae90 <args_lkup_entry+0x1a0>
			int key_len;
			char *k = args_key(&curr, &key_len);

			if ((unsigned int)key_len == len && strncmp(k, key, len) == 0) {
  40adb3:	8b 95 6c ff ff ff    	mov    edx,DWORD PTR [rbp-0x94]
	default:            return NULL;
  40adb9:	45 31 f6             	xor    r14d,r14d
			if ((unsigned int)key_len == len && strncmp(k, key, len) == 0) {
  40adbc:	39 da                	cmp    edx,ebx
  40adbe:	75 19                	jne    40add9 <args_lkup_entry+0xe9>
  40adc0:	41 89 d7             	mov    r15d,edx
  40adc3:	4c 89 e6             	mov    rsi,r12
  40adc6:	4c 89 f7             	mov    rdi,r14
  40adc9:	4c 89 fa             	mov    rdx,r15
  40adcc:	e8 7f ac 00 00       	call   415a50 <strncmp>
  40add1:	85 c0                	test   eax,eax
  40add3:	0f 84 07 01 00 00    	je     40aee0 <args_lkup_entry+0x1f0>
	arg->type = i->type;
  40add9:	8b 45 b0             	mov    eax,DWORD PTR [rbp-0x50]
--
	switch (i->type) {
  40ade2:	85 c0                	test   eax,eax
  40ade4:	75 6a                	jne    40ae50 <args_lkup_entry+0x160>
	if (i->start->vtype != VTYPE_ARR) return 0;
  40ade6:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
  40adea:	83 7a 08 01          	cmp    DWORD PTR [rdx+0x8],0x1
  40adee:	0f 85 7c 00 00 00    	jne    40ae70 <args_lkup_entry+0x180>
	if (i->curr == i->len) return 0;
  40adf4:	48 63 45 c0          	movsxd rax,DWORD PTR [rbp-0x40]
  40adf8:	3b 45 c4             	cmp    eax,DWORD PTR [rbp-0x3c]
  40adfb:	74 73                	je     40ae70 <args_lkup_entry+0x180>
	*ent = __kv_index(i->start, i->curr++);
  40adfd:	8d 48 01             	lea    ecx,[rax+0x1]
  40ae00:	89 4d c0             	mov    DWORD PTR [rbp-0x40],ecx
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  40ae03:	3b 42 10             	cmp    eax,DWORD PTR [rdx+0x10]
  40ae06:	0f 8d ac 00 00 00    	jge    40aeb8 <args_lkup_entry+0x1c8>
  40ae0c:	85 c0                	test   eax,eax
  40ae0e:	0f 88 a4 00 00 00    	js     40aeb8 <args_lkup_entry+0x1c8>
--
	if (!kv) return NULL;
  40ae2a:	4d 85 f6             	test   r14,r14
  40ae2d:	74 77                	je     40aea6 <args_lkup_entry+0x1b6>
	*key_len = strlen(kv->key);
  40ae2f:	4d 8b 36             	mov    r14,QWORD PTR [r14]
  40ae32:	4c 89 f7             	mov    rdi,r14
  40ae35:	e8 96 ab 00 00       	call   4159d0 <strlen>
  40ae3a:	89 c2                	mov    edx,eax
  40ae3c:	89 85 6c ff ff ff    	mov    DWORD PTR [rbp-0x94],eax
			if ((unsigned int)key_len == len && strncmp(k, key, len) == 0) {
  40ae42:	39 da                	cmp    edx,ebx
  40ae44:	0f 84 76 ff ff ff    	je     40adc0 <args_lkup_entry+0xd0>
  40ae4a:	eb 8d                	jmp    40add9 <args_lkup_entry+0xe9>
  40ae4c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	switch (i->type) {
  40ae50:	83 f8 01             	cmp    eax,0x1
  40ae53:	75 1b                	jne    40ae70 <args_lkup_entry+0x180>
	case ARGS_IMPL_TAR: return tar_iter_next(&i->i.tar_i, &arg->d.tar_ent);
  40ae55:	48 8d b5 78 ff ff ff 	lea    rsi,[rbp-0x88]
  40ae5c:	48 8d 7d b8          	lea    rdi,[rbp-0x48]
  40ae60:	e8 7b 05 00 00       	call   40b3e0 <tar_iter_next>
		for (cont = args_iter(&start, &i, &curr) ; cont ; cont = args_iter_next(&i, &curr)) {
  40ae65:	85 c0                	test   eax,eax
  40ae67:	0f 85 33 ff ff ff    	jne    40ada0 <args_lkup_entry+0xb0>
  40ae6d:	0f 1f 00             	nop    DWORD PTR [rax]
				start = curr;
--
  40ae90:	48 8d b5 6c ff ff ff 	lea    rsi,[rbp-0x94]
  40ae97:	48 8d bd 78 ff ff ff 	lea    rdi,[rbp-0x88]
  40ae9e:	e8 0d 03 00 00       	call   40b1b0 <tar_key>
  40aea3:	49 89 c6             	mov    r14,rax
			if ((unsigned int)key_len == len && strncmp(k, key, len) == 0) {
  40aea6:	8b 95 6c ff ff ff    	mov    edx,DWORD PTR [rbp-0x94]
	case ARGS_IMPL_TAR: return tar_key(&arg->d.tar_ent, arg_len);
  40aeac:	e9 0b ff ff ff       	jmp    40adbc <args_lkup_entry+0xcc>
  40aeb1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  40aeb8:	31 c0                	xor    eax,eax
  40aeba:	e9 5d ff ff ff       	jmp    40ae1c <args_lkup_entry+0x12c>
  40aebf:	90                   	nop
  40aec0:	48 8b 7d 98          	mov    rdi,QWORD PTR [rbp-0x68]
  40aec4:	48 8d 95 70 ff ff ff 	lea    rdx,[rbp-0x90]
  40aecb:	48 8d 75 b0          	lea    rsi,[rbp-0x50]
  40aecf:	e8 6c fa ff ff       	call   40a940 <args_iter.part.0.isra.0>
  40aed4:	e9 b5 fe ff ff       	jmp    40ad8e <args_lkup_entry+0x9e>
  40aed9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
				if (strlen(key) == len) {
  40aee0:	4c 89 e7             	mov    rdi,r12
  40aee3:	89 85 54 ff ff ff    	mov    DWORD PTR [rbp-0xac],eax
  40aee9:	e8 e2 aa 00 00       	call   4159d0 <strlen>
  40aeee:	44 8b 85 54 ff ff ff 	mov    r8d,DWORD PTR [rbp-0xac]
  40aef5:	49 39 c7             	cmp    r15,rax
  40aef8:	74 45                	je     40af3f <args_lkup_entry+0x24f>
				start = curr;
  40aefa:	66 0f 6f 8d 70 ff ff 	movdqa xmm1,XMMWORD PTR [rbp-0x90]
--
		if (slash) key = slash + 1;
  40af0e:	4d 85 ed             	test   r13,r13
  40af11:	0f 84 59 ff ff ff    	je     40ae70 <args_lkup_entry+0x180>
	} while (slash && *key != '\0');
  40af17:	41 80 7d 01 00       	cmp    BYTE PTR [r13+0x1],0x0
		if (slash) key = slash + 1;
  40af1c:	4d 8d 65 01          	lea    r12,[r13+0x1]
	} while (slash && *key != '\0');
  40af20:	0f 85 19 fe ff ff    	jne    40ad3f <args_lkup_entry+0x4f>
  40af26:	e9 45 ff ff ff       	jmp    40ae70 <args_lkup_entry+0x180>
  40af2b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		len = slash ? (unsigned int)(slash - key) : strlen(key);
  40af30:	4c 89 e7             	mov    rdi,r12
  40af33:	e8 98 aa 00 00       	call   4159d0 <strlen>
  40af38:	89 c3                	mov    ebx,eax
  40af3a:	e9 1e fe ff ff       	jmp    40ad5d <args_lkup_entry+0x6d>
					*ret = curr;
  40af3f:	48 8b 8d 58 ff ff ff 	mov    rcx,QWORD PTR [rbp-0xa8]
--
  40af55:	48 89 41 10          	mov    QWORD PTR [rcx+0x10],rax
					return 0;
  40af59:	e9 18 ff ff ff       	jmp    40ae76 <args_lkup_entry+0x186>
  40af5e:	66 90                	xchg   ax,ax

--
  40af6e:	44 8b 27             	mov    r12d,DWORD PTR [rdi]
  40af71:	45 85 e4             	test   r12d,r12d
  40af74:	74 3a                	je     40afb0 <args_type+0x50>
  40af76:	41 83 fc 01          	cmp    r12d,0x1
  40af7a:	75 24                	jne    40afa0 <args_type+0x40>
	case ARGS_IMPL_KV:  return kv_type(ent->d.kv_ent);
	case ARGS_IMPL_TAR: return tar_is_value(&ent->d.tar_ent) ? ARGS_VAL : ARGS_MAP;
  40af7c:	48 83 c7 08          	add    rdi,0x8
  40af80:	e8 fb 03 00 00       	call   40b380 <tar_is_value>
  40af85:	85 c0                	test   eax,eax
  40af87:	b8 02 00 00 00       	mov    eax,0x2
--
  40afba:	8b 40 08             	mov    eax,DWORD PTR [rax+0x8]
  40afbd:	85 c0                	test   eax,eax
  40afbf:	74 cf                	je     40af90 <args_type+0x30>
  40afc1:	45 31 e4             	xor    r12d,r12d
  40afc4:	83 f8 01             	cmp    eax,0x1
  40afc7:	41 0f 94 c4          	sete   r12b
}
--
	return args_lkup_entry(from, path, ent);
  40afea:	4c 89 c6             	mov    rsi,r8
  40afed:	e9 fe fc ff ff       	jmp    40acf0 <args_lkup_entry>
  40aff2:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40aff9:	00 00 00 00 
--
	return args_lkup_entry(from, path, ent);
  40b015:	48 8d 55 e0          	lea    rdx,[rbp-0x20]
  40b019:	e8 d2 fc ff ff       	call   40acf0 <args_lkup_entry>
  40b01e:	41 89 c0             	mov    r8d,eax
	struct initargs ent;
--
  40b021:	31 c0                	xor    eax,eax
  40b023:	45 85 c0             	test   r8d,r8d
  40b026:	75 0c                	jne    40b034 <args_get_from+0x34>
	switch (arg->type) {
  40b028:	8b 55 e0             	mov    edx,DWORD PTR [rbp-0x20]
  40b02b:	85 d2                	test   edx,edx
  40b02d:	74 21                	je     40b050 <args_get_from+0x50>
  40b02f:	83 fa 01             	cmp    edx,0x1
  40b032:	74 0c                	je     40b040 <args_get_from+0x40>

	return args_value(&ent);
--
	case ARGS_IMPL_TAR: return tar_value(&arg->d.tar_ent);
  40b040:	48 8d 7d e8          	lea    rdi,[rbp-0x18]
  40b044:	e8 17 02 00 00       	call   40b260 <tar_value>
}
  40b049:	c9                   	leave  
--
	if (!kv) return NULL;
  40b054:	48 85 c0             	test   rax,rax
  40b057:	74 db                	je     40b034 <args_get_from+0x34>
	switch (kv->vtype) {
  40b059:	8b 50 08             	mov    edx,DWORD PTR [rax+0x8]
  40b05c:	85 d2                	test   edx,edx
  40b05e:	75 10                	jne    40b070 <args_get_from+0x70>
	case VTYPE_STR: return kv->val.str;
  40b060:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
--
  40b09d:	48 83 ec 20          	sub    rsp,0x20
	return args_lkup_entry(from, path, ent);
  40b0a1:	e8 4a fc ff ff       	call   40acf0 <args_lkup_entry>
	struct initargs tarroot;
	struct tar_entry *tarent;
--
	if (!args_get_entry_from(path, &__initargs_root, ent)) return 0;
  40b0a6:	85 c0                	test   eax,eax
  40b0a8:	75 0e                	jne    40b0b8 <args_get_entry+0x38>
		.type = ARGS_IMPL_TAR,
		.d.tar_ent = *tarent
--
  40b0b4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	tarent = tar_root();
  40b0b8:	e8 33 07 00 00       	call   40b7f0 <tar_root>
	if (!tarent) return -1;
  40b0bd:	48 85 c0             	test   rax,rax
  40b0c0:	74 2d                	je     40b0ef <args_get_entry+0x6f>
		.d.tar_ent = *tarent
  40b0c2:	8b 10                	mov    edx,DWORD PTR [rax]
--
  40b0dc:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax
	return args_lkup_entry(from, path, ent);
  40b0e0:	e8 0b fc ff ff       	call   40acf0 <args_lkup_entry>
}
  40b0e5:	48 83 c4 20          	add    rsp,0x20
--
	if (!tarent) return -1;
  40b0ef:	b8 ff ff ff ff       	mov    eax,0xffffffff
  40b0f4:	eb b4                	jmp    40b0aa <args_get_entry+0x2a>
  40b0f6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40b0fd:	00 00 00 
--
  40b119:	48 83 ec 48          	sub    rsp,0x48
	return args_lkup_entry(from, path, ent);
  40b11d:	e8 ce fb ff ff       	call   40acf0 <args_lkup_entry>
	if (!args_get_entry_from(path, &__initargs_root, ent)) return 0;
  40b122:	85 c0                	test   eax,eax
  40b124:	75 4a                	jne    40b170 <args_get+0x70>
	switch (arg->type) {
  40b126:	8b 45 b0             	mov    eax,DWORD PTR [rbp-0x50]
  40b129:	85 c0                	test   eax,eax
  40b12b:	74 23                	je     40b150 <args_get+0x50>
  40b12d:	83 f8 01             	cmp    eax,0x1
  40b130:	74 0e                	je     40b140 <args_get+0x40>
	struct initargs ent;

--
	case ARGS_IMPL_TAR: return tar_value(&arg->d.tar_ent);
  40b140:	48 8d 7d b8          	lea    rdi,[rbp-0x48]
  40b144:	e8 17 01 00 00       	call   40b260 <tar_value>
}
  40b149:	4c 8b 65 f8          	mov    r12,QWORD PTR [rbp-0x8]
--
	if (!kv) return NULL;
  40b154:	48 85 c0             	test   rax,rax
  40b157:	74 d9                	je     40b132 <args_get+0x32>
	switch (kv->vtype) {
  40b159:	8b 50 08             	mov    edx,DWORD PTR [rax+0x8]
  40b15c:	85 d2                	test   edx,edx
  40b15e:	75 d2                	jne    40b132 <args_get+0x32>
	case VTYPE_STR: return kv->val.str;
  40b160:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
--
  40b16a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	tarent = tar_root();
  40b170:	e8 7b 06 00 00       	call   40b7f0 <tar_root>
	if (!tarent) return -1;
  40b175:	48 85 c0             	test   rax,rax
  40b178:	74 ba                	je     40b134 <args_get+0x34>
		.d.tar_ent = *tarent
  40b17a:	8b 10                	mov    edx,DWORD PTR [rax]
--
  40b195:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax
	return args_lkup_entry(from, path, ent);
  40b199:	e8 52 fb ff ff       	call   40acf0 <args_lkup_entry>
	if (args_get_entry(path, &ent)) return NULL;
  40b19e:	85 c0                	test   eax,eax
  40b1a0:	75 90                	jne    40b132 <args_get+0x32>
  40b1a2:	eb 82                	jmp    40b126 <args_get+0x26>
  40b1a4:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40b1ab:	00 00 00 
--
  40b1d1:	7e 3d                	jle    40b210 <tar_key+0x60>
  40b1d3:	31 db                	xor    ebx,ebx
  40b1d5:	eb 15                	jmp    40b1ec <tar_key+0x3c>
  40b1d7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40b1de:	00 00 
--
  40b1e3:	48 83 c7 01          	add    rdi,0x1
	for (i = 0 ; i < nesting_lvl ; i++) {
  40b1e7:	41 39 dc             	cmp    r12d,ebx
  40b1ea:	74 24                	je     40b210 <tar_key+0x60>
		key = strchr(key, '/');
  40b1ec:	be 2f 00 00 00       	mov    esi,0x2f
  40b1f1:	e8 2a a6 00 00       	call   415820 <strchr>
  40b1f6:	48 89 c7             	mov    rdi,rax
		if (!key) return NULL;
  40b1f9:	48 85 c0             	test   rax,rax
  40b1fc:	75 e2                	jne    40b1e0 <tar_key+0x30>
}
  40b1fe:	48 83 c4 18          	add    rsp,0x18
--
  40b210:	be 2f 00 00 00       	mov    esi,0x2f
  40b215:	48 89 7d d8          	mov    QWORD PTR [rbp-0x28],rdi
  40b219:	e8 02 a6 00 00       	call   415820 <strchr>
	if (!end) *key_len = strlen(key);
  40b21e:	48 8b 7d d8          	mov    rdi,QWORD PTR [rbp-0x28]
  40b222:	48 85 c0             	test   rax,rax
  40b225:	74 19                	je     40b240 <tar_key+0x90>
	else      *key_len = end - key;
  40b227:	48 29 f8             	sub    rax,rdi
--
  40b23c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	if (!end) *key_len = strlen(key);
  40b240:	e8 8b a7 00 00       	call   4159d0 <strlen>
  40b245:	48 8b 7d d8          	mov    rdi,QWORD PTR [rbp-0x28]
  40b249:	41 89 45 00          	mov    DWORD PTR [r13+0x0],eax
--
	return !(!ent || !ent->record || tar_end(ent->record));
  40b267:	48 85 ff             	test   rdi,rdi
  40b26a:	74 41                	je     40b2ad <tar_value+0x4d>
  40b26c:	4c 8b 47 08          	mov    r8,QWORD PTR [rdi+0x8]
  40b270:	4d 85 c0             	test   r8,r8
  40b273:	74 38                	je     40b2ad <tar_value+0x4d>
  40b275:	4c 89 c0             	mov    rax,r8
  40b278:	49 8d 90 00 04 00 00 	lea    rdx,[r8+0x400]
  40b27f:	eb 10                	jmp    40b291 <tar_value+0x31>
  40b281:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40b288:	48 83 c0 01          	add    rax,0x1
  40b28c:	48 39 d0             	cmp    rax,rdx
  40b28f:	74 27                	je     40b2b8 <tar_value+0x58>
		if (((char *)r)[i]) return 0;
  40b291:	80 38 00             	cmp    BYTE PTR [rax],0x0
  40b294:	74 f2                	je     40b288 <tar_value+0x28>
	return *r->linkflag == '0' || *r->linkflag == '\0';
  40b296:	41 0f b6 80 9c 00 00 	movzx  eax,BYTE PTR [r8+0x9c]
  40b29d:	00 
	if (!tar_is_file(ent->record)) return NULL;
  40b29e:	3c 30                	cmp    al,0x30
  40b2a0:	74 04                	je     40b2a6 <tar_value+0x46>
  40b2a2:	84 c0                	test   al,al
  40b2a4:	75 12                	jne    40b2b8 <tar_value+0x58>

	return (char *)&ent->record[1];
--
	return !(!ent || !ent->record || tar_end(ent->record));
  40b2c7:	48 85 ff             	test   rdi,rdi
  40b2ca:	74 54                	je     40b320 <tar_value_sz+0x60>
{
  40b2cc:	55                   	push   rbp
--
  40b2d5:	48 8b 5f 08          	mov    rbx,QWORD PTR [rdi+0x8]
  40b2d9:	48 85 db             	test   rbx,rbx
  40b2dc:	74 32                	je     40b310 <tar_value_sz+0x50>
  40b2de:	48 89 d8             	mov    rax,rbx
  40b2e1:	48 8d 93 00 04 00 00 	lea    rdx,[rbx+0x400]
  40b2e8:	eb 0f                	jmp    40b2f9 <tar_value_sz+0x39>
  40b2ea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40b2f0:	48 83 c0 01          	add    rax,0x1
  40b2f4:	48 39 d0             	cmp    rax,rdx
  40b2f7:	74 14                	je     40b30d <tar_value_sz+0x4d>
		if (((char *)r)[i]) return 0;
  40b2f9:	80 38 00             	cmp    BYTE PTR [rax],0x0
  40b2fc:	74 f2                	je     40b2f0 <tar_value_sz+0x30>
	return *r->linkflag == '0' || *r->linkflag == '\0';
  40b2fe:	0f b6 83 9c 00 00 00 	movzx  eax,BYTE PTR [rbx+0x9c]
	if (!tar_is_file(ent->record)) return 0;
  40b305:	3c 30                	cmp    al,0x30
  40b307:	74 1f                	je     40b328 <tar_value_sz+0x68>
  40b309:	84 c0                	test   al,al
  40b30b:	74 1b                	je     40b328 <tar_value_sz+0x68>
	if (!tar_valid(ent)) return 0;
  40b30d:	45 31 c0             	xor    r8d,r8d
--
  40b328:	48 8d 7b 7c          	lea    rdi,[rbx+0x7c]
  40b32c:	be 0c 00 00 00       	mov    esi,0xc
  40b331:	e8 9a a7 00 00       	call   415ad0 <strnlen>
  40b336:	8d 50 ff             	lea    edx,[rax-0x1]
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40b339:	85 c0                	test   eax,eax
  40b33b:	74 d0                	je     40b30d <tar_value_sz+0x4d>
  40b33d:	48 63 d2             	movsxd rdx,edx
  40b340:	45 31 c0             	xor    r8d,r8d
  40b343:	b9 01 00 00 00       	mov    ecx,0x1
  40b348:	eb 1a                	jmp    40b364 <tar_value_sz+0xa4>
  40b34a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
		tot = tot + (val * base);
--
  40b364:	0f b6 44 13 7c       	movzx  eax,BYTE PTR [rbx+rdx*1+0x7c]
  40b369:	83 e8 30             	sub    eax,0x30
  40b36c:	3c 07                	cmp    al,0x7
  40b36e:	76 e0                	jbe    40b350 <tar_value_sz+0x90>
	if (i == TAR_RECORD_SIZE) return -1;
  40b370:	41 b8 ff ff ff ff    	mov    r8d,0xffffffff
  40b376:	eb 98                	jmp    40b310 <tar_value_sz+0x50>
  40b378:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40b37f:	00 
--
	return !(!ent || !ent->record || tar_end(ent->record));
  40b386:	48 85 ff             	test   rdi,rdi
  40b389:	74 3a                	je     40b3c5 <tar_is_value+0x45>
  40b38b:	48 8b 4f 08          	mov    rcx,QWORD PTR [rdi+0x8]
  40b38f:	48 85 c9             	test   rcx,rcx
  40b392:	74 31                	je     40b3c5 <tar_is_value+0x45>
  40b394:	48 89 c8             	mov    rax,rcx
  40b397:	48 8d 91 00 04 00 00 	lea    rdx,[rcx+0x400]
  40b39e:	eb 09                	jmp    40b3a9 <tar_is_value+0x29>
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40b3a0:	48 83 c0 01          	add    rax,0x1
  40b3a4:	48 39 d0             	cmp    rax,rdx
  40b3a7:	74 27                	je     40b3d0 <tar_is_value+0x50>
		if (((char *)r)[i]) return 0;
  40b3a9:	80 38 00             	cmp    BYTE PTR [rax],0x0
  40b3ac:	74 f2                	je     40b3a0 <tar_is_value+0x20>
	return *r->linkflag == '0' || *r->linkflag == '\0';
  40b3ae:	0f b6 91 9c 00 00 00 	movzx  edx,BYTE PTR [rcx+0x9c]
  40b3b5:	80 fa 30             	cmp    dl,0x30
  40b3b8:	0f 94 c0             	sete   al
  40b3bb:	84 d2                	test   dl,dl
--
	if (!i || !tar_valid(&i->entry)) return 0;
  40b3f9:	48 85 ff             	test   rdi,rdi
  40b3fc:	0f 84 ee 00 00 00    	je     40b4f0 <tar_iter_next+0x110>
	return !(!ent || !ent->record || tar_end(ent->record));
  40b402:	4c 8b 67 08          	mov    r12,QWORD PTR [rdi+0x8]
--
	return !(!ent || !ent->record || tar_end(ent->record));
  40b40b:	4d 85 e4             	test   r12,r12
  40b40e:	0f 84 de 00 00 00    	je     40b4f2 <tar_iter_next+0x112>
  40b414:	4d 8d ac 24 00 04 00 	lea    r13,[r12+0x400]
  40b41b:	00 
  40b41c:	4c 89 e0             	mov    rax,r12
  40b41f:	eb 14                	jmp    40b435 <tar_iter_next+0x55>
  40b421:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40b428:	48 83 c0 01          	add    rax,0x1
  40b42c:	4c 39 e8             	cmp    rax,r13
  40b42f:	0f 84 bb 00 00 00    	je     40b4f0 <tar_iter_next+0x110>
		if (((char *)r)[i]) return 0;
  40b435:	80 38 00             	cmp    BYTE PTR [rax],0x0
  40b438:	74 ee                	je     40b428 <tar_iter_next+0x48>
  40b43a:	4c 89 e0             	mov    rax,r12
  40b43d:	eb 0e                	jmp    40b44d <tar_iter_next+0x6d>
  40b43f:	90                   	nop
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40b440:	48 83 c0 01          	add    rax,0x1
  40b444:	4c 39 e8             	cmp    rax,r13
  40b447:	0f 84 a3 00 00 00    	je     40b4f0 <tar_iter_next+0x110>
		if (((char *)r)[i]) return 0;
  40b44d:	80 38 00             	cmp    BYTE PTR [rax],0x0
  40b450:	74 ee                	je     40b440 <tar_iter_next+0x60>
	if (!tar_valid(path) || iter == NULL || *iter == NULL) return NULL;
  40b452:	4d 8b 7e 10          	mov    r15,QWORD PTR [r14+0x10]
  40b456:	4d 85 ff             	test   r15,r15
  40b459:	0f 84 91 00 00 00    	je     40b4f0 <tar_iter_next+0x110>
  40b45f:	90                   	nop
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
--
  40b463:	4d 8d 8f 00 04 00 00 	lea    r9,[r15+0x400]
  40b46a:	4c 89 f8             	mov    rax,r15
  40b46d:	eb 0a                	jmp    40b479 <tar_iter_next+0x99>
  40b46f:	90                   	nop
  40b470:	48 83 c0 01          	add    rax,0x1
  40b474:	49 39 c1             	cmp    r9,rax
  40b477:	74 57                	je     40b4d0 <tar_iter_next+0xf0>
		if (((char *)r)[i]) return 0;
  40b479:	80 38 00             	cmp    BYTE PTR [rax],0x0
  40b47c:	74 f2                	je     40b470 <tar_iter_next+0x90>
  40b47e:	4c 89 e0             	mov    rax,r12
  40b481:	eb 12                	jmp    40b495 <tar_iter_next+0xb5>
  40b483:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40b488:	48 83 c0 01          	add    rax,0x1
  40b48c:	4c 39 e8             	cmp    rax,r13
  40b48f:	0f 84 7c 00 00 00    	je     40b511 <tar_iter_next+0x131>
		if (((char *)r)[i]) return 0;
  40b495:	80 38 00             	cmp    BYTE PTR [rax],0x0
  40b498:	74 ee                	je     40b488 <tar_iter_next+0xa8>
	if (ent->nesting_lvl == 0) {
  40b49a:	41 8b 06             	mov    eax,DWORD PTR [r14]
--
  40b4a9:	89 45 b4             	mov    DWORD PTR [rbp-0x4c],eax
	end = strchr(key, '/');
  40b4ac:	e8 6f a3 00 00       	call   415820 <strchr>
	if (ent->nesting_lvl == 0) {
  40b4b1:	8b 55 b4             	mov    edx,DWORD PTR [rbp-0x4c]
  40b4b4:	4c 8b 4d c0          	mov    r9,QWORD PTR [rbp-0x40]
  40b4b8:	85 d2                	test   edx,edx
  40b4ba:	0f 85 65 01 00 00    	jne    40b625 <tar_iter_next+0x245>
	return !((cmp == 0) && (end == NULL || end[1] == '\0'));
  40b4c0:	48 85 c0             	test   rax,rax
  40b4c3:	74 0b                	je     40b4d0 <tar_iter_next+0xf0>
  40b4c5:	80 78 01 00          	cmp    BYTE PTR [rax+0x1],0x0
  40b4c9:	75 46                	jne    40b511 <tar_iter_next+0x131>
  40b4cb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40b4d0:	4c 89 f8             	mov    rax,r15
  40b4d3:	eb 0c                	jmp    40b4e1 <tar_iter_next+0x101>
  40b4d5:	0f 1f 00             	nop    DWORD PTR [rax]
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40b4d8:	48 83 c0 01          	add    rax,0x1
  40b4dc:	49 39 c1             	cmp    r9,rax
  40b4df:	74 0f                	je     40b4f0 <tar_iter_next+0x110>
		if (((char *)r)[i]) return 0;
  40b4e1:	80 38 00             	cmp    BYTE PTR [rax],0x0
  40b4e4:	74 f2                	je     40b4d8 <tar_iter_next+0xf8>
  40b4e6:	e9 9a 00 00 00       	jmp    40b585 <tar_iter_next+0x1a5>
  40b4eb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	if (!i || !tar_valid(&i->entry)) return 0;
--
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40b508:	48 83 c3 01          	add    rbx,0x1
  40b50c:	49 39 d9             	cmp    r9,rbx
  40b50f:	74 df                	je     40b4f0 <tar_iter_next+0x110>
		if (((char *)r)[i]) return 0;
  40b511:	80 3b 00             	cmp    BYTE PTR [rbx],0x0
  40b514:	74 f2                	je     40b508 <tar_iter_next+0x128>
	i = strnlen(oct, TAR_SZ) - 1;
  40b516:	49 8d 7f 7c          	lea    rdi,[r15+0x7c]
  40b51a:	be 0c 00 00 00       	mov    esi,0xc
  40b51f:	e8 ac a5 00 00       	call   415ad0 <strnlen>
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40b524:	31 ff                	xor    edi,edi
--
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40b52e:	48 63 d0             	movsxd rdx,eax
  40b531:	83 f8 ff             	cmp    eax,0xffffffff
  40b534:	75 21                	jne    40b557 <tar_iter_next+0x177>
  40b536:	eb 2c                	jmp    40b564 <tar_iter_next+0x184>
  40b538:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40b53f:	00 
--
  40b557:	41 0f b6 44 17 7c    	movzx  eax,BYTE PTR [r15+rdx*1+0x7c]
  40b55d:	83 e8 30             	sub    eax,0x30
  40b560:	3c 07                	cmp    al,0x7
  40b562:	76 dc                	jbe    40b540 <tar_iter_next+0x160>
  40b564:	b8 00 02 00 00       	mov    eax,0x200
	return &r[n_records + 1];
  40b569:	49 01 c7             	add    r15,rax
	for (r = *iter; r && !tar_end(r) && tar_pathcmp(path, r->name); r = tar_next_record(r)) ;
  40b56c:	e9 ef fe ff ff       	jmp    40b460 <tar_iter_next+0x80>
  40b571:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40b578:	48 83 c3 01          	add    rbx,0x1
  40b57c:	49 39 d9             	cmp    r9,rbx
  40b57f:	0f 84 45 01 00 00    	je     40b6ca <tar_iter_next+0x2ea>
		if (((char *)r)[i]) return 0;
  40b585:	80 3b 00             	cmp    BYTE PTR [rbx],0x0
  40b588:	74 ee                	je     40b578 <tar_iter_next+0x198>
	i = strnlen(oct, TAR_SZ) - 1;
  40b58a:	be 0c 00 00 00       	mov    esi,0xc
  40b58f:	49 8d 7f 7c          	lea    rdi,[r15+0x7c]
  40b593:	e8 38 a5 00 00       	call   415ad0 <strnlen>
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40b598:	31 f6                	xor    esi,esi
--
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40b5a2:	48 63 d0             	movsxd rdx,eax
  40b5a5:	83 f8 ff             	cmp    eax,0xffffffff
  40b5a8:	75 1d                	jne    40b5c7 <tar_iter_next+0x1e7>
  40b5aa:	eb 28                	jmp    40b5d4 <tar_iter_next+0x1f4>
  40b5ac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		tot = tot + (val * base);
--
  40b5c7:	41 0f b6 44 17 7c    	movzx  eax,BYTE PTR [r15+rdx*1+0x7c]
  40b5cd:	83 e8 30             	sub    eax,0x30
  40b5d0:	3c 07                	cmp    al,0x7
  40b5d2:	76 dc                	jbe    40b5b0 <tar_iter_next+0x1d0>
  40b5d4:	b8 00 02 00 00       	mov    eax,0x200
--
  40b612:	48 81 e7 00 fe ff ff 	and    rdi,0xfffffffffffffe00
  40b619:	48 8d 87 00 02 00 00 	lea    rax,[rdi+0x200]
  40b620:	e9 44 ff ff ff       	jmp    40b569 <tar_iter_next+0x189>
	for (i = 0 ; i < nesting_lvl ; i++) {
  40b625:	0f 8e a6 00 00 00    	jle    40b6d1 <tar_iter_next+0x2f1>
--
  40b638:	4c 89 4d c0          	mov    QWORD PTR [rbp-0x40],r9
  40b63c:	89 55 b8             	mov    DWORD PTR [rbp-0x48],edx
  40b63f:	e8 dc a1 00 00       	call   415820 <strchr>
		if (!key) return NULL;
  40b644:	4c 8b 4d c0          	mov    r9,QWORD PTR [rbp-0x40]
  40b648:	48 85 c0             	test   rax,rax
  40b64b:	0f 84 c0 fe ff ff    	je     40b511 <tar_iter_next+0x131>
	for (i = 0 ; i < nesting_lvl ; i++) {
  40b651:	8b 55 b8             	mov    edx,DWORD PTR [rbp-0x48]
--
	for (i = 0 ; i < nesting_lvl ; i++) {
  40b658:	83 c2 01             	add    edx,0x1
  40b65b:	39 55 b4             	cmp    DWORD PTR [rbp-0x4c],edx
  40b65e:	75 d0                	jne    40b630 <tar_iter_next+0x250>
	if (*key == '\0') return 1; /* if we have the actual directory, avoid it */
  40b660:	80 78 01 00          	cmp    BYTE PTR [rax+0x1],0x0
  40b664:	0f 84 a7 fe ff ff    	je     40b511 <tar_iter_next+0x131>
	len = (int)(key - path);
  40b66a:	4c 89 d2             	mov    rdx,r10
	cmp = strncmp(p, path, len);
  40b66d:	4c 89 fe             	mov    rsi,r15
  40b670:	4c 89 e7             	mov    rdi,r12
--
  40b67a:	4c 89 55 c0          	mov    QWORD PTR [rbp-0x40],r10
  40b67e:	48 63 d2             	movsxd rdx,edx
	cmp = strncmp(p, path, len);
  40b681:	e8 ca a3 00 00       	call   415a50 <strncmp>
	return !((cmp == 0) && (end == NULL || end[1] == '\0'));
  40b686:	4c 8b 55 c0          	mov    r10,QWORD PTR [rbp-0x40]
  40b68a:	4c 8b 4d b8          	mov    r9,QWORD PTR [rbp-0x48]
  40b68e:	85 c0                	test   eax,eax
  40b690:	0f 85 7b fe ff ff    	jne    40b511 <tar_iter_next+0x131>
	end = strchr(key, '/');
  40b696:	be 2f 00 00 00       	mov    esi,0x2f
  40b69b:	4c 89 d7             	mov    rdi,r10
  40b69e:	4c 89 4d c0          	mov    QWORD PTR [rbp-0x40],r9
  40b6a2:	e8 79 a1 00 00       	call   415820 <strchr>
  40b6a7:	4c 8b 4d c0          	mov    r9,QWORD PTR [rbp-0x40]
  40b6ab:	e9 10 fe ff ff       	jmp    40b4c0 <tar_iter_next+0xe0>
	n_records = round_up_to_pow2(sz, TAR_RECORD_SIZE) / TAR_RECORD_SIZE;
  40b6b0:	48 63 c6             	movsxd rax,esi
--
  40b6b9:	48 25 00 fe ff ff    	and    rax,0xfffffffffffffe00
  40b6bf:	48 05 00 02 00 00    	add    rax,0x200
  40b6c5:	e9 0f ff ff ff       	jmp    40b5d9 <tar_iter_next+0x1f9>
	if (tar_end(r)) return NULL;
  40b6ca:	31 c0                	xor    eax,eax
  40b6cc:	e9 0b ff ff ff       	jmp    40b5dc <tar_iter_next+0x1fc>
	if (*key == '\0') return 1; /* if we have the actual directory, avoid it */
  40b6d1:	41 80 3f 00          	cmp    BYTE PTR [r15],0x0
  40b6d5:	0f 85 e5 fd ff ff    	jne    40b4c0 <tar_iter_next+0xe0>
  40b6db:	e9 31 fe ff ff       	jmp    40b511 <tar_iter_next+0x131>

000000000040b6e0 <tar_iter>:
--
	return !(!ent || !ent->record || tar_end(ent->record));
  40b6ea:	4d 85 c0             	test   r8,r8
  40b6ed:	74 30                	je     40b71f <tar_iter+0x3f>
  40b6ef:	49 8b 70 08          	mov    rsi,QWORD PTR [r8+0x8]
  40b6f3:	48 85 f6             	test   rsi,rsi
  40b6f6:	74 27                	je     40b71f <tar_iter+0x3f>
  40b6f8:	48 89 f0             	mov    rax,rsi
  40b6fb:	48 8d 8e 00 04 00 00 	lea    rcx,[rsi+0x400]
  40b702:	eb 0d                	jmp    40b711 <tar_iter+0x31>
  40b704:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40b708:	48 83 c0 01          	add    rax,0x1
  40b70c:	48 39 c1             	cmp    rcx,rax
  40b70f:	74 0e                	je     40b71f <tar_iter+0x3f>
		if (((char *)r)[i]) return 0;
  40b711:	80 38 00             	cmp    BYTE PTR [rax],0x0
  40b714:	74 f2                	je     40b708 <tar_iter+0x28>
	if (!tar_valid(ent)) return 0;
	if (!tar_is_dir(ent->record)) return 0;
  40b716:	80 be 9c 00 00 00 35 	cmp    BYTE PTR [rsi+0x9c],0x35
  40b71d:	74 09                	je     40b728 <tar_iter+0x48>
	i->entry    = *ent;
	i->iter_rec = ent->record;
--
  40b73a:	48 89 47 10          	mov    QWORD PTR [rdi+0x10],rax
	return tar_iter_next(i, first);
  40b73e:	e9 9d fc ff ff       	jmp    40b3e0 <tar_iter_next>
  40b743:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40b74a:	00 00 00 00 
--
	return !(!ent || !ent->record || tar_end(ent->record));
  40b75e:	48 85 ff             	test   rdi,rdi
  40b761:	74 34                	je     40b797 <tar_len+0x47>
  40b763:	48 8b 4f 08          	mov    rcx,QWORD PTR [rdi+0x8]
  40b767:	48 85 c9             	test   rcx,rcx
  40b76a:	74 2b                	je     40b797 <tar_len+0x47>
  40b76c:	48 89 c8             	mov    rax,rcx
  40b76f:	48 8d 91 00 04 00 00 	lea    rdx,[rcx+0x400]
  40b776:	eb 11                	jmp    40b789 <tar_len+0x39>
  40b778:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40b77f:	00 
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40b780:	48 83 c0 01          	add    rax,0x1
  40b784:	48 39 d0             	cmp    rax,rdx
  40b787:	74 0e                	je     40b797 <tar_len+0x47>
		if (((char *)r)[i]) return 0;
  40b789:	80 38 00             	cmp    BYTE PTR [rax],0x0
  40b78c:	74 f2                	je     40b780 <tar_len+0x30>
	if (!tar_is_dir(ent->record)) return 0;
  40b78e:	80 b9 9c 00 00 00 35 	cmp    BYTE PTR [rcx+0x9c],0x35
  40b795:	74 0c                	je     40b7a3 <tar_len+0x53>
	int cont = 0, cnt = 0;
	struct tar_iter i;
--
  40b7b7:	83 45 d0 01          	add    DWORD PTR [rbp-0x30],0x1
	return tar_iter_next(i, first);
  40b7bb:	e8 20 fc ff ff       	call   40b3e0 <tar_iter_next>
	for (cont = tar_iter(start, &i, &entry); cont ; cont = tar_iter_next(&i, &entry)) {
  40b7c0:	85 c0                	test   eax,eax
  40b7c2:	74 d3                	je     40b797 <tar_len+0x47>
  40b7c4:	45 31 e4             	xor    r12d,r12d
  40b7c7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
--
  40b7d8:	41 83 c4 01          	add    r12d,0x1
	for (cont = tar_iter(start, &i, &entry); cont ; cont = tar_iter_next(&i, &entry)) {
  40b7dc:	e8 ff fb ff ff       	call   40b3e0 <tar_iter_next>
  40b7e1:	85 c0                	test   eax,eax
  40b7e3:	75 eb                	jne    40b7d0 <tar_len+0x80>
  40b7e5:	eb b3                	jmp    40b79a <tar_len+0x4a>
  40b7e7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40b7ee:	00 00 
--
  40b7f9:	ba 00 00 00 00       	mov    edx,0x0
  40b7fe:	48 2d 59 09 5a 00    	sub    rax,0x5a0959
  40b804:	48 3d ff 01 00 00    	cmp    rax,0x1ff
  40b80a:	b8 40 c0 45 00       	mov    eax,0x45c040
  40b80f:	48 0f 4e c2          	cmovle rax,rdx
--
  40b830:	48 89 e5             	mov    rbp,rsp
	(aep_fn)(aep_info->rcv, fn_data);
  40b833:	ff 50 20             	call   QWORD PTR [rax+0x20]
  40b836:	be 32 00 00 00       	mov    esi,0x32
  40b83b:	bf 20 d3 41 00       	mov    edi,0x41d320
  40b840:	e8 8b e8 ff ff       	call   40a0d0 <cos_print_str>
	assert(0);
  40b845:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	assert(defci);
  40b874:	48 85 ff             	test   rdi,rdi
  40b877:	74 04                	je     40b87d <cos_compinfo_get+0xd>
  40b879:	48 89 f8             	mov    rax,rdi
	return &(defci->ci);
--
  40b883:	bf 58 d3 41 00       	mov    edi,0x41d358
  40b888:	48 89 e5             	mov    rbp,rsp
  40b88b:	e8 40 e8 ff ff       	call   40a0d0 <cos_print_str>
	assert(defci);
  40b890:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	assert(defci);
  40b8a4:	48 85 ff             	test   rdi,rdi
  40b8a7:	74 08                	je     40b8b1 <cos_sched_aep_get+0x11>
	return &(defci->sched_aep[cos_cpuid()]);
  40b8a9:	48 8d 87 e0 00 00 00 	lea    rax,[rdi+0xe0]
--
  40b8b7:	bf 90 d3 41 00       	mov    edi,0x41d390
  40b8bc:	48 89 e5             	mov    rbp,rsp
  40b8bf:	e8 0c e8 ff ff       	call   40a0d0 <cos_print_str>
	assert(defci);
  40b8c4:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40b8ea:	48 89 e5             	mov    rbp,rsp
	capid_t cap_frontier = atol(args_get("captbl_end"));
  40b8ed:	e8 0e f8 ff ff       	call   40b100 <args_get>
  40b8f2:	48 89 c7             	mov    rdi,rax
  40b8f5:	e8 66 9e 00 00       	call   415760 <atol>

	assert(cap_frontier > 0);
  40b8fa:	48 85 c0             	test   rax,rax
  40b8fd:	0f 84 91 00 00 00    	je     40b994 <cos_defcompinfo_init+0xb4>
	if (curr_defci_init_status == INITIALIZED) return;
  40b903:	83 3d 66 51 19 00 01 	cmp    DWORD PTR [rip+0x195166],0x1        # 5a0a70 <curr_defci_init_status>
  40b90a:	0f 84 82 00 00 00    	je     40b992 <cos_defcompinfo_init+0xb2>
	struct cos_defcompinfo *defci = cos_defcompinfo_curr_get();
	struct cos_compinfo    *ci    = cos_compinfo_get(defci);
--
  40b92d:	be 08 00 00 00       	mov    esi,0x8
  40b932:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40b937:	e8 e4 1d 00 00       	call   40d720 <cos_compinfo_init>
	struct cos_compinfo    *ci        = cos_compinfo_get(defci);
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);
--
  40b97b:	0f 29 05 be 50 19 00 	movaps XMMWORD PTR [rip+0x1950be],xmm0        # 5a0a40 <curr_defci+0xe0>
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40b982:	e8 b9 61 00 00       	call   411b40 <cos_introspect>
  40b987:	48 98                	cdqe   
  40b989:	48 89 05 c0 50 19 00 	mov    QWORD PTR [rip+0x1950c0],rax        # 5a0a50 <curr_defci+0xf0>
--
  40b994:	be 30 00 00 00       	mov    esi,0x30
  40b999:	bf d0 d3 41 00       	mov    edi,0x41d3d0
  40b99e:	e8 2d e7 ff ff       	call   40a0d0 <cos_print_str>
	assert(cap_frontier > 0);
  40b9a3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40b9cc:	48 83 ec 10          	sub    rsp,0x10
	if (curr_defci_init_status == INITIALIZED) return;
  40b9d0:	83 3d 99 50 19 00 01 	cmp    DWORD PTR [rip+0x195099],0x1        # 5a0a70 <curr_defci_init_status>
  40b9d7:	0f 29 45 e0          	movaps XMMWORD PTR [rbp-0x20],xmm0
  40b9db:	74 74                	je     40ba51 <cos_defcompinfo_init_ext+0xa1>
	cos_compinfo_init(ci, pgtbl_cap, captbl_cap, comp_cap, heap_ptr, cap_frontier, ci);
  40b9dd:	48 83 ec 08          	sub    rsp,0x8
--
  40b9f6:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40b9fb:	4c 8b 45 10          	mov    r8,QWORD PTR [rbp+0x10]
  40b9ff:	e8 1c 1d 00 00       	call   40d720 <cos_compinfo_init>
	sched_aep->tc   = sched_tc;
  40ba04:	66 0f 6f 45 e0       	movdqa xmm0,XMMWORD PTR [rbp-0x20]
--
  40ba3a:	0f 29 05 ff 4f 19 00 	movaps XMMWORD PTR [rip+0x194fff],xmm0        # 5a0a40 <curr_defci+0xe0>
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40ba41:	e8 fa 60 00 00       	call   411b40 <cos_introspect>
  40ba46:	48 98                	cdqe   
  40ba48:	48 89 05 01 50 19 00 	mov    QWORD PTR [rip+0x195001],rax        # 5a0a50 <curr_defci+0xf0>
--
  40ba6a:	66 48 0f 6e ce       	movq   xmm1,rsi
	assert(curr_defci_init_status == INITIALIZED);
  40ba6f:	83 3d fa 4f 19 00 01 	cmp    DWORD PTR [rip+0x194ffa],0x1        # 5a0a70 <curr_defci_init_status>
  40ba76:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
{
  40ba7a:	48 89 e5             	mov    rbp,rsp
	assert(curr_defci_init_status == INITIALIZED);
  40ba7d:	75 3b                	jne    40baba <cos_defcompinfo_sched_init_ext+0x5a>
	sched_aep->rcv  = sched_rcv;
  40ba7f:	48 89 15 d2 4f 19 00 	mov    QWORD PTR [rip+0x194fd2],rdx        # 5a0a58 <curr_defci+0xf8>
--
  40baa3:	0f 29 05 96 4f 19 00 	movaps XMMWORD PTR [rip+0x194f96],xmm0        # 5a0a40 <curr_defci+0xe0>
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40baaa:	e8 91 60 00 00       	call   411b40 <cos_introspect>
}
  40baaf:	5d                   	pop    rbp
--
  40baba:	be 30 00 00 00       	mov    esi,0x30
  40babf:	bf 08 d4 41 00       	mov    edi,0x41d408
  40bac4:	e8 07 e6 ff ff       	call   40a0d0 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40bac9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40bae4:	55                   	push   rbp
	assert(curr_defci_init_status == INITIALIZED);
  40bae5:	83 3d 84 4f 19 00 01 	cmp    DWORD PTR [rip+0x194f84],0x1        # 5a0a70 <curr_defci_init_status>
{
  40baec:	48 89 e5             	mov    rbp,rsp
	assert(curr_defci_init_status == INITIALIZED);
  40baef:	75 4c                	jne    40bb3d <cos_defcompinfo_sched_init+0x5d>
	sched_aep->tc   = sched_tc;
  40baf1:	66 0f 6f 05 b7 1b 01 	movdqa xmm0,XMMWORD PTR [rip+0x11bb7]        # 41d6b0 <__unlock+0x1580>
--
  40bb26:	0f 29 05 13 4f 19 00 	movaps XMMWORD PTR [rip+0x194f13],xmm0        # 5a0a40 <curr_defci+0xe0>
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40bb2d:	e8 0e 60 00 00       	call   411b40 <cos_introspect>

	cos_defcompinfo_sched_init_ext(BOOT_CAPTBL_SELF_INITTCAP_CPU_BASE, BOOT_CAPTBL_SELF_INITTHD_CPU_BASE,
--
  40bb3d:	be 30 00 00 00       	mov    esi,0x30
  40bb42:	bf 40 d4 41 00       	mov    edi,0x41d440
  40bb47:	e8 84 e5 ff ff       	call   40a0d0 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40bb4c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	assert(defci);
  40bb71:	48 85 ff             	test   rdi,rdi
  40bb74:	0f 84 18 01 00 00    	je     40bc92 <cos_defcompinfo_child_alloc+0x132>
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);
	struct cos_compinfo    *ci        = cos_compinfo_get(defci);
--

	assert(curr_defci_init_status == INITIALIZED);
  40bb7a:	83 3d ef 4e 19 00 01 	cmp    DWORD PTR [rip+0x194eef],0x1        # 5a0a70 <curr_defci_init_status>
  40bb81:	0f 85 27 01 00 00    	jne    40bcae <cos_defcompinfo_child_alloc+0x14e>
  40bb87:	49 89 f2             	mov    r10,rsi
  40bb8a:	45 89 c5             	mov    r13d,r8d
--
  40bb9c:	4c 89 d1             	mov    rcx,r10
  40bb9f:	48 89 fb             	mov    rbx,rdi
  40bba2:	e8 99 4b 00 00       	call   410740 <cos_compinfo_alloc>
  40bba7:	41 89 c4             	mov    r12d,eax
	if (ret) return ret;
  40bbaa:	85 c0                	test   eax,eax
  40bbac:	0f 85 d2 00 00 00    	jne    40bc84 <cos_defcompinfo_child_alloc+0x124>
	ret = cos_aep_alloc_intern(child_aep, child_defci, 0, is_sched ? sched_aep : NULL, NULL, NULL, 0);
  40bbb2:	45 85 ed             	test   r13d,r13d
--
  40bbc0:	4c 0f 44 e8          	cmove  r13,rax
	assert(curr_defci_init_status == INITIALIZED);
  40bbc4:	83 3d a5 4e 19 00 01 	cmp    DWORD PTR [rip+0x194ea5],0x1        # 5a0a70 <curr_defci_init_status>
  40bbcb:	0f 85 f9 00 00 00    	jne    40bcca <cos_defcompinfo_child_alloc+0x16a>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40bbd1:	66 0f ef c0          	pxor   xmm0,xmm0
--
  40bbec:	0f 11 83 00 01 00 00 	movups XMMWORD PTR [rbx+0x100],xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40bbf3:	e8 d8 3b 00 00       	call   40f7d0 <cos_initthd_alloc>
  40bbf8:	48 89 83 e8 00 00 00 	mov    QWORD PTR [rbx+0xe8],rax
  40bbff:	48 89 c6             	mov    rsi,rax
	assert(aep->thd);
  40bc02:	48 85 c0             	test   rax,rax
  40bc05:	0f 84 db 00 00 00    	je     40bce6 <cos_defcompinfo_child_alloc+0x186>
	aep->tid  = cos_introspect(ci, aep->thd, THD_GET_TID);
  40bc0b:	31 d2                	xor    edx,edx
  40bc0d:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40bc12:	e8 29 5f 00 00       	call   411b40 <cos_introspect>
  40bc17:	48 98                	cdqe   
  40bc19:	48 89 83 f0 00 00 00 	mov    QWORD PTR [rbx+0xf0],rax
	if (!sched && is_init) return 0;
  40bc20:	4d 85 ed             	test   r13,r13
  40bc23:	74 5f                	je     40bc84 <cos_defcompinfo_child_alloc+0x124>
		aep->tc = cos_tcap_alloc(ci);
  40bc25:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40bc2a:	e8 71 5f 00 00       	call   411ba0 <cos_tcap_alloc>
  40bc2f:	48 89 83 e0 00 00 00 	mov    QWORD PTR [rbx+0xe0],rax
  40bc36:	48 89 c2             	mov    rdx,rax
		assert(aep->tc);
  40bc39:	48 85 c0             	test   rax,rax
  40bc3c:	0f 84 c0 00 00 00    	je     40bd02 <cos_defcompinfo_child_alloc+0x1a2>
	aep->rcv  = cos_arcv_alloc(ci, aep->thd, aep->tc, ci->comp_cap, sched->rcv);
  40bc42:	48 8b b3 e8 00 00 00 	mov    rsi,QWORD PTR [rbx+0xe8]
--
  40bc4d:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40bc52:	48 8b 0d 17 4d 19 00 	mov    rcx,QWORD PTR [rip+0x194d17]        # 5a0970 <curr_defci+0x10>
  40bc59:	e8 52 4e 00 00       	call   410ab0 <cos_arcv_alloc>
  40bc5e:	48 89 83 f8 00 00 00 	mov    QWORD PTR [rbx+0xf8],rax
	assert(aep->rcv);
  40bc65:	48 85 c0             	test   rax,rax
  40bc68:	0f 84 b0 00 00 00    	je     40bd1e <cos_defcompinfo_child_alloc+0x1be>
	aep->fn   = fn;
  40bc6e:	48 c7 83 00 01 00 00 	mov    QWORD PTR [rbx+0x100],0x0
--
  40bc92:	be 30 00 00 00       	mov    esi,0x30
  40bc97:	bf 58 d3 41 00       	mov    edi,0x41d358
  40bc9c:	e8 2f e4 ff ff       	call   40a0d0 <cos_print_str>
	assert(defci);
  40bca1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40bcae:	be 31 00 00 00       	mov    esi,0x31
  40bcb3:	bf 78 d4 41 00       	mov    edi,0x41d478
  40bcb8:	e8 13 e4 ff ff       	call   40a0d0 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40bcbd:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40bcca:	be 31 00 00 00       	mov    esi,0x31
  40bccf:	bf b0 d4 41 00       	mov    edi,0x41d4b0
  40bcd4:	e8 f7 e3 ff ff       	call   40a0d0 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40bcd9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40bce6:	be 31 00 00 00       	mov    esi,0x31
  40bceb:	bf e8 d4 41 00       	mov    edi,0x41d4e8
  40bcf0:	e8 db e3 ff ff       	call   40a0d0 <cos_print_str>
	assert(aep->thd);
  40bcf5:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40bd02:	be 31 00 00 00       	mov    esi,0x31
  40bd07:	bf 20 d5 41 00       	mov    edi,0x41d520
  40bd0c:	e8 bf e3 ff ff       	call   40a0d0 <cos_print_str>
		assert(aep->tc);
  40bd11:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40bd1e:	be 31 00 00 00       	mov    esi,0x31
  40bd23:	bf 58 d5 41 00       	mov    edi,0x41d558
  40bd28:	e8 a3 e3 ff ff       	call   40a0d0 <cos_print_str>
	assert(aep->rcv);
  40bd2d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40bd40:	f3 0f 1e fa          	endbr64 
	assert(child_defci != cos_defcompinfo_curr_get());
  40bd44:	48 81 ff 60 09 5a 00 	cmp    rdi,0x5a0960
  40bd4b:	74 04                	je     40bd51 <cos_defcompinfo_childid_init+0x11>

	child_defci->id = c;
--
  40bd57:	bf 90 d5 41 00       	mov    edi,0x41d590
  40bd5c:	48 89 e5             	mov    rbp,rsp
  40bd5f:	e8 6c e3 ff ff       	call   40a0d0 <cos_print_str>
	assert(child_defci != cos_defcompinfo_curr_get());
  40bd64:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	assert(defci);
  40bd8b:	48 85 ff             	test   rdi,rdi
  40bd8e:	0f 84 f0 00 00 00    	je     40be84 <cos_initaep_alloc+0x104>
  40bd94:	48 89 fb             	mov    rbx,rdi
	return &(defci->sched_aep[cos_cpuid()]);
--
  40bd9e:	45 31 e4             	xor    r12d,r12d
  40bda1:	85 d2                	test   edx,edx
  40bda3:	0f 85 c7 00 00 00    	jne    40be70 <cos_initaep_alloc+0xf0>
	assert(curr_defci_init_status == INITIALIZED);
  40bda9:	83 3d c0 4c 19 00 01 	cmp    DWORD PTR [rip+0x194cc0],0x1        # 5a0a70 <curr_defci_init_status>
  40bdb0:	0f 85 ea 00 00 00    	jne    40bea0 <cos_initaep_alloc+0x120>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40bdb6:	66 0f ef c0          	pxor   xmm0,xmm0
--
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40bdce:	48 8b 73 10          	mov    rsi,QWORD PTR [rbx+0x10]
  40bdd2:	e8 f9 39 00 00       	call   40f7d0 <cos_initthd_alloc>
  40bdd7:	48 89 83 e8 00 00 00 	mov    QWORD PTR [rbx+0xe8],rax
  40bdde:	48 89 c6             	mov    rsi,rax
	assert(aep->thd);
  40bde1:	48 85 c0             	test   rax,rax
  40bde4:	0f 84 d2 00 00 00    	je     40bebc <cos_initaep_alloc+0x13c>
	aep->tid  = cos_introspect(ci, aep->thd, THD_GET_TID);
  40bdea:	31 d2                	xor    edx,edx
  40bdec:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40bdf1:	e8 4a 5d 00 00       	call   411b40 <cos_introspect>
  40bdf6:	48 98                	cdqe   
  40bdf8:	48 89 83 f0 00 00 00 	mov    QWORD PTR [rbx+0xf0],rax
	if (!sched && is_init) return 0;
  40bdff:	4d 85 e4             	test   r12,r12
  40be02:	74 60                	je     40be64 <cos_initaep_alloc+0xe4>
		aep->tc = cos_tcap_alloc(ci);
  40be04:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40be09:	e8 92 5d 00 00       	call   411ba0 <cos_tcap_alloc>
  40be0e:	48 89 83 e0 00 00 00 	mov    QWORD PTR [rbx+0xe0],rax
  40be15:	48 89 c2             	mov    rdx,rax
		assert(aep->tc);
  40be18:	48 85 c0             	test   rax,rax
  40be1b:	0f 84 b7 00 00 00    	je     40bed8 <cos_initaep_alloc+0x158>
	aep->rcv  = cos_arcv_alloc(ci, aep->thd, aep->tc, ci->comp_cap, sched->rcv);
  40be21:	48 8b b3 e8 00 00 00 	mov    rsi,QWORD PTR [rbx+0xe8]
--
  40be2d:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40be32:	48 8b 0d 37 4b 19 00 	mov    rcx,QWORD PTR [rip+0x194b37]        # 5a0970 <curr_defci+0x10>
  40be39:	e8 72 4c 00 00       	call   410ab0 <cos_arcv_alloc>
  40be3e:	48 89 83 f8 00 00 00 	mov    QWORD PTR [rbx+0xf8],rax
	assert(aep->rcv);
  40be45:	48 85 c0             	test   rax,rax
  40be48:	0f 84 a6 00 00 00    	je     40bef4 <cos_initaep_alloc+0x174>
	aep->fn   = fn;
  40be4e:	48 c7 83 00 01 00 00 	mov    QWORD PTR [rbx+0x100],0x0
--
  40be76:	ba 40 0a 5a 00       	mov    edx,0x5a0a40
  40be7b:	4c 0f 44 e2          	cmove  r12,rdx
  40be7f:	e9 25 ff ff ff       	jmp    40bda9 <cos_initaep_alloc+0x29>
  40be84:	be 30 00 00 00       	mov    esi,0x30
  40be89:	bf 90 d3 41 00       	mov    edi,0x41d390
  40be8e:	e8 3d e2 ff ff       	call   40a0d0 <cos_print_str>
	assert(defci);
  40be93:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40bea0:	be 31 00 00 00       	mov    esi,0x31
  40bea5:	bf b0 d4 41 00       	mov    edi,0x41d4b0
  40beaa:	e8 21 e2 ff ff       	call   40a0d0 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40beaf:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40bebc:	be 31 00 00 00       	mov    esi,0x31
  40bec1:	bf e8 d4 41 00       	mov    edi,0x41d4e8
  40bec6:	e8 05 e2 ff ff       	call   40a0d0 <cos_print_str>
	assert(aep->thd);
  40becb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40bed8:	be 31 00 00 00       	mov    esi,0x31
  40bedd:	bf 20 d5 41 00       	mov    edi,0x41d520
  40bee2:	e8 e9 e1 ff ff       	call   40a0d0 <cos_print_str>
		assert(aep->tc);
  40bee7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40bef4:	be 31 00 00 00       	mov    esi,0x31
  40bef9:	bf 58 d5 41 00       	mov    edi,0x41d558
  40befe:	e8 cd e1 ff ff       	call   40a0d0 <cos_print_str>
	assert(aep->rcv);
  40bf03:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	assert(defci);
  40bf21:	48 85 ff             	test   rdi,rdi
  40bf24:	0f 84 0b 01 00 00    	je     40c035 <cos_initaep_tcap_alloc+0x125>
	struct cos_defcompinfo *defci     = cos_defcompinfo_curr_get();
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);
--
  40bf38:	4c 0f 44 e2          	cmove  r12,rdx
	assert(curr_defci_init_status == INITIALIZED);
  40bf3c:	83 3d 2d 4b 19 00 01 	cmp    DWORD PTR [rip+0x194b2d],0x1        # 5a0a70 <curr_defci_init_status>
	return &(defci->sched_aep[cos_cpuid()]);
  40bf43:	48 8d 87 e0 00 00 00 	lea    rax,[rdi+0xe0]
	assert(curr_defci_init_status == INITIALIZED);
  40bf4a:	0f 85 01 01 00 00    	jne    40c051 <cos_initaep_tcap_alloc+0x141>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40bf50:	66 0f ef c0          	pxor   xmm0,xmm0
--
  40bf66:	48 8b 77 10          	mov    rsi,QWORD PTR [rdi+0x10]
  40bf6a:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40bf6f:	e8 5c 38 00 00       	call   40f7d0 <cos_initthd_alloc>
  40bf74:	48 89 83 e8 00 00 00 	mov    QWORD PTR [rbx+0xe8],rax
  40bf7b:	48 89 c6             	mov    rsi,rax
	assert(aep->thd);
  40bf7e:	48 85 c0             	test   rax,rax
  40bf81:	0f 84 e6 00 00 00    	je     40c06d <cos_initaep_tcap_alloc+0x15d>
	aep->tid  = cos_introspect(ci, aep->thd, THD_GET_TID);
  40bf87:	31 d2                	xor    edx,edx
  40bf89:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40bf8e:	e8 ad 5b 00 00       	call   411b40 <cos_introspect>
  40bf93:	48 98                	cdqe   
  40bf95:	48 89 83 f0 00 00 00 	mov    QWORD PTR [rbx+0xf0],rax
	if (tc) {
  40bf9c:	4d 85 ed             	test   r13,r13
  40bf9f:	74 5f                	je     40c000 <cos_initaep_tcap_alloc+0xf0>
		aep->tc = tc;
  40bfa1:	4c 89 ab e0 00 00 00 	mov    QWORD PTR [rbx+0xe0],r13
--
  40bfb7:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40bfbc:	48 8b 0d ad 49 19 00 	mov    rcx,QWORD PTR [rip+0x1949ad]        # 5a0970 <curr_defci+0x10>
  40bfc3:	e8 e8 4a 00 00       	call   410ab0 <cos_arcv_alloc>
  40bfc8:	48 89 83 f8 00 00 00 	mov    QWORD PTR [rbx+0xf8],rax
	assert(aep->rcv);
  40bfcf:	48 85 c0             	test   rax,rax
  40bfd2:	0f 84 b1 00 00 00    	je     40c089 <cos_initaep_tcap_alloc+0x179>
	aep->fn   = fn;
  40bfd8:	48 c7 83 00 01 00 00 	mov    QWORD PTR [rbx+0x100],0x0
--
		aep->tc = cos_tcap_alloc(ci);
  40c000:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40c005:	e8 96 5b 00 00       	call   411ba0 <cos_tcap_alloc>
  40c00a:	48 89 83 e0 00 00 00 	mov    QWORD PTR [rbx+0xe0],rax
  40c011:	49 89 c5             	mov    r13,rax
		assert(aep->tc);
  40c014:	48 85 c0             	test   rax,rax
  40c017:	75 8f                	jne    40bfa8 <cos_initaep_tcap_alloc+0x98>
  40c019:	be 31 00 00 00       	mov    esi,0x31
  40c01e:	bf 20 d5 41 00       	mov    edi,0x41d520
  40c023:	e8 a8 e0 ff ff       	call   40a0d0 <cos_print_str>
  40c028:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c02f:	00 00 00 00 
--
  40c035:	be 30 00 00 00       	mov    esi,0x30
  40c03a:	bf 90 d3 41 00       	mov    edi,0x41d390
  40c03f:	e8 8c e0 ff ff       	call   40a0d0 <cos_print_str>
	assert(defci);
  40c044:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40c051:	be 31 00 00 00       	mov    esi,0x31
  40c056:	bf b0 d4 41 00       	mov    edi,0x41d4b0
  40c05b:	e8 70 e0 ff ff       	call   40a0d0 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40c060:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40c06d:	be 31 00 00 00       	mov    esi,0x31
  40c072:	bf e8 d4 41 00       	mov    edi,0x41d4e8
  40c077:	e8 54 e0 ff ff       	call   40a0d0 <cos_print_str>
	assert(aep->thd);
  40c07c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40c089:	be 31 00 00 00       	mov    esi,0x31
  40c08e:	bf 58 d5 41 00       	mov    edi,0x41d558
  40c093:	e8 38 e0 ff ff       	call   40a0d0 <cos_print_str>
	assert(aep->rcv);
  40c098:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	assert(aep && idx > 0);
  40c0bb:	48 85 ff             	test   rdi,rdi
  40c0be:	0f 84 ef 00 00 00    	je     40c1b3 <cos_aep_alloc_ext+0x103>
  40c0c4:	49 89 d4             	mov    r12,rdx
  40c0c7:	89 ca                	mov    edx,ecx
--
	if (!sched) sched_aep = cos_sched_aep_get(dst_dci);
  40c0d4:	4d 85 e4             	test   r12,r12
  40c0d7:	74 27                	je     40c100 <cos_aep_alloc_ext+0x50>
	assert(defci);
  40c0d9:	48 85 f6             	test   rsi,rsi
  40c0dc:	75 32                	jne    40c110 <cos_aep_alloc_ext+0x60>
  40c0de:	be 30 00 00 00       	mov    esi,0x30
  40c0e3:	bf 58 d3 41 00       	mov    edi,0x41d358
  40c0e8:	e8 e3 df ff ff       	call   40a0d0 <cos_print_str>
  40c0ed:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c0f4:	00 00 00 00 
--
	assert(defci);
  40c107:	48 85 f6             	test   rsi,rsi
  40c10a:	0f 84 18 01 00 00    	je     40c228 <cos_aep_alloc_ext+0x178>
	assert(curr_defci_init_status == INITIALIZED);
  40c110:	83 3d 59 49 19 00 01 	cmp    DWORD PTR [rip+0x194959],0x1        # 5a0a70 <curr_defci_init_status>
  40c117:	0f 85 b3 00 00 00    	jne    40c1d0 <cos_aep_alloc_ext+0x120>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c11d:	66 0f ef c0          	pxor   xmm0,xmm0
--
	else if (idx > 0) aep->thd = cos_thd_alloc_ext(ci, dst_ci->comp_cap, idx);
  40c131:	48 8b 76 10          	mov    rsi,QWORD PTR [rsi+0x10]
  40c135:	e8 b6 29 00 00       	call   40eaf0 <cos_thd_alloc_ext>
  40c13a:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  40c13e:	48 89 c6             	mov    rsi,rax
	assert(aep->thd);
  40c141:	48 85 c0             	test   rax,rax
  40c144:	0f 84 a6 00 00 00    	je     40c1f0 <cos_aep_alloc_ext+0x140>
	aep->tid  = cos_introspect(ci, aep->thd, THD_GET_TID);
  40c14a:	31 d2                	xor    edx,edx
  40c14c:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40c151:	e8 ea 59 00 00       	call   411b40 <cos_introspect>
		aep->tc = cos_tcap_alloc(ci);
  40c156:	bf 60 09 5a 00       	mov    edi,0x5a0960
--
  40c15d:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
		aep->tc = cos_tcap_alloc(ci);
  40c161:	e8 3a 5a 00 00       	call   411ba0 <cos_tcap_alloc>
  40c166:	48 89 03             	mov    QWORD PTR [rbx],rax
  40c169:	48 89 c2             	mov    rdx,rax
		assert(aep->tc);
  40c16c:	48 85 c0             	test   rax,rax
  40c16f:	0f 84 97 00 00 00    	je     40c20c <cos_aep_alloc_ext+0x15c>
	aep->rcv  = cos_arcv_alloc(ci, aep->thd, aep->tc, ci->comp_cap, sched->rcv);
  40c175:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
--
  40c17e:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40c183:	48 8b 0d e6 47 19 00 	mov    rcx,QWORD PTR [rip+0x1947e6]        # 5a0970 <curr_defci+0x10>
  40c18a:	e8 21 49 00 00       	call   410ab0 <cos_arcv_alloc>
  40c18f:	48 89 43 18          	mov    QWORD PTR [rbx+0x18],rax
	assert(aep->rcv);
  40c193:	48 85 c0             	test   rax,rax
  40c196:	0f 84 a8 00 00 00    	je     40c244 <cos_aep_alloc_ext+0x194>
	aep->fn   = fn;
  40c19c:	48 c7 43 20 00 00 00 	mov    QWORD PTR [rbx+0x20],0x0
--
  40c1b3:	be 31 00 00 00       	mov    esi,0x31
  40c1b8:	bf c8 d5 41 00       	mov    edi,0x41d5c8
  40c1bd:	e8 0e df ff ff       	call   40a0d0 <cos_print_str>
	assert(aep && idx > 0);
  40c1c2:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40c1d0:	be 31 00 00 00       	mov    esi,0x31
  40c1d5:	bf b0 d4 41 00       	mov    edi,0x41d4b0
  40c1da:	e8 f1 de ff ff       	call   40a0d0 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40c1df:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40c1f0:	be 31 00 00 00       	mov    esi,0x31
  40c1f5:	bf e8 d4 41 00       	mov    edi,0x41d4e8
  40c1fa:	e8 d1 de ff ff       	call   40a0d0 <cos_print_str>
	assert(aep->thd);
  40c1ff:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40c20c:	be 31 00 00 00       	mov    esi,0x31
  40c211:	bf 20 d5 41 00       	mov    edi,0x41d520
  40c216:	e8 b5 de ff ff       	call   40a0d0 <cos_print_str>
		assert(aep->tc);
  40c21b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40c228:	be 30 00 00 00       	mov    esi,0x30
  40c22d:	bf 90 d3 41 00       	mov    edi,0x41d390
  40c232:	e8 99 de ff ff       	call   40a0d0 <cos_print_str>
	assert(defci);
  40c237:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40c244:	be 31 00 00 00       	mov    esi,0x31
  40c249:	bf 58 d5 41 00       	mov    edi,0x41d558
  40c24e:	e8 7d de ff ff       	call   40a0d0 <cos_print_str>
	assert(aep->rcv);
  40c253:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	assert(aep);
  40c271:	48 85 ff             	test   rdi,rdi
  40c274:	0f 84 2b 01 00 00    	je     40c3a5 <cos_aep_tcap_alloc_ext+0x145>
	assert(idx > 0);
  40c27a:	45 85 c0             	test   r8d,r8d
--
	if (!sched) sched_aep = cos_sched_aep_get(dst_dci);
  40c28c:	48 85 d2             	test   rdx,rdx
  40c28f:	0f 84 ab 00 00 00    	je     40c340 <cos_aep_tcap_alloc_ext+0xe0>
	assert(defci);
  40c295:	48 85 f6             	test   rsi,rsi
  40c298:	0f 84 3f 01 00 00    	je     40c3dd <cos_aep_tcap_alloc_ext+0x17d>
	assert(curr_defci_init_status == INITIALIZED);
  40c29e:	83 3d cb 47 19 00 01 	cmp    DWORD PTR [rip+0x1947cb],0x1        # 5a0a70 <curr_defci_init_status>
  40c2a5:	0f 85 4e 01 00 00    	jne    40c3f9 <cos_aep_tcap_alloc_ext+0x199>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c2ab:	66 0f ef c0          	pxor   xmm0,xmm0
--
	else if (idx > 0) aep->thd = cos_thd_alloc_ext(ci, dst_ci->comp_cap, idx);
  40c2c2:	48 8b 76 10          	mov    rsi,QWORD PTR [rsi+0x10]
  40c2c6:	e8 25 28 00 00       	call   40eaf0 <cos_thd_alloc_ext>
  40c2cb:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  40c2cf:	48 89 c6             	mov    rsi,rax
	assert(aep->thd);
  40c2d2:	48 85 c0             	test   rax,rax
  40c2d5:	0f 84 3a 01 00 00    	je     40c415 <cos_aep_tcap_alloc_ext+0x1b5>
	aep->tid  = cos_introspect(ci, aep->thd, THD_GET_TID);
  40c2db:	31 d2                	xor    edx,edx
  40c2dd:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40c2e2:	e8 59 58 00 00       	call   411b40 <cos_introspect>
  40c2e7:	48 98                	cdqe   
  40c2e9:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
	if (tc) {
  40c2ed:	4d 85 e4             	test   r12,r12
  40c2f0:	74 7e                	je     40c370 <cos_aep_tcap_alloc_ext+0x110>
		aep->tc = tc;
  40c2f2:	4c 89 23             	mov    QWORD PTR [rbx],r12
--
  40c300:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40c305:	48 8b 0d 64 46 19 00 	mov    rcx,QWORD PTR [rip+0x194664]        # 5a0970 <curr_defci+0x10>
  40c30c:	e8 9f 47 00 00       	call   410ab0 <cos_arcv_alloc>
  40c311:	48 89 43 18          	mov    QWORD PTR [rbx+0x18],rax
	assert(aep->rcv);
  40c315:	48 85 c0             	test   rax,rax
  40c318:	0f 84 13 01 00 00    	je     40c431 <cos_aep_tcap_alloc_ext+0x1d1>
	aep->fn   = fn;
  40c31e:	48 c7 43 20 00 00 00 	mov    QWORD PTR [rbx+0x20],0x0
--
	assert(defci);
  40c347:	48 85 f6             	test   rsi,rsi
  40c34a:	0f 85 4e ff ff ff    	jne    40c29e <cos_aep_tcap_alloc_ext+0x3e>
  40c350:	be 30 00 00 00       	mov    esi,0x30
  40c355:	bf 90 d3 41 00       	mov    edi,0x41d390
  40c35a:	e8 71 dd ff ff       	call   40a0d0 <cos_print_str>
  40c35f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c366:	00 00 00 00 
--
		aep->tc = cos_tcap_alloc(ci);
  40c370:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40c375:	e8 26 58 00 00       	call   411ba0 <cos_tcap_alloc>
  40c37a:	48 89 03             	mov    QWORD PTR [rbx],rax
  40c37d:	49 89 c4             	mov    r12,rax
		assert(aep->tc);
  40c380:	48 85 c0             	test   rax,rax
  40c383:	0f 85 6c ff ff ff    	jne    40c2f5 <cos_aep_tcap_alloc_ext+0x95>
  40c389:	be 31 00 00 00       	mov    esi,0x31
  40c38e:	bf 20 d5 41 00       	mov    edi,0x41d520
  40c393:	e8 38 dd ff ff       	call   40a0d0 <cos_print_str>
  40c398:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c39f:	00 00 00 00 
--
  40c3a5:	be 31 00 00 00       	mov    esi,0x31
  40c3aa:	bf 00 d6 41 00       	mov    edi,0x41d600
  40c3af:	e8 1c dd ff ff       	call   40a0d0 <cos_print_str>
	assert(aep);
  40c3b4:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40c3c1:	be 31 00 00 00       	mov    esi,0x31
  40c3c6:	bf 38 d6 41 00       	mov    edi,0x41d638
  40c3cb:	e8 00 dd ff ff       	call   40a0d0 <cos_print_str>
	assert(idx > 0);
  40c3d0:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40c3dd:	be 30 00 00 00       	mov    esi,0x30
  40c3e2:	bf 58 d3 41 00       	mov    edi,0x41d358
  40c3e7:	e8 e4 dc ff ff       	call   40a0d0 <cos_print_str>
	assert(defci);
  40c3ec:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40c3f9:	be 31 00 00 00       	mov    esi,0x31
  40c3fe:	bf b0 d4 41 00       	mov    edi,0x41d4b0
  40c403:	e8 c8 dc ff ff       	call   40a0d0 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40c408:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40c415:	be 31 00 00 00       	mov    esi,0x31
  40c41a:	bf e8 d4 41 00       	mov    edi,0x41d4e8
  40c41f:	e8 ac dc ff ff       	call   40a0d0 <cos_print_str>
	assert(aep->thd);
  40c424:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40c431:	be 31 00 00 00       	mov    esi,0x31
  40c436:	bf 58 d5 41 00       	mov    edi,0x41d558
  40c43b:	e8 90 dc ff ff       	call   40a0d0 <cos_print_str>
	assert(aep->rcv);
  40c440:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40c470:	8b 05 fa 45 19 00    	mov    eax,DWORD PTR [rip+0x1945fa]        # 5a0a70 <curr_defci_init_status>
	int                     is_init = (!fn && !data && !idx);
  40c476:	0f 85 a4 00 00 00    	jne    40c520 <cos_aep_alloc+0xd0>
	assert(curr_defci_init_status == INITIALIZED);
  40c47c:	83 f8 01             	cmp    eax,0x1
  40c47f:	0f 85 d3 00 00 00    	jne    40c558 <cos_aep_alloc+0x108>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c485:	66 0f ef c0          	pxor   xmm0,xmm0
--
  40c49c:	0f 11 43 20          	movups XMMWORD PTR [rbx+0x20],xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40c4a0:	e8 2b 33 00 00       	call   40f7d0 <cos_initthd_alloc>
  40c4a5:	48 89 c6             	mov    rsi,rax
  40c4a8:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
	assert(aep->thd);
  40c4ac:	48 85 f6             	test   rsi,rsi
  40c4af:	0f 84 bf 00 00 00    	je     40c574 <cos_aep_alloc+0x124>
	aep->tid  = cos_introspect(ci, aep->thd, THD_GET_TID);
  40c4b5:	31 d2                	xor    edx,edx
  40c4b7:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40c4bc:	e8 7f 56 00 00       	call   411b40 <cos_introspect>
		aep->tc = cos_tcap_alloc(ci);
  40c4c1:	bf 60 09 5a 00       	mov    edi,0x5a0960
--
  40c4c8:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
		aep->tc = cos_tcap_alloc(ci);
  40c4cc:	e8 cf 56 00 00       	call   411ba0 <cos_tcap_alloc>
  40c4d1:	48 89 03             	mov    QWORD PTR [rbx],rax
  40c4d4:	48 89 c2             	mov    rdx,rax
		assert(aep->tc);
  40c4d7:	48 85 c0             	test   rax,rax
  40c4da:	0f 84 b0 00 00 00    	je     40c590 <cos_aep_alloc+0x140>
	aep->rcv  = cos_arcv_alloc(ci, aep->thd, aep->tc, ci->comp_cap, sched->rcv);
  40c4e0:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
--
  40c4eb:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40c4f0:	48 8b 0d 79 44 19 00 	mov    rcx,QWORD PTR [rip+0x194479]        # 5a0970 <curr_defci+0x10>
  40c4f7:	e8 b4 45 00 00       	call   410ab0 <cos_arcv_alloc>
  40c4fc:	48 89 43 18          	mov    QWORD PTR [rbx+0x18],rax
	assert(aep->rcv);
  40c500:	48 85 c0             	test   rax,rax
  40c503:	0f 84 a3 00 00 00    	je     40c5ac <cos_aep_alloc+0x15c>
	aep->fn   = fn;
  40c509:	4c 89 63 20          	mov    QWORD PTR [rbx+0x20],r12
--
  40c51e:	66 90                	xchg   ax,ax
	assert(curr_defci_init_status == INITIALIZED);
  40c520:	83 f8 01             	cmp    eax,0x1
  40c523:	75 33                	jne    40c558 <cos_aep_alloc+0x108>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c525:	66 0f ef c0          	pxor   xmm0,xmm0
--
  40c544:	0f 11 43 20          	movups XMMWORD PTR [rbx+0x20],xmm0
	else              aep->thd = cos_thd_alloc(ci, dst_ci->comp_cap, cos_aepthd_fn, (void *)aep);
  40c548:	e8 d3 25 00 00       	call   40eb20 <cos_thd_alloc>
  40c54d:	48 89 c6             	mov    rsi,rax
  40c550:	e9 53 ff ff ff       	jmp    40c4a8 <cos_aep_alloc+0x58>
  40c555:	0f 1f 00             	nop    DWORD PTR [rax]
  40c558:	be 31 00 00 00       	mov    esi,0x31
  40c55d:	bf b0 d4 41 00       	mov    edi,0x41d4b0
  40c562:	e8 69 db ff ff       	call   40a0d0 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40c567:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40c574:	be 31 00 00 00       	mov    esi,0x31
  40c579:	bf e8 d4 41 00       	mov    edi,0x41d4e8
  40c57e:	e8 4d db ff ff       	call   40a0d0 <cos_print_str>
	assert(aep->thd);
  40c583:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40c590:	be 31 00 00 00       	mov    esi,0x31
  40c595:	bf 20 d5 41 00       	mov    edi,0x41d520
  40c59a:	e8 31 db ff ff       	call   40a0d0 <cos_print_str>
		assert(aep->tc);
  40c59f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40c5ac:	be 31 00 00 00       	mov    esi,0x31
  40c5b1:	bf 58 d5 41 00       	mov    edi,0x41d558
  40c5b6:	e8 15 db ff ff       	call   40a0d0 <cos_print_str>
	assert(aep->rcv);
  40c5bb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40c5f1:	48 89 fb             	mov    rbx,rdi
	int                     is_init = (!fn && !data && !idx);
  40c5f4:	0f 85 96 00 00 00    	jne    40c690 <cos_aep_tcap_alloc+0xc0>
	assert(curr_defci_init_status == INITIALIZED);
  40c5fa:	83 f8 01             	cmp    eax,0x1
  40c5fd:	0f 85 c5 00 00 00    	jne    40c6c8 <cos_aep_tcap_alloc+0xf8>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c603:	66 0f ef c0          	pxor   xmm0,xmm0
--
  40c61a:	0f 11 43 20          	movups XMMWORD PTR [rbx+0x20],xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40c61e:	e8 ad 31 00 00       	call   40f7d0 <cos_initthd_alloc>
  40c623:	48 89 c6             	mov    rsi,rax
  40c626:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
	assert(aep->thd);
  40c62a:	48 85 f6             	test   rsi,rsi
  40c62d:	0f 84 ea 00 00 00    	je     40c71d <cos_aep_tcap_alloc+0x14d>
	aep->tid  = cos_introspect(ci, aep->thd, THD_GET_TID);
  40c633:	31 d2                	xor    edx,edx
  40c635:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40c63a:	e8 01 55 00 00       	call   411b40 <cos_introspect>
  40c63f:	48 98                	cdqe   
  40c641:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
	if (tc) {
  40c645:	4d 85 e4             	test   r12,r12
  40c648:	0f 84 9a 00 00 00    	je     40c6e8 <cos_aep_tcap_alloc+0x118>
		aep->tc = tc;
  40c64e:	4c 89 23             	mov    QWORD PTR [rbx],r12
--
  40c65f:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40c664:	48 8b 0d 05 43 19 00 	mov    rcx,QWORD PTR [rip+0x194305]        # 5a0970 <curr_defci+0x10>
  40c66b:	e8 40 44 00 00       	call   410ab0 <cos_arcv_alloc>
  40c670:	48 89 43 18          	mov    QWORD PTR [rbx+0x18],rax
	assert(aep->rcv);
  40c674:	48 85 c0             	test   rax,rax
  40c677:	0f 84 bc 00 00 00    	je     40c739 <cos_aep_tcap_alloc+0x169>
	aep->fn   = fn;
  40c67d:	4c 89 6b 20          	mov    QWORD PTR [rbx+0x20],r13
--
  40c68f:	c3                   	ret    
	assert(curr_defci_init_status == INITIALIZED);
  40c690:	83 f8 01             	cmp    eax,0x1
  40c693:	75 33                	jne    40c6c8 <cos_aep_tcap_alloc+0xf8>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c695:	66 0f ef c0          	pxor   xmm0,xmm0
--
  40c6b4:	0f 11 43 20          	movups XMMWORD PTR [rbx+0x20],xmm0
	else              aep->thd = cos_thd_alloc(ci, dst_ci->comp_cap, cos_aepthd_fn, (void *)aep);
  40c6b8:	e8 63 24 00 00       	call   40eb20 <cos_thd_alloc>
  40c6bd:	48 89 c6             	mov    rsi,rax
  40c6c0:	e9 61 ff ff ff       	jmp    40c626 <cos_aep_tcap_alloc+0x56>
  40c6c5:	0f 1f 00             	nop    DWORD PTR [rax]
  40c6c8:	be 31 00 00 00       	mov    esi,0x31
  40c6cd:	bf b0 d4 41 00       	mov    edi,0x41d4b0
  40c6d2:	e8 f9 d9 ff ff       	call   40a0d0 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40c6d7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
		aep->tc = cos_tcap_alloc(ci);
  40c6e8:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40c6ed:	e8 ae 54 00 00       	call   411ba0 <cos_tcap_alloc>
  40c6f2:	48 89 03             	mov    QWORD PTR [rbx],rax
  40c6f5:	49 89 c4             	mov    r12,rax
		assert(aep->tc);
  40c6f8:	48 85 c0             	test   rax,rax
  40c6fb:	0f 85 50 ff ff ff    	jne    40c651 <cos_aep_tcap_alloc+0x81>
  40c701:	be 31 00 00 00       	mov    esi,0x31
  40c706:	bf 20 d5 41 00       	mov    edi,0x41d520
  40c70b:	e8 c0 d9 ff ff       	call   40a0d0 <cos_print_str>
  40c710:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c717:	00 00 00 00 
--
  40c71d:	be 31 00 00 00       	mov    esi,0x31
  40c722:	bf e8 d4 41 00       	mov    edi,0x41d4e8
  40c727:	e8 a4 d9 ff ff       	call   40a0d0 <cos_print_str>
	assert(aep->thd);
  40c72c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40c739:	be 31 00 00 00       	mov    esi,0x31
  40c73e:	bf 58 d5 41 00       	mov    edi,0x41d558
  40c743:	e8 88 d9 ff ff       	call   40a0d0 <cos_print_str>
	assert(aep->rcv);
  40c748:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--

	assert(curr_defci_init_status == INITIALIZED);
  40c764:	83 3d 05 43 19 00 01 	cmp    DWORD PTR [rip+0x194305],0x1        # 5a0a70 <curr_defci_init_status>
  40c76b:	75 1c                	jne    40c789 <cos_defswitch+0x29>
  40c76d:	41 89 c9             	mov    r9d,ecx

--
  40c77a:	48 89 f2             	mov    rdx,rsi
  40c77d:	48 8b 35 bc 42 19 00 	mov    rsi,QWORD PTR [rip+0x1942bc]        # 5a0a40 <curr_defci+0xe0>
  40c784:	e9 97 4b 00 00       	jmp    411320 <cos_switch>
{
  40c789:	55                   	push   rbp
--
  40c78f:	bf 70 d6 41 00       	mov    edi,0x41d670
  40c794:	48 89 e5             	mov    rbp,rsp
  40c797:	e8 34 d9 ff ff       	call   40a0d0 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40c79c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40c7d7:	4c 89 8d 78 ff ff ff 	mov    QWORD PTR [rbp-0x88],r9
  40c7de:	84 c0                	test   al,al
  40c7e0:	74 20                	je     40c802 <printc.constprop.0+0x52>
  40c7e2:	0f 29 45 80          	movaps XMMWORD PTR [rbp-0x80],xmm0
  40c7e6:	0f 29 4d 90          	movaps XMMWORD PTR [rbp-0x70],xmm1
--
  40c844:	00 00 00 
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40c847:	e8 14 8d 00 00       	call   415560 <vsnprintf>
	ret = cos_print_str(s, ret);
  40c84c:	48 8d bd 90 fe ff ff 	lea    rdi,[rbp-0x170]
--
  40c853:	89 c6                	mov    esi,eax
	ret = cos_print_str(s, ret);
  40c855:	e8 76 d8 ff ff       	call   40a0d0 <cos_print_str>
}
  40c85a:	c9                   	leave  
--
	assert(__ci);
  40c86d:	48 85 ff             	test   rdi,rdi
  40c870:	0f 84 2f 01 00 00    	je     40c9a5 <__mem_bump_alloc.constprop.0+0x145>
	return ci->memsrc;
  40c876:	4c 8b 57 60          	mov    r10,QWORD PTR [rdi+0x60]
--
	assert(ci && ci == __compinfo_metacap(__ci));
  40c888:	4d 85 d2             	test   r10,r10
  40c88b:	0f 84 30 01 00 00    	je     40c9c1 <__mem_bump_alloc.constprop.0+0x161>
  40c891:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  40c898:	48 89 c8             	mov    rax,rcx
  40c89b:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40c8a0:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40c8a3:	84 c0                	test   al,al
  40c8a5:	74 f1                	je     40c898 <__mem_bump_alloc.constprop.0+0x38>
        __asm__ __volatile__("lock " PS_FAA_STR
  40c8a7:	41 bd 00 10 00 00    	mov    r13d,0x1000
--
	if (ret >= *frontier || *frontier - ret > RETYPE_MEM_SIZE) {
  40c8b3:	49 8b 92 90 00 00 00 	mov    rdx,QWORD PTR [r10+0x90]
  40c8ba:	49 39 d5             	cmp    r13,rdx
  40c8bd:	0f 82 bd 00 00 00    	jb     40c980 <__mem_bump_alloc.constprop.0+0x120>
		vaddr_t ptr_tmp = *ptr, front_tmp = *frontier;
--
		if (ci->mi.untyped_ptr == ci->mi.untyped_frontier) goto error;
  40c8c7:	49 8b 9a 80 00 00 00 	mov    rbx,QWORD PTR [r10+0x80]
  40c8ce:	49 39 5a 68          	cmp    QWORD PTR [r10+0x68],rbx
  40c8d2:	0f 84 c8 00 00 00    	je     40c9a0 <__mem_bump_alloc.constprop.0+0x140>
  40c8d8:	41 bd 00 10 00 00    	mov    r13d,0x1000
  40c8de:	f0 4d 0f c1 6a 68    	lock xadd QWORD PTR [r10+0x68],r13
--
  40c8e4:	49 8d 8d 00 10 00 00 	lea    rcx,[r13+0x1000]
        __asm__ __volatile__("lock " PS_CAS_STR
  40c8eb:	f0 49 0f b1 4a 78    	lock cmpxchg QWORD PTR [r10+0x78],rcx
  40c8f1:	0f 94 c0             	sete   al
  40c8f4:	84 c0                	test   al,al
  40c8f6:	74 0f                	je     40c907 <__mem_bump_alloc.constprop.0+0xa7>
  40c8f8:	48 89 d0             	mov    rax,rdx
  40c8fb:	f0 49 0f b1 8a 90 00 	lock cmpxchg QWORD PTR [r10+0x90],rcx
  40c902:	00 00 
  40c904:	0f 94 c0             	sete   al
--
  40c907:	4c 89 ea             	mov    rdx,r13
  40c90a:	81 e2 ff 0f 00 00    	and    edx,0xfff
  40c910:	75 50                	jne    40c962 <__mem_bump_alloc.constprop.0+0x102>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40c912:	41 8b 82 98 00 00 00 	mov    eax,DWORD PTR [r10+0x98]
--
  40c938:	49 b8 50 c9 40 00 00 	movabs r8,0x40c950
  40c93f:	00 00 00 
  40c942:	0f 05                	syscall 
  40c944:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  40c948:	eb 0d                	jmp    40c957 <__mem_bump_alloc.constprop.0+0xf7>
  40c94a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40c950:	b9 00 00 00 00       	mov    ecx,0x0
  40c955:	eb 05                	jmp    40c95c <__mem_bump_alloc.constprop.0+0xfc>
  40c957:	b9 01 00 00 00       	mov    ecx,0x1
  40c95c:	5d                   	pop    rbp
  40c95d:	5c                   	pop    rsp
		/* are we dealing with a kernel memory allocation? */
		syscall_op_t op = km ? CAPTBL_OP_MEM_RETYPE2KERN : CAPTBL_OP_MEM_RETYPE2USER;
		if (call_cap_op(ci->mi.pgtbl_cap, op, ret, 0, 0, 0)) goto error;
  40c95e:	85 c0                	test   eax,eax
  40c960:	75 3e                	jne    40c9a0 <__mem_bump_alloc.constprop.0+0x140>
  40c962:	49 c7 82 b8 00 00 00 	mov    QWORD PTR [r10+0xb8],0x0
  40c969:	00 00 00 00 
--
  40c980:	48 89 d0             	mov    rax,rdx
  40c983:	4c 29 e8             	sub    rax,r13
  40c986:	48 3d 00 10 00 00    	cmp    rax,0x1000
  40c98c:	0f 86 75 ff ff ff    	jbe    40c907 <__mem_bump_alloc.constprop.0+0xa7>
  40c992:	e9 2c ff ff ff       	jmp    40c8c3 <__mem_bump_alloc.constprop.0+0x63>
  40c997:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40c99e:	00 00 
	return 0;
  40c9a0:	45 31 ed             	xor    r13d,r13d
  40c9a3:	eb bd                	jmp    40c962 <__mem_bump_alloc.constprop.0+0x102>
	return cos_print_str(s, strlen(s));
  40c9a5:	be 2e 00 00 00       	mov    esi,0x2e
  40c9aa:	bf d0 d6 41 00       	mov    edi,0x41d6d0
  40c9af:	e8 1c d7 ff ff       	call   40a0d0 <cos_print_str>
	assert(__ci);
  40c9b4:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40c9c1:	be 2e 00 00 00       	mov    esi,0x2e
  40c9c6:	bf 00 d7 41 00       	mov    edi,0x41d700
  40c9cb:	e8 00 d7 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci && ci == __compinfo_metacap(__ci));
  40c9d0:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	/* ensure that we have bounded structure, and bounded recursion */
	assert(__compinfo_metacap(meta) == meta);
  40c9f5:	4d 39 64 24 60       	cmp    QWORD PTR [r12+0x60],r12
  40c9fa:	75 32                	jne    40ca2e <__capid_captbl_check_expand+0x4e>
	 * rest of the entry (internal fragmentation WRT the captbl
	 * capability).  Oh well.
--
  40ca00:	49 89 fd             	mov    r13,rdi
	if (self_resources) {
  40ca03:	4c 39 e7             	cmp    rdi,r12
  40ca06:	74 20                	je     40ca28 <__capid_captbl_check_expand+0x48>
	} else {
		frontier = ps_load(&ci->caprange_frontier);
	}
	assert(ci->cap_frontier <= frontier);
  40ca08:	49 39 5d 18          	cmp    QWORD PTR [r13+0x18],rbx
  40ca0c:	77 3c                	ja     40ca4a <__capid_captbl_check_expand+0x6a>

	/* Common case: */
	if (likely(ci->cap_frontier != frontier)) return 0;
  40ca0e:	74 56                	je     40ca66 <__capid_captbl_check_expand+0x86>
	frontier       = ps_load(&ci->cap_frontier);
	range_frontier = ps_faa(&ci->caprange_frontier, CAPTBL_EXPAND_SZ * 2);
--
		frontier = ps_load(&ci->caprange_frontier) - CAPMAX_ENTRY_SZ;
  40ca28:	48 83 eb 04          	sub    rbx,0x4
  40ca2c:	eb da                	jmp    40ca08 <__capid_captbl_check_expand+0x28>
  40ca2e:	be 2e 00 00 00       	mov    esi,0x2e
  40ca33:	bf 30 d7 41 00       	mov    edi,0x41d730
  40ca38:	e8 93 d6 ff ff       	call   40a0d0 <cos_print_str>
	assert(__compinfo_metacap(meta) == meta);
  40ca3d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40ca4a:	be 2e 00 00 00       	mov    esi,0x2e
  40ca4f:	bf 60 d7 41 00       	mov    edi,0x41d760
  40ca54:	e8 77 d6 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci->cap_frontier <= frontier);
  40ca59:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	return __mem_bump_alloc(ci, 1, 1);
  40ca66:	4c 89 ef             	mov    rdi,r13
  40ca69:	e8 f2 fd ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40ca6e:	49 89 c6             	mov    r14,rax
	assert(kmem); /* FIXME: should have a failure semantics for capids */
  40ca71:	48 85 c0             	test   rax,rax
  40ca74:	0f 84 9f 01 00 00    	je     40cc19 <__capid_captbl_check_expand+0x239>
	if (self_resources) {
  40ca7a:	4d 39 e5             	cmp    r13,r12
  40ca7d:	74 69                	je     40cae8 <__capid_captbl_check_expand+0x108>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40ca7f:	49 8d 94 24 b0 00 00 	lea    rdx,[r12+0xb0]
--
  40ca8e:	66 90                	xchg   ax,ax
  40ca90:	48 89 c8             	mov    rax,rcx
  40ca93:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40ca98:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40ca9b:	84 c0                	test   al,al
  40ca9d:	74 f1                	je     40ca90 <__capid_captbl_check_expand+0xb0>
	ps_lock_take(&ci->cap_lock);
	/*
--
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40ca9f:	41 f6 44 24 38 03    	test   BYTE PTR [r12+0x38],0x3
  40caa5:	0f 84 4c 01 00 00    	je     40cbf7 <__capid_captbl_check_expand+0x217>
        __asm__ __volatile__("lock " PS_FAA_STR
  40caab:	bb 04 00 00 00       	mov    ebx,0x4
--
		assert(captblcap);
  40cac3:	48 85 db             	test   rbx,rbx
  40cac6:	75 20                	jne    40cae8 <__capid_captbl_check_expand+0x108>
  40cac8:	be 2e 00 00 00       	mov    esi,0x2e
  40cacd:	bf c0 d7 41 00       	mov    edi,0x41d7c0
  40cad2:	e8 f9 d5 ff ff       	call   40a0d0 <cos_print_str>
  40cad7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40cade:	00 00 00 00 
--
  40caef:	83 e0 7f             	and    eax,0x7f
  40caf2:	48 89 45 b8          	mov    QWORD PTR [rbp-0x48],rax
  40caf6:	0f 85 39 01 00 00    	jne    40cc35 <__capid_captbl_check_expand+0x255>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40cafc:	41 8b 44 24 08       	mov    eax,DWORD PTR [r12+0x8]
--
  40cb2a:	49 b8 40 cb 40 00 00 	movabs r8,0x40cb40
  40cb31:	00 00 00 
  40cb34:	0f 05                	syscall 
  40cb36:	66 90                	xchg   ax,ax
  40cb38:	eb 0d                	jmp    40cb47 <__capid_captbl_check_expand+0x167>
  40cb3a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40cb40:	b9 00 00 00 00       	mov    ecx,0x0
  40cb45:	eb 05                	jmp    40cb4c <__capid_captbl_check_expand+0x16c>
  40cb47:	b9 01 00 00 00       	mov    ecx,0x1
  40cb4c:	5d                   	pop    rbp
  40cb4d:	5c                   	pop    rsp
	if (call_cap_op(meta->captbl_cap, CAPTBL_OP_CAPTBLACTIVATE, captblcap, meta->mi.pgtbl_cap, kmem, 1)) {
  40cb4e:	85 c0                	test   eax,eax
  40cb50:	75 6d                	jne    40cbbf <__capid_captbl_check_expand+0x1df>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40cb52:	41 8b 45 08          	mov    eax,DWORD PTR [r13+0x8]
--
  40cb75:	49 b8 90 cb 40 00 00 	movabs r8,0x40cb90
  40cb7c:	00 00 00 
  40cb7f:	0f 05                	syscall 
  40cb81:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  40cb88:	eb 0d                	jmp    40cb97 <__capid_captbl_check_expand+0x1b7>
  40cb8a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40cb90:	b9 00 00 00 00       	mov    ecx,0x0
  40cb95:	eb 05                	jmp    40cb9c <__capid_captbl_check_expand+0x1bc>
  40cb97:	b9 01 00 00 00       	mov    ecx,0x1
  40cb9c:	5d                   	pop    rbp
  40cb9d:	5c                   	pop    rsp
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_CONS, captblcap, captblid_add, 0, 0)) {
  40cb9e:	85 c0                	test   eax,eax
  40cba0:	75 39                	jne    40cbdb <__capid_captbl_check_expand+0x1fb>
	frontier       = ps_load(&ci->cap_frontier);
  40cba2:	49 8b 45 18          	mov    rax,QWORD PTR [r13+0x18]
--
  40cbab:	f0 49 0f c1 55 20    	lock xadd QWORD PTR [r13+0x20],rdx
        __asm__ __volatile__("lock " PS_CAS_STR
  40cbb1:	f0 49 0f b1 55 18    	lock cmpxchg QWORD PTR [r13+0x18],rdx
  40cbb7:	0f 94 c0             	sete   al
	return 0;
  40cbba:	e9 51 fe ff ff       	jmp    40ca10 <__capid_captbl_check_expand+0x30>
  40cbbf:	be 2e 00 00 00       	mov    esi,0x2e
  40cbc4:	bf 20 d8 41 00       	mov    edi,0x41d820
  40cbc9:	e8 02 d5 ff ff       	call   40a0d0 <cos_print_str>
		assert(0); /* race condition? */
  40cbce:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40cbdb:	be 2e 00 00 00       	mov    esi,0x2e
  40cbe0:	bf 50 d8 41 00       	mov    edi,0x41d850
  40cbe5:	e8 e6 d4 ff ff       	call   40a0d0 <cos_print_str>
		assert(0); /* race? */
  40cbea:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
		if (__capid_captbl_check_expand(ci)) goto error;
  40cbf7:	4c 89 e7             	mov    rdi,r12
  40cbfa:	e8 e1 fd ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40cbff:	85 c0                	test   eax,eax
  40cc01:	75 4e                	jne    40cc51 <__capid_captbl_check_expand+0x271>
        __asm__ __volatile__("lock " PS_FAA_STR
  40cc03:	b8 04 00 00 00       	mov    eax,0x4
--
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40cc0f:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  40cc14:	e9 92 fe ff ff       	jmp    40caab <__capid_captbl_check_expand+0xcb>
  40cc19:	be 2e 00 00 00       	mov    esi,0x2e
  40cc1e:	bf 90 d7 41 00       	mov    edi,0x41d790
  40cc23:	e8 a8 d4 ff ff       	call   40a0d0 <cos_print_str>
	assert(kmem); /* FIXME: should have a failure semantics for capids */
  40cc28:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40cc35:	be 2e 00 00 00       	mov    esi,0x2e
  40cc3a:	bf f0 d7 41 00       	mov    edi,0x41d7f0
  40cc3f:	e8 8c d4 ff ff       	call   40a0d0 <cos_print_str>
	assert(captblid_add % CAPTBL_EXPAND_SZ == 0);
  40cc44:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40cc58:	00 00 00 00 00 
		assert(captblcap);
  40cc5d:	e9 66 fe ff ff       	jmp    40cac8 <__capid_captbl_check_expand+0xe8>
  40cc62:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40cc69:	00 00 00 00 
--
	u8_t lvl = (u8_t)pgtbl_lvl;
	assert(lvl >= 0 && lvl < COS_PGTBL_DEPTH - 1);
  40cc85:	41 80 f8 02          	cmp    r8b,0x2
  40cc89:	0f 87 6f 02 00 00    	ja     40cefe <__bump_mem_expand_range+0x28e>
  40cc8f:	45 89 c7             	mov    r15d,r8d
--
  40ccb6:	48 03 4d b8          	add    rcx,QWORD PTR [rbp-0x48]
	switch (pgtbl_lvl)
  40ccba:	83 fa 01             	cmp    edx,0x1
  40ccbd:	0f 84 ae 01 00 00    	je     40ce71 <__bump_mem_expand_range+0x201>
  40ccc3:	83 fa 02             	cmp    edx,0x2
  40ccc6:	75 1f                	jne    40cce7 <__bump_mem_expand_range+0x77>
		return round_up_to_pgt2_page(vaddr);
  40ccc8:	48 81 c1 ff ff 1f 00 	add    rcx,0x1fffff
--
  40ccde:	48 89 4d b0          	mov    QWORD PTR [rbp-0x50],rcx
  40cce2:	48 89 cf             	mov    rdi,rcx
  40cce5:	eb 33                	jmp    40cd1a <__bump_mem_expand_range+0xaa>
	switch (pgtbl_lvl)
  40cce7:	85 d2                	test   edx,edx
  40cce9:	75 ad                	jne    40cc98 <__bump_mem_expand_range+0x28>
		return round_up_to_pgt0_page(vaddr);
  40cceb:	48 ba ff ff ff ff 7f 	movabs rdx,0x7fffffffff
--
	for (addr = mem_ptr; addr < tmp_frontier; addr += range) {
  40cd1a:	48 8b 5d b8          	mov    rbx,QWORD PTR [rbp-0x48]
  40cd1e:	48 39 fb             	cmp    rbx,rdi
  40cd21:	0f 83 71 ff ff ff    	jae    40cc98 <__bump_mem_expand_range+0x28>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
--
  40cd39:	89 45 a4             	mov    DWORD PTR [rbp-0x5c],eax
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  40cd3c:	4d 3b 76 60          	cmp    r14,QWORD PTR [r14+0x60]
  40cd40:	0f 85 0f 01 00 00    	jne    40ce55 <__bump_mem_expand_range+0x1e5>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40cd46:	49 8d 96 b0 00 00 00 	lea    rdx,[r14+0xb0]
--
  40cd4f:	90                   	nop
  40cd50:	48 89 c8             	mov    rax,rcx
  40cd53:	f0 4c 0f b1 2a       	lock cmpxchg QWORD PTR [rdx],r13
  40cd58:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40cd5b:	84 c0                	test   al,al
  40cd5d:	74 f1                	je     40cd50 <__bump_mem_expand_range+0xe0>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40cd5f:	41 f6 46 38 03       	test   BYTE PTR [r14+0x38],0x3
  40cd64:	0f 84 29 01 00 00    	je     40ce93 <__bump_mem_expand_range+0x223>
        __asm__ __volatile__("lock " PS_FAA_STR
  40cd6a:	bb 04 00 00 00       	mov    ebx,0x4
--
	return __mem_bump_alloc(ci, 1, 1);
  40cd80:	4c 89 f7             	mov    rdi,r14
  40cd83:	e8 d8 fa ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40cd88:	48 89 c7             	mov    rdi,rax
		if (pte_cap == 0 || ptemem_cap == 0) {
  40cd8b:	48 85 db             	test   rbx,rbx
  40cd8e:	0f 84 1e 01 00 00    	je     40ceb2 <__bump_mem_expand_range+0x242>
  40cd94:	48 85 c0             	test   rax,rax
  40cd97:	0f 84 15 01 00 00    	je     40ceb2 <__bump_mem_expand_range+0x242>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40cd9d:	41 8b 46 08          	mov    eax,DWORD PTR [r14+0x8]
--
  40cda1:	4c 8d 55 c0          	lea    r10,[rbp-0x40]
  40cda5:	49 8b b6 98 00 00 00 	mov    rsi,QWORD PTR [r14+0x98]
		if (call_cap_op(meta->captbl_cap, CAPTBL_OP_PGTBLACTIVATE, pte_cap, meta->mi.pgtbl_cap, ptemem_cap,
  40cdac:	41 8d 57 01          	lea    edx,[r15+0x1]
  40cdb0:	4c 89 d1             	mov    rcx,r10
--
  40cdc5:	49 b8 e0 cd 40 00 00 	movabs r8,0x40cde0
  40cdcc:	00 00 00 
  40cdcf:	0f 05                	syscall 
  40cdd1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  40cdd8:	eb 0d                	jmp    40cde7 <__bump_mem_expand_range+0x177>
  40cdda:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40cde0:	b9 00 00 00 00       	mov    ecx,0x0
  40cde5:	eb 05                	jmp    40cdec <__bump_mem_expand_range+0x17c>
  40cde7:	b9 01 00 00 00       	mov    ecx,0x1
  40cdec:	5d                   	pop    rbp
  40cded:	5c                   	pop    rsp
  40cdee:	85 c0                	test   eax,eax
  40cdf0:	0f 85 d8 00 00 00    	jne    40cece <__bump_mem_expand_range+0x25e>
  40cdf6:	31 d2                	xor    edx,edx
  40cdf8:	8b 45 a4             	mov    eax,DWORD PTR [rbp-0x5c]
--
  40ce0f:	49 b8 28 ce 40 00 00 	movabs r8,0x40ce28
  40ce16:	00 00 00 
  40ce19:	0f 05                	syscall 
  40ce1b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40ce20:	eb 0d                	jmp    40ce2f <__bump_mem_expand_range+0x1bf>
  40ce22:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40ce28:	b9 00 00 00 00       	mov    ecx,0x0
  40ce2d:	eb 05                	jmp    40ce34 <__bump_mem_expand_range+0x1c4>
  40ce2f:	b9 01 00 00 00       	mov    ecx,0x1
  40ce34:	5d                   	pop    rbp
--
  40ce3a:	48 01 c6             	add    rsi,rax
  40ce3d:	48 89 75 a8          	mov    QWORD PTR [rbp-0x58],rsi
  40ce41:	48 3b 75 b0          	cmp    rsi,QWORD PTR [rbp-0x50]
  40ce45:	0f 83 4d fe ff ff    	jae    40cc98 <__bump_mem_expand_range+0x28>
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  40ce4b:	4d 3b 76 60          	cmp    r14,QWORD PTR [r14+0x60]
  40ce4f:	0f 84 f1 fe ff ff    	je     40cd46 <__bump_mem_expand_range+0xd6>
  40ce55:	be 2e 00 00 00       	mov    esi,0x2e
  40ce5a:	bf b0 d8 41 00       	mov    edi,0x41d8b0
  40ce5f:	e8 6c d2 ff ff       	call   40a0d0 <cos_print_str>
  40ce64:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ce6b:	00 00 00 00 
--
  40ce87:	48 89 4d b0          	mov    QWORD PTR [rbp-0x50],rcx
  40ce8b:	48 89 cf             	mov    rdi,rcx
  40ce8e:	e9 87 fe ff ff       	jmp    40cd1a <__bump_mem_expand_range+0xaa>
		if (__capid_captbl_check_expand(ci)) goto error;
  40ce93:	4c 89 f7             	mov    rdi,r14
  40ce96:	e8 45 fb ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40ce9b:	85 c0                	test   eax,eax
  40ce9d:	74 4b                	je     40ceea <__bump_mem_expand_range+0x27a>
  40ce9f:	49 c7 86 b0 00 00 00 	mov    QWORD PTR [r14+0xb0],0x0
  40cea6:	00 00 00 00 
	return __mem_bump_alloc(ci, 1, 1);
  40ceaa:	4c 89 f7             	mov    rdi,r14
  40cead:	e8 ae f9 ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40ceb2:	be 2e 00 00 00       	mov    esi,0x2e
  40ceb7:	bf e0 d8 41 00       	mov    edi,0x41d8e0
  40cebc:	e8 0f d2 ff ff       	call   40a0d0 <cos_print_str>
			assert(0);
  40cec1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40cece:	be 2e 00 00 00       	mov    esi,0x2e
  40ced3:	bf 10 d9 41 00       	mov    edi,0x41d910
  40ced8:	e8 f3 d1 ff ff       	call   40a0d0 <cos_print_str>
				assert(0); /* race? */
  40cedd:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40cef5:	49 89 46 38          	mov    QWORD PTR [r14+0x38],rax
  40cef9:	e9 6c fe ff ff       	jmp    40cd6a <__bump_mem_expand_range+0xfa>
  40cefe:	be 2e 00 00 00       	mov    esi,0x2e
  40cf03:	bf 80 d8 41 00       	mov    edi,0x41d880
  40cf08:	e8 c3 d1 ff ff       	call   40a0d0 <cos_print_str>
	assert(lvl >= 0 && lvl < COS_PGTBL_DEPTH - 1);
  40cf0d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40cf4f:	00 
  40cf50:	48 89 c8             	mov    rax,rcx
  40cf53:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40cf58:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40cf5b:	84 c0                	test   al,al
  40cf5d:	74 f1                	je     40cf50 <__page_bump_valloc+0x30>
	vaddr_t ret_addr = 0;
	vaddr_t rounding; // how much we need to round up sz to handle alignment
--
  40cf7e:	4d 89 e6             	mov    r14,r12
  40cf81:	41 81 e6 ff 0f 00 00 	and    r14d,0xfff
  40cf88:	0f 85 32 01 00 00    	jne    40d0c0 <__page_bump_valloc+0x1a0>
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  40cf8e:	48 3b 7f 60          	cmp    rdi,QWORD PTR [rdi+0x60]
  40cf92:	0f 85 44 01 00 00    	jne    40d0dc <__page_bump_valloc+0x1bc>
        __asm__ __volatile__("lock " PS_FAA_STR
  40cf98:	4c 89 e2             	mov    rdx,r12
--
  40cfab:	4c 8d 6b 48          	lea    r13,[rbx+0x48]
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) pgtbl_flag = PGTBL_LVL_FLAG_VM;
  40cfaf:	80 bb d8 00 00 00 01 	cmp    BYTE PTR [rbx+0xd8],0x1
		return round_up_to_pgt0_page(vaddr);
  40cfb6:	48 b9 00 00 00 00 80 	movabs rcx,0xffffff8000000000
--
  40cfd9:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
		if (heap_vaddr + sz > ci->vasrange_frontier[pgtbl_lvl]) {
  40cfdd:	4d 39 4d 00          	cmp    QWORD PTR [r13+0x0],r9
  40cfe1:	72 45                	jb     40d028 <__page_bump_valloc+0x108>
	for (pgtbl_lvl = 0; pgtbl_lvl < COS_PGTBL_DEPTH - 1; pgtbl_lvl++) {
  40cfe3:	49 83 c6 01          	add    r14,0x1
  40cfe7:	49 83 c5 08          	add    r13,0x8
  40cfeb:	49 83 fe 03          	cmp    r14,0x3
  40cfef:	75 ec                	jne    40cfdd <__page_bump_valloc+0xbd>
{ l->o = 0; }
  40cff1:	48 c7 83 c0 00 00 00 	mov    QWORD PTR [rbx+0xc0],0x0
--
  40d005:	49 f7 f7             	div    r15
  40d008:	48 85 d2             	test   rdx,rdx
  40d00b:	0f 85 e7 00 00 00    	jne    40d0f8 <__page_bump_valloc+0x1d8>

	return ret_addr;
--
  40d03e:	45 09 f0             	or     r8d,r14d
  40d041:	48 89 55 b0          	mov    QWORD PTR [rbp-0x50],rdx
  40d045:	e8 26 fc ff ff       	call   40cc70 <__bump_mem_expand_range>
			assert(retaddr);
  40d04a:	48 85 c0             	test   rax,rax
  40d04d:	0f 84 c1 00 00 00    	je     40d114 <__page_bump_valloc+0x1f4>
		return round_up_to_pgt1_page(vaddr);
  40d053:	4c 8b 4d a0          	mov    r9,QWORD PTR [rbp-0x60]
--
  40d089:	48 89 f9             	mov    rcx,rdi
	switch (pgtbl_lvl)
  40d08c:	49 83 fe 01          	cmp    r14,0x1
  40d090:	74 0c                	je     40d09e <__page_bump_valloc+0x17e>
		return round_up_to_pgt0_page(vaddr);
  40d092:	48 8b 4d c8          	mov    rcx,QWORD PTR [rbp-0x38]
	switch (pgtbl_lvl)
  40d096:	41 83 f8 02          	cmp    r8d,0x2
		return round_up_to_pgt0_page(vaddr);
  40d09a:	48 0f 44 ce          	cmove  rcx,rsi
				if (tmp >= heap_vaddr + sz) break;
  40d09e:	49 39 c1             	cmp    r9,rax
  40d0a1:	0f 86 3c ff ff ff    	jbe    40cfe3 <__page_bump_valloc+0xc3>
        __asm__ __volatile__("lock " PS_CAS_STR
  40d0a7:	f0 49 0f b1 4d 00    	lock cmpxchg QWORD PTR [r13+0x0],rcx
  40d0ad:	0f 94 c0             	sete   al
				vaddr_t tmp = ps_load(&ci->vasrange_frontier[pgtbl_lvl]);
--
  40d0b5:	48 89 f9             	mov    rcx,rdi
	switch (pgtbl_lvl)
  40d0b8:	49 83 fe 01          	cmp    r14,0x1
  40d0bc:	75 d4                	jne    40d092 <__page_bump_valloc+0x172>
  40d0be:	eb de                	jmp    40d09e <__page_bump_valloc+0x17e>
  40d0c0:	be 2e 00 00 00       	mov    esi,0x2e
  40d0c5:	bf 40 d9 41 00       	mov    edi,0x41d940
  40d0ca:	e8 01 d0 ff ff       	call   40a0d0 <cos_print_str>
	assert(sz % PAGE_SIZE == 0);
  40d0cf:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40d0dc:	be 2e 00 00 00       	mov    esi,0x2e
  40d0e1:	bf 70 d9 41 00       	mov    edi,0x41d970
  40d0e6:	e8 e5 cf ff ff       	call   40a0d0 <cos_print_str>
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  40d0eb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40d0f8:	be 2e 00 00 00       	mov    esi,0x2e
  40d0fd:	bf d0 d9 41 00       	mov    edi,0x41d9d0
  40d102:	e8 c9 cf ff ff       	call   40a0d0 <cos_print_str>
	assert(ret_addr % align == 0);
  40d107:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40d114:	be 2e 00 00 00       	mov    esi,0x2e
  40d119:	bf a0 d9 41 00       	mov    edi,0x41d9a0
  40d11e:	e8 ad cf ff ff       	call   40a0d0 <cos_print_str>
			assert(retaddr);
  40d123:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	 */
	heap_vaddr = __page_bump_valloc(ci, sz, align);
  40d14f:	e8 cc fd ff ff       	call   40cf20 <__page_bump_valloc>
  40d154:	48 89 45 98          	mov    QWORD PTR [rbp-0x68],rax
	if (unlikely(!heap_vaddr)) return 0;
  40d158:	48 85 c0             	test   rax,rax
  40d15b:	0f 84 ea 01 00 00    	je     40d34b <__page_bump_alloc+0x21b>
  40d161:	48 89 c7             	mov    rdi,rax
	heap_limit = heap_vaddr + sz;
--
  40d16e:	48 89 45 a0          	mov    QWORD PTR [rbp-0x60],rax
	assert(heap_limit > heap_vaddr);
  40d172:	48 39 c7             	cmp    rdi,rax
  40d175:	0f 83 eb 01 00 00    	jae    40d366 <__page_bump_alloc+0x236>
	return ci->memsrc;
--
	assert(ci && ci == __compinfo_metacap(__ci));
  40d188:	4d 85 f6             	test   r14,r14
  40d18b:	0f 84 7c 01 00 00    	je     40d30d <__page_bump_alloc+0x1dd>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40d191:	49 8d 96 b8 00 00 00 	lea    rdx,[r14+0xb8]
--
        __asm__ __volatile__("lock " PS_CAS_STR
  40d1a0:	4c 89 d0             	mov    rax,r10
  40d1a3:	f0 4c 0f b1 2a       	lock cmpxchg QWORD PTR [rdx],r13
  40d1a8:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40d1ab:	84 c0                	test   al,al
  40d1ad:	74 f1                	je     40d1a0 <__page_bump_alloc+0x70>
        __asm__ __volatile__("lock " PS_FAA_STR
  40d1af:	bb 00 10 00 00       	mov    ebx,0x1000
--
	if (ret >= *frontier || *frontier - ret > RETYPE_MEM_SIZE) {
  40d1ba:	49 8b 96 88 00 00 00 	mov    rdx,QWORD PTR [r14+0x88]
  40d1c1:	48 39 d3             	cmp    rbx,rdx
  40d1c4:	73 0e                	jae    40d1d4 <__page_bump_alloc+0xa4>
  40d1c6:	48 89 d0             	mov    rax,rdx
  40d1c9:	48 29 d8             	sub    rax,rbx
  40d1cc:	48 3d 00 10 00 00    	cmp    rax,0x1000
  40d1d2:	76 43                	jbe    40d217 <__page_bump_alloc+0xe7>
		vaddr_t ptr_tmp = *ptr, front_tmp = *frontier;
--
		if (ci->mi.untyped_ptr == ci->mi.untyped_frontier) goto error;
  40d1d8:	49 8b 8e 80 00 00 00 	mov    rcx,QWORD PTR [r14+0x80]
  40d1df:	49 39 4e 68          	cmp    QWORD PTR [r14+0x68],rcx
  40d1e3:	0f 84 57 01 00 00    	je     40d340 <__page_bump_alloc+0x210>
  40d1e9:	bb 00 10 00 00       	mov    ebx,0x1000
  40d1ee:	f0 49 0f c1 5e 68    	lock xadd QWORD PTR [r14+0x68],rbx
--
  40d1f4:	48 8d 8b 00 10 00 00 	lea    rcx,[rbx+0x1000]
        __asm__ __volatile__("lock " PS_CAS_STR
  40d1fb:	f0 49 0f b1 4e 70    	lock cmpxchg QWORD PTR [r14+0x70],rcx
  40d201:	0f 94 c0             	sete   al
  40d204:	84 c0                	test   al,al
  40d206:	74 0f                	je     40d217 <__page_bump_alloc+0xe7>
  40d208:	48 89 d0             	mov    rax,rdx
  40d20b:	f0 49 0f b1 8e 88 00 	lock cmpxchg QWORD PTR [r14+0x88],rcx
  40d212:	00 00 
  40d214:	0f 94 c0             	sete   al
--
  40d217:	48 89 da             	mov    rdx,rbx
  40d21a:	81 e2 ff 0f 00 00    	and    edx,0xfff
  40d220:	0f 85 0a 01 00 00    	jne    40d330 <__page_bump_alloc+0x200>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40d226:	41 8b 86 98 00 00 00 	mov    eax,DWORD PTR [r14+0x98]
--
  40d249:	49 b8 60 d2 40 00 00 	movabs r8,0x40d260
  40d250:	00 00 00 
  40d253:	0f 05                	syscall 
  40d255:	0f 1f 00             	nop    DWORD PTR [rax]
  40d258:	eb 0d                	jmp    40d267 <__page_bump_alloc+0x137>
  40d25a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40d260:	b9 00 00 00 00       	mov    ecx,0x0
  40d265:	eb 05                	jmp    40d26c <__page_bump_alloc+0x13c>
  40d267:	b9 01 00 00 00       	mov    ecx,0x1
  40d26c:	5d                   	pop    rbp
  40d26d:	5c                   	pop    rsp
		if (call_cap_op(ci->mi.pgtbl_cap, op, ret, 0, 0, 0)) goto error;
  40d26e:	85 c0                	test   eax,eax
  40d270:	0f 85 ca 00 00 00    	jne    40d340 <__page_bump_alloc+0x210>
{ l->o = 0; }
  40d276:	49 c7 86 b8 00 00 00 	mov    QWORD PTR [r14+0xb8],0x0
--
		if (!umem) return 0;
  40d281:	48 85 db             	test   rbx,rbx
  40d284:	0f 84 c1 00 00 00    	je     40d34b <__page_bump_alloc+0x21b>

		/* Actually map in the memory. */
		if (call_cap_op(meta->mi.pgtbl_cap, CAPTBL_OP_MEMACTIVATE, umem, ci->pgtbl_cap, heap_cursor, PAGE_ORDER)) {
  40d28a:	48 8b 45 a8          	mov    rax,QWORD PTR [rbp-0x58]
  40d28e:	49 8b 37             	mov    rsi,QWORD PTR [r15]
--
  40d2be:	49 b8 d8 d2 40 00 00 	movabs r8,0x40d2d8
  40d2c5:	00 00 00 
  40d2c8:	0f 05                	syscall 
  40d2ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40d2d0:	eb 0d                	jmp    40d2df <__page_bump_alloc+0x1af>
  40d2d2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40d2d8:	b9 00 00 00 00       	mov    ecx,0x0
  40d2dd:	eb 05                	jmp    40d2e4 <__page_bump_alloc+0x1b4>
  40d2df:	b9 01 00 00 00       	mov    ecx,0x1
  40d2e4:	5d                   	pop    rbp
  40d2e5:	5c                   	pop    rsp
  40d2e6:	85 c0                	test   eax,eax
  40d2e8:	0f 85 94 00 00 00    	jne    40d382 <__page_bump_alloc+0x252>
	for (heap_cursor = heap_vaddr; heap_cursor < heap_limit; heap_cursor += PAGE_SIZE) {
  40d2ee:	48 81 45 b8 00 10 00 	add    QWORD PTR [rbp-0x48],0x1000
  40d2f5:	00 
  40d2f6:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  40d2fa:	48 39 45 a0          	cmp    QWORD PTR [rbp-0x60],rax
  40d2fe:	76 53                	jbe    40d353 <__page_bump_alloc+0x223>
	return ci->memsrc;
--
	assert(ci && ci == __compinfo_metacap(__ci));
  40d304:	4d 85 f6             	test   r14,r14
  40d307:	0f 85 84 fe ff ff    	jne    40d191 <__page_bump_alloc+0x61>
  40d30d:	be 2e 00 00 00       	mov    esi,0x2e
  40d312:	bf 00 d7 41 00       	mov    edi,0x41d700
  40d317:	e8 b4 cd ff ff       	call   40a0d0 <cos_print_str>
  40d31c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d323:	00 00 00 00 
--
  40d337:	00 00 00 00 
		if (!umem) return 0;
  40d33b:	e9 4a ff ff ff       	jmp    40d28a <__page_bump_alloc+0x15a>
  40d340:	49 c7 86 b8 00 00 00 	mov    QWORD PTR [r14+0xb8],0x0
  40d347:	00 00 00 00 
--
  40d366:	be 2e 00 00 00       	mov    esi,0x2e
  40d36b:	bf 00 da 41 00       	mov    edi,0x41da00
  40d370:	e8 5b cd ff ff       	call   40a0d0 <cos_print_str>
	assert(heap_limit > heap_vaddr);
  40d375:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40d382:	be 2e 00 00 00       	mov    esi,0x2e
  40d387:	bf 30 da 41 00       	mov    edi,0x41da30
  40d38c:	e8 3f cd ff ff       	call   40a0d0 <cos_print_str>
			assert(0);
  40d391:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40d3ad:	48 83 ec 28          	sub    rsp,0x28
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  40d3b1:	48 3b 7f 60          	cmp    rdi,QWORD PTR [rdi+0x60]
  40d3b5:	0f 85 b3 01 00 00    	jne    40d56e <__bump_mem_expand_intern+0x1ce>
  40d3bb:	49 89 f6             	mov    r14,rsi
  40d3be:	49 89 d7             	mov    r15,rdx
--
	if (!intern) {
  40d3c8:	48 85 c9             	test   rcx,rcx
  40d3cb:	0f 85 c9 00 00 00    	jne    40d49a <__bump_mem_expand_intern+0xfa>
  40d3d1:	49 89 fc             	mov    r12,rdi
{ while (!ps_cas(&l->o, 0, 1)) ; }
--
  40d3e2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40d3e8:	48 89 c8             	mov    rax,rcx
  40d3eb:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40d3f0:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40d3f3:	84 c0                	test   al,al
  40d3f5:	74 f1                	je     40d3e8 <__bump_mem_expand_intern+0x48>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40d3f7:	41 f6 44 24 38 03    	test   BYTE PTR [r12+0x38],0x3
  40d3fd:	0f 84 41 01 00 00    	je     40d544 <__bump_mem_expand_intern+0x1a4>
  40d403:	4c 89 45 b8          	mov    QWORD PTR [rbp-0x48],r8
        __asm__ __volatile__("lock " PS_FAA_STR
--
  40d422:	49 89 dd             	mov    r13,rbx
	return __mem_bump_alloc(ci, 1, 1);
  40d425:	e8 36 f4 ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40d42a:	48 89 c7             	mov    rdi,rax
		if (pte_cap == 0 || ptemem_cap == 0) {
  40d42d:	48 85 db             	test   rbx,rbx
  40d430:	0f 84 f2 00 00 00    	je     40d528 <__bump_mem_expand_intern+0x188>
  40d436:	48 85 c0             	test   rax,rax
  40d439:	4c 8b 45 b8          	mov    r8,QWORD PTR [rbp-0x48]
  40d43d:	0f 84 e5 00 00 00    	je     40d528 <__bump_mem_expand_intern+0x188>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40d443:	41 8b 44 24 08       	mov    eax,DWORD PTR [r12+0x8]
--
  40d44c:	49 8b b4 24 98 00 00 	mov    rsi,QWORD PTR [r12+0x98]
  40d453:	00 
		if (call_cap_op(meta->captbl_cap, CAPTBL_OP_PGTBLACTIVATE, pte_cap, meta->mi.pgtbl_cap, ptemem_cap,
  40d454:	49 8d 50 01          	lea    rdx,[r8+0x1]
  40d458:	4c 89 d1             	mov    rcx,r10
--
  40d46d:	49 b8 88 d4 40 00 00 	movabs r8,0x40d488
  40d474:	00 00 00 
  40d477:	0f 05                	syscall 
  40d479:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  40d480:	eb 0d                	jmp    40d48f <__bump_mem_expand_intern+0xef>
  40d482:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40d488:	b9 00 00 00 00       	mov    ecx,0x0
  40d48d:	eb 05                	jmp    40d494 <__bump_mem_expand_intern+0xf4>
  40d48f:	b9 01 00 00 00       	mov    ecx,0x1
  40d494:	5d                   	pop    rbp
  40d495:	5c                   	pop    rsp
  40d496:	85 c0                	test   eax,eax
  40d498:	75 5e                	jne    40d4f8 <__bump_mem_expand_intern+0x158>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40d49a:	41 c1 e6 10          	shl    r14d,0x10
--
  40d4bd:	49 b8 d8 d4 40 00 00 	movabs r8,0x40d4d8
  40d4c4:	00 00 00 
  40d4c7:	0f 05                	syscall 
  40d4c9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  40d4d0:	eb 0d                	jmp    40d4df <__bump_mem_expand_intern+0x13f>
  40d4d2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40d4d8:	b9 00 00 00 00       	mov    ecx,0x0
  40d4dd:	eb 05                	jmp    40d4e4 <__bump_mem_expand_intern+0x144>
  40d4df:	b9 01 00 00 00       	mov    ecx,0x1
  40d4e4:	5d                   	pop    rbp
--
  40d4f8:	be 2e 00 00 00       	mov    esi,0x2e
  40d4fd:	bf 10 d9 41 00       	mov    edi,0x41d910
  40d502:	e8 c9 cb ff ff       	call   40a0d0 <cos_print_str>
				assert(0); /* race? */
  40d507:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	return __mem_bump_alloc(ci, 1, 1);
  40d520:	4c 89 e7             	mov    rdi,r12
  40d523:	e8 38 f3 ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40d528:	be 2e 00 00 00       	mov    esi,0x2e
  40d52d:	bf e0 d8 41 00       	mov    edi,0x41d8e0
  40d532:	e8 99 cb ff ff       	call   40a0d0 <cos_print_str>
			assert(0);
  40d537:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40d544:	4c 89 e7             	mov    rdi,r12
  40d547:	4c 89 45 b8          	mov    QWORD PTR [rbp-0x48],r8
  40d54b:	e8 90 f4 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40d550:	4c 8b 45 b8          	mov    r8,QWORD PTR [rbp-0x48]
  40d554:	85 c0                	test   eax,eax
  40d556:	75 bc                	jne    40d514 <__bump_mem_expand_intern+0x174>
        __asm__ __volatile__("lock " PS_FAA_STR
  40d558:	b8 04 00 00 00       	mov    eax,0x4
--
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40d564:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  40d569:	e9 95 fe ff ff       	jmp    40d403 <__bump_mem_expand_intern+0x63>
  40d56e:	be 2e 00 00 00       	mov    esi,0x2e
  40d573:	bf b0 d8 41 00       	mov    edi,0x41d8b0
  40d578:	e8 53 cb ff ff       	call   40a0d0 <cos_print_str>
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  40d57d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40d630:	f3 0f 1e fa          	endbr64 
  40d634:	31 c0                	xor    eax,eax
  40d636:	83 ff 02             	cmp    edi,0x2
  40d639:	77 0a                	ja     40d645 <cos_pgtbl_get_range+0x15>
  40d63b:	89 ff                	mov    edi,edi
--
  40d657:	48 25 00 00 00 c0    	and    rax,0xffffffffc0000000
	switch (pgtbl_lvl)
  40d65d:	83 ff 01             	cmp    edi,0x1
  40d660:	74 14                	je     40d676 <cos_pgtbl_round_to_page+0x26>
		return round_to_pgt2_page(vaddr);
  40d662:	48 89 f0             	mov    rax,rsi
  40d665:	48 25 00 00 e0 ff    	and    rax,0xffffffffffe00000
	switch (pgtbl_lvl)
  40d66b:	83 ff 02             	cmp    edi,0x2
  40d66e:	74 06                	je     40d676 <cos_pgtbl_round_to_page+0x26>
  40d670:	31 c0                	xor    eax,eax
  40d672:	85 ff                	test   edi,edi
  40d674:	74 0a                	je     40d680 <cos_pgtbl_round_to_page+0x30>
}
  40d676:	c3                   	ret    
--
  40d690:	f3 0f 1e fa          	endbr64 
	switch (pgtbl_lvl)
  40d694:	83 ff 01             	cmp    edi,0x1
  40d697:	74 47                	je     40d6e0 <cos_pgtbl_round_up_to_page+0x50>
  40d699:	83 ff 02             	cmp    edi,0x2
  40d69c:	74 2a                	je     40d6c8 <cos_pgtbl_round_up_to_page+0x38>
  40d69e:	31 c0                	xor    eax,eax
  40d6a0:	85 ff                	test   edi,edi
  40d6a2:	74 04                	je     40d6a8 <cos_pgtbl_round_up_to_page+0x18>
}
  40d6a4:	c3                   	ret    
--
	assert(ci && ci_resources);
  40d73d:	48 85 ff             	test   rdi,rdi
  40d740:	0f 84 19 01 00 00    	je     40d85f <cos_compinfo_init+0x13f>
  40d746:	48 85 d2             	test   rdx,rdx
  40d749:	0f 84 10 01 00 00    	je     40d85f <cos_compinfo_init+0x13f>
	assert(cap_frontier % CAPMAX_ENTRY_SZ == 0);
  40d74f:	41 f6 c1 03          	test   r9b,0x3
  40d753:	0f 85 22 01 00 00    	jne    40d87b <cos_compinfo_init+0x15b>
	ci->memsrc = ci_resources;
  40d759:	48 89 57 60          	mov    QWORD PTR [rdi+0x60],rdx
  40d75d:	48 89 f8             	mov    rax,rdi
	assert(ci_resources->memsrc == ci_resources); /* prevent infinite data-structs */
  40d760:	48 39 52 60          	cmp    QWORD PTR [rdx+0x60],rdx
  40d764:	0f 85 2d 01 00 00    	jne    40d897 <cos_compinfo_init+0x177>
	vaddr_t last_page = round_to_page(heap_ptr - 1);
  40d76a:	49 8d 50 ff          	lea    rdx,[r8-0x1]
--
  40d7ed:	0f 11 47 50          	movups XMMWORD PTR [rdi+0x50],xmm0
	assert(round_up_to_pow2(cap_frontier, CAPMAX_ENTRY_SZ) == cap_frontier);
  40d7f1:	49 39 d1             	cmp    r9,rdx
  40d7f4:	0f 85 b9 00 00 00    	jne    40d8b3 <cos_compinfo_init+0x193>
  40d7fa:	66 49 0f 6e c9       	movq   xmm1,r9
	ci->cap_frontier = cap_frontier;
--
  40d803:	66 0f 6c c9          	punpcklqdq xmm1,xmm1
	if (cap_frontier < CAPTBL_EXPAND_SZ) {
  40d807:	49 83 f9 7f          	cmp    r9,0x7f
  40d80b:	76 43                	jbe    40d850 <cos_compinfo_init+0x130>
		ci->caprange_frontier = round_up_to_pow2(cap_frontier + CAPTBL_EXPAND_SZ, CAPTBL_EXPAND_SZ * 2) - CAPTBL_EXPAND_SZ;
--
  40d854:	48 83 e2 80          	and    rdx,0xffffffffffffff80
  40d858:	66 48 0f 6e c2       	movq   xmm0,rdx
  40d85d:	eb c0                	jmp    40d81f <cos_compinfo_init+0xff>
  40d85f:	be 2e 00 00 00       	mov    esi,0x2e
  40d864:	bf 60 da 41 00       	mov    edi,0x41da60
  40d869:	e8 62 c8 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci && ci_resources);
  40d86e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40d87b:	be 2e 00 00 00       	mov    esi,0x2e
  40d880:	bf 90 da 41 00       	mov    edi,0x41da90
  40d885:	e8 46 c8 ff ff       	call   40a0d0 <cos_print_str>
	assert(cap_frontier % CAPMAX_ENTRY_SZ == 0);
  40d88a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40d897:	be 2e 00 00 00       	mov    esi,0x2e
  40d89c:	bf c0 da 41 00       	mov    edi,0x41dac0
  40d8a1:	e8 2a c8 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci_resources->memsrc == ci_resources); /* prevent infinite data-structs */
  40d8a6:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40d8b3:	be 2e 00 00 00       	mov    esi,0x2e
  40d8b8:	bf f0 da 41 00       	mov    edi,0x41daf0
  40d8bd:	e8 0e c8 ff ff       	call   40a0d0 <cos_print_str>
	assert(round_up_to_pow2(cap_frontier, CAPMAX_ENTRY_SZ) == cap_frontier);
  40d8c2:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	/* TODO: optimize for invocation and return */
	switch (c) {
  40d8df:	83 fe 14             	cmp    esi,0x14
  40d8e2:	77 78                	ja     40d95c <cos_capid_bump_alloc+0x8c>
  40d8e4:	b8 01 00 00 00       	mov    eax,0x1
--
  40d8f7:	4c 8d 77 38          	lea    r14,[rdi+0x38]
  40d8fb:	a9 da 81 1f 00       	test   eax,0x1f81da
  40d900:	74 4e                	je     40d950 <cos_capid_bump_alloc+0x80>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40d902:	48 8d 93 b0 00 00 00 	lea    rdx,[rbx+0xb0]
--
  40d90e:	31 c9                	xor    ecx,ecx
  40d910:	48 89 c8             	mov    rax,rcx
  40d913:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40d918:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40d91b:	84 c0                	test   al,al
  40d91d:	74 f1                	je     40d910 <cos_capid_bump_alloc+0x40>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40d91f:	4d 8b 2e             	mov    r13,QWORD PTR [r14]
  40d922:	41 83 e5 03          	and    r13d,0x3
  40d926:	74 68                	je     40d990 <cos_capid_bump_alloc+0xc0>
        __asm__ __volatile__("lock " PS_FAA_STR
  40d928:	4c 89 e0             	mov    rax,r12
--
  40d94a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40d950:	a9 24 10 00 00       	test   eax,0x1024
  40d955:	75 29                	jne    40d980 <cos_capid_bump_alloc+0xb0>
  40d957:	f6 c4 60             	test   ah,0x60
  40d95a:	75 14                	jne    40d970 <cos_capid_bump_alloc+0xa0>
  40d95c:	49 c7 c5 ff ff ff ff 	mov    r13,0xffffffffffffffff
  40d963:	5b                   	pop    rbx
--
		break;
  40d974:	41 bc 02 00 00 00    	mov    r12d,0x2
  40d97a:	eb 86                	jmp    40d902 <cos_capid_bump_alloc+0x32>
  40d97c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		frontier = &ci->cap16_frontier[cos_cpuid()];
--
		break;
  40d984:	41 bc 01 00 00 00    	mov    r12d,0x1
  40d98a:	e9 73 ff ff ff       	jmp    40d902 <cos_capid_bump_alloc+0x32>
  40d98f:	90                   	nop
		if (__capid_captbl_check_expand(ci)) goto error;
  40d990:	48 89 df             	mov    rdi,rbx
  40d993:	e8 48 f0 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40d998:	85 c0                	test   eax,eax
  40d99a:	75 97                	jne    40d933 <cos_capid_bump_alloc+0x63>
        __asm__ __volatile__("lock " PS_FAA_STR
  40d99c:	b8 04 00 00 00       	mov    eax,0x4
--
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40d9a7:	49 89 06             	mov    QWORD PTR [r14],rax
  40d9aa:	e9 79 ff ff ff       	jmp    40d928 <cos_capid_bump_alloc+0x58>
  40d9af:	90                   	nop

--
  40d9d0:	48 83 ec 08          	sub    rsp,0x8
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  40d9d4:	80 bf d8 00 00 00 01 	cmp    BYTE PTR [rdi+0xd8],0x1
		ret = __bump_mem_expand_range(__compinfo_metacap(ci), cipgtbl, mem_ptr, mem_sz, i | pgtbl_lvl_flag);	
  40d9db:	48 8b 7f 60          	mov    rdi,QWORD PTR [rdi+0x60]
--
  40d9e7:	45 89 f8             	mov    r8d,r15d
  40d9ea:	41 83 c8 01          	or     r8d,0x1
  40d9ee:	e8 7d f2 ff ff       	call   40cc70 <__bump_mem_expand_range>
  40d9f3:	48 8b 7b 60          	mov    rdi,QWORD PTR [rbx+0x60]
  40d9f7:	45 89 f8             	mov    r8d,r15d
--
  40da14:	5d                   	pop    rbp
		ret = __bump_mem_expand_range(__compinfo_metacap(ci), cipgtbl, mem_ptr, mem_sz, i | pgtbl_lvl_flag);	
  40da15:	e9 56 f2 ff ff       	jmp    40cc70 <__bump_mem_expand_range>
  40da1a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

--
        __asm__ __volatile__("lock " PS_CAS_STR
  40da50:	48 89 f0             	mov    rax,rsi
  40da53:	f0 48 0f b1 39       	lock cmpxchg QWORD PTR [rcx],rdi
  40da58:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40da5b:	84 c0                	test   al,al
  40da5d:	74 f1                	je     40da50 <cos_pgtbl_intern_expand+0x30>
	if (ci->vasrange_frontier[lvl] != round_to_pgd_page(mem_ptr)) goto error;
  40da5f:	48 b8 00 00 00 00 80 	movabs rax,0xffffff8000000000
--
  40da6c:	4e 8d 34 eb          	lea    r14,[rbx+r13*8]
  40da70:	4c 21 e0             	and    rax,r12
  40da73:	49 39 46 48          	cmp    QWORD PTR [r14+0x48],rax
  40da77:	74 1f                	je     40da98 <cos_pgtbl_intern_expand+0x78>
	return 0;
  40da79:	45 31 c0             	xor    r8d,r8d
--
  40daa2:	31 c9                	xor    ecx,ecx
  40daa4:	4c 89 e2             	mov    rdx,r12
  40daa7:	e8 f4 f8 ff ff       	call   40d3a0 <__bump_mem_expand_intern>
  40daac:	49 89 c0             	mov    r8,rax
	if (!cap) goto error;
  40daaf:	48 85 c0             	test   rax,rax
  40dab2:	74 c5                	je     40da79 <cos_pgtbl_intern_expand+0x59>
		if (tmp >= mem_ptr + PGD_RANGE) break;
  40dab4:	48 be 00 00 00 00 80 	movabs rsi,0x8000000000
--
		if (tmp >= mem_ptr + PGD_RANGE) break;
  40dac7:	49 01 f4             	add    r12,rsi
  40daca:	4c 39 e0             	cmp    rax,r12
  40dacd:	73 ad                	jae    40da7c <cos_pgtbl_intern_expand+0x5c>
  40dacf:	90                   	nop
--
  40dad0:	48 8d 14 30          	lea    rdx,[rax+rsi*1]
        __asm__ __volatile__("lock " PS_CAS_STR
  40dad4:	f0 48 0f b1 11       	lock cmpxchg QWORD PTR [rcx],rdx
  40dad9:	0f 94 c0             	sete   al
		vaddr_t tmp = ps_load(&ci->vasrange_frontier[lvl]);
  40dadc:	49 8b 46 48          	mov    rax,QWORD PTR [r14+0x48]
		if (tmp >= mem_ptr + PGD_RANGE) break;
  40dae0:	4c 39 e0             	cmp    rax,r12
  40dae3:	72 eb                	jb     40dad0 <cos_pgtbl_intern_expand+0xb0>
  40dae5:	eb 95                	jmp    40da7c <cos_pgtbl_intern_expand+0x5c>
  40dae7:	be 2e 00 00 00       	mov    esi,0x2e
  40daec:	bf 20 db 41 00       	mov    edi,0x41db20
  40daf1:	e8 da c5 ff ff       	call   40a0d0 <cos_print_str>
	assert(lvl > 0);
  40daf6:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40db32:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40db38:	48 89 c8             	mov    rax,rcx
  40db3b:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40db40:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40db43:	84 c0                	test   al,al
  40db45:	74 f1                	je     40db38 <cos_pgtbl_intern_expandwith+0x28>
	if (ci->vasrange_frontier[0] != round_to_pgd_page(mem)) goto error;
  40db47:	48 b8 00 00 00 00 80 	movabs rax,0xffffff8000000000
  40db4e:	ff ff ff 
  40db51:	4c 21 c8             	and    rax,r9
  40db54:	48 39 43 48          	cmp    QWORD PTR [rbx+0x48],rax
  40db58:	75 23                	jne    40db7d <cos_pgtbl_intern_expandwith+0x6d>
        __asm__ __volatile__("lock " PS_FAA_STR
  40db5a:	48 ba 00 00 00 00 80 	movabs rdx,0x8000000000
--
  40db67:	f0 48 0f c1 4b 48    	lock xadd QWORD PTR [rbx+0x48],rcx
	if ((unsigned long)ps_faa(&ci->vasrange_frontier[0], PGD_RANGE) > round_to_pgd_page(mem)) goto error;
  40db6d:	48 39 c8             	cmp    rax,rcx
  40db70:	72 0b                	jb     40db7d <cos_pgtbl_intern_expandwith+0x6d>
  40db72:	f0 48 0f c1 53 40    	lock xadd QWORD PTR [rbx+0x40],rdx
	if ((unsigned long)ps_faa(&ci->vas_frontier, PGD_RANGE) > round_to_pgd_page(mem)) goto error;
  40db78:	48 39 d0             	cmp    rax,rdx
  40db7b:	73 1b                	jae    40db98 <cos_pgtbl_intern_expandwith+0x88>
{ l->o = 0; }
--
  40dba2:	4c 89 e1             	mov    rcx,r12
  40dba5:	4c 89 ca             	mov    rdx,r9
  40dba8:	e8 f3 f7 ff ff       	call   40d3a0 <__bump_mem_expand_intern>
  40dbad:	48 c7 83 c0 00 00 00 	mov    QWORD PTR [rbx+0xc0],0x0
  40dbb4:	00 00 00 00 
--
  40dbb8:	5b                   	pop    rbx
	if (__bump_mem_expand_intern(__compinfo_metacap(ci), ci->pgtbl_cap, mem, intern, 0) != intern) {
  40dbb9:	4c 39 e0             	cmp    rax,r12
}
  40dbbc:	41 5c                	pop    r12
--
  40dc02:	4c 8b 7f 60          	mov    r15,QWORD PTR [rdi+0x60]
	assert(untyped_ptr == round_up_to_pgd_page(untyped_ptr));
  40dc06:	48 39 c6             	cmp    rsi,rax
  40dc09:	0f 85 88 01 00 00    	jne    40dd97 <cos_meminfo_alloc+0x1c7>
  40dc0f:	49 89 fd             	mov    r13,rdi
  40dc12:	48 89 f3             	mov    rbx,rsi
--
  40dc25:	4c 89 f1             	mov    rcx,r14
  40dc28:	48 89 da             	mov    rdx,rbx
  40dc2b:	e8 40 f0 ff ff       	call   40cc70 <__bump_mem_expand_range>
  40dc30:	49 89 c2             	mov    r10,rax
		assert(retaddr);
  40dc33:	48 85 c0             	test   rax,rax
  40dc36:	0f 84 3f 01 00 00    	je     40dd7b <cos_meminfo_alloc+0x1ab>
	for(pgtbl_lvl = 0; pgtbl_lvl < COS_PGTBL_DEPTH - 1; pgtbl_lvl++) {
  40dc3c:	49 83 c4 01          	add    r12,0x1
  40dc40:	49 83 fc 03          	cmp    r12,0x3
  40dc44:	74 0a                	je     40dc50 <cos_meminfo_alloc+0x80>
	return ci->memsrc;
  40dc46:	49 8b 7d 60          	mov    rdi,QWORD PTR [r13+0x60]
  40dc4a:	eb cf                	jmp    40dc1b <cos_meminfo_alloc+0x4b>
  40dc4c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  40dc50:	66 48 0f 6e c0       	movq   xmm0,rax
--
  40dc63:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
	assert(retaddr == untyped_ptr);
  40dc67:	48 39 c3             	cmp    rbx,rax
  40dc6a:	0f 85 43 01 00 00    	jne    40ddb3 <cos_meminfo_alloc+0x1e3>
  40dc70:	48 89 c8             	mov    rax,rcx
  40dc73:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40dc78:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40dc7b:	84 c0                	test   al,al
  40dc7d:	74 f1                	je     40dc70 <cos_meminfo_alloc+0xa0>
        __asm__ __volatile__("lock " PS_FAA_STR
  40dc7f:	4c 89 f0             	mov    rax,r14
--
  40dcb4:	00 00 00 00 
  40dcb8:	66 0f 6c ca          	punpcklqdq xmm1,xmm2
  40dcbc:	4c 39 d3             	cmp    rbx,r10
  40dcbf:	0f 86 8f 00 00 00    	jbe    40dd54 <cos_meminfo_alloc+0x184>
  40dcc5:	4c 89 55 b8          	mov    QWORD PTR [rbp-0x48],r10
  40dcc9:	49 89 da             	mov    r10,rbx
  40dccc:	eb 0e                	jmp    40dcdc <cos_meminfo_alloc+0x10c>
  40dcce:	66 90                	xchg   ax,ax
  40dcd0:	48 81 c7 00 10 00 00 	add    rdi,0x1000
  40dcd7:	49 39 fa             	cmp    r10,rdi
  40dcda:	76 74                	jbe    40dd50 <cos_meminfo_alloc+0x180>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
--
  40dd04:	49 b8 18 dd 40 00 00 	movabs r8,0x40dd18
  40dd0b:	00 00 00 
  40dd0e:	0f 05                	syscall 
  40dd10:	eb 0d                	jmp    40dd1f <cos_meminfo_alloc+0x14f>
  40dd12:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40dd18:	b9 00 00 00 00       	mov    ecx,0x0
  40dd1d:	eb 05                	jmp    40dd24 <cos_meminfo_alloc+0x154>
  40dd1f:	b9 01 00 00 00       	mov    ecx,0x1
  40dd24:	5d                   	pop    rbp
  40dd25:	5c                   	pop    rsp
		if (call_cap_op(meta->mi.pgtbl_cap, CAPTBL_OP_MEMMOVE, start_addr, ci->mi.pgtbl_cap, addr, 0)) BUG();
  40dd26:	85 c0                	test   eax,eax
  40dd28:	74 a6                	je     40dcd0 <cos_meminfo_alloc+0x100>
  40dd2a:	be 1b 00 00 00       	mov    esi,0x1b
  40dd2f:	bf df db 41 00       	mov    edi,0x41dbdf
  40dd34:	e8 97 c3 ff ff       	call   40a0d0 <cos_print_str>
  40dd39:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40dd40:	00 00 00 00 
--
  40dd7b:	be 2e 00 00 00       	mov    esi,0x2e
  40dd80:	bf 80 db 41 00       	mov    edi,0x41db80
  40dd85:	e8 46 c3 ff ff       	call   40a0d0 <cos_print_str>
		assert(retaddr);
  40dd8a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40dd97:	be 2e 00 00 00       	mov    esi,0x2e
  40dd9c:	bf 50 db 41 00       	mov    edi,0x41db50
  40dda1:	e8 2a c3 ff ff       	call   40a0d0 <cos_print_str>
	assert(untyped_ptr == round_up_to_pgd_page(untyped_ptr));
  40dda6:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40ddb3:	be 2e 00 00 00       	mov    esi,0x2e
  40ddb8:	bf b0 db 41 00       	mov    edi,0x41dbb0
  40ddbd:	e8 0e c3 ff ff       	call   40a0d0 <cos_print_str>
	assert(retaddr == untyped_ptr);
  40ddc2:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	test_cap = CAPTBL_EXPAND_SZ;
	if (self_resource) {
  40ddf5:	4c 39 ff             	cmp    rdi,r15
  40ddf8:	0f 84 a2 02 00 00    	je     40e0a0 <missing_captbl_node_expand+0x2d0>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40ddfe:	41 8b 47 08          	mov    eax,DWORD PTR [r15+0x8]
--
  40de2d:	49 b8 48 de 40 00 00 	movabs r8,0x40de48
  40de34:	00 00 00 
  40de37:	0f 05                	syscall 
  40de39:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  40de40:	eb 0d                	jmp    40de4f <missing_captbl_node_expand+0x7f>
  40de42:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40de48:	b9 00 00 00 00       	mov    ecx,0x0
  40de4d:	eb 05                	jmp    40de54 <missing_captbl_node_expand+0x84>
  40de4f:	b9 01 00 00 00       	mov    ecx,0x1
  40de54:	5d                   	pop    rbp
--
	} else {
		printd("cap check before:%d\n", ci->captbl_cap);
		ret = call_cap_op(root_source->captbl_cap, CAPTBL_OP_CAPCHECK, ci->captbl_cap, 0, 1, 0);
		// printc("after cap check:%d\n", ret);
		/* make sure the sub captbl exists */
		assert(!ret);
  40de56:	85 c0                	test   eax,eax
  40de58:	0f 85 e8 03 00 00    	jne    40e246 <missing_captbl_node_expand+0x476>
		cap_frontier = ci->cap_frontier;
		caprange_frontier = ci->caprange_frontier;
--
  40de6c:	48 89 45 b0          	mov    QWORD PTR [rbp-0x50],rax
		missing_captbl_node_expand(root_source);
  40de70:	e8 5b ff ff ff       	call   40ddd0 <missing_captbl_node_expand>
		while (test_cap < caprange_frontier) {
  40de75:	48 81 fb 80 00 00 00 	cmp    rbx,0x80
  40de7c:	0f 86 24 02 00 00    	jbe    40e0a6 <missing_captbl_node_expand+0x2d6>
  40de82:	4c 8b 55 a8          	mov    r10,QWORD PTR [rbp-0x58]
--
  40de86:	41 be 80 00 00 00    	mov    r14d,0x80
  40de8c:	45 31 ed             	xor    r13d,r13d
  40de8f:	eb 18                	jmp    40dea9 <missing_captbl_node_expand+0xd9>
  40de91:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
					printc("assert ret:%d\n", ret);
--
  40de98:	49 81 c6 00 01 00 00 	add    r14,0x100
		while (test_cap < caprange_frontier) {
  40de9f:	4c 39 75 b0          	cmp    QWORD PTR [rbp-0x50],r14
  40dea3:	0f 86 fd 01 00 00    	jbe    40e0a6 <missing_captbl_node_expand+0x2d6>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
--
  40ded0:	49 b8 e8 de 40 00 00 	movabs r8,0x40dee8
  40ded7:	00 00 00 
  40deda:	0f 05                	syscall 
  40dedc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  40dee0:	eb 0d                	jmp    40deef <missing_captbl_node_expand+0x11f>
  40dee2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40dee8:	b9 00 00 00 00       	mov    ecx,0x0
  40deed:	eb 05                	jmp    40def4 <missing_captbl_node_expand+0x124>
  40deef:	b9 01 00 00 00       	mov    ecx,0x1
  40def4:	5d                   	pop    rbp
--
			if (ret) {
  40def6:	85 c0                	test   eax,eax
  40def8:	74 9e                	je     40de98 <missing_captbl_node_expand+0xc8>
	return __mem_bump_alloc(ci, 1, 1);
  40defa:	4c 89 ff             	mov    rdi,r15
  40defd:	4c 89 55 a8          	mov    QWORD PTR [rbp-0x58],r10
  40df01:	e8 5a e9 ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
				assert(kmem); /* FIXME: should have a failure semantics for capids */
  40df06:	4c 8b 55 a8          	mov    r10,QWORD PTR [rbp-0x58]
--
  40df0d:	49 89 c4             	mov    r12,rax
				assert(kmem); /* FIXME: should have a failure semantics for capids */
  40df10:	0f 84 9f 01 00 00    	je     40e0b5 <missing_captbl_node_expand+0x2e5>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40df16:	49 8d 97 b0 00 00 00 	lea    rdx,[r15+0xb0]
--
  40df22:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40df28:	4c 89 e8             	mov    rax,r13
  40df2b:	f0 48 0f b1 0a       	lock cmpxchg QWORD PTR [rdx],rcx
  40df30:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40df33:	84 c0                	test   al,al
  40df35:	74 f1                	je     40df28 <missing_captbl_node_expand+0x158>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40df37:	49 8b 5f 38          	mov    rbx,QWORD PTR [r15+0x38]
  40df3b:	83 e3 03             	and    ebx,0x3
  40df3e:	0f 84 2c 01 00 00    	je     40e070 <missing_captbl_node_expand+0x2a0>
        __asm__ __volatile__("lock " PS_FAA_STR
  40df44:	bb 04 00 00 00       	mov    ebx,0x4
--
  40df83:	49 b8 98 df 40 00 00 	movabs r8,0x40df98
  40df8a:	00 00 00 
  40df8d:	0f 05                	syscall 
  40df8f:	90                   	nop
  40df90:	eb 0d                	jmp    40df9f <missing_captbl_node_expand+0x1cf>
  40df92:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40df98:	b9 00 00 00 00       	mov    ecx,0x0
  40df9d:	eb 05                	jmp    40dfa4 <missing_captbl_node_expand+0x1d4>
  40df9f:	b9 01 00 00 00       	mov    ecx,0x1
  40dfa4:	5d                   	pop    rbp
  40dfa5:	5c                   	pop    rsp
				if (call_cap_op(root_source->captbl_cap, CAPTBL_OP_CAPTBLACTIVATE, frontier, root_source->mi.pgtbl_cap, kmem, 1)) {
  40dfa6:	85 c0                	test   eax,eax
  40dfa8:	0f 85 b4 02 00 00    	jne    40e262 <missing_captbl_node_expand+0x492>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40dfae:	41 8b 42 08          	mov    eax,DWORD PTR [r10+0x8]
--
  40dfd1:	49 b8 e8 df 40 00 00 	movabs r8,0x40dfe8
  40dfd8:	00 00 00 
  40dfdb:	0f 05                	syscall 
  40dfdd:	0f 1f 00             	nop    DWORD PTR [rax]
  40dfe0:	eb 0d                	jmp    40dfef <missing_captbl_node_expand+0x21f>
  40dfe2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40dfe8:	b9 00 00 00 00       	mov    ecx,0x0
  40dfed:	eb 05                	jmp    40dff4 <missing_captbl_node_expand+0x224>
  40dfef:	b9 01 00 00 00       	mov    ecx,0x1
  40dff4:	5d                   	pop    rbp
  40dff5:	5c                   	pop    rsp
				if (call_cap_op(ci->captbl_cap, CAPTBL_OP_CONS, frontier, test_cap, 0, 0)) {
  40dff6:	85 c0                	test   eax,eax
  40dff8:	0f 84 9a fe ff ff    	je     40de98 <missing_captbl_node_expand+0xc8>
					ret = call_cap_op(root_source->captbl_cap, CAPTBL_OP_CAPCHECK, ci->captbl_cap, 384, 0, 0);
  40dffe:	49 8b 47 08          	mov    rax,QWORD PTR [r15+0x8]
  40e002:	49 8b 5a 08          	mov    rbx,QWORD PTR [r10+0x8]
--
  40e021:	49 b8 38 e0 40 00 00 	movabs r8,0x40e038
  40e028:	00 00 00 
  40e02b:	0f 05                	syscall 
  40e02d:	0f 1f 00             	nop    DWORD PTR [rax]
  40e030:	eb 0d                	jmp    40e03f <missing_captbl_node_expand+0x26f>
  40e032:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e038:	b9 00 00 00 00       	mov    ecx,0x0
  40e03d:	eb 05                	jmp    40e044 <missing_captbl_node_expand+0x274>
  40e03f:	b9 01 00 00 00       	mov    ecx,0x1
  40e044:	5d                   	pop    rbp
--
  40e04b:	89 c6                	mov    esi,eax
  40e04d:	31 c0                	xor    eax,eax
  40e04f:	e8 5c e7 ff ff       	call   40c7b0 <printc.constprop.0>
  40e054:	be 2e 00 00 00       	mov    esi,0x2e
  40e059:	bf 20 dd 41 00       	mov    edi,0x41dd20
  40e05e:	e8 6d c0 ff ff       	call   40a0d0 <cos_print_str>
					assert(0); /* race? */
  40e063:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40e070:	4c 89 ff             	mov    rdi,r15
  40e073:	4c 89 55 a8          	mov    QWORD PTR [rbp-0x58],r10
  40e077:	e8 64 e9 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40e07c:	4c 8b 55 a8          	mov    r10,QWORD PTR [rbp-0x58]
  40e080:	85 c0                	test   eax,eax
  40e082:	0f 85 c7 fe ff ff    	jne    40df4f <missing_captbl_node_expand+0x17f>
        __asm__ __volatile__("lock " PS_FAA_STR
  40e088:	b8 04 00 00 00       	mov    eax,0x4
--
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40e093:	49 89 47 38          	mov    QWORD PTR [r15+0x38],rax
  40e097:	e9 a8 fe ff ff       	jmp    40df44 <missing_captbl_node_expand+0x174>
  40e09c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		if (cap_frontier >= CAPTBL_EXPAND_SZ) {
  40e0a0:	48 83 f8 7f          	cmp    rax,0x7f
  40e0a4:	76 2b                	jbe    40e0d1 <missing_captbl_node_expand+0x301>
		}
--
  40e0b5:	be 2e 00 00 00       	mov    esi,0x2e
  40e0ba:	bf c0 dc 41 00       	mov    edi,0x41dcc0
  40e0bf:	e8 0c c0 ff ff       	call   40a0d0 <cos_print_str>
				assert(kmem); /* FIXME: should have a failure semantics for capids */
  40e0c4:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40e0cf:	0f 0b                	ud2    
		while (test_cap < caprange_frontier) {
  40e0d1:	48 81 fe 80 00 00 00 	cmp    rsi,0x80
  40e0d8:	76 cc                	jbe    40e0a6 <missing_captbl_node_expand+0x2d6>
  40e0da:	48 8d 45 c0          	lea    rax,[rbp-0x40]
--
  40e0e4:	45 31 d2             	xor    r10d,r10d
  40e0e7:	48 89 45 b8          	mov    QWORD PTR [rbp-0x48],rax
  40e0eb:	eb 10                	jmp    40e0fd <missing_captbl_node_expand+0x32d>
  40e0ed:	0f 1f 00             	nop    DWORD PTR [rax]
			test_cap += CAPTBL_EXPAND_SZ * 2;
  40e0f0:	49 81 c5 00 01 00 00 	add    r13,0x100
		while (test_cap < caprange_frontier) {
  40e0f7:	4c 39 6d b0          	cmp    QWORD PTR [rbp-0x50],r13
  40e0fb:	76 a9                	jbe    40e0a6 <missing_captbl_node_expand+0x2d6>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
--
  40e129:	49 b8 40 e1 40 00 00 	movabs r8,0x40e140
  40e130:	00 00 00 
  40e133:	0f 05                	syscall 
  40e135:	0f 1f 00             	nop    DWORD PTR [rax]
  40e138:	eb 0d                	jmp    40e147 <missing_captbl_node_expand+0x377>
  40e13a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e140:	b9 00 00 00 00       	mov    ecx,0x0
  40e145:	eb 05                	jmp    40e14c <missing_captbl_node_expand+0x37c>
  40e147:	b9 01 00 00 00       	mov    ecx,0x1
  40e14c:	5d                   	pop    rbp
--
			if (ret) {
  40e14e:	85 c0                	test   eax,eax
  40e150:	74 9e                	je     40e0f0 <missing_captbl_node_expand+0x320>
	return __mem_bump_alloc(ci, 1, 1);
  40e152:	4c 89 ff             	mov    rdi,r15
--
  40e155:	49 8d 5d fc          	lea    rbx,[r13-0x4]
	return __mem_bump_alloc(ci, 1, 1);
  40e159:	e8 02 e7 ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
				assert(kmem); /* FIXME: should have a failure semantics for capids */
  40e15e:	45 31 d2             	xor    r10d,r10d
--
				assert(kmem); /* FIXME: should have a failure semantics for capids */
  40e164:	48 85 c0             	test   rax,rax
  40e167:	0f 84 bd 00 00 00    	je     40e22a <missing_captbl_node_expand+0x45a>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e16d:	41 8b 47 08          	mov    eax,DWORD PTR [r15+0x8]
--
  40e191:	49 b8 a8 e1 40 00 00 	movabs r8,0x40e1a8
  40e198:	00 00 00 
  40e19b:	0f 05                	syscall 
  40e19d:	0f 1f 00             	nop    DWORD PTR [rax]
  40e1a0:	eb 0d                	jmp    40e1af <missing_captbl_node_expand+0x3df>
  40e1a2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e1a8:	b9 00 00 00 00       	mov    ecx,0x0
  40e1ad:	eb 05                	jmp    40e1b4 <missing_captbl_node_expand+0x3e4>
  40e1af:	b9 01 00 00 00       	mov    ecx,0x1
  40e1b4:	5d                   	pop    rbp
  40e1b5:	5c                   	pop    rsp
				if (call_cap_op(root_source->captbl_cap, CAPTBL_OP_CAPTBLACTIVATE, frontier, root_source->mi.pgtbl_cap, kmem, 1)) {
  40e1b6:	85 c0                	test   eax,eax
  40e1b8:	0f 85 c0 00 00 00    	jne    40e27e <missing_captbl_node_expand+0x4ae>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e1be:	41 8b 47 08          	mov    eax,DWORD PTR [r15+0x8]
--
  40e1e1:	49 b8 f8 e1 40 00 00 	movabs r8,0x40e1f8
  40e1e8:	00 00 00 
  40e1eb:	0f 05                	syscall 
  40e1ed:	0f 1f 00             	nop    DWORD PTR [rax]
  40e1f0:	eb 0d                	jmp    40e1ff <missing_captbl_node_expand+0x42f>
  40e1f2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e1f8:	b9 00 00 00 00       	mov    ecx,0x0
  40e1fd:	eb 05                	jmp    40e204 <missing_captbl_node_expand+0x434>
  40e1ff:	b9 01 00 00 00       	mov    ecx,0x1
  40e204:	5d                   	pop    rbp
  40e205:	5c                   	pop    rsp
				if (call_cap_op(root_source->captbl_cap, CAPTBL_OP_CONS, frontier, test_cap, 0, 0)) {
  40e206:	85 c0                	test   eax,eax
  40e208:	0f 84 e2 fe ff ff    	je     40e0f0 <missing_captbl_node_expand+0x320>
  40e20e:	be 2e 00 00 00       	mov    esi,0x2e
  40e213:	bf 60 dc 41 00       	mov    edi,0x41dc60
  40e218:	e8 b3 be ff ff       	call   40a0d0 <cos_print_str>
					assert(0); /* race? */
  40e21d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40e22a:	be 2e 00 00 00       	mov    esi,0x2e
  40e22f:	bf 00 dc 41 00       	mov    edi,0x41dc00
  40e234:	e8 97 be ff ff       	call   40a0d0 <cos_print_str>
				assert(kmem); /* FIXME: should have a failure semantics for capids */
  40e239:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40e246:	be 2e 00 00 00       	mov    esi,0x2e
  40e24b:	bf 90 dc 41 00       	mov    edi,0x41dc90
  40e250:	e8 7b be ff ff       	call   40a0d0 <cos_print_str>
		assert(!ret);
  40e255:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40e262:	be 2e 00 00 00       	mov    esi,0x2e
  40e267:	bf f0 dc 41 00       	mov    edi,0x41dcf0
  40e26c:	e8 5f be ff ff       	call   40a0d0 <cos_print_str>
					assert(0); /* race condition? */
  40e271:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40e27e:	be 2e 00 00 00       	mov    esi,0x2e
  40e283:	bf 30 dc 41 00       	mov    edi,0x41dc30
  40e288:	e8 43 be ff ff       	call   40a0d0 <cos_print_str>
					assert(0); /* race condition? */
  40e28d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40e2c7:	0f 29 4d b0          	movaps XMMWORD PTR [rbp-0x50],xmm1
	missing_captbl_node_expand(ci);
  40e2cb:	e8 00 fb ff ff       	call   40ddd0 <missing_captbl_node_expand>
	// printc("mmp???:cap_frontier:%d, ci->cap_frontier:%d, ci->caprange_frontier:%d\n", cap_frontier, ci->cap_frontier, ci->caprange_frontier);
	if (cap_frontier <= ci->cap_frontier) return;
  40e2d0:	4d 39 75 18          	cmp    QWORD PTR [r13+0x18],r14
  40e2d4:	0f 83 1b 01 00 00    	jae    40e3f5 <cos_comp_capfrontier_update+0x155>

	if (try_expand) {
  40e2da:	45 85 ff             	test   r15d,r15d
  40e2dd:	0f 84 cd 00 00 00    	je     40e3b0 <cos_comp_capfrontier_update+0x110>
        __asm__ __volatile__("lock " PS_CAS_STR
  40e2e3:	41 bf 01 00 00 00    	mov    r15d,0x1
		while (cap_frontier > ci->caprange_frontier) {
  40e2e9:	49 8b 45 20          	mov    rax,QWORD PTR [r13+0x20]
  40e2ed:	4c 39 f0             	cmp    rax,r14
  40e2f0:	0f 83 ba 00 00 00    	jae    40e3b0 <cos_comp_capfrontier_update+0x110>
  40e2f6:	4d 8b 65 60          	mov    r12,QWORD PTR [r13+0x60]
--
  40e2ff:	49 89 45 18          	mov    QWORD PTR [r13+0x18],rax
	assert(__compinfo_metacap(meta) == meta);
  40e303:	4c 39 e2             	cmp    rdx,r12
  40e306:	0f 85 f7 01 00 00    	jne    40e503 <cos_comp_capfrontier_update+0x263>
		frontier = ps_load(&ci->caprange_frontier) - CAPMAX_ENTRY_SZ;
  40e30c:	49 8b 5d 20          	mov    rbx,QWORD PTR [r13+0x20]
	if (self_resources) {
  40e310:	49 39 d5             	cmp    r13,rdx
  40e313:	0f 84 ef 00 00 00    	je     40e408 <cos_comp_capfrontier_update+0x168>
	assert(ci->cap_frontier <= frontier);
  40e319:	48 39 d8             	cmp    rax,rbx
  40e31c:	0f 87 fd 01 00 00    	ja     40e51f <cos_comp_capfrontier_update+0x27f>
	if (likely(ci->cap_frontier != frontier)) return 0;
  40e322:	75 db                	jne    40e2ff <cos_comp_capfrontier_update+0x5f>
	return __mem_bump_alloc(ci, 1, 1);
  40e324:	4c 89 ef             	mov    rdi,r13
  40e327:	e8 34 e5 ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40e32c:	49 89 c2             	mov    r10,rax
	assert(kmem); /* FIXME: should have a failure semantics for capids */
  40e32f:	48 85 c0             	test   rax,rax
  40e332:	0f 84 81 02 00 00    	je     40e5b9 <cos_comp_capfrontier_update+0x319>
	if (self_resources) {
  40e338:	4d 39 e5             	cmp    r13,r12
  40e33b:	0f 84 e6 00 00 00    	je     40e427 <cos_comp_capfrontier_update+0x187>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40e341:	49 8d 94 24 b0 00 00 	lea    rdx,[r12+0xb0]
--
  40e34b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40e350:	48 89 c8             	mov    rax,rcx
  40e353:	f0 4c 0f b1 3a       	lock cmpxchg QWORD PTR [rdx],r15
  40e358:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40e35b:	84 c0                	test   al,al
  40e35d:	74 f1                	je     40e350 <cos_comp_capfrontier_update+0xb0>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40e35f:	41 f6 44 24 38 03    	test   BYTE PTR [r12+0x38],0x3
  40e365:	0f 84 24 02 00 00    	je     40e58f <cos_comp_capfrontier_update+0x2ef>
        __asm__ __volatile__("lock " PS_FAA_STR
  40e36b:	bb 04 00 00 00       	mov    ebx,0x4
--
		assert(captblcap);
  40e383:	48 85 db             	test   rbx,rbx
  40e386:	0f 85 9b 00 00 00    	jne    40e427 <cos_comp_capfrontier_update+0x187>
  40e38c:	be 2e 00 00 00       	mov    esi,0x2e
  40e391:	bf c0 d7 41 00       	mov    edi,0x41d7c0
  40e396:	e8 35 bd ff ff       	call   40a0d0 <cos_print_str>
  40e39b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e3a2:	00 00 00 00 
--
  40e3b0:	49 8d 46 03          	lea    rax,[r14+0x3]
  40e3b4:	48 83 e0 fc          	and    rax,0xfffffffffffffffc
  40e3b8:	49 39 c6             	cmp    r14,rax
  40e3bb:	0f 85 96 01 00 00    	jne    40e557 <cos_comp_capfrontier_update+0x2b7>
	ci->cap_frontier = cap_frontier;
  40e3c1:	4d 89 75 18          	mov    QWORD PTR [r13+0x18],r14
	if (cap_frontier < CAPTBL_EXPAND_SZ) {
  40e3c5:	49 83 fe 7f          	cmp    r14,0x7f
  40e3c9:	76 4d                	jbe    40e418 <cos_comp_capfrontier_update+0x178>
		ci->caprange_frontier = round_up_to_pow2(cap_frontier + CAPTBL_EXPAND_SZ, CAPTBL_EXPAND_SZ * 2) - CAPTBL_EXPAND_SZ;
--
		frontier = ps_load(&ci->caprange_frontier) - CAPMAX_ENTRY_SZ;
  40e408:	48 83 eb 04          	sub    rbx,0x4
  40e40c:	e9 08 ff ff ff       	jmp    40e319 <cos_comp_capfrontier_update+0x79>
  40e411:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		ci->caprange_frontier = round_up_to_pow2(cap_frontier, CAPTBL_EXPAND_SZ);
--
  40e41c:	48 83 e0 80          	and    rax,0xffffffffffffff80
  40e420:	66 48 0f 6e c0       	movq   xmm0,rax
  40e425:	eb b6                	jmp    40e3dd <cos_comp_capfrontier_update+0x13d>
	captblid_add = ps_load(&ci->caprange_frontier);
  40e427:	49 8b 45 20          	mov    rax,QWORD PTR [r13+0x20]
--
  40e42f:	83 e0 7f             	and    eax,0x7f
  40e432:	48 89 45 a0          	mov    QWORD PTR [rbp-0x60],rax
  40e436:	0f 85 99 01 00 00    	jne    40e5d5 <cos_comp_capfrontier_update+0x335>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e43c:	41 8b 44 24 08       	mov    eax,DWORD PTR [r12+0x8]
--
  40e465:	49 b8 80 e4 40 00 00 	movabs r8,0x40e480
  40e46c:	00 00 00 
  40e46f:	0f 05                	syscall 
  40e471:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  40e478:	eb 0d                	jmp    40e487 <cos_comp_capfrontier_update+0x1e7>
  40e47a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e480:	b9 00 00 00 00       	mov    ecx,0x0
  40e485:	eb 05                	jmp    40e48c <cos_comp_capfrontier_update+0x1ec>
  40e487:	b9 01 00 00 00       	mov    ecx,0x1
  40e48c:	5d                   	pop    rbp
  40e48d:	5c                   	pop    rsp
	if (call_cap_op(meta->captbl_cap, CAPTBL_OP_CAPTBLACTIVATE, captblcap, meta->mi.pgtbl_cap, kmem, 1)) {
  40e48e:	85 c0                	test   eax,eax
  40e490:	0f 85 a5 00 00 00    	jne    40e53b <cos_comp_capfrontier_update+0x29b>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e496:	41 8b 45 08          	mov    eax,DWORD PTR [r13+0x8]
--
  40e4bb:	49 b8 d0 e4 40 00 00 	movabs r8,0x40e4d0
  40e4c2:	00 00 00 
  40e4c5:	0f 05                	syscall 
  40e4c7:	90                   	nop
  40e4c8:	eb 0d                	jmp    40e4d7 <cos_comp_capfrontier_update+0x237>
  40e4ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e4d0:	b9 00 00 00 00       	mov    ecx,0x0
  40e4d5:	eb 05                	jmp    40e4dc <cos_comp_capfrontier_update+0x23c>
  40e4d7:	b9 01 00 00 00       	mov    ecx,0x1
  40e4dc:	5d                   	pop    rbp
  40e4dd:	5c                   	pop    rsp
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_CONS, captblcap, captblid_add, 0, 0)) {
  40e4de:	85 c0                	test   eax,eax
  40e4e0:	0f 85 8d 00 00 00    	jne    40e573 <cos_comp_capfrontier_update+0x2d3>
	frontier       = ps_load(&ci->cap_frontier);
  40e4e6:	49 8b 45 18          	mov    rax,QWORD PTR [r13+0x18]
--
  40e4ef:	f0 49 0f c1 55 20    	lock xadd QWORD PTR [r13+0x20],rdx
        __asm__ __volatile__("lock " PS_CAS_STR
  40e4f5:	f0 49 0f b1 55 18    	lock cmpxchg QWORD PTR [r13+0x18],rdx
  40e4fb:	0f 94 c0             	sete   al
	return 0;
  40e4fe:	e9 e6 fd ff ff       	jmp    40e2e9 <cos_comp_capfrontier_update+0x49>
  40e503:	be 2e 00 00 00       	mov    esi,0x2e
  40e508:	bf 30 d7 41 00       	mov    edi,0x41d730
  40e50d:	e8 be bb ff ff       	call   40a0d0 <cos_print_str>
	assert(__compinfo_metacap(meta) == meta);
  40e512:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40e51f:	be 2e 00 00 00       	mov    esi,0x2e
  40e524:	bf 60 d7 41 00       	mov    edi,0x41d760
  40e529:	e8 a2 bb ff ff       	call   40a0d0 <cos_print_str>
	assert(ci->cap_frontier <= frontier);
  40e52e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40e53b:	be 2e 00 00 00       	mov    esi,0x2e
  40e540:	bf 20 d8 41 00       	mov    edi,0x41d820
  40e545:	e8 86 bb ff ff       	call   40a0d0 <cos_print_str>
		assert(0); /* race condition? */
  40e54a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40e557:	be 2e 00 00 00       	mov    esi,0x2e
  40e55c:	bf f0 da 41 00       	mov    edi,0x41daf0
  40e561:	e8 6a bb ff ff       	call   40a0d0 <cos_print_str>
	assert(round_up_to_pow2(cap_frontier, CAPMAX_ENTRY_SZ) == cap_frontier);
  40e566:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40e573:	be 2e 00 00 00       	mov    esi,0x2e
  40e578:	bf 50 d8 41 00       	mov    edi,0x41d850
  40e57d:	e8 4e bb ff ff       	call   40a0d0 <cos_print_str>
		assert(0); /* race? */
  40e582:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40e58f:	4c 89 e7             	mov    rdi,r12
  40e592:	4c 89 55 a8          	mov    QWORD PTR [rbp-0x58],r10
  40e596:	e8 45 e4 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40e59b:	4c 8b 55 a8          	mov    r10,QWORD PTR [rbp-0x58]
  40e59f:	85 c0                	test   eax,eax
  40e5a1:	75 4e                	jne    40e5f1 <cos_comp_capfrontier_update+0x351>
        __asm__ __volatile__("lock " PS_FAA_STR
  40e5a3:	b8 04 00 00 00       	mov    eax,0x4
--
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40e5af:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  40e5b4:	e9 b2 fd ff ff       	jmp    40e36b <cos_comp_capfrontier_update+0xcb>
  40e5b9:	be 2e 00 00 00       	mov    esi,0x2e
  40e5be:	bf 90 d7 41 00       	mov    edi,0x41d790
  40e5c3:	e8 08 bb ff ff       	call   40a0d0 <cos_print_str>
	assert(kmem); /* FIXME: should have a failure semantics for capids */
  40e5c8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40e5d5:	be 2e 00 00 00       	mov    esi,0x2e
  40e5da:	bf f0 d7 41 00       	mov    edi,0x41d7f0
  40e5df:	e8 ec ba ff ff       	call   40a0d0 <cos_print_str>
	assert(captblid_add % CAPTBL_EXPAND_SZ == 0);
  40e5e4:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40e5f8:	00 00 00 00 00 
		assert(captblcap);
  40e5fd:	e9 8a fd ff ff       	jmp    40e38c <cos_comp_capfrontier_update+0xec>
  40e602:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40e609:	00 00 00 00 
--
	assert(ci_resources && ulkpt);
  40e65e:	4d 85 e4             	test   r12,r12
  40e661:	0f 84 7f 01 00 00    	je     40e7e6 <cos_ulk_page_alloc+0x1b6>
  40e667:	49 89 f5             	mov    r13,rsi
  40e66a:	48 85 f6             	test   rsi,rsi
  40e66d:	0f 84 73 01 00 00    	je     40e7e6 <cos_ulk_page_alloc+0x1b6>
	return __mem_bump_alloc(ci, 1, 1);
  40e673:	4c 89 e7             	mov    rdi,r12
  40e676:	44 89 4d bc          	mov    DWORD PTR [rbp-0x44],r9d
  40e67a:	e8 e1 e1 ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40e67f:	49 89 c6             	mov    r14,rax
	if (!*kmem) return -1;
  40e682:	48 85 c0             	test   rax,rax
  40e685:	0f 84 77 01 00 00    	je     40e802 <cos_ulk_page_alloc+0x1d2>
        __asm__ __volatile__("lock " PS_CAS_STR
  40e68b:	44 8b 4d bc          	mov    r9d,DWORD PTR [rbp-0x44]
--
  40e69f:	90                   	nop
  40e6a0:	4c 89 c0             	mov    rax,r8
  40e6a3:	f0 48 0f b1 11       	lock cmpxchg QWORD PTR [rcx],rdx
  40e6a8:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40e6ab:	84 c0                	test   al,al
  40e6ad:	74 f1                	je     40e6a0 <cos_ulk_page_alloc+0x70>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40e6af:	4d 8b 7c 24 30       	mov    r15,QWORD PTR [r12+0x30]
  40e6b4:	41 83 e7 03          	and    r15d,0x3
  40e6b8:	0f 84 b2 00 00 00    	je     40e770 <cos_ulk_page_alloc+0x140>
        __asm__ __volatile__("lock " PS_FAA_STR
  40e6be:	bb 02 00 00 00       	mov    ebx,0x2
--
	if (!*cap) return -1;
  40e6d9:	48 85 db             	test   rbx,rbx
  40e6dc:	0f 84 20 01 00 00    	je     40e802 <cos_ulk_page_alloc+0x1d2>

	if (__alloc_mem_cap(ci_resources, CAP_ULK, &kmem, &cap)) return 0;
	assert(kmem && (round_to_page(kmem) == kmem));
  40e6e2:	41 f7 c6 ff 0f 00 00 	test   r14d,0xfff
  40e6e9:	0f 85 db 00 00 00    	jne    40e7ca <cos_ulk_page_alloc+0x19a>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e6ef:	41 8b 44 24 08       	mov    eax,DWORD PTR [r12+0x8]
	if (call_cap_op(ci_resources->captbl_cap, CAPTBL_OP_ULK_MEMACTIVATE, cap << 16 | lid, ci_resources->mi.pgtbl_cap << 16 | ulkpt, kmem, uaddr))
  40e6f4:	48 c1 e3 10          	shl    rbx,0x10
  40e6f8:	45 89 c9             	mov    r9d,r9d
--
  40e72d:	49 b8 48 e7 40 00 00 	movabs r8,0x40e748
  40e734:	00 00 00 
  40e737:	0f 05                	syscall 
  40e739:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  40e740:	eb 0d                	jmp    40e74f <cos_ulk_page_alloc+0x11f>
  40e742:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e748:	b9 00 00 00 00       	mov    ecx,0x0
  40e74d:	eb 05                	jmp    40e754 <cos_ulk_page_alloc+0x124>
  40e74f:	b9 01 00 00 00       	mov    ecx,0x1
  40e754:	5d                   	pop    rbp
  40e755:	5c                   	pop    rsp
  40e756:	85 c0                	test   eax,eax
  40e758:	75 46                	jne    40e7a0 <cos_ulk_page_alloc+0x170>
		BUG();

--
  40e770:	4c 89 e7             	mov    rdi,r12
  40e773:	44 89 4d bc          	mov    DWORD PTR [rbp-0x44],r9d
  40e777:	e8 64 e2 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40e77c:	44 8b 4d bc          	mov    r9d,DWORD PTR [rbp-0x44]
  40e780:	85 c0                	test   eax,eax
  40e782:	75 38                	jne    40e7bc <cos_ulk_page_alloc+0x18c>
        __asm__ __volatile__("lock " PS_FAA_STR
  40e784:	b8 04 00 00 00       	mov    eax,0x4
--
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40e790:	49 89 44 24 30       	mov    QWORD PTR [r12+0x30],rax
  40e795:	e9 24 ff ff ff       	jmp    40e6be <cos_ulk_page_alloc+0x8e>
  40e79a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e7a0:	be 1b 00 00 00       	mov    esi,0x1b
  40e7a5:	bf af dd 41 00       	mov    edi,0x41ddaf
  40e7aa:	e8 21 b9 ff ff       	call   40a0d0 <cos_print_str>
		BUG();
  40e7af:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40e7c3:	00 00 00 00 00 
	if (!*cap) return -1;
  40e7c8:	eb 90                	jmp    40e75a <cos_ulk_page_alloc+0x12a>
  40e7ca:	be 2e 00 00 00       	mov    esi,0x2e
  40e7cf:	bf 80 dd 41 00       	mov    edi,0x41dd80
  40e7d4:	e8 f7 b8 ff ff       	call   40a0d0 <cos_print_str>
	assert(kmem && (round_to_page(kmem) == kmem));
  40e7d9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40e7e6:	be 2e 00 00 00       	mov    esi,0x2e
  40e7eb:	bf 50 dd 41 00       	mov    edi,0x41dd50
  40e7f0:	e8 db b8 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci_resources && ulkpt);
  40e7f5:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	if (__alloc_mem_cap(ci_resources, CAP_ULK, &kmem, &cap)) return 0;
  40e802:	45 31 ff             	xor    r15d,r15d
  40e805:	e9 50 ff ff ff       	jmp    40e75a <cos_ulk_page_alloc+0x12a>
  40e80a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

--
	assert(ci && comp > 0);
  40e825:	48 85 ff             	test   rdi,rdi
  40e828:	0f 84 bb 01 00 00    	je     40e9e9 <__cos_thd_alloc+0x1d9>
  40e82e:	49 89 f7             	mov    r15,rsi
  40e831:	48 85 f6             	test   rsi,rsi
  40e834:	0f 84 af 01 00 00    	je     40e9e9 <__cos_thd_alloc+0x1d9>
	if (!__cos_ulk_info.toplvl) return 0;
  40e83a:	4c 8b 25 3f 22 19 00 	mov    r12,QWORD PTR [rip+0x19223f]        # 5a0a80 <__cos_ulk_info>
--
  40e844:	89 d3                	mov    ebx,edx
  40e846:	4d 85 e4             	test   r12,r12
  40e849:	74 46                	je     40e891 <__cos_thd_alloc+0x81>
	if (!__cos_ulk_info.curr_pg || tid % ULK_STACKS_PER_PAGE == 0) {
  40e84b:	48 8b 05 3e 22 19 00 	mov    rax,QWORD PTR [rip+0x19223e]        # 5a0a90 <__cos_ulk_info+0x10>
  40e852:	48 85 c0             	test   rax,rax
  40e855:	74 0a                	je     40e861 <__cos_thd_alloc+0x51>
  40e857:	f6 45 b8 0f          	test   BYTE PTR [rbp-0x48],0xf
  40e85b:	0f 85 4f 01 00 00    	jne    40e9b0 <__cos_thd_alloc+0x1a0>
		__cos_ulk_info.curr_pg = cos_ulk_page_alloc(ci, __cos_ulk_info.toplvl, __cos_ulk_info.pg_frontier);
  40e861:	48 8b 15 30 22 19 00 	mov    rdx,QWORD PTR [rip+0x192230]        # 5a0a98 <__cos_ulk_info+0x18>
  40e868:	4c 89 e6             	mov    rsi,r12
  40e86b:	4c 89 ef             	mov    rdi,r13
  40e86e:	e8 bd fd ff ff       	call   40e630 <cos_ulk_page_alloc>
  40e873:	48 89 05 16 22 19 00 	mov    QWORD PTR [rip+0x192216],rax        # 5a0a90 <__cos_ulk_info+0x10>
  40e87a:	49 89 c4             	mov    r12,rax
		assert(__cos_ulk_info.curr_pg);
  40e87d:	48 85 c0             	test   rax,rax
  40e880:	0f 84 9b 01 00 00    	je     40ea21 <__cos_thd_alloc+0x211>
		__cos_ulk_info.pg_frontier += PAGE_SIZE;
  40e886:	48 81 05 07 22 19 00 	add    QWORD PTR [rip+0x192207],0x1000        # 5a0a98 <__cos_ulk_info+0x18>
--
	return __mem_bump_alloc(ci, 1, 1);
  40e891:	4c 89 ef             	mov    rdi,r13
  40e894:	e8 c7 df ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40e899:	49 89 c2             	mov    r10,rax
	if (!*kmem) return -1;
  40e89c:	48 85 c0             	test   rax,rax
  40e89f:	0f 84 98 01 00 00    	je     40ea3d <__cos_thd_alloc+0x22d>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40e8a5:	49 8d 8d b0 00 00 00 	lea    rcx,[r13+0xb0]
--
  40e8b3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40e8b8:	48 89 f0             	mov    rax,rsi
  40e8bb:	f0 48 0f b1 11       	lock cmpxchg QWORD PTR [rcx],rdx
  40e8c0:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40e8c3:	84 c0                	test   al,al
  40e8c5:	74 f1                	je     40e8b8 <__cos_thd_alloc+0xa8>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40e8c7:	4d 8b 75 28          	mov    r14,QWORD PTR [r13+0x28]
  40e8cb:	41 83 e6 03          	and    r14d,0x3
  40e8cf:	0f 84 b3 00 00 00    	je     40e988 <__cos_thd_alloc+0x178>
        __asm__ __volatile__("lock " PS_FAA_STR
  40e8d5:	ba 01 00 00 00       	mov    edx,0x1
--
	if (!*cap) return -1;
  40e8ee:	48 85 d2             	test   rdx,rdx
  40e8f1:	0f 84 46 01 00 00    	je     40ea3d <__cos_thd_alloc+0x22d>

	ulkcap = __cos_thd_ulk_page_alloc(ci, tid);
--
	assert(!(init_data & ~((1 << 16) - 1)));
  40e8f7:	f7 c3 00 00 ff ff    	test   ebx,0xffff0000
  40e8fd:	0f 85 02 01 00 00    	jne    40ea05 <__cos_thd_alloc+0x1f5>
	/* TODO: Add cap size checking */
	ret = call_cap_op(ci->captbl_cap, CAPTBL_OP_THDACTIVATE, (init_data << 16) | cap,
  40e903:	c1 e3 10             	shl    ebx,0x10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
--
  40e92a:	4c 89 e2             	mov    rdx,r12
  40e92d:	48 c1 e2 10          	shl    rdx,0x10
	ret = call_cap_op(ci->captbl_cap, CAPTBL_OP_THDACTIVATE, (init_data << 16) | cap,
  40e931:	48 0b 55 b8          	or     rdx,QWORD PTR [rbp-0x48]
			  __compinfo_metacap(ci)->mi.pgtbl_cap << 16 | comp, kmem, ulkcap << 16 | tid);
  40e935:	48 c1 e6 10          	shl    rsi,0x10
	ret = call_cap_op(ci->captbl_cap, CAPTBL_OP_THDACTIVATE, (init_data << 16) | cap,
  40e939:	4c 09 fe             	or     rsi,r15
	__asm__ __volatile__(
--
  40e946:	49 b8 60 e9 40 00 00 	movabs r8,0x40e960
  40e94d:	00 00 00 
  40e950:	0f 05                	syscall 
  40e952:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e958:	eb 0d                	jmp    40e967 <__cos_thd_alloc+0x157>
  40e95a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e960:	b9 00 00 00 00       	mov    ecx,0x0
  40e965:	eb 05                	jmp    40e96c <__cos_thd_alloc+0x15c>
  40e967:	b9 01 00 00 00       	mov    ecx,0x1
  40e96c:	5d                   	pop    rbp
--
	if (ret) BUG();
  40e96e:	85 c0                	test   eax,eax
  40e970:	75 4e                	jne    40e9c0 <__cos_thd_alloc+0x1b0>

	return cap;
--
  40e988:	4c 89 ef             	mov    rdi,r13
  40e98b:	4c 89 55 b0          	mov    QWORD PTR [rbp-0x50],r10
  40e98f:	e8 4c e0 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40e994:	4c 8b 55 b0          	mov    r10,QWORD PTR [rbp-0x50]
  40e998:	85 c0                	test   eax,eax
  40e99a:	75 40                	jne    40e9dc <__cos_thd_alloc+0x1cc>
        __asm__ __volatile__("lock " PS_FAA_STR
  40e99c:	b8 04 00 00 00       	mov    eax,0x4
--
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40e9a7:	49 89 45 28          	mov    QWORD PTR [r13+0x28],rax
  40e9ab:	e9 25 ff ff ff       	jmp    40e8d5 <__cos_thd_alloc+0xc5>
  40e9b0:	49 89 c4             	mov    r12,rax
	return __cos_ulk_info.curr_pg;
  40e9b3:	e9 d9 fe ff ff       	jmp    40e891 <__cos_thd_alloc+0x81>
  40e9b8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40e9bf:	00 
  40e9c0:	be 1b 00 00 00       	mov    esi,0x1b
  40e9c5:	bf 5f de 41 00       	mov    edi,0x41de5f
  40e9ca:	e8 01 b7 ff ff       	call   40a0d0 <cos_print_str>
	if (ret) BUG();
  40e9cf:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40e9e3:	00 00 00 00 
	if (!*cap) return -1;
  40e9e7:	eb 89                	jmp    40e972 <__cos_thd_alloc+0x162>
  40e9e9:	be 2e 00 00 00       	mov    esi,0x2e
  40e9ee:	bf d0 dd 41 00       	mov    edi,0x41ddd0
  40e9f3:	e8 d8 b6 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci && comp > 0);
  40e9f8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40ea05:	be 2e 00 00 00       	mov    esi,0x2e
  40ea0a:	bf 30 de 41 00       	mov    edi,0x41de30
  40ea0f:	e8 bc b6 ff ff       	call   40a0d0 <cos_print_str>
	assert(!(init_data & ~((1 << 16) - 1)));
  40ea14:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40ea21:	be 2e 00 00 00       	mov    esi,0x2e
  40ea26:	bf 00 de 41 00       	mov    edi,0x41de00
  40ea2b:	e8 a0 b6 ff ff       	call   40a0d0 <cos_print_str>
		assert(__cos_ulk_info.curr_pg);
  40ea30:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	if (__alloc_mem_cap(ci, CAP_THD, &kmem, &cap)) return 0;
  40ea3d:	45 31 f6             	xor    r14d,r14d
  40ea40:	e9 2d ff ff ff       	jmp    40e972 <__cos_thd_alloc+0x162>
  40ea45:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40ea4c:	00 00 00 00 
--
	assert(ptc && __cos_ulk_info.secondlvl);
  40ea5f:	48 85 ff             	test   rdi,rdi
  40ea62:	74 67                	je     40eacb <cos_ulk_map_in+0x7b>
  40ea64:	48 8b 1d 1d 20 19 00 	mov    rbx,QWORD PTR [rip+0x19201d]        # 5a0a88 <__cos_ulk_info+0x8>
  40ea6b:	48 85 db             	test   rbx,rbx
  40ea6e:	74 5b                	je     40eacb <cos_ulk_map_in+0x7b>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40ea70:	c1 e7 10             	shl    edi,0x10
--
  40ea96:	49 b8 b0 ea 40 00 00 	movabs r8,0x40eab0
  40ea9d:	00 00 00 
  40eaa0:	0f 05                	syscall 
  40eaa2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40eaa8:	eb 0d                	jmp    40eab7 <cos_ulk_map_in+0x67>
  40eaaa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40eab0:	b9 00 00 00 00       	mov    ecx,0x0
  40eab5:	eb 05                	jmp    40eabc <cos_ulk_map_in+0x6c>
  40eab7:	b9 01 00 00 00       	mov    ecx,0x1
  40eabc:	5d                   	pop    rbp
  40eabd:	5c                   	pop    rsp
	if (call_cap_op(ptc, CAPTBL_OP_CONS, __cos_ulk_info.secondlvl, ULK_BASE_ADDR, 0, 0)) {
  40eabe:	f7 d8                	neg    eax
  40eac0:	19 c0                	sbb    eax,eax
--
  40eacb:	be 2e 00 00 00       	mov    esi,0x2e
  40ead0:	bf 80 de 41 00       	mov    edi,0x41de80
  40ead5:	e8 f6 b5 ff ff       	call   40a0d0 <cos_print_str>
	assert(ptc && __cos_ulk_info.secondlvl);
  40eada:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--

	return __cos_thd_alloc(ci, comp, idx, tid);
  40eb06:	e9 05 fd ff ff       	jmp    40e810 <__cos_thd_alloc>
  40eb0b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
}
--
	if (!fn) return -1;
  40eb35:	48 85 d2             	test   rdx,rdx
  40eb38:	0f 84 c9 00 00 00    	je     40ec07 <cos_thd_alloc+0xe7>
  40eb3e:	55                   	push   rbp
  40eb3f:	49 89 f8             	mov    r8,rdi
--
  40eb5b:	31 f6                	xor    esi,esi
		if (__thd_init_data[i].fn == NULL) {
  40eb5d:	48 83 3a 00          	cmp    QWORD PTR [rdx],0x0
  40eb61:	74 1d                	je     40eb80 <cos_thd_alloc+0x60>
	for (i = 0; i < COS_THD_INIT_REGION_SIZE; i++) {
  40eb63:	83 c6 01             	add    esi,0x1
  40eb66:	48 83 c2 10          	add    rdx,0x10
  40eb6a:	81 fe 00 01 00 00    	cmp    esi,0x100
  40eb70:	75 eb                	jne    40eb5d <cos_thd_alloc+0x3d>
	if (!tried) {
  40eb72:	83 fb 01             	cmp    ebx,0x1
  40eb75:	74 6d                	je     40ebe4 <cos_thd_alloc+0xc4>
  40eb77:	bb 01 00 00 00       	mov    ebx,0x1
  40eb7c:	eb d8                	jmp    40eb56 <cos_thd_alloc+0x36>
  40eb7e:	66 90                	xchg   ax,ax
  40eb80:	4c 89 d8             	mov    rax,r11
  40eb83:	f0 48 0f b1 3a       	lock cmpxchg QWORD PTR [rdx],rdi
  40eb88:	0f 94 c0             	sete   al
			if (!ret) continue;
  40eb8b:	84 c0                	test   al,al
  40eb8d:	74 d4                	je     40eb63 <cos_thd_alloc+0x43>
			assert(__thd_init_data[i].fn == fn);
  40eb8f:	4c 63 e6             	movsxd r12,esi
--
  40eb96:	49 8d 84 24 40 f9 59 	lea    rax,[r12+0x59f940]
  40eb9d:	00 
  40eb9e:	49 3b bc 24 40 f9 59 	cmp    rdi,QWORD PTR [r12+0x59f940]
  40eba5:	00 
  40eba6:	75 43                	jne    40ebeb <cos_thd_alloc+0xcb>
			__thd_init_data[i].data = data;
  40eba8:	4c 89 50 08          	mov    QWORD PTR [rax+0x8],r10
--
  40ebb2:	4c 89 ce             	mov    rsi,r9
  40ebb5:	89 da                	mov    edx,ebx
  40ebb7:	e8 54 fc ff ff       	call   40e810 <__cos_thd_alloc>
	if (!ret) cos_thd_init_free(idx);
  40ebbc:	48 85 c0             	test   rax,rax
  40ebbf:	75 1e                	jne    40ebdf <cos_thd_alloc+0xbf>
 * thread creation failed for some reason.
 */
--
  40ebc1:	48 63 f3             	movsxd rsi,ebx
  40ebc4:	48 c1 e6 04          	shl    rsi,0x4
  40ebc8:	48 83 be 40 f9 59 00 	cmp    QWORD PTR [rsi+0x59f940],0x0
  40ebcf:	00 
  40ebd0:	74 12                	je     40ebe4 <cos_thd_alloc+0xc4>
	__thd_init_data[idx].fn   = NULL;
  40ebd2:	66 0f ef c0          	pxor   xmm0,xmm0
--
  40ebeb:	be 67 00 00 00       	mov    esi,0x67
  40ebf0:	bf b0 de 41 00       	mov    edi,0x41deb0
  40ebf5:	e8 d6 b4 ff ff       	call   40a0d0 <cos_print_str>
			assert(__thd_init_data[i].fn == fn);
  40ebfa:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--

	assert(meta == __compinfo_metacap(meta));
  40ec25:	4d 39 64 24 60       	cmp    QWORD PTR [r12+0x60],r12
  40ec2a:	0f 85 9c 00 00 00    	jne    40eccc <cos_shared_kernel_page_alloc_at+0xbc>
  40ec30:	48 89 fb             	mov    rbx,rdi
	return __mem_bump_alloc(ci, 1, 1);
  40ec33:	4c 89 e7             	mov    rdi,r12
  40ec36:	49 89 f5             	mov    r13,rsi
  40ec39:	e8 22 dc ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40ec3e:	49 89 c2             	mov    r10,rax

--
	assert(ptemem_cap != 0);
  40ec41:	48 85 c0             	test   rax,rax
  40ec44:	0f 84 9e 00 00 00    	je     40ece8 <cos_shared_kernel_page_alloc_at+0xd8>
  40ec4a:	48 8b 33             	mov    rsi,QWORD PTR [rbx]
  40ec4d:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
--

	/* Actually map in the memory. */
	ret = call_cap_op(meta->mi.pgtbl_cap, CAPTBL_OP_MEMACTIVATE, ptemem_cap, ci->pgtbl_cap, mem_ptr, PAGE_ORDER);
  40ec59:	49 8b 84 24 98 00 00 	mov    rax,QWORD PTR [r12+0x98]
  40ec60:	00 
--
  40ec76:	49 b8 90 ec 40 00 00 	movabs r8,0x40ec90
  40ec7d:	00 00 00 
  40ec80:	0f 05                	syscall 
  40ec82:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40ec88:	eb 0d                	jmp    40ec97 <cos_shared_kernel_page_alloc_at+0x87>
  40ec8a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40ec90:	b9 00 00 00 00       	mov    ecx,0x0
  40ec95:	eb 05                	jmp    40ec9c <cos_shared_kernel_page_alloc_at+0x8c>
  40ec97:	b9 01 00 00 00       	mov    ecx,0x1
  40ec9c:	5d                   	pop    rbp
--
	if (ret) {
  40ec9e:	85 c0                	test   eax,eax
  40eca0:	75 0e                	jne    40ecb0 <cos_shared_kernel_page_alloc_at+0xa0>
		BUG();
	}
--
  40ecb0:	be 1c 00 00 00       	mov    esi,0x1c
  40ecb5:	bf 78 df 41 00       	mov    edi,0x41df78
  40ecba:	e8 11 b4 ff ff       	call   40a0d0 <cos_print_str>
		BUG();
  40ecbf:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40eccc:	be 2f 00 00 00       	mov    esi,0x2f
  40ecd1:	bf 18 df 41 00       	mov    edi,0x41df18
  40ecd6:	e8 f5 b3 ff ff       	call   40a0d0 <cos_print_str>
	assert(meta == __compinfo_metacap(meta));
  40ecdb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40ece8:	be 2f 00 00 00       	mov    esi,0x2f
  40eced:	bf 48 df 41 00       	mov    edi,0x41df48
  40ecf2:	e8 d9 b3 ff ff       	call   40a0d0 <cos_print_str>
	assert(ptemem_cap != 0);
  40ecf7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--

	assert(meta == __compinfo_metacap(meta));
  40ed27:	4d 39 76 60          	cmp    QWORD PTR [r14+0x60],r14
  40ed2b:	0f 85 bb 00 00 00    	jne    40edec <cos_shared_kernel_page_alloc+0xdc>
  40ed31:	49 89 fc             	mov    r12,rdi
  40ed34:	49 89 f5             	mov    r13,rsi
	return __mem_bump_alloc(ci, 1, 1);
  40ed37:	e8 24 db ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40ed3c:	48 89 c3             	mov    rbx,rax

--
	assert(kmem);
  40ed3f:	48 85 c0             	test   rax,rax
  40ed42:	0f 84 c0 00 00 00    	je     40ee08 <cos_shared_kernel_page_alloc+0xf8>

	heap_vaddr = __page_bump_valloc(ci, PAGE_SIZE, PAGE_SIZE);
--
  40ed4d:	be 00 10 00 00       	mov    esi,0x1000
  40ed52:	4c 89 e7             	mov    rdi,r12
  40ed55:	e8 c6 e1 ff ff       	call   40cf20 <__page_bump_valloc>
  40ed5a:	49 89 c2             	mov    r10,rax
	assert(heap_vaddr);
  40ed5d:	48 85 c0             	test   rax,rax
  40ed60:	0f 84 be 00 00 00    	je     40ee24 <cos_shared_kernel_page_alloc+0x114>
  40ed66:	49 8b 34 24          	mov    rsi,QWORD PTR [r12]
  40ed6a:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
--
  40ed73:	4c 89 d7             	mov    rdi,r10

	ret = call_cap_op(meta->mi.pgtbl_cap, CAPTBL_OP_MEMACTIVATE, kmem, ci->pgtbl_cap, heap_vaddr, PAGE_ORDER);
  40ed76:	49 8b 86 98 00 00 00 	mov    rax,QWORD PTR [r14+0x98]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
--
  40ed8f:	49 b8 a8 ed 40 00 00 	movabs r8,0x40eda8
  40ed96:	00 00 00 
  40ed99:	0f 05                	syscall 
  40ed9b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40eda0:	eb 0d                	jmp    40edaf <cos_shared_kernel_page_alloc+0x9f>
  40eda2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40eda8:	b9 00 00 00 00       	mov    ecx,0x0
  40edad:	eb 05                	jmp    40edb4 <cos_shared_kernel_page_alloc+0xa4>
  40edaf:	b9 01 00 00 00       	mov    ecx,0x1
  40edb4:	5d                   	pop    rbp
--
	if (ret) {
  40edb6:	85 c0                	test   eax,eax
  40edb8:	75 16                	jne    40edd0 <cos_shared_kernel_page_alloc+0xc0>
		BUG();
	}
--
  40edd0:	be 1c 00 00 00       	mov    esi,0x1c
  40edd5:	bf 28 e0 41 00       	mov    edi,0x41e028
  40edda:	e8 f1 b2 ff ff       	call   40a0d0 <cos_print_str>
		BUG();
  40eddf:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40edec:	be 2f 00 00 00       	mov    esi,0x2f
  40edf1:	bf 98 df 41 00       	mov    edi,0x41df98
  40edf6:	e8 d5 b2 ff ff       	call   40a0d0 <cos_print_str>
	assert(meta == __compinfo_metacap(meta));
  40edfb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40ee08:	be 2f 00 00 00       	mov    esi,0x2f
  40ee0d:	bf c8 df 41 00       	mov    edi,0x41dfc8
  40ee12:	e8 b9 b2 ff ff       	call   40a0d0 <cos_print_str>
	assert(kmem);
  40ee17:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40ee24:	be 2f 00 00 00       	mov    esi,0x2f
  40ee29:	bf f8 df 41 00       	mov    edi,0x41dff8
  40ee2e:	e8 9d b2 ff ff       	call   40a0d0 <cos_print_str>
	assert(heap_vaddr);
  40ee33:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	assert(__ci);
  40ee51:	48 85 ff             	test   rdi,rdi
  40ee54:	0f 84 6f 01 00 00    	je     40efc9 <cos_vm_kernel_page_create+0x189>
	return ci->memsrc;
  40ee5a:	4c 8b 57 60          	mov    r10,QWORD PTR [rdi+0x60]
--
	assert(ci && ci == __compinfo_metacap(__ci));
  40ee6c:	4d 85 d2             	test   r10,r10
  40ee6f:	0f 84 70 01 00 00    	je     40efe5 <cos_vm_kernel_page_create+0x1a5>
  40ee75:	0f 1f 00             	nop    DWORD PTR [rax]
        __asm__ __volatile__("lock " PS_CAS_STR
  40ee78:	48 89 c8             	mov    rax,rcx
  40ee7b:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40ee80:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40ee83:	84 c0                	test   al,al
  40ee85:	74 f1                	je     40ee78 <cos_vm_kernel_page_create+0x38>
        __asm__ __volatile__("lock " PS_FAA_STR
  40ee87:	41 bd 00 10 00 00    	mov    r13d,0x1000
--
	if (ret >= *frontier || *frontier - ret > RETYPE_MEM_SIZE) {
  40ee93:	49 8b 92 90 00 00 00 	mov    rdx,QWORD PTR [r10+0x90]
  40ee9a:	49 39 d5             	cmp    r13,rdx
  40ee9d:	0f 82 bd 00 00 00    	jb     40ef60 <cos_vm_kernel_page_create+0x120>
		vaddr_t ptr_tmp = *ptr, front_tmp = *frontier;
--
		if (ci->mi.untyped_ptr == ci->mi.untyped_frontier) goto error;
  40eea7:	49 8b 9a 80 00 00 00 	mov    rbx,QWORD PTR [r10+0x80]
  40eeae:	49 39 5a 68          	cmp    QWORD PTR [r10+0x68],rbx
  40eeb2:	0f 84 c8 00 00 00    	je     40ef80 <cos_vm_kernel_page_create+0x140>
  40eeb8:	41 bd 00 10 00 00    	mov    r13d,0x1000
  40eebe:	f0 4d 0f c1 6a 68    	lock xadd QWORD PTR [r10+0x68],r13
--
  40eec4:	49 8d 8d 00 10 00 00 	lea    rcx,[r13+0x1000]
        __asm__ __volatile__("lock " PS_CAS_STR
  40eecb:	f0 49 0f b1 4a 78    	lock cmpxchg QWORD PTR [r10+0x78],rcx
  40eed1:	0f 94 c0             	sete   al
  40eed4:	84 c0                	test   al,al
  40eed6:	74 0f                	je     40eee7 <cos_vm_kernel_page_create+0xa7>
  40eed8:	48 89 d0             	mov    rax,rdx
  40eedb:	f0 49 0f b1 8a 90 00 	lock cmpxchg QWORD PTR [r10+0x90],rcx
  40eee2:	00 00 
  40eee4:	0f 94 c0             	sete   al
--
  40eee7:	4c 89 ea             	mov    rdx,r13
  40eeea:	81 e2 ff 0f 00 00    	and    edx,0xfff
  40eef0:	0f 85 ba 00 00 00    	jne    40efb0 <cos_vm_kernel_page_create+0x170>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40eef6:	41 8b 82 98 00 00 00 	mov    eax,DWORD PTR [r10+0x98]
--
  40ef1c:	49 b8 30 ef 40 00 00 	movabs r8,0x40ef30
  40ef23:	00 00 00 
  40ef26:	0f 05                	syscall 
  40ef28:	eb 0d                	jmp    40ef37 <cos_vm_kernel_page_create+0xf7>
  40ef2a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40ef30:	b9 00 00 00 00       	mov    ecx,0x0
  40ef35:	eb 05                	jmp    40ef3c <cos_vm_kernel_page_create+0xfc>
  40ef37:	b9 01 00 00 00       	mov    ecx,0x1
  40ef3c:	5d                   	pop    rbp
  40ef3d:	5c                   	pop    rsp
		if (call_cap_op(ci->mi.pgtbl_cap, op, ret, 0, 0, 0)) goto error;
  40ef3e:	85 c0                	test   eax,eax
  40ef40:	75 3e                	jne    40ef80 <cos_vm_kernel_page_create+0x140>
{ l->o = 0; }
  40ef42:	49 c7 82 b8 00 00 00 	mov    QWORD PTR [r10+0xb8],0x0
--
	assert(kmem);
  40ef4d:	4d 85 ed             	test   r13,r13
  40ef50:	74 39                	je     40ef8b <cos_vm_kernel_page_create+0x14b>

	return kmem;
--
  40ef60:	48 89 d0             	mov    rax,rdx
  40ef63:	4c 29 e8             	sub    rax,r13
  40ef66:	48 3d 00 10 00 00    	cmp    rax,0x1000
  40ef6c:	0f 86 75 ff ff ff    	jbe    40eee7 <cos_vm_kernel_page_create+0xa7>
  40ef72:	e9 2c ff ff ff       	jmp    40eea3 <cos_vm_kernel_page_create+0x63>
  40ef77:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40ef7e:	00 00 
--
  40ef8b:	be 2f 00 00 00       	mov    esi,0x2f
  40ef90:	bf 48 e0 41 00       	mov    edi,0x41e048
  40ef95:	e8 36 b1 ff ff       	call   40a0d0 <cos_print_str>
	assert(kmem);
  40ef9a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40efc9:	be 2e 00 00 00       	mov    esi,0x2e
  40efce:	bf d0 d6 41 00       	mov    edi,0x41d6d0
  40efd3:	e8 f8 b0 ff ff       	call   40a0d0 <cos_print_str>
	assert(__ci);
  40efd8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40efe5:	be 2e 00 00 00       	mov    esi,0x2e
  40efea:	bf 00 d7 41 00       	mov    edi,0x41d700
  40efef:	e8 dc b0 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci && ci == __compinfo_metacap(__ci));
  40eff4:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
        __asm__ __volatile__("lock " PS_CAS_STR
  40f040:	48 89 c8             	mov    rax,rcx
  40f043:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40f048:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f04b:	84 c0                	test   al,al
  40f04d:	74 f1                	je     40f040 <cos_vm_vmcs_alloc+0x30>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40f04f:	41 f6 44 24 38 03    	test   BYTE PTR [r12+0x38],0x3
  40f055:	0f 84 a1 00 00 00    	je     40f0fc <cos_vm_vmcs_alloc+0xec>
        __asm__ __volatile__("lock " PS_FAA_STR
  40f05b:	bf 04 00 00 00       	mov    edi,0x4
--
	if (cap == 0 || kmem == 0) {
  40f073:	48 85 ff             	test   rdi,rdi
  40f076:	0f 84 98 00 00 00    	je     40f114 <cos_vm_vmcs_alloc+0x104>
  40f07c:	48 85 db             	test   rbx,rbx
  40f07f:	0f 84 8f 00 00 00    	je     40f114 <cos_vm_vmcs_alloc+0x104>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f085:	41 8b 45 08          	mov    eax,DWORD PTR [r13+0x8]
--
	}

	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_VMCS_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  40f089:	49 8b 55 60          	mov    rdx,QWORD PTR [r13+0x60]
	__asm__ __volatile__(
--
  40f0ac:	49 b8 c0 f0 40 00 00 	movabs r8,0x40f0c0
  40f0b3:	00 00 00 
  40f0b6:	0f 05                	syscall 
  40f0b8:	eb 0d                	jmp    40f0c7 <cos_vm_vmcs_alloc+0xb7>
  40f0ba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40f0c0:	b9 00 00 00 00       	mov    ecx,0x0
  40f0c5:	eb 05                	jmp    40f0cc <cos_vm_vmcs_alloc+0xbc>
  40f0c7:	b9 01 00 00 00       	mov    ecx,0x1
  40f0cc:	5d                   	pop    rbp
  40f0cd:	5c                   	pop    rsp
  40f0ce:	85 c0                	test   eax,eax
  40f0d0:	75 0e                	jne    40f0e0 <cos_vm_vmcs_alloc+0xd0>

	return cap;
--
  40f0e0:	be 1c 00 00 00       	mov    esi,0x1c
  40f0e5:	bf a8 e0 41 00       	mov    edi,0x41e0a8
  40f0ea:	e8 e1 af ff ff       	call   40a0d0 <cos_print_str>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_VMCS_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  40f0ef:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f0f6:	00 00 00 00 
--
		if (__capid_captbl_check_expand(ci)) goto error;
  40f0fc:	4c 89 e7             	mov    rdi,r12
  40f0ff:	e8 dc d8 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40f104:	85 c0                	test   eax,eax
  40f106:	74 28                	je     40f130 <cos_vm_vmcs_alloc+0x120>
  40f108:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40f10f:	00 00 00 00 00 
  40f114:	be 2f 00 00 00       	mov    esi,0x2f
  40f119:	bf 78 e0 41 00       	mov    edi,0x41e078
  40f11e:	e8 ad af ff ff       	call   40a0d0 <cos_print_str>
		assert(0);
  40f123:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40f13c:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  40f141:	e9 15 ff ff ff       	jmp    40f05b <cos_vm_vmcs_alloc+0x4b>
  40f146:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40f14d:	00 00 00 
--
        __asm__ __volatile__("lock " PS_CAS_STR
  40f180:	48 89 c8             	mov    rax,rcx
  40f183:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40f188:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f18b:	84 c0                	test   al,al
  40f18d:	74 f1                	je     40f180 <cos_vm_msr_bitmap_alloc+0x30>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40f18f:	41 f6 44 24 38 03    	test   BYTE PTR [r12+0x38],0x3
  40f195:	0f 84 a1 00 00 00    	je     40f23c <cos_vm_msr_bitmap_alloc+0xec>
        __asm__ __volatile__("lock " PS_FAA_STR
  40f19b:	bf 04 00 00 00       	mov    edi,0x4
--
	if (cap == 0 || kmem == 0) {
  40f1b3:	48 85 ff             	test   rdi,rdi
  40f1b6:	0f 84 98 00 00 00    	je     40f254 <cos_vm_msr_bitmap_alloc+0x104>
  40f1bc:	48 85 db             	test   rbx,rbx
  40f1bf:	0f 84 8f 00 00 00    	je     40f254 <cos_vm_msr_bitmap_alloc+0x104>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f1c5:	41 8b 45 08          	mov    eax,DWORD PTR [r13+0x8]
--
	}

	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_MSR_BITMAP_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  40f1c9:	49 8b 55 60          	mov    rdx,QWORD PTR [r13+0x60]
	__asm__ __volatile__(
--
  40f1ec:	49 b8 00 f2 40 00 00 	movabs r8,0x40f200
  40f1f3:	00 00 00 
  40f1f6:	0f 05                	syscall 
  40f1f8:	eb 0d                	jmp    40f207 <cos_vm_msr_bitmap_alloc+0xb7>
  40f1fa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40f200:	b9 00 00 00 00       	mov    ecx,0x0
  40f205:	eb 05                	jmp    40f20c <cos_vm_msr_bitmap_alloc+0xbc>
  40f207:	b9 01 00 00 00       	mov    ecx,0x1
  40f20c:	5d                   	pop    rbp
  40f20d:	5c                   	pop    rsp
  40f20e:	85 c0                	test   eax,eax
  40f210:	75 0e                	jne    40f220 <cos_vm_msr_bitmap_alloc+0xd0>

	return cap;
--
  40f220:	be 1c 00 00 00       	mov    esi,0x1c
  40f225:	bf f8 e0 41 00       	mov    edi,0x41e0f8
  40f22a:	e8 a1 ae ff ff       	call   40a0d0 <cos_print_str>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_MSR_BITMAP_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  40f22f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f236:	00 00 00 00 
--
		if (__capid_captbl_check_expand(ci)) goto error;
  40f23c:	4c 89 e7             	mov    rdi,r12
  40f23f:	e8 9c d7 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40f244:	85 c0                	test   eax,eax
  40f246:	74 28                	je     40f270 <cos_vm_msr_bitmap_alloc+0x120>
  40f248:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40f24f:	00 00 00 00 00 
  40f254:	be 2f 00 00 00       	mov    esi,0x2f
  40f259:	bf c8 e0 41 00       	mov    edi,0x41e0c8
  40f25e:	e8 6d ae ff ff       	call   40a0d0 <cos_print_str>
		assert(0);
  40f263:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40f27c:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  40f281:	e9 15 ff ff ff       	jmp    40f19b <cos_vm_msr_bitmap_alloc+0x4b>
  40f286:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40f28d:	00 00 00 
--
        __asm__ __volatile__("lock " PS_CAS_STR
  40f2c0:	48 89 c8             	mov    rax,rcx
  40f2c3:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40f2c8:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f2cb:	84 c0                	test   al,al
  40f2cd:	74 f1                	je     40f2c0 <cos_vm_lapic_alloc+0x30>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40f2cf:	41 f6 44 24 38 03    	test   BYTE PTR [r12+0x38],0x3
  40f2d5:	0f 84 a1 00 00 00    	je     40f37c <cos_vm_lapic_alloc+0xec>
        __asm__ __volatile__("lock " PS_FAA_STR
  40f2db:	bf 04 00 00 00       	mov    edi,0x4
--
	if (cap == 0 || kmem == 0) {
  40f2f3:	48 85 ff             	test   rdi,rdi
  40f2f6:	0f 84 98 00 00 00    	je     40f394 <cos_vm_lapic_alloc+0x104>
  40f2fc:	48 85 db             	test   rbx,rbx
  40f2ff:	0f 84 8f 00 00 00    	je     40f394 <cos_vm_lapic_alloc+0x104>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f305:	41 8b 45 08          	mov    eax,DWORD PTR [r13+0x8]
--
	}

	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_LAPIC_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  40f309:	49 8b 55 60          	mov    rdx,QWORD PTR [r13+0x60]
	__asm__ __volatile__(
--
  40f32c:	49 b8 40 f3 40 00 00 	movabs r8,0x40f340
  40f333:	00 00 00 
  40f336:	0f 05                	syscall 
  40f338:	eb 0d                	jmp    40f347 <cos_vm_lapic_alloc+0xb7>
  40f33a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40f340:	b9 00 00 00 00       	mov    ecx,0x0
  40f345:	eb 05                	jmp    40f34c <cos_vm_lapic_alloc+0xbc>
  40f347:	b9 01 00 00 00       	mov    ecx,0x1
  40f34c:	5d                   	pop    rbp
  40f34d:	5c                   	pop    rsp
  40f34e:	85 c0                	test   eax,eax
  40f350:	75 0e                	jne    40f360 <cos_vm_lapic_alloc+0xd0>

	return cap;
--
  40f360:	be 1c 00 00 00       	mov    esi,0x1c
  40f365:	bf 48 e1 41 00       	mov    edi,0x41e148
  40f36a:	e8 61 ad ff ff       	call   40a0d0 <cos_print_str>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_LAPIC_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  40f36f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f376:	00 00 00 00 
--
		if (__capid_captbl_check_expand(ci)) goto error;
  40f37c:	4c 89 e7             	mov    rdi,r12
  40f37f:	e8 5c d6 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40f384:	85 c0                	test   eax,eax
  40f386:	74 28                	je     40f3b0 <cos_vm_lapic_alloc+0x120>
  40f388:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40f38f:	00 00 00 00 00 
  40f394:	be 2f 00 00 00       	mov    esi,0x2f
  40f399:	bf 18 e1 41 00       	mov    edi,0x41e118
  40f39e:	e8 2d ad ff ff       	call   40a0d0 <cos_print_str>
		assert(0);
  40f3a3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40f3bc:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  40f3c1:	e9 15 ff ff ff       	jmp    40f2db <cos_vm_lapic_alloc+0x4b>
  40f3c6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40f3cd:	00 00 00 
--
        __asm__ __volatile__("lock " PS_CAS_STR
  40f400:	48 89 c8             	mov    rax,rcx
  40f403:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40f408:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f40b:	84 c0                	test   al,al
  40f40d:	74 f1                	je     40f400 <cos_vm_shared_region_alloc+0x30>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40f40f:	41 f6 44 24 38 03    	test   BYTE PTR [r12+0x38],0x3
  40f415:	0f 84 a1 00 00 00    	je     40f4bc <cos_vm_shared_region_alloc+0xec>
        __asm__ __volatile__("lock " PS_FAA_STR
  40f41b:	bf 04 00 00 00       	mov    edi,0x4
--
	if (cap == 0 || kmem == 0) {
  40f433:	48 85 ff             	test   rdi,rdi
  40f436:	0f 84 98 00 00 00    	je     40f4d4 <cos_vm_shared_region_alloc+0x104>
  40f43c:	48 85 db             	test   rbx,rbx
  40f43f:	0f 84 8f 00 00 00    	je     40f4d4 <cos_vm_shared_region_alloc+0x104>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f445:	41 8b 45 08          	mov    eax,DWORD PTR [r13+0x8]
--
	}

	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_SHARED_MEM_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  40f449:	49 8b 55 60          	mov    rdx,QWORD PTR [r13+0x60]
	__asm__ __volatile__(
--
  40f46c:	49 b8 80 f4 40 00 00 	movabs r8,0x40f480
  40f473:	00 00 00 
  40f476:	0f 05                	syscall 
  40f478:	eb 0d                	jmp    40f487 <cos_vm_shared_region_alloc+0xb7>
  40f47a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40f480:	b9 00 00 00 00       	mov    ecx,0x0
  40f485:	eb 05                	jmp    40f48c <cos_vm_shared_region_alloc+0xbc>
  40f487:	b9 01 00 00 00       	mov    ecx,0x1
  40f48c:	5d                   	pop    rbp
  40f48d:	5c                   	pop    rsp
  40f48e:	85 c0                	test   eax,eax
  40f490:	75 0e                	jne    40f4a0 <cos_vm_shared_region_alloc+0xd0>

	return cap;
--
  40f4a0:	be 1c 00 00 00       	mov    esi,0x1c
  40f4a5:	bf 98 e1 41 00       	mov    edi,0x41e198
  40f4aa:	e8 21 ac ff ff       	call   40a0d0 <cos_print_str>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_SHARED_MEM_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  40f4af:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f4b6:	00 00 00 00 
--
		if (__capid_captbl_check_expand(ci)) goto error;
  40f4bc:	4c 89 e7             	mov    rdi,r12
  40f4bf:	e8 1c d5 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40f4c4:	85 c0                	test   eax,eax
  40f4c6:	74 28                	je     40f4f0 <cos_vm_shared_region_alloc+0x120>
  40f4c8:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40f4cf:	00 00 00 00 00 
  40f4d4:	be 2f 00 00 00       	mov    esi,0x2f
  40f4d9:	bf 68 e1 41 00       	mov    edi,0x41e168
  40f4de:	e8 ed ab ff ff       	call   40a0d0 <cos_print_str>
		assert(0);
  40f4e3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40f4fc:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  40f501:	e9 15 ff ff ff       	jmp    40f41b <cos_vm_shared_region_alloc+0x4b>
  40f506:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40f50d:	00 00 00 
--
        __asm__ __volatile__("lock " PS_CAS_STR
  40f540:	48 89 c8             	mov    rax,rcx
  40f543:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40f548:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f54b:	84 c0                	test   al,al
  40f54d:	74 f1                	je     40f540 <cos_vm_lapic_access_alloc+0x30>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40f54f:	41 f6 44 24 38 03    	test   BYTE PTR [r12+0x38],0x3
  40f555:	0f 84 a1 00 00 00    	je     40f5fc <cos_vm_lapic_access_alloc+0xec>
        __asm__ __volatile__("lock " PS_FAA_STR
  40f55b:	bf 04 00 00 00       	mov    edi,0x4
--
	if (cap == 0 || kmem == 0) {
  40f573:	48 85 ff             	test   rdi,rdi
  40f576:	0f 84 98 00 00 00    	je     40f614 <cos_vm_lapic_access_alloc+0x104>
  40f57c:	48 85 db             	test   rbx,rbx
  40f57f:	0f 84 8f 00 00 00    	je     40f614 <cos_vm_lapic_access_alloc+0x104>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f585:	41 8b 45 08          	mov    eax,DWORD PTR [r13+0x8]
--
	}

	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_LAPIC_ACCESS_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  40f589:	49 8b 55 60          	mov    rdx,QWORD PTR [r13+0x60]
	__asm__ __volatile__(
--
  40f5ac:	49 b8 c0 f5 40 00 00 	movabs r8,0x40f5c0
  40f5b3:	00 00 00 
  40f5b6:	0f 05                	syscall 
  40f5b8:	eb 0d                	jmp    40f5c7 <cos_vm_lapic_access_alloc+0xb7>
  40f5ba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40f5c0:	b9 00 00 00 00       	mov    ecx,0x0
  40f5c5:	eb 05                	jmp    40f5cc <cos_vm_lapic_access_alloc+0xbc>
  40f5c7:	b9 01 00 00 00       	mov    ecx,0x1
  40f5cc:	5d                   	pop    rbp
  40f5cd:	5c                   	pop    rsp
  40f5ce:	85 c0                	test   eax,eax
  40f5d0:	75 0e                	jne    40f5e0 <cos_vm_lapic_access_alloc+0xd0>

	return cap;
--
  40f5e0:	be 1c 00 00 00       	mov    esi,0x1c
  40f5e5:	bf e8 e1 41 00       	mov    edi,0x41e1e8
  40f5ea:	e8 e1 aa ff ff       	call   40a0d0 <cos_print_str>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_LAPIC_ACCESS_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  40f5ef:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f5f6:	00 00 00 00 
--
		if (__capid_captbl_check_expand(ci)) goto error;
  40f5fc:	4c 89 e7             	mov    rdi,r12
  40f5ff:	e8 dc d3 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40f604:	85 c0                	test   eax,eax
  40f606:	74 28                	je     40f630 <cos_vm_lapic_access_alloc+0x120>
  40f608:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40f60f:	00 00 00 00 00 
  40f614:	be 2f 00 00 00       	mov    esi,0x2f
  40f619:	bf b8 e1 41 00       	mov    edi,0x41e1b8
  40f61e:	e8 ad aa ff ff       	call   40a0d0 <cos_print_str>
		assert(0);
  40f623:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40f63c:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  40f641:	e9 15 ff ff ff       	jmp    40f55b <cos_vm_lapic_access_alloc+0x4b>
  40f646:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40f64d:	00 00 00 
--
        __asm__ __volatile__("lock " PS_CAS_STR
  40f690:	48 89 c8             	mov    rax,rcx
  40f693:	f0 48 0f b1 3a       	lock cmpxchg QWORD PTR [rdx],rdi
  40f698:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f69b:	84 c0                	test   al,al
  40f69d:	74 f1                	je     40f690 <cos_vm_vmcb_alloc+0x40>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40f69f:	f6 46 38 03          	test   BYTE PTR [rsi+0x38],0x3
  40f6a3:	0f 84 ab 00 00 00    	je     40f754 <cos_vm_vmcb_alloc+0x104>
        __asm__ __volatile__("lock " PS_FAA_STR
  40f6a9:	41 ba 04 00 00 00    	mov    r10d,0x4
--
	if (cap == 0) {
  40f6c0:	4d 85 d2             	test   r10,r10
  40f6c3:	0f 84 e2 00 00 00    	je     40f7ab <cos_vm_vmcb_alloc+0x15b>
		assert(0);
	}
--
  40f6d5:	49 c1 e6 30          	shl    r14,0x30

	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_VMCB_ACTIVATE, arg1, arg2, 0, 0)) BUG();
  40f6d9:	49 8b 44 24 08       	mov    rax,QWORD PTR [r12+0x8]
	arg1 = cap | vmcs_cap << (16 * 1) | msr_bitmap_cap << (16 * 2) |  lapic_access_cap << (16 * 3);
--
  40f71b:	49 b8 30 f7 40 00 00 	movabs r8,0x40f730
  40f722:	00 00 00 
  40f725:	0f 05                	syscall 
  40f727:	90                   	nop
  40f728:	eb 0d                	jmp    40f737 <cos_vm_vmcb_alloc+0xe7>
  40f72a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40f730:	b9 00 00 00 00       	mov    ecx,0x0
  40f735:	eb 05                	jmp    40f73c <cos_vm_vmcb_alloc+0xec>
  40f737:	b9 01 00 00 00       	mov    ecx,0x1
  40f73c:	5d                   	pop    rbp
  40f73d:	5c                   	pop    rsp
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_VMCB_ACTIVATE, arg1, arg2, 0, 0)) BUG();
  40f73e:	85 c0                	test   eax,eax
  40f740:	75 42                	jne    40f784 <cos_vm_vmcb_alloc+0x134>

	return cap;
--
  40f757:	4c 89 4d b0          	mov    QWORD PTR [rbp-0x50],r9
  40f75b:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
  40f75f:	e8 7c d2 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40f764:	48 8b 75 b8          	mov    rsi,QWORD PTR [rbp-0x48]
  40f768:	4c 8b 4d b0          	mov    r9,QWORD PTR [rbp-0x50]
  40f76c:	85 c0                	test   eax,eax
  40f76e:	75 30                	jne    40f7a0 <cos_vm_vmcb_alloc+0x150>
        __asm__ __volatile__("lock " PS_FAA_STR
  40f770:	b8 04 00 00 00       	mov    eax,0x4
--
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40f77b:	48 89 46 38          	mov    QWORD PTR [rsi+0x38],rax
  40f77f:	e9 25 ff ff ff       	jmp    40f6a9 <cos_vm_vmcb_alloc+0x59>
  40f784:	be 1c 00 00 00       	mov    esi,0x1c
  40f789:	bf 38 e2 41 00       	mov    edi,0x41e238
  40f78e:	e8 3d a9 ff ff       	call   40a0d0 <cos_print_str>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_VMCB_ACTIVATE, arg1, arg2, 0, 0)) BUG();
  40f793:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f79a:	00 00 00 00 
--
  40f7ab:	be 2f 00 00 00       	mov    esi,0x2f
  40f7b0:	bf 08 e2 41 00       	mov    edi,0x41e208
  40f7b5:	e8 16 a9 ff ff       	call   40a0d0 <cos_print_str>
		assert(0);
  40f7ba:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	assert(ci && comp > 0);
  40f7f4:	48 85 ff             	test   rdi,rdi
  40f7f7:	0f 84 b7 01 00 00    	je     40f9b4 <cos_initthd_alloc+0x1e4>
  40f7fd:	49 89 f4             	mov    r12,rsi
  40f800:	48 85 f6             	test   rsi,rsi
  40f803:	0f 84 ab 01 00 00    	je     40f9b4 <cos_initthd_alloc+0x1e4>
	if (!__cos_ulk_info.toplvl) return 0;
  40f809:	4c 8b 1d 70 12 19 00 	mov    r11,QWORD PTR [rip+0x191270]        # 5a0a80 <__cos_ulk_info>
  40f810:	49 89 fe             	mov    r14,rdi
  40f813:	4d 85 db             	test   r11,r11
  40f816:	74 46                	je     40f85e <cos_initthd_alloc+0x8e>
	if (!__cos_ulk_info.curr_pg || tid % ULK_STACKS_PER_PAGE == 0) {
  40f818:	48 8b 05 71 12 19 00 	mov    rax,QWORD PTR [rip+0x191271]        # 5a0a90 <__cos_ulk_info+0x10>
  40f81f:	48 85 c0             	test   rax,rax
  40f822:	74 0a                	je     40f82e <cos_initthd_alloc+0x5e>
  40f824:	41 f6 c5 0f          	test   r13b,0xf
  40f828:	0f 85 52 01 00 00    	jne    40f980 <cos_initthd_alloc+0x1b0>
		__cos_ulk_info.curr_pg = cos_ulk_page_alloc(ci, __cos_ulk_info.toplvl, __cos_ulk_info.pg_frontier);
  40f82e:	48 8b 15 63 12 19 00 	mov    rdx,QWORD PTR [rip+0x191263]        # 5a0a98 <__cos_ulk_info+0x18>
  40f835:	4c 89 de             	mov    rsi,r11
  40f838:	4c 89 f7             	mov    rdi,r14
  40f83b:	e8 f0 ed ff ff       	call   40e630 <cos_ulk_page_alloc>
  40f840:	48 89 05 49 12 19 00 	mov    QWORD PTR [rip+0x191249],rax        # 5a0a90 <__cos_ulk_info+0x10>
  40f847:	49 89 c3             	mov    r11,rax
		assert(__cos_ulk_info.curr_pg);
  40f84a:	48 85 c0             	test   rax,rax
  40f84d:	0f 84 7d 01 00 00    	je     40f9d0 <cos_initthd_alloc+0x200>
		__cos_ulk_info.pg_frontier += PAGE_SIZE;
  40f853:	48 81 05 3a 12 19 00 	add    QWORD PTR [rip+0x19123a],0x1000        # 5a0a98 <__cos_ulk_info+0x18>
--
  40f85e:	4c 89 f7             	mov    rdi,r14
  40f861:	4c 89 5d b8          	mov    QWORD PTR [rbp-0x48],r11
  40f865:	e8 f6 cf ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40f86a:	49 89 c2             	mov    r10,rax
	if (!*kmem) return -1;
  40f86d:	48 85 c0             	test   rax,rax
  40f870:	0f 84 76 01 00 00    	je     40f9ec <cos_initthd_alloc+0x21c>
        __asm__ __volatile__("lock " PS_CAS_STR
  40f876:	4c 8b 5d b8          	mov    r11,QWORD PTR [rbp-0x48]
--
  40f88a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40f890:	4c 89 c0             	mov    rax,r8
  40f893:	f0 4c 0f b1 09       	lock cmpxchg QWORD PTR [rcx],r9
  40f898:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f89b:	84 c0                	test   al,al
  40f89d:	74 f1                	je     40f890 <cos_initthd_alloc+0xc0>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40f89f:	4d 8b 7e 28          	mov    r15,QWORD PTR [r14+0x28]
  40f8a3:	41 83 e7 03          	and    r15d,0x3
  40f8a7:	0f 84 9b 00 00 00    	je     40f948 <cos_initthd_alloc+0x178>
        __asm__ __volatile__("lock " PS_FAA_STR
  40f8ad:	bb 01 00 00 00       	mov    ebx,0x1
--
	if (!*cap) return -1;
  40f8c6:	48 85 db             	test   rbx,rbx
  40f8c9:	0f 84 1d 01 00 00    	je     40f9ec <cos_initthd_alloc+0x21c>
			  __compinfo_metacap(ci)->mi.pgtbl_cap << 16 | comp, kmem, ulkcap << 16 | tid);
  40f8cf:	49 8b 56 60          	mov    rdx,QWORD PTR [r14+0x60]
--
  40f8ef:	05 04 00 01 00       	add    eax,0x10004
  40f8f4:	48 c1 e6 10          	shl    rsi,0x10
	ret = call_cap_op(ci->captbl_cap, CAPTBL_OP_THDACTIVATE, (init_data << 16) | cap,
  40f8f8:	4c 09 ea             	or     rdx,r13
  40f8fb:	4c 09 e6             	or     rsi,r12
--
  40f908:	49 b8 20 f9 40 00 00 	movabs r8,0x40f920
  40f90f:	00 00 00 
  40f912:	0f 05                	syscall 
  40f914:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  40f918:	eb 0d                	jmp    40f927 <cos_initthd_alloc+0x157>
  40f91a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40f920:	b9 00 00 00 00       	mov    ecx,0x0
  40f925:	eb 05                	jmp    40f92c <cos_initthd_alloc+0x15c>
  40f927:	b9 01 00 00 00       	mov    ecx,0x1
  40f92c:	5d                   	pop    rbp
--
	if (ret) BUG();
  40f92e:	85 c0                	test   eax,eax
  40f930:	75 66                	jne    40f998 <cos_initthd_alloc+0x1c8>
	thdid_t tid = cos_thd_id_alloc();

--
  40f94b:	4c 89 5d b0          	mov    QWORD PTR [rbp-0x50],r11
  40f94f:	4c 89 55 b8          	mov    QWORD PTR [rbp-0x48],r10
  40f953:	e8 88 d0 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40f958:	4c 8b 55 b8          	mov    r10,QWORD PTR [rbp-0x48]
  40f95c:	4c 8b 5d b0          	mov    r11,QWORD PTR [rbp-0x50]
  40f960:	85 c0                	test   eax,eax
  40f962:	75 24                	jne    40f988 <cos_initthd_alloc+0x1b8>
        __asm__ __volatile__("lock " PS_FAA_STR
  40f964:	b8 04 00 00 00       	mov    eax,0x4
--
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40f96f:	49 89 46 28          	mov    QWORD PTR [r14+0x28],rax
  40f973:	e9 35 ff ff ff       	jmp    40f8ad <cos_initthd_alloc+0xdd>
  40f978:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40f97f:	00 
  40f980:	49 89 c3             	mov    r11,rax
	return __cos_ulk_info.curr_pg;
  40f983:	e9 d6 fe ff ff       	jmp    40f85e <cos_initthd_alloc+0x8e>
{ l->o = 0; }
  40f988:	49 c7 86 b0 00 00 00 	mov    QWORD PTR [r14+0xb0],0x0
  40f98f:	00 00 00 00 
	if (!*cap) return -1;
  40f993:	eb 9d                	jmp    40f932 <cos_initthd_alloc+0x162>
  40f995:	0f 1f 00             	nop    DWORD PTR [rax]
  40f998:	be 1b 00 00 00       	mov    esi,0x1b
  40f99d:	bf 5f de 41 00       	mov    edi,0x41de5f
  40f9a2:	e8 29 a7 ff ff       	call   40a0d0 <cos_print_str>
	if (ret) BUG();
  40f9a7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40f9b4:	be 2e 00 00 00       	mov    esi,0x2e
  40f9b9:	bf d0 dd 41 00       	mov    edi,0x41ddd0
  40f9be:	e8 0d a7 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci && comp > 0);
  40f9c3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40f9d0:	be 2e 00 00 00       	mov    esi,0x2e
  40f9d5:	bf 00 de 41 00       	mov    edi,0x41de00
  40f9da:	e8 f1 a6 ff ff       	call   40a0d0 <cos_print_str>
		assert(__cos_ulk_info.curr_pg);
  40f9df:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40f9ec:	45 31 ff             	xor    r15d,r15d
	return __cos_thd_alloc(ci, comp, 0, tid);
  40f9ef:	e9 3e ff ff ff       	jmp    40f932 <cos_initthd_alloc+0x162>
  40f9f4:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40f9fb:	00 00 00 00 
--
	assert(ci);
  40fa13:	48 85 ff             	test   rdi,rdi
  40fa16:	0f 84 20 01 00 00    	je     40fb3c <cos_captbl_alloc+0x13c>
  40fa1c:	49 89 fc             	mov    r12,rdi
	return __mem_bump_alloc(ci, 1, 1);
  40fa1f:	e8 3c ce ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40fa24:	49 89 c5             	mov    r13,rax
	if (!*kmem) return -1;
  40fa27:	48 85 c0             	test   rax,rax
  40fa2a:	0f 84 28 01 00 00    	je     40fb58 <cos_captbl_alloc+0x158>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40fa30:	49 8d 94 24 b0 00 00 	lea    rdx,[r12+0xb0]
--
  40fa3f:	90                   	nop
  40fa40:	48 89 c8             	mov    rax,rcx
  40fa43:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40fa48:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40fa4b:	84 c0                	test   al,al
  40fa4d:	74 f1                	je     40fa40 <cos_captbl_alloc+0x40>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40fa4f:	4d 8b 74 24 38       	mov    r14,QWORD PTR [r12+0x38]
  40fa54:	41 83 e6 03          	and    r14d,0x3
  40fa58:	0f 84 92 00 00 00    	je     40faf0 <cos_captbl_alloc+0xf0>
        __asm__ __volatile__("lock " PS_FAA_STR
  40fa5e:	bb 04 00 00 00       	mov    ebx,0x4
--
	if (!*cap) return -1;
  40fa79:	48 85 db             	test   rbx,rbx
  40fa7c:	0f 84 d6 00 00 00    	je     40fb58 <cos_captbl_alloc+0x158>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40fa82:	41 8b 44 24 08       	mov    eax,DWORD PTR [r12+0x8]

	if (__alloc_mem_cap(ci, CAP_CAPTBL, &kmem, &cap)) return 0;
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_CAPTBLACTIVATE, cap, __compinfo_metacap(ci)->mi.pgtbl_cap, kmem, 0))
  40fa87:	49 8b 54 24 60       	mov    rdx,QWORD PTR [r12+0x60]
	__asm__ __volatile__(
--
  40faae:	49 b8 c8 fa 40 00 00 	movabs r8,0x40fac8
  40fab5:	00 00 00 
  40fab8:	0f 05                	syscall 
  40faba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40fac0:	eb 0d                	jmp    40facf <cos_captbl_alloc+0xcf>
  40fac2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40fac8:	b9 00 00 00 00       	mov    ecx,0x0
  40facd:	eb 05                	jmp    40fad4 <cos_captbl_alloc+0xd4>
  40facf:	b9 01 00 00 00       	mov    ecx,0x1
  40fad4:	5d                   	pop    rbp
  40fad5:	5c                   	pop    rsp
  40fad6:	85 c0                	test   eax,eax
  40fad8:	75 46                	jne    40fb20 <cos_captbl_alloc+0x120>
		BUG();

--
		if (__capid_captbl_check_expand(ci)) goto error;
  40faf0:	4c 89 e7             	mov    rdi,r12
  40faf3:	e8 e8 ce ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40faf8:	85 c0                	test   eax,eax
  40fafa:	75 16                	jne    40fb12 <cos_captbl_alloc+0x112>
        __asm__ __volatile__("lock " PS_FAA_STR
  40fafc:	b8 04 00 00 00       	mov    eax,0x4
--
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40fb08:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  40fb0d:	e9 4c ff ff ff       	jmp    40fa5e <cos_captbl_alloc+0x5e>
{ l->o = 0; }
  40fb12:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40fb19:	00 00 00 00 00 
	if (!*cap) return -1;
  40fb1e:	eb ba                	jmp    40fada <cos_captbl_alloc+0xda>
  40fb20:	be 1c 00 00 00       	mov    esi,0x1c
  40fb25:	bf 88 e2 41 00       	mov    edi,0x41e288
  40fb2a:	e8 a1 a5 ff ff       	call   40a0d0 <cos_print_str>
		BUG();
  40fb2f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40fb3c:	be 2f 00 00 00       	mov    esi,0x2f
  40fb41:	bf 58 e2 41 00       	mov    edi,0x41e258
  40fb46:	e8 85 a5 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci);
  40fb4b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	if (__alloc_mem_cap(ci, CAP_CAPTBL, &kmem, &cap)) return 0;
  40fb58:	45 31 f6             	xor    r14d,r14d
  40fb5b:	e9 7a ff ff ff       	jmp    40fada <cos_captbl_alloc+0xda>

000000000040fb60 <cos_pgtbl_alloc>:
--
	assert(ci);
  40fb75:	48 85 ff             	test   rdi,rdi
  40fb78:	0f 84 26 01 00 00    	je     40fca4 <cos_pgtbl_alloc+0x144>
  40fb7e:	49 89 fe             	mov    r14,rdi
  40fb81:	41 89 f4             	mov    r12d,esi
	return __mem_bump_alloc(ci, 1, 1);
  40fb84:	e8 d7 cc ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40fb89:	49 89 c5             	mov    r13,rax
	if (!*kmem) return -1;
  40fb8c:	48 85 c0             	test   rax,rax
  40fb8f:	0f 84 2b 01 00 00    	je     40fcc0 <cos_pgtbl_alloc+0x160>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40fb95:	49 8d 96 b0 00 00 00 	lea    rdx,[r14+0xb0]
--
  40fba3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40fba8:	48 89 c8             	mov    rax,rcx
  40fbab:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40fbb0:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40fbb3:	84 c0                	test   al,al
  40fbb5:	74 f1                	je     40fba8 <cos_pgtbl_alloc+0x48>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40fbb7:	4d 8b 7e 38          	mov    r15,QWORD PTR [r14+0x38]
  40fbbb:	41 83 e7 03          	and    r15d,0x3
  40fbbf:	0f 84 93 00 00 00    	je     40fc58 <cos_pgtbl_alloc+0xf8>
        __asm__ __volatile__("lock " PS_FAA_STR
  40fbc5:	bb 04 00 00 00       	mov    ebx,0x4
--
	if (!*cap) return -1;
  40fbde:	48 85 db             	test   rbx,rbx
  40fbe1:	0f 84 d9 00 00 00    	je     40fcc0 <cos_pgtbl_alloc+0x160>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40fbe7:	41 8b 46 08          	mov    eax,DWORD PTR [r14+0x8]
--

	if (unlikely(type)) lvl |= PGTBL_LVL_FLAG_VM;
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_PGTBLACTIVATE, cap, __compinfo_metacap(ci)->mi.pgtbl_cap, kmem, lvl))
  40fbeb:	49 8b 56 60          	mov    rdx,QWORD PTR [r14+0x60]
	__asm__ __volatile__(
--
  40fc1b:	49 b8 30 fc 40 00 00 	movabs r8,0x40fc30
  40fc22:	00 00 00 
  40fc25:	0f 05                	syscall 
  40fc27:	90                   	nop
  40fc28:	eb 0d                	jmp    40fc37 <cos_pgtbl_alloc+0xd7>
  40fc2a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40fc30:	b9 00 00 00 00       	mov    ecx,0x0
  40fc35:	eb 05                	jmp    40fc3c <cos_pgtbl_alloc+0xdc>
  40fc37:	b9 01 00 00 00       	mov    ecx,0x1
  40fc3c:	5d                   	pop    rbp
  40fc3d:	5c                   	pop    rsp
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_PGTBLACTIVATE, cap, __compinfo_metacap(ci)->mi.pgtbl_cap, kmem, lvl))
  40fc3e:	85 c0                	test   eax,eax
  40fc40:	75 46                	jne    40fc88 <cos_pgtbl_alloc+0x128>
		BUG();

--
		if (__capid_captbl_check_expand(ci)) goto error;
  40fc58:	4c 89 f7             	mov    rdi,r14
  40fc5b:	e8 80 cd ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40fc60:	85 c0                	test   eax,eax
  40fc62:	75 14                	jne    40fc78 <cos_pgtbl_alloc+0x118>
        __asm__ __volatile__("lock " PS_FAA_STR
  40fc64:	b8 04 00 00 00       	mov    eax,0x4
--
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40fc6f:	49 89 46 38          	mov    QWORD PTR [r14+0x38],rax
  40fc73:	e9 4d ff ff ff       	jmp    40fbc5 <cos_pgtbl_alloc+0x65>
{ l->o = 0; }
  40fc78:	49 c7 86 b0 00 00 00 	mov    QWORD PTR [r14+0xb0],0x0
  40fc7f:	00 00 00 00 
	if (!*cap) return -1;
  40fc83:	eb bd                	jmp    40fc42 <cos_pgtbl_alloc+0xe2>
  40fc85:	0f 1f 00             	nop    DWORD PTR [rax]
  40fc88:	be 1c 00 00 00       	mov    esi,0x1c
  40fc8d:	bf d8 e2 41 00       	mov    edi,0x41e2d8
  40fc92:	e8 39 a4 ff ff       	call   40a0d0 <cos_print_str>
		BUG();
  40fc97:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40fca4:	be 2f 00 00 00       	mov    esi,0x2f
  40fca9:	bf a8 e2 41 00       	mov    edi,0x41e2a8
  40fcae:	e8 1d a4 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci);
  40fcb3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	if (__alloc_mem_cap(ci, CAP_PGTBL, &kmem, &cap)) return 0;
  40fcc0:	45 31 ff             	xor    r15d,r15d
  40fcc3:	e9 7a ff ff ff       	jmp    40fc42 <cos_pgtbl_alloc+0xe2>
  40fcc8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40fccf:	00 
--
	assert(ci && secondlvl);
  40fce5:	48 85 ff             	test   rdi,rdi
  40fce8:	0f 84 22 02 00 00    	je     40ff10 <cos_ulk_pgtbl_create+0x240>
  40fcee:	49 89 f7             	mov    r15,rsi
  40fcf1:	48 85 f6             	test   rsi,rsi
  40fcf4:	0f 84 16 02 00 00    	je     40ff10 <cos_ulk_pgtbl_create+0x240>
  40fcfa:	49 89 fd             	mov    r13,rdi
	toplvl = cos_pgtbl_alloc(__compinfo_metacap(ci), PGTBL_TYPE_DEF);
  40fcfd:	48 8b 7f 60          	mov    rdi,QWORD PTR [rdi+0x60]
  40fd01:	31 f6                	xor    esi,esi
  40fd03:	e8 58 fe ff ff       	call   40fb60 <cos_pgtbl_alloc>
	*secondlvl = __bump_mem_expand_intern(__compinfo_metacap(ci), toplvl, ULK_BASE_ADDR, 0, 0);
  40fd08:	49 8b 7d 60          	mov    rdi,QWORD PTR [r13+0x60]
--
  40fd1e:	49 89 c6             	mov    r14,rax
	*secondlvl = __bump_mem_expand_intern(__compinfo_metacap(ci), toplvl, ULK_BASE_ADDR, 0, 0);
  40fd21:	e8 7a d6 ff ff       	call   40d3a0 <__bump_mem_expand_intern>
  40fd26:	49 89 07             	mov    QWORD PTR [r15],rax
	if (!*secondlvl) return 0;
  40fd29:	48 85 c0             	test   rax,rax
  40fd2c:	75 1a                	jne    40fd48 <cos_ulk_pgtbl_create+0x78>
  40fd2e:	45 31 f6             	xor    r14d,r14d
}
--
  40fd54:	48 ba 00 10 00 00 80 	movabs rdx,0x7f8000001000
  40fd5b:	7f 00 00 
  40fd5e:	e8 3d d6 ff ff       	call   40d3a0 <__bump_mem_expand_intern>
  40fd63:	48 85 c0             	test   rax,rax
  40fd66:	74 c6                	je     40fd2e <cos_ulk_pgtbl_create+0x5e>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40fd68:	44 89 f0             	mov    eax,r14d
--
  40fd9b:	00 
		return round_up_to_pgt2_page(vaddr);
  40fd9c:	48 83 f8 02          	cmp    rax,0x2
  40fda0:	48 b8 00 00 20 00 80 	movabs rax,0x7f8000200000
  40fda7:	7f 00 00 
--
  40fdca:	48 89 45 a8          	mov    QWORD PTR [rbp-0x58],rax
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  40fdce:	4d 3b 7f 60          	cmp    r15,QWORD PTR [r15+0x60]
  40fdd2:	0f 85 bf 01 00 00    	jne    40ff97 <cos_ulk_pgtbl_create+0x2c7>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40fdd8:	49 8d 97 b0 00 00 00 	lea    rdx,[r15+0xb0]
--
  40fde1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  40fde8:	48 89 c8             	mov    rax,rcx
  40fdeb:	f0 4c 0f b1 12       	lock cmpxchg QWORD PTR [rdx],r10
  40fdf0:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40fdf3:	84 c0                	test   al,al
  40fdf5:	74 f1                	je     40fde8 <cos_ulk_pgtbl_create+0x118>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40fdf7:	41 f6 47 38 03       	test   BYTE PTR [r15+0x38],0x3
  40fdfc:	0f 84 2a 01 00 00    	je     40ff2c <cos_ulk_pgtbl_create+0x25c>
        __asm__ __volatile__("lock " PS_FAA_STR
  40fe02:	bb 04 00 00 00       	mov    ebx,0x4
--
	return __mem_bump_alloc(ci, 1, 1);
  40fe18:	4c 89 ff             	mov    rdi,r15
  40fe1b:	e8 40 ca ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40fe20:	48 89 c7             	mov    rdi,rax
		if (pte_cap == 0 || ptemem_cap == 0) {
  40fe23:	48 85 db             	test   rbx,rbx
  40fe26:	0f 84 1f 01 00 00    	je     40ff4b <cos_ulk_pgtbl_create+0x27b>
  40fe2c:	48 85 c0             	test   rax,rax
  40fe2f:	41 ba 01 00 00 00    	mov    r10d,0x1
  40fe35:	0f 84 10 01 00 00    	je     40ff4b <cos_ulk_pgtbl_create+0x27b>
		if (call_cap_op(meta->captbl_cap, CAPTBL_OP_PGTBLACTIVATE, pte_cap, meta->mi.pgtbl_cap, ptemem_cap,
  40fe3b:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
	__asm__ __volatile__(
--
  40fe6a:	49 b8 80 fe 40 00 00 	movabs r8,0x40fe80
  40fe71:	00 00 00 
  40fe74:	0f 05                	syscall 
  40fe76:	66 90                	xchg   ax,ax
  40fe78:	eb 0d                	jmp    40fe87 <cos_ulk_pgtbl_create+0x1b7>
  40fe7a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40fe80:	b9 00 00 00 00       	mov    ecx,0x0
  40fe85:	eb 05                	jmp    40fe8c <cos_ulk_pgtbl_create+0x1bc>
  40fe87:	b9 01 00 00 00       	mov    ecx,0x1
  40fe8c:	5d                   	pop    rbp
  40fe8d:	5c                   	pop    rsp
  40fe8e:	85 c0                	test   eax,eax
  40fe90:	0f 85 e5 00 00 00    	jne    40ff7b <cos_ulk_pgtbl_create+0x2ab>
  40fe96:	31 d2                	xor    edx,edx
  40fe98:	8b 45 b4             	mov    eax,DWORD PTR [rbp-0x4c]
--
  40feaf:	49 b8 c8 fe 40 00 00 	movabs r8,0x40fec8
  40feb6:	00 00 00 
  40feb9:	0f 05                	syscall 
  40febb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40fec0:	eb 0d                	jmp    40fecf <cos_ulk_pgtbl_create+0x1ff>
  40fec2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40fec8:	b9 00 00 00 00       	mov    ecx,0x0
  40fecd:	eb 05                	jmp    40fed4 <cos_ulk_pgtbl_create+0x204>
  40fecf:	b9 01 00 00 00       	mov    ecx,0x1
  40fed4:	5d                   	pop    rbp
--
  40feda:	48 01 c6             	add    rsi,rax
  40fedd:	48 89 75 a8          	mov    QWORD PTR [rbp-0x58],rsi
  40fee1:	48 39 75 a0          	cmp    QWORD PTR [rbp-0x60],rsi
  40fee5:	0f 87 e3 fe ff ff    	ja     40fdce <cos_ulk_pgtbl_create+0xfe>
  40feeb:	4c 89 ea             	mov    rdx,r13
--
  40fefa:	4c 8b 6d 88          	mov    r13,QWORD PTR [rbp-0x78]
	for (pgtbl_lvl = 1; pgtbl_lvl < COS_PGTBL_DEPTH - 1; pgtbl_lvl++) {
  40fefe:	48 83 fa 03          	cmp    rdx,0x3
  40ff02:	0f 84 29 fe ff ff    	je     40fd31 <cos_ulk_pgtbl_create+0x61>
  40ff08:	e9 77 fe ff ff       	jmp    40fd84 <cos_ulk_pgtbl_create+0xb4>
  40ff0d:	0f 1f 00             	nop    DWORD PTR [rax]
  40ff10:	be 2e 00 00 00       	mov    esi,0x2e
  40ff15:	bf f8 e2 41 00       	mov    edi,0x41e2f8
  40ff1a:	e8 b1 a1 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci && secondlvl);
  40ff1f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
		if (__capid_captbl_check_expand(ci)) goto error;
  40ff2c:	4c 89 ff             	mov    rdi,r15
  40ff2f:	e8 ac ca ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40ff34:	85 c0                	test   eax,eax
  40ff36:	74 2f                	je     40ff67 <cos_ulk_pgtbl_create+0x297>
  40ff38:	49 c7 87 b0 00 00 00 	mov    QWORD PTR [r15+0xb0],0x0
  40ff3f:	00 00 00 00 
	return __mem_bump_alloc(ci, 1, 1);
  40ff43:	4c 89 ff             	mov    rdi,r15
  40ff46:	e8 15 c9 ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40ff4b:	be 2e 00 00 00       	mov    esi,0x2e
  40ff50:	bf e0 d8 41 00       	mov    edi,0x41d8e0
  40ff55:	e8 76 a1 ff ff       	call   40a0d0 <cos_print_str>
			assert(0);
  40ff5a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40ff72:	49 89 47 38          	mov    QWORD PTR [r15+0x38],rax
  40ff76:	e9 87 fe ff ff       	jmp    40fe02 <cos_ulk_pgtbl_create+0x132>
  40ff7b:	be 2e 00 00 00       	mov    esi,0x2e
  40ff80:	bf 10 d9 41 00       	mov    edi,0x41d910
  40ff85:	e8 46 a1 ff ff       	call   40a0d0 <cos_print_str>
				assert(0); /* race? */
  40ff8a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  40ff97:	be 2e 00 00 00       	mov    esi,0x2e
  40ff9c:	bf b0 d8 41 00       	mov    edi,0x41d8b0
  40ffa1:	e8 2a a1 ff ff       	call   40a0d0 <cos_print_str>
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  40ffa6:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	assert(ci && secondlvl);
  40ffd5:	48 85 ff             	test   rdi,rdi
  40ffd8:	0f 84 7d 02 00 00    	je     41025b <cos_ulk_info_init+0x29b>
  40ffde:	49 89 fd             	mov    r13,rdi
	toplvl = cos_pgtbl_alloc(__compinfo_metacap(ci), PGTBL_TYPE_DEF);
  40ffe1:	48 8b 7f 60          	mov    rdi,QWORD PTR [rdi+0x60]
  40ffe5:	31 f6                	xor    esi,esi
  40ffe7:	e8 74 fb ff ff       	call   40fb60 <cos_pgtbl_alloc>
	*secondlvl = __bump_mem_expand_intern(__compinfo_metacap(ci), toplvl, ULK_BASE_ADDR, 0, 0);
  40ffec:	49 8b 7d 60          	mov    rdi,QWORD PTR [r13+0x60]
--
  410002:	49 89 c7             	mov    r15,rax
	*secondlvl = __bump_mem_expand_intern(__compinfo_metacap(ci), toplvl, ULK_BASE_ADDR, 0, 0);
  410005:	e8 96 d3 ff ff       	call   40d3a0 <__bump_mem_expand_intern>
  41000a:	48 89 05 77 0a 19 00 	mov    QWORD PTR [rip+0x190a77],rax        # 5a0a88 <__cos_ulk_info+0x8>
	if (!*secondlvl) return 0;
  410011:	48 85 c0             	test   rax,rax
  410014:	75 4a                	jne    410060 <cos_ulk_info_init+0xa0>
	__cos_ulk_info.pg_frontier = ULK_BASE_ADDR + __thdid_alloc * sizeof(struct ulk_invstk);
  410016:	48 b8 00 00 00 80 7f 	movabs rax,0x7f80000000
--
  41003d:	be 2e 00 00 00       	mov    esi,0x2e
  410042:	bf 28 e3 41 00       	mov    edi,0x41e328
  410047:	e8 84 a0 ff ff       	call   40a0d0 <cos_print_str>
	assert(__cos_ulk_info.toplvl);
  41004c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  41006c:	48 ba 00 10 00 00 80 	movabs rdx,0x7f8000001000
  410073:	7f 00 00 
  410076:	e8 25 d3 ff ff       	call   40d3a0 <__bump_mem_expand_intern>
  41007b:	48 85 c0             	test   rax,rax
  41007e:	74 96                	je     410016 <cos_ulk_info_init+0x56>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  410080:	44 89 f8             	mov    eax,r15d
--
  4100b3:	00 
		return round_up_to_pgt2_page(vaddr);
  4100b4:	48 83 f8 02          	cmp    rax,0x2
  4100b8:	48 b8 00 00 20 00 80 	movabs rax,0x7f8000200000
  4100bf:	7f 00 00 
--
  4100e2:	48 89 45 a8          	mov    QWORD PTR [rbp-0x58],rax
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  4100e6:	4d 3b 76 60          	cmp    r14,QWORD PTR [r14+0x60]
  4100ea:	0f 85 f2 01 00 00    	jne    4102e2 <cos_ulk_info_init+0x322>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  4100f0:	49 8d 96 b0 00 00 00 	lea    rdx,[r14+0xb0]
--
  4100f9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  410100:	48 89 c8             	mov    rax,rcx
  410103:	f0 4c 0f b1 12       	lock cmpxchg QWORD PTR [rdx],r10
  410108:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  41010b:	84 c0                	test   al,al
  41010d:	74 f1                	je     410100 <cos_ulk_info_init+0x140>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  41010f:	41 f6 46 38 03       	test   BYTE PTR [r14+0x38],0x3
  410114:	0f 84 5d 01 00 00    	je     410277 <cos_ulk_info_init+0x2b7>
        __asm__ __volatile__("lock " PS_FAA_STR
  41011a:	bb 04 00 00 00       	mov    ebx,0x4
--
	return __mem_bump_alloc(ci, 1, 1);
  410130:	4c 89 f7             	mov    rdi,r14
  410133:	e8 28 c7 ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  410138:	48 89 c7             	mov    rdi,rax
		if (pte_cap == 0 || ptemem_cap == 0) {
  41013b:	48 85 db             	test   rbx,rbx
  41013e:	0f 84 52 01 00 00    	je     410296 <cos_ulk_info_init+0x2d6>
  410144:	48 85 c0             	test   rax,rax
  410147:	41 ba 01 00 00 00    	mov    r10d,0x1
  41014d:	0f 84 43 01 00 00    	je     410296 <cos_ulk_info_init+0x2d6>
		if (call_cap_op(meta->captbl_cap, CAPTBL_OP_PGTBLACTIVATE, pte_cap, meta->mi.pgtbl_cap, ptemem_cap,
  410153:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
	__asm__ __volatile__(
--
  410182:	49 b8 98 01 41 00 00 	movabs r8,0x410198
  410189:	00 00 00 
  41018c:	0f 05                	syscall 
  41018e:	66 90                	xchg   ax,ax
  410190:	eb 0d                	jmp    41019f <cos_ulk_info_init+0x1df>
  410192:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410198:	b9 00 00 00 00       	mov    ecx,0x0
  41019d:	eb 05                	jmp    4101a4 <cos_ulk_info_init+0x1e4>
  41019f:	b9 01 00 00 00       	mov    ecx,0x1
  4101a4:	5d                   	pop    rbp
  4101a5:	5c                   	pop    rsp
  4101a6:	85 c0                	test   eax,eax
  4101a8:	0f 85 18 01 00 00    	jne    4102c6 <cos_ulk_info_init+0x306>
  4101ae:	31 d2                	xor    edx,edx
  4101b0:	8b 45 b4             	mov    eax,DWORD PTR [rbp-0x4c]
--
  4101c7:	49 b8 e0 01 41 00 00 	movabs r8,0x4101e0
  4101ce:	00 00 00 
  4101d1:	0f 05                	syscall 
  4101d3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  4101d8:	eb 0d                	jmp    4101e7 <cos_ulk_info_init+0x227>
  4101da:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4101e0:	b9 00 00 00 00       	mov    ecx,0x0
  4101e5:	eb 05                	jmp    4101ec <cos_ulk_info_init+0x22c>
  4101e7:	b9 01 00 00 00       	mov    ecx,0x1
  4101ec:	5d                   	pop    rbp
--
  4101f2:	48 01 c6             	add    rsi,rax
  4101f5:	48 89 75 a8          	mov    QWORD PTR [rbp-0x58],rsi
  4101f9:	48 39 75 a0          	cmp    QWORD PTR [rbp-0x60],rsi
  4101fd:	0f 87 e3 fe ff ff    	ja     4100e6 <cos_ulk_info_init+0x126>
  410203:	4c 89 ea             	mov    rdx,r13
--
  410212:	4c 8b 6d 88          	mov    r13,QWORD PTR [rbp-0x78]
	for (pgtbl_lvl = 1; pgtbl_lvl < COS_PGTBL_DEPTH - 1; pgtbl_lvl++) {
  410216:	48 83 fa 03          	cmp    rdx,0x3
  41021a:	0f 85 7c fe ff ff    	jne    41009c <cos_ulk_info_init+0xdc>
	__cos_ulk_info.pg_frontier = ULK_BASE_ADDR + __thdid_alloc * sizeof(struct ulk_invstk);
  410220:	48 b8 00 00 00 80 7f 	movabs rax,0x7f80000000
--
	assert(__cos_ulk_info.toplvl);
  410243:	4d 85 ff             	test   r15,r15
  410246:	0f 84 f1 fd ff ff    	je     41003d <cos_ulk_info_init+0x7d>
}
  41024c:	48 83 c4 58          	add    rsp,0x58
--
  41025b:	be 2e 00 00 00       	mov    esi,0x2e
  410260:	bf f8 e2 41 00       	mov    edi,0x41e2f8
  410265:	e8 66 9e ff ff       	call   40a0d0 <cos_print_str>
	assert(ci && secondlvl);
  41026a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
		if (__capid_captbl_check_expand(ci)) goto error;
  410277:	4c 89 f7             	mov    rdi,r14
  41027a:	e8 61 c7 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  41027f:	85 c0                	test   eax,eax
  410281:	74 2f                	je     4102b2 <cos_ulk_info_init+0x2f2>
  410283:	49 c7 86 b0 00 00 00 	mov    QWORD PTR [r14+0xb0],0x0
  41028a:	00 00 00 00 
	return __mem_bump_alloc(ci, 1, 1);
  41028e:	4c 89 f7             	mov    rdi,r14
  410291:	e8 ca c5 ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  410296:	be 2e 00 00 00       	mov    esi,0x2e
  41029b:	bf e0 d8 41 00       	mov    edi,0x41d8e0
  4102a0:	e8 2b 9e ff ff       	call   40a0d0 <cos_print_str>
			assert(0);
  4102a5:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  4102bd:	49 89 46 38          	mov    QWORD PTR [r14+0x38],rax
  4102c1:	e9 54 fe ff ff       	jmp    41011a <cos_ulk_info_init+0x15a>
  4102c6:	be 2e 00 00 00       	mov    esi,0x2e
  4102cb:	bf 10 d9 41 00       	mov    edi,0x41d910
  4102d0:	e8 fb 9d ff ff       	call   40a0d0 <cos_print_str>
				assert(0); /* race? */
  4102d5:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  4102e2:	be 2e 00 00 00       	mov    esi,0x2e
  4102e7:	bf b0 d8 41 00       	mov    edi,0x41d8b0
  4102ec:	e8 df 9d ff ff       	call   40a0d0 <cos_print_str>
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  4102f1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  410304:	55                   	push   rbp
  410305:	41 89 d3             	mov    r11d,edx
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_COMPACTIVATE, comp, (ctc << 16) | ptc, ((unsigned long)lid << 32) | protdom, entry)) return 1;
  410308:	48 c1 e1 10          	shl    rcx,0x10
{
  41030c:	49 89 f2             	mov    r10,rsi
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_COMPACTIVATE, comp, (ctc << 16) | ptc, ((unsigned long)lid << 32) | protdom, entry)) return 1;
  41030f:	48 89 ce             	mov    rsi,rcx
{
  410312:	4c 89 ca             	mov    rdx,r9
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_COMPACTIVATE, comp, (ctc << 16) | ptc, ((unsigned long)lid << 32) | protdom, entry)) return 1;
  410315:	4c 09 c6             	or     rsi,r8
{
--
  41031d:	53                   	push   rbx
  41031e:	4c 89 d3             	mov    rbx,r10
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_COMPACTIVATE, comp, (ctc << 16) | ptc, ((unsigned long)lid << 32) | protdom, entry)) return 1;
  410321:	48 8b 47 08          	mov    rax,QWORD PTR [rdi+0x8]
  410325:	8b 4d 10             	mov    ecx,DWORD PTR [rbp+0x10]
--
  410348:	49 b8 60 03 41 00 00 	movabs r8,0x410360
  41034f:	00 00 00 
  410352:	0f 05                	syscall 
  410354:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  410358:	eb 0d                	jmp    410367 <cos_comp_alloc_with+0x67>
  41035a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410360:	b9 00 00 00 00       	mov    ecx,0x0
  410365:	eb 05                	jmp    41036c <cos_comp_alloc_with+0x6c>
  410367:	b9 01 00 00 00       	mov    ecx,0x1
  41036c:	5d                   	pop    rbp
--
}
  410373:	5b                   	pop    rbx
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_COMPACTIVATE, comp, (ctc << 16) | ptc, ((unsigned long)lid << 32) | protdom, entry)) return 1;
  410374:	0f b6 c0             	movzx  eax,al
}
--
	assert(ci && ctc && ptc && lid);
  4103a6:	48 85 ff             	test   rdi,rdi
  4103a9:	0f 84 59 01 00 00    	je     410508 <cos_comp_alloc+0x188>
  4103af:	49 89 f7             	mov    r15,rsi
  4103b2:	48 85 f6             	test   rsi,rsi
  4103b5:	0f 84 4d 01 00 00    	je     410508 <cos_comp_alloc+0x188>
  4103bb:	49 89 d1             	mov    r9,rdx
  4103be:	48 85 d2             	test   rdx,rdx
  4103c1:	0f 84 41 01 00 00    	je     410508 <cos_comp_alloc+0x188>
  4103c7:	45 85 d2             	test   r10d,r10d
  4103ca:	49 89 cd             	mov    r13,rcx
--
  4103df:	31 c9                	xor    ecx,ecx
  4103e1:	84 c0                	test   al,al
  4103e3:	0f 85 1f 01 00 00    	jne    410508 <cos_comp_alloc+0x188>
  4103e9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  4103f0:	48 89 c8             	mov    rax,rcx
  4103f3:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  4103f8:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  4103fb:	84 c0                	test   al,al
  4103fd:	74 f1                	je     4103f0 <cos_comp_alloc+0x70>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  4103ff:	4d 8b 74 24 38       	mov    r14,QWORD PTR [r12+0x38]
  410404:	41 83 e6 03          	and    r14d,0x3
  410408:	0f 84 b2 00 00 00    	je     4104c0 <cos_comp_alloc+0x140>
        __asm__ __volatile__("lock " PS_FAA_STR
  41040e:	bb 04 00 00 00       	mov    ebx,0x4
--
	if (!cap) return 0;
  410429:	48 85 db             	test   rbx,rbx
  41042c:	74 5c                	je     41048a <cos_comp_alloc+0x10a>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_COMPACTIVATE, comp, (ctc << 16) | ptc, ((unsigned long)lid << 32) | protdom, entry)) return 1;
  41042e:	49 8b 44 24 08       	mov    rax,QWORD PTR [r12+0x8]
  410433:	49 c1 e7 10          	shl    r15,0x10
--
  410463:	49 b8 78 04 41 00 00 	movabs r8,0x410478
  41046a:	00 00 00 
  41046d:	0f 05                	syscall 
  41046f:	90                   	nop
  410470:	eb 0d                	jmp    41047f <cos_comp_alloc+0xff>
  410472:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410478:	b9 00 00 00 00       	mov    ecx,0x0
  41047d:	eb 05                	jmp    410484 <cos_comp_alloc+0x104>
  41047f:	b9 01 00 00 00       	mov    ecx,0x1
  410484:	5d                   	pop    rbp
  410485:	5c                   	pop    rsp
  410486:	85 c0                	test   eax,eax
  410488:	75 16                	jne    4104a0 <cos_comp_alloc+0x120>
	if (cos_comp_alloc_with(ci, cap, lid, ctc, ptc, entry, protdom)) BUG();

--
  4104a0:	be 1c 00 00 00       	mov    esi,0x1c
  4104a5:	bf 88 e3 41 00       	mov    edi,0x41e388
  4104aa:	e8 21 9c ff ff       	call   40a0d0 <cos_print_str>
	if (cos_comp_alloc_with(ci, cap, lid, ctc, ptc, entry, protdom)) BUG();
  4104af:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  4104c7:	4c 89 4d b0          	mov    QWORD PTR [rbp-0x50],r9
  4104cb:	44 89 55 bc          	mov    DWORD PTR [rbp-0x44],r10d
  4104cf:	e8 0c c5 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  4104d4:	44 8b 55 bc          	mov    r10d,DWORD PTR [rbp-0x44]
  4104d8:	4c 8b 4d b0          	mov    r9,QWORD PTR [rbp-0x50]
  4104dc:	85 c0                	test   eax,eax
  4104de:	44 8b 45 b8          	mov    r8d,DWORD PTR [rbp-0x48]
  4104e2:	75 16                	jne    4104fa <cos_comp_alloc+0x17a>
        __asm__ __volatile__("lock " PS_FAA_STR
  4104e4:	b8 04 00 00 00       	mov    eax,0x4
--
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  4104f0:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  4104f5:	e9 14 ff ff ff       	jmp    41040e <cos_comp_alloc+0x8e>
{ l->o = 0; }
  4104fa:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  410501:	00 00 00 00 00 
	if (!cap) return 0;
  410506:	eb 82                	jmp    41048a <cos_comp_alloc+0x10a>
  410508:	be 2f 00 00 00       	mov    esi,0x2f
  41050d:	bf 58 e3 41 00       	mov    edi,0x41e358
  410512:	e8 b9 9b ff ff       	call   40a0d0 <cos_print_str>
	assert(ci && ctc && ptc && lid);
  410517:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	assert(ptc);
  41054c:	4d 85 ff             	test   r15,r15
  41054f:	0f 84 7f 01 00 00    	je     4106d4 <cos_comp_alloc_shared+0x1a4>
	assert(ctc);
  410555:	48 85 f6             	test   rsi,rsi
  410558:	0f 84 92 01 00 00    	je     4106f0 <cos_comp_alloc_shared+0x1c0>
  41055e:	49 89 d6             	mov    r14,rdx
	return livenessid_frontier++;
--
	assert(ci && ctc && ptc && lid);
  410573:	48 85 c9             	test   rcx,rcx
  410576:	0f 84 3c 01 00 00    	je     4106b8 <cos_comp_alloc_shared+0x188>
  41057c:	49 89 fd             	mov    r13,rdi
{ while (!ps_cas(&l->o, 0, 1)) ; }
--
  41058c:	45 31 c9             	xor    r9d,r9d
  41058f:	85 d2                	test   edx,edx
  410591:	0f 84 21 01 00 00    	je     4106b8 <cos_comp_alloc_shared+0x188>
  410597:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41059e:	00 00 
  4105a0:	4c 89 c8             	mov    rax,r9
  4105a3:	f0 4c 0f b1 11       	lock cmpxchg QWORD PTR [rcx],r10
  4105a8:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  4105ab:	84 c0                	test   al,al
  4105ad:	74 f1                	je     4105a0 <cos_comp_alloc_shared+0x70>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  4105af:	41 f6 44 24 38 03    	test   BYTE PTR [r12+0x38],0x3
  4105b5:	0f 84 c5 00 00 00    	je     410680 <cos_comp_alloc_shared+0x150>
        __asm__ __volatile__("lock " PS_FAA_STR
  4105bb:	bb 04 00 00 00       	mov    ebx,0x4
--
	if (!cap) return 0;
  4105e1:	48 85 db             	test   rbx,rbx
  4105e4:	0f 84 2e 01 00 00    	je     410718 <cos_comp_alloc_shared+0x1e8>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_COMPACTIVATE, comp, (ctc << 16) | ptc, ((unsigned long)lid << 32) | protdom, entry)) return 1;
  4105ea:	49 8b 44 24 08       	mov    rax,QWORD PTR [r12+0x8]
  4105ef:	48 c1 e2 20          	shl    rdx,0x20
--
  41061c:	49 b8 30 06 41 00 00 	movabs r8,0x410630
  410623:	00 00 00 
  410626:	0f 05                	syscall 
  410628:	eb 0d                	jmp    410637 <cos_comp_alloc_shared+0x107>
  41062a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410630:	b9 00 00 00 00       	mov    ecx,0x0
  410635:	eb 05                	jmp    41063c <cos_comp_alloc_shared+0x10c>
  410637:	b9 01 00 00 00       	mov    ecx,0x1
  41063c:	5d                   	pop    rbp
  41063d:	5c                   	pop    rsp
  41063e:	85 c0                	test   eax,eax
  410640:	75 1e                	jne    410660 <cos_comp_alloc_shared+0x130>
	compc = cos_comp_alloc(ci_resources, ctc, ptc, entry, protdom);
	assert(compc);
--
  410660:	be 1c 00 00 00       	mov    esi,0x1c
  410665:	bf 88 e3 41 00       	mov    edi,0x41e388
  41066a:	e8 61 9a ff ff       	call   40a0d0 <cos_print_str>
	if (cos_comp_alloc_with(ci, cap, lid, ctc, ptc, entry, protdom)) BUG();
  41066f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  410687:	89 55 b4             	mov    DWORD PTR [rbp-0x4c],edx
  41068a:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
  41068e:	e8 4d c3 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  410693:	48 8b 75 b8          	mov    rsi,QWORD PTR [rbp-0x48]
  410697:	8b 55 b4             	mov    edx,DWORD PTR [rbp-0x4c]
  41069a:	85 c0                	test   eax,eax
  41069c:	44 8b 45 b0          	mov    r8d,DWORD PTR [rbp-0x50]
  4106a0:	75 6a                	jne    41070c <cos_comp_alloc_shared+0x1dc>
        __asm__ __volatile__("lock " PS_FAA_STR
  4106a2:	b8 04 00 00 00       	mov    eax,0x4
--
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  4106ae:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  4106b3:	e9 03 ff ff ff       	jmp    4105bb <cos_comp_alloc_shared+0x8b>
  4106b8:	be 2f 00 00 00       	mov    esi,0x2f
  4106bd:	bf 58 e3 41 00       	mov    edi,0x41e358
  4106c2:	e8 09 9a ff ff       	call   40a0d0 <cos_print_str>
	assert(ci && ctc && ptc && lid);
  4106c7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  4106d4:	be 2f 00 00 00       	mov    esi,0x2f
  4106d9:	bf a8 e3 41 00       	mov    edi,0x41e3a8
  4106de:	e8 ed 99 ff ff       	call   40a0d0 <cos_print_str>
	assert(ptc);
  4106e3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  4106f0:	be 2f 00 00 00       	mov    esi,0x2f
  4106f5:	bf d8 e3 41 00       	mov    edi,0x41e3d8
  4106fa:	e8 d1 99 ff ff       	call   40a0d0 <cos_print_str>
	assert(ctc);
  4106ff:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  410718:	be 2f 00 00 00       	mov    esi,0x2f
  41071d:	bf 08 e4 41 00       	mov    edi,0x41e408
  410722:	e8 a9 99 ff ff       	call   40a0d0 <cos_print_str>
	assert(compc);
  410727:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  410768:	48 83 ec 38          	sub    rsp,0x38
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  41076c:	80 bf d8 00 00 00 01 	cmp    BYTE PTR [rdi+0xd8],0x1
{
  410773:	48 89 55 a8          	mov    QWORD PTR [rbp-0x58],rdx
--
  4107a8:	4c 0f 44 e0          	cmove  r12,rax
	ptc = cos_pgtbl_alloc(ci_resources, mem_type);
  4107ac:	e8 af f3 ff ff       	call   40fb60 <cos_pgtbl_alloc>
	assert(ptc);
  4107b1:	48 85 c0             	test   rax,rax
  4107b4:	0f 84 28 01 00 00    	je     4108e2 <cos_compinfo_alloc+0x1a2>
	ctc = cos_captbl_alloc(ci_resources);
  4107ba:	48 89 df             	mov    rdi,rbx
  4107bd:	49 89 c7             	mov    r15,rax
  4107c0:	e8 3b f2 ff ff       	call   40fa00 <cos_captbl_alloc>
	assert(ctc);
  4107c5:	48 85 c0             	test   rax,rax
  4107c8:	0f 84 30 01 00 00    	je     4108fe <cos_compinfo_alloc+0x1be>
	compc = cos_comp_alloc(ci_resources, ctc, ptc, entry, protdom);
  4107ce:	48 8b 4d c8          	mov    rcx,QWORD PTR [rbp-0x38]
--
  4107dc:	48 89 df             	mov    rdi,rbx
  4107df:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
  4107e3:	e8 98 fb ff ff       	call   410380 <cos_comp_alloc>
	assert(compc);
  4107e8:	4c 8b 55 c8          	mov    r10,QWORD PTR [rbp-0x38]
--
  4107ef:	48 89 c1             	mov    rcx,rax
	assert(compc);
  4107f2:	0f 84 22 01 00 00    	je     41091a <cos_compinfo_alloc+0x1da>

	cos_compinfo_init(ci, ptc, ctc, compc, heap_ptr, cap_frontier, ci_resources);
--
  41080b:	4c 89 ef             	mov    rdi,r13
  41080e:	49 89 d8             	mov    r8,rbx
  410811:	e8 0a cf ff ff       	call   40d720 <cos_compinfo_init>

	ci->mi.second_lvl_pgtbl_cap  = __bump_mem_expand_intern(__compinfo_metacap(ci), ci->pgtbl_cap, heap_ptr, 0, 0 | pgtbl_lvl_flag);
--
  410821:	31 c9                	xor    ecx,ecx
  410823:	4d 89 e0             	mov    r8,r12
  410826:	e8 75 cb ff ff       	call   40d3a0 <__bump_mem_expand_intern>
  41082b:	66 48 0f 6e cb       	movq   xmm1,rbx
  410830:	66 48 0f 6e c0       	movq   xmm0,rax
--
  41086c:	ff ff ff 
  41086f:	48 85 c3             	test   rbx,rax
  410872:	75 4c                	jne    4108c0 <cos_compinfo_alloc+0x180>

	}
--
  41087b:	4c 89 fe             	mov    rsi,r15
  41087e:	31 c9                	xor    ecx,ecx
  410880:	e8 1b cb ff ff       	call   40d3a0 <__bump_mem_expand_intern>
  410885:	49 8b 45 40          	mov    rax,QWORD PTR [r13+0x40]
  410889:	49 8b 7d 60          	mov    rdi,QWORD PTR [r13+0x60]
--
  410896:	48 8d 50 ff          	lea    rdx,[rax-0x1]
  41089a:	48 81 e2 00 f0 ff ff 	and    rdx,0xfffffffffffff000
  4108a1:	e8 fa ca ff ff       	call   40d3a0 <__bump_mem_expand_intern>
	}

--
  4108c7:	31 c9                	xor    ecx,ecx
  4108c9:	4c 89 fe             	mov    rsi,r15
  4108cc:	e8 cf ca ff ff       	call   40d3a0 <__bump_mem_expand_intern>
		__bump_mem_expand_intern(__compinfo_metacap(ci), ptc, round_to_page(ci->vas_frontier - 1), 0, pgtbl_lvl | pgtbl_lvl_flag);	
  4108d1:	49 8b 45 40          	mov    rax,QWORD PTR [r13+0x40]
  4108d5:	48 8d 50 ff          	lea    rdx,[rax-0x1]
  4108d9:	48 81 e2 00 f0 ff ff 	and    rdx,0xfffffffffffff000
  4108e0:	eb 92                	jmp    410874 <cos_compinfo_alloc+0x134>
  4108e2:	be 2f 00 00 00       	mov    esi,0x2f
  4108e7:	bf 38 e4 41 00       	mov    edi,0x41e438
  4108ec:	e8 df 97 ff ff       	call   40a0d0 <cos_print_str>
	assert(ptc);
  4108f1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  4108fe:	be 2f 00 00 00       	mov    esi,0x2f
  410903:	bf 68 e4 41 00       	mov    edi,0x41e468
  410908:	e8 c3 97 ff ff       	call   40a0d0 <cos_print_str>
	assert(ctc);
  41090d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  41091a:	be 2f 00 00 00       	mov    esi,0x2f
  41091f:	bf 98 e4 41 00       	mov    edi,0x41e498
  410924:	e8 a7 97 ff ff       	call   40a0d0 <cos_print_str>
	assert(compc);
  410929:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	assert(srcci && dstcomp);
  410955:	48 85 ff             	test   rdi,rdi
  410958:	0f 84 2c 01 00 00    	je     410a8a <cos_sinv_alloc+0x14a>
  41095e:	49 89 f7             	mov    r15,rsi
  410961:	48 85 f6             	test   rsi,rsi
  410964:	0f 84 20 01 00 00    	je     410a8a <cos_sinv_alloc+0x14a>
  41096a:	49 89 fc             	mov    r12,rdi
  41096d:	49 89 d5             	mov    r13,rdx
  410970:	49 89 ce             	mov    r14,rcx
	missing_captbl_node_expand(srcci);
  410973:	e8 58 d4 ff ff       	call   40ddd0 <missing_captbl_node_expand>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  410978:	49 8d 8c 24 b0 00 00 	lea    rcx,[r12+0xb0]
--
  41098e:	00 00 
  410990:	48 89 d0             	mov    rax,rdx
  410993:	f0 48 0f b1 31       	lock cmpxchg QWORD PTR [rcx],rsi
  410998:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  41099b:	84 c0                	test   al,al
  41099d:	74 f1                	je     410990 <cos_sinv_alloc+0x50>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  41099f:	4d 8b 54 24 38       	mov    r10,QWORD PTR [r12+0x38]
  4109a4:	41 83 e2 03          	and    r10d,0x3
  4109a8:	0f 84 82 00 00 00    	je     410a30 <cos_sinv_alloc+0xf0>
        __asm__ __volatile__("lock " PS_FAA_STR
  4109ae:	bb 04 00 00 00       	mov    ebx,0x4
--
	if (!cap) return 0;
  4109c9:	48 85 db             	test   rbx,rbx
  4109cc:	74 4c                	je     410a1a <cos_sinv_alloc+0xda>
	if (call_cap_op(srcci->captbl_cap, CAPTBL_OP_SINVACTIVATE, cap, dstcomp, entry, token)) BUG();
  4109ce:	49 8b 44 24 08       	mov    rax,QWORD PTR [r12+0x8]
  4109d3:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
--
  4109f2:	49 b8 08 0a 41 00 00 	movabs r8,0x410a08
  4109f9:	00 00 00 
  4109fc:	0f 05                	syscall 
  4109fe:	66 90                	xchg   ax,ax
  410a00:	eb 0d                	jmp    410a0f <cos_sinv_alloc+0xcf>
  410a02:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410a08:	b9 00 00 00 00       	mov    ecx,0x0
  410a0d:	eb 05                	jmp    410a14 <cos_sinv_alloc+0xd4>
  410a0f:	b9 01 00 00 00       	mov    ecx,0x1
  410a14:	5d                   	pop    rbp
  410a15:	5c                   	pop    rsp
  410a16:	85 c0                	test   eax,eax
  410a18:	75 46                	jne    410a60 <cos_sinv_alloc+0x120>

	return cap;
--
  410a30:	4c 89 e7             	mov    rdi,r12
  410a33:	4c 89 55 b8          	mov    QWORD PTR [rbp-0x48],r10
  410a37:	e8 a4 bf ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  410a3c:	4c 8b 55 b8          	mov    r10,QWORD PTR [rbp-0x48]
  410a40:	85 c0                	test   eax,eax
  410a42:	75 38                	jne    410a7c <cos_sinv_alloc+0x13c>
        __asm__ __volatile__("lock " PS_FAA_STR
  410a44:	b8 04 00 00 00       	mov    eax,0x4
--
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  410a50:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  410a55:	e9 54 ff ff ff       	jmp    4109ae <cos_sinv_alloc+0x6e>
  410a5a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410a60:	be 1c 00 00 00       	mov    esi,0x1c
  410a65:	bf f8 e4 41 00       	mov    edi,0x41e4f8
  410a6a:	e8 61 96 ff ff       	call   40a0d0 <cos_print_str>
	if (call_cap_op(srcci->captbl_cap, CAPTBL_OP_SINVACTIVATE, cap, dstcomp, entry, token)) BUG();
  410a6f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410a76:	00 00 00 00 
--
  410a83:	00 00 00 00 00 
	if (!cap) return 0;
  410a88:	eb 90                	jmp    410a1a <cos_sinv_alloc+0xda>
  410a8a:	be 2f 00 00 00       	mov    esi,0x2f
  410a8f:	bf c8 e4 41 00       	mov    edi,0x41e4c8
  410a94:	e8 37 96 ff ff       	call   40a0d0 <cos_print_str>
	assert(srcci && dstcomp);
  410a99:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	assert(ci && thdcap && tcapcap && compcap);
  410ac5:	48 85 ff             	test   rdi,rdi
  410ac8:	0f 84 4c 01 00 00    	je     410c1a <cos_arcv_alloc+0x16a>
  410ace:	48 85 f6             	test   rsi,rsi
  410ad1:	0f 84 43 01 00 00    	je     410c1a <cos_arcv_alloc+0x16a>
  410ad7:	48 85 d2             	test   rdx,rdx
  410ada:	0f 84 3a 01 00 00    	je     410c1a <cos_arcv_alloc+0x16a>
  410ae0:	48 85 c9             	test   rcx,rcx
  410ae3:	49 89 cd             	mov    r13,rcx
--
  410afc:	45 31 c9             	xor    r9d,r9d
  410aff:	84 c0                	test   al,al
  410b01:	0f 85 13 01 00 00    	jne    410c1a <cos_arcv_alloc+0x16a>
  410b07:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  410b0e:	00 00 
  410b10:	4c 89 c8             	mov    rax,r9
  410b13:	f0 4c 0f b1 11       	lock cmpxchg QWORD PTR [rcx],r10
  410b18:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  410b1b:	84 c0                	test   al,al
  410b1d:	74 f1                	je     410b10 <cos_arcv_alloc+0x60>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  410b1f:	4d 8b 7c 24 38       	mov    r15,QWORD PTR [r12+0x38]
  410b24:	41 83 e7 03          	and    r15d,0x3
  410b28:	0f 84 8a 00 00 00    	je     410bb8 <cos_arcv_alloc+0x108>
        __asm__ __volatile__("lock " PS_FAA_STR
  410b2e:	bb 04 00 00 00       	mov    ebx,0x4
--
	if (!cap) return 0;
  410b49:	48 85 db             	test   rbx,rbx
  410b4c:	74 54                	je     410ba2 <cos_arcv_alloc+0xf2>
	if ((ret = call_cap_op(ci->captbl_cap, CAPTBL_OP_ARCVACTIVATE, cap, thdcap | (tcapcap << 16), compcap, arcvcap))) BUG();
  410b4e:	49 8b 44 24 08       	mov    rax,QWORD PTR [r12+0x8]
  410b53:	48 c1 e2 10          	shl    rdx,0x10
--
  410b76:	49 b8 90 0b 41 00 00 	movabs r8,0x410b90
  410b7d:	00 00 00 
  410b80:	0f 05                	syscall 
  410b82:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410b88:	eb 0d                	jmp    410b97 <cos_arcv_alloc+0xe7>
  410b8a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410b90:	b9 00 00 00 00       	mov    ecx,0x0
  410b95:	eb 05                	jmp    410b9c <cos_arcv_alloc+0xec>
  410b97:	b9 01 00 00 00       	mov    ecx,0x1
  410b9c:	5d                   	pop    rbp
  410b9d:	5c                   	pop    rsp
  410b9e:	85 c0                	test   eax,eax
  410ba0:	75 4e                	jne    410bf0 <cos_arcv_alloc+0x140>

	return cap;
--
  410bbb:	48 89 55 b0          	mov    QWORD PTR [rbp-0x50],rdx
  410bbf:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
  410bc3:	e8 18 be ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  410bc8:	48 8b 75 b8          	mov    rsi,QWORD PTR [rbp-0x48]
  410bcc:	48 8b 55 b0          	mov    rdx,QWORD PTR [rbp-0x50]
  410bd0:	85 c0                	test   eax,eax
  410bd2:	75 38                	jne    410c0c <cos_arcv_alloc+0x15c>
        __asm__ __volatile__("lock " PS_FAA_STR
  410bd4:	b8 04 00 00 00       	mov    eax,0x4
--
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  410be0:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  410be5:	e9 44 ff ff ff       	jmp    410b2e <cos_arcv_alloc+0x7e>
  410bea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410bf0:	be 1c 00 00 00       	mov    esi,0x1c
  410bf5:	bf 48 e5 41 00       	mov    edi,0x41e548
  410bfa:	e8 d1 94 ff ff       	call   40a0d0 <cos_print_str>
	if ((ret = call_cap_op(ci->captbl_cap, CAPTBL_OP_ARCVACTIVATE, cap, thdcap | (tcapcap << 16), compcap, arcvcap))) BUG();
  410bff:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410c06:	00 00 00 00 
--
  410c13:	00 00 00 00 00 
	if (!cap) return 0;
  410c18:	eb 88                	jmp    410ba2 <cos_arcv_alloc+0xf2>
  410c1a:	be 2f 00 00 00       	mov    esi,0x2f
  410c1f:	bf 18 e5 41 00       	mov    edi,0x41e518
  410c24:	e8 a7 94 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci && thdcap && tcapcap && compcap);
  410c29:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  410c61:	0f 94 c2             	sete   dl
  410c64:	08 d0                	or     al,dl
  410c66:	0f 85 16 01 00 00    	jne    410d82 <cos_asnd_alloc+0x142>
  410c6c:	48 85 ff             	test   rdi,rdi
  410c6f:	49 89 fc             	mov    r12,rdi
--
  410c85:	31 c9                	xor    ecx,ecx
  410c87:	84 c0                	test   al,al
  410c89:	0f 85 f3 00 00 00    	jne    410d82 <cos_asnd_alloc+0x142>
  410c8f:	90                   	nop
  410c90:	48 89 c8             	mov    rax,rcx
  410c93:	f0 4c 0f b1 02       	lock cmpxchg QWORD PTR [rdx],r8
  410c98:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  410c9b:	84 c0                	test   al,al
  410c9d:	74 f1                	je     410c90 <cos_asnd_alloc+0x50>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  410c9f:	4d 8b 7c 24 38       	mov    r15,QWORD PTR [r12+0x38]
  410ca4:	41 83 e7 03          	and    r15d,0x3
  410ca8:	0f 84 82 00 00 00    	je     410d30 <cos_asnd_alloc+0xf0>
        __asm__ __volatile__("lock " PS_FAA_STR
  410cae:	bb 04 00 00 00       	mov    ebx,0x4
--
	if (!cap) return 0;
  410cc9:	48 85 db             	test   rbx,rbx
  410ccc:	74 4c                	je     410d1a <cos_asnd_alloc+0xda>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_ASNDACTIVATE, cap, ctcap, arcvcap, 0)) BUG();
  410cce:	49 8b 44 24 08       	mov    rax,QWORD PTR [r12+0x8]
  410cd3:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
--
  410cf1:	49 b8 08 0d 41 00 00 	movabs r8,0x410d08
  410cf8:	00 00 00 
  410cfb:	0f 05                	syscall 
  410cfd:	0f 1f 00             	nop    DWORD PTR [rax]
  410d00:	eb 0d                	jmp    410d0f <cos_asnd_alloc+0xcf>
  410d02:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410d08:	b9 00 00 00 00       	mov    ecx,0x0
  410d0d:	eb 05                	jmp    410d14 <cos_asnd_alloc+0xd4>
  410d0f:	b9 01 00 00 00       	mov    ecx,0x1
  410d14:	5d                   	pop    rbp
  410d15:	5c                   	pop    rsp
  410d16:	85 c0                	test   eax,eax
  410d18:	75 3e                	jne    410d58 <cos_asnd_alloc+0x118>

	return cap;
--
		if (__capid_captbl_check_expand(ci)) goto error;
  410d30:	4c 89 e7             	mov    rdi,r12
  410d33:	e8 a8 bc ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  410d38:	85 c0                	test   eax,eax
  410d3a:	75 38                	jne    410d74 <cos_asnd_alloc+0x134>
        __asm__ __volatile__("lock " PS_FAA_STR
  410d3c:	b8 04 00 00 00       	mov    eax,0x4
--
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  410d48:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  410d4d:	e9 5c ff ff ff       	jmp    410cae <cos_asnd_alloc+0x6e>
  410d52:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410d58:	be 1c 00 00 00       	mov    esi,0x1c
  410d5d:	bf 98 e5 41 00       	mov    edi,0x41e598
  410d62:	e8 69 93 ff ff       	call   40a0d0 <cos_print_str>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_ASNDACTIVATE, cap, ctcap, arcvcap, 0)) BUG();
  410d67:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410d6e:	00 00 00 00 
--
  410d7b:	00 00 00 00 00 
	if (!cap) return 0;
  410d80:	eb 98                	jmp    410d1a <cos_asnd_alloc+0xda>
  410d82:	be 2f 00 00 00       	mov    esi,0x2f
  410d87:	bf 68 e5 41 00       	mov    edi,0x41e568
  410d8c:	e8 3f 93 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci && arcvcap && ctcap);
  410d91:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	assert(ci);
  410db3:	48 85 ff             	test   rdi,rdi
  410db6:	0f 84 0e 01 00 00    	je     410eca <cos_hw_alloc+0x12a>
  410dbc:	49 89 fc             	mov    r12,rdi
  410dbf:	41 89 f6             	mov    r14d,esi
--
        __asm__ __volatile__("lock " PS_CAS_STR
  410dd8:	48 89 c8             	mov    rax,rcx
  410ddb:	f0 4c 0f b1 02       	lock cmpxchg QWORD PTR [rdx],r8
  410de0:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  410de3:	84 c0                	test   al,al
  410de5:	74 f1                	je     410dd8 <cos_hw_alloc+0x38>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  410de7:	4d 8b 6c 24 30       	mov    r13,QWORD PTR [r12+0x30]
  410dec:	41 83 e5 03          	and    r13d,0x3
  410df0:	0f 84 82 00 00 00    	je     410e78 <cos_hw_alloc+0xd8>
        __asm__ __volatile__("lock " PS_FAA_STR
  410df6:	bb 02 00 00 00       	mov    ebx,0x2
--
	if (!cap) return 0;
  410e11:	48 85 db             	test   rbx,rbx
  410e14:	74 4c                	je     410e62 <cos_hw_alloc+0xc2>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_HW_ACTIVATE, cap, bitmap, 0, 0)) BUG();
  410e16:	49 8b 44 24 08       	mov    rax,QWORD PTR [r12+0x8]
  410e1b:	31 d2                	xor    edx,edx
--
  410e39:	49 b8 50 0e 41 00 00 	movabs r8,0x410e50
  410e40:	00 00 00 
  410e43:	0f 05                	syscall 
  410e45:	0f 1f 00             	nop    DWORD PTR [rax]
  410e48:	eb 0d                	jmp    410e57 <cos_hw_alloc+0xb7>
  410e4a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410e50:	b9 00 00 00 00       	mov    ecx,0x0
  410e55:	eb 05                	jmp    410e5c <cos_hw_alloc+0xbc>
  410e57:	b9 01 00 00 00       	mov    ecx,0x1
  410e5c:	5d                   	pop    rbp
  410e5d:	5c                   	pop    rsp
  410e5e:	85 c0                	test   eax,eax
  410e60:	75 3e                	jne    410ea0 <cos_hw_alloc+0x100>

	return cap;
--
		if (__capid_captbl_check_expand(ci)) goto error;
  410e78:	4c 89 e7             	mov    rdi,r12
  410e7b:	e8 60 bb ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  410e80:	85 c0                	test   eax,eax
  410e82:	75 38                	jne    410ebc <cos_hw_alloc+0x11c>
        __asm__ __volatile__("lock " PS_FAA_STR
  410e84:	b8 04 00 00 00       	mov    eax,0x4
--
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  410e90:	49 89 44 24 30       	mov    QWORD PTR [r12+0x30],rax
  410e95:	e9 5c ff ff ff       	jmp    410df6 <cos_hw_alloc+0x56>
  410e9a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410ea0:	be 1c 00 00 00       	mov    esi,0x1c
  410ea5:	bf e8 e5 41 00       	mov    edi,0x41e5e8
  410eaa:	e8 21 92 ff ff       	call   40a0d0 <cos_print_str>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_HW_ACTIVATE, cap, bitmap, 0, 0)) BUG();
  410eaf:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410eb6:	00 00 00 00 
--
  410ec3:	00 00 00 00 00 
	if (!cap) return 0;
  410ec8:	eb 98                	jmp    410e62 <cos_hw_alloc+0xc2>
  410eca:	be 2f 00 00 00       	mov    esi,0x2f
  410ecf:	bf b8 e5 41 00       	mov    edi,0x41e5b8
  410ed4:	e8 f7 91 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci);
  410ed9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	assert(sz % PAGE_SIZE == 0);
  410ef4:	f7 c6 ff 0f 00 00    	test   esi,0xfff
  410efa:	75 0a                	jne    410f06 <cos_page_bump_allocn+0x16>
	return (void *)__page_bump_alloc(ci, sz, PAGE_SIZE);
  410efc:	ba 00 10 00 00       	mov    edx,0x1000
  410f01:	e9 2a c2 ff ff       	jmp    40d130 <__page_bump_alloc>
{
  410f06:	55                   	push   rbp
--
  410f0c:	bf 08 e6 41 00       	mov    edi,0x41e608
  410f11:	48 89 e5             	mov    rbp,rsp
  410f14:	e8 b7 91 ff ff       	call   40a0d0 <cos_print_str>
	assert(sz % PAGE_SIZE == 0);
  410f19:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	assert(sz % PAGE_SIZE == 0);
  410f38:	f7 c6 ff 0f 00 00    	test   esi,0xfff
  410f3e:	75 0e                	jne    410f4e <cos_page_bump_allocn_aligned+0x1e>
	assert(align % PAGE_SIZE == 0);
  410f40:	f7 c2 ff 0f 00 00    	test   edx,0xfff
  410f46:	75 22                	jne    410f6a <cos_page_bump_allocn_aligned+0x3a>

	return (void *)__page_bump_alloc(ci, sz, align);
--
  410f48:	5d                   	pop    rbp
	return (void *)__page_bump_alloc(ci, sz, align);
  410f49:	e9 e2 c1 ff ff       	jmp    40d130 <__page_bump_alloc>
  410f4e:	be 2f 00 00 00       	mov    esi,0x2f
  410f53:	bf 38 e6 41 00       	mov    edi,0x41e638
  410f58:	e8 73 91 ff ff       	call   40a0d0 <cos_print_str>
	assert(sz % PAGE_SIZE == 0);
  410f5d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  410f6a:	be 2f 00 00 00       	mov    esi,0x2f
  410f6f:	bf 68 e6 41 00       	mov    edi,0x41e668
  410f74:	e8 57 91 ff ff       	call   40a0d0 <cos_print_str>
	assert(align % PAGE_SIZE == 0);
  410f79:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  410f94:	ba 00 10 00 00       	mov    edx,0x1000
  410f99:	be 00 10 00 00       	mov    esi,0x1000
  410f9e:	e9 8d c1 ff ff       	jmp    40d130 <__page_bump_alloc>
  410fa3:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  410faa:	00 00 00 00 
--
	assert(srcci && dstci);
  410fc5:	48 85 f6             	test   rsi,rsi
  410fc8:	0f 84 7f 01 00 00    	je     41114d <cos_cap_cpy+0x19d>
  410fce:	49 89 fc             	mov    r12,rdi
  410fd1:	48 85 ff             	test   rdi,rdi
  410fd4:	0f 84 73 01 00 00    	je     41114d <cos_cap_cpy+0x19d>
  410fda:	49 89 f6             	mov    r14,rsi
  410fdd:	48 89 cb             	mov    rbx,rcx
  410fe0:	83 fa 14             	cmp    edx,0x14
  410fe3:	0f 87 27 01 00 00    	ja     411110 <cos_cap_cpy+0x160>
  410fe9:	b8 01 00 00 00       	mov    eax,0x1
--
  410ffa:	48 d3 e0             	shl    rax,cl
  410ffd:	a9 da 81 1f 00       	test   eax,0x1f81da
  411002:	0f 84 b0 00 00 00    	je     4110b8 <cos_cap_cpy+0x108>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  411008:	49 8d 94 24 b0 00 00 	lea    rdx,[r12+0xb0]
--
  41101e:	00 00 
  411020:	48 89 c8             	mov    rax,rcx
  411023:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  411028:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  41102b:	84 c0                	test   al,al
  41102d:	74 f1                	je     411020 <cos_cap_cpy+0x70>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  41102f:	4d 8b 28             	mov    r13,QWORD PTR [r8]
  411032:	41 83 e5 03          	and    r13d,0x3
  411036:	0f 84 9c 00 00 00    	je     4110d8 <cos_cap_cpy+0x128>
        __asm__ __volatile__("lock " PS_FAA_STR
  41103c:	4c 89 f8             	mov    rax,r15
--
	if (!dstcap) return 0;
  411053:	48 85 c0             	test   rax,rax
  411056:	74 4a                	je     4110a2 <cos_cap_cpy+0xf2>

	if (call_cap_op(srcci->captbl_cap, CAPTBL_OP_CPY, srccap, dstci->captbl_cap, dstcap, 0)) BUG();
  411058:	49 8b 46 08          	mov    rax,QWORD PTR [r14+0x8]
  41105c:	49 8b 74 24 08       	mov    rsi,QWORD PTR [r12+0x8]
--
  41107a:	49 b8 90 10 41 00 00 	movabs r8,0x411090
  411081:	00 00 00 
  411084:	0f 05                	syscall 
  411086:	66 90                	xchg   ax,ax
  411088:	eb 0d                	jmp    411097 <cos_cap_cpy+0xe7>
  41108a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411090:	b9 00 00 00 00       	mov    ecx,0x0
  411095:	eb 05                	jmp    41109c <cos_cap_cpy+0xec>
  411097:	b9 01 00 00 00       	mov    ecx,0x1
  41109c:	5d                   	pop    rbp
  41109d:	5c                   	pop    rsp
  41109e:	85 c0                	test   eax,eax
  4110a0:	75 7e                	jne    411120 <cos_cap_cpy+0x170>

	return dstcap;
--
  4110b4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  4110b8:	a9 24 10 00 00       	test   eax,0x1024
  4110bd:	75 41                	jne    411100 <cos_cap_cpy+0x150>
  4110bf:	f6 c4 60             	test   ah,0x60
  4110c2:	74 4c                	je     411110 <cos_cap_cpy+0x160>
		frontier = &ci->cap32_frontier[cos_cpuid()];
  4110c4:	4c 8d 47 30          	lea    r8,[rdi+0x30]
		break;
  4110c8:	41 bf 02 00 00 00    	mov    r15d,0x2
  4110ce:	e9 35 ff ff ff       	jmp    411008 <cos_cap_cpy+0x58>
  4110d3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  4110d8:	4c 89 e7             	mov    rdi,r12
  4110db:	4c 89 45 b8          	mov    QWORD PTR [rbp-0x48],r8
  4110df:	e8 fc b8 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  4110e4:	4c 8b 45 b8          	mov    r8,QWORD PTR [rbp-0x48]
  4110e8:	85 c0                	test   eax,eax
  4110ea:	75 50                	jne    41113c <cos_cap_cpy+0x18c>
  4110ec:	b8 04 00 00 00       	mov    eax,0x4
  4110f1:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  4110f8:	49 89 00             	mov    QWORD PTR [r8],rax
  4110fb:	e9 3c ff ff ff       	jmp    41103c <cos_cap_cpy+0x8c>
		frontier = &ci->cap16_frontier[cos_cpuid()];
  411100:	4c 8d 47 28          	lea    r8,[rdi+0x28]
		break;
  411104:	41 bf 01 00 00 00    	mov    r15d,0x1
  41110a:	e9 f9 fe ff ff       	jmp    411008 <cos_cap_cpy+0x58>
  41110f:	90                   	nop
  411110:	49 c7 c5 ff ff ff ff 	mov    r13,0xffffffffffffffff
  411117:	e9 3c ff ff ff       	jmp    411058 <cos_cap_cpy+0xa8>
  41111c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  411120:	be 1c 00 00 00       	mov    esi,0x1c
  411125:	bf c8 e6 41 00       	mov    edi,0x41e6c8
  41112a:	e8 a1 8f ff ff       	call   40a0d0 <cos_print_str>
	if (call_cap_op(srcci->captbl_cap, CAPTBL_OP_CPY, srccap, dstci->captbl_cap, dstcap, 0)) BUG();
  41112f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411136:	00 00 00 00 
--
  411143:	00 00 00 00 00 
	if (!dstcap) return 0;
  411148:	e9 55 ff ff ff       	jmp    4110a2 <cos_cap_cpy+0xf2>
  41114d:	be 2f 00 00 00       	mov    esi,0x2f
  411152:	bf 98 e6 41 00       	mov    edi,0x41e698
  411157:	e8 74 8f ff ff       	call   40a0d0 <cos_print_str>
	assert(srcci && dstci);
  41115c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	assert(srcci && dstci);
  41117f:	48 85 d2             	test   rdx,rdx
  411182:	0f 84 84 00 00 00    	je     41120c <cos_cap_cpy_at+0x9c>
  411188:	49 89 f8             	mov    r8,rdi
  41118b:	48 85 ff             	test   rdi,rdi
  41118e:	74 7c                	je     41120c <cos_cap_cpy_at+0x9c>
  411190:	48 89 f7             	mov    rdi,rsi

	if (!dstcap) return 0;
  411193:	48 85 f6             	test   rsi,rsi
  411196:	74 4a                	je     4111e2 <cos_cap_cpy_at+0x72>

	if (call_cap_op(srcci->captbl_cap, CAPTBL_OP_CPY, srccap, dstci->captbl_cap, dstcap, 0)) BUG();
  411198:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  41119c:	48 89 cb             	mov    rbx,rcx
--
  4111b9:	49 b8 d0 11 41 00 00 	movabs r8,0x4111d0
  4111c0:	00 00 00 
  4111c3:	0f 05                	syscall 
  4111c5:	0f 1f 00             	nop    DWORD PTR [rax]
  4111c8:	eb 0d                	jmp    4111d7 <cos_cap_cpy_at+0x67>
  4111ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4111d0:	b9 00 00 00 00       	mov    ecx,0x0
  4111d5:	eb 05                	jmp    4111dc <cos_cap_cpy_at+0x6c>
  4111d7:	b9 01 00 00 00       	mov    ecx,0x1
  4111dc:	5d                   	pop    rbp
  4111dd:	5c                   	pop    rsp
  4111de:	85 c0                	test   eax,eax
  4111e0:	75 0e                	jne    4111f0 <cos_cap_cpy_at+0x80>

	return 0;
--
  4111f0:	be 1c 00 00 00       	mov    esi,0x1c
  4111f5:	bf 18 e7 41 00       	mov    edi,0x41e718
  4111fa:	e8 d1 8e ff ff       	call   40a0d0 <cos_print_str>
	if (call_cap_op(srcci->captbl_cap, CAPTBL_OP_CPY, srccap, dstci->captbl_cap, dstcap, 0)) BUG();
  4111ff:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411206:	00 00 00 00 
--
  41120c:	be 2f 00 00 00       	mov    esi,0x2f
  411211:	bf e8 e6 41 00       	mov    edi,0x41e6e8
  411216:	e8 b5 8e ff ff       	call   40a0d0 <cos_print_str>
	assert(srcci && dstci);
  41121b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
0000000000411230 <cos_thd_switch>:

/**************** [Kernel Object Operations] ****************/

int
--
  41125a:	49 b8 70 12 41 00 00 	movabs r8,0x411270
  411261:	00 00 00 
  411264:	0f 05                	syscall 
  411266:	66 90                	xchg   ax,ax
  411268:	eb 0d                	jmp    411277 <cos_thd_switch+0x47>
  41126a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411270:	b9 00 00 00 00       	mov    ecx,0x0
  411275:	eb 05                	jmp    41127c <cos_thd_switch+0x4c>
  411277:	b9 01 00 00 00       	mov    ecx,0x1
  41127c:	5d                   	pop    rbp
  41127d:	5c                   	pop    rsp
	return call_cap_op(c, 0, 0, 0, 0, 0);
}
  41127e:	5b                   	pop    rbx
--
	cap_no += op;
  41129e:	8d 86 2a 00 01 00    	lea    eax,[rsi+0x1002a]
	return call_cap_op(tc, CAPTBL_OP_TCAP_WAKEUP, thd, (prio << 32) >> 32, prio >> 32, res);
  4112a4:	48 c1 ef 20          	shr    rdi,0x20
  4112a8:	89 d6                	mov    esi,edx
--
  4112c9:	49 b8 e0 12 41 00 00 	movabs r8,0x4112e0
  4112d0:	00 00 00 
  4112d3:	0f 05                	syscall 
  4112d5:	0f 1f 00             	nop    DWORD PTR [rax]
  4112d8:	eb 0d                	jmp    4112e7 <cos_thd_wakeup+0x57>
  4112da:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4112e0:	b9 00 00 00 00       	mov    ecx,0x0
  4112e5:	eb 05                	jmp    4112ec <cos_thd_wakeup+0x5c>
  4112e7:	b9 01 00 00 00       	mov    ecx,0x1
  4112ec:	5d                   	pop    rbp
--
  411346:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
#if defined(__x86_64__)
	return call_cap_op(c, tc, stok, prio, rcv, timeout);
  41134a:	44 89 cb             	mov    ebx,r9d
  41134d:	48 89 29             	mov    QWORD PTR [rcx],rbp
--
  411357:	49 b8 70 13 41 00 00 	movabs r8,0x411370
  41135e:	00 00 00 
  411361:	0f 05                	syscall 
  411363:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  411368:	eb 0d                	jmp    411377 <cos_switch+0x57>
  41136a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411370:	b9 00 00 00 00       	mov    ecx,0x0
  411375:	eb 05                	jmp    41137c <cos_switch+0x5c>
  411377:	b9 01 00 00 00       	mov    ecx,0x1
  41137c:	5d                   	pop    rbp
  41137d:	5c                   	pop    rsp
#else
	return call_cap_op(c, (stok >> 16), tc << 16 | rcv, (prio << 32) >> 32,
	                   (((prio << 16) >> 48) << 16) | ((stok << 16) >> 16), timeout);
#endif
--
  4113a3:	41 55                	push   r13
  4113a5:	49 89 f5             	mov    r13,rsi
	return call_cap_op(snd, 0, srcv, stok, timeout, 0);
  4113a8:	89 ce                	mov    esi,ecx
{
--
  4113c1:	49 b8 d8 13 41 00 00 	movabs r8,0x4113d8
  4113c8:	00 00 00 
  4113cb:	0f 05                	syscall 
  4113cd:	0f 1f 00             	nop    DWORD PTR [rax]
  4113d0:	eb 0d                	jmp    4113df <cos_sched_asnd+0x4f>
  4113d2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4113d8:	b9 00 00 00 00       	mov    ecx,0x0
  4113dd:	eb 05                	jmp    4113e4 <cos_sched_asnd+0x54>
  4113df:	b9 01 00 00 00       	mov    ecx,0x1
  4113e4:	5d                   	pop    rbp
--
  41141a:	49 b8 30 14 41 00 00 	movabs r8,0x411430
  411421:	00 00 00 
  411424:	0f 05                	syscall 
  411426:	66 90                	xchg   ax,ax
  411428:	eb 0d                	jmp    411437 <cos_asnd+0x47>
  41142a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411430:	b9 00 00 00 00       	mov    ecx,0x0
  411435:	eb 05                	jmp    41143c <cos_asnd+0x4c>
  411437:	b9 01 00 00 00       	mov    ecx,0x1
  41143c:	5d                   	pop    rbp
  41143d:	5c                   	pop    rsp
	return call_cap_op(snd, 0, 0, 0, 0, yield);
}
  41143e:	5b                   	pop    rbx
--
  41148b:	49 b8 a0 14 41 00 00 	movabs r8,0x4114a0
  411492:	00 00 00 
  411495:	0f 05                	syscall 
  411497:	90                   	nop
  411498:	eb 0f                	jmp    4114a9 <cos_sched_rcv+0x59>
  41149a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4114a0:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  4114a7:	eb 07                	jmp    4114b0 <cos_sched_rcv+0x60>
  4114a9:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  4114b0:	5d                   	pop    rbp
--
	int           ret;

	ret = call_cap_retvals_asm(rcv, 0, flags, timeout, 0, 0, &thd_state, &cyc, thd_timeout);

	*blocked = (int)(thd_state >> (sizeof(thd_state) * 8 - 1));
--
  4114d6:	78 10                	js     4114e8 <cos_sched_rcv+0x98>
  4114d8:	41 83 e2 02          	and    r10d,0x2
  4114dc:	74 0a                	je     4114e8 <cos_sched_rcv+0x98>
		*rcvd = (ret >> 1);
  4114de:	89 c2                	mov    edx,eax
--
  411535:	49 b8 50 15 41 00 00 	movabs r8,0x411550
  41153c:	00 00 00 
  41153f:	0f 05                	syscall 
  411541:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  411548:	eb 0f                	jmp    411559 <cos_rcv+0x59>
  41154a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411550:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  411557:	eb 07                	jmp    411560 <cos_rcv+0x60>
  411559:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  411560:	5d                   	pop    rbp
--
  411567:	78 06                	js     41156f <cos_rcv+0x6f>
  411569:	41 83 e2 02          	and    r10d,0x2
  41156d:	75 11                	jne    411580 <cos_rcv+0x80>
	cycles_t    cyc;
	int         ret;
--
	assert(tid == 0);
  41156f:	48 85 f6             	test   rsi,rsi
  411572:	75 1c                	jne    411590 <cos_rcv+0x90>

	return ret;
--
	assert(tid == 0);
  41158b:	48 85 f6             	test   rsi,rsi
  41158e:	74 e4                	je     411574 <cos_rcv+0x74>
  411590:	be 2f 00 00 00       	mov    esi,0x2f
  411595:	bf 38 e7 41 00       	mov    edi,0x41e738
  41159a:	e8 31 8b ff ff       	call   40a0d0 <cos_print_str>
  41159f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4115a6:	00 00 00 00 
--
	assert(srcci && dstci);
  4115cd:	48 85 f6             	test   rsi,rsi
  4115d0:	0f 84 f3 00 00 00    	je     4116c9 <cos_mem_aliasn_aligned+0x119>
  4115d6:	49 89 fd             	mov    r13,rdi
  4115d9:	48 85 ff             	test   rdi,rdi
  4115dc:	0f 84 e7 00 00 00    	je     4116c9 <cos_mem_aliasn_aligned+0x119>
	assert(sz && (sz % PAGE_SIZE == 0));
  4115e2:	48 85 c9             	test   rcx,rcx
  4115e5:	0f 84 c2 00 00 00    	je     4116ad <cos_mem_aliasn_aligned+0xfd>
  4115eb:	f7 c1 ff 0f 00 00    	test   ecx,0xfff
  4115f1:	0f 85 b6 00 00 00    	jne    4116ad <cos_mem_aliasn_aligned+0xfd>
  4115f7:	4c 89 c2             	mov    rdx,r8
	assert(align % PAGE_SIZE == 0);
  4115fa:	41 f7 c0 ff 0f 00 00 	test   r8d,0xfff
  411601:	0f 85 de 00 00 00    	jne    4116e5 <cos_mem_aliasn_aligned+0x135>
  411607:	49 89 f6             	mov    r14,rsi
  41160a:	48 89 ce             	mov    rsi,rcx
--

	dst = __page_bump_valloc(dstci, sz, align);
  411610:	e8 0b b9 ff ff       	call   40cf20 <__page_bump_valloc>
  411615:	49 89 c7             	mov    r15,rax
	if (unlikely(!dst)) return 0;
  411618:	48 85 c0             	test   rax,rax
  41161b:	0f 84 87 00 00 00    	je     4116a8 <cos_mem_aliasn_aligned+0xf8>
	first_dst = dst;

--
  411656:	49 b8 70 16 41 00 00 	movabs r8,0x411670
  41165d:	00 00 00 
  411660:	0f 05                	syscall 
  411662:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411668:	eb 0d                	jmp    411677 <cos_mem_aliasn_aligned+0xc7>
  41166a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411670:	b9 00 00 00 00       	mov    ecx,0x0
  411675:	eb 05                	jmp    41167c <cos_mem_aliasn_aligned+0xcc>
  411677:	b9 01 00 00 00       	mov    ecx,0x1
  41167c:	5d                   	pop    rbp
  41167d:	5c                   	pop    rsp
		if (call_cap_op(srcci->pgtbl_cap, CAPTBL_OP_CPY, src, dstci->pgtbl_cap, dst, perm_flags)) return 0;
  41167e:	85 c0                	test   eax,eax
  411680:	75 26                	jne    4116a8 <cos_mem_aliasn_aligned+0xf8>
	for (i = 0; i < sz; i += PAGE_SIZE, src += PAGE_SIZE, dst += PAGE_SIZE) {
  411682:	49 81 c2 00 10 00 00 	add    r10,0x1000
  411689:	4c 39 55 b8          	cmp    QWORD PTR [rbp-0x48],r10
  41168d:	77 a1                	ja     411630 <cos_mem_aliasn_aligned+0x80>
	}
--
	if (unlikely(!dst)) return 0;
  4116a8:	45 31 ff             	xor    r15d,r15d
  4116ab:	eb e2                	jmp    41168f <cos_mem_aliasn_aligned+0xdf>
  4116ad:	be 2f 00 00 00       	mov    esi,0x2f
  4116b2:	bf 98 e7 41 00       	mov    edi,0x41e798
  4116b7:	e8 14 8a ff ff       	call   40a0d0 <cos_print_str>
	assert(sz && (sz % PAGE_SIZE == 0));
  4116bc:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  4116c9:	be 2f 00 00 00       	mov    esi,0x2f
  4116ce:	bf 68 e7 41 00       	mov    edi,0x41e768
  4116d3:	e8 f8 89 ff ff       	call   40a0d0 <cos_print_str>
	assert(srcci && dstci);
  4116d8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  4116e5:	be 2f 00 00 00       	mov    esi,0x2f
  4116ea:	bf c8 e7 41 00       	mov    edi,0x41e7c8
  4116ef:	e8 dc 89 ff ff       	call   40a0d0 <cos_print_str>
	assert(align % PAGE_SIZE == 0);
  4116f4:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  411714:	4d 89 c1             	mov    r9,r8
  411717:	41 b8 00 10 00 00    	mov    r8d,0x1000
  41171d:	e9 8e fe ff ff       	jmp    4115b0 <cos_mem_aliasn_aligned>
  411722:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  411729:	00 00 00 00 
--
  411737:	41 b8 00 10 00 00    	mov    r8d,0x1000
  41173d:	b9 00 10 00 00       	mov    ecx,0x1000
  411742:	e9 69 fe ff ff       	jmp    4115b0 <cos_mem_aliasn_aligned>
  411747:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41174e:	00 00 
--
	assert(srcci && dstci);
  411762:	48 85 d2             	test   rdx,rdx
  411765:	74 7d                	je     4117e4 <cos_mem_alias_at+0x94>
  411767:	49 89 f9             	mov    r9,rdi
  41176a:	48 85 ff             	test   rdi,rdi
  41176d:	74 75                	je     4117e4 <cos_mem_alias_at+0x94>

	if (call_cap_op(srcci->pgtbl_cap, CAPTBL_OP_CPY, src, dstci->pgtbl_cap, dst, perm_flags)) BUG();
  41176f:	48 8b 00             	mov    rax,QWORD PTR [rax]
  411772:	48 89 f7             	mov    rdi,rsi
--
  411792:	49 b8 a8 17 41 00 00 	movabs r8,0x4117a8
  411799:	00 00 00 
  41179c:	0f 05                	syscall 
  41179e:	66 90                	xchg   ax,ax
  4117a0:	eb 0d                	jmp    4117af <cos_mem_alias_at+0x5f>
  4117a2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4117a8:	b9 00 00 00 00       	mov    ecx,0x0
  4117ad:	eb 05                	jmp    4117b4 <cos_mem_alias_at+0x64>
  4117af:	b9 01 00 00 00       	mov    ecx,0x1
  4117b4:	5d                   	pop    rbp
  4117b5:	5c                   	pop    rsp
  4117b6:	85 c0                	test   eax,eax
  4117b8:	75 0e                	jne    4117c8 <cos_mem_alias_at+0x78>

	return 0;
--
  4117c8:	be 1c 00 00 00       	mov    esi,0x1c
  4117cd:	bf 28 e8 41 00       	mov    edi,0x41e828
  4117d2:	e8 f9 88 ff ff       	call   40a0d0 <cos_print_str>
	if (call_cap_op(srcci->pgtbl_cap, CAPTBL_OP_CPY, src, dstci->pgtbl_cap, dst, perm_flags)) BUG();
  4117d7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4117de:	00 00 00 00 
--
  4117e4:	be 2f 00 00 00       	mov    esi,0x2f
  4117e9:	bf f8 e7 41 00       	mov    edi,0x41e7f8
  4117ee:	e8 dd 88 ff ff       	call   40a0d0 <cos_print_str>
	assert(srcci && dstci);
  4117f3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	assert(srcci && dstci);
  411818:	48 85 d2             	test   rdx,rdx
  41181b:	0f 84 c0 00 00 00    	je     4118e1 <cos_mem_alias_atn+0xe1>
  411821:	49 89 ff             	mov    r15,rdi
  411824:	48 85 ff             	test   rdi,rdi
  411827:	0f 84 b4 00 00 00    	je     4118e1 <cos_mem_alias_atn+0xe1>
	assert(sz % PAGE_SIZE == 0);
  41182d:	41 f7 c0 ff 0f 00 00 	test   r8d,0xfff
  411834:	0f 85 c3 00 00 00    	jne    4118fd <cos_mem_alias_atn+0xfd>

	npages = sz / PAGE_SIZE;
	for (i=0; i < npages; i++) {
  41183a:	49 c1 e8 0c          	shr    r8,0xc
  41183e:	0f 84 8c 00 00 00    	je     4118d0 <cos_mem_alias_atn+0xd0>
  411844:	49 89 f5             	mov    r13,rsi
  411847:	49 c1 e0 0c          	shl    r8,0xc
--
  411851:	4d 8d 14 08          	lea    r10,[r8+rcx*1]
  411855:	49 29 cd             	sub    r13,rcx
  411858:	eb 12                	jmp    41186c <cos_mem_alias_atn+0x6c>
  41185a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411860:	48 81 c3 00 10 00 00 	add    rbx,0x1000
  411867:	49 39 da             	cmp    r10,rbx
  41186a:	74 64                	je     4118d0 <cos_mem_alias_atn+0xd0>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  41186c:	41 8b 06             	mov    eax,DWORD PTR [r14]
--
  41188b:	49 b8 a0 18 41 00 00 	movabs r8,0x4118a0
  411892:	00 00 00 
  411895:	0f 05                	syscall 
  411897:	90                   	nop
  411898:	eb 0d                	jmp    4118a7 <cos_mem_alias_atn+0xa7>
  41189a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4118a0:	b9 00 00 00 00       	mov    ecx,0x0
  4118a5:	eb 05                	jmp    4118ac <cos_mem_alias_atn+0xac>
  4118a7:	b9 01 00 00 00       	mov    ecx,0x1
  4118ac:	5d                   	pop    rbp
  4118ad:	5c                   	pop    rsp
		if (call_cap_op(srcci->pgtbl_cap, CAPTBL_OP_CPY, src + i * PAGE_SIZE, dstci->pgtbl_cap, dst + i * PAGE_SIZE, perm_flags)) BUG();
  4118ae:	85 c0                	test   eax,eax
  4118b0:	74 ae                	je     411860 <cos_mem_alias_atn+0x60>
  4118b2:	be 1c 00 00 00       	mov    esi,0x1c
  4118b7:	bf a8 e8 41 00       	mov    edi,0x41e8a8
  4118bc:	e8 0f 88 ff ff       	call   40a0d0 <cos_print_str>
  4118c1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4118c8:	00 00 00 00 
--
  4118e1:	be 2f 00 00 00       	mov    esi,0x2f
  4118e6:	bf 48 e8 41 00       	mov    edi,0x41e848
  4118eb:	e8 e0 87 ff ff       	call   40a0d0 <cos_print_str>
	assert(srcci && dstci);
  4118f0:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  4118fd:	be 2f 00 00 00       	mov    esi,0x2f
  411902:	bf 78 e8 41 00       	mov    edi,0x41e878
  411907:	e8 c4 87 ff ff       	call   40a0d0 <cos_print_str>
	assert(sz % PAGE_SIZE == 0);
  41190c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  41192a:	bf c8 e8 41 00       	mov    edi,0x41e8c8
  41192f:	48 89 e5             	mov    rbp,rsp
  411932:	e8 99 87 ff ff       	call   40a0d0 <cos_print_str>
	assert(0);
  411937:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	assert(srcci && dstci);
  411961:	48 85 f6             	test   rsi,rsi
  411964:	0f 84 a2 00 00 00    	je     411a0c <cos_mem_move+0xbc>
  41196a:	49 89 fc             	mov    r12,rdi
  41196d:	48 85 ff             	test   rdi,rdi
  411970:	0f 84 96 00 00 00    	je     411a0c <cos_mem_move+0xbc>
  411976:	49 89 f5             	mov    r13,rsi
  411979:	48 89 d3             	mov    rbx,rdx
--
  41197c:	be 00 10 00 00       	mov    esi,0x1000
  411981:	ba 00 10 00 00       	mov    edx,0x1000
  411986:	e8 95 b5 ff ff       	call   40cf20 <__page_bump_valloc>
  41198b:	49 89 c2             	mov    r10,rax
	if (unlikely(!dst)) return 0;
  41198e:	48 85 c0             	test   rax,rax
  411991:	74 4f                	je     4119e2 <cos_mem_move+0x92>

	if (call_cap_op(srcci->pgtbl_cap, CAPTBL_OP_MEMMOVE, src, dstci->pgtbl_cap, dst, 0)) BUG();
  411993:	49 8b 45 00          	mov    rax,QWORD PTR [r13+0x0]
  411997:	49 8b 34 24          	mov    rsi,QWORD PTR [r12]
--
  4119b6:	49 b8 d0 19 41 00 00 	movabs r8,0x4119d0
  4119bd:	00 00 00 
  4119c0:	0f 05                	syscall 
  4119c2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4119c8:	eb 0d                	jmp    4119d7 <cos_mem_move+0x87>
  4119ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4119d0:	b9 00 00 00 00       	mov    ecx,0x0
  4119d5:	eb 05                	jmp    4119dc <cos_mem_move+0x8c>
  4119d7:	b9 01 00 00 00       	mov    ecx,0x1
  4119dc:	5d                   	pop    rbp
  4119dd:	5c                   	pop    rsp
  4119de:	85 c0                	test   eax,eax
  4119e0:	75 0e                	jne    4119f0 <cos_mem_move+0xa0>

	return dst;
--
  4119f0:	be 1c 00 00 00       	mov    esi,0x1c
  4119f5:	bf 28 e9 41 00       	mov    edi,0x41e928
  4119fa:	e8 d1 86 ff ff       	call   40a0d0 <cos_print_str>
	if (call_cap_op(srcci->pgtbl_cap, CAPTBL_OP_MEMMOVE, src, dstci->pgtbl_cap, dst, 0)) BUG();
  4119ff:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411a06:	00 00 00 00 
--
  411a0c:	be 2f 00 00 00       	mov    esi,0x2f
  411a11:	bf f8 e8 41 00       	mov    edi,0x41e8f8
  411a16:	e8 b5 86 ff ff       	call   40a0d0 <cos_print_str>
	assert(srcci && dstci);
  411a1b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	assert(srcci && dstci);
  411a3f:	48 85 d2             	test   rdx,rdx
  411a42:	0f 84 7c 00 00 00    	je     411ac4 <cos_mem_move_at+0x94>
  411a48:	49 89 f8             	mov    r8,rdi
  411a4b:	48 85 ff             	test   rdi,rdi
  411a4e:	74 74                	je     411ac4 <cos_mem_move_at+0x94>

	/* TODO */
	if (call_cap_op(srcci->pgtbl_cap, CAPTBL_OP_MEMMOVE, src, dstci->pgtbl_cap, dst, 0)) BUG();
  411a50:	48 8b 02             	mov    rax,QWORD PTR [rdx]
  411a53:	48 89 f7             	mov    rdi,rsi
--
  411a74:	49 b8 88 1a 41 00 00 	movabs r8,0x411a88
  411a7b:	00 00 00 
  411a7e:	0f 05                	syscall 
  411a80:	eb 0d                	jmp    411a8f <cos_mem_move_at+0x5f>
  411a82:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411a88:	b9 00 00 00 00       	mov    ecx,0x0
  411a8d:	eb 05                	jmp    411a94 <cos_mem_move_at+0x64>
  411a8f:	b9 01 00 00 00       	mov    ecx,0x1
  411a94:	5d                   	pop    rbp
  411a95:	5c                   	pop    rsp
  411a96:	85 c0                	test   eax,eax
  411a98:	75 0e                	jne    411aa8 <cos_mem_move_at+0x78>

	return 0;
--
  411aa8:	be 1c 00 00 00       	mov    esi,0x1c
  411aad:	bf 78 e9 41 00       	mov    edi,0x41e978
  411ab2:	e8 19 86 ff ff       	call   40a0d0 <cos_print_str>
	if (call_cap_op(srcci->pgtbl_cap, CAPTBL_OP_MEMMOVE, src, dstci->pgtbl_cap, dst, 0)) BUG();
  411ab7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411abe:	00 00 00 00 
--
  411ac4:	be 2f 00 00 00       	mov    esi,0x2f
  411ac9:	bf 48 e9 41 00       	mov    edi,0x41e948
  411ace:	e8 fd 85 ff ff       	call   40a0d0 <cos_print_str>
	assert(srcci && dstci);
  411ad3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  411af3:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  411af7:	4c 89 d3             	mov    rbx,r10
	return call_cap_op(ci->captbl_cap, CAPTBL_OP_THDTLSSET, tc, (word_t)tlsaddr, 0, 0);
  411afa:	48 8b 47 08          	mov    rax,QWORD PTR [rdi+0x8]
  411afe:	48 89 d7             	mov    rdi,rdx
--
  411b13:	49 b8 28 1b 41 00 00 	movabs r8,0x411b28
  411b1a:	00 00 00 
  411b1d:	0f 05                	syscall 
  411b1f:	90                   	nop
  411b20:	eb 0d                	jmp    411b2f <cos_thd_mod+0x4f>
  411b22:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411b28:	b9 00 00 00 00       	mov    ecx,0x0
  411b2d:	eb 05                	jmp    411b34 <cos_thd_mod+0x54>
  411b2f:	b9 01 00 00 00       	mov    ecx,0x1
  411b34:	5d                   	pop    rbp
--
  411b44:	55                   	push   rbp
  411b45:	49 89 f2             	mov    r10,rsi
	return call_cap_op(ci->captbl_cap, CAPTBL_OP_INTROSPECT, cap, (int)op, 0, 0);
  411b48:	48 63 f2             	movsxd rsi,edx
  411b4b:	31 d2                	xor    edx,edx
--
  411b53:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  411b57:	4c 89 d3             	mov    rbx,r10
	return call_cap_op(ci->captbl_cap, CAPTBL_OP_INTROSPECT, cap, (int)op, 0, 0);
  411b5a:	48 8b 47 08          	mov    rax,QWORD PTR [rdi+0x8]
  411b5e:	48 89 d7             	mov    rdi,rdx
--
  411b73:	49 b8 88 1b 41 00 00 	movabs r8,0x411b88
  411b7a:	00 00 00 
  411b7d:	0f 05                	syscall 
  411b7f:	90                   	nop
  411b80:	eb 0d                	jmp    411b8f <cos_introspect+0x4f>
  411b82:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411b88:	b9 00 00 00 00       	mov    ecx,0x0
  411b8d:	eb 05                	jmp    411b94 <cos_introspect+0x54>
  411b8f:	b9 01 00 00 00       	mov    ecx,0x1
  411b94:	5d                   	pop    rbp
--
	assert(ci);
  411bb3:	48 85 ff             	test   rdi,rdi
  411bb6:	0f 84 30 01 00 00    	je     411cec <cos_tcap_alloc+0x14c>
  411bbc:	49 89 fc             	mov    r12,rdi
	return __mem_bump_alloc(ci, 1, 1);
  411bbf:	e8 9c ac ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  411bc4:	49 89 c5             	mov    r13,rax
	if (!*kmem) return -1;
  411bc7:	48 85 c0             	test   rax,rax
  411bca:	0f 84 38 01 00 00    	je     411d08 <cos_tcap_alloc+0x168>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  411bd0:	49 8d 94 24 b0 00 00 	lea    rdx,[r12+0xb0]
--
  411bde:	31 c9                	xor    ecx,ecx
  411be0:	48 89 c8             	mov    rax,rcx
  411be3:	f0 4c 0f b1 02       	lock cmpxchg QWORD PTR [rdx],r8
  411be8:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  411beb:	84 c0                	test   al,al
  411bed:	74 f1                	je     411be0 <cos_tcap_alloc+0x40>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  411bef:	4d 8b 74 24 28       	mov    r14,QWORD PTR [r12+0x28]
  411bf4:	41 83 e6 03          	and    r14d,0x3
  411bf8:	0f 84 9a 00 00 00    	je     411c98 <cos_tcap_alloc+0xf8>
        __asm__ __volatile__("lock " PS_FAA_STR
  411bfe:	ba 01 00 00 00       	mov    edx,0x1
--
	if (!*cap) return -1;
  411c19:	48 85 d2             	test   rdx,rdx
  411c1c:	0f 84 e6 00 00 00    	je     411d08 <cos_tcap_alloc+0x168>

	if (__alloc_mem_cap(ci, CAP_TCAP, &kmem, &cap)) return 0;
	/* TODO: Add cap size checking */
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_TCAP_ACTIVATE, (cap << 16) | __compinfo_metacap(ci)->mi.pgtbl_cap,
  411c22:	49 8b 4c 24 60       	mov    rcx,QWORD PTR [r12+0x60]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
--
  411c58:	49 b8 70 1c 41 00 00 	movabs r8,0x411c70
  411c5f:	00 00 00 
  411c62:	0f 05                	syscall 
  411c64:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  411c68:	eb 0d                	jmp    411c77 <cos_tcap_alloc+0xd7>
  411c6a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411c70:	b9 00 00 00 00       	mov    ecx,0x0
  411c75:	eb 05                	jmp    411c7c <cos_tcap_alloc+0xdc>
  411c77:	b9 01 00 00 00       	mov    ecx,0x1
  411c7c:	5d                   	pop    rbp
  411c7d:	5c                   	pop    rsp
  411c7e:	85 c0                	test   eax,eax
  411c80:	75 4e                	jne    411cd0 <cos_tcap_alloc+0x130>
	                kmem, 0, 0))
		BUG();
--
		if (__capid_captbl_check_expand(ci)) goto error;
  411c98:	4c 89 e7             	mov    rdi,r12
  411c9b:	e8 40 ad ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  411ca0:	85 c0                	test   eax,eax
  411ca2:	75 16                	jne    411cba <cos_tcap_alloc+0x11a>
        __asm__ __volatile__("lock " PS_FAA_STR
  411ca4:	b8 04 00 00 00       	mov    eax,0x4
--
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  411cb0:	49 89 44 24 28       	mov    QWORD PTR [r12+0x28],rax
  411cb5:	e9 44 ff ff ff       	jmp    411bfe <cos_tcap_alloc+0x5e>
{ l->o = 0; }
  411cba:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  411cc1:	00 00 00 00 00 
	if (!*cap) return -1;
  411cc6:	eb ba                	jmp    411c82 <cos_tcap_alloc+0xe2>
  411cc8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  411ccf:	00 
  411cd0:	be 1c 00 00 00       	mov    esi,0x1c
  411cd5:	bf c8 e9 41 00       	mov    edi,0x41e9c8
  411cda:	e8 f1 83 ff ff       	call   40a0d0 <cos_print_str>
		BUG();
  411cdf:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  411cec:	be 2f 00 00 00       	mov    esi,0x2f
  411cf1:	bf 98 e9 41 00       	mov    edi,0x41e998
  411cf6:	e8 d5 83 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci);
  411cfb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	if (__alloc_mem_cap(ci, CAP_TCAP, &kmem, &cap)) return 0;
  411d08:	45 31 f6             	xor    r14d,r14d
  411d0b:	e9 72 ff ff ff       	jmp    411c82 <cos_tcap_alloc+0xe2>

0000000000411d10 <cos_tcap_transfer>:
--
	int prio_lower  = (u32_t)((prio << 32) >> 32);

	return call_cap_op(src, CAPTBL_OP_TCAP_TRANSFER, dst, res, prio_higher, prio_lower);
  411d1b:	48 89 cf             	mov    rdi,rcx
	cap_no += op;
--
  411d2b:	41 55                	push   r13
  411d2d:	49 89 d5             	mov    r13,rdx
	return call_cap_op(src, CAPTBL_OP_TCAP_TRANSFER, dst, res, prio_higher, prio_lower);
  411d30:	48 63 d1             	movsxd rdx,ecx
{
--
  411d4a:	49 b8 60 1d 41 00 00 	movabs r8,0x411d60
  411d51:	00 00 00 
  411d54:	0f 05                	syscall 
  411d56:	66 90                	xchg   ax,ax
  411d58:	eb 0d                	jmp    411d67 <cos_tcap_transfer+0x57>
  411d5a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411d60:	b9 00 00 00 00       	mov    ecx,0x0
  411d65:	eb 05                	jmp    411d6c <cos_tcap_transfer+0x5c>
  411d67:	b9 01 00 00 00       	mov    ecx,0x1
  411d6c:	5d                   	pop    rbp
--
	int prio_lower  = (u32_t)((prio << 32) >> 32);

	return call_cap_op(src, CAPTBL_OP_TCAP_DELEGATE, dst, res, prio_higher, prio_lower);
  411db3:	48 63 d1             	movsxd rdx,ecx
  411db6:	48 63 ff             	movsxd rdi,edi
--
  411dc7:	49 b8 e0 1d 41 00 00 	movabs r8,0x411de0
  411dce:	00 00 00 
  411dd1:	0f 05                	syscall 
  411dd3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  411dd8:	eb 0d                	jmp    411de7 <cos_tcap_delegate+0x67>
  411dda:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411de0:	b9 00 00 00 00       	mov    ecx,0x0
  411de5:	eb 05                	jmp    411dec <cos_tcap_delegate+0x6c>
  411de7:	b9 01 00 00 00       	mov    ecx,0x1
  411dec:	5d                   	pop    rbp
--
  411e2d:	49 b8 48 1e 41 00 00 	movabs r8,0x411e48
  411e34:	00 00 00 
  411e37:	0f 05                	syscall 
  411e39:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  411e40:	eb 0d                	jmp    411e4f <cos_tcap_merge+0x4f>
  411e42:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411e48:	b9 00 00 00 00       	mov    ecx,0x0
  411e4d:	eb 05                	jmp    411e54 <cos_tcap_merge+0x54>
  411e4f:	b9 01 00 00 00       	mov    ecx,0x1
  411e54:	5d                   	pop    rbp
  411e55:	5c                   	pop    rsp
	return call_cap_op(dst, CAPTBL_OP_TCAP_MERGE, rm, 0, 0, 0);
}
  411e56:	5b                   	pop    rbx
--
  411e7b:	53                   	push   rbx
  411e7c:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
	return call_cap_op(hwc, CAPTBL_OP_HW_ATTACH, hwid, arcv, 0, 0);
  411e80:	89 f3                	mov    ebx,esi
  411e82:	4c 89 d6             	mov    rsi,r10
--
  411e8f:	49 b8 a8 1e 41 00 00 	movabs r8,0x411ea8
  411e96:	00 00 00 
  411e99:	0f 05                	syscall 
  411e9b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  411ea0:	eb 0d                	jmp    411eaf <cos_hw_attach+0x4f>
  411ea2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411ea8:	b9 00 00 00 00       	mov    ecx,0x0
  411ead:	eb 05                	jmp    411eb4 <cos_hw_attach+0x54>
  411eaf:	b9 01 00 00 00       	mov    ecx,0x1
  411eb4:	5d                   	pop    rbp
--
  411ed8:	53                   	push   rbx
  411ed9:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
	return call_cap_op(hwc, CAPTBL_OP_HW_DETACH, hwid, 0, 0, 0);
  411edd:	89 f3                	mov    ebx,esi
  411edf:	48 89 d6             	mov    rsi,rdx
--
  411eec:	49 b8 00 1f 41 00 00 	movabs r8,0x411f00
  411ef3:	00 00 00 
  411ef6:	0f 05                	syscall 
  411ef8:	eb 0d                	jmp    411f07 <cos_hw_detach+0x47>
  411efa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411f00:	b9 00 00 00 00       	mov    ecx,0x0
  411f05:	eb 05                	jmp    411f0c <cos_hw_detach+0x4c>
  411f07:	b9 01 00 00 00       	mov    ecx,0x1
  411f0c:	5d                   	pop    rbp
--
	static int cycs = 0;

	while (cycs <= 0) cycs = call_cap_op(hwc, CAPTBL_OP_HW_CYC_USEC, 0, 0, 0, 0);
  411f24:	8b 05 76 eb 18 00    	mov    eax,DWORD PTR [rip+0x18eb76]        # 5a0aa0 <cycs.0>
  411f2a:	85 c0                	test   eax,eax
  411f2c:	7f 72                	jg     411fa0 <cos_hw_cycles_per_usec+0x80>
{
  411f2e:	55                   	push   rbp
--
  411f69:	49 b8 80 1f 41 00 00 	movabs r8,0x411f80
  411f70:	00 00 00 
  411f73:	0f 05                	syscall 
  411f75:	0f 1f 00             	nop    DWORD PTR [rax]
  411f78:	eb 0d                	jmp    411f87 <cos_hw_cycles_per_usec+0x67>
  411f7a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411f80:	b9 00 00 00 00       	mov    ecx,0x0
  411f85:	eb 05                	jmp    411f8c <cos_hw_cycles_per_usec+0x6c>
  411f87:	b9 01 00 00 00       	mov    ecx,0x1
  411f8c:	5d                   	pop    rbp
  411f8d:	5c                   	pop    rsp
	while (cycs <= 0) cycs = call_cap_op(hwc, CAPTBL_OP_HW_CYC_USEC, 0, 0, 0, 0);
  411f8e:	89 05 0c eb 18 00    	mov    DWORD PTR [rip+0x18eb0c],eax        # 5a0aa0 <cycs.0>
  411f94:	85 c0                	test   eax,eax
--
  411fe5:	49 b8 00 20 41 00 00 	movabs r8,0x412000
  411fec:	00 00 00 
  411fef:	0f 05                	syscall 
  411ff1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  411ff8:	eb 0d                	jmp    412007 <cos_hw_tlb_lockdown+0x57>
  411ffa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  412000:	b9 00 00 00 00       	mov    ecx,0x0
  412005:	eb 05                	jmp    41200c <cos_hw_tlb_lockdown+0x5c>
  412007:	b9 01 00 00 00       	mov    ecx,0x1
  41200c:	5d                   	pop    rbp
  41200d:	5c                   	pop    rsp
	return call_cap_op(hwc, CAPTBL_OP_HW_TLB_LOCKDOWN, entryid, vaddr, paddr, 0);
}
  41200e:	5b                   	pop    rbx
--
  41204d:	49 b8 68 20 41 00 00 	movabs r8,0x412068
  412054:	00 00 00 
  412057:	0f 05                	syscall 
  412059:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  412060:	eb 0d                	jmp    41206f <cos_hw_l1flush+0x4f>
  412062:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  412068:	b9 00 00 00 00       	mov    ecx,0x0
  41206d:	eb 05                	jmp    412074 <cos_hw_l1flush+0x54>
  41206f:	b9 01 00 00 00       	mov    ecx,0x1
  412074:	5d                   	pop    rbp
  412075:	5c                   	pop    rsp
	return call_cap_op(hwc, CAPTBL_OP_HW_L1FLUSH, 0, 0, 0, 0);
}
  412076:	5b                   	pop    rbx
--
  4120ad:	49 b8 c8 20 41 00 00 	movabs r8,0x4120c8
  4120b4:	00 00 00 
  4120b7:	0f 05                	syscall 
  4120b9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  4120c0:	eb 0d                	jmp    4120cf <cos_hw_tlbflush+0x4f>
  4120c2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4120c8:	b9 00 00 00 00       	mov    ecx,0x0
  4120cd:	eb 05                	jmp    4120d4 <cos_hw_tlbflush+0x54>
  4120cf:	b9 01 00 00 00       	mov    ecx,0x1
  4120d4:	5d                   	pop    rbp
  4120d5:	5c                   	pop    rsp
	return call_cap_op(hwc, CAPTBL_OP_HW_TLBFLUSH, 0, 0, 0, 0);
}
  4120d6:	5b                   	pop    rbx
--
  41210d:	49 b8 28 21 41 00 00 	movabs r8,0x412128
  412114:	00 00 00 
  412117:	0f 05                	syscall 
  412119:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  412120:	eb 0d                	jmp    41212f <cos_hw_tlbstall+0x4f>
  412122:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  412128:	b9 00 00 00 00       	mov    ecx,0x0
  41212d:	eb 05                	jmp    412134 <cos_hw_tlbstall+0x54>
  41212f:	b9 01 00 00 00       	mov    ecx,0x1
  412134:	5d                   	pop    rbp
  412135:	5c                   	pop    rsp
	return call_cap_op(hwc, CAPTBL_OP_HW_TLBSTALL, 0, 0, 0, 0);
}
  412136:	5b                   	pop    rbx
--
  41216d:	49 b8 88 21 41 00 00 	movabs r8,0x412188
  412174:	00 00 00 
  412177:	0f 05                	syscall 
  412179:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  412180:	eb 0d                	jmp    41218f <cos_hw_tlbstall_recount+0x4f>
  412182:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  412188:	b9 00 00 00 00       	mov    ecx,0x0
  41218d:	eb 05                	jmp    412194 <cos_hw_tlbstall_recount+0x54>
  41218f:	b9 01 00 00 00       	mov    ecx,0x1
  412194:	5d                   	pop    rbp
  412195:	5c                   	pop    rsp
	return call_cap_op(hwc, CAPTBL_OP_HW_TLBSTALL_RECOUNT, 0, 0, 0, 0);
}
  412196:	5b                   	pop    rbx
--
  4121cd:	49 b8 e8 21 41 00 00 	movabs r8,0x4121e8
  4121d4:	00 00 00 
  4121d7:	0f 05                	syscall 
  4121d9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  4121e0:	eb 0d                	jmp    4121ef <cos_hw_cycles_thresh+0x4f>
  4121e2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4121e8:	b9 00 00 00 00       	mov    ecx,0x0
  4121ed:	eb 05                	jmp    4121f4 <cos_hw_cycles_thresh+0x54>
  4121ef:	b9 01 00 00 00       	mov    ecx,0x1
  4121f4:	5d                   	pop    rbp
  4121f5:	5c                   	pop    rsp
	return call_cap_op(hwc, CAPTBL_OP_HW_CYC_THRESH, 0, 0, 0, 0);
}
  4121f6:	5b                   	pop    rbx
--
  41222d:	49 b8 48 22 41 00 00 	movabs r8,0x412248
  412234:	00 00 00 
  412237:	0f 05                	syscall 
  412239:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  412240:	eb 0d                	jmp    41224f <cos_hw_shutdown+0x4f>
  412242:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  412248:	b9 00 00 00 00       	mov    ecx,0x0
  41224d:	eb 05                	jmp    412254 <cos_hw_shutdown+0x54>
  41224f:	b9 01 00 00 00       	mov    ecx,0x1
  412254:	5d                   	pop    rbp
  412255:	5c                   	pop    rsp
	call_cap_op(hwc, CAPTBL_OP_HW_SHUTDOWN, 0, 0, 0, 0);
}
  412256:	5b                   	pop    rbx
--
	assert(ci && hwc && pa && len);
  412275:	48 85 ff             	test   rdi,rdi
  412278:	0f 84 f4 00 00 00    	je     412372 <cos_hw_map+0x112>
  41227e:	48 89 f3             	mov    rbx,rsi
  412281:	48 85 f6             	test   rsi,rsi
  412284:	0f 84 e8 00 00 00    	je     412372 <cos_hw_map+0x112>
  41228a:	49 89 d7             	mov    r15,rdx
  41228d:	48 85 d2             	test   rdx,rdx
  412290:	0f 84 dc 00 00 00    	je     412372 <cos_hw_map+0x112>
  412296:	85 c9                	test   ecx,ecx
  412298:	0f 84 d4 00 00 00    	je     412372 <cos_hw_map+0x112>

	sz = round_up_to_page(len);
--
  4122b9:	48 89 4d b8          	mov    QWORD PTR [rbp-0x48],rcx
	va = __page_bump_valloc(ci, sz, PAGE_SIZE);
  4122bd:	e8 5e ac ff ff       	call   40cf20 <__page_bump_valloc>
  4122c2:	49 89 c5             	mov    r13,rax
	if (unlikely(!va)) return NULL;
  4122c5:	48 85 c0             	test   rax,rax
  4122c8:	0f 84 c0 00 00 00    	je     41238e <cos_hw_map+0x12e>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4122ce:	c1 e3 10             	shl    ebx,0x10
--
  4122d6:	8d 83 2f 00 01 00    	lea    eax,[rbx+0x1002f]
  4122dc:	89 45 b4             	mov    DWORD PTR [rbp-0x4c],eax
  4122df:	eb 14                	jmp    4122f5 <cos_hw_map+0x95>
  4122e1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  4122e8:	49 81 c2 00 10 00 00 	add    r10,0x1000
  4122ef:	4c 39 55 b8          	cmp    QWORD PTR [rbp-0x48],r10
  4122f3:	76 6b                	jbe    412360 <cos_hw_map+0x100>
	__asm__ __volatile__(
--
  412311:	49 b8 28 23 41 00 00 	movabs r8,0x412328
  412318:	00 00 00 
  41231b:	0f 05                	syscall 
  41231d:	0f 1f 00             	nop    DWORD PTR [rax]
  412320:	eb 0d                	jmp    41232f <cos_hw_map+0xcf>
  412322:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  412328:	b9 00 00 00 00       	mov    ecx,0x0
  41232d:	eb 05                	jmp    412334 <cos_hw_map+0xd4>
  41232f:	b9 01 00 00 00       	mov    ecx,0x1
  412334:	5d                   	pop    rbp
  412335:	5c                   	pop    rsp
		if (call_cap_op(hwc, CAPTBL_OP_HW_MAP, ci->pgtbl_cap, va + i, pa + i, 0)) BUG();
  412336:	85 c0                	test   eax,eax
  412338:	74 ae                	je     4122e8 <cos_hw_map+0x88>
  41233a:	be 1c 00 00 00       	mov    esi,0x1c
  41233f:	bf 18 ea 41 00       	mov    edi,0x41ea18
  412344:	e8 87 7d ff ff       	call   40a0d0 <cos_print_str>
  412349:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412350:	00 00 00 00 
--
  412372:	be 2f 00 00 00       	mov    esi,0x2f
  412377:	bf e8 e9 41 00       	mov    edi,0x41e9e8
  41237c:	e8 4f 7d ff ff       	call   40a0d0 <cos_print_str>
	assert(ci && hwc && pa && len);
  412381:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	if (unlikely(!va)) return NULL;
  41238e:	31 c0                	xor    eax,eax
  412390:	eb d1                	jmp    412363 <cos_hw_map+0x103>
  412392:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  412399:	00 00 00 00 
--
  4123a4:	48 8b 87 a0 00 00 00 	mov    rax,QWORD PTR [rdi+0xa0]
  4123ab:	48 85 c0             	test   rax,rax
  4123ae:	74 10                	je     4123c0 <cos_get_second_lvl+0x20>
		return -1;
	}
--
  4123df:	48 8b 9f a0 00 00 00 	mov    rbx,QWORD PTR [rdi+0xa0]
  4123e6:	48 85 db             	test   rbx,rbx
  4123e9:	0f 84 7d 00 00 00    	je     41246c <cos_cons_into_shared_pgtbl+0x9c>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4123ef:	c1 e6 10             	shl    esi,0x10
--
  412412:	49 b8 28 24 41 00 00 	movabs r8,0x412428
  412419:	00 00 00 
  41241c:	0f 05                	syscall 
  41241e:	66 90                	xchg   ax,ax
  412420:	eb 0d                	jmp    41242f <cos_cons_into_shared_pgtbl+0x5f>
  412422:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  412428:	b9 00 00 00 00       	mov    ecx,0x0
  41242d:	eb 05                	jmp    412434 <cos_cons_into_shared_pgtbl+0x64>
  41242f:	b9 01 00 00 00       	mov    ecx,0x1
  412434:	5d                   	pop    rbp
  412435:	5c                   	pop    rsp
	if (call_cap_op(top_lvl, CAPTBL_OP_CONS, pte_cap, pgtbl_addr, 0, 0)) {
		assert(0); /* race? */
		return -1;
--
	return 0;
  412436:	45 31 c0             	xor    r8d,r8d
	if (call_cap_op(top_lvl, CAPTBL_OP_CONS, pte_cap, pgtbl_addr, 0, 0)) {
  412439:	85 c0                	test   eax,eax
  41243b:	75 13                	jne    412450 <cos_cons_into_shared_pgtbl+0x80>

}
--
  412450:	be 2f 00 00 00       	mov    esi,0x2f
  412455:	bf 38 ea 41 00       	mov    edi,0x41ea38
  41245a:	e8 71 7c ff ff       	call   40a0d0 <cos_print_str>
		assert(0); /* race? */
  41245f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
		return -1;
  41246c:	41 b8 ff ff ff ff    	mov    r8d,0xffffffff
  412472:	eb c9                	jmp    41243d <cos_cons_into_shared_pgtbl+0x6d>
  412474:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41247b:	00 00 00 
--
  412499:	48 8b 38             	mov    rdi,QWORD PTR [rax]
		if (ps_list_head_empty(&prios[i])) continue;
  41249c:	48 39 f8             	cmp    rax,rdi
  41249f:	74 3f                	je     4124e0 <slm_sched_fprr_schedule+0x50>
}

--
//		printc("Schedule -> %ld\n", slm_thd_from_sched(t)->tid);
		return slm_thd_from_sched(t);
  4124d9:	e9 e2 f1 fe ff       	jmp    4016c0 <slm_thd_from_sched>
  4124de:	66 90                	xchg   ax,ax
	for (i = 0 ; i < SLM_FPRR_NPRIOS ; i++) {
  4124e0:	48 83 c0 10          	add    rax,0x10
  4124e4:	48 3d 00 0d 5a 00    	cmp    rax,0x5a0d00
  4124ea:	75 ad                	jne    412499 <slm_sched_fprr_schedule+0x9>
	}
//	printc("Schedule -> idle\n");
--
  4124f5:	48 89 e5             	mov    rbp,rsp
	struct slm_sched_thd *p = slm_thd_sched_policy(t);
  4124f8:	e8 a3 f1 fe ff       	call   4016a0 <slm_thd_sched_policy>
	l->n->p = l->p;
  4124fd:	48 8b 08             	mov    rcx,QWORD PTR [rax]
--
  41252c:	48 83 ec 08          	sub    rsp,0x8
	struct slm_sched_thd *p = slm_thd_sched_policy(t);
  412530:	e8 6b f1 fe ff       	call   4016a0 <slm_thd_sched_policy>

	assert(ps_list_singleton_d(p));
  412535:	48 3b 00             	cmp    rax,QWORD PTR [rax]
  412538:	75 31                	jne    41256b <slm_sched_fprr_wakeup+0x4b>

	ps_list_head_append_d(&threads[cos_cpuid()].prio[t->priority - 1], p);
--
  41256b:	be 23 00 00 00       	mov    esi,0x23
  412570:	bf 88 ea 41 00       	mov    edi,0x41ea88
  412575:	e8 56 7b ff ff       	call   40a0d0 <cos_print_str>
	assert(ps_list_singleton_d(p));
  41257a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  41259c:	48 83 ec 08          	sub    rsp,0x8
	struct slm_sched_thd *p = slm_thd_sched_policy(t);
  4125a0:	e8 fb f0 fe ff       	call   4016a0 <slm_thd_sched_policy>
	l->n->p = l->p;
  4125a5:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
--
  4125fd:	48 89 e5             	mov    rbp,rsp
	ps_list_init_d(slm_thd_sched_policy(t));
  412600:	e8 9b f0 fe ff       	call   4016a0 <slm_thd_sched_policy>
{ l->n = l->p = l; }
  412605:	66 48 0f 6e c0       	movq   xmm0,rax
--
  412625:	48 89 e5             	mov    rbp,rsp
	ps_list_rem_d(slm_thd_sched_policy(t));
  412628:	e8 73 f0 fe ff       	call   4016a0 <slm_thd_sched_policy>
	l->n->p = l->p;
  41262d:	48 8b 08             	mov    rcx,QWORD PTR [rax]
--
  41265d:	53                   	push   rbx
	switch (type) {
  41265e:	83 fe 0a             	cmp    esi,0xa
  412661:	74 1d                	je     412680 <slm_sched_fprr_thd_update+0x30>
  412663:	83 fe 0b             	cmp    esi,0xb
  412666:	0f 84 b4 00 00 00    	je     412720 <slm_sched_fprr_thd_update+0xd0>
  41266c:	b8 ff ff ff ff       	mov    eax,0xffffffff
  412671:	83 fe 01             	cmp    esi,0x1
  412674:	74 5a                	je     4126d0 <slm_sched_fprr_thd_update+0x80>
	}
	/* Only support priority, for now */
--
  41267b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	struct slm_sched_thd *p = slm_thd_sched_policy(t);
  412680:	e8 1b f0 fe ff       	call   4016a0 <slm_thd_sched_policy>
	t->priority = prio;
  412685:	49 c7 44 24 30 00 00 	mov    QWORD PTR [r12+0x30],0x0
--
		assert(v >= SLM_FPRR_PRIO_HIGHEST && v <= SLM_FPRR_PRIO_LOWEST);
  4126d0:	8d 42 ff             	lea    eax,[rdx-0x1]
  4126d3:	83 f8 1e             	cmp    eax,0x1e
  4126d6:	0f 87 85 00 00 00    	ja     412761 <slm_sched_fprr_thd_update+0x111>
		update_queue(t, v);
  4126dc:	89 d3                	mov    ebx,edx
	struct slm_sched_thd *p = slm_thd_sched_policy(t);
  4126de:	e8 bd ef fe ff       	call   4016a0 <slm_thd_sched_policy>
	t->priority = prio;
  4126e3:	49 89 5c 24 30       	mov    QWORD PTR [r12+0x30],rbx
--
  412711:	66 48 0f 6e da       	movq   xmm3,rdx
  412716:	66 0f 6c c3          	punpcklqdq xmm0,xmm3
  41271a:	eb a0                	jmp    4126bc <slm_sched_fprr_thd_update+0x6c>
  41271c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	struct slm_sched_thd *p = slm_thd_sched_policy(t);
  412720:	e8 7b ef fe ff       	call   4016a0 <slm_thd_sched_policy>
	t->priority = prio;
  412725:	49 c7 44 24 30 1f 00 	mov    QWORD PTR [r12+0x30],0x1f
--
  412753:	66 48 0f 6e d2       	movq   xmm2,rdx
  412758:	66 0f 6c c2          	punpcklqdq xmm0,xmm2
  41275c:	e9 5b ff ff ff       	jmp    4126bc <slm_sched_fprr_thd_update+0x6c>
  412761:	be 24 00 00 00       	mov    esi,0x24
  412766:	bf b0 ea 41 00       	mov    edi,0x41eab0
  41276b:	e8 60 79 ff ff       	call   40a0d0 <cos_print_str>
		assert(v >= SLM_FPRR_PRIO_HIGHEST && v <= SLM_FPRR_PRIO_LOWEST);
  412770:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  412a55:	48 89 e5             	mov    rbp,rsp
	slm_idle_comp_initialization();
  412a58:	e8 d3 da fe ff       	call   400530 <slm_idle_comp_initialization>
  412a5d:	0f 1f 00             	nop    DWORD PTR [rax]

	while (1) {
		slm_idle_iteration();
  412a60:	e8 db ff ff ff       	call   412a40 <slm_idle_iteration>
	while (1) {
  412a65:	eb f9                	jmp    412a60 <slm_idle+0x10>
  412a67:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  412a6e:	00 00 
--
  412a79:	89 f3                	mov    ebx,esi
  412a7b:	48 83 ec 08          	sub    rsp,0x8
  412a7f:	e8 0c ec fe ff       	call   401690 <slm_thd_timer_policy>
  412a84:	89 18                	mov    DWORD PTR [rax],ebx
  412a86:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
--
  412a9d:	53                   	push   rbx
	return slm_thd_timer_policy((struct slm_thd *)a)->abs_wakeup <= slm_thd_timer_policy((struct slm_thd *)b)->abs_wakeup;
  412a9e:	e8 ed eb fe ff       	call   401690 <slm_thd_timer_policy>
  412aa3:	4c 89 e7             	mov    rdi,r12
  412aa6:	48 8b 58 08          	mov    rbx,QWORD PTR [rax+0x8]
  412aaa:	e8 e1 eb fe ff       	call   401690 <slm_thd_timer_policy>
  412aaf:	48 3b 58 08          	cmp    rbx,QWORD PTR [rax+0x8]
}
  412ab3:	5b                   	pop    rbx
--
	assert(now >= g->current_timeout);
  412ad1:	48 8b 15 18 e3 18 00 	mov    rdx,QWORD PTR [rip+0x18e318]        # 5a0df0 <__timer_globals+0xf0>
  412ad8:	48 39 fa             	cmp    rdx,rdi
  412adb:	0f 87 2f 01 00 00    	ja     412c10 <slm_timer_quantum_expire+0x150>
	offset = (now - g->current_timeout) % g->period;
--
  412afd:	48 29 d0             	sub    rax,rdx
	assert(next_timeout > now);
  412b00:	48 39 c7             	cmp    rdi,rax
  412b03:	0f 83 23 01 00 00    	jae    412c2c <slm_timer_quantum_expire+0x16c>
slm_timeout_set(cycles_t timeout)
--
  412b39:	0f 29 05 80 f4 18 00 	movaps XMMWORD PTR [rip+0x18f480],xmm0        # 5a1fc0 <__slm_global+0x100>
	while (heap_size(&g->h) > 0) {
  412b40:	e8 0b 22 00 00       	call   414d50 <heap_size>
  412b45:	85 c0                	test   eax,eax
  412b47:	7e 68                	jle    412bb1 <slm_timer_quantum_expire+0xf1>
		tp = heap_peek(&g->h);
  412b49:	bf 00 0d 5a 00       	mov    edi,0x5a0d00
  412b4e:	e8 0d 1f 00 00       	call   414a60 <heap_peek>
  412b53:	49 89 c4             	mov    r12,rax
		assert(tp);
  412b56:	48 85 c0             	test   rax,rax
  412b59:	74 7d                	je     412bd8 <slm_timer_quantum_expire+0x118>
		tt = slm_thd_timer_policy(tp);
  412b5b:	48 89 c7             	mov    rdi,rax
  412b5e:	e8 2d eb fe ff       	call   401690 <slm_thd_timer_policy>
  412b63:	48 89 c3             	mov    rbx,rax
		assert(tt && tt->timeout_idx > 0);
  412b66:	48 85 c0             	test   rax,rax
  412b69:	74 51                	je     412bbc <slm_timer_quantum_expire+0xfc>
  412b6b:	8b 00                	mov    eax,DWORD PTR [rax]
  412b6d:	85 c0                	test   eax,eax
--
		if (cycles_greater_than(tt->abs_wakeup, now)) break;
  412b78:	48 85 c0             	test   rax,rax
  412b7b:	7f 34                	jg     412bb1 <slm_timer_quantum_expire+0xf1>
		th = heap_highest(&g->h);
  412b7d:	bf 00 0d 5a 00       	mov    edi,0x5a0d00
  412b82:	e8 59 1d 00 00       	call   4148e0 <heap_highest>
		assert(th == tp);
  412b87:	49 39 c4             	cmp    r12,rax
  412b8a:	75 68                	jne    412bf4 <slm_timer_quantum_expire+0x134>
		tt->timeout_idx = -1;
  412b8c:	c7 03 ff ff ff ff    	mov    DWORD PTR [rbx],0xffffffff
--
  412b9a:	4c 89 6b 08          	mov    QWORD PTR [rbx+0x8],r13
		slm_thd_wakeup(th, 1);
  412b9e:	e8 8d 12 00 00       	call   413e30 <slm_thd_wakeup>
	while (heap_size(&g->h) > 0) {
  412ba3:	bf 00 0d 5a 00       	mov    edi,0x5a0d00
  412ba8:	e8 a3 21 00 00       	call   414d50 <heap_size>
  412bad:	85 c0                	test   eax,eax
  412baf:	7f 98                	jg     412b49 <slm_timer_quantum_expire+0x89>
}
  412bb1:	48 83 c4 08          	add    rsp,0x8
--
  412bbc:	be 26 00 00 00       	mov    esi,0x26
  412bc1:	bf 50 eb 41 00       	mov    edi,0x41eb50
  412bc6:	e8 05 75 ff ff       	call   40a0d0 <cos_print_str>
		assert(tt && tt->timeout_idx > 0);
  412bcb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  412bd8:	be 26 00 00 00       	mov    esi,0x26
  412bdd:	bf 28 eb 41 00       	mov    edi,0x41eb28
  412be2:	e8 e9 74 ff ff       	call   40a0d0 <cos_print_str>
		assert(tp);
  412be7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  412bf4:	be 26 00 00 00       	mov    esi,0x26
  412bf9:	bf 78 eb 41 00       	mov    edi,0x41eb78
  412bfe:	e8 cd 74 ff ff       	call   40a0d0 <cos_print_str>
		assert(th == tp);
  412c03:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  412c10:	be 26 00 00 00       	mov    esi,0x26
  412c15:	bf d8 ea 41 00       	mov    edi,0x41ead8
  412c1a:	e8 b1 74 ff ff       	call   40a0d0 <cos_print_str>
	assert(now >= g->current_timeout);
  412c1f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  412c2c:	be 26 00 00 00       	mov    esi,0x26
  412c31:	bf 00 eb 41 00       	mov    edi,0x41eb00
  412c36:	e8 95 74 ff ff       	call   40a0d0 <cos_print_str>
	assert(next_timeout > now);
  412c3b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  412c63:	48 83 ec 08          	sub    rsp,0x8
	struct slm_timer_thd *tt = slm_thd_timer_policy(t);
  412c67:	e8 24 ea fe ff       	call   401690 <slm_thd_timer_policy>
	assert(tt && tt->timeout_idx == -1);
  412c6c:	48 85 c0             	test   rax,rax
  412c6f:	74 35                	je     412ca6 <slm_timer_quantum_add+0x56>
  412c71:	83 38 ff             	cmp    DWORD PTR [rax],0xffffffff
  412c74:	48 89 c3             	mov    rbx,rax
  412c77:	75 2d                	jne    412ca6 <slm_timer_quantum_add+0x56>
	assert(heap_size(&g->h) < MAX_NUM_THREADS);
  412c79:	bf 00 0d 5a 00       	mov    edi,0x5a0d00
  412c7e:	e8 cd 20 00 00       	call   414d50 <heap_size>
  412c83:	83 f8 18             	cmp    eax,0x18
  412c86:	7f 3a                	jg     412cc2 <slm_timer_quantum_add+0x72>
	tt->abs_wakeup = absolute_timeout;
  412c88:	4c 89 6b 08          	mov    QWORD PTR [rbx+0x8],r13
--
  412c8c:	4c 89 e6             	mov    rsi,r12
  412c8f:	bf 00 0d 5a 00       	mov    edi,0x5a0d00
  412c94:	e8 17 1a 00 00       	call   4146b0 <heap_add>
}
  412c99:	48 83 c4 08          	add    rsp,0x8
--
  412ca6:	be 26 00 00 00       	mov    esi,0x26
  412cab:	bf a0 eb 41 00       	mov    edi,0x41eba0
  412cb0:	e8 1b 74 ff ff       	call   40a0d0 <cos_print_str>
	assert(tt && tt->timeout_idx == -1);
  412cb5:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  412cc2:	be 26 00 00 00       	mov    esi,0x26
  412cc7:	bf c8 eb 41 00       	mov    edi,0x41ebc8
  412ccc:	e8 ff 73 ff ff       	call   40a0d0 <cos_print_str>
	assert(heap_size(&g->h) < MAX_NUM_THREADS);
  412cd1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  412ce9:	48 83 ec 08          	sub    rsp,0x8
	struct slm_timer_thd *tt = slm_thd_timer_policy(t);
  412ced:	e8 9e e9 fe ff       	call   401690 <slm_thd_timer_policy>
	if (tt->timeout_idx == -1) return 0;
  412cf2:	83 38 ff             	cmp    DWORD PTR [rax],0xffffffff
  412cf5:	74 27                	je     412d1e <slm_timer_quantum_cancel+0x3e>
	assert(heap_size(&g->h));
  412cf7:	bf 00 0d 5a 00       	mov    edi,0x5a0d00
  412cfc:	48 89 c3             	mov    rbx,rax
  412cff:	e8 4c 20 00 00       	call   414d50 <heap_size>
  412d04:	85 c0                	test   eax,eax
  412d06:	74 1e                	je     412d26 <slm_timer_quantum_cancel+0x46>
	assert(tt->timeout_idx > 0);
  412d08:	8b 33                	mov    esi,DWORD PTR [rbx]
--
	heap_remove(&g->h, tt->timeout_idx);
  412d0e:	bf 00 0d 5a 00       	mov    edi,0x5a0d00
  412d13:	e8 68 1f 00 00       	call   414c80 <heap_remove>
	tt->timeout_idx = -1;
  412d18:	c7 03 ff ff ff ff    	mov    DWORD PTR [rbx],0xffffffff
--
  412d26:	be 27 00 00 00       	mov    esi,0x27
  412d2b:	bf f0 eb 41 00       	mov    edi,0x41ebf0
  412d30:	e8 9b 73 ff ff       	call   40a0d0 <cos_print_str>
	assert(heap_size(&g->h));
  412d35:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  412d42:	be 27 00 00 00       	mov    esi,0x27
  412d47:	bf 18 ec 41 00       	mov    edi,0x41ec18
  412d4c:	e8 7f 73 ff ff       	call   40a0d0 <cos_print_str>
	assert(tt->timeout_idx > 0);
  412d51:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  412d65:	48 89 e5             	mov    rbp,rsp
	struct slm_timer_thd *tt = slm_thd_timer_policy(t);
  412d68:	e8 23 e9 fe ff       	call   401690 <slm_thd_timer_policy>
	*tt = (struct slm_timer_thd){
  412d6d:	c7 00 ff ff ff ff    	mov    DWORD PTR [rax],0xffffffff
--
  412dcc:	48 89 05 15 e0 18 00 	mov    QWORD PTR [rip+0x18e015],rax        # 5a0de8 <__timer_globals+0xe8>
	heap_init(&g->h, MAX_NUM_THREADS, __slm_timeout_compare_min, __slm_timeout_update_idx);
  412dd3:	e8 38 18 00 00       	call   414610 <heap_init>
	__asm__ __volatile__("rdtsc" : "=a" (a), "=d" (d), "=c" (c) : : );
  412dd8:	0f 31                	rdtsc  
--
  412e29:	48 83 ec 08          	sub    rsp,0x8
	return cos_print_str(s, strlen(s));
  412e2d:	e8 9e 2b 00 00       	call   4159d0 <strlen>
  412e32:	4c 89 e7             	mov    rdi,r12
}
--
	return cos_print_str(s, strlen(s));
  412e3a:	89 c6                	mov    esi,eax
  412e3c:	e9 8f 72 ff ff       	jmp    40a0d0 <cos_print_str>
  412e41:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  412e48:	00 00 00 00 
--
	struct slm_thd *t = NULL, *tn = NULL;

	/* Only the scheduler thread should call this function. */
	assert(cos_thdid() == us->tid);
  412e71:	48 39 05 68 f0 18 00 	cmp    QWORD PTR [rip+0x18f068],rax        # 5a1ee0 <__slm_global+0x20>
  412e78:	0f 85 a9 04 00 00    	jne    413327 <slm_sched_loop_intern+0x4d7>
  412e7e:	44 8d 67 02          	lea    r12d,[rdi+0x2]
  412e82:	4c 8d 7d c8          	lea    r15,[rbp-0x38]
--
  412ea7:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  412eab:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  412eaf:	e8 9c e5 ff ff       	call   411450 <cos_sched_rcv>
			if (!tid) goto pending_events;
  412eb4:	48 8b 7d b8          	mov    rdi,QWORD PTR [rbp-0x48]
--
  412ebc:	5e                   	pop    rsi
  412ebd:	48 85 ff             	test   rdi,rdi
  412ec0:	74 51                	je     412f13 <slm_sched_loop_intern+0xc3>
			 * pointer back here that we can use instead
			 * of the tid. This is the only place where
--
			 */
			t = slm_thd_lookup(tid);
  412ec2:	e8 f9 e8 fe ff       	call   4017c0 <slm_thd_lookup>
			assert(t);
  412ec7:	48 85 c0             	test   rax,rax
  412eca:	0f 84 85 04 00 00    	je     413355 <slm_sched_loop_intern+0x505>
			/* don't report the idle thread or a freed thread */
			if (unlikely(t == &g->idle_thd || slm_state_is_dead(t->state))) goto pending_events;
  412ed0:	48 3d 40 1f 5a 00    	cmp    rax,0x5a1f40
  412ed6:	74 3b                	je     412f13 <slm_sched_loop_intern+0xc3>
  412ed8:	f7 40 04 fb ff ff ff 	test   DWORD PTR [rax+0x4],0xfffffffb
  412edf:	74 32                	je     412f13 <slm_sched_loop_intern+0xc3>
			 * allow the scheduler thread to switch to the
			 * CS holder, and switch back when the CS
--
  412eed:	8b 7d b0             	mov    edi,DWORD PTR [rbp-0x50]
	if (ps_list_singleton(t, thd_list)) ps_list_head_append(&g->event_head, t, thd_list);
  412ef0:	48 3b 48 58          	cmp    rcx,QWORD PTR [rax+0x58]
  412ef4:	0f 84 3d 03 00 00    	je     413237 <slm_sched_loop_intern+0x3e7>
	t->event_info.cycles += cycles;
  412efa:	48 03 50 48          	add    rdx,QWORD PTR [rax+0x48]
--
			/* No events? make a scheduling decision */
			if (ps_list_head_empty(&g->event_head)) break;
  412f13:	48 81 3d b2 f0 18 00 	cmp    QWORD PTR [rip+0x18f0b2],0x5a1fd0        # 5a1fd0 <__slm_global+0x110>
  412f1a:	d0 1f 5a 00 
  412f1e:	0f 84 8c 01 00 00    	je     4130b0 <slm_sched_loop_intern+0x260>
		tok    = cos_sched_sync();
  412f24:	e8 d7 e3 ff ff       	call   411300 <cos_sched_sync>
  412f29:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  412f32:	48 89 c2             	mov    rdx,rax
  412f35:	48 83 e2 fe          	and    rdx,0xfffffffffffffffe
  412f39:	0f 85 21 03 00 00    	jne    413260 <slm_sched_loop_intern+0x410>
        __asm__ __volatile__("lock " PS_CAS_STR
  412f3f:	f0 48 0f b1 1d 78 ef 	lock cmpxchg QWORD PTR [rip+0x18ef78],rbx        # 5a1ec0 <__slm_global>
  412f46:	18 00 
  412f48:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  412f4b:	84 c0                	test   al,al
  412f4d:	74 d5                	je     412f24 <slm_sched_loop_intern+0xd4>
			 *
			 * Thus we process the events now, with the CS taken.
--
  412f59:	4c 8d 72 a8          	lea    r14,[rdx-0x58]
  412f5d:	4c 8d 68 a8          	lea    r13,[rax-0x58]
  412f61:	48 81 fa d0 1f 5a 00 	cmp    rdx,0x5a1fd0
  412f68:	0f 84 e5 00 00 00    	je     413053 <slm_sched_loop_intern+0x203>
	l->n->p = l->p;
  412f6e:	49 8b 56 60          	mov    rdx,QWORD PTR [r14+0x60]
--
  412fb3:	41 f7 46 04 fb ff ff 	test   DWORD PTR [r14+0x4],0xfffffffb
  412fba:	ff 
  412fbb:	74 64                	je     413021 <slm_sched_loop_intern+0x1d1>

				/* Notify the policy that some execution has happened. */
				slm_sched_execution(t, cycles);
  412fbd:	4c 89 f7             	mov    rdi,r14
  412fc0:	e8 eb e7 fe ff       	call   4017b0 <slm_sched_execution>

				if (blocked) {
  412fc5:	8b 55 b0             	mov    edx,DWORD PTR [rbp-0x50]
  412fc8:	85 d2                	test   edx,edx
  412fca:	0f 84 cd 01 00 00    	je     41319d <slm_sched_loop_intern+0x34d>
					assert(cycles);
  412fd0:	48 83 7d c0 00       	cmp    QWORD PTR [rbp-0x40],0x0
  412fd5:	0f 84 63 03 00 00    	je     41333e <slm_sched_loop_intern+0x4ee>
	assert(slm_state_is_runnable(t->state) || t->state == SLM_THD_BLOCKED);
  412fdb:	41 8b 46 04          	mov    eax,DWORD PTR [r14+0x4]
--
  412fdf:	8d 50 fe             	lea    edx,[rax-0x2]
  412fe2:	83 e8 01             	sub    eax,0x1
  412fe5:	83 f8 02             	cmp    eax,0x2
  412fe8:	0f 87 82 04 00 00    	ja     413470 <slm_sched_loop_intern+0x620>
	return t != &g->idle_thd && t != &g->sched_thd;
  412fee:	49 81 fe 40 1f 5a 00 	cmp    r14,0x5a1f40
  412ff5:	0f 84 20 02 00 00    	je     41321b <slm_sched_loop_intern+0x3cb>
  412ffb:	49 81 fe c8 1e 5a 00 	cmp    r14,0x5a1ec8
  413002:	0f 84 13 02 00 00    	je     41321b <slm_sched_loop_intern+0x3cb>
	if (likely(slm_state_is_runnable(t->state))) {
  413008:	83 fa 01             	cmp    edx,0x1
  41300b:	77 08                	ja     413015 <slm_sched_loop_intern+0x1c5>
		slm_sched_block(t);
  41300d:	4c 89 f7             	mov    rdi,r14
  413010:	e8 5b e7 fe ff       	call   401770 <slm_sched_block>
	t->properties |= SLM_THD_PROPERTY_SUSPENDED;
  413015:	41 83 0e 04          	or     DWORD PTR [r14],0x4
--
  413025:	4d 89 ee             	mov    r14,r13
  413028:	48 8d 50 a8          	lea    rdx,[rax-0x58]
  41302c:	49 81 fd 78 1f 5a 00 	cmp    r13,0x5a1f78
  413033:	74 1e                	je     413053 <slm_sched_loop_intern+0x203>
  413035:	49 89 d5             	mov    r13,rdx
  413038:	e9 31 ff ff ff       	jmp    412f6e <slm_sched_loop_intern+0x11e>
  41303d:	0f 1f 00             	nop    DWORD PTR [rax]
  413040:	48 89 d0             	mov    rax,rdx
  413043:	f0 48 0f b1 35 74 ee 	lock cmpxchg QWORD PTR [rip+0x18ee74],rsi        # 5a1ec0 <__slm_global>
  41304a:	18 00 
  41304c:	0f 94 c0             	sete   al
	while (ret != 0) {
  41304f:	84 c0                	test   al,al
  413051:	75 4a                	jne    41309d <slm_sched_loop_intern+0x24d>
		tok    = cos_sched_sync();
  413053:	e8 a8 e2 ff ff       	call   411300 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  413058:	48 8b 15 61 ee 18 00 	mov    rdx,QWORD PTR [rip+0x18ee61]        # 5a1ec0 <__slm_global>
--
  413061:	48 89 d6             	mov    rsi,rdx
  413064:	83 e6 01             	and    esi,0x1
  413067:	74 d7                	je     413040 <slm_sched_loop_intern+0x1f0>
  413069:	31 ff                	xor    edi,edi
  41306b:	48 89 d0             	mov    rax,rdx
  41306e:	f0 48 0f b1 3d 49 ee 	lock cmpxchg QWORD PTR [rip+0x18ee49],rdi        # 5a1ec0 <__slm_global>
  413075:	18 00 
  413077:	0f 94 c0             	sete   al
	if (__slm_cs_cas(cs, cached, NULL, 0)) return 1;
  41307a:	84 c0                	test   al,al
  41307c:	74 d5                	je     413053 <slm_sched_loop_intern+0x203>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  41307e:	48 83 e2 fe          	and    rdx,0xfffffffffffffffe
--
  413089:	48 8b 72 30          	mov    rsi,QWORD PTR [rdx+0x30]
  41308d:	31 d2                	xor    edx,edx
  41308f:	e8 cc 96 ff ff       	call   40c760 <cos_defswitch>
	assert(ret != -EINVAL);
  413094:	83 f8 ea             	cmp    eax,0xffffffea
  413097:	0f 84 e4 00 00 00    	je     413181 <slm_sched_loop_intern+0x331>
					slm_thd_sched_wakeup(t);
				}
--
  41309d:	8b 45 ac             	mov    eax,DWORD PTR [rbp-0x54]
  4130a0:	85 c0                	test   eax,eax
  4130a2:	0f 8f e3 fd ff ff    	jg     412e8b <slm_sched_loop_intern+0x3b>
  4130a8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4130af:	00 
		tok    = cos_sched_sync();
  4130b0:	e8 4b e2 ff ff       	call   411300 <cos_sched_sync>
  4130b5:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  4130be:	48 89 c2             	mov    rdx,rax
  4130c1:	48 83 e2 fe          	and    rdx,0xfffffffffffffffe
  4130c5:	0f 85 11 01 00 00    	jne    4131dc <slm_sched_loop_intern+0x38c>
  4130cb:	f0 48 0f b1 1d ec ed 	lock cmpxchg QWORD PTR [rip+0x18edec],rbx        # 5a1ec0 <__slm_global>
  4130d2:	18 00 
  4130d4:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4130d7:	84 c0                	test   al,al
  4130d9:	74 d5                	je     4130b0 <slm_sched_loop_intern+0x260>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  4130db:	e8 80 87 ff ff       	call   40b860 <cos_defcompinfo_curr_get>
	tok  = cos_sched_sync();
  4130e0:	e8 1b e2 ff ff       	call   411300 <cos_sched_sync>
	if (flags & SLM_CS_CHECK_TIMEOUT && g->timer_set) {
  4130e5:	83 3d d0 ee 18 00 00 	cmp    DWORD PTR [rip+0x18eed0],0x0        # 5a1fbc <__slm_global+0xfc>
	tok  = cos_sched_sync();
  4130ec:	41 89 c6             	mov    r14d,eax
	if (flags & SLM_CS_CHECK_TIMEOUT && g->timer_set) {
  4130ef:	0f 85 77 02 00 00    	jne    41336c <slm_sched_loop_intern+0x51c>
	t = slm_sched_schedule();
  4130f5:	e8 a6 e6 fe ff       	call   4017a0 <slm_sched_schedule>
  4130fa:	49 89 c5             	mov    r13,rax
	if (unlikely(!t)) t = &g->idle_thd;
  4130fd:	48 85 c0             	test   rax,rax
  413100:	0f 84 de 02 00 00    	je     4133e4 <slm_sched_loop_intern+0x594>
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  413106:	41 8b 45 04          	mov    eax,DWORD PTR [r13+0x4]
  41310a:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  41310d:	83 f8 01             	cmp    eax,0x1
  413110:	76 25                	jbe    413137 <slm_sched_loop_intern+0x2e7>
  413112:	e9 b1 02 00 00       	jmp    4133c8 <slm_sched_loop_intern+0x578>
  413117:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41311e:	00 00 
  413120:	48 89 d0             	mov    rax,rdx
  413123:	f0 48 0f b1 35 94 ed 	lock cmpxchg QWORD PTR [rip+0x18ed94],rsi        # 5a1ec0 <__slm_global>
  41312a:	18 00 
  41312c:	0f 94 c0             	sete   al
	while (ret != 0) {
  41312f:	84 c0                	test   al,al
  413131:	0f 85 68 01 00 00    	jne    41329f <slm_sched_loop_intern+0x44f>
		tok    = cos_sched_sync();
  413137:	e8 c4 e1 ff ff       	call   411300 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  41313c:	48 8b 15 7d ed 18 00 	mov    rdx,QWORD PTR [rip+0x18ed7d]        # 5a1ec0 <__slm_global>
--
  413145:	48 89 d6             	mov    rsi,rdx
  413148:	83 e6 01             	and    esi,0x1
  41314b:	74 d3                	je     413120 <slm_sched_loop_intern+0x2d0>
  41314d:	31 ff                	xor    edi,edi
  41314f:	48 89 d0             	mov    rax,rdx
  413152:	f0 48 0f b1 3d 65 ed 	lock cmpxchg QWORD PTR [rip+0x18ed65],rdi        # 5a1ec0 <__slm_global>
  413159:	18 00 
  41315b:	0f 94 c0             	sete   al
	if (__slm_cs_cas(cs, cached, NULL, 0)) return 1;
  41315e:	84 c0                	test   al,al
  413160:	74 d5                	je     413137 <slm_sched_loop_intern+0x2e7>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  413162:	48 83 e2 fe          	and    rdx,0xfffffffffffffffe
--
  41316d:	48 8b 72 30          	mov    rsi,QWORD PTR [rdx+0x30]
  413171:	31 d2                	xor    edx,edx
  413173:	e8 e8 95 ff ff       	call   40c760 <cos_defswitch>
	assert(ret != -EINVAL);
  413178:	83 f8 ea             	cmp    eax,0xffffffea
  41317b:	0f 85 1e 01 00 00    	jne    41329f <slm_sched_loop_intern+0x44f>
  413181:	be 23 00 00 00       	mov    esi,0x23
  413186:	bf 08 ed 41 00       	mov    edi,0x41ed08
  41318b:	e8 40 6f ff ff       	call   40a0d0 <cos_print_str>
  413190:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413197:	00 00 00 00 
--
  41319d:	41 8b 06             	mov    eax,DWORD PTR [r14]
  4131a0:	a8 04                	test   al,0x4
  4131a2:	0f 84 79 fe ff ff    	je     413021 <slm_sched_loop_intern+0x1d1>
	t->properties &= ~SLM_THD_PROPERTY_SUSPENDED;
  4131a8:	83 e0 fb             	and    eax,0xfffffffb
--
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  4131b2:	8d 50 fe             	lea    edx,[rax-0x2]
  4131b5:	83 fa 01             	cmp    edx,0x1
  4131b8:	0f 86 e1 01 00 00    	jbe    41339f <slm_sched_loop_intern+0x54f>
	assert(t->state == SLM_THD_BLOCKED);
  4131be:	83 e8 01             	sub    eax,0x1
  4131c1:	0f 85 e5 01 00 00    	jne    4133ac <slm_sched_loop_intern+0x55c>
	t->state = SLM_THD_RUNNABLE;
  4131c7:	41 c7 46 04 03 00 00 	mov    DWORD PTR [r14+0x4],0x3
--
	slm_sched_wakeup(t);
  4131cf:	4c 89 f7             	mov    rdi,r14
  4131d2:	e8 a9 e5 fe ff       	call   401780 <slm_sched_wakeup>
	return 0;
  4131d7:	e9 45 fe ff ff       	jmp    413021 <slm_sched_loop_intern+0x1d1>
	if (!contended) {
  4131dc:	a8 01                	test   al,0x1
  4131de:	75 1b                	jne    4131fb <slm_sched_loop_intern+0x3ab>
	return !ps_cas(&cs->owner_contention, (unsigned long)cached, ((unsigned long)thd | !!contention));
  4131e0:	48 89 d6             	mov    rsi,rdx
  4131e3:	48 83 ce 01          	or     rsi,0x1
  4131e7:	f0 48 0f b1 35 d0 ec 	lock cmpxchg QWORD PTR [rip+0x18ecd0],rsi        # 5a1ec0 <__slm_global>
  4131ee:	18 00 
  4131f0:	0f 94 c0             	sete   al
		if (__slm_cs_cas(cs, cached, owner, 1)) return 1;
  4131f3:	84 c0                	test   al,al
  4131f5:	0f 84 b5 fe ff ff    	je     4130b0 <slm_sched_loop_intern+0x260>
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  4131fb:	48 8b 7a 10          	mov    rdi,QWORD PTR [rdx+0x10]
  4131ff:	48 8b 35 f2 ec 18 00 	mov    rsi,QWORD PTR [rip+0x18ecf2]        # 5a1ef8 <__slm_global+0x38>
  413206:	31 d2                	xor    edx,edx
  413208:	e8 53 95 ff ff       	call   40c760 <cos_defswitch>
			if (flags & SLM_CS_SCHEDEVT && ret == -EBUSY) return ret;
  41320d:	83 f8 f0             	cmp    eax,0xfffffff0
  413210:	0f 85 9a fe ff ff    	jne    4130b0 <slm_sched_loop_intern+0x260>
  413216:	e9 70 fc ff ff       	jmp    412e8b <slm_sched_loop_intern+0x3b>
  41321b:	be 23 00 00 00       	mov    esi,0x23
  413220:	bf 18 ee 41 00       	mov    edi,0x41ee18
  413225:	e8 a6 6e ff ff       	call   40a0d0 <cos_print_str>
	assert(slm_thd_normal(t));
  41322a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  413257:	49 89 48 08          	mov    QWORD PTR [r8+0x8],rcx
}
  41325b:	e9 9a fc ff ff       	jmp    412efa <slm_sched_loop_intern+0xaa>
	if (!contended) {
  413260:	a8 01                	test   al,0x1
  413262:	75 1b                	jne    41327f <slm_sched_loop_intern+0x42f>
  413264:	48 89 d6             	mov    rsi,rdx
  413267:	48 83 ce 01          	or     rsi,0x1
  41326b:	f0 48 0f b1 35 4c ec 	lock cmpxchg QWORD PTR [rip+0x18ec4c],rsi        # 5a1ec0 <__slm_global>
  413272:	18 00 
  413274:	0f 94 c0             	sete   al
		if (__slm_cs_cas(cs, cached, owner, 1)) return 1;
  413277:	84 c0                	test   al,al
  413279:	0f 84 a5 fc ff ff    	je     412f24 <slm_sched_loop_intern+0xd4>
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  41327f:	48 8b 7a 10          	mov    rdi,QWORD PTR [rdx+0x10]
  413283:	48 8b 35 6e ec 18 00 	mov    rsi,QWORD PTR [rip+0x18ec6e]        # 5a1ef8 <__slm_global+0x38>
  41328a:	31 d2                	xor    edx,edx
  41328c:	e8 cf 94 ff ff       	call   40c760 <cos_defswitch>
  413291:	83 f8 f0             	cmp    eax,0xfffffff0
  413294:	0f 85 8a fc ff ff    	jne    412f24 <slm_sched_loop_intern+0xd4>
  41329a:	e9 fe fd ff ff       	jmp    41309d <slm_sched_loop_intern+0x24d>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  41329f:	e8 bc 85 ff ff       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4132a4:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
--
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4132b3:	a8 0b                	test   al,0xb
  4132b5:	0f 85 6a 01 00 00    	jne    413425 <slm_sched_loop_intern+0x5d5>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  4132bb:	49 8b 7d 10          	mov    rdi,QWORD PTR [r13+0x10]
  4132bf:	44 89 f1             	mov    ecx,r14d
  4132c2:	4c 89 c2             	mov    rdx,r8
  4132c5:	e8 96 94 ff ff       	call   40c760 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  4132ca:	83 f8 ff             	cmp    eax,0xffffffff
  4132cd:	0f 84 1c 01 00 00    	je     4133ef <slm_sched_loop_intern+0x59f>
	if (unlikely(ret != 0)) {
  4132d3:	85 c0                	test   eax,eax
  4132d5:	0f 84 b0 fb ff ff    	je     412e8b <slm_sched_loop_intern+0x3b>
		assert(ret != -EINVAL);
  4132db:	83 f8 ea             	cmp    eax,0xffffffea
  4132de:	0f 84 5b 02 00 00    	je     41353f <slm_sched_loop_intern+0x6ef>
		if (ret == -EBUSY) return ret;
  4132e4:	83 f8 f0             	cmp    eax,0xfffffff0
  4132e7:	0f 84 9e fb ff ff    	je     412e8b <slm_sched_loop_intern+0x3b>
		assert(ret == -EAGAIN);
  4132ed:	83 f8 f5             	cmp    eax,0xfffffff5
  4132f0:	0f 85 2d 02 00 00    	jne    413523 <slm_sched_loop_intern+0x6d3>
		tok    = cos_sched_sync();
  4132f6:	e8 05 e0 ff ff       	call   411300 <cos_sched_sync>
  4132fb:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  413304:	48 89 c6             	mov    rsi,rax
  413307:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  41330b:	0f 85 c1 01 00 00    	jne    4134d2 <slm_sched_loop_intern+0x682>
  413311:	f0 48 0f b1 1d a6 eb 	lock cmpxchg QWORD PTR [rip+0x18eba6],rbx        # 5a1ec0 <__slm_global>
  413318:	18 00 
  41331a:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  41331d:	84 c0                	test   al,al
  41331f:	0f 85 bb fd ff ff    	jne    4130e0 <slm_sched_loop_intern+0x290>
  413325:	eb cf                	jmp    4132f6 <slm_sched_loop_intern+0x4a6>
	assert(cos_thdid() == us->tid);
  413327:	bf 40 ec 41 00       	mov    edi,0x41ec40
  41332c:	e8 ef fa ff ff       	call   412e20 <prints.isra.0>
  413331:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413338:	00 00 00 00 
--
					assert(cycles);
  41333e:	bf 90 ec 41 00       	mov    edi,0x41ec90
  413343:	e8 d8 fa ff ff       	call   412e20 <prints.isra.0>
  413348:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41334f:	00 00 00 00 
--
			assert(t);
  413355:	bf 68 ec 41 00       	mov    edi,0x41ec68
  41335a:	e8 c1 fa ff ff       	call   412e20 <prints.isra.0>
  41335f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413366:	00 00 00 00 
--
		if (!cycles_greater_than(g->timer_next, now)) {
  413382:	48 85 c0             	test   rax,rax
  413385:	0f 8f 6a fd ff ff    	jg     4130f5 <slm_sched_loop_intern+0x2a5>
			g->timer_set = 0;
  41338b:	c7 05 27 ec 18 00 00 	mov    DWORD PTR [rip+0x18ec27],0x0        # 5a1fbc <__slm_global+0xfc>
  413392:	00 00 00 
			slm_timer_expire(now);
  413395:	e8 36 e3 fe ff       	call   4016d0 <slm_timer_expire>
  41339a:	e9 56 fd ff ff       	jmp    4130f5 <slm_sched_loop_intern+0x2a5>
		t->state = SLM_THD_RUNNABLE;
  41339f:	41 c7 46 04 03 00 00 	mov    DWORD PTR [r14+0x4],0x3
  4133a6:	00 
		return 1;
  4133a7:	e9 75 fc ff ff       	jmp    413021 <slm_sched_loop_intern+0x1d1>
  4133ac:	be 23 00 00 00       	mov    esi,0x23
  4133b1:	bf e0 ec 41 00       	mov    edi,0x41ece0
  4133b6:	e8 15 6d ff ff       	call   40a0d0 <cos_print_str>
	assert(t->state == SLM_THD_BLOCKED);
  4133bb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  4133c8:	be 2d 00 00 00       	mov    esi,0x2d
  4133cd:	bf 30 ed 41 00       	mov    edi,0x41ed30
  4133d2:	e8 f9 6c ff ff       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  4133d7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	if (unlikely(!t)) t = &g->idle_thd;
  4133e4:	41 bd 40 1f 5a 00    	mov    r13d,0x5a1f40
  4133ea:	e9 17 fd ff ff       	jmp    413106 <slm_sched_loop_intern+0x2b6>
	return t != &g->idle_thd && t != &g->sched_thd;
  4133ef:	49 81 fd 40 1f 5a 00 	cmp    r13,0x5a1f40
  4133f6:	0f 84 b3 00 00 00    	je     4134af <slm_sched_loop_intern+0x65f>
  4133fc:	49 81 fd c8 1e 5a 00 	cmp    r13,0x5a1ec8
  413403:	0f 84 a6 00 00 00    	je     4134af <slm_sched_loop_intern+0x65f>
  413409:	be 2d 00 00 00       	mov    esi,0x2d
  41340e:	bf 60 ed 41 00       	mov    edi,0x41ed60
  413413:	e8 b8 6c ff ff       	call   40a0d0 <cos_print_str>
		assert(ret != -EPERM);
  413418:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  413425:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  413428:	49 81 fd c8 1e 5a 00 	cmp    r13,0x5a1ec8
  41342f:	74 73                	je     4134a4 <slm_sched_loop_intern+0x654>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  413431:	a8 02                	test   al,0x2
  413433:	75 57                	jne    41348c <slm_sched_loop_intern+0x63c>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  413435:	49 89 c8             	mov    r8,rcx
  413438:	a8 01                	test   al,0x1
  41343a:	0f 84 7b fe ff ff    	je     4132bb <slm_sched_loop_intern+0x46b>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  413440:	4d 8b 55 08          	mov    r10,QWORD PTR [r13+0x8]
--
  41344e:	4c 8b 05 93 ea 18 00 	mov    r8,QWORD PTR [rip+0x18ea93]        # 5a1ee8 <__slm_global+0x28>
  413455:	4c 89 d6             	mov    rsi,r10
  413458:	e8 c3 de ff ff       	call   411320 <cos_switch>
	if (unlikely(ret != 0)) {
  41345d:	85 c0                	test   eax,eax
  41345f:	0f 84 26 fa ff ff    	je     412e8b <slm_sched_loop_intern+0x3b>
		assert(ret != -EPERM);
  413465:	83 f8 ff             	cmp    eax,0xffffffff
  413468:	0f 85 6d fe ff ff    	jne    4132db <slm_sched_loop_intern+0x48b>
  41346e:	eb 99                	jmp    413409 <slm_sched_loop_intern+0x5b9>
  413470:	be 23 00 00 00       	mov    esi,0x23
  413475:	bf b8 ec 41 00       	mov    edi,0x41ecb8
  41347a:	e8 51 6c ff ff       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state) || t->state == SLM_THD_BLOCKED);
  41347f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  413497:	44 89 f1             	mov    ecx,r14d
  41349a:	4c 89 c6             	mov    rsi,r8
  41349d:	e8 ee de ff ff       	call   411390 <cos_sched_asnd>
  4134a2:	eb b9                	jmp    41345d <slm_sched_loop_intern+0x60d>
			prio    = curr->priority;
  4134a4:	48 8b 35 4d ea 18 00 	mov    rsi,QWORD PTR [rip+0x18ea4d]        # 5a1ef8 <__slm_global+0x38>
			timeout = TCAP_TIME_NIL;
  4134ab:	31 c9                	xor    ecx,ecx
  4134ad:	eb 82                	jmp    413431 <slm_sched_loop_intern+0x5e1>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  4134af:	4c 8b 05 32 ea 18 00 	mov    r8,QWORD PTR [rip+0x18ea32]        # 5a1ee8 <__slm_global+0x28>
--
  4134bd:	48 8b 15 34 ea 18 00 	mov    rdx,QWORD PTR [rip+0x18ea34]        # 5a1ef8 <__slm_global+0x38>
  4134c4:	48 8b 3d 0d ea 18 00 	mov    rdi,QWORD PTR [rip+0x18ea0d]        # 5a1ed8 <__slm_global+0x18>
  4134cb:	e8 50 de ff ff       	call   411320 <cos_switch>
  4134d0:	eb 8b                	jmp    41345d <slm_sched_loop_intern+0x60d>
	if (!contended) {
  4134d2:	a8 01                	test   al,0x1
  4134d4:	75 1b                	jne    4134f1 <slm_sched_loop_intern+0x6a1>
	return !ps_cas(&cs->owner_contention, (unsigned long)cached, ((unsigned long)thd | !!contention));
  4134d6:	48 89 f2             	mov    rdx,rsi
  4134d9:	48 83 ca 01          	or     rdx,0x1
        __asm__ __volatile__("lock " PS_CAS_STR
  4134dd:	f0 48 0f b1 15 da e9 	lock cmpxchg QWORD PTR [rip+0x18e9da],rdx        # 5a1ec0 <__slm_global>
  4134e4:	18 00 
  4134e6:	0f 94 c0             	sete   al
		if (__slm_cs_cas(cs, cached, owner, 1)) return 1;
  4134e9:	84 c0                	test   al,al
  4134eb:	0f 84 05 fe ff ff    	je     4132f6 <slm_sched_loop_intern+0x4a6>
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  4134f1:	48 8b 7e 10          	mov    rdi,QWORD PTR [rsi+0x10]
  4134f5:	48 8b 35 fc e9 18 00 	mov    rsi,QWORD PTR [rip+0x18e9fc]        # 5a1ef8 <__slm_global+0x38>
  4134fc:	31 d2                	xor    edx,edx
  4134fe:	e8 5d 92 ff ff       	call   40c760 <cos_defswitch>
			assert(ret != -EBUSY);
  413503:	83 f8 f0             	cmp    eax,0xfffffff0
  413506:	0f 85 ea fd ff ff    	jne    4132f6 <slm_sched_loop_intern+0x4a6>
  41350c:	bf f0 ed 41 00       	mov    edi,0x41edf0
  413511:	e8 0a f9 ff ff       	call   412e20 <prints.isra.0>
  413516:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41351d:	00 00 00 00 
--
  413523:	be 2d 00 00 00       	mov    esi,0x2d
  413528:	bf c0 ed 41 00       	mov    edi,0x41edc0
  41352d:	e8 9e 6b ff ff       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  413532:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  41353f:	be 2d 00 00 00       	mov    esi,0x2d
  413544:	bf 90 ed 41 00       	mov    edi,0x41ed90
  413549:	e8 82 6b ff ff       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  41354e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
		consumer = ck_pr_load_uint(&ring->c_head);
  413592:	4d 8d 8a 20 0e 5a 00 	lea    r9,[r10+0x5a0e20]
  413599:	eb 0f                	jmp    4135aa <slm_ipi_event_enqueue+0x4a>
  41359b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

#define CK_PR_CAS_S(S, T, I) CK_PR_CAS(S, T, T, T, I)

CK_PR_CAS_S(char, char, "cmpxchgb")
CK_PR_CAS_S(int, int, "cmpxchgl")
CK_PR_CAS_S(uint, unsigned int, "cmpxchgl")
  4135a0:	89 d0                	mov    eax,edx
  4135a2:	f0 0f b1 31          	lock cmpxchg DWORD PTR [rcx],esi
  4135a6:	89 c2                	mov    edx,eax
		/*
--
		if (CK_CC_LIKELY((producer - consumer) < mask)) {
			if (ck_pr_cas_uint_value(&ring->p_head,
  4135a8:	74 1e                	je     4135c8 <slm_ipi_event_enqueue+0x68>
CK_PR_LOAD_S(uint, unsigned int, "movl")
  4135aa:	41 8b 39             	mov    edi,DWORD PTR [r9]
--
		if (CK_CC_LIKELY((producer - consumer) < mask)) {
  4135b2:	29 f8                	sub    eax,edi
  4135b4:	41 39 c0             	cmp    r8d,eax
  4135b7:	77 e7                	ja     4135a0 <slm_ipi_event_enqueue+0x40>
  4135b9:	8b 01                	mov    eax,DWORD PTR [rcx]
--
			 */
			if (producer == new_producer) {
  4135bb:	39 c2                	cmp    edx,eax
  4135bd:	74 52                	je     413611 <slm_ipi_event_enqueue+0xb1>
  4135bf:	89 c2                	mov    edx,eax
  4135c1:	eb e7                	jmp    4135aa <slm_ipi_event_enqueue+0x4a>
  4135c3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
			producer = new_producer;
--
  4135e2:	49 8d 8a 60 0e 5a 00 	lea    rcx,[r10+0x5a0e60]
  4135e9:	44 8b 87 00 0e 5a 00 	mov    r8d,DWORD PTR [rdi+0x5a0e00]
  4135f0:	41 39 c0             	cmp    r8d,eax
  4135f3:	74 0b                	je     413600 <slm_ipi_event_enqueue+0xa0>
  4135f5:	0f 1f 00             	nop    DWORD PTR [rax]
	__asm__ __volatile__("pause" ::: "memory");
--
CK_PR_LOAD_S(uint, unsigned int, "movl")
  4135fa:	8b 11                	mov    edx,DWORD PTR [rcx]
  4135fc:	39 d0                	cmp    eax,edx
  4135fe:	75 f8                	jne    4135f8 <slm_ipi_event_enqueue+0x98>
CK_PR_STORE_S(uint, unsigned int, "movl", CK_CC_IMM_U32)
  413600:	89 b7 00 0e 5a 00    	mov    DWORD PTR [rdi+0x5a0e00],esi
--
  413641:	8b 8e 60 0e 5a 00    	mov    ecx,DWORD PTR [rsi+0x5a0e60]
	if (CK_CC_UNLIKELY(consumer == producer))
  413647:	39 ca                	cmp    edx,ecx
  413649:	74 25                	je     413670 <slm_ipi_event_dequeue+0x50>
	buffer = (const char *)buffer + size * (consumer & mask);
  41364b:	21 d0                	and    eax,edx
--
  4136dd:	0f b7 90 f0 1f 00 00 	movzx  edx,WORD PTR [rax+0x1ff0]
	if (me == g->sched_thd.tid)     return &g->sched_thd;
  4136e4:	48 39 15 f5 e7 18 00 	cmp    QWORD PTR [rip+0x18e7f5],rdx        # 5a1ee0 <__slm_global+0x20>
  4136eb:	b8 c8 1e 5a 00       	mov    eax,0x5a1ec8
  4136f0:	74 15                	je     413707 <slm_thd_special+0x37>
	else                            return NULL;
  4136f2:	48 39 15 5f e8 18 00 	cmp    QWORD PTR [rip+0x18e85f],rdx        # 5a1f58 <__slm_global+0x98>
  4136f9:	b8 40 1f 5a 00       	mov    eax,0x5a1f40
  4136fe:	ba 00 00 00 00       	mov    edx,0x0
--
  413725:	48 89 75 e8          	mov    QWORD PTR [rbp-0x18],rsi
	struct cos_defcompinfo *defci     = cos_defcompinfo_curr_get();
  413729:	e8 32 81 ff ff       	call   40b860 <cos_defcompinfo_curr_get>
  41372e:	48 89 c7             	mov    rdi,rax
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);
  413731:	e8 6a 81 ff ff       	call   40b8a0 <cos_sched_aep_get>
	memset(t, 0, sizeof(struct slm_thd));
  413736:	49 8d 7c 24 08       	lea    rdi,[r12+0x8]
--
  4137b5:	41 0f 11 44 24 68    	movups XMMWORD PTR [r12+0x68],xmm0
	if ((ret = slm_timer_thd_init(t))) return ret;
  4137bb:	e8 20 df fe ff       	call   4016e0 <slm_timer_thd_init>
  4137c0:	85 c0                	test   eax,eax
  4137c2:	74 0c                	je     4137d0 <slm_thd_init+0xc0>
}
  4137c4:	48 83 c4 10          	add    rsp,0x10
--
  4137da:	5d                   	pop    rbp
	if ((ret = slm_sched_thd_init(t))) return ret;
  4137db:	e9 60 df fe ff       	jmp    401740 <slm_sched_thd_init>

00000000004137e0 <slm_thd_deinit>:
--
  4137ec:	48 83 ec 08          	sub    rsp,0x8
	slm_sched_thd_deinit(t);
  4137f0:	e8 5b df fe ff       	call   401750 <slm_sched_thd_deinit>
	slm_timer_thd_deinit(t);
  4137f5:	48 89 df             	mov    rdi,rbx
  4137f8:	e8 f3 de fe ff       	call   4016f0 <slm_timer_thd_deinit>
	t->state = SLM_THD_DYING;
  4137fd:	c7 43 04 04 00 00 00 	mov    DWORD PTR [rbx+0x4],0x4
--
	if (!contended) {
  41381a:	45 85 c0             	test   r8d,r8d
  41381d:	75 16                	jne    413835 <slm_cs_enter_contention+0x25>
  41381f:	48 89 f0             	mov    rax,rsi
	return !ps_cas(&cs->owner_contention, (unsigned long)cached, ((unsigned long)thd | !!contention));
  413822:	4c 89 d6             	mov    rsi,r10
  413825:	48 83 ce 01          	or     rsi,0x1
  413829:	f0 48 0f b1 37       	lock cmpxchg QWORD PTR [rdi],rsi
  41382e:	0f 94 c0             	sete   al
		if (__slm_cs_cas(cs, cached, owner, 1)) return 1;
  413831:	84 c0                	test   al,al
  413833:	74 23                	je     413858 <slm_cs_enter_contention+0x48>
{
  413835:	55                   	push   rbp
--
  413840:	48 89 e5             	mov    rbp,rsp
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  413843:	e8 18 8f ff ff       	call   40c760 <cos_defswitch>
	if (ret) return ret;
  413848:	85 c0                	test   eax,eax
  41384a:	75 05                	jne    413851 <slm_cs_enter_contention+0x41>
	return 1;
  41384c:	b8 01 00 00 00       	mov    eax,0x1
--
  413867:	48 89 d0             	mov    rax,rdx
  41386a:	31 ff                	xor    edi,edi
  41386c:	f0 49 0f b1 38       	lock cmpxchg QWORD PTR [r8],rdi
  413871:	0f 94 c0             	sete   al
	if (__slm_cs_cas(cs, cached, NULL, 0)) return 1;
  413874:	84 c0                	test   al,al
  413876:	75 08                	jne    413880 <slm_cs_exit_contention+0x20>
}
  413878:	b8 01 00 00 00       	mov    eax,0x1
--
  41388e:	48 89 e5             	mov    rbp,rsp
	ret = cos_defswitch(s->thd, curr->priority, TCAP_TIME_NIL, tok);
  413891:	e8 ca 8e ff ff       	call   40c760 <cos_defswitch>
	return 0;
  413896:	45 31 c0             	xor    r8d,r8d
	assert(ret != -EINVAL);
  413899:	83 f8 ea             	cmp    eax,0xffffffea
  41389c:	74 05                	je     4138a3 <slm_cs_exit_contention+0x43>
}
  41389e:	44 89 c0             	mov    eax,r8d
--
  4138a3:	be 23 00 00 00       	mov    esi,0x23
  4138a8:	bf 08 ed 41 00       	mov    edi,0x41ed08
  4138ad:	e8 1e 68 ff ff       	call   40a0d0 <cos_print_str>
	assert(ret != -EINVAL);
  4138b2:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	assert(t);
  4138c8:	48 85 ff             	test   rdi,rdi
  4138cb:	74 5f                	je     41392c <slm_thd_block+0x6c>
	return t != &g->idle_thd && t != &g->sched_thd;
  4138cd:	48 81 ff c8 1e 5a 00 	cmp    rdi,0x5a1ec8
  4138d4:	74 3a                	je     413910 <slm_thd_block+0x50>
  4138d6:	48 81 ff 40 1f 5a 00 	cmp    rdi,0x5a1f40
  4138dd:	74 31                	je     413910 <slm_thd_block+0x50>
	if (unlikely(t->state == SLM_THD_WOKEN)) {
  4138df:	8b 47 04             	mov    eax,DWORD PTR [rdi+0x4]
  4138e2:	83 f8 02             	cmp    eax,0x2
  4138e5:	74 61                	je     413948 <slm_thd_block+0x88>
	assert(t->state == SLM_THD_RUNNABLE);
  4138e7:	83 f8 03             	cmp    eax,0x3
  4138ea:	75 6f                	jne    41395b <slm_thd_block+0x9b>
	if (t->properties & SLM_THD_PROPERTY_SUSPENDED) {
  4138ec:	8b 07                	mov    eax,DWORD PTR [rdi]
  4138ee:	a8 04                	test   al,0x4
  4138f0:	74 05                	je     4138f7 <slm_thd_block+0x37>
		t->properties &= ~SLM_THD_PROPERTY_SUSPENDED;
  4138f2:	83 e0 fb             	and    eax,0xfffffffb
--
  4138f7:	c7 47 04 01 00 00 00 	mov    DWORD PTR [rdi+0x4],0x1
	slm_sched_block(t);
  4138fe:	e8 6d de fe ff       	call   401770 <slm_sched_block>
	return 0;
  413903:	31 c0                	xor    eax,eax
--
  413910:	be 23 00 00 00       	mov    esi,0x23
  413915:	bf b8 ee 41 00       	mov    edi,0x41eeb8
  41391a:	e8 b1 67 ff ff       	call   40a0d0 <cos_print_str>
	assert(slm_thd_normal(t));
  41391f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  41392c:	be 23 00 00 00       	mov    esi,0x23
  413931:	bf 40 ee 41 00       	mov    edi,0x41ee40
  413936:	e8 95 67 ff ff       	call   40a0d0 <cos_print_str>
	assert(t);
  41393b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
		assert(!(t->properties & SLM_THD_PROPERTY_SUSPENDED));
  413948:	f6 07 04             	test   BYTE PTR [rdi],0x4
  41394b:	75 2a                	jne    413977 <slm_thd_block+0xb7>
		t->state = SLM_THD_RUNNABLE;
  41394d:	c7 47 04 03 00 00 00 	mov    DWORD PTR [rdi+0x4],0x3
--
  41395b:	be 23 00 00 00       	mov    esi,0x23
  413960:	bf 90 ee 41 00       	mov    edi,0x41ee90
  413965:	e8 66 67 ff ff       	call   40a0d0 <cos_print_str>
	assert(t->state == SLM_THD_RUNNABLE);
  41396a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  413977:	be 23 00 00 00       	mov    esi,0x23
  41397c:	bf 68 ee 41 00       	mov    edi,0x41ee68
  413981:	e8 4a 67 ff ff       	call   40a0d0 <cos_print_str>
		assert(!(t->properties & SLM_THD_PROPERTY_SUSPENDED));
  413986:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	assert(current);
  4139b8:	48 85 ff             	test   rdi,rdi
  4139bb:	0f 84 f2 01 00 00    	je     413bb3 <slm_thd_block_cs+0x213>
		tok    = cos_sched_sync();
  4139c1:	e8 3a d9 ff ff       	call   411300 <cos_sched_sync>
  4139c6:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  4139cf:	48 89 c2             	mov    rdx,rax
  4139d2:	48 83 e2 fe          	and    rdx,0xfffffffffffffffe
  4139d6:	0f 85 84 01 00 00    	jne    413b60 <slm_thd_block_cs+0x1c0>
  4139dc:	f0 48 0f b1 1d db e4 	lock cmpxchg QWORD PTR [rip+0x18e4db],rbx        # 5a1ec0 <__slm_global>
  4139e3:	18 00 
  4139e5:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4139e8:	84 c0                	test   al,al
  4139ea:	74 d5                	je     4139c1 <slm_thd_block_cs+0x21>
	if (slm_thd_block(current)) {
  4139ec:	48 89 df             	mov    rdi,rbx
  4139ef:	e8 cc fe ff ff       	call   4138c0 <slm_thd_block>
  4139f4:	85 c0                	test   eax,eax
  4139f6:	0f 85 e4 00 00 00    	jne    413ae0 <slm_thd_block_cs+0x140>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  4139fc:	e8 5f 7e ff ff       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(!t)) t = &g->idle_thd;
  413a01:	41 bf 40 1f 5a 00    	mov    r15d,0x5a1f40
  413a07:	45 31 f6             	xor    r14d,r14d
	tok  = cos_sched_sync();
  413a0a:	e8 f1 d8 ff ff       	call   411300 <cos_sched_sync>
  413a0f:	41 89 c5             	mov    r13d,eax
	t = slm_sched_schedule();
  413a12:	e8 89 dd fe ff       	call   4017a0 <slm_sched_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  413a17:	48 85 c0             	test   rax,rax
--
  413a26:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  413a29:	83 f8 01             	cmp    eax,0x1
  413a2c:	76 1a                	jbe    413a48 <slm_thd_block_cs+0xa8>
  413a2e:	e9 ed 01 00 00       	jmp    413c20 <slm_thd_block_cs+0x280>
  413a33:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  413a38:	f0 48 0f b1 35 7f e4 	lock cmpxchg QWORD PTR [rip+0x18e47f],rsi        # 5a1ec0 <__slm_global>
  413a3f:	18 00 
  413a41:	0f 94 c0             	sete   al
	while (ret != 0) {
  413a44:	84 c0                	test   al,al
  413a46:	75 48                	jne    413a90 <slm_thd_block_cs+0xf0>
		tok    = cos_sched_sync();
  413a48:	e8 b3 d8 ff ff       	call   411300 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  413a4d:	48 8b 15 6c e4 18 00 	mov    rdx,QWORD PTR [rip+0x18e46c]        # 5a1ec0 <__slm_global>
--
  413a59:	48 89 d0             	mov    rax,rdx
  413a5c:	83 e6 01             	and    esi,0x1
  413a5f:	74 d7                	je     413a38 <slm_thd_block_cs+0x98>
  413a61:	f0 4c 0f b1 35 56 e4 	lock cmpxchg QWORD PTR [rip+0x18e456],r14        # 5a1ec0 <__slm_global>
  413a68:	18 00 
  413a6a:	0f 94 c0             	sete   al
	if (__slm_cs_cas(cs, cached, NULL, 0)) return 1;
  413a6d:	84 c0                	test   al,al
  413a6f:	74 d7                	je     413a48 <slm_thd_block_cs+0xa8>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  413a71:	48 83 e2 fe          	and    rdx,0xfffffffffffffffe
--
  413a7c:	48 8b 72 30          	mov    rsi,QWORD PTR [rdx+0x30]
  413a80:	31 d2                	xor    edx,edx
  413a82:	e8 d9 8c ff ff       	call   40c760 <cos_defswitch>
	assert(ret != -EINVAL);
  413a87:	83 f8 ea             	cmp    eax,0xffffffea
  413a8a:	0f 84 ac 00 00 00    	je     413b3c <slm_thd_block_cs+0x19c>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  413a90:	e8 cb 7d ff ff       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  413a95:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
--
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  413aa5:	a8 0b                	test   al,0xb
  413aa7:	0f 85 8f 01 00 00    	jne    413c3c <slm_thd_block_cs+0x29c>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  413aad:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  413ab2:	44 89 e9             	mov    ecx,r13d
  413ab5:	4c 89 c2             	mov    rdx,r8
  413ab8:	e8 a3 8c ff ff       	call   40c760 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  413abd:	83 f8 ff             	cmp    eax,0xffffffff
  413ac0:	0f 84 e5 01 00 00    	je     413cab <slm_thd_block_cs+0x30b>
	if (unlikely(ret != 0)) {
  413ac6:	85 c0                	test   eax,eax
  413ac8:	0f 85 01 01 00 00    	jne    413bcf <slm_thd_block_cs+0x22f>
}
  413ace:	48 83 c4 08          	add    rsp,0x8
--
  413add:	0f 1f 00             	nop    DWORD PTR [rax]
  413ae0:	31 db                	xor    ebx,ebx
  413ae2:	eb 14                	jmp    413af8 <slm_thd_block_cs+0x158>
  413ae4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  413ae8:	f0 48 0f b1 35 cf e3 	lock cmpxchg QWORD PTR [rip+0x18e3cf],rsi        # 5a1ec0 <__slm_global>
  413aef:	18 00 
  413af1:	0f 94 c0             	sete   al
	while (ret != 0) {
  413af4:	84 c0                	test   al,al
  413af6:	75 d6                	jne    413ace <slm_thd_block_cs+0x12e>
		tok    = cos_sched_sync();
  413af8:	e8 03 d8 ff ff       	call   411300 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  413afd:	48 8b 15 bc e3 18 00 	mov    rdx,QWORD PTR [rip+0x18e3bc]        # 5a1ec0 <__slm_global>
--
  413b09:	48 89 d0             	mov    rax,rdx
  413b0c:	83 e6 01             	and    esi,0x1
  413b0f:	74 d7                	je     413ae8 <slm_thd_block_cs+0x148>
  413b11:	f0 48 0f b1 1d a6 e3 	lock cmpxchg QWORD PTR [rip+0x18e3a6],rbx        # 5a1ec0 <__slm_global>
  413b18:	18 00 
  413b1a:	0f 94 c0             	sete   al
	if (__slm_cs_cas(cs, cached, NULL, 0)) return 1;
  413b1d:	84 c0                	test   al,al
  413b1f:	74 d7                	je     413af8 <slm_thd_block_cs+0x158>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  413b21:	48 83 e2 fe          	and    rdx,0xfffffffffffffffe
--
  413b2c:	48 8b 72 30          	mov    rsi,QWORD PTR [rdx+0x30]
  413b30:	31 d2                	xor    edx,edx
  413b32:	e8 29 8c ff ff       	call   40c760 <cos_defswitch>
	assert(ret != -EINVAL);
  413b37:	83 f8 ea             	cmp    eax,0xffffffea
  413b3a:	75 92                	jne    413ace <slm_thd_block_cs+0x12e>
  413b3c:	be 23 00 00 00       	mov    esi,0x23
  413b41:	bf 08 ed 41 00       	mov    edi,0x41ed08
  413b46:	e8 85 65 ff ff       	call   40a0d0 <cos_print_str>
  413b4b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413b52:	00 00 00 00 
--
	if (!contended) {
  413b60:	a8 01                	test   al,0x1
  413b62:	75 1b                	jne    413b7f <slm_thd_block_cs+0x1df>
	return !ps_cas(&cs->owner_contention, (unsigned long)cached, ((unsigned long)thd | !!contention));
  413b64:	48 89 d6             	mov    rsi,rdx
  413b67:	48 83 ce 01          	or     rsi,0x1
  413b6b:	f0 48 0f b1 35 4c e3 	lock cmpxchg QWORD PTR [rip+0x18e34c],rsi        # 5a1ec0 <__slm_global>
  413b72:	18 00 
  413b74:	0f 94 c0             	sete   al
		if (__slm_cs_cas(cs, cached, owner, 1)) return 1;
  413b77:	84 c0                	test   al,al
  413b79:	0f 84 42 fe ff ff    	je     4139c1 <slm_thd_block_cs+0x21>
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  413b7f:	48 8b 7a 10          	mov    rdi,QWORD PTR [rdx+0x10]
  413b83:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
  413b87:	31 d2                	xor    edx,edx
  413b89:	e8 d2 8b ff ff       	call   40c760 <cos_defswitch>
			assert(ret != -EBUSY);
  413b8e:	83 f8 f0             	cmp    eax,0xfffffff0
  413b91:	0f 85 2a fe ff ff    	jne    4139c1 <slm_thd_block_cs+0x21>
  413b97:	be 25 00 00 00       	mov    esi,0x25
  413b9c:	bf f0 ed 41 00       	mov    edi,0x41edf0
  413ba1:	e8 2a 65 ff ff       	call   40a0d0 <cos_print_str>
  413ba6:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413bad:	00 00 00 00 
--
  413bb3:	be 25 00 00 00       	mov    esi,0x25
  413bb8:	bf e0 ee 41 00       	mov    edi,0x41eee0
  413bbd:	e8 0e 65 ff ff       	call   40a0d0 <cos_print_str>
	assert(current);
  413bc2:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  413bcd:	0f 0b                	ud2    
		assert(ret != -EINVAL);
  413bcf:	83 f8 ea             	cmp    eax,0xffffffea
  413bd2:	0f 84 2c 01 00 00    	je     413d04 <slm_thd_block_cs+0x364>
		if (ret == -EBUSY) return ret;
  413bd8:	83 f8 f0             	cmp    eax,0xfffffff0
  413bdb:	0f 84 ed fe ff ff    	je     413ace <slm_thd_block_cs+0x12e>
		assert(ret == -EAGAIN);
  413be1:	83 f8 f5             	cmp    eax,0xfffffff5
  413be4:	0f 85 8e 01 00 00    	jne    413d78 <slm_thd_block_cs+0x3d8>
		tok    = cos_sched_sync();
  413bea:	e8 11 d7 ff ff       	call   411300 <cos_sched_sync>
  413bef:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  413bf8:	48 89 c6             	mov    rsi,rax
  413bfb:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  413bff:	0f 85 1b 01 00 00    	jne    413d20 <slm_thd_block_cs+0x380>
  413c05:	f0 48 0f b1 1d b2 e2 	lock cmpxchg QWORD PTR [rip+0x18e2b2],rbx        # 5a1ec0 <__slm_global>
  413c0c:	18 00 
  413c0e:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  413c11:	84 c0                	test   al,al
  413c13:	0f 85 f1 fd ff ff    	jne    413a0a <slm_thd_block_cs+0x6a>
  413c19:	eb cf                	jmp    413bea <slm_thd_block_cs+0x24a>
  413c1b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  413c20:	be 2d 00 00 00       	mov    esi,0x2d
  413c25:	bf 30 ed 41 00       	mov    edi,0x41ed30
  413c2a:	e8 a1 64 ff ff       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  413c2f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  413c3c:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  413c3f:	49 81 fc c8 1e 5a 00 	cmp    r12,0x5a1ec8
  413c46:	0f 84 91 00 00 00    	je     413cdd <slm_thd_block_cs+0x33d>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  413c4c:	a8 02                	test   al,0x2
  413c4e:	0f 85 94 00 00 00    	jne    413ce8 <slm_thd_block_cs+0x348>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  413c54:	49 89 c8             	mov    r8,rcx
  413c57:	a8 01                	test   al,0x1
  413c59:	0f 84 4e fe ff ff    	je     413aad <slm_thd_block_cs+0x10d>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  413c5f:	4d 8b 54 24 08       	mov    r10,QWORD PTR [r12+0x8]
--
  413c6f:	4c 8b 05 72 e2 18 00 	mov    r8,QWORD PTR [rip+0x18e272]        # 5a1ee8 <__slm_global+0x28>
  413c76:	4c 89 d6             	mov    rsi,r10
  413c79:	e8 a2 d6 ff ff       	call   411320 <cos_switch>
	if (unlikely(ret != 0)) {
  413c7e:	85 c0                	test   eax,eax
  413c80:	0f 84 48 fe ff ff    	je     413ace <slm_thd_block_cs+0x12e>
		assert(ret != -EPERM);
  413c86:	83 f8 ff             	cmp    eax,0xffffffff
  413c89:	0f 85 40 ff ff ff    	jne    413bcf <slm_thd_block_cs+0x22f>
  413c8f:	be 2d 00 00 00       	mov    esi,0x2d
  413c94:	bf 60 ed 41 00       	mov    edi,0x41ed60
  413c99:	e8 32 64 ff ff       	call   40a0d0 <cos_print_str>
  413c9e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413ca5:	00 00 00 00 
  413ca9:	0f 0b                	ud2    
	return t != &g->idle_thd && t != &g->sched_thd;
  413cab:	49 81 fc 40 1f 5a 00 	cmp    r12,0x5a1f40
  413cb2:	74 09                	je     413cbd <slm_thd_block_cs+0x31d>
  413cb4:	49 81 fc c8 1e 5a 00 	cmp    r12,0x5a1ec8
  413cbb:	75 d2                	jne    413c8f <slm_thd_block_cs+0x2ef>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  413cbd:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]
--
  413ccd:	48 8b 3d 04 e2 18 00 	mov    rdi,QWORD PTR [rip+0x18e204]        # 5a1ed8 <__slm_global+0x18>
  413cd4:	31 f6                	xor    esi,esi
  413cd6:	e8 45 d6 ff ff       	call   411320 <cos_switch>
  413cdb:	eb a1                	jmp    413c7e <slm_thd_block_cs+0x2de>
			prio    = curr->priority;
  413cdd:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
			timeout = TCAP_TIME_NIL;
  413ce1:	31 c9                	xor    ecx,ecx
  413ce3:	e9 64 ff ff ff       	jmp    413c4c <slm_thd_block_cs+0x2ac>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  413ce8:	49 8b 7c 24 28       	mov    rdi,QWORD PTR [r12+0x28]
--
  413cf4:	44 89 e9             	mov    ecx,r13d
  413cf7:	4c 89 c6             	mov    rsi,r8
  413cfa:	e8 91 d6 ff ff       	call   411390 <cos_sched_asnd>
  413cff:	e9 7a ff ff ff       	jmp    413c7e <slm_thd_block_cs+0x2de>
  413d04:	be 2d 00 00 00       	mov    esi,0x2d
  413d09:	bf 90 ed 41 00       	mov    edi,0x41ed90
  413d0e:	e8 bd 63 ff ff       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  413d13:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	if (!contended) {
  413d20:	a8 01                	test   al,0x1
  413d22:	75 1b                	jne    413d3f <slm_thd_block_cs+0x39f>
	return !ps_cas(&cs->owner_contention, (unsigned long)cached, ((unsigned long)thd | !!contention));
  413d24:	48 89 f2             	mov    rdx,rsi
  413d27:	48 83 ca 01          	or     rdx,0x1
  413d2b:	f0 48 0f b1 15 8c e1 	lock cmpxchg QWORD PTR [rip+0x18e18c],rdx        # 5a1ec0 <__slm_global>
  413d32:	18 00 
  413d34:	0f 94 c0             	sete   al
		if (__slm_cs_cas(cs, cached, owner, 1)) return 1;
  413d37:	84 c0                	test   al,al
  413d39:	0f 84 ab fe ff ff    	je     413bea <slm_thd_block_cs+0x24a>
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  413d3f:	4c 8b 43 30          	mov    r8,QWORD PTR [rbx+0x30]
--
  413d47:	31 d2                	xor    edx,edx
  413d49:	4c 89 c6             	mov    rsi,r8
  413d4c:	e8 0f 8a ff ff       	call   40c760 <cos_defswitch>
			assert(ret != -EBUSY);
  413d51:	83 f8 f0             	cmp    eax,0xfffffff0
  413d54:	0f 85 90 fe ff ff    	jne    413bea <slm_thd_block_cs+0x24a>
  413d5a:	bf f0 ed 41 00       	mov    edi,0x41edf0
  413d5f:	e8 bc f0 ff ff       	call   412e20 <prints.isra.0>
  413d64:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413d6b:	00 00 00 00 
--
  413d78:	be 2d 00 00 00       	mov    esi,0x2d
  413d7d:	bf c0 ed 41 00       	mov    edi,0x41edc0
  413d82:	e8 49 63 ff ff       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  413d87:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	assert(t);
  413da8:	48 85 ff             	test   rdi,rdi
  413dab:	74 2b                	je     413dd8 <slm_thd_sched_wakeup+0x38>
	if (unlikely(!(t->properties & SLM_THD_PROPERTY_SUSPENDED))) return 1;
  413dad:	8b 07                	mov    eax,DWORD PTR [rdi]
  413daf:	a8 04                	test   al,0x4
  413db1:	74 41                	je     413df4 <slm_thd_sched_wakeup+0x54>
	t->properties &= ~SLM_THD_PROPERTY_SUSPENDED;
  413db3:	83 e0 fb             	and    eax,0xfffffffb
--
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  413dbb:	8d 50 fe             	lea    edx,[rax-0x2]
  413dbe:	83 fa 01             	cmp    edx,0x1
  413dc1:	76 38                	jbe    413dfb <slm_thd_sched_wakeup+0x5b>
	assert(t->state == SLM_THD_BLOCKED);
  413dc3:	83 f8 01             	cmp    eax,0x1
  413dc6:	75 41                	jne    413e09 <slm_thd_sched_wakeup+0x69>
	t->state = SLM_THD_RUNNABLE;
  413dc8:	c7 47 04 03 00 00 00 	mov    DWORD PTR [rdi+0x4],0x3
	slm_sched_wakeup(t);
  413dcf:	e8 ac d9 fe ff       	call   401780 <slm_sched_wakeup>
	return 0;
  413dd4:	31 c0                	xor    eax,eax
--
  413dd8:	be 23 00 00 00       	mov    esi,0x23
  413ddd:	bf 08 ef 41 00       	mov    edi,0x41ef08
  413de2:	e8 e9 62 ff ff       	call   40a0d0 <cos_print_str>
	assert(t);
  413de7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  413e09:	be 23 00 00 00       	mov    esi,0x23
  413e0e:	bf e0 ec 41 00       	mov    edi,0x41ece0
  413e13:	e8 b8 62 ff ff       	call   40a0d0 <cos_print_str>
	assert(t->state == SLM_THD_BLOCKED);
  413e18:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	assert(t);
  413e3b:	48 85 ff             	test   rdi,rdi
  413e3e:	74 6e                	je     413eae <slm_thd_wakeup+0x7e>
	if (unlikely(t->cpuid != cos_cpuid())) {
  413e40:	4c 63 67 38          	movsxd r12,DWORD PTR [rdi+0x38]
  413e44:	48 89 fb             	mov    rbx,rdi
  413e47:	45 85 e4             	test   r12d,r12d
  413e4a:	75 7e                	jne    413eca <slm_thd_wakeup+0x9a>
	if (t->state == SLM_THD_WOKEN) return 1;
  413e4c:	8b 47 04             	mov    eax,DWORD PTR [rdi+0x4]
  413e4f:	83 f8 02             	cmp    eax,0x2
  413e52:	74 4c                	je     413ea0 <slm_thd_wakeup+0x70>
	if (unlikely(t->state == SLM_THD_RUNNABLE || (redundant && t->state == SLM_THD_WOKEN))) {
  413e54:	83 f8 03             	cmp    eax,0x3
  413e57:	0f 84 22 01 00 00    	je     413f7f <slm_thd_wakeup+0x14f>
	assert(t->state == SLM_THD_BLOCKED);
  413e5d:	83 f8 01             	cmp    eax,0x1
  413e60:	0f 85 2b 01 00 00    	jne    413f91 <slm_thd_wakeup+0x161>
	return t != &g->idle_thd && t != &g->sched_thd;
  413e66:	48 81 ff c8 1e 5a 00 	cmp    rdi,0x5a1ec8
  413e6d:	0f 84 3d 01 00 00    	je     413fb0 <slm_thd_wakeup+0x180>
  413e73:	48 81 ff 40 1f 5a 00 	cmp    rdi,0x5a1f40
  413e7a:	0f 84 30 01 00 00    	je     413fb0 <slm_thd_wakeup+0x180>
	t->state = SLM_THD_RUNNABLE;
  413e80:	c7 47 04 03 00 00 00 	mov    DWORD PTR [rdi+0x4],0x3
	slm_sched_wakeup(t);
  413e87:	e8 f4 d8 fe ff       	call   401780 <slm_sched_wakeup>
	t->properties &= ~SLM_THD_PROPERTY_SUSPENDED;
  413e8c:	83 23 fb             	and    DWORD PTR [rbx],0xfffffffb
--
  413eae:	be 23 00 00 00       	mov    esi,0x23
  413eb3:	bf 30 ef 41 00       	mov    edi,0x41ef30
  413eb8:	e8 13 62 ff ff       	call   40a0d0 <cos_print_str>
	assert(t);
  413ebd:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
		consumer = ck_pr_load_uint(&ring->c_head);
  413ef1:	49 8d 99 20 0e 5a 00 	lea    rbx,[r9+0x5a0e20]
  413ef8:	eb 10                	jmp    413f0a <slm_thd_wakeup+0xda>
  413efa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
CK_PR_CAS_S(uint, unsigned int, "cmpxchgl")
  413f00:	89 d0                	mov    eax,edx
  413f02:	f0 0f b1 0e          	lock cmpxchg DWORD PTR [rsi],ecx
  413f06:	89 c2                	mov    edx,eax
			if (ck_pr_cas_uint_value(&ring->p_head,
  413f08:	74 1c                	je     413f26 <slm_thd_wakeup+0xf6>
CK_PR_LOAD_S(uint, unsigned int, "movl")
  413f0a:	8b 3b                	mov    edi,DWORD PTR [rbx]
--
		if (CK_CC_LIKELY((producer - consumer) < mask)) {
  413f11:	29 f8                	sub    eax,edi
  413f13:	41 39 c0             	cmp    r8d,eax
  413f16:	77 e8                	ja     413f00 <slm_thd_wakeup+0xd0>
  413f18:	8b 06                	mov    eax,DWORD PTR [rsi]
			if (producer == new_producer) {
  413f1a:	39 c2                	cmp    edx,eax
  413f1c:	0f 84 aa 00 00 00    	je     413fcc <slm_thd_wakeup+0x19c>
  413f22:	89 c2                	mov    edx,eax
  413f24:	eb e4                	jmp    413f0a <slm_thd_wakeup+0xda>
	buffer = (char *)buffer + ts * (producer & mask);
  413f26:	41 21 c0             	and    r8d,eax
--
  413f3d:	49 8d b1 60 0e 5a 00 	lea    rsi,[r9+0x5a0e60]
  413f44:	44 8b 87 00 0e 5a 00 	mov    r8d,DWORD PTR [rdi+0x5a0e00]
  413f4b:	41 39 c0             	cmp    r8d,eax
  413f4e:	74 08                	je     413f58 <slm_thd_wakeup+0x128>
	__asm__ __volatile__("pause" ::: "memory");
  413f50:	f3 90                	pause  
CK_PR_LOAD_S(uint, unsigned int, "movl")
  413f52:	8b 16                	mov    edx,DWORD PTR [rsi]
  413f54:	39 d0                	cmp    eax,edx
  413f56:	75 f8                	jne    413f50 <slm_thd_wakeup+0x120>
CK_PR_STORE_S(uint, unsigned int, "movl", CK_CC_IMM_U32)
  413f58:	89 8f 00 0e 5a 00    	mov    DWORD PTR [rdi+0x5a0e00],ecx
--
  413f72:	45 31 e4             	xor    r12d,r12d
		cos_asnd(ipi_data->ipi_thd.asnd, 1);
  413f75:	e8 76 d4 ff ff       	call   4113f0 <cos_asnd>
		return 0;
  413f7a:	e9 10 ff ff ff       	jmp    413e8f <slm_thd_wakeup+0x5f>
		t->state = SLM_THD_WOKEN;
  413f7f:	c7 47 04 02 00 00 00 	mov    DWORD PTR [rdi+0x4],0x2
		return 1;
  413f86:	41 bc 01 00 00 00    	mov    r12d,0x1
  413f8c:	e9 fe fe ff ff       	jmp    413e8f <slm_thd_wakeup+0x5f>
  413f91:	be 23 00 00 00       	mov    esi,0x23
  413f96:	bf 58 ef 41 00       	mov    edi,0x41ef58
  413f9b:	e8 30 61 ff ff       	call   40a0d0 <cos_print_str>
	assert(t->state == SLM_THD_BLOCKED);
  413fa0:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  413fb0:	be 23 00 00 00       	mov    esi,0x23
  413fb5:	bf a8 ef 41 00       	mov    edi,0x41efa8
  413fba:	e8 11 61 ff ff       	call   40a0d0 <cos_print_str>
	assert(slm_thd_normal(t));
  413fbf:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  413fcc:	be 23 00 00 00       	mov    esi,0x23
  413fd1:	bf 80 ef 41 00       	mov    edi,0x41ef80
  413fd6:	e8 f5 60 ff ff       	call   40a0d0 <cos_print_str>
		assert(ret);
  413fdb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	assert(t);
  414005:	48 85 f6             	test   rsi,rsi
  414008:	0f 84 aa 01 00 00    	je     4141b8 <slm_thd_wakeup_cs+0x1c8>
  41400e:	48 89 fb             	mov    rbx,rdi
  414011:	49 89 f4             	mov    r12,rsi
	assert(current);
  414014:	48 85 ff             	test   rdi,rdi
  414017:	0f 84 0a 02 00 00    	je     414227 <slm_thd_wakeup_cs+0x237>
		tok    = cos_sched_sync();
  41401d:	e8 de d2 ff ff       	call   411300 <cos_sched_sync>
  414022:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  41402b:	48 89 c2             	mov    rdx,rax
  41402e:	48 83 e2 fe          	and    rdx,0xfffffffffffffffe
  414032:	0f 85 9c 01 00 00    	jne    4141d4 <slm_thd_wakeup_cs+0x1e4>
  414038:	f0 48 0f b1 1d 7f de 	lock cmpxchg QWORD PTR [rip+0x18de7f],rbx        # 5a1ec0 <__slm_global>
  41403f:	18 00 
  414041:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  414044:	84 c0                	test   al,al
  414046:	74 d5                	je     41401d <slm_thd_wakeup_cs+0x2d>
	if (slm_thd_wakeup(t, 0)) {
  414048:	31 f6                	xor    esi,esi
  41404a:	4c 89 e7             	mov    rdi,r12
  41404d:	e8 de fd ff ff       	call   413e30 <slm_thd_wakeup>
  414052:	85 c0                	test   eax,eax
  414054:	0f 85 e6 00 00 00    	jne    414140 <slm_thd_wakeup_cs+0x150>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  41405a:	e8 01 78 ff ff       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(!t)) t = &g->idle_thd;
  41405f:	41 bf 40 1f 5a 00    	mov    r15d,0x5a1f40
  414065:	45 31 f6             	xor    r14d,r14d
	tok  = cos_sched_sync();
  414068:	e8 93 d2 ff ff       	call   411300 <cos_sched_sync>
  41406d:	41 89 c5             	mov    r13d,eax
	t = slm_sched_schedule();
  414070:	e8 2b d7 fe ff       	call   4017a0 <slm_sched_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  414075:	48 85 c0             	test   rax,rax
--
  414084:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  414087:	83 f8 01             	cmp    eax,0x1
  41408a:	76 1c                	jbe    4140a8 <slm_thd_wakeup_cs+0xb8>
  41408c:	e9 ff 01 00 00       	jmp    414290 <slm_thd_wakeup_cs+0x2a0>
  414091:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  414098:	f0 48 0f b1 35 1f de 	lock cmpxchg QWORD PTR [rip+0x18de1f],rsi        # 5a1ec0 <__slm_global>
  41409f:	18 00 
  4140a1:	0f 94 c0             	sete   al
	while (ret != 0) {
  4140a4:	84 c0                	test   al,al
  4140a6:	75 48                	jne    4140f0 <slm_thd_wakeup_cs+0x100>
		tok    = cos_sched_sync();
  4140a8:	e8 53 d2 ff ff       	call   411300 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  4140ad:	48 8b 15 0c de 18 00 	mov    rdx,QWORD PTR [rip+0x18de0c]        # 5a1ec0 <__slm_global>
--
  4140b9:	48 89 d0             	mov    rax,rdx
  4140bc:	83 e6 01             	and    esi,0x1
  4140bf:	74 d7                	je     414098 <slm_thd_wakeup_cs+0xa8>
  4140c1:	f0 4c 0f b1 35 f6 dd 	lock cmpxchg QWORD PTR [rip+0x18ddf6],r14        # 5a1ec0 <__slm_global>
  4140c8:	18 00 
  4140ca:	0f 94 c0             	sete   al
	if (__slm_cs_cas(cs, cached, NULL, 0)) return 1;
  4140cd:	84 c0                	test   al,al
  4140cf:	74 d7                	je     4140a8 <slm_thd_wakeup_cs+0xb8>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  4140d1:	48 83 e2 fe          	and    rdx,0xfffffffffffffffe
--
  4140dc:	48 8b 72 30          	mov    rsi,QWORD PTR [rdx+0x30]
  4140e0:	31 d2                	xor    edx,edx
  4140e2:	e8 79 86 ff ff       	call   40c760 <cos_defswitch>
	assert(ret != -EINVAL);
  4140e7:	83 f8 ea             	cmp    eax,0xffffffea
  4140ea:	0f 84 ac 00 00 00    	je     41419c <slm_thd_wakeup_cs+0x1ac>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  4140f0:	e8 6b 77 ff ff       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4140f5:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
--
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  414105:	a8 0b                	test   al,0xb
  414107:	0f 85 9f 01 00 00    	jne    4142ac <slm_thd_wakeup_cs+0x2bc>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  41410d:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  414112:	44 89 e9             	mov    ecx,r13d
  414115:	4c 89 c2             	mov    rdx,r8
  414118:	e8 43 86 ff ff       	call   40c760 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  41411d:	83 f8 ff             	cmp    eax,0xffffffff
  414120:	0f 84 f5 01 00 00    	je     41431b <slm_thd_wakeup_cs+0x32b>
	if (unlikely(ret != 0)) {
  414126:	85 c0                	test   eax,eax
  414128:	0f 85 15 01 00 00    	jne    414243 <slm_thd_wakeup_cs+0x253>
}
  41412e:	48 83 c4 08          	add    rsp,0x8
--
  41413d:	0f 1f 00             	nop    DWORD PTR [rax]
  414140:	31 db                	xor    ebx,ebx
  414142:	eb 14                	jmp    414158 <slm_thd_wakeup_cs+0x168>
  414144:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  414148:	f0 48 0f b1 35 6f dd 	lock cmpxchg QWORD PTR [rip+0x18dd6f],rsi        # 5a1ec0 <__slm_global>
  41414f:	18 00 
  414151:	0f 94 c0             	sete   al
	while (ret != 0) {
  414154:	84 c0                	test   al,al
  414156:	75 d6                	jne    41412e <slm_thd_wakeup_cs+0x13e>
		tok    = cos_sched_sync();
  414158:	e8 a3 d1 ff ff       	call   411300 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  41415d:	48 8b 15 5c dd 18 00 	mov    rdx,QWORD PTR [rip+0x18dd5c]        # 5a1ec0 <__slm_global>
--
  414169:	48 89 d0             	mov    rax,rdx
  41416c:	83 e6 01             	and    esi,0x1
  41416f:	74 d7                	je     414148 <slm_thd_wakeup_cs+0x158>
  414171:	f0 48 0f b1 1d 46 dd 	lock cmpxchg QWORD PTR [rip+0x18dd46],rbx        # 5a1ec0 <__slm_global>
  414178:	18 00 
  41417a:	0f 94 c0             	sete   al
	if (__slm_cs_cas(cs, cached, NULL, 0)) return 1;
  41417d:	84 c0                	test   al,al
  41417f:	74 d7                	je     414158 <slm_thd_wakeup_cs+0x168>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  414181:	48 83 e2 fe          	and    rdx,0xfffffffffffffffe
--
  41418c:	48 8b 72 30          	mov    rsi,QWORD PTR [rdx+0x30]
  414190:	31 d2                	xor    edx,edx
  414192:	e8 c9 85 ff ff       	call   40c760 <cos_defswitch>
	assert(ret != -EINVAL);
  414197:	83 f8 ea             	cmp    eax,0xffffffea
  41419a:	75 92                	jne    41412e <slm_thd_wakeup_cs+0x13e>
  41419c:	be 23 00 00 00       	mov    esi,0x23
  4141a1:	bf 08 ed 41 00       	mov    edi,0x41ed08
  4141a6:	e8 25 5f ff ff       	call   40a0d0 <cos_print_str>
  4141ab:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4141b2:	00 00 00 00 
--
  4141b8:	be 23 00 00 00       	mov    esi,0x23
  4141bd:	bf d0 ef 41 00       	mov    edi,0x41efd0
  4141c2:	e8 09 5f ff ff       	call   40a0d0 <cos_print_str>
	assert(t);
  4141c7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	if (!contended) {
  4141d4:	a8 01                	test   al,0x1
  4141d6:	75 1b                	jne    4141f3 <slm_thd_wakeup_cs+0x203>
	return !ps_cas(&cs->owner_contention, (unsigned long)cached, ((unsigned long)thd | !!contention));
  4141d8:	48 89 d6             	mov    rsi,rdx
  4141db:	48 83 ce 01          	or     rsi,0x1
  4141df:	f0 48 0f b1 35 d8 dc 	lock cmpxchg QWORD PTR [rip+0x18dcd8],rsi        # 5a1ec0 <__slm_global>
  4141e6:	18 00 
  4141e8:	0f 94 c0             	sete   al
		if (__slm_cs_cas(cs, cached, owner, 1)) return 1;
  4141eb:	84 c0                	test   al,al
  4141ed:	0f 84 2a fe ff ff    	je     41401d <slm_thd_wakeup_cs+0x2d>
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  4141f3:	48 8b 7a 10          	mov    rdi,QWORD PTR [rdx+0x10]
  4141f7:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
  4141fb:	31 d2                	xor    edx,edx
  4141fd:	e8 5e 85 ff ff       	call   40c760 <cos_defswitch>
			assert(ret != -EBUSY);
  414202:	83 f8 f0             	cmp    eax,0xfffffff0
  414205:	0f 85 12 fe ff ff    	jne    41401d <slm_thd_wakeup_cs+0x2d>
  41420b:	be 25 00 00 00       	mov    esi,0x25
  414210:	bf f0 ed 41 00       	mov    edi,0x41edf0
  414215:	e8 b6 5e ff ff       	call   40a0d0 <cos_print_str>
  41421a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414221:	00 00 00 00 
--
  414227:	be 25 00 00 00       	mov    esi,0x25
  41422c:	bf e0 ee 41 00       	mov    edi,0x41eee0
  414231:	e8 9a 5e ff ff       	call   40a0d0 <cos_print_str>
	assert(current);
  414236:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  414241:	0f 0b                	ud2    
		assert(ret != -EINVAL);
  414243:	83 f8 ea             	cmp    eax,0xffffffea
  414246:	0f 84 98 01 00 00    	je     4143e4 <slm_thd_wakeup_cs+0x3f4>
		if (ret == -EBUSY) return ret;
  41424c:	83 f8 f0             	cmp    eax,0xfffffff0
  41424f:	0f 84 d9 fe ff ff    	je     41412e <slm_thd_wakeup_cs+0x13e>
		assert(ret == -EAGAIN);
  414255:	83 f8 f5             	cmp    eax,0xfffffff5
  414258:	0f 85 6a 01 00 00    	jne    4143c8 <slm_thd_wakeup_cs+0x3d8>
		tok    = cos_sched_sync();
  41425e:	e8 9d d0 ff ff       	call   411300 <cos_sched_sync>
  414263:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
--
  41426c:	48 89 c6             	mov    rsi,rax
  41426f:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  414273:	0f 85 fb 00 00 00    	jne    414374 <slm_thd_wakeup_cs+0x384>
  414279:	f0 48 0f b1 1d 3e dc 	lock cmpxchg QWORD PTR [rip+0x18dc3e],rbx        # 5a1ec0 <__slm_global>
  414280:	18 00 
  414282:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  414285:	84 c0                	test   al,al
  414287:	0f 85 db fd ff ff    	jne    414068 <slm_thd_wakeup_cs+0x78>
  41428d:	eb cf                	jmp    41425e <slm_thd_wakeup_cs+0x26e>
  41428f:	90                   	nop
  414290:	be 2d 00 00 00       	mov    esi,0x2d
  414295:	bf 30 ed 41 00       	mov    edi,0x41ed30
  41429a:	e8 31 5e ff ff       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  41429f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  4142ac:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  4142af:	49 81 fc c8 1e 5a 00 	cmp    r12,0x5a1ec8
  4142b6:	0f 84 91 00 00 00    	je     41434d <slm_thd_wakeup_cs+0x35d>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  4142bc:	a8 02                	test   al,0x2
  4142be:	0f 85 94 00 00 00    	jne    414358 <slm_thd_wakeup_cs+0x368>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  4142c4:	49 89 c8             	mov    r8,rcx
  4142c7:	a8 01                	test   al,0x1
  4142c9:	0f 84 3e fe ff ff    	je     41410d <slm_thd_wakeup_cs+0x11d>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  4142cf:	4d 8b 54 24 08       	mov    r10,QWORD PTR [r12+0x8]
--
  4142df:	4c 8b 05 02 dc 18 00 	mov    r8,QWORD PTR [rip+0x18dc02]        # 5a1ee8 <__slm_global+0x28>
  4142e6:	4c 89 d6             	mov    rsi,r10
  4142e9:	e8 32 d0 ff ff       	call   411320 <cos_switch>
	if (unlikely(ret != 0)) {
  4142ee:	85 c0                	test   eax,eax
  4142f0:	0f 84 38 fe ff ff    	je     41412e <slm_thd_wakeup_cs+0x13e>
		assert(ret != -EPERM);
  4142f6:	83 f8 ff             	cmp    eax,0xffffffff
  4142f9:	0f 85 44 ff ff ff    	jne    414243 <slm_thd_wakeup_cs+0x253>
  4142ff:	be 2d 00 00 00       	mov    esi,0x2d
  414304:	bf 60 ed 41 00       	mov    edi,0x41ed60
  414309:	e8 c2 5d ff ff       	call   40a0d0 <cos_print_str>
  41430e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414315:	00 00 00 00 
  414319:	0f 0b                	ud2    
	return t != &g->idle_thd && t != &g->sched_thd;
  41431b:	49 81 fc 40 1f 5a 00 	cmp    r12,0x5a1f40
  414322:	74 09                	je     41432d <slm_thd_wakeup_cs+0x33d>
  414324:	49 81 fc c8 1e 5a 00 	cmp    r12,0x5a1ec8
  41432b:	75 d2                	jne    4142ff <slm_thd_wakeup_cs+0x30f>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  41432d:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]
--
  41433d:	48 8b 3d 94 db 18 00 	mov    rdi,QWORD PTR [rip+0x18db94]        # 5a1ed8 <__slm_global+0x18>
  414344:	31 f6                	xor    esi,esi
  414346:	e8 d5 cf ff ff       	call   411320 <cos_switch>
  41434b:	eb a1                	jmp    4142ee <slm_thd_wakeup_cs+0x2fe>
			prio    = curr->priority;
  41434d:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
			timeout = TCAP_TIME_NIL;
  414351:	31 c9                	xor    ecx,ecx
  414353:	e9 64 ff ff ff       	jmp    4142bc <slm_thd_wakeup_cs+0x2cc>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  414358:	49 8b 7c 24 28       	mov    rdi,QWORD PTR [r12+0x28]
--
  414364:	44 89 e9             	mov    ecx,r13d
  414367:	4c 89 c6             	mov    rsi,r8
  41436a:	e8 21 d0 ff ff       	call   411390 <cos_sched_asnd>
  41436f:	e9 7a ff ff ff       	jmp    4142ee <slm_thd_wakeup_cs+0x2fe>
	if (!contended) {
  414374:	a8 01                	test   al,0x1
  414376:	75 1b                	jne    414393 <slm_thd_wakeup_cs+0x3a3>
	return !ps_cas(&cs->owner_contention, (unsigned long)cached, ((unsigned long)thd | !!contention));
  414378:	48 89 f2             	mov    rdx,rsi
  41437b:	48 83 ca 01          	or     rdx,0x1
  41437f:	f0 48 0f b1 15 38 db 	lock cmpxchg QWORD PTR [rip+0x18db38],rdx        # 5a1ec0 <__slm_global>
  414386:	18 00 
  414388:	0f 94 c0             	sete   al
		if (__slm_cs_cas(cs, cached, owner, 1)) return 1;
  41438b:	84 c0                	test   al,al
  41438d:	0f 84 cb fe ff ff    	je     41425e <slm_thd_wakeup_cs+0x26e>
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  414393:	4c 8b 43 30          	mov    r8,QWORD PTR [rbx+0x30]
--
  41439b:	31 d2                	xor    edx,edx
  41439d:	4c 89 c6             	mov    rsi,r8
  4143a0:	e8 bb 83 ff ff       	call   40c760 <cos_defswitch>
			assert(ret != -EBUSY);
  4143a5:	83 f8 f0             	cmp    eax,0xfffffff0
  4143a8:	0f 85 b0 fe ff ff    	jne    41425e <slm_thd_wakeup_cs+0x26e>
  4143ae:	bf f0 ed 41 00       	mov    edi,0x41edf0
  4143b3:	e8 68 ea ff ff       	call   412e20 <prints.isra.0>
  4143b8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4143bf:	00 00 00 00 
--
  4143c8:	be 2d 00 00 00       	mov    esi,0x2d
  4143cd:	bf c0 ed 41 00       	mov    edi,0x41edc0
  4143d2:	e8 f9 5c ff ff       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  4143d7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  4143e4:	be 2d 00 00 00       	mov    esi,0x2d
  4143e9:	bf 90 ed 41 00       	mov    edi,0x41ed90
  4143ee:	e8 dd 5c ff ff       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  4143f3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  414437:	48 89 e5             	mov    rbp,rsp
	slm_sched_loop_intern(0);
  41443a:	e8 11 ea ff ff       	call   412e50 <slm_sched_loop_intern>
  41443f:	90                   	nop

--
  41444a:	48 89 e5             	mov    rbp,rsp
	slm_sched_loop_intern(1);
  41444d:	e8 fe e9 ff ff       	call   412e50 <slm_sched_loop_intern>
  414452:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  414459:	00 00 00 00 
--

	defci = cos_defcompinfo_curr_get();
  414487:	e8 d4 73 ff ff       	call   40b860 <cos_defcompinfo_curr_get>
  41448c:	48 89 c7             	mov    rdi,rax
	sched_aep = cos_sched_aep_get(defci);
  41448f:	e8 0c 74 ff ff       	call   40b8a0 <cos_sched_aep_get>

	*s = (struct slm_thd) {
--
  414518:	0f 29 15 11 da 18 00 	movaps XMMWORD PTR [rip+0x18da11],xmm2        # 5a1f30 <__slm_global+0x70>
	assert(s->tid == cos_thdid());
  41451f:	48 39 d0             	cmp    rax,rdx
  414522:	0f 85 cb 00 00 00    	jne    4145f3 <slm_init+0x193>
  414528:	41 bf 98 1f 5a 00    	mov    r15d,0x5a1f98

--
  4145be:	0f 29 05 1b da 18 00 	movaps XMMWORD PTR [rip+0x18da1b],xmm0        # 5a1fe0 <__slm_global+0x120>
	g->cyc_per_usec = cos_hw_cycles_per_usec(BOOT_CAPTBL_SELF_INITHW_BASE);
  4145c5:	e8 56 d9 ff ff       	call   411f20 <cos_hw_cycles_per_usec>
	g->lock.owner_contention = 0;
  4145ca:	48 c7 05 eb d8 18 00 	mov    QWORD PTR [rip+0x18d8eb],0x0        # 5a1ec0 <__slm_global>
--

	slm_sched_init();
  4145db:	e8 50 d1 fe ff       	call   401730 <slm_sched_init>
	slm_timer_init();
}
--
  4145ed:	5d                   	pop    rbp
	slm_timer_init();
  4145ee:	e9 2d d1 fe ff       	jmp    401720 <slm_timer_init>
  4145f3:	be 23 00 00 00       	mov    esi,0x23
  4145f8:	bf f8 ef 41 00       	mov    edi,0x41eff8
  4145fd:	e8 ce 5a ff ff       	call   40a0d0 <cos_print_str>
	assert(s->tid == cos_thdid());
  414602:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
/* public functions */
void
heap_init(struct heap *h, int max_sz, cmp_fn_t c, update_fn_t u)
{
  414610:	f3 0f 1e fa          	endbr64 
--
	assert(h);
  414622:	48 85 ff             	test   rdi,rdi
  414625:	74 19                	je     414640 <heap_init+0x30>

	h->max_sz = max_sz + 1;
--
  414646:	bf 38 f0 41 00       	mov    edi,0x41f038
  41464b:	48 89 e5             	mov    rbp,rsp
  41464e:	e8 7d 5a ff ff       	call   40a0d0 <cos_print_str>
	assert(h);
  414653:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--

struct heap *
heap_alloc(int max_sz, cmp_fn_t c, update_fn_t u)
{
  414660:	f3 0f 1e fa          	endbr64 
--
	assert(h && h->data);
  414674:	48 85 ff             	test   rdi,rdi
  414677:	74 08                	je     414681 <heap_destroy+0x11>
  414679:	48 83 7f 18 00       	cmp    QWORD PTR [rdi+0x18],0x0
  41467e:	74 01                	je     414681 <heap_destroy+0x11>
  414680:	c3                   	ret    
{
--
  414687:	bf 60 f0 41 00       	mov    edi,0x41f060
  41468c:	48 89 e5             	mov    rbp,rsp
  41468f:	e8 3c 5a ff ff       	call   40a0d0 <cos_print_str>
	assert(h && h->data);
  414694:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	if (h->max_sz == h->e) return -1;
  4146c8:	44 8b 37             	mov    r14d,DWORD PTR [rdi]
  4146cb:	44 39 77 04          	cmp    DWORD PTR [rdi+0x4],r14d
  4146cf:	0f 84 fd 01 00 00    	je     4148d2 <heap_add+0x222>

	debug("heap_add(%p,%d) %p\n", h, h->e, new);
--
	h->u(new, c);
  4146e3:	44 89 f6             	mov    esi,r14d
  4146e6:	ff 53 10             	call   QWORD PTR [rbx+0x10]
	h->e++;
  4146e9:	8b 03                	mov    eax,DWORD PTR [rbx]
--
  4146ee:	89 03                	mov    DWORD PTR [rbx],eax
	assert(c <= h->e);
  4146f0:	41 39 c6             	cmp    r14d,eax
  4146f3:	0f 8f 85 01 00 00    	jg     41487e <heap_add+0x1ce>
	assert(c > 0);
  4146f9:	45 85 f6             	test   r14d,r14d
  4146fc:	0f 8e 98 01 00 00    	jle    41489a <heap_add+0x1ea>
	while (c > 1) {
  414702:	41 83 fe 01          	cmp    r14d,0x1
  414706:	75 43                	jne    41474b <heap_add+0x9b>
  414708:	e9 55 01 00 00       	jmp    414862 <heap_add+0x1b2>
  41470d:	0f 1f 00             	nop    DWORD PTR [rax]
	arr[a] = arr[b];
--
	u(arr[a], a);
  414731:	48 8b 38             	mov    rdi,QWORD PTR [rax]
  414734:	41 ff d7             	call   r15
	u(arr[b], b);
  414737:	49 8b 3c 24          	mov    rdi,QWORD PTR [r12]
  41473b:	44 89 ee             	mov    esi,r13d
  41473e:	41 ff d7             	call   r15
	while (c > 1) {
  414741:	41 83 fe 01          	cmp    r14d,0x1
  414745:	0f 84 15 01 00 00    	je     414860 <heap_add+0x1b0>
		p = c / 2;
  41474b:	49 63 ce             	movsxd rcx,r14d
--
  414772:	48 89 7d c8          	mov    QWORD PTR [rbp-0x38],rdi
  414776:	48 8b 3c d0          	mov    rdi,QWORD PTR [rax+rdx*8]
  41477a:	ff 53 08             	call   QWORD PTR [rbx+0x8]
  41477d:	85 c0                	test   eax,eax
  41477f:	74 8f                	je     414710 <heap_add+0x60>
	assert(c <= h->e);
  414781:	8b 03                	mov    eax,DWORD PTR [rbx]
  414783:	41 39 c5             	cmp    r13d,eax
  414786:	0f 8f 2a 01 00 00    	jg     4148b6 <heap_add+0x206>
	l = h->e - 1;
  41478c:	83 e8 01             	sub    eax,0x1
--
  414792:	d1 f8                	sar    eax,1
  414794:	89 45 c0             	mov    DWORD PTR [rbp-0x40],eax
  414797:	41 39 c5             	cmp    r13d,eax
  41479a:	7e 75                	jle    414811 <heap_add+0x161>
  41479c:	e9 cc 00 00 00       	jmp    41486d <heap_add+0x1bd>
  4147a1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		if (h->c(h->data[c], h->data[n])) break; /* done? */
--
  4147c2:	48 8b 34 f0          	mov    rsi,QWORD PTR [rax+rsi*8]
  4147c6:	48 8b 3c c8          	mov    rdi,QWORD PTR [rax+rcx*8]
  4147ca:	ff 53 08             	call   QWORD PTR [rbx+0x8]
  4147cd:	85 c0                	test   eax,eax
  4147cf:	0f 85 98 00 00 00    	jne    41486d <heap_add+0x1bd>
	t      = arr[a];
  4147d5:	4c 03 63 18          	add    r12,QWORD PTR [rbx+0x18]
--
	u(arr[a], a);
  4147f6:	49 8b 3c 24          	mov    rdi,QWORD PTR [r12]
  4147fa:	ff d0                	call   rax
	u(arr[b], b);
  4147fc:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  4147ff:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  414803:	44 89 ee             	mov    esi,r13d
  414806:	ff d0                	call   rax
	while (c <= l / 2) { /* not a leaf? */
  414808:	44 3b 7d c0          	cmp    r15d,DWORD PTR [rbp-0x40]
  41480c:	7f 5f                	jg     41486d <heap_add+0x1bd>
  41480e:	45 89 fd             	mov    r13d,r15d
		left  = 2 * c;
--
  414816:	45 8d 67 01          	lea    r12d,[r15+0x1]
		if (right > l) {
  41481a:	44 39 65 c4          	cmp    DWORD PTR [rbp-0x3c],r12d
  41481e:	7c 1b                	jl     41483b <heap_add+0x18b>
		} else if (h->c(h->data[left], h->data[right])) {
--
  41482b:	49 63 cf             	movsxd rcx,r15d
  41482e:	48 8b 3c c8          	mov    rdi,QWORD PTR [rax+rcx*8]
  414832:	ff 53 08             	call   QWORD PTR [rbx+0x8]
  414835:	85 c0                	test   eax,eax
  414837:	45 0f 44 fc          	cmove  r15d,r12d
		assert(n < h->e);
  41483b:	44 39 3b             	cmp    DWORD PTR [rbx],r15d
  41483e:	0f 8f 64 ff ff ff    	jg     4147a8 <heap_add+0xf8>
  414844:	be 23 00 00 00       	mov    esi,0x23
  414849:	bf 00 f1 41 00       	mov    edi,0x41f100
  41484e:	e8 7d 58 ff ff       	call   40a0d0 <cos_print_str>
  414853:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41485a:	00 00 00 00 
--
  414860:	8b 03                	mov    eax,DWORD PTR [rbx]
  414862:	41 bd 01 00 00 00    	mov    r13d,0x1
  414868:	e9 16 ff ff ff       	jmp    414783 <heap_add+0xd3>
	heapify(h, c);
	assert(!heap_verify(h));
--
  41487e:	be 23 00 00 00       	mov    esi,0x23
  414883:	bf 88 f0 41 00       	mov    edi,0x41f088
  414888:	e8 43 58 ff ff       	call   40a0d0 <cos_print_str>
	assert(c <= h->e);
  41488d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  41489a:	be 23 00 00 00       	mov    esi,0x23
  41489f:	bf b0 f0 41 00       	mov    edi,0x41f0b0
  4148a4:	e8 27 58 ff ff       	call   40a0d0 <cos_print_str>
	assert(c > 0);
  4148a9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  4148b6:	be 23 00 00 00       	mov    esi,0x23
  4148bb:	bf d8 f0 41 00       	mov    edi,0x41f0d8
  4148c0:	e8 0b 58 ff ff       	call   40a0d0 <cos_print_str>
	assert(c <= h->e);
  4148c5:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	if (h->max_sz == h->e) return -1;
  4148d2:	b8 ff ff ff ff       	mov    eax,0xffffffff
  4148d7:	eb 96                	jmp    41486f <heap_add+0x1bf>
  4148d9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

--
	if (h->e == 1) return NULL;
  4148f5:	8b 07                	mov    eax,DWORD PTR [rdi]
  4148f7:	83 f8 01             	cmp    eax,0x1
  4148fa:	0f 84 2d 01 00 00    	je     414a2d <heap_highest+0x14d>

	assert(!heap_verify(h));
--
  414923:	48 8b 47 18          	mov    rax,QWORD PTR [rdi+0x18]
  414927:	48 8b 78 08          	mov    rdi,QWORD PTR [rax+0x8]
  41492b:	41 ff 57 10          	call   QWORD PTR [r15+0x10]
	assert(c <= h->e);
  41492f:	45 8b 2f             	mov    r13d,DWORD PTR [r15]
--
  414942:	d1 f8                	sar    eax,1
  414944:	89 45 c0             	mov    DWORD PTR [rbp-0x40],eax
  414947:	0f 84 c3 00 00 00    	je     414a10 <heap_highest+0x130>
  41494d:	41 bc 01 00 00 00    	mov    r12d,0x1
  414953:	eb 6d                	jmp    4149c2 <heap_highest+0xe2>
  414955:	0f 1f 00             	nop    DWORD PTR [rax]
		if (h->c(h->data[c], h->data[n])) break; /* done? */
--
  414976:	48 8b 3c f0          	mov    rdi,QWORD PTR [rax+rsi*8]
  41497a:	4c 89 c6             	mov    rsi,r8
  41497d:	41 ff 57 08          	call   QWORD PTR [r15+0x8]
  414981:	85 c0                	test   eax,eax
  414983:	0f 85 87 00 00 00    	jne    414a10 <heap_highest+0x130>
	t      = arr[a];
  414989:	49 03 5f 18          	add    rbx,QWORD PTR [r15+0x18]
--
  4149a5:	44 89 ee             	mov    esi,r13d
  4149a8:	48 8b 3b             	mov    rdi,QWORD PTR [rbx]
  4149ab:	ff d0                	call   rax
	u(arr[b], b);
  4149ad:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  4149b0:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  4149b4:	44 89 e6             	mov    esi,r12d
  4149b7:	ff d0                	call   rax
	while (c <= l / 2) { /* not a leaf? */
  4149b9:	44 3b 6d c0          	cmp    r13d,DWORD PTR [rbp-0x40]
  4149bd:	7f 51                	jg     414a10 <heap_highest+0x130>
  4149bf:	45 89 ec             	mov    r12d,r13d
		left  = 2 * c;
--
  4149c6:	41 8d 5d 01          	lea    ebx,[r13+0x1]
		if (right > l) {
  4149ca:	39 5d c4             	cmp    DWORD PTR [rbp-0x3c],ebx
  4149cd:	7c 1c                	jl     4149eb <heap_highest+0x10b>
		} else if (h->c(h->data[left], h->data[right])) {
--
  4149d9:	48 8b 34 f0          	mov    rsi,QWORD PTR [rax+rsi*8]
  4149dd:	48 8b 3c f8          	mov    rdi,QWORD PTR [rax+rdi*8]
  4149e1:	41 ff 57 08          	call   QWORD PTR [r15+0x8]
  4149e5:	85 c0                	test   eax,eax
  4149e7:	44 0f 44 eb          	cmove  r13d,ebx
		assert(n < h->e);
  4149eb:	45 39 2f             	cmp    DWORD PTR [r15],r13d
  4149ee:	0f 8f 64 ff ff ff    	jg     414958 <heap_highest+0x78>
  4149f4:	be 23 00 00 00       	mov    esi,0x23
  4149f9:	bf 00 f1 41 00       	mov    edi,0x41f100
  4149fe:	e8 cd 56 ff ff       	call   40a0d0 <cos_print_str>
  414a03:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414a0a:	00 00 00 00 
--
  414a10:	48 8b 7d b8          	mov    rdi,QWORD PTR [rbp-0x48]
  414a14:	31 f6                	xor    esi,esi
  414a16:	41 ff 57 10          	call   QWORD PTR [r15+0x10]

	return r;
--
  414a2d:	48 c7 45 b8 00 00 00 	mov    QWORD PTR [rbp-0x48],0x0
  414a34:	00 
  414a35:	eb e3                	jmp    414a1a <heap_highest+0x13a>
  414a37:	be 23 00 00 00       	mov    esi,0x23
  414a3c:	bf d8 f0 41 00       	mov    edi,0x41f0d8
  414a41:	e8 8a 56 ff ff       	call   40a0d0 <cos_print_str>
	assert(c <= h->e);
  414a46:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  414a60:	f3 0f 1e fa          	endbr64 
	if (h->e == 1) return NULL;
  414a64:	83 3f 01             	cmp    DWORD PTR [rdi],0x1
  414a67:	74 0f                	je     414a78 <heap_peek+0x18>
	assert(!heap_verify(h));
	return h->data[1];
--
	assert(c < h->e);
  414a95:	8b 07                	mov    eax,DWORD PTR [rdi]
  414a97:	39 f0                	cmp    eax,esi
  414a99:	0f 8e 8d 01 00 00    	jle    414c2c <heap_adjust+0x1ac>
  414a9f:	41 89 f6             	mov    r14d,esi
--
  414aaa:	48 89 fb             	mov    rbx,rdi
	while (c > 1) {
  414aad:	83 fe 01             	cmp    esi,0x1
  414ab0:	75 49                	jne    414afb <heap_adjust+0x7b>
  414ab2:	e9 5b 01 00 00       	jmp    414c12 <heap_adjust+0x192>
  414ab7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  414abe:	00 00 
--
	u(arr[a], a);
  414ae1:	48 8b 38             	mov    rdi,QWORD PTR [rax]
  414ae4:	41 ff d7             	call   r15
	u(arr[b], b);
  414ae7:	49 8b 3c 24          	mov    rdi,QWORD PTR [r12]
  414aeb:	44 89 ee             	mov    esi,r13d
  414aee:	41 ff d7             	call   r15
	while (c > 1) {
  414af1:	41 83 fe 01          	cmp    r14d,0x1
  414af5:	0f 84 15 01 00 00    	je     414c10 <heap_adjust+0x190>
		p = c / 2;
  414afb:	49 63 ce             	movsxd rcx,r14d
--
  414b22:	48 89 7d c8          	mov    QWORD PTR [rbp-0x38],rdi
  414b26:	48 8b 3c d0          	mov    rdi,QWORD PTR [rax+rdx*8]
  414b2a:	ff 53 08             	call   QWORD PTR [rbx+0x8]
  414b2d:	85 c0                	test   eax,eax
  414b2f:	74 8f                	je     414ac0 <heap_adjust+0x40>
	assert(c <= h->e);
  414b31:	8b 03                	mov    eax,DWORD PTR [rbx]
  414b33:	44 39 e8             	cmp    eax,r13d
  414b36:	0f 8c 28 01 00 00    	jl     414c64 <heap_adjust+0x1e4>
	l = h->e - 1;
--
  414b42:	d1 f8                	sar    eax,1
  414b44:	89 45 c0             	mov    DWORD PTR [rbp-0x40],eax
  414b47:	44 39 e8             	cmp    eax,r13d
  414b4a:	7d 75                	jge    414bc1 <heap_adjust+0x141>
  414b4c:	e9 cc 00 00 00       	jmp    414c1d <heap_adjust+0x19d>
  414b51:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		if (h->c(h->data[c], h->data[n])) break; /* done? */
--
  414b72:	48 8b 34 f0          	mov    rsi,QWORD PTR [rax+rsi*8]
  414b76:	48 8b 3c c8          	mov    rdi,QWORD PTR [rax+rcx*8]
  414b7a:	ff 53 08             	call   QWORD PTR [rbx+0x8]
  414b7d:	85 c0                	test   eax,eax
  414b7f:	0f 85 98 00 00 00    	jne    414c1d <heap_adjust+0x19d>
	t      = arr[a];
  414b85:	4c 03 63 18          	add    r12,QWORD PTR [rbx+0x18]
--
	u(arr[a], a);
  414ba6:	49 8b 3c 24          	mov    rdi,QWORD PTR [r12]
  414baa:	ff d0                	call   rax
	u(arr[b], b);
  414bac:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  414baf:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  414bb3:	44 89 ee             	mov    esi,r13d
  414bb6:	ff d0                	call   rax
	while (c <= l / 2) { /* not a leaf? */
  414bb8:	44 39 7d c0          	cmp    DWORD PTR [rbp-0x40],r15d
  414bbc:	7c 5f                	jl     414c1d <heap_adjust+0x19d>
  414bbe:	45 89 fd             	mov    r13d,r15d
--
  414bc6:	45 8d 67 01          	lea    r12d,[r15+0x1]
		if (right > l) {
  414bca:	44 39 65 c4          	cmp    DWORD PTR [rbp-0x3c],r12d
  414bce:	7c 1b                	jl     414beb <heap_adjust+0x16b>
		} else if (h->c(h->data[left], h->data[right])) {
--
  414bdb:	49 63 cf             	movsxd rcx,r15d
  414bde:	48 8b 3c c8          	mov    rdi,QWORD PTR [rax+rcx*8]
  414be2:	ff 53 08             	call   QWORD PTR [rbx+0x8]
  414be5:	85 c0                	test   eax,eax
  414be7:	45 0f 44 fc          	cmove  r15d,r12d
		assert(n < h->e);
  414beb:	44 39 3b             	cmp    DWORD PTR [rbx],r15d
  414bee:	0f 8f 64 ff ff ff    	jg     414b58 <heap_adjust+0xd8>
  414bf4:	be 23 00 00 00       	mov    esi,0x23
  414bf9:	bf 00 f1 41 00       	mov    edi,0x41f100
  414bfe:	e8 cd 54 ff ff       	call   40a0d0 <cos_print_str>
  414c03:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414c0a:	00 00 00 00 
--
  414c10:	8b 03                	mov    eax,DWORD PTR [rbx]
  414c12:	41 bd 01 00 00 00    	mov    r13d,0x1
  414c18:	e9 16 ff ff ff       	jmp    414b33 <heap_adjust+0xb3>

	debug("heap_adjust(%p,%d) %p@%d\n", h, h->e, h->data[c], c);
--
  414c2c:	be 24 00 00 00       	mov    esi,0x24
  414c31:	bf 28 f1 41 00       	mov    edi,0x41f128
  414c36:	e8 95 54 ff ff       	call   40a0d0 <cos_print_str>
	assert(c < h->e);
  414c3b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  414c48:	be 24 00 00 00       	mov    esi,0x24
  414c4d:	bf 50 f1 41 00       	mov    edi,0x41f150
  414c52:	e8 79 54 ff ff       	call   40a0d0 <cos_print_str>
	assert(c > 0);
  414c57:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  414c64:	be 23 00 00 00       	mov    esi,0x23
  414c69:	bf d8 f0 41 00       	mov    edi,0x41f0d8
  414c6e:	e8 5d 54 ff ff       	call   40a0d0 <cos_print_str>
	assert(c <= h->e);
  414c73:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	assert(c < h->e);
  414c8f:	8b 07                	mov    eax,DWORD PTR [rdi]
  414c91:	39 f0                	cmp    eax,esi
  414c93:	7e 6f                	jle    414d04 <heap_remove+0x84>
  414c95:	41 89 f5             	mov    r13d,esi
--
  414c9a:	0f 8e 80 00 00 00    	jle    414d20 <heap_remove+0xa0>
	if (h->e == 1) return NULL;
  414ca0:	83 f8 01             	cmp    eax,0x1
  414ca3:	0f 84 93 00 00 00    	je     414d3c <heap_remove+0xbc>

	assert(!heap_verify(h));
--
	h->u(r, 0);
  414cbe:	4c 89 f7             	mov    rdi,r14
  414cc1:	41 ff 54 24 10       	call   QWORD PTR [r12+0x10]

	if (c == h->e) {
  414cc6:	49 63 04 24          	movsxd rax,DWORD PTR [r12]
  414cca:	44 39 e8             	cmp    eax,r13d
  414ccd:	74 29                	je     414cf8 <heap_remove+0x78>
		assert(!heap_verify(h));
		return r;
--
  414cdf:	49 8b 44 24 18       	mov    rax,QWORD PTR [r12+0x18]
  414ce4:	48 8b 3c d8          	mov    rdi,QWORD PTR [rax+rbx*8]
  414ce8:	41 ff 54 24 10       	call   QWORD PTR [r12+0x10]
	heap_adjust(h, c);
  414ced:	44 89 ee             	mov    esi,r13d
  414cf0:	4c 89 e7             	mov    rdi,r12
  414cf3:	e8 88 fd ff ff       	call   414a80 <heap_adjust>
	assert(!heap_verify(h));

--
  414d04:	be 24 00 00 00       	mov    esi,0x24
  414d09:	bf 78 f1 41 00       	mov    edi,0x41f178
  414d0e:	e8 bd 53 ff ff       	call   40a0d0 <cos_print_str>
	assert(c < h->e);
  414d13:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
  414d20:	be 24 00 00 00       	mov    esi,0x24
  414d25:	bf a0 f1 41 00       	mov    edi,0x41f1a0
  414d2a:	e8 a1 53 ff ff       	call   40a0d0 <cos_print_str>
	assert(c >= 1);
  414d2f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
--
	if (h->e == 1) return NULL;
  414d3c:	45 31 f6             	xor    r14d,r14d
  414d3f:	eb b7                	jmp    414cf8 <heap_remove+0x78>
  414d41:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  414d48:	00 00 00 00 
--
	mov %rdi,%rax
  414d5a:	48 89 f8             	mov    rax,rdi
	cmp $8,%rdx
  414d5d:	48 83 fa 08          	cmp    rdx,0x8
	jc 1f
  414d61:	72 14                	jb     414d77 <memcpy+0x1d>
--
  414d63:	f7 c7 07 00 00 00    	test   edi,0x7
	jz 1f
  414d69:	74 0c                	je     414d77 <memcpy+0x1d>
2:	movsb
  414d6b:	a4                   	movs   BYTE PTR es:[rdi],BYTE PTR ds:[rsi]
--
  414d6f:	f7 c7 07 00 00 00    	test   edi,0x7
	jnz 2b
  414d75:	75 f4                	jne    414d6b <memcpy+0x11>
1:	mov %rdx,%rcx
  414d77:	48 89 d1             	mov    rcx,rdx
--
  414d81:	83 e2 07             	and    edx,0x7
	jz 1f
  414d84:	74 05                	je     414d8b <memcpy+0x31>
2:	movsb
  414d86:	a4                   	movs   BYTE PTR es:[rdi],BYTE PTR ds:[rsi]
--
  414d87:	ff ca                	dec    edx
	jnz 2b
  414d89:	75 fb                	jne    414d86 <memcpy+0x2c>
1:	ret
  414d8b:	c3                   	ret    
--
  414d9a:	49 0f af c0          	imul   rax,r8

	cmp $126,%rdx
  414d9e:	48 83 fa 7e          	cmp    rdx,0x7e
	ja 2f
  414da2:	77 78                	ja     414e1c <memset+0x90>
--
  414da4:	85 d2                	test   edx,edx
	jz 1f
  414da6:	74 70                	je     414e18 <memset+0x8c>

	mov %sil,(%rdi)
--
	mov %sil,-1(%rdi,%rdx)
  414dab:	40 88 74 17 ff       	mov    BYTE PTR [rdi+rdx*1-0x1],sil
	cmp $2,%edx
  414db0:	83 fa 02             	cmp    edx,0x2
	jbe 1f
  414db3:	76 63                	jbe    414e18 <memset+0x8c>
--
	mov %ax,(-1-2)(%rdi,%rdx)
  414db9:	66 89 44 17 fd       	mov    WORD PTR [rdi+rdx*1-0x3],ax
	cmp $6,%edx
  414dbe:	83 fa 06             	cmp    edx,0x6
	jbe 1f
  414dc1:	76 55                	jbe    414e18 <memset+0x8c>
--
	mov %eax,(-1-2-4)(%rdi,%rdx)
  414dc6:	89 44 17 f9          	mov    DWORD PTR [rdi+rdx*1-0x7],eax
	cmp $14,%edx
  414dca:	83 fa 0e             	cmp    edx,0xe
	jbe 1f
  414dcd:	76 49                	jbe    414e18 <memset+0x8c>
--
	mov %rax,(-1-2-4-8)(%rdi,%rdx)
  414dd3:	48 89 44 17 f1       	mov    QWORD PTR [rdi+rdx*1-0xf],rax
	cmp $30,%edx
  414dd8:	83 fa 1e             	cmp    edx,0x1e
	jbe 1f
  414ddb:	76 3b                	jbe    414e18 <memset+0x8c>
--
	mov %rax,(-1-2-4-8-8)(%rdi,%rdx)
  414dea:	48 89 44 17 e9       	mov    QWORD PTR [rdi+rdx*1-0x17],rax
	cmp $62,%edx
  414def:	83 fa 3e             	cmp    edx,0x3e
	jbe 1f
  414df2:	76 24                	jbe    414e18 <memset+0x8c>
--
  414e2a:	48 89 d1             	mov    rcx,rdx
	jnz 2f
  414e2d:	75 0b                	jne    414e3a <memset+0xae>

1:	shr $3,%rcx
--
	add %rdx,%rdi
  414e4b:	48 01 d7             	add    rdi,rdx
	jmp 1b
  414e4e:	eb df                	jmp    414e2f <memset+0xa3>

0000000000414e50 <__set_thread_area>:
--
.type __set_thread_area,@function
__set_thread_area:
	mov %rdi,%rsi           /* shift for syscall */
  414e50:	48 89 fe             	mov    rsi,rdi
	movl $0x1002,%edi       /* SET_FS register */
--
	movl $158,%eax          /* set fs segment to */
  414e58:	b8 9e 00 00 00       	mov    eax,0x9e
	syscall                 /* arch_prctl(SET_FS, arg)*/
  414e5d:	0f 05                	syscall 
	ret
  414e5f:	c3                   	ret    
--
0000000000414e80 <_init>:
#include <unistd.h>
#include "syscall.h"
#include "atomic.h"
#include "libc.h"
--
	__environ = envp;
	for (i=0; envp[i]; i++);
  414eed:	48 83 3a 00          	cmp    QWORD PTR [rdx],0x0
	size_t i, *auxv, aux[AUX_CNT] = { 0 };
  414ef1:	4c 8d 44 24 20       	lea    r8,[rsp+0x20]
--
  414f0a:	48 89 10             	mov    QWORD PTR [rax],rdx
	for (i=0; envp[i]; i++);
  414f0d:	0f 84 1d 03 00 00    	je     415230 <__init_libc+0x370>
  414f13:	31 c0                	xor    eax,eax
  414f15:	0f 1f 00             	nop    DWORD PTR [rax]
  414f18:	48 89 c1             	mov    rcx,rax
  414f1b:	48 83 c0 01          	add    rax,0x1
  414f1f:	48 83 3c c2 00       	cmp    QWORD PTR [rdx+rax*8],0x0
  414f24:	75 f2                	jne    414f18 <__init_libc+0x58>
	libc.auxv = auxv = (void *)(envp+i+1);
  414f26:	48 8d 04 cd 10 00 00 	lea    rax,[rcx*8+0x10]
--
  414f43:	48 83 c0 08          	add    rax,0x8
  414f47:	48 85 d2             	test   rdx,rdx
  414f4a:	0f 84 f0 02 00 00    	je     415240 <__init_libc+0x380>
  414f50:	48 83 fa 25          	cmp    rdx,0x25
  414f54:	0f 87 76 01 00 00    	ja     4150d0 <__init_libc+0x210>
  414f5a:	48 8b 08             	mov    rcx,QWORD PTR [rax]
--
  414f66:	48 8b 50 f8          	mov    rdx,QWORD PTR [rax-0x8]
  414f6a:	48 85 d2             	test   rdx,rdx
  414f6d:	75 e1                	jne    414f50 <__init_libc+0x90>
	__hwcap = aux[AT_HWCAP];
  414f6f:	48 8b bc 24 a0 00 00 	mov    rdi,QWORD PTR [rsp+0xa0]
--
	if (aux[AT_SYSINFO]) __sysinfo = aux[AT_SYSINFO];
  414f92:	48 85 c0             	test   rax,rax
  414f95:	74 0e                	je     414fa5 <__init_libc+0xe5>
  414f97:	48 b9 10 4c 14 00 00 	movabs rcx,0x144c10
  414f9e:	00 00 00 
--
	if (!pn) pn = (void*)aux[AT_EXECFN];
  414faa:	48 85 f6             	test   rsi,rsi
  414fad:	0f 84 1d 02 00 00    	je     4151d0 <__init_libc+0x310>
	if (!pn) pn = "";
	__progname = __progname_full = pn;
--
  414fd5:	0f b6 16             	movzx  edx,BYTE PTR [rsi]
  414fd8:	84 d2                	test   dl,dl
  414fda:	74 18                	je     414ff4 <__init_libc+0x134>
  414fdc:	48 8d 46 01          	lea    rax,[rsi+0x1]
  414fe0:	80 fa 2f             	cmp    dl,0x2f
  414fe3:	0f 84 07 01 00 00    	je     4150f0 <__init_libc+0x230>
  414fe9:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  414fec:	48 83 c0 01          	add    rax,0x1
  414ff0:	84 d2                	test   dl,dl
  414ff2:	75 ec                	jne    414fe0 <__init_libc+0x120>

	__init_tls(aux);
--
  414ffe:	4c 89 c7             	mov    rdi,r8
  415001:	4c 01 f8             	add    rax,r15
  415004:	ff d0                	call   rax
	__init_ssp((void *)aux[AT_RANDOM]);
  415006:	48 8b bc 24 e8 00 00 	mov    rdi,QWORD PTR [rsp+0xe8]
--
  415015:	ff ff ff 
  415018:	4c 01 f8             	add    rax,r15
  41501b:	ff d0                	call   rax

	if (aux[AT_UID]==aux[AT_EUID] && aux[AT_GID]==aux[AT_EGID]
  41501d:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  415024:	00 
  415025:	48 39 44 24 78       	cmp    QWORD PTR [rsp+0x78],rax
  41502a:	75 16                	jne    415042 <__init_libc+0x182>
  41502c:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  415033:	00 
  415034:	48 39 84 24 88 00 00 	cmp    QWORD PTR [rsp+0x88],rax
  41503b:	00 
  41503c:	0f 84 d6 01 00 00    	je     415218 <__init_libc+0x358>
		&& !aux[AT_SECURE]) return;

--
	int r =
#ifdef SYS_poll
	__syscall(SYS_poll, pfd, 3, 0);
  415046:	48 89 e6             	mov    rsi,rsp
	return __cos_syscall(n, a1, a2, 0, 0, 0, 0, 0);
}

static __inline long __syscall3(long n, long a1, long a2, long a3)
{
	return __cos_syscall(n, a1, a2, a3, 0, 0, 0, 0);
  415049:	45 31 c9             	xor    r9d,r9d
  41504c:	45 31 c0             	xor    r8d,r8d
--
  415087:	6a 00                	push   0x0
  415089:	6a 00                	push   0x0
  41508b:	ff d0                	call   rax
#else
	__syscall(SYS_ppoll, pfd, 3, &(struct timespec){0}, 0, _NSIG/8);
#endif
	if (r<0) a_crash();
--
	for (i=0; i<3; i++) if (pfd[i].revents&POLLNVAL)
  415096:	f6 44 24 06 20       	test   BYTE PTR [rsp+0x6],0x20
  41509b:	0f 85 ef 00 00 00    	jne    415190 <__init_libc+0x2d0>
  4150a1:	f6 44 24 0e 20       	test   BYTE PTR [rsp+0xe],0x20
  4150a6:	0f 85 a4 00 00 00    	jne    415150 <__init_libc+0x290>
  4150ac:	f6 44 24 16 20       	test   BYTE PTR [rsp+0x16],0x20
  4150b1:	75 5d                	jne    415110 <__init_libc+0x250>
		if (__sys_open("/dev/null", O_RDWR)<0)
			a_crash();
--
  4150d4:	48 83 c0 10          	add    rax,0x10
  4150d8:	48 85 d2             	test   rdx,rdx
  4150db:	0f 85 6f fe ff ff    	jne    414f50 <__init_libc+0x90>
  4150e1:	e9 89 fe ff ff       	jmp    414f6f <__init_libc+0xaf>
  4150e6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4150ed:	00 00 00 
--
  4150fa:	48 83 c0 01          	add    rax,0x1
  4150fe:	84 d2                	test   dl,dl
  415100:	0f 85 da fe ff ff    	jne    414fe0 <__init_libc+0x120>
  415106:	e9 e9 fe ff ff       	jmp    414ff4 <__init_libc+0x134>
  41510b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	return __cos_syscall(n, a1, a2, 0, 0, 0, 0, 0);
  415110:	6a 00                	push   0x0
  415112:	31 c9                	xor    ecx,ecx
--
  415130:	ff ff ff 
  415133:	49 8d 34 07          	lea    rsi,[r15+rax*1]
  415137:	ff d5                	call   rbp
		if (__sys_open("/dev/null", O_RDWR)<0)
  415139:	5a                   	pop    rdx
--
  415144:	f4                   	hlt    
}
  415145:	e9 69 ff ff ff       	jmp    4150b3 <__init_libc+0x1f3>
  41514a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  415150:	6a 00                	push   0x0
--
  415170:	49 8d 34 07          	lea    rsi,[r15+rax*1]
  415174:	4a 8d 44 3d 00       	lea    rax,[rbp+r15*1+0x0]
  415179:	ff d0                	call   rax
  41517b:	5e                   	pop    rsi
  41517c:	5f                   	pop    rdi
--
	__asm__ __volatile__( "hlt" : : : "memory" );
  415186:	f4                   	hlt    
  415187:	e9 20 ff ff ff       	jmp    4150ac <__init_libc+0x1ec>
  41518c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  415190:	6a 00                	push   0x0
--
  4151b0:	49 8d 34 07          	lea    rsi,[r15+rax*1]
  4151b4:	4a 8d 44 3d 00       	lea    rax,[rbp+r15*1+0x0]
  4151b9:	ff d0                	call   rax
  4151bb:	41 58                	pop    r8
  4151bd:	41 59                	pop    r9
--
  4151c2:	0f 89 d9 fe ff ff    	jns    4150a1 <__init_libc+0x1e1>
  4151c8:	f4                   	hlt    
  4151c9:	e9 d3 fe ff ff       	jmp    4150a1 <__init_libc+0x1e1>
  4151ce:	66 90                	xchg   ax,ax
	if (!pn) pn = (void*)aux[AT_EXECFN];
--
	if (!pn) pn = "";
  4151d8:	48 85 c0             	test   rax,rax
  4151db:	75 7a                	jne    415257 <__init_libc+0x397>
	__progname = __progname_full = pn;
  4151dd:	48 b8 f8 ff ff ff ff 	movabs rax,0xfffffffffffffff8
--
  415209:	48 89 02             	mov    QWORD PTR [rdx],rax
	for (i=0; pn[i]; i++) if (pn[i]=='/') __progname = pn+i+1;
  41520c:	e9 e3 fd ff ff       	jmp    414ff4 <__init_libc+0x134>
  415211:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		&& !aux[AT_SECURE]) return;
  415218:	48 83 bc 24 d8 00 00 	cmp    QWORD PTR [rsp+0xd8],0x0
  41521f:	00 00 
  415221:	0f 85 1b fe ff ff    	jne    415042 <__init_libc+0x182>
  415227:	e9 90 fe ff ff       	jmp    4150bc <__init_libc+0x1fc>
  41522c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	for (i=0; envp[i]; i++);
  415230:	b8 08 00 00 00       	mov    eax,0x8
  415235:	e9 f4 fc ff ff       	jmp    414f2e <__init_libc+0x6e>
  41523a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	__hwcap = aux[AT_HWCAP];
--
  415251:	00 
	if (aux[AT_SYSINFO]) __sysinfo = aux[AT_SYSINFO];
  415252:	e9 4e fd ff ff       	jmp    414fa5 <__init_libc+0xe5>
	if (!pn) pn = (void*)aux[AT_EXECFN];
  415257:	48 89 c6             	mov    rsi,rax
  41525a:	e9 54 fd ff ff       	jmp    414fb3 <__init_libc+0xf3>
  41525f:	90                   	nop

--
  415288:	53                   	push   rbx
	_init();
  415289:	ff d0                	call   rax
	uintptr_t a = (uintptr_t)&__init_array_start;
  41528b:	48 b8 f0 ff ff ff ff 	movabs rax,0xfffffffffffffff0
--
  4152a0:	ff ff ff 
  4152a3:	49 8b 2c 07          	mov    rbp,QWORD PTR [r15+rax*1]
  4152a7:	48 39 eb             	cmp    rbx,rbp
  4152aa:	73 0f                	jae    4152bb <__libc_start_init+0x5b>
  4152ac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		(*(void (**)(void))a)();
  4152b0:	ff 13                	call   QWORD PTR [rbx]
	for (; a<(uintptr_t)&__init_array_end; a+=sizeof(void(*)()))
  4152b2:	48 83 c3 08          	add    rbx,0x8
  4152b6:	48 39 eb             	cmp    rbx,rbp
  4152b9:	72 f5                	jb     4152b0 <__libc_start_init+0x50>
}
--
  4152fb:	48 89 fb             	mov    rbx,rdi
	__libc_start_init();
  4152fe:	ff d0                	call   rax

	/* Pass control to the application */
--
  415302:	4c 89 ea             	mov    rdx,r13
  415305:	4c 89 e6             	mov    rsi,r12
  415308:	ff d3                	call   rbx
  41530a:	89 c7                	mov    edi,eax
  41530c:	48 b8 f0 7f fb ff ff 	movabs rax,0xfffffffffffb7ff0
  415313:	ff ff ff 
  415316:	4c 01 f8             	add    rax,r15
  415319:	ff d0                	call   rax
  41531b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

--
	__init_libc(envp, argv[0]);
  415360:	48 8b 32             	mov    rsi,QWORD PTR [rdx]
  415363:	ff d0                	call   rax
	return stage2(main, argc, argv);
  415365:	4c 89 e2             	mov    rdx,r12
--
  415382:	41 5d                	pop    r13
	return stage2(main, argc, argv);
  415384:	ff e0                	jmp    rax
  415386:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41538d:	00 00 00 
--
  4153c1:	ff ff ff 
  4153c4:	49 8b 2c 07          	mov    rbp,QWORD PTR [r15+rax*1]
  4153c8:	48 39 eb             	cmp    rbx,rbp
  4153cb:	76 10                	jbe    4153dd <__libc_exit_fini+0x4d>
  4153cd:	0f 1f 00             	nop    DWORD PTR [rax]
--
  4153d0:	48 83 eb 08          	sub    rbx,0x8
  4153d4:	31 c0                	xor    eax,eax
  4153d6:	ff 13                	call   QWORD PTR [rbx]
	for (; a>(uintptr_t)&__fini_array_start; a-=sizeof(void(*)()))
  4153d8:	48 39 eb             	cmp    rbx,rbp
  4153db:	77 f3                	ja     4153d0 <__libc_exit_fini+0x40>
	_fini();
--
  4153ee:	41 5f                	pop    r15
	_fini();
  4153f0:	ff e2                	jmp    rdx
  4153f2:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4153f9:	00 00 00 
--
  41542a:	48 83 ec 08          	sub    rsp,0x8
	__funcs_on_exit();
  41542e:	ff d0                	call   rax
	__libc_exit_fini();
  415430:	48 b8 80 7f fb ff ff 	movabs rax,0xfffffffffffb7f80
  415437:	ff ff ff 
  41543a:	4c 01 f8             	add    rax,r15
  41543d:	ff d0                	call   rax
	__stdio_exit();
  41543f:	31 c0                	xor    eax,eax
--
  415448:	ff ff ff 
  41544b:	4c 01 fa             	add    rdx,r15
  41544e:	ff d2                	call   rdx
	_Exit(code);
  415450:	89 ef                	mov    edi,ebp
--
  415459:	ff ff ff 
  41545c:	4c 01 f8             	add    rax,r15
  41545f:	ff d0                	call   rax
  415461:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  415468:	00 00 00 
--
	size_t k = MIN(c->n, f->wpos - f->wbase);
  4154b6:	48 29 f2             	sub    rdx,rsi
  4154b9:	48 39 c2             	cmp    rdx,rax
  4154bc:	48 89 d3             	mov    rbx,rdx
  4154bf:	48 0f 47 d8          	cmova  rbx,rax
	if (k) {
  4154c3:	48 85 db             	test   rbx,rbx
  4154c6:	75 38                	jne    415500 <sn_write+0x90>
		c->s += k;
		c->n -= k;
	}
	k = MIN(c->n, l);
  4154c8:	49 39 c4             	cmp    r12,rax
  4154cb:	49 0f 46 c4          	cmovbe rax,r12
  4154cf:	48 89 c3             	mov    rbx,rax
	if (k) {
  4154d2:	48 85 c0             	test   rax,rax
  4154d5:	75 60                	jne    415537 <sn_write+0xc7>
		memcpy(c->s, s, k);
		c->s += k;
--
  41550a:	48 89 da             	mov    rdx,rbx
  41550d:	4c 01 f8             	add    rax,r15
  415510:	ff d0                	call   rax
		c->n -= k;
  415512:	49 8b 45 08          	mov    rax,QWORD PTR [r13+0x8]
--
  41551d:	48 01 df             	add    rdi,rbx
	k = MIN(c->n, l);
  415520:	49 39 c4             	cmp    r12,rax
		c->n -= k;
  415523:	49 89 45 08          	mov    QWORD PTR [r13+0x8],rax
--
	if (k) {
  415532:	48 85 c0             	test   rax,rax
  415535:	74 a0                	je     4154d7 <sn_write+0x67>
		memcpy(c->s, s, k);
  415537:	48 89 c2             	mov    rdx,rax
--
  415544:	ff ff ff 
  415547:	4c 01 f8             	add    rax,r15
  41554a:	ff d0                	call   rax
		c->s += k;
  41554c:	49 8b 7d 00          	mov    rdi,QWORD PTR [r13+0x0]
--
  415557:	49 89 7d 00          	mov    QWORD PTR [r13+0x0],rdi
		c->n -= k;
  41555b:	e9 77 ff ff ff       	jmp    4154d7 <sn_write+0x67>

0000000000415560 <vsnprintf>:
--
	struct cookie c = { .s = n ? s : dummy, .n = n ? n-1 : 0 };
  41558a:	4d 85 d2             	test   r10,r10
  41558d:	0f 85 8d 00 00 00    	jne    415620 <vsnprintf+0xc0>
	FILE f = {
  415593:	4c 8d 4c 24 20       	lea    r9,[rsp+0x20]
--
  415606:	4c 89 cf             	mov    rdi,r9
  415609:	4c 01 f8             	add    rax,r15
  41560c:	ff d0                	call   rax
}
  41560e:	48 81 c4 10 01 00 00 	add    rsp,0x110
--
  415681:	00 
	if (n > INT_MAX) {
  415682:	49 81 fa ff ff ff 7f 	cmp    r10,0x7fffffff
  415689:	0f 86 69 ff ff ff    	jbe    4155f8 <vsnprintf+0x98>
		errno = EOVERFLOW;
--
  415696:	ff ff ff 
  415699:	4c 01 f8             	add    rax,r15
  41569c:	ff d0                	call   rax
  41569e:	c7 00 4b 00 00 00    	mov    DWORD PTR [rax],0x4b
		return -1;
  4156a4:	b8 ff ff ff ff       	mov    eax,0xffffffff
  4156a9:	e9 60 ff ff ff       	jmp    41560e <vsnprintf+0xae>
  4156ae:	66 90                	xchg   ax,ax

--
	int n=0, neg=0;
	while (isspace(*s)) s++;
  4156b4:	eb 0e                	jmp    4156c4 <atoi+0x14>
  4156b6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4156bd:	00 00 00 
--
  4156c7:	8d 48 f7             	lea    ecx,[rax-0x9]
  4156ca:	89 c2                	mov    edx,eax
  4156cc:	83 f9 04             	cmp    ecx,0x4
  4156cf:	76 ef                	jbe    4156c0 <atoi+0x10>
  4156d1:	80 fa 20             	cmp    dl,0x20
  4156d4:	74 ea                	je     4156c0 <atoi+0x10>
	switch (*s) {
  4156d6:	80 fa 2b             	cmp    dl,0x2b
  4156d9:	74 4d                	je     415728 <atoi+0x78>
  4156db:	80 fa 2d             	cmp    dl,0x2d
  4156de:	74 68                	je     415748 <atoi+0x98>
	case '-': neg=1;
	case '+': s++;
--
  4156e6:	45 31 c9             	xor    r9d,r9d
	while (isdigit(*s))
  4156e9:	83 fa 09             	cmp    edx,0x9
  4156ec:	77 4d                	ja     41573b <atoi+0x8b>
	int n=0, neg=0;
--
  41570e:	41 29 f0             	sub    r8d,esi
	while (isdigit(*s))
  415711:	83 ff 09             	cmp    edi,0x9
  415714:	76 e2                	jbe    4156f8 <atoi+0x48>
	return neg ? n : -n;
--
	while (isdigit(*s))
  415733:	8d 50 d0             	lea    edx,[rax-0x30]
  415736:	83 fa 09             	cmp    edx,0x9
  415739:	76 b3                	jbe    4156ee <atoi+0x3e>
  41573b:	45 31 c0             	xor    r8d,r8d
--
	while (isdigit(*s))
  415750:	8d 50 d0             	lea    edx,[rax-0x30]
  415753:	83 fa 09             	cmp    edx,0x9
  415756:	77 e3                	ja     41573b <atoi+0x8b>
	case '-': neg=1;
  415758:	41 b9 01 00 00 00    	mov    r9d,0x1
  41575e:	eb 8e                	jmp    4156ee <atoi+0x3e>

0000000000415760 <atol>:
--
	int neg=0;
	while (isspace(*s)) s++;
  415764:	eb 0e                	jmp    415774 <atol+0x14>
  415766:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41576d:	00 00 00 
--
  415777:	8d 48 f7             	lea    ecx,[rax-0x9]
  41577a:	89 c2                	mov    edx,eax
  41577c:	83 f9 04             	cmp    ecx,0x4
  41577f:	76 ef                	jbe    415770 <atol+0x10>
  415781:	80 fa 20             	cmp    dl,0x20
  415784:	74 ea                	je     415770 <atol+0x10>
	switch (*s) {
  415786:	80 fa 2b             	cmp    dl,0x2b
  415789:	74 55                	je     4157e0 <atol+0x80>
  41578b:	80 fa 2d             	cmp    dl,0x2d
  41578e:	74 70                	je     415800 <atol+0xa0>
	case '-': neg=1;
	case '+': s++;
--
  415796:	45 31 c9             	xor    r9d,r9d
	while (isdigit(*s))
  415799:	83 fa 09             	cmp    edx,0x9
  41579c:	77 55                	ja     4157f3 <atol+0x93>
	int neg=0;
--
  4157c2:	49 29 f0             	sub    r8,rsi
	while (isdigit(*s))
  4157c5:	83 ff 09             	cmp    edi,0x9
  4157c8:	76 de                	jbe    4157a8 <atol+0x48>
	return neg ? n : -n;
--
	while (isdigit(*s))
  4157eb:	8d 50 d0             	lea    edx,[rax-0x30]
  4157ee:	83 fa 09             	cmp    edx,0x9
  4157f1:	76 ab                	jbe    41579e <atol+0x3e>
  4157f3:	45 31 c0             	xor    r8d,r8d
--
	while (isdigit(*s))
  415808:	8d 50 d0             	lea    edx,[rax-0x30]
  41580b:	83 fa 09             	cmp    edx,0x9
  41580e:	77 e3                	ja     4157f3 <atol+0x93>
	case '-': neg=1;
  415810:	41 b9 01 00 00 00    	mov    r9d,0x1
  415816:	eb 86                	jmp    41579e <atol+0x3e>
  415818:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41581f:	00 
--
  415842:	4c 01 d8             	add    rax,r11
  415845:	48 01 d0             	add    rax,rdx
  415848:	ff d0                	call   rax
	return *(unsigned char *)r == (unsigned char)c ? r : 0;
  41584a:	31 d2                	xor    edx,edx
  41584c:	38 18                	cmp    BYTE PTR [rax],bl
}
  41584e:	5b                   	pop    rbx
--
	if (!c) return (char *)s + strlen(s);
  415885:	81 e1 ff 00 00 00    	and    ecx,0xff
  41588b:	75 24                	jne    4158b1 <__strchrnul+0x51>
  41588d:	e9 d6 00 00 00       	jmp    415968 <__strchrnul+0x108>
  415892:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

--
  415898:	41 0f b6 04 24       	movzx  eax,BYTE PTR [r12]
  41589d:	84 c0                	test   al,al
  41589f:	0f 84 b4 00 00 00    	je     415959 <__strchrnul+0xf9>
  4158a5:	39 c8                	cmp    eax,ecx
  4158a7:	0f 84 ac 00 00 00    	je     415959 <__strchrnul+0xf9>
	for (; (uintptr_t)s % ALIGN; s++)
  4158ad:	49 83 c4 01          	add    r12,0x1
  4158b1:	41 f6 c4 07          	test   r12b,0x7
  4158b5:	75 e1                	jne    415898 <__strchrnul+0x38>
	size_t k = ONES * c;
  4158b7:	48 bf 01 01 01 01 01 	movabs rdi,0x101010101010101
--
  4158f4:	48 09 d0             	or     rax,rdx
  4158f7:	4c 85 c8             	test   rax,r9
  4158fa:	75 54                	jne    415950 <__strchrnul+0xf0>
  4158fc:	48 bf ff fe fe fe fe 	movabs rdi,0xfefefefefefefeff
  415903:	fe fe fe 
--
  415933:	48 09 d0             	or     rax,rdx
  415936:	4c 85 c8             	test   rax,r9
  415939:	74 d5                	je     415910 <__strchrnul+0xb0>
	s = (void *)w;
#endif
--
  41593b:	41 0f b6 04 24       	movzx  eax,BYTE PTR [r12]
  415940:	84 c0                	test   al,al
  415942:	74 15                	je     415959 <__strchrnul+0xf9>
  415944:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  415948:	39 c8                	cmp    eax,ecx
  41594a:	74 0d                	je     415959 <__strchrnul+0xf9>
  41594c:	49 83 c4 01          	add    r12,0x1
  415950:	41 0f b6 04 24       	movzx  eax,BYTE PTR [r12]
  415955:	84 c0                	test   al,al
  415957:	75 ef                	jne    415948 <__strchrnul+0xe8>
	return (char *)s;
}
--
  41596f:	ff ff ff 
  415972:	4c 01 f8             	add    rax,r15
  415975:	ff d0                	call   rax
}
  415977:	48 83 c4 08          	add    rsp,0x8
--
  41598d:	00 00 00 

0000000000415990 <strcmp>:
#include <string.h>

int strcmp(const char *l, const char *r)
{
  415990:	f3 0f 1e fa          	endbr64 
--
  415997:	0f b6 0e             	movzx  ecx,BYTE PTR [rsi]
  41599a:	b8 01 00 00 00       	mov    eax,0x1
  41599f:	38 d1                	cmp    cl,dl
  4159a1:	74 16                	je     4159b9 <strcmp+0x29>
  4159a3:	eb 23                	jmp    4159c8 <strcmp+0x38>
  4159a5:	0f 1f 00             	nop    DWORD PTR [rax]
  4159a8:	0f b6 14 07          	movzx  edx,BYTE PTR [rdi+rax*1]
  4159ac:	48 83 c0 01          	add    rax,0x1
  4159b0:	0f b6 4c 06 ff       	movzx  ecx,BYTE PTR [rsi+rax*1-0x1]
  4159b5:	38 ca                	cmp    dl,cl
  4159b7:	75 0f                	jne    4159c8 <strcmp+0x38>
  4159b9:	84 d2                	test   dl,dl
  4159bb:	75 eb                	jne    4159a8 <strcmp+0x18>
  4159bd:	31 c0                	xor    eax,eax
	return *(unsigned char *)l - *(unsigned char *)r;
--
  4159d4:	48 89 f8             	mov    rax,rdi
  4159d7:	40 f6 c7 07          	test   dil,0x7
  4159db:	75 0b                	jne    4159e8 <strlen+0x18>
  4159dd:	eb 19                	jmp    4159f8 <strlen+0x28>
  4159df:	90                   	nop
  4159e0:	48 83 c0 01          	add    rax,0x1
  4159e4:	a8 07                	test   al,0x7
  4159e6:	74 10                	je     4159f8 <strlen+0x28>
  4159e8:	80 38 00             	cmp    BYTE PTR [rax],0x0
  4159eb:	75 f3                	jne    4159e0 <strlen+0x10>
	for (w = (const void *)s; !HASZERO(*w); w++);
	s = (const void *)w;
--
  415a16:	48 21 ca             	and    rdx,rcx
  415a19:	48 85 f2             	test   rdx,rsi
  415a1c:	75 26                	jne    415a44 <strlen+0x74>
  415a1e:	66 90                	xchg   ax,ax
  415a20:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
--
  415a2f:	48 21 ca             	and    rdx,rcx
  415a32:	48 85 f2             	test   rdx,rsi
  415a35:	74 e9                	je     415a20 <strlen+0x50>
  415a37:	eb 0b                	jmp    415a44 <strlen+0x74>
  415a39:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (; *s; s++);
  415a40:	48 83 c0 01          	add    rax,0x1
  415a44:	80 38 00             	cmp    BYTE PTR [rax],0x0
  415a47:	75 f7                	jne    415a40 <strlen+0x70>
	return s-a;
  415a49:	48 29 f8             	sub    rax,rdi
--
  415a4d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000415a50 <strncmp>:
#include <string.h>

int strncmp(const char *_l, const char *_r, size_t n)
{
  415a50:	f3 0f 1e fa          	endbr64 
--
  415a5a:	31 c0                	xor    eax,eax
  415a5c:	48 85 d2             	test   rdx,rdx
  415a5f:	74 60                	je     415ac1 <strncmp+0x71>
	for (; *l && *r && n && *l == *r ; l++, r++, n--);
  415a61:	0f b6 07             	movzx  eax,BYTE PTR [rdi]
  415a64:	0f b6 3e             	movzx  edi,BYTE PTR [rsi]
  415a67:	84 c0                	test   al,al
  415a69:	74 5d                	je     415ac8 <strncmp+0x78>
  415a6b:	48 83 ea 01          	sub    rdx,0x1
  415a6f:	40 0f 95 c6          	setne  sil
--
  415a76:	0f 95 c1             	setne  cl
  415a79:	40 84 ce             	test   sil,cl
  415a7c:	74 41                	je     415abf <strncmp+0x6f>
  415a7e:	b9 01 00 00 00       	mov    ecx,0x1
  415a83:	40 38 f8             	cmp    al,dil
  415a86:	75 37                	jne    415abf <strncmp+0x6f>
  415a88:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  415a8f:	00 
--
  415a95:	41 0f b6 3c 0a       	movzx  edi,BYTE PTR [r10+rcx*1]
  415a9a:	84 c0                	test   al,al
  415a9c:	74 2a                	je     415ac8 <strncmp+0x78>
  415a9e:	40 84 ff             	test   dil,dil
  415aa1:	40 0f 95 c6          	setne  sil
  415aa5:	40 38 f8             	cmp    al,dil
  415aa8:	41 0f 94 c0          	sete   r8b
  415aac:	44 21 c6             	and    esi,r8d
  415aaf:	48 39 ca             	cmp    rdx,rcx
  415ab2:	41 0f 95 c0          	setne  r8b
  415ab6:	48 83 c1 01          	add    rcx,0x1
  415aba:	44 84 c6             	test   sil,r8b
  415abd:	75 d1                	jne    415a90 <strncmp+0x40>
	return *l - *r;
  415abf:	29 f8                	sub    eax,edi
--
	return *l - *r;
  415aca:	29 f8                	sub    eax,edi
  415acc:	eb f3                	jmp    415ac1 <strncmp+0x71>
  415ace:	66 90                	xchg   ax,ax

--
	const char *p = memchr(s, 0, n);
  415b02:	31 f6                	xor    esi,esi
  415b04:	ff d0                	call   rax
	return p ? p-s : n;
  415b06:	48 89 c2             	mov    rdx,rax
--

0000000000415b20 <__init_tp>:
#include "syscall.h"

volatile int __thread_list_lock;
--
  415b5b:	0f 29 04 24          	movaps XMMWORD PTR [rsp],xmm0
	int r = __set_thread_area(TP_ADJ(p));
  415b5f:	ff d0                	call   rax
	if (r < 0) return -1;
  415b61:	85 c0                	test   eax,eax
  415b63:	0f 88 a6 00 00 00    	js     415c0f <__init_tp+0xef>
	if (!r) libc.can_do_threads = 1;
  415b69:	0f 84 89 00 00 00    	je     415bf8 <__init_tp+0xd8>
	return __cos_syscall(n, a1, 0, 0, 0, 0, 0, 0);
  415b6f:	48 b8 58 4e 14 00 00 	movabs rax,0x144e58
  415b76:	00 00 00 
--
  415b9c:	bf da 00 00 00       	mov    edi,0xda
  415ba1:	4c 01 f8             	add    rax,r15
  415ba4:	ff d0                	call   rax
	td->tid = __syscall(SYS_set_tid_address, &__thread_list_lock);
	td->locale = &libc.global_locale;
	td->robust_list.head = &td->robust_list.head;
--
	td->next = td->prev = td;
  415ba6:	66 0f 6f 4c 24 10    	movdqa xmm1,XMMWORD PTR [rsp+0x10]
	td->tid = __syscall(SYS_set_tid_address, &__thread_list_lock);
  415bac:	89 43 38             	mov    DWORD PTR [rbx+0x38],eax
	td->locale = &libc.global_locale;
--
  415c02:	41 c7 04 07 01 00 00 	mov    DWORD PTR [r15+rax*1],0x1
  415c09:	00 
  415c0a:	e9 60 ff ff ff       	jmp    415b6f <__init_tp+0x4f>
	if (r < 0) return -1;
  415c0f:	b8 ff ff ff ff       	mov    eax,0xffffffff
  415c14:	eb d5                	jmp    415beb <__init_tp+0xcb>
  415c16:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  415c1d:	00 00 00 
--
	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
  415c75:	48 85 db             	test   rbx,rbx
  415c78:	74 3f                	je     415cb9 <__copy_tls+0x99>
  415c7a:	49 bc 4a 79 fb ff ff 	movabs r12,0xfffffffffffb794a
  415c81:	ff ff ff 
--
		memcpy(mem - p->offset, p->image, p->len);
  415caa:	48 2b 7b 28          	sub    rdi,QWORD PTR [rbx+0x28]
  415cae:	41 ff d4             	call   r12
	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
  415cb1:	48 8b 1b             	mov    rbx,QWORD PTR [rbx]
  415cb4:	48 85 db             	test   rbx,rbx
  415cb7:	75 d7                	jne    415c90 <__copy_tls+0x70>
	}
#endif
--
  415d1a:	4c 8b 5f 18          	mov    r11,QWORD PTR [rdi+0x18]
  415d1e:	4d 85 c0             	test   r8,r8
  415d21:	0f 84 a9 03 00 00    	je     4160d0 <__init_tls+0x3e0>
  415d27:	31 ed                	xor    ebp,ebp
	size_t base = 0;
--
  415d3f:	48 bb b8 ec ff ff ff 	movabs rbx,0xffffffffffffecb8
  415d46:	ff ff ff 
  415d49:	4b 83 3c 3c 00       	cmp    QWORD PTR [r12+r15*1],0x0
  415d4e:	46 8b 0c 3b          	mov    r9d,DWORD PTR [rbx+r15*1]
  415d52:	75 2a                	jne    415d7e <__init_tls+0x8e>
  415d54:	e9 61 02 00 00       	jmp    415fba <__init_tls+0x2ca>
  415d59:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		phdr = (void *)p;
--
			base = aux[AT_PHDR] - phdr->p_vaddr;
		if (phdr->p_type == PT_DYNAMIC && _DYNAMIC)
  415d60:	83 f9 02             	cmp    ecx,0x2
  415d63:	0f 84 97 02 00 00    	je     416000 <__init_tls+0x310>
			base = (size_t)_DYNAMIC - phdr->p_vaddr;
		if (phdr->p_type == PT_TLS)
  415d69:	83 f9 07             	cmp    ecx,0x7
  415d6c:	0f 85 58 02 00 00    	jne    415fca <__init_tls+0x2da>
  415d72:	49 89 c2             	mov    r10,rax
	for (p=(void *)aux[AT_PHDR],n=aux[AT_PHNUM]; n; n--,p+=aux[AT_PHENT]) {
  415d75:	48 01 f8             	add    rax,rdi
  415d78:	49 83 e8 01          	sub    r8,0x1
  415d7c:	74 17                	je     415d95 <__init_tls+0xa5>
		if (phdr->p_type == PT_PHDR)
  415d7e:	8b 08                	mov    ecx,DWORD PTR [rax]
  415d80:	83 f9 06             	cmp    ecx,0x6
  415d83:	75 db                	jne    415d60 <__init_tls+0x70>
			base = aux[AT_PHDR] - phdr->p_vaddr;
  415d85:	4c 89 da             	mov    rdx,r11
--
  415d8c:	48 01 f8             	add    rax,rdi
  415d8f:	49 83 e8 01          	sub    r8,0x1
  415d93:	75 e9                	jne    415d7e <__init_tls+0x8e>
  415d95:	40 84 ed             	test   bpl,bpl
  415d98:	74 04                	je     415d9e <__init_tls+0xae>
  415d9a:	46 89 0c 3b          	mov    DWORD PTR [rbx+r15*1],r9d
			__default_stacksize =
--
	if (tls_phdr) {
  415d9e:	4d 85 d2             	test   r10,r10
  415da1:	0f 84 29 03 00 00    	je     4160d0 <__init_tls+0x3e0>
		main_tls.image = (void *)(base + tls_phdr->p_vaddr);
  415da7:	48 b8 b0 4c 14 00 00 	movabs rax,0x144cb0
--
#endif
	if (main_tls.align < MIN_TLS_ALIGN) main_tls.align = MIN_TLS_ALIGN;
  415e09:	48 83 fe 07          	cmp    rsi,0x7
  415e0d:	0f 86 2d 02 00 00    	jbe    416040 <__init_tls+0x350>
  415e13:	48 8d 86 f7 00 00 00 	lea    rax,[rsi+0xf7]
--
		/* -4095...-1 cast to void * will crash on dereference anyway,
		 * so don't bloat the init code checking for error codes and
		 * explicitly calling a_crash(). */
	} else {
		mem = builtin_tls;
--
  415e41:	43 0f 11 44 3d 20    	movups XMMWORD PTR [r13+r15*1+0x20],xmm0
	if (libc.tls_size > sizeof builtin_tls) {
  415e47:	48 81 fa 68 01 00 00 	cmp    rdx,0x168
  415e4e:	0f 87 2c 02 00 00    	ja     416080 <__init_tls+0x390>
	mem += libc.tls_size - sizeof(struct pthread);
--
	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
  415e9e:	48 85 db             	test   rbx,rbx
  415ea1:	74 2d                	je     415ed0 <__init_tls+0x1e0>
  415ea3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		dtv[i] = (uintptr_t)(mem - p->offset) + DTP_OFFSET;
--
		memcpy(mem - p->offset, p->image, p->len);
  415ec2:	48 2b 7b 28          	sub    rdi,QWORD PTR [rbx+0x28]
  415ec6:	ff d5                	call   rbp
	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
  415ec8:	48 8b 1b             	mov    rbx,QWORD PTR [rbx]
  415ecb:	48 85 db             	test   rbx,rbx
  415ece:	75 d8                	jne    415ea8 <__init_tls+0x1b8>
	dtv[0] = libc.tls_cnt;
  415ed0:	4b 8b 44 3d 30       	mov    rax,QWORD PTR [r13+r15*1+0x30]
--
  415efa:	41 0f 11 26          	movups XMMWORD PTR [r14],xmm4
	int r = __set_thread_area(TP_ADJ(p));
  415efe:	ff d0                	call   rax
	if (r < 0) return -1;
  415f00:	85 c0                	test   eax,eax
  415f02:	0f 88 66 01 00 00    	js     41606e <__init_tls+0x37e>
	if (!r) libc.can_do_threads = 1;
  415f08:	0f 84 52 01 00 00    	je     416060 <__init_tls+0x370>
	td->detach_state = DT_JOINABLE;
  415f0e:	41 c7 46 40 01 00 00 	mov    DWORD PTR [r14+0x40],0x1
--
  415f3e:	ff ff ff 
  415f41:	4c 01 f8             	add    rax,r15
  415f44:	ff d0                	call   rax
	td->next = td->prev = td;
  415f46:	66 0f 6f 6c 24 30    	movdqa xmm5,XMMWORD PTR [rsp+0x30]
	td->tid = __syscall(SYS_set_tid_address, &__thread_list_lock);
  415f4c:	41 89 46 38          	mov    DWORD PTR [r14+0x38],eax
	td->locale = &libc.global_locale;
--
  415f9a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
		if (phdr->p_type == PT_DYNAMIC && _DYNAMIC)
  415fa0:	83 f9 02             	cmp    ecx,0x2
  415fa3:	74 08                	je     415fad <__init_tls+0x2bd>
		if (phdr->p_type == PT_TLS)
  415fa5:	83 f9 07             	cmp    ecx,0x7
  415fa8:	75 63                	jne    41600d <__init_tls+0x31d>
  415faa:	49 89 c2             	mov    r10,rax
	for (p=(void *)aux[AT_PHDR],n=aux[AT_PHNUM]; n; n--,p+=aux[AT_PHENT]) {
  415fad:	48 01 f8             	add    rax,rdi
  415fb0:	49 83 e8 01          	sub    r8,0x1
  415fb4:	0f 84 db fd ff ff    	je     415d95 <__init_tls+0xa5>
		if (phdr->p_type == PT_PHDR)
  415fba:	8b 08                	mov    ecx,DWORD PTR [rax]
  415fbc:	83 f9 06             	cmp    ecx,0x6
  415fbf:	75 df                	jne    415fa0 <__init_tls+0x2b0>
			base = aux[AT_PHDR] - phdr->p_vaddr;
  415fc1:	4c 89 da             	mov    rdx,r11
  415fc4:	48 2b 50 10          	sub    rdx,QWORD PTR [rax+0x10]
		if (phdr->p_type == PT_GNU_STACK &&
  415fc8:	eb e3                	jmp    415fad <__init_tls+0x2bd>
  415fca:	81 f9 51 e5 74 64    	cmp    ecx,0x6474e551
  415fd0:	0f 85 9f fd ff ff    	jne    415d75 <__init_tls+0x85>
		    phdr->p_memsz > __default_stacksize)
  415fd6:	48 8b 48 28          	mov    rcx,QWORD PTR [rax+0x28]
  415fda:	44 89 ce             	mov    esi,r9d
		if (phdr->p_type == PT_GNU_STACK &&
  415fdd:	48 39 f1             	cmp    rcx,rsi
  415fe0:	0f 86 8f fd ff ff    	jbe    415d75 <__init_tls+0x85>
			__default_stacksize =
  415fe6:	41 b9 00 00 80 00    	mov    r9d,0x800000
  415fec:	bd 01 00 00 00       	mov    ebp,0x1
  415ff1:	4c 39 c9             	cmp    rcx,r9
  415ff4:	4c 0f 46 c9          	cmovbe r9,rcx
  415ff8:	e9 78 fd ff ff       	jmp    415d75 <__init_tls+0x85>
  415ffd:	0f 1f 00             	nop    DWORD PTR [rax]
			base = (size_t)_DYNAMIC - phdr->p_vaddr;
--
  416004:	48 2b 50 10          	sub    rdx,QWORD PTR [rax+0x10]
		if (phdr->p_type == PT_GNU_STACK &&
  416008:	e9 68 fd ff ff       	jmp    415d75 <__init_tls+0x85>
  41600d:	81 f9 51 e5 74 64    	cmp    ecx,0x6474e551
  416013:	75 98                	jne    415fad <__init_tls+0x2bd>
		    phdr->p_memsz > __default_stacksize)
  416015:	48 8b 48 28          	mov    rcx,QWORD PTR [rax+0x28]
  416019:	44 89 ce             	mov    esi,r9d
		if (phdr->p_type == PT_GNU_STACK &&
  41601c:	48 39 ce             	cmp    rsi,rcx
  41601f:	73 8c                	jae    415fad <__init_tls+0x2bd>
			__default_stacksize =
  416021:	41 b9 00 00 80 00    	mov    r9d,0x800000
  416027:	bd 01 00 00 00       	mov    ebp,0x1
  41602c:	4c 39 c9             	cmp    rcx,r9
  41602f:	4c 0f 46 c9          	cmovbe r9,rcx
  416033:	e9 75 ff ff ff       	jmp    415fad <__init_tls+0x2bd>
  416038:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41603f:	00 
--
  41604e:	b8 ff 00 00 00       	mov    eax,0xff
  416053:	be 08 00 00 00       	mov    esi,0x8
  416058:	e9 bd fd ff ff       	jmp    415e1a <__init_tls+0x12a>
  41605d:	0f 1f 00             	nop    DWORD PTR [rax]
	if (!r) libc.can_do_threads = 1;
  416060:	43 c7 44 3d 00 01 00 	mov    DWORD PTR [r13+r15*1+0x0],0x1
  416067:	00 00 
  416069:	e9 a0 fe ff ff       	jmp    415f0e <__init_tls+0x21e>
  41606e:	f4                   	hlt    
}
--
  41607d:	c3                   	ret    
  41607e:	66 90                	xchg   ax,ax
	return __cos_syscall(n, a1, a2, a3, a4, a5, 0, 0);
}

static __inline long __syscall6(long n, long a1, long a2, long a3, long a4, long a5, long a6)
{
	return __cos_syscall(n, a1, a2, a3, a4, a5, a6, 0);
  416080:	6a 00                	push   0x0
  416082:	b9 03 00 00 00       	mov    ecx,0x3
--
  4160a1:	41 b8 22 00 00 00    	mov    r8d,0x22
  4160a7:	4c 01 f8             	add    rax,r15
  4160aa:	ff d0                	call   rax
	mem += libc.tls_size - sizeof(struct pthread);
  4160ac:	4b 8b 54 3d 20       	mov    rdx,QWORD PTR [r13+r15*1+0x20]
--
  4160bc:	5f                   	pop    rdi
  4160bd:	48 8d 48 ff          	lea    rcx,[rax-0x1]
  4160c1:	e9 8e fd ff ff       	jmp    415e54 <__init_tls+0x164>
  4160c6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4160cd:	00 00 00 
--
		& (main_tls.align-1);
  4160ee:	4a 8b 74 38 20       	mov    rsi,QWORD PTR [rax+r15*1+0x20]
  4160f3:	e9 f7 fc ff ff       	jmp    415def <__init_tls+0xff>
  4160f8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4160ff:	00 
--
0000000000416130 <_Exit>:
#include <stdlib.h>
#include "syscall.h"

_Noreturn void _Exit(int ec)
--
  416134:	41 57                	push   r15
  416136:	4c 8d 3d f7 ff ff ff 	lea    r15,[rip+0xfffffffffffffff7]        # 416134 <_Exit+0x4>
	return __cos_syscall(n, a1, 0, 0, 0, 0, 0, 0);
  41613d:	31 c9                	xor    ecx,ecx
  41613f:	45 31 c9             	xor    r9d,r9d
--
  416149:	00 00 00 
  41614c:	55                   	push   rbp
	__syscall(SYS_exit_group, ec);
  41614d:	48 63 ef             	movsxd rbp,edi
  416150:	45 31 c0             	xor    r8d,r8d
--
  41616d:	6a 00                	push   0x0
  41616f:	4c 01 fb             	add    rbx,r15
  416172:	ff d3                	call   rbx
  416174:	59                   	pop    rcx
  416175:	5e                   	pop    rsi
--
  41618e:	48 89 ee             	mov    rsi,rbp
  416191:	bf 3c 00 00 00       	mov    edi,0x3c
  416196:	ff d3                	call   rbx
  416198:	58                   	pop    rax
  416199:	5a                   	pop    rdx
  41619a:	eb e4                	jmp    416180 <_Exit+0x50>
  41619c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

--
  4161a7:	48 89 d0             	mov    rax,rdx
	switch (type) {
  4161aa:	83 fe 11             	cmp    esi,0x11
  4161ad:	77 49                	ja     4161f8 <pop_arg+0x58>
  4161af:	48 8d 15 1a 90 00 00 	lea    rdx,[rip+0x901a]        # 41f1d0 <CSWTCH.186+0x760>
  4161b6:	48 03 14 f2          	add    rdx,QWORD PTR [rdx+rsi*8]
  4161ba:	3e ff e2             	notrack jmp rdx
  4161bd:	0f 1f 00             	nop    DWORD PTR [rax]
	break; case LLONG:	arg->i = va_arg(*ap, long long);
--
	break; case UIPTR:	arg->i = (uintptr_t)va_arg(*ap, void *);
  4161c0:	8b 10                	mov    edx,DWORD PTR [rax]
  4161c2:	83 fa 2f             	cmp    edx,0x2f
  4161c5:	77 39                	ja     416200 <pop_arg+0x60>
  4161c7:	89 d1                	mov    ecx,edx
--
	break; case USHORT:	arg->i = (unsigned short)va_arg(*ap, int);
  416218:	8b 10                	mov    edx,DWORD PTR [rax]
  41621a:	83 fa 2f             	cmp    edx,0x2f
  41621d:	0f 87 55 01 00 00    	ja     416378 <pop_arg+0x1d8>
  416223:	89 d1                	mov    ecx,edx
--
	break; case DBL:	arg->f = va_arg(*ap, double);
  416238:	8b 50 04             	mov    edx,DWORD PTR [rax+0x4]
  41623b:	81 fa af 00 00 00    	cmp    edx,0xaf
  416241:	0f 87 19 01 00 00    	ja     416360 <pop_arg+0x1c0>
  416247:	89 d1                	mov    ecx,edx
--
	break; case INT:	arg->i = va_arg(*ap, int);
  416260:	8b 10                	mov    edx,DWORD PTR [rax]
  416262:	83 fa 2f             	cmp    edx,0x2f
  416265:	0f 87 dd 00 00 00    	ja     416348 <pop_arg+0x1a8>
  41626b:	89 d1                	mov    ecx,edx
--
  41627d:	0f 1f 00             	nop    DWORD PTR [rax]
  416280:	8b 10                	mov    edx,DWORD PTR [rax]
  416282:	83 fa 2f             	cmp    edx,0x2f
  416285:	0f 87 a5 00 00 00    	ja     416330 <pop_arg+0x190>
  41628b:	89 d1                	mov    ecx,edx
--
	break; case UCHAR:	arg->i = (unsigned char)va_arg(*ap, int);
  4162a0:	8b 10                	mov    edx,DWORD PTR [rax]
  4162a2:	83 fa 2f             	cmp    edx,0x2f
  4162a5:	77 79                	ja     416320 <pop_arg+0x180>
  4162a7:	89 d1                	mov    ecx,edx
--
	break; case CHAR:	arg->i = (signed char)va_arg(*ap, int);
  4162c0:	8b 10                	mov    edx,DWORD PTR [rax]
  4162c2:	83 fa 2f             	cmp    edx,0x2f
  4162c5:	77 49                	ja     416310 <pop_arg+0x170>
  4162c7:	89 d1                	mov    ecx,edx
--
	break; case SHORT:	arg->i = (short)va_arg(*ap, int);
  4162e0:	8b 10                	mov    edx,DWORD PTR [rax]
  4162e2:	83 fa 2f             	cmp    edx,0x2f
  4162e5:	77 19                	ja     416300 <pop_arg+0x160>
  4162e7:	89 d1                	mov    ecx,edx
--
  416304:	48 8d 51 08          	lea    rdx,[rcx+0x8]
  416308:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  41630c:	eb e4                	jmp    4162f2 <pop_arg+0x152>
  41630e:	66 90                	xchg   ax,ax
	break; case CHAR:	arg->i = (signed char)va_arg(*ap, int);
--
  416314:	48 8d 51 08          	lea    rdx,[rcx+0x8]
  416318:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  41631c:	eb b4                	jmp    4162d2 <pop_arg+0x132>
  41631e:	66 90                	xchg   ax,ax
	break; case UCHAR:	arg->i = (unsigned char)va_arg(*ap, int);
--
  416324:	48 8d 51 08          	lea    rdx,[rcx+0x8]
  416328:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  41632c:	eb 84                	jmp    4162b2 <pop_arg+0x112>
  41632e:	66 90                	xchg   ax,ax
	break; case UINT:	arg->i = va_arg(*ap, unsigned int);
--
  416334:	48 8d 51 08          	lea    rdx,[rcx+0x8]
  416338:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  41633c:	e9 55 ff ff ff       	jmp    416296 <pop_arg+0xf6>
  416341:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	break; case INT:	arg->i = va_arg(*ap, int);
--
  41634c:	48 8d 51 08          	lea    rdx,[rcx+0x8]
  416350:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  416354:	e9 1d ff ff ff       	jmp    416276 <pop_arg+0xd6>
  416359:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	break; case DBL:	arg->f = va_arg(*ap, double);
--
  416364:	48 8d 51 08          	lea    rdx,[rcx+0x8]
  416368:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  41636c:	e9 e2 fe ff ff       	jmp    416253 <pop_arg+0xb3>
  416371:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	break; case USHORT:	arg->i = (unsigned short)va_arg(*ap, int);
--
  41637c:	48 8d 51 08          	lea    rdx,[rcx+0x8]
  416380:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  416384:	e9 a5 fe ff ff       	jmp    41622e <pop_arg+0x8e>

0000000000416389 <fmt_fp.cold>:
--
	for (; l >= sizeof pad; l -= sizeof pad)
  4163ee:	66 0f fe ca          	paddd  xmm1,xmm2
  4163f2:	44 39 c1             	cmp    ecx,r8d
  4163f5:	77 e9                	ja     4163e0 <fmt_fp.cold+0x57>
  4163f7:	44 89 c8             	mov    eax,r9d
--
  416402:	66 0f 7e c1          	movd   ecx,xmm0
  416406:	69 d0 00 ff ff ff    	imul   edx,eax,0xffffff00
  41640c:	41 39 c1             	cmp    r9d,eax
  41640f:	0f 84 50 12 00 00    	je     417665 <fmt_fp+0xc65>
  416415:	8d 04 17             	lea    eax,[rdi+rdx*1]
  416418:	89 c1                	mov    ecx,eax
  41641a:	3d ff 00 00 00       	cmp    eax,0xff
  41641f:	0f 86 40 12 00 00    	jbe    417665 <fmt_fp+0xc65>
  416425:	81 e9 00 01 00 00    	sub    ecx,0x100
  41642b:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  416431:	0f 86 2e 12 00 00    	jbe    417665 <fmt_fp+0xc65>
  416437:	8d 88 00 fe ff ff    	lea    ecx,[rax-0x200]
  41643d:	e9 23 12 00 00       	jmp    417665 <fmt_fp+0xc65>
  416442:	44 8d 83 00 ff ff ff 	lea    r8d,[rbx-0x100]
  416449:	66 0f 6e fb          	movd   xmm7,ebx
--
	for (; l >= sizeof pad; l -= sizeof pad)
  4164a3:	66 0f fe c2          	paddd  xmm0,xmm2
  4164a7:	44 39 c9             	cmp    ecx,r9d
  4164aa:	72 ea                	jb     416496 <fmt_fp.cold+0x10d>
  4164ac:	89 fa                	mov    edx,edi
--
  4164b6:	66 0f 7e c5          	movd   ebp,xmm0
  4164ba:	69 c2 00 ff ff ff    	imul   eax,edx,0xffffff00
  4164c0:	39 fa                	cmp    edx,edi
  4164c2:	0f 84 56 0d 00 00    	je     41721e <fmt_fp+0x81e>
  4164c8:	44 01 c0             	add    eax,r8d
  4164cb:	89 c5                	mov    ebp,eax
  4164cd:	3d ff 00 00 00       	cmp    eax,0xff
  4164d2:	0f 86 46 0d 00 00    	jbe    41721e <fmt_fp+0x81e>
  4164d8:	81 ed 00 01 00 00    	sub    ebp,0x100
  4164de:	81 fd ff 00 00 00    	cmp    ebp,0xff
  4164e4:	0f 86 34 0d 00 00    	jbe    41721e <fmt_fp+0x81e>
  4164ea:	8d a8 00 fe ff ff    	lea    ebp,[rax-0x200]
  4164f0:	e9 29 0d 00 00       	jmp    41721e <fmt_fp+0x81e>
  4164f5:	45 8d 84 24 00 ff ff 	lea    r8d,[r12-0x100]
  4164fc:	ff 
--
	for (; l >= sizeof pad; l -= sizeof pad)
  416556:	66 0f fe c2          	paddd  xmm0,xmm2
  41655a:	41 39 c9             	cmp    r9d,ecx
  41655d:	77 ea                	ja     416549 <fmt_fp.cold+0x1c0>
  41655f:	89 f8                	mov    eax,edi
--
  416569:	66 41 0f 7e c1       	movd   r9d,xmm0
  41656e:	69 c8 00 ff ff ff    	imul   ecx,eax,0xffffff00
  416574:	39 c7                	cmp    edi,eax
  416576:	0f 84 8b 16 00 00    	je     417c07 <fmt_fp+0x1207>
  41657c:	41 01 c8             	add    r8d,ecx
  41657f:	45 89 c1             	mov    r9d,r8d
  416582:	41 81 f8 ff 00 00 00 	cmp    r8d,0xff
  416589:	0f 86 78 16 00 00    	jbe    417c07 <fmt_fp+0x1207>
  41658f:	41 81 e9 00 01 00 00 	sub    r9d,0x100
  416596:	41 81 f9 ff 00 00 00 	cmp    r9d,0xff
  41659d:	0f 86 64 16 00 00    	jbe    417c07 <fmt_fp+0x1207>
  4165a3:	45 8d 88 00 fe ff ff 	lea    r9d,[r8-0x200]
  4165aa:	e9 58 16 00 00       	jmp    417c07 <fmt_fp+0x1207>
  4165af:	41 8d b4 24 00 ff ff 	lea    esi,[r12-0x100]
  4165b6:	ff 
--
	for (; l >= sizeof pad; l -= sizeof pad)
  416611:	66 0f fe ca          	paddd  xmm1,xmm2
  416615:	45 39 c8             	cmp    r8d,r9d
  416618:	72 e9                	jb     416603 <fmt_fp.cold+0x27a>
  41661a:	89 f8                	mov    eax,edi
--
  416624:	66 41 0f 7e c5       	movd   r13d,xmm0
  416629:	69 c8 00 ff ff ff    	imul   ecx,eax,0xffffff00
  41662f:	39 c7                	cmp    edi,eax
  416631:	0f 84 16 11 00 00    	je     41774d <fmt_fp+0xd4d>
  416637:	8d 04 0e             	lea    eax,[rsi+rcx*1]
  41663a:	41 89 c5             	mov    r13d,eax
  41663d:	3d ff 00 00 00       	cmp    eax,0xff
  416642:	0f 86 05 11 00 00    	jbe    41774d <fmt_fp+0xd4d>
  416648:	41 81 ed 00 01 00 00 	sub    r13d,0x100
  41664f:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  416656:	0f 86 f1 10 00 00    	jbe    41774d <fmt_fp+0xd4d>
  41665c:	44 8d a8 00 fe ff ff 	lea    r13d,[rax-0x200]
  416663:	e9 e5 10 00 00       	jmp    41774d <fmt_fp+0xd4d>
  416668:	44 8d 85 00 ff ff ff 	lea    r8d,[rbp-0x100]
  41666f:	66 0f 6e fd          	movd   xmm7,ebp
--
	for (; l >= sizeof pad; l -= sizeof pad)
  4166c7:	66 0f fe c2          	paddd  xmm0,xmm2
  4166cb:	41 39 f1             	cmp    r9d,esi
  4166ce:	77 ea                	ja     4166ba <fmt_fp.cold+0x331>
  4166d0:	89 f9                	mov    ecx,edi
--
  4166da:	66 41 0f 7e c4       	movd   r12d,xmm0
  4166df:	69 c1 00 ff ff ff    	imul   eax,ecx,0xffffff00
  4166e5:	39 f9                	cmp    ecx,edi
  4166e7:	0f 84 a4 17 00 00    	je     417e91 <fmt_fp+0x1491>
  4166ed:	44 01 c0             	add    eax,r8d
  4166f0:	41 89 c4             	mov    r12d,eax
  4166f3:	3d ff 00 00 00       	cmp    eax,0xff
  4166f8:	0f 86 93 17 00 00    	jbe    417e91 <fmt_fp+0x1491>
  4166fe:	41 81 ec 00 01 00 00 	sub    r12d,0x100
  416705:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  41670c:	0f 86 7f 17 00 00    	jbe    417e91 <fmt_fp+0x1491>
  416712:	44 8d a0 00 fe ff ff 	lea    r12d,[rax-0x200]
  416719:	e9 73 17 00 00       	jmp    417e91 <fmt_fp+0x1491>
  41671e:	41 8d bd 00 ff ff ff 	lea    edi,[r13-0x100]
  416725:	66 41 0f 6e ed       	movd   xmm5,r13d
--
	for (; l >= sizeof pad; l -= sizeof pad)
  416781:	66 0f fe c2          	paddd  xmm0,xmm2
  416785:	45 39 c8             	cmp    r8d,r9d
  416788:	72 e9                	jb     416773 <fmt_fp.cold+0x3ea>
  41678a:	89 f2                	mov    edx,esi
--
  416794:	66 0f 7e c5          	movd   ebp,xmm0
  416798:	69 c2 00 ff ff ff    	imul   eax,edx,0xffffff00
  41679e:	39 f2                	cmp    edx,esi
  4167a0:	0f 84 65 0b 00 00    	je     41730b <fmt_fp+0x90b>
  4167a6:	01 f8                	add    eax,edi
  4167a8:	89 c5                	mov    ebp,eax
  4167aa:	3d ff 00 00 00       	cmp    eax,0xff
  4167af:	0f 86 56 0b 00 00    	jbe    41730b <fmt_fp+0x90b>
  4167b5:	81 ed 00 01 00 00    	sub    ebp,0x100
  4167bb:	81 fd ff 00 00 00    	cmp    ebp,0xff
  4167c1:	0f 86 44 0b 00 00    	jbe    41730b <fmt_fp+0x90b>
  4167c7:	8d a8 00 fe ff ff    	lea    ebp,[rax-0x200]
  4167cd:	e9 39 0b 00 00       	jmp    41730b <fmt_fp+0x90b>
  4167d2:	45 8d 84 24 00 ff ff 	lea    r8d,[r12-0x100]
  4167d9:	ff 
--
	for (; l >= sizeof pad; l -= sizeof pad)
  416835:	66 0f fe c2          	paddd  xmm0,xmm2
  416839:	44 39 c9             	cmp    ecx,r9d
  41683c:	72 ea                	jb     416828 <fmt_fp.cold+0x49f>
  41683e:	89 f8                	mov    eax,edi
--
  416848:	66 0f 7e c1          	movd   ecx,xmm0
  41684c:	69 d0 00 ff ff ff    	imul   edx,eax,0xffffff00
  416852:	39 c7                	cmp    edi,eax
  416854:	0f 84 be 12 00 00    	je     417b18 <fmt_fp+0x1118>
  41685a:	41 01 d0             	add    r8d,edx
  41685d:	44 89 c1             	mov    ecx,r8d
  416860:	41 81 f8 ff 00 00 00 	cmp    r8d,0xff
  416867:	0f 86 ab 12 00 00    	jbe    417b18 <fmt_fp+0x1118>
  41686d:	81 e9 00 01 00 00    	sub    ecx,0x100
  416873:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  416879:	0f 86 99 12 00 00    	jbe    417b18 <fmt_fp+0x1118>
  41687f:	41 8d 88 00 fe ff ff 	lea    ecx,[r8-0x200]
  416886:	e9 8d 12 00 00       	jmp    417b18 <fmt_fp+0x1118>
  41688b:	8d bb 00 ff ff ff    	lea    edi,[rbx-0x100]
  416891:	66 0f 6e f3          	movd   xmm6,ebx
--
	for (; l >= sizeof pad; l -= sizeof pad)
  4168ec:	66 0f fe c2          	paddd  xmm0,xmm2
  4168f0:	45 39 c8             	cmp    r8d,r9d
  4168f3:	77 e9                	ja     4168de <fmt_fp.cold+0x555>
  4168f5:	89 f2                	mov    edx,esi
--
  4168ff:	66 0f 7e 44 24 08    	movd   DWORD PTR [rsp+0x8],xmm0
  416905:	69 c2 00 ff ff ff    	imul   eax,edx,0xffffff00
  41690b:	39 f2                	cmp    edx,esi
  41690d:	0f 84 ac 0a 00 00    	je     4173bf <fmt_fp+0x9bf>
  416913:	01 f8                	add    eax,edi
  416915:	89 44 24 08          	mov    DWORD PTR [rsp+0x8],eax
  416919:	89 c3                	mov    ebx,eax
  41691b:	3d ff 00 00 00       	cmp    eax,0xff
  416920:	0f 86 99 0a 00 00    	jbe    4173bf <fmt_fp+0x9bf>
  416926:	81 eb 00 01 00 00    	sub    ebx,0x100
  41692c:	89 5c 24 08          	mov    DWORD PTR [rsp+0x8],ebx
  416930:	81 fb ff 00 00 00    	cmp    ebx,0xff
  416936:	0f 86 83 0a 00 00    	jbe    4173bf <fmt_fp+0x9bf>
  41693c:	2d 00 02 00 00       	sub    eax,0x200
  416941:	89 44 24 08          	mov    DWORD PTR [rsp+0x8],eax
  416945:	e9 75 0a 00 00       	jmp    4173bf <fmt_fp+0x9bf>
  41694a:	8d b5 00 ff ff ff    	lea    esi,[rbp-0x100]
  416950:	66 0f 6e fd          	movd   xmm7,ebp
--
	for (; l >= sizeof pad; l -= sizeof pad)
  4169a9:	66 0f fe c2          	paddd  xmm0,xmm2
  4169ad:	45 39 c8             	cmp    r8d,r9d
  4169b0:	72 e9                	jb     41699b <fmt_fp.cold+0x612>
  4169b2:	89 f8                	mov    eax,edi
--
  4169bc:	66 41 0f 7e c4       	movd   r12d,xmm0
  4169c1:	69 c8 00 ff ff ff    	imul   ecx,eax,0xffffff00
  4169c7:	39 c7                	cmp    edi,eax
  4169c9:	0f 84 ef 0a 00 00    	je     4174be <fmt_fp+0xabe>
  4169cf:	8d 04 0e             	lea    eax,[rsi+rcx*1]
  4169d2:	41 89 c4             	mov    r12d,eax
  4169d5:	3d ff 00 00 00       	cmp    eax,0xff
  4169da:	0f 86 de 0a 00 00    	jbe    4174be <fmt_fp+0xabe>
  4169e0:	41 81 ec 00 01 00 00 	sub    r12d,0x100
  4169e7:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  4169ee:	0f 86 ca 0a 00 00    	jbe    4174be <fmt_fp+0xabe>
  4169f4:	44 8d a0 00 fe ff ff 	lea    r12d,[rax-0x200]
  4169fb:	e9 be 0a 00 00       	jmp    4174be <fmt_fp+0xabe>

0000000000416a00 <fmt_fp>:
--
  416a5d:	ff b4 24 88 1e 00 00 	push   QWORD PTR [rsp+0x1e88]
  416a64:	ff b4 24 88 1e 00 00 	push   QWORD PTR [rsp+0x1e88]
  416a6b:	ff d0                	call   rax
  416a6d:	89 44 24 38          	mov    DWORD PTR [rsp+0x38],eax
  416a71:	59                   	pop    rcx
  416a72:	5e                   	pop    rsi
  416a73:	85 c0                	test   eax,eax
  416a75:	0f 84 1d 04 00 00    	je     416e98 <fmt_fp+0x498>
		y=-y;
  416a7b:	db ac 24 80 1e 00 00 	fld    TBYTE PTR [rsp+0x1e80]
--
  416acf:	4c 01 f8             	add    rax,r15
  416ad2:	ff b4 24 88 1e 00 00 	push   QWORD PTR [rsp+0x1e88]
  416ad9:	ff d0                	call   rax
  416adb:	41 5c                	pop    r12
  416add:	5a                   	pop    rdx
  416ade:	83 f8 01             	cmp    eax,0x1
  416ae1:	0f 8e 61 0a 00 00    	jle    417548 <fmt_fp+0xb48>
		out(f, s, 3);
--
  416afd:	4c 01 f8             	add    rax,r15
  416b00:	ff b4 24 88 1e 00 00 	push   QWORD PTR [rsp+0x1e88]
  416b07:	ff d0                	call   rax
	if (y) e2--;
  416b09:	41 5a                	pop    r10
--
  416b15:	dd d9                	fstp   st(1)
  416b17:	0f 8a c3 03 00 00    	jp     416ee0 <fmt_fp+0x4e0>
  416b1d:	0f 85 bd 03 00 00    	jne    416ee0 <fmt_fp+0x4e0>

	if ((t|32)=='a') {
--
	if ((t|32)=='a') {
  416b2d:	41 83 cb 20          	or     r11d,0x20
  416b31:	41 83 fb 61          	cmp    r11d,0x61
  416b35:	0f 84 c5 03 00 00    	je     416f00 <fmt_fp+0x500>
		pad(f, '0', l-(ebuf-estr)-(s-buf), 0, 0);
		out(f, estr, ebuf-estr);
--
  416b51:	dd d9                	fstp   st(1)
  416b53:	0f 8a 70 0c 00 00    	jp     4177c9 <fmt_fp+0xdc9>
  416b59:	0f 85 6a 0c 00 00    	jne    4177c9 <fmt_fp+0xdc9>
	if (e2<0) a=r=z=big;
  416b5f:	d9 7c 24 5e          	fnstcw WORD PTR [rsp+0x5e]
--
  416bd1:	db ea                	fucomi st,st(2)
  416bd3:	7a d3                	jp     416ba8 <fmt_fp+0x1a8>
  416bd5:	75 d1                	jne    416ba8 <fmt_fp+0x1a8>
  416bd7:	dd d8                	fstp   st(0)
  416bd9:	dd d8                	fstp   st(0)
--
  416bfd:	48 8d 7b fc          	lea    rdi,[rbx-0x4]
		int sh=MIN(29,e2);
  416c01:	41 39 c9             	cmp    r9d,ecx
  416c04:	41 0f 4e c9          	cmovle ecx,r9d
		for (d=z-1; d>=a; d--) {
  416c08:	48 39 ef             	cmp    rdi,rbp
  416c0b:	72 3f                	jb     416c4c <fmt_fp+0x24c>
		uint32_t carry=0;
--
  416c39:	89 77 04             	mov    DWORD PTR [rdi+0x4],esi
		for (d=z-1; d>=a; d--) {
  416c3c:	48 39 ef             	cmp    rdi,rbp
  416c3f:	73 cf                	jae    416c10 <fmt_fp+0x210>
		if (carry) *--a = carry;
  416c41:	85 c0                	test   eax,eax
  416c43:	74 07                	je     416c4c <fmt_fp+0x24c>
  416c45:	89 55 fc             	mov    DWORD PTR [rbp-0x4],edx
  416c48:	48 83 ed 04          	sub    rbp,0x4
		while (z>a && !z[-1]) z--;
  416c4c:	48 39 dd             	cmp    rbp,rbx
  416c4f:	72 10                	jb     416c61 <fmt_fp+0x261>
  416c51:	eb 15                	jmp    416c68 <fmt_fp+0x268>
  416c53:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  416c58:	48 83 eb 04          	sub    rbx,0x4
  416c5c:	48 39 eb             	cmp    rbx,rbp
  416c5f:	76 07                	jbe    416c68 <fmt_fp+0x268>
  416c61:	8b 73 fc             	mov    esi,DWORD PTR [rbx-0x4]
  416c64:	85 f6                	test   esi,esi
  416c66:	74 f0                	je     416c58 <fmt_fp+0x258>
		e2-=sh;
  416c68:	41 29 c9             	sub    r9d,ecx
	while (e2>0) {
  416c6b:	45 85 c9             	test   r9d,r9d
  416c6e:	7f 88                	jg     416bf8 <fmt_fp+0x1f8>
  416c70:	44 89 4c 24 60       	mov    DWORD PTR [rsp+0x60],r9d
	while (e2<0) {
  416c75:	45 85 c9             	test   r9d,r9d
  416c78:	0f 84 d3 00 00 00    	je     416d51 <fmt_fp+0x351>
		int sh=MIN(9,-e2), need=1+(p+LDBL_MANT_DIG/3U+8)/9;
  416c7e:	8b 04 24             	mov    eax,DWORD PTR [rsp]
--
  416ca5:	0f 1f 00             	nop    DWORD PTR [rax]
		int sh=MIN(9,-e2), need=1+(p+LDBL_MANT_DIG/3U+8)/9;
  416ca8:	41 83 f9 f7          	cmp    r9d,0xfffffff7
  416cac:	0f 8d 6e 08 00 00    	jge    417520 <fmt_fp+0xb20>
		if (!*a) a++;
  416cb2:	8b 45 00             	mov    eax,DWORD PTR [rbp+0x0]
--
  416cb9:	b9 09 00 00 00       	mov    ecx,0x9
		for (d=a; d<z; d++) {
  416cbe:	48 39 dd             	cmp    rbp,rbx
  416cc1:	0f 83 6d 08 00 00    	jae    417534 <fmt_fp+0xb34>
			uint32_t rm = *d & (1<<sh)-1;
--
  416cfe:	89 c2                	mov    edx,eax
		for (d=a; d<z; d++) {
  416d00:	48 39 de             	cmp    rsi,rbx
  416d03:	72 e3                	jb     416ce8 <fmt_fp+0x2e8>
		if (!*a) a++;
--
		if (carry) *z++ = carry;
  416d12:	85 d2                	test   edx,edx
  416d14:	74 06                	je     416d1c <fmt_fp+0x31c>
  416d16:	89 13                	mov    DWORD PTR [rbx],edx
  416d18:	48 83 c3 04          	add    rbx,0x4
		b = (t|32)=='f' ? r : a;
  416d1c:	41 83 fb 66          	cmp    r11d,0x66
  416d20:	4c 89 f0             	mov    rax,r14
		if (z-b > need) z = b+need;
--
  416d2d:	4c 01 e0             	add    rax,r12
  416d30:	48 c1 fa 02          	sar    rdx,0x2
  416d34:	4c 39 ea             	cmp    rdx,r13
  416d37:	48 0f 4f d8          	cmovg  rbx,rax
	while (e2<0) {
  416d3b:	45 85 c9             	test   r9d,r9d
  416d3e:	0f 85 64 ff ff ff    	jne    416ca8 <fmt_fp+0x2a8>
  416d44:	c7 44 24 60 00 00 00 	mov    DWORD PTR [rsp+0x60],0x0
  416d4b:	00 
  416d4c:	4c 8b 74 24 08       	mov    r14,QWORD PTR [rsp+0x8]
	if (a<z) for (i=10, e=9*(r-a); *a>=i; i*=10, e++);
  416d51:	48 39 eb             	cmp    rbx,rbp
  416d54:	0f 87 31 0a 00 00    	ja     41778b <fmt_fp+0xd8b>
  416d5a:	8b 04 24             	mov    eax,DWORD PTR [rsp]
--
	j = p - ((t|32)!='f')*e - ((t|32)=='g' && p);
  416d5f:	31 d2                	xor    edx,edx
  416d61:	41 83 fb 67          	cmp    r11d,0x67
	if (j < 9*(z-r-1)) {
  416d65:	48 8b 74 24 18       	mov    rsi,QWORD PTR [rsp+0x18]
--
  416d7c:	48 c1 fa 02          	sar    rdx,0x2
  416d80:	48 8d 54 d2 f7       	lea    rdx,[rdx+rdx*8-0x9]
  416d85:	48 39 d1             	cmp    rcx,rdx
  416d88:	0f 8d 9f 0b 00 00    	jge    41792d <fmt_fp+0xf2d>
		uint32_t x;
		/* We avoid C's broken division of negative numbers */
--
  416db7:	ff 
		for (i=10, j++; j<9; i*=10, j++);
  416db8:	83 f8 08             	cmp    eax,0x8
  416dbb:	0f 84 7e 23 00 00    	je     41913f <fmt_fp+0x273f>
  416dc1:	ba 08 00 00 00       	mov    edx,0x8
  416dc6:	29 c2                	sub    edx,eax
  416dc8:	41 89 d0             	mov    r8d,edx
  416dcb:	83 f8 07             	cmp    eax,0x7
  416dce:	0f 84 9b 23 00 00    	je     41916f <fmt_fp+0x276f>
  416dd4:	89 d0                	mov    eax,edx
  416dd6:	d1 e8                	shr    eax,1
  416dd8:	83 f8 01             	cmp    eax,0x1
  416ddb:	0f 84 10 23 00 00    	je     4190f1 <fmt_fp+0x26f1>
  416de1:	83 f8 02             	cmp    eax,0x2
  416de4:	0f 84 2a 23 00 00    	je     419114 <fmt_fp+0x2714>
  416dea:	83 f8 03             	cmp    eax,0x3
  416ded:	0f 84 86 23 00 00    	je     419179 <fmt_fp+0x2779>
  416df3:	83 f8 04             	cmp    eax,0x4
  416df6:	0f 84 9c 23 00 00    	je     419198 <fmt_fp+0x2798>
  416dfc:	83 f8 05             	cmp    eax,0x5
  416dff:	0f 84 c8 23 00 00    	je     4191cd <fmt_fp+0x27cd>
  416e05:	83 f8 06             	cmp    eax,0x6
  416e08:	0f 84 aa 23 00 00    	je     4191b8 <fmt_fp+0x27b8>
  416e0e:	b9 00 00 8a 5d       	mov    ecx,0x5d8a0000
  416e13:	83 f8 08             	cmp    eax,0x8
  416e16:	0f 85 b3 21 00 00    	jne    418fcf <fmt_fp+0x25cf>
  416e1c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		x = *d % i;
--
		if (x || d+1!=z) {
  416e31:	85 d2                	test   edx,edx
  416e33:	0f 85 68 0a 00 00    	jne    4178a1 <fmt_fp+0xea1>
  416e39:	48 8d 56 04          	lea    rdx,[rsi+0x4]
  416e3d:	48 39 d3             	cmp    rbx,rdx
  416e40:	0f 84 6e 22 00 00    	je     4190b4 <fmt_fp+0x26b4>
			long double round = 2/LDBL_EPSILON;
			long double small;
			if ((*d/i & 1) || (i==1000000000 && d>a && (d[-1]&1)))
  416e46:	a8 01                	test   al,0x1
  416e48:	0f 85 30 21 00 00    	jne    418f7e <fmt_fp+0x257e>
  416e4e:	81 f9 00 ca 9a 3b    	cmp    ecx,0x3b9aca00
  416e54:	75 09                	jne    416e5f <fmt_fp+0x45f>
  416e56:	48 39 ee             	cmp    rsi,rbp
  416e59:	0f 87 ea 20 00 00    	ja     418f49 <fmt_fp+0x2549>
  416e5f:	48 b8 c0 22 fc ff ff 	movabs rax,0xfffffffffffc22c0
--
  416e8b:	d9 ca                	fxch   st(2)
  416e8d:	d9 c9                	fxch   st(1)
  416e8f:	e9 50 0a 00 00       	jmp    4178e4 <fmt_fp+0xee4>
  416e94:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	} else if (fl & MARK_POS) {
  416e98:	8b 44 24 14          	mov    eax,DWORD PTR [rsp+0x14]
  416e9c:	f6 c4 08             	test   ah,0x8
  416e9f:	0f 84 33 06 00 00    	je     4174d8 <fmt_fp+0xad8>
  416ea5:	bb 03 00 00 00       	mov    ebx,0x3
  416eaa:	41 bd 03 00 00 00    	mov    r13d,0x3
--
		prefix+=3;
  416ed3:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  416ed8:	e9 e1 fb ff ff       	jmp    416abe <fmt_fp+0xbe>
  416edd:	0f 1f 00             	nop    DWORD PTR [rax]
	if (y) e2--;
--
  416ef1:	44 89 4c 24 60       	mov    DWORD PTR [rsp+0x60],r9d
	if ((t|32)=='a') {
  416ef6:	41 83 fb 61          	cmp    r11d,0x61
  416efa:	0f 85 3b fc ff ff    	jne    416b3b <fmt_fp+0x13b>
		if (t&32) prefix += 9;
  416f00:	48 8b 7c 24 30       	mov    rdi,QWORD PTR [rsp+0x30]
--
		if (p<0 || p>=LDBL_MANT_DIG/4-1) re=0;
  416f17:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  416f1a:	83 f8 0e             	cmp    eax,0xe
  416f1d:	0f 87 9b 00 00 00    	ja     416fbe <fmt_fp+0x5be>
			while (re--) round*=16;
  416f23:	0f 84 b9 22 00 00    	je     4191e2 <fmt_fp+0x27e2>
  416f29:	83 f8 0d             	cmp    eax,0xd
  416f2c:	0f 84 13 23 00 00    	je     419245 <fmt_fp+0x2845>
  416f32:	83 f8 0c             	cmp    eax,0xc
  416f35:	0f 84 f7 22 00 00    	je     419232 <fmt_fp+0x2832>
  416f3b:	83 f8 0b             	cmp    eax,0xb
  416f3e:	0f 84 db 22 00 00    	je     41921f <fmt_fp+0x281f>
  416f44:	83 f8 0a             	cmp    eax,0xa
  416f47:	0f 84 16 23 00 00    	je     419263 <fmt_fp+0x2863>
  416f4d:	83 f8 09             	cmp    eax,0x9
  416f50:	0f 84 b2 20 00 00    	je     419008 <fmt_fp+0x2608>
  416f56:	83 f8 08             	cmp    eax,0x8
  416f59:	0f 84 2a 23 00 00    	je     419289 <fmt_fp+0x2889>
  416f5f:	83 f8 07             	cmp    eax,0x7
  416f62:	0f 84 0e 23 00 00    	je     419276 <fmt_fp+0x2876>
  416f68:	83 f8 06             	cmp    eax,0x6
  416f6b:	0f 84 3e 23 00 00    	je     4192af <fmt_fp+0x28af>
  416f71:	83 f8 05             	cmp    eax,0x5
  416f74:	0f 84 22 23 00 00    	je     41929c <fmt_fp+0x289c>
  416f7a:	83 f8 04             	cmp    eax,0x4
  416f7d:	0f 84 78 23 00 00    	je     4192fb <fmt_fp+0x28fb>
  416f83:	83 f8 03             	cmp    eax,0x3
  416f86:	0f 84 5c 23 00 00    	je     4192e8 <fmt_fp+0x28e8>
  416f8c:	83 f8 02             	cmp    eax,0x2
  416f8f:	0f 84 40 23 00 00    	je     4192d5 <fmt_fp+0x28d5>
  416f95:	83 f8 01             	cmp    eax,0x1
  416f98:	0f 84 24 23 00 00    	je     4192c2 <fmt_fp+0x28c2>
  416f9e:	48 b8 80 22 fc ff ff 	movabs rax,0xfffffffffffc2280
  416fa5:	ff ff ff 
--
			if (*prefix=='-') {
  416fac:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  416fb1:	80 38 2d             	cmp    BYTE PTR [rax],0x2d
  416fb4:	0f 84 ca 20 00 00    	je     419084 <fmt_fp+0x2684>
				y+=round;
  416fba:	dc c1                	fadd   st(1),st
--
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  416fdc:	45 85 c9             	test   r9d,r9d
  416fdf:	0f 84 fe 1e 00 00    	je     418ee3 <fmt_fp+0x24e3>
  416fe5:	0f 1f 00             	nop    DWORD PTR [rax]
  416fe8:	48 89 c8             	mov    rax,rcx
--
  417008:	48 89 c8             	mov    rax,rcx
  41700b:	48 89 d1             	mov    rcx,rdx
  41700e:	48 83 f8 09          	cmp    rax,0x9
  417012:	77 d4                	ja     416fe8 <fmt_fp+0x5e8>
		if (estr==ebuf) *--estr='0';
  417014:	4c 39 e6             	cmp    rsi,r12
  417017:	0f 84 c6 1e 00 00    	je     418ee3 <fmt_fp+0x24e3>
		*--estr = t+('p'-'a');
  41701d:	8b 7c 24 20          	mov    edi,DWORD PTR [rsp+0x20]
--
  417044:	83 e6 20             	and    esi,0x20
  417047:	f6 44 24 14 08       	test   BYTE PTR [rsp+0x14],0x8
  41704c:	0f 85 b8 18 00 00    	jne    41890a <fmt_fp+0x1f0a>
  417052:	d9 7c 24 5e          	fnstcw WORD PTR [rsp+0x5e]
		s=buf;
--
  417083:	d9 ca                	fxch   st(2)
  417085:	66 89 44 24 5c       	mov    WORD PTR [rsp+0x5c],ax
  41708a:	eb 11                	jmp    41709d <fmt_fp+0x69d>
  41708c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
			*s++=xdigits[x]|(t&32);
--
  417093:	db ea                	fucomi st,st(2)
  417095:	7a 06                	jp     41709d <fmt_fp+0x69d>
  417097:	0f 84 69 20 00 00    	je     419106 <fmt_fp+0x2706>
			int x=y;
  41709d:	d9 c0                	fld    st(0)
--
  4170c5:	d8 c9                	fmul   st,st(1)
			if (s-buf==1 && (y||p>0||(fl&ALT_FORM))) *s++='.';
  4170c7:	4c 39 e2             	cmp    rdx,r12
  4170ca:	75 c4                	jne    417090 <fmt_fp+0x690>
  4170cc:	44 8b 0c 24          	mov    r9d,DWORD PTR [rsp]
  4170d0:	45 85 c9             	test   r9d,r9d
  4170d3:	0f 8f f0 10 00 00    	jg     4181c9 <fmt_fp+0x17c9>
  4170d9:	db ea                	fucomi st,st(2)
  4170db:	41 0f 9a c0          	setp   r8b
  4170df:	44 0f 45 c7          	cmovne r8d,edi
  4170e3:	45 84 c0             	test   r8b,r8b
  4170e6:	0f 85 dd 10 00 00    	jne    4181c9 <fmt_fp+0x17c9>
  4170ec:	dd d8                	fstp   st(0)
  4170ee:	dd d8                	fstp   st(0)
  4170f0:	dd d8                	fstp   st(0)
  4170f2:	eb 06                	jmp    4170fa <fmt_fp+0x6fa>
  4170f4:	dd d8                	fstp   st(0)
  4170f6:	dd d8                	fstp   st(0)
--
  41710e:	48 89 7c 24 20       	mov    QWORD PTR [rsp+0x20],rdi
  417113:	48 29 da             	sub    rdx,rbx
  417116:	48 39 d1             	cmp    rcx,rdx
  417119:	0f 8f 9f 11 00 00    	jg     4182be <fmt_fp+0x18be>
		if (p && s-buf-2 < p)
  41711f:	4c 29 e0             	sub    rax,r12
--
		if (p && s-buf-2 < p)
  417134:	85 ff                	test   edi,edi
  417136:	74 0d                	je     417145 <fmt_fp+0x745>
  417138:	48 8d 53 ff          	lea    rdx,[rbx-0x1]
  41713c:	48 39 d1             	cmp    rcx,rdx
  41713f:	0f 8d 21 1e 00 00    	jge    418f66 <fmt_fp+0x2566>
			l = (s-buf) + (ebuf-estr);
  417145:	c7 44 24 08 00 00 00 	mov    DWORD PTR [rsp+0x8],0x0
--
  417155:	44 01 e8             	add    eax,r13d
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  417158:	3b 44 24 58          	cmp    eax,DWORD PTR [rsp+0x58]
		pad(f, ' ', w, pl+l, fl);
  41715c:	89 44 24 18          	mov    DWORD PTR [rsp+0x18],eax
--
  417168:	f7 44 24 14 00 20 01 	test   DWORD PTR [rsp+0x14],0x12000
  41716f:	00 
  417170:	0f 85 c4 00 00 00    	jne    41723a <fmt_fp+0x83a>
  417176:	84 c0                	test   al,al
  417178:	0f 85 bc 00 00 00    	jne    41723a <fmt_fp+0x83a>
	l = w - l;
  41717e:	8b 6c 24 58          	mov    ebp,DWORD PTR [rsp+0x58]
--
  41718b:	4c 8d 94 24 90 01 00 	lea    r10,[rsp+0x190]
  417192:	00 
  417193:	39 c5                	cmp    ebp,eax
  417195:	4c 89 54 24 40       	mov    QWORD PTR [rsp+0x40],r10
  41719a:	4c 89 d7             	mov    rdi,r10
--
  4171af:	ff ff ff 
  4171b2:	4c 01 f8             	add    rax,r15
  4171b5:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  4171b7:	81 fd ff 00 00 00    	cmp    ebp,0xff
  4171bd:	4c 8b 54 24 40       	mov    r10,QWORD PTR [rsp+0x40]
  4171c2:	0f 8e 90 20 00 00    	jle    419258 <fmt_fp+0x2858>
--
  4171e3:	83 e0 20             	and    eax,0x20
  4171e6:	89 c6                	mov    esi,eax
  4171e8:	0f 84 e8 0f 00 00    	je     4181d6 <fmt_fp+0x17d6>
	for (; l >= sizeof pad; l -= sizeof pad)
  4171ee:	49 89 ea             	mov    r10,rbp
  4171f1:	81 fb ff 00 00 00    	cmp    ebx,0xff
  4171f7:	7e 47                	jle    417240 <fmt_fp+0x840>
  4171f9:	8d 83 00 e9 ff ff    	lea    eax,[rbx-0x1700]
  4171ff:	3d 00 e9 ff 7f       	cmp    eax,0x7fffe900
  417204:	0f 86 38 f2 ff ff    	jbe    416442 <fmt_fp.cold+0xb9>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
--
	for (; l >= sizeof pad; l -= sizeof pad)
  417214:	89 dd                	mov    ebp,ebx
  417216:	81 fb ff 00 00 00    	cmp    ebx,0xff
  41721c:	77 ee                	ja     41720c <fmt_fp+0x80c>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41721e:	85 f6                	test   esi,esi
  417220:	75 26                	jne    417248 <fmt_fp+0x848>
  417222:	48 b8 60 e3 fb ff ff 	movabs rax,0xfffffffffffbe360
  417229:	ff ff ff 
--
  417232:	4c 89 d7             	mov    rdi,r10
  417235:	4c 01 f8             	add    rax,r15
  417238:	ff d0                	call   rax
  41723a:	41 8b 36             	mov    esi,DWORD PTR [r14]
  41723d:	83 e6 20             	and    esi,0x20
  417240:	85 f6                	test   esi,esi
  417242:	0f 84 14 18 00 00    	je     418a5c <fmt_fp+0x205c>
		pad(f, '0', w, pl+l, fl^ZERO_PAD);
  417248:	8b 44 24 14          	mov    eax,DWORD PTR [rsp+0x14]
--
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  417251:	a9 00 20 01 00       	test   eax,0x12000
  417256:	0f 85 d0 10 00 00    	jne    41832c <fmt_fp+0x192c>
  41725c:	80 3c 24 00          	cmp    BYTE PTR [rsp],0x0
  417260:	0f 85 c6 10 00 00    	jne    41832c <fmt_fp+0x192c>
	l = w - l;
  417266:	8b 6c 24 58          	mov    ebp,DWORD PTR [rsp+0x58]
--
  417273:	4c 8d 94 24 90 01 00 	lea    r10,[rsp+0x190]
  41727a:	00 
  41727b:	39 c5                	cmp    ebp,eax
  41727d:	4c 89 54 24 30       	mov    QWORD PTR [rsp+0x30],r10
  417282:	4c 89 d7             	mov    rdi,r10
--
  417297:	ff ff ff 
  41729a:	4c 01 f8             	add    rax,r15
  41729d:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  41729f:	81 fd ff 00 00 00    	cmp    ebp,0xff
  4172a5:	4c 8b 54 24 30       	mov    r10,QWORD PTR [rsp+0x30]
  4172aa:	0f 8e 64 1f 00 00    	jle    419214 <fmt_fp+0x2814>
--
  4172c7:	83 e0 20             	and    eax,0x20
  4172ca:	89 c1                	mov    ecx,eax
  4172cc:	0f 84 6e 0f 00 00    	je     418240 <fmt_fp+0x1840>
	for (; l >= sizeof pad; l -= sizeof pad)
  4172d2:	49 89 ea             	mov    r10,rbp
  4172d5:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  4172dc:	0f 8e 50 10 00 00    	jle    418332 <fmt_fp+0x1932>
  4172e2:	41 8d 85 00 e9 ff ff 	lea    eax,[r13-0x1700]
  4172e9:	3d 00 e9 ff 7f       	cmp    eax,0x7fffe900
  4172ee:	0f 86 2a f4 ff ff    	jbe    41671e <fmt_fp.cold+0x395>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
--
	for (; l >= sizeof pad; l -= sizeof pad)
  4172ff:	44 89 ed             	mov    ebp,r13d
  417302:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  417309:	77 eb                	ja     4172f6 <fmt_fp+0x8f6>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41730b:	85 c9                	test   ecx,ecx
  41730d:	0f 84 01 10 00 00    	je     418314 <fmt_fp+0x1914>
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  417313:	8b 44 24 08          	mov    eax,DWORD PTR [rsp+0x8]
--
  417326:	ba 00 01 00 00       	mov    edx,0x100
  41732b:	be 30 00 00 00       	mov    esi,0x30
  417330:	81 7c 24 38 01 01 00 	cmp    DWORD PTR [rsp+0x38],0x101
  417337:	00 
  417338:	4c 8d 94 24 90 01 00 	lea    r10,[rsp+0x190]
--
  417353:	4c 89 d7             	mov    rdi,r10
  417356:	4c 01 f8             	add    rax,r15
  417359:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  41735b:	81 fd ff 00 00 00    	cmp    ebp,0xff
  417361:	4c 8b 54 24 30       	mov    r10,QWORD PTR [rsp+0x30]
  417366:	0f 8e 41 1e 00 00    	jle    4191ad <fmt_fp+0x27ad>
--
  417382:	83 e0 20             	and    eax,0x20
  417385:	89 c1                	mov    ecx,eax
  417387:	0f 84 83 0e 00 00    	je     418210 <fmt_fp+0x1810>
	for (; l >= sizeof pad; l -= sizeof pad)
  41738d:	4d 89 e2             	mov    r10,r12
  417390:	81 fb ff 00 00 00    	cmp    ebx,0xff
  417396:	7e 4b                	jle    4173e3 <fmt_fp+0x9e3>
  417398:	8d 83 00 e9 ff ff    	lea    eax,[rbx-0x1700]
  41739e:	3d 00 e9 ff 7f       	cmp    eax,0x7fffe900
  4173a3:	0f 86 e2 f4 ff ff    	jbe    41688b <fmt_fp.cold+0x502>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
--
  4173b1:	89 c1                	mov    ecx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  4173b3:	81 fb ff 00 00 00    	cmp    ebx,0xff
  4173b9:	77 f0                	ja     4173ab <fmt_fp+0x9ab>
  4173bb:	89 5c 24 08          	mov    DWORD PTR [rsp+0x8],ebx
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4173bf:	85 c9                	test   ecx,ecx
  4173c1:	75 40                	jne    417403 <fmt_fp+0xa03>
  4173c3:	48 b8 60 e3 fb ff ff 	movabs rax,0xfffffffffffbe360
  4173ca:	ff ff ff 
--
  4173d5:	4c 89 d7             	mov    rdi,r10
  4173d8:	4c 01 f8             	add    rax,r15
  4173db:	ff d0                	call   rax
  4173dd:	41 8b 0e             	mov    ecx,DWORD PTR [r14]
  4173e0:	83 e1 20             	and    ecx,0x20
  4173e3:	85 c9                	test   ecx,ecx
  4173e5:	75 1c                	jne    417403 <fmt_fp+0xa03>
  4173e7:	48 8b 74 24 20       	mov    rsi,QWORD PTR [rsp+0x20]
  4173ec:	48 8b 7c 24 28       	mov    rdi,QWORD PTR [rsp+0x28]
--
  4173fb:	ff ff ff 
  4173fe:	4c 01 f8             	add    rax,r15
  417401:	ff d0                	call   rax
		pad(f, ' ', w, pl+l, fl^LEFT_ADJ);
  417403:	8b 44 24 14          	mov    eax,DWORD PTR [rsp+0x14]
--
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41740a:	a9 00 20 01 00       	test   eax,0x12000
  41740f:	0f 85 b1 00 00 00    	jne    4174c6 <fmt_fp+0xac6>
  417415:	80 3c 24 00          	cmp    BYTE PTR [rsp],0x0
  417419:	0f 85 a7 00 00 00    	jne    4174c6 <fmt_fp+0xac6>
	l = w - l;
  41741f:	44 8b 64 24 58       	mov    r12d,DWORD PTR [rsp+0x58]
--
  41742e:	4c 8d 94 24 90 01 00 	lea    r10,[rsp+0x190]
  417435:	00 
  417436:	41 39 c4             	cmp    r12d,eax
  417439:	4c 89 14 24          	mov    QWORD PTR [rsp],r10
  41743d:	4c 89 d7             	mov    rdi,r10
--
  417453:	ff ff ff 
  417456:	4c 01 f8             	add    rax,r15
  417459:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  41745b:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  417462:	4c 8b 14 24          	mov    r10,QWORD PTR [rsp]
  417466:	0f 8e 9d 1d 00 00    	jle    419209 <fmt_fp+0x2809>
--
  417484:	89 c1                	mov    ecx,eax
  417486:	83 e1 20             	and    ecx,0x20
  417489:	0f 84 e3 0d 00 00    	je     418272 <fmt_fp+0x1872>
	for (; l >= sizeof pad; l -= sizeof pad)
  41748f:	4d 89 ea             	mov    r10,r13
  417492:	81 fd ff 00 00 00    	cmp    ebp,0xff
  417498:	7e 2c                	jle    4174c6 <fmt_fp+0xac6>
  41749a:	8d 85 00 e9 ff ff    	lea    eax,[rbp-0x1700]
  4174a0:	3d 00 e9 ff 7f       	cmp    eax,0x7fffe900
  4174a5:	0f 86 9f f4 ff ff    	jbe    41694a <fmt_fp.cold+0x5c1>
  4174ab:	81 ed 00 01 00 00    	sub    ebp,0x100
--
	for (; l >= sizeof pad; l -= sizeof pad)
  4174b3:	41 89 ec             	mov    r12d,ebp
  4174b6:	81 fd ff 00 00 00    	cmp    ebp,0xff
  4174bc:	77 ed                	ja     4174ab <fmt_fp+0xaab>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4174be:	85 d2                	test   edx,edx
  4174c0:	0f 84 0e 1c 00 00    	je     4190d4 <fmt_fp+0x26d4>
		return MAX(w, pl+l);
  4174c6:	8b 5c 24 18          	mov    ebx,DWORD PTR [rsp+0x18]
  4174ca:	8b 44 24 58          	mov    eax,DWORD PTR [rsp+0x58]
  4174ce:	39 c3                	cmp    ebx,eax
  4174d0:	0f 4d c3             	cmovge eax,ebx
  4174d3:	e9 a1 02 00 00       	jmp    417779 <fmt_fp+0xd79>
	} else if (fl & PAD_POS) {
  4174d8:	a8 01                	test   al,0x1
  4174da:	0f 84 05 03 00 00    	je     4177e5 <fmt_fp+0xde5>
  4174e0:	bb 03 00 00 00       	mov    ebx,0x3
  4174e5:	41 bd 03 00 00 00    	mov    r13d,0x3
--
		prefix+=6;
  41750e:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  417513:	e9 a6 f5 ff ff       	jmp    416abe <fmt_fp+0xbe>
  417518:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41751f:	00 
--
  417529:	f7 d9                	neg    ecx
		for (d=a; d<z; d++) {
  41752b:	48 39 dd             	cmp    rbp,rbx
  41752e:	0f 82 93 f7 ff ff    	jb     416cc7 <fmt_fp+0x2c7>
		if (!*a) a++;
--
  417538:	85 c0                	test   eax,eax
  41753a:	48 0f 44 ea          	cmove  rbp,rdx
  41753e:	e9 d9 f7 ff ff       	jmp    416d1c <fmt_fp+0x31c>
  417543:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		char *s = (t&32)?"inf":"INF";
--
  417556:	8b 44 24 20          	mov    eax,DWORD PTR [rsp+0x20]
  41755a:	83 e0 20             	and    eax,0x20
  41755d:	75 0e                	jne    41756d <fmt_fp+0xb6d>
  41755f:	48 ba 67 1e fc ff ff 	movabs rdx,0xfffffffffffc1e67
  417566:	ff ff ff 
--
  417582:	4d 8d 24 17          	lea    r12,[r15+rdx*1]
  417586:	85 c0                	test   eax,eax
  417588:	0f 84 87 02 00 00    	je     417815 <fmt_fp+0xe15>
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41758e:	39 6c 24 58          	cmp    DWORD PTR [rsp+0x58],ebp
  417592:	0f 9e c3             	setle  bl
  417595:	f7 44 24 14 00 20 00 	test   DWORD PTR [rsp+0x14],0x2000
  41759c:	00 
  41759d:	0f 85 de 00 00 00    	jne    417681 <fmt_fp+0xc81>
  4175a3:	84 db                	test   bl,bl
  4175a5:	0f 85 d6 00 00 00    	jne    417681 <fmt_fp+0xc81>
	l = w - l;
  4175ab:	8b 4c 24 58          	mov    ecx,DWORD PTR [rsp+0x58]
--
  4175c8:	29 e9                	sub    ecx,ebp
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  4175ca:	39 c1                	cmp    ecx,eax
  4175cc:	89 4c 24 08          	mov    DWORD PTR [rsp+0x8],ecx
  4175d0:	0f 4e c1             	cmovle eax,ecx
--
  4175dd:	ff ff ff 
  4175e0:	4c 01 f8             	add    rax,r15
  4175e3:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  4175e5:	8b 4c 24 08          	mov    ecx,DWORD PTR [rsp+0x8]
  4175e9:	4c 8b 14 24          	mov    r10,QWORD PTR [rsp]
  4175ed:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  4175f3:	0f 8e 3b 1b 00 00    	jle    419134 <fmt_fp+0x2734>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
--
  417620:	83 e0 20             	and    eax,0x20
  417623:	89 c6                	mov    esi,eax
  417625:	0f 84 3d 02 00 00    	je     417868 <fmt_fp+0xe68>
	for (; l >= sizeof pad; l -= sizeof pad)
  41762b:	49 89 da             	mov    r10,rbx
  41762e:	89 eb                	mov    ebx,ebp
  417630:	8b 2c 24             	mov    ebp,DWORD PTR [rsp]
  417633:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  41763a:	7e 4b                	jle    417687 <fmt_fp+0xc87>
  41763c:	41 8d 85 00 e9 ff ff 	lea    eax,[r13-0x1700]
  417643:	3d 00 e9 ff 7f       	cmp    eax,0x7fffe900
  417648:	0f 86 3b ed ff ff    	jbe    416389 <fmt_fp.cold>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
--
	for (; l >= sizeof pad; l -= sizeof pad)
  417659:	44 89 e9             	mov    ecx,r13d
  41765c:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  417663:	77 eb                	ja     417650 <fmt_fp+0xc50>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417665:	85 f6                	test   esi,esi
  417667:	75 26                	jne    41768f <fmt_fp+0xc8f>
  417669:	48 b8 60 e3 fb ff ff 	movabs rax,0xfffffffffffbe360
  417670:	ff ff ff 
--
  417679:	4c 89 d7             	mov    rdi,r10
  41767c:	4c 01 f8             	add    rax,r15
  41767f:	ff d0                	call   rax
  417681:	41 8b 36             	mov    esi,DWORD PTR [r14]
  417684:	83 e6 20             	and    esi,0x20
  417687:	85 f6                	test   esi,esi
  417689:	0f 84 4a 0c 00 00    	je     4182d9 <fmt_fp+0x18d9>
		pad(f, ' ', w, 3+pl, fl^LEFT_ADJ);
  41768f:	8b 44 24 14          	mov    eax,DWORD PTR [rsp+0x14]
--
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  417696:	a9 00 20 01 00       	test   eax,0x12000
  41769b:	0f 85 cf 00 00 00    	jne    417770 <fmt_fp+0xd70>
  4176a1:	84 db                	test   bl,bl
  4176a3:	0f 85 c7 00 00 00    	jne    417770 <fmt_fp+0xd70>
	l = w - l;
  4176a9:	44 8b 6c 24 58       	mov    r13d,DWORD PTR [rsp+0x58]
--
  4176c7:	41 29 ed             	sub    r13d,ebp
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  4176ca:	41 39 c5             	cmp    r13d,eax
  4176cd:	41 0f 4e c5          	cmovle eax,r13d
  4176d1:	48 63 d0             	movsxd rdx,eax
--
  4176db:	ff ff ff 
  4176de:	4c 01 f8             	add    rax,r15
  4176e1:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  4176e3:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  4176ea:	4c 8b 14 24          	mov    r10,QWORD PTR [rsp]
  4176ee:	0f 8e 35 1a 00 00    	jle    419129 <fmt_fp+0x2729>
--
  41770d:	0f 1f 00             	nop    DWORD PTR [rax]
  417710:	83 e1 20             	and    ecx,0x20
  417713:	0f 84 17 01 00 00    	je     417830 <fmt_fp+0xe30>
	for (; l >= sizeof pad; l -= sizeof pad)
  417719:	4d 89 ea             	mov    r10,r13
  41771c:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  417723:	7e 4b                	jle    417770 <fmt_fp+0xd70>
  417725:	41 8d 84 24 00 e9 ff 	lea    eax,[r12-0x1700]
  41772c:	ff 
  41772d:	3d 00 e9 ff 7f       	cmp    eax,0x7fffe900
  417732:	0f 86 77 ee ff ff    	jbe    4165af <fmt_fp.cold+0x226>
  417738:	41 81 ec 00 01 00 00 	sub    r12d,0x100
--
	for (; l >= sizeof pad; l -= sizeof pad)
  417741:	45 89 e5             	mov    r13d,r12d
  417744:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  41774b:	77 eb                	ja     417738 <fmt_fp+0xd38>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41774d:	85 d2                	test   edx,edx
  41774f:	75 1f                	jne    417770 <fmt_fp+0xd70>
  417751:	48 b8 60 e3 fb ff ff 	movabs rax,0xfffffffffffbe360
  417758:	ff ff ff 
--
  417761:	4c 89 d7             	mov    rdi,r10
  417764:	4c 01 f8             	add    rax,r15
  417767:	ff d0                	call   rax
  417769:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		return MAX(w, 3+pl);
  417770:	8b 44 24 58          	mov    eax,DWORD PTR [rsp+0x58]
  417774:	39 e8                	cmp    eax,ebp
  417776:	0f 4c c5             	cmovl  eax,ebp
	}
--
	j = p - ((t|32)!='f')*e - ((t|32)=='g' && p);
  417790:	31 c9                	xor    ecx,ecx
  417792:	41 83 fb 66          	cmp    r11d,0x66
	if (a<z) for (i=10, e=9*(r-a); *a>=i; i*=10, e++);
  417796:	8b 55 00             	mov    edx,DWORD PTR [rbp+0x0]
--
  4177a3:	8d 3c c0             	lea    edi,[rax+rax*8]
  4177a6:	b8 0a 00 00 00       	mov    eax,0xa
  4177ab:	83 fa 09             	cmp    edx,0x9
  4177ae:	76 0c                	jbe    4177bc <fmt_fp+0xdbc>
  4177b0:	8d 04 80             	lea    eax,[rax+rax*4]
  4177b3:	83 c7 01             	add    edi,0x1
  4177b6:	01 c0                	add    eax,eax
  4177b8:	39 d0                	cmp    eax,edx
  4177ba:	76 f4                	jbe    4177b0 <fmt_fp+0xdb0>
	j = p - ((t|32)!='f')*e - ((t|32)=='g' && p);
--
  4177bf:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  4177c2:	29 c8                	sub    eax,ecx
  4177c4:	e9 96 f5 ff ff       	jmp    416d5f <fmt_fp+0x35f>
	if (y) y *= 0x1p28, e2-=28;
  4177c9:	48 b8 d4 22 fc ff ff 	movabs rax,0xfffffffffffc22d4
--
  4177d7:	42 d8 0c 38          	fmul   DWORD PTR [rax+r15*1]
  4177db:	44 89 4c 24 60       	mov    DWORD PTR [rsp+0x60],r9d
  4177e0:	e9 7a f3 ff ff       	jmp    416b5f <fmt_fp+0x15f>
	} else if (fl & PAD_POS) {
  4177e5:	bb 02 00 00 00       	mov    ebx,0x2
--
  417808:	4c 01 f8             	add    rax,r15
  41780b:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  417810:	e9 a9 f2 ff ff       	jmp    416abe <fmt_fp+0xbe>
		if (y!=y) s=(t&32)?"nan":"NAN";
  417815:	48 b8 6b 1e fc ff ff 	movabs rax,0xfffffffffffc1e6b
  41781c:	ff ff ff 
  41781f:	4d 8d 24 07          	lea    r12,[r15+rax*1]
  417823:	e9 66 fd ff ff       	jmp    41758e <fmt_fp+0xb8e>
  417828:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41782f:	00 
--
  417838:	49 8d 04 1f          	lea    rax,[r15+rbx*1]
  41783c:	4c 89 ef             	mov    rdi,r13
  41783f:	ff d0                	call   rax
  417841:	41 8b 0e             	mov    ecx,DWORD PTR [r14]
  417844:	89 ca                	mov    edx,ecx
  417846:	83 e2 20             	and    edx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  417849:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  417850:	0f 8e be 16 00 00    	jle    418f14 <fmt_fp+0x2514>
  417856:	41 81 ec 00 01 00 00 	sub    r12d,0x100
  41785d:	e9 ae fe ff ff       	jmp    417710 <fmt_fp+0xd10>
  417862:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
--
  417875:	48 89 df             	mov    rdi,rbx
  417878:	4c 01 f8             	add    rax,r15
  41787b:	ff d0                	call   rax
  41787d:	41 8b 06             	mov    eax,DWORD PTR [r14]
	for (; l >= sizeof pad; l -= sizeof pad)
--
  417885:	83 e6 20             	and    esi,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  417888:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  41788f:	0f 8e 5d 16 00 00    	jle    418ef2 <fmt_fp+0x24f2>
  417895:	41 81 ed 00 01 00 00 	sub    r13d,0x100
  41789c:	e9 7f fd ff ff       	jmp    417620 <fmt_fp+0xc20>
			if ((*d/i & 1) || (i==1000000000 && d>a && (d[-1]&1)))
  4178a1:	a8 01                	test   al,0x1
  4178a3:	0f 84 93 16 00 00    	je     418f3c <fmt_fp+0x253c>
				round += 2;
  4178a9:	48 b8 20 23 fc ff ff 	movabs rax,0xfffffffffffc2320
--
			if (x<i/2) small=0x0.8p0;
  4178b7:	d1 f9                	sar    ecx,1
  4178b9:	44 39 c1             	cmp    ecx,r8d
  4178bc:	0f 87 d1 17 00 00    	ja     419093 <fmt_fp+0x2693>
			else if (x==i/2 && d+1==z) small=0x1.0p0;
  4178c2:	0f 84 f4 17 00 00    	je     4190bc <fmt_fp+0x26bc>
  4178c8:	48 b8 c8 22 fc ff ff 	movabs rax,0xfffffffffffc22c8
  4178cf:	ff ff ff 
--
  4178e4:	44 8b 64 24 28       	mov    r12d,DWORD PTR [rsp+0x28]
  4178e9:	45 85 e4             	test   r12d,r12d
  4178ec:	74 14                	je     417902 <fmt_fp+0xf02>
  4178ee:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  4178f3:	80 38 2d             	cmp    BYTE PTR [rax],0x2d
  4178f6:	75 0e                	jne    417906 <fmt_fp+0xf06>
  4178f8:	dd d8                	fstp   st(0)
  4178fa:	d9 c9                	fxch   st(1)
  4178fc:	d9 e0                	fchs   
  4178fe:	d9 c9                	fxch   st(1)
  417900:	eb 06                	jmp    417908 <fmt_fp+0xf08>
  417902:	dd d9                	fstp   st(1)
  417904:	eb 02                	jmp    417908 <fmt_fp+0xf08>
  417906:	dd d9                	fstp   st(1)
			if (round+small != round) {
--
  417912:	dd d8                	fstp   st(0)
  417914:	0f 8a 9e 10 00 00    	jp     4189b8 <fmt_fp+0x1fb8>
  41791a:	0f 85 98 10 00 00    	jne    4189b8 <fmt_fp+0x1fb8>
			*d -= x;
  417920:	89 06                	mov    DWORD PTR [rsi],eax
--
  417922:	48 83 c6 04          	add    rsi,0x4
		if (z>d+1) z=d+1;
  417926:	48 39 f3             	cmp    rbx,rsi
  417929:	48 0f 47 de          	cmova  rbx,rsi
	for (; z>a && !z[-1]; z--);
  41792d:	48 39 dd             	cmp    rbp,rbx
  417930:	72 0f                	jb     417941 <fmt_fp+0xf41>
  417932:	eb 16                	jmp    41794a <fmt_fp+0xf4a>
  417934:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  417938:	48 83 eb 04          	sub    rbx,0x4
  41793c:	48 39 eb             	cmp    rbx,rbp
  41793f:	76 09                	jbe    41794a <fmt_fp+0xf4a>
  417941:	44 8b 43 fc          	mov    r8d,DWORD PTR [rbx-0x4]
  417945:	45 85 c0             	test   r8d,r8d
  417948:	74 ee                	je     417938 <fmt_fp+0xf38>
	if ((t|32)=='g') {
  41794a:	41 83 fb 67          	cmp    r11d,0x67
  41794e:	0f 84 61 0a 00 00    	je     4183b5 <fmt_fp+0x19b5>
	if (p > INT_MAX-1-(p || (fl&ALT_FORM)))
  417954:	8b 34 24             	mov    esi,DWORD PTR [rsp]
  417957:	85 f6                	test   esi,esi
  417959:	0f 85 46 09 00 00    	jne    4182a5 <fmt_fp+0x18a5>
	l = 1 + p + (p || (fl&ALT_FORM));
  41795f:	44 8b 44 24 14       	mov    r8d,DWORD PTR [rsp+0x14]
--
  417981:	83 c8 20             	or     eax,0x20
  417984:	89 44 24 08          	mov    DWORD PTR [rsp+0x8],eax
  417988:	83 f8 66             	cmp    eax,0x66
  41798b:	0f 84 23 0f 00 00    	je     4188b4 <fmt_fp+0x1eb4>
		estr=fmt_u(e<0 ? -e : e, ebuf);
  417991:	89 fe                	mov    esi,edi
--
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  4179a3:	85 ff                	test   edi,edi
  4179a5:	74 49                	je     4179f0 <fmt_fp+0xff0>
  4179a7:	49 b9 cd cc cc cc cc 	movabs r9,0xcccccccccccccccd
  4179ae:	cc cc cc 
--
  4179d8:	48 89 f0             	mov    rax,rsi
  4179db:	48 89 d6             	mov    rsi,rdx
  4179de:	48 83 f8 09          	cmp    rax,0x9
  4179e2:	77 d4                	ja     4179b8 <fmt_fp+0xfb8>
		while(ebuf-estr<2) *--estr='0';
  4179e4:	4c 89 e0             	mov    rax,r12
  4179e7:	48 29 c8             	sub    rax,rcx
  4179ea:	48 83 f8 01          	cmp    rax,0x1
  4179ee:	7f 13                	jg     417a03 <fmt_fp+0x1003>
  4179f0:	48 83 e9 01          	sub    rcx,0x1
  4179f4:	4c 89 e0             	mov    rax,r12
  4179f7:	c6 01 30             	mov    BYTE PTR [rcx],0x30
  4179fa:	48 29 c8             	sub    rax,rcx
  4179fd:	48 83 f8 01          	cmp    rax,0x1
  417a01:	7e ed                	jle    4179f0 <fmt_fp+0xff0>
		*--estr = (e<0 ? '-' : '+');
--
  417a24:	40 88 79 fe          	mov    BYTE PTR [rcx-0x2],dil
		if (ebuf-estr > INT_MAX-l) return -1;
  417a28:	4d 39 d4             	cmp    r12,r10
  417a2b:	0f 8f 8d 08 00 00    	jg     4182be <fmt_fp+0x18be>
		l += ebuf-estr;
  417a31:	45 01 e0             	add    r8d,r12d
--
  417a3c:	19 c0                	sbb    eax,eax
  417a3e:	05 ff ff ff 7f       	add    eax,0x7fffffff
  417a43:	44 39 c0             	cmp    eax,r8d
  417a46:	0f 8c 72 08 00 00    	jl     4182be <fmt_fp+0x18be>
	pad(f, ' ', w, pl+l, fl);
  417a4c:	41 01 f8             	add    r8d,edi
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  417a4f:	44 3b 44 24 58       	cmp    r8d,DWORD PTR [rsp+0x58]
  417a54:	0f 9d 44 24 20       	setge  BYTE PTR [rsp+0x20]
  417a59:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
--
  417a63:	f7 44 24 14 00 20 01 	test   DWORD PTR [rsp+0x14],0x12000
  417a6a:	00 
  417a6b:	0f 85 c3 00 00 00    	jne    417b34 <fmt_fp+0x1134>
  417a71:	84 c0                	test   al,al
  417a73:	0f 85 bb 00 00 00    	jne    417b34 <fmt_fp+0x1134>
	l = w - l;
  417a79:	8b 4c 24 58          	mov    ecx,DWORD PTR [rsp+0x58]
--
  417a86:	4c 8d ac 24 90 00 00 	lea    r13,[rsp+0x90]
  417a8d:	00 
  417a8e:	39 c1                	cmp    ecx,eax
  417a90:	89 4c 24 28          	mov    DWORD PTR [rsp+0x28],ecx
  417a94:	be 20 00 00 00       	mov    esi,0x20
--
  417aa9:	ff ff ff 
  417aac:	4c 01 f8             	add    rax,r15
  417aaf:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  417ab1:	8b 4c 24 28          	mov    ecx,DWORD PTR [rsp+0x28]
--
  417ab5:	41 8b 06             	mov    eax,DWORD PTR [r14]
	for (; l >= sizeof pad; l -= sizeof pad)
  417ab8:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  417abe:	0f 8e ca 16 00 00    	jle    41918e <fmt_fp+0x278e>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
--
  417ada:	83 e0 20             	and    eax,0x20
  417add:	89 c6                	mov    esi,eax
  417adf:	0f 84 5b 06 00 00    	je     418140 <fmt_fp+0x1740>
	for (; l >= sizeof pad; l -= sizeof pad)
  417ae5:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  417aec:	7e 4e                	jle    417b3c <fmt_fp+0x113c>
  417aee:	41 8d 84 24 00 e9 ff 	lea    eax,[r12-0x1700]
  417af5:	ff 
  417af6:	3d 00 e9 ff 7f       	cmp    eax,0x7fffe900
  417afb:	0f 86 d1 ec ff ff    	jbe    4167d2 <fmt_fp.cold+0x449>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
--
	for (; l >= sizeof pad; l -= sizeof pad)
  417b0c:	44 89 e1             	mov    ecx,r12d
  417b0f:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  417b16:	77 eb                	ja     417b03 <fmt_fp+0x1103>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417b18:	85 f6                	test   esi,esi
  417b1a:	75 28                	jne    417b44 <fmt_fp+0x1144>
  417b1c:	48 b8 60 e3 fb ff ff 	movabs rax,0xfffffffffffbe360
  417b23:	ff ff ff 
--
  417b2c:	4c 89 ef             	mov    rdi,r13
  417b2f:	4c 01 f8             	add    rax,r15
  417b32:	ff d0                	call   rax
  417b34:	41 8b 06             	mov    eax,DWORD PTR [r14]
  417b37:	83 e0 20             	and    eax,0x20
  417b3a:	89 c6                	mov    esi,eax
  417b3c:	85 f6                	test   esi,esi
  417b3e:	0f 84 88 0d 00 00    	je     4188cc <fmt_fp+0x1ecc>
	pad(f, '0', w, pl+l, fl^ZERO_PAD);
  417b44:	8b 44 24 14          	mov    eax,DWORD PTR [rsp+0x14]
--
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  417b4d:	a9 00 20 01 00       	test   eax,0x12000
  417b52:	0f 85 d0 00 00 00    	jne    417c28 <fmt_fp+0x1228>
  417b58:	80 7c 24 20 00       	cmp    BYTE PTR [rsp+0x20],0x0
  417b5d:	0f 85 c5 00 00 00    	jne    417c28 <fmt_fp+0x1228>
	l = w - l;
  417b63:	44 8b 4c 24 58       	mov    r9d,DWORD PTR [rsp+0x58]
--
  417b72:	4c 8d ac 24 90 00 00 	lea    r13,[rsp+0x90]
  417b79:	00 
  417b7a:	41 39 c1             	cmp    r9d,eax
  417b7d:	44 89 4c 24 28       	mov    DWORD PTR [rsp+0x28],r9d
  417b82:	be 30 00 00 00       	mov    esi,0x30
--
  417b98:	ff ff ff 
  417b9b:	4c 01 f8             	add    rax,r15
  417b9e:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  417ba0:	44 8b 4c 24 28       	mov    r9d,DWORD PTR [rsp+0x28]
--
  417ba5:	41 8b 06             	mov    eax,DWORD PTR [r14]
	for (; l >= sizeof pad; l -= sizeof pad)
  417ba8:	41 81 f9 ff 00 00 00 	cmp    r9d,0xff
  417baf:	0f 8e b0 15 00 00    	jle    419165 <fmt_fp+0x2765>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
--
  417bc8:	48 89 7c 24 28       	mov    QWORD PTR [rsp+0x28],rdi
  417bcd:	83 e6 20             	and    esi,0x20
  417bd0:	0f 84 2a 05 00 00    	je     418100 <fmt_fp+0x1700>
	for (; l >= sizeof pad; l -= sizeof pad)
  417bd6:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  417bdd:	7e 49                	jle    417c28 <fmt_fp+0x1228>
  417bdf:	41 8d 84 24 00 e9 ff 	lea    eax,[r12-0x1700]
  417be6:	ff 
  417be7:	3d 00 e9 ff 7f       	cmp    eax,0x7fffe900
  417bec:	0f 86 03 e9 ff ff    	jbe    4164f5 <fmt_fp.cold+0x16c>
  417bf2:	41 81 ec 00 01 00 00 	sub    r12d,0x100
--
	for (; l >= sizeof pad; l -= sizeof pad)
  417bfb:	45 89 e1             	mov    r9d,r12d
  417bfe:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  417c05:	77 eb                	ja     417bf2 <fmt_fp+0x11f2>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417c07:	85 d2                	test   edx,edx
  417c09:	75 1d                	jne    417c28 <fmt_fp+0x1228>
  417c0b:	48 b8 60 e3 fb ff ff 	movabs rax,0xfffffffffffbe360
  417c12:	ff ff ff 
--
  417c1b:	4c 89 ef             	mov    rdi,r13
  417c1e:	4c 01 f8             	add    rax,r15
  417c21:	ff d0                	call   rax
  417c23:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	if ((t|32)=='f') {
  417c28:	83 7c 24 08 66       	cmp    DWORD PTR [rsp+0x8],0x66
  417c2d:	0f 84 48 08 00 00    	je     41847b <fmt_fp+0x1a7b>
		for (d=a; d<z && p>=0; d++) {
  417c33:	4c 63 24 24          	movsxd r12,DWORD PTR [rsp]
		if (z<=a) z=a+1;
  417c37:	48 8d 45 04          	lea    rax,[rbp+0x4]
  417c3b:	48 39 dd             	cmp    rbp,rbx
  417c3e:	48 0f 43 d8          	cmovae rbx,rax
		for (d=a; d<z && p>=0; d++) {
  417c42:	45 85 e4             	test   r12d,r12d
  417c45:	0f 88 fd 00 00 00    	js     417d48 <fmt_fp+0x1348>
  417c4b:	48 39 eb             	cmp    rbx,rbp
  417c4e:	0f 86 f4 00 00 00    	jbe    417d48 <fmt_fp+0x1348>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
--
  417c9b:	4c 89 df             	mov    rdi,r11
  417c9e:	48 85 f6             	test   rsi,rsi
  417ca1:	0f 84 79 03 00 00    	je     418020 <fmt_fp+0x1620>
  417ca7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  417cae:	00 00 
--
  417cd4:	48 89 f0             	mov    rax,rsi
  417cd7:	48 89 d6             	mov    rsi,rdx
  417cda:	48 83 f8 09          	cmp    rax,0x9
  417cde:	77 d0                	ja     417cb0 <fmt_fp+0x12b0>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
--
			if (s==buf+9) *--s='0';
  417ce3:	48 8d 54 24 70       	lea    rdx,[rsp+0x70]
  417ce8:	4c 39 df             	cmp    rdi,r11
  417ceb:	0f 84 32 03 00 00    	je     418023 <fmt_fp+0x1623>
			if (d!=a) while (s>buf) *--s='0';
  417cf1:	4c 39 74 24 08       	cmp    QWORD PTR [rsp+0x8],r14
  417cf6:	0f 85 b4 01 00 00    	jne    417eb0 <fmt_fp+0x14b0>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417cfc:	41 83 e0 20          	and    r8d,0x20
  417d00:	0f 84 3f 03 00 00    	je     418045 <fmt_fp+0x1645>
				if (p>0||(fl&ALT_FORM)) out(f, ".", 1);
  417d06:	8b 44 24 14          	mov    eax,DWORD PTR [rsp+0x14]
--
  417d0d:	83 e0 08             	and    eax,0x8
  417d10:	44 09 e0             	or     eax,r12d
  417d13:	0f 85 67 03 00 00    	jne    418080 <fmt_fp+0x1680>
			out(f, s, MIN(buf+9-s, p));
  417d19:	4d 89 da             	mov    r10,r11
--
  417d2f:	4d 63 e1             	movsxd r12,r9d
		for (d=a; d<z && p>=0; d++) {
  417d32:	4c 39 34 24          	cmp    QWORD PTR [rsp],r14
  417d36:	76 09                	jbe    417d41 <fmt_fp+0x1341>
  417d38:	45 85 e4             	test   r12d,r12d
--
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  417d53:	8b 1c 24             	mov    ebx,DWORD PTR [rsp]
  417d56:	81 fb 00 01 00 00    	cmp    ebx,0x100
  417d5c:	0f 8f 2d 0c 00 00    	jg     41898f <fmt_fp+0x1f8f>
  417d62:	48 63 eb             	movsxd rbp,ebx
  417d65:	4c 8d ac 24 90 00 00 	lea    r13,[rsp+0x90]
--
  417d7f:	48 89 ea             	mov    rdx,rbp
  417d82:	4c 89 ef             	mov    rdi,r13
  417d85:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  417d87:	81 fb 00 01 00 00    	cmp    ebx,0x100
  417d8d:	0f 85 c7 13 00 00    	jne    41915a <fmt_fp+0x275a>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417d93:	48 bd 60 e3 fb ff ff 	movabs rbp,0xfffffffffffbe360
--
  417db0:	89 d0                	mov    eax,edx
  417db2:	83 e0 20             	and    eax,0x20
  417db5:	0f 84 0d 03 00 00    	je     4180c8 <fmt_fp+0x16c8>
	for (; l >= sizeof pad; l -= sizeof pad)
  417dbb:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  417dc2:	76 14                	jbe    417dd8 <fmt_fp+0x13d8>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
--
  417dcd:	89 d0                	mov    eax,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  417dcf:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  417dd6:	77 ee                	ja     417dc6 <fmt_fp+0x13c6>
	out(f, pad, l);
--
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417ddb:	85 c0                	test   eax,eax
  417ddd:	0f 84 88 05 00 00    	je     41836b <fmt_fp+0x196b>
	pad(f, ' ', w, pl+l, fl^LEFT_ADJ);
  417de3:	8b 44 24 14          	mov    eax,DWORD PTR [rsp+0x14]
--
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  417dea:	a9 00 20 01 00       	test   eax,0x12000
  417def:	0f 85 a4 00 00 00    	jne    417e99 <fmt_fp+0x1499>
  417df5:	80 7c 24 20 00       	cmp    BYTE PTR [rsp+0x20],0x0
  417dfa:	0f 85 99 00 00 00    	jne    417e99 <fmt_fp+0x1499>
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  417e00:	b8 00 01 00 00       	mov    eax,0x100
--
  417e0f:	4c 8d ac 24 90 00 00 	lea    r13,[rsp+0x90]
  417e16:	00 
  417e17:	41 39 c4             	cmp    r12d,eax
  417e1a:	be 20 00 00 00       	mov    esi,0x20
  417e1f:	4c 89 ef             	mov    rdi,r13
--
  417e30:	ff ff ff 
  417e33:	4c 01 f8             	add    rax,r15
  417e36:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  417e38:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  417e3f:	0f 8e 0a 13 00 00    	jle    41914f <fmt_fp+0x274f>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
--
  417e5a:	89 c1                	mov    ecx,eax
  417e5c:	83 e1 20             	and    ecx,0x20
  417e5f:	0f 84 2b 02 00 00    	je     418090 <fmt_fp+0x1690>
	for (; l >= sizeof pad; l -= sizeof pad)
  417e65:	81 fd ff 00 00 00    	cmp    ebp,0xff
  417e6b:	7e 2c                	jle    417e99 <fmt_fp+0x1499>
  417e6d:	8d 85 00 e9 ff ff    	lea    eax,[rbp-0x1700]
  417e73:	3d 00 e9 ff 7f       	cmp    eax,0x7fffe900
  417e78:	0f 86 ea e7 ff ff    	jbe    416668 <fmt_fp.cold+0x2df>
  417e7e:	81 ed 00 01 00 00    	sub    ebp,0x100
--
	for (; l >= sizeof pad; l -= sizeof pad)
  417e86:	41 89 ec             	mov    r12d,ebp
  417e89:	81 fd ff 00 00 00    	cmp    ebp,0xff
  417e8f:	77 ed                	ja     417e7e <fmt_fp+0x147e>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417e91:	85 d2                	test   edx,edx
  417e93:	0f 84 86 10 00 00    	je     418f1f <fmt_fp+0x251f>
	return MAX(w, pl+l);
  417e99:	8b 5c 24 40          	mov    ebx,DWORD PTR [rsp+0x40]
  417e9d:	8b 44 24 58          	mov    eax,DWORD PTR [rsp+0x58]
  417ea1:	39 c3                	cmp    ebx,eax
  417ea3:	0f 4d c3             	cmovge eax,ebx
  417ea6:	e9 ce f8 ff ff       	jmp    417779 <fmt_fp+0xd79>
  417eab:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
			if (d!=a) while (s>buf) *--s='0';
  417eb0:	48 39 d7             	cmp    rdi,rdx
  417eb3:	0f 86 42 0a 00 00    	jbe    4188fb <fmt_fp+0x1efb>
  417eb9:	4c 8d 57 ff          	lea    r10,[rdi-0x1]
--
  417ec0:	be 01 00 00 00       	mov    esi,0x1
  417ec5:	48 29 d0             	sub    rax,rdx
  417ec8:	49 39 d2             	cmp    r10,rdx
  417ecb:	48 0f 43 f0          	cmovae rsi,rax
  417ecf:	48 83 e8 01          	sub    rax,0x1
  417ed3:	48 83 f8 0e          	cmp    rax,0xe
  417ed7:	0f 86 a7 0a 00 00    	jbe    418984 <fmt_fp+0x1f84>
  417edd:	49 39 d2             	cmp    r10,rdx
  417ee0:	0f 82 9e 0a 00 00    	jb     418984 <fmt_fp+0x1f84>
  417ee6:	48 bd 60 23 fc ff ff 	movabs rbp,0xfffffffffffc2360
--
  417f10:	0f 11 40 f0          	movups XMMWORD PTR [rax-0x10],xmm0
  417f14:	48 83 e8 10          	sub    rax,0x10
  417f18:	4c 39 c8             	cmp    rax,r9
  417f1b:	75 f3                	jne    417f10 <fmt_fp+0x1510>
  417f1d:	49 89 f1             	mov    r9,rsi
  417f20:	48 89 f8             	mov    rax,rdi
  417f23:	49 83 e1 f0          	and    r9,0xfffffffffffffff0
  417f27:	4c 29 c8             	sub    rax,r9
  417f2a:	4c 39 ce             	cmp    rsi,r9
  417f2d:	0f 84 86 00 00 00    	je     417fb9 <fmt_fp+0x15b9>
  417f33:	4c 29 ce             	sub    rsi,r9
  417f36:	48 8d 6e ff          	lea    rbp,[rsi-0x1]
  417f3a:	48 83 fd 06          	cmp    rbp,0x6
  417f3e:	76 27                	jbe    417f67 <fmt_fp+0x1567>
  417f40:	48 89 fd             	mov    rbp,rdi
--
  417f5b:	49 83 e1 f8          	and    r9,0xfffffffffffffff8
  417f5f:	4c 29 c8             	sub    rax,r9
  417f62:	4c 39 ce             	cmp    rsi,r9
  417f65:	74 52                	je     417fb9 <fmt_fp+0x15b9>
  417f67:	48 8d 70 ff          	lea    rsi,[rax-0x1]
  417f6b:	c6 40 ff 30          	mov    BYTE PTR [rax-0x1],0x30
  417f6f:	48 39 f2             	cmp    rdx,rsi
  417f72:	73 45                	jae    417fb9 <fmt_fp+0x15b9>
  417f74:	48 8d 70 fe          	lea    rsi,[rax-0x2]
  417f78:	c6 40 fe 30          	mov    BYTE PTR [rax-0x2],0x30
  417f7c:	48 39 f2             	cmp    rdx,rsi
  417f7f:	73 38                	jae    417fb9 <fmt_fp+0x15b9>
  417f81:	48 8d 70 fd          	lea    rsi,[rax-0x3]
  417f85:	c6 40 fd 30          	mov    BYTE PTR [rax-0x3],0x30
  417f89:	48 39 f2             	cmp    rdx,rsi
  417f8c:	73 2b                	jae    417fb9 <fmt_fp+0x15b9>
  417f8e:	48 8d 70 fc          	lea    rsi,[rax-0x4]
  417f92:	c6 40 fc 30          	mov    BYTE PTR [rax-0x4],0x30
  417f96:	48 39 f2             	cmp    rdx,rsi
  417f99:	73 1e                	jae    417fb9 <fmt_fp+0x15b9>
  417f9b:	48 8d 70 fb          	lea    rsi,[rax-0x5]
  417f9f:	c6 40 fb 30          	mov    BYTE PTR [rax-0x5],0x30
  417fa3:	48 39 f2             	cmp    rdx,rsi
  417fa6:	73 11                	jae    417fb9 <fmt_fp+0x15b9>
  417fa8:	48 8d 70 fa          	lea    rsi,[rax-0x6]
  417fac:	c6 40 fa 30          	mov    BYTE PTR [rax-0x6],0x30
  417fb0:	48 39 f2             	cmp    rdx,rsi
  417fb3:	73 04                	jae    417fb9 <fmt_fp+0x15b9>
  417fb5:	c6 40 f9 30          	mov    BYTE PTR [rax-0x7],0x30
--
  417fc3:	45 89 e1             	mov    r9d,r12d
  417fc6:	48 29 fd             	sub    rbp,rdi
  417fc9:	49 39 d2             	cmp    r10,rdx
  417fcc:	48 0f 42 e8          	cmovb  rbp,rax
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
--
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417fdd:	45 85 c0             	test   r8d,r8d
  417fe0:	0f 85 42 fd ff ff    	jne    417d28 <fmt_fp+0x1328>
			out(f, s, MIN(buf+9-s, p));
  417fe6:	4d 39 d4             	cmp    r12,r10
  417fe9:	4c 89 e6             	mov    rsi,r12
  417fec:	4c 89 5c 24 38       	mov    QWORD PTR [rsp+0x38],r11
--
  418005:	4c 89 54 24 28       	mov    QWORD PTR [rsp+0x28],r10
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41800a:	ff d0                	call   rax
  41800c:	4c 8b 5c 24 38       	mov    r11,QWORD PTR [rsp+0x38]
  418011:	44 8b 4c 24 30       	mov    r9d,DWORD PTR [rsp+0x30]
  418016:	4c 8b 54 24 28       	mov    r10,QWORD PTR [rsp+0x28]
  41801b:	e9 08 fd ff ff       	jmp    417d28 <fmt_fp+0x1328>
  418020:	44 8b 03             	mov    r8d,DWORD PTR [rbx]
			if (s==buf+9) *--s='0';
  418023:	c6 44 24 78 30       	mov    BYTE PTR [rsp+0x78],0x30
			if (d!=a) while (s>buf) *--s='0';
  418028:	4c 39 74 24 08       	cmp    QWORD PTR [rsp+0x8],r14
  41802d:	0f 85 87 01 00 00    	jne    4181ba <fmt_fp+0x17ba>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418033:	41 83 e0 20          	and    r8d,0x20
--
  41803a:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41803f:	0f 85 c1 fc ff ff    	jne    417d06 <fmt_fp+0x1306>
  418045:	4c 89 5c 24 28       	mov    QWORD PTR [rsp+0x28],r11
  41804a:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  41804f:	48 89 da             	mov    rdx,rbx
  418052:	be 01 00 00 00       	mov    esi,0x1
  418057:	ff d0                	call   rax
				if (p>0||(fl&ALT_FORM)) out(f, ".", 1);
  418059:	8b 44 24 14          	mov    eax,DWORD PTR [rsp+0x14]
--
				if (p>0||(fl&ALT_FORM)) out(f, ".", 1);
  41806f:	44 09 e0             	or     eax,r12d
  418072:	0f 85 01 01 00 00    	jne    418179 <fmt_fp+0x1779>
  418078:	45 31 c9             	xor    r9d,r9d
  41807b:	e9 57 ff ff ff       	jmp    417fd7 <fmt_fp+0x15d7>
			out(f, s, MIN(buf+9-s, p));
  418080:	4d 89 da             	mov    r10,r11
  418083:	49 29 ea             	sub    r10,rbp
  418086:	e9 9d fc ff ff       	jmp    417d28 <fmt_fp+0x1328>
  41808b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
--
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41809e:	49 8d 04 1f          	lea    rax,[r15+rbx*1]
  4180a2:	ff d0                	call   rax
  4180a4:	41 8b 0e             	mov    ecx,DWORD PTR [r14]
  4180a7:	89 ca                	mov    edx,ecx
  4180a9:	83 e2 20             	and    edx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  4180ac:	81 fd ff 00 00 00    	cmp    ebp,0xff
  4180b2:	0f 8e d9 fd ff ff    	jle    417e91 <fmt_fp+0x1491>
  4180b8:	81 ed 00 01 00 00    	sub    ebp,0x100
  4180be:	e9 99 fd ff ff       	jmp    417e5c <fmt_fp+0x145c>
  4180c3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
--
  4180d0:	49 8d 04 2f          	lea    rax,[r15+rbp*1]
  4180d4:	4c 89 ef             	mov    rdi,r13
  4180d7:	ff d0                	call   rax
  4180d9:	41 8b 16             	mov    edx,DWORD PTR [r14]
  4180dc:	89 d0                	mov    eax,edx
  4180de:	83 e0 20             	and    eax,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  4180e1:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  4180e8:	0f 86 ea fc ff ff    	jbe    417dd8 <fmt_fp+0x13d8>
  4180ee:	41 81 ec 00 01 00 00 	sub    r12d,0x100
  4180f5:	e9 b6 fc ff ff       	jmp    417db0 <fmt_fp+0x13b0>
  4180fa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
--
  41810d:	4c 89 ef             	mov    rdi,r13
  418110:	4c 01 f8             	add    rax,r15
  418113:	ff d0                	call   rax
  418115:	41 8b 36             	mov    esi,DWORD PTR [r14]
	for (; l >= sizeof pad; l -= sizeof pad)
--
  41811d:	83 e2 20             	and    edx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  418120:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  418127:	0f 8e da fa ff ff    	jle    417c07 <fmt_fp+0x1207>
  41812d:	41 81 ec 00 01 00 00 	sub    r12d,0x100
  418134:	e9 94 fa ff ff       	jmp    417bcd <fmt_fp+0x11cd>
  418139:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
--
  41814d:	4c 89 ef             	mov    rdi,r13
  418150:	4c 01 f8             	add    rax,r15
  418153:	ff d0                	call   rax
  418155:	41 8b 06             	mov    eax,DWORD PTR [r14]
	for (; l >= sizeof pad; l -= sizeof pad)
--
  41815d:	83 e6 20             	and    esi,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  418160:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  418167:	0f 8e ab f9 ff ff    	jle    417b18 <fmt_fp+0x1118>
  41816d:	41 81 ec 00 01 00 00 	sub    r12d,0x100
  418174:	e9 61 f9 ff ff       	jmp    417ada <fmt_fp+0x10da>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418179:	45 85 c0             	test   r8d,r8d
  41817c:	0f 85 fe fe ff ff    	jne    418080 <fmt_fp+0x1680>
  418182:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
  418187:	4c 89 5c 24 30       	mov    QWORD PTR [rsp+0x30],r11
--
  418199:	49 8d 3c 07          	lea    rdi,[r15+rax*1]
  41819d:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  4181a2:	ff d0                	call   rax
  4181a4:	44 8b 03             	mov    r8d,DWORD PTR [rbx]
  4181a7:	44 8b 4c 24 28       	mov    r9d,DWORD PTR [rsp+0x28]
  4181ac:	4c 8b 5c 24 30       	mov    r11,QWORD PTR [rsp+0x30]
  4181b1:	41 83 e0 20          	and    r8d,0x20
  4181b5:	e9 1d fe ff ff       	jmp    417fd7 <fmt_fp+0x15d7>
			if (s==buf+9) *--s='0';
  4181ba:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
  4181bf:	48 8d 54 24 70       	lea    rdx,[rsp+0x70]
  4181c4:	e9 f0 fc ff ff       	jmp    417eb9 <fmt_fp+0x14b9>
			if (s-buf==1 && (y||p>0||(fl&ALT_FORM))) *s++='.';
  4181c9:	c6 42 01 2e          	mov    BYTE PTR [rdx+0x1],0x2e
  4181cd:	48 83 c2 02          	add    rdx,0x2
  4181d1:	e9 bd ee ff ff       	jmp    417093 <fmt_fp+0x693>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4181d6:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
--
  4181e3:	48 89 ef             	mov    rdi,rbp
  4181e6:	4c 01 f8             	add    rax,r15
  4181e9:	ff d0                	call   rax
  4181eb:	41 8b 06             	mov    eax,DWORD PTR [r14]
  4181ee:	89 c6                	mov    esi,eax
  4181f0:	83 e6 20             	and    esi,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  4181f3:	81 fb ff 00 00 00    	cmp    ebx,0xff
  4181f9:	0f 8e 16 11 00 00    	jle    419315 <fmt_fp+0x2915>
  4181ff:	81 eb 00 01 00 00    	sub    ebx,0x100
  418205:	e9 d9 ef ff ff       	jmp    4171e3 <fmt_fp+0x7e3>
  41820a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
--
  418218:	49 8d 04 2f          	lea    rax,[r15+rbp*1]
  41821c:	4c 89 e7             	mov    rdi,r12
  41821f:	ff d0                	call   rax
  418221:	41 8b 06             	mov    eax,DWORD PTR [r14]
  418224:	89 c1                	mov    ecx,eax
  418226:	83 e1 20             	and    ecx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  418229:	81 fb ff 00 00 00    	cmp    ebx,0xff
  41822f:	0f 8e ea 10 00 00    	jle    41931f <fmt_fp+0x291f>
  418235:	81 eb 00 01 00 00    	sub    ebx,0x100
  41823b:	e9 42 f1 ff ff       	jmp    417382 <fmt_fp+0x982>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418240:	4c 89 f2             	mov    rdx,r14
--
  418248:	49 8d 04 1f          	lea    rax,[r15+rbx*1]
  41824c:	48 89 ef             	mov    rdi,rbp
  41824f:	ff d0                	call   rax
  418251:	41 8b 06             	mov    eax,DWORD PTR [r14]
  418254:	89 c1                	mov    ecx,eax
  418256:	83 e1 20             	and    ecx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  418259:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  418260:	0f 8e eb 07 00 00    	jle    418a51 <fmt_fp+0x2051>
  418266:	41 81 ed 00 01 00 00 	sub    r13d,0x100
  41826d:	e9 55 f0 ff ff       	jmp    4172c7 <fmt_fp+0x8c7>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418272:	4c 89 f2             	mov    rdx,r14
--
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418280:	49 8d 04 1f          	lea    rax,[r15+rbx*1]
  418284:	ff d0                	call   rax
  418286:	41 8b 0e             	mov    ecx,DWORD PTR [r14]
  418289:	89 ca                	mov    edx,ecx
  41828b:	83 e2 20             	and    edx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41828e:	81 fd ff 00 00 00    	cmp    ebp,0xff
  418294:	0f 8e af 07 00 00    	jle    418a49 <fmt_fp+0x2049>
  41829a:	81 ed 00 01 00 00    	sub    ebp,0x100
  4182a0:	e9 e1 f1 ff ff       	jmp    417486 <fmt_fp+0xa86>
	l = 1 + p + (p || (fl&ALT_FORM));
  4182a5:	8b 04 24             	mov    eax,DWORD PTR [rsp]
--
  4182ae:	83 c0 01             	add    eax,0x1
	if (p > INT_MAX-1-(p || (fl&ALT_FORM)))
  4182b1:	81 3c 24 fd ff ff 7f 	cmp    DWORD PTR [rsp],0x7ffffffd
  4182b8:	0f 8e b3 f6 ff ff    	jle    417971 <fmt_fp+0xf71>
			return -1;
  4182be:	b8 ff ff ff ff       	mov    eax,0xffffffff
  4182c3:	e9 b1 f4 ff ff       	jmp    417779 <fmt_fp+0xd79>
  4182c8:	c6 44 24 40 01       	mov    BYTE PTR [rsp+0x40],0x1
	if (p<0) p=6;
  4182cd:	c7 04 24 06 00 00 00 	mov    DWORD PTR [rsp],0x6
  4182d4:	e9 72 e8 ff ff       	jmp    416b4b <fmt_fp+0x14b>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4182d9:	48 8b 74 24 38       	mov    rsi,QWORD PTR [rsp+0x38]
--
  4182ed:	ff ff ff 
  4182f0:	4d 8d 2c 07          	lea    r13,[r15+rax*1]
  4182f4:	41 ff d5             	call   r13
  4182f7:	41 f6 06 20          	test   BYTE PTR [r14],0x20
  4182fb:	0f 85 8e f3 ff ff    	jne    41768f <fmt_fp+0xc8f>
  418301:	4c 89 f2             	mov    rdx,r14
  418304:	be 03 00 00 00       	mov    esi,0x3
  418309:	4c 89 e7             	mov    rdi,r12
  41830c:	41 ff d5             	call   r13
  41830f:	e9 7b f3 ff ff       	jmp    41768f <fmt_fp+0xc8f>
  418314:	48 b8 60 e3 fb ff ff 	movabs rax,0xfffffffffffbe360
  41831b:	ff ff ff 
--
  418324:	4c 89 d7             	mov    rdi,r10
  418327:	4c 01 f8             	add    rax,r15
  41832a:	ff d0                	call   rax
  41832c:	41 8b 0e             	mov    ecx,DWORD PTR [r14]
  41832f:	83 e1 20             	and    ecx,0x20
  418332:	85 c9                	test   ecx,ecx
  418334:	0f 85 d9 ef ff ff    	jne    417313 <fmt_fp+0x913>
  41833a:	48 b8 60 e3 fb ff ff 	movabs rax,0xfffffffffffbe360
  418341:	ff ff ff 
--
  41834c:	4c 89 e7             	mov    rdi,r12
  41834f:	4c 01 f8             	add    rax,r15
  418352:	ff d0                	call   rax
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  418354:	44 8b 44 24 08       	mov    r8d,DWORD PTR [rsp+0x8]
  418359:	8b 5c 24 38          	mov    ebx,DWORD PTR [rsp+0x38]
  41835d:	45 85 c0             	test   r8d,r8d
  418360:	0f 8f bb ef ff ff    	jg     417321 <fmt_fp+0x921>
  418366:	e9 72 f0 ff ff       	jmp    4173dd <fmt_fp+0x9dd>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41836b:	48 b8 60 e3 fb ff ff 	movabs rax,0xfffffffffffbe360
--
  41837b:	4c 89 ef             	mov    rdi,r13
  41837e:	4c 01 f8             	add    rax,r15
  418381:	ff d0                	call   rax
  418383:	41 8b 06             	mov    eax,DWORD PTR [r14]
  418386:	83 e0 20             	and    eax,0x20
  418389:	85 c0                	test   eax,eax
  41838b:	0f 85 52 fa ff ff    	jne    417de3 <fmt_fp+0x13e3>
		out(f, estr, ebuf-estr);
  418391:	48 8b 7c 24 50       	mov    rdi,QWORD PTR [rsp+0x50]
--
  4183ab:	48 29 fe             	sub    rsi,rdi
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4183ae:	ff d0                	call   rax
  4183b0:	e9 2e fa ff ff       	jmp    417de3 <fmt_fp+0x13e3>
		if (!p) p++;
  4183b5:	8b 0c 24             	mov    ecx,DWORD PTR [rsp]
--
  4183c5:	89 c1                	mov    ecx,eax
		if (p>e && e>=-4) {
  4183c7:	39 f8                	cmp    eax,edi
  4183c9:	0f 8e ac 06 00 00    	jle    418a7b <fmt_fp+0x207b>
  4183cf:	83 ff fc             	cmp    edi,0xfffffffc
  4183d2:	0f 8c a3 06 00 00    	jl     418a7b <fmt_fp+0x207b>
			p-=e+1;
--
		if (!(fl&ALT_FORM)) {
  4183e5:	f6 44 24 14 08       	test   BYTE PTR [rsp+0x14],0x8
  4183ea:	0f 85 64 f5 ff ff    	jne    417954 <fmt_fp+0xf54>
			if (z>a && z[-1]) for (i=10, j=0; z[-1]%i==0; i*=10, j++);
  4183f0:	be 09 00 00 00       	mov    esi,0x9
  4183f5:	48 39 dd             	cmp    rbp,rbx
  4183f8:	73 3a                	jae    418434 <fmt_fp+0x1a34>
  4183fa:	44 8b 43 fc          	mov    r8d,DWORD PTR [rbx-0x4]
  4183fe:	45 85 c0             	test   r8d,r8d
  418401:	74 31                	je     418434 <fmt_fp+0x1a34>
  418403:	41 69 c0 cd cc cc cc 	imul   eax,r8d,0xcccccccd
  41840a:	d1 c8                	ror    eax,1
  41840c:	3d 99 99 99 19       	cmp    eax,0x19999999
  418411:	0f 87 f7 0e 00 00    	ja     41930e <fmt_fp+0x290e>
  418417:	31 f6                	xor    esi,esi
--
  41842b:	f7 f1                	div    ecx
  41842d:	85 d2                	test   edx,edx
  41842f:	74 ed                	je     41841e <fmt_fp+0x1a1e>
				p = MIN(p,MAX(0,9*(z-r-1)-j));
  418431:	48 63 f6             	movsxd rsi,esi
--
  418449:	8b 44 24 20          	mov    eax,DWORD PTR [rsp+0x20]
  41844d:	83 c8 20             	or     eax,0x20
  418450:	83 f8 66             	cmp    eax,0x66
  418453:	0f 84 5a 0b 00 00    	je     418fb3 <fmt_fp+0x25b3>
				p = MIN(p,MAX(0,9*(z-r-1)+e-j));
  418459:	48 63 c7             	movsxd rax,edi
--
  418464:	48 29 f0             	sub    rax,rsi
  418467:	48 0f 48 c2          	cmovs  rax,rdx
  41846b:	48 39 c8             	cmp    rax,rcx
  41846e:	48 0f 4e c8          	cmovle rcx,rax
  418472:	48 89 0c 24          	mov    QWORD PTR [rsp],rcx
  418476:	e9 d9 f4 ff ff       	jmp    417954 <fmt_fp+0xf54>
			if (d!=a) while (s>buf) *--s='0';
  41847b:	49 bc 60 23 fc ff ff 	movabs r12,0xfffffffffffc2360
  418482:	ff ff ff 
  418485:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  41848a:	48 39 e8             	cmp    rax,rbp
  41848d:	48 0f 46 e8          	cmovbe rbp,rax
  418491:	48 b8 60 23 fc ff ff 	movabs rax,0xfffffffffffc2360
--
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  4184b8:	48 85 c9             	test   rcx,rcx
  4184bb:	0f 84 dc 03 00 00    	je     41889d <fmt_fp+0x1e9d>
  4184c1:	49 b8 cd cc cc cc cc 	movabs r8,0xcccccccccccccccd
  4184c8:	cc cc cc 
--
  4184f8:	48 89 c8             	mov    rax,rcx
  4184fb:	48 89 d1             	mov    rcx,rdx
  4184fe:	48 83 f8 09          	cmp    rax,0x9
  418502:	77 d4                	ja     4184d8 <fmt_fp+0x1ad8>
			if (d!=a) while (s>buf) *--s='0';
  418504:	49 39 ed             	cmp    r13,rbp
  418507:	0f 84 43 03 00 00    	je     418850 <fmt_fp+0x1e50>
  41850d:	48 8d 4c 24 70       	lea    rcx,[rsp+0x70]
  418512:	48 39 cf             	cmp    rdi,rcx
  418515:	0f 86 ff 00 00 00    	jbe    41861a <fmt_fp+0x1c1a>
  41851b:	4c 8d 4f ff          	lea    r9,[rdi-0x1]
--
  418522:	ba 01 00 00 00       	mov    edx,0x1
  418527:	48 29 c8             	sub    rax,rcx
  41852a:	49 39 c9             	cmp    r9,rcx
  41852d:	48 0f 43 d0          	cmovae rdx,rax
  418531:	48 83 e8 01          	sub    rax,0x1
  418535:	48 83 f8 0e          	cmp    rax,0xe
  418539:	0f 86 c0 09 00 00    	jbe    418eff <fmt_fp+0x24ff>
  41853f:	49 39 c9             	cmp    r9,rcx
  418542:	0f 82 b7 09 00 00    	jb     418eff <fmt_fp+0x24ff>
  418548:	4c 8b 5c 24 08       	mov    r11,QWORD PTR [rsp+0x8]
--
  418568:	0f 11 40 f0          	movups XMMWORD PTR [rax-0x10],xmm0
  41856c:	48 83 e8 10          	sub    rax,0x10
  418570:	49 39 c0             	cmp    r8,rax
  418573:	75 f3                	jne    418568 <fmt_fp+0x1b68>
  418575:	49 89 d0             	mov    r8,rdx
  418578:	48 89 f8             	mov    rax,rdi
  41857b:	49 83 e0 f0          	and    r8,0xfffffffffffffff0
  41857f:	4c 29 c0             	sub    rax,r8
  418582:	4c 39 c2             	cmp    rdx,r8
  418585:	74 7c                	je     418603 <fmt_fp+0x1c03>
  418587:	4c 29 c2             	sub    rdx,r8
  41858a:	4c 8d 52 ff          	lea    r10,[rdx-0x1]
  41858e:	49 83 fa 06          	cmp    r10,0x6
  418592:	76 1d                	jbe    4185b1 <fmt_fp+0x1bb1>
  418594:	49 89 fa             	mov    r10,rdi
--
  4185a5:	49 83 e0 f8          	and    r8,0xfffffffffffffff8
  4185a9:	4c 29 c0             	sub    rax,r8
  4185ac:	4c 39 c2             	cmp    rdx,r8
  4185af:	74 52                	je     418603 <fmt_fp+0x1c03>
  4185b1:	48 8d 50 ff          	lea    rdx,[rax-0x1]
  4185b5:	c6 40 ff 30          	mov    BYTE PTR [rax-0x1],0x30
  4185b9:	48 39 d1             	cmp    rcx,rdx
  4185bc:	73 45                	jae    418603 <fmt_fp+0x1c03>
  4185be:	48 8d 50 fe          	lea    rdx,[rax-0x2]
  4185c2:	c6 40 fe 30          	mov    BYTE PTR [rax-0x2],0x30
  4185c6:	48 39 d1             	cmp    rcx,rdx
  4185c9:	73 38                	jae    418603 <fmt_fp+0x1c03>
  4185cb:	48 8d 50 fd          	lea    rdx,[rax-0x3]
  4185cf:	c6 40 fd 30          	mov    BYTE PTR [rax-0x3],0x30
  4185d3:	48 39 d1             	cmp    rcx,rdx
  4185d6:	73 2b                	jae    418603 <fmt_fp+0x1c03>
  4185d8:	48 8d 50 fc          	lea    rdx,[rax-0x4]
  4185dc:	c6 40 fc 30          	mov    BYTE PTR [rax-0x4],0x30
  4185e0:	48 39 d1             	cmp    rcx,rdx
  4185e3:	73 1e                	jae    418603 <fmt_fp+0x1c03>
  4185e5:	48 8d 50 fb          	lea    rdx,[rax-0x5]
  4185e9:	c6 40 fb 30          	mov    BYTE PTR [rax-0x5],0x30
  4185ed:	48 39 d1             	cmp    rcx,rdx
  4185f0:	73 11                	jae    418603 <fmt_fp+0x1c03>
  4185f2:	48 8d 50 fa          	lea    rdx,[rax-0x6]
  4185f6:	c6 40 fa 30          	mov    BYTE PTR [rax-0x6],0x30
  4185fa:	48 39 d1             	cmp    rcx,rdx
  4185fd:	73 04                	jae    418603 <fmt_fp+0x1c03>
  4185ff:	c6 40 f9 30          	mov    BYTE PTR [rax-0x7],0x30
--
  418606:	48 c7 c2 ff ff ff ff 	mov    rdx,0xffffffffffffffff
  41860d:	48 29 f8             	sub    rax,rdi
  418610:	49 39 c9             	cmp    r9,rcx
  418613:	48 0f 42 c2          	cmovb  rax,rdx
  418617:	48 01 c7             	add    rdi,rax
--
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41861d:	41 f6 06 20          	test   BYTE PTR [r14],0x20
  418621:	0f 84 51 02 00 00    	je     418878 <fmt_fp+0x1e78>
		for (d=a; d<=r; d++) {
  418627:	48 8d 7d 04          	lea    rdi,[rbp+0x4]
  41862b:	48 3b 7c 24 18       	cmp    rdi,QWORD PTR [rsp+0x18]
  418630:	0f 87 84 01 00 00    	ja     4187ba <fmt_fp+0x1dba>
  418636:	48 b8 60 23 fc ff ff 	movabs rax,0xfffffffffffc2360
--
  41866c:	4c 89 d6             	mov    rsi,r10
  41866f:	48 85 c9             	test   rcx,rcx
  418672:	0f 84 75 02 00 00    	je     4188ed <fmt_fp+0x1eed>
  418678:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41867f:	00 
--
  4186a0:	48 89 c8             	mov    rax,rcx
  4186a3:	48 89 d1             	mov    rcx,rdx
  4186a6:	48 83 f8 09          	cmp    rax,0x9
  4186aa:	77 d4                	ja     418680 <fmt_fp+0x1c80>
			if (d!=a) while (s>buf) *--s='0';
  4186ac:	49 39 fd             	cmp    r13,rdi
  4186af:	0f 84 83 01 00 00    	je     418838 <fmt_fp+0x1e38>
  4186b5:	4c 39 ce             	cmp    rsi,r9
  4186b8:	0f 86 ed 00 00 00    	jbe    4187ab <fmt_fp+0x1dab>
  4186be:	4c 8d 66 ff          	lea    r12,[rsi-0x1]
--
  4186ca:	48 89 f0             	mov    rax,rsi
  4186cd:	4c 29 c9             	sub    rcx,r9
  4186d0:	4d 39 cc             	cmp    r12,r9
  4186d3:	48 0f 43 d1          	cmovae rdx,rcx
  4186d7:	48 83 e9 01          	sub    rcx,0x1
  4186db:	48 83 f9 0e          	cmp    rcx,0xe
  4186df:	0f 86 25 08 00 00    	jbe    418f0a <fmt_fp+0x250a>
  4186e5:	4d 39 cc             	cmp    r12,r9
  4186e8:	0f 82 1c 08 00 00    	jb     418f0a <fmt_fp+0x250a>
  4186ee:	49 89 d4             	mov    r12,rdx
--
  418710:	0f 11 40 f0          	movups XMMWORD PTR [rax-0x10],xmm0
  418714:	48 83 e8 10          	sub    rax,0x10
  418718:	48 39 c1             	cmp    rcx,rax
  41871b:	75 f3                	jne    418710 <fmt_fp+0x1d10>
  41871d:	48 89 d1             	mov    rcx,rdx
  418720:	48 89 f0             	mov    rax,rsi
  418723:	48 83 e1 f0          	and    rcx,0xfffffffffffffff0
  418727:	48 29 c8             	sub    rax,rcx
  41872a:	48 39 d1             	cmp    rcx,rdx
  41872d:	74 7c                	je     4187ab <fmt_fp+0x1dab>
  41872f:	48 29 ca             	sub    rdx,rcx
  418732:	4c 8d 62 ff          	lea    r12,[rdx-0x1]
  418736:	49 83 fc 06          	cmp    r12,0x6
  41873a:	76 1d                	jbe    418759 <fmt_fp+0x1d59>
  41873c:	49 89 ec             	mov    r12,rbp
--
  41874d:	48 83 e1 f8          	and    rcx,0xfffffffffffffff8
  418751:	48 29 c8             	sub    rax,rcx
  418754:	48 39 ca             	cmp    rdx,rcx
  418757:	74 52                	je     4187ab <fmt_fp+0x1dab>
  418759:	48 8d 50 ff          	lea    rdx,[rax-0x1]
  41875d:	c6 40 ff 30          	mov    BYTE PTR [rax-0x1],0x30
  418761:	49 39 d1             	cmp    r9,rdx
  418764:	73 45                	jae    4187ab <fmt_fp+0x1dab>
  418766:	48 8d 50 fe          	lea    rdx,[rax-0x2]
  41876a:	c6 40 fe 30          	mov    BYTE PTR [rax-0x2],0x30
  41876e:	49 39 d1             	cmp    r9,rdx
  418771:	73 38                	jae    4187ab <fmt_fp+0x1dab>
  418773:	48 8d 50 fd          	lea    rdx,[rax-0x3]
  418777:	c6 40 fd 30          	mov    BYTE PTR [rax-0x3],0x30
  41877b:	49 39 d1             	cmp    r9,rdx
  41877e:	73 2b                	jae    4187ab <fmt_fp+0x1dab>
  418780:	48 8d 50 fc          	lea    rdx,[rax-0x4]
  418784:	c6 40 fc 30          	mov    BYTE PTR [rax-0x4],0x30
  418788:	49 39 d1             	cmp    r9,rdx
  41878b:	73 1e                	jae    4187ab <fmt_fp+0x1dab>
  41878d:	48 8d 50 fb          	lea    rdx,[rax-0x5]
  418791:	c6 40 fb 30          	mov    BYTE PTR [rax-0x5],0x30
  418795:	49 39 d1             	cmp    r9,rdx
  418798:	73 11                	jae    4187ab <fmt_fp+0x1dab>
  41879a:	48 8d 50 fa          	lea    rdx,[rax-0x6]
  41879e:	c6 40 fa 30          	mov    BYTE PTR [rax-0x6],0x30
  4187a2:	49 39 d1             	cmp    r9,rdx
  4187a5:	73 04                	jae    4187ab <fmt_fp+0x1dab>
  4187a7:	c6 40 f9 30          	mov    BYTE PTR [rax-0x7],0x30
		for (d=a; d<=r; d++) {
  4187ab:	48 83 c7 04          	add    rdi,0x4
  4187af:	48 39 7c 24 18       	cmp    QWORD PTR [rsp+0x18],rdi
  4187b4:	0f 83 b0 fe ff ff    	jae    41866a <fmt_fp+0x1c6a>
  4187ba:	48 8b 7c 24 18       	mov    rdi,QWORD PTR [rsp+0x18]
--
  4187d7:	00 
  4187d8:	49 8d 45 01          	lea    rax,[r13+0x1]
  4187dc:	48 39 c7             	cmp    rdi,rax
  4187df:	b8 04 00 00 00       	mov    eax,0x4
  4187e4:	4c 0f 42 c0          	cmovb  r8,rax
--
		if (p || (fl&ALT_FORM)) out(f, ".", 1);
  4187ed:	85 c9                	test   ecx,ecx
  4187ef:	0f 85 94 02 00 00    	jne    418a89 <fmt_fp+0x2089>
  4187f5:	f6 44 24 14 08       	test   BYTE PTR [rsp+0x14],0x8
  4187fa:	0f 84 e3 f5 ff ff    	je     417de3 <fmt_fp+0x13e3>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418800:	41 f6 06 20          	test   BYTE PTR [r14],0x20
  418804:	0f 85 d9 f5 ff ff    	jne    417de3 <fmt_fp+0x13e3>
  41880a:	48 b8 73 1e fc ff ff 	movabs rax,0xfffffffffffc1e73
  418811:	ff ff ff 
--
  418827:	ff ff ff 
  41882a:	4c 01 f8             	add    rax,r15
  41882d:	ff d0                	call   rax
  41882f:	e9 5f 02 00 00       	jmp    418a93 <fmt_fp+0x2093>
  418834:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
			else if (s==buf+9) *--s='0';
  418838:	4c 39 d6             	cmp    rsi,r10
  41883b:	0f 85 6a ff ff ff    	jne    4187ab <fmt_fp+0x1dab>
  418841:	c6 44 24 78 30       	mov    BYTE PTR [rsp+0x78],0x30
  418846:	e9 60 ff ff ff       	jmp    4187ab <fmt_fp+0x1dab>
  41884b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  418850:	48 39 f7             	cmp    rdi,rsi
  418853:	0f 85 c1 fd ff ff    	jne    41861a <fmt_fp+0x1c1a>
  418859:	c6 44 24 78 30       	mov    BYTE PTR [rsp+0x78],0x30
  41885e:	be 01 00 00 00       	mov    esi,0x1
--
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418868:	41 f6 06 20          	test   BYTE PTR [r14],0x20
  41886c:	0f 85 b5 fd ff ff    	jne    418627 <fmt_fp+0x1c27>
  418872:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  418878:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
--
  418880:	48 83 c5 04          	add    rbp,0x4
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418884:	ff d0                	call   rax
		for (d=a; d<=r; d++) {
  418886:	48 39 6c 24 18       	cmp    QWORD PTR [rsp+0x18],rbp
  41888b:	0f 82 29 ff ff ff    	jb     4187ba <fmt_fp+0x1dba>
			char *s = fmt_u(*d, buf+9);
--
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  418894:	48 85 c9             	test   rcx,rcx
  418897:	0f 85 24 fc ff ff    	jne    4184c1 <fmt_fp+0x1ac1>
			if (d!=a) while (s>buf) *--s='0';
  41889d:	49 39 ed             	cmp    r13,rbp
  4188a0:	74 b7                	je     418859 <fmt_fp+0x1e59>
  4188a2:	48 8d 74 24 79       	lea    rsi,[rsp+0x79]
  4188a7:	48 8d 4c 24 70       	lea    rcx,[rsp+0x70]
  4188ac:	48 89 f7             	mov    rdi,rsi
  4188af:	e9 67 fc ff ff       	jmp    41851b <fmt_fp+0x1b1b>
		if (e > INT_MAX-l) return -1;
  4188b4:	44 39 d7             	cmp    edi,r10d
  4188b7:	0f 8f 01 fa ff ff    	jg     4182be <fmt_fp+0x18be>
		if (e>0) l+=e;
  4188bd:	41 8d 04 38          	lea    eax,[r8+rdi*1]
  4188c1:	85 ff                	test   edi,edi
  4188c3:	44 0f 4f c0          	cmovg  r8d,eax
  4188c7:	e9 68 f1 ff ff       	jmp    417a34 <fmt_fp+0x1034>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4188cc:	48 8b 74 24 38       	mov    rsi,QWORD PTR [rsp+0x38]
--
  4188e0:	ff ff ff 
  4188e3:	4c 01 f8             	add    rax,r15
  4188e6:	ff d0                	call   rax
  4188e8:	e9 57 f2 ff ff       	jmp    417b44 <fmt_fp+0x1144>
			if (d!=a) while (s>buf) *--s='0';
  4188ed:	49 39 fd             	cmp    r13,rdi
  4188f0:	0f 85 c8 fd ff ff    	jne    4186be <fmt_fp+0x1cbe>
  4188f6:	e9 46 ff ff ff       	jmp    418841 <fmt_fp+0x1e41>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4188fb:	41 83 e0 20          	and    r8d,0x20
  4188ff:	45 89 e1             	mov    r9d,r12d
  418902:	48 89 fd             	mov    rbp,rdi
  418905:	e9 cd f6 ff ff       	jmp    417fd7 <fmt_fp+0x15d7>
  41890a:	d9 7c 24 5e          	fnstcw WORD PTR [rsp+0x5e]
		s=buf;
--
  418936:	d9 ca                	fxch   st(2)
  418938:	66 89 54 24 5c       	mov    WORD PTR [rsp+0x5c],dx
  41893d:	eb 0e                	jmp    41894d <fmt_fp+0x1f4d>
  41893f:	90                   	nop
			*s++=xdigits[x]|(t&32);
--
  418943:	db ea                	fucomi st,st(2)
  418945:	7a 06                	jp     41894d <fmt_fp+0x1f4d>
  418947:	0f 84 a7 e7 ff ff    	je     4170f4 <fmt_fp+0x6f4>
			int x=y;
  41894d:	d9 c0                	fld    st(0)
--
  418973:	d8 c9                	fmul   st,st(1)
			if (s-buf==1 && (y||p>0||(fl&ALT_FORM))) *s++='.';
  418975:	4c 39 e0             	cmp    rax,r12
  418978:	75 c6                	jne    418940 <fmt_fp+0x1f40>
  41897a:	c6 40 01 2e          	mov    BYTE PTR [rax+0x1],0x2e
  41897e:	48 83 c0 02          	add    rax,0x2
  418982:	eb bf                	jmp    418943 <fmt_fp+0x1f43>
			if (s==buf+9) *--s='0';
  418984:	48 89 f8             	mov    rax,rdi
  418987:	45 31 c9             	xor    r9d,r9d
  41898a:	e9 a4 f5 ff ff       	jmp    417f33 <fmt_fp+0x1533>
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41898f:	4c 8d ac 24 90 00 00 	lea    r13,[rsp+0x90]
--
  4189ab:	4c 89 ef             	mov    rdi,r13
  4189ae:	4c 01 f8             	add    rax,r15
  4189b1:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  4189b3:	e9 db f3 ff ff       	jmp    417d93 <fmt_fp+0x1393>
				*d = *d + i;
  4189b8:	44 01 d0             	add    eax,r10d
  4189bb:	89 06                	mov    DWORD PTR [rsi],eax
				while (*d > 999999999) {
  4189bd:	3d ff c9 9a 3b       	cmp    eax,0x3b9ac9ff
  4189c2:	77 2e                	ja     4189f2 <fmt_fp+0x1ff2>
  4189c4:	e9 2c 08 00 00       	jmp    4191f5 <fmt_fp+0x27f5>
  4189c9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
					if (d<a) *--a=0;
--
  4189e4:	89 4e fc             	mov    DWORD PTR [rsi-0x4],ecx
				while (*d > 999999999) {
  4189e7:	81 f9 ff c9 9a 3b    	cmp    ecx,0x3b9ac9ff
  4189ed:	76 24                	jbe    418a13 <fmt_fp+0x2013>
			if (pl && *prefix=='-') round*=-1, small*=-1;
--
  4189f6:	c7 40 04 00 00 00 00 	mov    DWORD PTR [rax+0x4],0x0
					if (d<a) *--a=0;
  4189fd:	48 39 e8             	cmp    rax,rbp
  418a00:	72 ce                	jb     4189d0 <fmt_fp+0x1fd0>
					(*d)++;
--
  418a08:	89 56 fc             	mov    DWORD PTR [rsi-0x4],edx
				while (*d > 999999999) {
  418a0b:	81 fa ff c9 9a 3b    	cmp    edx,0x3b9ac9ff
  418a11:	77 dc                	ja     4189ef <fmt_fp+0x1fef>
				for (i=10, e=9*(r-a); *a>=i; i*=10, e++);
--
  418a1e:	48 c1 f8 02          	sar    rax,0x2
  418a22:	8d 3c c0             	lea    edi,[rax+rax*8]
  418a25:	83 fa 09             	cmp    edx,0x9
  418a28:	0f 86 f8 ee ff ff    	jbe    417926 <fmt_fp+0xf26>
  418a2e:	b8 0a 00 00 00       	mov    eax,0xa
--
  418a3b:	83 c7 01             	add    edi,0x1
  418a3e:	01 c0                	add    eax,eax
  418a40:	39 d0                	cmp    eax,edx
  418a42:	76 f4                	jbe    418a38 <fmt_fp+0x2038>
  418a44:	e9 dd ee ff ff       	jmp    417926 <fmt_fp+0xf26>
  418a49:	4d 89 ea             	mov    r10,r13
  418a4c:	e9 6d ea ff ff       	jmp    4174be <fmt_fp+0xabe>
  418a51:	49 89 ea             	mov    r10,rbp
  418a54:	44 89 ed             	mov    ebp,r13d
  418a57:	e9 af e8 ff ff       	jmp    41730b <fmt_fp+0x90b>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418a5c:	48 b8 60 e3 fb ff ff 	movabs rax,0xfffffffffffbe360
--
  418a6e:	4c 89 f2             	mov    rdx,r14
  418a71:	4c 01 f8             	add    rax,r15
  418a74:	ff d0                	call   rax
  418a76:	e9 cd e7 ff ff       	jmp    417248 <fmt_fp+0x848>
			t-=2;
  418a7b:	83 6c 24 20 02       	sub    DWORD PTR [rsp+0x20],0x2
			p--;
  418a80:	83 2c 24 01          	sub    DWORD PTR [rsp],0x1
  418a84:	e9 5c f9 ff ff       	jmp    4183e5 <fmt_fp+0x19e5>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418a89:	41 f6 06 20          	test   BYTE PTR [r14],0x20
  418a8d:	0f 84 77 fd ff ff    	je     41880a <fmt_fp+0x1e0a>
		for (; d<z && p>0; d++, p-=9) {
  418a93:	8b 14 24             	mov    edx,DWORD PTR [rsp]
  418a96:	85 d2                	test   edx,edx
  418a98:	0f 8e 45 f3 ff ff    	jle    417de3 <fmt_fp+0x13e3>
  418a9e:	48 39 dd             	cmp    rbp,rbx
  418aa1:	0f 83 1b 03 00 00    	jae    418dc2 <fmt_fp+0x23c2>
  418aa7:	4c 8d 5c 24 79       	lea    r11,[rsp+0x79]
--
  418ae0:	48 89 df             	mov    rdi,rbx
  418ae3:	48 85 f6             	test   rsi,rsi
  418ae6:	74 45                	je     418b2d <fmt_fp+0x212d>
  418ae8:	49 b8 cd cc cc cc cc 	movabs r8,0xcccccccccccccccd
  418aef:	cc cc cc 
--
  418b18:	48 89 f0             	mov    rax,rsi
  418b1b:	48 89 d6             	mov    rsi,rdx
  418b1e:	48 83 f8 09          	cmp    rax,0x9
  418b22:	77 d4                	ja     418af8 <fmt_fp+0x20f8>
			while (s>buf) *--s='0';
  418b24:	4c 39 e7             	cmp    rdi,r12
  418b27:	0f 86 f5 00 00 00    	jbe    418c22 <fmt_fp+0x2222>
  418b2d:	4c 8d 47 ff          	lea    r8,[rdi-0x1]
--
  418b34:	ba 01 00 00 00       	mov    edx,0x1
  418b39:	4c 29 e0             	sub    rax,r12
  418b3c:	4d 39 e0             	cmp    r8,r12
  418b3f:	48 0f 43 d0          	cmovae rdx,rax
  418b43:	48 83 e8 01          	sub    rax,0x1
  418b47:	48 83 f8 0e          	cmp    rax,0xe
  418b4b:	0f 86 88 03 00 00    	jbe    418ed9 <fmt_fp+0x24d9>
  418b51:	4d 39 e0             	cmp    r8,r12
  418b54:	0f 82 7f 03 00 00    	jb     418ed9 <fmt_fp+0x24d9>
  418b5a:	48 89 d0             	mov    rax,rdx
--
  418b70:	0f 11 40 f0          	movups XMMWORD PTR [rax-0x10],xmm0
  418b74:	48 83 e8 10          	sub    rax,0x10
  418b78:	48 39 f0             	cmp    rax,rsi
  418b7b:	75 f3                	jne    418b70 <fmt_fp+0x2170>
  418b7d:	48 89 d6             	mov    rsi,rdx
  418b80:	48 89 f8             	mov    rax,rdi
  418b83:	48 83 e6 f0          	and    rsi,0xfffffffffffffff0
  418b87:	48 29 f0             	sub    rax,rsi
  418b8a:	48 39 d6             	cmp    rsi,rdx
  418b8d:	74 7c                	je     418c0b <fmt_fp+0x220b>
  418b8f:	48 29 f2             	sub    rdx,rsi
  418b92:	4c 8d 52 ff          	lea    r10,[rdx-0x1]
  418b96:	49 83 fa 06          	cmp    r10,0x6
  418b9a:	76 1d                	jbe    418bb9 <fmt_fp+0x21b9>
  418b9c:	49 89 fa             	mov    r10,rdi
--
  418bad:	48 83 e6 f8          	and    rsi,0xfffffffffffffff8
  418bb1:	48 29 f0             	sub    rax,rsi
  418bb4:	48 39 f2             	cmp    rdx,rsi
  418bb7:	74 52                	je     418c0b <fmt_fp+0x220b>
  418bb9:	48 8d 50 ff          	lea    rdx,[rax-0x1]
  418bbd:	c6 40 ff 30          	mov    BYTE PTR [rax-0x1],0x30
  418bc1:	49 39 d4             	cmp    r12,rdx
  418bc4:	73 45                	jae    418c0b <fmt_fp+0x220b>
  418bc6:	48 8d 50 fe          	lea    rdx,[rax-0x2]
  418bca:	c6 40 fe 30          	mov    BYTE PTR [rax-0x2],0x30
  418bce:	49 39 d4             	cmp    r12,rdx
  418bd1:	73 38                	jae    418c0b <fmt_fp+0x220b>
  418bd3:	48 8d 50 fd          	lea    rdx,[rax-0x3]
  418bd7:	c6 40 fd 30          	mov    BYTE PTR [rax-0x3],0x30
  418bdb:	49 39 d4             	cmp    r12,rdx
  418bde:	73 2b                	jae    418c0b <fmt_fp+0x220b>
  418be0:	48 8d 50 fc          	lea    rdx,[rax-0x4]
  418be4:	c6 40 fc 30          	mov    BYTE PTR [rax-0x4],0x30
  418be8:	49 39 d4             	cmp    r12,rdx
  418beb:	73 1e                	jae    418c0b <fmt_fp+0x220b>
  418bed:	48 8d 50 fb          	lea    rdx,[rax-0x5]
  418bf1:	c6 40 fb 30          	mov    BYTE PTR [rax-0x5],0x30
  418bf5:	49 39 d4             	cmp    r12,rdx
  418bf8:	73 11                	jae    418c0b <fmt_fp+0x220b>
  418bfa:	48 8d 50 fa          	lea    rdx,[rax-0x6]
  418bfe:	c6 40 fa 30          	mov    BYTE PTR [rax-0x6],0x30
  418c02:	49 39 d4             	cmp    r12,rdx
  418c05:	73 04                	jae    418c0b <fmt_fp+0x220b>
  418c07:	c6 40 f9 30          	mov    BYTE PTR [rax-0x7],0x30
--
  418c0e:	48 c7 c2 ff ff ff ff 	mov    rdx,0xffffffffffffffff
  418c15:	48 29 f8             	sub    rax,rdi
  418c18:	4d 39 e0             	cmp    r8,r12
  418c1b:	48 0f 42 c2          	cmovb  rax,rdx
  418c1f:	48 01 c7             	add    rdi,rax
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418c22:	41 f6 06 20          	test   BYTE PTR [r14],0x20
  418c26:	0f 84 54 02 00 00    	je     418e80 <fmt_fp+0x2480>
		for (; d<z && p>0; d++, p-=9) {
  418c2c:	4c 8d 45 04          	lea    r8,[rbp+0x4]
--
  418c37:	8b 2c 24             	mov    ebp,DWORD PTR [rsp]
  418c3a:	48 89 cb             	mov    rbx,rcx
  418c3d:	49 39 c8             	cmp    r8,rcx
  418c40:	0f 83 7c 01 00 00    	jae    418dc2 <fmt_fp+0x23c2>
  418c46:	85 ed                	test   ebp,ebp
--
  418c7a:	4c 89 de             	mov    rsi,r11
  418c7d:	48 85 c9             	test   rcx,rcx
  418c80:	74 3b                	je     418cbd <fmt_fp+0x22bd>
  418c82:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  418c88:	48 89 c8             	mov    rax,rcx
--
  418ca8:	48 89 c8             	mov    rax,rcx
  418cab:	48 89 d1             	mov    rcx,rdx
  418cae:	48 83 f8 09          	cmp    rax,0x9
  418cb2:	77 d4                	ja     418c88 <fmt_fp+0x2288>
			while (s>buf) *--s='0';
  418cb4:	4c 39 e6             	cmp    rsi,r12
  418cb7:	0f 86 e6 00 00 00    	jbe    418da3 <fmt_fp+0x23a3>
  418cbd:	4c 8d 76 ff          	lea    r14,[rsi-0x1]
--
  418cc9:	48 89 f0             	mov    rax,rsi
  418ccc:	4c 29 e1             	sub    rcx,r12
  418ccf:	4d 39 e6             	cmp    r14,r12
  418cd2:	48 0f 43 d1          	cmovae rdx,rcx
  418cd6:	48 83 e9 01          	sub    rcx,0x1
  418cda:	48 83 f9 0e          	cmp    rcx,0xe
  418cde:	0f 86 eb 01 00 00    	jbe    418ecf <fmt_fp+0x24cf>
  418ce4:	4d 39 e6             	cmp    r14,r12
  418ce7:	0f 82 e2 01 00 00    	jb     418ecf <fmt_fp+0x24cf>
  418ced:	49 89 d6             	mov    r14,rdx
--
  418d08:	0f 11 40 f0          	movups XMMWORD PTR [rax-0x10],xmm0
  418d0c:	48 83 e8 10          	sub    rax,0x10
  418d10:	48 39 c8             	cmp    rax,rcx
  418d13:	75 f3                	jne    418d08 <fmt_fp+0x2308>
  418d15:	48 89 d1             	mov    rcx,rdx
  418d18:	48 89 f0             	mov    rax,rsi
  418d1b:	48 83 e1 f0          	and    rcx,0xfffffffffffffff0
  418d1f:	48 29 c8             	sub    rax,rcx
  418d22:	48 39 d1             	cmp    rcx,rdx
  418d25:	74 7c                	je     418da3 <fmt_fp+0x23a3>
  418d27:	48 29 ca             	sub    rdx,rcx
  418d2a:	4c 8d 72 ff          	lea    r14,[rdx-0x1]
  418d2e:	49 83 fe 06          	cmp    r14,0x6
  418d32:	76 1d                	jbe    418d51 <fmt_fp+0x2351>
  418d34:	4d 89 d6             	mov    r14,r10
--
  418d45:	48 83 e1 f8          	and    rcx,0xfffffffffffffff8
  418d49:	48 29 c8             	sub    rax,rcx
  418d4c:	48 39 d1             	cmp    rcx,rdx
  418d4f:	74 52                	je     418da3 <fmt_fp+0x23a3>
  418d51:	48 8d 50 ff          	lea    rdx,[rax-0x1]
  418d55:	c6 40 ff 30          	mov    BYTE PTR [rax-0x1],0x30
  418d59:	49 39 d4             	cmp    r12,rdx
  418d5c:	73 45                	jae    418da3 <fmt_fp+0x23a3>
  418d5e:	48 8d 50 fe          	lea    rdx,[rax-0x2]
  418d62:	c6 40 fe 30          	mov    BYTE PTR [rax-0x2],0x30
  418d66:	49 39 d4             	cmp    r12,rdx
  418d69:	73 38                	jae    418da3 <fmt_fp+0x23a3>
  418d6b:	48 8d 50 fd          	lea    rdx,[rax-0x3]
  418d6f:	c6 40 fd 30          	mov    BYTE PTR [rax-0x3],0x30
  418d73:	49 39 d4             	cmp    r12,rdx
  418d76:	73 2b                	jae    418da3 <fmt_fp+0x23a3>
  418d78:	48 8d 50 fc          	lea    rdx,[rax-0x4]
  418d7c:	c6 40 fc 30          	mov    BYTE PTR [rax-0x4],0x30
  418d80:	49 39 d4             	cmp    r12,rdx
  418d83:	73 1e                	jae    418da3 <fmt_fp+0x23a3>
  418d85:	48 8d 50 fb          	lea    rdx,[rax-0x5]
  418d89:	c6 40 fb 30          	mov    BYTE PTR [rax-0x5],0x30
  418d8d:	49 39 d4             	cmp    r12,rdx
  418d90:	73 11                	jae    418da3 <fmt_fp+0x23a3>
  418d92:	48 8d 50 fa          	lea    rdx,[rax-0x6]
  418d96:	c6 40 fa 30          	mov    BYTE PTR [rax-0x6],0x30
  418d9a:	49 39 d4             	cmp    r12,rdx
  418d9d:	73 04                	jae    418da3 <fmt_fp+0x23a3>
  418d9f:	c6 40 f9 30          	mov    BYTE PTR [rax-0x7],0x30
--
  418daa:	85 ed                	test   ebp,ebp
  418dac:	0f 8e a0 02 00 00    	jle    419052 <fmt_fp+0x2652>
  418db2:	4c 39 c3             	cmp    rbx,r8
  418db5:	0f 87 bc fe ff ff    	ja     418c77 <fmt_fp+0x2277>
  418dbb:	4c 8b 34 24          	mov    r14,QWORD PTR [rsp]
--
  418dc7:	0f 8e 16 f0 ff ff    	jle    417de3 <fmt_fp+0x13e3>
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  418dcd:	81 fb 00 01 00 00    	cmp    ebx,0x100
  418dd3:	0f 8f 82 02 00 00    	jg     41905b <fmt_fp+0x265b>
  418dd9:	48 63 eb             	movsxd rbp,ebx
  418ddc:	4c 8d ac 24 90 00 00 	lea    r13,[rsp+0x90]
--
  418df6:	48 89 ea             	mov    rdx,rbp
  418df9:	4c 89 ef             	mov    rdi,r13
  418dfc:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  418dfe:	81 fb 00 01 00 00    	cmp    ebx,0x100
  418e04:	0f 85 f4 03 00 00    	jne    4191fe <fmt_fp+0x27fe>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418e0a:	48 bd 60 e3 fb ff ff 	movabs rbp,0xfffffffffffbe360
--
  418e28:	89 d0                	mov    eax,edx
  418e2a:	83 e0 20             	and    eax,0x20
  418e2d:	0f 84 ed 01 00 00    	je     419020 <fmt_fp+0x2620>
	for (; l >= sizeof pad; l -= sizeof pad)
  418e33:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  418e3a:	76 14                	jbe    418e50 <fmt_fp+0x2450>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
--
  418e45:	89 d0                	mov    eax,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  418e47:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  418e4e:	77 ee                	ja     418e3e <fmt_fp+0x243e>
	out(f, pad, l);
--
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418e53:	85 c0                	test   eax,eax
  418e55:	0f 85 88 ef ff ff    	jne    417de3 <fmt_fp+0x13e3>
  418e5b:	48 b8 60 e3 fb ff ff 	movabs rax,0xfffffffffffbe360
  418e62:	ff ff ff 
--
  418e6b:	4c 89 ef             	mov    rdi,r13
  418e6e:	4c 01 f8             	add    rax,r15
  418e71:	ff d0                	call   rax
  418e73:	e9 6b ef ff ff       	jmp    417de3 <fmt_fp+0x13e3>
  418e78:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  418e7f:	00 
--
  418e90:	4c 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],r9
			out(f, s, MIN(9,p));
  418e95:	39 c1                	cmp    ecx,eax
  418e97:	0f 4e c1             	cmovle eax,ecx
		for (; d<z && p>0; d++, p-=9) {
--
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418ea1:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  418ea6:	ff d0                	call   rax
		for (; d<z && p>0; d++, p-=9) {
  418ea8:	83 2c 24 09          	sub    DWORD PTR [rsp],0x9
--
  418eb7:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  418ebc:	4c 8b 4c 24 08       	mov    r9,QWORD PTR [rsp+0x8]
  418ec1:	48 39 cd             	cmp    rbp,rcx
  418ec4:	0f 82 13 fc ff ff    	jb     418add <fmt_fp+0x20dd>
  418eca:	e9 f3 fe ff ff       	jmp    418dc2 <fmt_fp+0x23c2>
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  418ecf:	48 89 f0             	mov    rax,rsi
  418ed2:	31 c9                	xor    ecx,ecx
  418ed4:	e9 4e fe ff ff       	jmp    418d27 <fmt_fp+0x2327>
  418ed9:	48 89 f8             	mov    rax,rdi
  418edc:	31 f6                	xor    esi,esi
  418ede:	e9 ac fc ff ff       	jmp    418b8f <fmt_fp+0x218f>
		if (estr==ebuf) *--estr='0';
  418ee3:	c6 44 24 6f 30       	mov    BYTE PTR [rsp+0x6f],0x30
  418ee8:	48 8d 74 24 6f       	lea    rsi,[rsp+0x6f]
  418eed:	e9 2b e1 ff ff       	jmp    41701d <fmt_fp+0x61d>
  418ef2:	49 89 da             	mov    r10,rbx
  418ef5:	89 eb                	mov    ebx,ebp
  418ef7:	8b 2c 24             	mov    ebp,DWORD PTR [rsp]
  418efa:	e9 66 e7 ff ff       	jmp    417665 <fmt_fp+0xc65>
			if (d!=a) while (s>buf) *--s='0';
  418eff:	48 89 f8             	mov    rax,rdi
  418f02:	45 31 c0             	xor    r8d,r8d
  418f05:	e9 7d f6 ff ff       	jmp    418587 <fmt_fp+0x1b87>
  418f0a:	48 89 f0             	mov    rax,rsi
  418f0d:	31 c9                	xor    ecx,ecx
  418f0f:	e9 1b f8 ff ff       	jmp    41872f <fmt_fp+0x1d2f>
  418f14:	4d 89 ea             	mov    r10,r13
  418f17:	45 89 e5             	mov    r13d,r12d
  418f1a:	e9 2e e8 ff ff       	jmp    41774d <fmt_fp+0xd4d>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418f1f:	48 b8 60 e3 fb ff ff 	movabs rax,0xfffffffffffbe360
--
  418f2f:	4c 89 ef             	mov    rdi,r13
  418f32:	4c 01 f8             	add    rax,r15
  418f35:	ff d0                	call   rax
  418f37:	e9 5d ef ff ff       	jmp    417e99 <fmt_fp+0x1499>
			if ((*d/i & 1) || (i==1000000000 && d>a && (d[-1]&1)))
  418f3c:	81 f9 00 ca 9a 3b    	cmp    ecx,0x3b9aca00
  418f42:	75 0f                	jne    418f53 <fmt_fp+0x2553>
  418f44:	48 39 ee             	cmp    rsi,rbp
  418f47:	76 0a                	jbe    418f53 <fmt_fp+0x2553>
  418f49:	f6 46 fc 01          	test   BYTE PTR [rsi-0x4],0x1
  418f4d:	0f 85 56 e9 ff ff    	jne    4178a9 <fmt_fp+0xea9>
			long double round = 2/LDBL_EPSILON;
  418f53:	48 b8 bc 22 fc ff ff 	movabs rax,0xfffffffffffc22bc
  418f5a:	ff ff ff 
  418f5d:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  418f61:	e9 51 e9 ff ff       	jmp    4178b7 <fmt_fp+0xeb7>
			l = (p+2) + (ebuf-estr);
  418f66:	83 c7 02             	add    edi,0x2
--
  418f75:	89 54 24 08          	mov    DWORD PTR [rsp+0x8],edx
			l = (p+2) + (ebuf-estr);
  418f79:	e9 d7 e1 ff ff       	jmp    417155 <fmt_fp+0x755>
			if ((*d/i & 1) || (i==1000000000 && d>a && (d[-1]&1)))
  418f7e:	48 b8 c0 22 fc ff ff 	movabs rax,0xfffffffffffc22c0
--
  418faa:	d9 ca                	fxch   st(2)
  418fac:	d9 c9                	fxch   st(1)
  418fae:	e9 31 e9 ff ff       	jmp    4178e4 <fmt_fp+0xee4>
				p = MIN(p,MAX(0,9*(z-r-1)-j));
  418fb3:	48 29 f2             	sub    rdx,rsi
  418fb6:	b8 00 00 00 00       	mov    eax,0x0
  418fbb:	48 0f 48 d0          	cmovs  rdx,rax
  418fbf:	48 39 ca             	cmp    rdx,rcx
  418fc2:	48 0f 4e ca          	cmovle rcx,rdx
  418fc6:	48 89 0c 24          	mov    QWORD PTR [rsp],rcx
  418fca:	e9 85 e9 ff ff       	jmp    417954 <fmt_fp+0xf54>
		for (i=10, j++; j<9; i*=10, j++);
  418fcf:	48 b8 e0 22 fc ff ff 	movabs rax,0xfffffffffffc22e0
--
  418ff2:	01 c9                	add    ecx,ecx
  418ff4:	41 83 e0 01          	and    r8d,0x1
  418ff8:	0f 84 22 de ff ff    	je     416e20 <fmt_fp+0x420>
  418ffe:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  419001:	01 c9                	add    ecx,ecx
  419003:	e9 18 de ff ff       	jmp    416e20 <fmt_fp+0x420>
			while (re--) round*=16;
  419008:	48 b8 98 22 fc ff ff 	movabs rax,0xfffffffffffc2298
  41900f:	ff ff ff 
  419012:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  419016:	e9 91 df ff ff       	jmp    416fac <fmt_fp+0x5ac>
  41901b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
--
  419028:	49 8d 04 2f          	lea    rax,[r15+rbp*1]
  41902c:	4c 89 ef             	mov    rdi,r13
  41902f:	ff d0                	call   rax
  419031:	41 8b 16             	mov    edx,DWORD PTR [r14]
  419034:	89 d0                	mov    eax,edx
  419036:	83 e0 20             	and    eax,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  419039:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  419040:	0f 86 0a fe ff ff    	jbe    418e50 <fmt_fp+0x2450>
  419046:	41 81 ec 00 01 00 00 	sub    r12d,0x100
  41904d:	e9 d6 fd ff ff       	jmp    418e28 <fmt_fp+0x2428>
  419052:	4c 8b 34 24          	mov    r14,QWORD PTR [rsp]
  419056:	e9 88 ed ff ff       	jmp    417de3 <fmt_fp+0x13e3>
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41905b:	4c 8d ac 24 90 00 00 	lea    r13,[rsp+0x90]
--
  419077:	4c 89 ef             	mov    rdi,r13
  41907a:	4c 01 f8             	add    rax,r15
  41907d:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  41907f:	e9 86 fd ff ff       	jmp    418e0a <fmt_fp+0x240a>
  419084:	d9 c9                	fxch   st(1)
				y=-y;
--
				y=-y;
  41908c:	d9 e0                	fchs   
  41908e:	e9 2b df ff ff       	jmp    416fbe <fmt_fp+0x5be>
  419093:	48 b8 c0 22 fc ff ff 	movabs rax,0xfffffffffffc22c0
  41909a:	ff ff ff 
--
  4190a8:	ff ff ff 
  4190ab:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  4190af:	e9 30 e8 ff ff       	jmp    4178e4 <fmt_fp+0xee4>
  4190b4:	48 89 de             	mov    rsi,rbx
  4190b7:	e9 6a e8 ff ff       	jmp    417926 <fmt_fp+0xf26>
			else if (x==i/2 && d+1==z) small=0x1.0p0;
  4190bc:	48 8d 46 04          	lea    rax,[rsi+0x4]
  4190c0:	48 39 c3             	cmp    rbx,rax
  4190c3:	0f 85 ff e7 ff ff    	jne    4178c8 <fmt_fp+0xec8>
  4190c9:	d9 e8                	fld1   
  4190cb:	d9 e0                	fchs   
  4190cd:	d9 e8                	fld1   
  4190cf:	e9 10 e8 ff ff       	jmp    4178e4 <fmt_fp+0xee4>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4190d4:	48 b8 60 e3 fb ff ff 	movabs rax,0xfffffffffffbe360
--
  4190e4:	4c 89 d7             	mov    rdi,r10
  4190e7:	4c 01 f8             	add    rax,r15
  4190ea:	ff d0                	call   rax
  4190ec:	e9 d5 e3 ff ff       	jmp    4174c6 <fmt_fp+0xac6>
		for (i=10, j++; j<9; i*=10, j++);
  4190f1:	48 b8 e8 22 fc ff ff 	movabs rax,0xfffffffffffc22e8
  4190f8:	ff ff ff 
  4190fb:	f3 41 0f 7e 04 07    	movq   xmm0,QWORD PTR [r15+rax*1]
  419101:	e9 d9 fe ff ff       	jmp    418fdf <fmt_fp+0x25df>
  419106:	dd d8                	fstp   st(0)
  419108:	dd d8                	fstp   st(0)
--
		} while (y);
  41910c:	48 89 d0             	mov    rax,rdx
  41910f:	e9 e6 df ff ff       	jmp    4170fa <fmt_fp+0x6fa>
		for (i=10, j++; j<9; i*=10, j++);
  419114:	48 b8 f0 22 fc ff ff 	movabs rax,0xfffffffffffc22f0
  41911b:	ff ff ff 
  41911e:	f3 41 0f 7e 04 07    	movq   xmm0,QWORD PTR [r15+rax*1]
  419124:	e9 b6 fe ff ff       	jmp    418fdf <fmt_fp+0x25df>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419129:	41 8b 16             	mov    edx,DWORD PTR [r14]
  41912c:	83 e2 20             	and    edx,0x20
  41912f:	e9 19 e6 ff ff       	jmp    41774d <fmt_fp+0xd4d>
  419134:	41 8b 36             	mov    esi,DWORD PTR [r14]
  419137:	83 e6 20             	and    esi,0x20
  41913a:	e9 26 e5 ff ff       	jmp    417665 <fmt_fp+0xc65>
		for (i=10, j++; j<9; i*=10, j++);
  41913f:	41 ba 0a 00 00 00    	mov    r10d,0xa
  419145:	b9 0a 00 00 00       	mov    ecx,0xa
  41914a:	e9 d4 dc ff ff       	jmp    416e23 <fmt_fp+0x423>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41914f:	41 8b 16             	mov    edx,DWORD PTR [r14]
  419152:	83 e2 20             	and    edx,0x20
  419155:	e9 37 ed ff ff       	jmp    417e91 <fmt_fp+0x1491>
  41915a:	41 8b 06             	mov    eax,DWORD PTR [r14]
  41915d:	83 e0 20             	and    eax,0x20
  419160:	e9 76 ec ff ff       	jmp    417ddb <fmt_fp+0x13db>
  419165:	83 e0 20             	and    eax,0x20
  419168:	89 c2                	mov    edx,eax
  41916a:	e9 98 ea ff ff       	jmp    417c07 <fmt_fp+0x1207>
		for (i=10, j++; j<9; i*=10, j++);
  41916f:	b9 0a 00 00 00       	mov    ecx,0xa
  419174:	e9 85 fe ff ff       	jmp    418ffe <fmt_fp+0x25fe>
  419179:	48 b8 f8 22 fc ff ff 	movabs rax,0xfffffffffffc22f8
  419180:	ff ff ff 
  419183:	f3 41 0f 7e 04 07    	movq   xmm0,QWORD PTR [r15+rax*1]
  419189:	e9 51 fe ff ff       	jmp    418fdf <fmt_fp+0x25df>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41918e:	83 e0 20             	and    eax,0x20
  419191:	89 c6                	mov    esi,eax
  419193:	e9 80 e9 ff ff       	jmp    417b18 <fmt_fp+0x1118>
		for (i=10, j++; j<9; i*=10, j++);
  419198:	48 b8 00 23 fc ff ff 	movabs rax,0xfffffffffffc2300
  41919f:	ff ff ff 
  4191a2:	f3 41 0f 7e 04 07    	movq   xmm0,QWORD PTR [r15+rax*1]
  4191a8:	e9 32 fe ff ff       	jmp    418fdf <fmt_fp+0x25df>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4191ad:	41 8b 0e             	mov    ecx,DWORD PTR [r14]
  4191b0:	83 e1 20             	and    ecx,0x20
  4191b3:	e9 07 e2 ff ff       	jmp    4173bf <fmt_fp+0x9bf>
		for (i=10, j++; j<9; i*=10, j++);
  4191b8:	48 b8 10 23 fc ff ff 	movabs rax,0xfffffffffffc2310
  4191bf:	ff ff ff 
  4191c2:	f3 41 0f 7e 04 07    	movq   xmm0,QWORD PTR [r15+rax*1]
  4191c8:	e9 12 fe ff ff       	jmp    418fdf <fmt_fp+0x25df>
  4191cd:	48 b8 08 23 fc ff ff 	movabs rax,0xfffffffffffc2308
  4191d4:	ff ff ff 
  4191d7:	f3 41 0f 7e 04 07    	movq   xmm0,QWORD PTR [r15+rax*1]
  4191dd:	e9 fd fd ff ff       	jmp    418fdf <fmt_fp+0x25df>
			while (re--) round*=16;
  4191e2:	48 b8 84 22 fc ff ff 	movabs rax,0xfffffffffffc2284
  4191e9:	ff ff ff 
  4191ec:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  4191f0:	e9 b7 dd ff ff       	jmp    416fac <fmt_fp+0x5ac>
		if (x || d+1!=z) {
  4191f5:	48 83 c6 04          	add    rsi,0x4
  4191f9:	e9 15 f8 ff ff       	jmp    418a13 <fmt_fp+0x2013>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4191fe:	41 8b 06             	mov    eax,DWORD PTR [r14]
  419201:	83 e0 20             	and    eax,0x20
  419204:	e9 4a fc ff ff       	jmp    418e53 <fmt_fp+0x2453>
  419209:	41 8b 16             	mov    edx,DWORD PTR [r14]
  41920c:	83 e2 20             	and    edx,0x20
  41920f:	e9 aa e2 ff ff       	jmp    4174be <fmt_fp+0xabe>
  419214:	41 8b 0e             	mov    ecx,DWORD PTR [r14]
  419217:	83 e1 20             	and    ecx,0x20
  41921a:	e9 ec e0 ff ff       	jmp    41730b <fmt_fp+0x90b>
			while (re--) round*=16;
  41921f:	48 b8 90 22 fc ff ff 	movabs rax,0xfffffffffffc2290
  419226:	ff ff ff 
  419229:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  41922d:	e9 7a dd ff ff       	jmp    416fac <fmt_fp+0x5ac>
  419232:	48 b8 8c 22 fc ff ff 	movabs rax,0xfffffffffffc228c
  419239:	ff ff ff 
  41923c:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  419240:	e9 67 dd ff ff       	jmp    416fac <fmt_fp+0x5ac>
  419245:	48 b8 88 22 fc ff ff 	movabs rax,0xfffffffffffc2288
  41924c:	ff ff ff 
  41924f:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  419253:	e9 54 dd ff ff       	jmp    416fac <fmt_fp+0x5ac>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419258:	41 8b 36             	mov    esi,DWORD PTR [r14]
  41925b:	83 e6 20             	and    esi,0x20
  41925e:	e9 bb df ff ff       	jmp    41721e <fmt_fp+0x81e>
			while (re--) round*=16;
  419263:	48 b8 94 22 fc ff ff 	movabs rax,0xfffffffffffc2294
  41926a:	ff ff ff 
  41926d:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  419271:	e9 36 dd ff ff       	jmp    416fac <fmt_fp+0x5ac>
  419276:	48 b8 a0 22 fc ff ff 	movabs rax,0xfffffffffffc22a0
  41927d:	ff ff ff 
  419280:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  419284:	e9 23 dd ff ff       	jmp    416fac <fmt_fp+0x5ac>
  419289:	48 b8 9c 22 fc ff ff 	movabs rax,0xfffffffffffc229c
  419290:	ff ff ff 
  419293:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  419297:	e9 10 dd ff ff       	jmp    416fac <fmt_fp+0x5ac>
  41929c:	48 b8 a8 22 fc ff ff 	movabs rax,0xfffffffffffc22a8
  4192a3:	ff ff ff 
  4192a6:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  4192aa:	e9 fd dc ff ff       	jmp    416fac <fmt_fp+0x5ac>
  4192af:	48 b8 a4 22 fc ff ff 	movabs rax,0xfffffffffffc22a4
  4192b6:	ff ff ff 
  4192b9:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  4192bd:	e9 ea dc ff ff       	jmp    416fac <fmt_fp+0x5ac>
  4192c2:	48 b8 b8 22 fc ff ff 	movabs rax,0xfffffffffffc22b8
  4192c9:	ff ff ff 
  4192cc:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  4192d0:	e9 d7 dc ff ff       	jmp    416fac <fmt_fp+0x5ac>
  4192d5:	48 b8 b4 22 fc ff ff 	movabs rax,0xfffffffffffc22b4
  4192dc:	ff ff ff 
  4192df:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  4192e3:	e9 c4 dc ff ff       	jmp    416fac <fmt_fp+0x5ac>
  4192e8:	48 b8 b0 22 fc ff ff 	movabs rax,0xfffffffffffc22b0
  4192ef:	ff ff ff 
  4192f2:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  4192f6:	e9 b1 dc ff ff       	jmp    416fac <fmt_fp+0x5ac>
  4192fb:	48 b8 ac 22 fc ff ff 	movabs rax,0xfffffffffffc22ac
  419302:	ff ff ff 
  419305:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  419309:	e9 9e dc ff ff       	jmp    416fac <fmt_fp+0x5ac>
			if (z>a && z[-1]) for (i=10, j=0; z[-1]%i==0; i*=10, j++);
  41930e:	31 f6                	xor    esi,esi
  419310:	e9 1f f1 ff ff       	jmp    418434 <fmt_fp+0x1a34>
  419315:	49 89 ea             	mov    r10,rbp
  419318:	89 dd                	mov    ebp,ebx
  41931a:	e9 ff de ff ff       	jmp    41721e <fmt_fp+0x81e>
  41931f:	89 5c 24 08          	mov    DWORD PTR [rsp+0x8],ebx
  419323:	4d 89 e2             	mov    r10,r12
  419326:	e9 94 e0 ff ff       	jmp    4173bf <fmt_fp+0x9bf>

000000000041932b <printf_core.cold>:
--
	for (; l >= sizeof pad; l -= sizeof pad)
  419392:	66 0f fe c2          	paddd  xmm0,xmm2
  419396:	39 f9                	cmp    ecx,edi
  419398:	72 eb                	jb     419385 <printf_core.cold+0x5a>
  41939a:	44 89 ce             	mov    esi,r9d
--
  4193a5:	66 0f 7e c1          	movd   ecx,xmm0
  4193a9:	69 d6 00 ff ff ff    	imul   edx,esi,0xffffff00
  4193af:	44 39 ce             	cmp    esi,r9d
  4193b2:	0f 84 77 0b 00 00    	je     419f2f <printf_core+0x77f>
  4193b8:	44 01 da             	add    edx,r11d
  4193bb:	89 d1                	mov    ecx,edx
  4193bd:	81 fa ff 00 00 00    	cmp    edx,0xff
  4193c3:	0f 86 66 0b 00 00    	jbe    419f2f <printf_core+0x77f>
  4193c9:	81 e9 00 01 00 00    	sub    ecx,0x100
  4193cf:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  4193d5:	0f 86 54 0b 00 00    	jbe    419f2f <printf_core+0x77f>
  4193db:	8d 8a 00 fe ff ff    	lea    ecx,[rdx-0x200]
  4193e1:	e9 49 0b 00 00       	jmp    419f2f <printf_core+0x77f>
  4193e6:	41 8d 94 24 00 e8 ff 	lea    edx,[r12-0x1800]
  4193ed:	ff 
  4193ee:	81 fa 00 e9 ff 7f    	cmp    edx,0x7fffe900
  4193f4:	0f 87 b5 00 00 00    	ja     4194af <printf_core.cold+0x184>
  4193fa:	45 8d 84 24 00 fe ff 	lea    r8d,[r12-0x200]
--
	for (; l >= sizeof pad; l -= sizeof pad)
  41945e:	66 0f fe c2          	paddd  xmm0,xmm2
  419462:	39 ef                	cmp    edi,ebp
  419464:	77 eb                	ja     419451 <printf_core.cold+0x126>
  419466:	89 ce                	mov    esi,ecx
--
  419470:	66 0f 7e c5          	movd   ebp,xmm0
  419474:	69 c6 00 ff ff ff    	imul   eax,esi,0xffffff00
  41947a:	39 ce                	cmp    esi,ecx
  41947c:	0f 84 b2 16 00 00    	je     41ab34 <printf_core+0x1384>
  419482:	44 01 c0             	add    eax,r8d
  419485:	89 c5                	mov    ebp,eax
  419487:	3d ff 00 00 00       	cmp    eax,0xff
  41948c:	0f 86 a2 16 00 00    	jbe    41ab34 <printf_core+0x1384>
  419492:	81 ed 00 01 00 00    	sub    ebp,0x100
  419498:	81 fd ff 00 00 00    	cmp    ebp,0xff
  41949e:	0f 86 90 16 00 00    	jbe    41ab34 <printf_core+0x1384>
  4194a4:	8d a8 00 fe ff ff    	lea    ebp,[rax-0x200]
  4194aa:	e9 85 16 00 00       	jmp    41ab34 <printf_core+0x1384>
  4194af:	81 e9 00 01 00 00    	sub    ecx,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
--
	for (; l >= sizeof pad; l -= sizeof pad)
  4194b7:	89 cd                	mov    ebp,ecx
  4194b9:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  4194bf:	77 ee                	ja     4194af <printf_core.cold+0x184>
  4194c1:	e9 6e 16 00 00       	jmp    41ab34 <printf_core+0x1384>
  4194c6:	41 8d b8 00 ff ff ff 	lea    edi,[r8-0x100]
  4194cd:	4c 8b 54 24 18       	mov    r10,QWORD PTR [rsp+0x18]
--
	for (; l >= sizeof pad; l -= sizeof pad)
  41952c:	66 0f fe c2          	paddd  xmm0,xmm2
  419530:	44 39 c1             	cmp    ecx,r8d
  419533:	77 e9                	ja     41951e <printf_core.cold+0x1f3>
  419535:	44 89 fe             	mov    esi,r15d
--
  419540:	66 0f 7e c1          	movd   ecx,xmm0
  419544:	69 c6 00 ff ff ff    	imul   eax,esi,0xffffff00
  41954a:	44 39 fe             	cmp    esi,r15d
  41954d:	0f 84 45 11 00 00    	je     41a698 <printf_core+0xee8>
  419553:	01 f8                	add    eax,edi
  419555:	89 c1                	mov    ecx,eax
  419557:	3d ff 00 00 00       	cmp    eax,0xff
  41955c:	0f 86 36 11 00 00    	jbe    41a698 <printf_core+0xee8>
  419562:	81 e9 00 01 00 00    	sub    ecx,0x100
  419568:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  41956e:	0f 86 24 11 00 00    	jbe    41a698 <printf_core+0xee8>
  419574:	8d 88 00 fe ff ff    	lea    ecx,[rax-0x200]
  41957a:	e9 19 11 00 00       	jmp    41a698 <printf_core+0xee8>
  41957f:	45 8d 9f 00 ff ff ff 	lea    r11d,[r15-0x100]
  419586:	48 8b 7c 24 18       	mov    rdi,QWORD PTR [rsp+0x18]
--
	for (; l >= sizeof pad; l -= sizeof pad)
  4195e3:	66 0f fe c2          	paddd  xmm0,xmm2
  4195e7:	41 39 e9             	cmp    r9d,ebp
  4195ea:	72 e9                	jb     4195d5 <printf_core.cold+0x2aa>
  4195ec:	89 ce                	mov    esi,ecx
--
  4195f6:	66 0f 7e c5          	movd   ebp,xmm0
  4195fa:	69 d6 00 ff ff ff    	imul   edx,esi,0xffffff00
  419600:	39 ce                	cmp    esi,ecx
  419602:	0f 84 e8 0a 00 00    	je     41a0f0 <printf_core+0x940>
  419608:	44 01 da             	add    edx,r11d
  41960b:	89 d5                	mov    ebp,edx
  41960d:	81 fa ff 00 00 00    	cmp    edx,0xff
  419613:	0f 86 d7 0a 00 00    	jbe    41a0f0 <printf_core+0x940>
  419619:	81 ed 00 01 00 00    	sub    ebp,0x100
  41961f:	81 fd ff 00 00 00    	cmp    ebp,0xff
  419625:	0f 86 c5 0a 00 00    	jbe    41a0f0 <printf_core+0x940>
  41962b:	8d aa 00 fe ff ff    	lea    ebp,[rdx-0x200]
  419631:	e9 ba 0a 00 00       	jmp    41a0f0 <printf_core+0x940>
  419636:	44 8d 85 00 ff ff ff 	lea    r8d,[rbp-0x100]
  41963d:	48 8b 7c 24 18       	mov    rdi,QWORD PTR [rsp+0x18]
--
	for (; l >= sizeof pad; l -= sizeof pad)
  419699:	66 0f fe ca          	paddd  xmm1,xmm2
  41969d:	45 39 cb             	cmp    r11d,r9d
  4196a0:	72 e9                	jb     41968b <printf_core.cold+0x360>
  4196a2:	89 ce                	mov    esi,ecx
--
  4196ac:	66 41 0f 7e c4       	movd   r12d,xmm0
  4196b1:	69 c6 00 ff ff ff    	imul   eax,esi,0xffffff00
  4196b7:	39 f1                	cmp    ecx,esi
  4196b9:	0f 84 eb 0a 00 00    	je     41a1aa <printf_core+0x9fa>
  4196bf:	44 01 c0             	add    eax,r8d
  4196c2:	41 89 c4             	mov    r12d,eax
  4196c5:	3d ff 00 00 00       	cmp    eax,0xff
  4196ca:	0f 86 da 0a 00 00    	jbe    41a1aa <printf_core+0x9fa>
  4196d0:	41 81 ec 00 01 00 00 	sub    r12d,0x100
  4196d7:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  4196de:	0f 86 c6 0a 00 00    	jbe    41a1aa <printf_core+0x9fa>
  4196e4:	44 8d a0 00 fe ff ff 	lea    r12d,[rax-0x200]
  4196eb:	e9 ba 0a 00 00       	jmp    41a1aa <printf_core+0x9fa>
  4196f0:	45 8d 9f 00 ff ff ff 	lea    r11d,[r15-0x100]
  4196f7:	4c 8b 54 24 18       	mov    r10,QWORD PTR [rsp+0x18]
--
	for (; l >= sizeof pad; l -= sizeof pad)
  419755:	66 0f fe c2          	paddd  xmm0,xmm2
  419759:	39 f9                	cmp    ecx,edi
  41975b:	72 eb                	jb     419748 <printf_core.cold+0x41d>
  41975d:	44 89 ce             	mov    esi,r9d
--
  419768:	66 0f 7e c1          	movd   ecx,xmm0
  41976c:	69 c6 00 ff ff ff    	imul   eax,esi,0xffffff00
  419772:	44 39 ce             	cmp    esi,r9d
  419775:	0f 84 a3 08 00 00    	je     41a01e <printf_core+0x86e>
  41977b:	44 01 d8             	add    eax,r11d
  41977e:	89 c1                	mov    ecx,eax
  419780:	3d ff 00 00 00       	cmp    eax,0xff
  419785:	0f 86 93 08 00 00    	jbe    41a01e <printf_core+0x86e>
  41978b:	81 e9 00 01 00 00    	sub    ecx,0x100
  419791:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  419797:	0f 86 81 08 00 00    	jbe    41a01e <printf_core+0x86e>
  41979d:	8d 88 00 fe ff ff    	lea    ecx,[rax-0x200]
  4197a3:	e9 76 08 00 00       	jmp    41a01e <printf_core+0x86e>
  4197a8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4197af:	00 
--
		if (!*s) break;
  419838:	84 c0                	test   al,al
  41983a:	0f 84 50 05 00 00    	je     419d90 <printf_core+0x5e0>
		for (a=s; *s && *s!='%'; s++);
  419840:	4d 89 c6             	mov    r14,r8
  419843:	eb 10                	jmp    419855 <printf_core+0xa5>
  419845:	0f 1f 00             	nop    DWORD PTR [rax]
  419848:	41 0f b6 46 01       	movzx  eax,BYTE PTR [r14+0x1]
  41984d:	49 83 c6 01          	add    r14,0x1
  419851:	84 c0                	test   al,al
  419853:	74 6b                	je     4198c0 <printf_core+0x110>
  419855:	3c 25                	cmp    al,0x25
  419857:	75 ef                	jne    419848 <printf_core+0x98>
  419859:	4c 89 f3             	mov    rbx,r14
  41985c:	eb 0f                	jmp    41986d <printf_core+0xbd>
  41985e:	66 90                	xchg   ax,ax
		for (z=s; s[0]=='%' && s[1]=='%'; z++, s+=2);
  419860:	48 83 c3 02          	add    rbx,0x2
  419864:	49 83 c6 01          	add    r14,0x1
  419868:	80 3b 25             	cmp    BYTE PTR [rbx],0x25
  41986b:	75 06                	jne    419873 <printf_core+0xc3>
  41986d:	80 7b 01 25          	cmp    BYTE PTR [rbx+0x1],0x25
  419871:	74 ed                	je     419860 <printf_core+0xb0>
		if (z-a > INT_MAX-cnt) goto overflow;
  419873:	41 bb ff ff ff 7f    	mov    r11d,0x7fffffff
--
  41987e:	4d 29 c6             	sub    r14,r8
  419881:	49 63 c3             	movsxd rax,r11d
  419884:	49 39 c6             	cmp    r14,rax
  419887:	0f 8f 5c 03 00 00    	jg     419be9 <printf_core+0x439>
		l = z-a;
  41988d:	44 89 74 24 08       	mov    DWORD PTR [rsp+0x8],r14d
		if (f) out(f, a, l);
  419892:	4d 85 ed             	test   r13,r13
  419895:	74 0b                	je     4198a2 <printf_core+0xf2>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419897:	41 f6 45 00 20       	test   BYTE PTR [r13+0x0],0x20
  41989c:	0f 84 6e 01 00 00    	je     419a10 <printf_core+0x260>
		if (l) continue;
  4198a2:	45 85 f6             	test   r14d,r14d
  4198a5:	74 29                	je     4198d0 <printf_core+0x120>
		if (l > INT_MAX - cnt) goto overflow;
  4198a7:	44 3b 5c 24 08       	cmp    r11d,DWORD PTR [rsp+0x8]
  4198ac:	0f 8c 37 03 00 00    	jl     419be9 <printf_core+0x439>
{
  4198b2:	49 89 d8             	mov    r8,rbx
  4198b5:	e9 72 ff ff ff       	jmp    41982c <printf_core+0x7c>
  4198ba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
		for (a=s; *s && *s!='%'; s++);
  4198c0:	4c 89 f3             	mov    rbx,r14
		for (z=s; s[0]=='%' && s[1]=='%'; z++, s+=2);
  4198c3:	3c 25                	cmp    al,0x25
  4198c5:	74 92                	je     419859 <printf_core+0xa9>
  4198c7:	eb aa                	jmp    419873 <printf_core+0xc3>
  4198c9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		if (isdigit(s[1]) && s[2]=='$') {
--
  4198d4:	8d 51 d0             	lea    edx,[rcx-0x30]
  4198d7:	89 cf                	mov    edi,ecx
  4198d9:	83 fa 09             	cmp    edx,0x9
  4198dc:	77 0a                	ja     4198e8 <printf_core+0x138>
  4198de:	80 7b 02 24          	cmp    BYTE PTR [rbx+0x2],0x24
  4198e2:	0f 84 69 03 00 00    	je     419c51 <printf_core+0x4a1>
			s++;
  4198e8:	48 83 c3 01          	add    rbx,0x1
--
  4198fd:	be 01 00 00 00       	mov    esi,0x1
		for (fl=0; (unsigned)*s-' '<32 && (FLAGMASK&(1U<<*s-' ')); s++)
  419902:	41 83 f9 1f          	cmp    r9d,0x1f
  419906:	76 22                	jbe    41992a <printf_core+0x17a>
  419908:	eb 28                	jmp    419932 <printf_core+0x182>
  41990a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
			fl |= 1U<<*s-' ';
--
  41991e:	44 8d 49 e0          	lea    r9d,[rcx-0x20]
  419922:	89 cf                	mov    edi,ecx
  419924:	41 83 f9 1f          	cmp    r9d,0x1f
  419928:	77 08                	ja     419932 <printf_core+0x182>
  41992a:	83 e9 20             	sub    ecx,0x20
--
  419930:	72 de                	jb     419910 <printf_core+0x160>
		if (*s=='*') {
  419932:	40 80 ff 2a          	cmp    dil,0x2a
  419936:	0f 85 94 01 00 00    	jne    419ad0 <printf_core+0x320>
			if (isdigit(s[1]) && s[2]=='$') {
  41993c:	48 0f be 43 01       	movsx  rax,BYTE PTR [rbx+0x1]
  419941:	48 89 c6             	mov    rsi,rax
  419944:	83 e8 30             	sub    eax,0x30
  419947:	83 f8 09             	cmp    eax,0x9
  41994a:	0f 86 c0 02 00 00    	jbe    419c10 <printf_core+0x460>
			} else if (!l10n) {
  419950:	8b 44 24 58          	mov    eax,DWORD PTR [rsp+0x58]
  419954:	85 c0                	test   eax,eax
  419956:	0f 85 32 01 00 00    	jne    419a8e <printf_core+0x2de>
				s++;
  41995c:	48 83 c3 01          	add    rbx,0x1
--
  419960:	45 89 f1             	mov    r9d,r14d
  419963:	4d 85 ed             	test   r13,r13
  419966:	74 30                	je     419998 <printf_core+0x1e8>
  419968:	48 8b 7c 24 30       	mov    rdi,QWORD PTR [rsp+0x30]
  41996d:	8b 07                	mov    eax,DWORD PTR [rdi]
  41996f:	83 f8 2f             	cmp    eax,0x2f
  419972:	0f 87 08 03 00 00    	ja     419c80 <printf_core+0x4d0>
  419978:	89 c1                	mov    ecx,eax
--
  419995:	41 f7 d9             	neg    r9d
		if (*s=='.' && s[1]=='*') {
  419998:	40 80 fe 2e          	cmp    sil,0x2e
  41999c:	0f 85 a6 00 00 00    	jne    419a48 <printf_core+0x298>
  4199a2:	0f be 43 01          	movsx  eax,BYTE PTR [rbx+0x1]
  4199a6:	3c 2a                	cmp    al,0x2a
  4199a8:	0f 85 ea 02 00 00    	jne    419c98 <printf_core+0x4e8>
			if (isdigit(s[2]) && s[3]=='$') {
  4199ae:	48 0f be 43 02       	movsx  rax,BYTE PTR [rbx+0x2]
  4199b3:	48 89 c1             	mov    rcx,rax
  4199b6:	83 e8 30             	sub    eax,0x30
  4199b9:	83 f8 09             	cmp    eax,0x9
  4199bc:	77 0a                	ja     4199c8 <printf_core+0x218>
  4199be:	80 7b 03 24          	cmp    BYTE PTR [rbx+0x3],0x24
  4199c2:	0f 84 81 03 00 00    	je     419d49 <printf_core+0x599>
			} else if (!l10n) {
  4199c8:	8b 44 24 58          	mov    eax,DWORD PTR [rsp+0x58]
  4199cc:	85 c0                	test   eax,eax
  4199ce:	0f 85 ba 00 00 00    	jne    419a8e <printf_core+0x2de>
				p = f ? va_arg(*ap, int) : 0;
  4199d4:	4d 85 ed             	test   r13,r13
  4199d7:	0f 84 a5 03 00 00    	je     419d82 <printf_core+0x5d2>
  4199dd:	48 8b 7c 24 30       	mov    rdi,QWORD PTR [rsp+0x30]
  4199e2:	8b 07                	mov    eax,DWORD PTR [rdi]
  4199e4:	83 f8 2f             	cmp    eax,0x2f
  4199e7:	0f 87 12 03 00 00    	ja     419cff <printf_core+0x54f>
  4199ed:	89 c1                	mov    ecx,eax
--
  419a04:	48 83 c3 02          	add    rbx,0x2
			xp = (p>=0);
  419a08:	eb 46                	jmp    419a50 <printf_core+0x2a0>
  419a0a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
--
  419a28:	4c 89 44 24 38       	mov    QWORD PTR [rsp+0x38],r8
  419a2d:	48 01 c8             	add    rax,rcx
  419a30:	ff d0                	call   rax
  419a32:	44 8b 5c 24 50       	mov    r11d,DWORD PTR [rsp+0x50]
  419a37:	4c 8b 44 24 38       	mov    r8,QWORD PTR [rsp+0x38]
  419a3c:	e9 61 fe ff ff       	jmp    4198a2 <printf_core+0xf2>
  419a41:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
			xp = 0;
--
  419a50:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  419a55:	45 31 ff             	xor    r15d,r15d
  419a58:	eb 29                	jmp    419a83 <printf_core+0x2d3>
  419a5a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
			st=states[st]S(*s++);
--
		} while (st-1<STOP);
  419a74:	8d 46 ff             	lea    eax,[rsi-0x1]
  419a77:	83 f8 07             	cmp    eax,0x7
  419a7a:	0f 87 c8 00 00 00    	ja     419b48 <printf_core+0x398>
  419a80:	41 89 f7             	mov    r15d,esi
--
  419a83:	0f be 03             	movsx  eax,BYTE PTR [rbx]
  419a86:	83 e8 41             	sub    eax,0x41
  419a89:	83 f8 39             	cmp    eax,0x39
  419a8c:	76 d2                	jbe    419a60 <printf_core+0x2b0>
	for (; i<=NL_ARGMAX && !nl_type[i]; i++);
--
  419a98:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  419a9d:	48 01 d0             	add    rax,rdx
  419aa0:	ff d0                	call   rax
	return -1;
  419aa2:	c7 44 24 14 ff ff ff 	mov    DWORD PTR [rsp+0x14],0xffffffff
--
  419ad8:	83 e8 30             	sub    eax,0x30
  419adb:	89 ce                	mov    esi,ecx
  419add:	83 f8 09             	cmp    eax,0x9
  419ae0:	76 3a                	jbe    419b1c <printf_core+0x36c>
  419ae2:	e9 b1 fe ff ff       	jmp    419998 <printf_core+0x1e8>
  419ae7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  419aee:	00 00 
--
  419af4:	83 e9 30             	sub    ecx,0x30
  419af7:	44 8d 8f ff ff ff 7f 	lea    r9d,[rdi+0x7fffffff]
  419afe:	44 39 c9             	cmp    ecx,r9d
  419b01:	7f 2f                	jg     419b32 <printf_core+0x382>
		else i = 10*i + (**s-'0');
  419b03:	29 f9                	sub    ecx,edi
  419b05:	41 89 c9             	mov    r9d,ecx
	for (i=0; isdigit(**s); (*s)++) {
  419b08:	83 f8 09             	cmp    eax,0x9
  419b0b:	0f 87 cf 00 00 00    	ja     419be0 <printf_core+0x430>
  419b11:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
--
  419b26:	83 e8 30             	sub    eax,0x30
		if (i > INT_MAX/10U || **s-'0' > INT_MAX-10*i) i = -1;
  419b29:	41 81 f9 cc cc cc 0c 	cmp    r9d,0xccccccc
  419b30:	76 be                	jbe    419af0 <printf_core+0x340>
	for (i=0; isdigit(**s); (*s)++) {
  419b32:	83 f8 09             	cmp    eax,0x9
  419b35:	0f 87 ae 00 00 00    	ja     419be9 <printf_core+0x439>
  419b3b:	41 b9 ff ff ff ff    	mov    r9d,0xffffffff
  419b41:	eb d5                	jmp    419b18 <printf_core+0x368>
  419b43:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		if (!st) goto inval;
  419b48:	48 89 f8             	mov    rax,rdi
  419b4b:	85 f6                	test   esi,esi
  419b4d:	0f 84 3b ff ff ff    	je     419a8e <printf_core+0x2de>
		if (st==NOARG) {
  419b53:	83 fe 1b             	cmp    esi,0x1b
  419b56:	0f 84 0c 01 00 00    	je     419c68 <printf_core+0x4b8>
			if (argpos>=0) nl_type[argpos]=st, arg=nl_arg[argpos];
  419b5c:	83 fa ff             	cmp    edx,0xffffffff
  419b5f:	0f 84 ab 01 00 00    	je     419d10 <printf_core+0x560>
  419b65:	48 8b 7c 24 40       	mov    rdi,QWORD PTR [rsp+0x40]
  419b6a:	48 63 d2             	movsxd rdx,edx
--
		if (!f) continue;
  419b86:	4d 85 ed             	test   r13,r13
  419b89:	0f 84 23 fd ff ff    	je     4198b2 <printf_core+0x102>
		t = s[-1];
  419b8f:	0f be 53 ff          	movsx  edx,BYTE PTR [rbx-0x1]
--
		if (ps && (t&15)==3) t&=~32;
  419b95:	45 85 ff             	test   r15d,r15d
  419b98:	74 12                	je     419bac <printf_core+0x3fc>
  419b9a:	89 d6                	mov    esi,edx
  419b9c:	83 e1 df             	and    ecx,0xffffffdf
  419b9f:	83 e6 0f             	and    esi,0xf
  419ba2:	0f be c9             	movsx  ecx,cl
  419ba5:	40 80 fe 03          	cmp    sil,0x3
  419ba9:	0f 44 d1             	cmove  edx,ecx
		if (fl & LEFT_ADJ) fl &= ~ZERO_PAD;
--
		switch(t) {
  419bc0:	8d 4a bf             	lea    ecx,[rdx-0x41]
  419bc3:	83 f9 37             	cmp    ecx,0x37
  419bc6:	0f 87 34 02 00 00    	ja     419e00 <printf_core+0x650>
  419bcc:	48 8d 35 c5 56 00 00 	lea    rsi,[rip+0x56c5]        # 41f298 <CSWTCH.186+0x828>
  419bd3:	48 03 34 ce          	add    rsi,QWORD PTR [rsi+rcx*8]
  419bd7:	3e ff e6             	notrack jmp rsi
  419bda:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
		} else if ((w=getint(&s))<0) goto overflow;
  419be0:	83 f9 ff             	cmp    ecx,0xffffffff
  419be3:	0f 85 af fd ff ff    	jne    419998 <printf_core+0x1e8>
	errno = EOVERFLOW;
  419be9:	48 b8 f0 8c fb ff ff 	movabs rax,0xfffffffffffb8cf0
--
  419bf3:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  419bf8:	48 01 d0             	add    rax,rdx
  419bfb:	ff d0                	call   rax
	return -1;
  419bfd:	c7 44 24 14 ff ff ff 	mov    DWORD PTR [rsp+0x14],0xffffffff
--
  419c05:	c7 00 4b 00 00 00    	mov    DWORD PTR [rax],0x4b
	return -1;
  419c0b:	e9 a0 fe ff ff       	jmp    419ab0 <printf_core+0x300>
			if (isdigit(s[1]) && s[2]=='$') {
  419c10:	80 7b 02 24          	cmp    BYTE PTR [rbx+0x2],0x24
  419c14:	0f 85 36 fd ff ff    	jne    419950 <printf_core+0x1a0>
				nl_type[s[1]-'0'] = INT;
  419c1a:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
--
  419c4b:	ff 
				s+=3;
  419c4c:	e9 35 fd ff ff       	jmp    419986 <printf_core+0x1d6>
		for (fl=0; (unsigned)*s-' '<32 && (FLAGMASK&(1U<<*s-' ')); s++)
  419c51:	0f be 4b 03          	movsx  ecx,BYTE PTR [rbx+0x3]
--
  419c61:	89 cf                	mov    edi,ecx
			s+=3;
  419c63:	e9 89 fc ff ff       	jmp    4198f1 <printf_core+0x141>
			if (argpos>=0) goto inval;
  419c68:	83 fa ff             	cmp    edx,0xffffffff
  419c6b:	0f 84 15 ff ff ff    	je     419b86 <printf_core+0x3d6>
  419c71:	e9 18 fe ff ff       	jmp    419a8e <printf_core+0x2de>
  419c76:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  419c7d:	00 00 00 
--
  419c84:	48 8d 41 08          	lea    rax,[rcx+0x8]
  419c88:	48 89 47 08          	mov    QWORD PTR [rdi+0x8],rax
  419c8c:	e9 f2 fc ff ff       	jmp    419983 <printf_core+0x1d3>
  419c91:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (i=0; isdigit(**s); (*s)++) {
--
	for (i=0; isdigit(**s); (*s)++) {
  419c9f:	44 89 f5             	mov    ebp,r14d
  419ca2:	83 f9 09             	cmp    ecx,0x9
  419ca5:	77 4d                	ja     419cf4 <printf_core+0x544>
		if (i > INT_MAX/10U || **s-'0' > INT_MAX-10*i) i = -1;
  419ca7:	be ff ff ff ff       	mov    esi,0xffffffff
  419cac:	eb 29                	jmp    419cd7 <printf_core+0x527>
  419cae:	66 90                	xchg   ax,ax
  419cb0:	6b ed f6             	imul   ebp,ebp,0xfffffff6
--
  419cb8:	8d bd ff ff ff 7f    	lea    edi,[rbp+0x7fffffff]
  419cbe:	29 e9                	sub    ecx,ebp
  419cc0:	39 f8                	cmp    eax,edi
  419cc2:	0f 4f ce             	cmovg  ecx,esi
	for (i=0; isdigit(**s); (*s)++) {
--
  419ccd:	89 cd                	mov    ebp,ecx
  419ccf:	8d 48 d0             	lea    ecx,[rax-0x30]
  419cd2:	83 f9 09             	cmp    ecx,0x9
  419cd5:	77 1d                	ja     419cf4 <printf_core+0x544>
		if (i > INT_MAX/10U || **s-'0' > INT_MAX-10*i) i = -1;
  419cd7:	81 fd cc cc cc 0c    	cmp    ebp,0xccccccc
  419cdd:	76 d1                	jbe    419cb0 <printf_core+0x500>
	for (i=0; isdigit(**s); (*s)++) {
--
	for (i=0; isdigit(**s); (*s)++) {
  419cec:	8d 48 d0             	lea    ecx,[rax-0x30]
  419cef:	83 f9 09             	cmp    ecx,0x9
  419cf2:	76 e3                	jbe    419cd7 <printf_core+0x527>
			xp = 1;
  419cf4:	41 ba 01 00 00 00    	mov    r10d,0x1
  419cfa:	e9 51 fd ff ff       	jmp    419a50 <printf_core+0x2a0>
				p = f ? va_arg(*ap, int) : 0;
  419cff:	48 8b 4f 08          	mov    rcx,QWORD PTR [rdi+0x8]
  419d03:	48 8d 41 08          	lea    rax,[rcx+0x8]
  419d07:	48 89 47 08          	mov    QWORD PTR [rdi+0x8],rax
  419d0b:	e9 e8 fc ff ff       	jmp    4199f8 <printf_core+0x248>
			else if (f) pop_arg(&arg, st, ap);
  419d10:	4d 85 ed             	test   r13,r13
  419d13:	0f 84 97 0f 00 00    	je     41acb0 <printf_core+0x1500>
  419d19:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  419d1e:	48 8b 54 24 30       	mov    rdx,QWORD PTR [rsp+0x30]
--
  419d39:	00 
  419d3a:	48 01 c1             	add    rcx,rax
  419d3d:	ff d1                	call   rcx
		if (!f) continue;
  419d3f:	48 8b 44 24 38       	mov    rax,QWORD PTR [rsp+0x38]
  419d44:	e9 46 fe ff ff       	jmp    419b8f <printf_core+0x3df>
				nl_type[s[2]-'0'] = INT;
  419d49:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
--
  419d7a:	41 89 c2             	mov    r10d,eax
				s+=4;
  419d7d:	e9 ce fc ff ff       	jmp    419a50 <printf_core+0x2a0>
				p = f ? va_arg(*ap, int) : 0;
  419d82:	44 89 f5             	mov    ebp,r14d
  419d85:	41 ba 01 00 00 00    	mov    r10d,0x1
  419d8b:	e9 74 fc ff ff       	jmp    419a04 <printf_core+0x254>
	if (f) return cnt;
  419d90:	4d 85 ed             	test   r13,r13
  419d93:	0f 85 17 fd ff ff    	jne    419ab0 <printf_core+0x300>
	if (!l10n) return 0;
  419d99:	44 8b 64 24 58       	mov    r12d,DWORD PTR [rsp+0x58]
  419d9e:	45 85 e4             	test   r12d,r12d
  419da1:	0f 84 09 0f 00 00    	je     41acb0 <printf_core+0x1500>
  419da7:	48 8b 7c 24 48       	mov    rdi,QWORD PTR [rsp+0x48]
		pop_arg(nl_arg+i, nl_type[i], ap);
--
  419dca:	43 8b 34 83          	mov    esi,DWORD PTR [r11+r8*4]
  419dce:	85 f6                	test   esi,esi
  419dd0:	0f 84 6c 0f 00 00    	je     41ad42 <printf_core+0x1592>
		pop_arg(nl_arg+i, nl_type[i], ap);
  419dd6:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
--
  419ddf:	4c 89 d2             	mov    rdx,r10
  419de2:	4c 01 c8             	add    rax,r9
  419de5:	ff d0                	call   rax
	for (i=1; i<=NL_ARGMAX && nl_type[i]; i++)
  419de7:	48 83 c7 10          	add    rdi,0x10
  419deb:	49 83 f8 0a          	cmp    r8,0xa
  419def:	75 d9                	jne    419dca <printf_core+0x61a>
	return 1;
  419df1:	c7 44 24 14 01 00 00 	mov    DWORD PTR [rsp+0x14],0x1
  419df8:	00 
  419df9:	e9 b2 fc ff ff       	jmp    419ab0 <printf_core+0x300>
  419dfe:	66 90                	xchg   ax,ax
		if (p < z-a) p = z-a;
--
  419e0b:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
  419e10:	48 63 c5             	movsxd rax,ebp
  419e13:	48 39 44 24 50       	cmp    QWORD PTR [rsp+0x50],rax
  419e18:	44 89 74 24 60       	mov    DWORD PTR [rsp+0x60],r14d
  419e1d:	0f 8e 8d 0d 00 00    	jle    41abb0 <printf_core+0x1400>
--
  419e3f:	8b 6c 24 50          	mov    ebp,DWORD PTR [rsp+0x50]
		if (p > INT_MAX-pl) goto overflow;
  419e43:	39 d5                	cmp    ebp,edx
  419e45:	0f 8f 9e fd ff ff    	jg     419be9 <printf_core+0x439>
		if (w < pl+p) w = pl+p;
  419e4b:	8b 44 24 60          	mov    eax,DWORD PTR [rsp+0x60]
--
  419e51:	89 44 24 5c          	mov    DWORD PTR [rsp+0x5c],eax
  419e55:	8b 44 24 5c          	mov    eax,DWORD PTR [rsp+0x5c]
  419e59:	41 39 c1             	cmp    r9d,eax
  419e5c:	44 0f 4c c8          	cmovl  r9d,eax
  419e60:	44 89 4c 24 08       	mov    DWORD PTR [rsp+0x8],r9d
		if (w > INT_MAX-cnt) goto overflow;
  419e65:	45 39 cb             	cmp    r11d,r9d
  419e68:	0f 8c 7b fd ff ff    	jl     419be9 <printf_core+0x439>
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  419e6e:	41 39 c1             	cmp    r9d,eax
  419e71:	0f 9e 44 24 38       	setle  BYTE PTR [rsp+0x38]
  419e76:	0f b6 44 24 38       	movzx  eax,BYTE PTR [rsp+0x38]
  419e7b:	41 f7 c4 00 20 01 00 	test   r12d,0x12000
  419e82:	0f 85 ec 0a 00 00    	jne    41a974 <printf_core+0x11c4>
  419e88:	84 c0                	test   al,al
  419e8a:	0f 85 e4 0a 00 00    	jne    41a974 <printf_core+0x11c4>
  419e90:	44 89 c9             	mov    ecx,r9d
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
--
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  419e9c:	4c 8b 7c 24 18       	mov    r15,QWORD PTR [rsp+0x18]
  419ea1:	39 c1                	cmp    ecx,eax
  419ea3:	4c 8d b4 24 d0 00 00 	lea    r14,[rsp+0xd0]
  419eaa:	00 
--
  419ec9:	ff ff ff 
  419ecc:	4c 01 f8             	add    rax,r15
  419ecf:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  419ed1:	8b 4c 24 68          	mov    ecx,DWORD PTR [rsp+0x68]
  419ed5:	4c 8b 44 24 78       	mov    r8,QWORD PTR [rsp+0x78]
  419eda:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  419ee0:	0f 8e 5f 0d 00 00    	jle    41ac45 <printf_core+0x1495>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
--
  419ef1:	89 d0                	mov    eax,edx
  419ef3:	83 e0 20             	and    eax,0x20
  419ef6:	0f 84 24 0a 00 00    	je     41a920 <printf_core+0x1170>
	for (; l >= sizeof pad; l -= sizeof pad)
  419efc:	41 81 ff ff 00 00 00 	cmp    r15d,0xff
  419f03:	7e 57                	jle    419f5c <printf_core+0x7ac>
  419f05:	41 8d 97 00 e9 ff ff 	lea    edx,[r15-0x1700]
  419f0c:	81 fa 00 e9 ff 7f    	cmp    edx,0x7fffe900
  419f12:	0f 86 13 f4 ff ff    	jbe    41932b <printf_core.cold>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
--
	for (; l >= sizeof pad; l -= sizeof pad)
  419f23:	44 89 f9             	mov    ecx,r15d
  419f26:	41 81 ff ff 00 00 00 	cmp    r15d,0xff
  419f2d:	77 eb                	ja     419f1a <printf_core+0x76a>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419f2f:	85 c0                	test   eax,eax
  419f31:	75 31                	jne    419f64 <printf_core+0x7b4>
  419f33:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
	out(f, pad, l);
--
  419f48:	4c 89 f7             	mov    rdi,r14
  419f4b:	48 01 c8             	add    rax,rcx
  419f4e:	ff d0                	call   rax
  419f50:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
  419f54:	4c 8b 44 24 68       	mov    r8,QWORD PTR [rsp+0x68]
  419f59:	83 e0 20             	and    eax,0x20
  419f5c:	85 c0                	test   eax,eax
  419f5e:	0f 84 1f 0a 00 00    	je     41a983 <printf_core+0x11d3>
		pad(f, '0', w, pl+p, fl^ZERO_PAD);
  419f64:	44 89 e0             	mov    eax,r12d
--
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  419f6c:	a9 00 20 01 00       	test   eax,0x12000
  419f71:	0f 85 d1 00 00 00    	jne    41a048 <printf_core+0x898>
  419f77:	80 7c 24 38 00       	cmp    BYTE PTR [rsp+0x38],0x0
  419f7c:	0f 85 c6 00 00 00    	jne    41a048 <printf_core+0x898>
	l = w - l;
  419f82:	8b 4c 24 08          	mov    ecx,DWORD PTR [rsp+0x8]
--
  419f8f:	4c 8d b4 24 d0 00 00 	lea    r14,[rsp+0xd0]
  419f96:	00 
  419f97:	39 c1                	cmp    ecx,eax
  419f99:	4c 8b 7c 24 18       	mov    r15,QWORD PTR [rsp+0x18]
  419f9e:	4c 89 44 24 68       	mov    QWORD PTR [rsp+0x68],r8
--
  419fbc:	ff ff ff 
  419fbf:	4c 01 f8             	add    rax,r15
  419fc2:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  419fc4:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  419fc8:	4c 8b 44 24 68       	mov    r8,QWORD PTR [rsp+0x68]
  419fcd:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  419fd3:	0f 8e 60 0c 00 00    	jle    41ac39 <printf_core+0x1489>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
--
  419fdd:	44 8d b9 00 ff ff ff 	lea    r15d,[rcx-0x100]
  419fe4:	83 e0 20             	and    eax,0x20
  419fe7:	0f 84 a3 08 00 00    	je     41a890 <printf_core+0x10e0>
	for (; l >= sizeof pad; l -= sizeof pad)
  419fed:	41 81 ff ff 00 00 00 	cmp    r15d,0xff
  419ff4:	7e 52                	jle    41a048 <printf_core+0x898>
  419ff6:	41 8d 97 00 e9 ff ff 	lea    edx,[r15-0x1700]
  419ffd:	81 fa 00 e9 ff 7f    	cmp    edx,0x7fffe900
  41a003:	0f 86 e7 f6 ff ff    	jbe    4196f0 <printf_core.cold+0x3c5>
  41a009:	41 81 ef 00 01 00 00 	sub    r15d,0x100
--
	for (; l >= sizeof pad; l -= sizeof pad)
  41a012:	44 89 f9             	mov    ecx,r15d
  41a015:	41 81 ff ff 00 00 00 	cmp    r15d,0xff
  41a01c:	77 eb                	ja     41a009 <printf_core+0x859>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a01e:	85 d2                	test   edx,edx
  41a020:	75 26                	jne    41a048 <printf_core+0x898>
  41a022:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
	out(f, pad, l);
--
  41a037:	4c 89 f7             	mov    rdi,r14
  41a03a:	48 01 c8             	add    rax,rcx
  41a03d:	ff d0                	call   rax
  41a03f:	4c 8b 44 24 60       	mov    r8,QWORD PTR [rsp+0x60]
  41a044:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41a048:	39 6c 24 50          	cmp    DWORD PTR [rsp+0x50],ebp
  41a04c:	0f 8d 5c 09 00 00    	jge    41a9ae <printf_core+0x11fe>
	l = w - l;
  41a052:	2b 6c 24 50          	sub    ebp,DWORD PTR [rsp+0x50]
--
  41a060:	4c 8d b4 24 d0 00 00 	lea    r14,[rsp+0xd0]
  41a067:	00 
  41a068:	39 c5                	cmp    ebp,eax
  41a06a:	4c 89 44 24 60       	mov    QWORD PTR [rsp+0x60],r8
  41a06f:	be 30 00 00 00       	mov    esi,0x30
--
  41a084:	ff ff ff 
  41a087:	4c 01 f8             	add    rax,r15
  41a08a:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  41a08c:	81 fd ff 00 00 00    	cmp    ebp,0xff
  41a092:	4c 8b 44 24 60       	mov    r8,QWORD PTR [rsp+0x60]
  41a097:	0f 8e 83 0b 00 00    	jle    41ac20 <printf_core+0x1470>
--
  41a0ab:	89 d0                	mov    eax,edx
  41a0ad:	83 e0 20             	and    eax,0x20
  41a0b0:	0f 84 9a 07 00 00    	je     41a850 <printf_core+0x10a0>
	for (; l >= sizeof pad; l -= sizeof pad)
  41a0b6:	49 89 e8             	mov    r8,rbp
  41a0b9:	41 81 ff ff 00 00 00 	cmp    r15d,0xff
  41a0c0:	0f 8e ef 08 00 00    	jle    41a9b5 <printf_core+0x1205>
  41a0c6:	41 8d 97 00 e9 ff ff 	lea    edx,[r15-0x1700]
  41a0cd:	81 fa 00 e9 ff 7f    	cmp    edx,0x7fffe900
  41a0d3:	0f 86 a6 f4 ff ff    	jbe    41957f <printf_core.cold+0x254>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
--
	for (; l >= sizeof pad; l -= sizeof pad)
  41a0e4:	44 89 fd             	mov    ebp,r15d
  41a0e7:	41 81 ff ff 00 00 00 	cmp    r15d,0xff
  41a0ee:	77 eb                	ja     41a0db <printf_core+0x92b>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a0f0:	85 c0                	test   eax,eax
  41a0f2:	0f 84 71 0a 00 00    	je     41ab69 <printf_core+0x13b9>
		pad(f, ' ', w, pl+p, fl^LEFT_ADJ);
  41a0f8:	41 81 f4 00 20 00 00 	xor    r12d,0x2000
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41a0ff:	41 81 e4 00 20 01 00 	and    r12d,0x12000
  41a106:	0f 85 a6 f7 ff ff    	jne    4198b2 <printf_core+0x102>
  41a10c:	80 7c 24 38 00       	cmp    BYTE PTR [rsp+0x38],0x0
  41a111:	0f 85 9b f7 ff ff    	jne    4198b2 <printf_core+0x102>
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41a117:	b8 00 01 00 00       	mov    eax,0x100
--
  41a126:	4c 8d b4 24 d0 00 00 	lea    r14,[rsp+0xd0]
  41a12d:	00 
  41a12e:	41 39 c4             	cmp    r12d,eax
  41a131:	4c 8b 7c 24 18       	mov    r15,QWORD PTR [rsp+0x18]
  41a136:	be 20 00 00 00       	mov    esi,0x20
--
  41a14c:	ff ff ff 
  41a14f:	4c 01 f8             	add    rax,r15
  41a152:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  41a154:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  41a15b:	0f 8e f0 0a 00 00    	jle    41ac51 <printf_core+0x14a1>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
--
  41a16d:	0f 1f 00             	nop    DWORD PTR [rax]
  41a170:	83 e0 20             	and    eax,0x20
  41a173:	0f 84 67 07 00 00    	je     41a8e0 <printf_core+0x1130>
	for (; l >= sizeof pad; l -= sizeof pad)
  41a179:	81 fd ff 00 00 00    	cmp    ebp,0xff
  41a17f:	0f 8e 2d f7 ff ff    	jle    4198b2 <printf_core+0x102>
  41a185:	8d 95 00 e9 ff ff    	lea    edx,[rbp-0x1700]
  41a18b:	81 fa 00 e9 ff 7f    	cmp    edx,0x7fffe900
  41a191:	0f 86 9f f4 ff ff    	jbe    419636 <printf_core.cold+0x30b>
  41a197:	81 ed 00 01 00 00    	sub    ebp,0x100
--
	for (; l >= sizeof pad; l -= sizeof pad)
  41a19f:	41 89 ec             	mov    r12d,ebp
  41a1a2:	81 fd ff 00 00 00    	cmp    ebp,0xff
  41a1a8:	77 ed                	ja     41a197 <printf_core+0x9e7>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a1aa:	85 d2                	test   edx,edx
  41a1ac:	0f 85 00 f7 ff ff    	jne    4198b2 <printf_core+0x102>
  41a1b2:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  41a1b7:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
--
  41a1c2:	4c 89 f7             	mov    rdi,r14
  41a1c5:	48 01 c8             	add    rax,rcx
  41a1c8:	ff d0                	call   rax
  41a1ca:	e9 e3 f6 ff ff       	jmp    4198b2 <printf_core+0x102>
			if (xp && p<0) goto overflow;
  41a1cf:	85 ed                	test   ebp,ebp
  41a1d1:	79 0a                	jns    41a1dd <printf_core+0xa2d>
  41a1d3:	41 83 e2 01          	and    r10d,0x1
  41a1d7:	0f 85 0c fa ff ff    	jne    419be9 <printf_core+0x439>
  41a1dd:	44 89 5c 24 38       	mov    DWORD PTR [rsp+0x38],r11d
			l = fmt_fp(f, arg.f, w, p, fl, t);
--
  41a208:	4c 8b 54 24 28       	mov    r10,QWORD PTR [rsp+0x28]
  41a20d:	4c 01 d0             	add    rax,r10
  41a210:	ff d0                	call   rax
			if (l<0) goto overflow;
  41a212:	85 c0                	test   eax,eax
--
  41a21c:	44 8b 5c 24 38       	mov    r11d,DWORD PTR [rsp+0x38]
  41a221:	0f 89 80 f6 ff ff    	jns    4198a7 <printf_core+0xf7>
  41a227:	e9 bd f9 ff ff       	jmp    419be9 <printf_core+0x439>
  41a22c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
			if (arg.i>INTMAX_MAX) {
--
			} else if (fl & MARK_POS) {
  41a241:	41 f7 c4 00 08 00 00 	test   r12d,0x800
  41a248:	0f 85 3e 0a 00 00    	jne    41ac8c <printf_core+0x14dc>
			} else if (fl & PAD_POS) {
  41a24e:	41 f6 c4 01          	test   r12b,0x1
  41a252:	0f 85 c0 0b 00 00    	jne    41ae18 <printf_core+0x1668>
		prefix = "-+   0X0x";
  41a258:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
--
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  41a274:	48 85 c9             	test   rcx,rcx
  41a277:	0f 84 b5 0a 00 00    	je     41ad32 <printf_core+0x1582>
		prefix = "-+   0X0x";
  41a27d:	4c 8d bc 24 cb 00 00 	lea    r15,[rsp+0xcb]
--
  41a2b9:	48 89 c8             	mov    rax,rcx
  41a2bc:	48 89 d1             	mov    rcx,rdx
  41a2bf:	48 83 f8 09          	cmp    rax,0x9
  41a2c3:	77 d3                	ja     41a298 <printf_core+0xae8>
			if (xp && p<0) goto overflow;
--
  41a2c7:	79 0a                	jns    41a2d3 <printf_core+0xb23>
  41a2c9:	41 f6 c2 01          	test   r10b,0x1
  41a2cd:	0f 85 16 f9 ff ff    	jne    419be9 <printf_core+0x439>
			if (xp) fl &= ~ZERO_PAD;
  41a2d3:	44 89 e0             	mov    eax,r12d
--
  41a2de:	44 0f 45 e0          	cmovne r12d,eax
			if (!arg.i && !p) {
  41a2e2:	48 83 bc 24 90 00 00 	cmp    QWORD PTR [rsp+0x90],0x0
  41a2e9:	00 00 
  41a2eb:	0f 94 c0             	sete   al
  41a2ee:	85 ed                	test   ebp,ebp
  41a2f0:	75 08                	jne    41a2fa <printf_core+0xb4a>
  41a2f2:	84 c0                	test   al,al
  41a2f4:	0f 85 9d 08 00 00    	jne    41ab97 <printf_core+0x13e7>
			p = MAX(p, z-a + !arg.i);
  41a2fa:	4c 89 ff             	mov    rdi,r15
--
  41a30b:	48 01 f8             	add    rax,rdi
  41a30e:	48 89 7c 24 50       	mov    QWORD PTR [rsp+0x50],rdi
  41a313:	48 39 e8             	cmp    rax,rbp
  41a316:	48 0f 4c c5          	cmovl  rax,rbp
		if (p > INT_MAX-pl) goto overflow;
--
		if (p < z-a) p = z-a;
  41a320:	48 98                	cdqe   
  41a322:	48 39 c7             	cmp    rdi,rax
  41a325:	0f 8f 14 fb ff ff    	jg     419e3f <printf_core+0x68f>
  41a32b:	e9 13 fb ff ff       	jmp    419e43 <printf_core+0x693>
			a = fmt_x(arg.i, z, t&32);
  41a330:	89 d7                	mov    edi,edx
--
	for (; x; x>>=4) *--s = xdigits[(x&15)]|lower;
  41a33d:	48 85 c0             	test   rax,rax
  41a340:	0f 84 c0 09 00 00    	je     41ad06 <printf_core+0x1556>
  41a346:	89 54 24 38          	mov    DWORD PTR [rsp+0x38],edx
  41a34a:	4c 8d bc 24 cb 00 00 	lea    r15,[rsp+0xcb]
--
  41a378:	48 c1 e8 04          	shr    rax,0x4
  41a37c:	41 88 10             	mov    BYTE PTR [r8],dl
  41a37f:	75 e7                	jne    41a368 <printf_core+0xbb8>
  41a381:	8b 54 24 38          	mov    edx,DWORD PTR [rsp+0x38]
			if (arg.i && (fl & ALT_FORM)) prefix+=(t>>4), pl=2;
  41a385:	41 f6 c4 08          	test   r12b,0x8
  41a389:	0f 84 d5 00 00 00    	je     41a464 <printf_core+0xcb4>
  41a38f:	89 d0                	mov    eax,edx
  41a391:	48 8b 7c 24 18       	mov    rdi,QWORD PTR [rsp+0x18]
--
  41a3b0:	48 01 d0             	add    rax,rdx
  41a3b3:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  41a3b8:	e9 08 ff ff ff       	jmp    41a2c5 <printf_core+0xb15>
		prefix = "-+   0X0x";
  41a3bd:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
--
		if (p < z-a) p = z-a;
  41a410:	8b 6c 24 08          	mov    ebp,DWORD PTR [rsp+0x8]
  41a414:	e9 3c fa ff ff       	jmp    419e55 <printf_core+0x6a5>
			a = fmt_o(arg.i, z);
  41a419:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
--
  41a429:	4d 89 f8             	mov    r8,r15
  41a42c:	48 85 c0             	test   rax,rax
  41a42f:	74 1c                	je     41a44d <printf_core+0xc9d>
  41a431:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  41a438:	89 c2                	mov    edx,eax
--
  41a444:	48 c1 e8 03          	shr    rax,0x3
  41a448:	41 88 10             	mov    BYTE PTR [r8],dl
  41a44b:	75 eb                	jne    41a438 <printf_core+0xc88>
			if ((fl&ALT_FORM) && p<z-a+1) p=z-a+1;
  41a44d:	41 f6 c4 08          	test   r12b,0x8
  41a451:	74 11                	je     41a464 <printf_core+0xcb4>
  41a453:	4c 89 f8             	mov    rax,r15
  41a456:	48 63 d5             	movsxd rdx,ebp
  41a459:	4c 29 c0             	sub    rax,r8
  41a45c:	48 39 d0             	cmp    rax,rdx
  41a45f:	7c 03                	jl     41a464 <printf_core+0xcb4>
  41a461:	8d 68 01             	lea    ebp,[rax+0x1]
--
  41a478:	48 01 d0             	add    rax,rdx
  41a47b:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  41a480:	e9 40 fe ff ff       	jmp    41a2c5 <printf_core+0xb15>
			p = MAX(p, 2*sizeof(void*));
  41a485:	b8 10 00 00 00       	mov    eax,0x10
--
  41a48f:	ba 78 00 00 00       	mov    edx,0x78
			p = MAX(p, 2*sizeof(void*));
  41a494:	39 c5                	cmp    ebp,eax
  41a496:	0f 42 e8             	cmovb  ebp,eax
			fl |= ALT_FORM;
  41a499:	41 83 cc 08          	or     r12d,0x8
  41a49d:	e9 93 fe ff ff       	jmp    41a335 <printf_core+0xb85>
			a = arg.p ? arg.p : "(null)";
  41a4a2:	4c 8b 84 24 90 00 00 	mov    r8,QWORD PTR [rsp+0x90]
  41a4a9:	00 
  41a4aa:	4d 85 c0             	test   r8,r8
  41a4ad:	0f 84 0a 08 00 00    	je     41acbd <printf_core+0x150d>
			z = a + strnlen(a, p<0 ? INT_MAX : p);
  41a4b3:	85 ed                	test   ebp,ebp
--
  41a4da:	4c 89 44 24 08       	mov    QWORD PTR [rsp+0x8],r8
  41a4df:	4c 01 f8             	add    rax,r15
  41a4e2:	ff d0                	call   rax
  41a4e4:	4c 8b 44 24 08       	mov    r8,QWORD PTR [rsp+0x8]
  41a4e9:	44 8b 5c 24 38       	mov    r11d,DWORD PTR [rsp+0x38]
--
  41a504:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
			break;
  41a509:	e9 02 f9 ff ff       	jmp    419e10 <printf_core+0x660>
			ws = arg.p;
  41a50e:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
--
  41a51e:	48 89 c2             	mov    rdx,rax
  41a521:	48 85 c0             	test   rax,rax
  41a524:	0f 84 1e 09 00 00    	je     41ae48 <printf_core+0x1698>
  41a52a:	4c 8b 74 24 50       	mov    r14,QWORD PTR [rsp+0x50]
  41a52f:	31 ed                	xor    ebp,ebp
--
  41a554:	44 89 4c 24 60       	mov    DWORD PTR [rsp+0x60],r9d
  41a559:	48 89 c5             	mov    rbp,rax
  41a55c:	eb 3a                	jmp    41a598 <printf_core+0xde8>
  41a55e:	66 90                	xchg   ax,ax
  41a560:	4c 8b 7c 24 18       	mov    r15,QWORD PTR [rsp+0x18]
--
  41a573:	ff ff ff 
  41a576:	4c 01 f8             	add    rax,r15
  41a579:	ff d0                	call   rax
  41a57b:	85 c0                	test   eax,eax
  41a57d:	0f 88 a9 06 00 00    	js     41ac2c <printf_core+0x147c>
--
  41a586:	48 98                	cdqe   
  41a588:	4c 29 ee             	sub    rsi,r13
  41a58b:	48 39 f0             	cmp    rax,rsi
  41a58e:	77 10                	ja     41a5a0 <printf_core+0xdf0>
  41a590:	49 01 c5             	add    r13,rax
  41a593:	49 39 dd             	cmp    r13,rbx
  41a596:	73 08                	jae    41a5a0 <printf_core+0xdf0>
  41a598:	41 8b 34 24          	mov    esi,DWORD PTR [r12]
  41a59c:	85 f6                	test   esi,esi
  41a59e:	75 c0                	jne    41a560 <printf_core+0xdb0>
  41a5a0:	4c 89 ed             	mov    rbp,r13
  41a5a3:	44 8b 5c 24 08       	mov    r11d,DWORD PTR [rsp+0x8]
--
  41a5b0:	44 8b 64 24 5c       	mov    r12d,DWORD PTR [rsp+0x5c]
  41a5b5:	44 8b 4c 24 60       	mov    r9d,DWORD PTR [rsp+0x60]
  41a5ba:	48 81 fd ff ff ff 7f 	cmp    rbp,0x7fffffff
  41a5c1:	0f 87 22 f6 ff ff    	ja     419be9 <printf_core+0x439>
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41a5c7:	41 39 e9             	cmp    r9d,ebp
			p = i;
  41a5ca:	89 6c 24 08          	mov    DWORD PTR [rsp+0x8],ebp
--
  41a5d3:	0f b6 44 24 38       	movzx  eax,BYTE PTR [rsp+0x38]
  41a5d8:	41 f7 c4 00 20 01 00 	test   r12d,0x12000
  41a5df:	0f 85 c0 00 00 00    	jne    41a6a5 <printf_core+0xef5>
  41a5e5:	84 c0                	test   al,al
  41a5e7:	0f 85 b8 00 00 00    	jne    41a6a5 <printf_core+0xef5>
	l = w - l;
  41a5ed:	44 89 c9             	mov    ecx,r9d
--
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41a5f9:	4c 8b 7c 24 18       	mov    r15,QWORD PTR [rsp+0x18]
  41a5fe:	39 c1                	cmp    ecx,eax
  41a600:	44 89 5c 24 60       	mov    DWORD PTR [rsp+0x60],r11d
  41a605:	be 20 00 00 00       	mov    esi,0x20
--
  41a62b:	ff ff ff 
  41a62e:	4c 01 f8             	add    rax,r15
  41a631:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  41a633:	8b 4c 24 38          	mov    ecx,DWORD PTR [rsp+0x38]
  41a637:	44 8b 4c 24 5c       	mov    r9d,DWORD PTR [rsp+0x5c]
  41a63c:	44 8b 5c 24 60       	mov    r11d,DWORD PTR [rsp+0x60]
  41a641:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  41a647:	0f 8e ef 07 00 00    	jle    41ae3c <printf_core+0x168c>
  41a64d:	44 8d 81 00 ff ff ff 	lea    r8d,[rcx-0x100]
--
  41a658:	45 89 c7             	mov    r15d,r8d
  41a65b:	83 e0 20             	and    eax,0x20
  41a65e:	0f 84 78 03 00 00    	je     41a9dc <printf_core+0x122c>
	for (; l >= sizeof pad; l -= sizeof pad)
  41a664:	45 89 f8             	mov    r8d,r15d
  41a667:	41 81 ff ff 00 00 00 	cmp    r15d,0xff
  41a66e:	7e 30                	jle    41a6a0 <printf_core+0xef0>
  41a670:	41 8d 90 00 e9 ff ff 	lea    edx,[r8-0x1700]
  41a677:	81 fa 00 e9 ff 7f    	cmp    edx,0x7fffe900
  41a67d:	0f 86 43 ee ff ff    	jbe    4194c6 <printf_core.cold+0x19b>
  41a683:	41 81 e8 00 01 00 00 	sub    r8d,0x100
--
	for (; l >= sizeof pad; l -= sizeof pad)
  41a68c:	44 89 c1             	mov    ecx,r8d
  41a68f:	41 81 f8 ff 00 00 00 	cmp    r8d,0xff
  41a696:	77 eb                	ja     41a683 <printf_core+0xed3>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a698:	85 d2                	test   edx,edx
  41a69a:	0f 84 35 06 00 00    	je     41acd5 <printf_core+0x1525>
  41a6a0:	c6 44 24 38 00       	mov    BYTE PTR [rsp+0x38],0x0
			for (i=0; i<0U+p && *ws && i+(l=wctomb(mb, *ws++))<=p; i+=l)
  41a6a5:	45 31 f6             	xor    r14d,r14d
  41a6a8:	48 85 ed             	test   rbp,rbp
  41a6ab:	0f 84 92 03 00 00    	je     41aa43 <printf_core+0x1293>
  41a6b1:	48 89 5c 24 60       	mov    QWORD PTR [rsp+0x60],rbx
  41a6b6:	4c 89 f3             	mov    rbx,r14
--
  41a6c6:	44 89 64 24 68       	mov    DWORD PTR [rsp+0x68],r12d
  41a6cb:	44 89 4c 24 50       	mov    DWORD PTR [rsp+0x50],r9d
  41a6d0:	eb 0f                	jmp    41a6e1 <printf_core+0xf31>
  41a6d2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  41a6d8:	4c 39 f3             	cmp    rbx,r14
  41a6db:	0f 83 4e 03 00 00    	jae    41aa2f <printf_core+0x127f>
  41a6e1:	8b 75 00             	mov    esi,DWORD PTR [rbp+0x0]
  41a6e4:	85 f6                	test   esi,esi
  41a6e6:	0f 84 43 03 00 00    	je     41aa2f <printf_core+0x127f>
  41a6ec:	4c 8b 7c 24 18       	mov    r15,QWORD PTR [rsp+0x18]
  41a6f1:	4c 8d a4 24 84 00 00 	lea    r12,[rsp+0x84]
--
  41a707:	4c 89 e7             	mov    rdi,r12
  41a70a:	4c 01 f8             	add    rax,r15
  41a70d:	ff d0                	call   rax
  41a70f:	48 63 f0             	movsxd rsi,eax
  41a712:	48 01 f3             	add    rbx,rsi
  41a715:	4c 39 f3             	cmp    rbx,r14
  41a718:	0f 87 11 03 00 00    	ja     41aa2f <printf_core+0x127f>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a71e:	41 f6 45 00 20       	test   BYTE PTR [r13+0x0],0x20
  41a723:	75 b3                	jne    41a6d8 <printf_core+0xf28>
  41a725:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  41a72a:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
--
  41a732:	4c 89 e7             	mov    rdi,r12
  41a735:	48 01 c8             	add    rax,rcx
  41a738:	ff d0                	call   rax
  41a73a:	eb 9c                	jmp    41a6d8 <printf_core+0xf28>
			wc[0] = arg.i;
  41a73c:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
--
			ws = arg.p;
  41a76d:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
  41a772:	e9 b3 fd ff ff       	jmp    41a52a <printf_core+0xd7a>
			if (1) a = strerror(errno); else
  41a777:	4c 8b 7c 24 18       	mov    r15,QWORD PTR [rsp+0x18]
--
  41a78b:	44 89 5c 24 08       	mov    DWORD PTR [rsp+0x8],r11d
  41a790:	4c 01 f8             	add    rax,r15
  41a793:	ff d0                	call   rax
  41a795:	8b 38                	mov    edi,DWORD PTR [rax]
  41a797:	48 b8 60 de fb ff ff 	movabs rax,0xfffffffffffbde60
  41a79e:	ff ff ff 
  41a7a1:	4c 01 f8             	add    rax,r15
  41a7a4:	ff d0                	call   rax
  41a7a6:	44 8b 5c 24 08       	mov    r11d,DWORD PTR [rsp+0x8]
  41a7ab:	44 8b 4c 24 38       	mov    r9d,DWORD PTR [rsp+0x38]
  41a7b0:	49 89 c0             	mov    r8,rax
  41a7b3:	e9 fb fc ff ff       	jmp    41a4b3 <printf_core+0xd03>
			switch(ps) {
  41a7b8:	41 83 ff 07          	cmp    r15d,0x7
  41a7bc:	0f 87 e5 f0 ff ff    	ja     4198a7 <printf_core+0xf7>
  41a7c2:	48 8d 15 8f 4c 00 00 	lea    rdx,[rip+0x4c8f]        # 41f458 <CSWTCH.186+0x9e8>
  41a7c9:	48 03 14 c2          	add    rdx,QWORD PTR [rdx+rax*8]
  41a7cd:	3e ff e2             	notrack jmp rdx
			case JPRE: *(uintmax_t *)arg.p = cnt; break;
  41a7d0:	48 63 44 24 14       	movsxd rax,DWORD PTR [rsp+0x14]
--
  41a7dc:	00 
  41a7dd:	48 89 02             	mov    QWORD PTR [rdx],rax
  41a7e0:	e9 cd f0 ff ff       	jmp    4198b2 <printf_core+0x102>
		switch(t) {
  41a7e5:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
--
  41a801:	48 01 d0             	add    rax,rdx
  41a804:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  41a809:	e9 66 fa ff ff       	jmp    41a274 <printf_core+0xac4>
			case BARE: *(int *)arg.p = cnt; break;
  41a80e:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
--
  41a816:	8b 54 24 14          	mov    edx,DWORD PTR [rsp+0x14]
  41a81a:	89 10                	mov    DWORD PTR [rax],edx
  41a81c:	e9 91 f0 ff ff       	jmp    4198b2 <printf_core+0x102>
			case HPRE: *(unsigned short *)arg.p = cnt; break;
  41a821:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
--
  41a829:	0f b7 54 24 14       	movzx  edx,WORD PTR [rsp+0x14]
  41a82e:	66 89 10             	mov    WORD PTR [rax],dx
  41a831:	e9 7c f0 ff ff       	jmp    4198b2 <printf_core+0x102>
			case HHPRE: *(unsigned char *)arg.p = cnt; break;
  41a836:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
--
  41a83e:	0f b6 54 24 14       	movzx  edx,BYTE PTR [rsp+0x14]
  41a843:	88 10                	mov    BYTE PTR [rax],dl
  41a845:	e9 68 f0 ff ff       	jmp    4198b2 <printf_core+0x102>
  41a84a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
--
  41a860:	be 00 01 00 00       	mov    esi,0x100
  41a865:	48 01 c8             	add    rax,rcx
  41a868:	ff d0                	call   rax
  41a86a:	41 8b 55 00          	mov    edx,DWORD PTR [r13+0x0]
  41a86e:	89 d0                	mov    eax,edx
  41a870:	83 e0 20             	and    eax,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41a873:	41 81 ff ff 00 00 00 	cmp    r15d,0xff
  41a87a:	0f 8e e9 00 00 00    	jle    41a969 <printf_core+0x11b9>
  41a880:	41 81 ef 00 01 00 00 	sub    r15d,0x100
  41a887:	e9 1f f8 ff ff       	jmp    41a0ab <printf_core+0x8fb>
  41a88c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
--
  41a8a5:	be 00 01 00 00       	mov    esi,0x100
  41a8aa:	48 01 c8             	add    rax,rcx
  41a8ad:	ff d0                	call   rax
  41a8af:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
	for (; l >= sizeof pad; l -= sizeof pad)
--
  41a8bd:	83 e2 20             	and    edx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41a8c0:	41 81 ff ff 00 00 00 	cmp    r15d,0xff
  41a8c7:	0f 8e 51 f7 ff ff    	jle    41a01e <printf_core+0x86e>
  41a8cd:	41 81 ef 00 01 00 00 	sub    r15d,0x100
  41a8d4:	e9 0b f7 ff ff       	jmp    419fe4 <printf_core+0x834>
  41a8d9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
--
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a8f8:	48 01 c8             	add    rax,rcx
  41a8fb:	ff d0                	call   rax
  41a8fd:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
  41a901:	89 c2                	mov    edx,eax
  41a903:	83 e2 20             	and    edx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41a906:	81 fd ff 00 00 00    	cmp    ebp,0xff
  41a90c:	0f 8e 98 f8 ff ff    	jle    41a1aa <printf_core+0x9fa>
  41a912:	81 ed 00 01 00 00    	sub    ebp,0x100
  41a918:	e9 53 f8 ff ff       	jmp    41a170 <printf_core+0x9c0>
  41a91d:	0f 1f 00             	nop    DWORD PTR [rax]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
--
  41a935:	be 00 01 00 00       	mov    esi,0x100
  41a93a:	48 01 c8             	add    rax,rcx
  41a93d:	ff d0                	call   rax
  41a93f:	41 8b 55 00          	mov    edx,DWORD PTR [r13+0x0]
	for (; l >= sizeof pad; l -= sizeof pad)
--
  41a94d:	83 e0 20             	and    eax,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41a950:	41 81 ff ff 00 00 00 	cmp    r15d,0xff
  41a957:	0f 8e d2 f5 ff ff    	jle    419f2f <printf_core+0x77f>
  41a95d:	41 81 ef 00 01 00 00 	sub    r15d,0x100
  41a964:	e9 88 f5 ff ff       	jmp    419ef1 <printf_core+0x741>
  41a969:	49 89 e8             	mov    r8,rbp
  41a96c:	44 89 fd             	mov    ebp,r15d
  41a96f:	e9 7c f7 ff ff       	jmp    41a0f0 <printf_core+0x940>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a974:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
  41a978:	83 e0 20             	and    eax,0x20
  41a97b:	85 c0                	test   eax,eax
  41a97d:	0f 85 e1 f5 ff ff    	jne    419f64 <printf_core+0x7b4>
  41a983:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  41a988:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
--
  41a99a:	48 8b 7c 24 70       	mov    rdi,QWORD PTR [rsp+0x70]
  41a99f:	48 01 c8             	add    rax,rcx
  41a9a2:	ff d0                	call   rax
  41a9a4:	4c 8b 44 24 68       	mov    r8,QWORD PTR [rsp+0x68]
  41a9a9:	e9 b6 f5 ff ff       	jmp    419f64 <printf_core+0x7b4>
  41a9ae:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
  41a9b2:	83 e0 20             	and    eax,0x20
  41a9b5:	85 c0                	test   eax,eax
  41a9b7:	0f 85 3b f7 ff ff    	jne    41a0f8 <printf_core+0x948>
  41a9bd:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  41a9c2:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
--
  41a9cd:	48 8b 74 24 50       	mov    rsi,QWORD PTR [rsp+0x50]
  41a9d2:	48 01 c8             	add    rax,rcx
  41a9d5:	ff d0                	call   rax
  41a9d7:	e9 1c f7 ff ff       	jmp    41a0f8 <printf_core+0x948>
  41a9dc:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  41a9e1:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
--
  41a9f6:	48 01 c8             	add    rax,rcx
  41a9f9:	44 89 5c 24 38       	mov    DWORD PTR [rsp+0x38],r11d
  41a9fe:	ff d0                	call   rax
  41aa00:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
	for (; l >= sizeof pad; l -= sizeof pad)
--
  41aa13:	83 e2 20             	and    edx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41aa16:	41 81 ff ff 00 00 00 	cmp    r15d,0xff
  41aa1d:	0f 8e 75 fc ff ff    	jle    41a698 <printf_core+0xee8>
  41aa23:	41 81 ef 00 01 00 00 	sub    r15d,0x100
  41aa2a:	e9 2c fc ff ff       	jmp    41a65b <printf_core+0xeab>
  41aa2f:	44 8b 5c 24 5c       	mov    r11d,DWORD PTR [rsp+0x5c]
  41aa34:	48 8b 5c 24 60       	mov    rbx,QWORD PTR [rsp+0x60]
--
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41aa4a:	41 81 e4 00 20 01 00 	and    r12d,0x12000
  41aa51:	0f 85 85 00 00 00    	jne    41aadc <printf_core+0x132c>
  41aa57:	80 7c 24 38 00       	cmp    BYTE PTR [rsp+0x38],0x0
  41aa5c:	75 7e                	jne    41aadc <printf_core+0x132c>
	l = w - l;
  41aa5e:	44 89 cd             	mov    ebp,r9d
--
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41aa6a:	4c 8b 7c 24 18       	mov    r15,QWORD PTR [rsp+0x18]
  41aa6f:	39 c5                	cmp    ebp,eax
  41aa71:	44 89 5c 24 50       	mov    DWORD PTR [rsp+0x50],r11d
  41aa76:	be 20 00 00 00       	mov    esi,0x20
--
  41aa9b:	ff ff ff 
  41aa9e:	4c 01 f8             	add    rax,r15
  41aaa1:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  41aaa3:	81 fd ff 00 00 00    	cmp    ebp,0xff
  41aaa9:	44 8b 4c 24 38       	mov    r9d,DWORD PTR [rsp+0x38]
  41aaae:	44 8b 5c 24 50       	mov    r11d,DWORD PTR [rsp+0x50]
--
  41aabd:	45 89 df             	mov    r15d,r11d
  41aac0:	83 e0 20             	and    eax,0x20
  41aac3:	74 2c                	je     41aaf1 <printf_core+0x1341>
	for (; l >= sizeof pad; l -= sizeof pad)
  41aac5:	41 8d 8c 24 00 ff ff 	lea    ecx,[r12-0x100]
  41aacc:	ff 
  41aacd:	45 89 fb             	mov    r11d,r15d
  41aad0:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  41aad6:	0f 87 0a e9 ff ff    	ja     4193e6 <printf_core.cold+0xbb>
			l = w>p ? w : p;
  41aadc:	8b 44 24 08          	mov    eax,DWORD PTR [rsp+0x8]
  41aae0:	44 39 c8             	cmp    eax,r9d
  41aae3:	44 0f 4d c8          	cmovge r9d,eax
  41aae7:	44 89 4c 24 08       	mov    DWORD PTR [rsp+0x8],r9d
			continue;
  41aaec:	e9 b6 ed ff ff       	jmp    4198a7 <printf_core+0xf7>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41aaf1:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
--
  41ab15:	44 89 e5             	mov    ebp,r12d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41ab18:	ff d0                	call   rax
  41ab1a:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
	for (; l >= sizeof pad; l -= sizeof pad)
--
  41ab25:	83 e2 20             	and    edx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41ab28:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  41ab2f:	77 8f                	ja     41aac0 <printf_core+0x1310>
  41ab31:	45 89 fb             	mov    r11d,r15d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41ab34:	85 d2                	test   edx,edx
  41ab36:	75 a4                	jne    41aadc <printf_core+0x132c>
  41ab38:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  41ab3d:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
--
  41ab50:	44 89 5c 24 38       	mov    DWORD PTR [rsp+0x38],r11d
  41ab55:	48 01 c8             	add    rax,rcx
  41ab58:	ff d0                	call   rax
  41ab5a:	44 8b 4c 24 50       	mov    r9d,DWORD PTR [rsp+0x50]
  41ab5f:	44 8b 5c 24 38       	mov    r11d,DWORD PTR [rsp+0x38]
  41ab64:	e9 73 ff ff ff       	jmp    41aadc <printf_core+0x132c>
  41ab69:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  41ab6e:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
--
  41ab7e:	4c 89 f7             	mov    rdi,r14
  41ab81:	48 01 c8             	add    rax,rcx
  41ab84:	ff d0                	call   rax
  41ab86:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
  41ab8a:	4c 8b 44 24 60       	mov    r8,QWORD PTR [rsp+0x60]
  41ab8f:	83 e0 20             	and    eax,0x20
  41ab92:	e9 1e fe ff ff       	jmp    41a9b5 <printf_core+0x1205>
  41ab97:	48 c7 44 24 50 00 00 	mov    QWORD PTR [rsp+0x50],0x0
  41ab9e:	00 00 
--
  41aba4:	4d 89 f8             	mov    r8,r15
  41aba7:	89 44 24 5c          	mov    DWORD PTR [rsp+0x5c],eax
  41abab:	e9 60 f8 ff ff       	jmp    41a410 <printf_core+0xc60>
		if (p < z-a) p = z-a;
  41abb0:	48 b8 75 1e fc ff ff 	movabs rax,0xfffffffffffc1e75
--
  41abbf:	48 01 d0             	add    rax,rdx
  41abc2:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  41abc7:	e9 7f f2 ff ff       	jmp    419e4b <printf_core+0x69b>
			z = a + strnlen(a, p<0 ? INT_MAX : p);
  41abcc:	4c 8b 7c 24 18       	mov    r15,QWORD PTR [rsp+0x18]
--
  41abed:	4c 89 44 24 08       	mov    QWORD PTR [rsp+0x8],r8
  41abf2:	4c 01 f8             	add    rax,r15
  41abf5:	ff d0                	call   rax
  41abf7:	4c 8b 44 24 08       	mov    r8,QWORD PTR [rsp+0x8]
			if (p<0 && *z) goto overflow;
--
  41ac09:	49 8d 04 00          	lea    rax,[r8+rax*1]
			if (p<0 && *z) goto overflow;
  41ac0d:	80 38 00             	cmp    BYTE PTR [rax],0x0
  41ac10:	0f 84 e4 f8 ff ff    	je     41a4fa <printf_core+0xd4a>
  41ac16:	e9 ce ef ff ff       	jmp    419be9 <printf_core+0x439>
  41ac1b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41ac20:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
  41ac24:	83 e0 20             	and    eax,0x20
  41ac27:	e9 c4 f4 ff ff       	jmp    41a0f0 <printf_core+0x940>
			if (l<0) return -1;
  41ac2c:	c7 44 24 14 ff ff ff 	mov    DWORD PTR [rsp+0x14],0xffffffff
  41ac33:	ff 
  41ac34:	e9 77 ee ff ff       	jmp    419ab0 <printf_core+0x300>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41ac39:	41 8b 55 00          	mov    edx,DWORD PTR [r13+0x0]
  41ac3d:	83 e2 20             	and    edx,0x20
  41ac40:	e9 d9 f3 ff ff       	jmp    41a01e <printf_core+0x86e>
  41ac45:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
  41ac49:	83 e0 20             	and    eax,0x20
  41ac4c:	e9 de f2 ff ff       	jmp    419f2f <printf_core+0x77f>
  41ac51:	41 8b 55 00          	mov    edx,DWORD PTR [r13+0x0]
  41ac55:	83 e2 20             	and    edx,0x20
  41ac58:	e9 4d f5 ff ff       	jmp    41a1aa <printf_core+0x9fa>
		prefix = "-+   0X0x";
  41ac5d:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
--
  41ac7f:	48 01 d0             	add    rax,rdx
  41ac82:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  41ac87:	e9 f1 f5 ff ff       	jmp    41a27d <printf_core+0xacd>
				prefix++;
  41ac8c:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
--
  41aca3:	48 01 d0             	add    rax,rdx
  41aca6:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  41acab:	e9 c4 f5 ff ff       	jmp    41a274 <printf_core+0xac4>
			else return 0;
  41acb0:	c7 44 24 14 00 00 00 	mov    DWORD PTR [rsp+0x14],0x0
  41acb7:	00 
  41acb8:	e9 f3 ed ff ff       	jmp    419ab0 <printf_core+0x300>
			a = arg.p ? arg.p : "(null)";
  41acbd:	48 b8 7f 1e fc ff ff 	movabs rax,0xfffffffffffc1e7f
--
  41acc7:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  41accc:	4c 8d 04 02          	lea    r8,[rdx+rax*1]
  41acd0:	e9 de f7 ff ff       	jmp    41a4b3 <printf_core+0xd03>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41acd5:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
--
  41aced:	44 89 5c 24 38       	mov    DWORD PTR [rsp+0x38],r11d
  41acf2:	48 01 c8             	add    rax,rcx
  41acf5:	ff d0                	call   rax
  41acf7:	44 8b 4c 24 5c       	mov    r9d,DWORD PTR [rsp+0x5c]
  41acfc:	44 8b 5c 24 38       	mov    r11d,DWORD PTR [rsp+0x38]
  41ad01:	e9 9a f9 ff ff       	jmp    41a6a0 <printf_core+0xef0>
		prefix = "-+   0X0x";
  41ad06:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
--
  41ad25:	48 01 d0             	add    rax,rdx
  41ad28:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  41ad2d:	e9 93 f5 ff ff       	jmp    41a2c5 <printf_core+0xb15>
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  41ad32:	4c 8d bc 24 cb 00 00 	lea    r15,[rsp+0xcb]
  41ad39:	00 
  41ad3a:	4d 89 f8             	mov    r8,r15
  41ad3d:	e9 83 f5 ff ff       	jmp    41a2c5 <printf_core+0xb15>
	for (; i<=NL_ARGMAX && !nl_type[i]; i++);
  41ad42:	49 8d 50 01          	lea    rdx,[r8+0x1]
  41ad46:	49 83 f8 09          	cmp    r8,0x9
  41ad4a:	0f 84 a1 f0 ff ff    	je     419df1 <printf_core+0x641>
  41ad50:	48 8b 7c 24 40       	mov    rdi,QWORD PTR [rsp+0x40]
  41ad55:	48 8d 04 95 00 00 00 	lea    rax,[rdx*4+0x0]
--
  41ad5d:	8b 2c 97             	mov    ebp,DWORD PTR [rdi+rdx*4]
  41ad60:	85 ed                	test   ebp,ebp
  41ad62:	0f 85 26 ed ff ff    	jne    419a8e <printf_core+0x2de>
  41ad68:	49 83 f8 08          	cmp    r8,0x8
  41ad6c:	0f 84 7f f0 ff ff    	je     419df1 <printf_core+0x641>
  41ad72:	8b 5c 07 04          	mov    ebx,DWORD PTR [rdi+rax*1+0x4]
  41ad76:	85 db                	test   ebx,ebx
  41ad78:	0f 85 10 ed ff ff    	jne    419a8e <printf_core+0x2de>
  41ad7e:	49 83 f8 07          	cmp    r8,0x7
  41ad82:	0f 84 69 f0 ff ff    	je     419df1 <printf_core+0x641>
  41ad88:	44 8b 5c 07 08       	mov    r11d,DWORD PTR [rdi+rax*1+0x8]
  41ad8d:	45 85 db             	test   r11d,r11d
  41ad90:	0f 85 f8 ec ff ff    	jne    419a8e <printf_core+0x2de>
  41ad96:	49 83 f8 06          	cmp    r8,0x6
  41ad9a:	0f 84 51 f0 ff ff    	je     419df1 <printf_core+0x641>
  41ada0:	44 8b 54 07 0c       	mov    r10d,DWORD PTR [rdi+rax*1+0xc]
  41ada5:	45 85 d2             	test   r10d,r10d
  41ada8:	0f 85 e0 ec ff ff    	jne    419a8e <printf_core+0x2de>
  41adae:	49 83 f8 05          	cmp    r8,0x5
  41adb2:	0f 84 39 f0 ff ff    	je     419df1 <printf_core+0x641>
  41adb8:	44 8b 4c 07 10       	mov    r9d,DWORD PTR [rdi+rax*1+0x10]
  41adbd:	45 85 c9             	test   r9d,r9d
  41adc0:	0f 85 c8 ec ff ff    	jne    419a8e <printf_core+0x2de>
  41adc6:	49 83 f8 04          	cmp    r8,0x4
  41adca:	0f 84 21 f0 ff ff    	je     419df1 <printf_core+0x641>
  41add0:	8b 74 07 14          	mov    esi,DWORD PTR [rdi+rax*1+0x14]
  41add4:	85 f6                	test   esi,esi
  41add6:	0f 85 b2 ec ff ff    	jne    419a8e <printf_core+0x2de>
  41addc:	49 8d 50 07          	lea    rdx,[r8+0x7]
  41ade0:	49 83 f8 03          	cmp    r8,0x3
  41ade4:	0f 84 07 f0 ff ff    	je     419df1 <printf_core+0x641>
  41adea:	8b 4c 07 18          	mov    ecx,DWORD PTR [rdi+rax*1+0x18]
  41adee:	85 c9                	test   ecx,ecx
  41adf0:	0f 85 98 ec ff ff    	jne    419a8e <printf_core+0x2de>
  41adf6:	48 83 fa 08          	cmp    rdx,0x8
  41adfa:	0f 85 f1 ef ff ff    	jne    419df1 <printf_core+0x641>
  41ae00:	8b 44 07 1c          	mov    eax,DWORD PTR [rdi+rax*1+0x1c]
  41ae04:	85 c0                	test   eax,eax
  41ae06:	0f 84 e5 ef ff ff    	je     419df1 <printf_core+0x641>
  41ae0c:	e9 7d ec ff ff       	jmp    419a8e <printf_core+0x2de>
  41ae11:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
				prefix+=2;
--
  41ae2f:	48 01 d0             	add    rax,rdx
  41ae32:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  41ae37:	e9 38 f4 ff ff       	jmp    41a274 <printf_core+0xac4>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41ae3c:	41 8b 55 00          	mov    edx,DWORD PTR [r13+0x0]
  41ae40:	83 e2 20             	and    edx,0x20
  41ae43:	e9 50 f8 ff ff       	jmp    41a698 <printf_core+0xee8>
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41ae48:	45 85 c9             	test   r9d,r9d
--
  41ae4e:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  41ae52:	41 f7 c4 00 20 01 00 	test   r12d,0x12000
  41ae59:	0f 85 e4 fb ff ff    	jne    41aa43 <printf_core+0x1293>
			for (i=l=0; i<p && *ws && (l=wctomb(mb, *ws++))>=0 && l<=p-i; i+=l);
  41ae5f:	31 ed                	xor    ebp,ebp
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41ae61:	84 c0                	test   al,al
  41ae63:	0f 84 84 f7 ff ff    	je     41a5ed <printf_core+0xe3d>
  41ae69:	e9 d5 fb ff ff       	jmp    41aa43 <printf_core+0x1293>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41ae6e:	41 8b 55 00          	mov    edx,DWORD PTR [r13+0x0]
  41ae72:	83 e2 20             	and    edx,0x20
  41ae75:	e9 ba fc ff ff       	jmp    41ab34 <printf_core+0x1384>
  41ae7a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

--
  41af03:	48 01 d8             	add    rax,rbx
  41af06:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  41af0b:	ff d0                	call   rax
  41af0d:	85 c0                	test   eax,eax
  41af0f:	0f 88 8a 01 00 00    	js     41b09f <vfprintf+0x21f>
--
  41af43:	4c 89 44 24 10       	mov    QWORD PTR [rsp+0x10],r8
  41af48:	48 01 d8             	add    rax,rbx
  41af4b:	ff d0                	call   rax
  41af4d:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  41af52:	4c 8b 44 24 10       	mov    r8,QWORD PTR [rsp+0x10]
--
	if (f->mode < 1) f->flags &= ~F_ERR;
  41af6d:	85 d2                	test   edx,edx
  41af6f:	7f 06                	jg     41af77 <vfprintf+0xf7>
  41af71:	83 e0 df             	and    eax,0xffffffdf
  41af74:	89 45 00             	mov    DWORD PTR [rbp+0x0],eax
	if (!f->buf_size) {
  41af77:	48 83 7d 60 00       	cmp    QWORD PTR [rbp+0x60],0x0
  41af7c:	0f 84 9e 00 00 00    	je     41b020 <vfprintf+0x1a0>
		saved_buf = f->buf;
		f->buf = internal_buf;
--
  41af82:	4c 8b 6d 20          	mov    r13,QWORD PTR [rbp+0x20]
  41af86:	4d 85 ed             	test   r13,r13
  41af89:	0f 84 1b 01 00 00    	je     41b0aa <vfprintf+0x22a>
	unsigned char internal_buf[80], *saved_buf = 0;
  41af8f:	45 31 ed             	xor    r13d,r13d
--
  41af9d:	48 89 ef             	mov    rdi,rbp
  41afa0:	48 01 d8             	add    rax,rbx
  41afa3:	ff d0                	call   rax
  41afa5:	41 89 c4             	mov    r12d,eax
	if (saved_buf) {
  41afa8:	4d 85 ed             	test   r13,r13
  41afab:	74 34                	je     41afe1 <vfprintf+0x161>
		f->write(f, 0, 0);
  41afad:	31 d2                	xor    edx,edx
  41afaf:	31 f6                	xor    esi,esi
  41afb1:	48 89 ef             	mov    rdi,rbp
  41afb4:	ff 55 48             	call   QWORD PTR [rbp+0x48]
		if (!f->wpos) ret = -1;
  41afb7:	48 83 7d 28 00       	cmp    QWORD PTR [rbp+0x28],0x0
		f->buf = saved_buf;
  41afbc:	4c 89 6d 58          	mov    QWORD PTR [rbp+0x58],r13
--
	FUNLOCK(f);
  41afff:	85 c0                	test   eax,eax
  41b001:	0f 85 81 00 00 00    	jne    41b088 <vfprintf+0x208>
	va_end(ap2);
	return ret;
--
  41b064:	0f 11 45 20          	movups XMMWORD PTR [rbp+0x20],xmm0
	if (!f->wend && __towrite(f)) ret = -1;
  41b068:	ff d0                	call   rax
  41b06a:	85 c0                	test   eax,eax
  41b06c:	0f 85 36 ff ff ff    	jne    41afa8 <vfprintf+0x128>
  41b072:	4c 8b 44 24 18       	mov    r8,QWORD PTR [rsp+0x18]
  41b077:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  41b07c:	e9 11 ff ff ff       	jmp    41af92 <vfprintf+0x112>
  41b081:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	FUNLOCK(f);
--
  41b092:	48 89 ef             	mov    rdi,rbp
  41b095:	48 01 d8             	add    rax,rbx
  41b098:	ff d0                	call   rax
	return ret;
  41b09a:	e9 68 ff ff ff       	jmp    41b007 <vfprintf+0x187>
		return -1;
  41b09f:	41 bc ff ff ff ff    	mov    r12d,0xffffffff
  41b0a5:	e9 5d ff ff ff       	jmp    41b007 <vfprintf+0x187>
  41b0aa:	48 89 4c 24 28       	mov    QWORD PTR [rsp+0x28],rcx
	if (!f->wend && __towrite(f)) ret = -1;
--
  41b0c0:	4c 89 44 24 18       	mov    QWORD PTR [rsp+0x18],r8
  41b0c5:	48 01 d8             	add    rax,rbx
  41b0c8:	ff d0                	call   rax
  41b0ca:	85 c0                	test   eax,eax
  41b0cc:	0f 85 0f ff ff ff    	jne    41afe1 <vfprintf+0x161>
  41b0d2:	eb 9e                	jmp    41b072 <vfprintf+0x1f2>
  41b0d4:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41b0db:	00 00 00 
--
	for (; ((uintptr_t)s & ALIGN) && n && *s != c; s++, n--);
  41b0eb:	a8 07                	test   al,0x7
  41b0ed:	75 21                	jne    41b110 <memchr+0x30>
  41b0ef:	eb 2f                	jmp    41b120 <memchr+0x40>
  41b0f1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  41b0f8:	0f b6 08             	movzx  ecx,BYTE PTR [rax]
  41b0fb:	44 39 d1             	cmp    ecx,r10d
  41b0fe:	0f 84 7f 00 00 00    	je     41b183 <memchr+0xa3>
  41b104:	48 83 c0 01          	add    rax,0x1
  41b108:	48 83 ea 01          	sub    rdx,0x1
  41b10c:	a8 07                	test   al,0x7
  41b10e:	74 10                	je     41b120 <memchr+0x40>
  41b110:	48 85 d2             	test   rdx,rdx
  41b113:	75 e3                	jne    41b0f8 <memchr+0x18>
		for (w = (const void *)s; n>=SS && !HASZERO(*w^k); w++, n-=SS);
		s = (const void *)w;
--
	if (n && *s != c) {
  41b123:	48 85 d2             	test   rdx,rdx
  41b126:	74 f0                	je     41b118 <memchr+0x38>
  41b128:	0f b6 08             	movzx  ecx,BYTE PTR [rax]
  41b12b:	44 39 d1             	cmp    ecx,r10d
  41b12e:	74 53                	je     41b183 <memchr+0xa3>
		size_t k = ONES * c;
  41b130:	48 b9 01 01 01 01 01 	movabs rcx,0x101010101010101
--
  41b151:	48 0f af f9          	imul   rdi,rcx
		for (w = (const void *)s; n>=SS && !HASZERO(*w^k); w++, n-=SS);
  41b155:	48 83 fa 07          	cmp    rdx,0x7
  41b159:	77 13                	ja     41b16e <memchr+0x8e>
  41b15b:	eb 26                	jmp    41b183 <memchr+0xa3>
  41b15d:	0f 1f 00             	nop    DWORD PTR [rax]
  41b160:	48 83 ea 08          	sub    rdx,0x8
  41b164:	48 83 c0 08          	add    rax,0x8
  41b168:	48 83 fa 07          	cmp    rdx,0x7
  41b16c:	76 3d                	jbe    41b1ab <memchr+0xcb>
  41b16e:	48 8b 08             	mov    rcx,QWORD PTR [rax]
--
  41b17b:	48 21 f1             	and    rcx,rsi
  41b17e:	4c 85 c1             	test   rcx,r8
  41b181:	74 dd                	je     41b160 <memchr+0x80>
{
  41b183:	49 89 c0             	mov    r8,rax
--
	for (; n && *s != c; s++, n--);
  41b190:	41 0f b6 00          	movzx  eax,BYTE PTR [r8]
  41b194:	44 39 d0             	cmp    eax,r10d
  41b197:	0f 84 7b ff ff ff    	je     41b118 <memchr+0x38>
  41b19d:	49 83 c0 01          	add    r8,0x1
  41b1a1:	49 39 d0             	cmp    r8,rdx
  41b1a4:	75 ea                	jne    41b190 <memchr+0xb0>
  41b1a6:	e9 6a ff ff ff       	jmp    41b115 <memchr+0x35>
	return n ? (void *)s : 0;
  41b1ab:	45 31 c0             	xor    r8d,r8d
	for (; n && *s != c; s++, n--);
  41b1ae:	48 85 d2             	test   rdx,rdx
  41b1b1:	0f 84 61 ff ff ff    	je     41b118 <memchr+0x38>
  41b1b7:	eb ca                	jmp    41b183 <memchr+0xa3>
  41b1b9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

--
  41b1e4:	49 8d 0c 00          	lea    rcx,[r8+rax*1]
  41b1e8:	b8 54 00 00 00       	mov    eax,0x54
  41b1ed:	eb 0f                	jmp    41b1fe <__strerror_l+0x3e>
  41b1ef:	90                   	nop
  41b1f0:	0f b6 01             	movzx  eax,BYTE PTR [rcx]
--
  41b1f7:	83 c2 01             	add    edx,0x1
  41b1fa:	84 c0                	test   al,al
  41b1fc:	74 16                	je     41b214 <__strerror_l+0x54>
  41b1fe:	39 f8                	cmp    eax,edi
  41b200:	75 ee                	jne    41b1f0 <__strerror_l+0x30>
	for (s=errmsg; i; s++, i--) for (; *s; s++);
  41b202:	48 b8 90 23 fc ff ff 	movabs rax,0xfffffffffffc2390
--
  41b20c:	49 8d 3c 00          	lea    rdi,[r8+rax*1]
  41b210:	85 d2                	test   edx,edx
  41b212:	74 44                	je     41b258 <__strerror_l+0x98>
	for (i=0; errid[i] && errid[i] != e; i++);
  41b214:	48 b8 90 23 fc ff ff 	movabs rax,0xfffffffffffc2390
--
	for (s=errmsg; i; s++, i--) for (; *s; s++);
  41b230:	84 c9                	test   cl,cl
  41b232:	74 0d                	je     41b241 <__strerror_l+0x81>
  41b234:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  41b238:	48 83 c0 01          	add    rax,0x1
  41b23c:	80 38 00             	cmp    BYTE PTR [rax],0x0
  41b23f:	75 f7                	jne    41b238 <__strerror_l+0x78>
  41b241:	48 8d 78 01          	lea    rdi,[rax+0x1]
  41b245:	83 ea 01             	sub    edx,0x1
  41b248:	74 0e                	je     41b258 <__strerror_l+0x98>
  41b24a:	0f b6 48 01          	movzx  ecx,BYTE PTR [rax+0x1]
  41b24e:	48 89 f8             	mov    rax,rdi
  41b251:	eb dd                	jmp    41b230 <__strerror_l+0x70>
  41b253:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	return (char *)LCTRANS(s, LC_MESSAGES, loc);
--
  41b262:	48 8b 76 28          	mov    rsi,QWORD PTR [rsi+0x28]
  41b266:	4c 01 c0             	add    rax,r8
  41b269:	ff e0                	jmp    rax
  41b26b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

--
  41b2a7:	41 5f                	pop    r15
	return __strerror_l(e, CURRENT_LOCALE);
  41b2a9:	ff e0                	jmp    rax
  41b2ab:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

--
  41b2cf:	4c 01 d8             	add    rax,r11
  41b2d2:	48 01 d0             	add    rax,rdx
  41b2d5:	ff e0                	jmp    rax
  41b2d7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41b2de:	00 00 
--
  41b313:	ff ff ff 
  41b316:	48 01 d0             	add    rax,rdx
  41b319:	ff e0                	jmp    rax
  41b31b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

--
	if (!e && !msb)
  41b341:	09 c8                	or     eax,ecx
  41b343:	74 2b                	je     41b370 <__fpclassifyl+0x50>
		 * the version with it clear. */
		if (__BYTE_ORDER == __LITTLE_ENDIAN && !msb)
--
  41b345:	8d 04 8d 00 00 00 00 	lea    eax,[rcx*4+0x0]
	if (e == 0x7fff) {
  41b34c:	66 81 fe ff 7f       	cmp    si,0x7fff
  41b351:	74 05                	je     41b358 <__fpclassifyl+0x38>
		return FP_NAN;
	return FP_NORMAL;
--
		if (__BYTE_ORDER == __LITTLE_ENDIAN && !msb)
  41b35a:	48 85 c9             	test   rcx,rcx
  41b35d:	74 f4                	je     41b353 <__fpclassifyl+0x33>
		return u.i.m << 1 ? FP_NAN : FP_INFINITE;
  41b35f:	31 c0                	xor    eax,eax
--
  41b36f:	00 
		return u.i.m ? FP_SUBNORMAL : FP_ZERO;
  41b370:	48 83 fa 01          	cmp    rdx,0x1
  41b374:	b8 02 00 00 00       	mov    eax,0x2
  41b379:	83 d8 ff             	sbb    eax,0xffffffff
--
	if (!ee) {
  41b3cd:	66 81 e1 ff 7f       	and    cx,0x7fff
  41b3d2:	74 3c                	je     41b410 <frexpl+0x70>
  41b3d4:	dd d8                	fstp   st(0)
			x = frexpl(x*0x1p120, e);
--
  41b3dd:	db 3c 24             	fstp   TBYTE PTR [rsp]
	} else if (ee == 0x7fff) {
  41b3e0:	66 81 f9 ff 7f       	cmp    cx,0x7fff
  41b3e5:	74 1c                	je     41b403 <frexpl+0x63>
	}

--
  41b416:	dd d8                	fstp   st(0)
  41b418:	7a 1e                	jp     41b438 <frexpl+0x98>
  41b41a:	75 1c                	jne    41b438 <frexpl+0x98>
		} else *e = 0;
  41b41c:	db 6c 24 50          	fld    TBYTE PTR [rsp+0x50]
--
	if (!ee) {
  41b45b:	66 81 e1 ff 7f       	and    cx,0x7fff
  41b460:	74 36                	je     41b498 <frexpl+0xf8>
  41b462:	dd d8                	fstp   st(0)
	int ee = u.i.se & 0x7fff;
  41b464:	0f b7 d1             	movzx  edx,cx
	} else if (ee == 0x7fff) {
  41b467:	66 81 f9 ff 7f       	cmp    cx,0x7fff
  41b46c:	74 72                	je     41b4e0 <frexpl+0x140>
	u.i.se &= 0x8000;
  41b46e:	66 25 00 80          	and    ax,0x8000
--
  41b4a0:	7a 07                	jp     41b4a9 <frexpl+0x109>
  41b4a2:	b8 88 ff ff ff       	mov    eax,0xffffff88
  41b4a7:	74 df                	je     41b488 <frexpl+0xe8>
			x = frexpl(x*0x1p120, e);
  41b4a9:	db 2c 24             	fld    TBYTE PTR [rsp]
--
  41b4c2:	48 01 d0             	add    rax,rdx
  41b4c5:	db 3c 24             	fstp   TBYTE PTR [rsp]
  41b4c8:	ff d0                	call   rax
			*e -= 120;
  41b4ca:	48 8b 7c 24 28       	mov    rdi,QWORD PTR [rsp+0x28]
--
  41b4d7:	2d f0 00 00 00       	sub    eax,0xf0
  41b4dc:	89 07                	mov    DWORD PTR [rdi],eax
  41b4de:	eb aa                	jmp    41b48a <frexpl+0xea>
  41b4e0:	8b 07                	mov    eax,DWORD PTR [rdi]
  41b4e2:	83 e8 78             	sub    eax,0x78
  41b4e5:	89 07                	mov    DWORD PTR [rdi],eax
  41b4e7:	eb a1                	jmp    41b48a <frexpl+0xea>
  41b4e9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

--
	if (!s) return 0;
  41b50c:	48 85 ff             	test   rdi,rdi
  41b50f:	74 11                	je     41b522 <wctomb+0x32>
	return wcrtomb(s, wc, 0);
  41b511:	48 b8 70 e6 fb ff ff 	movabs rax,0xfffffffffffbe670
--
  41b51b:	31 d2                	xor    edx,edx
  41b51d:	4c 01 f8             	add    rax,r15
  41b520:	ff d0                	call   rax
}
  41b522:	41 5f                	pop    r15
--
	if ((owner & ~MAYBE_WAITERS) == tid)
  41b56b:	25 ff ff ff bf       	and    eax,0xbfffffff
  41b570:	39 d8                	cmp    eax,ebx
  41b572:	0f 84 c6 00 00 00    	je     41b63e <__lockfile+0x10e>
	owner = a_cas(&f->lock, 0, tid);
  41b578:	4c 8d a7 8c 00 00 00 	lea    r12,[rdi+0x8c]
	__asm__ __volatile__ (
  41b57f:	44 89 c0             	mov    eax,r8d
  41b582:	f0 0f b1 9f 8c 00 00 	lock cmpxchg DWORD PTR [rdi+0x8c],ebx
  41b589:	00 
	if (!owner) return 1;
  41b58a:	85 c0                	test   eax,eax
  41b58c:	0f 84 a6 00 00 00    	je     41b638 <__lockfile+0x108>
	while ((owner = a_cas(&f->lock, 0, tid|MAYBE_WAITERS))) {
  41b592:	81 cb 00 00 00 40    	or     ebx,0x40000000
  41b598:	44 89 c0             	mov    eax,r8d
  41b59b:	f0 0f b1 9f 8c 00 00 	lock cmpxchg DWORD PTR [rdi+0x8c],ebx
  41b5a2:	00 
  41b5a3:	89 c2                	mov    edx,eax
  41b5a5:	85 c0                	test   eax,eax
  41b5a7:	0f 84 8b 00 00 00    	je     41b638 <__lockfile+0x108>
	return __cos_syscall(n, a1, a2, a3, a4, 0, 0, 0);
  41b5ad:	48 bd d0 ce fa ff ff 	movabs rbp,0xfffffffffffaced0
  41b5b4:	ff ff ff 
  41b5b7:	eb 21                	jmp    41b5da <__lockfile+0xaa>
  41b5b9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  41b5c0:	89 d0                	mov    eax,edx
  41b5c2:	f0 41 0f b1 0c 24    	lock cmpxchg DWORD PTR [r12],ecx
		if ((owner & MAYBE_WAITERS) ||
  41b5c8:	39 d0                	cmp    eax,edx
  41b5ca:	74 1e                	je     41b5ea <__lockfile+0xba>
  41b5cc:	31 c0                	xor    eax,eax
  41b5ce:	f0 41 0f b1 1c 24    	lock cmpxchg DWORD PTR [r12],ebx
  41b5d4:	89 c2                	mov    edx,eax
	while ((owner = a_cas(&f->lock, 0, tid|MAYBE_WAITERS))) {
  41b5d6:	85 c0                	test   eax,eax
  41b5d8:	74 5e                	je     41b638 <__lockfile+0x108>
		    a_cas(&f->lock, owner, owner|MAYBE_WAITERS)==owner)
  41b5da:	89 d1                	mov    ecx,edx
--
		if ((owner & MAYBE_WAITERS) ||
  41b5e2:	f7 c2 00 00 00 40    	test   edx,0x40000000
  41b5e8:	74 d6                	je     41b5c0 <__lockfile+0x90>
	__syscall(SYS_futex, addr, FUTEX_WAKE, cnt);
}
static inline void __futexwait(volatile void *addr, int val, int priv)
{
	if (priv) priv = FUTEX_PRIVATE;
	__syscall(SYS_futex, addr, FUTEX_WAIT|priv, val, 0) != -ENOSYS ||
  41b5ea:	4c 63 e9             	movsxd r13,ecx
  41b5ed:	6a 00                	push   0x0
--
  41b602:	bf ca 00 00 00       	mov    edi,0xca
  41b607:	4e 8d 74 3d 00       	lea    r14,[rbp+r15*1+0x0]
  41b60c:	41 ff d6             	call   r14
  41b60f:	59                   	pop    rcx
  41b610:	5e                   	pop    rsi
  41b611:	48 83 f8 da          	cmp    rax,0xffffffffffffffda
  41b615:	75 b5                	jne    41b5cc <__lockfile+0x9c>
  41b617:	6a 00                	push   0x0
  41b619:	31 d2                	xor    edx,edx
--
  41b626:	4c 89 e6             	mov    rsi,r12
  41b629:	bf ca 00 00 00       	mov    edi,0xca
  41b62e:	41 ff d6             	call   r14
  41b631:	58                   	pop    rax
  41b632:	5a                   	pop    rdx
  41b633:	eb 97                	jmp    41b5cc <__lockfile+0x9c>
  41b635:	0f 1f 00             	nop    DWORD PTR [rax]
	if (!owner) return 1;
--
	if (a_swap(&f->lock, 0) & MAYBE_WAITERS)
  41b674:	a9 00 00 00 40       	test   eax,0x40000000
  41b679:	75 05                	jne    41b680 <__unlockfile+0x30>
		__wake(&f->lock, 1, 1);
}
--
  41b67f:	c3                   	ret    
  41b680:	48 8d af 8c 00 00 00 	lea    rbp,[rdi+0x8c]
	return __cos_syscall(n, a1, a2, a3, 0, 0, 0, 0);
  41b687:	6a 00                	push   0x0
  41b689:	45 31 c9             	xor    r9d,r9d
--
  41b6a8:	bf ca 00 00 00       	mov    edi,0xca
  41b6ad:	4c 01 fb             	add    rbx,r15
  41b6b0:	ff d3                	call   rbx
	__syscall(SYS_futex, addr, FUTEX_WAKE|priv, cnt) != -ENOSYS ||
  41b6b2:	59                   	pop    rcx
  41b6b3:	5e                   	pop    rsi
  41b6b4:	48 83 f8 da          	cmp    rax,0xffffffffffffffda
  41b6b8:	75 c1                	jne    41b67b <__unlockfile+0x2b>
  41b6ba:	6a 00                	push   0x0
  41b6bc:	ba 01 00 00 00       	mov    edx,0x1
--
  41b6ce:	48 89 ee             	mov    rsi,rbp
  41b6d1:	bf ca 00 00 00       	mov    edi,0xca
  41b6d6:	ff d3                	call   rbx
  41b6d8:	58                   	pop    rax
  41b6d9:	5a                   	pop    rdx
  41b6da:	eb 9f                	jmp    41b67b <__unlockfile+0x2b>
  41b6dc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

--
  41b6f5:	8b 07                	mov    eax,DWORD PTR [rdi]
  41b6f7:	a8 08                	test   al,0x8
  41b6f9:	75 35                	jne    41b730 <__towrite+0x50>
	}
	/* Clear read buffer (easier than summoning nasal demons) */
--
  41b75f:	4c 01 d8             	add    rax,r11
  41b762:	48 01 d0             	add    rax,rdx
  41b765:	ff e0                	jmp    rax
  41b767:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41b76e:	00 00 
--
  41b79f:	48 8b 42 20          	mov    rax,QWORD PTR [rdx+0x20]
  41b7a3:	48 85 c0             	test   rax,rax
  41b7a6:	0f 84 c4 00 00 00    	je     41b870 <__fwritex+0x100>

	if (l > f->wend - f->wpos) return f->write(f, s, l);
  41b7ac:	49 8b 7c 24 28       	mov    rdi,QWORD PTR [r12+0x28]
  41b7b1:	48 29 f8             	sub    rax,rdi
  41b7b4:	4c 39 e8             	cmp    rax,r13
  41b7b7:	72 5f                	jb     41b818 <__fwritex+0xa8>

--
  41b7d8:	48 89 ee             	mov    rsi,rbp
  41b7db:	4c 01 f8             	add    rax,r15
  41b7de:	ff d0                	call   rax
	f->wpos += l;
  41b7e0:	4d 01 74 24 28       	add    QWORD PTR [r12+0x28],r14
--
  41b7fe:	00 00 
		for (i=l; i && s[i-1] != '\n'; i--);
  41b800:	80 7c 1d ff 0a       	cmp    BYTE PTR [rbp+rbx*1-0x1],0xa
  41b805:	48 8d 43 ff          	lea    rax,[rbx-0x1]
  41b809:	74 35                	je     41b840 <__fwritex+0xd0>
  41b80b:	48 89 c3             	mov    rbx,rax
  41b80e:	48 85 db             	test   rbx,rbx
  41b811:	75 ed                	jne    41b800 <__fwritex+0x90>
  41b813:	eb b3                	jmp    41b7c8 <__fwritex+0x58>
  41b815:	0f 1f 00             	nop    DWORD PTR [rax]
	if (l > f->wend - f->wpos) return f->write(f, s, l);
--
  41b832:	41 5f                	pop    r15
	if (l > f->wend - f->wpos) return f->write(f, s, l);
  41b834:	ff e0                	jmp    rax
  41b836:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41b83d:	00 00 00 
--
  41b843:	48 89 ee             	mov    rsi,rbp
  41b846:	4c 89 e7             	mov    rdi,r12
  41b849:	41 ff 54 24 48       	call   QWORD PTR [r12+0x48]
			if (n < i) return n;
  41b84e:	48 39 c3             	cmp    rbx,rax
  41b851:	77 95                	ja     41b7e8 <__fwritex+0x78>
			l -= i;
--
			l -= i;
  41b85e:	49 29 de             	sub    r14,rbx
  41b861:	e9 65 ff ff ff       	jmp    41b7cb <__fwritex+0x5b>
  41b866:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41b86d:	00 00 00 
--
  41b87a:	48 89 d7             	mov    rdi,rdx
  41b87d:	4c 01 f8             	add    rax,r15
  41b880:	ff d0                	call   rax
  41b882:	85 c0                	test   eax,eax
  41b884:	75 0a                	jne    41b890 <__fwritex+0x120>
	if (l > f->wend - f->wpos) return f->write(f, s, l);
  41b886:	49 8b 44 24 20       	mov    rax,QWORD PTR [r12+0x20]
  41b88b:	e9 1c ff ff ff       	jmp    41b7ac <__fwritex+0x3c>
	if (!f->wend && __towrite(f)) return 0;
  41b890:	31 c0                	xor    eax,eax
  41b892:	e9 51 ff ff ff       	jmp    41b7e8 <__fwritex+0x78>
  41b897:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41b89e:	00 00 
--
  41b903:	48 89 cf             	mov    rdi,rcx
  41b906:	4c 01 f0             	add    rax,r14
  41b909:	ff d0                	call   rax
  41b90b:	4c 8b 44 24 10       	mov    r8,QWORD PTR [rsp+0x10]
  41b910:	89 44 24 08          	mov    DWORD PTR [rsp+0x8],eax
--
  41b914:	49 8b 40 20          	mov    rax,QWORD PTR [r8+0x20]
  41b918:	48 85 c0             	test   rax,rax
  41b91b:	0f 84 1f 01 00 00    	je     41ba40 <fwrite+0x1a0>
	if (l > f->wend - f->wpos) return f->write(f, s, l);
  41b921:	49 8b 78 28          	mov    rdi,QWORD PTR [r8+0x28]
  41b925:	48 29 f8             	sub    rax,rdi
  41b928:	49 39 c5             	cmp    r13,rax
  41b92b:	77 73                	ja     41b9a0 <fwrite+0x100>
	if (f->lbf >= 0) {
--
  41b953:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
  41b958:	4c 01 f0             	add    rax,r14
  41b95b:	ff d0                	call   rax
	f->wpos += l;
  41b95d:	4c 8b 44 24 18       	mov    r8,QWORD PTR [rsp+0x18]
--
	FUNLOCK(f);
  41b96f:	85 c9                	test   ecx,ecx
  41b971:	75 6d                	jne    41b9e0 <fwrite+0x140>
	return k==l ? nmemb : k/size;
}
--
  41b985:	0f 1f 00             	nop    DWORD PTR [rax]
		for (i=l; i && s[i-1] != '\n'; i--);
  41b988:	41 80 7c 1f ff 0a    	cmp    BYTE PTR [r15+rbx*1-0x1],0xa
  41b98e:	48 8d 43 ff          	lea    rax,[rbx-0x1]
  41b992:	74 74                	je     41ba08 <fwrite+0x168>
  41b994:	48 89 c3             	mov    rbx,rax
  41b997:	48 85 db             	test   rbx,rbx
  41b99a:	75 ec                	jne    41b988 <fwrite+0xe8>
  41b99c:	eb 9d                	jmp    41b93b <fwrite+0x9b>
  41b99e:	66 90                	xchg   ax,ax
	if (l > f->wend - f->wpos) return f->write(f, s, l);
--
  41b9a8:	4c 89 ea             	mov    rdx,r13
  41b9ab:	4c 89 fe             	mov    rsi,r15
  41b9ae:	41 ff 50 48          	call   QWORD PTR [r8+0x48]
  41b9b2:	4c 8b 44 24 10       	mov    r8,QWORD PTR [rsp+0x10]
	FUNLOCK(f);
  41b9b7:	8b 54 24 08          	mov    edx,DWORD PTR [rsp+0x8]
  41b9bb:	85 d2                	test   edx,edx
  41b9bd:	75 24                	jne    41b9e3 <fwrite+0x143>
	return k==l ? nmemb : k/size;
  41b9bf:	49 39 c5             	cmp    r13,rax
  41b9c2:	74 af                	je     41b973 <fwrite+0xd3>
}
  41b9c4:	48 83 c4 28          	add    rsp,0x28
--
  41b9f2:	4c 89 c7             	mov    rdi,r8
  41b9f5:	4c 01 f2             	add    rdx,r14
  41b9f8:	ff d2                	call   rdx
  41b9fa:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
  41b9ff:	eb be                	jmp    41b9bf <fwrite+0x11f>
  41ba01:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
			size_t n = f->write(f, s, i);
--
  41ba10:	48 89 da             	mov    rdx,rbx
  41ba13:	4c 89 fe             	mov    rsi,r15
  41ba16:	41 ff 50 48          	call   QWORD PTR [r8+0x48]
			if (n < i) return n;
  41ba1a:	4c 8b 44 24 10       	mov    r8,QWORD PTR [rsp+0x10]
  41ba1f:	48 39 c3             	cmp    rbx,rax
  41ba22:	77 93                	ja     41b9b7 <fwrite+0x117>
			l -= i;
--
			l -= i;
  41ba2e:	48 29 da             	sub    rdx,rbx
  41ba31:	e9 08 ff ff ff       	jmp    41b93e <fwrite+0x9e>
  41ba36:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41ba3d:	00 00 00 
--
  41ba4f:	4c 89 c7             	mov    rdi,r8
  41ba52:	4c 01 f0             	add    rax,r14
  41ba55:	ff d0                	call   rax
  41ba57:	4c 8b 44 24 10       	mov    r8,QWORD PTR [rsp+0x10]
  41ba5c:	85 c0                	test   eax,eax
  41ba5e:	75 10                	jne    41ba70 <fwrite+0x1d0>
	if (l > f->wend - f->wpos) return f->write(f, s, l);
  41ba60:	49 8b 40 20          	mov    rax,QWORD PTR [r8+0x20]
  41ba64:	e9 b8 fe ff ff       	jmp    41b921 <fwrite+0x81>
  41ba69:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	if (!f->wend && __towrite(f)) return 0;
  41ba70:	31 c0                	xor    eax,eax
  41ba72:	e9 40 ff ff ff       	jmp    41b9b7 <fwrite+0x117>
  41ba77:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41ba7e:	00 00 
--
  41ba95:	4c 01 da             	add    rdx,r11
  41ba98:	48 85 ff             	test   rdi,rdi
  41ba9b:	0f 84 82 00 00 00    	je     41bb23 <wcrtomb+0xa3>
  41baa1:	48 89 f9             	mov    rcx,rdi
  41baa4:	89 f0                	mov    eax,esi
	if ((unsigned)wc < 0x80) {
  41baa6:	83 fe 7f             	cmp    esi,0x7f
  41baa9:	76 75                	jbe    41bb20 <wcrtomb+0xa0>
{
--
	} else if (MB_CUR_MAX == 1) {
  41bab8:	48 8b b6 b0 00 00 00 	mov    rsi,QWORD PTR [rsi+0xb0]
  41babf:	48 83 3e 00          	cmp    QWORD PTR [rsi],0x0
  41bac3:	74 6b                	je     41bb30 <wcrtomb+0xb0>
			errno = EILSEQ;
			return -1;
--
		return 1;
	} else if ((unsigned)wc < 0x800) {
  41bac5:	3d ff 07 00 00       	cmp    eax,0x7ff
  41baca:	0f 86 c0 00 00 00    	jbe    41bb90 <wcrtomb+0x110>
		*s++ = 0xc0 | (wc>>6);
--
	} else if ((unsigned)wc < 0xd800 || (unsigned)wc-0xe000 < 0x2000) {
  41bad0:	8d b0 00 20 ff ff    	lea    esi,[rax-0xe000]
  41bad6:	81 fe ff 1f 00 00    	cmp    esi,0x1fff
  41badc:	0f 86 ce 00 00 00    	jbe    41bbb0 <wcrtomb+0x130>
  41bae2:	3d ff d7 00 00       	cmp    eax,0xd7ff
  41bae7:	0f 86 c3 00 00 00    	jbe    41bbb0 <wcrtomb+0x130>
		*s++ = 0xe0 | (wc>>12);
--
	} else if ((unsigned)wc-0x10000 < 0x100000) {
  41baed:	8d b0 00 00 ff ff    	lea    esi,[rax-0x10000]
  41baf3:	81 fe ff ff 0f 00    	cmp    esi,0xfffff
  41baf9:	76 55                	jbe    41bb50 <wcrtomb+0xd0>
		*s++ = 0x80 | ((wc>>12)&0x3f);
--
  41bb02:	ff ff ff 
  41bb05:	48 01 d0             	add    rax,rdx
  41bb08:	ff d0                	call   rax
  41bb0a:	c7 00 54 00 00 00    	mov    DWORD PTR [rax],0x54
	return -1;
--
		if (!IS_CODEUNIT(wc)) {
  41bb30:	8d b0 80 20 ff ff    	lea    esi,[rax-0xdf80]
  41bb36:	83 fe 7f             	cmp    esi,0x7f
  41bb39:	77 c0                	ja     41bafb <wcrtomb+0x7b>
		*s = wc;
--
  41bb81:	88 57 02             	mov    BYTE PTR [rdi+0x2],dl
		return 4;
  41bb84:	eb 91                	jmp    41bb17 <wcrtomb+0x97>
  41bb86:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41bb8d:	00 00 00 
--
  41bba6:	88 17                	mov    BYTE PTR [rdi],dl
		return 2;
  41bba8:	e9 6a ff ff ff       	jmp    41bb17 <wcrtomb+0x97>
  41bbad:	0f 1f 00             	nop    DWORD PTR [rax]
		*s++ = 0xe0 | (wc>>12);
--
  41bbd3:	88 51 01             	mov    BYTE PTR [rcx+0x1],dl
		return 3;
  41bbd6:	e9 3c ff ff ff       	jmp    41bb17 <wcrtomb+0x97>
  41bbdb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

--
	for (f=*__ofl_lock(); f; f=f->next) close_file(f);
  41bc06:	48 01 e8             	add    rax,rbp
  41bc09:	ff d0                	call   rax
  41bc0b:	48 8b 18             	mov    rbx,QWORD PTR [rax]
  41bc0e:	48 85 db             	test   rbx,rbx
  41bc11:	74 5d                	je     41bc70 <__stdio_exit+0x90>
	FFINALLOCK(f);
  41bc13:	49 bc 20 e1 fb ff ff 	movabs r12,0xfffffffffffbe120
--
  41bc2a:	48 89 df             	mov    rdi,rbx
  41bc2d:	4a 8d 44 25 00       	lea    rax,[rbp+r12*1+0x0]
  41bc32:	ff d0                	call   rax
	if (f->wpos != f->wbase) f->write(f, 0, 0);
  41bc34:	48 8b 43 38          	mov    rax,QWORD PTR [rbx+0x38]
  41bc38:	48 39 43 28          	cmp    QWORD PTR [rbx+0x28],rax
  41bc3c:	74 0a                	je     41bc48 <__stdio_exit+0x68>
  41bc3e:	31 d2                	xor    edx,edx
  41bc40:	31 f6                	xor    esi,esi
  41bc42:	48 89 df             	mov    rdi,rbx
  41bc45:	ff 53 48             	call   QWORD PTR [rbx+0x48]
	if (f->rpos != f->rend) f->seek(f, f->rpos-f->rend, SEEK_CUR);
  41bc48:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
  41bc4c:	48 8b 43 10          	mov    rax,QWORD PTR [rbx+0x10]
  41bc50:	48 39 c6             	cmp    rsi,rax
  41bc53:	0f 84 27 01 00 00    	je     41bd80 <__stdio_exit+0x1a0>
  41bc59:	48 89 df             	mov    rdi,rbx
  41bc5c:	48 29 c6             	sub    rsi,rax
  41bc5f:	ba 01 00 00 00       	mov    edx,0x1
  41bc64:	ff 53 50             	call   QWORD PTR [rbx+0x50]
	for (f=*__ofl_lock(); f; f=f->next) close_file(f);
  41bc67:	48 8b 5b 70          	mov    rbx,QWORD PTR [rbx+0x70]
  41bc6b:	48 85 db             	test   rbx,rbx
  41bc6e:	75 b0                	jne    41bc20 <__stdio_exit+0x40>
	close_file(__stdin_used);
  41bc70:	48 b8 60 4e 14 00 00 	movabs rax,0x144e60
--
	if (!f) return;
  41bc7f:	48 85 db             	test   rbx,rbx
  41bc82:	74 3d                	je     41bcc1 <__stdio_exit+0xe1>
	FFINALLOCK(f);
  41bc84:	8b 83 8c 00 00 00    	mov    eax,DWORD PTR [rbx+0x8c]
--
	if (f->wpos != f->wbase) f->write(f, 0, 0);
  41bc92:	48 8b 43 38          	mov    rax,QWORD PTR [rbx+0x38]
  41bc96:	48 39 43 28          	cmp    QWORD PTR [rbx+0x28],rax
  41bc9a:	74 0a                	je     41bca6 <__stdio_exit+0xc6>
  41bc9c:	31 d2                	xor    edx,edx
  41bc9e:	31 f6                	xor    esi,esi
  41bca0:	48 89 df             	mov    rdi,rbx
  41bca3:	ff 53 48             	call   QWORD PTR [rbx+0x48]
	if (f->rpos != f->rend) f->seek(f, f->rpos-f->rend, SEEK_CUR);
  41bca6:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
  41bcaa:	48 8b 43 10          	mov    rax,QWORD PTR [rbx+0x10]
  41bcae:	48 39 c6             	cmp    rsi,rax
  41bcb1:	74 0e                	je     41bcc1 <__stdio_exit+0xe1>
  41bcb3:	48 29 c6             	sub    rsi,rax
  41bcb6:	ba 01 00 00 00       	mov    edx,0x1
  41bcbb:	48 89 df             	mov    rdi,rbx
  41bcbe:	ff 53 50             	call   QWORD PTR [rbx+0x50]
	close_file(__stdout_used);
  41bcc1:	48 b8 60 4e 14 00 00 	movabs rax,0x144e60
--
	if (!f) return;
  41bcd0:	48 85 db             	test   rbx,rbx
  41bcd3:	74 3d                	je     41bd12 <__stdio_exit+0x132>
	FFINALLOCK(f);
  41bcd5:	8b 83 8c 00 00 00    	mov    eax,DWORD PTR [rbx+0x8c]
--
	if (f->wpos != f->wbase) f->write(f, 0, 0);
  41bce3:	48 8b 43 38          	mov    rax,QWORD PTR [rbx+0x38]
  41bce7:	48 39 43 28          	cmp    QWORD PTR [rbx+0x28],rax
  41bceb:	74 0a                	je     41bcf7 <__stdio_exit+0x117>
  41bced:	31 d2                	xor    edx,edx
  41bcef:	31 f6                	xor    esi,esi
  41bcf1:	48 89 df             	mov    rdi,rbx
  41bcf4:	ff 53 48             	call   QWORD PTR [rbx+0x48]
	if (f->rpos != f->rend) f->seek(f, f->rpos-f->rend, SEEK_CUR);
  41bcf7:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
  41bcfb:	48 8b 43 10          	mov    rax,QWORD PTR [rbx+0x10]
  41bcff:	48 39 c6             	cmp    rsi,rax
  41bd02:	74 0e                	je     41bd12 <__stdio_exit+0x132>
  41bd04:	48 29 c6             	sub    rsi,rax
  41bd07:	ba 01 00 00 00       	mov    edx,0x1
  41bd0c:	48 89 df             	mov    rdi,rbx
  41bd0f:	ff 53 50             	call   QWORD PTR [rbx+0x50]
	close_file(__stderr_used);
  41bd12:	48 b8 60 4e 14 00 00 	movabs rax,0x144e60
--
	if (!f) return;
  41bd21:	4d 85 e4             	test   r12,r12
  41bd24:	0f 84 c6 00 00 00    	je     41bdf0 <__stdio_exit+0x210>
	FFINALLOCK(f);
  41bd2a:	41 8b 84 24 8c 00 00 	mov    eax,DWORD PTR [r12+0x8c]
--
	if (f->wpos != f->wbase) f->write(f, 0, 0);
  41bd36:	49 8b 44 24 38       	mov    rax,QWORD PTR [r12+0x38]
  41bd3b:	49 39 44 24 28       	cmp    QWORD PTR [r12+0x28],rax
  41bd40:	74 0c                	je     41bd4e <__stdio_exit+0x16e>
  41bd42:	31 d2                	xor    edx,edx
  41bd44:	31 f6                	xor    esi,esi
  41bd46:	4c 89 e7             	mov    rdi,r12
  41bd49:	41 ff 54 24 48       	call   QWORD PTR [r12+0x48]
	if (f->rpos != f->rend) f->seek(f, f->rpos-f->rend, SEEK_CUR);
  41bd4e:	49 8b 74 24 08       	mov    rsi,QWORD PTR [r12+0x8]
  41bd53:	49 8b 44 24 10       	mov    rax,QWORD PTR [r12+0x10]
  41bd58:	48 39 c6             	cmp    rsi,rax
  41bd5b:	0f 84 8f 00 00 00    	je     41bdf0 <__stdio_exit+0x210>
}
  41bd61:	5b                   	pop    rbx
--
  41bd73:	41 5c                	pop    r12
	if (f->rpos != f->rend) f->seek(f, f->rpos-f->rend, SEEK_CUR);
  41bd75:	ff e0                	jmp    rax
  41bd77:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41bd7e:	00 00 
--
  41bd80:	48 8b 5b 70          	mov    rbx,QWORD PTR [rbx+0x70]
  41bd84:	48 85 db             	test   rbx,rbx
  41bd87:	0f 85 93 fe ff ff    	jne    41bc20 <__stdio_exit+0x40>
  41bd8d:	e9 de fe ff ff       	jmp    41bc70 <__stdio_exit+0x90>
  41bd92:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	FFINALLOCK(f);
--
  41bda2:	4c 89 e7             	mov    rdi,r12
  41bda5:	48 01 e8             	add    rax,rbp
  41bda8:	ff d0                	call   rax
  41bdaa:	eb 8a                	jmp    41bd36 <__stdio_exit+0x156>
  41bdac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  41bdb0:	48 b8 20 e1 fb ff ff 	movabs rax,0xfffffffffffbe120
--
  41bdba:	48 89 df             	mov    rdi,rbx
  41bdbd:	48 01 e8             	add    rax,rbp
  41bdc0:	ff d0                	call   rax
  41bdc2:	e9 1c ff ff ff       	jmp    41bce3 <__stdio_exit+0x103>
  41bdc7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41bdce:	00 00 
--
  41bdda:	48 89 df             	mov    rdi,rbx
  41bddd:	48 01 e8             	add    rax,rbp
  41bde0:	ff d0                	call   rax
  41bde2:	e9 ab fe ff ff       	jmp    41bc92 <__stdio_exit+0xb2>
  41bde7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41bdee:	00 00 
--
  41be2e:	ff ff ff 
  41be31:	48 01 d8             	add    rax,rbx
  41be34:	ff d0                	call   rax
	return &ofl_head;
  41be36:	48 b8 70 4e 14 00 00 	movabs rax,0x144e70
--
  41be7d:	ff ff ff 
  41be80:	48 01 d0             	add    rax,rdx
  41be83:	ff e0                	jmp    rax
  41be85:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41be8c:	00 00 00 
--
  41bec0:	41 8b 44 07 0c       	mov    eax,DWORD PTR [r15+rax*1+0xc]
  41bec5:	85 c0                	test   eax,eax
  41bec7:	0f 84 d3 01 00 00    	je     41c0a0 <__lock+0x210>
  41becd:	49 89 fc             	mov    r12,rdi
	__asm__ __volatile__ (
  41bed0:	31 c0                	xor    eax,eax
  41bed2:	ba 01 00 00 80       	mov    edx,0x80000001
  41bed7:	f0 0f b1 17          	lock cmpxchg DWORD PTR [rdi],edx
  41bedb:	89 c2                	mov    edx,eax
	/* fast path: INT_MIN for the lock, +1 for the congestion */
--
	if (!current) return;
  41bedd:	85 c0                	test   eax,eax
  41bedf:	0f 84 bb 01 00 00    	je     41c0a0 <__lock+0x210>
	/* A first spin loop, for medium congestion. */
	for (unsigned i = 0; i < 10; ++i) {
--
  41beef:	81 c2 ff ff ff 7f    	add    edx,0x7fffffff
  41bef5:	89 d0                	mov    eax,edx
  41bef7:	f0 41 0f b1 0c 24    	lock cmpxchg DWORD PTR [r12],ecx
  41befd:	89 c1                	mov    ecx,eax
		if (val == current) return;
  41beff:	39 d0                	cmp    eax,edx
  41bf01:	0f 84 99 01 00 00    	je     41c0a0 <__lock+0x210>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41bf07:	8d 90 01 00 00 80    	lea    edx,[rax-0x7fffffff]
--
  41bf13:	81 c1 ff ff ff 7f    	add    ecx,0x7fffffff
  41bf19:	89 c8                	mov    eax,ecx
  41bf1b:	f0 41 0f b1 14 24    	lock cmpxchg DWORD PTR [r12],edx
  41bf21:	89 c2                	mov    edx,eax
		if (val == current) return;
  41bf23:	39 c1                	cmp    ecx,eax
  41bf25:	0f 84 75 01 00 00    	je     41c0a0 <__lock+0x210>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41bf2b:	8d 88 01 00 00 80    	lea    ecx,[rax-0x7fffffff]
--
  41bf37:	81 c2 ff ff ff 7f    	add    edx,0x7fffffff
  41bf3d:	89 d0                	mov    eax,edx
  41bf3f:	f0 41 0f b1 0c 24    	lock cmpxchg DWORD PTR [r12],ecx
  41bf45:	89 c1                	mov    ecx,eax
		if (val == current) return;
  41bf47:	39 c2                	cmp    edx,eax
  41bf49:	0f 84 51 01 00 00    	je     41c0a0 <__lock+0x210>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41bf4f:	8d 90 01 00 00 80    	lea    edx,[rax-0x7fffffff]
--
  41bf5b:	81 c1 ff ff ff 7f    	add    ecx,0x7fffffff
  41bf61:	89 c8                	mov    eax,ecx
  41bf63:	f0 41 0f b1 14 24    	lock cmpxchg DWORD PTR [r12],edx
  41bf69:	89 c2                	mov    edx,eax
		if (val == current) return;
  41bf6b:	39 c1                	cmp    ecx,eax
  41bf6d:	0f 84 2d 01 00 00    	je     41c0a0 <__lock+0x210>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41bf73:	8d 88 01 00 00 80    	lea    ecx,[rax-0x7fffffff]
--
  41bf7f:	81 c2 ff ff ff 7f    	add    edx,0x7fffffff
  41bf85:	89 d0                	mov    eax,edx
  41bf87:	f0 41 0f b1 0c 24    	lock cmpxchg DWORD PTR [r12],ecx
  41bf8d:	89 c1                	mov    ecx,eax
		if (val == current) return;
  41bf8f:	39 c2                	cmp    edx,eax
  41bf91:	0f 84 09 01 00 00    	je     41c0a0 <__lock+0x210>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41bf97:	8d 90 01 00 00 80    	lea    edx,[rax-0x7fffffff]
--
  41bf9f:	0f 88 0b 01 00 00    	js     41c0b0 <__lock+0x220>
  41bfa5:	89 c8                	mov    eax,ecx
  41bfa7:	f0 41 0f b1 14 24    	lock cmpxchg DWORD PTR [r12],edx
  41bfad:	89 c2                	mov    edx,eax
		if (val == current) return;
  41bfaf:	39 c1                	cmp    ecx,eax
  41bfb1:	0f 84 e9 00 00 00    	je     41c0a0 <__lock+0x210>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41bfb7:	8d 88 01 00 00 80    	lea    ecx,[rax-0x7fffffff]
--
  41bfbf:	0f 88 fb 00 00 00    	js     41c0c0 <__lock+0x230>
  41bfc5:	89 d0                	mov    eax,edx
  41bfc7:	f0 41 0f b1 0c 24    	lock cmpxchg DWORD PTR [r12],ecx
  41bfcd:	89 c1                	mov    ecx,eax
		if (val == current) return;
  41bfcf:	39 c2                	cmp    edx,eax
  41bfd1:	0f 84 c9 00 00 00    	je     41c0a0 <__lock+0x210>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41bfd7:	8d 90 01 00 00 80    	lea    edx,[rax-0x7fffffff]
--
  41bfdf:	0f 88 eb 00 00 00    	js     41c0d0 <__lock+0x240>
  41bfe5:	89 c8                	mov    eax,ecx
  41bfe7:	f0 41 0f b1 14 24    	lock cmpxchg DWORD PTR [r12],edx
  41bfed:	89 c2                	mov    edx,eax
		if (val == current) return;
  41bfef:	39 c1                	cmp    ecx,eax
  41bff1:	0f 84 a9 00 00 00    	je     41c0a0 <__lock+0x210>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41bff7:	8d 88 01 00 00 80    	lea    ecx,[rax-0x7fffffff]
--
  41bfff:	0f 88 db 00 00 00    	js     41c0e0 <__lock+0x250>
  41c005:	89 d0                	mov    eax,edx
  41c007:	f0 41 0f b1 0c 24    	lock cmpxchg DWORD PTR [r12],ecx
  41c00d:	89 c1                	mov    ecx,eax
		if (val == current) return;
  41c00f:	39 c2                	cmp    edx,eax
  41c011:	0f 84 89 00 00 00    	je     41c0a0 <__lock+0x210>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41c017:	8d 90 01 00 00 80    	lea    edx,[rax-0x7fffffff]
--
  41c01f:	0f 88 cb 00 00 00    	js     41c0f0 <__lock+0x260>
  41c025:	89 c8                	mov    eax,ecx
  41c027:	f0 41 0f b1 14 24    	lock cmpxchg DWORD PTR [r12],edx
		if (val == current) return;
  41c02d:	39 c1                	cmp    ecx,eax
  41c02f:	74 6f                	je     41c0a0 <__lock+0x210>
	__asm__ __volatile__(
  41c031:	bb 01 00 00 00       	mov    ebx,0x1
  41c036:	f0 41 0f c1 1c 24    	lock xadd DWORD PTR [r12],ebx
	return __cos_syscall(n, a1, a2, a3, a4, 0, 0, 0);
  41c03c:	48 bd d0 ce fa ff ff 	movabs rbp,0xfffffffffffaced0
  41c043:	ff ff ff 
--
	current = a_fetch_add(l, 1) + 1;
  41c046:	83 c3 01             	add    ebx,0x1
  41c049:	eb 19                	jmp    41c064 <__lock+0x1d4>
  41c04b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		if (current < 0) {
--
	__asm__ __volatile__ (
  41c056:	89 d0                	mov    eax,edx
  41c058:	f0 41 0f b1 1c 24    	lock cmpxchg DWORD PTR [r12],ebx
  41c05e:	89 c3                	mov    ebx,eax
		if (val == current) return;
  41c060:	39 c2                	cmp    edx,eax
  41c062:	74 3c                	je     41c0a0 <__lock+0x210>
		if (current < 0) {
  41c064:	89 da                	mov    edx,ebx
  41c066:	85 db                	test   ebx,ebx
  41c068:	79 e6                	jns    41c050 <__lock+0x1c0>
	__syscall(SYS_futex, addr, FUTEX_WAIT|priv, val, 0) != -ENOSYS ||
  41c06a:	4c 63 f3             	movsxd r14,ebx
  41c06d:	6a 00                	push   0x0
--
  41c082:	bf ca 00 00 00       	mov    edi,0xca
  41c087:	4e 8d 6c 3d 00       	lea    r13,[rbp+r15*1+0x0]
  41c08c:	41 ff d5             	call   r13
  41c08f:	59                   	pop    rcx
  41c090:	5e                   	pop    rsi
  41c091:	48 83 f8 da          	cmp    rax,0xffffffffffffffda
  41c095:	74 69                	je     41c100 <__lock+0x270>
			current -= INT_MIN + 1;
  41c097:	8d 93 ff ff ff 7f    	lea    edx,[rbx+0x7fffffff]
  41c09d:	eb b1                	jmp    41c050 <__lock+0x1c0>
  41c09f:	90                   	nop
		current = val;
--
  41c0b0:	89 c2                	mov    edx,eax
  41c0b2:	81 c1 ff ff ff 7f    	add    ecx,0x7fffffff
  41c0b8:	e9 e8 fe ff ff       	jmp    41bfa5 <__lock+0x115>
  41c0bd:	0f 1f 00             	nop    DWORD PTR [rax]
  41c0c0:	89 c1                	mov    ecx,eax
  41c0c2:	81 c2 ff ff ff 7f    	add    edx,0x7fffffff
  41c0c8:	e9 f8 fe ff ff       	jmp    41bfc5 <__lock+0x135>
  41c0cd:	0f 1f 00             	nop    DWORD PTR [rax]
  41c0d0:	89 c2                	mov    edx,eax
  41c0d2:	81 c1 ff ff ff 7f    	add    ecx,0x7fffffff
  41c0d8:	e9 08 ff ff ff       	jmp    41bfe5 <__lock+0x155>
  41c0dd:	0f 1f 00             	nop    DWORD PTR [rax]
  41c0e0:	89 c1                	mov    ecx,eax
  41c0e2:	81 c2 ff ff ff 7f    	add    edx,0x7fffffff
  41c0e8:	e9 18 ff ff ff       	jmp    41c005 <__lock+0x175>
  41c0ed:	0f 1f 00             	nop    DWORD PTR [rax]
  41c0f0:	89 c2                	mov    edx,eax
  41c0f2:	81 c1 ff ff ff 7f    	add    ecx,0x7fffffff
  41c0f8:	e9 28 ff ff ff       	jmp    41c025 <__lock+0x195>
  41c0fd:	0f 1f 00             	nop    DWORD PTR [rax]
  41c100:	6a 00                	push   0x0
--
  41c10f:	4c 89 e6             	mov    rsi,r12
  41c112:	bf ca 00 00 00       	mov    edi,0xca
  41c117:	41 ff d5             	call   r13
  41c11a:	58                   	pop    rax
  41c11b:	5a                   	pop    rdx
  41c11c:	e9 76 ff ff ff       	jmp    41c097 <__lock+0x207>
  41c121:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41c128:	00 00 00 
--
  41c168:	f0 0f c1 07          	lock xadd DWORD PTR [rdi],eax
		if (a_fetch_add(l, -(INT_MIN + 1)) != (INT_MIN + 1)) {
  41c16c:	3d 01 00 00 80       	cmp    eax,0x80000001
  41c171:	74 df                	je     41c152 <__unlock+0x22>
	return __cos_syscall(n, a1, a2, a3, 0, 0, 0, 0);
  41c173:	6a 00                	push   0x0
  41c175:	48 89 fe             	mov    rsi,rdi
--
  41c196:	ff ff ff 
  41c199:	4c 01 fb             	add    rbx,r15
  41c19c:	ff d3                	call   rbx
	__syscall(SYS_futex, addr, FUTEX_WAKE|priv, cnt) != -ENOSYS ||
  41c19e:	59                   	pop    rcx
  41c19f:	5e                   	pop    rsi
  41c1a0:	48 83 f8 da          	cmp    rax,0xffffffffffffffda
  41c1a4:	75 ac                	jne    41c152 <__unlock+0x22>
  41c1a6:	6a 00                	push   0x0
  41c1a8:	ba 01 00 00 00       	mov    edx,0x1
--
  41c1ba:	48 89 ee             	mov    rsi,rbp
  41c1bd:	bf ca 00 00 00       	mov    edi,0xca
  41c1c2:	ff d3                	call   rbx
  41c1c4:	58                   	pop    rax
  41c1c5:	5a                   	pop    rdx
}
  41c1c6:	eb 8a                	jmp    41c152 <__unlock+0x22>
