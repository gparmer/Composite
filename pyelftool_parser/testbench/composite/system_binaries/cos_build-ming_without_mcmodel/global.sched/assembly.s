
sched.pfprr_quantum_static.global.sched:     file format elf64-x86-64


Disassembly of section .text:

0000000000400000 <printc>:
	return cos_print_str(s, strlen(s));
}

static int  __attribute__((format(printf, 1, 2)))
printc(char *fmt, ...)
{
  400000:	55                   	push   rbp
  400001:	49 89 fa             	mov    r10,rdi
  400004:	48 89 e5             	mov    rbp,rsp
  400007:	48 81 ec 90 01 00 00 	sub    rsp,0x190
  40000e:	48 89 b5 58 ff ff ff 	mov    QWORD PTR [rbp-0xa8],rsi
  400015:	48 89 95 60 ff ff ff 	mov    QWORD PTR [rbp-0xa0],rdx
  40001c:	48 89 8d 68 ff ff ff 	mov    QWORD PTR [rbp-0x98],rcx
  400023:	4c 89 85 70 ff ff ff 	mov    QWORD PTR [rbp-0x90],r8
  40002a:	4c 89 8d 78 ff ff ff 	mov    QWORD PTR [rbp-0x88],r9
  400031:	84 c0                	test   al,al
  400033:	74 20                	je     400055 <printc+0x55>
  400035:	0f 29 45 80          	movaps XMMWORD PTR [rbp-0x80],xmm0
  400039:	0f 29 4d 90          	movaps XMMWORD PTR [rbp-0x70],xmm1
  40003d:	0f 29 55 a0          	movaps XMMWORD PTR [rbp-0x60],xmm2
  400041:	0f 29 5d b0          	movaps XMMWORD PTR [rbp-0x50],xmm3
  400045:	0f 29 65 c0          	movaps XMMWORD PTR [rbp-0x40],xmm4
  400049:	0f 29 6d d0          	movaps XMMWORD PTR [rbp-0x30],xmm5
  40004d:	0f 29 75 e0          	movaps XMMWORD PTR [rbp-0x20],xmm6
  400051:	0f 29 7d f0          	movaps XMMWORD PTR [rbp-0x10],xmm7
	char    s[180];
	va_list arg_ptr;
	size_t  ret;

	va_start(arg_ptr, fmt);
  400055:	48 8d 45 10          	lea    rax,[rbp+0x10]
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  400059:	48 8d 8d 78 fe ff ff 	lea    rcx,[rbp-0x188]
  400060:	4c 89 d2             	mov    rdx,r10
  400063:	be b4 00 00 00       	mov    esi,0xb4
	va_start(arg_ptr, fmt);
  400068:	48 89 85 80 fe ff ff 	mov    QWORD PTR [rbp-0x180],rax
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40006f:	48 8d bd 90 fe ff ff 	lea    rdi,[rbp-0x170]
	va_start(arg_ptr, fmt);
  400076:	48 8d 85 50 ff ff ff 	lea    rax,[rbp-0xb0]
  40007d:	c7 85 78 fe ff ff 08 	mov    DWORD PTR [rbp-0x188],0x8
  400084:	00 00 00 
  400087:	c7 85 7c fe ff ff 30 	mov    DWORD PTR [rbp-0x184],0x30
  40008e:	00 00 00 
  400091:	48 89 85 88 fe ff ff 	mov    QWORD PTR [rbp-0x178],rax
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  400098:	e8 c3 54 01 00       	call   415560 <vsnprintf>
	va_end(arg_ptr);
	ret = cos_print_str(s, ret);
  40009d:	48 8d bd 90 fe ff ff 	lea    rdi,[rbp-0x170]
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  4000a4:	89 c6                	mov    esi,eax
	ret = cos_print_str(s, ret);
  4000a6:	e8 25 a0 00 00       	call   40a0d0 <cos_print_str>

	return ret;
}
  4000ab:	c9                   	leave  
  4000ac:	c3                   	ret    
  4000ad:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004000b0 <exit_init_thd>:

struct slm_thd *slm_thd_current_extern(void);

static __attribute__((noreturn)) void
exit_init_thd(void)
{
  4000b0:	55                   	push   rbp
  4000b1:	48 89 e5             	mov    rbp,rsp
  4000b4:	41 54                	push   r12
  4000b6:	48 83 ec 08          	sub    rsp,0x8
	struct slm_thd *current = slm_thd_current_extern();
  4000ba:	e8 81 18 00 00       	call   401940 <slm_thd_current_extern>

	if (cos_coreid() == 0) printc("\tScheduler %ld: Exiting thread %ld from component %ld\n", cos_compid(), cos_thdid(), (compid_t)cos_inv_token());
  4000bf:	48 8b 35 7a 6f 02 00 	mov    rsi,QWORD PTR [rip+0x26f7a]        # 427040 <__cosrt_comp_info+0x40>
  4000c6:	bf e0 c1 41 00       	mov    edi,0x41c1e0
	struct slm_thd *current = slm_thd_current_extern();
  4000cb:	49 89 c4             	mov    r12,rax
static inline long
get_stk_data(int offset)
{
	unsigned long curr_stk_pointer;

	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  4000ce:	48 89 e0             	mov    rax,rsp
	 * access.  We want to find the struct cos_stk (see the stkmgr
	 * interface) so that we can then offset into it and get the
	 * cpu_id.  This struct is at the _top_ of the current stack,
	 * and cpu_id is at the top of the struct (it is a u32_t).
	 */
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  4000d1:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
	if (cos_coreid() == 0) printc("\tScheduler %ld: Exiting thread %ld from component %ld\n", cos_compid(), cos_thdid(), (compid_t)cos_inv_token());
  4000d7:	48 8b 88 e8 1f 00 00 	mov    rcx,QWORD PTR [rax+0x1fe8]
typedef u16_t cos_thdid_t;

static thdid_t
cos_thdid(void)
{
	return cos_get_thd_id();
  4000de:	0f b7 90 f0 1f 00 00 	movzx  edx,WORD PTR [rax+0x1ff0]
  4000e5:	31 c0                	xor    eax,eax
  4000e7:	e8 14 ff ff ff       	call   400000 <printc>
	slm_cs_cached_t cached;
	sched_tok_t     tok;
	struct slm_thd  *owner;
	int             contended;

	assert(current);
  4000ec:	4d 85 e4             	test   r12,r12
  4000ef:	0f 84 09 01 00 00    	je     4001fe <exit_init_thd+0x14e>
	cs = &(slm_global()->lock);

	while (1) {
		tok    = cos_sched_sync();
  4000f5:	e8 06 12 01 00       	call   411300 <cos_sched_sync>
  4000fa:	41 89 c1             	mov    r9d,eax
 * - @ret - a *cached* version of the critical section metadata to be passed into `__slm_cs_cas`.
 */
static inline slm_cs_cached_t
__slm_cs_data(struct slm_cs *cs, struct slm_thd **thd, int *contention)
{
	unsigned long oc = ps_load(&cs->owner_contention);
  4000fd:	48 8b 05 bc 1d 1a 00 	mov    rax,QWORD PTR [rip+0x1a1dbc]        # 5a1ec0 <__slm_global>
		cached = __slm_cs_data(cs, &owner, &contended);

		if (unlikely(owner)) {
  400104:	48 89 c1             	mov    rcx,rax
  400107:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  40010b:	0f 85 b1 00 00 00    	jne    4001c2 <exit_init_thd+0x112>
 */
static inline int
ps_cas(unsigned long *target, unsigned long old, unsigned long updated)
{
        char z;
        __asm__ __volatile__("lock " PS_CAS_STR
  400111:	f0 4c 0f b1 25 a6 1d 	lock cmpxchg QWORD PTR [rip+0x1a1da6],r12        # 5a1ec0 <__slm_global>
  400118:	1a 00 
  40011a:	0f 94 c0             	sete   al

			continue;
		}

		/* success! common case */
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  40011d:	84 c0                	test   al,al
  40011f:	74 d4                	je     4000f5 <exit_init_thd+0x45>

	slm_cs_enter(current, SLM_CS_NONE);
	slm_thd_deinit(current);		/* I'm out! */
  400121:	4c 89 e7             	mov    rdi,r12
  400124:	e8 b7 36 01 00       	call   4137e0 <slm_thd_deinit>
slm_cs_exit(struct slm_thd *switchto, slm_cs_flags_t flags)
{
	int ret = 1;
	struct slm_cs *cs = &(slm_global()->lock);

	while (ret != 0) {
  400129:	eb 15                	jmp    400140 <exit_init_thd+0x90>
  40012b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  400130:	f0 48 0f b1 15 87 1d 	lock cmpxchg QWORD PTR [rip+0x1a1d87],rdx        # 5a1ec0 <__slm_global>
  400137:	1a 00 
  400139:	0f 94 c0             	sete   al
  40013c:	84 c0                	test   al,al
  40013e:	75 2e                	jne    40016e <exit_init_thd+0xbe>
		int             contention;
		sched_tok_t     tok;
		slm_cs_cached_t cached;
		struct slm_thd *current;

		tok    = cos_sched_sync();
  400140:	e8 bb 11 01 00       	call   411300 <cos_sched_sync>
  400145:	89 c1                	mov    ecx,eax
  400147:	48 8b 05 72 1d 1a 00 	mov    rax,QWORD PTR [rip+0x1a1d72]        # 5a1ec0 <__slm_global>
		cached = __slm_cs_data(cs, &current, &contention);
		/* Another thread attempted to enter the critical section */
		if (unlikely(contention)) {
  40014e:	48 89 c2             	mov    rdx,rax
  400151:	83 e2 01             	and    edx,0x1
  400154:	74 da                	je     400130 <exit_init_thd+0x80>
	/* least significant bit signifies contention */
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  400156:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  400159:	48 89 c2             	mov    rdx,rax
  40015c:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  400161:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  400165:	e8 f6 36 01 00       	call   413860 <slm_cs_exit_contention>
  40016a:	85 c0                	test   eax,eax
  40016c:	75 d2                	jne    400140 <exit_init_thd+0x90>
	slm_cs_exit(NULL, SLM_CS_NONE);

	/* Switch to the scheduler thread */
	if (cos_defswitch(BOOT_CAPTBL_SELF_INITTHD_CPU_BASE, TCAP_PRIO_MAX, TCAP_RES_INF, cos_sched_sync())) BUG();
  40016e:	e8 8d 11 01 00       	call   411300 <cos_sched_sync>
  400173:	be 01 00 00 00       	mov    esi,0x1
  400178:	bf 28 00 00 00       	mov    edi,0x28
  40017d:	48 c7 c2 ff ff ff ff 	mov    rdx,0xffffffffffffffff
  400184:	89 c1                	mov    ecx,eax
  400186:	e8 d5 c5 00 00       	call   40c760 <cos_defswitch>
	return cos_print_str(s, strlen(s));
  40018b:	be 11 00 00 00       	mov    esi,0x11
  400190:	85 c0                	test   eax,eax
  400192:	75 17                	jne    4001ab <exit_init_thd+0xfb>
  400194:	bf e4 c2 41 00       	mov    edi,0x41c2e4
  400199:	e8 32 9f 00 00       	call   40a0d0 <cos_print_str>

	BUG();
  40019e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4001a5:	00 00 00 00 
  4001a9:	0f 0b                	ud2    
  4001ab:	bf d2 c2 41 00       	mov    edi,0x41c2d2
  4001b0:	e8 1b 9f 00 00       	call   40a0d0 <cos_print_str>
	if (cos_defswitch(BOOT_CAPTBL_SELF_INITTHD_CPU_BASE, TCAP_PRIO_MAX, TCAP_RES_INF, cos_sched_sync())) BUG();
  4001b5:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4001bc:	00 00 00 00 
  4001c0:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  4001c2:	41 89 c0             	mov    r8d,eax
  4001c5:	4c 89 e2             	mov    rdx,r12
  4001c8:	48 89 c6             	mov    rsi,rax
  4001cb:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  4001d0:	41 83 e0 01          	and    r8d,0x1
  4001d4:	e8 37 36 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  4001d9:	83 f8 f0             	cmp    eax,0xfffffff0
  4001dc:	0f 85 13 ff ff ff    	jne    4000f5 <exit_init_thd+0x45>
  4001e2:	be 59 00 00 00       	mov    esi,0x59
  4001e7:	bf 78 c2 41 00       	mov    edi,0x41c278
  4001ec:	e8 df 9e 00 00       	call   40a0d0 <cos_print_str>
  4001f1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4001f8:	00 00 00 00 
  4001fc:	0f 0b                	ud2    
  4001fe:	be 59 00 00 00       	mov    esi,0x59
  400203:	bf 18 c2 41 00       	mov    edi,0x41c218
  400208:	e8 c3 9e 00 00       	call   40a0d0 <cos_print_str>
	assert(current);
  40020d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400214:	00 00 00 00 
  400218:	0f 0b                	ud2    
  40021a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000400220 <calculate_initialization_schedule>:
{
  400220:	f3 0f 1e fa          	endbr64 
  400224:	55                   	push   rbp
	ret = args_get_entry("execute", &exec_entries);
  400225:	bf f6 c2 41 00       	mov    edi,0x41c2f6
{
  40022a:	48 89 e5             	mov    rbp,rsp
  40022d:	41 54                	push   r12
  40022f:	53                   	push   rbx
	ret = args_get_entry("execute", &exec_entries);
  400230:	48 8d 75 90          	lea    rsi,[rbp-0x70]
{
  400234:	48 83 ec 70          	sub    rsp,0x70
	ret = args_get_entry("execute", &exec_entries);
  400238:	e8 43 ae 00 00       	call   40b080 <args_get_entry>
	assert(!ret);
  40023d:	85 c0                	test   eax,eax
  40023f:	0f 85 9b 01 00 00    	jne    4003e0 <calculate_initialization_schedule+0x1c0>
	printc("\tSched %ld: %d components that need execution\n", cos_compid(), args_len(&exec_entries));
  400245:	48 8d 7d 90          	lea    rdi,[rbp-0x70]
  400249:	e8 32 a8 00 00       	call   40aa80 <args_len>
  40024e:	48 8b 35 eb 6d 02 00 	mov    rsi,QWORD PTR [rip+0x26deb]        # 427040 <__cosrt_comp_info+0x40>
  400255:	bf 28 c3 41 00       	mov    edi,0x41c328
  40025a:	89 c2                	mov    edx,eax
  40025c:	31 c0                	xor    eax,eax
  40025e:	e8 9d fd ff ff       	call   400000 <printc>
	for (cont = args_iter(&exec_entries, &i, &curr) ; cont ; cont = args_iter_next(&i, &curr)) {
  400263:	48 8d 55 b0          	lea    rdx,[rbp-0x50]
  400267:	48 8d 75 d0          	lea    rsi,[rbp-0x30]
  40026b:	48 8d 7d 90          	lea    rdi,[rbp-0x70]
  40026f:	e8 cc a8 00 00       	call   40ab40 <args_iter>
  400274:	85 c0                	test   eax,eax
  400276:	0f 84 ea 00 00 00    	je     400366 <calculate_initialization_schedule+0x146>
		compid_t id        = atoi(args_key(&curr, &keylen));
  40027c:	48 8d 75 8c          	lea    rsi,[rbp-0x74]
  400280:	48 8d 7d b0          	lea    rdi,[rbp-0x50]
  400284:	e8 57 a7 00 00       	call   40a9e0 <args_key>
  400289:	48 89 c7             	mov    rdi,rax
  40028c:	e8 1f 54 01 00       	call   4156b0 <atoi>
		char    *exec_type = args_value(&curr);
  400291:	48 8d 7d b0          	lea    rdi,[rbp-0x50]
		compid_t id        = atoi(args_key(&curr, &keylen));
  400295:	48 63 d8             	movsxd rbx,eax
		char    *exec_type = args_value(&curr);
  400298:	e8 a3 a7 00 00       	call   40aa40 <args_value>
  40029d:	48 89 c7             	mov    rdi,rax
		assert(exec_type);
  4002a0:	48 85 c0             	test   rax,rax
  4002a3:	0f 84 e3 00 00 00    	je     40038c <calculate_initialization_schedule+0x16c>
	} while (0)

static inline long
cos_spd_id(void)
{
	return __cosrt_comp_info.cos_this_spd_id;
  4002a9:	4c 8b 25 90 6d 02 00 	mov    r12,QWORD PTR [rip+0x26d90]        # 427040 <__cosrt_comp_info+0x40>
		assert(id != cos_compid());
  4002b0:	4c 39 e3             	cmp    rbx,r12
  4002b3:	0f 84 ef 00 00 00    	je     4003a8 <calculate_initialization_schedule+0x188>
		if (strcmp(exec_type, "init")) BUG();	/* TODO: no support for hierarchical scheduling yet */
  4002b9:	be a5 c3 41 00       	mov    esi,0x41c3a5
  4002be:	e8 cd 56 01 00       	call   415990 <strcmp>
  4002c3:	85 c0                	test   eax,eax
  4002c5:	0f 85 a5 00 00 00    	jne    400370 <calculate_initialization_schedule+0x150>
	printc("\tSched %ld: %ld is the %ldth component to initialize\n", cos_compid(), cid, init_schedule_off);
  4002cb:	48 8b 0d 6e dd 05 00 	mov    rcx,QWORD PTR [rip+0x5dd6e]        # 45e040 <init_schedule_off>
  4002d2:	48 89 da             	mov    rdx,rbx
  4002d5:	4c 89 e6             	mov    rsi,r12
  4002d8:	31 c0                	xor    eax,eax
  4002da:	bf c0 c3 41 00       	mov    edi,0x41c3c0
	assert(s->status == SCHEDINIT_FREE);
  4002df:	4c 8d 24 9b          	lea    r12,[rbx+rbx*4]
	printc("\tSched %ld: %ld is the %ldth component to initialize\n", cos_compid(), cid, init_schedule_off);
  4002e3:	e8 18 fd ff ff       	call   400000 <printc>
	init_schedule[init_schedule_off] = cid;
  4002e8:	48 8b 05 51 dd 05 00 	mov    rax,QWORD PTR [rip+0x5dd51]        # 45e040 <init_schedule_off>
  4002ef:	48 89 1c c5 40 de 45 	mov    QWORD PTR [rax*8+0x45de40],rbx
  4002f6:	00 
	init_schedule_off++;
  4002f7:	48 83 c0 01          	add    rax,0x1
	assert(s->status == SCHEDINIT_FREE);
  4002fb:	4a 8d 1c e5 40 d4 45 	lea    rbx,[r12*8+0x45d440]
  400302:	00 
	init_schedule_off++;
  400303:	48 89 05 36 dd 05 00 	mov    QWORD PTR [rip+0x5dd36],rax        # 45e040 <init_schedule_off>
	assert(s->status == SCHEDINIT_FREE);
  40030a:	8b 43 10             	mov    eax,DWORD PTR [rbx+0x10]
  40030d:	85 c0                	test   eax,eax
  40030f:	0f 85 af 00 00 00    	jne    4003c4 <calculate_initialization_schedule+0x1a4>
	*s = (struct schedinit_status) {
  400315:	66 0f ef c0          	pxor   xmm0,xmm0
  400319:	42 0f 11 04 e5 40 d4 	movups XMMWORD PTR [r12*8+0x45d440],xmm0
  400320:	45 00 
  400322:	0f 11 43 10          	movups XMMWORD PTR [rbx+0x10],xmm0
  400326:	48 c7 43 20 00 00 00 	mov    QWORD PTR [rbx+0x20],0x0
  40032d:	00 
  40032e:	c7 43 10 01 00 00 00 	mov    DWORD PTR [rbx+0x10],0x1
  400335:	48 c7 43 18 ff ff ff 	mov    QWORD PTR [rbx+0x18],0xffffffffffffffff
  40033c:	ff 
	simple_barrier_init(&s->barrier, init_parallelism());
  40033d:	e8 de 99 00 00       	call   409d20 <init_parallelism>
	for (cont = args_iter(&exec_entries, &i, &curr) ; cont ; cont = args_iter_next(&i, &curr)) {
  400342:	48 8d 75 b0          	lea    rsi,[rbp-0x50]
  400346:	48 8d 7d d0          	lea    rdi,[rbp-0x30]
}

static inline void
simple_barrier_init(struct simple_barrier *b, unsigned int ncores)
{
	*b = (struct simple_barrier) {
  40034a:	4a c7 04 e5 40 d4 45 	mov    QWORD PTR [r12*8+0x45d440],0x0
  400351:	00 00 00 00 00 
  400356:	89 43 08             	mov    DWORD PTR [rbx+0x8],eax
  400359:	e8 72 a7 00 00       	call   40aad0 <args_iter_next>
  40035e:	85 c0                	test   eax,eax
  400360:	0f 85 16 ff ff ff    	jne    40027c <calculate_initialization_schedule+0x5c>
}
  400366:	48 83 c4 70          	add    rsp,0x70
  40036a:	5b                   	pop    rbx
  40036b:	41 5c                	pop    r12
  40036d:	5d                   	pop    rbp
  40036e:	c3                   	ret    
  40036f:	90                   	nop
  400370:	be 11 00 00 00       	mov    esi,0x11
  400375:	bf aa c3 41 00       	mov    edi,0x41c3aa
  40037a:	e8 51 9d 00 00       	call   40a0d0 <cos_print_str>
		if (strcmp(exec_type, "init")) BUG();	/* TODO: no support for hierarchical scheduling yet */
  40037f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400386:	00 00 00 00 
  40038a:	0f 0b                	ud2    
  40038c:	be 24 00 00 00       	mov    esi,0x24
  400391:	bf 58 c3 41 00       	mov    edi,0x41c358
  400396:	e8 35 9d 00 00       	call   40a0d0 <cos_print_str>
		assert(exec_type);
  40039b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4003a2:	00 00 00 00 
  4003a6:	0f 0b                	ud2    
  4003a8:	be 24 00 00 00       	mov    esi,0x24
  4003ad:	bf 80 c3 41 00       	mov    edi,0x41c380
  4003b2:	e8 19 9d 00 00       	call   40a0d0 <cos_print_str>
		assert(id != cos_compid());
  4003b7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4003be:	00 00 00 00 
  4003c2:	0f 0b                	ud2    
  4003c4:	be 23 00 00 00       	mov    esi,0x23
  4003c9:	bf f8 c3 41 00       	mov    edi,0x41c3f8
  4003ce:	e8 fd 9c 00 00       	call   40a0d0 <cos_print_str>
	assert(s->status == SCHEDINIT_FREE);
  4003d3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4003da:	00 00 00 00 
  4003de:	0f 0b                	ud2    
  4003e0:	be 23 00 00 00       	mov    esi,0x23
  4003e5:	bf 00 c3 41 00       	mov    edi,0x41c300
  4003ea:	e8 e1 9c 00 00       	call   40a0d0 <cos_print_str>
	assert(!ret);
  4003ef:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4003f6:	00 00 00 00 
  4003fa:	0f 0b                	ud2    
  4003fc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000400400 <init_done>:
	while (1) ;
}

void
init_done(int parallel_init, init_main_t cont)
{
  400400:	f3 0f 1e fa          	endbr64 
  400404:	55                   	push   rbp
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  400405:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  400408:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  40040e:	48 89 e5             	mov    rbp,rsp
  400411:	41 54                	push   r12
  400413:	53                   	push   rbx
	return get_stk_data(INVTOKEN_OFFSET);
  400414:	48 8b b8 e8 1f 00 00 	mov    rdi,QWORD PTR [rax+0x1fe8]
	compid_t client = (compid_t)cos_inv_token();
	struct schedinit_status *s;

	s = &initialization_state[client];
	assert(s->status != SCHEDINIT_FREE);
  40041b:	48 8d 14 bf          	lea    rdx,[rdi+rdi*4]
  40041f:	48 c1 e2 03          	shl    rdx,0x3
  400423:	8b 82 50 d4 45 00    	mov    eax,DWORD PTR [rdx+0x45d450]
  400429:	85 c0                	test   eax,eax
  40042b:	0f 84 a3 00 00 00    	je     4004d4 <init_done+0xd4>
  400431:	89 f3                	mov    ebx,esi
  400433:	48 8d 8a 40 d4 45 00 	lea    rcx,[rdx+0x45d440]
  40043a:	31 f6                	xor    esi,esi
  40043c:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
  400443:	f0 48 0f b1 b2 58 d4 	lock cmpxchg QWORD PTR [rdx+0x45d458],rsi
  40044a:	45 00 
  40044c:	0f 94 c0             	sete   al

	/*
	 * `init_done` should not be called once initialization is
	 * completed. This is an error.
	 */
	if (s->status == SCHEDINIT_MAIN) {
  40044f:	8b 41 10             	mov    eax,DWORD PTR [rcx+0x10]
  400452:	83 f8 03             	cmp    eax,0x3
  400455:	0f 84 b1 00 00 00    	je     40050c <init_done+0x10c>

	/*
	 * This should *ONLY* happen for the initialization thread
	 * *after* it executes `cos_init`.
	 */
	if (s->status == SCHEDINIT_INITING) {
  40045b:	83 f8 01             	cmp    eax,0x1
  40045e:	74 68                	je     4004c8 <init_done+0xc8>
	assert(*barrier <= ncore);
  400460:	8b 71 08             	mov    esi,DWORD PTR [rcx+0x8]
  400463:	48 39 b2 40 d4 45 00 	cmp    QWORD PTR [rdx+0x45d440],rsi
  40046a:	0f 87 80 00 00 00    	ja     4004f0 <init_done+0xf0>
ps_faa(unsigned long *target, long inc)
{
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Warray-bounds"
/* GCC has bug of processing a warning(-Warray-bounds) and not get fixed, thus close the warning in this function */
        __asm__ __volatile__("lock " PS_FAA_STR
  400470:	b8 01 00 00 00       	mov    eax,0x1
  400475:	f0 48 0f c1 82 40 d4 	lock xadd QWORD PTR [rdx+0x45d440],rax
  40047c:	45 00 
                             : "+m" (*target), "+q" (inc)
                             : : "memory", "cc");
        return inc;
  40047e:	66 90                	xchg   ax,ax
	while (ps_load(barrier) < ncore) ;
  400480:	48 8b 01             	mov    rax,QWORD PTR [rcx]
  400483:	48 39 c6             	cmp    rsi,rax
  400486:	77 f8                	ja     400480 <init_done+0x80>
 	 * If this barrier is hit *after* the parallel initialization
	 * has finished, no blocking will occur as its count has
	 * already been hit.
	 */
	simple_barrier(&s->barrier);
	s->status = SCHEDINIT_MAIN;
  400488:	48 8d 04 bf          	lea    rax,[rdi+rdi*4]
  40048c:	4c 8d 24 c5 40 d4 45 	lea    r12,[rax*8+0x45d440]
  400493:	00 
  400494:	41 c7 44 24 10 03 00 	mov    DWORD PTR [r12+0x10],0x3
  40049b:	00 00 

	s->initialization_thds[cos_coreid()] = slm_thd_current_extern();
  40049d:	e8 9e 14 00 00       	call   401940 <slm_thd_current_extern>
  4004a2:	49 89 44 24 20       	mov    QWORD PTR [r12+0x20],rax
	extern int thd_block(void);
	thd_block(); 		/* block until initialization is completed */
  4004a7:	e8 04 1f 00 00       	call   4023b0 <thd_block>

 	/*
	 * After initialization, we're done with the parallel threads
	 * in some cases.
	 */
	if ((cos_coreid() != s->init_core && cont == INIT_MAIN_SINGLE) || cont == INIT_MAIN_NONE) {
  4004ac:	49 83 7c 24 18 00    	cmp    QWORD PTR [r12+0x18],0x0
  4004b2:	74 05                	je     4004b9 <init_done+0xb9>
  4004b4:	83 fb 01             	cmp    ebx,0x1
  4004b7:	74 53                	je     40050c <init_done+0x10c>
  4004b9:	85 db                	test   ebx,ebx
  4004bb:	74 4f                	je     40050c <init_done+0x10c>
	 * main execution. We'd expect the next API call here to be
	 * `init_exit`.
	 */

	return;
}
  4004bd:	5b                   	pop    rbx
  4004be:	41 5c                	pop    r12
  4004c0:	5d                   	pop    rbp
  4004c1:	c3                   	ret    
  4004c2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
		ps_store(&s->status, SCHEDINIT_PARINIT);
  4004c8:	c7 41 10 02 00 00 00 	mov    DWORD PTR [rcx+0x10],0x2
}
  4004cf:	5b                   	pop    rbx
  4004d0:	41 5c                	pop    r12
  4004d2:	5d                   	pop    rbp
  4004d3:	c3                   	ret    
  4004d4:	be 24 00 00 00       	mov    esi,0x24
  4004d9:	bf 20 c4 41 00       	mov    edi,0x41c420
  4004de:	e8 ed 9b 00 00       	call   40a0d0 <cos_print_str>
	assert(s->status != SCHEDINIT_FREE);
  4004e3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4004ea:	00 00 00 00 
  4004ee:	0f 0b                	ud2    
  4004f0:	be 5d 00 00 00       	mov    esi,0x5d
  4004f5:	bf 48 c4 41 00       	mov    edi,0x41c448
  4004fa:	e8 d1 9b 00 00       	call   40a0d0 <cos_print_str>
	assert(*barrier <= ncore);
  4004ff:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400506:	00 00 00 00 
  40050a:	0f 0b                	ud2    
		exit_init_thd();
  40050c:	e8 9f fb ff ff       	call   4000b0 <exit_init_thd>
  400511:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  400518:	00 00 00 00 
  40051c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000400520 <init_exit>:

void
init_exit(int retval)
{
  400520:	f3 0f 1e fa          	endbr64 
  400524:	55                   	push   rbp
  400525:	48 89 e5             	mov    rbp,rsp
	exit_init_thd();
  400528:	e8 83 fb ff ff       	call   4000b0 <exit_init_thd>
  40052d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000400530 <slm_idle_comp_initialization>:
	return;
}

void
slm_idle_comp_initialization(void)
{
  400530:	f3 0f 1e fa          	endbr64 
  400534:	55                   	push   rbp
	if (cos_coreid() == 0) printc("Scheduler %ld: Running initialization thread.\n", cos_compid());
  400535:	bf a8 c4 41 00       	mov    edi,0x41c4a8
  40053a:	31 c0                	xor    eax,eax
{
  40053c:	48 89 e5             	mov    rbp,rsp
  40053f:	41 56                	push   r14
  400541:	41 55                	push   r13
  400543:	41 54                	push   r12
  400545:	53                   	push   rbx
  400546:	31 db                	xor    ebx,ebx
  400548:	48 83 ec 10          	sub    rsp,0x10
	if (cos_coreid() == 0) printc("Scheduler %ld: Running initialization thread.\n", cos_compid());
  40054c:	48 8b 35 ed 6a 02 00 	mov    rsi,QWORD PTR [rip+0x26aed]        # 427040 <__cosrt_comp_info+0x40>
  400553:	e8 a8 fa ff ff       	call   400000 <printc>
	while (init_schedule_current != ps_load(&init_schedule_off)) {
  400558:	48 8b 05 e1 da 05 00 	mov    rax,QWORD PTR [rip+0x5dae1]        # 45e040 <init_schedule_off>
  40055f:	4c 8b 25 d2 c1 01 00 	mov    r12,QWORD PTR [rip+0x1c1d2]        # 41c738 <__unlock+0x608>
  400566:	48 85 c0             	test   rax,rax
  400569:	74 72                	je     4005dd <slm_idle_comp_initialization+0xad>
  40056b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		t = thd_alloc_in(client, 0, param, 1);
  400570:	31 f6                	xor    esi,esi
  400572:	b9 01 00 00 00       	mov    ecx,0x1
  400577:	48 8d 55 d8          	lea    rdx,[rbp-0x28]
		param[0] = sched_param_pack(SCHEDP_INIT, 0);
  40057b:	4c 89 65 d8          	mov    QWORD PTR [rbp-0x28],r12
		compid_t client = init_schedule[init_schedule_current];
  40057f:	4c 8b 2c dd 40 de 45 	mov    r13,QWORD PTR [rbx*8+0x45de40]
  400586:	00 
		t = thd_alloc_in(client, 0, param, 1);
  400587:	4c 89 ef             	mov    rdi,r13
  40058a:	e8 d1 47 00 00       	call   404d60 <thd_alloc_in>
		assert(t);
  40058f:	48 85 c0             	test   rax,rax
  400592:	0f 84 f4 00 00 00    	je     40068c <slm_idle_comp_initialization+0x15c>
		if (cos_coreid() == 0)	printc("\tScheduler %ld: initializing component %ld with thread %ld.\n", cos_compid(), client, t->tid);
  400598:	48 8b 48 18          	mov    rcx,QWORD PTR [rax+0x18]
  40059c:	48 8b 35 9d 6a 02 00 	mov    rsi,QWORD PTR [rip+0x26a9d]        # 427040 <__cosrt_comp_info+0x40>
  4005a3:	4c 89 ea             	mov    rdx,r13
  4005a6:	31 c0                	xor    eax,eax
  4005a8:	bf 30 c5 41 00       	mov    edi,0x41c530
		init_schedule_current++;
  4005ad:	48 83 c3 01          	add    rbx,0x1
		if (cos_coreid() == 0)	printc("\tScheduler %ld: initializing component %ld with thread %ld.\n", cos_compid(), client, t->tid);
  4005b1:	e8 4a fa ff ff       	call   400000 <printc>
		while (ps_load(&n->initialization_thds[cos_coreid()]) == NULL) ;
  4005b6:	4b 8d 44 ad 00       	lea    rax,[r13+r13*4+0x0]
  4005bb:	48 8d 14 c5 40 d4 45 	lea    rdx,[rax*8+0x45d440]
  4005c2:	00 
  4005c3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  4005c8:	48 8b 42 20          	mov    rax,QWORD PTR [rdx+0x20]
  4005cc:	48 85 c0             	test   rax,rax
  4005cf:	74 f7                	je     4005c8 <slm_idle_comp_initialization+0x98>
	while (init_schedule_current != ps_load(&init_schedule_off)) {
  4005d1:	48 8b 05 68 da 05 00 	mov    rax,QWORD PTR [rip+0x5da68]        # 45e040 <init_schedule_off>
  4005d8:	48 39 c3             	cmp    rbx,rax
  4005db:	75 93                	jne    400570 <slm_idle_comp_initialization+0x40>
	if (cos_coreid() == 0) printc("Scheduler %ld, initialization completed.\n", cos_compid());
  4005dd:	48 8b 35 5c 6a 02 00 	mov    rsi,QWORD PTR [rip+0x26a5c]        # 427040 <__cosrt_comp_info+0x40>
  4005e4:	bf d8 c4 41 00       	mov    edi,0x41c4d8
  4005e9:	31 c0                	xor    eax,eax
  4005eb:	e8 10 fa ff ff       	call   400000 <printc>
	slm_cs_enter(slm_thd_special(), SLM_CS_NONE);
  4005f0:	e8 db 30 01 00       	call   4136d0 <slm_thd_special>
  4005f5:	48 89 c3             	mov    rbx,rax
  4005f8:	48 85 c0             	test   rax,rax
  4005fb:	0f 84 ab 01 00 00    	je     4007ac <slm_idle_comp_initialization+0x27c>
		tok    = cos_sched_sync();
  400601:	e8 fa 0c 01 00       	call   411300 <cos_sched_sync>
  400606:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  400609:	48 8b 05 b0 18 1a 00 	mov    rax,QWORD PTR [rip+0x1a18b0]        # 5a1ec0 <__slm_global>
		if (unlikely(owner)) {
  400610:	48 89 c1             	mov    rcx,rax
  400613:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  400617:	0f 85 53 01 00 00    	jne    400770 <slm_idle_comp_initialization+0x240>
        __asm__ __volatile__("lock " PS_CAS_STR
  40061d:	f0 48 0f b1 1d 9a 18 	lock cmpxchg QWORD PTR [rip+0x1a189a],rbx        # 5a1ec0 <__slm_global>
  400624:	1a 00 
  400626:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  400629:	84 c0                	test   al,al
  40062b:	74 d4                	je     400601 <slm_idle_comp_initialization+0xd1>
	for (i = 0; i < ps_load(&init_schedule_off); i++) {
  40062d:	48 8b 05 0c da 05 00 	mov    rax,QWORD PTR [rip+0x5da0c]        # 45e040 <init_schedule_off>
  400634:	31 db                	xor    ebx,ebx
  400636:	48 85 c0             	test   rax,rax
  400639:	75 1c                	jne    400657 <slm_idle_comp_initialization+0x127>
  40063b:	eb 6b                	jmp    4006a8 <slm_idle_comp_initialization+0x178>
  40063d:	0f 1f 00             	nop    DWORD PTR [rax]
		slm_thd_wakeup(t, 0);
  400640:	31 f6                	xor    esi,esi
	for (i = 0; i < ps_load(&init_schedule_off); i++) {
  400642:	48 83 c3 01          	add    rbx,0x1
		slm_thd_wakeup(t, 0);
  400646:	e8 e5 37 01 00       	call   413e30 <slm_thd_wakeup>
	for (i = 0; i < ps_load(&init_schedule_off); i++) {
  40064b:	48 8b 05 ee d9 05 00 	mov    rax,QWORD PTR [rip+0x5d9ee]        # 45e040 <init_schedule_off>
  400652:	48 39 c3             	cmp    rbx,rax
  400655:	73 51                	jae    4006a8 <slm_idle_comp_initialization+0x178>
		t = initialization_state[client].initialization_thds[cos_coreid()];
  400657:	48 8b 04 dd 40 de 45 	mov    rax,QWORD PTR [rbx*8+0x45de40]
  40065e:	00 
  40065f:	48 8d 04 80          	lea    rax,[rax+rax*4]
  400663:	48 8b 3c c5 60 d4 45 	mov    rdi,QWORD PTR [rax*8+0x45d460]
  40066a:	00 
		assert(t != NULL);
  40066b:	48 85 ff             	test   rdi,rdi
  40066e:	75 d0                	jne    400640 <slm_idle_comp_initialization+0x110>
  400670:	be 24 00 00 00       	mov    esi,0x24
  400675:	bf 70 c5 41 00       	mov    edi,0x41c570
  40067a:	e8 51 9a 00 00       	call   40a0d0 <cos_print_str>
  40067f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400686:	00 00 00 00 
  40068a:	0f 0b                	ud2    
  40068c:	be 24 00 00 00       	mov    esi,0x24
  400691:	bf 08 c5 41 00       	mov    edi,0x41c508
  400696:	e8 35 9a 00 00       	call   40a0d0 <cos_print_str>
		assert(t);
  40069b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4006a2:	00 00 00 00 
  4006a6:	0f 0b                	ud2    
	slm_cs_exit_reschedule(slm_thd_special(), SLM_CS_NONE);
  4006a8:	e8 23 30 01 00       	call   4136d0 <slm_thd_special>
		}
	}

	/* Make a policy decision! */
	t = slm_sched_schedule();
	if (unlikely(!t)) t = &g->idle_thd;
  4006ad:	41 be 40 1f 5a 00    	mov    r14d,0x5a1f40
  4006b3:	49 89 c5             	mov    r13,rax
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  4006b6:	e8 a5 b1 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	tok  = cos_sched_sync();
  4006bb:	e8 40 0c 01 00       	call   411300 <cos_sched_sync>
  4006c0:	41 89 c4             	mov    r12d,eax
	t = slm_sched_schedule();
  4006c3:	e8 d8 10 00 00       	call   4017a0 <slm_sched_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  4006c8:	48 85 c0             	test   rax,rax
	t = slm_sched_schedule();
  4006cb:	48 89 c3             	mov    rbx,rax
	if (unlikely(!t)) t = &g->idle_thd;
  4006ce:	49 0f 44 de          	cmove  rbx,r14
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  4006d2:	8b 43 04             	mov    eax,DWORD PTR [rbx+0x4]
  4006d5:	83 e8 02             	sub    eax,0x2

	assert(slm_state_is_runnable(t->state));
  4006d8:	83 f8 01             	cmp    eax,0x1
  4006db:	76 1b                	jbe    4006f8 <slm_idle_comp_initialization+0x1c8>
  4006dd:	e9 e6 00 00 00       	jmp    4007c8 <slm_idle_comp_initialization+0x298>
  4006e2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4006e8:	f0 48 0f b1 15 cf 17 	lock cmpxchg QWORD PTR [rip+0x1a17cf],rdx        # 5a1ec0 <__slm_global>
  4006ef:	1a 00 
  4006f1:	0f 94 c0             	sete   al
	while (ret != 0) {
  4006f4:	84 c0                	test   al,al
  4006f6:	75 2e                	jne    400726 <slm_idle_comp_initialization+0x1f6>
		tok    = cos_sched_sync();
  4006f8:	e8 03 0c 01 00       	call   411300 <cos_sched_sync>
  4006fd:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4006ff:	48 8b 05 ba 17 1a 00 	mov    rax,QWORD PTR [rip+0x1a17ba]        # 5a1ec0 <__slm_global>
		if (unlikely(contention)) {
  400706:	48 89 c2             	mov    rdx,rax
  400709:	83 e2 01             	and    edx,0x1
  40070c:	74 da                	je     4006e8 <slm_idle_comp_initialization+0x1b8>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  40070e:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  400711:	48 89 c2             	mov    rdx,rax
  400714:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  400719:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  40071d:	e8 3e 31 01 00       	call   413860 <slm_cs_exit_contention>
  400722:	85 c0                	test   eax,eax
  400724:	75 d2                	jne    4006f8 <slm_idle_comp_initialization+0x1c8>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  400726:	e8 35 b1 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  40072b:	8b 03                	mov    eax,DWORD PTR [rbx]
	timeout = g->timeout_next;
  40072d:	48 8b 35 94 18 1a 00 	mov    rsi,QWORD PTR [rip+0x1a1894]        # 5a1fc8 <__slm_global+0x108>
	prio = inherit_prio ? curr->priority : t->priority;
  400734:	4c 8b 53 30          	mov    r10,QWORD PTR [rbx+0x30]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  400738:	a8 0b                	test   al,0xb
  40073a:	0f 85 da 00 00 00    	jne    40081a <slm_idle_comp_initialization+0x2ea>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  400740:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  400744:	48 89 f2             	mov    rdx,rsi
  400747:	44 89 e1             	mov    ecx,r12d
  40074a:	4c 89 d6             	mov    rsi,r10
  40074d:	e8 0e c0 00 00       	call   40c760 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  400752:	83 f8 ff             	cmp    eax,0xffffffff
  400755:	0f 84 89 00 00 00    	je     4007e4 <slm_idle_comp_initialization+0x2b4>
	slm_cs_exit(NULL, flags);

	ret = slm_thd_activate(curr, t, tok, 0);
	
	if (unlikely(ret != 0)) {
  40075b:	85 c0                	test   eax,eax
  40075d:	0f 85 01 01 00 00    	jne    400864 <slm_idle_comp_initialization+0x334>
	slm_comp_init_loop();
}
  400763:	48 83 c4 10          	add    rsp,0x10
  400767:	5b                   	pop    rbx
  400768:	41 5c                	pop    r12
  40076a:	41 5d                	pop    r13
  40076c:	41 5e                	pop    r14
  40076e:	5d                   	pop    rbp
  40076f:	c3                   	ret    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  400770:	41 89 c0             	mov    r8d,eax
  400773:	48 89 da             	mov    rdx,rbx
  400776:	48 89 c6             	mov    rsi,rax
  400779:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  40077e:	41 83 e0 01          	and    r8d,0x1
  400782:	e8 89 30 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  400787:	83 f8 f0             	cmp    eax,0xfffffff0
  40078a:	0f 85 71 fe ff ff    	jne    400601 <slm_idle_comp_initialization+0xd1>
  400790:	be 59 00 00 00       	mov    esi,0x59
  400795:	bf 78 c2 41 00       	mov    edi,0x41c278
  40079a:	e8 31 99 00 00       	call   40a0d0 <cos_print_str>
  40079f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4007a6:	00 00 00 00 
  4007aa:	0f 0b                	ud2    
  4007ac:	be 59 00 00 00       	mov    esi,0x59
  4007b1:	bf 18 c2 41 00       	mov    edi,0x41c218
  4007b6:	e8 15 99 00 00       	call   40a0d0 <cos_print_str>
	assert(current);
  4007bb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4007c2:	00 00 00 00 
  4007c6:	0f 0b                	ud2    
  4007c8:	be 61 00 00 00       	mov    esi,0x61
  4007cd:	bf 98 c5 41 00       	mov    edi,0x41c598
  4007d2:	e8 f9 98 00 00       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  4007d7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4007de:	00 00 00 00 
  4007e2:	0f 0b                	ud2    
	return t != &g->idle_thd && t != &g->sched_thd;
  4007e4:	48 81 fb 40 1f 5a 00 	cmp    rbx,0x5a1f40
  4007eb:	0f 84 d3 00 00 00    	je     4008c4 <slm_idle_comp_initialization+0x394>
  4007f1:	48 81 fb c8 1e 5a 00 	cmp    rbx,0x5a1ec8
  4007f8:	0f 84 c6 00 00 00    	je     4008c4 <slm_idle_comp_initialization+0x394>
  4007fe:	be 61 00 00 00       	mov    esi,0x61
  400803:	bf 00 c6 41 00       	mov    edi,0x41c600
  400808:	e8 c3 98 00 00       	call   40a0d0 <cos_print_str>
		/* Assuming only the single tcap with infinite budget...should not get EPERM */
		assert(ret != -EPERM);
  40080d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400814:	00 00 00 00 
  400818:	0f 0b                	ud2    
	timeout = g->timeout_next;
  40081a:	48 89 f1             	mov    rcx,rsi
		if (t == &g->sched_thd) {
  40081d:	48 81 fb c8 1e 5a 00 	cmp    rbx,0x5a1ec8
  400824:	0f 84 8f 00 00 00    	je     4008b9 <slm_idle_comp_initialization+0x389>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  40082a:	a8 02                	test   al,0x2
  40082c:	0f 85 b5 00 00 00    	jne    4008e7 <slm_idle_comp_initialization+0x3b7>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  400832:	48 89 ce             	mov    rsi,rcx
  400835:	a8 01                	test   al,0x1
  400837:	0f 84 03 ff ff ff    	je     400740 <slm_idle_comp_initialization+0x210>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  40083d:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
  400841:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  400845:	45 89 e1             	mov    r9d,r12d
  400848:	4c 89 d2             	mov    rdx,r10
  40084b:	4c 8b 05 96 16 1a 00 	mov    r8,QWORD PTR [rip+0x1a1696]        # 5a1ee8 <__slm_global+0x28>
  400852:	e8 c9 0a 01 00       	call   411320 <cos_switch>
	if (unlikely(ret != 0)) {
  400857:	85 c0                	test   eax,eax
  400859:	0f 84 04 ff ff ff    	je     400763 <slm_idle_comp_initialization+0x233>
		assert(ret != -EPERM);
  40085f:	83 f8 ff             	cmp    eax,0xffffffff
  400862:	74 9a                	je     4007fe <slm_idle_comp_initialization+0x2ce>
		assert(ret != -EINVAL);
  400864:	83 f8 ea             	cmp    eax,0xffffffea
  400867:	0f 84 d0 00 00 00    	je     40093d <slm_idle_comp_initialization+0x40d>

		/*
		 * If the slm_thd_activate returns -EBUSY, this means we are trying to switch to the scheduler thread,
		 * and scheduler thread still has pending events. Directly return to process pending events.
		 */
		if (ret == -EBUSY) return ret;
  40086d:	83 f8 f0             	cmp    eax,0xfffffff0
  400870:	0f 84 ed fe ff ff    	je     400763 <slm_idle_comp_initialization+0x233>
		/* If the slm_thd_activate returns -EAGAIN, this means this scheduling token is outdated, try again */
		assert(ret == -EAGAIN);
  400876:	83 f8 f5             	cmp    eax,0xfffffff5
  400879:	0f 85 a2 00 00 00    	jne    400921 <slm_idle_comp_initialization+0x3f1>
  40087f:	4d 85 ed             	test   r13,r13
  400882:	0f 84 24 ff ff ff    	je     4007ac <slm_idle_comp_initialization+0x27c>
		tok    = cos_sched_sync();
  400888:	e8 73 0a 01 00       	call   411300 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  40088d:	48 8b 35 2c 16 1a 00 	mov    rsi,QWORD PTR [rip+0x1a162c]        # 5a1ec0 <__slm_global>
  400894:	41 89 c1             	mov    r9d,eax
		if (unlikely(owner)) {
  400897:	48 89 f1             	mov    rcx,rsi
  40089a:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  40089e:	75 5f                	jne    4008ff <slm_idle_comp_initialization+0x3cf>
  4008a0:	48 89 f0             	mov    rax,rsi
  4008a3:	f0 4c 0f b1 2d 14 16 	lock cmpxchg QWORD PTR [rip+0x1a1614],r13        # 5a1ec0 <__slm_global>
  4008aa:	1a 00 
  4008ac:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4008af:	84 c0                	test   al,al
  4008b1:	0f 85 04 fe ff ff    	jne    4006bb <slm_idle_comp_initialization+0x18b>
  4008b7:	eb cf                	jmp    400888 <slm_idle_comp_initialization+0x358>
			prio    = curr->priority;
  4008b9:	4d 8b 55 30          	mov    r10,QWORD PTR [r13+0x30]
			timeout = TCAP_TIME_NIL;
  4008bd:	31 c9                	xor    ecx,ecx
  4008bf:	e9 66 ff ff ff       	jmp    40082a <slm_idle_comp_initialization+0x2fa>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  4008c4:	49 8b 55 30          	mov    rdx,QWORD PTR [r13+0x30]
  4008c8:	4c 8b 05 19 16 1a 00 	mov    r8,QWORD PTR [rip+0x1a1619]        # 5a1ee8 <__slm_global+0x28>
  4008cf:	45 89 e1             	mov    r9d,r12d
  4008d2:	31 c9                	xor    ecx,ecx
  4008d4:	48 8b 3d fd 15 1a 00 	mov    rdi,QWORD PTR [rip+0x1a15fd]        # 5a1ed8 <__slm_global+0x18>
  4008db:	31 f6                	xor    esi,esi
  4008dd:	e8 3e 0a 01 00       	call   411320 <cos_switch>
  4008e2:	e9 70 ff ff ff       	jmp    400857 <slm_idle_comp_initialization+0x327>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  4008e7:	48 8b 7b 28          	mov    rdi,QWORD PTR [rbx+0x28]
  4008eb:	48 8b 15 f6 15 1a 00 	mov    rdx,QWORD PTR [rip+0x1a15f6]        # 5a1ee8 <__slm_global+0x28>
  4008f2:	44 89 e1             	mov    ecx,r12d
  4008f5:	e8 96 0a 01 00       	call   411390 <cos_sched_asnd>
  4008fa:	e9 58 ff ff ff       	jmp    400857 <slm_idle_comp_initialization+0x327>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  4008ff:	41 89 f0             	mov    r8d,esi
  400902:	4c 89 ea             	mov    rdx,r13
  400905:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  40090a:	41 83 e0 01          	and    r8d,0x1
  40090e:	e8 fd 2e 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  400913:	83 f8 f0             	cmp    eax,0xfffffff0
  400916:	0f 85 6c ff ff ff    	jne    400888 <slm_idle_comp_initialization+0x358>
  40091c:	e9 6f fe ff ff       	jmp    400790 <slm_idle_comp_initialization+0x260>
  400921:	be 61 00 00 00       	mov    esi,0x61
  400926:	bf d0 c6 41 00       	mov    edi,0x41c6d0
  40092b:	e8 a0 97 00 00       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  400930:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400937:	00 00 00 00 
  40093b:	0f 0b                	ud2    
  40093d:	be 61 00 00 00       	mov    esi,0x61
  400942:	bf 68 c6 41 00       	mov    edi,0x41c668
  400947:	e8 84 97 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  40094c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400953:	00 00 00 00 
  400957:	0f 0b                	ud2    
  400959:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000400960 <printc.constprop.0>:
printc(char *fmt, ...)
  400960:	55                   	push   rbp
  400961:	48 89 e5             	mov    rbp,rsp
  400964:	48 81 ec 90 01 00 00 	sub    rsp,0x190
  40096b:	48 89 b5 58 ff ff ff 	mov    QWORD PTR [rbp-0xa8],rsi
  400972:	48 89 95 60 ff ff ff 	mov    QWORD PTR [rbp-0xa0],rdx
  400979:	48 89 8d 68 ff ff ff 	mov    QWORD PTR [rbp-0x98],rcx
  400980:	4c 89 85 70 ff ff ff 	mov    QWORD PTR [rbp-0x90],r8
  400987:	4c 89 8d 78 ff ff ff 	mov    QWORD PTR [rbp-0x88],r9
  40098e:	84 c0                	test   al,al
  400990:	74 20                	je     4009b2 <printc.constprop.0+0x52>
  400992:	0f 29 45 80          	movaps XMMWORD PTR [rbp-0x80],xmm0
  400996:	0f 29 4d 90          	movaps XMMWORD PTR [rbp-0x70],xmm1
  40099a:	0f 29 55 a0          	movaps XMMWORD PTR [rbp-0x60],xmm2
  40099e:	0f 29 5d b0          	movaps XMMWORD PTR [rbp-0x50],xmm3
  4009a2:	0f 29 65 c0          	movaps XMMWORD PTR [rbp-0x40],xmm4
  4009a6:	0f 29 6d d0          	movaps XMMWORD PTR [rbp-0x30],xmm5
  4009aa:	0f 29 75 e0          	movaps XMMWORD PTR [rbp-0x20],xmm6
  4009ae:	0f 29 7d f0          	movaps XMMWORD PTR [rbp-0x10],xmm7
	va_start(arg_ptr, fmt);
  4009b2:	48 8d 45 10          	lea    rax,[rbp+0x10]
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  4009b6:	ba 40 c7 41 00       	mov    edx,0x41c740
  4009bb:	be b4 00 00 00       	mov    esi,0xb4
	va_start(arg_ptr, fmt);
  4009c0:	c7 85 78 fe ff ff 08 	mov    DWORD PTR [rbp-0x188],0x8
  4009c7:	00 00 00 
  4009ca:	48 89 85 80 fe ff ff 	mov    QWORD PTR [rbp-0x180],rax
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  4009d1:	48 8d 8d 78 fe ff ff 	lea    rcx,[rbp-0x188]
	va_start(arg_ptr, fmt);
  4009d8:	48 8d 85 50 ff ff ff 	lea    rax,[rbp-0xb0]
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  4009df:	48 8d bd 90 fe ff ff 	lea    rdi,[rbp-0x170]
	va_start(arg_ptr, fmt);
  4009e6:	48 89 85 88 fe ff ff 	mov    QWORD PTR [rbp-0x178],rax
  4009ed:	c7 85 7c fe ff ff 30 	mov    DWORD PTR [rbp-0x184],0x30
  4009f4:	00 00 00 
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  4009f7:	e8 64 4b 01 00       	call   415560 <vsnprintf>
	ret = cos_print_str(s, ret);
  4009fc:	48 8d bd 90 fe ff ff 	lea    rdi,[rbp-0x170]
  400a03:	be 1b 00 00 00       	mov    esi,0x1b
  400a08:	e8 c3 96 00 00       	call   40a0d0 <cos_print_str>
}
  400a0d:	c9                   	leave  
  400a0e:	c3                   	ret    
  400a0f:	90                   	nop

0000000000400a10 <slm_ipi_process>:
	goto done;
}

void
slm_ipi_process(void *d)
{
  400a10:	f3 0f 1e fa          	endbr64 
  400a14:	55                   	push   rbp
	int rcvd, ret;
	struct slm_ipi_percore *ipi_data = slm_ipi_percore_get(cos_cpuid());
  400a15:	31 ff                	xor    edi,edi
{
  400a17:	48 89 e5             	mov    rbp,rsp
  400a1a:	41 55                	push   r13
  400a1c:	41 54                	push   r12
  400a1e:	53                   	push   rbx
  400a1f:	48 83 ec 18          	sub    rsp,0x18
	struct slm_ipi_percore *ipi_data = slm_ipi_percore_get(cos_cpuid());
  400a23:	e8 88 2c 01 00       	call   4136b0 <slm_ipi_percore_get>
	struct slm_ipi_thd     *r        = &ipi_data->ipi_thd;
	struct slm_ipi_event    event    = { 0 };
  400a28:	48 c7 45 d8 00 00 00 	mov    QWORD PTR [rbp-0x28],0x0
  400a2f:	00 
	struct slm_ipi_percore *ipi_data = slm_ipi_percore_get(cos_cpuid());
  400a30:	49 89 c4             	mov    r12,rax
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  400a33:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  400a36:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  400a3c:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  400a43:	48 85 c0             	test   rax,rax
  400a46:	0f 84 c0 01 00 00    	je     400c0c <slm_ipi_process+0x1fc>
  400a4c:	83 e8 01             	sub    eax,0x1
  400a4f:	83 f8 18             	cmp    eax,0x18
  400a52:	0f 87 b4 01 00 00    	ja     400c0c <slm_ipi_process+0x1fc>
  400a58:	48 8b 14 c5 00 e7 45 	mov    rdx,QWORD PTR [rax*8+0x45e700]
  400a5f:	00 
  400a60:	31 db                	xor    ebx,ebx
}

static inline int
ss_state_is_allocated(ss_state_t state)
{
	return ((state & ~1) != 0) && ((state & 1) == SS_STATE_ALLOC);
  400a62:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  400a69:	0f 85 65 01 00 00    	jne    400bd4 <slm_ipi_process+0x1c4>
  400a6f:	90                   	nop
	struct slm_thd         *current  = slm_thd_current();
	struct slm_thd         *thd;

	while (1) {
		cos_rcv(r->rcv, RCV_ALL_PENDING, &rcvd);
  400a70:	49 8b 3c 24          	mov    rdi,QWORD PTR [r12]
  400a74:	48 8d 55 d4          	lea    rdx,[rbp-0x2c]
  400a78:	be 02 00 00 00       	mov    esi,0x2
  400a7d:	e8 7e 0a 01 00       	call   411500 <cos_rcv>

		while (!slm_ipi_event_empty(cos_cpuid())) {
  400a82:	31 ff                	xor    edi,edi
  400a84:	e8 f7 2b 01 00       	call   413680 <slm_ipi_event_empty>
  400a89:	85 c0                	test   eax,eax
  400a8b:	75 e3                	jne    400a70 <slm_ipi_process+0x60>
			slm_ipi_event_dequeue(&event, cos_cpuid());
  400a8d:	31 f6                	xor    esi,esi
  400a8f:	48 8d 7d d8          	lea    rdi,[rbp-0x28]
  400a93:	e8 88 2b 01 00       	call   413620 <slm_ipi_event_dequeue>
	return &ss_thd_get(id)->thd;
  400a98:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  400a9c:	85 c0                	test   eax,eax
  400a9e:	0f 84 cc 00 00 00    	je     400b70 <slm_ipi_process+0x160>
  400aa4:	83 e8 01             	sub    eax,0x1
  400aa7:	83 f8 18             	cmp    eax,0x18
  400aaa:	0f 87 c0 00 00 00    	ja     400b70 <slm_ipi_process+0x160>
  400ab0:	48 8b 14 c5 00 e7 45 	mov    rdx,QWORD PTR [rax*8+0x45e700]
  400ab7:	00 
  400ab8:	45 31 ed             	xor    r13d,r13d
  400abb:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  400ac2:	74 18                	je     400adc <slm_ipi_process+0xcc>
  400ac4:	83 e2 01             	and    edx,0x1
  400ac7:	75 13                	jne    400adc <slm_ipi_process+0xcc>
  400ac9:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  400acd:	4c 8d 2c 50          	lea    r13,[rax+rdx*2]
  400ad1:	49 c1 e5 04          	shl    r13,0x4
  400ad5:	49 81 c5 c8 e7 45 00 	add    r13,0x45e7c8
	assert(current);
  400adc:	48 85 db             	test   rbx,rbx
  400adf:	0f 84 97 00 00 00    	je     400b7c <slm_ipi_process+0x16c>
		tok    = cos_sched_sync();
  400ae5:	e8 16 08 01 00       	call   411300 <cos_sched_sync>
  400aea:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  400aed:	48 8b 05 cc 13 1a 00 	mov    rax,QWORD PTR [rip+0x1a13cc]        # 5a1ec0 <__slm_global>
		if (unlikely(owner)) {
  400af4:	48 89 c1             	mov    rcx,rax
  400af7:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  400afb:	0f 85 97 00 00 00    	jne    400b98 <slm_ipi_process+0x188>
  400b01:	f0 48 0f b1 1d b6 13 	lock cmpxchg QWORD PTR [rip+0x1a13b6],rbx        # 5a1ec0 <__slm_global>
  400b08:	1a 00 
  400b0a:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  400b0d:	84 c0                	test   al,al
  400b0f:	74 d4                	je     400ae5 <slm_ipi_process+0xd5>

			thd = slm_thd_static_cm_lookup(event.tid);
			slm_cs_enter(current, SLM_CS_NONE);
			ret = slm_thd_wakeup(thd, 0);
  400b11:	31 f6                	xor    esi,esi
  400b13:	4c 89 ef             	mov    rdi,r13
  400b16:	e8 15 33 01 00       	call   413e30 <slm_thd_wakeup>
			/*
			 * Return "0" means the thread is woken up in this call.
			 * Return "1" means the thread is already `RUNNABLE`.
			 */
			assert(ret == 0 || ret == 1);
  400b1b:	83 f8 01             	cmp    eax,0x1
  400b1e:	76 1c                	jbe    400b3c <slm_ipi_process+0x12c>
  400b20:	e9 cb 00 00 00       	jmp    400bf0 <slm_ipi_process+0x1e0>
  400b25:	0f 1f 00             	nop    DWORD PTR [rax]
  400b28:	f0 48 0f b1 15 8f 13 	lock cmpxchg QWORD PTR [rip+0x1a138f],rdx        # 5a1ec0 <__slm_global>
  400b2f:	1a 00 
  400b31:	0f 94 c0             	sete   al
	while (ret != 0) {
  400b34:	84 c0                	test   al,al
  400b36:	0f 85 46 ff ff ff    	jne    400a82 <slm_ipi_process+0x72>
		tok    = cos_sched_sync();
  400b3c:	e8 bf 07 01 00       	call   411300 <cos_sched_sync>
  400b41:	89 c1                	mov    ecx,eax
  400b43:	48 8b 05 76 13 1a 00 	mov    rax,QWORD PTR [rip+0x1a1376]        # 5a1ec0 <__slm_global>
		if (unlikely(contention)) {
  400b4a:	48 89 c2             	mov    rdx,rax
  400b4d:	83 e2 01             	and    edx,0x1
  400b50:	74 d6                	je     400b28 <slm_ipi_process+0x118>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  400b52:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  400b55:	48 89 c2             	mov    rdx,rax
  400b58:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  400b5d:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  400b61:	e8 fa 2c 01 00       	call   413860 <slm_cs_exit_contention>
  400b66:	85 c0                	test   eax,eax
  400b68:	0f 84 14 ff ff ff    	je     400a82 <slm_ipi_process+0x72>
  400b6e:	eb cc                	jmp    400b3c <slm_ipi_process+0x12c>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  400b70:	45 31 ed             	xor    r13d,r13d
	assert(current);
  400b73:	48 85 db             	test   rbx,rbx
  400b76:	0f 85 69 ff ff ff    	jne    400ae5 <slm_ipi_process+0xd5>
	return cos_print_str(s, strlen(s));
  400b7c:	be 59 00 00 00       	mov    esi,0x59
  400b81:	bf 60 c7 41 00       	mov    edi,0x41c760
  400b86:	e8 45 95 00 00       	call   40a0d0 <cos_print_str>
  400b8b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400b92:	00 00 00 00 
  400b96:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  400b98:	41 89 c0             	mov    r8d,eax
  400b9b:	48 89 da             	mov    rdx,rbx
  400b9e:	48 89 c6             	mov    rsi,rax
  400ba1:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  400ba6:	41 83 e0 01          	and    r8d,0x1
  400baa:	e8 61 2c 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  400baf:	83 f8 f0             	cmp    eax,0xfffffff0
  400bb2:	0f 85 2d ff ff ff    	jne    400ae5 <slm_ipi_process+0xd5>
  400bb8:	be 59 00 00 00       	mov    esi,0x59
  400bbd:	bf c0 c7 41 00       	mov    edi,0x41c7c0
  400bc2:	e8 09 95 00 00       	call   40a0d0 <cos_print_str>
  400bc7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400bce:	00 00 00 00 
  400bd2:	0f 0b                	ud2    
  400bd4:	80 e2 01             	and    dl,0x1
  400bd7:	0f 85 93 fe ff ff    	jne    400a70 <slm_ipi_process+0x60>
  400bdd:	48 69 c0 b0 00 00 00 	imul   rax,rax,0xb0
  400be4:	48 8d 98 c8 e7 45 00 	lea    rbx,[rax+0x45e7c8]
  400beb:	e9 80 fe ff ff       	jmp    400a70 <slm_ipi_process+0x60>
  400bf0:	be 24 00 00 00       	mov    esi,0x24
  400bf5:	bf 20 c8 41 00       	mov    edi,0x41c820
  400bfa:	e8 d1 94 00 00       	call   40a0d0 <cos_print_str>
			assert(ret == 0 || ret == 1);
  400bff:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400c06:	00 00 00 00 
  400c0a:	0f 0b                	ud2    
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  400c0c:	31 db                	xor    ebx,ebx
  400c0e:	e9 5d fe ff ff       	jmp    400a70 <slm_ipi_process+0x60>
  400c13:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  400c1a:	00 00 00 00 
  400c1e:	66 90                	xchg   ax,ax

0000000000400c20 <slm_blkpt_alloc>:
	return &__blkpts[id-1];
}

sched_blkpt_id_t
slm_blkpt_alloc(struct slm_thd *current)
{
  400c20:	f3 0f 1e fa          	endbr64 
  400c24:	55                   	push   rbp
  400c25:	48 89 e5             	mov    rbp,rsp
  400c28:	41 54                	push   r12
  400c2a:	49 89 fc             	mov    r12,rdi
  400c2d:	48 83 ec 08          	sub    rsp,0x8
	assert(current);
  400c31:	48 85 ff             	test   rdi,rdi
  400c34:	0f 84 12 01 00 00    	je     400d4c <slm_blkpt_alloc+0x12c>
		tok    = cos_sched_sync();
  400c3a:	e8 c1 06 01 00       	call   411300 <cos_sched_sync>
  400c3f:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  400c42:	48 8b 05 77 12 1a 00 	mov    rax,QWORD PTR [rip+0x1a1277]        # 5a1ec0 <__slm_global>
		if (unlikely(owner)) {
  400c49:	48 89 c1             	mov    rcx,rax
  400c4c:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  400c50:	0f 85 ba 00 00 00    	jne    400d10 <slm_blkpt_alloc+0xf0>
  400c56:	f0 4c 0f b1 25 61 12 	lock cmpxchg QWORD PTR [rip+0x1a1261],r12        # 5a1ec0 <__slm_global>
  400c5d:	1a 00 
  400c5f:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  400c62:	84 c0                	test   al,al
  400c64:	74 d4                	je     400c3a <slm_blkpt_alloc+0x1a>
	struct blkpt_mem *m;
	sched_blkpt_id_t ret = SCHED_BLKPT_NULL;

	slm_cs_enter(current, SLM_CS_NONE);

	id = (sched_blkpt_id_t)__blkpt_offset;
  400c66:	44 8b 25 93 33 02 00 	mov    r12d,DWORD PTR [rip+0x23393]        # 424000 <__blkpt_offset>
	if (id - 1 == NBLKPTS) return NULL;
  400c6d:	41 81 fc 01 a0 00 00 	cmp    r12d,0xa001
  400c74:	0f 84 ee 00 00 00    	je     400d68 <slm_blkpt_alloc+0x148>
	return &__blkpts[id-1];
  400c7a:	41 8d 44 24 ff       	lea    eax,[r12-0x1]
  400c7f:	48 c1 e0 05          	shl    rax,0x5
	m  = blkpt_get(id);
	if (!m) ERR_THROW(SCHED_BLKPT_NULL, unlock);

	m->id    = id;
  400c83:	44 89 a0 00 f9 45 00 	mov    DWORD PTR [rax+0x45f900],r12d
	ret      = id;
	m->epoch = 0;
  400c8a:	48 c7 80 08 f9 45 00 	mov    QWORD PTR [rax+0x45f908],0x0
  400c91:	00 00 00 00 
};

static inline void
stacklist_init(struct stacklist_head *h)
{
	h->head = NULL;
  400c95:	48 c7 80 10 f9 45 00 	mov    QWORD PTR [rax+0x45f910],0x0
  400c9c:	00 00 00 00 
ps_lock_release(struct ps_lock *l)
{ l->o = 0; }

static inline void
ps_lock_init(struct ps_lock *l)
{ l->o = 0; }
  400ca0:	48 c7 80 18 f9 45 00 	mov    QWORD PTR [rax+0x45f918],0x0
  400ca7:	00 00 00 00 
	stacklist_init(&m->blocked);
	ps_lock_init(&m->lock);
	__blkpt_offset++;
  400cab:	41 8d 44 24 01       	lea    eax,[r12+0x1]
  400cb0:	89 05 4a 33 02 00    	mov    DWORD PTR [rip+0x2334a],eax        # 424000 <__blkpt_offset>
  400cb6:	eb 18                	jmp    400cd0 <slm_blkpt_alloc+0xb0>
  400cb8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  400cbf:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  400cc0:	f0 48 0f b1 15 f7 11 	lock cmpxchg QWORD PTR [rip+0x1a11f7],rdx        # 5a1ec0 <__slm_global>
  400cc7:	1a 00 
  400cc9:	0f 94 c0             	sete   al
	while (ret != 0) {
  400ccc:	84 c0                	test   al,al
  400cce:	75 2e                	jne    400cfe <slm_blkpt_alloc+0xde>
		tok    = cos_sched_sync();
  400cd0:	e8 2b 06 01 00       	call   411300 <cos_sched_sync>
  400cd5:	89 c1                	mov    ecx,eax
  400cd7:	48 8b 05 e2 11 1a 00 	mov    rax,QWORD PTR [rip+0x1a11e2]        # 5a1ec0 <__slm_global>
		if (unlikely(contention)) {
  400cde:	48 89 c2             	mov    rdx,rax
  400ce1:	83 e2 01             	and    edx,0x1
  400ce4:	74 da                	je     400cc0 <slm_blkpt_alloc+0xa0>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  400ce6:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  400ce9:	48 89 c2             	mov    rdx,rax
  400cec:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  400cf1:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  400cf5:	e8 66 2b 01 00       	call   413860 <slm_cs_exit_contention>
  400cfa:	85 c0                	test   eax,eax
  400cfc:	75 d2                	jne    400cd0 <slm_blkpt_alloc+0xb0>
unlock:
	slm_cs_exit(NULL, SLM_CS_NONE);

	return ret;
}
  400cfe:	44 89 e0             	mov    eax,r12d
  400d01:	4c 8b 65 f8          	mov    r12,QWORD PTR [rbp-0x8]
  400d05:	c9                   	leave  
  400d06:	c3                   	ret    
  400d07:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  400d0e:	00 00 
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  400d10:	41 89 c0             	mov    r8d,eax
  400d13:	4c 89 e2             	mov    rdx,r12
  400d16:	48 89 c6             	mov    rsi,rax
  400d19:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  400d1e:	41 83 e0 01          	and    r8d,0x1
  400d22:	e8 e9 2a 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  400d27:	83 f8 f0             	cmp    eax,0xfffffff0
  400d2a:	0f 85 0a ff ff ff    	jne    400c3a <slm_blkpt_alloc+0x1a>
  400d30:	be 59 00 00 00       	mov    esi,0x59
  400d35:	bf c0 c7 41 00       	mov    edi,0x41c7c0
  400d3a:	e8 91 93 00 00       	call   40a0d0 <cos_print_str>
  400d3f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400d46:	00 00 00 00 
  400d4a:	0f 0b                	ud2    
  400d4c:	be 59 00 00 00       	mov    esi,0x59
  400d51:	bf 60 c7 41 00       	mov    edi,0x41c760
  400d56:	e8 75 93 00 00       	call   40a0d0 <cos_print_str>
	assert(current);
  400d5b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400d62:	00 00 00 00 
  400d66:	0f 0b                	ud2    
	if (!m) ERR_THROW(SCHED_BLKPT_NULL, unlock);
  400d68:	45 31 e4             	xor    r12d,r12d
	while (ret != 0) {
  400d6b:	e9 60 ff ff ff       	jmp    400cd0 <slm_blkpt_alloc+0xb0>

0000000000400d70 <slm_blkpt_free>:

int
slm_blkpt_free(sched_blkpt_id_t id)
{
  400d70:	f3 0f 1e fa          	endbr64 
	/* alloc only for now */
	return 0;
}
  400d74:	31 c0                	xor    eax,eax
  400d76:	c3                   	ret    
  400d77:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  400d7e:	00 00 

0000000000400d80 <slm_blkpt_trigger>:

int
slm_blkpt_trigger(sched_blkpt_id_t blkpt, struct slm_thd *current, sched_blkpt_epoch_t epoch, int single)
{
  400d80:	f3 0f 1e fa          	endbr64 
  400d84:	55                   	push   rbp
  400d85:	48 89 e5             	mov    rbp,rsp
  400d88:	41 57                	push   r15
  400d8a:	41 56                	push   r14
  400d8c:	41 89 fe             	mov    r14d,edi
  400d8f:	41 55                	push   r13
  400d91:	49 89 d5             	mov    r13,rdx
  400d94:	41 54                	push   r12
  400d96:	41 89 cc             	mov    r12d,ecx
  400d99:	53                   	push   rbx
  400d9a:	48 89 f3             	mov    rbx,rsi
  400d9d:	48 83 ec 08          	sub    rsp,0x8
	assert(current);
  400da1:	48 85 f6             	test   rsi,rsi
  400da4:	0f 84 5a 02 00 00    	je     401004 <slm_blkpt_trigger+0x284>
		tok    = cos_sched_sync();
  400daa:	e8 51 05 01 00       	call   411300 <cos_sched_sync>
  400daf:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  400db2:	48 8b 05 07 11 1a 00 	mov    rax,QWORD PTR [rip+0x1a1107]        # 5a1ec0 <__slm_global>
		if (unlikely(owner)) {
  400db9:	48 89 c1             	mov    rcx,rax
  400dbc:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  400dc0:	0f 85 02 02 00 00    	jne    400fc8 <slm_blkpt_trigger+0x248>
  400dc6:	f0 48 0f b1 1d f1 10 	lock cmpxchg QWORD PTR [rip+0x1a10f1],rbx        # 5a1ec0 <__slm_global>
  400dcd:	1a 00 
  400dcf:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  400dd2:	84 c0                	test   al,al
  400dd4:	74 d4                	je     400daa <slm_blkpt_trigger+0x2a>
	if (id - 1 == NBLKPTS) return NULL;
  400dd6:	41 81 fe 01 a0 00 00 	cmp    r14d,0xa001
  400ddd:	0f 84 3d 02 00 00    	je     401020 <slm_blkpt_trigger+0x2a0>
	return &__blkpts[id-1];
  400de3:	41 8d 7e ff          	lea    edi,[r14-0x1]
  400de7:	be 01 00 00 00       	mov    esi,0x1
  400dec:	31 c9                	xor    ecx,ecx
  400dee:	49 89 fe             	mov    r14,rdi
  400df1:	49 c1 e6 05          	shl    r14,0x5
  400df5:	4d 8d be 00 f9 45 00 	lea    r15,[r14+0x45f900]
{ while (!ps_cas(&l->o, 0, 1)) ; }
  400dfc:	49 8d 96 18 f9 45 00 	lea    rdx,[r14+0x45f918]
  400e03:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  400e08:	48 89 c8             	mov    rax,rcx
  400e0b:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  400e10:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  400e13:	84 c0                	test   al,al
  400e15:	74 f1                	je     400e08 <slm_blkpt_trigger+0x88>

		if (!blkpt_epoch_is_higher(pre, epoch)) {
			ps_lock_release(&m->lock);
			ERR_THROW(0, unlock); 
		}
		if (ps_cas(&m->epoch, pre, epoch)) break;
  400e17:	49 8d 96 08 f9 45 00 	lea    rdx,[r14+0x45f908]
  400e1e:	eb 0c                	jmp    400e2c <slm_blkpt_trigger+0xac>
        __asm__ __volatile__("lock " PS_CAS_STR
  400e20:	f0 4c 0f b1 2a       	lock cmpxchg QWORD PTR [rdx],r13
  400e25:	0f 94 c0             	sete   al
  400e28:	84 c0                	test   al,al
  400e2a:	75 74                	jne    400ea0 <slm_blkpt_trigger+0x120>
		sched_blkpt_epoch_t pre = ps_load(&m->epoch);
  400e2c:	49 8b 47 08          	mov    rax,QWORD PTR [r15+0x8]
		if (!blkpt_epoch_is_higher(pre, epoch)) {
  400e30:	4c 39 e8             	cmp    rax,r13
  400e33:	76 eb                	jbe    400e20 <slm_blkpt_trigger+0xa0>
{ l->o = 0; }
  400e35:	49 c7 47 18 00 00 00 	mov    QWORD PTR [r15+0x18],0x0
  400e3c:	00 
			ERR_THROW(0, unlock); 
  400e3d:	45 31 e4             	xor    r12d,r12d
  400e40:	eb 16                	jmp    400e58 <slm_blkpt_trigger+0xd8>
  400e42:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  400e48:	f0 48 0f b1 15 6f 10 	lock cmpxchg QWORD PTR [rip+0x1a106f],rdx        # 5a1ec0 <__slm_global>
  400e4f:	1a 00 
  400e51:	0f 94 c0             	sete   al
	while (ret != 0) {
  400e54:	84 c0                	test   al,al
  400e56:	75 2e                	jne    400e86 <slm_blkpt_trigger+0x106>
		tok    = cos_sched_sync();
  400e58:	e8 a3 04 01 00       	call   411300 <cos_sched_sync>
  400e5d:	89 c1                	mov    ecx,eax
  400e5f:	48 8b 05 5a 10 1a 00 	mov    rax,QWORD PTR [rip+0x1a105a]        # 5a1ec0 <__slm_global>
		if (unlikely(contention)) {
  400e66:	48 89 c2             	mov    rdx,rax
  400e69:	83 e2 01             	and    edx,0x1
  400e6c:	74 da                	je     400e48 <slm_blkpt_trigger+0xc8>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  400e6e:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  400e71:	48 89 c2             	mov    rdx,rax
  400e74:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  400e79:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  400e7d:	e8 de 29 01 00       	call   413860 <slm_cs_exit_contention>
  400e82:	85 c0                	test   eax,eax
  400e84:	75 d2                	jne    400e58 <slm_blkpt_trigger+0xd8>
	return 0;
unlock:
	slm_cs_exit(NULL, SLM_CS_NONE);

	return ret;
}
  400e86:	48 83 c4 08          	add    rsp,0x8
  400e8a:	44 89 e0             	mov    eax,r12d
  400e8d:	5b                   	pop    rbx
  400e8e:	41 5c                	pop    r12
  400e90:	41 5d                	pop    r13
  400e92:	41 5e                	pop    r14
  400e94:	41 5f                	pop    r15
  400e96:	5d                   	pop    rbp
  400e97:	c3                   	ret    
  400e98:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  400e9f:	00 
	 * threads, but we'll implement this conservatively. Given
	 * this, please note that this should *not* iterate more than
	 * once.
	 */
	while (1) {
		sl = ps_load(&h->head);
  400ea0:	48 c1 e7 05          	shl    rdi,0x5
		/*
		 * Check sl again in case other thread updating the head,
		 * which might causes dereferencing a NULL pointer.
		 */
		if (!sl) return NULL;
		if (ps_cas((unsigned long *)&h->head, (unsigned long)sl, (unsigned long)sl->next)) break;
  400ea4:	49 81 c6 10 f9 45 00 	add    r14,0x45f910
		sl = ps_load(&h->head);
  400eab:	49 89 fd             	mov    r13,rdi
  400eae:	66 90                	xchg   ax,ax
	if (!h->head) return NULL;
  400eb0:	49 83 7f 10 00       	cmp    QWORD PTR [r15+0x10],0x0
  400eb5:	74 28                	je     400edf <slm_blkpt_trigger+0x15f>
		sl = ps_load(&h->head);
  400eb7:	49 8d b5 00 f9 45 00 	lea    rsi,[r13+0x45f900]
  400ebe:	eb 16                	jmp    400ed6 <slm_blkpt_trigger+0x156>
  400ec0:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
  400ec3:	48 89 d0             	mov    rax,rdx
  400ec6:	f0 49 0f b1 0e       	lock cmpxchg QWORD PTR [r14],rcx
  400ecb:	0f 94 c0             	sete   al
		if (ps_cas((unsigned long *)&h->head, (unsigned long)sl, (unsigned long)sl->next)) break;
  400ece:	84 c0                	test   al,al
  400ed0:	0f 85 d2 00 00 00    	jne    400fa8 <slm_blkpt_trigger+0x228>
		sl = ps_load(&h->head);
  400ed6:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
		if (!sl) return NULL;
  400eda:	48 85 d2             	test   rdx,rdx
  400edd:	75 e1                	jne    400ec0 <slm_blkpt_trigger+0x140>
{ l->o = 0; }
  400edf:	49 c7 47 18 00 00 00 	mov    QWORD PTR [r15+0x18],0x0
  400ee6:	00 
	if (unlikely(!t)) t = &g->idle_thd;
  400ee7:	41 bd 40 1f 5a 00    	mov    r13d,0x5a1f40
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  400eed:	e8 6e a9 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	tok  = cos_sched_sync();
  400ef2:	e8 09 04 01 00       	call   411300 <cos_sched_sync>
  400ef7:	41 89 c6             	mov    r14d,eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  400efa:	e8 91 15 01 00       	call   412490 <slm_sched_fprr_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  400eff:	48 85 c0             	test   rax,rax
  400f02:	49 89 c4             	mov    r12,rax
  400f05:	4d 0f 44 e5          	cmove  r12,r13
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  400f09:	41 8b 44 24 04       	mov    eax,DWORD PTR [r12+0x4]
  400f0e:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  400f11:	83 f8 01             	cmp    eax,0x1
  400f14:	76 1a                	jbe    400f30 <slm_blkpt_trigger+0x1b0>
  400f16:	e9 10 01 00 00       	jmp    40102b <slm_blkpt_trigger+0x2ab>
  400f1b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  400f20:	f0 48 0f b1 15 97 0f 	lock cmpxchg QWORD PTR [rip+0x1a0f97],rdx        # 5a1ec0 <__slm_global>
  400f27:	1a 00 
  400f29:	0f 94 c0             	sete   al
	while (ret != 0) {
  400f2c:	84 c0                	test   al,al
  400f2e:	75 2e                	jne    400f5e <slm_blkpt_trigger+0x1de>
		tok    = cos_sched_sync();
  400f30:	e8 cb 03 01 00       	call   411300 <cos_sched_sync>
  400f35:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  400f37:	48 8b 05 82 0f 1a 00 	mov    rax,QWORD PTR [rip+0x1a0f82]        # 5a1ec0 <__slm_global>
		if (unlikely(contention)) {
  400f3e:	48 89 c2             	mov    rdx,rax
  400f41:	83 e2 01             	and    edx,0x1
  400f44:	74 da                	je     400f20 <slm_blkpt_trigger+0x1a0>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  400f46:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  400f49:	48 89 c2             	mov    rdx,rax
  400f4c:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  400f51:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  400f55:	e8 06 29 01 00       	call   413860 <slm_cs_exit_contention>
  400f5a:	85 c0                	test   eax,eax
  400f5c:	75 d2                	jne    400f30 <slm_blkpt_trigger+0x1b0>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  400f5e:	e8 fd a8 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  400f63:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
	prio = inherit_prio ? curr->priority : t->priority;
  400f67:	49 8b 74 24 30       	mov    rsi,QWORD PTR [r12+0x30]
	timeout = g->timeout_next;
  400f6c:	4c 8b 05 55 10 1a 00 	mov    r8,QWORD PTR [rip+0x1a1055]        # 5a1fc8 <__slm_global+0x108>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  400f73:	a8 0b                	test   al,0xb
  400f75:	0f 85 cc 00 00 00    	jne    401047 <slm_blkpt_trigger+0x2c7>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  400f7b:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  400f80:	44 89 f1             	mov    ecx,r14d
  400f83:	4c 89 c2             	mov    rdx,r8
  400f86:	e8 d5 b7 00 00       	call   40c760 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  400f8b:	83 f8 ff             	cmp    eax,0xffffffff
  400f8e:	0f 84 5c 01 00 00    	je     4010f0 <slm_blkpt_trigger+0x370>
	if (unlikely(ret != 0)) {
  400f94:	85 c0                	test   eax,eax
  400f96:	0f 85 fa 00 00 00    	jne    401096 <slm_blkpt_trigger+0x316>
	return 0;
  400f9c:	45 31 e4             	xor    r12d,r12d
  400f9f:	e9 e2 fe ff ff       	jmp    400e86 <slm_blkpt_trigger+0x106>
  400fa4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	}
	sl->next = NULL;
  400fa8:	48 c7 02 00 00 00 00 	mov    QWORD PTR [rdx],0x0
		slm_thd_wakeup(t, 0); /* ignore retval: process next thread */
  400faf:	48 8b 7a 08          	mov    rdi,QWORD PTR [rdx+0x8]
  400fb3:	31 f6                	xor    esi,esi
  400fb5:	e8 76 2e 01 00       	call   413e30 <slm_thd_wakeup>
		if (single) break;
  400fba:	45 85 e4             	test   r12d,r12d
  400fbd:	0f 84 ed fe ff ff    	je     400eb0 <slm_blkpt_trigger+0x130>
  400fc3:	e9 17 ff ff ff       	jmp    400edf <slm_blkpt_trigger+0x15f>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  400fc8:	41 89 c0             	mov    r8d,eax
  400fcb:	48 89 da             	mov    rdx,rbx
  400fce:	48 89 c6             	mov    rsi,rax
  400fd1:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  400fd6:	41 83 e0 01          	and    r8d,0x1
  400fda:	e8 31 28 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  400fdf:	83 f8 f0             	cmp    eax,0xfffffff0
  400fe2:	0f 85 c2 fd ff ff    	jne    400daa <slm_blkpt_trigger+0x2a>
  400fe8:	be 59 00 00 00       	mov    esi,0x59
  400fed:	bf c0 c7 41 00       	mov    edi,0x41c7c0
  400ff2:	e8 d9 90 00 00       	call   40a0d0 <cos_print_str>
  400ff7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400ffe:	00 00 00 00 
  401002:	0f 0b                	ud2    
  401004:	be 59 00 00 00       	mov    esi,0x59
  401009:	bf 60 c7 41 00       	mov    edi,0x41c760
  40100e:	e8 bd 90 00 00       	call   40a0d0 <cos_print_str>
	assert(current);
  401013:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40101a:	00 00 00 00 
  40101e:	0f 0b                	ud2    
	if (!m) ERR_THROW(-1, unlock);
  401020:	41 bc ff ff ff ff    	mov    r12d,0xffffffff
	while (ret != 0) {
  401026:	e9 2d fe ff ff       	jmp    400e58 <slm_blkpt_trigger+0xd8>
  40102b:	be 61 00 00 00       	mov    esi,0x61
  401030:	bf 48 c8 41 00       	mov    edi,0x41c848
  401035:	e8 96 90 00 00       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  40103a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401041:	00 00 00 00 
  401045:	0f 0b                	ud2    
	timeout = g->timeout_next;
  401047:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  40104a:	49 81 fc c8 1e 5a 00 	cmp    r12,0x5a1ec8
  401051:	0f 84 c7 00 00 00    	je     40111e <slm_blkpt_trigger+0x39e>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  401057:	a8 02                	test   al,0x2
  401059:	0f 85 ca 00 00 00    	jne    401129 <slm_blkpt_trigger+0x3a9>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  40105f:	49 89 c8             	mov    r8,rcx
  401062:	a8 01                	test   al,0x1
  401064:	0f 84 11 ff ff ff    	je     400f7b <slm_blkpt_trigger+0x1fb>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  40106a:	4d 8b 54 24 08       	mov    r10,QWORD PTR [r12+0x8]
  40106f:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  401074:	48 89 f2             	mov    rdx,rsi
  401077:	45 89 f1             	mov    r9d,r14d
  40107a:	4c 8b 05 67 0e 1a 00 	mov    r8,QWORD PTR [rip+0x1a0e67]        # 5a1ee8 <__slm_global+0x28>
  401081:	4c 89 d6             	mov    rsi,r10
  401084:	e8 97 02 01 00       	call   411320 <cos_switch>
	if (unlikely(ret != 0)) {
  401089:	85 c0                	test   eax,eax
  40108b:	0f 84 0b ff ff ff    	je     400f9c <slm_blkpt_trigger+0x21c>
		assert(ret != -EPERM);
  401091:	83 f8 ff             	cmp    eax,0xffffffff
  401094:	74 6c                	je     401102 <slm_blkpt_trigger+0x382>
		assert(ret != -EINVAL);
  401096:	83 f8 ea             	cmp    eax,0xffffffea
  401099:	0f 84 0d 01 00 00    	je     4011ac <slm_blkpt_trigger+0x42c>
		if (ret == -EBUSY) return ret;
  40109f:	83 f8 f0             	cmp    eax,0xfffffff0
  4010a2:	0f 84 f4 fe ff ff    	je     400f9c <slm_blkpt_trigger+0x21c>
		assert(ret == -EAGAIN);
  4010a8:	83 f8 f5             	cmp    eax,0xfffffff5
  4010ab:	0f 85 df 00 00 00    	jne    401190 <slm_blkpt_trigger+0x410>
		tok    = cos_sched_sync();
  4010b1:	e8 4a 02 01 00       	call   411300 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  4010b6:	48 8b 35 03 0e 1a 00 	mov    rsi,QWORD PTR [rip+0x1a0e03]        # 5a1ec0 <__slm_global>
  4010bd:	41 89 c1             	mov    r9d,eax
		if (unlikely(owner)) {
  4010c0:	48 89 f1             	mov    rcx,rsi
  4010c3:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  4010c7:	0f 85 9b 00 00 00    	jne    401168 <slm_blkpt_trigger+0x3e8>
  4010cd:	48 89 f0             	mov    rax,rsi
  4010d0:	f0 48 0f b1 1d e7 0d 	lock cmpxchg QWORD PTR [rip+0x1a0de7],rbx        # 5a1ec0 <__slm_global>
  4010d7:	1a 00 
  4010d9:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4010dc:	84 c0                	test   al,al
  4010de:	0f 85 0e fe ff ff    	jne    400ef2 <slm_blkpt_trigger+0x172>
  4010e4:	eb cb                	jmp    4010b1 <slm_blkpt_trigger+0x331>
  4010e6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4010ed:	00 00 00 
	return t != &g->idle_thd && t != &g->sched_thd;
  4010f0:	49 81 fc 40 1f 5a 00 	cmp    r12,0x5a1f40
  4010f7:	74 4c                	je     401145 <slm_blkpt_trigger+0x3c5>
  4010f9:	49 81 fc c8 1e 5a 00 	cmp    r12,0x5a1ec8
  401100:	74 43                	je     401145 <slm_blkpt_trigger+0x3c5>
  401102:	be 61 00 00 00       	mov    esi,0x61
  401107:	bf b0 c8 41 00       	mov    edi,0x41c8b0
  40110c:	e8 bf 8f 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EPERM);
  401111:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401118:	00 00 00 00 
  40111c:	0f 0b                	ud2    
			prio    = curr->priority;
  40111e:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
			timeout = TCAP_TIME_NIL;
  401122:	31 c9                	xor    ecx,ecx
  401124:	e9 2e ff ff ff       	jmp    401057 <slm_blkpt_trigger+0x2d7>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  401129:	49 8b 7c 24 28       	mov    rdi,QWORD PTR [r12+0x28]
  40112e:	48 8b 15 b3 0d 1a 00 	mov    rdx,QWORD PTR [rip+0x1a0db3]        # 5a1ee8 <__slm_global+0x28>
  401135:	44 89 f1             	mov    ecx,r14d
  401138:	4c 89 c6             	mov    rsi,r8
  40113b:	e8 50 02 01 00       	call   411390 <cos_sched_asnd>
  401140:	e9 44 ff ff ff       	jmp    401089 <slm_blkpt_trigger+0x309>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  401145:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]
  401149:	4c 8b 05 98 0d 1a 00 	mov    r8,QWORD PTR [rip+0x1a0d98]        # 5a1ee8 <__slm_global+0x28>
  401150:	45 89 f1             	mov    r9d,r14d
  401153:	31 c9                	xor    ecx,ecx
  401155:	48 8b 3d 7c 0d 1a 00 	mov    rdi,QWORD PTR [rip+0x1a0d7c]        # 5a1ed8 <__slm_global+0x18>
  40115c:	31 f6                	xor    esi,esi
  40115e:	e8 bd 01 01 00       	call   411320 <cos_switch>
  401163:	e9 21 ff ff ff       	jmp    401089 <slm_blkpt_trigger+0x309>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  401168:	41 89 f0             	mov    r8d,esi
  40116b:	48 89 da             	mov    rdx,rbx
  40116e:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  401173:	41 83 e0 01          	and    r8d,0x1
  401177:	e8 94 26 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  40117c:	83 f8 f0             	cmp    eax,0xfffffff0
  40117f:	0f 85 2c ff ff ff    	jne    4010b1 <slm_blkpt_trigger+0x331>
  401185:	e9 5e fe ff ff       	jmp    400fe8 <slm_blkpt_trigger+0x268>
  40118a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  401190:	be 61 00 00 00       	mov    esi,0x61
  401195:	bf 80 c9 41 00       	mov    edi,0x41c980
  40119a:	e8 31 8f 00 00       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  40119f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4011a6:	00 00 00 00 
  4011aa:	0f 0b                	ud2    
  4011ac:	be 61 00 00 00       	mov    esi,0x61
  4011b1:	bf 18 c9 41 00       	mov    edi,0x41c918
  4011b6:	e8 15 8f 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  4011bb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4011c2:	00 00 00 00 
  4011c6:	0f 0b                	ud2    
  4011c8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4011cf:	00 

00000000004011d0 <slm_blkpt_block>:

int
slm_blkpt_block(sched_blkpt_id_t blkpt, struct slm_thd *current, sched_blkpt_epoch_t epoch, thdid_t dependency)
{
  4011d0:	f3 0f 1e fa          	endbr64 
  4011d4:	55                   	push   rbp
  4011d5:	48 89 e5             	mov    rbp,rsp
  4011d8:	41 57                	push   r15
  4011da:	41 56                	push   r14
  4011dc:	41 55                	push   r13
  4011de:	41 89 fd             	mov    r13d,edi
  4011e1:	41 54                	push   r12
  4011e3:	49 89 d4             	mov    r12,rdx
  4011e6:	53                   	push   rbx
  4011e7:	48 89 f3             	mov    rbx,rsi
  4011ea:	48 83 ec 18          	sub    rsp,0x18
	assert(current);
  4011ee:	48 85 f6             	test   rsi,rsi
  4011f1:	0f 84 05 02 00 00    	je     4013fc <slm_blkpt_block+0x22c>
		tok    = cos_sched_sync();
  4011f7:	e8 04 01 01 00       	call   411300 <cos_sched_sync>
  4011fc:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4011ff:	48 8b 05 ba 0c 1a 00 	mov    rax,QWORD PTR [rip+0x1a0cba]        # 5a1ec0 <__slm_global>
		if (unlikely(owner)) {
  401206:	48 89 c1             	mov    rcx,rax
  401209:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  40120d:	0f 85 ad 01 00 00    	jne    4013c0 <slm_blkpt_block+0x1f0>
  401213:	f0 48 0f b1 1d a4 0c 	lock cmpxchg QWORD PTR [rip+0x1a0ca4],rbx        # 5a1ec0 <__slm_global>
  40121a:	1a 00 
  40121c:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  40121f:	84 c0                	test   al,al
  401221:	74 d4                	je     4011f7 <slm_blkpt_block+0x27>
	if (id - 1 == NBLKPTS) return NULL;
  401223:	41 81 fd 01 a0 00 00 	cmp    r13d,0xa001
  40122a:	0f 84 e8 01 00 00    	je     401418 <slm_blkpt_block+0x248>
	return &__blkpts[id-1];
  401230:	45 8d 45 ff          	lea    r8d,[r13-0x1]
  401234:	be 01 00 00 00       	mov    esi,0x1
  401239:	31 c9                	xor    ecx,ecx
  40123b:	4c 89 c7             	mov    rdi,r8
  40123e:	48 c1 e7 05          	shl    rdi,0x5
  401242:	4c 8d af 00 f9 45 00 	lea    r13,[rdi+0x45f900]
{ while (!ps_cas(&l->o, 0, 1)) ; }
  401249:	48 8d 97 18 f9 45 00 	lea    rdx,[rdi+0x45f918]
        __asm__ __volatile__("lock " PS_CAS_STR
  401250:	48 89 c8             	mov    rax,rcx
  401253:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  401258:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40125b:	84 c0                	test   al,al
  40125d:	74 f1                	je     401250 <slm_blkpt_block+0x80>
		ERR_THROW(-1, unlock);
	}

	ps_lock_take(&m->lock);
	/* Outdated event? don't block! */
	pre = ps_load(&m->epoch);
  40125f:	49 8b 75 08          	mov    rsi,QWORD PTR [r13+0x8]
	if (!blkpt_epoch_is_higher(pre, epoch)) {
  401263:	4c 39 e6             	cmp    rsi,r12
  401266:	76 68                	jbe    4012d0 <slm_blkpt_block+0x100>
{ l->o = 0; }
  401268:	49 c7 45 18 00 00 00 	mov    QWORD PTR [r13+0x18],0x0
  40126f:	00 
			 */
			assert(_sl == &sl);
		}
		assert(stacklist_is_removed(&sl));
		ps_lock_release(&m->lock);
		ERR_THROW(0, unlock);
  401270:	45 31 e4             	xor    r12d,r12d
  401273:	eb 13                	jmp    401288 <slm_blkpt_block+0xb8>
  401275:	0f 1f 00             	nop    DWORD PTR [rax]
        __asm__ __volatile__("lock " PS_CAS_STR
  401278:	f0 48 0f b1 15 3f 0c 	lock cmpxchg QWORD PTR [rip+0x1a0c3f],rdx        # 5a1ec0 <__slm_global>
  40127f:	1a 00 
  401281:	0f 94 c0             	sete   al
	while (ret != 0) {
  401284:	84 c0                	test   al,al
  401286:	75 2e                	jne    4012b6 <slm_blkpt_block+0xe6>
		tok    = cos_sched_sync();
  401288:	e8 73 00 01 00       	call   411300 <cos_sched_sync>
  40128d:	89 c1                	mov    ecx,eax
  40128f:	48 8b 05 2a 0c 1a 00 	mov    rax,QWORD PTR [rip+0x1a0c2a]        # 5a1ec0 <__slm_global>
		if (unlikely(contention)) {
  401296:	48 89 c2             	mov    rdx,rax
  401299:	83 e2 01             	and    edx,0x1
  40129c:	74 da                	je     401278 <slm_blkpt_block+0xa8>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  40129e:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  4012a1:	48 89 c2             	mov    rdx,rax
  4012a4:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  4012a9:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  4012ad:	e8 ae 25 01 00       	call   413860 <slm_cs_exit_contention>
  4012b2:	85 c0                	test   eax,eax
  4012b4:	75 d2                	jne    401288 <slm_blkpt_block+0xb8>
	return 0;
unlock:
	slm_cs_exit(NULL, SLM_CS_NONE);

	return ret;
}
  4012b6:	48 83 c4 18          	add    rsp,0x18
  4012ba:	44 89 e0             	mov    eax,r12d
  4012bd:	5b                   	pop    rbx
  4012be:	41 5c                	pop    r12
  4012c0:	41 5d                	pop    r13
  4012c2:	41 5e                	pop    r14
  4012c4:	41 5f                	pop    r15
  4012c6:	5d                   	pop    rbp
  4012c7:	c3                   	ret    
  4012c8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4012cf:	00 
		struct stacklist *n = ps_load(&h->head);
  4012d0:	4c 89 c1             	mov    rcx,r8
	l->data = data;
  4012d3:	48 89 5d c8          	mov    QWORD PTR [rbp-0x38],rbx
		if (ps_cas((unsigned long *)&h->head, (unsigned long)n, (unsigned long)l)) break;
  4012d7:	48 8d 97 10 f9 45 00 	lea    rdx,[rdi+0x45f910]
  4012de:	48 8d 7d c0          	lea    rdi,[rbp-0x40]
		struct stacklist *n = ps_load(&h->head);
  4012e2:	48 c1 e1 05          	shl    rcx,0x5
  4012e6:	48 81 c1 00 f9 45 00 	add    rcx,0x45f900
  4012ed:	0f 1f 00             	nop    DWORD PTR [rax]
  4012f0:	48 8b 41 10          	mov    rax,QWORD PTR [rcx+0x10]
		l->next = n;
  4012f4:	48 89 45 c0          	mov    QWORD PTR [rbp-0x40],rax
  4012f8:	f0 48 0f b1 3a       	lock cmpxchg QWORD PTR [rdx],rdi
  4012fd:	0f 94 c0             	sete   al
		if (ps_cas((unsigned long *)&h->head, (unsigned long)n, (unsigned long)l)) break;
  401300:	84 c0                	test   al,al
  401302:	74 ec                	je     4012f0 <slm_blkpt_block+0x120>
	if (!blkpt_epoch_is_higher(ps_load(&m->epoch), pre)) {
  401304:	49 8b 45 08          	mov    rax,QWORD PTR [r13+0x8]
  401308:	48 39 f0             	cmp    rax,rsi
  40130b:	0f 86 8f 00 00 00    	jbe    4013a0 <slm_blkpt_block+0x1d0>
	if (!h->head) return NULL;
  401311:	49 83 7d 10 00       	cmp    QWORD PTR [r13+0x10],0x0
  401316:	74 2b                	je     401343 <slm_blkpt_block+0x173>
		sl = ps_load(&h->head);
  401318:	49 c1 e0 05          	shl    r8,0x5
  40131c:	49 81 c0 00 f9 45 00 	add    r8,0x45f900
  401323:	eb 15                	jmp    40133a <slm_blkpt_block+0x16a>
  401325:	0f 1f 00             	nop    DWORD PTR [rax]
  401328:	48 8b 31             	mov    rsi,QWORD PTR [rcx]
  40132b:	48 89 c8             	mov    rax,rcx
  40132e:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  401333:	0f 94 c0             	sete   al
		if (ps_cas((unsigned long *)&h->head, (unsigned long)sl, (unsigned long)sl->next)) break;
  401336:	84 c0                	test   al,al
  401338:	75 36                	jne    401370 <slm_blkpt_block+0x1a0>
		sl = ps_load(&h->head);
  40133a:	49 8b 48 10          	mov    rcx,QWORD PTR [r8+0x10]
		if (!sl) return NULL;
  40133e:	48 85 c9             	test   rcx,rcx
  401341:	75 e5                	jne    401328 <slm_blkpt_block+0x158>
		assert(stacklist_is_removed(&sl));
  401343:	48 83 7d c0 00       	cmp    QWORD PTR [rbp-0x40],0x0
  401348:	0f 84 1a ff ff ff    	je     401268 <slm_blkpt_block+0x98>
  40134e:	be 5f 00 00 00       	mov    esi,0x5f
  401353:	bf 48 ca 41 00       	mov    edi,0x41ca48
  401358:	e8 73 8d 00 00       	call   40a0d0 <cos_print_str>
  40135d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401364:	00 00 00 00 
  401368:	0f 0b                	ud2    
  40136a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	sl->next = NULL;
  401370:	48 c7 01 00 00 00 00 	mov    QWORD PTR [rcx],0x0
			assert(_sl == &sl);
  401377:	48 39 f9             	cmp    rcx,rdi
  40137a:	74 c7                	je     401343 <slm_blkpt_block+0x173>
  40137c:	be 5f 00 00 00       	mov    esi,0x5f
  401381:	bf e8 c9 41 00       	mov    edi,0x41c9e8
  401386:	e8 45 8d 00 00       	call   40a0d0 <cos_print_str>
  40138b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401392:	00 00 00 00 
  401396:	0f 0b                	ud2    
  401398:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40139f:	00 
	if (slm_thd_block(current)) {
  4013a0:	48 89 df             	mov    rdi,rbx
  4013a3:	e8 18 25 01 00       	call   4138c0 <slm_thd_block>
{ l->o = 0; }
  4013a8:	49 c7 45 18 00 00 00 	mov    QWORD PTR [r13+0x18],0x0
  4013af:	00 
  4013b0:	41 89 c4             	mov    r12d,eax
  4013b3:	85 c0                	test   eax,eax
  4013b5:	74 6c                	je     401423 <slm_blkpt_block+0x253>
		ERR_THROW(0, unlock);
  4013b7:	45 31 e4             	xor    r12d,r12d
  4013ba:	e9 c9 fe ff ff       	jmp    401288 <slm_blkpt_block+0xb8>
  4013bf:	90                   	nop
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  4013c0:	41 89 c0             	mov    r8d,eax
  4013c3:	48 89 da             	mov    rdx,rbx
  4013c6:	48 89 c6             	mov    rsi,rax
  4013c9:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  4013ce:	41 83 e0 01          	and    r8d,0x1
  4013d2:	e8 39 24 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  4013d7:	83 f8 f0             	cmp    eax,0xfffffff0
  4013da:	0f 85 17 fe ff ff    	jne    4011f7 <slm_blkpt_block+0x27>
  4013e0:	be 59 00 00 00       	mov    esi,0x59
  4013e5:	bf c0 c7 41 00       	mov    edi,0x41c7c0
  4013ea:	e8 e1 8c 00 00       	call   40a0d0 <cos_print_str>
  4013ef:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4013f6:	00 00 00 00 
  4013fa:	0f 0b                	ud2    
  4013fc:	be 59 00 00 00       	mov    esi,0x59
  401401:	bf 60 c7 41 00       	mov    edi,0x41c760
  401406:	e8 c5 8c 00 00       	call   40a0d0 <cos_print_str>
	assert(current);
  40140b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401412:	00 00 00 00 
  401416:	0f 0b                	ud2    
		ERR_THROW(-1, unlock);
  401418:	41 bc ff ff ff ff    	mov    r12d,0xffffffff
	while (ret != 0) {
  40141e:	e9 65 fe ff ff       	jmp    401288 <slm_blkpt_block+0xb8>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  401423:	e8 38 a4 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(!t)) t = &g->idle_thd;
  401428:	41 bf 40 1f 5a 00    	mov    r15d,0x5a1f40
	tok  = cos_sched_sync();
  40142e:	e8 cd fe 00 00       	call   411300 <cos_sched_sync>
  401433:	41 89 c6             	mov    r14d,eax
  401436:	e8 55 10 01 00       	call   412490 <slm_sched_fprr_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  40143b:	48 85 c0             	test   rax,rax
  40143e:	49 89 c5             	mov    r13,rax
  401441:	4d 0f 44 ef          	cmove  r13,r15
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  401445:	41 8b 45 04          	mov    eax,DWORD PTR [r13+0x4]
  401449:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  40144c:	83 f8 01             	cmp    eax,0x1
  40144f:	76 1f                	jbe    401470 <slm_blkpt_block+0x2a0>
  401451:	e9 7a 01 00 00       	jmp    4015d0 <slm_blkpt_block+0x400>
  401456:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40145d:	00 00 00 
        __asm__ __volatile__("lock " PS_CAS_STR
  401460:	f0 48 0f b1 15 57 0a 	lock cmpxchg QWORD PTR [rip+0x1a0a57],rdx        # 5a1ec0 <__slm_global>
  401467:	1a 00 
  401469:	0f 94 c0             	sete   al
  40146c:	84 c0                	test   al,al
  40146e:	75 2e                	jne    40149e <slm_blkpt_block+0x2ce>
		tok    = cos_sched_sync();
  401470:	e8 8b fe 00 00       	call   411300 <cos_sched_sync>
  401475:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  401477:	48 8b 05 42 0a 1a 00 	mov    rax,QWORD PTR [rip+0x1a0a42]        # 5a1ec0 <__slm_global>
		if (unlikely(contention)) {
  40147e:	48 89 c2             	mov    rdx,rax
  401481:	83 e2 01             	and    edx,0x1
  401484:	74 da                	je     401460 <slm_blkpt_block+0x290>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  401486:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  401489:	48 89 c2             	mov    rdx,rax
  40148c:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  401491:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  401495:	e8 c6 23 01 00       	call   413860 <slm_cs_exit_contention>
  40149a:	85 c0                	test   eax,eax
  40149c:	75 d2                	jne    401470 <slm_blkpt_block+0x2a0>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  40149e:	e8 bd a3 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4014a3:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
	timeout = g->timeout_next;
  4014a7:	4c 8b 05 1a 0b 1a 00 	mov    r8,QWORD PTR [rip+0x1a0b1a]        # 5a1fc8 <__slm_global+0x108>
	prio = inherit_prio ? curr->priority : t->priority;
  4014ae:	49 8b 75 30          	mov    rsi,QWORD PTR [r13+0x30]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4014b2:	a8 0b                	test   al,0xb
  4014b4:	75 79                	jne    40152f <slm_blkpt_block+0x35f>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  4014b6:	49 8b 7d 10          	mov    rdi,QWORD PTR [r13+0x10]
  4014ba:	44 89 f1             	mov    ecx,r14d
  4014bd:	4c 89 c2             	mov    rdx,r8
  4014c0:	e8 9b b2 00 00       	call   40c760 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  4014c5:	83 f8 ff             	cmp    eax,0xffffffff
  4014c8:	74 2f                	je     4014f9 <slm_blkpt_block+0x329>
	if (unlikely(ret != 0)) {
  4014ca:	85 c0                	test   eax,eax
  4014cc:	0f 85 aa 00 00 00    	jne    40157c <slm_blkpt_block+0x3ac>
	assert(stacklist_is_removed(&sl));
  4014d2:	48 83 7d c0 00       	cmp    QWORD PTR [rbp-0x40],0x0
  4014d7:	0f 84 d9 fd ff ff    	je     4012b6 <slm_blkpt_block+0xe6>
  4014dd:	be 5f 00 00 00       	mov    esi,0x5f
  4014e2:	bf a8 ca 41 00       	mov    edi,0x41caa8
  4014e7:	e8 e4 8b 00 00       	call   40a0d0 <cos_print_str>
  4014ec:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4014f3:	00 00 00 00 
  4014f7:	0f 0b                	ud2    
	return t != &g->idle_thd && t != &g->sched_thd;
  4014f9:	49 81 fd c8 1e 5a 00 	cmp    r13,0x5a1ec8
  401500:	0f 84 0c 01 00 00    	je     401612 <slm_blkpt_block+0x442>
  401506:	49 81 fd 40 1f 5a 00 	cmp    r13,0x5a1f40
  40150d:	0f 84 ff 00 00 00    	je     401612 <slm_blkpt_block+0x442>
  401513:	be 61 00 00 00       	mov    esi,0x61
  401518:	bf b0 c8 41 00       	mov    edi,0x41c8b0
  40151d:	e8 ae 8b 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EPERM);
  401522:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401529:	00 00 00 00 
  40152d:	0f 0b                	ud2    
	timeout = g->timeout_next;
  40152f:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  401532:	49 81 fd c8 1e 5a 00 	cmp    r13,0x5a1ec8
  401539:	0f 84 ad 00 00 00    	je     4015ec <slm_blkpt_block+0x41c>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  40153f:	a8 02                	test   al,0x2
  401541:	0f 85 b0 00 00 00    	jne    4015f7 <slm_blkpt_block+0x427>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  401547:	49 89 c8             	mov    r8,rcx
  40154a:	a8 01                	test   al,0x1
  40154c:	0f 84 64 ff ff ff    	je     4014b6 <slm_blkpt_block+0x2e6>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  401552:	4d 8b 55 08          	mov    r10,QWORD PTR [r13+0x8]
  401556:	49 8b 7d 10          	mov    rdi,QWORD PTR [r13+0x10]
  40155a:	48 89 f2             	mov    rdx,rsi
  40155d:	45 89 f1             	mov    r9d,r14d
  401560:	4c 8b 05 81 09 1a 00 	mov    r8,QWORD PTR [rip+0x1a0981]        # 5a1ee8 <__slm_global+0x28>
  401567:	4c 89 d6             	mov    rsi,r10
  40156a:	e8 b1 fd 00 00       	call   411320 <cos_switch>
	if (unlikely(ret != 0)) {
  40156f:	85 c0                	test   eax,eax
  401571:	0f 84 5b ff ff ff    	je     4014d2 <slm_blkpt_block+0x302>
		assert(ret != -EPERM);
  401577:	83 f8 ff             	cmp    eax,0xffffffff
  40157a:	74 97                	je     401513 <slm_blkpt_block+0x343>
		assert(ret != -EINVAL);
  40157c:	83 f8 ea             	cmp    eax,0xffffffea
  40157f:	0f 84 ee 00 00 00    	je     401673 <slm_blkpt_block+0x4a3>
		if (ret == -EBUSY) return ret;
  401585:	83 f8 f0             	cmp    eax,0xfffffff0
  401588:	0f 84 44 ff ff ff    	je     4014d2 <slm_blkpt_block+0x302>
		assert(ret == -EAGAIN);
  40158e:	83 f8 f5             	cmp    eax,0xfffffff5
  401591:	0f 85 c0 00 00 00    	jne    401657 <slm_blkpt_block+0x487>
		tok    = cos_sched_sync();
  401597:	e8 64 fd 00 00       	call   411300 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  40159c:	48 8b 35 1d 09 1a 00 	mov    rsi,QWORD PTR [rip+0x1a091d]        # 5a1ec0 <__slm_global>
  4015a3:	41 89 c1             	mov    r9d,eax
		if (unlikely(owner)) {
  4015a6:	48 89 f1             	mov    rcx,rsi
  4015a9:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  4015ad:	0f 85 82 00 00 00    	jne    401635 <slm_blkpt_block+0x465>
  4015b3:	48 89 f0             	mov    rax,rsi
  4015b6:	f0 48 0f b1 1d 01 09 	lock cmpxchg QWORD PTR [rip+0x1a0901],rbx        # 5a1ec0 <__slm_global>
  4015bd:	1a 00 
  4015bf:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4015c2:	84 c0                	test   al,al
  4015c4:	0f 85 64 fe ff ff    	jne    40142e <slm_blkpt_block+0x25e>
  4015ca:	eb cb                	jmp    401597 <slm_blkpt_block+0x3c7>
  4015cc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  4015d0:	be 61 00 00 00       	mov    esi,0x61
  4015d5:	bf 48 c8 41 00       	mov    edi,0x41c848
  4015da:	e8 f1 8a 00 00       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  4015df:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4015e6:	00 00 00 00 
  4015ea:	0f 0b                	ud2    
			prio    = curr->priority;
  4015ec:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
			timeout = TCAP_TIME_NIL;
  4015f0:	31 c9                	xor    ecx,ecx
  4015f2:	e9 48 ff ff ff       	jmp    40153f <slm_blkpt_block+0x36f>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  4015f7:	49 8b 7d 28          	mov    rdi,QWORD PTR [r13+0x28]
  4015fb:	48 8b 15 e6 08 1a 00 	mov    rdx,QWORD PTR [rip+0x1a08e6]        # 5a1ee8 <__slm_global+0x28>
  401602:	44 89 f1             	mov    ecx,r14d
  401605:	4c 89 c6             	mov    rsi,r8
  401608:	e8 83 fd 00 00       	call   411390 <cos_sched_asnd>
  40160d:	e9 5d ff ff ff       	jmp    40156f <slm_blkpt_block+0x39f>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  401612:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]
  401616:	4c 8b 05 cb 08 1a 00 	mov    r8,QWORD PTR [rip+0x1a08cb]        # 5a1ee8 <__slm_global+0x28>
  40161d:	45 89 f1             	mov    r9d,r14d
  401620:	31 c9                	xor    ecx,ecx
  401622:	48 8b 3d af 08 1a 00 	mov    rdi,QWORD PTR [rip+0x1a08af]        # 5a1ed8 <__slm_global+0x18>
  401629:	31 f6                	xor    esi,esi
  40162b:	e8 f0 fc 00 00       	call   411320 <cos_switch>
  401630:	e9 3a ff ff ff       	jmp    40156f <slm_blkpt_block+0x39f>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  401635:	41 89 f0             	mov    r8d,esi
  401638:	48 89 da             	mov    rdx,rbx
  40163b:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  401640:	41 83 e0 01          	and    r8d,0x1
  401644:	e8 c7 21 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  401649:	83 f8 f0             	cmp    eax,0xfffffff0
  40164c:	0f 85 45 ff ff ff    	jne    401597 <slm_blkpt_block+0x3c7>
  401652:	e9 89 fd ff ff       	jmp    4013e0 <slm_blkpt_block+0x210>
  401657:	be 61 00 00 00       	mov    esi,0x61
  40165c:	bf 80 c9 41 00       	mov    edi,0x41c980
  401661:	e8 6a 8a 00 00       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  401666:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40166d:	00 00 00 00 
  401671:	0f 0b                	ud2    
  401673:	be 61 00 00 00       	mov    esi,0x61
  401678:	bf 18 c9 41 00       	mov    edi,0x41c918
  40167d:	e8 4e 8a 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  401682:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401689:	00 00 00 00 
  40168d:	0f 0b                	ud2    
  40168f:	90                   	nop

0000000000401690 <slm_thd_timer_policy>:
SLM_MODULES_COMPOSE_DATA();
  401690:	f3 0f 1e fa          	endbr64 
  401694:	48 8d 87 88 00 00 00 	lea    rax,[rdi+0x88]
  40169b:	c3                   	ret    
  40169c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

00000000004016a0 <slm_thd_sched_policy>:
  4016a0:	f3 0f 1e fa          	endbr64 
  4016a4:	48 8d 47 78          	lea    rax,[rdi+0x78]
  4016a8:	c3                   	ret    
  4016a9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

00000000004016b0 <slm_thd_from_timer>:
  4016b0:	f3 0f 1e fa          	endbr64 
  4016b4:	48 8d 87 78 ff ff ff 	lea    rax,[rdi-0x88]
  4016bb:	c3                   	ret    
  4016bc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

00000000004016c0 <slm_thd_from_sched>:
  4016c0:	f3 0f 1e fa          	endbr64 
  4016c4:	48 8d 47 88          	lea    rax,[rdi-0x78]
  4016c8:	c3                   	ret    
  4016c9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

00000000004016d0 <slm_timer_expire>:
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  4016d0:	f3 0f 1e fa          	endbr64 
  4016d4:	e9 e7 13 01 00       	jmp    412ac0 <slm_timer_quantum_expire>
  4016d9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

00000000004016e0 <slm_timer_thd_init>:
  4016e0:	f3 0f 1e fa          	endbr64 
  4016e4:	e9 77 16 01 00       	jmp    412d60 <slm_timer_quantum_thd_init>
  4016e9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

00000000004016f0 <slm_timer_thd_deinit>:
  4016f0:	f3 0f 1e fa          	endbr64 
  4016f4:	e9 87 16 01 00       	jmp    412d80 <slm_timer_quantum_thd_deinit>
  4016f9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401700 <slm_timer_add>:
  401700:	f3 0f 1e fa          	endbr64 
  401704:	e9 47 15 01 00       	jmp    412c50 <slm_timer_quantum_add>
  401709:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401710 <slm_timer_cancel>:
  401710:	f3 0f 1e fa          	endbr64 
  401714:	e9 c7 15 01 00       	jmp    412ce0 <slm_timer_quantum_cancel>
  401719:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401720 <slm_timer_init>:
  401720:	f3 0f 1e fa          	endbr64 
  401724:	e9 67 16 01 00       	jmp    412d90 <slm_timer_quantum_init>
  401729:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401730 <slm_sched_init>:
  401730:	f3 0f 1e fa          	endbr64 
  401734:	e9 47 10 01 00       	jmp    412780 <slm_sched_fprr_init>
  401739:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401740 <slm_sched_thd_init>:
  401740:	f3 0f 1e fa          	endbr64 
  401744:	e9 a7 0e 01 00       	jmp    4125f0 <slm_sched_fprr_thd_init>
  401749:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401750 <slm_sched_thd_deinit>:
  401750:	f3 0f 1e fa          	endbr64 
  401754:	e9 c7 0e 01 00       	jmp    412620 <slm_sched_fprr_thd_deinit>
  401759:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401760 <slm_sched_thd_update>:
  401760:	f3 0f 1e fa          	endbr64 
  401764:	e9 e7 0e 01 00       	jmp    412650 <slm_sched_fprr_thd_update>
  401769:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401770 <slm_sched_block>:
  401770:	f3 0f 1e fa          	endbr64 
  401774:	e9 77 0d 01 00       	jmp    4124f0 <slm_sched_fprr_block>
  401779:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401780 <slm_sched_wakeup>:
  401780:	f3 0f 1e fa          	endbr64 
  401784:	e9 97 0d 01 00       	jmp    412520 <slm_sched_fprr_wakeup>
  401789:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401790 <slm_sched_yield>:
  401790:	f3 0f 1e fa          	endbr64 
  401794:	e9 f7 0d 01 00       	jmp    412590 <slm_sched_fprr_yield>
  401799:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

00000000004017a0 <slm_sched_schedule>:
  4017a0:	f3 0f 1e fa          	endbr64 
  4017a4:	e9 e7 0c 01 00       	jmp    412490 <slm_sched_fprr_schedule>
  4017a9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

00000000004017b0 <slm_sched_execution>:
  4017b0:	f3 0f 1e fa          	endbr64 
  4017b4:	e9 c7 0c 01 00       	jmp    412480 <slm_sched_fprr_execution>
  4017b9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

00000000004017c0 <slm_thd_lookup>:
  4017c0:	f3 0f 1e fa          	endbr64 
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  4017c4:	85 ff                	test   edi,edi
  4017c6:	74 38                	je     401800 <slm_thd_lookup+0x40>
  4017c8:	83 ef 01             	sub    edi,0x1
  4017cb:	83 ff 18             	cmp    edi,0x18
  4017ce:	77 30                	ja     401800 <slm_thd_lookup+0x40>
  4017d0:	48 8b 14 fd 00 e7 45 	mov    rdx,QWORD PTR [rdi*8+0x45e700]
  4017d7:	00 
  4017d8:	31 c0                	xor    eax,eax
  4017da:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  4017e1:	74 1f                	je     401802 <slm_thd_lookup+0x42>
  4017e3:	83 e2 01             	and    edx,0x1
  4017e6:	75 1a                	jne    401802 <slm_thd_lookup+0x42>
  4017e8:	48 8d 04 bf          	lea    rax,[rdi+rdi*4]
  4017ec:	48 8d 04 47          	lea    rax,[rdi+rax*2]
  4017f0:	48 c1 e0 04          	shl    rax,0x4
  4017f4:	48 05 c8 e7 45 00    	add    rax,0x45e7c8
  4017fa:	c3                   	ret    
  4017fb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  401800:	31 c0                	xor    eax,eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  401802:	c3                   	ret    
  401803:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40180a:	00 00 00 00 
  40180e:	66 90                	xchg   ax,ax

0000000000401810 <ss_thd_intern_is_allocated>:
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  401810:	f3 0f 1e fa          	endbr64 
  401814:	48 8d 87 c8 00 00 00 	lea    rax,[rdi+0xc8]
  40181b:	48 39 c6             	cmp    rsi,rax
  40181e:	72 32                	jb     401852 <ss_thd_intern_is_allocated+0x42>
  401820:	48 8d 97 48 11 00 00 	lea    rdx,[rdi+0x1148]
  401827:	48 39 d6             	cmp    rsi,rdx
  40182a:	77 26                	ja     401852 <ss_thd_intern_is_allocated+0x42>
  40182c:	48 29 c6             	sub    rsi,rax
  40182f:	48 c1 fe 04          	sar    rsi,0x4
  401833:	69 c6 a3 8b 2e ba    	imul   eax,esi,0xba2e8ba3
  401839:	48 8b 04 c7          	mov    rax,QWORD PTR [rdi+rax*8]
  40183d:	48 89 c2             	mov    rdx,rax
  401840:	83 e2 01             	and    edx,0x1
  401843:	48 a9 fe ff ff ff    	test   rax,0xfffffffffffffffe
  401849:	b8 01 00 00 00       	mov    eax,0x1
  40184e:	0f 45 c2             	cmovne eax,edx
  401851:	c3                   	ret    
  401852:	55                   	push   rbp
  401853:	be 23 00 00 00       	mov    esi,0x23
  401858:	bf 08 cb 41 00       	mov    edi,0x41cb08
  40185d:	48 89 e5             	mov    rbp,rsp
  401860:	e8 6b 88 00 00       	call   40a0d0 <cos_print_str>
  401865:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40186c:	00 00 00 00 
  401870:	0f 0b                	ud2    
  401872:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  401879:	00 00 00 00 
  40187d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000401880 <ss_thd_is_allocated>:
  401880:	f3 0f 1e fa          	endbr64 
  401884:	48 81 ff 48 f8 45 00 	cmp    rdi,0x45f848
  40188b:	77 37                	ja     4018c4 <ss_thd_is_allocated+0x44>
  40188d:	48 81 ff c8 e7 45 00 	cmp    rdi,0x45e7c8
  401894:	72 2e                	jb     4018c4 <ss_thd_is_allocated+0x44>
  401896:	48 81 ef c8 e7 45 00 	sub    rdi,0x45e7c8
  40189d:	48 c1 ff 04          	sar    rdi,0x4
  4018a1:	69 c7 a3 8b 2e ba    	imul   eax,edi,0xba2e8ba3
  4018a7:	48 8b 04 c5 00 e7 45 	mov    rax,QWORD PTR [rax*8+0x45e700]
  4018ae:	00 
  4018af:	48 89 c2             	mov    rdx,rax
  4018b2:	83 e2 01             	and    edx,0x1
  4018b5:	48 a9 fe ff ff ff    	test   rax,0xfffffffffffffffe
  4018bb:	b8 01 00 00 00       	mov    eax,0x1
  4018c0:	0f 45 c2             	cmovne eax,edx
  4018c3:	c3                   	ret    
  4018c4:	55                   	push   rbp
  4018c5:	be 23 00 00 00       	mov    esi,0x23
  4018ca:	bf 08 cb 41 00       	mov    edi,0x41cb08
  4018cf:	48 89 e5             	mov    rbp,rsp
  4018d2:	e8 f9 87 00 00       	call   40a0d0 <cos_print_str>
  4018d7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4018de:	00 00 00 00 
  4018e2:	0f 0b                	ud2    
  4018e4:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4018eb:	00 00 00 00 
  4018ef:	90                   	nop

00000000004018f0 <slm_thd_static_cm_lookup>:
  4018f0:	f3 0f 1e fa          	endbr64 
  4018f4:	85 ff                	test   edi,edi
  4018f6:	74 38                	je     401930 <slm_thd_static_cm_lookup+0x40>
  4018f8:	83 ef 01             	sub    edi,0x1
  4018fb:	83 ff 18             	cmp    edi,0x18
  4018fe:	77 30                	ja     401930 <slm_thd_static_cm_lookup+0x40>
  401900:	48 8b 14 fd 00 e7 45 	mov    rdx,QWORD PTR [rdi*8+0x45e700]
  401907:	00 
  401908:	31 c0                	xor    eax,eax
  40190a:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  401911:	74 1f                	je     401932 <slm_thd_static_cm_lookup+0x42>
  401913:	83 e2 01             	and    edx,0x1
  401916:	75 1a                	jne    401932 <slm_thd_static_cm_lookup+0x42>
  401918:	48 8d 04 bf          	lea    rax,[rdi+rdi*4]
  40191c:	48 8d 04 47          	lea    rax,[rdi+rax*2]
  401920:	48 c1 e0 04          	shl    rax,0x4
  401924:	48 05 c8 e7 45 00    	add    rax,0x45e7c8
  40192a:	c3                   	ret    
  40192b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  401930:	31 c0                	xor    eax,eax
  401932:	c3                   	ret    
  401933:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40193a:	00 00 00 00 
  40193e:	66 90                	xchg   ax,ax

0000000000401940 <slm_thd_current_extern>:
{
  401940:	f3 0f 1e fa          	endbr64 
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  401944:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  401947:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  40194d:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  401954:	48 85 c0             	test   rax,rax
  401957:	74 3f                	je     401998 <slm_thd_current_extern+0x58>
  401959:	83 e8 01             	sub    eax,0x1
  40195c:	83 f8 18             	cmp    eax,0x18
  40195f:	77 37                	ja     401998 <slm_thd_current_extern+0x58>
  401961:	48 8b 14 c5 00 e7 45 	mov    rdx,QWORD PTR [rax*8+0x45e700]
  401968:	00 
  401969:	45 31 c0             	xor    r8d,r8d
  40196c:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  401973:	74 18                	je     40198d <slm_thd_current_extern+0x4d>
  401975:	83 e2 01             	and    edx,0x1
  401978:	75 13                	jne    40198d <slm_thd_current_extern+0x4d>
  40197a:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  40197e:	4c 8d 04 50          	lea    r8,[rax+rdx*2]
  401982:	49 c1 e0 04          	shl    r8,0x4
  401986:	49 81 c0 c8 e7 45 00 	add    r8,0x45e7c8
}
  40198d:	4c 89 c0             	mov    rax,r8
  401990:	c3                   	ret    
  401991:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  401998:	45 31 c0             	xor    r8d,r8d
}
  40199b:	4c 89 c0             	mov    rax,r8
  40199e:	c3                   	ret    
  40199f:	90                   	nop

00000000004019a0 <slm_thd_from_container>:
slm_thd_from_container(struct slm_thd_container *c) {
  4019a0:	f3 0f 1e fa          	endbr64 
  4019a4:	48 89 f8             	mov    rax,rdi
}
  4019a7:	c3                   	ret    
  4019a8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4019af:	00 

00000000004019b0 <slm_thd_mem_alloc>:
{
  4019b0:	f3 0f 1e fa          	endbr64 
  4019b4:	55                   	push   rbp
  4019b5:	66 48 0f 6e c7       	movq   xmm0,rdi
  4019ba:	66 48 0f 6e ce       	movq   xmm1,rsi
  4019bf:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  4019c3:	48 89 e5             	mov    rbp,rsp
  4019c6:	53                   	push   rbx
  4019c7:	48 83 ec 08          	sub    rsp,0x8
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  4019cb:	85 f6                	test   esi,esi
  4019cd:	0f 84 85 00 00 00    	je     401a58 <slm_thd_mem_alloc+0xa8>
  4019d3:	49 89 d2             	mov    r10,rdx
  4019d6:	8d 56 ff             	lea    edx,[rsi-0x1]
  4019d9:	83 fa 18             	cmp    edx,0x18
  4019dc:	77 7a                	ja     401a58 <slm_thd_mem_alloc+0xa8>
	if (*state != SS_STATE_FREE ||
  4019de:	48 83 3c d5 00 e7 45 	cmp    QWORD PTR [rdx*8+0x45e700],0x0
  4019e5:	00 00 
  4019e7:	75 6f                	jne    401a58 <slm_thd_mem_alloc+0xa8>
  4019e9:	31 db                	xor    ebx,ebx
  4019eb:	49 89 c9             	mov    r9,rcx
  4019ee:	b9 01 00 00 00       	mov    ecx,0x1
  4019f3:	48 89 d8             	mov    rax,rbx
  4019f6:	f0 48 0f b1 0c d5 00 	lock cmpxchg QWORD PTR [rdx*8+0x45e700],rcx
  4019fd:	e7 45 00 
  401a00:	0f 94 c0             	sete   al
  401a03:	84 c0                	test   al,al
  401a05:	74 51                	je     401a58 <slm_thd_mem_alloc+0xa8>
  401a07:	48 8d 04 92          	lea    rax,[rdx+rdx*4]
  401a0b:	49 89 f8             	mov    r8,rdi
  401a0e:	b9 16 00 00 00       	mov    ecx,0x16
  401a13:	48 8d 14 42          	lea    rdx,[rdx+rax*2]
  401a17:	48 89 d8             	mov    rax,rbx
  401a1a:	48 c1 e2 04          	shl    rdx,0x4
  401a1e:	4c 8d 9a c8 e7 45 00 	lea    r11,[rdx+0x45e7c8]
  401a25:	4c 89 df             	mov    rdi,r11
  401a28:	f3 48 ab             	rep stos QWORD PTR es:[rdi],rax
	assert(_cap != 0 && _tid != 0);
  401a2b:	4d 85 c0             	test   r8,r8
  401a2e:	74 44                	je     401a74 <slm_thd_mem_alloc+0xc4>
	t->resources = (struct slm_resources_thd) {
  401a30:	48 8b 05 09 56 02 00 	mov    rax,QWORD PTR [rip+0x25609]        # 427040 <__cosrt_comp_info+0x40>
  401a37:	0f 29 82 60 e8 45 00 	movaps XMMWORD PTR [rdx+0x45e860],xmm0
}
  401a3e:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
	t->resources = (struct slm_resources_thd) {
  401a42:	48 89 82 70 e8 45 00 	mov    QWORD PTR [rdx+0x45e870],rax
}
  401a49:	4c 89 d8             	mov    rax,r11
	*thd = _cap;
  401a4c:	4d 89 02             	mov    QWORD PTR [r10],r8
	*tid = _tid;
  401a4f:	49 89 31             	mov    QWORD PTR [r9],rsi
}
  401a52:	c9                   	leave  
  401a53:	c3                   	ret    
  401a54:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  401a58:	be 23 00 00 00       	mov    esi,0x23
  401a5d:	bf 30 cb 41 00       	mov    edi,0x41cb30
  401a62:	e8 69 86 00 00       	call   40a0d0 <cos_print_str>
	if (!t) assert(0);
  401a67:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401a6e:	00 00 00 00 
  401a72:	0f 0b                	ud2    
  401a74:	be 23 00 00 00       	mov    esi,0x23
  401a79:	bf 58 cb 41 00       	mov    edi,0x41cb58
  401a7e:	e8 4d 86 00 00       	call   40a0d0 <cos_print_str>
	assert(_cap != 0 && _tid != 0);
  401a83:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401a8a:	00 00 00 00 
  401a8e:	0f 0b                	ud2    

0000000000401a90 <slm_thd_mem_activate>:
void slm_thd_mem_activate(struct slm_thd_container *t) { ss_thd_activate(t); }
  401a90:	f3 0f 1e fa          	endbr64 
  401a94:	55                   	push   rbp
  401a95:	48 89 e5             	mov    rbp,rsp
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  401a98:	48 81 ff c8 e7 45 00 	cmp    rdi,0x45e7c8
  401a9f:	72 50                	jb     401af1 <slm_thd_mem_activate+0x61>
  401aa1:	48 81 ff 48 f8 45 00 	cmp    rdi,0x45f848
  401aa8:	77 47                	ja     401af1 <slm_thd_mem_activate+0x61>
  401aaa:	48 81 ef c8 e7 45 00 	sub    rdi,0x45e7c8
  401ab1:	48 c1 ff 04          	sar    rdi,0x4
 */
static inline void
ss_state_activate_with(ss_state_t *state, word_t val)
{
	assert(val != 0);
	*state = val | (*state & 1);
  401ab5:	69 c7 a3 8b 2e ba    	imul   eax,edi,0xba2e8ba3
  401abb:	48 8b 14 c5 00 e7 45 	mov    rdx,QWORD PTR [rax*8+0x45e700]
  401ac2:	00 
  401ac3:	48 83 ca fe          	or     rdx,0xfffffffffffffffe
  401ac7:	48 89 14 c5 00 e7 45 	mov    QWORD PTR [rax*8+0x45e700],rdx
  401ace:	00 
	assert((*state & 1) == SS_STATE_CONS);
  401acf:	48 83 fa ff          	cmp    rdx,0xffffffffffffffff
  401ad3:	75 38                	jne    401b0d <slm_thd_mem_activate+0x7d>
	*state &= ~SS_STATE_CONS;
  401ad5:	48 c7 04 c5 00 e7 45 	mov    QWORD PTR [rax*8+0x45e700],0xfffffffffffffffe
  401adc:	00 fe ff ff ff 
{ __asm__ __volatile__("mfence" ::: "memory"); }
  401ae1:	0f ae f0             	mfence 
	assert(*state != 0);
  401ae4:	48 83 3c c5 00 e7 45 	cmp    QWORD PTR [rax*8+0x45e700],0x0
  401aeb:	00 00 
  401aed:	74 3a                	je     401b29 <slm_thd_mem_activate+0x99>
void slm_thd_mem_activate(struct slm_thd_container *t) { ss_thd_activate(t); }
  401aef:	5d                   	pop    rbp
  401af0:	c3                   	ret    
  401af1:	be 23 00 00 00       	mov    esi,0x23
  401af6:	bf 08 cb 41 00       	mov    edi,0x41cb08
  401afb:	e8 d0 85 00 00       	call   40a0d0 <cos_print_str>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  401b00:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401b07:	00 00 00 00 
  401b0b:	0f 0b                	ud2    
  401b0d:	be 61 00 00 00       	mov    esi,0x61
  401b12:	bf 80 cb 41 00       	mov    edi,0x41cb80
  401b17:	e8 b4 85 00 00       	call   40a0d0 <cos_print_str>
	assert((*state & 1) == SS_STATE_CONS);
  401b1c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401b23:	00 00 00 00 
  401b27:	0f 0b                	ud2    
  401b29:	be 61 00 00 00       	mov    esi,0x61
  401b2e:	bf e8 cb 41 00       	mov    edi,0x41cbe8
  401b33:	e8 98 85 00 00       	call   40a0d0 <cos_print_str>
	assert(*state != 0);
  401b38:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401b3f:	00 00 00 00 
  401b43:	0f 0b                	ud2    
  401b45:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  401b4c:	00 00 00 00 

0000000000401b50 <slm_thd_mem_free>:
void slm_thd_mem_free(struct slm_thd_container *t) { return; }
  401b50:	f3 0f 1e fa          	endbr64 
  401b54:	c3                   	ret    
  401b55:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  401b5c:	00 00 00 00 

0000000000401b60 <sched_thd_create_closure>:
{
  401b60:	f3 0f 1e fa          	endbr64 
  401b64:	55                   	push   rbp
  401b65:	89 fe                	mov    esi,edi
	struct slm_thd *t = thd_alloc_in(cos_inv_token(), idx, &p, 0);
  401b67:	31 c9                	xor    ecx,ecx
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  401b69:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  401b6c:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
{
  401b72:	48 89 e5             	mov    rbp,rsp
  401b75:	48 83 ec 10          	sub    rsp,0x10
	struct slm_thd *t = thd_alloc_in(cos_inv_token(), idx, &p, 0);
  401b79:	48 8b b8 e8 1f 00 00 	mov    rdi,QWORD PTR [rax+0x1fe8]
  401b80:	48 8d 55 fc          	lea    rdx,[rbp-0x4]
	sched_param_t p = 0;
  401b84:	c7 45 fc 00 00 00 00 	mov    DWORD PTR [rbp-0x4],0x0
	struct slm_thd *t = thd_alloc_in(cos_inv_token(), idx, &p, 0);
  401b8b:	e8 d0 31 00 00       	call   404d60 <thd_alloc_in>
	if (!t) return 0;
  401b90:	48 85 c0             	test   rax,rax
  401b93:	74 0b                	je     401ba0 <sched_thd_create_closure+0x40>
	return t->tid;
  401b95:	48 8b 40 18          	mov    rax,QWORD PTR [rax+0x18]
}
  401b99:	c9                   	leave  
  401b9a:	c3                   	ret    
  401b9b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  401ba0:	c9                   	leave  
	if (!t) return 0;
  401ba1:	31 c0                	xor    eax,eax
}
  401ba3:	c3                   	ret    
  401ba4:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  401bab:	00 00 00 00 
  401baf:	90                   	nop

0000000000401bb0 <sched_thd_param_set>:
{
  401bb0:	f3 0f 1e fa          	endbr64 

static inline void
sched_param_get(sched_param_t sp, sched_param_type_t *type, unsigned int *value)
{
	if (type)  *type  = (sched_param_type_t)(sp &  SCHED_PARAM_TYPE_MASK);
	if (value) *value = (unsigned int)      (sp >> SCHED_PARAM_TYPE_BITS);
  401bb4:	89 f2                	mov    edx,esi
	if (type)  *type  = (sched_param_type_t)(sp &  SCHED_PARAM_TYPE_MASK);
  401bb6:	83 e6 3f             	and    esi,0x3f
	if (value) *value = (unsigned int)      (sp >> SCHED_PARAM_TYPE_BITS);
  401bb9:	c1 ea 06             	shr    edx,0x6
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  401bbc:	85 ff                	test   edi,edi
  401bbe:	74 38                	je     401bf8 <sched_thd_param_set+0x48>
  401bc0:	83 ef 01             	sub    edi,0x1
  401bc3:	83 ff 18             	cmp    edi,0x18
  401bc6:	77 30                	ja     401bf8 <sched_thd_param_set+0x48>
  401bc8:	48 8b 04 fd 00 e7 45 	mov    rax,QWORD PTR [rdi*8+0x45e700]
  401bcf:	00 
	return ((state & ~1) != 0) && ((state & 1) == SS_STATE_ALLOC);
  401bd0:	48 a9 fe ff ff ff    	test   rax,0xfffffffffffffffe
  401bd6:	74 20                	je     401bf8 <sched_thd_param_set+0x48>
  401bd8:	a8 01                	test   al,0x1
  401bda:	75 1c                	jne    401bf8 <sched_thd_param_set+0x48>
	return &ss_thd_get(id)->thd;
  401bdc:	48 8d 04 bf          	lea    rax,[rdi+rdi*4]
  401be0:	48 8d 3c 47          	lea    rdi,[rdi+rax*2]
  401be4:	48 c1 e7 04          	shl    rdi,0x4
  401be8:	48 81 c7 c8 e7 45 00 	add    rdi,0x45e7c8
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  401bef:	e9 5c 0a 01 00       	jmp    412650 <slm_sched_fprr_thd_update>
  401bf4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
}
  401bf8:	b8 ff ff ff ff       	mov    eax,0xffffffff
  401bfd:	c3                   	ret    
  401bfe:	66 90                	xchg   ax,ax

0000000000401c00 <sched_thd_delete>:
{
  401c00:	f3 0f 1e fa          	endbr64 
}
  401c04:	31 c0                	xor    eax,eax
  401c06:	c3                   	ret    
  401c07:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  401c0e:	00 00 

0000000000401c10 <sched_thd_exit>:
{
  401c10:	f3 0f 1e fa          	endbr64 
  401c14:	55                   	push   rbp
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  401c15:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  401c18:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  401c1e:	48 89 e5             	mov    rbp,rsp
  401c21:	41 57                	push   r15
  401c23:	41 56                	push   r14
  401c25:	41 55                	push   r13
  401c27:	41 54                	push   r12
  401c29:	53                   	push   rbx
  401c2a:	48 83 ec 08          	sub    rsp,0x8
  401c2e:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  401c35:	48 85 c0             	test   rax,rax
  401c38:	0f 84 22 02 00 00    	je     401e60 <sched_thd_exit+0x250>
  401c3e:	83 e8 01             	sub    eax,0x1
  401c41:	83 f8 18             	cmp    eax,0x18
  401c44:	0f 87 16 02 00 00    	ja     401e60 <sched_thd_exit+0x250>
  401c4a:	48 8b 14 c5 00 e7 45 	mov    rdx,QWORD PTR [rax*8+0x45e700]
  401c51:	00 
  401c52:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  401c59:	0f 84 01 02 00 00    	je     401e60 <sched_thd_exit+0x250>
  401c5f:	80 e2 01             	and    dl,0x1
  401c62:	0f 85 f8 01 00 00    	jne    401e60 <sched_thd_exit+0x250>
  401c68:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  401c6c:	4c 8d 34 50          	lea    r14,[rax+rdx*2]
  401c70:	49 c1 e6 04          	shl    r14,0x4
  401c74:	49 81 c6 c8 e7 45 00 	add    r14,0x45e7c8
		tok    = cos_sched_sync();
  401c7b:	e8 80 f6 00 00       	call   411300 <cos_sched_sync>
  401c80:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  401c83:	48 8b 05 36 02 1a 00 	mov    rax,QWORD PTR [rip+0x1a0236]        # 5a1ec0 <__slm_global>
		if (unlikely(owner)) {
  401c8a:	48 89 c1             	mov    rcx,rax
  401c8d:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  401c91:	0f 85 03 02 00 00    	jne    401e9a <sched_thd_exit+0x28a>
        __asm__ __volatile__("lock " PS_CAS_STR
  401c97:	f0 4c 0f b1 35 20 02 	lock cmpxchg QWORD PTR [rip+0x1a0220],r14        # 5a1ec0 <__slm_global>
  401c9e:	1a 00 
  401ca0:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  401ca3:	84 c0                	test   al,al
  401ca5:	74 d4                	je     401c7b <sched_thd_exit+0x6b>
	slm_thd_deinit(current);
  401ca7:	4c 89 f7             	mov    rdi,r14
	for (i = 0; slm_cs_exit_reschedule(current, SLM_CS_NONE) && i < 16; i++) ;
  401caa:	41 bd 11 00 00 00    	mov    r13d,0x11
	if (unlikely(!t)) t = &g->idle_thd;
  401cb0:	41 bf 40 1f 5a 00    	mov    r15d,0x5a1f40
	slm_thd_deinit(current);
  401cb6:	e8 25 1b 01 00       	call   4137e0 <slm_thd_deinit>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  401cbb:	e8 a0 9b 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	tok  = cos_sched_sync();
  401cc0:	e8 3b f6 00 00       	call   411300 <cos_sched_sync>
  401cc5:	41 89 c4             	mov    r12d,eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  401cc8:	e8 c3 07 01 00       	call   412490 <slm_sched_fprr_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  401ccd:	48 85 c0             	test   rax,rax
  401cd0:	48 89 c3             	mov    rbx,rax
  401cd3:	49 0f 44 df          	cmove  rbx,r15
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  401cd7:	8b 43 04             	mov    eax,DWORD PTR [rbx+0x4]
  401cda:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  401cdd:	83 f8 01             	cmp    eax,0x1
  401ce0:	76 1e                	jbe    401d00 <sched_thd_exit+0xf0>
  401ce2:	e9 95 00 00 00       	jmp    401d7c <sched_thd_exit+0x16c>
  401ce7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  401cee:	00 00 
  401cf0:	f0 48 0f b1 15 c7 01 	lock cmpxchg QWORD PTR [rip+0x1a01c7],rdx        # 5a1ec0 <__slm_global>
  401cf7:	1a 00 
  401cf9:	0f 94 c0             	sete   al
	while (ret != 0) {
  401cfc:	84 c0                	test   al,al
  401cfe:	75 2e                	jne    401d2e <sched_thd_exit+0x11e>
		tok    = cos_sched_sync();
  401d00:	e8 fb f5 00 00       	call   411300 <cos_sched_sync>
  401d05:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  401d07:	48 8b 05 b2 01 1a 00 	mov    rax,QWORD PTR [rip+0x1a01b2]        # 5a1ec0 <__slm_global>
		if (unlikely(contention)) {
  401d0e:	48 89 c2             	mov    rdx,rax
  401d11:	83 e2 01             	and    edx,0x1
  401d14:	74 da                	je     401cf0 <sched_thd_exit+0xe0>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  401d16:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  401d19:	48 89 c2             	mov    rdx,rax
  401d1c:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  401d21:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  401d25:	e8 36 1b 01 00       	call   413860 <slm_cs_exit_contention>
  401d2a:	85 c0                	test   eax,eax
  401d2c:	75 d2                	jne    401d00 <sched_thd_exit+0xf0>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  401d2e:	e8 2d 9b 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  401d33:	8b 03                	mov    eax,DWORD PTR [rbx]
	timeout = g->timeout_next;
  401d35:	4c 8b 05 8c 02 1a 00 	mov    r8,QWORD PTR [rip+0x1a028c]        # 5a1fc8 <__slm_global+0x108>
	prio = inherit_prio ? curr->priority : t->priority;
  401d3c:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  401d40:	a8 0b                	test   al,0xb
  401d42:	75 54                	jne    401d98 <sched_thd_exit+0x188>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  401d44:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  401d48:	44 89 e1             	mov    ecx,r12d
  401d4b:	4c 89 c2             	mov    rdx,r8
  401d4e:	e8 0d aa 00 00       	call   40c760 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  401d53:	83 f8 ff             	cmp    eax,0xffffffff
  401d56:	0f 84 ce 00 00 00    	je     401e2a <sched_thd_exit+0x21a>
	if (unlikely(ret != 0)) {
  401d5c:	85 c0                	test   eax,eax
  401d5e:	75 7d                	jne    401ddd <sched_thd_exit+0x1cd>
  401d60:	be 11 00 00 00       	mov    esi,0x11
  401d65:	bf 4a cc 41 00       	mov    edi,0x41cc4a
  401d6a:	e8 61 83 00 00       	call   40a0d0 <cos_print_str>
	BUG();
  401d6f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401d76:	00 00 00 00 
  401d7a:	0f 0b                	ud2    
  401d7c:	be 61 00 00 00       	mov    esi,0x61
  401d81:	bf 48 c8 41 00       	mov    edi,0x41c848
  401d86:	e8 45 83 00 00       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  401d8b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401d92:	00 00 00 00 
  401d96:	0f 0b                	ud2    
	timeout = g->timeout_next;
  401d98:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  401d9b:	48 81 fb c8 1e 5a 00 	cmp    rbx,0x5a1ec8
  401da2:	0f 84 e7 00 00 00    	je     401e8f <sched_thd_exit+0x27f>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  401da8:	a8 02                	test   al,0x2
  401daa:	0f 85 26 01 00 00    	jne    401ed6 <sched_thd_exit+0x2c6>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  401db0:	49 89 c8             	mov    r8,rcx
  401db3:	a8 01                	test   al,0x1
  401db5:	74 8d                	je     401d44 <sched_thd_exit+0x134>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  401db7:	4c 8b 53 08          	mov    r10,QWORD PTR [rbx+0x8]
  401dbb:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  401dbf:	48 89 f2             	mov    rdx,rsi
  401dc2:	45 89 e1             	mov    r9d,r12d
  401dc5:	4c 8b 05 1c 01 1a 00 	mov    r8,QWORD PTR [rip+0x1a011c]        # 5a1ee8 <__slm_global+0x28>
  401dcc:	4c 89 d6             	mov    rsi,r10
  401dcf:	e8 4c f5 00 00       	call   411320 <cos_switch>
	if (unlikely(ret != 0)) {
  401dd4:	85 c0                	test   eax,eax
  401dd6:	74 88                	je     401d60 <sched_thd_exit+0x150>
		assert(ret != -EPERM);
  401dd8:	83 f8 ff             	cmp    eax,0xffffffff
  401ddb:	74 67                	je     401e44 <sched_thd_exit+0x234>
		assert(ret != -EINVAL);
  401ddd:	83 f8 ea             	cmp    eax,0xffffffea
  401de0:	0f 84 2e 01 00 00    	je     401f14 <sched_thd_exit+0x304>
		if (ret == -EBUSY) return ret;
  401de6:	83 f8 f0             	cmp    eax,0xfffffff0
  401de9:	0f 84 91 00 00 00    	je     401e80 <sched_thd_exit+0x270>
		assert(ret == -EAGAIN);
  401def:	83 f8 f5             	cmp    eax,0xfffffff5
  401df2:	0f 85 5d 01 00 00    	jne    401f55 <sched_thd_exit+0x345>
		tok    = cos_sched_sync();
  401df8:	e8 03 f5 00 00       	call   411300 <cos_sched_sync>
  401dfd:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  401e00:	48 8b 05 b9 00 1a 00 	mov    rax,QWORD PTR [rip+0x1a00b9]        # 5a1ec0 <__slm_global>
		if (unlikely(owner)) {
  401e07:	48 89 c1             	mov    rcx,rax
  401e0a:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  401e0e:	0f 85 1c 01 00 00    	jne    401f30 <sched_thd_exit+0x320>
  401e14:	f0 4c 0f b1 35 a3 00 	lock cmpxchg QWORD PTR [rip+0x1a00a3],r14        # 5a1ec0 <__slm_global>
  401e1b:	1a 00 
  401e1d:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  401e20:	84 c0                	test   al,al
  401e22:	0f 85 98 fe ff ff    	jne    401cc0 <sched_thd_exit+0xb0>
  401e28:	eb ce                	jmp    401df8 <sched_thd_exit+0x1e8>
	return t != &g->idle_thd && t != &g->sched_thd;
  401e2a:	48 81 fb 40 1f 5a 00 	cmp    rbx,0x5a1f40
  401e31:	0f 84 ba 00 00 00    	je     401ef1 <sched_thd_exit+0x2e1>
  401e37:	48 81 fb c8 1e 5a 00 	cmp    rbx,0x5a1ec8
  401e3e:	0f 84 ad 00 00 00    	je     401ef1 <sched_thd_exit+0x2e1>
  401e44:	be 61 00 00 00       	mov    esi,0x61
  401e49:	bf b0 c8 41 00       	mov    edi,0x41c8b0
  401e4e:	e8 7d 82 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EPERM);
  401e53:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401e5a:	00 00 00 00 
  401e5e:	0f 0b                	ud2    
  401e60:	be 59 00 00 00       	mov    esi,0x59
  401e65:	bf 60 c7 41 00       	mov    edi,0x41c760
  401e6a:	e8 61 82 00 00       	call   40a0d0 <cos_print_str>
	assert(current);
  401e6f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401e76:	00 00 00 00 
  401e7a:	0f 0b                	ud2    
  401e7c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	for (i = 0; slm_cs_exit_reschedule(current, SLM_CS_NONE) && i < 16; i++) ;
  401e80:	41 83 ed 01          	sub    r13d,0x1
  401e84:	0f 85 31 fe ff ff    	jne    401cbb <sched_thd_exit+0xab>
  401e8a:	e9 d1 fe ff ff       	jmp    401d60 <sched_thd_exit+0x150>
			prio    = curr->priority;
  401e8f:	49 8b 76 30          	mov    rsi,QWORD PTR [r14+0x30]
			timeout = TCAP_TIME_NIL;
  401e93:	31 c9                	xor    ecx,ecx
  401e95:	e9 0e ff ff ff       	jmp    401da8 <sched_thd_exit+0x198>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  401e9a:	41 89 c0             	mov    r8d,eax
  401e9d:	4c 89 f2             	mov    rdx,r14
  401ea0:	48 89 c6             	mov    rsi,rax
  401ea3:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  401ea8:	41 83 e0 01          	and    r8d,0x1
  401eac:	e8 5f 19 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  401eb1:	83 f8 f0             	cmp    eax,0xfffffff0
  401eb4:	0f 85 c1 fd ff ff    	jne    401c7b <sched_thd_exit+0x6b>
  401eba:	be 59 00 00 00       	mov    esi,0x59
  401ebf:	bf c0 c7 41 00       	mov    edi,0x41c7c0
  401ec4:	e8 07 82 00 00       	call   40a0d0 <cos_print_str>
  401ec9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401ed0:	00 00 00 00 
  401ed4:	0f 0b                	ud2    
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  401ed6:	48 8b 7b 28          	mov    rdi,QWORD PTR [rbx+0x28]
  401eda:	48 8b 15 07 00 1a 00 	mov    rdx,QWORD PTR [rip+0x1a0007]        # 5a1ee8 <__slm_global+0x28>
  401ee1:	44 89 e1             	mov    ecx,r12d
  401ee4:	4c 89 c6             	mov    rsi,r8
  401ee7:	e8 a4 f4 00 00       	call   411390 <cos_sched_asnd>
  401eec:	e9 e3 fe ff ff       	jmp    401dd4 <sched_thd_exit+0x1c4>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  401ef1:	49 8b 56 30          	mov    rdx,QWORD PTR [r14+0x30]
  401ef5:	4c 8b 05 ec ff 19 00 	mov    r8,QWORD PTR [rip+0x19ffec]        # 5a1ee8 <__slm_global+0x28>
  401efc:	45 89 e1             	mov    r9d,r12d
  401eff:	31 c9                	xor    ecx,ecx
  401f01:	48 8b 3d d0 ff 19 00 	mov    rdi,QWORD PTR [rip+0x19ffd0]        # 5a1ed8 <__slm_global+0x18>
  401f08:	31 f6                	xor    esi,esi
  401f0a:	e8 11 f4 00 00       	call   411320 <cos_switch>
  401f0f:	e9 c0 fe ff ff       	jmp    401dd4 <sched_thd_exit+0x1c4>
  401f14:	be 61 00 00 00       	mov    esi,0x61
  401f19:	bf 18 c9 41 00       	mov    edi,0x41c918
  401f1e:	e8 ad 81 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  401f23:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401f2a:	00 00 00 00 
  401f2e:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  401f30:	41 89 c0             	mov    r8d,eax
  401f33:	4c 89 f2             	mov    rdx,r14
  401f36:	48 89 c6             	mov    rsi,rax
  401f39:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  401f3e:	41 83 e0 01          	and    r8d,0x1
  401f42:	e8 c9 18 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  401f47:	83 f8 f0             	cmp    eax,0xfffffff0
  401f4a:	0f 85 a8 fe ff ff    	jne    401df8 <sched_thd_exit+0x1e8>
  401f50:	e9 65 ff ff ff       	jmp    401eba <sched_thd_exit+0x2aa>
  401f55:	be 61 00 00 00       	mov    esi,0x61
  401f5a:	bf 80 c9 41 00       	mov    edi,0x41c980
  401f5f:	e8 6c 81 00 00       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  401f64:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401f6b:	00 00 00 00 
  401f6f:	0f 0b                	ud2    
  401f71:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  401f78:	00 00 00 00 
  401f7c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000401f80 <sched_thd_yield_to>:
{
  401f80:	f3 0f 1e fa          	endbr64 
  401f84:	55                   	push   rbp
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  401f85:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  401f88:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  401f8e:	48 89 e5             	mov    rbp,rsp
  401f91:	41 56                	push   r14
  401f93:	41 55                	push   r13
  401f95:	41 54                	push   r12
  401f97:	53                   	push   rbx
  401f98:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  401f9f:	48 85 c0             	test   rax,rax
  401fa2:	0f 84 b0 01 00 00    	je     402158 <sched_thd_yield_to+0x1d8>
  401fa8:	83 e8 01             	sub    eax,0x1
  401fab:	83 f8 18             	cmp    eax,0x18
  401fae:	0f 87 a4 01 00 00    	ja     402158 <sched_thd_yield_to+0x1d8>
  401fb4:	48 8b 14 c5 00 e7 45 	mov    rdx,QWORD PTR [rax*8+0x45e700]
  401fbb:	00 
  401fbc:	45 31 e4             	xor    r12d,r12d
  401fbf:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  401fc6:	0f 85 44 01 00 00    	jne    402110 <sched_thd_yield_to+0x190>
  401fcc:	85 ff                	test   edi,edi
  401fce:	0f 84 64 01 00 00    	je     402138 <sched_thd_yield_to+0x1b8>
  401fd4:	83 ef 01             	sub    edi,0x1
  401fd7:	83 ff 18             	cmp    edi,0x18
  401fda:	0f 87 58 01 00 00    	ja     402138 <sched_thd_yield_to+0x1b8>
  401fe0:	89 f8                	mov    eax,edi
  401fe2:	48 8b 14 c5 00 e7 45 	mov    rdx,QWORD PTR [rax*8+0x45e700]
  401fe9:	00 
  401fea:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  401ff1:	0f 84 41 01 00 00    	je     402138 <sched_thd_yield_to+0x1b8>
  401ff7:	83 e2 01             	and    edx,0x1
  401ffa:	0f 85 38 01 00 00    	jne    402138 <sched_thd_yield_to+0x1b8>
	return &ss_thd_get(id)->thd;
  402000:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  402004:	48 8d 04 50          	lea    rax,[rax+rdx*2]
  402008:	48 c1 e0 04          	shl    rax,0x4
  40200c:	4c 8d a8 c8 e7 45 00 	lea    r13,[rax+0x45e7c8]
	assert(current);
  402013:	4d 85 e4             	test   r12,r12
  402016:	0f 84 80 01 00 00    	je     40219c <sched_thd_yield_to+0x21c>
		tok    = cos_sched_sync();
  40201c:	e8 df f2 00 00       	call   411300 <cos_sched_sync>
  402021:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  402024:	48 8b 05 95 fe 19 00 	mov    rax,QWORD PTR [rip+0x19fe95]        # 5a1ec0 <__slm_global>
		if (unlikely(owner)) {
  40202b:	48 89 c1             	mov    rcx,rax
  40202e:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  402032:	0f 85 28 01 00 00    	jne    402160 <sched_thd_yield_to+0x1e0>
  402038:	f0 4c 0f b1 25 7f fe 	lock cmpxchg QWORD PTR [rip+0x19fe7f],r12        # 5a1ec0 <__slm_global>
  40203f:	19 00 
  402041:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  402044:	84 c0                	test   al,al
  402046:	74 d4                	je     40201c <sched_thd_yield_to+0x9c>
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  402048:	4c 89 ee             	mov    rsi,r13
  40204b:	4c 89 e7             	mov    rdi,r12
	if (unlikely(!t)) t = &g->idle_thd;
  40204e:	41 be 40 1f 5a 00    	mov    r14d,0x5a1f40
  402054:	e8 37 05 01 00       	call   412590 <slm_sched_fprr_yield>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  402059:	e8 02 98 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	tok  = cos_sched_sync();
  40205e:	e8 9d f2 00 00       	call   411300 <cos_sched_sync>
  402063:	41 89 c5             	mov    r13d,eax
  402066:	e8 25 04 01 00       	call   412490 <slm_sched_fprr_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  40206b:	48 85 c0             	test   rax,rax
  40206e:	48 89 c3             	mov    rbx,rax
  402071:	49 0f 44 de          	cmove  rbx,r14
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  402075:	8b 43 04             	mov    eax,DWORD PTR [rbx+0x4]
  402078:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  40207b:	83 f8 01             	cmp    eax,0x1
  40207e:	76 18                	jbe    402098 <sched_thd_yield_to+0x118>
  402080:	e9 33 01 00 00       	jmp    4021b8 <sched_thd_yield_to+0x238>
  402085:	0f 1f 00             	nop    DWORD PTR [rax]
  402088:	f0 48 0f b1 15 2f fe 	lock cmpxchg QWORD PTR [rip+0x19fe2f],rdx        # 5a1ec0 <__slm_global>
  40208f:	19 00 
  402091:	0f 94 c0             	sete   al
	while (ret != 0) {
  402094:	84 c0                	test   al,al
  402096:	75 2e                	jne    4020c6 <sched_thd_yield_to+0x146>
		tok    = cos_sched_sync();
  402098:	e8 63 f2 00 00       	call   411300 <cos_sched_sync>
  40209d:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  40209f:	48 8b 05 1a fe 19 00 	mov    rax,QWORD PTR [rip+0x19fe1a]        # 5a1ec0 <__slm_global>
		if (unlikely(contention)) {
  4020a6:	48 89 c2             	mov    rdx,rax
  4020a9:	83 e2 01             	and    edx,0x1
  4020ac:	74 da                	je     402088 <sched_thd_yield_to+0x108>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  4020ae:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  4020b1:	48 89 c2             	mov    rdx,rax
  4020b4:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  4020b9:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  4020bd:	e8 9e 17 01 00       	call   413860 <slm_cs_exit_contention>
  4020c2:	85 c0                	test   eax,eax
  4020c4:	75 d2                	jne    402098 <sched_thd_yield_to+0x118>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  4020c6:	e8 95 97 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4020cb:	8b 03                	mov    eax,DWORD PTR [rbx]
	timeout = g->timeout_next;
  4020cd:	4c 8b 05 f4 fe 19 00 	mov    r8,QWORD PTR [rip+0x19fef4]        # 5a1fc8 <__slm_global+0x108>
	prio = inherit_prio ? curr->priority : t->priority;
  4020d4:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4020d8:	a8 0b                	test   al,0xb
  4020da:	0f 85 f4 00 00 00    	jne    4021d4 <sched_thd_yield_to+0x254>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  4020e0:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  4020e4:	44 89 e9             	mov    ecx,r13d
  4020e7:	4c 89 c2             	mov    rdx,r8
  4020ea:	e8 71 a6 00 00       	call   40c760 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  4020ef:	83 f8 ff             	cmp    eax,0xffffffff
  4020f2:	0f 84 1e 01 00 00    	je     402216 <sched_thd_yield_to+0x296>
	if (unlikely(ret != 0)) {
  4020f8:	85 c0                	test   eax,eax
  4020fa:	0f 85 70 01 00 00    	jne    402270 <sched_thd_yield_to+0x2f0>
  402100:	31 c0                	xor    eax,eax
}
  402102:	5b                   	pop    rbx
  402103:	41 5c                	pop    r12
  402105:	41 5d                	pop    r13
  402107:	41 5e                	pop    r14
  402109:	5d                   	pop    rbp
  40210a:	c3                   	ret    
  40210b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  402110:	83 e2 01             	and    edx,0x1
  402113:	0f 85 b3 fe ff ff    	jne    401fcc <sched_thd_yield_to+0x4c>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  402119:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  40211d:	4c 8d 24 50          	lea    r12,[rax+rdx*2]
  402121:	49 c1 e4 04          	shl    r12,0x4
  402125:	49 81 c4 c8 e7 45 00 	add    r12,0x45e7c8
  40212c:	85 ff                	test   edi,edi
  40212e:	0f 85 a0 fe ff ff    	jne    401fd4 <sched_thd_yield_to+0x54>
  402134:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  402138:	be 24 00 00 00       	mov    esi,0x24
  40213d:	bf 60 cc 41 00       	mov    edi,0x41cc60
  402142:	e8 89 7f 00 00       	call   40a0d0 <cos_print_str>
	assert(to);
  402147:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40214e:	00 00 00 00 
  402152:	0f 0b                	ud2    
  402154:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  402158:	45 31 e4             	xor    r12d,r12d
  40215b:	e9 6c fe ff ff       	jmp    401fcc <sched_thd_yield_to+0x4c>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  402160:	41 89 c0             	mov    r8d,eax
  402163:	4c 89 e2             	mov    rdx,r12
  402166:	48 89 c6             	mov    rsi,rax
  402169:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  40216e:	41 83 e0 01          	and    r8d,0x1
  402172:	e8 99 16 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  402177:	83 f8 f0             	cmp    eax,0xfffffff0
  40217a:	0f 85 9c fe ff ff    	jne    40201c <sched_thd_yield_to+0x9c>
  402180:	be 59 00 00 00       	mov    esi,0x59
  402185:	bf c0 c7 41 00       	mov    edi,0x41c7c0
  40218a:	e8 41 7f 00 00       	call   40a0d0 <cos_print_str>
  40218f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402196:	00 00 00 00 
  40219a:	0f 0b                	ud2    
  40219c:	be 59 00 00 00       	mov    esi,0x59
  4021a1:	bf 60 c7 41 00       	mov    edi,0x41c760
  4021a6:	e8 25 7f 00 00       	call   40a0d0 <cos_print_str>
	assert(current);
  4021ab:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4021b2:	00 00 00 00 
  4021b6:	0f 0b                	ud2    
  4021b8:	be 61 00 00 00       	mov    esi,0x61
  4021bd:	bf 48 c8 41 00       	mov    edi,0x41c848
  4021c2:	e8 09 7f 00 00       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  4021c7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4021ce:	00 00 00 00 
  4021d2:	0f 0b                	ud2    
	timeout = g->timeout_next;
  4021d4:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  4021d7:	48 81 fb c8 1e 5a 00 	cmp    rbx,0x5a1ec8
  4021de:	0f 84 d1 00 00 00    	je     4022b5 <sched_thd_yield_to+0x335>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  4021e4:	a8 02                	test   al,0x2
  4021e6:	0f 85 d5 00 00 00    	jne    4022c1 <sched_thd_yield_to+0x341>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  4021ec:	49 89 c8             	mov    r8,rcx
  4021ef:	a8 01                	test   al,0x1
  4021f1:	0f 84 e9 fe ff ff    	je     4020e0 <sched_thd_yield_to+0x160>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  4021f7:	4c 8b 53 08          	mov    r10,QWORD PTR [rbx+0x8]
  4021fb:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  4021ff:	48 89 f2             	mov    rdx,rsi
  402202:	45 89 e9             	mov    r9d,r13d
  402205:	4c 8b 05 dc fc 19 00 	mov    r8,QWORD PTR [rip+0x19fcdc]        # 5a1ee8 <__slm_global+0x28>
  40220c:	4c 89 d6             	mov    rsi,r10
  40220f:	e8 0c f1 00 00       	call   411320 <cos_switch>
  402214:	eb 4d                	jmp    402263 <sched_thd_yield_to+0x2e3>
	return t != &g->idle_thd && t != &g->sched_thd;
  402216:	48 81 fb c8 1e 5a 00 	cmp    rbx,0x5a1ec8
  40221d:	74 25                	je     402244 <sched_thd_yield_to+0x2c4>
  40221f:	48 81 fb 40 1f 5a 00 	cmp    rbx,0x5a1f40
  402226:	74 1c                	je     402244 <sched_thd_yield_to+0x2c4>
  402228:	be 61 00 00 00       	mov    esi,0x61
  40222d:	bf b0 c8 41 00       	mov    edi,0x41c8b0
  402232:	e8 99 7e 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EPERM);
  402237:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40223e:	00 00 00 00 
  402242:	0f 0b                	ud2    
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  402244:	49 8b 54 24 30       	mov    rdx,QWORD PTR [r12+0x30]
  402249:	4c 8b 05 98 fc 19 00 	mov    r8,QWORD PTR [rip+0x19fc98]        # 5a1ee8 <__slm_global+0x28>
  402250:	31 c9                	xor    ecx,ecx
  402252:	31 f6                	xor    esi,esi
  402254:	48 8b 3d 7d fc 19 00 	mov    rdi,QWORD PTR [rip+0x19fc7d]        # 5a1ed8 <__slm_global+0x18>
  40225b:	45 89 e9             	mov    r9d,r13d
  40225e:	e8 bd f0 00 00       	call   411320 <cos_switch>
	if (unlikely(ret != 0)) {
  402263:	85 c0                	test   eax,eax
  402265:	0f 84 95 fe ff ff    	je     402100 <sched_thd_yield_to+0x180>
		assert(ret != -EPERM);
  40226b:	83 f8 ff             	cmp    eax,0xffffffff
  40226e:	74 b8                	je     402228 <sched_thd_yield_to+0x2a8>
		assert(ret != -EINVAL);
  402270:	83 f8 ea             	cmp    eax,0xffffffea
  402273:	74 64                	je     4022d9 <sched_thd_yield_to+0x359>
		if (ret == -EBUSY) return ret;
  402275:	83 f8 f0             	cmp    eax,0xfffffff0
  402278:	0f 84 84 fe ff ff    	je     402102 <sched_thd_yield_to+0x182>
		assert(ret == -EAGAIN);
  40227e:	83 f8 f5             	cmp    eax,0xfffffff5
  402281:	0f 85 99 00 00 00    	jne    402320 <sched_thd_yield_to+0x3a0>
		tok    = cos_sched_sync();
  402287:	e8 74 f0 00 00       	call   411300 <cos_sched_sync>
  40228c:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  40228f:	48 8b 05 2a fc 19 00 	mov    rax,QWORD PTR [rip+0x19fc2a]        # 5a1ec0 <__slm_global>
		if (unlikely(owner)) {
  402296:	48 89 c1             	mov    rcx,rax
  402299:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  40229d:	75 56                	jne    4022f5 <sched_thd_yield_to+0x375>
  40229f:	f0 4c 0f b1 25 18 fc 	lock cmpxchg QWORD PTR [rip+0x19fc18],r12        # 5a1ec0 <__slm_global>
  4022a6:	19 00 
  4022a8:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4022ab:	84 c0                	test   al,al
  4022ad:	0f 85 ab fd ff ff    	jne    40205e <sched_thd_yield_to+0xde>
  4022b3:	eb d2                	jmp    402287 <sched_thd_yield_to+0x307>
			prio    = curr->priority;
  4022b5:	49 8b 74 24 30       	mov    rsi,QWORD PTR [r12+0x30]
			timeout = TCAP_TIME_NIL;
  4022ba:	31 c9                	xor    ecx,ecx
  4022bc:	e9 23 ff ff ff       	jmp    4021e4 <sched_thd_yield_to+0x264>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  4022c1:	48 8b 7b 28          	mov    rdi,QWORD PTR [rbx+0x28]
  4022c5:	48 8b 15 1c fc 19 00 	mov    rdx,QWORD PTR [rip+0x19fc1c]        # 5a1ee8 <__slm_global+0x28>
  4022cc:	44 89 e9             	mov    ecx,r13d
  4022cf:	4c 89 c6             	mov    rsi,r8
  4022d2:	e8 b9 f0 00 00       	call   411390 <cos_sched_asnd>
  4022d7:	eb 8a                	jmp    402263 <sched_thd_yield_to+0x2e3>
  4022d9:	be 61 00 00 00       	mov    esi,0x61
  4022de:	bf 18 c9 41 00       	mov    edi,0x41c918
  4022e3:	e8 e8 7d 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  4022e8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4022ef:	00 00 00 00 
  4022f3:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  4022f5:	41 89 c0             	mov    r8d,eax
  4022f8:	4c 89 e2             	mov    rdx,r12
  4022fb:	48 89 c6             	mov    rsi,rax
  4022fe:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  402303:	41 83 e0 01          	and    r8d,0x1
  402307:	e8 04 15 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  40230c:	83 f8 f0             	cmp    eax,0xfffffff0
  40230f:	0f 85 72 ff ff ff    	jne    402287 <sched_thd_yield_to+0x307>
  402315:	e9 66 fe ff ff       	jmp    402180 <sched_thd_yield_to+0x200>
  40231a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  402320:	be 61 00 00 00       	mov    esi,0x61
  402325:	bf 80 c9 41 00       	mov    edi,0x41c980
  40232a:	e8 a1 7d 00 00       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  40232f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402336:	00 00 00 00 
  40233a:	0f 0b                	ud2    
  40233c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000402340 <sched_set_tls>:
{
  402340:	f3 0f 1e fa          	endbr64 
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  402344:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  402347:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  40234d:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  402354:	48 85 c0             	test   rax,rax
  402357:	0f 84 03 2b 01 00    	je     414e60 <sched_set_tls.cold>
  40235d:	83 e8 01             	sub    eax,0x1
  402360:	83 f8 18             	cmp    eax,0x18
  402363:	0f 87 f7 2a 01 00    	ja     414e60 <sched_set_tls.cold>
  402369:	48 8b 14 c5 00 e7 45 	mov    rdx,QWORD PTR [rax*8+0x45e700]
  402370:	00 
  402371:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  402378:	0f 84 e2 2a 01 00    	je     414e60 <sched_set_tls.cold>
  40237e:	83 e2 01             	and    edx,0x1
  402381:	0f 85 d9 2a 01 00    	jne    414e60 <sched_set_tls.cold>
	thdcap_t thdcap = current->thd;
  402387:	48 8d 14 80          	lea    rdx,[rax+rax*4]
	capmgr_set_tls(thdcap, tls_addr);
  40238b:	48 89 fe             	mov    rsi,rdi
	thdcap_t thdcap = current->thd;
  40238e:	48 8d 04 50          	lea    rax,[rax+rdx*2]
  402392:	48 c1 e0 04          	shl    rax,0x4
	capmgr_set_tls(thdcap, tls_addr);
  402396:	4c 8b 80 d8 e7 45 00 	mov    r8,QWORD PTR [rax+0x45e7d8]
  40239d:	4c 89 c7             	mov    rdi,r8
  4023a0:	e9 3b 50 00 00       	jmp    4073e0 <__cosrt_extern_capmgr_set_tls>
  4023a5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4023ac:	00 00 00 00 

00000000004023b0 <thd_block>:
{
  4023b0:	f3 0f 1e fa          	endbr64 
  4023b4:	55                   	push   rbp
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  4023b5:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  4023b8:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  4023be:	48 89 e5             	mov    rbp,rsp
  4023c1:	41 57                	push   r15
  4023c3:	41 56                	push   r14
  4023c5:	41 55                	push   r13
  4023c7:	41 54                	push   r12
  4023c9:	53                   	push   rbx
  4023ca:	48 83 ec 08          	sub    rsp,0x8
  4023ce:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  4023d5:	48 85 c0             	test   rax,rax
  4023d8:	0f 84 82 01 00 00    	je     402560 <thd_block+0x1b0>
  4023de:	83 e8 01             	sub    eax,0x1
  4023e1:	83 f8 18             	cmp    eax,0x18
  4023e4:	0f 87 76 01 00 00    	ja     402560 <thd_block+0x1b0>
  4023ea:	48 8b 14 c5 00 e7 45 	mov    rdx,QWORD PTR [rax*8+0x45e700]
  4023f1:	00 
  4023f2:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  4023f9:	0f 84 61 01 00 00    	je     402560 <thd_block+0x1b0>
  4023ff:	83 e2 01             	and    edx,0x1
  402402:	0f 85 58 01 00 00    	jne    402560 <thd_block+0x1b0>
  402408:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  40240c:	48 8d 1c 50          	lea    rbx,[rax+rdx*2]
  402410:	48 c1 e3 04          	shl    rbx,0x4
  402414:	48 81 c3 c8 e7 45 00 	add    rbx,0x45e7c8
		tok    = cos_sched_sync();
  40241b:	e8 e0 ee 00 00       	call   411300 <cos_sched_sync>
  402420:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  402423:	48 8b 05 96 fa 19 00 	mov    rax,QWORD PTR [rip+0x19fa96]        # 5a1ec0 <__slm_global>
		if (unlikely(owner)) {
  40242a:	48 89 c1             	mov    rcx,rax
  40242d:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  402431:	0f 85 49 01 00 00    	jne    402580 <thd_block+0x1d0>
  402437:	f0 48 0f b1 1d 80 fa 	lock cmpxchg QWORD PTR [rip+0x19fa80],rbx        # 5a1ec0 <__slm_global>
  40243e:	19 00 
  402440:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  402443:	84 c0                	test   al,al
  402445:	74 d4                	je     40241b <thd_block+0x6b>
        ret = slm_thd_block(current);
  402447:	48 89 df             	mov    rdi,rbx
  40244a:	e8 71 14 01 00       	call   4138c0 <slm_thd_block>
  40244f:	41 89 c5             	mov    r13d,eax
	if (!ret) ret = slm_cs_exit_reschedule(current, SLM_CS_NONE);
  402452:	85 c0                	test   eax,eax
  402454:	0f 85 d6 00 00 00    	jne    402530 <thd_block+0x180>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  40245a:	e8 01 94 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(!t)) t = &g->idle_thd;
  40245f:	41 bf 40 1f 5a 00    	mov    r15d,0x5a1f40
	tok  = cos_sched_sync();
  402465:	e8 96 ee 00 00       	call   411300 <cos_sched_sync>
  40246a:	41 89 c6             	mov    r14d,eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  40246d:	e8 1e 00 01 00       	call   412490 <slm_sched_fprr_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  402472:	48 85 c0             	test   rax,rax
  402475:	49 89 c4             	mov    r12,rax
  402478:	4d 0f 44 e7          	cmove  r12,r15
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  40247c:	41 8b 44 24 04       	mov    eax,DWORD PTR [r12+0x4]
  402481:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  402484:	83 f8 01             	cmp    eax,0x1
  402487:	76 17                	jbe    4024a0 <thd_block+0xf0>
  402489:	e9 82 01 00 00       	jmp    402610 <thd_block+0x260>
  40248e:	66 90                	xchg   ax,ax
  402490:	f0 48 0f b1 15 27 fa 	lock cmpxchg QWORD PTR [rip+0x19fa27],rdx        # 5a1ec0 <__slm_global>
  402497:	19 00 
  402499:	0f 94 c0             	sete   al
	while (ret != 0) {
  40249c:	84 c0                	test   al,al
  40249e:	75 2e                	jne    4024ce <thd_block+0x11e>
		tok    = cos_sched_sync();
  4024a0:	e8 5b ee 00 00       	call   411300 <cos_sched_sync>
  4024a5:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4024a7:	48 8b 05 12 fa 19 00 	mov    rax,QWORD PTR [rip+0x19fa12]        # 5a1ec0 <__slm_global>
		if (unlikely(contention)) {
  4024ae:	48 89 c2             	mov    rdx,rax
  4024b1:	83 e2 01             	and    edx,0x1
  4024b4:	74 da                	je     402490 <thd_block+0xe0>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  4024b6:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  4024b9:	48 89 c2             	mov    rdx,rax
  4024bc:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  4024c1:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  4024c5:	e8 96 13 01 00       	call   413860 <slm_cs_exit_contention>
  4024ca:	85 c0                	test   eax,eax
  4024cc:	75 d2                	jne    4024a0 <thd_block+0xf0>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  4024ce:	e8 8d 93 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4024d3:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
	prio = inherit_prio ? curr->priority : t->priority;
  4024d7:	49 8b 74 24 30       	mov    rsi,QWORD PTR [r12+0x30]
	timeout = g->timeout_next;
  4024dc:	4c 8b 05 e5 fa 19 00 	mov    r8,QWORD PTR [rip+0x19fae5]        # 5a1fc8 <__slm_global+0x108>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4024e3:	a8 0b                	test   al,0xb
  4024e5:	0f 85 41 01 00 00    	jne    40262c <thd_block+0x27c>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  4024eb:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  4024f0:	44 89 f1             	mov    ecx,r14d
  4024f3:	4c 89 c2             	mov    rdx,r8
  4024f6:	e8 65 a2 00 00       	call   40c760 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  4024fb:	83 f8 ff             	cmp    eax,0xffffffff
  4024fe:	0f 84 97 01 00 00    	je     40269b <thd_block+0x2eb>
	if (unlikely(ret != 0)) {
  402504:	85 c0                	test   eax,eax
  402506:	0f 85 b0 00 00 00    	jne    4025bc <thd_block+0x20c>
}
  40250c:	48 83 c4 08          	add    rsp,0x8
  402510:	44 89 e8             	mov    eax,r13d
  402513:	5b                   	pop    rbx
  402514:	41 5c                	pop    r12
  402516:	41 5d                	pop    r13
  402518:	41 5e                	pop    r14
  40251a:	41 5f                	pop    r15
  40251c:	5d                   	pop    rbp
  40251d:	c3                   	ret    
  40251e:	66 90                	xchg   ax,ax
  402520:	f0 48 0f b1 15 97 f9 	lock cmpxchg QWORD PTR [rip+0x19f997],rdx        # 5a1ec0 <__slm_global>
  402527:	19 00 
  402529:	0f 94 c0             	sete   al
	while (ret != 0) {
  40252c:	84 c0                	test   al,al
  40252e:	75 dc                	jne    40250c <thd_block+0x15c>
		tok    = cos_sched_sync();
  402530:	e8 cb ed 00 00       	call   411300 <cos_sched_sync>
  402535:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  402537:	48 8b 05 82 f9 19 00 	mov    rax,QWORD PTR [rip+0x19f982]        # 5a1ec0 <__slm_global>
		if (unlikely(contention)) {
  40253e:	48 89 c2             	mov    rdx,rax
  402541:	83 e2 01             	and    edx,0x1
  402544:	74 da                	je     402520 <thd_block+0x170>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  402546:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  402549:	48 89 c2             	mov    rdx,rax
  40254c:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  402551:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  402555:	e8 06 13 01 00       	call   413860 <slm_cs_exit_contention>
  40255a:	85 c0                	test   eax,eax
  40255c:	74 ae                	je     40250c <thd_block+0x15c>
  40255e:	eb d0                	jmp    402530 <thd_block+0x180>
  402560:	be 59 00 00 00       	mov    esi,0x59
  402565:	bf 60 c7 41 00       	mov    edi,0x41c760
  40256a:	e8 61 7b 00 00       	call   40a0d0 <cos_print_str>
	assert(current);
  40256f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402576:	00 00 00 00 
  40257a:	0f 0b                	ud2    
  40257c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  402580:	41 89 c0             	mov    r8d,eax
  402583:	48 89 da             	mov    rdx,rbx
  402586:	48 89 c6             	mov    rsi,rax
  402589:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  40258e:	41 83 e0 01          	and    r8d,0x1
  402592:	e8 79 12 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  402597:	83 f8 f0             	cmp    eax,0xfffffff0
  40259a:	0f 85 7b fe ff ff    	jne    40241b <thd_block+0x6b>
  4025a0:	be 59 00 00 00       	mov    esi,0x59
  4025a5:	bf c0 c7 41 00       	mov    edi,0x41c7c0
  4025aa:	e8 21 7b 00 00       	call   40a0d0 <cos_print_str>
  4025af:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4025b6:	00 00 00 00 
  4025ba:	0f 0b                	ud2    
		assert(ret != -EINVAL);
  4025bc:	83 f8 ea             	cmp    eax,0xffffffea
  4025bf:	0f 84 2f 01 00 00    	je     4026f4 <thd_block+0x344>
		if (ret == -EBUSY) return ret;
  4025c5:	83 f8 f0             	cmp    eax,0xfffffff0
  4025c8:	0f 84 86 01 00 00    	je     402754 <thd_block+0x3a4>
		assert(ret == -EAGAIN);
  4025ce:	83 f8 f5             	cmp    eax,0xfffffff5
  4025d1:	0f 85 61 01 00 00    	jne    402738 <thd_block+0x388>
		tok    = cos_sched_sync();
  4025d7:	e8 24 ed 00 00       	call   411300 <cos_sched_sync>
  4025dc:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4025df:	48 8b 05 da f8 19 00 	mov    rax,QWORD PTR [rip+0x19f8da]        # 5a1ec0 <__slm_global>
		if (unlikely(owner)) {
  4025e6:	48 89 c1             	mov    rcx,rax
  4025e9:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  4025ed:	0f 85 1d 01 00 00    	jne    402710 <thd_block+0x360>
  4025f3:	f0 48 0f b1 1d c4 f8 	lock cmpxchg QWORD PTR [rip+0x19f8c4],rbx        # 5a1ec0 <__slm_global>
  4025fa:	19 00 
  4025fc:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4025ff:	84 c0                	test   al,al
  402601:	0f 85 5e fe ff ff    	jne    402465 <thd_block+0xb5>
  402607:	eb ce                	jmp    4025d7 <thd_block+0x227>
  402609:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  402610:	be 61 00 00 00       	mov    esi,0x61
  402615:	bf 48 c8 41 00       	mov    edi,0x41c848
  40261a:	e8 b1 7a 00 00       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  40261f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402626:	00 00 00 00 
  40262a:	0f 0b                	ud2    
	timeout = g->timeout_next;
  40262c:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  40262f:	49 81 fc c8 1e 5a 00 	cmp    r12,0x5a1ec8
  402636:	0f 84 91 00 00 00    	je     4026cd <thd_block+0x31d>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  40263c:	a8 02                	test   al,0x2
  40263e:	0f 85 94 00 00 00    	jne    4026d8 <thd_block+0x328>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  402644:	49 89 c8             	mov    r8,rcx
  402647:	a8 01                	test   al,0x1
  402649:	0f 84 9c fe ff ff    	je     4024eb <thd_block+0x13b>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  40264f:	4d 8b 54 24 08       	mov    r10,QWORD PTR [r12+0x8]
  402654:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  402659:	48 89 f2             	mov    rdx,rsi
  40265c:	45 89 f1             	mov    r9d,r14d
  40265f:	4c 8b 05 82 f8 19 00 	mov    r8,QWORD PTR [rip+0x19f882]        # 5a1ee8 <__slm_global+0x28>
  402666:	4c 89 d6             	mov    rsi,r10
  402669:	e8 b2 ec 00 00       	call   411320 <cos_switch>
	if (unlikely(ret != 0)) {
  40266e:	85 c0                	test   eax,eax
  402670:	0f 84 96 fe ff ff    	je     40250c <thd_block+0x15c>
		assert(ret != -EPERM);
  402676:	83 f8 ff             	cmp    eax,0xffffffff
  402679:	0f 85 3d ff ff ff    	jne    4025bc <thd_block+0x20c>
  40267f:	be 61 00 00 00       	mov    esi,0x61
  402684:	bf b0 c8 41 00       	mov    edi,0x41c8b0
  402689:	e8 42 7a 00 00       	call   40a0d0 <cos_print_str>
  40268e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402695:	00 00 00 00 
  402699:	0f 0b                	ud2    
	return t != &g->idle_thd && t != &g->sched_thd;
  40269b:	49 81 fc 40 1f 5a 00 	cmp    r12,0x5a1f40
  4026a2:	74 09                	je     4026ad <thd_block+0x2fd>
  4026a4:	49 81 fc c8 1e 5a 00 	cmp    r12,0x5a1ec8
  4026ab:	75 d2                	jne    40267f <thd_block+0x2cf>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  4026ad:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]
  4026b1:	4c 8b 05 30 f8 19 00 	mov    r8,QWORD PTR [rip+0x19f830]        # 5a1ee8 <__slm_global+0x28>
  4026b8:	45 89 f1             	mov    r9d,r14d
  4026bb:	31 c9                	xor    ecx,ecx
  4026bd:	48 8b 3d 14 f8 19 00 	mov    rdi,QWORD PTR [rip+0x19f814]        # 5a1ed8 <__slm_global+0x18>
  4026c4:	31 f6                	xor    esi,esi
  4026c6:	e8 55 ec 00 00       	call   411320 <cos_switch>
  4026cb:	eb a1                	jmp    40266e <thd_block+0x2be>
			prio    = curr->priority;
  4026cd:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
			timeout = TCAP_TIME_NIL;
  4026d1:	31 c9                	xor    ecx,ecx
  4026d3:	e9 64 ff ff ff       	jmp    40263c <thd_block+0x28c>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  4026d8:	49 8b 7c 24 28       	mov    rdi,QWORD PTR [r12+0x28]
  4026dd:	48 8b 15 04 f8 19 00 	mov    rdx,QWORD PTR [rip+0x19f804]        # 5a1ee8 <__slm_global+0x28>
  4026e4:	44 89 f1             	mov    ecx,r14d
  4026e7:	4c 89 c6             	mov    rsi,r8
  4026ea:	e8 a1 ec 00 00       	call   411390 <cos_sched_asnd>
  4026ef:	e9 7a ff ff ff       	jmp    40266e <thd_block+0x2be>
  4026f4:	be 61 00 00 00       	mov    esi,0x61
  4026f9:	bf 18 c9 41 00       	mov    edi,0x41c918
  4026fe:	e8 cd 79 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  402703:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40270a:	00 00 00 00 
  40270e:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  402710:	41 89 c0             	mov    r8d,eax
  402713:	48 89 da             	mov    rdx,rbx
  402716:	48 89 c6             	mov    rsi,rax
  402719:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  40271e:	41 83 e0 01          	and    r8d,0x1
  402722:	e8 e9 10 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  402727:	83 f8 f0             	cmp    eax,0xfffffff0
  40272a:	0f 85 a7 fe ff ff    	jne    4025d7 <thd_block+0x227>
  402730:	e9 6b fe ff ff       	jmp    4025a0 <thd_block+0x1f0>
  402735:	0f 1f 00             	nop    DWORD PTR [rax]
  402738:	be 61 00 00 00       	mov    esi,0x61
  40273d:	bf 80 c9 41 00       	mov    edi,0x41c980
  402742:	e8 89 79 00 00       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  402747:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40274e:	00 00 00 00 
  402752:	0f 0b                	ud2    
	ret = slm_thd_activate(curr, t, tok, 0);
  402754:	41 bd f0 ff ff ff    	mov    r13d,0xfffffff0
	return ret;
  40275a:	e9 ad fd ff ff       	jmp    40250c <thd_block+0x15c>
  40275f:	90                   	nop

0000000000402760 <sched_thd_block>:
{
  402760:	f3 0f 1e fa          	endbr64 
  402764:	55                   	push   rbp
  402765:	48 89 e5             	mov    rbp,rsp
  402768:	41 57                	push   r15
  40276a:	41 56                	push   r14
  40276c:	41 55                	push   r13
  40276e:	41 54                	push   r12
  402770:	53                   	push   rbx
  402771:	48 83 ec 08          	sub    rsp,0x8
	if (dep_id) return -1;
  402775:	48 85 ff             	test   rdi,rdi
  402778:	0f 85 0f 03 00 00    	jne    402a8d <sched_thd_block+0x32d>
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  40277e:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  402781:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  402787:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  40278e:	48 85 c0             	test   rax,rax
  402791:	0f 84 89 01 00 00    	je     402920 <sched_thd_block+0x1c0>
  402797:	83 e8 01             	sub    eax,0x1
  40279a:	83 f8 18             	cmp    eax,0x18
  40279d:	0f 87 7d 01 00 00    	ja     402920 <sched_thd_block+0x1c0>
  4027a3:	48 8b 14 c5 00 e7 45 	mov    rdx,QWORD PTR [rax*8+0x45e700]
  4027aa:	00 
  4027ab:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  4027b2:	0f 84 68 01 00 00    	je     402920 <sched_thd_block+0x1c0>
  4027b8:	83 e2 01             	and    edx,0x1
  4027bb:	0f 85 5f 01 00 00    	jne    402920 <sched_thd_block+0x1c0>
  4027c1:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  4027c5:	48 8d 1c 50          	lea    rbx,[rax+rdx*2]
  4027c9:	48 c1 e3 04          	shl    rbx,0x4
  4027cd:	48 81 c3 c8 e7 45 00 	add    rbx,0x45e7c8
		tok    = cos_sched_sync();
  4027d4:	e8 27 eb 00 00       	call   411300 <cos_sched_sync>
  4027d9:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4027dc:	48 8b 05 dd f6 19 00 	mov    rax,QWORD PTR [rip+0x19f6dd]        # 5a1ec0 <__slm_global>
		if (unlikely(owner)) {
  4027e3:	48 89 c1             	mov    rcx,rax
  4027e6:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  4027ea:	0f 85 50 01 00 00    	jne    402940 <sched_thd_block+0x1e0>
  4027f0:	f0 48 0f b1 1d c7 f6 	lock cmpxchg QWORD PTR [rip+0x19f6c7],rbx        # 5a1ec0 <__slm_global>
  4027f7:	19 00 
  4027f9:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4027fc:	84 c0                	test   al,al
  4027fe:	74 d4                	je     4027d4 <sched_thd_block+0x74>
        ret = slm_thd_block(current);
  402800:	48 89 df             	mov    rdi,rbx
  402803:	e8 b8 10 01 00       	call   4138c0 <slm_thd_block>
  402808:	41 89 c5             	mov    r13d,eax
	if (!ret) ret = slm_cs_exit_reschedule(current, SLM_CS_NONE);
  40280b:	85 c0                	test   eax,eax
  40280d:	0f 85 dd 00 00 00    	jne    4028f0 <sched_thd_block+0x190>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  402813:	e8 48 90 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(!t)) t = &g->idle_thd;
  402818:	41 bf 40 1f 5a 00    	mov    r15d,0x5a1f40
	tok  = cos_sched_sync();
  40281e:	e8 dd ea 00 00       	call   411300 <cos_sched_sync>
  402823:	41 89 c6             	mov    r14d,eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  402826:	e8 65 fc 00 00       	call   412490 <slm_sched_fprr_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  40282b:	48 85 c0             	test   rax,rax
  40282e:	49 89 c4             	mov    r12,rax
  402831:	4d 0f 44 e7          	cmove  r12,r15
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  402835:	41 8b 44 24 04       	mov    eax,DWORD PTR [r12+0x4]
  40283a:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  40283d:	83 f8 01             	cmp    eax,0x1
  402840:	76 1e                	jbe    402860 <sched_thd_block+0x100>
  402842:	e9 89 01 00 00       	jmp    4029d0 <sched_thd_block+0x270>
  402847:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40284e:	00 00 
  402850:	f0 48 0f b1 15 67 f6 	lock cmpxchg QWORD PTR [rip+0x19f667],rdx        # 5a1ec0 <__slm_global>
  402857:	19 00 
  402859:	0f 94 c0             	sete   al
	while (ret != 0) {
  40285c:	84 c0                	test   al,al
  40285e:	75 2e                	jne    40288e <sched_thd_block+0x12e>
		tok    = cos_sched_sync();
  402860:	e8 9b ea 00 00       	call   411300 <cos_sched_sync>
  402865:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  402867:	48 8b 05 52 f6 19 00 	mov    rax,QWORD PTR [rip+0x19f652]        # 5a1ec0 <__slm_global>
		if (unlikely(contention)) {
  40286e:	48 89 c2             	mov    rdx,rax
  402871:	83 e2 01             	and    edx,0x1
  402874:	74 da                	je     402850 <sched_thd_block+0xf0>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  402876:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  402879:	48 89 c2             	mov    rdx,rax
  40287c:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  402881:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  402885:	e8 d6 0f 01 00       	call   413860 <slm_cs_exit_contention>
  40288a:	85 c0                	test   eax,eax
  40288c:	75 d2                	jne    402860 <sched_thd_block+0x100>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  40288e:	e8 cd 8f 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  402893:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
	prio = inherit_prio ? curr->priority : t->priority;
  402897:	49 8b 74 24 30       	mov    rsi,QWORD PTR [r12+0x30]
	timeout = g->timeout_next;
  40289c:	4c 8b 05 25 f7 19 00 	mov    r8,QWORD PTR [rip+0x19f725]        # 5a1fc8 <__slm_global+0x108>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4028a3:	a8 0b                	test   al,0xb
  4028a5:	0f 85 41 01 00 00    	jne    4029ec <sched_thd_block+0x28c>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  4028ab:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  4028b0:	44 89 f1             	mov    ecx,r14d
  4028b3:	4c 89 c2             	mov    rdx,r8
  4028b6:	e8 a5 9e 00 00       	call   40c760 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  4028bb:	83 f8 ff             	cmp    eax,0xffffffff
  4028be:	0f 84 97 01 00 00    	je     402a5b <sched_thd_block+0x2fb>
	if (unlikely(ret != 0)) {
  4028c4:	85 c0                	test   eax,eax
  4028c6:	0f 85 b0 00 00 00    	jne    40297c <sched_thd_block+0x21c>
}
  4028cc:	48 83 c4 08          	add    rsp,0x8
  4028d0:	44 89 e8             	mov    eax,r13d
  4028d3:	5b                   	pop    rbx
  4028d4:	41 5c                	pop    r12
  4028d6:	41 5d                	pop    r13
  4028d8:	41 5e                	pop    r14
  4028da:	41 5f                	pop    r15
  4028dc:	5d                   	pop    rbp
  4028dd:	c3                   	ret    
  4028de:	66 90                	xchg   ax,ax
  4028e0:	f0 48 0f b1 15 d7 f5 	lock cmpxchg QWORD PTR [rip+0x19f5d7],rdx        # 5a1ec0 <__slm_global>
  4028e7:	19 00 
  4028e9:	0f 94 c0             	sete   al
	while (ret != 0) {
  4028ec:	84 c0                	test   al,al
  4028ee:	75 dc                	jne    4028cc <sched_thd_block+0x16c>
		tok    = cos_sched_sync();
  4028f0:	e8 0b ea 00 00       	call   411300 <cos_sched_sync>
  4028f5:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4028f7:	48 8b 05 c2 f5 19 00 	mov    rax,QWORD PTR [rip+0x19f5c2]        # 5a1ec0 <__slm_global>
		if (unlikely(contention)) {
  4028fe:	48 89 c2             	mov    rdx,rax
  402901:	83 e2 01             	and    edx,0x1
  402904:	74 da                	je     4028e0 <sched_thd_block+0x180>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  402906:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  402909:	48 89 c2             	mov    rdx,rax
  40290c:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  402911:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  402915:	e8 46 0f 01 00       	call   413860 <slm_cs_exit_contention>
  40291a:	85 c0                	test   eax,eax
  40291c:	74 ae                	je     4028cc <sched_thd_block+0x16c>
  40291e:	eb d0                	jmp    4028f0 <sched_thd_block+0x190>
  402920:	be 59 00 00 00       	mov    esi,0x59
  402925:	bf 60 c7 41 00       	mov    edi,0x41c760
  40292a:	e8 a1 77 00 00       	call   40a0d0 <cos_print_str>
	assert(current);
  40292f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402936:	00 00 00 00 
  40293a:	0f 0b                	ud2    
  40293c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  402940:	41 89 c0             	mov    r8d,eax
  402943:	48 89 da             	mov    rdx,rbx
  402946:	48 89 c6             	mov    rsi,rax
  402949:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  40294e:	41 83 e0 01          	and    r8d,0x1
  402952:	e8 b9 0e 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  402957:	83 f8 f0             	cmp    eax,0xfffffff0
  40295a:	0f 85 74 fe ff ff    	jne    4027d4 <sched_thd_block+0x74>
  402960:	be 59 00 00 00       	mov    esi,0x59
  402965:	bf c0 c7 41 00       	mov    edi,0x41c7c0
  40296a:	e8 61 77 00 00       	call   40a0d0 <cos_print_str>
  40296f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402976:	00 00 00 00 
  40297a:	0f 0b                	ud2    
		assert(ret != -EINVAL);
  40297c:	83 f8 ea             	cmp    eax,0xffffffea
  40297f:	0f 84 3a 01 00 00    	je     402abf <sched_thd_block+0x35f>
		if (ret == -EBUSY) return ret;
  402985:	83 f8 f0             	cmp    eax,0xfffffff0
  402988:	0f 84 8e 01 00 00    	je     402b1c <sched_thd_block+0x3bc>
		assert(ret == -EAGAIN);
  40298e:	83 f8 f5             	cmp    eax,0xfffffff5
  402991:	0f 85 69 01 00 00    	jne    402b00 <sched_thd_block+0x3a0>
		tok    = cos_sched_sync();
  402997:	e8 64 e9 00 00       	call   411300 <cos_sched_sync>
  40299c:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  40299f:	48 8b 05 1a f5 19 00 	mov    rax,QWORD PTR [rip+0x19f51a]        # 5a1ec0 <__slm_global>
		if (unlikely(owner)) {
  4029a6:	48 89 c1             	mov    rcx,rax
  4029a9:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  4029ad:	0f 85 28 01 00 00    	jne    402adb <sched_thd_block+0x37b>
  4029b3:	f0 48 0f b1 1d 04 f5 	lock cmpxchg QWORD PTR [rip+0x19f504],rbx        # 5a1ec0 <__slm_global>
  4029ba:	19 00 
  4029bc:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4029bf:	84 c0                	test   al,al
  4029c1:	0f 85 57 fe ff ff    	jne    40281e <sched_thd_block+0xbe>
  4029c7:	eb ce                	jmp    402997 <sched_thd_block+0x237>
  4029c9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  4029d0:	be 61 00 00 00       	mov    esi,0x61
  4029d5:	bf 48 c8 41 00       	mov    edi,0x41c848
  4029da:	e8 f1 76 00 00       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  4029df:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4029e6:	00 00 00 00 
  4029ea:	0f 0b                	ud2    
	timeout = g->timeout_next;
  4029ec:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  4029ef:	49 81 fc c8 1e 5a 00 	cmp    r12,0x5a1ec8
  4029f6:	0f 84 9c 00 00 00    	je     402a98 <sched_thd_block+0x338>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  4029fc:	a8 02                	test   al,0x2
  4029fe:	0f 85 9f 00 00 00    	jne    402aa3 <sched_thd_block+0x343>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  402a04:	49 89 c8             	mov    r8,rcx
  402a07:	a8 01                	test   al,0x1
  402a09:	0f 84 9c fe ff ff    	je     4028ab <sched_thd_block+0x14b>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  402a0f:	4d 8b 54 24 08       	mov    r10,QWORD PTR [r12+0x8]
  402a14:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  402a19:	48 89 f2             	mov    rdx,rsi
  402a1c:	45 89 f1             	mov    r9d,r14d
  402a1f:	4c 8b 05 c2 f4 19 00 	mov    r8,QWORD PTR [rip+0x19f4c2]        # 5a1ee8 <__slm_global+0x28>
  402a26:	4c 89 d6             	mov    rsi,r10
  402a29:	e8 f2 e8 00 00       	call   411320 <cos_switch>
	if (unlikely(ret != 0)) {
  402a2e:	85 c0                	test   eax,eax
  402a30:	0f 84 96 fe ff ff    	je     4028cc <sched_thd_block+0x16c>
		assert(ret != -EPERM);
  402a36:	83 f8 ff             	cmp    eax,0xffffffff
  402a39:	0f 85 3d ff ff ff    	jne    40297c <sched_thd_block+0x21c>
  402a3f:	be 61 00 00 00       	mov    esi,0x61
  402a44:	bf b0 c8 41 00       	mov    edi,0x41c8b0
  402a49:	e8 82 76 00 00       	call   40a0d0 <cos_print_str>
  402a4e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402a55:	00 00 00 00 
  402a59:	0f 0b                	ud2    
	return t != &g->idle_thd && t != &g->sched_thd;
  402a5b:	49 81 fc 40 1f 5a 00 	cmp    r12,0x5a1f40
  402a62:	74 09                	je     402a6d <sched_thd_block+0x30d>
  402a64:	49 81 fc c8 1e 5a 00 	cmp    r12,0x5a1ec8
  402a6b:	75 d2                	jne    402a3f <sched_thd_block+0x2df>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  402a6d:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]
  402a71:	4c 8b 05 70 f4 19 00 	mov    r8,QWORD PTR [rip+0x19f470]        # 5a1ee8 <__slm_global+0x28>
  402a78:	45 89 f1             	mov    r9d,r14d
  402a7b:	31 c9                	xor    ecx,ecx
  402a7d:	48 8b 3d 54 f4 19 00 	mov    rdi,QWORD PTR [rip+0x19f454]        # 5a1ed8 <__slm_global+0x18>
  402a84:	31 f6                	xor    esi,esi
  402a86:	e8 95 e8 00 00       	call   411320 <cos_switch>
  402a8b:	eb a1                	jmp    402a2e <sched_thd_block+0x2ce>
	if (dep_id) return -1;
  402a8d:	41 bd ff ff ff ff    	mov    r13d,0xffffffff
  402a93:	e9 34 fe ff ff       	jmp    4028cc <sched_thd_block+0x16c>
			prio    = curr->priority;
  402a98:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
			timeout = TCAP_TIME_NIL;
  402a9c:	31 c9                	xor    ecx,ecx
  402a9e:	e9 59 ff ff ff       	jmp    4029fc <sched_thd_block+0x29c>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  402aa3:	49 8b 7c 24 28       	mov    rdi,QWORD PTR [r12+0x28]
  402aa8:	48 8b 15 39 f4 19 00 	mov    rdx,QWORD PTR [rip+0x19f439]        # 5a1ee8 <__slm_global+0x28>
  402aaf:	44 89 f1             	mov    ecx,r14d
  402ab2:	4c 89 c6             	mov    rsi,r8
  402ab5:	e8 d6 e8 00 00       	call   411390 <cos_sched_asnd>
  402aba:	e9 6f ff ff ff       	jmp    402a2e <sched_thd_block+0x2ce>
  402abf:	be 61 00 00 00       	mov    esi,0x61
  402ac4:	bf 18 c9 41 00       	mov    edi,0x41c918
  402ac9:	e8 02 76 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  402ace:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402ad5:	00 00 00 00 
  402ad9:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  402adb:	41 89 c0             	mov    r8d,eax
  402ade:	48 89 da             	mov    rdx,rbx
  402ae1:	48 89 c6             	mov    rsi,rax
  402ae4:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  402ae9:	41 83 e0 01          	and    r8d,0x1
  402aed:	e8 1e 0d 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  402af2:	83 f8 f0             	cmp    eax,0xfffffff0
  402af5:	0f 85 9c fe ff ff    	jne    402997 <sched_thd_block+0x237>
  402afb:	e9 60 fe ff ff       	jmp    402960 <sched_thd_block+0x200>
  402b00:	be 61 00 00 00       	mov    esi,0x61
  402b05:	bf 80 c9 41 00       	mov    edi,0x41c980
  402b0a:	e8 c1 75 00 00       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  402b0f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402b16:	00 00 00 00 
  402b1a:	0f 0b                	ud2    
	ret = slm_thd_activate(curr, t, tok, 0);
  402b1c:	41 bd f0 ff ff ff    	mov    r13d,0xfffffff0
  402b22:	e9 a5 fd ff ff       	jmp    4028cc <sched_thd_block+0x16c>
  402b27:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  402b2e:	00 00 

0000000000402b30 <thd_wakeup>:
{
  402b30:	f3 0f 1e fa          	endbr64 
  402b34:	55                   	push   rbp
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  402b35:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  402b38:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  402b3e:	48 89 e5             	mov    rbp,rsp
  402b41:	41 57                	push   r15
  402b43:	41 56                	push   r14
  402b45:	41 55                	push   r13
  402b47:	41 54                	push   r12
  402b49:	53                   	push   rbx
  402b4a:	48 83 ec 08          	sub    rsp,0x8
  402b4e:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  402b55:	48 85 c0             	test   rax,rax
  402b58:	0f 84 92 01 00 00    	je     402cf0 <thd_wakeup+0x1c0>
  402b5e:	83 e8 01             	sub    eax,0x1
  402b61:	83 f8 18             	cmp    eax,0x18
  402b64:	0f 87 86 01 00 00    	ja     402cf0 <thd_wakeup+0x1c0>
  402b6a:	48 8b 14 c5 00 e7 45 	mov    rdx,QWORD PTR [rax*8+0x45e700]
  402b71:	00 
  402b72:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  402b79:	0f 84 71 01 00 00    	je     402cf0 <thd_wakeup+0x1c0>
  402b7f:	83 e2 01             	and    edx,0x1
  402b82:	0f 85 68 01 00 00    	jne    402cf0 <thd_wakeup+0x1c0>
  402b88:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  402b8c:	49 89 fd             	mov    r13,rdi
  402b8f:	4c 8d 24 50          	lea    r12,[rax+rdx*2]
  402b93:	49 c1 e4 04          	shl    r12,0x4
  402b97:	49 81 c4 c8 e7 45 00 	add    r12,0x45e7c8
		tok    = cos_sched_sync();
  402b9e:	e8 5d e7 00 00       	call   411300 <cos_sched_sync>
  402ba3:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  402ba6:	48 8b 05 13 f3 19 00 	mov    rax,QWORD PTR [rip+0x19f313]        # 5a1ec0 <__slm_global>
		if (unlikely(owner)) {
  402bad:	48 89 c1             	mov    rcx,rax
  402bb0:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  402bb4:	0f 85 56 01 00 00    	jne    402d10 <thd_wakeup+0x1e0>
  402bba:	f0 4c 0f b1 25 fd f2 	lock cmpxchg QWORD PTR [rip+0x19f2fd],r12        # 5a1ec0 <__slm_global>
  402bc1:	19 00 
  402bc3:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  402bc6:	84 c0                	test   al,al
  402bc8:	74 d4                	je     402b9e <thd_wakeup+0x6e>
	ret = slm_thd_wakeup(t, 0);
  402bca:	31 f6                	xor    esi,esi
  402bcc:	4c 89 ef             	mov    rdi,r13
  402bcf:	e8 5c 12 01 00       	call   413e30 <slm_thd_wakeup>
  402bd4:	41 89 c7             	mov    r15d,eax
	if (ret < 0) {
  402bd7:	85 c0                	test   eax,eax
  402bd9:	0f 88 e1 00 00 00    	js     402cc0 <thd_wakeup+0x190>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  402bdf:	e8 7c 8c 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(!t)) t = &g->idle_thd;
  402be4:	41 be 40 1f 5a 00    	mov    r14d,0x5a1f40
	tok  = cos_sched_sync();
  402bea:	e8 11 e7 00 00       	call   411300 <cos_sched_sync>
  402bef:	41 89 c5             	mov    r13d,eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  402bf2:	e8 99 f8 00 00       	call   412490 <slm_sched_fprr_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  402bf7:	48 85 c0             	test   rax,rax
  402bfa:	48 89 c3             	mov    rbx,rax
  402bfd:	49 0f 44 de          	cmove  rbx,r14
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  402c01:	8b 43 04             	mov    eax,DWORD PTR [rbx+0x4]
  402c04:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  402c07:	83 f8 01             	cmp    eax,0x1
  402c0a:	76 1c                	jbe    402c28 <thd_wakeup+0xf8>
  402c0c:	e9 3b 01 00 00       	jmp    402d4c <thd_wakeup+0x21c>
  402c11:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  402c18:	f0 48 0f b1 15 9f f2 	lock cmpxchg QWORD PTR [rip+0x19f29f],rdx        # 5a1ec0 <__slm_global>
  402c1f:	19 00 
  402c21:	0f 94 c0             	sete   al
	while (ret != 0) {
  402c24:	84 c0                	test   al,al
  402c26:	75 2e                	jne    402c56 <thd_wakeup+0x126>
		tok    = cos_sched_sync();
  402c28:	e8 d3 e6 00 00       	call   411300 <cos_sched_sync>
  402c2d:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  402c2f:	48 8b 05 8a f2 19 00 	mov    rax,QWORD PTR [rip+0x19f28a]        # 5a1ec0 <__slm_global>
		if (unlikely(contention)) {
  402c36:	48 89 c2             	mov    rdx,rax
  402c39:	83 e2 01             	and    edx,0x1
  402c3c:	74 da                	je     402c18 <thd_wakeup+0xe8>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  402c3e:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  402c41:	48 89 c2             	mov    rdx,rax
  402c44:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  402c49:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  402c4d:	e8 0e 0c 01 00       	call   413860 <slm_cs_exit_contention>
  402c52:	85 c0                	test   eax,eax
  402c54:	75 d2                	jne    402c28 <thd_wakeup+0xf8>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  402c56:	e8 05 8c 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  402c5b:	8b 03                	mov    eax,DWORD PTR [rbx]
	timeout = g->timeout_next;
  402c5d:	4c 8b 05 64 f3 19 00 	mov    r8,QWORD PTR [rip+0x19f364]        # 5a1fc8 <__slm_global+0x108>
	prio = inherit_prio ? curr->priority : t->priority;
  402c64:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  402c68:	a8 0b                	test   al,0xb
  402c6a:	0f 85 f8 00 00 00    	jne    402d68 <thd_wakeup+0x238>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  402c70:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  402c74:	44 89 e9             	mov    ecx,r13d
  402c77:	4c 89 c2             	mov    rdx,r8
  402c7a:	e8 e1 9a 00 00       	call   40c760 <cos_defswitch>
  402c7f:	41 89 c7             	mov    r15d,eax
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  402c82:	83 f8 ff             	cmp    eax,0xffffffff
  402c85:	0f 84 85 01 00 00    	je     402e10 <thd_wakeup+0x2e0>
	if (unlikely(ret != 0)) {
  402c8b:	85 c0                	test   eax,eax
  402c8d:	0f 85 27 01 00 00    	jne    402dba <thd_wakeup+0x28a>
  402c93:	45 31 ff             	xor    r15d,r15d
}
  402c96:	48 83 c4 08          	add    rsp,0x8
  402c9a:	44 89 f8             	mov    eax,r15d
  402c9d:	5b                   	pop    rbx
  402c9e:	41 5c                	pop    r12
  402ca0:	41 5d                	pop    r13
  402ca2:	41 5e                	pop    r14
  402ca4:	41 5f                	pop    r15
  402ca6:	5d                   	pop    rbp
  402ca7:	c3                   	ret    
  402ca8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  402caf:	00 
  402cb0:	f0 48 0f b1 15 07 f2 	lock cmpxchg QWORD PTR [rip+0x19f207],rdx        # 5a1ec0 <__slm_global>
  402cb7:	19 00 
  402cb9:	0f 94 c0             	sete   al
	while (ret != 0) {
  402cbc:	84 c0                	test   al,al
  402cbe:	75 d6                	jne    402c96 <thd_wakeup+0x166>
		tok    = cos_sched_sync();
  402cc0:	e8 3b e6 00 00       	call   411300 <cos_sched_sync>
  402cc5:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  402cc7:	48 8b 05 f2 f1 19 00 	mov    rax,QWORD PTR [rip+0x19f1f2]        # 5a1ec0 <__slm_global>
		if (unlikely(contention)) {
  402cce:	48 89 c2             	mov    rdx,rax
  402cd1:	83 e2 01             	and    edx,0x1
  402cd4:	74 da                	je     402cb0 <thd_wakeup+0x180>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  402cd6:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  402cd9:	48 89 c2             	mov    rdx,rax
  402cdc:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  402ce1:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  402ce5:	e8 76 0b 01 00       	call   413860 <slm_cs_exit_contention>
  402cea:	85 c0                	test   eax,eax
  402cec:	74 a8                	je     402c96 <thd_wakeup+0x166>
  402cee:	eb d0                	jmp    402cc0 <thd_wakeup+0x190>
  402cf0:	be 59 00 00 00       	mov    esi,0x59
  402cf5:	bf 60 c7 41 00       	mov    edi,0x41c760
  402cfa:	e8 d1 73 00 00       	call   40a0d0 <cos_print_str>
	assert(current);
  402cff:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402d06:	00 00 00 00 
  402d0a:	0f 0b                	ud2    
  402d0c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  402d10:	41 89 c0             	mov    r8d,eax
  402d13:	4c 89 e2             	mov    rdx,r12
  402d16:	48 89 c6             	mov    rsi,rax
  402d19:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  402d1e:	41 83 e0 01          	and    r8d,0x1
  402d22:	e8 e9 0a 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  402d27:	83 f8 f0             	cmp    eax,0xfffffff0
  402d2a:	0f 85 6e fe ff ff    	jne    402b9e <thd_wakeup+0x6e>
  402d30:	be 59 00 00 00       	mov    esi,0x59
  402d35:	bf c0 c7 41 00       	mov    edi,0x41c7c0
  402d3a:	e8 91 73 00 00       	call   40a0d0 <cos_print_str>
  402d3f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402d46:	00 00 00 00 
  402d4a:	0f 0b                	ud2    
  402d4c:	be 61 00 00 00       	mov    esi,0x61
  402d51:	bf 48 c8 41 00       	mov    edi,0x41c848
  402d56:	e8 75 73 00 00       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  402d5b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402d62:	00 00 00 00 
  402d66:	0f 0b                	ud2    
	timeout = g->timeout_next;
  402d68:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  402d6b:	48 81 fb c8 1e 5a 00 	cmp    rbx,0x5a1ec8
  402d72:	0f 84 c6 00 00 00    	je     402e3e <thd_wakeup+0x30e>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  402d78:	a8 02                	test   al,0x2
  402d7a:	0f 85 f1 00 00 00    	jne    402e71 <thd_wakeup+0x341>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  402d80:	49 89 c8             	mov    r8,rcx
  402d83:	a8 01                	test   al,0x1
  402d85:	0f 84 e5 fe ff ff    	je     402c70 <thd_wakeup+0x140>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  402d8b:	4c 8b 53 08          	mov    r10,QWORD PTR [rbx+0x8]
  402d8f:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  402d93:	48 89 f2             	mov    rdx,rsi
  402d96:	45 89 e9             	mov    r9d,r13d
  402d99:	4c 8b 05 48 f1 19 00 	mov    r8,QWORD PTR [rip+0x19f148]        # 5a1ee8 <__slm_global+0x28>
  402da0:	4c 89 d6             	mov    rsi,r10
  402da3:	e8 78 e5 00 00       	call   411320 <cos_switch>
  402da8:	41 89 c7             	mov    r15d,eax
	if (unlikely(ret != 0)) {
  402dab:	45 85 ff             	test   r15d,r15d
  402dae:	0f 84 df fe ff ff    	je     402c93 <thd_wakeup+0x163>
		assert(ret != -EPERM);
  402db4:	41 83 ff ff          	cmp    r15d,0xffffffff
  402db8:	74 68                	je     402e22 <thd_wakeup+0x2f2>
		assert(ret != -EINVAL);
  402dba:	41 83 ff ea          	cmp    r15d,0xffffffea
  402dbe:	0f 84 cb 00 00 00    	je     402e8f <thd_wakeup+0x35f>
		if (ret == -EBUSY) return ret;
  402dc4:	41 83 ff f0          	cmp    r15d,0xfffffff0
  402dc8:	0f 84 c8 fe ff ff    	je     402c96 <thd_wakeup+0x166>
		assert(ret == -EAGAIN);
  402dce:	41 83 ff f5          	cmp    r15d,0xfffffff5
  402dd2:	0f 85 f8 00 00 00    	jne    402ed0 <thd_wakeup+0x3a0>
		tok    = cos_sched_sync();
  402dd8:	e8 23 e5 00 00       	call   411300 <cos_sched_sync>
  402ddd:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  402de0:	48 8b 05 d9 f0 19 00 	mov    rax,QWORD PTR [rip+0x19f0d9]        # 5a1ec0 <__slm_global>
		if (unlikely(owner)) {
  402de7:	48 89 c1             	mov    rcx,rax
  402dea:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  402dee:	0f 85 b7 00 00 00    	jne    402eab <thd_wakeup+0x37b>
  402df4:	f0 4c 0f b1 25 c3 f0 	lock cmpxchg QWORD PTR [rip+0x19f0c3],r12        # 5a1ec0 <__slm_global>
  402dfb:	19 00 
  402dfd:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  402e00:	84 c0                	test   al,al
  402e02:	0f 85 e2 fd ff ff    	jne    402bea <thd_wakeup+0xba>
  402e08:	eb ce                	jmp    402dd8 <thd_wakeup+0x2a8>
  402e0a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	return t != &g->idle_thd && t != &g->sched_thd;
  402e10:	48 81 fb 40 1f 5a 00 	cmp    rbx,0x5a1f40
  402e17:	74 31                	je     402e4a <thd_wakeup+0x31a>
  402e19:	48 81 fb c8 1e 5a 00 	cmp    rbx,0x5a1ec8
  402e20:	74 28                	je     402e4a <thd_wakeup+0x31a>
  402e22:	be 61 00 00 00       	mov    esi,0x61
  402e27:	bf b0 c8 41 00       	mov    edi,0x41c8b0
  402e2c:	e8 9f 72 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EPERM);
  402e31:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402e38:	00 00 00 00 
  402e3c:	0f 0b                	ud2    
			prio    = curr->priority;
  402e3e:	49 8b 74 24 30       	mov    rsi,QWORD PTR [r12+0x30]
			timeout = TCAP_TIME_NIL;
  402e43:	31 c9                	xor    ecx,ecx
  402e45:	e9 2e ff ff ff       	jmp    402d78 <thd_wakeup+0x248>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  402e4a:	49 8b 54 24 30       	mov    rdx,QWORD PTR [r12+0x30]
  402e4f:	4c 8b 05 92 f0 19 00 	mov    r8,QWORD PTR [rip+0x19f092]        # 5a1ee8 <__slm_global+0x28>
  402e56:	31 c9                	xor    ecx,ecx
  402e58:	31 f6                	xor    esi,esi
  402e5a:	48 8b 3d 77 f0 19 00 	mov    rdi,QWORD PTR [rip+0x19f077]        # 5a1ed8 <__slm_global+0x18>
  402e61:	45 89 e9             	mov    r9d,r13d
  402e64:	e8 b7 e4 00 00       	call   411320 <cos_switch>
  402e69:	41 89 c7             	mov    r15d,eax
  402e6c:	e9 3a ff ff ff       	jmp    402dab <thd_wakeup+0x27b>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  402e71:	48 8b 7b 28          	mov    rdi,QWORD PTR [rbx+0x28]
  402e75:	48 8b 15 6c f0 19 00 	mov    rdx,QWORD PTR [rip+0x19f06c]        # 5a1ee8 <__slm_global+0x28>
  402e7c:	44 89 e9             	mov    ecx,r13d
  402e7f:	4c 89 c6             	mov    rsi,r8
  402e82:	e8 09 e5 00 00       	call   411390 <cos_sched_asnd>
  402e87:	41 89 c7             	mov    r15d,eax
  402e8a:	e9 1c ff ff ff       	jmp    402dab <thd_wakeup+0x27b>
  402e8f:	be 61 00 00 00       	mov    esi,0x61
  402e94:	bf 18 c9 41 00       	mov    edi,0x41c918
  402e99:	e8 32 72 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  402e9e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402ea5:	00 00 00 00 
  402ea9:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  402eab:	41 89 c0             	mov    r8d,eax
  402eae:	4c 89 e2             	mov    rdx,r12
  402eb1:	48 89 c6             	mov    rsi,rax
  402eb4:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  402eb9:	41 83 e0 01          	and    r8d,0x1
  402ebd:	e8 4e 09 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  402ec2:	83 f8 f0             	cmp    eax,0xfffffff0
  402ec5:	0f 85 0d ff ff ff    	jne    402dd8 <thd_wakeup+0x2a8>
  402ecb:	e9 60 fe ff ff       	jmp    402d30 <thd_wakeup+0x200>
  402ed0:	be 61 00 00 00       	mov    esi,0x61
  402ed5:	bf 80 c9 41 00       	mov    edi,0x41c980
  402eda:	e8 f1 71 00 00       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  402edf:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402ee6:	00 00 00 00 
  402eea:	0f 0b                	ud2    
  402eec:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000402ef0 <sched_thd_wakeup>:
{
  402ef0:	f3 0f 1e fa          	endbr64 
  402ef4:	55                   	push   rbp
  402ef5:	48 89 e5             	mov    rbp,rsp
  402ef8:	41 57                	push   r15
  402efa:	41 56                	push   r14
  402efc:	41 55                	push   r13
  402efe:	41 54                	push   r12
  402f00:	53                   	push   rbx
  402f01:	48 83 ec 08          	sub    rsp,0x8
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  402f05:	85 ff                	test   edi,edi
  402f07:	74 1b                	je     402f24 <sched_thd_wakeup+0x34>
  402f09:	83 ef 01             	sub    edi,0x1
  402f0c:	83 ff 18             	cmp    edi,0x18
  402f0f:	77 13                	ja     402f24 <sched_thd_wakeup+0x34>
  402f11:	89 f8                	mov    eax,edi
  402f13:	48 8b 14 c5 00 e7 45 	mov    rdx,QWORD PTR [rax*8+0x45e700]
  402f1a:	00 
  402f1b:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  402f22:	75 1c                	jne    402f40 <sched_thd_wakeup+0x50>
	if (!t) return -1;
  402f24:	41 bf ff ff ff ff    	mov    r15d,0xffffffff
}
  402f2a:	48 83 c4 08          	add    rsp,0x8
  402f2e:	44 89 f8             	mov    eax,r15d
  402f31:	5b                   	pop    rbx
  402f32:	41 5c                	pop    r12
  402f34:	41 5d                	pop    r13
  402f36:	41 5e                	pop    r14
  402f38:	41 5f                	pop    r15
  402f3a:	5d                   	pop    rbp
  402f3b:	c3                   	ret    
  402f3c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  402f40:	83 e2 01             	and    edx,0x1
  402f43:	75 df                	jne    402f24 <sched_thd_wakeup+0x34>
	return &ss_thd_get(id)->thd;
  402f45:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  402f49:	4c 8d 2c 50          	lea    r13,[rax+rdx*2]
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  402f4d:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  402f50:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  402f56:	49 c1 e5 04          	shl    r13,0x4
  402f5a:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
  402f61:	49 81 c5 c8 e7 45 00 	add    r13,0x45e7c8
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  402f68:	48 85 c0             	test   rax,rax
  402f6b:	74 19                	je     402f86 <sched_thd_wakeup+0x96>
  402f6d:	83 e8 01             	sub    eax,0x1
  402f70:	83 f8 18             	cmp    eax,0x18
  402f73:	77 11                	ja     402f86 <sched_thd_wakeup+0x96>
  402f75:	48 8b 14 c5 00 e7 45 	mov    rdx,QWORD PTR [rax*8+0x45e700]
  402f7c:	00 
  402f7d:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  402f84:	75 22                	jne    402fa8 <sched_thd_wakeup+0xb8>
  402f86:	be 59 00 00 00       	mov    esi,0x59
  402f8b:	bf 60 c7 41 00       	mov    edi,0x41c760
  402f90:	e8 3b 71 00 00       	call   40a0d0 <cos_print_str>
	assert(current);
  402f95:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402f9c:	00 00 00 00 
  402fa0:	0f 0b                	ud2    
  402fa2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  402fa8:	83 e2 01             	and    edx,0x1
  402fab:	75 d9                	jne    402f86 <sched_thd_wakeup+0x96>
  402fad:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  402fb1:	4c 8d 24 50          	lea    r12,[rax+rdx*2]
  402fb5:	49 c1 e4 04          	shl    r12,0x4
  402fb9:	49 81 c4 c8 e7 45 00 	add    r12,0x45e7c8
		tok    = cos_sched_sync();
  402fc0:	e8 3b e3 00 00       	call   411300 <cos_sched_sync>
  402fc5:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  402fc8:	48 8b 05 f1 ee 19 00 	mov    rax,QWORD PTR [rip+0x19eef1]        # 5a1ec0 <__slm_global>
		if (unlikely(owner)) {
  402fcf:	48 89 c1             	mov    rcx,rax
  402fd2:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  402fd6:	0f 85 34 01 00 00    	jne    403110 <sched_thd_wakeup+0x220>
  402fdc:	f0 4c 0f b1 25 db ee 	lock cmpxchg QWORD PTR [rip+0x19eedb],r12        # 5a1ec0 <__slm_global>
  402fe3:	19 00 
  402fe5:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  402fe8:	84 c0                	test   al,al
  402fea:	74 d4                	je     402fc0 <sched_thd_wakeup+0xd0>
	ret = slm_thd_wakeup(t, 0);
  402fec:	31 f6                	xor    esi,esi
  402fee:	4c 89 ef             	mov    rdi,r13
  402ff1:	e8 3a 0e 01 00       	call   413e30 <slm_thd_wakeup>
  402ff6:	41 89 c7             	mov    r15d,eax
	if (ret < 0) {
  402ff9:	85 c0                	test   eax,eax
  402ffb:	0f 88 d3 00 00 00    	js     4030d4 <sched_thd_wakeup+0x1e4>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  403001:	e8 5a 88 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(!t)) t = &g->idle_thd;
  403006:	41 be 40 1f 5a 00    	mov    r14d,0x5a1f40
	tok  = cos_sched_sync();
  40300c:	e8 ef e2 00 00       	call   411300 <cos_sched_sync>
  403011:	41 89 c5             	mov    r13d,eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  403014:	e8 77 f4 00 00       	call   412490 <slm_sched_fprr_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  403019:	48 85 c0             	test   rax,rax
  40301c:	48 89 c3             	mov    rbx,rax
  40301f:	49 0f 44 de          	cmove  rbx,r14
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  403023:	8b 43 04             	mov    eax,DWORD PTR [rbx+0x4]
  403026:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  403029:	83 f8 01             	cmp    eax,0x1
  40302c:	76 1a                	jbe    403048 <sched_thd_wakeup+0x158>
  40302e:	e9 19 01 00 00       	jmp    40314c <sched_thd_wakeup+0x25c>
  403033:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  403038:	f0 48 0f b1 15 7f ee 	lock cmpxchg QWORD PTR [rip+0x19ee7f],rdx        # 5a1ec0 <__slm_global>
  40303f:	19 00 
  403041:	0f 94 c0             	sete   al
	while (ret != 0) {
  403044:	84 c0                	test   al,al
  403046:	75 2e                	jne    403076 <sched_thd_wakeup+0x186>
		tok    = cos_sched_sync();
  403048:	e8 b3 e2 00 00       	call   411300 <cos_sched_sync>
  40304d:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  40304f:	48 8b 05 6a ee 19 00 	mov    rax,QWORD PTR [rip+0x19ee6a]        # 5a1ec0 <__slm_global>
		if (unlikely(contention)) {
  403056:	48 89 c2             	mov    rdx,rax
  403059:	83 e2 01             	and    edx,0x1
  40305c:	74 da                	je     403038 <sched_thd_wakeup+0x148>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  40305e:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  403061:	48 89 c2             	mov    rdx,rax
  403064:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  403069:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  40306d:	e8 ee 07 01 00       	call   413860 <slm_cs_exit_contention>
  403072:	85 c0                	test   eax,eax
  403074:	75 d2                	jne    403048 <sched_thd_wakeup+0x158>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  403076:	e8 e5 87 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  40307b:	8b 03                	mov    eax,DWORD PTR [rbx]
	timeout = g->timeout_next;
  40307d:	4c 8b 05 44 ef 19 00 	mov    r8,QWORD PTR [rip+0x19ef44]        # 5a1fc8 <__slm_global+0x108>
	prio = inherit_prio ? curr->priority : t->priority;
  403084:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  403088:	a8 0b                	test   al,0xb
  40308a:	0f 85 d8 00 00 00    	jne    403168 <sched_thd_wakeup+0x278>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  403090:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  403094:	44 89 e9             	mov    ecx,r13d
  403097:	4c 89 c2             	mov    rdx,r8
  40309a:	e8 c1 96 00 00       	call   40c760 <cos_defswitch>
  40309f:	41 89 c7             	mov    r15d,eax
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  4030a2:	83 f8 ff             	cmp    eax,0xffffffff
  4030a5:	0f 84 65 01 00 00    	je     403210 <sched_thd_wakeup+0x320>
	if (unlikely(ret != 0)) {
  4030ab:	85 c0                	test   eax,eax
  4030ad:	0f 85 07 01 00 00    	jne    4031ba <sched_thd_wakeup+0x2ca>
	if (!t) return -1;
  4030b3:	45 31 ff             	xor    r15d,r15d
  4030b6:	e9 6f fe ff ff       	jmp    402f2a <sched_thd_wakeup+0x3a>
  4030bb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  4030c0:	f0 48 0f b1 15 f7 ed 	lock cmpxchg QWORD PTR [rip+0x19edf7],rdx        # 5a1ec0 <__slm_global>
  4030c7:	19 00 
  4030c9:	0f 94 c0             	sete   al
	while (ret != 0) {
  4030cc:	84 c0                	test   al,al
  4030ce:	0f 85 56 fe ff ff    	jne    402f2a <sched_thd_wakeup+0x3a>
		tok    = cos_sched_sync();
  4030d4:	e8 27 e2 00 00       	call   411300 <cos_sched_sync>
  4030d9:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4030db:	48 8b 05 de ed 19 00 	mov    rax,QWORD PTR [rip+0x19edde]        # 5a1ec0 <__slm_global>
		if (unlikely(contention)) {
  4030e2:	48 89 c2             	mov    rdx,rax
  4030e5:	83 e2 01             	and    edx,0x1
  4030e8:	74 d6                	je     4030c0 <sched_thd_wakeup+0x1d0>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  4030ea:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  4030ed:	48 89 c2             	mov    rdx,rax
  4030f0:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  4030f5:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  4030f9:	e8 62 07 01 00       	call   413860 <slm_cs_exit_contention>
  4030fe:	85 c0                	test   eax,eax
  403100:	0f 84 24 fe ff ff    	je     402f2a <sched_thd_wakeup+0x3a>
  403106:	eb cc                	jmp    4030d4 <sched_thd_wakeup+0x1e4>
  403108:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40310f:	00 
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  403110:	41 89 c0             	mov    r8d,eax
  403113:	4c 89 e2             	mov    rdx,r12
  403116:	48 89 c6             	mov    rsi,rax
  403119:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  40311e:	41 83 e0 01          	and    r8d,0x1
  403122:	e8 e9 06 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  403127:	83 f8 f0             	cmp    eax,0xfffffff0
  40312a:	0f 85 90 fe ff ff    	jne    402fc0 <sched_thd_wakeup+0xd0>
  403130:	be 59 00 00 00       	mov    esi,0x59
  403135:	bf c0 c7 41 00       	mov    edi,0x41c7c0
  40313a:	e8 91 6f 00 00       	call   40a0d0 <cos_print_str>
  40313f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403146:	00 00 00 00 
  40314a:	0f 0b                	ud2    
  40314c:	be 61 00 00 00       	mov    esi,0x61
  403151:	bf 48 c8 41 00       	mov    edi,0x41c848
  403156:	e8 75 6f 00 00       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  40315b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403162:	00 00 00 00 
  403166:	0f 0b                	ud2    
	timeout = g->timeout_next;
  403168:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  40316b:	48 81 fb c8 1e 5a 00 	cmp    rbx,0x5a1ec8
  403172:	0f 84 c6 00 00 00    	je     40323e <sched_thd_wakeup+0x34e>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  403178:	a8 02                	test   al,0x2
  40317a:	0f 85 f1 00 00 00    	jne    403271 <sched_thd_wakeup+0x381>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  403180:	49 89 c8             	mov    r8,rcx
  403183:	a8 01                	test   al,0x1
  403185:	0f 84 05 ff ff ff    	je     403090 <sched_thd_wakeup+0x1a0>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  40318b:	4c 8b 53 08          	mov    r10,QWORD PTR [rbx+0x8]
  40318f:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  403193:	48 89 f2             	mov    rdx,rsi
  403196:	45 89 e9             	mov    r9d,r13d
  403199:	4c 8b 05 48 ed 19 00 	mov    r8,QWORD PTR [rip+0x19ed48]        # 5a1ee8 <__slm_global+0x28>
  4031a0:	4c 89 d6             	mov    rsi,r10
  4031a3:	e8 78 e1 00 00       	call   411320 <cos_switch>
  4031a8:	41 89 c7             	mov    r15d,eax
	if (unlikely(ret != 0)) {
  4031ab:	45 85 ff             	test   r15d,r15d
  4031ae:	0f 84 ff fe ff ff    	je     4030b3 <sched_thd_wakeup+0x1c3>
		assert(ret != -EPERM);
  4031b4:	41 83 ff ff          	cmp    r15d,0xffffffff
  4031b8:	74 68                	je     403222 <sched_thd_wakeup+0x332>
		assert(ret != -EINVAL);
  4031ba:	41 83 ff ea          	cmp    r15d,0xffffffea
  4031be:	0f 84 cb 00 00 00    	je     40328f <sched_thd_wakeup+0x39f>
		if (ret == -EBUSY) return ret;
  4031c4:	41 83 ff f0          	cmp    r15d,0xfffffff0
  4031c8:	0f 84 5c fd ff ff    	je     402f2a <sched_thd_wakeup+0x3a>
		assert(ret == -EAGAIN);
  4031ce:	41 83 ff f5          	cmp    r15d,0xfffffff5
  4031d2:	0f 85 f8 00 00 00    	jne    4032d0 <sched_thd_wakeup+0x3e0>
		tok    = cos_sched_sync();
  4031d8:	e8 23 e1 00 00       	call   411300 <cos_sched_sync>
  4031dd:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4031e0:	48 8b 05 d9 ec 19 00 	mov    rax,QWORD PTR [rip+0x19ecd9]        # 5a1ec0 <__slm_global>
		if (unlikely(owner)) {
  4031e7:	48 89 c1             	mov    rcx,rax
  4031ea:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  4031ee:	0f 85 b7 00 00 00    	jne    4032ab <sched_thd_wakeup+0x3bb>
  4031f4:	f0 4c 0f b1 25 c3 ec 	lock cmpxchg QWORD PTR [rip+0x19ecc3],r12        # 5a1ec0 <__slm_global>
  4031fb:	19 00 
  4031fd:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  403200:	84 c0                	test   al,al
  403202:	0f 85 04 fe ff ff    	jne    40300c <sched_thd_wakeup+0x11c>
  403208:	eb ce                	jmp    4031d8 <sched_thd_wakeup+0x2e8>
  40320a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	return t != &g->idle_thd && t != &g->sched_thd;
  403210:	48 81 fb 40 1f 5a 00 	cmp    rbx,0x5a1f40
  403217:	74 31                	je     40324a <sched_thd_wakeup+0x35a>
  403219:	48 81 fb c8 1e 5a 00 	cmp    rbx,0x5a1ec8
  403220:	74 28                	je     40324a <sched_thd_wakeup+0x35a>
  403222:	be 61 00 00 00       	mov    esi,0x61
  403227:	bf b0 c8 41 00       	mov    edi,0x41c8b0
  40322c:	e8 9f 6e 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EPERM);
  403231:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403238:	00 00 00 00 
  40323c:	0f 0b                	ud2    
			prio    = curr->priority;
  40323e:	49 8b 74 24 30       	mov    rsi,QWORD PTR [r12+0x30]
			timeout = TCAP_TIME_NIL;
  403243:	31 c9                	xor    ecx,ecx
  403245:	e9 2e ff ff ff       	jmp    403178 <sched_thd_wakeup+0x288>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  40324a:	49 8b 54 24 30       	mov    rdx,QWORD PTR [r12+0x30]
  40324f:	4c 8b 05 92 ec 19 00 	mov    r8,QWORD PTR [rip+0x19ec92]        # 5a1ee8 <__slm_global+0x28>
  403256:	31 c9                	xor    ecx,ecx
  403258:	31 f6                	xor    esi,esi
  40325a:	48 8b 3d 77 ec 19 00 	mov    rdi,QWORD PTR [rip+0x19ec77]        # 5a1ed8 <__slm_global+0x18>
  403261:	45 89 e9             	mov    r9d,r13d
  403264:	e8 b7 e0 00 00       	call   411320 <cos_switch>
  403269:	41 89 c7             	mov    r15d,eax
  40326c:	e9 3a ff ff ff       	jmp    4031ab <sched_thd_wakeup+0x2bb>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  403271:	48 8b 7b 28          	mov    rdi,QWORD PTR [rbx+0x28]
  403275:	48 8b 15 6c ec 19 00 	mov    rdx,QWORD PTR [rip+0x19ec6c]        # 5a1ee8 <__slm_global+0x28>
  40327c:	44 89 e9             	mov    ecx,r13d
  40327f:	4c 89 c6             	mov    rsi,r8
  403282:	e8 09 e1 00 00       	call   411390 <cos_sched_asnd>
  403287:	41 89 c7             	mov    r15d,eax
  40328a:	e9 1c ff ff ff       	jmp    4031ab <sched_thd_wakeup+0x2bb>
  40328f:	be 61 00 00 00       	mov    esi,0x61
  403294:	bf 18 c9 41 00       	mov    edi,0x41c918
  403299:	e8 32 6e 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  40329e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4032a5:	00 00 00 00 
  4032a9:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  4032ab:	41 89 c0             	mov    r8d,eax
  4032ae:	4c 89 e2             	mov    rdx,r12
  4032b1:	48 89 c6             	mov    rsi,rax
  4032b4:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  4032b9:	41 83 e0 01          	and    r8d,0x1
  4032bd:	e8 4e 05 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  4032c2:	83 f8 f0             	cmp    eax,0xfffffff0
  4032c5:	0f 85 0d ff ff ff    	jne    4031d8 <sched_thd_wakeup+0x2e8>
  4032cb:	e9 60 fe ff ff       	jmp    403130 <sched_thd_wakeup+0x240>
  4032d0:	be 61 00 00 00       	mov    esi,0x61
  4032d5:	bf 80 c9 41 00       	mov    edi,0x41c980
  4032da:	e8 f1 6d 00 00       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  4032df:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4032e6:	00 00 00 00 
  4032ea:	0f 0b                	ud2    
  4032ec:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

00000000004032f0 <sched_debug_thd_state>:
{
  4032f0:	f3 0f 1e fa          	endbr64 
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  4032f4:	85 ff                	test   edi,edi
  4032f6:	0f 84 6e 1b 01 00    	je     414e6a <sched_debug_thd_state.cold>
  4032fc:	83 ef 01             	sub    edi,0x1
  4032ff:	83 ff 18             	cmp    edi,0x18
  403302:	0f 87 62 1b 01 00    	ja     414e6a <sched_debug_thd_state.cold>
  403308:	48 8b 04 fd 00 e7 45 	mov    rax,QWORD PTR [rdi*8+0x45e700]
  40330f:	00 
  403310:	48 a9 fe ff ff ff    	test   rax,0xfffffffffffffffe
  403316:	0f 84 4e 1b 01 00    	je     414e6a <sched_debug_thd_state.cold>
  40331c:	a8 01                	test   al,0x1
  40331e:	0f 85 46 1b 01 00    	jne    414e6a <sched_debug_thd_state.cold>
	return t->state;
  403324:	48 8d 04 bf          	lea    rax,[rdi+rdi*4]
  403328:	48 8d 04 47          	lea    rax,[rdi+rax*2]
  40332c:	48 c1 e0 04          	shl    rax,0x4
  403330:	8b 80 cc e7 45 00    	mov    eax,DWORD PTR [rax+0x45e7cc]
}
  403336:	c3                   	ret    
  403337:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40333e:	00 00 

0000000000403340 <sched_thd_block_timeout>:
{
  403340:	f3 0f 1e fa          	endbr64 
	if (dep_id) return 0;
  403344:	48 85 ff             	test   rdi,rdi
  403347:	74 07                	je     403350 <sched_thd_block_timeout+0x10>
  403349:	31 c0                	xor    eax,eax
}
  40334b:	c3                   	ret    
  40334c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
{
  403350:	55                   	push   rbp
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  403351:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  403354:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  40335a:	48 89 e5             	mov    rbp,rsp
  40335d:	41 57                	push   r15
  40335f:	41 56                	push   r14
  403361:	41 55                	push   r13
  403363:	49 89 f5             	mov    r13,rsi
  403366:	41 54                	push   r12
  403368:	53                   	push   rbx
  403369:	48 83 ec 08          	sub    rsp,0x8
  40336d:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403374:	48 85 c0             	test   rax,rax
  403377:	0f 84 bb 01 00 00    	je     403538 <sched_thd_block_timeout+0x1f8>
  40337d:	83 e8 01             	sub    eax,0x1
  403380:	83 f8 18             	cmp    eax,0x18
  403383:	0f 87 af 01 00 00    	ja     403538 <sched_thd_block_timeout+0x1f8>
  403389:	48 8b 14 c5 00 e7 45 	mov    rdx,QWORD PTR [rax*8+0x45e700]
  403390:	00 
  403391:	45 31 e4             	xor    r12d,r12d
  403394:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  40339b:	0f 85 5f 01 00 00    	jne    403500 <sched_thd_block_timeout+0x1c0>
static inline ps_tsc_t
ps_tsc(void)
{
	unsigned long a, d, c;

	__asm__ __volatile__("rdtsc" : "=a" (a), "=d" (d), "=c" (c) : : );
  4033a1:	0f 31                	rdtsc  

	return ((u64_t)d << 32) | (u64_t)a;
  4033a3:	48 c1 e2 20          	shl    rdx,0x20
  4033a7:	48 09 c2             	or     rdx,rax
 * more than 2^63 into the future.
 */
static inline int
cycles_greater_than(cycles_t g, cycles_t l)
{
	return (s64_t)(g - l) > 0;
  4033aa:	4c 89 e8             	mov    rax,r13
  4033ad:	48 29 d0             	sub    rax,rdx
	while (cycles_greater_than(timeout, slm_now())) {
  4033b0:	48 85 c0             	test   rax,rax
  4033b3:	0f 8e a7 02 00 00    	jle    403660 <sched_thd_block_timeout+0x320>
	assert(current);
  4033b9:	4d 85 e4             	test   r12,r12
  4033bc:	0f 84 ba 01 00 00    	je     40357c <sched_thd_block_timeout+0x23c>
		tok    = cos_sched_sync();
  4033c2:	e8 39 df 00 00       	call   411300 <cos_sched_sync>
  4033c7:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4033ca:	48 8b 05 ef ea 19 00 	mov    rax,QWORD PTR [rip+0x19eaef]        # 5a1ec0 <__slm_global>
		if (unlikely(owner)) {
  4033d1:	48 89 c1             	mov    rcx,rax
  4033d4:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  4033d8:	0f 85 62 01 00 00    	jne    403540 <sched_thd_block_timeout+0x200>
        __asm__ __volatile__("lock " PS_CAS_STR
  4033de:	f0 4c 0f b1 25 d9 ea 	lock cmpxchg QWORD PTR [rip+0x19ead9],r12        # 5a1ec0 <__slm_global>
  4033e5:	19 00 
  4033e7:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4033ea:	84 c0                	test   al,al
  4033ec:	74 d4                	je     4033c2 <sched_thd_block_timeout+0x82>
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  4033ee:	4c 89 ee             	mov    rsi,r13
  4033f1:	4c 89 e7             	mov    rdi,r12
  4033f4:	e8 57 f8 00 00       	call   412c50 <slm_timer_quantum_add>
		if (slm_timer_add(current, timeout)) goto done;
  4033f9:	85 c0                	test   eax,eax
  4033fb:	75 10                	jne    40340d <sched_thd_block_timeout+0xcd>
		if (slm_thd_block(current)) {
  4033fd:	4c 89 e7             	mov    rdi,r12
  403400:	e8 bb 04 01 00       	call   4138c0 <slm_thd_block>
  403405:	85 c0                	test   eax,eax
  403407:	0f 85 1b 01 00 00    	jne    403528 <sched_thd_block_timeout+0x1e8>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  40340d:	e8 4e 84 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	tok  = cos_sched_sync();
  403412:	e8 e9 de 00 00       	call   411300 <cos_sched_sync>
  403417:	41 89 c6             	mov    r14d,eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  40341a:	e8 71 f0 00 00       	call   412490 <slm_sched_fprr_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  40341f:	48 85 c0             	test   rax,rax
  403422:	48 89 c3             	mov    rbx,rax
  403425:	b8 40 1f 5a 00       	mov    eax,0x5a1f40
  40342a:	48 0f 44 d8          	cmove  rbx,rax
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  40342e:	8b 43 04             	mov    eax,DWORD PTR [rbx+0x4]
  403431:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  403434:	83 f8 01             	cmp    eax,0x1
  403437:	76 17                	jbe    403450 <sched_thd_block_timeout+0x110>
  403439:	e9 5a 01 00 00       	jmp    403598 <sched_thd_block_timeout+0x258>
  40343e:	66 90                	xchg   ax,ax
  403440:	f0 48 0f b1 15 77 ea 	lock cmpxchg QWORD PTR [rip+0x19ea77],rdx        # 5a1ec0 <__slm_global>
  403447:	19 00 
  403449:	0f 94 c0             	sete   al
	while (ret != 0) {
  40344c:	84 c0                	test   al,al
  40344e:	75 2e                	jne    40347e <sched_thd_block_timeout+0x13e>
		tok    = cos_sched_sync();
  403450:	e8 ab de 00 00       	call   411300 <cos_sched_sync>
  403455:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  403457:	48 8b 05 62 ea 19 00 	mov    rax,QWORD PTR [rip+0x19ea62]        # 5a1ec0 <__slm_global>
		if (unlikely(contention)) {
  40345e:	48 89 c2             	mov    rdx,rax
  403461:	83 e2 01             	and    edx,0x1
  403464:	74 da                	je     403440 <sched_thd_block_timeout+0x100>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  403466:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  403469:	48 89 c2             	mov    rdx,rax
  40346c:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  403471:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  403475:	e8 e6 03 01 00       	call   413860 <slm_cs_exit_contention>
  40347a:	85 c0                	test   eax,eax
  40347c:	75 d2                	jne    403450 <sched_thd_block_timeout+0x110>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  40347e:	e8 dd 83 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  403483:	8b 03                	mov    eax,DWORD PTR [rbx]
	timeout = g->timeout_next;
  403485:	4c 8b 05 3c eb 19 00 	mov    r8,QWORD PTR [rip+0x19eb3c]        # 5a1fc8 <__slm_global+0x108>
	prio = inherit_prio ? curr->priority : t->priority;
  40348c:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  403490:	a8 0b                	test   al,0xb
  403492:	0f 85 1c 01 00 00    	jne    4035b4 <sched_thd_block_timeout+0x274>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  403498:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  40349c:	44 89 f1             	mov    ecx,r14d
  40349f:	4c 89 c2             	mov    rdx,r8
  4034a2:	e8 b9 92 00 00       	call   40c760 <cos_defswitch>
  4034a7:	41 89 c7             	mov    r15d,eax
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  4034aa:	83 f8 ff             	cmp    eax,0xffffffff
  4034ad:	0f 84 e5 01 00 00    	je     403698 <sched_thd_block_timeout+0x358>
	if (unlikely(ret != 0)) {
  4034b3:	85 c0                	test   eax,eax
  4034b5:	0f 85 4f 01 00 00    	jne    40360a <sched_thd_block_timeout+0x2ca>
  4034bb:	45 31 ff             	xor    r15d,r15d
  4034be:	4c 89 e7             	mov    rdi,r12
  4034c1:	e8 1a f8 00 00       	call   412ce0 <slm_timer_quantum_cancel>
	__asm__ __volatile__("rdtsc" : "=a" (a), "=d" (d), "=c" (c) : : );
  4034c6:	0f 31                	rdtsc  
	return ((u64_t)d << 32) | (u64_t)a;
  4034c8:	48 c1 e2 20          	shl    rdx,0x20
  4034cc:	48 09 c2             	or     rdx,rax
  4034cf:	4c 89 e8             	mov    rax,r13
  4034d2:	48 29 d0             	sub    rax,rdx
	while (cycles_greater_than(timeout, slm_now())) {
  4034d5:	48 85 c0             	test   rax,rax
  4034d8:	0f 8f e4 fe ff ff    	jg     4033c2 <sched_thd_block_timeout+0x82>
	if (dep_id) return 0;
  4034de:	31 c0                	xor    eax,eax
	if (thd_block_until(abs_timeout)) return 0;
  4034e0:	45 85 ff             	test   r15d,r15d
  4034e3:	0f 84 77 01 00 00    	je     403660 <sched_thd_block_timeout+0x320>
}
  4034e9:	48 83 c4 08          	add    rsp,0x8
  4034ed:	5b                   	pop    rbx
  4034ee:	41 5c                	pop    r12
  4034f0:	41 5d                	pop    r13
  4034f2:	41 5e                	pop    r14
  4034f4:	41 5f                	pop    r15
  4034f6:	5d                   	pop    rbp
  4034f7:	c3                   	ret    
  4034f8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4034ff:	00 
  403500:	83 e2 01             	and    edx,0x1
  403503:	0f 85 98 fe ff ff    	jne    4033a1 <sched_thd_block_timeout+0x61>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403509:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  40350d:	4c 8d 24 50          	lea    r12,[rax+rdx*2]
  403511:	49 c1 e4 04          	shl    r12,0x4
  403515:	49 81 c4 c8 e7 45 00 	add    r12,0x45e7c8
  40351c:	e9 80 fe ff ff       	jmp    4033a1 <sched_thd_block_timeout+0x61>
  403521:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  403528:	4c 89 e7             	mov    rdi,r12
  40352b:	e8 b0 f7 00 00       	call   412ce0 <slm_timer_quantum_cancel>
  403530:	e9 d8 fe ff ff       	jmp    40340d <sched_thd_block_timeout+0xcd>
  403535:	0f 1f 00             	nop    DWORD PTR [rax]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403538:	45 31 e4             	xor    r12d,r12d
  40353b:	e9 61 fe ff ff       	jmp    4033a1 <sched_thd_block_timeout+0x61>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  403540:	41 89 c0             	mov    r8d,eax
  403543:	4c 89 e2             	mov    rdx,r12
  403546:	48 89 c6             	mov    rsi,rax
  403549:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  40354e:	41 83 e0 01          	and    r8d,0x1
  403552:	e8 b9 02 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  403557:	83 f8 f0             	cmp    eax,0xfffffff0
  40355a:	0f 85 62 fe ff ff    	jne    4033c2 <sched_thd_block_timeout+0x82>
  403560:	be 59 00 00 00       	mov    esi,0x59
  403565:	bf c0 c7 41 00       	mov    edi,0x41c7c0
  40356a:	e8 61 6b 00 00       	call   40a0d0 <cos_print_str>
  40356f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403576:	00 00 00 00 
  40357a:	0f 0b                	ud2    
  40357c:	be 59 00 00 00       	mov    esi,0x59
  403581:	bf 60 c7 41 00       	mov    edi,0x41c760
  403586:	e8 45 6b 00 00       	call   40a0d0 <cos_print_str>
	assert(current);
  40358b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403592:	00 00 00 00 
  403596:	0f 0b                	ud2    
  403598:	be 61 00 00 00       	mov    esi,0x61
  40359d:	bf 48 c8 41 00       	mov    edi,0x41c848
  4035a2:	e8 29 6b 00 00       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  4035a7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4035ae:	00 00 00 00 
  4035b2:	0f 0b                	ud2    
	timeout = g->timeout_next;
  4035b4:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  4035b7:	48 81 fb c8 1e 5a 00 	cmp    rbx,0x5a1ec8
  4035be:	0f 84 02 01 00 00    	je     4036c6 <sched_thd_block_timeout+0x386>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  4035c4:	a8 02                	test   al,0x2
  4035c6:	0f 85 06 01 00 00    	jne    4036d2 <sched_thd_block_timeout+0x392>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  4035cc:	49 89 c8             	mov    r8,rcx
  4035cf:	a8 01                	test   al,0x1
  4035d1:	0f 84 c1 fe ff ff    	je     403498 <sched_thd_block_timeout+0x158>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  4035d7:	4c 8b 53 08          	mov    r10,QWORD PTR [rbx+0x8]
  4035db:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  4035df:	48 89 f2             	mov    rdx,rsi
  4035e2:	45 89 f1             	mov    r9d,r14d
  4035e5:	4c 8b 05 fc e8 19 00 	mov    r8,QWORD PTR [rip+0x19e8fc]        # 5a1ee8 <__slm_global+0x28>
  4035ec:	4c 89 d6             	mov    rsi,r10
  4035ef:	e8 2c dd 00 00       	call   411320 <cos_switch>
  4035f4:	41 89 c7             	mov    r15d,eax
	if (unlikely(ret != 0)) {
  4035f7:	45 85 ff             	test   r15d,r15d
  4035fa:	0f 84 bb fe ff ff    	je     4034bb <sched_thd_block_timeout+0x17b>
		assert(ret != -EPERM);
  403600:	41 83 ff ff          	cmp    r15d,0xffffffff
  403604:	0f 84 a0 00 00 00    	je     4036aa <sched_thd_block_timeout+0x36a>
		assert(ret != -EINVAL);
  40360a:	41 83 ff ea          	cmp    r15d,0xffffffea
  40360e:	0f 84 03 01 00 00    	je     403717 <sched_thd_block_timeout+0x3d7>
		if (ret == -EBUSY) return ret;
  403614:	41 83 ff f0          	cmp    r15d,0xfffffff0
  403618:	0f 84 a0 fe ff ff    	je     4034be <sched_thd_block_timeout+0x17e>
		assert(ret == -EAGAIN);
  40361e:	41 83 ff f5          	cmp    r15d,0xfffffff5
  403622:	0f 85 0b 01 00 00    	jne    403733 <sched_thd_block_timeout+0x3f3>
		tok    = cos_sched_sync();
  403628:	e8 d3 dc 00 00       	call   411300 <cos_sched_sync>
  40362d:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  403630:	48 8b 05 89 e8 19 00 	mov    rax,QWORD PTR [rip+0x19e889]        # 5a1ec0 <__slm_global>
		if (unlikely(owner)) {
  403637:	48 89 c1             	mov    rcx,rax
  40363a:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  40363e:	0f 85 0b 01 00 00    	jne    40374f <sched_thd_block_timeout+0x40f>
        __asm__ __volatile__("lock " PS_CAS_STR
  403644:	f0 4c 0f b1 25 73 e8 	lock cmpxchg QWORD PTR [rip+0x19e873],r12        # 5a1ec0 <__slm_global>
  40364b:	19 00 
  40364d:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  403650:	84 c0                	test   al,al
  403652:	0f 85 ba fd ff ff    	jne    403412 <sched_thd_block_timeout+0xd2>
  403658:	eb ce                	jmp    403628 <sched_thd_block_timeout+0x2e8>
  40365a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	__asm__ __volatile__("rdtsc" : "=a" (a), "=d" (d), "=c" (c) : : );
  403660:	0f 31                	rdtsc  
	return ((u64_t)d << 32) | (u64_t)a;
  403662:	48 c1 e2 20          	shl    rdx,0x20
  403666:	48 09 d0             	or     rax,rdx
  403669:	48 89 c2             	mov    rdx,rax
  40366c:	4c 29 ea             	sub    rdx,r13
	assert(cycles_greater_than(now, abs_timeout));
  40366f:	48 85 d2             	test   rdx,rdx
  403672:	0f 8f 71 fe ff ff    	jg     4034e9 <sched_thd_block_timeout+0x1a9>
  403678:	be 24 00 00 00       	mov    esi,0x24
  40367d:	bf 88 cc 41 00       	mov    edi,0x41cc88
  403682:	e8 49 6a 00 00       	call   40a0d0 <cos_print_str>
  403687:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40368e:	00 00 00 00 
  403692:	0f 0b                	ud2    
  403694:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	return t != &g->idle_thd && t != &g->sched_thd;
  403698:	48 81 fb 40 1f 5a 00 	cmp    rbx,0x5a1f40
  40369f:	74 4f                	je     4036f0 <sched_thd_block_timeout+0x3b0>
  4036a1:	48 81 fb c8 1e 5a 00 	cmp    rbx,0x5a1ec8
  4036a8:	74 46                	je     4036f0 <sched_thd_block_timeout+0x3b0>
  4036aa:	be 61 00 00 00       	mov    esi,0x61
  4036af:	bf b0 c8 41 00       	mov    edi,0x41c8b0
  4036b4:	e8 17 6a 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EPERM);
  4036b9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4036c0:	00 00 00 00 
  4036c4:	0f 0b                	ud2    
			prio    = curr->priority;
  4036c6:	49 8b 74 24 30       	mov    rsi,QWORD PTR [r12+0x30]
			timeout = TCAP_TIME_NIL;
  4036cb:	31 c9                	xor    ecx,ecx
  4036cd:	e9 f2 fe ff ff       	jmp    4035c4 <sched_thd_block_timeout+0x284>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  4036d2:	48 8b 7b 28          	mov    rdi,QWORD PTR [rbx+0x28]
  4036d6:	48 8b 15 0b e8 19 00 	mov    rdx,QWORD PTR [rip+0x19e80b]        # 5a1ee8 <__slm_global+0x28>
  4036dd:	44 89 f1             	mov    ecx,r14d
  4036e0:	4c 89 c6             	mov    rsi,r8
  4036e3:	e8 a8 dc 00 00       	call   411390 <cos_sched_asnd>
  4036e8:	41 89 c7             	mov    r15d,eax
  4036eb:	e9 07 ff ff ff       	jmp    4035f7 <sched_thd_block_timeout+0x2b7>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  4036f0:	49 8b 54 24 30       	mov    rdx,QWORD PTR [r12+0x30]
  4036f5:	4c 8b 05 ec e7 19 00 	mov    r8,QWORD PTR [rip+0x19e7ec]        # 5a1ee8 <__slm_global+0x28>
  4036fc:	31 c9                	xor    ecx,ecx
  4036fe:	31 f6                	xor    esi,esi
  403700:	48 8b 3d d1 e7 19 00 	mov    rdi,QWORD PTR [rip+0x19e7d1]        # 5a1ed8 <__slm_global+0x18>
  403707:	45 89 f1             	mov    r9d,r14d
  40370a:	e8 11 dc 00 00       	call   411320 <cos_switch>
  40370f:	41 89 c7             	mov    r15d,eax
  403712:	e9 e0 fe ff ff       	jmp    4035f7 <sched_thd_block_timeout+0x2b7>
  403717:	be 61 00 00 00       	mov    esi,0x61
  40371c:	bf 18 c9 41 00       	mov    edi,0x41c918
  403721:	e8 aa 69 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  403726:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40372d:	00 00 00 00 
  403731:	0f 0b                	ud2    
  403733:	be 61 00 00 00       	mov    esi,0x61
  403738:	bf 80 c9 41 00       	mov    edi,0x41c980
  40373d:	e8 8e 69 00 00       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  403742:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403749:	00 00 00 00 
  40374d:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  40374f:	41 89 c0             	mov    r8d,eax
  403752:	4c 89 e2             	mov    rdx,r12
  403755:	48 89 c6             	mov    rsi,rax
  403758:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  40375d:	41 83 e0 01          	and    r8d,0x1
  403761:	e8 aa 00 01 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  403766:	83 f8 f0             	cmp    eax,0xfffffff0
  403769:	0f 85 b9 fe ff ff    	jne    403628 <sched_thd_block_timeout+0x2e8>
  40376f:	be 59 00 00 00       	mov    esi,0x59
  403774:	bf c0 c7 41 00       	mov    edi,0x41c7c0
  403779:	e8 52 69 00 00       	call   40a0d0 <cos_print_str>
  40377e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403785:	00 00 00 00 
  403789:	0f 0b                	ud2    
  40378b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000403790 <thd_sleep>:
{
  403790:	f3 0f 1e fa          	endbr64 
  403794:	55                   	push   rbp
  403795:	48 89 e5             	mov    rbp,rsp
  403798:	41 57                	push   r15
  40379a:	41 56                	push   r14
  40379c:	41 55                	push   r13
  40379e:	41 54                	push   r12
  4037a0:	53                   	push   rbx
  4037a1:	48 83 ec 08          	sub    rsp,0x8
	__asm__ __volatile__("rdtsc" : "=a" (a), "=d" (d), "=c" (c) : : );
  4037a5:	0f 31                	rdtsc  
	return ((u64_t)d << 32) | (u64_t)a;
  4037a7:	48 c1 e2 20          	shl    rdx,0x20
  4037ab:	48 09 c2             	or     rdx,rax
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  4037ae:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  4037b1:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
	cycles_t timeout = c + slm_now();
  4037b7:	4c 8d 2c 3a          	lea    r13,[rdx+rdi*1]
  4037bb:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  4037c2:	48 85 c0             	test   rax,rax
  4037c5:	0f 84 ad 01 00 00    	je     403978 <thd_sleep+0x1e8>
  4037cb:	83 e8 01             	sub    eax,0x1
  4037ce:	83 f8 18             	cmp    eax,0x18
  4037d1:	0f 87 a1 01 00 00    	ja     403978 <thd_sleep+0x1e8>
  4037d7:	48 8b 14 c5 00 e7 45 	mov    rdx,QWORD PTR [rax*8+0x45e700]
  4037de:	00 
  4037df:	45 31 e4             	xor    r12d,r12d
  4037e2:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  4037e9:	0f 85 51 01 00 00    	jne    403940 <thd_sleep+0x1b0>
	__asm__ __volatile__("rdtsc" : "=a" (a), "=d" (d), "=c" (c) : : );
  4037ef:	0f 31                	rdtsc  
	return ((u64_t)d << 32) | (u64_t)a;
  4037f1:	48 c1 e2 20          	shl    rdx,0x20
  4037f5:	48 09 c2             	or     rdx,rax
  4037f8:	4c 89 e8             	mov    rax,r13
  4037fb:	48 29 d0             	sub    rax,rdx
	while (cycles_greater_than(timeout, slm_now())) {
  4037fe:	48 85 c0             	test   rax,rax
  403801:	0f 8e da 02 00 00    	jle    403ae1 <thd_sleep+0x351>
	assert(current);
  403807:	4d 85 e4             	test   r12,r12
  40380a:	0f 84 ac 01 00 00    	je     4039bc <thd_sleep+0x22c>
		tok    = cos_sched_sync();
  403810:	e8 eb da 00 00       	call   411300 <cos_sched_sync>
  403815:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  403818:	48 8b 05 a1 e6 19 00 	mov    rax,QWORD PTR [rip+0x19e6a1]        # 5a1ec0 <__slm_global>
		if (unlikely(owner)) {
  40381f:	48 89 c1             	mov    rcx,rax
  403822:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  403826:	0f 85 54 01 00 00    	jne    403980 <thd_sleep+0x1f0>
        __asm__ __volatile__("lock " PS_CAS_STR
  40382c:	f0 4c 0f b1 25 8b e6 	lock cmpxchg QWORD PTR [rip+0x19e68b],r12        # 5a1ec0 <__slm_global>
  403833:	19 00 
  403835:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  403838:	84 c0                	test   al,al
  40383a:	74 d4                	je     403810 <thd_sleep+0x80>
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  40383c:	4c 89 ee             	mov    rsi,r13
  40383f:	4c 89 e7             	mov    rdi,r12
  403842:	e8 09 f4 00 00       	call   412c50 <slm_timer_quantum_add>
		if (slm_timer_add(current, timeout)) goto done;
  403847:	85 c0                	test   eax,eax
  403849:	75 10                	jne    40385b <thd_sleep+0xcb>
		if (slm_thd_block(current)) {
  40384b:	4c 89 e7             	mov    rdi,r12
  40384e:	e8 6d 00 01 00       	call   4138c0 <slm_thd_block>
  403853:	85 c0                	test   eax,eax
  403855:	0f 85 0d 01 00 00    	jne    403968 <thd_sleep+0x1d8>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  40385b:	e8 00 80 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	tok  = cos_sched_sync();
  403860:	e8 9b da 00 00       	call   411300 <cos_sched_sync>
  403865:	41 89 c6             	mov    r14d,eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  403868:	e8 23 ec 00 00       	call   412490 <slm_sched_fprr_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  40386d:	48 85 c0             	test   rax,rax
  403870:	48 89 c3             	mov    rbx,rax
  403873:	b8 40 1f 5a 00       	mov    eax,0x5a1f40
  403878:	48 0f 44 d8          	cmove  rbx,rax
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  40387c:	8b 43 04             	mov    eax,DWORD PTR [rbx+0x4]
  40387f:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  403882:	83 f8 01             	cmp    eax,0x1
  403885:	76 19                	jbe    4038a0 <thd_sleep+0x110>
  403887:	e9 4c 01 00 00       	jmp    4039d8 <thd_sleep+0x248>
  40388c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  403890:	f0 48 0f b1 15 27 e6 	lock cmpxchg QWORD PTR [rip+0x19e627],rdx        # 5a1ec0 <__slm_global>
  403897:	19 00 
  403899:	0f 94 c0             	sete   al
	while (ret != 0) {
  40389c:	84 c0                	test   al,al
  40389e:	75 2e                	jne    4038ce <thd_sleep+0x13e>
		tok    = cos_sched_sync();
  4038a0:	e8 5b da 00 00       	call   411300 <cos_sched_sync>
  4038a5:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4038a7:	48 8b 05 12 e6 19 00 	mov    rax,QWORD PTR [rip+0x19e612]        # 5a1ec0 <__slm_global>
		if (unlikely(contention)) {
  4038ae:	48 89 c2             	mov    rdx,rax
  4038b1:	83 e2 01             	and    edx,0x1
  4038b4:	74 da                	je     403890 <thd_sleep+0x100>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  4038b6:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  4038b9:	48 89 c2             	mov    rdx,rax
  4038bc:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  4038c1:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  4038c5:	e8 96 ff 00 00       	call   413860 <slm_cs_exit_contention>
  4038ca:	85 c0                	test   eax,eax
  4038cc:	75 d2                	jne    4038a0 <thd_sleep+0x110>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  4038ce:	e8 8d 7f 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4038d3:	8b 03                	mov    eax,DWORD PTR [rbx]
	timeout = g->timeout_next;
  4038d5:	4c 8b 05 ec e6 19 00 	mov    r8,QWORD PTR [rip+0x19e6ec]        # 5a1fc8 <__slm_global+0x108>
	prio = inherit_prio ? curr->priority : t->priority;
  4038dc:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4038e0:	a8 0b                	test   al,0xb
  4038e2:	0f 85 0c 01 00 00    	jne    4039f4 <thd_sleep+0x264>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  4038e8:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  4038ec:	44 89 f1             	mov    ecx,r14d
  4038ef:	4c 89 c2             	mov    rdx,r8
  4038f2:	e8 69 8e 00 00       	call   40c760 <cos_defswitch>
  4038f7:	41 89 c7             	mov    r15d,eax
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  4038fa:	83 f8 ff             	cmp    eax,0xffffffff
  4038fd:	0f 84 32 01 00 00    	je     403a35 <thd_sleep+0x2a5>
	if (unlikely(ret != 0)) {
  403903:	85 c0                	test   eax,eax
  403905:	0f 85 92 01 00 00    	jne    403a9d <thd_sleep+0x30d>
  40390b:	45 31 ff             	xor    r15d,r15d
  40390e:	4c 89 e7             	mov    rdi,r12
  403911:	e8 ca f3 00 00       	call   412ce0 <slm_timer_quantum_cancel>
	__asm__ __volatile__("rdtsc" : "=a" (a), "=d" (d), "=c" (c) : : );
  403916:	0f 31                	rdtsc  
	return ((u64_t)d << 32) | (u64_t)a;
  403918:	48 c1 e2 20          	shl    rdx,0x20
  40391c:	48 09 c2             	or     rdx,rax
  40391f:	4c 89 e8             	mov    rax,r13
  403922:	48 29 d0             	sub    rax,rdx
	while (cycles_greater_than(timeout, slm_now())) {
  403925:	48 85 c0             	test   rax,rax
  403928:	0f 8f e2 fe ff ff    	jg     403810 <thd_sleep+0x80>
}
  40392e:	48 83 c4 08          	add    rsp,0x8
  403932:	44 89 f8             	mov    eax,r15d
  403935:	5b                   	pop    rbx
  403936:	41 5c                	pop    r12
  403938:	41 5d                	pop    r13
  40393a:	41 5e                	pop    r14
  40393c:	41 5f                	pop    r15
  40393e:	5d                   	pop    rbp
  40393f:	c3                   	ret    
  403940:	83 e2 01             	and    edx,0x1
  403943:	0f 85 a6 fe ff ff    	jne    4037ef <thd_sleep+0x5f>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403949:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  40394d:	4c 8d 24 50          	lea    r12,[rax+rdx*2]
  403951:	49 c1 e4 04          	shl    r12,0x4
  403955:	49 81 c4 c8 e7 45 00 	add    r12,0x45e7c8
  40395c:	e9 8e fe ff ff       	jmp    4037ef <thd_sleep+0x5f>
  403961:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  403968:	4c 89 e7             	mov    rdi,r12
  40396b:	e8 70 f3 00 00       	call   412ce0 <slm_timer_quantum_cancel>
  403970:	e9 e6 fe ff ff       	jmp    40385b <thd_sleep+0xcb>
  403975:	0f 1f 00             	nop    DWORD PTR [rax]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403978:	45 31 e4             	xor    r12d,r12d
  40397b:	e9 6f fe ff ff       	jmp    4037ef <thd_sleep+0x5f>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  403980:	41 89 c0             	mov    r8d,eax
  403983:	4c 89 e2             	mov    rdx,r12
  403986:	48 89 c6             	mov    rsi,rax
  403989:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  40398e:	41 83 e0 01          	and    r8d,0x1
  403992:	e8 79 fe 00 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  403997:	83 f8 f0             	cmp    eax,0xfffffff0
  40399a:	0f 85 70 fe ff ff    	jne    403810 <thd_sleep+0x80>
  4039a0:	be 59 00 00 00       	mov    esi,0x59
  4039a5:	bf c0 c7 41 00       	mov    edi,0x41c7c0
  4039aa:	e8 21 67 00 00       	call   40a0d0 <cos_print_str>
  4039af:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4039b6:	00 00 00 00 
  4039ba:	0f 0b                	ud2    
  4039bc:	be 59 00 00 00       	mov    esi,0x59
  4039c1:	bf 60 c7 41 00       	mov    edi,0x41c760
  4039c6:	e8 05 67 00 00       	call   40a0d0 <cos_print_str>
	assert(current);
  4039cb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4039d2:	00 00 00 00 
  4039d6:	0f 0b                	ud2    
  4039d8:	be 61 00 00 00       	mov    esi,0x61
  4039dd:	bf 48 c8 41 00       	mov    edi,0x41c848
  4039e2:	e8 e9 66 00 00       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  4039e7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4039ee:	00 00 00 00 
  4039f2:	0f 0b                	ud2    
	timeout = g->timeout_next;
  4039f4:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  4039f7:	48 81 fb c8 1e 5a 00 	cmp    rbx,0x5a1ec8
  4039fe:	74 63                	je     403a63 <thd_sleep+0x2d3>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  403a00:	a8 02                	test   al,0x2
  403a02:	0f 85 e1 00 00 00    	jne    403ae9 <thd_sleep+0x359>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  403a08:	49 89 c8             	mov    r8,rcx
  403a0b:	a8 01                	test   al,0x1
  403a0d:	0f 84 d5 fe ff ff    	je     4038e8 <thd_sleep+0x158>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  403a13:	4c 8b 53 08          	mov    r10,QWORD PTR [rbx+0x8]
  403a17:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  403a1b:	48 89 f2             	mov    rdx,rsi
  403a1e:	45 89 f1             	mov    r9d,r14d
  403a21:	4c 8b 05 c0 e4 19 00 	mov    r8,QWORD PTR [rip+0x19e4c0]        # 5a1ee8 <__slm_global+0x28>
  403a28:	4c 89 d6             	mov    rsi,r10
  403a2b:	e8 f0 d8 00 00       	call   411320 <cos_switch>
  403a30:	41 89 c7             	mov    r15d,eax
  403a33:	eb 59                	jmp    403a8e <thd_sleep+0x2fe>
	return t != &g->idle_thd && t != &g->sched_thd;
  403a35:	48 81 fb 40 1f 5a 00 	cmp    rbx,0x5a1f40
  403a3c:	74 2e                	je     403a6c <thd_sleep+0x2dc>
  403a3e:	48 81 fb c8 1e 5a 00 	cmp    rbx,0x5a1ec8
  403a45:	74 25                	je     403a6c <thd_sleep+0x2dc>
  403a47:	be 61 00 00 00       	mov    esi,0x61
  403a4c:	bf b0 c8 41 00       	mov    edi,0x41c8b0
  403a51:	e8 7a 66 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EPERM);
  403a56:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403a5d:	00 00 00 00 
  403a61:	0f 0b                	ud2    
			prio    = curr->priority;
  403a63:	49 8b 74 24 30       	mov    rsi,QWORD PTR [r12+0x30]
			timeout = TCAP_TIME_NIL;
  403a68:	31 c9                	xor    ecx,ecx
  403a6a:	eb 94                	jmp    403a00 <thd_sleep+0x270>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  403a6c:	49 8b 54 24 30       	mov    rdx,QWORD PTR [r12+0x30]
  403a71:	4c 8b 05 70 e4 19 00 	mov    r8,QWORD PTR [rip+0x19e470]        # 5a1ee8 <__slm_global+0x28>
  403a78:	31 c9                	xor    ecx,ecx
  403a7a:	31 f6                	xor    esi,esi
  403a7c:	48 8b 3d 55 e4 19 00 	mov    rdi,QWORD PTR [rip+0x19e455]        # 5a1ed8 <__slm_global+0x18>
  403a83:	45 89 f1             	mov    r9d,r14d
  403a86:	e8 95 d8 00 00       	call   411320 <cos_switch>
  403a8b:	41 89 c7             	mov    r15d,eax
	if (unlikely(ret != 0)) {
  403a8e:	45 85 ff             	test   r15d,r15d
  403a91:	0f 84 74 fe ff ff    	je     40390b <thd_sleep+0x17b>
		assert(ret != -EPERM);
  403a97:	41 83 ff ff          	cmp    r15d,0xffffffff
  403a9b:	74 aa                	je     403a47 <thd_sleep+0x2b7>
		assert(ret != -EINVAL);
  403a9d:	41 83 ff ea          	cmp    r15d,0xffffffea
  403aa1:	74 61                	je     403b04 <thd_sleep+0x374>
		if (ret == -EBUSY) return ret;
  403aa3:	41 83 ff f0          	cmp    r15d,0xfffffff0
  403aa7:	0f 84 61 fe ff ff    	je     40390e <thd_sleep+0x17e>
		assert(ret == -EAGAIN);
  403aad:	41 83 ff f5          	cmp    r15d,0xfffffff5
  403ab1:	75 6d                	jne    403b20 <thd_sleep+0x390>
		tok    = cos_sched_sync();
  403ab3:	e8 48 d8 00 00       	call   411300 <cos_sched_sync>
  403ab8:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  403abb:	48 8b 05 fe e3 19 00 	mov    rax,QWORD PTR [rip+0x19e3fe]        # 5a1ec0 <__slm_global>
		if (unlikely(owner)) {
  403ac2:	48 89 c1             	mov    rcx,rax
  403ac5:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  403ac9:	75 71                	jne    403b3c <thd_sleep+0x3ac>
        __asm__ __volatile__("lock " PS_CAS_STR
  403acb:	f0 4c 0f b1 25 ec e3 	lock cmpxchg QWORD PTR [rip+0x19e3ec],r12        # 5a1ec0 <__slm_global>
  403ad2:	19 00 
  403ad4:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  403ad7:	84 c0                	test   al,al
  403ad9:	0f 85 81 fd ff ff    	jne    403860 <thd_sleep+0xd0>
  403adf:	eb d2                	jmp    403ab3 <thd_sleep+0x323>
	int ret = 0;
  403ae1:	45 31 ff             	xor    r15d,r15d
	return thd_block_until(timeout);
  403ae4:	e9 45 fe ff ff       	jmp    40392e <thd_sleep+0x19e>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  403ae9:	48 8b 7b 28          	mov    rdi,QWORD PTR [rbx+0x28]
  403aed:	48 8b 15 f4 e3 19 00 	mov    rdx,QWORD PTR [rip+0x19e3f4]        # 5a1ee8 <__slm_global+0x28>
  403af4:	44 89 f1             	mov    ecx,r14d
  403af7:	4c 89 c6             	mov    rsi,r8
  403afa:	e8 91 d8 00 00       	call   411390 <cos_sched_asnd>
  403aff:	41 89 c7             	mov    r15d,eax
  403b02:	eb 8a                	jmp    403a8e <thd_sleep+0x2fe>
  403b04:	be 61 00 00 00       	mov    esi,0x61
  403b09:	bf 18 c9 41 00       	mov    edi,0x41c918
  403b0e:	e8 bd 65 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  403b13:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403b1a:	00 00 00 00 
  403b1e:	0f 0b                	ud2    
  403b20:	be 61 00 00 00       	mov    esi,0x61
  403b25:	bf 80 c9 41 00       	mov    edi,0x41c980
  403b2a:	e8 a1 65 00 00       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  403b2f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403b36:	00 00 00 00 
  403b3a:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  403b3c:	41 89 c0             	mov    r8d,eax
  403b3f:	4c 89 e2             	mov    rdx,r12
  403b42:	48 89 c6             	mov    rsi,rax
  403b45:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  403b4a:	41 83 e0 01          	and    r8d,0x1
  403b4e:	e8 bd fc 00 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  403b53:	83 f8 f0             	cmp    eax,0xfffffff0
  403b56:	0f 85 57 ff ff ff    	jne    403ab3 <thd_sleep+0x323>
  403b5c:	e9 3f fe ff ff       	jmp    4039a0 <thd_sleep+0x210>
  403b61:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  403b68:	00 00 00 00 
  403b6c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000403b70 <sched_blkpt_alloc>:
{
  403b70:	f3 0f 1e fa          	endbr64 
  403b74:	55                   	push   rbp
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  403b75:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  403b78:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  403b7e:	48 89 e5             	mov    rbp,rsp
  403b81:	41 54                	push   r12
  403b83:	48 83 ec 08          	sub    rsp,0x8
  403b87:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403b8e:	48 85 c0             	test   rax,rax
  403b91:	0f 84 09 01 00 00    	je     403ca0 <sched_blkpt_alloc+0x130>
  403b97:	83 e8 01             	sub    eax,0x1
  403b9a:	83 f8 18             	cmp    eax,0x18
  403b9d:	0f 87 fd 00 00 00    	ja     403ca0 <sched_blkpt_alloc+0x130>
  403ba3:	48 8b 14 c5 00 e7 45 	mov    rdx,QWORD PTR [rax*8+0x45e700]
  403baa:	00 
  403bab:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  403bb2:	0f 84 e8 00 00 00    	je     403ca0 <sched_blkpt_alloc+0x130>
  403bb8:	83 e2 01             	and    edx,0x1
  403bbb:	0f 85 df 00 00 00    	jne    403ca0 <sched_blkpt_alloc+0x130>
	return &ss_thd_get(cos_thdid())->thd;
  403bc1:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  403bc5:	4c 8d 24 50          	lea    r12,[rax+rdx*2]
  403bc9:	49 c1 e4 04          	shl    r12,0x4
  403bcd:	49 81 c4 c8 e7 45 00 	add    r12,0x45e7c8
		tok    = cos_sched_sync();
  403bd4:	e8 27 d7 00 00       	call   411300 <cos_sched_sync>
  403bd9:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  403bdc:	48 8b 05 dd e2 19 00 	mov    rax,QWORD PTR [rip+0x19e2dd]        # 5a1ec0 <__slm_global>
		if (unlikely(owner)) {
  403be3:	48 89 c1             	mov    rcx,rax
  403be6:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  403bea:	0f 85 d0 00 00 00    	jne    403cc0 <sched_blkpt_alloc+0x150>
  403bf0:	f0 4c 0f b1 25 c7 e2 	lock cmpxchg QWORD PTR [rip+0x19e2c7],r12        # 5a1ec0 <__slm_global>
  403bf7:	19 00 
  403bf9:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  403bfc:	84 c0                	test   al,al
  403bfe:	74 d4                	je     403bd4 <sched_blkpt_alloc+0x64>
	id = (sched_blkpt_id_t)__blkpt_offset;
  403c00:	44 8b 25 f9 03 02 00 	mov    r12d,DWORD PTR [rip+0x203f9]        # 424000 <__blkpt_offset>
	if (id - 1 == NBLKPTS) return NULL;
  403c07:	41 81 fc 01 a0 00 00 	cmp    r12d,0xa001
  403c0e:	0f 84 e8 00 00 00    	je     403cfc <sched_blkpt_alloc+0x18c>
	return &__blkpts[id-1];
  403c14:	41 8d 44 24 ff       	lea    eax,[r12-0x1]
  403c19:	48 c1 e0 05          	shl    rax,0x5
	m->id    = id;
  403c1d:	44 89 a0 00 f9 45 00 	mov    DWORD PTR [rax+0x45f900],r12d
	m->epoch = 0;
  403c24:	48 c7 80 08 f9 45 00 	mov    QWORD PTR [rax+0x45f908],0x0
  403c2b:	00 00 00 00 
	h->head = NULL;
  403c2f:	48 c7 80 10 f9 45 00 	mov    QWORD PTR [rax+0x45f910],0x0
  403c36:	00 00 00 00 
{ l->o = 0; }
  403c3a:	48 c7 80 18 f9 45 00 	mov    QWORD PTR [rax+0x45f918],0x0
  403c41:	00 00 00 00 
	__blkpt_offset++;
  403c45:	41 8d 44 24 01       	lea    eax,[r12+0x1]
  403c4a:	89 05 b0 03 02 00    	mov    DWORD PTR [rip+0x203b0],eax        # 424000 <__blkpt_offset>
  403c50:	eb 16                	jmp    403c68 <sched_blkpt_alloc+0xf8>
  403c52:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  403c58:	f0 48 0f b1 15 5f e2 	lock cmpxchg QWORD PTR [rip+0x19e25f],rdx        # 5a1ec0 <__slm_global>
  403c5f:	19 00 
  403c61:	0f 94 c0             	sete   al
	while (ret != 0) {
  403c64:	84 c0                	test   al,al
  403c66:	75 2e                	jne    403c96 <sched_blkpt_alloc+0x126>
		tok    = cos_sched_sync();
  403c68:	e8 93 d6 00 00       	call   411300 <cos_sched_sync>
  403c6d:	89 c1                	mov    ecx,eax
  403c6f:	48 8b 05 4a e2 19 00 	mov    rax,QWORD PTR [rip+0x19e24a]        # 5a1ec0 <__slm_global>
		if (unlikely(contention)) {
  403c76:	48 89 c2             	mov    rdx,rax
  403c79:	83 e2 01             	and    edx,0x1
  403c7c:	74 da                	je     403c58 <sched_blkpt_alloc+0xe8>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  403c7e:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  403c81:	48 89 c2             	mov    rdx,rax
  403c84:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  403c89:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  403c8d:	e8 ce fb 00 00       	call   413860 <slm_cs_exit_contention>
  403c92:	85 c0                	test   eax,eax
  403c94:	75 d2                	jne    403c68 <sched_blkpt_alloc+0xf8>
}
  403c96:	44 89 e0             	mov    eax,r12d
  403c99:	4c 8b 65 f8          	mov    r12,QWORD PTR [rbp-0x8]
  403c9d:	c9                   	leave  
  403c9e:	c3                   	ret    
  403c9f:	90                   	nop
  403ca0:	be 59 00 00 00       	mov    esi,0x59
  403ca5:	bf 60 c7 41 00       	mov    edi,0x41c760
  403caa:	e8 21 64 00 00       	call   40a0d0 <cos_print_str>
	assert(current);
  403caf:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403cb6:	00 00 00 00 
  403cba:	0f 0b                	ud2    
  403cbc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  403cc0:	41 89 c0             	mov    r8d,eax
  403cc3:	4c 89 e2             	mov    rdx,r12
  403cc6:	48 89 c6             	mov    rsi,rax
  403cc9:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  403cce:	41 83 e0 01          	and    r8d,0x1
  403cd2:	e8 39 fb 00 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  403cd7:	83 f8 f0             	cmp    eax,0xfffffff0
  403cda:	0f 85 f4 fe ff ff    	jne    403bd4 <sched_blkpt_alloc+0x64>
  403ce0:	be 59 00 00 00       	mov    esi,0x59
  403ce5:	bf c0 c7 41 00       	mov    edi,0x41c7c0
  403cea:	e8 e1 63 00 00       	call   40a0d0 <cos_print_str>
  403cef:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403cf6:	00 00 00 00 
  403cfa:	0f 0b                	ud2    
	if (!m) ERR_THROW(SCHED_BLKPT_NULL, unlock);
  403cfc:	45 31 e4             	xor    r12d,r12d
	while (ret != 0) {
  403cff:	e9 64 ff ff ff       	jmp    403c68 <sched_blkpt_alloc+0xf8>
  403d04:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  403d0b:	00 00 00 00 
  403d0f:	90                   	nop

0000000000403d10 <sched_blkpt_free>:
  403d10:	f3 0f 1e fa          	endbr64 
  403d14:	31 c0                	xor    eax,eax
  403d16:	c3                   	ret    
  403d17:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  403d1e:	00 00 

0000000000403d20 <sched_blkpt_trigger>:
{
  403d20:	f3 0f 1e fa          	endbr64 
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  403d24:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  403d27:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  403d2d:	49 89 f0             	mov    r8,rsi
  403d30:	89 d1                	mov    ecx,edx
  403d32:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403d39:	48 85 c0             	test   rax,rax
  403d3c:	74 42                	je     403d80 <sched_blkpt_trigger+0x60>
  403d3e:	83 e8 01             	sub    eax,0x1
  403d41:	83 f8 18             	cmp    eax,0x18
  403d44:	77 3a                	ja     403d80 <sched_blkpt_trigger+0x60>
  403d46:	48 8b 14 c5 00 e7 45 	mov    rdx,QWORD PTR [rax*8+0x45e700]
  403d4d:	00 
  403d4e:	31 f6                	xor    esi,esi
  403d50:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  403d57:	74 18                	je     403d71 <sched_blkpt_trigger+0x51>
  403d59:	83 e2 01             	and    edx,0x1
  403d5c:	75 13                	jne    403d71 <sched_blkpt_trigger+0x51>
  403d5e:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  403d62:	48 8d 34 50          	lea    rsi,[rax+rdx*2]
  403d66:	48 c1 e6 04          	shl    rsi,0x4
  403d6a:	48 81 c6 c8 e7 45 00 	add    rsi,0x45e7c8
	return slm_blkpt_trigger(blkpt, current, epoch, single);
  403d71:	4c 89 c2             	mov    rdx,r8
  403d74:	e9 07 d0 ff ff       	jmp    400d80 <slm_blkpt_trigger>
  403d79:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403d80:	31 f6                	xor    esi,esi
	return slm_blkpt_trigger(blkpt, current, epoch, single);
  403d82:	4c 89 c2             	mov    rdx,r8
  403d85:	e9 f6 cf ff ff       	jmp    400d80 <slm_blkpt_trigger>
  403d8a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000403d90 <sched_blkpt_block>:
{
  403d90:	f3 0f 1e fa          	endbr64 
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  403d94:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  403d97:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  403d9d:	49 89 f0             	mov    r8,rsi
  403da0:	48 89 d1             	mov    rcx,rdx
  403da3:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403daa:	48 85 c0             	test   rax,rax
  403dad:	74 41                	je     403df0 <sched_blkpt_block+0x60>
  403daf:	83 e8 01             	sub    eax,0x1
  403db2:	83 f8 18             	cmp    eax,0x18
  403db5:	77 39                	ja     403df0 <sched_blkpt_block+0x60>
  403db7:	48 8b 14 c5 00 e7 45 	mov    rdx,QWORD PTR [rax*8+0x45e700]
  403dbe:	00 
  403dbf:	31 f6                	xor    esi,esi
  403dc1:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  403dc8:	74 18                	je     403de2 <sched_blkpt_block+0x52>
  403dca:	83 e2 01             	and    edx,0x1
  403dcd:	75 13                	jne    403de2 <sched_blkpt_block+0x52>
  403dcf:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  403dd3:	48 8d 34 50          	lea    rsi,[rax+rdx*2]
  403dd7:	48 c1 e6 04          	shl    rsi,0x4
  403ddb:	48 81 c6 c8 e7 45 00 	add    rsi,0x45e7c8
	return slm_blkpt_block(blkpt, current, epoch, dependency);
  403de2:	4c 89 c2             	mov    rdx,r8
  403de5:	e9 e6 d3 ff ff       	jmp    4011d0 <slm_blkpt_block>
  403dea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403df0:	31 f6                	xor    esi,esi
	return slm_blkpt_block(blkpt, current, epoch, dependency);
  403df2:	4c 89 c2             	mov    rdx,r8
  403df5:	e9 d6 d3 ff ff       	jmp    4011d0 <slm_blkpt_block>
  403dfa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000403e00 <syncipc_call>:
{
  403e00:	f3 0f 1e fa          	endbr64 
  403e04:	55                   	push   rbp
  403e05:	66 48 0f 6e ce       	movq   xmm1,rsi
  403e0a:	66 48 0f 6e d2       	movq   xmm2,rdx
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  403e0f:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  403e12:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  403e18:	66 0f 6c ca          	punpcklqdq xmm1,xmm2
  403e1c:	48 89 e5             	mov    rbp,rsp
  403e1f:	41 57                	push   r15
  403e21:	41 56                	push   r14
  403e23:	49 89 ce             	mov    r14,rcx
  403e26:	41 55                	push   r13
  403e28:	4d 89 c5             	mov    r13,r8
  403e2b:	41 54                	push   r12
  403e2d:	53                   	push   rbx
  403e2e:	48 83 ec 38          	sub    rsp,0x38
  403e32:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
  403e39:	0f 29 4d a0          	movaps XMMWORD PTR [rbp-0x60],xmm1
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403e3d:	48 85 c0             	test   rax,rax
  403e40:	0f 84 62 01 00 00    	je     403fa8 <syncipc_call+0x1a8>
  403e46:	83 e8 01             	sub    eax,0x1
  403e49:	83 f8 18             	cmp    eax,0x18
  403e4c:	0f 87 56 01 00 00    	ja     403fa8 <syncipc_call+0x1a8>
  403e52:	48 8b 14 c5 00 e7 45 	mov    rdx,QWORD PTR [rax*8+0x45e700]
  403e59:	00 
  403e5a:	31 db                	xor    ebx,ebx
  403e5c:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  403e63:	0f 85 17 01 00 00    	jne    403f80 <syncipc_call+0x180>
	counts[type]++;
  403e69:	48 83 05 8f a2 05 00 	add    QWORD PTR [rip+0x5a28f],0x1        # 45e100 <counts>
  403e70:	01 
	struct ipc_retvals retvals = { .ready = 0 };
  403e71:	66 0f ef c0          	pxor   xmm0,xmm0
	if (ep->server == NULL) return -EAGAIN;
  403e75:	48 83 3d cb a2 05 00 	cmp    QWORD PTR [rip+0x5a2cb],0x0        # 45e148 <eps+0x8>
  403e7c:	00 
	struct ipc_retvals retvals = { .ready = 0 };
  403e7d:	48 c7 45 c0 00 00 00 	mov    QWORD PTR [rbp-0x40],0x0
  403e84:	00 
  403e85:	0f 29 45 b0          	movaps XMMWORD PTR [rbp-0x50],xmm0
	if (ep->server == NULL) return -EAGAIN;
  403e89:	0f 84 29 02 00 00    	je     4040b8 <syncipc_call+0x2b8>
		tok      = cos_sched_sync();
  403e8f:	e8 6c d4 00 00       	call   411300 <cos_sched_sync>
		switchto = ps_load(&ep->server);
  403e94:	4c 8b 3d ad a2 05 00 	mov    r15,QWORD PTR [rip+0x5a2ad]        # 45e148 <eps+0x8>
		tok      = cos_sched_sync();
  403e9b:	41 89 c4             	mov    r12d,eax
  403e9e:	31 c0                	xor    eax,eax
  403ea0:	f0 48 0f b1 1d 97 a2 	lock cmpxchg QWORD PTR [rip+0x5a297],rbx        # 45e140 <eps>
  403ea7:	05 00 
  403ea9:	0f 94 c0             	sete   al
		if (likely(ps_cas((unsigned long *)&ep->client, 0, (unsigned long)t))) {
  403eac:	84 c0                	test   al,al
  403eae:	0f 84 fc 00 00 00    	je     403fb0 <syncipc_call+0x1b0>
			ep->retvals = &retvals;
  403eb4:	48 8d 45 b0          	lea    rax,[rbp-0x50]
			ep->a0      = arg0;
  403eb8:	66 0f 6f 5d a0       	movdqa xmm3,XMMWORD PTR [rbp-0x60]
			ep->retvals = &retvals;
  403ebd:	48 89 05 9c a2 05 00 	mov    QWORD PTR [rip+0x5a29c],rax        # 45e160 <eps+0x20>
			assert(ps_load(&ep->client) == t);
  403ec4:	48 8b 05 75 a2 05 00 	mov    rax,QWORD PTR [rip+0x5a275]        # 45e140 <eps>
			ep->a0      = arg0;
  403ecb:	0f 29 1d 7e a2 05 00 	movaps XMMWORD PTR [rip+0x5a27e],xmm3        # 45e150 <eps+0x10>
			assert(ps_load(&ep->client) == t);
  403ed2:	48 39 d8             	cmp    rax,rbx
  403ed5:	0f 85 0f 01 00 00    	jne    403fea <syncipc_call+0x1ea>
		client = ps_load(&ep->client);
  403edb:	48 8b 05 5e a2 05 00 	mov    rax,QWORD PTR [rip+0x5a25e]        # 45e140 <eps>
	__asm__ __volatile__("rdtsc" : "=a" (a), "=d" (d), "=c" (c) : : );
  403ee2:	0f 31                	rdtsc  
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  403ee4:	41 8b 47 04          	mov    eax,DWORD PTR [r15+0x4]
  403ee8:	83 e8 02             	sub    eax,0x2
 * - `inherit_prio` - should `to` inherit `curr`'s priority?
 */
static inline int
slm_switch_to(struct slm_thd *curr, struct slm_thd *to, sched_tok_t tok, int inherit_prio)
{
	if (unlikely(!slm_state_is_runnable(to->state))) return 1;
  403eeb:	83 f8 01             	cmp    eax,0x1
  403eee:	0f 87 e4 00 00 00    	ja     403fd8 <syncipc_call+0x1d8>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  403ef4:	e8 67 79 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  403ef9:	41 8b 07             	mov    eax,DWORD PTR [r15]
	timeout = g->timeout_next;
  403efc:	4c 8b 05 c5 e0 19 00 	mov    r8,QWORD PTR [rip+0x19e0c5]        # 5a1fc8 <__slm_global+0x108>
	prio = inherit_prio ? curr->priority : t->priority;
  403f03:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  403f07:	a8 0b                	test   al,0xb
  403f09:	0f 85 f7 00 00 00    	jne    404006 <syncipc_call+0x206>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  403f0f:	49 8b 7f 10          	mov    rdi,QWORD PTR [r15+0x10]
  403f13:	4c 89 c2             	mov    rdx,r8
  403f16:	44 89 e1             	mov    ecx,r12d
  403f19:	e8 42 88 00 00       	call   40c760 <cos_defswitch>
  403f1e:	41 89 c0             	mov    r8d,eax
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  403f21:	83 f8 ff             	cmp    eax,0xffffffff
  403f24:	0f 84 21 01 00 00    	je     40404b <syncipc_call+0x24b>
		if (unlikely(ret)) {
  403f2a:	45 85 c0             	test   r8d,r8d
  403f2d:	40 0f 95 c6          	setne  sil
			if (ret != -EAGAIN) return ret;
  403f31:	41 83 f8 f5          	cmp    r8d,0xfffffff5
  403f35:	0f 95 c0             	setne  al
  403f38:	21 c6                	and    esi,eax
  403f3a:	0f 31                	rdtsc  
	counts[type]++;
  403f3c:	48 83 05 c4 a1 05 00 	add    QWORD PTR [rip+0x5a1c4],0x1        # 45e108 <counts+0x8>
  403f43:	01 
			if (ret != -EAGAIN) return ret;
  403f44:	40 84 f6             	test   sil,sil
  403f47:	75 25                	jne    403f6e <syncipc_call+0x16e>
		if (likely(ps_load(&retvals.ready))) break;
  403f49:	8b 45 b0             	mov    eax,DWORD PTR [rbp-0x50]
  403f4c:	85 c0                	test   eax,eax
  403f4e:	0f 84 3b ff ff ff    	je     403e8f <syncipc_call+0x8f>
	*ret0 = ps_load(&retvals.r0);
  403f54:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
	counts[type]++;
  403f58:	48 83 05 b0 a1 05 00 	add    QWORD PTR [rip+0x5a1b0],0x1        # 45e110 <counts+0x10>
  403f5f:	01 
	return 0;
  403f60:	45 31 c0             	xor    r8d,r8d
	*ret0 = ps_load(&retvals.r0);
  403f63:	49 89 06             	mov    QWORD PTR [r14],rax
	*ret1 = ps_load(&retvals.r1);
  403f66:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
  403f6a:	49 89 45 00          	mov    QWORD PTR [r13+0x0],rax
}
  403f6e:	48 83 c4 38          	add    rsp,0x38
  403f72:	44 89 c0             	mov    eax,r8d
  403f75:	5b                   	pop    rbx
  403f76:	41 5c                	pop    r12
  403f78:	41 5d                	pop    r13
  403f7a:	41 5e                	pop    r14
  403f7c:	41 5f                	pop    r15
  403f7e:	5d                   	pop    rbp
  403f7f:	c3                   	ret    
  403f80:	83 e2 01             	and    edx,0x1
  403f83:	0f 85 e0 fe ff ff    	jne    403e69 <syncipc_call+0x69>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403f89:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  403f8d:	48 8d 1c 50          	lea    rbx,[rax+rdx*2]
  403f91:	48 c1 e3 04          	shl    rbx,0x4
  403f95:	48 81 c3 c8 e7 45 00 	add    rbx,0x45e7c8
  403f9c:	e9 c8 fe ff ff       	jmp    403e69 <syncipc_call+0x69>
  403fa1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  403fa8:	31 db                	xor    ebx,ebx
  403faa:	e9 ba fe ff ff       	jmp    403e69 <syncipc_call+0x69>
  403faf:	90                   	nop
		if (unlikely(ep->client != t && ep->retvals == NULL)) switchto = client;
  403fb0:	48 39 1d 89 a1 05 00 	cmp    QWORD PTR [rip+0x5a189],rbx        # 45e140 <eps>
		client = ps_load(&ep->client);
  403fb7:	48 8b 05 82 a1 05 00 	mov    rax,QWORD PTR [rip+0x5a182]        # 45e140 <eps>
		if (unlikely(ep->client != t && ep->retvals == NULL)) switchto = client;
  403fbe:	0f 84 1e ff ff ff    	je     403ee2 <syncipc_call+0xe2>
		client = ps_load(&ep->client);
  403fc4:	48 83 3d 94 a1 05 00 	cmp    QWORD PTR [rip+0x5a194],0x0        # 45e160 <eps+0x20>
  403fcb:	00 
  403fcc:	4c 0f 44 f8          	cmove  r15,rax
  403fd0:	e9 0d ff ff ff       	jmp    403ee2 <syncipc_call+0xe2>
  403fd5:	0f 1f 00             	nop    DWORD PTR [rax]
  403fd8:	0f 31                	rdtsc  
	counts[type]++;
  403fda:	48 83 05 26 a1 05 00 	add    QWORD PTR [rip+0x5a126],0x1        # 45e108 <counts+0x8>
  403fe1:	01 
  403fe2:	41 b8 01 00 00 00    	mov    r8d,0x1
  403fe8:	eb 84                	jmp    403f6e <syncipc_call+0x16e>
  403fea:	be 24 00 00 00       	mov    esi,0x24
  403fef:	bf b0 cc 41 00       	mov    edi,0x41ccb0
  403ff4:	e8 d7 60 00 00       	call   40a0d0 <cos_print_str>
			assert(ps_load(&ep->client) == t);
  403ff9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404000:	00 00 00 00 
  404004:	0f 0b                	ud2    
			timeout = TCAP_TIME_NIL;
  404006:	31 c9                	xor    ecx,ecx
  404008:	49 81 ff c8 1e 5a 00 	cmp    r15,0x5a1ec8
  40400f:	49 0f 45 c8          	cmovne rcx,r8
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  404013:	a8 02                	test   al,0x2
  404015:	0f 85 85 00 00 00    	jne    4040a0 <syncipc_call+0x2a0>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  40401b:	49 89 c8             	mov    r8,rcx
  40401e:	a8 01                	test   al,0x1
  404020:	0f 84 e9 fe ff ff    	je     403f0f <syncipc_call+0x10f>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  404026:	4d 8b 57 08          	mov    r10,QWORD PTR [r15+0x8]
  40402a:	49 8b 7f 10          	mov    rdi,QWORD PTR [r15+0x10]
  40402e:	48 89 f2             	mov    rdx,rsi
  404031:	45 89 e1             	mov    r9d,r12d
  404034:	4c 8b 05 ad de 19 00 	mov    r8,QWORD PTR [rip+0x19dead]        # 5a1ee8 <__slm_global+0x28>
  40403b:	4c 89 d6             	mov    rsi,r10
  40403e:	e8 dd d2 00 00       	call   411320 <cos_switch>
  404043:	41 89 c0             	mov    r8d,eax
  404046:	e9 df fe ff ff       	jmp    403f2a <syncipc_call+0x12a>
	return t != &g->idle_thd && t != &g->sched_thd;
  40404b:	49 81 ff 40 1f 5a 00 	cmp    r15,0x5a1f40
  404052:	74 18                	je     40406c <syncipc_call+0x26c>
  404054:	49 81 ff c8 1e 5a 00 	cmp    r15,0x5a1ec8
  40405b:	74 0f                	je     40406c <syncipc_call+0x26c>
  40405d:	0f 31                	rdtsc  
	counts[type]++;
  40405f:	48 83 05 a1 a0 05 00 	add    QWORD PTR [rip+0x5a0a1],0x1        # 45e108 <counts+0x8>
  404066:	01 
			if (ret != -EAGAIN) return ret;
  404067:	e9 02 ff ff ff       	jmp    403f6e <syncipc_call+0x16e>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  40406c:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]
  404070:	4c 8b 05 71 de 19 00 	mov    r8,QWORD PTR [rip+0x19de71]        # 5a1ee8 <__slm_global+0x28>
  404077:	45 89 e1             	mov    r9d,r12d
  40407a:	31 c9                	xor    ecx,ecx
  40407c:	48 8b 3d 55 de 19 00 	mov    rdi,QWORD PTR [rip+0x19de55]        # 5a1ed8 <__slm_global+0x18>
  404083:	31 f6                	xor    esi,esi
  404085:	e8 96 d2 00 00       	call   411320 <cos_switch>
  40408a:	83 f8 f5             	cmp    eax,0xfffffff5
  40408d:	41 89 c0             	mov    r8d,eax
  404090:	40 0f 95 c6          	setne  sil
		if (unlikely(ret)) {
  404094:	85 c0                	test   eax,eax
  404096:	0f 95 c0             	setne  al
			if (ret != -EAGAIN) return ret;
  404099:	21 c6                	and    esi,eax
  40409b:	e9 9a fe ff ff       	jmp    403f3a <syncipc_call+0x13a>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  4040a0:	49 8b 7f 28          	mov    rdi,QWORD PTR [r15+0x28]
  4040a4:	48 8b 15 3d de 19 00 	mov    rdx,QWORD PTR [rip+0x19de3d]        # 5a1ee8 <__slm_global+0x28>
  4040ab:	44 89 e1             	mov    ecx,r12d
  4040ae:	4c 89 c6             	mov    rsi,r8
  4040b1:	e8 da d2 00 00       	call   411390 <cos_sched_asnd>
  4040b6:	eb d2                	jmp    40408a <syncipc_call+0x28a>
	if (ep->server == NULL) return -EAGAIN;
  4040b8:	41 b8 f5 ff ff ff    	mov    r8d,0xfffffff5
  4040be:	e9 ab fe ff ff       	jmp    403f6e <syncipc_call+0x16e>
  4040c3:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4040ca:	00 00 00 00 
  4040ce:	66 90                	xchg   ax,ax

00000000004040d0 <syncipc_reply_wait>:
{
  4040d0:	f3 0f 1e fa          	endbr64 
  4040d4:	55                   	push   rbp
  4040d5:	66 48 0f 6e c6       	movq   xmm0,rsi
  4040da:	66 48 0f 6e ca       	movq   xmm1,rdx
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  4040df:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  4040e2:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  4040e8:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  4040ec:	48 89 e5             	mov    rbp,rsp
  4040ef:	41 57                	push   r15
  4040f1:	4d 89 c7             	mov    r15,r8
  4040f4:	41 56                	push   r14
  4040f6:	41 55                	push   r13
  4040f8:	41 54                	push   r12
  4040fa:	53                   	push   rbx
  4040fb:	48 83 ec 18          	sub    rsp,0x18
  4040ff:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
  404106:	48 89 4d c8          	mov    QWORD PTR [rbp-0x38],rcx
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  40410a:	48 85 c0             	test   rax,rax
  40410d:	0f 84 7d 02 00 00    	je     404390 <syncipc_reply_wait+0x2c0>
  404113:	83 e8 01             	sub    eax,0x1
  404116:	83 f8 18             	cmp    eax,0x18
  404119:	0f 87 71 02 00 00    	ja     404390 <syncipc_reply_wait+0x2c0>
  40411f:	48 8b 14 c5 00 e7 45 	mov    rdx,QWORD PTR [rax*8+0x45e700]
  404126:	00 
  404127:	45 31 ed             	xor    r13d,r13d
  40412a:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  404131:	0f 85 b9 01 00 00    	jne    4042f0 <syncipc_reply_wait+0x220>
	if (unlikely(ep->server != t)) {
  404137:	48 8b 05 0a a0 05 00 	mov    rax,QWORD PTR [rip+0x5a00a]        # 45e148 <eps+0x8>
  40413e:	4c 39 e8             	cmp    rax,r13
  404141:	0f 85 d5 01 00 00    	jne    40431c <syncipc_reply_wait+0x24c>
	client             = ps_load(&ep->client);
  404147:	48 8b 1d f2 9f 05 00 	mov    rbx,QWORD PTR [rip+0x59ff2]        # 45e140 <eps>
	ep->retvals->r0    = arg0;
  40414e:	48 8b 05 0b a0 05 00 	mov    rax,QWORD PTR [rip+0x5a00b]        # 45e160 <eps+0x20>
	counts[type]++;
  404155:	48 83 05 bb 9f 05 00 	add    QWORD PTR [rip+0x59fbb],0x1        # 45e118 <counts+0x18>
  40415c:	01 
	return t != &g->idle_thd && t != &g->sched_thd;
  40415d:	48 81 fb 40 1f 5a 00 	cmp    rbx,0x5a1f40
	ep->retvals->ready = 1;
  404164:	c7 00 01 00 00 00    	mov    DWORD PTR [rax],0x1
	ep->retvals->r0    = arg0;
  40416a:	0f 11 40 08          	movups XMMWORD PTR [rax+0x8],xmm0
  40416e:	41 0f 95 c6          	setne  r14b
  404172:	48 81 fb c8 1e 5a 00 	cmp    rbx,0x5a1ec8
	ep->retvals       = NULL;
  404179:	48 c7 05 dc 9f 05 00 	mov    QWORD PTR [rip+0x59fdc],0x0        # 45e160 <eps+0x20>
  404180:	00 00 00 00 
  404184:	0f 95 c0             	setne  al
	ep->client        = NULL;
  404187:	48 c7 05 ae 9f 05 00 	mov    QWORD PTR [rip+0x59fae],0x0        # 45e140 <eps>
  40418e:	00 00 00 00 
  404192:	41 21 c6             	and    r14d,eax
  404195:	0f 31                	rdtsc  
		ret = slm_switch_to(t, client, cos_sched_sync(), 1);
  404197:	e8 64 d1 00 00       	call   411300 <cos_sched_sync>
  40419c:	41 89 c4             	mov    r12d,eax
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  40419f:	8b 43 04             	mov    eax,DWORD PTR [rbx+0x4]
  4041a2:	83 e8 02             	sub    eax,0x2
  4041a5:	83 f8 01             	cmp    eax,0x1
  4041a8:	0f 87 a2 00 00 00    	ja     404250 <syncipc_reply_wait+0x180>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  4041ae:	e8 ad 76 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4041b3:	8b 03                	mov    eax,DWORD PTR [rbx]
	timeout = g->timeout_next;
  4041b5:	4c 8b 05 0c de 19 00 	mov    r8,QWORD PTR [rip+0x19de0c]        # 5a1fc8 <__slm_global+0x108>
	prio = inherit_prio ? curr->priority : t->priority;
  4041bc:	49 8b 75 30          	mov    rsi,QWORD PTR [r13+0x30]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4041c0:	a8 0b                	test   al,0xb
  4041c2:	0f 85 a8 00 00 00    	jne    404270 <syncipc_reply_wait+0x1a0>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  4041c8:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  4041cc:	4c 89 c2             	mov    rdx,r8
  4041cf:	44 89 e1             	mov    ecx,r12d
  4041d2:	e8 89 85 00 00       	call   40c760 <cos_defswitch>
  4041d7:	41 89 c0             	mov    r8d,eax
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  4041da:	83 f8 ff             	cmp    eax,0xffffffff
  4041dd:	0f 84 d5 00 00 00    	je     4042b8 <syncipc_reply_wait+0x1e8>
  4041e3:	0f 31                	rdtsc  
		if (unlikely(ret) && ret != -EAGAIN) return ret;
  4041e5:	45 85 c0             	test   r8d,r8d
  4041e8:	75 70                	jne    40425a <syncipc_reply_wait+0x18a>
	counts[type]++;
  4041ea:	66 0f 6f 05 5e 8b 01 	movdqa xmm0,XMMWORD PTR [rip+0x18b5e]        # 41cd50 <__unlock+0xc20>
  4041f1:	00 
  4041f2:	66 0f d4 05 26 9f 05 	paddq  xmm0,XMMWORD PTR [rip+0x59f26]        # 45e120 <counts+0x20>
  4041f9:	00 
  4041fa:	0f 29 05 1f 9f 05 00 	movaps XMMWORD PTR [rip+0x59f1f],xmm0        # 45e120 <counts+0x20>
  404201:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	while (ps_load(&ep->client) == NULL) ;
  404208:	48 8b 05 31 9f 05 00 	mov    rax,QWORD PTR [rip+0x59f31]        # 45e140 <eps>
  40420f:	48 85 c0             	test   rax,rax
  404212:	74 f4                	je     404208 <syncipc_reply_wait+0x138>
	*ret0 = ep->a0;
  404214:	48 8b 05 35 9f 05 00 	mov    rax,QWORD PTR [rip+0x59f35]        # 45e150 <eps+0x10>
  40421b:	48 8b 7d c8          	mov    rdi,QWORD PTR [rbp-0x38]
  40421f:	48 89 07             	mov    QWORD PTR [rdi],rax
	*ret1 = ep->a1;
  404222:	48 8b 05 2f 9f 05 00 	mov    rax,QWORD PTR [rip+0x59f2f]        # 45e158 <eps+0x18>
  404229:	49 89 07             	mov    QWORD PTR [r15],rax
	counts[type]++;
  40422c:	48 83 05 fc 9e 05 00 	add    QWORD PTR [rip+0x59efc],0x1        # 45e130 <counts+0x30>
  404233:	01 
}
  404234:	48 83 c4 18          	add    rsp,0x18
  404238:	44 89 c0             	mov    eax,r8d
  40423b:	5b                   	pop    rbx
  40423c:	41 5c                	pop    r12
  40423e:	41 5d                	pop    r13
  404240:	41 5e                	pop    r14
  404242:	41 5f                	pop    r15
  404244:	5d                   	pop    rbp
  404245:	c3                   	ret    
  404246:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40424d:	00 00 00 
  404250:	0f 31                	rdtsc  
  404252:	41 b8 01 00 00 00    	mov    r8d,0x1
  404258:	eb da                	jmp    404234 <syncipc_reply_wait+0x164>
		if (unlikely(ret) && ret != -EAGAIN) return ret;
  40425a:	41 83 f8 f5          	cmp    r8d,0xfffffff5
  40425e:	75 d4                	jne    404234 <syncipc_reply_wait+0x164>
	counts[type]++;
  404260:	48 83 05 b8 9e 05 00 	add    QWORD PTR [rip+0x59eb8],0x1        # 45e120 <counts+0x20>
  404267:	01 
	} while (ret == -EAGAIN);
  404268:	e9 28 ff ff ff       	jmp    404195 <syncipc_reply_wait+0xc5>
  40426d:	0f 1f 00             	nop    DWORD PTR [rax]
			timeout = TCAP_TIME_NIL;
  404270:	31 c9                	xor    ecx,ecx
  404272:	48 81 fb c8 1e 5a 00 	cmp    rbx,0x5a1ec8
  404279:	49 0f 45 c8          	cmovne rcx,r8
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  40427d:	a8 02                	test   al,0x2
  40427f:	0f 85 1b 01 00 00    	jne    4043a0 <syncipc_reply_wait+0x2d0>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  404285:	49 89 c8             	mov    r8,rcx
  404288:	a8 01                	test   al,0x1
  40428a:	0f 84 38 ff ff ff    	je     4041c8 <syncipc_reply_wait+0xf8>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  404290:	4c 8b 53 08          	mov    r10,QWORD PTR [rbx+0x8]
  404294:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  404298:	48 89 f2             	mov    rdx,rsi
  40429b:	45 89 e1             	mov    r9d,r12d
  40429e:	4c 8b 05 43 dc 19 00 	mov    r8,QWORD PTR [rip+0x19dc43]        # 5a1ee8 <__slm_global+0x28>
  4042a5:	4c 89 d6             	mov    rsi,r10
  4042a8:	e8 73 d0 00 00       	call   411320 <cos_switch>
  4042ad:	41 89 c0             	mov    r8d,eax
  4042b0:	e9 2e ff ff ff       	jmp    4041e3 <syncipc_reply_wait+0x113>
  4042b5:	0f 1f 00             	nop    DWORD PTR [rax]
	return t != &g->idle_thd && t != &g->sched_thd;
  4042b8:	45 84 f6             	test   r14b,r14b
  4042bb:	75 2b                	jne    4042e8 <syncipc_reply_wait+0x218>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  4042bd:	4c 8b 05 24 dc 19 00 	mov    r8,QWORD PTR [rip+0x19dc24]        # 5a1ee8 <__slm_global+0x28>
  4042c4:	49 8b 55 30          	mov    rdx,QWORD PTR [r13+0x30]
  4042c8:	45 89 e1             	mov    r9d,r12d
  4042cb:	31 c9                	xor    ecx,ecx
  4042cd:	48 8b 3d 04 dc 19 00 	mov    rdi,QWORD PTR [rip+0x19dc04]        # 5a1ed8 <__slm_global+0x18>
  4042d4:	31 f6                	xor    esi,esi
  4042d6:	e8 45 d0 00 00       	call   411320 <cos_switch>
  4042db:	41 89 c0             	mov    r8d,eax
  4042de:	e9 00 ff ff ff       	jmp    4041e3 <syncipc_reply_wait+0x113>
  4042e3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  4042e8:	0f 31                	rdtsc  
		if (unlikely(ret) && ret != -EAGAIN) return ret;
  4042ea:	e9 45 ff ff ff       	jmp    404234 <syncipc_reply_wait+0x164>
  4042ef:	90                   	nop
  4042f0:	83 e2 01             	and    edx,0x1
  4042f3:	0f 85 3e fe ff ff    	jne    404137 <syncipc_reply_wait+0x67>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  4042f9:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  4042fd:	4c 8d 2c 50          	lea    r13,[rax+rdx*2]
	if (unlikely(ep->server != t)) {
  404301:	48 8b 05 40 9e 05 00 	mov    rax,QWORD PTR [rip+0x59e40]        # 45e148 <eps+0x8>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  404308:	49 c1 e5 04          	shl    r13,0x4
  40430c:	49 81 c5 c8 e7 45 00 	add    r13,0x45e7c8
	if (unlikely(ep->server != t)) {
  404313:	4c 39 e8             	cmp    rax,r13
  404316:	0f 84 2b fe ff ff    	je     404147 <syncipc_reply_wait+0x77>
		if (ep->server != NULL)         return -1;
  40431c:	48 85 c0             	test   rax,rax
  40431f:	0f 85 d1 00 00 00    	jne    4043f6 <syncipc_reply_wait+0x326>
        __asm__ __volatile__("lock " PS_CAS_STR
  404325:	f0 4c 0f b1 2d 1a 9e 	lock cmpxchg QWORD PTR [rip+0x59e1a],r13        # 45e148 <eps+0x8>
  40432c:	05 00 
  40432e:	0f 94 c0             	sete   al
		if (!ps_cas((unsigned long *)&ep->server, 0, (unsigned long)t)) return -1;
  404331:	84 c0                	test   al,al
  404333:	0f 84 bd 00 00 00    	je     4043f6 <syncipc_reply_wait+0x326>
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  404339:	31 d2                	xor    edx,edx
  40433b:	be 0b 00 00 00       	mov    esi,0xb
  404340:	4c 89 ef             	mov    rdi,r13
  404343:	e8 08 e3 00 00       	call   412650 <slm_sched_fprr_thd_update>
  404348:	41 89 c0             	mov    r8d,eax
		assert(ret == 0);
  40434b:	85 c0                	test   eax,eax
  40434d:	75 6f                	jne    4043be <syncipc_reply_wait+0x2ee>
		assert(ep->server == t);
  40434f:	4c 39 2d f2 9d 05 00 	cmp    QWORD PTR [rip+0x59df2],r13        # 45e148 <eps+0x8>
  404356:	0f 85 7e 00 00 00    	jne    4043da <syncipc_reply_wait+0x30a>
  40435c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		while (ps_load(&ep->client) == NULL) ;
  404360:	48 8b 05 d9 9d 05 00 	mov    rax,QWORD PTR [rip+0x59dd9]        # 45e140 <eps>
  404367:	48 85 c0             	test   rax,rax
  40436a:	74 f4                	je     404360 <syncipc_reply_wait+0x290>
		*ret0 = ep->a0;
  40436c:	48 8b 05 dd 9d 05 00 	mov    rax,QWORD PTR [rip+0x59ddd]        # 45e150 <eps+0x10>
  404373:	48 8b 7d c8          	mov    rdi,QWORD PTR [rbp-0x38]
  404377:	48 89 07             	mov    QWORD PTR [rdi],rax
		*ret1 = ep->a1;
  40437a:	48 8b 05 d7 9d 05 00 	mov    rax,QWORD PTR [rip+0x59dd7]        # 45e158 <eps+0x18>
  404381:	49 89 07             	mov    QWORD PTR [r15],rax
		return 0;
  404384:	e9 ab fe ff ff       	jmp    404234 <syncipc_reply_wait+0x164>
  404389:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  404390:	45 31 ed             	xor    r13d,r13d
  404393:	e9 9f fd ff ff       	jmp    404137 <syncipc_reply_wait+0x67>
  404398:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40439f:	00 
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  4043a0:	48 8b 7b 28          	mov    rdi,QWORD PTR [rbx+0x28]
  4043a4:	48 8b 15 3d db 19 00 	mov    rdx,QWORD PTR [rip+0x19db3d]        # 5a1ee8 <__slm_global+0x28>
  4043ab:	4c 89 c6             	mov    rsi,r8
  4043ae:	44 89 e1             	mov    ecx,r12d
  4043b1:	e8 da cf 00 00       	call   411390 <cos_sched_asnd>
  4043b6:	41 89 c0             	mov    r8d,eax
  4043b9:	e9 25 fe ff ff       	jmp    4041e3 <syncipc_reply_wait+0x113>
  4043be:	be 24 00 00 00       	mov    esi,0x24
  4043c3:	bf d8 cc 41 00       	mov    edi,0x41ccd8
  4043c8:	e8 03 5d 00 00       	call   40a0d0 <cos_print_str>
		assert(ret == 0);
  4043cd:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4043d4:	00 00 00 00 
  4043d8:	0f 0b                	ud2    
  4043da:	be 24 00 00 00       	mov    esi,0x24
  4043df:	bf 00 cd 41 00       	mov    edi,0x41cd00
  4043e4:	e8 e7 5c 00 00       	call   40a0d0 <cos_print_str>
		assert(ep->server == t);
  4043e9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4043f0:	00 00 00 00 
  4043f4:	0f 0b                	ud2    
		if (ep->server != NULL)         return -1;
  4043f6:	41 b8 ff ff ff ff    	mov    r8d,0xffffffff
  4043fc:	e9 33 fe ff ff       	jmp    404234 <syncipc_reply_wait+0x164>
  404401:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  404408:	00 00 00 00 
  40440c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000404410 <sched_aep_create_closure>:
{
  404410:	f3 0f 1e fa          	endbr64 
}
  404414:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
  40441b:	c3                   	ret    
  40441c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000404420 <sched_get_cpu_freq>:
{
  404420:	f3 0f 1e fa          	endbr64 
	return slm_get_cycs_per_usec();
  404424:	e9 f7 ff 00 00       	jmp    414420 <slm_get_cycs_per_usec>
  404429:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000404430 <slm_ipithd_create>:
{
  404430:	f3 0f 1e fa          	endbr64 
  404434:	55                   	push   rbp
  404435:	48 89 e5             	mov    rbp,rsp
  404438:	41 57                	push   r15
  40443a:	49 89 f7             	mov    r15,rsi
  40443d:	41 56                	push   r14
  40443f:	49 89 fe             	mov    r14,rdi
	struct slm_ipi_percore   *ipi_data = slm_ipi_percore_get(cos_cpuid());
  404442:	31 ff                	xor    edi,edi
{
  404444:	41 55                	push   r13
  404446:	49 89 cd             	mov    r13,rcx
  404449:	41 54                	push   r12
  40444b:	4d 89 c4             	mov    r12,r8
  40444e:	53                   	push   rbx
  40444f:	48 83 ec 28          	sub    rsp,0x28
  404453:	89 55 bc             	mov    DWORD PTR [rbp-0x44],edx
	struct slm_ipi_percore   *ipi_data = slm_ipi_percore_get(cos_cpuid());
  404456:	e8 55 f2 00 00       	call   4136b0 <slm_ipi_percore_get>
	r->rcv = capmgr_rcv_alloc(fn, data, flags, &r->asnd, &_thd, &_tid);
  40445b:	8b 55 bc             	mov    edx,DWORD PTR [rbp-0x44]
  40445e:	4c 8d 45 c0          	lea    r8,[rbp-0x40]
  404462:	4c 89 fe             	mov    rsi,r15
  404465:	48 8d 48 08          	lea    rcx,[rax+0x8]
  404469:	4c 8d 4d c8          	lea    r9,[rbp-0x38]
  40446d:	4c 89 f7             	mov    rdi,r14
	struct slm_ipi_percore   *ipi_data = slm_ipi_percore_get(cos_cpuid());
  404470:	48 89 c3             	mov    rbx,rax
	r->rcv = capmgr_rcv_alloc(fn, data, flags, &r->asnd, &_thd, &_tid);
  404473:	e8 a8 59 00 00       	call   409e20 <capmgr_rcv_alloc>
	r->tid = _tid;
  404478:	48 8b 75 c8          	mov    rsi,QWORD PTR [rbp-0x38]
	t = slm_thd_mem_alloc(_thd, _tid, thdcap, tid);
  40447c:	4c 8b 45 c0          	mov    r8,QWORD PTR [rbp-0x40]
	r->cpuid = cos_cpuid();
  404480:	c7 43 10 00 00 00 00 	mov    DWORD PTR [rbx+0x10],0x0
	r->rcv = capmgr_rcv_alloc(fn, data, flags, &r->asnd, &_thd, &_tid);
  404487:	48 89 03             	mov    QWORD PTR [rbx],rax
	r->tid = _tid;
  40448a:	66 49 0f 6e c0       	movq   xmm0,r8
  40448f:	66 48 0f 6e ce       	movq   xmm1,rsi
  404494:	48 89 73 18          	mov    QWORD PTR [rbx+0x18],rsi
	t = slm_thd_mem_alloc(_thd, _tid, thdcap, tid);
  404498:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  40449c:	85 f6                	test   esi,esi
  40449e:	0f 84 8c 01 00 00    	je     404630 <slm_ipithd_create+0x200>
  4044a4:	8d 56 ff             	lea    edx,[rsi-0x1]
  4044a7:	83 fa 18             	cmp    edx,0x18
  4044aa:	0f 87 80 01 00 00    	ja     404630 <slm_ipithd_create+0x200>
	if (*state != SS_STATE_FREE ||
  4044b0:	48 83 3c d5 00 e7 45 	cmp    QWORD PTR [rdx*8+0x45e700],0x0
  4044b7:	00 00 
  4044b9:	0f 85 71 01 00 00    	jne    404630 <slm_ipithd_create+0x200>
  4044bf:	45 31 c9             	xor    r9d,r9d
  4044c2:	b9 01 00 00 00       	mov    ecx,0x1
  4044c7:	4c 89 c8             	mov    rax,r9
  4044ca:	f0 48 0f b1 0c d5 00 	lock cmpxchg QWORD PTR [rdx*8+0x45e700],rcx
  4044d1:	e7 45 00 
  4044d4:	0f 94 c0             	sete   al
  4044d7:	84 c0                	test   al,al
  4044d9:	0f 84 51 01 00 00    	je     404630 <slm_ipithd_create+0x200>
  4044df:	48 8d 04 92          	lea    rax,[rdx+rdx*4]
  4044e3:	b9 16 00 00 00       	mov    ecx,0x16
  4044e8:	48 8d 14 42          	lea    rdx,[rdx+rax*2]
  4044ec:	4c 89 c8             	mov    rax,r9
  4044ef:	48 c1 e2 04          	shl    rdx,0x4
  4044f3:	4c 8d b2 c8 e7 45 00 	lea    r14,[rdx+0x45e7c8]
  4044fa:	4c 89 f7             	mov    rdi,r14
  4044fd:	f3 48 ab             	rep stos QWORD PTR es:[rdi],rax
	assert(_cap != 0 && _tid != 0);
  404500:	4d 85 c0             	test   r8,r8
  404503:	0f 84 64 01 00 00    	je     40466d <slm_ipithd_create+0x23d>
	t->resources = (struct slm_resources_thd) {
  404509:	48 8b 05 30 2b 02 00 	mov    rax,QWORD PTR [rip+0x22b30]        # 427040 <__cosrt_comp_info+0x40>
  404510:	0f 29 82 60 e8 45 00 	movaps XMMWORD PTR [rdx+0x45e860],xmm0
  404517:	bb c8 1e 5a 00       	mov    ebx,0x5a1ec8
  40451c:	48 89 82 70 e8 45 00 	mov    QWORD PTR [rdx+0x45e870],rax
	*thd = _cap;
  404523:	4d 89 45 00          	mov    QWORD PTR [r13+0x0],r8
	*tid = _tid;
  404527:	49 89 34 24          	mov    QWORD PTR [r12],rsi
		tok    = cos_sched_sync();
  40452b:	e8 d0 cd 00 00       	call   411300 <cos_sched_sync>
  404530:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  404533:	48 8b 05 86 d9 19 00 	mov    rax,QWORD PTR [rip+0x19d986]        # 5a1ec0 <__slm_global>
		if (unlikely(owner)) {
  40453a:	48 89 c1             	mov    rcx,rax
  40453d:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  404541:	0f 85 42 01 00 00    	jne    404689 <slm_ipithd_create+0x259>
  404547:	f0 48 0f b1 1d 70 d9 	lock cmpxchg QWORD PTR [rip+0x19d970],rbx        # 5a1ec0 <__slm_global>
  40454e:	19 00 
  404550:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  404553:	84 c0                	test   al,al
  404555:	74 d4                	je     40452b <slm_ipithd_create+0xfb>
	if (slm_thd_init(thd, _thd, _tid)) ERR_THROW(NULL, free);
  404557:	48 8b 55 c8          	mov    rdx,QWORD PTR [rbp-0x38]
  40455b:	48 8b 75 c0          	mov    rsi,QWORD PTR [rbp-0x40]
  40455f:	4c 89 f7             	mov    rdi,r14
  404562:	e8 a9 f1 00 00       	call   413710 <slm_thd_init>
  404567:	85 c0                	test   eax,eax
  404569:	0f 85 dd 00 00 00    	jne    40464c <slm_ipithd_create+0x21c>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  40456f:	49 81 fe c8 e7 45 00 	cmp    r14,0x45e7c8
  404576:	0f 82 d5 00 00 00    	jb     404651 <slm_ipithd_create+0x221>
  40457c:	49 81 fe 48 f8 45 00 	cmp    r14,0x45f848
  404583:	0f 87 c8 00 00 00    	ja     404651 <slm_ipithd_create+0x221>
  404589:	4c 89 f0             	mov    rax,r14
  40458c:	48 2d c8 e7 45 00    	sub    rax,0x45e7c8
  404592:	48 c1 f8 04          	sar    rax,0x4
	*state = val | (*state & 1);
  404596:	69 c0 a3 8b 2e ba    	imul   eax,eax,0xba2e8ba3
  40459c:	48 8b 14 c5 00 e7 45 	mov    rdx,QWORD PTR [rax*8+0x45e700]
  4045a3:	00 
  4045a4:	48 83 ca fe          	or     rdx,0xfffffffffffffffe
  4045a8:	48 89 14 c5 00 e7 45 	mov    QWORD PTR [rax*8+0x45e700],rdx
  4045af:	00 
	assert((*state & 1) == SS_STATE_CONS);
  4045b0:	48 83 fa ff          	cmp    rdx,0xffffffffffffffff
  4045b4:	0f 85 29 01 00 00    	jne    4046e3 <slm_ipithd_create+0x2b3>
	*state &= ~SS_STATE_CONS;
  4045ba:	48 c7 04 c5 00 e7 45 	mov    QWORD PTR [rax*8+0x45e700],0xfffffffffffffffe
  4045c1:	00 fe ff ff ff 
{ __asm__ __volatile__("mfence" ::: "memory"); }
  4045c6:	0f ae f0             	mfence 
	assert(*state != 0);
  4045c9:	48 83 3c c5 00 e7 45 	cmp    QWORD PTR [rax*8+0x45e700],0x0
  4045d0:	00 00 
  4045d2:	75 1c                	jne    4045f0 <slm_ipithd_create+0x1c0>
  4045d4:	e9 ee 00 00 00       	jmp    4046c7 <slm_ipithd_create+0x297>
  4045d9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  4045e0:	f0 48 0f b1 15 d7 d8 	lock cmpxchg QWORD PTR [rip+0x19d8d7],rdx        # 5a1ec0 <__slm_global>
  4045e7:	19 00 
  4045e9:	0f 94 c0             	sete   al
	while (ret != 0) {
  4045ec:	84 c0                	test   al,al
  4045ee:	75 2e                	jne    40461e <slm_ipithd_create+0x1ee>
		tok    = cos_sched_sync();
  4045f0:	e8 0b cd 00 00       	call   411300 <cos_sched_sync>
  4045f5:	89 c1                	mov    ecx,eax
  4045f7:	48 8b 05 c2 d8 19 00 	mov    rax,QWORD PTR [rip+0x19d8c2]        # 5a1ec0 <__slm_global>
		if (unlikely(contention)) {
  4045fe:	48 89 c2             	mov    rdx,rax
  404601:	83 e2 01             	and    edx,0x1
  404604:	74 da                	je     4045e0 <slm_ipithd_create+0x1b0>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  404606:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  404609:	48 89 c2             	mov    rdx,rax
  40460c:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  404611:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  404615:	e8 46 f2 00 00       	call   413860 <slm_cs_exit_contention>
  40461a:	85 c0                	test   eax,eax
  40461c:	75 d2                	jne    4045f0 <slm_ipithd_create+0x1c0>
}
  40461e:	48 83 c4 28          	add    rsp,0x28
  404622:	4c 89 f0             	mov    rax,r14
  404625:	5b                   	pop    rbx
  404626:	41 5c                	pop    r12
  404628:	41 5d                	pop    r13
  40462a:	41 5e                	pop    r14
  40462c:	41 5f                	pop    r15
  40462e:	5d                   	pop    rbp
  40462f:	c3                   	ret    
  404630:	be 23 00 00 00       	mov    esi,0x23
  404635:	bf 30 cb 41 00       	mov    edi,0x41cb30
  40463a:	e8 91 5a 00 00       	call   40a0d0 <cos_print_str>
	if (!t) assert(0);
  40463f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404646:	00 00 00 00 
  40464a:	0f 0b                	ud2    
	ret = NULL;
  40464c:	45 31 f6             	xor    r14d,r14d
	return ret;
  40464f:	eb cd                	jmp    40461e <slm_ipithd_create+0x1ee>
  404651:	be 23 00 00 00       	mov    esi,0x23
  404656:	bf 08 cb 41 00       	mov    edi,0x41cb08
  40465b:	e8 70 5a 00 00       	call   40a0d0 <cos_print_str>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  404660:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404667:	00 00 00 00 
  40466b:	0f 0b                	ud2    
  40466d:	be 23 00 00 00       	mov    esi,0x23
  404672:	bf 58 cb 41 00       	mov    edi,0x41cb58
  404677:	e8 54 5a 00 00       	call   40a0d0 <cos_print_str>
	assert(_cap != 0 && _tid != 0);
  40467c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404683:	00 00 00 00 
  404687:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  404689:	41 89 c0             	mov    r8d,eax
  40468c:	ba c8 1e 5a 00       	mov    edx,0x5a1ec8
  404691:	48 89 c6             	mov    rsi,rax
  404694:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  404699:	41 83 e0 01          	and    r8d,0x1
  40469d:	e8 6e f1 00 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  4046a2:	83 f8 f0             	cmp    eax,0xfffffff0
  4046a5:	0f 85 80 fe ff ff    	jne    40452b <slm_ipithd_create+0xfb>
  4046ab:	be 59 00 00 00       	mov    esi,0x59
  4046b0:	bf c0 c7 41 00       	mov    edi,0x41c7c0
  4046b5:	e8 16 5a 00 00       	call   40a0d0 <cos_print_str>
  4046ba:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4046c1:	00 00 00 00 
  4046c5:	0f 0b                	ud2    
  4046c7:	be 61 00 00 00       	mov    esi,0x61
  4046cc:	bf e8 cb 41 00       	mov    edi,0x41cbe8
  4046d1:	e8 fa 59 00 00       	call   40a0d0 <cos_print_str>
  4046d6:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4046dd:	00 00 00 00 
  4046e1:	0f 0b                	ud2    
  4046e3:	be 61 00 00 00       	mov    esi,0x61
  4046e8:	bf 80 cb 41 00       	mov    edi,0x41cb80
  4046ed:	e8 de 59 00 00       	call   40a0d0 <cos_print_str>
	assert((*state & 1) == SS_STATE_CONS);
  4046f2:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4046f9:	00 00 00 00 
  4046fd:	0f 0b                	ud2    
  4046ff:	90                   	nop

0000000000404700 <parallel_main>:

static coreid_t _init_core_id = 0;

void
parallel_main(coreid_t cid)
{
  404700:	f3 0f 1e fa          	endbr64 
	if (cid == _init_core_id) printc("Starting scheduler loop...\n");
  404704:	66 39 3d dd 9f 05 00 	cmp    WORD PTR [rip+0x59fdd],di        # 45e6e8 <_init_core_id>
  40470b:	74 0b                	je     404718 <parallel_main+0x18>
	slm_sched_loop_nonblock();
  40470d:	e9 2e fd 00 00       	jmp    414440 <slm_sched_loop_nonblock>
  404712:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
{
  404718:	55                   	push   rbp
	if (cid == _init_core_id) printc("Starting scheduler loop...\n");
  404719:	bf 40 c7 41 00       	mov    edi,0x41c740
  40471e:	31 c0                	xor    eax,eax
{
  404720:	48 89 e5             	mov    rbp,rsp
	if (cid == _init_core_id) printc("Starting scheduler loop...\n");
  404723:	e8 38 c2 ff ff       	call   400960 <printc.constprop.0>
}
  404728:	5d                   	pop    rbp
	slm_sched_loop_nonblock();
  404729:	e9 12 fd 00 00       	jmp    414440 <slm_sched_loop_nonblock>
  40472e:	66 90                	xchg   ax,ax

0000000000404730 <cos_parallel_init>:

void
cos_parallel_init(coreid_t cid, int init_core, int ncores)
{
  404730:	f3 0f 1e fa          	endbr64 
  404734:	55                   	push   rbp
  404735:	48 89 e5             	mov    rbp,rsp
  404738:	53                   	push   rbx
  404739:	48 83 ec 28          	sub    rsp,0x28
	struct slm_thd_container *t;
	struct slm_thd *r;
	thdcap_t thdcap, ipithdcap;
	arcvcap_t rcvcap;
	thdid_t tid, ipitid;
	if (init_core) {
  40473d:	85 f6                	test   esi,esi
  40473f:	74 07                	je     404748 <cos_parallel_init+0x18>
		_init_core_id = cid;
  404741:	66 89 3d a0 9f 05 00 	mov    WORD PTR [rip+0x59fa0],di        # 45e6e8 <_init_core_id>
	} 
	struct slm_ipi_percore *ipi_data = slm_ipi_percore_get(cos_cpuid());
  404748:	31 ff                	xor    edi,edi
  40474a:	e8 61 ef 00 00       	call   4136b0 <slm_ipi_percore_get>
  40474f:	48 89 c3             	mov    rbx,rax

	cos_defcompinfo_sched_init();
  404752:	e8 89 73 00 00       	call   40bae0 <cos_defcompinfo_sched_init>

	t = slm_thd_alloc(slm_idle, NULL, &thdcap, &tid);
  404757:	31 f6                	xor    esi,esi
  404759:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  40475d:	48 8d 55 d0          	lea    rdx,[rbp-0x30]
  404761:	bf 50 2a 41 00       	mov    edi,0x412a50
  404766:	e8 35 01 00 00       	call   4048a0 <slm_thd_alloc>
	if (!t) BUG();
  40476b:	48 85 c0             	test   rax,rax
  40476e:	0f 84 bc 00 00 00    	je     404830 <cos_parallel_init+0x100>

	slm_init(thdcap, tid);
  404774:	48 8b 75 e0          	mov    rsi,QWORD PTR [rbp-0x20]
  404778:	48 8b 7d d0          	mov    rdi,QWORD PTR [rbp-0x30]
  40477c:	e8 df fc 00 00       	call   414460 <slm_init>

	r = slm_ipithd_create(slm_ipi_process, NULL, 0, &ipithdcap, &ipitid);
  404781:	31 d2                	xor    edx,edx
  404783:	31 f6                	xor    esi,esi
  404785:	4c 8d 45 e8          	lea    r8,[rbp-0x18]
  404789:	48 8d 4d d8          	lea    rcx,[rbp-0x28]
  40478d:	bf 10 0a 40 00       	mov    edi,0x400a10
  404792:	e8 99 fc ff ff       	call   404430 <slm_ipithd_create>
	if (!r) BUG();
  404797:	48 85 c0             	test   rax,rax
  40479a:	74 74                	je     404810 <cos_parallel_init+0xe0>
	return &ss_thd_get(id)->thd;
  40479c:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  4047a0:	85 c0                	test   eax,eax
  4047a2:	74 40                	je     4047e4 <cos_parallel_init+0xb4>
  4047a4:	83 e8 01             	sub    eax,0x1
  4047a7:	83 f8 18             	cmp    eax,0x18
  4047aa:	77 38                	ja     4047e4 <cos_parallel_init+0xb4>
  4047ac:	48 8b 14 c5 00 e7 45 	mov    rdx,QWORD PTR [rax*8+0x45e700]
  4047b3:	00 
	return ((state & ~1) != 0) && ((state & 1) == SS_STATE_ALLOC);
  4047b4:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  4047bb:	74 27                	je     4047e4 <cos_parallel_init+0xb4>
  4047bd:	83 e2 01             	and    edx,0x1
  4047c0:	75 22                	jne    4047e4 <cos_parallel_init+0xb4>
	return &ss_thd_get(id)->thd;
  4047c2:	48 8d 14 80          	lea    rdx,[rax+rax*4]
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  4047c6:	be 01 00 00 00       	mov    esi,0x1
	return &ss_thd_get(id)->thd;
  4047cb:	48 8d 3c 50          	lea    rdi,[rax+rdx*2]
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  4047cf:	ba 14 00 00 00       	mov    edx,0x14
	return &ss_thd_get(id)->thd;
  4047d4:	48 c1 e7 04          	shl    rdi,0x4
  4047d8:	48 81 c7 c8 e7 45 00 	add    rdi,0x45e7c8
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  4047df:	e8 6c de 00 00       	call   412650 <slm_sched_fprr_thd_update>

CK_CC_INLINE static void
ck_ring_init(struct ck_ring *ring, unsigned int size)
{

	ring->size = size;
  4047e4:	48 8b 05 75 85 01 00 	mov    rax,QWORD PTR [rip+0x18575]        # 41cd60 <__unlock+0xc30>
	ring->mask = size - 1;
	ring->p_tail = 0;
  4047eb:	48 c7 43 60 00 00 00 	mov    QWORD PTR [rbx+0x60],0x0
  4047f2:	00 
	ring->p_head = 0;
	ring->c_head = 0;
  4047f3:	c7 43 20 00 00 00 00 	mov    DWORD PTR [rbx+0x20],0x0
	ring->size = size;
  4047fa:	48 89 83 a0 00 00 00 	mov    QWORD PTR [rbx+0xa0],rax
	sched_thd_param_set(ipitid, sched_param_pack(SCHEDP_PRIO, SLM_IPI_THD_PRIO));
	ck_ring_init(&ipi_data->ring, PAGE_SIZE / sizeof(struct slm_ipi_event));
}
  404801:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
  404805:	c9                   	leave  
  404806:	c3                   	ret    
  404807:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40480e:	00 00 
  404810:	be 11 00 00 00       	mov    esi,0x11
  404815:	bf 37 cd 41 00       	mov    edi,0x41cd37
  40481a:	e8 b1 58 00 00       	call   40a0d0 <cos_print_str>
	if (!r) BUG();
  40481f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404826:	00 00 00 00 
  40482a:	0f 0b                	ud2    
  40482c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  404830:	be 11 00 00 00       	mov    esi,0x11
  404835:	bf 25 cd 41 00       	mov    edi,0x41cd25
  40483a:	e8 91 58 00 00       	call   40a0d0 <cos_print_str>
	if (!t) BUG();
  40483f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404846:	00 00 00 00 
  40484a:	0f 0b                	ud2    
  40484c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000404850 <cos_init>:

void
cos_init(void)
{
  404850:	f3 0f 1e fa          	endbr64 
  404854:	55                   	push   rbp
  404855:	48 89 e5             	mov    rbp,rsp
	struct cos_compinfo *boot_info = cos_compinfo_get(cos_defcompinfo_curr_get());
  404858:	e8 03 70 00 00       	call   40b860 <cos_defcompinfo_curr_get>
  40485d:	48 89 c7             	mov    rdi,rax
  404860:	e8 0b 70 00 00       	call   40b870 <cos_compinfo_get>

	cos_meminfo_init(&(boot_info->mi), BOOT_MEM_KM_BASE, COS_MEM_KERN_PA_SZ, BOOT_CAPTBL_SELF_UNTYPED_PT);
  404865:	b9 14 00 00 00       	mov    ecx,0x14
  40486a:	48 ba 00 00 00 fc 01 	movabs rdx,0x1fc000000
  404871:	00 00 00 
  404874:	48 be 00 00 00 00 80 	movabs rsi,0x8000000000
  40487b:	00 00 00 
  40487e:	48 8d 78 68          	lea    rdi,[rax+0x68]
  404882:	e8 69 8e 00 00       	call   40d6f0 <cos_meminfo_init>
	extern void calculate_initialization_schedule(void);
	calculate_initialization_schedule();
  404887:	e8 94 b9 ff ff       	call   400220 <calculate_initialization_schedule>
	cos_defcompinfo_init();
}
  40488c:	5d                   	pop    rbp
	cos_defcompinfo_init();
  40488d:	e9 4e 70 00 00       	jmp    40b8e0 <cos_defcompinfo_init>
  404892:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  404899:	00 00 00 
  40489c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

00000000004048a0 <slm_thd_alloc>:
#include <slm_modules.h>
#include <capmgr.h>

struct slm_thd_container *
slm_thd_alloc(thd_fn_t fn, void *data, thdcap_t *thd, thdid_t *tid)
{
  4048a0:	f3 0f 1e fa          	endbr64 
  4048a4:	55                   	push   rbp
  4048a5:	48 89 e5             	mov    rbp,rsp
  4048a8:	41 55                	push   r13
  4048aa:	49 89 cd             	mov    r13,rcx
  4048ad:	41 54                	push   r12
  4048af:	49 89 d4             	mov    r12,rdx
	thdid_t _tid;
	thdcap_t _cap;
	struct slm_thd_container *ret = NULL;

	_cap = capmgr_thd_create(fn, data, &_tid);
  4048b2:	48 8d 55 e8          	lea    rdx,[rbp-0x18]
{
  4048b6:	48 83 ec 10          	sub    rsp,0x10
	_cap = capmgr_thd_create(fn, data, &_tid);
  4048ba:	e8 b1 54 00 00       	call   409d70 <capmgr_thd_create>
  4048bf:	48 89 c7             	mov    rdi,rax
	if (_cap <= 0) return NULL;
  4048c2:	31 c0                	xor    eax,eax
  4048c4:	48 85 ff             	test   rdi,rdi
  4048c7:	74 0f                	je     4048d8 <slm_thd_alloc+0x38>

	return slm_thd_mem_alloc(_cap, _tid, thd, tid);
  4048c9:	48 8b 75 e8          	mov    rsi,QWORD PTR [rbp-0x18]
  4048cd:	4c 89 e9             	mov    rcx,r13
  4048d0:	4c 89 e2             	mov    rdx,r12
  4048d3:	e8 d8 d0 ff ff       	call   4019b0 <slm_thd_mem_alloc>
}
  4048d8:	48 83 c4 10          	add    rsp,0x10
  4048dc:	41 5c                	pop    r12
  4048de:	41 5d                	pop    r13
  4048e0:	5d                   	pop    rbp
  4048e1:	c3                   	ret    
  4048e2:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4048e9:	00 00 00 00 
  4048ed:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004048f0 <slm_thd_alloc_in>:

struct slm_thd_container *
slm_thd_alloc_in(compid_t cid, thdclosure_index_t idx, thdcap_t *thd, thdid_t *tid)
{
  4048f0:	f3 0f 1e fa          	endbr64 
  4048f4:	55                   	push   rbp
	struct slm_thd_container *ret = NULL;
	thdid_t _tid;
	thdcap_t _cap;

	_cap = capmgr_thd_create_ext(cid, idx, &_tid);
  4048f5:	0f b7 ff             	movzx  edi,di
{
  4048f8:	48 89 e5             	mov    rbp,rsp
  4048fb:	41 55                	push   r13
  4048fd:	49 89 cd             	mov    r13,rcx
  404900:	41 54                	push   r12
  404902:	49 89 d4             	mov    r12,rdx
	_cap = capmgr_thd_create_ext(cid, idx, &_tid);
  404905:	48 8d 55 e8          	lea    rdx,[rbp-0x18]
{
  404909:	48 83 ec 10          	sub    rsp,0x10
	_cap = capmgr_thd_create_ext(cid, idx, &_tid);
  40490d:	e8 5e 22 00 00       	call   406b70 <__cosrt_extern_capmgr_thd_create_ext>
  404912:	48 89 c7             	mov    rdi,rax
	if (_cap <= 0) return NULL;
  404915:	31 c0                	xor    eax,eax
  404917:	48 85 ff             	test   rdi,rdi
  40491a:	74 0f                	je     40492b <slm_thd_alloc_in+0x3b>

	return slm_thd_mem_alloc(_cap, _tid, thd, tid);
  40491c:	48 8b 75 e8          	mov    rsi,QWORD PTR [rbp-0x18]
  404920:	4c 89 e9             	mov    rcx,r13
  404923:	4c 89 e2             	mov    rdx,r12
  404926:	e8 85 d0 ff ff       	call   4019b0 <slm_thd_mem_alloc>
}
  40492b:	48 83 c4 10          	add    rsp,0x10
  40492f:	41 5c                	pop    r12
  404931:	41 5d                	pop    r13
  404933:	5d                   	pop    rbp
  404934:	c3                   	ret    
  404935:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40493c:	00 00 00 00 

0000000000404940 <thd_alloc>:
extern struct slm_thd *slm_thd_current_extern(void);
extern struct slm_thd *slm_thd_from_container(struct slm_thd_container *c);

struct slm_thd *
thd_alloc(thd_fn_t fn, void *data, sched_param_t *parameters, int reschedule)
{
  404940:	f3 0f 1e fa          	endbr64 
  404944:	55                   	push   rbp
  404945:	48 89 e5             	mov    rbp,rsp
  404948:	41 57                	push   r15
  40494a:	41 89 cf             	mov    r15d,ecx
  40494d:	41 56                	push   r14
  40494f:	49 89 d6             	mov    r14,rdx
  404952:	41 55                	push   r13
  404954:	49 89 f5             	mov    r13,rsi
  404957:	41 54                	push   r12
  404959:	49 89 fc             	mov    r12,rdi
  40495c:	53                   	push   rbx
  40495d:	48 83 ec 28          	sub    rsp,0x28
	struct slm_thd_container *t;
	struct slm_thd *thd;
	struct slm_thd *ret     = NULL;
	struct slm_thd *current = slm_thd_current_extern();
  404961:	e8 da cf ff ff       	call   401940 <slm_thd_current_extern>

	/*
	 * If this condition is true, we are likely in the
	 * initialization sequence in the idle or scheduler threads...
	 */
	if (!current) {
  404966:	48 89 c3             	mov    rbx,rax
  404969:	48 85 c0             	test   rax,rax
  40496c:	0f 84 3e 02 00 00    	je     404bb0 <thd_alloc+0x270>
	_cap = capmgr_thd_create(fn, data, &_tid);
  404972:	4c 89 e7             	mov    rdi,r12
  404975:	48 8d 55 c8          	lea    rdx,[rbp-0x38]
  404979:	4c 89 ee             	mov    rsi,r13
  40497c:	e8 ef 53 00 00       	call   409d70 <capmgr_thd_create>
  404981:	48 89 c7             	mov    rdi,rax
	if (_cap <= 0) return NULL;
  404984:	48 85 c0             	test   rax,rax
  404987:	0f 84 a2 00 00 00    	je     404a2f <thd_alloc+0xef>
	return slm_thd_mem_alloc(_cap, _tid, thd, tid);
  40498d:	48 8b 75 c8          	mov    rsi,QWORD PTR [rbp-0x38]
  404991:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  404995:	48 8d 55 b8          	lea    rdx,[rbp-0x48]
  404999:	e8 12 d0 ff ff       	call   4019b0 <slm_thd_mem_alloc>
  40499e:	49 89 c5             	mov    r13,rax
		current = slm_thd_special();
		assert(current);
	}

	t = slm_thd_alloc(fn, data, &thdcap, &tid);
	if (!t) ERR_THROW(NULL, done);
  4049a1:	48 85 c0             	test   rax,rax
  4049a4:	0f 84 85 00 00 00    	je     404a2f <thd_alloc+0xef>
	thd = slm_thd_from_container(t);
  4049aa:	48 89 c7             	mov    rdi,rax
  4049ad:	e8 ee cf ff ff       	call   4019a0 <slm_thd_from_container>
  4049b2:	49 89 c4             	mov    r12,rax
		tok    = cos_sched_sync();
  4049b5:	e8 46 c9 00 00       	call   411300 <cos_sched_sync>
  4049ba:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4049bd:	48 8b 05 fc d4 19 00 	mov    rax,QWORD PTR [rip+0x19d4fc]        # 5a1ec0 <__slm_global>
		if (unlikely(owner)) {
  4049c4:	48 89 c1             	mov    rcx,rax
  4049c7:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  4049cb:	0f 85 0f 02 00 00    	jne    404be0 <thd_alloc+0x2a0>
  4049d1:	f0 48 0f b1 1d e6 d4 	lock cmpxchg QWORD PTR [rip+0x19d4e6],rbx        # 5a1ec0 <__slm_global>
  4049d8:	19 00 
  4049da:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4049dd:	84 c0                	test   al,al
  4049df:	74 d4                	je     4049b5 <thd_alloc+0x75>

	slm_cs_enter(current, SLM_CS_NONE);
	if (slm_thd_init(thd, thdcap, tid)) ERR_THROW(NULL, free);
  4049e1:	48 8b 55 c0          	mov    rdx,QWORD PTR [rbp-0x40]
  4049e5:	48 8b 75 b8          	mov    rsi,QWORD PTR [rbp-0x48]
  4049e9:	4c 89 e7             	mov    rdi,r12
  4049ec:	e8 1f ed 00 00       	call   413710 <slm_thd_init>
  4049f1:	85 c0                	test   eax,eax
  4049f3:	75 32                	jne    404a27 <thd_alloc+0xe7>

	for (i = 0; parameters[i] != 0; i++) {
  4049f5:	41 8b 36             	mov    esi,DWORD PTR [r14]
  4049f8:	49 83 c6 04          	add    r14,0x4
  4049fc:	85 f6                	test   esi,esi
  4049fe:	75 13                	jne    404a13 <thd_alloc+0xd3>
  404a00:	eb 46                	jmp    404a48 <thd_alloc+0x108>
  404a02:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  404a08:	41 8b 36             	mov    esi,DWORD PTR [r14]
  404a0b:	49 83 c6 04          	add    r14,0x4
  404a0f:	85 f6                	test   esi,esi
  404a11:	74 35                	je     404a48 <thd_alloc+0x108>
  404a13:	89 f2                	mov    edx,esi
		sched_param_type_t type;
		unsigned int value;

		sched_param_get(parameters[i], &type, &value);
		if (slm_sched_thd_update(thd, type, value)) ERR_THROW(NULL, free);
  404a15:	4c 89 e7             	mov    rdi,r12
	if (type)  *type  = (sched_param_type_t)(sp &  SCHED_PARAM_TYPE_MASK);
  404a18:	83 e6 3f             	and    esi,0x3f
	if (value) *value = (unsigned int)      (sp >> SCHED_PARAM_TYPE_BITS);
  404a1b:	c1 ea 06             	shr    edx,0x6
  404a1e:	e8 3d cd ff ff       	call   401760 <slm_sched_thd_update>
  404a23:	85 c0                	test   eax,eax
  404a25:	74 e1                	je     404a08 <thd_alloc+0xc8>

	ret = thd;
done:
	return ret;
free:
	slm_thd_mem_free(t);
  404a27:	4c 89 ef             	mov    rdi,r13
  404a2a:	e8 21 d1 ff ff       	call   401b50 <slm_thd_mem_free>
	ret = NULL;
  404a2f:	45 31 e4             	xor    r12d,r12d
	goto done;
}
  404a32:	48 83 c4 28          	add    rsp,0x28
  404a36:	4c 89 e0             	mov    rax,r12
  404a39:	5b                   	pop    rbx
  404a3a:	41 5c                	pop    r12
  404a3c:	41 5d                	pop    r13
  404a3e:	41 5e                	pop    r14
  404a40:	41 5f                	pop    r15
  404a42:	5d                   	pop    rbp
  404a43:	c3                   	ret    
  404a44:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	slm_thd_mem_activate(t);
  404a48:	4c 89 ef             	mov    rdi,r13
  404a4b:	e8 40 d0 ff ff       	call   401a90 <slm_thd_mem_activate>
	if (reschedule) {
  404a50:	45 85 ff             	test   r15d,r15d
  404a53:	0f 84 1b 01 00 00    	je     404b74 <thd_alloc+0x234>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  404a59:	e8 02 6e 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	tok  = cos_sched_sync();
  404a5e:	e8 9d c8 00 00       	call   411300 <cos_sched_sync>
  404a63:	41 89 c7             	mov    r15d,eax
	t = slm_sched_schedule();
  404a66:	e8 35 cd ff ff       	call   4017a0 <slm_sched_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  404a6b:	48 85 c0             	test   rax,rax
	t = slm_sched_schedule();
  404a6e:	49 89 c6             	mov    r14,rax
	if (unlikely(!t)) t = &g->idle_thd;
  404a71:	b8 40 1f 5a 00       	mov    eax,0x5a1f40
  404a76:	4c 0f 44 f0          	cmove  r14,rax
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  404a7a:	41 8b 46 04          	mov    eax,DWORD PTR [r14+0x4]
  404a7e:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  404a81:	83 f8 01             	cmp    eax,0x1
  404a84:	76 1a                	jbe    404aa0 <thd_alloc+0x160>
  404a86:	e9 91 01 00 00       	jmp    404c1c <thd_alloc+0x2dc>
  404a8b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  404a90:	f0 48 0f b1 15 27 d4 	lock cmpxchg QWORD PTR [rip+0x19d427],rdx        # 5a1ec0 <__slm_global>
  404a97:	19 00 
  404a99:	0f 94 c0             	sete   al
	while (ret != 0) {
  404a9c:	84 c0                	test   al,al
  404a9e:	75 2e                	jne    404ace <thd_alloc+0x18e>
		tok    = cos_sched_sync();
  404aa0:	e8 5b c8 00 00       	call   411300 <cos_sched_sync>
  404aa5:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  404aa7:	48 8b 05 12 d4 19 00 	mov    rax,QWORD PTR [rip+0x19d412]        # 5a1ec0 <__slm_global>
		if (unlikely(contention)) {
  404aae:	48 89 c2             	mov    rdx,rax
  404ab1:	83 e2 01             	and    edx,0x1
  404ab4:	74 da                	je     404a90 <thd_alloc+0x150>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  404ab6:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  404ab9:	48 89 c2             	mov    rdx,rax
  404abc:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  404ac1:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  404ac5:	e8 96 ed 00 00       	call   413860 <slm_cs_exit_contention>
  404aca:	85 c0                	test   eax,eax
  404acc:	75 d2                	jne    404aa0 <thd_alloc+0x160>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  404ace:	e8 8d 6d 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  404ad3:	41 8b 06             	mov    eax,DWORD PTR [r14]
	timeout = g->timeout_next;
  404ad6:	4c 8b 05 eb d4 19 00 	mov    r8,QWORD PTR [rip+0x19d4eb]        # 5a1fc8 <__slm_global+0x108>
	prio = inherit_prio ? curr->priority : t->priority;
  404add:	49 8b 76 30          	mov    rsi,QWORD PTR [r14+0x30]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  404ae1:	a8 0b                	test   al,0xb
  404ae3:	0f 85 4f 01 00 00    	jne    404c38 <thd_alloc+0x2f8>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  404ae9:	49 8b 7e 10          	mov    rdi,QWORD PTR [r14+0x10]
  404aed:	44 89 f9             	mov    ecx,r15d
  404af0:	4c 89 c2             	mov    rdx,r8
  404af3:	e8 68 7c 00 00       	call   40c760 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  404af8:	83 f8 ff             	cmp    eax,0xffffffff
  404afb:	0f 84 a4 01 00 00    	je     404ca5 <thd_alloc+0x365>
	if (unlikely(ret != 0)) {
  404b01:	85 c0                	test   eax,eax
  404b03:	0f 84 29 ff ff ff    	je     404a32 <thd_alloc+0xf2>
		assert(ret != -EINVAL);
  404b09:	83 f8 ea             	cmp    eax,0xffffffea
  404b0c:	0f 84 eb 01 00 00    	je     404cfd <thd_alloc+0x3bd>
		if (ret == -EBUSY) return ret;
  404b12:	83 f8 f0             	cmp    eax,0xfffffff0
  404b15:	0f 84 0c ff ff ff    	je     404a27 <thd_alloc+0xe7>
		assert(ret == -EAGAIN);
  404b1b:	83 f8 f5             	cmp    eax,0xfffffff5
  404b1e:	0f 85 1c 02 00 00    	jne    404d40 <thd_alloc+0x400>
		tok    = cos_sched_sync();
  404b24:	e8 d7 c7 00 00       	call   411300 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  404b29:	48 8b 35 90 d3 19 00 	mov    rsi,QWORD PTR [rip+0x19d390]        # 5a1ec0 <__slm_global>
  404b30:	41 89 c1             	mov    r9d,eax
		if (unlikely(owner)) {
  404b33:	48 89 f1             	mov    rcx,rsi
  404b36:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  404b3a:	0f 85 d9 01 00 00    	jne    404d19 <thd_alloc+0x3d9>
  404b40:	48 89 f0             	mov    rax,rsi
  404b43:	f0 48 0f b1 1d 74 d3 	lock cmpxchg QWORD PTR [rip+0x19d374],rbx        # 5a1ec0 <__slm_global>
  404b4a:	19 00 
  404b4c:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  404b4f:	84 c0                	test   al,al
  404b51:	0f 85 07 ff ff ff    	jne    404a5e <thd_alloc+0x11e>
  404b57:	eb cb                	jmp    404b24 <thd_alloc+0x1e4>
  404b59:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  404b60:	f0 48 0f b1 15 57 d3 	lock cmpxchg QWORD PTR [rip+0x19d357],rdx        # 5a1ec0 <__slm_global>
  404b67:	19 00 
  404b69:	0f 94 c0             	sete   al
	while (ret != 0) {
  404b6c:	84 c0                	test   al,al
  404b6e:	0f 85 be fe ff ff    	jne    404a32 <thd_alloc+0xf2>
		tok    = cos_sched_sync();
  404b74:	e8 87 c7 00 00       	call   411300 <cos_sched_sync>
  404b79:	89 c1                	mov    ecx,eax
  404b7b:	48 8b 05 3e d3 19 00 	mov    rax,QWORD PTR [rip+0x19d33e]        # 5a1ec0 <__slm_global>
		if (unlikely(contention)) {
  404b82:	48 89 c2             	mov    rdx,rax
  404b85:	83 e2 01             	and    edx,0x1
  404b88:	74 d6                	je     404b60 <thd_alloc+0x220>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  404b8a:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  404b8d:	48 89 c2             	mov    rdx,rax
  404b90:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  404b95:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  404b99:	e8 c2 ec 00 00       	call   413860 <slm_cs_exit_contention>
  404b9e:	85 c0                	test   eax,eax
  404ba0:	0f 84 8c fe ff ff    	je     404a32 <thd_alloc+0xf2>
  404ba6:	eb cc                	jmp    404b74 <thd_alloc+0x234>
  404ba8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  404baf:	00 
		current = slm_thd_special();
  404bb0:	e8 1b eb 00 00       	call   4136d0 <slm_thd_special>
  404bb5:	48 89 c3             	mov    rbx,rax
		assert(current);
  404bb8:	48 85 c0             	test   rax,rax
  404bbb:	0f 85 b1 fd ff ff    	jne    404972 <thd_alloc+0x32>
  404bc1:	be 28 00 00 00       	mov    esi,0x28
  404bc6:	bf 68 cd 41 00       	mov    edi,0x41cd68
  404bcb:	e8 00 55 00 00       	call   40a0d0 <cos_print_str>
  404bd0:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404bd7:	00 00 00 00 
  404bdb:	0f 0b                	ud2    
  404bdd:	0f 1f 00             	nop    DWORD PTR [rax]
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  404be0:	41 89 c0             	mov    r8d,eax
  404be3:	48 89 da             	mov    rdx,rbx
  404be6:	48 89 c6             	mov    rsi,rax
  404be9:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  404bee:	41 83 e0 01          	and    r8d,0x1
  404bf2:	e8 19 ec 00 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  404bf7:	83 f8 f0             	cmp    eax,0xfffffff0
  404bfa:	0f 85 b5 fd ff ff    	jne    4049b5 <thd_alloc+0x75>
  404c00:	be 59 00 00 00       	mov    esi,0x59
  404c05:	bf 98 cd 41 00       	mov    edi,0x41cd98
  404c0a:	e8 c1 54 00 00       	call   40a0d0 <cos_print_str>
  404c0f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404c16:	00 00 00 00 
  404c1a:	0f 0b                	ud2    
  404c1c:	be 61 00 00 00       	mov    esi,0x61
  404c21:	bf f8 cd 41 00       	mov    edi,0x41cdf8
  404c26:	e8 a5 54 00 00       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  404c2b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404c32:	00 00 00 00 
  404c36:	0f 0b                	ud2    
	timeout = g->timeout_next;
  404c38:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  404c3b:	49 81 fe c8 1e 5a 00 	cmp    r14,0x5a1ec8
  404c42:	0f 84 8f 00 00 00    	je     404cd7 <thd_alloc+0x397>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  404c48:	a8 02                	test   al,0x2
  404c4a:	0f 85 92 00 00 00    	jne    404ce2 <thd_alloc+0x3a2>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  404c50:	49 89 c8             	mov    r8,rcx
  404c53:	a8 01                	test   al,0x1
  404c55:	0f 84 8e fe ff ff    	je     404ae9 <thd_alloc+0x1a9>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  404c5b:	4d 8b 56 08          	mov    r10,QWORD PTR [r14+0x8]
  404c5f:	49 8b 7e 10          	mov    rdi,QWORD PTR [r14+0x10]
  404c63:	48 89 f2             	mov    rdx,rsi
  404c66:	45 89 f9             	mov    r9d,r15d
  404c69:	4c 8b 05 78 d2 19 00 	mov    r8,QWORD PTR [rip+0x19d278]        # 5a1ee8 <__slm_global+0x28>
  404c70:	4c 89 d6             	mov    rsi,r10
  404c73:	e8 a8 c6 00 00       	call   411320 <cos_switch>
	if (unlikely(ret != 0)) {
  404c78:	85 c0                	test   eax,eax
  404c7a:	0f 84 b2 fd ff ff    	je     404a32 <thd_alloc+0xf2>
		assert(ret != -EPERM);
  404c80:	83 f8 ff             	cmp    eax,0xffffffff
  404c83:	0f 85 80 fe ff ff    	jne    404b09 <thd_alloc+0x1c9>
  404c89:	be 61 00 00 00       	mov    esi,0x61
  404c8e:	bf 60 ce 41 00       	mov    edi,0x41ce60
  404c93:	e8 38 54 00 00       	call   40a0d0 <cos_print_str>
  404c98:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404c9f:	00 00 00 00 
  404ca3:	0f 0b                	ud2    
	return t != &g->idle_thd && t != &g->sched_thd;
  404ca5:	49 81 fe 40 1f 5a 00 	cmp    r14,0x5a1f40
  404cac:	74 09                	je     404cb7 <thd_alloc+0x377>
  404cae:	49 81 fe c8 1e 5a 00 	cmp    r14,0x5a1ec8
  404cb5:	75 d2                	jne    404c89 <thd_alloc+0x349>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  404cb7:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]
  404cbb:	4c 8b 05 26 d2 19 00 	mov    r8,QWORD PTR [rip+0x19d226]        # 5a1ee8 <__slm_global+0x28>
  404cc2:	45 89 f9             	mov    r9d,r15d
  404cc5:	31 c9                	xor    ecx,ecx
  404cc7:	48 8b 3d 0a d2 19 00 	mov    rdi,QWORD PTR [rip+0x19d20a]        # 5a1ed8 <__slm_global+0x18>
  404cce:	31 f6                	xor    esi,esi
  404cd0:	e8 4b c6 00 00       	call   411320 <cos_switch>
  404cd5:	eb a1                	jmp    404c78 <thd_alloc+0x338>
			prio    = curr->priority;
  404cd7:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
			timeout = TCAP_TIME_NIL;
  404cdb:	31 c9                	xor    ecx,ecx
  404cdd:	e9 66 ff ff ff       	jmp    404c48 <thd_alloc+0x308>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  404ce2:	49 8b 7e 28          	mov    rdi,QWORD PTR [r14+0x28]
  404ce6:	48 8b 15 fb d1 19 00 	mov    rdx,QWORD PTR [rip+0x19d1fb]        # 5a1ee8 <__slm_global+0x28>
  404ced:	44 89 f9             	mov    ecx,r15d
  404cf0:	4c 89 c6             	mov    rsi,r8
  404cf3:	e8 98 c6 00 00       	call   411390 <cos_sched_asnd>
  404cf8:	e9 7b ff ff ff       	jmp    404c78 <thd_alloc+0x338>
  404cfd:	be 61 00 00 00       	mov    esi,0x61
  404d02:	bf c8 ce 41 00       	mov    edi,0x41cec8
  404d07:	e8 c4 53 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  404d0c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404d13:	00 00 00 00 
  404d17:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  404d19:	41 89 f0             	mov    r8d,esi
  404d1c:	48 89 da             	mov    rdx,rbx
  404d1f:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  404d24:	41 83 e0 01          	and    r8d,0x1
  404d28:	e8 e3 ea 00 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  404d2d:	83 f8 f0             	cmp    eax,0xfffffff0
  404d30:	0f 85 ee fd ff ff    	jne    404b24 <thd_alloc+0x1e4>
  404d36:	e9 c5 fe ff ff       	jmp    404c00 <thd_alloc+0x2c0>
  404d3b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  404d40:	be 61 00 00 00       	mov    esi,0x61
  404d45:	bf 30 cf 41 00       	mov    edi,0x41cf30
  404d4a:	e8 81 53 00 00       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  404d4f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404d56:	00 00 00 00 
  404d5a:	0f 0b                	ud2    
  404d5c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000404d60 <thd_alloc_in>:

struct slm_thd *
thd_alloc_in(compid_t id, thdclosure_index_t idx, sched_param_t *parameters, int reschedule)
{
  404d60:	f3 0f 1e fa          	endbr64 
  404d64:	55                   	push   rbp
  404d65:	48 89 e5             	mov    rbp,rsp
  404d68:	41 57                	push   r15
  404d6a:	41 89 cf             	mov    r15d,ecx
  404d6d:	41 56                	push   r14
  404d6f:	41 89 f6             	mov    r14d,esi
  404d72:	41 55                	push   r13
  404d74:	41 54                	push   r12
  404d76:	49 89 fc             	mov    r12,rdi
  404d79:	53                   	push   rbx
  404d7a:	48 89 d3             	mov    rbx,rdx
  404d7d:	48 83 ec 28          	sub    rsp,0x28
	struct slm_thd_container *t;
	struct slm_thd *ret     = NULL, *thd;
	struct slm_thd *current = slm_thd_current_extern();
  404d81:	e8 ba cb ff ff       	call   401940 <slm_thd_current_extern>

	/*
	 * If this condition is true, we are likely in the
	 * initialization sequence in the idle or scheduler threads...
	 */
	if (!current) {
  404d86:	49 89 c5             	mov    r13,rax
  404d89:	48 85 c0             	test   rax,rax
  404d8c:	0f 84 2e 02 00 00    	je     404fc0 <thd_alloc_in+0x260>
	_cap = capmgr_thd_create_ext(cid, idx, &_tid);
  404d92:	41 0f b7 fc          	movzx  edi,r12w
  404d96:	48 8d 55 c8          	lea    rdx,[rbp-0x38]
  404d9a:	44 89 f6             	mov    esi,r14d
  404d9d:	e8 ce 1d 00 00       	call   406b70 <__cosrt_extern_capmgr_thd_create_ext>
  404da2:	48 89 c7             	mov    rdi,rax
	if (_cap <= 0) return NULL;
  404da5:	48 85 c0             	test   rax,rax
  404da8:	0f 84 98 00 00 00    	je     404e46 <thd_alloc_in+0xe6>
	return slm_thd_mem_alloc(_cap, _tid, thd, tid);
  404dae:	48 8b 75 c8          	mov    rsi,QWORD PTR [rbp-0x38]
  404db2:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  404db6:	48 8d 55 b8          	lea    rdx,[rbp-0x48]
  404dba:	e8 f1 cb ff ff       	call   4019b0 <slm_thd_mem_alloc>
  404dbf:	49 89 c6             	mov    r14,rax
		current = slm_thd_special();
		assert(current);
	}

	t = slm_thd_alloc_in(id, idx, &thdcap, &tid);
	if (!t) ERR_THROW(NULL, done);
  404dc2:	48 85 c0             	test   rax,rax
  404dc5:	74 7f                	je     404e46 <thd_alloc_in+0xe6>
	thd = slm_thd_from_container(t);
  404dc7:	48 89 c7             	mov    rdi,rax
  404dca:	e8 d1 cb ff ff       	call   4019a0 <slm_thd_from_container>
  404dcf:	49 89 c4             	mov    r12,rax
		tok    = cos_sched_sync();
  404dd2:	e8 29 c5 00 00       	call   411300 <cos_sched_sync>
  404dd7:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  404dda:	48 8b 05 df d0 19 00 	mov    rax,QWORD PTR [rip+0x19d0df]        # 5a1ec0 <__slm_global>
		if (unlikely(owner)) {
  404de1:	48 89 c1             	mov    rcx,rax
  404de4:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  404de8:	0f 85 02 02 00 00    	jne    404ff0 <thd_alloc_in+0x290>
  404dee:	f0 4c 0f b1 2d c9 d0 	lock cmpxchg QWORD PTR [rip+0x19d0c9],r13        # 5a1ec0 <__slm_global>
  404df5:	19 00 
  404df7:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  404dfa:	84 c0                	test   al,al
  404dfc:	74 d4                	je     404dd2 <thd_alloc_in+0x72>

	slm_cs_enter(current, SLM_CS_NONE);
	if (slm_thd_init(thd, thdcap, tid)) ERR_THROW(NULL, free);
  404dfe:	48 8b 55 c0          	mov    rdx,QWORD PTR [rbp-0x40]
  404e02:	48 8b 75 b8          	mov    rsi,QWORD PTR [rbp-0x48]
  404e06:	4c 89 e7             	mov    rdi,r12
  404e09:	e8 02 e9 00 00       	call   413710 <slm_thd_init>
  404e0e:	85 c0                	test   eax,eax
  404e10:	75 2c                	jne    404e3e <thd_alloc_in+0xde>

	for (i = 0; parameters[i] != 0; i++) {
  404e12:	8b 33                	mov    esi,DWORD PTR [rbx]
  404e14:	48 83 c3 04          	add    rbx,0x4
  404e18:	85 f6                	test   esi,esi
  404e1a:	75 0e                	jne    404e2a <thd_alloc_in+0xca>
  404e1c:	eb 42                	jmp    404e60 <thd_alloc_in+0x100>
  404e1e:	66 90                	xchg   ax,ax
  404e20:	8b 33                	mov    esi,DWORD PTR [rbx]
  404e22:	48 83 c3 04          	add    rbx,0x4
  404e26:	85 f6                	test   esi,esi
  404e28:	74 36                	je     404e60 <thd_alloc_in+0x100>
  404e2a:	89 f2                	mov    edx,esi
		sched_param_type_t type;
		unsigned int value;

		sched_param_get(parameters[i], &type, &value);
		if (slm_sched_thd_update(thd, type, value)) ERR_THROW(NULL, free);
  404e2c:	4c 89 e7             	mov    rdi,r12
	if (type)  *type  = (sched_param_type_t)(sp &  SCHED_PARAM_TYPE_MASK);
  404e2f:	83 e6 3f             	and    esi,0x3f
	if (value) *value = (unsigned int)      (sp >> SCHED_PARAM_TYPE_BITS);
  404e32:	c1 ea 06             	shr    edx,0x6
  404e35:	e8 26 c9 ff ff       	call   401760 <slm_sched_thd_update>
  404e3a:	85 c0                	test   eax,eax
  404e3c:	74 e2                	je     404e20 <thd_alloc_in+0xc0>

	ret = thd;
done:
	return ret;
free:
	slm_thd_mem_free(t);
  404e3e:	4c 89 f7             	mov    rdi,r14
  404e41:	e8 0a cd ff ff       	call   401b50 <slm_thd_mem_free>
	ret = NULL;
  404e46:	45 31 e4             	xor    r12d,r12d
	goto done;
}
  404e49:	48 83 c4 28          	add    rsp,0x28
  404e4d:	4c 89 e0             	mov    rax,r12
  404e50:	5b                   	pop    rbx
  404e51:	41 5c                	pop    r12
  404e53:	41 5d                	pop    r13
  404e55:	41 5e                	pop    r14
  404e57:	41 5f                	pop    r15
  404e59:	5d                   	pop    rbp
  404e5a:	c3                   	ret    
  404e5b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	slm_thd_mem_activate(t);
  404e60:	4c 89 f7             	mov    rdi,r14
  404e63:	e8 28 cc ff ff       	call   401a90 <slm_thd_mem_activate>
	if (reschedule) {
  404e68:	45 85 ff             	test   r15d,r15d
  404e6b:	0f 84 13 01 00 00    	je     404f84 <thd_alloc_in+0x224>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  404e71:	e8 ea 69 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(!t)) t = &g->idle_thd;
  404e76:	41 bf 40 1f 5a 00    	mov    r15d,0x5a1f40
	tok  = cos_sched_sync();
  404e7c:	e8 7f c4 00 00       	call   411300 <cos_sched_sync>
  404e81:	41 89 c6             	mov    r14d,eax
	t = slm_sched_schedule();
  404e84:	e8 17 c9 ff ff       	call   4017a0 <slm_sched_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  404e89:	48 85 c0             	test   rax,rax
	t = slm_sched_schedule();
  404e8c:	48 89 c3             	mov    rbx,rax
	if (unlikely(!t)) t = &g->idle_thd;
  404e8f:	49 0f 44 df          	cmove  rbx,r15
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  404e93:	8b 43 04             	mov    eax,DWORD PTR [rbx+0x4]
  404e96:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  404e99:	83 f8 01             	cmp    eax,0x1
  404e9c:	76 1a                	jbe    404eb8 <thd_alloc_in+0x158>
  404e9e:	e9 89 01 00 00       	jmp    40502c <thd_alloc_in+0x2cc>
  404ea3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  404ea8:	f0 48 0f b1 15 0f d0 	lock cmpxchg QWORD PTR [rip+0x19d00f],rdx        # 5a1ec0 <__slm_global>
  404eaf:	19 00 
  404eb1:	0f 94 c0             	sete   al
	while (ret != 0) {
  404eb4:	84 c0                	test   al,al
  404eb6:	75 2e                	jne    404ee6 <thd_alloc_in+0x186>
		tok    = cos_sched_sync();
  404eb8:	e8 43 c4 00 00       	call   411300 <cos_sched_sync>
  404ebd:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  404ebf:	48 8b 05 fa cf 19 00 	mov    rax,QWORD PTR [rip+0x19cffa]        # 5a1ec0 <__slm_global>
		if (unlikely(contention)) {
  404ec6:	48 89 c2             	mov    rdx,rax
  404ec9:	83 e2 01             	and    edx,0x1
  404ecc:	74 da                	je     404ea8 <thd_alloc_in+0x148>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  404ece:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  404ed1:	48 89 c2             	mov    rdx,rax
  404ed4:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  404ed9:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  404edd:	e8 7e e9 00 00       	call   413860 <slm_cs_exit_contention>
  404ee2:	85 c0                	test   eax,eax
  404ee4:	75 d2                	jne    404eb8 <thd_alloc_in+0x158>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  404ee6:	e8 75 69 00 00       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  404eeb:	8b 03                	mov    eax,DWORD PTR [rbx]
	timeout = g->timeout_next;
  404eed:	4c 8b 05 d4 d0 19 00 	mov    r8,QWORD PTR [rip+0x19d0d4]        # 5a1fc8 <__slm_global+0x108>
	prio = inherit_prio ? curr->priority : t->priority;
  404ef4:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  404ef8:	a8 0b                	test   al,0xb
  404efa:	0f 85 48 01 00 00    	jne    405048 <thd_alloc_in+0x2e8>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  404f00:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  404f04:	44 89 f1             	mov    ecx,r14d
  404f07:	4c 89 c2             	mov    rdx,r8
  404f0a:	e8 51 78 00 00       	call   40c760 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  404f0f:	83 f8 ff             	cmp    eax,0xffffffff
  404f12:	0f 84 9d 01 00 00    	je     4050b5 <thd_alloc_in+0x355>
	if (unlikely(ret != 0)) {
  404f18:	85 c0                	test   eax,eax
  404f1a:	0f 84 29 ff ff ff    	je     404e49 <thd_alloc_in+0xe9>
		assert(ret != -EINVAL);
  404f20:	83 f8 ea             	cmp    eax,0xffffffea
  404f23:	0f 84 e4 01 00 00    	je     40510d <thd_alloc_in+0x3ad>
		if (ret == -EBUSY) return ret;
  404f29:	83 f8 f0             	cmp    eax,0xfffffff0
  404f2c:	0f 84 14 ff ff ff    	je     404e46 <thd_alloc_in+0xe6>
		assert(ret == -EAGAIN);
  404f32:	83 f8 f5             	cmp    eax,0xfffffff5
  404f35:	0f 85 15 02 00 00    	jne    405150 <thd_alloc_in+0x3f0>
		tok    = cos_sched_sync();
  404f3b:	e8 c0 c3 00 00       	call   411300 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  404f40:	48 8b 35 79 cf 19 00 	mov    rsi,QWORD PTR [rip+0x19cf79]        # 5a1ec0 <__slm_global>
  404f47:	41 89 c1             	mov    r9d,eax
		if (unlikely(owner)) {
  404f4a:	48 89 f1             	mov    rcx,rsi
  404f4d:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  404f51:	0f 85 d2 01 00 00    	jne    405129 <thd_alloc_in+0x3c9>
  404f57:	48 89 f0             	mov    rax,rsi
  404f5a:	f0 4c 0f b1 2d 5d cf 	lock cmpxchg QWORD PTR [rip+0x19cf5d],r13        # 5a1ec0 <__slm_global>
  404f61:	19 00 
  404f63:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  404f66:	84 c0                	test   al,al
  404f68:	0f 85 0e ff ff ff    	jne    404e7c <thd_alloc_in+0x11c>
  404f6e:	eb cb                	jmp    404f3b <thd_alloc_in+0x1db>
  404f70:	f0 48 0f b1 15 47 cf 	lock cmpxchg QWORD PTR [rip+0x19cf47],rdx        # 5a1ec0 <__slm_global>
  404f77:	19 00 
  404f79:	0f 94 c0             	sete   al
	while (ret != 0) {
  404f7c:	84 c0                	test   al,al
  404f7e:	0f 85 c5 fe ff ff    	jne    404e49 <thd_alloc_in+0xe9>
		tok    = cos_sched_sync();
  404f84:	e8 77 c3 00 00       	call   411300 <cos_sched_sync>
  404f89:	89 c1                	mov    ecx,eax
  404f8b:	48 8b 05 2e cf 19 00 	mov    rax,QWORD PTR [rip+0x19cf2e]        # 5a1ec0 <__slm_global>
		if (unlikely(contention)) {
  404f92:	48 89 c2             	mov    rdx,rax
  404f95:	83 e2 01             	and    edx,0x1
  404f98:	74 d6                	je     404f70 <thd_alloc_in+0x210>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  404f9a:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  404f9d:	48 89 c2             	mov    rdx,rax
  404fa0:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  404fa5:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  404fa9:	e8 b2 e8 00 00       	call   413860 <slm_cs_exit_contention>
  404fae:	85 c0                	test   eax,eax
  404fb0:	0f 84 93 fe ff ff    	je     404e49 <thd_alloc_in+0xe9>
  404fb6:	eb cc                	jmp    404f84 <thd_alloc_in+0x224>
  404fb8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  404fbf:	00 
		current = slm_thd_special();
  404fc0:	e8 0b e7 00 00       	call   4136d0 <slm_thd_special>
  404fc5:	49 89 c5             	mov    r13,rax
		assert(current);
  404fc8:	48 85 c0             	test   rax,rax
  404fcb:	0f 85 c1 fd ff ff    	jne    404d92 <thd_alloc_in+0x32>
  404fd1:	be 29 00 00 00       	mov    esi,0x29
  404fd6:	bf 98 cf 41 00       	mov    edi,0x41cf98
  404fdb:	e8 f0 50 00 00       	call   40a0d0 <cos_print_str>
  404fe0:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404fe7:	00 00 00 00 
  404feb:	0f 0b                	ud2    
  404fed:	0f 1f 00             	nop    DWORD PTR [rax]
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  404ff0:	41 89 c0             	mov    r8d,eax
  404ff3:	4c 89 ea             	mov    rdx,r13
  404ff6:	48 89 c6             	mov    rsi,rax
  404ff9:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  404ffe:	41 83 e0 01          	and    r8d,0x1
  405002:	e8 09 e8 00 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  405007:	83 f8 f0             	cmp    eax,0xfffffff0
  40500a:	0f 85 c2 fd ff ff    	jne    404dd2 <thd_alloc_in+0x72>
  405010:	be 59 00 00 00       	mov    esi,0x59
  405015:	bf 98 cd 41 00       	mov    edi,0x41cd98
  40501a:	e8 b1 50 00 00       	call   40a0d0 <cos_print_str>
  40501f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  405026:	00 00 00 00 
  40502a:	0f 0b                	ud2    
  40502c:	be 61 00 00 00       	mov    esi,0x61
  405031:	bf f8 cd 41 00       	mov    edi,0x41cdf8
  405036:	e8 95 50 00 00       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  40503b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  405042:	00 00 00 00 
  405046:	0f 0b                	ud2    
	timeout = g->timeout_next;
  405048:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  40504b:	48 81 fb c8 1e 5a 00 	cmp    rbx,0x5a1ec8
  405052:	0f 84 8f 00 00 00    	je     4050e7 <thd_alloc_in+0x387>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  405058:	a8 02                	test   al,0x2
  40505a:	0f 85 92 00 00 00    	jne    4050f2 <thd_alloc_in+0x392>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  405060:	49 89 c8             	mov    r8,rcx
  405063:	a8 01                	test   al,0x1
  405065:	0f 84 95 fe ff ff    	je     404f00 <thd_alloc_in+0x1a0>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  40506b:	4c 8b 53 08          	mov    r10,QWORD PTR [rbx+0x8]
  40506f:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  405073:	48 89 f2             	mov    rdx,rsi
  405076:	45 89 f1             	mov    r9d,r14d
  405079:	4c 8b 05 68 ce 19 00 	mov    r8,QWORD PTR [rip+0x19ce68]        # 5a1ee8 <__slm_global+0x28>
  405080:	4c 89 d6             	mov    rsi,r10
  405083:	e8 98 c2 00 00       	call   411320 <cos_switch>
	if (unlikely(ret != 0)) {
  405088:	85 c0                	test   eax,eax
  40508a:	0f 84 b9 fd ff ff    	je     404e49 <thd_alloc_in+0xe9>
		assert(ret != -EPERM);
  405090:	83 f8 ff             	cmp    eax,0xffffffff
  405093:	0f 85 87 fe ff ff    	jne    404f20 <thd_alloc_in+0x1c0>
  405099:	be 61 00 00 00       	mov    esi,0x61
  40509e:	bf 60 ce 41 00       	mov    edi,0x41ce60
  4050a3:	e8 28 50 00 00       	call   40a0d0 <cos_print_str>
  4050a8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4050af:	00 00 00 00 
  4050b3:	0f 0b                	ud2    
	return t != &g->idle_thd && t != &g->sched_thd;
  4050b5:	48 81 fb 40 1f 5a 00 	cmp    rbx,0x5a1f40
  4050bc:	74 09                	je     4050c7 <thd_alloc_in+0x367>
  4050be:	48 81 fb c8 1e 5a 00 	cmp    rbx,0x5a1ec8
  4050c5:	75 d2                	jne    405099 <thd_alloc_in+0x339>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  4050c7:	49 8b 55 30          	mov    rdx,QWORD PTR [r13+0x30]
  4050cb:	4c 8b 05 16 ce 19 00 	mov    r8,QWORD PTR [rip+0x19ce16]        # 5a1ee8 <__slm_global+0x28>
  4050d2:	45 89 f1             	mov    r9d,r14d
  4050d5:	31 c9                	xor    ecx,ecx
  4050d7:	48 8b 3d fa cd 19 00 	mov    rdi,QWORD PTR [rip+0x19cdfa]        # 5a1ed8 <__slm_global+0x18>
  4050de:	31 f6                	xor    esi,esi
  4050e0:	e8 3b c2 00 00       	call   411320 <cos_switch>
  4050e5:	eb a1                	jmp    405088 <thd_alloc_in+0x328>
			prio    = curr->priority;
  4050e7:	49 8b 75 30          	mov    rsi,QWORD PTR [r13+0x30]
			timeout = TCAP_TIME_NIL;
  4050eb:	31 c9                	xor    ecx,ecx
  4050ed:	e9 66 ff ff ff       	jmp    405058 <thd_alloc_in+0x2f8>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  4050f2:	48 8b 7b 28          	mov    rdi,QWORD PTR [rbx+0x28]
  4050f6:	48 8b 15 eb cd 19 00 	mov    rdx,QWORD PTR [rip+0x19cdeb]        # 5a1ee8 <__slm_global+0x28>
  4050fd:	44 89 f1             	mov    ecx,r14d
  405100:	4c 89 c6             	mov    rsi,r8
  405103:	e8 88 c2 00 00       	call   411390 <cos_sched_asnd>
  405108:	e9 7b ff ff ff       	jmp    405088 <thd_alloc_in+0x328>
  40510d:	be 61 00 00 00       	mov    esi,0x61
  405112:	bf c8 ce 41 00       	mov    edi,0x41cec8
  405117:	e8 b4 4f 00 00       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  40511c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  405123:	00 00 00 00 
  405127:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  405129:	41 89 f0             	mov    r8d,esi
  40512c:	4c 89 ea             	mov    rdx,r13
  40512f:	bf c0 1e 5a 00       	mov    edi,0x5a1ec0
  405134:	41 83 e0 01          	and    r8d,0x1
  405138:	e8 d3 e6 00 00       	call   413810 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  40513d:	83 f8 f0             	cmp    eax,0xfffffff0
  405140:	0f 85 f5 fd ff ff    	jne    404f3b <thd_alloc_in+0x1db>
  405146:	e9 c5 fe ff ff       	jmp    405010 <thd_alloc_in+0x2b0>
  40514b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  405150:	be 61 00 00 00       	mov    esi,0x61
  405155:	bf 30 cf 41 00       	mov    edi,0x41cf30
  40515a:	e8 71 4f 00 00       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  40515f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  405166:	00 00 00 00 
  40516a:	0f 0b                	ud2    
  40516c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000405170 <__cosrt_s_sched_get_cpu_freq>:
  405170:	48 b9 7f 51 40 00 00 	movabs rcx,0x40517f
  405177:	00 00 00 
  40517a:	e9 31 57 00 00       	jmp    40a8b0 <custom_acquire_stack>
  40517f:	52                   	push   rdx
  405180:	50                   	push   rax
  405181:	55                   	push   rbp
  405182:	4c 89 e1             	mov    rcx,r12
  405185:	48 31 ed             	xor    rbp,rbp
  405188:	48 89 f8             	mov    rax,rdi
  40518b:	48 89 df             	mov    rdi,rbx
  40518e:	48 89 c2             	mov    rdx,rax
  405191:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405195:	e8 86 f2 ff ff       	call   404420 <sched_get_cpu_freq>
  40519a:	49 89 c0             	mov    r8,rax
  40519d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  4051a4:	0f 05                	syscall 
  4051a6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4051ad:	00 00 00 

00000000004051b0 <__cosrt_alts_sched_get_cpu_freq>:
  4051b0:	4c 89 e8             	mov    rax,r13
  4051b3:	48 b9 c2 51 40 00 00 	movabs rcx,0x4051c2
  4051ba:	00 00 00 
  4051bd:	e9 ee 56 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4051c2:	52                   	push   rdx
  4051c3:	50                   	push   rax
  4051c4:	55                   	push   rbp
  4051c5:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4051c9:	48 31 ed             	xor    rbp,rbp
  4051cc:	51                   	push   rcx
  4051cd:	51                   	push   rcx
  4051ce:	4c 89 c1             	mov    rcx,r8
  4051d1:	4c 89 ca             	mov    rdx,r9
  4051d4:	e8 47 f2 ff ff       	call   404420 <sched_get_cpu_freq>
  4051d9:	59                   	pop    rcx
  4051da:	c3                   	ret    
  4051db:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000004051e0 <__cosrt_s_sched_thd_yield_to>:
  4051e0:	48 b9 ef 51 40 00 00 	movabs rcx,0x4051ef
  4051e7:	00 00 00 
  4051ea:	e9 c1 56 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4051ef:	52                   	push   rdx
  4051f0:	50                   	push   rax
  4051f1:	55                   	push   rbp
  4051f2:	4c 89 e1             	mov    rcx,r12
  4051f5:	48 31 ed             	xor    rbp,rbp
  4051f8:	48 89 f8             	mov    rax,rdi
  4051fb:	48 89 df             	mov    rdi,rbx
  4051fe:	48 89 c2             	mov    rdx,rax
  405201:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405205:	e8 76 cd ff ff       	call   401f80 <sched_thd_yield_to>
  40520a:	49 89 c0             	mov    r8,rax
  40520d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  405214:	0f 05                	syscall 
  405216:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40521d:	00 00 00 

0000000000405220 <__cosrt_alts_sched_thd_yield_to>:
  405220:	4c 89 e8             	mov    rax,r13
  405223:	48 b9 32 52 40 00 00 	movabs rcx,0x405232
  40522a:	00 00 00 
  40522d:	e9 7e 56 00 00       	jmp    40a8b0 <custom_acquire_stack>
  405232:	52                   	push   rdx
  405233:	50                   	push   rax
  405234:	55                   	push   rbp
  405235:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405239:	48 31 ed             	xor    rbp,rbp
  40523c:	51                   	push   rcx
  40523d:	51                   	push   rcx
  40523e:	4c 89 c1             	mov    rcx,r8
  405241:	4c 89 ca             	mov    rdx,r9
  405244:	e8 37 cd ff ff       	call   401f80 <sched_thd_yield_to>
  405249:	59                   	pop    rcx
  40524a:	c3                   	ret    
  40524b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000405250 <__cosrt_s_sched_thd_wakeup>:
  405250:	48 b9 5f 52 40 00 00 	movabs rcx,0x40525f
  405257:	00 00 00 
  40525a:	e9 51 56 00 00       	jmp    40a8b0 <custom_acquire_stack>
  40525f:	52                   	push   rdx
  405260:	50                   	push   rax
  405261:	55                   	push   rbp
  405262:	4c 89 e1             	mov    rcx,r12
  405265:	48 31 ed             	xor    rbp,rbp
  405268:	48 89 f8             	mov    rax,rdi
  40526b:	48 89 df             	mov    rdi,rbx
  40526e:	48 89 c2             	mov    rdx,rax
  405271:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405275:	e8 76 dc ff ff       	call   402ef0 <sched_thd_wakeup>
  40527a:	49 89 c0             	mov    r8,rax
  40527d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  405284:	0f 05                	syscall 
  405286:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40528d:	00 00 00 

0000000000405290 <__cosrt_alts_sched_thd_wakeup>:
  405290:	4c 89 e8             	mov    rax,r13
  405293:	48 b9 a2 52 40 00 00 	movabs rcx,0x4052a2
  40529a:	00 00 00 
  40529d:	e9 0e 56 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4052a2:	52                   	push   rdx
  4052a3:	50                   	push   rax
  4052a4:	55                   	push   rbp
  4052a5:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4052a9:	48 31 ed             	xor    rbp,rbp
  4052ac:	51                   	push   rcx
  4052ad:	51                   	push   rcx
  4052ae:	4c 89 c1             	mov    rcx,r8
  4052b1:	4c 89 ca             	mov    rdx,r9
  4052b4:	e8 37 dc ff ff       	call   402ef0 <sched_thd_wakeup>
  4052b9:	59                   	pop    rcx
  4052ba:	c3                   	ret    
  4052bb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000004052c0 <__cosrt_s_sched_debug_thd_state>:
  4052c0:	48 b9 cf 52 40 00 00 	movabs rcx,0x4052cf
  4052c7:	00 00 00 
  4052ca:	e9 e1 55 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4052cf:	52                   	push   rdx
  4052d0:	50                   	push   rax
  4052d1:	55                   	push   rbp
  4052d2:	4c 89 e1             	mov    rcx,r12
  4052d5:	48 31 ed             	xor    rbp,rbp
  4052d8:	48 89 f8             	mov    rax,rdi
  4052db:	48 89 df             	mov    rdi,rbx
  4052de:	48 89 c2             	mov    rdx,rax
  4052e1:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4052e5:	e8 06 e0 ff ff       	call   4032f0 <sched_debug_thd_state>
  4052ea:	49 89 c0             	mov    r8,rax
  4052ed:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  4052f4:	0f 05                	syscall 
  4052f6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4052fd:	00 00 00 

0000000000405300 <__cosrt_alts_sched_debug_thd_state>:
  405300:	4c 89 e8             	mov    rax,r13
  405303:	48 b9 12 53 40 00 00 	movabs rcx,0x405312
  40530a:	00 00 00 
  40530d:	e9 9e 55 00 00       	jmp    40a8b0 <custom_acquire_stack>
  405312:	52                   	push   rdx
  405313:	50                   	push   rax
  405314:	55                   	push   rbp
  405315:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405319:	48 31 ed             	xor    rbp,rbp
  40531c:	51                   	push   rcx
  40531d:	51                   	push   rcx
  40531e:	4c 89 c1             	mov    rcx,r8
  405321:	4c 89 ca             	mov    rdx,r9
  405324:	e8 c7 df ff ff       	call   4032f0 <sched_debug_thd_state>
  405329:	59                   	pop    rcx
  40532a:	c3                   	ret    
  40532b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000405330 <__cosrt_s_sched_thd_block>:
  405330:	48 b9 3f 53 40 00 00 	movabs rcx,0x40533f
  405337:	00 00 00 
  40533a:	e9 71 55 00 00       	jmp    40a8b0 <custom_acquire_stack>
  40533f:	52                   	push   rdx
  405340:	50                   	push   rax
  405341:	55                   	push   rbp
  405342:	4c 89 e1             	mov    rcx,r12
  405345:	48 31 ed             	xor    rbp,rbp
  405348:	48 89 f8             	mov    rax,rdi
  40534b:	48 89 df             	mov    rdi,rbx
  40534e:	48 89 c2             	mov    rdx,rax
  405351:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405355:	e8 06 d4 ff ff       	call   402760 <sched_thd_block>
  40535a:	49 89 c0             	mov    r8,rax
  40535d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  405364:	0f 05                	syscall 
  405366:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40536d:	00 00 00 

0000000000405370 <__cosrt_alts_sched_thd_block>:
  405370:	4c 89 e8             	mov    rax,r13
  405373:	48 b9 82 53 40 00 00 	movabs rcx,0x405382
  40537a:	00 00 00 
  40537d:	e9 2e 55 00 00       	jmp    40a8b0 <custom_acquire_stack>
  405382:	52                   	push   rdx
  405383:	50                   	push   rax
  405384:	55                   	push   rbp
  405385:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405389:	48 31 ed             	xor    rbp,rbp
  40538c:	51                   	push   rcx
  40538d:	51                   	push   rcx
  40538e:	4c 89 c1             	mov    rcx,r8
  405391:	4c 89 ca             	mov    rdx,r9
  405394:	e8 c7 d3 ff ff       	call   402760 <sched_thd_block>
  405399:	59                   	pop    rcx
  40539a:	c3                   	ret    
  40539b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000004053a0 <__cosrt_s_sched_blkpt_alloc>:
  4053a0:	48 b9 af 53 40 00 00 	movabs rcx,0x4053af
  4053a7:	00 00 00 
  4053aa:	e9 01 55 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4053af:	52                   	push   rdx
  4053b0:	50                   	push   rax
  4053b1:	55                   	push   rbp
  4053b2:	4c 89 e1             	mov    rcx,r12
  4053b5:	48 31 ed             	xor    rbp,rbp
  4053b8:	48 89 f8             	mov    rax,rdi
  4053bb:	48 89 df             	mov    rdi,rbx
  4053be:	48 89 c2             	mov    rdx,rax
  4053c1:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4053c5:	e8 a6 e7 ff ff       	call   403b70 <sched_blkpt_alloc>
  4053ca:	49 89 c0             	mov    r8,rax
  4053cd:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  4053d4:	0f 05                	syscall 
  4053d6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4053dd:	00 00 00 

00000000004053e0 <__cosrt_alts_sched_blkpt_alloc>:
  4053e0:	4c 89 e8             	mov    rax,r13
  4053e3:	48 b9 f2 53 40 00 00 	movabs rcx,0x4053f2
  4053ea:	00 00 00 
  4053ed:	e9 be 54 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4053f2:	52                   	push   rdx
  4053f3:	50                   	push   rax
  4053f4:	55                   	push   rbp
  4053f5:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4053f9:	48 31 ed             	xor    rbp,rbp
  4053fc:	51                   	push   rcx
  4053fd:	51                   	push   rcx
  4053fe:	4c 89 c1             	mov    rcx,r8
  405401:	4c 89 ca             	mov    rdx,r9
  405404:	e8 67 e7 ff ff       	call   403b70 <sched_blkpt_alloc>
  405409:	59                   	pop    rcx
  40540a:	c3                   	ret    
  40540b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000405410 <__cosrt_s_sched_blkpt_free>:
  405410:	48 b9 1f 54 40 00 00 	movabs rcx,0x40541f
  405417:	00 00 00 
  40541a:	e9 91 54 00 00       	jmp    40a8b0 <custom_acquire_stack>
  40541f:	52                   	push   rdx
  405420:	50                   	push   rax
  405421:	55                   	push   rbp
  405422:	4c 89 e1             	mov    rcx,r12
  405425:	48 31 ed             	xor    rbp,rbp
  405428:	48 89 f8             	mov    rax,rdi
  40542b:	48 89 df             	mov    rdi,rbx
  40542e:	48 89 c2             	mov    rdx,rax
  405431:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405435:	e8 d6 e8 ff ff       	call   403d10 <sched_blkpt_free>
  40543a:	49 89 c0             	mov    r8,rax
  40543d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  405444:	0f 05                	syscall 
  405446:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40544d:	00 00 00 

0000000000405450 <__cosrt_alts_sched_blkpt_free>:
  405450:	4c 89 e8             	mov    rax,r13
  405453:	48 b9 62 54 40 00 00 	movabs rcx,0x405462
  40545a:	00 00 00 
  40545d:	e9 4e 54 00 00       	jmp    40a8b0 <custom_acquire_stack>
  405462:	52                   	push   rdx
  405463:	50                   	push   rax
  405464:	55                   	push   rbp
  405465:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405469:	48 31 ed             	xor    rbp,rbp
  40546c:	51                   	push   rcx
  40546d:	51                   	push   rcx
  40546e:	4c 89 c1             	mov    rcx,r8
  405471:	4c 89 ca             	mov    rdx,r9
  405474:	e8 97 e8 ff ff       	call   403d10 <sched_blkpt_free>
  405479:	59                   	pop    rcx
  40547a:	c3                   	ret    
  40547b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000405480 <__cosrt_s_sched_blkpt_trigger>:
  405480:	48 b9 8f 54 40 00 00 	movabs rcx,0x40548f
  405487:	00 00 00 
  40548a:	e9 21 54 00 00       	jmp    40a8b0 <custom_acquire_stack>
  40548f:	52                   	push   rdx
  405490:	50                   	push   rax
  405491:	55                   	push   rbp
  405492:	4c 89 e1             	mov    rcx,r12
  405495:	48 31 ed             	xor    rbp,rbp
  405498:	48 89 f8             	mov    rax,rdi
  40549b:	48 89 df             	mov    rdi,rbx
  40549e:	48 89 c2             	mov    rdx,rax
  4054a1:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4054a5:	e8 76 e8 ff ff       	call   403d20 <sched_blkpt_trigger>
  4054aa:	49 89 c0             	mov    r8,rax
  4054ad:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  4054b4:	0f 05                	syscall 
  4054b6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4054bd:	00 00 00 

00000000004054c0 <__cosrt_alts_sched_blkpt_trigger>:
  4054c0:	4c 89 e8             	mov    rax,r13
  4054c3:	48 b9 d2 54 40 00 00 	movabs rcx,0x4054d2
  4054ca:	00 00 00 
  4054cd:	e9 de 53 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4054d2:	52                   	push   rdx
  4054d3:	50                   	push   rax
  4054d4:	55                   	push   rbp
  4054d5:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4054d9:	48 31 ed             	xor    rbp,rbp
  4054dc:	51                   	push   rcx
  4054dd:	51                   	push   rcx
  4054de:	4c 89 c1             	mov    rcx,r8
  4054e1:	4c 89 ca             	mov    rdx,r9
  4054e4:	e8 37 e8 ff ff       	call   403d20 <sched_blkpt_trigger>
  4054e9:	59                   	pop    rcx
  4054ea:	c3                   	ret    
  4054eb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000004054f0 <__cosrt_s_sched_blkpt_block>:
  4054f0:	48 b9 ff 54 40 00 00 	movabs rcx,0x4054ff
  4054f7:	00 00 00 
  4054fa:	e9 b1 53 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4054ff:	52                   	push   rdx
  405500:	50                   	push   rax
  405501:	55                   	push   rbp
  405502:	4c 89 e1             	mov    rcx,r12
  405505:	48 31 ed             	xor    rbp,rbp
  405508:	48 89 f8             	mov    rax,rdi
  40550b:	48 89 df             	mov    rdi,rbx
  40550e:	48 89 c2             	mov    rdx,rax
  405511:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405515:	e8 76 e8 ff ff       	call   403d90 <sched_blkpt_block>
  40551a:	49 89 c0             	mov    r8,rax
  40551d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  405524:	0f 05                	syscall 
  405526:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40552d:	00 00 00 

0000000000405530 <__cosrt_alts_sched_blkpt_block>:
  405530:	4c 89 e8             	mov    rax,r13
  405533:	48 b9 42 55 40 00 00 	movabs rcx,0x405542
  40553a:	00 00 00 
  40553d:	e9 6e 53 00 00       	jmp    40a8b0 <custom_acquire_stack>
  405542:	52                   	push   rdx
  405543:	50                   	push   rax
  405544:	55                   	push   rbp
  405545:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405549:	48 31 ed             	xor    rbp,rbp
  40554c:	51                   	push   rcx
  40554d:	51                   	push   rcx
  40554e:	4c 89 c1             	mov    rcx,r8
  405551:	4c 89 ca             	mov    rdx,r9
  405554:	e8 37 e8 ff ff       	call   403d90 <sched_blkpt_block>
  405559:	59                   	pop    rcx
  40555a:	c3                   	ret    
  40555b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000405560 <__cosrt_s_sched_thd_block_timeout>:
  405560:	48 b9 6f 55 40 00 00 	movabs rcx,0x40556f
  405567:	00 00 00 
  40556a:	e9 41 53 00 00       	jmp    40a8b0 <custom_acquire_stack>
  40556f:	52                   	push   rdx
  405570:	50                   	push   rax
  405571:	55                   	push   rbp
  405572:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405576:	6a 00                	push   0x0
  405578:	49 89 e0             	mov    r8,rsp
  40557b:	6a 00                	push   0x0
  40557d:	49 89 e1             	mov    r9,rsp
  405580:	4c 89 e1             	mov    rcx,r12
  405583:	48 31 ed             	xor    rbp,rbp
  405586:	49 89 fc             	mov    r12,rdi
  405589:	48 89 df             	mov    rdi,rbx
  40558c:	4c 89 e2             	mov    rdx,r12
  40558f:	e8 1c 03 00 00       	call   4058b0 <__cosrt_s_cstub_sched_thd_block_timeout>
  405594:	5f                   	pop    rdi
  405595:	5e                   	pop    rsi
  405596:	49 89 c0             	mov    r8,rax
  405599:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  4055a0:	0f 05                	syscall 
  4055a2:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4055a9:	00 00 00 00 
  4055ad:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004055b0 <__cosrt_alts_sched_thd_block_timeout>:
  4055b0:	4c 89 e8             	mov    rax,r13
  4055b3:	48 b9 c2 55 40 00 00 	movabs rcx,0x4055c2
  4055ba:	00 00 00 
  4055bd:	e9 ee 52 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4055c2:	52                   	push   rdx
  4055c3:	50                   	push   rax
  4055c4:	55                   	push   rbp
  4055c5:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4055c9:	48 31 ed             	xor    rbp,rbp
  4055cc:	51                   	push   rcx
  4055cd:	51                   	push   rcx
  4055ce:	4c 89 c1             	mov    rcx,r8
  4055d1:	4c 89 ca             	mov    rdx,r9
  4055d4:	6a 00                	push   0x0
  4055d6:	49 89 e0             	mov    r8,rsp
  4055d9:	6a 00                	push   0x0
  4055db:	49 89 e1             	mov    r9,rsp
  4055de:	e8 cd 02 00 00       	call   4058b0 <__cosrt_s_cstub_sched_thd_block_timeout>
  4055e3:	5f                   	pop    rdi
  4055e4:	5e                   	pop    rsi
  4055e5:	59                   	pop    rcx
  4055e6:	c3                   	ret    
  4055e7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  4055ee:	00 00 

00000000004055f0 <__cosrt_s_sched_thd_create_closure>:
  4055f0:	48 b9 ff 55 40 00 00 	movabs rcx,0x4055ff
  4055f7:	00 00 00 
  4055fa:	e9 b1 52 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4055ff:	52                   	push   rdx
  405600:	50                   	push   rax
  405601:	55                   	push   rbp
  405602:	4c 89 e1             	mov    rcx,r12
  405605:	48 31 ed             	xor    rbp,rbp
  405608:	48 89 f8             	mov    rax,rdi
  40560b:	48 89 df             	mov    rdi,rbx
  40560e:	48 89 c2             	mov    rdx,rax
  405611:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405615:	e8 46 c5 ff ff       	call   401b60 <sched_thd_create_closure>
  40561a:	49 89 c0             	mov    r8,rax
  40561d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  405624:	0f 05                	syscall 
  405626:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40562d:	00 00 00 

0000000000405630 <__cosrt_alts_sched_thd_create_closure>:
  405630:	4c 89 e8             	mov    rax,r13
  405633:	48 b9 42 56 40 00 00 	movabs rcx,0x405642
  40563a:	00 00 00 
  40563d:	e9 6e 52 00 00       	jmp    40a8b0 <custom_acquire_stack>
  405642:	52                   	push   rdx
  405643:	50                   	push   rax
  405644:	55                   	push   rbp
  405645:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405649:	48 31 ed             	xor    rbp,rbp
  40564c:	51                   	push   rcx
  40564d:	51                   	push   rcx
  40564e:	4c 89 c1             	mov    rcx,r8
  405651:	4c 89 ca             	mov    rdx,r9
  405654:	e8 07 c5 ff ff       	call   401b60 <sched_thd_create_closure>
  405659:	59                   	pop    rcx
  40565a:	c3                   	ret    
  40565b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000405660 <__cosrt_s_sched_aep_create_closure>:
  405660:	48 b9 6f 56 40 00 00 	movabs rcx,0x40566f
  405667:	00 00 00 
  40566a:	e9 41 52 00 00       	jmp    40a8b0 <custom_acquire_stack>
  40566f:	52                   	push   rdx
  405670:	50                   	push   rax
  405671:	55                   	push   rbp
  405672:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405676:	6a 00                	push   0x0
  405678:	49 89 e0             	mov    r8,rsp
  40567b:	6a 00                	push   0x0
  40567d:	49 89 e1             	mov    r9,rsp
  405680:	4c 89 e1             	mov    rcx,r12
  405683:	48 31 ed             	xor    rbp,rbp
  405686:	49 89 fc             	mov    r12,rdi
  405689:	48 89 df             	mov    rdi,rbx
  40568c:	4c 89 e2             	mov    rdx,r12
  40568f:	e8 4c 02 00 00       	call   4058e0 <__cosrt_s_cstub_sched_aep_create_closure>
  405694:	5f                   	pop    rdi
  405695:	5e                   	pop    rsi
  405696:	49 89 c0             	mov    r8,rax
  405699:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  4056a0:	0f 05                	syscall 
  4056a2:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4056a9:	00 00 00 00 
  4056ad:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004056b0 <__cosrt_alts_sched_aep_create_closure>:
  4056b0:	4c 89 e8             	mov    rax,r13
  4056b3:	48 b9 c2 56 40 00 00 	movabs rcx,0x4056c2
  4056ba:	00 00 00 
  4056bd:	e9 ee 51 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4056c2:	52                   	push   rdx
  4056c3:	50                   	push   rax
  4056c4:	55                   	push   rbp
  4056c5:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4056c9:	48 31 ed             	xor    rbp,rbp
  4056cc:	51                   	push   rcx
  4056cd:	51                   	push   rcx
  4056ce:	4c 89 c1             	mov    rcx,r8
  4056d1:	4c 89 ca             	mov    rdx,r9
  4056d4:	6a 00                	push   0x0
  4056d6:	49 89 e0             	mov    r8,rsp
  4056d9:	6a 00                	push   0x0
  4056db:	49 89 e1             	mov    r9,rsp
  4056de:	e8 fd 01 00 00       	call   4058e0 <__cosrt_s_cstub_sched_aep_create_closure>
  4056e3:	5f                   	pop    rdi
  4056e4:	5e                   	pop    rsi
  4056e5:	59                   	pop    rcx
  4056e6:	c3                   	ret    
  4056e7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  4056ee:	00 00 

00000000004056f0 <__cosrt_s_sched_thd_param_set>:
  4056f0:	48 b9 ff 56 40 00 00 	movabs rcx,0x4056ff
  4056f7:	00 00 00 
  4056fa:	e9 b1 51 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4056ff:	52                   	push   rdx
  405700:	50                   	push   rax
  405701:	55                   	push   rbp
  405702:	4c 89 e1             	mov    rcx,r12
  405705:	48 31 ed             	xor    rbp,rbp
  405708:	48 89 f8             	mov    rax,rdi
  40570b:	48 89 df             	mov    rdi,rbx
  40570e:	48 89 c2             	mov    rdx,rax
  405711:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405715:	e8 96 c4 ff ff       	call   401bb0 <sched_thd_param_set>
  40571a:	49 89 c0             	mov    r8,rax
  40571d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  405724:	0f 05                	syscall 
  405726:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40572d:	00 00 00 

0000000000405730 <__cosrt_alts_sched_thd_param_set>:
  405730:	4c 89 e8             	mov    rax,r13
  405733:	48 b9 42 57 40 00 00 	movabs rcx,0x405742
  40573a:	00 00 00 
  40573d:	e9 6e 51 00 00       	jmp    40a8b0 <custom_acquire_stack>
  405742:	52                   	push   rdx
  405743:	50                   	push   rax
  405744:	55                   	push   rbp
  405745:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405749:	48 31 ed             	xor    rbp,rbp
  40574c:	51                   	push   rcx
  40574d:	51                   	push   rcx
  40574e:	4c 89 c1             	mov    rcx,r8
  405751:	4c 89 ca             	mov    rdx,r9
  405754:	e8 57 c4 ff ff       	call   401bb0 <sched_thd_param_set>
  405759:	59                   	pop    rcx
  40575a:	c3                   	ret    
  40575b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000405760 <__cosrt_s_sched_thd_exit>:
  405760:	48 b9 6f 57 40 00 00 	movabs rcx,0x40576f
  405767:	00 00 00 
  40576a:	e9 41 51 00 00       	jmp    40a8b0 <custom_acquire_stack>
  40576f:	52                   	push   rdx
  405770:	50                   	push   rax
  405771:	55                   	push   rbp
  405772:	4c 89 e1             	mov    rcx,r12
  405775:	48 31 ed             	xor    rbp,rbp
  405778:	48 89 f8             	mov    rax,rdi
  40577b:	48 89 df             	mov    rdi,rbx
  40577e:	48 89 c2             	mov    rdx,rax
  405781:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405785:	e8 86 c4 ff ff       	call   401c10 <sched_thd_exit>
  40578a:	49 89 c0             	mov    r8,rax
  40578d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  405794:	0f 05                	syscall 
  405796:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40579d:	00 00 00 

00000000004057a0 <__cosrt_alts_sched_thd_exit>:
  4057a0:	4c 89 e8             	mov    rax,r13
  4057a3:	48 b9 b2 57 40 00 00 	movabs rcx,0x4057b2
  4057aa:	00 00 00 
  4057ad:	e9 fe 50 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4057b2:	52                   	push   rdx
  4057b3:	50                   	push   rax
  4057b4:	55                   	push   rbp
  4057b5:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4057b9:	48 31 ed             	xor    rbp,rbp
  4057bc:	51                   	push   rcx
  4057bd:	51                   	push   rcx
  4057be:	4c 89 c1             	mov    rcx,r8
  4057c1:	4c 89 ca             	mov    rdx,r9
  4057c4:	e8 47 c4 ff ff       	call   401c10 <sched_thd_exit>
  4057c9:	59                   	pop    rcx
  4057ca:	c3                   	ret    
  4057cb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000004057d0 <__cosrt_s_sched_thd_delete>:
  4057d0:	48 b9 df 57 40 00 00 	movabs rcx,0x4057df
  4057d7:	00 00 00 
  4057da:	e9 d1 50 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4057df:	52                   	push   rdx
  4057e0:	50                   	push   rax
  4057e1:	55                   	push   rbp
  4057e2:	4c 89 e1             	mov    rcx,r12
  4057e5:	48 31 ed             	xor    rbp,rbp
  4057e8:	48 89 f8             	mov    rax,rdi
  4057eb:	48 89 df             	mov    rdi,rbx
  4057ee:	48 89 c2             	mov    rdx,rax
  4057f1:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4057f5:	e8 06 c4 ff ff       	call   401c00 <sched_thd_delete>
  4057fa:	49 89 c0             	mov    r8,rax
  4057fd:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  405804:	0f 05                	syscall 
  405806:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40580d:	00 00 00 

0000000000405810 <__cosrt_alts_sched_thd_delete>:
  405810:	4c 89 e8             	mov    rax,r13
  405813:	48 b9 22 58 40 00 00 	movabs rcx,0x405822
  40581a:	00 00 00 
  40581d:	e9 8e 50 00 00       	jmp    40a8b0 <custom_acquire_stack>
  405822:	52                   	push   rdx
  405823:	50                   	push   rax
  405824:	55                   	push   rbp
  405825:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405829:	48 31 ed             	xor    rbp,rbp
  40582c:	51                   	push   rcx
  40582d:	51                   	push   rcx
  40582e:	4c 89 c1             	mov    rcx,r8
  405831:	4c 89 ca             	mov    rdx,r9
  405834:	e8 c7 c3 ff ff       	call   401c00 <sched_thd_delete>
  405839:	59                   	pop    rcx
  40583a:	c3                   	ret    
  40583b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000405840 <__cosrt_s_sched_set_tls>:
  405840:	48 b9 4f 58 40 00 00 	movabs rcx,0x40584f
  405847:	00 00 00 
  40584a:	e9 61 50 00 00       	jmp    40a8b0 <custom_acquire_stack>
  40584f:	52                   	push   rdx
  405850:	50                   	push   rax
  405851:	55                   	push   rbp
  405852:	4c 89 e1             	mov    rcx,r12
  405855:	48 31 ed             	xor    rbp,rbp
  405858:	48 89 f8             	mov    rax,rdi
  40585b:	48 89 df             	mov    rdi,rbx
  40585e:	48 89 c2             	mov    rdx,rax
  405861:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405865:	e8 d6 ca ff ff       	call   402340 <sched_set_tls>
  40586a:	49 89 c0             	mov    r8,rax
  40586d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  405874:	0f 05                	syscall 
  405876:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40587d:	00 00 00 

0000000000405880 <__cosrt_alts_sched_set_tls>:
  405880:	4c 89 e8             	mov    rax,r13
  405883:	48 b9 92 58 40 00 00 	movabs rcx,0x405892
  40588a:	00 00 00 
  40588d:	e9 1e 50 00 00       	jmp    40a8b0 <custom_acquire_stack>
  405892:	52                   	push   rdx
  405893:	50                   	push   rax
  405894:	55                   	push   rbp
  405895:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405899:	48 31 ed             	xor    rbp,rbp
  40589c:	51                   	push   rcx
  40589d:	51                   	push   rcx
  40589e:	4c 89 c1             	mov    rcx,r8
  4058a1:	4c 89 ca             	mov    rdx,r9
  4058a4:	e8 97 ca ff ff       	call   402340 <sched_set_tls>
  4058a9:	59                   	pop    rcx
  4058aa:	c3                   	ret    
  4058ab:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000004058b0 <__cosrt_s_cstub_sched_thd_block_timeout>:
#include <cos_stubs.h>
#include <sched.h>

COS_SERVER_3RET_STUB(int, sched_thd_block_timeout)
{
  4058b0:	f3 0f 1e fa          	endbr64 
  4058b4:	55                   	push   rbp
  4058b5:	48 89 e5             	mov    rbp,rsp
  4058b8:	41 54                	push   r12
  4058ba:	4d 89 c4             	mov    r12,r8
  4058bd:	53                   	push   rbx
  4058be:	4c 89 cb             	mov    rbx,r9
	cycles_t elapsed = 0, abs_timeout;

	/* works on armv7a too, as we control where hi and lo are passed for timeout */
	COS_ARG_WORDS_TO_DWORD(p1, p2, abs_timeout);
	elapsed = sched_thd_block_timeout((thdid_t)p0, abs_timeout);
  4058c1:	e8 7a da ff ff       	call   403340 <sched_thd_block_timeout>
	*r1 = (elapsed >> 32);
  4058c6:	48 89 c2             	mov    rdx,rax
	*r2 = (elapsed << 32) >> 32;
  4058c9:	83 e0 ff             	and    eax,0xffffffff
	*r1 = (elapsed >> 32);
  4058cc:	48 c1 ea 20          	shr    rdx,0x20
  4058d0:	49 89 14 24          	mov    QWORD PTR [r12],rdx
	*r2 = (elapsed << 32) >> 32;
  4058d4:	48 89 03             	mov    QWORD PTR [rbx],rax

	return 0;
}
  4058d7:	5b                   	pop    rbx
  4058d8:	31 c0                	xor    eax,eax
  4058da:	41 5c                	pop    r12
  4058dc:	5d                   	pop    rbp
  4058dd:	c3                   	ret    
  4058de:	66 90                	xchg   ax,ax

00000000004058e0 <__cosrt_s_cstub_sched_aep_create_closure>:

COS_SERVER_3RET_STUB(thdid_t, sched_aep_create_closure)
{
  4058e0:	f3 0f 1e fa          	endbr64 
  4058e4:	55                   	push   rbp
  4058e5:	48 89 f8             	mov    rax,rdi
  4058e8:	48 89 d1             	mov    rcx,rdx
	u32_t               ipimax = (p1 << 16) >> 16;
	cos_channelkey_t    key    = (p1 >> 16);
	arcvcap_t rcv;
	thdid_t ret;

	ret = sched_aep_create_closure(idx, owntc, key, ipiwin, ipimax, &rcv);
  4058eb:	89 f2                	mov    edx,esi
  4058ed:	c1 ea 10             	shr    edx,0x10
	thdclosure_index_t  idx    = (p0 >> 16);
  4058f0:	48 c1 ef 10          	shr    rdi,0x10
{
  4058f4:	48 89 e5             	mov    rbp,rsp
  4058f7:	41 54                	push   r12
  4058f9:	4d 89 c4             	mov    r12,r8
	ret = sched_aep_create_closure(idx, owntc, key, ipiwin, ipimax, &rcv);
  4058fc:	41 89 f0             	mov    r8d,esi
{
  4058ff:	53                   	push   rbx
	ret = sched_aep_create_closure(idx, owntc, key, ipiwin, ipimax, &rcv);
  405900:	89 c6                	mov    esi,eax
{
  405902:	4c 89 cb             	mov    rbx,r9
	ret = sched_aep_create_closure(idx, owntc, key, ipiwin, ipimax, &rcv);
  405905:	4c 8d 4d e8          	lea    r9,[rbp-0x18]
{
  405909:	48 83 ec 10          	sub    rsp,0x10
	ret = sched_aep_create_closure(idx, owntc, key, ipiwin, ipimax, &rcv);
  40590d:	e8 fe ea ff ff       	call   404410 <sched_aep_create_closure>

	*r1 = rcv;
  405912:	48 8b 55 e8          	mov    rdx,QWORD PTR [rbp-0x18]
  405916:	49 89 14 24          	mov    QWORD PTR [r12],rdx
	*r2 = 0;
  40591a:	48 c7 03 00 00 00 00 	mov    QWORD PTR [rbx],0x0

	return ret;
}
  405921:	48 83 c4 10          	add    rsp,0x10
  405925:	5b                   	pop    rbx
  405926:	41 5c                	pop    r12
  405928:	5d                   	pop    rbp
  405929:	c3                   	ret    
  40592a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000405930 <__cosrt_s_init_done>:
  405930:	48 b9 3f 59 40 00 00 	movabs rcx,0x40593f
  405937:	00 00 00 
  40593a:	e9 71 4f 00 00       	jmp    40a8b0 <custom_acquire_stack>
  40593f:	52                   	push   rdx
  405940:	50                   	push   rax
  405941:	55                   	push   rbp
  405942:	4c 89 e1             	mov    rcx,r12
  405945:	48 31 ed             	xor    rbp,rbp
  405948:	48 89 f8             	mov    rax,rdi
  40594b:	48 89 df             	mov    rdi,rbx
  40594e:	48 89 c2             	mov    rdx,rax
  405951:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405955:	e8 a6 aa ff ff       	call   400400 <init_done>
  40595a:	49 89 c0             	mov    r8,rax
  40595d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  405964:	0f 05                	syscall 
  405966:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40596d:	00 00 00 

0000000000405970 <__cosrt_alts_init_done>:
  405970:	4c 89 e8             	mov    rax,r13
  405973:	48 b9 82 59 40 00 00 	movabs rcx,0x405982
  40597a:	00 00 00 
  40597d:	e9 2e 4f 00 00       	jmp    40a8b0 <custom_acquire_stack>
  405982:	52                   	push   rdx
  405983:	50                   	push   rax
  405984:	55                   	push   rbp
  405985:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405989:	48 31 ed             	xor    rbp,rbp
  40598c:	51                   	push   rcx
  40598d:	51                   	push   rcx
  40598e:	4c 89 c1             	mov    rcx,r8
  405991:	4c 89 ca             	mov    rdx,r9
  405994:	e8 67 aa ff ff       	call   400400 <init_done>
  405999:	59                   	pop    rcx
  40599a:	c3                   	ret    
  40599b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000004059a0 <__cosrt_s_init_exit>:
  4059a0:	48 b9 af 59 40 00 00 	movabs rcx,0x4059af
  4059a7:	00 00 00 
  4059aa:	e9 01 4f 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4059af:	52                   	push   rdx
  4059b0:	50                   	push   rax
  4059b1:	55                   	push   rbp
  4059b2:	4c 89 e1             	mov    rcx,r12
  4059b5:	48 31 ed             	xor    rbp,rbp
  4059b8:	48 89 f8             	mov    rax,rdi
  4059bb:	48 89 df             	mov    rdi,rbx
  4059be:	48 89 c2             	mov    rdx,rax
  4059c1:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4059c5:	e8 56 ab ff ff       	call   400520 <init_exit>
  4059ca:	49 89 c0             	mov    r8,rax
  4059cd:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  4059d4:	0f 05                	syscall 
  4059d6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4059dd:	00 00 00 

00000000004059e0 <__cosrt_alts_init_exit>:
  4059e0:	4c 89 e8             	mov    rax,r13
  4059e3:	48 b9 f2 59 40 00 00 	movabs rcx,0x4059f2
  4059ea:	00 00 00 
  4059ed:	e9 be 4e 00 00       	jmp    40a8b0 <custom_acquire_stack>
  4059f2:	52                   	push   rdx
  4059f3:	50                   	push   rax
  4059f4:	55                   	push   rbp
  4059f5:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4059f9:	48 31 ed             	xor    rbp,rbp
  4059fc:	51                   	push   rcx
  4059fd:	51                   	push   rcx
  4059fe:	4c 89 c1             	mov    rcx,r8
  405a01:	4c 89 ca             	mov    rdx,r9
  405a04:	e8 17 ab ff ff       	call   400520 <init_exit>
  405a09:	59                   	pop    rcx
  405a0a:	c3                   	ret    
  405a0b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000405a10 <__cosrt_c_init_done>:
 * to serialize and deserialize arguments. In contrast, this code
 * doesn't have a corresponding client-side stub as it only
 * orchestrates the coordination with the await_init function.
 */
COS_CLIENT_STUB(int, init_done, int parallel_init, init_main_t cont)
{
  405a10:	f3 0f 1e fa          	endbr64 
  405a14:	55                   	push   rbp
	COS_CLIENT_INVCAP;
	int ret;

	ret = cos_sinv(uc, parallel_init, cont, 0, 0);
  405a15:	89 f6                	mov    esi,esi
  405a17:	4c 63 d7             	movsxd r10,edi
{
  405a1a:	48 89 e5             	mov    rbp,rsp
  405a1d:	41 55                	push   r13
  405a1f:	41 54                	push   r12
  405a21:	53                   	push   rbx
  405a22:	48 83 ec 28          	sub    rsp,0x28
  405a26:	4c 8b 68 10          	mov    r13,QWORD PTR [rax+0x10]
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, &r1, &r2);
  405a2a:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  405a2e:	4d 85 ed             	test   r13,r13
  405a31:	74 2d                	je     405a60 <__cosrt_c_init_done+0x50>
  405a33:	4c 8d 4d d0          	lea    r9,[rbp-0x30]
  405a37:	4c 8d 45 c8          	lea    r8,[rbp-0x38]
  405a3b:	31 c9                	xor    ecx,ecx
  405a3d:	31 d2                	xor    edx,edx
  405a3f:	4c 89 d7             	mov    rdi,r10
  405a42:	41 ff d5             	call   r13
	ps_store(&awaiting_init, 0);
  405a45:	c7 05 b5 e5 01 00 00 	mov    DWORD PTR [rip+0x1e5b5],0x0        # 424004 <awaiting_init>
  405a4c:	00 00 00 

	return ret;
}
  405a4f:	48 83 c4 28          	add    rsp,0x28
  405a53:	5b                   	pop    rbx
  405a54:	41 5c                	pop    r12
  405a56:	41 5d                	pop    r13
  405a58:	5d                   	pop    rbp
  405a59:	c3                   	ret    
  405a5a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  405a60:	8d 42 01             	lea    eax,[rdx+0x1]
	__asm__ __volatile__(
  405a63:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  405a67:	4c 89 d3             	mov    rbx,r10
  405a6a:	4c 89 ef             	mov    rdi,r13
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  405a6d:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  405a70:	4c 89 ea             	mov    rdx,r13
  405a73:	48 89 29             	mov    QWORD PTR [rcx],rbp
  405a76:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  405a7a:	48 89 cd             	mov    rbp,rcx
  405a7d:	49 b8 98 5a 40 00 00 	movabs r8,0x405a98
  405a84:	00 00 00 
  405a87:	0f 05                	syscall 
  405a89:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  405a90:	eb 0d                	jmp    405a9f <__cosrt_c_init_done+0x8f>
  405a92:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  405a98:	b9 00 00 00 00       	mov    ecx,0x0
  405a9d:	eb 05                	jmp    405aa4 <__cosrt_c_init_done+0x94>
  405a9f:	b9 01 00 00 00       	mov    ecx,0x1
  405aa4:	5d                   	pop    rbp
  405aa5:	5c                   	pop    rsp
	return call_cap_op(uc->cap_no, 0, arg1, arg2, arg3, arg4);
  405aa6:	eb 9d                	jmp    405a45 <__cosrt_c_init_done+0x35>
  405aa8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  405aaf:	00 

0000000000405ab0 <__cosrt_extern_init_parallel_await_init>:
 * This function is implemented as a library compiled directly into
 * the client component.
 */
void
COS_STUB_LIBFN(init_parallel_await_init)(void)
{
  405ab0:	f3 0f 1e fa          	endbr64 
  405ab4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	while (ps_load(&awaiting_init)) ;
  405ab8:	8b 05 46 e5 01 00    	mov    eax,DWORD PTR [rip+0x1e546]        # 424004 <awaiting_init>
  405abe:	85 c0                	test   eax,eax
  405ac0:	75 f6                	jne    405ab8 <__cosrt_extern_init_parallel_await_init+0x8>
}
  405ac2:	c3                   	ret    
  405ac3:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  405aca:	00 00 00 
  405acd:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000405ad0 <__cosrt_extern_init_done>:
  405ad0:	48 b8 cc c0 45 00 00 	movabs rax,0x45c0cc
  405ad7:	00 00 00 
  405ada:	ff 10                	call   QWORD PTR [rax]
  405adc:	c3                   	ret    
  405add:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000405ae0 <__cosrt_fast_callgate_init_done>:
  405ae0:	55                   	push   rbp
  405ae1:	41 55                	push   r13
  405ae3:	41 56                	push   r14
  405ae5:	41 57                	push   r15
  405ae7:	49 89 c8             	mov    r8,rcx
  405aea:	49 89 d1             	mov    r9,rdx
  405aed:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  405af4:	be ad de 
  405af7:	0f 01 f9             	rdtscp 
  405afa:	48 89 c8             	mov    rax,rcx
  405afd:	48 25 ff 0f 00 00    	and    rax,0xfff
  405b03:	48 89 e2             	mov    rdx,rsp
  405b06:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  405b0d:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  405b14:	00 
  405b15:	48 c1 e0 10          	shl    rax,0x10
  405b19:	49 09 c5             	or     r13,rax
  405b1c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  405b23:	7f 00 00 
  405b26:	4c 89 e8             	mov    rax,r13
  405b29:	48 25 ff ff 00 00    	and    rax,0xffff
  405b2f:	48 c1 e0 08          	shl    rax,0x8
  405b33:	49 01 c6             	add    r14,rax
  405b36:	b9 01 00 00 00       	mov    ecx,0x1
  405b3b:	01 c9                	add    ecx,ecx
  405b3d:	b8 03 00 00 00       	mov    eax,0x3
  405b42:	d3 e0                	shl    eax,cl
  405b44:	f7 d0                	not    eax
  405b46:	83 e0 fc             	and    eax,0xfffffffc
  405b49:	48 31 c9             	xor    rcx,rcx
  405b4c:	48 31 d2             	xor    rdx,rdx
  405b4f:	0f 01 ef             	wrpkru 
  405b52:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  405b55:	48 83 c2 01          	add    rdx,0x1
  405b59:	48 c1 e2 04          	shl    rdx,0x4
  405b5d:	4c 01 f2             	add    rdx,r14
  405b60:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  405b67:	45 23 01 
  405b6a:	48 89 02             	mov    QWORD PTR [rdx],rax
  405b6d:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  405b71:	49 8b 06             	mov    rax,QWORD PTR [r14]
  405b74:	48 83 c0 01          	add    rax,0x1
  405b78:	49 89 06             	mov    QWORD PTR [r14],rax
  405b7b:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  405b80:	01 c9                	add    ecx,ecx
  405b82:	b8 03 00 00 00       	mov    eax,0x3
  405b87:	d3 e0                	shl    eax,cl
  405b89:	f7 d0                	not    eax
  405b8b:	83 e0 fc             	and    eax,0xfffffffc
  405b8e:	48 31 c9             	xor    rcx,rcx
  405b91:	48 31 d2             	xor    rdx,rdx
  405b94:	0f 01 ef             	wrpkru 
  405b97:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  405b9e:	45 23 01 
  405ba1:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  405ba8:	be ad de 
  405bab:	49 39 c7             	cmp    r15,rax
  405bae:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  405bb5:	12 12 12 
  405bb8:	48 b9 c4 5b 40 00 00 	movabs rcx,0x405bc4
  405bbf:	00 00 00 
  405bc2:	ff e0                	jmp    rax

0000000000405bc4 <srv_call_ret_init_done>:
  405bc4:	49 89 c0             	mov    r8,rax
  405bc7:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  405bce:	be ad de 
  405bd1:	48 89 e2             	mov    rdx,rsp
  405bd4:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  405bdb:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  405be2:	00 
  405be3:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  405bea:	7f 00 00 
  405bed:	4c 89 e8             	mov    rax,r13
  405bf0:	48 25 ff ff 00 00    	and    rax,0xffff
  405bf6:	48 c1 e0 08          	shl    rax,0x8
  405bfa:	49 01 c6             	add    r14,rax
  405bfd:	b9 01 00 00 00       	mov    ecx,0x1
  405c02:	01 c9                	add    ecx,ecx
  405c04:	b8 03 00 00 00       	mov    eax,0x3
  405c09:	d3 e0                	shl    eax,cl
  405c0b:	f7 d0                	not    eax
  405c0d:	83 e0 fc             	and    eax,0xfffffffc
  405c10:	48 31 c9             	xor    rcx,rcx
  405c13:	48 31 d2             	xor    rdx,rdx
  405c16:	0f 01 ef             	wrpkru 
  405c19:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  405c1c:	48 c1 e2 04          	shl    rdx,0x4
  405c20:	4c 01 f2             	add    rdx,r14
  405c23:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  405c27:	49 8b 06             	mov    rax,QWORD PTR [r14]
  405c2a:	48 83 e8 01          	sub    rax,0x1
  405c2e:	49 89 06             	mov    QWORD PTR [r14],rax
  405c31:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  405c36:	01 c9                	add    ecx,ecx
  405c38:	b8 03 00 00 00       	mov    eax,0x3
  405c3d:	d3 e0                	shl    eax,cl
  405c3f:	f7 d0                	not    eax
  405c41:	83 e0 fc             	and    eax,0xfffffffc
  405c44:	48 31 c9             	xor    rcx,rcx
  405c47:	48 31 d2             	xor    rdx,rdx
  405c4a:	0f 01 ef             	wrpkru 
  405c4d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  405c54:	be ad de 
  405c57:	49 39 c7             	cmp    r15,rax
  405c5a:	4c 89 c0             	mov    rax,r8
  405c5d:	41 5f                	pop    r15
  405c5f:	41 5e                	pop    r14
  405c61:	41 5d                	pop    r13
  405c63:	5d                   	pop    rbp
  405c64:	c3                   	ret    
  405c65:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  405c6c:	00 00 00 00 

0000000000405c70 <__cosrt_extern_init_exit>:
  405c70:	48 b8 e4 c0 45 00 00 	movabs rax,0x45c0e4
  405c77:	00 00 00 
  405c7a:	ff 10                	call   QWORD PTR [rax]
  405c7c:	c3                   	ret    
  405c7d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000405c80 <__cosrt_fast_callgate_init_exit>:
  405c80:	55                   	push   rbp
  405c81:	41 55                	push   r13
  405c83:	41 56                	push   r14
  405c85:	41 57                	push   r15
  405c87:	49 89 c8             	mov    r8,rcx
  405c8a:	49 89 d1             	mov    r9,rdx
  405c8d:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  405c94:	be ad de 
  405c97:	0f 01 f9             	rdtscp 
  405c9a:	48 89 c8             	mov    rax,rcx
  405c9d:	48 25 ff 0f 00 00    	and    rax,0xfff
  405ca3:	48 89 e2             	mov    rdx,rsp
  405ca6:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  405cad:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  405cb4:	00 
  405cb5:	48 c1 e0 10          	shl    rax,0x10
  405cb9:	49 09 c5             	or     r13,rax
  405cbc:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  405cc3:	7f 00 00 
  405cc6:	4c 89 e8             	mov    rax,r13
  405cc9:	48 25 ff ff 00 00    	and    rax,0xffff
  405ccf:	48 c1 e0 08          	shl    rax,0x8
  405cd3:	49 01 c6             	add    r14,rax
  405cd6:	b9 01 00 00 00       	mov    ecx,0x1
  405cdb:	01 c9                	add    ecx,ecx
  405cdd:	b8 03 00 00 00       	mov    eax,0x3
  405ce2:	d3 e0                	shl    eax,cl
  405ce4:	f7 d0                	not    eax
  405ce6:	83 e0 fc             	and    eax,0xfffffffc
  405ce9:	48 31 c9             	xor    rcx,rcx
  405cec:	48 31 d2             	xor    rdx,rdx
  405cef:	0f 01 ef             	wrpkru 
  405cf2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  405cf5:	48 83 c2 01          	add    rdx,0x1
  405cf9:	48 c1 e2 04          	shl    rdx,0x4
  405cfd:	4c 01 f2             	add    rdx,r14
  405d00:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  405d07:	45 23 01 
  405d0a:	48 89 02             	mov    QWORD PTR [rdx],rax
  405d0d:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  405d11:	49 8b 06             	mov    rax,QWORD PTR [r14]
  405d14:	48 83 c0 01          	add    rax,0x1
  405d18:	49 89 06             	mov    QWORD PTR [r14],rax
  405d1b:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  405d20:	01 c9                	add    ecx,ecx
  405d22:	b8 03 00 00 00       	mov    eax,0x3
  405d27:	d3 e0                	shl    eax,cl
  405d29:	f7 d0                	not    eax
  405d2b:	83 e0 fc             	and    eax,0xfffffffc
  405d2e:	48 31 c9             	xor    rcx,rcx
  405d31:	48 31 d2             	xor    rdx,rdx
  405d34:	0f 01 ef             	wrpkru 
  405d37:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  405d3e:	45 23 01 
  405d41:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  405d48:	be ad de 
  405d4b:	49 39 c7             	cmp    r15,rax
  405d4e:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  405d55:	12 12 12 
  405d58:	48 b9 64 5d 40 00 00 	movabs rcx,0x405d64
  405d5f:	00 00 00 
  405d62:	ff e0                	jmp    rax

0000000000405d64 <srv_call_ret_init_exit>:
  405d64:	49 89 c0             	mov    r8,rax
  405d67:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  405d6e:	be ad de 
  405d71:	48 89 e2             	mov    rdx,rsp
  405d74:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  405d7b:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  405d82:	00 
  405d83:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  405d8a:	7f 00 00 
  405d8d:	4c 89 e8             	mov    rax,r13
  405d90:	48 25 ff ff 00 00    	and    rax,0xffff
  405d96:	48 c1 e0 08          	shl    rax,0x8
  405d9a:	49 01 c6             	add    r14,rax
  405d9d:	b9 01 00 00 00       	mov    ecx,0x1
  405da2:	01 c9                	add    ecx,ecx
  405da4:	b8 03 00 00 00       	mov    eax,0x3
  405da9:	d3 e0                	shl    eax,cl
  405dab:	f7 d0                	not    eax
  405dad:	83 e0 fc             	and    eax,0xfffffffc
  405db0:	48 31 c9             	xor    rcx,rcx
  405db3:	48 31 d2             	xor    rdx,rdx
  405db6:	0f 01 ef             	wrpkru 
  405db9:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  405dbc:	48 c1 e2 04          	shl    rdx,0x4
  405dc0:	4c 01 f2             	add    rdx,r14
  405dc3:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  405dc7:	49 8b 06             	mov    rax,QWORD PTR [r14]
  405dca:	48 83 e8 01          	sub    rax,0x1
  405dce:	49 89 06             	mov    QWORD PTR [r14],rax
  405dd1:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  405dd6:	01 c9                	add    ecx,ecx
  405dd8:	b8 03 00 00 00       	mov    eax,0x3
  405ddd:	d3 e0                	shl    eax,cl
  405ddf:	f7 d0                	not    eax
  405de1:	83 e0 fc             	and    eax,0xfffffffc
  405de4:	48 31 c9             	xor    rcx,rcx
  405de7:	48 31 d2             	xor    rdx,rdx
  405dea:	0f 01 ef             	wrpkru 
  405ded:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  405df4:	be ad de 
  405df7:	49 39 c7             	cmp    r15,rax
  405dfa:	4c 89 c0             	mov    rax,r8
  405dfd:	41 5f                	pop    r15
  405dff:	41 5e                	pop    r14
  405e01:	41 5d                	pop    r13
  405e03:	5d                   	pop    rbp
  405e04:	c3                   	ret    
  405e05:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  405e0c:	00 00 00 
  405e0f:	90                   	nop

0000000000405e10 <__cosrt_c_capmgr_rcv_create>:
#include <cos_thd_init.h>
#include <cos_defkernel_api.h>
#include <cos_stubs.h>

COS_CLIENT_STUB(arcvcap_t, capmgr_rcv_create, thdclosure_index_t idx, int flags, asndcap_t *asnd, thdcap_t *thdcap, thdid_t *tid)
{
  405e10:	f3 0f 1e fa          	endbr64 
  405e14:	55                   	push   rbp
	COS_CLIENT_INVCAP;
	word_t thdret, asnd_ret;
	arcvcap_t ret;

	ret = cos_sinv_2rets(uc, idx, flags, 0, 0, &asnd_ret, &thdret);
  405e15:	48 63 f6             	movsxd rsi,esi
{
  405e18:	48 89 e5             	mov    rbp,rsp
  405e1b:	41 57                	push   r15
  405e1d:	41 56                	push   r14
  405e1f:	49 89 d6             	mov    r14,rdx
  405e22:	41 55                	push   r13
  405e24:	49 89 cd             	mov    r13,rcx
  405e27:	41 54                	push   r12
  405e29:	53                   	push   rbx
	ret = cos_sinv_2rets(uc, idx, flags, 0, 0, &asnd_ret, &thdret);
  405e2a:	48 63 df             	movsxd rbx,edi
{
  405e2d:	48 83 ec 38          	sub    rsp,0x38
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  405e31:	4c 8b 78 10          	mov    r15,QWORD PTR [rax+0x10]
  405e35:	4c 89 45 a8          	mov    QWORD PTR [rbp-0x58],r8
  405e39:	4d 85 ff             	test   r15,r15
  405e3c:	74 4a                	je     405e88 <__cosrt_c_capmgr_rcv_create+0x78>
  405e3e:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  405e42:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  405e46:	31 c9                	xor    ecx,ecx
  405e48:	31 d2                	xor    edx,edx
  405e4a:	48 89 df             	mov    rdi,rbx
  405e4d:	41 ff d7             	call   r15
	*asnd   = asnd_ret;
  405e50:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
	*thdcap = (thdcap_t)thdret >> 16;
	*tid    = (thdid_t)thdret & 0xFFFF;
  405e54:	48 8b 5d a8          	mov    rbx,QWORD PTR [rbp-0x58]
	ret = cos_sinv_2rets(uc, idx, flags, 0, 0, &asnd_ret, &thdret);
  405e58:	48 98                	cdqe   
	*asnd   = asnd_ret;
  405e5a:	49 89 16             	mov    QWORD PTR [r14],rdx
	*thdcap = (thdcap_t)thdret >> 16;
  405e5d:	48 8b 55 b0          	mov    rdx,QWORD PTR [rbp-0x50]
  405e61:	48 89 d1             	mov    rcx,rdx
	*tid    = (thdid_t)thdret & 0xFFFF;
  405e64:	81 e2 ff ff 00 00    	and    edx,0xffff
	*thdcap = (thdcap_t)thdret >> 16;
  405e6a:	48 c1 e9 10          	shr    rcx,0x10
  405e6e:	49 89 4d 00          	mov    QWORD PTR [r13+0x0],rcx
	*tid    = (thdid_t)thdret & 0xFFFF;
  405e72:	48 89 13             	mov    QWORD PTR [rbx],rdx

	return ret;
}
  405e75:	48 83 c4 38          	add    rsp,0x38
  405e79:	5b                   	pop    rbx
  405e7a:	41 5c                	pop    r12
  405e7c:	41 5d                	pop    r13
  405e7e:	41 5e                	pop    r14
  405e80:	41 5f                	pop    r15
  405e82:	5d                   	pop    rbp
  405e83:	c3                   	ret    
  405e84:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  405e88:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  405e8c:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  405e90:	4c 89 ff             	mov    rdi,r15
  405e93:	4c 89 fa             	mov    rdx,r15
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  405e96:	83 c0 01             	add    eax,0x1
  405e99:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  405e9c:	48 89 29             	mov    QWORD PTR [rcx],rbp
  405e9f:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  405ea3:	48 89 cd             	mov    rbp,rcx
  405ea6:	49 b8 c0 5e 40 00 00 	movabs r8,0x405ec0
  405ead:	00 00 00 
  405eb0:	0f 05                	syscall 
  405eb2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  405eb8:	eb 0f                	jmp    405ec9 <__cosrt_c_capmgr_rcv_create+0xb9>
  405eba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  405ec0:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  405ec7:	eb 07                	jmp    405ed0 <__cosrt_c_capmgr_rcv_create+0xc0>
  405ec9:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  405ed0:	5d                   	pop    rbp
  405ed1:	5c                   	pop    rsp
  405ed2:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
  405ed6:	48 89 7d b0          	mov    QWORD PTR [rbp-0x50],rdi
	return ret;
  405eda:	e9 71 ff ff ff       	jmp    405e50 <__cosrt_c_capmgr_rcv_create+0x40>
  405edf:	90                   	nop

0000000000405ee0 <__cosrt_c_capmgr_shared_kernel_page_create>:

COS_CLIENT_STUB(vaddr_t, capmgr_shared_kernel_page_create, vaddr_t *resource)
{
  405ee0:	f3 0f 1e fa          	endbr64 
  405ee4:	55                   	push   rbp
  405ee5:	48 89 e5             	mov    rbp,rsp
  405ee8:	41 55                	push   r13
  405eea:	49 89 fd             	mov    r13,rdi
  405eed:	41 54                	push   r12
  405eef:	53                   	push   rbx
  405ef0:	48 83 ec 28          	sub    rsp,0x28
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  405ef4:	48 8b 58 10          	mov    rbx,QWORD PTR [rax+0x10]
  405ef8:	48 85 db             	test   rbx,rbx
  405efb:	74 2b                	je     405f28 <__cosrt_c_capmgr_shared_kernel_page_create+0x48>
  405efd:	4c 8d 4d c8          	lea    r9,[rbp-0x38]
  405f01:	4c 8d 45 c0          	lea    r8,[rbp-0x40]
  405f05:	31 c9                	xor    ecx,ecx
  405f07:	31 d2                	xor    edx,edx
  405f09:	31 f6                	xor    esi,esi
  405f0b:	31 ff                	xor    edi,edi
  405f0d:	ff d3                	call   rbx
	COS_CLIENT_INVCAP;
	word_t ret1, ret2;
	vaddr_t ret;

	ret = cos_sinv_2rets(uc, 0, 0, 0, 0, &ret1, &ret2);
	*resource   = ret1;
  405f0f:	48 8b 55 c0          	mov    rdx,QWORD PTR [rbp-0x40]
	ret = cos_sinv_2rets(uc, 0, 0, 0, 0, &ret1, &ret2);
  405f13:	48 98                	cdqe   
	*resource   = ret1;
  405f15:	49 89 55 00          	mov    QWORD PTR [r13+0x0],rdx

	return ret;
}
  405f19:	48 83 c4 28          	add    rsp,0x28
  405f1d:	5b                   	pop    rbx
  405f1e:	41 5c                	pop    r12
  405f20:	41 5d                	pop    r13
  405f22:	5d                   	pop    rbp
  405f23:	c3                   	ret    
  405f24:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  405f28:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  405f2c:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  405f30:	48 89 de             	mov    rsi,rbx
  405f33:	48 89 df             	mov    rdi,rbx
  405f36:	48 89 da             	mov    rdx,rbx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  405f39:	83 c0 01             	add    eax,0x1
  405f3c:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  405f3f:	48 89 29             	mov    QWORD PTR [rcx],rbp
  405f42:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  405f46:	48 89 cd             	mov    rbp,rcx
  405f49:	49 b8 60 5f 40 00 00 	movabs r8,0x405f60
  405f50:	00 00 00 
  405f53:	0f 05                	syscall 
  405f55:	0f 1f 00             	nop    DWORD PTR [rax]
  405f58:	eb 0f                	jmp    405f69 <__cosrt_c_capmgr_shared_kernel_page_create+0x89>
  405f5a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  405f60:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  405f67:	eb 07                	jmp    405f70 <__cosrt_c_capmgr_shared_kernel_page_create+0x90>
  405f69:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  405f70:	5d                   	pop    rbp
  405f71:	5c                   	pop    rsp
  405f72:	48 89 75 c0          	mov    QWORD PTR [rbp-0x40],rsi
	return ret;
  405f76:	eb 97                	jmp    405f0f <__cosrt_c_capmgr_shared_kernel_page_create+0x2f>
  405f78:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  405f7f:	00 

0000000000405f80 <__cosrt_c_capmgr_vm_lapic_create>:
  405f80:	f3 0f 1e fa          	endbr64 
  405f84:	55                   	push   rbp
  405f85:	48 89 e5             	mov    rbp,rsp
  405f88:	41 55                	push   r13
  405f8a:	49 89 fd             	mov    r13,rdi
  405f8d:	41 54                	push   r12
  405f8f:	53                   	push   rbx
  405f90:	48 83 ec 28          	sub    rsp,0x28
  405f94:	48 8b 58 10          	mov    rbx,QWORD PTR [rax+0x10]
  405f98:	48 85 db             	test   rbx,rbx
  405f9b:	74 2b                	je     405fc8 <__cosrt_c_capmgr_vm_lapic_create+0x48>
  405f9d:	4c 8d 4d c8          	lea    r9,[rbp-0x38]
  405fa1:	4c 8d 45 c0          	lea    r8,[rbp-0x40]
  405fa5:	31 c9                	xor    ecx,ecx
  405fa7:	31 d2                	xor    edx,edx
  405fa9:	31 f6                	xor    esi,esi
  405fab:	31 ff                	xor    edi,edi
  405fad:	ff d3                	call   rbx
  405faf:	48 8b 55 c0          	mov    rdx,QWORD PTR [rbp-0x40]
  405fb3:	48 98                	cdqe   
  405fb5:	49 89 55 00          	mov    QWORD PTR [r13+0x0],rdx
  405fb9:	48 83 c4 28          	add    rsp,0x28
  405fbd:	5b                   	pop    rbx
  405fbe:	41 5c                	pop    r12
  405fc0:	41 5d                	pop    r13
  405fc2:	5d                   	pop    rbp
  405fc3:	c3                   	ret    
  405fc4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  405fc8:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  405fcc:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  405fd0:	48 89 de             	mov    rsi,rbx
  405fd3:	48 89 df             	mov    rdi,rbx
  405fd6:	48 89 da             	mov    rdx,rbx
  405fd9:	83 c0 01             	add    eax,0x1
  405fdc:	c1 e0 10             	shl    eax,0x10
  405fdf:	48 89 29             	mov    QWORD PTR [rcx],rbp
  405fe2:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  405fe6:	48 89 cd             	mov    rbp,rcx
  405fe9:	49 b8 00 60 40 00 00 	movabs r8,0x406000
  405ff0:	00 00 00 
  405ff3:	0f 05                	syscall 
  405ff5:	0f 1f 00             	nop    DWORD PTR [rax]
  405ff8:	eb 0f                	jmp    406009 <__cosrt_c_capmgr_vm_lapic_create+0x89>
  405ffa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  406000:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  406007:	eb 07                	jmp    406010 <__cosrt_c_capmgr_vm_lapic_create+0x90>
  406009:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  406010:	5d                   	pop    rbp
  406011:	5c                   	pop    rsp
  406012:	48 89 75 c0          	mov    QWORD PTR [rbp-0x40],rsi
  406016:	eb 97                	jmp    405faf <__cosrt_c_capmgr_vm_lapic_create+0x2f>
  406018:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40601f:	00 

0000000000406020 <__cosrt_c_capmgr_vm_shared_region_create>:
  406020:	f3 0f 1e fa          	endbr64 
  406024:	55                   	push   rbp
  406025:	48 89 e5             	mov    rbp,rsp
  406028:	41 55                	push   r13
  40602a:	49 89 fd             	mov    r13,rdi
  40602d:	41 54                	push   r12
  40602f:	53                   	push   rbx
  406030:	48 83 ec 28          	sub    rsp,0x28
  406034:	48 8b 58 10          	mov    rbx,QWORD PTR [rax+0x10]
  406038:	48 85 db             	test   rbx,rbx
  40603b:	74 2b                	je     406068 <__cosrt_c_capmgr_vm_shared_region_create+0x48>
  40603d:	4c 8d 4d c8          	lea    r9,[rbp-0x38]
  406041:	4c 8d 45 c0          	lea    r8,[rbp-0x40]
  406045:	31 c9                	xor    ecx,ecx
  406047:	31 d2                	xor    edx,edx
  406049:	31 f6                	xor    esi,esi
  40604b:	31 ff                	xor    edi,edi
  40604d:	ff d3                	call   rbx
  40604f:	48 8b 55 c0          	mov    rdx,QWORD PTR [rbp-0x40]
  406053:	48 98                	cdqe   
  406055:	49 89 55 00          	mov    QWORD PTR [r13+0x0],rdx
  406059:	48 83 c4 28          	add    rsp,0x28
  40605d:	5b                   	pop    rbx
  40605e:	41 5c                	pop    r12
  406060:	41 5d                	pop    r13
  406062:	5d                   	pop    rbp
  406063:	c3                   	ret    
  406064:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  406068:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  40606c:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  406070:	48 89 de             	mov    rsi,rbx
  406073:	48 89 df             	mov    rdi,rbx
  406076:	48 89 da             	mov    rdx,rbx
  406079:	83 c0 01             	add    eax,0x1
  40607c:	c1 e0 10             	shl    eax,0x10
  40607f:	48 89 29             	mov    QWORD PTR [rcx],rbp
  406082:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  406086:	48 89 cd             	mov    rbp,rcx
  406089:	49 b8 a0 60 40 00 00 	movabs r8,0x4060a0
  406090:	00 00 00 
  406093:	0f 05                	syscall 
  406095:	0f 1f 00             	nop    DWORD PTR [rax]
  406098:	eb 0f                	jmp    4060a9 <__cosrt_c_capmgr_vm_shared_region_create+0x89>
  40609a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4060a0:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  4060a7:	eb 07                	jmp    4060b0 <__cosrt_c_capmgr_vm_shared_region_create+0x90>
  4060a9:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  4060b0:	5d                   	pop    rbp
  4060b1:	5c                   	pop    rsp
  4060b2:	48 89 75 c0          	mov    QWORD PTR [rbp-0x40],rsi
  4060b6:	eb 97                	jmp    40604f <__cosrt_c_capmgr_vm_shared_region_create+0x2f>
  4060b8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4060bf:	00 

00000000004060c0 <__cosrt_c_capmgr_vm_vcpu_create>:

	return ret;
}

COS_CLIENT_STUB(thdcap_t, capmgr_vm_vcpu_create, compid_t vm_comp, vm_vmcb_t vmcb_cap, thdid_t *tid)
{
  4060c0:	f3 0f 1e fa          	endbr64 
  4060c4:	55                   	push   rbp
  4060c5:	48 89 e5             	mov    rbp,rsp
  4060c8:	41 57                	push   r15
  4060ca:	49 89 d7             	mov    r15,rdx
  4060cd:	41 56                	push   r14
  4060cf:	41 55                	push   r13
  4060d1:	41 54                	push   r12
  4060d3:	53                   	push   rbx
  4060d4:	48 83 ec 28          	sub    rsp,0x28
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  4060d8:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  4060dc:	4d 85 f6             	test   r14,r14
  4060df:	74 2f                	je     406110 <__cosrt_c_capmgr_vm_vcpu_create+0x50>
  4060e1:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  4060e5:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  4060e9:	31 c9                	xor    ecx,ecx
  4060eb:	31 d2                	xor    edx,edx
  4060ed:	41 ff d6             	call   r14
	COS_CLIENT_INVCAP;
	word_t unused, tid_ret;
	thdcap_t ret;

	ret = cos_sinv_2rets(uc, vm_comp, vmcb_cap, 0, 0, &tid_ret, &unused);
	*tid = tid_ret;
  4060f0:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
	ret = cos_sinv_2rets(uc, vm_comp, vmcb_cap, 0, 0, &tid_ret, &unused);
  4060f4:	48 98                	cdqe   
	*tid = tid_ret;
  4060f6:	49 89 17             	mov    QWORD PTR [r15],rdx

	return ret;
}
  4060f9:	48 83 c4 28          	add    rsp,0x28
  4060fd:	5b                   	pop    rbx
  4060fe:	41 5c                	pop    r12
  406100:	41 5d                	pop    r13
  406102:	41 5e                	pop    r14
  406104:	41 5f                	pop    r15
  406106:	5d                   	pop    rbp
  406107:	c3                   	ret    
  406108:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40610f:	00 
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  406110:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  406114:	48 89 fb             	mov    rbx,rdi
  406117:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  40611b:	4c 89 f7             	mov    rdi,r14
  40611e:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  406121:	83 c0 01             	add    eax,0x1
  406124:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  406127:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40612a:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40612e:	48 89 cd             	mov    rbp,rcx
  406131:	49 b8 48 61 40 00 00 	movabs r8,0x406148
  406138:	00 00 00 
  40613b:	0f 05                	syscall 
  40613d:	0f 1f 00             	nop    DWORD PTR [rax]
  406140:	eb 0f                	jmp    406151 <__cosrt_c_capmgr_vm_vcpu_create+0x91>
  406142:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  406148:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  40614f:	eb 07                	jmp    406158 <__cosrt_c_capmgr_vm_vcpu_create+0x98>
  406151:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  406158:	5d                   	pop    rbp
  406159:	5c                   	pop    rsp
  40615a:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  40615e:	eb 90                	jmp    4060f0 <__cosrt_c_capmgr_vm_vcpu_create+0x30>

0000000000406160 <__cosrt_c_capmgr_initthd_create>:

COS_CLIENT_STUB(thdcap_t, capmgr_initthd_create, spdid_t child, thdid_t *tid)
{
  406160:	f3 0f 1e fa          	endbr64 
  406164:	55                   	push   rbp
  406165:	48 89 e5             	mov    rbp,rsp
  406168:	41 57                	push   r15
	COS_CLIENT_INVCAP;
	word_t unused, tid_ret;
	thdcap_t ret;

	ret = cos_sinv_2rets(uc, child, 0, 0, 0, &tid_ret, &unused);
  40616a:	44 0f b7 ff          	movzx  r15d,di
{
  40616e:	41 56                	push   r14
  406170:	41 55                	push   r13
  406172:	49 89 f5             	mov    r13,rsi
  406175:	41 54                	push   r12
  406177:	53                   	push   rbx
  406178:	48 83 ec 28          	sub    rsp,0x28
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  40617c:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  406180:	4d 85 f6             	test   r14,r14
  406183:	74 33                	je     4061b8 <__cosrt_c_capmgr_initthd_create+0x58>
  406185:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  406189:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  40618d:	31 c9                	xor    ecx,ecx
  40618f:	31 d2                	xor    edx,edx
  406191:	31 f6                	xor    esi,esi
  406193:	4c 89 ff             	mov    rdi,r15
  406196:	41 ff d6             	call   r14
	*tid = tid_ret;
  406199:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
	ret = cos_sinv_2rets(uc, child, 0, 0, 0, &tid_ret, &unused);
  40619d:	48 98                	cdqe   
	*tid = tid_ret;
  40619f:	49 89 55 00          	mov    QWORD PTR [r13+0x0],rdx

	return ret;
}
  4061a3:	48 83 c4 28          	add    rsp,0x28
  4061a7:	5b                   	pop    rbx
  4061a8:	41 5c                	pop    r12
  4061aa:	41 5d                	pop    r13
  4061ac:	41 5e                	pop    r14
  4061ae:	41 5f                	pop    r15
  4061b0:	5d                   	pop    rbp
  4061b1:	c3                   	ret    
  4061b2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  4061b8:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  4061bc:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  4061c0:	4c 89 fb             	mov    rbx,r15
  4061c3:	4c 89 f6             	mov    rsi,r14
  4061c6:	4c 89 f7             	mov    rdi,r14
  4061c9:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4061cc:	83 c0 01             	add    eax,0x1
  4061cf:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  4061d2:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4061d5:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4061d9:	48 89 cd             	mov    rbp,rcx
  4061dc:	49 b8 f0 61 40 00 00 	movabs r8,0x4061f0
  4061e3:	00 00 00 
  4061e6:	0f 05                	syscall 
  4061e8:	eb 0f                	jmp    4061f9 <__cosrt_c_capmgr_initthd_create+0x99>
  4061ea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4061f0:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  4061f7:	eb 07                	jmp    406200 <__cosrt_c_capmgr_initthd_create+0xa0>
  4061f9:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  406200:	5d                   	pop    rbp
  406201:	5c                   	pop    rsp
  406202:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  406206:	eb 91                	jmp    406199 <__cosrt_c_capmgr_initthd_create+0x39>
  406208:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40620f:	00 

0000000000406210 <__cosrt_c_capmgr_thd_create_thunk>:

COS_CLIENT_STUB(thdcap_t, capmgr_thd_create_thunk, thdclosure_index_t id, thdid_t *tid)
{
  406210:	f3 0f 1e fa          	endbr64 
  406214:	55                   	push   rbp
  406215:	48 89 e5             	mov    rbp,rsp
  406218:	41 57                	push   r15
	COS_CLIENT_INVCAP;
	word_t unused, tid_ret;
	thdcap_t ret;

	ret = cos_sinv_2rets(uc, id, 0, 0, 0, &tid_ret, &unused);
  40621a:	4c 63 ff             	movsxd r15,edi
{
  40621d:	41 56                	push   r14
  40621f:	41 55                	push   r13
  406221:	49 89 f5             	mov    r13,rsi
  406224:	41 54                	push   r12
  406226:	53                   	push   rbx
  406227:	48 83 ec 28          	sub    rsp,0x28
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  40622b:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  40622f:	4d 85 f6             	test   r14,r14
  406232:	74 34                	je     406268 <__cosrt_c_capmgr_thd_create_thunk+0x58>
  406234:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  406238:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  40623c:	31 c9                	xor    ecx,ecx
  40623e:	31 d2                	xor    edx,edx
  406240:	31 f6                	xor    esi,esi
  406242:	4c 89 ff             	mov    rdi,r15
  406245:	41 ff d6             	call   r14
	*tid = tid_ret;
  406248:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
	ret = cos_sinv_2rets(uc, id, 0, 0, 0, &tid_ret, &unused);
  40624c:	48 98                	cdqe   
	*tid = tid_ret;
  40624e:	49 89 55 00          	mov    QWORD PTR [r13+0x0],rdx

	return ret;
}
  406252:	48 83 c4 28          	add    rsp,0x28
  406256:	5b                   	pop    rbx
  406257:	41 5c                	pop    r12
  406259:	41 5d                	pop    r13
  40625b:	41 5e                	pop    r14
  40625d:	41 5f                	pop    r15
  40625f:	5d                   	pop    rbp
  406260:	c3                   	ret    
  406261:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  406268:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  40626c:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  406270:	4c 89 fb             	mov    rbx,r15
  406273:	4c 89 f6             	mov    rsi,r14
  406276:	4c 89 f7             	mov    rdi,r14
  406279:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40627c:	83 c0 01             	add    eax,0x1
  40627f:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  406282:	48 89 29             	mov    QWORD PTR [rcx],rbp
  406285:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  406289:	48 89 cd             	mov    rbp,rcx
  40628c:	49 b8 a0 62 40 00 00 	movabs r8,0x4062a0
  406293:	00 00 00 
  406296:	0f 05                	syscall 
  406298:	eb 0f                	jmp    4062a9 <__cosrt_c_capmgr_thd_create_thunk+0x99>
  40629a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4062a0:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  4062a7:	eb 07                	jmp    4062b0 <__cosrt_c_capmgr_thd_create_thunk+0xa0>
  4062a9:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  4062b0:	5d                   	pop    rbp
  4062b1:	5c                   	pop    rsp
  4062b2:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  4062b6:	eb 90                	jmp    406248 <__cosrt_c_capmgr_thd_create_thunk+0x38>
  4062b8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4062bf:	00 

00000000004062c0 <__cosrt_c_capmgr_thd_create_ext>:

COS_CLIENT_STUB(thdcap_t, capmgr_thd_create_ext, spdid_t child, thdclosure_index_t idx, thdid_t *tid)
{
  4062c0:	f3 0f 1e fa          	endbr64 
  4062c4:	55                   	push   rbp
	COS_CLIENT_INVCAP;
	word_t unused, tid_ret;
	thdcap_t ret;

	ret = cos_sinv_2rets(uc, child, idx, 0, 0, &tid_ret, &unused);
  4062c5:	48 63 f6             	movsxd rsi,esi
{
  4062c8:	48 89 e5             	mov    rbp,rsp
  4062cb:	41 57                	push   r15
  4062cd:	49 89 d7             	mov    r15,rdx
  4062d0:	41 56                	push   r14
  4062d2:	41 55                	push   r13
	ret = cos_sinv_2rets(uc, child, idx, 0, 0, &tid_ret, &unused);
  4062d4:	44 0f b7 ef          	movzx  r13d,di
{
  4062d8:	41 54                	push   r12
  4062da:	53                   	push   rbx
  4062db:	48 83 ec 28          	sub    rsp,0x28
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  4062df:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  4062e3:	4d 85 f6             	test   r14,r14
  4062e6:	74 30                	je     406318 <__cosrt_c_capmgr_thd_create_ext+0x58>
  4062e8:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  4062ec:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  4062f0:	31 c9                	xor    ecx,ecx
  4062f2:	31 d2                	xor    edx,edx
  4062f4:	4c 89 ef             	mov    rdi,r13
  4062f7:	41 ff d6             	call   r14
	*tid = tid_ret;
  4062fa:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
	ret = cos_sinv_2rets(uc, child, idx, 0, 0, &tid_ret, &unused);
  4062fe:	48 98                	cdqe   
	*tid = tid_ret;
  406300:	49 89 17             	mov    QWORD PTR [r15],rdx

	return ret;
}
  406303:	48 83 c4 28          	add    rsp,0x28
  406307:	5b                   	pop    rbx
  406308:	41 5c                	pop    r12
  40630a:	41 5d                	pop    r13
  40630c:	41 5e                	pop    r14
  40630e:	41 5f                	pop    r15
  406310:	5d                   	pop    rbp
  406311:	c3                   	ret    
  406312:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  406318:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  40631c:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  406320:	4c 89 eb             	mov    rbx,r13
  406323:	4c 89 f7             	mov    rdi,r14
  406326:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  406329:	83 c0 01             	add    eax,0x1
  40632c:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40632f:	48 89 29             	mov    QWORD PTR [rcx],rbp
  406332:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  406336:	48 89 cd             	mov    rbp,rcx
  406339:	49 b8 50 63 40 00 00 	movabs r8,0x406350
  406340:	00 00 00 
  406343:	0f 05                	syscall 
  406345:	0f 1f 00             	nop    DWORD PTR [rax]
  406348:	eb 0f                	jmp    406359 <__cosrt_c_capmgr_thd_create_ext+0x99>
  40634a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  406350:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  406357:	eb 07                	jmp    406360 <__cosrt_c_capmgr_thd_create_ext+0xa0>
  406359:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  406360:	5d                   	pop    rbp
  406361:	5c                   	pop    rsp
  406362:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  406366:	eb 92                	jmp    4062fa <__cosrt_c_capmgr_thd_create_ext+0x3a>
  406368:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40636f:	00 

0000000000406370 <__cosrt_c_capmgr_aep_create_thunk>:

COS_CLIENT_STUB(thdcap_t, capmgr_aep_create_thunk, struct cos_aep_info *aep, thdclosure_index_t idx, int owntc, cos_channelkey_t key, microsec_t ipiwin, u32_t ipimax)
{
  406370:	f3 0f 1e fa          	endbr64 
  406374:	55                   	push   rbp
  406375:	48 89 e5             	mov    rbp,rsp
  406378:	41 57                	push   r15
  40637a:	41 56                	push   r14
  40637c:	41 55                	push   r13
  40637e:	41 54                	push   r12
  406380:	53                   	push   rbx
  406381:	48 83 ec 28          	sub    rsp,0x28
	COS_CLIENT_INVCAP;
	word_t tcrcvret   = 0;
  406385:	48 c7 45 b0 00 00 00 	mov    QWORD PTR [rbp-0x50],0x0
  40638c:	00 
	thdcap_t thd     = 0;
	thdid_t tid      = 0;
  40638d:	48 c7 45 b8 00 00 00 	mov    QWORD PTR [rbp-0x48],0x0
  406394:	00 
	u32_t owntc_idx  = (owntc << 16) | idx;
	u32_t key_ipimax = (key << 16) | ((ipimax << 16) >> 16);
	u32_t ipiwin32b  = (u32_t)ipiwin;

	if (idx < 1) return 0;
  406395:	85 f6                	test   esi,esi
  406397:	0f 8e 93 00 00 00    	jle    406430 <__cosrt_c_capmgr_aep_create_thunk+0xc0>
  40639d:	41 89 d5             	mov    r13d,edx
	u32_t key_ipimax = (key << 16) | ((ipimax << 16) >> 16);
  4063a0:	c1 e1 10             	shl    ecx,0x10
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  4063a3:	4c 8b 78 10          	mov    r15,QWORD PTR [rax+0x10]
  4063a7:	41 89 f2             	mov    r10d,esi
  4063aa:	45 0f b7 c9          	movzx  r9d,r9w

	thd = cos_sinv_2rets(uc, owntc_idx, key_ipimax, ipiwin32b, 0, &tid, &tcrcvret);
  4063ae:	89 ce                	mov    esi,ecx
	u32_t owntc_idx  = (owntc << 16) | idx;
  4063b0:	41 c1 e5 10          	shl    r13d,0x10
  4063b4:	49 89 fe             	mov    r14,rdi
	thd = cos_sinv_2rets(uc, owntc_idx, key_ipimax, ipiwin32b, 0, &tid, &tcrcvret);
  4063b7:	44 09 ce             	or     esi,r9d
  4063ba:	44 89 c7             	mov    edi,r8d
  4063bd:	45 09 d5             	or     r13d,r10d
  4063c0:	4d 85 ff             	test   r15,r15
  4063c3:	0f 84 7f 00 00 00    	je     406448 <__cosrt_c_capmgr_aep_create_thunk+0xd8>
  4063c9:	48 89 fa             	mov    rdx,rdi
  4063cc:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  4063d0:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  4063d4:	31 c9                	xor    ecx,ecx
  4063d6:	4c 89 ef             	mov    rdi,r13
  4063d9:	41 ff d7             	call   r15
  4063dc:	48 98                	cdqe   
	if (!thd) return 0;
  4063de:	48 85 c0             	test   rax,rax
  4063e1:	74 3a                	je     40641d <__cosrt_c_capmgr_aep_create_thunk+0xad>

	aep->thd  = thd;
	aep->rcv  = (tcrcvret << 16) >> 16;
  4063e3:	48 8b 55 b0          	mov    rdx,QWORD PTR [rbp-0x50]
	aep->tc   = (tcrcvret >> 16);
	aep->tid  = tid;
  4063e7:	f3 0f 7e 4d b8       	movq   xmm1,QWORD PTR [rbp-0x48]
	aep->tc   = (tcrcvret >> 16);
  4063ec:	66 48 0f 6e d8       	movq   xmm3,rax
	aep->rcv  = (tcrcvret << 16) >> 16;
  4063f1:	48 b9 ff ff ff ff ff 	movabs rcx,0xffffffffffff
  4063f8:	ff 00 00 
  4063fb:	48 21 d1             	and    rcx,rdx
	aep->tc   = (tcrcvret >> 16);
  4063fe:	48 c1 ea 10          	shr    rdx,0x10
  406402:	66 48 0f 6e d1       	movq   xmm2,rcx
  406407:	66 48 0f 6e c2       	movq   xmm0,rdx
  40640c:	66 0f 6c ca          	punpcklqdq xmm1,xmm2
  406410:	66 0f 6c c3          	punpcklqdq xmm0,xmm3
  406414:	41 0f 11 06          	movups XMMWORD PTR [r14],xmm0
  406418:	41 0f 11 4e 10       	movups XMMWORD PTR [r14+0x10],xmm1

	return thd;
}
  40641d:	48 83 c4 28          	add    rsp,0x28
  406421:	5b                   	pop    rbx
  406422:	41 5c                	pop    r12
  406424:	41 5d                	pop    r13
  406426:	41 5e                	pop    r14
  406428:	41 5f                	pop    r15
  40642a:	5d                   	pop    rbp
  40642b:	c3                   	ret    
  40642c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  406430:	48 83 c4 28          	add    rsp,0x28
	if (idx < 1) return 0;
  406434:	31 c0                	xor    eax,eax
}
  406436:	5b                   	pop    rbx
  406437:	41 5c                	pop    r12
  406439:	41 5d                	pop    r13
  40643b:	41 5e                	pop    r14
  40643d:	41 5f                	pop    r15
  40643f:	5d                   	pop    rbp
  406440:	c3                   	ret    
  406441:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  406448:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  40644c:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  406450:	4c 89 eb             	mov    rbx,r13
  406453:	4c 89 fa             	mov    rdx,r15
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  406456:	83 c0 01             	add    eax,0x1
  406459:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40645c:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40645f:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  406463:	48 89 cd             	mov    rbp,rcx
  406466:	49 b8 80 64 40 00 00 	movabs r8,0x406480
  40646d:	00 00 00 
  406470:	0f 05                	syscall 
  406472:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  406478:	eb 0f                	jmp    406489 <__cosrt_c_capmgr_aep_create_thunk+0x119>
  40647a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  406480:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  406487:	eb 07                	jmp    406490 <__cosrt_c_capmgr_aep_create_thunk+0x120>
  406489:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  406490:	5d                   	pop    rbp
  406491:	5c                   	pop    rsp
  406492:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
  406496:	48 89 7d b0          	mov    QWORD PTR [rbp-0x50],rdi
	return ret;
  40649a:	e9 3d ff ff ff       	jmp    4063dc <__cosrt_c_capmgr_aep_create_thunk+0x6c>
  40649f:	90                   	nop

00000000004064a0 <__cosrt_c_capmgr_aep_create_ext>:

COS_CLIENT_STUB(thdcap_t, capmgr_aep_create_ext, spdid_t child, struct cos_aep_info *aep, thdclosure_index_t idx, int owntc, cos_channelkey_t key, microsec_t ipiwin, u32_t ipimax, arcvcap_t *extrcv)
{
  4064a0:	f3 0f 1e fa          	endbr64 
  4064a4:	55                   	push   rbp
	COS_CLIENT_INVCAP;
	word_t drcvtidret  = 0;
	word_t tcrcvret    = 0;
	thdcap_t thd       = 0;
	u32_t spdid_thdidx = (child << 16) | ((idx << 16) >> 16);
	u32_t key_ipimax   = (key << 16) | ((ipimax << 16) >> 16);
  4064a5:	41 c1 e0 10          	shl    r8d,0x10
	u32_t spdid_thdidx = (child << 16) | ((idx << 16) >> 16);
  4064a9:	c1 e7 10             	shl    edi,0x10
{
  4064ac:	48 89 e5             	mov    rbp,rsp
  4064af:	41 57                	push   r15
  4064b1:	41 89 d7             	mov    r15d,edx
  4064b4:	44 89 ca             	mov    edx,r9d
  4064b7:	41 56                	push   r14
	u32_t spdid_thdidx = (child << 16) | ((idx << 16) >> 16);
  4064b9:	45 0f bf ff          	movsx  r15d,r15w
	u32_t ipiwin32b    = (u32_t)ipiwin;

	thd = cos_sinv_2rets(uc, spdid_thdidx, owntc, key_ipimax, ipiwin32b, &drcvtidret, &tcrcvret);
  4064bd:	45 89 c6             	mov    r14d,r8d
{
  4064c0:	41 55                	push   r13
  4064c2:	49 89 f5             	mov    r13,rsi
	thd = cos_sinv_2rets(uc, spdid_thdidx, owntc, key_ipimax, ipiwin32b, &drcvtidret, &tcrcvret);
  4064c5:	41 09 ff             	or     r15d,edi
{
  4064c8:	41 54                	push   r12
  4064ca:	53                   	push   rbx
  4064cb:	48 83 ec 28          	sub    rsp,0x28
	u32_t key_ipimax   = (key << 16) | ((ipimax << 16) >> 16);
  4064cf:	0f b7 75 10          	movzx  esi,WORD PTR [rbp+0x10]
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  4064d3:	4c 8b 50 10          	mov    r10,QWORD PTR [rax+0x10]
	word_t drcvtidret  = 0;
  4064d7:	48 c7 45 b0 00 00 00 	mov    QWORD PTR [rbp-0x50],0x0
  4064de:	00 
	word_t tcrcvret    = 0;
  4064df:	48 c7 45 b8 00 00 00 	mov    QWORD PTR [rbp-0x48],0x0
  4064e6:	00 
	thd = cos_sinv_2rets(uc, spdid_thdidx, owntc, key_ipimax, ipiwin32b, &drcvtidret, &tcrcvret);
  4064e7:	41 09 f6             	or     r14d,esi
  4064ea:	48 63 f1             	movsxd rsi,ecx
  4064ed:	4d 85 d2             	test   r10,r10
  4064f0:	0f 84 8a 00 00 00    	je     406580 <__cosrt_c_capmgr_aep_create_ext+0xe0>
  4064f6:	48 89 d1             	mov    rcx,rdx
  4064f9:	4c 8d 4d b8          	lea    r9,[rbp-0x48]
  4064fd:	4c 8d 45 b0          	lea    r8,[rbp-0x50]
  406501:	4c 89 f2             	mov    rdx,r14
  406504:	4c 89 ff             	mov    rdi,r15
  406507:	41 ff d2             	call   r10
  40650a:	48 98                	cdqe   
	if (!thd) return thd;
  40650c:	48 85 c0             	test   rax,rax
  40650f:	74 60                	je     406571 <__cosrt_c_capmgr_aep_create_ext+0xd1>

	aep->fn   = NULL;
	aep->data = NULL;
	aep->thd  = thd;
	aep->tid  = (drcvtidret << 16) >> 16;
	aep->rcv  = tcrcvret >> 16;
  406511:	48 8b 75 b8          	mov    rsi,QWORD PTR [rbp-0x48]
	aep->tid  = (drcvtidret << 16) >> 16;
  406515:	48 8b 4d b0          	mov    rcx,QWORD PTR [rbp-0x50]
	aep->tc   = (tcrcvret << 16) >> 16;
  406519:	48 ba ff ff ff ff ff 	movabs rdx,0xffffffffffff
  406520:	ff 00 00 
  406523:	66 48 0f 6e c8       	movq   xmm1,rax
	aep->fn   = NULL;
  406528:	49 c7 45 20 00 00 00 	mov    QWORD PTR [r13+0x20],0x0
  40652f:	00 
	aep->tc   = (tcrcvret << 16) >> 16;
  406530:	48 89 f3             	mov    rbx,rsi
	aep->rcv  = tcrcvret >> 16;
  406533:	48 c1 ee 10          	shr    rsi,0x10
	aep->data = NULL;
  406537:	49 c7 45 28 00 00 00 	mov    QWORD PTR [r13+0x28],0x0
  40653e:	00 
	aep->tc   = (tcrcvret << 16) >> 16;
  40653f:	48 21 d3             	and    rbx,rdx
	aep->tid  = (drcvtidret << 16) >> 16;
  406542:	48 21 ca             	and    rdx,rcx
	aep->tc   = (tcrcvret << 16) >> 16;
  406545:	66 48 0f 6e d6       	movq   xmm2,rsi
	*extrcv   = drcvtidret >> 16;
  40654a:	48 c1 e9 10          	shr    rcx,0x10
	aep->tc   = (tcrcvret << 16) >> 16;
  40654e:	66 48 0f 6e c3       	movq   xmm0,rbx
  406553:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  406557:	41 0f 11 45 00       	movups XMMWORD PTR [r13+0x0],xmm0
  40655c:	66 48 0f 6e c2       	movq   xmm0,rdx
	*extrcv   = drcvtidret >> 16;
  406561:	48 8b 55 18          	mov    rdx,QWORD PTR [rbp+0x18]
	aep->tc   = (tcrcvret << 16) >> 16;
  406565:	66 0f 6c c2          	punpcklqdq xmm0,xmm2
  406569:	41 0f 11 45 10       	movups XMMWORD PTR [r13+0x10],xmm0
	*extrcv   = drcvtidret >> 16;
  40656e:	48 89 0a             	mov    QWORD PTR [rdx],rcx

	return thd;
}
  406571:	48 83 c4 28          	add    rsp,0x28
  406575:	5b                   	pop    rbx
  406576:	41 5c                	pop    r12
  406578:	41 5d                	pop    r13
  40657a:	41 5e                	pop    r14
  40657c:	41 5f                	pop    r15
  40657e:	5d                   	pop    rbp
  40657f:	c3                   	ret    
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  406580:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  406584:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  406588:	4c 89 fb             	mov    rbx,r15
  40658b:	4c 89 f7             	mov    rdi,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40658e:	83 c0 01             	add    eax,0x1
  406591:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  406594:	48 89 29             	mov    QWORD PTR [rcx],rbp
  406597:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40659b:	48 89 cd             	mov    rbp,rcx
  40659e:	49 b8 b8 65 40 00 00 	movabs r8,0x4065b8
  4065a5:	00 00 00 
  4065a8:	0f 05                	syscall 
  4065aa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4065b0:	eb 0f                	jmp    4065c1 <__cosrt_c_capmgr_aep_create_ext+0x121>
  4065b2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4065b8:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  4065bf:	eb 07                	jmp    4065c8 <__cosrt_c_capmgr_aep_create_ext+0x128>
  4065c1:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  4065c8:	5d                   	pop    rbp
  4065c9:	5c                   	pop    rsp
  4065ca:	48 89 75 b0          	mov    QWORD PTR [rbp-0x50],rsi
  4065ce:	48 89 7d b8          	mov    QWORD PTR [rbp-0x48],rdi
	return ret;
  4065d2:	e9 33 ff ff ff       	jmp    40650a <__cosrt_c_capmgr_aep_create_ext+0x6a>
  4065d7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  4065de:	00 00 

00000000004065e0 <__cosrt_c_capmgr_vm_vmcb_create>:

COS_CLIENT_STUB(capid_t, capmgr_vm_vmcb_create, vm_vmcscap_t vmcs_cap, vm_msrbitmapcap_t msr_bitmap_cap, vm_lapicaccesscap_t lapic_access_cap, vm_lapiccap_t lapic_cap, vm_shared_mem_t shared_mem_cap, thdid_t handler_thd_id, word_t vpid)
{
  4065e0:	f3 0f 1e fa          	endbr64 
  4065e4:	55                   	push   rbp

	/* FIXME: MPK call gate make indirect call complicated, arguments passed via stack gets wrong, walk around now by avoiding pass that argument */
	vpid = handler_thd_id & 0xFFFF;
	handler_thd_id = (handler_thd_id >> 16) & 0xFFFF;

	arg1 = 0 | vmcs_cap << (16 * 1) | msr_bitmap_cap << (16 * 2) |  lapic_access_cap << (16 * 3);
  4065e5:	48 c1 e2 30          	shl    rdx,0x30
  4065e9:	48 c1 e6 20          	shl    rsi,0x20
  4065ed:	48 c1 e7 10          	shl    rdi,0x10
  4065f1:	48 09 d6             	or     rsi,rdx
	arg2 = lapic_cap | shared_mem_cap << (16 * 1) | handler_thd_id << (16 * 2) | vpid << (16 * 3);
  4065f4:	49 c1 e0 10          	shl    r8,0x10
  4065f8:	4c 89 ca             	mov    rdx,r9
  4065fb:	48 c1 e2 30          	shl    rdx,0x30
	arg1 = 0 | vmcs_cap << (16 * 1) | msr_bitmap_cap << (16 * 2) |  lapic_access_cap << (16 * 3);
  4065ff:	48 09 fe             	or     rsi,rdi
	arg2 = lapic_cap | shared_mem_cap << (16 * 1) | handler_thd_id << (16 * 2) | vpid << (16 * 3);
  406602:	49 09 c8             	or     r8,rcx
  406605:	49 c1 e1 10          	shl    r9,0x10
{
  406609:	48 89 e5             	mov    rbp,rsp
  40660c:	41 56                	push   r14
  40660e:	41 55                	push   r13
	arg1 = 0 | vmcs_cap << (16 * 1) | msr_bitmap_cap << (16 * 2) |  lapic_access_cap << (16 * 3);
  406610:	49 89 f5             	mov    r13,rsi
	arg2 = lapic_cap | shared_mem_cap << (16 * 1) | handler_thd_id << (16 * 2) | vpid << (16 * 3);
  406613:	4c 89 c6             	mov    rsi,r8
{
  406616:	41 54                	push   r12
	arg2 = lapic_cap | shared_mem_cap << (16 * 1) | handler_thd_id << (16 * 2) | vpid << (16 * 3);
  406618:	48 09 d6             	or     rsi,rdx
  40661b:	48 ba 00 00 00 00 ff 	movabs rdx,0xffff00000000
  406622:	ff 00 00 
{
  406625:	53                   	push   rbx
	arg2 = lapic_cap | shared_mem_cap << (16 * 1) | handler_thd_id << (16 * 2) | vpid << (16 * 3);
  406626:	49 21 d1             	and    r9,rdx
  406629:	4c 09 ce             	or     rsi,r9
{
  40662c:	48 83 ec 20          	sub    rsp,0x20
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  406630:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
	word_t ret1 = 0;
  406634:	48 c7 45 c0 00 00 00 	mov    QWORD PTR [rbp-0x40],0x0
  40663b:	00 
	word_t ret2 = 0;
  40663c:	48 c7 45 c8 00 00 00 	mov    QWORD PTR [rbp-0x38],0x0
  406643:	00 
  406644:	4d 85 f6             	test   r14,r14
  406647:	74 27                	je     406670 <__cosrt_c_capmgr_vm_vmcb_create+0x90>
  406649:	4c 8d 4d c8          	lea    r9,[rbp-0x38]
  40664d:	4c 8d 45 c0          	lea    r8,[rbp-0x40]
  406651:	4c 89 ef             	mov    rdi,r13
  406654:	31 c9                	xor    ecx,ecx
  406656:	31 d2                	xor    edx,edx
  406658:	41 ff d6             	call   r14
	cap = cos_sinv_2rets(uc, arg1, arg2, 0, 0, &ret1, &ret2);

	return cap;
}
  40665b:	48 83 c4 20          	add    rsp,0x20
  40665f:	5b                   	pop    rbx
	cap = cos_sinv_2rets(uc, arg1, arg2, 0, 0, &ret1, &ret2);
  406660:	48 98                	cdqe   
}
  406662:	41 5c                	pop    r12
  406664:	41 5d                	pop    r13
  406666:	41 5e                	pop    r14
  406668:	5d                   	pop    rbp
  406669:	c3                   	ret    
  40666a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  406670:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  406674:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  406678:	4c 89 eb             	mov    rbx,r13
  40667b:	4c 89 f7             	mov    rdi,r14
  40667e:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  406681:	83 c0 01             	add    eax,0x1
  406684:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  406687:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40668a:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40668e:	48 89 cd             	mov    rbp,rcx
  406691:	49 b8 a8 66 40 00 00 	movabs r8,0x4066a8
  406698:	00 00 00 
  40669b:	0f 05                	syscall 
  40669d:	0f 1f 00             	nop    DWORD PTR [rax]
  4066a0:	eb 0f                	jmp    4066b1 <__cosrt_c_capmgr_vm_vmcb_create+0xd1>
  4066a2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4066a8:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  4066af:	eb 07                	jmp    4066b8 <__cosrt_c_capmgr_vm_vmcb_create+0xd8>
  4066b1:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  4066b8:	5d                   	pop    rbp
  4066b9:	5c                   	pop    rsp
  4066ba:	48 83 c4 20          	add    rsp,0x20
	cap = cos_sinv_2rets(uc, arg1, arg2, 0, 0, &ret1, &ret2);
  4066be:	48 98                	cdqe   
}
  4066c0:	5b                   	pop    rbx
  4066c1:	41 5c                	pop    r12
  4066c3:	41 5d                	pop    r13
  4066c5:	41 5e                	pop    r14
  4066c7:	5d                   	pop    rbp
  4066c8:	c3                   	ret    
  4066c9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

00000000004066d0 <__cosrt_c_capmgr_initaep_create>:

COS_CLIENT_STUB(thdcap_t, capmgr_initaep_create, spdid_t child, struct cos_aep_info *aep, int owntc, cos_channelkey_t key, microsec_t ipiwin, u32_t ipimax, asndcap_t *snd)
{
  4066d0:	f3 0f 1e fa          	endbr64 
  4066d4:	55                   	push   rbp
	COS_CLIENT_INVCAP;
	u32_t child_owntc = (child << 16) | owntc;
	u32_t key_ipimax  = (key << 16) >> ipimax;
  4066d5:	c1 e1 10             	shl    ecx,0x10
	u32_t child_owntc = (child << 16) | owntc;
  4066d8:	c1 e7 10             	shl    edi,0x10
{
  4066db:	48 89 e5             	mov    rbp,rsp
  4066de:	41 57                	push   r15
  4066e0:	41 56                	push   r14
	u32_t child_owntc = (child << 16) | owntc;
  4066e2:	41 89 fe             	mov    r14d,edi
{
  4066e5:	41 55                	push   r13
  4066e7:	49 89 f5             	mov    r13,rsi
	u32_t key_ipimax  = (key << 16) >> ipimax;
  4066ea:	89 ce                	mov    esi,ecx
	u32_t ipiwin32b   = (u32_t)ipiwin;
	thdcap_t thd = 0;
	word_t sndtidret = 0, rcvtcret = 0;

	thd = cos_sinv_2rets(uc, child_owntc, key_ipimax, ipiwin32b, 0, &sndtidret, &rcvtcret);
  4066ec:	44 89 c9             	mov    ecx,r9d
{
  4066ef:	41 54                	push   r12
	thd = cos_sinv_2rets(uc, child_owntc, key_ipimax, ipiwin32b, 0, &sndtidret, &rcvtcret);
  4066f1:	d3 fe                	sar    esi,cl
  4066f3:	41 09 d6             	or     r14d,edx
{
  4066f6:	53                   	push   rbx
  4066f7:	44 89 c3             	mov    ebx,r8d
  4066fa:	48 83 ec 28          	sub    rsp,0x28
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  4066fe:	4c 8b 78 10          	mov    r15,QWORD PTR [rax+0x10]
	word_t sndtidret = 0, rcvtcret = 0;
  406702:	48 c7 45 b0 00 00 00 	mov    QWORD PTR [rbp-0x50],0x0
  406709:	00 
  40670a:	48 c7 45 b8 00 00 00 	mov    QWORD PTR [rbp-0x48],0x0
  406711:	00 
  406712:	4d 85 ff             	test   r15,r15
  406715:	0f 84 95 00 00 00    	je     4067b0 <__cosrt_c_capmgr_initaep_create+0xe0>
  40671b:	4c 8d 4d b8          	lea    r9,[rbp-0x48]
  40671f:	4c 8d 45 b0          	lea    r8,[rbp-0x50]
  406723:	31 c9                	xor    ecx,ecx
  406725:	48 89 da             	mov    rdx,rbx
  406728:	4c 89 f7             	mov    rdi,r14
  40672b:	41 ff d7             	call   r15
	thd = cos_sinv_2rets(uc, child_owntc, key_ipimax, ipiwin32b, 0, &sndtidret, &rcvtcret);
  40672e:	48 98                	cdqe   
	if (!thd) return thd;
  406730:	48 85 c0             	test   rax,rax
  406733:	74 64                	je     406799 <__cosrt_c_capmgr_initaep_create+0xc9>

	aep->fn   = NULL;
	aep->data = NULL;
	aep->thd  = thd;
	aep->tid  = (sndtidret << 16) >> 16;
	aep->rcv  = rcvtcret >> 16;
  406735:	48 8b 75 b8          	mov    rsi,QWORD PTR [rbp-0x48]
	aep->tid  = (sndtidret << 16) >> 16;
  406739:	48 8b 4d b0          	mov    rcx,QWORD PTR [rbp-0x50]
	aep->tc   = (rcvtcret << 16) >> 16;
  40673d:	48 ba ff ff ff ff ff 	movabs rdx,0xffffffffffff
  406744:	ff 00 00 
  406747:	66 48 0f 6e c8       	movq   xmm1,rax
	*snd      = sndtidret >> 16;
  40674c:	48 8b 45 10          	mov    rax,QWORD PTR [rbp+0x10]
	aep->fn   = NULL;
  406750:	49 c7 45 20 00 00 00 	mov    QWORD PTR [r13+0x20],0x0
  406757:	00 
	aep->tc   = (rcvtcret << 16) >> 16;
  406758:	48 89 f3             	mov    rbx,rsi
	aep->rcv  = rcvtcret >> 16;
  40675b:	48 c1 ee 10          	shr    rsi,0x10
	aep->data = NULL;
  40675f:	49 c7 45 28 00 00 00 	mov    QWORD PTR [r13+0x28],0x0
  406766:	00 
	aep->tc   = (rcvtcret << 16) >> 16;
  406767:	48 21 d3             	and    rbx,rdx
	aep->tid  = (sndtidret << 16) >> 16;
  40676a:	48 21 ca             	and    rdx,rcx
	aep->tc   = (rcvtcret << 16) >> 16;
  40676d:	66 48 0f 6e d6       	movq   xmm2,rsi
	*snd      = sndtidret >> 16;
  406772:	48 c1 e9 10          	shr    rcx,0x10
	aep->tc   = (rcvtcret << 16) >> 16;
  406776:	66 48 0f 6e c3       	movq   xmm0,rbx
  40677b:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  40677f:	41 0f 11 45 00       	movups XMMWORD PTR [r13+0x0],xmm0
  406784:	66 48 0f 6e c2       	movq   xmm0,rdx
  406789:	66 0f 6c c2          	punpcklqdq xmm0,xmm2
  40678d:	41 0f 11 45 10       	movups XMMWORD PTR [r13+0x10],xmm0
	*snd      = sndtidret >> 16;
  406792:	48 89 08             	mov    QWORD PTR [rax],rcx

	/* initcaps are copied to INITXXX offsets in the dst component */
	return aep->thd;
  406795:	49 8b 45 08          	mov    rax,QWORD PTR [r13+0x8]
}
  406799:	48 83 c4 28          	add    rsp,0x28
  40679d:	5b                   	pop    rbx
  40679e:	41 5c                	pop    r12
  4067a0:	41 5d                	pop    r13
  4067a2:	41 5e                	pop    r14
  4067a4:	41 5f                	pop    r15
  4067a6:	5d                   	pop    rbp
  4067a7:	c3                   	ret    
  4067a8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4067af:	00 
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  4067b0:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  4067b4:	49 89 da             	mov    r10,rbx
	__asm__ __volatile__(
  4067b7:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  4067bb:	4c 89 f3             	mov    rbx,r14
  4067be:	4c 89 d7             	mov    rdi,r10
  4067c1:	4c 89 fa             	mov    rdx,r15
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4067c4:	83 c0 01             	add    eax,0x1
  4067c7:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  4067ca:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4067cd:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4067d1:	48 89 cd             	mov    rbp,rcx
  4067d4:	49 b8 e8 67 40 00 00 	movabs r8,0x4067e8
  4067db:	00 00 00 
  4067de:	0f 05                	syscall 
  4067e0:	eb 0f                	jmp    4067f1 <__cosrt_c_capmgr_initaep_create+0x121>
  4067e2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4067e8:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  4067ef:	eb 07                	jmp    4067f8 <__cosrt_c_capmgr_initaep_create+0x128>
  4067f1:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  4067f8:	5d                   	pop    rbp
  4067f9:	5c                   	pop    rsp
  4067fa:	48 89 75 b0          	mov    QWORD PTR [rbp-0x50],rsi
  4067fe:	48 89 7d b8          	mov    QWORD PTR [rbp-0x48],rdi
	return ret;
  406802:	e9 27 ff ff ff       	jmp    40672e <__cosrt_c_capmgr_initaep_create+0x5e>
  406807:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40680e:	00 00 

0000000000406810 <__cosrt_extern_capmgr_initthd_create>:
  406810:	48 b8 fc c0 45 00 00 	movabs rax,0x45c0fc
  406817:	00 00 00 
  40681a:	ff 10                	call   QWORD PTR [rax]
  40681c:	c3                   	ret    
  40681d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000406820 <__cosrt_fast_callgate_capmgr_initthd_create>:
  406820:	55                   	push   rbp
  406821:	53                   	push   rbx
  406822:	41 54                	push   r12
  406824:	41 55                	push   r13
  406826:	41 56                	push   r14
  406828:	41 57                	push   r15
  40682a:	4d 89 c4             	mov    r12,r8
  40682d:	4c 89 cb             	mov    rbx,r9
  406830:	49 89 c8             	mov    r8,rcx
  406833:	49 89 d1             	mov    r9,rdx
  406836:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40683d:	be ad de 
  406840:	0f 01 f9             	rdtscp 
  406843:	48 89 ca             	mov    rdx,rcx
  406846:	48 25 ff 0f 00 00    	and    rax,0xfff
  40684c:	48 89 e2             	mov    rdx,rsp
  40684f:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  406856:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40685d:	00 
  40685e:	48 c1 e0 10          	shl    rax,0x10
  406862:	49 09 c5             	or     r13,rax
  406865:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40686c:	7f 00 00 
  40686f:	4c 89 e8             	mov    rax,r13
  406872:	48 25 ff ff 00 00    	and    rax,0xffff
  406878:	48 c1 e0 08          	shl    rax,0x8
  40687c:	49 01 c6             	add    r14,rax
  40687f:	b9 01 00 00 00       	mov    ecx,0x1
  406884:	01 c9                	add    ecx,ecx
  406886:	b8 03 00 00 00       	mov    eax,0x3
  40688b:	d3 e0                	shl    eax,cl
  40688d:	f7 d0                	not    eax
  40688f:	83 e0 fc             	and    eax,0xfffffffc
  406892:	48 31 c9             	xor    rcx,rcx
  406895:	48 31 d2             	xor    rdx,rdx
  406898:	0f 01 ef             	wrpkru 
  40689b:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40689e:	48 83 c2 01          	add    rdx,0x1
  4068a2:	48 c1 e2 04          	shl    rdx,0x4
  4068a6:	4c 01 f2             	add    rdx,r14
  4068a9:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  4068b0:	45 23 01 
  4068b3:	48 89 02             	mov    QWORD PTR [rdx],rax
  4068b6:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  4068ba:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4068bd:	48 83 c0 01          	add    rax,0x1
  4068c1:	49 89 06             	mov    QWORD PTR [r14],rax
  4068c4:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4068c9:	01 c9                	add    ecx,ecx
  4068cb:	b8 03 00 00 00       	mov    eax,0x3
  4068d0:	d3 e0                	shl    eax,cl
  4068d2:	f7 d0                	not    eax
  4068d4:	83 e0 fc             	and    eax,0xfffffffc
  4068d7:	48 31 c9             	xor    rcx,rcx
  4068da:	48 31 d2             	xor    rdx,rdx
  4068dd:	0f 01 ef             	wrpkru 
  4068e0:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  4068e7:	45 23 01 
  4068ea:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4068f1:	be ad de 
  4068f4:	49 39 c7             	cmp    r15,rax
  4068f7:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  4068fe:	12 12 12 
  406901:	48 b9 0d 69 40 00 00 	movabs rcx,0x40690d
  406908:	00 00 00 
  40690b:	ff e0                	jmp    rax

000000000040690d <srv_call_ret_capmgr_initthd_create>:
  40690d:	49 89 c0             	mov    r8,rax
  406910:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  406917:	be ad de 
  40691a:	48 89 e2             	mov    rdx,rsp
  40691d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  406924:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40692b:	00 
  40692c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  406933:	7f 00 00 
  406936:	4c 89 e8             	mov    rax,r13
  406939:	48 25 ff ff 00 00    	and    rax,0xffff
  40693f:	48 c1 e0 08          	shl    rax,0x8
  406943:	49 01 c6             	add    r14,rax
  406946:	b9 01 00 00 00       	mov    ecx,0x1
  40694b:	01 c9                	add    ecx,ecx
  40694d:	b8 03 00 00 00       	mov    eax,0x3
  406952:	d3 e0                	shl    eax,cl
  406954:	f7 d0                	not    eax
  406956:	83 e0 fc             	and    eax,0xfffffffc
  406959:	48 31 c9             	xor    rcx,rcx
  40695c:	48 31 d2             	xor    rdx,rdx
  40695f:	0f 01 ef             	wrpkru 
  406962:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  406965:	48 c1 e2 04          	shl    rdx,0x4
  406969:	4c 01 f2             	add    rdx,r14
  40696c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  406970:	49 8b 06             	mov    rax,QWORD PTR [r14]
  406973:	48 83 e8 01          	sub    rax,0x1
  406977:	49 89 06             	mov    QWORD PTR [r14],rax
  40697a:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40697f:	01 c9                	add    ecx,ecx
  406981:	b8 03 00 00 00       	mov    eax,0x3
  406986:	d3 e0                	shl    eax,cl
  406988:	f7 d0                	not    eax
  40698a:	83 e0 fc             	and    eax,0xfffffffc
  40698d:	48 31 c9             	xor    rcx,rcx
  406990:	48 31 d2             	xor    rdx,rdx
  406993:	0f 01 ef             	wrpkru 
  406996:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40699d:	be ad de 
  4069a0:	49 39 c7             	cmp    r15,rax
  4069a3:	4c 89 c0             	mov    rax,r8
  4069a6:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  4069aa:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  4069ad:	41 5f                	pop    r15
  4069af:	41 5e                	pop    r14
  4069b1:	41 5d                	pop    r13
  4069b3:	41 5c                	pop    r12
  4069b5:	5b                   	pop    rbx
  4069b6:	5d                   	pop    rbp
  4069b7:	c3                   	ret    
  4069b8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4069bf:	00 

00000000004069c0 <__cosrt_extern_capmgr_thd_create_thunk>:
  4069c0:	48 b8 14 c1 45 00 00 	movabs rax,0x45c114
  4069c7:	00 00 00 
  4069ca:	ff 10                	call   QWORD PTR [rax]
  4069cc:	c3                   	ret    
  4069cd:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004069d0 <__cosrt_fast_callgate_capmgr_thd_create_thunk>:
  4069d0:	55                   	push   rbp
  4069d1:	53                   	push   rbx
  4069d2:	41 54                	push   r12
  4069d4:	41 55                	push   r13
  4069d6:	41 56                	push   r14
  4069d8:	41 57                	push   r15
  4069da:	4d 89 c4             	mov    r12,r8
  4069dd:	4c 89 cb             	mov    rbx,r9
  4069e0:	49 89 c8             	mov    r8,rcx
  4069e3:	49 89 d1             	mov    r9,rdx
  4069e6:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4069ed:	be ad de 
  4069f0:	0f 01 f9             	rdtscp 
  4069f3:	48 89 ca             	mov    rdx,rcx
  4069f6:	48 25 ff 0f 00 00    	and    rax,0xfff
  4069fc:	48 89 e2             	mov    rdx,rsp
  4069ff:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  406a06:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  406a0d:	00 
  406a0e:	48 c1 e0 10          	shl    rax,0x10
  406a12:	49 09 c5             	or     r13,rax
  406a15:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  406a1c:	7f 00 00 
  406a1f:	4c 89 e8             	mov    rax,r13
  406a22:	48 25 ff ff 00 00    	and    rax,0xffff
  406a28:	48 c1 e0 08          	shl    rax,0x8
  406a2c:	49 01 c6             	add    r14,rax
  406a2f:	b9 01 00 00 00       	mov    ecx,0x1
  406a34:	01 c9                	add    ecx,ecx
  406a36:	b8 03 00 00 00       	mov    eax,0x3
  406a3b:	d3 e0                	shl    eax,cl
  406a3d:	f7 d0                	not    eax
  406a3f:	83 e0 fc             	and    eax,0xfffffffc
  406a42:	48 31 c9             	xor    rcx,rcx
  406a45:	48 31 d2             	xor    rdx,rdx
  406a48:	0f 01 ef             	wrpkru 
  406a4b:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  406a4e:	48 83 c2 01          	add    rdx,0x1
  406a52:	48 c1 e2 04          	shl    rdx,0x4
  406a56:	4c 01 f2             	add    rdx,r14
  406a59:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  406a60:	45 23 01 
  406a63:	48 89 02             	mov    QWORD PTR [rdx],rax
  406a66:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  406a6a:	49 8b 06             	mov    rax,QWORD PTR [r14]
  406a6d:	48 83 c0 01          	add    rax,0x1
  406a71:	49 89 06             	mov    QWORD PTR [r14],rax
  406a74:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  406a79:	01 c9                	add    ecx,ecx
  406a7b:	b8 03 00 00 00       	mov    eax,0x3
  406a80:	d3 e0                	shl    eax,cl
  406a82:	f7 d0                	not    eax
  406a84:	83 e0 fc             	and    eax,0xfffffffc
  406a87:	48 31 c9             	xor    rcx,rcx
  406a8a:	48 31 d2             	xor    rdx,rdx
  406a8d:	0f 01 ef             	wrpkru 
  406a90:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  406a97:	45 23 01 
  406a9a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  406aa1:	be ad de 
  406aa4:	49 39 c7             	cmp    r15,rax
  406aa7:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  406aae:	12 12 12 
  406ab1:	48 b9 bd 6a 40 00 00 	movabs rcx,0x406abd
  406ab8:	00 00 00 
  406abb:	ff e0                	jmp    rax

0000000000406abd <srv_call_ret_capmgr_thd_create_thunk>:
  406abd:	49 89 c0             	mov    r8,rax
  406ac0:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  406ac7:	be ad de 
  406aca:	48 89 e2             	mov    rdx,rsp
  406acd:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  406ad4:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  406adb:	00 
  406adc:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  406ae3:	7f 00 00 
  406ae6:	4c 89 e8             	mov    rax,r13
  406ae9:	48 25 ff ff 00 00    	and    rax,0xffff
  406aef:	48 c1 e0 08          	shl    rax,0x8
  406af3:	49 01 c6             	add    r14,rax
  406af6:	b9 01 00 00 00       	mov    ecx,0x1
  406afb:	01 c9                	add    ecx,ecx
  406afd:	b8 03 00 00 00       	mov    eax,0x3
  406b02:	d3 e0                	shl    eax,cl
  406b04:	f7 d0                	not    eax
  406b06:	83 e0 fc             	and    eax,0xfffffffc
  406b09:	48 31 c9             	xor    rcx,rcx
  406b0c:	48 31 d2             	xor    rdx,rdx
  406b0f:	0f 01 ef             	wrpkru 
  406b12:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  406b15:	48 c1 e2 04          	shl    rdx,0x4
  406b19:	4c 01 f2             	add    rdx,r14
  406b1c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  406b20:	49 8b 06             	mov    rax,QWORD PTR [r14]
  406b23:	48 83 e8 01          	sub    rax,0x1
  406b27:	49 89 06             	mov    QWORD PTR [r14],rax
  406b2a:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  406b2f:	01 c9                	add    ecx,ecx
  406b31:	b8 03 00 00 00       	mov    eax,0x3
  406b36:	d3 e0                	shl    eax,cl
  406b38:	f7 d0                	not    eax
  406b3a:	83 e0 fc             	and    eax,0xfffffffc
  406b3d:	48 31 c9             	xor    rcx,rcx
  406b40:	48 31 d2             	xor    rdx,rdx
  406b43:	0f 01 ef             	wrpkru 
  406b46:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  406b4d:	be ad de 
  406b50:	49 39 c7             	cmp    r15,rax
  406b53:	4c 89 c0             	mov    rax,r8
  406b56:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  406b5a:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  406b5d:	41 5f                	pop    r15
  406b5f:	41 5e                	pop    r14
  406b61:	41 5d                	pop    r13
  406b63:	41 5c                	pop    r12
  406b65:	5b                   	pop    rbx
  406b66:	5d                   	pop    rbp
  406b67:	c3                   	ret    
  406b68:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  406b6f:	00 

0000000000406b70 <__cosrt_extern_capmgr_thd_create_ext>:
  406b70:	48 b8 2c c1 45 00 00 	movabs rax,0x45c12c
  406b77:	00 00 00 
  406b7a:	ff 10                	call   QWORD PTR [rax]
  406b7c:	c3                   	ret    
  406b7d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000406b80 <__cosrt_fast_callgate_capmgr_thd_create_ext>:
  406b80:	55                   	push   rbp
  406b81:	53                   	push   rbx
  406b82:	41 54                	push   r12
  406b84:	41 55                	push   r13
  406b86:	41 56                	push   r14
  406b88:	41 57                	push   r15
  406b8a:	4d 89 c4             	mov    r12,r8
  406b8d:	4c 89 cb             	mov    rbx,r9
  406b90:	49 89 c8             	mov    r8,rcx
  406b93:	49 89 d1             	mov    r9,rdx
  406b96:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  406b9d:	be ad de 
  406ba0:	0f 01 f9             	rdtscp 
  406ba3:	48 89 ca             	mov    rdx,rcx
  406ba6:	48 25 ff 0f 00 00    	and    rax,0xfff
  406bac:	48 89 e2             	mov    rdx,rsp
  406baf:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  406bb6:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  406bbd:	00 
  406bbe:	48 c1 e0 10          	shl    rax,0x10
  406bc2:	49 09 c5             	or     r13,rax
  406bc5:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  406bcc:	7f 00 00 
  406bcf:	4c 89 e8             	mov    rax,r13
  406bd2:	48 25 ff ff 00 00    	and    rax,0xffff
  406bd8:	48 c1 e0 08          	shl    rax,0x8
  406bdc:	49 01 c6             	add    r14,rax
  406bdf:	b9 01 00 00 00       	mov    ecx,0x1
  406be4:	01 c9                	add    ecx,ecx
  406be6:	b8 03 00 00 00       	mov    eax,0x3
  406beb:	d3 e0                	shl    eax,cl
  406bed:	f7 d0                	not    eax
  406bef:	83 e0 fc             	and    eax,0xfffffffc
  406bf2:	48 31 c9             	xor    rcx,rcx
  406bf5:	48 31 d2             	xor    rdx,rdx
  406bf8:	0f 01 ef             	wrpkru 
  406bfb:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  406bfe:	48 83 c2 01          	add    rdx,0x1
  406c02:	48 c1 e2 04          	shl    rdx,0x4
  406c06:	4c 01 f2             	add    rdx,r14
  406c09:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  406c10:	45 23 01 
  406c13:	48 89 02             	mov    QWORD PTR [rdx],rax
  406c16:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  406c1a:	49 8b 06             	mov    rax,QWORD PTR [r14]
  406c1d:	48 83 c0 01          	add    rax,0x1
  406c21:	49 89 06             	mov    QWORD PTR [r14],rax
  406c24:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  406c29:	01 c9                	add    ecx,ecx
  406c2b:	b8 03 00 00 00       	mov    eax,0x3
  406c30:	d3 e0                	shl    eax,cl
  406c32:	f7 d0                	not    eax
  406c34:	83 e0 fc             	and    eax,0xfffffffc
  406c37:	48 31 c9             	xor    rcx,rcx
  406c3a:	48 31 d2             	xor    rdx,rdx
  406c3d:	0f 01 ef             	wrpkru 
  406c40:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  406c47:	45 23 01 
  406c4a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  406c51:	be ad de 
  406c54:	49 39 c7             	cmp    r15,rax
  406c57:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  406c5e:	12 12 12 
  406c61:	48 b9 6d 6c 40 00 00 	movabs rcx,0x406c6d
  406c68:	00 00 00 
  406c6b:	ff e0                	jmp    rax

0000000000406c6d <srv_call_ret_capmgr_thd_create_ext>:
  406c6d:	49 89 c0             	mov    r8,rax
  406c70:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  406c77:	be ad de 
  406c7a:	48 89 e2             	mov    rdx,rsp
  406c7d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  406c84:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  406c8b:	00 
  406c8c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  406c93:	7f 00 00 
  406c96:	4c 89 e8             	mov    rax,r13
  406c99:	48 25 ff ff 00 00    	and    rax,0xffff
  406c9f:	48 c1 e0 08          	shl    rax,0x8
  406ca3:	49 01 c6             	add    r14,rax
  406ca6:	b9 01 00 00 00       	mov    ecx,0x1
  406cab:	01 c9                	add    ecx,ecx
  406cad:	b8 03 00 00 00       	mov    eax,0x3
  406cb2:	d3 e0                	shl    eax,cl
  406cb4:	f7 d0                	not    eax
  406cb6:	83 e0 fc             	and    eax,0xfffffffc
  406cb9:	48 31 c9             	xor    rcx,rcx
  406cbc:	48 31 d2             	xor    rdx,rdx
  406cbf:	0f 01 ef             	wrpkru 
  406cc2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  406cc5:	48 c1 e2 04          	shl    rdx,0x4
  406cc9:	4c 01 f2             	add    rdx,r14
  406ccc:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  406cd0:	49 8b 06             	mov    rax,QWORD PTR [r14]
  406cd3:	48 83 e8 01          	sub    rax,0x1
  406cd7:	49 89 06             	mov    QWORD PTR [r14],rax
  406cda:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  406cdf:	01 c9                	add    ecx,ecx
  406ce1:	b8 03 00 00 00       	mov    eax,0x3
  406ce6:	d3 e0                	shl    eax,cl
  406ce8:	f7 d0                	not    eax
  406cea:	83 e0 fc             	and    eax,0xfffffffc
  406ced:	48 31 c9             	xor    rcx,rcx
  406cf0:	48 31 d2             	xor    rdx,rdx
  406cf3:	0f 01 ef             	wrpkru 
  406cf6:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  406cfd:	be ad de 
  406d00:	49 39 c7             	cmp    r15,rax
  406d03:	4c 89 c0             	mov    rax,r8
  406d06:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  406d0a:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  406d0d:	41 5f                	pop    r15
  406d0f:	41 5e                	pop    r14
  406d11:	41 5d                	pop    r13
  406d13:	41 5c                	pop    r12
  406d15:	5b                   	pop    rbx
  406d16:	5d                   	pop    rbp
  406d17:	c3                   	ret    
  406d18:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  406d1f:	00 

0000000000406d20 <__cosrt_extern_capmgr_initaep_create>:
  406d20:	48 b8 44 c1 45 00 00 	movabs rax,0x45c144
  406d27:	00 00 00 
  406d2a:	ff 10                	call   QWORD PTR [rax]
  406d2c:	c3                   	ret    
  406d2d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000406d30 <__cosrt_fast_callgate_capmgr_initaep_create>:
  406d30:	55                   	push   rbp
  406d31:	53                   	push   rbx
  406d32:	41 54                	push   r12
  406d34:	41 55                	push   r13
  406d36:	41 56                	push   r14
  406d38:	41 57                	push   r15
  406d3a:	4d 89 c4             	mov    r12,r8
  406d3d:	4c 89 cb             	mov    rbx,r9
  406d40:	49 89 c8             	mov    r8,rcx
  406d43:	49 89 d1             	mov    r9,rdx
  406d46:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  406d4d:	be ad de 
  406d50:	0f 01 f9             	rdtscp 
  406d53:	48 89 ca             	mov    rdx,rcx
  406d56:	48 25 ff 0f 00 00    	and    rax,0xfff
  406d5c:	48 89 e2             	mov    rdx,rsp
  406d5f:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  406d66:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  406d6d:	00 
  406d6e:	48 c1 e0 10          	shl    rax,0x10
  406d72:	49 09 c5             	or     r13,rax
  406d75:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  406d7c:	7f 00 00 
  406d7f:	4c 89 e8             	mov    rax,r13
  406d82:	48 25 ff ff 00 00    	and    rax,0xffff
  406d88:	48 c1 e0 08          	shl    rax,0x8
  406d8c:	49 01 c6             	add    r14,rax
  406d8f:	b9 01 00 00 00       	mov    ecx,0x1
  406d94:	01 c9                	add    ecx,ecx
  406d96:	b8 03 00 00 00       	mov    eax,0x3
  406d9b:	d3 e0                	shl    eax,cl
  406d9d:	f7 d0                	not    eax
  406d9f:	83 e0 fc             	and    eax,0xfffffffc
  406da2:	48 31 c9             	xor    rcx,rcx
  406da5:	48 31 d2             	xor    rdx,rdx
  406da8:	0f 01 ef             	wrpkru 
  406dab:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  406dae:	48 83 c2 01          	add    rdx,0x1
  406db2:	48 c1 e2 04          	shl    rdx,0x4
  406db6:	4c 01 f2             	add    rdx,r14
  406db9:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  406dc0:	45 23 01 
  406dc3:	48 89 02             	mov    QWORD PTR [rdx],rax
  406dc6:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  406dca:	49 8b 06             	mov    rax,QWORD PTR [r14]
  406dcd:	48 83 c0 01          	add    rax,0x1
  406dd1:	49 89 06             	mov    QWORD PTR [r14],rax
  406dd4:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  406dd9:	01 c9                	add    ecx,ecx
  406ddb:	b8 03 00 00 00       	mov    eax,0x3
  406de0:	d3 e0                	shl    eax,cl
  406de2:	f7 d0                	not    eax
  406de4:	83 e0 fc             	and    eax,0xfffffffc
  406de7:	48 31 c9             	xor    rcx,rcx
  406dea:	48 31 d2             	xor    rdx,rdx
  406ded:	0f 01 ef             	wrpkru 
  406df0:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  406df7:	45 23 01 
  406dfa:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  406e01:	be ad de 
  406e04:	49 39 c7             	cmp    r15,rax
  406e07:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  406e0e:	12 12 12 
  406e11:	48 b9 1d 6e 40 00 00 	movabs rcx,0x406e1d
  406e18:	00 00 00 
  406e1b:	ff e0                	jmp    rax

0000000000406e1d <srv_call_ret_capmgr_initaep_create>:
  406e1d:	49 89 c0             	mov    r8,rax
  406e20:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  406e27:	be ad de 
  406e2a:	48 89 e2             	mov    rdx,rsp
  406e2d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  406e34:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  406e3b:	00 
  406e3c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  406e43:	7f 00 00 
  406e46:	4c 89 e8             	mov    rax,r13
  406e49:	48 25 ff ff 00 00    	and    rax,0xffff
  406e4f:	48 c1 e0 08          	shl    rax,0x8
  406e53:	49 01 c6             	add    r14,rax
  406e56:	b9 01 00 00 00       	mov    ecx,0x1
  406e5b:	01 c9                	add    ecx,ecx
  406e5d:	b8 03 00 00 00       	mov    eax,0x3
  406e62:	d3 e0                	shl    eax,cl
  406e64:	f7 d0                	not    eax
  406e66:	83 e0 fc             	and    eax,0xfffffffc
  406e69:	48 31 c9             	xor    rcx,rcx
  406e6c:	48 31 d2             	xor    rdx,rdx
  406e6f:	0f 01 ef             	wrpkru 
  406e72:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  406e75:	48 c1 e2 04          	shl    rdx,0x4
  406e79:	4c 01 f2             	add    rdx,r14
  406e7c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  406e80:	49 8b 06             	mov    rax,QWORD PTR [r14]
  406e83:	48 83 e8 01          	sub    rax,0x1
  406e87:	49 89 06             	mov    QWORD PTR [r14],rax
  406e8a:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  406e8f:	01 c9                	add    ecx,ecx
  406e91:	b8 03 00 00 00       	mov    eax,0x3
  406e96:	d3 e0                	shl    eax,cl
  406e98:	f7 d0                	not    eax
  406e9a:	83 e0 fc             	and    eax,0xfffffffc
  406e9d:	48 31 c9             	xor    rcx,rcx
  406ea0:	48 31 d2             	xor    rdx,rdx
  406ea3:	0f 01 ef             	wrpkru 
  406ea6:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  406ead:	be ad de 
  406eb0:	49 39 c7             	cmp    r15,rax
  406eb3:	4c 89 c0             	mov    rax,r8
  406eb6:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  406eba:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  406ebd:	41 5f                	pop    r15
  406ebf:	41 5e                	pop    r14
  406ec1:	41 5d                	pop    r13
  406ec3:	41 5c                	pop    r12
  406ec5:	5b                   	pop    rbx
  406ec6:	5d                   	pop    rbp
  406ec7:	c3                   	ret    
  406ec8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  406ecf:	00 

0000000000406ed0 <__cosrt_extern_capmgr_aep_create_thunk>:
  406ed0:	48 b8 5c c1 45 00 00 	movabs rax,0x45c15c
  406ed7:	00 00 00 
  406eda:	ff 10                	call   QWORD PTR [rax]
  406edc:	c3                   	ret    
  406edd:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000406ee0 <__cosrt_fast_callgate_capmgr_aep_create_thunk>:
  406ee0:	55                   	push   rbp
  406ee1:	53                   	push   rbx
  406ee2:	41 54                	push   r12
  406ee4:	41 55                	push   r13
  406ee6:	41 56                	push   r14
  406ee8:	41 57                	push   r15
  406eea:	4d 89 c4             	mov    r12,r8
  406eed:	4c 89 cb             	mov    rbx,r9
  406ef0:	49 89 c8             	mov    r8,rcx
  406ef3:	49 89 d1             	mov    r9,rdx
  406ef6:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  406efd:	be ad de 
  406f00:	0f 01 f9             	rdtscp 
  406f03:	48 89 ca             	mov    rdx,rcx
  406f06:	48 25 ff 0f 00 00    	and    rax,0xfff
  406f0c:	48 89 e2             	mov    rdx,rsp
  406f0f:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  406f16:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  406f1d:	00 
  406f1e:	48 c1 e0 10          	shl    rax,0x10
  406f22:	49 09 c5             	or     r13,rax
  406f25:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  406f2c:	7f 00 00 
  406f2f:	4c 89 e8             	mov    rax,r13
  406f32:	48 25 ff ff 00 00    	and    rax,0xffff
  406f38:	48 c1 e0 08          	shl    rax,0x8
  406f3c:	49 01 c6             	add    r14,rax
  406f3f:	b9 01 00 00 00       	mov    ecx,0x1
  406f44:	01 c9                	add    ecx,ecx
  406f46:	b8 03 00 00 00       	mov    eax,0x3
  406f4b:	d3 e0                	shl    eax,cl
  406f4d:	f7 d0                	not    eax
  406f4f:	83 e0 fc             	and    eax,0xfffffffc
  406f52:	48 31 c9             	xor    rcx,rcx
  406f55:	48 31 d2             	xor    rdx,rdx
  406f58:	0f 01 ef             	wrpkru 
  406f5b:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  406f5e:	48 83 c2 01          	add    rdx,0x1
  406f62:	48 c1 e2 04          	shl    rdx,0x4
  406f66:	4c 01 f2             	add    rdx,r14
  406f69:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  406f70:	45 23 01 
  406f73:	48 89 02             	mov    QWORD PTR [rdx],rax
  406f76:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  406f7a:	49 8b 06             	mov    rax,QWORD PTR [r14]
  406f7d:	48 83 c0 01          	add    rax,0x1
  406f81:	49 89 06             	mov    QWORD PTR [r14],rax
  406f84:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  406f89:	01 c9                	add    ecx,ecx
  406f8b:	b8 03 00 00 00       	mov    eax,0x3
  406f90:	d3 e0                	shl    eax,cl
  406f92:	f7 d0                	not    eax
  406f94:	83 e0 fc             	and    eax,0xfffffffc
  406f97:	48 31 c9             	xor    rcx,rcx
  406f9a:	48 31 d2             	xor    rdx,rdx
  406f9d:	0f 01 ef             	wrpkru 
  406fa0:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  406fa7:	45 23 01 
  406faa:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  406fb1:	be ad de 
  406fb4:	49 39 c7             	cmp    r15,rax
  406fb7:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  406fbe:	12 12 12 
  406fc1:	48 b9 cd 6f 40 00 00 	movabs rcx,0x406fcd
  406fc8:	00 00 00 
  406fcb:	ff e0                	jmp    rax

0000000000406fcd <srv_call_ret_capmgr_aep_create_thunk>:
  406fcd:	49 89 c0             	mov    r8,rax
  406fd0:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  406fd7:	be ad de 
  406fda:	48 89 e2             	mov    rdx,rsp
  406fdd:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  406fe4:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  406feb:	00 
  406fec:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  406ff3:	7f 00 00 
  406ff6:	4c 89 e8             	mov    rax,r13
  406ff9:	48 25 ff ff 00 00    	and    rax,0xffff
  406fff:	48 c1 e0 08          	shl    rax,0x8
  407003:	49 01 c6             	add    r14,rax
  407006:	b9 01 00 00 00       	mov    ecx,0x1
  40700b:	01 c9                	add    ecx,ecx
  40700d:	b8 03 00 00 00       	mov    eax,0x3
  407012:	d3 e0                	shl    eax,cl
  407014:	f7 d0                	not    eax
  407016:	83 e0 fc             	and    eax,0xfffffffc
  407019:	48 31 c9             	xor    rcx,rcx
  40701c:	48 31 d2             	xor    rdx,rdx
  40701f:	0f 01 ef             	wrpkru 
  407022:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  407025:	48 c1 e2 04          	shl    rdx,0x4
  407029:	4c 01 f2             	add    rdx,r14
  40702c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  407030:	49 8b 06             	mov    rax,QWORD PTR [r14]
  407033:	48 83 e8 01          	sub    rax,0x1
  407037:	49 89 06             	mov    QWORD PTR [r14],rax
  40703a:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40703f:	01 c9                	add    ecx,ecx
  407041:	b8 03 00 00 00       	mov    eax,0x3
  407046:	d3 e0                	shl    eax,cl
  407048:	f7 d0                	not    eax
  40704a:	83 e0 fc             	and    eax,0xfffffffc
  40704d:	48 31 c9             	xor    rcx,rcx
  407050:	48 31 d2             	xor    rdx,rdx
  407053:	0f 01 ef             	wrpkru 
  407056:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40705d:	be ad de 
  407060:	49 39 c7             	cmp    r15,rax
  407063:	4c 89 c0             	mov    rax,r8
  407066:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  40706a:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  40706d:	41 5f                	pop    r15
  40706f:	41 5e                	pop    r14
  407071:	41 5d                	pop    r13
  407073:	41 5c                	pop    r12
  407075:	5b                   	pop    rbx
  407076:	5d                   	pop    rbp
  407077:	c3                   	ret    
  407078:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40707f:	00 

0000000000407080 <__cosrt_extern_capmgr_aep_create_ext>:
  407080:	48 b8 74 c1 45 00 00 	movabs rax,0x45c174
  407087:	00 00 00 
  40708a:	ff 10                	call   QWORD PTR [rax]
  40708c:	c3                   	ret    
  40708d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000407090 <__cosrt_fast_callgate_capmgr_aep_create_ext>:
  407090:	55                   	push   rbp
  407091:	53                   	push   rbx
  407092:	41 54                	push   r12
  407094:	41 55                	push   r13
  407096:	41 56                	push   r14
  407098:	41 57                	push   r15
  40709a:	4d 89 c4             	mov    r12,r8
  40709d:	4c 89 cb             	mov    rbx,r9
  4070a0:	49 89 c8             	mov    r8,rcx
  4070a3:	49 89 d1             	mov    r9,rdx
  4070a6:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4070ad:	be ad de 
  4070b0:	0f 01 f9             	rdtscp 
  4070b3:	48 89 ca             	mov    rdx,rcx
  4070b6:	48 25 ff 0f 00 00    	and    rax,0xfff
  4070bc:	48 89 e2             	mov    rdx,rsp
  4070bf:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4070c6:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4070cd:	00 
  4070ce:	48 c1 e0 10          	shl    rax,0x10
  4070d2:	49 09 c5             	or     r13,rax
  4070d5:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4070dc:	7f 00 00 
  4070df:	4c 89 e8             	mov    rax,r13
  4070e2:	48 25 ff ff 00 00    	and    rax,0xffff
  4070e8:	48 c1 e0 08          	shl    rax,0x8
  4070ec:	49 01 c6             	add    r14,rax
  4070ef:	b9 01 00 00 00       	mov    ecx,0x1
  4070f4:	01 c9                	add    ecx,ecx
  4070f6:	b8 03 00 00 00       	mov    eax,0x3
  4070fb:	d3 e0                	shl    eax,cl
  4070fd:	f7 d0                	not    eax
  4070ff:	83 e0 fc             	and    eax,0xfffffffc
  407102:	48 31 c9             	xor    rcx,rcx
  407105:	48 31 d2             	xor    rdx,rdx
  407108:	0f 01 ef             	wrpkru 
  40710b:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40710e:	48 83 c2 01          	add    rdx,0x1
  407112:	48 c1 e2 04          	shl    rdx,0x4
  407116:	4c 01 f2             	add    rdx,r14
  407119:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  407120:	45 23 01 
  407123:	48 89 02             	mov    QWORD PTR [rdx],rax
  407126:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  40712a:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40712d:	48 83 c0 01          	add    rax,0x1
  407131:	49 89 06             	mov    QWORD PTR [r14],rax
  407134:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407139:	01 c9                	add    ecx,ecx
  40713b:	b8 03 00 00 00       	mov    eax,0x3
  407140:	d3 e0                	shl    eax,cl
  407142:	f7 d0                	not    eax
  407144:	83 e0 fc             	and    eax,0xfffffffc
  407147:	48 31 c9             	xor    rcx,rcx
  40714a:	48 31 d2             	xor    rdx,rdx
  40714d:	0f 01 ef             	wrpkru 
  407150:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  407157:	45 23 01 
  40715a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407161:	be ad de 
  407164:	49 39 c7             	cmp    r15,rax
  407167:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  40716e:	12 12 12 
  407171:	48 b9 7d 71 40 00 00 	movabs rcx,0x40717d
  407178:	00 00 00 
  40717b:	ff e0                	jmp    rax

000000000040717d <srv_call_ret_capmgr_aep_create_ext>:
  40717d:	49 89 c0             	mov    r8,rax
  407180:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  407187:	be ad de 
  40718a:	48 89 e2             	mov    rdx,rsp
  40718d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  407194:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40719b:	00 
  40719c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4071a3:	7f 00 00 
  4071a6:	4c 89 e8             	mov    rax,r13
  4071a9:	48 25 ff ff 00 00    	and    rax,0xffff
  4071af:	48 c1 e0 08          	shl    rax,0x8
  4071b3:	49 01 c6             	add    r14,rax
  4071b6:	b9 01 00 00 00       	mov    ecx,0x1
  4071bb:	01 c9                	add    ecx,ecx
  4071bd:	b8 03 00 00 00       	mov    eax,0x3
  4071c2:	d3 e0                	shl    eax,cl
  4071c4:	f7 d0                	not    eax
  4071c6:	83 e0 fc             	and    eax,0xfffffffc
  4071c9:	48 31 c9             	xor    rcx,rcx
  4071cc:	48 31 d2             	xor    rdx,rdx
  4071cf:	0f 01 ef             	wrpkru 
  4071d2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4071d5:	48 c1 e2 04          	shl    rdx,0x4
  4071d9:	4c 01 f2             	add    rdx,r14
  4071dc:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  4071e0:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4071e3:	48 83 e8 01          	sub    rax,0x1
  4071e7:	49 89 06             	mov    QWORD PTR [r14],rax
  4071ea:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4071ef:	01 c9                	add    ecx,ecx
  4071f1:	b8 03 00 00 00       	mov    eax,0x3
  4071f6:	d3 e0                	shl    eax,cl
  4071f8:	f7 d0                	not    eax
  4071fa:	83 e0 fc             	and    eax,0xfffffffc
  4071fd:	48 31 c9             	xor    rcx,rcx
  407200:	48 31 d2             	xor    rdx,rdx
  407203:	0f 01 ef             	wrpkru 
  407206:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40720d:	be ad de 
  407210:	49 39 c7             	cmp    r15,rax
  407213:	4c 89 c0             	mov    rax,r8
  407216:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  40721a:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  40721d:	41 5f                	pop    r15
  40721f:	41 5e                	pop    r14
  407221:	41 5d                	pop    r13
  407223:	41 5c                	pop    r12
  407225:	5b                   	pop    rbx
  407226:	5d                   	pop    rbp
  407227:	c3                   	ret    
  407228:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40722f:	00 

0000000000407230 <__cosrt_extern_capmgr_rcv_create>:
  407230:	48 b8 8c c1 45 00 00 	movabs rax,0x45c18c
  407237:	00 00 00 
  40723a:	ff 10                	call   QWORD PTR [rax]
  40723c:	c3                   	ret    
  40723d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000407240 <__cosrt_fast_callgate_capmgr_rcv_create>:
  407240:	55                   	push   rbp
  407241:	53                   	push   rbx
  407242:	41 54                	push   r12
  407244:	41 55                	push   r13
  407246:	41 56                	push   r14
  407248:	41 57                	push   r15
  40724a:	4d 89 c4             	mov    r12,r8
  40724d:	4c 89 cb             	mov    rbx,r9
  407250:	49 89 c8             	mov    r8,rcx
  407253:	49 89 d1             	mov    r9,rdx
  407256:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40725d:	be ad de 
  407260:	0f 01 f9             	rdtscp 
  407263:	48 89 ca             	mov    rdx,rcx
  407266:	48 25 ff 0f 00 00    	and    rax,0xfff
  40726c:	48 89 e2             	mov    rdx,rsp
  40726f:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  407276:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40727d:	00 
  40727e:	48 c1 e0 10          	shl    rax,0x10
  407282:	49 09 c5             	or     r13,rax
  407285:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40728c:	7f 00 00 
  40728f:	4c 89 e8             	mov    rax,r13
  407292:	48 25 ff ff 00 00    	and    rax,0xffff
  407298:	48 c1 e0 08          	shl    rax,0x8
  40729c:	49 01 c6             	add    r14,rax
  40729f:	b9 01 00 00 00       	mov    ecx,0x1
  4072a4:	01 c9                	add    ecx,ecx
  4072a6:	b8 03 00 00 00       	mov    eax,0x3
  4072ab:	d3 e0                	shl    eax,cl
  4072ad:	f7 d0                	not    eax
  4072af:	83 e0 fc             	and    eax,0xfffffffc
  4072b2:	48 31 c9             	xor    rcx,rcx
  4072b5:	48 31 d2             	xor    rdx,rdx
  4072b8:	0f 01 ef             	wrpkru 
  4072bb:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4072be:	48 83 c2 01          	add    rdx,0x1
  4072c2:	48 c1 e2 04          	shl    rdx,0x4
  4072c6:	4c 01 f2             	add    rdx,r14
  4072c9:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  4072d0:	45 23 01 
  4072d3:	48 89 02             	mov    QWORD PTR [rdx],rax
  4072d6:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  4072da:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4072dd:	48 83 c0 01          	add    rax,0x1
  4072e1:	49 89 06             	mov    QWORD PTR [r14],rax
  4072e4:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4072e9:	01 c9                	add    ecx,ecx
  4072eb:	b8 03 00 00 00       	mov    eax,0x3
  4072f0:	d3 e0                	shl    eax,cl
  4072f2:	f7 d0                	not    eax
  4072f4:	83 e0 fc             	and    eax,0xfffffffc
  4072f7:	48 31 c9             	xor    rcx,rcx
  4072fa:	48 31 d2             	xor    rdx,rdx
  4072fd:	0f 01 ef             	wrpkru 
  407300:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  407307:	45 23 01 
  40730a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407311:	be ad de 
  407314:	49 39 c7             	cmp    r15,rax
  407317:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  40731e:	12 12 12 
  407321:	48 b9 2d 73 40 00 00 	movabs rcx,0x40732d
  407328:	00 00 00 
  40732b:	ff e0                	jmp    rax

000000000040732d <srv_call_ret_capmgr_rcv_create>:
  40732d:	49 89 c0             	mov    r8,rax
  407330:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  407337:	be ad de 
  40733a:	48 89 e2             	mov    rdx,rsp
  40733d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  407344:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40734b:	00 
  40734c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  407353:	7f 00 00 
  407356:	4c 89 e8             	mov    rax,r13
  407359:	48 25 ff ff 00 00    	and    rax,0xffff
  40735f:	48 c1 e0 08          	shl    rax,0x8
  407363:	49 01 c6             	add    r14,rax
  407366:	b9 01 00 00 00       	mov    ecx,0x1
  40736b:	01 c9                	add    ecx,ecx
  40736d:	b8 03 00 00 00       	mov    eax,0x3
  407372:	d3 e0                	shl    eax,cl
  407374:	f7 d0                	not    eax
  407376:	83 e0 fc             	and    eax,0xfffffffc
  407379:	48 31 c9             	xor    rcx,rcx
  40737c:	48 31 d2             	xor    rdx,rdx
  40737f:	0f 01 ef             	wrpkru 
  407382:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  407385:	48 c1 e2 04          	shl    rdx,0x4
  407389:	4c 01 f2             	add    rdx,r14
  40738c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  407390:	49 8b 06             	mov    rax,QWORD PTR [r14]
  407393:	48 83 e8 01          	sub    rax,0x1
  407397:	49 89 06             	mov    QWORD PTR [r14],rax
  40739a:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40739f:	01 c9                	add    ecx,ecx
  4073a1:	b8 03 00 00 00       	mov    eax,0x3
  4073a6:	d3 e0                	shl    eax,cl
  4073a8:	f7 d0                	not    eax
  4073aa:	83 e0 fc             	and    eax,0xfffffffc
  4073ad:	48 31 c9             	xor    rcx,rcx
  4073b0:	48 31 d2             	xor    rdx,rdx
  4073b3:	0f 01 ef             	wrpkru 
  4073b6:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4073bd:	be ad de 
  4073c0:	49 39 c7             	cmp    r15,rax
  4073c3:	4c 89 c0             	mov    rax,r8
  4073c6:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  4073ca:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  4073cd:	41 5f                	pop    r15
  4073cf:	41 5e                	pop    r14
  4073d1:	41 5d                	pop    r13
  4073d3:	41 5c                	pop    r12
  4073d5:	5b                   	pop    rbx
  4073d6:	5d                   	pop    rbp
  4073d7:	c3                   	ret    
  4073d8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4073df:	00 

00000000004073e0 <__cosrt_extern_capmgr_set_tls>:
  4073e0:	48 b8 a4 c1 45 00 00 	movabs rax,0x45c1a4
  4073e7:	00 00 00 
  4073ea:	ff 10                	call   QWORD PTR [rax]
  4073ec:	c3                   	ret    
  4073ed:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004073f0 <__cosrt_fast_callgate_capmgr_set_tls>:
  4073f0:	55                   	push   rbp
  4073f1:	41 55                	push   r13
  4073f3:	41 56                	push   r14
  4073f5:	41 57                	push   r15
  4073f7:	49 89 c8             	mov    r8,rcx
  4073fa:	49 89 d1             	mov    r9,rdx
  4073fd:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  407404:	be ad de 
  407407:	0f 01 f9             	rdtscp 
  40740a:	48 89 c8             	mov    rax,rcx
  40740d:	48 25 ff 0f 00 00    	and    rax,0xfff
  407413:	48 89 e2             	mov    rdx,rsp
  407416:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40741d:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  407424:	00 
  407425:	48 c1 e0 10          	shl    rax,0x10
  407429:	49 09 c5             	or     r13,rax
  40742c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  407433:	7f 00 00 
  407436:	4c 89 e8             	mov    rax,r13
  407439:	48 25 ff ff 00 00    	and    rax,0xffff
  40743f:	48 c1 e0 08          	shl    rax,0x8
  407443:	49 01 c6             	add    r14,rax
  407446:	b9 01 00 00 00       	mov    ecx,0x1
  40744b:	01 c9                	add    ecx,ecx
  40744d:	b8 03 00 00 00       	mov    eax,0x3
  407452:	d3 e0                	shl    eax,cl
  407454:	f7 d0                	not    eax
  407456:	83 e0 fc             	and    eax,0xfffffffc
  407459:	48 31 c9             	xor    rcx,rcx
  40745c:	48 31 d2             	xor    rdx,rdx
  40745f:	0f 01 ef             	wrpkru 
  407462:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  407465:	48 83 c2 01          	add    rdx,0x1
  407469:	48 c1 e2 04          	shl    rdx,0x4
  40746d:	4c 01 f2             	add    rdx,r14
  407470:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  407477:	45 23 01 
  40747a:	48 89 02             	mov    QWORD PTR [rdx],rax
  40747d:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  407481:	49 8b 06             	mov    rax,QWORD PTR [r14]
  407484:	48 83 c0 01          	add    rax,0x1
  407488:	49 89 06             	mov    QWORD PTR [r14],rax
  40748b:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407490:	01 c9                	add    ecx,ecx
  407492:	b8 03 00 00 00       	mov    eax,0x3
  407497:	d3 e0                	shl    eax,cl
  407499:	f7 d0                	not    eax
  40749b:	83 e0 fc             	and    eax,0xfffffffc
  40749e:	48 31 c9             	xor    rcx,rcx
  4074a1:	48 31 d2             	xor    rdx,rdx
  4074a4:	0f 01 ef             	wrpkru 
  4074a7:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  4074ae:	45 23 01 
  4074b1:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4074b8:	be ad de 
  4074bb:	49 39 c7             	cmp    r15,rax
  4074be:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  4074c5:	12 12 12 
  4074c8:	48 b9 d4 74 40 00 00 	movabs rcx,0x4074d4
  4074cf:	00 00 00 
  4074d2:	ff e0                	jmp    rax

00000000004074d4 <srv_call_ret_capmgr_set_tls>:
  4074d4:	49 89 c0             	mov    r8,rax
  4074d7:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4074de:	be ad de 
  4074e1:	48 89 e2             	mov    rdx,rsp
  4074e4:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4074eb:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4074f2:	00 
  4074f3:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4074fa:	7f 00 00 
  4074fd:	4c 89 e8             	mov    rax,r13
  407500:	48 25 ff ff 00 00    	and    rax,0xffff
  407506:	48 c1 e0 08          	shl    rax,0x8
  40750a:	49 01 c6             	add    r14,rax
  40750d:	b9 01 00 00 00       	mov    ecx,0x1
  407512:	01 c9                	add    ecx,ecx
  407514:	b8 03 00 00 00       	mov    eax,0x3
  407519:	d3 e0                	shl    eax,cl
  40751b:	f7 d0                	not    eax
  40751d:	83 e0 fc             	and    eax,0xfffffffc
  407520:	48 31 c9             	xor    rcx,rcx
  407523:	48 31 d2             	xor    rdx,rdx
  407526:	0f 01 ef             	wrpkru 
  407529:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40752c:	48 c1 e2 04          	shl    rdx,0x4
  407530:	4c 01 f2             	add    rdx,r14
  407533:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  407537:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40753a:	48 83 e8 01          	sub    rax,0x1
  40753e:	49 89 06             	mov    QWORD PTR [r14],rax
  407541:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407546:	01 c9                	add    ecx,ecx
  407548:	b8 03 00 00 00       	mov    eax,0x3
  40754d:	d3 e0                	shl    eax,cl
  40754f:	f7 d0                	not    eax
  407551:	83 e0 fc             	and    eax,0xfffffffc
  407554:	48 31 c9             	xor    rcx,rcx
  407557:	48 31 d2             	xor    rdx,rdx
  40755a:	0f 01 ef             	wrpkru 
  40755d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407564:	be ad de 
  407567:	49 39 c7             	cmp    r15,rax
  40756a:	4c 89 c0             	mov    rax,r8
  40756d:	41 5f                	pop    r15
  40756f:	41 5e                	pop    r14
  407571:	41 5d                	pop    r13
  407573:	5d                   	pop    rbp
  407574:	c3                   	ret    
  407575:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40757c:	00 00 00 00 

0000000000407580 <__cosrt_extern_capmgr_asnd_create>:
  407580:	48 b8 bc c1 45 00 00 	movabs rax,0x45c1bc
  407587:	00 00 00 
  40758a:	ff 10                	call   QWORD PTR [rax]
  40758c:	c3                   	ret    
  40758d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000407590 <__cosrt_fast_callgate_capmgr_asnd_create>:
  407590:	55                   	push   rbp
  407591:	41 55                	push   r13
  407593:	41 56                	push   r14
  407595:	41 57                	push   r15
  407597:	49 89 c8             	mov    r8,rcx
  40759a:	49 89 d1             	mov    r9,rdx
  40759d:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4075a4:	be ad de 
  4075a7:	0f 01 f9             	rdtscp 
  4075aa:	48 89 c8             	mov    rax,rcx
  4075ad:	48 25 ff 0f 00 00    	and    rax,0xfff
  4075b3:	48 89 e2             	mov    rdx,rsp
  4075b6:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4075bd:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4075c4:	00 
  4075c5:	48 c1 e0 10          	shl    rax,0x10
  4075c9:	49 09 c5             	or     r13,rax
  4075cc:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4075d3:	7f 00 00 
  4075d6:	4c 89 e8             	mov    rax,r13
  4075d9:	48 25 ff ff 00 00    	and    rax,0xffff
  4075df:	48 c1 e0 08          	shl    rax,0x8
  4075e3:	49 01 c6             	add    r14,rax
  4075e6:	b9 01 00 00 00       	mov    ecx,0x1
  4075eb:	01 c9                	add    ecx,ecx
  4075ed:	b8 03 00 00 00       	mov    eax,0x3
  4075f2:	d3 e0                	shl    eax,cl
  4075f4:	f7 d0                	not    eax
  4075f6:	83 e0 fc             	and    eax,0xfffffffc
  4075f9:	48 31 c9             	xor    rcx,rcx
  4075fc:	48 31 d2             	xor    rdx,rdx
  4075ff:	0f 01 ef             	wrpkru 
  407602:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  407605:	48 83 c2 01          	add    rdx,0x1
  407609:	48 c1 e2 04          	shl    rdx,0x4
  40760d:	4c 01 f2             	add    rdx,r14
  407610:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  407617:	45 23 01 
  40761a:	48 89 02             	mov    QWORD PTR [rdx],rax
  40761d:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  407621:	49 8b 06             	mov    rax,QWORD PTR [r14]
  407624:	48 83 c0 01          	add    rax,0x1
  407628:	49 89 06             	mov    QWORD PTR [r14],rax
  40762b:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407630:	01 c9                	add    ecx,ecx
  407632:	b8 03 00 00 00       	mov    eax,0x3
  407637:	d3 e0                	shl    eax,cl
  407639:	f7 d0                	not    eax
  40763b:	83 e0 fc             	and    eax,0xfffffffc
  40763e:	48 31 c9             	xor    rcx,rcx
  407641:	48 31 d2             	xor    rdx,rdx
  407644:	0f 01 ef             	wrpkru 
  407647:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  40764e:	45 23 01 
  407651:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407658:	be ad de 
  40765b:	49 39 c7             	cmp    r15,rax
  40765e:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  407665:	12 12 12 
  407668:	48 b9 74 76 40 00 00 	movabs rcx,0x407674
  40766f:	00 00 00 
  407672:	ff e0                	jmp    rax

0000000000407674 <srv_call_ret_capmgr_asnd_create>:
  407674:	49 89 c0             	mov    r8,rax
  407677:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40767e:	be ad de 
  407681:	48 89 e2             	mov    rdx,rsp
  407684:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40768b:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  407692:	00 
  407693:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40769a:	7f 00 00 
  40769d:	4c 89 e8             	mov    rax,r13
  4076a0:	48 25 ff ff 00 00    	and    rax,0xffff
  4076a6:	48 c1 e0 08          	shl    rax,0x8
  4076aa:	49 01 c6             	add    r14,rax
  4076ad:	b9 01 00 00 00       	mov    ecx,0x1
  4076b2:	01 c9                	add    ecx,ecx
  4076b4:	b8 03 00 00 00       	mov    eax,0x3
  4076b9:	d3 e0                	shl    eax,cl
  4076bb:	f7 d0                	not    eax
  4076bd:	83 e0 fc             	and    eax,0xfffffffc
  4076c0:	48 31 c9             	xor    rcx,rcx
  4076c3:	48 31 d2             	xor    rdx,rdx
  4076c6:	0f 01 ef             	wrpkru 
  4076c9:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4076cc:	48 c1 e2 04          	shl    rdx,0x4
  4076d0:	4c 01 f2             	add    rdx,r14
  4076d3:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  4076d7:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4076da:	48 83 e8 01          	sub    rax,0x1
  4076de:	49 89 06             	mov    QWORD PTR [r14],rax
  4076e1:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4076e6:	01 c9                	add    ecx,ecx
  4076e8:	b8 03 00 00 00       	mov    eax,0x3
  4076ed:	d3 e0                	shl    eax,cl
  4076ef:	f7 d0                	not    eax
  4076f1:	83 e0 fc             	and    eax,0xfffffffc
  4076f4:	48 31 c9             	xor    rcx,rcx
  4076f7:	48 31 d2             	xor    rdx,rdx
  4076fa:	0f 01 ef             	wrpkru 
  4076fd:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407704:	be ad de 
  407707:	49 39 c7             	cmp    r15,rax
  40770a:	4c 89 c0             	mov    rax,r8
  40770d:	41 5f                	pop    r15
  40770f:	41 5e                	pop    r14
  407711:	41 5d                	pop    r13
  407713:	5d                   	pop    rbp
  407714:	c3                   	ret    
  407715:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40771c:	00 00 00 00 

0000000000407720 <__cosrt_extern_capmgr_asnd_rcv_create>:
  407720:	48 b8 d4 c1 45 00 00 	movabs rax,0x45c1d4
  407727:	00 00 00 
  40772a:	ff 10                	call   QWORD PTR [rax]
  40772c:	c3                   	ret    
  40772d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000407730 <__cosrt_fast_callgate_capmgr_asnd_rcv_create>:
  407730:	55                   	push   rbp
  407731:	41 55                	push   r13
  407733:	41 56                	push   r14
  407735:	41 57                	push   r15
  407737:	49 89 c8             	mov    r8,rcx
  40773a:	49 89 d1             	mov    r9,rdx
  40773d:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  407744:	be ad de 
  407747:	0f 01 f9             	rdtscp 
  40774a:	48 89 c8             	mov    rax,rcx
  40774d:	48 25 ff 0f 00 00    	and    rax,0xfff
  407753:	48 89 e2             	mov    rdx,rsp
  407756:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40775d:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  407764:	00 
  407765:	48 c1 e0 10          	shl    rax,0x10
  407769:	49 09 c5             	or     r13,rax
  40776c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  407773:	7f 00 00 
  407776:	4c 89 e8             	mov    rax,r13
  407779:	48 25 ff ff 00 00    	and    rax,0xffff
  40777f:	48 c1 e0 08          	shl    rax,0x8
  407783:	49 01 c6             	add    r14,rax
  407786:	b9 01 00 00 00       	mov    ecx,0x1
  40778b:	01 c9                	add    ecx,ecx
  40778d:	b8 03 00 00 00       	mov    eax,0x3
  407792:	d3 e0                	shl    eax,cl
  407794:	f7 d0                	not    eax
  407796:	83 e0 fc             	and    eax,0xfffffffc
  407799:	48 31 c9             	xor    rcx,rcx
  40779c:	48 31 d2             	xor    rdx,rdx
  40779f:	0f 01 ef             	wrpkru 
  4077a2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4077a5:	48 83 c2 01          	add    rdx,0x1
  4077a9:	48 c1 e2 04          	shl    rdx,0x4
  4077ad:	4c 01 f2             	add    rdx,r14
  4077b0:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  4077b7:	45 23 01 
  4077ba:	48 89 02             	mov    QWORD PTR [rdx],rax
  4077bd:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  4077c1:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4077c4:	48 83 c0 01          	add    rax,0x1
  4077c8:	49 89 06             	mov    QWORD PTR [r14],rax
  4077cb:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4077d0:	01 c9                	add    ecx,ecx
  4077d2:	b8 03 00 00 00       	mov    eax,0x3
  4077d7:	d3 e0                	shl    eax,cl
  4077d9:	f7 d0                	not    eax
  4077db:	83 e0 fc             	and    eax,0xfffffffc
  4077de:	48 31 c9             	xor    rcx,rcx
  4077e1:	48 31 d2             	xor    rdx,rdx
  4077e4:	0f 01 ef             	wrpkru 
  4077e7:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  4077ee:	45 23 01 
  4077f1:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4077f8:	be ad de 
  4077fb:	49 39 c7             	cmp    r15,rax
  4077fe:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  407805:	12 12 12 
  407808:	48 b9 14 78 40 00 00 	movabs rcx,0x407814
  40780f:	00 00 00 
  407812:	ff e0                	jmp    rax

0000000000407814 <srv_call_ret_capmgr_asnd_rcv_create>:
  407814:	49 89 c0             	mov    r8,rax
  407817:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40781e:	be ad de 
  407821:	48 89 e2             	mov    rdx,rsp
  407824:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40782b:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  407832:	00 
  407833:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40783a:	7f 00 00 
  40783d:	4c 89 e8             	mov    rax,r13
  407840:	48 25 ff ff 00 00    	and    rax,0xffff
  407846:	48 c1 e0 08          	shl    rax,0x8
  40784a:	49 01 c6             	add    r14,rax
  40784d:	b9 01 00 00 00       	mov    ecx,0x1
  407852:	01 c9                	add    ecx,ecx
  407854:	b8 03 00 00 00       	mov    eax,0x3
  407859:	d3 e0                	shl    eax,cl
  40785b:	f7 d0                	not    eax
  40785d:	83 e0 fc             	and    eax,0xfffffffc
  407860:	48 31 c9             	xor    rcx,rcx
  407863:	48 31 d2             	xor    rdx,rdx
  407866:	0f 01 ef             	wrpkru 
  407869:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40786c:	48 c1 e2 04          	shl    rdx,0x4
  407870:	4c 01 f2             	add    rdx,r14
  407873:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  407877:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40787a:	48 83 e8 01          	sub    rax,0x1
  40787e:	49 89 06             	mov    QWORD PTR [r14],rax
  407881:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407886:	01 c9                	add    ecx,ecx
  407888:	b8 03 00 00 00       	mov    eax,0x3
  40788d:	d3 e0                	shl    eax,cl
  40788f:	f7 d0                	not    eax
  407891:	83 e0 fc             	and    eax,0xfffffffc
  407894:	48 31 c9             	xor    rcx,rcx
  407897:	48 31 d2             	xor    rdx,rdx
  40789a:	0f 01 ef             	wrpkru 
  40789d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4078a4:	be ad de 
  4078a7:	49 39 c7             	cmp    r15,rax
  4078aa:	4c 89 c0             	mov    rax,r8
  4078ad:	41 5f                	pop    r15
  4078af:	41 5e                	pop    r14
  4078b1:	41 5d                	pop    r13
  4078b3:	5d                   	pop    rbp
  4078b4:	c3                   	ret    
  4078b5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4078bc:	00 00 00 00 

00000000004078c0 <__cosrt_extern_capmgr_asnd_key_create>:
  4078c0:	48 b8 ec c1 45 00 00 	movabs rax,0x45c1ec
  4078c7:	00 00 00 
  4078ca:	ff 10                	call   QWORD PTR [rax]
  4078cc:	c3                   	ret    
  4078cd:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004078d0 <__cosrt_fast_callgate_capmgr_asnd_key_create>:
  4078d0:	55                   	push   rbp
  4078d1:	41 55                	push   r13
  4078d3:	41 56                	push   r14
  4078d5:	41 57                	push   r15
  4078d7:	49 89 c8             	mov    r8,rcx
  4078da:	49 89 d1             	mov    r9,rdx
  4078dd:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4078e4:	be ad de 
  4078e7:	0f 01 f9             	rdtscp 
  4078ea:	48 89 c8             	mov    rax,rcx
  4078ed:	48 25 ff 0f 00 00    	and    rax,0xfff
  4078f3:	48 89 e2             	mov    rdx,rsp
  4078f6:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4078fd:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  407904:	00 
  407905:	48 c1 e0 10          	shl    rax,0x10
  407909:	49 09 c5             	or     r13,rax
  40790c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  407913:	7f 00 00 
  407916:	4c 89 e8             	mov    rax,r13
  407919:	48 25 ff ff 00 00    	and    rax,0xffff
  40791f:	48 c1 e0 08          	shl    rax,0x8
  407923:	49 01 c6             	add    r14,rax
  407926:	b9 01 00 00 00       	mov    ecx,0x1
  40792b:	01 c9                	add    ecx,ecx
  40792d:	b8 03 00 00 00       	mov    eax,0x3
  407932:	d3 e0                	shl    eax,cl
  407934:	f7 d0                	not    eax
  407936:	83 e0 fc             	and    eax,0xfffffffc
  407939:	48 31 c9             	xor    rcx,rcx
  40793c:	48 31 d2             	xor    rdx,rdx
  40793f:	0f 01 ef             	wrpkru 
  407942:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  407945:	48 83 c2 01          	add    rdx,0x1
  407949:	48 c1 e2 04          	shl    rdx,0x4
  40794d:	4c 01 f2             	add    rdx,r14
  407950:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  407957:	45 23 01 
  40795a:	48 89 02             	mov    QWORD PTR [rdx],rax
  40795d:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  407961:	49 8b 06             	mov    rax,QWORD PTR [r14]
  407964:	48 83 c0 01          	add    rax,0x1
  407968:	49 89 06             	mov    QWORD PTR [r14],rax
  40796b:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407970:	01 c9                	add    ecx,ecx
  407972:	b8 03 00 00 00       	mov    eax,0x3
  407977:	d3 e0                	shl    eax,cl
  407979:	f7 d0                	not    eax
  40797b:	83 e0 fc             	and    eax,0xfffffffc
  40797e:	48 31 c9             	xor    rcx,rcx
  407981:	48 31 d2             	xor    rdx,rdx
  407984:	0f 01 ef             	wrpkru 
  407987:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  40798e:	45 23 01 
  407991:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407998:	be ad de 
  40799b:	49 39 c7             	cmp    r15,rax
  40799e:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  4079a5:	12 12 12 
  4079a8:	48 b9 b4 79 40 00 00 	movabs rcx,0x4079b4
  4079af:	00 00 00 
  4079b2:	ff e0                	jmp    rax

00000000004079b4 <srv_call_ret_capmgr_asnd_key_create>:
  4079b4:	49 89 c0             	mov    r8,rax
  4079b7:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4079be:	be ad de 
  4079c1:	48 89 e2             	mov    rdx,rsp
  4079c4:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4079cb:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4079d2:	00 
  4079d3:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4079da:	7f 00 00 
  4079dd:	4c 89 e8             	mov    rax,r13
  4079e0:	48 25 ff ff 00 00    	and    rax,0xffff
  4079e6:	48 c1 e0 08          	shl    rax,0x8
  4079ea:	49 01 c6             	add    r14,rax
  4079ed:	b9 01 00 00 00       	mov    ecx,0x1
  4079f2:	01 c9                	add    ecx,ecx
  4079f4:	b8 03 00 00 00       	mov    eax,0x3
  4079f9:	d3 e0                	shl    eax,cl
  4079fb:	f7 d0                	not    eax
  4079fd:	83 e0 fc             	and    eax,0xfffffffc
  407a00:	48 31 c9             	xor    rcx,rcx
  407a03:	48 31 d2             	xor    rdx,rdx
  407a06:	0f 01 ef             	wrpkru 
  407a09:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  407a0c:	48 c1 e2 04          	shl    rdx,0x4
  407a10:	4c 01 f2             	add    rdx,r14
  407a13:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  407a17:	49 8b 06             	mov    rax,QWORD PTR [r14]
  407a1a:	48 83 e8 01          	sub    rax,0x1
  407a1e:	49 89 06             	mov    QWORD PTR [r14],rax
  407a21:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407a26:	01 c9                	add    ecx,ecx
  407a28:	b8 03 00 00 00       	mov    eax,0x3
  407a2d:	d3 e0                	shl    eax,cl
  407a2f:	f7 d0                	not    eax
  407a31:	83 e0 fc             	and    eax,0xfffffffc
  407a34:	48 31 c9             	xor    rcx,rcx
  407a37:	48 31 d2             	xor    rdx,rdx
  407a3a:	0f 01 ef             	wrpkru 
  407a3d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407a44:	be ad de 
  407a47:	49 39 c7             	cmp    r15,rax
  407a4a:	4c 89 c0             	mov    rax,r8
  407a4d:	41 5f                	pop    r15
  407a4f:	41 5e                	pop    r14
  407a51:	41 5d                	pop    r13
  407a53:	5d                   	pop    rbp
  407a54:	c3                   	ret    
  407a55:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  407a5c:	00 00 00 00 

0000000000407a60 <__cosrt_extern_capmgr_vm_comp_create>:
  407a60:	48 b8 04 c2 45 00 00 	movabs rax,0x45c204
  407a67:	00 00 00 
  407a6a:	ff 10                	call   QWORD PTR [rax]
  407a6c:	c3                   	ret    
  407a6d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000407a70 <__cosrt_fast_callgate_capmgr_vm_comp_create>:
  407a70:	55                   	push   rbp
  407a71:	41 55                	push   r13
  407a73:	41 56                	push   r14
  407a75:	41 57                	push   r15
  407a77:	49 89 c8             	mov    r8,rcx
  407a7a:	49 89 d1             	mov    r9,rdx
  407a7d:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  407a84:	be ad de 
  407a87:	0f 01 f9             	rdtscp 
  407a8a:	48 89 c8             	mov    rax,rcx
  407a8d:	48 25 ff 0f 00 00    	and    rax,0xfff
  407a93:	48 89 e2             	mov    rdx,rsp
  407a96:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  407a9d:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  407aa4:	00 
  407aa5:	48 c1 e0 10          	shl    rax,0x10
  407aa9:	49 09 c5             	or     r13,rax
  407aac:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  407ab3:	7f 00 00 
  407ab6:	4c 89 e8             	mov    rax,r13
  407ab9:	48 25 ff ff 00 00    	and    rax,0xffff
  407abf:	48 c1 e0 08          	shl    rax,0x8
  407ac3:	49 01 c6             	add    r14,rax
  407ac6:	b9 01 00 00 00       	mov    ecx,0x1
  407acb:	01 c9                	add    ecx,ecx
  407acd:	b8 03 00 00 00       	mov    eax,0x3
  407ad2:	d3 e0                	shl    eax,cl
  407ad4:	f7 d0                	not    eax
  407ad6:	83 e0 fc             	and    eax,0xfffffffc
  407ad9:	48 31 c9             	xor    rcx,rcx
  407adc:	48 31 d2             	xor    rdx,rdx
  407adf:	0f 01 ef             	wrpkru 
  407ae2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  407ae5:	48 83 c2 01          	add    rdx,0x1
  407ae9:	48 c1 e2 04          	shl    rdx,0x4
  407aed:	4c 01 f2             	add    rdx,r14
  407af0:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  407af7:	45 23 01 
  407afa:	48 89 02             	mov    QWORD PTR [rdx],rax
  407afd:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  407b01:	49 8b 06             	mov    rax,QWORD PTR [r14]
  407b04:	48 83 c0 01          	add    rax,0x1
  407b08:	49 89 06             	mov    QWORD PTR [r14],rax
  407b0b:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407b10:	01 c9                	add    ecx,ecx
  407b12:	b8 03 00 00 00       	mov    eax,0x3
  407b17:	d3 e0                	shl    eax,cl
  407b19:	f7 d0                	not    eax
  407b1b:	83 e0 fc             	and    eax,0xfffffffc
  407b1e:	48 31 c9             	xor    rcx,rcx
  407b21:	48 31 d2             	xor    rdx,rdx
  407b24:	0f 01 ef             	wrpkru 
  407b27:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  407b2e:	45 23 01 
  407b31:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407b38:	be ad de 
  407b3b:	49 39 c7             	cmp    r15,rax
  407b3e:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  407b45:	12 12 12 
  407b48:	48 b9 54 7b 40 00 00 	movabs rcx,0x407b54
  407b4f:	00 00 00 
  407b52:	ff e0                	jmp    rax

0000000000407b54 <srv_call_ret_capmgr_vm_comp_create>:
  407b54:	49 89 c0             	mov    r8,rax
  407b57:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  407b5e:	be ad de 
  407b61:	48 89 e2             	mov    rdx,rsp
  407b64:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  407b6b:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  407b72:	00 
  407b73:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  407b7a:	7f 00 00 
  407b7d:	4c 89 e8             	mov    rax,r13
  407b80:	48 25 ff ff 00 00    	and    rax,0xffff
  407b86:	48 c1 e0 08          	shl    rax,0x8
  407b8a:	49 01 c6             	add    r14,rax
  407b8d:	b9 01 00 00 00       	mov    ecx,0x1
  407b92:	01 c9                	add    ecx,ecx
  407b94:	b8 03 00 00 00       	mov    eax,0x3
  407b99:	d3 e0                	shl    eax,cl
  407b9b:	f7 d0                	not    eax
  407b9d:	83 e0 fc             	and    eax,0xfffffffc
  407ba0:	48 31 c9             	xor    rcx,rcx
  407ba3:	48 31 d2             	xor    rdx,rdx
  407ba6:	0f 01 ef             	wrpkru 
  407ba9:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  407bac:	48 c1 e2 04          	shl    rdx,0x4
  407bb0:	4c 01 f2             	add    rdx,r14
  407bb3:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  407bb7:	49 8b 06             	mov    rax,QWORD PTR [r14]
  407bba:	48 83 e8 01          	sub    rax,0x1
  407bbe:	49 89 06             	mov    QWORD PTR [r14],rax
  407bc1:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407bc6:	01 c9                	add    ecx,ecx
  407bc8:	b8 03 00 00 00       	mov    eax,0x3
  407bcd:	d3 e0                	shl    eax,cl
  407bcf:	f7 d0                	not    eax
  407bd1:	83 e0 fc             	and    eax,0xfffffffc
  407bd4:	48 31 c9             	xor    rcx,rcx
  407bd7:	48 31 d2             	xor    rdx,rdx
  407bda:	0f 01 ef             	wrpkru 
  407bdd:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407be4:	be ad de 
  407be7:	49 39 c7             	cmp    r15,rax
  407bea:	4c 89 c0             	mov    rax,r8
  407bed:	41 5f                	pop    r15
  407bef:	41 5e                	pop    r14
  407bf1:	41 5d                	pop    r13
  407bf3:	5d                   	pop    rbp
  407bf4:	c3                   	ret    
  407bf5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  407bfc:	00 00 00 00 

0000000000407c00 <__cosrt_extern_capmgr_vm_shared_kernel_page_create_at>:
  407c00:	48 b8 1c c2 45 00 00 	movabs rax,0x45c21c
  407c07:	00 00 00 
  407c0a:	ff 10                	call   QWORD PTR [rax]
  407c0c:	c3                   	ret    
  407c0d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000407c10 <__cosrt_fast_callgate_capmgr_vm_shared_kernel_page_create_at>:
  407c10:	55                   	push   rbp
  407c11:	41 55                	push   r13
  407c13:	41 56                	push   r14
  407c15:	41 57                	push   r15
  407c17:	49 89 c8             	mov    r8,rcx
  407c1a:	49 89 d1             	mov    r9,rdx
  407c1d:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  407c24:	be ad de 
  407c27:	0f 01 f9             	rdtscp 
  407c2a:	48 89 c8             	mov    rax,rcx
  407c2d:	48 25 ff 0f 00 00    	and    rax,0xfff
  407c33:	48 89 e2             	mov    rdx,rsp
  407c36:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  407c3d:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  407c44:	00 
  407c45:	48 c1 e0 10          	shl    rax,0x10
  407c49:	49 09 c5             	or     r13,rax
  407c4c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  407c53:	7f 00 00 
  407c56:	4c 89 e8             	mov    rax,r13
  407c59:	48 25 ff ff 00 00    	and    rax,0xffff
  407c5f:	48 c1 e0 08          	shl    rax,0x8
  407c63:	49 01 c6             	add    r14,rax
  407c66:	b9 01 00 00 00       	mov    ecx,0x1
  407c6b:	01 c9                	add    ecx,ecx
  407c6d:	b8 03 00 00 00       	mov    eax,0x3
  407c72:	d3 e0                	shl    eax,cl
  407c74:	f7 d0                	not    eax
  407c76:	83 e0 fc             	and    eax,0xfffffffc
  407c79:	48 31 c9             	xor    rcx,rcx
  407c7c:	48 31 d2             	xor    rdx,rdx
  407c7f:	0f 01 ef             	wrpkru 
  407c82:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  407c85:	48 83 c2 01          	add    rdx,0x1
  407c89:	48 c1 e2 04          	shl    rdx,0x4
  407c8d:	4c 01 f2             	add    rdx,r14
  407c90:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  407c97:	45 23 01 
  407c9a:	48 89 02             	mov    QWORD PTR [rdx],rax
  407c9d:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  407ca1:	49 8b 06             	mov    rax,QWORD PTR [r14]
  407ca4:	48 83 c0 01          	add    rax,0x1
  407ca8:	49 89 06             	mov    QWORD PTR [r14],rax
  407cab:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407cb0:	01 c9                	add    ecx,ecx
  407cb2:	b8 03 00 00 00       	mov    eax,0x3
  407cb7:	d3 e0                	shl    eax,cl
  407cb9:	f7 d0                	not    eax
  407cbb:	83 e0 fc             	and    eax,0xfffffffc
  407cbe:	48 31 c9             	xor    rcx,rcx
  407cc1:	48 31 d2             	xor    rdx,rdx
  407cc4:	0f 01 ef             	wrpkru 
  407cc7:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  407cce:	45 23 01 
  407cd1:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407cd8:	be ad de 
  407cdb:	49 39 c7             	cmp    r15,rax
  407cde:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  407ce5:	12 12 12 
  407ce8:	48 b9 f4 7c 40 00 00 	movabs rcx,0x407cf4
  407cef:	00 00 00 
  407cf2:	ff e0                	jmp    rax

0000000000407cf4 <srv_call_ret_capmgr_vm_shared_kernel_page_create_at>:
  407cf4:	49 89 c0             	mov    r8,rax
  407cf7:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  407cfe:	be ad de 
  407d01:	48 89 e2             	mov    rdx,rsp
  407d04:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  407d0b:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  407d12:	00 
  407d13:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  407d1a:	7f 00 00 
  407d1d:	4c 89 e8             	mov    rax,r13
  407d20:	48 25 ff ff 00 00    	and    rax,0xffff
  407d26:	48 c1 e0 08          	shl    rax,0x8
  407d2a:	49 01 c6             	add    r14,rax
  407d2d:	b9 01 00 00 00       	mov    ecx,0x1
  407d32:	01 c9                	add    ecx,ecx
  407d34:	b8 03 00 00 00       	mov    eax,0x3
  407d39:	d3 e0                	shl    eax,cl
  407d3b:	f7 d0                	not    eax
  407d3d:	83 e0 fc             	and    eax,0xfffffffc
  407d40:	48 31 c9             	xor    rcx,rcx
  407d43:	48 31 d2             	xor    rdx,rdx
  407d46:	0f 01 ef             	wrpkru 
  407d49:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  407d4c:	48 c1 e2 04          	shl    rdx,0x4
  407d50:	4c 01 f2             	add    rdx,r14
  407d53:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  407d57:	49 8b 06             	mov    rax,QWORD PTR [r14]
  407d5a:	48 83 e8 01          	sub    rax,0x1
  407d5e:	49 89 06             	mov    QWORD PTR [r14],rax
  407d61:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407d66:	01 c9                	add    ecx,ecx
  407d68:	b8 03 00 00 00       	mov    eax,0x3
  407d6d:	d3 e0                	shl    eax,cl
  407d6f:	f7 d0                	not    eax
  407d71:	83 e0 fc             	and    eax,0xfffffffc
  407d74:	48 31 c9             	xor    rcx,rcx
  407d77:	48 31 d2             	xor    rdx,rdx
  407d7a:	0f 01 ef             	wrpkru 
  407d7d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407d84:	be ad de 
  407d87:	49 39 c7             	cmp    r15,rax
  407d8a:	4c 89 c0             	mov    rax,r8
  407d8d:	41 5f                	pop    r15
  407d8f:	41 5e                	pop    r14
  407d91:	41 5d                	pop    r13
  407d93:	5d                   	pop    rbp
  407d94:	c3                   	ret    
  407d95:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  407d9c:	00 00 00 00 

0000000000407da0 <__cosrt_extern_capmgr_vm_vmcs_create>:
  407da0:	48 b8 34 c2 45 00 00 	movabs rax,0x45c234
  407da7:	00 00 00 
  407daa:	ff 10                	call   QWORD PTR [rax]
  407dac:	c3                   	ret    
  407dad:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000407db0 <__cosrt_fast_callgate_capmgr_vm_vmcs_create>:
  407db0:	55                   	push   rbp
  407db1:	41 55                	push   r13
  407db3:	41 56                	push   r14
  407db5:	41 57                	push   r15
  407db7:	49 89 c8             	mov    r8,rcx
  407dba:	49 89 d1             	mov    r9,rdx
  407dbd:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  407dc4:	be ad de 
  407dc7:	0f 01 f9             	rdtscp 
  407dca:	48 89 c8             	mov    rax,rcx
  407dcd:	48 25 ff 0f 00 00    	and    rax,0xfff
  407dd3:	48 89 e2             	mov    rdx,rsp
  407dd6:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  407ddd:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  407de4:	00 
  407de5:	48 c1 e0 10          	shl    rax,0x10
  407de9:	49 09 c5             	or     r13,rax
  407dec:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  407df3:	7f 00 00 
  407df6:	4c 89 e8             	mov    rax,r13
  407df9:	48 25 ff ff 00 00    	and    rax,0xffff
  407dff:	48 c1 e0 08          	shl    rax,0x8
  407e03:	49 01 c6             	add    r14,rax
  407e06:	b9 01 00 00 00       	mov    ecx,0x1
  407e0b:	01 c9                	add    ecx,ecx
  407e0d:	b8 03 00 00 00       	mov    eax,0x3
  407e12:	d3 e0                	shl    eax,cl
  407e14:	f7 d0                	not    eax
  407e16:	83 e0 fc             	and    eax,0xfffffffc
  407e19:	48 31 c9             	xor    rcx,rcx
  407e1c:	48 31 d2             	xor    rdx,rdx
  407e1f:	0f 01 ef             	wrpkru 
  407e22:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  407e25:	48 83 c2 01          	add    rdx,0x1
  407e29:	48 c1 e2 04          	shl    rdx,0x4
  407e2d:	4c 01 f2             	add    rdx,r14
  407e30:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  407e37:	45 23 01 
  407e3a:	48 89 02             	mov    QWORD PTR [rdx],rax
  407e3d:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  407e41:	49 8b 06             	mov    rax,QWORD PTR [r14]
  407e44:	48 83 c0 01          	add    rax,0x1
  407e48:	49 89 06             	mov    QWORD PTR [r14],rax
  407e4b:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407e50:	01 c9                	add    ecx,ecx
  407e52:	b8 03 00 00 00       	mov    eax,0x3
  407e57:	d3 e0                	shl    eax,cl
  407e59:	f7 d0                	not    eax
  407e5b:	83 e0 fc             	and    eax,0xfffffffc
  407e5e:	48 31 c9             	xor    rcx,rcx
  407e61:	48 31 d2             	xor    rdx,rdx
  407e64:	0f 01 ef             	wrpkru 
  407e67:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  407e6e:	45 23 01 
  407e71:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407e78:	be ad de 
  407e7b:	49 39 c7             	cmp    r15,rax
  407e7e:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  407e85:	12 12 12 
  407e88:	48 b9 94 7e 40 00 00 	movabs rcx,0x407e94
  407e8f:	00 00 00 
  407e92:	ff e0                	jmp    rax

0000000000407e94 <srv_call_ret_capmgr_vm_vmcs_create>:
  407e94:	49 89 c0             	mov    r8,rax
  407e97:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  407e9e:	be ad de 
  407ea1:	48 89 e2             	mov    rdx,rsp
  407ea4:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  407eab:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  407eb2:	00 
  407eb3:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  407eba:	7f 00 00 
  407ebd:	4c 89 e8             	mov    rax,r13
  407ec0:	48 25 ff ff 00 00    	and    rax,0xffff
  407ec6:	48 c1 e0 08          	shl    rax,0x8
  407eca:	49 01 c6             	add    r14,rax
  407ecd:	b9 01 00 00 00       	mov    ecx,0x1
  407ed2:	01 c9                	add    ecx,ecx
  407ed4:	b8 03 00 00 00       	mov    eax,0x3
  407ed9:	d3 e0                	shl    eax,cl
  407edb:	f7 d0                	not    eax
  407edd:	83 e0 fc             	and    eax,0xfffffffc
  407ee0:	48 31 c9             	xor    rcx,rcx
  407ee3:	48 31 d2             	xor    rdx,rdx
  407ee6:	0f 01 ef             	wrpkru 
  407ee9:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  407eec:	48 c1 e2 04          	shl    rdx,0x4
  407ef0:	4c 01 f2             	add    rdx,r14
  407ef3:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  407ef7:	49 8b 06             	mov    rax,QWORD PTR [r14]
  407efa:	48 83 e8 01          	sub    rax,0x1
  407efe:	49 89 06             	mov    QWORD PTR [r14],rax
  407f01:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407f06:	01 c9                	add    ecx,ecx
  407f08:	b8 03 00 00 00       	mov    eax,0x3
  407f0d:	d3 e0                	shl    eax,cl
  407f0f:	f7 d0                	not    eax
  407f11:	83 e0 fc             	and    eax,0xfffffffc
  407f14:	48 31 c9             	xor    rcx,rcx
  407f17:	48 31 d2             	xor    rdx,rdx
  407f1a:	0f 01 ef             	wrpkru 
  407f1d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407f24:	be ad de 
  407f27:	49 39 c7             	cmp    r15,rax
  407f2a:	4c 89 c0             	mov    rax,r8
  407f2d:	41 5f                	pop    r15
  407f2f:	41 5e                	pop    r14
  407f31:	41 5d                	pop    r13
  407f33:	5d                   	pop    rbp
  407f34:	c3                   	ret    
  407f35:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  407f3c:	00 00 00 00 

0000000000407f40 <__cosrt_extern_capmgr_vm_msr_bitmap_create>:
  407f40:	48 b8 4c c2 45 00 00 	movabs rax,0x45c24c
  407f47:	00 00 00 
  407f4a:	ff 10                	call   QWORD PTR [rax]
  407f4c:	c3                   	ret    
  407f4d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000407f50 <__cosrt_fast_callgate_capmgr_vm_msr_bitmap_create>:
  407f50:	55                   	push   rbp
  407f51:	41 55                	push   r13
  407f53:	41 56                	push   r14
  407f55:	41 57                	push   r15
  407f57:	49 89 c8             	mov    r8,rcx
  407f5a:	49 89 d1             	mov    r9,rdx
  407f5d:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  407f64:	be ad de 
  407f67:	0f 01 f9             	rdtscp 
  407f6a:	48 89 c8             	mov    rax,rcx
  407f6d:	48 25 ff 0f 00 00    	and    rax,0xfff
  407f73:	48 89 e2             	mov    rdx,rsp
  407f76:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  407f7d:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  407f84:	00 
  407f85:	48 c1 e0 10          	shl    rax,0x10
  407f89:	49 09 c5             	or     r13,rax
  407f8c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  407f93:	7f 00 00 
  407f96:	4c 89 e8             	mov    rax,r13
  407f99:	48 25 ff ff 00 00    	and    rax,0xffff
  407f9f:	48 c1 e0 08          	shl    rax,0x8
  407fa3:	49 01 c6             	add    r14,rax
  407fa6:	b9 01 00 00 00       	mov    ecx,0x1
  407fab:	01 c9                	add    ecx,ecx
  407fad:	b8 03 00 00 00       	mov    eax,0x3
  407fb2:	d3 e0                	shl    eax,cl
  407fb4:	f7 d0                	not    eax
  407fb6:	83 e0 fc             	and    eax,0xfffffffc
  407fb9:	48 31 c9             	xor    rcx,rcx
  407fbc:	48 31 d2             	xor    rdx,rdx
  407fbf:	0f 01 ef             	wrpkru 
  407fc2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  407fc5:	48 83 c2 01          	add    rdx,0x1
  407fc9:	48 c1 e2 04          	shl    rdx,0x4
  407fcd:	4c 01 f2             	add    rdx,r14
  407fd0:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  407fd7:	45 23 01 
  407fda:	48 89 02             	mov    QWORD PTR [rdx],rax
  407fdd:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  407fe1:	49 8b 06             	mov    rax,QWORD PTR [r14]
  407fe4:	48 83 c0 01          	add    rax,0x1
  407fe8:	49 89 06             	mov    QWORD PTR [r14],rax
  407feb:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407ff0:	01 c9                	add    ecx,ecx
  407ff2:	b8 03 00 00 00       	mov    eax,0x3
  407ff7:	d3 e0                	shl    eax,cl
  407ff9:	f7 d0                	not    eax
  407ffb:	83 e0 fc             	and    eax,0xfffffffc
  407ffe:	48 31 c9             	xor    rcx,rcx
  408001:	48 31 d2             	xor    rdx,rdx
  408004:	0f 01 ef             	wrpkru 
  408007:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  40800e:	45 23 01 
  408011:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408018:	be ad de 
  40801b:	49 39 c7             	cmp    r15,rax
  40801e:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  408025:	12 12 12 
  408028:	48 b9 34 80 40 00 00 	movabs rcx,0x408034
  40802f:	00 00 00 
  408032:	ff e0                	jmp    rax

0000000000408034 <srv_call_ret_capmgr_vm_msr_bitmap_create>:
  408034:	49 89 c0             	mov    r8,rax
  408037:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40803e:	be ad de 
  408041:	48 89 e2             	mov    rdx,rsp
  408044:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40804b:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  408052:	00 
  408053:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40805a:	7f 00 00 
  40805d:	4c 89 e8             	mov    rax,r13
  408060:	48 25 ff ff 00 00    	and    rax,0xffff
  408066:	48 c1 e0 08          	shl    rax,0x8
  40806a:	49 01 c6             	add    r14,rax
  40806d:	b9 01 00 00 00       	mov    ecx,0x1
  408072:	01 c9                	add    ecx,ecx
  408074:	b8 03 00 00 00       	mov    eax,0x3
  408079:	d3 e0                	shl    eax,cl
  40807b:	f7 d0                	not    eax
  40807d:	83 e0 fc             	and    eax,0xfffffffc
  408080:	48 31 c9             	xor    rcx,rcx
  408083:	48 31 d2             	xor    rdx,rdx
  408086:	0f 01 ef             	wrpkru 
  408089:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40808c:	48 c1 e2 04          	shl    rdx,0x4
  408090:	4c 01 f2             	add    rdx,r14
  408093:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  408097:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40809a:	48 83 e8 01          	sub    rax,0x1
  40809e:	49 89 06             	mov    QWORD PTR [r14],rax
  4080a1:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4080a6:	01 c9                	add    ecx,ecx
  4080a8:	b8 03 00 00 00       	mov    eax,0x3
  4080ad:	d3 e0                	shl    eax,cl
  4080af:	f7 d0                	not    eax
  4080b1:	83 e0 fc             	and    eax,0xfffffffc
  4080b4:	48 31 c9             	xor    rcx,rcx
  4080b7:	48 31 d2             	xor    rdx,rdx
  4080ba:	0f 01 ef             	wrpkru 
  4080bd:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4080c4:	be ad de 
  4080c7:	49 39 c7             	cmp    r15,rax
  4080ca:	4c 89 c0             	mov    rax,r8
  4080cd:	41 5f                	pop    r15
  4080cf:	41 5e                	pop    r14
  4080d1:	41 5d                	pop    r13
  4080d3:	5d                   	pop    rbp
  4080d4:	c3                   	ret    
  4080d5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4080dc:	00 00 00 00 

00000000004080e0 <__cosrt_extern_capmgr_vm_lapic_access_create>:
  4080e0:	48 b8 64 c2 45 00 00 	movabs rax,0x45c264
  4080e7:	00 00 00 
  4080ea:	ff 10                	call   QWORD PTR [rax]
  4080ec:	c3                   	ret    
  4080ed:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004080f0 <__cosrt_fast_callgate_capmgr_vm_lapic_access_create>:
  4080f0:	55                   	push   rbp
  4080f1:	41 55                	push   r13
  4080f3:	41 56                	push   r14
  4080f5:	41 57                	push   r15
  4080f7:	49 89 c8             	mov    r8,rcx
  4080fa:	49 89 d1             	mov    r9,rdx
  4080fd:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  408104:	be ad de 
  408107:	0f 01 f9             	rdtscp 
  40810a:	48 89 c8             	mov    rax,rcx
  40810d:	48 25 ff 0f 00 00    	and    rax,0xfff
  408113:	48 89 e2             	mov    rdx,rsp
  408116:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40811d:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  408124:	00 
  408125:	48 c1 e0 10          	shl    rax,0x10
  408129:	49 09 c5             	or     r13,rax
  40812c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  408133:	7f 00 00 
  408136:	4c 89 e8             	mov    rax,r13
  408139:	48 25 ff ff 00 00    	and    rax,0xffff
  40813f:	48 c1 e0 08          	shl    rax,0x8
  408143:	49 01 c6             	add    r14,rax
  408146:	b9 01 00 00 00       	mov    ecx,0x1
  40814b:	01 c9                	add    ecx,ecx
  40814d:	b8 03 00 00 00       	mov    eax,0x3
  408152:	d3 e0                	shl    eax,cl
  408154:	f7 d0                	not    eax
  408156:	83 e0 fc             	and    eax,0xfffffffc
  408159:	48 31 c9             	xor    rcx,rcx
  40815c:	48 31 d2             	xor    rdx,rdx
  40815f:	0f 01 ef             	wrpkru 
  408162:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  408165:	48 83 c2 01          	add    rdx,0x1
  408169:	48 c1 e2 04          	shl    rdx,0x4
  40816d:	4c 01 f2             	add    rdx,r14
  408170:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  408177:	45 23 01 
  40817a:	48 89 02             	mov    QWORD PTR [rdx],rax
  40817d:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  408181:	49 8b 06             	mov    rax,QWORD PTR [r14]
  408184:	48 83 c0 01          	add    rax,0x1
  408188:	49 89 06             	mov    QWORD PTR [r14],rax
  40818b:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  408190:	01 c9                	add    ecx,ecx
  408192:	b8 03 00 00 00       	mov    eax,0x3
  408197:	d3 e0                	shl    eax,cl
  408199:	f7 d0                	not    eax
  40819b:	83 e0 fc             	and    eax,0xfffffffc
  40819e:	48 31 c9             	xor    rcx,rcx
  4081a1:	48 31 d2             	xor    rdx,rdx
  4081a4:	0f 01 ef             	wrpkru 
  4081a7:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  4081ae:	45 23 01 
  4081b1:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4081b8:	be ad de 
  4081bb:	49 39 c7             	cmp    r15,rax
  4081be:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  4081c5:	12 12 12 
  4081c8:	48 b9 d4 81 40 00 00 	movabs rcx,0x4081d4
  4081cf:	00 00 00 
  4081d2:	ff e0                	jmp    rax

00000000004081d4 <srv_call_ret_capmgr_vm_lapic_access_create>:
  4081d4:	49 89 c0             	mov    r8,rax
  4081d7:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4081de:	be ad de 
  4081e1:	48 89 e2             	mov    rdx,rsp
  4081e4:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4081eb:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4081f2:	00 
  4081f3:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4081fa:	7f 00 00 
  4081fd:	4c 89 e8             	mov    rax,r13
  408200:	48 25 ff ff 00 00    	and    rax,0xffff
  408206:	48 c1 e0 08          	shl    rax,0x8
  40820a:	49 01 c6             	add    r14,rax
  40820d:	b9 01 00 00 00       	mov    ecx,0x1
  408212:	01 c9                	add    ecx,ecx
  408214:	b8 03 00 00 00       	mov    eax,0x3
  408219:	d3 e0                	shl    eax,cl
  40821b:	f7 d0                	not    eax
  40821d:	83 e0 fc             	and    eax,0xfffffffc
  408220:	48 31 c9             	xor    rcx,rcx
  408223:	48 31 d2             	xor    rdx,rdx
  408226:	0f 01 ef             	wrpkru 
  408229:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40822c:	48 c1 e2 04          	shl    rdx,0x4
  408230:	4c 01 f2             	add    rdx,r14
  408233:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  408237:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40823a:	48 83 e8 01          	sub    rax,0x1
  40823e:	49 89 06             	mov    QWORD PTR [r14],rax
  408241:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  408246:	01 c9                	add    ecx,ecx
  408248:	b8 03 00 00 00       	mov    eax,0x3
  40824d:	d3 e0                	shl    eax,cl
  40824f:	f7 d0                	not    eax
  408251:	83 e0 fc             	and    eax,0xfffffffc
  408254:	48 31 c9             	xor    rcx,rcx
  408257:	48 31 d2             	xor    rdx,rdx
  40825a:	0f 01 ef             	wrpkru 
  40825d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408264:	be ad de 
  408267:	49 39 c7             	cmp    r15,rax
  40826a:	4c 89 c0             	mov    rax,r8
  40826d:	41 5f                	pop    r15
  40826f:	41 5e                	pop    r14
  408271:	41 5d                	pop    r13
  408273:	5d                   	pop    rbp
  408274:	c3                   	ret    
  408275:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40827c:	00 00 00 00 

0000000000408280 <__cosrt_extern_capmgr_shared_kernel_page_create>:
  408280:	48 b8 7c c2 45 00 00 	movabs rax,0x45c27c
  408287:	00 00 00 
  40828a:	ff 10                	call   QWORD PTR [rax]
  40828c:	c3                   	ret    
  40828d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000408290 <__cosrt_fast_callgate_capmgr_shared_kernel_page_create>:
  408290:	55                   	push   rbp
  408291:	53                   	push   rbx
  408292:	41 54                	push   r12
  408294:	41 55                	push   r13
  408296:	41 56                	push   r14
  408298:	41 57                	push   r15
  40829a:	4d 89 c4             	mov    r12,r8
  40829d:	4c 89 cb             	mov    rbx,r9
  4082a0:	49 89 c8             	mov    r8,rcx
  4082a3:	49 89 d1             	mov    r9,rdx
  4082a6:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4082ad:	be ad de 
  4082b0:	0f 01 f9             	rdtscp 
  4082b3:	48 89 ca             	mov    rdx,rcx
  4082b6:	48 25 ff 0f 00 00    	and    rax,0xfff
  4082bc:	48 89 e2             	mov    rdx,rsp
  4082bf:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4082c6:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4082cd:	00 
  4082ce:	48 c1 e0 10          	shl    rax,0x10
  4082d2:	49 09 c5             	or     r13,rax
  4082d5:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4082dc:	7f 00 00 
  4082df:	4c 89 e8             	mov    rax,r13
  4082e2:	48 25 ff ff 00 00    	and    rax,0xffff
  4082e8:	48 c1 e0 08          	shl    rax,0x8
  4082ec:	49 01 c6             	add    r14,rax
  4082ef:	b9 01 00 00 00       	mov    ecx,0x1
  4082f4:	01 c9                	add    ecx,ecx
  4082f6:	b8 03 00 00 00       	mov    eax,0x3
  4082fb:	d3 e0                	shl    eax,cl
  4082fd:	f7 d0                	not    eax
  4082ff:	83 e0 fc             	and    eax,0xfffffffc
  408302:	48 31 c9             	xor    rcx,rcx
  408305:	48 31 d2             	xor    rdx,rdx
  408308:	0f 01 ef             	wrpkru 
  40830b:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40830e:	48 83 c2 01          	add    rdx,0x1
  408312:	48 c1 e2 04          	shl    rdx,0x4
  408316:	4c 01 f2             	add    rdx,r14
  408319:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  408320:	45 23 01 
  408323:	48 89 02             	mov    QWORD PTR [rdx],rax
  408326:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  40832a:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40832d:	48 83 c0 01          	add    rax,0x1
  408331:	49 89 06             	mov    QWORD PTR [r14],rax
  408334:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  408339:	01 c9                	add    ecx,ecx
  40833b:	b8 03 00 00 00       	mov    eax,0x3
  408340:	d3 e0                	shl    eax,cl
  408342:	f7 d0                	not    eax
  408344:	83 e0 fc             	and    eax,0xfffffffc
  408347:	48 31 c9             	xor    rcx,rcx
  40834a:	48 31 d2             	xor    rdx,rdx
  40834d:	0f 01 ef             	wrpkru 
  408350:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  408357:	45 23 01 
  40835a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408361:	be ad de 
  408364:	49 39 c7             	cmp    r15,rax
  408367:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  40836e:	12 12 12 
  408371:	48 b9 7d 83 40 00 00 	movabs rcx,0x40837d
  408378:	00 00 00 
  40837b:	ff e0                	jmp    rax

000000000040837d <srv_call_ret_capmgr_shared_kernel_page_create>:
  40837d:	49 89 c0             	mov    r8,rax
  408380:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  408387:	be ad de 
  40838a:	48 89 e2             	mov    rdx,rsp
  40838d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  408394:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40839b:	00 
  40839c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4083a3:	7f 00 00 
  4083a6:	4c 89 e8             	mov    rax,r13
  4083a9:	48 25 ff ff 00 00    	and    rax,0xffff
  4083af:	48 c1 e0 08          	shl    rax,0x8
  4083b3:	49 01 c6             	add    r14,rax
  4083b6:	b9 01 00 00 00       	mov    ecx,0x1
  4083bb:	01 c9                	add    ecx,ecx
  4083bd:	b8 03 00 00 00       	mov    eax,0x3
  4083c2:	d3 e0                	shl    eax,cl
  4083c4:	f7 d0                	not    eax
  4083c6:	83 e0 fc             	and    eax,0xfffffffc
  4083c9:	48 31 c9             	xor    rcx,rcx
  4083cc:	48 31 d2             	xor    rdx,rdx
  4083cf:	0f 01 ef             	wrpkru 
  4083d2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4083d5:	48 c1 e2 04          	shl    rdx,0x4
  4083d9:	4c 01 f2             	add    rdx,r14
  4083dc:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  4083e0:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4083e3:	48 83 e8 01          	sub    rax,0x1
  4083e7:	49 89 06             	mov    QWORD PTR [r14],rax
  4083ea:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4083ef:	01 c9                	add    ecx,ecx
  4083f1:	b8 03 00 00 00       	mov    eax,0x3
  4083f6:	d3 e0                	shl    eax,cl
  4083f8:	f7 d0                	not    eax
  4083fa:	83 e0 fc             	and    eax,0xfffffffc
  4083fd:	48 31 c9             	xor    rcx,rcx
  408400:	48 31 d2             	xor    rdx,rdx
  408403:	0f 01 ef             	wrpkru 
  408406:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40840d:	be ad de 
  408410:	49 39 c7             	cmp    r15,rax
  408413:	4c 89 c0             	mov    rax,r8
  408416:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  40841a:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  40841d:	41 5f                	pop    r15
  40841f:	41 5e                	pop    r14
  408421:	41 5d                	pop    r13
  408423:	41 5c                	pop    r12
  408425:	5b                   	pop    rbx
  408426:	5d                   	pop    rbp
  408427:	c3                   	ret    
  408428:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40842f:	00 

0000000000408430 <__cosrt_extern_capmgr_vm_lapic_create>:
  408430:	48 b8 94 c2 45 00 00 	movabs rax,0x45c294
  408437:	00 00 00 
  40843a:	ff 10                	call   QWORD PTR [rax]
  40843c:	c3                   	ret    
  40843d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000408440 <__cosrt_fast_callgate_capmgr_vm_lapic_create>:
  408440:	55                   	push   rbp
  408441:	53                   	push   rbx
  408442:	41 54                	push   r12
  408444:	41 55                	push   r13
  408446:	41 56                	push   r14
  408448:	41 57                	push   r15
  40844a:	4d 89 c4             	mov    r12,r8
  40844d:	4c 89 cb             	mov    rbx,r9
  408450:	49 89 c8             	mov    r8,rcx
  408453:	49 89 d1             	mov    r9,rdx
  408456:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40845d:	be ad de 
  408460:	0f 01 f9             	rdtscp 
  408463:	48 89 ca             	mov    rdx,rcx
  408466:	48 25 ff 0f 00 00    	and    rax,0xfff
  40846c:	48 89 e2             	mov    rdx,rsp
  40846f:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  408476:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40847d:	00 
  40847e:	48 c1 e0 10          	shl    rax,0x10
  408482:	49 09 c5             	or     r13,rax
  408485:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40848c:	7f 00 00 
  40848f:	4c 89 e8             	mov    rax,r13
  408492:	48 25 ff ff 00 00    	and    rax,0xffff
  408498:	48 c1 e0 08          	shl    rax,0x8
  40849c:	49 01 c6             	add    r14,rax
  40849f:	b9 01 00 00 00       	mov    ecx,0x1
  4084a4:	01 c9                	add    ecx,ecx
  4084a6:	b8 03 00 00 00       	mov    eax,0x3
  4084ab:	d3 e0                	shl    eax,cl
  4084ad:	f7 d0                	not    eax
  4084af:	83 e0 fc             	and    eax,0xfffffffc
  4084b2:	48 31 c9             	xor    rcx,rcx
  4084b5:	48 31 d2             	xor    rdx,rdx
  4084b8:	0f 01 ef             	wrpkru 
  4084bb:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4084be:	48 83 c2 01          	add    rdx,0x1
  4084c2:	48 c1 e2 04          	shl    rdx,0x4
  4084c6:	4c 01 f2             	add    rdx,r14
  4084c9:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  4084d0:	45 23 01 
  4084d3:	48 89 02             	mov    QWORD PTR [rdx],rax
  4084d6:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  4084da:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4084dd:	48 83 c0 01          	add    rax,0x1
  4084e1:	49 89 06             	mov    QWORD PTR [r14],rax
  4084e4:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4084e9:	01 c9                	add    ecx,ecx
  4084eb:	b8 03 00 00 00       	mov    eax,0x3
  4084f0:	d3 e0                	shl    eax,cl
  4084f2:	f7 d0                	not    eax
  4084f4:	83 e0 fc             	and    eax,0xfffffffc
  4084f7:	48 31 c9             	xor    rcx,rcx
  4084fa:	48 31 d2             	xor    rdx,rdx
  4084fd:	0f 01 ef             	wrpkru 
  408500:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  408507:	45 23 01 
  40850a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408511:	be ad de 
  408514:	49 39 c7             	cmp    r15,rax
  408517:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  40851e:	12 12 12 
  408521:	48 b9 2d 85 40 00 00 	movabs rcx,0x40852d
  408528:	00 00 00 
  40852b:	ff e0                	jmp    rax

000000000040852d <srv_call_ret_capmgr_vm_lapic_create>:
  40852d:	49 89 c0             	mov    r8,rax
  408530:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  408537:	be ad de 
  40853a:	48 89 e2             	mov    rdx,rsp
  40853d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  408544:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40854b:	00 
  40854c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  408553:	7f 00 00 
  408556:	4c 89 e8             	mov    rax,r13
  408559:	48 25 ff ff 00 00    	and    rax,0xffff
  40855f:	48 c1 e0 08          	shl    rax,0x8
  408563:	49 01 c6             	add    r14,rax
  408566:	b9 01 00 00 00       	mov    ecx,0x1
  40856b:	01 c9                	add    ecx,ecx
  40856d:	b8 03 00 00 00       	mov    eax,0x3
  408572:	d3 e0                	shl    eax,cl
  408574:	f7 d0                	not    eax
  408576:	83 e0 fc             	and    eax,0xfffffffc
  408579:	48 31 c9             	xor    rcx,rcx
  40857c:	48 31 d2             	xor    rdx,rdx
  40857f:	0f 01 ef             	wrpkru 
  408582:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  408585:	48 c1 e2 04          	shl    rdx,0x4
  408589:	4c 01 f2             	add    rdx,r14
  40858c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  408590:	49 8b 06             	mov    rax,QWORD PTR [r14]
  408593:	48 83 e8 01          	sub    rax,0x1
  408597:	49 89 06             	mov    QWORD PTR [r14],rax
  40859a:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40859f:	01 c9                	add    ecx,ecx
  4085a1:	b8 03 00 00 00       	mov    eax,0x3
  4085a6:	d3 e0                	shl    eax,cl
  4085a8:	f7 d0                	not    eax
  4085aa:	83 e0 fc             	and    eax,0xfffffffc
  4085ad:	48 31 c9             	xor    rcx,rcx
  4085b0:	48 31 d2             	xor    rdx,rdx
  4085b3:	0f 01 ef             	wrpkru 
  4085b6:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4085bd:	be ad de 
  4085c0:	49 39 c7             	cmp    r15,rax
  4085c3:	4c 89 c0             	mov    rax,r8
  4085c6:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  4085ca:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  4085cd:	41 5f                	pop    r15
  4085cf:	41 5e                	pop    r14
  4085d1:	41 5d                	pop    r13
  4085d3:	41 5c                	pop    r12
  4085d5:	5b                   	pop    rbx
  4085d6:	5d                   	pop    rbp
  4085d7:	c3                   	ret    
  4085d8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4085df:	00 

00000000004085e0 <__cosrt_extern_capmgr_vm_shared_region_create>:
  4085e0:	48 b8 ac c2 45 00 00 	movabs rax,0x45c2ac
  4085e7:	00 00 00 
  4085ea:	ff 10                	call   QWORD PTR [rax]
  4085ec:	c3                   	ret    
  4085ed:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004085f0 <__cosrt_fast_callgate_capmgr_vm_shared_region_create>:
  4085f0:	55                   	push   rbp
  4085f1:	53                   	push   rbx
  4085f2:	41 54                	push   r12
  4085f4:	41 55                	push   r13
  4085f6:	41 56                	push   r14
  4085f8:	41 57                	push   r15
  4085fa:	4d 89 c4             	mov    r12,r8
  4085fd:	4c 89 cb             	mov    rbx,r9
  408600:	49 89 c8             	mov    r8,rcx
  408603:	49 89 d1             	mov    r9,rdx
  408606:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40860d:	be ad de 
  408610:	0f 01 f9             	rdtscp 
  408613:	48 89 ca             	mov    rdx,rcx
  408616:	48 25 ff 0f 00 00    	and    rax,0xfff
  40861c:	48 89 e2             	mov    rdx,rsp
  40861f:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  408626:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40862d:	00 
  40862e:	48 c1 e0 10          	shl    rax,0x10
  408632:	49 09 c5             	or     r13,rax
  408635:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40863c:	7f 00 00 
  40863f:	4c 89 e8             	mov    rax,r13
  408642:	48 25 ff ff 00 00    	and    rax,0xffff
  408648:	48 c1 e0 08          	shl    rax,0x8
  40864c:	49 01 c6             	add    r14,rax
  40864f:	b9 01 00 00 00       	mov    ecx,0x1
  408654:	01 c9                	add    ecx,ecx
  408656:	b8 03 00 00 00       	mov    eax,0x3
  40865b:	d3 e0                	shl    eax,cl
  40865d:	f7 d0                	not    eax
  40865f:	83 e0 fc             	and    eax,0xfffffffc
  408662:	48 31 c9             	xor    rcx,rcx
  408665:	48 31 d2             	xor    rdx,rdx
  408668:	0f 01 ef             	wrpkru 
  40866b:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40866e:	48 83 c2 01          	add    rdx,0x1
  408672:	48 c1 e2 04          	shl    rdx,0x4
  408676:	4c 01 f2             	add    rdx,r14
  408679:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  408680:	45 23 01 
  408683:	48 89 02             	mov    QWORD PTR [rdx],rax
  408686:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  40868a:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40868d:	48 83 c0 01          	add    rax,0x1
  408691:	49 89 06             	mov    QWORD PTR [r14],rax
  408694:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  408699:	01 c9                	add    ecx,ecx
  40869b:	b8 03 00 00 00       	mov    eax,0x3
  4086a0:	d3 e0                	shl    eax,cl
  4086a2:	f7 d0                	not    eax
  4086a4:	83 e0 fc             	and    eax,0xfffffffc
  4086a7:	48 31 c9             	xor    rcx,rcx
  4086aa:	48 31 d2             	xor    rdx,rdx
  4086ad:	0f 01 ef             	wrpkru 
  4086b0:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  4086b7:	45 23 01 
  4086ba:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4086c1:	be ad de 
  4086c4:	49 39 c7             	cmp    r15,rax
  4086c7:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  4086ce:	12 12 12 
  4086d1:	48 b9 dd 86 40 00 00 	movabs rcx,0x4086dd
  4086d8:	00 00 00 
  4086db:	ff e0                	jmp    rax

00000000004086dd <srv_call_ret_capmgr_vm_shared_region_create>:
  4086dd:	49 89 c0             	mov    r8,rax
  4086e0:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4086e7:	be ad de 
  4086ea:	48 89 e2             	mov    rdx,rsp
  4086ed:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4086f4:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4086fb:	00 
  4086fc:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  408703:	7f 00 00 
  408706:	4c 89 e8             	mov    rax,r13
  408709:	48 25 ff ff 00 00    	and    rax,0xffff
  40870f:	48 c1 e0 08          	shl    rax,0x8
  408713:	49 01 c6             	add    r14,rax
  408716:	b9 01 00 00 00       	mov    ecx,0x1
  40871b:	01 c9                	add    ecx,ecx
  40871d:	b8 03 00 00 00       	mov    eax,0x3
  408722:	d3 e0                	shl    eax,cl
  408724:	f7 d0                	not    eax
  408726:	83 e0 fc             	and    eax,0xfffffffc
  408729:	48 31 c9             	xor    rcx,rcx
  40872c:	48 31 d2             	xor    rdx,rdx
  40872f:	0f 01 ef             	wrpkru 
  408732:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  408735:	48 c1 e2 04          	shl    rdx,0x4
  408739:	4c 01 f2             	add    rdx,r14
  40873c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  408740:	49 8b 06             	mov    rax,QWORD PTR [r14]
  408743:	48 83 e8 01          	sub    rax,0x1
  408747:	49 89 06             	mov    QWORD PTR [r14],rax
  40874a:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40874f:	01 c9                	add    ecx,ecx
  408751:	b8 03 00 00 00       	mov    eax,0x3
  408756:	d3 e0                	shl    eax,cl
  408758:	f7 d0                	not    eax
  40875a:	83 e0 fc             	and    eax,0xfffffffc
  40875d:	48 31 c9             	xor    rcx,rcx
  408760:	48 31 d2             	xor    rdx,rdx
  408763:	0f 01 ef             	wrpkru 
  408766:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40876d:	be ad de 
  408770:	49 39 c7             	cmp    r15,rax
  408773:	4c 89 c0             	mov    rax,r8
  408776:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  40877a:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  40877d:	41 5f                	pop    r15
  40877f:	41 5e                	pop    r14
  408781:	41 5d                	pop    r13
  408783:	41 5c                	pop    r12
  408785:	5b                   	pop    rbx
  408786:	5d                   	pop    rbp
  408787:	c3                   	ret    
  408788:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40878f:	00 

0000000000408790 <__cosrt_extern_capmgr_vm_vmcb_create>:
  408790:	48 b8 c4 c2 45 00 00 	movabs rax,0x45c2c4
  408797:	00 00 00 
  40879a:	ff 10                	call   QWORD PTR [rax]
  40879c:	c3                   	ret    
  40879d:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004087a0 <__cosrt_fast_callgate_capmgr_vm_vmcb_create>:
  4087a0:	55                   	push   rbp
  4087a1:	53                   	push   rbx
  4087a2:	41 54                	push   r12
  4087a4:	41 55                	push   r13
  4087a6:	41 56                	push   r14
  4087a8:	41 57                	push   r15
  4087aa:	4d 89 c4             	mov    r12,r8
  4087ad:	4c 89 cb             	mov    rbx,r9
  4087b0:	49 89 c8             	mov    r8,rcx
  4087b3:	49 89 d1             	mov    r9,rdx
  4087b6:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4087bd:	be ad de 
  4087c0:	0f 01 f9             	rdtscp 
  4087c3:	48 89 ca             	mov    rdx,rcx
  4087c6:	48 25 ff 0f 00 00    	and    rax,0xfff
  4087cc:	48 89 e2             	mov    rdx,rsp
  4087cf:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4087d6:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4087dd:	00 
  4087de:	48 c1 e0 10          	shl    rax,0x10
  4087e2:	49 09 c5             	or     r13,rax
  4087e5:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4087ec:	7f 00 00 
  4087ef:	4c 89 e8             	mov    rax,r13
  4087f2:	48 25 ff ff 00 00    	and    rax,0xffff
  4087f8:	48 c1 e0 08          	shl    rax,0x8
  4087fc:	49 01 c6             	add    r14,rax
  4087ff:	b9 01 00 00 00       	mov    ecx,0x1
  408804:	01 c9                	add    ecx,ecx
  408806:	b8 03 00 00 00       	mov    eax,0x3
  40880b:	d3 e0                	shl    eax,cl
  40880d:	f7 d0                	not    eax
  40880f:	83 e0 fc             	and    eax,0xfffffffc
  408812:	48 31 c9             	xor    rcx,rcx
  408815:	48 31 d2             	xor    rdx,rdx
  408818:	0f 01 ef             	wrpkru 
  40881b:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40881e:	48 83 c2 01          	add    rdx,0x1
  408822:	48 c1 e2 04          	shl    rdx,0x4
  408826:	4c 01 f2             	add    rdx,r14
  408829:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  408830:	45 23 01 
  408833:	48 89 02             	mov    QWORD PTR [rdx],rax
  408836:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  40883a:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40883d:	48 83 c0 01          	add    rax,0x1
  408841:	49 89 06             	mov    QWORD PTR [r14],rax
  408844:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  408849:	01 c9                	add    ecx,ecx
  40884b:	b8 03 00 00 00       	mov    eax,0x3
  408850:	d3 e0                	shl    eax,cl
  408852:	f7 d0                	not    eax
  408854:	83 e0 fc             	and    eax,0xfffffffc
  408857:	48 31 c9             	xor    rcx,rcx
  40885a:	48 31 d2             	xor    rdx,rdx
  40885d:	0f 01 ef             	wrpkru 
  408860:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  408867:	45 23 01 
  40886a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408871:	be ad de 
  408874:	49 39 c7             	cmp    r15,rax
  408877:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  40887e:	12 12 12 
  408881:	48 b9 8d 88 40 00 00 	movabs rcx,0x40888d
  408888:	00 00 00 
  40888b:	ff e0                	jmp    rax

000000000040888d <srv_call_ret_capmgr_vm_vmcb_create>:
  40888d:	49 89 c0             	mov    r8,rax
  408890:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  408897:	be ad de 
  40889a:	48 89 e2             	mov    rdx,rsp
  40889d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4088a4:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4088ab:	00 
  4088ac:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4088b3:	7f 00 00 
  4088b6:	4c 89 e8             	mov    rax,r13
  4088b9:	48 25 ff ff 00 00    	and    rax,0xffff
  4088bf:	48 c1 e0 08          	shl    rax,0x8
  4088c3:	49 01 c6             	add    r14,rax
  4088c6:	b9 01 00 00 00       	mov    ecx,0x1
  4088cb:	01 c9                	add    ecx,ecx
  4088cd:	b8 03 00 00 00       	mov    eax,0x3
  4088d2:	d3 e0                	shl    eax,cl
  4088d4:	f7 d0                	not    eax
  4088d6:	83 e0 fc             	and    eax,0xfffffffc
  4088d9:	48 31 c9             	xor    rcx,rcx
  4088dc:	48 31 d2             	xor    rdx,rdx
  4088df:	0f 01 ef             	wrpkru 
  4088e2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4088e5:	48 c1 e2 04          	shl    rdx,0x4
  4088e9:	4c 01 f2             	add    rdx,r14
  4088ec:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  4088f0:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4088f3:	48 83 e8 01          	sub    rax,0x1
  4088f7:	49 89 06             	mov    QWORD PTR [r14],rax
  4088fa:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4088ff:	01 c9                	add    ecx,ecx
  408901:	b8 03 00 00 00       	mov    eax,0x3
  408906:	d3 e0                	shl    eax,cl
  408908:	f7 d0                	not    eax
  40890a:	83 e0 fc             	and    eax,0xfffffffc
  40890d:	48 31 c9             	xor    rcx,rcx
  408910:	48 31 d2             	xor    rdx,rdx
  408913:	0f 01 ef             	wrpkru 
  408916:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40891d:	be ad de 
  408920:	49 39 c7             	cmp    r15,rax
  408923:	4c 89 c0             	mov    rax,r8
  408926:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  40892a:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  40892d:	41 5f                	pop    r15
  40892f:	41 5e                	pop    r14
  408931:	41 5d                	pop    r13
  408933:	41 5c                	pop    r12
  408935:	5b                   	pop    rbx
  408936:	5d                   	pop    rbp
  408937:	c3                   	ret    
  408938:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40893f:	00 

0000000000408940 <__cosrt_extern_capmgr_vm_vcpu_create>:
  408940:	48 b8 dc c2 45 00 00 	movabs rax,0x45c2dc
  408947:	00 00 00 
  40894a:	ff 10                	call   QWORD PTR [rax]
  40894c:	c3                   	ret    
  40894d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000408950 <__cosrt_fast_callgate_capmgr_vm_vcpu_create>:
  408950:	55                   	push   rbp
  408951:	53                   	push   rbx
  408952:	41 54                	push   r12
  408954:	41 55                	push   r13
  408956:	41 56                	push   r14
  408958:	41 57                	push   r15
  40895a:	4d 89 c4             	mov    r12,r8
  40895d:	4c 89 cb             	mov    rbx,r9
  408960:	49 89 c8             	mov    r8,rcx
  408963:	49 89 d1             	mov    r9,rdx
  408966:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40896d:	be ad de 
  408970:	0f 01 f9             	rdtscp 
  408973:	48 89 ca             	mov    rdx,rcx
  408976:	48 25 ff 0f 00 00    	and    rax,0xfff
  40897c:	48 89 e2             	mov    rdx,rsp
  40897f:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  408986:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40898d:	00 
  40898e:	48 c1 e0 10          	shl    rax,0x10
  408992:	49 09 c5             	or     r13,rax
  408995:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40899c:	7f 00 00 
  40899f:	4c 89 e8             	mov    rax,r13
  4089a2:	48 25 ff ff 00 00    	and    rax,0xffff
  4089a8:	48 c1 e0 08          	shl    rax,0x8
  4089ac:	49 01 c6             	add    r14,rax
  4089af:	b9 01 00 00 00       	mov    ecx,0x1
  4089b4:	01 c9                	add    ecx,ecx
  4089b6:	b8 03 00 00 00       	mov    eax,0x3
  4089bb:	d3 e0                	shl    eax,cl
  4089bd:	f7 d0                	not    eax
  4089bf:	83 e0 fc             	and    eax,0xfffffffc
  4089c2:	48 31 c9             	xor    rcx,rcx
  4089c5:	48 31 d2             	xor    rdx,rdx
  4089c8:	0f 01 ef             	wrpkru 
  4089cb:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4089ce:	48 83 c2 01          	add    rdx,0x1
  4089d2:	48 c1 e2 04          	shl    rdx,0x4
  4089d6:	4c 01 f2             	add    rdx,r14
  4089d9:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  4089e0:	45 23 01 
  4089e3:	48 89 02             	mov    QWORD PTR [rdx],rax
  4089e6:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  4089ea:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4089ed:	48 83 c0 01          	add    rax,0x1
  4089f1:	49 89 06             	mov    QWORD PTR [r14],rax
  4089f4:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4089f9:	01 c9                	add    ecx,ecx
  4089fb:	b8 03 00 00 00       	mov    eax,0x3
  408a00:	d3 e0                	shl    eax,cl
  408a02:	f7 d0                	not    eax
  408a04:	83 e0 fc             	and    eax,0xfffffffc
  408a07:	48 31 c9             	xor    rcx,rcx
  408a0a:	48 31 d2             	xor    rdx,rdx
  408a0d:	0f 01 ef             	wrpkru 
  408a10:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  408a17:	45 23 01 
  408a1a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408a21:	be ad de 
  408a24:	49 39 c7             	cmp    r15,rax
  408a27:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  408a2e:	12 12 12 
  408a31:	48 b9 3d 8a 40 00 00 	movabs rcx,0x408a3d
  408a38:	00 00 00 
  408a3b:	ff e0                	jmp    rax

0000000000408a3d <srv_call_ret_capmgr_vm_vcpu_create>:
  408a3d:	49 89 c0             	mov    r8,rax
  408a40:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  408a47:	be ad de 
  408a4a:	48 89 e2             	mov    rdx,rsp
  408a4d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  408a54:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  408a5b:	00 
  408a5c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  408a63:	7f 00 00 
  408a66:	4c 89 e8             	mov    rax,r13
  408a69:	48 25 ff ff 00 00    	and    rax,0xffff
  408a6f:	48 c1 e0 08          	shl    rax,0x8
  408a73:	49 01 c6             	add    r14,rax
  408a76:	b9 01 00 00 00       	mov    ecx,0x1
  408a7b:	01 c9                	add    ecx,ecx
  408a7d:	b8 03 00 00 00       	mov    eax,0x3
  408a82:	d3 e0                	shl    eax,cl
  408a84:	f7 d0                	not    eax
  408a86:	83 e0 fc             	and    eax,0xfffffffc
  408a89:	48 31 c9             	xor    rcx,rcx
  408a8c:	48 31 d2             	xor    rdx,rdx
  408a8f:	0f 01 ef             	wrpkru 
  408a92:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  408a95:	48 c1 e2 04          	shl    rdx,0x4
  408a99:	4c 01 f2             	add    rdx,r14
  408a9c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  408aa0:	49 8b 06             	mov    rax,QWORD PTR [r14]
  408aa3:	48 83 e8 01          	sub    rax,0x1
  408aa7:	49 89 06             	mov    QWORD PTR [r14],rax
  408aaa:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  408aaf:	01 c9                	add    ecx,ecx
  408ab1:	b8 03 00 00 00       	mov    eax,0x3
  408ab6:	d3 e0                	shl    eax,cl
  408ab8:	f7 d0                	not    eax
  408aba:	83 e0 fc             	and    eax,0xfffffffc
  408abd:	48 31 c9             	xor    rcx,rcx
  408ac0:	48 31 d2             	xor    rdx,rdx
  408ac3:	0f 01 ef             	wrpkru 
  408ac6:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408acd:	be ad de 
  408ad0:	49 39 c7             	cmp    r15,rax
  408ad3:	4c 89 c0             	mov    rax,r8
  408ad6:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  408ada:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  408add:	41 5f                	pop    r15
  408adf:	41 5e                	pop    r14
  408ae1:	41 5d                	pop    r13
  408ae3:	41 5c                	pop    r12
  408ae5:	5b                   	pop    rbx
  408ae6:	5d                   	pop    rbp
  408ae7:	c3                   	ret    
  408ae8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  408aef:	00 

0000000000408af0 <__cosrt_c_memmgr_shared_page_allocn>:
#include <cos_component.h>
#include <cos_stubs.h>
#include <memmgr.h>

COS_CLIENT_STUB(cbuf_t, memmgr_shared_page_allocn, unsigned long num_pages, vaddr_t *pgaddr)
{
  408af0:	f3 0f 1e fa          	endbr64 
  408af4:	55                   	push   rbp
  408af5:	48 89 e5             	mov    rbp,rsp
  408af8:	41 57                	push   r15
  408afa:	41 56                	push   r14
  408afc:	41 55                	push   r13
  408afe:	49 89 f5             	mov    r13,rsi
  408b01:	41 54                	push   r12
  408b03:	53                   	push   rbx
  408b04:	48 83 ec 28          	sub    rsp,0x28
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  408b08:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  408b0c:	4d 85 f6             	test   r14,r14
  408b0f:	74 2f                	je     408b40 <__cosrt_c_memmgr_shared_page_allocn+0x50>
  408b11:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  408b15:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  408b19:	31 c9                	xor    ecx,ecx
  408b1b:	31 d2                	xor    edx,edx
  408b1d:	31 f6                	xor    esi,esi
  408b1f:	41 ff d6             	call   r14
	COS_CLIENT_INVCAP;
	word_t unused, addrret;
	cbuf_t ret;

	ret = cos_sinv_2rets(uc, num_pages, 0, 0, 0, &addrret, &unused);
	*pgaddr = addrret;
  408b22:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
  408b26:	49 89 55 00          	mov    QWORD PTR [r13+0x0],rdx

	return ret;
}
  408b2a:	48 83 c4 28          	add    rsp,0x28
  408b2e:	5b                   	pop    rbx
  408b2f:	41 5c                	pop    r12
  408b31:	41 5d                	pop    r13
  408b33:	41 5e                	pop    r14
  408b35:	41 5f                	pop    r15
  408b37:	5d                   	pop    rbp
  408b38:	c3                   	ret    
  408b39:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  408b40:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  408b44:	48 89 fb             	mov    rbx,rdi
  408b47:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  408b4b:	4c 89 f6             	mov    rsi,r14
  408b4e:	4c 89 f7             	mov    rdi,r14
  408b51:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  408b54:	83 c0 01             	add    eax,0x1
  408b57:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  408b5a:	48 89 29             	mov    QWORD PTR [rcx],rbp
  408b5d:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  408b61:	48 89 cd             	mov    rbp,rcx
  408b64:	49 b8 78 8b 40 00 00 	movabs r8,0x408b78
  408b6b:	00 00 00 
  408b6e:	0f 05                	syscall 
  408b70:	eb 0f                	jmp    408b81 <__cosrt_c_memmgr_shared_page_allocn+0x91>
  408b72:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  408b78:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  408b7f:	eb 07                	jmp    408b88 <__cosrt_c_memmgr_shared_page_allocn+0x98>
  408b81:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  408b88:	5d                   	pop    rbp
  408b89:	5c                   	pop    rsp
  408b8a:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  408b8e:	eb 92                	jmp    408b22 <__cosrt_c_memmgr_shared_page_allocn+0x32>

0000000000408b90 <__cosrt_c_memmgr_shared_page_map>:

COS_CLIENT_STUB(unsigned long, memmgr_shared_page_map, cbuf_t id, vaddr_t *pgaddr)
{
  408b90:	f3 0f 1e fa          	endbr64 
  408b94:	55                   	push   rbp
  408b95:	48 89 e5             	mov    rbp,rsp
  408b98:	41 57                	push   r15
	COS_CLIENT_INVCAP;
	word_t unused, addrret;
	unsigned long ret;

	ret = cos_sinv_2rets(uc, id, 0, 0, 0, &addrret, &unused);
  408b9a:	41 89 ff             	mov    r15d,edi
{
  408b9d:	41 56                	push   r14
  408b9f:	41 55                	push   r13
  408ba1:	49 89 f5             	mov    r13,rsi
  408ba4:	41 54                	push   r12
  408ba6:	53                   	push   rbx
  408ba7:	48 83 ec 28          	sub    rsp,0x28
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  408bab:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  408baf:	4d 85 f6             	test   r14,r14
  408bb2:	74 34                	je     408be8 <__cosrt_c_memmgr_shared_page_map+0x58>
  408bb4:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  408bb8:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  408bbc:	31 c9                	xor    ecx,ecx
  408bbe:	31 d2                	xor    edx,edx
  408bc0:	31 f6                	xor    esi,esi
  408bc2:	4c 89 ff             	mov    rdi,r15
  408bc5:	41 ff d6             	call   r14
	*pgaddr = addrret;
  408bc8:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
	ret = cos_sinv_2rets(uc, id, 0, 0, 0, &addrret, &unused);
  408bcc:	48 98                	cdqe   
	*pgaddr = addrret;
  408bce:	49 89 55 00          	mov    QWORD PTR [r13+0x0],rdx

	return ret;
}
  408bd2:	48 83 c4 28          	add    rsp,0x28
  408bd6:	5b                   	pop    rbx
  408bd7:	41 5c                	pop    r12
  408bd9:	41 5d                	pop    r13
  408bdb:	41 5e                	pop    r14
  408bdd:	41 5f                	pop    r15
  408bdf:	5d                   	pop    rbp
  408be0:	c3                   	ret    
  408be1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  408be8:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  408bec:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  408bf0:	4c 89 fb             	mov    rbx,r15
  408bf3:	4c 89 f6             	mov    rsi,r14
  408bf6:	4c 89 f7             	mov    rdi,r14
  408bf9:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  408bfc:	83 c0 01             	add    eax,0x1
  408bff:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  408c02:	48 89 29             	mov    QWORD PTR [rcx],rbp
  408c05:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  408c09:	48 89 cd             	mov    rbp,rcx
  408c0c:	49 b8 20 8c 40 00 00 	movabs r8,0x408c20
  408c13:	00 00 00 
  408c16:	0f 05                	syscall 
  408c18:	eb 0f                	jmp    408c29 <__cosrt_c_memmgr_shared_page_map+0x99>
  408c1a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  408c20:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  408c27:	eb 07                	jmp    408c30 <__cosrt_c_memmgr_shared_page_map+0xa0>
  408c29:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  408c30:	5d                   	pop    rbp
  408c31:	5c                   	pop    rsp
  408c32:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  408c36:	eb 90                	jmp    408bc8 <__cosrt_c_memmgr_shared_page_map+0x38>
  408c38:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  408c3f:	00 

0000000000408c40 <__cosrt_c_memmgr_shared_page_allocn_aligned>:

COS_CLIENT_STUB(cbuf_t, memmgr_shared_page_allocn_aligned, unsigned long num_pages, unsigned long align, vaddr_t *pgaddr)
{
  408c40:	f3 0f 1e fa          	endbr64 
  408c44:	55                   	push   rbp
  408c45:	48 89 e5             	mov    rbp,rsp
  408c48:	41 57                	push   r15
  408c4a:	49 89 d7             	mov    r15,rdx
  408c4d:	41 56                	push   r14
  408c4f:	41 55                	push   r13
  408c51:	41 54                	push   r12
  408c53:	53                   	push   rbx
  408c54:	48 83 ec 28          	sub    rsp,0x28
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  408c58:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  408c5c:	4d 85 f6             	test   r14,r14
  408c5f:	74 2f                	je     408c90 <__cosrt_c_memmgr_shared_page_allocn_aligned+0x50>
  408c61:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  408c65:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  408c69:	31 c9                	xor    ecx,ecx
  408c6b:	31 d2                	xor    edx,edx
  408c6d:	41 ff d6             	call   r14
	COS_CLIENT_INVCAP;
	word_t unused, addrret;
	cbuf_t ret;

	ret = cos_sinv_2rets(uc, num_pages, align, 0, 0, &addrret, &unused);
	*pgaddr = addrret;
  408c70:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
  408c74:	49 89 17             	mov    QWORD PTR [r15],rdx

	return ret;
}
  408c77:	48 83 c4 28          	add    rsp,0x28
  408c7b:	5b                   	pop    rbx
  408c7c:	41 5c                	pop    r12
  408c7e:	41 5d                	pop    r13
  408c80:	41 5e                	pop    r14
  408c82:	41 5f                	pop    r15
  408c84:	5d                   	pop    rbp
  408c85:	c3                   	ret    
  408c86:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  408c8d:	00 00 00 
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  408c90:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  408c94:	48 89 fb             	mov    rbx,rdi
  408c97:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  408c9b:	4c 89 f7             	mov    rdi,r14
  408c9e:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  408ca1:	83 c0 01             	add    eax,0x1
  408ca4:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  408ca7:	48 89 29             	mov    QWORD PTR [rcx],rbp
  408caa:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  408cae:	48 89 cd             	mov    rbp,rcx
  408cb1:	49 b8 c8 8c 40 00 00 	movabs r8,0x408cc8
  408cb8:	00 00 00 
  408cbb:	0f 05                	syscall 
  408cbd:	0f 1f 00             	nop    DWORD PTR [rax]
  408cc0:	eb 0f                	jmp    408cd1 <__cosrt_c_memmgr_shared_page_allocn_aligned+0x91>
  408cc2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  408cc8:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  408ccf:	eb 07                	jmp    408cd8 <__cosrt_c_memmgr_shared_page_allocn_aligned+0x98>
  408cd1:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  408cd8:	5d                   	pop    rbp
  408cd9:	5c                   	pop    rsp
  408cda:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  408cde:	eb 90                	jmp    408c70 <__cosrt_c_memmgr_shared_page_allocn_aligned+0x30>

0000000000408ce0 <__cosrt_c_memmgr_shared_page_map_aligned>:

COS_CLIENT_STUB(unsigned long, memmgr_shared_page_map_aligned, cbuf_t id, unsigned long align, vaddr_t *pgaddr)
{
  408ce0:	f3 0f 1e fa          	endbr64 
  408ce4:	55                   	push   rbp
  408ce5:	48 89 e5             	mov    rbp,rsp
  408ce8:	41 57                	push   r15
  408cea:	49 89 d7             	mov    r15,rdx
  408ced:	41 56                	push   r14
  408cef:	41 55                	push   r13
	COS_CLIENT_INVCAP;
	word_t unused, addrret;
	unsigned long ret;

	ret = cos_sinv_2rets(uc, id, align, 0, 0, &addrret, &unused);
  408cf1:	41 89 fd             	mov    r13d,edi
{
  408cf4:	41 54                	push   r12
  408cf6:	53                   	push   rbx
  408cf7:	48 83 ec 28          	sub    rsp,0x28
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  408cfb:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  408cff:	4d 85 f6             	test   r14,r14
  408d02:	74 2c                	je     408d30 <__cosrt_c_memmgr_shared_page_map_aligned+0x50>
  408d04:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  408d08:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  408d0c:	31 c9                	xor    ecx,ecx
  408d0e:	31 d2                	xor    edx,edx
  408d10:	4c 89 ef             	mov    rdi,r13
  408d13:	41 ff d6             	call   r14
	*pgaddr = addrret;
  408d16:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
	ret = cos_sinv_2rets(uc, id, align, 0, 0, &addrret, &unused);
  408d1a:	48 98                	cdqe   
	*pgaddr = addrret;
  408d1c:	49 89 17             	mov    QWORD PTR [r15],rdx

	return ret;
}
  408d1f:	48 83 c4 28          	add    rsp,0x28
  408d23:	5b                   	pop    rbx
  408d24:	41 5c                	pop    r12
  408d26:	41 5d                	pop    r13
  408d28:	41 5e                	pop    r14
  408d2a:	41 5f                	pop    r15
  408d2c:	5d                   	pop    rbp
  408d2d:	c3                   	ret    
  408d2e:	66 90                	xchg   ax,ax
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  408d30:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  408d34:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  408d38:	4c 89 eb             	mov    rbx,r13
  408d3b:	4c 89 f7             	mov    rdi,r14
  408d3e:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  408d41:	83 c0 01             	add    eax,0x1
  408d44:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  408d47:	48 89 29             	mov    QWORD PTR [rcx],rbp
  408d4a:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  408d4e:	48 89 cd             	mov    rbp,rcx
  408d51:	49 b8 68 8d 40 00 00 	movabs r8,0x408d68
  408d58:	00 00 00 
  408d5b:	0f 05                	syscall 
  408d5d:	0f 1f 00             	nop    DWORD PTR [rax]
  408d60:	eb 0f                	jmp    408d71 <__cosrt_c_memmgr_shared_page_map_aligned+0x91>
  408d62:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  408d68:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  408d6f:	eb 07                	jmp    408d78 <__cosrt_c_memmgr_shared_page_map_aligned+0x98>
  408d71:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  408d78:	5d                   	pop    rbp
  408d79:	5c                   	pop    rsp
  408d7a:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  408d7e:	eb 96                	jmp    408d16 <__cosrt_c_memmgr_shared_page_map_aligned+0x36>

0000000000408d80 <__cosrt_c_memmgr_shared_page_map_aligned_in_vm>:

COS_CLIENT_STUB(unsigned long, memmgr_shared_page_map_aligned_in_vm, cbuf_t id, unsigned long align, vaddr_t *pgaddr, compid_t cid)
{
  408d80:	f3 0f 1e fa          	endbr64 
  408d84:	55                   	push   rbp
  408d85:	48 89 e5             	mov    rbp,rsp
  408d88:	41 57                	push   r15
	COS_CLIENT_INVCAP;
	word_t unused, addrret;
	unsigned long ret;

	ret = cos_sinv_2rets(uc, id, align, cid, 0, &addrret, &unused);
  408d8a:	41 89 ff             	mov    r15d,edi
{
  408d8d:	41 56                	push   r14
  408d8f:	41 55                	push   r13
  408d91:	49 89 cd             	mov    r13,rcx
  408d94:	41 54                	push   r12
  408d96:	53                   	push   rbx
  408d97:	48 83 ec 38          	sub    rsp,0x38
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  408d9b:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  408d9f:	48 89 55 a8          	mov    QWORD PTR [rbp-0x58],rdx
  408da3:	4d 85 f6             	test   r14,r14
  408da6:	74 38                	je     408de0 <__cosrt_c_memmgr_shared_page_map_aligned_in_vm+0x60>
  408da8:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  408dac:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  408db0:	31 c9                	xor    ecx,ecx
  408db2:	4c 89 ea             	mov    rdx,r13
  408db5:	4c 89 ff             	mov    rdi,r15
  408db8:	41 ff d6             	call   r14
	*pgaddr = addrret;
  408dbb:	48 8b 5d a8          	mov    rbx,QWORD PTR [rbp-0x58]
  408dbf:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
	ret = cos_sinv_2rets(uc, id, align, cid, 0, &addrret, &unused);
  408dc3:	48 98                	cdqe   
	*pgaddr = addrret;
  408dc5:	48 89 13             	mov    QWORD PTR [rbx],rdx

	return ret;
}
  408dc8:	48 83 c4 38          	add    rsp,0x38
  408dcc:	5b                   	pop    rbx
  408dcd:	41 5c                	pop    r12
  408dcf:	41 5d                	pop    r13
  408dd1:	41 5e                	pop    r14
  408dd3:	41 5f                	pop    r15
  408dd5:	5d                   	pop    rbp
  408dd6:	c3                   	ret    
  408dd7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  408dde:	00 00 
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  408de0:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  408de4:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  408de8:	4c 89 fb             	mov    rbx,r15
  408deb:	4c 89 ef             	mov    rdi,r13
  408dee:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  408df1:	83 c0 01             	add    eax,0x1
  408df4:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  408df7:	48 89 29             	mov    QWORD PTR [rcx],rbp
  408dfa:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  408dfe:	48 89 cd             	mov    rbp,rcx
  408e01:	49 b8 18 8e 40 00 00 	movabs r8,0x408e18
  408e08:	00 00 00 
  408e0b:	0f 05                	syscall 
  408e0d:	0f 1f 00             	nop    DWORD PTR [rax]
  408e10:	eb 0f                	jmp    408e21 <__cosrt_c_memmgr_shared_page_map_aligned_in_vm+0xa1>
  408e12:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  408e18:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  408e1f:	eb 07                	jmp    408e28 <__cosrt_c_memmgr_shared_page_map_aligned_in_vm+0xa8>
  408e21:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  408e28:	5d                   	pop    rbp
  408e29:	5c                   	pop    rsp
  408e2a:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  408e2e:	eb 8b                	jmp    408dbb <__cosrt_c_memmgr_shared_page_map_aligned_in_vm+0x3b>

0000000000408e30 <__cosrt_extern_memmgr_heap_page_allocn>:
  408e30:	48 b8 f4 c2 45 00 00 	movabs rax,0x45c2f4
  408e37:	00 00 00 
  408e3a:	ff 10                	call   QWORD PTR [rax]
  408e3c:	c3                   	ret    
  408e3d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000408e40 <__cosrt_fast_callgate_memmgr_heap_page_allocn>:
  408e40:	55                   	push   rbp
  408e41:	41 55                	push   r13
  408e43:	41 56                	push   r14
  408e45:	41 57                	push   r15
  408e47:	49 89 c8             	mov    r8,rcx
  408e4a:	49 89 d1             	mov    r9,rdx
  408e4d:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  408e54:	be ad de 
  408e57:	0f 01 f9             	rdtscp 
  408e5a:	48 89 c8             	mov    rax,rcx
  408e5d:	48 25 ff 0f 00 00    	and    rax,0xfff
  408e63:	48 89 e2             	mov    rdx,rsp
  408e66:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  408e6d:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  408e74:	00 
  408e75:	48 c1 e0 10          	shl    rax,0x10
  408e79:	49 09 c5             	or     r13,rax
  408e7c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  408e83:	7f 00 00 
  408e86:	4c 89 e8             	mov    rax,r13
  408e89:	48 25 ff ff 00 00    	and    rax,0xffff
  408e8f:	48 c1 e0 08          	shl    rax,0x8
  408e93:	49 01 c6             	add    r14,rax
  408e96:	b9 01 00 00 00       	mov    ecx,0x1
  408e9b:	01 c9                	add    ecx,ecx
  408e9d:	b8 03 00 00 00       	mov    eax,0x3
  408ea2:	d3 e0                	shl    eax,cl
  408ea4:	f7 d0                	not    eax
  408ea6:	83 e0 fc             	and    eax,0xfffffffc
  408ea9:	48 31 c9             	xor    rcx,rcx
  408eac:	48 31 d2             	xor    rdx,rdx
  408eaf:	0f 01 ef             	wrpkru 
  408eb2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  408eb5:	48 83 c2 01          	add    rdx,0x1
  408eb9:	48 c1 e2 04          	shl    rdx,0x4
  408ebd:	4c 01 f2             	add    rdx,r14
  408ec0:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  408ec7:	45 23 01 
  408eca:	48 89 02             	mov    QWORD PTR [rdx],rax
  408ecd:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  408ed1:	49 8b 06             	mov    rax,QWORD PTR [r14]
  408ed4:	48 83 c0 01          	add    rax,0x1
  408ed8:	49 89 06             	mov    QWORD PTR [r14],rax
  408edb:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  408ee0:	01 c9                	add    ecx,ecx
  408ee2:	b8 03 00 00 00       	mov    eax,0x3
  408ee7:	d3 e0                	shl    eax,cl
  408ee9:	f7 d0                	not    eax
  408eeb:	83 e0 fc             	and    eax,0xfffffffc
  408eee:	48 31 c9             	xor    rcx,rcx
  408ef1:	48 31 d2             	xor    rdx,rdx
  408ef4:	0f 01 ef             	wrpkru 
  408ef7:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  408efe:	45 23 01 
  408f01:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408f08:	be ad de 
  408f0b:	49 39 c7             	cmp    r15,rax
  408f0e:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  408f15:	12 12 12 
  408f18:	48 b9 24 8f 40 00 00 	movabs rcx,0x408f24
  408f1f:	00 00 00 
  408f22:	ff e0                	jmp    rax

0000000000408f24 <srv_call_ret_memmgr_heap_page_allocn>:
  408f24:	49 89 c0             	mov    r8,rax
  408f27:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  408f2e:	be ad de 
  408f31:	48 89 e2             	mov    rdx,rsp
  408f34:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  408f3b:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  408f42:	00 
  408f43:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  408f4a:	7f 00 00 
  408f4d:	4c 89 e8             	mov    rax,r13
  408f50:	48 25 ff ff 00 00    	and    rax,0xffff
  408f56:	48 c1 e0 08          	shl    rax,0x8
  408f5a:	49 01 c6             	add    r14,rax
  408f5d:	b9 01 00 00 00       	mov    ecx,0x1
  408f62:	01 c9                	add    ecx,ecx
  408f64:	b8 03 00 00 00       	mov    eax,0x3
  408f69:	d3 e0                	shl    eax,cl
  408f6b:	f7 d0                	not    eax
  408f6d:	83 e0 fc             	and    eax,0xfffffffc
  408f70:	48 31 c9             	xor    rcx,rcx
  408f73:	48 31 d2             	xor    rdx,rdx
  408f76:	0f 01 ef             	wrpkru 
  408f79:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  408f7c:	48 c1 e2 04          	shl    rdx,0x4
  408f80:	4c 01 f2             	add    rdx,r14
  408f83:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  408f87:	49 8b 06             	mov    rax,QWORD PTR [r14]
  408f8a:	48 83 e8 01          	sub    rax,0x1
  408f8e:	49 89 06             	mov    QWORD PTR [r14],rax
  408f91:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  408f96:	01 c9                	add    ecx,ecx
  408f98:	b8 03 00 00 00       	mov    eax,0x3
  408f9d:	d3 e0                	shl    eax,cl
  408f9f:	f7 d0                	not    eax
  408fa1:	83 e0 fc             	and    eax,0xfffffffc
  408fa4:	48 31 c9             	xor    rcx,rcx
  408fa7:	48 31 d2             	xor    rdx,rdx
  408faa:	0f 01 ef             	wrpkru 
  408fad:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408fb4:	be ad de 
  408fb7:	49 39 c7             	cmp    r15,rax
  408fba:	4c 89 c0             	mov    rax,r8
  408fbd:	41 5f                	pop    r15
  408fbf:	41 5e                	pop    r14
  408fc1:	41 5d                	pop    r13
  408fc3:	5d                   	pop    rbp
  408fc4:	c3                   	ret    
  408fc5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  408fcc:	00 00 00 00 

0000000000408fd0 <__cosrt_extern_memmgr_heap_page_allocn_aligned>:
  408fd0:	48 b8 0c c3 45 00 00 	movabs rax,0x45c30c
  408fd7:	00 00 00 
  408fda:	ff 10                	call   QWORD PTR [rax]
  408fdc:	c3                   	ret    
  408fdd:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000408fe0 <__cosrt_fast_callgate_memmgr_heap_page_allocn_aligned>:
  408fe0:	55                   	push   rbp
  408fe1:	41 55                	push   r13
  408fe3:	41 56                	push   r14
  408fe5:	41 57                	push   r15
  408fe7:	49 89 c8             	mov    r8,rcx
  408fea:	49 89 d1             	mov    r9,rdx
  408fed:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  408ff4:	be ad de 
  408ff7:	0f 01 f9             	rdtscp 
  408ffa:	48 89 c8             	mov    rax,rcx
  408ffd:	48 25 ff 0f 00 00    	and    rax,0xfff
  409003:	48 89 e2             	mov    rdx,rsp
  409006:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40900d:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  409014:	00 
  409015:	48 c1 e0 10          	shl    rax,0x10
  409019:	49 09 c5             	or     r13,rax
  40901c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  409023:	7f 00 00 
  409026:	4c 89 e8             	mov    rax,r13
  409029:	48 25 ff ff 00 00    	and    rax,0xffff
  40902f:	48 c1 e0 08          	shl    rax,0x8
  409033:	49 01 c6             	add    r14,rax
  409036:	b9 01 00 00 00       	mov    ecx,0x1
  40903b:	01 c9                	add    ecx,ecx
  40903d:	b8 03 00 00 00       	mov    eax,0x3
  409042:	d3 e0                	shl    eax,cl
  409044:	f7 d0                	not    eax
  409046:	83 e0 fc             	and    eax,0xfffffffc
  409049:	48 31 c9             	xor    rcx,rcx
  40904c:	48 31 d2             	xor    rdx,rdx
  40904f:	0f 01 ef             	wrpkru 
  409052:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  409055:	48 83 c2 01          	add    rdx,0x1
  409059:	48 c1 e2 04          	shl    rdx,0x4
  40905d:	4c 01 f2             	add    rdx,r14
  409060:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  409067:	45 23 01 
  40906a:	48 89 02             	mov    QWORD PTR [rdx],rax
  40906d:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  409071:	49 8b 06             	mov    rax,QWORD PTR [r14]
  409074:	48 83 c0 01          	add    rax,0x1
  409078:	49 89 06             	mov    QWORD PTR [r14],rax
  40907b:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  409080:	01 c9                	add    ecx,ecx
  409082:	b8 03 00 00 00       	mov    eax,0x3
  409087:	d3 e0                	shl    eax,cl
  409089:	f7 d0                	not    eax
  40908b:	83 e0 fc             	and    eax,0xfffffffc
  40908e:	48 31 c9             	xor    rcx,rcx
  409091:	48 31 d2             	xor    rdx,rdx
  409094:	0f 01 ef             	wrpkru 
  409097:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  40909e:	45 23 01 
  4090a1:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4090a8:	be ad de 
  4090ab:	49 39 c7             	cmp    r15,rax
  4090ae:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  4090b5:	12 12 12 
  4090b8:	48 b9 c4 90 40 00 00 	movabs rcx,0x4090c4
  4090bf:	00 00 00 
  4090c2:	ff e0                	jmp    rax

00000000004090c4 <srv_call_ret_memmgr_heap_page_allocn_aligned>:
  4090c4:	49 89 c0             	mov    r8,rax
  4090c7:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4090ce:	be ad de 
  4090d1:	48 89 e2             	mov    rdx,rsp
  4090d4:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4090db:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4090e2:	00 
  4090e3:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4090ea:	7f 00 00 
  4090ed:	4c 89 e8             	mov    rax,r13
  4090f0:	48 25 ff ff 00 00    	and    rax,0xffff
  4090f6:	48 c1 e0 08          	shl    rax,0x8
  4090fa:	49 01 c6             	add    r14,rax
  4090fd:	b9 01 00 00 00       	mov    ecx,0x1
  409102:	01 c9                	add    ecx,ecx
  409104:	b8 03 00 00 00       	mov    eax,0x3
  409109:	d3 e0                	shl    eax,cl
  40910b:	f7 d0                	not    eax
  40910d:	83 e0 fc             	and    eax,0xfffffffc
  409110:	48 31 c9             	xor    rcx,rcx
  409113:	48 31 d2             	xor    rdx,rdx
  409116:	0f 01 ef             	wrpkru 
  409119:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40911c:	48 c1 e2 04          	shl    rdx,0x4
  409120:	4c 01 f2             	add    rdx,r14
  409123:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  409127:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40912a:	48 83 e8 01          	sub    rax,0x1
  40912e:	49 89 06             	mov    QWORD PTR [r14],rax
  409131:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  409136:	01 c9                	add    ecx,ecx
  409138:	b8 03 00 00 00       	mov    eax,0x3
  40913d:	d3 e0                	shl    eax,cl
  40913f:	f7 d0                	not    eax
  409141:	83 e0 fc             	and    eax,0xfffffffc
  409144:	48 31 c9             	xor    rcx,rcx
  409147:	48 31 d2             	xor    rdx,rdx
  40914a:	0f 01 ef             	wrpkru 
  40914d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409154:	be ad de 
  409157:	49 39 c7             	cmp    r15,rax
  40915a:	4c 89 c0             	mov    rax,r8
  40915d:	41 5f                	pop    r15
  40915f:	41 5e                	pop    r14
  409161:	41 5d                	pop    r13
  409163:	5d                   	pop    rbp
  409164:	c3                   	ret    
  409165:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40916c:	00 00 00 00 

0000000000409170 <__cosrt_extern_memmgr_virt_to_phys>:
  409170:	48 b8 24 c3 45 00 00 	movabs rax,0x45c324
  409177:	00 00 00 
  40917a:	ff 10                	call   QWORD PTR [rax]
  40917c:	c3                   	ret    
  40917d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000409180 <__cosrt_fast_callgate_memmgr_virt_to_phys>:
  409180:	55                   	push   rbp
  409181:	41 55                	push   r13
  409183:	41 56                	push   r14
  409185:	41 57                	push   r15
  409187:	49 89 c8             	mov    r8,rcx
  40918a:	49 89 d1             	mov    r9,rdx
  40918d:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  409194:	be ad de 
  409197:	0f 01 f9             	rdtscp 
  40919a:	48 89 c8             	mov    rax,rcx
  40919d:	48 25 ff 0f 00 00    	and    rax,0xfff
  4091a3:	48 89 e2             	mov    rdx,rsp
  4091a6:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4091ad:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4091b4:	00 
  4091b5:	48 c1 e0 10          	shl    rax,0x10
  4091b9:	49 09 c5             	or     r13,rax
  4091bc:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4091c3:	7f 00 00 
  4091c6:	4c 89 e8             	mov    rax,r13
  4091c9:	48 25 ff ff 00 00    	and    rax,0xffff
  4091cf:	48 c1 e0 08          	shl    rax,0x8
  4091d3:	49 01 c6             	add    r14,rax
  4091d6:	b9 01 00 00 00       	mov    ecx,0x1
  4091db:	01 c9                	add    ecx,ecx
  4091dd:	b8 03 00 00 00       	mov    eax,0x3
  4091e2:	d3 e0                	shl    eax,cl
  4091e4:	f7 d0                	not    eax
  4091e6:	83 e0 fc             	and    eax,0xfffffffc
  4091e9:	48 31 c9             	xor    rcx,rcx
  4091ec:	48 31 d2             	xor    rdx,rdx
  4091ef:	0f 01 ef             	wrpkru 
  4091f2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4091f5:	48 83 c2 01          	add    rdx,0x1
  4091f9:	48 c1 e2 04          	shl    rdx,0x4
  4091fd:	4c 01 f2             	add    rdx,r14
  409200:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  409207:	45 23 01 
  40920a:	48 89 02             	mov    QWORD PTR [rdx],rax
  40920d:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  409211:	49 8b 06             	mov    rax,QWORD PTR [r14]
  409214:	48 83 c0 01          	add    rax,0x1
  409218:	49 89 06             	mov    QWORD PTR [r14],rax
  40921b:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  409220:	01 c9                	add    ecx,ecx
  409222:	b8 03 00 00 00       	mov    eax,0x3
  409227:	d3 e0                	shl    eax,cl
  409229:	f7 d0                	not    eax
  40922b:	83 e0 fc             	and    eax,0xfffffffc
  40922e:	48 31 c9             	xor    rcx,rcx
  409231:	48 31 d2             	xor    rdx,rdx
  409234:	0f 01 ef             	wrpkru 
  409237:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  40923e:	45 23 01 
  409241:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409248:	be ad de 
  40924b:	49 39 c7             	cmp    r15,rax
  40924e:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  409255:	12 12 12 
  409258:	48 b9 64 92 40 00 00 	movabs rcx,0x409264
  40925f:	00 00 00 
  409262:	ff e0                	jmp    rax

0000000000409264 <srv_call_ret_memmgr_virt_to_phys>:
  409264:	49 89 c0             	mov    r8,rax
  409267:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40926e:	be ad de 
  409271:	48 89 e2             	mov    rdx,rsp
  409274:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40927b:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  409282:	00 
  409283:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40928a:	7f 00 00 
  40928d:	4c 89 e8             	mov    rax,r13
  409290:	48 25 ff ff 00 00    	and    rax,0xffff
  409296:	48 c1 e0 08          	shl    rax,0x8
  40929a:	49 01 c6             	add    r14,rax
  40929d:	b9 01 00 00 00       	mov    ecx,0x1
  4092a2:	01 c9                	add    ecx,ecx
  4092a4:	b8 03 00 00 00       	mov    eax,0x3
  4092a9:	d3 e0                	shl    eax,cl
  4092ab:	f7 d0                	not    eax
  4092ad:	83 e0 fc             	and    eax,0xfffffffc
  4092b0:	48 31 c9             	xor    rcx,rcx
  4092b3:	48 31 d2             	xor    rdx,rdx
  4092b6:	0f 01 ef             	wrpkru 
  4092b9:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4092bc:	48 c1 e2 04          	shl    rdx,0x4
  4092c0:	4c 01 f2             	add    rdx,r14
  4092c3:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  4092c7:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4092ca:	48 83 e8 01          	sub    rax,0x1
  4092ce:	49 89 06             	mov    QWORD PTR [r14],rax
  4092d1:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4092d6:	01 c9                	add    ecx,ecx
  4092d8:	b8 03 00 00 00       	mov    eax,0x3
  4092dd:	d3 e0                	shl    eax,cl
  4092df:	f7 d0                	not    eax
  4092e1:	83 e0 fc             	and    eax,0xfffffffc
  4092e4:	48 31 c9             	xor    rcx,rcx
  4092e7:	48 31 d2             	xor    rdx,rdx
  4092ea:	0f 01 ef             	wrpkru 
  4092ed:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4092f4:	be ad de 
  4092f7:	49 39 c7             	cmp    r15,rax
  4092fa:	4c 89 c0             	mov    rax,r8
  4092fd:	41 5f                	pop    r15
  4092ff:	41 5e                	pop    r14
  409301:	41 5d                	pop    r13
  409303:	5d                   	pop    rbp
  409304:	c3                   	ret    
  409305:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40930c:	00 00 00 00 

0000000000409310 <__cosrt_extern_memmgr_map_phys_to_virt>:
  409310:	48 b8 3c c3 45 00 00 	movabs rax,0x45c33c
  409317:	00 00 00 
  40931a:	ff 10                	call   QWORD PTR [rax]
  40931c:	c3                   	ret    
  40931d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000409320 <__cosrt_fast_callgate_memmgr_map_phys_to_virt>:
  409320:	55                   	push   rbp
  409321:	41 55                	push   r13
  409323:	41 56                	push   r14
  409325:	41 57                	push   r15
  409327:	49 89 c8             	mov    r8,rcx
  40932a:	49 89 d1             	mov    r9,rdx
  40932d:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  409334:	be ad de 
  409337:	0f 01 f9             	rdtscp 
  40933a:	48 89 c8             	mov    rax,rcx
  40933d:	48 25 ff 0f 00 00    	and    rax,0xfff
  409343:	48 89 e2             	mov    rdx,rsp
  409346:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40934d:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  409354:	00 
  409355:	48 c1 e0 10          	shl    rax,0x10
  409359:	49 09 c5             	or     r13,rax
  40935c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  409363:	7f 00 00 
  409366:	4c 89 e8             	mov    rax,r13
  409369:	48 25 ff ff 00 00    	and    rax,0xffff
  40936f:	48 c1 e0 08          	shl    rax,0x8
  409373:	49 01 c6             	add    r14,rax
  409376:	b9 01 00 00 00       	mov    ecx,0x1
  40937b:	01 c9                	add    ecx,ecx
  40937d:	b8 03 00 00 00       	mov    eax,0x3
  409382:	d3 e0                	shl    eax,cl
  409384:	f7 d0                	not    eax
  409386:	83 e0 fc             	and    eax,0xfffffffc
  409389:	48 31 c9             	xor    rcx,rcx
  40938c:	48 31 d2             	xor    rdx,rdx
  40938f:	0f 01 ef             	wrpkru 
  409392:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  409395:	48 83 c2 01          	add    rdx,0x1
  409399:	48 c1 e2 04          	shl    rdx,0x4
  40939d:	4c 01 f2             	add    rdx,r14
  4093a0:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  4093a7:	45 23 01 
  4093aa:	48 89 02             	mov    QWORD PTR [rdx],rax
  4093ad:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  4093b1:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4093b4:	48 83 c0 01          	add    rax,0x1
  4093b8:	49 89 06             	mov    QWORD PTR [r14],rax
  4093bb:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4093c0:	01 c9                	add    ecx,ecx
  4093c2:	b8 03 00 00 00       	mov    eax,0x3
  4093c7:	d3 e0                	shl    eax,cl
  4093c9:	f7 d0                	not    eax
  4093cb:	83 e0 fc             	and    eax,0xfffffffc
  4093ce:	48 31 c9             	xor    rcx,rcx
  4093d1:	48 31 d2             	xor    rdx,rdx
  4093d4:	0f 01 ef             	wrpkru 
  4093d7:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  4093de:	45 23 01 
  4093e1:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4093e8:	be ad de 
  4093eb:	49 39 c7             	cmp    r15,rax
  4093ee:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  4093f5:	12 12 12 
  4093f8:	48 b9 04 94 40 00 00 	movabs rcx,0x409404
  4093ff:	00 00 00 
  409402:	ff e0                	jmp    rax

0000000000409404 <srv_call_ret_memmgr_map_phys_to_virt>:
  409404:	49 89 c0             	mov    r8,rax
  409407:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40940e:	be ad de 
  409411:	48 89 e2             	mov    rdx,rsp
  409414:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40941b:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  409422:	00 
  409423:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40942a:	7f 00 00 
  40942d:	4c 89 e8             	mov    rax,r13
  409430:	48 25 ff ff 00 00    	and    rax,0xffff
  409436:	48 c1 e0 08          	shl    rax,0x8
  40943a:	49 01 c6             	add    r14,rax
  40943d:	b9 01 00 00 00       	mov    ecx,0x1
  409442:	01 c9                	add    ecx,ecx
  409444:	b8 03 00 00 00       	mov    eax,0x3
  409449:	d3 e0                	shl    eax,cl
  40944b:	f7 d0                	not    eax
  40944d:	83 e0 fc             	and    eax,0xfffffffc
  409450:	48 31 c9             	xor    rcx,rcx
  409453:	48 31 d2             	xor    rdx,rdx
  409456:	0f 01 ef             	wrpkru 
  409459:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40945c:	48 c1 e2 04          	shl    rdx,0x4
  409460:	4c 01 f2             	add    rdx,r14
  409463:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  409467:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40946a:	48 83 e8 01          	sub    rax,0x1
  40946e:	49 89 06             	mov    QWORD PTR [r14],rax
  409471:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  409476:	01 c9                	add    ecx,ecx
  409478:	b8 03 00 00 00       	mov    eax,0x3
  40947d:	d3 e0                	shl    eax,cl
  40947f:	f7 d0                	not    eax
  409481:	83 e0 fc             	and    eax,0xfffffffc
  409484:	48 31 c9             	xor    rcx,rcx
  409487:	48 31 d2             	xor    rdx,rdx
  40948a:	0f 01 ef             	wrpkru 
  40948d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409494:	be ad de 
  409497:	49 39 c7             	cmp    r15,rax
  40949a:	4c 89 c0             	mov    rax,r8
  40949d:	41 5f                	pop    r15
  40949f:	41 5e                	pop    r14
  4094a1:	41 5d                	pop    r13
  4094a3:	5d                   	pop    rbp
  4094a4:	c3                   	ret    
  4094a5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4094ac:	00 00 00 00 

00000000004094b0 <__cosrt_extern_memmgr_shared_page_allocn>:
  4094b0:	48 b8 54 c3 45 00 00 	movabs rax,0x45c354
  4094b7:	00 00 00 
  4094ba:	ff 10                	call   QWORD PTR [rax]
  4094bc:	c3                   	ret    
  4094bd:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004094c0 <__cosrt_fast_callgate_memmgr_shared_page_allocn>:
  4094c0:	55                   	push   rbp
  4094c1:	53                   	push   rbx
  4094c2:	41 54                	push   r12
  4094c4:	41 55                	push   r13
  4094c6:	41 56                	push   r14
  4094c8:	41 57                	push   r15
  4094ca:	4d 89 c4             	mov    r12,r8
  4094cd:	4c 89 cb             	mov    rbx,r9
  4094d0:	49 89 c8             	mov    r8,rcx
  4094d3:	49 89 d1             	mov    r9,rdx
  4094d6:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4094dd:	be ad de 
  4094e0:	0f 01 f9             	rdtscp 
  4094e3:	48 89 ca             	mov    rdx,rcx
  4094e6:	48 25 ff 0f 00 00    	and    rax,0xfff
  4094ec:	48 89 e2             	mov    rdx,rsp
  4094ef:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4094f6:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4094fd:	00 
  4094fe:	48 c1 e0 10          	shl    rax,0x10
  409502:	49 09 c5             	or     r13,rax
  409505:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40950c:	7f 00 00 
  40950f:	4c 89 e8             	mov    rax,r13
  409512:	48 25 ff ff 00 00    	and    rax,0xffff
  409518:	48 c1 e0 08          	shl    rax,0x8
  40951c:	49 01 c6             	add    r14,rax
  40951f:	b9 01 00 00 00       	mov    ecx,0x1
  409524:	01 c9                	add    ecx,ecx
  409526:	b8 03 00 00 00       	mov    eax,0x3
  40952b:	d3 e0                	shl    eax,cl
  40952d:	f7 d0                	not    eax
  40952f:	83 e0 fc             	and    eax,0xfffffffc
  409532:	48 31 c9             	xor    rcx,rcx
  409535:	48 31 d2             	xor    rdx,rdx
  409538:	0f 01 ef             	wrpkru 
  40953b:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40953e:	48 83 c2 01          	add    rdx,0x1
  409542:	48 c1 e2 04          	shl    rdx,0x4
  409546:	4c 01 f2             	add    rdx,r14
  409549:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  409550:	45 23 01 
  409553:	48 89 02             	mov    QWORD PTR [rdx],rax
  409556:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  40955a:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40955d:	48 83 c0 01          	add    rax,0x1
  409561:	49 89 06             	mov    QWORD PTR [r14],rax
  409564:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  409569:	01 c9                	add    ecx,ecx
  40956b:	b8 03 00 00 00       	mov    eax,0x3
  409570:	d3 e0                	shl    eax,cl
  409572:	f7 d0                	not    eax
  409574:	83 e0 fc             	and    eax,0xfffffffc
  409577:	48 31 c9             	xor    rcx,rcx
  40957a:	48 31 d2             	xor    rdx,rdx
  40957d:	0f 01 ef             	wrpkru 
  409580:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  409587:	45 23 01 
  40958a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409591:	be ad de 
  409594:	49 39 c7             	cmp    r15,rax
  409597:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  40959e:	12 12 12 
  4095a1:	48 b9 ad 95 40 00 00 	movabs rcx,0x4095ad
  4095a8:	00 00 00 
  4095ab:	ff e0                	jmp    rax

00000000004095ad <srv_call_ret_memmgr_shared_page_allocn>:
  4095ad:	49 89 c0             	mov    r8,rax
  4095b0:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4095b7:	be ad de 
  4095ba:	48 89 e2             	mov    rdx,rsp
  4095bd:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4095c4:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4095cb:	00 
  4095cc:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4095d3:	7f 00 00 
  4095d6:	4c 89 e8             	mov    rax,r13
  4095d9:	48 25 ff ff 00 00    	and    rax,0xffff
  4095df:	48 c1 e0 08          	shl    rax,0x8
  4095e3:	49 01 c6             	add    r14,rax
  4095e6:	b9 01 00 00 00       	mov    ecx,0x1
  4095eb:	01 c9                	add    ecx,ecx
  4095ed:	b8 03 00 00 00       	mov    eax,0x3
  4095f2:	d3 e0                	shl    eax,cl
  4095f4:	f7 d0                	not    eax
  4095f6:	83 e0 fc             	and    eax,0xfffffffc
  4095f9:	48 31 c9             	xor    rcx,rcx
  4095fc:	48 31 d2             	xor    rdx,rdx
  4095ff:	0f 01 ef             	wrpkru 
  409602:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  409605:	48 c1 e2 04          	shl    rdx,0x4
  409609:	4c 01 f2             	add    rdx,r14
  40960c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  409610:	49 8b 06             	mov    rax,QWORD PTR [r14]
  409613:	48 83 e8 01          	sub    rax,0x1
  409617:	49 89 06             	mov    QWORD PTR [r14],rax
  40961a:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40961f:	01 c9                	add    ecx,ecx
  409621:	b8 03 00 00 00       	mov    eax,0x3
  409626:	d3 e0                	shl    eax,cl
  409628:	f7 d0                	not    eax
  40962a:	83 e0 fc             	and    eax,0xfffffffc
  40962d:	48 31 c9             	xor    rcx,rcx
  409630:	48 31 d2             	xor    rdx,rdx
  409633:	0f 01 ef             	wrpkru 
  409636:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40963d:	be ad de 
  409640:	49 39 c7             	cmp    r15,rax
  409643:	4c 89 c0             	mov    rax,r8
  409646:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  40964a:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  40964d:	41 5f                	pop    r15
  40964f:	41 5e                	pop    r14
  409651:	41 5d                	pop    r13
  409653:	41 5c                	pop    r12
  409655:	5b                   	pop    rbx
  409656:	5d                   	pop    rbp
  409657:	c3                   	ret    
  409658:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40965f:	00 

0000000000409660 <__cosrt_extern_memmgr_shared_page_allocn_aligned>:
  409660:	48 b8 6c c3 45 00 00 	movabs rax,0x45c36c
  409667:	00 00 00 
  40966a:	ff 10                	call   QWORD PTR [rax]
  40966c:	c3                   	ret    
  40966d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000409670 <__cosrt_fast_callgate_memmgr_shared_page_allocn_aligned>:
  409670:	55                   	push   rbp
  409671:	53                   	push   rbx
  409672:	41 54                	push   r12
  409674:	41 55                	push   r13
  409676:	41 56                	push   r14
  409678:	41 57                	push   r15
  40967a:	4d 89 c4             	mov    r12,r8
  40967d:	4c 89 cb             	mov    rbx,r9
  409680:	49 89 c8             	mov    r8,rcx
  409683:	49 89 d1             	mov    r9,rdx
  409686:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40968d:	be ad de 
  409690:	0f 01 f9             	rdtscp 
  409693:	48 89 ca             	mov    rdx,rcx
  409696:	48 25 ff 0f 00 00    	and    rax,0xfff
  40969c:	48 89 e2             	mov    rdx,rsp
  40969f:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4096a6:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4096ad:	00 
  4096ae:	48 c1 e0 10          	shl    rax,0x10
  4096b2:	49 09 c5             	or     r13,rax
  4096b5:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4096bc:	7f 00 00 
  4096bf:	4c 89 e8             	mov    rax,r13
  4096c2:	48 25 ff ff 00 00    	and    rax,0xffff
  4096c8:	48 c1 e0 08          	shl    rax,0x8
  4096cc:	49 01 c6             	add    r14,rax
  4096cf:	b9 01 00 00 00       	mov    ecx,0x1
  4096d4:	01 c9                	add    ecx,ecx
  4096d6:	b8 03 00 00 00       	mov    eax,0x3
  4096db:	d3 e0                	shl    eax,cl
  4096dd:	f7 d0                	not    eax
  4096df:	83 e0 fc             	and    eax,0xfffffffc
  4096e2:	48 31 c9             	xor    rcx,rcx
  4096e5:	48 31 d2             	xor    rdx,rdx
  4096e8:	0f 01 ef             	wrpkru 
  4096eb:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4096ee:	48 83 c2 01          	add    rdx,0x1
  4096f2:	48 c1 e2 04          	shl    rdx,0x4
  4096f6:	4c 01 f2             	add    rdx,r14
  4096f9:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  409700:	45 23 01 
  409703:	48 89 02             	mov    QWORD PTR [rdx],rax
  409706:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  40970a:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40970d:	48 83 c0 01          	add    rax,0x1
  409711:	49 89 06             	mov    QWORD PTR [r14],rax
  409714:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  409719:	01 c9                	add    ecx,ecx
  40971b:	b8 03 00 00 00       	mov    eax,0x3
  409720:	d3 e0                	shl    eax,cl
  409722:	f7 d0                	not    eax
  409724:	83 e0 fc             	and    eax,0xfffffffc
  409727:	48 31 c9             	xor    rcx,rcx
  40972a:	48 31 d2             	xor    rdx,rdx
  40972d:	0f 01 ef             	wrpkru 
  409730:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  409737:	45 23 01 
  40973a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409741:	be ad de 
  409744:	49 39 c7             	cmp    r15,rax
  409747:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  40974e:	12 12 12 
  409751:	48 b9 5d 97 40 00 00 	movabs rcx,0x40975d
  409758:	00 00 00 
  40975b:	ff e0                	jmp    rax

000000000040975d <srv_call_ret_memmgr_shared_page_allocn_aligned>:
  40975d:	49 89 c0             	mov    r8,rax
  409760:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  409767:	be ad de 
  40976a:	48 89 e2             	mov    rdx,rsp
  40976d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  409774:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40977b:	00 
  40977c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  409783:	7f 00 00 
  409786:	4c 89 e8             	mov    rax,r13
  409789:	48 25 ff ff 00 00    	and    rax,0xffff
  40978f:	48 c1 e0 08          	shl    rax,0x8
  409793:	49 01 c6             	add    r14,rax
  409796:	b9 01 00 00 00       	mov    ecx,0x1
  40979b:	01 c9                	add    ecx,ecx
  40979d:	b8 03 00 00 00       	mov    eax,0x3
  4097a2:	d3 e0                	shl    eax,cl
  4097a4:	f7 d0                	not    eax
  4097a6:	83 e0 fc             	and    eax,0xfffffffc
  4097a9:	48 31 c9             	xor    rcx,rcx
  4097ac:	48 31 d2             	xor    rdx,rdx
  4097af:	0f 01 ef             	wrpkru 
  4097b2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4097b5:	48 c1 e2 04          	shl    rdx,0x4
  4097b9:	4c 01 f2             	add    rdx,r14
  4097bc:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  4097c0:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4097c3:	48 83 e8 01          	sub    rax,0x1
  4097c7:	49 89 06             	mov    QWORD PTR [r14],rax
  4097ca:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4097cf:	01 c9                	add    ecx,ecx
  4097d1:	b8 03 00 00 00       	mov    eax,0x3
  4097d6:	d3 e0                	shl    eax,cl
  4097d8:	f7 d0                	not    eax
  4097da:	83 e0 fc             	and    eax,0xfffffffc
  4097dd:	48 31 c9             	xor    rcx,rcx
  4097e0:	48 31 d2             	xor    rdx,rdx
  4097e3:	0f 01 ef             	wrpkru 
  4097e6:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4097ed:	be ad de 
  4097f0:	49 39 c7             	cmp    r15,rax
  4097f3:	4c 89 c0             	mov    rax,r8
  4097f6:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  4097fa:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  4097fd:	41 5f                	pop    r15
  4097ff:	41 5e                	pop    r14
  409801:	41 5d                	pop    r13
  409803:	41 5c                	pop    r12
  409805:	5b                   	pop    rbx
  409806:	5d                   	pop    rbp
  409807:	c3                   	ret    
  409808:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40980f:	00 

0000000000409810 <__cosrt_extern_memmgr_shared_page_map>:
  409810:	48 b8 84 c3 45 00 00 	movabs rax,0x45c384
  409817:	00 00 00 
  40981a:	ff 10                	call   QWORD PTR [rax]
  40981c:	c3                   	ret    
  40981d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000409820 <__cosrt_fast_callgate_memmgr_shared_page_map>:
  409820:	55                   	push   rbp
  409821:	53                   	push   rbx
  409822:	41 54                	push   r12
  409824:	41 55                	push   r13
  409826:	41 56                	push   r14
  409828:	41 57                	push   r15
  40982a:	4d 89 c4             	mov    r12,r8
  40982d:	4c 89 cb             	mov    rbx,r9
  409830:	49 89 c8             	mov    r8,rcx
  409833:	49 89 d1             	mov    r9,rdx
  409836:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40983d:	be ad de 
  409840:	0f 01 f9             	rdtscp 
  409843:	48 89 ca             	mov    rdx,rcx
  409846:	48 25 ff 0f 00 00    	and    rax,0xfff
  40984c:	48 89 e2             	mov    rdx,rsp
  40984f:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  409856:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40985d:	00 
  40985e:	48 c1 e0 10          	shl    rax,0x10
  409862:	49 09 c5             	or     r13,rax
  409865:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40986c:	7f 00 00 
  40986f:	4c 89 e8             	mov    rax,r13
  409872:	48 25 ff ff 00 00    	and    rax,0xffff
  409878:	48 c1 e0 08          	shl    rax,0x8
  40987c:	49 01 c6             	add    r14,rax
  40987f:	b9 01 00 00 00       	mov    ecx,0x1
  409884:	01 c9                	add    ecx,ecx
  409886:	b8 03 00 00 00       	mov    eax,0x3
  40988b:	d3 e0                	shl    eax,cl
  40988d:	f7 d0                	not    eax
  40988f:	83 e0 fc             	and    eax,0xfffffffc
  409892:	48 31 c9             	xor    rcx,rcx
  409895:	48 31 d2             	xor    rdx,rdx
  409898:	0f 01 ef             	wrpkru 
  40989b:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40989e:	48 83 c2 01          	add    rdx,0x1
  4098a2:	48 c1 e2 04          	shl    rdx,0x4
  4098a6:	4c 01 f2             	add    rdx,r14
  4098a9:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  4098b0:	45 23 01 
  4098b3:	48 89 02             	mov    QWORD PTR [rdx],rax
  4098b6:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  4098ba:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4098bd:	48 83 c0 01          	add    rax,0x1
  4098c1:	49 89 06             	mov    QWORD PTR [r14],rax
  4098c4:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4098c9:	01 c9                	add    ecx,ecx
  4098cb:	b8 03 00 00 00       	mov    eax,0x3
  4098d0:	d3 e0                	shl    eax,cl
  4098d2:	f7 d0                	not    eax
  4098d4:	83 e0 fc             	and    eax,0xfffffffc
  4098d7:	48 31 c9             	xor    rcx,rcx
  4098da:	48 31 d2             	xor    rdx,rdx
  4098dd:	0f 01 ef             	wrpkru 
  4098e0:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  4098e7:	45 23 01 
  4098ea:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4098f1:	be ad de 
  4098f4:	49 39 c7             	cmp    r15,rax
  4098f7:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  4098fe:	12 12 12 
  409901:	48 b9 0d 99 40 00 00 	movabs rcx,0x40990d
  409908:	00 00 00 
  40990b:	ff e0                	jmp    rax

000000000040990d <srv_call_ret_memmgr_shared_page_map>:
  40990d:	49 89 c0             	mov    r8,rax
  409910:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  409917:	be ad de 
  40991a:	48 89 e2             	mov    rdx,rsp
  40991d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  409924:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40992b:	00 
  40992c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  409933:	7f 00 00 
  409936:	4c 89 e8             	mov    rax,r13
  409939:	48 25 ff ff 00 00    	and    rax,0xffff
  40993f:	48 c1 e0 08          	shl    rax,0x8
  409943:	49 01 c6             	add    r14,rax
  409946:	b9 01 00 00 00       	mov    ecx,0x1
  40994b:	01 c9                	add    ecx,ecx
  40994d:	b8 03 00 00 00       	mov    eax,0x3
  409952:	d3 e0                	shl    eax,cl
  409954:	f7 d0                	not    eax
  409956:	83 e0 fc             	and    eax,0xfffffffc
  409959:	48 31 c9             	xor    rcx,rcx
  40995c:	48 31 d2             	xor    rdx,rdx
  40995f:	0f 01 ef             	wrpkru 
  409962:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  409965:	48 c1 e2 04          	shl    rdx,0x4
  409969:	4c 01 f2             	add    rdx,r14
  40996c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  409970:	49 8b 06             	mov    rax,QWORD PTR [r14]
  409973:	48 83 e8 01          	sub    rax,0x1
  409977:	49 89 06             	mov    QWORD PTR [r14],rax
  40997a:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40997f:	01 c9                	add    ecx,ecx
  409981:	b8 03 00 00 00       	mov    eax,0x3
  409986:	d3 e0                	shl    eax,cl
  409988:	f7 d0                	not    eax
  40998a:	83 e0 fc             	and    eax,0xfffffffc
  40998d:	48 31 c9             	xor    rcx,rcx
  409990:	48 31 d2             	xor    rdx,rdx
  409993:	0f 01 ef             	wrpkru 
  409996:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40999d:	be ad de 
  4099a0:	49 39 c7             	cmp    r15,rax
  4099a3:	4c 89 c0             	mov    rax,r8
  4099a6:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  4099aa:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  4099ad:	41 5f                	pop    r15
  4099af:	41 5e                	pop    r14
  4099b1:	41 5d                	pop    r13
  4099b3:	41 5c                	pop    r12
  4099b5:	5b                   	pop    rbx
  4099b6:	5d                   	pop    rbp
  4099b7:	c3                   	ret    
  4099b8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4099bf:	00 

00000000004099c0 <__cosrt_extern_memmgr_shared_page_map_aligned>:
  4099c0:	48 b8 9c c3 45 00 00 	movabs rax,0x45c39c
  4099c7:	00 00 00 
  4099ca:	ff 10                	call   QWORD PTR [rax]
  4099cc:	c3                   	ret    
  4099cd:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004099d0 <__cosrt_fast_callgate_memmgr_shared_page_map_aligned>:
  4099d0:	55                   	push   rbp
  4099d1:	53                   	push   rbx
  4099d2:	41 54                	push   r12
  4099d4:	41 55                	push   r13
  4099d6:	41 56                	push   r14
  4099d8:	41 57                	push   r15
  4099da:	4d 89 c4             	mov    r12,r8
  4099dd:	4c 89 cb             	mov    rbx,r9
  4099e0:	49 89 c8             	mov    r8,rcx
  4099e3:	49 89 d1             	mov    r9,rdx
  4099e6:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4099ed:	be ad de 
  4099f0:	0f 01 f9             	rdtscp 
  4099f3:	48 89 ca             	mov    rdx,rcx
  4099f6:	48 25 ff 0f 00 00    	and    rax,0xfff
  4099fc:	48 89 e2             	mov    rdx,rsp
  4099ff:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  409a06:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  409a0d:	00 
  409a0e:	48 c1 e0 10          	shl    rax,0x10
  409a12:	49 09 c5             	or     r13,rax
  409a15:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  409a1c:	7f 00 00 
  409a1f:	4c 89 e8             	mov    rax,r13
  409a22:	48 25 ff ff 00 00    	and    rax,0xffff
  409a28:	48 c1 e0 08          	shl    rax,0x8
  409a2c:	49 01 c6             	add    r14,rax
  409a2f:	b9 01 00 00 00       	mov    ecx,0x1
  409a34:	01 c9                	add    ecx,ecx
  409a36:	b8 03 00 00 00       	mov    eax,0x3
  409a3b:	d3 e0                	shl    eax,cl
  409a3d:	f7 d0                	not    eax
  409a3f:	83 e0 fc             	and    eax,0xfffffffc
  409a42:	48 31 c9             	xor    rcx,rcx
  409a45:	48 31 d2             	xor    rdx,rdx
  409a48:	0f 01 ef             	wrpkru 
  409a4b:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  409a4e:	48 83 c2 01          	add    rdx,0x1
  409a52:	48 c1 e2 04          	shl    rdx,0x4
  409a56:	4c 01 f2             	add    rdx,r14
  409a59:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  409a60:	45 23 01 
  409a63:	48 89 02             	mov    QWORD PTR [rdx],rax
  409a66:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  409a6a:	49 8b 06             	mov    rax,QWORD PTR [r14]
  409a6d:	48 83 c0 01          	add    rax,0x1
  409a71:	49 89 06             	mov    QWORD PTR [r14],rax
  409a74:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  409a79:	01 c9                	add    ecx,ecx
  409a7b:	b8 03 00 00 00       	mov    eax,0x3
  409a80:	d3 e0                	shl    eax,cl
  409a82:	f7 d0                	not    eax
  409a84:	83 e0 fc             	and    eax,0xfffffffc
  409a87:	48 31 c9             	xor    rcx,rcx
  409a8a:	48 31 d2             	xor    rdx,rdx
  409a8d:	0f 01 ef             	wrpkru 
  409a90:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  409a97:	45 23 01 
  409a9a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409aa1:	be ad de 
  409aa4:	49 39 c7             	cmp    r15,rax
  409aa7:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  409aae:	12 12 12 
  409ab1:	48 b9 bd 9a 40 00 00 	movabs rcx,0x409abd
  409ab8:	00 00 00 
  409abb:	ff e0                	jmp    rax

0000000000409abd <srv_call_ret_memmgr_shared_page_map_aligned>:
  409abd:	49 89 c0             	mov    r8,rax
  409ac0:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  409ac7:	be ad de 
  409aca:	48 89 e2             	mov    rdx,rsp
  409acd:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  409ad4:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  409adb:	00 
  409adc:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  409ae3:	7f 00 00 
  409ae6:	4c 89 e8             	mov    rax,r13
  409ae9:	48 25 ff ff 00 00    	and    rax,0xffff
  409aef:	48 c1 e0 08          	shl    rax,0x8
  409af3:	49 01 c6             	add    r14,rax
  409af6:	b9 01 00 00 00       	mov    ecx,0x1
  409afb:	01 c9                	add    ecx,ecx
  409afd:	b8 03 00 00 00       	mov    eax,0x3
  409b02:	d3 e0                	shl    eax,cl
  409b04:	f7 d0                	not    eax
  409b06:	83 e0 fc             	and    eax,0xfffffffc
  409b09:	48 31 c9             	xor    rcx,rcx
  409b0c:	48 31 d2             	xor    rdx,rdx
  409b0f:	0f 01 ef             	wrpkru 
  409b12:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  409b15:	48 c1 e2 04          	shl    rdx,0x4
  409b19:	4c 01 f2             	add    rdx,r14
  409b1c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  409b20:	49 8b 06             	mov    rax,QWORD PTR [r14]
  409b23:	48 83 e8 01          	sub    rax,0x1
  409b27:	49 89 06             	mov    QWORD PTR [r14],rax
  409b2a:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  409b2f:	01 c9                	add    ecx,ecx
  409b31:	b8 03 00 00 00       	mov    eax,0x3
  409b36:	d3 e0                	shl    eax,cl
  409b38:	f7 d0                	not    eax
  409b3a:	83 e0 fc             	and    eax,0xfffffffc
  409b3d:	48 31 c9             	xor    rcx,rcx
  409b40:	48 31 d2             	xor    rdx,rdx
  409b43:	0f 01 ef             	wrpkru 
  409b46:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409b4d:	be ad de 
  409b50:	49 39 c7             	cmp    r15,rax
  409b53:	4c 89 c0             	mov    rax,r8
  409b56:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  409b5a:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  409b5d:	41 5f                	pop    r15
  409b5f:	41 5e                	pop    r14
  409b61:	41 5d                	pop    r13
  409b63:	41 5c                	pop    r12
  409b65:	5b                   	pop    rbx
  409b66:	5d                   	pop    rbp
  409b67:	c3                   	ret    
  409b68:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  409b6f:	00 

0000000000409b70 <__cosrt_extern_memmgr_shared_page_map_aligned_in_vm>:
  409b70:	48 b8 b4 c3 45 00 00 	movabs rax,0x45c3b4
  409b77:	00 00 00 
  409b7a:	ff 10                	call   QWORD PTR [rax]
  409b7c:	c3                   	ret    
  409b7d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000409b80 <__cosrt_fast_callgate_memmgr_shared_page_map_aligned_in_vm>:
  409b80:	55                   	push   rbp
  409b81:	53                   	push   rbx
  409b82:	41 54                	push   r12
  409b84:	41 55                	push   r13
  409b86:	41 56                	push   r14
  409b88:	41 57                	push   r15
  409b8a:	4d 89 c4             	mov    r12,r8
  409b8d:	4c 89 cb             	mov    rbx,r9
  409b90:	49 89 c8             	mov    r8,rcx
  409b93:	49 89 d1             	mov    r9,rdx
  409b96:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  409b9d:	be ad de 
  409ba0:	0f 01 f9             	rdtscp 
  409ba3:	48 89 ca             	mov    rdx,rcx
  409ba6:	48 25 ff 0f 00 00    	and    rax,0xfff
  409bac:	48 89 e2             	mov    rdx,rsp
  409baf:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  409bb6:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  409bbd:	00 
  409bbe:	48 c1 e0 10          	shl    rax,0x10
  409bc2:	49 09 c5             	or     r13,rax
  409bc5:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  409bcc:	7f 00 00 
  409bcf:	4c 89 e8             	mov    rax,r13
  409bd2:	48 25 ff ff 00 00    	and    rax,0xffff
  409bd8:	48 c1 e0 08          	shl    rax,0x8
  409bdc:	49 01 c6             	add    r14,rax
  409bdf:	b9 01 00 00 00       	mov    ecx,0x1
  409be4:	01 c9                	add    ecx,ecx
  409be6:	b8 03 00 00 00       	mov    eax,0x3
  409beb:	d3 e0                	shl    eax,cl
  409bed:	f7 d0                	not    eax
  409bef:	83 e0 fc             	and    eax,0xfffffffc
  409bf2:	48 31 c9             	xor    rcx,rcx
  409bf5:	48 31 d2             	xor    rdx,rdx
  409bf8:	0f 01 ef             	wrpkru 
  409bfb:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  409bfe:	48 83 c2 01          	add    rdx,0x1
  409c02:	48 c1 e2 04          	shl    rdx,0x4
  409c06:	4c 01 f2             	add    rdx,r14
  409c09:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  409c10:	45 23 01 
  409c13:	48 89 02             	mov    QWORD PTR [rdx],rax
  409c16:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  409c1a:	49 8b 06             	mov    rax,QWORD PTR [r14]
  409c1d:	48 83 c0 01          	add    rax,0x1
  409c21:	49 89 06             	mov    QWORD PTR [r14],rax
  409c24:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  409c29:	01 c9                	add    ecx,ecx
  409c2b:	b8 03 00 00 00       	mov    eax,0x3
  409c30:	d3 e0                	shl    eax,cl
  409c32:	f7 d0                	not    eax
  409c34:	83 e0 fc             	and    eax,0xfffffffc
  409c37:	48 31 c9             	xor    rcx,rcx
  409c3a:	48 31 d2             	xor    rdx,rdx
  409c3d:	0f 01 ef             	wrpkru 
  409c40:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  409c47:	45 23 01 
  409c4a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409c51:	be ad de 
  409c54:	49 39 c7             	cmp    r15,rax
  409c57:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  409c5e:	12 12 12 
  409c61:	48 b9 6d 9c 40 00 00 	movabs rcx,0x409c6d
  409c68:	00 00 00 
  409c6b:	ff e0                	jmp    rax

0000000000409c6d <srv_call_ret_memmgr_shared_page_map_aligned_in_vm>:
  409c6d:	49 89 c0             	mov    r8,rax
  409c70:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  409c77:	be ad de 
  409c7a:	48 89 e2             	mov    rdx,rsp
  409c7d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  409c84:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  409c8b:	00 
  409c8c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  409c93:	7f 00 00 
  409c96:	4c 89 e8             	mov    rax,r13
  409c99:	48 25 ff ff 00 00    	and    rax,0xffff
  409c9f:	48 c1 e0 08          	shl    rax,0x8
  409ca3:	49 01 c6             	add    r14,rax
  409ca6:	b9 01 00 00 00       	mov    ecx,0x1
  409cab:	01 c9                	add    ecx,ecx
  409cad:	b8 03 00 00 00       	mov    eax,0x3
  409cb2:	d3 e0                	shl    eax,cl
  409cb4:	f7 d0                	not    eax
  409cb6:	83 e0 fc             	and    eax,0xfffffffc
  409cb9:	48 31 c9             	xor    rcx,rcx
  409cbc:	48 31 d2             	xor    rdx,rdx
  409cbf:	0f 01 ef             	wrpkru 
  409cc2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  409cc5:	48 c1 e2 04          	shl    rdx,0x4
  409cc9:	4c 01 f2             	add    rdx,r14
  409ccc:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  409cd0:	49 8b 06             	mov    rax,QWORD PTR [r14]
  409cd3:	48 83 e8 01          	sub    rax,0x1
  409cd7:	49 89 06             	mov    QWORD PTR [r14],rax
  409cda:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  409cdf:	01 c9                	add    ecx,ecx
  409ce1:	b8 03 00 00 00       	mov    eax,0x3
  409ce6:	d3 e0                	shl    eax,cl
  409ce8:	f7 d0                	not    eax
  409cea:	83 e0 fc             	and    eax,0xfffffffc
  409ced:	48 31 c9             	xor    rcx,rcx
  409cf0:	48 31 d2             	xor    rdx,rdx
  409cf3:	0f 01 ef             	wrpkru 
  409cf6:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409cfd:	be ad de 
  409d00:	49 39 c7             	cmp    r15,rax
  409d03:	4c 89 c0             	mov    rax,r8
  409d06:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  409d0a:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  409d0d:	41 5f                	pop    r15
  409d0f:	41 5e                	pop    r14
  409d11:	41 5d                	pop    r13
  409d13:	41 5c                	pop    r12
  409d15:	5b                   	pop    rbx
  409d16:	5d                   	pop    rbp
  409d17:	c3                   	ret    
  409d18:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  409d1f:	00 

0000000000409d20 <init_parallelism>:
 * functions) are found in the c files in this directory. They
 * generate a .a static library that is linked on-demand.
 */
int
init_parallelism(void)
{
  409d20:	f3 0f 1e fa          	endbr64 
	return NUM_CPU;
}
  409d24:	b8 01 00 00 00       	mov    eax,0x1
  409d29:	c3                   	ret    
  409d2a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000409d30 <cos_aepthd_fn>:
	struct cos_aep_info sched_aep[NUM_CPU];
};

static void
cos_aepthd_fn(void *data)
{
  409d30:	f3 0f 1e fa          	endbr64 
  409d34:	55                   	push   rbp
  409d35:	48 89 f8             	mov    rax,rdi
	struct cos_aep_info *aep_info = (struct cos_aep_info *)data;
	cos_aepthd_fn_t      aep_fn   = aep_info->fn;
	void *               fn_data  = aep_info->data;

	(aep_fn)(aep_info->rcv, fn_data);
  409d38:	48 8b 77 28          	mov    rsi,QWORD PTR [rdi+0x28]
  409d3c:	48 8b 7f 18          	mov    rdi,QWORD PTR [rdi+0x18]
{
  409d40:	48 89 e5             	mov    rbp,rsp
	(aep_fn)(aep_info->rcv, fn_data);
  409d43:	ff 50 20             	call   QWORD PTR [rax+0x20]
  409d46:	be 69 00 00 00       	mov    esi,0x69
  409d4b:	bf f0 cf 41 00       	mov    edi,0x41cff0
  409d50:	e8 7b 03 00 00       	call   40a0d0 <cos_print_str>

	/* TODO: handling destruction */
	assert(0);
  409d55:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  409d5c:	00 00 00 00 
  409d60:	0f 0b                	ud2    
  409d62:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  409d69:	00 00 00 00 
  409d6d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000409d70 <capmgr_thd_create>:
#include <capmgr.h>
#include <cos_thd_init.h>

thdcap_t
capmgr_thd_create(cos_thd_fn_t fn, void *data, thdid_t *tid)
{
  409d70:	f3 0f 1e fa          	endbr64 

/* See comments of cos_thd_create_remote. */
static thdclosure_index_t
cos_thd_init_alloc(void *fn, void *data)
{
	if (!fn) return -1;
  409d74:	48 85 ff             	test   rdi,rdi
  409d77:	0f 84 95 00 00 00    	je     409e12 <capmgr_thd_create+0xa2>
  409d7d:	49 89 f1             	mov    r9,rsi
  409d80:	49 89 f8             	mov    r8,rdi
  409d83:	48 89 d6             	mov    rsi,rdx
  409d86:	41 ba 02 00 00 00    	mov    r10d,0x2
static inline int
cos_cas(unsigned long *target, unsigned long old, unsigned long updated)
{
	char z;
	#if defined(__x86_64__)
	__asm__ __volatile__("lock cmpxchgq %2, %0; setz %1"
  409d8c:	31 d2                	xor    edx,edx
	for (i = 0; i < COS_THD_INIT_REGION_SIZE; i++) {
  409d8e:	b9 40 f9 59 00       	mov    ecx,0x59f940
  409d93:	31 ff                	xor    edi,edi
		if (__thd_init_data[i].fn == NULL) {
  409d95:	48 83 39 00          	cmp    QWORD PTR [rcx],0x0
  409d99:	74 25                	je     409dc0 <capmgr_thd_create+0x50>
	for (i = 0; i < COS_THD_INIT_REGION_SIZE; i++) {
  409d9b:	83 c7 01             	add    edi,0x1
  409d9e:	48 83 c1 10          	add    rcx,0x10
  409da2:	81 ff 00 01 00 00    	cmp    edi,0x100
  409da8:	75 eb                	jne    409d95 <capmgr_thd_create+0x25>
	if (!tried) {
  409daa:	41 83 fa 01          	cmp    r10d,0x1
  409dae:	74 62                	je     409e12 <capmgr_thd_create+0xa2>
  409db0:	41 ba 01 00 00 00    	mov    r10d,0x1
  409db6:	eb d6                	jmp    409d8e <capmgr_thd_create+0x1e>
  409db8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  409dbf:	00 
  409dc0:	48 89 d0             	mov    rax,rdx
  409dc3:	f0 4c 0f b1 01       	lock cmpxchg QWORD PTR [rcx],r8
  409dc8:	0f 94 c0             	sete   al
			if (!ret) continue;
  409dcb:	84 c0                	test   al,al
  409dcd:	74 cc                	je     409d9b <capmgr_thd_create+0x2b>
			assert(__thd_init_data[i].fn == fn);
  409dcf:	48 63 c7             	movsxd rax,edi
  409dd2:	48 c1 e0 04          	shl    rax,0x4
  409dd6:	48 8d 90 40 f9 59 00 	lea    rdx,[rax+0x59f940]
  409ddd:	4c 3b 80 40 f9 59 00 	cmp    r8,QWORD PTR [rax+0x59f940]
  409de4:	75 0c                	jne    409df2 <capmgr_thd_create+0x82>
			__thd_init_data[i].data = data;
  409de6:	4c 89 4a 08          	mov    QWORD PTR [rdx+0x8],r9
			return i + 1;
  409dea:	83 c7 01             	add    edi,0x1
	thdclosure_index_t idx = cos_thd_init_alloc(fn, data);

	if (idx < 1) return 0;

	return capmgr_thd_create_thunk(idx, tid);
  409ded:	e9 ce cb ff ff       	jmp    4069c0 <__cosrt_extern_capmgr_thd_create_thunk>
{
  409df2:	55                   	push   rbp
  409df3:	be 67 00 00 00       	mov    esi,0x67
  409df8:	bf 60 d0 41 00       	mov    edi,0x41d060
  409dfd:	48 89 e5             	mov    rbp,rsp
  409e00:	e8 cb 02 00 00       	call   40a0d0 <cos_print_str>
			assert(__thd_init_data[i].fn == fn);
  409e05:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  409e0c:	00 00 00 00 
  409e10:	0f 0b                	ud2    
}
  409e12:	31 c0                	xor    eax,eax
  409e14:	c3                   	ret    
  409e15:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  409e1c:	00 00 00 00 

0000000000409e20 <capmgr_rcv_alloc>:

arcvcap_t
capmgr_rcv_alloc(cos_thd_fn_t fn, void *data, int flags, asndcap_t *asnd, thdcap_t *thdcap, thdid_t *tid)
{
  409e20:	f3 0f 1e fa          	endbr64 
	if (!fn) return -1;
  409e24:	48 85 ff             	test   rdi,rdi
  409e27:	0f 84 af 00 00 00    	je     409edc <capmgr_rcv_alloc+0xbc>
  409e2d:	55                   	push   rbp
  409e2e:	49 89 cb             	mov    r11,rcx
  409e31:	49 89 fa             	mov    r10,rdi
  409e34:	4c 89 c1             	mov    rcx,r8
  409e37:	4d 89 c8             	mov    r8,r9
  409e3a:	41 b9 02 00 00 00    	mov    r9d,0x2
  409e40:	48 89 e5             	mov    rbp,rsp
  409e43:	41 54                	push   r12
  409e45:	45 31 e4             	xor    r12d,r12d
  409e48:	53                   	push   rbx
  409e49:	48 89 f3             	mov    rbx,rsi
  409e4c:	89 d6                	mov    esi,edx
	for (i = 0; i < COS_THD_INIT_REGION_SIZE; i++) {
  409e4e:	ba 40 f9 59 00       	mov    edx,0x59f940
  409e53:	31 ff                	xor    edi,edi
		if (__thd_init_data[i].fn == NULL) {
  409e55:	48 83 3a 00          	cmp    QWORD PTR [rdx],0x0
  409e59:	74 25                	je     409e80 <capmgr_rcv_alloc+0x60>
	for (i = 0; i < COS_THD_INIT_REGION_SIZE; i++) {
  409e5b:	83 c7 01             	add    edi,0x1
  409e5e:	48 83 c2 10          	add    rdx,0x10
  409e62:	81 ff 00 01 00 00    	cmp    edi,0x100
  409e68:	75 eb                	jne    409e55 <capmgr_rcv_alloc+0x35>
	if (!tried) {
  409e6a:	41 83 f9 01          	cmp    r9d,0x1
  409e6e:	74 65                	je     409ed5 <capmgr_rcv_alloc+0xb5>
  409e70:	41 b9 01 00 00 00    	mov    r9d,0x1
  409e76:	eb d6                	jmp    409e4e <capmgr_rcv_alloc+0x2e>
  409e78:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  409e7f:	00 
  409e80:	4c 89 e0             	mov    rax,r12
  409e83:	f0 4c 0f b1 12       	lock cmpxchg QWORD PTR [rdx],r10
  409e88:	0f 94 c0             	sete   al
			if (!ret) continue;
  409e8b:	84 c0                	test   al,al
  409e8d:	74 cc                	je     409e5b <capmgr_rcv_alloc+0x3b>
			assert(__thd_init_data[i].fn == fn);
  409e8f:	48 63 c7             	movsxd rax,edi
  409e92:	48 c1 e0 04          	shl    rax,0x4
  409e96:	48 8d 90 40 f9 59 00 	lea    rdx,[rax+0x59f940]
  409e9d:	4c 3b 90 40 f9 59 00 	cmp    r10,QWORD PTR [rax+0x59f940]
  409ea4:	75 13                	jne    409eb9 <capmgr_rcv_alloc+0x99>
			__thd_init_data[i].data = data;
  409ea6:	48 89 5a 08          	mov    QWORD PTR [rdx+0x8],rbx
			return i + 1;
  409eaa:	83 c7 01             	add    edi,0x1
	thdclosure_index_t idx = cos_thd_init_alloc(fn, data);

	if (idx < 1) return 0;

	return capmgr_rcv_create(idx, flags, asnd, thdcap, tid);
}
  409ead:	5b                   	pop    rbx
	return capmgr_rcv_create(idx, flags, asnd, thdcap, tid);
  409eae:	4c 89 da             	mov    rdx,r11
}
  409eb1:	41 5c                	pop    r12
  409eb3:	5d                   	pop    rbp
	return capmgr_rcv_create(idx, flags, asnd, thdcap, tid);
  409eb4:	e9 77 d3 ff ff       	jmp    407230 <__cosrt_extern_capmgr_rcv_create>
  409eb9:	be 67 00 00 00       	mov    esi,0x67
  409ebe:	bf 60 d0 41 00       	mov    edi,0x41d060
  409ec3:	e8 08 02 00 00       	call   40a0d0 <cos_print_str>
			assert(__thd_init_data[i].fn == fn);
  409ec8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  409ecf:	00 00 00 00 
  409ed3:	0f 0b                	ud2    
}
  409ed5:	5b                   	pop    rbx
  409ed6:	31 c0                	xor    eax,eax
  409ed8:	41 5c                	pop    r12
  409eda:	5d                   	pop    rbp
  409edb:	c3                   	ret    
  409edc:	31 c0                	xor    eax,eax
  409ede:	c3                   	ret    
  409edf:	90                   	nop

0000000000409ee0 <capmgr_aep_create>:

thdcap_t
capmgr_aep_create(struct cos_aep_info *a, cos_aepthd_fn_t fn, void *data, int owntc, cos_channelkey_t key, microsec_t ipiwin, u32_t ipimax)
{
  409ee0:	f3 0f 1e fa          	endbr64 
  409ee4:	55                   	push   rbp
  409ee5:	41 89 ca             	mov    r10d,ecx
  409ee8:	44 89 c1             	mov    ecx,r8d
  409eeb:	4d 89 c8             	mov    r8,r9
  409eee:	49 89 f3             	mov    r11,rsi
  409ef1:	48 89 e5             	mov    rbp,rsp
  409ef4:	41 56                	push   r14
again:
  409ef6:	41 be 02 00 00 00    	mov    r14d,0x2
  409efc:	44 8b 4d 10          	mov    r9d,DWORD PTR [rbp+0x10]
  409f00:	41 55                	push   r13
  409f02:	41 bd 30 9d 40 00    	mov    r13d,0x409d30
  409f08:	41 54                	push   r12
  409f0a:	45 31 e4             	xor    r12d,r12d
  409f0d:	53                   	push   rbx
  409f0e:	48 89 d3             	mov    rbx,rdx
	for (i = 0; i < COS_THD_INIT_REGION_SIZE; i++) {
  409f11:	ba 40 f9 59 00       	mov    edx,0x59f940
  409f16:	31 f6                	xor    esi,esi
		if (__thd_init_data[i].fn == NULL) {
  409f18:	48 83 3a 00          	cmp    QWORD PTR [rdx],0x0
  409f1c:	74 22                	je     409f40 <capmgr_aep_create+0x60>
	for (i = 0; i < COS_THD_INIT_REGION_SIZE; i++) {
  409f1e:	83 c6 01             	add    esi,0x1
  409f21:	48 83 c2 10          	add    rdx,0x10
  409f25:	81 fe 00 01 00 00    	cmp    esi,0x100
  409f2b:	75 eb                	jne    409f18 <capmgr_aep_create+0x38>
	if (!tried) {
  409f2d:	41 83 fe 01          	cmp    r14d,0x1
  409f31:	75 75                	jne    409fa8 <capmgr_aep_create+0xc8>
	if (idx < 1) return 0;
	a->fn   = fn;
	a->data = data;

	return capmgr_aep_create_thunk(a, idx, owntc, key, ipiwin, ipimax);
}
  409f33:	5b                   	pop    rbx
  409f34:	31 c0                	xor    eax,eax
  409f36:	41 5c                	pop    r12
  409f38:	41 5d                	pop    r13
  409f3a:	41 5e                	pop    r14
  409f3c:	5d                   	pop    rbp
  409f3d:	c3                   	ret    
  409f3e:	66 90                	xchg   ax,ax
  409f40:	4c 89 e0             	mov    rax,r12
  409f43:	f0 4c 0f b1 2a       	lock cmpxchg QWORD PTR [rdx],r13
  409f48:	0f 94 c0             	sete   al
			if (!ret) continue;
  409f4b:	84 c0                	test   al,al
  409f4d:	74 cf                	je     409f1e <capmgr_aep_create+0x3e>
			assert(__thd_init_data[i].fn == fn);
  409f4f:	48 63 c6             	movsxd rax,esi
  409f52:	48 c1 e0 04          	shl    rax,0x4
  409f56:	48 8d 90 40 f9 59 00 	lea    rdx,[rax+0x59f940]
  409f5d:	48 81 b8 40 f9 59 00 	cmp    QWORD PTR [rax+0x59f940],0x409d30
  409f64:	30 9d 40 00 
  409f68:	75 22                	jne    409f8c <capmgr_aep_create+0xac>
			__thd_init_data[i].data = data;
  409f6a:	48 89 7a 08          	mov    QWORD PTR [rdx+0x8],rdi
	return capmgr_aep_create_thunk(a, idx, owntc, key, ipiwin, ipimax);
  409f6e:	0f b7 c9             	movzx  ecx,cx
			return i + 1;
  409f71:	83 c6 01             	add    esi,0x1
  409f74:	44 89 d2             	mov    edx,r10d
	a->fn   = fn;
  409f77:	4c 89 5f 20          	mov    QWORD PTR [rdi+0x20],r11
	a->data = data;
  409f7b:	48 89 5f 28          	mov    QWORD PTR [rdi+0x28],rbx
}
  409f7f:	5b                   	pop    rbx
  409f80:	41 5c                	pop    r12
  409f82:	41 5d                	pop    r13
  409f84:	41 5e                	pop    r14
  409f86:	5d                   	pop    rbp
	return capmgr_aep_create_thunk(a, idx, owntc, key, ipiwin, ipimax);
  409f87:	e9 44 cf ff ff       	jmp    406ed0 <__cosrt_extern_capmgr_aep_create_thunk>
  409f8c:	be 67 00 00 00       	mov    esi,0x67
  409f91:	bf 60 d0 41 00       	mov    edi,0x41d060
  409f96:	e8 35 01 00 00       	call   40a0d0 <cos_print_str>
			assert(__thd_init_data[i].fn == fn);
  409f9b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  409fa2:	00 00 00 00 
  409fa6:	0f 0b                	ud2    
  409fa8:	41 be 01 00 00 00    	mov    r14d,0x1
  409fae:	e9 5e ff ff ff       	jmp    409f11 <capmgr_aep_create+0x31>
  409fb3:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  409fba:	00 00 00 
  409fbd:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000409fc0 <main>:
 * __crt_main is just used to identify if the user has defined their
 * own main (thus overriding the weak place-holder below)
 */
static int
__crt_main(void)
{
  409fc0:	f3 0f 1e fa          	endbr64 
	return 0;
}
  409fc4:	31 c0                	xor    eax,eax
  409fc6:	c3                   	ret    
  409fc7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  409fce:	00 00 

0000000000409fd0 <__crt_parallel_main>:
	return;
}

static void
__crt_parallel_main(coreid_t cid, int init_core, int ncores)
{
  409fd0:	f3 0f 1e fa          	endbr64 
	return;
}
  409fd4:	c3                   	ret    
  409fd5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  409fdc:	00 00 00 00 

0000000000409fe0 <__crt_cos_parallel_init>:
  409fe0:	f3 0f 1e fa          	endbr64 
  409fe4:	c3                   	ret    
  409fe5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  409fec:	00 00 00 00 
{
  409ff0:	f3 0f 1e fa          	endbr64 
}
  409ff4:	c3                   	ret    
  409ff5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  409ffc:	00 00 00 00 

000000000040a000 <cos_main_defined>:
}
COS_FN_WEAKALIAS(cos_parallel_init, __crt_cos_parallel_init);

int
cos_main_defined(void)
{
  40a000:	f3 0f 1e fa          	endbr64 
	return __crt_main != main;
  40a004:	b8 c0 9f 40 00       	mov    eax,0x409fc0
  40a009:	48 3d c0 9f 40 00    	cmp    rax,0x409fc0
  40a00f:	0f 95 c0             	setne  al
  40a012:	0f b6 c0             	movzx  eax,al
}
  40a015:	c3                   	ret    
  40a016:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40a01d:	00 00 00 

000000000040a020 <pre_syscall_default_setup>:
  40a020:	f3 0f 1e fa          	endbr64 
  40a024:	c3                   	ret    
  40a025:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a02c:	00 00 00 00 

000000000040a030 <pre_syscall_setup>:
}

/* Intended to be overriden by components */
CWEAKSYMB void
pre_syscall_setup()
{
  40a030:	f3 0f 1e fa          	endbr64 
	pre_syscall_default_setup();
  40a034:	31 c0                	xor    eax,eax
  40a036:	e9 e5 ff ff ff       	jmp    40a020 <pre_syscall_default_setup>
  40a03b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000040a040 <syscall_emulation_setup>:
  40a040:	f3 0f 1e fa          	endbr64 
  40a044:	c3                   	ret    
  40a045:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a04c:	00 00 00 00 

000000000040a050 <libc_initialization_handler>:
  40a050:	f3 0f 1e fa          	endbr64 
  40a054:	c3                   	ret    
  40a055:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a05c:	00 00 00 00 

000000000040a060 <libc_posixcap_initialization_handler>:
  40a060:	f3 0f 1e fa          	endbr64 
  40a064:	c3                   	ret    
  40a065:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a06c:	00 00 00 00 

000000000040a070 <libc_posixsched_initialization_handler>:
  40a070:	f3 0f 1e fa          	endbr64 
  40a074:	c3                   	ret    
  40a075:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a07c:	00 00 00 00 

000000000040a080 <libc_tls_init>:
{
}

CWEAKSYMB void
libc_tls_init(unsigned int cpuid)
{
  40a080:	f3 0f 1e fa          	endbr64 

}
  40a084:	c3                   	ret    
  40a085:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a08c:	00 00 00 00 

000000000040a090 <libc_init>:
/* TODO: Make this a weak symbol (currently doing so makes this fail) */
void __init_libc(char **envp, char *pn);

void
libc_init()
{
  40a090:	f3 0f 1e fa          	endbr64 
                               (char *)AT_SECURE,
                               (char *)0, /* Whether the program is being run under sudo */
                               NULL
	};
	char *program_name = "composite component";
	__init_libc(envp, program_name);
  40a094:	be c8 d0 41 00       	mov    esi,0x41d0c8
  40a099:	bf 20 60 42 00       	mov    edi,0x426020
  40a09e:	e9 1d ae 00 00       	jmp    414ec0 <__init_libc>
  40a0a3:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a0aa:	00 00 00 00 
  40a0ae:	66 90                	xchg   ax,ax

000000000040a0b0 <cos_upcall_exec>:
}

CWEAKSYMB void
cos_upcall_exec(void *arg)
{
  40a0b0:	f3 0f 1e fa          	endbr64 
}
  40a0b4:	c3                   	ret    
  40a0b5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a0bc:	00 00 00 00 

000000000040a0c0 <cos_async_inv>:

CWEAKSYMB int
cos_async_inv(struct usr_inv_cap *ucap, int *params)
{
  40a0c0:	f3 0f 1e fa          	endbr64 
	return 0;
}
  40a0c4:	31 c0                	xor    eax,eax
  40a0c6:	c3                   	ret    
  40a0c7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40a0ce:	00 00 

000000000040a0d0 <cos_print_str>:
	return 0;
}

CWEAKSYMB int
cos_print_str(char *s, int len)
{
  40a0d0:	f3 0f 1e fa          	endbr64 
	int written = 0;

	while (written < len) {
  40a0d4:	85 f6                	test   esi,esi
  40a0d6:	0f 8e a4 00 00 00    	jle    40a180 <cos_print_str+0xb0>
{
  40a0dc:	55                   	push   rbp
	int written = 0;
  40a0dd:	45 31 d2             	xor    r10d,r10d
{
  40a0e0:	48 89 e5             	mov    rbp,rsp
  40a0e3:	41 57                	push   r15
  40a0e5:	41 56                	push   r14
  40a0e7:	4c 8d 7d c0          	lea    r15,[rbp-0x40]
  40a0eb:	49 89 fe             	mov    r14,rdi
  40a0ee:	41 55                	push   r13
  40a0f0:	41 89 f5             	mov    r13d,esi
  40a0f3:	41 54                	push   r12
  40a0f5:	53                   	push   rbx
  40a0f6:	eb 10                	jmp    40a108 <cos_print_str+0x38>
  40a0f8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40a0ff:	00 
		int ret;

		ret = call_cap(PRINT_CAP_TEMP, s_ints[0], s_ints[1], s_ints[2], len - written);
		/* Bomb out. Can't use a print out here as we must avoid recursion. */
		if (ret < 0) written = *(int *)NULL;
		written += ret;
  40a100:	41 01 c2             	add    r10d,eax
	while (written < len) {
  40a103:	45 39 d5             	cmp    r13d,r10d
  40a106:	7e 60                	jle    40a168 <cos_print_str+0x98>
		u32_t *s_ints = (u32_t *)&s[written];
  40a108:	49 63 c2             	movsxd rax,r10d
		ret = call_cap(PRINT_CAP_TEMP, s_ints[0], s_ints[1], s_ints[2], len - written);
  40a10b:	44 89 ea             	mov    edx,r13d
	__asm__ __volatile__(
  40a10e:	4c 89 f9             	mov    rcx,r15
		u32_t *s_ints = (u32_t *)&s[written];
  40a111:	4c 01 f0             	add    rax,r14
		ret = call_cap(PRINT_CAP_TEMP, s_ints[0], s_ints[1], s_ints[2], len - written);
  40a114:	44 29 d2             	sub    edx,r10d
  40a117:	8b 18                	mov    ebx,DWORD PTR [rax]
  40a119:	8b 70 04             	mov    esi,DWORD PTR [rax+0x4]
  40a11c:	48 63 d2             	movsxd rdx,edx
  40a11f:	8b 78 08             	mov    edi,DWORD PTR [rax+0x8]
  40a122:	b8 00 00 03 00       	mov    eax,0x30000
  40a127:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40a12a:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40a12e:	48 89 cd             	mov    rbp,rcx
  40a131:	49 b8 48 a1 40 00 00 	movabs r8,0x40a148
  40a138:	00 00 00 
  40a13b:	0f 05                	syscall 
  40a13d:	0f 1f 00             	nop    DWORD PTR [rax]
  40a140:	eb 0d                	jmp    40a14f <cos_print_str+0x7f>
  40a142:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40a148:	b9 00 00 00 00       	mov    ecx,0x0
  40a14d:	eb 05                	jmp    40a154 <cos_print_str+0x84>
  40a14f:	b9 01 00 00 00       	mov    ecx,0x1
  40a154:	5d                   	pop    rbp
  40a155:	5c                   	pop    rsp
		if (ret < 0) written = *(int *)NULL;
  40a156:	85 c0                	test   eax,eax
  40a158:	79 a6                	jns    40a100 <cos_print_str+0x30>
  40a15a:	8b 04 25 00 00 00 00 	mov    eax,DWORD PTR ds:0x0
  40a161:	0f 0b                	ud2    
  40a163:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	}

	return written;
}
  40a168:	44 89 d0             	mov    eax,r10d
  40a16b:	5b                   	pop    rbx
  40a16c:	41 5c                	pop    r12
  40a16e:	41 5d                	pop    r13
  40a170:	41 5e                	pop    r14
  40a172:	41 5f                	pop    r15
  40a174:	5d                   	pop    rbp
  40a175:	c3                   	ret    
  40a176:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40a17d:	00 00 00 
  40a180:	31 c0                	xor    eax,eax
  40a182:	c3                   	ret    
  40a183:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a18a:	00 00 00 00 
  40a18e:	66 90                	xchg   ax,ax

000000000040a190 <printc.constprop.0>:
printc(char *fmt, ...)
  40a190:	55                   	push   rbp
  40a191:	48 89 e5             	mov    rbp,rsp
  40a194:	48 81 ec 90 01 00 00 	sub    rsp,0x190
  40a19b:	48 89 b5 58 ff ff ff 	mov    QWORD PTR [rbp-0xa8],rsi
  40a1a2:	48 89 95 60 ff ff ff 	mov    QWORD PTR [rbp-0xa0],rdx
  40a1a9:	48 89 8d 68 ff ff ff 	mov    QWORD PTR [rbp-0x98],rcx
  40a1b0:	4c 89 85 70 ff ff ff 	mov    QWORD PTR [rbp-0x90],r8
  40a1b7:	4c 89 8d 78 ff ff ff 	mov    QWORD PTR [rbp-0x88],r9
  40a1be:	84 c0                	test   al,al
  40a1c0:	74 20                	je     40a1e2 <printc.constprop.0+0x52>
  40a1c2:	0f 29 45 80          	movaps XMMWORD PTR [rbp-0x80],xmm0
  40a1c6:	0f 29 4d 90          	movaps XMMWORD PTR [rbp-0x70],xmm1
  40a1ca:	0f 29 55 a0          	movaps XMMWORD PTR [rbp-0x60],xmm2
  40a1ce:	0f 29 5d b0          	movaps XMMWORD PTR [rbp-0x50],xmm3
  40a1d2:	0f 29 65 c0          	movaps XMMWORD PTR [rbp-0x40],xmm4
  40a1d6:	0f 29 6d d0          	movaps XMMWORD PTR [rbp-0x30],xmm5
  40a1da:	0f 29 75 e0          	movaps XMMWORD PTR [rbp-0x20],xmm6
  40a1de:	0f 29 7d f0          	movaps XMMWORD PTR [rbp-0x10],xmm7
	va_start(arg_ptr, fmt);
  40a1e2:	48 8d 45 10          	lea    rax,[rbp+0x10]
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40a1e6:	ba e0 d0 41 00       	mov    edx,0x41d0e0
  40a1eb:	be b4 00 00 00       	mov    esi,0xb4
	va_start(arg_ptr, fmt);
  40a1f0:	c7 85 78 fe ff ff 08 	mov    DWORD PTR [rbp-0x188],0x8
  40a1f7:	00 00 00 
  40a1fa:	48 89 85 80 fe ff ff 	mov    QWORD PTR [rbp-0x180],rax
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40a201:	48 8d 8d 78 fe ff ff 	lea    rcx,[rbp-0x188]
	va_start(arg_ptr, fmt);
  40a208:	48 8d 85 50 ff ff ff 	lea    rax,[rbp-0xb0]
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40a20f:	48 8d bd 90 fe ff ff 	lea    rdi,[rbp-0x170]
	va_start(arg_ptr, fmt);
  40a216:	48 89 85 88 fe ff ff 	mov    QWORD PTR [rbp-0x178],rax
  40a21d:	c7 85 7c fe ff ff 30 	mov    DWORD PTR [rbp-0x184],0x30
  40a224:	00 00 00 
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40a227:	e8 34 b3 00 00       	call   415560 <vsnprintf>
	ret = cos_print_str(s, ret);
  40a22c:	48 8d bd 90 fe ff ff 	lea    rdi,[rbp-0x170]
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40a233:	89 c6                	mov    esi,eax
	ret = cos_print_str(s, ret);
  40a235:	e8 96 fe ff ff       	call   40a0d0 <cos_print_str>
}
  40a23a:	c9                   	leave  
  40a23b:	c3                   	ret    
  40a23c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000040a240 <prints.isra.0>:
prints(char *s)
  40a240:	55                   	push   rbp
  40a241:	48 89 e5             	mov    rbp,rsp
  40a244:	41 54                	push   r12
  40a246:	49 89 fc             	mov    r12,rdi
  40a249:	48 83 ec 08          	sub    rsp,0x8
	return cos_print_str(s, strlen(s));
  40a24d:	e8 7e b7 00 00       	call   4159d0 <strlen>
  40a252:	4c 89 e7             	mov    rdi,r12
}
  40a255:	4c 8b 65 f8          	mov    r12,QWORD PTR [rbp-0x8]
  40a259:	c9                   	leave  
	return cos_print_str(s, strlen(s));
  40a25a:	89 c6                	mov    esi,eax
  40a25c:	e9 6f fe ff ff       	jmp    40a0d0 <cos_print_str>
  40a261:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a268:	00 00 00 00 
  40a26c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000040a270 <cos_thd_entry_static>:
{
  40a270:	f3 0f 1e fa          	endbr64 
  40a274:	55                   	push   rbp
  40a275:	be 2d 00 00 00       	mov    esi,0x2d
  40a27a:	bf 28 d1 41 00       	mov    edi,0x41d128
  40a27f:	48 89 e5             	mov    rbp,rsp
  40a282:	e8 49 fe ff ff       	call   40a0d0 <cos_print_str>
	assert(0);
  40a287:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40a28e:	00 00 00 00 
  40a292:	0f 0b                	ud2    
  40a294:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a29b:	00 00 00 00 
  40a29f:	90                   	nop

000000000040a2a0 <cos_syscall_handler>:
{
  40a2a0:	f3 0f 1e fa          	endbr64 
  40a2a4:	55                   	push   rbp
  40a2a5:	48 89 f2             	mov    rdx,rsi
	printc("Default syscall handler called (syscall: %d, first arg: %ld), faulting!", syscall_num, a);
  40a2a8:	31 c0                	xor    eax,eax
  40a2aa:	89 fe                	mov    esi,edi
  40a2ac:	bf e0 d0 41 00       	mov    edi,0x41d0e0
{
  40a2b1:	48 89 e5             	mov    rbp,rsp
	printc("Default syscall handler called (syscall: %d, first arg: %ld), faulting!", syscall_num, a);
  40a2b4:	e8 d7 fe ff ff       	call   40a190 <printc.constprop.0>
  40a2b9:	be 2c 00 00 00       	mov    esi,0x2c
  40a2be:	bf 58 d1 41 00       	mov    edi,0x41d158
  40a2c3:	e8 08 fe ff ff       	call   40a0d0 <cos_print_str>
	assert(0);
  40a2c8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40a2cf:	00 00 00 00 
  40a2d3:	0f 0b                	ud2    
  40a2d5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a2dc:	00 00 00 00 

000000000040a2e0 <__cos_syscall>:
{
  40a2e0:	f3 0f 1e fa          	endbr64 
	return cos_syscall_handler(syscall_num, a, b, c, d, e, f, g);
  40a2e4:	e9 b7 ff ff ff       	jmp    40a2a0 <cos_syscall_handler>
  40a2e9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000040a2f0 <cos_main>:
{
  40a2f0:	f3 0f 1e fa          	endbr64 
	assert(cos_main_defined());
  40a2f4:	b8 c0 9f 40 00       	mov    eax,0x409fc0
  40a2f9:	48 3d c0 9f 40 00    	cmp    rax,0x409fc0
  40a2ff:	74 05                	je     40a306 <cos_main+0x16>
	return main();
  40a301:	e9 ba fc ff ff       	jmp    409fc0 <main>
{
  40a306:	55                   	push   rbp
  40a307:	be 2c 00 00 00       	mov    esi,0x2c
  40a30c:	bf 88 d1 41 00       	mov    edi,0x41d188
  40a311:	48 89 e5             	mov    rbp,rsp
  40a314:	e8 b7 fd ff ff       	call   40a0d0 <cos_print_str>
	assert(cos_main_defined());
  40a319:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40a320:	00 00 00 00 
  40a324:	0f 0b                	ud2    
  40a326:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40a32d:	00 00 00 

000000000040a330 <cos_print_level_set>:
int cos_print_level   = PRINT_ERROR;
int cos_print_lvl_str = 0;

CWEAKSYMB void
cos_print_level_set(cos_print_level_t lvl, int print_str)
{
  40a330:	f3 0f 1e fa          	endbr64 
	cos_print_level   = lvl;
  40a334:	89 3d 0a 66 19 00    	mov    DWORD PTR [rip+0x19660a],edi        # 5a0944 <cos_print_level>
	cos_print_lvl_str = print_str;
  40a33a:	89 35 00 66 19 00    	mov    DWORD PTR [rip+0x196600],esi        # 5a0940 <cos_print_lvl_str>
}
  40a340:	c3                   	ret    
  40a341:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a348:	00 00 00 00 
  40a34c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000040a350 <cos_upcall_fn>:
}
#endif

CWEAKSYMB void
cos_upcall_fn(upcall_type_t t, void *arg1, void *arg2, void *arg3)
{
  40a350:	f3 0f 1e fa          	endbr64 
  40a354:	55                   	push   rbp
  40a355:	b9 01 00 00 00       	mov    ecx,0x1
  40a35a:	31 d2                	xor    edx,edx
  40a35c:	48 89 e5             	mov    rbp,rsp
  40a35f:	41 55                	push   r13
  40a361:	41 54                	push   r12
  40a363:	41 89 fc             	mov    r12d,edi
  40a366:	53                   	push   rbx
  40a367:	48 89 f3             	mov    rbx,rsi
  40a36a:	48 83 ec 08          	sub    rsp,0x8
  40a36e:	66 90                	xchg   ax,ax
  40a370:	48 89 d0             	mov    rax,rdx
  40a373:	f0 48 0f b1 0d d4 65 	lock cmpxchg QWORD PTR [rip+0x1965d4],rcx        # 5a0950 <_lock.1>
  40a37a:	19 00 
  40a37c:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40a37f:	84 c0                	test   al,al
  40a381:	74 ed                	je     40a370 <cos_upcall_fn+0x20>
	 * There should be no concurrency at initialization (the init
	 * interface ensures this), so atomic operations aren't
	 * required here to update first.
	 */
	ps_lock_take(&_lock);
	libc_tls_init(cos_cpuid());
  40a383:	31 ff                	xor    edi,edi
  40a385:	e8 f6 fc ff ff       	call   40a080 <libc_tls_init>
	if (first) {
  40a38a:	8b 05 78 bc 01 00    	mov    eax,DWORD PTR [rip+0x1bc78]        # 426008 <first.2>
  40a390:	85 c0                	test   eax,eax
  40a392:	0f 84 a5 00 00 00    	je     40a43d <cos_upcall_fn+0xed>
		/*
		 * Use the heap pointer as calculated from the linker
		 * script *if* the loader doesn't pass in its own
		 * value.
		 */
		if (__cosrt_comp_info.cos_heap_ptr == 0) {
  40a398:	48 83 3d b8 cc 01 00 	cmp    QWORD PTR [rip+0x1ccb8],0x0        # 427058 <__cosrt_comp_info+0x58>
  40a39f:	00 
		first = 0;
  40a3a0:	c7 05 5e bc 01 00 00 	mov    DWORD PTR [rip+0x1bc5e],0x0        # 426008 <first.2>
  40a3a7:	00 00 00 
		if (__cosrt_comp_info.cos_heap_ptr == 0) {
  40a3aa:	75 12                	jne    40a3be <cos_upcall_fn+0x6e>
			extern const vaddr_t __crt_static_heap_ptr;

			__cosrt_comp_info.cos_heap_ptr = round_up_to_page((vaddr_t)&__crt_static_heap_ptr);
  40a3ac:	b8 87 32 5a 00       	mov    eax,0x5a3287
  40a3b1:	48 25 00 f0 ff ff    	and    rax,0xfffffffffffff000
  40a3b7:	48 89 05 9a cc 01 00 	mov    QWORD PTR [rip+0x1cc9a],rax        # 427058 <__cosrt_comp_info+0x58>
		}

		cos_print_level_set(PRINT_DEBUG, 1);
  40a3be:	be 01 00 00 00       	mov    esi,0x1
  40a3c3:	bf 02 00 00 00       	mov    edi,0x2
static inline void
section_fnptrs_execute(long *list)
{
	int i;

	for (i = 0; i < list[0]; i++) {
  40a3c8:	45 31 ed             	xor    r13d,r13d
  40a3cb:	e8 60 ff ff ff       	call   40a330 <cos_print_level_set>
		/* The syscall enumlator might need something to be setup before it can work */
		pre_syscall_setup();
  40a3d0:	31 c0                	xor    eax,eax
  40a3d2:	e8 59 fc ff ff       	call   40a030 <pre_syscall_setup>
		/* libc needs syscall emulation to work */
		syscall_emulation_setup();
  40a3d7:	31 c0                	xor    eax,eax
  40a3d9:	e8 62 fc ff ff       	call   40a040 <syscall_emulation_setup>
		/* With all that setup, we can invoke the libc_initialization_handler */
		libc_initialization_handler();
  40a3de:	31 c0                	xor    eax,eax
  40a3e0:	e8 6b fc ff ff       	call   40a050 <libc_initialization_handler>
		/* init lib posix variants */
		libc_posixcap_initialization_handler();
  40a3e5:	31 c0                	xor    eax,eax
  40a3e7:	e8 74 fc ff ff       	call   40a060 <libc_posixcap_initialization_handler>
		libc_posixsched_initialization_handler();
  40a3ec:	31 c0                	xor    eax,eax
  40a3ee:	e8 7d fc ff ff       	call   40a070 <libc_posixsched_initialization_handler>
  40a3f3:	48 83 3d 05 8c 01 00 	cmp    QWORD PTR [rip+0x18c05],0x0        # 423000 <__CTOR_LIST__>
  40a3fa:	00 
  40a3fb:	7e 18                	jle    40a415 <cos_upcall_fn+0xc5>
  40a3fd:	0f 1f 00             	nop    DWORD PTR [rax]
		typedef void (*ctors_t)(void);
		ctors_t ctors = (ctors_t)list[i + 1];
		ctors();
  40a400:	42 ff 14 ed 08 30 42 	call   QWORD PTR [r13*8+0x423008]
  40a407:	00 
	for (i = 0; i < list[0]; i++) {
  40a408:	49 83 c5 01          	add    r13,0x1
  40a40c:	4c 3b 2d ed 8b 01 00 	cmp    r13,QWORD PTR [rip+0x18bed]        # 423000 <__CTOR_LIST__>
  40a413:	7c eb                	jl     40a400 <cos_upcall_fn+0xb0>
  40a415:	45 31 ed             	xor    r13d,r13d
  40a418:	48 83 3d 00 8c 01 00 	cmp    QWORD PTR [rip+0x18c00],0x0        # 423020 <__DTOR_END__>
  40a41f:	00 
  40a420:	7e 1b                	jle    40a43d <cos_upcall_fn+0xed>
  40a422:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
		ctors();
  40a428:	42 ff 14 ed 28 30 42 	call   QWORD PTR [r13*8+0x423028]
  40a42f:	00 
	for (i = 0; i < list[0]; i++) {
  40a430:	49 83 c5 01          	add    r13,0x1
  40a434:	4c 39 2d e5 8b 01 00 	cmp    QWORD PTR [rip+0x18be5],r13        # 423020 <__DTOR_END__>
  40a43b:	7f eb                	jg     40a428 <cos_upcall_fn+0xd8>
	ps_lock_release(&_lock);
	/*
	 * if it's the first component.. wait for timer calibration.
	 * NOTE: for "fork"ing components and not updating "spdid"s, this call will just fail and should be fine.
	 */
	if (cos_compid_uninitialized()) { /* we must be in the initial booter! */
  40a43d:	48 83 3d fb cb 01 00 	cmp    QWORD PTR [rip+0x1cbfb],0x0        # 427040 <__cosrt_comp_info+0x40>
  40a444:	00 
{ l->o = 0; }
  40a445:	48 c7 05 00 65 19 00 	mov    QWORD PTR [rip+0x196500],0x0        # 5a0950 <_lock.1>
  40a44c:	00 00 00 00 
  40a450:	74 58                	je     40a4aa <cos_upcall_fn+0x15a>
		cos_hw_cycles_per_usec(BOOT_CAPTBL_SELF_INITHW_BASE);
		perfcntr_init();
	}

	switch (t) {
  40a452:	45 85 e4             	test   r12d,r12d
  40a455:	75 62                	jne    40a4b9 <cos_upcall_fn+0x169>
	{
		/* A new thread is created in this comp. */

		/* arg1 is the thread init data. 0 means
		 * bootstrap. */
		if (arg1 == 0) {
  40a457:	48 85 db             	test   rbx,rbx
  40a45a:	0f 84 82 00 00 00    	je     40a4e2 <cos_upcall_fn+0x192>
			static unsigned long first_core = 1;

			/* FIXME: assume that core 0 is the initial core for now */
			start_execution(cos_coreid(), ps_cas(&first_core, 1, 0), init_parallelism());
		} else {
			word_t idx = (word_t)arg1 - 1;
  40a460:	48 83 eb 01          	sub    rbx,0x1
			if (idx >= COS_THD_INIT_REGION_SIZE) {
  40a464:	48 81 fb ff 00 00 00 	cmp    rbx,0xff
  40a46b:	77 68                	ja     40a4d5 <cos_upcall_fn+0x185>
	fn   = __thd_init_data[idx].fn;
  40a46d:	89 db                	mov    ebx,ebx
	__thd_init_data[idx].fn   = NULL;
  40a46f:	66 0f ef c0          	pxor   xmm0,xmm0
	fn   = __thd_init_data[idx].fn;
  40a473:	48 c1 e3 04          	shl    rbx,0x4
  40a477:	48 8b 83 40 f9 59 00 	mov    rax,QWORD PTR [rbx+0x59f940]
	data = __thd_init_data[idx].data;
  40a47e:	48 8b bb 48 f9 59 00 	mov    rdi,QWORD PTR [rbx+0x59f948]
	__thd_init_data[idx].fn   = NULL;
  40a485:	0f 29 83 40 f9 59 00 	movaps XMMWORD PTR [rbx+0x59f940],xmm0
	(fn)(data);
  40a48c:	ff d0                	call   rax
  40a48e:	be 2d 00 00 00       	mov    esi,0x2d
  40a493:	bf 78 d2 41 00       	mov    edi,0x41d278
  40a498:	e8 33 fc ff ff       	call   40a0d0 <cos_print_str>
	}
	default:
		/* fault! */
		assert(0);
	}
	assert(0); 		/* should *not* return from threads */
  40a49d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40a4a4:	00 00 00 00 
  40a4a8:	0f 0b                	ud2    
		cos_hw_cycles_per_usec(BOOT_CAPTBL_SELF_INITHW_BASE);
  40a4aa:	bf 24 00 00 00       	mov    edi,0x24
  40a4af:	e8 6c 7a 00 00       	call   411f20 <cos_hw_cycles_per_usec>
	switch (t) {
  40a4b4:	45 85 e4             	test   r12d,r12d
  40a4b7:	74 9e                	je     40a457 <cos_upcall_fn+0x107>
  40a4b9:	be 2d 00 00 00       	mov    esi,0x2d
  40a4be:	bf 48 d2 41 00       	mov    edi,0x41d248
  40a4c3:	e8 08 fc ff ff       	call   40a0d0 <cos_print_str>
		assert(0);
  40a4c8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40a4cf:	00 00 00 00 
  40a4d3:	0f 0b                	ud2    
				cos_thd_entry_static(idx - COS_THD_INIT_REGION_SIZE);
  40a4d5:	8d bb 00 ff ff ff    	lea    edi,[rbx-0x100]
  40a4db:	e8 90 fd ff ff       	call   40a270 <cos_thd_entry_static>
  40a4e0:	eb ac                	jmp    40a48e <cos_upcall_fn+0x13e>
			start_execution(cos_coreid(), ps_cas(&first_core, 1, 0), init_parallelism());
  40a4e2:	e8 39 f8 ff ff       	call   409d20 <init_parallelism>
        __asm__ __volatile__("lock " PS_CAS_STR
  40a4e7:	b8 01 00 00 00       	mov    eax,0x1
  40a4ec:	f0 48 0f b1 1d 0b bb 	lock cmpxchg QWORD PTR [rip+0x1bb0b],rbx        # 426000 <first_core.3>
  40a4f3:	01 00 
  40a4f5:	0f 94 c0             	sete   al
        return (int)z;
  40a4f8:	44 0f be e8          	movsx  r13d,al
	if (parallel_main != __crt_parallel_main) {
  40a4fc:	b8 00 47 40 00       	mov    eax,0x404700
  40a501:	48 3d d0 9f 40 00    	cmp    rax,0x409fd0
  40a507:	0f 84 9b 00 00 00    	je     40a5a8 <cos_upcall_fn+0x258>
	if (initialization_completed == 0) {
  40a50d:	8b 05 39 64 19 00    	mov    eax,DWORD PTR [rip+0x196439]        # 5a094c <initialization_completed.4>
  40a513:	85 c0                	test   eax,eax
  40a515:	75 79                	jne    40a590 <cos_upcall_fn+0x240>
		main_type = INIT_MAIN_PARALLEL;
  40a517:	41 bc 02 00 00 00    	mov    r12d,0x2
		if (init_core) {
  40a51d:	45 85 ed             	test   r13d,r13d
  40a520:	0f 85 a4 00 00 00    	jne    40a5ca <cos_upcall_fn+0x27a>
  40a526:	bb 30 47 40 00       	mov    ebx,0x404730
		COS_EXTERN_INV(init_parallel_await_init)();
  40a52b:	e8 80 b5 ff ff       	call   405ab0 <__cosrt_extern_init_parallel_await_init>
		if (parallel_init) {
  40a530:	48 81 fb e0 9f 40 00 	cmp    rbx,0x409fe0
  40a537:	74 11                	je     40a54a <cos_upcall_fn+0x1fa>
			cos_parallel_init(cid, init_core, init_parallelism());
  40a539:	e8 e2 f7 ff ff       	call   409d20 <init_parallelism>
  40a53e:	44 89 ee             	mov    esi,r13d
  40a541:	31 ff                	xor    edi,edi
  40a543:	89 c2                	mov    edx,eax
  40a545:	e8 e6 a1 ff ff       	call   404730 <cos_parallel_init>
		COS_EXTERN_INV(init_done)(0, main_type);
  40a54a:	44 89 e6             	mov    esi,r12d
  40a54d:	31 ff                	xor    edi,edi
  40a54f:	e8 7c b5 ff ff       	call   405ad0 <__cosrt_extern_init_done>
		initialization_completed = 1;
  40a554:	c7 05 ee 63 19 00 01 	mov    DWORD PTR [rip+0x1963ee],0x1        # 5a094c <initialization_completed.4>
  40a55b:	00 00 00 
	assert(main_type != INIT_MAIN_NONE);
  40a55e:	45 85 e4             	test   r12d,r12d
  40a561:	0f 84 89 00 00 00    	je     40a5f0 <cos_upcall_fn+0x2a0>
	assert(main_type == INIT_MAIN_PARALLEL || (main_type == INIT_MAIN_SINGLE && init_core));
  40a567:	41 83 fc 02          	cmp    r12d,0x2
  40a56b:	74 23                	je     40a590 <cos_upcall_fn+0x240>
  40a56d:	45 85 ed             	test   r13d,r13d
  40a570:	0f 84 ff 00 00 00    	je     40a675 <cos_upcall_fn+0x325>
	assert(cos_main_defined());
  40a576:	b8 c0 9f 40 00       	mov    eax,0x409fc0
  40a57b:	48 3d c0 9f 40 00    	cmp    rax,0x409fc0
  40a581:	0f 84 d7 00 00 00    	je     40a65e <cos_upcall_fn+0x30e>
	return main();
  40a587:	e8 34 fa ff ff       	call   409fc0 <main>
  40a58c:	89 c7                	mov    edi,eax
  40a58e:	eb 13                	jmp    40a5a3 <cos_upcall_fn+0x253>
		parallel_main(cid, init_core, init_parallelism());
  40a590:	e8 8b f7 ff ff       	call   409d20 <init_parallelism>
  40a595:	31 ff                	xor    edi,edi
  40a597:	44 89 ee             	mov    esi,r13d
  40a59a:	89 c2                	mov    edx,eax
  40a59c:	e8 5f a1 ff ff       	call   404700 <parallel_main>
	int ret = 0;
  40a5a1:	31 ff                	xor    edi,edi
	COS_EXTERN_INV(init_exit)(ret);
  40a5a3:	e8 c8 b6 ff ff       	call   405c70 <__cosrt_extern_init_exit>
	} else if (cos_main_defined()) {
  40a5a8:	b8 c0 9f 40 00       	mov    eax,0x409fc0
  40a5ad:	48 3d c0 9f 40 00    	cmp    rax,0x409fc0
  40a5b3:	74 52                	je     40a607 <cos_upcall_fn+0x2b7>
	if (initialization_completed == 0) {
  40a5b5:	8b 05 91 63 19 00    	mov    eax,DWORD PTR [rip+0x196391]        # 5a094c <initialization_completed.4>
  40a5bb:	85 c0                	test   eax,eax
  40a5bd:	75 ae                	jne    40a56d <cos_upcall_fn+0x21d>
		main_type = INIT_MAIN_SINGLE;
  40a5bf:	41 bc 01 00 00 00    	mov    r12d,0x1
  40a5c5:	e9 53 ff ff ff       	jmp    40a51d <cos_upcall_fn+0x1cd>
			cos_init();
  40a5ca:	31 c0                	xor    eax,eax
	const int parallel_init = cos_parallel_init != __crt_cos_parallel_init;
  40a5cc:	bb 30 47 40 00       	mov    ebx,0x404730
			cos_init();
  40a5d1:	e8 7a a2 ff ff       	call   404850 <cos_init>
	const int parallel_init = cos_parallel_init != __crt_cos_parallel_init;
  40a5d6:	31 ff                	xor    edi,edi
  40a5d8:	48 81 fb e0 9f 40 00 	cmp    rbx,0x409fe0
			COS_EXTERN_INV(init_done)(parallel_init, main_type);
  40a5df:	44 89 e6             	mov    esi,r12d
	const int parallel_init = cos_parallel_init != __crt_cos_parallel_init;
  40a5e2:	40 0f 95 c7          	setne  dil
			COS_EXTERN_INV(init_done)(parallel_init, main_type);
  40a5e6:	e8 e5 b4 ff ff       	call   405ad0 <__cosrt_extern_init_done>
			assert(parallel_init || main_type != INIT_MAIN_NONE);
  40a5eb:	e9 3b ff ff ff       	jmp    40a52b <cos_upcall_fn+0x1db>
	assert(main_type != INIT_MAIN_NONE);
  40a5f0:	bf e8 d1 41 00       	mov    edi,0x41d1e8
  40a5f5:	e8 46 fc ff ff       	call   40a240 <prints.isra.0>
  40a5fa:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40a601:	00 00 00 00 
  40a605:	0f 0b                	ud2    
	if (initialization_completed == 0) {
  40a607:	8b 05 3f 63 19 00    	mov    eax,DWORD PTR [rip+0x19633f]        # 5a094c <initialization_completed.4>
  40a60d:	85 c0                	test   eax,eax
  40a60f:	75 df                	jne    40a5f0 <cos_upcall_fn+0x2a0>
		if (init_core) {
  40a611:	45 85 ed             	test   r13d,r13d
  40a614:	0f 84 0c ff ff ff    	je     40a526 <cos_upcall_fn+0x1d6>
			cos_init();
  40a61a:	31 c0                	xor    eax,eax
	const int parallel_init = cos_parallel_init != __crt_cos_parallel_init;
  40a61c:	bb 30 47 40 00       	mov    ebx,0x404730
			cos_init();
  40a621:	e8 2a a2 ff ff       	call   404850 <cos_init>
	const int parallel_init = cos_parallel_init != __crt_cos_parallel_init;
  40a626:	31 ff                	xor    edi,edi
  40a628:	48 81 fb e0 9f 40 00 	cmp    rbx,0x409fe0
  40a62f:	40 0f 95 c7          	setne  dil
			COS_EXTERN_INV(init_done)(parallel_init, main_type);
  40a633:	31 f6                	xor    esi,esi
  40a635:	e8 96 b4 ff ff       	call   405ad0 <__cosrt_extern_init_done>
			assert(parallel_init || main_type != INIT_MAIN_NONE);
  40a63a:	48 81 fb e0 9f 40 00 	cmp    rbx,0x409fe0
  40a641:	0f 85 e4 fe ff ff    	jne    40a52b <cos_upcall_fn+0x1db>
  40a647:	bf b8 d1 41 00       	mov    edi,0x41d1b8
  40a64c:	e8 ef fb ff ff       	call   40a240 <prints.isra.0>
  40a651:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40a658:	00 00 00 00 
  40a65c:	0f 0b                	ud2    
	assert(cos_main_defined());
  40a65e:	bf 88 d1 41 00       	mov    edi,0x41d188
  40a663:	e8 d8 fb ff ff       	call   40a240 <prints.isra.0>
  40a668:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40a66f:	00 00 00 00 
  40a673:	0f 0b                	ud2    
	assert(main_type == INIT_MAIN_PARALLEL || (main_type == INIT_MAIN_SINGLE && init_core));
  40a675:	bf 18 d2 41 00       	mov    edi,0x41d218
  40a67a:	e8 c1 fb ff ff       	call   40a240 <prints.isra.0>
  40a67f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40a686:	00 00 00 00 
  40a68a:	0f 0b                	ud2    
  40a68c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000040a690 <cos_get_vas_page>:
	return;
}

CWEAKSYMB void *
cos_get_vas_page(void)
{
  40a690:	f3 0f 1e fa          	endbr64 
  40a694:	55                   	push   rbp
  40a695:	48 89 e5             	mov    rbp,rsp
  40a698:	53                   	push   rbx
  40a699:	bb 58 70 42 00       	mov    ebx,0x427058
  40a69e:	66 90                	xchg   ax,ax
	return (void *)__cosrt_comp_info.cos_heap_ptr;
  40a6a0:	48 8b 05 b1 c9 01 00 	mov    rax,QWORD PTR [rip+0x1c9b1]        # 427058 <__cosrt_comp_info+0x58>
	char *h;
	long  r;
	do {
		h = cos_get_heap_ptr();
		r = (long)h + PAGE_SIZE;
  40a6a7:	48 8d 88 00 10 00 00 	lea    rcx,[rax+0x1000]
	__asm__ __volatile__("call cos_atomic_cmpxchg"
  40a6ae:	e8 7d 02 00 00       	call   40a930 <cos_atomic_cmpxchg>
	} while (cos_cmpxchg(&__cosrt_comp_info.cos_heap_ptr, (long)h, r) != r);
  40a6b3:	48 39 ca             	cmp    rdx,rcx
  40a6b6:	75 e8                	jne    40a6a0 <cos_get_vas_page+0x10>
	return h;
}
  40a6b8:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
  40a6bc:	c9                   	leave  
  40a6bd:	c3                   	ret    
  40a6be:	66 90                	xchg   ax,ax

000000000040a6c0 <cos_release_vas_page>:

CWEAKSYMB void
cos_release_vas_page(void *p)
{
  40a6c0:	f3 0f 1e fa          	endbr64 
  40a6c4:	55                   	push   rbp
  40a6c5:	48 89 f9             	mov    rcx,rdi
	cos_set_heap_ptr_conditional(p + PAGE_SIZE, p);
  40a6c8:	48 8d 87 00 10 00 00 	lea    rax,[rdi+0x1000]
{
  40a6cf:	48 89 e5             	mov    rbp,rsp
  40a6d2:	53                   	push   rbx
  40a6d3:	bb 58 70 42 00       	mov    ebx,0x427058
  40a6d8:	e8 53 02 00 00       	call   40a930 <cos_atomic_cmpxchg>
}
  40a6dd:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
  40a6e1:	c9                   	leave  
  40a6e2:	c3                   	ret    
  40a6e3:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a6ea:	00 00 00 00 
  40a6ee:	66 90                	xchg   ax,ax

000000000040a6f0 <cos_initargs_tar>:
CWEAKSYMB long _binary_tar_binary_start = 0;
CWEAKSYMB long _binary_tar_binary_end = 0;

char *
cos_initargs_tar(void)
{
  40a6f0:	f3 0f 1e fa          	endbr64 
	/* Tar files are at least one record, which is 512 bytes */
	if (_binary_tar_binary_end - _binary_tar_binary_start < 512) return NULL;
  40a6f4:	48 8b 05 0d 52 19 00 	mov    rax,QWORD PTR [rip+0x19520d]        # 59f908 <_binary_tar_binary_start>
  40a6fb:	48 8b 15 fe 51 19 00 	mov    rdx,QWORD PTR [rip+0x1951fe]        # 59f900 <_binary_tar_binary_end>
  40a702:	48 29 c2             	sub    rdx,rax
  40a705:	48 81 fa ff 01 00 00 	cmp    rdx,0x1ff
  40a70c:	ba 00 00 00 00       	mov    edx,0x0
  40a711:	48 0f 4e c2          	cmovle rax,rdx
	return (char *)_binary_tar_binary_start;
}
  40a715:	c3                   	ret    
  40a716:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40a71d:	00 00 00 

000000000040a720 <__cosrt_c_cosrtdefault>:
#include <cos_kernel_api.h>
#include <cos_types.h>
#include <c_stub.h>

COS_CLIENT_STUB(int, cosrtdefault, word_t p0, word_t p1, word_t p2, word_t p3)
{
  40a720:	f3 0f 1e fa          	endbr64 
  40a724:	55                   	push   rbp
  40a725:	48 89 e5             	mov    rbp,rsp
  40a728:	41 56                	push   r14
  40a72a:	49 89 ce             	mov    r14,rcx
  40a72d:	41 55                	push   r13
  40a72f:	41 54                	push   r12
  40a731:	53                   	push   rbx
  40a732:	48 83 ec 20          	sub    rsp,0x20
  40a736:	4c 8b 40 08          	mov    r8,QWORD PTR [rax+0x8]
  40a73a:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, &r1, &r2);
  40a73e:	48 85 c0             	test   rax,rax
  40a741:	74 1d                	je     40a760 <__cosrt_c_cosrtdefault+0x40>
  40a743:	4c 8d 4d d0          	lea    r9,[rbp-0x30]
  40a747:	4c 8d 45 c8          	lea    r8,[rbp-0x38]
  40a74b:	ff d0                	call   rax
	COS_CLIENT_INVCAP;
	return cos_sinv(uc, p0, p1, p2, p3);
}
  40a74d:	48 83 c4 20          	add    rsp,0x20
  40a751:	5b                   	pop    rbx
  40a752:	41 5c                	pop    r12
  40a754:	41 5d                	pop    r13
  40a756:	41 5e                	pop    r14
  40a758:	5d                   	pop    rbp
  40a759:	c3                   	ret    
  40a75a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40a760:	41 8d 40 01          	lea    eax,[r8+0x1]
	__asm__ __volatile__(
  40a764:	48 89 fb             	mov    rbx,rdi
  40a767:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  40a76b:	48 89 d7             	mov    rdi,rdx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40a76e:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40a771:	4c 89 f2             	mov    rdx,r14
  40a774:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40a777:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40a77b:	48 89 cd             	mov    rbp,rcx
  40a77e:	49 b8 98 a7 40 00 00 	movabs r8,0x40a798
  40a785:	00 00 00 
  40a788:	0f 05                	syscall 
  40a78a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40a790:	eb 0d                	jmp    40a79f <__cosrt_c_cosrtdefault+0x7f>
  40a792:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40a798:	b9 00 00 00 00       	mov    ecx,0x0
  40a79d:	eb 05                	jmp    40a7a4 <__cosrt_c_cosrtdefault+0x84>
  40a79f:	b9 01 00 00 00       	mov    ecx,0x1
  40a7a4:	5d                   	pop    rbp
  40a7a5:	5c                   	pop    rsp
  40a7a6:	48 83 c4 20          	add    rsp,0x20
  40a7aa:	5b                   	pop    rbx
  40a7ab:	41 5c                	pop    r12
  40a7ad:	41 5d                	pop    r13
  40a7af:	41 5e                	pop    r14
  40a7b1:	5d                   	pop    rbp
  40a7b2:	c3                   	ret    
  40a7b3:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a7ba:	00 00 00 00 
  40a7be:	66 90                	xchg   ax,ax

000000000040a7c0 <__cosrt_c_cosrtretdefault>:

COS_CLIENT_STUB(int, cosrtretdefault, word_t p0, word_t p1, word_t p2, word_t p3, word_t *r1, word_t *r2)
{
  40a7c0:	f3 0f 1e fa          	endbr64 
  40a7c4:	55                   	push   rbp
  40a7c5:	48 89 e5             	mov    rbp,rsp
  40a7c8:	41 57                	push   r15
  40a7ca:	4d 89 c7             	mov    r15,r8
  40a7cd:	41 56                	push   r14
  40a7cf:	4d 89 ce             	mov    r14,r9
  40a7d2:	41 55                	push   r13
  40a7d4:	49 89 d5             	mov    r13,rdx
  40a7d7:	48 89 ca             	mov    rdx,rcx
  40a7da:	41 54                	push   r12
  40a7dc:	53                   	push   rbx
  40a7dd:	48 89 fb             	mov    rbx,rdi
  40a7e0:	4c 8b 50 10          	mov    r10,QWORD PTR [rax+0x10]
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  40a7e4:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  40a7e8:	4d 85 d2             	test   r10,r10
  40a7eb:	74 13                	je     40a800 <__cosrt_c_cosrtretdefault+0x40>
  40a7ed:	48 89 d1             	mov    rcx,rdx
  40a7f0:	4c 89 ea             	mov    rdx,r13
	COS_CLIENT_INVCAP;

	return cos_sinv_2rets(uc, p0, p1, p2, p3, r1, r2);
}
  40a7f3:	5b                   	pop    rbx
  40a7f4:	41 5c                	pop    r12
  40a7f6:	41 5d                	pop    r13
  40a7f8:	41 5e                	pop    r14
  40a7fa:	41 5f                	pop    r15
  40a7fc:	5d                   	pop    rbp
  40a7fd:	41 ff e2             	jmp    r10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40a800:	8d 41 01             	lea    eax,[rcx+0x1]
	__asm__ __volatile__(
  40a803:	4c 89 ef             	mov    rdi,r13
  40a806:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40a80a:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40a80d:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40a810:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40a814:	48 89 cd             	mov    rbp,rcx
  40a817:	49 b8 30 a8 40 00 00 	movabs r8,0x40a830
  40a81e:	00 00 00 
  40a821:	0f 05                	syscall 
  40a823:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40a828:	eb 0f                	jmp    40a839 <__cosrt_c_cosrtretdefault+0x79>
  40a82a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40a830:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  40a837:	eb 07                	jmp    40a840 <__cosrt_c_cosrtretdefault+0x80>
  40a839:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  40a840:	5d                   	pop    rbp
  40a841:	5c                   	pop    rsp
  40a842:	49 89 37             	mov    QWORD PTR [r15],rsi
  40a845:	49 89 3e             	mov    QWORD PTR [r14],rdi
  40a848:	5b                   	pop    rbx
  40a849:	41 5c                	pop    r12
  40a84b:	41 5d                	pop    r13
  40a84d:	41 5e                	pop    r14
  40a84f:	41 5f                	pop    r15
  40a851:	5d                   	pop    rbp
  40a852:	c3                   	ret    
  40a853:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40a85a:	00 00 00 
  40a85d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040a860 <cos_ainv_entry>:
  40a860:	53                   	push   rbx
  40a861:	56                   	push   rsi
  40a862:	57                   	push   rdi
  40a863:	52                   	push   rdx
  40a864:	55                   	push   rbp
  40a865:	89 e3                	mov    ebx,esp
  40a867:	83 c3 18             	add    ebx,0x18
  40a86a:	53                   	push   rbx
  40a86b:	50                   	push   rax
  40a86c:	e8 4f f8 ff ff       	call   40a0c0 <cos_async_inv>
  40a871:	83 c4 08             	add    esp,0x8
  40a874:	83 f8 00             	cmp    eax,0x0
  40a877:	74 22                	je     40a89b <ainv_ret>
  40a879:	67 8b 5c 24 18       	mov    ebx,DWORD PTR [esp+0x18]
  40a87e:	67 8b 74 24 1c       	mov    esi,DWORD PTR [esp+0x1c]
  40a883:	67 8b 7c 24 20       	mov    edi,DWORD PTR [esp+0x20]
  40a888:	67 8b 54 24 24       	mov    edx,DWORD PTR [esp+0x24]
  40a88d:	89 e5                	mov    ebp,esp
  40a88f:	48 b9 9b a8 40 00 00 	movabs rcx,0x40a89b
  40a896:	00 00 00 
  40a899:	0f 34                	sysenter 

000000000040a89b <ainv_ret>:
  40a89b:	5d                   	pop    rbp
  40a89c:	5a                   	pop    rdx
  40a89d:	5f                   	pop    rdi
  40a89e:	5e                   	pop    rsi
  40a89f:	5b                   	pop    rbx
  40a8a0:	c3                   	ret    
  40a8a1:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40a8a8:	00 00 00 
  40a8ab:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000040a8b0 <custom_acquire_stack>:
  40a8b0:	48 89 c2             	mov    rdx,rax
  40a8b3:	48 bc 00 a0 42 00 00 	movabs rsp,0x42a000
  40a8ba:	00 00 00 
  40a8bd:	48 25 ff ff 00 00    	and    rax,0xffff
  40a8c3:	48 c1 e0 0d          	shl    rax,0xd
  40a8c7:	48 01 c4             	add    rsp,rax
  40a8ca:	48 c1 e8 0d          	shr    rax,0xd
  40a8ce:	48 c1 ea 10          	shr    rdx,0x10
  40a8d2:	ff e1                	jmp    rcx
  40a8d4:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a8db:	00 00 00 00 
  40a8df:	90                   	nop

000000000040a8e0 <__cosrt_upcall_entry>:
  40a8e0:	48 b9 ef a8 40 00 00 	movabs rcx,0x40a8ef
  40a8e7:	00 00 00 
  40a8ea:	e9 c1 ff ff ff       	jmp    40a8b0 <custom_acquire_stack>
  40a8ef:	52                   	push   rdx
  40a8f0:	50                   	push   rax
  40a8f1:	6a 00                	push   0x0
  40a8f3:	6a 00                	push   0x0
  40a8f5:	48 89 64 24 f0       	mov    QWORD PTR [rsp-0x10],rsp
  40a8fa:	6a 00                	push   0x0
  40a8fc:	48 89 64 24 f0       	mov    QWORD PTR [rsp-0x10],rsp
  40a901:	48 83 ec 10          	sub    rsp,0x10
  40a905:	48 89 f1             	mov    rcx,rsi
  40a908:	48 89 fa             	mov    rdx,rdi
  40a90b:	48 89 de             	mov    rsi,rbx
  40a90e:	48 31 ed             	xor    rbp,rbp
  40a911:	4c 89 e7             	mov    rdi,r12
  40a914:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  40a918:	e8 33 fa ff ff       	call   40a350 <cos_upcall_fn>
  40a91d:	83 c4 18             	add    esp,0x18
  40a920:	5e                   	pop    rsi
  40a921:	5f                   	pop    rdi
  40a922:	89 c1                	mov    ecx,eax
  40a924:	b8 00 00 01 00       	mov    eax,0x10000
  40a929:	0f 34                	sysenter 
  40a92b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000040a930 <cos_atomic_cmpxchg>:
  40a930:	c3                   	ret    

000000000040a931 <cos_atomic_user1>:
  40a931:	b8 00 00 00 00       	mov    eax,0x0
  40a936:	67 8b 00             	mov    eax,DWORD PTR [eax]
  40a939:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000040a940 <args_iter.part.0.isra.0>:

/* Length of the K/V map (= 1 for a K/V with a string value) */
static int
kv_len(struct kv_entry *kv)
{
	if (!kv) return 0;
  40a940:	48 85 ff             	test   rdi,rdi
  40a943:	74 73                	je     40a9b8 <args_iter.part.0.isra.0+0x78>
	switch (kv->vtype) {
  40a945:	8b 47 08             	mov    eax,DWORD PTR [rdi+0x8]
  40a948:	85 c0                	test   eax,eax
  40a94a:	74 54                	je     40a9a0 <args_iter.part.0.isra.0+0x60>
  40a94c:	83 f8 01             	cmp    eax,0x1
  40a94f:	74 0f                	je     40a960 <args_iter.part.0.isra.0+0x20>
 * this returns the first item in the K/V store
 */
static int
kv_iter(struct kv_entry *kv, struct kv_iter *i, struct kv_entry **ent)
{
	*i = (struct kv_iter){
  40a951:	48 89 7e 08          	mov    QWORD PTR [rsi+0x8],rdi
	if (i->start->vtype != VTYPE_ARR) return 0;
  40a955:	31 c0                	xor    eax,eax
	*i = (struct kv_iter){
  40a957:	48 c7 46 10 00 00 00 	mov    QWORD PTR [rsi+0x10],0x0
  40a95e:	00 
	if (i->start->vtype != VTYPE_ARR) return 0;
  40a95f:	c3                   	ret    
	case VTYPE_ARR: return kv->val.arr.sz;
  40a960:	8b 47 10             	mov    eax,DWORD PTR [rdi+0x10]
	*i = (struct kv_iter){
  40a963:	48 89 7e 08          	mov    QWORD PTR [rsi+0x8],rdi
  40a967:	c7 46 10 00 00 00 00 	mov    DWORD PTR [rsi+0x10],0x0
  40a96e:	89 46 14             	mov    DWORD PTR [rsi+0x14],eax
	if (i->curr == i->len) return 0;
  40a971:	85 c0                	test   eax,eax
  40a973:	75 0b                	jne    40a980 <args_iter.part.0.isra.0+0x40>
	switch (arg->type) {
	case ARGS_IMPL_KV:  return kv_iter(arg->d.kv_ent, &i->i.kv_i, &ent->d.kv_ent);
	case ARGS_IMPL_TAR: return tar_iter(&arg->d.tar_ent, &i->i.tar_i, &ent->d.tar_ent);
	default:            return 0;
	}
}
  40a975:	c3                   	ret    
  40a976:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40a97d:	00 00 00 
	*ent = __kv_index(i->start, i->curr++);
  40a980:	c7 46 10 01 00 00 00 	mov    DWORD PTR [rsi+0x10],0x1
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  40a987:	7e 47                	jle    40a9d0 <args_iter.part.0.isra.0+0x90>
	return kv->val.arr.kvs[idx];
  40a989:	48 8b 47 18          	mov    rax,QWORD PTR [rdi+0x18]
  40a98d:	48 8b 00             	mov    rax,QWORD PTR [rax]
	*ent = __kv_index(i->start, i->curr++);
  40a990:	48 89 42 08          	mov    QWORD PTR [rdx+0x8],rax
	return 1;
  40a994:	b8 01 00 00 00       	mov    eax,0x1
  40a999:	c3                   	ret    
  40a99a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	*i = (struct kv_iter){
  40a9a0:	48 8b 05 71 29 01 00 	mov    rax,QWORD PTR [rip+0x12971]        # 41d318 <__unlock+0x11e8>
  40a9a7:	48 89 7e 08          	mov    QWORD PTR [rsi+0x8],rdi
  40a9ab:	48 89 46 10          	mov    QWORD PTR [rsi+0x10],rax
	if (i->start->vtype != VTYPE_ARR) return 0;
  40a9af:	31 c0                	xor    eax,eax
  40a9b1:	c3                   	ret    
  40a9b2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	*i = (struct kv_iter){
  40a9b8:	48 c7 46 08 00 00 00 	mov    QWORD PTR [rsi+0x8],0x0
  40a9bf:	00 
	if (i->start->vtype != VTYPE_ARR) return 0;
  40a9c0:	31 c0                	xor    eax,eax
	*i = (struct kv_iter){
  40a9c2:	48 c7 46 10 00 00 00 	mov    QWORD PTR [rsi+0x10],0x0
  40a9c9:	00 
	if (i->start->vtype != VTYPE_ARR) return 0;
  40a9ca:	c3                   	ret    
  40a9cb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  40a9d0:	31 c0                	xor    eax,eax
  40a9d2:	eb bc                	jmp    40a990 <args_iter.part.0.isra.0+0x50>
  40a9d4:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a9db:	00 00 00 00 
  40a9df:	90                   	nop

000000000040a9e0 <args_key>:
{
  40a9e0:	f3 0f 1e fa          	endbr64 
  40a9e4:	55                   	push   rbp
  40a9e5:	48 89 e5             	mov    rbp,rsp
  40a9e8:	41 55                	push   r13
  40a9ea:	49 89 f5             	mov    r13,rsi
  40a9ed:	41 54                	push   r12
	switch (arg->type) {
  40a9ef:	8b 07                	mov    eax,DWORD PTR [rdi]
  40a9f1:	85 c0                	test   eax,eax
  40a9f3:	74 1b                	je     40aa10 <args_key+0x30>
  40a9f5:	45 31 e4             	xor    r12d,r12d
  40a9f8:	83 f8 01             	cmp    eax,0x1
  40a9fb:	75 2c                	jne    40aa29 <args_key+0x49>
}
  40a9fd:	41 5c                	pop    r12
	case ARGS_IMPL_TAR: return tar_key(&arg->d.tar_ent, arg_len);
  40a9ff:	48 83 c7 08          	add    rdi,0x8
}
  40aa03:	41 5d                	pop    r13
  40aa05:	5d                   	pop    rbp
	case ARGS_IMPL_TAR: return tar_key(&arg->d.tar_ent, arg_len);
  40aa06:	e9 a5 07 00 00       	jmp    40b1b0 <tar_key>
  40aa0b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40aa10:	4c 8b 67 08          	mov    r12,QWORD PTR [rdi+0x8]
	if (!kv) return NULL;
  40aa14:	4d 85 e4             	test   r12,r12
  40aa17:	74 10                	je     40aa29 <args_key+0x49>
	*key_len = strlen(kv->key);
  40aa19:	4d 8b 24 24          	mov    r12,QWORD PTR [r12]
  40aa1d:	4c 89 e7             	mov    rdi,r12
  40aa20:	e8 ab af 00 00       	call   4159d0 <strlen>
  40aa25:	41 89 45 00          	mov    DWORD PTR [r13+0x0],eax
}
  40aa29:	4c 89 e0             	mov    rax,r12
  40aa2c:	41 5c                	pop    r12
  40aa2e:	41 5d                	pop    r13
  40aa30:	5d                   	pop    rbp
  40aa31:	c3                   	ret    
  40aa32:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40aa39:	00 00 00 00 
  40aa3d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040aa40 <args_value>:
{
  40aa40:	f3 0f 1e fa          	endbr64 
	switch (arg->type) {
  40aa44:	8b 07                	mov    eax,DWORD PTR [rdi]
  40aa46:	85 c0                	test   eax,eax
  40aa48:	74 1e                	je     40aa68 <args_value+0x28>
  40aa4a:	83 f8 01             	cmp    eax,0x1
  40aa4d:	75 11                	jne    40aa60 <args_value+0x20>
	case ARGS_IMPL_TAR: return tar_value(&arg->d.tar_ent);
  40aa4f:	48 83 c7 08          	add    rdi,0x8
  40aa53:	e9 08 08 00 00       	jmp    40b260 <tar_value>
  40aa58:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40aa5f:	00 
	if (!kv) return NULL;
  40aa60:	31 c0                	xor    eax,eax
}
  40aa62:	c3                   	ret    
  40aa63:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40aa68:	48 8b 47 08          	mov    rax,QWORD PTR [rdi+0x8]
	if (!kv) return NULL;
  40aa6c:	48 85 c0             	test   rax,rax
  40aa6f:	74 f1                	je     40aa62 <args_value+0x22>
	switch (kv->vtype) {
  40aa71:	8b 50 08             	mov    edx,DWORD PTR [rax+0x8]
  40aa74:	85 d2                	test   edx,edx
  40aa76:	75 e8                	jne    40aa60 <args_value+0x20>
	case VTYPE_STR: return kv->val.str;
  40aa78:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
  40aa7c:	c3                   	ret    
  40aa7d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040aa80 <args_len>:
{
  40aa80:	f3 0f 1e fa          	endbr64 
	switch (arg->type) {
  40aa84:	8b 07                	mov    eax,DWORD PTR [rdi]
  40aa86:	85 c0                	test   eax,eax
  40aa88:	74 1e                	je     40aaa8 <args_len+0x28>
  40aa8a:	83 f8 01             	cmp    eax,0x1
  40aa8d:	75 11                	jne    40aaa0 <args_len+0x20>
	case ARGS_IMPL_TAR: return tar_len(&arg->d.tar_ent);
  40aa8f:	48 83 c7 08          	add    rdi,0x8
  40aa93:	e9 b8 0c 00 00       	jmp    40b750 <tar_len>
  40aa98:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40aa9f:	00 
	if (!kv) return 0;
  40aaa0:	31 c0                	xor    eax,eax
}
  40aaa2:	c3                   	ret    
  40aaa3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	case ARGS_IMPL_KV:  return kv_len(arg->d.kv_ent);
  40aaa8:	48 8b 57 08          	mov    rdx,QWORD PTR [rdi+0x8]
	if (!kv) return 0;
  40aaac:	48 85 d2             	test   rdx,rdx
  40aaaf:	74 ef                	je     40aaa0 <args_len+0x20>
	switch (kv->vtype) {
  40aab1:	8b 4a 08             	mov    ecx,DWORD PTR [rdx+0x8]
  40aab4:	b8 01 00 00 00       	mov    eax,0x1
  40aab9:	85 c9                	test   ecx,ecx
  40aabb:	74 e5                	je     40aaa2 <args_len+0x22>
	default:        return 0;
  40aabd:	31 c0                	xor    eax,eax
	switch (kv->vtype) {
  40aabf:	83 f9 01             	cmp    ecx,0x1
  40aac2:	75 de                	jne    40aaa2 <args_len+0x22>
	case VTYPE_ARR: return kv->val.arr.sz;
  40aac4:	8b 42 10             	mov    eax,DWORD PTR [rdx+0x10]
  40aac7:	c3                   	ret    
  40aac8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40aacf:	00 

000000000040aad0 <args_iter_next>:
{
  40aad0:	f3 0f 1e fa          	endbr64 
	arg->type = i->type;
  40aad4:	8b 07                	mov    eax,DWORD PTR [rdi]
  40aad6:	89 06                	mov    DWORD PTR [rsi],eax
	switch (i->type) {
  40aad8:	85 c0                	test   eax,eax
  40aada:	74 1c                	je     40aaf8 <args_iter_next+0x28>
  40aadc:	83 f8 01             	cmp    eax,0x1
  40aadf:	75 0f                	jne    40aaf0 <args_iter_next+0x20>
	case ARGS_IMPL_TAR: return tar_iter_next(&i->i.tar_i, &arg->d.tar_ent);
  40aae1:	48 83 c6 08          	add    rsi,0x8
  40aae5:	48 83 c7 08          	add    rdi,0x8
  40aae9:	e9 f2 08 00 00       	jmp    40b3e0 <tar_iter_next>
  40aaee:	66 90                	xchg   ax,ax
	switch (i->type) {
  40aaf0:	31 c0                	xor    eax,eax
  40aaf2:	c3                   	ret    
  40aaf3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	if (i->start->vtype != VTYPE_ARR) return 0;
  40aaf8:	48 8b 4f 08          	mov    rcx,QWORD PTR [rdi+0x8]
  40aafc:	31 c0                	xor    eax,eax
  40aafe:	83 79 08 01          	cmp    DWORD PTR [rcx+0x8],0x1
  40ab02:	75 2c                	jne    40ab30 <args_iter_next+0x60>
	if (i->curr == i->len) return 0;
  40ab04:	48 63 57 10          	movsxd rdx,DWORD PTR [rdi+0x10]
  40ab08:	3b 57 14             	cmp    edx,DWORD PTR [rdi+0x14]
  40ab0b:	74 23                	je     40ab30 <args_iter_next+0x60>
	*ent = __kv_index(i->start, i->curr++);
  40ab0d:	8d 42 01             	lea    eax,[rdx+0x1]
  40ab10:	89 47 10             	mov    DWORD PTR [rdi+0x10],eax
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  40ab13:	3b 51 10             	cmp    edx,DWORD PTR [rcx+0x10]
  40ab16:	7d 20                	jge    40ab38 <args_iter_next+0x68>
  40ab18:	85 d2                	test   edx,edx
  40ab1a:	78 1c                	js     40ab38 <args_iter_next+0x68>
	return kv->val.arr.kvs[idx];
  40ab1c:	48 8b 41 18          	mov    rax,QWORD PTR [rcx+0x18]
  40ab20:	48 8b 04 d0          	mov    rax,QWORD PTR [rax+rdx*8]
	*ent = __kv_index(i->start, i->curr++);
  40ab24:	48 89 46 08          	mov    QWORD PTR [rsi+0x8],rax
	return 1;
  40ab28:	b8 01 00 00 00       	mov    eax,0x1
  40ab2d:	c3                   	ret    
  40ab2e:	66 90                	xchg   ax,ax
}
  40ab30:	c3                   	ret    
  40ab31:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  40ab38:	31 c0                	xor    eax,eax
  40ab3a:	eb e8                	jmp    40ab24 <args_iter_next+0x54>
  40ab3c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000040ab40 <args_iter>:
{
  40ab40:	f3 0f 1e fa          	endbr64 
	i->type = ent->type = arg->type;
  40ab44:	8b 07                	mov    eax,DWORD PTR [rdi]
  40ab46:	89 02                	mov    DWORD PTR [rdx],eax
  40ab48:	89 06                	mov    DWORD PTR [rsi],eax
	switch (arg->type) {
  40ab4a:	85 c0                	test   eax,eax
  40ab4c:	74 32                	je     40ab80 <args_iter+0x40>
  40ab4e:	83 f8 01             	cmp    eax,0x1
  40ab51:	75 25                	jne    40ab78 <args_iter+0x38>
	case ARGS_IMPL_TAR: return tar_iter(&arg->d.tar_ent, &i->i.tar_i, &ent->d.tar_ent);
  40ab53:	48 83 c2 08          	add    rdx,0x8
  40ab57:	48 83 c6 08          	add    rsi,0x8
  40ab5b:	48 83 c7 08          	add    rdi,0x8
  40ab5f:	e9 7c 0b 00 00       	jmp    40b6e0 <tar_iter>
  40ab64:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	*i = (struct kv_iter){
  40ab68:	48 c7 46 08 00 00 00 	mov    QWORD PTR [rsi+0x8],0x0
  40ab6f:	00 
  40ab70:	48 c7 46 10 00 00 00 	mov    QWORD PTR [rsi+0x10],0x0
  40ab77:	00 
	if (i->start->vtype != VTYPE_ARR) return 0;
  40ab78:	31 c0                	xor    eax,eax
  40ab7a:	c3                   	ret    
  40ab7b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40ab80:	48 8b 4f 08          	mov    rcx,QWORD PTR [rdi+0x8]
	if (!kv) return 0;
  40ab84:	48 85 c9             	test   rcx,rcx
  40ab87:	74 df                	je     40ab68 <args_iter+0x28>
	switch (kv->vtype) {
  40ab89:	8b 41 08             	mov    eax,DWORD PTR [rcx+0x8]
  40ab8c:	85 c0                	test   eax,eax
  40ab8e:	74 30                	je     40abc0 <args_iter+0x80>
  40ab90:	83 f8 01             	cmp    eax,0x1
  40ab93:	74 13                	je     40aba8 <args_iter+0x68>
	*i = (struct kv_iter){
  40ab95:	48 89 4e 08          	mov    QWORD PTR [rsi+0x8],rcx
	if (i->start->vtype != VTYPE_ARR) return 0;
  40ab99:	31 c0                	xor    eax,eax
	*i = (struct kv_iter){
  40ab9b:	48 c7 46 10 00 00 00 	mov    QWORD PTR [rsi+0x10],0x0
  40aba2:	00 
	if (i->start->vtype != VTYPE_ARR) return 0;
  40aba3:	c3                   	ret    
  40aba4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	case VTYPE_ARR: return kv->val.arr.sz;
  40aba8:	8b 41 10             	mov    eax,DWORD PTR [rcx+0x10]
	*i = (struct kv_iter){
  40abab:	48 89 4e 08          	mov    QWORD PTR [rsi+0x8],rcx
  40abaf:	c7 46 10 00 00 00 00 	mov    DWORD PTR [rsi+0x10],0x0
  40abb6:	89 46 14             	mov    DWORD PTR [rsi+0x14],eax
	if (i->curr == i->len) return 0;
  40abb9:	85 c0                	test   eax,eax
  40abbb:	75 1b                	jne    40abd8 <args_iter+0x98>
}
  40abbd:	c3                   	ret    
  40abbe:	66 90                	xchg   ax,ax
	*i = (struct kv_iter){
  40abc0:	48 8b 05 51 27 01 00 	mov    rax,QWORD PTR [rip+0x12751]        # 41d318 <__unlock+0x11e8>
  40abc7:	48 89 4e 08          	mov    QWORD PTR [rsi+0x8],rcx
  40abcb:	48 89 46 10          	mov    QWORD PTR [rsi+0x10],rax
	if (i->start->vtype != VTYPE_ARR) return 0;
  40abcf:	31 c0                	xor    eax,eax
  40abd1:	c3                   	ret    
  40abd2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	*ent = __kv_index(i->start, i->curr++);
  40abd8:	c7 46 10 01 00 00 00 	mov    DWORD PTR [rsi+0x10],0x1
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  40abdf:	7e 17                	jle    40abf8 <args_iter+0xb8>
	return kv->val.arr.kvs[idx];
  40abe1:	48 8b 41 18          	mov    rax,QWORD PTR [rcx+0x18]
  40abe5:	48 8b 00             	mov    rax,QWORD PTR [rax]
	*ent = __kv_index(i->start, i->curr++);
  40abe8:	48 89 42 08          	mov    QWORD PTR [rdx+0x8],rax
	return 1;
  40abec:	b8 01 00 00 00       	mov    eax,0x1
  40abf1:	c3                   	ret    
  40abf2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  40abf8:	31 c0                	xor    eax,eax
  40abfa:	eb ec                	jmp    40abe8 <args_iter+0xa8>
  40abfc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000040ac00 <args_foreach>:

typedef void (*args_visitor_fn_t)(struct initargs *ent, void *data);

int
args_foreach(struct initargs *ent, args_visitor_fn_t fn, void *data)
{
  40ac00:	f3 0f 1e fa          	endbr64 
	struct initargs_iter i;
	struct initargs curr;
	int cont;

	if (!ent) return -1;
  40ac04:	48 85 ff             	test   rdi,rdi
  40ac07:	0f 84 d7 00 00 00    	je     40ace4 <args_foreach+0xe4>
{
  40ac0d:	55                   	push   rbp
  40ac0e:	48 89 e5             	mov    rbp,rsp
  40ac11:	41 55                	push   r13
  40ac13:	41 54                	push   r12
  40ac15:	49 89 d4             	mov    r12,rdx
  40ac18:	53                   	push   rbx
  40ac19:	48 89 f3             	mov    rbx,rsi
  40ac1c:	48 83 ec 48          	sub    rsp,0x48
	i->type = ent->type = arg->type;
  40ac20:	8b 07                	mov    eax,DWORD PTR [rdi]
  40ac22:	89 45 a0             	mov    DWORD PTR [rbp-0x60],eax
  40ac25:	89 45 c0             	mov    DWORD PTR [rbp-0x40],eax
	switch (arg->type) {
  40ac28:	85 c0                	test   eax,eax
  40ac2a:	0f 84 90 00 00 00    	je     40acc0 <args_foreach+0xc0>
  40ac30:	83 f8 01             	cmp    eax,0x1
  40ac33:	75 43                	jne    40ac78 <args_foreach+0x78>
	case ARGS_IMPL_TAR: return tar_iter(&arg->d.tar_ent, &i->i.tar_i, &ent->d.tar_ent);
  40ac35:	48 83 c7 08          	add    rdi,0x8
  40ac39:	48 8d 55 a8          	lea    rdx,[rbp-0x58]
  40ac3d:	48 8d 75 c8          	lea    rsi,[rbp-0x38]
  40ac41:	e8 9a 0a 00 00       	call   40b6e0 <tar_iter>
	for (cont = args_iter(ent, &i, &curr); cont; cont = args_iter_next(&i, &curr)) {
  40ac46:	85 c0                	test   eax,eax
  40ac48:	74 2e                	je     40ac78 <args_foreach+0x78>
  40ac4a:	4c 8d 6d a0          	lea    r13,[rbp-0x60]
  40ac4e:	66 90                	xchg   ax,ax
		fn(&curr, data);
  40ac50:	4c 89 e6             	mov    rsi,r12
  40ac53:	4c 89 ef             	mov    rdi,r13
  40ac56:	ff d3                	call   rbx
	arg->type = i->type;
  40ac58:	8b 45 c0             	mov    eax,DWORD PTR [rbp-0x40]
  40ac5b:	89 45 a0             	mov    DWORD PTR [rbp-0x60],eax
	switch (i->type) {
  40ac5e:	85 c0                	test   eax,eax
  40ac60:	74 26                	je     40ac88 <args_foreach+0x88>
  40ac62:	83 f8 01             	cmp    eax,0x1
  40ac65:	75 11                	jne    40ac78 <args_foreach+0x78>
	case ARGS_IMPL_TAR: return tar_iter_next(&i->i.tar_i, &arg->d.tar_ent);
  40ac67:	48 8d 75 a8          	lea    rsi,[rbp-0x58]
  40ac6b:	48 8d 7d c8          	lea    rdi,[rbp-0x38]
  40ac6f:	e8 6c 07 00 00       	call   40b3e0 <tar_iter_next>
	for (cont = args_iter(ent, &i, &curr); cont; cont = args_iter_next(&i, &curr)) {
  40ac74:	85 c0                	test   eax,eax
  40ac76:	75 d8                	jne    40ac50 <args_foreach+0x50>
	}

	return 0;
}
  40ac78:	48 83 c4 48          	add    rsp,0x48
	return 0;
  40ac7c:	31 c0                	xor    eax,eax
}
  40ac7e:	5b                   	pop    rbx
  40ac7f:	41 5c                	pop    r12
  40ac81:	41 5d                	pop    r13
  40ac83:	5d                   	pop    rbp
  40ac84:	c3                   	ret    
  40ac85:	0f 1f 00             	nop    DWORD PTR [rax]
	if (i->start->vtype != VTYPE_ARR) return 0;
  40ac88:	48 8b 55 c8          	mov    rdx,QWORD PTR [rbp-0x38]
  40ac8c:	83 7a 08 01          	cmp    DWORD PTR [rdx+0x8],0x1
  40ac90:	75 e6                	jne    40ac78 <args_foreach+0x78>
	if (i->curr == i->len) return 0;
  40ac92:	48 63 45 d0          	movsxd rax,DWORD PTR [rbp-0x30]
  40ac96:	3b 45 d4             	cmp    eax,DWORD PTR [rbp-0x2c]
  40ac99:	74 dd                	je     40ac78 <args_foreach+0x78>
	*ent = __kv_index(i->start, i->curr++);
  40ac9b:	8d 48 01             	lea    ecx,[rax+0x1]
  40ac9e:	89 4d d0             	mov    DWORD PTR [rbp-0x30],ecx
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  40aca1:	3b 42 10             	cmp    eax,DWORD PTR [rdx+0x10]
  40aca4:	7d 3a                	jge    40ace0 <args_foreach+0xe0>
  40aca6:	85 c0                	test   eax,eax
  40aca8:	78 36                	js     40ace0 <args_foreach+0xe0>
	return kv->val.arr.kvs[idx];
  40acaa:	48 8b 52 18          	mov    rdx,QWORD PTR [rdx+0x18]
  40acae:	48 8b 04 c2          	mov    rax,QWORD PTR [rdx+rax*8]
	*ent = __kv_index(i->start, i->curr++);
  40acb2:	48 89 45 a8          	mov    QWORD PTR [rbp-0x58],rax
	for (cont = args_iter(ent, &i, &curr); cont; cont = args_iter_next(&i, &curr)) {
  40acb6:	eb 98                	jmp    40ac50 <args_foreach+0x50>
  40acb8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40acbf:	00 
  40acc0:	4c 8d 6d a0          	lea    r13,[rbp-0x60]
  40acc4:	48 8b 7f 08          	mov    rdi,QWORD PTR [rdi+0x8]
  40acc8:	48 8d 75 c0          	lea    rsi,[rbp-0x40]
  40accc:	4c 89 ea             	mov    rdx,r13
  40accf:	e8 6c fc ff ff       	call   40a940 <args_iter.part.0.isra.0>
  40acd4:	e9 6d ff ff ff       	jmp    40ac46 <args_foreach+0x46>
  40acd9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  40ace0:	31 c0                	xor    eax,eax
  40ace2:	eb ce                	jmp    40acb2 <args_foreach+0xb2>
	if (!ent) return -1;
  40ace4:	b8 ff ff ff ff       	mov    eax,0xffffffff
}
  40ace9:	c3                   	ret    
  40acea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000040acf0 <args_lkup_entry>:
 * not including a '/').  This enables this function to be used to
 * walk through the data-structure guided by a path through the k/v.
 */
int
args_lkup_entry(struct initargs *arg, char *path, struct initargs *ret)
{
  40acf0:	f3 0f 1e fa          	endbr64 
  40acf4:	55                   	push   rbp
  40acf5:	48 89 e5             	mov    rbp,rsp
  40acf8:	41 57                	push   r15
  40acfa:	41 56                	push   r14
  40acfc:	41 55                	push   r13
  40acfe:	41 54                	push   r12
  40ad00:	53                   	push   rbx
  40ad01:	48 81 ec 88 00 00 00 	sub    rsp,0x88
	struct initargs_iter i;
	struct initargs curr, start;
	unsigned int len, cont;
	char *slash, *key = path;

	if (!arg || !key || !ret) return -1;
  40ad08:	48 85 ff             	test   rdi,rdi
{
  40ad0b:	48 89 95 58 ff ff ff 	mov    QWORD PTR [rbp-0xa8],rdx
	if (!arg || !key || !ret) return -1;
  40ad12:	0f 94 c0             	sete   al
  40ad15:	48 85 d2             	test   rdx,rdx
  40ad18:	0f 94 c2             	sete   dl
  40ad1b:	08 d0                	or     al,dl
  40ad1d:	0f 85 4d 01 00 00    	jne    40ae70 <args_lkup_entry+0x180>
  40ad23:	49 89 f4             	mov    r12,rsi
  40ad26:	48 85 f6             	test   rsi,rsi
  40ad29:	0f 84 41 01 00 00    	je     40ae70 <args_lkup_entry+0x180>
	start = *arg;
  40ad2f:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  40ad33:	f3 0f 6f 07          	movdqu xmm0,XMMWORD PTR [rdi]
  40ad37:	48 89 45 a0          	mov    QWORD PTR [rbp-0x60],rax
  40ad3b:	0f 29 45 90          	movaps XMMWORD PTR [rbp-0x70],xmm0
	/* Iterate through the path... */
	do {
		int found = 0;

		slash = strchr(key, '/');
  40ad3f:	be 2f 00 00 00       	mov    esi,0x2f
  40ad44:	4c 89 e7             	mov    rdi,r12
  40ad47:	e8 d4 aa 00 00       	call   415820 <strchr>
  40ad4c:	49 89 c5             	mov    r13,rax
		len = slash ? (unsigned int)(slash - key) : strlen(key);
  40ad4f:	48 85 c0             	test   rax,rax
  40ad52:	0f 84 d8 01 00 00    	je     40af30 <args_lkup_entry+0x240>
  40ad58:	89 c3                	mov    ebx,eax
  40ad5a:	44 29 e3             	sub    ebx,r12d
	i->type = ent->type = arg->type;
  40ad5d:	8b 45 90             	mov    eax,DWORD PTR [rbp-0x70]
  40ad60:	89 85 70 ff ff ff    	mov    DWORD PTR [rbp-0x90],eax
  40ad66:	89 45 b0             	mov    DWORD PTR [rbp-0x50],eax
	switch (arg->type) {
  40ad69:	85 c0                	test   eax,eax
  40ad6b:	0f 84 4f 01 00 00    	je     40aec0 <args_lkup_entry+0x1d0>
  40ad71:	83 f8 01             	cmp    eax,0x1
  40ad74:	0f 85 f6 00 00 00    	jne    40ae70 <args_lkup_entry+0x180>
	case ARGS_IMPL_TAR: return tar_iter(&arg->d.tar_ent, &i->i.tar_i, &ent->d.tar_ent);
  40ad7a:	48 8d 95 78 ff ff ff 	lea    rdx,[rbp-0x88]
  40ad81:	48 8d 75 b8          	lea    rsi,[rbp-0x48]
  40ad85:	48 8d 7d 98          	lea    rdi,[rbp-0x68]
  40ad89:	e8 52 09 00 00       	call   40b6e0 <tar_iter>

		/* ...and look the key up in the KV */
		for (cont = args_iter(&start, &i, &curr) ; cont ; cont = args_iter_next(&i, &curr)) {
  40ad8e:	85 c0                	test   eax,eax
  40ad90:	0f 84 da 00 00 00    	je     40ae70 <args_lkup_entry+0x180>
  40ad96:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40ad9d:	00 00 00 
	switch (arg->type) {
  40ada0:	8b 85 70 ff ff ff    	mov    eax,DWORD PTR [rbp-0x90]
  40ada6:	85 c0                	test   eax,eax
  40ada8:	74 79                	je     40ae23 <args_lkup_entry+0x133>
  40adaa:	83 f8 01             	cmp    eax,0x1
  40adad:	0f 84 dd 00 00 00    	je     40ae90 <args_lkup_entry+0x1a0>
			int key_len;
			char *k = args_key(&curr, &key_len);

			if ((unsigned int)key_len == len && strncmp(k, key, len) == 0) {
  40adb3:	8b 95 6c ff ff ff    	mov    edx,DWORD PTR [rbp-0x94]
	default:            return NULL;
  40adb9:	45 31 f6             	xor    r14d,r14d
			if ((unsigned int)key_len == len && strncmp(k, key, len) == 0) {
  40adbc:	39 da                	cmp    edx,ebx
  40adbe:	75 19                	jne    40add9 <args_lkup_entry+0xe9>
  40adc0:	41 89 d7             	mov    r15d,edx
  40adc3:	4c 89 e6             	mov    rsi,r12
  40adc6:	4c 89 f7             	mov    rdi,r14
  40adc9:	4c 89 fa             	mov    rdx,r15
  40adcc:	e8 7f ac 00 00       	call   415a50 <strncmp>
  40add1:	85 c0                	test   eax,eax
  40add3:	0f 84 07 01 00 00    	je     40aee0 <args_lkup_entry+0x1f0>
	arg->type = i->type;
  40add9:	8b 45 b0             	mov    eax,DWORD PTR [rbp-0x50]
  40addc:	89 85 70 ff ff ff    	mov    DWORD PTR [rbp-0x90],eax
	switch (i->type) {
  40ade2:	85 c0                	test   eax,eax
  40ade4:	75 6a                	jne    40ae50 <args_lkup_entry+0x160>
	if (i->start->vtype != VTYPE_ARR) return 0;
  40ade6:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
  40adea:	83 7a 08 01          	cmp    DWORD PTR [rdx+0x8],0x1
  40adee:	0f 85 7c 00 00 00    	jne    40ae70 <args_lkup_entry+0x180>
	if (i->curr == i->len) return 0;
  40adf4:	48 63 45 c0          	movsxd rax,DWORD PTR [rbp-0x40]
  40adf8:	3b 45 c4             	cmp    eax,DWORD PTR [rbp-0x3c]
  40adfb:	74 73                	je     40ae70 <args_lkup_entry+0x180>
	*ent = __kv_index(i->start, i->curr++);
  40adfd:	8d 48 01             	lea    ecx,[rax+0x1]
  40ae00:	89 4d c0             	mov    DWORD PTR [rbp-0x40],ecx
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  40ae03:	3b 42 10             	cmp    eax,DWORD PTR [rdx+0x10]
  40ae06:	0f 8d ac 00 00 00    	jge    40aeb8 <args_lkup_entry+0x1c8>
  40ae0c:	85 c0                	test   eax,eax
  40ae0e:	0f 88 a4 00 00 00    	js     40aeb8 <args_lkup_entry+0x1c8>
	return kv->val.arr.kvs[idx];
  40ae14:	48 8b 52 18          	mov    rdx,QWORD PTR [rdx+0x18]
  40ae18:	48 8b 04 c2          	mov    rax,QWORD PTR [rdx+rax*8]
	*ent = __kv_index(i->start, i->curr++);
  40ae1c:	48 89 85 78 ff ff ff 	mov    QWORD PTR [rbp-0x88],rax
	switch (arg->type) {
  40ae23:	4c 8b b5 78 ff ff ff 	mov    r14,QWORD PTR [rbp-0x88]
	if (!kv) return NULL;
  40ae2a:	4d 85 f6             	test   r14,r14
  40ae2d:	74 77                	je     40aea6 <args_lkup_entry+0x1b6>
	*key_len = strlen(kv->key);
  40ae2f:	4d 8b 36             	mov    r14,QWORD PTR [r14]
  40ae32:	4c 89 f7             	mov    rdi,r14
  40ae35:	e8 96 ab 00 00       	call   4159d0 <strlen>
  40ae3a:	89 c2                	mov    edx,eax
  40ae3c:	89 85 6c ff ff ff    	mov    DWORD PTR [rbp-0x94],eax
			if ((unsigned int)key_len == len && strncmp(k, key, len) == 0) {
  40ae42:	39 da                	cmp    edx,ebx
  40ae44:	0f 84 76 ff ff ff    	je     40adc0 <args_lkup_entry+0xd0>
  40ae4a:	eb 8d                	jmp    40add9 <args_lkup_entry+0xe9>
  40ae4c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	switch (i->type) {
  40ae50:	83 f8 01             	cmp    eax,0x1
  40ae53:	75 1b                	jne    40ae70 <args_lkup_entry+0x180>
	case ARGS_IMPL_TAR: return tar_iter_next(&i->i.tar_i, &arg->d.tar_ent);
  40ae55:	48 8d b5 78 ff ff ff 	lea    rsi,[rbp-0x88]
  40ae5c:	48 8d 7d b8          	lea    rdi,[rbp-0x48]
  40ae60:	e8 7b 05 00 00       	call   40b3e0 <tar_iter_next>
		for (cont = args_iter(&start, &i, &curr) ; cont ; cont = args_iter_next(&i, &curr)) {
  40ae65:	85 c0                	test   eax,eax
  40ae67:	0f 85 33 ff ff ff    	jne    40ada0 <args_lkup_entry+0xb0>
  40ae6d:	0f 1f 00             	nop    DWORD PTR [rax]
				start = curr;
				found = 1;
				break;
			}
		}
		if (!found) return -1;
  40ae70:	41 b8 ff ff ff ff    	mov    r8d,0xffffffff

		if (slash) key = slash + 1;
	} while (slash && *key != '\0');

	return -1;
}
  40ae76:	48 81 c4 88 00 00 00 	add    rsp,0x88
  40ae7d:	44 89 c0             	mov    eax,r8d
  40ae80:	5b                   	pop    rbx
  40ae81:	41 5c                	pop    r12
  40ae83:	41 5d                	pop    r13
  40ae85:	41 5e                	pop    r14
  40ae87:	41 5f                	pop    r15
  40ae89:	5d                   	pop    rbp
  40ae8a:	c3                   	ret    
  40ae8b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	case ARGS_IMPL_TAR: return tar_key(&arg->d.tar_ent, arg_len);
  40ae90:	48 8d b5 6c ff ff ff 	lea    rsi,[rbp-0x94]
  40ae97:	48 8d bd 78 ff ff ff 	lea    rdi,[rbp-0x88]
  40ae9e:	e8 0d 03 00 00       	call   40b1b0 <tar_key>
  40aea3:	49 89 c6             	mov    r14,rax
			if ((unsigned int)key_len == len && strncmp(k, key, len) == 0) {
  40aea6:	8b 95 6c ff ff ff    	mov    edx,DWORD PTR [rbp-0x94]
	case ARGS_IMPL_TAR: return tar_key(&arg->d.tar_ent, arg_len);
  40aeac:	e9 0b ff ff ff       	jmp    40adbc <args_lkup_entry+0xcc>
  40aeb1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  40aeb8:	31 c0                	xor    eax,eax
  40aeba:	e9 5d ff ff ff       	jmp    40ae1c <args_lkup_entry+0x12c>
  40aebf:	90                   	nop
  40aec0:	48 8b 7d 98          	mov    rdi,QWORD PTR [rbp-0x68]
  40aec4:	48 8d 95 70 ff ff ff 	lea    rdx,[rbp-0x90]
  40aecb:	48 8d 75 b0          	lea    rsi,[rbp-0x50]
  40aecf:	e8 6c fa ff ff       	call   40a940 <args_iter.part.0.isra.0>
  40aed4:	e9 b5 fe ff ff       	jmp    40ad8e <args_lkup_entry+0x9e>
  40aed9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
				if (strlen(key) == len) {
  40aee0:	4c 89 e7             	mov    rdi,r12
  40aee3:	89 85 54 ff ff ff    	mov    DWORD PTR [rbp-0xac],eax
  40aee9:	e8 e2 aa 00 00       	call   4159d0 <strlen>
  40aeee:	44 8b 85 54 ff ff ff 	mov    r8d,DWORD PTR [rbp-0xac]
  40aef5:	49 39 c7             	cmp    r15,rax
  40aef8:	74 45                	je     40af3f <args_lkup_entry+0x24f>
				start = curr;
  40aefa:	66 0f 6f 8d 70 ff ff 	movdqa xmm1,XMMWORD PTR [rbp-0x90]
  40af01:	ff 
  40af02:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  40af06:	0f 29 4d 90          	movaps XMMWORD PTR [rbp-0x70],xmm1
  40af0a:	48 89 45 a0          	mov    QWORD PTR [rbp-0x60],rax
		if (slash) key = slash + 1;
  40af0e:	4d 85 ed             	test   r13,r13
  40af11:	0f 84 59 ff ff ff    	je     40ae70 <args_lkup_entry+0x180>
	} while (slash && *key != '\0');
  40af17:	41 80 7d 01 00       	cmp    BYTE PTR [r13+0x1],0x0
		if (slash) key = slash + 1;
  40af1c:	4d 8d 65 01          	lea    r12,[r13+0x1]
	} while (slash && *key != '\0');
  40af20:	0f 85 19 fe ff ff    	jne    40ad3f <args_lkup_entry+0x4f>
  40af26:	e9 45 ff ff ff       	jmp    40ae70 <args_lkup_entry+0x180>
  40af2b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		len = slash ? (unsigned int)(slash - key) : strlen(key);
  40af30:	4c 89 e7             	mov    rdi,r12
  40af33:	e8 98 aa 00 00       	call   4159d0 <strlen>
  40af38:	89 c3                	mov    ebx,eax
  40af3a:	e9 1e fe ff ff       	jmp    40ad5d <args_lkup_entry+0x6d>
					*ret = curr;
  40af3f:	48 8b 8d 58 ff ff ff 	mov    rcx,QWORD PTR [rbp-0xa8]
  40af46:	66 0f 6f 95 70 ff ff 	movdqa xmm2,XMMWORD PTR [rbp-0x90]
  40af4d:	ff 
  40af4e:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  40af52:	0f 11 11             	movups XMMWORD PTR [rcx],xmm2
  40af55:	48 89 41 10          	mov    QWORD PTR [rcx+0x10],rax
					return 0;
  40af59:	e9 18 ff ff ff       	jmp    40ae76 <args_lkup_entry+0x186>
  40af5e:	66 90                	xchg   ax,ax

000000000040af60 <args_type>:

args_type_t
args_type(struct initargs *ent)
{
  40af60:	f3 0f 1e fa          	endbr64 
  40af64:	55                   	push   rbp
  40af65:	48 89 e5             	mov    rbp,rsp
  40af68:	41 54                	push   r12
  40af6a:	48 83 ec 08          	sub    rsp,0x8
	switch (ent->type) {
  40af6e:	44 8b 27             	mov    r12d,DWORD PTR [rdi]
  40af71:	45 85 e4             	test   r12d,r12d
  40af74:	74 3a                	je     40afb0 <args_type+0x50>
  40af76:	41 83 fc 01          	cmp    r12d,0x1
  40af7a:	75 24                	jne    40afa0 <args_type+0x40>
	case ARGS_IMPL_KV:  return kv_type(ent->d.kv_ent);
	case ARGS_IMPL_TAR: return tar_is_value(&ent->d.tar_ent) ? ARGS_VAL : ARGS_MAP;
  40af7c:	48 83 c7 08          	add    rdi,0x8
  40af80:	e8 fb 03 00 00       	call   40b380 <tar_is_value>
  40af85:	85 c0                	test   eax,eax
  40af87:	b8 02 00 00 00       	mov    eax,0x2
  40af8c:	44 0f 45 e0          	cmovne r12d,eax
	default:            return ARGS_ERR;
	}
}
  40af90:	44 89 e0             	mov    eax,r12d
  40af93:	4c 8b 65 f8          	mov    r12,QWORD PTR [rbp-0x8]
  40af97:	c9                   	leave  
  40af98:	c3                   	ret    
  40af99:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	switch (ent->type) {
  40afa0:	45 31 e4             	xor    r12d,r12d
}
  40afa3:	44 89 e0             	mov    eax,r12d
  40afa6:	4c 8b 65 f8          	mov    r12,QWORD PTR [rbp-0x8]
  40afaa:	c9                   	leave  
  40afab:	c3                   	ret    
  40afac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	switch (kv->vtype) {
  40afb0:	48 8b 47 08          	mov    rax,QWORD PTR [rdi+0x8]
	case VTYPE_STR: return ARGS_VAL;
  40afb4:	41 bc 02 00 00 00    	mov    r12d,0x2
	switch (kv->vtype) {
  40afba:	8b 40 08             	mov    eax,DWORD PTR [rax+0x8]
  40afbd:	85 c0                	test   eax,eax
  40afbf:	74 cf                	je     40af90 <args_type+0x30>
  40afc1:	45 31 e4             	xor    r12d,r12d
  40afc4:	83 f8 01             	cmp    eax,0x1
  40afc7:	41 0f 94 c4          	sete   r12b
}
  40afcb:	44 89 e0             	mov    eax,r12d
  40afce:	4c 8b 65 f8          	mov    r12,QWORD PTR [rbp-0x8]
  40afd2:	c9                   	leave  
  40afd3:	c3                   	ret    
  40afd4:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40afdb:	00 00 00 00 
  40afdf:	90                   	nop

000000000040afe0 <args_get_entry_from>:

int
args_get_entry_from(char *path, struct initargs *from, struct initargs *ent)
{
  40afe0:	f3 0f 1e fa          	endbr64 
  40afe4:	49 89 f8             	mov    r8,rdi
  40afe7:	48 89 f7             	mov    rdi,rsi
	return args_lkup_entry(from, path, ent);
  40afea:	4c 89 c6             	mov    rsi,r8
  40afed:	e9 fe fc ff ff       	jmp    40acf0 <args_lkup_entry>
  40aff2:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40aff9:	00 00 00 00 
  40affd:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040b000 <args_get_from>:
}

char *
args_get_from(char *path, struct initargs *from)
{
  40b000:	f3 0f 1e fa          	endbr64 
  40b004:	55                   	push   rbp
  40b005:	49 89 f8             	mov    r8,rdi
  40b008:	48 89 f7             	mov    rdi,rsi
	return args_lkup_entry(from, path, ent);
  40b00b:	4c 89 c6             	mov    rsi,r8
{
  40b00e:	48 89 e5             	mov    rbp,rsp
  40b011:	48 83 ec 20          	sub    rsp,0x20
	return args_lkup_entry(from, path, ent);
  40b015:	48 8d 55 e0          	lea    rdx,[rbp-0x20]
  40b019:	e8 d2 fc ff ff       	call   40acf0 <args_lkup_entry>
  40b01e:	41 89 c0             	mov    r8d,eax
	struct initargs ent;

	if (args_get_entry_from(path, from, &ent)) return NULL;
  40b021:	31 c0                	xor    eax,eax
  40b023:	45 85 c0             	test   r8d,r8d
  40b026:	75 0c                	jne    40b034 <args_get_from+0x34>
	switch (arg->type) {
  40b028:	8b 55 e0             	mov    edx,DWORD PTR [rbp-0x20]
  40b02b:	85 d2                	test   edx,edx
  40b02d:	74 21                	je     40b050 <args_get_from+0x50>
  40b02f:	83 fa 01             	cmp    edx,0x1
  40b032:	74 0c                	je     40b040 <args_get_from+0x40>

	return args_value(&ent);
}
  40b034:	c9                   	leave  
  40b035:	c3                   	ret    
  40b036:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40b03d:	00 00 00 
	case ARGS_IMPL_TAR: return tar_value(&arg->d.tar_ent);
  40b040:	48 8d 7d e8          	lea    rdi,[rbp-0x18]
  40b044:	e8 17 02 00 00       	call   40b260 <tar_value>
}
  40b049:	c9                   	leave  
  40b04a:	c3                   	ret    
  40b04b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40b050:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
	if (!kv) return NULL;
  40b054:	48 85 c0             	test   rax,rax
  40b057:	74 db                	je     40b034 <args_get_from+0x34>
	switch (kv->vtype) {
  40b059:	8b 50 08             	mov    edx,DWORD PTR [rax+0x8]
  40b05c:	85 d2                	test   edx,edx
  40b05e:	75 10                	jne    40b070 <args_get_from+0x70>
	case VTYPE_STR: return kv->val.str;
  40b060:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
}
  40b064:	c9                   	leave  
  40b065:	c3                   	ret    
  40b066:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40b06d:	00 00 00 
  40b070:	c9                   	leave  
	if (args_get_entry_from(path, from, &ent)) return NULL;
  40b071:	31 c0                	xor    eax,eax
}
  40b073:	c3                   	ret    
  40b074:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40b07b:	00 00 00 00 
  40b07f:	90                   	nop

000000000040b080 <args_get_entry>:
 * structure, which is just a /-separated set of keys used to lookup
 * in the corresponding maps.
 */
int
args_get_entry(char *path, struct initargs *ent)
{
  40b080:	f3 0f 1e fa          	endbr64 
  40b084:	55                   	push   rbp
	return args_lkup_entry(from, path, ent);
  40b085:	48 89 f2             	mov    rdx,rsi
{
  40b088:	48 89 e5             	mov    rbp,rsp
  40b08b:	41 55                	push   r13
  40b08d:	49 89 f5             	mov    r13,rsi
	return args_lkup_entry(from, path, ent);
  40b090:	48 89 fe             	mov    rsi,rdi
{
  40b093:	41 54                	push   r12
  40b095:	49 89 fc             	mov    r12,rdi
	return args_lkup_entry(from, path, ent);
  40b098:	bf 20 40 42 00       	mov    edi,0x424020
{
  40b09d:	48 83 ec 20          	sub    rsp,0x20
	return args_lkup_entry(from, path, ent);
  40b0a1:	e8 4a fc ff ff       	call   40acf0 <args_lkup_entry>
	struct initargs tarroot;
	struct tar_entry *tarent;

	if (!args_get_entry_from(path, &__initargs_root, ent)) return 0;
  40b0a6:	85 c0                	test   eax,eax
  40b0a8:	75 0e                	jne    40b0b8 <args_get_entry+0x38>
		.type = ARGS_IMPL_TAR,
		.d.tar_ent = *tarent
	};

	return args_get_entry_from(path, &tarroot, ent);
}
  40b0aa:	48 83 c4 20          	add    rsp,0x20
  40b0ae:	41 5c                	pop    r12
  40b0b0:	41 5d                	pop    r13
  40b0b2:	5d                   	pop    rbp
  40b0b3:	c3                   	ret    
  40b0b4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	tarent = tar_root();
  40b0b8:	e8 33 07 00 00       	call   40b7f0 <tar_root>
	if (!tarent) return -1;
  40b0bd:	48 85 c0             	test   rax,rax
  40b0c0:	74 2d                	je     40b0ef <args_get_entry+0x6f>
		.d.tar_ent = *tarent
  40b0c2:	8b 10                	mov    edx,DWORD PTR [rax]
  40b0c4:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	return args_lkup_entry(from, path, ent);
  40b0c8:	4c 89 e6             	mov    rsi,r12
  40b0cb:	48 8d 7d d0          	lea    rdi,[rbp-0x30]
	tarroot = (struct initargs) {
  40b0cf:	c7 45 d0 01 00 00 00 	mov    DWORD PTR [rbp-0x30],0x1
  40b0d6:	89 55 d8             	mov    DWORD PTR [rbp-0x28],edx
	return args_lkup_entry(from, path, ent);
  40b0d9:	4c 89 ea             	mov    rdx,r13
	tarroot = (struct initargs) {
  40b0dc:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax
	return args_lkup_entry(from, path, ent);
  40b0e0:	e8 0b fc ff ff       	call   40acf0 <args_lkup_entry>
}
  40b0e5:	48 83 c4 20          	add    rsp,0x20
  40b0e9:	41 5c                	pop    r12
  40b0eb:	41 5d                	pop    r13
  40b0ed:	5d                   	pop    rbp
  40b0ee:	c3                   	ret    
	if (!tarent) return -1;
  40b0ef:	b8 ff ff ff ff       	mov    eax,0xffffffff
  40b0f4:	eb b4                	jmp    40b0aa <args_get_entry+0x2a>
  40b0f6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40b0fd:	00 00 00 

000000000040b100 <args_get>:

char *
args_get(char *path)
{
  40b100:	f3 0f 1e fa          	endbr64 
  40b104:	55                   	push   rbp
	return args_lkup_entry(from, path, ent);
  40b105:	48 89 fe             	mov    rsi,rdi
{
  40b108:	48 89 e5             	mov    rbp,rsp
  40b10b:	41 54                	push   r12
  40b10d:	49 89 fc             	mov    r12,rdi
	return args_lkup_entry(from, path, ent);
  40b110:	bf 20 40 42 00       	mov    edi,0x424020
  40b115:	48 8d 55 b0          	lea    rdx,[rbp-0x50]
{
  40b119:	48 83 ec 48          	sub    rsp,0x48
	return args_lkup_entry(from, path, ent);
  40b11d:	e8 ce fb ff ff       	call   40acf0 <args_lkup_entry>
	if (!args_get_entry_from(path, &__initargs_root, ent)) return 0;
  40b122:	85 c0                	test   eax,eax
  40b124:	75 4a                	jne    40b170 <args_get+0x70>
	switch (arg->type) {
  40b126:	8b 45 b0             	mov    eax,DWORD PTR [rbp-0x50]
  40b129:	85 c0                	test   eax,eax
  40b12b:	74 23                	je     40b150 <args_get+0x50>
  40b12d:	83 f8 01             	cmp    eax,0x1
  40b130:	74 0e                	je     40b140 <args_get+0x40>
	struct initargs ent;

	if (args_get_entry(path, &ent)) return NULL;
  40b132:	31 c0                	xor    eax,eax

	return args_value(&ent);
}
  40b134:	4c 8b 65 f8          	mov    r12,QWORD PTR [rbp-0x8]
  40b138:	c9                   	leave  
  40b139:	c3                   	ret    
  40b13a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	case ARGS_IMPL_TAR: return tar_value(&arg->d.tar_ent);
  40b140:	48 8d 7d b8          	lea    rdi,[rbp-0x48]
  40b144:	e8 17 01 00 00       	call   40b260 <tar_value>
}
  40b149:	4c 8b 65 f8          	mov    r12,QWORD PTR [rbp-0x8]
  40b14d:	c9                   	leave  
  40b14e:	c3                   	ret    
  40b14f:	90                   	nop
  40b150:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
	if (!kv) return NULL;
  40b154:	48 85 c0             	test   rax,rax
  40b157:	74 d9                	je     40b132 <args_get+0x32>
	switch (kv->vtype) {
  40b159:	8b 50 08             	mov    edx,DWORD PTR [rax+0x8]
  40b15c:	85 d2                	test   edx,edx
  40b15e:	75 d2                	jne    40b132 <args_get+0x32>
	case VTYPE_STR: return kv->val.str;
  40b160:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
}
  40b164:	4c 8b 65 f8          	mov    r12,QWORD PTR [rbp-0x8]
  40b168:	c9                   	leave  
  40b169:	c3                   	ret    
  40b16a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	tarent = tar_root();
  40b170:	e8 7b 06 00 00       	call   40b7f0 <tar_root>
	if (!tarent) return -1;
  40b175:	48 85 c0             	test   rax,rax
  40b178:	74 ba                	je     40b134 <args_get+0x34>
		.d.tar_ent = *tarent
  40b17a:	8b 10                	mov    edx,DWORD PTR [rax]
  40b17c:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	return args_lkup_entry(from, path, ent);
  40b180:	4c 89 e6             	mov    rsi,r12
  40b183:	48 8d 7d d0          	lea    rdi,[rbp-0x30]
	tarroot = (struct initargs) {
  40b187:	c7 45 d0 01 00 00 00 	mov    DWORD PTR [rbp-0x30],0x1
  40b18e:	89 55 d8             	mov    DWORD PTR [rbp-0x28],edx
	return args_lkup_entry(from, path, ent);
  40b191:	48 8d 55 b0          	lea    rdx,[rbp-0x50]
	tarroot = (struct initargs) {
  40b195:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax
	return args_lkup_entry(from, path, ent);
  40b199:	e8 52 fb ff ff       	call   40acf0 <args_lkup_entry>
	if (args_get_entry(path, &ent)) return NULL;
  40b19e:	85 c0                	test   eax,eax
  40b1a0:	75 90                	jne    40b132 <args_get+0x32>
  40b1a2:	eb 82                	jmp    40b126 <args_get+0x26>
  40b1a4:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40b1ab:	00 00 00 
  40b1ae:	66 90                	xchg   ax,ax

000000000040b1b0 <tar_key>:
	return r;
}

char *
tar_key(struct tar_entry *ent, int *str_len)
{
  40b1b0:	f3 0f 1e fa          	endbr64 
  40b1b4:	55                   	push   rbp
  40b1b5:	48 89 f8             	mov    rax,rdi
  40b1b8:	48 89 e5             	mov    rbp,rsp
  40b1bb:	41 55                	push   r13
  40b1bd:	49 89 f5             	mov    r13,rsi
  40b1c0:	41 54                	push   r12
  40b1c2:	53                   	push   rbx
  40b1c3:	48 83 ec 18          	sub    rsp,0x18
	return tar_nesting(ent->nesting_lvl, ent->record->name, str_len);
  40b1c7:	44 8b 20             	mov    r12d,DWORD PTR [rax]
  40b1ca:	48 8b 7f 08          	mov    rdi,QWORD PTR [rdi+0x8]
	for (i = 0 ; i < nesting_lvl ; i++) {
  40b1ce:	45 85 e4             	test   r12d,r12d
  40b1d1:	7e 3d                	jle    40b210 <tar_key+0x60>
  40b1d3:	31 db                	xor    ebx,ebx
  40b1d5:	eb 15                	jmp    40b1ec <tar_key+0x3c>
  40b1d7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40b1de:	00 00 
  40b1e0:	83 c3 01             	add    ebx,0x1
		key++;		/* one past the / */
  40b1e3:	48 83 c7 01          	add    rdi,0x1
	for (i = 0 ; i < nesting_lvl ; i++) {
  40b1e7:	41 39 dc             	cmp    r12d,ebx
  40b1ea:	74 24                	je     40b210 <tar_key+0x60>
		key = strchr(key, '/');
  40b1ec:	be 2f 00 00 00       	mov    esi,0x2f
  40b1f1:	e8 2a a6 00 00       	call   415820 <strchr>
  40b1f6:	48 89 c7             	mov    rdi,rax
		if (!key) return NULL;
  40b1f9:	48 85 c0             	test   rax,rax
  40b1fc:	75 e2                	jne    40b1e0 <tar_key+0x30>
}
  40b1fe:	48 83 c4 18          	add    rsp,0x18
  40b202:	48 89 f8             	mov    rax,rdi
  40b205:	5b                   	pop    rbx
  40b206:	41 5c                	pop    r12
  40b208:	41 5d                	pop    r13
  40b20a:	5d                   	pop    rbp
  40b20b:	c3                   	ret    
  40b20c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	end = strchr(key, '/');
  40b210:	be 2f 00 00 00       	mov    esi,0x2f
  40b215:	48 89 7d d8          	mov    QWORD PTR [rbp-0x28],rdi
  40b219:	e8 02 a6 00 00       	call   415820 <strchr>
	if (!end) *key_len = strlen(key);
  40b21e:	48 8b 7d d8          	mov    rdi,QWORD PTR [rbp-0x28]
  40b222:	48 85 c0             	test   rax,rax
  40b225:	74 19                	je     40b240 <tar_key+0x90>
	else      *key_len = end - key;
  40b227:	48 29 f8             	sub    rax,rdi
  40b22a:	41 89 45 00          	mov    DWORD PTR [r13+0x0],eax
}
  40b22e:	48 83 c4 18          	add    rsp,0x18
  40b232:	48 89 f8             	mov    rax,rdi
  40b235:	5b                   	pop    rbx
  40b236:	41 5c                	pop    r12
  40b238:	41 5d                	pop    r13
  40b23a:	5d                   	pop    rbp
  40b23b:	c3                   	ret    
  40b23c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	if (!end) *key_len = strlen(key);
  40b240:	e8 8b a7 00 00       	call   4159d0 <strlen>
  40b245:	48 8b 7d d8          	mov    rdi,QWORD PTR [rbp-0x28]
  40b249:	41 89 45 00          	mov    DWORD PTR [r13+0x0],eax
}
  40b24d:	48 83 c4 18          	add    rsp,0x18
  40b251:	5b                   	pop    rbx
  40b252:	48 89 f8             	mov    rax,rdi
  40b255:	41 5c                	pop    r12
  40b257:	41 5d                	pop    r13
  40b259:	5d                   	pop    rbp
  40b25a:	c3                   	ret    
  40b25b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000040b260 <tar_value>:

char *
tar_value(struct tar_entry *ent)
{
  40b260:	f3 0f 1e fa          	endbr64 
	if (!tar_valid(ent)) return NULL;
  40b264:	45 31 c0             	xor    r8d,r8d
	return !(!ent || !ent->record || tar_end(ent->record));
  40b267:	48 85 ff             	test   rdi,rdi
  40b26a:	74 41                	je     40b2ad <tar_value+0x4d>
  40b26c:	4c 8b 47 08          	mov    r8,QWORD PTR [rdi+0x8]
  40b270:	4d 85 c0             	test   r8,r8
  40b273:	74 38                	je     40b2ad <tar_value+0x4d>
  40b275:	4c 89 c0             	mov    rax,r8
  40b278:	49 8d 90 00 04 00 00 	lea    rdx,[r8+0x400]
  40b27f:	eb 10                	jmp    40b291 <tar_value+0x31>
  40b281:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40b288:	48 83 c0 01          	add    rax,0x1
  40b28c:	48 39 d0             	cmp    rax,rdx
  40b28f:	74 27                	je     40b2b8 <tar_value+0x58>
		if (((char *)r)[i]) return 0;
  40b291:	80 38 00             	cmp    BYTE PTR [rax],0x0
  40b294:	74 f2                	je     40b288 <tar_value+0x28>
	return *r->linkflag == '0' || *r->linkflag == '\0';
  40b296:	41 0f b6 80 9c 00 00 	movzx  eax,BYTE PTR [r8+0x9c]
  40b29d:	00 
	if (!tar_is_file(ent->record)) return NULL;
  40b29e:	3c 30                	cmp    al,0x30
  40b2a0:	74 04                	je     40b2a6 <tar_value+0x46>
  40b2a2:	84 c0                	test   al,al
  40b2a4:	75 12                	jne    40b2b8 <tar_value+0x58>

	return (char *)&ent->record[1];
  40b2a6:	49 81 c0 00 02 00 00 	add    r8,0x200
}
  40b2ad:	4c 89 c0             	mov    rax,r8
  40b2b0:	c3                   	ret    
  40b2b1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	if (!tar_valid(ent)) return NULL;
  40b2b8:	45 31 c0             	xor    r8d,r8d
}
  40b2bb:	4c 89 c0             	mov    rax,r8
  40b2be:	c3                   	ret    
  40b2bf:	90                   	nop

000000000040b2c0 <tar_value_sz>:

int
tar_value_sz(struct tar_entry *ent)
{
  40b2c0:	f3 0f 1e fa          	endbr64 
	if (!tar_valid(ent)) return 0;
  40b2c4:	45 31 c0             	xor    r8d,r8d
	return !(!ent || !ent->record || tar_end(ent->record));
  40b2c7:	48 85 ff             	test   rdi,rdi
  40b2ca:	74 54                	je     40b320 <tar_value_sz+0x60>
{
  40b2cc:	55                   	push   rbp
  40b2cd:	48 89 e5             	mov    rbp,rsp
  40b2d0:	53                   	push   rbx
  40b2d1:	48 83 ec 08          	sub    rsp,0x8
	return !(!ent || !ent->record || tar_end(ent->record));
  40b2d5:	48 8b 5f 08          	mov    rbx,QWORD PTR [rdi+0x8]
  40b2d9:	48 85 db             	test   rbx,rbx
  40b2dc:	74 32                	je     40b310 <tar_value_sz+0x50>
  40b2de:	48 89 d8             	mov    rax,rbx
  40b2e1:	48 8d 93 00 04 00 00 	lea    rdx,[rbx+0x400]
  40b2e8:	eb 0f                	jmp    40b2f9 <tar_value_sz+0x39>
  40b2ea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40b2f0:	48 83 c0 01          	add    rax,0x1
  40b2f4:	48 39 d0             	cmp    rax,rdx
  40b2f7:	74 14                	je     40b30d <tar_value_sz+0x4d>
		if (((char *)r)[i]) return 0;
  40b2f9:	80 38 00             	cmp    BYTE PTR [rax],0x0
  40b2fc:	74 f2                	je     40b2f0 <tar_value_sz+0x30>
	return *r->linkflag == '0' || *r->linkflag == '\0';
  40b2fe:	0f b6 83 9c 00 00 00 	movzx  eax,BYTE PTR [rbx+0x9c]
	if (!tar_is_file(ent->record)) return 0;
  40b305:	3c 30                	cmp    al,0x30
  40b307:	74 1f                	je     40b328 <tar_value_sz+0x68>
  40b309:	84 c0                	test   al,al
  40b30b:	74 1b                	je     40b328 <tar_value_sz+0x68>
	if (!tar_valid(ent)) return 0;
  40b30d:	45 31 c0             	xor    r8d,r8d

	return oct2dec(ent->record->size);
}
  40b310:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
  40b314:	44 89 c0             	mov    eax,r8d
  40b317:	c9                   	leave  
  40b318:	c3                   	ret    
  40b319:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  40b320:	44 89 c0             	mov    eax,r8d
  40b323:	c3                   	ret    
  40b324:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	i = strnlen(oct, TAR_SZ) - 1;
  40b328:	48 8d 7b 7c          	lea    rdi,[rbx+0x7c]
  40b32c:	be 0c 00 00 00       	mov    esi,0xc
  40b331:	e8 9a a7 00 00       	call   415ad0 <strnlen>
  40b336:	8d 50 ff             	lea    edx,[rax-0x1]
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40b339:	85 c0                	test   eax,eax
  40b33b:	74 d0                	je     40b30d <tar_value_sz+0x4d>
  40b33d:	48 63 d2             	movsxd rdx,edx
  40b340:	45 31 c0             	xor    r8d,r8d
  40b343:	b9 01 00 00 00       	mov    ecx,0x1
  40b348:	eb 1a                	jmp    40b364 <tar_value_sz+0xa4>
  40b34a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
		tot = tot + (val * base);
  40b350:	0f b6 c0             	movzx  eax,al
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40b353:	48 83 ea 01          	sub    rdx,0x1
		tot = tot + (val * base);
  40b357:	0f af c1             	imul   eax,ecx
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40b35a:	c1 e1 03             	shl    ecx,0x3
		tot = tot + (val * base);
  40b35d:	41 01 c0             	add    r8d,eax
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40b360:	85 d2                	test   edx,edx
  40b362:	78 ac                	js     40b310 <tar_value_sz+0x50>
		if (val > '7' || val < '0') return -1;
  40b364:	0f b6 44 13 7c       	movzx  eax,BYTE PTR [rbx+rdx*1+0x7c]
  40b369:	83 e8 30             	sub    eax,0x30
  40b36c:	3c 07                	cmp    al,0x7
  40b36e:	76 e0                	jbe    40b350 <tar_value_sz+0x90>
	if (i == TAR_RECORD_SIZE) return -1;
  40b370:	41 b8 ff ff ff ff    	mov    r8d,0xffffffff
  40b376:	eb 98                	jmp    40b310 <tar_value_sz+0x50>
  40b378:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40b37f:	00 

000000000040b380 <tar_is_value>:

int
tar_is_value(struct tar_entry *ent)
{
  40b380:	f3 0f 1e fa          	endbr64 
	if (!tar_valid(ent)) return 0;
  40b384:	31 c0                	xor    eax,eax
	return !(!ent || !ent->record || tar_end(ent->record));
  40b386:	48 85 ff             	test   rdi,rdi
  40b389:	74 3a                	je     40b3c5 <tar_is_value+0x45>
  40b38b:	48 8b 4f 08          	mov    rcx,QWORD PTR [rdi+0x8]
  40b38f:	48 85 c9             	test   rcx,rcx
  40b392:	74 31                	je     40b3c5 <tar_is_value+0x45>
  40b394:	48 89 c8             	mov    rax,rcx
  40b397:	48 8d 91 00 04 00 00 	lea    rdx,[rcx+0x400]
  40b39e:	eb 09                	jmp    40b3a9 <tar_is_value+0x29>
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40b3a0:	48 83 c0 01          	add    rax,0x1
  40b3a4:	48 39 d0             	cmp    rax,rdx
  40b3a7:	74 27                	je     40b3d0 <tar_is_value+0x50>
		if (((char *)r)[i]) return 0;
  40b3a9:	80 38 00             	cmp    BYTE PTR [rax],0x0
  40b3ac:	74 f2                	je     40b3a0 <tar_is_value+0x20>
	return *r->linkflag == '0' || *r->linkflag == '\0';
  40b3ae:	0f b6 91 9c 00 00 00 	movzx  edx,BYTE PTR [rcx+0x9c]
  40b3b5:	80 fa 30             	cmp    dl,0x30
  40b3b8:	0f 94 c0             	sete   al
  40b3bb:	84 d2                	test   dl,dl
  40b3bd:	0f 94 c2             	sete   dl
  40b3c0:	09 d0                	or     eax,edx
  40b3c2:	0f b6 c0             	movzx  eax,al

	return tar_is_file(ent->record);
}
  40b3c5:	c3                   	ret    
  40b3c6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40b3cd:	00 00 00 
	if (!tar_valid(ent)) return 0;
  40b3d0:	31 c0                	xor    eax,eax
  40b3d2:	c3                   	ret    
  40b3d3:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40b3da:	00 00 00 00 
  40b3de:	66 90                	xchg   ax,ax

000000000040b3e0 <tar_iter_next>:

int
tar_iter_next(struct tar_iter *i, struct tar_entry *next)
{
  40b3e0:	f3 0f 1e fa          	endbr64 
  40b3e4:	55                   	push   rbp
  40b3e5:	48 89 e5             	mov    rbp,rsp
  40b3e8:	41 57                	push   r15
  40b3ea:	41 56                	push   r14
  40b3ec:	41 55                	push   r13
  40b3ee:	41 54                	push   r12
  40b3f0:	53                   	push   rbx
  40b3f1:	48 83 ec 28          	sub    rsp,0x28
  40b3f5:	48 89 75 c8          	mov    QWORD PTR [rbp-0x38],rsi
	struct tar_record *r;

	if (!i || !tar_valid(&i->entry)) return 0;
  40b3f9:	48 85 ff             	test   rdi,rdi
  40b3fc:	0f 84 ee 00 00 00    	je     40b4f0 <tar_iter_next+0x110>
	return !(!ent || !ent->record || tar_end(ent->record));
  40b402:	4c 8b 67 08          	mov    r12,QWORD PTR [rdi+0x8]
  40b406:	49 89 fe             	mov    r14,rdi
	if (!i || !tar_valid(&i->entry)) return 0;
  40b409:	31 c0                	xor    eax,eax
	return !(!ent || !ent->record || tar_end(ent->record));
  40b40b:	4d 85 e4             	test   r12,r12
  40b40e:	0f 84 de 00 00 00    	je     40b4f2 <tar_iter_next+0x112>
  40b414:	4d 8d ac 24 00 04 00 	lea    r13,[r12+0x400]
  40b41b:	00 
  40b41c:	4c 89 e0             	mov    rax,r12
  40b41f:	eb 14                	jmp    40b435 <tar_iter_next+0x55>
  40b421:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40b428:	48 83 c0 01          	add    rax,0x1
  40b42c:	4c 39 e8             	cmp    rax,r13
  40b42f:	0f 84 bb 00 00 00    	je     40b4f0 <tar_iter_next+0x110>
		if (((char *)r)[i]) return 0;
  40b435:	80 38 00             	cmp    BYTE PTR [rax],0x0
  40b438:	74 ee                	je     40b428 <tar_iter_next+0x48>
  40b43a:	4c 89 e0             	mov    rax,r12
  40b43d:	eb 0e                	jmp    40b44d <tar_iter_next+0x6d>
  40b43f:	90                   	nop
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40b440:	48 83 c0 01          	add    rax,0x1
  40b444:	4c 39 e8             	cmp    rax,r13
  40b447:	0f 84 a3 00 00 00    	je     40b4f0 <tar_iter_next+0x110>
		if (((char *)r)[i]) return 0;
  40b44d:	80 38 00             	cmp    BYTE PTR [rax],0x0
  40b450:	74 ee                	je     40b440 <tar_iter_next+0x60>
	if (!tar_valid(path) || iter == NULL || *iter == NULL) return NULL;
  40b452:	4d 8b 7e 10          	mov    r15,QWORD PTR [r14+0x10]
  40b456:	4d 85 ff             	test   r15,r15
  40b459:	0f 84 91 00 00 00    	je     40b4f0 <tar_iter_next+0x110>
  40b45f:	90                   	nop
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40b460:	4c 89 fb             	mov    rbx,r15
  40b463:	4d 8d 8f 00 04 00 00 	lea    r9,[r15+0x400]
  40b46a:	4c 89 f8             	mov    rax,r15
  40b46d:	eb 0a                	jmp    40b479 <tar_iter_next+0x99>
  40b46f:	90                   	nop
  40b470:	48 83 c0 01          	add    rax,0x1
  40b474:	49 39 c1             	cmp    r9,rax
  40b477:	74 57                	je     40b4d0 <tar_iter_next+0xf0>
		if (((char *)r)[i]) return 0;
  40b479:	80 38 00             	cmp    BYTE PTR [rax],0x0
  40b47c:	74 f2                	je     40b470 <tar_iter_next+0x90>
  40b47e:	4c 89 e0             	mov    rax,r12
  40b481:	eb 12                	jmp    40b495 <tar_iter_next+0xb5>
  40b483:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40b488:	48 83 c0 01          	add    rax,0x1
  40b48c:	4c 39 e8             	cmp    rax,r13
  40b48f:	0f 84 7c 00 00 00    	je     40b511 <tar_iter_next+0x131>
		if (((char *)r)[i]) return 0;
  40b495:	80 38 00             	cmp    BYTE PTR [rax],0x0
  40b498:	74 ee                	je     40b488 <tar_iter_next+0xa8>
	if (ent->nesting_lvl == 0) {
  40b49a:	41 8b 06             	mov    eax,DWORD PTR [r14]
	end = strchr(key, '/');
  40b49d:	be 2f 00 00 00       	mov    esi,0x2f
  40b4a2:	4c 89 ff             	mov    rdi,r15
  40b4a5:	4c 89 4d c0          	mov    QWORD PTR [rbp-0x40],r9
	if (ent->nesting_lvl == 0) {
  40b4a9:	89 45 b4             	mov    DWORD PTR [rbp-0x4c],eax
	end = strchr(key, '/');
  40b4ac:	e8 6f a3 00 00       	call   415820 <strchr>
	if (ent->nesting_lvl == 0) {
  40b4b1:	8b 55 b4             	mov    edx,DWORD PTR [rbp-0x4c]
  40b4b4:	4c 8b 4d c0          	mov    r9,QWORD PTR [rbp-0x40]
  40b4b8:	85 d2                	test   edx,edx
  40b4ba:	0f 85 65 01 00 00    	jne    40b625 <tar_iter_next+0x245>
	return !((cmp == 0) && (end == NULL || end[1] == '\0'));
  40b4c0:	48 85 c0             	test   rax,rax
  40b4c3:	74 0b                	je     40b4d0 <tar_iter_next+0xf0>
  40b4c5:	80 78 01 00          	cmp    BYTE PTR [rax+0x1],0x0
  40b4c9:	75 46                	jne    40b511 <tar_iter_next+0x131>
  40b4cb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40b4d0:	4c 89 f8             	mov    rax,r15
  40b4d3:	eb 0c                	jmp    40b4e1 <tar_iter_next+0x101>
  40b4d5:	0f 1f 00             	nop    DWORD PTR [rax]
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40b4d8:	48 83 c0 01          	add    rax,0x1
  40b4dc:	49 39 c1             	cmp    r9,rax
  40b4df:	74 0f                	je     40b4f0 <tar_iter_next+0x110>
		if (((char *)r)[i]) return 0;
  40b4e1:	80 38 00             	cmp    BYTE PTR [rax],0x0
  40b4e4:	74 f2                	je     40b4d8 <tar_iter_next+0xf8>
  40b4e6:	e9 9a 00 00 00       	jmp    40b585 <tar_iter_next+0x1a5>
  40b4eb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	if (!i || !tar_valid(&i->entry)) return 0;
  40b4f0:	31 c0                	xor    eax,eax

	next->nesting_lvl = i->entry.nesting_lvl;
	next->record = r;

	return 1;
}
  40b4f2:	48 83 c4 28          	add    rsp,0x28
  40b4f6:	5b                   	pop    rbx
  40b4f7:	41 5c                	pop    r12
  40b4f9:	41 5d                	pop    r13
  40b4fb:	41 5e                	pop    r14
  40b4fd:	41 5f                	pop    r15
  40b4ff:	5d                   	pop    rbp
  40b500:	c3                   	ret    
  40b501:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40b508:	48 83 c3 01          	add    rbx,0x1
  40b50c:	49 39 d9             	cmp    r9,rbx
  40b50f:	74 df                	je     40b4f0 <tar_iter_next+0x110>
		if (((char *)r)[i]) return 0;
  40b511:	80 3b 00             	cmp    BYTE PTR [rbx],0x0
  40b514:	74 f2                	je     40b508 <tar_iter_next+0x128>
	i = strnlen(oct, TAR_SZ) - 1;
  40b516:	49 8d 7f 7c          	lea    rdi,[r15+0x7c]
  40b51a:	be 0c 00 00 00       	mov    esi,0xc
  40b51f:	e8 ac a5 00 00       	call   415ad0 <strnlen>
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40b524:	31 ff                	xor    edi,edi
  40b526:	be 01 00 00 00       	mov    esi,0x1
	i = strnlen(oct, TAR_SZ) - 1;
  40b52b:	83 e8 01             	sub    eax,0x1
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40b52e:	48 63 d0             	movsxd rdx,eax
  40b531:	83 f8 ff             	cmp    eax,0xffffffff
  40b534:	75 21                	jne    40b557 <tar_iter_next+0x177>
  40b536:	eb 2c                	jmp    40b564 <tar_iter_next+0x184>
  40b538:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40b53f:	00 
		tot = tot + (val * base);
  40b540:	0f b6 c0             	movzx  eax,al
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40b543:	48 83 ea 01          	sub    rdx,0x1
		tot = tot + (val * base);
  40b547:	0f af c6             	imul   eax,esi
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40b54a:	c1 e6 03             	shl    esi,0x3
		tot = tot + (val * base);
  40b54d:	01 c7                	add    edi,eax
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40b54f:	85 d2                	test   edx,edx
  40b551:	0f 88 b1 00 00 00    	js     40b608 <tar_iter_next+0x228>
		if (val > '7' || val < '0') return -1;
  40b557:	41 0f b6 44 17 7c    	movzx  eax,BYTE PTR [r15+rdx*1+0x7c]
  40b55d:	83 e8 30             	sub    eax,0x30
  40b560:	3c 07                	cmp    al,0x7
  40b562:	76 dc                	jbe    40b540 <tar_iter_next+0x160>
  40b564:	b8 00 02 00 00       	mov    eax,0x200
	return &r[n_records + 1];
  40b569:	49 01 c7             	add    r15,rax
	for (r = *iter; r && !tar_end(r) && tar_pathcmp(path, r->name); r = tar_next_record(r)) ;
  40b56c:	e9 ef fe ff ff       	jmp    40b460 <tar_iter_next+0x80>
  40b571:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40b578:	48 83 c3 01          	add    rbx,0x1
  40b57c:	49 39 d9             	cmp    r9,rbx
  40b57f:	0f 84 45 01 00 00    	je     40b6ca <tar_iter_next+0x2ea>
		if (((char *)r)[i]) return 0;
  40b585:	80 3b 00             	cmp    BYTE PTR [rbx],0x0
  40b588:	74 ee                	je     40b578 <tar_iter_next+0x198>
	i = strnlen(oct, TAR_SZ) - 1;
  40b58a:	be 0c 00 00 00       	mov    esi,0xc
  40b58f:	49 8d 7f 7c          	lea    rdi,[r15+0x7c]
  40b593:	e8 38 a5 00 00       	call   415ad0 <strnlen>
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40b598:	31 f6                	xor    esi,esi
  40b59a:	b9 01 00 00 00       	mov    ecx,0x1
	i = strnlen(oct, TAR_SZ) - 1;
  40b59f:	83 e8 01             	sub    eax,0x1
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40b5a2:	48 63 d0             	movsxd rdx,eax
  40b5a5:	83 f8 ff             	cmp    eax,0xffffffff
  40b5a8:	75 1d                	jne    40b5c7 <tar_iter_next+0x1e7>
  40b5aa:	eb 28                	jmp    40b5d4 <tar_iter_next+0x1f4>
  40b5ac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		tot = tot + (val * base);
  40b5b0:	0f b6 c0             	movzx  eax,al
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40b5b3:	48 83 ea 01          	sub    rdx,0x1
		tot = tot + (val * base);
  40b5b7:	0f af c1             	imul   eax,ecx
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40b5ba:	c1 e1 03             	shl    ecx,0x3
		tot = tot + (val * base);
  40b5bd:	01 c6                	add    esi,eax
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40b5bf:	85 d2                	test   edx,edx
  40b5c1:	0f 88 e9 00 00 00    	js     40b6b0 <tar_iter_next+0x2d0>
		if (val > '7' || val < '0') return -1;
  40b5c7:	41 0f b6 44 17 7c    	movzx  eax,BYTE PTR [r15+rdx*1+0x7c]
  40b5cd:	83 e8 30             	sub    eax,0x30
  40b5d0:	3c 07                	cmp    al,0x7
  40b5d2:	76 dc                	jbe    40b5b0 <tar_iter_next+0x1d0>
  40b5d4:	b8 00 02 00 00       	mov    eax,0x200
	return &r[n_records + 1];
  40b5d9:	4c 01 f8             	add    rax,r15
	*iter = tar_next_record(r);
  40b5dc:	49 89 46 10          	mov    QWORD PTR [r14+0x10],rax
	next->nesting_lvl = i->entry.nesting_lvl;
  40b5e0:	48 8b 4d c8          	mov    rcx,QWORD PTR [rbp-0x38]
  40b5e4:	41 8b 06             	mov    eax,DWORD PTR [r14]
	next->record = r;
  40b5e7:	4c 89 79 08          	mov    QWORD PTR [rcx+0x8],r15
	next->nesting_lvl = i->entry.nesting_lvl;
  40b5eb:	89 01                	mov    DWORD PTR [rcx],eax
}
  40b5ed:	48 83 c4 28          	add    rsp,0x28
	return 1;
  40b5f1:	b8 01 00 00 00       	mov    eax,0x1
}
  40b5f6:	5b                   	pop    rbx
  40b5f7:	41 5c                	pop    r12
  40b5f9:	41 5d                	pop    r13
  40b5fb:	41 5e                	pop    r14
  40b5fd:	41 5f                	pop    r15
  40b5ff:	5d                   	pop    rbp
  40b600:	c3                   	ret    
  40b601:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	n_records = round_up_to_pow2(sz, TAR_RECORD_SIZE) / TAR_RECORD_SIZE;
  40b608:	48 63 ff             	movsxd rdi,edi
  40b60b:	48 81 c7 ff 01 00 00 	add    rdi,0x1ff
	return &r[n_records + 1];
  40b612:	48 81 e7 00 fe ff ff 	and    rdi,0xfffffffffffffe00
  40b619:	48 8d 87 00 02 00 00 	lea    rax,[rdi+0x200]
  40b620:	e9 44 ff ff ff       	jmp    40b569 <tar_iter_next+0x189>
	for (i = 0 ; i < nesting_lvl ; i++) {
  40b625:	0f 8e a6 00 00 00    	jle    40b6d1 <tar_iter_next+0x2f1>
  40b62b:	4d 89 fa             	mov    r10,r15
  40b62e:	31 d2                	xor    edx,edx
		key = strchr(key, '/');
  40b630:	be 2f 00 00 00       	mov    esi,0x2f
  40b635:	4c 89 d7             	mov    rdi,r10
  40b638:	4c 89 4d c0          	mov    QWORD PTR [rbp-0x40],r9
  40b63c:	89 55 b8             	mov    DWORD PTR [rbp-0x48],edx
  40b63f:	e8 dc a1 00 00       	call   415820 <strchr>
		if (!key) return NULL;
  40b644:	4c 8b 4d c0          	mov    r9,QWORD PTR [rbp-0x40]
  40b648:	48 85 c0             	test   rax,rax
  40b64b:	0f 84 c0 fe ff ff    	je     40b511 <tar_iter_next+0x131>
	for (i = 0 ; i < nesting_lvl ; i++) {
  40b651:	8b 55 b8             	mov    edx,DWORD PTR [rbp-0x48]
		key++;		/* one past the / */
  40b654:	4c 8d 50 01          	lea    r10,[rax+0x1]
	for (i = 0 ; i < nesting_lvl ; i++) {
  40b658:	83 c2 01             	add    edx,0x1
  40b65b:	39 55 b4             	cmp    DWORD PTR [rbp-0x4c],edx
  40b65e:	75 d0                	jne    40b630 <tar_iter_next+0x250>
	if (*key == '\0') return 1; /* if we have the actual directory, avoid it */
  40b660:	80 78 01 00          	cmp    BYTE PTR [rax+0x1],0x0
  40b664:	0f 84 a7 fe ff ff    	je     40b511 <tar_iter_next+0x131>
	len = (int)(key - path);
  40b66a:	4c 89 d2             	mov    rdx,r10
	cmp = strncmp(p, path, len);
  40b66d:	4c 89 fe             	mov    rsi,r15
  40b670:	4c 89 e7             	mov    rdi,r12
  40b673:	4c 89 4d b8          	mov    QWORD PTR [rbp-0x48],r9
	len = (int)(key - path);
  40b677:	4c 29 fa             	sub    rdx,r15
  40b67a:	4c 89 55 c0          	mov    QWORD PTR [rbp-0x40],r10
  40b67e:	48 63 d2             	movsxd rdx,edx
	cmp = strncmp(p, path, len);
  40b681:	e8 ca a3 00 00       	call   415a50 <strncmp>
	return !((cmp == 0) && (end == NULL || end[1] == '\0'));
  40b686:	4c 8b 55 c0          	mov    r10,QWORD PTR [rbp-0x40]
  40b68a:	4c 8b 4d b8          	mov    r9,QWORD PTR [rbp-0x48]
  40b68e:	85 c0                	test   eax,eax
  40b690:	0f 85 7b fe ff ff    	jne    40b511 <tar_iter_next+0x131>
	end = strchr(key, '/');
  40b696:	be 2f 00 00 00       	mov    esi,0x2f
  40b69b:	4c 89 d7             	mov    rdi,r10
  40b69e:	4c 89 4d c0          	mov    QWORD PTR [rbp-0x40],r9
  40b6a2:	e8 79 a1 00 00       	call   415820 <strchr>
  40b6a7:	4c 8b 4d c0          	mov    r9,QWORD PTR [rbp-0x40]
  40b6ab:	e9 10 fe ff ff       	jmp    40b4c0 <tar_iter_next+0xe0>
	n_records = round_up_to_pow2(sz, TAR_RECORD_SIZE) / TAR_RECORD_SIZE;
  40b6b0:	48 63 c6             	movsxd rax,esi
  40b6b3:	48 05 ff 01 00 00    	add    rax,0x1ff
	return &r[n_records + 1];
  40b6b9:	48 25 00 fe ff ff    	and    rax,0xfffffffffffffe00
  40b6bf:	48 05 00 02 00 00    	add    rax,0x200
  40b6c5:	e9 0f ff ff ff       	jmp    40b5d9 <tar_iter_next+0x1f9>
	if (tar_end(r)) return NULL;
  40b6ca:	31 c0                	xor    eax,eax
  40b6cc:	e9 0b ff ff ff       	jmp    40b5dc <tar_iter_next+0x1fc>
	if (*key == '\0') return 1; /* if we have the actual directory, avoid it */
  40b6d1:	41 80 3f 00          	cmp    BYTE PTR [r15],0x0
  40b6d5:	0f 85 e5 fd ff ff    	jne    40b4c0 <tar_iter_next+0xe0>
  40b6db:	e9 31 fe ff ff       	jmp    40b511 <tar_iter_next+0x131>

000000000040b6e0 <tar_iter>:
 * assumptions is wrong, we will skip all of those entries in a
 * directory that come *before* the directory record.
 */
int
tar_iter(struct tar_entry *ent, struct tar_iter *i, struct tar_entry *first)
{
  40b6e0:	f3 0f 1e fa          	endbr64 
  40b6e4:	49 89 f8             	mov    r8,rdi
  40b6e7:	48 89 f7             	mov    rdi,rsi
	return !(!ent || !ent->record || tar_end(ent->record));
  40b6ea:	4d 85 c0             	test   r8,r8
  40b6ed:	74 30                	je     40b71f <tar_iter+0x3f>
  40b6ef:	49 8b 70 08          	mov    rsi,QWORD PTR [r8+0x8]
  40b6f3:	48 85 f6             	test   rsi,rsi
  40b6f6:	74 27                	je     40b71f <tar_iter+0x3f>
  40b6f8:	48 89 f0             	mov    rax,rsi
  40b6fb:	48 8d 8e 00 04 00 00 	lea    rcx,[rsi+0x400]
  40b702:	eb 0d                	jmp    40b711 <tar_iter+0x31>
  40b704:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40b708:	48 83 c0 01          	add    rax,0x1
  40b70c:	48 39 c1             	cmp    rcx,rax
  40b70f:	74 0e                	je     40b71f <tar_iter+0x3f>
		if (((char *)r)[i]) return 0;
  40b711:	80 38 00             	cmp    BYTE PTR [rax],0x0
  40b714:	74 f2                	je     40b708 <tar_iter+0x28>
	if (!tar_valid(ent)) return 0;
	if (!tar_is_dir(ent->record)) return 0;
  40b716:	80 be 9c 00 00 00 35 	cmp    BYTE PTR [rsi+0x9c],0x35
  40b71d:	74 09                	je     40b728 <tar_iter+0x48>
	i->entry    = *ent;
	i->iter_rec = ent->record;
	i->entry.nesting_lvl++;	/* look *in* the entry */

	return tar_iter_next(i, first);
}
  40b71f:	31 c0                	xor    eax,eax
  40b721:	c3                   	ret    
  40b722:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	i->entry    = *ent;
  40b728:	f3 41 0f 6f 00       	movdqu xmm0,XMMWORD PTR [r8]
	return tar_iter_next(i, first);
  40b72d:	48 89 d6             	mov    rsi,rdx
	i->entry    = *ent;
  40b730:	0f 11 07             	movups XMMWORD PTR [rdi],xmm0
	i->iter_rec = ent->record;
  40b733:	49 8b 40 08          	mov    rax,QWORD PTR [r8+0x8]
	i->entry.nesting_lvl++;	/* look *in* the entry */
  40b737:	83 07 01             	add    DWORD PTR [rdi],0x1
	i->iter_rec = ent->record;
  40b73a:	48 89 47 10          	mov    QWORD PTR [rdi+0x10],rax
	return tar_iter_next(i, first);
  40b73e:	e9 9d fc ff ff       	jmp    40b3e0 <tar_iter_next>
  40b743:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40b74a:	00 00 00 00 
  40b74e:	66 90                	xchg   ax,ax

000000000040b750 <tar_len>:

int
tar_len(struct tar_entry *start)
{
  40b750:	f3 0f 1e fa          	endbr64 
  40b754:	55                   	push   rbp
  40b755:	48 89 e5             	mov    rbp,rsp
  40b758:	41 54                	push   r12
  40b75a:	48 83 ec 38          	sub    rsp,0x38
	return !(!ent || !ent->record || tar_end(ent->record));
  40b75e:	48 85 ff             	test   rdi,rdi
  40b761:	74 34                	je     40b797 <tar_len+0x47>
  40b763:	48 8b 4f 08          	mov    rcx,QWORD PTR [rdi+0x8]
  40b767:	48 85 c9             	test   rcx,rcx
  40b76a:	74 2b                	je     40b797 <tar_len+0x47>
  40b76c:	48 89 c8             	mov    rax,rcx
  40b76f:	48 8d 91 00 04 00 00 	lea    rdx,[rcx+0x400]
  40b776:	eb 11                	jmp    40b789 <tar_len+0x39>
  40b778:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40b77f:	00 
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40b780:	48 83 c0 01          	add    rax,0x1
  40b784:	48 39 d0             	cmp    rax,rdx
  40b787:	74 0e                	je     40b797 <tar_len+0x47>
		if (((char *)r)[i]) return 0;
  40b789:	80 38 00             	cmp    BYTE PTR [rax],0x0
  40b78c:	74 f2                	je     40b780 <tar_len+0x30>
	if (!tar_is_dir(ent->record)) return 0;
  40b78e:	80 b9 9c 00 00 00 35 	cmp    BYTE PTR [rcx+0x9c],0x35
  40b795:	74 0c                	je     40b7a3 <tar_len+0x53>
	int cont = 0, cnt = 0;
	struct tar_iter i;
	struct tar_entry entry;	/* data placed in here; don't care about it for calculating len */
	for (cont = tar_iter(start, &i, &entry); cont ; cont = tar_iter_next(&i, &entry)) {
  40b797:	45 31 e4             	xor    r12d,r12d
		cnt++;
	}

	return cnt;
}
  40b79a:	44 89 e0             	mov    eax,r12d
  40b79d:	4c 8b 65 f8          	mov    r12,QWORD PTR [rbp-0x8]
  40b7a1:	c9                   	leave  
  40b7a2:	c3                   	ret    
	i->entry    = *ent;
  40b7a3:	f3 0f 6f 07          	movdqu xmm0,XMMWORD PTR [rdi]
	return tar_iter_next(i, first);
  40b7a7:	48 8d 75 c0          	lea    rsi,[rbp-0x40]
  40b7ab:	48 8d 7d d0          	lea    rdi,[rbp-0x30]
	i->iter_rec = ent->record;
  40b7af:	48 89 4d e0          	mov    QWORD PTR [rbp-0x20],rcx
	i->entry    = *ent;
  40b7b3:	0f 29 45 d0          	movaps XMMWORD PTR [rbp-0x30],xmm0
	i->entry.nesting_lvl++;	/* look *in* the entry */
  40b7b7:	83 45 d0 01          	add    DWORD PTR [rbp-0x30],0x1
	return tar_iter_next(i, first);
  40b7bb:	e8 20 fc ff ff       	call   40b3e0 <tar_iter_next>
	for (cont = tar_iter(start, &i, &entry); cont ; cont = tar_iter_next(&i, &entry)) {
  40b7c0:	85 c0                	test   eax,eax
  40b7c2:	74 d3                	je     40b797 <tar_len+0x47>
  40b7c4:	45 31 e4             	xor    r12d,r12d
  40b7c7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40b7ce:	00 00 
  40b7d0:	48 8d 75 c0          	lea    rsi,[rbp-0x40]
  40b7d4:	48 8d 7d d0          	lea    rdi,[rbp-0x30]
		cnt++;
  40b7d8:	41 83 c4 01          	add    r12d,0x1
	for (cont = tar_iter(start, &i, &entry); cont ; cont = tar_iter_next(&i, &entry)) {
  40b7dc:	e8 ff fb ff ff       	call   40b3e0 <tar_iter_next>
  40b7e1:	85 c0                	test   eax,eax
  40b7e3:	75 eb                	jne    40b7d0 <tar_len+0x80>
  40b7e5:	eb b3                	jmp    40b79a <tar_len+0x4a>
  40b7e7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40b7ee:	00 00 

000000000040b7f0 <tar_root>:
	return (unsigned int)((char *)_binary_crt_init_tar_end - (char *)_binary_crt_init_tar_start);
}

struct tar_entry *
tar_root(void)
{
  40b7f0:	f3 0f 1e fa          	endbr64 
	if ((char *)_binary_crt_init_tar_end - (char *)_binary_crt_init_tar_start < 512) return NULL;
  40b7f4:	b8 58 09 5a 00       	mov    eax,0x5a0958
  40b7f9:	ba 00 00 00 00       	mov    edx,0x0
  40b7fe:	48 2d 59 09 5a 00    	sub    rax,0x5a0959
  40b804:	48 3d ff 01 00 00    	cmp    rax,0x1ff
  40b80a:	b8 40 c0 45 00       	mov    eax,0x45c040
  40b80f:	48 0f 4e c2          	cmovle rax,rdx

	return &__tar_root;
}
  40b813:	c3                   	ret    
  40b814:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40b81b:	00 00 00 
  40b81e:	66 90                	xchg   ax,ax

000000000040b820 <cos_aepthd_fn>:
{
  40b820:	f3 0f 1e fa          	endbr64 
  40b824:	55                   	push   rbp
  40b825:	48 89 f8             	mov    rax,rdi
	(aep_fn)(aep_info->rcv, fn_data);
  40b828:	48 8b 77 28          	mov    rsi,QWORD PTR [rdi+0x28]
  40b82c:	48 8b 7f 18          	mov    rdi,QWORD PTR [rdi+0x18]
{
  40b830:	48 89 e5             	mov    rbp,rsp
	(aep_fn)(aep_info->rcv, fn_data);
  40b833:	ff 50 20             	call   QWORD PTR [rax+0x20]
  40b836:	be 32 00 00 00       	mov    esi,0x32
  40b83b:	bf 20 d3 41 00       	mov    edi,0x41d320
  40b840:	e8 8b e8 ff ff       	call   40a0d0 <cos_print_str>
	assert(0);
  40b845:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40b84c:	00 00 00 00 
  40b850:	0f 0b                	ud2    
  40b852:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40b859:	00 00 00 00 
  40b85d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040b860 <cos_defcompinfo_curr_get>:
static int                    curr_defci_init_status;
static struct cos_defcompinfo curr_defci;

struct cos_defcompinfo *
cos_defcompinfo_curr_get(void)
{
  40b860:	f3 0f 1e fa          	endbr64 
	return &curr_defci;
}
  40b864:	b8 60 09 5a 00       	mov    eax,0x5a0960
  40b869:	c3                   	ret    
  40b86a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000040b870 <cos_compinfo_get>:

struct cos_compinfo *
cos_compinfo_get(struct cos_defcompinfo *defci)
{
  40b870:	f3 0f 1e fa          	endbr64 
	assert(defci);
  40b874:	48 85 ff             	test   rdi,rdi
  40b877:	74 04                	je     40b87d <cos_compinfo_get+0xd>
  40b879:	48 89 f8             	mov    rax,rdi
	return &(defci->ci);
}
  40b87c:	c3                   	ret    
{
  40b87d:	55                   	push   rbp
  40b87e:	be 30 00 00 00       	mov    esi,0x30
  40b883:	bf 58 d3 41 00       	mov    edi,0x41d358
  40b888:	48 89 e5             	mov    rbp,rsp
  40b88b:	e8 40 e8 ff ff       	call   40a0d0 <cos_print_str>
	assert(defci);
  40b890:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40b897:	00 00 00 00 
  40b89b:	0f 0b                	ud2    
  40b89d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040b8a0 <cos_sched_aep_get>:

struct cos_aep_info *
cos_sched_aep_get(struct cos_defcompinfo *defci)
{
  40b8a0:	f3 0f 1e fa          	endbr64 
	assert(defci);
  40b8a4:	48 85 ff             	test   rdi,rdi
  40b8a7:	74 08                	je     40b8b1 <cos_sched_aep_get+0x11>
	return &(defci->sched_aep[cos_cpuid()]);
  40b8a9:	48 8d 87 e0 00 00 00 	lea    rax,[rdi+0xe0]
}
  40b8b0:	c3                   	ret    
{
  40b8b1:	55                   	push   rbp
  40b8b2:	be 30 00 00 00       	mov    esi,0x30
  40b8b7:	bf 90 d3 41 00       	mov    edi,0x41d390
  40b8bc:	48 89 e5             	mov    rbp,rsp
  40b8bf:	e8 0c e8 ff ff       	call   40a0d0 <cos_print_str>
	assert(defci);
  40b8c4:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40b8cb:	00 00 00 00 
  40b8cf:	0f 0b                	ud2    
  40b8d1:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40b8d8:	00 00 00 00 
  40b8dc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000040b8e0 <cos_defcompinfo_init>:

void
cos_defcompinfo_init(void)
{
  40b8e0:	f3 0f 1e fa          	endbr64 
  40b8e4:	55                   	push   rbp
	capid_t cap_frontier = atol(args_get("captbl_end"));
  40b8e5:	bf c1 d3 41 00       	mov    edi,0x41d3c1
{
  40b8ea:	48 89 e5             	mov    rbp,rsp
	capid_t cap_frontier = atol(args_get("captbl_end"));
  40b8ed:	e8 0e f8 ff ff       	call   40b100 <args_get>
  40b8f2:	48 89 c7             	mov    rdi,rax
  40b8f5:	e8 66 9e 00 00       	call   415760 <atol>

	assert(cap_frontier > 0);
  40b8fa:	48 85 c0             	test   rax,rax
  40b8fd:	0f 84 91 00 00 00    	je     40b994 <cos_defcompinfo_init+0xb4>
	if (curr_defci_init_status == INITIALIZED) return;
  40b903:	83 3d 66 51 19 00 01 	cmp    DWORD PTR [rip+0x195166],0x1        # 5a0a70 <curr_defci_init_status>
  40b90a:	0f 84 82 00 00 00    	je     40b992 <cos_defcompinfo_init+0xb2>
	struct cos_defcompinfo *defci = cos_defcompinfo_curr_get();
	struct cos_compinfo    *ci    = cos_compinfo_get(defci);

	if (curr_defci_init_status == INITIALIZED) return;

	cos_compinfo_init(ci, pgtbl_cap, captbl_cap, comp_cap, heap_ptr, cap_frontier, ci);
  40b910:	48 83 ec 08          	sub    rsp,0x8
  40b914:	4c 8b 05 3d b7 01 00 	mov    r8,QWORD PTR [rip+0x1b73d]        # 427058 <__cosrt_comp_info+0x58>
  40b91b:	49 89 c1             	mov    r9,rax
  40b91e:	b9 0c 00 00 00       	mov    ecx,0xc
  40b923:	68 60 09 5a 00       	push   0x5a0960
  40b928:	ba 04 00 00 00       	mov    edx,0x4
  40b92d:	be 08 00 00 00       	mov    esi,0x8
  40b932:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40b937:	e8 e4 1d 00 00       	call   40d720 <cos_compinfo_init>
	struct cos_compinfo    *ci        = cos_compinfo_get(defci);
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);

	assert(curr_defci_init_status == INITIALIZED);

	sched_aep->tc   = sched_tc;
  40b93c:	66 0f 6f 05 6c 1d 01 	movdqa xmm0,XMMWORD PTR [rip+0x11d6c]        # 41d6b0 <__unlock+0x1580>
  40b943:	00 
	sched_aep->thd  = sched_thd;
	sched_aep->rcv  = sched_rcv;
	sched_aep->fn   = NULL;
	sched_aep->data = NULL;
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40b944:	31 d2                	xor    edx,edx
  40b946:	be 28 00 00 00       	mov    esi,0x28
	curr_defci_init_status = INITIALIZED;
  40b94b:	c7 05 1b 51 19 00 01 	mov    DWORD PTR [rip+0x19511b],0x1        # 5a0a70 <curr_defci_init_status>
  40b952:	00 00 00 
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40b955:	bf 60 09 5a 00       	mov    edi,0x5a0960
	sched_aep->rcv  = sched_rcv;
  40b95a:	48 c7 05 f3 50 19 00 	mov    QWORD PTR [rip+0x1950f3],0x30        # 5a0a58 <curr_defci+0xf8>
  40b961:	30 00 00 00 
	sched_aep->fn   = NULL;
  40b965:	48 c7 05 f0 50 19 00 	mov    QWORD PTR [rip+0x1950f0],0x0        # 5a0a60 <curr_defci+0x100>
  40b96c:	00 00 00 00 
	sched_aep->data = NULL;
  40b970:	48 c7 05 ed 50 19 00 	mov    QWORD PTR [rip+0x1950ed],0x0        # 5a0a68 <curr_defci+0x108>
  40b977:	00 00 00 00 
	sched_aep->tc   = sched_tc;
  40b97b:	0f 29 05 be 50 19 00 	movaps XMMWORD PTR [rip+0x1950be],xmm0        # 5a0a40 <curr_defci+0xe0>
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40b982:	e8 b9 61 00 00       	call   411b40 <cos_introspect>
  40b987:	48 98                	cdqe   
  40b989:	48 89 05 c0 50 19 00 	mov    QWORD PTR [rip+0x1950c0],rax        # 5a0a50 <curr_defci+0xf0>
}
  40b990:	58                   	pop    rax
  40b991:	5a                   	pop    rdx
}
  40b992:	c9                   	leave  
  40b993:	c3                   	ret    
  40b994:	be 30 00 00 00       	mov    esi,0x30
  40b999:	bf d0 d3 41 00       	mov    edi,0x41d3d0
  40b99e:	e8 2d e7 ff ff       	call   40a0d0 <cos_print_str>
	assert(cap_frontier > 0);
  40b9a3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40b9aa:	00 00 00 00 
  40b9ae:	0f 0b                	ud2    

000000000040b9b0 <cos_defcompinfo_init_ext>:
{
  40b9b0:	f3 0f 1e fa          	endbr64 
  40b9b4:	55                   	push   rbp
  40b9b5:	66 48 0f 6e c7       	movq   xmm0,rdi
  40b9ba:	66 48 0f 6e ce       	movq   xmm1,rsi
  40b9bf:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  40b9c3:	48 89 e5             	mov    rbp,rsp
  40b9c6:	41 54                	push   r12
  40b9c8:	49 89 f4             	mov    r12,rsi
  40b9cb:	53                   	push   rbx
  40b9cc:	48 83 ec 10          	sub    rsp,0x10
	if (curr_defci_init_status == INITIALIZED) return;
  40b9d0:	83 3d 99 50 19 00 01 	cmp    DWORD PTR [rip+0x195099],0x1        # 5a0a70 <curr_defci_init_status>
  40b9d7:	0f 29 45 e0          	movaps XMMWORD PTR [rbp-0x20],xmm0
  40b9db:	74 74                	je     40ba51 <cos_defcompinfo_init_ext+0xa1>
	cos_compinfo_init(ci, pgtbl_cap, captbl_cap, comp_cap, heap_ptr, cap_frontier, ci);
  40b9dd:	48 83 ec 08          	sub    rsp,0x8
  40b9e1:	48 89 ce             	mov    rsi,rcx
  40b9e4:	48 89 d3             	mov    rbx,rdx
  40b9e7:	4c 89 c9             	mov    rcx,r9
  40b9ea:	68 60 09 5a 00       	push   0x5a0960
  40b9ef:	4c 89 c2             	mov    rdx,r8
  40b9f2:	4c 8b 4d 18          	mov    r9,QWORD PTR [rbp+0x18]
  40b9f6:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40b9fb:	4c 8b 45 10          	mov    r8,QWORD PTR [rbp+0x10]
  40b9ff:	e8 1c 1d 00 00       	call   40d720 <cos_compinfo_init>
	sched_aep->tc   = sched_tc;
  40ba04:	66 0f 6f 45 e0       	movdqa xmm0,XMMWORD PTR [rbp-0x20]
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40ba09:	31 d2                	xor    edx,edx
  40ba0b:	4c 89 e6             	mov    rsi,r12
  40ba0e:	bf 60 09 5a 00       	mov    edi,0x5a0960
	curr_defci_init_status = INITIALIZED;
  40ba13:	c7 05 53 50 19 00 01 	mov    DWORD PTR [rip+0x195053],0x1        # 5a0a70 <curr_defci_init_status>
  40ba1a:	00 00 00 
	sched_aep->rcv  = sched_rcv;
  40ba1d:	48 89 1d 34 50 19 00 	mov    QWORD PTR [rip+0x195034],rbx        # 5a0a58 <curr_defci+0xf8>
	sched_aep->fn   = NULL;
  40ba24:	48 c7 05 31 50 19 00 	mov    QWORD PTR [rip+0x195031],0x0        # 5a0a60 <curr_defci+0x100>
  40ba2b:	00 00 00 00 
	sched_aep->data = NULL;
  40ba2f:	48 c7 05 2e 50 19 00 	mov    QWORD PTR [rip+0x19502e],0x0        # 5a0a68 <curr_defci+0x108>
  40ba36:	00 00 00 00 
	sched_aep->tc   = sched_tc;
  40ba3a:	0f 29 05 ff 4f 19 00 	movaps XMMWORD PTR [rip+0x194fff],xmm0        # 5a0a40 <curr_defci+0xe0>
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40ba41:	e8 fa 60 00 00       	call   411b40 <cos_introspect>
  40ba46:	48 98                	cdqe   
  40ba48:	48 89 05 01 50 19 00 	mov    QWORD PTR [rip+0x195001],rax        # 5a0a50 <curr_defci+0xf0>
}
  40ba4f:	58                   	pop    rax
  40ba50:	5a                   	pop    rdx
}
  40ba51:	48 8d 65 f0          	lea    rsp,[rbp-0x10]
  40ba55:	5b                   	pop    rbx
  40ba56:	41 5c                	pop    r12
  40ba58:	5d                   	pop    rbp
  40ba59:	c3                   	ret    
  40ba5a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000040ba60 <cos_defcompinfo_sched_init_ext>:
{
  40ba60:	f3 0f 1e fa          	endbr64 
  40ba64:	55                   	push   rbp
  40ba65:	66 48 0f 6e c7       	movq   xmm0,rdi
  40ba6a:	66 48 0f 6e ce       	movq   xmm1,rsi
	assert(curr_defci_init_status == INITIALIZED);
  40ba6f:	83 3d fa 4f 19 00 01 	cmp    DWORD PTR [rip+0x194ffa],0x1        # 5a0a70 <curr_defci_init_status>
  40ba76:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
{
  40ba7a:	48 89 e5             	mov    rbp,rsp
	assert(curr_defci_init_status == INITIALIZED);
  40ba7d:	75 3b                	jne    40baba <cos_defcompinfo_sched_init_ext+0x5a>
	sched_aep->rcv  = sched_rcv;
  40ba7f:	48 89 15 d2 4f 19 00 	mov    QWORD PTR [rip+0x194fd2],rdx        # 5a0a58 <curr_defci+0xf8>
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40ba86:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40ba8b:	31 d2                	xor    edx,edx
	sched_aep->fn   = NULL;
  40ba8d:	48 c7 05 c8 4f 19 00 	mov    QWORD PTR [rip+0x194fc8],0x0        # 5a0a60 <curr_defci+0x100>
  40ba94:	00 00 00 00 
	sched_aep->data = NULL;
  40ba98:	48 c7 05 c5 4f 19 00 	mov    QWORD PTR [rip+0x194fc5],0x0        # 5a0a68 <curr_defci+0x108>
  40ba9f:	00 00 00 00 
	sched_aep->tc   = sched_tc;
  40baa3:	0f 29 05 96 4f 19 00 	movaps XMMWORD PTR [rip+0x194f96],xmm0        # 5a0a40 <curr_defci+0xe0>
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40baaa:	e8 91 60 00 00       	call   411b40 <cos_introspect>
}
  40baaf:	5d                   	pop    rbp
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40bab0:	48 98                	cdqe   
  40bab2:	48 89 05 97 4f 19 00 	mov    QWORD PTR [rip+0x194f97],rax        # 5a0a50 <curr_defci+0xf0>
}
  40bab9:	c3                   	ret    
  40baba:	be 30 00 00 00       	mov    esi,0x30
  40babf:	bf 08 d4 41 00       	mov    edi,0x41d408
  40bac4:	e8 07 e6 ff ff       	call   40a0d0 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40bac9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40bad0:	00 00 00 00 
  40bad4:	0f 0b                	ud2    
  40bad6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40badd:	00 00 00 

000000000040bae0 <cos_defcompinfo_sched_init>:

void
cos_defcompinfo_sched_init(void)
{
  40bae0:	f3 0f 1e fa          	endbr64 
  40bae4:	55                   	push   rbp
	assert(curr_defci_init_status == INITIALIZED);
  40bae5:	83 3d 84 4f 19 00 01 	cmp    DWORD PTR [rip+0x194f84],0x1        # 5a0a70 <curr_defci_init_status>
{
  40baec:	48 89 e5             	mov    rbp,rsp
	assert(curr_defci_init_status == INITIALIZED);
  40baef:	75 4c                	jne    40bb3d <cos_defcompinfo_sched_init+0x5d>
	sched_aep->tc   = sched_tc;
  40baf1:	66 0f 6f 05 b7 1b 01 	movdqa xmm0,XMMWORD PTR [rip+0x11bb7]        # 41d6b0 <__unlock+0x1580>
  40baf8:	00 
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40baf9:	31 d2                	xor    edx,edx
  40bafb:	be 28 00 00 00       	mov    esi,0x28
  40bb00:	bf 60 09 5a 00       	mov    edi,0x5a0960
	sched_aep->rcv  = sched_rcv;
  40bb05:	48 c7 05 48 4f 19 00 	mov    QWORD PTR [rip+0x194f48],0x30        # 5a0a58 <curr_defci+0xf8>
  40bb0c:	30 00 00 00 
	sched_aep->fn   = NULL;
  40bb10:	48 c7 05 45 4f 19 00 	mov    QWORD PTR [rip+0x194f45],0x0        # 5a0a60 <curr_defci+0x100>
  40bb17:	00 00 00 00 
	sched_aep->data = NULL;
  40bb1b:	48 c7 05 42 4f 19 00 	mov    QWORD PTR [rip+0x194f42],0x0        # 5a0a68 <curr_defci+0x108>
  40bb22:	00 00 00 00 
	sched_aep->tc   = sched_tc;
  40bb26:	0f 29 05 13 4f 19 00 	movaps XMMWORD PTR [rip+0x194f13],xmm0        # 5a0a40 <curr_defci+0xe0>
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40bb2d:	e8 0e 60 00 00       	call   411b40 <cos_introspect>

	cos_defcompinfo_sched_init_ext(BOOT_CAPTBL_SELF_INITTCAP_CPU_BASE, BOOT_CAPTBL_SELF_INITTHD_CPU_BASE,
				       BOOT_CAPTBL_SELF_INITRCV_CPU_BASE);
}
  40bb32:	5d                   	pop    rbp
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40bb33:	48 98                	cdqe   
  40bb35:	48 89 05 14 4f 19 00 	mov    QWORD PTR [rip+0x194f14],rax        # 5a0a50 <curr_defci+0xf0>
}
  40bb3c:	c3                   	ret    
  40bb3d:	be 30 00 00 00       	mov    esi,0x30
  40bb42:	bf 40 d4 41 00       	mov    edi,0x41d440
  40bb47:	e8 84 e5 ff ff       	call   40a0d0 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40bb4c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40bb53:	00 00 00 00 
  40bb57:	0f 0b                	ud2    
  40bb59:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000040bb60 <cos_defcompinfo_child_alloc>:
}

int
cos_defcompinfo_child_alloc(struct cos_defcompinfo *child_defci, vaddr_t entry, vaddr_t heap_ptr, capid_t cap_frontier,
                            int is_sched)
{
  40bb60:	f3 0f 1e fa          	endbr64 
  40bb64:	55                   	push   rbp
  40bb65:	48 89 e5             	mov    rbp,rsp
  40bb68:	41 55                	push   r13
  40bb6a:	41 54                	push   r12
  40bb6c:	53                   	push   rbx
  40bb6d:	48 83 ec 08          	sub    rsp,0x8
	assert(defci);
  40bb71:	48 85 ff             	test   rdi,rdi
  40bb74:	0f 84 18 01 00 00    	je     40bc92 <cos_defcompinfo_child_alloc+0x132>
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);
	struct cos_compinfo    *ci        = cos_compinfo_get(defci);
	struct cos_compinfo    *child_ci  = cos_compinfo_get(child_defci);
	struct cos_aep_info    *child_aep = cos_sched_aep_get(child_defci);

	assert(curr_defci_init_status == INITIALIZED);
  40bb7a:	83 3d ef 4e 19 00 01 	cmp    DWORD PTR [rip+0x194eef],0x1        # 5a0a70 <curr_defci_init_status>
  40bb81:	0f 85 27 01 00 00    	jne    40bcae <cos_defcompinfo_child_alloc+0x14e>
  40bb87:	49 89 f2             	mov    r10,rsi
  40bb8a:	45 89 c5             	mov    r13d,r8d
	ret = cos_compinfo_alloc(child_ci, heap_ptr, cap_frontier, entry, ci, 0);
  40bb8d:	48 89 d6             	mov    rsi,rdx
  40bb90:	45 31 c9             	xor    r9d,r9d
  40bb93:	48 89 ca             	mov    rdx,rcx
  40bb96:	41 b8 60 09 5a 00    	mov    r8d,0x5a0960
  40bb9c:	4c 89 d1             	mov    rcx,r10
  40bb9f:	48 89 fb             	mov    rbx,rdi
  40bba2:	e8 99 4b 00 00       	call   410740 <cos_compinfo_alloc>
  40bba7:	41 89 c4             	mov    r12d,eax
	if (ret) return ret;
  40bbaa:	85 c0                	test   eax,eax
  40bbac:	0f 85 d2 00 00 00    	jne    40bc84 <cos_defcompinfo_child_alloc+0x124>
	ret = cos_aep_alloc_intern(child_aep, child_defci, 0, is_sched ? sched_aep : NULL, NULL, NULL, 0);
  40bbb2:	45 85 ed             	test   r13d,r13d
  40bbb5:	b8 00 00 00 00       	mov    eax,0x0
  40bbba:	41 bd 40 0a 5a 00    	mov    r13d,0x5a0a40
  40bbc0:	4c 0f 44 e8          	cmove  r13,rax
	assert(curr_defci_init_status == INITIALIZED);
  40bbc4:	83 3d a5 4e 19 00 01 	cmp    DWORD PTR [rip+0x194ea5],0x1        # 5a0a70 <curr_defci_init_status>
  40bbcb:	0f 85 f9 00 00 00    	jne    40bcca <cos_defcompinfo_child_alloc+0x16a>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40bbd1:	66 0f ef c0          	pxor   xmm0,xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40bbd5:	48 8b 73 10          	mov    rsi,QWORD PTR [rbx+0x10]
  40bbd9:	bf 60 09 5a 00       	mov    edi,0x5a0960
	memset(aep, 0, sizeof(struct cos_aep_info));
  40bbde:	0f 11 83 e0 00 00 00 	movups XMMWORD PTR [rbx+0xe0],xmm0
  40bbe5:	0f 11 83 f0 00 00 00 	movups XMMWORD PTR [rbx+0xf0],xmm0
  40bbec:	0f 11 83 00 01 00 00 	movups XMMWORD PTR [rbx+0x100],xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40bbf3:	e8 d8 3b 00 00       	call   40f7d0 <cos_initthd_alloc>
  40bbf8:	48 89 83 e8 00 00 00 	mov    QWORD PTR [rbx+0xe8],rax
  40bbff:	48 89 c6             	mov    rsi,rax
	assert(aep->thd);
  40bc02:	48 85 c0             	test   rax,rax
  40bc05:	0f 84 db 00 00 00    	je     40bce6 <cos_defcompinfo_child_alloc+0x186>
	aep->tid  = cos_introspect(ci, aep->thd, THD_GET_TID);
  40bc0b:	31 d2                	xor    edx,edx
  40bc0d:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40bc12:	e8 29 5f 00 00       	call   411b40 <cos_introspect>
  40bc17:	48 98                	cdqe   
  40bc19:	48 89 83 f0 00 00 00 	mov    QWORD PTR [rbx+0xf0],rax
	if (!sched && is_init) return 0;
  40bc20:	4d 85 ed             	test   r13,r13
  40bc23:	74 5f                	je     40bc84 <cos_defcompinfo_child_alloc+0x124>
		aep->tc = cos_tcap_alloc(ci);
  40bc25:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40bc2a:	e8 71 5f 00 00       	call   411ba0 <cos_tcap_alloc>
  40bc2f:	48 89 83 e0 00 00 00 	mov    QWORD PTR [rbx+0xe0],rax
  40bc36:	48 89 c2             	mov    rdx,rax
		assert(aep->tc);
  40bc39:	48 85 c0             	test   rax,rax
  40bc3c:	0f 84 c0 00 00 00    	je     40bd02 <cos_defcompinfo_child_alloc+0x1a2>
	aep->rcv  = cos_arcv_alloc(ci, aep->thd, aep->tc, ci->comp_cap, sched->rcv);
  40bc42:	48 8b b3 e8 00 00 00 	mov    rsi,QWORD PTR [rbx+0xe8]
  40bc49:	4d 8b 45 18          	mov    r8,QWORD PTR [r13+0x18]
  40bc4d:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40bc52:	48 8b 0d 17 4d 19 00 	mov    rcx,QWORD PTR [rip+0x194d17]        # 5a0970 <curr_defci+0x10>
  40bc59:	e8 52 4e 00 00       	call   410ab0 <cos_arcv_alloc>
  40bc5e:	48 89 83 f8 00 00 00 	mov    QWORD PTR [rbx+0xf8],rax
	assert(aep->rcv);
  40bc65:	48 85 c0             	test   rax,rax
  40bc68:	0f 84 b0 00 00 00    	je     40bd1e <cos_defcompinfo_child_alloc+0x1be>
	aep->fn   = fn;
  40bc6e:	48 c7 83 00 01 00 00 	mov    QWORD PTR [rbx+0x100],0x0
  40bc75:	00 00 00 00 
	aep->data = data;
  40bc79:	48 c7 83 08 01 00 00 	mov    QWORD PTR [rbx+0x108],0x0
  40bc80:	00 00 00 00 

	return ret;
}
  40bc84:	48 83 c4 08          	add    rsp,0x8
  40bc88:	44 89 e0             	mov    eax,r12d
  40bc8b:	5b                   	pop    rbx
  40bc8c:	41 5c                	pop    r12
  40bc8e:	41 5d                	pop    r13
  40bc90:	5d                   	pop    rbp
  40bc91:	c3                   	ret    
  40bc92:	be 30 00 00 00       	mov    esi,0x30
  40bc97:	bf 58 d3 41 00       	mov    edi,0x41d358
  40bc9c:	e8 2f e4 ff ff       	call   40a0d0 <cos_print_str>
	assert(defci);
  40bca1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40bca8:	00 00 00 00 
  40bcac:	0f 0b                	ud2    
  40bcae:	be 31 00 00 00       	mov    esi,0x31
  40bcb3:	bf 78 d4 41 00       	mov    edi,0x41d478
  40bcb8:	e8 13 e4 ff ff       	call   40a0d0 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40bcbd:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40bcc4:	00 00 00 00 
  40bcc8:	0f 0b                	ud2    
  40bcca:	be 31 00 00 00       	mov    esi,0x31
  40bccf:	bf b0 d4 41 00       	mov    edi,0x41d4b0
  40bcd4:	e8 f7 e3 ff ff       	call   40a0d0 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40bcd9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40bce0:	00 00 00 00 
  40bce4:	0f 0b                	ud2    
  40bce6:	be 31 00 00 00       	mov    esi,0x31
  40bceb:	bf e8 d4 41 00       	mov    edi,0x41d4e8
  40bcf0:	e8 db e3 ff ff       	call   40a0d0 <cos_print_str>
	assert(aep->thd);
  40bcf5:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40bcfc:	00 00 00 00 
  40bd00:	0f 0b                	ud2    
  40bd02:	be 31 00 00 00       	mov    esi,0x31
  40bd07:	bf 20 d5 41 00       	mov    edi,0x41d520
  40bd0c:	e8 bf e3 ff ff       	call   40a0d0 <cos_print_str>
		assert(aep->tc);
  40bd11:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40bd18:	00 00 00 00 
  40bd1c:	0f 0b                	ud2    
  40bd1e:	be 31 00 00 00       	mov    esi,0x31
  40bd23:	bf 58 d5 41 00       	mov    edi,0x41d558
  40bd28:	e8 a3 e3 ff ff       	call   40a0d0 <cos_print_str>
	assert(aep->rcv);
  40bd2d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40bd34:	00 00 00 00 
  40bd38:	0f 0b                	ud2    
  40bd3a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000040bd40 <cos_defcompinfo_childid_init>:

void
cos_defcompinfo_childid_init(struct cos_defcompinfo *child_defci, spdid_t c)
{
  40bd40:	f3 0f 1e fa          	endbr64 
	assert(child_defci != cos_defcompinfo_curr_get());
  40bd44:	48 81 ff 60 09 5a 00 	cmp    rdi,0x5a0960
  40bd4b:	74 04                	je     40bd51 <cos_defcompinfo_childid_init+0x11>

	child_defci->id = c;
  40bd4d:	66 89 37             	mov    WORD PTR [rdi],si
  40bd50:	c3                   	ret    
{
  40bd51:	55                   	push   rbp
  40bd52:	be 31 00 00 00       	mov    esi,0x31
  40bd57:	bf 90 d5 41 00       	mov    edi,0x41d590
  40bd5c:	48 89 e5             	mov    rbp,rsp
  40bd5f:	e8 6c e3 ff ff       	call   40a0d0 <cos_print_str>
	assert(child_defci != cos_defcompinfo_curr_get());
  40bd64:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40bd6b:	00 00 00 00 
  40bd6f:	0f 0b                	ud2    
  40bd71:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40bd78:	00 00 00 00 
  40bd7c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000040bd80 <cos_initaep_alloc>:
}

int
cos_initaep_alloc(struct cos_defcompinfo *dst_dci, struct cos_aep_info *sched, int is_sched)
{
  40bd80:	f3 0f 1e fa          	endbr64 
  40bd84:	55                   	push   rbp
  40bd85:	48 89 e5             	mov    rbp,rsp
  40bd88:	41 54                	push   r12
  40bd8a:	53                   	push   rbx
	assert(defci);
  40bd8b:	48 85 ff             	test   rdi,rdi
  40bd8e:	0f 84 f0 00 00 00    	je     40be84 <cos_initaep_alloc+0x104>
  40bd94:	48 89 fb             	mov    rbx,rdi
	return &(defci->sched_aep[cos_cpuid()]);
  40bd97:	48 8d 87 e0 00 00 00 	lea    rax,[rdi+0xe0]
	struct cos_defcompinfo *defci     = cos_defcompinfo_curr_get();
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);
	struct cos_aep_info    *child_aep = cos_sched_aep_get(dst_dci);
	struct cos_aep_info    *sched_use = is_sched ? (sched ? sched : sched_aep) : NULL;
  40bd9e:	45 31 e4             	xor    r12d,r12d
  40bda1:	85 d2                	test   edx,edx
  40bda3:	0f 85 c7 00 00 00    	jne    40be70 <cos_initaep_alloc+0xf0>
	assert(curr_defci_init_status == INITIALIZED);
  40bda9:	83 3d c0 4c 19 00 01 	cmp    DWORD PTR [rip+0x194cc0],0x1        # 5a0a70 <curr_defci_init_status>
  40bdb0:	0f 85 ea 00 00 00    	jne    40bea0 <cos_initaep_alloc+0x120>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40bdb6:	66 0f ef c0          	pxor   xmm0,xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40bdba:	bf 60 09 5a 00       	mov    edi,0x5a0960
	memset(aep, 0, sizeof(struct cos_aep_info));
  40bdbf:	0f 11 83 e0 00 00 00 	movups XMMWORD PTR [rbx+0xe0],xmm0
  40bdc6:	0f 11 40 10          	movups XMMWORD PTR [rax+0x10],xmm0
  40bdca:	0f 11 40 20          	movups XMMWORD PTR [rax+0x20],xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40bdce:	48 8b 73 10          	mov    rsi,QWORD PTR [rbx+0x10]
  40bdd2:	e8 f9 39 00 00       	call   40f7d0 <cos_initthd_alloc>
  40bdd7:	48 89 83 e8 00 00 00 	mov    QWORD PTR [rbx+0xe8],rax
  40bdde:	48 89 c6             	mov    rsi,rax
	assert(aep->thd);
  40bde1:	48 85 c0             	test   rax,rax
  40bde4:	0f 84 d2 00 00 00    	je     40bebc <cos_initaep_alloc+0x13c>
	aep->tid  = cos_introspect(ci, aep->thd, THD_GET_TID);
  40bdea:	31 d2                	xor    edx,edx
  40bdec:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40bdf1:	e8 4a 5d 00 00       	call   411b40 <cos_introspect>
  40bdf6:	48 98                	cdqe   
  40bdf8:	48 89 83 f0 00 00 00 	mov    QWORD PTR [rbx+0xf0],rax
	if (!sched && is_init) return 0;
  40bdff:	4d 85 e4             	test   r12,r12
  40be02:	74 60                	je     40be64 <cos_initaep_alloc+0xe4>
		aep->tc = cos_tcap_alloc(ci);
  40be04:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40be09:	e8 92 5d 00 00       	call   411ba0 <cos_tcap_alloc>
  40be0e:	48 89 83 e0 00 00 00 	mov    QWORD PTR [rbx+0xe0],rax
  40be15:	48 89 c2             	mov    rdx,rax
		assert(aep->tc);
  40be18:	48 85 c0             	test   rax,rax
  40be1b:	0f 84 b7 00 00 00    	je     40bed8 <cos_initaep_alloc+0x158>
	aep->rcv  = cos_arcv_alloc(ci, aep->thd, aep->tc, ci->comp_cap, sched->rcv);
  40be21:	48 8b b3 e8 00 00 00 	mov    rsi,QWORD PTR [rbx+0xe8]
  40be28:	4d 8b 44 24 18       	mov    r8,QWORD PTR [r12+0x18]
  40be2d:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40be32:	48 8b 0d 37 4b 19 00 	mov    rcx,QWORD PTR [rip+0x194b37]        # 5a0970 <curr_defci+0x10>
  40be39:	e8 72 4c 00 00       	call   410ab0 <cos_arcv_alloc>
  40be3e:	48 89 83 f8 00 00 00 	mov    QWORD PTR [rbx+0xf8],rax
	assert(aep->rcv);
  40be45:	48 85 c0             	test   rax,rax
  40be48:	0f 84 a6 00 00 00    	je     40bef4 <cos_initaep_alloc+0x174>
	aep->fn   = fn;
  40be4e:	48 c7 83 00 01 00 00 	mov    QWORD PTR [rbx+0x100],0x0
  40be55:	00 00 00 00 
	aep->data = data;
  40be59:	48 c7 83 08 01 00 00 	mov    QWORD PTR [rbx+0x108],0x0
  40be60:	00 00 00 00 

	return cos_aep_alloc_intern(child_aep, dst_dci, 0, sched_use, NULL, NULL, 0);
}
  40be64:	5b                   	pop    rbx
  40be65:	31 c0                	xor    eax,eax
  40be67:	41 5c                	pop    r12
  40be69:	5d                   	pop    rbp
  40be6a:	c3                   	ret    
  40be6b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40be70:	49 89 f4             	mov    r12,rsi
	struct cos_aep_info    *sched_use = is_sched ? (sched ? sched : sched_aep) : NULL;
  40be73:	48 85 f6             	test   rsi,rsi
  40be76:	ba 40 0a 5a 00       	mov    edx,0x5a0a40
  40be7b:	4c 0f 44 e2          	cmove  r12,rdx
  40be7f:	e9 25 ff ff ff       	jmp    40bda9 <cos_initaep_alloc+0x29>
  40be84:	be 30 00 00 00       	mov    esi,0x30
  40be89:	bf 90 d3 41 00       	mov    edi,0x41d390
  40be8e:	e8 3d e2 ff ff       	call   40a0d0 <cos_print_str>
	assert(defci);
  40be93:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40be9a:	00 00 00 00 
  40be9e:	0f 0b                	ud2    
  40bea0:	be 31 00 00 00       	mov    esi,0x31
  40bea5:	bf b0 d4 41 00       	mov    edi,0x41d4b0
  40beaa:	e8 21 e2 ff ff       	call   40a0d0 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40beaf:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40beb6:	00 00 00 00 
  40beba:	0f 0b                	ud2    
  40bebc:	be 31 00 00 00       	mov    esi,0x31
  40bec1:	bf e8 d4 41 00       	mov    edi,0x41d4e8
  40bec6:	e8 05 e2 ff ff       	call   40a0d0 <cos_print_str>
	assert(aep->thd);
  40becb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40bed2:	00 00 00 00 
  40bed6:	0f 0b                	ud2    
  40bed8:	be 31 00 00 00       	mov    esi,0x31
  40bedd:	bf 20 d5 41 00       	mov    edi,0x41d520
  40bee2:	e8 e9 e1 ff ff       	call   40a0d0 <cos_print_str>
		assert(aep->tc);
  40bee7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40beee:	00 00 00 00 
  40bef2:	0f 0b                	ud2    
  40bef4:	be 31 00 00 00       	mov    esi,0x31
  40bef9:	bf 58 d5 41 00       	mov    edi,0x41d558
  40befe:	e8 cd e1 ff ff       	call   40a0d0 <cos_print_str>
	assert(aep->rcv);
  40bf03:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40bf0a:	00 00 00 00 
  40bf0e:	0f 0b                	ud2    

000000000040bf10 <cos_initaep_tcap_alloc>:

int
cos_initaep_tcap_alloc(struct cos_defcompinfo *dst_dci, tcap_t tc, struct cos_aep_info *sched)
{
  40bf10:	f3 0f 1e fa          	endbr64 
  40bf14:	55                   	push   rbp
  40bf15:	48 89 e5             	mov    rbp,rsp
  40bf18:	41 55                	push   r13
  40bf1a:	41 54                	push   r12
  40bf1c:	53                   	push   rbx
  40bf1d:	48 83 ec 08          	sub    rsp,0x8
	assert(defci);
  40bf21:	48 85 ff             	test   rdi,rdi
  40bf24:	0f 84 0b 01 00 00    	je     40c035 <cos_initaep_tcap_alloc+0x125>
	struct cos_defcompinfo *defci     = cos_defcompinfo_curr_get();
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);
	struct cos_aep_info    *child_aep = cos_sched_aep_get(dst_dci);
	struct cos_aep_info    *sched_use = sched ? sched : sched_aep;
  40bf2a:	48 85 d2             	test   rdx,rdx
  40bf2d:	49 89 d4             	mov    r12,rdx
  40bf30:	ba 40 0a 5a 00       	mov    edx,0x5a0a40
  40bf35:	48 89 fb             	mov    rbx,rdi
  40bf38:	4c 0f 44 e2          	cmove  r12,rdx
	assert(curr_defci_init_status == INITIALIZED);
  40bf3c:	83 3d 2d 4b 19 00 01 	cmp    DWORD PTR [rip+0x194b2d],0x1        # 5a0a70 <curr_defci_init_status>
	return &(defci->sched_aep[cos_cpuid()]);
  40bf43:	48 8d 87 e0 00 00 00 	lea    rax,[rdi+0xe0]
	assert(curr_defci_init_status == INITIALIZED);
  40bf4a:	0f 85 01 01 00 00    	jne    40c051 <cos_initaep_tcap_alloc+0x141>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40bf50:	66 0f ef c0          	pxor   xmm0,xmm0
  40bf54:	49 89 f5             	mov    r13,rsi
  40bf57:	0f 11 87 e0 00 00 00 	movups XMMWORD PTR [rdi+0xe0],xmm0
  40bf5e:	0f 11 40 10          	movups XMMWORD PTR [rax+0x10],xmm0
  40bf62:	0f 11 40 20          	movups XMMWORD PTR [rax+0x20],xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40bf66:	48 8b 77 10          	mov    rsi,QWORD PTR [rdi+0x10]
  40bf6a:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40bf6f:	e8 5c 38 00 00       	call   40f7d0 <cos_initthd_alloc>
  40bf74:	48 89 83 e8 00 00 00 	mov    QWORD PTR [rbx+0xe8],rax
  40bf7b:	48 89 c6             	mov    rsi,rax
	assert(aep->thd);
  40bf7e:	48 85 c0             	test   rax,rax
  40bf81:	0f 84 e6 00 00 00    	je     40c06d <cos_initaep_tcap_alloc+0x15d>
	aep->tid  = cos_introspect(ci, aep->thd, THD_GET_TID);
  40bf87:	31 d2                	xor    edx,edx
  40bf89:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40bf8e:	e8 ad 5b 00 00       	call   411b40 <cos_introspect>
  40bf93:	48 98                	cdqe   
  40bf95:	48 89 83 f0 00 00 00 	mov    QWORD PTR [rbx+0xf0],rax
	if (tc) {
  40bf9c:	4d 85 ed             	test   r13,r13
  40bf9f:	74 5f                	je     40c000 <cos_initaep_tcap_alloc+0xf0>
		aep->tc = tc;
  40bfa1:	4c 89 ab e0 00 00 00 	mov    QWORD PTR [rbx+0xe0],r13
	aep->rcv  = cos_arcv_alloc(ci, aep->thd, aep->tc, ci->comp_cap, sched->rcv);
  40bfa8:	48 8b b3 e8 00 00 00 	mov    rsi,QWORD PTR [rbx+0xe8]
  40bfaf:	4d 8b 44 24 18       	mov    r8,QWORD PTR [r12+0x18]
  40bfb4:	4c 89 ea             	mov    rdx,r13
  40bfb7:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40bfbc:	48 8b 0d ad 49 19 00 	mov    rcx,QWORD PTR [rip+0x1949ad]        # 5a0970 <curr_defci+0x10>
  40bfc3:	e8 e8 4a 00 00       	call   410ab0 <cos_arcv_alloc>
  40bfc8:	48 89 83 f8 00 00 00 	mov    QWORD PTR [rbx+0xf8],rax
	assert(aep->rcv);
  40bfcf:	48 85 c0             	test   rax,rax
  40bfd2:	0f 84 b1 00 00 00    	je     40c089 <cos_initaep_tcap_alloc+0x179>
	aep->fn   = fn;
  40bfd8:	48 c7 83 00 01 00 00 	mov    QWORD PTR [rbx+0x100],0x0
  40bfdf:	00 00 00 00 

	return cos_aep_alloc_intern(child_aep, dst_dci, tc, sched_use, NULL, NULL, 0);
}
  40bfe3:	31 c0                	xor    eax,eax
	aep->data = data;
  40bfe5:	48 c7 83 08 01 00 00 	mov    QWORD PTR [rbx+0x108],0x0
  40bfec:	00 00 00 00 
}
  40bff0:	48 83 c4 08          	add    rsp,0x8
  40bff4:	5b                   	pop    rbx
  40bff5:	41 5c                	pop    r12
  40bff7:	41 5d                	pop    r13
  40bff9:	5d                   	pop    rbp
  40bffa:	c3                   	ret    
  40bffb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		aep->tc = cos_tcap_alloc(ci);
  40c000:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40c005:	e8 96 5b 00 00       	call   411ba0 <cos_tcap_alloc>
  40c00a:	48 89 83 e0 00 00 00 	mov    QWORD PTR [rbx+0xe0],rax
  40c011:	49 89 c5             	mov    r13,rax
		assert(aep->tc);
  40c014:	48 85 c0             	test   rax,rax
  40c017:	75 8f                	jne    40bfa8 <cos_initaep_tcap_alloc+0x98>
  40c019:	be 31 00 00 00       	mov    esi,0x31
  40c01e:	bf 20 d5 41 00       	mov    edi,0x41d520
  40c023:	e8 a8 e0 ff ff       	call   40a0d0 <cos_print_str>
  40c028:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c02f:	00 00 00 00 
  40c033:	0f 0b                	ud2    
  40c035:	be 30 00 00 00       	mov    esi,0x30
  40c03a:	bf 90 d3 41 00       	mov    edi,0x41d390
  40c03f:	e8 8c e0 ff ff       	call   40a0d0 <cos_print_str>
	assert(defci);
  40c044:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c04b:	00 00 00 00 
  40c04f:	0f 0b                	ud2    
  40c051:	be 31 00 00 00       	mov    esi,0x31
  40c056:	bf b0 d4 41 00       	mov    edi,0x41d4b0
  40c05b:	e8 70 e0 ff ff       	call   40a0d0 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40c060:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c067:	00 00 00 00 
  40c06b:	0f 0b                	ud2    
  40c06d:	be 31 00 00 00       	mov    esi,0x31
  40c072:	bf e8 d4 41 00       	mov    edi,0x41d4e8
  40c077:	e8 54 e0 ff ff       	call   40a0d0 <cos_print_str>
	assert(aep->thd);
  40c07c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c083:	00 00 00 00 
  40c087:	0f 0b                	ud2    
  40c089:	be 31 00 00 00       	mov    esi,0x31
  40c08e:	bf 58 d5 41 00       	mov    edi,0x41d558
  40c093:	e8 38 e0 ff ff       	call   40a0d0 <cos_print_str>
	assert(aep->rcv);
  40c098:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c09f:	00 00 00 00 
  40c0a3:	0f 0b                	ud2    
  40c0a5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40c0ac:	00 00 00 00 

000000000040c0b0 <cos_aep_alloc_ext>:

int
cos_aep_alloc_ext(struct cos_aep_info *aep, struct cos_defcompinfo *dst_dci, struct cos_aep_info *sched, thdclosure_index_t idx)
{
  40c0b0:	f3 0f 1e fa          	endbr64 
  40c0b4:	55                   	push   rbp
  40c0b5:	48 89 e5             	mov    rbp,rsp
  40c0b8:	41 54                	push   r12
  40c0ba:	53                   	push   rbx
	struct cos_defcompinfo *defci     = cos_defcompinfo_curr_get();
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);

	assert(aep && idx > 0);
  40c0bb:	48 85 ff             	test   rdi,rdi
  40c0be:	0f 84 ef 00 00 00    	je     40c1b3 <cos_aep_alloc_ext+0x103>
  40c0c4:	49 89 d4             	mov    r12,rdx
  40c0c7:	89 ca                	mov    edx,ecx
  40c0c9:	85 c9                	test   ecx,ecx
  40c0cb:	0f 8e e2 00 00 00    	jle    40c1b3 <cos_aep_alloc_ext+0x103>
  40c0d1:	48 89 fb             	mov    rbx,rdi
	if (!sched) sched_aep = cos_sched_aep_get(dst_dci);
  40c0d4:	4d 85 e4             	test   r12,r12
  40c0d7:	74 27                	je     40c100 <cos_aep_alloc_ext+0x50>
	assert(defci);
  40c0d9:	48 85 f6             	test   rsi,rsi
  40c0dc:	75 32                	jne    40c110 <cos_aep_alloc_ext+0x60>
  40c0de:	be 30 00 00 00       	mov    esi,0x30
  40c0e3:	bf 58 d3 41 00       	mov    edi,0x41d358
  40c0e8:	e8 e3 df ff ff       	call   40a0d0 <cos_print_str>
  40c0ed:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c0f4:	00 00 00 00 
  40c0f8:	0f 0b                	ud2    
  40c0fa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	return &(defci->sched_aep[cos_cpuid()]);
  40c100:	4c 8d a6 e0 00 00 00 	lea    r12,[rsi+0xe0]
	assert(defci);
  40c107:	48 85 f6             	test   rsi,rsi
  40c10a:	0f 84 18 01 00 00    	je     40c228 <cos_aep_alloc_ext+0x178>
	assert(curr_defci_init_status == INITIALIZED);
  40c110:	83 3d 59 49 19 00 01 	cmp    DWORD PTR [rip+0x194959],0x1        # 5a0a70 <curr_defci_init_status>
  40c117:	0f 85 b3 00 00 00    	jne    40c1d0 <cos_aep_alloc_ext+0x120>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c11d:	66 0f ef c0          	pxor   xmm0,xmm0
	else if (idx > 0) aep->thd = cos_thd_alloc_ext(ci, dst_ci->comp_cap, idx);
  40c121:	bf 60 09 5a 00       	mov    edi,0x5a0960
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c126:	0f 11 03             	movups XMMWORD PTR [rbx],xmm0
  40c129:	0f 11 43 10          	movups XMMWORD PTR [rbx+0x10],xmm0
  40c12d:	0f 11 43 20          	movups XMMWORD PTR [rbx+0x20],xmm0
	else if (idx > 0) aep->thd = cos_thd_alloc_ext(ci, dst_ci->comp_cap, idx);
  40c131:	48 8b 76 10          	mov    rsi,QWORD PTR [rsi+0x10]
  40c135:	e8 b6 29 00 00       	call   40eaf0 <cos_thd_alloc_ext>
  40c13a:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  40c13e:	48 89 c6             	mov    rsi,rax
	assert(aep->thd);
  40c141:	48 85 c0             	test   rax,rax
  40c144:	0f 84 a6 00 00 00    	je     40c1f0 <cos_aep_alloc_ext+0x140>
	aep->tid  = cos_introspect(ci, aep->thd, THD_GET_TID);
  40c14a:	31 d2                	xor    edx,edx
  40c14c:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40c151:	e8 ea 59 00 00       	call   411b40 <cos_introspect>
		aep->tc = cos_tcap_alloc(ci);
  40c156:	bf 60 09 5a 00       	mov    edi,0x5a0960
	aep->tid  = cos_introspect(ci, aep->thd, THD_GET_TID);
  40c15b:	48 98                	cdqe   
  40c15d:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
		aep->tc = cos_tcap_alloc(ci);
  40c161:	e8 3a 5a 00 00       	call   411ba0 <cos_tcap_alloc>
  40c166:	48 89 03             	mov    QWORD PTR [rbx],rax
  40c169:	48 89 c2             	mov    rdx,rax
		assert(aep->tc);
  40c16c:	48 85 c0             	test   rax,rax
  40c16f:	0f 84 97 00 00 00    	je     40c20c <cos_aep_alloc_ext+0x15c>
	aep->rcv  = cos_arcv_alloc(ci, aep->thd, aep->tc, ci->comp_cap, sched->rcv);
  40c175:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
  40c179:	4d 8b 44 24 18       	mov    r8,QWORD PTR [r12+0x18]
  40c17e:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40c183:	48 8b 0d e6 47 19 00 	mov    rcx,QWORD PTR [rip+0x1947e6]        # 5a0970 <curr_defci+0x10>
  40c18a:	e8 21 49 00 00       	call   410ab0 <cos_arcv_alloc>
  40c18f:	48 89 43 18          	mov    QWORD PTR [rbx+0x18],rax
	assert(aep->rcv);
  40c193:	48 85 c0             	test   rax,rax
  40c196:	0f 84 a8 00 00 00    	je     40c244 <cos_aep_alloc_ext+0x194>
	aep->fn   = fn;
  40c19c:	48 c7 43 20 00 00 00 	mov    QWORD PTR [rbx+0x20],0x0
  40c1a3:	00 
	else        sched_aep = sched;

	return cos_aep_alloc_intern(aep, dst_dci, 0, sched_aep, NULL, NULL, idx);
}
  40c1a4:	31 c0                	xor    eax,eax
	aep->data = data;
  40c1a6:	48 c7 43 28 00 00 00 	mov    QWORD PTR [rbx+0x28],0x0
  40c1ad:	00 
}
  40c1ae:	5b                   	pop    rbx
  40c1af:	41 5c                	pop    r12
  40c1b1:	5d                   	pop    rbp
  40c1b2:	c3                   	ret    
  40c1b3:	be 31 00 00 00       	mov    esi,0x31
  40c1b8:	bf c8 d5 41 00       	mov    edi,0x41d5c8
  40c1bd:	e8 0e df ff ff       	call   40a0d0 <cos_print_str>
	assert(aep && idx > 0);
  40c1c2:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c1c9:	00 00 00 00 
  40c1cd:	0f 0b                	ud2    
  40c1cf:	90                   	nop
  40c1d0:	be 31 00 00 00       	mov    esi,0x31
  40c1d5:	bf b0 d4 41 00       	mov    edi,0x41d4b0
  40c1da:	e8 f1 de ff ff       	call   40a0d0 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40c1df:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c1e6:	00 00 00 00 
  40c1ea:	0f 0b                	ud2    
  40c1ec:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  40c1f0:	be 31 00 00 00       	mov    esi,0x31
  40c1f5:	bf e8 d4 41 00       	mov    edi,0x41d4e8
  40c1fa:	e8 d1 de ff ff       	call   40a0d0 <cos_print_str>
	assert(aep->thd);
  40c1ff:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c206:	00 00 00 00 
  40c20a:	0f 0b                	ud2    
  40c20c:	be 31 00 00 00       	mov    esi,0x31
  40c211:	bf 20 d5 41 00       	mov    edi,0x41d520
  40c216:	e8 b5 de ff ff       	call   40a0d0 <cos_print_str>
		assert(aep->tc);
  40c21b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c222:	00 00 00 00 
  40c226:	0f 0b                	ud2    
  40c228:	be 30 00 00 00       	mov    esi,0x30
  40c22d:	bf 90 d3 41 00       	mov    edi,0x41d390
  40c232:	e8 99 de ff ff       	call   40a0d0 <cos_print_str>
	assert(defci);
  40c237:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c23e:	00 00 00 00 
  40c242:	0f 0b                	ud2    
  40c244:	be 31 00 00 00       	mov    esi,0x31
  40c249:	bf 58 d5 41 00       	mov    edi,0x41d558
  40c24e:	e8 7d de ff ff       	call   40a0d0 <cos_print_str>
	assert(aep->rcv);
  40c253:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c25a:	00 00 00 00 
  40c25e:	0f 0b                	ud2    

000000000040c260 <cos_aep_tcap_alloc_ext>:

int
cos_aep_tcap_alloc_ext(struct cos_aep_info *aep, struct cos_defcompinfo *dst_dci, struct cos_aep_info *sched, tcap_t tc, thdclosure_index_t idx)
{
  40c260:	f3 0f 1e fa          	endbr64 
  40c264:	55                   	push   rbp
  40c265:	48 89 e5             	mov    rbp,rsp
  40c268:	41 55                	push   r13
  40c26a:	41 54                	push   r12
  40c26c:	53                   	push   rbx
  40c26d:	48 83 ec 08          	sub    rsp,0x8
	struct cos_defcompinfo *defci     = cos_defcompinfo_curr_get();
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);

	assert(aep);
  40c271:	48 85 ff             	test   rdi,rdi
  40c274:	0f 84 2b 01 00 00    	je     40c3a5 <cos_aep_tcap_alloc_ext+0x145>
	assert(idx > 0);
  40c27a:	45 85 c0             	test   r8d,r8d
  40c27d:	0f 8e 3e 01 00 00    	jle    40c3c1 <cos_aep_tcap_alloc_ext+0x161>
  40c283:	48 89 fb             	mov    rbx,rdi
  40c286:	49 89 d5             	mov    r13,rdx
  40c289:	49 89 cc             	mov    r12,rcx
	if (!sched) sched_aep = cos_sched_aep_get(dst_dci);
  40c28c:	48 85 d2             	test   rdx,rdx
  40c28f:	0f 84 ab 00 00 00    	je     40c340 <cos_aep_tcap_alloc_ext+0xe0>
	assert(defci);
  40c295:	48 85 f6             	test   rsi,rsi
  40c298:	0f 84 3f 01 00 00    	je     40c3dd <cos_aep_tcap_alloc_ext+0x17d>
	assert(curr_defci_init_status == INITIALIZED);
  40c29e:	83 3d cb 47 19 00 01 	cmp    DWORD PTR [rip+0x1947cb],0x1        # 5a0a70 <curr_defci_init_status>
  40c2a5:	0f 85 4e 01 00 00    	jne    40c3f9 <cos_aep_tcap_alloc_ext+0x199>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c2ab:	66 0f ef c0          	pxor   xmm0,xmm0
	else if (idx > 0) aep->thd = cos_thd_alloc_ext(ci, dst_ci->comp_cap, idx);
  40c2af:	44 89 c2             	mov    edx,r8d
  40c2b2:	bf 60 09 5a 00       	mov    edi,0x5a0960
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c2b7:	0f 11 03             	movups XMMWORD PTR [rbx],xmm0
  40c2ba:	0f 11 43 10          	movups XMMWORD PTR [rbx+0x10],xmm0
  40c2be:	0f 11 43 20          	movups XMMWORD PTR [rbx+0x20],xmm0
	else if (idx > 0) aep->thd = cos_thd_alloc_ext(ci, dst_ci->comp_cap, idx);
  40c2c2:	48 8b 76 10          	mov    rsi,QWORD PTR [rsi+0x10]
  40c2c6:	e8 25 28 00 00       	call   40eaf0 <cos_thd_alloc_ext>
  40c2cb:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  40c2cf:	48 89 c6             	mov    rsi,rax
	assert(aep->thd);
  40c2d2:	48 85 c0             	test   rax,rax
  40c2d5:	0f 84 3a 01 00 00    	je     40c415 <cos_aep_tcap_alloc_ext+0x1b5>
	aep->tid  = cos_introspect(ci, aep->thd, THD_GET_TID);
  40c2db:	31 d2                	xor    edx,edx
  40c2dd:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40c2e2:	e8 59 58 00 00       	call   411b40 <cos_introspect>
  40c2e7:	48 98                	cdqe   
  40c2e9:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
	if (tc) {
  40c2ed:	4d 85 e4             	test   r12,r12
  40c2f0:	74 7e                	je     40c370 <cos_aep_tcap_alloc_ext+0x110>
		aep->tc = tc;
  40c2f2:	4c 89 23             	mov    QWORD PTR [rbx],r12
	aep->rcv  = cos_arcv_alloc(ci, aep->thd, aep->tc, ci->comp_cap, sched->rcv);
  40c2f5:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
  40c2f9:	4d 8b 45 18          	mov    r8,QWORD PTR [r13+0x18]
  40c2fd:	4c 89 e2             	mov    rdx,r12
  40c300:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40c305:	48 8b 0d 64 46 19 00 	mov    rcx,QWORD PTR [rip+0x194664]        # 5a0970 <curr_defci+0x10>
  40c30c:	e8 9f 47 00 00       	call   410ab0 <cos_arcv_alloc>
  40c311:	48 89 43 18          	mov    QWORD PTR [rbx+0x18],rax
	assert(aep->rcv);
  40c315:	48 85 c0             	test   rax,rax
  40c318:	0f 84 13 01 00 00    	je     40c431 <cos_aep_tcap_alloc_ext+0x1d1>
	aep->fn   = fn;
  40c31e:	48 c7 43 20 00 00 00 	mov    QWORD PTR [rbx+0x20],0x0
  40c325:	00 
	else        sched_aep = sched;

	return cos_aep_alloc_intern(aep, dst_dci, tc, sched_aep, NULL, NULL, idx);
}
  40c326:	31 c0                	xor    eax,eax
	aep->data = data;
  40c328:	48 c7 43 28 00 00 00 	mov    QWORD PTR [rbx+0x28],0x0
  40c32f:	00 
}
  40c330:	48 83 c4 08          	add    rsp,0x8
  40c334:	5b                   	pop    rbx
  40c335:	41 5c                	pop    r12
  40c337:	41 5d                	pop    r13
  40c339:	5d                   	pop    rbp
  40c33a:	c3                   	ret    
  40c33b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	return &(defci->sched_aep[cos_cpuid()]);
  40c340:	4c 8d ae e0 00 00 00 	lea    r13,[rsi+0xe0]
	assert(defci);
  40c347:	48 85 f6             	test   rsi,rsi
  40c34a:	0f 85 4e ff ff ff    	jne    40c29e <cos_aep_tcap_alloc_ext+0x3e>
  40c350:	be 30 00 00 00       	mov    esi,0x30
  40c355:	bf 90 d3 41 00       	mov    edi,0x41d390
  40c35a:	e8 71 dd ff ff       	call   40a0d0 <cos_print_str>
  40c35f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c366:	00 00 00 00 
  40c36a:	0f 0b                	ud2    
  40c36c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		aep->tc = cos_tcap_alloc(ci);
  40c370:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40c375:	e8 26 58 00 00       	call   411ba0 <cos_tcap_alloc>
  40c37a:	48 89 03             	mov    QWORD PTR [rbx],rax
  40c37d:	49 89 c4             	mov    r12,rax
		assert(aep->tc);
  40c380:	48 85 c0             	test   rax,rax
  40c383:	0f 85 6c ff ff ff    	jne    40c2f5 <cos_aep_tcap_alloc_ext+0x95>
  40c389:	be 31 00 00 00       	mov    esi,0x31
  40c38e:	bf 20 d5 41 00       	mov    edi,0x41d520
  40c393:	e8 38 dd ff ff       	call   40a0d0 <cos_print_str>
  40c398:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c39f:	00 00 00 00 
  40c3a3:	0f 0b                	ud2    
  40c3a5:	be 31 00 00 00       	mov    esi,0x31
  40c3aa:	bf 00 d6 41 00       	mov    edi,0x41d600
  40c3af:	e8 1c dd ff ff       	call   40a0d0 <cos_print_str>
	assert(aep);
  40c3b4:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c3bb:	00 00 00 00 
  40c3bf:	0f 0b                	ud2    
  40c3c1:	be 31 00 00 00       	mov    esi,0x31
  40c3c6:	bf 38 d6 41 00       	mov    edi,0x41d638
  40c3cb:	e8 00 dd ff ff       	call   40a0d0 <cos_print_str>
	assert(idx > 0);
  40c3d0:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c3d7:	00 00 00 00 
  40c3db:	0f 0b                	ud2    
  40c3dd:	be 30 00 00 00       	mov    esi,0x30
  40c3e2:	bf 58 d3 41 00       	mov    edi,0x41d358
  40c3e7:	e8 e4 dc ff ff       	call   40a0d0 <cos_print_str>
	assert(defci);
  40c3ec:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c3f3:	00 00 00 00 
  40c3f7:	0f 0b                	ud2    
  40c3f9:	be 31 00 00 00       	mov    esi,0x31
  40c3fe:	bf b0 d4 41 00       	mov    edi,0x41d4b0
  40c403:	e8 c8 dc ff ff       	call   40a0d0 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40c408:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c40f:	00 00 00 00 
  40c413:	0f 0b                	ud2    
  40c415:	be 31 00 00 00       	mov    esi,0x31
  40c41a:	bf e8 d4 41 00       	mov    edi,0x41d4e8
  40c41f:	e8 ac dc ff ff       	call   40a0d0 <cos_print_str>
	assert(aep->thd);
  40c424:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c42b:	00 00 00 00 
  40c42f:	0f 0b                	ud2    
  40c431:	be 31 00 00 00       	mov    esi,0x31
  40c436:	bf 58 d5 41 00       	mov    edi,0x41d558
  40c43b:	e8 90 dc ff ff       	call   40a0d0 <cos_print_str>
	assert(aep->rcv);
  40c440:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c447:	00 00 00 00 
  40c44b:	0f 0b                	ud2    
  40c44d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040c450 <cos_aep_alloc>:

int
cos_aep_alloc(struct cos_aep_info *aep, cos_aepthd_fn_t fn, void *data)
{
  40c450:	f3 0f 1e fa          	endbr64 
  40c454:	55                   	push   rbp
	int                     is_init = (!fn && !data && !idx);
  40c455:	48 89 d1             	mov    rcx,rdx
{
  40c458:	48 89 e5             	mov    rbp,rsp
  40c45b:	41 55                	push   r13
  40c45d:	49 89 d5             	mov    r13,rdx
  40c460:	41 54                	push   r12
  40c462:	49 89 f4             	mov    r12,rsi
  40c465:	53                   	push   rbx
  40c466:	48 89 fb             	mov    rbx,rdi
  40c469:	48 83 ec 08          	sub    rsp,0x8
	int                     is_init = (!fn && !data && !idx);
  40c46d:	48 09 f1             	or     rcx,rsi
	assert(curr_defci_init_status == INITIALIZED);
  40c470:	8b 05 fa 45 19 00    	mov    eax,DWORD PTR [rip+0x1945fa]        # 5a0a70 <curr_defci_init_status>
	int                     is_init = (!fn && !data && !idx);
  40c476:	0f 85 a4 00 00 00    	jne    40c520 <cos_aep_alloc+0xd0>
	assert(curr_defci_init_status == INITIALIZED);
  40c47c:	83 f8 01             	cmp    eax,0x1
  40c47f:	0f 85 d3 00 00 00    	jne    40c558 <cos_aep_alloc+0x108>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c485:	66 0f ef c0          	pxor   xmm0,xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40c489:	bf 60 09 5a 00       	mov    edi,0x5a0960
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c48e:	0f 11 03             	movups XMMWORD PTR [rbx],xmm0
  40c491:	0f 11 43 10          	movups XMMWORD PTR [rbx+0x10],xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40c495:	48 8b 35 d4 44 19 00 	mov    rsi,QWORD PTR [rip+0x1944d4]        # 5a0970 <curr_defci+0x10>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c49c:	0f 11 43 20          	movups XMMWORD PTR [rbx+0x20],xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40c4a0:	e8 2b 33 00 00       	call   40f7d0 <cos_initthd_alloc>
  40c4a5:	48 89 c6             	mov    rsi,rax
  40c4a8:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
	assert(aep->thd);
  40c4ac:	48 85 f6             	test   rsi,rsi
  40c4af:	0f 84 bf 00 00 00    	je     40c574 <cos_aep_alloc+0x124>
	aep->tid  = cos_introspect(ci, aep->thd, THD_GET_TID);
  40c4b5:	31 d2                	xor    edx,edx
  40c4b7:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40c4bc:	e8 7f 56 00 00       	call   411b40 <cos_introspect>
		aep->tc = cos_tcap_alloc(ci);
  40c4c1:	bf 60 09 5a 00       	mov    edi,0x5a0960
	aep->tid  = cos_introspect(ci, aep->thd, THD_GET_TID);
  40c4c6:	48 98                	cdqe   
  40c4c8:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
		aep->tc = cos_tcap_alloc(ci);
  40c4cc:	e8 cf 56 00 00       	call   411ba0 <cos_tcap_alloc>
  40c4d1:	48 89 03             	mov    QWORD PTR [rbx],rax
  40c4d4:	48 89 c2             	mov    rdx,rax
		assert(aep->tc);
  40c4d7:	48 85 c0             	test   rax,rax
  40c4da:	0f 84 b0 00 00 00    	je     40c590 <cos_aep_alloc+0x140>
	aep->rcv  = cos_arcv_alloc(ci, aep->thd, aep->tc, ci->comp_cap, sched->rcv);
  40c4e0:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
  40c4e4:	4c 8b 05 6d 45 19 00 	mov    r8,QWORD PTR [rip+0x19456d]        # 5a0a58 <curr_defci+0xf8>
  40c4eb:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40c4f0:	48 8b 0d 79 44 19 00 	mov    rcx,QWORD PTR [rip+0x194479]        # 5a0970 <curr_defci+0x10>
  40c4f7:	e8 b4 45 00 00       	call   410ab0 <cos_arcv_alloc>
  40c4fc:	48 89 43 18          	mov    QWORD PTR [rbx+0x18],rax
	assert(aep->rcv);
  40c500:	48 85 c0             	test   rax,rax
  40c503:	0f 84 a3 00 00 00    	je     40c5ac <cos_aep_alloc+0x15c>
	aep->fn   = fn;
  40c509:	4c 89 63 20          	mov    QWORD PTR [rbx+0x20],r12
	struct cos_defcompinfo *defci     = cos_defcompinfo_curr_get();
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);

	return cos_aep_alloc_intern(aep, defci, 0, sched_aep, fn, data, 0);
}
  40c50d:	31 c0                	xor    eax,eax
	aep->data = data;
  40c50f:	4c 89 6b 28          	mov    QWORD PTR [rbx+0x28],r13
}
  40c513:	48 83 c4 08          	add    rsp,0x8
  40c517:	5b                   	pop    rbx
  40c518:	41 5c                	pop    r12
  40c51a:	41 5d                	pop    r13
  40c51c:	5d                   	pop    rbp
  40c51d:	c3                   	ret    
  40c51e:	66 90                	xchg   ax,ax
	assert(curr_defci_init_status == INITIALIZED);
  40c520:	83 f8 01             	cmp    eax,0x1
  40c523:	75 33                	jne    40c558 <cos_aep_alloc+0x108>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c525:	66 0f ef c0          	pxor   xmm0,xmm0
	else              aep->thd = cos_thd_alloc(ci, dst_ci->comp_cap, cos_aepthd_fn, (void *)aep);
  40c529:	48 89 d9             	mov    rcx,rbx
  40c52c:	ba 20 b8 40 00       	mov    edx,0x40b820
  40c531:	bf 60 09 5a 00       	mov    edi,0x5a0960
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c536:	0f 11 03             	movups XMMWORD PTR [rbx],xmm0
  40c539:	0f 11 43 10          	movups XMMWORD PTR [rbx+0x10],xmm0
	else              aep->thd = cos_thd_alloc(ci, dst_ci->comp_cap, cos_aepthd_fn, (void *)aep);
  40c53d:	48 8b 35 2c 44 19 00 	mov    rsi,QWORD PTR [rip+0x19442c]        # 5a0970 <curr_defci+0x10>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c544:	0f 11 43 20          	movups XMMWORD PTR [rbx+0x20],xmm0
	else              aep->thd = cos_thd_alloc(ci, dst_ci->comp_cap, cos_aepthd_fn, (void *)aep);
  40c548:	e8 d3 25 00 00       	call   40eb20 <cos_thd_alloc>
  40c54d:	48 89 c6             	mov    rsi,rax
  40c550:	e9 53 ff ff ff       	jmp    40c4a8 <cos_aep_alloc+0x58>
  40c555:	0f 1f 00             	nop    DWORD PTR [rax]
  40c558:	be 31 00 00 00       	mov    esi,0x31
  40c55d:	bf b0 d4 41 00       	mov    edi,0x41d4b0
  40c562:	e8 69 db ff ff       	call   40a0d0 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40c567:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c56e:	00 00 00 00 
  40c572:	0f 0b                	ud2    
  40c574:	be 31 00 00 00       	mov    esi,0x31
  40c579:	bf e8 d4 41 00       	mov    edi,0x41d4e8
  40c57e:	e8 4d db ff ff       	call   40a0d0 <cos_print_str>
	assert(aep->thd);
  40c583:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c58a:	00 00 00 00 
  40c58e:	0f 0b                	ud2    
  40c590:	be 31 00 00 00       	mov    esi,0x31
  40c595:	bf 20 d5 41 00       	mov    edi,0x41d520
  40c59a:	e8 31 db ff ff       	call   40a0d0 <cos_print_str>
		assert(aep->tc);
  40c59f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c5a6:	00 00 00 00 
  40c5aa:	0f 0b                	ud2    
  40c5ac:	be 31 00 00 00       	mov    esi,0x31
  40c5b1:	bf 58 d5 41 00       	mov    edi,0x41d558
  40c5b6:	e8 15 db ff ff       	call   40a0d0 <cos_print_str>
	assert(aep->rcv);
  40c5bb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c5c2:	00 00 00 00 
  40c5c6:	0f 0b                	ud2    
  40c5c8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40c5cf:	00 

000000000040c5d0 <cos_aep_tcap_alloc>:

int
cos_aep_tcap_alloc(struct cos_aep_info *aep, tcap_t tc, cos_aepthd_fn_t fn, void *data)
{
  40c5d0:	f3 0f 1e fa          	endbr64 
  40c5d4:	55                   	push   rbp
	assert(curr_defci_init_status == INITIALIZED);
  40c5d5:	8b 05 95 44 19 00    	mov    eax,DWORD PTR [rip+0x194495]        # 5a0a70 <curr_defci_init_status>
{
  40c5db:	48 89 e5             	mov    rbp,rsp
  40c5de:	41 56                	push   r14
  40c5e0:	49 89 ce             	mov    r14,rcx
	int                     is_init = (!fn && !data && !idx);
  40c5e3:	48 09 d1             	or     rcx,rdx
{
  40c5e6:	41 55                	push   r13
  40c5e8:	49 89 d5             	mov    r13,rdx
  40c5eb:	41 54                	push   r12
  40c5ed:	49 89 f4             	mov    r12,rsi
  40c5f0:	53                   	push   rbx
  40c5f1:	48 89 fb             	mov    rbx,rdi
	int                     is_init = (!fn && !data && !idx);
  40c5f4:	0f 85 96 00 00 00    	jne    40c690 <cos_aep_tcap_alloc+0xc0>
	assert(curr_defci_init_status == INITIALIZED);
  40c5fa:	83 f8 01             	cmp    eax,0x1
  40c5fd:	0f 85 c5 00 00 00    	jne    40c6c8 <cos_aep_tcap_alloc+0xf8>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c603:	66 0f ef c0          	pxor   xmm0,xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40c607:	bf 60 09 5a 00       	mov    edi,0x5a0960
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c60c:	0f 11 03             	movups XMMWORD PTR [rbx],xmm0
  40c60f:	0f 11 43 10          	movups XMMWORD PTR [rbx+0x10],xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40c613:	48 8b 35 56 43 19 00 	mov    rsi,QWORD PTR [rip+0x194356]        # 5a0970 <curr_defci+0x10>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c61a:	0f 11 43 20          	movups XMMWORD PTR [rbx+0x20],xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40c61e:	e8 ad 31 00 00       	call   40f7d0 <cos_initthd_alloc>
  40c623:	48 89 c6             	mov    rsi,rax
  40c626:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
	assert(aep->thd);
  40c62a:	48 85 f6             	test   rsi,rsi
  40c62d:	0f 84 ea 00 00 00    	je     40c71d <cos_aep_tcap_alloc+0x14d>
	aep->tid  = cos_introspect(ci, aep->thd, THD_GET_TID);
  40c633:	31 d2                	xor    edx,edx
  40c635:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40c63a:	e8 01 55 00 00       	call   411b40 <cos_introspect>
  40c63f:	48 98                	cdqe   
  40c641:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
	if (tc) {
  40c645:	4d 85 e4             	test   r12,r12
  40c648:	0f 84 9a 00 00 00    	je     40c6e8 <cos_aep_tcap_alloc+0x118>
		aep->tc = tc;
  40c64e:	4c 89 23             	mov    QWORD PTR [rbx],r12
	aep->rcv  = cos_arcv_alloc(ci, aep->thd, aep->tc, ci->comp_cap, sched->rcv);
  40c651:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
  40c655:	4c 8b 05 fc 43 19 00 	mov    r8,QWORD PTR [rip+0x1943fc]        # 5a0a58 <curr_defci+0xf8>
  40c65c:	4c 89 e2             	mov    rdx,r12
  40c65f:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40c664:	48 8b 0d 05 43 19 00 	mov    rcx,QWORD PTR [rip+0x194305]        # 5a0970 <curr_defci+0x10>
  40c66b:	e8 40 44 00 00       	call   410ab0 <cos_arcv_alloc>
  40c670:	48 89 43 18          	mov    QWORD PTR [rbx+0x18],rax
	assert(aep->rcv);
  40c674:	48 85 c0             	test   rax,rax
  40c677:	0f 84 bc 00 00 00    	je     40c739 <cos_aep_tcap_alloc+0x169>
	aep->fn   = fn;
  40c67d:	4c 89 6b 20          	mov    QWORD PTR [rbx+0x20],r13
	struct cos_defcompinfo *defci     = cos_defcompinfo_curr_get();
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);

	return cos_aep_alloc_intern(aep, defci, tc, sched_aep, fn, data, 0);
}
  40c681:	31 c0                	xor    eax,eax
	aep->data = data;
  40c683:	4c 89 73 28          	mov    QWORD PTR [rbx+0x28],r14
}
  40c687:	5b                   	pop    rbx
  40c688:	41 5c                	pop    r12
  40c68a:	41 5d                	pop    r13
  40c68c:	41 5e                	pop    r14
  40c68e:	5d                   	pop    rbp
  40c68f:	c3                   	ret    
	assert(curr_defci_init_status == INITIALIZED);
  40c690:	83 f8 01             	cmp    eax,0x1
  40c693:	75 33                	jne    40c6c8 <cos_aep_tcap_alloc+0xf8>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c695:	66 0f ef c0          	pxor   xmm0,xmm0
	else              aep->thd = cos_thd_alloc(ci, dst_ci->comp_cap, cos_aepthd_fn, (void *)aep);
  40c699:	48 89 d9             	mov    rcx,rbx
  40c69c:	ba 20 b8 40 00       	mov    edx,0x40b820
  40c6a1:	bf 60 09 5a 00       	mov    edi,0x5a0960
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c6a6:	0f 11 03             	movups XMMWORD PTR [rbx],xmm0
  40c6a9:	0f 11 43 10          	movups XMMWORD PTR [rbx+0x10],xmm0
	else              aep->thd = cos_thd_alloc(ci, dst_ci->comp_cap, cos_aepthd_fn, (void *)aep);
  40c6ad:	48 8b 35 bc 42 19 00 	mov    rsi,QWORD PTR [rip+0x1942bc]        # 5a0970 <curr_defci+0x10>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c6b4:	0f 11 43 20          	movups XMMWORD PTR [rbx+0x20],xmm0
	else              aep->thd = cos_thd_alloc(ci, dst_ci->comp_cap, cos_aepthd_fn, (void *)aep);
  40c6b8:	e8 63 24 00 00       	call   40eb20 <cos_thd_alloc>
  40c6bd:	48 89 c6             	mov    rsi,rax
  40c6c0:	e9 61 ff ff ff       	jmp    40c626 <cos_aep_tcap_alloc+0x56>
  40c6c5:	0f 1f 00             	nop    DWORD PTR [rax]
  40c6c8:	be 31 00 00 00       	mov    esi,0x31
  40c6cd:	bf b0 d4 41 00       	mov    edi,0x41d4b0
  40c6d2:	e8 f9 d9 ff ff       	call   40a0d0 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40c6d7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c6de:	00 00 00 00 
  40c6e2:	0f 0b                	ud2    
  40c6e4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		aep->tc = cos_tcap_alloc(ci);
  40c6e8:	bf 60 09 5a 00       	mov    edi,0x5a0960
  40c6ed:	e8 ae 54 00 00       	call   411ba0 <cos_tcap_alloc>
  40c6f2:	48 89 03             	mov    QWORD PTR [rbx],rax
  40c6f5:	49 89 c4             	mov    r12,rax
		assert(aep->tc);
  40c6f8:	48 85 c0             	test   rax,rax
  40c6fb:	0f 85 50 ff ff ff    	jne    40c651 <cos_aep_tcap_alloc+0x81>
  40c701:	be 31 00 00 00       	mov    esi,0x31
  40c706:	bf 20 d5 41 00       	mov    edi,0x41d520
  40c70b:	e8 c0 d9 ff ff       	call   40a0d0 <cos_print_str>
  40c710:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c717:	00 00 00 00 
  40c71b:	0f 0b                	ud2    
  40c71d:	be 31 00 00 00       	mov    esi,0x31
  40c722:	bf e8 d4 41 00       	mov    edi,0x41d4e8
  40c727:	e8 a4 d9 ff ff       	call   40a0d0 <cos_print_str>
	assert(aep->thd);
  40c72c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c733:	00 00 00 00 
  40c737:	0f 0b                	ud2    
  40c739:	be 31 00 00 00       	mov    esi,0x31
  40c73e:	bf 58 d5 41 00       	mov    edi,0x41d558
  40c743:	e8 88 d9 ff ff       	call   40a0d0 <cos_print_str>
	assert(aep->rcv);
  40c748:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c74f:	00 00 00 00 
  40c753:	0f 0b                	ud2    
  40c755:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40c75c:	00 00 00 00 

000000000040c760 <cos_defswitch>:

int
cos_defswitch(thdcap_t c, tcap_prio_t p, tcap_time_t r, sched_tok_t stok)
{
  40c760:	f3 0f 1e fa          	endbr64 
	struct cos_defcompinfo *defci     = cos_defcompinfo_curr_get();
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);

	assert(curr_defci_init_status == INITIALIZED);
  40c764:	83 3d 05 43 19 00 01 	cmp    DWORD PTR [rip+0x194305],0x1        # 5a0a70 <curr_defci_init_status>
  40c76b:	75 1c                	jne    40c789 <cos_defswitch+0x29>
  40c76d:	41 89 c9             	mov    r9d,ecx

	return cos_switch(c, sched_aep->tc, p, r, sched_aep->rcv, stok);
  40c770:	4c 8b 05 e1 42 19 00 	mov    r8,QWORD PTR [rip+0x1942e1]        # 5a0a58 <curr_defci+0xf8>
  40c777:	48 89 d1             	mov    rcx,rdx
  40c77a:	48 89 f2             	mov    rdx,rsi
  40c77d:	48 8b 35 bc 42 19 00 	mov    rsi,QWORD PTR [rip+0x1942bc]        # 5a0a40 <curr_defci+0xe0>
  40c784:	e9 97 4b 00 00       	jmp    411320 <cos_switch>
{
  40c789:	55                   	push   rbp
  40c78a:	be 31 00 00 00       	mov    esi,0x31
  40c78f:	bf 70 d6 41 00       	mov    edi,0x41d670
  40c794:	48 89 e5             	mov    rbp,rsp
  40c797:	e8 34 d9 ff ff       	call   40a0d0 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40c79c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c7a3:	00 00 00 00 
  40c7a7:	0f 0b                	ud2    
  40c7a9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000040c7b0 <printc.constprop.0>:
printc(char *fmt, ...)
  40c7b0:	55                   	push   rbp
  40c7b1:	48 89 e5             	mov    rbp,rsp
  40c7b4:	48 81 ec 90 01 00 00 	sub    rsp,0x190
  40c7bb:	48 89 b5 58 ff ff ff 	mov    QWORD PTR [rbp-0xa8],rsi
  40c7c2:	48 89 95 60 ff ff ff 	mov    QWORD PTR [rbp-0xa0],rdx
  40c7c9:	48 89 8d 68 ff ff ff 	mov    QWORD PTR [rbp-0x98],rcx
  40c7d0:	4c 89 85 70 ff ff ff 	mov    QWORD PTR [rbp-0x90],r8
  40c7d7:	4c 89 8d 78 ff ff ff 	mov    QWORD PTR [rbp-0x88],r9
  40c7de:	84 c0                	test   al,al
  40c7e0:	74 20                	je     40c802 <printc.constprop.0+0x52>
  40c7e2:	0f 29 45 80          	movaps XMMWORD PTR [rbp-0x80],xmm0
  40c7e6:	0f 29 4d 90          	movaps XMMWORD PTR [rbp-0x70],xmm1
  40c7ea:	0f 29 55 a0          	movaps XMMWORD PTR [rbp-0x60],xmm2
  40c7ee:	0f 29 5d b0          	movaps XMMWORD PTR [rbp-0x50],xmm3
  40c7f2:	0f 29 65 c0          	movaps XMMWORD PTR [rbp-0x40],xmm4
  40c7f6:	0f 29 6d d0          	movaps XMMWORD PTR [rbp-0x30],xmm5
  40c7fa:	0f 29 75 e0          	movaps XMMWORD PTR [rbp-0x20],xmm6
  40c7fe:	0f 29 7d f0          	movaps XMMWORD PTR [rbp-0x10],xmm7
	va_start(arg_ptr, fmt);
  40c802:	48 8d 45 10          	lea    rax,[rbp+0x10]
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40c806:	ba c0 d6 41 00       	mov    edx,0x41d6c0
  40c80b:	be b4 00 00 00       	mov    esi,0xb4
	va_start(arg_ptr, fmt);
  40c810:	c7 85 78 fe ff ff 08 	mov    DWORD PTR [rbp-0x188],0x8
  40c817:	00 00 00 
  40c81a:	48 89 85 80 fe ff ff 	mov    QWORD PTR [rbp-0x180],rax
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40c821:	48 8d 8d 78 fe ff ff 	lea    rcx,[rbp-0x188]
	va_start(arg_ptr, fmt);
  40c828:	48 8d 85 50 ff ff ff 	lea    rax,[rbp-0xb0]
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40c82f:	48 8d bd 90 fe ff ff 	lea    rdi,[rbp-0x170]
	va_start(arg_ptr, fmt);
  40c836:	48 89 85 88 fe ff ff 	mov    QWORD PTR [rbp-0x178],rax
  40c83d:	c7 85 7c fe ff ff 30 	mov    DWORD PTR [rbp-0x184],0x30
  40c844:	00 00 00 
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40c847:	e8 14 8d 00 00       	call   415560 <vsnprintf>
	ret = cos_print_str(s, ret);
  40c84c:	48 8d bd 90 fe ff ff 	lea    rdi,[rbp-0x170]
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40c853:	89 c6                	mov    esi,eax
	ret = cos_print_str(s, ret);
  40c855:	e8 76 d8 ff ff       	call   40a0d0 <cos_print_str>
}
  40c85a:	c9                   	leave  
  40c85b:	c3                   	ret    
  40c85c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000040c860 <__mem_bump_alloc.constprop.0>:
}

/**************** [Memory Capability Allocation Functions] ***************/

static vaddr_t
__mem_bump_alloc(struct cos_compinfo *__ci, int km, int retype)
  40c860:	55                   	push   rbp
  40c861:	48 89 e5             	mov    rbp,rsp
  40c864:	41 55                	push   r13
  40c866:	41 54                	push   r12
  40c868:	53                   	push   rbx
  40c869:	48 83 ec 18          	sub    rsp,0x18
	struct cos_compinfo *ci;
	vaddr_t *            ptr, *frontier;

	printd("__mem_bump_alloc\n");

	assert(__ci);
  40c86d:	48 85 ff             	test   rdi,rdi
  40c870:	0f 84 2f 01 00 00    	je     40c9a5 <__mem_bump_alloc.constprop.0+0x145>
	return ci->memsrc;
  40c876:	4c 8b 57 60          	mov    r10,QWORD PTR [rdi+0x60]
        __asm__ __volatile__("lock " PS_CAS_STR
  40c87a:	be 01 00 00 00       	mov    esi,0x1
  40c87f:	31 c9                	xor    ecx,ecx
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40c881:	49 8d 92 b8 00 00 00 	lea    rdx,[r10+0xb8]
	ci = __compinfo_metacap(__ci);
	assert(ci && ci == __compinfo_metacap(__ci));
  40c888:	4d 85 d2             	test   r10,r10
  40c88b:	0f 84 30 01 00 00    	je     40c9c1 <__mem_bump_alloc.constprop.0+0x161>
  40c891:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  40c898:	48 89 c8             	mov    rax,rcx
  40c89b:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40c8a0:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40c8a3:	84 c0                	test   al,al
  40c8a5:	74 f1                	je     40c898 <__mem_bump_alloc.constprop.0+0x38>
        __asm__ __volatile__("lock " PS_FAA_STR
  40c8a7:	41 bd 00 10 00 00    	mov    r13d,0x1000
  40c8ad:	f0 4d 0f c1 6a 78    	lock xadd QWORD PTR [r10+0x78],r13
		frontier = &ci->mi.umem_frontier;
	}

	ret = ps_faa(ptr, PAGE_SIZE);

	if (ret >= *frontier || *frontier - ret > RETYPE_MEM_SIZE) {
  40c8b3:	49 8b 92 90 00 00 00 	mov    rdx,QWORD PTR [r10+0x90]
  40c8ba:	49 39 d5             	cmp    r13,rdx
  40c8bd:	0f 82 bd 00 00 00    	jb     40c980 <__mem_bump_alloc.constprop.0+0x120>
		vaddr_t ptr_tmp = *ptr, front_tmp = *frontier;
  40c8c3:	49 8b 42 78          	mov    rax,QWORD PTR [r10+0x78]

		/* TODO: expand frontier if introspection says there is more memory */
		if (ci->mi.untyped_ptr == ci->mi.untyped_frontier) goto error;
  40c8c7:	49 8b 9a 80 00 00 00 	mov    rbx,QWORD PTR [r10+0x80]
  40c8ce:	49 39 5a 68          	cmp    QWORD PTR [r10+0x68],rbx
  40c8d2:	0f 84 c8 00 00 00    	je     40c9a0 <__mem_bump_alloc.constprop.0+0x140>
  40c8d8:	41 bd 00 10 00 00    	mov    r13d,0x1000
  40c8de:	f0 4d 0f c1 6a 68    	lock xadd QWORD PTR [r10+0x68],r13
		/* this is the overall frontier, so we know we can use this value... */
		ret = ps_faa(&ci->mi.untyped_ptr, RETYPE_MEM_SIZE);
		/* failure here means that someone else already advanced the frontier/ptr */
		if (ps_cas(ptr, ptr_tmp, ret + PAGE_SIZE)) {
  40c8e4:	49 8d 8d 00 10 00 00 	lea    rcx,[r13+0x1000]
        __asm__ __volatile__("lock " PS_CAS_STR
  40c8eb:	f0 49 0f b1 4a 78    	lock cmpxchg QWORD PTR [r10+0x78],rcx
  40c8f1:	0f 94 c0             	sete   al
  40c8f4:	84 c0                	test   al,al
  40c8f6:	74 0f                	je     40c907 <__mem_bump_alloc.constprop.0+0xa7>
  40c8f8:	48 89 d0             	mov    rax,rdx
  40c8fb:	f0 49 0f b1 8a 90 00 	lock cmpxchg QWORD PTR [r10+0x90],rcx
  40c902:	00 00 
  40c904:	0f 94 c0             	sete   al
			ps_cas(frontier, front_tmp, ret + RETYPE_MEM_SIZE);
		}
	}

	if (retype && (ret % RETYPE_MEM_SIZE == 0)) {
  40c907:	4c 89 ea             	mov    rdx,r13
  40c90a:	81 e2 ff 0f 00 00    	and    edx,0xfff
  40c910:	75 50                	jne    40c962 <__mem_bump_alloc.constprop.0+0x102>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40c912:	41 8b 82 98 00 00 00 	mov    eax,DWORD PTR [r10+0x98]
	__asm__ __volatile__(
  40c919:	4c 89 eb             	mov    rbx,r13
  40c91c:	48 89 d6             	mov    rsi,rdx
  40c91f:	48 89 d7             	mov    rdi,rdx
  40c922:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40c926:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40c929:	05 1a 00 01 00       	add    eax,0x1001a
	__asm__ __volatile__(
  40c92e:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40c931:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40c935:	48 89 cd             	mov    rbp,rcx
  40c938:	49 b8 50 c9 40 00 00 	movabs r8,0x40c950
  40c93f:	00 00 00 
  40c942:	0f 05                	syscall 
  40c944:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  40c948:	eb 0d                	jmp    40c957 <__mem_bump_alloc.constprop.0+0xf7>
  40c94a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40c950:	b9 00 00 00 00       	mov    ecx,0x0
  40c955:	eb 05                	jmp    40c95c <__mem_bump_alloc.constprop.0+0xfc>
  40c957:	b9 01 00 00 00       	mov    ecx,0x1
  40c95c:	5d                   	pop    rbp
  40c95d:	5c                   	pop    rsp
		/* are we dealing with a kernel memory allocation? */
		syscall_op_t op = km ? CAPTBL_OP_MEM_RETYPE2KERN : CAPTBL_OP_MEM_RETYPE2USER;
		if (call_cap_op(ci->mi.pgtbl_cap, op, ret, 0, 0, 0)) goto error;
  40c95e:	85 c0                	test   eax,eax
  40c960:	75 3e                	jne    40c9a0 <__mem_bump_alloc.constprop.0+0x140>
  40c962:	49 c7 82 b8 00 00 00 	mov    QWORD PTR [r10+0xb8],0x0
  40c969:	00 00 00 00 
	return ret;
error:
	ps_lock_release(&ci->mem_lock);

	return 0;
}
  40c96d:	48 83 c4 18          	add    rsp,0x18
  40c971:	4c 89 e8             	mov    rax,r13
  40c974:	5b                   	pop    rbx
  40c975:	41 5c                	pop    r12
  40c977:	41 5d                	pop    r13
  40c979:	5d                   	pop    rbp
  40c97a:	c3                   	ret    
  40c97b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	if (ret >= *frontier || *frontier - ret > RETYPE_MEM_SIZE) {
  40c980:	48 89 d0             	mov    rax,rdx
  40c983:	4c 29 e8             	sub    rax,r13
  40c986:	48 3d 00 10 00 00    	cmp    rax,0x1000
  40c98c:	0f 86 75 ff ff ff    	jbe    40c907 <__mem_bump_alloc.constprop.0+0xa7>
  40c992:	e9 2c ff ff ff       	jmp    40c8c3 <__mem_bump_alloc.constprop.0+0x63>
  40c997:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40c99e:	00 00 
	return 0;
  40c9a0:	45 31 ed             	xor    r13d,r13d
  40c9a3:	eb bd                	jmp    40c962 <__mem_bump_alloc.constprop.0+0x102>
	return cos_print_str(s, strlen(s));
  40c9a5:	be 2e 00 00 00       	mov    esi,0x2e
  40c9aa:	bf d0 d6 41 00       	mov    edi,0x41d6d0
  40c9af:	e8 1c d7 ff ff       	call   40a0d0 <cos_print_str>
	assert(__ci);
  40c9b4:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c9bb:	00 00 00 00 
  40c9bf:	0f 0b                	ud2    
  40c9c1:	be 2e 00 00 00       	mov    esi,0x2e
  40c9c6:	bf 00 d7 41 00       	mov    edi,0x41d700
  40c9cb:	e8 00 d7 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci && ci == __compinfo_metacap(__ci));
  40c9d0:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c9d7:	00 00 00 00 
  40c9db:	0f 0b                	ud2    
  40c9dd:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040c9e0 <__capid_captbl_check_expand>:

static capid_t __capid_bump_alloc(struct cos_compinfo *ci, cap_t cap);

static int
__capid_captbl_check_expand(struct cos_compinfo *ci)
{
  40c9e0:	55                   	push   rbp
  40c9e1:	48 89 e5             	mov    rbp,rsp
  40c9e4:	41 57                	push   r15
  40c9e6:	41 56                	push   r14
  40c9e8:	41 55                	push   r13
  40c9ea:	41 54                	push   r12
  40c9ec:	53                   	push   rbx
  40c9ed:	48 83 ec 28          	sub    rsp,0x28
	return ci->memsrc;
  40c9f1:	4c 8b 67 60          	mov    r12,QWORD PTR [rdi+0x60]
	capid_t captblcap;
	capid_t captblid_add;
	vaddr_t kmem;

	/* ensure that we have bounded structure, and bounded recursion */
	assert(__compinfo_metacap(meta) == meta);
  40c9f5:	4d 39 64 24 60       	cmp    QWORD PTR [r12+0x60],r12
  40c9fa:	75 32                	jne    40ca2e <__capid_captbl_check_expand+0x4e>
	 * rest of the entry (internal fragmentation WRT the captbl
	 * capability).  Oh well.
	 */

	if (self_resources) {
		frontier = ps_load(&ci->caprange_frontier) - CAPMAX_ENTRY_SZ;
  40c9fc:	48 8b 5f 20          	mov    rbx,QWORD PTR [rdi+0x20]
  40ca00:	49 89 fd             	mov    r13,rdi
	if (self_resources) {
  40ca03:	4c 39 e7             	cmp    rdi,r12
  40ca06:	74 20                	je     40ca28 <__capid_captbl_check_expand+0x48>
	} else {
		frontier = ps_load(&ci->caprange_frontier);
	}
	assert(ci->cap_frontier <= frontier);
  40ca08:	49 39 5d 18          	cmp    QWORD PTR [r13+0x18],rbx
  40ca0c:	77 3c                	ja     40ca4a <__capid_captbl_check_expand+0x6a>

	/* Common case: */
	if (likely(ci->cap_frontier != frontier)) return 0;
  40ca0e:	74 56                	je     40ca66 <__capid_captbl_check_expand+0x86>
	frontier       = ps_load(&ci->cap_frontier);
	range_frontier = ps_faa(&ci->caprange_frontier, CAPTBL_EXPAND_SZ * 2);
	ps_cas(&ci->cap_frontier, frontier, range_frontier);

	return 0;
}
  40ca10:	48 83 c4 28          	add    rsp,0x28
  40ca14:	31 c0                	xor    eax,eax
  40ca16:	5b                   	pop    rbx
  40ca17:	41 5c                	pop    r12
  40ca19:	41 5d                	pop    r13
  40ca1b:	41 5e                	pop    r14
  40ca1d:	41 5f                	pop    r15
  40ca1f:	5d                   	pop    rbp
  40ca20:	c3                   	ret    
  40ca21:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		frontier = ps_load(&ci->caprange_frontier) - CAPMAX_ENTRY_SZ;
  40ca28:	48 83 eb 04          	sub    rbx,0x4
  40ca2c:	eb da                	jmp    40ca08 <__capid_captbl_check_expand+0x28>
  40ca2e:	be 2e 00 00 00       	mov    esi,0x2e
  40ca33:	bf 30 d7 41 00       	mov    edi,0x41d730
  40ca38:	e8 93 d6 ff ff       	call   40a0d0 <cos_print_str>
	assert(__compinfo_metacap(meta) == meta);
  40ca3d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ca44:	00 00 00 00 
  40ca48:	0f 0b                	ud2    
  40ca4a:	be 2e 00 00 00       	mov    esi,0x2e
  40ca4f:	bf 60 d7 41 00       	mov    edi,0x41d760
  40ca54:	e8 77 d6 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci->cap_frontier <= frontier);
  40ca59:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ca60:	00 00 00 00 
  40ca64:	0f 0b                	ud2    
	return __mem_bump_alloc(ci, 1, 1);
  40ca66:	4c 89 ef             	mov    rdi,r13
  40ca69:	e8 f2 fd ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40ca6e:	49 89 c6             	mov    r14,rax
	assert(kmem); /* FIXME: should have a failure semantics for capids */
  40ca71:	48 85 c0             	test   rax,rax
  40ca74:	0f 84 9f 01 00 00    	je     40cc19 <__capid_captbl_check_expand+0x239>
	if (self_resources) {
  40ca7a:	4d 39 e5             	cmp    r13,r12
  40ca7d:	74 69                	je     40cae8 <__capid_captbl_check_expand+0x108>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40ca7f:	49 8d 94 24 b0 00 00 	lea    rdx,[r12+0xb0]
  40ca86:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  40ca87:	be 01 00 00 00       	mov    esi,0x1
  40ca8c:	31 c9                	xor    ecx,ecx
  40ca8e:	66 90                	xchg   ax,ax
  40ca90:	48 89 c8             	mov    rax,rcx
  40ca93:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40ca98:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40ca9b:	84 c0                	test   al,al
  40ca9d:	74 f1                	je     40ca90 <__capid_captbl_check_expand+0xb0>
	ps_lock_take(&ci->cap_lock);
	/*
	 * Do we need a new cache-line in the capability table for
	 * this size of capability?
	 */
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40ca9f:	41 f6 44 24 38 03    	test   BYTE PTR [r12+0x38],0x3
  40caa5:	0f 84 4c 01 00 00    	je     40cbf7 <__capid_captbl_check_expand+0x217>
        __asm__ __volatile__("lock " PS_FAA_STR
  40caab:	bb 04 00 00 00       	mov    ebx,0x4
  40cab0:	f0 49 0f c1 5c 24 38 	lock xadd QWORD PTR [r12+0x38],rbx
{ l->o = 0; }
  40cab7:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40cabe:	00 00 00 00 00 
		assert(captblcap);
  40cac3:	48 85 db             	test   rbx,rbx
  40cac6:	75 20                	jne    40cae8 <__capid_captbl_check_expand+0x108>
  40cac8:	be 2e 00 00 00       	mov    esi,0x2e
  40cacd:	bf c0 d7 41 00       	mov    edi,0x41d7c0
  40cad2:	e8 f9 d5 ff ff       	call   40a0d0 <cos_print_str>
  40cad7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40cade:	00 00 00 00 
  40cae2:	0f 0b                	ud2    
  40cae4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	captblid_add = ps_load(&ci->caprange_frontier);
  40cae8:	4d 8b 7d 20          	mov    r15,QWORD PTR [r13+0x20]
	assert(captblid_add % CAPTBL_EXPAND_SZ == 0);
  40caec:	4c 89 f8             	mov    rax,r15
  40caef:	83 e0 7f             	and    eax,0x7f
  40caf2:	48 89 45 b8          	mov    QWORD PTR [rbp-0x48],rax
  40caf6:	0f 85 39 01 00 00    	jne    40cc35 <__capid_captbl_check_expand+0x255>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40cafc:	41 8b 44 24 08       	mov    eax,DWORD PTR [r12+0x8]
	__asm__ __volatile__(
  40cb01:	4c 8d 55 c0          	lea    r10,[rbp-0x40]
  40cb05:	ba 01 00 00 00       	mov    edx,0x1
  40cb0a:	4c 89 f7             	mov    rdi,r14
  40cb0d:	49 8b b4 24 98 00 00 	mov    rsi,QWORD PTR [r12+0x98]
  40cb14:	00 
  40cb15:	4c 89 d1             	mov    rcx,r10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40cb18:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40cb1b:	05 1e 00 01 00       	add    eax,0x1001e
	__asm__ __volatile__(
  40cb20:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40cb23:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40cb27:	48 89 cd             	mov    rbp,rcx
  40cb2a:	49 b8 40 cb 40 00 00 	movabs r8,0x40cb40
  40cb31:	00 00 00 
  40cb34:	0f 05                	syscall 
  40cb36:	66 90                	xchg   ax,ax
  40cb38:	eb 0d                	jmp    40cb47 <__capid_captbl_check_expand+0x167>
  40cb3a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40cb40:	b9 00 00 00 00       	mov    ecx,0x0
  40cb45:	eb 05                	jmp    40cb4c <__capid_captbl_check_expand+0x16c>
  40cb47:	b9 01 00 00 00       	mov    ecx,0x1
  40cb4c:	5d                   	pop    rbp
  40cb4d:	5c                   	pop    rsp
	if (call_cap_op(meta->captbl_cap, CAPTBL_OP_CAPTBLACTIVATE, captblcap, meta->mi.pgtbl_cap, kmem, 1)) {
  40cb4e:	85 c0                	test   eax,eax
  40cb50:	75 6d                	jne    40cbbf <__capid_captbl_check_expand+0x1df>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40cb52:	41 8b 45 08          	mov    eax,DWORD PTR [r13+0x8]
	__asm__ __volatile__(
  40cb56:	48 8b 7d b8          	mov    rdi,QWORD PTR [rbp-0x48]
  40cb5a:	4c 89 fe             	mov    rsi,r15
  40cb5d:	4c 89 d1             	mov    rcx,r10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40cb60:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40cb63:	48 89 fa             	mov    rdx,rdi
	cap_no += op;
  40cb66:	05 01 00 01 00       	add    eax,0x10001
	__asm__ __volatile__(
  40cb6b:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40cb6e:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40cb72:	48 89 cd             	mov    rbp,rcx
  40cb75:	49 b8 90 cb 40 00 00 	movabs r8,0x40cb90
  40cb7c:	00 00 00 
  40cb7f:	0f 05                	syscall 
  40cb81:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  40cb88:	eb 0d                	jmp    40cb97 <__capid_captbl_check_expand+0x1b7>
  40cb8a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40cb90:	b9 00 00 00 00       	mov    ecx,0x0
  40cb95:	eb 05                	jmp    40cb9c <__capid_captbl_check_expand+0x1bc>
  40cb97:	b9 01 00 00 00       	mov    ecx,0x1
  40cb9c:	5d                   	pop    rbp
  40cb9d:	5c                   	pop    rsp
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_CONS, captblcap, captblid_add, 0, 0)) {
  40cb9e:	85 c0                	test   eax,eax
  40cba0:	75 39                	jne    40cbdb <__capid_captbl_check_expand+0x1fb>
	frontier       = ps_load(&ci->cap_frontier);
  40cba2:	49 8b 45 18          	mov    rax,QWORD PTR [r13+0x18]
        __asm__ __volatile__("lock " PS_FAA_STR
  40cba6:	ba 00 01 00 00       	mov    edx,0x100
  40cbab:	f0 49 0f c1 55 20    	lock xadd QWORD PTR [r13+0x20],rdx
        __asm__ __volatile__("lock " PS_CAS_STR
  40cbb1:	f0 49 0f b1 55 18    	lock cmpxchg QWORD PTR [r13+0x18],rdx
  40cbb7:	0f 94 c0             	sete   al
	return 0;
  40cbba:	e9 51 fe ff ff       	jmp    40ca10 <__capid_captbl_check_expand+0x30>
  40cbbf:	be 2e 00 00 00       	mov    esi,0x2e
  40cbc4:	bf 20 d8 41 00       	mov    edi,0x41d820
  40cbc9:	e8 02 d5 ff ff       	call   40a0d0 <cos_print_str>
		assert(0); /* race condition? */
  40cbce:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40cbd5:	00 00 00 00 
  40cbd9:	0f 0b                	ud2    
  40cbdb:	be 2e 00 00 00       	mov    esi,0x2e
  40cbe0:	bf 50 d8 41 00       	mov    edi,0x41d850
  40cbe5:	e8 e6 d4 ff ff       	call   40a0d0 <cos_print_str>
		assert(0); /* race? */
  40cbea:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40cbf1:	00 00 00 00 
  40cbf5:	0f 0b                	ud2    
		if (__capid_captbl_check_expand(ci)) goto error;
  40cbf7:	4c 89 e7             	mov    rdi,r12
  40cbfa:	e8 e1 fd ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40cbff:	85 c0                	test   eax,eax
  40cc01:	75 4e                	jne    40cc51 <__capid_captbl_check_expand+0x271>
        __asm__ __volatile__("lock " PS_FAA_STR
  40cc03:	b8 04 00 00 00       	mov    eax,0x4
  40cc08:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40cc0f:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  40cc14:	e9 92 fe ff ff       	jmp    40caab <__capid_captbl_check_expand+0xcb>
  40cc19:	be 2e 00 00 00       	mov    esi,0x2e
  40cc1e:	bf 90 d7 41 00       	mov    edi,0x41d790
  40cc23:	e8 a8 d4 ff ff       	call   40a0d0 <cos_print_str>
	assert(kmem); /* FIXME: should have a failure semantics for capids */
  40cc28:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40cc2f:	00 00 00 00 
  40cc33:	0f 0b                	ud2    
  40cc35:	be 2e 00 00 00       	mov    esi,0x2e
  40cc3a:	bf f0 d7 41 00       	mov    edi,0x41d7f0
  40cc3f:	e8 8c d4 ff ff       	call   40a0d0 <cos_print_str>
	assert(captblid_add % CAPTBL_EXPAND_SZ == 0);
  40cc44:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40cc4b:	00 00 00 00 
  40cc4f:	0f 0b                	ud2    
{ l->o = 0; }
  40cc51:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40cc58:	00 00 00 00 00 
		assert(captblcap);
  40cc5d:	e9 66 fe ff ff       	jmp    40cac8 <__capid_captbl_check_expand+0xe8>
  40cc62:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40cc69:	00 00 00 00 
  40cc6d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040cc70 <__bump_mem_expand_range>:
	return pte_cap;
}

static vaddr_t
__bump_mem_expand_range(struct cos_compinfo *meta, pgtblcap_t cipgtbl, vaddr_t mem_ptr, unsigned long mem_sz, u32_t pgtbl_lvl)
{
  40cc70:	55                   	push   rbp
  40cc71:	48 89 e5             	mov    rbp,rsp
  40cc74:	41 57                	push   r15
  40cc76:	41 56                	push   r14
  40cc78:	41 55                	push   r13
  40cc7a:	41 54                	push   r12
  40cc7c:	53                   	push   rbx
  40cc7d:	48 83 ec 48          	sub    rsp,0x48
  40cc81:	48 89 55 b8          	mov    QWORD PTR [rbp-0x48],rdx
	vaddr_t addr, range;
	u8_t lvl = (u8_t)pgtbl_lvl;
	assert(lvl >= 0 && lvl < COS_PGTBL_DEPTH - 1);
  40cc85:	41 80 f8 02          	cmp    r8b,0x2
  40cc89:	0f 87 6f 02 00 00    	ja     40cefe <__bump_mem_expand_range+0x28e>
  40cc8f:	45 89 c7             	mov    r15d,r8d


#if defined(__x86_64__)
	vaddr_t tmp_frontier;
	range		 = cos_pgtbl_get_range(lvl);
  40cc92:	41 0f b6 d0          	movzx  edx,r8b
  40cc96:	76 18                	jbe    40ccb0 <__bump_mem_expand_range+0x40>
	}
	assert(round_up_to_pgd_page(addr) == round_up_to_pgd_page(mem_ptr + mem_sz));
#endif

	return mem_ptr;
}
  40cc98:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  40cc9c:	48 83 c4 48          	add    rsp,0x48
  40cca0:	5b                   	pop    rbx
  40cca1:	41 5c                	pop    r12
  40cca3:	41 5d                	pop    r13
  40cca5:	41 5e                	pop    r14
  40cca7:	41 5f                	pop    r15
  40cca9:	5d                   	pop    rbp
  40ccaa:	c3                   	ret    
  40ccab:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40ccb0:	49 89 fe             	mov    r14,rdi
  40ccb3:	48 89 f0             	mov    rax,rsi
	tmp_frontier = cos_pgtbl_round_up_to_page(lvl, mem_ptr + mem_sz);
  40ccb6:	48 03 4d b8          	add    rcx,QWORD PTR [rbp-0x48]
	switch (pgtbl_lvl)
  40ccba:	83 fa 01             	cmp    edx,0x1
  40ccbd:	0f 84 ae 01 00 00    	je     40ce71 <__bump_mem_expand_range+0x201>
  40ccc3:	83 fa 02             	cmp    edx,0x2
  40ccc6:	75 1f                	jne    40cce7 <__bump_mem_expand_range+0x77>
		return round_up_to_pgt2_page(vaddr);
  40ccc8:	48 81 c1 ff ff 1f 00 	add    rcx,0x1fffff
  40cccf:	48 c7 45 98 00 00 20 	mov    QWORD PTR [rbp-0x68],0x200000
  40ccd6:	00 
  40ccd7:	48 81 e1 00 00 e0 ff 	and    rcx,0xffffffffffe00000
  40ccde:	48 89 4d b0          	mov    QWORD PTR [rbp-0x50],rcx
  40cce2:	48 89 cf             	mov    rdi,rcx
  40cce5:	eb 33                	jmp    40cd1a <__bump_mem_expand_range+0xaa>
	switch (pgtbl_lvl)
  40cce7:	85 d2                	test   edx,edx
  40cce9:	75 ad                	jne    40cc98 <__bump_mem_expand_range+0x28>
		return round_up_to_pgt0_page(vaddr);
  40cceb:	48 ba ff ff ff ff 7f 	movabs rdx,0x7fffffffff
  40ccf2:	00 00 00 
  40ccf5:	48 bb 00 00 00 00 80 	movabs rbx,0x8000000000
  40ccfc:	00 00 00 
  40ccff:	48 01 d1             	add    rcx,rdx
  40cd02:	48 89 5d 98          	mov    QWORD PTR [rbp-0x68],rbx
  40cd06:	48 ba 00 00 00 00 80 	movabs rdx,0xffffff8000000000
  40cd0d:	ff ff ff 
  40cd10:	48 21 d1             	and    rcx,rdx
  40cd13:	48 89 4d b0          	mov    QWORD PTR [rbp-0x50],rcx
  40cd17:	48 89 cf             	mov    rdi,rcx
	for (addr = mem_ptr; addr < tmp_frontier; addr += range) {
  40cd1a:	48 8b 5d b8          	mov    rbx,QWORD PTR [rbp-0x48]
  40cd1e:	48 39 fb             	cmp    rbx,rdi
  40cd21:	0f 83 71 ff ff ff    	jae    40cc98 <__bump_mem_expand_range+0x28>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40cd27:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40cd2a:	48 89 5d a8          	mov    QWORD PTR [rbp-0x58],rbx
        __asm__ __volatile__("lock " PS_CAS_STR
  40cd2e:	41 bd 01 00 00 00    	mov    r13d,0x1
  40cd34:	05 01 00 01 00       	add    eax,0x10001
  40cd39:	89 45 a4             	mov    DWORD PTR [rbp-0x5c],eax
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  40cd3c:	4d 3b 76 60          	cmp    r14,QWORD PTR [r14+0x60]
  40cd40:	0f 85 0f 01 00 00    	jne    40ce55 <__bump_mem_expand_range+0x1e5>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40cd46:	49 8d 96 b0 00 00 00 	lea    rdx,[r14+0xb0]
        __asm__ __volatile__("lock " PS_CAS_STR
  40cd4d:	31 c9                	xor    ecx,ecx
  40cd4f:	90                   	nop
  40cd50:	48 89 c8             	mov    rax,rcx
  40cd53:	f0 4c 0f b1 2a       	lock cmpxchg QWORD PTR [rdx],r13
  40cd58:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40cd5b:	84 c0                	test   al,al
  40cd5d:	74 f1                	je     40cd50 <__bump_mem_expand_range+0xe0>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40cd5f:	41 f6 46 38 03       	test   BYTE PTR [r14+0x38],0x3
  40cd64:	0f 84 29 01 00 00    	je     40ce93 <__bump_mem_expand_range+0x223>
        __asm__ __volatile__("lock " PS_FAA_STR
  40cd6a:	bb 04 00 00 00       	mov    ebx,0x4
  40cd6f:	f0 49 0f c1 5e 38    	lock xadd QWORD PTR [r14+0x38],rbx
{ l->o = 0; }
  40cd75:	49 c7 86 b0 00 00 00 	mov    QWORD PTR [r14+0xb0],0x0
  40cd7c:	00 00 00 00 
	return __mem_bump_alloc(ci, 1, 1);
  40cd80:	4c 89 f7             	mov    rdi,r14
  40cd83:	e8 d8 fa ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40cd88:	48 89 c7             	mov    rdi,rax
		if (pte_cap == 0 || ptemem_cap == 0) {
  40cd8b:	48 85 db             	test   rbx,rbx
  40cd8e:	0f 84 1e 01 00 00    	je     40ceb2 <__bump_mem_expand_range+0x242>
  40cd94:	48 85 c0             	test   rax,rax
  40cd97:	0f 84 15 01 00 00    	je     40ceb2 <__bump_mem_expand_range+0x242>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40cd9d:	41 8b 46 08          	mov    eax,DWORD PTR [r14+0x8]
	__asm__ __volatile__(
  40cda1:	4c 8d 55 c0          	lea    r10,[rbp-0x40]
  40cda5:	49 8b b6 98 00 00 00 	mov    rsi,QWORD PTR [r14+0x98]
		if (call_cap_op(meta->captbl_cap, CAPTBL_OP_PGTBLACTIVATE, pte_cap, meta->mi.pgtbl_cap, ptemem_cap,
  40cdac:	41 8d 57 01          	lea    edx,[r15+0x1]
  40cdb0:	4c 89 d1             	mov    rcx,r10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40cdb3:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40cdb6:	05 1c 00 01 00       	add    eax,0x1001c
	__asm__ __volatile__(
  40cdbb:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40cdbe:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40cdc2:	48 89 cd             	mov    rbp,rcx
  40cdc5:	49 b8 e0 cd 40 00 00 	movabs r8,0x40cde0
  40cdcc:	00 00 00 
  40cdcf:	0f 05                	syscall 
  40cdd1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  40cdd8:	eb 0d                	jmp    40cde7 <__bump_mem_expand_range+0x177>
  40cdda:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40cde0:	b9 00 00 00 00       	mov    ecx,0x0
  40cde5:	eb 05                	jmp    40cdec <__bump_mem_expand_range+0x17c>
  40cde7:	b9 01 00 00 00       	mov    ecx,0x1
  40cdec:	5d                   	pop    rbp
  40cded:	5c                   	pop    rsp
  40cdee:	85 c0                	test   eax,eax
  40cdf0:	0f 85 d8 00 00 00    	jne    40cece <__bump_mem_expand_range+0x25e>
  40cdf6:	31 d2                	xor    edx,edx
  40cdf8:	8b 45 a4             	mov    eax,DWORD PTR [rbp-0x5c]
  40cdfb:	48 8b 75 a8          	mov    rsi,QWORD PTR [rbp-0x58]
  40cdff:	4c 89 d1             	mov    rcx,r10
  40ce02:	48 89 d7             	mov    rdi,rdx
  40ce05:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40ce08:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40ce0c:	48 89 cd             	mov    rbp,rcx
  40ce0f:	49 b8 28 ce 40 00 00 	movabs r8,0x40ce28
  40ce16:	00 00 00 
  40ce19:	0f 05                	syscall 
  40ce1b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40ce20:	eb 0d                	jmp    40ce2f <__bump_mem_expand_range+0x1bf>
  40ce22:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40ce28:	b9 00 00 00 00       	mov    ecx,0x0
  40ce2d:	eb 05                	jmp    40ce34 <__bump_mem_expand_range+0x1c4>
  40ce2f:	b9 01 00 00 00       	mov    ecx,0x1
  40ce34:	5d                   	pop    rbp
  40ce35:	5c                   	pop    rsp
	for (addr = mem_ptr; addr < tmp_frontier; addr += range) {
  40ce36:	48 8b 45 98          	mov    rax,QWORD PTR [rbp-0x68]
  40ce3a:	48 01 c6             	add    rsi,rax
  40ce3d:	48 89 75 a8          	mov    QWORD PTR [rbp-0x58],rsi
  40ce41:	48 3b 75 b0          	cmp    rsi,QWORD PTR [rbp-0x50]
  40ce45:	0f 83 4d fe ff ff    	jae    40cc98 <__bump_mem_expand_range+0x28>
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  40ce4b:	4d 3b 76 60          	cmp    r14,QWORD PTR [r14+0x60]
  40ce4f:	0f 84 f1 fe ff ff    	je     40cd46 <__bump_mem_expand_range+0xd6>
  40ce55:	be 2e 00 00 00       	mov    esi,0x2e
  40ce5a:	bf b0 d8 41 00       	mov    edi,0x41d8b0
  40ce5f:	e8 6c d2 ff ff       	call   40a0d0 <cos_print_str>
  40ce64:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ce6b:	00 00 00 00 
  40ce6f:	0f 0b                	ud2    
		return round_up_to_pgt1_page(vaddr);
  40ce71:	48 81 c1 ff ff ff 3f 	add    rcx,0x3fffffff
  40ce78:	48 c7 45 98 00 00 00 	mov    QWORD PTR [rbp-0x68],0x40000000
  40ce7f:	40 
  40ce80:	48 81 e1 00 00 00 c0 	and    rcx,0xffffffffc0000000
  40ce87:	48 89 4d b0          	mov    QWORD PTR [rbp-0x50],rcx
  40ce8b:	48 89 cf             	mov    rdi,rcx
  40ce8e:	e9 87 fe ff ff       	jmp    40cd1a <__bump_mem_expand_range+0xaa>
		if (__capid_captbl_check_expand(ci)) goto error;
  40ce93:	4c 89 f7             	mov    rdi,r14
  40ce96:	e8 45 fb ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40ce9b:	85 c0                	test   eax,eax
  40ce9d:	74 4b                	je     40ceea <__bump_mem_expand_range+0x27a>
  40ce9f:	49 c7 86 b0 00 00 00 	mov    QWORD PTR [r14+0xb0],0x0
  40cea6:	00 00 00 00 
	return __mem_bump_alloc(ci, 1, 1);
  40ceaa:	4c 89 f7             	mov    rdi,r14
  40cead:	e8 ae f9 ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40ceb2:	be 2e 00 00 00       	mov    esi,0x2e
  40ceb7:	bf e0 d8 41 00       	mov    edi,0x41d8e0
  40cebc:	e8 0f d2 ff ff       	call   40a0d0 <cos_print_str>
			assert(0);
  40cec1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40cec8:	00 00 00 00 
  40cecc:	0f 0b                	ud2    
  40cece:	be 2e 00 00 00       	mov    esi,0x2e
  40ced3:	bf 10 d9 41 00       	mov    edi,0x41d910
  40ced8:	e8 f3 d1 ff ff       	call   40a0d0 <cos_print_str>
				assert(0); /* race? */
  40cedd:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40cee4:	00 00 00 00 
  40cee8:	0f 0b                	ud2    
        __asm__ __volatile__("lock " PS_FAA_STR
  40ceea:	b8 04 00 00 00       	mov    eax,0x4
  40ceef:	f0 49 0f c1 46 18    	lock xadd QWORD PTR [r14+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40cef5:	49 89 46 38          	mov    QWORD PTR [r14+0x38],rax
  40cef9:	e9 6c fe ff ff       	jmp    40cd6a <__bump_mem_expand_range+0xfa>
  40cefe:	be 2e 00 00 00       	mov    esi,0x2e
  40cf03:	bf 80 d8 41 00       	mov    edi,0x41d880
  40cf08:	e8 c3 d1 ff ff       	call   40a0d0 <cos_print_str>
	assert(lvl >= 0 && lvl < COS_PGTBL_DEPTH - 1);
  40cf0d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40cf14:	00 00 00 00 
  40cf18:	0f 0b                	ud2    
  40cf1a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000040cf20 <__page_bump_valloc>:
	return heap_vaddr;
}

static vaddr_t
__page_bump_valloc(struct cos_compinfo *ci, size_t sz, size_t align)
{
  40cf20:	55                   	push   rbp
        __asm__ __volatile__("lock " PS_CAS_STR
  40cf21:	31 c9                	xor    ecx,ecx
  40cf23:	48 89 e5             	mov    rbp,rsp
  40cf26:	41 57                	push   r15
  40cf28:	49 89 d7             	mov    r15,rdx
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40cf2b:	48 8d 97 c0 00 00 00 	lea    rdx,[rdi+0xc0]
  40cf32:	41 56                	push   r14
  40cf34:	41 55                	push   r13
  40cf36:	41 54                	push   r12
  40cf38:	49 89 f4             	mov    r12,rsi
        __asm__ __volatile__("lock " PS_CAS_STR
  40cf3b:	be 01 00 00 00       	mov    esi,0x1
  40cf40:	53                   	push   rbx
  40cf41:	48 89 fb             	mov    rbx,rdi
  40cf44:	48 83 ec 38          	sub    rsp,0x38
  40cf48:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40cf4f:	00 
  40cf50:	48 89 c8             	mov    rax,rcx
  40cf53:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40cf58:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40cf5b:	84 c0                	test   al,al
  40cf5d:	74 f1                	je     40cf50 <__page_bump_valloc+0x30>
	vaddr_t ret_addr = 0;
	vaddr_t rounding; // how much we need to round up sz to handle alignment

	ps_lock_take(&ci->va_lock);
	rounding = round_up_to_pow2(ci->vas_frontier, align) - ci->vas_frontier;
  40cf5f:	48 8b 53 40          	mov    rdx,QWORD PTR [rbx+0x40]
  40cf63:	4c 89 f9             	mov    rcx,r15
	return ci->memsrc;
  40cf66:	48 8b 7b 60          	mov    rdi,QWORD PTR [rbx+0x60]
	rounding = round_up_to_pow2(ci->vas_frontier, align) - ci->vas_frontier;
  40cf6a:	48 f7 d9             	neg    rcx
  40cf6d:	4a 8d 44 3a ff       	lea    rax,[rdx+r15*1-0x1]
  40cf72:	48 21 c8             	and    rax,rcx
  40cf75:	48 29 d0             	sub    rax,rdx
	sz += rounding;
  40cf78:	49 01 c4             	add    r12,rax
	rounding = round_up_to_pow2(ci->vas_frontier, align) - ci->vas_frontier;
  40cf7b:	49 89 c3             	mov    r11,rax
	assert(sz % PAGE_SIZE == 0);
  40cf7e:	4d 89 e6             	mov    r14,r12
  40cf81:	41 81 e6 ff 0f 00 00 	and    r14d,0xfff
  40cf88:	0f 85 32 01 00 00    	jne    40d0c0 <__page_bump_valloc+0x1a0>
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  40cf8e:	48 3b 7f 60          	cmp    rdi,QWORD PTR [rdi+0x60]
  40cf92:	0f 85 44 01 00 00    	jne    40d0dc <__page_bump_valloc+0x1bc>
        __asm__ __volatile__("lock " PS_FAA_STR
  40cf98:	4c 89 e2             	mov    rdx,r12
  40cf9b:	f0 48 0f c1 53 40    	lock xadd QWORD PTR [rbx+0x40],rdx
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) pgtbl_flag = PGTBL_LVL_FLAG_VM;
  40cfa1:	31 c0                	xor    eax,eax
		if (heap_vaddr + sz > ci->vasrange_frontier[pgtbl_lvl]) {
  40cfa3:	4d 8d 0c 14          	lea    r9,[r12+rdx*1]
		return round_up_to_pgt0_page(vaddr);
  40cfa7:	48 89 7d b8          	mov    QWORD PTR [rbp-0x48],rdi
  40cfab:	4c 8d 6b 48          	lea    r13,[rbx+0x48]
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) pgtbl_flag = PGTBL_LVL_FLAG_VM;
  40cfaf:	80 bb d8 00 00 00 01 	cmp    BYTE PTR [rbx+0xd8],0x1
		return round_up_to_pgt0_page(vaddr);
  40cfb6:	48 b9 00 00 00 00 80 	movabs rcx,0xffffff8000000000
  40cfbd:	ff ff ff 
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) pgtbl_flag = PGTBL_LVL_FLAG_VM;
  40cfc0:	0f 94 c0             	sete   al
  40cfc3:	c1 e0 1f             	shl    eax,0x1f
  40cfc6:	89 45 c4             	mov    DWORD PTR [rbp-0x3c],eax
		return round_up_to_pgt0_page(vaddr);
  40cfc9:	48 b8 ff ff ff ff 7f 	movabs rax,0x7fffffffff
  40cfd0:	00 00 00 
  40cfd3:	4c 01 c8             	add    rax,r9
  40cfd6:	48 21 c8             	and    rax,rcx
  40cfd9:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
		if (heap_vaddr + sz > ci->vasrange_frontier[pgtbl_lvl]) {
  40cfdd:	4d 39 4d 00          	cmp    QWORD PTR [r13+0x0],r9
  40cfe1:	72 45                	jb     40d028 <__page_bump_valloc+0x108>
	for (pgtbl_lvl = 0; pgtbl_lvl < COS_PGTBL_DEPTH - 1; pgtbl_lvl++) {
  40cfe3:	49 83 c6 01          	add    r14,0x1
  40cfe7:	49 83 c5 08          	add    r13,0x8
  40cfeb:	49 83 fe 03          	cmp    r14,0x3
  40cfef:	75 ec                	jne    40cfdd <__page_bump_valloc+0xbd>
{ l->o = 0; }
  40cff1:	48 c7 83 c0 00 00 00 	mov    QWORD PTR [rbx+0xc0],0x0
  40cff8:	00 00 00 00 
	ret_addr = __page_bump_mem_alloc(ci, &ci->vas_frontier, &ci->vasrange_frontier[0], sz);
	ret_addr += rounding;
  40cffc:	4d 8d 04 13          	lea    r8,[r11+rdx*1]
	ps_lock_release(&ci->va_lock);
	assert(ret_addr % align == 0);
  40d000:	31 d2                	xor    edx,edx
  40d002:	4c 89 c0             	mov    rax,r8
  40d005:	49 f7 f7             	div    r15
  40d008:	48 85 d2             	test   rdx,rdx
  40d00b:	0f 85 e7 00 00 00    	jne    40d0f8 <__page_bump_valloc+0x1d8>

	return ret_addr;
}
  40d011:	48 83 c4 38          	add    rsp,0x38
  40d015:	4c 89 c0             	mov    rax,r8
  40d018:	5b                   	pop    rbx
  40d019:	41 5c                	pop    r12
  40d01b:	41 5d                	pop    r13
  40d01d:	41 5e                	pop    r14
  40d01f:	41 5f                	pop    r15
  40d021:	5d                   	pop    rbp
  40d022:	c3                   	ret    
  40d023:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
			retaddr = __bump_mem_expand_range(meta, ci->pgtbl_cap, heap_vaddr, sz, pgtbl_lvl | pgtbl_flag);
  40d028:	44 8b 45 c4          	mov    r8d,DWORD PTR [rbp-0x3c]
  40d02c:	48 8b 33             	mov    rsi,QWORD PTR [rbx]
  40d02f:	4c 89 e1             	mov    rcx,r12
  40d032:	4c 89 4d a0          	mov    QWORD PTR [rbp-0x60],r9
  40d036:	48 8b 7d b8          	mov    rdi,QWORD PTR [rbp-0x48]
  40d03a:	4c 89 5d a8          	mov    QWORD PTR [rbp-0x58],r11
  40d03e:	45 09 f0             	or     r8d,r14d
  40d041:	48 89 55 b0          	mov    QWORD PTR [rbp-0x50],rdx
  40d045:	e8 26 fc ff ff       	call   40cc70 <__bump_mem_expand_range>
			assert(retaddr);
  40d04a:	48 85 c0             	test   rax,rax
  40d04d:	0f 84 c1 00 00 00    	je     40d114 <__page_bump_valloc+0x1f4>
		return round_up_to_pgt1_page(vaddr);
  40d053:	4c 8b 4d a0          	mov    r9,QWORD PTR [rbp-0x60]
  40d057:	4d 8d 56 08          	lea    r10,[r14+0x8]
  40d05b:	4c 8b 5d a8          	mov    r11,QWORD PTR [rbp-0x58]
				tmp_frontier = cos_pgtbl_round_up_to_page(pgtbl_lvl, heap_vaddr + sz);
  40d05f:	45 89 f0             	mov    r8d,r14d
  40d062:	48 8b 55 b0          	mov    rdx,QWORD PTR [rbp-0x50]
		return round_up_to_pgt1_page(vaddr);
  40d066:	49 8d 81 ff ff ff 3f 	lea    rax,[r9+0x3fffffff]
		return round_up_to_pgt2_page(vaddr);
  40d06d:	49 8d b1 ff ff 1f 00 	lea    rsi,[r9+0x1fffff]
		return round_up_to_pgt1_page(vaddr);
  40d074:	48 25 00 00 00 c0    	and    rax,0xffffffffc0000000
		return round_up_to_pgt2_page(vaddr);
  40d07a:	48 81 e6 00 00 e0 ff 	and    rsi,0xffffffffffe00000
		return round_up_to_pgt1_page(vaddr);
  40d081:	48 89 c7             	mov    rdi,rax
				vaddr_t tmp = ps_load(&ci->vasrange_frontier[pgtbl_lvl]);
  40d084:	4a 8b 44 d3 08       	mov    rax,QWORD PTR [rbx+r10*8+0x8]
		return round_up_to_pgt1_page(vaddr);
  40d089:	48 89 f9             	mov    rcx,rdi
	switch (pgtbl_lvl)
  40d08c:	49 83 fe 01          	cmp    r14,0x1
  40d090:	74 0c                	je     40d09e <__page_bump_valloc+0x17e>
		return round_up_to_pgt0_page(vaddr);
  40d092:	48 8b 4d c8          	mov    rcx,QWORD PTR [rbp-0x38]
	switch (pgtbl_lvl)
  40d096:	41 83 f8 02          	cmp    r8d,0x2
		return round_up_to_pgt0_page(vaddr);
  40d09a:	48 0f 44 ce          	cmove  rcx,rsi
				if (tmp >= heap_vaddr + sz) break;
  40d09e:	49 39 c1             	cmp    r9,rax
  40d0a1:	0f 86 3c ff ff ff    	jbe    40cfe3 <__page_bump_valloc+0xc3>
        __asm__ __volatile__("lock " PS_CAS_STR
  40d0a7:	f0 49 0f b1 4d 00    	lock cmpxchg QWORD PTR [r13+0x0],rcx
  40d0ad:	0f 94 c0             	sete   al
				vaddr_t tmp = ps_load(&ci->vasrange_frontier[pgtbl_lvl]);
  40d0b0:	4a 8b 44 d3 08       	mov    rax,QWORD PTR [rbx+r10*8+0x8]
		return round_up_to_pgt1_page(vaddr);
  40d0b5:	48 89 f9             	mov    rcx,rdi
	switch (pgtbl_lvl)
  40d0b8:	49 83 fe 01          	cmp    r14,0x1
  40d0bc:	75 d4                	jne    40d092 <__page_bump_valloc+0x172>
  40d0be:	eb de                	jmp    40d09e <__page_bump_valloc+0x17e>
  40d0c0:	be 2e 00 00 00       	mov    esi,0x2e
  40d0c5:	bf 40 d9 41 00       	mov    edi,0x41d940
  40d0ca:	e8 01 d0 ff ff       	call   40a0d0 <cos_print_str>
	assert(sz % PAGE_SIZE == 0);
  40d0cf:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d0d6:	00 00 00 00 
  40d0da:	0f 0b                	ud2    
  40d0dc:	be 2e 00 00 00       	mov    esi,0x2e
  40d0e1:	bf 70 d9 41 00       	mov    edi,0x41d970
  40d0e6:	e8 e5 cf ff ff       	call   40a0d0 <cos_print_str>
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  40d0eb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d0f2:	00 00 00 00 
  40d0f6:	0f 0b                	ud2    
  40d0f8:	be 2e 00 00 00       	mov    esi,0x2e
  40d0fd:	bf d0 d9 41 00       	mov    edi,0x41d9d0
  40d102:	e8 c9 cf ff ff       	call   40a0d0 <cos_print_str>
	assert(ret_addr % align == 0);
  40d107:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d10e:	00 00 00 00 
  40d112:	0f 0b                	ud2    
  40d114:	be 2e 00 00 00       	mov    esi,0x2e
  40d119:	bf a0 d9 41 00       	mov    edi,0x41d9a0
  40d11e:	e8 ad cf ff ff       	call   40a0d0 <cos_print_str>
			assert(retaddr);
  40d123:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d12a:	00 00 00 00 
  40d12e:	0f 0b                	ud2    

000000000040d130 <__page_bump_alloc>:

static vaddr_t
__page_bump_alloc(struct cos_compinfo *ci, size_t sz, size_t align)
{
  40d130:	55                   	push   rbp
  40d131:	48 89 e5             	mov    rbp,rsp
  40d134:	41 57                	push   r15
  40d136:	49 89 ff             	mov    r15,rdi
  40d139:	41 56                	push   r14
  40d13b:	41 55                	push   r13
  40d13d:	41 54                	push   r12
  40d13f:	53                   	push   rbx
  40d140:	48 89 f3             	mov    rbx,rsi
  40d143:	48 83 ec 48          	sub    rsp,0x48
	return ci->memsrc;
  40d147:	48 8b 47 60          	mov    rax,QWORD PTR [rdi+0x60]
  40d14b:	48 89 45 a8          	mov    QWORD PTR [rbp-0x58],rax

	/*
	 * Allocate the virtual address range to map into.  This is
	 * atomic, so we will get a contiguous range of sz.
	 */
	heap_vaddr = __page_bump_valloc(ci, sz, align);
  40d14f:	e8 cc fd ff ff       	call   40cf20 <__page_bump_valloc>
  40d154:	48 89 45 98          	mov    QWORD PTR [rbp-0x68],rax
	if (unlikely(!heap_vaddr)) return 0;
  40d158:	48 85 c0             	test   rax,rax
  40d15b:	0f 84 ea 01 00 00    	je     40d34b <__page_bump_alloc+0x21b>
  40d161:	48 89 c7             	mov    rdi,rax
	heap_limit = heap_vaddr + sz;
  40d164:	48 89 d8             	mov    rax,rbx
  40d167:	48 01 f8             	add    rax,rdi
  40d16a:	48 89 7d b8          	mov    QWORD PTR [rbp-0x48],rdi
  40d16e:	48 89 45 a0          	mov    QWORD PTR [rbp-0x60],rax
	assert(heap_limit > heap_vaddr);
  40d172:	48 39 c7             	cmp    rdi,rax
  40d175:	0f 83 eb 01 00 00    	jae    40d366 <__page_bump_alloc+0x236>
	return ci->memsrc;
  40d17b:	4d 8b 77 60          	mov    r14,QWORD PTR [r15+0x60]
  40d17f:	41 bd 01 00 00 00    	mov    r13d,0x1
  40d185:	45 31 d2             	xor    r10d,r10d
	assert(ci && ci == __compinfo_metacap(__ci));
  40d188:	4d 85 f6             	test   r14,r14
  40d18b:	0f 84 7c 01 00 00    	je     40d30d <__page_bump_alloc+0x1dd>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40d191:	49 8d 96 b8 00 00 00 	lea    rdx,[r14+0xb8]
  40d198:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40d19f:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  40d1a0:	4c 89 d0             	mov    rax,r10
  40d1a3:	f0 4c 0f b1 2a       	lock cmpxchg QWORD PTR [rdx],r13
  40d1a8:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40d1ab:	84 c0                	test   al,al
  40d1ad:	74 f1                	je     40d1a0 <__page_bump_alloc+0x70>
        __asm__ __volatile__("lock " PS_FAA_STR
  40d1af:	bb 00 10 00 00       	mov    ebx,0x1000
  40d1b4:	f0 49 0f c1 5e 70    	lock xadd QWORD PTR [r14+0x70],rbx
	if (ret >= *frontier || *frontier - ret > RETYPE_MEM_SIZE) {
  40d1ba:	49 8b 96 88 00 00 00 	mov    rdx,QWORD PTR [r14+0x88]
  40d1c1:	48 39 d3             	cmp    rbx,rdx
  40d1c4:	73 0e                	jae    40d1d4 <__page_bump_alloc+0xa4>
  40d1c6:	48 89 d0             	mov    rax,rdx
  40d1c9:	48 29 d8             	sub    rax,rbx
  40d1cc:	48 3d 00 10 00 00    	cmp    rax,0x1000
  40d1d2:	76 43                	jbe    40d217 <__page_bump_alloc+0xe7>
		vaddr_t ptr_tmp = *ptr, front_tmp = *frontier;
  40d1d4:	49 8b 46 70          	mov    rax,QWORD PTR [r14+0x70]
		if (ci->mi.untyped_ptr == ci->mi.untyped_frontier) goto error;
  40d1d8:	49 8b 8e 80 00 00 00 	mov    rcx,QWORD PTR [r14+0x80]
  40d1df:	49 39 4e 68          	cmp    QWORD PTR [r14+0x68],rcx
  40d1e3:	0f 84 57 01 00 00    	je     40d340 <__page_bump_alloc+0x210>
  40d1e9:	bb 00 10 00 00       	mov    ebx,0x1000
  40d1ee:	f0 49 0f c1 5e 68    	lock xadd QWORD PTR [r14+0x68],rbx
		if (ps_cas(ptr, ptr_tmp, ret + PAGE_SIZE)) {
  40d1f4:	48 8d 8b 00 10 00 00 	lea    rcx,[rbx+0x1000]
        __asm__ __volatile__("lock " PS_CAS_STR
  40d1fb:	f0 49 0f b1 4e 70    	lock cmpxchg QWORD PTR [r14+0x70],rcx
  40d201:	0f 94 c0             	sete   al
  40d204:	84 c0                	test   al,al
  40d206:	74 0f                	je     40d217 <__page_bump_alloc+0xe7>
  40d208:	48 89 d0             	mov    rax,rdx
  40d20b:	f0 49 0f b1 8e 88 00 	lock cmpxchg QWORD PTR [r14+0x88],rcx
  40d212:	00 00 
  40d214:	0f 94 c0             	sete   al
	if (retype && (ret % RETYPE_MEM_SIZE == 0)) {
  40d217:	48 89 da             	mov    rdx,rbx
  40d21a:	81 e2 ff 0f 00 00    	and    edx,0xfff
  40d220:	0f 85 0a 01 00 00    	jne    40d330 <__page_bump_alloc+0x200>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40d226:	41 8b 86 98 00 00 00 	mov    eax,DWORD PTR [r14+0x98]
	__asm__ __volatile__(
  40d22d:	48 89 d6             	mov    rsi,rdx
  40d230:	48 89 d7             	mov    rdi,rdx
  40d233:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40d237:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40d23a:	05 19 00 01 00       	add    eax,0x10019
	__asm__ __volatile__(
  40d23f:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40d242:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40d246:	48 89 cd             	mov    rbp,rcx
  40d249:	49 b8 60 d2 40 00 00 	movabs r8,0x40d260
  40d250:	00 00 00 
  40d253:	0f 05                	syscall 
  40d255:	0f 1f 00             	nop    DWORD PTR [rax]
  40d258:	eb 0d                	jmp    40d267 <__page_bump_alloc+0x137>
  40d25a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40d260:	b9 00 00 00 00       	mov    ecx,0x0
  40d265:	eb 05                	jmp    40d26c <__page_bump_alloc+0x13c>
  40d267:	b9 01 00 00 00       	mov    ecx,0x1
  40d26c:	5d                   	pop    rbp
  40d26d:	5c                   	pop    rsp
		if (call_cap_op(ci->mi.pgtbl_cap, op, ret, 0, 0, 0)) goto error;
  40d26e:	85 c0                	test   eax,eax
  40d270:	0f 85 ca 00 00 00    	jne    40d340 <__page_bump_alloc+0x210>
{ l->o = 0; }
  40d276:	49 c7 86 b8 00 00 00 	mov    QWORD PTR [r14+0xb8],0x0
  40d27d:	00 00 00 00 
	 */
	for (heap_cursor = heap_vaddr; heap_cursor < heap_limit; heap_cursor += PAGE_SIZE) {
		vaddr_t umem;

		umem = __umem_bump_alloc(ci);
		if (!umem) return 0;
  40d281:	48 85 db             	test   rbx,rbx
  40d284:	0f 84 c1 00 00 00    	je     40d34b <__page_bump_alloc+0x21b>

		/* Actually map in the memory. */
		if (call_cap_op(meta->mi.pgtbl_cap, CAPTBL_OP_MEMACTIVATE, umem, ci->pgtbl_cap, heap_cursor, PAGE_ORDER)) {
  40d28a:	48 8b 45 a8          	mov    rax,QWORD PTR [rbp-0x58]
  40d28e:	49 8b 37             	mov    rsi,QWORD PTR [r15]
  40d291:	ba 0c 00 00 00       	mov    edx,0xc
  40d296:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  40d29a:	48 8b 7d b8          	mov    rdi,QWORD PTR [rbp-0x48]
  40d29e:	48 8b 80 98 00 00 00 	mov    rax,QWORD PTR [rax+0x98]
  40d2a5:	48 89 45 b0          	mov    QWORD PTR [rbp-0x50],rax
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40d2a9:	8b 45 b0             	mov    eax,DWORD PTR [rbp-0x50]
  40d2ac:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40d2af:	05 17 00 01 00       	add    eax,0x10017
	__asm__ __volatile__(
  40d2b4:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40d2b7:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40d2bb:	48 89 cd             	mov    rbp,rcx
  40d2be:	49 b8 d8 d2 40 00 00 	movabs r8,0x40d2d8
  40d2c5:	00 00 00 
  40d2c8:	0f 05                	syscall 
  40d2ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40d2d0:	eb 0d                	jmp    40d2df <__page_bump_alloc+0x1af>
  40d2d2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40d2d8:	b9 00 00 00 00       	mov    ecx,0x0
  40d2dd:	eb 05                	jmp    40d2e4 <__page_bump_alloc+0x1b4>
  40d2df:	b9 01 00 00 00       	mov    ecx,0x1
  40d2e4:	5d                   	pop    rbp
  40d2e5:	5c                   	pop    rsp
  40d2e6:	85 c0                	test   eax,eax
  40d2e8:	0f 85 94 00 00 00    	jne    40d382 <__page_bump_alloc+0x252>
	for (heap_cursor = heap_vaddr; heap_cursor < heap_limit; heap_cursor += PAGE_SIZE) {
  40d2ee:	48 81 45 b8 00 10 00 	add    QWORD PTR [rbp-0x48],0x1000
  40d2f5:	00 
  40d2f6:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  40d2fa:	48 39 45 a0          	cmp    QWORD PTR [rbp-0x60],rax
  40d2fe:	76 53                	jbe    40d353 <__page_bump_alloc+0x223>
	return ci->memsrc;
  40d300:	4d 8b 77 60          	mov    r14,QWORD PTR [r15+0x60]
	assert(ci && ci == __compinfo_metacap(__ci));
  40d304:	4d 85 f6             	test   r14,r14
  40d307:	0f 85 84 fe ff ff    	jne    40d191 <__page_bump_alloc+0x61>
  40d30d:	be 2e 00 00 00       	mov    esi,0x2e
  40d312:	bf 00 d7 41 00       	mov    edi,0x41d700
  40d317:	e8 b4 cd ff ff       	call   40a0d0 <cos_print_str>
  40d31c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d323:	00 00 00 00 
  40d327:	0f 0b                	ud2    
  40d329:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  40d330:	49 c7 86 b8 00 00 00 	mov    QWORD PTR [r14+0xb8],0x0
  40d337:	00 00 00 00 
		if (!umem) return 0;
  40d33b:	e9 4a ff ff ff       	jmp    40d28a <__page_bump_alloc+0x15a>
  40d340:	49 c7 86 b8 00 00 00 	mov    QWORD PTR [r14+0xb8],0x0
  40d347:	00 00 00 00 
  40d34b:	48 c7 45 98 00 00 00 	mov    QWORD PTR [rbp-0x68],0x0
  40d352:	00 
			return 0;
		}
	}

	return heap_vaddr;
}
  40d353:	48 8b 45 98          	mov    rax,QWORD PTR [rbp-0x68]
  40d357:	48 83 c4 48          	add    rsp,0x48
  40d35b:	5b                   	pop    rbx
  40d35c:	41 5c                	pop    r12
  40d35e:	41 5d                	pop    r13
  40d360:	41 5e                	pop    r14
  40d362:	41 5f                	pop    r15
  40d364:	5d                   	pop    rbp
  40d365:	c3                   	ret    
  40d366:	be 2e 00 00 00       	mov    esi,0x2e
  40d36b:	bf 00 da 41 00       	mov    edi,0x41da00
  40d370:	e8 5b cd ff ff       	call   40a0d0 <cos_print_str>
	assert(heap_limit > heap_vaddr);
  40d375:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d37c:	00 00 00 00 
  40d380:	0f 0b                	ud2    
  40d382:	be 2e 00 00 00       	mov    esi,0x2e
  40d387:	bf 30 da 41 00       	mov    edi,0x41da30
  40d38c:	e8 3f cd ff ff       	call   40a0d0 <cos_print_str>
			assert(0);
  40d391:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d398:	00 00 00 00 
  40d39c:	0f 0b                	ud2    
  40d39e:	66 90                	xchg   ax,ax

000000000040d3a0 <__bump_mem_expand_intern>:
{
  40d3a0:	55                   	push   rbp
  40d3a1:	48 89 e5             	mov    rbp,rsp
  40d3a4:	41 57                	push   r15
  40d3a6:	41 56                	push   r14
  40d3a8:	41 55                	push   r13
  40d3aa:	41 54                	push   r12
  40d3ac:	53                   	push   rbx
  40d3ad:	48 83 ec 28          	sub    rsp,0x28
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  40d3b1:	48 3b 7f 60          	cmp    rdi,QWORD PTR [rdi+0x60]
  40d3b5:	0f 85 b3 01 00 00    	jne    40d56e <__bump_mem_expand_intern+0x1ce>
  40d3bb:	49 89 f6             	mov    r14,rsi
  40d3be:	49 89 d7             	mov    r15,rdx
  40d3c1:	4c 8d 55 c0          	lea    r10,[rbp-0x40]
  40d3c5:	49 89 cd             	mov    r13,rcx
	if (!intern) {
  40d3c8:	48 85 c9             	test   rcx,rcx
  40d3cb:	0f 85 c9 00 00 00    	jne    40d49a <__bump_mem_expand_intern+0xfa>
  40d3d1:	49 89 fc             	mov    r12,rdi
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40d3d4:	48 8d 97 b0 00 00 00 	lea    rdx,[rdi+0xb0]
        __asm__ __volatile__("lock " PS_CAS_STR
  40d3db:	be 01 00 00 00       	mov    esi,0x1
  40d3e0:	31 c9                	xor    ecx,ecx
  40d3e2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40d3e8:	48 89 c8             	mov    rax,rcx
  40d3eb:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40d3f0:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40d3f3:	84 c0                	test   al,al
  40d3f5:	74 f1                	je     40d3e8 <__bump_mem_expand_intern+0x48>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40d3f7:	41 f6 44 24 38 03    	test   BYTE PTR [r12+0x38],0x3
  40d3fd:	0f 84 41 01 00 00    	je     40d544 <__bump_mem_expand_intern+0x1a4>
  40d403:	4c 89 45 b8          	mov    QWORD PTR [rbp-0x48],r8
        __asm__ __volatile__("lock " PS_FAA_STR
  40d407:	bb 04 00 00 00       	mov    ebx,0x4
  40d40c:	f0 49 0f c1 5c 24 38 	lock xadd QWORD PTR [r12+0x38],rbx
{ l->o = 0; }
  40d413:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40d41a:	00 00 00 00 00 
	return __mem_bump_alloc(ci, 1, 1);
  40d41f:	4c 89 e7             	mov    rdi,r12
	ret = ps_faa(capsz_frontier, sz);
  40d422:	49 89 dd             	mov    r13,rbx
	return __mem_bump_alloc(ci, 1, 1);
  40d425:	e8 36 f4 ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40d42a:	48 89 c7             	mov    rdi,rax
		if (pte_cap == 0 || ptemem_cap == 0) {
  40d42d:	48 85 db             	test   rbx,rbx
  40d430:	0f 84 f2 00 00 00    	je     40d528 <__bump_mem_expand_intern+0x188>
  40d436:	48 85 c0             	test   rax,rax
  40d439:	4c 8b 45 b8          	mov    r8,QWORD PTR [rbp-0x48]
  40d43d:	0f 84 e5 00 00 00    	je     40d528 <__bump_mem_expand_intern+0x188>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40d443:	41 8b 44 24 08       	mov    eax,DWORD PTR [r12+0x8]
	__asm__ __volatile__(
  40d448:	4c 8d 55 c0          	lea    r10,[rbp-0x40]
  40d44c:	49 8b b4 24 98 00 00 	mov    rsi,QWORD PTR [r12+0x98]
  40d453:	00 
		if (call_cap_op(meta->captbl_cap, CAPTBL_OP_PGTBLACTIVATE, pte_cap, meta->mi.pgtbl_cap, ptemem_cap,
  40d454:	49 8d 50 01          	lea    rdx,[r8+0x1]
  40d458:	4c 89 d1             	mov    rcx,r10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40d45b:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40d45e:	05 1c 00 01 00       	add    eax,0x1001c
	__asm__ __volatile__(
  40d463:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40d466:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40d46a:	48 89 cd             	mov    rbp,rcx
  40d46d:	49 b8 88 d4 40 00 00 	movabs r8,0x40d488
  40d474:	00 00 00 
  40d477:	0f 05                	syscall 
  40d479:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  40d480:	eb 0d                	jmp    40d48f <__bump_mem_expand_intern+0xef>
  40d482:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40d488:	b9 00 00 00 00       	mov    ecx,0x0
  40d48d:	eb 05                	jmp    40d494 <__bump_mem_expand_intern+0xf4>
  40d48f:	b9 01 00 00 00       	mov    ecx,0x1
  40d494:	5d                   	pop    rbp
  40d495:	5c                   	pop    rsp
  40d496:	85 c0                	test   eax,eax
  40d498:	75 5e                	jne    40d4f8 <__bump_mem_expand_intern+0x158>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40d49a:	41 c1 e6 10          	shl    r14d,0x10
	__asm__ __volatile__(
  40d49e:	31 d2                	xor    edx,edx
  40d4a0:	4c 89 eb             	mov    rbx,r13
  40d4a3:	4c 89 fe             	mov    rsi,r15
	cap_no += op;
  40d4a6:	41 8d 86 01 00 01 00 	lea    eax,[r14+0x10001]
	__asm__ __volatile__(
  40d4ad:	48 89 d7             	mov    rdi,rdx
  40d4b0:	4c 89 d1             	mov    rcx,r10
  40d4b3:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40d4b6:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40d4ba:	48 89 cd             	mov    rbp,rcx
  40d4bd:	49 b8 d8 d4 40 00 00 	movabs r8,0x40d4d8
  40d4c4:	00 00 00 
  40d4c7:	0f 05                	syscall 
  40d4c9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  40d4d0:	eb 0d                	jmp    40d4df <__bump_mem_expand_intern+0x13f>
  40d4d2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40d4d8:	b9 00 00 00 00       	mov    ecx,0x0
  40d4dd:	eb 05                	jmp    40d4e4 <__bump_mem_expand_intern+0x144>
  40d4df:	b9 01 00 00 00       	mov    ecx,0x1
  40d4e4:	5d                   	pop    rbp
  40d4e5:	5c                   	pop    rsp
}
  40d4e6:	48 83 c4 28          	add    rsp,0x28
  40d4ea:	4c 89 e8             	mov    rax,r13
  40d4ed:	5b                   	pop    rbx
  40d4ee:	41 5c                	pop    r12
  40d4f0:	41 5d                	pop    r13
  40d4f2:	41 5e                	pop    r14
  40d4f4:	41 5f                	pop    r15
  40d4f6:	5d                   	pop    rbp
  40d4f7:	c3                   	ret    
  40d4f8:	be 2e 00 00 00       	mov    esi,0x2e
  40d4fd:	bf 10 d9 41 00       	mov    edi,0x41d910
  40d502:	e8 c9 cb ff ff       	call   40a0d0 <cos_print_str>
				assert(0); /* race? */
  40d507:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d50e:	00 00 00 00 
  40d512:	0f 0b                	ud2    
  40d514:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40d51b:	00 00 00 00 00 
	return __mem_bump_alloc(ci, 1, 1);
  40d520:	4c 89 e7             	mov    rdi,r12
  40d523:	e8 38 f3 ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40d528:	be 2e 00 00 00       	mov    esi,0x2e
  40d52d:	bf e0 d8 41 00       	mov    edi,0x41d8e0
  40d532:	e8 99 cb ff ff       	call   40a0d0 <cos_print_str>
			assert(0);
  40d537:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d53e:	00 00 00 00 
  40d542:	0f 0b                	ud2    
		if (__capid_captbl_check_expand(ci)) goto error;
  40d544:	4c 89 e7             	mov    rdi,r12
  40d547:	4c 89 45 b8          	mov    QWORD PTR [rbp-0x48],r8
  40d54b:	e8 90 f4 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40d550:	4c 8b 45 b8          	mov    r8,QWORD PTR [rbp-0x48]
  40d554:	85 c0                	test   eax,eax
  40d556:	75 bc                	jne    40d514 <__bump_mem_expand_intern+0x174>
        __asm__ __volatile__("lock " PS_FAA_STR
  40d558:	b8 04 00 00 00       	mov    eax,0x4
  40d55d:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40d564:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  40d569:	e9 95 fe ff ff       	jmp    40d403 <__bump_mem_expand_intern+0x63>
  40d56e:	be 2e 00 00 00       	mov    esi,0x2e
  40d573:	bf b0 d8 41 00       	mov    edi,0x41d8b0
  40d578:	e8 53 cb ff ff       	call   40a0d0 <cos_print_str>
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  40d57d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d584:	00 00 00 00 
  40d588:	0f 0b                	ud2    
  40d58a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000040d590 <__round_to_pgt0_page>:
vaddr_t __round_to_pgt0_page(vaddr_t vaddr) { return round_to_pgt0_page(vaddr); }
  40d590:	f3 0f 1e fa          	endbr64 
  40d594:	48 b8 00 00 00 00 80 	movabs rax,0xffffff8000000000
  40d59b:	ff ff ff 
  40d59e:	48 21 f8             	and    rax,rdi
  40d5a1:	c3                   	ret    
  40d5a2:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40d5a9:	00 00 00 00 
  40d5ad:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040d5b0 <__round_up_to_pgt0_page>:
vaddr_t __round_up_to_pgt0_page(vaddr_t vaddr) { return round_up_to_pgt0_page(vaddr); }
  40d5b0:	f3 0f 1e fa          	endbr64 
  40d5b4:	48 b8 ff ff ff ff 7f 	movabs rax,0x7fffffffff
  40d5bb:	00 00 00 
  40d5be:	48 ba 00 00 00 00 80 	movabs rdx,0xffffff8000000000
  40d5c5:	ff ff ff 
  40d5c8:	48 01 f8             	add    rax,rdi
  40d5cb:	48 21 d0             	and    rax,rdx
  40d5ce:	c3                   	ret    
  40d5cf:	90                   	nop

000000000040d5d0 <__round_to_pgt1_page>:
vaddr_t __round_to_pgt1_page(vaddr_t vaddr) { return round_to_pgt1_page(vaddr); }
  40d5d0:	f3 0f 1e fa          	endbr64 
  40d5d4:	48 89 f8             	mov    rax,rdi
  40d5d7:	48 25 00 00 00 c0    	and    rax,0xffffffffc0000000
  40d5dd:	c3                   	ret    
  40d5de:	66 90                	xchg   ax,ax

000000000040d5e0 <__round_up_to_pgt1_page>:
vaddr_t __round_up_to_pgt1_page(vaddr_t vaddr) { return round_up_to_pgt1_page(vaddr); }
  40d5e0:	f3 0f 1e fa          	endbr64 
  40d5e4:	48 8d 87 ff ff ff 3f 	lea    rax,[rdi+0x3fffffff]
  40d5eb:	48 25 00 00 00 c0    	and    rax,0xffffffffc0000000
  40d5f1:	c3                   	ret    
  40d5f2:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40d5f9:	00 00 00 00 
  40d5fd:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040d600 <__round_to_pgt2_page>:
vaddr_t __round_to_pgt2_page(vaddr_t vaddr) { return round_to_pgt2_page(vaddr); }
  40d600:	f3 0f 1e fa          	endbr64 
  40d604:	48 89 f8             	mov    rax,rdi
  40d607:	48 25 00 00 e0 ff    	and    rax,0xffffffffffe00000
  40d60d:	c3                   	ret    
  40d60e:	66 90                	xchg   ax,ax

000000000040d610 <__round_up_to_pgt2_page>:
vaddr_t __round_up_to_pgt2_page(vaddr_t vaddr) { return round_up_to_pgt2_page(vaddr); }
  40d610:	f3 0f 1e fa          	endbr64 
  40d614:	48 8d 87 ff ff 1f 00 	lea    rax,[rdi+0x1fffff]
  40d61b:	48 25 00 00 e0 ff    	and    rax,0xffffffffffe00000
  40d621:	c3                   	ret    
  40d622:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40d629:	00 00 00 00 
  40d62d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040d630 <cos_pgtbl_get_range>:
{
  40d630:	f3 0f 1e fa          	endbr64 
  40d634:	31 c0                	xor    eax,eax
  40d636:	83 ff 02             	cmp    edi,0x2
  40d639:	77 0a                	ja     40d645 <cos_pgtbl_get_range+0x15>
  40d63b:	89 ff                	mov    edi,edi
  40d63d:	48 8b 04 fd 70 ea 41 	mov    rax,QWORD PTR [rdi*8+0x41ea70]
  40d644:	00 
}
  40d645:	c3                   	ret    
  40d646:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40d64d:	00 00 00 

000000000040d650 <cos_pgtbl_round_to_page>:
{
  40d650:	f3 0f 1e fa          	endbr64 
		return round_to_pgt1_page(vaddr);
  40d654:	48 89 f0             	mov    rax,rsi
  40d657:	48 25 00 00 00 c0    	and    rax,0xffffffffc0000000
	switch (pgtbl_lvl)
  40d65d:	83 ff 01             	cmp    edi,0x1
  40d660:	74 14                	je     40d676 <cos_pgtbl_round_to_page+0x26>
		return round_to_pgt2_page(vaddr);
  40d662:	48 89 f0             	mov    rax,rsi
  40d665:	48 25 00 00 e0 ff    	and    rax,0xffffffffffe00000
	switch (pgtbl_lvl)
  40d66b:	83 ff 02             	cmp    edi,0x2
  40d66e:	74 06                	je     40d676 <cos_pgtbl_round_to_page+0x26>
  40d670:	31 c0                	xor    eax,eax
  40d672:	85 ff                	test   edi,edi
  40d674:	74 0a                	je     40d680 <cos_pgtbl_round_to_page+0x30>
}
  40d676:	c3                   	ret    
  40d677:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40d67e:	00 00 
		return round_to_pgt0_page(vaddr);
  40d680:	48 b8 00 00 00 00 80 	movabs rax,0xffffff8000000000
  40d687:	ff ff ff 
  40d68a:	48 21 f0             	and    rax,rsi
}
  40d68d:	c3                   	ret    
  40d68e:	66 90                	xchg   ax,ax

000000000040d690 <cos_pgtbl_round_up_to_page>:
{
  40d690:	f3 0f 1e fa          	endbr64 
	switch (pgtbl_lvl)
  40d694:	83 ff 01             	cmp    edi,0x1
  40d697:	74 47                	je     40d6e0 <cos_pgtbl_round_up_to_page+0x50>
  40d699:	83 ff 02             	cmp    edi,0x2
  40d69c:	74 2a                	je     40d6c8 <cos_pgtbl_round_up_to_page+0x38>
  40d69e:	31 c0                	xor    eax,eax
  40d6a0:	85 ff                	test   edi,edi
  40d6a2:	74 04                	je     40d6a8 <cos_pgtbl_round_up_to_page+0x18>
}
  40d6a4:	c3                   	ret    
  40d6a5:	0f 1f 00             	nop    DWORD PTR [rax]
		return round_up_to_pgt0_page(vaddr);
  40d6a8:	48 b8 ff ff ff ff 7f 	movabs rax,0x7fffffffff
  40d6af:	00 00 00 
  40d6b2:	48 ba 00 00 00 00 80 	movabs rdx,0xffffff8000000000
  40d6b9:	ff ff ff 
  40d6bc:	48 01 f0             	add    rax,rsi
  40d6bf:	48 21 d0             	and    rax,rdx
  40d6c2:	c3                   	ret    
  40d6c3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		return round_up_to_pgt2_page(vaddr);
  40d6c8:	48 8d 86 ff ff 1f 00 	lea    rax,[rsi+0x1fffff]
  40d6cf:	48 25 00 00 e0 ff    	and    rax,0xffffffffffe00000
}
  40d6d5:	c3                   	ret    
  40d6d6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40d6dd:	00 00 00 
		return round_up_to_pgt1_page(vaddr);
  40d6e0:	48 8d 86 ff ff ff 3f 	lea    rax,[rsi+0x3fffffff]
  40d6e7:	48 25 00 00 00 c0    	and    rax,0xffffffffc0000000
  40d6ed:	c3                   	ret    
  40d6ee:	66 90                	xchg   ax,ax

000000000040d6f0 <cos_meminfo_init>:
{
  40d6f0:	f3 0f 1e fa          	endbr64 
	mi->untyped_frontier = untyped_ptr + untyped_sz;
  40d6f4:	48 01 f2             	add    rdx,rsi
  40d6f7:	66 48 0f 6e ce       	movq   xmm1,rsi
	mi->untyped_ptr = mi->umem_ptr = mi->kmem_ptr = mi->umem_frontier = mi->kmem_frontier = untyped_ptr;
  40d6fc:	66 48 0f 6e c6       	movq   xmm0,rsi
	mi->pgtbl_cap        = pgtbl_cap;
  40d701:	48 89 4f 30          	mov    QWORD PTR [rdi+0x30],rcx
	mi->untyped_ptr = mi->umem_ptr = mi->kmem_ptr = mi->umem_frontier = mi->kmem_frontier = untyped_ptr;
  40d705:	66 48 0f 6e d2       	movq   xmm2,rdx
  40d70a:	66 0f 6c c9          	punpcklqdq xmm1,xmm1
  40d70e:	66 0f 6c c2          	punpcklqdq xmm0,xmm2
  40d712:	0f 11 0f             	movups XMMWORD PTR [rdi],xmm1
  40d715:	0f 11 47 10          	movups XMMWORD PTR [rdi+0x10],xmm0
  40d719:	0f 11 4f 20          	movups XMMWORD PTR [rdi+0x20],xmm1
}
  40d71d:	c3                   	ret    
  40d71e:	66 90                	xchg   ax,ax

000000000040d720 <cos_compinfo_init>:
{
  40d720:	f3 0f 1e fa          	endbr64 
  40d724:	55                   	push   rbp
  40d725:	49 89 d2             	mov    r10,rdx
  40d728:	66 48 0f 6e c6       	movq   xmm0,rsi
  40d72d:	66 49 0f 6e d2       	movq   xmm2,r10
  40d732:	66 0f 6c c2          	punpcklqdq xmm0,xmm2
  40d736:	48 89 e5             	mov    rbp,rsp
  40d739:	48 8b 55 10          	mov    rdx,QWORD PTR [rbp+0x10]
	assert(ci && ci_resources);
  40d73d:	48 85 ff             	test   rdi,rdi
  40d740:	0f 84 19 01 00 00    	je     40d85f <cos_compinfo_init+0x13f>
  40d746:	48 85 d2             	test   rdx,rdx
  40d749:	0f 84 10 01 00 00    	je     40d85f <cos_compinfo_init+0x13f>
	assert(cap_frontier % CAPMAX_ENTRY_SZ == 0);
  40d74f:	41 f6 c1 03          	test   r9b,0x3
  40d753:	0f 85 22 01 00 00    	jne    40d87b <cos_compinfo_init+0x15b>
	ci->memsrc = ci_resources;
  40d759:	48 89 57 60          	mov    QWORD PTR [rdi+0x60],rdx
  40d75d:	48 89 f8             	mov    rax,rdi
	assert(ci_resources->memsrc == ci_resources); /* prevent infinite data-structs */
  40d760:	48 39 52 60          	cmp    QWORD PTR [rdx+0x60],rdx
  40d764:	0f 85 2d 01 00 00    	jne    40d897 <cos_compinfo_init+0x177>
	vaddr_t last_page = round_to_page(heap_ptr - 1);
  40d76a:	49 8d 50 ff          	lea    rdx,[r8-0x1]
	ci->comp_cap     		= comp_cap;
  40d76e:	48 89 4f 10          	mov    QWORD PTR [rdi+0x10],rcx
		return round_up_to_pgt0_page(vaddr);
  40d772:	48 b9 ff ff ff ff 7f 	movabs rcx,0x7fffffffff
  40d779:	00 00 00 
  40d77c:	48 be 00 00 00 00 80 	movabs rsi,0xffffff8000000000
  40d783:	ff ff ff 
	vaddr_t last_page = round_to_page(heap_ptr - 1);
  40d786:	48 81 e2 00 f0 ff ff 	and    rdx,0xfffffffffffff000
	ci->pgtbl_cap    		= pgtbl_cap;
  40d78d:	0f 11 07             	movups XMMWORD PTR [rdi],xmm0
	ci->comp_cap_shared 	= 0;
  40d790:	66 0f ef c0          	pxor   xmm0,xmm0
		return round_up_to_pgt0_page(vaddr);
  40d794:	48 01 d1             	add    rcx,rdx
	ci->comp_cap_shared 	= 0;
  40d797:	0f 11 87 c8 00 00 00 	movups XMMWORD PTR [rdi+0xc8],xmm0
	ci->vas_frontier = heap_ptr;
  40d79e:	66 49 0f 6e c0       	movq   xmm0,r8
		return round_up_to_pgt0_page(vaddr);
  40d7a3:	48 21 f1             	and    rcx,rsi
	ci->cap_frontier 		= 0;
  40d7a6:	48 c7 47 18 00 00 00 	mov    QWORD PTR [rdi+0x18],0x0
  40d7ad:	00 
	ci->vas_frontier = heap_ptr;
  40d7ae:	66 48 0f 6e d9       	movq   xmm3,rcx
		return round_up_to_pgt1_page(vaddr);
  40d7b3:	48 8d 8a ff ff ff 3f 	lea    rcx,[rdx+0x3fffffff]
		return round_up_to_pgt2_page(vaddr);
  40d7ba:	48 81 c2 ff ff 1f 00 	add    rdx,0x1fffff
	ci->vas_frontier = heap_ptr;
  40d7c1:	66 0f 6c c3          	punpcklqdq xmm0,xmm3
		return round_up_to_pgt2_page(vaddr);
  40d7c5:	48 81 e2 00 00 e0 ff 	and    rdx,0xffffffffffe00000
		return round_up_to_pgt1_page(vaddr);
  40d7cc:	48 81 e1 00 00 00 c0 	and    rcx,0xffffffffc0000000
	ci->vas_frontier = heap_ptr;
  40d7d3:	66 48 0f 6e e2       	movq   xmm4,rdx
  40d7d8:	0f 11 47 40          	movups XMMWORD PTR [rdi+0x40],xmm0
	assert(round_up_to_pow2(cap_frontier, CAPMAX_ENTRY_SZ) == cap_frontier);
  40d7dc:	49 8d 51 03          	lea    rdx,[r9+0x3]
	ci->vas_frontier = heap_ptr;
  40d7e0:	66 48 0f 6e c1       	movq   xmm0,rcx
  40d7e5:	66 0f 6c c4          	punpcklqdq xmm0,xmm4
	assert(round_up_to_pow2(cap_frontier, CAPMAX_ENTRY_SZ) == cap_frontier);
  40d7e9:	48 83 e2 fc          	and    rdx,0xfffffffffffffffc
	ci->vas_frontier = heap_ptr;
  40d7ed:	0f 11 47 50          	movups XMMWORD PTR [rdi+0x50],xmm0
	assert(round_up_to_pow2(cap_frontier, CAPMAX_ENTRY_SZ) == cap_frontier);
  40d7f1:	49 39 d1             	cmp    r9,rdx
  40d7f4:	0f 85 b9 00 00 00    	jne    40d8b3 <cos_compinfo_init+0x193>
  40d7fa:	66 49 0f 6e c9       	movq   xmm1,r9
	ci->cap_frontier = cap_frontier;
  40d7ff:	4c 89 4f 18          	mov    QWORD PTR [rdi+0x18],r9
  40d803:	66 0f 6c c9          	punpcklqdq xmm1,xmm1
	if (cap_frontier < CAPTBL_EXPAND_SZ) {
  40d807:	49 83 f9 7f          	cmp    r9,0x7f
  40d80b:	76 43                	jbe    40d850 <cos_compinfo_init+0x130>
		ci->caprange_frontier = round_up_to_pow2(cap_frontier + CAPTBL_EXPAND_SZ, CAPTBL_EXPAND_SZ * 2) - CAPTBL_EXPAND_SZ;
  40d80d:	49 8d 91 7f 01 00 00 	lea    rdx,[r9+0x17f]
  40d814:	30 d2                	xor    dl,dl
  40d816:	48 8d 7a 80          	lea    rdi,[rdx-0x80]
  40d81a:	66 48 0f 6e c7       	movq   xmm0,rdi
		ci->cap16_frontier[i] = ci->cap32_frontier[i] = ci->cap64_frontier[i] = cap_frontier;
  40d81f:	66 49 0f 6e e9       	movq   xmm5,r9
  40d824:	0f 11 48 30          	movups XMMWORD PTR [rax+0x30],xmm1
{ l->o = 0; }
  40d828:	48 c7 80 c0 00 00 00 	mov    QWORD PTR [rax+0xc0],0x0
  40d82f:	00 00 00 00 
  40d833:	66 0f 6c c5          	punpcklqdq xmm0,xmm5
  40d837:	0f 11 40 20          	movups XMMWORD PTR [rax+0x20],xmm0
  40d83b:	66 0f ef c0          	pxor   xmm0,xmm0
  40d83f:	0f 11 80 b0 00 00 00 	movups XMMWORD PTR [rax+0xb0],xmm0
}
  40d846:	5d                   	pop    rbp
  40d847:	c3                   	ret    
  40d848:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40d84f:	00 
		ci->caprange_frontier = round_up_to_pow2(cap_frontier, CAPTBL_EXPAND_SZ);
  40d850:	49 8d 51 7f          	lea    rdx,[r9+0x7f]
  40d854:	48 83 e2 80          	and    rdx,0xffffffffffffff80
  40d858:	66 48 0f 6e c2       	movq   xmm0,rdx
  40d85d:	eb c0                	jmp    40d81f <cos_compinfo_init+0xff>
  40d85f:	be 2e 00 00 00       	mov    esi,0x2e
  40d864:	bf 60 da 41 00       	mov    edi,0x41da60
  40d869:	e8 62 c8 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci && ci_resources);
  40d86e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d875:	00 00 00 00 
  40d879:	0f 0b                	ud2    
  40d87b:	be 2e 00 00 00       	mov    esi,0x2e
  40d880:	bf 90 da 41 00       	mov    edi,0x41da90
  40d885:	e8 46 c8 ff ff       	call   40a0d0 <cos_print_str>
	assert(cap_frontier % CAPMAX_ENTRY_SZ == 0);
  40d88a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d891:	00 00 00 00 
  40d895:	0f 0b                	ud2    
  40d897:	be 2e 00 00 00       	mov    esi,0x2e
  40d89c:	bf c0 da 41 00       	mov    edi,0x41dac0
  40d8a1:	e8 2a c8 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci_resources->memsrc == ci_resources); /* prevent infinite data-structs */
  40d8a6:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d8ad:	00 00 00 00 
  40d8b1:	0f 0b                	ud2    
  40d8b3:	be 2e 00 00 00       	mov    esi,0x2e
  40d8b8:	bf f0 da 41 00       	mov    edi,0x41daf0
  40d8bd:	e8 0e c8 ff ff       	call   40a0d0 <cos_print_str>
	assert(round_up_to_pow2(cap_frontier, CAPMAX_ENTRY_SZ) == cap_frontier);
  40d8c2:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d8c9:	00 00 00 00 
  40d8cd:	0f 0b                	ud2    
  40d8cf:	90                   	nop

000000000040d8d0 <cos_capid_bump_alloc>:
{ return __capid_bump_alloc(ci, cap); }
  40d8d0:	f3 0f 1e fa          	endbr64 
  40d8d4:	55                   	push   rbp
  40d8d5:	48 89 e5             	mov    rbp,rsp
  40d8d8:	41 56                	push   r14
  40d8da:	41 55                	push   r13
  40d8dc:	41 54                	push   r12
  40d8de:	53                   	push   rbx
/* a function instead of a struct to enable inlining + constant prop */
static inline cap_sz_t
__captbl_cap2sz(cap_t c)
{
	/* TODO: optimize for invocation and return */
	switch (c) {
  40d8df:	83 fe 14             	cmp    esi,0x14
  40d8e2:	77 78                	ja     40d95c <cos_capid_bump_alloc+0x8c>
  40d8e4:	b8 01 00 00 00       	mov    eax,0x1
  40d8e9:	89 f1                	mov    ecx,esi
  40d8eb:	48 89 fb             	mov    rbx,rdi
		break;
  40d8ee:	41 bc 04 00 00 00    	mov    r12d,0x4
  40d8f4:	48 d3 e0             	shl    rax,cl
		frontier = &ci->cap64_frontier[cos_cpuid()];
  40d8f7:	4c 8d 77 38          	lea    r14,[rdi+0x38]
  40d8fb:	a9 da 81 1f 00       	test   eax,0x1f81da
  40d900:	74 4e                	je     40d950 <cos_capid_bump_alloc+0x80>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40d902:	48 8d 93 b0 00 00 00 	lea    rdx,[rbx+0xb0]
        __asm__ __volatile__("lock " PS_CAS_STR
  40d909:	be 01 00 00 00       	mov    esi,0x1
  40d90e:	31 c9                	xor    ecx,ecx
  40d910:	48 89 c8             	mov    rax,rcx
  40d913:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40d918:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40d91b:	84 c0                	test   al,al
  40d91d:	74 f1                	je     40d910 <cos_capid_bump_alloc+0x40>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40d91f:	4d 8b 2e             	mov    r13,QWORD PTR [r14]
  40d922:	41 83 e5 03          	and    r13d,0x3
  40d926:	74 68                	je     40d990 <cos_capid_bump_alloc+0xc0>
        __asm__ __volatile__("lock " PS_FAA_STR
  40d928:	4c 89 e0             	mov    rax,r12
  40d92b:	f0 49 0f c1 06       	lock xadd QWORD PTR [r14],rax
  40d930:	49 89 c5             	mov    r13,rax
{ l->o = 0; }
  40d933:	48 c7 83 b0 00 00 00 	mov    QWORD PTR [rbx+0xb0],0x0
  40d93a:	00 00 00 00 
{ return __capid_bump_alloc(ci, cap); }
  40d93e:	4c 89 e8             	mov    rax,r13
  40d941:	5b                   	pop    rbx
  40d942:	41 5c                	pop    r12
  40d944:	41 5d                	pop    r13
  40d946:	41 5e                	pop    r14
  40d948:	5d                   	pop    rbp
  40d949:	c3                   	ret    
  40d94a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40d950:	a9 24 10 00 00       	test   eax,0x1024
  40d955:	75 29                	jne    40d980 <cos_capid_bump_alloc+0xb0>
  40d957:	f6 c4 60             	test   ah,0x60
  40d95a:	75 14                	jne    40d970 <cos_capid_bump_alloc+0xa0>
  40d95c:	49 c7 c5 ff ff ff ff 	mov    r13,0xffffffffffffffff
  40d963:	5b                   	pop    rbx
  40d964:	41 5c                	pop    r12
  40d966:	4c 89 e8             	mov    rax,r13
  40d969:	41 5d                	pop    r13
  40d96b:	41 5e                	pop    r14
  40d96d:	5d                   	pop    rbp
  40d96e:	c3                   	ret    
  40d96f:	90                   	nop
		frontier = &ci->cap32_frontier[cos_cpuid()];
  40d970:	4c 8d 77 30          	lea    r14,[rdi+0x30]
		break;
  40d974:	41 bc 02 00 00 00    	mov    r12d,0x2
  40d97a:	eb 86                	jmp    40d902 <cos_capid_bump_alloc+0x32>
  40d97c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		frontier = &ci->cap16_frontier[cos_cpuid()];
  40d980:	4c 8d 77 28          	lea    r14,[rdi+0x28]
		break;
  40d984:	41 bc 01 00 00 00    	mov    r12d,0x1
  40d98a:	e9 73 ff ff ff       	jmp    40d902 <cos_capid_bump_alloc+0x32>
  40d98f:	90                   	nop
		if (__capid_captbl_check_expand(ci)) goto error;
  40d990:	48 89 df             	mov    rdi,rbx
  40d993:	e8 48 f0 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40d998:	85 c0                	test   eax,eax
  40d99a:	75 97                	jne    40d933 <cos_capid_bump_alloc+0x63>
        __asm__ __volatile__("lock " PS_FAA_STR
  40d99c:	b8 04 00 00 00       	mov    eax,0x4
  40d9a1:	f0 48 0f c1 43 18    	lock xadd QWORD PTR [rbx+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40d9a7:	49 89 06             	mov    QWORD PTR [r14],rax
  40d9aa:	e9 79 ff ff ff       	jmp    40d928 <cos_capid_bump_alloc+0x58>
  40d9af:	90                   	nop

000000000040d9b0 <cos_pgtbl_intern_alloc>:
{
  40d9b0:	f3 0f 1e fa          	endbr64 
  40d9b4:	55                   	push   rbp
  40d9b5:	48 89 e5             	mov    rbp,rsp
  40d9b8:	41 57                	push   r15
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  40d9ba:	45 31 ff             	xor    r15d,r15d
{
  40d9bd:	41 56                	push   r14
  40d9bf:	49 89 ce             	mov    r14,rcx
  40d9c2:	41 55                	push   r13
  40d9c4:	49 89 d5             	mov    r13,rdx
  40d9c7:	41 54                	push   r12
  40d9c9:	49 89 f4             	mov    r12,rsi
  40d9cc:	53                   	push   rbx
  40d9cd:	48 89 fb             	mov    rbx,rdi
  40d9d0:	48 83 ec 08          	sub    rsp,0x8
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  40d9d4:	80 bf d8 00 00 00 01 	cmp    BYTE PTR [rdi+0xd8],0x1
		ret = __bump_mem_expand_range(__compinfo_metacap(ci), cipgtbl, mem_ptr, mem_sz, i | pgtbl_lvl_flag);	
  40d9db:	48 8b 7f 60          	mov    rdi,QWORD PTR [rdi+0x60]
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  40d9df:	41 0f 94 c7          	sete   r15b
  40d9e3:	49 c1 e7 1f          	shl    r15,0x1f
		ret = __bump_mem_expand_range(__compinfo_metacap(ci), cipgtbl, mem_ptr, mem_sz, i | pgtbl_lvl_flag);	
  40d9e7:	45 89 f8             	mov    r8d,r15d
  40d9ea:	41 83 c8 01          	or     r8d,0x1
  40d9ee:	e8 7d f2 ff ff       	call   40cc70 <__bump_mem_expand_range>
  40d9f3:	48 8b 7b 60          	mov    rdi,QWORD PTR [rbx+0x60]
  40d9f7:	45 89 f8             	mov    r8d,r15d
}
  40d9fa:	48 83 c4 08          	add    rsp,0x8
  40d9fe:	5b                   	pop    rbx
		ret = __bump_mem_expand_range(__compinfo_metacap(ci), cipgtbl, mem_ptr, mem_sz, i | pgtbl_lvl_flag);	
  40d9ff:	4c 89 f1             	mov    rcx,r14
  40da02:	4c 89 ea             	mov    rdx,r13
  40da05:	4c 89 e6             	mov    rsi,r12
  40da08:	41 83 c8 02          	or     r8d,0x2
}
  40da0c:	41 5c                	pop    r12
  40da0e:	41 5d                	pop    r13
  40da10:	41 5e                	pop    r14
  40da12:	41 5f                	pop    r15
  40da14:	5d                   	pop    rbp
		ret = __bump_mem_expand_range(__compinfo_metacap(ci), cipgtbl, mem_ptr, mem_sz, i | pgtbl_lvl_flag);	
  40da15:	e9 56 f2 ff ff       	jmp    40cc70 <__bump_mem_expand_range>
  40da1a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000040da20 <cos_pgtbl_intern_expand>:
{
  40da20:	f3 0f 1e fa          	endbr64 
  40da24:	55                   	push   rbp
  40da25:	48 89 e5             	mov    rbp,rsp
  40da28:	41 56                	push   r14
  40da2a:	41 55                	push   r13
  40da2c:	41 54                	push   r12
  40da2e:	53                   	push   rbx
	assert(lvl > 0);
  40da2f:	85 d2                	test   edx,edx
  40da31:	0f 8e b0 00 00 00    	jle    40dae7 <cos_pgtbl_intern_expand+0xc7>
  40da37:	48 89 fb             	mov    rbx,rdi
  40da3a:	49 89 f4             	mov    r12,rsi
  40da3d:	48 8d 8f c0 00 00 00 	lea    rcx,[rdi+0xc0]
  40da44:	31 f6                	xor    esi,esi
  40da46:	bf 01 00 00 00       	mov    edi,0x1
  40da4b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  40da50:	48 89 f0             	mov    rax,rsi
  40da53:	f0 48 0f b1 39       	lock cmpxchg QWORD PTR [rcx],rdi
  40da58:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40da5b:	84 c0                	test   al,al
  40da5d:	74 f1                	je     40da50 <cos_pgtbl_intern_expand+0x30>
	if (ci->vasrange_frontier[lvl] != round_to_pgd_page(mem_ptr)) goto error;
  40da5f:	48 b8 00 00 00 00 80 	movabs rax,0xffffff8000000000
  40da66:	ff ff ff 
  40da69:	4c 63 ea             	movsxd r13,edx
  40da6c:	4e 8d 34 eb          	lea    r14,[rbx+r13*8]
  40da70:	4c 21 e0             	and    rax,r12
  40da73:	49 39 46 48          	cmp    QWORD PTR [r14+0x48],rax
  40da77:	74 1f                	je     40da98 <cos_pgtbl_intern_expand+0x78>
	return 0;
  40da79:	45 31 c0             	xor    r8d,r8d
{ l->o = 0; }
  40da7c:	48 c7 83 c0 00 00 00 	mov    QWORD PTR [rbx+0xc0],0x0
  40da83:	00 00 00 00 
}
  40da87:	4c 89 c0             	mov    rax,r8
  40da8a:	5b                   	pop    rbx
  40da8b:	41 5c                	pop    r12
  40da8d:	41 5d                	pop    r13
  40da8f:	41 5e                	pop    r14
  40da91:	5d                   	pop    rbp
  40da92:	c3                   	ret    
  40da93:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	cap = __bump_mem_expand_intern(__compinfo_metacap(ci), ci->pgtbl_cap, mem_ptr, 0, 0);
  40da98:	48 8b 7b 60          	mov    rdi,QWORD PTR [rbx+0x60]
  40da9c:	48 8b 33             	mov    rsi,QWORD PTR [rbx]
  40da9f:	45 31 c0             	xor    r8d,r8d
  40daa2:	31 c9                	xor    ecx,ecx
  40daa4:	4c 89 e2             	mov    rdx,r12
  40daa7:	e8 f4 f8 ff ff       	call   40d3a0 <__bump_mem_expand_intern>
  40daac:	49 89 c0             	mov    r8,rax
	if (!cap) goto error;
  40daaf:	48 85 c0             	test   rax,rax
  40dab2:	74 c5                	je     40da79 <cos_pgtbl_intern_expand+0x59>
		if (tmp >= mem_ptr + PGD_RANGE) break;
  40dab4:	48 be 00 00 00 00 80 	movabs rsi,0x8000000000
  40dabb:	00 00 00 
		vaddr_t tmp = ps_load(&ci->vasrange_frontier[lvl]);
  40dabe:	49 8b 46 48          	mov    rax,QWORD PTR [r14+0x48]
		ps_cas(&ci->vasrange_frontier[lvl], tmp, tmp + PGD_RANGE);
  40dac2:	4a 8d 4c eb 48       	lea    rcx,[rbx+r13*8+0x48]
		if (tmp >= mem_ptr + PGD_RANGE) break;
  40dac7:	49 01 f4             	add    r12,rsi
  40daca:	4c 39 e0             	cmp    rax,r12
  40dacd:	73 ad                	jae    40da7c <cos_pgtbl_intern_expand+0x5c>
  40dacf:	90                   	nop
		ps_cas(&ci->vasrange_frontier[lvl], tmp, tmp + PGD_RANGE);
  40dad0:	48 8d 14 30          	lea    rdx,[rax+rsi*1]
        __asm__ __volatile__("lock " PS_CAS_STR
  40dad4:	f0 48 0f b1 11       	lock cmpxchg QWORD PTR [rcx],rdx
  40dad9:	0f 94 c0             	sete   al
		vaddr_t tmp = ps_load(&ci->vasrange_frontier[lvl]);
  40dadc:	49 8b 46 48          	mov    rax,QWORD PTR [r14+0x48]
		if (tmp >= mem_ptr + PGD_RANGE) break;
  40dae0:	4c 39 e0             	cmp    rax,r12
  40dae3:	72 eb                	jb     40dad0 <cos_pgtbl_intern_expand+0xb0>
  40dae5:	eb 95                	jmp    40da7c <cos_pgtbl_intern_expand+0x5c>
  40dae7:	be 2e 00 00 00       	mov    esi,0x2e
  40daec:	bf 20 db 41 00       	mov    edi,0x41db20
  40daf1:	e8 da c5 ff ff       	call   40a0d0 <cos_print_str>
	assert(lvl > 0);
  40daf6:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40dafd:	00 00 00 00 
  40db01:	0f 0b                	ud2    
  40db03:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40db0a:	00 00 00 00 
  40db0e:	66 90                	xchg   ax,ax

000000000040db10 <cos_pgtbl_intern_expandwith>:
{
  40db10:	f3 0f 1e fa          	endbr64 
  40db14:	55                   	push   rbp
  40db15:	49 89 d1             	mov    r9,rdx
  40db18:	31 c9                	xor    ecx,ecx
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40db1a:	48 8d 97 c0 00 00 00 	lea    rdx,[rdi+0xc0]
  40db21:	48 89 e5             	mov    rbp,rsp
  40db24:	41 54                	push   r12
  40db26:	49 89 f4             	mov    r12,rsi
        __asm__ __volatile__("lock " PS_CAS_STR
  40db29:	be 01 00 00 00       	mov    esi,0x1
  40db2e:	53                   	push   rbx
  40db2f:	48 89 fb             	mov    rbx,rdi
  40db32:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40db38:	48 89 c8             	mov    rax,rcx
  40db3b:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40db40:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40db43:	84 c0                	test   al,al
  40db45:	74 f1                	je     40db38 <cos_pgtbl_intern_expandwith+0x28>
	if (ci->vasrange_frontier[0] != round_to_pgd_page(mem)) goto error;
  40db47:	48 b8 00 00 00 00 80 	movabs rax,0xffffff8000000000
  40db4e:	ff ff ff 
  40db51:	4c 21 c8             	and    rax,r9
  40db54:	48 39 43 48          	cmp    QWORD PTR [rbx+0x48],rax
  40db58:	75 23                	jne    40db7d <cos_pgtbl_intern_expandwith+0x6d>
        __asm__ __volatile__("lock " PS_FAA_STR
  40db5a:	48 ba 00 00 00 00 80 	movabs rdx,0x8000000000
  40db61:	00 00 00 
  40db64:	48 89 d1             	mov    rcx,rdx
  40db67:	f0 48 0f c1 4b 48    	lock xadd QWORD PTR [rbx+0x48],rcx
	if ((unsigned long)ps_faa(&ci->vasrange_frontier[0], PGD_RANGE) > round_to_pgd_page(mem)) goto error;
  40db6d:	48 39 c8             	cmp    rax,rcx
  40db70:	72 0b                	jb     40db7d <cos_pgtbl_intern_expandwith+0x6d>
  40db72:	f0 48 0f c1 53 40    	lock xadd QWORD PTR [rbx+0x40],rdx
	if ((unsigned long)ps_faa(&ci->vas_frontier, PGD_RANGE) > round_to_pgd_page(mem)) goto error;
  40db78:	48 39 d0             	cmp    rax,rdx
  40db7b:	73 1b                	jae    40db98 <cos_pgtbl_intern_expandwith+0x88>
{ l->o = 0; }
  40db7d:	48 c7 83 c0 00 00 00 	mov    QWORD PTR [rbx+0xc0],0x0
  40db84:	00 00 00 00 
	return -1;
  40db88:	b8 ff ff ff ff       	mov    eax,0xffffffff
}
  40db8d:	5b                   	pop    rbx
  40db8e:	41 5c                	pop    r12
  40db90:	5d                   	pop    rbp
  40db91:	c3                   	ret    
  40db92:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	if (__bump_mem_expand_intern(__compinfo_metacap(ci), ci->pgtbl_cap, mem, intern, 0) != intern) {
  40db98:	48 8b 7b 60          	mov    rdi,QWORD PTR [rbx+0x60]
  40db9c:	48 8b 33             	mov    rsi,QWORD PTR [rbx]
  40db9f:	45 31 c0             	xor    r8d,r8d
  40dba2:	4c 89 e1             	mov    rcx,r12
  40dba5:	4c 89 ca             	mov    rdx,r9
  40dba8:	e8 f3 f7 ff ff       	call   40d3a0 <__bump_mem_expand_intern>
  40dbad:	48 c7 83 c0 00 00 00 	mov    QWORD PTR [rbx+0xc0],0x0
  40dbb4:	00 00 00 00 
}
  40dbb8:	5b                   	pop    rbx
	if (__bump_mem_expand_intern(__compinfo_metacap(ci), ci->pgtbl_cap, mem, intern, 0) != intern) {
  40dbb9:	4c 39 e0             	cmp    rax,r12
}
  40dbbc:	41 5c                	pop    r12
  40dbbe:	5d                   	pop    rbp
	if (__bump_mem_expand_intern(__compinfo_metacap(ci), ci->pgtbl_cap, mem, intern, 0) != intern) {
  40dbbf:	0f 95 c0             	setne  al
  40dbc2:	0f b6 c0             	movzx  eax,al
}
  40dbc5:	c3                   	ret    
  40dbc6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40dbcd:	00 00 00 

000000000040dbd0 <cos_meminfo_alloc>:
{
  40dbd0:	f3 0f 1e fa          	endbr64 
	assert(untyped_ptr == round_up_to_pgd_page(untyped_ptr));
  40dbd4:	48 b8 ff ff ff ff 7f 	movabs rax,0x7fffffffff
  40dbdb:	00 00 00 
{
  40dbde:	55                   	push   rbp
	assert(untyped_ptr == round_up_to_pgd_page(untyped_ptr));
  40dbdf:	48 01 f0             	add    rax,rsi
{
  40dbe2:	48 89 e5             	mov    rbp,rsp
  40dbe5:	41 57                	push   r15
  40dbe7:	41 56                	push   r14
  40dbe9:	49 89 d6             	mov    r14,rdx
	assert(untyped_ptr == round_up_to_pgd_page(untyped_ptr));
  40dbec:	48 ba 00 00 00 00 80 	movabs rdx,0xffffff8000000000
  40dbf3:	ff ff ff 
{
  40dbf6:	41 55                	push   r13
	assert(untyped_ptr == round_up_to_pgd_page(untyped_ptr));
  40dbf8:	48 21 d0             	and    rax,rdx
{
  40dbfb:	41 54                	push   r12
  40dbfd:	53                   	push   rbx
  40dbfe:	48 83 ec 28          	sub    rsp,0x28
	return ci->memsrc;
  40dc02:	4c 8b 7f 60          	mov    r15,QWORD PTR [rdi+0x60]
	assert(untyped_ptr == round_up_to_pgd_page(untyped_ptr));
  40dc06:	48 39 c6             	cmp    rsi,rax
  40dc09:	0f 85 88 01 00 00    	jne    40dd97 <cos_meminfo_alloc+0x1c7>
  40dc0f:	49 89 fd             	mov    r13,rdi
  40dc12:	48 89 f3             	mov    rbx,rsi
  40dc15:	4c 89 ff             	mov    rdi,r15
  40dc18:	45 31 e4             	xor    r12d,r12d
		retaddr = __bump_mem_expand_range(__compinfo_metacap(ci), ci->mi.pgtbl_cap, untyped_ptr, untyped_sz, pgtbl_lvl);
  40dc1b:	49 8b b5 98 00 00 00 	mov    rsi,QWORD PTR [r13+0x98]
  40dc22:	45 89 e0             	mov    r8d,r12d
  40dc25:	4c 89 f1             	mov    rcx,r14
  40dc28:	48 89 da             	mov    rdx,rbx
  40dc2b:	e8 40 f0 ff ff       	call   40cc70 <__bump_mem_expand_range>
  40dc30:	49 89 c2             	mov    r10,rax
		assert(retaddr);
  40dc33:	48 85 c0             	test   rax,rax
  40dc36:	0f 84 3f 01 00 00    	je     40dd7b <cos_meminfo_alloc+0x1ab>
	for(pgtbl_lvl = 0; pgtbl_lvl < COS_PGTBL_DEPTH - 1; pgtbl_lvl++) {
  40dc3c:	49 83 c4 01          	add    r12,0x1
  40dc40:	49 83 fc 03          	cmp    r12,0x3
  40dc44:	74 0a                	je     40dc50 <cos_meminfo_alloc+0x80>
	return ci->memsrc;
  40dc46:	49 8b 7d 60          	mov    rdi,QWORD PTR [r13+0x60]
  40dc4a:	eb cf                	jmp    40dc1b <cos_meminfo_alloc+0x4b>
  40dc4c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  40dc50:	66 48 0f 6e c0       	movq   xmm0,rax
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40dc55:	49 8d 95 b8 00 00 00 	lea    rdx,[r13+0xb8]
        __asm__ __volatile__("lock " PS_CAS_STR
  40dc5c:	be 01 00 00 00       	mov    esi,0x1
  40dc61:	31 c9                	xor    ecx,ecx
  40dc63:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
	assert(retaddr == untyped_ptr);
  40dc67:	48 39 c3             	cmp    rbx,rax
  40dc6a:	0f 85 43 01 00 00    	jne    40ddb3 <cos_meminfo_alloc+0x1e3>
  40dc70:	48 89 c8             	mov    rax,rcx
  40dc73:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40dc78:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40dc7b:	84 c0                	test   al,al
  40dc7d:	74 f1                	je     40dc70 <cos_meminfo_alloc+0xa0>
        __asm__ __volatile__("lock " PS_FAA_STR
  40dc7f:	4c 89 f0             	mov    rax,r14
  40dc82:	f0 49 0f c1 47 68    	lock xadd QWORD PTR [r15+0x68],rax
  40dc88:	4c 89 f2             	mov    rdx,r14
  40dc8b:	f0 49 0f c1 97 80 00 	lock xadd QWORD PTR [r15+0x80],rdx
  40dc92:	00 00 
	for (addr = untyped_ptr; addr < untyped_ptr + untyped_sz; addr += PAGE_SIZE, start_addr += PAGE_SIZE) {
  40dc94:	4b 8d 1c 16          	lea    rbx,[r14+r10*1]
  40dc98:	66 49 0f 6e d2       	movq   xmm2,r10
  40dc9d:	4c 29 d0             	sub    rax,r10
  40dca0:	4c 89 d7             	mov    rdi,r10
  40dca3:	66 48 0f 6e cb       	movq   xmm1,rbx
  40dca8:	49 89 c6             	mov    r14,rax
  40dcab:	31 d2                	xor    edx,edx
{ l->o = 0; }
  40dcad:	49 c7 85 b8 00 00 00 	mov    QWORD PTR [r13+0xb8],0x0
  40dcb4:	00 00 00 00 
  40dcb8:	66 0f 6c ca          	punpcklqdq xmm1,xmm2
  40dcbc:	4c 39 d3             	cmp    rbx,r10
  40dcbf:	0f 86 8f 00 00 00    	jbe    40dd54 <cos_meminfo_alloc+0x184>
  40dcc5:	4c 89 55 b8          	mov    QWORD PTR [rbp-0x48],r10
  40dcc9:	49 89 da             	mov    r10,rbx
  40dccc:	eb 0e                	jmp    40dcdc <cos_meminfo_alloc+0x10c>
  40dcce:	66 90                	xchg   ax,ax
  40dcd0:	48 81 c7 00 10 00 00 	add    rdi,0x1000
  40dcd7:	49 39 fa             	cmp    r10,rdi
  40dcda:	76 74                	jbe    40dd50 <cos_meminfo_alloc+0x180>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40dcdc:	41 8b 87 98 00 00 00 	mov    eax,DWORD PTR [r15+0x98]
	__asm__ __volatile__(
  40dce3:	49 8b b5 98 00 00 00 	mov    rsi,QWORD PTR [r13+0x98]
  40dcea:	49 8d 1c 3e          	lea    rbx,[r14+rdi*1]
  40dcee:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40dcf2:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40dcf5:	05 24 00 01 00       	add    eax,0x10024
	__asm__ __volatile__(
  40dcfa:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40dcfd:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40dd01:	48 89 cd             	mov    rbp,rcx
  40dd04:	49 b8 18 dd 40 00 00 	movabs r8,0x40dd18
  40dd0b:	00 00 00 
  40dd0e:	0f 05                	syscall 
  40dd10:	eb 0d                	jmp    40dd1f <cos_meminfo_alloc+0x14f>
  40dd12:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40dd18:	b9 00 00 00 00       	mov    ecx,0x0
  40dd1d:	eb 05                	jmp    40dd24 <cos_meminfo_alloc+0x154>
  40dd1f:	b9 01 00 00 00       	mov    ecx,0x1
  40dd24:	5d                   	pop    rbp
  40dd25:	5c                   	pop    rsp
		if (call_cap_op(meta->mi.pgtbl_cap, CAPTBL_OP_MEMMOVE, start_addr, ci->mi.pgtbl_cap, addr, 0)) BUG();
  40dd26:	85 c0                	test   eax,eax
  40dd28:	74 a6                	je     40dcd0 <cos_meminfo_alloc+0x100>
  40dd2a:	be 1b 00 00 00       	mov    esi,0x1b
  40dd2f:	bf df db 41 00       	mov    edi,0x41dbdf
  40dd34:	e8 97 c3 ff ff       	call   40a0d0 <cos_print_str>
  40dd39:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40dd40:	00 00 00 00 
  40dd44:	0f 0b                	ud2    
  40dd46:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40dd4d:	00 00 00 
  40dd50:	4c 8b 55 b8          	mov    r10,QWORD PTR [rbp-0x48]
	ci->mi.untyped_ptr = ci->mi.umem_ptr = ci->mi.kmem_ptr = ci->mi.umem_frontier = ci->mi.kmem_frontier =
  40dd54:	4d 89 95 90 00 00 00 	mov    QWORD PTR [r13+0x90],r10
  40dd5b:	4d 89 55 78          	mov    QWORD PTR [r13+0x78],r10
  40dd5f:	41 0f 11 45 68       	movups XMMWORD PTR [r13+0x68],xmm0
	ci->mi.untyped_frontier = untyped_ptr + untyped_sz;
  40dd64:	41 0f 11 8d 80 00 00 	movups XMMWORD PTR [r13+0x80],xmm1
  40dd6b:	00 
}
  40dd6c:	48 83 c4 28          	add    rsp,0x28
  40dd70:	5b                   	pop    rbx
  40dd71:	41 5c                	pop    r12
  40dd73:	41 5d                	pop    r13
  40dd75:	41 5e                	pop    r14
  40dd77:	41 5f                	pop    r15
  40dd79:	5d                   	pop    rbp
  40dd7a:	c3                   	ret    
  40dd7b:	be 2e 00 00 00       	mov    esi,0x2e
  40dd80:	bf 80 db 41 00       	mov    edi,0x41db80
  40dd85:	e8 46 c3 ff ff       	call   40a0d0 <cos_print_str>
		assert(retaddr);
  40dd8a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40dd91:	00 00 00 00 
  40dd95:	0f 0b                	ud2    
  40dd97:	be 2e 00 00 00       	mov    esi,0x2e
  40dd9c:	bf 50 db 41 00       	mov    edi,0x41db50
  40dda1:	e8 2a c3 ff ff       	call   40a0d0 <cos_print_str>
	assert(untyped_ptr == round_up_to_pgd_page(untyped_ptr));
  40dda6:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ddad:	00 00 00 00 
  40ddb1:	0f 0b                	ud2    
  40ddb3:	be 2e 00 00 00       	mov    esi,0x2e
  40ddb8:	bf b0 db 41 00       	mov    edi,0x41dbb0
  40ddbd:	e8 0e c3 ff ff       	call   40a0d0 <cos_print_str>
	assert(retaddr == untyped_ptr);
  40ddc2:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ddc9:	00 00 00 00 
  40ddcd:	0f 0b                	ud2    
  40ddcf:	90                   	nop

000000000040ddd0 <missing_captbl_node_expand>:

void
missing_captbl_node_expand(struct cos_compinfo *ci)
{
  40ddd0:	f3 0f 1e fa          	endbr64 
  40ddd4:	55                   	push   rbp
  40ddd5:	48 89 e5             	mov    rbp,rsp
  40ddd8:	41 57                	push   r15
  40ddda:	41 56                	push   r14
  40dddc:	41 55                	push   r13
  40ddde:	41 54                	push   r12
  40dde0:	53                   	push   rbx
  40dde1:	48 83 ec 38          	sub    rsp,0x38
	return ci->memsrc;
  40dde5:	4c 8b 7f 60          	mov    r15,QWORD PTR [rdi+0x60]
	int self_resource = (root_source == ci);
	vaddr_t kmem;
	int ret;

	cap_frontier = root_source->cap_frontier;
	caprange_frontier = root_source->caprange_frontier;
  40dde9:	49 8b 77 20          	mov    rsi,QWORD PTR [r15+0x20]
	cap_frontier = root_source->cap_frontier;
  40dded:	49 8b 47 18          	mov    rax,QWORD PTR [r15+0x18]
	caprange_frontier = root_source->caprange_frontier;
  40ddf1:	48 89 75 b0          	mov    QWORD PTR [rbp-0x50],rsi

	test_cap = CAPTBL_EXPAND_SZ;
	if (self_resource) {
  40ddf5:	4c 39 ff             	cmp    rdi,r15
  40ddf8:	0f 84 a2 02 00 00    	je     40e0a0 <missing_captbl_node_expand+0x2d0>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40ddfe:	41 8b 47 08          	mov    eax,DWORD PTR [r15+0x8]
	__asm__ __volatile__(
  40de02:	31 d2                	xor    edx,edx
  40de04:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  40de08:	48 8b 5f 08          	mov    rbx,QWORD PTR [rdi+0x8]
  40de0c:	49 89 fa             	mov    r10,rdi
  40de0f:	48 89 4d b8          	mov    QWORD PTR [rbp-0x48],rcx
  40de13:	bf 01 00 00 00       	mov    edi,0x1
  40de18:	48 89 d6             	mov    rsi,rdx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40de1b:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40de1e:	05 03 00 01 00       	add    eax,0x10003
	__asm__ __volatile__(
  40de23:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40de26:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40de2a:	48 89 cd             	mov    rbp,rcx
  40de2d:	49 b8 48 de 40 00 00 	movabs r8,0x40de48
  40de34:	00 00 00 
  40de37:	0f 05                	syscall 
  40de39:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  40de40:	eb 0d                	jmp    40de4f <missing_captbl_node_expand+0x7f>
  40de42:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40de48:	b9 00 00 00 00       	mov    ecx,0x0
  40de4d:	eb 05                	jmp    40de54 <missing_captbl_node_expand+0x84>
  40de4f:	b9 01 00 00 00       	mov    ecx,0x1
  40de54:	5d                   	pop    rbp
  40de55:	5c                   	pop    rsp
	} else {
		printd("cap check before:%d\n", ci->captbl_cap);
		ret = call_cap_op(root_source->captbl_cap, CAPTBL_OP_CAPCHECK, ci->captbl_cap, 0, 1, 0);
		// printc("after cap check:%d\n", ret);
		/* make sure the sub captbl exists */
		assert(!ret);
  40de56:	85 c0                	test   eax,eax
  40de58:	0f 85 e8 03 00 00    	jne    40e246 <missing_captbl_node_expand+0x476>
		cap_frontier = ci->cap_frontier;
		caprange_frontier = ci->caprange_frontier;
  40de5e:	49 8b 42 20          	mov    rax,QWORD PTR [r10+0x20]
		/* we make sure before expanding the missing node of sub captbl, we make sure its root captbl is in a good state */
		printd("begin to expanding a SUB source:%d, %d\n", cap_frontier, caprange_frontier);
		missing_captbl_node_expand(root_source);
  40de62:	4c 89 ff             	mov    rdi,r15
		caprange_frontier = ci->caprange_frontier;
  40de65:	4c 89 55 a8          	mov    QWORD PTR [rbp-0x58],r10
  40de69:	48 89 c3             	mov    rbx,rax
  40de6c:	48 89 45 b0          	mov    QWORD PTR [rbp-0x50],rax
		missing_captbl_node_expand(root_source);
  40de70:	e8 5b ff ff ff       	call   40ddd0 <missing_captbl_node_expand>
		while (test_cap < caprange_frontier) {
  40de75:	48 81 fb 80 00 00 00 	cmp    rbx,0x80
  40de7c:	0f 86 24 02 00 00    	jbe    40e0a6 <missing_captbl_node_expand+0x2d6>
  40de82:	4c 8b 55 a8          	mov    r10,QWORD PTR [rbp-0x58]
	test_cap = CAPTBL_EXPAND_SZ;
  40de86:	41 be 80 00 00 00    	mov    r14d,0x80
  40de8c:	45 31 ed             	xor    r13d,r13d
  40de8f:	eb 18                	jmp    40dea9 <missing_captbl_node_expand+0xd9>
  40de91:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
					printc("assert ret:%d\n", ret);
					assert(0); /* race? */
				}
				printd("try to expand a SUB node: DONE once\n");
			}
			test_cap += CAPTBL_EXPAND_SZ * 2;
  40de98:	49 81 c6 00 01 00 00 	add    r14,0x100
		while (test_cap < caprange_frontier) {
  40de9f:	4c 39 75 b0          	cmp    QWORD PTR [rbp-0x50],r14
  40dea3:	0f 86 fd 01 00 00    	jbe    40e0a6 <missing_captbl_node_expand+0x2d6>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40dea9:	41 8b 47 08          	mov    eax,DWORD PTR [r15+0x8]
	__asm__ __volatile__(
  40dead:	49 8b 5a 08          	mov    rbx,QWORD PTR [r10+0x8]
  40deb1:	4c 89 f6             	mov    rsi,r14
  40deb4:	4c 89 ef             	mov    rdi,r13
  40deb7:	48 8b 4d b8          	mov    rcx,QWORD PTR [rbp-0x48]
  40debb:	4c 89 ea             	mov    rdx,r13
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40debe:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40dec1:	05 03 00 01 00       	add    eax,0x10003
	__asm__ __volatile__(
  40dec6:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40dec9:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40decd:	48 89 cd             	mov    rbp,rcx
  40ded0:	49 b8 e8 de 40 00 00 	movabs r8,0x40dee8
  40ded7:	00 00 00 
  40deda:	0f 05                	syscall 
  40dedc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  40dee0:	eb 0d                	jmp    40deef <missing_captbl_node_expand+0x11f>
  40dee2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40dee8:	b9 00 00 00 00       	mov    ecx,0x0
  40deed:	eb 05                	jmp    40def4 <missing_captbl_node_expand+0x124>
  40deef:	b9 01 00 00 00       	mov    ecx,0x1
  40def4:	5d                   	pop    rbp
  40def5:	5c                   	pop    rsp
			if (ret) {
  40def6:	85 c0                	test   eax,eax
  40def8:	74 9e                	je     40de98 <missing_captbl_node_expand+0xc8>
	return __mem_bump_alloc(ci, 1, 1);
  40defa:	4c 89 ff             	mov    rdi,r15
  40defd:	4c 89 55 a8          	mov    QWORD PTR [rbp-0x58],r10
  40df01:	e8 5a e9 ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
				assert(kmem); /* FIXME: should have a failure semantics for capids */
  40df06:	4c 8b 55 a8          	mov    r10,QWORD PTR [rbp-0x58]
  40df0a:	48 85 c0             	test   rax,rax
	return __mem_bump_alloc(ci, 1, 1);
  40df0d:	49 89 c4             	mov    r12,rax
				assert(kmem); /* FIXME: should have a failure semantics for capids */
  40df10:	0f 84 9f 01 00 00    	je     40e0b5 <missing_captbl_node_expand+0x2e5>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40df16:	49 8d 97 b0 00 00 00 	lea    rdx,[r15+0xb0]
        __asm__ __volatile__("lock " PS_CAS_STR
  40df1d:	b9 01 00 00 00       	mov    ecx,0x1
  40df22:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40df28:	4c 89 e8             	mov    rax,r13
  40df2b:	f0 48 0f b1 0a       	lock cmpxchg QWORD PTR [rdx],rcx
  40df30:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40df33:	84 c0                	test   al,al
  40df35:	74 f1                	je     40df28 <missing_captbl_node_expand+0x158>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40df37:	49 8b 5f 38          	mov    rbx,QWORD PTR [r15+0x38]
  40df3b:	83 e3 03             	and    ebx,0x3
  40df3e:	0f 84 2c 01 00 00    	je     40e070 <missing_captbl_node_expand+0x2a0>
        __asm__ __volatile__("lock " PS_FAA_STR
  40df44:	bb 04 00 00 00       	mov    ebx,0x4
  40df49:	f0 49 0f c1 5f 38    	lock xadd QWORD PTR [r15+0x38],rbx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40df4f:	41 8b 47 08          	mov    eax,DWORD PTR [r15+0x8]
	__asm__ __volatile__(
  40df53:	48 8b 4d b8          	mov    rcx,QWORD PTR [rbp-0x48]
  40df57:	ba 01 00 00 00       	mov    edx,0x1
  40df5c:	4c 89 e7             	mov    rdi,r12
{ l->o = 0; }
  40df5f:	49 c7 87 b0 00 00 00 	mov    QWORD PTR [r15+0xb0],0x0
  40df66:	00 00 00 00 
  40df6a:	49 8b b7 98 00 00 00 	mov    rsi,QWORD PTR [r15+0x98]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40df71:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40df74:	05 1e 00 01 00       	add    eax,0x1001e
	__asm__ __volatile__(
  40df79:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40df7c:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40df80:	48 89 cd             	mov    rbp,rcx
  40df83:	49 b8 98 df 40 00 00 	movabs r8,0x40df98
  40df8a:	00 00 00 
  40df8d:	0f 05                	syscall 
  40df8f:	90                   	nop
  40df90:	eb 0d                	jmp    40df9f <missing_captbl_node_expand+0x1cf>
  40df92:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40df98:	b9 00 00 00 00       	mov    ecx,0x0
  40df9d:	eb 05                	jmp    40dfa4 <missing_captbl_node_expand+0x1d4>
  40df9f:	b9 01 00 00 00       	mov    ecx,0x1
  40dfa4:	5d                   	pop    rbp
  40dfa5:	5c                   	pop    rsp
				if (call_cap_op(root_source->captbl_cap, CAPTBL_OP_CAPTBLACTIVATE, frontier, root_source->mi.pgtbl_cap, kmem, 1)) {
  40dfa6:	85 c0                	test   eax,eax
  40dfa8:	0f 85 b4 02 00 00    	jne    40e262 <missing_captbl_node_expand+0x492>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40dfae:	41 8b 42 08          	mov    eax,DWORD PTR [r10+0x8]
	__asm__ __volatile__(
  40dfb2:	48 8b 4d b8          	mov    rcx,QWORD PTR [rbp-0x48]
  40dfb6:	4c 89 f6             	mov    rsi,r14
  40dfb9:	4c 89 ef             	mov    rdi,r13
  40dfbc:	4c 89 ea             	mov    rdx,r13
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40dfbf:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40dfc2:	05 01 00 01 00       	add    eax,0x10001
	__asm__ __volatile__(
  40dfc7:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40dfca:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40dfce:	48 89 cd             	mov    rbp,rcx
  40dfd1:	49 b8 e8 df 40 00 00 	movabs r8,0x40dfe8
  40dfd8:	00 00 00 
  40dfdb:	0f 05                	syscall 
  40dfdd:	0f 1f 00             	nop    DWORD PTR [rax]
  40dfe0:	eb 0d                	jmp    40dfef <missing_captbl_node_expand+0x21f>
  40dfe2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40dfe8:	b9 00 00 00 00       	mov    ecx,0x0
  40dfed:	eb 05                	jmp    40dff4 <missing_captbl_node_expand+0x224>
  40dfef:	b9 01 00 00 00       	mov    ecx,0x1
  40dff4:	5d                   	pop    rbp
  40dff5:	5c                   	pop    rsp
				if (call_cap_op(ci->captbl_cap, CAPTBL_OP_CONS, frontier, test_cap, 0, 0)) {
  40dff6:	85 c0                	test   eax,eax
  40dff8:	0f 84 9a fe ff ff    	je     40de98 <missing_captbl_node_expand+0xc8>
					ret = call_cap_op(root_source->captbl_cap, CAPTBL_OP_CAPCHECK, ci->captbl_cap, 384, 0, 0);
  40dffe:	49 8b 47 08          	mov    rax,QWORD PTR [r15+0x8]
  40e002:	49 8b 5a 08          	mov    rbx,QWORD PTR [r10+0x8]
  40e006:	be 80 01 00 00       	mov    esi,0x180
  40e00b:	48 8b 4d b8          	mov    rcx,QWORD PTR [rbp-0x48]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e00f:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40e012:	05 03 00 01 00       	add    eax,0x10003
	__asm__ __volatile__(
  40e017:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40e01a:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40e01e:	48 89 cd             	mov    rbp,rcx
  40e021:	49 b8 38 e0 40 00 00 	movabs r8,0x40e038
  40e028:	00 00 00 
  40e02b:	0f 05                	syscall 
  40e02d:	0f 1f 00             	nop    DWORD PTR [rax]
  40e030:	eb 0d                	jmp    40e03f <missing_captbl_node_expand+0x26f>
  40e032:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e038:	b9 00 00 00 00       	mov    ecx,0x0
  40e03d:	eb 05                	jmp    40e044 <missing_captbl_node_expand+0x274>
  40e03f:	b9 01 00 00 00       	mov    ecx,0x1
  40e044:	5d                   	pop    rbp
  40e045:	5c                   	pop    rsp
					printc("assert ret:%d\n", ret);
  40e046:	bf c0 d6 41 00       	mov    edi,0x41d6c0
  40e04b:	89 c6                	mov    esi,eax
  40e04d:	31 c0                	xor    eax,eax
  40e04f:	e8 5c e7 ff ff       	call   40c7b0 <printc.constprop.0>
  40e054:	be 2e 00 00 00       	mov    esi,0x2e
  40e059:	bf 20 dd 41 00       	mov    edi,0x41dd20
  40e05e:	e8 6d c0 ff ff       	call   40a0d0 <cos_print_str>
					assert(0); /* race? */
  40e063:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e06a:	00 00 00 00 
  40e06e:	0f 0b                	ud2    
		if (__capid_captbl_check_expand(ci)) goto error;
  40e070:	4c 89 ff             	mov    rdi,r15
  40e073:	4c 89 55 a8          	mov    QWORD PTR [rbp-0x58],r10
  40e077:	e8 64 e9 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40e07c:	4c 8b 55 a8          	mov    r10,QWORD PTR [rbp-0x58]
  40e080:	85 c0                	test   eax,eax
  40e082:	0f 85 c7 fe ff ff    	jne    40df4f <missing_captbl_node_expand+0x17f>
        __asm__ __volatile__("lock " PS_FAA_STR
  40e088:	b8 04 00 00 00       	mov    eax,0x4
  40e08d:	f0 49 0f c1 47 18    	lock xadd QWORD PTR [r15+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40e093:	49 89 47 38          	mov    QWORD PTR [r15+0x38],rax
  40e097:	e9 a8 fe ff ff       	jmp    40df44 <missing_captbl_node_expand+0x174>
  40e09c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		if (cap_frontier >= CAPTBL_EXPAND_SZ) {
  40e0a0:	48 83 f8 7f          	cmp    rax,0x7f
  40e0a4:	76 2b                	jbe    40e0d1 <missing_captbl_node_expand+0x301>
		}
		printd("begin to expanding a SUB source:%d, %d, done\n", cap_frontier, caprange_frontier);
	}
}
  40e0a6:	48 83 c4 38          	add    rsp,0x38
  40e0aa:	5b                   	pop    rbx
  40e0ab:	41 5c                	pop    r12
  40e0ad:	41 5d                	pop    r13
  40e0af:	41 5e                	pop    r14
  40e0b1:	41 5f                	pop    r15
  40e0b3:	5d                   	pop    rbp
  40e0b4:	c3                   	ret    
  40e0b5:	be 2e 00 00 00       	mov    esi,0x2e
  40e0ba:	bf c0 dc 41 00       	mov    edi,0x41dcc0
  40e0bf:	e8 0c c0 ff ff       	call   40a0d0 <cos_print_str>
				assert(kmem); /* FIXME: should have a failure semantics for capids */
  40e0c4:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e0cb:	00 00 00 00 
  40e0cf:	0f 0b                	ud2    
		while (test_cap < caprange_frontier) {
  40e0d1:	48 81 fe 80 00 00 00 	cmp    rsi,0x80
  40e0d8:	76 cc                	jbe    40e0a6 <missing_captbl_node_expand+0x2d6>
  40e0da:	48 8d 45 c0          	lea    rax,[rbp-0x40]
	test_cap = CAPTBL_EXPAND_SZ;
  40e0de:	41 bd 80 00 00 00    	mov    r13d,0x80
  40e0e4:	45 31 d2             	xor    r10d,r10d
  40e0e7:	48 89 45 b8          	mov    QWORD PTR [rbp-0x48],rax
  40e0eb:	eb 10                	jmp    40e0fd <missing_captbl_node_expand+0x32d>
  40e0ed:	0f 1f 00             	nop    DWORD PTR [rax]
			test_cap += CAPTBL_EXPAND_SZ * 2;
  40e0f0:	49 81 c5 00 01 00 00 	add    r13,0x100
		while (test_cap < caprange_frontier) {
  40e0f7:	4c 39 6d b0          	cmp    QWORD PTR [rbp-0x50],r13
  40e0fb:	76 a9                	jbe    40e0a6 <missing_captbl_node_expand+0x2d6>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e0fd:	41 8b 47 08          	mov    eax,DWORD PTR [r15+0x8]
	__asm__ __volatile__(
  40e101:	41 be 01 00 00 00    	mov    r14d,0x1
  40e107:	4c 89 eb             	mov    rbx,r13
  40e10a:	4c 89 d6             	mov    rsi,r10
  40e10d:	48 8b 4d b8          	mov    rcx,QWORD PTR [rbp-0x48]
  40e111:	4c 89 f7             	mov    rdi,r14
  40e114:	4c 89 d2             	mov    rdx,r10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e117:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40e11a:	05 03 00 01 00       	add    eax,0x10003
	__asm__ __volatile__(
  40e11f:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40e122:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40e126:	48 89 cd             	mov    rbp,rcx
  40e129:	49 b8 40 e1 40 00 00 	movabs r8,0x40e140
  40e130:	00 00 00 
  40e133:	0f 05                	syscall 
  40e135:	0f 1f 00             	nop    DWORD PTR [rax]
  40e138:	eb 0d                	jmp    40e147 <missing_captbl_node_expand+0x377>
  40e13a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e140:	b9 00 00 00 00       	mov    ecx,0x0
  40e145:	eb 05                	jmp    40e14c <missing_captbl_node_expand+0x37c>
  40e147:	b9 01 00 00 00       	mov    ecx,0x1
  40e14c:	5d                   	pop    rbp
  40e14d:	5c                   	pop    rsp
			if (ret) {
  40e14e:	85 c0                	test   eax,eax
  40e150:	74 9e                	je     40e0f0 <missing_captbl_node_expand+0x320>
	return __mem_bump_alloc(ci, 1, 1);
  40e152:	4c 89 ff             	mov    rdi,r15
				frontier = test_cap - CAPMAX_ENTRY_SZ;
  40e155:	49 8d 5d fc          	lea    rbx,[r13-0x4]
	return __mem_bump_alloc(ci, 1, 1);
  40e159:	e8 02 e7 ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
				assert(kmem); /* FIXME: should have a failure semantics for capids */
  40e15e:	45 31 d2             	xor    r10d,r10d
	return __mem_bump_alloc(ci, 1, 1);
  40e161:	48 89 c7             	mov    rdi,rax
				assert(kmem); /* FIXME: should have a failure semantics for capids */
  40e164:	48 85 c0             	test   rax,rax
  40e167:	0f 84 bd 00 00 00    	je     40e22a <missing_captbl_node_expand+0x45a>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e16d:	41 8b 47 08          	mov    eax,DWORD PTR [r15+0x8]
	__asm__ __volatile__(
  40e171:	49 8b b7 98 00 00 00 	mov    rsi,QWORD PTR [r15+0x98]
  40e178:	4c 89 f2             	mov    rdx,r14
  40e17b:	48 8b 4d b8          	mov    rcx,QWORD PTR [rbp-0x48]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e17f:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40e182:	05 1e 00 01 00       	add    eax,0x1001e
	__asm__ __volatile__(
  40e187:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40e18a:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40e18e:	48 89 cd             	mov    rbp,rcx
  40e191:	49 b8 a8 e1 40 00 00 	movabs r8,0x40e1a8
  40e198:	00 00 00 
  40e19b:	0f 05                	syscall 
  40e19d:	0f 1f 00             	nop    DWORD PTR [rax]
  40e1a0:	eb 0d                	jmp    40e1af <missing_captbl_node_expand+0x3df>
  40e1a2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e1a8:	b9 00 00 00 00       	mov    ecx,0x0
  40e1ad:	eb 05                	jmp    40e1b4 <missing_captbl_node_expand+0x3e4>
  40e1af:	b9 01 00 00 00       	mov    ecx,0x1
  40e1b4:	5d                   	pop    rbp
  40e1b5:	5c                   	pop    rsp
				if (call_cap_op(root_source->captbl_cap, CAPTBL_OP_CAPTBLACTIVATE, frontier, root_source->mi.pgtbl_cap, kmem, 1)) {
  40e1b6:	85 c0                	test   eax,eax
  40e1b8:	0f 85 c0 00 00 00    	jne    40e27e <missing_captbl_node_expand+0x4ae>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e1be:	41 8b 47 08          	mov    eax,DWORD PTR [r15+0x8]
	__asm__ __volatile__(
  40e1c2:	48 8b 4d b8          	mov    rcx,QWORD PTR [rbp-0x48]
  40e1c6:	4c 89 ee             	mov    rsi,r13
  40e1c9:	4c 89 d7             	mov    rdi,r10
  40e1cc:	4c 89 d2             	mov    rdx,r10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e1cf:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40e1d2:	05 01 00 01 00       	add    eax,0x10001
	__asm__ __volatile__(
  40e1d7:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40e1da:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40e1de:	48 89 cd             	mov    rbp,rcx
  40e1e1:	49 b8 f8 e1 40 00 00 	movabs r8,0x40e1f8
  40e1e8:	00 00 00 
  40e1eb:	0f 05                	syscall 
  40e1ed:	0f 1f 00             	nop    DWORD PTR [rax]
  40e1f0:	eb 0d                	jmp    40e1ff <missing_captbl_node_expand+0x42f>
  40e1f2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e1f8:	b9 00 00 00 00       	mov    ecx,0x0
  40e1fd:	eb 05                	jmp    40e204 <missing_captbl_node_expand+0x434>
  40e1ff:	b9 01 00 00 00       	mov    ecx,0x1
  40e204:	5d                   	pop    rbp
  40e205:	5c                   	pop    rsp
				if (call_cap_op(root_source->captbl_cap, CAPTBL_OP_CONS, frontier, test_cap, 0, 0)) {
  40e206:	85 c0                	test   eax,eax
  40e208:	0f 84 e2 fe ff ff    	je     40e0f0 <missing_captbl_node_expand+0x320>
  40e20e:	be 2e 00 00 00       	mov    esi,0x2e
  40e213:	bf 60 dc 41 00       	mov    edi,0x41dc60
  40e218:	e8 b3 be ff ff       	call   40a0d0 <cos_print_str>
					assert(0); /* race? */
  40e21d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e224:	00 00 00 00 
  40e228:	0f 0b                	ud2    
  40e22a:	be 2e 00 00 00       	mov    esi,0x2e
  40e22f:	bf 00 dc 41 00       	mov    edi,0x41dc00
  40e234:	e8 97 be ff ff       	call   40a0d0 <cos_print_str>
				assert(kmem); /* FIXME: should have a failure semantics for capids */
  40e239:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e240:	00 00 00 00 
  40e244:	0f 0b                	ud2    
  40e246:	be 2e 00 00 00       	mov    esi,0x2e
  40e24b:	bf 90 dc 41 00       	mov    edi,0x41dc90
  40e250:	e8 7b be ff ff       	call   40a0d0 <cos_print_str>
		assert(!ret);
  40e255:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e25c:	00 00 00 00 
  40e260:	0f 0b                	ud2    
  40e262:	be 2e 00 00 00       	mov    esi,0x2e
  40e267:	bf f0 dc 41 00       	mov    edi,0x41dcf0
  40e26c:	e8 5f be ff ff       	call   40a0d0 <cos_print_str>
					assert(0); /* race condition? */
  40e271:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e278:	00 00 00 00 
  40e27c:	0f 0b                	ud2    
  40e27e:	be 2e 00 00 00       	mov    esi,0x2e
  40e283:	bf 30 dc 41 00       	mov    edi,0x41dc30
  40e288:	e8 43 be ff ff       	call   40a0d0 <cos_print_str>
					assert(0); /* race condition? */
  40e28d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e294:	00 00 00 00 
  40e298:	0f 0b                	ud2    
  40e29a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000040e2a0 <cos_comp_capfrontier_update>:

void
cos_comp_capfrontier_update(struct cos_compinfo *ci, capid_t cap_frontier, int try_expand)
{
  40e2a0:	f3 0f 1e fa          	endbr64 
  40e2a4:	55                   	push   rbp
  40e2a5:	66 48 0f 6e ce       	movq   xmm1,rsi
  40e2aa:	66 0f 6c c9          	punpcklqdq xmm1,xmm1
  40e2ae:	48 89 e5             	mov    rbp,rsp
  40e2b1:	41 57                	push   r15
  40e2b3:	41 89 d7             	mov    r15d,edx
  40e2b6:	41 56                	push   r14
  40e2b8:	49 89 f6             	mov    r14,rsi
  40e2bb:	41 55                	push   r13
  40e2bd:	49 89 fd             	mov    r13,rdi
  40e2c0:	41 54                	push   r12
  40e2c2:	53                   	push   rbx
  40e2c3:	48 83 ec 38          	sub    rsp,0x38
  40e2c7:	0f 29 4d b0          	movaps XMMWORD PTR [rbp-0x50],xmm1
	missing_captbl_node_expand(ci);
  40e2cb:	e8 00 fb ff ff       	call   40ddd0 <missing_captbl_node_expand>
	// printc("mmp???:cap_frontier:%d, ci->cap_frontier:%d, ci->caprange_frontier:%d\n", cap_frontier, ci->cap_frontier, ci->caprange_frontier);
	if (cap_frontier <= ci->cap_frontier) return;
  40e2d0:	4d 39 75 18          	cmp    QWORD PTR [r13+0x18],r14
  40e2d4:	0f 83 1b 01 00 00    	jae    40e3f5 <cos_comp_capfrontier_update+0x155>

	if (try_expand) {
  40e2da:	45 85 ff             	test   r15d,r15d
  40e2dd:	0f 84 cd 00 00 00    	je     40e3b0 <cos_comp_capfrontier_update+0x110>
        __asm__ __volatile__("lock " PS_CAS_STR
  40e2e3:	41 bf 01 00 00 00    	mov    r15d,0x1
		while (cap_frontier > ci->caprange_frontier) {
  40e2e9:	49 8b 45 20          	mov    rax,QWORD PTR [r13+0x20]
  40e2ed:	4c 39 f0             	cmp    rax,r14
  40e2f0:	0f 83 ba 00 00 00    	jae    40e3b0 <cos_comp_capfrontier_update+0x110>
  40e2f6:	4d 8b 65 60          	mov    r12,QWORD PTR [r13+0x60]
	return ci->memsrc;
  40e2fa:	49 8b 54 24 60       	mov    rdx,QWORD PTR [r12+0x60]
			ci->cap_frontier = ci->caprange_frontier;	
  40e2ff:	49 89 45 18          	mov    QWORD PTR [r13+0x18],rax
	assert(__compinfo_metacap(meta) == meta);
  40e303:	4c 39 e2             	cmp    rdx,r12
  40e306:	0f 85 f7 01 00 00    	jne    40e503 <cos_comp_capfrontier_update+0x263>
		frontier = ps_load(&ci->caprange_frontier) - CAPMAX_ENTRY_SZ;
  40e30c:	49 8b 5d 20          	mov    rbx,QWORD PTR [r13+0x20]
	if (self_resources) {
  40e310:	49 39 d5             	cmp    r13,rdx
  40e313:	0f 84 ef 00 00 00    	je     40e408 <cos_comp_capfrontier_update+0x168>
	assert(ci->cap_frontier <= frontier);
  40e319:	48 39 d8             	cmp    rax,rbx
  40e31c:	0f 87 fd 01 00 00    	ja     40e51f <cos_comp_capfrontier_update+0x27f>
	if (likely(ci->cap_frontier != frontier)) return 0;
  40e322:	75 db                	jne    40e2ff <cos_comp_capfrontier_update+0x5f>
	return __mem_bump_alloc(ci, 1, 1);
  40e324:	4c 89 ef             	mov    rdi,r13
  40e327:	e8 34 e5 ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40e32c:	49 89 c2             	mov    r10,rax
	assert(kmem); /* FIXME: should have a failure semantics for capids */
  40e32f:	48 85 c0             	test   rax,rax
  40e332:	0f 84 81 02 00 00    	je     40e5b9 <cos_comp_capfrontier_update+0x319>
	if (self_resources) {
  40e338:	4d 39 e5             	cmp    r13,r12
  40e33b:	0f 84 e6 00 00 00    	je     40e427 <cos_comp_capfrontier_update+0x187>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40e341:	49 8d 94 24 b0 00 00 	lea    rdx,[r12+0xb0]
  40e348:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  40e349:	31 c9                	xor    ecx,ecx
  40e34b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40e350:	48 89 c8             	mov    rax,rcx
  40e353:	f0 4c 0f b1 3a       	lock cmpxchg QWORD PTR [rdx],r15
  40e358:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40e35b:	84 c0                	test   al,al
  40e35d:	74 f1                	je     40e350 <cos_comp_capfrontier_update+0xb0>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40e35f:	41 f6 44 24 38 03    	test   BYTE PTR [r12+0x38],0x3
  40e365:	0f 84 24 02 00 00    	je     40e58f <cos_comp_capfrontier_update+0x2ef>
        __asm__ __volatile__("lock " PS_FAA_STR
  40e36b:	bb 04 00 00 00       	mov    ebx,0x4
  40e370:	f0 49 0f c1 5c 24 38 	lock xadd QWORD PTR [r12+0x38],rbx
{ l->o = 0; }
  40e377:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40e37e:	00 00 00 00 00 
		assert(captblcap);
  40e383:	48 85 db             	test   rbx,rbx
  40e386:	0f 85 9b 00 00 00    	jne    40e427 <cos_comp_capfrontier_update+0x187>
  40e38c:	be 2e 00 00 00       	mov    esi,0x2e
  40e391:	bf c0 d7 41 00       	mov    edi,0x41d7c0
  40e396:	e8 35 bd ff ff       	call   40a0d0 <cos_print_str>
  40e39b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e3a2:	00 00 00 00 
  40e3a6:	0f 0b                	ud2    
  40e3a8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40e3af:	00 
	assert(round_up_to_pow2(cap_frontier, CAPMAX_ENTRY_SZ) == cap_frontier);
  40e3b0:	49 8d 46 03          	lea    rax,[r14+0x3]
  40e3b4:	48 83 e0 fc          	and    rax,0xfffffffffffffffc
  40e3b8:	49 39 c6             	cmp    r14,rax
  40e3bb:	0f 85 96 01 00 00    	jne    40e557 <cos_comp_capfrontier_update+0x2b7>
	ci->cap_frontier = cap_frontier;
  40e3c1:	4d 89 75 18          	mov    QWORD PTR [r13+0x18],r14
	if (cap_frontier < CAPTBL_EXPAND_SZ) {
  40e3c5:	49 83 fe 7f          	cmp    r14,0x7f
  40e3c9:	76 4d                	jbe    40e418 <cos_comp_capfrontier_update+0x178>
		ci->caprange_frontier = round_up_to_pow2(cap_frontier + CAPTBL_EXPAND_SZ, CAPTBL_EXPAND_SZ * 2) - CAPTBL_EXPAND_SZ;
  40e3cb:	49 8d 86 7f 01 00 00 	lea    rax,[r14+0x17f]
  40e3d2:	30 c0                	xor    al,al
  40e3d4:	48 83 c0 80          	add    rax,0xffffffffffffff80
  40e3d8:	66 48 0f 6e c0       	movq   xmm0,rax
		ci->cap16_frontier[i] = ci->cap32_frontier[i] = ci->cap64_frontier[i] = cap_frontier;
  40e3dd:	66 0f 6f 5d b0       	movdqa xmm3,XMMWORD PTR [rbp-0x50]
  40e3e2:	66 49 0f 6e d6       	movq   xmm2,r14
  40e3e7:	66 0f 6c c2          	punpcklqdq xmm0,xmm2
  40e3eb:	41 0f 11 45 20       	movups XMMWORD PTR [r13+0x20],xmm0
  40e3f0:	41 0f 11 5d 30       	movups XMMWORD PTR [r13+0x30],xmm3
			__capid_captbl_check_expand(ci);
		}
	}

	cos_capfrontier_init(ci, cap_frontier);
}
  40e3f5:	48 83 c4 38          	add    rsp,0x38
  40e3f9:	5b                   	pop    rbx
  40e3fa:	41 5c                	pop    r12
  40e3fc:	41 5d                	pop    r13
  40e3fe:	41 5e                	pop    r14
  40e400:	41 5f                	pop    r15
  40e402:	5d                   	pop    rbp
  40e403:	c3                   	ret    
  40e404:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		frontier = ps_load(&ci->caprange_frontier) - CAPMAX_ENTRY_SZ;
  40e408:	48 83 eb 04          	sub    rbx,0x4
  40e40c:	e9 08 ff ff ff       	jmp    40e319 <cos_comp_capfrontier_update+0x79>
  40e411:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		ci->caprange_frontier = round_up_to_pow2(cap_frontier, CAPTBL_EXPAND_SZ);
  40e418:	49 8d 46 7f          	lea    rax,[r14+0x7f]
  40e41c:	48 83 e0 80          	and    rax,0xffffffffffffff80
  40e420:	66 48 0f 6e c0       	movq   xmm0,rax
  40e425:	eb b6                	jmp    40e3dd <cos_comp_capfrontier_update+0x13d>
	captblid_add = ps_load(&ci->caprange_frontier);
  40e427:	49 8b 45 20          	mov    rax,QWORD PTR [r13+0x20]
  40e42b:	48 89 45 a8          	mov    QWORD PTR [rbp-0x58],rax
	assert(captblid_add % CAPTBL_EXPAND_SZ == 0);
  40e42f:	83 e0 7f             	and    eax,0x7f
  40e432:	48 89 45 a0          	mov    QWORD PTR [rbp-0x60],rax
  40e436:	0f 85 99 01 00 00    	jne    40e5d5 <cos_comp_capfrontier_update+0x335>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e43c:	41 8b 44 24 08       	mov    eax,DWORD PTR [r12+0x8]
	__asm__ __volatile__(
  40e441:	4c 89 d7             	mov    rdi,r10
  40e444:	4c 89 fa             	mov    rdx,r15
  40e447:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  40e44b:	49 8b b4 24 98 00 00 	mov    rsi,QWORD PTR [r12+0x98]
  40e452:	00 
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e453:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40e456:	05 1e 00 01 00       	add    eax,0x1001e
	__asm__ __volatile__(
  40e45b:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40e45e:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40e462:	48 89 cd             	mov    rbp,rcx
  40e465:	49 b8 80 e4 40 00 00 	movabs r8,0x40e480
  40e46c:	00 00 00 
  40e46f:	0f 05                	syscall 
  40e471:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  40e478:	eb 0d                	jmp    40e487 <cos_comp_capfrontier_update+0x1e7>
  40e47a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e480:	b9 00 00 00 00       	mov    ecx,0x0
  40e485:	eb 05                	jmp    40e48c <cos_comp_capfrontier_update+0x1ec>
  40e487:	b9 01 00 00 00       	mov    ecx,0x1
  40e48c:	5d                   	pop    rbp
  40e48d:	5c                   	pop    rsp
	if (call_cap_op(meta->captbl_cap, CAPTBL_OP_CAPTBLACTIVATE, captblcap, meta->mi.pgtbl_cap, kmem, 1)) {
  40e48e:	85 c0                	test   eax,eax
  40e490:	0f 85 a5 00 00 00    	jne    40e53b <cos_comp_capfrontier_update+0x29b>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e496:	41 8b 45 08          	mov    eax,DWORD PTR [r13+0x8]
	__asm__ __volatile__(
  40e49a:	48 8b 7d a0          	mov    rdi,QWORD PTR [rbp-0x60]
  40e49e:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  40e4a2:	48 8b 75 a8          	mov    rsi,QWORD PTR [rbp-0x58]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e4a6:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40e4a9:	48 89 fa             	mov    rdx,rdi
	cap_no += op;
  40e4ac:	05 01 00 01 00       	add    eax,0x10001
	__asm__ __volatile__(
  40e4b1:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40e4b4:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40e4b8:	48 89 cd             	mov    rbp,rcx
  40e4bb:	49 b8 d0 e4 40 00 00 	movabs r8,0x40e4d0
  40e4c2:	00 00 00 
  40e4c5:	0f 05                	syscall 
  40e4c7:	90                   	nop
  40e4c8:	eb 0d                	jmp    40e4d7 <cos_comp_capfrontier_update+0x237>
  40e4ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e4d0:	b9 00 00 00 00       	mov    ecx,0x0
  40e4d5:	eb 05                	jmp    40e4dc <cos_comp_capfrontier_update+0x23c>
  40e4d7:	b9 01 00 00 00       	mov    ecx,0x1
  40e4dc:	5d                   	pop    rbp
  40e4dd:	5c                   	pop    rsp
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_CONS, captblcap, captblid_add, 0, 0)) {
  40e4de:	85 c0                	test   eax,eax
  40e4e0:	0f 85 8d 00 00 00    	jne    40e573 <cos_comp_capfrontier_update+0x2d3>
	frontier       = ps_load(&ci->cap_frontier);
  40e4e6:	49 8b 45 18          	mov    rax,QWORD PTR [r13+0x18]
        __asm__ __volatile__("lock " PS_FAA_STR
  40e4ea:	ba 00 01 00 00       	mov    edx,0x100
  40e4ef:	f0 49 0f c1 55 20    	lock xadd QWORD PTR [r13+0x20],rdx
        __asm__ __volatile__("lock " PS_CAS_STR
  40e4f5:	f0 49 0f b1 55 18    	lock cmpxchg QWORD PTR [r13+0x18],rdx
  40e4fb:	0f 94 c0             	sete   al
	return 0;
  40e4fe:	e9 e6 fd ff ff       	jmp    40e2e9 <cos_comp_capfrontier_update+0x49>
  40e503:	be 2e 00 00 00       	mov    esi,0x2e
  40e508:	bf 30 d7 41 00       	mov    edi,0x41d730
  40e50d:	e8 be bb ff ff       	call   40a0d0 <cos_print_str>
	assert(__compinfo_metacap(meta) == meta);
  40e512:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e519:	00 00 00 00 
  40e51d:	0f 0b                	ud2    
  40e51f:	be 2e 00 00 00       	mov    esi,0x2e
  40e524:	bf 60 d7 41 00       	mov    edi,0x41d760
  40e529:	e8 a2 bb ff ff       	call   40a0d0 <cos_print_str>
	assert(ci->cap_frontier <= frontier);
  40e52e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e535:	00 00 00 00 
  40e539:	0f 0b                	ud2    
  40e53b:	be 2e 00 00 00       	mov    esi,0x2e
  40e540:	bf 20 d8 41 00       	mov    edi,0x41d820
  40e545:	e8 86 bb ff ff       	call   40a0d0 <cos_print_str>
		assert(0); /* race condition? */
  40e54a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e551:	00 00 00 00 
  40e555:	0f 0b                	ud2    
  40e557:	be 2e 00 00 00       	mov    esi,0x2e
  40e55c:	bf f0 da 41 00       	mov    edi,0x41daf0
  40e561:	e8 6a bb ff ff       	call   40a0d0 <cos_print_str>
	assert(round_up_to_pow2(cap_frontier, CAPMAX_ENTRY_SZ) == cap_frontier);
  40e566:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e56d:	00 00 00 00 
  40e571:	0f 0b                	ud2    
  40e573:	be 2e 00 00 00       	mov    esi,0x2e
  40e578:	bf 50 d8 41 00       	mov    edi,0x41d850
  40e57d:	e8 4e bb ff ff       	call   40a0d0 <cos_print_str>
		assert(0); /* race? */
  40e582:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e589:	00 00 00 00 
  40e58d:	0f 0b                	ud2    
		if (__capid_captbl_check_expand(ci)) goto error;
  40e58f:	4c 89 e7             	mov    rdi,r12
  40e592:	4c 89 55 a8          	mov    QWORD PTR [rbp-0x58],r10
  40e596:	e8 45 e4 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40e59b:	4c 8b 55 a8          	mov    r10,QWORD PTR [rbp-0x58]
  40e59f:	85 c0                	test   eax,eax
  40e5a1:	75 4e                	jne    40e5f1 <cos_comp_capfrontier_update+0x351>
        __asm__ __volatile__("lock " PS_FAA_STR
  40e5a3:	b8 04 00 00 00       	mov    eax,0x4
  40e5a8:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40e5af:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  40e5b4:	e9 b2 fd ff ff       	jmp    40e36b <cos_comp_capfrontier_update+0xcb>
  40e5b9:	be 2e 00 00 00       	mov    esi,0x2e
  40e5be:	bf 90 d7 41 00       	mov    edi,0x41d790
  40e5c3:	e8 08 bb ff ff       	call   40a0d0 <cos_print_str>
	assert(kmem); /* FIXME: should have a failure semantics for capids */
  40e5c8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e5cf:	00 00 00 00 
  40e5d3:	0f 0b                	ud2    
  40e5d5:	be 2e 00 00 00       	mov    esi,0x2e
  40e5da:	bf f0 d7 41 00       	mov    edi,0x41d7f0
  40e5df:	e8 ec ba ff ff       	call   40a0d0 <cos_print_str>
	assert(captblid_add % CAPTBL_EXPAND_SZ == 0);
  40e5e4:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e5eb:	00 00 00 00 
  40e5ef:	0f 0b                	ud2    
{ l->o = 0; }
  40e5f1:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40e5f8:	00 00 00 00 00 
		assert(captblcap);
  40e5fd:	e9 8a fd ff ff       	jmp    40e38c <cos_comp_capfrontier_update+0xec>
  40e602:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40e609:	00 00 00 00 
  40e60d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040e610 <cos_thd_id_alloc>:
 */
unsigned long __thdid_alloc = NUM_CPU + 2;

thdid_t
cos_thd_id_alloc(void)
{
  40e610:	f3 0f 1e fa          	endbr64 
        __asm__ __volatile__("lock " PS_FAA_STR
  40e614:	b8 01 00 00 00       	mov    eax,0x1
  40e619:	f0 48 0f c1 05 5e da 	lock xadd QWORD PTR [rip+0x4da5e],rax        # 45c080 <__thdid_alloc>
  40e620:	04 00 
  thdid_t assignment = (thdid_t)id;

  assert((unsigned long)assignment == id);

  return assignment;
}
  40e622:	c3                   	ret    
  40e623:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40e62a:	00 00 00 00 
  40e62e:	66 90                	xchg   ax,ax

000000000040e630 <cos_ulk_page_alloc>:
	return toplvl;
}

ulkcap_t
cos_ulk_page_alloc(struct cos_compinfo *ci, pgtblcap_t ulkpt, vaddr_t uaddr)
{
  40e630:	f3 0f 1e fa          	endbr64 
  40e634:	55                   	push   rbp
  40e635:	48 89 e5             	mov    rbp,rsp
  40e638:	41 57                	push   r15
  40e63a:	41 56                	push   r14
  40e63c:	41 55                	push   r13
  40e63e:	41 54                	push   r12
  40e640:	53                   	push   rbx
  40e641:	48 83 ec 28          	sub    rsp,0x28
	return livenessid_frontier++;
  40e645:	44 8b 0d 74 da 04 00 	mov    r9d,DWORD PTR [rip+0x4da74]        # 45c0c0 <livenessid_frontier>
	return ci->memsrc;
  40e64c:	4c 8b 67 60          	mov    r12,QWORD PTR [rdi+0x60]
{
  40e650:	48 89 55 b0          	mov    QWORD PTR [rbp-0x50],rdx
	return livenessid_frontier++;
  40e654:	41 8d 41 01          	lea    eax,[r9+0x1]
  40e658:	89 05 62 da 04 00    	mov    DWORD PTR [rip+0x4da62],eax        # 45c0c0 <livenessid_frontier>
	vaddr_t kmem;
	capid_t cap;
	u32_t   lid = livenessid_bump_alloc();

	printd("cos_ulk_pgtbl_create\n");
	assert(ci_resources && ulkpt);
  40e65e:	4d 85 e4             	test   r12,r12
  40e661:	0f 84 7f 01 00 00    	je     40e7e6 <cos_ulk_page_alloc+0x1b6>
  40e667:	49 89 f5             	mov    r13,rsi
  40e66a:	48 85 f6             	test   rsi,rsi
  40e66d:	0f 84 73 01 00 00    	je     40e7e6 <cos_ulk_page_alloc+0x1b6>
	return __mem_bump_alloc(ci, 1, 1);
  40e673:	4c 89 e7             	mov    rdi,r12
  40e676:	44 89 4d bc          	mov    DWORD PTR [rbp-0x44],r9d
  40e67a:	e8 e1 e1 ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40e67f:	49 89 c6             	mov    r14,rax
	if (!*kmem) return -1;
  40e682:	48 85 c0             	test   rax,rax
  40e685:	0f 84 77 01 00 00    	je     40e802 <cos_ulk_page_alloc+0x1d2>
        __asm__ __volatile__("lock " PS_CAS_STR
  40e68b:	44 8b 4d bc          	mov    r9d,DWORD PTR [rbp-0x44]
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40e68f:	49 8d 8c 24 b0 00 00 	lea    rcx,[r12+0xb0]
  40e696:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  40e697:	ba 01 00 00 00       	mov    edx,0x1
  40e69c:	45 31 c0             	xor    r8d,r8d
  40e69f:	90                   	nop
  40e6a0:	4c 89 c0             	mov    rax,r8
  40e6a3:	f0 48 0f b1 11       	lock cmpxchg QWORD PTR [rcx],rdx
  40e6a8:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40e6ab:	84 c0                	test   al,al
  40e6ad:	74 f1                	je     40e6a0 <cos_ulk_page_alloc+0x70>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40e6af:	4d 8b 7c 24 30       	mov    r15,QWORD PTR [r12+0x30]
  40e6b4:	41 83 e7 03          	and    r15d,0x3
  40e6b8:	0f 84 b2 00 00 00    	je     40e770 <cos_ulk_page_alloc+0x140>
        __asm__ __volatile__("lock " PS_FAA_STR
  40e6be:	bb 02 00 00 00       	mov    ebx,0x2
  40e6c3:	f0 49 0f c1 5c 24 30 	lock xadd QWORD PTR [r12+0x30],rbx
{ l->o = 0; }
  40e6ca:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40e6d1:	00 00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  40e6d6:	49 89 df             	mov    r15,rbx
	if (!*cap) return -1;
  40e6d9:	48 85 db             	test   rbx,rbx
  40e6dc:	0f 84 20 01 00 00    	je     40e802 <cos_ulk_page_alloc+0x1d2>

	if (__alloc_mem_cap(ci_resources, CAP_ULK, &kmem, &cap)) return 0;
	assert(kmem && (round_to_page(kmem) == kmem));
  40e6e2:	41 f7 c6 ff 0f 00 00 	test   r14d,0xfff
  40e6e9:	0f 85 db 00 00 00    	jne    40e7ca <cos_ulk_page_alloc+0x19a>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e6ef:	41 8b 44 24 08       	mov    eax,DWORD PTR [r12+0x8]
	if (call_cap_op(ci_resources->captbl_cap, CAPTBL_OP_ULK_MEMACTIVATE, cap << 16 | lid, ci_resources->mi.pgtbl_cap << 16 | ulkpt, kmem, uaddr))
  40e6f4:	48 c1 e3 10          	shl    rbx,0x10
  40e6f8:	45 89 c9             	mov    r9d,r9d
	__asm__ __volatile__(
  40e6fb:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  40e6ff:	49 8b 94 24 98 00 00 	mov    rdx,QWORD PTR [r12+0x98]
  40e706:	00 
  40e707:	4c 09 cb             	or     rbx,r9
  40e70a:	4c 89 f7             	mov    rdi,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e70d:	c1 e0 10             	shl    eax,0x10
  40e710:	48 c1 e2 10          	shl    rdx,0x10
	cap_no += op;
  40e714:	05 38 00 01 00       	add    eax,0x10038
  40e719:	48 89 d6             	mov    rsi,rdx
	__asm__ __volatile__(
  40e71c:	48 8b 55 b0          	mov    rdx,QWORD PTR [rbp-0x50]
  40e720:	4c 09 ee             	or     rsi,r13
  40e723:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40e726:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40e72a:	48 89 cd             	mov    rbp,rcx
  40e72d:	49 b8 48 e7 40 00 00 	movabs r8,0x40e748
  40e734:	00 00 00 
  40e737:	0f 05                	syscall 
  40e739:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  40e740:	eb 0d                	jmp    40e74f <cos_ulk_page_alloc+0x11f>
  40e742:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e748:	b9 00 00 00 00       	mov    ecx,0x0
  40e74d:	eb 05                	jmp    40e754 <cos_ulk_page_alloc+0x124>
  40e74f:	b9 01 00 00 00       	mov    ecx,0x1
  40e754:	5d                   	pop    rbp
  40e755:	5c                   	pop    rsp
  40e756:	85 c0                	test   eax,eax
  40e758:	75 46                	jne    40e7a0 <cos_ulk_page_alloc+0x170>
		BUG();

	return cap;
}
  40e75a:	48 83 c4 28          	add    rsp,0x28
  40e75e:	4c 89 f8             	mov    rax,r15
  40e761:	5b                   	pop    rbx
  40e762:	41 5c                	pop    r12
  40e764:	41 5d                	pop    r13
  40e766:	41 5e                	pop    r14
  40e768:	41 5f                	pop    r15
  40e76a:	5d                   	pop    rbp
  40e76b:	c3                   	ret    
  40e76c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  40e770:	4c 89 e7             	mov    rdi,r12
  40e773:	44 89 4d bc          	mov    DWORD PTR [rbp-0x44],r9d
  40e777:	e8 64 e2 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40e77c:	44 8b 4d bc          	mov    r9d,DWORD PTR [rbp-0x44]
  40e780:	85 c0                	test   eax,eax
  40e782:	75 38                	jne    40e7bc <cos_ulk_page_alloc+0x18c>
        __asm__ __volatile__("lock " PS_FAA_STR
  40e784:	b8 04 00 00 00       	mov    eax,0x4
  40e789:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40e790:	49 89 44 24 30       	mov    QWORD PTR [r12+0x30],rax
  40e795:	e9 24 ff ff ff       	jmp    40e6be <cos_ulk_page_alloc+0x8e>
  40e79a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e7a0:	be 1b 00 00 00       	mov    esi,0x1b
  40e7a5:	bf af dd 41 00       	mov    edi,0x41ddaf
  40e7aa:	e8 21 b9 ff ff       	call   40a0d0 <cos_print_str>
		BUG();
  40e7af:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e7b6:	00 00 00 00 
  40e7ba:	0f 0b                	ud2    
{ l->o = 0; }
  40e7bc:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40e7c3:	00 00 00 00 00 
	if (!*cap) return -1;
  40e7c8:	eb 90                	jmp    40e75a <cos_ulk_page_alloc+0x12a>
  40e7ca:	be 2e 00 00 00       	mov    esi,0x2e
  40e7cf:	bf 80 dd 41 00       	mov    edi,0x41dd80
  40e7d4:	e8 f7 b8 ff ff       	call   40a0d0 <cos_print_str>
	assert(kmem && (round_to_page(kmem) == kmem));
  40e7d9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e7e0:	00 00 00 00 
  40e7e4:	0f 0b                	ud2    
  40e7e6:	be 2e 00 00 00       	mov    esi,0x2e
  40e7eb:	bf 50 dd 41 00       	mov    edi,0x41dd50
  40e7f0:	e8 db b8 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci_resources && ulkpt);
  40e7f5:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e7fc:	00 00 00 00 
  40e800:	0f 0b                	ud2    
	if (__alloc_mem_cap(ci_resources, CAP_ULK, &kmem, &cap)) return 0;
  40e802:	45 31 ff             	xor    r15d,r15d
  40e805:	e9 50 ff ff ff       	jmp    40e75a <cos_ulk_page_alloc+0x12a>
  40e80a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000040e810 <__cos_thd_alloc>:
	return __cos_ulk_info.curr_pg;
}

static thdcap_t
__cos_thd_alloc(struct cos_compinfo *ci, compcap_t comp, thdclosure_index_t init_data, thdid_t tid)
{
  40e810:	55                   	push   rbp
  40e811:	48 89 e5             	mov    rbp,rsp
  40e814:	41 57                	push   r15
  40e816:	41 56                	push   r14
  40e818:	41 55                	push   r13
  40e81a:	41 54                	push   r12
  40e81c:	53                   	push   rbx
  40e81d:	48 83 ec 28          	sub    rsp,0x28
  40e821:	48 89 4d b8          	mov    QWORD PTR [rbp-0x48],rcx
	capid_t  cap;
	int      ret;

	printd("cos_thd_alloc\n");

	assert(ci && comp > 0);
  40e825:	48 85 ff             	test   rdi,rdi
  40e828:	0f 84 bb 01 00 00    	je     40e9e9 <__cos_thd_alloc+0x1d9>
  40e82e:	49 89 f7             	mov    r15,rsi
  40e831:	48 85 f6             	test   rsi,rsi
  40e834:	0f 84 af 01 00 00    	je     40e9e9 <__cos_thd_alloc+0x1d9>
	if (!__cos_ulk_info.toplvl) return 0;
  40e83a:	4c 8b 25 3f 22 19 00 	mov    r12,QWORD PTR [rip+0x19223f]        # 5a0a80 <__cos_ulk_info>
  40e841:	49 89 fd             	mov    r13,rdi
  40e844:	89 d3                	mov    ebx,edx
  40e846:	4d 85 e4             	test   r12,r12
  40e849:	74 46                	je     40e891 <__cos_thd_alloc+0x81>
	if (!__cos_ulk_info.curr_pg || tid % ULK_STACKS_PER_PAGE == 0) {
  40e84b:	48 8b 05 3e 22 19 00 	mov    rax,QWORD PTR [rip+0x19223e]        # 5a0a90 <__cos_ulk_info+0x10>
  40e852:	48 85 c0             	test   rax,rax
  40e855:	74 0a                	je     40e861 <__cos_thd_alloc+0x51>
  40e857:	f6 45 b8 0f          	test   BYTE PTR [rbp-0x48],0xf
  40e85b:	0f 85 4f 01 00 00    	jne    40e9b0 <__cos_thd_alloc+0x1a0>
		__cos_ulk_info.curr_pg = cos_ulk_page_alloc(ci, __cos_ulk_info.toplvl, __cos_ulk_info.pg_frontier);
  40e861:	48 8b 15 30 22 19 00 	mov    rdx,QWORD PTR [rip+0x192230]        # 5a0a98 <__cos_ulk_info+0x18>
  40e868:	4c 89 e6             	mov    rsi,r12
  40e86b:	4c 89 ef             	mov    rdi,r13
  40e86e:	e8 bd fd ff ff       	call   40e630 <cos_ulk_page_alloc>
  40e873:	48 89 05 16 22 19 00 	mov    QWORD PTR [rip+0x192216],rax        # 5a0a90 <__cos_ulk_info+0x10>
  40e87a:	49 89 c4             	mov    r12,rax
		assert(__cos_ulk_info.curr_pg);
  40e87d:	48 85 c0             	test   rax,rax
  40e880:	0f 84 9b 01 00 00    	je     40ea21 <__cos_thd_alloc+0x211>
		__cos_ulk_info.pg_frontier += PAGE_SIZE;
  40e886:	48 81 05 07 22 19 00 	add    QWORD PTR [rip+0x192207],0x1000        # 5a0a98 <__cos_ulk_info+0x18>
  40e88d:	00 10 00 00 
	return __mem_bump_alloc(ci, 1, 1);
  40e891:	4c 89 ef             	mov    rdi,r13
  40e894:	e8 c7 df ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40e899:	49 89 c2             	mov    r10,rax
	if (!*kmem) return -1;
  40e89c:	48 85 c0             	test   rax,rax
  40e89f:	0f 84 98 01 00 00    	je     40ea3d <__cos_thd_alloc+0x22d>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40e8a5:	49 8d 8d b0 00 00 00 	lea    rcx,[r13+0xb0]
        __asm__ __volatile__("lock " PS_CAS_STR
  40e8ac:	ba 01 00 00 00       	mov    edx,0x1
  40e8b1:	31 f6                	xor    esi,esi
  40e8b3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40e8b8:	48 89 f0             	mov    rax,rsi
  40e8bb:	f0 48 0f b1 11       	lock cmpxchg QWORD PTR [rcx],rdx
  40e8c0:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40e8c3:	84 c0                	test   al,al
  40e8c5:	74 f1                	je     40e8b8 <__cos_thd_alloc+0xa8>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40e8c7:	4d 8b 75 28          	mov    r14,QWORD PTR [r13+0x28]
  40e8cb:	41 83 e6 03          	and    r14d,0x3
  40e8cf:	0f 84 b3 00 00 00    	je     40e988 <__cos_thd_alloc+0x178>
        __asm__ __volatile__("lock " PS_FAA_STR
  40e8d5:	ba 01 00 00 00       	mov    edx,0x1
  40e8da:	f0 49 0f c1 55 28    	lock xadd QWORD PTR [r13+0x28],rdx
{ l->o = 0; }
  40e8e0:	49 c7 85 b0 00 00 00 	mov    QWORD PTR [r13+0xb0],0x0
  40e8e7:	00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  40e8eb:	49 89 d6             	mov    r14,rdx
	if (!*cap) return -1;
  40e8ee:	48 85 d2             	test   rdx,rdx
  40e8f1:	0f 84 46 01 00 00    	je     40ea3d <__cos_thd_alloc+0x22d>

	ulkcap = __cos_thd_ulk_page_alloc(ci, tid);

	if (__alloc_mem_cap(ci, CAP_THD, &kmem, &cap)) return 0;
	assert(!(init_data & ~((1 << 16) - 1)));
  40e8f7:	f7 c3 00 00 ff ff    	test   ebx,0xffff0000
  40e8fd:	0f 85 02 01 00 00    	jne    40ea05 <__cos_thd_alloc+0x1f5>
	/* TODO: Add cap size checking */
	ret = call_cap_op(ci->captbl_cap, CAPTBL_OP_THDACTIVATE, (init_data << 16) | cap,
  40e903:	c1 e3 10             	shl    ebx,0x10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e906:	41 8b 45 08          	mov    eax,DWORD PTR [r13+0x8]
	__asm__ __volatile__(
  40e90a:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  40e90e:	4c 89 d7             	mov    rdi,r10
  40e911:	48 63 db             	movsxd rbx,ebx
  40e914:	48 09 d3             	or     rbx,rdx
			  __compinfo_metacap(ci)->mi.pgtbl_cap << 16 | comp, kmem, ulkcap << 16 | tid);
  40e917:	49 8b 55 60          	mov    rdx,QWORD PTR [r13+0x60]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e91b:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40e91e:	05 04 00 01 00       	add    eax,0x10004
  40e923:	48 8b b2 98 00 00 00 	mov    rsi,QWORD PTR [rdx+0x98]
  40e92a:	4c 89 e2             	mov    rdx,r12
  40e92d:	48 c1 e2 10          	shl    rdx,0x10
	ret = call_cap_op(ci->captbl_cap, CAPTBL_OP_THDACTIVATE, (init_data << 16) | cap,
  40e931:	48 0b 55 b8          	or     rdx,QWORD PTR [rbp-0x48]
			  __compinfo_metacap(ci)->mi.pgtbl_cap << 16 | comp, kmem, ulkcap << 16 | tid);
  40e935:	48 c1 e6 10          	shl    rsi,0x10
	ret = call_cap_op(ci->captbl_cap, CAPTBL_OP_THDACTIVATE, (init_data << 16) | cap,
  40e939:	4c 09 fe             	or     rsi,r15
	__asm__ __volatile__(
  40e93c:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40e93f:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40e943:	48 89 cd             	mov    rbp,rcx
  40e946:	49 b8 60 e9 40 00 00 	movabs r8,0x40e960
  40e94d:	00 00 00 
  40e950:	0f 05                	syscall 
  40e952:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e958:	eb 0d                	jmp    40e967 <__cos_thd_alloc+0x157>
  40e95a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e960:	b9 00 00 00 00       	mov    ecx,0x0
  40e965:	eb 05                	jmp    40e96c <__cos_thd_alloc+0x15c>
  40e967:	b9 01 00 00 00       	mov    ecx,0x1
  40e96c:	5d                   	pop    rbp
  40e96d:	5c                   	pop    rsp
	if (ret) BUG();
  40e96e:	85 c0                	test   eax,eax
  40e970:	75 4e                	jne    40e9c0 <__cos_thd_alloc+0x1b0>

	return cap;
}
  40e972:	48 83 c4 28          	add    rsp,0x28
  40e976:	4c 89 f0             	mov    rax,r14
  40e979:	5b                   	pop    rbx
  40e97a:	41 5c                	pop    r12
  40e97c:	41 5d                	pop    r13
  40e97e:	41 5e                	pop    r14
  40e980:	41 5f                	pop    r15
  40e982:	5d                   	pop    rbp
  40e983:	c3                   	ret    
  40e984:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  40e988:	4c 89 ef             	mov    rdi,r13
  40e98b:	4c 89 55 b0          	mov    QWORD PTR [rbp-0x50],r10
  40e98f:	e8 4c e0 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40e994:	4c 8b 55 b0          	mov    r10,QWORD PTR [rbp-0x50]
  40e998:	85 c0                	test   eax,eax
  40e99a:	75 40                	jne    40e9dc <__cos_thd_alloc+0x1cc>
        __asm__ __volatile__("lock " PS_FAA_STR
  40e99c:	b8 04 00 00 00       	mov    eax,0x4
  40e9a1:	f0 49 0f c1 45 18    	lock xadd QWORD PTR [r13+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40e9a7:	49 89 45 28          	mov    QWORD PTR [r13+0x28],rax
  40e9ab:	e9 25 ff ff ff       	jmp    40e8d5 <__cos_thd_alloc+0xc5>
  40e9b0:	49 89 c4             	mov    r12,rax
	return __cos_ulk_info.curr_pg;
  40e9b3:	e9 d9 fe ff ff       	jmp    40e891 <__cos_thd_alloc+0x81>
  40e9b8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40e9bf:	00 
  40e9c0:	be 1b 00 00 00       	mov    esi,0x1b
  40e9c5:	bf 5f de 41 00       	mov    edi,0x41de5f
  40e9ca:	e8 01 b7 ff ff       	call   40a0d0 <cos_print_str>
	if (ret) BUG();
  40e9cf:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e9d6:	00 00 00 00 
  40e9da:	0f 0b                	ud2    
{ l->o = 0; }
  40e9dc:	49 c7 85 b0 00 00 00 	mov    QWORD PTR [r13+0xb0],0x0
  40e9e3:	00 00 00 00 
	if (!*cap) return -1;
  40e9e7:	eb 89                	jmp    40e972 <__cos_thd_alloc+0x162>
  40e9e9:	be 2e 00 00 00       	mov    esi,0x2e
  40e9ee:	bf d0 dd 41 00       	mov    edi,0x41ddd0
  40e9f3:	e8 d8 b6 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci && comp > 0);
  40e9f8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e9ff:	00 00 00 00 
  40ea03:	0f 0b                	ud2    
  40ea05:	be 2e 00 00 00       	mov    esi,0x2e
  40ea0a:	bf 30 de 41 00       	mov    edi,0x41de30
  40ea0f:	e8 bc b6 ff ff       	call   40a0d0 <cos_print_str>
	assert(!(init_data & ~((1 << 16) - 1)));
  40ea14:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ea1b:	00 00 00 00 
  40ea1f:	0f 0b                	ud2    
  40ea21:	be 2e 00 00 00       	mov    esi,0x2e
  40ea26:	bf 00 de 41 00       	mov    edi,0x41de00
  40ea2b:	e8 a0 b6 ff ff       	call   40a0d0 <cos_print_str>
		assert(__cos_ulk_info.curr_pg);
  40ea30:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ea37:	00 00 00 00 
  40ea3b:	0f 0b                	ud2    
	if (__alloc_mem_cap(ci, CAP_THD, &kmem, &cap)) return 0;
  40ea3d:	45 31 f6             	xor    r14d,r14d
  40ea40:	e9 2d ff ff ff       	jmp    40e972 <__cos_thd_alloc+0x162>
  40ea45:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40ea4c:	00 00 00 00 

000000000040ea50 <cos_ulk_map_in>:
{
  40ea50:	f3 0f 1e fa          	endbr64 
  40ea54:	55                   	push   rbp
  40ea55:	48 89 e5             	mov    rbp,rsp
  40ea58:	41 54                	push   r12
  40ea5a:	53                   	push   rbx
  40ea5b:	48 83 ec 10          	sub    rsp,0x10
	assert(ptc && __cos_ulk_info.secondlvl);
  40ea5f:	48 85 ff             	test   rdi,rdi
  40ea62:	74 67                	je     40eacb <cos_ulk_map_in+0x7b>
  40ea64:	48 8b 1d 1d 20 19 00 	mov    rbx,QWORD PTR [rip+0x19201d]        # 5a0a88 <__cos_ulk_info+0x8>
  40ea6b:	48 85 db             	test   rbx,rbx
  40ea6e:	74 5b                	je     40eacb <cos_ulk_map_in+0x7b>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40ea70:	c1 e7 10             	shl    edi,0x10
	__asm__ __volatile__(
  40ea73:	31 d2                	xor    edx,edx
  40ea75:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  40ea79:	48 be 00 00 00 00 80 	movabs rsi,0x7f8000000000
  40ea80:	7f 00 00 
	cap_no += op;
  40ea83:	8d 87 01 00 01 00    	lea    eax,[rdi+0x10001]
	__asm__ __volatile__(
  40ea89:	48 89 d7             	mov    rdi,rdx
  40ea8c:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40ea8f:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40ea93:	48 89 cd             	mov    rbp,rcx
  40ea96:	49 b8 b0 ea 40 00 00 	movabs r8,0x40eab0
  40ea9d:	00 00 00 
  40eaa0:	0f 05                	syscall 
  40eaa2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40eaa8:	eb 0d                	jmp    40eab7 <cos_ulk_map_in+0x67>
  40eaaa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40eab0:	b9 00 00 00 00       	mov    ecx,0x0
  40eab5:	eb 05                	jmp    40eabc <cos_ulk_map_in+0x6c>
  40eab7:	b9 01 00 00 00       	mov    ecx,0x1
  40eabc:	5d                   	pop    rbp
  40eabd:	5c                   	pop    rsp
	if (call_cap_op(ptc, CAPTBL_OP_CONS, __cos_ulk_info.secondlvl, ULK_BASE_ADDR, 0, 0)) {
  40eabe:	f7 d8                	neg    eax
  40eac0:	19 c0                	sbb    eax,eax
}
  40eac2:	48 83 c4 10          	add    rsp,0x10
  40eac6:	5b                   	pop    rbx
  40eac7:	41 5c                	pop    r12
  40eac9:	5d                   	pop    rbp
  40eaca:	c3                   	ret    
  40eacb:	be 2e 00 00 00       	mov    esi,0x2e
  40ead0:	bf 80 de 41 00       	mov    edi,0x41de80
  40ead5:	e8 f6 b5 ff ff       	call   40a0d0 <cos_print_str>
	assert(ptc && __cos_ulk_info.secondlvl);
  40eada:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40eae1:	00 00 00 00 
  40eae5:	0f 0b                	ud2    
  40eae7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40eaee:	00 00 

000000000040eaf0 <cos_thd_alloc_ext>:

#include <cos_thd_init.h>

thdcap_t
cos_thd_alloc_ext(struct cos_compinfo *ci, compcap_t comp, thdclosure_index_t idx)
{
  40eaf0:	f3 0f 1e fa          	endbr64 
        __asm__ __volatile__("lock " PS_FAA_STR
  40eaf4:	b9 01 00 00 00       	mov    ecx,0x1
  40eaf9:	f0 48 0f c1 0d 7e d5 	lock xadd QWORD PTR [rip+0x4d57e],rcx        # 45c080 <__thdid_alloc>
  40eb00:	04 00 
	thdid_t tid = cos_thd_id_alloc();

	if (idx < 1) return 0;
  40eb02:	85 d2                	test   edx,edx
  40eb04:	7e 0a                	jle    40eb10 <cos_thd_alloc_ext+0x20>

	return __cos_thd_alloc(ci, comp, idx, tid);
  40eb06:	e9 05 fd ff ff       	jmp    40e810 <__cos_thd_alloc>
  40eb0b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
}
  40eb10:	31 c0                	xor    eax,eax
  40eb12:	c3                   	ret    
  40eb13:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40eb1a:	00 00 00 00 
  40eb1e:	66 90                	xchg   ax,ax

000000000040eb20 <cos_thd_alloc>:

thdcap_t
cos_thd_alloc(struct cos_compinfo *ci, compcap_t comp, cos_thd_fn_t fn, void *data)
{
  40eb20:	f3 0f 1e fa          	endbr64 
  40eb24:	49 89 ca             	mov    r10,rcx
  40eb27:	b9 01 00 00 00       	mov    ecx,0x1
  40eb2c:	f0 48 0f c1 0d 4b d5 	lock xadd QWORD PTR [rip+0x4d54b],rcx        # 45c080 <__thdid_alloc>
  40eb33:	04 00 
	if (!fn) return -1;
  40eb35:	48 85 d2             	test   rdx,rdx
  40eb38:	0f 84 c9 00 00 00    	je     40ec07 <cos_thd_alloc+0xe7>
  40eb3e:	55                   	push   rbp
  40eb3f:	49 89 f8             	mov    r8,rdi
  40eb42:	49 89 f1             	mov    r9,rsi
  40eb45:	48 89 d7             	mov    rdi,rdx
  40eb48:	45 31 db             	xor    r11d,r11d
  40eb4b:	48 89 e5             	mov    rbp,rsp
  40eb4e:	41 54                	push   r12
  40eb50:	53                   	push   rbx
  40eb51:	bb 02 00 00 00       	mov    ebx,0x2
	for (i = 0; i < COS_THD_INIT_REGION_SIZE; i++) {
  40eb56:	ba 40 f9 59 00       	mov    edx,0x59f940
  40eb5b:	31 f6                	xor    esi,esi
		if (__thd_init_data[i].fn == NULL) {
  40eb5d:	48 83 3a 00          	cmp    QWORD PTR [rdx],0x0
  40eb61:	74 1d                	je     40eb80 <cos_thd_alloc+0x60>
	for (i = 0; i < COS_THD_INIT_REGION_SIZE; i++) {
  40eb63:	83 c6 01             	add    esi,0x1
  40eb66:	48 83 c2 10          	add    rdx,0x10
  40eb6a:	81 fe 00 01 00 00    	cmp    esi,0x100
  40eb70:	75 eb                	jne    40eb5d <cos_thd_alloc+0x3d>
	if (!tried) {
  40eb72:	83 fb 01             	cmp    ebx,0x1
  40eb75:	74 6d                	je     40ebe4 <cos_thd_alloc+0xc4>
  40eb77:	bb 01 00 00 00       	mov    ebx,0x1
  40eb7c:	eb d8                	jmp    40eb56 <cos_thd_alloc+0x36>
  40eb7e:	66 90                	xchg   ax,ax
  40eb80:	4c 89 d8             	mov    rax,r11
  40eb83:	f0 48 0f b1 3a       	lock cmpxchg QWORD PTR [rdx],rdi
  40eb88:	0f 94 c0             	sete   al
			if (!ret) continue;
  40eb8b:	84 c0                	test   al,al
  40eb8d:	74 d4                	je     40eb63 <cos_thd_alloc+0x43>
			assert(__thd_init_data[i].fn == fn);
  40eb8f:	4c 63 e6             	movsxd r12,esi
  40eb92:	49 c1 e4 04          	shl    r12,0x4
  40eb96:	49 8d 84 24 40 f9 59 	lea    rax,[r12+0x59f940]
  40eb9d:	00 
  40eb9e:	49 3b bc 24 40 f9 59 	cmp    rdi,QWORD PTR [r12+0x59f940]
  40eba5:	00 
  40eba6:	75 43                	jne    40ebeb <cos_thd_alloc+0xcb>
			__thd_init_data[i].data = data;
  40eba8:	4c 89 50 08          	mov    QWORD PTR [rax+0x8],r10
			return i + 1;
  40ebac:	8d 5e 01             	lea    ebx,[rsi+0x1]
	thdid_t  tid = cos_thd_id_alloc();
	int      idx = cos_thd_init_alloc(fn, data);
	thdcap_t ret;

	if (idx < 1) return 0;
	ret = __cos_thd_alloc(ci, comp, idx, tid);
  40ebaf:	4c 89 c7             	mov    rdi,r8
  40ebb2:	4c 89 ce             	mov    rsi,r9
  40ebb5:	89 da                	mov    edx,ebx
  40ebb7:	e8 54 fc ff ff       	call   40e810 <__cos_thd_alloc>
	if (!ret) cos_thd_init_free(idx);
  40ebbc:	48 85 c0             	test   rax,rax
  40ebbf:	75 1e                	jne    40ebdf <cos_thd_alloc+0xbf>
 * thread creation failed for some reason.
 */
static void
cos_thd_init_free(thdclosure_index_t idx)
{
	if (idx > COS_THD_INIT_REGION_SIZE || idx <= 0 || !__thd_init_data[idx].fn) return;
  40ebc1:	48 63 f3             	movsxd rsi,ebx
  40ebc4:	48 c1 e6 04          	shl    rsi,0x4
  40ebc8:	48 83 be 40 f9 59 00 	cmp    QWORD PTR [rsi+0x59f940],0x0
  40ebcf:	00 
  40ebd0:	74 12                	je     40ebe4 <cos_thd_alloc+0xc4>
	__thd_init_data[idx].fn   = NULL;
  40ebd2:	66 0f ef c0          	pxor   xmm0,xmm0
  40ebd6:	41 0f 11 84 24 40 f9 	movups XMMWORD PTR [r12+0x59f940],xmm0
  40ebdd:	59 00 

	return ret;
}
  40ebdf:	5b                   	pop    rbx
  40ebe0:	41 5c                	pop    r12
  40ebe2:	5d                   	pop    rbp
  40ebe3:	c3                   	ret    
  40ebe4:	5b                   	pop    rbx
	if (idx < 1) return 0;
  40ebe5:	31 c0                	xor    eax,eax
}
  40ebe7:	41 5c                	pop    r12
  40ebe9:	5d                   	pop    rbp
  40ebea:	c3                   	ret    
  40ebeb:	be 67 00 00 00       	mov    esi,0x67
  40ebf0:	bf b0 de 41 00       	mov    edi,0x41deb0
  40ebf5:	e8 d6 b4 ff ff       	call   40a0d0 <cos_print_str>
			assert(__thd_init_data[i].fn == fn);
  40ebfa:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ec01:	00 00 00 00 
  40ec05:	0f 0b                	ud2    
	if (idx < 1) return 0;
  40ec07:	31 c0                	xor    eax,eax
}
  40ec09:	c3                   	ret    
  40ec0a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000040ec10 <cos_shared_kernel_page_alloc_at>:

vaddr_t
cos_shared_kernel_page_alloc_at(struct cos_compinfo *ci, vaddr_t mem_ptr)
{
  40ec10:	f3 0f 1e fa          	endbr64 
  40ec14:	55                   	push   rbp
  40ec15:	48 89 e5             	mov    rbp,rsp
  40ec18:	41 55                	push   r13
  40ec1a:	41 54                	push   r12
  40ec1c:	53                   	push   rbx
  40ec1d:	48 83 ec 18          	sub    rsp,0x18
	return ci->memsrc;
  40ec21:	4c 8b 67 60          	mov    r12,QWORD PTR [rdi+0x60]
	vaddr_t ptemem_cap;
	int ret;

	struct cos_compinfo *meta = __compinfo_metacap(ci);

	assert(meta == __compinfo_metacap(meta));
  40ec25:	4d 39 64 24 60       	cmp    QWORD PTR [r12+0x60],r12
  40ec2a:	0f 85 9c 00 00 00    	jne    40eccc <cos_shared_kernel_page_alloc_at+0xbc>
  40ec30:	48 89 fb             	mov    rbx,rdi
	return __mem_bump_alloc(ci, 1, 1);
  40ec33:	4c 89 e7             	mov    rdi,r12
  40ec36:	49 89 f5             	mov    r13,rsi
  40ec39:	e8 22 dc ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40ec3e:	49 89 c2             	mov    r10,rax

	ptemem_cap = __kmem_bump_alloc(meta);

	assert(ptemem_cap != 0);
  40ec41:	48 85 c0             	test   rax,rax
  40ec44:	0f 84 9e 00 00 00    	je     40ece8 <cos_shared_kernel_page_alloc_at+0xd8>
  40ec4a:	48 8b 33             	mov    rsi,QWORD PTR [rbx]
  40ec4d:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  40ec51:	ba 0c 00 00 00       	mov    edx,0xc
  40ec56:	4c 89 d3             	mov    rbx,r10

	/* Actually map in the memory. */
	ret = call_cap_op(meta->mi.pgtbl_cap, CAPTBL_OP_MEMACTIVATE, ptemem_cap, ci->pgtbl_cap, mem_ptr, PAGE_ORDER);
  40ec59:	49 8b 84 24 98 00 00 	mov    rax,QWORD PTR [r12+0x98]
  40ec60:	00 
  40ec61:	4c 89 ef             	mov    rdi,r13
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40ec64:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40ec67:	05 17 00 01 00       	add    eax,0x10017
	__asm__ __volatile__(
  40ec6c:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40ec6f:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40ec73:	48 89 cd             	mov    rbp,rcx
  40ec76:	49 b8 90 ec 40 00 00 	movabs r8,0x40ec90
  40ec7d:	00 00 00 
  40ec80:	0f 05                	syscall 
  40ec82:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40ec88:	eb 0d                	jmp    40ec97 <cos_shared_kernel_page_alloc_at+0x87>
  40ec8a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40ec90:	b9 00 00 00 00       	mov    ecx,0x0
  40ec95:	eb 05                	jmp    40ec9c <cos_shared_kernel_page_alloc_at+0x8c>
  40ec97:	b9 01 00 00 00       	mov    ecx,0x1
  40ec9c:	5d                   	pop    rbp
  40ec9d:	5c                   	pop    rsp
	if (ret) {
  40ec9e:	85 c0                	test   eax,eax
  40eca0:	75 0e                	jne    40ecb0 <cos_shared_kernel_page_alloc_at+0xa0>
		BUG();
	}

	return ptemem_cap;
}
  40eca2:	48 83 c4 18          	add    rsp,0x18
  40eca6:	4c 89 d0             	mov    rax,r10
  40eca9:	5b                   	pop    rbx
  40ecaa:	41 5c                	pop    r12
  40ecac:	41 5d                	pop    r13
  40ecae:	5d                   	pop    rbp
  40ecaf:	c3                   	ret    
  40ecb0:	be 1c 00 00 00       	mov    esi,0x1c
  40ecb5:	bf 78 df 41 00       	mov    edi,0x41df78
  40ecba:	e8 11 b4 ff ff       	call   40a0d0 <cos_print_str>
		BUG();
  40ecbf:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ecc6:	00 00 00 00 
  40ecca:	0f 0b                	ud2    
  40eccc:	be 2f 00 00 00       	mov    esi,0x2f
  40ecd1:	bf 18 df 41 00       	mov    edi,0x41df18
  40ecd6:	e8 f5 b3 ff ff       	call   40a0d0 <cos_print_str>
	assert(meta == __compinfo_metacap(meta));
  40ecdb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ece2:	00 00 00 00 
  40ece6:	0f 0b                	ud2    
  40ece8:	be 2f 00 00 00       	mov    esi,0x2f
  40eced:	bf 48 df 41 00       	mov    edi,0x41df48
  40ecf2:	e8 d9 b3 ff ff       	call   40a0d0 <cos_print_str>
	assert(ptemem_cap != 0);
  40ecf7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ecfe:	00 00 00 00 
  40ed02:	0f 0b                	ud2    
  40ed04:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40ed0b:	00 00 00 00 
  40ed0f:	90                   	nop

000000000040ed10 <cos_shared_kernel_page_alloc>:

vaddr_t
cos_shared_kernel_page_alloc(struct cos_compinfo *ci, vaddr_t *resource)
{
  40ed10:	f3 0f 1e fa          	endbr64 
  40ed14:	55                   	push   rbp
  40ed15:	48 89 e5             	mov    rbp,rsp
  40ed18:	41 56                	push   r14
  40ed1a:	41 55                	push   r13
  40ed1c:	41 54                	push   r12
  40ed1e:	53                   	push   rbx
  40ed1f:	48 83 ec 10          	sub    rsp,0x10
	return ci->memsrc;
  40ed23:	4c 8b 77 60          	mov    r14,QWORD PTR [rdi+0x60]
	int ret;
	vaddr_t heap_vaddr = 0;
	vaddr_t kmem = 0;
	struct cos_compinfo *meta = __compinfo_metacap(ci);

	assert(meta == __compinfo_metacap(meta));
  40ed27:	4d 39 76 60          	cmp    QWORD PTR [r14+0x60],r14
  40ed2b:	0f 85 bb 00 00 00    	jne    40edec <cos_shared_kernel_page_alloc+0xdc>
  40ed31:	49 89 fc             	mov    r12,rdi
  40ed34:	49 89 f5             	mov    r13,rsi
	return __mem_bump_alloc(ci, 1, 1);
  40ed37:	e8 24 db ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40ed3c:	48 89 c3             	mov    rbx,rax

	kmem = __kmem_bump_alloc(ci);
	assert(kmem);
  40ed3f:	48 85 c0             	test   rax,rax
  40ed42:	0f 84 c0 00 00 00    	je     40ee08 <cos_shared_kernel_page_alloc+0xf8>

	heap_vaddr = __page_bump_valloc(ci, PAGE_SIZE, PAGE_SIZE);
  40ed48:	ba 00 10 00 00       	mov    edx,0x1000
  40ed4d:	be 00 10 00 00       	mov    esi,0x1000
  40ed52:	4c 89 e7             	mov    rdi,r12
  40ed55:	e8 c6 e1 ff ff       	call   40cf20 <__page_bump_valloc>
  40ed5a:	49 89 c2             	mov    r10,rax
	assert(heap_vaddr);
  40ed5d:	48 85 c0             	test   rax,rax
  40ed60:	0f 84 be 00 00 00    	je     40ee24 <cos_shared_kernel_page_alloc+0x114>
  40ed66:	49 8b 34 24          	mov    rsi,QWORD PTR [r12]
  40ed6a:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  40ed6e:	ba 0c 00 00 00       	mov    edx,0xc
  40ed73:	4c 89 d7             	mov    rdi,r10

	ret = call_cap_op(meta->mi.pgtbl_cap, CAPTBL_OP_MEMACTIVATE, kmem, ci->pgtbl_cap, heap_vaddr, PAGE_ORDER);
  40ed76:	49 8b 86 98 00 00 00 	mov    rax,QWORD PTR [r14+0x98]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40ed7d:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40ed80:	05 17 00 01 00       	add    eax,0x10017
	__asm__ __volatile__(
  40ed85:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40ed88:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40ed8c:	48 89 cd             	mov    rbp,rcx
  40ed8f:	49 b8 a8 ed 40 00 00 	movabs r8,0x40eda8
  40ed96:	00 00 00 
  40ed99:	0f 05                	syscall 
  40ed9b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40eda0:	eb 0d                	jmp    40edaf <cos_shared_kernel_page_alloc+0x9f>
  40eda2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40eda8:	b9 00 00 00 00       	mov    ecx,0x0
  40edad:	eb 05                	jmp    40edb4 <cos_shared_kernel_page_alloc+0xa4>
  40edaf:	b9 01 00 00 00       	mov    ecx,0x1
  40edb4:	5d                   	pop    rbp
  40edb5:	5c                   	pop    rsp
	if (ret) {
  40edb6:	85 c0                	test   eax,eax
  40edb8:	75 16                	jne    40edd0 <cos_shared_kernel_page_alloc+0xc0>
		BUG();
	}

	*resource = kmem;
  40edba:	49 89 5d 00          	mov    QWORD PTR [r13+0x0],rbx

	return heap_vaddr;
}
  40edbe:	48 83 c4 10          	add    rsp,0x10
  40edc2:	4c 89 d0             	mov    rax,r10
  40edc5:	5b                   	pop    rbx
  40edc6:	41 5c                	pop    r12
  40edc8:	41 5d                	pop    r13
  40edca:	41 5e                	pop    r14
  40edcc:	5d                   	pop    rbp
  40edcd:	c3                   	ret    
  40edce:	66 90                	xchg   ax,ax
  40edd0:	be 1c 00 00 00       	mov    esi,0x1c
  40edd5:	bf 28 e0 41 00       	mov    edi,0x41e028
  40edda:	e8 f1 b2 ff ff       	call   40a0d0 <cos_print_str>
		BUG();
  40eddf:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ede6:	00 00 00 00 
  40edea:	0f 0b                	ud2    
  40edec:	be 2f 00 00 00       	mov    esi,0x2f
  40edf1:	bf 98 df 41 00       	mov    edi,0x41df98
  40edf6:	e8 d5 b2 ff ff       	call   40a0d0 <cos_print_str>
	assert(meta == __compinfo_metacap(meta));
  40edfb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ee02:	00 00 00 00 
  40ee06:	0f 0b                	ud2    
  40ee08:	be 2f 00 00 00       	mov    esi,0x2f
  40ee0d:	bf c8 df 41 00       	mov    edi,0x41dfc8
  40ee12:	e8 b9 b2 ff ff       	call   40a0d0 <cos_print_str>
	assert(kmem);
  40ee17:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ee1e:	00 00 00 00 
  40ee22:	0f 0b                	ud2    
  40ee24:	be 2f 00 00 00       	mov    esi,0x2f
  40ee29:	bf f8 df 41 00       	mov    edi,0x41dff8
  40ee2e:	e8 9d b2 ff ff       	call   40a0d0 <cos_print_str>
	assert(heap_vaddr);
  40ee33:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ee3a:	00 00 00 00 
  40ee3e:	0f 0b                	ud2    

000000000040ee40 <cos_vm_kernel_page_create>:

vaddr_t
cos_vm_kernel_page_create(struct cos_compinfo *ci)
{
  40ee40:	f3 0f 1e fa          	endbr64 
  40ee44:	55                   	push   rbp
  40ee45:	48 89 e5             	mov    rbp,rsp
  40ee48:	41 55                	push   r13
  40ee4a:	41 54                	push   r12
  40ee4c:	53                   	push   rbx
  40ee4d:	48 83 ec 18          	sub    rsp,0x18
	assert(__ci);
  40ee51:	48 85 ff             	test   rdi,rdi
  40ee54:	0f 84 6f 01 00 00    	je     40efc9 <cos_vm_kernel_page_create+0x189>
	return ci->memsrc;
  40ee5a:	4c 8b 57 60          	mov    r10,QWORD PTR [rdi+0x60]
        __asm__ __volatile__("lock " PS_CAS_STR
  40ee5e:	be 01 00 00 00       	mov    esi,0x1
  40ee63:	31 c9                	xor    ecx,ecx
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40ee65:	49 8d 92 b8 00 00 00 	lea    rdx,[r10+0xb8]
	assert(ci && ci == __compinfo_metacap(__ci));
  40ee6c:	4d 85 d2             	test   r10,r10
  40ee6f:	0f 84 70 01 00 00    	je     40efe5 <cos_vm_kernel_page_create+0x1a5>
  40ee75:	0f 1f 00             	nop    DWORD PTR [rax]
        __asm__ __volatile__("lock " PS_CAS_STR
  40ee78:	48 89 c8             	mov    rax,rcx
  40ee7b:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40ee80:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40ee83:	84 c0                	test   al,al
  40ee85:	74 f1                	je     40ee78 <cos_vm_kernel_page_create+0x38>
        __asm__ __volatile__("lock " PS_FAA_STR
  40ee87:	41 bd 00 10 00 00    	mov    r13d,0x1000
  40ee8d:	f0 4d 0f c1 6a 78    	lock xadd QWORD PTR [r10+0x78],r13
	if (ret >= *frontier || *frontier - ret > RETYPE_MEM_SIZE) {
  40ee93:	49 8b 92 90 00 00 00 	mov    rdx,QWORD PTR [r10+0x90]
  40ee9a:	49 39 d5             	cmp    r13,rdx
  40ee9d:	0f 82 bd 00 00 00    	jb     40ef60 <cos_vm_kernel_page_create+0x120>
		vaddr_t ptr_tmp = *ptr, front_tmp = *frontier;
  40eea3:	49 8b 42 78          	mov    rax,QWORD PTR [r10+0x78]
		if (ci->mi.untyped_ptr == ci->mi.untyped_frontier) goto error;
  40eea7:	49 8b 9a 80 00 00 00 	mov    rbx,QWORD PTR [r10+0x80]
  40eeae:	49 39 5a 68          	cmp    QWORD PTR [r10+0x68],rbx
  40eeb2:	0f 84 c8 00 00 00    	je     40ef80 <cos_vm_kernel_page_create+0x140>
  40eeb8:	41 bd 00 10 00 00    	mov    r13d,0x1000
  40eebe:	f0 4d 0f c1 6a 68    	lock xadd QWORD PTR [r10+0x68],r13
		if (ps_cas(ptr, ptr_tmp, ret + PAGE_SIZE)) {
  40eec4:	49 8d 8d 00 10 00 00 	lea    rcx,[r13+0x1000]
        __asm__ __volatile__("lock " PS_CAS_STR
  40eecb:	f0 49 0f b1 4a 78    	lock cmpxchg QWORD PTR [r10+0x78],rcx
  40eed1:	0f 94 c0             	sete   al
  40eed4:	84 c0                	test   al,al
  40eed6:	74 0f                	je     40eee7 <cos_vm_kernel_page_create+0xa7>
  40eed8:	48 89 d0             	mov    rax,rdx
  40eedb:	f0 49 0f b1 8a 90 00 	lock cmpxchg QWORD PTR [r10+0x90],rcx
  40eee2:	00 00 
  40eee4:	0f 94 c0             	sete   al
	if (retype && (ret % RETYPE_MEM_SIZE == 0)) {
  40eee7:	4c 89 ea             	mov    rdx,r13
  40eeea:	81 e2 ff 0f 00 00    	and    edx,0xfff
  40eef0:	0f 85 ba 00 00 00    	jne    40efb0 <cos_vm_kernel_page_create+0x170>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40eef6:	41 8b 82 98 00 00 00 	mov    eax,DWORD PTR [r10+0x98]
	__asm__ __volatile__(
  40eefd:	4c 89 eb             	mov    rbx,r13
  40ef00:	48 89 d6             	mov    rsi,rdx
  40ef03:	48 89 d7             	mov    rdi,rdx
  40ef06:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40ef0a:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40ef0d:	05 1a 00 01 00       	add    eax,0x1001a
	__asm__ __volatile__(
  40ef12:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40ef15:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40ef19:	48 89 cd             	mov    rbp,rcx
  40ef1c:	49 b8 30 ef 40 00 00 	movabs r8,0x40ef30
  40ef23:	00 00 00 
  40ef26:	0f 05                	syscall 
  40ef28:	eb 0d                	jmp    40ef37 <cos_vm_kernel_page_create+0xf7>
  40ef2a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40ef30:	b9 00 00 00 00       	mov    ecx,0x0
  40ef35:	eb 05                	jmp    40ef3c <cos_vm_kernel_page_create+0xfc>
  40ef37:	b9 01 00 00 00       	mov    ecx,0x1
  40ef3c:	5d                   	pop    rbp
  40ef3d:	5c                   	pop    rsp
		if (call_cap_op(ci->mi.pgtbl_cap, op, ret, 0, 0, 0)) goto error;
  40ef3e:	85 c0                	test   eax,eax
  40ef40:	75 3e                	jne    40ef80 <cos_vm_kernel_page_create+0x140>
{ l->o = 0; }
  40ef42:	49 c7 82 b8 00 00 00 	mov    QWORD PTR [r10+0xb8],0x0
  40ef49:	00 00 00 00 
	vaddr_t kmem = 0;

	kmem = __kmem_bump_alloc(ci);
	assert(kmem);
  40ef4d:	4d 85 ed             	test   r13,r13
  40ef50:	74 39                	je     40ef8b <cos_vm_kernel_page_create+0x14b>

	return kmem;
}
  40ef52:	48 83 c4 18          	add    rsp,0x18
  40ef56:	4c 89 e8             	mov    rax,r13
  40ef59:	5b                   	pop    rbx
  40ef5a:	41 5c                	pop    r12
  40ef5c:	41 5d                	pop    r13
  40ef5e:	5d                   	pop    rbp
  40ef5f:	c3                   	ret    
	if (ret >= *frontier || *frontier - ret > RETYPE_MEM_SIZE) {
  40ef60:	48 89 d0             	mov    rax,rdx
  40ef63:	4c 29 e8             	sub    rax,r13
  40ef66:	48 3d 00 10 00 00    	cmp    rax,0x1000
  40ef6c:	0f 86 75 ff ff ff    	jbe    40eee7 <cos_vm_kernel_page_create+0xa7>
  40ef72:	e9 2c ff ff ff       	jmp    40eea3 <cos_vm_kernel_page_create+0x63>
  40ef77:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40ef7e:	00 00 
  40ef80:	49 c7 82 b8 00 00 00 	mov    QWORD PTR [r10+0xb8],0x0
  40ef87:	00 00 00 00 
  40ef8b:	be 2f 00 00 00       	mov    esi,0x2f
  40ef90:	bf 48 e0 41 00       	mov    edi,0x41e048
  40ef95:	e8 36 b1 ff ff       	call   40a0d0 <cos_print_str>
	assert(kmem);
  40ef9a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40efa1:	00 00 00 00 
  40efa5:	0f 0b                	ud2    
  40efa7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40efae:	00 00 
  40efb0:	49 c7 82 b8 00 00 00 	mov    QWORD PTR [r10+0xb8],0x0
  40efb7:	00 00 00 00 
}
  40efbb:	48 83 c4 18          	add    rsp,0x18
  40efbf:	4c 89 e8             	mov    rax,r13
  40efc2:	5b                   	pop    rbx
  40efc3:	41 5c                	pop    r12
  40efc5:	41 5d                	pop    r13
  40efc7:	5d                   	pop    rbp
  40efc8:	c3                   	ret    
  40efc9:	be 2e 00 00 00       	mov    esi,0x2e
  40efce:	bf d0 d6 41 00       	mov    edi,0x41d6d0
  40efd3:	e8 f8 b0 ff ff       	call   40a0d0 <cos_print_str>
	assert(__ci);
  40efd8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40efdf:	00 00 00 00 
  40efe3:	0f 0b                	ud2    
  40efe5:	be 2e 00 00 00       	mov    esi,0x2e
  40efea:	bf 00 d7 41 00       	mov    edi,0x41d700
  40efef:	e8 dc b0 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci && ci == __compinfo_metacap(__ci));
  40eff4:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40effb:	00 00 00 00 
  40efff:	0f 0b                	ud2    
  40f001:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40f008:	00 00 00 00 
  40f00c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000040f010 <cos_vm_vmcs_alloc>:

capid_t
cos_vm_vmcs_alloc(struct cos_compinfo *ci, vaddr_t kmem)
{
  40f010:	f3 0f 1e fa          	endbr64 
  40f014:	55                   	push   rbp
        __asm__ __volatile__("lock " PS_CAS_STR
  40f015:	31 c9                	xor    ecx,ecx
  40f017:	48 89 e5             	mov    rbp,rsp
  40f01a:	41 55                	push   r13
  40f01c:	49 89 fd             	mov    r13,rdi
  40f01f:	41 54                	push   r12
  40f021:	53                   	push   rbx
  40f022:	48 89 f3             	mov    rbx,rsi
  40f025:	be 01 00 00 00       	mov    esi,0x1
  40f02a:	48 83 ec 18          	sub    rsp,0x18
	return ci->memsrc;
  40f02e:	4c 8b 67 60          	mov    r12,QWORD PTR [rdi+0x60]
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f032:	49 8d 94 24 b0 00 00 	lea    rdx,[r12+0xb0]
  40f039:	00 
  40f03a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  40f040:	48 89 c8             	mov    rax,rcx
  40f043:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40f048:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f04b:	84 c0                	test   al,al
  40f04d:	74 f1                	je     40f040 <cos_vm_vmcs_alloc+0x30>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40f04f:	41 f6 44 24 38 03    	test   BYTE PTR [r12+0x38],0x3
  40f055:	0f 84 a1 00 00 00    	je     40f0fc <cos_vm_vmcs_alloc+0xec>
        __asm__ __volatile__("lock " PS_FAA_STR
  40f05b:	bf 04 00 00 00       	mov    edi,0x4
  40f060:	f0 49 0f c1 7c 24 38 	lock xadd QWORD PTR [r12+0x38],rdi
{ l->o = 0; }
  40f067:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40f06e:	00 00 00 00 00 
	capid_t cap = 0;

	cap = __capid_bump_alloc(__compinfo_metacap(ci), CAP_VM_VMCS);

	if (cap == 0 || kmem == 0) {
  40f073:	48 85 ff             	test   rdi,rdi
  40f076:	0f 84 98 00 00 00    	je     40f114 <cos_vm_vmcs_alloc+0x104>
  40f07c:	48 85 db             	test   rbx,rbx
  40f07f:	0f 84 8f 00 00 00    	je     40f114 <cos_vm_vmcs_alloc+0x104>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f085:	41 8b 45 08          	mov    eax,DWORD PTR [r13+0x8]
		assert(0);
	}

	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_VMCS_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  40f089:	49 8b 55 60          	mov    rdx,QWORD PTR [r13+0x60]
	__asm__ __volatile__(
  40f08d:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f091:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40f094:	48 8b b2 98 00 00 00 	mov    rsi,QWORD PTR [rdx+0x98]
  40f09b:	31 d2                	xor    edx,edx
	cap_no += op;
  40f09d:	05 07 00 01 00       	add    eax,0x10007
	__asm__ __volatile__(
  40f0a2:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40f0a5:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40f0a9:	48 89 cd             	mov    rbp,rcx
  40f0ac:	49 b8 c0 f0 40 00 00 	movabs r8,0x40f0c0
  40f0b3:	00 00 00 
  40f0b6:	0f 05                	syscall 
  40f0b8:	eb 0d                	jmp    40f0c7 <cos_vm_vmcs_alloc+0xb7>
  40f0ba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40f0c0:	b9 00 00 00 00       	mov    ecx,0x0
  40f0c5:	eb 05                	jmp    40f0cc <cos_vm_vmcs_alloc+0xbc>
  40f0c7:	b9 01 00 00 00       	mov    ecx,0x1
  40f0cc:	5d                   	pop    rbp
  40f0cd:	5c                   	pop    rsp
  40f0ce:	85 c0                	test   eax,eax
  40f0d0:	75 0e                	jne    40f0e0 <cos_vm_vmcs_alloc+0xd0>

	return cap;
}
  40f0d2:	48 83 c4 18          	add    rsp,0x18
  40f0d6:	48 89 f8             	mov    rax,rdi
  40f0d9:	5b                   	pop    rbx
  40f0da:	41 5c                	pop    r12
  40f0dc:	41 5d                	pop    r13
  40f0de:	5d                   	pop    rbp
  40f0df:	c3                   	ret    
  40f0e0:	be 1c 00 00 00       	mov    esi,0x1c
  40f0e5:	bf a8 e0 41 00       	mov    edi,0x41e0a8
  40f0ea:	e8 e1 af ff ff       	call   40a0d0 <cos_print_str>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_VMCS_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  40f0ef:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f0f6:	00 00 00 00 
  40f0fa:	0f 0b                	ud2    
		if (__capid_captbl_check_expand(ci)) goto error;
  40f0fc:	4c 89 e7             	mov    rdi,r12
  40f0ff:	e8 dc d8 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40f104:	85 c0                	test   eax,eax
  40f106:	74 28                	je     40f130 <cos_vm_vmcs_alloc+0x120>
  40f108:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40f10f:	00 00 00 00 00 
  40f114:	be 2f 00 00 00       	mov    esi,0x2f
  40f119:	bf 78 e0 41 00       	mov    edi,0x41e078
  40f11e:	e8 ad af ff ff       	call   40a0d0 <cos_print_str>
		assert(0);
  40f123:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f12a:	00 00 00 00 
  40f12e:	0f 0b                	ud2    
        __asm__ __volatile__("lock " PS_FAA_STR
  40f130:	b8 04 00 00 00       	mov    eax,0x4
  40f135:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40f13c:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  40f141:	e9 15 ff ff ff       	jmp    40f05b <cos_vm_vmcs_alloc+0x4b>
  40f146:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40f14d:	00 00 00 

000000000040f150 <cos_vm_msr_bitmap_alloc>:

capid_t
cos_vm_msr_bitmap_alloc(struct cos_compinfo *ci, vaddr_t kmem)
{
  40f150:	f3 0f 1e fa          	endbr64 
  40f154:	55                   	push   rbp
        __asm__ __volatile__("lock " PS_CAS_STR
  40f155:	31 c9                	xor    ecx,ecx
  40f157:	48 89 e5             	mov    rbp,rsp
  40f15a:	41 55                	push   r13
  40f15c:	49 89 fd             	mov    r13,rdi
  40f15f:	41 54                	push   r12
  40f161:	53                   	push   rbx
  40f162:	48 89 f3             	mov    rbx,rsi
  40f165:	be 01 00 00 00       	mov    esi,0x1
  40f16a:	48 83 ec 18          	sub    rsp,0x18
	return ci->memsrc;
  40f16e:	4c 8b 67 60          	mov    r12,QWORD PTR [rdi+0x60]
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f172:	49 8d 94 24 b0 00 00 	lea    rdx,[r12+0xb0]
  40f179:	00 
  40f17a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  40f180:	48 89 c8             	mov    rax,rcx
  40f183:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40f188:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f18b:	84 c0                	test   al,al
  40f18d:	74 f1                	je     40f180 <cos_vm_msr_bitmap_alloc+0x30>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40f18f:	41 f6 44 24 38 03    	test   BYTE PTR [r12+0x38],0x3
  40f195:	0f 84 a1 00 00 00    	je     40f23c <cos_vm_msr_bitmap_alloc+0xec>
        __asm__ __volatile__("lock " PS_FAA_STR
  40f19b:	bf 04 00 00 00       	mov    edi,0x4
  40f1a0:	f0 49 0f c1 7c 24 38 	lock xadd QWORD PTR [r12+0x38],rdi
{ l->o = 0; }
  40f1a7:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40f1ae:	00 00 00 00 00 
	capid_t cap = 0;

	cap = __capid_bump_alloc(__compinfo_metacap(ci), CAP_VM_MSR_BITMAP);

	if (cap == 0 || kmem == 0) {
  40f1b3:	48 85 ff             	test   rdi,rdi
  40f1b6:	0f 84 98 00 00 00    	je     40f254 <cos_vm_msr_bitmap_alloc+0x104>
  40f1bc:	48 85 db             	test   rbx,rbx
  40f1bf:	0f 84 8f 00 00 00    	je     40f254 <cos_vm_msr_bitmap_alloc+0x104>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f1c5:	41 8b 45 08          	mov    eax,DWORD PTR [r13+0x8]
		assert(0);
	}

	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_MSR_BITMAP_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  40f1c9:	49 8b 55 60          	mov    rdx,QWORD PTR [r13+0x60]
	__asm__ __volatile__(
  40f1cd:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f1d1:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40f1d4:	48 8b b2 98 00 00 00 	mov    rsi,QWORD PTR [rdx+0x98]
  40f1db:	31 d2                	xor    edx,edx
	cap_no += op;
  40f1dd:	05 08 00 01 00       	add    eax,0x10008
	__asm__ __volatile__(
  40f1e2:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40f1e5:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40f1e9:	48 89 cd             	mov    rbp,rcx
  40f1ec:	49 b8 00 f2 40 00 00 	movabs r8,0x40f200
  40f1f3:	00 00 00 
  40f1f6:	0f 05                	syscall 
  40f1f8:	eb 0d                	jmp    40f207 <cos_vm_msr_bitmap_alloc+0xb7>
  40f1fa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40f200:	b9 00 00 00 00       	mov    ecx,0x0
  40f205:	eb 05                	jmp    40f20c <cos_vm_msr_bitmap_alloc+0xbc>
  40f207:	b9 01 00 00 00       	mov    ecx,0x1
  40f20c:	5d                   	pop    rbp
  40f20d:	5c                   	pop    rsp
  40f20e:	85 c0                	test   eax,eax
  40f210:	75 0e                	jne    40f220 <cos_vm_msr_bitmap_alloc+0xd0>

	return cap;
}
  40f212:	48 83 c4 18          	add    rsp,0x18
  40f216:	48 89 f8             	mov    rax,rdi
  40f219:	5b                   	pop    rbx
  40f21a:	41 5c                	pop    r12
  40f21c:	41 5d                	pop    r13
  40f21e:	5d                   	pop    rbp
  40f21f:	c3                   	ret    
  40f220:	be 1c 00 00 00       	mov    esi,0x1c
  40f225:	bf f8 e0 41 00       	mov    edi,0x41e0f8
  40f22a:	e8 a1 ae ff ff       	call   40a0d0 <cos_print_str>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_MSR_BITMAP_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  40f22f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f236:	00 00 00 00 
  40f23a:	0f 0b                	ud2    
		if (__capid_captbl_check_expand(ci)) goto error;
  40f23c:	4c 89 e7             	mov    rdi,r12
  40f23f:	e8 9c d7 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40f244:	85 c0                	test   eax,eax
  40f246:	74 28                	je     40f270 <cos_vm_msr_bitmap_alloc+0x120>
  40f248:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40f24f:	00 00 00 00 00 
  40f254:	be 2f 00 00 00       	mov    esi,0x2f
  40f259:	bf c8 e0 41 00       	mov    edi,0x41e0c8
  40f25e:	e8 6d ae ff ff       	call   40a0d0 <cos_print_str>
		assert(0);
  40f263:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f26a:	00 00 00 00 
  40f26e:	0f 0b                	ud2    
        __asm__ __volatile__("lock " PS_FAA_STR
  40f270:	b8 04 00 00 00       	mov    eax,0x4
  40f275:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40f27c:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  40f281:	e9 15 ff ff ff       	jmp    40f19b <cos_vm_msr_bitmap_alloc+0x4b>
  40f286:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40f28d:	00 00 00 

000000000040f290 <cos_vm_lapic_alloc>:

capid_t
cos_vm_lapic_alloc(struct cos_compinfo *ci, vaddr_t kmem)
{
  40f290:	f3 0f 1e fa          	endbr64 
  40f294:	55                   	push   rbp
        __asm__ __volatile__("lock " PS_CAS_STR
  40f295:	31 c9                	xor    ecx,ecx
  40f297:	48 89 e5             	mov    rbp,rsp
  40f29a:	41 55                	push   r13
  40f29c:	49 89 fd             	mov    r13,rdi
  40f29f:	41 54                	push   r12
  40f2a1:	53                   	push   rbx
  40f2a2:	48 89 f3             	mov    rbx,rsi
  40f2a5:	be 01 00 00 00       	mov    esi,0x1
  40f2aa:	48 83 ec 18          	sub    rsp,0x18
	return ci->memsrc;
  40f2ae:	4c 8b 67 60          	mov    r12,QWORD PTR [rdi+0x60]
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f2b2:	49 8d 94 24 b0 00 00 	lea    rdx,[r12+0xb0]
  40f2b9:	00 
  40f2ba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  40f2c0:	48 89 c8             	mov    rax,rcx
  40f2c3:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40f2c8:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f2cb:	84 c0                	test   al,al
  40f2cd:	74 f1                	je     40f2c0 <cos_vm_lapic_alloc+0x30>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40f2cf:	41 f6 44 24 38 03    	test   BYTE PTR [r12+0x38],0x3
  40f2d5:	0f 84 a1 00 00 00    	je     40f37c <cos_vm_lapic_alloc+0xec>
        __asm__ __volatile__("lock " PS_FAA_STR
  40f2db:	bf 04 00 00 00       	mov    edi,0x4
  40f2e0:	f0 49 0f c1 7c 24 38 	lock xadd QWORD PTR [r12+0x38],rdi
{ l->o = 0; }
  40f2e7:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40f2ee:	00 00 00 00 00 
	capid_t cap = 0;

	cap = __capid_bump_alloc(__compinfo_metacap(ci), CAP_VM_LAPIC);
	if (cap == 0 || kmem == 0) {
  40f2f3:	48 85 ff             	test   rdi,rdi
  40f2f6:	0f 84 98 00 00 00    	je     40f394 <cos_vm_lapic_alloc+0x104>
  40f2fc:	48 85 db             	test   rbx,rbx
  40f2ff:	0f 84 8f 00 00 00    	je     40f394 <cos_vm_lapic_alloc+0x104>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f305:	41 8b 45 08          	mov    eax,DWORD PTR [r13+0x8]
		assert(0);
	}

	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_LAPIC_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  40f309:	49 8b 55 60          	mov    rdx,QWORD PTR [r13+0x60]
	__asm__ __volatile__(
  40f30d:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f311:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40f314:	48 8b b2 98 00 00 00 	mov    rsi,QWORD PTR [rdx+0x98]
  40f31b:	31 d2                	xor    edx,edx
	cap_no += op;
  40f31d:	05 0a 00 01 00       	add    eax,0x1000a
	__asm__ __volatile__(
  40f322:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40f325:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40f329:	48 89 cd             	mov    rbp,rcx
  40f32c:	49 b8 40 f3 40 00 00 	movabs r8,0x40f340
  40f333:	00 00 00 
  40f336:	0f 05                	syscall 
  40f338:	eb 0d                	jmp    40f347 <cos_vm_lapic_alloc+0xb7>
  40f33a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40f340:	b9 00 00 00 00       	mov    ecx,0x0
  40f345:	eb 05                	jmp    40f34c <cos_vm_lapic_alloc+0xbc>
  40f347:	b9 01 00 00 00       	mov    ecx,0x1
  40f34c:	5d                   	pop    rbp
  40f34d:	5c                   	pop    rsp
  40f34e:	85 c0                	test   eax,eax
  40f350:	75 0e                	jne    40f360 <cos_vm_lapic_alloc+0xd0>

	return cap;

}
  40f352:	48 83 c4 18          	add    rsp,0x18
  40f356:	48 89 f8             	mov    rax,rdi
  40f359:	5b                   	pop    rbx
  40f35a:	41 5c                	pop    r12
  40f35c:	41 5d                	pop    r13
  40f35e:	5d                   	pop    rbp
  40f35f:	c3                   	ret    
  40f360:	be 1c 00 00 00       	mov    esi,0x1c
  40f365:	bf 48 e1 41 00       	mov    edi,0x41e148
  40f36a:	e8 61 ad ff ff       	call   40a0d0 <cos_print_str>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_LAPIC_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  40f36f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f376:	00 00 00 00 
  40f37a:	0f 0b                	ud2    
		if (__capid_captbl_check_expand(ci)) goto error;
  40f37c:	4c 89 e7             	mov    rdi,r12
  40f37f:	e8 5c d6 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40f384:	85 c0                	test   eax,eax
  40f386:	74 28                	je     40f3b0 <cos_vm_lapic_alloc+0x120>
  40f388:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40f38f:	00 00 00 00 00 
  40f394:	be 2f 00 00 00       	mov    esi,0x2f
  40f399:	bf 18 e1 41 00       	mov    edi,0x41e118
  40f39e:	e8 2d ad ff ff       	call   40a0d0 <cos_print_str>
		assert(0);
  40f3a3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f3aa:	00 00 00 00 
  40f3ae:	0f 0b                	ud2    
        __asm__ __volatile__("lock " PS_FAA_STR
  40f3b0:	b8 04 00 00 00       	mov    eax,0x4
  40f3b5:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40f3bc:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  40f3c1:	e9 15 ff ff ff       	jmp    40f2db <cos_vm_lapic_alloc+0x4b>
  40f3c6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40f3cd:	00 00 00 

000000000040f3d0 <cos_vm_shared_region_alloc>:

capid_t
cos_vm_shared_region_alloc(struct cos_compinfo *ci, vaddr_t kmem)
{
  40f3d0:	f3 0f 1e fa          	endbr64 
  40f3d4:	55                   	push   rbp
        __asm__ __volatile__("lock " PS_CAS_STR
  40f3d5:	31 c9                	xor    ecx,ecx
  40f3d7:	48 89 e5             	mov    rbp,rsp
  40f3da:	41 55                	push   r13
  40f3dc:	49 89 fd             	mov    r13,rdi
  40f3df:	41 54                	push   r12
  40f3e1:	53                   	push   rbx
  40f3e2:	48 89 f3             	mov    rbx,rsi
  40f3e5:	be 01 00 00 00       	mov    esi,0x1
  40f3ea:	48 83 ec 18          	sub    rsp,0x18
	return ci->memsrc;
  40f3ee:	4c 8b 67 60          	mov    r12,QWORD PTR [rdi+0x60]
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f3f2:	49 8d 94 24 b0 00 00 	lea    rdx,[r12+0xb0]
  40f3f9:	00 
  40f3fa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  40f400:	48 89 c8             	mov    rax,rcx
  40f403:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40f408:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f40b:	84 c0                	test   al,al
  40f40d:	74 f1                	je     40f400 <cos_vm_shared_region_alloc+0x30>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40f40f:	41 f6 44 24 38 03    	test   BYTE PTR [r12+0x38],0x3
  40f415:	0f 84 a1 00 00 00    	je     40f4bc <cos_vm_shared_region_alloc+0xec>
        __asm__ __volatile__("lock " PS_FAA_STR
  40f41b:	bf 04 00 00 00       	mov    edi,0x4
  40f420:	f0 49 0f c1 7c 24 38 	lock xadd QWORD PTR [r12+0x38],rdi
{ l->o = 0; }
  40f427:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40f42e:	00 00 00 00 00 
	capid_t cap = 0;

	cap = __capid_bump_alloc(__compinfo_metacap(ci), CAP_VM_SHARED_MEM);
	if (cap == 0 || kmem == 0) {
  40f433:	48 85 ff             	test   rdi,rdi
  40f436:	0f 84 98 00 00 00    	je     40f4d4 <cos_vm_shared_region_alloc+0x104>
  40f43c:	48 85 db             	test   rbx,rbx
  40f43f:	0f 84 8f 00 00 00    	je     40f4d4 <cos_vm_shared_region_alloc+0x104>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f445:	41 8b 45 08          	mov    eax,DWORD PTR [r13+0x8]
		assert(0);
	}

	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_SHARED_MEM_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  40f449:	49 8b 55 60          	mov    rdx,QWORD PTR [r13+0x60]
	__asm__ __volatile__(
  40f44d:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f451:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40f454:	48 8b b2 98 00 00 00 	mov    rsi,QWORD PTR [rdx+0x98]
  40f45b:	31 d2                	xor    edx,edx
	cap_no += op;
  40f45d:	05 0b 00 01 00       	add    eax,0x1000b
	__asm__ __volatile__(
  40f462:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40f465:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40f469:	48 89 cd             	mov    rbp,rcx
  40f46c:	49 b8 80 f4 40 00 00 	movabs r8,0x40f480
  40f473:	00 00 00 
  40f476:	0f 05                	syscall 
  40f478:	eb 0d                	jmp    40f487 <cos_vm_shared_region_alloc+0xb7>
  40f47a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40f480:	b9 00 00 00 00       	mov    ecx,0x0
  40f485:	eb 05                	jmp    40f48c <cos_vm_shared_region_alloc+0xbc>
  40f487:	b9 01 00 00 00       	mov    ecx,0x1
  40f48c:	5d                   	pop    rbp
  40f48d:	5c                   	pop    rsp
  40f48e:	85 c0                	test   eax,eax
  40f490:	75 0e                	jne    40f4a0 <cos_vm_shared_region_alloc+0xd0>

	return cap;

}
  40f492:	48 83 c4 18          	add    rsp,0x18
  40f496:	48 89 f8             	mov    rax,rdi
  40f499:	5b                   	pop    rbx
  40f49a:	41 5c                	pop    r12
  40f49c:	41 5d                	pop    r13
  40f49e:	5d                   	pop    rbp
  40f49f:	c3                   	ret    
  40f4a0:	be 1c 00 00 00       	mov    esi,0x1c
  40f4a5:	bf 98 e1 41 00       	mov    edi,0x41e198
  40f4aa:	e8 21 ac ff ff       	call   40a0d0 <cos_print_str>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_SHARED_MEM_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  40f4af:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f4b6:	00 00 00 00 
  40f4ba:	0f 0b                	ud2    
		if (__capid_captbl_check_expand(ci)) goto error;
  40f4bc:	4c 89 e7             	mov    rdi,r12
  40f4bf:	e8 1c d5 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40f4c4:	85 c0                	test   eax,eax
  40f4c6:	74 28                	je     40f4f0 <cos_vm_shared_region_alloc+0x120>
  40f4c8:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40f4cf:	00 00 00 00 00 
  40f4d4:	be 2f 00 00 00       	mov    esi,0x2f
  40f4d9:	bf 68 e1 41 00       	mov    edi,0x41e168
  40f4de:	e8 ed ab ff ff       	call   40a0d0 <cos_print_str>
		assert(0);
  40f4e3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f4ea:	00 00 00 00 
  40f4ee:	0f 0b                	ud2    
        __asm__ __volatile__("lock " PS_FAA_STR
  40f4f0:	b8 04 00 00 00       	mov    eax,0x4
  40f4f5:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40f4fc:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  40f501:	e9 15 ff ff ff       	jmp    40f41b <cos_vm_shared_region_alloc+0x4b>
  40f506:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40f50d:	00 00 00 

000000000040f510 <cos_vm_lapic_access_alloc>:

capid_t
cos_vm_lapic_access_alloc(struct cos_compinfo *ci, vaddr_t kmem)
{
  40f510:	f3 0f 1e fa          	endbr64 
  40f514:	55                   	push   rbp
        __asm__ __volatile__("lock " PS_CAS_STR
  40f515:	31 c9                	xor    ecx,ecx
  40f517:	48 89 e5             	mov    rbp,rsp
  40f51a:	41 55                	push   r13
  40f51c:	49 89 fd             	mov    r13,rdi
  40f51f:	41 54                	push   r12
  40f521:	53                   	push   rbx
  40f522:	48 89 f3             	mov    rbx,rsi
  40f525:	be 01 00 00 00       	mov    esi,0x1
  40f52a:	48 83 ec 18          	sub    rsp,0x18
	return ci->memsrc;
  40f52e:	4c 8b 67 60          	mov    r12,QWORD PTR [rdi+0x60]
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f532:	49 8d 94 24 b0 00 00 	lea    rdx,[r12+0xb0]
  40f539:	00 
  40f53a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  40f540:	48 89 c8             	mov    rax,rcx
  40f543:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40f548:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f54b:	84 c0                	test   al,al
  40f54d:	74 f1                	je     40f540 <cos_vm_lapic_access_alloc+0x30>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40f54f:	41 f6 44 24 38 03    	test   BYTE PTR [r12+0x38],0x3
  40f555:	0f 84 a1 00 00 00    	je     40f5fc <cos_vm_lapic_access_alloc+0xec>
        __asm__ __volatile__("lock " PS_FAA_STR
  40f55b:	bf 04 00 00 00       	mov    edi,0x4
  40f560:	f0 49 0f c1 7c 24 38 	lock xadd QWORD PTR [r12+0x38],rdi
{ l->o = 0; }
  40f567:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40f56e:	00 00 00 00 00 
	capid_t cap = 0;

	cap = __capid_bump_alloc(__compinfo_metacap(ci), CAP_VM_LAPIC_ACCESS);
	if (cap == 0 || kmem == 0) {
  40f573:	48 85 ff             	test   rdi,rdi
  40f576:	0f 84 98 00 00 00    	je     40f614 <cos_vm_lapic_access_alloc+0x104>
  40f57c:	48 85 db             	test   rbx,rbx
  40f57f:	0f 84 8f 00 00 00    	je     40f614 <cos_vm_lapic_access_alloc+0x104>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f585:	41 8b 45 08          	mov    eax,DWORD PTR [r13+0x8]
		assert(0);
	}

	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_LAPIC_ACCESS_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  40f589:	49 8b 55 60          	mov    rdx,QWORD PTR [r13+0x60]
	__asm__ __volatile__(
  40f58d:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f591:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40f594:	48 8b b2 98 00 00 00 	mov    rsi,QWORD PTR [rdx+0x98]
  40f59b:	31 d2                	xor    edx,edx
	cap_no += op;
  40f59d:	05 09 00 01 00       	add    eax,0x10009
	__asm__ __volatile__(
  40f5a2:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40f5a5:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40f5a9:	48 89 cd             	mov    rbp,rcx
  40f5ac:	49 b8 c0 f5 40 00 00 	movabs r8,0x40f5c0
  40f5b3:	00 00 00 
  40f5b6:	0f 05                	syscall 
  40f5b8:	eb 0d                	jmp    40f5c7 <cos_vm_lapic_access_alloc+0xb7>
  40f5ba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40f5c0:	b9 00 00 00 00       	mov    ecx,0x0
  40f5c5:	eb 05                	jmp    40f5cc <cos_vm_lapic_access_alloc+0xbc>
  40f5c7:	b9 01 00 00 00       	mov    ecx,0x1
  40f5cc:	5d                   	pop    rbp
  40f5cd:	5c                   	pop    rsp
  40f5ce:	85 c0                	test   eax,eax
  40f5d0:	75 0e                	jne    40f5e0 <cos_vm_lapic_access_alloc+0xd0>

	return cap;

}
  40f5d2:	48 83 c4 18          	add    rsp,0x18
  40f5d6:	48 89 f8             	mov    rax,rdi
  40f5d9:	5b                   	pop    rbx
  40f5da:	41 5c                	pop    r12
  40f5dc:	41 5d                	pop    r13
  40f5de:	5d                   	pop    rbp
  40f5df:	c3                   	ret    
  40f5e0:	be 1c 00 00 00       	mov    esi,0x1c
  40f5e5:	bf e8 e1 41 00       	mov    edi,0x41e1e8
  40f5ea:	e8 e1 aa ff ff       	call   40a0d0 <cos_print_str>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_LAPIC_ACCESS_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  40f5ef:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f5f6:	00 00 00 00 
  40f5fa:	0f 0b                	ud2    
		if (__capid_captbl_check_expand(ci)) goto error;
  40f5fc:	4c 89 e7             	mov    rdi,r12
  40f5ff:	e8 dc d3 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40f604:	85 c0                	test   eax,eax
  40f606:	74 28                	je     40f630 <cos_vm_lapic_access_alloc+0x120>
  40f608:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40f60f:	00 00 00 00 00 
  40f614:	be 2f 00 00 00       	mov    esi,0x2f
  40f619:	bf b8 e1 41 00       	mov    edi,0x41e1b8
  40f61e:	e8 ad aa ff ff       	call   40a0d0 <cos_print_str>
		assert(0);
  40f623:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f62a:	00 00 00 00 
  40f62e:	0f 0b                	ud2    
        __asm__ __volatile__("lock " PS_FAA_STR
  40f630:	b8 04 00 00 00       	mov    eax,0x4
  40f635:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40f63c:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  40f641:	e9 15 ff ff ff       	jmp    40f55b <cos_vm_lapic_access_alloc+0x4b>
  40f646:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40f64d:	00 00 00 

000000000040f650 <cos_vm_vmcb_alloc>:

capid_t
cos_vm_vmcb_alloc(struct cos_compinfo *ci, vm_vmcscap_t vmcs_cap, vm_msrbitmapcap_t msr_bitmap_cap, vm_lapicaccesscap_t lapic_access_cap, vm_lapiccap_t lapic_cap, vm_shared_mem_t shared_mem_cap, thdcap_t handler_cap, word_t vpid)
{
  40f650:	f3 0f 1e fa          	endbr64 
  40f654:	55                   	push   rbp
  40f655:	48 89 e5             	mov    rbp,rsp
  40f658:	41 57                	push   r15
  40f65a:	4d 89 c7             	mov    r15,r8
  40f65d:	41 56                	push   r14
  40f65f:	49 89 ce             	mov    r14,rcx
        __asm__ __volatile__("lock " PS_CAS_STR
  40f662:	31 c9                	xor    ecx,ecx
  40f664:	41 55                	push   r13
  40f666:	49 89 f5             	mov    r13,rsi
  40f669:	41 54                	push   r12
  40f66b:	49 89 fc             	mov    r12,rdi
  40f66e:	53                   	push   rbx
  40f66f:	48 89 d3             	mov    rbx,rdx
  40f672:	48 83 ec 28          	sub    rsp,0x28
	return ci->memsrc;
  40f676:	48 8b 77 60          	mov    rsi,QWORD PTR [rdi+0x60]
  40f67a:	bf 01 00 00 00       	mov    edi,0x1
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f67f:	48 8d 96 b0 00 00 00 	lea    rdx,[rsi+0xb0]
  40f686:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40f68d:	00 00 00 
        __asm__ __volatile__("lock " PS_CAS_STR
  40f690:	48 89 c8             	mov    rax,rcx
  40f693:	f0 48 0f b1 3a       	lock cmpxchg QWORD PTR [rdx],rdi
  40f698:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f69b:	84 c0                	test   al,al
  40f69d:	74 f1                	je     40f690 <cos_vm_vmcb_alloc+0x40>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40f69f:	f6 46 38 03          	test   BYTE PTR [rsi+0x38],0x3
  40f6a3:	0f 84 ab 00 00 00    	je     40f754 <cos_vm_vmcb_alloc+0x104>
        __asm__ __volatile__("lock " PS_FAA_STR
  40f6a9:	41 ba 04 00 00 00    	mov    r10d,0x4
  40f6af:	f0 4c 0f c1 56 38    	lock xadd QWORD PTR [rsi+0x38],r10
{ l->o = 0; }
  40f6b5:	48 c7 86 b0 00 00 00 	mov    QWORD PTR [rsi+0xb0],0x0
  40f6bc:	00 00 00 00 
	capid_t cap = 0;
	word_t arg1 = 0;
	word_t arg2 = 0;

	cap = __capid_bump_alloc(__compinfo_metacap(ci), CAP_VM_VMCB);
	if (cap == 0) {
  40f6c0:	4d 85 d2             	test   r10,r10
  40f6c3:	0f 84 e2 00 00 00    	je     40f7ab <cos_vm_vmcb_alloc+0x15b>
		assert(0);
	}

	arg1 = cap | vmcs_cap << (16 * 1) | msr_bitmap_cap << (16 * 2) |  lapic_access_cap << (16 * 3);
	arg2 = lapic_cap | shared_mem_cap << (16 * 1) | handler_cap << (16 * 2) | vpid << (16 * 3);
  40f6c9:	48 8b 75 10          	mov    rsi,QWORD PTR [rbp+0x10]
  40f6cd:	48 8b 55 18          	mov    rdx,QWORD PTR [rbp+0x18]
	arg1 = cap | vmcs_cap << (16 * 1) | msr_bitmap_cap << (16 * 2) |  lapic_access_cap << (16 * 3);
  40f6d1:	48 c1 e3 20          	shl    rbx,0x20
  40f6d5:	49 c1 e6 30          	shl    r14,0x30

	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_VMCB_ACTIVATE, arg1, arg2, 0, 0)) BUG();
  40f6d9:	49 8b 44 24 08       	mov    rax,QWORD PTR [r12+0x8]
	arg1 = cap | vmcs_cap << (16 * 1) | msr_bitmap_cap << (16 * 2) |  lapic_access_cap << (16 * 3);
  40f6de:	4c 09 f3             	or     rbx,r14
  40f6e1:	49 c1 e5 10          	shl    r13,0x10
  40f6e5:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
	arg2 = lapic_cap | shared_mem_cap << (16 * 1) | handler_cap << (16 * 2) | vpid << (16 * 3);
  40f6e9:	48 c1 e6 20          	shl    rsi,0x20
  40f6ed:	48 c1 e2 30          	shl    rdx,0x30
	arg1 = cap | vmcs_cap << (16 * 1) | msr_bitmap_cap << (16 * 2) |  lapic_access_cap << (16 * 3);
  40f6f1:	4c 09 eb             	or     rbx,r13
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f6f4:	c1 e0 10             	shl    eax,0x10
	arg2 = lapic_cap | shared_mem_cap << (16 * 1) | handler_cap << (16 * 2) | vpid << (16 * 3);
  40f6f7:	4c 09 fe             	or     rsi,r15
  40f6fa:	49 c1 e1 10          	shl    r9,0x10
	arg1 = cap | vmcs_cap << (16 * 1) | msr_bitmap_cap << (16 * 2) |  lapic_access_cap << (16 * 3);
  40f6fe:	4c 09 d3             	or     rbx,r10
	arg2 = lapic_cap | shared_mem_cap << (16 * 1) | handler_cap << (16 * 2) | vpid << (16 * 3);
  40f701:	48 09 d6             	or     rsi,rdx
	__asm__ __volatile__(
  40f704:	31 d2                	xor    edx,edx
	cap_no += op;
  40f706:	05 0c 00 01 00       	add    eax,0x1000c
  40f70b:	4c 09 ce             	or     rsi,r9
	__asm__ __volatile__(
  40f70e:	48 89 d7             	mov    rdi,rdx
  40f711:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40f714:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40f718:	48 89 cd             	mov    rbp,rcx
  40f71b:	49 b8 30 f7 40 00 00 	movabs r8,0x40f730
  40f722:	00 00 00 
  40f725:	0f 05                	syscall 
  40f727:	90                   	nop
  40f728:	eb 0d                	jmp    40f737 <cos_vm_vmcb_alloc+0xe7>
  40f72a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40f730:	b9 00 00 00 00       	mov    ecx,0x0
  40f735:	eb 05                	jmp    40f73c <cos_vm_vmcb_alloc+0xec>
  40f737:	b9 01 00 00 00       	mov    ecx,0x1
  40f73c:	5d                   	pop    rbp
  40f73d:	5c                   	pop    rsp
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_VMCB_ACTIVATE, arg1, arg2, 0, 0)) BUG();
  40f73e:	85 c0                	test   eax,eax
  40f740:	75 42                	jne    40f784 <cos_vm_vmcb_alloc+0x134>

	return cap;

}
  40f742:	48 83 c4 28          	add    rsp,0x28
  40f746:	4c 89 d0             	mov    rax,r10
  40f749:	5b                   	pop    rbx
  40f74a:	41 5c                	pop    r12
  40f74c:	41 5d                	pop    r13
  40f74e:	41 5e                	pop    r14
  40f750:	41 5f                	pop    r15
  40f752:	5d                   	pop    rbp
  40f753:	c3                   	ret    
		if (__capid_captbl_check_expand(ci)) goto error;
  40f754:	48 89 f7             	mov    rdi,rsi
  40f757:	4c 89 4d b0          	mov    QWORD PTR [rbp-0x50],r9
  40f75b:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
  40f75f:	e8 7c d2 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40f764:	48 8b 75 b8          	mov    rsi,QWORD PTR [rbp-0x48]
  40f768:	4c 8b 4d b0          	mov    r9,QWORD PTR [rbp-0x50]
  40f76c:	85 c0                	test   eax,eax
  40f76e:	75 30                	jne    40f7a0 <cos_vm_vmcb_alloc+0x150>
        __asm__ __volatile__("lock " PS_FAA_STR
  40f770:	b8 04 00 00 00       	mov    eax,0x4
  40f775:	f0 48 0f c1 46 18    	lock xadd QWORD PTR [rsi+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40f77b:	48 89 46 38          	mov    QWORD PTR [rsi+0x38],rax
  40f77f:	e9 25 ff ff ff       	jmp    40f6a9 <cos_vm_vmcb_alloc+0x59>
  40f784:	be 1c 00 00 00       	mov    esi,0x1c
  40f789:	bf 38 e2 41 00       	mov    edi,0x41e238
  40f78e:	e8 3d a9 ff ff       	call   40a0d0 <cos_print_str>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_VMCB_ACTIVATE, arg1, arg2, 0, 0)) BUG();
  40f793:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f79a:	00 00 00 00 
  40f79e:	0f 0b                	ud2    
{ l->o = 0; }
  40f7a0:	48 c7 86 b0 00 00 00 	mov    QWORD PTR [rsi+0xb0],0x0
  40f7a7:	00 00 00 00 
  40f7ab:	be 2f 00 00 00       	mov    esi,0x2f
  40f7b0:	bf 08 e2 41 00       	mov    edi,0x41e208
  40f7b5:	e8 16 a9 ff ff       	call   40a0d0 <cos_print_str>
		assert(0);
  40f7ba:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f7c1:	00 00 00 00 
  40f7c5:	0f 0b                	ud2    
  40f7c7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40f7ce:	00 00 

000000000040f7d0 <cos_initthd_alloc>:

thdcap_t
cos_initthd_alloc(struct cos_compinfo *ci, compcap_t comp)
{
  40f7d0:	f3 0f 1e fa          	endbr64 
  40f7d4:	55                   	push   rbp
  40f7d5:	48 89 e5             	mov    rbp,rsp
  40f7d8:	41 57                	push   r15
  40f7da:	41 56                	push   r14
  40f7dc:	41 55                	push   r13
        __asm__ __volatile__("lock " PS_FAA_STR
  40f7de:	41 bd 01 00 00 00    	mov    r13d,0x1
  40f7e4:	41 54                	push   r12
  40f7e6:	53                   	push   rbx
  40f7e7:	48 83 ec 28          	sub    rsp,0x28
  40f7eb:	f0 4c 0f c1 2d 8c c8 	lock xadd QWORD PTR [rip+0x4c88c],r13        # 45c080 <__thdid_alloc>
  40f7f2:	04 00 
	assert(ci && comp > 0);
  40f7f4:	48 85 ff             	test   rdi,rdi
  40f7f7:	0f 84 b7 01 00 00    	je     40f9b4 <cos_initthd_alloc+0x1e4>
  40f7fd:	49 89 f4             	mov    r12,rsi
  40f800:	48 85 f6             	test   rsi,rsi
  40f803:	0f 84 ab 01 00 00    	je     40f9b4 <cos_initthd_alloc+0x1e4>
	if (!__cos_ulk_info.toplvl) return 0;
  40f809:	4c 8b 1d 70 12 19 00 	mov    r11,QWORD PTR [rip+0x191270]        # 5a0a80 <__cos_ulk_info>
  40f810:	49 89 fe             	mov    r14,rdi
  40f813:	4d 85 db             	test   r11,r11
  40f816:	74 46                	je     40f85e <cos_initthd_alloc+0x8e>
	if (!__cos_ulk_info.curr_pg || tid % ULK_STACKS_PER_PAGE == 0) {
  40f818:	48 8b 05 71 12 19 00 	mov    rax,QWORD PTR [rip+0x191271]        # 5a0a90 <__cos_ulk_info+0x10>
  40f81f:	48 85 c0             	test   rax,rax
  40f822:	74 0a                	je     40f82e <cos_initthd_alloc+0x5e>
  40f824:	41 f6 c5 0f          	test   r13b,0xf
  40f828:	0f 85 52 01 00 00    	jne    40f980 <cos_initthd_alloc+0x1b0>
		__cos_ulk_info.curr_pg = cos_ulk_page_alloc(ci, __cos_ulk_info.toplvl, __cos_ulk_info.pg_frontier);
  40f82e:	48 8b 15 63 12 19 00 	mov    rdx,QWORD PTR [rip+0x191263]        # 5a0a98 <__cos_ulk_info+0x18>
  40f835:	4c 89 de             	mov    rsi,r11
  40f838:	4c 89 f7             	mov    rdi,r14
  40f83b:	e8 f0 ed ff ff       	call   40e630 <cos_ulk_page_alloc>
  40f840:	48 89 05 49 12 19 00 	mov    QWORD PTR [rip+0x191249],rax        # 5a0a90 <__cos_ulk_info+0x10>
  40f847:	49 89 c3             	mov    r11,rax
		assert(__cos_ulk_info.curr_pg);
  40f84a:	48 85 c0             	test   rax,rax
  40f84d:	0f 84 7d 01 00 00    	je     40f9d0 <cos_initthd_alloc+0x200>
		__cos_ulk_info.pg_frontier += PAGE_SIZE;
  40f853:	48 81 05 3a 12 19 00 	add    QWORD PTR [rip+0x19123a],0x1000        # 5a0a98 <__cos_ulk_info+0x18>
  40f85a:	00 10 00 00 
	return __mem_bump_alloc(ci, 1, 1);
  40f85e:	4c 89 f7             	mov    rdi,r14
  40f861:	4c 89 5d b8          	mov    QWORD PTR [rbp-0x48],r11
  40f865:	e8 f6 cf ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40f86a:	49 89 c2             	mov    r10,rax
	if (!*kmem) return -1;
  40f86d:	48 85 c0             	test   rax,rax
  40f870:	0f 84 76 01 00 00    	je     40f9ec <cos_initthd_alloc+0x21c>
        __asm__ __volatile__("lock " PS_CAS_STR
  40f876:	4c 8b 5d b8          	mov    r11,QWORD PTR [rbp-0x48]
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f87a:	49 8d 8e b0 00 00 00 	lea    rcx,[r14+0xb0]
        __asm__ __volatile__("lock " PS_CAS_STR
  40f881:	41 b9 01 00 00 00    	mov    r9d,0x1
  40f887:	45 31 c0             	xor    r8d,r8d
  40f88a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40f890:	4c 89 c0             	mov    rax,r8
  40f893:	f0 4c 0f b1 09       	lock cmpxchg QWORD PTR [rcx],r9
  40f898:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f89b:	84 c0                	test   al,al
  40f89d:	74 f1                	je     40f890 <cos_initthd_alloc+0xc0>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40f89f:	4d 8b 7e 28          	mov    r15,QWORD PTR [r14+0x28]
  40f8a3:	41 83 e7 03          	and    r15d,0x3
  40f8a7:	0f 84 9b 00 00 00    	je     40f948 <cos_initthd_alloc+0x178>
        __asm__ __volatile__("lock " PS_FAA_STR
  40f8ad:	bb 01 00 00 00       	mov    ebx,0x1
  40f8b2:	f0 49 0f c1 5e 28    	lock xadd QWORD PTR [r14+0x28],rbx
{ l->o = 0; }
  40f8b8:	49 c7 86 b0 00 00 00 	mov    QWORD PTR [r14+0xb0],0x0
  40f8bf:	00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  40f8c3:	49 89 df             	mov    r15,rbx
	if (!*cap) return -1;
  40f8c6:	48 85 db             	test   rbx,rbx
  40f8c9:	0f 84 1d 01 00 00    	je     40f9ec <cos_initthd_alloc+0x21c>
			  __compinfo_metacap(ci)->mi.pgtbl_cap << 16 | comp, kmem, ulkcap << 16 | tid);
  40f8cf:	49 8b 56 60          	mov    rdx,QWORD PTR [r14+0x60]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f8d3:	41 8b 46 08          	mov    eax,DWORD PTR [r14+0x8]
	__asm__ __volatile__(
  40f8d7:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  40f8db:	4c 89 d7             	mov    rdi,r10
  40f8de:	48 8b b2 98 00 00 00 	mov    rsi,QWORD PTR [rdx+0x98]
  40f8e5:	4c 89 da             	mov    rdx,r11
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f8e8:	c1 e0 10             	shl    eax,0x10
  40f8eb:	48 c1 e2 10          	shl    rdx,0x10
	cap_no += op;
  40f8ef:	05 04 00 01 00       	add    eax,0x10004
  40f8f4:	48 c1 e6 10          	shl    rsi,0x10
	ret = call_cap_op(ci->captbl_cap, CAPTBL_OP_THDACTIVATE, (init_data << 16) | cap,
  40f8f8:	4c 09 ea             	or     rdx,r13
  40f8fb:	4c 09 e6             	or     rsi,r12
	__asm__ __volatile__(
  40f8fe:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40f901:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40f905:	48 89 cd             	mov    rbp,rcx
  40f908:	49 b8 20 f9 40 00 00 	movabs r8,0x40f920
  40f90f:	00 00 00 
  40f912:	0f 05                	syscall 
  40f914:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  40f918:	eb 0d                	jmp    40f927 <cos_initthd_alloc+0x157>
  40f91a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40f920:	b9 00 00 00 00       	mov    ecx,0x0
  40f925:	eb 05                	jmp    40f92c <cos_initthd_alloc+0x15c>
  40f927:	b9 01 00 00 00       	mov    ecx,0x1
  40f92c:	5d                   	pop    rbp
  40f92d:	5c                   	pop    rsp
	if (ret) BUG();
  40f92e:	85 c0                	test   eax,eax
  40f930:	75 66                	jne    40f998 <cos_initthd_alloc+0x1c8>
	thdid_t tid = cos_thd_id_alloc();

	return __cos_thd_alloc(ci, comp, 0, tid);
}
  40f932:	48 83 c4 28          	add    rsp,0x28
  40f936:	4c 89 f8             	mov    rax,r15
  40f939:	5b                   	pop    rbx
  40f93a:	41 5c                	pop    r12
  40f93c:	41 5d                	pop    r13
  40f93e:	41 5e                	pop    r14
  40f940:	41 5f                	pop    r15
  40f942:	5d                   	pop    rbp
  40f943:	c3                   	ret    
  40f944:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  40f948:	4c 89 f7             	mov    rdi,r14
  40f94b:	4c 89 5d b0          	mov    QWORD PTR [rbp-0x50],r11
  40f94f:	4c 89 55 b8          	mov    QWORD PTR [rbp-0x48],r10
  40f953:	e8 88 d0 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40f958:	4c 8b 55 b8          	mov    r10,QWORD PTR [rbp-0x48]
  40f95c:	4c 8b 5d b0          	mov    r11,QWORD PTR [rbp-0x50]
  40f960:	85 c0                	test   eax,eax
  40f962:	75 24                	jne    40f988 <cos_initthd_alloc+0x1b8>
        __asm__ __volatile__("lock " PS_FAA_STR
  40f964:	b8 04 00 00 00       	mov    eax,0x4
  40f969:	f0 49 0f c1 46 18    	lock xadd QWORD PTR [r14+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40f96f:	49 89 46 28          	mov    QWORD PTR [r14+0x28],rax
  40f973:	e9 35 ff ff ff       	jmp    40f8ad <cos_initthd_alloc+0xdd>
  40f978:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40f97f:	00 
  40f980:	49 89 c3             	mov    r11,rax
	return __cos_ulk_info.curr_pg;
  40f983:	e9 d6 fe ff ff       	jmp    40f85e <cos_initthd_alloc+0x8e>
{ l->o = 0; }
  40f988:	49 c7 86 b0 00 00 00 	mov    QWORD PTR [r14+0xb0],0x0
  40f98f:	00 00 00 00 
	if (!*cap) return -1;
  40f993:	eb 9d                	jmp    40f932 <cos_initthd_alloc+0x162>
  40f995:	0f 1f 00             	nop    DWORD PTR [rax]
  40f998:	be 1b 00 00 00       	mov    esi,0x1b
  40f99d:	bf 5f de 41 00       	mov    edi,0x41de5f
  40f9a2:	e8 29 a7 ff ff       	call   40a0d0 <cos_print_str>
	if (ret) BUG();
  40f9a7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f9ae:	00 00 00 00 
  40f9b2:	0f 0b                	ud2    
  40f9b4:	be 2e 00 00 00       	mov    esi,0x2e
  40f9b9:	bf d0 dd 41 00       	mov    edi,0x41ddd0
  40f9be:	e8 0d a7 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci && comp > 0);
  40f9c3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f9ca:	00 00 00 00 
  40f9ce:	0f 0b                	ud2    
  40f9d0:	be 2e 00 00 00       	mov    esi,0x2e
  40f9d5:	bf 00 de 41 00       	mov    edi,0x41de00
  40f9da:	e8 f1 a6 ff ff       	call   40a0d0 <cos_print_str>
		assert(__cos_ulk_info.curr_pg);
  40f9df:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f9e6:	00 00 00 00 
  40f9ea:	0f 0b                	ud2    
	if (__alloc_mem_cap(ci, CAP_THD, &kmem, &cap)) return 0;
  40f9ec:	45 31 ff             	xor    r15d,r15d
	return __cos_thd_alloc(ci, comp, 0, tid);
  40f9ef:	e9 3e ff ff ff       	jmp    40f932 <cos_initthd_alloc+0x162>
  40f9f4:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40f9fb:	00 00 00 00 
  40f9ff:	90                   	nop

000000000040fa00 <cos_captbl_alloc>:

captblcap_t
cos_captbl_alloc(struct cos_compinfo *ci)
{
  40fa00:	f3 0f 1e fa          	endbr64 
  40fa04:	55                   	push   rbp
  40fa05:	48 89 e5             	mov    rbp,rsp
  40fa08:	41 56                	push   r14
  40fa0a:	41 55                	push   r13
  40fa0c:	41 54                	push   r12
  40fa0e:	53                   	push   rbx
  40fa0f:	48 83 ec 10          	sub    rsp,0x10
	vaddr_t kmem;
	capid_t cap;

	printd("cos_captbl_alloc\n");

	assert(ci);
  40fa13:	48 85 ff             	test   rdi,rdi
  40fa16:	0f 84 20 01 00 00    	je     40fb3c <cos_captbl_alloc+0x13c>
  40fa1c:	49 89 fc             	mov    r12,rdi
	return __mem_bump_alloc(ci, 1, 1);
  40fa1f:	e8 3c ce ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40fa24:	49 89 c5             	mov    r13,rax
	if (!*kmem) return -1;
  40fa27:	48 85 c0             	test   rax,rax
  40fa2a:	0f 84 28 01 00 00    	je     40fb58 <cos_captbl_alloc+0x158>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40fa30:	49 8d 94 24 b0 00 00 	lea    rdx,[r12+0xb0]
  40fa37:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  40fa38:	be 01 00 00 00       	mov    esi,0x1
  40fa3d:	31 c9                	xor    ecx,ecx
  40fa3f:	90                   	nop
  40fa40:	48 89 c8             	mov    rax,rcx
  40fa43:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40fa48:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40fa4b:	84 c0                	test   al,al
  40fa4d:	74 f1                	je     40fa40 <cos_captbl_alloc+0x40>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40fa4f:	4d 8b 74 24 38       	mov    r14,QWORD PTR [r12+0x38]
  40fa54:	41 83 e6 03          	and    r14d,0x3
  40fa58:	0f 84 92 00 00 00    	je     40faf0 <cos_captbl_alloc+0xf0>
        __asm__ __volatile__("lock " PS_FAA_STR
  40fa5e:	bb 04 00 00 00       	mov    ebx,0x4
  40fa63:	f0 49 0f c1 5c 24 38 	lock xadd QWORD PTR [r12+0x38],rbx
{ l->o = 0; }
  40fa6a:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40fa71:	00 00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  40fa76:	49 89 de             	mov    r14,rbx
	if (!*cap) return -1;
  40fa79:	48 85 db             	test   rbx,rbx
  40fa7c:	0f 84 d6 00 00 00    	je     40fb58 <cos_captbl_alloc+0x158>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40fa82:	41 8b 44 24 08       	mov    eax,DWORD PTR [r12+0x8]

	if (__alloc_mem_cap(ci, CAP_CAPTBL, &kmem, &cap)) return 0;
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_CAPTBLACTIVATE, cap, __compinfo_metacap(ci)->mi.pgtbl_cap, kmem, 0))
  40fa87:	49 8b 54 24 60       	mov    rdx,QWORD PTR [r12+0x60]
	__asm__ __volatile__(
  40fa8c:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  40fa90:	4c 89 ef             	mov    rdi,r13
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40fa93:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40fa96:	48 8b b2 98 00 00 00 	mov    rsi,QWORD PTR [rdx+0x98]
  40fa9d:	31 d2                	xor    edx,edx
	cap_no += op;
  40fa9f:	05 1e 00 01 00       	add    eax,0x1001e
	__asm__ __volatile__(
  40faa4:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40faa7:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40faab:	48 89 cd             	mov    rbp,rcx
  40faae:	49 b8 c8 fa 40 00 00 	movabs r8,0x40fac8
  40fab5:	00 00 00 
  40fab8:	0f 05                	syscall 
  40faba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40fac0:	eb 0d                	jmp    40facf <cos_captbl_alloc+0xcf>
  40fac2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40fac8:	b9 00 00 00 00       	mov    ecx,0x0
  40facd:	eb 05                	jmp    40fad4 <cos_captbl_alloc+0xd4>
  40facf:	b9 01 00 00 00       	mov    ecx,0x1
  40fad4:	5d                   	pop    rbp
  40fad5:	5c                   	pop    rsp
  40fad6:	85 c0                	test   eax,eax
  40fad8:	75 46                	jne    40fb20 <cos_captbl_alloc+0x120>
		BUG();

	return cap;
}
  40fada:	48 83 c4 10          	add    rsp,0x10
  40fade:	4c 89 f0             	mov    rax,r14
  40fae1:	5b                   	pop    rbx
  40fae2:	41 5c                	pop    r12
  40fae4:	41 5d                	pop    r13
  40fae6:	41 5e                	pop    r14
  40fae8:	5d                   	pop    rbp
  40fae9:	c3                   	ret    
  40faea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  40faf0:	4c 89 e7             	mov    rdi,r12
  40faf3:	e8 e8 ce ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40faf8:	85 c0                	test   eax,eax
  40fafa:	75 16                	jne    40fb12 <cos_captbl_alloc+0x112>
        __asm__ __volatile__("lock " PS_FAA_STR
  40fafc:	b8 04 00 00 00       	mov    eax,0x4
  40fb01:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40fb08:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  40fb0d:	e9 4c ff ff ff       	jmp    40fa5e <cos_captbl_alloc+0x5e>
{ l->o = 0; }
  40fb12:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40fb19:	00 00 00 00 00 
	if (!*cap) return -1;
  40fb1e:	eb ba                	jmp    40fada <cos_captbl_alloc+0xda>
  40fb20:	be 1c 00 00 00       	mov    esi,0x1c
  40fb25:	bf 88 e2 41 00       	mov    edi,0x41e288
  40fb2a:	e8 a1 a5 ff ff       	call   40a0d0 <cos_print_str>
		BUG();
  40fb2f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40fb36:	00 00 00 00 
  40fb3a:	0f 0b                	ud2    
  40fb3c:	be 2f 00 00 00       	mov    esi,0x2f
  40fb41:	bf 58 e2 41 00       	mov    edi,0x41e258
  40fb46:	e8 85 a5 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci);
  40fb4b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40fb52:	00 00 00 00 
  40fb56:	0f 0b                	ud2    
	if (__alloc_mem_cap(ci, CAP_CAPTBL, &kmem, &cap)) return 0;
  40fb58:	45 31 f6             	xor    r14d,r14d
  40fb5b:	e9 7a ff ff ff       	jmp    40fada <cos_captbl_alloc+0xda>

000000000040fb60 <cos_pgtbl_alloc>:

pgtblcap_t
cos_pgtbl_alloc(struct cos_compinfo *ci, u8_t type)
{
  40fb60:	f3 0f 1e fa          	endbr64 
  40fb64:	55                   	push   rbp
  40fb65:	48 89 e5             	mov    rbp,rsp
  40fb68:	41 57                	push   r15
  40fb6a:	41 56                	push   r14
  40fb6c:	41 55                	push   r13
  40fb6e:	41 54                	push   r12
  40fb70:	53                   	push   rbx
  40fb71:	48 83 ec 18          	sub    rsp,0x18
	capid_t cap;
	word_t lvl = 0;

	printd("cos_pgtbl_alloc\n");

	assert(ci);
  40fb75:	48 85 ff             	test   rdi,rdi
  40fb78:	0f 84 26 01 00 00    	je     40fca4 <cos_pgtbl_alloc+0x144>
  40fb7e:	49 89 fe             	mov    r14,rdi
  40fb81:	41 89 f4             	mov    r12d,esi
	return __mem_bump_alloc(ci, 1, 1);
  40fb84:	e8 d7 cc ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40fb89:	49 89 c5             	mov    r13,rax
	if (!*kmem) return -1;
  40fb8c:	48 85 c0             	test   rax,rax
  40fb8f:	0f 84 2b 01 00 00    	je     40fcc0 <cos_pgtbl_alloc+0x160>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40fb95:	49 8d 96 b0 00 00 00 	lea    rdx,[r14+0xb0]
        __asm__ __volatile__("lock " PS_CAS_STR
  40fb9c:	be 01 00 00 00       	mov    esi,0x1
  40fba1:	31 c9                	xor    ecx,ecx
  40fba3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40fba8:	48 89 c8             	mov    rax,rcx
  40fbab:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40fbb0:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40fbb3:	84 c0                	test   al,al
  40fbb5:	74 f1                	je     40fba8 <cos_pgtbl_alloc+0x48>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40fbb7:	4d 8b 7e 38          	mov    r15,QWORD PTR [r14+0x38]
  40fbbb:	41 83 e7 03          	and    r15d,0x3
  40fbbf:	0f 84 93 00 00 00    	je     40fc58 <cos_pgtbl_alloc+0xf8>
        __asm__ __volatile__("lock " PS_FAA_STR
  40fbc5:	bb 04 00 00 00       	mov    ebx,0x4
  40fbca:	f0 49 0f c1 5e 38    	lock xadd QWORD PTR [r14+0x38],rbx
{ l->o = 0; }
  40fbd0:	49 c7 86 b0 00 00 00 	mov    QWORD PTR [r14+0xb0],0x0
  40fbd7:	00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  40fbdb:	49 89 df             	mov    r15,rbx
	if (!*cap) return -1;
  40fbde:	48 85 db             	test   rbx,rbx
  40fbe1:	0f 84 d9 00 00 00    	je     40fcc0 <cos_pgtbl_alloc+0x160>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40fbe7:	41 8b 46 08          	mov    eax,DWORD PTR [r14+0x8]

	if (__alloc_mem_cap(ci, CAP_PGTBL, &kmem, &cap)) return 0;

	if (unlikely(type)) lvl |= PGTBL_LVL_FLAG_VM;
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_PGTBLACTIVATE, cap, __compinfo_metacap(ci)->mi.pgtbl_cap, kmem, lvl))
  40fbeb:	49 8b 56 60          	mov    rdx,QWORD PTR [r14+0x60]
	__asm__ __volatile__(
  40fbef:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  40fbf3:	4c 89 ef             	mov    rdi,r13
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40fbf6:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40fbf9:	48 8b b2 98 00 00 00 	mov    rsi,QWORD PTR [rdx+0x98]
	if (unlikely(type)) lvl |= PGTBL_LVL_FLAG_VM;
  40fc00:	31 d2                	xor    edx,edx
	cap_no += op;
  40fc02:	05 1c 00 01 00       	add    eax,0x1001c
  40fc07:	45 84 e4             	test   r12b,r12b
  40fc0a:	0f 95 c2             	setne  dl
  40fc0d:	48 c1 e2 1f          	shl    rdx,0x1f
	__asm__ __volatile__(
  40fc11:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40fc14:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40fc18:	48 89 cd             	mov    rbp,rcx
  40fc1b:	49 b8 30 fc 40 00 00 	movabs r8,0x40fc30
  40fc22:	00 00 00 
  40fc25:	0f 05                	syscall 
  40fc27:	90                   	nop
  40fc28:	eb 0d                	jmp    40fc37 <cos_pgtbl_alloc+0xd7>
  40fc2a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40fc30:	b9 00 00 00 00       	mov    ecx,0x0
  40fc35:	eb 05                	jmp    40fc3c <cos_pgtbl_alloc+0xdc>
  40fc37:	b9 01 00 00 00       	mov    ecx,0x1
  40fc3c:	5d                   	pop    rbp
  40fc3d:	5c                   	pop    rsp
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_PGTBLACTIVATE, cap, __compinfo_metacap(ci)->mi.pgtbl_cap, kmem, lvl))
  40fc3e:	85 c0                	test   eax,eax
  40fc40:	75 46                	jne    40fc88 <cos_pgtbl_alloc+0x128>
		BUG();

	return cap;
}
  40fc42:	48 83 c4 18          	add    rsp,0x18
  40fc46:	4c 89 f8             	mov    rax,r15
  40fc49:	5b                   	pop    rbx
  40fc4a:	41 5c                	pop    r12
  40fc4c:	41 5d                	pop    r13
  40fc4e:	41 5e                	pop    r14
  40fc50:	41 5f                	pop    r15
  40fc52:	5d                   	pop    rbp
  40fc53:	c3                   	ret    
  40fc54:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  40fc58:	4c 89 f7             	mov    rdi,r14
  40fc5b:	e8 80 cd ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40fc60:	85 c0                	test   eax,eax
  40fc62:	75 14                	jne    40fc78 <cos_pgtbl_alloc+0x118>
        __asm__ __volatile__("lock " PS_FAA_STR
  40fc64:	b8 04 00 00 00       	mov    eax,0x4
  40fc69:	f0 49 0f c1 46 18    	lock xadd QWORD PTR [r14+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40fc6f:	49 89 46 38          	mov    QWORD PTR [r14+0x38],rax
  40fc73:	e9 4d ff ff ff       	jmp    40fbc5 <cos_pgtbl_alloc+0x65>
{ l->o = 0; }
  40fc78:	49 c7 86 b0 00 00 00 	mov    QWORD PTR [r14+0xb0],0x0
  40fc7f:	00 00 00 00 
	if (!*cap) return -1;
  40fc83:	eb bd                	jmp    40fc42 <cos_pgtbl_alloc+0xe2>
  40fc85:	0f 1f 00             	nop    DWORD PTR [rax]
  40fc88:	be 1c 00 00 00       	mov    esi,0x1c
  40fc8d:	bf d8 e2 41 00       	mov    edi,0x41e2d8
  40fc92:	e8 39 a4 ff ff       	call   40a0d0 <cos_print_str>
		BUG();
  40fc97:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40fc9e:	00 00 00 00 
  40fca2:	0f 0b                	ud2    
  40fca4:	be 2f 00 00 00       	mov    esi,0x2f
  40fca9:	bf a8 e2 41 00       	mov    edi,0x41e2a8
  40fcae:	e8 1d a4 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci);
  40fcb3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40fcba:	00 00 00 00 
  40fcbe:	0f 0b                	ud2    
	if (__alloc_mem_cap(ci, CAP_PGTBL, &kmem, &cap)) return 0;
  40fcc0:	45 31 ff             	xor    r15d,r15d
  40fcc3:	e9 7a ff ff ff       	jmp    40fc42 <cos_pgtbl_alloc+0xe2>
  40fcc8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40fccf:	00 

000000000040fcd0 <cos_ulk_pgtbl_create>:
{
  40fcd0:	f3 0f 1e fa          	endbr64 
  40fcd4:	55                   	push   rbp
  40fcd5:	48 89 e5             	mov    rbp,rsp
  40fcd8:	41 57                	push   r15
  40fcda:	41 56                	push   r14
  40fcdc:	41 55                	push   r13
  40fcde:	41 54                	push   r12
  40fce0:	53                   	push   rbx
  40fce1:	48 83 ec 58          	sub    rsp,0x58
	assert(ci && secondlvl);
  40fce5:	48 85 ff             	test   rdi,rdi
  40fce8:	0f 84 22 02 00 00    	je     40ff10 <cos_ulk_pgtbl_create+0x240>
  40fcee:	49 89 f7             	mov    r15,rsi
  40fcf1:	48 85 f6             	test   rsi,rsi
  40fcf4:	0f 84 16 02 00 00    	je     40ff10 <cos_ulk_pgtbl_create+0x240>
  40fcfa:	49 89 fd             	mov    r13,rdi
	toplvl = cos_pgtbl_alloc(__compinfo_metacap(ci), PGTBL_TYPE_DEF);
  40fcfd:	48 8b 7f 60          	mov    rdi,QWORD PTR [rdi+0x60]
  40fd01:	31 f6                	xor    esi,esi
  40fd03:	e8 58 fe ff ff       	call   40fb60 <cos_pgtbl_alloc>
	*secondlvl = __bump_mem_expand_intern(__compinfo_metacap(ci), toplvl, ULK_BASE_ADDR, 0, 0);
  40fd08:	49 8b 7d 60          	mov    rdi,QWORD PTR [r13+0x60]
  40fd0c:	45 31 c0             	xor    r8d,r8d
  40fd0f:	31 c9                	xor    ecx,ecx
  40fd11:	48 ba 00 00 00 00 80 	movabs rdx,0x7f8000000000
  40fd18:	7f 00 00 
  40fd1b:	48 89 c6             	mov    rsi,rax
	toplvl = cos_pgtbl_alloc(__compinfo_metacap(ci), PGTBL_TYPE_DEF);
  40fd1e:	49 89 c6             	mov    r14,rax
	*secondlvl = __bump_mem_expand_intern(__compinfo_metacap(ci), toplvl, ULK_BASE_ADDR, 0, 0);
  40fd21:	e8 7a d6 ff ff       	call   40d3a0 <__bump_mem_expand_intern>
  40fd26:	49 89 07             	mov    QWORD PTR [r15],rax
	if (!*secondlvl) return 0;
  40fd29:	48 85 c0             	test   rax,rax
  40fd2c:	75 1a                	jne    40fd48 <cos_ulk_pgtbl_create+0x78>
  40fd2e:	45 31 f6             	xor    r14d,r14d
}
  40fd31:	48 83 c4 58          	add    rsp,0x58
  40fd35:	4c 89 f0             	mov    rax,r14
  40fd38:	5b                   	pop    rbx
  40fd39:	41 5c                	pop    r12
  40fd3b:	41 5d                	pop    r13
  40fd3d:	41 5e                	pop    r14
  40fd3f:	41 5f                	pop    r15
  40fd41:	5d                   	pop    rbp
  40fd42:	c3                   	ret    
  40fd43:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		if (__bump_mem_expand_intern(meta, cipgtbl, addr, 0, pgtbl_lvl) == 0) return 0;
  40fd48:	49 8b 7d 60          	mov    rdi,QWORD PTR [r13+0x60]
  40fd4c:	45 31 c0             	xor    r8d,r8d
  40fd4f:	31 c9                	xor    ecx,ecx
  40fd51:	4c 89 f6             	mov    rsi,r14
  40fd54:	48 ba 00 10 00 00 80 	movabs rdx,0x7f8000001000
  40fd5b:	7f 00 00 
  40fd5e:	e8 3d d6 ff ff       	call   40d3a0 <__bump_mem_expand_intern>
  40fd63:	48 85 c0             	test   rax,rax
  40fd66:	74 c6                	je     40fd2e <cos_ulk_pgtbl_create+0x5e>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40fd68:	44 89 f0             	mov    eax,r14d
	cap_no += op;
  40fd6b:	48 c7 45 b8 01 00 00 	mov    QWORD PTR [rbp-0x48],0x1
  40fd72:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  40fd73:	41 ba 01 00 00 00    	mov    r10d,0x1
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40fd79:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40fd7c:	05 01 00 01 00       	add    eax,0x10001
  40fd81:	89 45 b4             	mov    DWORD PTR [rbp-0x4c],eax
	return ci->memsrc;
  40fd84:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  40fd88:	4d 8b 7d 60          	mov    r15,QWORD PTR [r13+0x60]
	for (addr = mem_ptr; addr < tmp_frontier; addr += range) {
  40fd8c:	4c 89 75 90          	mov    QWORD PTR [rbp-0x70],r14
  40fd90:	4c 89 6d 88          	mov    QWORD PTR [rbp-0x78],r13
  40fd94:	48 8b 1c c5 70 ea 41 	mov    rbx,QWORD PTR [rax*8+0x41ea70]
  40fd9b:	00 
		return round_up_to_pgt2_page(vaddr);
  40fd9c:	48 83 f8 02          	cmp    rax,0x2
  40fda0:	48 b8 00 00 20 00 80 	movabs rax,0x7f8000200000
  40fda7:	7f 00 00 
  40fdaa:	48 89 5d 98          	mov    QWORD PTR [rbp-0x68],rbx
  40fdae:	48 bb 00 00 00 40 80 	movabs rbx,0x7f8040000000
  40fdb5:	7f 00 00 
  40fdb8:	48 0f 45 c3          	cmovne rax,rbx
  40fdbc:	48 89 45 a0          	mov    QWORD PTR [rbp-0x60],rax
	for (addr = mem_ptr; addr < tmp_frontier; addr += range) {
  40fdc0:	48 b8 00 00 00 00 80 	movabs rax,0x7f8000000000
  40fdc7:	7f 00 00 
  40fdca:	48 89 45 a8          	mov    QWORD PTR [rbp-0x58],rax
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  40fdce:	4d 3b 7f 60          	cmp    r15,QWORD PTR [r15+0x60]
  40fdd2:	0f 85 bf 01 00 00    	jne    40ff97 <cos_ulk_pgtbl_create+0x2c7>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40fdd8:	49 8d 97 b0 00 00 00 	lea    rdx,[r15+0xb0]
        __asm__ __volatile__("lock " PS_CAS_STR
  40fddf:	31 c9                	xor    ecx,ecx
  40fde1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  40fde8:	48 89 c8             	mov    rax,rcx
  40fdeb:	f0 4c 0f b1 12       	lock cmpxchg QWORD PTR [rdx],r10
  40fdf0:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40fdf3:	84 c0                	test   al,al
  40fdf5:	74 f1                	je     40fde8 <cos_ulk_pgtbl_create+0x118>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40fdf7:	41 f6 47 38 03       	test   BYTE PTR [r15+0x38],0x3
  40fdfc:	0f 84 2a 01 00 00    	je     40ff2c <cos_ulk_pgtbl_create+0x25c>
        __asm__ __volatile__("lock " PS_FAA_STR
  40fe02:	bb 04 00 00 00       	mov    ebx,0x4
  40fe07:	f0 49 0f c1 5f 38    	lock xadd QWORD PTR [r15+0x38],rbx
{ l->o = 0; }
  40fe0d:	49 c7 87 b0 00 00 00 	mov    QWORD PTR [r15+0xb0],0x0
  40fe14:	00 00 00 00 
	return __mem_bump_alloc(ci, 1, 1);
  40fe18:	4c 89 ff             	mov    rdi,r15
  40fe1b:	e8 40 ca ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40fe20:	48 89 c7             	mov    rdi,rax
		if (pte_cap == 0 || ptemem_cap == 0) {
  40fe23:	48 85 db             	test   rbx,rbx
  40fe26:	0f 84 1f 01 00 00    	je     40ff4b <cos_ulk_pgtbl_create+0x27b>
  40fe2c:	48 85 c0             	test   rax,rax
  40fe2f:	41 ba 01 00 00 00    	mov    r10d,0x1
  40fe35:	0f 84 10 01 00 00    	je     40ff4b <cos_ulk_pgtbl_create+0x27b>
		if (call_cap_op(meta->captbl_cap, CAPTBL_OP_PGTBLACTIVATE, pte_cap, meta->mi.pgtbl_cap, ptemem_cap,
  40fe3b:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
	__asm__ __volatile__(
  40fe3f:	4c 8d 75 c0          	lea    r14,[rbp-0x40]
  40fe43:	49 8b b7 98 00 00 00 	mov    rsi,QWORD PTR [r15+0x98]
  40fe4a:	4c 89 f1             	mov    rcx,r14
  40fe4d:	4c 8d 68 01          	lea    r13,[rax+0x1]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40fe51:	41 8b 47 08          	mov    eax,DWORD PTR [r15+0x8]
	__asm__ __volatile__(
  40fe55:	4c 89 ea             	mov    rdx,r13
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40fe58:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40fe5b:	05 1c 00 01 00       	add    eax,0x1001c
	__asm__ __volatile__(
  40fe60:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40fe63:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40fe67:	48 89 cd             	mov    rbp,rcx
  40fe6a:	49 b8 80 fe 40 00 00 	movabs r8,0x40fe80
  40fe71:	00 00 00 
  40fe74:	0f 05                	syscall 
  40fe76:	66 90                	xchg   ax,ax
  40fe78:	eb 0d                	jmp    40fe87 <cos_ulk_pgtbl_create+0x1b7>
  40fe7a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40fe80:	b9 00 00 00 00       	mov    ecx,0x0
  40fe85:	eb 05                	jmp    40fe8c <cos_ulk_pgtbl_create+0x1bc>
  40fe87:	b9 01 00 00 00       	mov    ecx,0x1
  40fe8c:	5d                   	pop    rbp
  40fe8d:	5c                   	pop    rsp
  40fe8e:	85 c0                	test   eax,eax
  40fe90:	0f 85 e5 00 00 00    	jne    40ff7b <cos_ulk_pgtbl_create+0x2ab>
  40fe96:	31 d2                	xor    edx,edx
  40fe98:	8b 45 b4             	mov    eax,DWORD PTR [rbp-0x4c]
  40fe9b:	48 8b 75 a8          	mov    rsi,QWORD PTR [rbp-0x58]
  40fe9f:	4c 89 f1             	mov    rcx,r14
  40fea2:	48 89 d7             	mov    rdi,rdx
  40fea5:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40fea8:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40feac:	48 89 cd             	mov    rbp,rcx
  40feaf:	49 b8 c8 fe 40 00 00 	movabs r8,0x40fec8
  40feb6:	00 00 00 
  40feb9:	0f 05                	syscall 
  40febb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40fec0:	eb 0d                	jmp    40fecf <cos_ulk_pgtbl_create+0x1ff>
  40fec2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40fec8:	b9 00 00 00 00       	mov    ecx,0x0
  40fecd:	eb 05                	jmp    40fed4 <cos_ulk_pgtbl_create+0x204>
  40fecf:	b9 01 00 00 00       	mov    ecx,0x1
  40fed4:	5d                   	pop    rbp
  40fed5:	5c                   	pop    rsp
	for (addr = mem_ptr; addr < tmp_frontier; addr += range) {
  40fed6:	48 8b 45 98          	mov    rax,QWORD PTR [rbp-0x68]
  40feda:	48 01 c6             	add    rsi,rax
  40fedd:	48 89 75 a8          	mov    QWORD PTR [rbp-0x58],rsi
  40fee1:	48 39 75 a0          	cmp    QWORD PTR [rbp-0x60],rsi
  40fee5:	0f 87 e3 fe ff ff    	ja     40fdce <cos_ulk_pgtbl_create+0xfe>
  40feeb:	4c 89 ea             	mov    rdx,r13
  40feee:	48 c7 45 b8 02 00 00 	mov    QWORD PTR [rbp-0x48],0x2
  40fef5:	00 
  40fef6:	4c 8b 75 90          	mov    r14,QWORD PTR [rbp-0x70]
  40fefa:	4c 8b 6d 88          	mov    r13,QWORD PTR [rbp-0x78]
	for (pgtbl_lvl = 1; pgtbl_lvl < COS_PGTBL_DEPTH - 1; pgtbl_lvl++) {
  40fefe:	48 83 fa 03          	cmp    rdx,0x3
  40ff02:	0f 84 29 fe ff ff    	je     40fd31 <cos_ulk_pgtbl_create+0x61>
  40ff08:	e9 77 fe ff ff       	jmp    40fd84 <cos_ulk_pgtbl_create+0xb4>
  40ff0d:	0f 1f 00             	nop    DWORD PTR [rax]
  40ff10:	be 2e 00 00 00       	mov    esi,0x2e
  40ff15:	bf f8 e2 41 00       	mov    edi,0x41e2f8
  40ff1a:	e8 b1 a1 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci && secondlvl);
  40ff1f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ff26:	00 00 00 00 
  40ff2a:	0f 0b                	ud2    
		if (__capid_captbl_check_expand(ci)) goto error;
  40ff2c:	4c 89 ff             	mov    rdi,r15
  40ff2f:	e8 ac ca ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  40ff34:	85 c0                	test   eax,eax
  40ff36:	74 2f                	je     40ff67 <cos_ulk_pgtbl_create+0x297>
  40ff38:	49 c7 87 b0 00 00 00 	mov    QWORD PTR [r15+0xb0],0x0
  40ff3f:	00 00 00 00 
	return __mem_bump_alloc(ci, 1, 1);
  40ff43:	4c 89 ff             	mov    rdi,r15
  40ff46:	e8 15 c9 ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  40ff4b:	be 2e 00 00 00       	mov    esi,0x2e
  40ff50:	bf e0 d8 41 00       	mov    edi,0x41d8e0
  40ff55:	e8 76 a1 ff ff       	call   40a0d0 <cos_print_str>
			assert(0);
  40ff5a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ff61:	00 00 00 00 
  40ff65:	0f 0b                	ud2    
        __asm__ __volatile__("lock " PS_FAA_STR
  40ff67:	b8 04 00 00 00       	mov    eax,0x4
  40ff6c:	f0 49 0f c1 47 18    	lock xadd QWORD PTR [r15+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40ff72:	49 89 47 38          	mov    QWORD PTR [r15+0x38],rax
  40ff76:	e9 87 fe ff ff       	jmp    40fe02 <cos_ulk_pgtbl_create+0x132>
  40ff7b:	be 2e 00 00 00       	mov    esi,0x2e
  40ff80:	bf 10 d9 41 00       	mov    edi,0x41d910
  40ff85:	e8 46 a1 ff ff       	call   40a0d0 <cos_print_str>
				assert(0); /* race? */
  40ff8a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ff91:	00 00 00 00 
  40ff95:	0f 0b                	ud2    
  40ff97:	be 2e 00 00 00       	mov    esi,0x2e
  40ff9c:	bf b0 d8 41 00       	mov    edi,0x41d8b0
  40ffa1:	e8 2a a1 ff ff       	call   40a0d0 <cos_print_str>
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  40ffa6:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ffad:	00 00 00 00 
  40ffb1:	0f 0b                	ud2    
  40ffb3:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40ffba:	00 00 00 00 
  40ffbe:	66 90                	xchg   ax,ax

000000000040ffc0 <cos_ulk_info_init>:
{
  40ffc0:	f3 0f 1e fa          	endbr64 
  40ffc4:	55                   	push   rbp
  40ffc5:	48 89 e5             	mov    rbp,rsp
  40ffc8:	41 57                	push   r15
  40ffca:	41 56                	push   r14
  40ffcc:	41 55                	push   r13
  40ffce:	41 54                	push   r12
  40ffd0:	53                   	push   rbx
  40ffd1:	48 83 ec 58          	sub    rsp,0x58
	assert(ci && secondlvl);
  40ffd5:	48 85 ff             	test   rdi,rdi
  40ffd8:	0f 84 7d 02 00 00    	je     41025b <cos_ulk_info_init+0x29b>
  40ffde:	49 89 fd             	mov    r13,rdi
	toplvl = cos_pgtbl_alloc(__compinfo_metacap(ci), PGTBL_TYPE_DEF);
  40ffe1:	48 8b 7f 60          	mov    rdi,QWORD PTR [rdi+0x60]
  40ffe5:	31 f6                	xor    esi,esi
  40ffe7:	e8 74 fb ff ff       	call   40fb60 <cos_pgtbl_alloc>
	*secondlvl = __bump_mem_expand_intern(__compinfo_metacap(ci), toplvl, ULK_BASE_ADDR, 0, 0);
  40ffec:	49 8b 7d 60          	mov    rdi,QWORD PTR [r13+0x60]
  40fff0:	45 31 c0             	xor    r8d,r8d
  40fff3:	31 c9                	xor    ecx,ecx
  40fff5:	48 ba 00 00 00 00 80 	movabs rdx,0x7f8000000000
  40fffc:	7f 00 00 
  40ffff:	48 89 c6             	mov    rsi,rax
	toplvl = cos_pgtbl_alloc(__compinfo_metacap(ci), PGTBL_TYPE_DEF);
  410002:	49 89 c7             	mov    r15,rax
	*secondlvl = __bump_mem_expand_intern(__compinfo_metacap(ci), toplvl, ULK_BASE_ADDR, 0, 0);
  410005:	e8 96 d3 ff ff       	call   40d3a0 <__bump_mem_expand_intern>
  41000a:	48 89 05 77 0a 19 00 	mov    QWORD PTR [rip+0x190a77],rax        # 5a0a88 <__cos_ulk_info+0x8>
	if (!*secondlvl) return 0;
  410011:	48 85 c0             	test   rax,rax
  410014:	75 4a                	jne    410060 <cos_ulk_info_init+0xa0>
	__cos_ulk_info.pg_frontier = ULK_BASE_ADDR + __thdid_alloc * sizeof(struct ulk_invstk);
  410016:	48 b8 00 00 00 80 7f 	movabs rax,0x7f80000000
  41001d:	00 00 00 
  410020:	48 03 05 59 c0 04 00 	add    rax,QWORD PTR [rip+0x4c059]        # 45c080 <__thdid_alloc>
	__cos_ulk_info.toplvl = cos_ulk_pgtbl_create(ci, &__cos_ulk_info.secondlvl);
  410027:	48 c7 05 4e 0a 19 00 	mov    QWORD PTR [rip+0x190a4e],0x0        # 5a0a80 <__cos_ulk_info>
  41002e:	00 00 00 00 
	__cos_ulk_info.pg_frontier = ULK_BASE_ADDR + __thdid_alloc * sizeof(struct ulk_invstk);
  410032:	48 c1 e0 08          	shl    rax,0x8
  410036:	48 89 05 5b 0a 19 00 	mov    QWORD PTR [rip+0x190a5b],rax        # 5a0a98 <__cos_ulk_info+0x18>
  41003d:	be 2e 00 00 00       	mov    esi,0x2e
  410042:	bf 28 e3 41 00       	mov    edi,0x41e328
  410047:	e8 84 a0 ff ff       	call   40a0d0 <cos_print_str>
	assert(__cos_ulk_info.toplvl);
  41004c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410053:	00 00 00 00 
  410057:	0f 0b                	ud2    
  410059:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		if (__bump_mem_expand_intern(meta, cipgtbl, addr, 0, pgtbl_lvl) == 0) return 0;
  410060:	49 8b 7d 60          	mov    rdi,QWORD PTR [r13+0x60]
  410064:	45 31 c0             	xor    r8d,r8d
  410067:	31 c9                	xor    ecx,ecx
  410069:	4c 89 fe             	mov    rsi,r15
  41006c:	48 ba 00 10 00 00 80 	movabs rdx,0x7f8000001000
  410073:	7f 00 00 
  410076:	e8 25 d3 ff ff       	call   40d3a0 <__bump_mem_expand_intern>
  41007b:	48 85 c0             	test   rax,rax
  41007e:	74 96                	je     410016 <cos_ulk_info_init+0x56>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  410080:	44 89 f8             	mov    eax,r15d
	cap_no += op;
  410083:	48 c7 45 b8 01 00 00 	mov    QWORD PTR [rbp-0x48],0x1
  41008a:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  41008b:	41 ba 01 00 00 00    	mov    r10d,0x1
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  410091:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  410094:	05 01 00 01 00       	add    eax,0x10001
  410099:	89 45 b4             	mov    DWORD PTR [rbp-0x4c],eax
	return ci->memsrc;
  41009c:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  4100a0:	4d 8b 75 60          	mov    r14,QWORD PTR [r13+0x60]
	for (addr = mem_ptr; addr < tmp_frontier; addr += range) {
  4100a4:	4c 89 7d 90          	mov    QWORD PTR [rbp-0x70],r15
  4100a8:	4c 89 6d 88          	mov    QWORD PTR [rbp-0x78],r13
  4100ac:	48 8b 1c c5 70 ea 41 	mov    rbx,QWORD PTR [rax*8+0x41ea70]
  4100b3:	00 
		return round_up_to_pgt2_page(vaddr);
  4100b4:	48 83 f8 02          	cmp    rax,0x2
  4100b8:	48 b8 00 00 20 00 80 	movabs rax,0x7f8000200000
  4100bf:	7f 00 00 
  4100c2:	48 89 5d 98          	mov    QWORD PTR [rbp-0x68],rbx
  4100c6:	48 bb 00 00 00 40 80 	movabs rbx,0x7f8040000000
  4100cd:	7f 00 00 
  4100d0:	48 0f 45 c3          	cmovne rax,rbx
  4100d4:	48 89 45 a0          	mov    QWORD PTR [rbp-0x60],rax
	for (addr = mem_ptr; addr < tmp_frontier; addr += range) {
  4100d8:	48 b8 00 00 00 00 80 	movabs rax,0x7f8000000000
  4100df:	7f 00 00 
  4100e2:	48 89 45 a8          	mov    QWORD PTR [rbp-0x58],rax
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  4100e6:	4d 3b 76 60          	cmp    r14,QWORD PTR [r14+0x60]
  4100ea:	0f 85 f2 01 00 00    	jne    4102e2 <cos_ulk_info_init+0x322>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  4100f0:	49 8d 96 b0 00 00 00 	lea    rdx,[r14+0xb0]
        __asm__ __volatile__("lock " PS_CAS_STR
  4100f7:	31 c9                	xor    ecx,ecx
  4100f9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  410100:	48 89 c8             	mov    rax,rcx
  410103:	f0 4c 0f b1 12       	lock cmpxchg QWORD PTR [rdx],r10
  410108:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  41010b:	84 c0                	test   al,al
  41010d:	74 f1                	je     410100 <cos_ulk_info_init+0x140>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  41010f:	41 f6 46 38 03       	test   BYTE PTR [r14+0x38],0x3
  410114:	0f 84 5d 01 00 00    	je     410277 <cos_ulk_info_init+0x2b7>
        __asm__ __volatile__("lock " PS_FAA_STR
  41011a:	bb 04 00 00 00       	mov    ebx,0x4
  41011f:	f0 49 0f c1 5e 38    	lock xadd QWORD PTR [r14+0x38],rbx
{ l->o = 0; }
  410125:	49 c7 86 b0 00 00 00 	mov    QWORD PTR [r14+0xb0],0x0
  41012c:	00 00 00 00 
	return __mem_bump_alloc(ci, 1, 1);
  410130:	4c 89 f7             	mov    rdi,r14
  410133:	e8 28 c7 ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  410138:	48 89 c7             	mov    rdi,rax
		if (pte_cap == 0 || ptemem_cap == 0) {
  41013b:	48 85 db             	test   rbx,rbx
  41013e:	0f 84 52 01 00 00    	je     410296 <cos_ulk_info_init+0x2d6>
  410144:	48 85 c0             	test   rax,rax
  410147:	41 ba 01 00 00 00    	mov    r10d,0x1
  41014d:	0f 84 43 01 00 00    	je     410296 <cos_ulk_info_init+0x2d6>
		if (call_cap_op(meta->captbl_cap, CAPTBL_OP_PGTBLACTIVATE, pte_cap, meta->mi.pgtbl_cap, ptemem_cap,
  410153:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
	__asm__ __volatile__(
  410157:	4c 8d 7d c0          	lea    r15,[rbp-0x40]
  41015b:	49 8b b6 98 00 00 00 	mov    rsi,QWORD PTR [r14+0x98]
  410162:	4c 89 f9             	mov    rcx,r15
  410165:	4c 8d 68 01          	lea    r13,[rax+0x1]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  410169:	41 8b 46 08          	mov    eax,DWORD PTR [r14+0x8]
	__asm__ __volatile__(
  41016d:	4c 89 ea             	mov    rdx,r13
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  410170:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  410173:	05 1c 00 01 00       	add    eax,0x1001c
	__asm__ __volatile__(
  410178:	48 89 29             	mov    QWORD PTR [rcx],rbp
  41017b:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  41017f:	48 89 cd             	mov    rbp,rcx
  410182:	49 b8 98 01 41 00 00 	movabs r8,0x410198
  410189:	00 00 00 
  41018c:	0f 05                	syscall 
  41018e:	66 90                	xchg   ax,ax
  410190:	eb 0d                	jmp    41019f <cos_ulk_info_init+0x1df>
  410192:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410198:	b9 00 00 00 00       	mov    ecx,0x0
  41019d:	eb 05                	jmp    4101a4 <cos_ulk_info_init+0x1e4>
  41019f:	b9 01 00 00 00       	mov    ecx,0x1
  4101a4:	5d                   	pop    rbp
  4101a5:	5c                   	pop    rsp
  4101a6:	85 c0                	test   eax,eax
  4101a8:	0f 85 18 01 00 00    	jne    4102c6 <cos_ulk_info_init+0x306>
  4101ae:	31 d2                	xor    edx,edx
  4101b0:	8b 45 b4             	mov    eax,DWORD PTR [rbp-0x4c]
  4101b3:	48 8b 75 a8          	mov    rsi,QWORD PTR [rbp-0x58]
  4101b7:	4c 89 f9             	mov    rcx,r15
  4101ba:	48 89 d7             	mov    rdi,rdx
  4101bd:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4101c0:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4101c4:	48 89 cd             	mov    rbp,rcx
  4101c7:	49 b8 e0 01 41 00 00 	movabs r8,0x4101e0
  4101ce:	00 00 00 
  4101d1:	0f 05                	syscall 
  4101d3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  4101d8:	eb 0d                	jmp    4101e7 <cos_ulk_info_init+0x227>
  4101da:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4101e0:	b9 00 00 00 00       	mov    ecx,0x0
  4101e5:	eb 05                	jmp    4101ec <cos_ulk_info_init+0x22c>
  4101e7:	b9 01 00 00 00       	mov    ecx,0x1
  4101ec:	5d                   	pop    rbp
  4101ed:	5c                   	pop    rsp
	for (addr = mem_ptr; addr < tmp_frontier; addr += range) {
  4101ee:	48 8b 45 98          	mov    rax,QWORD PTR [rbp-0x68]
  4101f2:	48 01 c6             	add    rsi,rax
  4101f5:	48 89 75 a8          	mov    QWORD PTR [rbp-0x58],rsi
  4101f9:	48 39 75 a0          	cmp    QWORD PTR [rbp-0x60],rsi
  4101fd:	0f 87 e3 fe ff ff    	ja     4100e6 <cos_ulk_info_init+0x126>
  410203:	4c 89 ea             	mov    rdx,r13
  410206:	48 c7 45 b8 02 00 00 	mov    QWORD PTR [rbp-0x48],0x2
  41020d:	00 
  41020e:	4c 8b 7d 90          	mov    r15,QWORD PTR [rbp-0x70]
  410212:	4c 8b 6d 88          	mov    r13,QWORD PTR [rbp-0x78]
	for (pgtbl_lvl = 1; pgtbl_lvl < COS_PGTBL_DEPTH - 1; pgtbl_lvl++) {
  410216:	48 83 fa 03          	cmp    rdx,0x3
  41021a:	0f 85 7c fe ff ff    	jne    41009c <cos_ulk_info_init+0xdc>
	__cos_ulk_info.pg_frontier = ULK_BASE_ADDR + __thdid_alloc * sizeof(struct ulk_invstk);
  410220:	48 b8 00 00 00 80 7f 	movabs rax,0x7f80000000
  410227:	00 00 00 
  41022a:	48 03 05 4f be 04 00 	add    rax,QWORD PTR [rip+0x4be4f]        # 45c080 <__thdid_alloc>
	__cos_ulk_info.toplvl = cos_ulk_pgtbl_create(ci, &__cos_ulk_info.secondlvl);
  410231:	4c 89 3d 48 08 19 00 	mov    QWORD PTR [rip+0x190848],r15        # 5a0a80 <__cos_ulk_info>
	__cos_ulk_info.pg_frontier = ULK_BASE_ADDR + __thdid_alloc * sizeof(struct ulk_invstk);
  410238:	48 c1 e0 08          	shl    rax,0x8
  41023c:	48 89 05 55 08 19 00 	mov    QWORD PTR [rip+0x190855],rax        # 5a0a98 <__cos_ulk_info+0x18>
	assert(__cos_ulk_info.toplvl);
  410243:	4d 85 ff             	test   r15,r15
  410246:	0f 84 f1 fd ff ff    	je     41003d <cos_ulk_info_init+0x7d>
}
  41024c:	48 83 c4 58          	add    rsp,0x58
  410250:	5b                   	pop    rbx
  410251:	41 5c                	pop    r12
  410253:	41 5d                	pop    r13
  410255:	41 5e                	pop    r14
  410257:	41 5f                	pop    r15
  410259:	5d                   	pop    rbp
  41025a:	c3                   	ret    
  41025b:	be 2e 00 00 00       	mov    esi,0x2e
  410260:	bf f8 e2 41 00       	mov    edi,0x41e2f8
  410265:	e8 66 9e ff ff       	call   40a0d0 <cos_print_str>
	assert(ci && secondlvl);
  41026a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410271:	00 00 00 00 
  410275:	0f 0b                	ud2    
		if (__capid_captbl_check_expand(ci)) goto error;
  410277:	4c 89 f7             	mov    rdi,r14
  41027a:	e8 61 c7 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  41027f:	85 c0                	test   eax,eax
  410281:	74 2f                	je     4102b2 <cos_ulk_info_init+0x2f2>
  410283:	49 c7 86 b0 00 00 00 	mov    QWORD PTR [r14+0xb0],0x0
  41028a:	00 00 00 00 
	return __mem_bump_alloc(ci, 1, 1);
  41028e:	4c 89 f7             	mov    rdi,r14
  410291:	e8 ca c5 ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  410296:	be 2e 00 00 00       	mov    esi,0x2e
  41029b:	bf e0 d8 41 00       	mov    edi,0x41d8e0
  4102a0:	e8 2b 9e ff ff       	call   40a0d0 <cos_print_str>
			assert(0);
  4102a5:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4102ac:	00 00 00 00 
  4102b0:	0f 0b                	ud2    
        __asm__ __volatile__("lock " PS_FAA_STR
  4102b2:	b8 04 00 00 00       	mov    eax,0x4
  4102b7:	f0 49 0f c1 46 18    	lock xadd QWORD PTR [r14+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  4102bd:	49 89 46 38          	mov    QWORD PTR [r14+0x38],rax
  4102c1:	e9 54 fe ff ff       	jmp    41011a <cos_ulk_info_init+0x15a>
  4102c6:	be 2e 00 00 00       	mov    esi,0x2e
  4102cb:	bf 10 d9 41 00       	mov    edi,0x41d910
  4102d0:	e8 fb 9d ff ff       	call   40a0d0 <cos_print_str>
				assert(0); /* race? */
  4102d5:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4102dc:	00 00 00 00 
  4102e0:	0f 0b                	ud2    
  4102e2:	be 2e 00 00 00       	mov    esi,0x2e
  4102e7:	bf b0 d8 41 00       	mov    edi,0x41d8b0
  4102ec:	e8 df 9d ff ff       	call   40a0d0 <cos_print_str>
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  4102f1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4102f8:	00 00 00 00 
  4102fc:	0f 0b                	ud2    
  4102fe:	66 90                	xchg   ax,ax

0000000000410300 <cos_comp_alloc_with>:

int
cos_comp_alloc_with(struct cos_compinfo *ci, compcap_t comp, u32_t lid, captblcap_t ctc, pgtblcap_t ptc, vaddr_t entry, prot_domain_t protdom)
{
  410300:	f3 0f 1e fa          	endbr64 
  410304:	55                   	push   rbp
  410305:	41 89 d3             	mov    r11d,edx
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_COMPACTIVATE, comp, (ctc << 16) | ptc, ((unsigned long)lid << 32) | protdom, entry)) return 1;
  410308:	48 c1 e1 10          	shl    rcx,0x10
{
  41030c:	49 89 f2             	mov    r10,rsi
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_COMPACTIVATE, comp, (ctc << 16) | ptc, ((unsigned long)lid << 32) | protdom, entry)) return 1;
  41030f:	48 89 ce             	mov    rsi,rcx
{
  410312:	4c 89 ca             	mov    rdx,r9
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_COMPACTIVATE, comp, (ctc << 16) | ptc, ((unsigned long)lid << 32) | protdom, entry)) return 1;
  410315:	4c 09 c6             	or     rsi,r8
{
  410318:	48 89 e5             	mov    rbp,rsp
  41031b:	41 54                	push   r12
  41031d:	53                   	push   rbx
  41031e:	4c 89 d3             	mov    rbx,r10
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_COMPACTIVATE, comp, (ctc << 16) | ptc, ((unsigned long)lid << 32) | protdom, entry)) return 1;
  410321:	48 8b 47 08          	mov    rax,QWORD PTR [rdi+0x8]
  410325:	8b 4d 10             	mov    ecx,DWORD PTR [rbp+0x10]
  410328:	4c 89 df             	mov    rdi,r11
  41032b:	48 c1 e7 20          	shl    rdi,0x20
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  41032f:	c1 e0 10             	shl    eax,0x10
  410332:	48 09 cf             	or     rdi,rcx
	__asm__ __volatile__(
  410335:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
	cap_no += op;
  410339:	05 0d 00 01 00       	add    eax,0x1000d
	__asm__ __volatile__(
  41033e:	48 89 29             	mov    QWORD PTR [rcx],rbp
  410341:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  410345:	48 89 cd             	mov    rbp,rcx
  410348:	49 b8 60 03 41 00 00 	movabs r8,0x410360
  41034f:	00 00 00 
  410352:	0f 05                	syscall 
  410354:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  410358:	eb 0d                	jmp    410367 <cos_comp_alloc_with+0x67>
  41035a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410360:	b9 00 00 00 00       	mov    ecx,0x0
  410365:	eb 05                	jmp    41036c <cos_comp_alloc_with+0x6c>
  410367:	b9 01 00 00 00       	mov    ecx,0x1
  41036c:	5d                   	pop    rbp
  41036d:	5c                   	pop    rsp
  41036e:	85 c0                	test   eax,eax
  410370:	0f 95 c0             	setne  al

	return 0;
}
  410373:	5b                   	pop    rbx
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_COMPACTIVATE, comp, (ctc << 16) | ptc, ((unsigned long)lid << 32) | protdom, entry)) return 1;
  410374:	0f b6 c0             	movzx  eax,al
}
  410377:	41 5c                	pop    r12
  410379:	5d                   	pop    rbp
  41037a:	c3                   	ret    
  41037b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000410380 <cos_comp_alloc>:

compcap_t
cos_comp_alloc(struct cos_compinfo *ci, captblcap_t ctc, pgtblcap_t ptc, vaddr_t entry, prot_domain_t protdom)
{
  410380:	f3 0f 1e fa          	endbr64 
  410384:	55                   	push   rbp
  410385:	48 89 e5             	mov    rbp,rsp
  410388:	41 57                	push   r15
  41038a:	41 56                	push   r14
  41038c:	41 55                	push   r13
  41038e:	41 54                	push   r12
  410390:	53                   	push   rbx
  410391:	48 83 ec 28          	sub    rsp,0x28
	return livenessid_frontier++;
  410395:	44 8b 15 24 bd 04 00 	mov    r10d,DWORD PTR [rip+0x4bd24]        # 45c0c0 <livenessid_frontier>
  41039c:	41 8d 42 01          	lea    eax,[r10+0x1]
  4103a0:	89 05 1a bd 04 00    	mov    DWORD PTR [rip+0x4bd1a],eax        # 45c0c0 <livenessid_frontier>
	capid_t cap;
	u32_t   lid = livenessid_bump_alloc();

	printd("cos_comp_alloc\n");

	assert(ci && ctc && ptc && lid);
  4103a6:	48 85 ff             	test   rdi,rdi
  4103a9:	0f 84 59 01 00 00    	je     410508 <cos_comp_alloc+0x188>
  4103af:	49 89 f7             	mov    r15,rsi
  4103b2:	48 85 f6             	test   rsi,rsi
  4103b5:	0f 84 4d 01 00 00    	je     410508 <cos_comp_alloc+0x188>
  4103bb:	49 89 d1             	mov    r9,rdx
  4103be:	48 85 d2             	test   rdx,rdx
  4103c1:	0f 84 41 01 00 00    	je     410508 <cos_comp_alloc+0x188>
  4103c7:	45 85 d2             	test   r10d,r10d
  4103ca:	49 89 cd             	mov    r13,rcx
  4103cd:	49 89 fc             	mov    r12,rdi
        __asm__ __volatile__("lock " PS_CAS_STR
  4103d0:	be 01 00 00 00       	mov    esi,0x1
  4103d5:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  4103d8:	48 8d 97 b0 00 00 00 	lea    rdx,[rdi+0xb0]
        __asm__ __volatile__("lock " PS_CAS_STR
  4103df:	31 c9                	xor    ecx,ecx
  4103e1:	84 c0                	test   al,al
  4103e3:	0f 85 1f 01 00 00    	jne    410508 <cos_comp_alloc+0x188>
  4103e9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  4103f0:	48 89 c8             	mov    rax,rcx
  4103f3:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  4103f8:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  4103fb:	84 c0                	test   al,al
  4103fd:	74 f1                	je     4103f0 <cos_comp_alloc+0x70>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  4103ff:	4d 8b 74 24 38       	mov    r14,QWORD PTR [r12+0x38]
  410404:	41 83 e6 03          	and    r14d,0x3
  410408:	0f 84 b2 00 00 00    	je     4104c0 <cos_comp_alloc+0x140>
        __asm__ __volatile__("lock " PS_FAA_STR
  41040e:	bb 04 00 00 00       	mov    ebx,0x4
  410413:	f0 49 0f c1 5c 24 38 	lock xadd QWORD PTR [r12+0x38],rbx
{ l->o = 0; }
  41041a:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  410421:	00 00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  410426:	49 89 de             	mov    r14,rbx

	cap = __capid_bump_alloc(ci, CAP_COMP);
	if (!cap) return 0;
  410429:	48 85 db             	test   rbx,rbx
  41042c:	74 5c                	je     41048a <cos_comp_alloc+0x10a>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_COMPACTIVATE, comp, (ctc << 16) | ptc, ((unsigned long)lid << 32) | protdom, entry)) return 1;
  41042e:	49 8b 44 24 08       	mov    rax,QWORD PTR [r12+0x8]
  410433:	49 c1 e7 10          	shl    r15,0x10
  410437:	4c 89 d7             	mov    rdi,r10
  41043a:	45 89 c0             	mov    r8d,r8d
  41043d:	4c 89 fe             	mov    rsi,r15
  410440:	48 c1 e7 20          	shl    rdi,0x20
  410444:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  410448:	4c 89 ea             	mov    rdx,r13
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  41044b:	c1 e0 10             	shl    eax,0x10
  41044e:	4c 09 ce             	or     rsi,r9
  410451:	4c 09 c7             	or     rdi,r8
	cap_no += op;
  410454:	05 0d 00 01 00       	add    eax,0x1000d
	__asm__ __volatile__(
  410459:	48 89 29             	mov    QWORD PTR [rcx],rbp
  41045c:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  410460:	48 89 cd             	mov    rbp,rcx
  410463:	49 b8 78 04 41 00 00 	movabs r8,0x410478
  41046a:	00 00 00 
  41046d:	0f 05                	syscall 
  41046f:	90                   	nop
  410470:	eb 0d                	jmp    41047f <cos_comp_alloc+0xff>
  410472:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410478:	b9 00 00 00 00       	mov    ecx,0x0
  41047d:	eb 05                	jmp    410484 <cos_comp_alloc+0x104>
  41047f:	b9 01 00 00 00       	mov    ecx,0x1
  410484:	5d                   	pop    rbp
  410485:	5c                   	pop    rsp
  410486:	85 c0                	test   eax,eax
  410488:	75 16                	jne    4104a0 <cos_comp_alloc+0x120>
	if (cos_comp_alloc_with(ci, cap, lid, ctc, ptc, entry, protdom)) BUG();

	return cap;
}
  41048a:	48 83 c4 28          	add    rsp,0x28
  41048e:	4c 89 f0             	mov    rax,r14
  410491:	5b                   	pop    rbx
  410492:	41 5c                	pop    r12
  410494:	41 5d                	pop    r13
  410496:	41 5e                	pop    r14
  410498:	41 5f                	pop    r15
  41049a:	5d                   	pop    rbp
  41049b:	c3                   	ret    
  41049c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  4104a0:	be 1c 00 00 00       	mov    esi,0x1c
  4104a5:	bf 88 e3 41 00       	mov    edi,0x41e388
  4104aa:	e8 21 9c ff ff       	call   40a0d0 <cos_print_str>
	if (cos_comp_alloc_with(ci, cap, lid, ctc, ptc, entry, protdom)) BUG();
  4104af:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4104b6:	00 00 00 00 
  4104ba:	0f 0b                	ud2    
  4104bc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  4104c0:	4c 89 e7             	mov    rdi,r12
  4104c3:	44 89 45 b8          	mov    DWORD PTR [rbp-0x48],r8d
  4104c7:	4c 89 4d b0          	mov    QWORD PTR [rbp-0x50],r9
  4104cb:	44 89 55 bc          	mov    DWORD PTR [rbp-0x44],r10d
  4104cf:	e8 0c c5 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  4104d4:	44 8b 55 bc          	mov    r10d,DWORD PTR [rbp-0x44]
  4104d8:	4c 8b 4d b0          	mov    r9,QWORD PTR [rbp-0x50]
  4104dc:	85 c0                	test   eax,eax
  4104de:	44 8b 45 b8          	mov    r8d,DWORD PTR [rbp-0x48]
  4104e2:	75 16                	jne    4104fa <cos_comp_alloc+0x17a>
        __asm__ __volatile__("lock " PS_FAA_STR
  4104e4:	b8 04 00 00 00       	mov    eax,0x4
  4104e9:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  4104f0:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  4104f5:	e9 14 ff ff ff       	jmp    41040e <cos_comp_alloc+0x8e>
{ l->o = 0; }
  4104fa:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  410501:	00 00 00 00 00 
	if (!cap) return 0;
  410506:	eb 82                	jmp    41048a <cos_comp_alloc+0x10a>
  410508:	be 2f 00 00 00       	mov    esi,0x2f
  41050d:	bf 58 e3 41 00       	mov    edi,0x41e358
  410512:	e8 b9 9b ff ff       	call   40a0d0 <cos_print_str>
	assert(ci && ctc && ptc && lid);
  410517:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41051e:	00 00 00 00 
  410522:	0f 0b                	ud2    
  410524:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41052b:	00 00 00 00 
  41052f:	90                   	nop

0000000000410530 <cos_comp_alloc_shared>:

int
cos_comp_alloc_shared(struct cos_compinfo *ci, pgtblcap_t ptc, vaddr_t entry, struct cos_compinfo *ci_resources, prot_domain_t protdom)
{
  410530:	f3 0f 1e fa          	endbr64 
  410534:	55                   	push   rbp
  410535:	48 89 e5             	mov    rbp,rsp
  410538:	41 57                	push   r15
  41053a:	49 89 f7             	mov    r15,rsi
  41053d:	41 56                	push   r14
  41053f:	41 55                	push   r13
  410541:	41 54                	push   r12
  410543:	53                   	push   rbx
  410544:	48 83 ec 28          	sub    rsp,0x28
	compcap_t   compc;
	captblcap_t ctc = ci->captbl_cap;
  410548:	48 8b 77 08          	mov    rsi,QWORD PTR [rdi+0x8]

	printd("cos_compinfo_alloc_shared\n");
	assert(ptc);
  41054c:	4d 85 ff             	test   r15,r15
  41054f:	0f 84 7f 01 00 00    	je     4106d4 <cos_comp_alloc_shared+0x1a4>
	assert(ctc);
  410555:	48 85 f6             	test   rsi,rsi
  410558:	0f 84 92 01 00 00    	je     4106f0 <cos_comp_alloc_shared+0x1c0>
  41055e:	49 89 d6             	mov    r14,rdx
	return livenessid_frontier++;
  410561:	8b 15 59 bb 04 00    	mov    edx,DWORD PTR [rip+0x4bb59]        # 45c0c0 <livenessid_frontier>
  410567:	49 89 cc             	mov    r12,rcx
  41056a:	8d 42 01             	lea    eax,[rdx+0x1]
  41056d:	89 05 4d bb 04 00    	mov    DWORD PTR [rip+0x4bb4d],eax        # 45c0c0 <livenessid_frontier>
	assert(ci && ctc && ptc && lid);
  410573:	48 85 c9             	test   rcx,rcx
  410576:	0f 84 3c 01 00 00    	je     4106b8 <cos_comp_alloc_shared+0x188>
  41057c:	49 89 fd             	mov    r13,rdi
{ while (!ps_cas(&l->o, 0, 1)) ; }
  41057f:	48 8d 89 b0 00 00 00 	lea    rcx,[rcx+0xb0]
        __asm__ __volatile__("lock " PS_CAS_STR
  410586:	41 ba 01 00 00 00    	mov    r10d,0x1
  41058c:	45 31 c9             	xor    r9d,r9d
  41058f:	85 d2                	test   edx,edx
  410591:	0f 84 21 01 00 00    	je     4106b8 <cos_comp_alloc_shared+0x188>
  410597:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41059e:	00 00 
  4105a0:	4c 89 c8             	mov    rax,r9
  4105a3:	f0 4c 0f b1 11       	lock cmpxchg QWORD PTR [rcx],r10
  4105a8:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  4105ab:	84 c0                	test   al,al
  4105ad:	74 f1                	je     4105a0 <cos_comp_alloc_shared+0x70>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  4105af:	41 f6 44 24 38 03    	test   BYTE PTR [r12+0x38],0x3
  4105b5:	0f 84 c5 00 00 00    	je     410680 <cos_comp_alloc_shared+0x150>
        __asm__ __volatile__("lock " PS_FAA_STR
  4105bb:	bb 04 00 00 00       	mov    ebx,0x4
  4105c0:	f0 49 0f c1 5c 24 38 	lock xadd QWORD PTR [r12+0x38],rbx
        return inc;
  4105c7:	66 48 0f 6e c3       	movq   xmm0,rbx
  4105cc:	66 49 0f 6e cf       	movq   xmm1,r15
{ l->o = 0; }
  4105d1:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  4105d8:	00 00 00 00 00 
  4105dd:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
	if (!cap) return 0;
  4105e1:	48 85 db             	test   rbx,rbx
  4105e4:	0f 84 2e 01 00 00    	je     410718 <cos_comp_alloc_shared+0x1e8>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_COMPACTIVATE, comp, (ctc << 16) | ptc, ((unsigned long)lid << 32) | protdom, entry)) return 1;
  4105ea:	49 8b 44 24 08       	mov    rax,QWORD PTR [r12+0x8]
  4105ef:	48 c1 e2 20          	shl    rdx,0x20
  4105f3:	48 c1 e6 10          	shl    rsi,0x10
  4105f7:	45 89 c0             	mov    r8d,r8d
  4105fa:	48 89 d7             	mov    rdi,rdx
  4105fd:	4c 09 fe             	or     rsi,r15
  410600:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  410604:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  410607:	c1 e0 10             	shl    eax,0x10
  41060a:	4c 09 c7             	or     rdi,r8
	cap_no += op;
  41060d:	05 0d 00 01 00       	add    eax,0x1000d
	__asm__ __volatile__(
  410612:	48 89 29             	mov    QWORD PTR [rcx],rbp
  410615:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  410619:	48 89 cd             	mov    rbp,rcx
  41061c:	49 b8 30 06 41 00 00 	movabs r8,0x410630
  410623:	00 00 00 
  410626:	0f 05                	syscall 
  410628:	eb 0d                	jmp    410637 <cos_comp_alloc_shared+0x107>
  41062a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410630:	b9 00 00 00 00       	mov    ecx,0x0
  410635:	eb 05                	jmp    41063c <cos_comp_alloc_shared+0x10c>
  410637:	b9 01 00 00 00       	mov    ecx,0x1
  41063c:	5d                   	pop    rbp
  41063d:	5c                   	pop    rsp
  41063e:	85 c0                	test   eax,eax
  410640:	75 1e                	jne    410660 <cos_comp_alloc_shared+0x130>
	compc = cos_comp_alloc(ci_resources, ctc, ptc, entry, protdom);
	assert(compc);

	ci->comp_cap_shared = compc;
  410642:	41 0f 11 85 c8 00 00 	movups XMMWORD PTR [r13+0xc8],xmm0
  410649:	00 
	ci->pgtbl_cap_shared = ptc;

	return 0;
}
  41064a:	48 83 c4 28          	add    rsp,0x28
  41064e:	31 c0                	xor    eax,eax
  410650:	5b                   	pop    rbx
  410651:	41 5c                	pop    r12
  410653:	41 5d                	pop    r13
  410655:	41 5e                	pop    r14
  410657:	41 5f                	pop    r15
  410659:	5d                   	pop    rbp
  41065a:	c3                   	ret    
  41065b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  410660:	be 1c 00 00 00       	mov    esi,0x1c
  410665:	bf 88 e3 41 00       	mov    edi,0x41e388
  41066a:	e8 61 9a ff ff       	call   40a0d0 <cos_print_str>
	if (cos_comp_alloc_with(ci, cap, lid, ctc, ptc, entry, protdom)) BUG();
  41066f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410676:	00 00 00 00 
  41067a:	0f 0b                	ud2    
  41067c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  410680:	4c 89 e7             	mov    rdi,r12
  410683:	44 89 45 b0          	mov    DWORD PTR [rbp-0x50],r8d
  410687:	89 55 b4             	mov    DWORD PTR [rbp-0x4c],edx
  41068a:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
  41068e:	e8 4d c3 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  410693:	48 8b 75 b8          	mov    rsi,QWORD PTR [rbp-0x48]
  410697:	8b 55 b4             	mov    edx,DWORD PTR [rbp-0x4c]
  41069a:	85 c0                	test   eax,eax
  41069c:	44 8b 45 b0          	mov    r8d,DWORD PTR [rbp-0x50]
  4106a0:	75 6a                	jne    41070c <cos_comp_alloc_shared+0x1dc>
        __asm__ __volatile__("lock " PS_FAA_STR
  4106a2:	b8 04 00 00 00       	mov    eax,0x4
  4106a7:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  4106ae:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  4106b3:	e9 03 ff ff ff       	jmp    4105bb <cos_comp_alloc_shared+0x8b>
  4106b8:	be 2f 00 00 00       	mov    esi,0x2f
  4106bd:	bf 58 e3 41 00       	mov    edi,0x41e358
  4106c2:	e8 09 9a ff ff       	call   40a0d0 <cos_print_str>
	assert(ci && ctc && ptc && lid);
  4106c7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4106ce:	00 00 00 00 
  4106d2:	0f 0b                	ud2    
  4106d4:	be 2f 00 00 00       	mov    esi,0x2f
  4106d9:	bf a8 e3 41 00       	mov    edi,0x41e3a8
  4106de:	e8 ed 99 ff ff       	call   40a0d0 <cos_print_str>
	assert(ptc);
  4106e3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4106ea:	00 00 00 00 
  4106ee:	0f 0b                	ud2    
  4106f0:	be 2f 00 00 00       	mov    esi,0x2f
  4106f5:	bf d8 e3 41 00       	mov    edi,0x41e3d8
  4106fa:	e8 d1 99 ff ff       	call   40a0d0 <cos_print_str>
	assert(ctc);
  4106ff:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410706:	00 00 00 00 
  41070a:	0f 0b                	ud2    
{ l->o = 0; }
  41070c:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  410713:	00 00 00 00 00 
  410718:	be 2f 00 00 00       	mov    esi,0x2f
  41071d:	bf 08 e4 41 00       	mov    edi,0x41e408
  410722:	e8 a9 99 ff ff       	call   40a0d0 <cos_print_str>
	assert(compc);
  410727:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41072e:	00 00 00 00 
  410732:	0f 0b                	ud2    
  410734:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41073b:	00 00 00 00 
  41073f:	90                   	nop

0000000000410740 <cos_compinfo_alloc>:
}

int
cos_compinfo_alloc(struct cos_compinfo *ci, vaddr_t heap_ptr, capid_t cap_frontier, vaddr_t entry,
                   struct cos_compinfo *ci_resources, prot_domain_t protdom)
{
  410740:	f3 0f 1e fa          	endbr64 
  410744:	55                   	push   rbp
	vaddr_t     last_page;
	word_t      pgtbl_lvl;
	u8_t        mem_type = PGTBL_TYPE_DEF;
	word_t      pgtbl_lvl_flag = 0;

	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  410745:	b8 01 00 00 80       	mov    eax,0x80000001
{
  41074a:	48 89 e5             	mov    rbp,rsp
  41074d:	41 57                	push   r15
  41074f:	41 56                	push   r14
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  410751:	41 be 01 00 00 00    	mov    r14d,0x1
{
  410757:	41 55                	push   r13
  410759:	49 89 fd             	mov    r13,rdi
  41075c:	41 54                	push   r12
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  41075e:	41 bc 00 00 00 00    	mov    r12d,0x0
{
  410764:	53                   	push   rbx
  410765:	4c 89 c3             	mov    rbx,r8
  410768:	48 83 ec 38          	sub    rsp,0x38
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  41076c:	80 bf d8 00 00 00 01 	cmp    BYTE PTR [rdi+0xd8],0x1
{
  410773:	48 89 55 a8          	mov    QWORD PTR [rbp-0x58],rdx
		pgtbl_lvl_flag = PGTBL_LVL_FLAG_VM;
	}

	printd("cos_compinfo_alloc\n");

	ptc = cos_pgtbl_alloc(ci_resources, mem_type);
  410777:	4c 89 c7             	mov    rdi,r8
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  41077a:	4c 0f 44 f0          	cmove  r14,rax
  41077e:	ba 02 00 00 00       	mov    edx,0x2
  410783:	48 8d 40 01          	lea    rax,[rax+0x1]
{
  410787:	48 89 75 b0          	mov    QWORD PTR [rbp-0x50],rsi
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  41078b:	48 0f 45 c2          	cmovne rax,rdx
  41078f:	40 0f 94 c6          	sete   sil
{
  410793:	48 89 4d c8          	mov    QWORD PTR [rbp-0x38],rcx
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  410797:	40 0f b6 f6          	movzx  esi,sil
{
  41079b:	44 89 4d c4          	mov    DWORD PTR [rbp-0x3c],r9d
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  41079f:	48 89 45 b8          	mov    QWORD PTR [rbp-0x48],rax
  4107a3:	b8 00 00 00 80       	mov    eax,0x80000000
  4107a8:	4c 0f 44 e0          	cmove  r12,rax
	ptc = cos_pgtbl_alloc(ci_resources, mem_type);
  4107ac:	e8 af f3 ff ff       	call   40fb60 <cos_pgtbl_alloc>
	assert(ptc);
  4107b1:	48 85 c0             	test   rax,rax
  4107b4:	0f 84 28 01 00 00    	je     4108e2 <cos_compinfo_alloc+0x1a2>
	ctc = cos_captbl_alloc(ci_resources);
  4107ba:	48 89 df             	mov    rdi,rbx
  4107bd:	49 89 c7             	mov    r15,rax
  4107c0:	e8 3b f2 ff ff       	call   40fa00 <cos_captbl_alloc>
	assert(ctc);
  4107c5:	48 85 c0             	test   rax,rax
  4107c8:	0f 84 30 01 00 00    	je     4108fe <cos_compinfo_alloc+0x1be>
	compc = cos_comp_alloc(ci_resources, ctc, ptc, entry, protdom);
  4107ce:	48 8b 4d c8          	mov    rcx,QWORD PTR [rbp-0x38]
  4107d2:	44 8b 45 c4          	mov    r8d,DWORD PTR [rbp-0x3c]
  4107d6:	4c 89 fa             	mov    rdx,r15
  4107d9:	48 89 c6             	mov    rsi,rax
  4107dc:	48 89 df             	mov    rdi,rbx
  4107df:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
  4107e3:	e8 98 fb ff ff       	call   410380 <cos_comp_alloc>
	assert(compc);
  4107e8:	4c 8b 55 c8          	mov    r10,QWORD PTR [rbp-0x38]
  4107ec:	48 85 c0             	test   rax,rax
	compc = cos_comp_alloc(ci_resources, ctc, ptc, entry, protdom);
  4107ef:	48 89 c1             	mov    rcx,rax
	assert(compc);
  4107f2:	0f 84 22 01 00 00    	je     41091a <cos_compinfo_alloc+0x1da>

	cos_compinfo_init(ci, ptc, ctc, compc, heap_ptr, cap_frontier, ci_resources);
  4107f8:	48 83 ec 08          	sub    rsp,0x8
  4107fc:	4c 8b 4d a8          	mov    r9,QWORD PTR [rbp-0x58]
  410800:	4c 89 d2             	mov    rdx,r10
  410803:	4c 89 fe             	mov    rsi,r15
  410806:	53                   	push   rbx
  410807:	48 8b 5d b0          	mov    rbx,QWORD PTR [rbp-0x50]
  41080b:	4c 89 ef             	mov    rdi,r13
  41080e:	49 89 d8             	mov    r8,rbx
  410811:	e8 0a cf ff ff       	call   40d720 <cos_compinfo_init>

	ci->mi.second_lvl_pgtbl_cap  = __bump_mem_expand_intern(__compinfo_metacap(ci), ci->pgtbl_cap, heap_ptr, 0, 0 | pgtbl_lvl_flag);
  410816:	49 8b 7d 60          	mov    rdi,QWORD PTR [r13+0x60]
  41081a:	49 8b 75 00          	mov    rsi,QWORD PTR [r13+0x0]
  41081e:	48 89 da             	mov    rdx,rbx
  410821:	31 c9                	xor    ecx,ecx
  410823:	4d 89 e0             	mov    r8,r12
  410826:	e8 75 cb ff ff       	call   40d3a0 <__bump_mem_expand_intern>
  41082b:	66 48 0f 6e cb       	movq   xmm1,rbx
  410830:	66 48 0f 6e c0       	movq   xmm0,rax

	/* 
	 * This is to make sure that "the address below vas_frontier has been allocated, 
	 * follow the assumption we put in cos_vasfrontier_init()"
	 */
	last_page = round_to_page(ci->vas_frontier - 1);
  410835:	49 8b 45 40          	mov    rax,QWORD PTR [r13+0x40]
	ci->mi.second_lvl_pgtbl_cap  = __bump_mem_expand_intern(__compinfo_metacap(ci), ci->pgtbl_cap, heap_ptr, 0, 0 | pgtbl_lvl_flag);
  410839:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
	last_page = round_to_page(ci->vas_frontier - 1);
  41083d:	48 8d 50 ff          	lea    rdx,[rax-0x1]
	ci->mi.second_lvl_pgtbl_cap  = __bump_mem_expand_intern(__compinfo_metacap(ci), ci->pgtbl_cap, heap_ptr, 0, 0 | pgtbl_lvl_flag);
  410841:	41 0f 11 85 a0 00 00 	movups XMMWORD PTR [r13+0xa0],xmm0
  410848:	00 
		return round_up_to_pgt0_page(vaddr);
  410849:	48 b8 ff ff ff ff 7f 	movabs rax,0x7fffffffff
  410850:	00 00 00 
	last_page = round_to_page(ci->vas_frontier - 1);
  410853:	48 81 e2 00 f0 ff ff 	and    rdx,0xfffffffffffff000
		return round_up_to_pgt0_page(vaddr);
  41085a:	48 01 c3             	add    rbx,rax
  41085d:	48 01 d0             	add    rax,rdx

	/* If previous page is in a different second level pagetable, need to allocate */
	if (cos_pgtbl_round_up_to_page(0, last_page) != cos_pgtbl_round_up_to_page(0, heap_ptr)) {
  410860:	48 31 c3             	xor    rbx,rax
  410863:	58                   	pop    rax
  410864:	59                   	pop    rcx
  410865:	48 b8 00 00 00 00 80 	movabs rax,0xffffff8000000000
  41086c:	ff ff ff 
  41086f:	48 85 c3             	test   rbx,rax
  410872:	75 4c                	jne    4108c0 <cos_compinfo_alloc+0x180>

	}

	/* Allocate the rest of the levels */
	for (pgtbl_lvl = 1; pgtbl_lvl < COS_PGTBL_DEPTH - 1; pgtbl_lvl++) {
		__bump_mem_expand_intern(__compinfo_metacap(ci), ptc, round_to_page(ci->vas_frontier - 1), 0, pgtbl_lvl | pgtbl_lvl_flag);	
  410874:	49 8b 7d 60          	mov    rdi,QWORD PTR [r13+0x60]
  410878:	4d 89 f0             	mov    r8,r14
  41087b:	4c 89 fe             	mov    rsi,r15
  41087e:	31 c9                	xor    ecx,ecx
  410880:	e8 1b cb ff ff       	call   40d3a0 <__bump_mem_expand_intern>
  410885:	49 8b 45 40          	mov    rax,QWORD PTR [r13+0x40]
  410889:	49 8b 7d 60          	mov    rdi,QWORD PTR [r13+0x60]
  41088d:	4c 89 fe             	mov    rsi,r15
  410890:	4c 8b 45 b8          	mov    r8,QWORD PTR [rbp-0x48]
  410894:	31 c9                	xor    ecx,ecx
  410896:	48 8d 50 ff          	lea    rdx,[rax-0x1]
  41089a:	48 81 e2 00 f0 ff ff 	and    rdx,0xfffffffffffff000
  4108a1:	e8 fa ca ff ff       	call   40d3a0 <__bump_mem_expand_intern>
	}

	return 0;
}
  4108a6:	48 8d 65 d8          	lea    rsp,[rbp-0x28]
  4108aa:	31 c0                	xor    eax,eax
  4108ac:	5b                   	pop    rbx
  4108ad:	41 5c                	pop    r12
  4108af:	41 5d                	pop    r13
  4108b1:	41 5e                	pop    r14
  4108b3:	41 5f                	pop    r15
  4108b5:	5d                   	pop    rbp
  4108b6:	c3                   	ret    
  4108b7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  4108be:	00 00 
		__bump_mem_expand_intern(__compinfo_metacap(ci), ptc, round_to_page(ci->vas_frontier - 1), 0, 0 | pgtbl_lvl_flag);
  4108c0:	49 8b 7d 60          	mov    rdi,QWORD PTR [r13+0x60]
  4108c4:	4d 89 e0             	mov    r8,r12
  4108c7:	31 c9                	xor    ecx,ecx
  4108c9:	4c 89 fe             	mov    rsi,r15
  4108cc:	e8 cf ca ff ff       	call   40d3a0 <__bump_mem_expand_intern>
		__bump_mem_expand_intern(__compinfo_metacap(ci), ptc, round_to_page(ci->vas_frontier - 1), 0, pgtbl_lvl | pgtbl_lvl_flag);	
  4108d1:	49 8b 45 40          	mov    rax,QWORD PTR [r13+0x40]
  4108d5:	48 8d 50 ff          	lea    rdx,[rax-0x1]
  4108d9:	48 81 e2 00 f0 ff ff 	and    rdx,0xfffffffffffff000
  4108e0:	eb 92                	jmp    410874 <cos_compinfo_alloc+0x134>
  4108e2:	be 2f 00 00 00       	mov    esi,0x2f
  4108e7:	bf 38 e4 41 00       	mov    edi,0x41e438
  4108ec:	e8 df 97 ff ff       	call   40a0d0 <cos_print_str>
	assert(ptc);
  4108f1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4108f8:	00 00 00 00 
  4108fc:	0f 0b                	ud2    
  4108fe:	be 2f 00 00 00       	mov    esi,0x2f
  410903:	bf 68 e4 41 00       	mov    edi,0x41e468
  410908:	e8 c3 97 ff ff       	call   40a0d0 <cos_print_str>
	assert(ctc);
  41090d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410914:	00 00 00 00 
  410918:	0f 0b                	ud2    
  41091a:	be 2f 00 00 00       	mov    esi,0x2f
  41091f:	bf 98 e4 41 00       	mov    edi,0x41e498
  410924:	e8 a7 97 ff ff       	call   40a0d0 <cos_print_str>
	assert(compc);
  410929:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410930:	00 00 00 00 
  410934:	0f 0b                	ud2    
  410936:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41093d:	00 00 00 

0000000000410940 <cos_sinv_alloc>:

sinvcap_t
cos_sinv_alloc(struct cos_compinfo *srcci, compcap_t dstcomp, vaddr_t entry, invtoken_t token)
{
  410940:	f3 0f 1e fa          	endbr64 
  410944:	55                   	push   rbp
  410945:	48 89 e5             	mov    rbp,rsp
  410948:	41 57                	push   r15
  41094a:	41 56                	push   r14
  41094c:	41 55                	push   r13
  41094e:	41 54                	push   r12
  410950:	53                   	push   rbx
  410951:	48 83 ec 28          	sub    rsp,0x28
	capid_t cap;

	printd("cos_sinv_alloc\n");

	assert(srcci && dstcomp);
  410955:	48 85 ff             	test   rdi,rdi
  410958:	0f 84 2c 01 00 00    	je     410a8a <cos_sinv_alloc+0x14a>
  41095e:	49 89 f7             	mov    r15,rsi
  410961:	48 85 f6             	test   rsi,rsi
  410964:	0f 84 20 01 00 00    	je     410a8a <cos_sinv_alloc+0x14a>
  41096a:	49 89 fc             	mov    r12,rdi
  41096d:	49 89 d5             	mov    r13,rdx
  410970:	49 89 ce             	mov    r14,rcx
	missing_captbl_node_expand(srcci);
  410973:	e8 58 d4 ff ff       	call   40ddd0 <missing_captbl_node_expand>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  410978:	49 8d 8c 24 b0 00 00 	lea    rcx,[r12+0xb0]
  41097f:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  410980:	be 01 00 00 00       	mov    esi,0x1
  410985:	31 d2                	xor    edx,edx
  410987:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41098e:	00 00 
  410990:	48 89 d0             	mov    rax,rdx
  410993:	f0 48 0f b1 31       	lock cmpxchg QWORD PTR [rcx],rsi
  410998:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  41099b:	84 c0                	test   al,al
  41099d:	74 f1                	je     410990 <cos_sinv_alloc+0x50>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  41099f:	4d 8b 54 24 38       	mov    r10,QWORD PTR [r12+0x38]
  4109a4:	41 83 e2 03          	and    r10d,0x3
  4109a8:	0f 84 82 00 00 00    	je     410a30 <cos_sinv_alloc+0xf0>
        __asm__ __volatile__("lock " PS_FAA_STR
  4109ae:	bb 04 00 00 00       	mov    ebx,0x4
  4109b3:	f0 49 0f c1 5c 24 38 	lock xadd QWORD PTR [r12+0x38],rbx
{ l->o = 0; }
  4109ba:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  4109c1:	00 00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  4109c6:	49 89 da             	mov    r10,rbx
	cap = __capid_bump_alloc(srcci, CAP_COMP);
	if (!cap) return 0;
  4109c9:	48 85 db             	test   rbx,rbx
  4109cc:	74 4c                	je     410a1a <cos_sinv_alloc+0xda>
	if (call_cap_op(srcci->captbl_cap, CAPTBL_OP_SINVACTIVATE, cap, dstcomp, entry, token)) BUG();
  4109ce:	49 8b 44 24 08       	mov    rax,QWORD PTR [r12+0x8]
  4109d3:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  4109d7:	4c 89 fe             	mov    rsi,r15
  4109da:	4c 89 ef             	mov    rdi,r13
  4109dd:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4109e0:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  4109e3:	05 0f 00 01 00       	add    eax,0x1000f
	__asm__ __volatile__(
  4109e8:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4109eb:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4109ef:	48 89 cd             	mov    rbp,rcx
  4109f2:	49 b8 08 0a 41 00 00 	movabs r8,0x410a08
  4109f9:	00 00 00 
  4109fc:	0f 05                	syscall 
  4109fe:	66 90                	xchg   ax,ax
  410a00:	eb 0d                	jmp    410a0f <cos_sinv_alloc+0xcf>
  410a02:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410a08:	b9 00 00 00 00       	mov    ecx,0x0
  410a0d:	eb 05                	jmp    410a14 <cos_sinv_alloc+0xd4>
  410a0f:	b9 01 00 00 00       	mov    ecx,0x1
  410a14:	5d                   	pop    rbp
  410a15:	5c                   	pop    rsp
  410a16:	85 c0                	test   eax,eax
  410a18:	75 46                	jne    410a60 <cos_sinv_alloc+0x120>

	return cap;
}
  410a1a:	48 83 c4 28          	add    rsp,0x28
  410a1e:	4c 89 d0             	mov    rax,r10
  410a21:	5b                   	pop    rbx
  410a22:	41 5c                	pop    r12
  410a24:	41 5d                	pop    r13
  410a26:	41 5e                	pop    r14
  410a28:	41 5f                	pop    r15
  410a2a:	5d                   	pop    rbp
  410a2b:	c3                   	ret    
  410a2c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  410a30:	4c 89 e7             	mov    rdi,r12
  410a33:	4c 89 55 b8          	mov    QWORD PTR [rbp-0x48],r10
  410a37:	e8 a4 bf ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  410a3c:	4c 8b 55 b8          	mov    r10,QWORD PTR [rbp-0x48]
  410a40:	85 c0                	test   eax,eax
  410a42:	75 38                	jne    410a7c <cos_sinv_alloc+0x13c>
        __asm__ __volatile__("lock " PS_FAA_STR
  410a44:	b8 04 00 00 00       	mov    eax,0x4
  410a49:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  410a50:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  410a55:	e9 54 ff ff ff       	jmp    4109ae <cos_sinv_alloc+0x6e>
  410a5a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410a60:	be 1c 00 00 00       	mov    esi,0x1c
  410a65:	bf f8 e4 41 00       	mov    edi,0x41e4f8
  410a6a:	e8 61 96 ff ff       	call   40a0d0 <cos_print_str>
	if (call_cap_op(srcci->captbl_cap, CAPTBL_OP_SINVACTIVATE, cap, dstcomp, entry, token)) BUG();
  410a6f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410a76:	00 00 00 00 
  410a7a:	0f 0b                	ud2    
{ l->o = 0; }
  410a7c:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  410a83:	00 00 00 00 00 
	if (!cap) return 0;
  410a88:	eb 90                	jmp    410a1a <cos_sinv_alloc+0xda>
  410a8a:	be 2f 00 00 00       	mov    esi,0x2f
  410a8f:	bf c8 e4 41 00       	mov    edi,0x41e4c8
  410a94:	e8 37 96 ff ff       	call   40a0d0 <cos_print_str>
	assert(srcci && dstcomp);
  410a99:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410aa0:	00 00 00 00 
  410aa4:	0f 0b                	ud2    
  410aa6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  410aad:	00 00 00 

0000000000410ab0 <cos_arcv_alloc>:
 * arcvcap: the rcv * endpoint that is the scheduler to be activated
 *          when the thread blocks on this endpoint.
 */
arcvcap_t
cos_arcv_alloc(struct cos_compinfo *ci, thdcap_t thdcap, tcap_t tcapcap, compcap_t compcap, arcvcap_t arcvcap)
{
  410ab0:	f3 0f 1e fa          	endbr64 
  410ab4:	55                   	push   rbp
  410ab5:	48 89 e5             	mov    rbp,rsp
  410ab8:	41 57                	push   r15
  410aba:	41 56                	push   r14
  410abc:	41 55                	push   r13
  410abe:	41 54                	push   r12
  410ac0:	53                   	push   rbx
  410ac1:	48 83 ec 28          	sub    rsp,0x28
	capid_t cap;
	int ret;

	assert(ci && thdcap && tcapcap && compcap);
  410ac5:	48 85 ff             	test   rdi,rdi
  410ac8:	0f 84 4c 01 00 00    	je     410c1a <cos_arcv_alloc+0x16a>
  410ace:	48 85 f6             	test   rsi,rsi
  410ad1:	0f 84 43 01 00 00    	je     410c1a <cos_arcv_alloc+0x16a>
  410ad7:	48 85 d2             	test   rdx,rdx
  410ada:	0f 84 3a 01 00 00    	je     410c1a <cos_arcv_alloc+0x16a>
  410ae0:	48 85 c9             	test   rcx,rcx
  410ae3:	49 89 cd             	mov    r13,rcx
  410ae6:	49 89 fc             	mov    r12,rdi
  410ae9:	4d 89 c6             	mov    r14,r8
  410aec:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  410aef:	48 8d 8f b0 00 00 00 	lea    rcx,[rdi+0xb0]
        __asm__ __volatile__("lock " PS_CAS_STR
  410af6:	41 ba 01 00 00 00    	mov    r10d,0x1
  410afc:	45 31 c9             	xor    r9d,r9d
  410aff:	84 c0                	test   al,al
  410b01:	0f 85 13 01 00 00    	jne    410c1a <cos_arcv_alloc+0x16a>
  410b07:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  410b0e:	00 00 
  410b10:	4c 89 c8             	mov    rax,r9
  410b13:	f0 4c 0f b1 11       	lock cmpxchg QWORD PTR [rcx],r10
  410b18:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  410b1b:	84 c0                	test   al,al
  410b1d:	74 f1                	je     410b10 <cos_arcv_alloc+0x60>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  410b1f:	4d 8b 7c 24 38       	mov    r15,QWORD PTR [r12+0x38]
  410b24:	41 83 e7 03          	and    r15d,0x3
  410b28:	0f 84 8a 00 00 00    	je     410bb8 <cos_arcv_alloc+0x108>
        __asm__ __volatile__("lock " PS_FAA_STR
  410b2e:	bb 04 00 00 00       	mov    ebx,0x4
  410b33:	f0 49 0f c1 5c 24 38 	lock xadd QWORD PTR [r12+0x38],rbx
{ l->o = 0; }
  410b3a:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  410b41:	00 00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  410b46:	49 89 df             	mov    r15,rbx

	printd("arcv_alloc: tcap cap %d\n", (int)tcapcap);

	cap = __capid_bump_alloc(ci, CAP_ARCV);
	if (!cap) return 0;
  410b49:	48 85 db             	test   rbx,rbx
  410b4c:	74 54                	je     410ba2 <cos_arcv_alloc+0xf2>
	if ((ret = call_cap_op(ci->captbl_cap, CAPTBL_OP_ARCVACTIVATE, cap, thdcap | (tcapcap << 16), compcap, arcvcap))) BUG();
  410b4e:	49 8b 44 24 08       	mov    rax,QWORD PTR [r12+0x8]
  410b53:	48 c1 e2 10          	shl    rdx,0x10
  410b57:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  410b5b:	4c 89 ef             	mov    rdi,r13
  410b5e:	48 09 d6             	or     rsi,rdx
  410b61:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  410b64:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  410b67:	05 15 00 01 00       	add    eax,0x10015
	__asm__ __volatile__(
  410b6c:	48 89 29             	mov    QWORD PTR [rcx],rbp
  410b6f:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  410b73:	48 89 cd             	mov    rbp,rcx
  410b76:	49 b8 90 0b 41 00 00 	movabs r8,0x410b90
  410b7d:	00 00 00 
  410b80:	0f 05                	syscall 
  410b82:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410b88:	eb 0d                	jmp    410b97 <cos_arcv_alloc+0xe7>
  410b8a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410b90:	b9 00 00 00 00       	mov    ecx,0x0
  410b95:	eb 05                	jmp    410b9c <cos_arcv_alloc+0xec>
  410b97:	b9 01 00 00 00       	mov    ecx,0x1
  410b9c:	5d                   	pop    rbp
  410b9d:	5c                   	pop    rsp
  410b9e:	85 c0                	test   eax,eax
  410ba0:	75 4e                	jne    410bf0 <cos_arcv_alloc+0x140>

	return cap;
}
  410ba2:	48 83 c4 28          	add    rsp,0x28
  410ba6:	4c 89 f8             	mov    rax,r15
  410ba9:	5b                   	pop    rbx
  410baa:	41 5c                	pop    r12
  410bac:	41 5d                	pop    r13
  410bae:	41 5e                	pop    r14
  410bb0:	41 5f                	pop    r15
  410bb2:	5d                   	pop    rbp
  410bb3:	c3                   	ret    
  410bb4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  410bb8:	4c 89 e7             	mov    rdi,r12
  410bbb:	48 89 55 b0          	mov    QWORD PTR [rbp-0x50],rdx
  410bbf:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
  410bc3:	e8 18 be ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  410bc8:	48 8b 75 b8          	mov    rsi,QWORD PTR [rbp-0x48]
  410bcc:	48 8b 55 b0          	mov    rdx,QWORD PTR [rbp-0x50]
  410bd0:	85 c0                	test   eax,eax
  410bd2:	75 38                	jne    410c0c <cos_arcv_alloc+0x15c>
        __asm__ __volatile__("lock " PS_FAA_STR
  410bd4:	b8 04 00 00 00       	mov    eax,0x4
  410bd9:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  410be0:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  410be5:	e9 44 ff ff ff       	jmp    410b2e <cos_arcv_alloc+0x7e>
  410bea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410bf0:	be 1c 00 00 00       	mov    esi,0x1c
  410bf5:	bf 48 e5 41 00       	mov    edi,0x41e548
  410bfa:	e8 d1 94 ff ff       	call   40a0d0 <cos_print_str>
	if ((ret = call_cap_op(ci->captbl_cap, CAPTBL_OP_ARCVACTIVATE, cap, thdcap | (tcapcap << 16), compcap, arcvcap))) BUG();
  410bff:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410c06:	00 00 00 00 
  410c0a:	0f 0b                	ud2    
{ l->o = 0; }
  410c0c:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  410c13:	00 00 00 00 00 
	if (!cap) return 0;
  410c18:	eb 88                	jmp    410ba2 <cos_arcv_alloc+0xf2>
  410c1a:	be 2f 00 00 00       	mov    esi,0x2f
  410c1f:	bf 18 e5 41 00       	mov    edi,0x41e518
  410c24:	e8 a7 94 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci && thdcap && tcapcap && compcap);
  410c29:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410c30:	00 00 00 00 
  410c34:	0f 0b                	ud2    
  410c36:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  410c3d:	00 00 00 

0000000000410c40 <cos_asnd_alloc>:

asndcap_t
cos_asnd_alloc(struct cos_compinfo *ci, arcvcap_t arcvcap, captblcap_t ctcap)
{
  410c40:	f3 0f 1e fa          	endbr64 
  410c44:	55                   	push   rbp
  410c45:	48 89 e5             	mov    rbp,rsp
  410c48:	41 57                	push   r15
  410c4a:	41 56                	push   r14
  410c4c:	49 89 d6             	mov    r14,rdx
  410c4f:	41 55                	push   r13
  410c51:	41 54                	push   r12
  410c53:	53                   	push   rbx
  410c54:	48 83 ec 18          	sub    rsp,0x18
	capid_t cap;

	assert(ci && arcvcap && ctcap);
  410c58:	48 85 f6             	test   rsi,rsi
  410c5b:	0f 94 c0             	sete   al
  410c5e:	48 85 d2             	test   rdx,rdx
  410c61:	0f 94 c2             	sete   dl
  410c64:	08 d0                	or     al,dl
  410c66:	0f 85 16 01 00 00    	jne    410d82 <cos_asnd_alloc+0x142>
  410c6c:	48 85 ff             	test   rdi,rdi
  410c6f:	49 89 fc             	mov    r12,rdi
  410c72:	49 89 f5             	mov    r13,rsi
        __asm__ __volatile__("lock " PS_CAS_STR
  410c75:	41 b8 01 00 00 00    	mov    r8d,0x1
  410c7b:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  410c7e:	48 8d 97 b0 00 00 00 	lea    rdx,[rdi+0xb0]
        __asm__ __volatile__("lock " PS_CAS_STR
  410c85:	31 c9                	xor    ecx,ecx
  410c87:	84 c0                	test   al,al
  410c89:	0f 85 f3 00 00 00    	jne    410d82 <cos_asnd_alloc+0x142>
  410c8f:	90                   	nop
  410c90:	48 89 c8             	mov    rax,rcx
  410c93:	f0 4c 0f b1 02       	lock cmpxchg QWORD PTR [rdx],r8
  410c98:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  410c9b:	84 c0                	test   al,al
  410c9d:	74 f1                	je     410c90 <cos_asnd_alloc+0x50>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  410c9f:	4d 8b 7c 24 38       	mov    r15,QWORD PTR [r12+0x38]
  410ca4:	41 83 e7 03          	and    r15d,0x3
  410ca8:	0f 84 82 00 00 00    	je     410d30 <cos_asnd_alloc+0xf0>
        __asm__ __volatile__("lock " PS_FAA_STR
  410cae:	bb 04 00 00 00       	mov    ebx,0x4
  410cb3:	f0 49 0f c1 5c 24 38 	lock xadd QWORD PTR [r12+0x38],rbx
{ l->o = 0; }
  410cba:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  410cc1:	00 00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  410cc6:	49 89 df             	mov    r15,rbx

	cap = __capid_bump_alloc(ci, CAP_ASND);
	if (!cap) return 0;
  410cc9:	48 85 db             	test   rbx,rbx
  410ccc:	74 4c                	je     410d1a <cos_asnd_alloc+0xda>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_ASNDACTIVATE, cap, ctcap, arcvcap, 0)) BUG();
  410cce:	49 8b 44 24 08       	mov    rax,QWORD PTR [r12+0x8]
  410cd3:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  410cd7:	31 d2                	xor    edx,edx
  410cd9:	4c 89 f6             	mov    rsi,r14
  410cdc:	4c 89 ef             	mov    rdi,r13
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  410cdf:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  410ce2:	05 13 00 01 00       	add    eax,0x10013
	__asm__ __volatile__(
  410ce7:	48 89 29             	mov    QWORD PTR [rcx],rbp
  410cea:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  410cee:	48 89 cd             	mov    rbp,rcx
  410cf1:	49 b8 08 0d 41 00 00 	movabs r8,0x410d08
  410cf8:	00 00 00 
  410cfb:	0f 05                	syscall 
  410cfd:	0f 1f 00             	nop    DWORD PTR [rax]
  410d00:	eb 0d                	jmp    410d0f <cos_asnd_alloc+0xcf>
  410d02:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410d08:	b9 00 00 00 00       	mov    ecx,0x0
  410d0d:	eb 05                	jmp    410d14 <cos_asnd_alloc+0xd4>
  410d0f:	b9 01 00 00 00       	mov    ecx,0x1
  410d14:	5d                   	pop    rbp
  410d15:	5c                   	pop    rsp
  410d16:	85 c0                	test   eax,eax
  410d18:	75 3e                	jne    410d58 <cos_asnd_alloc+0x118>

	return cap;
}
  410d1a:	48 83 c4 18          	add    rsp,0x18
  410d1e:	4c 89 f8             	mov    rax,r15
  410d21:	5b                   	pop    rbx
  410d22:	41 5c                	pop    r12
  410d24:	41 5d                	pop    r13
  410d26:	41 5e                	pop    r14
  410d28:	41 5f                	pop    r15
  410d2a:	5d                   	pop    rbp
  410d2b:	c3                   	ret    
  410d2c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  410d30:	4c 89 e7             	mov    rdi,r12
  410d33:	e8 a8 bc ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  410d38:	85 c0                	test   eax,eax
  410d3a:	75 38                	jne    410d74 <cos_asnd_alloc+0x134>
        __asm__ __volatile__("lock " PS_FAA_STR
  410d3c:	b8 04 00 00 00       	mov    eax,0x4
  410d41:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  410d48:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  410d4d:	e9 5c ff ff ff       	jmp    410cae <cos_asnd_alloc+0x6e>
  410d52:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410d58:	be 1c 00 00 00       	mov    esi,0x1c
  410d5d:	bf 98 e5 41 00       	mov    edi,0x41e598
  410d62:	e8 69 93 ff ff       	call   40a0d0 <cos_print_str>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_ASNDACTIVATE, cap, ctcap, arcvcap, 0)) BUG();
  410d67:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410d6e:	00 00 00 00 
  410d72:	0f 0b                	ud2    
{ l->o = 0; }
  410d74:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  410d7b:	00 00 00 00 00 
	if (!cap) return 0;
  410d80:	eb 98                	jmp    410d1a <cos_asnd_alloc+0xda>
  410d82:	be 2f 00 00 00       	mov    esi,0x2f
  410d87:	bf 68 e5 41 00       	mov    edi,0x41e568
  410d8c:	e8 3f 93 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci && arcvcap && ctcap);
  410d91:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410d98:	00 00 00 00 
  410d9c:	0f 0b                	ud2    
  410d9e:	66 90                	xchg   ax,ax

0000000000410da0 <cos_hw_alloc>:
 * TODO: bitmap must be a subset of existing one.
 *       but there is no such check now, violates access control policy.
 */
hwcap_t
cos_hw_alloc(struct cos_compinfo *ci, u32_t bitmap)
{
  410da0:	f3 0f 1e fa          	endbr64 
  410da4:	55                   	push   rbp
  410da5:	48 89 e5             	mov    rbp,rsp
  410da8:	41 56                	push   r14
  410daa:	41 55                	push   r13
  410dac:	41 54                	push   r12
  410dae:	53                   	push   rbx
  410daf:	48 83 ec 10          	sub    rsp,0x10
	capid_t cap;

	assert(ci);
  410db3:	48 85 ff             	test   rdi,rdi
  410db6:	0f 84 0e 01 00 00    	je     410eca <cos_hw_alloc+0x12a>
  410dbc:	49 89 fc             	mov    r12,rdi
  410dbf:	41 89 f6             	mov    r14d,esi
  410dc2:	48 8d 97 b0 00 00 00 	lea    rdx,[rdi+0xb0]
  410dc9:	31 c9                	xor    ecx,ecx
  410dcb:	41 b8 01 00 00 00    	mov    r8d,0x1
  410dd1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  410dd8:	48 89 c8             	mov    rax,rcx
  410ddb:	f0 4c 0f b1 02       	lock cmpxchg QWORD PTR [rdx],r8
  410de0:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  410de3:	84 c0                	test   al,al
  410de5:	74 f1                	je     410dd8 <cos_hw_alloc+0x38>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  410de7:	4d 8b 6c 24 30       	mov    r13,QWORD PTR [r12+0x30]
  410dec:	41 83 e5 03          	and    r13d,0x3
  410df0:	0f 84 82 00 00 00    	je     410e78 <cos_hw_alloc+0xd8>
        __asm__ __volatile__("lock " PS_FAA_STR
  410df6:	bb 02 00 00 00       	mov    ebx,0x2
  410dfb:	f0 49 0f c1 5c 24 30 	lock xadd QWORD PTR [r12+0x30],rbx
{ l->o = 0; }
  410e02:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  410e09:	00 00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  410e0e:	49 89 dd             	mov    r13,rbx

	cap = __capid_bump_alloc(ci, CAP_HW);
	if (!cap) return 0;
  410e11:	48 85 db             	test   rbx,rbx
  410e14:	74 4c                	je     410e62 <cos_hw_alloc+0xc2>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_HW_ACTIVATE, cap, bitmap, 0, 0)) BUG();
  410e16:	49 8b 44 24 08       	mov    rax,QWORD PTR [r12+0x8]
  410e1b:	31 d2                	xor    edx,edx
  410e1d:	44 89 f6             	mov    esi,r14d
  410e20:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  410e24:	48 89 d7             	mov    rdi,rdx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  410e27:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  410e2a:	05 2b 00 01 00       	add    eax,0x1002b
	__asm__ __volatile__(
  410e2f:	48 89 29             	mov    QWORD PTR [rcx],rbp
  410e32:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  410e36:	48 89 cd             	mov    rbp,rcx
  410e39:	49 b8 50 0e 41 00 00 	movabs r8,0x410e50
  410e40:	00 00 00 
  410e43:	0f 05                	syscall 
  410e45:	0f 1f 00             	nop    DWORD PTR [rax]
  410e48:	eb 0d                	jmp    410e57 <cos_hw_alloc+0xb7>
  410e4a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410e50:	b9 00 00 00 00       	mov    ecx,0x0
  410e55:	eb 05                	jmp    410e5c <cos_hw_alloc+0xbc>
  410e57:	b9 01 00 00 00       	mov    ecx,0x1
  410e5c:	5d                   	pop    rbp
  410e5d:	5c                   	pop    rsp
  410e5e:	85 c0                	test   eax,eax
  410e60:	75 3e                	jne    410ea0 <cos_hw_alloc+0x100>

	return cap;
}
  410e62:	48 83 c4 10          	add    rsp,0x10
  410e66:	4c 89 e8             	mov    rax,r13
  410e69:	5b                   	pop    rbx
  410e6a:	41 5c                	pop    r12
  410e6c:	41 5d                	pop    r13
  410e6e:	41 5e                	pop    r14
  410e70:	5d                   	pop    rbp
  410e71:	c3                   	ret    
  410e72:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  410e78:	4c 89 e7             	mov    rdi,r12
  410e7b:	e8 60 bb ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  410e80:	85 c0                	test   eax,eax
  410e82:	75 38                	jne    410ebc <cos_hw_alloc+0x11c>
        __asm__ __volatile__("lock " PS_FAA_STR
  410e84:	b8 04 00 00 00       	mov    eax,0x4
  410e89:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  410e90:	49 89 44 24 30       	mov    QWORD PTR [r12+0x30],rax
  410e95:	e9 5c ff ff ff       	jmp    410df6 <cos_hw_alloc+0x56>
  410e9a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410ea0:	be 1c 00 00 00       	mov    esi,0x1c
  410ea5:	bf e8 e5 41 00       	mov    edi,0x41e5e8
  410eaa:	e8 21 92 ff ff       	call   40a0d0 <cos_print_str>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_HW_ACTIVATE, cap, bitmap, 0, 0)) BUG();
  410eaf:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410eb6:	00 00 00 00 
  410eba:	0f 0b                	ud2    
{ l->o = 0; }
  410ebc:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  410ec3:	00 00 00 00 00 
	if (!cap) return 0;
  410ec8:	eb 98                	jmp    410e62 <cos_hw_alloc+0xc2>
  410eca:	be 2f 00 00 00       	mov    esi,0x2f
  410ecf:	bf b8 e5 41 00       	mov    edi,0x41e5b8
  410ed4:	e8 f7 91 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci);
  410ed9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410ee0:	00 00 00 00 
  410ee4:	0f 0b                	ud2    
  410ee6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  410eed:	00 00 00 

0000000000410ef0 <cos_page_bump_allocn>:

void *
cos_page_bump_allocn(struct cos_compinfo *ci, size_t sz)
{
  410ef0:	f3 0f 1e fa          	endbr64 
	assert(sz % PAGE_SIZE == 0);
  410ef4:	f7 c6 ff 0f 00 00    	test   esi,0xfff
  410efa:	75 0a                	jne    410f06 <cos_page_bump_allocn+0x16>
	return (void *)__page_bump_alloc(ci, sz, PAGE_SIZE);
  410efc:	ba 00 10 00 00       	mov    edx,0x1000
  410f01:	e9 2a c2 ff ff       	jmp    40d130 <__page_bump_alloc>
{
  410f06:	55                   	push   rbp
  410f07:	be 2f 00 00 00       	mov    esi,0x2f
  410f0c:	bf 08 e6 41 00       	mov    edi,0x41e608
  410f11:	48 89 e5             	mov    rbp,rsp
  410f14:	e8 b7 91 ff ff       	call   40a0d0 <cos_print_str>
	assert(sz % PAGE_SIZE == 0);
  410f19:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410f20:	00 00 00 00 
  410f24:	0f 0b                	ud2    
  410f26:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  410f2d:	00 00 00 

0000000000410f30 <cos_page_bump_allocn_aligned>:
}

void *
cos_page_bump_allocn_aligned(struct cos_compinfo *ci, size_t sz, size_t align)
{
  410f30:	f3 0f 1e fa          	endbr64 
  410f34:	55                   	push   rbp
  410f35:	48 89 e5             	mov    rbp,rsp
	assert(sz % PAGE_SIZE == 0);
  410f38:	f7 c6 ff 0f 00 00    	test   esi,0xfff
  410f3e:	75 0e                	jne    410f4e <cos_page_bump_allocn_aligned+0x1e>
	assert(align % PAGE_SIZE == 0);
  410f40:	f7 c2 ff 0f 00 00    	test   edx,0xfff
  410f46:	75 22                	jne    410f6a <cos_page_bump_allocn_aligned+0x3a>

	return (void *)__page_bump_alloc(ci, sz, align);
}
  410f48:	5d                   	pop    rbp
	return (void *)__page_bump_alloc(ci, sz, align);
  410f49:	e9 e2 c1 ff ff       	jmp    40d130 <__page_bump_alloc>
  410f4e:	be 2f 00 00 00       	mov    esi,0x2f
  410f53:	bf 38 e6 41 00       	mov    edi,0x41e638
  410f58:	e8 73 91 ff ff       	call   40a0d0 <cos_print_str>
	assert(sz % PAGE_SIZE == 0);
  410f5d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410f64:	00 00 00 00 
  410f68:	0f 0b                	ud2    
  410f6a:	be 2f 00 00 00       	mov    esi,0x2f
  410f6f:	bf 68 e6 41 00       	mov    edi,0x41e668
  410f74:	e8 57 91 ff ff       	call   40a0d0 <cos_print_str>
	assert(align % PAGE_SIZE == 0);
  410f79:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410f80:	00 00 00 00 
  410f84:	0f 0b                	ud2    
  410f86:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  410f8d:	00 00 00 

0000000000410f90 <cos_page_bump_alloc>:

void *
cos_page_bump_alloc(struct cos_compinfo *ci)
{
  410f90:	f3 0f 1e fa          	endbr64 
	return (void *)__page_bump_alloc(ci, sz, PAGE_SIZE);
  410f94:	ba 00 10 00 00       	mov    edx,0x1000
  410f99:	be 00 10 00 00       	mov    esi,0x1000
  410f9e:	e9 8d c1 ff ff       	jmp    40d130 <__page_bump_alloc>
  410fa3:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  410faa:	00 00 00 00 
  410fae:	66 90                	xchg   ax,ax

0000000000410fb0 <cos_cap_cpy>:

}

capid_t
cos_cap_cpy(struct cos_compinfo *dstci, struct cos_compinfo *srcci, cap_t srcctype, capid_t srccap)
{
  410fb0:	f3 0f 1e fa          	endbr64 
  410fb4:	55                   	push   rbp
  410fb5:	48 89 e5             	mov    rbp,rsp
  410fb8:	41 57                	push   r15
  410fba:	41 56                	push   r14
  410fbc:	41 55                	push   r13
  410fbe:	41 54                	push   r12
  410fc0:	53                   	push   rbx
  410fc1:	48 83 ec 28          	sub    rsp,0x28
	capid_t dstcap;

	assert(srcci && dstci);
  410fc5:	48 85 f6             	test   rsi,rsi
  410fc8:	0f 84 7f 01 00 00    	je     41114d <cos_cap_cpy+0x19d>
  410fce:	49 89 fc             	mov    r12,rdi
  410fd1:	48 85 ff             	test   rdi,rdi
  410fd4:	0f 84 73 01 00 00    	je     41114d <cos_cap_cpy+0x19d>
  410fda:	49 89 f6             	mov    r14,rsi
  410fdd:	48 89 cb             	mov    rbx,rcx
  410fe0:	83 fa 14             	cmp    edx,0x14
  410fe3:	0f 87 27 01 00 00    	ja     411110 <cos_cap_cpy+0x160>
  410fe9:	b8 01 00 00 00       	mov    eax,0x1
  410fee:	89 d1                	mov    ecx,edx
		frontier = &ci->cap64_frontier[cos_cpuid()];
  410ff0:	4c 8d 47 38          	lea    r8,[rdi+0x38]
		break;
  410ff4:	41 bf 04 00 00 00    	mov    r15d,0x4
  410ffa:	48 d3 e0             	shl    rax,cl
  410ffd:	a9 da 81 1f 00       	test   eax,0x1f81da
  411002:	0f 84 b0 00 00 00    	je     4110b8 <cos_cap_cpy+0x108>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  411008:	49 8d 94 24 b0 00 00 	lea    rdx,[r12+0xb0]
  41100f:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  411010:	be 01 00 00 00       	mov    esi,0x1
  411015:	31 c9                	xor    ecx,ecx
  411017:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41101e:	00 00 
  411020:	48 89 c8             	mov    rax,rcx
  411023:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  411028:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  41102b:	84 c0                	test   al,al
  41102d:	74 f1                	je     411020 <cos_cap_cpy+0x70>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  41102f:	4d 8b 28             	mov    r13,QWORD PTR [r8]
  411032:	41 83 e5 03          	and    r13d,0x3
  411036:	0f 84 9c 00 00 00    	je     4110d8 <cos_cap_cpy+0x128>
        __asm__ __volatile__("lock " PS_FAA_STR
  41103c:	4c 89 f8             	mov    rax,r15
  41103f:	f0 49 0f c1 00       	lock xadd QWORD PTR [r8],rax
{ l->o = 0; }
  411044:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  41104b:	00 00 00 00 00 
        __asm__ __volatile__("lock " PS_FAA_STR
  411050:	49 89 c5             	mov    r13,rax

	dstcap = __capid_bump_alloc(dstci, srcctype);
	if (!dstcap) return 0;
  411053:	48 85 c0             	test   rax,rax
  411056:	74 4a                	je     4110a2 <cos_cap_cpy+0xf2>

	if (call_cap_op(srcci->captbl_cap, CAPTBL_OP_CPY, srccap, dstci->captbl_cap, dstcap, 0)) BUG();
  411058:	49 8b 46 08          	mov    rax,QWORD PTR [r14+0x8]
  41105c:	49 8b 74 24 08       	mov    rsi,QWORD PTR [r12+0x8]
  411061:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  411065:	31 d2                	xor    edx,edx
  411067:	4c 89 ef             	mov    rdi,r13
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  41106a:	83 c0 01             	add    eax,0x1
  41106d:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  411070:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411073:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411077:	48 89 cd             	mov    rbp,rcx
  41107a:	49 b8 90 10 41 00 00 	movabs r8,0x411090
  411081:	00 00 00 
  411084:	0f 05                	syscall 
  411086:	66 90                	xchg   ax,ax
  411088:	eb 0d                	jmp    411097 <cos_cap_cpy+0xe7>
  41108a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411090:	b9 00 00 00 00       	mov    ecx,0x0
  411095:	eb 05                	jmp    41109c <cos_cap_cpy+0xec>
  411097:	b9 01 00 00 00       	mov    ecx,0x1
  41109c:	5d                   	pop    rbp
  41109d:	5c                   	pop    rsp
  41109e:	85 c0                	test   eax,eax
  4110a0:	75 7e                	jne    411120 <cos_cap_cpy+0x170>

	return dstcap;
}
  4110a2:	48 83 c4 28          	add    rsp,0x28
  4110a6:	4c 89 e8             	mov    rax,r13
  4110a9:	5b                   	pop    rbx
  4110aa:	41 5c                	pop    r12
  4110ac:	41 5d                	pop    r13
  4110ae:	41 5e                	pop    r14
  4110b0:	41 5f                	pop    r15
  4110b2:	5d                   	pop    rbp
  4110b3:	c3                   	ret    
  4110b4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  4110b8:	a9 24 10 00 00       	test   eax,0x1024
  4110bd:	75 41                	jne    411100 <cos_cap_cpy+0x150>
  4110bf:	f6 c4 60             	test   ah,0x60
  4110c2:	74 4c                	je     411110 <cos_cap_cpy+0x160>
		frontier = &ci->cap32_frontier[cos_cpuid()];
  4110c4:	4c 8d 47 30          	lea    r8,[rdi+0x30]
		break;
  4110c8:	41 bf 02 00 00 00    	mov    r15d,0x2
  4110ce:	e9 35 ff ff ff       	jmp    411008 <cos_cap_cpy+0x58>
  4110d3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  4110d8:	4c 89 e7             	mov    rdi,r12
  4110db:	4c 89 45 b8          	mov    QWORD PTR [rbp-0x48],r8
  4110df:	e8 fc b8 ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  4110e4:	4c 8b 45 b8          	mov    r8,QWORD PTR [rbp-0x48]
  4110e8:	85 c0                	test   eax,eax
  4110ea:	75 50                	jne    41113c <cos_cap_cpy+0x18c>
  4110ec:	b8 04 00 00 00       	mov    eax,0x4
  4110f1:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  4110f8:	49 89 00             	mov    QWORD PTR [r8],rax
  4110fb:	e9 3c ff ff ff       	jmp    41103c <cos_cap_cpy+0x8c>
		frontier = &ci->cap16_frontier[cos_cpuid()];
  411100:	4c 8d 47 28          	lea    r8,[rdi+0x28]
		break;
  411104:	41 bf 01 00 00 00    	mov    r15d,0x1
  41110a:	e9 f9 fe ff ff       	jmp    411008 <cos_cap_cpy+0x58>
  41110f:	90                   	nop
  411110:	49 c7 c5 ff ff ff ff 	mov    r13,0xffffffffffffffff
  411117:	e9 3c ff ff ff       	jmp    411058 <cos_cap_cpy+0xa8>
  41111c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  411120:	be 1c 00 00 00       	mov    esi,0x1c
  411125:	bf c8 e6 41 00       	mov    edi,0x41e6c8
  41112a:	e8 a1 8f ff ff       	call   40a0d0 <cos_print_str>
	if (call_cap_op(srcci->captbl_cap, CAPTBL_OP_CPY, srccap, dstci->captbl_cap, dstcap, 0)) BUG();
  41112f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411136:	00 00 00 00 
  41113a:	0f 0b                	ud2    
{ l->o = 0; }
  41113c:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  411143:	00 00 00 00 00 
	if (!dstcap) return 0;
  411148:	e9 55 ff ff ff       	jmp    4110a2 <cos_cap_cpy+0xf2>
  41114d:	be 2f 00 00 00       	mov    esi,0x2f
  411152:	bf 98 e6 41 00       	mov    edi,0x41e698
  411157:	e8 74 8f ff ff       	call   40a0d0 <cos_print_str>
	assert(srcci && dstci);
  41115c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411163:	00 00 00 00 
  411167:	0f 0b                	ud2    
  411169:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000411170 <cos_cap_cpy_at>:

int
cos_cap_cpy_at(struct cos_compinfo *dstci, capid_t dstcap, struct cos_compinfo *srcci, capid_t srccap)
{
  411170:	f3 0f 1e fa          	endbr64 
  411174:	55                   	push   rbp
  411175:	48 89 e5             	mov    rbp,rsp
  411178:	41 54                	push   r12
  41117a:	53                   	push   rbx
  41117b:	48 83 ec 10          	sub    rsp,0x10
	assert(srcci && dstci);
  41117f:	48 85 d2             	test   rdx,rdx
  411182:	0f 84 84 00 00 00    	je     41120c <cos_cap_cpy_at+0x9c>
  411188:	49 89 f8             	mov    r8,rdi
  41118b:	48 85 ff             	test   rdi,rdi
  41118e:	74 7c                	je     41120c <cos_cap_cpy_at+0x9c>
  411190:	48 89 f7             	mov    rdi,rsi

	if (!dstcap) return 0;
  411193:	48 85 f6             	test   rsi,rsi
  411196:	74 4a                	je     4111e2 <cos_cap_cpy_at+0x72>

	if (call_cap_op(srcci->captbl_cap, CAPTBL_OP_CPY, srccap, dstci->captbl_cap, dstcap, 0)) BUG();
  411198:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  41119c:	48 89 cb             	mov    rbx,rcx
  41119f:	49 8b 70 08          	mov    rsi,QWORD PTR [r8+0x8]
  4111a3:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  4111a7:	31 d2                	xor    edx,edx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4111a9:	83 c0 01             	add    eax,0x1
  4111ac:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  4111af:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4111b2:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4111b6:	48 89 cd             	mov    rbp,rcx
  4111b9:	49 b8 d0 11 41 00 00 	movabs r8,0x4111d0
  4111c0:	00 00 00 
  4111c3:	0f 05                	syscall 
  4111c5:	0f 1f 00             	nop    DWORD PTR [rax]
  4111c8:	eb 0d                	jmp    4111d7 <cos_cap_cpy_at+0x67>
  4111ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4111d0:	b9 00 00 00 00       	mov    ecx,0x0
  4111d5:	eb 05                	jmp    4111dc <cos_cap_cpy_at+0x6c>
  4111d7:	b9 01 00 00 00       	mov    ecx,0x1
  4111dc:	5d                   	pop    rbp
  4111dd:	5c                   	pop    rsp
  4111de:	85 c0                	test   eax,eax
  4111e0:	75 0e                	jne    4111f0 <cos_cap_cpy_at+0x80>

	return 0;
}
  4111e2:	48 83 c4 10          	add    rsp,0x10
  4111e6:	31 c0                	xor    eax,eax
  4111e8:	5b                   	pop    rbx
  4111e9:	41 5c                	pop    r12
  4111eb:	5d                   	pop    rbp
  4111ec:	c3                   	ret    
  4111ed:	0f 1f 00             	nop    DWORD PTR [rax]
  4111f0:	be 1c 00 00 00       	mov    esi,0x1c
  4111f5:	bf 18 e7 41 00       	mov    edi,0x41e718
  4111fa:	e8 d1 8e ff ff       	call   40a0d0 <cos_print_str>
	if (call_cap_op(srcci->captbl_cap, CAPTBL_OP_CPY, srccap, dstci->captbl_cap, dstcap, 0)) BUG();
  4111ff:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411206:	00 00 00 00 
  41120a:	0f 0b                	ud2    
  41120c:	be 2f 00 00 00       	mov    esi,0x2f
  411211:	bf e8 e6 41 00       	mov    edi,0x41e6e8
  411216:	e8 b5 8e ff ff       	call   40a0d0 <cos_print_str>
	assert(srcci && dstci);
  41121b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411222:	00 00 00 00 
  411226:	0f 0b                	ud2    
  411228:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41122f:	00 

0000000000411230 <cos_thd_switch>:

/**************** [Kernel Object Operations] ****************/

int
cos_thd_switch(thdcap_t c)
{
  411230:	f3 0f 1e fa          	endbr64 
  411234:	55                   	push   rbp
  411235:	31 d2                	xor    edx,edx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411237:	8d 47 01             	lea    eax,[rdi+0x1]
  41123a:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  41123d:	48 89 d6             	mov    rsi,rdx
  411240:	48 89 d7             	mov    rdi,rdx
  411243:	48 89 e5             	mov    rbp,rsp
  411246:	41 54                	push   r12
  411248:	53                   	push   rbx
  411249:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  41124d:	48 89 d3             	mov    rbx,rdx
  411250:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411253:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411257:	48 89 cd             	mov    rbp,rcx
  41125a:	49 b8 70 12 41 00 00 	movabs r8,0x411270
  411261:	00 00 00 
  411264:	0f 05                	syscall 
  411266:	66 90                	xchg   ax,ax
  411268:	eb 0d                	jmp    411277 <cos_thd_switch+0x47>
  41126a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411270:	b9 00 00 00 00       	mov    ecx,0x0
  411275:	eb 05                	jmp    41127c <cos_thd_switch+0x4c>
  411277:	b9 01 00 00 00       	mov    ecx,0x1
  41127c:	5d                   	pop    rbp
  41127d:	5c                   	pop    rsp
	return call_cap_op(c, 0, 0, 0, 0, 0);
}
  41127e:	5b                   	pop    rbx
  41127f:	41 5c                	pop    r12
  411281:	5d                   	pop    rbp
  411282:	c3                   	ret    
  411283:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41128a:	00 00 00 00 
  41128e:	66 90                	xchg   ax,ax

0000000000411290 <cos_thd_wakeup>:

int
cos_thd_wakeup(thdcap_t thd, tcap_t tc, tcap_prio_t prio, tcap_res_t res)
{
  411290:	f3 0f 1e fa          	endbr64 
  411294:	55                   	push   rbp
  411295:	49 89 fa             	mov    r10,rdi
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411298:	c1 e6 10             	shl    esi,0x10
  41129b:	48 89 d7             	mov    rdi,rdx
	cap_no += op;
  41129e:	8d 86 2a 00 01 00    	lea    eax,[rsi+0x1002a]
	return call_cap_op(tc, CAPTBL_OP_TCAP_WAKEUP, thd, (prio << 32) >> 32, prio >> 32, res);
  4112a4:	48 c1 ef 20          	shr    rdi,0x20
  4112a8:	89 d6                	mov    esi,edx
{
  4112aa:	48 89 e5             	mov    rbp,rsp
  4112ad:	41 55                	push   r13
  4112af:	49 89 cd             	mov    r13,rcx
  4112b2:	41 54                	push   r12
	__asm__ __volatile__(
  4112b4:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  4112b8:	4c 89 ea             	mov    rdx,r13
  4112bb:	53                   	push   rbx
  4112bc:	4c 89 d3             	mov    rbx,r10
  4112bf:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4112c2:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4112c6:	48 89 cd             	mov    rbp,rcx
  4112c9:	49 b8 e0 12 41 00 00 	movabs r8,0x4112e0
  4112d0:	00 00 00 
  4112d3:	0f 05                	syscall 
  4112d5:	0f 1f 00             	nop    DWORD PTR [rax]
  4112d8:	eb 0d                	jmp    4112e7 <cos_thd_wakeup+0x57>
  4112da:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4112e0:	b9 00 00 00 00       	mov    ecx,0x0
  4112e5:	eb 05                	jmp    4112ec <cos_thd_wakeup+0x5c>
  4112e7:	b9 01 00 00 00       	mov    ecx,0x1
  4112ec:	5d                   	pop    rbp
  4112ed:	5c                   	pop    rsp
}
  4112ee:	5b                   	pop    rbx
  4112ef:	41 5c                	pop    r12
  4112f1:	41 5d                	pop    r13
  4112f3:	5d                   	pop    rbp
  4112f4:	c3                   	ret    
  4112f5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4112fc:	00 00 00 00 

0000000000411300 <cos_sched_sync>:

sched_tok_t
cos_sched_sync(void)
{
  411300:	f3 0f 1e fa          	endbr64 
        __asm__ __volatile__("lock " PS_FAA_STR
  411304:	b8 01 00 00 00       	mov    eax,0x1
  411309:	f0 48 0f c1 05 ae f7 	lock xadd QWORD PTR [rip+0x18f7ae],rax        # 5a0ac0 <stok.1>
  411310:	18 00 
	static sched_tok_t stok[NUM_CPU] CACHE_ALIGNED;

	return ps_faa((unsigned long *)&stok[cos_cpuid()], 1);
}
  411312:	c3                   	ret    
  411313:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41131a:	00 00 00 00 
  41131e:	66 90                	xchg   ax,ax

0000000000411320 <cos_switch>:

int
cos_switch(thdcap_t c, tcap_t tc, tcap_prio_t prio, tcap_time_t timeout, arcvcap_t rcv, sched_tok_t stok)
{
  411320:	f3 0f 1e fa          	endbr64 
  411324:	55                   	push   rbp
  411325:	49 89 fa             	mov    r10,rdi
  411328:	49 89 f3             	mov    r11,rsi
  41132b:	4c 89 c7             	mov    rdi,r8
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  41132e:	41 83 c2 01          	add    r10d,0x1
  411332:	48 89 d6             	mov    rsi,rdx
  411335:	48 89 ca             	mov    rdx,rcx
  411338:	41 c1 e2 10          	shl    r10d,0x10
  41133c:	48 89 e5             	mov    rbp,rsp
  41133f:	41 54                	push   r12
	cap_no += op;
  411341:	43 8d 04 1a          	lea    eax,[r10+r11*1]
  411345:	53                   	push   rbx
	__asm__ __volatile__(
  411346:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
#if defined(__x86_64__)
	return call_cap_op(c, tc, stok, prio, rcv, timeout);
  41134a:	44 89 cb             	mov    ebx,r9d
  41134d:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411350:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411354:	48 89 cd             	mov    rbp,rcx
  411357:	49 b8 70 13 41 00 00 	movabs r8,0x411370
  41135e:	00 00 00 
  411361:	0f 05                	syscall 
  411363:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  411368:	eb 0d                	jmp    411377 <cos_switch+0x57>
  41136a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411370:	b9 00 00 00 00       	mov    ecx,0x0
  411375:	eb 05                	jmp    41137c <cos_switch+0x5c>
  411377:	b9 01 00 00 00       	mov    ecx,0x1
  41137c:	5d                   	pop    rbp
  41137d:	5c                   	pop    rsp
#else
	return call_cap_op(c, (stok >> 16), tc << 16 | rcv, (prio << 32) >> 32,
	                   (((prio << 16) >> 48) << 16) | ((stok << 16) >> 16), timeout);
#endif
}
  41137e:	5b                   	pop    rbx
  41137f:	41 5c                	pop    r12
  411381:	5d                   	pop    rbp
  411382:	c3                   	ret    
  411383:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41138a:	00 00 00 00 
  41138e:	66 90                	xchg   ax,ax

0000000000411390 <cos_sched_asnd>:

int
cos_sched_asnd(asndcap_t snd, tcap_time_t timeout, arcvcap_t srcv, sched_tok_t stok)
{
  411390:	f3 0f 1e fa          	endbr64 
  411394:	55                   	push   rbp
  411395:	49 89 d2             	mov    r10,rdx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411398:	8d 47 01             	lea    eax,[rdi+0x1]
	__asm__ __volatile__(
  41139b:	31 d2                	xor    edx,edx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  41139d:	c1 e0 10             	shl    eax,0x10
  4113a0:	48 89 e5             	mov    rbp,rsp
  4113a3:	41 55                	push   r13
  4113a5:	49 89 f5             	mov    r13,rsi
	return call_cap_op(snd, 0, srcv, stok, timeout, 0);
  4113a8:	89 ce                	mov    esi,ecx
{
  4113aa:	41 54                	push   r12
	__asm__ __volatile__(
  4113ac:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  4113b0:	4c 89 ef             	mov    rdi,r13
  4113b3:	53                   	push   rbx
  4113b4:	4c 89 d3             	mov    rbx,r10
  4113b7:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4113ba:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4113be:	48 89 cd             	mov    rbp,rcx
  4113c1:	49 b8 d8 13 41 00 00 	movabs r8,0x4113d8
  4113c8:	00 00 00 
  4113cb:	0f 05                	syscall 
  4113cd:	0f 1f 00             	nop    DWORD PTR [rax]
  4113d0:	eb 0d                	jmp    4113df <cos_sched_asnd+0x4f>
  4113d2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4113d8:	b9 00 00 00 00       	mov    ecx,0x0
  4113dd:	eb 05                	jmp    4113e4 <cos_sched_asnd+0x54>
  4113df:	b9 01 00 00 00       	mov    ecx,0x1
  4113e4:	5d                   	pop    rbp
  4113e5:	5c                   	pop    rsp
}
  4113e6:	5b                   	pop    rbx
  4113e7:	41 5c                	pop    r12
  4113e9:	41 5d                	pop    r13
  4113eb:	5d                   	pop    rbp
  4113ec:	c3                   	ret    
  4113ed:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004113f0 <cos_asnd>:

int
cos_asnd(asndcap_t snd, int yield)
{
  4113f0:	f3 0f 1e fa          	endbr64 
  4113f4:	55                   	push   rbp
  4113f5:	48 63 d6             	movsxd rdx,esi
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4113f8:	8d 47 01             	lea    eax,[rdi+0x1]
	__asm__ __volatile__(
  4113fb:	31 f6                	xor    esi,esi
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4113fd:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  411400:	48 89 f7             	mov    rdi,rsi
  411403:	48 89 e5             	mov    rbp,rsp
  411406:	41 54                	push   r12
  411408:	53                   	push   rbx
  411409:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  41140d:	48 89 f3             	mov    rbx,rsi
  411410:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411413:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411417:	48 89 cd             	mov    rbp,rcx
  41141a:	49 b8 30 14 41 00 00 	movabs r8,0x411430
  411421:	00 00 00 
  411424:	0f 05                	syscall 
  411426:	66 90                	xchg   ax,ax
  411428:	eb 0d                	jmp    411437 <cos_asnd+0x47>
  41142a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411430:	b9 00 00 00 00       	mov    ecx,0x0
  411435:	eb 05                	jmp    41143c <cos_asnd+0x4c>
  411437:	b9 01 00 00 00       	mov    ecx,0x1
  41143c:	5d                   	pop    rbp
  41143d:	5c                   	pop    rsp
	return call_cap_op(snd, 0, 0, 0, 0, yield);
}
  41143e:	5b                   	pop    rbx
  41143f:	41 5c                	pop    r12
  411441:	5d                   	pop    rbp
  411442:	c3                   	ret    
  411443:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41144a:	00 00 00 00 
  41144e:	66 90                	xchg   ax,ax

0000000000411450 <cos_sched_rcv>:

int
cos_sched_rcv(arcvcap_t rcv, rcv_flags_t flags, tcap_time_t timeout,
	      int *rcvd, thdid_t *thdid, int *blocked, cycles_t *cycles, tcap_time_t *thd_timeout)
{
  411450:	f3 0f 1e fa          	endbr64 
  411454:	55                   	push   rbp
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411455:	8d 47 01             	lea    eax,[rdi+0x1]
	__asm__ __volatile__(
  411458:	31 ff                	xor    edi,edi
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  41145a:	c1 e0 10             	shl    eax,0x10
  41145d:	48 89 e5             	mov    rbp,rsp
  411460:	41 57                	push   r15
  411462:	49 89 cf             	mov    r15,rcx
  411465:	41 56                	push   r14
	__asm__ __volatile__(
  411467:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  41146b:	4d 89 c6             	mov    r14,r8
  41146e:	41 55                	push   r13
  411470:	4d 89 cd             	mov    r13,r9
  411473:	41 54                	push   r12
  411475:	53                   	push   rbx
  411476:	89 f3                	mov    ebx,esi
  411478:	48 89 d6             	mov    rsi,rdx
  41147b:	48 89 fa             	mov    rdx,rdi
  41147e:	49 89 da             	mov    r10,rbx
  411481:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411484:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411488:	48 89 cd             	mov    rbp,rcx
  41148b:	49 b8 a0 14 41 00 00 	movabs r8,0x4114a0
  411492:	00 00 00 
  411495:	0f 05                	syscall 
  411497:	90                   	nop
  411498:	eb 0f                	jmp    4114a9 <cos_sched_rcv+0x59>
  41149a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4114a0:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  4114a7:	eb 07                	jmp    4114b0 <cos_sched_rcv+0x60>
  4114a9:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  4114b0:	5d                   	pop    rbp
  4114b1:	5c                   	pop    rsp
  4114b2:	48 8b 55 18          	mov    rdx,QWORD PTR [rbp+0x18]
  4114b6:	48 89 1a             	mov    QWORD PTR [rdx],rbx
	unsigned long cyc       = 0;
	int           ret;

	ret = call_cap_retvals_asm(rcv, 0, flags, timeout, 0, 0, &thd_state, &cyc, thd_timeout);

	*blocked = (int)(thd_state >> (sizeof(thd_state) * 8 - 1));
  4114b9:	48 89 f2             	mov    rdx,rsi
	*thdid   = (thdid_t)(thd_state & ((1 << (sizeof(unsigned short int) * 8)) - 1));
  4114bc:	81 e6 ff ff 00 00    	and    esi,0xffff
	*blocked = (int)(thd_state >> (sizeof(thd_state) * 8 - 1));
  4114c2:	48 c1 ea 3f          	shr    rdx,0x3f
  4114c6:	41 89 55 00          	mov    DWORD PTR [r13+0x0],edx
	*cycles  = cyc;
  4114ca:	48 8b 55 10          	mov    rdx,QWORD PTR [rbp+0x10]
	*thdid   = (thdid_t)(thd_state & ((1 << (sizeof(unsigned short int) * 8)) - 1));
  4114ce:	49 89 36             	mov    QWORD PTR [r14],rsi
	*cycles  = cyc;
  4114d1:	48 89 3a             	mov    QWORD PTR [rdx],rdi

	if (ret >= 0 && flags & RCV_ALL_PENDING) {
  4114d4:	85 c0                	test   eax,eax
  4114d6:	78 10                	js     4114e8 <cos_sched_rcv+0x98>
  4114d8:	41 83 e2 02          	and    r10d,0x2
  4114dc:	74 0a                	je     4114e8 <cos_sched_rcv+0x98>
		*rcvd = (ret >> 1);
  4114de:	89 c2                	mov    edx,eax
		ret &= 1;
  4114e0:	83 e0 01             	and    eax,0x1
		*rcvd = (ret >> 1);
  4114e3:	d1 fa                	sar    edx,1
  4114e5:	41 89 17             	mov    DWORD PTR [r15],edx
	}

	return ret;
}
  4114e8:	5b                   	pop    rbx
  4114e9:	41 5c                	pop    r12
  4114eb:	41 5d                	pop    r13
  4114ed:	41 5e                	pop    r14
  4114ef:	41 5f                	pop    r15
  4114f1:	5d                   	pop    rbp
  4114f2:	c3                   	ret    
  4114f3:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4114fa:	00 00 00 00 
  4114fe:	66 90                	xchg   ax,ax

0000000000411500 <cos_rcv>:

int
cos_rcv(arcvcap_t rcv, rcv_flags_t flags, int *rcvd)
{
  411500:	f3 0f 1e fa          	endbr64 
  411504:	55                   	push   rbp
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411505:	8d 47 01             	lea    eax,[rdi+0x1]
	__asm__ __volatile__(
  411508:	31 ff                	xor    edi,edi
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  41150a:	c1 e0 10             	shl    eax,0x10
  41150d:	48 89 e5             	mov    rbp,rsp
  411510:	41 55                	push   r13
  411512:	49 89 d5             	mov    r13,rdx
	__asm__ __volatile__(
  411515:	48 89 fa             	mov    rdx,rdi
  411518:	41 54                	push   r12
  41151a:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  41151e:	53                   	push   rbx
  41151f:	89 f3                	mov    ebx,esi
  411521:	48 89 fe             	mov    rsi,rdi
  411524:	49 89 da             	mov    r10,rbx
  411527:	48 83 ec 18          	sub    rsp,0x18
  41152b:	48 89 29             	mov    QWORD PTR [rcx],rbp
  41152e:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411532:	48 89 cd             	mov    rbp,rcx
  411535:	49 b8 50 15 41 00 00 	movabs r8,0x411550
  41153c:	00 00 00 
  41153f:	0f 05                	syscall 
  411541:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  411548:	eb 0f                	jmp    411559 <cos_rcv+0x59>
  41154a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411550:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  411557:	eb 07                	jmp    411560 <cos_rcv+0x60>
  411559:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  411560:	5d                   	pop    rbp
  411561:	5c                   	pop    rsp
	*thdid   = (thdid_t)(thd_state & ((1 << (sizeof(unsigned short int) * 8)) - 1));
  411562:	0f b7 f6             	movzx  esi,si
	if (ret >= 0 && flags & RCV_ALL_PENDING) {
  411565:	85 c0                	test   eax,eax
  411567:	78 06                	js     41156f <cos_rcv+0x6f>
  411569:	41 83 e2 02          	and    r10d,0x2
  41156d:	75 11                	jne    411580 <cos_rcv+0x80>
	cycles_t    cyc;
	int         ret;
	tcap_time_t thd_timeout;

	ret = cos_sched_rcv(rcv, flags, 0, rcvd, &tid, &blocked, &cyc, &thd_timeout);
	assert(tid == 0);
  41156f:	48 85 f6             	test   rsi,rsi
  411572:	75 1c                	jne    411590 <cos_rcv+0x90>

	return ret;
}
  411574:	48 83 c4 18          	add    rsp,0x18
  411578:	5b                   	pop    rbx
  411579:	41 5c                	pop    r12
  41157b:	41 5d                	pop    r13
  41157d:	5d                   	pop    rbp
  41157e:	c3                   	ret    
  41157f:	90                   	nop
		*rcvd = (ret >> 1);
  411580:	89 c2                	mov    edx,eax
		ret &= 1;
  411582:	83 e0 01             	and    eax,0x1
		*rcvd = (ret >> 1);
  411585:	d1 fa                	sar    edx,1
  411587:	41 89 55 00          	mov    DWORD PTR [r13+0x0],edx
	assert(tid == 0);
  41158b:	48 85 f6             	test   rsi,rsi
  41158e:	74 e4                	je     411574 <cos_rcv+0x74>
  411590:	be 2f 00 00 00       	mov    esi,0x2f
  411595:	bf 38 e7 41 00       	mov    edi,0x41e738
  41159a:	e8 31 8b ff ff       	call   40a0d0 <cos_print_str>
  41159f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4115a6:	00 00 00 00 
  4115aa:	0f 0b                	ud2    
  4115ac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

00000000004115b0 <cos_mem_aliasn_aligned>:

vaddr_t
cos_mem_aliasn_aligned(struct cos_compinfo *dstci, struct cos_compinfo *srcci, vaddr_t src, size_t sz, size_t align, unsigned long perm_flags)
{
  4115b0:	f3 0f 1e fa          	endbr64 
  4115b4:	55                   	push   rbp
  4115b5:	48 89 e5             	mov    rbp,rsp
  4115b8:	41 57                	push   r15
  4115ba:	41 56                	push   r14
  4115bc:	41 55                	push   r13
  4115be:	41 54                	push   r12
  4115c0:	53                   	push   rbx
  4115c1:	48 83 ec 28          	sub    rsp,0x28
  4115c5:	48 89 55 b0          	mov    QWORD PTR [rbp-0x50],rdx
  4115c9:	48 89 4d b8          	mov    QWORD PTR [rbp-0x48],rcx
	size_t i;
	vaddr_t dst, first_dst;

	assert(srcci && dstci);
  4115cd:	48 85 f6             	test   rsi,rsi
  4115d0:	0f 84 f3 00 00 00    	je     4116c9 <cos_mem_aliasn_aligned+0x119>
  4115d6:	49 89 fd             	mov    r13,rdi
  4115d9:	48 85 ff             	test   rdi,rdi
  4115dc:	0f 84 e7 00 00 00    	je     4116c9 <cos_mem_aliasn_aligned+0x119>
	assert(sz && (sz % PAGE_SIZE == 0));
  4115e2:	48 85 c9             	test   rcx,rcx
  4115e5:	0f 84 c2 00 00 00    	je     4116ad <cos_mem_aliasn_aligned+0xfd>
  4115eb:	f7 c1 ff 0f 00 00    	test   ecx,0xfff
  4115f1:	0f 85 b6 00 00 00    	jne    4116ad <cos_mem_aliasn_aligned+0xfd>
  4115f7:	4c 89 c2             	mov    rdx,r8
	assert(align % PAGE_SIZE == 0);
  4115fa:	41 f7 c0 ff 0f 00 00 	test   r8d,0xfff
  411601:	0f 85 de 00 00 00    	jne    4116e5 <cos_mem_aliasn_aligned+0x135>
  411607:	49 89 f6             	mov    r14,rsi
  41160a:	48 89 ce             	mov    rsi,rcx
  41160d:	4c 89 cb             	mov    rbx,r9

	dst = __page_bump_valloc(dstci, sz, align);
  411610:	e8 0b b9 ff ff       	call   40cf20 <__page_bump_valloc>
  411615:	49 89 c7             	mov    r15,rax
	if (unlikely(!dst)) return 0;
  411618:	48 85 c0             	test   rax,rax
  41161b:	0f 84 87 00 00 00    	je     4116a8 <cos_mem_aliasn_aligned+0xf8>
	first_dst = dst;

	for (i = 0; i < sz; i += PAGE_SIZE, src += PAGE_SIZE, dst += PAGE_SIZE) {
  411621:	45 31 d2             	xor    r10d,r10d
  411624:	48 89 da             	mov    rdx,rbx
  411627:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41162e:	00 00 
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411630:	41 8b 06             	mov    eax,DWORD PTR [r14]
	__asm__ __volatile__(
  411633:	48 8b 5d b0          	mov    rbx,QWORD PTR [rbp-0x50]
  411637:	4b 8d 3c 3a          	lea    rdi,[r10+r15*1]
  41163b:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  41163f:	49 8b 75 00          	mov    rsi,QWORD PTR [r13+0x0]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411643:	83 c0 01             	add    eax,0x1
	__asm__ __volatile__(
  411646:	4c 01 d3             	add    rbx,r10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411649:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  41164c:	48 89 29             	mov    QWORD PTR [rcx],rbp
  41164f:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411653:	48 89 cd             	mov    rbp,rcx
  411656:	49 b8 70 16 41 00 00 	movabs r8,0x411670
  41165d:	00 00 00 
  411660:	0f 05                	syscall 
  411662:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411668:	eb 0d                	jmp    411677 <cos_mem_aliasn_aligned+0xc7>
  41166a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411670:	b9 00 00 00 00       	mov    ecx,0x0
  411675:	eb 05                	jmp    41167c <cos_mem_aliasn_aligned+0xcc>
  411677:	b9 01 00 00 00       	mov    ecx,0x1
  41167c:	5d                   	pop    rbp
  41167d:	5c                   	pop    rsp
		if (call_cap_op(srcci->pgtbl_cap, CAPTBL_OP_CPY, src, dstci->pgtbl_cap, dst, perm_flags)) return 0;
  41167e:	85 c0                	test   eax,eax
  411680:	75 26                	jne    4116a8 <cos_mem_aliasn_aligned+0xf8>
	for (i = 0; i < sz; i += PAGE_SIZE, src += PAGE_SIZE, dst += PAGE_SIZE) {
  411682:	49 81 c2 00 10 00 00 	add    r10,0x1000
  411689:	4c 39 55 b8          	cmp    QWORD PTR [rbp-0x48],r10
  41168d:	77 a1                	ja     411630 <cos_mem_aliasn_aligned+0x80>
	}

	return first_dst;
}
  41168f:	48 83 c4 28          	add    rsp,0x28
  411693:	4c 89 f8             	mov    rax,r15
  411696:	5b                   	pop    rbx
  411697:	41 5c                	pop    r12
  411699:	41 5d                	pop    r13
  41169b:	41 5e                	pop    r14
  41169d:	41 5f                	pop    r15
  41169f:	5d                   	pop    rbp
  4116a0:	c3                   	ret    
  4116a1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	if (unlikely(!dst)) return 0;
  4116a8:	45 31 ff             	xor    r15d,r15d
  4116ab:	eb e2                	jmp    41168f <cos_mem_aliasn_aligned+0xdf>
  4116ad:	be 2f 00 00 00       	mov    esi,0x2f
  4116b2:	bf 98 e7 41 00       	mov    edi,0x41e798
  4116b7:	e8 14 8a ff ff       	call   40a0d0 <cos_print_str>
	assert(sz && (sz % PAGE_SIZE == 0));
  4116bc:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4116c3:	00 00 00 00 
  4116c7:	0f 0b                	ud2    
  4116c9:	be 2f 00 00 00       	mov    esi,0x2f
  4116ce:	bf 68 e7 41 00       	mov    edi,0x41e768
  4116d3:	e8 f8 89 ff ff       	call   40a0d0 <cos_print_str>
	assert(srcci && dstci);
  4116d8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4116df:	00 00 00 00 
  4116e3:	0f 0b                	ud2    
  4116e5:	be 2f 00 00 00       	mov    esi,0x2f
  4116ea:	bf c8 e7 41 00       	mov    edi,0x41e7c8
  4116ef:	e8 dc 89 ff ff       	call   40a0d0 <cos_print_str>
	assert(align % PAGE_SIZE == 0);
  4116f4:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4116fb:	00 00 00 00 
  4116ff:	0f 0b                	ud2    
  411701:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  411708:	00 00 00 00 
  41170c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000411710 <cos_mem_aliasn>:

vaddr_t
cos_mem_aliasn(struct cos_compinfo *dstci, struct cos_compinfo *srcci, vaddr_t src, size_t sz, unsigned long perm_flags)
{
  411710:	f3 0f 1e fa          	endbr64 
	return cos_mem_aliasn_aligned(dstci, srcci, src, sz, PAGE_SIZE, perm_flags);
  411714:	4d 89 c1             	mov    r9,r8
  411717:	41 b8 00 10 00 00    	mov    r8d,0x1000
  41171d:	e9 8e fe ff ff       	jmp    4115b0 <cos_mem_aliasn_aligned>
  411722:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  411729:	00 00 00 00 
  41172d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000411730 <cos_mem_alias>:
}

vaddr_t
cos_mem_alias(struct cos_compinfo *dstci, struct cos_compinfo *srcci, vaddr_t src, unsigned long perm_flags)
{
  411730:	f3 0f 1e fa          	endbr64 
  411734:	49 89 c9             	mov    r9,rcx
	return cos_mem_aliasn_aligned(dstci, srcci, src, sz, PAGE_SIZE, perm_flags);
  411737:	41 b8 00 10 00 00    	mov    r8d,0x1000
  41173d:	b9 00 10 00 00       	mov    ecx,0x1000
  411742:	e9 69 fe ff ff       	jmp    4115b0 <cos_mem_aliasn_aligned>
  411747:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41174e:	00 00 

0000000000411750 <cos_mem_alias_at>:
	return cos_mem_aliasn(dstci, srcci, src, PAGE_SIZE, perm_flags);
}

int
cos_mem_alias_at(struct cos_compinfo *dstci, vaddr_t dst, struct cos_compinfo *srcci, vaddr_t src, unsigned long perm_flags)
{
  411750:	f3 0f 1e fa          	endbr64 
  411754:	55                   	push   rbp
  411755:	48 89 d0             	mov    rax,rdx
  411758:	48 89 e5             	mov    rbp,rsp
  41175b:	41 54                	push   r12
  41175d:	53                   	push   rbx
  41175e:	48 83 ec 10          	sub    rsp,0x10
	assert(srcci && dstci);
  411762:	48 85 d2             	test   rdx,rdx
  411765:	74 7d                	je     4117e4 <cos_mem_alias_at+0x94>
  411767:	49 89 f9             	mov    r9,rdi
  41176a:	48 85 ff             	test   rdi,rdi
  41176d:	74 75                	je     4117e4 <cos_mem_alias_at+0x94>

	if (call_cap_op(srcci->pgtbl_cap, CAPTBL_OP_CPY, src, dstci->pgtbl_cap, dst, perm_flags)) BUG();
  41176f:	48 8b 00             	mov    rax,QWORD PTR [rax]
  411772:	48 89 f7             	mov    rdi,rsi
  411775:	48 89 cb             	mov    rbx,rcx
  411778:	49 8b 31             	mov    rsi,QWORD PTR [r9]
  41177b:	4c 89 c2             	mov    rdx,r8
  41177e:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411782:	83 c0 01             	add    eax,0x1
  411785:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  411788:	48 89 29             	mov    QWORD PTR [rcx],rbp
  41178b:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  41178f:	48 89 cd             	mov    rbp,rcx
  411792:	49 b8 a8 17 41 00 00 	movabs r8,0x4117a8
  411799:	00 00 00 
  41179c:	0f 05                	syscall 
  41179e:	66 90                	xchg   ax,ax
  4117a0:	eb 0d                	jmp    4117af <cos_mem_alias_at+0x5f>
  4117a2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4117a8:	b9 00 00 00 00       	mov    ecx,0x0
  4117ad:	eb 05                	jmp    4117b4 <cos_mem_alias_at+0x64>
  4117af:	b9 01 00 00 00       	mov    ecx,0x1
  4117b4:	5d                   	pop    rbp
  4117b5:	5c                   	pop    rsp
  4117b6:	85 c0                	test   eax,eax
  4117b8:	75 0e                	jne    4117c8 <cos_mem_alias_at+0x78>

	return 0;
}
  4117ba:	48 83 c4 10          	add    rsp,0x10
  4117be:	31 c0                	xor    eax,eax
  4117c0:	5b                   	pop    rbx
  4117c1:	41 5c                	pop    r12
  4117c3:	5d                   	pop    rbp
  4117c4:	c3                   	ret    
  4117c5:	0f 1f 00             	nop    DWORD PTR [rax]
  4117c8:	be 1c 00 00 00       	mov    esi,0x1c
  4117cd:	bf 28 e8 41 00       	mov    edi,0x41e828
  4117d2:	e8 f9 88 ff ff       	call   40a0d0 <cos_print_str>
	if (call_cap_op(srcci->pgtbl_cap, CAPTBL_OP_CPY, src, dstci->pgtbl_cap, dst, perm_flags)) BUG();
  4117d7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4117de:	00 00 00 00 
  4117e2:	0f 0b                	ud2    
  4117e4:	be 2f 00 00 00       	mov    esi,0x2f
  4117e9:	bf f8 e7 41 00       	mov    edi,0x41e7f8
  4117ee:	e8 dd 88 ff ff       	call   40a0d0 <cos_print_str>
	assert(srcci && dstci);
  4117f3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4117fa:	00 00 00 00 
  4117fe:	0f 0b                	ud2    

0000000000411800 <cos_mem_alias_atn>:

int
cos_mem_alias_atn(struct cos_compinfo *dstci, vaddr_t dst, struct cos_compinfo *srcci, vaddr_t src, size_t sz, unsigned long perm_flags)
{
  411800:	f3 0f 1e fa          	endbr64 
  411804:	55                   	push   rbp
  411805:	48 89 e5             	mov    rbp,rsp
  411808:	41 57                	push   r15
  41180a:	41 56                	push   r14
  41180c:	49 89 d6             	mov    r14,rdx
  41180f:	41 55                	push   r13
  411811:	41 54                	push   r12
  411813:	53                   	push   rbx
  411814:	48 83 ec 18          	sub    rsp,0x18
	size_t i;
	size_t npages;

	assert(srcci && dstci);
  411818:	48 85 d2             	test   rdx,rdx
  41181b:	0f 84 c0 00 00 00    	je     4118e1 <cos_mem_alias_atn+0xe1>
  411821:	49 89 ff             	mov    r15,rdi
  411824:	48 85 ff             	test   rdi,rdi
  411827:	0f 84 b4 00 00 00    	je     4118e1 <cos_mem_alias_atn+0xe1>
	assert(sz % PAGE_SIZE == 0);
  41182d:	41 f7 c0 ff 0f 00 00 	test   r8d,0xfff
  411834:	0f 85 c3 00 00 00    	jne    4118fd <cos_mem_alias_atn+0xfd>

	npages = sz / PAGE_SIZE;
	for (i=0; i < npages; i++) {
  41183a:	49 c1 e8 0c          	shr    r8,0xc
  41183e:	0f 84 8c 00 00 00    	je     4118d0 <cos_mem_alias_atn+0xd0>
  411844:	49 89 f5             	mov    r13,rsi
  411847:	49 c1 e0 0c          	shl    r8,0xc
  41184b:	48 89 cb             	mov    rbx,rcx
  41184e:	4c 89 ca             	mov    rdx,r9
  411851:	4d 8d 14 08          	lea    r10,[r8+rcx*1]
  411855:	49 29 cd             	sub    r13,rcx
  411858:	eb 12                	jmp    41186c <cos_mem_alias_atn+0x6c>
  41185a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411860:	48 81 c3 00 10 00 00 	add    rbx,0x1000
  411867:	49 39 da             	cmp    r10,rbx
  41186a:	74 64                	je     4118d0 <cos_mem_alias_atn+0xd0>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  41186c:	41 8b 06             	mov    eax,DWORD PTR [r14]
	__asm__ __volatile__(
  41186f:	49 8b 37             	mov    rsi,QWORD PTR [r15]
  411872:	49 8d 7c 1d 00       	lea    rdi,[r13+rbx*1+0x0]
  411877:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  41187b:	83 c0 01             	add    eax,0x1
  41187e:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  411881:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411884:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411888:	48 89 cd             	mov    rbp,rcx
  41188b:	49 b8 a0 18 41 00 00 	movabs r8,0x4118a0
  411892:	00 00 00 
  411895:	0f 05                	syscall 
  411897:	90                   	nop
  411898:	eb 0d                	jmp    4118a7 <cos_mem_alias_atn+0xa7>
  41189a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4118a0:	b9 00 00 00 00       	mov    ecx,0x0
  4118a5:	eb 05                	jmp    4118ac <cos_mem_alias_atn+0xac>
  4118a7:	b9 01 00 00 00       	mov    ecx,0x1
  4118ac:	5d                   	pop    rbp
  4118ad:	5c                   	pop    rsp
		if (call_cap_op(srcci->pgtbl_cap, CAPTBL_OP_CPY, src + i * PAGE_SIZE, dstci->pgtbl_cap, dst + i * PAGE_SIZE, perm_flags)) BUG();
  4118ae:	85 c0                	test   eax,eax
  4118b0:	74 ae                	je     411860 <cos_mem_alias_atn+0x60>
  4118b2:	be 1c 00 00 00       	mov    esi,0x1c
  4118b7:	bf a8 e8 41 00       	mov    edi,0x41e8a8
  4118bc:	e8 0f 88 ff ff       	call   40a0d0 <cos_print_str>
  4118c1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4118c8:	00 00 00 00 
  4118cc:	0f 0b                	ud2    
  4118ce:	66 90                	xchg   ax,ax
	}

	return 0;
}
  4118d0:	48 83 c4 18          	add    rsp,0x18
  4118d4:	31 c0                	xor    eax,eax
  4118d6:	5b                   	pop    rbx
  4118d7:	41 5c                	pop    r12
  4118d9:	41 5d                	pop    r13
  4118db:	41 5e                	pop    r14
  4118dd:	41 5f                	pop    r15
  4118df:	5d                   	pop    rbp
  4118e0:	c3                   	ret    
  4118e1:	be 2f 00 00 00       	mov    esi,0x2f
  4118e6:	bf 48 e8 41 00       	mov    edi,0x41e848
  4118eb:	e8 e0 87 ff ff       	call   40a0d0 <cos_print_str>
	assert(srcci && dstci);
  4118f0:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4118f7:	00 00 00 00 
  4118fb:	0f 0b                	ud2    
  4118fd:	be 2f 00 00 00       	mov    esi,0x2f
  411902:	bf 78 e8 41 00       	mov    edi,0x41e878
  411907:	e8 c4 87 ff ff       	call   40a0d0 <cos_print_str>
	assert(sz % PAGE_SIZE == 0);
  41190c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411913:	00 00 00 00 
  411917:	0f 0b                	ud2    
  411919:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000411920 <cos_mem_remove>:

int
cos_mem_remove(pgtblcap_t pt, vaddr_t addr)
{
  411920:	f3 0f 1e fa          	endbr64 
  411924:	55                   	push   rbp
  411925:	be 2f 00 00 00       	mov    esi,0x2f
  41192a:	bf c8 e8 41 00       	mov    edi,0x41e8c8
  41192f:	48 89 e5             	mov    rbp,rsp
  411932:	e8 99 87 ff ff       	call   40a0d0 <cos_print_str>
	assert(0);
  411937:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41193e:	00 00 00 00 
  411942:	0f 0b                	ud2    
  411944:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41194b:	00 00 00 00 
  41194f:	90                   	nop

0000000000411950 <cos_mem_move>:
	return 0;
}

vaddr_t
cos_mem_move(struct cos_compinfo *dstci, struct cos_compinfo *srcci, vaddr_t src)
{
  411950:	f3 0f 1e fa          	endbr64 
  411954:	55                   	push   rbp
  411955:	48 89 e5             	mov    rbp,rsp
  411958:	41 55                	push   r13
  41195a:	41 54                	push   r12
  41195c:	53                   	push   rbx
  41195d:	48 83 ec 18          	sub    rsp,0x18
	vaddr_t dst;

	assert(srcci && dstci);
  411961:	48 85 f6             	test   rsi,rsi
  411964:	0f 84 a2 00 00 00    	je     411a0c <cos_mem_move+0xbc>
  41196a:	49 89 fc             	mov    r12,rdi
  41196d:	48 85 ff             	test   rdi,rdi
  411970:	0f 84 96 00 00 00    	je     411a0c <cos_mem_move+0xbc>
  411976:	49 89 f5             	mov    r13,rsi
  411979:	48 89 d3             	mov    rbx,rdx

	dst = __page_bump_valloc(dstci, PAGE_SIZE, PAGE_SIZE);
  41197c:	be 00 10 00 00       	mov    esi,0x1000
  411981:	ba 00 10 00 00       	mov    edx,0x1000
  411986:	e8 95 b5 ff ff       	call   40cf20 <__page_bump_valloc>
  41198b:	49 89 c2             	mov    r10,rax
	if (unlikely(!dst)) return 0;
  41198e:	48 85 c0             	test   rax,rax
  411991:	74 4f                	je     4119e2 <cos_mem_move+0x92>

	if (call_cap_op(srcci->pgtbl_cap, CAPTBL_OP_MEMMOVE, src, dstci->pgtbl_cap, dst, 0)) BUG();
  411993:	49 8b 45 00          	mov    rax,QWORD PTR [r13+0x0]
  411997:	49 8b 34 24          	mov    rsi,QWORD PTR [r12]
  41199b:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  41199f:	31 d2                	xor    edx,edx
  4119a1:	4c 89 d7             	mov    rdi,r10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4119a4:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  4119a7:	05 24 00 01 00       	add    eax,0x10024
	__asm__ __volatile__(
  4119ac:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4119af:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4119b3:	48 89 cd             	mov    rbp,rcx
  4119b6:	49 b8 d0 19 41 00 00 	movabs r8,0x4119d0
  4119bd:	00 00 00 
  4119c0:	0f 05                	syscall 
  4119c2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4119c8:	eb 0d                	jmp    4119d7 <cos_mem_move+0x87>
  4119ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4119d0:	b9 00 00 00 00       	mov    ecx,0x0
  4119d5:	eb 05                	jmp    4119dc <cos_mem_move+0x8c>
  4119d7:	b9 01 00 00 00       	mov    ecx,0x1
  4119dc:	5d                   	pop    rbp
  4119dd:	5c                   	pop    rsp
  4119de:	85 c0                	test   eax,eax
  4119e0:	75 0e                	jne    4119f0 <cos_mem_move+0xa0>

	return dst;
}
  4119e2:	48 83 c4 18          	add    rsp,0x18
  4119e6:	4c 89 d0             	mov    rax,r10
  4119e9:	5b                   	pop    rbx
  4119ea:	41 5c                	pop    r12
  4119ec:	41 5d                	pop    r13
  4119ee:	5d                   	pop    rbp
  4119ef:	c3                   	ret    
  4119f0:	be 1c 00 00 00       	mov    esi,0x1c
  4119f5:	bf 28 e9 41 00       	mov    edi,0x41e928
  4119fa:	e8 d1 86 ff ff       	call   40a0d0 <cos_print_str>
	if (call_cap_op(srcci->pgtbl_cap, CAPTBL_OP_MEMMOVE, src, dstci->pgtbl_cap, dst, 0)) BUG();
  4119ff:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411a06:	00 00 00 00 
  411a0a:	0f 0b                	ud2    
  411a0c:	be 2f 00 00 00       	mov    esi,0x2f
  411a11:	bf f8 e8 41 00       	mov    edi,0x41e8f8
  411a16:	e8 b5 86 ff ff       	call   40a0d0 <cos_print_str>
	assert(srcci && dstci);
  411a1b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411a22:	00 00 00 00 
  411a26:	0f 0b                	ud2    
  411a28:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  411a2f:	00 

0000000000411a30 <cos_mem_move_at>:

int
cos_mem_move_at(struct cos_compinfo *dstci, vaddr_t dst, struct cos_compinfo *srcci, vaddr_t src)
{
  411a30:	f3 0f 1e fa          	endbr64 
  411a34:	55                   	push   rbp
  411a35:	48 89 e5             	mov    rbp,rsp
  411a38:	41 54                	push   r12
  411a3a:	53                   	push   rbx
  411a3b:	48 83 ec 10          	sub    rsp,0x10
	assert(srcci && dstci);
  411a3f:	48 85 d2             	test   rdx,rdx
  411a42:	0f 84 7c 00 00 00    	je     411ac4 <cos_mem_move_at+0x94>
  411a48:	49 89 f8             	mov    r8,rdi
  411a4b:	48 85 ff             	test   rdi,rdi
  411a4e:	74 74                	je     411ac4 <cos_mem_move_at+0x94>

	/* TODO */
	if (call_cap_op(srcci->pgtbl_cap, CAPTBL_OP_MEMMOVE, src, dstci->pgtbl_cap, dst, 0)) BUG();
  411a50:	48 8b 02             	mov    rax,QWORD PTR [rdx]
  411a53:	48 89 f7             	mov    rdi,rsi
  411a56:	48 89 cb             	mov    rbx,rcx
  411a59:	49 8b 30             	mov    rsi,QWORD PTR [r8]
  411a5c:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  411a60:	31 d2                	xor    edx,edx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411a62:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  411a65:	05 24 00 01 00       	add    eax,0x10024
	__asm__ __volatile__(
  411a6a:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411a6d:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411a71:	48 89 cd             	mov    rbp,rcx
  411a74:	49 b8 88 1a 41 00 00 	movabs r8,0x411a88
  411a7b:	00 00 00 
  411a7e:	0f 05                	syscall 
  411a80:	eb 0d                	jmp    411a8f <cos_mem_move_at+0x5f>
  411a82:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411a88:	b9 00 00 00 00       	mov    ecx,0x0
  411a8d:	eb 05                	jmp    411a94 <cos_mem_move_at+0x64>
  411a8f:	b9 01 00 00 00       	mov    ecx,0x1
  411a94:	5d                   	pop    rbp
  411a95:	5c                   	pop    rsp
  411a96:	85 c0                	test   eax,eax
  411a98:	75 0e                	jne    411aa8 <cos_mem_move_at+0x78>

	return 0;
}
  411a9a:	48 83 c4 10          	add    rsp,0x10
  411a9e:	31 c0                	xor    eax,eax
  411aa0:	5b                   	pop    rbx
  411aa1:	41 5c                	pop    r12
  411aa3:	5d                   	pop    rbp
  411aa4:	c3                   	ret    
  411aa5:	0f 1f 00             	nop    DWORD PTR [rax]
  411aa8:	be 1c 00 00 00       	mov    esi,0x1c
  411aad:	bf 78 e9 41 00       	mov    edi,0x41e978
  411ab2:	e8 19 86 ff ff       	call   40a0d0 <cos_print_str>
	if (call_cap_op(srcci->pgtbl_cap, CAPTBL_OP_MEMMOVE, src, dstci->pgtbl_cap, dst, 0)) BUG();
  411ab7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411abe:	00 00 00 00 
  411ac2:	0f 0b                	ud2    
  411ac4:	be 2f 00 00 00       	mov    esi,0x2f
  411ac9:	bf 48 e9 41 00       	mov    edi,0x41e948
  411ace:	e8 fd 85 ff ff       	call   40a0d0 <cos_print_str>
	assert(srcci && dstci);
  411ad3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411ada:	00 00 00 00 
  411ade:	0f 0b                	ud2    

0000000000411ae0 <cos_thd_mod>:

/* TODO: generalize to modify all state */
int
cos_thd_mod(struct cos_compinfo *ci, thdcap_t tc, void *tlsaddr)
{
  411ae0:	f3 0f 1e fa          	endbr64 
  411ae4:	55                   	push   rbp
  411ae5:	49 89 f2             	mov    r10,rsi
  411ae8:	48 89 d6             	mov    rsi,rdx
  411aeb:	31 d2                	xor    edx,edx
  411aed:	48 89 e5             	mov    rbp,rsp
  411af0:	41 54                	push   r12
  411af2:	53                   	push   rbx
  411af3:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  411af7:	4c 89 d3             	mov    rbx,r10
	return call_cap_op(ci->captbl_cap, CAPTBL_OP_THDTLSSET, tc, (word_t)tlsaddr, 0, 0);
  411afa:	48 8b 47 08          	mov    rax,QWORD PTR [rdi+0x8]
  411afe:	48 89 d7             	mov    rdi,rdx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411b01:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  411b04:	05 06 00 01 00       	add    eax,0x10006
	__asm__ __volatile__(
  411b09:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411b0c:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411b10:	48 89 cd             	mov    rbp,rcx
  411b13:	49 b8 28 1b 41 00 00 	movabs r8,0x411b28
  411b1a:	00 00 00 
  411b1d:	0f 05                	syscall 
  411b1f:	90                   	nop
  411b20:	eb 0d                	jmp    411b2f <cos_thd_mod+0x4f>
  411b22:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411b28:	b9 00 00 00 00       	mov    ecx,0x0
  411b2d:	eb 05                	jmp    411b34 <cos_thd_mod+0x54>
  411b2f:	b9 01 00 00 00       	mov    ecx,0x1
  411b34:	5d                   	pop    rbp
  411b35:	5c                   	pop    rsp
}
  411b36:	5b                   	pop    rbx
  411b37:	41 5c                	pop    r12
  411b39:	5d                   	pop    rbp
  411b3a:	c3                   	ret    
  411b3b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000411b40 <cos_introspect>:

/* FIXME: problems when we got to 64 bit systems with the return value */
int
cos_introspect(struct cos_compinfo *ci, capid_t cap, unsigned long op)
{
  411b40:	f3 0f 1e fa          	endbr64 
  411b44:	55                   	push   rbp
  411b45:	49 89 f2             	mov    r10,rsi
	return call_cap_op(ci->captbl_cap, CAPTBL_OP_INTROSPECT, cap, (int)op, 0, 0);
  411b48:	48 63 f2             	movsxd rsi,edx
  411b4b:	31 d2                	xor    edx,edx
{
  411b4d:	48 89 e5             	mov    rbp,rsp
  411b50:	41 54                	push   r12
  411b52:	53                   	push   rbx
  411b53:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  411b57:	4c 89 d3             	mov    rbx,r10
	return call_cap_op(ci->captbl_cap, CAPTBL_OP_INTROSPECT, cap, (int)op, 0, 0);
  411b5a:	48 8b 47 08          	mov    rax,QWORD PTR [rdi+0x8]
  411b5e:	48 89 d7             	mov    rdi,rdx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411b61:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  411b64:	05 25 00 01 00       	add    eax,0x10025
	__asm__ __volatile__(
  411b69:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411b6c:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411b70:	48 89 cd             	mov    rbp,rcx
  411b73:	49 b8 88 1b 41 00 00 	movabs r8,0x411b88
  411b7a:	00 00 00 
  411b7d:	0f 05                	syscall 
  411b7f:	90                   	nop
  411b80:	eb 0d                	jmp    411b8f <cos_introspect+0x4f>
  411b82:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411b88:	b9 00 00 00 00       	mov    ecx,0x0
  411b8d:	eb 05                	jmp    411b94 <cos_introspect+0x54>
  411b8f:	b9 01 00 00 00       	mov    ecx,0x1
  411b94:	5d                   	pop    rbp
  411b95:	5c                   	pop    rsp
}
  411b96:	5b                   	pop    rbx
  411b97:	41 5c                	pop    r12
  411b99:	5d                   	pop    rbp
  411b9a:	c3                   	ret    
  411b9b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000411ba0 <cos_tcap_alloc>:

/***************** [Kernel Tcap Operations] *****************/

tcap_t
cos_tcap_alloc(struct cos_compinfo *ci)
{
  411ba0:	f3 0f 1e fa          	endbr64 
  411ba4:	55                   	push   rbp
  411ba5:	48 89 e5             	mov    rbp,rsp
  411ba8:	41 56                	push   r14
  411baa:	41 55                	push   r13
  411bac:	41 54                	push   r12
  411bae:	53                   	push   rbx
  411baf:	48 83 ec 10          	sub    rsp,0x10
	vaddr_t kmem;
	capid_t cap;

	printd("cos_tcap_alloc\n");
	assert(ci);
  411bb3:	48 85 ff             	test   rdi,rdi
  411bb6:	0f 84 30 01 00 00    	je     411cec <cos_tcap_alloc+0x14c>
  411bbc:	49 89 fc             	mov    r12,rdi
	return __mem_bump_alloc(ci, 1, 1);
  411bbf:	e8 9c ac ff ff       	call   40c860 <__mem_bump_alloc.constprop.0>
  411bc4:	49 89 c5             	mov    r13,rax
	if (!*kmem) return -1;
  411bc7:	48 85 c0             	test   rax,rax
  411bca:	0f 84 38 01 00 00    	je     411d08 <cos_tcap_alloc+0x168>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  411bd0:	49 8d 94 24 b0 00 00 	lea    rdx,[r12+0xb0]
  411bd7:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  411bd8:	41 b8 01 00 00 00    	mov    r8d,0x1
  411bde:	31 c9                	xor    ecx,ecx
  411be0:	48 89 c8             	mov    rax,rcx
  411be3:	f0 4c 0f b1 02       	lock cmpxchg QWORD PTR [rdx],r8
  411be8:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  411beb:	84 c0                	test   al,al
  411bed:	74 f1                	je     411be0 <cos_tcap_alloc+0x40>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  411bef:	4d 8b 74 24 28       	mov    r14,QWORD PTR [r12+0x28]
  411bf4:	41 83 e6 03          	and    r14d,0x3
  411bf8:	0f 84 9a 00 00 00    	je     411c98 <cos_tcap_alloc+0xf8>
        __asm__ __volatile__("lock " PS_FAA_STR
  411bfe:	ba 01 00 00 00       	mov    edx,0x1
  411c03:	f0 49 0f c1 54 24 28 	lock xadd QWORD PTR [r12+0x28],rdx
{ l->o = 0; }
  411c0a:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  411c11:	00 00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  411c16:	49 89 d6             	mov    r14,rdx
	if (!*cap) return -1;
  411c19:	48 85 d2             	test   rdx,rdx
  411c1c:	0f 84 e6 00 00 00    	je     411d08 <cos_tcap_alloc+0x168>

	if (__alloc_mem_cap(ci, CAP_TCAP, &kmem, &cap)) return 0;
	/* TODO: Add cap size checking */
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_TCAP_ACTIVATE, (cap << 16) | __compinfo_metacap(ci)->mi.pgtbl_cap,
  411c22:	49 8b 4c 24 60       	mov    rcx,QWORD PTR [r12+0x60]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411c27:	41 8b 44 24 08       	mov    eax,DWORD PTR [r12+0x8]
  411c2c:	48 c1 e2 10          	shl    rdx,0x10
	__asm__ __volatile__(
  411c30:	4c 89 ee             	mov    rsi,r13
  411c33:	48 8b 99 98 00 00 00 	mov    rbx,QWORD PTR [rcx+0x98]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411c3a:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  411c3d:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
	cap_no += op;
  411c41:	05 26 00 01 00       	add    eax,0x10026
  411c46:	48 09 d3             	or     rbx,rdx
	__asm__ __volatile__(
  411c49:	31 d2                	xor    edx,edx
  411c4b:	48 89 d7             	mov    rdi,rdx
  411c4e:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411c51:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411c55:	48 89 cd             	mov    rbp,rcx
  411c58:	49 b8 70 1c 41 00 00 	movabs r8,0x411c70
  411c5f:	00 00 00 
  411c62:	0f 05                	syscall 
  411c64:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  411c68:	eb 0d                	jmp    411c77 <cos_tcap_alloc+0xd7>
  411c6a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411c70:	b9 00 00 00 00       	mov    ecx,0x0
  411c75:	eb 05                	jmp    411c7c <cos_tcap_alloc+0xdc>
  411c77:	b9 01 00 00 00       	mov    ecx,0x1
  411c7c:	5d                   	pop    rbp
  411c7d:	5c                   	pop    rsp
  411c7e:	85 c0                	test   eax,eax
  411c80:	75 4e                	jne    411cd0 <cos_tcap_alloc+0x130>
	                kmem, 0, 0))
		BUG();

	return cap;
}
  411c82:	48 83 c4 10          	add    rsp,0x10
  411c86:	4c 89 f0             	mov    rax,r14
  411c89:	5b                   	pop    rbx
  411c8a:	41 5c                	pop    r12
  411c8c:	41 5d                	pop    r13
  411c8e:	41 5e                	pop    r14
  411c90:	5d                   	pop    rbp
  411c91:	c3                   	ret    
  411c92:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  411c98:	4c 89 e7             	mov    rdi,r12
  411c9b:	e8 40 ad ff ff       	call   40c9e0 <__capid_captbl_check_expand>
  411ca0:	85 c0                	test   eax,eax
  411ca2:	75 16                	jne    411cba <cos_tcap_alloc+0x11a>
        __asm__ __volatile__("lock " PS_FAA_STR
  411ca4:	b8 04 00 00 00       	mov    eax,0x4
  411ca9:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  411cb0:	49 89 44 24 28       	mov    QWORD PTR [r12+0x28],rax
  411cb5:	e9 44 ff ff ff       	jmp    411bfe <cos_tcap_alloc+0x5e>
{ l->o = 0; }
  411cba:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  411cc1:	00 00 00 00 00 
	if (!*cap) return -1;
  411cc6:	eb ba                	jmp    411c82 <cos_tcap_alloc+0xe2>
  411cc8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  411ccf:	00 
  411cd0:	be 1c 00 00 00       	mov    esi,0x1c
  411cd5:	bf c8 e9 41 00       	mov    edi,0x41e9c8
  411cda:	e8 f1 83 ff ff       	call   40a0d0 <cos_print_str>
		BUG();
  411cdf:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411ce6:	00 00 00 00 
  411cea:	0f 0b                	ud2    
  411cec:	be 2f 00 00 00       	mov    esi,0x2f
  411cf1:	bf 98 e9 41 00       	mov    edi,0x41e998
  411cf6:	e8 d5 83 ff ff       	call   40a0d0 <cos_print_str>
	assert(ci);
  411cfb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411d02:	00 00 00 00 
  411d06:	0f 0b                	ud2    
	if (__alloc_mem_cap(ci, CAP_TCAP, &kmem, &cap)) return 0;
  411d08:	45 31 f6             	xor    r14d,r14d
  411d0b:	e9 72 ff ff ff       	jmp    411c82 <cos_tcap_alloc+0xe2>

0000000000411d10 <cos_tcap_transfer>:

int
cos_tcap_transfer(arcvcap_t dst, tcap_t src, tcap_res_t res, tcap_prio_t prio)
{
  411d10:	f3 0f 1e fa          	endbr64 
  411d14:	55                   	push   rbp
  411d15:	49 89 fa             	mov    r10,rdi
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411d18:	c1 e6 10             	shl    esi,0x10
	int prio_higher = (u32_t)(prio >> 32);
	int prio_lower  = (u32_t)((prio << 32) >> 32);

	return call_cap_op(src, CAPTBL_OP_TCAP_TRANSFER, dst, res, prio_higher, prio_lower);
  411d1b:	48 89 cf             	mov    rdi,rcx
	cap_no += op;
  411d1e:	8d 86 27 00 01 00    	lea    eax,[rsi+0x10027]
  411d24:	48 c1 ff 20          	sar    rdi,0x20
{
  411d28:	48 89 e5             	mov    rbp,rsp
  411d2b:	41 55                	push   r13
  411d2d:	49 89 d5             	mov    r13,rdx
	return call_cap_op(src, CAPTBL_OP_TCAP_TRANSFER, dst, res, prio_higher, prio_lower);
  411d30:	48 63 d1             	movsxd rdx,ecx
{
  411d33:	41 54                	push   r12
	__asm__ __volatile__(
  411d35:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  411d39:	4c 89 ee             	mov    rsi,r13
  411d3c:	53                   	push   rbx
  411d3d:	4c 89 d3             	mov    rbx,r10
  411d40:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411d43:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411d47:	48 89 cd             	mov    rbp,rcx
  411d4a:	49 b8 60 1d 41 00 00 	movabs r8,0x411d60
  411d51:	00 00 00 
  411d54:	0f 05                	syscall 
  411d56:	66 90                	xchg   ax,ax
  411d58:	eb 0d                	jmp    411d67 <cos_tcap_transfer+0x57>
  411d5a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411d60:	b9 00 00 00 00       	mov    ecx,0x0
  411d65:	eb 05                	jmp    411d6c <cos_tcap_transfer+0x5c>
  411d67:	b9 01 00 00 00       	mov    ecx,0x1
  411d6c:	5d                   	pop    rbp
  411d6d:	5c                   	pop    rsp
}
  411d6e:	5b                   	pop    rbx
  411d6f:	41 5c                	pop    r12
  411d71:	41 5d                	pop    r13
  411d73:	5d                   	pop    rbp
  411d74:	c3                   	ret    
  411d75:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  411d7c:	00 00 00 00 

0000000000411d80 <cos_tcap_delegate>:

int
cos_tcap_delegate(asndcap_t dst, tcap_t src, tcap_res_t res, tcap_prio_t prio, tcap_deleg_flags_t flags)
{
  411d80:	f3 0f 1e fa          	endbr64 
  411d84:	55                   	push   rbp
  411d85:	49 89 fa             	mov    r10,rdi
	u32_t yield = ((flags & TCAP_DELEG_YIELD) != 0);
  411d88:	44 89 c7             	mov    edi,r8d
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411d8b:	c1 e6 10             	shl    esi,0x10
  411d8e:	d1 ef                	shr    edi,1
	cap_no += op;
  411d90:	8d 86 28 00 01 00    	lea    eax,[rsi+0x10028]
	/* top bit is if we are dispatching or not */
	int prio_higher = (u32_t)(prio >> 32) | (yield << ((sizeof(yield) * 8) - 1));
  411d96:	c1 e7 1f             	shl    edi,0x1f
{
  411d99:	48 89 e5             	mov    rbp,rsp
  411d9c:	41 55                	push   r13
  411d9e:	49 89 d5             	mov    r13,rdx
	int prio_higher = (u32_t)(prio >> 32) | (yield << ((sizeof(yield) * 8) - 1));
  411da1:	48 89 ca             	mov    rdx,rcx
{
  411da4:	41 54                	push   r12
	int prio_higher = (u32_t)(prio >> 32) | (yield << ((sizeof(yield) * 8) - 1));
  411da6:	48 c1 ea 20          	shr    rdx,0x20
	__asm__ __volatile__(
  411daa:	4c 89 ee             	mov    rsi,r13
{
  411dad:	53                   	push   rbx
	int prio_higher = (u32_t)(prio >> 32) | (yield << ((sizeof(yield) * 8) - 1));
  411dae:	09 d7                	or     edi,edx
  411db0:	4c 89 d3             	mov    rbx,r10
	int prio_lower  = (u32_t)((prio << 32) >> 32);

	return call_cap_op(src, CAPTBL_OP_TCAP_DELEGATE, dst, res, prio_higher, prio_lower);
  411db3:	48 63 d1             	movsxd rdx,ecx
  411db6:	48 63 ff             	movsxd rdi,edi
  411db9:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  411dbd:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411dc0:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411dc4:	48 89 cd             	mov    rbp,rcx
  411dc7:	49 b8 e0 1d 41 00 00 	movabs r8,0x411de0
  411dce:	00 00 00 
  411dd1:	0f 05                	syscall 
  411dd3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  411dd8:	eb 0d                	jmp    411de7 <cos_tcap_delegate+0x67>
  411dda:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411de0:	b9 00 00 00 00       	mov    ecx,0x0
  411de5:	eb 05                	jmp    411dec <cos_tcap_delegate+0x6c>
  411de7:	b9 01 00 00 00       	mov    ecx,0x1
  411dec:	5d                   	pop    rbp
  411ded:	5c                   	pop    rsp
}
  411dee:	5b                   	pop    rbx
  411def:	41 5c                	pop    r12
  411df1:	41 5d                	pop    r13
  411df3:	5d                   	pop    rbp
  411df4:	c3                   	ret    
  411df5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  411dfc:	00 00 00 00 

0000000000411e00 <cos_tcap_merge>:

int
cos_tcap_merge(tcap_t dst, tcap_t rm)
{
  411e00:	f3 0f 1e fa          	endbr64 
  411e04:	55                   	push   rbp
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411e05:	c1 e7 10             	shl    edi,0x10
	__asm__ __volatile__(
  411e08:	31 d2                	xor    edx,edx
	cap_no += op;
  411e0a:	8d 87 29 00 01 00    	lea    eax,[rdi+0x10029]
	__asm__ __volatile__(
  411e10:	48 89 d7             	mov    rdi,rdx
  411e13:	48 89 e5             	mov    rbp,rsp
  411e16:	41 54                	push   r12
  411e18:	53                   	push   rbx
  411e19:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  411e1d:	48 89 f3             	mov    rbx,rsi
  411e20:	48 89 d6             	mov    rsi,rdx
  411e23:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411e26:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411e2a:	48 89 cd             	mov    rbp,rcx
  411e2d:	49 b8 48 1e 41 00 00 	movabs r8,0x411e48
  411e34:	00 00 00 
  411e37:	0f 05                	syscall 
  411e39:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  411e40:	eb 0d                	jmp    411e4f <cos_tcap_merge+0x4f>
  411e42:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411e48:	b9 00 00 00 00       	mov    ecx,0x0
  411e4d:	eb 05                	jmp    411e54 <cos_tcap_merge+0x54>
  411e4f:	b9 01 00 00 00       	mov    ecx,0x1
  411e54:	5d                   	pop    rbp
  411e55:	5c                   	pop    rsp
	return call_cap_op(dst, CAPTBL_OP_TCAP_MERGE, rm, 0, 0, 0);
}
  411e56:	5b                   	pop    rbx
  411e57:	41 5c                	pop    r12
  411e59:	5d                   	pop    rbp
  411e5a:	c3                   	ret    
  411e5b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000411e60 <cos_hw_attach>:

int
cos_hw_attach(hwcap_t hwc, hwid_t hwid, arcvcap_t arcv)
{
  411e60:	f3 0f 1e fa          	endbr64 
  411e64:	55                   	push   rbp
  411e65:	49 89 d2             	mov    r10,rdx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411e68:	c1 e7 10             	shl    edi,0x10
	__asm__ __volatile__(
  411e6b:	31 d2                	xor    edx,edx
	cap_no += op;
  411e6d:	8d 87 2d 00 01 00    	lea    eax,[rdi+0x1002d]
	__asm__ __volatile__(
  411e73:	48 89 d7             	mov    rdi,rdx
  411e76:	48 89 e5             	mov    rbp,rsp
  411e79:	41 54                	push   r12
  411e7b:	53                   	push   rbx
  411e7c:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
	return call_cap_op(hwc, CAPTBL_OP_HW_ATTACH, hwid, arcv, 0, 0);
  411e80:	89 f3                	mov    ebx,esi
  411e82:	4c 89 d6             	mov    rsi,r10
  411e85:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411e88:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411e8c:	48 89 cd             	mov    rbp,rcx
  411e8f:	49 b8 a8 1e 41 00 00 	movabs r8,0x411ea8
  411e96:	00 00 00 
  411e99:	0f 05                	syscall 
  411e9b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  411ea0:	eb 0d                	jmp    411eaf <cos_hw_attach+0x4f>
  411ea2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411ea8:	b9 00 00 00 00       	mov    ecx,0x0
  411ead:	eb 05                	jmp    411eb4 <cos_hw_attach+0x54>
  411eaf:	b9 01 00 00 00       	mov    ecx,0x1
  411eb4:	5d                   	pop    rbp
  411eb5:	5c                   	pop    rsp
}
  411eb6:	5b                   	pop    rbx
  411eb7:	41 5c                	pop    r12
  411eb9:	5d                   	pop    rbp
  411eba:	c3                   	ret    
  411ebb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000411ec0 <cos_hw_detach>:

int
cos_hw_detach(hwcap_t hwc, hwid_t hwid)
{
  411ec0:	f3 0f 1e fa          	endbr64 
  411ec4:	55                   	push   rbp
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411ec5:	c1 e7 10             	shl    edi,0x10
	__asm__ __volatile__(
  411ec8:	31 d2                	xor    edx,edx
	cap_no += op;
  411eca:	8d 87 2e 00 01 00    	lea    eax,[rdi+0x1002e]
	__asm__ __volatile__(
  411ed0:	48 89 d7             	mov    rdi,rdx
  411ed3:	48 89 e5             	mov    rbp,rsp
  411ed6:	41 54                	push   r12
  411ed8:	53                   	push   rbx
  411ed9:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
	return call_cap_op(hwc, CAPTBL_OP_HW_DETACH, hwid, 0, 0, 0);
  411edd:	89 f3                	mov    ebx,esi
  411edf:	48 89 d6             	mov    rsi,rdx
  411ee2:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411ee5:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411ee9:	48 89 cd             	mov    rbp,rcx
  411eec:	49 b8 00 1f 41 00 00 	movabs r8,0x411f00
  411ef3:	00 00 00 
  411ef6:	0f 05                	syscall 
  411ef8:	eb 0d                	jmp    411f07 <cos_hw_detach+0x47>
  411efa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411f00:	b9 00 00 00 00       	mov    ecx,0x0
  411f05:	eb 05                	jmp    411f0c <cos_hw_detach+0x4c>
  411f07:	b9 01 00 00 00       	mov    ecx,0x1
  411f0c:	5d                   	pop    rbp
  411f0d:	5c                   	pop    rsp
}
  411f0e:	5b                   	pop    rbx
  411f0f:	41 5c                	pop    r12
  411f11:	5d                   	pop    rbp
  411f12:	c3                   	ret    
  411f13:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  411f1a:	00 00 00 00 
  411f1e:	66 90                	xchg   ax,ax

0000000000411f20 <cos_hw_cycles_per_usec>:

int
cos_hw_cycles_per_usec(hwcap_t hwc)
{
  411f20:	f3 0f 1e fa          	endbr64 
	static int cycs = 0;

	while (cycs <= 0) cycs = call_cap_op(hwc, CAPTBL_OP_HW_CYC_USEC, 0, 0, 0, 0);
  411f24:	8b 05 76 eb 18 00    	mov    eax,DWORD PTR [rip+0x18eb76]        # 5a0aa0 <cycs.0>
  411f2a:	85 c0                	test   eax,eax
  411f2c:	7f 72                	jg     411fa0 <cos_hw_cycles_per_usec+0x80>
{
  411f2e:	55                   	push   rbp
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411f2f:	c1 e7 10             	shl    edi,0x10
	__asm__ __volatile__(
  411f32:	31 d2                	xor    edx,edx
  411f34:	48 89 e5             	mov    rbp,rsp
  411f37:	41 55                	push   r13
	cap_no += op;
  411f39:	44 8d af 30 00 01 00 	lea    r13d,[rdi+0x10030]
  411f40:	41 54                	push   r12
  411f42:	4c 8d 55 d0          	lea    r10,[rbp-0x30]
  411f46:	53                   	push   rbx
  411f47:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  411f4e:	00 00 
	__asm__ __volatile__(
  411f50:	44 89 e8             	mov    eax,r13d
  411f53:	48 89 d3             	mov    rbx,rdx
  411f56:	48 89 d6             	mov    rsi,rdx
  411f59:	48 89 d7             	mov    rdi,rdx
  411f5c:	4c 89 d1             	mov    rcx,r10
  411f5f:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411f62:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411f66:	48 89 cd             	mov    rbp,rcx
  411f69:	49 b8 80 1f 41 00 00 	movabs r8,0x411f80
  411f70:	00 00 00 
  411f73:	0f 05                	syscall 
  411f75:	0f 1f 00             	nop    DWORD PTR [rax]
  411f78:	eb 0d                	jmp    411f87 <cos_hw_cycles_per_usec+0x67>
  411f7a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411f80:	b9 00 00 00 00       	mov    ecx,0x0
  411f85:	eb 05                	jmp    411f8c <cos_hw_cycles_per_usec+0x6c>
  411f87:	b9 01 00 00 00       	mov    ecx,0x1
  411f8c:	5d                   	pop    rbp
  411f8d:	5c                   	pop    rsp
	while (cycs <= 0) cycs = call_cap_op(hwc, CAPTBL_OP_HW_CYC_USEC, 0, 0, 0, 0);
  411f8e:	89 05 0c eb 18 00    	mov    DWORD PTR [rip+0x18eb0c],eax        # 5a0aa0 <cycs.0>
  411f94:	85 c0                	test   eax,eax
  411f96:	7e b8                	jle    411f50 <cos_hw_cycles_per_usec+0x30>

	return cycs;
}
  411f98:	5b                   	pop    rbx
  411f99:	41 5c                	pop    r12
  411f9b:	41 5d                	pop    r13
  411f9d:	5d                   	pop    rbp
  411f9e:	c3                   	ret    
  411f9f:	90                   	nop
  411fa0:	c3                   	ret    
  411fa1:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  411fa8:	00 00 00 00 
  411fac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000411fb0 <cos_hw_tlb_lockdown>:

int
cos_hw_tlb_lockdown(hwcap_t hwc, unsigned long entryid, unsigned long vaddr, unsigned long paddr)
{
  411fb0:	f3 0f 1e fa          	endbr64 
  411fb4:	55                   	push   rbp
  411fb5:	49 89 f2             	mov    r10,rsi
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411fb8:	c1 e7 10             	shl    edi,0x10
  411fbb:	48 89 d6             	mov    rsi,rdx
	cap_no += op;
  411fbe:	8d 87 33 00 01 00    	lea    eax,[rdi+0x10033]
	__asm__ __volatile__(
  411fc4:	31 d2                	xor    edx,edx
  411fc6:	48 89 e5             	mov    rbp,rsp
  411fc9:	41 55                	push   r13
  411fcb:	49 89 cd             	mov    r13,rcx
  411fce:	41 54                	push   r12
  411fd0:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  411fd4:	4c 89 ef             	mov    rdi,r13
  411fd7:	53                   	push   rbx
  411fd8:	4c 89 d3             	mov    rbx,r10
  411fdb:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411fde:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411fe2:	48 89 cd             	mov    rbp,rcx
  411fe5:	49 b8 00 20 41 00 00 	movabs r8,0x412000
  411fec:	00 00 00 
  411fef:	0f 05                	syscall 
  411ff1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  411ff8:	eb 0d                	jmp    412007 <cos_hw_tlb_lockdown+0x57>
  411ffa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  412000:	b9 00 00 00 00       	mov    ecx,0x0
  412005:	eb 05                	jmp    41200c <cos_hw_tlb_lockdown+0x5c>
  412007:	b9 01 00 00 00       	mov    ecx,0x1
  41200c:	5d                   	pop    rbp
  41200d:	5c                   	pop    rsp
	return call_cap_op(hwc, CAPTBL_OP_HW_TLB_LOCKDOWN, entryid, vaddr, paddr, 0);
}
  41200e:	5b                   	pop    rbx
  41200f:	41 5c                	pop    r12
  412011:	41 5d                	pop    r13
  412013:	5d                   	pop    rbp
  412014:	c3                   	ret    
  412015:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41201c:	00 00 00 00 

0000000000412020 <cos_hw_l1flush>:

int
cos_hw_l1flush(hwcap_t hwc)
{
  412020:	f3 0f 1e fa          	endbr64 
  412024:	55                   	push   rbp
  412025:	31 d2                	xor    edx,edx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  412027:	c1 e7 10             	shl    edi,0x10
	cap_no += op;
  41202a:	8d 87 34 00 01 00    	lea    eax,[rdi+0x10034]
	__asm__ __volatile__(
  412030:	48 89 d6             	mov    rsi,rdx
  412033:	48 89 d7             	mov    rdi,rdx
  412036:	48 89 e5             	mov    rbp,rsp
  412039:	41 54                	push   r12
  41203b:	53                   	push   rbx
  41203c:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  412040:	48 89 d3             	mov    rbx,rdx
  412043:	48 89 29             	mov    QWORD PTR [rcx],rbp
  412046:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  41204a:	48 89 cd             	mov    rbp,rcx
  41204d:	49 b8 68 20 41 00 00 	movabs r8,0x412068
  412054:	00 00 00 
  412057:	0f 05                	syscall 
  412059:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  412060:	eb 0d                	jmp    41206f <cos_hw_l1flush+0x4f>
  412062:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  412068:	b9 00 00 00 00       	mov    ecx,0x0
  41206d:	eb 05                	jmp    412074 <cos_hw_l1flush+0x54>
  41206f:	b9 01 00 00 00       	mov    ecx,0x1
  412074:	5d                   	pop    rbp
  412075:	5c                   	pop    rsp
	return call_cap_op(hwc, CAPTBL_OP_HW_L1FLUSH, 0, 0, 0, 0);
}
  412076:	5b                   	pop    rbx
  412077:	41 5c                	pop    r12
  412079:	5d                   	pop    rbp
  41207a:	c3                   	ret    
  41207b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000412080 <cos_hw_tlbflush>:

int
cos_hw_tlbflush(hwcap_t hwc)
{
  412080:	f3 0f 1e fa          	endbr64 
  412084:	55                   	push   rbp
  412085:	31 d2                	xor    edx,edx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  412087:	c1 e7 10             	shl    edi,0x10
	cap_no += op;
  41208a:	8d 87 35 00 01 00    	lea    eax,[rdi+0x10035]
	__asm__ __volatile__(
  412090:	48 89 d6             	mov    rsi,rdx
  412093:	48 89 d7             	mov    rdi,rdx
  412096:	48 89 e5             	mov    rbp,rsp
  412099:	41 54                	push   r12
  41209b:	53                   	push   rbx
  41209c:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  4120a0:	48 89 d3             	mov    rbx,rdx
  4120a3:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4120a6:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4120aa:	48 89 cd             	mov    rbp,rcx
  4120ad:	49 b8 c8 20 41 00 00 	movabs r8,0x4120c8
  4120b4:	00 00 00 
  4120b7:	0f 05                	syscall 
  4120b9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  4120c0:	eb 0d                	jmp    4120cf <cos_hw_tlbflush+0x4f>
  4120c2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4120c8:	b9 00 00 00 00       	mov    ecx,0x0
  4120cd:	eb 05                	jmp    4120d4 <cos_hw_tlbflush+0x54>
  4120cf:	b9 01 00 00 00       	mov    ecx,0x1
  4120d4:	5d                   	pop    rbp
  4120d5:	5c                   	pop    rsp
	return call_cap_op(hwc, CAPTBL_OP_HW_TLBFLUSH, 0, 0, 0, 0);
}
  4120d6:	5b                   	pop    rbx
  4120d7:	41 5c                	pop    r12
  4120d9:	5d                   	pop    rbp
  4120da:	c3                   	ret    
  4120db:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000004120e0 <cos_hw_tlbstall>:

int
cos_hw_tlbstall(hwcap_t hwc)
{
  4120e0:	f3 0f 1e fa          	endbr64 
  4120e4:	55                   	push   rbp
  4120e5:	31 d2                	xor    edx,edx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4120e7:	c1 e7 10             	shl    edi,0x10
	cap_no += op;
  4120ea:	8d 87 36 00 01 00    	lea    eax,[rdi+0x10036]
	__asm__ __volatile__(
  4120f0:	48 89 d6             	mov    rsi,rdx
  4120f3:	48 89 d7             	mov    rdi,rdx
  4120f6:	48 89 e5             	mov    rbp,rsp
  4120f9:	41 54                	push   r12
  4120fb:	53                   	push   rbx
  4120fc:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  412100:	48 89 d3             	mov    rbx,rdx
  412103:	48 89 29             	mov    QWORD PTR [rcx],rbp
  412106:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  41210a:	48 89 cd             	mov    rbp,rcx
  41210d:	49 b8 28 21 41 00 00 	movabs r8,0x412128
  412114:	00 00 00 
  412117:	0f 05                	syscall 
  412119:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  412120:	eb 0d                	jmp    41212f <cos_hw_tlbstall+0x4f>
  412122:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  412128:	b9 00 00 00 00       	mov    ecx,0x0
  41212d:	eb 05                	jmp    412134 <cos_hw_tlbstall+0x54>
  41212f:	b9 01 00 00 00       	mov    ecx,0x1
  412134:	5d                   	pop    rbp
  412135:	5c                   	pop    rsp
	return call_cap_op(hwc, CAPTBL_OP_HW_TLBSTALL, 0, 0, 0, 0);
}
  412136:	5b                   	pop    rbx
  412137:	41 5c                	pop    r12
  412139:	5d                   	pop    rbp
  41213a:	c3                   	ret    
  41213b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000412140 <cos_hw_tlbstall_recount>:

int
cos_hw_tlbstall_recount(hwcap_t hwc)
{
  412140:	f3 0f 1e fa          	endbr64 
  412144:	55                   	push   rbp
  412145:	31 d2                	xor    edx,edx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  412147:	c1 e7 10             	shl    edi,0x10
	cap_no += op;
  41214a:	8d 87 37 00 01 00    	lea    eax,[rdi+0x10037]
	__asm__ __volatile__(
  412150:	48 89 d6             	mov    rsi,rdx
  412153:	48 89 d7             	mov    rdi,rdx
  412156:	48 89 e5             	mov    rbp,rsp
  412159:	41 54                	push   r12
  41215b:	53                   	push   rbx
  41215c:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  412160:	48 89 d3             	mov    rbx,rdx
  412163:	48 89 29             	mov    QWORD PTR [rcx],rbp
  412166:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  41216a:	48 89 cd             	mov    rbp,rcx
  41216d:	49 b8 88 21 41 00 00 	movabs r8,0x412188
  412174:	00 00 00 
  412177:	0f 05                	syscall 
  412179:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  412180:	eb 0d                	jmp    41218f <cos_hw_tlbstall_recount+0x4f>
  412182:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  412188:	b9 00 00 00 00       	mov    ecx,0x0
  41218d:	eb 05                	jmp    412194 <cos_hw_tlbstall_recount+0x54>
  41218f:	b9 01 00 00 00       	mov    ecx,0x1
  412194:	5d                   	pop    rbp
  412195:	5c                   	pop    rsp
	return call_cap_op(hwc, CAPTBL_OP_HW_TLBSTALL_RECOUNT, 0, 0, 0, 0);
}
  412196:	5b                   	pop    rbx
  412197:	41 5c                	pop    r12
  412199:	5d                   	pop    rbp
  41219a:	c3                   	ret    
  41219b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000004121a0 <cos_hw_cycles_thresh>:

int
cos_hw_cycles_thresh(hwcap_t hwc)
{
  4121a0:	f3 0f 1e fa          	endbr64 
  4121a4:	55                   	push   rbp
  4121a5:	31 d2                	xor    edx,edx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4121a7:	c1 e7 10             	shl    edi,0x10
	cap_no += op;
  4121aa:	8d 87 31 00 01 00    	lea    eax,[rdi+0x10031]
	__asm__ __volatile__(
  4121b0:	48 89 d6             	mov    rsi,rdx
  4121b3:	48 89 d7             	mov    rdi,rdx
  4121b6:	48 89 e5             	mov    rbp,rsp
  4121b9:	41 54                	push   r12
  4121bb:	53                   	push   rbx
  4121bc:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  4121c0:	48 89 d3             	mov    rbx,rdx
  4121c3:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4121c6:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4121ca:	48 89 cd             	mov    rbp,rcx
  4121cd:	49 b8 e8 21 41 00 00 	movabs r8,0x4121e8
  4121d4:	00 00 00 
  4121d7:	0f 05                	syscall 
  4121d9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  4121e0:	eb 0d                	jmp    4121ef <cos_hw_cycles_thresh+0x4f>
  4121e2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4121e8:	b9 00 00 00 00       	mov    ecx,0x0
  4121ed:	eb 05                	jmp    4121f4 <cos_hw_cycles_thresh+0x54>
  4121ef:	b9 01 00 00 00       	mov    ecx,0x1
  4121f4:	5d                   	pop    rbp
  4121f5:	5c                   	pop    rsp
	return call_cap_op(hwc, CAPTBL_OP_HW_CYC_THRESH, 0, 0, 0, 0);
}
  4121f6:	5b                   	pop    rbx
  4121f7:	41 5c                	pop    r12
  4121f9:	5d                   	pop    rbp
  4121fa:	c3                   	ret    
  4121fb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000412200 <cos_hw_shutdown>:

void
cos_hw_shutdown(hwcap_t hwc)
{
  412200:	f3 0f 1e fa          	endbr64 
  412204:	55                   	push   rbp
  412205:	31 d2                	xor    edx,edx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  412207:	c1 e7 10             	shl    edi,0x10
	cap_no += op;
  41220a:	8d 87 32 00 01 00    	lea    eax,[rdi+0x10032]
	__asm__ __volatile__(
  412210:	48 89 d6             	mov    rsi,rdx
  412213:	48 89 d7             	mov    rdi,rdx
  412216:	48 89 e5             	mov    rbp,rsp
  412219:	41 54                	push   r12
  41221b:	53                   	push   rbx
  41221c:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  412220:	48 89 d3             	mov    rbx,rdx
  412223:	48 89 29             	mov    QWORD PTR [rcx],rbp
  412226:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  41222a:	48 89 cd             	mov    rbp,rcx
  41222d:	49 b8 48 22 41 00 00 	movabs r8,0x412248
  412234:	00 00 00 
  412237:	0f 05                	syscall 
  412239:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  412240:	eb 0d                	jmp    41224f <cos_hw_shutdown+0x4f>
  412242:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  412248:	b9 00 00 00 00       	mov    ecx,0x0
  41224d:	eb 05                	jmp    412254 <cos_hw_shutdown+0x54>
  41224f:	b9 01 00 00 00       	mov    ecx,0x1
  412254:	5d                   	pop    rbp
  412255:	5c                   	pop    rsp
	call_cap_op(hwc, CAPTBL_OP_HW_SHUTDOWN, 0, 0, 0, 0);
}
  412256:	5b                   	pop    rbx
  412257:	41 5c                	pop    r12
  412259:	5d                   	pop    rbp
  41225a:	c3                   	ret    
  41225b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000412260 <cos_hw_map>:

void *
cos_hw_map(struct cos_compinfo *ci, hwcap_t hwc, paddr_t pa, unsigned int len)
{
  412260:	f3 0f 1e fa          	endbr64 
  412264:	55                   	push   rbp
  412265:	48 89 e5             	mov    rbp,rsp
  412268:	41 57                	push   r15
  41226a:	41 56                	push   r14
  41226c:	41 55                	push   r13
  41226e:	41 54                	push   r12
  412270:	53                   	push   rbx
  412271:	48 83 ec 28          	sub    rsp,0x28
	size_t  sz, i;
	vaddr_t va;

	assert(ci && hwc && pa && len);
  412275:	48 85 ff             	test   rdi,rdi
  412278:	0f 84 f4 00 00 00    	je     412372 <cos_hw_map+0x112>
  41227e:	48 89 f3             	mov    rbx,rsi
  412281:	48 85 f6             	test   rsi,rsi
  412284:	0f 84 e8 00 00 00    	je     412372 <cos_hw_map+0x112>
  41228a:	49 89 d7             	mov    r15,rdx
  41228d:	48 85 d2             	test   rdx,rdx
  412290:	0f 84 dc 00 00 00    	je     412372 <cos_hw_map+0x112>
  412296:	85 c9                	test   ecx,ecx
  412298:	0f 84 d4 00 00 00    	je     412372 <cos_hw_map+0x112>

	sz = round_up_to_page(len);
  41229e:	89 c9                	mov    ecx,ecx
	va = __page_bump_valloc(ci, sz, PAGE_SIZE);
  4122a0:	ba 00 10 00 00       	mov    edx,0x1000
  4122a5:	49 89 fe             	mov    r14,rdi
	sz = round_up_to_page(len);
  4122a8:	48 81 c1 ff 0f 00 00 	add    rcx,0xfff
  4122af:	48 81 e1 00 f0 ff ff 	and    rcx,0xfffffffffffff000
  4122b6:	48 89 ce             	mov    rsi,rcx
  4122b9:	48 89 4d b8          	mov    QWORD PTR [rbp-0x48],rcx
	va = __page_bump_valloc(ci, sz, PAGE_SIZE);
  4122bd:	e8 5e ac ff ff       	call   40cf20 <__page_bump_valloc>
  4122c2:	49 89 c5             	mov    r13,rax
	if (unlikely(!va)) return NULL;
  4122c5:	48 85 c0             	test   rax,rax
  4122c8:	0f 84 c0 00 00 00    	je     41238e <cos_hw_map+0x12e>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4122ce:	c1 e3 10             	shl    ebx,0x10

	for (i = 0; i < sz; i += PAGE_SIZE) {
  4122d1:	45 31 d2             	xor    r10d,r10d
	__asm__ __volatile__(
  4122d4:	31 d2                	xor    edx,edx
	cap_no += op;
  4122d6:	8d 83 2f 00 01 00    	lea    eax,[rbx+0x1002f]
  4122dc:	89 45 b4             	mov    DWORD PTR [rbp-0x4c],eax
  4122df:	eb 14                	jmp    4122f5 <cos_hw_map+0x95>
  4122e1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  4122e8:	49 81 c2 00 10 00 00 	add    r10,0x1000
  4122ef:	4c 39 55 b8          	cmp    QWORD PTR [rbp-0x48],r10
  4122f3:	76 6b                	jbe    412360 <cos_hw_map+0x100>
	__asm__ __volatile__(
  4122f5:	49 8b 1e             	mov    rbx,QWORD PTR [r14]
  4122f8:	8b 45 b4             	mov    eax,DWORD PTR [rbp-0x4c]
  4122fb:	4b 8d 34 2a          	lea    rsi,[r10+r13*1]
  4122ff:	4b 8d 3c 3a          	lea    rdi,[r10+r15*1]
  412303:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  412307:	48 89 29             	mov    QWORD PTR [rcx],rbp
  41230a:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  41230e:	48 89 cd             	mov    rbp,rcx
  412311:	49 b8 28 23 41 00 00 	movabs r8,0x412328
  412318:	00 00 00 
  41231b:	0f 05                	syscall 
  41231d:	0f 1f 00             	nop    DWORD PTR [rax]
  412320:	eb 0d                	jmp    41232f <cos_hw_map+0xcf>
  412322:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  412328:	b9 00 00 00 00       	mov    ecx,0x0
  41232d:	eb 05                	jmp    412334 <cos_hw_map+0xd4>
  41232f:	b9 01 00 00 00       	mov    ecx,0x1
  412334:	5d                   	pop    rbp
  412335:	5c                   	pop    rsp
		if (call_cap_op(hwc, CAPTBL_OP_HW_MAP, ci->pgtbl_cap, va + i, pa + i, 0)) BUG();
  412336:	85 c0                	test   eax,eax
  412338:	74 ae                	je     4122e8 <cos_hw_map+0x88>
  41233a:	be 1c 00 00 00       	mov    esi,0x1c
  41233f:	bf 18 ea 41 00       	mov    edi,0x41ea18
  412344:	e8 87 7d ff ff       	call   40a0d0 <cos_print_str>
  412349:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412350:	00 00 00 00 
  412354:	0f 0b                	ud2    
  412356:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41235d:	00 00 00 
	}

	return (void *)va;
  412360:	4c 89 e8             	mov    rax,r13
}
  412363:	48 83 c4 28          	add    rsp,0x28
  412367:	5b                   	pop    rbx
  412368:	41 5c                	pop    r12
  41236a:	41 5d                	pop    r13
  41236c:	41 5e                	pop    r14
  41236e:	41 5f                	pop    r15
  412370:	5d                   	pop    rbp
  412371:	c3                   	ret    
  412372:	be 2f 00 00 00       	mov    esi,0x2f
  412377:	bf e8 e9 41 00       	mov    edi,0x41e9e8
  41237c:	e8 4f 7d ff ff       	call   40a0d0 <cos_print_str>
	assert(ci && hwc && pa && len);
  412381:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412388:	00 00 00 00 
  41238c:	0f 0b                	ud2    
	if (unlikely(!va)) return NULL;
  41238e:	31 c0                	xor    eax,eax
  412390:	eb d1                	jmp    412363 <cos_hw_map+0x103>
  412392:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  412399:	00 00 00 00 
  41239d:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004123a0 <cos_get_second_lvl>:


/* ----- Shared Pgtbl ------ */
int
cos_get_second_lvl(struct cos_compinfo *ci, capid_t *pgtbl_cap, vaddr_t *pgtbl_addr)
{
  4123a0:	f3 0f 1e fa          	endbr64 
	if(ci->mi.second_lvl_pgtbl_cap == 0) {
  4123a4:	48 8b 87 a0 00 00 00 	mov    rax,QWORD PTR [rdi+0xa0]
  4123ab:	48 85 c0             	test   rax,rax
  4123ae:	74 10                	je     4123c0 <cos_get_second_lvl+0x20>
		return -1;
	}
	*pgtbl_cap = ci->mi.second_lvl_pgtbl_cap;
  4123b0:	48 89 06             	mov    QWORD PTR [rsi],rax
	*pgtbl_addr = ci->mi.second_lvl_pgtbl_addr;
  4123b3:	48 8b 87 a8 00 00 00 	mov    rax,QWORD PTR [rdi+0xa8]
  4123ba:	48 89 02             	mov    QWORD PTR [rdx],rax

	return 0;
  4123bd:	31 c0                	xor    eax,eax
  4123bf:	c3                   	ret    
		return -1;
  4123c0:	b8 ff ff ff ff       	mov    eax,0xffffffff
}
  4123c5:	c3                   	ret    
  4123c6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4123cd:	00 00 00 

00000000004123d0 <cos_cons_into_shared_pgtbl>:

u32_t
cos_cons_into_shared_pgtbl(struct cos_compinfo *ci, pgtblcap_t top_lvl)
{
  4123d0:	f3 0f 1e fa          	endbr64 
  4123d4:	55                   	push   rbp
  4123d5:	48 89 e5             	mov    rbp,rsp
  4123d8:	41 54                	push   r12
  4123da:	53                   	push   rbx
  4123db:	48 83 ec 10          	sub    rsp,0x10
	if(ci->mi.second_lvl_pgtbl_cap == 0) {
  4123df:	48 8b 9f a0 00 00 00 	mov    rbx,QWORD PTR [rdi+0xa0]
  4123e6:	48 85 db             	test   rbx,rbx
  4123e9:	0f 84 7d 00 00 00    	je     41246c <cos_cons_into_shared_pgtbl+0x9c>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4123ef:	c1 e6 10             	shl    esi,0x10
	__asm__ __volatile__(
  4123f2:	31 d2                	xor    edx,edx
  4123f4:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
	cap_no += op;
  4123f8:	8d 86 01 00 01 00    	lea    eax,[rsi+0x10001]
	__asm__ __volatile__(
  4123fe:	48 8b b7 a8 00 00 00 	mov    rsi,QWORD PTR [rdi+0xa8]
  412405:	48 89 d7             	mov    rdi,rdx
  412408:	48 89 29             	mov    QWORD PTR [rcx],rbp
  41240b:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  41240f:	48 89 cd             	mov    rbp,rcx
  412412:	49 b8 28 24 41 00 00 	movabs r8,0x412428
  412419:	00 00 00 
  41241c:	0f 05                	syscall 
  41241e:	66 90                	xchg   ax,ax
  412420:	eb 0d                	jmp    41242f <cos_cons_into_shared_pgtbl+0x5f>
  412422:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  412428:	b9 00 00 00 00       	mov    ecx,0x0
  41242d:	eb 05                	jmp    412434 <cos_cons_into_shared_pgtbl+0x64>
  41242f:	b9 01 00 00 00       	mov    ecx,0x1
  412434:	5d                   	pop    rbp
  412435:	5c                   	pop    rsp
	if (call_cap_op(top_lvl, CAPTBL_OP_CONS, pte_cap, pgtbl_addr, 0, 0)) {
		assert(0); /* race? */
		return -1;
	}

	return 0;
  412436:	45 31 c0             	xor    r8d,r8d
	if (call_cap_op(top_lvl, CAPTBL_OP_CONS, pte_cap, pgtbl_addr, 0, 0)) {
  412439:	85 c0                	test   eax,eax
  41243b:	75 13                	jne    412450 <cos_cons_into_shared_pgtbl+0x80>

}
  41243d:	48 83 c4 10          	add    rsp,0x10
  412441:	44 89 c0             	mov    eax,r8d
  412444:	5b                   	pop    rbx
  412445:	41 5c                	pop    r12
  412447:	5d                   	pop    rbp
  412448:	c3                   	ret    
  412449:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  412450:	be 2f 00 00 00       	mov    esi,0x2f
  412455:	bf 38 ea 41 00       	mov    edi,0x41ea38
  41245a:	e8 71 7c ff ff       	call   40a0d0 <cos_print_str>
		assert(0); /* race? */
  41245f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412466:	00 00 00 00 
  41246a:	0f 0b                	ud2    
		return -1;
  41246c:	41 b8 ff ff ff ff    	mov    r8d,0xffffffff
  412472:	eb c9                	jmp    41243d <cos_cons_into_shared_pgtbl+0x6d>
  412474:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41247b:	00 00 00 
  41247e:	66 90                	xchg   ax,ax

0000000000412480 <slm_sched_fprr_execution>:
struct runqueue threads[NUM_CPU];

/* No RR based on execution, yet */
void
slm_sched_fprr_execution(struct slm_thd *t, cycles_t cycles)
{ return; }
  412480:	f3 0f 1e fa          	endbr64 
  412484:	c3                   	ret    
  412485:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41248c:	00 00 00 00 

0000000000412490 <slm_sched_fprr_schedule>:
	}
}

struct slm_thd *
slm_sched_fprr_schedule(void)
{
  412490:	f3 0f 1e fa          	endbr64 

#if ENABLE_DEBUG_INFO
	debug_dump_info();
#endif

	for (i = 0 ; i < SLM_FPRR_NPRIOS ; i++) {
  412494:	b8 00 0b 5a 00       	mov    eax,0x5a0b00
ps_list_head_init(struct ps_list_head *lh)
{ ps_list_ll_init(&lh->l); }

static inline int
ps_list_ll_empty(struct ps_list *l)
{ return l->n == l; }
  412499:	48 8b 38             	mov    rdi,QWORD PTR [rax]
		if (ps_list_head_empty(&prios[i])) continue;
  41249c:	48 39 f8             	cmp    rax,rdi
  41249f:	74 3f                	je     4124e0 <slm_sched_fprr_schedule+0x50>
}

static inline void
ps_list_ll_rem(struct ps_list *l)
{
	l->n->p = l->p;
  4124a1:	48 8b 0f             	mov    rcx,QWORD PTR [rdi]
  4124a4:	48 8b 57 08          	mov    rdx,QWORD PTR [rdi+0x8]
	l->p->n = l->n;
	l->p = l->n = l;
  4124a8:	66 48 0f 6e c7       	movq   xmm0,rdi
  4124ad:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
	l->n->p = l->p;
  4124b1:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
	l->p->n = l->n;
  4124b5:	48 89 0a             	mov    QWORD PTR [rdx],rcx
	l->p = l->n = l;
  4124b8:	0f 11 07             	movups XMMWORD PTR [rdi],xmm0
		/*
		 * We want to move the selected thread to the back of the list.
		 * Otherwise fprr won't be truly round robin
		 */
		ps_list_rem_d(t);
		ps_list_head_append_d(&prios[i], t);
  4124bb:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	new->n    = l->n;
  4124bf:	f3 0f 7e 00          	movq   xmm0,QWORD PTR [rax]
  4124c3:	66 48 0f 6e c8       	movq   xmm1,rax
  4124c8:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  4124cc:	0f 11 07             	movups XMMWORD PTR [rdi],xmm0
	l->n      = new;
  4124cf:	48 89 38             	mov    QWORD PTR [rax],rdi
	new->n->p = new;
  4124d2:	48 8b 07             	mov    rax,QWORD PTR [rdi]
  4124d5:	48 89 78 08          	mov    QWORD PTR [rax+0x8],rdi

//		printc("Schedule -> %ld\n", slm_thd_from_sched(t)->tid);
		return slm_thd_from_sched(t);
  4124d9:	e9 e2 f1 fe ff       	jmp    4016c0 <slm_thd_from_sched>
  4124de:	66 90                	xchg   ax,ax
	for (i = 0 ; i < SLM_FPRR_NPRIOS ; i++) {
  4124e0:	48 83 c0 10          	add    rax,0x10
  4124e4:	48 3d 00 0d 5a 00    	cmp    rax,0x5a0d00
  4124ea:	75 ad                	jne    412499 <slm_sched_fprr_schedule+0x9>
	}
//	printc("Schedule -> idle\n");

	return NULL;
}
  4124ec:	31 c0                	xor    eax,eax
  4124ee:	c3                   	ret    
  4124ef:	90                   	nop

00000000004124f0 <slm_sched_fprr_block>:

int
slm_sched_fprr_block(struct slm_thd *t)
{
  4124f0:	f3 0f 1e fa          	endbr64 
  4124f4:	55                   	push   rbp
  4124f5:	48 89 e5             	mov    rbp,rsp
	struct slm_sched_thd *p = slm_thd_sched_policy(t);
  4124f8:	e8 a3 f1 fe ff       	call   4016a0 <slm_thd_sched_policy>
	l->n->p = l->p;
  4124fd:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  412500:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
	l->p = l->n = l;
  412504:	66 48 0f 6e c0       	movq   xmm0,rax
  412509:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
	l->n->p = l->p;
  41250d:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
	l->p->n = l->n;
  412511:	48 89 0a             	mov    QWORD PTR [rdx],rcx
	l->p = l->n = l;
  412514:	0f 11 00             	movups XMMWORD PTR [rax],xmm0

	ps_list_rem_d(p);

	return 0;
}
  412517:	31 c0                	xor    eax,eax
  412519:	5d                   	pop    rbp
  41251a:	c3                   	ret    
  41251b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000412520 <slm_sched_fprr_wakeup>:

int
slm_sched_fprr_wakeup(struct slm_thd *t)
{
  412520:	f3 0f 1e fa          	endbr64 
  412524:	55                   	push   rbp
  412525:	48 89 e5             	mov    rbp,rsp
  412528:	53                   	push   rbx
  412529:	48 89 fb             	mov    rbx,rdi
  41252c:	48 83 ec 08          	sub    rsp,0x8
	struct slm_sched_thd *p = slm_thd_sched_policy(t);
  412530:	e8 6b f1 fe ff       	call   4016a0 <slm_thd_sched_policy>

	assert(ps_list_singleton_d(p));
  412535:	48 3b 00             	cmp    rax,QWORD PTR [rax]
  412538:	75 31                	jne    41256b <slm_sched_fprr_wakeup+0x4b>

	ps_list_head_append_d(&threads[cos_cpuid()].prio[t->priority - 1], p);
  41253a:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]

	return 0;
}
  41253e:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
	ps_list_head_append_d(&threads[cos_cpuid()].prio[t->priority - 1], p);
  412542:	48 c1 e2 04          	shl    rdx,0x4
  412546:	48 8b 92 f8 0a 5a 00 	mov    rdx,QWORD PTR [rdx+0x5a0af8]
	new->n    = l->n;
  41254d:	f3 0f 7e 02          	movq   xmm0,QWORD PTR [rdx]
  412551:	66 48 0f 6e ca       	movq   xmm1,rdx
  412556:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  41255a:	0f 11 00             	movups XMMWORD PTR [rax],xmm0
	l->n      = new;
  41255d:	48 89 02             	mov    QWORD PTR [rdx],rax
	new->n->p = new;
  412560:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  412563:	48 89 42 08          	mov    QWORD PTR [rdx+0x8],rax
}
  412567:	31 c0                	xor    eax,eax
  412569:	c9                   	leave  
  41256a:	c3                   	ret    
  41256b:	be 23 00 00 00       	mov    esi,0x23
  412570:	bf 88 ea 41 00       	mov    edi,0x41ea88
  412575:	e8 56 7b ff ff       	call   40a0d0 <cos_print_str>
	assert(ps_list_singleton_d(p));
  41257a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412581:	00 00 00 00 
  412585:	0f 0b                	ud2    
  412587:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41258e:	00 00 

0000000000412590 <slm_sched_fprr_yield>:

void
slm_sched_fprr_yield(struct slm_thd *t, struct slm_thd *yield_to)
{
  412590:	f3 0f 1e fa          	endbr64 
  412594:	55                   	push   rbp
  412595:	48 89 e5             	mov    rbp,rsp
  412598:	53                   	push   rbx
  412599:	48 89 fb             	mov    rbx,rdi
  41259c:	48 83 ec 08          	sub    rsp,0x8
	struct slm_sched_thd *p = slm_thd_sched_policy(t);
  4125a0:	e8 fb f0 fe ff       	call   4016a0 <slm_thd_sched_policy>
	l->n->p = l->p;
  4125a5:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  4125a9:	48 8b 08             	mov    rcx,QWORD PTR [rax]
	l->p = l->n = l;
  4125ac:	66 48 0f 6e c0       	movq   xmm0,rax
  4125b1:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
	l->n->p = l->p;
  4125b5:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
	l->p->n = l->n;
  4125b9:	48 89 0a             	mov    QWORD PTR [rdx],rcx

	ps_list_rem_d(p);
	ps_list_head_append_d(&threads[cos_cpuid()].prio[t->priority], p);
  4125bc:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]
	l->p = l->n = l;
  4125c0:	0f 11 00             	movups XMMWORD PTR [rax],xmm0
}
  4125c3:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
	ps_list_head_append_d(&threads[cos_cpuid()].prio[t->priority], p);
  4125c7:	48 c1 e2 04          	shl    rdx,0x4
  4125cb:	48 8b 92 08 0b 5a 00 	mov    rdx,QWORD PTR [rdx+0x5a0b08]
	new->n    = l->n;
  4125d2:	f3 0f 7e 02          	movq   xmm0,QWORD PTR [rdx]
  4125d6:	66 48 0f 6e ca       	movq   xmm1,rdx
  4125db:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  4125df:	0f 11 00             	movups XMMWORD PTR [rax],xmm0
	l->n      = new;
  4125e2:	48 89 02             	mov    QWORD PTR [rdx],rax
	new->n->p = new;
  4125e5:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  4125e8:	48 89 42 08          	mov    QWORD PTR [rdx+0x8],rax
}
  4125ec:	c9                   	leave  
  4125ed:	c3                   	ret    
  4125ee:	66 90                	xchg   ax,ax

00000000004125f0 <slm_sched_fprr_thd_init>:

int
slm_sched_fprr_thd_init(struct slm_thd *t)
{
  4125f0:	f3 0f 1e fa          	endbr64 
  4125f4:	55                   	push   rbp
	t->priority = SLM_FPRR_PRIO_LOWEST;
  4125f5:	48 c7 47 30 1f 00 00 	mov    QWORD PTR [rdi+0x30],0x1f
  4125fc:	00 
{
  4125fd:	48 89 e5             	mov    rbp,rsp
	ps_list_init_d(slm_thd_sched_policy(t));
  412600:	e8 9b f0 fe ff       	call   4016a0 <slm_thd_sched_policy>
{ l->n = l->p = l; }
  412605:	66 48 0f 6e c0       	movq   xmm0,rax
  41260a:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  41260e:	0f 11 00             	movups XMMWORD PTR [rax],xmm0

	return 0;
}
  412611:	31 c0                	xor    eax,eax
  412613:	5d                   	pop    rbp
  412614:	c3                   	ret    
  412615:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41261c:	00 00 00 00 

0000000000412620 <slm_sched_fprr_thd_deinit>:

void
slm_sched_fprr_thd_deinit(struct slm_thd *t)
{
  412620:	f3 0f 1e fa          	endbr64 
  412624:	55                   	push   rbp
  412625:	48 89 e5             	mov    rbp,rsp
	ps_list_rem_d(slm_thd_sched_policy(t));
  412628:	e8 73 f0 fe ff       	call   4016a0 <slm_thd_sched_policy>
	l->n->p = l->p;
  41262d:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  412630:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
	l->p = l->n = l;
  412634:	66 48 0f 6e c0       	movq   xmm0,rax
  412639:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
	l->n->p = l->p;
  41263d:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
	l->p->n = l->n;
  412641:	48 89 0a             	mov    QWORD PTR [rdx],rcx
	l->p = l->n = l;
  412644:	0f 11 00             	movups XMMWORD PTR [rax],xmm0
}
  412647:	5d                   	pop    rbp
  412648:	c3                   	ret    
  412649:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000412650 <slm_sched_fprr_thd_update>:
	return;
}

int
slm_sched_fprr_thd_update(struct slm_thd *t, sched_param_type_t type, unsigned int v)
{
  412650:	f3 0f 1e fa          	endbr64 
  412654:	55                   	push   rbp
  412655:	48 89 e5             	mov    rbp,rsp
  412658:	41 54                	push   r12
  41265a:	49 89 fc             	mov    r12,rdi
  41265d:	53                   	push   rbx
	switch (type) {
  41265e:	83 fe 0a             	cmp    esi,0xa
  412661:	74 1d                	je     412680 <slm_sched_fprr_thd_update+0x30>
  412663:	83 fe 0b             	cmp    esi,0xb
  412666:	0f 84 b4 00 00 00    	je     412720 <slm_sched_fprr_thd_update+0xd0>
  41266c:	b8 ff ff ff ff       	mov    eax,0xffffffff
  412671:	83 fe 01             	cmp    esi,0x1
  412674:	74 5a                	je     4126d0 <slm_sched_fprr_thd_update+0x80>
	}
	/* Only support priority, for now */
	default:
		return -1;
	}
}
  412676:	5b                   	pop    rbx
  412677:	41 5c                	pop    r12
  412679:	5d                   	pop    rbp
  41267a:	c3                   	ret    
  41267b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	struct slm_sched_thd *p = slm_thd_sched_policy(t);
  412680:	e8 1b f0 fe ff       	call   4016a0 <slm_thd_sched_policy>
	t->priority = prio;
  412685:	49 c7 44 24 30 00 00 	mov    QWORD PTR [r12+0x30],0x0
  41268c:	00 00 
	l->n->p = l->p;
  41268e:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  412692:	48 8b 08             	mov    rcx,QWORD PTR [rax]
	l->p = l->n = l;
  412695:	66 48 0f 6e c0       	movq   xmm0,rax
  41269a:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
	l->n->p = l->p;
  41269e:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
	l->p->n = l->n;
  4126a2:	48 89 0a             	mov    QWORD PTR [rdx],rcx
	l->p = l->n = l;
  4126a5:	0f 11 00             	movups XMMWORD PTR [rax],xmm0
	ps_list_head_append_d(&threads[cos_cpuid()].prio[prio], p);
  4126a8:	48 8b 15 59 e4 18 00 	mov    rdx,QWORD PTR [rip+0x18e459]        # 5a0b08 <threads+0x8>
	new->n    = l->n;
  4126af:	f3 0f 7e 02          	movq   xmm0,QWORD PTR [rdx]
  4126b3:	66 48 0f 6e ca       	movq   xmm1,rdx
  4126b8:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  4126bc:	0f 11 00             	movups XMMWORD PTR [rax],xmm0
	l->n      = new;
  4126bf:	48 89 02             	mov    QWORD PTR [rdx],rax
	new->n->p = new;
  4126c2:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  4126c5:	48 89 42 08          	mov    QWORD PTR [rdx+0x8],rax
		return 0;
  4126c9:	31 c0                	xor    eax,eax
}
  4126cb:	5b                   	pop    rbx
  4126cc:	41 5c                	pop    r12
  4126ce:	5d                   	pop    rbp
  4126cf:	c3                   	ret    
		assert(v >= SLM_FPRR_PRIO_HIGHEST && v <= SLM_FPRR_PRIO_LOWEST);
  4126d0:	8d 42 ff             	lea    eax,[rdx-0x1]
  4126d3:	83 f8 1e             	cmp    eax,0x1e
  4126d6:	0f 87 85 00 00 00    	ja     412761 <slm_sched_fprr_thd_update+0x111>
		update_queue(t, v);
  4126dc:	89 d3                	mov    ebx,edx
	struct slm_sched_thd *p = slm_thd_sched_policy(t);
  4126de:	e8 bd ef fe ff       	call   4016a0 <slm_thd_sched_policy>
	t->priority = prio;
  4126e3:	49 89 5c 24 30       	mov    QWORD PTR [r12+0x30],rbx
	ps_list_head_append_d(&threads[cos_cpuid()].prio[prio], p);
  4126e8:	48 c1 e3 04          	shl    rbx,0x4
	l->n->p = l->p;
  4126ec:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  4126f0:	48 8b 08             	mov    rcx,QWORD PTR [rax]
	l->p = l->n = l;
  4126f3:	66 48 0f 6e c0       	movq   xmm0,rax
  4126f8:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
	l->n->p = l->p;
  4126fc:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
	l->p->n = l->n;
  412700:	48 89 0a             	mov    QWORD PTR [rdx],rcx
	l->p = l->n = l;
  412703:	0f 11 00             	movups XMMWORD PTR [rax],xmm0
  412706:	48 8b 93 08 0b 5a 00 	mov    rdx,QWORD PTR [rbx+0x5a0b08]
	new->n    = l->n;
  41270d:	f3 0f 7e 02          	movq   xmm0,QWORD PTR [rdx]
  412711:	66 48 0f 6e da       	movq   xmm3,rdx
  412716:	66 0f 6c c3          	punpcklqdq xmm0,xmm3
  41271a:	eb a0                	jmp    4126bc <slm_sched_fprr_thd_update+0x6c>
  41271c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	struct slm_sched_thd *p = slm_thd_sched_policy(t);
  412720:	e8 7b ef fe ff       	call   4016a0 <slm_thd_sched_policy>
	t->priority = prio;
  412725:	49 c7 44 24 30 1f 00 	mov    QWORD PTR [r12+0x30],0x1f
  41272c:	00 00 
	l->n->p = l->p;
  41272e:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  412732:	48 8b 08             	mov    rcx,QWORD PTR [rax]
	l->p = l->n = l;
  412735:	66 48 0f 6e c0       	movq   xmm0,rax
  41273a:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
	l->n->p = l->p;
  41273e:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
	l->p->n = l->n;
  412742:	48 89 0a             	mov    QWORD PTR [rdx],rcx
	l->p = l->n = l;
  412745:	0f 11 00             	movups XMMWORD PTR [rax],xmm0
	ps_list_head_append_d(&threads[cos_cpuid()].prio[prio], p);
  412748:	48 8b 15 a9 e5 18 00 	mov    rdx,QWORD PTR [rip+0x18e5a9]        # 5a0cf8 <threads+0x1f8>
	new->n    = l->n;
  41274f:	f3 0f 7e 02          	movq   xmm0,QWORD PTR [rdx]
  412753:	66 48 0f 6e d2       	movq   xmm2,rdx
  412758:	66 0f 6c c2          	punpcklqdq xmm0,xmm2
  41275c:	e9 5b ff ff ff       	jmp    4126bc <slm_sched_fprr_thd_update+0x6c>
  412761:	be 24 00 00 00       	mov    esi,0x24
  412766:	bf b0 ea 41 00       	mov    edi,0x41eab0
  41276b:	e8 60 79 ff ff       	call   40a0d0 <cos_print_str>
		assert(v >= SLM_FPRR_PRIO_HIGHEST && v <= SLM_FPRR_PRIO_LOWEST);
  412770:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412777:	00 00 00 00 
  41277b:	0f 0b                	ud2    
  41277d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000412780 <slm_sched_fprr_init>:

void
slm_sched_fprr_init(void)
{
  412780:	f3 0f 1e fa          	endbr64 
{ l->n = l->p = l; }
  412784:	b8 00 0b 5a 00       	mov    eax,0x5a0b00
  412789:	66 48 0f 6e c0       	movq   xmm0,rax
	int i;

	for (i = 0 ; i < SLM_FPRR_NPRIOS ; i++) {
		ps_list_head_init(&threads[cos_cpuid()].prio[i]);
  41278e:	b8 10 0b 5a 00       	mov    eax,0x5a0b10
  412793:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  412797:	0f 29 05 62 e3 18 00 	movaps XMMWORD PTR [rip+0x18e362],xmm0        # 5a0b00 <threads>
  41279e:	66 48 0f 6e c0       	movq   xmm0,rax
  4127a3:	b8 20 0b 5a 00       	mov    eax,0x5a0b20
  4127a8:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  4127ac:	0f 29 05 5d e3 18 00 	movaps XMMWORD PTR [rip+0x18e35d],xmm0        # 5a0b10 <threads+0x10>
  4127b3:	66 48 0f 6e c0       	movq   xmm0,rax
  4127b8:	b8 30 0b 5a 00       	mov    eax,0x5a0b30
  4127bd:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  4127c1:	0f 29 05 58 e3 18 00 	movaps XMMWORD PTR [rip+0x18e358],xmm0        # 5a0b20 <threads+0x20>
  4127c8:	66 48 0f 6e c0       	movq   xmm0,rax
  4127cd:	b8 40 0b 5a 00       	mov    eax,0x5a0b40
  4127d2:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  4127d6:	0f 29 05 53 e3 18 00 	movaps XMMWORD PTR [rip+0x18e353],xmm0        # 5a0b30 <threads+0x30>
	for (i = 0 ; i < SLM_FPRR_NPRIOS ; i++) {
  4127dd:	66 48 0f 6e c0       	movq   xmm0,rax
		ps_list_head_init(&threads[cos_cpuid()].prio[i]);
  4127e2:	b8 50 0b 5a 00       	mov    eax,0x5a0b50
  4127e7:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  4127eb:	0f 29 05 4e e3 18 00 	movaps XMMWORD PTR [rip+0x18e34e],xmm0        # 5a0b40 <threads+0x40>
  4127f2:	66 48 0f 6e c0       	movq   xmm0,rax
  4127f7:	b8 60 0b 5a 00       	mov    eax,0x5a0b60
  4127fc:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  412800:	0f 29 05 49 e3 18 00 	movaps XMMWORD PTR [rip+0x18e349],xmm0        # 5a0b50 <threads+0x50>
  412807:	66 48 0f 6e c0       	movq   xmm0,rax
  41280c:	b8 70 0b 5a 00       	mov    eax,0x5a0b70
  412811:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  412815:	0f 29 05 44 e3 18 00 	movaps XMMWORD PTR [rip+0x18e344],xmm0        # 5a0b60 <threads+0x60>
  41281c:	66 48 0f 6e c0       	movq   xmm0,rax
  412821:	b8 80 0b 5a 00       	mov    eax,0x5a0b80
  412826:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  41282a:	0f 29 05 3f e3 18 00 	movaps XMMWORD PTR [rip+0x18e33f],xmm0        # 5a0b70 <threads+0x70>
  412831:	66 48 0f 6e c0       	movq   xmm0,rax
  412836:	b8 90 0b 5a 00       	mov    eax,0x5a0b90
  41283b:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  41283f:	0f 29 05 3a e3 18 00 	movaps XMMWORD PTR [rip+0x18e33a],xmm0        # 5a0b80 <threads+0x80>
  412846:	66 48 0f 6e c0       	movq   xmm0,rax
  41284b:	b8 a0 0b 5a 00       	mov    eax,0x5a0ba0
  412850:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  412854:	0f 29 05 35 e3 18 00 	movaps XMMWORD PTR [rip+0x18e335],xmm0        # 5a0b90 <threads+0x90>
  41285b:	66 48 0f 6e c0       	movq   xmm0,rax
  412860:	b8 b0 0b 5a 00       	mov    eax,0x5a0bb0
  412865:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  412869:	0f 29 05 30 e3 18 00 	movaps XMMWORD PTR [rip+0x18e330],xmm0        # 5a0ba0 <threads+0xa0>
  412870:	66 48 0f 6e c0       	movq   xmm0,rax
  412875:	b8 c0 0b 5a 00       	mov    eax,0x5a0bc0
  41287a:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  41287e:	0f 29 05 2b e3 18 00 	movaps XMMWORD PTR [rip+0x18e32b],xmm0        # 5a0bb0 <threads+0xb0>
  412885:	66 48 0f 6e c0       	movq   xmm0,rax
  41288a:	b8 d0 0b 5a 00       	mov    eax,0x5a0bd0
  41288f:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  412893:	0f 29 05 26 e3 18 00 	movaps XMMWORD PTR [rip+0x18e326],xmm0        # 5a0bc0 <threads+0xc0>
  41289a:	66 48 0f 6e c0       	movq   xmm0,rax
  41289f:	b8 e0 0b 5a 00       	mov    eax,0x5a0be0
  4128a4:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  4128a8:	0f 29 05 21 e3 18 00 	movaps XMMWORD PTR [rip+0x18e321],xmm0        # 5a0bd0 <threads+0xd0>
  4128af:	66 48 0f 6e c0       	movq   xmm0,rax
  4128b4:	b8 f0 0b 5a 00       	mov    eax,0x5a0bf0
  4128b9:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  4128bd:	0f 29 05 1c e3 18 00 	movaps XMMWORD PTR [rip+0x18e31c],xmm0        # 5a0be0 <threads+0xe0>
  4128c4:	66 48 0f 6e c0       	movq   xmm0,rax
  4128c9:	b8 00 0c 5a 00       	mov    eax,0x5a0c00
  4128ce:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  4128d2:	0f 29 05 17 e3 18 00 	movaps XMMWORD PTR [rip+0x18e317],xmm0        # 5a0bf0 <threads+0xf0>
  4128d9:	66 48 0f 6e c0       	movq   xmm0,rax
  4128de:	b8 10 0c 5a 00       	mov    eax,0x5a0c10
  4128e3:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  4128e7:	0f 29 05 12 e3 18 00 	movaps XMMWORD PTR [rip+0x18e312],xmm0        # 5a0c00 <threads+0x100>
  4128ee:	66 48 0f 6e c0       	movq   xmm0,rax
  4128f3:	b8 20 0c 5a 00       	mov    eax,0x5a0c20
  4128f8:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  4128fc:	0f 29 05 0d e3 18 00 	movaps XMMWORD PTR [rip+0x18e30d],xmm0        # 5a0c10 <threads+0x110>
  412903:	66 48 0f 6e c0       	movq   xmm0,rax
  412908:	b8 30 0c 5a 00       	mov    eax,0x5a0c30
  41290d:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  412911:	0f 29 05 08 e3 18 00 	movaps XMMWORD PTR [rip+0x18e308],xmm0        # 5a0c20 <threads+0x120>
  412918:	66 48 0f 6e c0       	movq   xmm0,rax
  41291d:	b8 40 0c 5a 00       	mov    eax,0x5a0c40
  412922:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  412926:	0f 29 05 03 e3 18 00 	movaps XMMWORD PTR [rip+0x18e303],xmm0        # 5a0c30 <threads+0x130>
  41292d:	66 48 0f 6e c0       	movq   xmm0,rax
  412932:	b8 50 0c 5a 00       	mov    eax,0x5a0c50
  412937:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  41293b:	0f 29 05 fe e2 18 00 	movaps XMMWORD PTR [rip+0x18e2fe],xmm0        # 5a0c40 <threads+0x140>
  412942:	66 48 0f 6e c0       	movq   xmm0,rax
  412947:	b8 60 0c 5a 00       	mov    eax,0x5a0c60
  41294c:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  412950:	0f 29 05 f9 e2 18 00 	movaps XMMWORD PTR [rip+0x18e2f9],xmm0        # 5a0c50 <threads+0x150>
  412957:	66 48 0f 6e c0       	movq   xmm0,rax
  41295c:	b8 70 0c 5a 00       	mov    eax,0x5a0c70
  412961:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  412965:	0f 29 05 f4 e2 18 00 	movaps XMMWORD PTR [rip+0x18e2f4],xmm0        # 5a0c60 <threads+0x160>
  41296c:	66 48 0f 6e c0       	movq   xmm0,rax
  412971:	b8 80 0c 5a 00       	mov    eax,0x5a0c80
  412976:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  41297a:	0f 29 05 ef e2 18 00 	movaps XMMWORD PTR [rip+0x18e2ef],xmm0        # 5a0c70 <threads+0x170>
  412981:	66 48 0f 6e c0       	movq   xmm0,rax
  412986:	b8 90 0c 5a 00       	mov    eax,0x5a0c90
  41298b:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  41298f:	0f 29 05 ea e2 18 00 	movaps XMMWORD PTR [rip+0x18e2ea],xmm0        # 5a0c80 <threads+0x180>
  412996:	66 48 0f 6e c0       	movq   xmm0,rax
  41299b:	b8 a0 0c 5a 00       	mov    eax,0x5a0ca0
  4129a0:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  4129a4:	0f 29 05 e5 e2 18 00 	movaps XMMWORD PTR [rip+0x18e2e5],xmm0        # 5a0c90 <threads+0x190>
  4129ab:	66 48 0f 6e c0       	movq   xmm0,rax
  4129b0:	b8 b0 0c 5a 00       	mov    eax,0x5a0cb0
  4129b5:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  4129b9:	0f 29 05 e0 e2 18 00 	movaps XMMWORD PTR [rip+0x18e2e0],xmm0        # 5a0ca0 <threads+0x1a0>
  4129c0:	66 48 0f 6e c0       	movq   xmm0,rax
  4129c5:	b8 c0 0c 5a 00       	mov    eax,0x5a0cc0
  4129ca:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  4129ce:	0f 29 05 db e2 18 00 	movaps XMMWORD PTR [rip+0x18e2db],xmm0        # 5a0cb0 <threads+0x1b0>
  4129d5:	66 48 0f 6e c0       	movq   xmm0,rax
  4129da:	b8 d0 0c 5a 00       	mov    eax,0x5a0cd0
  4129df:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  4129e3:	0f 29 05 d6 e2 18 00 	movaps XMMWORD PTR [rip+0x18e2d6],xmm0        # 5a0cc0 <threads+0x1c0>
  4129ea:	66 48 0f 6e c0       	movq   xmm0,rax
  4129ef:	b8 e0 0c 5a 00       	mov    eax,0x5a0ce0
  4129f4:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  4129f8:	0f 29 05 d1 e2 18 00 	movaps XMMWORD PTR [rip+0x18e2d1],xmm0        # 5a0cd0 <threads+0x1d0>
  4129ff:	66 48 0f 6e c0       	movq   xmm0,rax
  412a04:	b8 f0 0c 5a 00       	mov    eax,0x5a0cf0
  412a09:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  412a0d:	0f 29 05 cc e2 18 00 	movaps XMMWORD PTR [rip+0x18e2cc],xmm0        # 5a0ce0 <threads+0x1e0>
  412a14:	66 48 0f 6e c0       	movq   xmm0,rax
  412a19:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  412a1d:	0f 29 05 cc e2 18 00 	movaps XMMWORD PTR [rip+0x18e2cc],xmm0        # 5a0cf0 <threads+0x1f0>
	}
}
  412a24:	c3                   	ret    
  412a25:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  412a2c:	00 00 00 
  412a2f:	90                   	nop
#include <cos_debug.h>

/* Override this to do initialization before idle computation */
CWEAKSYMB void slm_idle_comp_initialization(void) { return; }
  412a30:	f3 0f 1e fa          	endbr64 
  412a34:	c3                   	ret    
  412a35:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  412a3c:	00 00 00 00 

0000000000412a40 <slm_idle_iteration>:
  412a40:	f3 0f 1e fa          	endbr64 
  412a44:	c3                   	ret    
  412a45:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  412a4c:	00 00 00 00 

0000000000412a50 <slm_idle>:
/* Override this to do repetitive computation in idle */
CWEAKSYMB void slm_idle_iteration(void) { return; }

void
slm_idle(void *d)
{
  412a50:	f3 0f 1e fa          	endbr64 
  412a54:	55                   	push   rbp
  412a55:	48 89 e5             	mov    rbp,rsp
	slm_idle_comp_initialization();
  412a58:	e8 d3 da fe ff       	call   400530 <slm_idle_comp_initialization>
  412a5d:	0f 1f 00             	nop    DWORD PTR [rax]

	while (1) {
		slm_idle_iteration();
  412a60:	e8 db ff ff ff       	call   412a40 <slm_idle_iteration>
	while (1) {
  412a65:	eb f9                	jmp    412a60 <slm_idle+0x10>
  412a67:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  412a6e:	00 00 

0000000000412a70 <__slm_timeout_update_idx>:
	return slm_thd_timer_policy((struct slm_thd *)a)->abs_wakeup <= slm_thd_timer_policy((struct slm_thd *)b)->abs_wakeup;
}

static void
__slm_timeout_update_idx(void *e, int pos)
{ slm_thd_timer_policy((struct slm_thd *)e)->timeout_idx = pos; }
  412a70:	f3 0f 1e fa          	endbr64 
  412a74:	55                   	push   rbp
  412a75:	48 89 e5             	mov    rbp,rsp
  412a78:	53                   	push   rbx
  412a79:	89 f3                	mov    ebx,esi
  412a7b:	48 83 ec 08          	sub    rsp,0x8
  412a7f:	e8 0c ec fe ff       	call   401690 <slm_thd_timer_policy>
  412a84:	89 18                	mov    DWORD PTR [rax],ebx
  412a86:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
  412a8a:	c9                   	leave  
  412a8b:	c3                   	ret    
  412a8c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000412a90 <__slm_timeout_compare_min>:
{
  412a90:	f3 0f 1e fa          	endbr64 
  412a94:	55                   	push   rbp
  412a95:	48 89 e5             	mov    rbp,rsp
  412a98:	41 54                	push   r12
  412a9a:	49 89 f4             	mov    r12,rsi
  412a9d:	53                   	push   rbx
	return slm_thd_timer_policy((struct slm_thd *)a)->abs_wakeup <= slm_thd_timer_policy((struct slm_thd *)b)->abs_wakeup;
  412a9e:	e8 ed eb fe ff       	call   401690 <slm_thd_timer_policy>
  412aa3:	4c 89 e7             	mov    rdi,r12
  412aa6:	48 8b 58 08          	mov    rbx,QWORD PTR [rax+0x8]
  412aaa:	e8 e1 eb fe ff       	call   401690 <slm_thd_timer_policy>
  412aaf:	48 3b 58 08          	cmp    rbx,QWORD PTR [rax+0x8]
}
  412ab3:	5b                   	pop    rbx
	return slm_thd_timer_policy((struct slm_thd *)a)->abs_wakeup <= slm_thd_timer_policy((struct slm_thd *)b)->abs_wakeup;
  412ab4:	0f 96 c0             	setbe  al
}
  412ab7:	41 5c                	pop    r12
  412ab9:	5d                   	pop    rbp
	return slm_thd_timer_policy((struct slm_thd *)a)->abs_wakeup <= slm_thd_timer_policy((struct slm_thd *)b)->abs_wakeup;
  412aba:	0f b6 c0             	movzx  eax,al
}
  412abd:	c3                   	ret    
  412abe:	66 90                	xchg   ax,ax

0000000000412ac0 <slm_timer_quantum_expire>:
{
  412ac0:	f3 0f 1e fa          	endbr64 
  412ac4:	55                   	push   rbp
  412ac5:	48 89 e5             	mov    rbp,rsp
  412ac8:	41 55                	push   r13
  412aca:	41 54                	push   r12
  412acc:	53                   	push   rbx
  412acd:	48 83 ec 08          	sub    rsp,0x8
	assert(now >= g->current_timeout);
  412ad1:	48 8b 15 18 e3 18 00 	mov    rdx,QWORD PTR [rip+0x18e318]        # 5a0df0 <__timer_globals+0xf0>
  412ad8:	48 39 fa             	cmp    rdx,rdi
  412adb:	0f 87 2f 01 00 00    	ja     412c10 <slm_timer_quantum_expire+0x150>
	offset = (now - g->current_timeout) % g->period;
  412ae1:	48 8b 35 00 e3 18 00 	mov    rsi,QWORD PTR [rip+0x18e300]        # 5a0de8 <__timer_globals+0xe8>
  412ae8:	48 89 f8             	mov    rax,rdi
  412aeb:	49 89 fd             	mov    r13,rdi
  412aee:	48 29 d0             	sub    rax,rdx
  412af1:	31 d2                	xor    edx,edx
  412af3:	48 f7 f6             	div    rsi
	next_timeout = now + (g->period - offset);
  412af6:	48 8d 0c 3e          	lea    rcx,[rsi+rdi*1]
  412afa:	48 89 c8             	mov    rax,rcx
  412afd:	48 29 d0             	sub    rax,rdx
	assert(next_timeout > now);
  412b00:	48 39 c7             	cmp    rdi,rax
  412b03:	0f 83 23 01 00 00    	jae    412c2c <slm_timer_quantum_expire+0x16c>
slm_timeout_set(cycles_t timeout)
{
	struct slm_global *g = slm_global();

	g->timeout_next = tcap_cyc2time(timeout);
	g->timer_next   = timeout;
  412b09:	48 85 c0             	test   rax,rax
  412b0c:	ba 01 00 00 00       	mov    edx,0x1
  412b11:	66 48 0f 6e c0       	movq   xmm0,rax
	while (heap_size(&g->h) > 0) {
  412b16:	bf 00 0d 5a 00       	mov    edi,0x5a0d00
  412b1b:	48 0f 45 d0          	cmovne rdx,rax
	g->current_timeout = next_timeout;
  412b1f:	48 89 05 ca e2 18 00 	mov    QWORD PTR [rip+0x18e2ca],rax        # 5a0df0 <__timer_globals+0xf0>
	g->timer_set    = 1;
  412b26:	c7 05 8c f4 18 00 01 	mov    DWORD PTR [rip+0x18f48c],0x1        # 5a1fbc <__slm_global+0xfc>
  412b2d:	00 00 00 
	g->timer_next   = timeout;
  412b30:	66 48 0f 6e ca       	movq   xmm1,rdx
  412b35:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  412b39:	0f 29 05 80 f4 18 00 	movaps XMMWORD PTR [rip+0x18f480],xmm0        # 5a1fc0 <__slm_global+0x100>
	while (heap_size(&g->h) > 0) {
  412b40:	e8 0b 22 00 00       	call   414d50 <heap_size>
  412b45:	85 c0                	test   eax,eax
  412b47:	7e 68                	jle    412bb1 <slm_timer_quantum_expire+0xf1>
		tp = heap_peek(&g->h);
  412b49:	bf 00 0d 5a 00       	mov    edi,0x5a0d00
  412b4e:	e8 0d 1f 00 00       	call   414a60 <heap_peek>
  412b53:	49 89 c4             	mov    r12,rax
		assert(tp);
  412b56:	48 85 c0             	test   rax,rax
  412b59:	74 7d                	je     412bd8 <slm_timer_quantum_expire+0x118>
		tt = slm_thd_timer_policy(tp);
  412b5b:	48 89 c7             	mov    rdi,rax
  412b5e:	e8 2d eb fe ff       	call   401690 <slm_thd_timer_policy>
  412b63:	48 89 c3             	mov    rbx,rax
		assert(tt && tt->timeout_idx > 0);
  412b66:	48 85 c0             	test   rax,rax
  412b69:	74 51                	je     412bbc <slm_timer_quantum_expire+0xfc>
  412b6b:	8b 00                	mov    eax,DWORD PTR [rax]
  412b6d:	85 c0                	test   eax,eax
  412b6f:	7e 4b                	jle    412bbc <slm_timer_quantum_expire+0xfc>
	return (s64_t)(g - l) > 0;
  412b71:	48 8b 43 08          	mov    rax,QWORD PTR [rbx+0x8]
  412b75:	4c 29 e8             	sub    rax,r13
		if (cycles_greater_than(tt->abs_wakeup, now)) break;
  412b78:	48 85 c0             	test   rax,rax
  412b7b:	7f 34                	jg     412bb1 <slm_timer_quantum_expire+0xf1>
		th = heap_highest(&g->h);
  412b7d:	bf 00 0d 5a 00       	mov    edi,0x5a0d00
  412b82:	e8 59 1d 00 00       	call   4148e0 <heap_highest>
		assert(th == tp);
  412b87:	49 39 c4             	cmp    r12,rax
  412b8a:	75 68                	jne    412bf4 <slm_timer_quantum_expire+0x134>
		tt->timeout_idx = -1;
  412b8c:	c7 03 ff ff ff ff    	mov    DWORD PTR [rbx],0xffffffff
		slm_thd_wakeup(th, 1);
  412b92:	4c 89 e7             	mov    rdi,r12
  412b95:	be 01 00 00 00       	mov    esi,0x1
		tt->abs_wakeup  = now;
  412b9a:	4c 89 6b 08          	mov    QWORD PTR [rbx+0x8],r13
		slm_thd_wakeup(th, 1);
  412b9e:	e8 8d 12 00 00       	call   413e30 <slm_thd_wakeup>
	while (heap_size(&g->h) > 0) {
  412ba3:	bf 00 0d 5a 00       	mov    edi,0x5a0d00
  412ba8:	e8 a3 21 00 00       	call   414d50 <heap_size>
  412bad:	85 c0                	test   eax,eax
  412baf:	7f 98                	jg     412b49 <slm_timer_quantum_expire+0x89>
}
  412bb1:	48 83 c4 08          	add    rsp,0x8
  412bb5:	5b                   	pop    rbx
  412bb6:	41 5c                	pop    r12
  412bb8:	41 5d                	pop    r13
  412bba:	5d                   	pop    rbp
  412bbb:	c3                   	ret    
  412bbc:	be 26 00 00 00       	mov    esi,0x26
  412bc1:	bf 50 eb 41 00       	mov    edi,0x41eb50
  412bc6:	e8 05 75 ff ff       	call   40a0d0 <cos_print_str>
		assert(tt && tt->timeout_idx > 0);
  412bcb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412bd2:	00 00 00 00 
  412bd6:	0f 0b                	ud2    
  412bd8:	be 26 00 00 00       	mov    esi,0x26
  412bdd:	bf 28 eb 41 00       	mov    edi,0x41eb28
  412be2:	e8 e9 74 ff ff       	call   40a0d0 <cos_print_str>
		assert(tp);
  412be7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412bee:	00 00 00 00 
  412bf2:	0f 0b                	ud2    
  412bf4:	be 26 00 00 00       	mov    esi,0x26
  412bf9:	bf 78 eb 41 00       	mov    edi,0x41eb78
  412bfe:	e8 cd 74 ff ff       	call   40a0d0 <cos_print_str>
		assert(th == tp);
  412c03:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412c0a:	00 00 00 00 
  412c0e:	0f 0b                	ud2    
  412c10:	be 26 00 00 00       	mov    esi,0x26
  412c15:	bf d8 ea 41 00       	mov    edi,0x41ead8
  412c1a:	e8 b1 74 ff ff       	call   40a0d0 <cos_print_str>
	assert(now >= g->current_timeout);
  412c1f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412c26:	00 00 00 00 
  412c2a:	0f 0b                	ud2    
  412c2c:	be 26 00 00 00       	mov    esi,0x26
  412c31:	bf 00 eb 41 00       	mov    edi,0x41eb00
  412c36:	e8 95 74 ff ff       	call   40a0d0 <cos_print_str>
	assert(next_timeout > now);
  412c3b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412c42:	00 00 00 00 
  412c46:	0f 0b                	ud2    
  412c48:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  412c4f:	00 

0000000000412c50 <slm_timer_quantum_add>:
{
  412c50:	f3 0f 1e fa          	endbr64 
  412c54:	55                   	push   rbp
  412c55:	48 89 e5             	mov    rbp,rsp
  412c58:	41 55                	push   r13
  412c5a:	49 89 f5             	mov    r13,rsi
  412c5d:	41 54                	push   r12
  412c5f:	49 89 fc             	mov    r12,rdi
  412c62:	53                   	push   rbx
  412c63:	48 83 ec 08          	sub    rsp,0x8
	struct slm_timer_thd *tt = slm_thd_timer_policy(t);
  412c67:	e8 24 ea fe ff       	call   401690 <slm_thd_timer_policy>
	assert(tt && tt->timeout_idx == -1);
  412c6c:	48 85 c0             	test   rax,rax
  412c6f:	74 35                	je     412ca6 <slm_timer_quantum_add+0x56>
  412c71:	83 38 ff             	cmp    DWORD PTR [rax],0xffffffff
  412c74:	48 89 c3             	mov    rbx,rax
  412c77:	75 2d                	jne    412ca6 <slm_timer_quantum_add+0x56>
	assert(heap_size(&g->h) < MAX_NUM_THREADS);
  412c79:	bf 00 0d 5a 00       	mov    edi,0x5a0d00
  412c7e:	e8 cd 20 00 00       	call   414d50 <heap_size>
  412c83:	83 f8 18             	cmp    eax,0x18
  412c86:	7f 3a                	jg     412cc2 <slm_timer_quantum_add+0x72>
	tt->abs_wakeup = absolute_timeout;
  412c88:	4c 89 6b 08          	mov    QWORD PTR [rbx+0x8],r13
	heap_add(&g->h, t);
  412c8c:	4c 89 e6             	mov    rsi,r12
  412c8f:	bf 00 0d 5a 00       	mov    edi,0x5a0d00
  412c94:	e8 17 1a 00 00       	call   4146b0 <heap_add>
}
  412c99:	48 83 c4 08          	add    rsp,0x8
  412c9d:	31 c0                	xor    eax,eax
  412c9f:	5b                   	pop    rbx
  412ca0:	41 5c                	pop    r12
  412ca2:	41 5d                	pop    r13
  412ca4:	5d                   	pop    rbp
  412ca5:	c3                   	ret    
  412ca6:	be 26 00 00 00       	mov    esi,0x26
  412cab:	bf a0 eb 41 00       	mov    edi,0x41eba0
  412cb0:	e8 1b 74 ff ff       	call   40a0d0 <cos_print_str>
	assert(tt && tt->timeout_idx == -1);
  412cb5:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412cbc:	00 00 00 00 
  412cc0:	0f 0b                	ud2    
  412cc2:	be 26 00 00 00       	mov    esi,0x26
  412cc7:	bf c8 eb 41 00       	mov    edi,0x41ebc8
  412ccc:	e8 ff 73 ff ff       	call   40a0d0 <cos_print_str>
	assert(heap_size(&g->h) < MAX_NUM_THREADS);
  412cd1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412cd8:	00 00 00 00 
  412cdc:	0f 0b                	ud2    
  412cde:	66 90                	xchg   ax,ax

0000000000412ce0 <slm_timer_quantum_cancel>:
{
  412ce0:	f3 0f 1e fa          	endbr64 
  412ce4:	55                   	push   rbp
  412ce5:	48 89 e5             	mov    rbp,rsp
  412ce8:	53                   	push   rbx
  412ce9:	48 83 ec 08          	sub    rsp,0x8
	struct slm_timer_thd *tt = slm_thd_timer_policy(t);
  412ced:	e8 9e e9 fe ff       	call   401690 <slm_thd_timer_policy>
	if (tt->timeout_idx == -1) return 0;
  412cf2:	83 38 ff             	cmp    DWORD PTR [rax],0xffffffff
  412cf5:	74 27                	je     412d1e <slm_timer_quantum_cancel+0x3e>
	assert(heap_size(&g->h));
  412cf7:	bf 00 0d 5a 00       	mov    edi,0x5a0d00
  412cfc:	48 89 c3             	mov    rbx,rax
  412cff:	e8 4c 20 00 00       	call   414d50 <heap_size>
  412d04:	85 c0                	test   eax,eax
  412d06:	74 1e                	je     412d26 <slm_timer_quantum_cancel+0x46>
	assert(tt->timeout_idx > 0);
  412d08:	8b 33                	mov    esi,DWORD PTR [rbx]
  412d0a:	85 f6                	test   esi,esi
  412d0c:	7e 34                	jle    412d42 <slm_timer_quantum_cancel+0x62>
	heap_remove(&g->h, tt->timeout_idx);
  412d0e:	bf 00 0d 5a 00       	mov    edi,0x5a0d00
  412d13:	e8 68 1f 00 00       	call   414c80 <heap_remove>
	tt->timeout_idx = -1;
  412d18:	c7 03 ff ff ff ff    	mov    DWORD PTR [rbx],0xffffffff
}
  412d1e:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
  412d22:	31 c0                	xor    eax,eax
  412d24:	c9                   	leave  
  412d25:	c3                   	ret    
  412d26:	be 27 00 00 00       	mov    esi,0x27
  412d2b:	bf f0 eb 41 00       	mov    edi,0x41ebf0
  412d30:	e8 9b 73 ff ff       	call   40a0d0 <cos_print_str>
	assert(heap_size(&g->h));
  412d35:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412d3c:	00 00 00 00 
  412d40:	0f 0b                	ud2    
  412d42:	be 27 00 00 00       	mov    esi,0x27
  412d47:	bf 18 ec 41 00       	mov    edi,0x41ec18
  412d4c:	e8 7f 73 ff ff       	call   40a0d0 <cos_print_str>
	assert(tt->timeout_idx > 0);
  412d51:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412d58:	00 00 00 00 
  412d5c:	0f 0b                	ud2    
  412d5e:	66 90                	xchg   ax,ax

0000000000412d60 <slm_timer_quantum_thd_init>:
{
  412d60:	f3 0f 1e fa          	endbr64 
  412d64:	55                   	push   rbp
  412d65:	48 89 e5             	mov    rbp,rsp
	struct slm_timer_thd *tt = slm_thd_timer_policy(t);
  412d68:	e8 23 e9 fe ff       	call   401690 <slm_thd_timer_policy>
	*tt = (struct slm_timer_thd){
  412d6d:	c7 00 ff ff ff ff    	mov    DWORD PTR [rax],0xffffffff
  412d73:	48 c7 40 08 00 00 00 	mov    QWORD PTR [rax+0x8],0x0
  412d7a:	00 
}
  412d7b:	31 c0                	xor    eax,eax
  412d7d:	5d                   	pop    rbp
  412d7e:	c3                   	ret    
  412d7f:	90                   	nop

0000000000412d80 <slm_timer_quantum_thd_deinit>:
{
  412d80:	f3 0f 1e fa          	endbr64 
}
  412d84:	c3                   	ret    
  412d85:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  412d8c:	00 00 00 00 

0000000000412d90 <slm_timer_quantum_init>:
	slm_timeout_set(next_timeout);
}

int
slm_timer_quantum_init(void)
{
  412d90:	f3 0f 1e fa          	endbr64 
	memset(g, 0, sizeof(struct timer_global));
  412d94:	ba 00 0d 5a 00       	mov    edx,0x5a0d00
  412d99:	31 c0                	xor    eax,eax
  412d9b:	b9 20 00 00 00       	mov    ecx,0x20
{
  412da0:	55                   	push   rbp
	memset(g, 0, sizeof(struct timer_global));
  412da1:	48 89 d7             	mov    rdi,rdx
	heap_init(&g->h, MAX_NUM_THREADS, __slm_timeout_compare_min, __slm_timeout_update_idx);
  412da4:	be 19 00 00 00       	mov    esi,0x19
  412da9:	ba 90 2a 41 00       	mov    edx,0x412a90
	memset(g, 0, sizeof(struct timer_global));
  412dae:	f3 48 ab             	rep stos QWORD PTR es:[rdi],rax
	return usec * slm_global()->cyc_per_usec;
  412db1:	48 63 05 00 f2 18 00 	movsxd rax,DWORD PTR [rip+0x18f200]        # 5a1fb8 <__slm_global+0xf8>
	heap_init(&g->h, MAX_NUM_THREADS, __slm_timeout_compare_min, __slm_timeout_update_idx);
  412db8:	b9 70 2a 41 00       	mov    ecx,0x412a70
  412dbd:	bf 00 0d 5a 00       	mov    edi,0x5a0d00
{
  412dc2:	48 89 e5             	mov    rbp,rsp
  412dc5:	48 69 c0 10 27 00 00 	imul   rax,rax,0x2710
	g->period = slm_usec2cyc(period);
  412dcc:	48 89 05 15 e0 18 00 	mov    QWORD PTR [rip+0x18e015],rax        # 5a0de8 <__timer_globals+0xe8>
	heap_init(&g->h, MAX_NUM_THREADS, __slm_timeout_compare_min, __slm_timeout_update_idx);
  412dd3:	e8 38 18 00 00       	call   414610 <heap_init>
	__asm__ __volatile__("rdtsc" : "=a" (a), "=d" (d), "=c" (c) : : );
  412dd8:	0f 31                	rdtsc  
	g->timer_set    = 1;
  412dda:	c7 05 d8 f1 18 00 01 	mov    DWORD PTR [rip+0x18f1d8],0x1        # 5a1fbc <__slm_global+0xfc>
  412de1:	00 00 00 
	return ((u64_t)d << 32) | (u64_t)a;
  412de4:	48 c1 e2 20          	shl    rdx,0x20
	/* 10ms */
	slm_policy_timer_init(10000);

	return 0;
}
  412de8:	5d                   	pop    rbp
  412de9:	48 09 c2             	or     rdx,rax
	next_timeout = slm_now() + g->period;
  412dec:	48 89 d0             	mov    rax,rdx
	g->timer_next   = timeout;
  412def:	ba 01 00 00 00       	mov    edx,0x1
  412df4:	48 03 05 ed df 18 00 	add    rax,QWORD PTR [rip+0x18dfed]        # 5a0de8 <__timer_globals+0xe8>
  412dfb:	48 0f 45 d0          	cmovne rdx,rax
  412dff:	66 48 0f 6e c0       	movq   xmm0,rax
	g->current_timeout = next_timeout;
  412e04:	48 89 05 e5 df 18 00 	mov    QWORD PTR [rip+0x18dfe5],rax        # 5a0df0 <__timer_globals+0xf0>
}
  412e0b:	31 c0                	xor    eax,eax
  412e0d:	66 48 0f 6e ca       	movq   xmm1,rdx
  412e12:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  412e16:	0f 29 05 a3 f1 18 00 	movaps XMMWORD PTR [rip+0x18f1a3],xmm0        # 5a1fc0 <__slm_global+0x100>
  412e1d:	c3                   	ret    
  412e1e:	66 90                	xchg   ax,ax

0000000000412e20 <prints.isra.0>:
prints(char *s)
  412e20:	55                   	push   rbp
  412e21:	48 89 e5             	mov    rbp,rsp
  412e24:	41 54                	push   r12
  412e26:	49 89 fc             	mov    r12,rdi
  412e29:	48 83 ec 08          	sub    rsp,0x8
	return cos_print_str(s, strlen(s));
  412e2d:	e8 9e 2b 00 00       	call   4159d0 <strlen>
  412e32:	4c 89 e7             	mov    rdi,r12
}
  412e35:	4c 8b 65 f8          	mov    r12,QWORD PTR [rbp-0x8]
  412e39:	c9                   	leave  
	return cos_print_str(s, strlen(s));
  412e3a:	89 c6                	mov    esi,eax
  412e3c:	e9 8f 72 ff ff       	jmp    40a0d0 <cos_print_str>
  412e41:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  412e48:	00 00 00 00 
  412e4c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000412e50 <slm_sched_loop_intern>:
	return (unsigned long)g->cyc_per_usec;
}

static void
slm_sched_loop_intern(int non_block)
{
  412e50:	55                   	push   rbp
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  412e51:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  412e54:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  412e5a:	48 89 e5             	mov    rbp,rsp
  412e5d:	41 57                	push   r15
  412e5f:	41 56                	push   r14
  412e61:	41 55                	push   r13
  412e63:	41 54                	push   r12
  412e65:	53                   	push   rbx
  412e66:	48 83 ec 38          	sub    rsp,0x38
	return cos_get_thd_id();
  412e6a:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
	rcv_flags_t      rfl = (non_block ? RCV_NON_BLOCKING : 0) | RCV_ALL_PENDING;
	struct slm_thd   *us = &g->sched_thd;
	struct slm_thd *t = NULL, *tn = NULL;

	/* Only the scheduler thread should call this function. */
	assert(cos_thdid() == us->tid);
  412e71:	48 39 05 68 f0 18 00 	cmp    QWORD PTR [rip+0x18f068],rax        # 5a1ee0 <__slm_global+0x20>
  412e78:	0f 85 a9 04 00 00    	jne    413327 <slm_sched_loop_intern+0x4d7>
  412e7e:	44 8d 67 02          	lea    r12d,[rdi+0x2]
  412e82:	4c 8d 7d c8          	lea    r15,[rbp-0x38]
	return !ps_cas(&cs->owner_contention, (unsigned long)cached, ((unsigned long)thd | !!contention));
  412e86:	bb c8 1e 5a 00       	mov    ebx,0x5a1ec8
			 * if `non_block` is `0`.
			 *
			 * Important that this is *not* in the CS due
			 * to the potential blocking.
			 */
			pending = cos_sched_rcv(us->rcv, rfl, g->timeout_next, &rcvd, &tid, &blocked, &cycles, &thd_timeout);
  412e8b:	48 8d 45 c0          	lea    rax,[rbp-0x40]
  412e8f:	41 57                	push   r15
  412e91:	48 8b 3d 50 f0 18 00 	mov    rdi,QWORD PTR [rip+0x18f050]        # 5a1ee8 <__slm_global+0x28>
  412e98:	44 89 e6             	mov    esi,r12d
  412e9b:	50                   	push   rax
  412e9c:	48 8b 15 25 f1 18 00 	mov    rdx,QWORD PTR [rip+0x18f125]        # 5a1fc8 <__slm_global+0x108>
  412ea3:	48 8d 4d b4          	lea    rcx,[rbp-0x4c]
  412ea7:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  412eab:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  412eaf:	e8 9c e5 ff ff       	call   411450 <cos_sched_rcv>
			if (!tid) goto pending_events;
  412eb4:	48 8b 7d b8          	mov    rdi,QWORD PTR [rbp-0x48]
  412eb8:	59                   	pop    rcx
			pending = cos_sched_rcv(us->rcv, rfl, g->timeout_next, &rcvd, &tid, &blocked, &cycles, &thd_timeout);
  412eb9:	89 45 ac             	mov    DWORD PTR [rbp-0x54],eax
			if (!tid) goto pending_events;
  412ebc:	5e                   	pop    rsi
  412ebd:	48 85 ff             	test   rdi,rdi
  412ec0:	74 51                	je     412f13 <slm_sched_loop_intern+0xc3>
			 * pointer back here that we can use instead
			 * of the tid. This is the only place where
			 * slm requires the thread id -> thread
			 * mapping ;-(
			 */
			t = slm_thd_lookup(tid);
  412ec2:	e8 f9 e8 fe ff       	call   4017c0 <slm_thd_lookup>
			assert(t);
  412ec7:	48 85 c0             	test   rax,rax
  412eca:	0f 84 85 04 00 00    	je     413355 <slm_sched_loop_intern+0x505>
			/* don't report the idle thread or a freed thread */
			if (unlikely(t == &g->idle_thd || slm_state_is_dead(t->state))) goto pending_events;
  412ed0:	48 3d 40 1f 5a 00    	cmp    rax,0x5a1f40
  412ed6:	74 3b                	je     412f13 <slm_sched_loop_intern+0xc3>
  412ed8:	f7 40 04 fb ff ff ff 	test   DWORD PTR [rax+0x4],0xfffffffb
  412edf:	74 32                	je     412f13 <slm_sched_loop_intern+0xc3>
			 * allow the scheduler thread to switch to the
			 * CS holder, and switch back when the CS
			 * holder releases the CS (thus allowing the
			 * events to be processed at that point.
			 */
			slm_thd_event_enqueue(t, blocked, cycles, thd_timeout);
  412ee1:	48 8b 75 c8          	mov    rsi,QWORD PTR [rbp-0x38]
  412ee5:	48 8b 55 c0          	mov    rdx,QWORD PTR [rbp-0x40]
	if (ps_list_singleton(t, thd_list)) ps_list_head_append(&g->event_head, t, thd_list);
  412ee9:	48 8d 48 58          	lea    rcx,[rax+0x58]
			slm_thd_event_enqueue(t, blocked, cycles, thd_timeout);
  412eed:	8b 7d b0             	mov    edi,DWORD PTR [rbp-0x50]
	if (ps_list_singleton(t, thd_list)) ps_list_head_append(&g->event_head, t, thd_list);
  412ef0:	48 3b 48 58          	cmp    rcx,QWORD PTR [rax+0x58]
  412ef4:	0f 84 3d 03 00 00    	je     413237 <slm_sched_loop_intern+0x3e7>
	t->event_info.cycles += cycles;
  412efa:	48 03 50 48          	add    rdx,QWORD PTR [rax+0x48]
  412efe:	66 48 0f 6e ce       	movq   xmm1,rsi
	t->event_info.blocked = blocked;
  412f03:	89 78 40             	mov    DWORD PTR [rax+0x40],edi
	t->event_info.cycles += cycles;
  412f06:	66 48 0f 6e c2       	movq   xmm0,rdx
  412f0b:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  412f0f:	0f 11 40 48          	movups XMMWORD PTR [rax+0x48],xmm0

pending_events:
			/* No events? make a scheduling decision */
			if (ps_list_head_empty(&g->event_head)) break;
  412f13:	48 81 3d b2 f0 18 00 	cmp    QWORD PTR [rip+0x18f0b2],0x5a1fd0        # 5a1fd0 <__slm_global+0x110>
  412f1a:	d0 1f 5a 00 
  412f1e:	0f 84 8c 01 00 00    	je     4130b0 <slm_sched_loop_intern+0x260>
		tok    = cos_sched_sync();
  412f24:	e8 d7 e3 ff ff       	call   411300 <cos_sched_sync>
  412f29:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  412f2b:	48 8b 05 8e ef 18 00 	mov    rax,QWORD PTR [rip+0x18ef8e]        # 5a1ec0 <__slm_global>
		if (unlikely(owner)) {
  412f32:	48 89 c2             	mov    rdx,rax
  412f35:	48 83 e2 fe          	and    rdx,0xfffffffffffffffe
  412f39:	0f 85 21 03 00 00    	jne    413260 <slm_sched_loop_intern+0x410>
        __asm__ __volatile__("lock " PS_CAS_STR
  412f3f:	f0 48 0f b1 1d 78 ef 	lock cmpxchg QWORD PTR [rip+0x18ef78],rbx        # 5a1ec0 <__slm_global>
  412f46:	18 00 
  412f48:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  412f4b:	84 c0                	test   al,al
  412f4d:	74 d5                	je     412f24 <slm_sched_loop_intern+0xd4>
			 *
			 * Thus we process the events now, with the CS taken.
			 */
			if (slm_cs_enter(us, SLM_CS_SCHEDEVT)) continue;

			ps_list_foreach_del(&g->event_head, t, tn, thd_list) {
  412f4f:	48 8b 15 7a f0 18 00 	mov    rdx,QWORD PTR [rip+0x18f07a]        # 5a1fd0 <__slm_global+0x110>
  412f56:	48 8b 02             	mov    rax,QWORD PTR [rdx]
  412f59:	4c 8d 72 a8          	lea    r14,[rdx-0x58]
  412f5d:	4c 8d 68 a8          	lea    r13,[rax-0x58]
  412f61:	48 81 fa d0 1f 5a 00 	cmp    rdx,0x5a1fd0
  412f68:	0f 84 e5 00 00 00    	je     413053 <slm_sched_loop_intern+0x203>
	l->n->p = l->p;
  412f6e:	49 8b 56 60          	mov    rdx,QWORD PTR [r14+0x60]
	ps_list_rem(t, thd_list);
  412f72:	49 8d 4e 58          	lea    rcx,[r14+0x58]
	*cycles  = t->event_info.cycles;
  412f76:	49 8b 76 48          	mov    rsi,QWORD PTR [r14+0x48]
	ps_list_rem(t, thd_list);
  412f7a:	66 48 0f 6e c1       	movq   xmm0,rcx
  412f7f:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
	l->p = l->n = l;
  412f83:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
	l->p->n = l->n;
  412f87:	48 89 02             	mov    QWORD PTR [rdx],rax
	*blocked = t->event_info.blocked;
  412f8a:	41 8b 46 40          	mov    eax,DWORD PTR [r14+0x40]
	l->p = l->n = l;
  412f8e:	41 0f 11 46 58       	movups XMMWORD PTR [r14+0x58],xmm0
	memset(&t->event_info, 0, sizeof(struct event_info));
  412f93:	66 0f ef c0          	pxor   xmm0,xmm0
	*blocked = t->event_info.blocked;
  412f97:	89 45 b0             	mov    DWORD PTR [rbp-0x50],eax
	*timeout = t->event_info.timeout;
  412f9a:	49 8b 46 50          	mov    rax,QWORD PTR [r14+0x50]
	*cycles  = t->event_info.cycles;
  412f9e:	48 89 75 c0          	mov    QWORD PTR [rbp-0x40],rsi
	*timeout = t->event_info.timeout;
  412fa2:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
	memset(&t->event_info, 0, sizeof(struct event_info));
  412fa6:	49 c7 46 50 00 00 00 	mov    QWORD PTR [r14+0x50],0x0
  412fad:	00 
  412fae:	41 0f 11 46 40       	movups XMMWORD PTR [r14+0x40],xmm0
				/* remove the event from the list and get event info */
				slm_thd_event_dequeue(t, &blocked, &cycles, &thd_timeout);

				/* outdated event for a freed thread */
				if (unlikely(slm_state_is_dead(t->state))) continue;
  412fb3:	41 f7 46 04 fb ff ff 	test   DWORD PTR [r14+0x4],0xfffffffb
  412fba:	ff 
  412fbb:	74 64                	je     413021 <slm_sched_loop_intern+0x1d1>

				/* Notify the policy that some execution has happened. */
				slm_sched_execution(t, cycles);
  412fbd:	4c 89 f7             	mov    rdi,r14
  412fc0:	e8 eb e7 fe ff       	call   4017b0 <slm_sched_execution>

				if (blocked) {
  412fc5:	8b 55 b0             	mov    edx,DWORD PTR [rbp-0x50]
  412fc8:	85 d2                	test   edx,edx
  412fca:	0f 84 cd 01 00 00    	je     41319d <slm_sched_loop_intern+0x34d>
					assert(cycles);
  412fd0:	48 83 7d c0 00       	cmp    QWORD PTR [rbp-0x40],0x0
  412fd5:	0f 84 63 03 00 00    	je     41333e <slm_sched_loop_intern+0x4ee>
	assert(slm_state_is_runnable(t->state) || t->state == SLM_THD_BLOCKED);
  412fdb:	41 8b 46 04          	mov    eax,DWORD PTR [r14+0x4]
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  412fdf:	8d 50 fe             	lea    edx,[rax-0x2]
  412fe2:	83 e8 01             	sub    eax,0x1
  412fe5:	83 f8 02             	cmp    eax,0x2
  412fe8:	0f 87 82 04 00 00    	ja     413470 <slm_sched_loop_intern+0x620>
	return t != &g->idle_thd && t != &g->sched_thd;
  412fee:	49 81 fe 40 1f 5a 00 	cmp    r14,0x5a1f40
  412ff5:	0f 84 20 02 00 00    	je     41321b <slm_sched_loop_intern+0x3cb>
  412ffb:	49 81 fe c8 1e 5a 00 	cmp    r14,0x5a1ec8
  413002:	0f 84 13 02 00 00    	je     41321b <slm_sched_loop_intern+0x3cb>
	if (likely(slm_state_is_runnable(t->state))) {
  413008:	83 fa 01             	cmp    edx,0x1
  41300b:	77 08                	ja     413015 <slm_sched_loop_intern+0x1c5>
		slm_sched_block(t);
  41300d:	4c 89 f7             	mov    rdi,r14
  413010:	e8 5b e7 fe ff       	call   401770 <slm_sched_block>
	t->properties |= SLM_THD_PROPERTY_SUSPENDED;
  413015:	41 83 0e 04          	or     DWORD PTR [r14],0x4
	t->state       = SLM_THD_BLOCKED;
  413019:	41 c7 46 04 01 00 00 	mov    DWORD PTR [r14+0x4],0x1
  413020:	00 
			ps_list_foreach_del(&g->event_head, t, tn, thd_list) {
  413021:	49 8b 45 58          	mov    rax,QWORD PTR [r13+0x58]
  413025:	4d 89 ee             	mov    r14,r13
  413028:	48 8d 50 a8          	lea    rdx,[rax-0x58]
  41302c:	49 81 fd 78 1f 5a 00 	cmp    r13,0x5a1f78
  413033:	74 1e                	je     413053 <slm_sched_loop_intern+0x203>
  413035:	49 89 d5             	mov    r13,rdx
  413038:	e9 31 ff ff ff       	jmp    412f6e <slm_sched_loop_intern+0x11e>
  41303d:	0f 1f 00             	nop    DWORD PTR [rax]
  413040:	48 89 d0             	mov    rax,rdx
  413043:	f0 48 0f b1 35 74 ee 	lock cmpxchg QWORD PTR [rip+0x18ee74],rsi        # 5a1ec0 <__slm_global>
  41304a:	18 00 
  41304c:	0f 94 c0             	sete   al
	while (ret != 0) {
  41304f:	84 c0                	test   al,al
  413051:	75 4a                	jne    41309d <slm_sched_loop_intern+0x24d>
		tok    = cos_sched_sync();
  413053:	e8 a8 e2 ff ff       	call   411300 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  413058:	48 8b 15 61 ee 18 00 	mov    rdx,QWORD PTR [rip+0x18ee61]        # 5a1ec0 <__slm_global>
  41305f:	89 c1                	mov    ecx,eax
		if (unlikely(contention)) {
  413061:	48 89 d6             	mov    rsi,rdx
  413064:	83 e6 01             	and    esi,0x1
  413067:	74 d7                	je     413040 <slm_sched_loop_intern+0x1f0>
  413069:	31 ff                	xor    edi,edi
  41306b:	48 89 d0             	mov    rax,rdx
  41306e:	f0 48 0f b1 3d 49 ee 	lock cmpxchg QWORD PTR [rip+0x18ee49],rdi        # 5a1ec0 <__slm_global>
  413075:	18 00 
  413077:	0f 94 c0             	sete   al
	if (__slm_cs_cas(cs, cached, NULL, 0)) return 1;
  41307a:	84 c0                	test   al,al
  41307c:	74 d5                	je     413053 <slm_sched_loop_intern+0x203>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  41307e:	48 83 e2 fe          	and    rdx,0xfffffffffffffffe
	ret = cos_defswitch(s->thd, curr->priority, TCAP_TIME_NIL, tok);
  413082:	48 8b 3d 4f ee 18 00 	mov    rdi,QWORD PTR [rip+0x18ee4f]        # 5a1ed8 <__slm_global+0x18>
  413089:	48 8b 72 30          	mov    rsi,QWORD PTR [rdx+0x30]
  41308d:	31 d2                	xor    edx,edx
  41308f:	e8 cc 96 ff ff       	call   40c760 <cos_defswitch>
	assert(ret != -EINVAL);
  413094:	83 f8 ea             	cmp    eax,0xffffffea
  413097:	0f 84 e4 00 00 00    	je     413181 <slm_sched_loop_intern+0x331>
					slm_thd_sched_wakeup(t);
				}
			}

			slm_cs_exit(us, SLM_CS_NONE);
		} while (pending > 0);
  41309d:	8b 45 ac             	mov    eax,DWORD PTR [rbp-0x54]
  4130a0:	85 c0                	test   eax,eax
  4130a2:	0f 8f e3 fd ff ff    	jg     412e8b <slm_sched_loop_intern+0x3b>
  4130a8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4130af:	00 
		tok    = cos_sched_sync();
  4130b0:	e8 4b e2 ff ff       	call   411300 <cos_sched_sync>
  4130b5:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4130b7:	48 8b 05 02 ee 18 00 	mov    rax,QWORD PTR [rip+0x18ee02]        # 5a1ec0 <__slm_global>
		if (unlikely(owner)) {
  4130be:	48 89 c2             	mov    rdx,rax
  4130c1:	48 83 e2 fe          	and    rdx,0xfffffffffffffffe
  4130c5:	0f 85 11 01 00 00    	jne    4131dc <slm_sched_loop_intern+0x38c>
  4130cb:	f0 48 0f b1 1d ec ed 	lock cmpxchg QWORD PTR [rip+0x18edec],rbx        # 5a1ec0 <__slm_global>
  4130d2:	18 00 
  4130d4:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4130d7:	84 c0                	test   al,al
  4130d9:	74 d5                	je     4130b0 <slm_sched_loop_intern+0x260>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  4130db:	e8 80 87 ff ff       	call   40b860 <cos_defcompinfo_curr_get>
	tok  = cos_sched_sync();
  4130e0:	e8 1b e2 ff ff       	call   411300 <cos_sched_sync>
	if (flags & SLM_CS_CHECK_TIMEOUT && g->timer_set) {
  4130e5:	83 3d d0 ee 18 00 00 	cmp    DWORD PTR [rip+0x18eed0],0x0        # 5a1fbc <__slm_global+0xfc>
	tok  = cos_sched_sync();
  4130ec:	41 89 c6             	mov    r14d,eax
	if (flags & SLM_CS_CHECK_TIMEOUT && g->timer_set) {
  4130ef:	0f 85 77 02 00 00    	jne    41336c <slm_sched_loop_intern+0x51c>
	t = slm_sched_schedule();
  4130f5:	e8 a6 e6 fe ff       	call   4017a0 <slm_sched_schedule>
  4130fa:	49 89 c5             	mov    r13,rax
	if (unlikely(!t)) t = &g->idle_thd;
  4130fd:	48 85 c0             	test   rax,rax
  413100:	0f 84 de 02 00 00    	je     4133e4 <slm_sched_loop_intern+0x594>
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  413106:	41 8b 45 04          	mov    eax,DWORD PTR [r13+0x4]
  41310a:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  41310d:	83 f8 01             	cmp    eax,0x1
  413110:	76 25                	jbe    413137 <slm_sched_loop_intern+0x2e7>
  413112:	e9 b1 02 00 00       	jmp    4133c8 <slm_sched_loop_intern+0x578>
  413117:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41311e:	00 00 
  413120:	48 89 d0             	mov    rax,rdx
  413123:	f0 48 0f b1 35 94 ed 	lock cmpxchg QWORD PTR [rip+0x18ed94],rsi        # 5a1ec0 <__slm_global>
  41312a:	18 00 
  41312c:	0f 94 c0             	sete   al
	while (ret != 0) {
  41312f:	84 c0                	test   al,al
  413131:	0f 85 68 01 00 00    	jne    41329f <slm_sched_loop_intern+0x44f>
		tok    = cos_sched_sync();
  413137:	e8 c4 e1 ff ff       	call   411300 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  41313c:	48 8b 15 7d ed 18 00 	mov    rdx,QWORD PTR [rip+0x18ed7d]        # 5a1ec0 <__slm_global>
  413143:	89 c1                	mov    ecx,eax
		if (unlikely(contention)) {
  413145:	48 89 d6             	mov    rsi,rdx
  413148:	83 e6 01             	and    esi,0x1
  41314b:	74 d3                	je     413120 <slm_sched_loop_intern+0x2d0>
  41314d:	31 ff                	xor    edi,edi
  41314f:	48 89 d0             	mov    rax,rdx
  413152:	f0 48 0f b1 3d 65 ed 	lock cmpxchg QWORD PTR [rip+0x18ed65],rdi        # 5a1ec0 <__slm_global>
  413159:	18 00 
  41315b:	0f 94 c0             	sete   al
	if (__slm_cs_cas(cs, cached, NULL, 0)) return 1;
  41315e:	84 c0                	test   al,al
  413160:	74 d5                	je     413137 <slm_sched_loop_intern+0x2e7>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  413162:	48 83 e2 fe          	and    rdx,0xfffffffffffffffe
	ret = cos_defswitch(s->thd, curr->priority, TCAP_TIME_NIL, tok);
  413166:	48 8b 3d 6b ed 18 00 	mov    rdi,QWORD PTR [rip+0x18ed6b]        # 5a1ed8 <__slm_global+0x18>
  41316d:	48 8b 72 30          	mov    rsi,QWORD PTR [rdx+0x30]
  413171:	31 d2                	xor    edx,edx
  413173:	e8 e8 95 ff ff       	call   40c760 <cos_defswitch>
	assert(ret != -EINVAL);
  413178:	83 f8 ea             	cmp    eax,0xffffffea
  41317b:	0f 85 1e 01 00 00    	jne    41329f <slm_sched_loop_intern+0x44f>
  413181:	be 23 00 00 00       	mov    esi,0x23
  413186:	bf 08 ed 41 00       	mov    edi,0x41ed08
  41318b:	e8 40 6f ff ff       	call   40a0d0 <cos_print_str>
  413190:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413197:	00 00 00 00 
  41319b:	0f 0b                	ud2    
	if (unlikely(!(t->properties & SLM_THD_PROPERTY_SUSPENDED))) return 1;
  41319d:	41 8b 06             	mov    eax,DWORD PTR [r14]
  4131a0:	a8 04                	test   al,0x4
  4131a2:	0f 84 79 fe ff ff    	je     413021 <slm_sched_loop_intern+0x1d1>
	t->properties &= ~SLM_THD_PROPERTY_SUSPENDED;
  4131a8:	83 e0 fb             	and    eax,0xfffffffb
  4131ab:	41 89 06             	mov    DWORD PTR [r14],eax
	if (unlikely(slm_state_is_runnable(t->state))) {
  4131ae:	41 8b 46 04          	mov    eax,DWORD PTR [r14+0x4]
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  4131b2:	8d 50 fe             	lea    edx,[rax-0x2]
  4131b5:	83 fa 01             	cmp    edx,0x1
  4131b8:	0f 86 e1 01 00 00    	jbe    41339f <slm_sched_loop_intern+0x54f>
	assert(t->state == SLM_THD_BLOCKED);
  4131be:	83 e8 01             	sub    eax,0x1
  4131c1:	0f 85 e5 01 00 00    	jne    4133ac <slm_sched_loop_intern+0x55c>
	t->state = SLM_THD_RUNNABLE;
  4131c7:	41 c7 46 04 03 00 00 	mov    DWORD PTR [r14+0x4],0x3
  4131ce:	00 
	slm_sched_wakeup(t);
  4131cf:	4c 89 f7             	mov    rdi,r14
  4131d2:	e8 a9 e5 fe ff       	call   401780 <slm_sched_wakeup>
	return 0;
  4131d7:	e9 45 fe ff ff       	jmp    413021 <slm_sched_loop_intern+0x1d1>
	if (!contended) {
  4131dc:	a8 01                	test   al,0x1
  4131de:	75 1b                	jne    4131fb <slm_sched_loop_intern+0x3ab>
	return !ps_cas(&cs->owner_contention, (unsigned long)cached, ((unsigned long)thd | !!contention));
  4131e0:	48 89 d6             	mov    rsi,rdx
  4131e3:	48 83 ce 01          	or     rsi,0x1
  4131e7:	f0 48 0f b1 35 d0 ec 	lock cmpxchg QWORD PTR [rip+0x18ecd0],rsi        # 5a1ec0 <__slm_global>
  4131ee:	18 00 
  4131f0:	0f 94 c0             	sete   al
		if (__slm_cs_cas(cs, cached, owner, 1)) return 1;
  4131f3:	84 c0                	test   al,al
  4131f5:	0f 84 b5 fe ff ff    	je     4130b0 <slm_sched_loop_intern+0x260>
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  4131fb:	48 8b 7a 10          	mov    rdi,QWORD PTR [rdx+0x10]
  4131ff:	48 8b 35 f2 ec 18 00 	mov    rsi,QWORD PTR [rip+0x18ecf2]        # 5a1ef8 <__slm_global+0x38>
  413206:	31 d2                	xor    edx,edx
  413208:	e8 53 95 ff ff       	call   40c760 <cos_defswitch>
			if (flags & SLM_CS_SCHEDEVT && ret == -EBUSY) return ret;
  41320d:	83 f8 f0             	cmp    eax,0xfffffff0
  413210:	0f 85 9a fe ff ff    	jne    4130b0 <slm_sched_loop_intern+0x260>
  413216:	e9 70 fc ff ff       	jmp    412e8b <slm_sched_loop_intern+0x3b>
  41321b:	be 23 00 00 00       	mov    esi,0x23
  413220:	bf 18 ee 41 00       	mov    edi,0x41ee18
  413225:	e8 a6 6e ff ff       	call   40a0d0 <cos_print_str>
	assert(slm_thd_normal(t));
  41322a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413231:	00 00 00 00 
  413235:	0f 0b                	ud2    
	if (ps_list_singleton(t, thd_list)) ps_list_head_append(&g->event_head, t, thd_list);
  413237:	4c 8b 05 9a ed 18 00 	mov    r8,QWORD PTR [rip+0x18ed9a]        # 5a1fd8 <__slm_global+0x118>
	new->n    = l->n;
  41323e:	f3 41 0f 7e 00       	movq   xmm0,QWORD PTR [r8]
  413243:	66 49 0f 6e d0       	movq   xmm2,r8
  413248:	66 0f 6c c2          	punpcklqdq xmm0,xmm2
  41324c:	0f 11 40 58          	movups XMMWORD PTR [rax+0x58],xmm0
	l->n      = new;
  413250:	49 89 08             	mov    QWORD PTR [r8],rcx
	new->n->p = new;
  413253:	4c 8b 40 58          	mov    r8,QWORD PTR [rax+0x58]
  413257:	49 89 48 08          	mov    QWORD PTR [r8+0x8],rcx
}
  41325b:	e9 9a fc ff ff       	jmp    412efa <slm_sched_loop_intern+0xaa>
	if (!contended) {
  413260:	a8 01                	test   al,0x1
  413262:	75 1b                	jne    41327f <slm_sched_loop_intern+0x42f>
  413264:	48 89 d6             	mov    rsi,rdx
  413267:	48 83 ce 01          	or     rsi,0x1
  41326b:	f0 48 0f b1 35 4c ec 	lock cmpxchg QWORD PTR [rip+0x18ec4c],rsi        # 5a1ec0 <__slm_global>
  413272:	18 00 
  413274:	0f 94 c0             	sete   al
		if (__slm_cs_cas(cs, cached, owner, 1)) return 1;
  413277:	84 c0                	test   al,al
  413279:	0f 84 a5 fc ff ff    	je     412f24 <slm_sched_loop_intern+0xd4>
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  41327f:	48 8b 7a 10          	mov    rdi,QWORD PTR [rdx+0x10]
  413283:	48 8b 35 6e ec 18 00 	mov    rsi,QWORD PTR [rip+0x18ec6e]        # 5a1ef8 <__slm_global+0x38>
  41328a:	31 d2                	xor    edx,edx
  41328c:	e8 cf 94 ff ff       	call   40c760 <cos_defswitch>
  413291:	83 f8 f0             	cmp    eax,0xfffffff0
  413294:	0f 85 8a fc ff ff    	jne    412f24 <slm_sched_loop_intern+0xd4>
  41329a:	e9 fe fd ff ff       	jmp    41309d <slm_sched_loop_intern+0x24d>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  41329f:	e8 bc 85 ff ff       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4132a4:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
	timeout = g->timeout_next;
  4132a8:	4c 8b 05 19 ed 18 00 	mov    r8,QWORD PTR [rip+0x18ed19]        # 5a1fc8 <__slm_global+0x108>
	prio = inherit_prio ? curr->priority : t->priority;
  4132af:	49 8b 75 30          	mov    rsi,QWORD PTR [r13+0x30]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4132b3:	a8 0b                	test   al,0xb
  4132b5:	0f 85 6a 01 00 00    	jne    413425 <slm_sched_loop_intern+0x5d5>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  4132bb:	49 8b 7d 10          	mov    rdi,QWORD PTR [r13+0x10]
  4132bf:	44 89 f1             	mov    ecx,r14d
  4132c2:	4c 89 c2             	mov    rdx,r8
  4132c5:	e8 96 94 ff ff       	call   40c760 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  4132ca:	83 f8 ff             	cmp    eax,0xffffffff
  4132cd:	0f 84 1c 01 00 00    	je     4133ef <slm_sched_loop_intern+0x59f>
	if (unlikely(ret != 0)) {
  4132d3:	85 c0                	test   eax,eax
  4132d5:	0f 84 b0 fb ff ff    	je     412e8b <slm_sched_loop_intern+0x3b>
		assert(ret != -EINVAL);
  4132db:	83 f8 ea             	cmp    eax,0xffffffea
  4132de:	0f 84 5b 02 00 00    	je     41353f <slm_sched_loop_intern+0x6ef>
		if (ret == -EBUSY) return ret;
  4132e4:	83 f8 f0             	cmp    eax,0xfffffff0
  4132e7:	0f 84 9e fb ff ff    	je     412e8b <slm_sched_loop_intern+0x3b>
		assert(ret == -EAGAIN);
  4132ed:	83 f8 f5             	cmp    eax,0xfffffff5
  4132f0:	0f 85 2d 02 00 00    	jne    413523 <slm_sched_loop_intern+0x6d3>
		tok    = cos_sched_sync();
  4132f6:	e8 05 e0 ff ff       	call   411300 <cos_sched_sync>
  4132fb:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4132fd:	48 8b 05 bc eb 18 00 	mov    rax,QWORD PTR [rip+0x18ebbc]        # 5a1ec0 <__slm_global>
		if (unlikely(owner)) {
  413304:	48 89 c6             	mov    rsi,rax
  413307:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  41330b:	0f 85 c1 01 00 00    	jne    4134d2 <slm_sched_loop_intern+0x682>
  413311:	f0 48 0f b1 1d a6 eb 	lock cmpxchg QWORD PTR [rip+0x18eba6],rbx        # 5a1ec0 <__slm_global>
  413318:	18 00 
  41331a:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  41331d:	84 c0                	test   al,al
  41331f:	0f 85 bb fd ff ff    	jne    4130e0 <slm_sched_loop_intern+0x290>
  413325:	eb cf                	jmp    4132f6 <slm_sched_loop_intern+0x4a6>
	assert(cos_thdid() == us->tid);
  413327:	bf 40 ec 41 00       	mov    edi,0x41ec40
  41332c:	e8 ef fa ff ff       	call   412e20 <prints.isra.0>
  413331:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413338:	00 00 00 00 
  41333c:	0f 0b                	ud2    
					assert(cycles);
  41333e:	bf 90 ec 41 00       	mov    edi,0x41ec90
  413343:	e8 d8 fa ff ff       	call   412e20 <prints.isra.0>
  413348:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41334f:	00 00 00 00 
  413353:	0f 0b                	ud2    
			assert(t);
  413355:	bf 68 ec 41 00       	mov    edi,0x41ec68
  41335a:	e8 c1 fa ff ff       	call   412e20 <prints.isra.0>
  41335f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413366:	00 00 00 00 
  41336a:	0f 0b                	ud2    
	__asm__ __volatile__("rdtsc" : "=a" (a), "=d" (d), "=c" (c) : : );
  41336c:	0f 31                	rdtsc  
	return ((u64_t)d << 32) | (u64_t)a;
  41336e:	48 c1 e2 20          	shl    rdx,0x20
  413372:	48 89 d7             	mov    rdi,rdx
  413375:	48 09 c7             	or     rdi,rax
  413378:	48 8b 05 41 ec 18 00 	mov    rax,QWORD PTR [rip+0x18ec41]        # 5a1fc0 <__slm_global+0x100>
  41337f:	48 29 f8             	sub    rax,rdi
		if (!cycles_greater_than(g->timer_next, now)) {
  413382:	48 85 c0             	test   rax,rax
  413385:	0f 8f 6a fd ff ff    	jg     4130f5 <slm_sched_loop_intern+0x2a5>
			g->timer_set = 0;
  41338b:	c7 05 27 ec 18 00 00 	mov    DWORD PTR [rip+0x18ec27],0x0        # 5a1fbc <__slm_global+0xfc>
  413392:	00 00 00 
			slm_timer_expire(now);
  413395:	e8 36 e3 fe ff       	call   4016d0 <slm_timer_expire>
  41339a:	e9 56 fd ff ff       	jmp    4130f5 <slm_sched_loop_intern+0x2a5>
		t->state = SLM_THD_RUNNABLE;
  41339f:	41 c7 46 04 03 00 00 	mov    DWORD PTR [r14+0x4],0x3
  4133a6:	00 
		return 1;
  4133a7:	e9 75 fc ff ff       	jmp    413021 <slm_sched_loop_intern+0x1d1>
  4133ac:	be 23 00 00 00       	mov    esi,0x23
  4133b1:	bf e0 ec 41 00       	mov    edi,0x41ece0
  4133b6:	e8 15 6d ff ff       	call   40a0d0 <cos_print_str>
	assert(t->state == SLM_THD_BLOCKED);
  4133bb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4133c2:	00 00 00 00 
  4133c6:	0f 0b                	ud2    
  4133c8:	be 2d 00 00 00       	mov    esi,0x2d
  4133cd:	bf 30 ed 41 00       	mov    edi,0x41ed30
  4133d2:	e8 f9 6c ff ff       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  4133d7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4133de:	00 00 00 00 
  4133e2:	0f 0b                	ud2    
	if (unlikely(!t)) t = &g->idle_thd;
  4133e4:	41 bd 40 1f 5a 00    	mov    r13d,0x5a1f40
  4133ea:	e9 17 fd ff ff       	jmp    413106 <slm_sched_loop_intern+0x2b6>
	return t != &g->idle_thd && t != &g->sched_thd;
  4133ef:	49 81 fd 40 1f 5a 00 	cmp    r13,0x5a1f40
  4133f6:	0f 84 b3 00 00 00    	je     4134af <slm_sched_loop_intern+0x65f>
  4133fc:	49 81 fd c8 1e 5a 00 	cmp    r13,0x5a1ec8
  413403:	0f 84 a6 00 00 00    	je     4134af <slm_sched_loop_intern+0x65f>
  413409:	be 2d 00 00 00       	mov    esi,0x2d
  41340e:	bf 60 ed 41 00       	mov    edi,0x41ed60
  413413:	e8 b8 6c ff ff       	call   40a0d0 <cos_print_str>
		assert(ret != -EPERM);
  413418:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41341f:	00 00 00 00 
  413423:	0f 0b                	ud2    
	timeout = g->timeout_next;
  413425:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  413428:	49 81 fd c8 1e 5a 00 	cmp    r13,0x5a1ec8
  41342f:	74 73                	je     4134a4 <slm_sched_loop_intern+0x654>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  413431:	a8 02                	test   al,0x2
  413433:	75 57                	jne    41348c <slm_sched_loop_intern+0x63c>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  413435:	49 89 c8             	mov    r8,rcx
  413438:	a8 01                	test   al,0x1
  41343a:	0f 84 7b fe ff ff    	je     4132bb <slm_sched_loop_intern+0x46b>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  413440:	4d 8b 55 08          	mov    r10,QWORD PTR [r13+0x8]
  413444:	49 8b 7d 10          	mov    rdi,QWORD PTR [r13+0x10]
  413448:	48 89 f2             	mov    rdx,rsi
  41344b:	45 89 f1             	mov    r9d,r14d
  41344e:	4c 8b 05 93 ea 18 00 	mov    r8,QWORD PTR [rip+0x18ea93]        # 5a1ee8 <__slm_global+0x28>
  413455:	4c 89 d6             	mov    rsi,r10
  413458:	e8 c3 de ff ff       	call   411320 <cos_switch>
	if (unlikely(ret != 0)) {
  41345d:	85 c0                	test   eax,eax
  41345f:	0f 84 26 fa ff ff    	je     412e8b <slm_sched_loop_intern+0x3b>
		assert(ret != -EPERM);
  413465:	83 f8 ff             	cmp    eax,0xffffffff
  413468:	0f 85 6d fe ff ff    	jne    4132db <slm_sched_loop_intern+0x48b>
  41346e:	eb 99                	jmp    413409 <slm_sched_loop_intern+0x5b9>
  413470:	be 23 00 00 00       	mov    esi,0x23
  413475:	bf b8 ec 41 00       	mov    edi,0x41ecb8
  41347a:	e8 51 6c ff ff       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state) || t->state == SLM_THD_BLOCKED);
  41347f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413486:	00 00 00 00 
  41348a:	0f 0b                	ud2    
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  41348c:	49 8b 7d 28          	mov    rdi,QWORD PTR [r13+0x28]
  413490:	48 8b 15 51 ea 18 00 	mov    rdx,QWORD PTR [rip+0x18ea51]        # 5a1ee8 <__slm_global+0x28>
  413497:	44 89 f1             	mov    ecx,r14d
  41349a:	4c 89 c6             	mov    rsi,r8
  41349d:	e8 ee de ff ff       	call   411390 <cos_sched_asnd>
  4134a2:	eb b9                	jmp    41345d <slm_sched_loop_intern+0x60d>
			prio    = curr->priority;
  4134a4:	48 8b 35 4d ea 18 00 	mov    rsi,QWORD PTR [rip+0x18ea4d]        # 5a1ef8 <__slm_global+0x38>
			timeout = TCAP_TIME_NIL;
  4134ab:	31 c9                	xor    ecx,ecx
  4134ad:	eb 82                	jmp    413431 <slm_sched_loop_intern+0x5e1>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  4134af:	4c 8b 05 32 ea 18 00 	mov    r8,QWORD PTR [rip+0x18ea32]        # 5a1ee8 <__slm_global+0x28>
  4134b6:	45 89 f1             	mov    r9d,r14d
  4134b9:	31 c9                	xor    ecx,ecx
  4134bb:	31 f6                	xor    esi,esi
  4134bd:	48 8b 15 34 ea 18 00 	mov    rdx,QWORD PTR [rip+0x18ea34]        # 5a1ef8 <__slm_global+0x38>
  4134c4:	48 8b 3d 0d ea 18 00 	mov    rdi,QWORD PTR [rip+0x18ea0d]        # 5a1ed8 <__slm_global+0x18>
  4134cb:	e8 50 de ff ff       	call   411320 <cos_switch>
  4134d0:	eb 8b                	jmp    41345d <slm_sched_loop_intern+0x60d>
	if (!contended) {
  4134d2:	a8 01                	test   al,0x1
  4134d4:	75 1b                	jne    4134f1 <slm_sched_loop_intern+0x6a1>
	return !ps_cas(&cs->owner_contention, (unsigned long)cached, ((unsigned long)thd | !!contention));
  4134d6:	48 89 f2             	mov    rdx,rsi
  4134d9:	48 83 ca 01          	or     rdx,0x1
        __asm__ __volatile__("lock " PS_CAS_STR
  4134dd:	f0 48 0f b1 15 da e9 	lock cmpxchg QWORD PTR [rip+0x18e9da],rdx        # 5a1ec0 <__slm_global>
  4134e4:	18 00 
  4134e6:	0f 94 c0             	sete   al
		if (__slm_cs_cas(cs, cached, owner, 1)) return 1;
  4134e9:	84 c0                	test   al,al
  4134eb:	0f 84 05 fe ff ff    	je     4132f6 <slm_sched_loop_intern+0x4a6>
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  4134f1:	48 8b 7e 10          	mov    rdi,QWORD PTR [rsi+0x10]
  4134f5:	48 8b 35 fc e9 18 00 	mov    rsi,QWORD PTR [rip+0x18e9fc]        # 5a1ef8 <__slm_global+0x38>
  4134fc:	31 d2                	xor    edx,edx
  4134fe:	e8 5d 92 ff ff       	call   40c760 <cos_defswitch>
			assert(ret != -EBUSY);
  413503:	83 f8 f0             	cmp    eax,0xfffffff0
  413506:	0f 85 ea fd ff ff    	jne    4132f6 <slm_sched_loop_intern+0x4a6>
  41350c:	bf f0 ed 41 00       	mov    edi,0x41edf0
  413511:	e8 0a f9 ff ff       	call   412e20 <prints.isra.0>
  413516:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41351d:	00 00 00 00 
  413521:	0f 0b                	ud2    
  413523:	be 2d 00 00 00       	mov    esi,0x2d
  413528:	bf c0 ed 41 00       	mov    edi,0x41edc0
  41352d:	e8 9e 6b ff ff       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  413532:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413539:	00 00 00 00 
  41353d:	0f 0b                	ud2    
  41353f:	be 2d 00 00 00       	mov    esi,0x2d
  413544:	bf 90 ed 41 00       	mov    edi,0x41ed90
  413549:	e8 82 6b ff ff       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  41354e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413555:	00 00 00 00 
  413559:	0f 0b                	ud2    
  41355b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000413560 <slm_ipi_event_enqueue>:
{
  413560:	f3 0f 1e fa          	endbr64 
    return CK_RING_ENQUEUE_MPSC(slm_ipi_ringbuf, &ipi_data->ring, ipi_data->ringbuf, event);
  413564:	4c 63 d6             	movsxd r10,esi
{
  413567:	55                   	push   rbp
  413568:	4d 69 d2 c0 10 00 00 	imul   r10,r10,0x10c0
  41356f:	48 89 e5             	mov    rbp,rsp
  413572:	53                   	push   rbx
  413573:	48 89 fb             	mov    rbx,rdi
    void *buffer,
    const void *entry,
    unsigned int ts,
    unsigned int *size)
{
	const unsigned int mask = ring->mask;
  413576:	45 8b 82 a4 0e 5a 00 	mov    r8d,DWORD PTR [r10+0x5a0ea4]
  41357d:	4d 8d 9a a8 00 00 00 	lea    r11,[r10+0xa8]
	unsigned int producer, consumer, delta;
	bool r = true;

	producer = ck_pr_load_uint(&ring->p_head);
  413584:	49 8d 8a 64 0e 5a 00 	lea    rcx,[r10+0x5a0e64]
CK_PR_LOAD(ptr, void, void *, char, "movq")

#define CK_PR_LOAD_S(S, T, I) CK_PR_LOAD(S, T, T, T, I)

CK_PR_LOAD_S(char, char, "movb")
CK_PR_LOAD_S(uint, unsigned int, "movl")
  41358b:	41 8b 92 64 0e 5a 00 	mov    edx,DWORD PTR [r10+0x5a0e64]
		/*
		 * The snapshot of producer must be up to date with respect to
		 * consumer.
		 */
		ck_pr_fence_load();
		consumer = ck_pr_load_uint(&ring->c_head);
  413592:	4d 8d 8a 20 0e 5a 00 	lea    r9,[r10+0x5a0e20]
  413599:	eb 0f                	jmp    4135aa <slm_ipi_event_enqueue+0x4a>
  41359b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

#define CK_PR_CAS_S(S, T, I) CK_PR_CAS(S, T, T, T, I)

CK_PR_CAS_S(char, char, "cmpxchgb")
CK_PR_CAS_S(int, int, "cmpxchgl")
CK_PR_CAS_S(uint, unsigned int, "cmpxchgl")
  4135a0:	89 d0                	mov    eax,edx
  4135a2:	f0 0f b1 31          	lock cmpxchg DWORD PTR [rcx],esi
  4135a6:	89 c2                	mov    edx,eax
		/*
		 * Only try to CAS if the producer is not clearly stale (not
		 * less than consumer) and the buffer is definitely not full.
		 */
		if (CK_CC_LIKELY((producer - consumer) < mask)) {
			if (ck_pr_cas_uint_value(&ring->p_head,
  4135a8:	74 1e                	je     4135c8 <slm_ipi_event_enqueue+0x68>
CK_PR_LOAD_S(uint, unsigned int, "movl")
  4135aa:	41 8b 39             	mov    edi,DWORD PTR [r9]
		if (CK_CC_LIKELY((producer - consumer) < mask)) {
  4135ad:	89 d0                	mov    eax,edx
		delta = producer + 1;
  4135af:	8d 72 01             	lea    esi,[rdx+0x1]
		if (CK_CC_LIKELY((producer - consumer) < mask)) {
  4135b2:	29 f8                	sub    eax,edi
  4135b4:	41 39 c0             	cmp    r8d,eax
  4135b7:	77 e7                	ja     4135a0 <slm_ipi_event_enqueue+0x40>
  4135b9:	8b 01                	mov    eax,DWORD PTR [rcx]
			 * Only fail if we haven't made forward progress in
			 * production: the buffer must have been full when we
			 * read new_producer (or we wrapped around UINT_MAX
			 * during this iteration).
			 */
			if (producer == new_producer) {
  4135bb:	39 c2                	cmp    edx,eax
  4135bd:	74 52                	je     413611 <slm_ipi_event_enqueue+0xb1>
  4135bf:	89 c2                	mov    edx,eax
  4135c1:	eb e7                	jmp    4135aa <slm_ipi_event_enqueue+0x4a>
  4135c3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
			producer = new_producer;
		}
	}

	buffer = (char *)buffer + ts * (producer & mask);
	memcpy(buffer, entry, ts);
  4135c8:	48 8b 3b             	mov    rdi,QWORD PTR [rbx]
	buffer = (char *)buffer + ts * (producer & mask);
  4135cb:	41 21 c0             	and    r8d,eax
  4135ce:	42 8d 0c c5 00 00 00 	lea    ecx,[r8*8+0x0]
  4135d5:	00 
	memcpy(buffer, entry, ts);
  4135d6:	49 89 bc 0b 00 0e 5a 	mov    QWORD PTR [r11+rcx*1+0x5a0e00],rdi
  4135dd:	00 

	/*
	 * Wait until all concurrent producers have completed writing
	 * their data into the ring buffer.
	 */
	while (ck_pr_load_uint(&ring->p_tail) != producer)
  4135de:	49 8d 7a 60          	lea    rdi,[r10+0x60]
  4135e2:	49 8d 8a 60 0e 5a 00 	lea    rcx,[r10+0x5a0e60]
  4135e9:	44 8b 87 00 0e 5a 00 	mov    r8d,DWORD PTR [rdi+0x5a0e00]
  4135f0:	41 39 c0             	cmp    r8d,eax
  4135f3:	74 0b                	je     413600 <slm_ipi_event_enqueue+0xa0>
  4135f5:	0f 1f 00             	nop    DWORD PTR [rax]
	__asm__ __volatile__("pause" ::: "memory");
  4135f8:	f3 90                	pause  
CK_PR_LOAD_S(uint, unsigned int, "movl")
  4135fa:	8b 11                	mov    edx,DWORD PTR [rcx]
  4135fc:	39 d0                	cmp    eax,edx
  4135fe:	75 f8                	jne    4135f8 <slm_ipi_event_enqueue+0x98>
CK_PR_STORE_S(uint, unsigned int, "movl", CK_CC_IMM_U32)
  413600:	89 b7 00 0e 5a 00    	mov    DWORD PTR [rdi+0x5a0e00],esi
  413606:	b8 01 00 00 00       	mov    eax,0x1
}
  41360b:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
  41360f:	c9                   	leave  
  413610:	c3                   	ret    
  413611:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
  413615:	31 c0                	xor    eax,eax
  413617:	c9                   	leave  
  413618:	c3                   	ret    
  413619:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000413620 <slm_ipi_event_dequeue>:
{
  413620:	f3 0f 1e fa          	endbr64 
    return CK_RING_DEQUEUE_MPSC(slm_ipi_ringbuf, &ipi_data->ring, ipi_data->ringbuf, event);
  413624:	48 63 f6             	movsxd rsi,esi
  413627:	48 69 f6 c0 10 00 00 	imul   rsi,rsi,0x10c0
	const unsigned int mask = ring->mask;
  41362e:	8b 86 a4 0e 5a 00    	mov    eax,DWORD PTR [rsi+0x5a0ea4]
	consumer = ring->c_head;
  413634:	8b 96 20 0e 5a 00    	mov    edx,DWORD PTR [rsi+0x5a0e20]
  41363a:	4c 8d 86 a8 00 00 00 	lea    r8,[rsi+0xa8]
CK_PR_LOAD_S(uint, unsigned int, "movl")
  413641:	8b 8e 60 0e 5a 00    	mov    ecx,DWORD PTR [rsi+0x5a0e60]
	if (CK_CC_UNLIKELY(consumer == producer))
  413647:	39 ca                	cmp    edx,ecx
  413649:	74 25                	je     413670 <slm_ipi_event_dequeue+0x50>
	buffer = (const char *)buffer + size * (consumer & mask);
  41364b:	21 d0                	and    eax,edx
  41364d:	c1 e0 03             	shl    eax,0x3
  413650:	49 8b 84 00 00 0e 5a 	mov    rax,QWORD PTR [r8+rax*1+0x5a0e00]
  413657:	00 
	memcpy(target, buffer, size);
  413658:	48 89 07             	mov    QWORD PTR [rdi],rax
	ck_pr_store_uint(&ring->c_head, consumer + 1);
  41365b:	83 c2 01             	add    edx,0x1
CK_PR_STORE_S(uint, unsigned int, "movl", CK_CC_IMM_U32)
  41365e:	89 96 20 0e 5a 00    	mov    DWORD PTR [rsi+0x5a0e20],edx
  413664:	b8 01 00 00 00       	mov    eax,0x1
  413669:	c3                   	ret    
  41366a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  413670:	31 c0                	xor    eax,eax
}
  413672:	c3                   	ret    
  413673:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41367a:	00 00 00 00 
  41367e:	66 90                	xchg   ax,ax

0000000000413680 <slm_ipi_event_empty>:
{
  413680:	f3 0f 1e fa          	endbr64 
	c = ck_pr_load_uint(&ring->c_head);
  413684:	48 63 ff             	movsxd rdi,edi
  413687:	48 69 ff c0 10 00 00 	imul   rdi,rdi,0x10c0
CK_PR_LOAD_S(uint, unsigned int, "movl")
  41368e:	8b 97 20 0e 5a 00    	mov    edx,DWORD PTR [rdi+0x5a0e20]
  413694:	8b 87 60 0e 5a 00    	mov    eax,DWORD PTR [rdi+0x5a0e60]
	return (p - c) & ring->mask;
  41369a:	29 d0                	sub    eax,edx
  41369c:	23 87 a4 0e 5a 00    	and    eax,DWORD PTR [rdi+0x5a0ea4]
    return (!ck_ring_size(&ipi_data->ring));
  4136a2:	0f 94 c0             	sete   al
  4136a5:	0f b6 c0             	movzx  eax,al
}
  4136a8:	c3                   	ret    
  4136a9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

00000000004136b0 <slm_ipi_percore_get>:
{
  4136b0:	f3 0f 1e fa          	endbr64 
    return &slm_ipi_percore_data[id];
  4136b4:	48 63 c7             	movsxd rax,edi
  4136b7:	48 69 c0 c0 10 00 00 	imul   rax,rax,0x10c0
  4136be:	48 05 00 0e 5a 00    	add    rax,0x5a0e00
}
  4136c4:	c3                   	ret    
  4136c5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4136cc:	00 00 00 00 

00000000004136d0 <slm_thd_special>:
{
  4136d0:	f3 0f 1e fa          	endbr64 
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  4136d4:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  4136d7:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
	return cos_get_thd_id();
  4136dd:	0f b7 90 f0 1f 00 00 	movzx  edx,WORD PTR [rax+0x1ff0]
	if (me == g->sched_thd.tid)     return &g->sched_thd;
  4136e4:	48 39 15 f5 e7 18 00 	cmp    QWORD PTR [rip+0x18e7f5],rdx        # 5a1ee0 <__slm_global+0x20>
  4136eb:	b8 c8 1e 5a 00       	mov    eax,0x5a1ec8
  4136f0:	74 15                	je     413707 <slm_thd_special+0x37>
	else                            return NULL;
  4136f2:	48 39 15 5f e8 18 00 	cmp    QWORD PTR [rip+0x18e85f],rdx        # 5a1f58 <__slm_global+0x98>
  4136f9:	b8 40 1f 5a 00       	mov    eax,0x5a1f40
  4136fe:	ba 00 00 00 00       	mov    edx,0x0
  413703:	48 0f 45 c2          	cmovne rax,rdx
}
  413707:	c3                   	ret    
  413708:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41370f:	00 

0000000000413710 <slm_thd_init>:
{
  413710:	f3 0f 1e fa          	endbr64 
  413714:	55                   	push   rbp
  413715:	48 89 e5             	mov    rbp,rsp
  413718:	41 54                	push   r12
  41371a:	49 89 fc             	mov    r12,rdi
  41371d:	53                   	push   rbx
  41371e:	48 89 d3             	mov    rbx,rdx
  413721:	48 83 ec 10          	sub    rsp,0x10
  413725:	48 89 75 e8          	mov    QWORD PTR [rbp-0x18],rsi
	struct cos_defcompinfo *defci     = cos_defcompinfo_curr_get();
  413729:	e8 32 81 ff ff       	call   40b860 <cos_defcompinfo_curr_get>
  41372e:	48 89 c7             	mov    rdi,rax
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);
  413731:	e8 6a 81 ff ff       	call   40b8a0 <cos_sched_aep_get>
	memset(t, 0, sizeof(struct slm_thd));
  413736:	49 8d 7c 24 08       	lea    rdi,[r12+0x8]
  41373b:	4c 89 e1             	mov    rcx,r12
  41373e:	49 c7 04 24 00 00 00 	mov    QWORD PTR [r12],0x0
  413745:	00 
  413746:	49 c7 44 24 70 00 00 	mov    QWORD PTR [r12+0x70],0x0
  41374d:	00 00 
  41374f:	48 83 e7 f8          	and    rdi,0xfffffffffffffff8
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);
  413753:	49 89 c0             	mov    r8,rax
	memset(t, 0, sizeof(struct slm_thd));
  413756:	31 c0                	xor    eax,eax
  413758:	48 29 f9             	sub    rcx,rdi
  41375b:	83 c1 78             	add    ecx,0x78
  41375e:	c1 e9 03             	shr    ecx,0x3
  413761:	f3 48 ab             	rep stos QWORD PTR es:[rdi],rax
	if ((ret = slm_timer_thd_init(t))) return ret;
  413764:	4c 89 e7             	mov    rdi,r12
	*t = (struct slm_thd) {
  413767:	48 b8 ff ff ff ff ff 	movabs rax,0xffffffffffff
  41376e:	ff 00 00 
  413771:	f3 41 0f 7e 00       	movq   xmm0,QWORD PTR [r8]
  413776:	49 89 44 24 30       	mov    QWORD PTR [r12+0x30],rax
	ps_list_init(t, thd_list);
  41377b:	49 8d 44 24 58       	lea    rax,[r12+0x58]
  413780:	66 48 0f 6e c8       	movq   xmm1,rax
	ps_list_init(t, graveyard_list);
  413785:	49 8d 44 24 68       	lea    rax,[r12+0x68]
	*t = (struct slm_thd) {
  41378a:	49 89 5c 24 18       	mov    QWORD PTR [r12+0x18],rbx
  41378f:	41 c7 44 24 04 03 00 	mov    DWORD PTR [r12+0x4],0x3
  413796:	00 00 
{ l->n = l->p = l; }
  413798:	66 0f 6c c9          	punpcklqdq xmm1,xmm1
  41379c:	41 0f 11 4c 24 58    	movups XMMWORD PTR [r12+0x58],xmm1
  4137a2:	0f 16 45 e8          	movhps xmm0,QWORD PTR [rbp-0x18]
  4137a6:	41 0f 11 44 24 08    	movups XMMWORD PTR [r12+0x8],xmm0
	ps_list_init(t, graveyard_list);
  4137ac:	66 48 0f 6e c0       	movq   xmm0,rax
  4137b1:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  4137b5:	41 0f 11 44 24 68    	movups XMMWORD PTR [r12+0x68],xmm0
	if ((ret = slm_timer_thd_init(t))) return ret;
  4137bb:	e8 20 df fe ff       	call   4016e0 <slm_timer_thd_init>
  4137c0:	85 c0                	test   eax,eax
  4137c2:	74 0c                	je     4137d0 <slm_thd_init+0xc0>
}
  4137c4:	48 83 c4 10          	add    rsp,0x10
  4137c8:	5b                   	pop    rbx
  4137c9:	41 5c                	pop    r12
  4137cb:	5d                   	pop    rbp
  4137cc:	c3                   	ret    
  4137cd:	0f 1f 00             	nop    DWORD PTR [rax]
  4137d0:	48 83 c4 10          	add    rsp,0x10
	if ((ret = slm_sched_thd_init(t))) return ret;
  4137d4:	4c 89 e7             	mov    rdi,r12
}
  4137d7:	5b                   	pop    rbx
  4137d8:	41 5c                	pop    r12
  4137da:	5d                   	pop    rbp
	if ((ret = slm_sched_thd_init(t))) return ret;
  4137db:	e9 60 df fe ff       	jmp    401740 <slm_sched_thd_init>

00000000004137e0 <slm_thd_deinit>:
{
  4137e0:	f3 0f 1e fa          	endbr64 
  4137e4:	55                   	push   rbp
  4137e5:	48 89 e5             	mov    rbp,rsp
  4137e8:	53                   	push   rbx
  4137e9:	48 89 fb             	mov    rbx,rdi
  4137ec:	48 83 ec 08          	sub    rsp,0x8
	slm_sched_thd_deinit(t);
  4137f0:	e8 5b df fe ff       	call   401750 <slm_sched_thd_deinit>
	slm_timer_thd_deinit(t);
  4137f5:	48 89 df             	mov    rdi,rbx
  4137f8:	e8 f3 de fe ff       	call   4016f0 <slm_timer_thd_deinit>
	t->state = SLM_THD_DYING;
  4137fd:	c7 43 04 04 00 00 00 	mov    DWORD PTR [rbx+0x4],0x4
}
  413804:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
  413808:	c9                   	leave  
  413809:	c3                   	ret    
  41380a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000413810 <slm_cs_enter_contention>:
{
  413810:	f3 0f 1e fa          	endbr64 
  413814:	49 89 ca             	mov    r10,rcx
  413817:	44 89 c9             	mov    ecx,r9d
	if (!contended) {
  41381a:	45 85 c0             	test   r8d,r8d
  41381d:	75 16                	jne    413835 <slm_cs_enter_contention+0x25>
  41381f:	48 89 f0             	mov    rax,rsi
	return !ps_cas(&cs->owner_contention, (unsigned long)cached, ((unsigned long)thd | !!contention));
  413822:	4c 89 d6             	mov    rsi,r10
  413825:	48 83 ce 01          	or     rsi,0x1
  413829:	f0 48 0f b1 37       	lock cmpxchg QWORD PTR [rdi],rsi
  41382e:	0f 94 c0             	sete   al
		if (__slm_cs_cas(cs, cached, owner, 1)) return 1;
  413831:	84 c0                	test   al,al
  413833:	74 23                	je     413858 <slm_cs_enter_contention+0x48>
{
  413835:	55                   	push   rbp
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  413836:	49 8b 7a 10          	mov    rdi,QWORD PTR [r10+0x10]
  41383a:	48 8b 72 30          	mov    rsi,QWORD PTR [rdx+0x30]
  41383e:	31 d2                	xor    edx,edx
{
  413840:	48 89 e5             	mov    rbp,rsp
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  413843:	e8 18 8f ff ff       	call   40c760 <cos_defswitch>
	if (ret) return ret;
  413848:	85 c0                	test   eax,eax
  41384a:	75 05                	jne    413851 <slm_cs_enter_contention+0x41>
	return 1;
  41384c:	b8 01 00 00 00       	mov    eax,0x1
}
  413851:	5d                   	pop    rbp
  413852:	c3                   	ret    
  413853:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	return 1;
  413858:	b8 01 00 00 00       	mov    eax,0x1
}
  41385d:	c3                   	ret    
  41385e:	66 90                	xchg   ax,ax

0000000000413860 <slm_cs_exit_contention>:
{
  413860:	f3 0f 1e fa          	endbr64 
  413864:	49 89 f8             	mov    r8,rdi
  413867:	48 89 d0             	mov    rax,rdx
  41386a:	31 ff                	xor    edi,edi
  41386c:	f0 49 0f b1 38       	lock cmpxchg QWORD PTR [r8],rdi
  413871:	0f 94 c0             	sete   al
	if (__slm_cs_cas(cs, cached, NULL, 0)) return 1;
  413874:	84 c0                	test   al,al
  413876:	75 08                	jne    413880 <slm_cs_exit_contention+0x20>
}
  413878:	b8 01 00 00 00       	mov    eax,0x1
  41387d:	c3                   	ret    
  41387e:	66 90                	xchg   ax,ax
{
  413880:	55                   	push   rbp
	ret = cos_defswitch(s->thd, curr->priority, TCAP_TIME_NIL, tok);
  413881:	48 8b 3d 50 e6 18 00 	mov    rdi,QWORD PTR [rip+0x18e650]        # 5a1ed8 <__slm_global+0x18>
  413888:	31 d2                	xor    edx,edx
  41388a:	48 8b 76 30          	mov    rsi,QWORD PTR [rsi+0x30]
{
  41388e:	48 89 e5             	mov    rbp,rsp
	ret = cos_defswitch(s->thd, curr->priority, TCAP_TIME_NIL, tok);
  413891:	e8 ca 8e ff ff       	call   40c760 <cos_defswitch>
	return 0;
  413896:	45 31 c0             	xor    r8d,r8d
	assert(ret != -EINVAL);
  413899:	83 f8 ea             	cmp    eax,0xffffffea
  41389c:	74 05                	je     4138a3 <slm_cs_exit_contention+0x43>
}
  41389e:	44 89 c0             	mov    eax,r8d
  4138a1:	5d                   	pop    rbp
  4138a2:	c3                   	ret    
  4138a3:	be 23 00 00 00       	mov    esi,0x23
  4138a8:	bf 08 ed 41 00       	mov    edi,0x41ed08
  4138ad:	e8 1e 68 ff ff       	call   40a0d0 <cos_print_str>
	assert(ret != -EINVAL);
  4138b2:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4138b9:	00 00 00 00 
  4138bd:	0f 0b                	ud2    
  4138bf:	90                   	nop

00000000004138c0 <slm_thd_block>:
{
  4138c0:	f3 0f 1e fa          	endbr64 
  4138c4:	55                   	push   rbp
  4138c5:	48 89 e5             	mov    rbp,rsp
	assert(t);
  4138c8:	48 85 ff             	test   rdi,rdi
  4138cb:	74 5f                	je     41392c <slm_thd_block+0x6c>
	return t != &g->idle_thd && t != &g->sched_thd;
  4138cd:	48 81 ff c8 1e 5a 00 	cmp    rdi,0x5a1ec8
  4138d4:	74 3a                	je     413910 <slm_thd_block+0x50>
  4138d6:	48 81 ff 40 1f 5a 00 	cmp    rdi,0x5a1f40
  4138dd:	74 31                	je     413910 <slm_thd_block+0x50>
	if (unlikely(t->state == SLM_THD_WOKEN)) {
  4138df:	8b 47 04             	mov    eax,DWORD PTR [rdi+0x4]
  4138e2:	83 f8 02             	cmp    eax,0x2
  4138e5:	74 61                	je     413948 <slm_thd_block+0x88>
	assert(t->state == SLM_THD_RUNNABLE);
  4138e7:	83 f8 03             	cmp    eax,0x3
  4138ea:	75 6f                	jne    41395b <slm_thd_block+0x9b>
	if (t->properties & SLM_THD_PROPERTY_SUSPENDED) {
  4138ec:	8b 07                	mov    eax,DWORD PTR [rdi]
  4138ee:	a8 04                	test   al,0x4
  4138f0:	74 05                	je     4138f7 <slm_thd_block+0x37>
		t->properties &= ~SLM_THD_PROPERTY_SUSPENDED;
  4138f2:	83 e0 fb             	and    eax,0xfffffffb
  4138f5:	89 07                	mov    DWORD PTR [rdi],eax
	t->state = SLM_THD_BLOCKED;
  4138f7:	c7 47 04 01 00 00 00 	mov    DWORD PTR [rdi+0x4],0x1
	slm_sched_block(t);
  4138fe:	e8 6d de fe ff       	call   401770 <slm_sched_block>
	return 0;
  413903:	31 c0                	xor    eax,eax
}
  413905:	5d                   	pop    rbp
  413906:	c3                   	ret    
  413907:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41390e:	00 00 
  413910:	be 23 00 00 00       	mov    esi,0x23
  413915:	bf b8 ee 41 00       	mov    edi,0x41eeb8
  41391a:	e8 b1 67 ff ff       	call   40a0d0 <cos_print_str>
	assert(slm_thd_normal(t));
  41391f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413926:	00 00 00 00 
  41392a:	0f 0b                	ud2    
  41392c:	be 23 00 00 00       	mov    esi,0x23
  413931:	bf 40 ee 41 00       	mov    edi,0x41ee40
  413936:	e8 95 67 ff ff       	call   40a0d0 <cos_print_str>
	assert(t);
  41393b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413942:	00 00 00 00 
  413946:	0f 0b                	ud2    
		assert(!(t->properties & SLM_THD_PROPERTY_SUSPENDED));
  413948:	f6 07 04             	test   BYTE PTR [rdi],0x4
  41394b:	75 2a                	jne    413977 <slm_thd_block+0xb7>
		t->state = SLM_THD_RUNNABLE;
  41394d:	c7 47 04 03 00 00 00 	mov    DWORD PTR [rdi+0x4],0x3
		return 1;
  413954:	b8 01 00 00 00       	mov    eax,0x1
}
  413959:	5d                   	pop    rbp
  41395a:	c3                   	ret    
  41395b:	be 23 00 00 00       	mov    esi,0x23
  413960:	bf 90 ee 41 00       	mov    edi,0x41ee90
  413965:	e8 66 67 ff ff       	call   40a0d0 <cos_print_str>
	assert(t->state == SLM_THD_RUNNABLE);
  41396a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413971:	00 00 00 00 
  413975:	0f 0b                	ud2    
  413977:	be 23 00 00 00       	mov    esi,0x23
  41397c:	bf 68 ee 41 00       	mov    edi,0x41ee68
  413981:	e8 4a 67 ff ff       	call   40a0d0 <cos_print_str>
		assert(!(t->properties & SLM_THD_PROPERTY_SUSPENDED));
  413986:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41398d:	00 00 00 00 
  413991:	0f 0b                	ud2    
  413993:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41399a:	00 00 00 00 
  41399e:	66 90                	xchg   ax,ax

00000000004139a0 <slm_thd_block_cs>:
{
  4139a0:	f3 0f 1e fa          	endbr64 
  4139a4:	55                   	push   rbp
  4139a5:	48 89 e5             	mov    rbp,rsp
  4139a8:	41 57                	push   r15
  4139aa:	41 56                	push   r14
  4139ac:	41 55                	push   r13
  4139ae:	41 54                	push   r12
  4139b0:	53                   	push   rbx
  4139b1:	48 89 fb             	mov    rbx,rdi
  4139b4:	48 83 ec 08          	sub    rsp,0x8
	assert(current);
  4139b8:	48 85 ff             	test   rdi,rdi
  4139bb:	0f 84 f2 01 00 00    	je     413bb3 <slm_thd_block_cs+0x213>
		tok    = cos_sched_sync();
  4139c1:	e8 3a d9 ff ff       	call   411300 <cos_sched_sync>
  4139c6:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4139c8:	48 8b 05 f1 e4 18 00 	mov    rax,QWORD PTR [rip+0x18e4f1]        # 5a1ec0 <__slm_global>
		if (unlikely(owner)) {
  4139cf:	48 89 c2             	mov    rdx,rax
  4139d2:	48 83 e2 fe          	and    rdx,0xfffffffffffffffe
  4139d6:	0f 85 84 01 00 00    	jne    413b60 <slm_thd_block_cs+0x1c0>
  4139dc:	f0 48 0f b1 1d db e4 	lock cmpxchg QWORD PTR [rip+0x18e4db],rbx        # 5a1ec0 <__slm_global>
  4139e3:	18 00 
  4139e5:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4139e8:	84 c0                	test   al,al
  4139ea:	74 d5                	je     4139c1 <slm_thd_block_cs+0x21>
	if (slm_thd_block(current)) {
  4139ec:	48 89 df             	mov    rdi,rbx
  4139ef:	e8 cc fe ff ff       	call   4138c0 <slm_thd_block>
  4139f4:	85 c0                	test   eax,eax
  4139f6:	0f 85 e4 00 00 00    	jne    413ae0 <slm_thd_block_cs+0x140>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  4139fc:	e8 5f 7e ff ff       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(!t)) t = &g->idle_thd;
  413a01:	41 bf 40 1f 5a 00    	mov    r15d,0x5a1f40
  413a07:	45 31 f6             	xor    r14d,r14d
	tok  = cos_sched_sync();
  413a0a:	e8 f1 d8 ff ff       	call   411300 <cos_sched_sync>
  413a0f:	41 89 c5             	mov    r13d,eax
	t = slm_sched_schedule();
  413a12:	e8 89 dd fe ff       	call   4017a0 <slm_sched_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  413a17:	48 85 c0             	test   rax,rax
	t = slm_sched_schedule();
  413a1a:	49 89 c4             	mov    r12,rax
	if (unlikely(!t)) t = &g->idle_thd;
  413a1d:	4d 0f 44 e7          	cmove  r12,r15
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  413a21:	41 8b 44 24 04       	mov    eax,DWORD PTR [r12+0x4]
  413a26:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  413a29:	83 f8 01             	cmp    eax,0x1
  413a2c:	76 1a                	jbe    413a48 <slm_thd_block_cs+0xa8>
  413a2e:	e9 ed 01 00 00       	jmp    413c20 <slm_thd_block_cs+0x280>
  413a33:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  413a38:	f0 48 0f b1 35 7f e4 	lock cmpxchg QWORD PTR [rip+0x18e47f],rsi        # 5a1ec0 <__slm_global>
  413a3f:	18 00 
  413a41:	0f 94 c0             	sete   al
	while (ret != 0) {
  413a44:	84 c0                	test   al,al
  413a46:	75 48                	jne    413a90 <slm_thd_block_cs+0xf0>
		tok    = cos_sched_sync();
  413a48:	e8 b3 d8 ff ff       	call   411300 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  413a4d:	48 8b 15 6c e4 18 00 	mov    rdx,QWORD PTR [rip+0x18e46c]        # 5a1ec0 <__slm_global>
  413a54:	89 c1                	mov    ecx,eax
		if (unlikely(contention)) {
  413a56:	48 89 d6             	mov    rsi,rdx
  413a59:	48 89 d0             	mov    rax,rdx
  413a5c:	83 e6 01             	and    esi,0x1
  413a5f:	74 d7                	je     413a38 <slm_thd_block_cs+0x98>
  413a61:	f0 4c 0f b1 35 56 e4 	lock cmpxchg QWORD PTR [rip+0x18e456],r14        # 5a1ec0 <__slm_global>
  413a68:	18 00 
  413a6a:	0f 94 c0             	sete   al
	if (__slm_cs_cas(cs, cached, NULL, 0)) return 1;
  413a6d:	84 c0                	test   al,al
  413a6f:	74 d7                	je     413a48 <slm_thd_block_cs+0xa8>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  413a71:	48 83 e2 fe          	and    rdx,0xfffffffffffffffe
	ret = cos_defswitch(s->thd, curr->priority, TCAP_TIME_NIL, tok);
  413a75:	48 8b 3d 5c e4 18 00 	mov    rdi,QWORD PTR [rip+0x18e45c]        # 5a1ed8 <__slm_global+0x18>
  413a7c:	48 8b 72 30          	mov    rsi,QWORD PTR [rdx+0x30]
  413a80:	31 d2                	xor    edx,edx
  413a82:	e8 d9 8c ff ff       	call   40c760 <cos_defswitch>
	assert(ret != -EINVAL);
  413a87:	83 f8 ea             	cmp    eax,0xffffffea
  413a8a:	0f 84 ac 00 00 00    	je     413b3c <slm_thd_block_cs+0x19c>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  413a90:	e8 cb 7d ff ff       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  413a95:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
	prio = inherit_prio ? curr->priority : t->priority;
  413a99:	49 8b 74 24 30       	mov    rsi,QWORD PTR [r12+0x30]
	timeout = g->timeout_next;
  413a9e:	4c 8b 05 23 e5 18 00 	mov    r8,QWORD PTR [rip+0x18e523]        # 5a1fc8 <__slm_global+0x108>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  413aa5:	a8 0b                	test   al,0xb
  413aa7:	0f 85 8f 01 00 00    	jne    413c3c <slm_thd_block_cs+0x29c>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  413aad:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  413ab2:	44 89 e9             	mov    ecx,r13d
  413ab5:	4c 89 c2             	mov    rdx,r8
  413ab8:	e8 a3 8c ff ff       	call   40c760 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  413abd:	83 f8 ff             	cmp    eax,0xffffffff
  413ac0:	0f 84 e5 01 00 00    	je     413cab <slm_thd_block_cs+0x30b>
	if (unlikely(ret != 0)) {
  413ac6:	85 c0                	test   eax,eax
  413ac8:	0f 85 01 01 00 00    	jne    413bcf <slm_thd_block_cs+0x22f>
}
  413ace:	48 83 c4 08          	add    rsp,0x8
  413ad2:	5b                   	pop    rbx
  413ad3:	41 5c                	pop    r12
  413ad5:	41 5d                	pop    r13
  413ad7:	41 5e                	pop    r14
  413ad9:	41 5f                	pop    r15
  413adb:	5d                   	pop    rbp
  413adc:	c3                   	ret    
  413add:	0f 1f 00             	nop    DWORD PTR [rax]
  413ae0:	31 db                	xor    ebx,ebx
  413ae2:	eb 14                	jmp    413af8 <slm_thd_block_cs+0x158>
  413ae4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  413ae8:	f0 48 0f b1 35 cf e3 	lock cmpxchg QWORD PTR [rip+0x18e3cf],rsi        # 5a1ec0 <__slm_global>
  413aef:	18 00 
  413af1:	0f 94 c0             	sete   al
	while (ret != 0) {
  413af4:	84 c0                	test   al,al
  413af6:	75 d6                	jne    413ace <slm_thd_block_cs+0x12e>
		tok    = cos_sched_sync();
  413af8:	e8 03 d8 ff ff       	call   411300 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  413afd:	48 8b 15 bc e3 18 00 	mov    rdx,QWORD PTR [rip+0x18e3bc]        # 5a1ec0 <__slm_global>
  413b04:	89 c1                	mov    ecx,eax
		if (unlikely(contention)) {
  413b06:	48 89 d6             	mov    rsi,rdx
  413b09:	48 89 d0             	mov    rax,rdx
  413b0c:	83 e6 01             	and    esi,0x1
  413b0f:	74 d7                	je     413ae8 <slm_thd_block_cs+0x148>
  413b11:	f0 48 0f b1 1d a6 e3 	lock cmpxchg QWORD PTR [rip+0x18e3a6],rbx        # 5a1ec0 <__slm_global>
  413b18:	18 00 
  413b1a:	0f 94 c0             	sete   al
	if (__slm_cs_cas(cs, cached, NULL, 0)) return 1;
  413b1d:	84 c0                	test   al,al
  413b1f:	74 d7                	je     413af8 <slm_thd_block_cs+0x158>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  413b21:	48 83 e2 fe          	and    rdx,0xfffffffffffffffe
	ret = cos_defswitch(s->thd, curr->priority, TCAP_TIME_NIL, tok);
  413b25:	48 8b 3d ac e3 18 00 	mov    rdi,QWORD PTR [rip+0x18e3ac]        # 5a1ed8 <__slm_global+0x18>
  413b2c:	48 8b 72 30          	mov    rsi,QWORD PTR [rdx+0x30]
  413b30:	31 d2                	xor    edx,edx
  413b32:	e8 29 8c ff ff       	call   40c760 <cos_defswitch>
	assert(ret != -EINVAL);
  413b37:	83 f8 ea             	cmp    eax,0xffffffea
  413b3a:	75 92                	jne    413ace <slm_thd_block_cs+0x12e>
  413b3c:	be 23 00 00 00       	mov    esi,0x23
  413b41:	bf 08 ed 41 00       	mov    edi,0x41ed08
  413b46:	e8 85 65 ff ff       	call   40a0d0 <cos_print_str>
  413b4b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413b52:	00 00 00 00 
  413b56:	0f 0b                	ud2    
  413b58:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  413b5f:	00 
	if (!contended) {
  413b60:	a8 01                	test   al,0x1
  413b62:	75 1b                	jne    413b7f <slm_thd_block_cs+0x1df>
	return !ps_cas(&cs->owner_contention, (unsigned long)cached, ((unsigned long)thd | !!contention));
  413b64:	48 89 d6             	mov    rsi,rdx
  413b67:	48 83 ce 01          	or     rsi,0x1
  413b6b:	f0 48 0f b1 35 4c e3 	lock cmpxchg QWORD PTR [rip+0x18e34c],rsi        # 5a1ec0 <__slm_global>
  413b72:	18 00 
  413b74:	0f 94 c0             	sete   al
		if (__slm_cs_cas(cs, cached, owner, 1)) return 1;
  413b77:	84 c0                	test   al,al
  413b79:	0f 84 42 fe ff ff    	je     4139c1 <slm_thd_block_cs+0x21>
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  413b7f:	48 8b 7a 10          	mov    rdi,QWORD PTR [rdx+0x10]
  413b83:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
  413b87:	31 d2                	xor    edx,edx
  413b89:	e8 d2 8b ff ff       	call   40c760 <cos_defswitch>
			assert(ret != -EBUSY);
  413b8e:	83 f8 f0             	cmp    eax,0xfffffff0
  413b91:	0f 85 2a fe ff ff    	jne    4139c1 <slm_thd_block_cs+0x21>
  413b97:	be 25 00 00 00       	mov    esi,0x25
  413b9c:	bf f0 ed 41 00       	mov    edi,0x41edf0
  413ba1:	e8 2a 65 ff ff       	call   40a0d0 <cos_print_str>
  413ba6:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413bad:	00 00 00 00 
  413bb1:	0f 0b                	ud2    
  413bb3:	be 25 00 00 00       	mov    esi,0x25
  413bb8:	bf e0 ee 41 00       	mov    edi,0x41eee0
  413bbd:	e8 0e 65 ff ff       	call   40a0d0 <cos_print_str>
	assert(current);
  413bc2:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413bc9:	00 00 00 00 
  413bcd:	0f 0b                	ud2    
		assert(ret != -EINVAL);
  413bcf:	83 f8 ea             	cmp    eax,0xffffffea
  413bd2:	0f 84 2c 01 00 00    	je     413d04 <slm_thd_block_cs+0x364>
		if (ret == -EBUSY) return ret;
  413bd8:	83 f8 f0             	cmp    eax,0xfffffff0
  413bdb:	0f 84 ed fe ff ff    	je     413ace <slm_thd_block_cs+0x12e>
		assert(ret == -EAGAIN);
  413be1:	83 f8 f5             	cmp    eax,0xfffffff5
  413be4:	0f 85 8e 01 00 00    	jne    413d78 <slm_thd_block_cs+0x3d8>
		tok    = cos_sched_sync();
  413bea:	e8 11 d7 ff ff       	call   411300 <cos_sched_sync>
  413bef:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  413bf1:	48 8b 05 c8 e2 18 00 	mov    rax,QWORD PTR [rip+0x18e2c8]        # 5a1ec0 <__slm_global>
		if (unlikely(owner)) {
  413bf8:	48 89 c6             	mov    rsi,rax
  413bfb:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  413bff:	0f 85 1b 01 00 00    	jne    413d20 <slm_thd_block_cs+0x380>
  413c05:	f0 48 0f b1 1d b2 e2 	lock cmpxchg QWORD PTR [rip+0x18e2b2],rbx        # 5a1ec0 <__slm_global>
  413c0c:	18 00 
  413c0e:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  413c11:	84 c0                	test   al,al
  413c13:	0f 85 f1 fd ff ff    	jne    413a0a <slm_thd_block_cs+0x6a>
  413c19:	eb cf                	jmp    413bea <slm_thd_block_cs+0x24a>
  413c1b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  413c20:	be 2d 00 00 00       	mov    esi,0x2d
  413c25:	bf 30 ed 41 00       	mov    edi,0x41ed30
  413c2a:	e8 a1 64 ff ff       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  413c2f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413c36:	00 00 00 00 
  413c3a:	0f 0b                	ud2    
	timeout = g->timeout_next;
  413c3c:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  413c3f:	49 81 fc c8 1e 5a 00 	cmp    r12,0x5a1ec8
  413c46:	0f 84 91 00 00 00    	je     413cdd <slm_thd_block_cs+0x33d>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  413c4c:	a8 02                	test   al,0x2
  413c4e:	0f 85 94 00 00 00    	jne    413ce8 <slm_thd_block_cs+0x348>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  413c54:	49 89 c8             	mov    r8,rcx
  413c57:	a8 01                	test   al,0x1
  413c59:	0f 84 4e fe ff ff    	je     413aad <slm_thd_block_cs+0x10d>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  413c5f:	4d 8b 54 24 08       	mov    r10,QWORD PTR [r12+0x8]
  413c64:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  413c69:	48 89 f2             	mov    rdx,rsi
  413c6c:	45 89 e9             	mov    r9d,r13d
  413c6f:	4c 8b 05 72 e2 18 00 	mov    r8,QWORD PTR [rip+0x18e272]        # 5a1ee8 <__slm_global+0x28>
  413c76:	4c 89 d6             	mov    rsi,r10
  413c79:	e8 a2 d6 ff ff       	call   411320 <cos_switch>
	if (unlikely(ret != 0)) {
  413c7e:	85 c0                	test   eax,eax
  413c80:	0f 84 48 fe ff ff    	je     413ace <slm_thd_block_cs+0x12e>
		assert(ret != -EPERM);
  413c86:	83 f8 ff             	cmp    eax,0xffffffff
  413c89:	0f 85 40 ff ff ff    	jne    413bcf <slm_thd_block_cs+0x22f>
  413c8f:	be 2d 00 00 00       	mov    esi,0x2d
  413c94:	bf 60 ed 41 00       	mov    edi,0x41ed60
  413c99:	e8 32 64 ff ff       	call   40a0d0 <cos_print_str>
  413c9e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413ca5:	00 00 00 00 
  413ca9:	0f 0b                	ud2    
	return t != &g->idle_thd && t != &g->sched_thd;
  413cab:	49 81 fc 40 1f 5a 00 	cmp    r12,0x5a1f40
  413cb2:	74 09                	je     413cbd <slm_thd_block_cs+0x31d>
  413cb4:	49 81 fc c8 1e 5a 00 	cmp    r12,0x5a1ec8
  413cbb:	75 d2                	jne    413c8f <slm_thd_block_cs+0x2ef>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  413cbd:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]
  413cc1:	4c 8b 05 20 e2 18 00 	mov    r8,QWORD PTR [rip+0x18e220]        # 5a1ee8 <__slm_global+0x28>
  413cc8:	45 89 e9             	mov    r9d,r13d
  413ccb:	31 c9                	xor    ecx,ecx
  413ccd:	48 8b 3d 04 e2 18 00 	mov    rdi,QWORD PTR [rip+0x18e204]        # 5a1ed8 <__slm_global+0x18>
  413cd4:	31 f6                	xor    esi,esi
  413cd6:	e8 45 d6 ff ff       	call   411320 <cos_switch>
  413cdb:	eb a1                	jmp    413c7e <slm_thd_block_cs+0x2de>
			prio    = curr->priority;
  413cdd:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
			timeout = TCAP_TIME_NIL;
  413ce1:	31 c9                	xor    ecx,ecx
  413ce3:	e9 64 ff ff ff       	jmp    413c4c <slm_thd_block_cs+0x2ac>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  413ce8:	49 8b 7c 24 28       	mov    rdi,QWORD PTR [r12+0x28]
  413ced:	48 8b 15 f4 e1 18 00 	mov    rdx,QWORD PTR [rip+0x18e1f4]        # 5a1ee8 <__slm_global+0x28>
  413cf4:	44 89 e9             	mov    ecx,r13d
  413cf7:	4c 89 c6             	mov    rsi,r8
  413cfa:	e8 91 d6 ff ff       	call   411390 <cos_sched_asnd>
  413cff:	e9 7a ff ff ff       	jmp    413c7e <slm_thd_block_cs+0x2de>
  413d04:	be 2d 00 00 00       	mov    esi,0x2d
  413d09:	bf 90 ed 41 00       	mov    edi,0x41ed90
  413d0e:	e8 bd 63 ff ff       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  413d13:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413d1a:	00 00 00 00 
  413d1e:	0f 0b                	ud2    
	if (!contended) {
  413d20:	a8 01                	test   al,0x1
  413d22:	75 1b                	jne    413d3f <slm_thd_block_cs+0x39f>
	return !ps_cas(&cs->owner_contention, (unsigned long)cached, ((unsigned long)thd | !!contention));
  413d24:	48 89 f2             	mov    rdx,rsi
  413d27:	48 83 ca 01          	or     rdx,0x1
  413d2b:	f0 48 0f b1 15 8c e1 	lock cmpxchg QWORD PTR [rip+0x18e18c],rdx        # 5a1ec0 <__slm_global>
  413d32:	18 00 
  413d34:	0f 94 c0             	sete   al
		if (__slm_cs_cas(cs, cached, owner, 1)) return 1;
  413d37:	84 c0                	test   al,al
  413d39:	0f 84 ab fe ff ff    	je     413bea <slm_thd_block_cs+0x24a>
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  413d3f:	4c 8b 43 30          	mov    r8,QWORD PTR [rbx+0x30]
  413d43:	48 8b 7e 10          	mov    rdi,QWORD PTR [rsi+0x10]
  413d47:	31 d2                	xor    edx,edx
  413d49:	4c 89 c6             	mov    rsi,r8
  413d4c:	e8 0f 8a ff ff       	call   40c760 <cos_defswitch>
			assert(ret != -EBUSY);
  413d51:	83 f8 f0             	cmp    eax,0xfffffff0
  413d54:	0f 85 90 fe ff ff    	jne    413bea <slm_thd_block_cs+0x24a>
  413d5a:	bf f0 ed 41 00       	mov    edi,0x41edf0
  413d5f:	e8 bc f0 ff ff       	call   412e20 <prints.isra.0>
  413d64:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413d6b:	00 00 00 00 
  413d6f:	0f 0b                	ud2    
  413d71:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  413d78:	be 2d 00 00 00       	mov    esi,0x2d
  413d7d:	bf c0 ed 41 00       	mov    edi,0x41edc0
  413d82:	e8 49 63 ff ff       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  413d87:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413d8e:	00 00 00 00 
  413d92:	0f 0b                	ud2    
  413d94:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  413d9b:	00 00 00 00 
  413d9f:	90                   	nop

0000000000413da0 <slm_thd_sched_wakeup>:
{
  413da0:	f3 0f 1e fa          	endbr64 
  413da4:	55                   	push   rbp
  413da5:	48 89 e5             	mov    rbp,rsp
	assert(t);
  413da8:	48 85 ff             	test   rdi,rdi
  413dab:	74 2b                	je     413dd8 <slm_thd_sched_wakeup+0x38>
	if (unlikely(!(t->properties & SLM_THD_PROPERTY_SUSPENDED))) return 1;
  413dad:	8b 07                	mov    eax,DWORD PTR [rdi]
  413daf:	a8 04                	test   al,0x4
  413db1:	74 41                	je     413df4 <slm_thd_sched_wakeup+0x54>
	t->properties &= ~SLM_THD_PROPERTY_SUSPENDED;
  413db3:	83 e0 fb             	and    eax,0xfffffffb
  413db6:	89 07                	mov    DWORD PTR [rdi],eax
	if (unlikely(slm_state_is_runnable(t->state))) {
  413db8:	8b 47 04             	mov    eax,DWORD PTR [rdi+0x4]
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  413dbb:	8d 50 fe             	lea    edx,[rax-0x2]
  413dbe:	83 fa 01             	cmp    edx,0x1
  413dc1:	76 38                	jbe    413dfb <slm_thd_sched_wakeup+0x5b>
	assert(t->state == SLM_THD_BLOCKED);
  413dc3:	83 f8 01             	cmp    eax,0x1
  413dc6:	75 41                	jne    413e09 <slm_thd_sched_wakeup+0x69>
	t->state = SLM_THD_RUNNABLE;
  413dc8:	c7 47 04 03 00 00 00 	mov    DWORD PTR [rdi+0x4],0x3
	slm_sched_wakeup(t);
  413dcf:	e8 ac d9 fe ff       	call   401780 <slm_sched_wakeup>
	return 0;
  413dd4:	31 c0                	xor    eax,eax
}
  413dd6:	5d                   	pop    rbp
  413dd7:	c3                   	ret    
  413dd8:	be 23 00 00 00       	mov    esi,0x23
  413ddd:	bf 08 ef 41 00       	mov    edi,0x41ef08
  413de2:	e8 e9 62 ff ff       	call   40a0d0 <cos_print_str>
	assert(t);
  413de7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413dee:	00 00 00 00 
  413df2:	0f 0b                	ud2    
	if (unlikely(!(t->properties & SLM_THD_PROPERTY_SUSPENDED))) return 1;
  413df4:	b8 01 00 00 00       	mov    eax,0x1
}
  413df9:	5d                   	pop    rbp
  413dfa:	c3                   	ret    
		t->state = SLM_THD_RUNNABLE;
  413dfb:	c7 47 04 03 00 00 00 	mov    DWORD PTR [rdi+0x4],0x3
		return 1;
  413e02:	b8 01 00 00 00       	mov    eax,0x1
}
  413e07:	5d                   	pop    rbp
  413e08:	c3                   	ret    
  413e09:	be 23 00 00 00       	mov    esi,0x23
  413e0e:	bf e0 ec 41 00       	mov    edi,0x41ece0
  413e13:	e8 b8 62 ff ff       	call   40a0d0 <cos_print_str>
	assert(t->state == SLM_THD_BLOCKED);
  413e18:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413e1f:	00 00 00 00 
  413e23:	0f 0b                	ud2    
  413e25:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  413e2c:	00 00 00 00 

0000000000413e30 <slm_thd_wakeup>:
{
  413e30:	f3 0f 1e fa          	endbr64 
  413e34:	55                   	push   rbp
  413e35:	48 89 e5             	mov    rbp,rsp
  413e38:	41 54                	push   r12
  413e3a:	53                   	push   rbx
	assert(t);
  413e3b:	48 85 ff             	test   rdi,rdi
  413e3e:	74 6e                	je     413eae <slm_thd_wakeup+0x7e>
	if (unlikely(t->cpuid != cos_cpuid())) {
  413e40:	4c 63 67 38          	movsxd r12,DWORD PTR [rdi+0x38]
  413e44:	48 89 fb             	mov    rbx,rdi
  413e47:	45 85 e4             	test   r12d,r12d
  413e4a:	75 7e                	jne    413eca <slm_thd_wakeup+0x9a>
	if (t->state == SLM_THD_WOKEN) return 1;
  413e4c:	8b 47 04             	mov    eax,DWORD PTR [rdi+0x4]
  413e4f:	83 f8 02             	cmp    eax,0x2
  413e52:	74 4c                	je     413ea0 <slm_thd_wakeup+0x70>
	if (unlikely(t->state == SLM_THD_RUNNABLE || (redundant && t->state == SLM_THD_WOKEN))) {
  413e54:	83 f8 03             	cmp    eax,0x3
  413e57:	0f 84 22 01 00 00    	je     413f7f <slm_thd_wakeup+0x14f>
	assert(t->state == SLM_THD_BLOCKED);
  413e5d:	83 f8 01             	cmp    eax,0x1
  413e60:	0f 85 2b 01 00 00    	jne    413f91 <slm_thd_wakeup+0x161>
	return t != &g->idle_thd && t != &g->sched_thd;
  413e66:	48 81 ff c8 1e 5a 00 	cmp    rdi,0x5a1ec8
  413e6d:	0f 84 3d 01 00 00    	je     413fb0 <slm_thd_wakeup+0x180>
  413e73:	48 81 ff 40 1f 5a 00 	cmp    rdi,0x5a1f40
  413e7a:	0f 84 30 01 00 00    	je     413fb0 <slm_thd_wakeup+0x180>
	t->state = SLM_THD_RUNNABLE;
  413e80:	c7 47 04 03 00 00 00 	mov    DWORD PTR [rdi+0x4],0x3
	slm_sched_wakeup(t);
  413e87:	e8 f4 d8 fe ff       	call   401780 <slm_sched_wakeup>
	t->properties &= ~SLM_THD_PROPERTY_SUSPENDED;
  413e8c:	83 23 fb             	and    DWORD PTR [rbx],0xfffffffb
}
  413e8f:	44 89 e0             	mov    eax,r12d
  413e92:	5b                   	pop    rbx
  413e93:	41 5c                	pop    r12
  413e95:	5d                   	pop    rbp
  413e96:	c3                   	ret    
  413e97:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  413e9e:	00 00 
	if (t->state == SLM_THD_WOKEN) return 1;
  413ea0:	41 bc 01 00 00 00    	mov    r12d,0x1
}
  413ea6:	5b                   	pop    rbx
  413ea7:	44 89 e0             	mov    eax,r12d
  413eaa:	41 5c                	pop    r12
  413eac:	5d                   	pop    rbp
  413ead:	c3                   	ret    
  413eae:	be 23 00 00 00       	mov    esi,0x23
  413eb3:	bf 30 ef 41 00       	mov    edi,0x41ef30
  413eb8:	e8 13 62 ff ff       	call   40a0d0 <cos_print_str>
	assert(t);
  413ebd:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413ec4:	00 00 00 00 
  413ec8:	0f 0b                	ud2    
		event.tid = t->tid;
  413eca:	4d 69 cc c0 10 00 00 	imul   r9,r12,0x10c0
  413ed1:	4c 8b 57 18          	mov    r10,QWORD PTR [rdi+0x18]
	const unsigned int mask = ring->mask;
  413ed5:	45 8b 81 a4 0e 5a 00 	mov    r8d,DWORD PTR [r9+0x5a0ea4]
  413edc:	4d 8d 99 a8 00 00 00 	lea    r11,[r9+0xa8]
	producer = ck_pr_load_uint(&ring->p_head);
  413ee3:	49 8d b1 64 0e 5a 00 	lea    rsi,[r9+0x5a0e64]
  413eea:	41 8b 91 64 0e 5a 00 	mov    edx,DWORD PTR [r9+0x5a0e64]
		consumer = ck_pr_load_uint(&ring->c_head);
  413ef1:	49 8d 99 20 0e 5a 00 	lea    rbx,[r9+0x5a0e20]
  413ef8:	eb 10                	jmp    413f0a <slm_thd_wakeup+0xda>
  413efa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
CK_PR_CAS_S(uint, unsigned int, "cmpxchgl")
  413f00:	89 d0                	mov    eax,edx
  413f02:	f0 0f b1 0e          	lock cmpxchg DWORD PTR [rsi],ecx
  413f06:	89 c2                	mov    edx,eax
			if (ck_pr_cas_uint_value(&ring->p_head,
  413f08:	74 1c                	je     413f26 <slm_thd_wakeup+0xf6>
CK_PR_LOAD_S(uint, unsigned int, "movl")
  413f0a:	8b 3b                	mov    edi,DWORD PTR [rbx]
		if (CK_CC_LIKELY((producer - consumer) < mask)) {
  413f0c:	89 d0                	mov    eax,edx
		delta = producer + 1;
  413f0e:	8d 4a 01             	lea    ecx,[rdx+0x1]
		if (CK_CC_LIKELY((producer - consumer) < mask)) {
  413f11:	29 f8                	sub    eax,edi
  413f13:	41 39 c0             	cmp    r8d,eax
  413f16:	77 e8                	ja     413f00 <slm_thd_wakeup+0xd0>
  413f18:	8b 06                	mov    eax,DWORD PTR [rsi]
			if (producer == new_producer) {
  413f1a:	39 c2                	cmp    edx,eax
  413f1c:	0f 84 aa 00 00 00    	je     413fcc <slm_thd_wakeup+0x19c>
  413f22:	89 c2                	mov    edx,eax
  413f24:	eb e4                	jmp    413f0a <slm_thd_wakeup+0xda>
	buffer = (char *)buffer + ts * (producer & mask);
  413f26:	41 21 c0             	and    r8d,eax
	while (ck_pr_load_uint(&ring->p_tail) != producer)
  413f29:	49 8d 79 60          	lea    rdi,[r9+0x60]
	buffer = (char *)buffer + ts * (producer & mask);
  413f2d:	42 8d 34 c5 00 00 00 	lea    esi,[r8*8+0x0]
  413f34:	00 
	memcpy(buffer, entry, ts);
  413f35:	4d 89 94 33 00 0e 5a 	mov    QWORD PTR [r11+rsi*1+0x5a0e00],r10
  413f3c:	00 
	while (ck_pr_load_uint(&ring->p_tail) != producer)
  413f3d:	49 8d b1 60 0e 5a 00 	lea    rsi,[r9+0x5a0e60]
  413f44:	44 8b 87 00 0e 5a 00 	mov    r8d,DWORD PTR [rdi+0x5a0e00]
  413f4b:	41 39 c0             	cmp    r8d,eax
  413f4e:	74 08                	je     413f58 <slm_thd_wakeup+0x128>
	__asm__ __volatile__("pause" ::: "memory");
  413f50:	f3 90                	pause  
CK_PR_LOAD_S(uint, unsigned int, "movl")
  413f52:	8b 16                	mov    edx,DWORD PTR [rsi]
  413f54:	39 d0                	cmp    eax,edx
  413f56:	75 f8                	jne    413f50 <slm_thd_wakeup+0x120>
CK_PR_STORE_S(uint, unsigned int, "movl", CK_CC_IMM_U32)
  413f58:	89 8f 00 0e 5a 00    	mov    DWORD PTR [rdi+0x5a0e00],ecx
		cos_asnd(ipi_data->ipi_thd.asnd, 1);
  413f5e:	4d 69 e4 c0 10 00 00 	imul   r12,r12,0x10c0
  413f65:	be 01 00 00 00       	mov    esi,0x1
  413f6a:	49 8b bc 24 08 0e 5a 	mov    rdi,QWORD PTR [r12+0x5a0e08]
  413f71:	00 
		return 0;
  413f72:	45 31 e4             	xor    r12d,r12d
		cos_asnd(ipi_data->ipi_thd.asnd, 1);
  413f75:	e8 76 d4 ff ff       	call   4113f0 <cos_asnd>
		return 0;
  413f7a:	e9 10 ff ff ff       	jmp    413e8f <slm_thd_wakeup+0x5f>
		t->state = SLM_THD_WOKEN;
  413f7f:	c7 47 04 02 00 00 00 	mov    DWORD PTR [rdi+0x4],0x2
		return 1;
  413f86:	41 bc 01 00 00 00    	mov    r12d,0x1
  413f8c:	e9 fe fe ff ff       	jmp    413e8f <slm_thd_wakeup+0x5f>
  413f91:	be 23 00 00 00       	mov    esi,0x23
  413f96:	bf 58 ef 41 00       	mov    edi,0x41ef58
  413f9b:	e8 30 61 ff ff       	call   40a0d0 <cos_print_str>
	assert(t->state == SLM_THD_BLOCKED);
  413fa0:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413fa7:	00 00 00 00 
  413fab:	0f 0b                	ud2    
  413fad:	0f 1f 00             	nop    DWORD PTR [rax]
  413fb0:	be 23 00 00 00       	mov    esi,0x23
  413fb5:	bf a8 ef 41 00       	mov    edi,0x41efa8
  413fba:	e8 11 61 ff ff       	call   40a0d0 <cos_print_str>
	assert(slm_thd_normal(t));
  413fbf:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413fc6:	00 00 00 00 
  413fca:	0f 0b                	ud2    
  413fcc:	be 23 00 00 00       	mov    esi,0x23
  413fd1:	bf 80 ef 41 00       	mov    edi,0x41ef80
  413fd6:	e8 f5 60 ff ff       	call   40a0d0 <cos_print_str>
		assert(ret);
  413fdb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413fe2:	00 00 00 00 
  413fe6:	0f 0b                	ud2    
  413fe8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  413fef:	00 

0000000000413ff0 <slm_thd_wakeup_cs>:
{
  413ff0:	f3 0f 1e fa          	endbr64 
  413ff4:	55                   	push   rbp
  413ff5:	48 89 e5             	mov    rbp,rsp
  413ff8:	41 57                	push   r15
  413ffa:	41 56                	push   r14
  413ffc:	41 55                	push   r13
  413ffe:	41 54                	push   r12
  414000:	53                   	push   rbx
  414001:	48 83 ec 08          	sub    rsp,0x8
	assert(t);
  414005:	48 85 f6             	test   rsi,rsi
  414008:	0f 84 aa 01 00 00    	je     4141b8 <slm_thd_wakeup_cs+0x1c8>
  41400e:	48 89 fb             	mov    rbx,rdi
  414011:	49 89 f4             	mov    r12,rsi
	assert(current);
  414014:	48 85 ff             	test   rdi,rdi
  414017:	0f 84 0a 02 00 00    	je     414227 <slm_thd_wakeup_cs+0x237>
		tok    = cos_sched_sync();
  41401d:	e8 de d2 ff ff       	call   411300 <cos_sched_sync>
  414022:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  414024:	48 8b 05 95 de 18 00 	mov    rax,QWORD PTR [rip+0x18de95]        # 5a1ec0 <__slm_global>
		if (unlikely(owner)) {
  41402b:	48 89 c2             	mov    rdx,rax
  41402e:	48 83 e2 fe          	and    rdx,0xfffffffffffffffe
  414032:	0f 85 9c 01 00 00    	jne    4141d4 <slm_thd_wakeup_cs+0x1e4>
  414038:	f0 48 0f b1 1d 7f de 	lock cmpxchg QWORD PTR [rip+0x18de7f],rbx        # 5a1ec0 <__slm_global>
  41403f:	18 00 
  414041:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  414044:	84 c0                	test   al,al
  414046:	74 d5                	je     41401d <slm_thd_wakeup_cs+0x2d>
	if (slm_thd_wakeup(t, 0)) {
  414048:	31 f6                	xor    esi,esi
  41404a:	4c 89 e7             	mov    rdi,r12
  41404d:	e8 de fd ff ff       	call   413e30 <slm_thd_wakeup>
  414052:	85 c0                	test   eax,eax
  414054:	0f 85 e6 00 00 00    	jne    414140 <slm_thd_wakeup_cs+0x150>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  41405a:	e8 01 78 ff ff       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(!t)) t = &g->idle_thd;
  41405f:	41 bf 40 1f 5a 00    	mov    r15d,0x5a1f40
  414065:	45 31 f6             	xor    r14d,r14d
	tok  = cos_sched_sync();
  414068:	e8 93 d2 ff ff       	call   411300 <cos_sched_sync>
  41406d:	41 89 c5             	mov    r13d,eax
	t = slm_sched_schedule();
  414070:	e8 2b d7 fe ff       	call   4017a0 <slm_sched_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  414075:	48 85 c0             	test   rax,rax
	t = slm_sched_schedule();
  414078:	49 89 c4             	mov    r12,rax
	if (unlikely(!t)) t = &g->idle_thd;
  41407b:	4d 0f 44 e7          	cmove  r12,r15
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  41407f:	41 8b 44 24 04       	mov    eax,DWORD PTR [r12+0x4]
  414084:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  414087:	83 f8 01             	cmp    eax,0x1
  41408a:	76 1c                	jbe    4140a8 <slm_thd_wakeup_cs+0xb8>
  41408c:	e9 ff 01 00 00       	jmp    414290 <slm_thd_wakeup_cs+0x2a0>
  414091:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  414098:	f0 48 0f b1 35 1f de 	lock cmpxchg QWORD PTR [rip+0x18de1f],rsi        # 5a1ec0 <__slm_global>
  41409f:	18 00 
  4140a1:	0f 94 c0             	sete   al
	while (ret != 0) {
  4140a4:	84 c0                	test   al,al
  4140a6:	75 48                	jne    4140f0 <slm_thd_wakeup_cs+0x100>
		tok    = cos_sched_sync();
  4140a8:	e8 53 d2 ff ff       	call   411300 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  4140ad:	48 8b 15 0c de 18 00 	mov    rdx,QWORD PTR [rip+0x18de0c]        # 5a1ec0 <__slm_global>
  4140b4:	89 c1                	mov    ecx,eax
		if (unlikely(contention)) {
  4140b6:	48 89 d6             	mov    rsi,rdx
  4140b9:	48 89 d0             	mov    rax,rdx
  4140bc:	83 e6 01             	and    esi,0x1
  4140bf:	74 d7                	je     414098 <slm_thd_wakeup_cs+0xa8>
  4140c1:	f0 4c 0f b1 35 f6 dd 	lock cmpxchg QWORD PTR [rip+0x18ddf6],r14        # 5a1ec0 <__slm_global>
  4140c8:	18 00 
  4140ca:	0f 94 c0             	sete   al
	if (__slm_cs_cas(cs, cached, NULL, 0)) return 1;
  4140cd:	84 c0                	test   al,al
  4140cf:	74 d7                	je     4140a8 <slm_thd_wakeup_cs+0xb8>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  4140d1:	48 83 e2 fe          	and    rdx,0xfffffffffffffffe
	ret = cos_defswitch(s->thd, curr->priority, TCAP_TIME_NIL, tok);
  4140d5:	48 8b 3d fc dd 18 00 	mov    rdi,QWORD PTR [rip+0x18ddfc]        # 5a1ed8 <__slm_global+0x18>
  4140dc:	48 8b 72 30          	mov    rsi,QWORD PTR [rdx+0x30]
  4140e0:	31 d2                	xor    edx,edx
  4140e2:	e8 79 86 ff ff       	call   40c760 <cos_defswitch>
	assert(ret != -EINVAL);
  4140e7:	83 f8 ea             	cmp    eax,0xffffffea
  4140ea:	0f 84 ac 00 00 00    	je     41419c <slm_thd_wakeup_cs+0x1ac>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  4140f0:	e8 6b 77 ff ff       	call   40b860 <cos_defcompinfo_curr_get>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4140f5:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
	prio = inherit_prio ? curr->priority : t->priority;
  4140f9:	49 8b 74 24 30       	mov    rsi,QWORD PTR [r12+0x30]
	timeout = g->timeout_next;
  4140fe:	4c 8b 05 c3 de 18 00 	mov    r8,QWORD PTR [rip+0x18dec3]        # 5a1fc8 <__slm_global+0x108>
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  414105:	a8 0b                	test   al,0xb
  414107:	0f 85 9f 01 00 00    	jne    4142ac <slm_thd_wakeup_cs+0x2bc>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  41410d:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  414112:	44 89 e9             	mov    ecx,r13d
  414115:	4c 89 c2             	mov    rdx,r8
  414118:	e8 43 86 ff ff       	call   40c760 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  41411d:	83 f8 ff             	cmp    eax,0xffffffff
  414120:	0f 84 f5 01 00 00    	je     41431b <slm_thd_wakeup_cs+0x32b>
	if (unlikely(ret != 0)) {
  414126:	85 c0                	test   eax,eax
  414128:	0f 85 15 01 00 00    	jne    414243 <slm_thd_wakeup_cs+0x253>
}
  41412e:	48 83 c4 08          	add    rsp,0x8
  414132:	5b                   	pop    rbx
  414133:	41 5c                	pop    r12
  414135:	41 5d                	pop    r13
  414137:	41 5e                	pop    r14
  414139:	41 5f                	pop    r15
  41413b:	5d                   	pop    rbp
  41413c:	c3                   	ret    
  41413d:	0f 1f 00             	nop    DWORD PTR [rax]
  414140:	31 db                	xor    ebx,ebx
  414142:	eb 14                	jmp    414158 <slm_thd_wakeup_cs+0x168>
  414144:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  414148:	f0 48 0f b1 35 6f dd 	lock cmpxchg QWORD PTR [rip+0x18dd6f],rsi        # 5a1ec0 <__slm_global>
  41414f:	18 00 
  414151:	0f 94 c0             	sete   al
	while (ret != 0) {
  414154:	84 c0                	test   al,al
  414156:	75 d6                	jne    41412e <slm_thd_wakeup_cs+0x13e>
		tok    = cos_sched_sync();
  414158:	e8 a3 d1 ff ff       	call   411300 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  41415d:	48 8b 15 5c dd 18 00 	mov    rdx,QWORD PTR [rip+0x18dd5c]        # 5a1ec0 <__slm_global>
  414164:	89 c1                	mov    ecx,eax
		if (unlikely(contention)) {
  414166:	48 89 d6             	mov    rsi,rdx
  414169:	48 89 d0             	mov    rax,rdx
  41416c:	83 e6 01             	and    esi,0x1
  41416f:	74 d7                	je     414148 <slm_thd_wakeup_cs+0x158>
  414171:	f0 48 0f b1 1d 46 dd 	lock cmpxchg QWORD PTR [rip+0x18dd46],rbx        # 5a1ec0 <__slm_global>
  414178:	18 00 
  41417a:	0f 94 c0             	sete   al
	if (__slm_cs_cas(cs, cached, NULL, 0)) return 1;
  41417d:	84 c0                	test   al,al
  41417f:	74 d7                	je     414158 <slm_thd_wakeup_cs+0x168>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  414181:	48 83 e2 fe          	and    rdx,0xfffffffffffffffe
	ret = cos_defswitch(s->thd, curr->priority, TCAP_TIME_NIL, tok);
  414185:	48 8b 3d 4c dd 18 00 	mov    rdi,QWORD PTR [rip+0x18dd4c]        # 5a1ed8 <__slm_global+0x18>
  41418c:	48 8b 72 30          	mov    rsi,QWORD PTR [rdx+0x30]
  414190:	31 d2                	xor    edx,edx
  414192:	e8 c9 85 ff ff       	call   40c760 <cos_defswitch>
	assert(ret != -EINVAL);
  414197:	83 f8 ea             	cmp    eax,0xffffffea
  41419a:	75 92                	jne    41412e <slm_thd_wakeup_cs+0x13e>
  41419c:	be 23 00 00 00       	mov    esi,0x23
  4141a1:	bf 08 ed 41 00       	mov    edi,0x41ed08
  4141a6:	e8 25 5f ff ff       	call   40a0d0 <cos_print_str>
  4141ab:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4141b2:	00 00 00 00 
  4141b6:	0f 0b                	ud2    
  4141b8:	be 23 00 00 00       	mov    esi,0x23
  4141bd:	bf d0 ef 41 00       	mov    edi,0x41efd0
  4141c2:	e8 09 5f ff ff       	call   40a0d0 <cos_print_str>
	assert(t);
  4141c7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4141ce:	00 00 00 00 
  4141d2:	0f 0b                	ud2    
	if (!contended) {
  4141d4:	a8 01                	test   al,0x1
  4141d6:	75 1b                	jne    4141f3 <slm_thd_wakeup_cs+0x203>
	return !ps_cas(&cs->owner_contention, (unsigned long)cached, ((unsigned long)thd | !!contention));
  4141d8:	48 89 d6             	mov    rsi,rdx
  4141db:	48 83 ce 01          	or     rsi,0x1
  4141df:	f0 48 0f b1 35 d8 dc 	lock cmpxchg QWORD PTR [rip+0x18dcd8],rsi        # 5a1ec0 <__slm_global>
  4141e6:	18 00 
  4141e8:	0f 94 c0             	sete   al
		if (__slm_cs_cas(cs, cached, owner, 1)) return 1;
  4141eb:	84 c0                	test   al,al
  4141ed:	0f 84 2a fe ff ff    	je     41401d <slm_thd_wakeup_cs+0x2d>
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  4141f3:	48 8b 7a 10          	mov    rdi,QWORD PTR [rdx+0x10]
  4141f7:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
  4141fb:	31 d2                	xor    edx,edx
  4141fd:	e8 5e 85 ff ff       	call   40c760 <cos_defswitch>
			assert(ret != -EBUSY);
  414202:	83 f8 f0             	cmp    eax,0xfffffff0
  414205:	0f 85 12 fe ff ff    	jne    41401d <slm_thd_wakeup_cs+0x2d>
  41420b:	be 25 00 00 00       	mov    esi,0x25
  414210:	bf f0 ed 41 00       	mov    edi,0x41edf0
  414215:	e8 b6 5e ff ff       	call   40a0d0 <cos_print_str>
  41421a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414221:	00 00 00 00 
  414225:	0f 0b                	ud2    
  414227:	be 25 00 00 00       	mov    esi,0x25
  41422c:	bf e0 ee 41 00       	mov    edi,0x41eee0
  414231:	e8 9a 5e ff ff       	call   40a0d0 <cos_print_str>
	assert(current);
  414236:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41423d:	00 00 00 00 
  414241:	0f 0b                	ud2    
		assert(ret != -EINVAL);
  414243:	83 f8 ea             	cmp    eax,0xffffffea
  414246:	0f 84 98 01 00 00    	je     4143e4 <slm_thd_wakeup_cs+0x3f4>
		if (ret == -EBUSY) return ret;
  41424c:	83 f8 f0             	cmp    eax,0xfffffff0
  41424f:	0f 84 d9 fe ff ff    	je     41412e <slm_thd_wakeup_cs+0x13e>
		assert(ret == -EAGAIN);
  414255:	83 f8 f5             	cmp    eax,0xfffffff5
  414258:	0f 85 6a 01 00 00    	jne    4143c8 <slm_thd_wakeup_cs+0x3d8>
		tok    = cos_sched_sync();
  41425e:	e8 9d d0 ff ff       	call   411300 <cos_sched_sync>
  414263:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  414265:	48 8b 05 54 dc 18 00 	mov    rax,QWORD PTR [rip+0x18dc54]        # 5a1ec0 <__slm_global>
		if (unlikely(owner)) {
  41426c:	48 89 c6             	mov    rsi,rax
  41426f:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  414273:	0f 85 fb 00 00 00    	jne    414374 <slm_thd_wakeup_cs+0x384>
  414279:	f0 48 0f b1 1d 3e dc 	lock cmpxchg QWORD PTR [rip+0x18dc3e],rbx        # 5a1ec0 <__slm_global>
  414280:	18 00 
  414282:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  414285:	84 c0                	test   al,al
  414287:	0f 85 db fd ff ff    	jne    414068 <slm_thd_wakeup_cs+0x78>
  41428d:	eb cf                	jmp    41425e <slm_thd_wakeup_cs+0x26e>
  41428f:	90                   	nop
  414290:	be 2d 00 00 00       	mov    esi,0x2d
  414295:	bf 30 ed 41 00       	mov    edi,0x41ed30
  41429a:	e8 31 5e ff ff       	call   40a0d0 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  41429f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4142a6:	00 00 00 00 
  4142aa:	0f 0b                	ud2    
	timeout = g->timeout_next;
  4142ac:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  4142af:	49 81 fc c8 1e 5a 00 	cmp    r12,0x5a1ec8
  4142b6:	0f 84 91 00 00 00    	je     41434d <slm_thd_wakeup_cs+0x35d>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  4142bc:	a8 02                	test   al,0x2
  4142be:	0f 85 94 00 00 00    	jne    414358 <slm_thd_wakeup_cs+0x368>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  4142c4:	49 89 c8             	mov    r8,rcx
  4142c7:	a8 01                	test   al,0x1
  4142c9:	0f 84 3e fe ff ff    	je     41410d <slm_thd_wakeup_cs+0x11d>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  4142cf:	4d 8b 54 24 08       	mov    r10,QWORD PTR [r12+0x8]
  4142d4:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  4142d9:	48 89 f2             	mov    rdx,rsi
  4142dc:	45 89 e9             	mov    r9d,r13d
  4142df:	4c 8b 05 02 dc 18 00 	mov    r8,QWORD PTR [rip+0x18dc02]        # 5a1ee8 <__slm_global+0x28>
  4142e6:	4c 89 d6             	mov    rsi,r10
  4142e9:	e8 32 d0 ff ff       	call   411320 <cos_switch>
	if (unlikely(ret != 0)) {
  4142ee:	85 c0                	test   eax,eax
  4142f0:	0f 84 38 fe ff ff    	je     41412e <slm_thd_wakeup_cs+0x13e>
		assert(ret != -EPERM);
  4142f6:	83 f8 ff             	cmp    eax,0xffffffff
  4142f9:	0f 85 44 ff ff ff    	jne    414243 <slm_thd_wakeup_cs+0x253>
  4142ff:	be 2d 00 00 00       	mov    esi,0x2d
  414304:	bf 60 ed 41 00       	mov    edi,0x41ed60
  414309:	e8 c2 5d ff ff       	call   40a0d0 <cos_print_str>
  41430e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414315:	00 00 00 00 
  414319:	0f 0b                	ud2    
	return t != &g->idle_thd && t != &g->sched_thd;
  41431b:	49 81 fc 40 1f 5a 00 	cmp    r12,0x5a1f40
  414322:	74 09                	je     41432d <slm_thd_wakeup_cs+0x33d>
  414324:	49 81 fc c8 1e 5a 00 	cmp    r12,0x5a1ec8
  41432b:	75 d2                	jne    4142ff <slm_thd_wakeup_cs+0x30f>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  41432d:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]
  414331:	4c 8b 05 b0 db 18 00 	mov    r8,QWORD PTR [rip+0x18dbb0]        # 5a1ee8 <__slm_global+0x28>
  414338:	45 89 e9             	mov    r9d,r13d
  41433b:	31 c9                	xor    ecx,ecx
  41433d:	48 8b 3d 94 db 18 00 	mov    rdi,QWORD PTR [rip+0x18db94]        # 5a1ed8 <__slm_global+0x18>
  414344:	31 f6                	xor    esi,esi
  414346:	e8 d5 cf ff ff       	call   411320 <cos_switch>
  41434b:	eb a1                	jmp    4142ee <slm_thd_wakeup_cs+0x2fe>
			prio    = curr->priority;
  41434d:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
			timeout = TCAP_TIME_NIL;
  414351:	31 c9                	xor    ecx,ecx
  414353:	e9 64 ff ff ff       	jmp    4142bc <slm_thd_wakeup_cs+0x2cc>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  414358:	49 8b 7c 24 28       	mov    rdi,QWORD PTR [r12+0x28]
  41435d:	48 8b 15 84 db 18 00 	mov    rdx,QWORD PTR [rip+0x18db84]        # 5a1ee8 <__slm_global+0x28>
  414364:	44 89 e9             	mov    ecx,r13d
  414367:	4c 89 c6             	mov    rsi,r8
  41436a:	e8 21 d0 ff ff       	call   411390 <cos_sched_asnd>
  41436f:	e9 7a ff ff ff       	jmp    4142ee <slm_thd_wakeup_cs+0x2fe>
	if (!contended) {
  414374:	a8 01                	test   al,0x1
  414376:	75 1b                	jne    414393 <slm_thd_wakeup_cs+0x3a3>
	return !ps_cas(&cs->owner_contention, (unsigned long)cached, ((unsigned long)thd | !!contention));
  414378:	48 89 f2             	mov    rdx,rsi
  41437b:	48 83 ca 01          	or     rdx,0x1
  41437f:	f0 48 0f b1 15 38 db 	lock cmpxchg QWORD PTR [rip+0x18db38],rdx        # 5a1ec0 <__slm_global>
  414386:	18 00 
  414388:	0f 94 c0             	sete   al
		if (__slm_cs_cas(cs, cached, owner, 1)) return 1;
  41438b:	84 c0                	test   al,al
  41438d:	0f 84 cb fe ff ff    	je     41425e <slm_thd_wakeup_cs+0x26e>
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  414393:	4c 8b 43 30          	mov    r8,QWORD PTR [rbx+0x30]
  414397:	48 8b 7e 10          	mov    rdi,QWORD PTR [rsi+0x10]
  41439b:	31 d2                	xor    edx,edx
  41439d:	4c 89 c6             	mov    rsi,r8
  4143a0:	e8 bb 83 ff ff       	call   40c760 <cos_defswitch>
			assert(ret != -EBUSY);
  4143a5:	83 f8 f0             	cmp    eax,0xfffffff0
  4143a8:	0f 85 b0 fe ff ff    	jne    41425e <slm_thd_wakeup_cs+0x26e>
  4143ae:	bf f0 ed 41 00       	mov    edi,0x41edf0
  4143b3:	e8 68 ea ff ff       	call   412e20 <prints.isra.0>
  4143b8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4143bf:	00 00 00 00 
  4143c3:	0f 0b                	ud2    
  4143c5:	0f 1f 00             	nop    DWORD PTR [rax]
  4143c8:	be 2d 00 00 00       	mov    esi,0x2d
  4143cd:	bf c0 ed 41 00       	mov    edi,0x41edc0
  4143d2:	e8 f9 5c ff ff       	call   40a0d0 <cos_print_str>
		assert(ret == -EAGAIN);
  4143d7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4143de:	00 00 00 00 
  4143e2:	0f 0b                	ud2    
  4143e4:	be 2d 00 00 00       	mov    esi,0x2d
  4143e9:	bf 90 ed 41 00       	mov    edi,0x41ed90
  4143ee:	e8 dd 5c ff ff       	call   40a0d0 <cos_print_str>
		assert(ret != -EINVAL);
  4143f3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4143fa:	00 00 00 00 
  4143fe:	0f 0b                	ud2    

0000000000414400 <slm_thd_event_reset>:
{
  414400:	f3 0f 1e fa          	endbr64 
	memset(&t->event_info, 0, sizeof(struct event_info));
  414404:	66 0f ef c0          	pxor   xmm0,xmm0
  414408:	48 c7 47 50 00 00 00 	mov    QWORD PTR [rdi+0x50],0x0
  41440f:	00 
  414410:	0f 11 47 40          	movups XMMWORD PTR [rdi+0x40],xmm0
}
  414414:	c3                   	ret    
  414415:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41441c:	00 00 00 00 

0000000000414420 <slm_get_cycs_per_usec>:
{
  414420:	f3 0f 1e fa          	endbr64 
	return (unsigned long)g->cyc_per_usec;
  414424:	48 63 05 8d db 18 00 	movsxd rax,DWORD PTR [rip+0x18db8d]        # 5a1fb8 <__slm_global+0xf8>
}
  41442b:	c3                   	ret    
  41442c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000414430 <slm_sched_loop>:
	}
}

void
slm_sched_loop(void)
{
  414430:	f3 0f 1e fa          	endbr64 
  414434:	55                   	push   rbp
	slm_sched_loop_intern(0);
  414435:	31 ff                	xor    edi,edi
{
  414437:	48 89 e5             	mov    rbp,rsp
	slm_sched_loop_intern(0);
  41443a:	e8 11 ea ff ff       	call   412e50 <slm_sched_loop_intern>
  41443f:	90                   	nop

0000000000414440 <slm_sched_loop_nonblock>:
}

void
slm_sched_loop_nonblock(void)
{
  414440:	f3 0f 1e fa          	endbr64 
  414444:	55                   	push   rbp
	slm_sched_loop_intern(1);
  414445:	bf 01 00 00 00       	mov    edi,0x1
{
  41444a:	48 89 e5             	mov    rbp,rsp
	slm_sched_loop_intern(1);
  41444d:	e8 fe e9 ff ff       	call   412e50 <slm_sched_loop_intern>
  414452:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  414459:	00 00 00 00 
  41445d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000414460 <slm_init>:
}

void
slm_init(thdcap_t thd, thdid_t tid)
{
  414460:	f3 0f 1e fa          	endbr64 
  414464:	55                   	push   rbp
  414465:	48 89 e5             	mov    rbp,rsp
  414468:	41 57                	push   r15
  41446a:	41 56                	push   r14
  41446c:	41 55                	push   r13
  41446e:	49 89 f5             	mov    r13,rsi
  414471:	41 54                	push   r12
  414473:	41 bc 20 1f 5a 00    	mov    r12d,0x5a1f20
  414479:	53                   	push   rbx
  41447a:	bb 30 1f 5a 00       	mov    ebx,0x5a1f30
  41447f:	48 83 ec 18          	sub    rsp,0x18
  414483:	48 89 7d c8          	mov    QWORD PTR [rbp-0x38],rdi
	struct slm_thd *s    = &g->sched_thd;
	struct slm_thd *i    = &g->idle_thd;
	struct cos_defcompinfo *defci;
	struct cos_aep_info    *sched_aep;

	defci = cos_defcompinfo_curr_get();
  414487:	e8 d4 73 ff ff       	call   40b860 <cos_defcompinfo_curr_get>
  41448c:	48 89 c7             	mov    rdi,rax
	sched_aep = cos_sched_aep_get(defci);
  41448f:	e8 0c 74 ff ff       	call   40b8a0 <cos_sched_aep_get>

	*s = (struct slm_thd) {
  414494:	66 0f ef c0          	pxor   xmm0,xmm0
  414498:	48 8b 0d 81 ab 00 00 	mov    rcx,QWORD PTR [rip+0xab81]        # 41f020 <CSWTCH.186+0x5b0>
		.properties = SLM_THD_PROPERTY_SPECIAL,
		.state = SLM_THD_RUNNABLE,
		.tc  = sched_aep->tc,
  41449f:	f3 0f 6f 10          	movdqu xmm2,XMMWORD PTR [rax]
  4144a3:	f3 0f 6f 48 10       	movdqu xmm1,XMMWORD PTR [rax+0x10]
  4144a8:	48 8b 00             	mov    rax,QWORD PTR [rax]
	*s = (struct slm_thd) {
  4144ab:	0f 29 05 3e da 18 00 	movaps XMMWORD PTR [rip+0x18da3e],xmm0        # 5a1ef0 <__slm_global+0x30>
  4144b2:	0f 29 15 17 da 18 00 	movaps XMMWORD PTR [rip+0x18da17],xmm2        # 5a1ed0 <__slm_global+0x10>
  4144b9:	66 49 0f 6e d4       	movq   xmm2,r12
  4144be:	66 0f 6c d2          	punpcklqdq xmm2,xmm2
  4144c2:	0f 29 05 37 da 18 00 	movaps XMMWORD PTR [rip+0x18da37],xmm0        # 5a1f00 <__slm_global+0x40>
  4144c9:	66 48 0f 6e d8       	movq   xmm3,rax
		.cpuid = cos_cpuid(),
		.priority = TCAP_PRIO_MAX
	};
	ps_list_init(s, thd_list);
	ps_list_init(s, graveyard_list);
	assert(s->tid == cos_thdid());
  4144ce:	66 48 0f 7e c8       	movq   rax,xmm1
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  4144d3:	48 89 e2             	mov    rdx,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  4144d6:	48 81 e2 00 e0 ff ff 	and    rdx,0xffffffffffffe000
	*s = (struct slm_thd) {
  4144dd:	0f 29 05 2c da 18 00 	movaps XMMWORD PTR [rip+0x18da2c],xmm0        # 5a1f10 <__slm_global+0x50>
  4144e4:	0f 16 5d c8          	movhps xmm3,QWORD PTR [rbp-0x38]
  4144e8:	0f 29 0d f1 d9 18 00 	movaps XMMWORD PTR [rip+0x18d9f1],xmm1        # 5a1ee0 <__slm_global+0x20>
	return cos_get_thd_id();
  4144ef:	0f b7 92 f0 1f 00 00 	movzx  edx,WORD PTR [rdx+0x1ff0]
  4144f6:	0f 29 15 23 da 18 00 	movaps XMMWORD PTR [rip+0x18da23],xmm2        # 5a1f20 <__slm_global+0x60>
  4144fd:	66 48 0f 6e d3       	movq   xmm2,rbx
  414502:	66 0f 6c d2          	punpcklqdq xmm2,xmm2
  414506:	48 89 0d bb d9 18 00 	mov    QWORD PTR [rip+0x18d9bb],rcx        # 5a1ec8 <__slm_global+0x8>
  41450d:	48 c7 05 e0 d9 18 00 	mov    QWORD PTR [rip+0x18d9e0],0x1        # 5a1ef8 <__slm_global+0x38>
  414514:	01 00 00 00 
  414518:	0f 29 15 11 da 18 00 	movaps XMMWORD PTR [rip+0x18da11],xmm2        # 5a1f30 <__slm_global+0x70>
	assert(s->tid == cos_thdid());
  41451f:	48 39 d0             	cmp    rax,rdx
  414522:	0f 85 cb 00 00 00    	jne    4145f3 <slm_init+0x193>
  414528:	41 bf 98 1f 5a 00    	mov    r15d,0x5a1f98

	*i = (struct slm_thd) {
  41452e:	0f 29 05 3b da 18 00 	movaps XMMWORD PTR [rip+0x18da3b],xmm0        # 5a1f70 <__slm_global+0xb0>
  414535:	41 be a8 1f 5a 00    	mov    r14d,0x5a1fa8
  41453b:	48 b8 ff ff ff ff ff 	movabs rax,0xffffffffffff
  414542:	ff 00 00 
  414545:	0f 29 05 14 da 18 00 	movaps XMMWORD PTR [rip+0x18da14],xmm0        # 5a1f60 <__slm_global+0xa0>
	ps_list_init(i, graveyard_list);

	ps_list_head_init(&g->event_head);
	ps_list_head_init(&g->graveyard_head);

	g->cyc_per_usec = cos_hw_cycles_per_usec(BOOT_CAPTBL_SELF_INITHW_BASE);
  41454c:	bf 24 00 00 00       	mov    edi,0x24
	*i = (struct slm_thd) {
  414551:	0f 29 05 28 da 18 00 	movaps XMMWORD PTR [rip+0x18da28],xmm0        # 5a1f80 <__slm_global+0xc0>
  414558:	66 49 0f 6e c7       	movq   xmm0,r15
  41455d:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  414561:	48 89 0d d8 d9 18 00 	mov    QWORD PTR [rip+0x18d9d8],rcx        # 5a1f40 <__slm_global+0x80>
  414568:	0f 11 05 29 da 18 00 	movups XMMWORD PTR [rip+0x18da29],xmm0        # 5a1f98 <__slm_global+0xd8>
  41456f:	66 49 0f 6e c6       	movq   xmm0,r14
  414574:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  414578:	4c 89 2d d9 d9 18 00 	mov    QWORD PTR [rip+0x18d9d9],r13        # 5a1f58 <__slm_global+0x98>
  41457f:	0f 11 05 22 da 18 00 	movups XMMWORD PTR [rip+0x18da22],xmm0        # 5a1fa8 <__slm_global+0xe8>
  414586:	f3 0f 7e 05 9a aa 00 	movq   xmm0,QWORD PTR [rip+0xaa9a]        # 41f028 <CSWTCH.186+0x5b8>
  41458d:	00 
  41458e:	0f 11 1d b3 d9 18 00 	movups XMMWORD PTR [rip+0x18d9b3],xmm3        # 5a1f48 <__slm_global+0x88>
  414595:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  414599:	48 89 05 d0 d9 18 00 	mov    QWORD PTR [rip+0x18d9d0],rax        # 5a1f70 <__slm_global+0xb0>
  4145a0:	0f 29 05 29 da 18 00 	movaps XMMWORD PTR [rip+0x18da29],xmm0        # 5a1fd0 <__slm_global+0x110>
  4145a7:	f3 0f 7e 05 81 aa 00 	movq   xmm0,QWORD PTR [rip+0xaa81]        # 41f030 <CSWTCH.186+0x5c0>
  4145ae:	00 
  4145af:	48 c7 05 d6 d9 18 00 	mov    QWORD PTR [rip+0x18d9d6],0x0        # 5a1f90 <__slm_global+0xd0>
  4145b6:	00 00 00 00 
  4145ba:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  4145be:	0f 29 05 1b da 18 00 	movaps XMMWORD PTR [rip+0x18da1b],xmm0        # 5a1fe0 <__slm_global+0x120>
	g->cyc_per_usec = cos_hw_cycles_per_usec(BOOT_CAPTBL_SELF_INITHW_BASE);
  4145c5:	e8 56 d9 ff ff       	call   411f20 <cos_hw_cycles_per_usec>
	g->lock.owner_contention = 0;
  4145ca:	48 c7 05 eb d8 18 00 	mov    QWORD PTR [rip+0x18d8eb],0x0        # 5a1ec0 <__slm_global>
  4145d1:	00 00 00 00 
	g->cyc_per_usec = cos_hw_cycles_per_usec(BOOT_CAPTBL_SELF_INITHW_BASE);
  4145d5:	89 05 dd d9 18 00    	mov    DWORD PTR [rip+0x18d9dd],eax        # 5a1fb8 <__slm_global+0xf8>

	slm_sched_init();
  4145db:	e8 50 d1 fe ff       	call   401730 <slm_sched_init>
	slm_timer_init();
}
  4145e0:	48 83 c4 18          	add    rsp,0x18
  4145e4:	5b                   	pop    rbx
  4145e5:	41 5c                	pop    r12
  4145e7:	41 5d                	pop    r13
  4145e9:	41 5e                	pop    r14
  4145eb:	41 5f                	pop    r15
  4145ed:	5d                   	pop    rbp
	slm_timer_init();
  4145ee:	e9 2d d1 fe ff       	jmp    401720 <slm_timer_init>
  4145f3:	be 23 00 00 00       	mov    esi,0x23
  4145f8:	bf f8 ef 41 00       	mov    edi,0x41eff8
  4145fd:	e8 ce 5a ff ff       	call   40a0d0 <cos_print_str>
	assert(s->tid == cos_thdid());
  414602:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414609:	00 00 00 00 
  41460d:	0f 0b                	ud2    
  41460f:	90                   	nop

0000000000414610 <heap_init>:
#endif

/* public functions */
void
heap_init(struct heap *h, int max_sz, cmp_fn_t c, update_fn_t u)
{
  414610:	f3 0f 1e fa          	endbr64 
  414614:	66 48 0f 6e c2       	movq   xmm0,rdx
  414619:	66 48 0f 6e c9       	movq   xmm1,rcx
  41461e:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
	assert(h);
  414622:	48 85 ff             	test   rdi,rdi
  414625:	74 19                	je     414640 <heap_init+0x30>

	h->max_sz = max_sz + 1;
  414627:	83 c6 01             	add    esi,0x1
	h->e      = 1;
	h->c      = c;
	h->u      = u;
	h->data   = (void *)&h[1];
  41462a:	48 8d 47 20          	lea    rax,[rdi+0x20]
	h->e      = 1;
  41462e:	c7 07 01 00 00 00    	mov    DWORD PTR [rdi],0x1
	h->max_sz = max_sz + 1;
  414634:	89 77 04             	mov    DWORD PTR [rdi+0x4],esi
	h->data   = (void *)&h[1];
  414637:	48 89 47 18          	mov    QWORD PTR [rdi+0x18],rax
	h->c      = c;
  41463b:	0f 11 47 08          	movups XMMWORD PTR [rdi+0x8],xmm0
	h->data   = (void *)&h[1];
  41463f:	c3                   	ret    
{
  414640:	55                   	push   rbp
  414641:	be 24 00 00 00       	mov    esi,0x24
  414646:	bf 38 f0 41 00       	mov    edi,0x41f038
  41464b:	48 89 e5             	mov    rbp,rsp
  41464e:	e8 7d 5a ff ff       	call   40a0d0 <cos_print_str>
	assert(h);
  414653:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41465a:	00 00 00 00 
  41465e:	0f 0b                	ud2    

0000000000414660 <heap_alloc>:
	assert(!heap_verify(h));
}

struct heap *
heap_alloc(int max_sz, cmp_fn_t c, update_fn_t u)
{
  414660:	f3 0f 1e fa          	endbr64 

	heap_init(h, max_sz, c, u);
#endif

	return h;
}
  414664:	31 c0                	xor    eax,eax
  414666:	c3                   	ret    
  414667:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41466e:	00 00 

0000000000414670 <heap_destroy>:

void
heap_destroy(struct heap *h)
{
  414670:	f3 0f 1e fa          	endbr64 
	assert(h && h->data);
  414674:	48 85 ff             	test   rdi,rdi
  414677:	74 08                	je     414681 <heap_destroy+0x11>
  414679:	48 83 7f 18 00       	cmp    QWORD PTR [rdi+0x18],0x0
  41467e:	74 01                	je     414681 <heap_destroy+0x11>
  414680:	c3                   	ret    
{
  414681:	55                   	push   rbp
  414682:	be 24 00 00 00       	mov    esi,0x24
  414687:	bf 60 f0 41 00       	mov    edi,0x41f060
  41468c:	48 89 e5             	mov    rbp,rsp
  41468f:	e8 3c 5a ff ff       	call   40a0d0 <cos_print_str>
	assert(h && h->data);
  414694:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41469b:	00 00 00 00 
  41469f:	0f 0b                	ud2    
  4146a1:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4146a8:	00 00 00 00 
  4146ac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

00000000004146b0 <heap_add>:
#endif
}

int
heap_add(struct heap *h, void *new)
{
  4146b0:	f3 0f 1e fa          	endbr64 
  4146b4:	55                   	push   rbp
  4146b5:	48 89 e5             	mov    rbp,rsp
  4146b8:	41 57                	push   r15
  4146ba:	41 56                	push   r14
  4146bc:	41 55                	push   r13
  4146be:	41 54                	push   r12
  4146c0:	53                   	push   rbx
  4146c1:	48 89 fb             	mov    rbx,rdi
  4146c4:	48 83 ec 18          	sub    rsp,0x18
	int c;

	if (h->max_sz == h->e) return -1;
  4146c8:	44 8b 37             	mov    r14d,DWORD PTR [rdi]
  4146cb:	44 39 77 04          	cmp    DWORD PTR [rdi+0x4],r14d
  4146cf:	0f 84 fd 01 00 00    	je     4148d2 <heap_add+0x222>

	debug("heap_add(%p,%d) %p\n", h, h->e, new);

	assert(!heap_verify(h));
	c          = h->e;
	h->data[c] = new;
  4146d5:	48 8b 53 18          	mov    rdx,QWORD PTR [rbx+0x18]
  4146d9:	49 63 c6             	movsxd rax,r14d
  4146dc:	48 89 f7             	mov    rdi,rsi
  4146df:	48 89 34 c2          	mov    QWORD PTR [rdx+rax*8],rsi
	h->u(new, c);
  4146e3:	44 89 f6             	mov    esi,r14d
  4146e6:	ff 53 10             	call   QWORD PTR [rbx+0x10]
	h->e++;
  4146e9:	8b 03                	mov    eax,DWORD PTR [rbx]
  4146eb:	83 c0 01             	add    eax,0x1
  4146ee:	89 03                	mov    DWORD PTR [rbx],eax
	assert(c <= h->e);
  4146f0:	41 39 c6             	cmp    r14d,eax
  4146f3:	0f 8f 85 01 00 00    	jg     41487e <heap_add+0x1ce>
	assert(c > 0);
  4146f9:	45 85 f6             	test   r14d,r14d
  4146fc:	0f 8e 98 01 00 00    	jle    41489a <heap_add+0x1ea>
	while (c > 1) {
  414702:	41 83 fe 01          	cmp    r14d,0x1
  414706:	75 43                	jne    41474b <heap_add+0x9b>
  414708:	e9 55 01 00 00       	jmp    414862 <heap_add+0x1b2>
  41470d:	0f 1f 00             	nop    DWORD PTR [rax]
	arr[a] = arr[b];
  414710:	4c 03 63 18          	add    r12,QWORD PTR [rbx+0x18]
	t      = arr[a];
  414714:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
	u(arr[a], a);
  414718:	44 89 f6             	mov    esi,r14d
	t      = arr[a];
  41471b:	48 03 43 18          	add    rax,QWORD PTR [rbx+0x18]
	arr[a] = arr[b];
  41471f:	49 8b 0c 24          	mov    rcx,QWORD PTR [r12]
	t      = arr[a];
  414723:	48 8b 10             	mov    rdx,QWORD PTR [rax]
		swap_entries(h->data, p, c, h->u);
  414726:	4c 8b 7b 10          	mov    r15,QWORD PTR [rbx+0x10]
	arr[a] = arr[b];
  41472a:	48 89 08             	mov    QWORD PTR [rax],rcx
	arr[b] = t;
  41472d:	49 89 14 24          	mov    QWORD PTR [r12],rdx
	u(arr[a], a);
  414731:	48 8b 38             	mov    rdi,QWORD PTR [rax]
  414734:	41 ff d7             	call   r15
	u(arr[b], b);
  414737:	49 8b 3c 24          	mov    rdi,QWORD PTR [r12]
  41473b:	44 89 ee             	mov    esi,r13d
  41473e:	41 ff d7             	call   r15
	while (c > 1) {
  414741:	41 83 fe 01          	cmp    r14d,0x1
  414745:	0f 84 15 01 00 00    	je     414860 <heap_add+0x1b0>
		p = c / 2;
  41474b:	49 63 ce             	movsxd rcx,r14d
		if (h->c(h->data[p], h->data[c])) break; /* done? */
  41474e:	48 8b 43 18          	mov    rax,QWORD PTR [rbx+0x18]
		p = c / 2;
  414752:	41 89 ce             	mov    r14d,ecx
  414755:	49 89 cd             	mov    r13,rcx
		if (h->c(h->data[p], h->data[c])) break; /* done? */
  414758:	4c 8d 24 cd 00 00 00 	lea    r12,[rcx*8+0x0]
  41475f:	00 
		p = c / 2;
  414760:	41 d1 fe             	sar    r14d,1
		if (h->c(h->data[p], h->data[c])) break; /* done? */
  414763:	48 8b 34 c8          	mov    rsi,QWORD PTR [rax+rcx*8]
  414767:	49 63 d6             	movsxd rdx,r14d
  41476a:	48 8d 3c d5 00 00 00 	lea    rdi,[rdx*8+0x0]
  414771:	00 
  414772:	48 89 7d c8          	mov    QWORD PTR [rbp-0x38],rdi
  414776:	48 8b 3c d0          	mov    rdi,QWORD PTR [rax+rdx*8]
  41477a:	ff 53 08             	call   QWORD PTR [rbx+0x8]
  41477d:	85 c0                	test   eax,eax
  41477f:	74 8f                	je     414710 <heap_add+0x60>
	assert(c <= h->e);
  414781:	8b 03                	mov    eax,DWORD PTR [rbx]
  414783:	41 39 c5             	cmp    r13d,eax
  414786:	0f 8f 2a 01 00 00    	jg     4148b6 <heap_add+0x206>
	l = h->e - 1;
  41478c:	83 e8 01             	sub    eax,0x1
  41478f:	89 45 c4             	mov    DWORD PTR [rbp-0x3c],eax
	while (c <= l / 2) { /* not a leaf? */
  414792:	d1 f8                	sar    eax,1
  414794:	89 45 c0             	mov    DWORD PTR [rbp-0x40],eax
  414797:	41 39 c5             	cmp    r13d,eax
  41479a:	7e 75                	jle    414811 <heap_add+0x161>
  41479c:	e9 cc 00 00 00       	jmp    41486d <heap_add+0x1bd>
  4147a1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		if (h->c(h->data[c], h->data[n])) break; /* done? */
  4147a8:	48 8b 43 18          	mov    rax,QWORD PTR [rbx+0x18]
  4147ac:	49 63 f7             	movsxd rsi,r15d
  4147af:	49 63 cd             	movsxd rcx,r13d
  4147b2:	4c 8d 24 f5 00 00 00 	lea    r12,[rsi*8+0x0]
  4147b9:	00 
  4147ba:	4c 8d 34 cd 00 00 00 	lea    r14,[rcx*8+0x0]
  4147c1:	00 
  4147c2:	48 8b 34 f0          	mov    rsi,QWORD PTR [rax+rsi*8]
  4147c6:	48 8b 3c c8          	mov    rdi,QWORD PTR [rax+rcx*8]
  4147ca:	ff 53 08             	call   QWORD PTR [rbx+0x8]
  4147cd:	85 c0                	test   eax,eax
  4147cf:	0f 85 98 00 00 00    	jne    41486d <heap_add+0x1bd>
	t      = arr[a];
  4147d5:	4c 03 63 18          	add    r12,QWORD PTR [rbx+0x18]
	arr[a] = arr[b];
  4147d9:	4c 03 73 18          	add    r14,QWORD PTR [rbx+0x18]
		swap_entries(h->data, n, c, h->u);
  4147dd:	48 8b 43 10          	mov    rax,QWORD PTR [rbx+0x10]
	arr[a] = arr[b];
  4147e1:	49 8b 36             	mov    rsi,QWORD PTR [r14]
	t      = arr[a];
  4147e4:	49 8b 0c 24          	mov    rcx,QWORD PTR [r12]
	u(arr[a], a);
  4147e8:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
	arr[a] = arr[b];
  4147ec:	49 89 34 24          	mov    QWORD PTR [r12],rsi
	u(arr[a], a);
  4147f0:	44 89 fe             	mov    esi,r15d
	arr[b] = t;
  4147f3:	49 89 0e             	mov    QWORD PTR [r14],rcx
	u(arr[a], a);
  4147f6:	49 8b 3c 24          	mov    rdi,QWORD PTR [r12]
  4147fa:	ff d0                	call   rax
	u(arr[b], b);
  4147fc:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  4147ff:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  414803:	44 89 ee             	mov    esi,r13d
  414806:	ff d0                	call   rax
	while (c <= l / 2) { /* not a leaf? */
  414808:	44 3b 7d c0          	cmp    r15d,DWORD PTR [rbp-0x40]
  41480c:	7f 5f                	jg     41486d <heap_add+0x1bd>
  41480e:	45 89 fd             	mov    r13d,r15d
		left  = 2 * c;
  414811:	47 8d 7c 2d 00       	lea    r15d,[r13+r13*1+0x0]
		right = 2 * c + 1;
  414816:	45 8d 67 01          	lea    r12d,[r15+0x1]
		if (right > l) {
  41481a:	44 39 65 c4          	cmp    DWORD PTR [rbp-0x3c],r12d
  41481e:	7c 1b                	jl     41483b <heap_add+0x18b>
		} else if (h->c(h->data[left], h->data[right])) {
  414820:	48 8b 43 18          	mov    rax,QWORD PTR [rbx+0x18]
  414824:	49 63 cc             	movsxd rcx,r12d
  414827:	48 8b 34 c8          	mov    rsi,QWORD PTR [rax+rcx*8]
  41482b:	49 63 cf             	movsxd rcx,r15d
  41482e:	48 8b 3c c8          	mov    rdi,QWORD PTR [rax+rcx*8]
  414832:	ff 53 08             	call   QWORD PTR [rbx+0x8]
  414835:	85 c0                	test   eax,eax
  414837:	45 0f 44 fc          	cmove  r15d,r12d
		assert(n < h->e);
  41483b:	44 39 3b             	cmp    DWORD PTR [rbx],r15d
  41483e:	0f 8f 64 ff ff ff    	jg     4147a8 <heap_add+0xf8>
  414844:	be 23 00 00 00       	mov    esi,0x23
  414849:	bf 00 f1 41 00       	mov    edi,0x41f100
  41484e:	e8 7d 58 ff ff       	call   40a0d0 <cos_print_str>
  414853:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41485a:	00 00 00 00 
  41485e:	0f 0b                	ud2    
	assert(c <= h->e);
  414860:	8b 03                	mov    eax,DWORD PTR [rbx]
  414862:	41 bd 01 00 00 00    	mov    r13d,0x1
  414868:	e9 16 ff ff ff       	jmp    414783 <heap_add+0xd3>
	heapify(h, c);
	assert(!heap_verify(h));

	return 0;
  41486d:	31 c0                	xor    eax,eax
}
  41486f:	48 83 c4 18          	add    rsp,0x18
  414873:	5b                   	pop    rbx
  414874:	41 5c                	pop    r12
  414876:	41 5d                	pop    r13
  414878:	41 5e                	pop    r14
  41487a:	41 5f                	pop    r15
  41487c:	5d                   	pop    rbp
  41487d:	c3                   	ret    
  41487e:	be 23 00 00 00       	mov    esi,0x23
  414883:	bf 88 f0 41 00       	mov    edi,0x41f088
  414888:	e8 43 58 ff ff       	call   40a0d0 <cos_print_str>
	assert(c <= h->e);
  41488d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414894:	00 00 00 00 
  414898:	0f 0b                	ud2    
  41489a:	be 23 00 00 00       	mov    esi,0x23
  41489f:	bf b0 f0 41 00       	mov    edi,0x41f0b0
  4148a4:	e8 27 58 ff ff       	call   40a0d0 <cos_print_str>
	assert(c > 0);
  4148a9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4148b0:	00 00 00 00 
  4148b4:	0f 0b                	ud2    
  4148b6:	be 23 00 00 00       	mov    esi,0x23
  4148bb:	bf d8 f0 41 00       	mov    edi,0x41f0d8
  4148c0:	e8 0b 58 ff ff       	call   40a0d0 <cos_print_str>
	assert(c <= h->e);
  4148c5:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4148cc:	00 00 00 00 
  4148d0:	0f 0b                	ud2    
	if (h->max_sz == h->e) return -1;
  4148d2:	b8 ff ff ff ff       	mov    eax,0xffffffff
  4148d7:	eb 96                	jmp    41486f <heap_add+0x1bf>
  4148d9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

00000000004148e0 <heap_highest>:

void *
heap_highest(struct heap *h)
{
  4148e0:	f3 0f 1e fa          	endbr64 
  4148e4:	55                   	push   rbp
  4148e5:	48 89 e5             	mov    rbp,rsp
  4148e8:	41 57                	push   r15
  4148ea:	41 56                	push   r14
  4148ec:	41 55                	push   r13
  4148ee:	41 54                	push   r12
  4148f0:	53                   	push   rbx
  4148f1:	48 83 ec 28          	sub    rsp,0x28
	void *r;

	if (h->e == 1) return NULL;
  4148f5:	8b 07                	mov    eax,DWORD PTR [rdi]
  4148f7:	83 f8 01             	cmp    eax,0x1
  4148fa:	0f 84 2d 01 00 00    	je     414a2d <heap_highest+0x14d>

	assert(!heap_verify(h));
	r = h->data[1];
  414900:	48 8b 57 18          	mov    rdx,QWORD PTR [rdi+0x18]
	debug("heap_highest(%p,%d) %p\n", h, h->e, r);

	h->e--;
  414904:	83 e8 01             	sub    eax,0x1
  414907:	49 89 ff             	mov    r15,rdi
	h->data[1] = h->data[h->e];
	h->u(h->data[1], 1);
  41490a:	be 01 00 00 00       	mov    esi,0x1
	r = h->data[1];
  41490f:	48 8b 4a 08          	mov    rcx,QWORD PTR [rdx+0x8]
	h->e--;
  414913:	89 07                	mov    DWORD PTR [rdi],eax
	h->data[1] = h->data[h->e];
  414915:	48 98                	cdqe   
  414917:	48 8b 04 c2          	mov    rax,QWORD PTR [rdx+rax*8]
	r = h->data[1];
  41491b:	48 89 4d b8          	mov    QWORD PTR [rbp-0x48],rcx
	h->data[1] = h->data[h->e];
  41491f:	48 89 42 08          	mov    QWORD PTR [rdx+0x8],rax
	h->u(h->data[1], 1);
  414923:	48 8b 47 18          	mov    rax,QWORD PTR [rdi+0x18]
  414927:	48 8b 78 08          	mov    rdi,QWORD PTR [rax+0x8]
  41492b:	41 ff 57 10          	call   QWORD PTR [r15+0x10]
	assert(c <= h->e);
  41492f:	45 8b 2f             	mov    r13d,DWORD PTR [r15]
  414932:	45 85 ed             	test   r13d,r13d
  414935:	0f 8e fc 00 00 00    	jle    414a37 <heap_highest+0x157>
	l = h->e - 1;
  41493b:	41 8d 45 ff          	lea    eax,[r13-0x1]
  41493f:	89 45 c4             	mov    DWORD PTR [rbp-0x3c],eax
	while (c <= l / 2) { /* not a leaf? */
  414942:	d1 f8                	sar    eax,1
  414944:	89 45 c0             	mov    DWORD PTR [rbp-0x40],eax
  414947:	0f 84 c3 00 00 00    	je     414a10 <heap_highest+0x130>
  41494d:	41 bc 01 00 00 00    	mov    r12d,0x1
  414953:	eb 6d                	jmp    4149c2 <heap_highest+0xe2>
  414955:	0f 1f 00             	nop    DWORD PTR [rax]
		if (h->c(h->data[c], h->data[n])) break; /* done? */
  414958:	49 8b 47 18          	mov    rax,QWORD PTR [r15+0x18]
  41495c:	49 63 fd             	movsxd rdi,r13d
  41495f:	49 63 f4             	movsxd rsi,r12d
  414962:	48 8d 1c fd 00 00 00 	lea    rbx,[rdi*8+0x0]
  414969:	00 
  41496a:	4c 8d 34 f5 00 00 00 	lea    r14,[rsi*8+0x0]
  414971:	00 
  414972:	4c 8b 04 f8          	mov    r8,QWORD PTR [rax+rdi*8]
  414976:	48 8b 3c f0          	mov    rdi,QWORD PTR [rax+rsi*8]
  41497a:	4c 89 c6             	mov    rsi,r8
  41497d:	41 ff 57 08          	call   QWORD PTR [r15+0x8]
  414981:	85 c0                	test   eax,eax
  414983:	0f 85 87 00 00 00    	jne    414a10 <heap_highest+0x130>
	t      = arr[a];
  414989:	49 03 5f 18          	add    rbx,QWORD PTR [r15+0x18]
	arr[a] = arr[b];
  41498d:	4d 03 77 18          	add    r14,QWORD PTR [r15+0x18]
		swap_entries(h->data, n, c, h->u);
  414991:	49 8b 47 10          	mov    rax,QWORD PTR [r15+0x10]
	t      = arr[a];
  414995:	48 8b 33             	mov    rsi,QWORD PTR [rbx]
	arr[a] = arr[b];
  414998:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
	u(arr[a], a);
  41499b:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
	arr[a] = arr[b];
  41499f:	48 89 3b             	mov    QWORD PTR [rbx],rdi
	arr[b] = t;
  4149a2:	49 89 36             	mov    QWORD PTR [r14],rsi
	u(arr[a], a);
  4149a5:	44 89 ee             	mov    esi,r13d
  4149a8:	48 8b 3b             	mov    rdi,QWORD PTR [rbx]
  4149ab:	ff d0                	call   rax
	u(arr[b], b);
  4149ad:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  4149b0:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  4149b4:	44 89 e6             	mov    esi,r12d
  4149b7:	ff d0                	call   rax
	while (c <= l / 2) { /* not a leaf? */
  4149b9:	44 3b 6d c0          	cmp    r13d,DWORD PTR [rbp-0x40]
  4149bd:	7f 51                	jg     414a10 <heap_highest+0x130>
  4149bf:	45 89 ec             	mov    r12d,r13d
		left  = 2 * c;
  4149c2:	47 8d 2c 24          	lea    r13d,[r12+r12*1]
		right = 2 * c + 1;
  4149c6:	41 8d 5d 01          	lea    ebx,[r13+0x1]
		if (right > l) {
  4149ca:	39 5d c4             	cmp    DWORD PTR [rbp-0x3c],ebx
  4149cd:	7c 1c                	jl     4149eb <heap_highest+0x10b>
		} else if (h->c(h->data[left], h->data[right])) {
  4149cf:	49 8b 47 18          	mov    rax,QWORD PTR [r15+0x18]
  4149d3:	49 63 fd             	movsxd rdi,r13d
  4149d6:	48 63 f3             	movsxd rsi,ebx
  4149d9:	48 8b 34 f0          	mov    rsi,QWORD PTR [rax+rsi*8]
  4149dd:	48 8b 3c f8          	mov    rdi,QWORD PTR [rax+rdi*8]
  4149e1:	41 ff 57 08          	call   QWORD PTR [r15+0x8]
  4149e5:	85 c0                	test   eax,eax
  4149e7:	44 0f 44 eb          	cmove  r13d,ebx
		assert(n < h->e);
  4149eb:	45 39 2f             	cmp    DWORD PTR [r15],r13d
  4149ee:	0f 8f 64 ff ff ff    	jg     414958 <heap_highest+0x78>
  4149f4:	be 23 00 00 00       	mov    esi,0x23
  4149f9:	bf 00 f1 41 00       	mov    edi,0x41f100
  4149fe:	e8 cd 56 ff ff       	call   40a0d0 <cos_print_str>
  414a03:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414a0a:	00 00 00 00 
  414a0e:	0f 0b                	ud2    
	swap_down(h, 1);
	assert(!heap_verify(h));
	h->u(r, 0);
  414a10:	48 8b 7d b8          	mov    rdi,QWORD PTR [rbp-0x48]
  414a14:	31 f6                	xor    esi,esi
  414a16:	41 ff 57 10          	call   QWORD PTR [r15+0x10]

	return r;
}
  414a1a:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  414a1e:	48 83 c4 28          	add    rsp,0x28
  414a22:	5b                   	pop    rbx
  414a23:	41 5c                	pop    r12
  414a25:	41 5d                	pop    r13
  414a27:	41 5e                	pop    r14
  414a29:	41 5f                	pop    r15
  414a2b:	5d                   	pop    rbp
  414a2c:	c3                   	ret    
	if (h->e == 1) return NULL;
  414a2d:	48 c7 45 b8 00 00 00 	mov    QWORD PTR [rbp-0x48],0x0
  414a34:	00 
  414a35:	eb e3                	jmp    414a1a <heap_highest+0x13a>
  414a37:	be 23 00 00 00       	mov    esi,0x23
  414a3c:	bf d8 f0 41 00       	mov    edi,0x41f0d8
  414a41:	e8 8a 56 ff ff       	call   40a0d0 <cos_print_str>
	assert(c <= h->e);
  414a46:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414a4d:	00 00 00 00 
  414a51:	0f 0b                	ud2    
  414a53:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  414a5a:	00 00 00 00 
  414a5e:	66 90                	xchg   ax,ax

0000000000414a60 <heap_peek>:

void *
heap_peek(struct heap *h)
{
  414a60:	f3 0f 1e fa          	endbr64 
	if (h->e == 1) return NULL;
  414a64:	83 3f 01             	cmp    DWORD PTR [rdi],0x1
  414a67:	74 0f                	je     414a78 <heap_peek+0x18>
	assert(!heap_verify(h));
	return h->data[1];
  414a69:	48 8b 47 18          	mov    rax,QWORD PTR [rdi+0x18]
  414a6d:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  414a71:	c3                   	ret    
  414a72:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	if (h->e == 1) return NULL;
  414a78:	31 c0                	xor    eax,eax
}
  414a7a:	c3                   	ret    
  414a7b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000414a80 <heap_adjust>:

void
heap_adjust(struct heap *h, int c)
{
  414a80:	f3 0f 1e fa          	endbr64 
  414a84:	55                   	push   rbp
  414a85:	48 89 e5             	mov    rbp,rsp
  414a88:	41 57                	push   r15
  414a8a:	41 56                	push   r14
  414a8c:	41 55                	push   r13
  414a8e:	41 54                	push   r12
  414a90:	53                   	push   rbx
  414a91:	48 83 ec 18          	sub    rsp,0x18
	assert(c < h->e);
  414a95:	8b 07                	mov    eax,DWORD PTR [rdi]
  414a97:	39 f0                	cmp    eax,esi
  414a99:	0f 8e 8d 01 00 00    	jle    414c2c <heap_adjust+0x1ac>
  414a9f:	41 89 f6             	mov    r14d,esi
	assert(c > 0);
  414aa2:	85 f6                	test   esi,esi
  414aa4:	0f 8e 9e 01 00 00    	jle    414c48 <heap_adjust+0x1c8>
  414aaa:	48 89 fb             	mov    rbx,rdi
	while (c > 1) {
  414aad:	83 fe 01             	cmp    esi,0x1
  414ab0:	75 49                	jne    414afb <heap_adjust+0x7b>
  414ab2:	e9 5b 01 00 00       	jmp    414c12 <heap_adjust+0x192>
  414ab7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  414abe:	00 00 
	arr[a] = arr[b];
  414ac0:	4c 03 63 18          	add    r12,QWORD PTR [rbx+0x18]
	t      = arr[a];
  414ac4:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
	u(arr[a], a);
  414ac8:	44 89 f6             	mov    esi,r14d
	t      = arr[a];
  414acb:	48 03 43 18          	add    rax,QWORD PTR [rbx+0x18]
	arr[a] = arr[b];
  414acf:	49 8b 0c 24          	mov    rcx,QWORD PTR [r12]
	t      = arr[a];
  414ad3:	48 8b 10             	mov    rdx,QWORD PTR [rax]
		swap_entries(h->data, p, c, h->u);
  414ad6:	4c 8b 7b 10          	mov    r15,QWORD PTR [rbx+0x10]
	arr[a] = arr[b];
  414ada:	48 89 08             	mov    QWORD PTR [rax],rcx
	arr[b] = t;
  414add:	49 89 14 24          	mov    QWORD PTR [r12],rdx
	u(arr[a], a);
  414ae1:	48 8b 38             	mov    rdi,QWORD PTR [rax]
  414ae4:	41 ff d7             	call   r15
	u(arr[b], b);
  414ae7:	49 8b 3c 24          	mov    rdi,QWORD PTR [r12]
  414aeb:	44 89 ee             	mov    esi,r13d
  414aee:	41 ff d7             	call   r15
	while (c > 1) {
  414af1:	41 83 fe 01          	cmp    r14d,0x1
  414af5:	0f 84 15 01 00 00    	je     414c10 <heap_adjust+0x190>
		p = c / 2;
  414afb:	49 63 ce             	movsxd rcx,r14d
		if (h->c(h->data[p], h->data[c])) break; /* done? */
  414afe:	48 8b 43 18          	mov    rax,QWORD PTR [rbx+0x18]
		p = c / 2;
  414b02:	41 89 ce             	mov    r14d,ecx
  414b05:	49 89 cd             	mov    r13,rcx
		if (h->c(h->data[p], h->data[c])) break; /* done? */
  414b08:	4c 8d 24 cd 00 00 00 	lea    r12,[rcx*8+0x0]
  414b0f:	00 
		p = c / 2;
  414b10:	41 d1 fe             	sar    r14d,1
		if (h->c(h->data[p], h->data[c])) break; /* done? */
  414b13:	48 8b 34 c8          	mov    rsi,QWORD PTR [rax+rcx*8]
  414b17:	49 63 d6             	movsxd rdx,r14d
  414b1a:	48 8d 3c d5 00 00 00 	lea    rdi,[rdx*8+0x0]
  414b21:	00 
  414b22:	48 89 7d c8          	mov    QWORD PTR [rbp-0x38],rdi
  414b26:	48 8b 3c d0          	mov    rdi,QWORD PTR [rax+rdx*8]
  414b2a:	ff 53 08             	call   QWORD PTR [rbx+0x8]
  414b2d:	85 c0                	test   eax,eax
  414b2f:	74 8f                	je     414ac0 <heap_adjust+0x40>
	assert(c <= h->e);
  414b31:	8b 03                	mov    eax,DWORD PTR [rbx]
  414b33:	44 39 e8             	cmp    eax,r13d
  414b36:	0f 8c 28 01 00 00    	jl     414c64 <heap_adjust+0x1e4>
	l = h->e - 1;
  414b3c:	83 e8 01             	sub    eax,0x1
  414b3f:	89 45 c4             	mov    DWORD PTR [rbp-0x3c],eax
	while (c <= l / 2) { /* not a leaf? */
  414b42:	d1 f8                	sar    eax,1
  414b44:	89 45 c0             	mov    DWORD PTR [rbp-0x40],eax
  414b47:	44 39 e8             	cmp    eax,r13d
  414b4a:	7d 75                	jge    414bc1 <heap_adjust+0x141>
  414b4c:	e9 cc 00 00 00       	jmp    414c1d <heap_adjust+0x19d>
  414b51:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		if (h->c(h->data[c], h->data[n])) break; /* done? */
  414b58:	48 8b 43 18          	mov    rax,QWORD PTR [rbx+0x18]
  414b5c:	49 63 f7             	movsxd rsi,r15d
  414b5f:	49 63 cd             	movsxd rcx,r13d
  414b62:	4c 8d 24 f5 00 00 00 	lea    r12,[rsi*8+0x0]
  414b69:	00 
  414b6a:	4c 8d 34 cd 00 00 00 	lea    r14,[rcx*8+0x0]
  414b71:	00 
  414b72:	48 8b 34 f0          	mov    rsi,QWORD PTR [rax+rsi*8]
  414b76:	48 8b 3c c8          	mov    rdi,QWORD PTR [rax+rcx*8]
  414b7a:	ff 53 08             	call   QWORD PTR [rbx+0x8]
  414b7d:	85 c0                	test   eax,eax
  414b7f:	0f 85 98 00 00 00    	jne    414c1d <heap_adjust+0x19d>
	t      = arr[a];
  414b85:	4c 03 63 18          	add    r12,QWORD PTR [rbx+0x18]
	arr[a] = arr[b];
  414b89:	4c 03 73 18          	add    r14,QWORD PTR [rbx+0x18]
		swap_entries(h->data, n, c, h->u);
  414b8d:	48 8b 43 10          	mov    rax,QWORD PTR [rbx+0x10]
	arr[a] = arr[b];
  414b91:	49 8b 36             	mov    rsi,QWORD PTR [r14]
	t      = arr[a];
  414b94:	49 8b 0c 24          	mov    rcx,QWORD PTR [r12]
	u(arr[a], a);
  414b98:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
	arr[a] = arr[b];
  414b9c:	49 89 34 24          	mov    QWORD PTR [r12],rsi
	u(arr[a], a);
  414ba0:	44 89 fe             	mov    esi,r15d
	arr[b] = t;
  414ba3:	49 89 0e             	mov    QWORD PTR [r14],rcx
	u(arr[a], a);
  414ba6:	49 8b 3c 24          	mov    rdi,QWORD PTR [r12]
  414baa:	ff d0                	call   rax
	u(arr[b], b);
  414bac:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  414baf:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  414bb3:	44 89 ee             	mov    esi,r13d
  414bb6:	ff d0                	call   rax
	while (c <= l / 2) { /* not a leaf? */
  414bb8:	44 39 7d c0          	cmp    DWORD PTR [rbp-0x40],r15d
  414bbc:	7c 5f                	jl     414c1d <heap_adjust+0x19d>
  414bbe:	45 89 fd             	mov    r13d,r15d
		left  = 2 * c;
  414bc1:	47 8d 7c 2d 00       	lea    r15d,[r13+r13*1+0x0]
		right = 2 * c + 1;
  414bc6:	45 8d 67 01          	lea    r12d,[r15+0x1]
		if (right > l) {
  414bca:	44 39 65 c4          	cmp    DWORD PTR [rbp-0x3c],r12d
  414bce:	7c 1b                	jl     414beb <heap_adjust+0x16b>
		} else if (h->c(h->data[left], h->data[right])) {
  414bd0:	48 8b 43 18          	mov    rax,QWORD PTR [rbx+0x18]
  414bd4:	49 63 cc             	movsxd rcx,r12d
  414bd7:	48 8b 34 c8          	mov    rsi,QWORD PTR [rax+rcx*8]
  414bdb:	49 63 cf             	movsxd rcx,r15d
  414bde:	48 8b 3c c8          	mov    rdi,QWORD PTR [rax+rcx*8]
  414be2:	ff 53 08             	call   QWORD PTR [rbx+0x8]
  414be5:	85 c0                	test   eax,eax
  414be7:	45 0f 44 fc          	cmove  r15d,r12d
		assert(n < h->e);
  414beb:	44 39 3b             	cmp    DWORD PTR [rbx],r15d
  414bee:	0f 8f 64 ff ff ff    	jg     414b58 <heap_adjust+0xd8>
  414bf4:	be 23 00 00 00       	mov    esi,0x23
  414bf9:	bf 00 f1 41 00       	mov    edi,0x41f100
  414bfe:	e8 cd 54 ff ff       	call   40a0d0 <cos_print_str>
  414c03:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414c0a:	00 00 00 00 
  414c0e:	0f 0b                	ud2    
	assert(c <= h->e);
  414c10:	8b 03                	mov    eax,DWORD PTR [rbx]
  414c12:	41 bd 01 00 00 00    	mov    r13d,0x1
  414c18:	e9 16 ff ff ff       	jmp    414b33 <heap_adjust+0xb3>

	debug("heap_adjust(%p,%d) %p@%d\n", h, h->e, h->data[c], c);
	heapify(h, c);
	assert(!heap_verify(h));
}
  414c1d:	48 83 c4 18          	add    rsp,0x18
  414c21:	5b                   	pop    rbx
  414c22:	41 5c                	pop    r12
  414c24:	41 5d                	pop    r13
  414c26:	41 5e                	pop    r14
  414c28:	41 5f                	pop    r15
  414c2a:	5d                   	pop    rbp
  414c2b:	c3                   	ret    
  414c2c:	be 24 00 00 00       	mov    esi,0x24
  414c31:	bf 28 f1 41 00       	mov    edi,0x41f128
  414c36:	e8 95 54 ff ff       	call   40a0d0 <cos_print_str>
	assert(c < h->e);
  414c3b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414c42:	00 00 00 00 
  414c46:	0f 0b                	ud2    
  414c48:	be 24 00 00 00       	mov    esi,0x24
  414c4d:	bf 50 f1 41 00       	mov    edi,0x41f150
  414c52:	e8 79 54 ff ff       	call   40a0d0 <cos_print_str>
	assert(c > 0);
  414c57:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414c5e:	00 00 00 00 
  414c62:	0f 0b                	ud2    
  414c64:	be 23 00 00 00       	mov    esi,0x23
  414c69:	bf d8 f0 41 00       	mov    edi,0x41f0d8
  414c6e:	e8 5d 54 ff ff       	call   40a0d0 <cos_print_str>
	assert(c <= h->e);
  414c73:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414c7a:	00 00 00 00 
  414c7e:	0f 0b                	ud2    

0000000000414c80 <heap_remove>:

void *
heap_remove(struct heap *h, int c)
{
  414c80:	f3 0f 1e fa          	endbr64 
  414c84:	55                   	push   rbp
  414c85:	48 89 e5             	mov    rbp,rsp
  414c88:	41 56                	push   r14
  414c8a:	41 55                	push   r13
  414c8c:	41 54                	push   r12
  414c8e:	53                   	push   rbx
	void *r;

	assert(c < h->e);
  414c8f:	8b 07                	mov    eax,DWORD PTR [rdi]
  414c91:	39 f0                	cmp    eax,esi
  414c93:	7e 6f                	jle    414d04 <heap_remove+0x84>
  414c95:	41 89 f5             	mov    r13d,esi
	assert(c >= 1);
  414c98:	85 f6                	test   esi,esi
  414c9a:	0f 8e 80 00 00 00    	jle    414d20 <heap_remove+0xa0>
	if (h->e == 1) return NULL;
  414ca0:	83 f8 01             	cmp    eax,0x1
  414ca3:	0f 84 93 00 00 00    	je     414d3c <heap_remove+0xbc>

	assert(!heap_verify(h));
	r = h->data[c];
  414ca9:	48 8b 57 18          	mov    rdx,QWORD PTR [rdi+0x18]
  414cad:	48 63 de             	movsxd rbx,esi
  414cb0:	49 89 fc             	mov    r12,rdi
	debug("heap_remove(%p,%d) %p@%d\n", h, h->e, h->data[c], c);
	h->e--;
  414cb3:	83 e8 01             	sub    eax,0x1
	h->u(r, 0);
  414cb6:	31 f6                	xor    esi,esi
	r = h->data[c];
  414cb8:	4c 8b 34 da          	mov    r14,QWORD PTR [rdx+rbx*8]
	h->e--;
  414cbc:	89 07                	mov    DWORD PTR [rdi],eax
	h->u(r, 0);
  414cbe:	4c 89 f7             	mov    rdi,r14
  414cc1:	41 ff 54 24 10       	call   QWORD PTR [r12+0x10]

	if (c == h->e) {
  414cc6:	49 63 04 24          	movsxd rax,DWORD PTR [r12]
  414cca:	44 39 e8             	cmp    eax,r13d
  414ccd:	74 29                	je     414cf8 <heap_remove+0x78>
		assert(!heap_verify(h));
		return r;
	}
	h->data[c] = h->data[h->e];
  414ccf:	49 8b 54 24 18       	mov    rdx,QWORD PTR [r12+0x18]
	h->u(h->data[c], c);
  414cd4:	44 89 ee             	mov    esi,r13d
	h->data[c] = h->data[h->e];
  414cd7:	48 8b 04 c2          	mov    rax,QWORD PTR [rdx+rax*8]
  414cdb:	48 89 04 da          	mov    QWORD PTR [rdx+rbx*8],rax
	h->u(h->data[c], c);
  414cdf:	49 8b 44 24 18       	mov    rax,QWORD PTR [r12+0x18]
  414ce4:	48 8b 3c d8          	mov    rdi,QWORD PTR [rax+rbx*8]
  414ce8:	41 ff 54 24 10       	call   QWORD PTR [r12+0x10]
	heap_adjust(h, c);
  414ced:	44 89 ee             	mov    esi,r13d
  414cf0:	4c 89 e7             	mov    rdi,r12
  414cf3:	e8 88 fd ff ff       	call   414a80 <heap_adjust>
	assert(!heap_verify(h));

	return r;
}
  414cf8:	5b                   	pop    rbx
  414cf9:	4c 89 f0             	mov    rax,r14
  414cfc:	41 5c                	pop    r12
  414cfe:	41 5d                	pop    r13
  414d00:	41 5e                	pop    r14
  414d02:	5d                   	pop    rbp
  414d03:	c3                   	ret    
  414d04:	be 24 00 00 00       	mov    esi,0x24
  414d09:	bf 78 f1 41 00       	mov    edi,0x41f178
  414d0e:	e8 bd 53 ff ff       	call   40a0d0 <cos_print_str>
	assert(c < h->e);
  414d13:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414d1a:	00 00 00 00 
  414d1e:	0f 0b                	ud2    
  414d20:	be 24 00 00 00       	mov    esi,0x24
  414d25:	bf a0 f1 41 00       	mov    edi,0x41f1a0
  414d2a:	e8 a1 53 ff ff       	call   40a0d0 <cos_print_str>
	assert(c >= 1);
  414d2f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414d36:	00 00 00 00 
  414d3a:	0f 0b                	ud2    
	if (h->e == 1) return NULL;
  414d3c:	45 31 f6             	xor    r14d,r14d
  414d3f:	eb b7                	jmp    414cf8 <heap_remove+0x78>
  414d41:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  414d48:	00 00 00 00 
  414d4c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000414d50 <heap_size>:

int
heap_size(struct heap *h)
{
  414d50:	f3 0f 1e fa          	endbr64 
	return h->e - 1;
  414d54:	8b 07                	mov    eax,DWORD PTR [rdi]
  414d56:	83 e8 01             	sub    eax,0x1
}
  414d59:	c3                   	ret    

0000000000414d5a <memcpy>:
.global __memcpy_fwd
.hidden __memcpy_fwd
.type memcpy,@function
memcpy:
__memcpy_fwd:
	mov %rdi,%rax
  414d5a:	48 89 f8             	mov    rax,rdi
	cmp $8,%rdx
  414d5d:	48 83 fa 08          	cmp    rdx,0x8
	jc 1f
  414d61:	72 14                	jb     414d77 <memcpy+0x1d>
	test $7,%edi
  414d63:	f7 c7 07 00 00 00    	test   edi,0x7
	jz 1f
  414d69:	74 0c                	je     414d77 <memcpy+0x1d>
2:	movsb
  414d6b:	a4                   	movs   BYTE PTR es:[rdi],BYTE PTR ds:[rsi]
	dec %rdx
  414d6c:	48 ff ca             	dec    rdx
	test $7,%edi
  414d6f:	f7 c7 07 00 00 00    	test   edi,0x7
	jnz 2b
  414d75:	75 f4                	jne    414d6b <memcpy+0x11>
1:	mov %rdx,%rcx
  414d77:	48 89 d1             	mov    rcx,rdx
	shr $3,%rcx
  414d7a:	48 c1 e9 03          	shr    rcx,0x3
	rep
  414d7e:	f3 48 a5             	rep movs QWORD PTR es:[rdi],QWORD PTR ds:[rsi]
	movsq
	and $7,%edx
  414d81:	83 e2 07             	and    edx,0x7
	jz 1f
  414d84:	74 05                	je     414d8b <memcpy+0x31>
2:	movsb
  414d86:	a4                   	movs   BYTE PTR es:[rdi],BYTE PTR ds:[rsi]
	dec %edx
  414d87:	ff ca                	dec    edx
	jnz 2b
  414d89:	75 fb                	jne    414d86 <memcpy+0x2c>
1:	ret
  414d8b:	c3                   	ret    

0000000000414d8c <memset>:
.global memset
.type memset,@function
memset:
	movzbq %sil,%rax
  414d8c:	48 0f b6 c6          	movzx  rax,sil
	mov $0x101010101010101,%r8
  414d90:	49 b8 01 01 01 01 01 	movabs r8,0x101010101010101
  414d97:	01 01 01 
	imul %r8,%rax
  414d9a:	49 0f af c0          	imul   rax,r8

	cmp $126,%rdx
  414d9e:	48 83 fa 7e          	cmp    rdx,0x7e
	ja 2f
  414da2:	77 78                	ja     414e1c <memset+0x90>

	test %edx,%edx
  414da4:	85 d2                	test   edx,edx
	jz 1f
  414da6:	74 70                	je     414e18 <memset+0x8c>

	mov %sil,(%rdi)
  414da8:	40 88 37             	mov    BYTE PTR [rdi],sil
	mov %sil,-1(%rdi,%rdx)
  414dab:	40 88 74 17 ff       	mov    BYTE PTR [rdi+rdx*1-0x1],sil
	cmp $2,%edx
  414db0:	83 fa 02             	cmp    edx,0x2
	jbe 1f
  414db3:	76 63                	jbe    414e18 <memset+0x8c>

	mov %ax,1(%rdi)
  414db5:	66 89 47 01          	mov    WORD PTR [rdi+0x1],ax
	mov %ax,(-1-2)(%rdi,%rdx)
  414db9:	66 89 44 17 fd       	mov    WORD PTR [rdi+rdx*1-0x3],ax
	cmp $6,%edx
  414dbe:	83 fa 06             	cmp    edx,0x6
	jbe 1f
  414dc1:	76 55                	jbe    414e18 <memset+0x8c>

	mov %eax,(1+2)(%rdi)
  414dc3:	89 47 03             	mov    DWORD PTR [rdi+0x3],eax
	mov %eax,(-1-2-4)(%rdi,%rdx)
  414dc6:	89 44 17 f9          	mov    DWORD PTR [rdi+rdx*1-0x7],eax
	cmp $14,%edx
  414dca:	83 fa 0e             	cmp    edx,0xe
	jbe 1f
  414dcd:	76 49                	jbe    414e18 <memset+0x8c>

	mov %rax,(1+2+4)(%rdi)
  414dcf:	48 89 47 07          	mov    QWORD PTR [rdi+0x7],rax
	mov %rax,(-1-2-4-8)(%rdi,%rdx)
  414dd3:	48 89 44 17 f1       	mov    QWORD PTR [rdi+rdx*1-0xf],rax
	cmp $30,%edx
  414dd8:	83 fa 1e             	cmp    edx,0x1e
	jbe 1f
  414ddb:	76 3b                	jbe    414e18 <memset+0x8c>

	mov %rax,(1+2+4+8)(%rdi)
  414ddd:	48 89 47 0f          	mov    QWORD PTR [rdi+0xf],rax
	mov %rax,(1+2+4+8+8)(%rdi)
  414de1:	48 89 47 17          	mov    QWORD PTR [rdi+0x17],rax
	mov %rax,(-1-2-4-8-16)(%rdi,%rdx)
  414de5:	48 89 44 17 e1       	mov    QWORD PTR [rdi+rdx*1-0x1f],rax
	mov %rax,(-1-2-4-8-8)(%rdi,%rdx)
  414dea:	48 89 44 17 e9       	mov    QWORD PTR [rdi+rdx*1-0x17],rax
	cmp $62,%edx
  414def:	83 fa 3e             	cmp    edx,0x3e
	jbe 1f
  414df2:	76 24                	jbe    414e18 <memset+0x8c>

	mov %rax,(1+2+4+8+16)(%rdi)
  414df4:	48 89 47 1f          	mov    QWORD PTR [rdi+0x1f],rax
	mov %rax,(1+2+4+8+16+8)(%rdi)
  414df8:	48 89 47 27          	mov    QWORD PTR [rdi+0x27],rax
	mov %rax,(1+2+4+8+16+16)(%rdi)
  414dfc:	48 89 47 2f          	mov    QWORD PTR [rdi+0x2f],rax
	mov %rax,(1+2+4+8+16+24)(%rdi)
  414e00:	48 89 47 37          	mov    QWORD PTR [rdi+0x37],rax
	mov %rax,(-1-2-4-8-16-32)(%rdi,%rdx)
  414e04:	48 89 44 17 c1       	mov    QWORD PTR [rdi+rdx*1-0x3f],rax
	mov %rax,(-1-2-4-8-16-24)(%rdi,%rdx)
  414e09:	48 89 44 17 c9       	mov    QWORD PTR [rdi+rdx*1-0x37],rax
	mov %rax,(-1-2-4-8-16-16)(%rdi,%rdx)
  414e0e:	48 89 44 17 d1       	mov    QWORD PTR [rdi+rdx*1-0x2f],rax
	mov %rax,(-1-2-4-8-16-8)(%rdi,%rdx)
  414e13:	48 89 44 17 d9       	mov    QWORD PTR [rdi+rdx*1-0x27],rax

1:	mov %rdi,%rax
  414e18:	48 89 f8             	mov    rax,rdi
	ret
  414e1b:	c3                   	ret    

2:	test $15,%edi
  414e1c:	f7 c7 0f 00 00 00    	test   edi,0xf
	mov %rdi,%r8
  414e22:	49 89 f8             	mov    r8,rdi
	mov %rax,-8(%rdi,%rdx)
  414e25:	48 89 44 17 f8       	mov    QWORD PTR [rdi+rdx*1-0x8],rax
	mov %rdx,%rcx
  414e2a:	48 89 d1             	mov    rcx,rdx
	jnz 2f
  414e2d:	75 0b                	jne    414e3a <memset+0xae>

1:	shr $3,%rcx
  414e2f:	48 c1 e9 03          	shr    rcx,0x3
	rep
  414e33:	f3 48 ab             	rep stos QWORD PTR es:[rdi],rax
	stosq
	mov %r8,%rax
  414e36:	4c 89 c0             	mov    rax,r8
	ret
  414e39:	c3                   	ret    

2:	xor %edx,%edx
  414e3a:	31 d2                	xor    edx,edx
	sub %edi,%edx
  414e3c:	29 fa                	sub    edx,edi
	and $15,%edx
  414e3e:	83 e2 0f             	and    edx,0xf
	mov %rax,(%rdi)
  414e41:	48 89 07             	mov    QWORD PTR [rdi],rax
	mov %rax,8(%rdi)
  414e44:	48 89 47 08          	mov    QWORD PTR [rdi+0x8],rax
	sub %rdx,%rcx
  414e48:	48 29 d1             	sub    rcx,rdx
	add %rdx,%rdi
  414e4b:	48 01 d7             	add    rdi,rdx
	jmp 1b
  414e4e:	eb df                	jmp    414e2f <memset+0xa3>

0000000000414e50 <__set_thread_area>:
.text
.global __set_thread_area
.hidden __set_thread_area
.type __set_thread_area,@function
__set_thread_area:
	mov %rdi,%rsi           /* shift for syscall */
  414e50:	48 89 fe             	mov    rsi,rdi
	movl $0x1002,%edi       /* SET_FS register */
  414e53:	bf 02 10 00 00       	mov    edi,0x1002
	movl $158,%eax          /* set fs segment to */
  414e58:	b8 9e 00 00 00       	mov    eax,0x9e
	syscall                 /* arch_prctl(SET_FS, arg)*/
  414e5d:	0f 05                	syscall 
	ret
  414e5f:	c3                   	ret    

0000000000414e60 <sched_set_tls.cold>:
	thdcap_t thdcap = current->thd;
  414e60:	48 8b 04 25 10 00 00 	mov    rax,QWORD PTR ds:0x10
  414e67:	00 
  414e68:	0f 0b                	ud2    

0000000000414e6a <sched_debug_thd_state.cold>:
	return t->state;
  414e6a:	8b 04 25 04 00 00 00 	mov    eax,DWORD PTR ds:0x4
  414e71:	0f 0b                	ud2    
  414e73:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  414e7a:	00 00 00 
  414e7d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000414e80 <_init>:
#include <unistd.h>
#include "syscall.h"
#include "atomic.h"
#include "libc.h"

static void dummy(void) {}
  414e80:	f3 0f 1e fa          	endbr64 
  414e84:	c3                   	ret    
  414e85:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  414e8c:	00 00 00 
  414e8f:	90                   	nop

0000000000414e90 <__funcs_on_exit>:
#include <stdlib.h>
#include <stdint.h>
#include "libc.h"

static void dummy()
{
  414e90:	f3 0f 1e fa          	endbr64 
}
  414e94:	c3                   	ret    
  414e95:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  414e9c:	00 00 00 
  414e9f:	90                   	nop

0000000000414ea0 <__lctrans_impl>:
#include <locale.h>
#include "locale_impl.h"

static const char *dummy(const char *msg, const struct __locale_map *lm)
{
  414ea0:	f3 0f 1e fa          	endbr64 
  414ea4:	48 89 f8             	mov    rax,rdi
	return msg;
}
  414ea7:	c3                   	ret    
  414ea8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  414eaf:	00 

0000000000414eb0 <__init_ssp>:
weak_alias(dummy, _init);

extern weak hidden void (*const __init_array_start)(void), (*const __init_array_end)(void);

static void dummy1(void *p) {}
  414eb0:	f3 0f 1e fa          	endbr64 
  414eb4:	c3                   	ret    
  414eb5:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  414ebc:	00 00 00 
  414ebf:	90                   	nop

0000000000414ec0 <__init_libc>:

#ifdef __GNUC__
__attribute__((__noinline__))
#endif
void __init_libc(char **envp, char *pn)
{
  414ec0:	f3 0f 1e fa          	endbr64 
  414ec4:	41 57                	push   r15
  414ec6:	48 89 fa             	mov    rdx,rdi
	size_t i, *auxv, aux[AUX_CNT] = { 0 };
  414ec9:	31 c0                	xor    eax,eax
  414ecb:	4c 8d 3d f2 ff ff ff 	lea    r15,[rip+0xfffffffffffffff2]        # 414ec4 <__init_libc+0x4>
{
  414ed2:	55                   	push   rbp
	size_t i, *auxv, aux[AUX_CNT] = { 0 };
  414ed3:	b9 26 00 00 00       	mov    ecx,0x26
  414ed8:	49 bb 4c 85 04 00 00 	movabs r11,0x4854c
  414edf:	00 00 00 
{
  414ee2:	53                   	push   rbx
  414ee3:	4d 01 df             	add    r15,r11
  414ee6:	48 81 ec 50 01 00 00 	sub    rsp,0x150
	__environ = envp;
	for (i=0; envp[i]; i++);
  414eed:	48 83 3a 00          	cmp    QWORD PTR [rdx],0x0
	size_t i, *auxv, aux[AUX_CNT] = { 0 };
  414ef1:	4c 8d 44 24 20       	lea    r8,[rsp+0x20]
  414ef6:	4c 89 c7             	mov    rdi,r8
  414ef9:	f3 48 ab             	rep stos QWORD PTR es:[rdi],rax
	__environ = envp;
  414efc:	48 b8 d0 ff ff ff ff 	movabs rax,0xffffffffffffffd0
  414f03:	ff ff ff 
  414f06:	49 8b 04 07          	mov    rax,QWORD PTR [r15+rax*1]
  414f0a:	48 89 10             	mov    QWORD PTR [rax],rdx
	for (i=0; envp[i]; i++);
  414f0d:	0f 84 1d 03 00 00    	je     415230 <__init_libc+0x370>
  414f13:	31 c0                	xor    eax,eax
  414f15:	0f 1f 00             	nop    DWORD PTR [rax]
  414f18:	48 89 c1             	mov    rcx,rax
  414f1b:	48 83 c0 01          	add    rax,0x1
  414f1f:	48 83 3c c2 00       	cmp    QWORD PTR [rdx+rax*8],0x0
  414f24:	75 f2                	jne    414f18 <__init_libc+0x58>
	libc.auxv = auxv = (void *)(envp+i+1);
  414f26:	48 8d 04 cd 10 00 00 	lea    rax,[rcx*8+0x10]
  414f2d:	00 
  414f2e:	48 bb 30 4c 14 00 00 	movabs rbx,0x144c30
  414f35:	00 00 00 
  414f38:	48 01 d0             	add    rax,rdx
	for (i=0; auxv[i]; i+=2) if (auxv[i]<AUX_CNT) aux[auxv[i]] = auxv[i+1];
  414f3b:	48 8b 10             	mov    rdx,QWORD PTR [rax]
	libc.auxv = auxv = (void *)(envp+i+1);
  414f3e:	4a 89 44 3b 10       	mov    QWORD PTR [rbx+r15*1+0x10],rax
	for (i=0; auxv[i]; i+=2) if (auxv[i]<AUX_CNT) aux[auxv[i]] = auxv[i+1];
  414f43:	48 83 c0 08          	add    rax,0x8
  414f47:	48 85 d2             	test   rdx,rdx
  414f4a:	0f 84 f0 02 00 00    	je     415240 <__init_libc+0x380>
  414f50:	48 83 fa 25          	cmp    rdx,0x25
  414f54:	0f 87 76 01 00 00    	ja     4150d0 <__init_libc+0x210>
  414f5a:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  414f5d:	48 83 c0 10          	add    rax,0x10
  414f61:	48 89 4c d4 20       	mov    QWORD PTR [rsp+rdx*8+0x20],rcx
  414f66:	48 8b 50 f8          	mov    rdx,QWORD PTR [rax-0x8]
  414f6a:	48 85 d2             	test   rdx,rdx
  414f6d:	75 e1                	jne    414f50 <__init_libc+0x90>
	__hwcap = aux[AT_HWCAP];
  414f6f:	48 8b bc 24 a0 00 00 	mov    rdi,QWORD PTR [rsp+0xa0]
  414f76:	00 
	if (aux[AT_SYSINFO]) __sysinfo = aux[AT_SYSINFO];
  414f77:	48 8b 84 24 20 01 00 	mov    rax,QWORD PTR [rsp+0x120]
  414f7e:	00 
	__hwcap = aux[AT_HWCAP];
  414f7f:	48 b9 28 4c 14 00 00 	movabs rcx,0x144c28
  414f86:	00 00 00 
	libc.page_size = aux[AT_PAGESZ];
  414f89:	48 8b 54 24 50       	mov    rdx,QWORD PTR [rsp+0x50]
	__hwcap = aux[AT_HWCAP];
  414f8e:	49 89 3c 0f          	mov    QWORD PTR [r15+rcx*1],rdi
	if (aux[AT_SYSINFO]) __sysinfo = aux[AT_SYSINFO];
  414f92:	48 85 c0             	test   rax,rax
  414f95:	74 0e                	je     414fa5 <__init_libc+0xe5>
  414f97:	48 b9 10 4c 14 00 00 	movabs rcx,0x144c10
  414f9e:	00 00 00 
  414fa1:	49 89 04 0f          	mov    QWORD PTR [r15+rcx*1],rax
	libc.page_size = aux[AT_PAGESZ];
  414fa5:	4a 89 54 3b 38       	mov    QWORD PTR [rbx+r15*1+0x38],rdx

	if (!pn) pn = (void*)aux[AT_EXECFN];
  414faa:	48 85 f6             	test   rsi,rsi
  414fad:	0f 84 1d 02 00 00    	je     4151d0 <__init_libc+0x310>
	if (!pn) pn = "";
	__progname = __progname_full = pn;
  414fb3:	48 b8 f8 ff ff ff ff 	movabs rax,0xfffffffffffffff8
  414fba:	ff ff ff 
  414fbd:	48 b9 d8 ff ff ff ff 	movabs rcx,0xffffffffffffffd8
  414fc4:	ff ff ff 
  414fc7:	49 8b 04 07          	mov    rax,QWORD PTR [r15+rax*1]
  414fcb:	48 89 30             	mov    QWORD PTR [rax],rsi
  414fce:	4a 8b 04 39          	mov    rax,QWORD PTR [rcx+r15*1]
  414fd2:	48 89 30             	mov    QWORD PTR [rax],rsi
	for (i=0; pn[i]; i++) if (pn[i]=='/') __progname = pn+i+1;
  414fd5:	0f b6 16             	movzx  edx,BYTE PTR [rsi]
  414fd8:	84 d2                	test   dl,dl
  414fda:	74 18                	je     414ff4 <__init_libc+0x134>
  414fdc:	48 8d 46 01          	lea    rax,[rsi+0x1]
  414fe0:	80 fa 2f             	cmp    dl,0x2f
  414fe3:	0f 84 07 01 00 00    	je     4150f0 <__init_libc+0x230>
  414fe9:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  414fec:	48 83 c0 01          	add    rax,0x1
  414ff0:	84 d2                	test   dl,dl
  414ff2:	75 ec                	jne    414fe0 <__init_libc+0x120>

	__init_tls(aux);
  414ff4:	48 b8 e0 88 fb ff ff 	movabs rax,0xfffffffffffb88e0
  414ffb:	ff ff ff 
  414ffe:	4c 89 c7             	mov    rdi,r8
  415001:	4c 01 f8             	add    rax,r15
  415004:	ff d0                	call   rax
	__init_ssp((void *)aux[AT_RANDOM]);
  415006:	48 8b bc 24 e8 00 00 	mov    rdi,QWORD PTR [rsp+0xe8]
  41500d:	00 
  41500e:	48 b8 a0 7a fb ff ff 	movabs rax,0xfffffffffffb7aa0
  415015:	ff ff ff 
  415018:	4c 01 f8             	add    rax,r15
  41501b:	ff d0                	call   rax

	if (aux[AT_UID]==aux[AT_EUID] && aux[AT_GID]==aux[AT_EGID]
  41501d:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  415024:	00 
  415025:	48 39 44 24 78       	cmp    QWORD PTR [rsp+0x78],rax
  41502a:	75 16                	jne    415042 <__init_libc+0x182>
  41502c:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  415033:	00 
  415034:	48 39 84 24 88 00 00 	cmp    QWORD PTR [rsp+0x88],rax
  41503b:	00 
  41503c:	0f 84 d6 01 00 00    	je     415218 <__init_libc+0x358>
		&& !aux[AT_SECURE]) return;

	struct pollfd pfd[3] = { {.fd=0}, {.fd=1}, {.fd=2} };
  415042:	66 0f ef c0          	pxor   xmm0,xmm0
	int r =
#ifdef SYS_poll
	__syscall(SYS_poll, pfd, 3, 0);
  415046:	48 89 e6             	mov    rsi,rsp
	return __cos_syscall(n, a1, a2, 0, 0, 0, 0, 0);
}

static __inline long __syscall3(long n, long a1, long a2, long a3)
{
	return __cos_syscall(n, a1, a2, a3, 0, 0, 0, 0);
  415049:	45 31 c9             	xor    r9d,r9d
  41504c:	45 31 c0             	xor    r8d,r8d
	struct pollfd pfd[3] = { {.fd=0}, {.fd=1}, {.fd=2} };
  41504f:	0f 29 04 24          	movaps XMMWORD PTR [rsp],xmm0
  415053:	31 c9                	xor    ecx,ecx
  415055:	ba 03 00 00 00       	mov    edx,0x3
  41505a:	bf 07 00 00 00       	mov    edi,0x7
  41505f:	48 bd d0 ce fa ff ff 	movabs rbp,0xfffffffffffaced0
  415066:	ff ff ff 
  415069:	c7 44 24 08 01 00 00 	mov    DWORD PTR [rsp+0x8],0x1
  415070:	00 
  415071:	48 c7 44 24 10 00 00 	mov    QWORD PTR [rsp+0x10],0x0
  415078:	00 00 
  41507a:	4a 8d 44 3d 00       	lea    rax,[rbp+r15*1+0x0]
  41507f:	c7 44 24 10 02 00 00 	mov    DWORD PTR [rsp+0x10],0x2
  415086:	00 
  415087:	6a 00                	push   0x0
  415089:	6a 00                	push   0x0
  41508b:	ff d0                	call   rax
#else
	__syscall(SYS_ppoll, pfd, 3, &(struct timespec){0}, 0, _NSIG/8);
#endif
	if (r<0) a_crash();
  41508d:	41 5a                	pop    r10
  41508f:	41 5b                	pop    r11
  415091:	85 c0                	test   eax,eax
  415093:	79 01                	jns    415096 <__init_libc+0x1d6>
}

#define a_crash a_crash
static inline void a_crash()
{
	__asm__ __volatile__( "hlt" : : : "memory" );
  415095:	f4                   	hlt    
	for (i=0; i<3; i++) if (pfd[i].revents&POLLNVAL)
  415096:	f6 44 24 06 20       	test   BYTE PTR [rsp+0x6],0x20
  41509b:	0f 85 ef 00 00 00    	jne    415190 <__init_libc+0x2d0>
  4150a1:	f6 44 24 0e 20       	test   BYTE PTR [rsp+0xe],0x20
  4150a6:	0f 85 a4 00 00 00    	jne    415150 <__init_libc+0x290>
  4150ac:	f6 44 24 16 20       	test   BYTE PTR [rsp+0x16],0x20
  4150b1:	75 5d                	jne    415110 <__init_libc+0x250>
		if (__sys_open("/dev/null", O_RDWR)<0)
			a_crash();
	libc.secure = 1;
  4150b3:	42 c7 44 3b 08 01 00 	mov    DWORD PTR [rbx+r15*1+0x8],0x1
  4150ba:	00 00 
}
  4150bc:	48 81 c4 50 01 00 00 	add    rsp,0x150
  4150c3:	5b                   	pop    rbx
  4150c4:	5d                   	pop    rbp
  4150c5:	41 5f                	pop    r15
  4150c7:	c3                   	ret    
  4150c8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4150cf:	00 
	for (i=0; auxv[i]; i+=2) if (auxv[i]<AUX_CNT) aux[auxv[i]] = auxv[i+1];
  4150d0:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  4150d4:	48 83 c0 10          	add    rax,0x10
  4150d8:	48 85 d2             	test   rdx,rdx
  4150db:	0f 85 6f fe ff ff    	jne    414f50 <__init_libc+0x90>
  4150e1:	e9 89 fe ff ff       	jmp    414f6f <__init_libc+0xaf>
  4150e6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4150ed:	00 00 00 
	for (i=0; pn[i]; i++) if (pn[i]=='/') __progname = pn+i+1;
  4150f0:	4a 8b 14 39          	mov    rdx,QWORD PTR [rcx+r15*1]
  4150f4:	48 89 02             	mov    QWORD PTR [rdx],rax
  4150f7:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  4150fa:	48 83 c0 01          	add    rax,0x1
  4150fe:	84 d2                	test   dl,dl
  415100:	0f 85 da fe ff ff    	jne    414fe0 <__init_libc+0x120>
  415106:	e9 e9 fe ff ff       	jmp    414ff4 <__init_libc+0x134>
  41510b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	return __cos_syscall(n, a1, a2, 0, 0, 0, 0, 0);
  415110:	6a 00                	push   0x0
  415112:	31 c9                	xor    ecx,ecx
  415114:	ba 02 00 00 00       	mov    edx,0x2
  415119:	45 31 c9             	xor    r9d,r9d
  41511c:	6a 00                	push   0x0
  41511e:	45 31 c0             	xor    r8d,r8d
  415121:	bf 02 00 00 00       	mov    edi,0x2
  415126:	4c 01 fd             	add    rbp,r15
  415129:	48 b8 b5 1d fc ff ff 	movabs rax,0xfffffffffffc1db5
  415130:	ff ff ff 
  415133:	49 8d 34 07          	lea    rsi,[r15+rax*1]
  415137:	ff d5                	call   rbp
		if (__sys_open("/dev/null", O_RDWR)<0)
  415139:	5a                   	pop    rdx
  41513a:	59                   	pop    rcx
  41513b:	48 85 c0             	test   rax,rax
  41513e:	0f 89 6f ff ff ff    	jns    4150b3 <__init_libc+0x1f3>
  415144:	f4                   	hlt    
}
  415145:	e9 69 ff ff ff       	jmp    4150b3 <__init_libc+0x1f3>
  41514a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  415150:	6a 00                	push   0x0
  415152:	bf 02 00 00 00       	mov    edi,0x2
  415157:	45 31 c9             	xor    r9d,r9d
  41515a:	45 31 c0             	xor    r8d,r8d
  41515d:	48 b8 b5 1d fc ff ff 	movabs rax,0xfffffffffffc1db5
  415164:	ff ff ff 
  415167:	6a 00                	push   0x0
  415169:	31 c9                	xor    ecx,ecx
  41516b:	ba 02 00 00 00       	mov    edx,0x2
  415170:	49 8d 34 07          	lea    rsi,[r15+rax*1]
  415174:	4a 8d 44 3d 00       	lea    rax,[rbp+r15*1+0x0]
  415179:	ff d0                	call   rax
  41517b:	5e                   	pop    rsi
  41517c:	5f                   	pop    rdi
  41517d:	48 85 c0             	test   rax,rax
  415180:	0f 89 26 ff ff ff    	jns    4150ac <__init_libc+0x1ec>
	__asm__ __volatile__( "hlt" : : : "memory" );
  415186:	f4                   	hlt    
  415187:	e9 20 ff ff ff       	jmp    4150ac <__init_libc+0x1ec>
  41518c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  415190:	6a 00                	push   0x0
  415192:	45 31 c9             	xor    r9d,r9d
  415195:	45 31 c0             	xor    r8d,r8d
  415198:	31 c9                	xor    ecx,ecx
  41519a:	6a 00                	push   0x0
  41519c:	ba 02 00 00 00       	mov    edx,0x2
  4151a1:	bf 02 00 00 00       	mov    edi,0x2
  4151a6:	48 b8 b5 1d fc ff ff 	movabs rax,0xfffffffffffc1db5
  4151ad:	ff ff ff 
  4151b0:	49 8d 34 07          	lea    rsi,[r15+rax*1]
  4151b4:	4a 8d 44 3d 00       	lea    rax,[rbp+r15*1+0x0]
  4151b9:	ff d0                	call   rax
  4151bb:	41 58                	pop    r8
  4151bd:	41 59                	pop    r9
  4151bf:	48 85 c0             	test   rax,rax
  4151c2:	0f 89 d9 fe ff ff    	jns    4150a1 <__init_libc+0x1e1>
  4151c8:	f4                   	hlt    
  4151c9:	e9 d3 fe ff ff       	jmp    4150a1 <__init_libc+0x1e1>
  4151ce:	66 90                	xchg   ax,ax
	if (!pn) pn = (void*)aux[AT_EXECFN];
  4151d0:	48 8b 84 24 18 01 00 	mov    rax,QWORD PTR [rsp+0x118]
  4151d7:	00 
	if (!pn) pn = "";
  4151d8:	48 85 c0             	test   rax,rax
  4151db:	75 7a                	jne    415257 <__init_libc+0x397>
	__progname = __progname_full = pn;
  4151dd:	48 b8 f8 ff ff ff ff 	movabs rax,0xfffffffffffffff8
  4151e4:	ff ff ff 
  4151e7:	49 8b 14 07          	mov    rdx,QWORD PTR [r15+rax*1]
  4151eb:	48 b8 85 1e fc ff ff 	movabs rax,0xfffffffffffc1e85
  4151f2:	ff ff ff 
  4151f5:	4c 01 f8             	add    rax,r15
  4151f8:	48 89 02             	mov    QWORD PTR [rdx],rax
  4151fb:	48 ba d8 ff ff ff ff 	movabs rdx,0xffffffffffffffd8
  415202:	ff ff ff 
  415205:	49 8b 14 17          	mov    rdx,QWORD PTR [r15+rdx*1]
  415209:	48 89 02             	mov    QWORD PTR [rdx],rax
	for (i=0; pn[i]; i++) if (pn[i]=='/') __progname = pn+i+1;
  41520c:	e9 e3 fd ff ff       	jmp    414ff4 <__init_libc+0x134>
  415211:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		&& !aux[AT_SECURE]) return;
  415218:	48 83 bc 24 d8 00 00 	cmp    QWORD PTR [rsp+0xd8],0x0
  41521f:	00 00 
  415221:	0f 85 1b fe ff ff    	jne    415042 <__init_libc+0x182>
  415227:	e9 90 fe ff ff       	jmp    4150bc <__init_libc+0x1fc>
  41522c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	for (i=0; envp[i]; i++);
  415230:	b8 08 00 00 00       	mov    eax,0x8
  415235:	e9 f4 fc ff ff       	jmp    414f2e <__init_libc+0x6e>
  41523a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	__hwcap = aux[AT_HWCAP];
  415240:	48 b8 28 4c 14 00 00 	movabs rax,0x144c28
  415247:	00 00 00 
  41524a:	49 c7 04 07 00 00 00 	mov    QWORD PTR [r15+rax*1],0x0
  415251:	00 
	if (aux[AT_SYSINFO]) __sysinfo = aux[AT_SYSINFO];
  415252:	e9 4e fd ff ff       	jmp    414fa5 <__init_libc+0xe5>
	if (!pn) pn = (void*)aux[AT_EXECFN];
  415257:	48 89 c6             	mov    rsi,rax
  41525a:	e9 54 fd ff ff       	jmp    414fb3 <__init_libc+0xf3>
  41525f:	90                   	nop

0000000000415260 <__libc_start_init>:

static void libc_start_init(void)
{
  415260:	f3 0f 1e fa          	endbr64 
	_init();
  415264:	49 bb ac 81 04 00 00 	movabs r11,0x481ac
  41526b:	00 00 00 
{
  41526e:	41 57                	push   r15
  415270:	4c 8d 3d ed ff ff ff 	lea    r15,[rip+0xffffffffffffffed]        # 415264 <__libc_start_init+0x4>
	_init();
  415277:	48 b8 70 7a fb ff ff 	movabs rax,0xfffffffffffb7a70
  41527e:	ff ff ff 
  415281:	4d 01 df             	add    r15,r11
{
  415284:	55                   	push   rbp
	_init();
  415285:	4c 01 f8             	add    rax,r15
{
  415288:	53                   	push   rbx
	_init();
  415289:	ff d0                	call   rax
	uintptr_t a = (uintptr_t)&__init_array_start;
  41528b:	48 b8 f0 ff ff ff ff 	movabs rax,0xfffffffffffffff0
  415292:	ff ff ff 
  415295:	49 8b 1c 07          	mov    rbx,QWORD PTR [r15+rax*1]
	for (; a<(uintptr_t)&__init_array_end; a+=sizeof(void(*)()))
  415299:	48 b8 e8 ff ff ff ff 	movabs rax,0xffffffffffffffe8
  4152a0:	ff ff ff 
  4152a3:	49 8b 2c 07          	mov    rbp,QWORD PTR [r15+rax*1]
  4152a7:	48 39 eb             	cmp    rbx,rbp
  4152aa:	73 0f                	jae    4152bb <__libc_start_init+0x5b>
  4152ac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		(*(void (**)(void))a)();
  4152b0:	ff 13                	call   QWORD PTR [rbx]
	for (; a<(uintptr_t)&__init_array_end; a+=sizeof(void(*)()))
  4152b2:	48 83 c3 08          	add    rbx,0x8
  4152b6:	48 39 eb             	cmp    rbx,rbp
  4152b9:	72 f5                	jb     4152b0 <__libc_start_init+0x50>
}
  4152bb:	5b                   	pop    rbx
  4152bc:	5d                   	pop    rbp
  4152bd:	41 5f                	pop    r15
  4152bf:	c3                   	ret    

00000000004152c0 <libc_start_main_stage2>:
	__asm__ ( "" : "+r"(stage2) : : "memory" );
	return stage2(main, argc, argv);
}

static int libc_start_main_stage2(int (*main)(int,char **,char **), int argc, char **argv)
{
  4152c0:	f3 0f 1e fa          	endbr64 
	char **envp = argv+argc+1;
  4152c4:	49 bb 4c 81 04 00 00 	movabs r11,0x4814c
  4152cb:	00 00 00 
{
  4152ce:	41 57                	push   r15
  4152d0:	48 63 c6             	movsxd rax,esi
  4152d3:	4c 8d 3d ea ff ff ff 	lea    r15,[rip+0xffffffffffffffea]        # 4152c4 <libc_start_main_stage2+0x4>
  4152da:	41 55                	push   r13
  4152dc:	4d 01 df             	add    r15,r11
	char **envp = argv+argc+1;
  4152df:	4c 8d 6c c2 08       	lea    r13,[rdx+rax*8+0x8]
{
  4152e4:	41 54                	push   r12
  4152e6:	49 89 d4             	mov    r12,rdx
  4152e9:	55                   	push   rbp
  4152ea:	48 89 c5             	mov    rbp,rax
	__libc_start_init();
  4152ed:	48 b8 50 7e fb ff ff 	movabs rax,0xfffffffffffb7e50
  4152f4:	ff ff ff 
{
  4152f7:	53                   	push   rbx
	__libc_start_init();
  4152f8:	4c 01 f8             	add    rax,r15
{
  4152fb:	48 89 fb             	mov    rbx,rdi
	__libc_start_init();
  4152fe:	ff d0                	call   rax

	/* Pass control to the application */
	exit(main(argc, argv, envp));
  415300:	89 ef                	mov    edi,ebp
  415302:	4c 89 ea             	mov    rdx,r13
  415305:	4c 89 e6             	mov    rsi,r12
  415308:	ff d3                	call   rbx
  41530a:	89 c7                	mov    edi,eax
  41530c:	48 b8 f0 7f fb ff ff 	movabs rax,0xfffffffffffb7ff0
  415313:	ff ff ff 
  415316:	4c 01 f8             	add    rax,r15
  415319:	ff d0                	call   rax
  41531b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000415320 <__libc_start_main>:
{
  415320:	f3 0f 1e fa          	endbr64 
	char **envp = argv+argc+1;
  415324:	49 bb ec 80 04 00 00 	movabs r11,0x480ec
  41532b:	00 00 00 
{
  41532e:	41 55                	push   r13
  415330:	48 63 c6             	movsxd rax,esi
  415333:	49 89 fd             	mov    r13,rdi
  415336:	41 54                	push   r12
	char **envp = argv+argc+1;
  415338:	48 8d 7c c2 08       	lea    rdi,[rdx+rax*8+0x8]
{
  41533d:	49 89 d4             	mov    r12,rdx
  415340:	55                   	push   rbp
  415341:	48 89 c5             	mov    rbp,rax
	__init_libc(envp, argv[0]);
  415344:	48 b8 b0 7a fb ff ff 	movabs rax,0xfffffffffffb7ab0
  41534b:	ff ff ff 
{
  41534e:	53                   	push   rbx
  41534f:	48 8d 1d ce ff ff ff 	lea    rbx,[rip+0xffffffffffffffce]        # 415324 <__libc_start_main+0x4>
  415356:	4c 01 db             	add    rbx,r11
	__init_libc(envp, argv[0]);
  415359:	48 01 d8             	add    rax,rbx
{
  41535c:	48 83 ec 08          	sub    rsp,0x8
	__init_libc(envp, argv[0]);
  415360:	48 8b 32             	mov    rsi,QWORD PTR [rdx]
  415363:	ff d0                	call   rax
	return stage2(main, argc, argv);
  415365:	4c 89 e2             	mov    rdx,r12
  415368:	89 ee                	mov    esi,ebp
  41536a:	4c 89 ef             	mov    rdi,r13
	__asm__ ( "" : "+r"(stage2) : : "memory" );
  41536d:	48 b8 b0 7e fb ff ff 	movabs rax,0xfffffffffffb7eb0
  415374:	ff ff ff 
  415377:	48 01 d8             	add    rax,rbx
}
  41537a:	48 83 c4 08          	add    rsp,0x8
  41537e:	5b                   	pop    rbx
  41537f:	5d                   	pop    rbp
  415380:	41 5c                	pop    r12
  415382:	41 5d                	pop    r13
	return stage2(main, argc, argv);
  415384:	ff e0                	jmp    rax
  415386:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41538d:	00 00 00 

0000000000415390 <__libc_exit_fini>:
weak_alias(dummy, _fini);

extern weak hidden void (*const __fini_array_start)(void), (*const __fini_array_end)(void);

static void libc_exit_fini(void)
{
  415390:	f3 0f 1e fa          	endbr64 
	uintptr_t a = (uintptr_t)&__fini_array_end;
  415394:	49 bb 7c 80 04 00 00 	movabs r11,0x4807c
  41539b:	00 00 00 
{
  41539e:	41 57                	push   r15
  4153a0:	4c 8d 3d ed ff ff ff 	lea    r15,[rip+0xffffffffffffffed]        # 415394 <__libc_exit_fini+0x4>
	uintptr_t a = (uintptr_t)&__fini_array_end;
  4153a7:	48 b8 c8 ff ff ff ff 	movabs rax,0xffffffffffffffc8
  4153ae:	ff ff ff 
  4153b1:	4d 01 df             	add    r15,r11
{
  4153b4:	55                   	push   rbp
  4153b5:	53                   	push   rbx
	uintptr_t a = (uintptr_t)&__fini_array_end;
  4153b6:	49 8b 1c 07          	mov    rbx,QWORD PTR [r15+rax*1]
	for (; a>(uintptr_t)&__fini_array_start; a-=sizeof(void(*)()))
  4153ba:	48 b8 e0 ff ff ff ff 	movabs rax,0xffffffffffffffe0
  4153c1:	ff ff ff 
  4153c4:	49 8b 2c 07          	mov    rbp,QWORD PTR [r15+rax*1]
  4153c8:	48 39 eb             	cmp    rbx,rbp
  4153cb:	76 10                	jbe    4153dd <__libc_exit_fini+0x4d>
  4153cd:	0f 1f 00             	nop    DWORD PTR [rax]
		(*(void (**)())(a-sizeof(void(*)())))();
  4153d0:	48 83 eb 08          	sub    rbx,0x8
  4153d4:	31 c0                	xor    eax,eax
  4153d6:	ff 13                	call   QWORD PTR [rbx]
	for (; a>(uintptr_t)&__fini_array_start; a-=sizeof(void(*)()))
  4153d8:	48 39 eb             	cmp    rbx,rbp
  4153db:	77 f3                	ja     4153d0 <__libc_exit_fini+0x40>
	_fini();
  4153dd:	48 ba 80 7a fb ff ff 	movabs rdx,0xfffffffffffb7a80
  4153e4:	ff ff ff 
}
  4153e7:	5b                   	pop    rbx
	_fini();
  4153e8:	31 c0                	xor    eax,eax
}
  4153ea:	5d                   	pop    rbp
	_fini();
  4153eb:	4c 01 fa             	add    rdx,r15
}
  4153ee:	41 5f                	pop    r15
	_fini();
  4153f0:	ff e2                	jmp    rdx
  4153f2:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4153f9:	00 00 00 
  4153fc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000415400 <exit>:

weak_alias(libc_exit_fini, __libc_exit_fini);

_Noreturn void exit(int code)
{
  415400:	f3 0f 1e fa          	endbr64 
	__funcs_on_exit();
  415404:	49 bb 0c 80 04 00 00 	movabs r11,0x4800c
  41540b:	00 00 00 
{
  41540e:	41 57                	push   r15
  415410:	4c 8d 3d ed ff ff ff 	lea    r15,[rip+0xffffffffffffffed]        # 415404 <exit+0x4>
	__funcs_on_exit();
  415417:	48 b8 80 7a fb ff ff 	movabs rax,0xfffffffffffb7a80
  41541e:	ff ff ff 
{
  415421:	55                   	push   rbp
  415422:	4d 01 df             	add    r15,r11
  415425:	89 fd                	mov    ebp,edi
	__funcs_on_exit();
  415427:	4c 01 f8             	add    rax,r15
{
  41542a:	48 83 ec 08          	sub    rsp,0x8
	__funcs_on_exit();
  41542e:	ff d0                	call   rax
	__libc_exit_fini();
  415430:	48 b8 80 7f fb ff ff 	movabs rax,0xfffffffffffb7f80
  415437:	ff ff ff 
  41543a:	4c 01 f8             	add    rax,r15
  41543d:	ff d0                	call   rax
	__stdio_exit();
  41543f:	31 c0                	xor    eax,eax
  415441:	48 ba d0 e7 fb ff ff 	movabs rdx,0xfffffffffffbe7d0
  415448:	ff ff ff 
  41544b:	4c 01 fa             	add    rdx,r15
  41544e:	ff d2                	call   rdx
	_Exit(code);
  415450:	89 ef                	mov    edi,ebp
  415452:	48 b8 20 8d fb ff ff 	movabs rax,0xfffffffffffb8d20
  415459:	ff ff ff 
  41545c:	4c 01 f8             	add    rax,r15
  41545f:	ff d0                	call   rax
  415461:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  415468:	00 00 00 
  41546b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000415470 <sn_write>:
};

#define MIN(a, b) ((a) < (b) ? (a) : (b))

static size_t sn_write(FILE *f, const unsigned char *s, size_t l)
{
  415470:	f3 0f 1e fa          	endbr64 
	struct cookie *c = f->cookie;
  415474:	49 bb 9c 7f 04 00 00 	movabs r11,0x47f9c
  41547b:	00 00 00 
{
  41547e:	41 57                	push   r15
  415480:	4c 8d 3d ed ff ff ff 	lea    r15,[rip+0xffffffffffffffed]        # 415474 <sn_write+0x4>
  415487:	41 56                	push   r14
  415489:	49 89 f6             	mov    r14,rsi
  41548c:	4d 01 df             	add    r15,r11
  41548f:	41 55                	push   r13
  415491:	41 54                	push   r12
  415493:	49 89 d4             	mov    r12,rdx
  415496:	55                   	push   rbp
  415497:	48 89 fd             	mov    rbp,rdi
  41549a:	53                   	push   rbx
  41549b:	48 83 ec 08          	sub    rsp,0x8
	struct cookie *c = f->cookie;
  41549f:	4c 8b af 98 00 00 00 	mov    r13,QWORD PTR [rdi+0x98]
	size_t k = MIN(c->n, f->wpos - f->wbase);
  4154a6:	48 8b 77 38          	mov    rsi,QWORD PTR [rdi+0x38]
  4154aa:	48 8b 57 28          	mov    rdx,QWORD PTR [rdi+0x28]
  4154ae:	49 8b 45 08          	mov    rax,QWORD PTR [r13+0x8]
	if (k) {
		memcpy(c->s, f->wbase, k);
  4154b2:	49 8b 7d 00          	mov    rdi,QWORD PTR [r13+0x0]
	size_t k = MIN(c->n, f->wpos - f->wbase);
  4154b6:	48 29 f2             	sub    rdx,rsi
  4154b9:	48 39 c2             	cmp    rdx,rax
  4154bc:	48 89 d3             	mov    rbx,rdx
  4154bf:	48 0f 47 d8          	cmova  rbx,rax
	if (k) {
  4154c3:	48 85 db             	test   rbx,rbx
  4154c6:	75 38                	jne    415500 <sn_write+0x90>
		c->s += k;
		c->n -= k;
	}
	k = MIN(c->n, l);
  4154c8:	49 39 c4             	cmp    r12,rax
  4154cb:	49 0f 46 c4          	cmovbe rax,r12
  4154cf:	48 89 c3             	mov    rbx,rax
	if (k) {
  4154d2:	48 85 c0             	test   rax,rax
  4154d5:	75 60                	jne    415537 <sn_write+0xc7>
		memcpy(c->s, s, k);
		c->s += k;
		c->n -= k;
	}
	*c->s = 0;
  4154d7:	c6 07 00             	mov    BYTE PTR [rdi],0x0
	f->wpos = f->wbase = f->buf;
  4154da:	48 8b 45 58          	mov    rax,QWORD PTR [rbp+0x58]
  4154de:	48 89 45 38          	mov    QWORD PTR [rbp+0x38],rax
  4154e2:	48 89 45 28          	mov    QWORD PTR [rbp+0x28],rax
	/* pretend to succeed, even if we discarded extra data */
	return l;
}
  4154e6:	48 83 c4 08          	add    rsp,0x8
  4154ea:	4c 89 e0             	mov    rax,r12
  4154ed:	5b                   	pop    rbx
  4154ee:	5d                   	pop    rbp
  4154ef:	41 5c                	pop    r12
  4154f1:	41 5d                	pop    r13
  4154f3:	41 5e                	pop    r14
  4154f5:	41 5f                	pop    r15
  4154f7:	c3                   	ret    
  4154f8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4154ff:	00 
		memcpy(c->s, f->wbase, k);
  415500:	48 b8 4a 79 fb ff ff 	movabs rax,0xfffffffffffb794a
  415507:	ff ff ff 
  41550a:	48 89 da             	mov    rdx,rbx
  41550d:	4c 01 f8             	add    rax,r15
  415510:	ff d0                	call   rax
		c->n -= k;
  415512:	49 8b 45 08          	mov    rax,QWORD PTR [r13+0x8]
		c->s += k;
  415516:	49 8b 7d 00          	mov    rdi,QWORD PTR [r13+0x0]
		c->n -= k;
  41551a:	48 29 d8             	sub    rax,rbx
		c->s += k;
  41551d:	48 01 df             	add    rdi,rbx
	k = MIN(c->n, l);
  415520:	49 39 c4             	cmp    r12,rax
		c->n -= k;
  415523:	49 89 45 08          	mov    QWORD PTR [r13+0x8],rax
	k = MIN(c->n, l);
  415527:	49 0f 46 c4          	cmovbe rax,r12
		c->s += k;
  41552b:	49 89 7d 00          	mov    QWORD PTR [r13+0x0],rdi
	k = MIN(c->n, l);
  41552f:	48 89 c3             	mov    rbx,rax
	if (k) {
  415532:	48 85 c0             	test   rax,rax
  415535:	74 a0                	je     4154d7 <sn_write+0x67>
		memcpy(c->s, s, k);
  415537:	48 89 c2             	mov    rdx,rax
  41553a:	4c 89 f6             	mov    rsi,r14
  41553d:	48 b8 4a 79 fb ff ff 	movabs rax,0xfffffffffffb794a
  415544:	ff ff ff 
  415547:	4c 01 f8             	add    rax,r15
  41554a:	ff d0                	call   rax
		c->s += k;
  41554c:	49 8b 7d 00          	mov    rdi,QWORD PTR [r13+0x0]
		c->n -= k;
  415550:	49 29 5d 08          	sub    QWORD PTR [r13+0x8],rbx
		c->s += k;
  415554:	48 01 df             	add    rdi,rbx
  415557:	49 89 7d 00          	mov    QWORD PTR [r13+0x0],rdi
		c->n -= k;
  41555b:	e9 77 ff ff ff       	jmp    4154d7 <sn_write+0x67>

0000000000415560 <vsnprintf>:

int vsnprintf(char *restrict s, size_t n, const char *restrict fmt, va_list ap)
{
  415560:	f3 0f 1e fa          	endbr64 
	unsigned char buf[1];
	char dummy[1];
	struct cookie c = { .s = n ? s : dummy, .n = n ? n-1 : 0 };
  415564:	49 bb ac 7e 04 00 00 	movabs r11,0x47eac
  41556b:	00 00 00 
{
  41556e:	41 57                	push   r15
  415570:	49 89 f2             	mov    r10,rsi
  415573:	4c 8d 3d ea ff ff ff 	lea    r15,[rip+0xffffffffffffffea]        # 415564 <vsnprintf+0x4>
  41557a:	48 89 d6             	mov    rsi,rdx
  41557d:	4d 01 df             	add    r15,r11
  415580:	48 89 ca             	mov    rdx,rcx
  415583:	48 81 ec 10 01 00 00 	sub    rsp,0x110
	struct cookie c = { .s = n ? s : dummy, .n = n ? n-1 : 0 };
  41558a:	4d 85 d2             	test   r10,r10
  41558d:	0f 85 8d 00 00 00    	jne    415620 <vsnprintf+0xc0>
	FILE f = {
  415593:	4c 8d 4c 24 20       	lea    r9,[rsp+0x20]
  415598:	4c 89 d0             	mov    rax,r10
  41559b:	b9 1d 00 00 00       	mov    ecx,0x1d
	struct cookie c = { .s = n ? s : dummy, .n = n ? n-1 : 0 };
  4155a0:	48 c7 44 24 18 00 00 	mov    QWORD PTR [rsp+0x18],0x0
  4155a7:	00 00 
	FILE f = {
  4155a9:	4c 89 cf             	mov    rdi,r9
	struct cookie c = { .s = n ? s : dummy, .n = n ? n-1 : 0 };
  4155ac:	4c 8d 44 24 0f       	lea    r8,[rsp+0xf]
	FILE f = {
  4155b1:	f3 48 ab             	rep stos QWORD PTR es:[rdi],rax
	struct cookie c = { .s = n ? s : dummy, .n = n ? n-1 : 0 };
  4155b4:	4c 89 44 24 10       	mov    QWORD PTR [rsp+0x10],r8
	FILE f = {
  4155b9:	48 b8 60 80 fb ff ff 	movabs rax,0xfffffffffffb8060
  4155c0:	ff ff ff 
  4155c3:	c7 84 24 ac 00 00 00 	mov    DWORD PTR [rsp+0xac],0xffffffff
  4155ca:	ff ff ff ff 
  4155ce:	4c 01 f8             	add    rax,r15
  4155d1:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  4155d6:	48 8d 44 24 0e       	lea    rax,[rsp+0xe]
  4155db:	48 89 44 24 78       	mov    QWORD PTR [rsp+0x78],rax
  4155e0:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  4155e5:	c7 84 24 b0 00 00 00 	mov    DWORD PTR [rsp+0xb0],0xffffffff
  4155ec:	ff ff ff ff 
  4155f0:	48 89 84 24 b8 00 00 	mov    QWORD PTR [rsp+0xb8],rax
  4155f7:	00 
		errno = EOVERFLOW;
		return -1;
	}

	*c.s = 0;
	return vfprintf(&f, fmt, ap);
  4155f8:	48 b8 70 da fb ff ff 	movabs rax,0xfffffffffffbda70
  4155ff:	ff ff ff 
	*c.s = 0;
  415602:	41 c6 00 00          	mov    BYTE PTR [r8],0x0
	return vfprintf(&f, fmt, ap);
  415606:	4c 89 cf             	mov    rdi,r9
  415609:	4c 01 f8             	add    rax,r15
  41560c:	ff d0                	call   rax
}
  41560e:	48 81 c4 10 01 00 00 	add    rsp,0x110
  415615:	41 5f                	pop    r15
  415617:	c3                   	ret    
  415618:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41561f:	00 
	struct cookie c = { .s = n ? s : dummy, .n = n ? n-1 : 0 };
  415620:	49 8d 42 ff          	lea    rax,[r10-0x1]
	FILE f = {
  415624:	4c 8d 4c 24 20       	lea    r9,[rsp+0x20]
	struct cookie c = { .s = n ? s : dummy, .n = n ? n-1 : 0 };
  415629:	48 89 7c 24 10       	mov    QWORD PTR [rsp+0x10],rdi
  41562e:	49 89 f8             	mov    r8,rdi
  415631:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
	FILE f = {
  415636:	b9 1d 00 00 00       	mov    ecx,0x1d
  41563b:	31 c0                	xor    eax,eax
  41563d:	4c 89 cf             	mov    rdi,r9
  415640:	f3 48 ab             	rep stos QWORD PTR es:[rdi],rax
  415643:	48 b8 60 80 fb ff ff 	movabs rax,0xfffffffffffb8060
  41564a:	ff ff ff 
  41564d:	c7 84 24 ac 00 00 00 	mov    DWORD PTR [rsp+0xac],0xffffffff
  415654:	ff ff ff ff 
  415658:	c7 84 24 b0 00 00 00 	mov    DWORD PTR [rsp+0xb0],0xffffffff
  41565f:	ff ff ff ff 
  415663:	4c 01 f8             	add    rax,r15
  415666:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  41566b:	48 8d 44 24 0e       	lea    rax,[rsp+0xe]
  415670:	48 89 44 24 78       	mov    QWORD PTR [rsp+0x78],rax
  415675:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  41567a:	48 89 84 24 b8 00 00 	mov    QWORD PTR [rsp+0xb8],rax
  415681:	00 
	if (n > INT_MAX) {
  415682:	49 81 fa ff ff ff 7f 	cmp    r10,0x7fffffff
  415689:	0f 86 69 ff ff ff    	jbe    4155f8 <vsnprintf+0x98>
		errno = EOVERFLOW;
  41568f:	48 b8 f0 8c fb ff ff 	movabs rax,0xfffffffffffb8cf0
  415696:	ff ff ff 
  415699:	4c 01 f8             	add    rax,r15
  41569c:	ff d0                	call   rax
  41569e:	c7 00 4b 00 00 00    	mov    DWORD PTR [rax],0x4b
		return -1;
  4156a4:	b8 ff ff ff ff       	mov    eax,0xffffffff
  4156a9:	e9 60 ff ff ff       	jmp    41560e <vsnprintf+0xae>
  4156ae:	66 90                	xchg   ax,ax

00000000004156b0 <atoi>:
#include <stdlib.h>
#include <ctype.h>

int atoi(const char *s)
{
  4156b0:	f3 0f 1e fa          	endbr64 
	int n=0, neg=0;
	while (isspace(*s)) s++;
  4156b4:	eb 0e                	jmp    4156c4 <atoi+0x14>
  4156b6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4156bd:	00 00 00 
  4156c0:	48 83 c7 01          	add    rdi,0x1
  4156c4:	0f be 07             	movsx  eax,BYTE PTR [rdi]
int   toupper(int);

#ifndef __cplusplus
static __inline int __isspace(int _c)
{
	return _c == ' ' || (unsigned)_c-'\t' < 5;
  4156c7:	8d 48 f7             	lea    ecx,[rax-0x9]
  4156ca:	89 c2                	mov    edx,eax
  4156cc:	83 f9 04             	cmp    ecx,0x4
  4156cf:	76 ef                	jbe    4156c0 <atoi+0x10>
  4156d1:	80 fa 20             	cmp    dl,0x20
  4156d4:	74 ea                	je     4156c0 <atoi+0x10>
	switch (*s) {
  4156d6:	80 fa 2b             	cmp    dl,0x2b
  4156d9:	74 4d                	je     415728 <atoi+0x78>
  4156db:	80 fa 2d             	cmp    dl,0x2d
  4156de:	74 68                	je     415748 <atoi+0x98>
	case '-': neg=1;
	case '+': s++;
	}
	/* Compute n as a negative number to avoid overflow on INT_MIN */
	while (isdigit(*s))
  4156e0:	8d 50 d0             	lea    edx,[rax-0x30]
  4156e3:	48 89 f9             	mov    rcx,rdi
	int n=0, neg=0;
  4156e6:	45 31 c9             	xor    r9d,r9d
	while (isdigit(*s))
  4156e9:	83 fa 09             	cmp    edx,0x9
  4156ec:	77 4d                	ja     41573b <atoi+0x8b>
	int n=0, neg=0;
  4156ee:	45 31 c0             	xor    r8d,r8d
  4156f1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		n = 10*n - (*s++ - '0');
  4156f8:	48 83 c1 01          	add    rcx,0x1
  4156fc:	43 8d 14 80          	lea    edx,[r8+r8*4]
  415700:	8d 70 d0             	lea    esi,[rax-0x30]
	while (isdigit(*s))
  415703:	0f be 01             	movsx  eax,BYTE PTR [rcx]
		n = 10*n - (*s++ - '0');
  415706:	01 d2                	add    edx,edx
  415708:	41 89 d0             	mov    r8d,edx
	while (isdigit(*s))
  41570b:	8d 78 d0             	lea    edi,[rax-0x30]
		n = 10*n - (*s++ - '0');
  41570e:	41 29 f0             	sub    r8d,esi
	while (isdigit(*s))
  415711:	83 ff 09             	cmp    edi,0x9
  415714:	76 e2                	jbe    4156f8 <atoi+0x48>
	return neg ? n : -n;
  415716:	29 d6                	sub    esi,edx
  415718:	45 85 c9             	test   r9d,r9d
  41571b:	44 0f 44 c6          	cmove  r8d,esi
}
  41571f:	44 89 c0             	mov    eax,r8d
  415722:	c3                   	ret    
  415723:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	while (isdigit(*s))
  415728:	0f be 47 01          	movsx  eax,BYTE PTR [rdi+0x1]
	case '+': s++;
  41572c:	48 8d 4f 01          	lea    rcx,[rdi+0x1]
	int n=0, neg=0;
  415730:	45 31 c9             	xor    r9d,r9d
	while (isdigit(*s))
  415733:	8d 50 d0             	lea    edx,[rax-0x30]
  415736:	83 fa 09             	cmp    edx,0x9
  415739:	76 b3                	jbe    4156ee <atoi+0x3e>
  41573b:	45 31 c0             	xor    r8d,r8d
}
  41573e:	44 89 c0             	mov    eax,r8d
  415741:	c3                   	ret    
  415742:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	while (isdigit(*s))
  415748:	0f be 47 01          	movsx  eax,BYTE PTR [rdi+0x1]
	case '+': s++;
  41574c:	48 8d 4f 01          	lea    rcx,[rdi+0x1]
	while (isdigit(*s))
  415750:	8d 50 d0             	lea    edx,[rax-0x30]
  415753:	83 fa 09             	cmp    edx,0x9
  415756:	77 e3                	ja     41573b <atoi+0x8b>
	case '-': neg=1;
  415758:	41 b9 01 00 00 00    	mov    r9d,0x1
  41575e:	eb 8e                	jmp    4156ee <atoi+0x3e>

0000000000415760 <atol>:
#include <stdlib.h>
#include <ctype.h>

long atol(const char *s)
{
  415760:	f3 0f 1e fa          	endbr64 
	long n=0;
	int neg=0;
	while (isspace(*s)) s++;
  415764:	eb 0e                	jmp    415774 <atol+0x14>
  415766:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41576d:	00 00 00 
  415770:	48 83 c7 01          	add    rdi,0x1
  415774:	0f be 07             	movsx  eax,BYTE PTR [rdi]
  415777:	8d 48 f7             	lea    ecx,[rax-0x9]
  41577a:	89 c2                	mov    edx,eax
  41577c:	83 f9 04             	cmp    ecx,0x4
  41577f:	76 ef                	jbe    415770 <atol+0x10>
  415781:	80 fa 20             	cmp    dl,0x20
  415784:	74 ea                	je     415770 <atol+0x10>
	switch (*s) {
  415786:	80 fa 2b             	cmp    dl,0x2b
  415789:	74 55                	je     4157e0 <atol+0x80>
  41578b:	80 fa 2d             	cmp    dl,0x2d
  41578e:	74 70                	je     415800 <atol+0xa0>
	case '-': neg=1;
	case '+': s++;
	}
	/* Compute n as a negative number to avoid overflow on LONG_MIN */
	while (isdigit(*s))
  415790:	8d 50 d0             	lea    edx,[rax-0x30]
  415793:	48 89 f9             	mov    rcx,rdi
	int neg=0;
  415796:	45 31 c9             	xor    r9d,r9d
	while (isdigit(*s))
  415799:	83 fa 09             	cmp    edx,0x9
  41579c:	77 55                	ja     4157f3 <atol+0x93>
	int neg=0;
  41579e:	45 31 c0             	xor    r8d,r8d
  4157a1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		n = 10*n - (*s++ - '0');
  4157a8:	83 e8 30             	sub    eax,0x30
  4157ab:	48 83 c1 01          	add    rcx,0x1
  4157af:	4b 8d 14 80          	lea    rdx,[r8+r8*4]
  4157b3:	48 63 f0             	movsxd rsi,eax
	while (isdigit(*s))
  4157b6:	0f be 01             	movsx  eax,BYTE PTR [rcx]
		n = 10*n - (*s++ - '0');
  4157b9:	48 01 d2             	add    rdx,rdx
  4157bc:	49 89 d0             	mov    r8,rdx
	while (isdigit(*s))
  4157bf:	8d 78 d0             	lea    edi,[rax-0x30]
		n = 10*n - (*s++ - '0');
  4157c2:	49 29 f0             	sub    r8,rsi
	while (isdigit(*s))
  4157c5:	83 ff 09             	cmp    edi,0x9
  4157c8:	76 de                	jbe    4157a8 <atol+0x48>
	return neg ? n : -n;
  4157ca:	48 29 d6             	sub    rsi,rdx
  4157cd:	45 85 c9             	test   r9d,r9d
  4157d0:	4c 0f 44 c6          	cmove  r8,rsi
}
  4157d4:	4c 89 c0             	mov    rax,r8
  4157d7:	c3                   	ret    
  4157d8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4157df:	00 
	while (isdigit(*s))
  4157e0:	0f be 47 01          	movsx  eax,BYTE PTR [rdi+0x1]
	case '+': s++;
  4157e4:	48 8d 4f 01          	lea    rcx,[rdi+0x1]
	int neg=0;
  4157e8:	45 31 c9             	xor    r9d,r9d
	while (isdigit(*s))
  4157eb:	8d 50 d0             	lea    edx,[rax-0x30]
  4157ee:	83 fa 09             	cmp    edx,0x9
  4157f1:	76 ab                	jbe    41579e <atol+0x3e>
  4157f3:	45 31 c0             	xor    r8d,r8d
}
  4157f6:	4c 89 c0             	mov    rax,r8
  4157f9:	c3                   	ret    
  4157fa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	while (isdigit(*s))
  415800:	0f be 47 01          	movsx  eax,BYTE PTR [rdi+0x1]
	case '+': s++;
  415804:	48 8d 4f 01          	lea    rcx,[rdi+0x1]
	while (isdigit(*s))
  415808:	8d 50 d0             	lea    edx,[rax-0x30]
  41580b:	83 fa 09             	cmp    edx,0x9
  41580e:	77 e3                	ja     4157f3 <atol+0x93>
	case '-': neg=1;
  415810:	41 b9 01 00 00 00    	mov    r9d,0x1
  415816:	eb 86                	jmp    41579e <atol+0x3e>
  415818:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41581f:	00 

0000000000415820 <strchr>:
#include <string.h>

char *strchr(const char *s, int c)
{
  415820:	f3 0f 1e fa          	endbr64 
	char *r = __strchrnul(s, c);
  415824:	49 bb ec 7b 04 00 00 	movabs r11,0x47bec
  41582b:	00 00 00 
  41582e:	48 8d 05 ef ff ff ff 	lea    rax,[rip+0xffffffffffffffef]        # 415824 <strchr+0x4>
{
  415835:	53                   	push   rbx
  415836:	89 f3                	mov    ebx,esi
	char *r = __strchrnul(s, c);
  415838:	48 ba 50 84 fb ff ff 	movabs rdx,0xfffffffffffb8450
  41583f:	ff ff ff 
  415842:	4c 01 d8             	add    rax,r11
  415845:	48 01 d0             	add    rax,rdx
  415848:	ff d0                	call   rax
	return *(unsigned char *)r == (unsigned char)c ? r : 0;
  41584a:	31 d2                	xor    edx,edx
  41584c:	38 18                	cmp    BYTE PTR [rax],bl
}
  41584e:	5b                   	pop    rbx
	return *(unsigned char *)r == (unsigned char)c ? r : 0;
  41584f:	48 0f 45 c2          	cmovne rax,rdx
}
  415853:	c3                   	ret    
  415854:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41585b:	00 00 00 
  41585e:	66 90                	xchg   ax,ax

0000000000415860 <__strchrnul>:
#define ONES ((size_t)-1/UCHAR_MAX)
#define HIGHS (ONES * (UCHAR_MAX/2+1))
#define HASZERO(x) ((x)-ONES & ~(x) & HIGHS)

char *__strchrnul(const char *s, int c)
{
  415860:	f3 0f 1e fa          	endbr64 
  415864:	49 bb ac 7b 04 00 00 	movabs r11,0x47bac
  41586b:	00 00 00 
  41586e:	41 57                	push   r15
	c = (unsigned char)c;
	if (!c) return (char *)s + strlen(s);
  415870:	89 f1                	mov    ecx,esi
  415872:	4c 8d 3d eb ff ff ff 	lea    r15,[rip+0xffffffffffffffeb]        # 415864 <__strchrnul+0x4>
{
  415879:	41 54                	push   r12
  41587b:	4d 01 df             	add    r15,r11
  41587e:	49 89 fc             	mov    r12,rdi
  415881:	48 83 ec 08          	sub    rsp,0x8
	if (!c) return (char *)s + strlen(s);
  415885:	81 e1 ff 00 00 00    	and    ecx,0xff
  41588b:	75 24                	jne    4158b1 <__strchrnul+0x51>
  41588d:	e9 d6 00 00 00       	jmp    415968 <__strchrnul+0x108>
  415892:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

#ifdef __GNUC__
	typedef size_t __attribute__((__may_alias__)) word;
	const word *w;
	for (; (uintptr_t)s % ALIGN; s++)
		if (!*s || *(unsigned char *)s == c) return (char *)s;
  415898:	41 0f b6 04 24       	movzx  eax,BYTE PTR [r12]
  41589d:	84 c0                	test   al,al
  41589f:	0f 84 b4 00 00 00    	je     415959 <__strchrnul+0xf9>
  4158a5:	39 c8                	cmp    eax,ecx
  4158a7:	0f 84 ac 00 00 00    	je     415959 <__strchrnul+0xf9>
	for (; (uintptr_t)s % ALIGN; s++)
  4158ad:	49 83 c4 01          	add    r12,0x1
  4158b1:	41 f6 c4 07          	test   r12b,0x7
  4158b5:	75 e1                	jne    415898 <__strchrnul+0x38>
	size_t k = ONES * c;
  4158b7:	48 bf 01 01 01 01 01 	movabs rdi,0x101010101010101
  4158be:	01 01 01 
  4158c1:	4c 63 c1             	movsxd r8,ecx
	for (w = (void *)s; !HASZERO(*w) && !HASZERO(*w^k); w++);
  4158c4:	49 8b 14 24          	mov    rdx,QWORD PTR [r12]
  4158c8:	49 b9 80 80 80 80 80 	movabs r9,0x8080808080808080
  4158cf:	80 80 80 
	size_t k = ONES * c;
  4158d2:	4c 0f af c7          	imul   r8,rdi
	for (w = (void *)s; !HASZERO(*w) && !HASZERO(*w^k); w++);
  4158d6:	48 89 d0             	mov    rax,rdx
  4158d9:	48 f7 d0             	not    rax
  4158dc:	4c 89 c6             	mov    rsi,r8
  4158df:	48 31 d6             	xor    rsi,rdx
  4158e2:	48 29 fa             	sub    rdx,rdi
  4158e5:	48 21 d0             	and    rax,rdx
  4158e8:	48 89 f2             	mov    rdx,rsi
  4158eb:	48 f7 d6             	not    rsi
  4158ee:	48 29 fa             	sub    rdx,rdi
  4158f1:	48 21 f2             	and    rdx,rsi
  4158f4:	48 09 d0             	or     rax,rdx
  4158f7:	4c 85 c8             	test   rax,r9
  4158fa:	75 54                	jne    415950 <__strchrnul+0xf0>
  4158fc:	48 bf ff fe fe fe fe 	movabs rdi,0xfefefefefefefeff
  415903:	fe fe fe 
  415906:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41590d:	00 00 00 
  415910:	49 8b 54 24 08       	mov    rdx,QWORD PTR [r12+0x8]
  415915:	49 83 c4 08          	add    r12,0x8
  415919:	48 89 d6             	mov    rsi,rdx
  41591c:	48 8d 04 3a          	lea    rax,[rdx+rdi*1]
  415920:	48 f7 d2             	not    rdx
  415923:	4c 31 c6             	xor    rsi,r8
  415926:	48 21 d0             	and    rax,rdx
  415929:	48 8d 14 3e          	lea    rdx,[rsi+rdi*1]
  41592d:	48 f7 d6             	not    rsi
  415930:	48 21 f2             	and    rdx,rsi
  415933:	48 09 d0             	or     rax,rdx
  415936:	4c 85 c8             	test   rax,r9
  415939:	74 d5                	je     415910 <__strchrnul+0xb0>
	s = (void *)w;
#endif
	for (; *s && *(unsigned char *)s != c; s++);
  41593b:	41 0f b6 04 24       	movzx  eax,BYTE PTR [r12]
  415940:	84 c0                	test   al,al
  415942:	74 15                	je     415959 <__strchrnul+0xf9>
  415944:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  415948:	39 c8                	cmp    eax,ecx
  41594a:	74 0d                	je     415959 <__strchrnul+0xf9>
  41594c:	49 83 c4 01          	add    r12,0x1
  415950:	41 0f b6 04 24       	movzx  eax,BYTE PTR [r12]
  415955:	84 c0                	test   al,al
  415957:	75 ef                	jne    415948 <__strchrnul+0xe8>
	return (char *)s;
}
  415959:	48 83 c4 08          	add    rsp,0x8
  41595d:	4c 89 e0             	mov    rax,r12
  415960:	41 5c                	pop    r12
  415962:	41 5f                	pop    r15
  415964:	c3                   	ret    
  415965:	0f 1f 00             	nop    DWORD PTR [rax]
	if (!c) return (char *)s + strlen(s);
  415968:	48 b8 c0 85 fb ff ff 	movabs rax,0xfffffffffffb85c0
  41596f:	ff ff ff 
  415972:	4c 01 f8             	add    rax,r15
  415975:	ff d0                	call   rax
}
  415977:	48 83 c4 08          	add    rsp,0x8
	if (!c) return (char *)s + strlen(s);
  41597b:	49 01 c4             	add    r12,rax
}
  41597e:	4c 89 e0             	mov    rax,r12
  415981:	41 5c                	pop    r12
  415983:	41 5f                	pop    r15
  415985:	c3                   	ret    
  415986:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41598d:	00 00 00 

0000000000415990 <strcmp>:
#include <string.h>

int strcmp(const char *l, const char *r)
{
  415990:	f3 0f 1e fa          	endbr64 
	for (; *l==*r && *l; l++, r++);
  415994:	0f b6 17             	movzx  edx,BYTE PTR [rdi]
  415997:	0f b6 0e             	movzx  ecx,BYTE PTR [rsi]
  41599a:	b8 01 00 00 00       	mov    eax,0x1
  41599f:	38 d1                	cmp    cl,dl
  4159a1:	74 16                	je     4159b9 <strcmp+0x29>
  4159a3:	eb 23                	jmp    4159c8 <strcmp+0x38>
  4159a5:	0f 1f 00             	nop    DWORD PTR [rax]
  4159a8:	0f b6 14 07          	movzx  edx,BYTE PTR [rdi+rax*1]
  4159ac:	48 83 c0 01          	add    rax,0x1
  4159b0:	0f b6 4c 06 ff       	movzx  ecx,BYTE PTR [rsi+rax*1-0x1]
  4159b5:	38 ca                	cmp    dl,cl
  4159b7:	75 0f                	jne    4159c8 <strcmp+0x38>
  4159b9:	84 d2                	test   dl,dl
  4159bb:	75 eb                	jne    4159a8 <strcmp+0x18>
  4159bd:	31 c0                	xor    eax,eax
	return *(unsigned char *)l - *(unsigned char *)r;
  4159bf:	29 c8                	sub    eax,ecx
}
  4159c1:	c3                   	ret    
  4159c2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	return *(unsigned char *)l - *(unsigned char *)r;
  4159c8:	0f b6 c2             	movzx  eax,dl
  4159cb:	29 c8                	sub    eax,ecx
}
  4159cd:	c3                   	ret    
  4159ce:	66 90                	xchg   ax,ax

00000000004159d0 <strlen>:
#define ONES ((size_t)-1/UCHAR_MAX)
#define HIGHS (ONES * (UCHAR_MAX/2+1))
#define HASZERO(x) ((x)-ONES & ~(x) & HIGHS)

size_t strlen(const char *s)
{
  4159d0:	f3 0f 1e fa          	endbr64 
	const char *a = s;
#ifdef __GNUC__
	typedef size_t __attribute__((__may_alias__)) word;
	const word *w;
	for (; (uintptr_t)s % ALIGN; s++) if (!*s) return s-a;
  4159d4:	48 89 f8             	mov    rax,rdi
  4159d7:	40 f6 c7 07          	test   dil,0x7
  4159db:	75 0b                	jne    4159e8 <strlen+0x18>
  4159dd:	eb 19                	jmp    4159f8 <strlen+0x28>
  4159df:	90                   	nop
  4159e0:	48 83 c0 01          	add    rax,0x1
  4159e4:	a8 07                	test   al,0x7
  4159e6:	74 10                	je     4159f8 <strlen+0x28>
  4159e8:	80 38 00             	cmp    BYTE PTR [rax],0x0
  4159eb:	75 f3                	jne    4159e0 <strlen+0x10>
	for (w = (const void *)s; !HASZERO(*w); w++);
	s = (const void *)w;
#endif
	for (; *s; s++);
	return s-a;
  4159ed:	48 29 f8             	sub    rax,rdi
}
  4159f0:	c3                   	ret    
  4159f1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (w = (const void *)s; !HASZERO(*w); w++);
  4159f8:	49 b8 ff fe fe fe fe 	movabs r8,0xfefefefefefefeff
  4159ff:	fe fe fe 
  415a02:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  415a05:	48 be 80 80 80 80 80 	movabs rsi,0x8080808080808080
  415a0c:	80 80 80 
  415a0f:	4a 8d 0c 02          	lea    rcx,[rdx+r8*1]
  415a13:	48 f7 d2             	not    rdx
  415a16:	48 21 ca             	and    rdx,rcx
  415a19:	48 85 f2             	test   rdx,rsi
  415a1c:	75 26                	jne    415a44 <strlen+0x74>
  415a1e:	66 90                	xchg   ax,ax
  415a20:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  415a24:	48 83 c0 08          	add    rax,0x8
  415a28:	4a 8d 0c 02          	lea    rcx,[rdx+r8*1]
  415a2c:	48 f7 d2             	not    rdx
  415a2f:	48 21 ca             	and    rdx,rcx
  415a32:	48 85 f2             	test   rdx,rsi
  415a35:	74 e9                	je     415a20 <strlen+0x50>
  415a37:	eb 0b                	jmp    415a44 <strlen+0x74>
  415a39:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (; *s; s++);
  415a40:	48 83 c0 01          	add    rax,0x1
  415a44:	80 38 00             	cmp    BYTE PTR [rax],0x0
  415a47:	75 f7                	jne    415a40 <strlen+0x70>
	return s-a;
  415a49:	48 29 f8             	sub    rax,rdi
}
  415a4c:	c3                   	ret    
  415a4d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000415a50 <strncmp>:
#include <string.h>

int strncmp(const char *_l, const char *_r, size_t n)
{
  415a50:	f3 0f 1e fa          	endbr64 
  415a54:	49 89 f9             	mov    r9,rdi
  415a57:	49 89 f2             	mov    r10,rsi
	const unsigned char *l=(void *)_l, *r=(void *)_r;
	if (!n--) return 0;
  415a5a:	31 c0                	xor    eax,eax
  415a5c:	48 85 d2             	test   rdx,rdx
  415a5f:	74 60                	je     415ac1 <strncmp+0x71>
	for (; *l && *r && n && *l == *r ; l++, r++, n--);
  415a61:	0f b6 07             	movzx  eax,BYTE PTR [rdi]
  415a64:	0f b6 3e             	movzx  edi,BYTE PTR [rsi]
  415a67:	84 c0                	test   al,al
  415a69:	74 5d                	je     415ac8 <strncmp+0x78>
  415a6b:	48 83 ea 01          	sub    rdx,0x1
  415a6f:	40 0f 95 c6          	setne  sil
  415a73:	40 84 ff             	test   dil,dil
  415a76:	0f 95 c1             	setne  cl
  415a79:	40 84 ce             	test   sil,cl
  415a7c:	74 41                	je     415abf <strncmp+0x6f>
  415a7e:	b9 01 00 00 00       	mov    ecx,0x1
  415a83:	40 38 f8             	cmp    al,dil
  415a86:	75 37                	jne    415abf <strncmp+0x6f>
  415a88:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  415a8f:	00 
  415a90:	41 0f b6 04 09       	movzx  eax,BYTE PTR [r9+rcx*1]
  415a95:	41 0f b6 3c 0a       	movzx  edi,BYTE PTR [r10+rcx*1]
  415a9a:	84 c0                	test   al,al
  415a9c:	74 2a                	je     415ac8 <strncmp+0x78>
  415a9e:	40 84 ff             	test   dil,dil
  415aa1:	40 0f 95 c6          	setne  sil
  415aa5:	40 38 f8             	cmp    al,dil
  415aa8:	41 0f 94 c0          	sete   r8b
  415aac:	44 21 c6             	and    esi,r8d
  415aaf:	48 39 ca             	cmp    rdx,rcx
  415ab2:	41 0f 95 c0          	setne  r8b
  415ab6:	48 83 c1 01          	add    rcx,0x1
  415aba:	44 84 c6             	test   sil,r8b
  415abd:	75 d1                	jne    415a90 <strncmp+0x40>
	return *l - *r;
  415abf:	29 f8                	sub    eax,edi
}
  415ac1:	c3                   	ret    
  415ac2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  415ac8:	31 c0                	xor    eax,eax
	return *l - *r;
  415aca:	29 f8                	sub    eax,edi
  415acc:	eb f3                	jmp    415ac1 <strncmp+0x71>
  415ace:	66 90                	xchg   ax,ax

0000000000415ad0 <strnlen>:
#include <string.h>

size_t strnlen(const char *s, size_t n)
{
  415ad0:	f3 0f 1e fa          	endbr64 
	const char *p = memchr(s, 0, n);
  415ad4:	49 bb 3c 79 04 00 00 	movabs r11,0x4793c
  415adb:	00 00 00 
{
  415ade:	41 57                	push   r15
  415ae0:	4c 8d 3d ed ff ff ff 	lea    r15,[rip+0xffffffffffffffed]        # 415ad4 <strnlen+0x4>
	const char *p = memchr(s, 0, n);
  415ae7:	48 89 f2             	mov    rdx,rsi
  415aea:	48 b8 d0 dc fb ff ff 	movabs rax,0xfffffffffffbdcd0
  415af1:	ff ff ff 
  415af4:	4d 01 df             	add    r15,r11
{
  415af7:	55                   	push   rbp
  415af8:	48 89 fd             	mov    rbp,rdi
  415afb:	53                   	push   rbx
	const char *p = memchr(s, 0, n);
  415afc:	4c 01 f8             	add    rax,r15
{
  415aff:	48 89 f3             	mov    rbx,rsi
	const char *p = memchr(s, 0, n);
  415b02:	31 f6                	xor    esi,esi
  415b04:	ff d0                	call   rax
	return p ? p-s : n;
  415b06:	48 89 c2             	mov    rdx,rax
  415b09:	48 29 ea             	sub    rdx,rbp
  415b0c:	48 85 c0             	test   rax,rax
  415b0f:	48 89 d8             	mov    rax,rbx
}
  415b12:	5b                   	pop    rbx
	return p ? p-s : n;
  415b13:	48 0f 45 c2          	cmovne rax,rdx
}
  415b17:	5d                   	pop    rbp
  415b18:	41 5f                	pop    r15
  415b1a:	c3                   	ret    
  415b1b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000415b20 <__init_tp>:
#include "syscall.h"

volatile int __thread_list_lock;

int __init_tp(void *p)
{
  415b20:	f3 0f 1e fa          	endbr64 
  415b24:	41 57                	push   r15
  415b26:	66 48 0f 6e c7       	movq   xmm0,rdi
  415b2b:	4c 8d 3d f2 ff ff ff 	lea    r15,[rip+0xfffffffffffffff2]        # 415b24 <__init_tp+0x4>
  415b32:	49 bb ec 78 04 00 00 	movabs r11,0x478ec
  415b39:	00 00 00 
  415b3c:	53                   	push   rbx
  415b3d:	4d 01 df             	add    r15,r11
  415b40:	48 89 fb             	mov    rbx,rdi
  415b43:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
	pthread_t td = p;
	td->self = td;
	int r = __set_thread_area(TP_ADJ(p));
  415b47:	48 b8 40 7a fb ff ff 	movabs rax,0xfffffffffffb7a40
  415b4e:	ff ff ff 
  415b51:	4c 01 f8             	add    rax,r15
{
  415b54:	48 83 ec 18          	sub    rsp,0x18
	td->self = td;
  415b58:	48 89 3f             	mov    QWORD PTR [rdi],rdi
  415b5b:	0f 29 04 24          	movaps XMMWORD PTR [rsp],xmm0
	int r = __set_thread_area(TP_ADJ(p));
  415b5f:	ff d0                	call   rax
	if (r < 0) return -1;
  415b61:	85 c0                	test   eax,eax
  415b63:	0f 88 a6 00 00 00    	js     415c0f <__init_tp+0xef>
	if (!r) libc.can_do_threads = 1;
  415b69:	0f 84 89 00 00 00    	je     415bf8 <__init_tp+0xd8>
	return __cos_syscall(n, a1, 0, 0, 0, 0, 0, 0);
  415b6f:	48 b8 58 4e 14 00 00 	movabs rax,0x144e58
  415b76:	00 00 00 
  415b79:	6a 00                	push   0x0
  415b7b:	31 d2                	xor    edx,edx
  415b7d:	31 c9                	xor    ecx,ecx
  415b7f:	49 8d 34 07          	lea    rsi,[r15+rax*1]
  415b83:	6a 00                	push   0x0
  415b85:	45 31 c9             	xor    r9d,r9d
  415b88:	45 31 c0             	xor    r8d,r8d
  415b8b:	48 b8 d0 ce fa ff ff 	movabs rax,0xfffffffffffaced0
  415b92:	ff ff ff 
	td->detach_state = DT_JOINABLE;
  415b95:	c7 43 40 01 00 00 00 	mov    DWORD PTR [rbx+0x40],0x1
  415b9c:	bf da 00 00 00       	mov    edi,0xda
  415ba1:	4c 01 f8             	add    rax,r15
  415ba4:	ff d0                	call   rax
	td->tid = __syscall(SYS_set_tid_address, &__thread_list_lock);
	td->locale = &libc.global_locale;
	td->robust_list.head = &td->robust_list.head;
	td->sysinfo = __sysinfo;
	td->next = td->prev = td;
  415ba6:	66 0f 6f 4c 24 10    	movdqa xmm1,XMMWORD PTR [rsp+0x10]
	td->tid = __syscall(SYS_set_tid_address, &__thread_list_lock);
  415bac:	89 43 38             	mov    DWORD PTR [rbx+0x38],eax
	td->locale = &libc.global_locale;
  415baf:	48 b8 70 4c 14 00 00 	movabs rax,0x144c70
  415bb6:	00 00 00 
  415bb9:	4c 01 f8             	add    rax,r15
	td->next = td->prev = td;
  415bbc:	0f 11 4b 10          	movups XMMWORD PTR [rbx+0x10],xmm1
	td->locale = &libc.global_locale;
  415bc0:	48 89 83 b0 00 00 00 	mov    QWORD PTR [rbx+0xb0],rax
	td->robust_list.head = &td->robust_list.head;
  415bc7:	48 8d 83 90 00 00 00 	lea    rax,[rbx+0x90]
  415bce:	48 89 83 90 00 00 00 	mov    QWORD PTR [rbx+0x90],rax
	td->sysinfo = __sysinfo;
  415bd5:	48 b8 10 4c 14 00 00 	movabs rax,0x144c10
  415bdc:	00 00 00 
  415bdf:	49 8b 04 07          	mov    rax,QWORD PTR [r15+rax*1]
  415be3:	48 89 43 20          	mov    QWORD PTR [rbx+0x20],rax
	return 0;
  415be7:	58                   	pop    rax
  415be8:	31 c0                	xor    eax,eax
  415bea:	5a                   	pop    rdx
}
  415beb:	48 83 c4 18          	add    rsp,0x18
  415bef:	5b                   	pop    rbx
  415bf0:	41 5f                	pop    r15
  415bf2:	c3                   	ret    
  415bf3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	if (!r) libc.can_do_threads = 1;
  415bf8:	48 b8 30 4c 14 00 00 	movabs rax,0x144c30
  415bff:	00 00 00 
  415c02:	41 c7 04 07 01 00 00 	mov    DWORD PTR [r15+rax*1],0x1
  415c09:	00 
  415c0a:	e9 60 ff ff ff       	jmp    415b6f <__init_tp+0x4f>
	if (r < 0) return -1;
  415c0f:	b8 ff ff ff ff       	mov    eax,0xffffffff
  415c14:	eb d5                	jmp    415beb <__init_tp+0xcb>
  415c16:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  415c1d:	00 00 00 

0000000000415c20 <__copy_tls>:
#define MIN_TLS_ALIGN offsetof(struct builtin_tls, pt)

static struct tls_module main_tls;

void *__copy_tls(unsigned char *mem)
{
  415c20:	f3 0f 1e fa          	endbr64 
  415c24:	49 bb ec 77 04 00 00 	movabs r11,0x477ec
  415c2b:	00 00 00 
  415c2e:	41 57                	push   r15
  415c30:	4c 8d 3d ed ff ff ff 	lea    r15,[rip+0xffffffffffffffed]        # 415c24 <__copy_tls+0x4>
  415c37:	41 56                	push   r14
  415c39:	4d 01 df             	add    r15,r11
		memcpy(mem + p->offset, p->image, p->len);
	}
#else
	dtv = (uintptr_t *)mem;

	mem += libc.tls_size - sizeof(struct pthread);
  415c3c:	49 be 30 4c 14 00 00 	movabs r14,0x144c30
  415c43:	00 00 00 
{
  415c46:	41 55                	push   r13
  415c48:	41 54                	push   r12
  415c4a:	55                   	push   rbp
  415c4b:	53                   	push   rbx
  415c4c:	48 83 ec 18          	sub    rsp,0x18
	mem += libc.tls_size - sizeof(struct pthread);
  415c50:	4b 8b 44 3e 20       	mov    rax,QWORD PTR [r14+r15*1+0x20]
	mem -= (uintptr_t)mem & (libc.tls_align-1);
  415c55:	4f 8b 44 3e 28       	mov    r8,QWORD PTR [r14+r15*1+0x28]
	td = (pthread_t)mem;

	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
  415c5a:	4b 8b 5c 3e 18       	mov    rbx,QWORD PTR [r14+r15*1+0x18]
{
  415c5f:	48 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],rdi
	mem += libc.tls_size - sizeof(struct pthread);
  415c64:	48 8d 84 07 20 ff ff 	lea    rax,[rdi+rax*1-0xe0]
  415c6b:	ff 
	mem -= (uintptr_t)mem & (libc.tls_align-1);
  415c6c:	49 f7 d8             	neg    r8
  415c6f:	49 21 c0             	and    r8,rax
  415c72:	4d 89 c5             	mov    r13,r8
	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
  415c75:	48 85 db             	test   rbx,rbx
  415c78:	74 3f                	je     415cb9 <__copy_tls+0x99>
  415c7a:	49 bc 4a 79 fb ff ff 	movabs r12,0xfffffffffffb794a
  415c81:	ff ff ff 
  415c84:	48 8d 6f 08          	lea    rbp,[rdi+0x8]
		dtv[i] = (uintptr_t)(mem - p->offset) + DTP_OFFSET;
		memcpy(mem - p->offset, p->image, p->len);
  415c88:	4d 01 fc             	add    r12,r15
  415c8b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		dtv[i] = (uintptr_t)(mem - p->offset) + DTP_OFFSET;
  415c90:	4c 89 e8             	mov    rax,r13
  415c93:	48 2b 43 28          	sub    rax,QWORD PTR [rbx+0x28]
		memcpy(mem - p->offset, p->image, p->len);
  415c97:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
  415c9b:	4c 89 ef             	mov    rdi,r13
		dtv[i] = (uintptr_t)(mem - p->offset) + DTP_OFFSET;
  415c9e:	48 89 45 00          	mov    QWORD PTR [rbp+0x0],rax
		memcpy(mem - p->offset, p->image, p->len);
  415ca2:	48 8b 53 10          	mov    rdx,QWORD PTR [rbx+0x10]
	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
  415ca6:	48 83 c5 08          	add    rbp,0x8
		memcpy(mem - p->offset, p->image, p->len);
  415caa:	48 2b 7b 28          	sub    rdi,QWORD PTR [rbx+0x28]
  415cae:	41 ff d4             	call   r12
	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
  415cb1:	48 8b 1b             	mov    rbx,QWORD PTR [rbx]
  415cb4:	48 85 db             	test   rbx,rbx
  415cb7:	75 d7                	jne    415c90 <__copy_tls+0x70>
	}
#endif
	dtv[0] = libc.tls_cnt;
  415cb9:	4b 8b 44 3e 30       	mov    rax,QWORD PTR [r14+r15*1+0x30]
  415cbe:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
  415cc3:	48 89 01             	mov    QWORD PTR [rcx],rax
	td->dtv = td->dtv_copy = dtv;
	return td;
}
  415cc6:	4c 89 e8             	mov    rax,r13
	td->dtv = td->dtv_copy = dtv;
  415cc9:	49 89 8d d8 00 00 00 	mov    QWORD PTR [r13+0xd8],rcx
  415cd0:	49 89 4d 08          	mov    QWORD PTR [r13+0x8],rcx
}
  415cd4:	48 83 c4 18          	add    rsp,0x18
  415cd8:	5b                   	pop    rbx
  415cd9:	5d                   	pop    rbp
  415cda:	41 5c                	pop    r12
  415cdc:	41 5d                	pop    r13
  415cde:	41 5e                	pop    r14
  415ce0:	41 5f                	pop    r15
  415ce2:	c3                   	ret    
  415ce3:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  415cea:	00 00 00 
  415ced:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000415cf0 <__init_tls>:
#endif

extern weak hidden const size_t _DYNAMIC[];

static void static_init_tls(size_t *aux)
{
  415cf0:	f3 0f 1e fa          	endbr64 
	size_t n;
	Phdr *phdr, *tls_phdr=0;
	size_t base = 0;
	void *mem;

	for (p=(void *)aux[AT_PHDR],n=aux[AT_PHNUM]; n; n--,p+=aux[AT_PHENT]) {
  415cf4:	49 bb 1c 77 04 00 00 	movabs r11,0x4771c
  415cfb:	00 00 00 
{
  415cfe:	41 57                	push   r15
  415d00:	4c 8d 3d ed ff ff ff 	lea    r15,[rip+0xffffffffffffffed]        # 415cf4 <__init_tls+0x4>
  415d07:	41 56                	push   r14
  415d09:	4d 01 df             	add    r15,r11
  415d0c:	41 55                	push   r13
  415d0e:	41 54                	push   r12
  415d10:	55                   	push   rbp
  415d11:	53                   	push   rbx
  415d12:	48 83 ec 38          	sub    rsp,0x38
	for (p=(void *)aux[AT_PHDR],n=aux[AT_PHNUM]; n; n--,p+=aux[AT_PHENT]) {
  415d16:	4c 8b 47 28          	mov    r8,QWORD PTR [rdi+0x28]
  415d1a:	4c 8b 5f 18          	mov    r11,QWORD PTR [rdi+0x18]
  415d1e:	4d 85 c0             	test   r8,r8
  415d21:	0f 84 a9 03 00 00    	je     4160d0 <__init_tls+0x3e0>
  415d27:	31 ed                	xor    ebp,ebp
	size_t base = 0;
  415d29:	31 d2                	xor    edx,edx
	Phdr *phdr, *tls_phdr=0;
  415d2b:	45 31 d2             	xor    r10d,r10d
	for (p=(void *)aux[AT_PHDR],n=aux[AT_PHNUM]; n; n--,p+=aux[AT_PHENT]) {
  415d2e:	48 8b 7f 20          	mov    rdi,QWORD PTR [rdi+0x20]
  415d32:	49 bc c0 ff ff ff ff 	movabs r12,0xffffffffffffffc0
  415d39:	ff ff ff 
  415d3c:	4c 89 d8             	mov    rax,r11
  415d3f:	48 bb b8 ec ff ff ff 	movabs rbx,0xffffffffffffecb8
  415d46:	ff ff ff 
  415d49:	4b 83 3c 3c 00       	cmp    QWORD PTR [r12+r15*1],0x0
  415d4e:	46 8b 0c 3b          	mov    r9d,DWORD PTR [rbx+r15*1]
  415d52:	75 2a                	jne    415d7e <__init_tls+0x8e>
  415d54:	e9 61 02 00 00       	jmp    415fba <__init_tls+0x2ca>
  415d59:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		phdr = (void *)p;
		if (phdr->p_type == PT_PHDR)
			base = aux[AT_PHDR] - phdr->p_vaddr;
		if (phdr->p_type == PT_DYNAMIC && _DYNAMIC)
  415d60:	83 f9 02             	cmp    ecx,0x2
  415d63:	0f 84 97 02 00 00    	je     416000 <__init_tls+0x310>
			base = (size_t)_DYNAMIC - phdr->p_vaddr;
		if (phdr->p_type == PT_TLS)
  415d69:	83 f9 07             	cmp    ecx,0x7
  415d6c:	0f 85 58 02 00 00    	jne    415fca <__init_tls+0x2da>
  415d72:	49 89 c2             	mov    r10,rax
	for (p=(void *)aux[AT_PHDR],n=aux[AT_PHNUM]; n; n--,p+=aux[AT_PHENT]) {
  415d75:	48 01 f8             	add    rax,rdi
  415d78:	49 83 e8 01          	sub    r8,0x1
  415d7c:	74 17                	je     415d95 <__init_tls+0xa5>
		if (phdr->p_type == PT_PHDR)
  415d7e:	8b 08                	mov    ecx,DWORD PTR [rax]
  415d80:	83 f9 06             	cmp    ecx,0x6
  415d83:	75 db                	jne    415d60 <__init_tls+0x70>
			base = aux[AT_PHDR] - phdr->p_vaddr;
  415d85:	4c 89 da             	mov    rdx,r11
  415d88:	48 2b 50 10          	sub    rdx,QWORD PTR [rax+0x10]
	for (p=(void *)aux[AT_PHDR],n=aux[AT_PHNUM]; n; n--,p+=aux[AT_PHENT]) {
  415d8c:	48 01 f8             	add    rax,rdi
  415d8f:	49 83 e8 01          	sub    r8,0x1
  415d93:	75 e9                	jne    415d7e <__init_tls+0x8e>
  415d95:	40 84 ed             	test   bpl,bpl
  415d98:	74 04                	je     415d9e <__init_tls+0xae>
  415d9a:	46 89 0c 3b          	mov    DWORD PTR [rbx+r15*1],r9d
			__default_stacksize =
				phdr->p_memsz < DEFAULT_STACK_MAX ?
				phdr->p_memsz : DEFAULT_STACK_MAX;
	}

	if (tls_phdr) {
  415d9e:	4d 85 d2             	test   r10,r10
  415da1:	0f 84 29 03 00 00    	je     4160d0 <__init_tls+0x3e0>
		main_tls.image = (void *)(base + tls_phdr->p_vaddr);
  415da7:	48 b8 b0 4c 14 00 00 	movabs rax,0x144cb0
  415dae:	00 00 00 
		main_tls.len = tls_phdr->p_filesz;
		main_tls.size = tls_phdr->p_memsz;
		main_tls.align = tls_phdr->p_align;
  415db1:	49 8b 72 30          	mov    rsi,QWORD PTR [r10+0x30]
		main_tls.image = (void *)(base + tls_phdr->p_vaddr);
  415db5:	49 03 52 10          	add    rdx,QWORD PTR [r10+0x10]
		libc.tls_cnt = 1;
  415db9:	49 bd 30 4c 14 00 00 	movabs r13,0x144c30
  415dc0:	00 00 00 
		libc.tls_head = &main_tls;
  415dc3:	4a 8d 0c 38          	lea    rcx,[rax+r15*1]
		main_tls.len = tls_phdr->p_filesz;
  415dc7:	f3 41 0f 6f 72 20    	movdqu xmm6,XMMWORD PTR [r10+0x20]
		main_tls.size = tls_phdr->p_memsz;
  415dcd:	49 8b 7a 28          	mov    rdi,QWORD PTR [r10+0x28]
		main_tls.image = (void *)(base + tls_phdr->p_vaddr);
  415dd1:	4a 89 54 38 08       	mov    QWORD PTR [rax+r15*1+0x8],rdx
		main_tls.align = tls_phdr->p_align;
  415dd6:	4a 89 74 38 20       	mov    QWORD PTR [rax+r15*1+0x20],rsi
		libc.tls_cnt = 1;
  415ddb:	4b c7 44 3d 30 01 00 	mov    QWORD PTR [r13+r15*1+0x30],0x1
  415de2:	00 00 
		libc.tls_head = &main_tls;
  415de4:	4b 89 4c 3d 18       	mov    QWORD PTR [r13+r15*1+0x18],rcx
		main_tls.len = tls_phdr->p_filesz;
  415de9:	42 0f 29 74 38 10    	movaps XMMWORD PTR [rax+r15*1+0x10],xmm6
	}

	main_tls.size += (-main_tls.size - (uintptr_t)main_tls.image)
  415def:	48 01 fa             	add    rdx,rdi
		& (main_tls.align-1);
  415df2:	48 8d 4e ff          	lea    rcx,[rsi-0x1]
	main_tls.size += (-main_tls.size - (uintptr_t)main_tls.image)
  415df6:	48 f7 da             	neg    rdx
		& (main_tls.align-1);
  415df9:	48 21 ca             	and    rdx,rcx
	main_tls.size += (-main_tls.size - (uintptr_t)main_tls.image)
  415dfc:	48 01 fa             	add    rdx,rdi
  415dff:	4a 89 54 38 18       	mov    QWORD PTR [rax+r15*1+0x18],rdx
#ifdef TLS_ABOVE_TP
	main_tls.offset = GAP_ABOVE_TP;
	main_tls.offset += (-GAP_ABOVE_TP + (uintptr_t)main_tls.image)
		& (main_tls.align-1);
#else
	main_tls.offset = main_tls.size;
  415e04:	4a 89 54 38 28       	mov    QWORD PTR [rax+r15*1+0x28],rdx
#endif
	if (main_tls.align < MIN_TLS_ALIGN) main_tls.align = MIN_TLS_ALIGN;
  415e09:	48 83 fe 07          	cmp    rsi,0x7
  415e0d:	0f 86 2d 02 00 00    	jbe    416040 <__init_tls+0x350>
  415e13:	48 8d 86 f7 00 00 00 	lea    rax,[rsi+0xf7]
	libc.tls_size = 2*sizeof(void *) + sizeof(struct pthread)
#ifdef TLS_ABOVE_TP
		+ main_tls.offset
#endif
		+ main_tls.size + main_tls.align
		+ MIN_TLS_ALIGN-1 & -MIN_TLS_ALIGN;
  415e1a:	48 01 c2             	add    rdx,rax
	libc.tls_size = 2*sizeof(void *) + sizeof(struct pthread)
  415e1d:	66 48 0f 6e de       	movq   xmm3,rsi
			MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);
		/* -4095...-1 cast to void * will crash on dereference anyway,
		 * so don't bloat the init code checking for error codes and
		 * explicitly calling a_crash(). */
	} else {
		mem = builtin_tls;
  415e22:	48 b8 f0 4c 14 00 00 	movabs rax,0x144cf0
  415e29:	00 00 00 
		+ MIN_TLS_ALIGN-1 & -MIN_TLS_ALIGN;
  415e2c:	48 83 e2 f8          	and    rdx,0xfffffffffffffff8
		mem = builtin_tls;
  415e30:	4c 01 f8             	add    rax,r15
	libc.tls_size = 2*sizeof(void *) + sizeof(struct pthread)
  415e33:	66 48 0f 6e c2       	movq   xmm0,rdx
		mem = builtin_tls;
  415e38:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
	libc.tls_size = 2*sizeof(void *) + sizeof(struct pthread)
  415e3d:	66 0f 6c c3          	punpcklqdq xmm0,xmm3
  415e41:	43 0f 11 44 3d 20    	movups XMMWORD PTR [r13+r15*1+0x20],xmm0
	if (libc.tls_size > sizeof builtin_tls) {
  415e47:	48 81 fa 68 01 00 00 	cmp    rdx,0x168
  415e4e:	0f 87 2c 02 00 00    	ja     416080 <__init_tls+0x390>
	mem += libc.tls_size - sizeof(struct pthread);
  415e54:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
  415e59:	4b 8b 5c 3d 18       	mov    rbx,QWORD PTR [r13+r15*1+0x18]
  415e5e:	48 bd 4a 79 fb ff ff 	movabs rbp,0xfffffffffffb794a
  415e65:	ff ff ff 
		memcpy(mem - p->offset, p->image, p->len);
  415e68:	4c 01 fd             	add    rbp,r15
	mem += libc.tls_size - sizeof(struct pthread);
  415e6b:	4c 8d b4 10 20 ff ff 	lea    r14,[rax+rdx*1-0xe0]
  415e72:	ff 
	mem -= (uintptr_t)mem & (libc.tls_align-1);
  415e73:	66 48 0f 6e f8       	movq   xmm7,rax
  415e78:	4c 8d 60 08          	lea    r12,[rax+0x8]
  415e7c:	4c 21 f1             	and    rcx,r14
  415e7f:	49 29 ce             	sub    r14,rcx
  415e82:	66 49 0f 6e ce       	movq   xmm1,r14
  415e87:	66 49 0f 6e d6       	movq   xmm2,r14
  415e8c:	66 0f 6c c9          	punpcklqdq xmm1,xmm1
  415e90:	66 0f 6c d7          	punpcklqdq xmm2,xmm7
  415e94:	0f 29 4c 24 20       	movaps XMMWORD PTR [rsp+0x20],xmm1
  415e99:	0f 29 54 24 10       	movaps XMMWORD PTR [rsp+0x10],xmm2
	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
  415e9e:	48 85 db             	test   rbx,rbx
  415ea1:	74 2d                	je     415ed0 <__init_tls+0x1e0>
  415ea3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		dtv[i] = (uintptr_t)(mem - p->offset) + DTP_OFFSET;
  415ea8:	4c 89 f0             	mov    rax,r14
  415eab:	48 2b 43 28          	sub    rax,QWORD PTR [rbx+0x28]
		memcpy(mem - p->offset, p->image, p->len);
  415eaf:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
  415eb3:	4c 89 f7             	mov    rdi,r14
		dtv[i] = (uintptr_t)(mem - p->offset) + DTP_OFFSET;
  415eb6:	49 89 04 24          	mov    QWORD PTR [r12],rax
		memcpy(mem - p->offset, p->image, p->len);
  415eba:	48 8b 53 10          	mov    rdx,QWORD PTR [rbx+0x10]
	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
  415ebe:	49 83 c4 08          	add    r12,0x8
		memcpy(mem - p->offset, p->image, p->len);
  415ec2:	48 2b 7b 28          	sub    rdi,QWORD PTR [rbx+0x28]
  415ec6:	ff d5                	call   rbp
	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
  415ec8:	48 8b 1b             	mov    rbx,QWORD PTR [rbx]
  415ecb:	48 85 db             	test   rbx,rbx
  415ece:	75 d8                	jne    415ea8 <__init_tls+0x1b8>
	dtv[0] = libc.tls_cnt;
  415ed0:	4b 8b 44 3d 30       	mov    rax,QWORD PTR [r13+r15*1+0x30]
  415ed5:	48 8b 74 24 08       	mov    rsi,QWORD PTR [rsp+0x8]
	int r = __set_thread_area(TP_ADJ(p));
  415eda:	4c 89 f7             	mov    rdi,r14
	td->self = td;
  415edd:	66 0f 6f 64 24 10    	movdqa xmm4,XMMWORD PTR [rsp+0x10]
	dtv[0] = libc.tls_cnt;
  415ee3:	48 89 06             	mov    QWORD PTR [rsi],rax
	int r = __set_thread_area(TP_ADJ(p));
  415ee6:	48 b8 40 7a fb ff ff 	movabs rax,0xfffffffffffb7a40
  415eed:	ff ff ff 
  415ef0:	4c 01 f8             	add    rax,r15
	td->dtv = td->dtv_copy = dtv;
  415ef3:	49 89 b6 d8 00 00 00 	mov    QWORD PTR [r14+0xd8],rsi
	td->self = td;
  415efa:	41 0f 11 26          	movups XMMWORD PTR [r14],xmm4
	int r = __set_thread_area(TP_ADJ(p));
  415efe:	ff d0                	call   rax
	if (r < 0) return -1;
  415f00:	85 c0                	test   eax,eax
  415f02:	0f 88 66 01 00 00    	js     41606e <__init_tls+0x37e>
	if (!r) libc.can_do_threads = 1;
  415f08:	0f 84 52 01 00 00    	je     416060 <__init_tls+0x370>
	td->detach_state = DT_JOINABLE;
  415f0e:	41 c7 46 40 01 00 00 	mov    DWORD PTR [r14+0x40],0x1
  415f15:	00 
  415f16:	31 d2                	xor    edx,edx
  415f18:	45 31 c9             	xor    r9d,r9d
  415f1b:	45 31 c0             	xor    r8d,r8d
  415f1e:	48 b8 58 4e 14 00 00 	movabs rax,0x144e58
  415f25:	00 00 00 
  415f28:	6a 00                	push   0x0
  415f2a:	31 c9                	xor    ecx,ecx
  415f2c:	bf da 00 00 00       	mov    edi,0xda
  415f31:	49 8d 34 07          	lea    rsi,[r15+rax*1]
  415f35:	6a 00                	push   0x0
  415f37:	48 b8 d0 ce fa ff ff 	movabs rax,0xfffffffffffaced0
  415f3e:	ff ff ff 
  415f41:	4c 01 f8             	add    rax,r15
  415f44:	ff d0                	call   rax
	td->next = td->prev = td;
  415f46:	66 0f 6f 6c 24 30    	movdqa xmm5,XMMWORD PTR [rsp+0x30]
	td->tid = __syscall(SYS_set_tid_address, &__thread_list_lock);
  415f4c:	41 89 46 38          	mov    DWORD PTR [r14+0x38],eax
	td->locale = &libc.global_locale;
  415f50:	48 b8 70 4c 14 00 00 	movabs rax,0x144c70
  415f57:	00 00 00 
  415f5a:	4c 01 f8             	add    rax,r15
	td->next = td->prev = td;
  415f5d:	41 0f 11 6e 10       	movups XMMWORD PTR [r14+0x10],xmm5
	td->locale = &libc.global_locale;
  415f62:	49 89 86 b0 00 00 00 	mov    QWORD PTR [r14+0xb0],rax
	td->robust_list.head = &td->robust_list.head;
  415f69:	49 8d 86 90 00 00 00 	lea    rax,[r14+0x90]
  415f70:	49 89 86 90 00 00 00 	mov    QWORD PTR [r14+0x90],rax
	td->sysinfo = __sysinfo;
  415f77:	48 b8 10 4c 14 00 00 	movabs rax,0x144c10
  415f7e:	00 00 00 
  415f81:	49 8b 04 07          	mov    rax,QWORD PTR [r15+rax*1]
  415f85:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
	td->next = td->prev = td;
  415f89:	58                   	pop    rax
  415f8a:	5a                   	pop    rdx
	}

	/* Failure to initialize thread pointer is always fatal. */
	if (__init_tp(__copy_tls(mem)) < 0)
		a_crash();
}
  415f8b:	48 83 c4 38          	add    rsp,0x38
  415f8f:	5b                   	pop    rbx
  415f90:	5d                   	pop    rbp
  415f91:	41 5c                	pop    r12
  415f93:	41 5d                	pop    r13
  415f95:	41 5e                	pop    r14
  415f97:	41 5f                	pop    r15
  415f99:	c3                   	ret    
  415f9a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
		if (phdr->p_type == PT_DYNAMIC && _DYNAMIC)
  415fa0:	83 f9 02             	cmp    ecx,0x2
  415fa3:	74 08                	je     415fad <__init_tls+0x2bd>
		if (phdr->p_type == PT_TLS)
  415fa5:	83 f9 07             	cmp    ecx,0x7
  415fa8:	75 63                	jne    41600d <__init_tls+0x31d>
  415faa:	49 89 c2             	mov    r10,rax
	for (p=(void *)aux[AT_PHDR],n=aux[AT_PHNUM]; n; n--,p+=aux[AT_PHENT]) {
  415fad:	48 01 f8             	add    rax,rdi
  415fb0:	49 83 e8 01          	sub    r8,0x1
  415fb4:	0f 84 db fd ff ff    	je     415d95 <__init_tls+0xa5>
		if (phdr->p_type == PT_PHDR)
  415fba:	8b 08                	mov    ecx,DWORD PTR [rax]
  415fbc:	83 f9 06             	cmp    ecx,0x6
  415fbf:	75 df                	jne    415fa0 <__init_tls+0x2b0>
			base = aux[AT_PHDR] - phdr->p_vaddr;
  415fc1:	4c 89 da             	mov    rdx,r11
  415fc4:	48 2b 50 10          	sub    rdx,QWORD PTR [rax+0x10]
		if (phdr->p_type == PT_GNU_STACK &&
  415fc8:	eb e3                	jmp    415fad <__init_tls+0x2bd>
  415fca:	81 f9 51 e5 74 64    	cmp    ecx,0x6474e551
  415fd0:	0f 85 9f fd ff ff    	jne    415d75 <__init_tls+0x85>
		    phdr->p_memsz > __default_stacksize)
  415fd6:	48 8b 48 28          	mov    rcx,QWORD PTR [rax+0x28]
  415fda:	44 89 ce             	mov    esi,r9d
		if (phdr->p_type == PT_GNU_STACK &&
  415fdd:	48 39 f1             	cmp    rcx,rsi
  415fe0:	0f 86 8f fd ff ff    	jbe    415d75 <__init_tls+0x85>
			__default_stacksize =
  415fe6:	41 b9 00 00 80 00    	mov    r9d,0x800000
  415fec:	bd 01 00 00 00       	mov    ebp,0x1
  415ff1:	4c 39 c9             	cmp    rcx,r9
  415ff4:	4c 0f 46 c9          	cmovbe r9,rcx
  415ff8:	e9 78 fd ff ff       	jmp    415d75 <__init_tls+0x85>
  415ffd:	0f 1f 00             	nop    DWORD PTR [rax]
			base = (size_t)_DYNAMIC - phdr->p_vaddr;
  416000:	4b 8b 14 3c          	mov    rdx,QWORD PTR [r12+r15*1]
  416004:	48 2b 50 10          	sub    rdx,QWORD PTR [rax+0x10]
		if (phdr->p_type == PT_GNU_STACK &&
  416008:	e9 68 fd ff ff       	jmp    415d75 <__init_tls+0x85>
  41600d:	81 f9 51 e5 74 64    	cmp    ecx,0x6474e551
  416013:	75 98                	jne    415fad <__init_tls+0x2bd>
		    phdr->p_memsz > __default_stacksize)
  416015:	48 8b 48 28          	mov    rcx,QWORD PTR [rax+0x28]
  416019:	44 89 ce             	mov    esi,r9d
		if (phdr->p_type == PT_GNU_STACK &&
  41601c:	48 39 ce             	cmp    rsi,rcx
  41601f:	73 8c                	jae    415fad <__init_tls+0x2bd>
			__default_stacksize =
  416021:	41 b9 00 00 80 00    	mov    r9d,0x800000
  416027:	bd 01 00 00 00       	mov    ebp,0x1
  41602c:	4c 39 c9             	cmp    rcx,r9
  41602f:	4c 0f 46 c9          	cmovbe r9,rcx
  416033:	e9 75 ff ff ff       	jmp    415fad <__init_tls+0x2bd>
  416038:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41603f:	00 
	if (main_tls.align < MIN_TLS_ALIGN) main_tls.align = MIN_TLS_ALIGN;
  416040:	4a c7 44 38 20 08 00 	mov    QWORD PTR [rax+r15*1+0x20],0x8
  416047:	00 00 
  416049:	b9 07 00 00 00       	mov    ecx,0x7
  41604e:	b8 ff 00 00 00       	mov    eax,0xff
  416053:	be 08 00 00 00       	mov    esi,0x8
  416058:	e9 bd fd ff ff       	jmp    415e1a <__init_tls+0x12a>
  41605d:	0f 1f 00             	nop    DWORD PTR [rax]
	if (!r) libc.can_do_threads = 1;
  416060:	43 c7 44 3d 00 01 00 	mov    DWORD PTR [r13+r15*1+0x0],0x1
  416067:	00 00 
  416069:	e9 a0 fe ff ff       	jmp    415f0e <__init_tls+0x21e>
  41606e:	f4                   	hlt    
}
  41606f:	48 83 c4 38          	add    rsp,0x38
  416073:	5b                   	pop    rbx
  416074:	5d                   	pop    rbp
  416075:	41 5c                	pop    r12
  416077:	41 5d                	pop    r13
  416079:	41 5e                	pop    r14
  41607b:	41 5f                	pop    r15
  41607d:	c3                   	ret    
  41607e:	66 90                	xchg   ax,ax
	return __cos_syscall(n, a1, a2, a3, a4, a5, 0, 0);
}

static __inline long __syscall6(long n, long a1, long a2, long a3, long a4, long a5, long a6)
{
	return __cos_syscall(n, a1, a2, a3, a4, a5, a6, 0);
  416080:	6a 00                	push   0x0
  416082:	b9 03 00 00 00       	mov    ecx,0x3
  416087:	31 f6                	xor    esi,esi
  416089:	bf 09 00 00 00       	mov    edi,0x9
  41608e:	6a 00                	push   0x0
  416090:	49 c7 c1 ff ff ff ff 	mov    r9,0xffffffffffffffff
  416097:	48 b8 d0 ce fa ff ff 	movabs rax,0xfffffffffffaced0
  41609e:	ff ff ff 
  4160a1:	41 b8 22 00 00 00    	mov    r8d,0x22
  4160a7:	4c 01 f8             	add    rax,r15
  4160aa:	ff d0                	call   rax
	mem += libc.tls_size - sizeof(struct pthread);
  4160ac:	4b 8b 54 3d 20       	mov    rdx,QWORD PTR [r13+r15*1+0x20]
  4160b1:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
	mem -= (uintptr_t)mem & (libc.tls_align-1);
  4160b6:	4b 8b 44 3d 28       	mov    rax,QWORD PTR [r13+r15*1+0x28]
  4160bb:	5e                   	pop    rsi
  4160bc:	5f                   	pop    rdi
  4160bd:	48 8d 48 ff          	lea    rcx,[rax-0x1]
  4160c1:	e9 8e fd ff ff       	jmp    415e54 <__init_tls+0x164>
  4160c6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4160cd:	00 00 00 
	main_tls.size += (-main_tls.size - (uintptr_t)main_tls.image)
  4160d0:	48 b8 b0 4c 14 00 00 	movabs rax,0x144cb0
  4160d7:	00 00 00 
  4160da:	49 bd 30 4c 14 00 00 	movabs r13,0x144c30
  4160e1:	00 00 00 
  4160e4:	4a 8b 7c 38 18       	mov    rdi,QWORD PTR [rax+r15*1+0x18]
  4160e9:	4a 8b 54 38 08       	mov    rdx,QWORD PTR [rax+r15*1+0x8]
		& (main_tls.align-1);
  4160ee:	4a 8b 74 38 20       	mov    rsi,QWORD PTR [rax+r15*1+0x20]
  4160f3:	e9 f7 fc ff ff       	jmp    415def <__init_tls+0xff>
  4160f8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4160ff:	00 

0000000000416100 <__errno_location>:
#include <errno.h>
#include "pthread_impl.h"

int *__errno_location(void)
{
  416100:	f3 0f 1e fa          	endbr64 
	static int e;
	return &e;
  416104:	49 bb 0c 73 04 00 00 	movabs r11,0x4730c
  41610b:	00 00 00 
  41610e:	48 8d 05 ef ff ff ff 	lea    rax,[rip+0xffffffffffffffef]        # 416104 <__errno_location+0x4>
  416115:	48 ba 5c 4e 14 00 00 	movabs rdx,0x144e5c
  41611c:	00 00 00 
  41611f:	4c 01 d8             	add    rax,r11
  416122:	48 01 d0             	add    rax,rdx
}
  416125:	c3                   	ret    
  416126:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41612d:	00 00 00 

0000000000416130 <_Exit>:
#include <stdlib.h>
#include "syscall.h"

_Noreturn void _Exit(int ec)
{
  416130:	f3 0f 1e fa          	endbr64 
  416134:	41 57                	push   r15
  416136:	4c 8d 3d f7 ff ff ff 	lea    r15,[rip+0xfffffffffffffff7]        # 416134 <_Exit+0x4>
	return __cos_syscall(n, a1, 0, 0, 0, 0, 0, 0);
  41613d:	31 c9                	xor    ecx,ecx
  41613f:	45 31 c9             	xor    r9d,r9d
  416142:	49 bb dc 72 04 00 00 	movabs r11,0x472dc
  416149:	00 00 00 
  41614c:	55                   	push   rbp
	__syscall(SYS_exit_group, ec);
  41614d:	48 63 ef             	movsxd rbp,edi
  416150:	45 31 c0             	xor    r8d,r8d
{
  416153:	53                   	push   rbx
  416154:	4d 01 df             	add    r15,r11
  416157:	48 89 ee             	mov    rsi,rbp
  41615a:	31 d2                	xor    edx,edx
  41615c:	48 bb d0 ce fa ff ff 	movabs rbx,0xfffffffffffaced0
  416163:	ff ff ff 
  416166:	6a 00                	push   0x0
  416168:	bf e7 00 00 00       	mov    edi,0xe7
  41616d:	6a 00                	push   0x0
  41616f:	4c 01 fb             	add    rbx,r15
  416172:	ff d3                	call   rbx
  416174:	59                   	pop    rcx
  416175:	5e                   	pop    rsi
  416176:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41617d:	00 00 00 
  416180:	6a 00                	push   0x0
  416182:	31 d2                	xor    edx,edx
  416184:	45 31 c9             	xor    r9d,r9d
  416187:	45 31 c0             	xor    r8d,r8d
  41618a:	6a 00                	push   0x0
  41618c:	31 c9                	xor    ecx,ecx
  41618e:	48 89 ee             	mov    rsi,rbp
  416191:	bf 3c 00 00 00       	mov    edi,0x3c
  416196:	ff d3                	call   rbx
  416198:	58                   	pop    rax
  416199:	5a                   	pop    rdx
  41619a:	eb e4                	jmp    416180 <_Exit+0x50>
  41619c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

00000000004161a0 <pop_arg>:
	long double f;
	void *p;
};

static void pop_arg(union arg *arg, int type, va_list *ap)
{
  4161a0:	f3 0f 1e fa          	endbr64 
	switch (type) {
  4161a4:	83 ee 09             	sub    esi,0x9
{
  4161a7:	48 89 d0             	mov    rax,rdx
	switch (type) {
  4161aa:	83 fe 11             	cmp    esi,0x11
  4161ad:	77 49                	ja     4161f8 <pop_arg+0x58>
  4161af:	48 8d 15 1a 90 00 00 	lea    rdx,[rip+0x901a]        # 41f1d0 <CSWTCH.186+0x760>
  4161b6:	48 03 14 f2          	add    rdx,QWORD PTR [rdx+rsi*8]
  4161ba:	3e ff e2             	notrack jmp rdx
  4161bd:	0f 1f 00             	nop    DWORD PTR [rax]
	break; case LLONG:	arg->i = va_arg(*ap, long long);
	break; case SIZET:	arg->i = va_arg(*ap, size_t);
	break; case IMAX:	arg->i = va_arg(*ap, intmax_t);
	break; case UMAX:	arg->i = va_arg(*ap, uintmax_t);
	break; case PDIFF:	arg->i = va_arg(*ap, ptrdiff_t);
	break; case UIPTR:	arg->i = (uintptr_t)va_arg(*ap, void *);
  4161c0:	8b 10                	mov    edx,DWORD PTR [rax]
  4161c2:	83 fa 2f             	cmp    edx,0x2f
  4161c5:	77 39                	ja     416200 <pop_arg+0x60>
  4161c7:	89 d1                	mov    ecx,edx
  4161c9:	83 c2 08             	add    edx,0x8
  4161cc:	48 03 48 10          	add    rcx,QWORD PTR [rax+0x10]
  4161d0:	89 10                	mov    DWORD PTR [rax],edx
  4161d2:	48 8b 01             	mov    rax,QWORD PTR [rcx]
  4161d5:	48 89 07             	mov    QWORD PTR [rdi],rax
	break; case DBL:	arg->f = va_arg(*ap, double);
  4161d8:	c3                   	ret    
  4161d9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	break; case LDBL:	arg->f = va_arg(*ap, long double);
  4161e0:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  4161e4:	48 8d 51 0f          	lea    rdx,[rcx+0xf]
  4161e8:	48 83 e2 f0          	and    rdx,0xfffffffffffffff0
  4161ec:	48 8d 4a 10          	lea    rcx,[rdx+0x10]
  4161f0:	48 89 48 08          	mov    QWORD PTR [rax+0x8],rcx
  4161f4:	db 2a                	fld    TBYTE PTR [rdx]
  4161f6:	db 3f                	fstp   TBYTE PTR [rdi]
	}
}
  4161f8:	c3                   	ret    
  4161f9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	break; case UIPTR:	arg->i = (uintptr_t)va_arg(*ap, void *);
  416200:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  416204:	48 8d 51 08          	lea    rdx,[rcx+0x8]
  416208:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  41620c:	48 8b 01             	mov    rax,QWORD PTR [rcx]
  41620f:	48 89 07             	mov    QWORD PTR [rdi],rax
	break; case DBL:	arg->f = va_arg(*ap, double);
  416212:	c3                   	ret    
  416213:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	break; case USHORT:	arg->i = (unsigned short)va_arg(*ap, int);
  416218:	8b 10                	mov    edx,DWORD PTR [rax]
  41621a:	83 fa 2f             	cmp    edx,0x2f
  41621d:	0f 87 55 01 00 00    	ja     416378 <pop_arg+0x1d8>
  416223:	89 d1                	mov    ecx,edx
  416225:	83 c2 08             	add    edx,0x8
  416228:	48 03 48 10          	add    rcx,QWORD PTR [rax+0x10]
  41622c:	89 10                	mov    DWORD PTR [rax],edx
  41622e:	0f b7 01             	movzx  eax,WORD PTR [rcx]
  416231:	48 89 07             	mov    QWORD PTR [rdi],rax
	break; case CHAR:	arg->i = (signed char)va_arg(*ap, int);
  416234:	c3                   	ret    
  416235:	0f 1f 00             	nop    DWORD PTR [rax]
	break; case DBL:	arg->f = va_arg(*ap, double);
  416238:	8b 50 04             	mov    edx,DWORD PTR [rax+0x4]
  41623b:	81 fa af 00 00 00    	cmp    edx,0xaf
  416241:	0f 87 19 01 00 00    	ja     416360 <pop_arg+0x1c0>
  416247:	89 d1                	mov    ecx,edx
  416249:	83 c2 10             	add    edx,0x10
  41624c:	48 03 48 10          	add    rcx,QWORD PTR [rax+0x10]
  416250:	89 50 04             	mov    DWORD PTR [rax+0x4],edx
  416253:	dd 01                	fld    QWORD PTR [rcx]
  416255:	db 3f                	fstp   TBYTE PTR [rdi]
	break; case LDBL:	arg->f = va_arg(*ap, long double);
  416257:	c3                   	ret    
  416258:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41625f:	00 
	break; case INT:	arg->i = va_arg(*ap, int);
  416260:	8b 10                	mov    edx,DWORD PTR [rax]
  416262:	83 fa 2f             	cmp    edx,0x2f
  416265:	0f 87 dd 00 00 00    	ja     416348 <pop_arg+0x1a8>
  41626b:	89 d1                	mov    ecx,edx
  41626d:	83 c2 08             	add    edx,0x8
  416270:	48 03 48 10          	add    rcx,QWORD PTR [rax+0x10]
  416274:	89 10                	mov    DWORD PTR [rax],edx
  416276:	48 63 01             	movsxd rax,DWORD PTR [rcx]
  416279:	48 89 07             	mov    QWORD PTR [rdi],rax
	break; case UINT:	arg->i = va_arg(*ap, unsigned int);
  41627c:	c3                   	ret    
  41627d:	0f 1f 00             	nop    DWORD PTR [rax]
  416280:	8b 10                	mov    edx,DWORD PTR [rax]
  416282:	83 fa 2f             	cmp    edx,0x2f
  416285:	0f 87 a5 00 00 00    	ja     416330 <pop_arg+0x190>
  41628b:	89 d1                	mov    ecx,edx
  41628d:	83 c2 08             	add    edx,0x8
  416290:	48 03 48 10          	add    rcx,QWORD PTR [rax+0x10]
  416294:	89 10                	mov    DWORD PTR [rax],edx
  416296:	8b 01                	mov    eax,DWORD PTR [rcx]
  416298:	48 89 07             	mov    QWORD PTR [rdi],rax
	break; case LONG:	arg->i = va_arg(*ap, long);
  41629b:	c3                   	ret    
  41629c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	break; case UCHAR:	arg->i = (unsigned char)va_arg(*ap, int);
  4162a0:	8b 10                	mov    edx,DWORD PTR [rax]
  4162a2:	83 fa 2f             	cmp    edx,0x2f
  4162a5:	77 79                	ja     416320 <pop_arg+0x180>
  4162a7:	89 d1                	mov    ecx,edx
  4162a9:	83 c2 08             	add    edx,0x8
  4162ac:	48 03 48 10          	add    rcx,QWORD PTR [rax+0x10]
  4162b0:	89 10                	mov    DWORD PTR [rax],edx
  4162b2:	0f b6 01             	movzx  eax,BYTE PTR [rcx]
  4162b5:	48 89 07             	mov    QWORD PTR [rdi],rax
	break; case LLONG:	arg->i = va_arg(*ap, long long);
  4162b8:	c3                   	ret    
  4162b9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	break; case CHAR:	arg->i = (signed char)va_arg(*ap, int);
  4162c0:	8b 10                	mov    edx,DWORD PTR [rax]
  4162c2:	83 fa 2f             	cmp    edx,0x2f
  4162c5:	77 49                	ja     416310 <pop_arg+0x170>
  4162c7:	89 d1                	mov    ecx,edx
  4162c9:	83 c2 08             	add    edx,0x8
  4162cc:	48 03 48 10          	add    rcx,QWORD PTR [rax+0x10]
  4162d0:	89 10                	mov    DWORD PTR [rax],edx
  4162d2:	48 0f be 01          	movsx  rax,BYTE PTR [rcx]
  4162d6:	48 89 07             	mov    QWORD PTR [rdi],rax
	break; case UCHAR:	arg->i = (unsigned char)va_arg(*ap, int);
  4162d9:	c3                   	ret    
  4162da:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	break; case SHORT:	arg->i = (short)va_arg(*ap, int);
  4162e0:	8b 10                	mov    edx,DWORD PTR [rax]
  4162e2:	83 fa 2f             	cmp    edx,0x2f
  4162e5:	77 19                	ja     416300 <pop_arg+0x160>
  4162e7:	89 d1                	mov    ecx,edx
  4162e9:	83 c2 08             	add    edx,0x8
  4162ec:	48 03 48 10          	add    rcx,QWORD PTR [rax+0x10]
  4162f0:	89 10                	mov    DWORD PTR [rax],edx
  4162f2:	48 0f bf 01          	movsx  rax,WORD PTR [rcx]
  4162f6:	48 89 07             	mov    QWORD PTR [rdi],rax
	break; case USHORT:	arg->i = (unsigned short)va_arg(*ap, int);
  4162f9:	c3                   	ret    
  4162fa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	break; case SHORT:	arg->i = (short)va_arg(*ap, int);
  416300:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  416304:	48 8d 51 08          	lea    rdx,[rcx+0x8]
  416308:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  41630c:	eb e4                	jmp    4162f2 <pop_arg+0x152>
  41630e:	66 90                	xchg   ax,ax
	break; case CHAR:	arg->i = (signed char)va_arg(*ap, int);
  416310:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  416314:	48 8d 51 08          	lea    rdx,[rcx+0x8]
  416318:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  41631c:	eb b4                	jmp    4162d2 <pop_arg+0x132>
  41631e:	66 90                	xchg   ax,ax
	break; case UCHAR:	arg->i = (unsigned char)va_arg(*ap, int);
  416320:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  416324:	48 8d 51 08          	lea    rdx,[rcx+0x8]
  416328:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  41632c:	eb 84                	jmp    4162b2 <pop_arg+0x112>
  41632e:	66 90                	xchg   ax,ax
	break; case UINT:	arg->i = va_arg(*ap, unsigned int);
  416330:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  416334:	48 8d 51 08          	lea    rdx,[rcx+0x8]
  416338:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  41633c:	e9 55 ff ff ff       	jmp    416296 <pop_arg+0xf6>
  416341:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	break; case INT:	arg->i = va_arg(*ap, int);
  416348:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  41634c:	48 8d 51 08          	lea    rdx,[rcx+0x8]
  416350:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  416354:	e9 1d ff ff ff       	jmp    416276 <pop_arg+0xd6>
  416359:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	break; case DBL:	arg->f = va_arg(*ap, double);
  416360:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  416364:	48 8d 51 08          	lea    rdx,[rcx+0x8]
  416368:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  41636c:	e9 e2 fe ff ff       	jmp    416253 <pop_arg+0xb3>
  416371:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	break; case USHORT:	arg->i = (unsigned short)va_arg(*ap, int);
  416378:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  41637c:	48 8d 51 08          	lea    rdx,[rcx+0x8]
  416380:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  416384:	e9 a5 fe ff ff       	jmp    41622e <pop_arg+0x8e>

0000000000416389 <fmt_fp.cold>:
  416389:	41 8d bd 00 ff ff ff 	lea    edi,[r13-0x100]
  416390:	66 41 0f 6e ed       	movd   xmm5,r13d
{
	char pad[256];
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
	l = w - l;
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
	for (; l >= sizeof pad; l -= sizeof pad)
  416395:	45 31 c0             	xor    r8d,r8d
  416398:	48 b8 30 23 fc ff ff 	movabs rax,0xfffffffffffc2330
  41639f:	ff ff ff 
  4163a2:	41 89 f9             	mov    r9d,edi
  4163a5:	66 0f 70 c5 00       	pshufd xmm0,xmm5,0x0
  4163aa:	66 42 0f fe 04 38    	paddd  xmm0,XMMWORD PTR [rax+r15*1]
  4163b0:	48 b8 50 23 fc ff ff 	movabs rax,0xfffffffffffc2350
  4163b7:	ff ff ff 
  4163ba:	41 c1 e9 08          	shr    r9d,0x8
  4163be:	66 42 0f 6f 14 38    	movdqa xmm2,XMMWORD PTR [rax+r15*1]
  4163c4:	48 ba 40 23 fc ff ff 	movabs rdx,0xfffffffffffc2340
  4163cb:	ff ff ff 
  4163ce:	41 83 c1 01          	add    r9d,0x1
  4163d2:	66 42 0f 6f 1c 3a    	movdqa xmm3,XMMWORD PTR [rdx+r15*1]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4163d8:	89 f2                	mov    edx,esi
  4163da:	44 89 c9             	mov    ecx,r9d
  4163dd:	c1 e9 02             	shr    ecx,0x2
  4163e0:	66 0f 6f c8          	movdqa xmm1,xmm0
  4163e4:	41 83 c0 01          	add    r8d,0x1
  4163e8:	66 0f fe c3          	paddd  xmm0,xmm3
  4163ec:	89 d6                	mov    esi,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  4163ee:	66 0f fe ca          	paddd  xmm1,xmm2
  4163f2:	44 39 c1             	cmp    ecx,r8d
  4163f5:	77 e9                	ja     4163e0 <fmt_fp.cold+0x57>
  4163f7:	44 89 c8             	mov    eax,r9d
  4163fa:	66 0f 70 c1 ff       	pshufd xmm0,xmm1,0xff
  4163ff:	83 e0 fc             	and    eax,0xfffffffc
  416402:	66 0f 7e c1          	movd   ecx,xmm0
  416406:	69 d0 00 ff ff ff    	imul   edx,eax,0xffffff00
  41640c:	41 39 c1             	cmp    r9d,eax
  41640f:	0f 84 50 12 00 00    	je     417665 <fmt_fp+0xc65>
  416415:	8d 04 17             	lea    eax,[rdi+rdx*1]
  416418:	89 c1                	mov    ecx,eax
  41641a:	3d ff 00 00 00       	cmp    eax,0xff
  41641f:	0f 86 40 12 00 00    	jbe    417665 <fmt_fp+0xc65>
  416425:	81 e9 00 01 00 00    	sub    ecx,0x100
  41642b:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  416431:	0f 86 2e 12 00 00    	jbe    417665 <fmt_fp+0xc65>
  416437:	8d 88 00 fe ff ff    	lea    ecx,[rax-0x200]
  41643d:	e9 23 12 00 00       	jmp    417665 <fmt_fp+0xc65>
  416442:	44 8d 83 00 ff ff ff 	lea    r8d,[rbx-0x100]
  416449:	66 0f 6e fb          	movd   xmm7,ebx
  41644d:	31 c9                	xor    ecx,ecx
  41644f:	48 b8 30 23 fc ff ff 	movabs rax,0xfffffffffffc2330
  416456:	ff ff ff 
  416459:	44 89 c7             	mov    edi,r8d
  41645c:	66 0f 70 cf 00       	pshufd xmm1,xmm7,0x0
  416461:	66 42 0f fe 0c 38    	paddd  xmm1,XMMWORD PTR [rax+r15*1]
  416467:	48 b8 50 23 fc ff ff 	movabs rax,0xfffffffffffc2350
  41646e:	ff ff ff 
  416471:	c1 ef 08             	shr    edi,0x8
  416474:	66 42 0f 6f 14 38    	movdqa xmm2,XMMWORD PTR [rax+r15*1]
  41647a:	48 ba 40 23 fc ff ff 	movabs rdx,0xfffffffffffc2340
  416481:	ff ff ff 
  416484:	83 c7 01             	add    edi,0x1
  416487:	66 42 0f 6f 1c 3a    	movdqa xmm3,XMMWORD PTR [rdx+r15*1]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41648d:	89 f2                	mov    edx,esi
  41648f:	41 89 f9             	mov    r9d,edi
  416492:	41 c1 e9 02          	shr    r9d,0x2
  416496:	66 0f 6f c1          	movdqa xmm0,xmm1
  41649a:	83 c1 01             	add    ecx,0x1
  41649d:	66 0f fe cb          	paddd  xmm1,xmm3
  4164a1:	89 d6                	mov    esi,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  4164a3:	66 0f fe c2          	paddd  xmm0,xmm2
  4164a7:	44 39 c9             	cmp    ecx,r9d
  4164aa:	72 ea                	jb     416496 <fmt_fp.cold+0x10d>
  4164ac:	89 fa                	mov    edx,edi
  4164ae:	66 0f 70 c0 ff       	pshufd xmm0,xmm0,0xff
  4164b3:	83 e2 fc             	and    edx,0xfffffffc
  4164b6:	66 0f 7e c5          	movd   ebp,xmm0
  4164ba:	69 c2 00 ff ff ff    	imul   eax,edx,0xffffff00
  4164c0:	39 fa                	cmp    edx,edi
  4164c2:	0f 84 56 0d 00 00    	je     41721e <fmt_fp+0x81e>
  4164c8:	44 01 c0             	add    eax,r8d
  4164cb:	89 c5                	mov    ebp,eax
  4164cd:	3d ff 00 00 00       	cmp    eax,0xff
  4164d2:	0f 86 46 0d 00 00    	jbe    41721e <fmt_fp+0x81e>
  4164d8:	81 ed 00 01 00 00    	sub    ebp,0x100
  4164de:	81 fd ff 00 00 00    	cmp    ebp,0xff
  4164e4:	0f 86 34 0d 00 00    	jbe    41721e <fmt_fp+0x81e>
  4164ea:	8d a8 00 fe ff ff    	lea    ebp,[rax-0x200]
  4164f0:	e9 29 0d 00 00       	jmp    41721e <fmt_fp+0x81e>
  4164f5:	45 8d 84 24 00 ff ff 	lea    r8d,[r12-0x100]
  4164fc:	ff 
  4164fd:	66 41 0f 6e f4       	movd   xmm6,r12d
  416502:	31 c9                	xor    ecx,ecx
  416504:	48 ba 40 23 fc ff ff 	movabs rdx,0xfffffffffffc2340
  41650b:	ff ff ff 
  41650e:	44 89 c0             	mov    eax,r8d
  416511:	66 0f 70 ce 00       	pshufd xmm1,xmm6,0x0
  416516:	66 42 0f 6f 1c 3a    	movdqa xmm3,XMMWORD PTR [rdx+r15*1]
  41651c:	c1 e8 08             	shr    eax,0x8
  41651f:	8d 78 01             	lea    edi,[rax+0x1]
  416522:	48 b8 30 23 fc ff ff 	movabs rax,0xfffffffffffc2330
  416529:	ff ff ff 
  41652c:	66 42 0f fe 0c 38    	paddd  xmm1,XMMWORD PTR [rax+r15*1]
  416532:	41 89 f9             	mov    r9d,edi
  416535:	48 b8 50 23 fc ff ff 	movabs rax,0xfffffffffffc2350
  41653c:	ff ff ff 
  41653f:	66 42 0f 6f 14 38    	movdqa xmm2,XMMWORD PTR [rax+r15*1]
  416545:	41 c1 e9 02          	shr    r9d,0x2
  416549:	66 0f 6f c1          	movdqa xmm0,xmm1
  41654d:	83 c1 01             	add    ecx,0x1
  416550:	66 0f fe cb          	paddd  xmm1,xmm3
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  416554:	89 f2                	mov    edx,esi
	for (; l >= sizeof pad; l -= sizeof pad)
  416556:	66 0f fe c2          	paddd  xmm0,xmm2
  41655a:	41 39 c9             	cmp    r9d,ecx
  41655d:	77 ea                	ja     416549 <fmt_fp.cold+0x1c0>
  41655f:	89 f8                	mov    eax,edi
  416561:	66 0f 70 c0 ff       	pshufd xmm0,xmm0,0xff
  416566:	83 e0 fc             	and    eax,0xfffffffc
  416569:	66 41 0f 7e c1       	movd   r9d,xmm0
  41656e:	69 c8 00 ff ff ff    	imul   ecx,eax,0xffffff00
  416574:	39 c7                	cmp    edi,eax
  416576:	0f 84 8b 16 00 00    	je     417c07 <fmt_fp+0x1207>
  41657c:	41 01 c8             	add    r8d,ecx
  41657f:	45 89 c1             	mov    r9d,r8d
  416582:	41 81 f8 ff 00 00 00 	cmp    r8d,0xff
  416589:	0f 86 78 16 00 00    	jbe    417c07 <fmt_fp+0x1207>
  41658f:	41 81 e9 00 01 00 00 	sub    r9d,0x100
  416596:	41 81 f9 ff 00 00 00 	cmp    r9d,0xff
  41659d:	0f 86 64 16 00 00    	jbe    417c07 <fmt_fp+0x1207>
  4165a3:	45 8d 88 00 fe ff ff 	lea    r9d,[r8-0x200]
  4165aa:	e9 58 16 00 00       	jmp    417c07 <fmt_fp+0x1207>
  4165af:	41 8d b4 24 00 ff ff 	lea    esi,[r12-0x100]
  4165b6:	ff 
  4165b7:	66 41 0f 6e f4       	movd   xmm6,r12d
  4165bc:	45 31 c0             	xor    r8d,r8d
  4165bf:	48 b8 30 23 fc ff ff 	movabs rax,0xfffffffffffc2330
  4165c6:	ff ff ff 
  4165c9:	89 f7                	mov    edi,esi
  4165cb:	66 0f 70 c6 00       	pshufd xmm0,xmm6,0x0
  4165d0:	48 ba 40 23 fc ff ff 	movabs rdx,0xfffffffffffc2340
  4165d7:	ff ff ff 
  4165da:	c1 ef 08             	shr    edi,0x8
  4165dd:	66 42 0f fe 04 38    	paddd  xmm0,XMMWORD PTR [rax+r15*1]
  4165e3:	66 42 0f 6f 1c 3a    	movdqa xmm3,XMMWORD PTR [rdx+r15*1]
  4165e9:	48 b8 50 23 fc ff ff 	movabs rax,0xfffffffffffc2350
  4165f0:	ff ff ff 
  4165f3:	83 c7 01             	add    edi,0x1
  4165f6:	66 42 0f 6f 14 38    	movdqa xmm2,XMMWORD PTR [rax+r15*1]
  4165fc:	41 89 f9             	mov    r9d,edi
  4165ff:	41 c1 e9 02          	shr    r9d,0x2
  416603:	66 0f 6f c8          	movdqa xmm1,xmm0
  416607:	41 83 c0 01          	add    r8d,0x1
  41660b:	66 0f fe c3          	paddd  xmm0,xmm3
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41660f:	89 ca                	mov    edx,ecx
	for (; l >= sizeof pad; l -= sizeof pad)
  416611:	66 0f fe ca          	paddd  xmm1,xmm2
  416615:	45 39 c8             	cmp    r8d,r9d
  416618:	72 e9                	jb     416603 <fmt_fp.cold+0x27a>
  41661a:	89 f8                	mov    eax,edi
  41661c:	66 0f 70 c1 ff       	pshufd xmm0,xmm1,0xff
  416621:	83 e0 fc             	and    eax,0xfffffffc
  416624:	66 41 0f 7e c5       	movd   r13d,xmm0
  416629:	69 c8 00 ff ff ff    	imul   ecx,eax,0xffffff00
  41662f:	39 c7                	cmp    edi,eax
  416631:	0f 84 16 11 00 00    	je     41774d <fmt_fp+0xd4d>
  416637:	8d 04 0e             	lea    eax,[rsi+rcx*1]
  41663a:	41 89 c5             	mov    r13d,eax
  41663d:	3d ff 00 00 00       	cmp    eax,0xff
  416642:	0f 86 05 11 00 00    	jbe    41774d <fmt_fp+0xd4d>
  416648:	41 81 ed 00 01 00 00 	sub    r13d,0x100
  41664f:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  416656:	0f 86 f1 10 00 00    	jbe    41774d <fmt_fp+0xd4d>
  41665c:	44 8d a8 00 fe ff ff 	lea    r13d,[rax-0x200]
  416663:	e9 e5 10 00 00       	jmp    41774d <fmt_fp+0xd4d>
  416668:	44 8d 85 00 ff ff ff 	lea    r8d,[rbp-0x100]
  41666f:	66 0f 6e fd          	movd   xmm7,ebp
  416673:	31 f6                	xor    esi,esi
  416675:	48 b8 30 23 fc ff ff 	movabs rax,0xfffffffffffc2330
  41667c:	ff ff ff 
  41667f:	44 89 c7             	mov    edi,r8d
  416682:	66 0f 70 cf 00       	pshufd xmm1,xmm7,0x0
  416687:	48 ba 40 23 fc ff ff 	movabs rdx,0xfffffffffffc2340
  41668e:	ff ff ff 
  416691:	c1 ef 08             	shr    edi,0x8
  416694:	66 42 0f fe 0c 38    	paddd  xmm1,XMMWORD PTR [rax+r15*1]
  41669a:	66 42 0f 6f 1c 3a    	movdqa xmm3,XMMWORD PTR [rdx+r15*1]
  4166a0:	48 b8 50 23 fc ff ff 	movabs rax,0xfffffffffffc2350
  4166a7:	ff ff ff 
  4166aa:	83 c7 01             	add    edi,0x1
  4166ad:	66 42 0f 6f 14 38    	movdqa xmm2,XMMWORD PTR [rax+r15*1]
  4166b3:	41 89 f9             	mov    r9d,edi
  4166b6:	41 c1 e9 02          	shr    r9d,0x2
  4166ba:	66 0f 6f c1          	movdqa xmm0,xmm1
  4166be:	83 c6 01             	add    esi,0x1
  4166c1:	66 0f fe cb          	paddd  xmm1,xmm3
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4166c5:	89 ca                	mov    edx,ecx
	for (; l >= sizeof pad; l -= sizeof pad)
  4166c7:	66 0f fe c2          	paddd  xmm0,xmm2
  4166cb:	41 39 f1             	cmp    r9d,esi
  4166ce:	77 ea                	ja     4166ba <fmt_fp.cold+0x331>
  4166d0:	89 f9                	mov    ecx,edi
  4166d2:	66 0f 70 c0 ff       	pshufd xmm0,xmm0,0xff
  4166d7:	83 e1 fc             	and    ecx,0xfffffffc
  4166da:	66 41 0f 7e c4       	movd   r12d,xmm0
  4166df:	69 c1 00 ff ff ff    	imul   eax,ecx,0xffffff00
  4166e5:	39 f9                	cmp    ecx,edi
  4166e7:	0f 84 a4 17 00 00    	je     417e91 <fmt_fp+0x1491>
  4166ed:	44 01 c0             	add    eax,r8d
  4166f0:	41 89 c4             	mov    r12d,eax
  4166f3:	3d ff 00 00 00       	cmp    eax,0xff
  4166f8:	0f 86 93 17 00 00    	jbe    417e91 <fmt_fp+0x1491>
  4166fe:	41 81 ec 00 01 00 00 	sub    r12d,0x100
  416705:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  41670c:	0f 86 7f 17 00 00    	jbe    417e91 <fmt_fp+0x1491>
  416712:	44 8d a0 00 fe ff ff 	lea    r12d,[rax-0x200]
  416719:	e9 73 17 00 00       	jmp    417e91 <fmt_fp+0x1491>
  41671e:	41 8d bd 00 ff ff ff 	lea    edi,[r13-0x100]
  416725:	66 41 0f 6e ed       	movd   xmm5,r13d
  41672a:	45 31 c0             	xor    r8d,r8d
  41672d:	48 b8 30 23 fc ff ff 	movabs rax,0xfffffffffffc2330
  416734:	ff ff ff 
  416737:	89 fe                	mov    esi,edi
  416739:	66 0f 70 cd 00       	pshufd xmm1,xmm5,0x0
  41673e:	66 42 0f fe 0c 38    	paddd  xmm1,XMMWORD PTR [rax+r15*1]
  416744:	48 b8 50 23 fc ff ff 	movabs rax,0xfffffffffffc2350
  41674b:	ff ff ff 
  41674e:	c1 ee 08             	shr    esi,0x8
  416751:	66 42 0f 6f 14 38    	movdqa xmm2,XMMWORD PTR [rax+r15*1]
  416757:	48 ba 40 23 fc ff ff 	movabs rdx,0xfffffffffffc2340
  41675e:	ff ff ff 
  416761:	83 c6 01             	add    esi,0x1
  416764:	66 42 0f 6f 1c 3a    	movdqa xmm3,XMMWORD PTR [rdx+r15*1]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41676a:	89 ca                	mov    edx,ecx
  41676c:	41 89 f1             	mov    r9d,esi
  41676f:	41 c1 e9 02          	shr    r9d,0x2
  416773:	66 0f 6f c1          	movdqa xmm0,xmm1
  416777:	41 83 c0 01          	add    r8d,0x1
  41677b:	66 0f fe cb          	paddd  xmm1,xmm3
  41677f:	89 d1                	mov    ecx,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  416781:	66 0f fe c2          	paddd  xmm0,xmm2
  416785:	45 39 c8             	cmp    r8d,r9d
  416788:	72 e9                	jb     416773 <fmt_fp.cold+0x3ea>
  41678a:	89 f2                	mov    edx,esi
  41678c:	66 0f 70 c0 ff       	pshufd xmm0,xmm0,0xff
  416791:	83 e2 fc             	and    edx,0xfffffffc
  416794:	66 0f 7e c5          	movd   ebp,xmm0
  416798:	69 c2 00 ff ff ff    	imul   eax,edx,0xffffff00
  41679e:	39 f2                	cmp    edx,esi
  4167a0:	0f 84 65 0b 00 00    	je     41730b <fmt_fp+0x90b>
  4167a6:	01 f8                	add    eax,edi
  4167a8:	89 c5                	mov    ebp,eax
  4167aa:	3d ff 00 00 00       	cmp    eax,0xff
  4167af:	0f 86 56 0b 00 00    	jbe    41730b <fmt_fp+0x90b>
  4167b5:	81 ed 00 01 00 00    	sub    ebp,0x100
  4167bb:	81 fd ff 00 00 00    	cmp    ebp,0xff
  4167c1:	0f 86 44 0b 00 00    	jbe    41730b <fmt_fp+0x90b>
  4167c7:	8d a8 00 fe ff ff    	lea    ebp,[rax-0x200]
  4167cd:	e9 39 0b 00 00       	jmp    41730b <fmt_fp+0x90b>
  4167d2:	45 8d 84 24 00 ff ff 	lea    r8d,[r12-0x100]
  4167d9:	ff 
  4167da:	66 41 0f 6e ec       	movd   xmm5,r12d
  4167df:	31 c9                	xor    ecx,ecx
  4167e1:	48 ba 40 23 fc ff ff 	movabs rdx,0xfffffffffffc2340
  4167e8:	ff ff ff 
  4167eb:	44 89 c0             	mov    eax,r8d
  4167ee:	66 0f 70 cd 00       	pshufd xmm1,xmm5,0x0
  4167f3:	66 42 0f 6f 1c 3a    	movdqa xmm3,XMMWORD PTR [rdx+r15*1]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4167f9:	89 f2                	mov    edx,esi
  4167fb:	c1 e8 08             	shr    eax,0x8
  4167fe:	8d 78 01             	lea    edi,[rax+0x1]
  416801:	48 b8 30 23 fc ff ff 	movabs rax,0xfffffffffffc2330
  416808:	ff ff ff 
  41680b:	66 42 0f fe 0c 38    	paddd  xmm1,XMMWORD PTR [rax+r15*1]
  416811:	41 89 f9             	mov    r9d,edi
  416814:	48 b8 50 23 fc ff ff 	movabs rax,0xfffffffffffc2350
  41681b:	ff ff ff 
	for (; l >= sizeof pad; l -= sizeof pad)
  41681e:	66 42 0f 6f 14 38    	movdqa xmm2,XMMWORD PTR [rax+r15*1]
  416824:	41 c1 e9 02          	shr    r9d,0x2
  416828:	66 0f 6f c1          	movdqa xmm0,xmm1
  41682c:	83 c1 01             	add    ecx,0x1
  41682f:	66 0f fe cb          	paddd  xmm1,xmm3
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  416833:	89 d6                	mov    esi,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  416835:	66 0f fe c2          	paddd  xmm0,xmm2
  416839:	44 39 c9             	cmp    ecx,r9d
  41683c:	72 ea                	jb     416828 <fmt_fp.cold+0x49f>
  41683e:	89 f8                	mov    eax,edi
  416840:	66 0f 70 c0 ff       	pshufd xmm0,xmm0,0xff
  416845:	83 e0 fc             	and    eax,0xfffffffc
  416848:	66 0f 7e c1          	movd   ecx,xmm0
  41684c:	69 d0 00 ff ff ff    	imul   edx,eax,0xffffff00
  416852:	39 c7                	cmp    edi,eax
  416854:	0f 84 be 12 00 00    	je     417b18 <fmt_fp+0x1118>
  41685a:	41 01 d0             	add    r8d,edx
  41685d:	44 89 c1             	mov    ecx,r8d
  416860:	41 81 f8 ff 00 00 00 	cmp    r8d,0xff
  416867:	0f 86 ab 12 00 00    	jbe    417b18 <fmt_fp+0x1118>
  41686d:	81 e9 00 01 00 00    	sub    ecx,0x100
  416873:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  416879:	0f 86 99 12 00 00    	jbe    417b18 <fmt_fp+0x1118>
  41687f:	41 8d 88 00 fe ff ff 	lea    ecx,[r8-0x200]
  416886:	e9 8d 12 00 00       	jmp    417b18 <fmt_fp+0x1118>
  41688b:	8d bb 00 ff ff ff    	lea    edi,[rbx-0x100]
  416891:	66 0f 6e f3          	movd   xmm6,ebx
  416895:	45 31 c9             	xor    r9d,r9d
  416898:	48 b8 30 23 fc ff ff 	movabs rax,0xfffffffffffc2330
  41689f:	ff ff ff 
  4168a2:	89 fe                	mov    esi,edi
  4168a4:	66 0f 70 ce 00       	pshufd xmm1,xmm6,0x0
  4168a9:	66 42 0f fe 0c 38    	paddd  xmm1,XMMWORD PTR [rax+r15*1]
  4168af:	48 b8 50 23 fc ff ff 	movabs rax,0xfffffffffffc2350
  4168b6:	ff ff ff 
  4168b9:	c1 ee 08             	shr    esi,0x8
  4168bc:	66 42 0f 6f 14 38    	movdqa xmm2,XMMWORD PTR [rax+r15*1]
  4168c2:	48 ba 40 23 fc ff ff 	movabs rdx,0xfffffffffffc2340
  4168c9:	ff ff ff 
  4168cc:	83 c6 01             	add    esi,0x1
  4168cf:	66 42 0f 6f 1c 3a    	movdqa xmm3,XMMWORD PTR [rdx+r15*1]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4168d5:	89 ca                	mov    edx,ecx
  4168d7:	41 89 f0             	mov    r8d,esi
  4168da:	41 c1 e8 02          	shr    r8d,0x2
  4168de:	66 0f 6f c1          	movdqa xmm0,xmm1
  4168e2:	41 83 c1 01          	add    r9d,0x1
  4168e6:	66 0f fe cb          	paddd  xmm1,xmm3
  4168ea:	89 d1                	mov    ecx,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  4168ec:	66 0f fe c2          	paddd  xmm0,xmm2
  4168f0:	45 39 c8             	cmp    r8d,r9d
  4168f3:	77 e9                	ja     4168de <fmt_fp.cold+0x555>
  4168f5:	89 f2                	mov    edx,esi
  4168f7:	66 0f 70 c0 ff       	pshufd xmm0,xmm0,0xff
  4168fc:	83 e2 fc             	and    edx,0xfffffffc
  4168ff:	66 0f 7e 44 24 08    	movd   DWORD PTR [rsp+0x8],xmm0
  416905:	69 c2 00 ff ff ff    	imul   eax,edx,0xffffff00
  41690b:	39 f2                	cmp    edx,esi
  41690d:	0f 84 ac 0a 00 00    	je     4173bf <fmt_fp+0x9bf>
  416913:	01 f8                	add    eax,edi
  416915:	89 44 24 08          	mov    DWORD PTR [rsp+0x8],eax
  416919:	89 c3                	mov    ebx,eax
  41691b:	3d ff 00 00 00       	cmp    eax,0xff
  416920:	0f 86 99 0a 00 00    	jbe    4173bf <fmt_fp+0x9bf>
  416926:	81 eb 00 01 00 00    	sub    ebx,0x100
  41692c:	89 5c 24 08          	mov    DWORD PTR [rsp+0x8],ebx
  416930:	81 fb ff 00 00 00    	cmp    ebx,0xff
  416936:	0f 86 83 0a 00 00    	jbe    4173bf <fmt_fp+0x9bf>
  41693c:	2d 00 02 00 00       	sub    eax,0x200
  416941:	89 44 24 08          	mov    DWORD PTR [rsp+0x8],eax
  416945:	e9 75 0a 00 00       	jmp    4173bf <fmt_fp+0x9bf>
  41694a:	8d b5 00 ff ff ff    	lea    esi,[rbp-0x100]
  416950:	66 0f 6e fd          	movd   xmm7,ebp
  416954:	45 31 c0             	xor    r8d,r8d
  416957:	48 b8 30 23 fc ff ff 	movabs rax,0xfffffffffffc2330
  41695e:	ff ff ff 
  416961:	89 f7                	mov    edi,esi
  416963:	66 0f 70 cf 00       	pshufd xmm1,xmm7,0x0
  416968:	48 ba 40 23 fc ff ff 	movabs rdx,0xfffffffffffc2340
  41696f:	ff ff ff 
  416972:	c1 ef 08             	shr    edi,0x8
  416975:	66 42 0f fe 0c 38    	paddd  xmm1,XMMWORD PTR [rax+r15*1]
  41697b:	66 42 0f 6f 1c 3a    	movdqa xmm3,XMMWORD PTR [rdx+r15*1]
  416981:	48 b8 50 23 fc ff ff 	movabs rax,0xfffffffffffc2350
  416988:	ff ff ff 
  41698b:	83 c7 01             	add    edi,0x1
  41698e:	66 42 0f 6f 14 38    	movdqa xmm2,XMMWORD PTR [rax+r15*1]
  416994:	41 89 f9             	mov    r9d,edi
  416997:	41 c1 e9 02          	shr    r9d,0x2
  41699b:	66 0f 6f c1          	movdqa xmm0,xmm1
  41699f:	41 83 c0 01          	add    r8d,0x1
  4169a3:	66 0f fe cb          	paddd  xmm1,xmm3
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4169a7:	89 ca                	mov    edx,ecx
	for (; l >= sizeof pad; l -= sizeof pad)
  4169a9:	66 0f fe c2          	paddd  xmm0,xmm2
  4169ad:	45 39 c8             	cmp    r8d,r9d
  4169b0:	72 e9                	jb     41699b <fmt_fp.cold+0x612>
  4169b2:	89 f8                	mov    eax,edi
  4169b4:	66 0f 70 c0 ff       	pshufd xmm0,xmm0,0xff
  4169b9:	83 e0 fc             	and    eax,0xfffffffc
  4169bc:	66 41 0f 7e c4       	movd   r12d,xmm0
  4169c1:	69 c8 00 ff ff ff    	imul   ecx,eax,0xffffff00
  4169c7:	39 c7                	cmp    edi,eax
  4169c9:	0f 84 ef 0a 00 00    	je     4174be <fmt_fp+0xabe>
  4169cf:	8d 04 0e             	lea    eax,[rsi+rcx*1]
  4169d2:	41 89 c4             	mov    r12d,eax
  4169d5:	3d ff 00 00 00       	cmp    eax,0xff
  4169da:	0f 86 de 0a 00 00    	jbe    4174be <fmt_fp+0xabe>
  4169e0:	41 81 ec 00 01 00 00 	sub    r12d,0x100
  4169e7:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  4169ee:	0f 86 ca 0a 00 00    	jbe    4174be <fmt_fp+0xabe>
  4169f4:	44 8d a0 00 fe ff ff 	lea    r12d,[rax-0x200]
  4169fb:	e9 be 0a 00 00       	jmp    4174be <fmt_fp+0xabe>

0000000000416a00 <fmt_fp>:
#if LDBL_MANT_DIG == 53
typedef char compiler_defines_long_double_incorrectly[9-(int)sizeof(long double)];
#endif

static int fmt_fp(FILE *f, long double y, int w, int p, int fl, int t)
{
  416a00:	f3 0f 1e fa          	endbr64 
  416a04:	41 57                	push   r15
  416a06:	41 56                	push   r14
  416a08:	41 55                	push   r13
  416a0a:	41 54                	push   r12
  416a0c:	55                   	push   rbp
  416a0d:	53                   	push   rbx
  416a0e:	48 81 ec 00 10 00 00 	sub    rsp,0x1000
  416a15:	48 83 0c 24 00       	or     QWORD PTR [rsp],0x0
  416a1a:	48 81 ec 48 0e 00 00 	sub    rsp,0xe48
  416a21:	4c 8d 3d dc ff ff ff 	lea    r15,[rip+0xffffffffffffffdc]        # 416a04 <fmt_fp+0x4>
  416a28:	49 bb 0c 6a 04 00 00 	movabs r11,0x46a0c
  416a2f:	00 00 00 
	const char *prefix="-0X+0X 0X-0x+0x 0x";
	int pl;
	char ebuf0[3*sizeof(int)], *ebuf=&ebuf0[3*sizeof(int)], *estr;

	pl=1;
	if (signbit(y)) {
  416a32:	48 b8 70 df fb ff ff 	movabs rax,0xfffffffffffbdf70
  416a39:	ff ff ff 
  416a3c:	4d 01 df             	add    r15,r11
  416a3f:	4c 01 f8             	add    rax,r15
{
  416a42:	89 74 24 58          	mov    DWORD PTR [rsp+0x58],esi
  416a46:	49 89 fe             	mov    r14,rdi
  416a49:	89 14 24             	mov    DWORD PTR [rsp],edx
  416a4c:	89 4c 24 14          	mov    DWORD PTR [rsp+0x14],ecx
  416a50:	44 89 44 24 20       	mov    DWORD PTR [rsp+0x20],r8d
	int e2=0, e, i, j, l;
  416a55:	c7 44 24 60 00 00 00 	mov    DWORD PTR [rsp+0x60],0x0
  416a5c:	00 
	if (signbit(y)) {
  416a5d:	ff b4 24 88 1e 00 00 	push   QWORD PTR [rsp+0x1e88]
  416a64:	ff b4 24 88 1e 00 00 	push   QWORD PTR [rsp+0x1e88]
  416a6b:	ff d0                	call   rax
  416a6d:	89 44 24 38          	mov    DWORD PTR [rsp+0x38],eax
  416a71:	59                   	pop    rcx
  416a72:	5e                   	pop    rsi
  416a73:	85 c0                	test   eax,eax
  416a75:	0f 84 1d 04 00 00    	je     416e98 <fmt_fp+0x498>
		y=-y;
  416a7b:	db ac 24 80 1e 00 00 	fld    TBYTE PTR [rsp+0x1e80]
	pl=1;
  416a82:	c7 44 24 28 01 00 00 	mov    DWORD PTR [rsp+0x28],0x1
  416a89:	00 
	const char *prefix="-0X+0X 0X-0x+0x 0x";
  416a8a:	48 b8 50 1e fc ff ff 	movabs rax,0xfffffffffffc1e50
  416a91:	ff ff ff 
  416a94:	bb 03 00 00 00       	mov    ebx,0x3
  416a99:	4c 01 f8             	add    rax,r15
  416a9c:	41 bd 03 00 00 00    	mov    r13d,0x3
  416aa2:	bd 04 00 00 00       	mov    ebp,0x4
  416aa7:	48 c7 44 24 38 01 00 	mov    QWORD PTR [rsp+0x38],0x1
  416aae:	00 00 
  416ab0:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
		y=-y;
  416ab5:	d9 e0                	fchs   
  416ab7:	db bc 24 80 1e 00 00 	fstp   TBYTE PTR [rsp+0x1e80]
		prefix+=3;
	} else if (fl & PAD_POS) {
		prefix+=6;
	} else prefix++, pl=0;

	if (!isfinite(y)) {
  416abe:	48 b8 10 df fb ff ff 	movabs rax,0xfffffffffffbdf10
  416ac5:	ff ff ff 
  416ac8:	ff b4 24 88 1e 00 00 	push   QWORD PTR [rsp+0x1e88]
  416acf:	4c 01 f8             	add    rax,r15
  416ad2:	ff b4 24 88 1e 00 00 	push   QWORD PTR [rsp+0x1e88]
  416ad9:	ff d0                	call   rax
  416adb:	41 5c                	pop    r12
  416add:	5a                   	pop    rdx
  416ade:	83 f8 01             	cmp    eax,0x1
  416ae1:	0f 8e 61 0a 00 00    	jle    417548 <fmt_fp+0xb48>
		out(f, s, 3);
		pad(f, ' ', w, 3+pl, fl^LEFT_ADJ);
		return MAX(w, 3+pl);
	}

	y = frexpl(y, &e2) * 2;
  416ae7:	48 b8 90 df fb ff ff 	movabs rax,0xfffffffffffbdf90
  416aee:	ff ff ff 
  416af1:	48 8d 7c 24 60       	lea    rdi,[rsp+0x60]
  416af6:	ff b4 24 88 1e 00 00 	push   QWORD PTR [rsp+0x1e88]
  416afd:	4c 01 f8             	add    rax,r15
  416b00:	ff b4 24 88 1e 00 00 	push   QWORD PTR [rsp+0x1e88]
  416b07:	ff d0                	call   rax
	if (y) e2--;
  416b09:	41 5a                	pop    r10
	y = frexpl(y, &e2) * 2;
  416b0b:	d8 c0                	fadd   st,st(0)
	if (y) e2--;
  416b0d:	41 5b                	pop    r11
  416b0f:	d9 ee                	fldz   
  416b11:	d9 c9                	fxch   st(1)
  416b13:	db e9                	fucomi st,st(1)
  416b15:	dd d9                	fstp   st(1)
  416b17:	0f 8a c3 03 00 00    	jp     416ee0 <fmt_fp+0x4e0>
  416b1d:	0f 85 bd 03 00 00    	jne    416ee0 <fmt_fp+0x4e0>

	if ((t|32)=='a') {
  416b23:	44 8b 5c 24 20       	mov    r11d,DWORD PTR [rsp+0x20]
	if (y) e2--;
  416b28:	44 8b 4c 24 60       	mov    r9d,DWORD PTR [rsp+0x60]
	if ((t|32)=='a') {
  416b2d:	41 83 cb 20          	or     r11d,0x20
  416b31:	41 83 fb 61          	cmp    r11d,0x61
  416b35:	0f 84 c5 03 00 00    	je     416f00 <fmt_fp+0x500>
		pad(f, '0', l-(ebuf-estr)-(s-buf), 0, 0);
		out(f, estr, ebuf-estr);
		pad(f, ' ', w, pl+l, fl^LEFT_ADJ);
		return MAX(w, pl+l);
	}
	if (p<0) p=6;
  416b3b:	8b 3c 24             	mov    edi,DWORD PTR [rsp]
  416b3e:	85 ff                	test   edi,edi
  416b40:	0f 88 82 17 00 00    	js     4182c8 <fmt_fp+0x18c8>

	if (a<z) for (i=10, e=9*(r-a); *a>=i; i*=10, e++);
	else e=0;

	/* Perform rounding: j is precision after the radix (possibly neg) */
	j = p - ((t|32)!='f')*e - ((t|32)=='g' && p);
  416b46:	0f 95 44 24 40       	setne  BYTE PTR [rsp+0x40]
	if (y) y *= 0x1p28, e2-=28;
  416b4b:	d9 ee                	fldz   
  416b4d:	d9 c9                	fxch   st(1)
  416b4f:	db e9                	fucomi st,st(1)
  416b51:	dd d9                	fstp   st(1)
  416b53:	0f 8a 70 0c 00 00    	jp     4177c9 <fmt_fp+0xdc9>
  416b59:	0f 85 6a 0c 00 00    	jne    4177c9 <fmt_fp+0xdc9>
	if (e2<0) a=r=z=big;
  416b5f:	d9 7c 24 5e          	fnstcw WORD PTR [rsp+0x5e]
  416b63:	45 85 c9             	test   r9d,r9d
  416b66:	48 8d 84 24 90 01 00 	lea    rax,[rsp+0x190]
  416b6d:	00 
  416b6e:	48 8d 94 24 38 1d 00 	lea    rdx,[rsp+0x1d38]
  416b75:	00 
  416b76:	48 0f 49 c2          	cmovns rax,rdx
  416b7a:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
	else a=r=z=big+sizeof(big)/sizeof(*big) - LDBL_MANT_DIG - 1;
  416b7f:	48 89 c3             	mov    rbx,rax
  416b82:	48 b8 d8 22 fc ff ff 	movabs rax,0xfffffffffffc22d8
  416b89:	ff ff ff 
		y = 1000000000*(y-*z++);
  416b8c:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  416b90:	0f b7 44 24 5e       	movzx  eax,WORD PTR [rsp+0x5e]
  416b95:	80 cc 0c             	or     ah,0xc
  416b98:	66 89 44 24 5c       	mov    WORD PTR [rsp+0x5c],ax
	} while (y);
  416b9d:	d9 ee                	fldz   
  416b9f:	d9 ca                	fxch   st(2)
  416ba1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		*z = y;
  416ba8:	d9 c0                	fld    st(0)
  416baa:	d9 6c 24 5c          	fldcw  WORD PTR [rsp+0x5c]
  416bae:	df 7c 24 08          	fistp  QWORD PTR [rsp+0x8]
  416bb2:	d9 6c 24 5e          	fldcw  WORD PTR [rsp+0x5e]
		y = 1000000000*(y-*z++);
  416bb6:	48 83 c3 04          	add    rbx,0x4
		*z = y;
  416bba:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
  416bbf:	89 43 fc             	mov    DWORD PTR [rbx-0x4],eax
		y = 1000000000*(y-*z++);
  416bc2:	89 c0                	mov    eax,eax
  416bc4:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  416bc9:	df 6c 24 08          	fild   QWORD PTR [rsp+0x8]
  416bcd:	de e9                	fsubp  st(1),st
  416bcf:	d8 c9                	fmul   st,st(1)
	} while (y);
  416bd1:	db ea                	fucomi st,st(2)
  416bd3:	7a d3                	jp     416ba8 <fmt_fp+0x1a8>
  416bd5:	75 d1                	jne    416ba8 <fmt_fp+0x1a8>
  416bd7:	dd d8                	fstp   st(0)
  416bd9:	dd d8                	fstp   st(0)
  416bdb:	dd d8                	fstp   st(0)
	while (e2>0) {
  416bdd:	48 8b 6c 24 18       	mov    rbp,QWORD PTR [rsp+0x18]
  416be2:	45 85 c9             	test   r9d,r9d
  416be5:	0f 8e 8a 00 00 00    	jle    416c75 <fmt_fp+0x275>
			*d = x % 1000000000;
  416beb:	49 b8 53 5a 9b a0 2f 	movabs r8,0x44b82fa09b5a53
  416bf2:	b8 44 00 
  416bf5:	0f 1f 00             	nop    DWORD PTR [rax]
		int sh=MIN(29,e2);
  416bf8:	b9 1d 00 00 00       	mov    ecx,0x1d
		for (d=z-1; d>=a; d--) {
  416bfd:	48 8d 7b fc          	lea    rdi,[rbx-0x4]
		int sh=MIN(29,e2);
  416c01:	41 39 c9             	cmp    r9d,ecx
  416c04:	41 0f 4e c9          	cmovle ecx,r9d
		for (d=z-1; d>=a; d--) {
  416c08:	48 39 ef             	cmp    rdi,rbp
  416c0b:	72 3f                	jb     416c4c <fmt_fp+0x24c>
		uint32_t carry=0;
  416c0d:	31 c0                	xor    eax,eax
  416c0f:	90                   	nop
			uint64_t x = ((uint64_t)*d<<sh)+carry;
  416c10:	8b 37                	mov    esi,DWORD PTR [rdi]
		for (d=z-1; d>=a; d--) {
  416c12:	48 83 ef 04          	sub    rdi,0x4
			uint64_t x = ((uint64_t)*d<<sh)+carry;
  416c16:	48 d3 e6             	shl    rsi,cl
  416c19:	48 01 c6             	add    rsi,rax
			*d = x % 1000000000;
  416c1c:	48 89 f2             	mov    rdx,rsi
  416c1f:	48 c1 ea 09          	shr    rdx,0x9
  416c23:	48 89 d0             	mov    rax,rdx
  416c26:	49 f7 e0             	mul    r8
  416c29:	48 c1 ea 0b          	shr    rdx,0xb
  416c2d:	48 69 c2 00 ca 9a 3b 	imul   rax,rdx,0x3b9aca00
  416c34:	48 29 c6             	sub    rsi,rax
			carry = x / 1000000000;
  416c37:	89 d0                	mov    eax,edx
			*d = x % 1000000000;
  416c39:	89 77 04             	mov    DWORD PTR [rdi+0x4],esi
		for (d=z-1; d>=a; d--) {
  416c3c:	48 39 ef             	cmp    rdi,rbp
  416c3f:	73 cf                	jae    416c10 <fmt_fp+0x210>
		if (carry) *--a = carry;
  416c41:	85 c0                	test   eax,eax
  416c43:	74 07                	je     416c4c <fmt_fp+0x24c>
  416c45:	89 55 fc             	mov    DWORD PTR [rbp-0x4],edx
  416c48:	48 83 ed 04          	sub    rbp,0x4
		while (z>a && !z[-1]) z--;
  416c4c:	48 39 dd             	cmp    rbp,rbx
  416c4f:	72 10                	jb     416c61 <fmt_fp+0x261>
  416c51:	eb 15                	jmp    416c68 <fmt_fp+0x268>
  416c53:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  416c58:	48 83 eb 04          	sub    rbx,0x4
  416c5c:	48 39 eb             	cmp    rbx,rbp
  416c5f:	76 07                	jbe    416c68 <fmt_fp+0x268>
  416c61:	8b 73 fc             	mov    esi,DWORD PTR [rbx-0x4]
  416c64:	85 f6                	test   esi,esi
  416c66:	74 f0                	je     416c58 <fmt_fp+0x258>
		e2-=sh;
  416c68:	41 29 c9             	sub    r9d,ecx
	while (e2>0) {
  416c6b:	45 85 c9             	test   r9d,r9d
  416c6e:	7f 88                	jg     416bf8 <fmt_fp+0x1f8>
  416c70:	44 89 4c 24 60       	mov    DWORD PTR [rsp+0x60],r9d
	while (e2<0) {
  416c75:	45 85 c9             	test   r9d,r9d
  416c78:	0f 84 d3 00 00 00    	je     416d51 <fmt_fp+0x351>
		int sh=MIN(9,-e2), need=1+(p+LDBL_MANT_DIG/3U+8)/9;
  416c7e:	8b 04 24             	mov    eax,DWORD PTR [rsp]
			carry = (1000000000>>sh) * rm;
  416c81:	4c 89 74 24 08       	mov    QWORD PTR [rsp+0x8],r14
  416c86:	4c 8b 74 24 18       	mov    r14,QWORD PTR [rsp+0x18]
		int sh=MIN(9,-e2), need=1+(p+LDBL_MANT_DIG/3U+8)/9;
  416c8b:	83 c0 1d             	add    eax,0x1d
  416c8e:	48 69 c0 39 8e e3 38 	imul   rax,rax,0x38e38e39
  416c95:	48 c1 e8 21          	shr    rax,0x21
		if (z-b > need) z = b+need;
  416c99:	4c 8d 68 01          	lea    r13,[rax+0x1]
  416c9d:	4e 8d 24 ad 00 00 00 	lea    r12,[r13*4+0x0]
  416ca4:	00 
  416ca5:	0f 1f 00             	nop    DWORD PTR [rax]
		int sh=MIN(9,-e2), need=1+(p+LDBL_MANT_DIG/3U+8)/9;
  416ca8:	41 83 f9 f7          	cmp    r9d,0xfffffff7
  416cac:	0f 8d 6e 08 00 00    	jge    417520 <fmt_fp+0xb20>
		if (!*a) a++;
  416cb2:	8b 45 00             	mov    eax,DWORD PTR [rbp+0x0]
		e2+=sh;
  416cb5:	41 83 c1 09          	add    r9d,0x9
		int sh=MIN(9,-e2), need=1+(p+LDBL_MANT_DIG/3U+8)/9;
  416cb9:	b9 09 00 00 00       	mov    ecx,0x9
		for (d=a; d<z; d++) {
  416cbe:	48 39 dd             	cmp    rbp,rbx
  416cc1:	0f 83 6d 08 00 00    	jae    417534 <fmt_fp+0xb34>
			uint32_t rm = *d & (1<<sh)-1;
  416cc7:	41 b8 01 00 00 00    	mov    r8d,0x1
			carry = (1000000000>>sh) * rm;
  416ccd:	41 ba 00 ca 9a 3b    	mov    r10d,0x3b9aca00
  416cd3:	48 89 ee             	mov    rsi,rbp
		uint32_t carry=0, *b;
  416cd6:	31 d2                	xor    edx,edx
			uint32_t rm = *d & (1<<sh)-1;
  416cd8:	41 d3 e0             	shl    r8d,cl
			carry = (1000000000>>sh) * rm;
  416cdb:	41 d3 fa             	sar    r10d,cl
			uint32_t rm = *d & (1<<sh)-1;
  416cde:	41 83 e8 01          	sub    r8d,0x1
  416ce2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  416ce8:	8b 06                	mov    eax,DWORD PTR [rsi]
		for (d=a; d<z; d++) {
  416cea:	48 83 c6 04          	add    rsi,0x4
			*d = (*d>>sh) + carry;
  416cee:	89 c7                	mov    edi,eax
			uint32_t rm = *d & (1<<sh)-1;
  416cf0:	44 21 c0             	and    eax,r8d
			carry = (1000000000>>sh) * rm;
  416cf3:	41 0f af c2          	imul   eax,r10d
			*d = (*d>>sh) + carry;
  416cf7:	d3 ef                	shr    edi,cl
  416cf9:	01 fa                	add    edx,edi
  416cfb:	89 56 fc             	mov    DWORD PTR [rsi-0x4],edx
			carry = (1000000000>>sh) * rm;
  416cfe:	89 c2                	mov    edx,eax
		for (d=a; d<z; d++) {
  416d00:	48 39 de             	cmp    rsi,rbx
  416d03:	72 e3                	jb     416ce8 <fmt_fp+0x2e8>
		if (!*a) a++;
  416d05:	8b 4d 00             	mov    ecx,DWORD PTR [rbp+0x0]
  416d08:	48 8d 45 04          	lea    rax,[rbp+0x4]
  416d0c:	85 c9                	test   ecx,ecx
  416d0e:	48 0f 44 e8          	cmove  rbp,rax
		if (carry) *z++ = carry;
  416d12:	85 d2                	test   edx,edx
  416d14:	74 06                	je     416d1c <fmt_fp+0x31c>
  416d16:	89 13                	mov    DWORD PTR [rbx],edx
  416d18:	48 83 c3 04          	add    rbx,0x4
		b = (t|32)=='f' ? r : a;
  416d1c:	41 83 fb 66          	cmp    r11d,0x66
  416d20:	4c 89 f0             	mov    rax,r14
		if (z-b > need) z = b+need;
  416d23:	48 89 da             	mov    rdx,rbx
		b = (t|32)=='f' ? r : a;
  416d26:	48 0f 45 c5          	cmovne rax,rbp
		if (z-b > need) z = b+need;
  416d2a:	48 29 c2             	sub    rdx,rax
  416d2d:	4c 01 e0             	add    rax,r12
  416d30:	48 c1 fa 02          	sar    rdx,0x2
  416d34:	4c 39 ea             	cmp    rdx,r13
  416d37:	48 0f 4f d8          	cmovg  rbx,rax
	while (e2<0) {
  416d3b:	45 85 c9             	test   r9d,r9d
  416d3e:	0f 85 64 ff ff ff    	jne    416ca8 <fmt_fp+0x2a8>
  416d44:	c7 44 24 60 00 00 00 	mov    DWORD PTR [rsp+0x60],0x0
  416d4b:	00 
  416d4c:	4c 8b 74 24 08       	mov    r14,QWORD PTR [rsp+0x8]
	if (a<z) for (i=10, e=9*(r-a); *a>=i; i*=10, e++);
  416d51:	48 39 eb             	cmp    rbx,rbp
  416d54:	0f 87 31 0a 00 00    	ja     41778b <fmt_fp+0xd8b>
  416d5a:	8b 04 24             	mov    eax,DWORD PTR [rsp]
	else e=0;
  416d5d:	31 ff                	xor    edi,edi
	j = p - ((t|32)!='f')*e - ((t|32)=='g' && p);
  416d5f:	31 d2                	xor    edx,edx
  416d61:	41 83 fb 67          	cmp    r11d,0x67
	if (j < 9*(z-r-1)) {
  416d65:	48 8b 74 24 18       	mov    rsi,QWORD PTR [rsp+0x18]
	j = p - ((t|32)!='f')*e - ((t|32)=='g' && p);
  416d6a:	0f 94 c2             	sete   dl
  416d6d:	23 54 24 40          	and    edx,DWORD PTR [rsp+0x40]
  416d71:	29 d0                	sub    eax,edx
	if (j < 9*(z-r-1)) {
  416d73:	48 89 da             	mov    rdx,rbx
  416d76:	48 29 f2             	sub    rdx,rsi
  416d79:	48 63 c8             	movsxd rcx,eax
  416d7c:	48 c1 fa 02          	sar    rdx,0x2
  416d80:	48 8d 54 d2 f7       	lea    rdx,[rdx+rdx*8-0x9]
  416d85:	48 39 d1             	cmp    rcx,rdx
  416d88:	0f 8d 9f 0b 00 00    	jge    41792d <fmt_fp+0xf2d>
		uint32_t x;
		/* We avoid C's broken division of negative numbers */
		d = r + 1 + ((j+9*LDBL_MAX_EXP)/9 - LDBL_MAX_EXP);
  416d8e:	05 00 40 02 00       	add    eax,0x24000
  416d93:	48 63 d0             	movsxd rdx,eax
  416d96:	89 c1                	mov    ecx,eax
  416d98:	48 69 d2 39 8e e3 38 	imul   rdx,rdx,0x38e38e39
  416d9f:	c1 f9 1f             	sar    ecx,0x1f
  416da2:	48 c1 fa 21          	sar    rdx,0x21
  416da6:	29 ca                	sub    edx,ecx
  416da8:	48 63 ca             	movsxd rcx,edx
		j += 9*LDBL_MAX_EXP;
		j %= 9;
  416dab:	8d 14 d2             	lea    edx,[rdx+rdx*8]
  416dae:	29 d0                	sub    eax,edx
		d = r + 1 + ((j+9*LDBL_MAX_EXP)/9 - LDBL_MAX_EXP);
  416db0:	48 8d b4 8e 04 00 ff 	lea    rsi,[rsi+rcx*4-0xfffc]
  416db7:	ff 
		for (i=10, j++; j<9; i*=10, j++);
  416db8:	83 f8 08             	cmp    eax,0x8
  416dbb:	0f 84 7e 23 00 00    	je     41913f <fmt_fp+0x273f>
  416dc1:	ba 08 00 00 00       	mov    edx,0x8
  416dc6:	29 c2                	sub    edx,eax
  416dc8:	41 89 d0             	mov    r8d,edx
  416dcb:	83 f8 07             	cmp    eax,0x7
  416dce:	0f 84 9b 23 00 00    	je     41916f <fmt_fp+0x276f>
  416dd4:	89 d0                	mov    eax,edx
  416dd6:	d1 e8                	shr    eax,1
  416dd8:	83 f8 01             	cmp    eax,0x1
  416ddb:	0f 84 10 23 00 00    	je     4190f1 <fmt_fp+0x26f1>
  416de1:	83 f8 02             	cmp    eax,0x2
  416de4:	0f 84 2a 23 00 00    	je     419114 <fmt_fp+0x2714>
  416dea:	83 f8 03             	cmp    eax,0x3
  416ded:	0f 84 86 23 00 00    	je     419179 <fmt_fp+0x2779>
  416df3:	83 f8 04             	cmp    eax,0x4
  416df6:	0f 84 9c 23 00 00    	je     419198 <fmt_fp+0x2798>
  416dfc:	83 f8 05             	cmp    eax,0x5
  416dff:	0f 84 c8 23 00 00    	je     4191cd <fmt_fp+0x27cd>
  416e05:	83 f8 06             	cmp    eax,0x6
  416e08:	0f 84 aa 23 00 00    	je     4191b8 <fmt_fp+0x27b8>
  416e0e:	b9 00 00 8a 5d       	mov    ecx,0x5d8a0000
  416e13:	83 f8 08             	cmp    eax,0x8
  416e16:	0f 85 b3 21 00 00    	jne    418fcf <fmt_fp+0x25cf>
  416e1c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		x = *d % i;
  416e20:	41 89 ca             	mov    r10d,ecx
  416e23:	44 8b 0e             	mov    r9d,DWORD PTR [rsi]
  416e26:	31 d2                	xor    edx,edx
  416e28:	44 89 c8             	mov    eax,r9d
  416e2b:	41 f7 f2             	div    r10d
  416e2e:	41 89 d0             	mov    r8d,edx
		/* Are there any significant digits past j? */
		if (x || d+1!=z) {
  416e31:	85 d2                	test   edx,edx
  416e33:	0f 85 68 0a 00 00    	jne    4178a1 <fmt_fp+0xea1>
  416e39:	48 8d 56 04          	lea    rdx,[rsi+0x4]
  416e3d:	48 39 d3             	cmp    rbx,rdx
  416e40:	0f 84 6e 22 00 00    	je     4190b4 <fmt_fp+0x26b4>
			long double round = 2/LDBL_EPSILON;
			long double small;
			if ((*d/i & 1) || (i==1000000000 && d>a && (d[-1]&1)))
  416e46:	a8 01                	test   al,0x1
  416e48:	0f 85 30 21 00 00    	jne    418f7e <fmt_fp+0x257e>
  416e4e:	81 f9 00 ca 9a 3b    	cmp    ecx,0x3b9aca00
  416e54:	75 09                	jne    416e5f <fmt_fp+0x45f>
  416e56:	48 39 ee             	cmp    rsi,rbp
  416e59:	0f 87 ea 20 00 00    	ja     418f49 <fmt_fp+0x2549>
  416e5f:	48 b8 c0 22 fc ff ff 	movabs rax,0xfffffffffffc22c0
  416e66:	ff ff ff 
  416e69:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
			long double round = 2/LDBL_EPSILON;
  416e6d:	48 b8 bc 22 fc ff ff 	movabs rax,0xfffffffffffc22bc
  416e74:	ff ff ff 
  416e77:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
				round += 2;
			if (x<i/2) small=0x0.8p0;
  416e7b:	48 b8 c4 22 fc ff ff 	movabs rax,0xfffffffffffc22c4
  416e82:	ff ff ff 
  416e85:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  416e89:	d9 c9                	fxch   st(1)
  416e8b:	d9 ca                	fxch   st(2)
  416e8d:	d9 c9                	fxch   st(1)
  416e8f:	e9 50 0a 00 00       	jmp    4178e4 <fmt_fp+0xee4>
  416e94:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	} else if (fl & MARK_POS) {
  416e98:	8b 44 24 14          	mov    eax,DWORD PTR [rsp+0x14]
  416e9c:	f6 c4 08             	test   ah,0x8
  416e9f:	0f 84 33 06 00 00    	je     4174d8 <fmt_fp+0xad8>
  416ea5:	bb 03 00 00 00       	mov    ebx,0x3
  416eaa:	41 bd 03 00 00 00    	mov    r13d,0x3
  416eb0:	bd 04 00 00 00       	mov    ebp,0x4
		prefix+=3;
  416eb5:	48 b8 53 1e fc ff ff 	movabs rax,0xfffffffffffc1e53
  416ebc:	ff ff ff 
  416ebf:	4c 01 f8             	add    rax,r15
	pl=1;
  416ec2:	c7 44 24 28 01 00 00 	mov    DWORD PTR [rsp+0x28],0x1
  416ec9:	00 
  416eca:	48 c7 44 24 38 01 00 	mov    QWORD PTR [rsp+0x38],0x1
  416ed1:	00 00 
		prefix+=3;
  416ed3:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  416ed8:	e9 e1 fb ff ff       	jmp    416abe <fmt_fp+0xbe>
  416edd:	0f 1f 00             	nop    DWORD PTR [rax]
	if (y) e2--;
  416ee0:	8b 44 24 60          	mov    eax,DWORD PTR [rsp+0x60]
	if ((t|32)=='a') {
  416ee4:	44 8b 5c 24 20       	mov    r11d,DWORD PTR [rsp+0x20]
	if (y) e2--;
  416ee9:	44 8d 48 ff          	lea    r9d,[rax-0x1]
	if ((t|32)=='a') {
  416eed:	41 83 cb 20          	or     r11d,0x20
	if (y) e2--;
  416ef1:	44 89 4c 24 60       	mov    DWORD PTR [rsp+0x60],r9d
	if ((t|32)=='a') {
  416ef6:	41 83 fb 61          	cmp    r11d,0x61
  416efa:	0f 85 3b fc ff ff    	jne    416b3b <fmt_fp+0x13b>
		if (t&32) prefix += 9;
  416f00:	48 8b 7c 24 30       	mov    rdi,QWORD PTR [rsp+0x30]
  416f05:	f6 44 24 20 20       	test   BYTE PTR [rsp+0x20],0x20
  416f0a:	48 8d 47 09          	lea    rax,[rdi+0x9]
  416f0e:	48 0f 44 c7          	cmove  rax,rdi
  416f12:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
		if (p<0 || p>=LDBL_MANT_DIG/4-1) re=0;
  416f17:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  416f1a:	83 f8 0e             	cmp    eax,0xe
  416f1d:	0f 87 9b 00 00 00    	ja     416fbe <fmt_fp+0x5be>
			while (re--) round*=16;
  416f23:	0f 84 b9 22 00 00    	je     4191e2 <fmt_fp+0x27e2>
  416f29:	83 f8 0d             	cmp    eax,0xd
  416f2c:	0f 84 13 23 00 00    	je     419245 <fmt_fp+0x2845>
  416f32:	83 f8 0c             	cmp    eax,0xc
  416f35:	0f 84 f7 22 00 00    	je     419232 <fmt_fp+0x2832>
  416f3b:	83 f8 0b             	cmp    eax,0xb
  416f3e:	0f 84 db 22 00 00    	je     41921f <fmt_fp+0x281f>
  416f44:	83 f8 0a             	cmp    eax,0xa
  416f47:	0f 84 16 23 00 00    	je     419263 <fmt_fp+0x2863>
  416f4d:	83 f8 09             	cmp    eax,0x9
  416f50:	0f 84 b2 20 00 00    	je     419008 <fmt_fp+0x2608>
  416f56:	83 f8 08             	cmp    eax,0x8
  416f59:	0f 84 2a 23 00 00    	je     419289 <fmt_fp+0x2889>
  416f5f:	83 f8 07             	cmp    eax,0x7
  416f62:	0f 84 0e 23 00 00    	je     419276 <fmt_fp+0x2876>
  416f68:	83 f8 06             	cmp    eax,0x6
  416f6b:	0f 84 3e 23 00 00    	je     4192af <fmt_fp+0x28af>
  416f71:	83 f8 05             	cmp    eax,0x5
  416f74:	0f 84 22 23 00 00    	je     41929c <fmt_fp+0x289c>
  416f7a:	83 f8 04             	cmp    eax,0x4
  416f7d:	0f 84 78 23 00 00    	je     4192fb <fmt_fp+0x28fb>
  416f83:	83 f8 03             	cmp    eax,0x3
  416f86:	0f 84 5c 23 00 00    	je     4192e8 <fmt_fp+0x28e8>
  416f8c:	83 f8 02             	cmp    eax,0x2
  416f8f:	0f 84 40 23 00 00    	je     4192d5 <fmt_fp+0x28d5>
  416f95:	83 f8 01             	cmp    eax,0x1
  416f98:	0f 84 24 23 00 00    	je     4192c2 <fmt_fp+0x28c2>
  416f9e:	48 b8 80 22 fc ff ff 	movabs rax,0xfffffffffffc2280
  416fa5:	ff ff ff 
  416fa8:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
			if (*prefix=='-') {
  416fac:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  416fb1:	80 38 2d             	cmp    BYTE PTR [rax],0x2d
  416fb4:	0f 84 ca 20 00 00    	je     419084 <fmt_fp+0x2684>
				y+=round;
  416fba:	dc c1                	fadd   st(1),st
				y-=round;
  416fbc:	de e9                	fsubp  st(1),st
		estr=fmt_u(e2<0 ? -e2 : e2, ebuf);
  416fbe:	44 89 c9             	mov    ecx,r9d
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  416fc1:	4c 8d 64 24 70       	lea    r12,[rsp+0x70]
  416fc6:	48 bf cd cc cc cc cc 	movabs rdi,0xcccccccccccccccd
  416fcd:	cc cc cc 
		estr=fmt_u(e2<0 ? -e2 : e2, ebuf);
  416fd0:	f7 d9                	neg    ecx
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  416fd2:	4c 89 e6             	mov    rsi,r12
		estr=fmt_u(e2<0 ? -e2 : e2, ebuf);
  416fd5:	41 0f 48 c9          	cmovs  ecx,r9d
  416fd9:	48 63 c9             	movsxd rcx,ecx
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  416fdc:	45 85 c9             	test   r9d,r9d
  416fdf:	0f 84 fe 1e 00 00    	je     418ee3 <fmt_fp+0x24e3>
  416fe5:	0f 1f 00             	nop    DWORD PTR [rax]
  416fe8:	48 89 c8             	mov    rax,rcx
  416feb:	48 83 ee 01          	sub    rsi,0x1
  416fef:	48 f7 e7             	mul    rdi
  416ff2:	48 89 c8             	mov    rax,rcx
  416ff5:	48 c1 ea 03          	shr    rdx,0x3
  416ff9:	4c 8d 04 92          	lea    r8,[rdx+rdx*4]
  416ffd:	4d 01 c0             	add    r8,r8
  417000:	4c 29 c0             	sub    rax,r8
  417003:	83 c0 30             	add    eax,0x30
  417006:	88 06                	mov    BYTE PTR [rsi],al
  417008:	48 89 c8             	mov    rax,rcx
  41700b:	48 89 d1             	mov    rcx,rdx
  41700e:	48 83 f8 09          	cmp    rax,0x9
  417012:	77 d4                	ja     416fe8 <fmt_fp+0x5e8>
		if (estr==ebuf) *--estr='0';
  417014:	4c 39 e6             	cmp    rsi,r12
  417017:	0f 84 c6 1e 00 00    	je     418ee3 <fmt_fp+0x24e3>
		*--estr = t+('p'-'a');
  41701d:	8b 7c 24 20          	mov    edi,DWORD PTR [rsp+0x20]
  417021:	48 8d 46 fe          	lea    rax,[rsi-0x2]
		*--estr = (e2<0 ? '-' : '+');
  417025:	41 c1 f9 1f          	sar    r9d,0x1f
		*--estr = t+('p'-'a');
  417029:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
		*--estr = (e2<0 ? '-' : '+');
  41702e:	41 83 e1 02          	and    r9d,0x2
		*--estr = t+('p'-'a');
  417032:	89 f8                	mov    eax,edi
		*--estr = (e2<0 ? '-' : '+');
  417034:	41 83 c1 2b          	add    r9d,0x2b
		*--estr = t+('p'-'a');
  417038:	83 c0 0f             	add    eax,0xf
		*--estr = (e2<0 ? '-' : '+');
  41703b:	44 88 4e ff          	mov    BYTE PTR [rsi-0x1],r9b
		*--estr = t+('p'-'a');
  41703f:	88 46 fe             	mov    BYTE PTR [rsi-0x2],al
			*s++=xdigits[x]|(t&32);
  417042:	89 fe                	mov    esi,edi
  417044:	83 e6 20             	and    esi,0x20
  417047:	f6 44 24 14 08       	test   BYTE PTR [rsp+0x14],0x8
  41704c:	0f 85 b8 18 00 00    	jne    41890a <fmt_fp+0x1f0a>
  417052:	d9 7c 24 5e          	fnstcw WORD PTR [rsp+0x5e]
		s=buf;
  417056:	4c 89 e2             	mov    rdx,r12
  417059:	48 bf d0 22 fc ff ff 	movabs rdi,0xfffffffffffc22d0
  417060:	ff ff ff 
  417063:	48 b9 90 20 fc ff ff 	movabs rcx,0xfffffffffffc2090
  41706a:	ff ff ff 
			y=16*(y-x);
  41706d:	42 d9 04 3f          	fld    DWORD PTR [rdi+r15*1]
			*s++=xdigits[x]|(t&32);
  417071:	4c 01 f9             	add    rcx,r15
			if (s-buf==1 && (y||p>0||(fl&ALT_FORM))) *s++='.';
  417074:	bf 01 00 00 00       	mov    edi,0x1
  417079:	0f b7 44 24 5e       	movzx  eax,WORD PTR [rsp+0x5e]
  41707e:	80 cc 0c             	or     ah,0xc
  417081:	d9 ee                	fldz   
  417083:	d9 ca                	fxch   st(2)
  417085:	66 89 44 24 5c       	mov    WORD PTR [rsp+0x5c],ax
  41708a:	eb 11                	jmp    41709d <fmt_fp+0x69d>
  41708c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
			*s++=xdigits[x]|(t&32);
  417090:	48 89 c2             	mov    rdx,rax
		} while (y);
  417093:	db ea                	fucomi st,st(2)
  417095:	7a 06                	jp     41709d <fmt_fp+0x69d>
  417097:	0f 84 69 20 00 00    	je     419106 <fmt_fp+0x2706>
			int x=y;
  41709d:	d9 c0                	fld    st(0)
  41709f:	d9 6c 24 5c          	fldcw  WORD PTR [rsp+0x5c]
  4170a3:	db 5c 24 08          	fistp  DWORD PTR [rsp+0x8]
  4170a7:	d9 6c 24 5e          	fldcw  WORD PTR [rsp+0x5e]
			y=16*(y-x);
  4170ab:	db 44 24 08          	fild   DWORD PTR [rsp+0x8]
			*s++=xdigits[x]|(t&32);
  4170af:	48 63 44 24 08       	movsxd rax,DWORD PTR [rsp+0x8]
  4170b4:	44 0f b6 1c 01       	movzx  r11d,BYTE PTR [rcx+rax*1]
			if (s-buf==1 && (y||p>0||(fl&ALT_FORM))) *s++='.';
  4170b9:	48 8d 42 01          	lea    rax,[rdx+0x1]
			y=16*(y-x);
  4170bd:	de e9                	fsubp  st(1),st
			*s++=xdigits[x]|(t&32);
  4170bf:	41 09 f3             	or     r11d,esi
  4170c2:	44 88 1a             	mov    BYTE PTR [rdx],r11b
			y=16*(y-x);
  4170c5:	d8 c9                	fmul   st,st(1)
			if (s-buf==1 && (y||p>0||(fl&ALT_FORM))) *s++='.';
  4170c7:	4c 39 e2             	cmp    rdx,r12
  4170ca:	75 c4                	jne    417090 <fmt_fp+0x690>
  4170cc:	44 8b 0c 24          	mov    r9d,DWORD PTR [rsp]
  4170d0:	45 85 c9             	test   r9d,r9d
  4170d3:	0f 8f f0 10 00 00    	jg     4181c9 <fmt_fp+0x17c9>
  4170d9:	db ea                	fucomi st,st(2)
  4170db:	41 0f 9a c0          	setp   r8b
  4170df:	44 0f 45 c7          	cmovne r8d,edi
  4170e3:	45 84 c0             	test   r8b,r8b
  4170e6:	0f 85 dd 10 00 00    	jne    4181c9 <fmt_fp+0x17c9>
  4170ec:	dd d8                	fstp   st(0)
  4170ee:	dd d8                	fstp   st(0)
  4170f0:	dd d8                	fstp   st(0)
  4170f2:	eb 06                	jmp    4170fa <fmt_fp+0x6fa>
  4170f4:	dd d8                	fstp   st(0)
  4170f6:	dd d8                	fstp   st(0)
  4170f8:	dd d8                	fstp   st(0)
		if (p > INT_MAX-2-(ebuf-estr)-pl)
  4170fa:	4c 89 e7             	mov    rdi,r12
  4170fd:	ba fd ff ff 7f       	mov    edx,0x7ffffffd
  417102:	48 2b 7c 24 28       	sub    rdi,QWORD PTR [rsp+0x28]
  417107:	48 63 0c 24          	movsxd rcx,DWORD PTR [rsp]
  41710b:	48 29 fa             	sub    rdx,rdi
  41710e:	48 89 7c 24 20       	mov    QWORD PTR [rsp+0x20],rdi
  417113:	48 29 da             	sub    rdx,rbx
  417116:	48 39 d1             	cmp    rcx,rdx
  417119:	0f 8f 9f 11 00 00    	jg     4182be <fmt_fp+0x18be>
		if (p && s-buf-2 < p)
  41711f:	4c 29 e0             	sub    rax,r12
  417122:	48 89 fe             	mov    rsi,rdi
  417125:	48 89 c3             	mov    rbx,rax
  417128:	48 89 44 24 48       	mov    QWORD PTR [rsp+0x48],rax
			l = (s-buf) + (ebuf-estr);
  41712d:	89 f8                	mov    eax,edi
		if (p && s-buf-2 < p)
  41712f:	8b 3c 24             	mov    edi,DWORD PTR [rsp]
			l = (s-buf) + (ebuf-estr);
  417132:	01 d8                	add    eax,ebx
		if (p && s-buf-2 < p)
  417134:	85 ff                	test   edi,edi
  417136:	74 0d                	je     417145 <fmt_fp+0x745>
  417138:	48 8d 53 ff          	lea    rdx,[rbx-0x1]
  41713c:	48 39 d1             	cmp    rcx,rdx
  41713f:	0f 8d 21 1e 00 00    	jge    418f66 <fmt_fp+0x2566>
			l = (s-buf) + (ebuf-estr);
  417145:	c7 44 24 08 00 00 00 	mov    DWORD PTR [rsp+0x8],0x0
  41714c:	00 
  41714d:	c7 44 24 38 00 00 00 	mov    DWORD PTR [rsp+0x38],0x0
  417154:	00 
		pad(f, ' ', w, pl+l, fl);
  417155:	44 01 e8             	add    eax,r13d
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  417158:	3b 44 24 58          	cmp    eax,DWORD PTR [rsp+0x58]
		pad(f, ' ', w, pl+l, fl);
  41715c:	89 44 24 18          	mov    DWORD PTR [rsp+0x18],eax
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  417160:	0f 9d 04 24          	setge  BYTE PTR [rsp]
  417164:	0f b6 04 24          	movzx  eax,BYTE PTR [rsp]
  417168:	f7 44 24 14 00 20 01 	test   DWORD PTR [rsp+0x14],0x12000
  41716f:	00 
  417170:	0f 85 c4 00 00 00    	jne    41723a <fmt_fp+0x83a>
  417176:	84 c0                	test   al,al
  417178:	0f 85 bc 00 00 00    	jne    41723a <fmt_fp+0x83a>
	l = w - l;
  41717e:	8b 6c 24 58          	mov    ebp,DWORD PTR [rsp+0x58]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  417182:	b8 00 01 00 00       	mov    eax,0x100
	l = w - l;
  417187:	2b 6c 24 18          	sub    ebp,DWORD PTR [rsp+0x18]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41718b:	4c 8d 94 24 90 01 00 	lea    r10,[rsp+0x190]
  417192:	00 
  417193:	39 c5                	cmp    ebp,eax
  417195:	4c 89 54 24 40       	mov    QWORD PTR [rsp+0x40],r10
  41719a:	4c 89 d7             	mov    rdi,r10
  41719d:	be 20 00 00 00       	mov    esi,0x20
  4171a2:	0f 4e c5             	cmovle eax,ebp
  4171a5:	48 63 d0             	movsxd rdx,eax
  4171a8:	48 b8 7c 79 fb ff ff 	movabs rax,0xfffffffffffb797c
  4171af:	ff ff ff 
  4171b2:	4c 01 f8             	add    rax,r15
  4171b5:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  4171b7:	81 fd ff 00 00 00    	cmp    ebp,0xff
  4171bd:	4c 8b 54 24 40       	mov    r10,QWORD PTR [rsp+0x40]
  4171c2:	0f 8e 90 20 00 00    	jle    419258 <fmt_fp+0x2858>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4171c8:	48 bf 60 e3 fb ff ff 	movabs rdi,0xfffffffffffbe360
  4171cf:	ff ff ff 
  4171d2:	41 8b 06             	mov    eax,DWORD PTR [r14]
  4171d5:	8d 9d 00 ff ff ff    	lea    ebx,[rbp-0x100]
  4171db:	4c 89 d5             	mov    rbp,r10
  4171de:	48 89 7c 24 40       	mov    QWORD PTR [rsp+0x40],rdi
  4171e3:	83 e0 20             	and    eax,0x20
  4171e6:	89 c6                	mov    esi,eax
  4171e8:	0f 84 e8 0f 00 00    	je     4181d6 <fmt_fp+0x17d6>
	for (; l >= sizeof pad; l -= sizeof pad)
  4171ee:	49 89 ea             	mov    r10,rbp
  4171f1:	81 fb ff 00 00 00    	cmp    ebx,0xff
  4171f7:	7e 47                	jle    417240 <fmt_fp+0x840>
  4171f9:	8d 83 00 e9 ff ff    	lea    eax,[rbx-0x1700]
  4171ff:	3d 00 e9 ff 7f       	cmp    eax,0x7fffe900
  417204:	0f 86 38 f2 ff ff    	jbe    416442 <fmt_fp.cold+0xb9>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41720a:	89 f0                	mov    eax,esi
	for (; l >= sizeof pad; l -= sizeof pad)
  41720c:	81 eb 00 01 00 00    	sub    ebx,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417212:	89 c6                	mov    esi,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  417214:	89 dd                	mov    ebp,ebx
  417216:	81 fb ff 00 00 00    	cmp    ebx,0xff
  41721c:	77 ee                	ja     41720c <fmt_fp+0x80c>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41721e:	85 f6                	test   esi,esi
  417220:	75 26                	jne    417248 <fmt_fp+0x848>
  417222:	48 b8 60 e3 fb ff ff 	movabs rax,0xfffffffffffbe360
  417229:	ff ff ff 
	out(f, pad, l);
  41722c:	48 63 f5             	movsxd rsi,ebp
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41722f:	4c 89 f2             	mov    rdx,r14
  417232:	4c 89 d7             	mov    rdi,r10
  417235:	4c 01 f8             	add    rax,r15
  417238:	ff d0                	call   rax
  41723a:	41 8b 36             	mov    esi,DWORD PTR [r14]
  41723d:	83 e6 20             	and    esi,0x20
  417240:	85 f6                	test   esi,esi
  417242:	0f 84 14 18 00 00    	je     418a5c <fmt_fp+0x205c>
		pad(f, '0', w, pl+l, fl^ZERO_PAD);
  417248:	8b 44 24 14          	mov    eax,DWORD PTR [rsp+0x14]
  41724c:	35 00 00 01 00       	xor    eax,0x10000
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  417251:	a9 00 20 01 00       	test   eax,0x12000
  417256:	0f 85 d0 10 00 00    	jne    41832c <fmt_fp+0x192c>
  41725c:	80 3c 24 00          	cmp    BYTE PTR [rsp],0x0
  417260:	0f 85 c6 10 00 00    	jne    41832c <fmt_fp+0x192c>
	l = w - l;
  417266:	8b 6c 24 58          	mov    ebp,DWORD PTR [rsp+0x58]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41726a:	b8 00 01 00 00       	mov    eax,0x100
	l = w - l;
  41726f:	2b 6c 24 18          	sub    ebp,DWORD PTR [rsp+0x18]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  417273:	4c 8d 94 24 90 01 00 	lea    r10,[rsp+0x190]
  41727a:	00 
  41727b:	39 c5                	cmp    ebp,eax
  41727d:	4c 89 54 24 30       	mov    QWORD PTR [rsp+0x30],r10
  417282:	4c 89 d7             	mov    rdi,r10
  417285:	be 30 00 00 00       	mov    esi,0x30
  41728a:	0f 4e c5             	cmovle eax,ebp
  41728d:	48 63 d0             	movsxd rdx,eax
  417290:	48 b8 7c 79 fb ff ff 	movabs rax,0xfffffffffffb797c
  417297:	ff ff ff 
  41729a:	4c 01 f8             	add    rax,r15
  41729d:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  41729f:	81 fd ff 00 00 00    	cmp    ebp,0xff
  4172a5:	4c 8b 54 24 30       	mov    r10,QWORD PTR [rsp+0x30]
  4172aa:	0f 8e 64 1f 00 00    	jle    419214 <fmt_fp+0x2814>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4172b0:	41 8b 06             	mov    eax,DWORD PTR [r14]
  4172b3:	44 8d ad 00 ff ff ff 	lea    r13d,[rbp-0x100]
  4172ba:	4c 89 d5             	mov    rbp,r10
  4172bd:	48 bb 60 e3 fb ff ff 	movabs rbx,0xfffffffffffbe360
  4172c4:	ff ff ff 
  4172c7:	83 e0 20             	and    eax,0x20
  4172ca:	89 c1                	mov    ecx,eax
  4172cc:	0f 84 6e 0f 00 00    	je     418240 <fmt_fp+0x1840>
	for (; l >= sizeof pad; l -= sizeof pad)
  4172d2:	49 89 ea             	mov    r10,rbp
  4172d5:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  4172dc:	0f 8e 50 10 00 00    	jle    418332 <fmt_fp+0x1932>
  4172e2:	41 8d 85 00 e9 ff ff 	lea    eax,[r13-0x1700]
  4172e9:	3d 00 e9 ff 7f       	cmp    eax,0x7fffe900
  4172ee:	0f 86 2a f4 ff ff    	jbe    41671e <fmt_fp.cold+0x395>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4172f4:	89 c8                	mov    eax,ecx
	for (; l >= sizeof pad; l -= sizeof pad)
  4172f6:	41 81 ed 00 01 00 00 	sub    r13d,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4172fd:	89 c1                	mov    ecx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  4172ff:	44 89 ed             	mov    ebp,r13d
  417302:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  417309:	77 eb                	ja     4172f6 <fmt_fp+0x8f6>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41730b:	85 c9                	test   ecx,ecx
  41730d:	0f 84 01 10 00 00    	je     418314 <fmt_fp+0x1914>
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  417313:	8b 44 24 08          	mov    eax,DWORD PTR [rsp+0x8]
	for (; l >= sizeof pad; l -= sizeof pad)
  417317:	89 c3                	mov    ebx,eax
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  417319:	85 c0                	test   eax,eax
  41731b:	0f 8e e2 00 00 00    	jle    417403 <fmt_fp+0xa03>
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  417321:	48 63 6c 24 08       	movsxd rbp,DWORD PTR [rsp+0x8]
  417326:	ba 00 01 00 00       	mov    edx,0x100
  41732b:	be 30 00 00 00       	mov    esi,0x30
  417330:	81 7c 24 38 01 01 00 	cmp    DWORD PTR [rsp+0x38],0x101
  417337:	00 
  417338:	4c 8d 94 24 90 01 00 	lea    r10,[rsp+0x190]
  41733f:	00 
  417340:	48 b8 7c 79 fb ff ff 	movabs rax,0xfffffffffffb797c
  417347:	ff ff ff 
  41734a:	48 0f 42 d5          	cmovb  rdx,rbp
  41734e:	4c 89 54 24 30       	mov    QWORD PTR [rsp+0x30],r10
  417353:	4c 89 d7             	mov    rdi,r10
  417356:	4c 01 f8             	add    rax,r15
  417359:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  41735b:	81 fd ff 00 00 00    	cmp    ebp,0xff
  417361:	4c 8b 54 24 30       	mov    r10,QWORD PTR [rsp+0x30]
  417366:	0f 8e 41 1e 00 00    	jle    4191ad <fmt_fp+0x27ad>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41736c:	41 8b 06             	mov    eax,DWORD PTR [r14]
  41736f:	81 eb 00 01 00 00    	sub    ebx,0x100
  417375:	4d 89 d4             	mov    r12,r10
  417378:	48 bd 60 e3 fb ff ff 	movabs rbp,0xfffffffffffbe360
  41737f:	ff ff ff 
  417382:	83 e0 20             	and    eax,0x20
  417385:	89 c1                	mov    ecx,eax
  417387:	0f 84 83 0e 00 00    	je     418210 <fmt_fp+0x1810>
	for (; l >= sizeof pad; l -= sizeof pad)
  41738d:	4d 89 e2             	mov    r10,r12
  417390:	81 fb ff 00 00 00    	cmp    ebx,0xff
  417396:	7e 4b                	jle    4173e3 <fmt_fp+0x9e3>
  417398:	8d 83 00 e9 ff ff    	lea    eax,[rbx-0x1700]
  41739e:	3d 00 e9 ff 7f       	cmp    eax,0x7fffe900
  4173a3:	0f 86 e2 f4 ff ff    	jbe    41688b <fmt_fp.cold+0x502>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4173a9:	89 c8                	mov    eax,ecx
	for (; l >= sizeof pad; l -= sizeof pad)
  4173ab:	81 eb 00 01 00 00    	sub    ebx,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4173b1:	89 c1                	mov    ecx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  4173b3:	81 fb ff 00 00 00    	cmp    ebx,0xff
  4173b9:	77 f0                	ja     4173ab <fmt_fp+0x9ab>
  4173bb:	89 5c 24 08          	mov    DWORD PTR [rsp+0x8],ebx
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4173bf:	85 c9                	test   ecx,ecx
  4173c1:	75 40                	jne    417403 <fmt_fp+0xa03>
  4173c3:	48 b8 60 e3 fb ff ff 	movabs rax,0xfffffffffffbe360
  4173ca:	ff ff ff 
	out(f, pad, l);
  4173cd:	48 63 74 24 08       	movsxd rsi,DWORD PTR [rsp+0x8]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4173d2:	4c 89 f2             	mov    rdx,r14
  4173d5:	4c 89 d7             	mov    rdi,r10
  4173d8:	4c 01 f8             	add    rax,r15
  4173db:	ff d0                	call   rax
  4173dd:	41 8b 0e             	mov    ecx,DWORD PTR [r14]
  4173e0:	83 e1 20             	and    ecx,0x20
  4173e3:	85 c9                	test   ecx,ecx
  4173e5:	75 1c                	jne    417403 <fmt_fp+0xa03>
  4173e7:	48 8b 74 24 20       	mov    rsi,QWORD PTR [rsp+0x20]
  4173ec:	48 8b 7c 24 28       	mov    rdi,QWORD PTR [rsp+0x28]
  4173f1:	4c 89 f2             	mov    rdx,r14
  4173f4:	48 b8 60 e3 fb ff ff 	movabs rax,0xfffffffffffbe360
  4173fb:	ff ff ff 
  4173fe:	4c 01 f8             	add    rax,r15
  417401:	ff d0                	call   rax
		pad(f, ' ', w, pl+l, fl^LEFT_ADJ);
  417403:	8b 44 24 14          	mov    eax,DWORD PTR [rsp+0x14]
  417407:	80 f4 20             	xor    ah,0x20
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41740a:	a9 00 20 01 00       	test   eax,0x12000
  41740f:	0f 85 b1 00 00 00    	jne    4174c6 <fmt_fp+0xac6>
  417415:	80 3c 24 00          	cmp    BYTE PTR [rsp],0x0
  417419:	0f 85 a7 00 00 00    	jne    4174c6 <fmt_fp+0xac6>
	l = w - l;
  41741f:	44 8b 64 24 58       	mov    r12d,DWORD PTR [rsp+0x58]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  417424:	b8 00 01 00 00       	mov    eax,0x100
	l = w - l;
  417429:	44 2b 64 24 18       	sub    r12d,DWORD PTR [rsp+0x18]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41742e:	4c 8d 94 24 90 01 00 	lea    r10,[rsp+0x190]
  417435:	00 
  417436:	41 39 c4             	cmp    r12d,eax
  417439:	4c 89 14 24          	mov    QWORD PTR [rsp],r10
  41743d:	4c 89 d7             	mov    rdi,r10
  417440:	be 20 00 00 00       	mov    esi,0x20
  417445:	41 0f 4e c4          	cmovle eax,r12d
  417449:	48 63 d0             	movsxd rdx,eax
  41744c:	48 b8 7c 79 fb ff ff 	movabs rax,0xfffffffffffb797c
  417453:	ff ff ff 
  417456:	4c 01 f8             	add    rax,r15
  417459:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  41745b:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  417462:	4c 8b 14 24          	mov    r10,QWORD PTR [rsp]
  417466:	0f 8e 9d 1d 00 00    	jle    419209 <fmt_fp+0x2809>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41746c:	41 8b 06             	mov    eax,DWORD PTR [r14]
  41746f:	41 8d ac 24 00 ff ff 	lea    ebp,[r12-0x100]
  417476:	ff 
  417477:	4d 89 d5             	mov    r13,r10
  41747a:	48 bb 60 e3 fb ff ff 	movabs rbx,0xfffffffffffbe360
  417481:	ff ff ff 
  417484:	89 c1                	mov    ecx,eax
  417486:	83 e1 20             	and    ecx,0x20
  417489:	0f 84 e3 0d 00 00    	je     418272 <fmt_fp+0x1872>
	for (; l >= sizeof pad; l -= sizeof pad)
  41748f:	4d 89 ea             	mov    r10,r13
  417492:	81 fd ff 00 00 00    	cmp    ebp,0xff
  417498:	7e 2c                	jle    4174c6 <fmt_fp+0xac6>
  41749a:	8d 85 00 e9 ff ff    	lea    eax,[rbp-0x1700]
  4174a0:	3d 00 e9 ff 7f       	cmp    eax,0x7fffe900
  4174a5:	0f 86 9f f4 ff ff    	jbe    41694a <fmt_fp.cold+0x5c1>
  4174ab:	81 ed 00 01 00 00    	sub    ebp,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4174b1:	89 ca                	mov    edx,ecx
	for (; l >= sizeof pad; l -= sizeof pad)
  4174b3:	41 89 ec             	mov    r12d,ebp
  4174b6:	81 fd ff 00 00 00    	cmp    ebp,0xff
  4174bc:	77 ed                	ja     4174ab <fmt_fp+0xaab>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4174be:	85 d2                	test   edx,edx
  4174c0:	0f 84 0e 1c 00 00    	je     4190d4 <fmt_fp+0x26d4>
		return MAX(w, pl+l);
  4174c6:	8b 5c 24 18          	mov    ebx,DWORD PTR [rsp+0x18]
  4174ca:	8b 44 24 58          	mov    eax,DWORD PTR [rsp+0x58]
  4174ce:	39 c3                	cmp    ebx,eax
  4174d0:	0f 4d c3             	cmovge eax,ebx
  4174d3:	e9 a1 02 00 00       	jmp    417779 <fmt_fp+0xd79>
	} else if (fl & PAD_POS) {
  4174d8:	a8 01                	test   al,0x1
  4174da:	0f 84 05 03 00 00    	je     4177e5 <fmt_fp+0xde5>
  4174e0:	bb 03 00 00 00       	mov    ebx,0x3
  4174e5:	41 bd 03 00 00 00    	mov    r13d,0x3
  4174eb:	bd 04 00 00 00       	mov    ebp,0x4
		prefix+=6;
  4174f0:	48 b8 56 1e fc ff ff 	movabs rax,0xfffffffffffc1e56
  4174f7:	ff ff ff 
  4174fa:	4c 01 f8             	add    rax,r15
	pl=1;
  4174fd:	c7 44 24 28 01 00 00 	mov    DWORD PTR [rsp+0x28],0x1
  417504:	00 
  417505:	48 c7 44 24 38 01 00 	mov    QWORD PTR [rsp+0x38],0x1
  41750c:	00 00 
		prefix+=6;
  41750e:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  417513:	e9 a6 f5 ff ff       	jmp    416abe <fmt_fp+0xbe>
  417518:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41751f:	00 
		int sh=MIN(9,-e2), need=1+(p+LDBL_MANT_DIG/3U+8)/9;
  417520:	44 89 c9             	mov    ecx,r9d
		if (!*a) a++;
  417523:	8b 45 00             	mov    eax,DWORD PTR [rbp+0x0]
  417526:	45 31 c9             	xor    r9d,r9d
		int sh=MIN(9,-e2), need=1+(p+LDBL_MANT_DIG/3U+8)/9;
  417529:	f7 d9                	neg    ecx
		for (d=a; d<z; d++) {
  41752b:	48 39 dd             	cmp    rbp,rbx
  41752e:	0f 82 93 f7 ff ff    	jb     416cc7 <fmt_fp+0x2c7>
		if (!*a) a++;
  417534:	48 8d 55 04          	lea    rdx,[rbp+0x4]
  417538:	85 c0                	test   eax,eax
  41753a:	48 0f 44 ea          	cmove  rbp,rdx
  41753e:	e9 d9 f7 ff ff       	jmp    416d1c <fmt_fp+0x31c>
  417543:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		char *s = (t&32)?"inf":"INF";
  417548:	48 b8 63 1e fc ff ff 	movabs rax,0xfffffffffffc1e63
  41754f:	ff ff ff 
  417552:	4d 8d 24 07          	lea    r12,[r15+rax*1]
  417556:	8b 44 24 20          	mov    eax,DWORD PTR [rsp+0x20]
  41755a:	83 e0 20             	and    eax,0x20
  41755d:	75 0e                	jne    41756d <fmt_fp+0xb6d>
  41755f:	48 ba 67 1e fc ff ff 	movabs rdx,0xfffffffffffc1e67
  417566:	ff ff ff 
  417569:	4d 8d 24 17          	lea    r12,[r15+rdx*1]
		if (y!=y) s=(t&32)?"nan":"NAN";
  41756d:	db ac 24 80 1e 00 00 	fld    TBYTE PTR [rsp+0x1e80]
  417574:	df e8                	fucomip st,st(0)
  417576:	7b 16                	jnp    41758e <fmt_fp+0xb8e>
  417578:	48 ba 6f 1e fc ff ff 	movabs rdx,0xfffffffffffc1e6f
  41757f:	ff ff ff 
  417582:	4d 8d 24 17          	lea    r12,[r15+rdx*1]
  417586:	85 c0                	test   eax,eax
  417588:	0f 84 87 02 00 00    	je     417815 <fmt_fp+0xe15>
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41758e:	39 6c 24 58          	cmp    DWORD PTR [rsp+0x58],ebp
  417592:	0f 9e c3             	setle  bl
  417595:	f7 44 24 14 00 20 00 	test   DWORD PTR [rsp+0x14],0x2000
  41759c:	00 
  41759d:	0f 85 de 00 00 00    	jne    417681 <fmt_fp+0xc81>
  4175a3:	84 db                	test   bl,bl
  4175a5:	0f 85 d6 00 00 00    	jne    417681 <fmt_fp+0xc81>
	l = w - l;
  4175ab:	8b 4c 24 58          	mov    ecx,DWORD PTR [rsp+0x58]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  4175af:	b8 00 01 00 00       	mov    eax,0x100
  4175b4:	be 20 00 00 00       	mov    esi,0x20
  4175b9:	4c 8d 94 24 90 01 00 	lea    r10,[rsp+0x190]
  4175c0:	00 
  4175c1:	4c 89 14 24          	mov    QWORD PTR [rsp],r10
  4175c5:	4c 89 d7             	mov    rdi,r10
	l = w - l;
  4175c8:	29 e9                	sub    ecx,ebp
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  4175ca:	39 c1                	cmp    ecx,eax
  4175cc:	89 4c 24 08          	mov    DWORD PTR [rsp+0x8],ecx
  4175d0:	0f 4e c1             	cmovle eax,ecx
  4175d3:	48 63 d0             	movsxd rdx,eax
  4175d6:	48 b8 7c 79 fb ff ff 	movabs rax,0xfffffffffffb797c
  4175dd:	ff ff ff 
  4175e0:	4c 01 f8             	add    rax,r15
  4175e3:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  4175e5:	8b 4c 24 08          	mov    ecx,DWORD PTR [rsp+0x8]
  4175e9:	4c 8b 14 24          	mov    r10,QWORD PTR [rsp]
  4175ed:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  4175f3:	0f 8e 3b 1b 00 00    	jle    419134 <fmt_fp+0x2734>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4175f9:	48 bf 60 e3 fb ff ff 	movabs rdi,0xfffffffffffbe360
  417600:	ff ff ff 
  417603:	41 8b 06             	mov    eax,DWORD PTR [r14]
  417606:	89 2c 24             	mov    DWORD PTR [rsp],ebp
  417609:	89 dd                	mov    ebp,ebx
  41760b:	48 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],rdi
  417610:	44 8d a9 00 ff ff ff 	lea    r13d,[rcx-0x100]
  417617:	4c 89 d3             	mov    rbx,r10
  41761a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  417620:	83 e0 20             	and    eax,0x20
  417623:	89 c6                	mov    esi,eax
  417625:	0f 84 3d 02 00 00    	je     417868 <fmt_fp+0xe68>
	for (; l >= sizeof pad; l -= sizeof pad)
  41762b:	49 89 da             	mov    r10,rbx
  41762e:	89 eb                	mov    ebx,ebp
  417630:	8b 2c 24             	mov    ebp,DWORD PTR [rsp]
  417633:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  41763a:	7e 4b                	jle    417687 <fmt_fp+0xc87>
  41763c:	41 8d 85 00 e9 ff ff 	lea    eax,[r13-0x1700]
  417643:	3d 00 e9 ff 7f       	cmp    eax,0x7fffe900
  417648:	0f 86 3b ed ff ff    	jbe    416389 <fmt_fp.cold>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41764e:	89 f0                	mov    eax,esi
	for (; l >= sizeof pad; l -= sizeof pad)
  417650:	41 81 ed 00 01 00 00 	sub    r13d,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417657:	89 c6                	mov    esi,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  417659:	44 89 e9             	mov    ecx,r13d
  41765c:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  417663:	77 eb                	ja     417650 <fmt_fp+0xc50>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417665:	85 f6                	test   esi,esi
  417667:	75 26                	jne    41768f <fmt_fp+0xc8f>
  417669:	48 b8 60 e3 fb ff ff 	movabs rax,0xfffffffffffbe360
  417670:	ff ff ff 
	out(f, pad, l);
  417673:	48 63 f1             	movsxd rsi,ecx
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417676:	4c 89 f2             	mov    rdx,r14
  417679:	4c 89 d7             	mov    rdi,r10
  41767c:	4c 01 f8             	add    rax,r15
  41767f:	ff d0                	call   rax
  417681:	41 8b 36             	mov    esi,DWORD PTR [r14]
  417684:	83 e6 20             	and    esi,0x20
  417687:	85 f6                	test   esi,esi
  417689:	0f 84 4a 0c 00 00    	je     4182d9 <fmt_fp+0x18d9>
		pad(f, ' ', w, 3+pl, fl^LEFT_ADJ);
  41768f:	8b 44 24 14          	mov    eax,DWORD PTR [rsp+0x14]
  417693:	80 f4 20             	xor    ah,0x20
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  417696:	a9 00 20 01 00       	test   eax,0x12000
  41769b:	0f 85 cf 00 00 00    	jne    417770 <fmt_fp+0xd70>
  4176a1:	84 db                	test   bl,bl
  4176a3:	0f 85 c7 00 00 00    	jne    417770 <fmt_fp+0xd70>
	l = w - l;
  4176a9:	44 8b 6c 24 58       	mov    r13d,DWORD PTR [rsp+0x58]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  4176ae:	b8 00 01 00 00       	mov    eax,0x100
  4176b3:	be 20 00 00 00       	mov    esi,0x20
  4176b8:	4c 8d 94 24 90 01 00 	lea    r10,[rsp+0x190]
  4176bf:	00 
  4176c0:	4c 89 14 24          	mov    QWORD PTR [rsp],r10
  4176c4:	4c 89 d7             	mov    rdi,r10
	l = w - l;
  4176c7:	41 29 ed             	sub    r13d,ebp
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  4176ca:	41 39 c5             	cmp    r13d,eax
  4176cd:	41 0f 4e c5          	cmovle eax,r13d
  4176d1:	48 63 d0             	movsxd rdx,eax
  4176d4:	48 b8 7c 79 fb ff ff 	movabs rax,0xfffffffffffb797c
  4176db:	ff ff ff 
  4176de:	4c 01 f8             	add    rax,r15
  4176e1:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  4176e3:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  4176ea:	4c 8b 14 24          	mov    r10,QWORD PTR [rsp]
  4176ee:	0f 8e 35 1a 00 00    	jle    419129 <fmt_fp+0x2729>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4176f4:	41 8b 06             	mov    eax,DWORD PTR [r14]
  4176f7:	45 8d a5 00 ff ff ff 	lea    r12d,[r13-0x100]
  4176fe:	4d 89 d5             	mov    r13,r10
  417701:	48 bb 60 e3 fb ff ff 	movabs rbx,0xfffffffffffbe360
  417708:	ff ff ff 
  41770b:	89 c1                	mov    ecx,eax
  41770d:	0f 1f 00             	nop    DWORD PTR [rax]
  417710:	83 e1 20             	and    ecx,0x20
  417713:	0f 84 17 01 00 00    	je     417830 <fmt_fp+0xe30>
	for (; l >= sizeof pad; l -= sizeof pad)
  417719:	4d 89 ea             	mov    r10,r13
  41771c:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  417723:	7e 4b                	jle    417770 <fmt_fp+0xd70>
  417725:	41 8d 84 24 00 e9 ff 	lea    eax,[r12-0x1700]
  41772c:	ff 
  41772d:	3d 00 e9 ff 7f       	cmp    eax,0x7fffe900
  417732:	0f 86 77 ee ff ff    	jbe    4165af <fmt_fp.cold+0x226>
  417738:	41 81 ec 00 01 00 00 	sub    r12d,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41773f:	89 ca                	mov    edx,ecx
	for (; l >= sizeof pad; l -= sizeof pad)
  417741:	45 89 e5             	mov    r13d,r12d
  417744:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  41774b:	77 eb                	ja     417738 <fmt_fp+0xd38>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41774d:	85 d2                	test   edx,edx
  41774f:	75 1f                	jne    417770 <fmt_fp+0xd70>
  417751:	48 b8 60 e3 fb ff ff 	movabs rax,0xfffffffffffbe360
  417758:	ff ff ff 
	out(f, pad, l);
  41775b:	49 63 f5             	movsxd rsi,r13d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41775e:	4c 89 f2             	mov    rdx,r14
  417761:	4c 89 d7             	mov    rdi,r10
  417764:	4c 01 f8             	add    rax,r15
  417767:	ff d0                	call   rax
  417769:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		return MAX(w, 3+pl);
  417770:	8b 44 24 58          	mov    eax,DWORD PTR [rsp+0x58]
  417774:	39 e8                	cmp    eax,ebp
  417776:	0f 4c c5             	cmovl  eax,ebp
	}

	pad(f, ' ', w, pl+l, fl^LEFT_ADJ);

	return MAX(w, pl+l);
}
  417779:	48 81 c4 48 1e 00 00 	add    rsp,0x1e48
  417780:	5b                   	pop    rbx
  417781:	5d                   	pop    rbp
  417782:	41 5c                	pop    r12
  417784:	41 5d                	pop    r13
  417786:	41 5e                	pop    r14
  417788:	41 5f                	pop    r15
  41778a:	c3                   	ret    
	if (a<z) for (i=10, e=9*(r-a); *a>=i; i*=10, e++);
  41778b:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
	j = p - ((t|32)!='f')*e - ((t|32)=='g' && p);
  417790:	31 c9                	xor    ecx,ecx
  417792:	41 83 fb 66          	cmp    r11d,0x66
	if (a<z) for (i=10, e=9*(r-a); *a>=i; i*=10, e++);
  417796:	8b 55 00             	mov    edx,DWORD PTR [rbp+0x0]
	j = p - ((t|32)!='f')*e - ((t|32)=='g' && p);
  417799:	0f 95 c1             	setne  cl
	if (a<z) for (i=10, e=9*(r-a); *a>=i; i*=10, e++);
  41779c:	48 29 e8             	sub    rax,rbp
  41779f:	48 c1 f8 02          	sar    rax,0x2
  4177a3:	8d 3c c0             	lea    edi,[rax+rax*8]
  4177a6:	b8 0a 00 00 00       	mov    eax,0xa
  4177ab:	83 fa 09             	cmp    edx,0x9
  4177ae:	76 0c                	jbe    4177bc <fmt_fp+0xdbc>
  4177b0:	8d 04 80             	lea    eax,[rax+rax*4]
  4177b3:	83 c7 01             	add    edi,0x1
  4177b6:	01 c0                	add    eax,eax
  4177b8:	39 d0                	cmp    eax,edx
  4177ba:	76 f4                	jbe    4177b0 <fmt_fp+0xdb0>
	j = p - ((t|32)!='f')*e - ((t|32)=='g' && p);
  4177bc:	0f af cf             	imul   ecx,edi
  4177bf:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  4177c2:	29 c8                	sub    eax,ecx
  4177c4:	e9 96 f5 ff ff       	jmp    416d5f <fmt_fp+0x35f>
	if (y) y *= 0x1p28, e2-=28;
  4177c9:	48 b8 d4 22 fc ff ff 	movabs rax,0xfffffffffffc22d4
  4177d0:	ff ff ff 
  4177d3:	41 83 e9 1c          	sub    r9d,0x1c
  4177d7:	42 d8 0c 38          	fmul   DWORD PTR [rax+r15*1]
  4177db:	44 89 4c 24 60       	mov    DWORD PTR [rsp+0x60],r9d
  4177e0:	e9 7a f3 ff ff       	jmp    416b5f <fmt_fp+0x15f>
	} else if (fl & PAD_POS) {
  4177e5:	bb 02 00 00 00       	mov    ebx,0x2
  4177ea:	41 bd 02 00 00 00    	mov    r13d,0x2
  4177f0:	bd 03 00 00 00       	mov    ebp,0x3
	} else prefix++, pl=0;
  4177f5:	48 b8 51 1e fc ff ff 	movabs rax,0xfffffffffffc1e51
  4177fc:	ff ff ff 
	} else if (fl & PAD_POS) {
  4177ff:	48 c7 44 24 38 00 00 	mov    QWORD PTR [rsp+0x38],0x0
  417806:	00 00 
	} else prefix++, pl=0;
  417808:	4c 01 f8             	add    rax,r15
  41780b:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  417810:	e9 a9 f2 ff ff       	jmp    416abe <fmt_fp+0xbe>
		if (y!=y) s=(t&32)?"nan":"NAN";
  417815:	48 b8 6b 1e fc ff ff 	movabs rax,0xfffffffffffc1e6b
  41781c:	ff ff ff 
  41781f:	4d 8d 24 07          	lea    r12,[r15+rax*1]
  417823:	e9 66 fd ff ff       	jmp    41758e <fmt_fp+0xb8e>
  417828:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41782f:	00 
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417830:	4c 89 f2             	mov    rdx,r14
  417833:	be 00 01 00 00       	mov    esi,0x100
  417838:	49 8d 04 1f          	lea    rax,[r15+rbx*1]
  41783c:	4c 89 ef             	mov    rdi,r13
  41783f:	ff d0                	call   rax
  417841:	41 8b 0e             	mov    ecx,DWORD PTR [r14]
  417844:	89 ca                	mov    edx,ecx
  417846:	83 e2 20             	and    edx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  417849:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  417850:	0f 8e be 16 00 00    	jle    418f14 <fmt_fp+0x2514>
  417856:	41 81 ec 00 01 00 00 	sub    r12d,0x100
  41785d:	e9 ae fe ff ff       	jmp    417710 <fmt_fp+0xd10>
  417862:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417868:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
  41786d:	be 00 01 00 00       	mov    esi,0x100
  417872:	4c 89 f2             	mov    rdx,r14
  417875:	48 89 df             	mov    rdi,rbx
  417878:	4c 01 f8             	add    rax,r15
  41787b:	ff d0                	call   rax
  41787d:	41 8b 06             	mov    eax,DWORD PTR [r14]
	for (; l >= sizeof pad; l -= sizeof pad)
  417880:	44 89 e9             	mov    ecx,r13d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417883:	89 c6                	mov    esi,eax
  417885:	83 e6 20             	and    esi,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  417888:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  41788f:	0f 8e 5d 16 00 00    	jle    418ef2 <fmt_fp+0x24f2>
  417895:	41 81 ed 00 01 00 00 	sub    r13d,0x100
  41789c:	e9 7f fd ff ff       	jmp    417620 <fmt_fp+0xc20>
			if ((*d/i & 1) || (i==1000000000 && d>a && (d[-1]&1)))
  4178a1:	a8 01                	test   al,0x1
  4178a3:	0f 84 93 16 00 00    	je     418f3c <fmt_fp+0x253c>
				round += 2;
  4178a9:	48 b8 20 23 fc ff ff 	movabs rax,0xfffffffffffc2320
  4178b0:	ff ff ff 
  4178b3:	41 db 2c 07          	fld    TBYTE PTR [r15+rax*1]
			if (x<i/2) small=0x0.8p0;
  4178b7:	d1 f9                	sar    ecx,1
  4178b9:	44 39 c1             	cmp    ecx,r8d
  4178bc:	0f 87 d1 17 00 00    	ja     419093 <fmt_fp+0x2693>
			else if (x==i/2 && d+1==z) small=0x1.0p0;
  4178c2:	0f 84 f4 17 00 00    	je     4190bc <fmt_fp+0x26bc>
  4178c8:	48 b8 c8 22 fc ff ff 	movabs rax,0xfffffffffffc22c8
  4178cf:	ff ff ff 
  4178d2:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
			else small=0x1.8p0;
  4178d6:	48 b8 cc 22 fc ff ff 	movabs rax,0xfffffffffffc22cc
  4178dd:	ff ff ff 
  4178e0:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
			if (pl && *prefix=='-') round*=-1, small*=-1;
  4178e4:	44 8b 64 24 28       	mov    r12d,DWORD PTR [rsp+0x28]
  4178e9:	45 85 e4             	test   r12d,r12d
  4178ec:	74 14                	je     417902 <fmt_fp+0xf02>
  4178ee:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  4178f3:	80 38 2d             	cmp    BYTE PTR [rax],0x2d
  4178f6:	75 0e                	jne    417906 <fmt_fp+0xf06>
  4178f8:	dd d8                	fstp   st(0)
  4178fa:	d9 c9                	fxch   st(1)
  4178fc:	d9 e0                	fchs   
  4178fe:	d9 c9                	fxch   st(1)
  417900:	eb 06                	jmp    417908 <fmt_fp+0xf08>
  417902:	dd d9                	fstp   st(1)
  417904:	eb 02                	jmp    417908 <fmt_fp+0xf08>
  417906:	dd d9                	fstp   st(1)
			if (round+small != round) {
  417908:	d8 c1                	fadd   st,st(1)
			*d -= x;
  41790a:	44 89 c8             	mov    eax,r9d
  41790d:	44 29 c0             	sub    eax,r8d
			if (round+small != round) {
  417910:	df e9                	fucomip st,st(1)
  417912:	dd d8                	fstp   st(0)
  417914:	0f 8a 9e 10 00 00    	jp     4189b8 <fmt_fp+0x1fb8>
  41791a:	0f 85 98 10 00 00    	jne    4189b8 <fmt_fp+0x1fb8>
			*d -= x;
  417920:	89 06                	mov    DWORD PTR [rsi],eax
		if (x || d+1!=z) {
  417922:	48 83 c6 04          	add    rsi,0x4
		if (z>d+1) z=d+1;
  417926:	48 39 f3             	cmp    rbx,rsi
  417929:	48 0f 47 de          	cmova  rbx,rsi
	for (; z>a && !z[-1]; z--);
  41792d:	48 39 dd             	cmp    rbp,rbx
  417930:	72 0f                	jb     417941 <fmt_fp+0xf41>
  417932:	eb 16                	jmp    41794a <fmt_fp+0xf4a>
  417934:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  417938:	48 83 eb 04          	sub    rbx,0x4
  41793c:	48 39 eb             	cmp    rbx,rbp
  41793f:	76 09                	jbe    41794a <fmt_fp+0xf4a>
  417941:	44 8b 43 fc          	mov    r8d,DWORD PTR [rbx-0x4]
  417945:	45 85 c0             	test   r8d,r8d
  417948:	74 ee                	je     417938 <fmt_fp+0xf38>
	if ((t|32)=='g') {
  41794a:	41 83 fb 67          	cmp    r11d,0x67
  41794e:	0f 84 61 0a 00 00    	je     4183b5 <fmt_fp+0x19b5>
	if (p > INT_MAX-1-(p || (fl&ALT_FORM)))
  417954:	8b 34 24             	mov    esi,DWORD PTR [rsp]
  417957:	85 f6                	test   esi,esi
  417959:	0f 85 46 09 00 00    	jne    4182a5 <fmt_fp+0x18a5>
	l = 1 + p + (p || (fl&ALT_FORM));
  41795f:	44 8b 44 24 14       	mov    r8d,DWORD PTR [rsp+0x14]
  417964:	b8 01 00 00 00       	mov    eax,0x1
  417969:	41 c1 e8 03          	shr    r8d,0x3
  41796d:	41 83 e0 01          	and    r8d,0x1
  417971:	41 01 c0             	add    r8d,eax
	if ((t|32)=='f') {
  417974:	8b 44 24 20          	mov    eax,DWORD PTR [rsp+0x20]
		if (e > INT_MAX-l) return -1;
  417978:	41 ba ff ff ff 7f    	mov    r10d,0x7fffffff
  41797e:	45 29 c2             	sub    r10d,r8d
	if ((t|32)=='f') {
  417981:	83 c8 20             	or     eax,0x20
  417984:	89 44 24 08          	mov    DWORD PTR [rsp+0x8],eax
  417988:	83 f8 66             	cmp    eax,0x66
  41798b:	0f 84 23 0f 00 00    	je     4188b4 <fmt_fp+0x1eb4>
		estr=fmt_u(e<0 ? -e : e, ebuf);
  417991:	89 fe                	mov    esi,edi
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  417993:	4c 8d 64 24 70       	lea    r12,[rsp+0x70]
		estr=fmt_u(e<0 ? -e : e, ebuf);
  417998:	f7 de                	neg    esi
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  41799a:	4c 89 e1             	mov    rcx,r12
		estr=fmt_u(e<0 ? -e : e, ebuf);
  41799d:	0f 48 f7             	cmovs  esi,edi
  4179a0:	48 63 f6             	movsxd rsi,esi
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  4179a3:	85 ff                	test   edi,edi
  4179a5:	74 49                	je     4179f0 <fmt_fp+0xff0>
  4179a7:	49 b9 cd cc cc cc cc 	movabs r9,0xcccccccccccccccd
  4179ae:	cc cc cc 
  4179b1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  4179b8:	48 89 f0             	mov    rax,rsi
  4179bb:	48 83 e9 01          	sub    rcx,0x1
  4179bf:	49 f7 e1             	mul    r9
  4179c2:	48 89 f0             	mov    rax,rsi
  4179c5:	48 c1 ea 03          	shr    rdx,0x3
  4179c9:	4c 8d 1c 92          	lea    r11,[rdx+rdx*4]
  4179cd:	4d 01 db             	add    r11,r11
  4179d0:	4c 29 d8             	sub    rax,r11
  4179d3:	83 c0 30             	add    eax,0x30
  4179d6:	88 01                	mov    BYTE PTR [rcx],al
  4179d8:	48 89 f0             	mov    rax,rsi
  4179db:	48 89 d6             	mov    rsi,rdx
  4179de:	48 83 f8 09          	cmp    rax,0x9
  4179e2:	77 d4                	ja     4179b8 <fmt_fp+0xfb8>
		while(ebuf-estr<2) *--estr='0';
  4179e4:	4c 89 e0             	mov    rax,r12
  4179e7:	48 29 c8             	sub    rax,rcx
  4179ea:	48 83 f8 01          	cmp    rax,0x1
  4179ee:	7f 13                	jg     417a03 <fmt_fp+0x1003>
  4179f0:	48 83 e9 01          	sub    rcx,0x1
  4179f4:	4c 89 e0             	mov    rax,r12
  4179f7:	c6 01 30             	mov    BYTE PTR [rcx],0x30
  4179fa:	48 29 c8             	sub    rax,rcx
  4179fd:	48 83 f8 01          	cmp    rax,0x1
  417a01:	7e ed                	jle    4179f0 <fmt_fp+0xff0>
		*--estr = (e<0 ? '-' : '+');
  417a03:	c1 ff 1f             	sar    edi,0x1f
		*--estr = t;
  417a06:	48 8d 41 fe          	lea    rax,[rcx-0x2]
		if (ebuf-estr > INT_MAX-l) return -1;
  417a0a:	4d 63 d2             	movsxd r10,r10d
		*--estr = (e<0 ? '-' : '+');
  417a0d:	83 e7 02             	and    edi,0x2
		if (ebuf-estr > INT_MAX-l) return -1;
  417a10:	49 29 c4             	sub    r12,rax
		*--estr = t;
  417a13:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
		*--estr = (e<0 ? '-' : '+');
  417a18:	83 c7 2b             	add    edi,0x2b
  417a1b:	40 88 79 ff          	mov    BYTE PTR [rcx-0x1],dil
		*--estr = t;
  417a1f:	0f b6 7c 24 20       	movzx  edi,BYTE PTR [rsp+0x20]
  417a24:	40 88 79 fe          	mov    BYTE PTR [rcx-0x2],dil
		if (ebuf-estr > INT_MAX-l) return -1;
  417a28:	4d 39 d4             	cmp    r12,r10
  417a2b:	0f 8f 8d 08 00 00    	jg     4182be <fmt_fp+0x18be>
		l += ebuf-estr;
  417a31:	45 01 e0             	add    r8d,r12d
	if (l > INT_MAX-pl) return -1;
  417a34:	8b 7c 24 28          	mov    edi,DWORD PTR [rsp+0x28]
  417a38:	89 f8                	mov    eax,edi
  417a3a:	f7 d8                	neg    eax
  417a3c:	19 c0                	sbb    eax,eax
  417a3e:	05 ff ff ff 7f       	add    eax,0x7fffffff
  417a43:	44 39 c0             	cmp    eax,r8d
  417a46:	0f 8c 72 08 00 00    	jl     4182be <fmt_fp+0x18be>
	pad(f, ' ', w, pl+l, fl);
  417a4c:	41 01 f8             	add    r8d,edi
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  417a4f:	44 3b 44 24 58       	cmp    r8d,DWORD PTR [rsp+0x58]
  417a54:	0f 9d 44 24 20       	setge  BYTE PTR [rsp+0x20]
  417a59:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
	pad(f, ' ', w, pl+l, fl);
  417a5e:	44 89 44 24 40       	mov    DWORD PTR [rsp+0x40],r8d
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  417a63:	f7 44 24 14 00 20 01 	test   DWORD PTR [rsp+0x14],0x12000
  417a6a:	00 
  417a6b:	0f 85 c3 00 00 00    	jne    417b34 <fmt_fp+0x1134>
  417a71:	84 c0                	test   al,al
  417a73:	0f 85 bb 00 00 00    	jne    417b34 <fmt_fp+0x1134>
	l = w - l;
  417a79:	8b 4c 24 58          	mov    ecx,DWORD PTR [rsp+0x58]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  417a7d:	b8 00 01 00 00       	mov    eax,0x100
	l = w - l;
  417a82:	2b 4c 24 40          	sub    ecx,DWORD PTR [rsp+0x40]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  417a86:	4c 8d ac 24 90 00 00 	lea    r13,[rsp+0x90]
  417a8d:	00 
  417a8e:	39 c1                	cmp    ecx,eax
  417a90:	89 4c 24 28          	mov    DWORD PTR [rsp+0x28],ecx
  417a94:	be 20 00 00 00       	mov    esi,0x20
  417a99:	4c 89 ef             	mov    rdi,r13
  417a9c:	0f 4e c1             	cmovle eax,ecx
  417a9f:	48 63 d0             	movsxd rdx,eax
  417aa2:	48 b8 7c 79 fb ff ff 	movabs rax,0xfffffffffffb797c
  417aa9:	ff ff ff 
  417aac:	4c 01 f8             	add    rax,r15
  417aaf:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  417ab1:	8b 4c 24 28          	mov    ecx,DWORD PTR [rsp+0x28]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417ab5:	41 8b 06             	mov    eax,DWORD PTR [r14]
	for (; l >= sizeof pad; l -= sizeof pad)
  417ab8:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  417abe:	0f 8e ca 16 00 00    	jle    41918e <fmt_fp+0x278e>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417ac4:	48 bf 60 e3 fb ff ff 	movabs rdi,0xfffffffffffbe360
  417acb:	ff ff ff 
  417ace:	44 8d a1 00 ff ff ff 	lea    r12d,[rcx-0x100]
  417ad5:	48 89 7c 24 28       	mov    QWORD PTR [rsp+0x28],rdi
  417ada:	83 e0 20             	and    eax,0x20
  417add:	89 c6                	mov    esi,eax
  417adf:	0f 84 5b 06 00 00    	je     418140 <fmt_fp+0x1740>
	for (; l >= sizeof pad; l -= sizeof pad)
  417ae5:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  417aec:	7e 4e                	jle    417b3c <fmt_fp+0x113c>
  417aee:	41 8d 84 24 00 e9 ff 	lea    eax,[r12-0x1700]
  417af5:	ff 
  417af6:	3d 00 e9 ff 7f       	cmp    eax,0x7fffe900
  417afb:	0f 86 d1 ec ff ff    	jbe    4167d2 <fmt_fp.cold+0x449>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417b01:	89 f0                	mov    eax,esi
	for (; l >= sizeof pad; l -= sizeof pad)
  417b03:	41 81 ec 00 01 00 00 	sub    r12d,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417b0a:	89 c6                	mov    esi,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  417b0c:	44 89 e1             	mov    ecx,r12d
  417b0f:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  417b16:	77 eb                	ja     417b03 <fmt_fp+0x1103>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417b18:	85 f6                	test   esi,esi
  417b1a:	75 28                	jne    417b44 <fmt_fp+0x1144>
  417b1c:	48 b8 60 e3 fb ff ff 	movabs rax,0xfffffffffffbe360
  417b23:	ff ff ff 
	out(f, pad, l);
  417b26:	48 63 f1             	movsxd rsi,ecx
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417b29:	4c 89 f2             	mov    rdx,r14
  417b2c:	4c 89 ef             	mov    rdi,r13
  417b2f:	4c 01 f8             	add    rax,r15
  417b32:	ff d0                	call   rax
  417b34:	41 8b 06             	mov    eax,DWORD PTR [r14]
  417b37:	83 e0 20             	and    eax,0x20
  417b3a:	89 c6                	mov    esi,eax
  417b3c:	85 f6                	test   esi,esi
  417b3e:	0f 84 88 0d 00 00    	je     4188cc <fmt_fp+0x1ecc>
	pad(f, '0', w, pl+l, fl^ZERO_PAD);
  417b44:	8b 44 24 14          	mov    eax,DWORD PTR [rsp+0x14]
  417b48:	35 00 00 01 00       	xor    eax,0x10000
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  417b4d:	a9 00 20 01 00       	test   eax,0x12000
  417b52:	0f 85 d0 00 00 00    	jne    417c28 <fmt_fp+0x1228>
  417b58:	80 7c 24 20 00       	cmp    BYTE PTR [rsp+0x20],0x0
  417b5d:	0f 85 c5 00 00 00    	jne    417c28 <fmt_fp+0x1228>
	l = w - l;
  417b63:	44 8b 4c 24 58       	mov    r9d,DWORD PTR [rsp+0x58]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  417b68:	b8 00 01 00 00       	mov    eax,0x100
	l = w - l;
  417b6d:	44 2b 4c 24 40       	sub    r9d,DWORD PTR [rsp+0x40]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  417b72:	4c 8d ac 24 90 00 00 	lea    r13,[rsp+0x90]
  417b79:	00 
  417b7a:	41 39 c1             	cmp    r9d,eax
  417b7d:	44 89 4c 24 28       	mov    DWORD PTR [rsp+0x28],r9d
  417b82:	be 30 00 00 00       	mov    esi,0x30
  417b87:	4c 89 ef             	mov    rdi,r13
  417b8a:	41 0f 4e c1          	cmovle eax,r9d
  417b8e:	48 63 d0             	movsxd rdx,eax
  417b91:	48 b8 7c 79 fb ff ff 	movabs rax,0xfffffffffffb797c
  417b98:	ff ff ff 
  417b9b:	4c 01 f8             	add    rax,r15
  417b9e:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  417ba0:	44 8b 4c 24 28       	mov    r9d,DWORD PTR [rsp+0x28]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417ba5:	41 8b 06             	mov    eax,DWORD PTR [r14]
	for (; l >= sizeof pad; l -= sizeof pad)
  417ba8:	41 81 f9 ff 00 00 00 	cmp    r9d,0xff
  417baf:	0f 8e b0 15 00 00    	jle    419165 <fmt_fp+0x2765>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417bb5:	48 bf 60 e3 fb ff ff 	movabs rdi,0xfffffffffffbe360
  417bbc:	ff ff ff 
  417bbf:	45 8d a1 00 ff ff ff 	lea    r12d,[r9-0x100]
  417bc6:	89 c6                	mov    esi,eax
  417bc8:	48 89 7c 24 28       	mov    QWORD PTR [rsp+0x28],rdi
  417bcd:	83 e6 20             	and    esi,0x20
  417bd0:	0f 84 2a 05 00 00    	je     418100 <fmt_fp+0x1700>
	for (; l >= sizeof pad; l -= sizeof pad)
  417bd6:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  417bdd:	7e 49                	jle    417c28 <fmt_fp+0x1228>
  417bdf:	41 8d 84 24 00 e9 ff 	lea    eax,[r12-0x1700]
  417be6:	ff 
  417be7:	3d 00 e9 ff 7f       	cmp    eax,0x7fffe900
  417bec:	0f 86 03 e9 ff ff    	jbe    4164f5 <fmt_fp.cold+0x16c>
  417bf2:	41 81 ec 00 01 00 00 	sub    r12d,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417bf9:	89 f2                	mov    edx,esi
	for (; l >= sizeof pad; l -= sizeof pad)
  417bfb:	45 89 e1             	mov    r9d,r12d
  417bfe:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  417c05:	77 eb                	ja     417bf2 <fmt_fp+0x11f2>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417c07:	85 d2                	test   edx,edx
  417c09:	75 1d                	jne    417c28 <fmt_fp+0x1228>
  417c0b:	48 b8 60 e3 fb ff ff 	movabs rax,0xfffffffffffbe360
  417c12:	ff ff ff 
	out(f, pad, l);
  417c15:	49 63 f1             	movsxd rsi,r9d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417c18:	4c 89 f2             	mov    rdx,r14
  417c1b:	4c 89 ef             	mov    rdi,r13
  417c1e:	4c 01 f8             	add    rax,r15
  417c21:	ff d0                	call   rax
  417c23:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	if ((t|32)=='f') {
  417c28:	83 7c 24 08 66       	cmp    DWORD PTR [rsp+0x8],0x66
  417c2d:	0f 84 48 08 00 00    	je     41847b <fmt_fp+0x1a7b>
		for (d=a; d<z && p>=0; d++) {
  417c33:	4c 63 24 24          	movsxd r12,DWORD PTR [rsp]
		if (z<=a) z=a+1;
  417c37:	48 8d 45 04          	lea    rax,[rbp+0x4]
  417c3b:	48 39 dd             	cmp    rbp,rbx
  417c3e:	48 0f 43 d8          	cmovae rbx,rax
		for (d=a; d<z && p>=0; d++) {
  417c42:	45 85 e4             	test   r12d,r12d
  417c45:	0f 88 fd 00 00 00    	js     417d48 <fmt_fp+0x1348>
  417c4b:	48 39 eb             	cmp    rbx,rbp
  417c4e:	0f 86 f4 00 00 00    	jbe    417d48 <fmt_fp+0x1348>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417c54:	48 b8 60 e3 fb ff ff 	movabs rax,0xfffffffffffbe360
  417c5b:	ff ff ff 
  417c5e:	48 89 6c 24 08       	mov    QWORD PTR [rsp+0x8],rbp
  417c63:	4c 8d 5c 24 79       	lea    r11,[rsp+0x79]
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  417c68:	49 bd cd cc cc cc cc 	movabs r13,0xcccccccccccccccd
  417c6f:	cc cc cc 
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417c72:	4c 01 f8             	add    rax,r15
  417c75:	48 89 1c 24          	mov    QWORD PTR [rsp],rbx
  417c79:	4c 89 f3             	mov    rbx,r14
  417c7c:	49 89 ee             	mov    r14,rbp
  417c7f:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  417c84:	48 b8 73 1e fc ff ff 	movabs rax,0xfffffffffffc1e73
  417c8b:	ff ff ff 
  417c8e:	48 89 44 24 48       	mov    QWORD PTR [rsp+0x48],rax
  417c93:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
			char *s = fmt_u(*d, buf+9);
  417c98:	41 8b 36             	mov    esi,DWORD PTR [r14]
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  417c9b:	4c 89 df             	mov    rdi,r11
  417c9e:	48 85 f6             	test   rsi,rsi
  417ca1:	0f 84 79 03 00 00    	je     418020 <fmt_fp+0x1620>
  417ca7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  417cae:	00 00 
  417cb0:	48 89 f0             	mov    rax,rsi
  417cb3:	48 89 fd             	mov    rbp,rdi
  417cb6:	48 8d 7f ff          	lea    rdi,[rdi-0x1]
  417cba:	49 f7 e5             	mul    r13
  417cbd:	48 89 f0             	mov    rax,rsi
  417cc0:	48 c1 ea 03          	shr    rdx,0x3
  417cc4:	48 8d 0c 92          	lea    rcx,[rdx+rdx*4]
  417cc8:	48 01 c9             	add    rcx,rcx
  417ccb:	48 29 c8             	sub    rax,rcx
  417cce:	83 c0 30             	add    eax,0x30
  417cd1:	88 45 ff             	mov    BYTE PTR [rbp-0x1],al
  417cd4:	48 89 f0             	mov    rax,rsi
  417cd7:	48 89 d6             	mov    rsi,rdx
  417cda:	48 83 f8 09          	cmp    rax,0x9
  417cde:	77 d0                	ja     417cb0 <fmt_fp+0x12b0>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417ce0:	44 8b 03             	mov    r8d,DWORD PTR [rbx]
			if (s==buf+9) *--s='0';
  417ce3:	48 8d 54 24 70       	lea    rdx,[rsp+0x70]
  417ce8:	4c 39 df             	cmp    rdi,r11
  417ceb:	0f 84 32 03 00 00    	je     418023 <fmt_fp+0x1623>
			if (d!=a) while (s>buf) *--s='0';
  417cf1:	4c 39 74 24 08       	cmp    QWORD PTR [rsp+0x8],r14
  417cf6:	0f 85 b4 01 00 00    	jne    417eb0 <fmt_fp+0x14b0>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417cfc:	41 83 e0 20          	and    r8d,0x20
  417d00:	0f 84 3f 03 00 00    	je     418045 <fmt_fp+0x1645>
				if (p>0||(fl&ALT_FORM)) out(f, ".", 1);
  417d06:	8b 44 24 14          	mov    eax,DWORD PTR [rsp+0x14]
  417d0a:	45 89 e1             	mov    r9d,r12d
  417d0d:	83 e0 08             	and    eax,0x8
  417d10:	44 09 e0             	or     eax,r12d
  417d13:	0f 85 67 03 00 00    	jne    418080 <fmt_fp+0x1680>
			out(f, s, MIN(buf+9-s, p));
  417d19:	4d 89 da             	mov    r10,r11
  417d1c:	45 31 c9             	xor    r9d,r9d
  417d1f:	49 29 ea             	sub    r10,rbp
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417d22:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
			p -= buf+9-s;
  417d28:	45 29 d1             	sub    r9d,r10d
		for (d=a; d<z && p>=0; d++) {
  417d2b:	49 83 c6 04          	add    r14,0x4
			p -= buf+9-s;
  417d2f:	4d 63 e1             	movsxd r12,r9d
		for (d=a; d<z && p>=0; d++) {
  417d32:	4c 39 34 24          	cmp    QWORD PTR [rsp],r14
  417d36:	76 09                	jbe    417d41 <fmt_fp+0x1341>
  417d38:	45 85 e4             	test   r12d,r12d
  417d3b:	0f 89 57 ff ff ff    	jns    417c98 <fmt_fp+0x1298>
  417d41:	44 89 24 24          	mov    DWORD PTR [rsp],r12d
  417d45:	49 89 de             	mov    r14,rbx
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  417d48:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  417d4b:	85 c0                	test   eax,eax
  417d4d:	0f 8e 30 06 00 00    	jle    418383 <fmt_fp+0x1983>
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  417d53:	8b 1c 24             	mov    ebx,DWORD PTR [rsp]
  417d56:	81 fb 00 01 00 00    	cmp    ebx,0x100
  417d5c:	0f 8f 2d 0c 00 00    	jg     41898f <fmt_fp+0x1f8f>
  417d62:	48 63 eb             	movsxd rbp,ebx
  417d65:	4c 8d ac 24 90 00 00 	lea    r13,[rsp+0x90]
  417d6c:	00 
  417d6d:	be 30 00 00 00       	mov    esi,0x30
  417d72:	48 b8 7c 79 fb ff ff 	movabs rax,0xfffffffffffb797c
  417d79:	ff ff ff 
  417d7c:	4c 01 f8             	add    rax,r15
  417d7f:	48 89 ea             	mov    rdx,rbp
  417d82:	4c 89 ef             	mov    rdi,r13
  417d85:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  417d87:	81 fb 00 01 00 00    	cmp    ebx,0x100
  417d8d:	0f 85 c7 13 00 00    	jne    41915a <fmt_fp+0x275a>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417d93:	48 bd 60 e3 fb ff ff 	movabs rbp,0xfffffffffffbe360
  417d9a:	ff ff ff 
  417d9d:	8b 1c 24             	mov    ebx,DWORD PTR [rsp]
  417da0:	41 8b 16             	mov    edx,DWORD PTR [r14]
  417da3:	81 eb 00 01 00 00    	sub    ebx,0x100
  417da9:	41 89 dc             	mov    r12d,ebx
  417dac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  417db0:	89 d0                	mov    eax,edx
  417db2:	83 e0 20             	and    eax,0x20
  417db5:	0f 84 0d 03 00 00    	je     4180c8 <fmt_fp+0x16c8>
	for (; l >= sizeof pad; l -= sizeof pad)
  417dbb:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  417dc2:	76 14                	jbe    417dd8 <fmt_fp+0x13d8>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417dc4:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  417dc6:	41 81 ec 00 01 00 00 	sub    r12d,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417dcd:	89 d0                	mov    eax,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  417dcf:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  417dd6:	77 ee                	ja     417dc6 <fmt_fp+0x13c6>
	out(f, pad, l);
  417dd8:	0f b6 eb             	movzx  ebp,bl
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417ddb:	85 c0                	test   eax,eax
  417ddd:	0f 84 88 05 00 00    	je     41836b <fmt_fp+0x196b>
	pad(f, ' ', w, pl+l, fl^LEFT_ADJ);
  417de3:	8b 44 24 14          	mov    eax,DWORD PTR [rsp+0x14]
  417de7:	80 f4 20             	xor    ah,0x20
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  417dea:	a9 00 20 01 00       	test   eax,0x12000
  417def:	0f 85 a4 00 00 00    	jne    417e99 <fmt_fp+0x1499>
  417df5:	80 7c 24 20 00       	cmp    BYTE PTR [rsp+0x20],0x0
  417dfa:	0f 85 99 00 00 00    	jne    417e99 <fmt_fp+0x1499>
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  417e00:	b8 00 01 00 00       	mov    eax,0x100
	l = w - l;
  417e05:	44 8b 64 24 58       	mov    r12d,DWORD PTR [rsp+0x58]
  417e0a:	44 2b 64 24 40       	sub    r12d,DWORD PTR [rsp+0x40]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  417e0f:	4c 8d ac 24 90 00 00 	lea    r13,[rsp+0x90]
  417e16:	00 
  417e17:	41 39 c4             	cmp    r12d,eax
  417e1a:	be 20 00 00 00       	mov    esi,0x20
  417e1f:	4c 89 ef             	mov    rdi,r13
  417e22:	41 0f 4e c4          	cmovle eax,r12d
  417e26:	48 63 d0             	movsxd rdx,eax
  417e29:	48 b8 7c 79 fb ff ff 	movabs rax,0xfffffffffffb797c
  417e30:	ff ff ff 
  417e33:	4c 01 f8             	add    rax,r15
  417e36:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  417e38:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  417e3f:	0f 8e 0a 13 00 00    	jle    41914f <fmt_fp+0x274f>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417e45:	41 8b 06             	mov    eax,DWORD PTR [r14]
  417e48:	41 8d ac 24 00 ff ff 	lea    ebp,[r12-0x100]
  417e4f:	ff 
  417e50:	48 bb 60 e3 fb ff ff 	movabs rbx,0xfffffffffffbe360
  417e57:	ff ff ff 
  417e5a:	89 c1                	mov    ecx,eax
  417e5c:	83 e1 20             	and    ecx,0x20
  417e5f:	0f 84 2b 02 00 00    	je     418090 <fmt_fp+0x1690>
	for (; l >= sizeof pad; l -= sizeof pad)
  417e65:	81 fd ff 00 00 00    	cmp    ebp,0xff
  417e6b:	7e 2c                	jle    417e99 <fmt_fp+0x1499>
  417e6d:	8d 85 00 e9 ff ff    	lea    eax,[rbp-0x1700]
  417e73:	3d 00 e9 ff 7f       	cmp    eax,0x7fffe900
  417e78:	0f 86 ea e7 ff ff    	jbe    416668 <fmt_fp.cold+0x2df>
  417e7e:	81 ed 00 01 00 00    	sub    ebp,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417e84:	89 ca                	mov    edx,ecx
	for (; l >= sizeof pad; l -= sizeof pad)
  417e86:	41 89 ec             	mov    r12d,ebp
  417e89:	81 fd ff 00 00 00    	cmp    ebp,0xff
  417e8f:	77 ed                	ja     417e7e <fmt_fp+0x147e>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417e91:	85 d2                	test   edx,edx
  417e93:	0f 84 86 10 00 00    	je     418f1f <fmt_fp+0x251f>
	return MAX(w, pl+l);
  417e99:	8b 5c 24 40          	mov    ebx,DWORD PTR [rsp+0x40]
  417e9d:	8b 44 24 58          	mov    eax,DWORD PTR [rsp+0x58]
  417ea1:	39 c3                	cmp    ebx,eax
  417ea3:	0f 4d c3             	cmovge eax,ebx
  417ea6:	e9 ce f8 ff ff       	jmp    417779 <fmt_fp+0xd79>
  417eab:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
			if (d!=a) while (s>buf) *--s='0';
  417eb0:	48 39 d7             	cmp    rdi,rdx
  417eb3:	0f 86 42 0a 00 00    	jbe    4188fb <fmt_fp+0x1efb>
  417eb9:	4c 8d 57 ff          	lea    r10,[rdi-0x1]
  417ebd:	48 89 f8             	mov    rax,rdi
  417ec0:	be 01 00 00 00       	mov    esi,0x1
  417ec5:	48 29 d0             	sub    rax,rdx
  417ec8:	49 39 d2             	cmp    r10,rdx
  417ecb:	48 0f 43 f0          	cmovae rsi,rax
  417ecf:	48 83 e8 01          	sub    rax,0x1
  417ed3:	48 83 f8 0e          	cmp    rax,0xe
  417ed7:	0f 86 a7 0a 00 00    	jbe    418984 <fmt_fp+0x1f84>
  417edd:	49 39 d2             	cmp    r10,rdx
  417ee0:	0f 82 9e 0a 00 00    	jb     418984 <fmt_fp+0x1f84>
  417ee6:	48 bd 60 23 fc ff ff 	movabs rbp,0xfffffffffffc2360
  417eed:	ff ff ff 
  417ef0:	48 89 f0             	mov    rax,rsi
  417ef3:	49 89 f9             	mov    r9,rdi
  417ef6:	48 83 e0 f0          	and    rax,0xfffffffffffffff0
  417efa:	66 42 0f 6f 44 3d 00 	movdqa xmm0,XMMWORD PTR [rbp+r15*1+0x0]
  417f01:	49 29 c1             	sub    r9,rax
			if (s==buf+9) *--s='0';
  417f04:	48 89 f8             	mov    rax,rdi
  417f07:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  417f0e:	00 00 
			if (d!=a) while (s>buf) *--s='0';
  417f10:	0f 11 40 f0          	movups XMMWORD PTR [rax-0x10],xmm0
  417f14:	48 83 e8 10          	sub    rax,0x10
  417f18:	4c 39 c8             	cmp    rax,r9
  417f1b:	75 f3                	jne    417f10 <fmt_fp+0x1510>
  417f1d:	49 89 f1             	mov    r9,rsi
  417f20:	48 89 f8             	mov    rax,rdi
  417f23:	49 83 e1 f0          	and    r9,0xfffffffffffffff0
  417f27:	4c 29 c8             	sub    rax,r9
  417f2a:	4c 39 ce             	cmp    rsi,r9
  417f2d:	0f 84 86 00 00 00    	je     417fb9 <fmt_fp+0x15b9>
  417f33:	4c 29 ce             	sub    rsi,r9
  417f36:	48 8d 6e ff          	lea    rbp,[rsi-0x1]
  417f3a:	48 83 fd 06          	cmp    rbp,0x6
  417f3e:	76 27                	jbe    417f67 <fmt_fp+0x1567>
  417f40:	48 89 fd             	mov    rbp,rdi
  417f43:	4c 29 cd             	sub    rbp,r9
  417f46:	49 b9 60 23 fc ff ff 	movabs r9,0xfffffffffffc2360
  417f4d:	ff ff ff 
  417f50:	4f 8b 0c 0f          	mov    r9,QWORD PTR [r15+r9*1]
  417f54:	4c 89 4d f8          	mov    QWORD PTR [rbp-0x8],r9
  417f58:	49 89 f1             	mov    r9,rsi
  417f5b:	49 83 e1 f8          	and    r9,0xfffffffffffffff8
  417f5f:	4c 29 c8             	sub    rax,r9
  417f62:	4c 39 ce             	cmp    rsi,r9
  417f65:	74 52                	je     417fb9 <fmt_fp+0x15b9>
  417f67:	48 8d 70 ff          	lea    rsi,[rax-0x1]
  417f6b:	c6 40 ff 30          	mov    BYTE PTR [rax-0x1],0x30
  417f6f:	48 39 f2             	cmp    rdx,rsi
  417f72:	73 45                	jae    417fb9 <fmt_fp+0x15b9>
  417f74:	48 8d 70 fe          	lea    rsi,[rax-0x2]
  417f78:	c6 40 fe 30          	mov    BYTE PTR [rax-0x2],0x30
  417f7c:	48 39 f2             	cmp    rdx,rsi
  417f7f:	73 38                	jae    417fb9 <fmt_fp+0x15b9>
  417f81:	48 8d 70 fd          	lea    rsi,[rax-0x3]
  417f85:	c6 40 fd 30          	mov    BYTE PTR [rax-0x3],0x30
  417f89:	48 39 f2             	cmp    rdx,rsi
  417f8c:	73 2b                	jae    417fb9 <fmt_fp+0x15b9>
  417f8e:	48 8d 70 fc          	lea    rsi,[rax-0x4]
  417f92:	c6 40 fc 30          	mov    BYTE PTR [rax-0x4],0x30
  417f96:	48 39 f2             	cmp    rdx,rsi
  417f99:	73 1e                	jae    417fb9 <fmt_fp+0x15b9>
  417f9b:	48 8d 70 fb          	lea    rsi,[rax-0x5]
  417f9f:	c6 40 fb 30          	mov    BYTE PTR [rax-0x5],0x30
  417fa3:	48 39 f2             	cmp    rdx,rsi
  417fa6:	73 11                	jae    417fb9 <fmt_fp+0x15b9>
  417fa8:	48 8d 70 fa          	lea    rsi,[rax-0x6]
  417fac:	c6 40 fa 30          	mov    BYTE PTR [rax-0x6],0x30
  417fb0:	48 39 f2             	cmp    rdx,rsi
  417fb3:	73 04                	jae    417fb9 <fmt_fp+0x15b9>
  417fb5:	c6 40 f9 30          	mov    BYTE PTR [rax-0x7],0x30
  417fb9:	48 89 d5             	mov    rbp,rdx
  417fbc:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
  417fc3:	45 89 e1             	mov    r9d,r12d
  417fc6:	48 29 fd             	sub    rbp,rdi
  417fc9:	49 39 d2             	cmp    r10,rdx
  417fcc:	48 0f 42 e8          	cmovb  rbp,rax
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417fd0:	41 83 e0 20          	and    r8d,0x20
			if (d!=a) while (s>buf) *--s='0';
  417fd4:	48 01 fd             	add    rbp,rdi
			out(f, s, MIN(buf+9-s, p));
  417fd7:	4d 89 da             	mov    r10,r11
  417fda:	49 29 ea             	sub    r10,rbp
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417fdd:	45 85 c0             	test   r8d,r8d
  417fe0:	0f 85 42 fd ff ff    	jne    417d28 <fmt_fp+0x1328>
			out(f, s, MIN(buf+9-s, p));
  417fe6:	4d 39 d4             	cmp    r12,r10
  417fe9:	4c 89 e6             	mov    rsi,r12
  417fec:	4c 89 5c 24 38       	mov    QWORD PTR [rsp+0x38],r11
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417ff1:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  417ff6:	44 89 4c 24 30       	mov    DWORD PTR [rsp+0x30],r9d
			out(f, s, MIN(buf+9-s, p));
  417ffb:	49 0f 4f f2          	cmovg  rsi,r10
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417fff:	48 89 da             	mov    rdx,rbx
  418002:	48 89 ef             	mov    rdi,rbp
			out(f, s, MIN(buf+9-s, p));
  418005:	4c 89 54 24 28       	mov    QWORD PTR [rsp+0x28],r10
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41800a:	ff d0                	call   rax
  41800c:	4c 8b 5c 24 38       	mov    r11,QWORD PTR [rsp+0x38]
  418011:	44 8b 4c 24 30       	mov    r9d,DWORD PTR [rsp+0x30]
  418016:	4c 8b 54 24 28       	mov    r10,QWORD PTR [rsp+0x28]
  41801b:	e9 08 fd ff ff       	jmp    417d28 <fmt_fp+0x1328>
  418020:	44 8b 03             	mov    r8d,DWORD PTR [rbx]
			if (s==buf+9) *--s='0';
  418023:	c6 44 24 78 30       	mov    BYTE PTR [rsp+0x78],0x30
			if (d!=a) while (s>buf) *--s='0';
  418028:	4c 39 74 24 08       	cmp    QWORD PTR [rsp+0x8],r14
  41802d:	0f 85 87 01 00 00    	jne    4181ba <fmt_fp+0x17ba>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418033:	41 83 e0 20          	and    r8d,0x20
			if (d!=a) while (s>buf) *--s='0';
  418037:	4c 89 dd             	mov    rbp,r11
			if (s==buf+9) *--s='0';
  41803a:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41803f:	0f 85 c1 fc ff ff    	jne    417d06 <fmt_fp+0x1306>
  418045:	4c 89 5c 24 28       	mov    QWORD PTR [rsp+0x28],r11
  41804a:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  41804f:	48 89 da             	mov    rdx,rbx
  418052:	be 01 00 00 00       	mov    esi,0x1
  418057:	ff d0                	call   rax
				if (p>0||(fl&ALT_FORM)) out(f, ".", 1);
  418059:	8b 44 24 14          	mov    eax,DWORD PTR [rsp+0x14]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41805d:	44 8b 03             	mov    r8d,DWORD PTR [rbx]
  418060:	45 89 e1             	mov    r9d,r12d
				if (p>0||(fl&ALT_FORM)) out(f, ".", 1);
  418063:	4c 8b 5c 24 28       	mov    r11,QWORD PTR [rsp+0x28]
  418068:	83 e0 08             	and    eax,0x8
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41806b:	41 83 e0 20          	and    r8d,0x20
				if (p>0||(fl&ALT_FORM)) out(f, ".", 1);
  41806f:	44 09 e0             	or     eax,r12d
  418072:	0f 85 01 01 00 00    	jne    418179 <fmt_fp+0x1779>
  418078:	45 31 c9             	xor    r9d,r9d
  41807b:	e9 57 ff ff ff       	jmp    417fd7 <fmt_fp+0x15d7>
			out(f, s, MIN(buf+9-s, p));
  418080:	4d 89 da             	mov    r10,r11
  418083:	49 29 ea             	sub    r10,rbp
  418086:	e9 9d fc ff ff       	jmp    417d28 <fmt_fp+0x1328>
  41808b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418090:	4c 89 f2             	mov    rdx,r14
  418093:	be 00 01 00 00       	mov    esi,0x100
  418098:	4c 89 ef             	mov    rdi,r13
	for (; l >= sizeof pad; l -= sizeof pad)
  41809b:	41 89 ec             	mov    r12d,ebp
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41809e:	49 8d 04 1f          	lea    rax,[r15+rbx*1]
  4180a2:	ff d0                	call   rax
  4180a4:	41 8b 0e             	mov    ecx,DWORD PTR [r14]
  4180a7:	89 ca                	mov    edx,ecx
  4180a9:	83 e2 20             	and    edx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  4180ac:	81 fd ff 00 00 00    	cmp    ebp,0xff
  4180b2:	0f 8e d9 fd ff ff    	jle    417e91 <fmt_fp+0x1491>
  4180b8:	81 ed 00 01 00 00    	sub    ebp,0x100
  4180be:	e9 99 fd ff ff       	jmp    417e5c <fmt_fp+0x145c>
  4180c3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4180c8:	4c 89 f2             	mov    rdx,r14
  4180cb:	be 00 01 00 00       	mov    esi,0x100
  4180d0:	49 8d 04 2f          	lea    rax,[r15+rbp*1]
  4180d4:	4c 89 ef             	mov    rdi,r13
  4180d7:	ff d0                	call   rax
  4180d9:	41 8b 16             	mov    edx,DWORD PTR [r14]
  4180dc:	89 d0                	mov    eax,edx
  4180de:	83 e0 20             	and    eax,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  4180e1:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  4180e8:	0f 86 ea fc ff ff    	jbe    417dd8 <fmt_fp+0x13d8>
  4180ee:	41 81 ec 00 01 00 00 	sub    r12d,0x100
  4180f5:	e9 b6 fc ff ff       	jmp    417db0 <fmt_fp+0x13b0>
  4180fa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418100:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  418105:	4c 89 f2             	mov    rdx,r14
  418108:	be 00 01 00 00       	mov    esi,0x100
  41810d:	4c 89 ef             	mov    rdi,r13
  418110:	4c 01 f8             	add    rax,r15
  418113:	ff d0                	call   rax
  418115:	41 8b 36             	mov    esi,DWORD PTR [r14]
	for (; l >= sizeof pad; l -= sizeof pad)
  418118:	45 89 e1             	mov    r9d,r12d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41811b:	89 f2                	mov    edx,esi
  41811d:	83 e2 20             	and    edx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  418120:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  418127:	0f 8e da fa ff ff    	jle    417c07 <fmt_fp+0x1207>
  41812d:	41 81 ec 00 01 00 00 	sub    r12d,0x100
  418134:	e9 94 fa ff ff       	jmp    417bcd <fmt_fp+0x11cd>
  418139:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418140:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  418145:	be 00 01 00 00       	mov    esi,0x100
  41814a:	4c 89 f2             	mov    rdx,r14
  41814d:	4c 89 ef             	mov    rdi,r13
  418150:	4c 01 f8             	add    rax,r15
  418153:	ff d0                	call   rax
  418155:	41 8b 06             	mov    eax,DWORD PTR [r14]
	for (; l >= sizeof pad; l -= sizeof pad)
  418158:	44 89 e1             	mov    ecx,r12d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41815b:	89 c6                	mov    esi,eax
  41815d:	83 e6 20             	and    esi,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  418160:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  418167:	0f 8e ab f9 ff ff    	jle    417b18 <fmt_fp+0x1118>
  41816d:	41 81 ec 00 01 00 00 	sub    r12d,0x100
  418174:	e9 61 f9 ff ff       	jmp    417ada <fmt_fp+0x10da>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418179:	45 85 c0             	test   r8d,r8d
  41817c:	0f 85 fe fe ff ff    	jne    418080 <fmt_fp+0x1680>
  418182:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
  418187:	4c 89 5c 24 30       	mov    QWORD PTR [rsp+0x30],r11
  41818c:	48 89 da             	mov    rdx,rbx
  41818f:	be 01 00 00 00       	mov    esi,0x1
  418194:	44 89 64 24 28       	mov    DWORD PTR [rsp+0x28],r12d
  418199:	49 8d 3c 07          	lea    rdi,[r15+rax*1]
  41819d:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  4181a2:	ff d0                	call   rax
  4181a4:	44 8b 03             	mov    r8d,DWORD PTR [rbx]
  4181a7:	44 8b 4c 24 28       	mov    r9d,DWORD PTR [rsp+0x28]
  4181ac:	4c 8b 5c 24 30       	mov    r11,QWORD PTR [rsp+0x30]
  4181b1:	41 83 e0 20          	and    r8d,0x20
  4181b5:	e9 1d fe ff ff       	jmp    417fd7 <fmt_fp+0x15d7>
			if (s==buf+9) *--s='0';
  4181ba:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
  4181bf:	48 8d 54 24 70       	lea    rdx,[rsp+0x70]
  4181c4:	e9 f0 fc ff ff       	jmp    417eb9 <fmt_fp+0x14b9>
			if (s-buf==1 && (y||p>0||(fl&ALT_FORM))) *s++='.';
  4181c9:	c6 42 01 2e          	mov    BYTE PTR [rdx+0x1],0x2e
  4181cd:	48 83 c2 02          	add    rdx,0x2
  4181d1:	e9 bd ee ff ff       	jmp    417093 <fmt_fp+0x693>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4181d6:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  4181db:	be 00 01 00 00       	mov    esi,0x100
  4181e0:	4c 89 f2             	mov    rdx,r14
  4181e3:	48 89 ef             	mov    rdi,rbp
  4181e6:	4c 01 f8             	add    rax,r15
  4181e9:	ff d0                	call   rax
  4181eb:	41 8b 06             	mov    eax,DWORD PTR [r14]
  4181ee:	89 c6                	mov    esi,eax
  4181f0:	83 e6 20             	and    esi,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  4181f3:	81 fb ff 00 00 00    	cmp    ebx,0xff
  4181f9:	0f 8e 16 11 00 00    	jle    419315 <fmt_fp+0x2915>
  4181ff:	81 eb 00 01 00 00    	sub    ebx,0x100
  418205:	e9 d9 ef ff ff       	jmp    4171e3 <fmt_fp+0x7e3>
  41820a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418210:	4c 89 f2             	mov    rdx,r14
  418213:	be 00 01 00 00       	mov    esi,0x100
  418218:	49 8d 04 2f          	lea    rax,[r15+rbp*1]
  41821c:	4c 89 e7             	mov    rdi,r12
  41821f:	ff d0                	call   rax
  418221:	41 8b 06             	mov    eax,DWORD PTR [r14]
  418224:	89 c1                	mov    ecx,eax
  418226:	83 e1 20             	and    ecx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  418229:	81 fb ff 00 00 00    	cmp    ebx,0xff
  41822f:	0f 8e ea 10 00 00    	jle    41931f <fmt_fp+0x291f>
  418235:	81 eb 00 01 00 00    	sub    ebx,0x100
  41823b:	e9 42 f1 ff ff       	jmp    417382 <fmt_fp+0x982>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418240:	4c 89 f2             	mov    rdx,r14
  418243:	be 00 01 00 00       	mov    esi,0x100
  418248:	49 8d 04 1f          	lea    rax,[r15+rbx*1]
  41824c:	48 89 ef             	mov    rdi,rbp
  41824f:	ff d0                	call   rax
  418251:	41 8b 06             	mov    eax,DWORD PTR [r14]
  418254:	89 c1                	mov    ecx,eax
  418256:	83 e1 20             	and    ecx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  418259:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  418260:	0f 8e eb 07 00 00    	jle    418a51 <fmt_fp+0x2051>
  418266:	41 81 ed 00 01 00 00 	sub    r13d,0x100
  41826d:	e9 55 f0 ff ff       	jmp    4172c7 <fmt_fp+0x8c7>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418272:	4c 89 f2             	mov    rdx,r14
  418275:	be 00 01 00 00       	mov    esi,0x100
  41827a:	4c 89 ef             	mov    rdi,r13
	for (; l >= sizeof pad; l -= sizeof pad)
  41827d:	41 89 ec             	mov    r12d,ebp
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418280:	49 8d 04 1f          	lea    rax,[r15+rbx*1]
  418284:	ff d0                	call   rax
  418286:	41 8b 0e             	mov    ecx,DWORD PTR [r14]
  418289:	89 ca                	mov    edx,ecx
  41828b:	83 e2 20             	and    edx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41828e:	81 fd ff 00 00 00    	cmp    ebp,0xff
  418294:	0f 8e af 07 00 00    	jle    418a49 <fmt_fp+0x2049>
  41829a:	81 ed 00 01 00 00    	sub    ebp,0x100
  4182a0:	e9 e1 f1 ff ff       	jmp    417486 <fmt_fp+0xa86>
	l = 1 + p + (p || (fl&ALT_FORM));
  4182a5:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  4182a8:	41 b8 01 00 00 00    	mov    r8d,0x1
  4182ae:	83 c0 01             	add    eax,0x1
	if (p > INT_MAX-1-(p || (fl&ALT_FORM)))
  4182b1:	81 3c 24 fd ff ff 7f 	cmp    DWORD PTR [rsp],0x7ffffffd
  4182b8:	0f 8e b3 f6 ff ff    	jle    417971 <fmt_fp+0xf71>
			return -1;
  4182be:	b8 ff ff ff ff       	mov    eax,0xffffffff
  4182c3:	e9 b1 f4 ff ff       	jmp    417779 <fmt_fp+0xd79>
  4182c8:	c6 44 24 40 01       	mov    BYTE PTR [rsp+0x40],0x1
	if (p<0) p=6;
  4182cd:	c7 04 24 06 00 00 00 	mov    DWORD PTR [rsp],0x6
  4182d4:	e9 72 e8 ff ff       	jmp    416b4b <fmt_fp+0x14b>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4182d9:	48 8b 74 24 38       	mov    rsi,QWORD PTR [rsp+0x38]
  4182de:	48 8b 7c 24 30       	mov    rdi,QWORD PTR [rsp+0x30]
  4182e3:	4c 89 f2             	mov    rdx,r14
  4182e6:	48 b8 60 e3 fb ff ff 	movabs rax,0xfffffffffffbe360
  4182ed:	ff ff ff 
  4182f0:	4d 8d 2c 07          	lea    r13,[r15+rax*1]
  4182f4:	41 ff d5             	call   r13
  4182f7:	41 f6 06 20          	test   BYTE PTR [r14],0x20
  4182fb:	0f 85 8e f3 ff ff    	jne    41768f <fmt_fp+0xc8f>
  418301:	4c 89 f2             	mov    rdx,r14
  418304:	be 03 00 00 00       	mov    esi,0x3
  418309:	4c 89 e7             	mov    rdi,r12
  41830c:	41 ff d5             	call   r13
  41830f:	e9 7b f3 ff ff       	jmp    41768f <fmt_fp+0xc8f>
  418314:	48 b8 60 e3 fb ff ff 	movabs rax,0xfffffffffffbe360
  41831b:	ff ff ff 
	out(f, pad, l);
  41831e:	48 63 f5             	movsxd rsi,ebp
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418321:	4c 89 f2             	mov    rdx,r14
  418324:	4c 89 d7             	mov    rdi,r10
  418327:	4c 01 f8             	add    rax,r15
  41832a:	ff d0                	call   rax
  41832c:	41 8b 0e             	mov    ecx,DWORD PTR [r14]
  41832f:	83 e1 20             	and    ecx,0x20
  418332:	85 c9                	test   ecx,ecx
  418334:	0f 85 d9 ef ff ff    	jne    417313 <fmt_fp+0x913>
  41833a:	48 b8 60 e3 fb ff ff 	movabs rax,0xfffffffffffbe360
  418341:	ff ff ff 
  418344:	48 8b 74 24 48       	mov    rsi,QWORD PTR [rsp+0x48]
  418349:	4c 89 f2             	mov    rdx,r14
  41834c:	4c 89 e7             	mov    rdi,r12
  41834f:	4c 01 f8             	add    rax,r15
  418352:	ff d0                	call   rax
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  418354:	44 8b 44 24 08       	mov    r8d,DWORD PTR [rsp+0x8]
  418359:	8b 5c 24 38          	mov    ebx,DWORD PTR [rsp+0x38]
  41835d:	45 85 c0             	test   r8d,r8d
  418360:	0f 8f bb ef ff ff    	jg     417321 <fmt_fp+0x921>
  418366:	e9 72 f0 ff ff       	jmp    4173dd <fmt_fp+0x9dd>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41836b:	48 b8 60 e3 fb ff ff 	movabs rax,0xfffffffffffbe360
  418372:	ff ff ff 
  418375:	4c 89 f2             	mov    rdx,r14
  418378:	48 89 ee             	mov    rsi,rbp
  41837b:	4c 89 ef             	mov    rdi,r13
  41837e:	4c 01 f8             	add    rax,r15
  418381:	ff d0                	call   rax
  418383:	41 8b 06             	mov    eax,DWORD PTR [r14]
  418386:	83 e0 20             	and    eax,0x20
  418389:	85 c0                	test   eax,eax
  41838b:	0f 85 52 fa ff ff    	jne    417de3 <fmt_fp+0x13e3>
		out(f, estr, ebuf-estr);
  418391:	48 8b 7c 24 50       	mov    rdi,QWORD PTR [rsp+0x50]
  418396:	48 8d 74 24 70       	lea    rsi,[rsp+0x70]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41839b:	4c 89 f2             	mov    rdx,r14
  41839e:	48 b8 60 e3 fb ff ff 	movabs rax,0xfffffffffffbe360
  4183a5:	ff ff ff 
  4183a8:	4c 01 f8             	add    rax,r15
		out(f, estr, ebuf-estr);
  4183ab:	48 29 fe             	sub    rsi,rdi
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4183ae:	ff d0                	call   rax
  4183b0:	e9 2e fa ff ff       	jmp    417de3 <fmt_fp+0x13e3>
		if (!p) p++;
  4183b5:	8b 0c 24             	mov    ecx,DWORD PTR [rsp]
  4183b8:	b8 01 00 00 00       	mov    eax,0x1
  4183bd:	85 c9                	test   ecx,ecx
  4183bf:	0f 45 c1             	cmovne eax,ecx
  4183c2:	89 04 24             	mov    DWORD PTR [rsp],eax
  4183c5:	89 c1                	mov    ecx,eax
		if (p>e && e>=-4) {
  4183c7:	39 f8                	cmp    eax,edi
  4183c9:	0f 8e ac 06 00 00    	jle    418a7b <fmt_fp+0x207b>
  4183cf:	83 ff fc             	cmp    edi,0xfffffffc
  4183d2:	0f 8c a3 06 00 00    	jl     418a7b <fmt_fp+0x207b>
			p-=e+1;
  4183d8:	8d 47 01             	lea    eax,[rdi+0x1]
			t--;
  4183db:	83 6c 24 20 01       	sub    DWORD PTR [rsp+0x20],0x1
			p-=e+1;
  4183e0:	29 c1                	sub    ecx,eax
  4183e2:	89 0c 24             	mov    DWORD PTR [rsp],ecx
		if (!(fl&ALT_FORM)) {
  4183e5:	f6 44 24 14 08       	test   BYTE PTR [rsp+0x14],0x8
  4183ea:	0f 85 64 f5 ff ff    	jne    417954 <fmt_fp+0xf54>
			if (z>a && z[-1]) for (i=10, j=0; z[-1]%i==0; i*=10, j++);
  4183f0:	be 09 00 00 00       	mov    esi,0x9
  4183f5:	48 39 dd             	cmp    rbp,rbx
  4183f8:	73 3a                	jae    418434 <fmt_fp+0x1a34>
  4183fa:	44 8b 43 fc          	mov    r8d,DWORD PTR [rbx-0x4]
  4183fe:	45 85 c0             	test   r8d,r8d
  418401:	74 31                	je     418434 <fmt_fp+0x1a34>
  418403:	41 69 c0 cd cc cc cc 	imul   eax,r8d,0xcccccccd
  41840a:	d1 c8                	ror    eax,1
  41840c:	3d 99 99 99 19       	cmp    eax,0x19999999
  418411:	0f 87 f7 0e 00 00    	ja     41930e <fmt_fp+0x290e>
  418417:	31 f6                	xor    esi,esi
  418419:	b9 0a 00 00 00       	mov    ecx,0xa
  41841e:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  418421:	44 89 c0             	mov    eax,r8d
  418424:	31 d2                	xor    edx,edx
  418426:	83 c6 01             	add    esi,0x1
  418429:	01 c9                	add    ecx,ecx
  41842b:	f7 f1                	div    ecx
  41842d:	85 d2                	test   edx,edx
  41842f:	74 ed                	je     41841e <fmt_fp+0x1a1e>
				p = MIN(p,MAX(0,9*(z-r-1)-j));
  418431:	48 63 f6             	movsxd rsi,esi
  418434:	48 89 d8             	mov    rax,rbx
  418437:	48 2b 44 24 18       	sub    rax,QWORD PTR [rsp+0x18]
  41843c:	48 63 0c 24          	movsxd rcx,DWORD PTR [rsp]
  418440:	48 c1 f8 02          	sar    rax,0x2
  418444:	48 8d 54 c0 f7       	lea    rdx,[rax+rax*8-0x9]
			if ((t|32)=='f')
  418449:	8b 44 24 20          	mov    eax,DWORD PTR [rsp+0x20]
  41844d:	83 c8 20             	or     eax,0x20
  418450:	83 f8 66             	cmp    eax,0x66
  418453:	0f 84 5a 0b 00 00    	je     418fb3 <fmt_fp+0x25b3>
				p = MIN(p,MAX(0,9*(z-r-1)+e-j));
  418459:	48 63 c7             	movsxd rax,edi
  41845c:	48 01 d0             	add    rax,rdx
  41845f:	ba 00 00 00 00       	mov    edx,0x0
  418464:	48 29 f0             	sub    rax,rsi
  418467:	48 0f 48 c2          	cmovs  rax,rdx
  41846b:	48 39 c8             	cmp    rax,rcx
  41846e:	48 0f 4e c8          	cmovle rcx,rax
  418472:	48 89 0c 24          	mov    QWORD PTR [rsp],rcx
  418476:	e9 d9 f4 ff ff       	jmp    417954 <fmt_fp+0xf54>
			if (d!=a) while (s>buf) *--s='0';
  41847b:	49 bc 60 23 fc ff ff 	movabs r12,0xfffffffffffc2360
  418482:	ff ff ff 
  418485:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  41848a:	48 39 e8             	cmp    rax,rbp
  41848d:	48 0f 46 e8          	cmovbe rbp,rax
  418491:	48 b8 60 23 fc ff ff 	movabs rax,0xfffffffffffc2360
  418498:	ff ff ff 
  41849b:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4184a0:	48 b8 60 e3 fb ff ff 	movabs rax,0xfffffffffffbe360
  4184a7:	ff ff ff 
			char *s = fmt_u(*d, buf+9);
  4184aa:	8b 4d 00             	mov    ecx,DWORD PTR [rbp+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4184ad:	4c 01 f8             	add    rax,r15
  4184b0:	49 89 ed             	mov    r13,rbp
  4184b3:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  4184b8:	48 85 c9             	test   rcx,rcx
  4184bb:	0f 84 dc 03 00 00    	je     41889d <fmt_fp+0x1e9d>
  4184c1:	49 b8 cd cc cc cc cc 	movabs r8,0xcccccccccccccccd
  4184c8:	cc cc cc 
  4184cb:	48 8d 74 24 79       	lea    rsi,[rsp+0x79]
  4184d0:	48 89 f7             	mov    rdi,rsi
  4184d3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  4184d8:	48 89 c8             	mov    rax,rcx
  4184db:	48 83 ef 01          	sub    rdi,0x1
  4184df:	49 f7 e0             	mul    r8
  4184e2:	48 89 c8             	mov    rax,rcx
  4184e5:	48 c1 ea 03          	shr    rdx,0x3
  4184e9:	4c 8d 0c 92          	lea    r9,[rdx+rdx*4]
  4184ed:	4d 01 c9             	add    r9,r9
  4184f0:	4c 29 c8             	sub    rax,r9
  4184f3:	83 c0 30             	add    eax,0x30
  4184f6:	88 07                	mov    BYTE PTR [rdi],al
  4184f8:	48 89 c8             	mov    rax,rcx
  4184fb:	48 89 d1             	mov    rcx,rdx
  4184fe:	48 83 f8 09          	cmp    rax,0x9
  418502:	77 d4                	ja     4184d8 <fmt_fp+0x1ad8>
			if (d!=a) while (s>buf) *--s='0';
  418504:	49 39 ed             	cmp    r13,rbp
  418507:	0f 84 43 03 00 00    	je     418850 <fmt_fp+0x1e50>
  41850d:	48 8d 4c 24 70       	lea    rcx,[rsp+0x70]
  418512:	48 39 cf             	cmp    rdi,rcx
  418515:	0f 86 ff 00 00 00    	jbe    41861a <fmt_fp+0x1c1a>
  41851b:	4c 8d 4f ff          	lea    r9,[rdi-0x1]
  41851f:	48 89 f8             	mov    rax,rdi
  418522:	ba 01 00 00 00       	mov    edx,0x1
  418527:	48 29 c8             	sub    rax,rcx
  41852a:	49 39 c9             	cmp    r9,rcx
  41852d:	48 0f 43 d0          	cmovae rdx,rax
  418531:	48 83 e8 01          	sub    rax,0x1
  418535:	48 83 f8 0e          	cmp    rax,0xe
  418539:	0f 86 c0 09 00 00    	jbe    418eff <fmt_fp+0x24ff>
  41853f:	49 39 c9             	cmp    r9,rcx
  418542:	0f 82 b7 09 00 00    	jb     418eff <fmt_fp+0x24ff>
  418548:	4c 8b 5c 24 08       	mov    r11,QWORD PTR [rsp+0x8]
  41854d:	48 89 d0             	mov    rax,rdx
  418550:	49 89 f8             	mov    r8,rdi
  418553:	48 83 e0 f0          	and    rax,0xfffffffffffffff0
  418557:	66 43 0f 6f 04 3b    	movdqa xmm0,XMMWORD PTR [r11+r15*1]
  41855d:	49 29 c0             	sub    r8,rax
  418560:	48 89 f8             	mov    rax,rdi
  418563:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  418568:	0f 11 40 f0          	movups XMMWORD PTR [rax-0x10],xmm0
  41856c:	48 83 e8 10          	sub    rax,0x10
  418570:	49 39 c0             	cmp    r8,rax
  418573:	75 f3                	jne    418568 <fmt_fp+0x1b68>
  418575:	49 89 d0             	mov    r8,rdx
  418578:	48 89 f8             	mov    rax,rdi
  41857b:	49 83 e0 f0          	and    r8,0xfffffffffffffff0
  41857f:	4c 29 c0             	sub    rax,r8
  418582:	4c 39 c2             	cmp    rdx,r8
  418585:	74 7c                	je     418603 <fmt_fp+0x1c03>
  418587:	4c 29 c2             	sub    rdx,r8
  41858a:	4c 8d 52 ff          	lea    r10,[rdx-0x1]
  41858e:	49 83 fa 06          	cmp    r10,0x6
  418592:	76 1d                	jbe    4185b1 <fmt_fp+0x1bb1>
  418594:	49 89 fa             	mov    r10,rdi
  418597:	4d 29 c2             	sub    r10,r8
  41859a:	4f 8b 04 27          	mov    r8,QWORD PTR [r15+r12*1]
  41859e:	4d 89 42 f8          	mov    QWORD PTR [r10-0x8],r8
  4185a2:	49 89 d0             	mov    r8,rdx
  4185a5:	49 83 e0 f8          	and    r8,0xfffffffffffffff8
  4185a9:	4c 29 c0             	sub    rax,r8
  4185ac:	4c 39 c2             	cmp    rdx,r8
  4185af:	74 52                	je     418603 <fmt_fp+0x1c03>
  4185b1:	48 8d 50 ff          	lea    rdx,[rax-0x1]
  4185b5:	c6 40 ff 30          	mov    BYTE PTR [rax-0x1],0x30
  4185b9:	48 39 d1             	cmp    rcx,rdx
  4185bc:	73 45                	jae    418603 <fmt_fp+0x1c03>
  4185be:	48 8d 50 fe          	lea    rdx,[rax-0x2]
  4185c2:	c6 40 fe 30          	mov    BYTE PTR [rax-0x2],0x30
  4185c6:	48 39 d1             	cmp    rcx,rdx
  4185c9:	73 38                	jae    418603 <fmt_fp+0x1c03>
  4185cb:	48 8d 50 fd          	lea    rdx,[rax-0x3]
  4185cf:	c6 40 fd 30          	mov    BYTE PTR [rax-0x3],0x30
  4185d3:	48 39 d1             	cmp    rcx,rdx
  4185d6:	73 2b                	jae    418603 <fmt_fp+0x1c03>
  4185d8:	48 8d 50 fc          	lea    rdx,[rax-0x4]
  4185dc:	c6 40 fc 30          	mov    BYTE PTR [rax-0x4],0x30
  4185e0:	48 39 d1             	cmp    rcx,rdx
  4185e3:	73 1e                	jae    418603 <fmt_fp+0x1c03>
  4185e5:	48 8d 50 fb          	lea    rdx,[rax-0x5]
  4185e9:	c6 40 fb 30          	mov    BYTE PTR [rax-0x5],0x30
  4185ed:	48 39 d1             	cmp    rcx,rdx
  4185f0:	73 11                	jae    418603 <fmt_fp+0x1c03>
  4185f2:	48 8d 50 fa          	lea    rdx,[rax-0x6]
  4185f6:	c6 40 fa 30          	mov    BYTE PTR [rax-0x6],0x30
  4185fa:	48 39 d1             	cmp    rcx,rdx
  4185fd:	73 04                	jae    418603 <fmt_fp+0x1c03>
  4185ff:	c6 40 f9 30          	mov    BYTE PTR [rax-0x7],0x30
  418603:	48 89 c8             	mov    rax,rcx
  418606:	48 c7 c2 ff ff ff ff 	mov    rdx,0xffffffffffffffff
  41860d:	48 29 f8             	sub    rax,rdi
  418610:	49 39 c9             	cmp    r9,rcx
  418613:	48 0f 42 c2          	cmovb  rax,rdx
  418617:	48 01 c7             	add    rdi,rax
			out(f, s, buf+9-s);
  41861a:	48 29 fe             	sub    rsi,rdi
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41861d:	41 f6 06 20          	test   BYTE PTR [r14],0x20
  418621:	0f 84 51 02 00 00    	je     418878 <fmt_fp+0x1e78>
		for (d=a; d<=r; d++) {
  418627:	48 8d 7d 04          	lea    rdi,[rbp+0x4]
  41862b:	48 3b 7c 24 18       	cmp    rdi,QWORD PTR [rsp+0x18]
  418630:	0f 87 84 01 00 00    	ja     4187ba <fmt_fp+0x1dba>
  418636:	48 b8 60 23 fc ff ff 	movabs rax,0xfffffffffffc2360
  41863d:	ff ff ff 
			if (d!=a) while (s>buf) *--s='0';
  418640:	4c 8d 54 24 79       	lea    r10,[rsp+0x79]
  418645:	4c 8d 4c 24 70       	lea    r9,[rsp+0x70]
  41864a:	48 c7 c5 f8 ff ff ff 	mov    rbp,0xfffffffffffffff8
  418651:	49 bb 60 23 fc ff ff 	movabs r11,0xfffffffffffc2360
  418658:	ff ff ff 
  41865b:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  418660:	49 b8 cd cc cc cc cc 	movabs r8,0xcccccccccccccccd
  418667:	cc cc cc 
			char *s = fmt_u(*d, buf+9);
  41866a:	8b 0f                	mov    ecx,DWORD PTR [rdi]
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  41866c:	4c 89 d6             	mov    rsi,r10
  41866f:	48 85 c9             	test   rcx,rcx
  418672:	0f 84 75 02 00 00    	je     4188ed <fmt_fp+0x1eed>
  418678:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41867f:	00 
  418680:	48 89 c8             	mov    rax,rcx
  418683:	48 83 ee 01          	sub    rsi,0x1
  418687:	49 f7 e0             	mul    r8
  41868a:	48 89 c8             	mov    rax,rcx
  41868d:	48 c1 ea 03          	shr    rdx,0x3
  418691:	4c 8d 24 92          	lea    r12,[rdx+rdx*4]
  418695:	4d 01 e4             	add    r12,r12
  418698:	4c 29 e0             	sub    rax,r12
  41869b:	83 c0 30             	add    eax,0x30
  41869e:	88 06                	mov    BYTE PTR [rsi],al
  4186a0:	48 89 c8             	mov    rax,rcx
  4186a3:	48 89 d1             	mov    rcx,rdx
  4186a6:	48 83 f8 09          	cmp    rax,0x9
  4186aa:	77 d4                	ja     418680 <fmt_fp+0x1c80>
			if (d!=a) while (s>buf) *--s='0';
  4186ac:	49 39 fd             	cmp    r13,rdi
  4186af:	0f 84 83 01 00 00    	je     418838 <fmt_fp+0x1e38>
  4186b5:	4c 39 ce             	cmp    rsi,r9
  4186b8:	0f 86 ed 00 00 00    	jbe    4187ab <fmt_fp+0x1dab>
  4186be:	4c 8d 66 ff          	lea    r12,[rsi-0x1]
  4186c2:	48 89 f1             	mov    rcx,rsi
  4186c5:	ba 01 00 00 00       	mov    edx,0x1
  4186ca:	48 89 f0             	mov    rax,rsi
  4186cd:	4c 29 c9             	sub    rcx,r9
  4186d0:	4d 39 cc             	cmp    r12,r9
  4186d3:	48 0f 43 d1          	cmovae rdx,rcx
  4186d7:	48 83 e9 01          	sub    rcx,0x1
  4186db:	48 83 f9 0e          	cmp    rcx,0xe
  4186df:	0f 86 25 08 00 00    	jbe    418f0a <fmt_fp+0x250a>
  4186e5:	4d 39 cc             	cmp    r12,r9
  4186e8:	0f 82 1c 08 00 00    	jb     418f0a <fmt_fp+0x250a>
  4186ee:	49 89 d4             	mov    r12,rdx
  4186f1:	48 89 f1             	mov    rcx,rsi
  4186f4:	49 83 e4 f0          	and    r12,0xfffffffffffffff0
  4186f8:	4c 29 e1             	sub    rcx,r12
  4186fb:	4c 8b 64 24 08       	mov    r12,QWORD PTR [rsp+0x8]
  418700:	66 43 0f 6f 04 3c    	movdqa xmm0,XMMWORD PTR [r12+r15*1]
  418706:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41870d:	00 00 00 
  418710:	0f 11 40 f0          	movups XMMWORD PTR [rax-0x10],xmm0
  418714:	48 83 e8 10          	sub    rax,0x10
  418718:	48 39 c1             	cmp    rcx,rax
  41871b:	75 f3                	jne    418710 <fmt_fp+0x1d10>
  41871d:	48 89 d1             	mov    rcx,rdx
  418720:	48 89 f0             	mov    rax,rsi
  418723:	48 83 e1 f0          	and    rcx,0xfffffffffffffff0
  418727:	48 29 c8             	sub    rax,rcx
  41872a:	48 39 d1             	cmp    rcx,rdx
  41872d:	74 7c                	je     4187ab <fmt_fp+0x1dab>
  41872f:	48 29 ca             	sub    rdx,rcx
  418732:	4c 8d 62 ff          	lea    r12,[rdx-0x1]
  418736:	49 83 fc 06          	cmp    r12,0x6
  41873a:	76 1d                	jbe    418759 <fmt_fp+0x1d59>
  41873c:	49 89 ec             	mov    r12,rbp
  41873f:	49 29 cc             	sub    r12,rcx
  418742:	4b 8b 0c 1f          	mov    rcx,QWORD PTR [r15+r11*1]
  418746:	4a 89 0c 26          	mov    QWORD PTR [rsi+r12*1],rcx
  41874a:	48 89 d1             	mov    rcx,rdx
  41874d:	48 83 e1 f8          	and    rcx,0xfffffffffffffff8
  418751:	48 29 c8             	sub    rax,rcx
  418754:	48 39 ca             	cmp    rdx,rcx
  418757:	74 52                	je     4187ab <fmt_fp+0x1dab>
  418759:	48 8d 50 ff          	lea    rdx,[rax-0x1]
  41875d:	c6 40 ff 30          	mov    BYTE PTR [rax-0x1],0x30
  418761:	49 39 d1             	cmp    r9,rdx
  418764:	73 45                	jae    4187ab <fmt_fp+0x1dab>
  418766:	48 8d 50 fe          	lea    rdx,[rax-0x2]
  41876a:	c6 40 fe 30          	mov    BYTE PTR [rax-0x2],0x30
  41876e:	49 39 d1             	cmp    r9,rdx
  418771:	73 38                	jae    4187ab <fmt_fp+0x1dab>
  418773:	48 8d 50 fd          	lea    rdx,[rax-0x3]
  418777:	c6 40 fd 30          	mov    BYTE PTR [rax-0x3],0x30
  41877b:	49 39 d1             	cmp    r9,rdx
  41877e:	73 2b                	jae    4187ab <fmt_fp+0x1dab>
  418780:	48 8d 50 fc          	lea    rdx,[rax-0x4]
  418784:	c6 40 fc 30          	mov    BYTE PTR [rax-0x4],0x30
  418788:	49 39 d1             	cmp    r9,rdx
  41878b:	73 1e                	jae    4187ab <fmt_fp+0x1dab>
  41878d:	48 8d 50 fb          	lea    rdx,[rax-0x5]
  418791:	c6 40 fb 30          	mov    BYTE PTR [rax-0x5],0x30
  418795:	49 39 d1             	cmp    r9,rdx
  418798:	73 11                	jae    4187ab <fmt_fp+0x1dab>
  41879a:	48 8d 50 fa          	lea    rdx,[rax-0x6]
  41879e:	c6 40 fa 30          	mov    BYTE PTR [rax-0x6],0x30
  4187a2:	49 39 d1             	cmp    r9,rdx
  4187a5:	73 04                	jae    4187ab <fmt_fp+0x1dab>
  4187a7:	c6 40 f9 30          	mov    BYTE PTR [rax-0x7],0x30
		for (d=a; d<=r; d++) {
  4187ab:	48 83 c7 04          	add    rdi,0x4
  4187af:	48 39 7c 24 18       	cmp    QWORD PTR [rsp+0x18],rdi
  4187b4:	0f 83 b0 fe ff ff    	jae    41866a <fmt_fp+0x1c6a>
  4187ba:	48 8b 7c 24 18       	mov    rdi,QWORD PTR [rsp+0x18]
		if (p || (fl&ALT_FORM)) out(f, ".", 1);
  4187bf:	8b 0c 24             	mov    ecx,DWORD PTR [rsp]
		for (d=a; d<=r; d++) {
  4187c2:	48 89 f8             	mov    rax,rdi
  4187c5:	48 83 c7 01          	add    rdi,0x1
  4187c9:	4c 29 e8             	sub    rax,r13
  4187cc:	48 c1 e8 02          	shr    rax,0x2
  4187d0:	4c 8d 04 85 04 00 00 	lea    r8,[rax*4+0x4]
  4187d7:	00 
  4187d8:	49 8d 45 01          	lea    rax,[r13+0x1]
  4187dc:	48 39 c7             	cmp    rdi,rax
  4187df:	b8 04 00 00 00       	mov    eax,0x4
  4187e4:	4c 0f 42 c0          	cmovb  r8,rax
  4187e8:	4b 8d 6c 05 00       	lea    rbp,[r13+r8*1+0x0]
		if (p || (fl&ALT_FORM)) out(f, ".", 1);
  4187ed:	85 c9                	test   ecx,ecx
  4187ef:	0f 85 94 02 00 00    	jne    418a89 <fmt_fp+0x2089>
  4187f5:	f6 44 24 14 08       	test   BYTE PTR [rsp+0x14],0x8
  4187fa:	0f 84 e3 f5 ff ff    	je     417de3 <fmt_fp+0x13e3>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418800:	41 f6 06 20          	test   BYTE PTR [r14],0x20
  418804:	0f 85 d9 f5 ff ff    	jne    417de3 <fmt_fp+0x13e3>
  41880a:	48 b8 73 1e fc ff ff 	movabs rax,0xfffffffffffc1e73
  418811:	ff ff ff 
  418814:	4c 89 f2             	mov    rdx,r14
  418817:	be 01 00 00 00       	mov    esi,0x1
  41881c:	49 8d 3c 07          	lea    rdi,[r15+rax*1]
  418820:	48 b8 60 e3 fb ff ff 	movabs rax,0xfffffffffffbe360
  418827:	ff ff ff 
  41882a:	4c 01 f8             	add    rax,r15
  41882d:	ff d0                	call   rax
  41882f:	e9 5f 02 00 00       	jmp    418a93 <fmt_fp+0x2093>
  418834:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
			else if (s==buf+9) *--s='0';
  418838:	4c 39 d6             	cmp    rsi,r10
  41883b:	0f 85 6a ff ff ff    	jne    4187ab <fmt_fp+0x1dab>
  418841:	c6 44 24 78 30       	mov    BYTE PTR [rsp+0x78],0x30
  418846:	e9 60 ff ff ff       	jmp    4187ab <fmt_fp+0x1dab>
  41884b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  418850:	48 39 f7             	cmp    rdi,rsi
  418853:	0f 85 c1 fd ff ff    	jne    41861a <fmt_fp+0x1c1a>
  418859:	c6 44 24 78 30       	mov    BYTE PTR [rsp+0x78],0x30
  41885e:	be 01 00 00 00       	mov    esi,0x1
  418863:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418868:	41 f6 06 20          	test   BYTE PTR [r14],0x20
  41886c:	0f 85 b5 fd ff ff    	jne    418627 <fmt_fp+0x1c27>
  418872:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  418878:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  41887d:	4c 89 f2             	mov    rdx,r14
		for (d=a; d<=r; d++) {
  418880:	48 83 c5 04          	add    rbp,0x4
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418884:	ff d0                	call   rax
		for (d=a; d<=r; d++) {
  418886:	48 39 6c 24 18       	cmp    QWORD PTR [rsp+0x18],rbp
  41888b:	0f 82 29 ff ff ff    	jb     4187ba <fmt_fp+0x1dba>
			char *s = fmt_u(*d, buf+9);
  418891:	8b 4d 00             	mov    ecx,DWORD PTR [rbp+0x0]
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  418894:	48 85 c9             	test   rcx,rcx
  418897:	0f 85 24 fc ff ff    	jne    4184c1 <fmt_fp+0x1ac1>
			if (d!=a) while (s>buf) *--s='0';
  41889d:	49 39 ed             	cmp    r13,rbp
  4188a0:	74 b7                	je     418859 <fmt_fp+0x1e59>
  4188a2:	48 8d 74 24 79       	lea    rsi,[rsp+0x79]
  4188a7:	48 8d 4c 24 70       	lea    rcx,[rsp+0x70]
  4188ac:	48 89 f7             	mov    rdi,rsi
  4188af:	e9 67 fc ff ff       	jmp    41851b <fmt_fp+0x1b1b>
		if (e > INT_MAX-l) return -1;
  4188b4:	44 39 d7             	cmp    edi,r10d
  4188b7:	0f 8f 01 fa ff ff    	jg     4182be <fmt_fp+0x18be>
		if (e>0) l+=e;
  4188bd:	41 8d 04 38          	lea    eax,[r8+rdi*1]
  4188c1:	85 ff                	test   edi,edi
  4188c3:	44 0f 4f c0          	cmovg  r8d,eax
  4188c7:	e9 68 f1 ff ff       	jmp    417a34 <fmt_fp+0x1034>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4188cc:	48 8b 74 24 38       	mov    rsi,QWORD PTR [rsp+0x38]
  4188d1:	48 8b 7c 24 30       	mov    rdi,QWORD PTR [rsp+0x30]
  4188d6:	4c 89 f2             	mov    rdx,r14
  4188d9:	48 b8 60 e3 fb ff ff 	movabs rax,0xfffffffffffbe360
  4188e0:	ff ff ff 
  4188e3:	4c 01 f8             	add    rax,r15
  4188e6:	ff d0                	call   rax
  4188e8:	e9 57 f2 ff ff       	jmp    417b44 <fmt_fp+0x1144>
			if (d!=a) while (s>buf) *--s='0';
  4188ed:	49 39 fd             	cmp    r13,rdi
  4188f0:	0f 85 c8 fd ff ff    	jne    4186be <fmt_fp+0x1cbe>
  4188f6:	e9 46 ff ff ff       	jmp    418841 <fmt_fp+0x1e41>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4188fb:	41 83 e0 20          	and    r8d,0x20
  4188ff:	45 89 e1             	mov    r9d,r12d
  418902:	48 89 fd             	mov    rbp,rdi
  418905:	e9 cd f6 ff ff       	jmp    417fd7 <fmt_fp+0x15d7>
  41890a:	d9 7c 24 5e          	fnstcw WORD PTR [rsp+0x5e]
		s=buf;
  41890e:	4c 89 e0             	mov    rax,r12
  418911:	48 bf d0 22 fc ff ff 	movabs rdi,0xfffffffffffc22d0
  418918:	ff ff ff 
  41891b:	48 b9 90 20 fc ff ff 	movabs rcx,0xfffffffffffc2090
  418922:	ff ff ff 
			y=16*(y-x);
  418925:	42 d9 04 3f          	fld    DWORD PTR [rdi+r15*1]
			*s++=xdigits[x]|(t&32);
  418929:	4c 01 f9             	add    rcx,r15
  41892c:	0f b7 54 24 5e       	movzx  edx,WORD PTR [rsp+0x5e]
  418931:	80 ce 0c             	or     dh,0xc
		} while (y);
  418934:	d9 ee                	fldz   
  418936:	d9 ca                	fxch   st(2)
  418938:	66 89 54 24 5c       	mov    WORD PTR [rsp+0x5c],dx
  41893d:	eb 0e                	jmp    41894d <fmt_fp+0x1f4d>
  41893f:	90                   	nop
			*s++=xdigits[x]|(t&32);
  418940:	48 89 d0             	mov    rax,rdx
		} while (y);
  418943:	db ea                	fucomi st,st(2)
  418945:	7a 06                	jp     41894d <fmt_fp+0x1f4d>
  418947:	0f 84 a7 e7 ff ff    	je     4170f4 <fmt_fp+0x6f4>
			int x=y;
  41894d:	d9 c0                	fld    st(0)
  41894f:	d9 6c 24 5c          	fldcw  WORD PTR [rsp+0x5c]
  418953:	db 5c 24 08          	fistp  DWORD PTR [rsp+0x8]
  418957:	d9 6c 24 5e          	fldcw  WORD PTR [rsp+0x5e]
			y=16*(y-x);
  41895b:	db 44 24 08          	fild   DWORD PTR [rsp+0x8]
			*s++=xdigits[x]|(t&32);
  41895f:	48 63 54 24 08       	movsxd rdx,DWORD PTR [rsp+0x8]
  418964:	0f b6 3c 11          	movzx  edi,BYTE PTR [rcx+rdx*1]
			if (s-buf==1 && (y||p>0||(fl&ALT_FORM))) *s++='.';
  418968:	48 8d 50 01          	lea    rdx,[rax+0x1]
			y=16*(y-x);
  41896c:	de e9                	fsubp  st(1),st
			*s++=xdigits[x]|(t&32);
  41896e:	09 f7                	or     edi,esi
  418970:	40 88 38             	mov    BYTE PTR [rax],dil
			y=16*(y-x);
  418973:	d8 c9                	fmul   st,st(1)
			if (s-buf==1 && (y||p>0||(fl&ALT_FORM))) *s++='.';
  418975:	4c 39 e0             	cmp    rax,r12
  418978:	75 c6                	jne    418940 <fmt_fp+0x1f40>
  41897a:	c6 40 01 2e          	mov    BYTE PTR [rax+0x1],0x2e
  41897e:	48 83 c0 02          	add    rax,0x2
  418982:	eb bf                	jmp    418943 <fmt_fp+0x1f43>
			if (s==buf+9) *--s='0';
  418984:	48 89 f8             	mov    rax,rdi
  418987:	45 31 c9             	xor    r9d,r9d
  41898a:	e9 a4 f5 ff ff       	jmp    417f33 <fmt_fp+0x1533>
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41898f:	4c 8d ac 24 90 00 00 	lea    r13,[rsp+0x90]
  418996:	00 
  418997:	ba 00 01 00 00       	mov    edx,0x100
  41899c:	be 30 00 00 00       	mov    esi,0x30
  4189a1:	48 b8 7c 79 fb ff ff 	movabs rax,0xfffffffffffb797c
  4189a8:	ff ff ff 
  4189ab:	4c 89 ef             	mov    rdi,r13
  4189ae:	4c 01 f8             	add    rax,r15
  4189b1:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  4189b3:	e9 db f3 ff ff       	jmp    417d93 <fmt_fp+0x1393>
				*d = *d + i;
  4189b8:	44 01 d0             	add    eax,r10d
  4189bb:	89 06                	mov    DWORD PTR [rsi],eax
				while (*d > 999999999) {
  4189bd:	3d ff c9 9a 3b       	cmp    eax,0x3b9ac9ff
  4189c2:	77 2e                	ja     4189f2 <fmt_fp+0x1ff2>
  4189c4:	e9 2c 08 00 00       	jmp    4191f5 <fmt_fp+0x27f5>
  4189c9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
					if (d<a) *--a=0;
  4189d0:	c7 45 fc 00 00 00 00 	mov    DWORD PTR [rbp-0x4],0x0
					(*d)++;
  4189d7:	8b 7e fc             	mov    edi,DWORD PTR [rsi-0x4]
					if (d<a) *--a=0;
  4189da:	48 8d 55 fc          	lea    rdx,[rbp-0x4]
  4189de:	48 89 d5             	mov    rbp,rdx
					(*d)++;
  4189e1:	8d 4f 01             	lea    ecx,[rdi+0x1]
  4189e4:	89 4e fc             	mov    DWORD PTR [rsi-0x4],ecx
				while (*d > 999999999) {
  4189e7:	81 f9 ff c9 9a 3b    	cmp    ecx,0x3b9ac9ff
  4189ed:	76 24                	jbe    418a13 <fmt_fp+0x2013>
			if (pl && *prefix=='-') round*=-1, small*=-1;
  4189ef:	48 89 c6             	mov    rsi,rax
					*d--=0;
  4189f2:	48 8d 46 fc          	lea    rax,[rsi-0x4]
  4189f6:	c7 40 04 00 00 00 00 	mov    DWORD PTR [rax+0x4],0x0
					if (d<a) *--a=0;
  4189fd:	48 39 e8             	cmp    rax,rbp
  418a00:	72 ce                	jb     4189d0 <fmt_fp+0x1fd0>
					(*d)++;
  418a02:	8b 7e fc             	mov    edi,DWORD PTR [rsi-0x4]
  418a05:	8d 57 01             	lea    edx,[rdi+0x1]
  418a08:	89 56 fc             	mov    DWORD PTR [rsi-0x4],edx
				while (*d > 999999999) {
  418a0b:	81 fa ff c9 9a 3b    	cmp    edx,0x3b9ac9ff
  418a11:	77 dc                	ja     4189ef <fmt_fp+0x1fef>
				for (i=10, e=9*(r-a); *a>=i; i*=10, e++);
  418a13:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  418a18:	8b 55 00             	mov    edx,DWORD PTR [rbp+0x0]
  418a1b:	48 29 e8             	sub    rax,rbp
  418a1e:	48 c1 f8 02          	sar    rax,0x2
  418a22:	8d 3c c0             	lea    edi,[rax+rax*8]
  418a25:	83 fa 09             	cmp    edx,0x9
  418a28:	0f 86 f8 ee ff ff    	jbe    417926 <fmt_fp+0xf26>
  418a2e:	b8 0a 00 00 00       	mov    eax,0xa
  418a33:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  418a38:	8d 04 80             	lea    eax,[rax+rax*4]
  418a3b:	83 c7 01             	add    edi,0x1
  418a3e:	01 c0                	add    eax,eax
  418a40:	39 d0                	cmp    eax,edx
  418a42:	76 f4                	jbe    418a38 <fmt_fp+0x2038>
  418a44:	e9 dd ee ff ff       	jmp    417926 <fmt_fp+0xf26>
  418a49:	4d 89 ea             	mov    r10,r13
  418a4c:	e9 6d ea ff ff       	jmp    4174be <fmt_fp+0xabe>
  418a51:	49 89 ea             	mov    r10,rbp
  418a54:	44 89 ed             	mov    ebp,r13d
  418a57:	e9 af e8 ff ff       	jmp    41730b <fmt_fp+0x90b>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418a5c:	48 b8 60 e3 fb ff ff 	movabs rax,0xfffffffffffbe360
  418a63:	ff ff ff 
  418a66:	48 8b 7c 24 30       	mov    rdi,QWORD PTR [rsp+0x30]
		out(f, prefix, pl);
  418a6b:	49 63 f5             	movsxd rsi,r13d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418a6e:	4c 89 f2             	mov    rdx,r14
  418a71:	4c 01 f8             	add    rax,r15
  418a74:	ff d0                	call   rax
  418a76:	e9 cd e7 ff ff       	jmp    417248 <fmt_fp+0x848>
			t-=2;
  418a7b:	83 6c 24 20 02       	sub    DWORD PTR [rsp+0x20],0x2
			p--;
  418a80:	83 2c 24 01          	sub    DWORD PTR [rsp],0x1
  418a84:	e9 5c f9 ff ff       	jmp    4183e5 <fmt_fp+0x19e5>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418a89:	41 f6 06 20          	test   BYTE PTR [r14],0x20
  418a8d:	0f 84 77 fd ff ff    	je     41880a <fmt_fp+0x1e0a>
		for (; d<z && p>0; d++, p-=9) {
  418a93:	8b 14 24             	mov    edx,DWORD PTR [rsp]
  418a96:	85 d2                	test   edx,edx
  418a98:	0f 8e 45 f3 ff ff    	jle    417de3 <fmt_fp+0x13e3>
  418a9e:	48 39 dd             	cmp    rbp,rbx
  418aa1:	0f 83 1b 03 00 00    	jae    418dc2 <fmt_fp+0x23c2>
  418aa7:	4c 8d 5c 24 79       	lea    r11,[rsp+0x79]
  418aac:	48 89 d9             	mov    rcx,rbx
  418aaf:	4c 8d 64 24 70       	lea    r12,[rsp+0x70]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418ab4:	48 b8 60 e3 fb ff ff 	movabs rax,0xfffffffffffbe360
  418abb:	ff ff ff 
			while (s>buf) *--s='0';
  418abe:	49 bd 60 23 fc ff ff 	movabs r13,0xfffffffffffc2360
  418ac5:	ff ff ff 
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418ac8:	4c 01 f8             	add    rax,r15
  418acb:	4c 89 db             	mov    rbx,r11
  418ace:	49 b9 60 23 fc ff ff 	movabs r9,0xfffffffffffc2360
  418ad5:	ff ff ff 
  418ad8:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
			char *s = fmt_u(*d, buf+9);
  418add:	8b 75 00             	mov    esi,DWORD PTR [rbp+0x0]
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  418ae0:	48 89 df             	mov    rdi,rbx
  418ae3:	48 85 f6             	test   rsi,rsi
  418ae6:	74 45                	je     418b2d <fmt_fp+0x212d>
  418ae8:	49 b8 cd cc cc cc cc 	movabs r8,0xcccccccccccccccd
  418aef:	cc cc cc 
  418af2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  418af8:	48 89 f0             	mov    rax,rsi
  418afb:	48 83 ef 01          	sub    rdi,0x1
  418aff:	49 f7 e0             	mul    r8
  418b02:	48 89 f0             	mov    rax,rsi
  418b05:	48 c1 ea 03          	shr    rdx,0x3
  418b09:	4c 8d 14 92          	lea    r10,[rdx+rdx*4]
  418b0d:	4d 01 d2             	add    r10,r10
  418b10:	4c 29 d0             	sub    rax,r10
  418b13:	83 c0 30             	add    eax,0x30
  418b16:	88 07                	mov    BYTE PTR [rdi],al
  418b18:	48 89 f0             	mov    rax,rsi
  418b1b:	48 89 d6             	mov    rsi,rdx
  418b1e:	48 83 f8 09          	cmp    rax,0x9
  418b22:	77 d4                	ja     418af8 <fmt_fp+0x20f8>
			while (s>buf) *--s='0';
  418b24:	4c 39 e7             	cmp    rdi,r12
  418b27:	0f 86 f5 00 00 00    	jbe    418c22 <fmt_fp+0x2222>
  418b2d:	4c 8d 47 ff          	lea    r8,[rdi-0x1]
  418b31:	48 89 f8             	mov    rax,rdi
  418b34:	ba 01 00 00 00       	mov    edx,0x1
  418b39:	4c 29 e0             	sub    rax,r12
  418b3c:	4d 39 e0             	cmp    r8,r12
  418b3f:	48 0f 43 d0          	cmovae rdx,rax
  418b43:	48 83 e8 01          	sub    rax,0x1
  418b47:	48 83 f8 0e          	cmp    rax,0xe
  418b4b:	0f 86 88 03 00 00    	jbe    418ed9 <fmt_fp+0x24d9>
  418b51:	4d 39 e0             	cmp    r8,r12
  418b54:	0f 82 7f 03 00 00    	jb     418ed9 <fmt_fp+0x24d9>
  418b5a:	48 89 d0             	mov    rax,rdx
  418b5d:	48 89 fe             	mov    rsi,rdi
  418b60:	66 43 0f 6f 04 39    	movdqa xmm0,XMMWORD PTR [r9+r15*1]
  418b66:	48 83 e0 f0          	and    rax,0xfffffffffffffff0
  418b6a:	48 29 c6             	sub    rsi,rax
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  418b6d:	48 89 f8             	mov    rax,rdi
			while (s>buf) *--s='0';
  418b70:	0f 11 40 f0          	movups XMMWORD PTR [rax-0x10],xmm0
  418b74:	48 83 e8 10          	sub    rax,0x10
  418b78:	48 39 f0             	cmp    rax,rsi
  418b7b:	75 f3                	jne    418b70 <fmt_fp+0x2170>
  418b7d:	48 89 d6             	mov    rsi,rdx
  418b80:	48 89 f8             	mov    rax,rdi
  418b83:	48 83 e6 f0          	and    rsi,0xfffffffffffffff0
  418b87:	48 29 f0             	sub    rax,rsi
  418b8a:	48 39 d6             	cmp    rsi,rdx
  418b8d:	74 7c                	je     418c0b <fmt_fp+0x220b>
  418b8f:	48 29 f2             	sub    rdx,rsi
  418b92:	4c 8d 52 ff          	lea    r10,[rdx-0x1]
  418b96:	49 83 fa 06          	cmp    r10,0x6
  418b9a:	76 1d                	jbe    418bb9 <fmt_fp+0x21b9>
  418b9c:	49 89 fa             	mov    r10,rdi
  418b9f:	49 29 f2             	sub    r10,rsi
  418ba2:	4b 8b 34 2f          	mov    rsi,QWORD PTR [r15+r13*1]
  418ba6:	49 89 72 f8          	mov    QWORD PTR [r10-0x8],rsi
  418baa:	48 89 d6             	mov    rsi,rdx
  418bad:	48 83 e6 f8          	and    rsi,0xfffffffffffffff8
  418bb1:	48 29 f0             	sub    rax,rsi
  418bb4:	48 39 f2             	cmp    rdx,rsi
  418bb7:	74 52                	je     418c0b <fmt_fp+0x220b>
  418bb9:	48 8d 50 ff          	lea    rdx,[rax-0x1]
  418bbd:	c6 40 ff 30          	mov    BYTE PTR [rax-0x1],0x30
  418bc1:	49 39 d4             	cmp    r12,rdx
  418bc4:	73 45                	jae    418c0b <fmt_fp+0x220b>
  418bc6:	48 8d 50 fe          	lea    rdx,[rax-0x2]
  418bca:	c6 40 fe 30          	mov    BYTE PTR [rax-0x2],0x30
  418bce:	49 39 d4             	cmp    r12,rdx
  418bd1:	73 38                	jae    418c0b <fmt_fp+0x220b>
  418bd3:	48 8d 50 fd          	lea    rdx,[rax-0x3]
  418bd7:	c6 40 fd 30          	mov    BYTE PTR [rax-0x3],0x30
  418bdb:	49 39 d4             	cmp    r12,rdx
  418bde:	73 2b                	jae    418c0b <fmt_fp+0x220b>
  418be0:	48 8d 50 fc          	lea    rdx,[rax-0x4]
  418be4:	c6 40 fc 30          	mov    BYTE PTR [rax-0x4],0x30
  418be8:	49 39 d4             	cmp    r12,rdx
  418beb:	73 1e                	jae    418c0b <fmt_fp+0x220b>
  418bed:	48 8d 50 fb          	lea    rdx,[rax-0x5]
  418bf1:	c6 40 fb 30          	mov    BYTE PTR [rax-0x5],0x30
  418bf5:	49 39 d4             	cmp    r12,rdx
  418bf8:	73 11                	jae    418c0b <fmt_fp+0x220b>
  418bfa:	48 8d 50 fa          	lea    rdx,[rax-0x6]
  418bfe:	c6 40 fa 30          	mov    BYTE PTR [rax-0x6],0x30
  418c02:	49 39 d4             	cmp    r12,rdx
  418c05:	73 04                	jae    418c0b <fmt_fp+0x220b>
  418c07:	c6 40 f9 30          	mov    BYTE PTR [rax-0x7],0x30
  418c0b:	4c 89 e0             	mov    rax,r12
  418c0e:	48 c7 c2 ff ff ff ff 	mov    rdx,0xffffffffffffffff
  418c15:	48 29 f8             	sub    rax,rdi
  418c18:	4d 39 e0             	cmp    r8,r12
  418c1b:	48 0f 42 c2          	cmovb  rax,rdx
  418c1f:	48 01 c7             	add    rdi,rax
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418c22:	41 f6 06 20          	test   BYTE PTR [r14],0x20
  418c26:	0f 84 54 02 00 00    	je     418e80 <fmt_fp+0x2480>
		for (; d<z && p>0; d++, p-=9) {
  418c2c:	4c 8d 45 04          	lea    r8,[rbp+0x4]
  418c30:	83 2c 24 09          	sub    DWORD PTR [rsp],0x9
  418c34:	49 89 db             	mov    r11,rbx
  418c37:	8b 2c 24             	mov    ebp,DWORD PTR [rsp]
  418c3a:	48 89 cb             	mov    rbx,rcx
  418c3d:	49 39 c8             	cmp    r8,rcx
  418c40:	0f 83 7c 01 00 00    	jae    418dc2 <fmt_fp+0x23c2>
  418c46:	85 ed                	test   ebp,ebp
  418c48:	0f 8e 95 f1 ff ff    	jle    417de3 <fmt_fp+0x13e3>
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  418c4e:	4c 89 34 24          	mov    QWORD PTR [rsp],r14
			while (s>buf) *--s='0';
  418c52:	49 c7 c2 f8 ff ff ff 	mov    r10,0xfffffffffffffff8
  418c59:	49 b9 60 23 fc ff ff 	movabs r9,0xfffffffffffc2360
  418c60:	ff ff ff 
  418c63:	49 bd 60 23 fc ff ff 	movabs r13,0xfffffffffffc2360
  418c6a:	ff ff ff 
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  418c6d:	48 bf cd cc cc cc cc 	movabs rdi,0xcccccccccccccccd
  418c74:	cc cc cc 
			char *s = fmt_u(*d, buf+9);
  418c77:	41 8b 08             	mov    ecx,DWORD PTR [r8]
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  418c7a:	4c 89 de             	mov    rsi,r11
  418c7d:	48 85 c9             	test   rcx,rcx
  418c80:	74 3b                	je     418cbd <fmt_fp+0x22bd>
  418c82:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  418c88:	48 89 c8             	mov    rax,rcx
  418c8b:	48 83 ee 01          	sub    rsi,0x1
  418c8f:	48 f7 e7             	mul    rdi
  418c92:	48 89 c8             	mov    rax,rcx
  418c95:	48 c1 ea 03          	shr    rdx,0x3
  418c99:	4c 8d 34 92          	lea    r14,[rdx+rdx*4]
  418c9d:	4d 01 f6             	add    r14,r14
  418ca0:	4c 29 f0             	sub    rax,r14
  418ca3:	83 c0 30             	add    eax,0x30
  418ca6:	88 06                	mov    BYTE PTR [rsi],al
  418ca8:	48 89 c8             	mov    rax,rcx
  418cab:	48 89 d1             	mov    rcx,rdx
  418cae:	48 83 f8 09          	cmp    rax,0x9
  418cb2:	77 d4                	ja     418c88 <fmt_fp+0x2288>
			while (s>buf) *--s='0';
  418cb4:	4c 39 e6             	cmp    rsi,r12
  418cb7:	0f 86 e6 00 00 00    	jbe    418da3 <fmt_fp+0x23a3>
  418cbd:	4c 8d 76 ff          	lea    r14,[rsi-0x1]
  418cc1:	48 89 f1             	mov    rcx,rsi
  418cc4:	ba 01 00 00 00       	mov    edx,0x1
  418cc9:	48 89 f0             	mov    rax,rsi
  418ccc:	4c 29 e1             	sub    rcx,r12
  418ccf:	4d 39 e6             	cmp    r14,r12
  418cd2:	48 0f 43 d1          	cmovae rdx,rcx
  418cd6:	48 83 e9 01          	sub    rcx,0x1
  418cda:	48 83 f9 0e          	cmp    rcx,0xe
  418cde:	0f 86 eb 01 00 00    	jbe    418ecf <fmt_fp+0x24cf>
  418ce4:	4d 39 e6             	cmp    r14,r12
  418ce7:	0f 82 e2 01 00 00    	jb     418ecf <fmt_fp+0x24cf>
  418ced:	49 89 d6             	mov    r14,rdx
  418cf0:	48 89 f1             	mov    rcx,rsi
  418cf3:	66 43 0f 6f 44 3d 00 	movdqa xmm0,XMMWORD PTR [r13+r15*1+0x0]
  418cfa:	49 83 e6 f0          	and    r14,0xfffffffffffffff0
  418cfe:	4c 29 f1             	sub    rcx,r14
  418d01:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  418d08:	0f 11 40 f0          	movups XMMWORD PTR [rax-0x10],xmm0
  418d0c:	48 83 e8 10          	sub    rax,0x10
  418d10:	48 39 c8             	cmp    rax,rcx
  418d13:	75 f3                	jne    418d08 <fmt_fp+0x2308>
  418d15:	48 89 d1             	mov    rcx,rdx
  418d18:	48 89 f0             	mov    rax,rsi
  418d1b:	48 83 e1 f0          	and    rcx,0xfffffffffffffff0
  418d1f:	48 29 c8             	sub    rax,rcx
  418d22:	48 39 d1             	cmp    rcx,rdx
  418d25:	74 7c                	je     418da3 <fmt_fp+0x23a3>
  418d27:	48 29 ca             	sub    rdx,rcx
  418d2a:	4c 8d 72 ff          	lea    r14,[rdx-0x1]
  418d2e:	49 83 fe 06          	cmp    r14,0x6
  418d32:	76 1d                	jbe    418d51 <fmt_fp+0x2351>
  418d34:	4d 89 d6             	mov    r14,r10
  418d37:	49 29 ce             	sub    r14,rcx
  418d3a:	4b 8b 0c 0f          	mov    rcx,QWORD PTR [r15+r9*1]
  418d3e:	4a 89 0c 36          	mov    QWORD PTR [rsi+r14*1],rcx
  418d42:	48 89 d1             	mov    rcx,rdx
  418d45:	48 83 e1 f8          	and    rcx,0xfffffffffffffff8
  418d49:	48 29 c8             	sub    rax,rcx
  418d4c:	48 39 d1             	cmp    rcx,rdx
  418d4f:	74 52                	je     418da3 <fmt_fp+0x23a3>
  418d51:	48 8d 50 ff          	lea    rdx,[rax-0x1]
  418d55:	c6 40 ff 30          	mov    BYTE PTR [rax-0x1],0x30
  418d59:	49 39 d4             	cmp    r12,rdx
  418d5c:	73 45                	jae    418da3 <fmt_fp+0x23a3>
  418d5e:	48 8d 50 fe          	lea    rdx,[rax-0x2]
  418d62:	c6 40 fe 30          	mov    BYTE PTR [rax-0x2],0x30
  418d66:	49 39 d4             	cmp    r12,rdx
  418d69:	73 38                	jae    418da3 <fmt_fp+0x23a3>
  418d6b:	48 8d 50 fd          	lea    rdx,[rax-0x3]
  418d6f:	c6 40 fd 30          	mov    BYTE PTR [rax-0x3],0x30
  418d73:	49 39 d4             	cmp    r12,rdx
  418d76:	73 2b                	jae    418da3 <fmt_fp+0x23a3>
  418d78:	48 8d 50 fc          	lea    rdx,[rax-0x4]
  418d7c:	c6 40 fc 30          	mov    BYTE PTR [rax-0x4],0x30
  418d80:	49 39 d4             	cmp    r12,rdx
  418d83:	73 1e                	jae    418da3 <fmt_fp+0x23a3>
  418d85:	48 8d 50 fb          	lea    rdx,[rax-0x5]
  418d89:	c6 40 fb 30          	mov    BYTE PTR [rax-0x5],0x30
  418d8d:	49 39 d4             	cmp    r12,rdx
  418d90:	73 11                	jae    418da3 <fmt_fp+0x23a3>
  418d92:	48 8d 50 fa          	lea    rdx,[rax-0x6]
  418d96:	c6 40 fa 30          	mov    BYTE PTR [rax-0x6],0x30
  418d9a:	49 39 d4             	cmp    r12,rdx
  418d9d:	73 04                	jae    418da3 <fmt_fp+0x23a3>
  418d9f:	c6 40 f9 30          	mov    BYTE PTR [rax-0x7],0x30
		for (; d<z && p>0; d++, p-=9) {
  418da3:	83 ed 09             	sub    ebp,0x9
  418da6:	49 83 c0 04          	add    r8,0x4
  418daa:	85 ed                	test   ebp,ebp
  418dac:	0f 8e a0 02 00 00    	jle    419052 <fmt_fp+0x2652>
  418db2:	4c 39 c3             	cmp    rbx,r8
  418db5:	0f 87 bc fe ff ff    	ja     418c77 <fmt_fp+0x2277>
  418dbb:	4c 8b 34 24          	mov    r14,QWORD PTR [rsp]
  418dbf:	89 2c 24             	mov    DWORD PTR [rsp],ebp
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  418dc2:	8b 1c 24             	mov    ebx,DWORD PTR [rsp]
  418dc5:	85 db                	test   ebx,ebx
  418dc7:	0f 8e 16 f0 ff ff    	jle    417de3 <fmt_fp+0x13e3>
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  418dcd:	81 fb 00 01 00 00    	cmp    ebx,0x100
  418dd3:	0f 8f 82 02 00 00    	jg     41905b <fmt_fp+0x265b>
  418dd9:	48 63 eb             	movsxd rbp,ebx
  418ddc:	4c 8d ac 24 90 00 00 	lea    r13,[rsp+0x90]
  418de3:	00 
  418de4:	be 30 00 00 00       	mov    esi,0x30
  418de9:	48 b8 7c 79 fb ff ff 	movabs rax,0xfffffffffffb797c
  418df0:	ff ff ff 
  418df3:	4c 01 f8             	add    rax,r15
  418df6:	48 89 ea             	mov    rdx,rbp
  418df9:	4c 89 ef             	mov    rdi,r13
  418dfc:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  418dfe:	81 fb 00 01 00 00    	cmp    ebx,0x100
  418e04:	0f 85 f4 03 00 00    	jne    4191fe <fmt_fp+0x27fe>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418e0a:	48 bd 60 e3 fb ff ff 	movabs rbp,0xfffffffffffbe360
  418e11:	ff ff ff 
  418e14:	8b 1c 24             	mov    ebx,DWORD PTR [rsp]
  418e17:	41 8b 16             	mov    edx,DWORD PTR [r14]
  418e1a:	81 eb 00 01 00 00    	sub    ebx,0x100
  418e20:	41 89 dc             	mov    r12d,ebx
  418e23:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  418e28:	89 d0                	mov    eax,edx
  418e2a:	83 e0 20             	and    eax,0x20
  418e2d:	0f 84 ed 01 00 00    	je     419020 <fmt_fp+0x2620>
	for (; l >= sizeof pad; l -= sizeof pad)
  418e33:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  418e3a:	76 14                	jbe    418e50 <fmt_fp+0x2450>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418e3c:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  418e3e:	41 81 ec 00 01 00 00 	sub    r12d,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418e45:	89 d0                	mov    eax,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  418e47:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  418e4e:	77 ee                	ja     418e3e <fmt_fp+0x243e>
	out(f, pad, l);
  418e50:	0f b6 eb             	movzx  ebp,bl
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418e53:	85 c0                	test   eax,eax
  418e55:	0f 85 88 ef ff ff    	jne    417de3 <fmt_fp+0x13e3>
  418e5b:	48 b8 60 e3 fb ff ff 	movabs rax,0xfffffffffffbe360
  418e62:	ff ff ff 
  418e65:	4c 89 f2             	mov    rdx,r14
  418e68:	48 89 ee             	mov    rsi,rbp
  418e6b:	4c 89 ef             	mov    rdi,r13
  418e6e:	4c 01 f8             	add    rax,r15
  418e71:	ff d0                	call   rax
  418e73:	e9 6b ef ff ff       	jmp    417de3 <fmt_fp+0x13e3>
  418e78:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  418e7f:	00 
  418e80:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
			out(f, s, MIN(9,p));
  418e85:	8b 0c 24             	mov    ecx,DWORD PTR [rsp]
  418e88:	b8 09 00 00 00       	mov    eax,0x9
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418e8d:	4c 89 f2             	mov    rdx,r14
  418e90:	4c 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],r9
			out(f, s, MIN(9,p));
  418e95:	39 c1                	cmp    ecx,eax
  418e97:	0f 4e c1             	cmovle eax,ecx
		for (; d<z && p>0; d++, p-=9) {
  418e9a:	48 83 c5 04          	add    rbp,0x4
			out(f, s, MIN(9,p));
  418e9e:	48 63 f0             	movsxd rsi,eax
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418ea1:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  418ea6:	ff d0                	call   rax
		for (; d<z && p>0; d++, p-=9) {
  418ea8:	83 2c 24 09          	sub    DWORD PTR [rsp],0x9
  418eac:	8b 0c 24             	mov    ecx,DWORD PTR [rsp]
  418eaf:	85 c9                	test   ecx,ecx
  418eb1:	0f 8e 2c ef ff ff    	jle    417de3 <fmt_fp+0x13e3>
  418eb7:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  418ebc:	4c 8b 4c 24 08       	mov    r9,QWORD PTR [rsp+0x8]
  418ec1:	48 39 cd             	cmp    rbp,rcx
  418ec4:	0f 82 13 fc ff ff    	jb     418add <fmt_fp+0x20dd>
  418eca:	e9 f3 fe ff ff       	jmp    418dc2 <fmt_fp+0x23c2>
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  418ecf:	48 89 f0             	mov    rax,rsi
  418ed2:	31 c9                	xor    ecx,ecx
  418ed4:	e9 4e fe ff ff       	jmp    418d27 <fmt_fp+0x2327>
  418ed9:	48 89 f8             	mov    rax,rdi
  418edc:	31 f6                	xor    esi,esi
  418ede:	e9 ac fc ff ff       	jmp    418b8f <fmt_fp+0x218f>
		if (estr==ebuf) *--estr='0';
  418ee3:	c6 44 24 6f 30       	mov    BYTE PTR [rsp+0x6f],0x30
  418ee8:	48 8d 74 24 6f       	lea    rsi,[rsp+0x6f]
  418eed:	e9 2b e1 ff ff       	jmp    41701d <fmt_fp+0x61d>
  418ef2:	49 89 da             	mov    r10,rbx
  418ef5:	89 eb                	mov    ebx,ebp
  418ef7:	8b 2c 24             	mov    ebp,DWORD PTR [rsp]
  418efa:	e9 66 e7 ff ff       	jmp    417665 <fmt_fp+0xc65>
			if (d!=a) while (s>buf) *--s='0';
  418eff:	48 89 f8             	mov    rax,rdi
  418f02:	45 31 c0             	xor    r8d,r8d
  418f05:	e9 7d f6 ff ff       	jmp    418587 <fmt_fp+0x1b87>
  418f0a:	48 89 f0             	mov    rax,rsi
  418f0d:	31 c9                	xor    ecx,ecx
  418f0f:	e9 1b f8 ff ff       	jmp    41872f <fmt_fp+0x1d2f>
  418f14:	4d 89 ea             	mov    r10,r13
  418f17:	45 89 e5             	mov    r13d,r12d
  418f1a:	e9 2e e8 ff ff       	jmp    41774d <fmt_fp+0xd4d>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418f1f:	48 b8 60 e3 fb ff ff 	movabs rax,0xfffffffffffbe360
  418f26:	ff ff ff 
	out(f, pad, l);
  418f29:	49 63 f4             	movsxd rsi,r12d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418f2c:	4c 89 f2             	mov    rdx,r14
  418f2f:	4c 89 ef             	mov    rdi,r13
  418f32:	4c 01 f8             	add    rax,r15
  418f35:	ff d0                	call   rax
  418f37:	e9 5d ef ff ff       	jmp    417e99 <fmt_fp+0x1499>
			if ((*d/i & 1) || (i==1000000000 && d>a && (d[-1]&1)))
  418f3c:	81 f9 00 ca 9a 3b    	cmp    ecx,0x3b9aca00
  418f42:	75 0f                	jne    418f53 <fmt_fp+0x2553>
  418f44:	48 39 ee             	cmp    rsi,rbp
  418f47:	76 0a                	jbe    418f53 <fmt_fp+0x2553>
  418f49:	f6 46 fc 01          	test   BYTE PTR [rsi-0x4],0x1
  418f4d:	0f 85 56 e9 ff ff    	jne    4178a9 <fmt_fp+0xea9>
			long double round = 2/LDBL_EPSILON;
  418f53:	48 b8 bc 22 fc ff ff 	movabs rax,0xfffffffffffc22bc
  418f5a:	ff ff ff 
  418f5d:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  418f61:	e9 51 e9 ff ff       	jmp    4178b7 <fmt_fp+0xeb7>
			l = (p+2) + (ebuf-estr);
  418f66:	83 c7 02             	add    edi,0x2
  418f69:	89 f0                	mov    eax,esi
  418f6b:	89 fa                	mov    edx,edi
  418f6d:	01 f8                	add    eax,edi
		pad(f, '0', l-(ebuf-estr)-(s-buf), 0, 0);
  418f6f:	29 da                	sub    edx,ebx
  418f71:	89 54 24 38          	mov    DWORD PTR [rsp+0x38],edx
  418f75:	89 54 24 08          	mov    DWORD PTR [rsp+0x8],edx
			l = (p+2) + (ebuf-estr);
  418f79:	e9 d7 e1 ff ff       	jmp    417155 <fmt_fp+0x755>
			if ((*d/i & 1) || (i==1000000000 && d>a && (d[-1]&1)))
  418f7e:	48 b8 c0 22 fc ff ff 	movabs rax,0xfffffffffffc22c0
  418f85:	ff ff ff 
  418f88:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
				round += 2;
  418f8c:	48 b8 20 23 fc ff ff 	movabs rax,0xfffffffffffc2320
  418f93:	ff ff ff 
  418f96:	41 db 2c 07          	fld    TBYTE PTR [r15+rax*1]
			if (x<i/2) small=0x0.8p0;
  418f9a:	48 b8 c4 22 fc ff ff 	movabs rax,0xfffffffffffc22c4
  418fa1:	ff ff ff 
  418fa4:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  418fa8:	d9 c9                	fxch   st(1)
  418faa:	d9 ca                	fxch   st(2)
  418fac:	d9 c9                	fxch   st(1)
  418fae:	e9 31 e9 ff ff       	jmp    4178e4 <fmt_fp+0xee4>
				p = MIN(p,MAX(0,9*(z-r-1)-j));
  418fb3:	48 29 f2             	sub    rdx,rsi
  418fb6:	b8 00 00 00 00       	mov    eax,0x0
  418fbb:	48 0f 48 d0          	cmovs  rdx,rax
  418fbf:	48 39 ca             	cmp    rdx,rcx
  418fc2:	48 0f 4e ca          	cmovle rcx,rdx
  418fc6:	48 89 0c 24          	mov    QWORD PTR [rsp],rcx
  418fca:	e9 85 e9 ff ff       	jmp    417954 <fmt_fp+0xf54>
		for (i=10, j++; j<9; i*=10, j++);
  418fcf:	48 b8 e0 22 fc ff ff 	movabs rax,0xfffffffffffc22e0
  418fd6:	ff ff ff 
  418fd9:	f3 41 0f 7e 04 07    	movq   xmm0,QWORD PTR [r15+rax*1]
  418fdf:	66 0f 7e c2          	movd   edx,xmm0
  418fe3:	66 0f 70 e0 e5       	pshufd xmm4,xmm0,0xe5
  418fe8:	66 0f 7e e0          	movd   eax,xmm4
  418fec:	0f af d0             	imul   edx,eax
  418fef:	8d 0c 92             	lea    ecx,[rdx+rdx*4]
  418ff2:	01 c9                	add    ecx,ecx
  418ff4:	41 83 e0 01          	and    r8d,0x1
  418ff8:	0f 84 22 de ff ff    	je     416e20 <fmt_fp+0x420>
  418ffe:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  419001:	01 c9                	add    ecx,ecx
  419003:	e9 18 de ff ff       	jmp    416e20 <fmt_fp+0x420>
			while (re--) round*=16;
  419008:	48 b8 98 22 fc ff ff 	movabs rax,0xfffffffffffc2298
  41900f:	ff ff ff 
  419012:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  419016:	e9 91 df ff ff       	jmp    416fac <fmt_fp+0x5ac>
  41901b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419020:	4c 89 f2             	mov    rdx,r14
  419023:	be 00 01 00 00       	mov    esi,0x100
  419028:	49 8d 04 2f          	lea    rax,[r15+rbp*1]
  41902c:	4c 89 ef             	mov    rdi,r13
  41902f:	ff d0                	call   rax
  419031:	41 8b 16             	mov    edx,DWORD PTR [r14]
  419034:	89 d0                	mov    eax,edx
  419036:	83 e0 20             	and    eax,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  419039:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  419040:	0f 86 0a fe ff ff    	jbe    418e50 <fmt_fp+0x2450>
  419046:	41 81 ec 00 01 00 00 	sub    r12d,0x100
  41904d:	e9 d6 fd ff ff       	jmp    418e28 <fmt_fp+0x2428>
  419052:	4c 8b 34 24          	mov    r14,QWORD PTR [rsp]
  419056:	e9 88 ed ff ff       	jmp    417de3 <fmt_fp+0x13e3>
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41905b:	4c 8d ac 24 90 00 00 	lea    r13,[rsp+0x90]
  419062:	00 
  419063:	ba 00 01 00 00       	mov    edx,0x100
  419068:	be 30 00 00 00       	mov    esi,0x30
  41906d:	48 b8 7c 79 fb ff ff 	movabs rax,0xfffffffffffb797c
  419074:	ff ff ff 
  419077:	4c 89 ef             	mov    rdi,r13
  41907a:	4c 01 f8             	add    rax,r15
  41907d:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  41907f:	e9 86 fd ff ff       	jmp    418e0a <fmt_fp+0x240a>
  419084:	d9 c9                	fxch   st(1)
				y=-y;
  419086:	d9 e0                	fchs   
				y-=round;
  419088:	d8 e1                	fsub   st,st(1)
				y+=round;
  41908a:	de c1                	faddp  st(1),st
				y=-y;
  41908c:	d9 e0                	fchs   
  41908e:	e9 2b df ff ff       	jmp    416fbe <fmt_fp+0x5be>
  419093:	48 b8 c0 22 fc ff ff 	movabs rax,0xfffffffffffc22c0
  41909a:	ff ff ff 
  41909d:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
			if (x<i/2) small=0x0.8p0;
  4190a1:	48 b8 c4 22 fc ff ff 	movabs rax,0xfffffffffffc22c4
  4190a8:	ff ff ff 
  4190ab:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  4190af:	e9 30 e8 ff ff       	jmp    4178e4 <fmt_fp+0xee4>
  4190b4:	48 89 de             	mov    rsi,rbx
  4190b7:	e9 6a e8 ff ff       	jmp    417926 <fmt_fp+0xf26>
			else if (x==i/2 && d+1==z) small=0x1.0p0;
  4190bc:	48 8d 46 04          	lea    rax,[rsi+0x4]
  4190c0:	48 39 c3             	cmp    rbx,rax
  4190c3:	0f 85 ff e7 ff ff    	jne    4178c8 <fmt_fp+0xec8>
  4190c9:	d9 e8                	fld1   
  4190cb:	d9 e0                	fchs   
  4190cd:	d9 e8                	fld1   
  4190cf:	e9 10 e8 ff ff       	jmp    4178e4 <fmt_fp+0xee4>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4190d4:	48 b8 60 e3 fb ff ff 	movabs rax,0xfffffffffffbe360
  4190db:	ff ff ff 
	out(f, pad, l);
  4190de:	49 63 f4             	movsxd rsi,r12d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4190e1:	4c 89 f2             	mov    rdx,r14
  4190e4:	4c 89 d7             	mov    rdi,r10
  4190e7:	4c 01 f8             	add    rax,r15
  4190ea:	ff d0                	call   rax
  4190ec:	e9 d5 e3 ff ff       	jmp    4174c6 <fmt_fp+0xac6>
		for (i=10, j++; j<9; i*=10, j++);
  4190f1:	48 b8 e8 22 fc ff ff 	movabs rax,0xfffffffffffc22e8
  4190f8:	ff ff ff 
  4190fb:	f3 41 0f 7e 04 07    	movq   xmm0,QWORD PTR [r15+rax*1]
  419101:	e9 d9 fe ff ff       	jmp    418fdf <fmt_fp+0x25df>
  419106:	dd d8                	fstp   st(0)
  419108:	dd d8                	fstp   st(0)
  41910a:	dd d8                	fstp   st(0)
		} while (y);
  41910c:	48 89 d0             	mov    rax,rdx
  41910f:	e9 e6 df ff ff       	jmp    4170fa <fmt_fp+0x6fa>
		for (i=10, j++; j<9; i*=10, j++);
  419114:	48 b8 f0 22 fc ff ff 	movabs rax,0xfffffffffffc22f0
  41911b:	ff ff ff 
  41911e:	f3 41 0f 7e 04 07    	movq   xmm0,QWORD PTR [r15+rax*1]
  419124:	e9 b6 fe ff ff       	jmp    418fdf <fmt_fp+0x25df>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419129:	41 8b 16             	mov    edx,DWORD PTR [r14]
  41912c:	83 e2 20             	and    edx,0x20
  41912f:	e9 19 e6 ff ff       	jmp    41774d <fmt_fp+0xd4d>
  419134:	41 8b 36             	mov    esi,DWORD PTR [r14]
  419137:	83 e6 20             	and    esi,0x20
  41913a:	e9 26 e5 ff ff       	jmp    417665 <fmt_fp+0xc65>
		for (i=10, j++; j<9; i*=10, j++);
  41913f:	41 ba 0a 00 00 00    	mov    r10d,0xa
  419145:	b9 0a 00 00 00       	mov    ecx,0xa
  41914a:	e9 d4 dc ff ff       	jmp    416e23 <fmt_fp+0x423>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41914f:	41 8b 16             	mov    edx,DWORD PTR [r14]
  419152:	83 e2 20             	and    edx,0x20
  419155:	e9 37 ed ff ff       	jmp    417e91 <fmt_fp+0x1491>
  41915a:	41 8b 06             	mov    eax,DWORD PTR [r14]
  41915d:	83 e0 20             	and    eax,0x20
  419160:	e9 76 ec ff ff       	jmp    417ddb <fmt_fp+0x13db>
  419165:	83 e0 20             	and    eax,0x20
  419168:	89 c2                	mov    edx,eax
  41916a:	e9 98 ea ff ff       	jmp    417c07 <fmt_fp+0x1207>
		for (i=10, j++; j<9; i*=10, j++);
  41916f:	b9 0a 00 00 00       	mov    ecx,0xa
  419174:	e9 85 fe ff ff       	jmp    418ffe <fmt_fp+0x25fe>
  419179:	48 b8 f8 22 fc ff ff 	movabs rax,0xfffffffffffc22f8
  419180:	ff ff ff 
  419183:	f3 41 0f 7e 04 07    	movq   xmm0,QWORD PTR [r15+rax*1]
  419189:	e9 51 fe ff ff       	jmp    418fdf <fmt_fp+0x25df>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41918e:	83 e0 20             	and    eax,0x20
  419191:	89 c6                	mov    esi,eax
  419193:	e9 80 e9 ff ff       	jmp    417b18 <fmt_fp+0x1118>
		for (i=10, j++; j<9; i*=10, j++);
  419198:	48 b8 00 23 fc ff ff 	movabs rax,0xfffffffffffc2300
  41919f:	ff ff ff 
  4191a2:	f3 41 0f 7e 04 07    	movq   xmm0,QWORD PTR [r15+rax*1]
  4191a8:	e9 32 fe ff ff       	jmp    418fdf <fmt_fp+0x25df>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4191ad:	41 8b 0e             	mov    ecx,DWORD PTR [r14]
  4191b0:	83 e1 20             	and    ecx,0x20
  4191b3:	e9 07 e2 ff ff       	jmp    4173bf <fmt_fp+0x9bf>
		for (i=10, j++; j<9; i*=10, j++);
  4191b8:	48 b8 10 23 fc ff ff 	movabs rax,0xfffffffffffc2310
  4191bf:	ff ff ff 
  4191c2:	f3 41 0f 7e 04 07    	movq   xmm0,QWORD PTR [r15+rax*1]
  4191c8:	e9 12 fe ff ff       	jmp    418fdf <fmt_fp+0x25df>
  4191cd:	48 b8 08 23 fc ff ff 	movabs rax,0xfffffffffffc2308
  4191d4:	ff ff ff 
  4191d7:	f3 41 0f 7e 04 07    	movq   xmm0,QWORD PTR [r15+rax*1]
  4191dd:	e9 fd fd ff ff       	jmp    418fdf <fmt_fp+0x25df>
			while (re--) round*=16;
  4191e2:	48 b8 84 22 fc ff ff 	movabs rax,0xfffffffffffc2284
  4191e9:	ff ff ff 
  4191ec:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  4191f0:	e9 b7 dd ff ff       	jmp    416fac <fmt_fp+0x5ac>
		if (x || d+1!=z) {
  4191f5:	48 83 c6 04          	add    rsi,0x4
  4191f9:	e9 15 f8 ff ff       	jmp    418a13 <fmt_fp+0x2013>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4191fe:	41 8b 06             	mov    eax,DWORD PTR [r14]
  419201:	83 e0 20             	and    eax,0x20
  419204:	e9 4a fc ff ff       	jmp    418e53 <fmt_fp+0x2453>
  419209:	41 8b 16             	mov    edx,DWORD PTR [r14]
  41920c:	83 e2 20             	and    edx,0x20
  41920f:	e9 aa e2 ff ff       	jmp    4174be <fmt_fp+0xabe>
  419214:	41 8b 0e             	mov    ecx,DWORD PTR [r14]
  419217:	83 e1 20             	and    ecx,0x20
  41921a:	e9 ec e0 ff ff       	jmp    41730b <fmt_fp+0x90b>
			while (re--) round*=16;
  41921f:	48 b8 90 22 fc ff ff 	movabs rax,0xfffffffffffc2290
  419226:	ff ff ff 
  419229:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  41922d:	e9 7a dd ff ff       	jmp    416fac <fmt_fp+0x5ac>
  419232:	48 b8 8c 22 fc ff ff 	movabs rax,0xfffffffffffc228c
  419239:	ff ff ff 
  41923c:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  419240:	e9 67 dd ff ff       	jmp    416fac <fmt_fp+0x5ac>
  419245:	48 b8 88 22 fc ff ff 	movabs rax,0xfffffffffffc2288
  41924c:	ff ff ff 
  41924f:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  419253:	e9 54 dd ff ff       	jmp    416fac <fmt_fp+0x5ac>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419258:	41 8b 36             	mov    esi,DWORD PTR [r14]
  41925b:	83 e6 20             	and    esi,0x20
  41925e:	e9 bb df ff ff       	jmp    41721e <fmt_fp+0x81e>
			while (re--) round*=16;
  419263:	48 b8 94 22 fc ff ff 	movabs rax,0xfffffffffffc2294
  41926a:	ff ff ff 
  41926d:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  419271:	e9 36 dd ff ff       	jmp    416fac <fmt_fp+0x5ac>
  419276:	48 b8 a0 22 fc ff ff 	movabs rax,0xfffffffffffc22a0
  41927d:	ff ff ff 
  419280:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  419284:	e9 23 dd ff ff       	jmp    416fac <fmt_fp+0x5ac>
  419289:	48 b8 9c 22 fc ff ff 	movabs rax,0xfffffffffffc229c
  419290:	ff ff ff 
  419293:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  419297:	e9 10 dd ff ff       	jmp    416fac <fmt_fp+0x5ac>
  41929c:	48 b8 a8 22 fc ff ff 	movabs rax,0xfffffffffffc22a8
  4192a3:	ff ff ff 
  4192a6:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  4192aa:	e9 fd dc ff ff       	jmp    416fac <fmt_fp+0x5ac>
  4192af:	48 b8 a4 22 fc ff ff 	movabs rax,0xfffffffffffc22a4
  4192b6:	ff ff ff 
  4192b9:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  4192bd:	e9 ea dc ff ff       	jmp    416fac <fmt_fp+0x5ac>
  4192c2:	48 b8 b8 22 fc ff ff 	movabs rax,0xfffffffffffc22b8
  4192c9:	ff ff ff 
  4192cc:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  4192d0:	e9 d7 dc ff ff       	jmp    416fac <fmt_fp+0x5ac>
  4192d5:	48 b8 b4 22 fc ff ff 	movabs rax,0xfffffffffffc22b4
  4192dc:	ff ff ff 
  4192df:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  4192e3:	e9 c4 dc ff ff       	jmp    416fac <fmt_fp+0x5ac>
  4192e8:	48 b8 b0 22 fc ff ff 	movabs rax,0xfffffffffffc22b0
  4192ef:	ff ff ff 
  4192f2:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  4192f6:	e9 b1 dc ff ff       	jmp    416fac <fmt_fp+0x5ac>
  4192fb:	48 b8 ac 22 fc ff ff 	movabs rax,0xfffffffffffc22ac
  419302:	ff ff ff 
  419305:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  419309:	e9 9e dc ff ff       	jmp    416fac <fmt_fp+0x5ac>
			if (z>a && z[-1]) for (i=10, j=0; z[-1]%i==0; i*=10, j++);
  41930e:	31 f6                	xor    esi,esi
  419310:	e9 1f f1 ff ff       	jmp    418434 <fmt_fp+0x1a34>
  419315:	49 89 ea             	mov    r10,rbp
  419318:	89 dd                	mov    ebp,ebx
  41931a:	e9 ff de ff ff       	jmp    41721e <fmt_fp+0x81e>
  41931f:	89 5c 24 08          	mov    DWORD PTR [rsp+0x8],ebx
  419323:	4d 89 e2             	mov    r10,r12
  419326:	e9 94 e0 ff ff       	jmp    4173bf <fmt_fp+0x9bf>

000000000041932b <printf_core.cold>:
  41932b:	45 8d 9f 00 ff ff ff 	lea    r11d,[r15-0x100]
  419332:	4c 8b 54 24 18       	mov    r10,QWORD PTR [rsp+0x18]
	for (; l >= sizeof pad; l -= sizeof pad)
  419337:	31 c9                	xor    ecx,ecx
  419339:	66 41 0f 6e ff       	movd   xmm7,r15d
  41933e:	44 89 da             	mov    edx,r11d
  419341:	66 0f 70 cf 00       	pshufd xmm1,xmm7,0x0
  419346:	48 be 40 23 fc ff ff 	movabs rsi,0xfffffffffffc2340
  41934d:	ff ff ff 
  419350:	c1 ea 08             	shr    edx,0x8
  419353:	66 42 0f 6f 1c 16    	movdqa xmm3,XMMWORD PTR [rsi+r10*1]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419359:	89 c6                	mov    esi,eax
  41935b:	44 8d 4a 01          	lea    r9d,[rdx+0x1]
  41935f:	48 ba 30 23 fc ff ff 	movabs rdx,0xfffffffffffc2330
  419366:	ff ff ff 
  419369:	66 42 0f fe 0c 12    	paddd  xmm1,XMMWORD PTR [rdx+r10*1]
  41936f:	44 89 cf             	mov    edi,r9d
  419372:	48 ba 50 23 fc ff ff 	movabs rdx,0xfffffffffffc2350
  419379:	ff ff ff 
	for (; l >= sizeof pad; l -= sizeof pad)
  41937c:	66 42 0f 6f 14 12    	movdqa xmm2,XMMWORD PTR [rdx+r10*1]
  419382:	c1 ef 02             	shr    edi,0x2
  419385:	66 0f 6f c1          	movdqa xmm0,xmm1
  419389:	83 c1 01             	add    ecx,0x1
  41938c:	66 0f fe cb          	paddd  xmm1,xmm3
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419390:	89 f0                	mov    eax,esi
	for (; l >= sizeof pad; l -= sizeof pad)
  419392:	66 0f fe c2          	paddd  xmm0,xmm2
  419396:	39 f9                	cmp    ecx,edi
  419398:	72 eb                	jb     419385 <printf_core.cold+0x5a>
  41939a:	44 89 ce             	mov    esi,r9d
  41939d:	66 0f 70 c0 ff       	pshufd xmm0,xmm0,0xff
  4193a2:	83 e6 fc             	and    esi,0xfffffffc
  4193a5:	66 0f 7e c1          	movd   ecx,xmm0
  4193a9:	69 d6 00 ff ff ff    	imul   edx,esi,0xffffff00
  4193af:	44 39 ce             	cmp    esi,r9d
  4193b2:	0f 84 77 0b 00 00    	je     419f2f <printf_core+0x77f>
  4193b8:	44 01 da             	add    edx,r11d
  4193bb:	89 d1                	mov    ecx,edx
  4193bd:	81 fa ff 00 00 00    	cmp    edx,0xff
  4193c3:	0f 86 66 0b 00 00    	jbe    419f2f <printf_core+0x77f>
  4193c9:	81 e9 00 01 00 00    	sub    ecx,0x100
  4193cf:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  4193d5:	0f 86 54 0b 00 00    	jbe    419f2f <printf_core+0x77f>
  4193db:	8d 8a 00 fe ff ff    	lea    ecx,[rdx-0x200]
  4193e1:	e9 49 0b 00 00       	jmp    419f2f <printf_core+0x77f>
  4193e6:	41 8d 94 24 00 e8 ff 	lea    edx,[r12-0x1800]
  4193ed:	ff 
  4193ee:	81 fa 00 e9 ff 7f    	cmp    edx,0x7fffe900
  4193f4:	0f 87 b5 00 00 00    	ja     4194af <printf_core.cold+0x184>
  4193fa:	45 8d 84 24 00 fe ff 	lea    r8d,[r12-0x200]
  419401:	ff 
  419402:	4c 8b 54 24 18       	mov    r10,QWORD PTR [rsp+0x18]
  419407:	66 41 0f 6e f4       	movd   xmm6,r12d
  41940c:	31 ed                	xor    ebp,ebp
  41940e:	44 89 c1             	mov    ecx,r8d
  419411:	66 0f 70 ce 00       	pshufd xmm1,xmm6,0x0
  419416:	48 ba 70 23 fc ff ff 	movabs rdx,0xfffffffffffc2370
  41941d:	ff ff ff 
  419420:	48 be 40 23 fc ff ff 	movabs rsi,0xfffffffffffc2340
  419427:	ff ff ff 
  41942a:	c1 e9 08             	shr    ecx,0x8
  41942d:	66 42 0f fe 0c 12    	paddd  xmm1,XMMWORD PTR [rdx+r10*1]
  419433:	66 42 0f 6f 1c 16    	movdqa xmm3,XMMWORD PTR [rsi+r10*1]
  419439:	48 ba 50 23 fc ff ff 	movabs rdx,0xfffffffffffc2350
  419440:	ff ff ff 
  419443:	83 c1 01             	add    ecx,0x1
  419446:	66 42 0f 6f 14 12    	movdqa xmm2,XMMWORD PTR [rdx+r10*1]
  41944c:	89 cf                	mov    edi,ecx
  41944e:	c1 ef 02             	shr    edi,0x2
  419451:	66 0f 6f c1          	movdqa xmm0,xmm1
  419455:	83 c5 01             	add    ebp,0x1
  419458:	66 0f fe cb          	paddd  xmm1,xmm3
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41945c:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  41945e:	66 0f fe c2          	paddd  xmm0,xmm2
  419462:	39 ef                	cmp    edi,ebp
  419464:	77 eb                	ja     419451 <printf_core.cold+0x126>
  419466:	89 ce                	mov    esi,ecx
  419468:	66 0f 70 c0 ff       	pshufd xmm0,xmm0,0xff
  41946d:	83 e6 fc             	and    esi,0xfffffffc
  419470:	66 0f 7e c5          	movd   ebp,xmm0
  419474:	69 c6 00 ff ff ff    	imul   eax,esi,0xffffff00
  41947a:	39 ce                	cmp    esi,ecx
  41947c:	0f 84 b2 16 00 00    	je     41ab34 <printf_core+0x1384>
  419482:	44 01 c0             	add    eax,r8d
  419485:	89 c5                	mov    ebp,eax
  419487:	3d ff 00 00 00       	cmp    eax,0xff
  41948c:	0f 86 a2 16 00 00    	jbe    41ab34 <printf_core+0x1384>
  419492:	81 ed 00 01 00 00    	sub    ebp,0x100
  419498:	81 fd ff 00 00 00    	cmp    ebp,0xff
  41949e:	0f 86 90 16 00 00    	jbe    41ab34 <printf_core+0x1384>
  4194a4:	8d a8 00 fe ff ff    	lea    ebp,[rax-0x200]
  4194aa:	e9 85 16 00 00       	jmp    41ab34 <printf_core+0x1384>
  4194af:	81 e9 00 01 00 00    	sub    ecx,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4194b5:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  4194b7:	89 cd                	mov    ebp,ecx
  4194b9:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  4194bf:	77 ee                	ja     4194af <printf_core.cold+0x184>
  4194c1:	e9 6e 16 00 00       	jmp    41ab34 <printf_core+0x1384>
  4194c6:	41 8d b8 00 ff ff ff 	lea    edi,[r8-0x100]
  4194cd:	4c 8b 54 24 18       	mov    r10,QWORD PTR [rsp+0x18]
  4194d2:	66 41 0f 6e e8       	movd   xmm5,r8d
  4194d7:	48 be 40 23 fc ff ff 	movabs rsi,0xfffffffffffc2340
  4194de:	ff ff ff 
  4194e1:	89 fa                	mov    edx,edi
  4194e3:	66 0f 70 cd 00       	pshufd xmm1,xmm5,0x0
  4194e8:	45 31 c0             	xor    r8d,r8d
  4194eb:	c1 ea 08             	shr    edx,0x8
  4194ee:	66 42 0f 6f 1c 16    	movdqa xmm3,XMMWORD PTR [rsi+r10*1]
  4194f4:	44 8d 7a 01          	lea    r15d,[rdx+0x1]
  4194f8:	48 ba 30 23 fc ff ff 	movabs rdx,0xfffffffffffc2330
  4194ff:	ff ff ff 
  419502:	66 42 0f fe 0c 12    	paddd  xmm1,XMMWORD PTR [rdx+r10*1]
  419508:	44 89 f9             	mov    ecx,r15d
  41950b:	48 ba 50 23 fc ff ff 	movabs rdx,0xfffffffffffc2350
  419512:	ff ff ff 
  419515:	66 42 0f 6f 14 12    	movdqa xmm2,XMMWORD PTR [rdx+r10*1]
  41951b:	c1 e9 02             	shr    ecx,0x2
  41951e:	66 0f 6f c1          	movdqa xmm0,xmm1
  419522:	41 83 c0 01          	add    r8d,0x1
  419526:	66 0f fe cb          	paddd  xmm1,xmm3
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41952a:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  41952c:	66 0f fe c2          	paddd  xmm0,xmm2
  419530:	44 39 c1             	cmp    ecx,r8d
  419533:	77 e9                	ja     41951e <printf_core.cold+0x1f3>
  419535:	44 89 fe             	mov    esi,r15d
  419538:	66 0f 70 c0 ff       	pshufd xmm0,xmm0,0xff
  41953d:	83 e6 fc             	and    esi,0xfffffffc
  419540:	66 0f 7e c1          	movd   ecx,xmm0
  419544:	69 c6 00 ff ff ff    	imul   eax,esi,0xffffff00
  41954a:	44 39 fe             	cmp    esi,r15d
  41954d:	0f 84 45 11 00 00    	je     41a698 <printf_core+0xee8>
  419553:	01 f8                	add    eax,edi
  419555:	89 c1                	mov    ecx,eax
  419557:	3d ff 00 00 00       	cmp    eax,0xff
  41955c:	0f 86 36 11 00 00    	jbe    41a698 <printf_core+0xee8>
  419562:	81 e9 00 01 00 00    	sub    ecx,0x100
  419568:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  41956e:	0f 86 24 11 00 00    	jbe    41a698 <printf_core+0xee8>
  419574:	8d 88 00 fe ff ff    	lea    ecx,[rax-0x200]
  41957a:	e9 19 11 00 00       	jmp    41a698 <printf_core+0xee8>
  41957f:	45 8d 9f 00 ff ff ff 	lea    r11d,[r15-0x100]
  419586:	48 8b 7c 24 18       	mov    rdi,QWORD PTR [rsp+0x18]
  41958b:	45 31 c9             	xor    r9d,r9d
  41958e:	66 41 0f 6e f7       	movd   xmm6,r15d
  419593:	44 89 da             	mov    edx,r11d
  419596:	66 0f 70 ce 00       	pshufd xmm1,xmm6,0x0
  41959b:	48 be 40 23 fc ff ff 	movabs rsi,0xfffffffffffc2340
  4195a2:	ff ff ff 
  4195a5:	c1 ea 08             	shr    edx,0x8
  4195a8:	66 0f 6f 1c 3e       	movdqa xmm3,XMMWORD PTR [rsi+rdi*1]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4195ad:	89 c6                	mov    esi,eax
  4195af:	8d 4a 01             	lea    ecx,[rdx+0x1]
  4195b2:	48 ba 30 23 fc ff ff 	movabs rdx,0xfffffffffffc2330
  4195b9:	ff ff ff 
  4195bc:	66 0f fe 0c 3a       	paddd  xmm1,XMMWORD PTR [rdx+rdi*1]
  4195c1:	89 cd                	mov    ebp,ecx
  4195c3:	48 ba 50 23 fc ff ff 	movabs rdx,0xfffffffffffc2350
  4195ca:	ff ff ff 
	for (; l >= sizeof pad; l -= sizeof pad)
  4195cd:	66 0f 6f 14 3a       	movdqa xmm2,XMMWORD PTR [rdx+rdi*1]
  4195d2:	c1 ed 02             	shr    ebp,0x2
  4195d5:	66 0f 6f c1          	movdqa xmm0,xmm1
  4195d9:	41 83 c1 01          	add    r9d,0x1
  4195dd:	66 0f fe cb          	paddd  xmm1,xmm3
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4195e1:	89 f0                	mov    eax,esi
	for (; l >= sizeof pad; l -= sizeof pad)
  4195e3:	66 0f fe c2          	paddd  xmm0,xmm2
  4195e7:	41 39 e9             	cmp    r9d,ebp
  4195ea:	72 e9                	jb     4195d5 <printf_core.cold+0x2aa>
  4195ec:	89 ce                	mov    esi,ecx
  4195ee:	66 0f 70 c0 ff       	pshufd xmm0,xmm0,0xff
  4195f3:	83 e6 fc             	and    esi,0xfffffffc
  4195f6:	66 0f 7e c5          	movd   ebp,xmm0
  4195fa:	69 d6 00 ff ff ff    	imul   edx,esi,0xffffff00
  419600:	39 ce                	cmp    esi,ecx
  419602:	0f 84 e8 0a 00 00    	je     41a0f0 <printf_core+0x940>
  419608:	44 01 da             	add    edx,r11d
  41960b:	89 d5                	mov    ebp,edx
  41960d:	81 fa ff 00 00 00    	cmp    edx,0xff
  419613:	0f 86 d7 0a 00 00    	jbe    41a0f0 <printf_core+0x940>
  419619:	81 ed 00 01 00 00    	sub    ebp,0x100
  41961f:	81 fd ff 00 00 00    	cmp    ebp,0xff
  419625:	0f 86 c5 0a 00 00    	jbe    41a0f0 <printf_core+0x940>
  41962b:	8d aa 00 fe ff ff    	lea    ebp,[rdx-0x200]
  419631:	e9 ba 0a 00 00       	jmp    41a0f0 <printf_core+0x940>
  419636:	44 8d 85 00 ff ff ff 	lea    r8d,[rbp-0x100]
  41963d:	48 8b 7c 24 18       	mov    rdi,QWORD PTR [rsp+0x18]
  419642:	66 0f 6e fd          	movd   xmm7,ebp
  419646:	45 31 db             	xor    r11d,r11d
  419649:	44 89 c1             	mov    ecx,r8d
  41964c:	66 0f 70 c7 00       	pshufd xmm0,xmm7,0x0
  419651:	48 ba 30 23 fc ff ff 	movabs rdx,0xfffffffffffc2330
  419658:	ff ff ff 
  41965b:	48 be 40 23 fc ff ff 	movabs rsi,0xfffffffffffc2340
  419662:	ff ff ff 
  419665:	c1 e9 08             	shr    ecx,0x8
  419668:	66 0f fe 04 3a       	paddd  xmm0,XMMWORD PTR [rdx+rdi*1]
  41966d:	66 0f 6f 1c 3e       	movdqa xmm3,XMMWORD PTR [rsi+rdi*1]
  419672:	48 ba 50 23 fc ff ff 	movabs rdx,0xfffffffffffc2350
  419679:	ff ff ff 
  41967c:	83 c1 01             	add    ecx,0x1
  41967f:	66 0f 6f 14 3a       	movdqa xmm2,XMMWORD PTR [rdx+rdi*1]
  419684:	41 89 c9             	mov    r9d,ecx
  419687:	41 c1 e9 02          	shr    r9d,0x2
  41968b:	66 0f 6f c8          	movdqa xmm1,xmm0
  41968f:	41 83 c3 01          	add    r11d,0x1
  419693:	66 0f fe c3          	paddd  xmm0,xmm3
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419697:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  419699:	66 0f fe ca          	paddd  xmm1,xmm2
  41969d:	45 39 cb             	cmp    r11d,r9d
  4196a0:	72 e9                	jb     41968b <printf_core.cold+0x360>
  4196a2:	89 ce                	mov    esi,ecx
  4196a4:	66 0f 70 c1 ff       	pshufd xmm0,xmm1,0xff
  4196a9:	83 e6 fc             	and    esi,0xfffffffc
  4196ac:	66 41 0f 7e c4       	movd   r12d,xmm0
  4196b1:	69 c6 00 ff ff ff    	imul   eax,esi,0xffffff00
  4196b7:	39 f1                	cmp    ecx,esi
  4196b9:	0f 84 eb 0a 00 00    	je     41a1aa <printf_core+0x9fa>
  4196bf:	44 01 c0             	add    eax,r8d
  4196c2:	41 89 c4             	mov    r12d,eax
  4196c5:	3d ff 00 00 00       	cmp    eax,0xff
  4196ca:	0f 86 da 0a 00 00    	jbe    41a1aa <printf_core+0x9fa>
  4196d0:	41 81 ec 00 01 00 00 	sub    r12d,0x100
  4196d7:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  4196de:	0f 86 c6 0a 00 00    	jbe    41a1aa <printf_core+0x9fa>
  4196e4:	44 8d a0 00 fe ff ff 	lea    r12d,[rax-0x200]
  4196eb:	e9 ba 0a 00 00       	jmp    41a1aa <printf_core+0x9fa>
  4196f0:	45 8d 9f 00 ff ff ff 	lea    r11d,[r15-0x100]
  4196f7:	4c 8b 54 24 18       	mov    r10,QWORD PTR [rsp+0x18]
  4196fc:	31 c9                	xor    ecx,ecx
  4196fe:	66 41 0f 6e ef       	movd   xmm5,r15d
  419703:	44 89 da             	mov    edx,r11d
  419706:	66 0f 70 cd 00       	pshufd xmm1,xmm5,0x0
  41970b:	48 be 40 23 fc ff ff 	movabs rsi,0xfffffffffffc2340
  419712:	ff ff ff 
  419715:	c1 ea 08             	shr    edx,0x8
  419718:	66 42 0f 6f 1c 16    	movdqa xmm3,XMMWORD PTR [rsi+r10*1]
  41971e:	44 8d 4a 01          	lea    r9d,[rdx+0x1]
  419722:	48 ba 30 23 fc ff ff 	movabs rdx,0xfffffffffffc2330
  419729:	ff ff ff 
  41972c:	66 42 0f fe 0c 12    	paddd  xmm1,XMMWORD PTR [rdx+r10*1]
  419732:	44 89 cf             	mov    edi,r9d
  419735:	48 ba 50 23 fc ff ff 	movabs rdx,0xfffffffffffc2350
  41973c:	ff ff ff 
  41973f:	66 42 0f 6f 14 12    	movdqa xmm2,XMMWORD PTR [rdx+r10*1]
  419745:	c1 ef 02             	shr    edi,0x2
  419748:	66 0f 6f c1          	movdqa xmm0,xmm1
  41974c:	83 c1 01             	add    ecx,0x1
  41974f:	66 0f fe cb          	paddd  xmm1,xmm3
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419753:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  419755:	66 0f fe c2          	paddd  xmm0,xmm2
  419759:	39 f9                	cmp    ecx,edi
  41975b:	72 eb                	jb     419748 <printf_core.cold+0x41d>
  41975d:	44 89 ce             	mov    esi,r9d
  419760:	66 0f 70 c0 ff       	pshufd xmm0,xmm0,0xff
  419765:	83 e6 fc             	and    esi,0xfffffffc
  419768:	66 0f 7e c1          	movd   ecx,xmm0
  41976c:	69 c6 00 ff ff ff    	imul   eax,esi,0xffffff00
  419772:	44 39 ce             	cmp    esi,r9d
  419775:	0f 84 a3 08 00 00    	je     41a01e <printf_core+0x86e>
  41977b:	44 01 d8             	add    eax,r11d
  41977e:	89 c1                	mov    ecx,eax
  419780:	3d ff 00 00 00       	cmp    eax,0xff
  419785:	0f 86 93 08 00 00    	jbe    41a01e <printf_core+0x86e>
  41978b:	81 e9 00 01 00 00    	sub    ecx,0x100
  419791:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  419797:	0f 86 81 08 00 00    	jbe    41a01e <printf_core+0x86e>
  41979d:	8d 88 00 fe ff ff    	lea    ecx,[rax-0x200]
  4197a3:	e9 76 08 00 00       	jmp    41a01e <printf_core+0x86e>
  4197a8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4197af:	00 

00000000004197b0 <printf_core>:
	}
	return i;
}

static int printf_core(FILE *f, const char *fmt, va_list *ap, union arg *nl_arg, int *nl_type)
{
  4197b0:	f3 0f 1e fa          	endbr64 
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4197b4:	48 b8 60 e3 fb ff ff 	movabs rax,0xfffffffffffbe360
  4197bb:	ff ff ff 
{
  4197be:	41 57                	push   r15
  4197c0:	49 bb 5c 3c 04 00 00 	movabs r11,0x43c5c
  4197c7:	00 00 00 
  4197ca:	41 56                	push   r14
  4197cc:	41 55                	push   r13
  4197ce:	49 89 fd             	mov    r13,rdi
  4197d1:	41 54                	push   r12
  4197d3:	55                   	push   rbp
  4197d4:	53                   	push   rbx
  4197d5:	48 8d 1d d8 ff ff ff 	lea    rbx,[rip+0xffffffffffffffd8]        # 4197b4 <printf_core+0x4>
  4197dc:	4c 01 db             	add    rbx,r11
  4197df:	48 81 ec d8 01 00 00 	sub    rsp,0x1d8
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4197e6:	48 89 44 24 20       	mov    QWORD PTR [rsp+0x20],rax
		/* Format specifier state machine */
		st=0;
		do {
			if (OOB(*s)) goto inval;
			ps=st;
			st=states[st]S(*s++);
  4197eb:	48 b8 b0 20 fc ff ff 	movabs rax,0xfffffffffffc20b0
  4197f2:	ff ff ff 
  4197f5:	48 01 d8             	add    rax,rbx
  4197f8:	48 89 5c 24 18       	mov    QWORD PTR [rsp+0x18],rbx
{
  4197fd:	48 89 54 24 30       	mov    QWORD PTR [rsp+0x30],rdx
  419802:	48 89 4c 24 48       	mov    QWORD PTR [rsp+0x48],rcx
	int cnt=0, l=0;
  419807:	c7 44 24 08 00 00 00 	mov    DWORD PTR [rsp+0x8],0x0
  41980e:	00 
  41980f:	c7 44 24 14 00 00 00 	mov    DWORD PTR [rsp+0x14],0x0
  419816:	00 
	unsigned l10n=0, fl;
  419817:	c7 44 24 58 00 00 00 	mov    DWORD PTR [rsp+0x58],0x0
  41981e:	00 
			st=states[st]S(*s++);
  41981f:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
{
  419824:	4c 89 44 24 40       	mov    QWORD PTR [rsp+0x40],r8
  419829:	49 89 f0             	mov    r8,rsi
		if (!*s) break;
  41982c:	41 0f b6 00          	movzx  eax,BYTE PTR [r8]
		cnt += l;
  419830:	8b 54 24 08          	mov    edx,DWORD PTR [rsp+0x8]
  419834:	01 54 24 14          	add    DWORD PTR [rsp+0x14],edx
		if (!*s) break;
  419838:	84 c0                	test   al,al
  41983a:	0f 84 50 05 00 00    	je     419d90 <printf_core+0x5e0>
		for (a=s; *s && *s!='%'; s++);
  419840:	4d 89 c6             	mov    r14,r8
  419843:	eb 10                	jmp    419855 <printf_core+0xa5>
  419845:	0f 1f 00             	nop    DWORD PTR [rax]
  419848:	41 0f b6 46 01       	movzx  eax,BYTE PTR [r14+0x1]
  41984d:	49 83 c6 01          	add    r14,0x1
  419851:	84 c0                	test   al,al
  419853:	74 6b                	je     4198c0 <printf_core+0x110>
  419855:	3c 25                	cmp    al,0x25
  419857:	75 ef                	jne    419848 <printf_core+0x98>
  419859:	4c 89 f3             	mov    rbx,r14
  41985c:	eb 0f                	jmp    41986d <printf_core+0xbd>
  41985e:	66 90                	xchg   ax,ax
		for (z=s; s[0]=='%' && s[1]=='%'; z++, s+=2);
  419860:	48 83 c3 02          	add    rbx,0x2
  419864:	49 83 c6 01          	add    r14,0x1
  419868:	80 3b 25             	cmp    BYTE PTR [rbx],0x25
  41986b:	75 06                	jne    419873 <printf_core+0xc3>
  41986d:	80 7b 01 25          	cmp    BYTE PTR [rbx+0x1],0x25
  419871:	74 ed                	je     419860 <printf_core+0xb0>
		if (z-a > INT_MAX-cnt) goto overflow;
  419873:	41 bb ff ff ff 7f    	mov    r11d,0x7fffffff
  419879:	44 2b 5c 24 14       	sub    r11d,DWORD PTR [rsp+0x14]
  41987e:	4d 29 c6             	sub    r14,r8
  419881:	49 63 c3             	movsxd rax,r11d
  419884:	49 39 c6             	cmp    r14,rax
  419887:	0f 8f 5c 03 00 00    	jg     419be9 <printf_core+0x439>
		l = z-a;
  41988d:	44 89 74 24 08       	mov    DWORD PTR [rsp+0x8],r14d
		if (f) out(f, a, l);
  419892:	4d 85 ed             	test   r13,r13
  419895:	74 0b                	je     4198a2 <printf_core+0xf2>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419897:	41 f6 45 00 20       	test   BYTE PTR [r13+0x0],0x20
  41989c:	0f 84 6e 01 00 00    	je     419a10 <printf_core+0x260>
		if (l) continue;
  4198a2:	45 85 f6             	test   r14d,r14d
  4198a5:	74 29                	je     4198d0 <printf_core+0x120>
		if (l > INT_MAX - cnt) goto overflow;
  4198a7:	44 3b 5c 24 08       	cmp    r11d,DWORD PTR [rsp+0x8]
  4198ac:	0f 8c 37 03 00 00    	jl     419be9 <printf_core+0x439>
{
  4198b2:	49 89 d8             	mov    r8,rbx
  4198b5:	e9 72 ff ff ff       	jmp    41982c <printf_core+0x7c>
  4198ba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
		for (a=s; *s && *s!='%'; s++);
  4198c0:	4c 89 f3             	mov    rbx,r14
		for (z=s; s[0]=='%' && s[1]=='%'; z++, s+=2);
  4198c3:	3c 25                	cmp    al,0x25
  4198c5:	74 92                	je     419859 <printf_core+0xa9>
  4198c7:	eb aa                	jmp    419873 <printf_core+0xc3>
  4198c9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		if (isdigit(s[1]) && s[2]=='$') {
  4198d0:	0f be 4b 01          	movsx  ecx,BYTE PTR [rbx+0x1]
  4198d4:	8d 51 d0             	lea    edx,[rcx-0x30]
  4198d7:	89 cf                	mov    edi,ecx
  4198d9:	83 fa 09             	cmp    edx,0x9
  4198dc:	77 0a                	ja     4198e8 <printf_core+0x138>
  4198de:	80 7b 02 24          	cmp    BYTE PTR [rbx+0x2],0x24
  4198e2:	0f 84 69 03 00 00    	je     419c51 <printf_core+0x4a1>
			s++;
  4198e8:	48 83 c3 01          	add    rbx,0x1
			argpos = -1;
  4198ec:	ba ff ff ff ff       	mov    edx,0xffffffff
		for (fl=0; (unsigned)*s-' '<32 && (FLAGMASK&(1U<<*s-' ')); s++)
  4198f1:	44 8d 49 e0          	lea    r9d,[rcx-0x20]
  4198f5:	45 31 e4             	xor    r12d,r12d
  4198f8:	b8 89 28 01 00       	mov    eax,0x12889
			fl |= 1U<<*s-' ';
  4198fd:	be 01 00 00 00       	mov    esi,0x1
		for (fl=0; (unsigned)*s-' '<32 && (FLAGMASK&(1U<<*s-' ')); s++)
  419902:	41 83 f9 1f          	cmp    r9d,0x1f
  419906:	76 22                	jbe    41992a <printf_core+0x17a>
  419908:	eb 28                	jmp    419932 <printf_core+0x182>
  41990a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
			fl |= 1U<<*s-' ';
  419910:	89 f7                	mov    edi,esi
		for (fl=0; (unsigned)*s-' '<32 && (FLAGMASK&(1U<<*s-' ')); s++)
  419912:	48 83 c3 01          	add    rbx,0x1
			fl |= 1U<<*s-' ';
  419916:	d3 e7                	shl    edi,cl
		for (fl=0; (unsigned)*s-' '<32 && (FLAGMASK&(1U<<*s-' ')); s++)
  419918:	0f be 0b             	movsx  ecx,BYTE PTR [rbx]
			fl |= 1U<<*s-' ';
  41991b:	41 09 fc             	or     r12d,edi
		for (fl=0; (unsigned)*s-' '<32 && (FLAGMASK&(1U<<*s-' ')); s++)
  41991e:	44 8d 49 e0          	lea    r9d,[rcx-0x20]
  419922:	89 cf                	mov    edi,ecx
  419924:	41 83 f9 1f          	cmp    r9d,0x1f
  419928:	77 08                	ja     419932 <printf_core+0x182>
  41992a:	83 e9 20             	sub    ecx,0x20
  41992d:	0f a3 c8             	bt     eax,ecx
  419930:	72 de                	jb     419910 <printf_core+0x160>
		if (*s=='*') {
  419932:	40 80 ff 2a          	cmp    dil,0x2a
  419936:	0f 85 94 01 00 00    	jne    419ad0 <printf_core+0x320>
			if (isdigit(s[1]) && s[2]=='$') {
  41993c:	48 0f be 43 01       	movsx  rax,BYTE PTR [rbx+0x1]
  419941:	48 89 c6             	mov    rsi,rax
  419944:	83 e8 30             	sub    eax,0x30
  419947:	83 f8 09             	cmp    eax,0x9
  41994a:	0f 86 c0 02 00 00    	jbe    419c10 <printf_core+0x460>
			} else if (!l10n) {
  419950:	8b 44 24 58          	mov    eax,DWORD PTR [rsp+0x58]
  419954:	85 c0                	test   eax,eax
  419956:	0f 85 32 01 00 00    	jne    419a8e <printf_core+0x2de>
				s++;
  41995c:	48 83 c3 01          	add    rbx,0x1
				w = f ? va_arg(*ap, int) : 0;
  419960:	45 89 f1             	mov    r9d,r14d
  419963:	4d 85 ed             	test   r13,r13
  419966:	74 30                	je     419998 <printf_core+0x1e8>
  419968:	48 8b 7c 24 30       	mov    rdi,QWORD PTR [rsp+0x30]
  41996d:	8b 07                	mov    eax,DWORD PTR [rdi]
  41996f:	83 f8 2f             	cmp    eax,0x2f
  419972:	0f 87 08 03 00 00    	ja     419c80 <printf_core+0x4d0>
  419978:	89 c1                	mov    ecx,eax
  41997a:	83 c0 08             	add    eax,0x8
  41997d:	48 03 4f 10          	add    rcx,QWORD PTR [rdi+0x10]
  419981:	89 07                	mov    DWORD PTR [rdi],eax
  419983:	44 8b 09             	mov    r9d,DWORD PTR [rcx]
		if (*s=='.' && s[1]=='*') {
  419986:	0f b6 33             	movzx  esi,BYTE PTR [rbx]
			if (w<0) fl|=LEFT_ADJ, w=-w;
  419989:	45 85 c9             	test   r9d,r9d
  41998c:	79 0a                	jns    419998 <printf_core+0x1e8>
  41998e:	41 81 cc 00 20 00 00 	or     r12d,0x2000
  419995:	41 f7 d9             	neg    r9d
		if (*s=='.' && s[1]=='*') {
  419998:	40 80 fe 2e          	cmp    sil,0x2e
  41999c:	0f 85 a6 00 00 00    	jne    419a48 <printf_core+0x298>
  4199a2:	0f be 43 01          	movsx  eax,BYTE PTR [rbx+0x1]
  4199a6:	3c 2a                	cmp    al,0x2a
  4199a8:	0f 85 ea 02 00 00    	jne    419c98 <printf_core+0x4e8>
			if (isdigit(s[2]) && s[3]=='$') {
  4199ae:	48 0f be 43 02       	movsx  rax,BYTE PTR [rbx+0x2]
  4199b3:	48 89 c1             	mov    rcx,rax
  4199b6:	83 e8 30             	sub    eax,0x30
  4199b9:	83 f8 09             	cmp    eax,0x9
  4199bc:	77 0a                	ja     4199c8 <printf_core+0x218>
  4199be:	80 7b 03 24          	cmp    BYTE PTR [rbx+0x3],0x24
  4199c2:	0f 84 81 03 00 00    	je     419d49 <printf_core+0x599>
			} else if (!l10n) {
  4199c8:	8b 44 24 58          	mov    eax,DWORD PTR [rsp+0x58]
  4199cc:	85 c0                	test   eax,eax
  4199ce:	0f 85 ba 00 00 00    	jne    419a8e <printf_core+0x2de>
				p = f ? va_arg(*ap, int) : 0;
  4199d4:	4d 85 ed             	test   r13,r13
  4199d7:	0f 84 a5 03 00 00    	je     419d82 <printf_core+0x5d2>
  4199dd:	48 8b 7c 24 30       	mov    rdi,QWORD PTR [rsp+0x30]
  4199e2:	8b 07                	mov    eax,DWORD PTR [rdi]
  4199e4:	83 f8 2f             	cmp    eax,0x2f
  4199e7:	0f 87 12 03 00 00    	ja     419cff <printf_core+0x54f>
  4199ed:	89 c1                	mov    ecx,eax
  4199ef:	83 c0 08             	add    eax,0x8
  4199f2:	48 03 4f 10          	add    rcx,QWORD PTR [rdi+0x10]
  4199f6:	89 07                	mov    DWORD PTR [rdi],eax
  4199f8:	8b 29                	mov    ebp,DWORD PTR [rcx]
			xp = (p>=0);
  4199fa:	89 e8                	mov    eax,ebp
  4199fc:	f7 d0                	not    eax
  4199fe:	c1 e8 1f             	shr    eax,0x1f
  419a01:	41 89 c2             	mov    r10d,eax
				s+=2;
  419a04:	48 83 c3 02          	add    rbx,0x2
			xp = (p>=0);
  419a08:	eb 46                	jmp    419a50 <printf_core+0x2a0>
  419a0a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419a10:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  419a15:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  419a1a:	4c 89 c7             	mov    rdi,r8
		if (f) out(f, a, l);
  419a1d:	49 63 f6             	movsxd rsi,r14d
  419a20:	44 89 5c 24 50       	mov    DWORD PTR [rsp+0x50],r11d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419a25:	4c 89 ea             	mov    rdx,r13
  419a28:	4c 89 44 24 38       	mov    QWORD PTR [rsp+0x38],r8
  419a2d:	48 01 c8             	add    rax,rcx
  419a30:	ff d0                	call   rax
  419a32:	44 8b 5c 24 50       	mov    r11d,DWORD PTR [rsp+0x50]
  419a37:	4c 8b 44 24 38       	mov    r8,QWORD PTR [rsp+0x38]
  419a3c:	e9 61 fe ff ff       	jmp    4198a2 <printf_core+0xf2>
  419a41:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
			xp = 0;
  419a48:	45 89 f2             	mov    r10d,r14d
			p = -1;
  419a4b:	bd ff ff ff ff       	mov    ebp,0xffffffff
		st=0;
  419a50:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  419a55:	45 31 ff             	xor    r15d,r15d
  419a58:	eb 29                	jmp    419a83 <printf_core+0x2d3>
  419a5a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
			st=states[st]S(*s++);
  419a60:	44 89 ff             	mov    edi,r15d
  419a63:	48 98                	cdqe   
  419a65:	48 83 c3 01          	add    rbx,0x1
  419a69:	48 6b f7 3a          	imul   rsi,rdi,0x3a
  419a6d:	48 01 c6             	add    rsi,rax
  419a70:	0f b6 34 0e          	movzx  esi,BYTE PTR [rsi+rcx*1]
		} while (st-1<STOP);
  419a74:	8d 46 ff             	lea    eax,[rsi-0x1]
  419a77:	83 f8 07             	cmp    eax,0x7
  419a7a:	0f 87 c8 00 00 00    	ja     419b48 <printf_core+0x398>
  419a80:	41 89 f7             	mov    r15d,esi
			if (OOB(*s)) goto inval;
  419a83:	0f be 03             	movsx  eax,BYTE PTR [rbx]
  419a86:	83 e8 41             	sub    eax,0x41
  419a89:	83 f8 39             	cmp    eax,0x39
  419a8c:	76 d2                	jbe    419a60 <printf_core+0x2b0>
	for (; i<=NL_ARGMAX && !nl_type[i]; i++);
	if (i<=NL_ARGMAX) goto inval;
	return 1;

inval:
	errno = EINVAL;
  419a8e:	48 b8 f0 8c fb ff ff 	movabs rax,0xfffffffffffb8cf0
  419a95:	ff ff ff 
  419a98:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  419a9d:	48 01 d0             	add    rax,rdx
  419aa0:	ff d0                	call   rax
	return -1;
  419aa2:	c7 44 24 14 ff ff ff 	mov    DWORD PTR [rsp+0x14],0xffffffff
  419aa9:	ff 
	errno = EINVAL;
  419aaa:	c7 00 16 00 00 00    	mov    DWORD PTR [rax],0x16
overflow:
	errno = EOVERFLOW;
	return -1;
}
  419ab0:	8b 44 24 14          	mov    eax,DWORD PTR [rsp+0x14]
  419ab4:	48 81 c4 d8 01 00 00 	add    rsp,0x1d8
  419abb:	5b                   	pop    rbx
  419abc:	5d                   	pop    rbp
  419abd:	41 5c                	pop    r12
  419abf:	41 5d                	pop    r13
  419ac1:	41 5e                	pop    r14
  419ac3:	41 5f                	pop    r15
  419ac5:	c3                   	ret    
  419ac6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  419acd:	00 00 00 
	for (i=0; isdigit(**s); (*s)++) {
  419ad0:	0f be 03             	movsx  eax,BYTE PTR [rbx]
  419ad3:	45 89 f1             	mov    r9d,r14d
  419ad6:	89 c1                	mov    ecx,eax
  419ad8:	83 e8 30             	sub    eax,0x30
  419adb:	89 ce                	mov    esi,ecx
  419add:	83 f8 09             	cmp    eax,0x9
  419ae0:	76 3a                	jbe    419b1c <printf_core+0x36c>
  419ae2:	e9 b1 fe ff ff       	jmp    419998 <printf_core+0x1e8>
  419ae7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  419aee:	00 00 
		if (i > INT_MAX/10U || **s-'0' > INT_MAX-10*i) i = -1;
  419af0:	41 6b f9 f6          	imul   edi,r9d,0xfffffff6
  419af4:	83 e9 30             	sub    ecx,0x30
  419af7:	44 8d 8f ff ff ff 7f 	lea    r9d,[rdi+0x7fffffff]
  419afe:	44 39 c9             	cmp    ecx,r9d
  419b01:	7f 2f                	jg     419b32 <printf_core+0x382>
		else i = 10*i + (**s-'0');
  419b03:	29 f9                	sub    ecx,edi
  419b05:	41 89 c9             	mov    r9d,ecx
	for (i=0; isdigit(**s); (*s)++) {
  419b08:	83 f8 09             	cmp    eax,0x9
  419b0b:	0f 87 cf 00 00 00    	ja     419be0 <printf_core+0x430>
  419b11:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  419b18:	40 0f be ce          	movsx  ecx,sil
  419b1c:	0f be 43 01          	movsx  eax,BYTE PTR [rbx+0x1]
  419b20:	48 83 c3 01          	add    rbx,0x1
  419b24:	89 c6                	mov    esi,eax
  419b26:	83 e8 30             	sub    eax,0x30
		if (i > INT_MAX/10U || **s-'0' > INT_MAX-10*i) i = -1;
  419b29:	41 81 f9 cc cc cc 0c 	cmp    r9d,0xccccccc
  419b30:	76 be                	jbe    419af0 <printf_core+0x340>
	for (i=0; isdigit(**s); (*s)++) {
  419b32:	83 f8 09             	cmp    eax,0x9
  419b35:	0f 87 ae 00 00 00    	ja     419be9 <printf_core+0x439>
  419b3b:	41 b9 ff ff ff ff    	mov    r9d,0xffffffff
  419b41:	eb d5                	jmp    419b18 <printf_core+0x368>
  419b43:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		if (!st) goto inval;
  419b48:	48 89 f8             	mov    rax,rdi
  419b4b:	85 f6                	test   esi,esi
  419b4d:	0f 84 3b ff ff ff    	je     419a8e <printf_core+0x2de>
		if (st==NOARG) {
  419b53:	83 fe 1b             	cmp    esi,0x1b
  419b56:	0f 84 0c 01 00 00    	je     419c68 <printf_core+0x4b8>
			if (argpos>=0) nl_type[argpos]=st, arg=nl_arg[argpos];
  419b5c:	83 fa ff             	cmp    edx,0xffffffff
  419b5f:	0f 84 ab 01 00 00    	je     419d10 <printf_core+0x560>
  419b65:	48 8b 7c 24 40       	mov    rdi,QWORD PTR [rsp+0x40]
  419b6a:	48 63 d2             	movsxd rdx,edx
  419b6d:	89 34 97             	mov    DWORD PTR [rdi+rdx*4],esi
  419b70:	48 8b 7c 24 48       	mov    rdi,QWORD PTR [rsp+0x48]
  419b75:	48 c1 e2 04          	shl    rdx,0x4
  419b79:	66 0f 6f 24 17       	movdqa xmm4,XMMWORD PTR [rdi+rdx*1]
  419b7e:	0f 29 a4 24 90 00 00 	movaps XMMWORD PTR [rsp+0x90],xmm4
  419b85:	00 
		if (!f) continue;
  419b86:	4d 85 ed             	test   r13,r13
  419b89:	0f 84 23 fd ff ff    	je     4198b2 <printf_core+0x102>
		t = s[-1];
  419b8f:	0f be 53 ff          	movsx  edx,BYTE PTR [rbx-0x1]
  419b93:	89 d1                	mov    ecx,edx
		if (ps && (t&15)==3) t&=~32;
  419b95:	45 85 ff             	test   r15d,r15d
  419b98:	74 12                	je     419bac <printf_core+0x3fc>
  419b9a:	89 d6                	mov    esi,edx
  419b9c:	83 e1 df             	and    ecx,0xffffffdf
  419b9f:	83 e6 0f             	and    esi,0xf
  419ba2:	0f be c9             	movsx  ecx,cl
  419ba5:	40 80 fe 03          	cmp    sil,0x3
  419ba9:	0f 44 d1             	cmove  edx,ecx
		if (fl & LEFT_ADJ) fl &= ~ZERO_PAD;
  419bac:	44 89 e1             	mov    ecx,r12d
  419baf:	81 e1 ff ff fe ff    	and    ecx,0xfffeffff
  419bb5:	41 f7 c4 00 20 00 00 	test   r12d,0x2000
  419bbc:	44 0f 45 e1          	cmovne r12d,ecx
		switch(t) {
  419bc0:	8d 4a bf             	lea    ecx,[rdx-0x41]
  419bc3:	83 f9 37             	cmp    ecx,0x37
  419bc6:	0f 87 34 02 00 00    	ja     419e00 <printf_core+0x650>
  419bcc:	48 8d 35 c5 56 00 00 	lea    rsi,[rip+0x56c5]        # 41f298 <CSWTCH.186+0x828>
  419bd3:	48 03 34 ce          	add    rsi,QWORD PTR [rsi+rcx*8]
  419bd7:	3e ff e6             	notrack jmp rsi
  419bda:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
		} else if ((w=getint(&s))<0) goto overflow;
  419be0:	83 f9 ff             	cmp    ecx,0xffffffff
  419be3:	0f 85 af fd ff ff    	jne    419998 <printf_core+0x1e8>
	errno = EOVERFLOW;
  419be9:	48 b8 f0 8c fb ff ff 	movabs rax,0xfffffffffffb8cf0
  419bf0:	ff ff ff 
  419bf3:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  419bf8:	48 01 d0             	add    rax,rdx
  419bfb:	ff d0                	call   rax
	return -1;
  419bfd:	c7 44 24 14 ff ff ff 	mov    DWORD PTR [rsp+0x14],0xffffffff
  419c04:	ff 
	errno = EOVERFLOW;
  419c05:	c7 00 4b 00 00 00    	mov    DWORD PTR [rax],0x4b
	return -1;
  419c0b:	e9 a0 fe ff ff       	jmp    419ab0 <printf_core+0x300>
			if (isdigit(s[1]) && s[2]=='$') {
  419c10:	80 7b 02 24          	cmp    BYTE PTR [rbx+0x2],0x24
  419c14:	0f 85 36 fd ff ff    	jne    419950 <printf_core+0x1a0>
				nl_type[s[1]-'0'] = INT;
  419c1a:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
				w = nl_arg[s[1]-'0'].i;
  419c1f:	48 8b 7c 24 48       	mov    rdi,QWORD PTR [rsp+0x48]
				l10n=1;
  419c24:	c7 44 24 58 01 00 00 	mov    DWORD PTR [rsp+0x58],0x1
  419c2b:	00 
				s+=3;
  419c2c:	48 83 c3 03          	add    rbx,0x3
				nl_type[s[1]-'0'] = INT;
  419c30:	c7 84 b0 40 ff ff ff 	mov    DWORD PTR [rax+rsi*4-0xc0],0xa
  419c37:	0a 00 00 00 
				w = nl_arg[s[1]-'0'].i;
  419c3b:	48 0f be 43 fe       	movsx  rax,BYTE PTR [rbx-0x2]
  419c40:	48 c1 e0 04          	shl    rax,0x4
  419c44:	44 8b 8c 07 00 fd ff 	mov    r9d,DWORD PTR [rdi+rax*1-0x300]
  419c4b:	ff 
				s+=3;
  419c4c:	e9 35 fd ff ff       	jmp    419986 <printf_core+0x1d6>
		for (fl=0; (unsigned)*s-' '<32 && (FLAGMASK&(1U<<*s-' ')); s++)
  419c51:	0f be 4b 03          	movsx  ecx,BYTE PTR [rbx+0x3]
			l10n=1;
  419c55:	c7 44 24 58 01 00 00 	mov    DWORD PTR [rsp+0x58],0x1
  419c5c:	00 
			s+=3;
  419c5d:	48 83 c3 03          	add    rbx,0x3
		for (fl=0; (unsigned)*s-' '<32 && (FLAGMASK&(1U<<*s-' ')); s++)
  419c61:	89 cf                	mov    edi,ecx
			s+=3;
  419c63:	e9 89 fc ff ff       	jmp    4198f1 <printf_core+0x141>
			if (argpos>=0) goto inval;
  419c68:	83 fa ff             	cmp    edx,0xffffffff
  419c6b:	0f 84 15 ff ff ff    	je     419b86 <printf_core+0x3d6>
  419c71:	e9 18 fe ff ff       	jmp    419a8e <printf_core+0x2de>
  419c76:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  419c7d:	00 00 00 
				w = f ? va_arg(*ap, int) : 0;
  419c80:	48 8b 4f 08          	mov    rcx,QWORD PTR [rdi+0x8]
  419c84:	48 8d 41 08          	lea    rax,[rcx+0x8]
  419c88:	48 89 47 08          	mov    QWORD PTR [rdi+0x8],rax
  419c8c:	e9 f2 fc ff ff       	jmp    419983 <printf_core+0x1d3>
  419c91:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (i=0; isdigit(**s); (*s)++) {
  419c98:	8d 48 d0             	lea    ecx,[rax-0x30]
			s++;
  419c9b:	48 83 c3 01          	add    rbx,0x1
	for (i=0; isdigit(**s); (*s)++) {
  419c9f:	44 89 f5             	mov    ebp,r14d
  419ca2:	83 f9 09             	cmp    ecx,0x9
  419ca5:	77 4d                	ja     419cf4 <printf_core+0x544>
		if (i > INT_MAX/10U || **s-'0' > INT_MAX-10*i) i = -1;
  419ca7:	be ff ff ff ff       	mov    esi,0xffffffff
  419cac:	eb 29                	jmp    419cd7 <printf_core+0x527>
  419cae:	66 90                	xchg   ax,ax
  419cb0:	6b ed f6             	imul   ebp,ebp,0xfffffff6
  419cb3:	83 e8 30             	sub    eax,0x30
  419cb6:	89 c1                	mov    ecx,eax
  419cb8:	8d bd ff ff ff 7f    	lea    edi,[rbp+0x7fffffff]
  419cbe:	29 e9                	sub    ecx,ebp
  419cc0:	39 f8                	cmp    eax,edi
  419cc2:	0f 4f ce             	cmovg  ecx,esi
	for (i=0; isdigit(**s); (*s)++) {
  419cc5:	0f be 43 01          	movsx  eax,BYTE PTR [rbx+0x1]
  419cc9:	48 83 c3 01          	add    rbx,0x1
  419ccd:	89 cd                	mov    ebp,ecx
  419ccf:	8d 48 d0             	lea    ecx,[rax-0x30]
  419cd2:	83 f9 09             	cmp    ecx,0x9
  419cd5:	77 1d                	ja     419cf4 <printf_core+0x544>
		if (i > INT_MAX/10U || **s-'0' > INT_MAX-10*i) i = -1;
  419cd7:	81 fd cc cc cc 0c    	cmp    ebp,0xccccccc
  419cdd:	76 d1                	jbe    419cb0 <printf_core+0x500>
	for (i=0; isdigit(**s); (*s)++) {
  419cdf:	0f be 43 01          	movsx  eax,BYTE PTR [rbx+0x1]
  419ce3:	48 83 c3 01          	add    rbx,0x1
		if (i > INT_MAX/10U || **s-'0' > INT_MAX-10*i) i = -1;
  419ce7:	bd ff ff ff ff       	mov    ebp,0xffffffff
	for (i=0; isdigit(**s); (*s)++) {
  419cec:	8d 48 d0             	lea    ecx,[rax-0x30]
  419cef:	83 f9 09             	cmp    ecx,0x9
  419cf2:	76 e3                	jbe    419cd7 <printf_core+0x527>
			xp = 1;
  419cf4:	41 ba 01 00 00 00    	mov    r10d,0x1
  419cfa:	e9 51 fd ff ff       	jmp    419a50 <printf_core+0x2a0>
				p = f ? va_arg(*ap, int) : 0;
  419cff:	48 8b 4f 08          	mov    rcx,QWORD PTR [rdi+0x8]
  419d03:	48 8d 41 08          	lea    rax,[rcx+0x8]
  419d07:	48 89 47 08          	mov    QWORD PTR [rdi+0x8],rax
  419d0b:	e9 e8 fc ff ff       	jmp    4199f8 <printf_core+0x248>
			else if (f) pop_arg(&arg, st, ap);
  419d10:	4d 85 ed             	test   r13,r13
  419d13:	0f 84 97 0f 00 00    	je     41acb0 <printf_core+0x1500>
  419d19:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  419d1e:	48 8b 54 24 30       	mov    rdx,QWORD PTR [rsp+0x30]
  419d23:	48 89 7c 24 38       	mov    QWORD PTR [rsp+0x38],rdi
  419d28:	48 b9 90 8d fb ff ff 	movabs rcx,0xfffffffffffb8d90
  419d2f:	ff ff ff 
  419d32:	48 8d bc 24 90 00 00 	lea    rdi,[rsp+0x90]
  419d39:	00 
  419d3a:	48 01 c1             	add    rcx,rax
  419d3d:	ff d1                	call   rcx
		if (!f) continue;
  419d3f:	48 8b 44 24 38       	mov    rax,QWORD PTR [rsp+0x38]
  419d44:	e9 46 fe ff ff       	jmp    419b8f <printf_core+0x3df>
				nl_type[s[2]-'0'] = INT;
  419d49:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
				p = nl_arg[s[2]-'0'].i;
  419d4e:	48 8b 7c 24 48       	mov    rdi,QWORD PTR [rsp+0x48]
				s+=4;
  419d53:	48 83 c3 04          	add    rbx,0x4
				nl_type[s[2]-'0'] = INT;
  419d57:	c7 84 88 40 ff ff ff 	mov    DWORD PTR [rax+rcx*4-0xc0],0xa
  419d5e:	0a 00 00 00 
				p = nl_arg[s[2]-'0'].i;
  419d62:	48 0f be 43 fe       	movsx  rax,BYTE PTR [rbx-0x2]
  419d67:	48 c1 e0 04          	shl    rax,0x4
  419d6b:	48 8b 84 07 00 fd ff 	mov    rax,QWORD PTR [rdi+rax*1-0x300]
  419d72:	ff 
  419d73:	89 c5                	mov    ebp,eax
			xp = (p>=0);
  419d75:	f7 d0                	not    eax
  419d77:	c1 e8 1f             	shr    eax,0x1f
  419d7a:	41 89 c2             	mov    r10d,eax
				s+=4;
  419d7d:	e9 ce fc ff ff       	jmp    419a50 <printf_core+0x2a0>
				p = f ? va_arg(*ap, int) : 0;
  419d82:	44 89 f5             	mov    ebp,r14d
  419d85:	41 ba 01 00 00 00    	mov    r10d,0x1
  419d8b:	e9 74 fc ff ff       	jmp    419a04 <printf_core+0x254>
	if (f) return cnt;
  419d90:	4d 85 ed             	test   r13,r13
  419d93:	0f 85 17 fd ff ff    	jne    419ab0 <printf_core+0x300>
	if (!l10n) return 0;
  419d99:	44 8b 64 24 58       	mov    r12d,DWORD PTR [rsp+0x58]
  419d9e:	45 85 e4             	test   r12d,r12d
  419da1:	0f 84 09 0f 00 00    	je     41acb0 <printf_core+0x1500>
  419da7:	48 8b 7c 24 48       	mov    rdi,QWORD PTR [rsp+0x48]
		pop_arg(nl_arg+i, nl_type[i], ap);
  419dac:	4c 8b 54 24 30       	mov    r10,QWORD PTR [rsp+0x30]
	for (i=1; i<=NL_ARGMAX && nl_type[i]; i++)
  419db1:	41 b8 01 00 00 00    	mov    r8d,0x1
		pop_arg(nl_arg+i, nl_type[i], ap);
  419db7:	49 b9 90 8d fb ff ff 	movabs r9,0xfffffffffffb8d90
  419dbe:	ff ff ff 
  419dc1:	4c 8b 5c 24 40       	mov    r11,QWORD PTR [rsp+0x40]
  419dc6:	48 83 c7 10          	add    rdi,0x10
	for (i=1; i<=NL_ARGMAX && nl_type[i]; i++)
  419dca:	43 8b 34 83          	mov    esi,DWORD PTR [r11+r8*4]
  419dce:	85 f6                	test   esi,esi
  419dd0:	0f 84 6c 0f 00 00    	je     41ad42 <printf_core+0x1592>
		pop_arg(nl_arg+i, nl_type[i], ap);
  419dd6:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
	for (i=1; i<=NL_ARGMAX && nl_type[i]; i++)
  419ddb:	49 83 c0 01          	add    r8,0x1
		pop_arg(nl_arg+i, nl_type[i], ap);
  419ddf:	4c 89 d2             	mov    rdx,r10
  419de2:	4c 01 c8             	add    rax,r9
  419de5:	ff d0                	call   rax
	for (i=1; i<=NL_ARGMAX && nl_type[i]; i++)
  419de7:	48 83 c7 10          	add    rdi,0x10
  419deb:	49 83 f8 0a          	cmp    r8,0xa
  419def:	75 d9                	jne    419dca <printf_core+0x61a>
	return 1;
  419df1:	c7 44 24 14 01 00 00 	mov    DWORD PTR [rsp+0x14],0x1
  419df8:	00 
  419df9:	e9 b2 fc ff ff       	jmp    419ab0 <printf_core+0x300>
  419dfe:	66 90                	xchg   ax,ax
		if (p < z-a) p = z-a;
  419e00:	48 8d 84 24 cb 00 00 	lea    rax,[rsp+0xcb]
  419e07:	00 
  419e08:	4c 29 c0             	sub    rax,r8
  419e0b:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
  419e10:	48 63 c5             	movsxd rax,ebp
  419e13:	48 39 44 24 50       	cmp    QWORD PTR [rsp+0x50],rax
  419e18:	44 89 74 24 60       	mov    DWORD PTR [rsp+0x60],r14d
  419e1d:	0f 8e 8d 0d 00 00    	jle    41abb0 <printf_core+0x1400>
  419e23:	48 8b 7c 24 18       	mov    rdi,QWORD PTR [rsp+0x18]
  419e28:	ba ff ff ff 7f       	mov    edx,0x7fffffff
  419e2d:	48 b8 75 1e fc ff ff 	movabs rax,0xfffffffffffc1e75
  419e34:	ff ff ff 
  419e37:	48 01 f8             	add    rax,rdi
  419e3a:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  419e3f:	8b 6c 24 50          	mov    ebp,DWORD PTR [rsp+0x50]
		if (p > INT_MAX-pl) goto overflow;
  419e43:	39 d5                	cmp    ebp,edx
  419e45:	0f 8f 9e fd ff ff    	jg     419be9 <printf_core+0x439>
		if (w < pl+p) w = pl+p;
  419e4b:	8b 44 24 60          	mov    eax,DWORD PTR [rsp+0x60]
  419e4f:	01 e8                	add    eax,ebp
  419e51:	89 44 24 5c          	mov    DWORD PTR [rsp+0x5c],eax
  419e55:	8b 44 24 5c          	mov    eax,DWORD PTR [rsp+0x5c]
  419e59:	41 39 c1             	cmp    r9d,eax
  419e5c:	44 0f 4c c8          	cmovl  r9d,eax
  419e60:	44 89 4c 24 08       	mov    DWORD PTR [rsp+0x8],r9d
		if (w > INT_MAX-cnt) goto overflow;
  419e65:	45 39 cb             	cmp    r11d,r9d
  419e68:	0f 8c 7b fd ff ff    	jl     419be9 <printf_core+0x439>
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  419e6e:	41 39 c1             	cmp    r9d,eax
  419e71:	0f 9e 44 24 38       	setle  BYTE PTR [rsp+0x38]
  419e76:	0f b6 44 24 38       	movzx  eax,BYTE PTR [rsp+0x38]
  419e7b:	41 f7 c4 00 20 01 00 	test   r12d,0x12000
  419e82:	0f 85 ec 0a 00 00    	jne    41a974 <printf_core+0x11c4>
  419e88:	84 c0                	test   al,al
  419e8a:	0f 85 e4 0a 00 00    	jne    41a974 <printf_core+0x11c4>
  419e90:	44 89 c9             	mov    ecx,r9d
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  419e93:	b8 00 01 00 00       	mov    eax,0x100
	l = w - l;
  419e98:	2b 4c 24 5c          	sub    ecx,DWORD PTR [rsp+0x5c]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  419e9c:	4c 8b 7c 24 18       	mov    r15,QWORD PTR [rsp+0x18]
  419ea1:	39 c1                	cmp    ecx,eax
  419ea3:	4c 8d b4 24 d0 00 00 	lea    r14,[rsp+0xd0]
  419eaa:	00 
  419eab:	4c 89 44 24 78       	mov    QWORD PTR [rsp+0x78],r8
  419eb0:	be 20 00 00 00       	mov    esi,0x20
  419eb5:	0f 4e c1             	cmovle eax,ecx
  419eb8:	89 4c 24 68          	mov    DWORD PTR [rsp+0x68],ecx
  419ebc:	4c 89 f7             	mov    rdi,r14
  419ebf:	48 63 d0             	movsxd rdx,eax
  419ec2:	48 b8 7c 79 fb ff ff 	movabs rax,0xfffffffffffb797c
  419ec9:	ff ff ff 
  419ecc:	4c 01 f8             	add    rax,r15
  419ecf:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  419ed1:	8b 4c 24 68          	mov    ecx,DWORD PTR [rsp+0x68]
  419ed5:	4c 8b 44 24 78       	mov    r8,QWORD PTR [rsp+0x78]
  419eda:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  419ee0:	0f 8e 5f 0d 00 00    	jle    41ac45 <printf_core+0x1495>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419ee6:	41 8b 55 00          	mov    edx,DWORD PTR [r13+0x0]
  419eea:	44 8d b9 00 ff ff ff 	lea    r15d,[rcx-0x100]
  419ef1:	89 d0                	mov    eax,edx
  419ef3:	83 e0 20             	and    eax,0x20
  419ef6:	0f 84 24 0a 00 00    	je     41a920 <printf_core+0x1170>
	for (; l >= sizeof pad; l -= sizeof pad)
  419efc:	41 81 ff ff 00 00 00 	cmp    r15d,0xff
  419f03:	7e 57                	jle    419f5c <printf_core+0x7ac>
  419f05:	41 8d 97 00 e9 ff ff 	lea    edx,[r15-0x1700]
  419f0c:	81 fa 00 e9 ff 7f    	cmp    edx,0x7fffe900
  419f12:	0f 86 13 f4 ff ff    	jbe    41932b <printf_core.cold>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419f18:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  419f1a:	41 81 ef 00 01 00 00 	sub    r15d,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419f21:	89 d0                	mov    eax,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  419f23:	44 89 f9             	mov    ecx,r15d
  419f26:	41 81 ff ff 00 00 00 	cmp    r15d,0xff
  419f2d:	77 eb                	ja     419f1a <printf_core+0x76a>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419f2f:	85 c0                	test   eax,eax
  419f31:	75 31                	jne    419f64 <printf_core+0x7b4>
  419f33:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
	out(f, pad, l);
  419f38:	48 63 f1             	movsxd rsi,ecx
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419f3b:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  419f40:	4c 89 ea             	mov    rdx,r13
  419f43:	4c 89 44 24 68       	mov    QWORD PTR [rsp+0x68],r8
  419f48:	4c 89 f7             	mov    rdi,r14
  419f4b:	48 01 c8             	add    rax,rcx
  419f4e:	ff d0                	call   rax
  419f50:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
  419f54:	4c 8b 44 24 68       	mov    r8,QWORD PTR [rsp+0x68]
  419f59:	83 e0 20             	and    eax,0x20
  419f5c:	85 c0                	test   eax,eax
  419f5e:	0f 84 1f 0a 00 00    	je     41a983 <printf_core+0x11d3>
		pad(f, '0', w, pl+p, fl^ZERO_PAD);
  419f64:	44 89 e0             	mov    eax,r12d
  419f67:	35 00 00 01 00       	xor    eax,0x10000
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  419f6c:	a9 00 20 01 00       	test   eax,0x12000
  419f71:	0f 85 d1 00 00 00    	jne    41a048 <printf_core+0x898>
  419f77:	80 7c 24 38 00       	cmp    BYTE PTR [rsp+0x38],0x0
  419f7c:	0f 85 c6 00 00 00    	jne    41a048 <printf_core+0x898>
	l = w - l;
  419f82:	8b 4c 24 08          	mov    ecx,DWORD PTR [rsp+0x8]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  419f86:	b8 00 01 00 00       	mov    eax,0x100
	l = w - l;
  419f8b:	2b 4c 24 5c          	sub    ecx,DWORD PTR [rsp+0x5c]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  419f8f:	4c 8d b4 24 d0 00 00 	lea    r14,[rsp+0xd0]
  419f96:	00 
  419f97:	39 c1                	cmp    ecx,eax
  419f99:	4c 8b 7c 24 18       	mov    r15,QWORD PTR [rsp+0x18]
  419f9e:	4c 89 44 24 68       	mov    QWORD PTR [rsp+0x68],r8
  419fa3:	4c 89 f7             	mov    rdi,r14
  419fa6:	0f 4e c1             	cmovle eax,ecx
  419fa9:	89 4c 24 60          	mov    DWORD PTR [rsp+0x60],ecx
  419fad:	be 30 00 00 00       	mov    esi,0x30
  419fb2:	48 63 d0             	movsxd rdx,eax
  419fb5:	48 b8 7c 79 fb ff ff 	movabs rax,0xfffffffffffb797c
  419fbc:	ff ff ff 
  419fbf:	4c 01 f8             	add    rax,r15
  419fc2:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  419fc4:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  419fc8:	4c 8b 44 24 68       	mov    r8,QWORD PTR [rsp+0x68]
  419fcd:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  419fd3:	0f 8e 60 0c 00 00    	jle    41ac39 <printf_core+0x1489>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419fd9:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
  419fdd:	44 8d b9 00 ff ff ff 	lea    r15d,[rcx-0x100]
  419fe4:	83 e0 20             	and    eax,0x20
  419fe7:	0f 84 a3 08 00 00    	je     41a890 <printf_core+0x10e0>
	for (; l >= sizeof pad; l -= sizeof pad)
  419fed:	41 81 ff ff 00 00 00 	cmp    r15d,0xff
  419ff4:	7e 52                	jle    41a048 <printf_core+0x898>
  419ff6:	41 8d 97 00 e9 ff ff 	lea    edx,[r15-0x1700]
  419ffd:	81 fa 00 e9 ff 7f    	cmp    edx,0x7fffe900
  41a003:	0f 86 e7 f6 ff ff    	jbe    4196f0 <printf_core.cold+0x3c5>
  41a009:	41 81 ef 00 01 00 00 	sub    r15d,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a010:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  41a012:	44 89 f9             	mov    ecx,r15d
  41a015:	41 81 ff ff 00 00 00 	cmp    r15d,0xff
  41a01c:	77 eb                	ja     41a009 <printf_core+0x859>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a01e:	85 d2                	test   edx,edx
  41a020:	75 26                	jne    41a048 <printf_core+0x898>
  41a022:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
	out(f, pad, l);
  41a027:	48 63 f1             	movsxd rsi,ecx
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a02a:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  41a02f:	4c 89 ea             	mov    rdx,r13
  41a032:	4c 89 44 24 60       	mov    QWORD PTR [rsp+0x60],r8
  41a037:	4c 89 f7             	mov    rdi,r14
  41a03a:	48 01 c8             	add    rax,rcx
  41a03d:	ff d0                	call   rax
  41a03f:	4c 8b 44 24 60       	mov    r8,QWORD PTR [rsp+0x60]
  41a044:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41a048:	39 6c 24 50          	cmp    DWORD PTR [rsp+0x50],ebp
  41a04c:	0f 8d 5c 09 00 00    	jge    41a9ae <printf_core+0x11fe>
	l = w - l;
  41a052:	2b 6c 24 50          	sub    ebp,DWORD PTR [rsp+0x50]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41a056:	b8 00 01 00 00       	mov    eax,0x100
  41a05b:	4c 8b 7c 24 18       	mov    r15,QWORD PTR [rsp+0x18]
  41a060:	4c 8d b4 24 d0 00 00 	lea    r14,[rsp+0xd0]
  41a067:	00 
  41a068:	39 c5                	cmp    ebp,eax
  41a06a:	4c 89 44 24 60       	mov    QWORD PTR [rsp+0x60],r8
  41a06f:	be 30 00 00 00       	mov    esi,0x30
  41a074:	4c 89 f7             	mov    rdi,r14
  41a077:	0f 4e c5             	cmovle eax,ebp
  41a07a:	48 63 d0             	movsxd rdx,eax
  41a07d:	48 b8 7c 79 fb ff ff 	movabs rax,0xfffffffffffb797c
  41a084:	ff ff ff 
  41a087:	4c 01 f8             	add    rax,r15
  41a08a:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  41a08c:	81 fd ff 00 00 00    	cmp    ebp,0xff
  41a092:	4c 8b 44 24 60       	mov    r8,QWORD PTR [rsp+0x60]
  41a097:	0f 8e 83 0b 00 00    	jle    41ac20 <printf_core+0x1470>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a09d:	41 8b 55 00          	mov    edx,DWORD PTR [r13+0x0]
  41a0a1:	44 8d bd 00 ff ff ff 	lea    r15d,[rbp-0x100]
  41a0a8:	4c 89 c5             	mov    rbp,r8
  41a0ab:	89 d0                	mov    eax,edx
  41a0ad:	83 e0 20             	and    eax,0x20
  41a0b0:	0f 84 9a 07 00 00    	je     41a850 <printf_core+0x10a0>
	for (; l >= sizeof pad; l -= sizeof pad)
  41a0b6:	49 89 e8             	mov    r8,rbp
  41a0b9:	41 81 ff ff 00 00 00 	cmp    r15d,0xff
  41a0c0:	0f 8e ef 08 00 00    	jle    41a9b5 <printf_core+0x1205>
  41a0c6:	41 8d 97 00 e9 ff ff 	lea    edx,[r15-0x1700]
  41a0cd:	81 fa 00 e9 ff 7f    	cmp    edx,0x7fffe900
  41a0d3:	0f 86 a6 f4 ff ff    	jbe    41957f <printf_core.cold+0x254>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a0d9:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  41a0db:	41 81 ef 00 01 00 00 	sub    r15d,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a0e2:	89 d0                	mov    eax,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  41a0e4:	44 89 fd             	mov    ebp,r15d
  41a0e7:	41 81 ff ff 00 00 00 	cmp    r15d,0xff
  41a0ee:	77 eb                	ja     41a0db <printf_core+0x92b>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a0f0:	85 c0                	test   eax,eax
  41a0f2:	0f 84 71 0a 00 00    	je     41ab69 <printf_core+0x13b9>
		pad(f, ' ', w, pl+p, fl^LEFT_ADJ);
  41a0f8:	41 81 f4 00 20 00 00 	xor    r12d,0x2000
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41a0ff:	41 81 e4 00 20 01 00 	and    r12d,0x12000
  41a106:	0f 85 a6 f7 ff ff    	jne    4198b2 <printf_core+0x102>
  41a10c:	80 7c 24 38 00       	cmp    BYTE PTR [rsp+0x38],0x0
  41a111:	0f 85 9b f7 ff ff    	jne    4198b2 <printf_core+0x102>
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41a117:	b8 00 01 00 00       	mov    eax,0x100
	l = w - l;
  41a11c:	44 8b 64 24 08       	mov    r12d,DWORD PTR [rsp+0x8]
  41a121:	44 2b 64 24 5c       	sub    r12d,DWORD PTR [rsp+0x5c]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41a126:	4c 8d b4 24 d0 00 00 	lea    r14,[rsp+0xd0]
  41a12d:	00 
  41a12e:	41 39 c4             	cmp    r12d,eax
  41a131:	4c 8b 7c 24 18       	mov    r15,QWORD PTR [rsp+0x18]
  41a136:	be 20 00 00 00       	mov    esi,0x20
  41a13b:	4c 89 f7             	mov    rdi,r14
  41a13e:	41 0f 4e c4          	cmovle eax,r12d
  41a142:	48 63 d0             	movsxd rdx,eax
  41a145:	48 b8 7c 79 fb ff ff 	movabs rax,0xfffffffffffb797c
  41a14c:	ff ff ff 
  41a14f:	4c 01 f8             	add    rax,r15
  41a152:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  41a154:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  41a15b:	0f 8e f0 0a 00 00    	jle    41ac51 <printf_core+0x14a1>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a161:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
  41a165:	41 8d ac 24 00 ff ff 	lea    ebp,[r12-0x100]
  41a16c:	ff 
  41a16d:	0f 1f 00             	nop    DWORD PTR [rax]
  41a170:	83 e0 20             	and    eax,0x20
  41a173:	0f 84 67 07 00 00    	je     41a8e0 <printf_core+0x1130>
	for (; l >= sizeof pad; l -= sizeof pad)
  41a179:	81 fd ff 00 00 00    	cmp    ebp,0xff
  41a17f:	0f 8e 2d f7 ff ff    	jle    4198b2 <printf_core+0x102>
  41a185:	8d 95 00 e9 ff ff    	lea    edx,[rbp-0x1700]
  41a18b:	81 fa 00 e9 ff 7f    	cmp    edx,0x7fffe900
  41a191:	0f 86 9f f4 ff ff    	jbe    419636 <printf_core.cold+0x30b>
  41a197:	81 ed 00 01 00 00    	sub    ebp,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a19d:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  41a19f:	41 89 ec             	mov    r12d,ebp
  41a1a2:	81 fd ff 00 00 00    	cmp    ebp,0xff
  41a1a8:	77 ed                	ja     41a197 <printf_core+0x9e7>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a1aa:	85 d2                	test   edx,edx
  41a1ac:	0f 85 00 f7 ff ff    	jne    4198b2 <printf_core+0x102>
  41a1b2:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  41a1b7:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
	out(f, pad, l);
  41a1bc:	49 63 f4             	movsxd rsi,r12d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a1bf:	4c 89 ea             	mov    rdx,r13
  41a1c2:	4c 89 f7             	mov    rdi,r14
  41a1c5:	48 01 c8             	add    rax,rcx
  41a1c8:	ff d0                	call   rax
  41a1ca:	e9 e3 f6 ff ff       	jmp    4198b2 <printf_core+0x102>
			if (xp && p<0) goto overflow;
  41a1cf:	85 ed                	test   ebp,ebp
  41a1d1:	79 0a                	jns    41a1dd <printf_core+0xa2d>
  41a1d3:	41 83 e2 01          	and    r10d,0x1
  41a1d7:	0f 85 0c fa ff ff    	jne    419be9 <printf_core+0x439>
  41a1dd:	44 89 5c 24 38       	mov    DWORD PTR [rsp+0x38],r11d
			l = fmt_fp(f, arg.f, w, p, fl, t);
  41a1e2:	41 89 d0             	mov    r8d,edx
  41a1e5:	44 89 e1             	mov    ecx,r12d
  41a1e8:	89 ea                	mov    edx,ebp
  41a1ea:	ff b4 24 98 00 00 00 	push   QWORD PTR [rsp+0x98]
  41a1f1:	44 89 ce             	mov    esi,r9d
  41a1f4:	4c 89 ef             	mov    rdi,r13
  41a1f7:	48 b8 f0 95 fb ff ff 	movabs rax,0xfffffffffffb95f0
  41a1fe:	ff ff ff 
  41a201:	ff b4 24 98 00 00 00 	push   QWORD PTR [rsp+0x98]
  41a208:	4c 8b 54 24 28       	mov    r10,QWORD PTR [rsp+0x28]
  41a20d:	4c 01 d0             	add    rax,r10
  41a210:	ff d0                	call   rax
			if (l<0) goto overflow;
  41a212:	85 c0                	test   eax,eax
			l = fmt_fp(f, arg.f, w, p, fl, t);
  41a214:	89 44 24 18          	mov    DWORD PTR [rsp+0x18],eax
			if (l<0) goto overflow;
  41a218:	41 5e                	pop    r14
  41a21a:	41 5f                	pop    r15
  41a21c:	44 8b 5c 24 38       	mov    r11d,DWORD PTR [rsp+0x38]
  41a221:	0f 89 80 f6 ff ff    	jns    4198a7 <printf_core+0xf7>
  41a227:	e9 bd f9 ff ff       	jmp    419be9 <printf_core+0x439>
  41a22c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
			if (arg.i>INTMAX_MAX) {
  41a230:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  41a237:	00 
  41a238:	48 85 c9             	test   rcx,rcx
  41a23b:	0f 88 1c 0a 00 00    	js     41ac5d <printf_core+0x14ad>
			} else if (fl & MARK_POS) {
  41a241:	41 f7 c4 00 08 00 00 	test   r12d,0x800
  41a248:	0f 85 3e 0a 00 00    	jne    41ac8c <printf_core+0x14dc>
			} else if (fl & PAD_POS) {
  41a24e:	41 f6 c4 01          	test   r12b,0x1
  41a252:	0f 85 c0 0b 00 00    	jne    41ae18 <printf_core+0x1668>
		prefix = "-+   0X0x";
  41a258:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
			} else pl=0;
  41a25d:	44 89 74 24 60       	mov    DWORD PTR [rsp+0x60],r14d
		prefix = "-+   0X0x";
  41a262:	48 b8 75 1e fc ff ff 	movabs rax,0xfffffffffffc1e75
  41a269:	ff ff ff 
  41a26c:	48 01 d0             	add    rax,rdx
  41a26f:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  41a274:	48 85 c9             	test   rcx,rcx
  41a277:	0f 84 b5 0a 00 00    	je     41ad32 <printf_core+0x1582>
		prefix = "-+   0X0x";
  41a27d:	4c 8d bc 24 cb 00 00 	lea    r15,[rsp+0xcb]
  41a284:	00 
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  41a285:	48 be cd cc cc cc cc 	movabs rsi,0xcccccccccccccccd
  41a28c:	cc cc cc 
		prefix = "-+   0X0x";
  41a28f:	4d 89 f8             	mov    r8,r15
  41a292:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  41a298:	48 89 c8             	mov    rax,rcx
  41a29b:	49 83 e8 01          	sub    r8,0x1
  41a29f:	48 f7 e6             	mul    rsi
  41a2a2:	48 89 c8             	mov    rax,rcx
  41a2a5:	48 c1 ea 03          	shr    rdx,0x3
  41a2a9:	48 8d 3c 92          	lea    rdi,[rdx+rdx*4]
  41a2ad:	48 01 ff             	add    rdi,rdi
  41a2b0:	48 29 f8             	sub    rax,rdi
  41a2b3:	83 c0 30             	add    eax,0x30
  41a2b6:	41 88 00             	mov    BYTE PTR [r8],al
  41a2b9:	48 89 c8             	mov    rax,rcx
  41a2bc:	48 89 d1             	mov    rcx,rdx
  41a2bf:	48 83 f8 09          	cmp    rax,0x9
  41a2c3:	77 d3                	ja     41a298 <printf_core+0xae8>
			if (xp && p<0) goto overflow;
  41a2c5:	85 ed                	test   ebp,ebp
  41a2c7:	79 0a                	jns    41a2d3 <printf_core+0xb23>
  41a2c9:	41 f6 c2 01          	test   r10b,0x1
  41a2cd:	0f 85 16 f9 ff ff    	jne    419be9 <printf_core+0x439>
			if (xp) fl &= ~ZERO_PAD;
  41a2d3:	44 89 e0             	mov    eax,r12d
  41a2d6:	25 ff ff fe ff       	and    eax,0xfffeffff
  41a2db:	45 85 d2             	test   r10d,r10d
  41a2de:	44 0f 45 e0          	cmovne r12d,eax
			if (!arg.i && !p) {
  41a2e2:	48 83 bc 24 90 00 00 	cmp    QWORD PTR [rsp+0x90],0x0
  41a2e9:	00 00 
  41a2eb:	0f 94 c0             	sete   al
  41a2ee:	85 ed                	test   ebp,ebp
  41a2f0:	75 08                	jne    41a2fa <printf_core+0xb4a>
  41a2f2:	84 c0                	test   al,al
  41a2f4:	0f 85 9d 08 00 00    	jne    41ab97 <printf_core+0x13e7>
			p = MAX(p, z-a + !arg.i);
  41a2fa:	4c 89 ff             	mov    rdi,r15
  41a2fd:	0f b6 c0             	movzx  eax,al
  41a300:	48 63 ed             	movsxd rbp,ebp
		if (p > INT_MAX-pl) goto overflow;
  41a303:	ba ff ff ff 7f       	mov    edx,0x7fffffff
			p = MAX(p, z-a + !arg.i);
  41a308:	4c 29 c7             	sub    rdi,r8
  41a30b:	48 01 f8             	add    rax,rdi
  41a30e:	48 89 7c 24 50       	mov    QWORD PTR [rsp+0x50],rdi
  41a313:	48 39 e8             	cmp    rax,rbp
  41a316:	48 0f 4c c5          	cmovl  rax,rbp
		if (p > INT_MAX-pl) goto overflow;
  41a31a:	2b 54 24 60          	sub    edx,DWORD PTR [rsp+0x60]
			p = MAX(p, z-a + !arg.i);
  41a31e:	89 c5                	mov    ebp,eax
		if (p < z-a) p = z-a;
  41a320:	48 98                	cdqe   
  41a322:	48 39 c7             	cmp    rdi,rax
  41a325:	0f 8f 14 fb ff ff    	jg     419e3f <printf_core+0x68f>
  41a32b:	e9 13 fb ff ff       	jmp    419e43 <printf_core+0x693>
			a = fmt_x(arg.i, z, t&32);
  41a330:	89 d7                	mov    edi,edx
  41a332:	83 e7 20             	and    edi,0x20
  41a335:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  41a33c:	00 
	for (; x; x>>=4) *--s = xdigits[(x&15)]|lower;
  41a33d:	48 85 c0             	test   rax,rax
  41a340:	0f 84 c0 09 00 00    	je     41ad06 <printf_core+0x1556>
  41a346:	89 54 24 38          	mov    DWORD PTR [rsp+0x38],edx
  41a34a:	4c 8d bc 24 cb 00 00 	lea    r15,[rsp+0xcb]
  41a351:	00 
  41a352:	48 be 90 20 fc ff ff 	movabs rsi,0xfffffffffffc2090
  41a359:	ff ff ff 
  41a35c:	48 03 74 24 18       	add    rsi,QWORD PTR [rsp+0x18]
  41a361:	4d 89 f8             	mov    r8,r15
  41a364:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  41a368:	48 89 c1             	mov    rcx,rax
  41a36b:	49 83 e8 01          	sub    r8,0x1
  41a36f:	83 e1 0f             	and    ecx,0xf
  41a372:	0f b6 14 0e          	movzx  edx,BYTE PTR [rsi+rcx*1]
  41a376:	09 fa                	or     edx,edi
  41a378:	48 c1 e8 04          	shr    rax,0x4
  41a37c:	41 88 10             	mov    BYTE PTR [r8],dl
  41a37f:	75 e7                	jne    41a368 <printf_core+0xbb8>
  41a381:	8b 54 24 38          	mov    edx,DWORD PTR [rsp+0x38]
			if (arg.i && (fl & ALT_FORM)) prefix+=(t>>4), pl=2;
  41a385:	41 f6 c4 08          	test   r12b,0x8
  41a389:	0f 84 d5 00 00 00    	je     41a464 <printf_core+0xcb4>
  41a38f:	89 d0                	mov    eax,edx
  41a391:	48 8b 7c 24 18       	mov    rdi,QWORD PTR [rsp+0x18]
  41a396:	c7 44 24 60 02 00 00 	mov    DWORD PTR [rsp+0x60],0x2
  41a39d:	00 
  41a39e:	48 ba 75 1e fc ff ff 	movabs rdx,0xfffffffffffc1e75
  41a3a5:	ff ff ff 
  41a3a8:	c1 f8 04             	sar    eax,0x4
  41a3ab:	48 98                	cdqe   
  41a3ad:	48 01 fa             	add    rdx,rdi
  41a3b0:	48 01 d0             	add    rax,rdx
  41a3b3:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  41a3b8:	e9 08 ff ff ff       	jmp    41a2c5 <printf_core+0xb15>
		prefix = "-+   0X0x";
  41a3bd:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
			*(a=z-(p=1))=arg.i;
  41a3c2:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  41a3c9:	00 
		prefix = "-+   0X0x";
  41a3ca:	48 b8 75 1e fc ff ff 	movabs rax,0xfffffffffffc1e75
  41a3d1:	ff ff ff 
		pl = 0;
  41a3d4:	44 89 74 24 60       	mov    DWORD PTR [rsp+0x60],r14d
			break;
  41a3d9:	c7 44 24 5c 01 00 00 	mov    DWORD PTR [rsp+0x5c],0x1
  41a3e0:	00 
			fl &= ~ZERO_PAD;
  41a3e1:	41 81 e4 ff ff fe ff 	and    r12d,0xfffeffff
			*(a=z-(p=1))=arg.i;
  41a3e8:	4c 8d 84 24 ca 00 00 	lea    r8,[rsp+0xca]
  41a3ef:	00 
		prefix = "-+   0X0x";
  41a3f0:	48 01 d0             	add    rax,rdx
			*(a=z-(p=1))=arg.i;
  41a3f3:	88 8c 24 ca 00 00 00 	mov    BYTE PTR [rsp+0xca],cl
			break;
  41a3fa:	48 c7 44 24 50 01 00 	mov    QWORD PTR [rsp+0x50],0x1
  41a401:	00 00 
		prefix = "-+   0X0x";
  41a403:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
			*(a=z-(p=1))=arg.i;
  41a408:	c7 44 24 08 01 00 00 	mov    DWORD PTR [rsp+0x8],0x1
  41a40f:	00 
		if (p < z-a) p = z-a;
  41a410:	8b 6c 24 08          	mov    ebp,DWORD PTR [rsp+0x8]
  41a414:	e9 3c fa ff ff       	jmp    419e55 <printf_core+0x6a5>
			a = fmt_o(arg.i, z);
  41a419:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  41a420:	00 
	for (; x; x>>=3) *--s = '0' + (x&7);
  41a421:	4c 8d bc 24 cb 00 00 	lea    r15,[rsp+0xcb]
  41a428:	00 
  41a429:	4d 89 f8             	mov    r8,r15
  41a42c:	48 85 c0             	test   rax,rax
  41a42f:	74 1c                	je     41a44d <printf_core+0xc9d>
  41a431:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  41a438:	89 c2                	mov    edx,eax
  41a43a:	49 83 e8 01          	sub    r8,0x1
  41a43e:	83 e2 07             	and    edx,0x7
  41a441:	83 c2 30             	add    edx,0x30
  41a444:	48 c1 e8 03          	shr    rax,0x3
  41a448:	41 88 10             	mov    BYTE PTR [r8],dl
  41a44b:	75 eb                	jne    41a438 <printf_core+0xc88>
			if ((fl&ALT_FORM) && p<z-a+1) p=z-a+1;
  41a44d:	41 f6 c4 08          	test   r12b,0x8
  41a451:	74 11                	je     41a464 <printf_core+0xcb4>
  41a453:	4c 89 f8             	mov    rax,r15
  41a456:	48 63 d5             	movsxd rdx,ebp
  41a459:	4c 29 c0             	sub    rax,r8
  41a45c:	48 39 d0             	cmp    rax,rdx
  41a45f:	7c 03                	jl     41a464 <printf_core+0xcb4>
  41a461:	8d 68 01             	lea    ebp,[rax+0x1]
		prefix = "-+   0X0x";
  41a464:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
		pl = 0;
  41a469:	44 89 74 24 60       	mov    DWORD PTR [rsp+0x60],r14d
		prefix = "-+   0X0x";
  41a46e:	48 b8 75 1e fc ff ff 	movabs rax,0xfffffffffffc1e75
  41a475:	ff ff ff 
  41a478:	48 01 d0             	add    rax,rdx
  41a47b:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  41a480:	e9 40 fe ff ff       	jmp    41a2c5 <printf_core+0xb15>
			p = MAX(p, 2*sizeof(void*));
  41a485:	b8 10 00 00 00       	mov    eax,0x10
			fl |= ALT_FORM;
  41a48a:	bf 20 00 00 00       	mov    edi,0x20
			t = 'x';
  41a48f:	ba 78 00 00 00       	mov    edx,0x78
			p = MAX(p, 2*sizeof(void*));
  41a494:	39 c5                	cmp    ebp,eax
  41a496:	0f 42 e8             	cmovb  ebp,eax
			fl |= ALT_FORM;
  41a499:	41 83 cc 08          	or     r12d,0x8
  41a49d:	e9 93 fe ff ff       	jmp    41a335 <printf_core+0xb85>
			a = arg.p ? arg.p : "(null)";
  41a4a2:	4c 8b 84 24 90 00 00 	mov    r8,QWORD PTR [rsp+0x90]
  41a4a9:	00 
  41a4aa:	4d 85 c0             	test   r8,r8
  41a4ad:	0f 84 0a 08 00 00    	je     41acbd <printf_core+0x150d>
			z = a + strnlen(a, p<0 ? INT_MAX : p);
  41a4b3:	85 ed                	test   ebp,ebp
  41a4b5:	0f 88 11 07 00 00    	js     41abcc <printf_core+0x141c>
  41a4bb:	4c 8b 7c 24 18       	mov    r15,QWORD PTR [rsp+0x18]
  41a4c0:	44 89 4c 24 50       	mov    DWORD PTR [rsp+0x50],r9d
  41a4c5:	48 63 f5             	movsxd rsi,ebp
  41a4c8:	4c 89 c7             	mov    rdi,r8
  41a4cb:	48 b8 c0 86 fb ff ff 	movabs rax,0xfffffffffffb86c0
  41a4d2:	ff ff ff 
  41a4d5:	44 89 5c 24 38       	mov    DWORD PTR [rsp+0x38],r11d
  41a4da:	4c 89 44 24 08       	mov    QWORD PTR [rsp+0x8],r8
  41a4df:	4c 01 f8             	add    rax,r15
  41a4e2:	ff d0                	call   rax
  41a4e4:	4c 8b 44 24 08       	mov    r8,QWORD PTR [rsp+0x8]
  41a4e9:	44 8b 5c 24 38       	mov    r11d,DWORD PTR [rsp+0x38]
  41a4ee:	44 8b 4c 24 50       	mov    r9d,DWORD PTR [rsp+0x50]
  41a4f3:	48 89 c5             	mov    rbp,rax
  41a4f6:	49 8d 04 00          	lea    rax,[r8+rax*1]
		if (p < z-a) p = z-a;
  41a4fa:	4c 29 c0             	sub    rax,r8
			fl &= ~ZERO_PAD;
  41a4fd:	41 81 e4 ff ff fe ff 	and    r12d,0xfffeffff
		if (p < z-a) p = z-a;
  41a504:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
			break;
  41a509:	e9 02 f9 ff ff       	jmp    419e10 <printf_core+0x660>
			ws = arg.p;
  41a50e:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  41a515:	00 
  41a516:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
			for (i=l=0; i<p && *ws && (l=wctomb(mb, *ws++))>=0 && l<=p-i; i+=l);
  41a51b:	48 63 c5             	movsxd rax,ebp
  41a51e:	48 89 c2             	mov    rdx,rax
  41a521:	48 85 c0             	test   rax,rax
  41a524:	0f 84 1e 09 00 00    	je     41ae48 <printf_core+0x1698>
  41a52a:	4c 8b 74 24 50       	mov    r14,QWORD PTR [rsp+0x50]
  41a52f:	31 ed                	xor    ebp,ebp
  41a531:	48 89 5c 24 38       	mov    QWORD PTR [rsp+0x38],rbx
  41a536:	48 8d 84 24 84 00 00 	lea    rax,[rsp+0x84]
  41a53d:	00 
  41a53e:	44 89 64 24 5c       	mov    DWORD PTR [rsp+0x5c],r12d
  41a543:	48 89 d3             	mov    rbx,rdx
  41a546:	4d 89 f4             	mov    r12,r14
  41a549:	44 89 5c 24 08       	mov    DWORD PTR [rsp+0x8],r11d
  41a54e:	4d 89 ee             	mov    r14,r13
  41a551:	49 89 ed             	mov    r13,rbp
  41a554:	44 89 4c 24 60       	mov    DWORD PTR [rsp+0x60],r9d
  41a559:	48 89 c5             	mov    rbp,rax
  41a55c:	eb 3a                	jmp    41a598 <printf_core+0xde8>
  41a55e:	66 90                	xchg   ax,ax
  41a560:	4c 8b 7c 24 18       	mov    r15,QWORD PTR [rsp+0x18]
  41a565:	49 83 c4 04          	add    r12,0x4
  41a569:	48 89 ef             	mov    rdi,rbp
  41a56c:	48 b8 e0 e0 fb ff ff 	movabs rax,0xfffffffffffbe0e0
  41a573:	ff ff ff 
  41a576:	4c 01 f8             	add    rax,r15
  41a579:	ff d0                	call   rax
  41a57b:	85 c0                	test   eax,eax
  41a57d:	0f 88 a9 06 00 00    	js     41ac2c <printf_core+0x147c>
  41a583:	48 89 de             	mov    rsi,rbx
  41a586:	48 98                	cdqe   
  41a588:	4c 29 ee             	sub    rsi,r13
  41a58b:	48 39 f0             	cmp    rax,rsi
  41a58e:	77 10                	ja     41a5a0 <printf_core+0xdf0>
  41a590:	49 01 c5             	add    r13,rax
  41a593:	49 39 dd             	cmp    r13,rbx
  41a596:	73 08                	jae    41a5a0 <printf_core+0xdf0>
  41a598:	41 8b 34 24          	mov    esi,DWORD PTR [r12]
  41a59c:	85 f6                	test   esi,esi
  41a59e:	75 c0                	jne    41a560 <printf_core+0xdb0>
  41a5a0:	4c 89 ed             	mov    rbp,r13
  41a5a3:	44 8b 5c 24 08       	mov    r11d,DWORD PTR [rsp+0x8]
  41a5a8:	48 8b 5c 24 38       	mov    rbx,QWORD PTR [rsp+0x38]
  41a5ad:	4d 89 f5             	mov    r13,r14
			if (i > INT_MAX) goto overflow;
  41a5b0:	44 8b 64 24 5c       	mov    r12d,DWORD PTR [rsp+0x5c]
  41a5b5:	44 8b 4c 24 60       	mov    r9d,DWORD PTR [rsp+0x60]
  41a5ba:	48 81 fd ff ff ff 7f 	cmp    rbp,0x7fffffff
  41a5c1:	0f 87 22 f6 ff ff    	ja     419be9 <printf_core+0x439>
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41a5c7:	41 39 e9             	cmp    r9d,ebp
			p = i;
  41a5ca:	89 6c 24 08          	mov    DWORD PTR [rsp+0x8],ebp
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41a5ce:	0f 9e 44 24 38       	setle  BYTE PTR [rsp+0x38]
  41a5d3:	0f b6 44 24 38       	movzx  eax,BYTE PTR [rsp+0x38]
  41a5d8:	41 f7 c4 00 20 01 00 	test   r12d,0x12000
  41a5df:	0f 85 c0 00 00 00    	jne    41a6a5 <printf_core+0xef5>
  41a5e5:	84 c0                	test   al,al
  41a5e7:	0f 85 b8 00 00 00    	jne    41a6a5 <printf_core+0xef5>
	l = w - l;
  41a5ed:	44 89 c9             	mov    ecx,r9d
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41a5f0:	b8 00 01 00 00       	mov    eax,0x100
	l = w - l;
  41a5f5:	2b 4c 24 08          	sub    ecx,DWORD PTR [rsp+0x8]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41a5f9:	4c 8b 7c 24 18       	mov    r15,QWORD PTR [rsp+0x18]
  41a5fe:	39 c1                	cmp    ecx,eax
  41a600:	44 89 5c 24 60       	mov    DWORD PTR [rsp+0x60],r11d
  41a605:	be 20 00 00 00       	mov    esi,0x20
  41a60a:	4c 8d b4 24 d0 00 00 	lea    r14,[rsp+0xd0]
  41a611:	00 
  41a612:	0f 4e c1             	cmovle eax,ecx
	l = w - l;
  41a615:	44 89 4c 24 5c       	mov    DWORD PTR [rsp+0x5c],r9d
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41a61a:	4c 89 f7             	mov    rdi,r14
  41a61d:	89 4c 24 38          	mov    DWORD PTR [rsp+0x38],ecx
  41a621:	48 63 d0             	movsxd rdx,eax
  41a624:	48 b8 7c 79 fb ff ff 	movabs rax,0xfffffffffffb797c
  41a62b:	ff ff ff 
  41a62e:	4c 01 f8             	add    rax,r15
  41a631:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  41a633:	8b 4c 24 38          	mov    ecx,DWORD PTR [rsp+0x38]
  41a637:	44 8b 4c 24 5c       	mov    r9d,DWORD PTR [rsp+0x5c]
  41a63c:	44 8b 5c 24 60       	mov    r11d,DWORD PTR [rsp+0x60]
  41a641:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  41a647:	0f 8e ef 07 00 00    	jle    41ae3c <printf_core+0x168c>
  41a64d:	44 8d 81 00 ff ff ff 	lea    r8d,[rcx-0x100]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a654:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
  41a658:	45 89 c7             	mov    r15d,r8d
  41a65b:	83 e0 20             	and    eax,0x20
  41a65e:	0f 84 78 03 00 00    	je     41a9dc <printf_core+0x122c>
	for (; l >= sizeof pad; l -= sizeof pad)
  41a664:	45 89 f8             	mov    r8d,r15d
  41a667:	41 81 ff ff 00 00 00 	cmp    r15d,0xff
  41a66e:	7e 30                	jle    41a6a0 <printf_core+0xef0>
  41a670:	41 8d 90 00 e9 ff ff 	lea    edx,[r8-0x1700]
  41a677:	81 fa 00 e9 ff 7f    	cmp    edx,0x7fffe900
  41a67d:	0f 86 43 ee ff ff    	jbe    4194c6 <printf_core.cold+0x19b>
  41a683:	41 81 e8 00 01 00 00 	sub    r8d,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a68a:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  41a68c:	44 89 c1             	mov    ecx,r8d
  41a68f:	41 81 f8 ff 00 00 00 	cmp    r8d,0xff
  41a696:	77 eb                	ja     41a683 <printf_core+0xed3>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a698:	85 d2                	test   edx,edx
  41a69a:	0f 84 35 06 00 00    	je     41acd5 <printf_core+0x1525>
  41a6a0:	c6 44 24 38 00       	mov    BYTE PTR [rsp+0x38],0x0
			for (i=0; i<0U+p && *ws && i+(l=wctomb(mb, *ws++))<=p; i+=l)
  41a6a5:	45 31 f6             	xor    r14d,r14d
  41a6a8:	48 85 ed             	test   rbp,rbp
  41a6ab:	0f 84 92 03 00 00    	je     41aa43 <printf_core+0x1293>
  41a6b1:	48 89 5c 24 60       	mov    QWORD PTR [rsp+0x60],rbx
  41a6b6:	4c 89 f3             	mov    rbx,r14
  41a6b9:	49 89 ee             	mov    r14,rbp
  41a6bc:	48 8b 6c 24 50       	mov    rbp,QWORD PTR [rsp+0x50]
  41a6c1:	44 89 5c 24 5c       	mov    DWORD PTR [rsp+0x5c],r11d
  41a6c6:	44 89 64 24 68       	mov    DWORD PTR [rsp+0x68],r12d
  41a6cb:	44 89 4c 24 50       	mov    DWORD PTR [rsp+0x50],r9d
  41a6d0:	eb 0f                	jmp    41a6e1 <printf_core+0xf31>
  41a6d2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  41a6d8:	4c 39 f3             	cmp    rbx,r14
  41a6db:	0f 83 4e 03 00 00    	jae    41aa2f <printf_core+0x127f>
  41a6e1:	8b 75 00             	mov    esi,DWORD PTR [rbp+0x0]
  41a6e4:	85 f6                	test   esi,esi
  41a6e6:	0f 84 43 03 00 00    	je     41aa2f <printf_core+0x127f>
  41a6ec:	4c 8b 7c 24 18       	mov    r15,QWORD PTR [rsp+0x18]
  41a6f1:	4c 8d a4 24 84 00 00 	lea    r12,[rsp+0x84]
  41a6f8:	00 
  41a6f9:	48 83 c5 04          	add    rbp,0x4
  41a6fd:	48 b8 e0 e0 fb ff ff 	movabs rax,0xfffffffffffbe0e0
  41a704:	ff ff ff 
  41a707:	4c 89 e7             	mov    rdi,r12
  41a70a:	4c 01 f8             	add    rax,r15
  41a70d:	ff d0                	call   rax
  41a70f:	48 63 f0             	movsxd rsi,eax
  41a712:	48 01 f3             	add    rbx,rsi
  41a715:	4c 39 f3             	cmp    rbx,r14
  41a718:	0f 87 11 03 00 00    	ja     41aa2f <printf_core+0x127f>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a71e:	41 f6 45 00 20       	test   BYTE PTR [r13+0x0],0x20
  41a723:	75 b3                	jne    41a6d8 <printf_core+0xf28>
  41a725:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  41a72a:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  41a72f:	4c 89 ea             	mov    rdx,r13
  41a732:	4c 89 e7             	mov    rdi,r12
  41a735:	48 01 c8             	add    rax,rcx
  41a738:	ff d0                	call   rax
  41a73a:	eb 9c                	jmp    41a6d8 <printf_core+0xf28>
			wc[0] = arg.i;
  41a73c:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  41a743:	00 
			for (i=l=0; i<p && *ws && (l=wctomb(mb, *ws++))>=0 && l<=p-i; i+=l);
  41a744:	48 c7 c2 ff ff ff ff 	mov    rdx,0xffffffffffffffff
			wc[1] = 0;
  41a74b:	c7 84 24 8c 00 00 00 	mov    DWORD PTR [rsp+0x8c],0x0
  41a752:	00 00 00 00 
			wc[0] = arg.i;
  41a756:	89 84 24 88 00 00 00 	mov    DWORD PTR [rsp+0x88],eax
			arg.p = wc;
  41a75d:	48 8d 84 24 88 00 00 	lea    rax,[rsp+0x88]
  41a764:	00 
  41a765:	48 89 84 24 90 00 00 	mov    QWORD PTR [rsp+0x90],rax
  41a76c:	00 
			ws = arg.p;
  41a76d:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
  41a772:	e9 b3 fd ff ff       	jmp    41a52a <printf_core+0xd7a>
			if (1) a = strerror(errno); else
  41a777:	4c 8b 7c 24 18       	mov    r15,QWORD PTR [rsp+0x18]
  41a77c:	44 89 4c 24 38       	mov    DWORD PTR [rsp+0x38],r9d
  41a781:	48 b8 f0 8c fb ff ff 	movabs rax,0xfffffffffffb8cf0
  41a788:	ff ff ff 
  41a78b:	44 89 5c 24 08       	mov    DWORD PTR [rsp+0x8],r11d
  41a790:	4c 01 f8             	add    rax,r15
  41a793:	ff d0                	call   rax
  41a795:	8b 38                	mov    edi,DWORD PTR [rax]
  41a797:	48 b8 60 de fb ff ff 	movabs rax,0xfffffffffffbde60
  41a79e:	ff ff ff 
  41a7a1:	4c 01 f8             	add    rax,r15
  41a7a4:	ff d0                	call   rax
  41a7a6:	44 8b 5c 24 08       	mov    r11d,DWORD PTR [rsp+0x8]
  41a7ab:	44 8b 4c 24 38       	mov    r9d,DWORD PTR [rsp+0x38]
  41a7b0:	49 89 c0             	mov    r8,rax
  41a7b3:	e9 fb fc ff ff       	jmp    41a4b3 <printf_core+0xd03>
			switch(ps) {
  41a7b8:	41 83 ff 07          	cmp    r15d,0x7
  41a7bc:	0f 87 e5 f0 ff ff    	ja     4198a7 <printf_core+0xf7>
  41a7c2:	48 8d 15 8f 4c 00 00 	lea    rdx,[rip+0x4c8f]        # 41f458 <CSWTCH.186+0x9e8>
  41a7c9:	48 03 14 c2          	add    rdx,QWORD PTR [rdx+rax*8]
  41a7cd:	3e ff e2             	notrack jmp rdx
			case JPRE: *(uintmax_t *)arg.p = cnt; break;
  41a7d0:	48 63 44 24 14       	movsxd rax,DWORD PTR [rsp+0x14]
  41a7d5:	48 8b 94 24 90 00 00 	mov    rdx,QWORD PTR [rsp+0x90]
  41a7dc:	00 
  41a7dd:	48 89 02             	mov    QWORD PTR [rdx],rax
  41a7e0:	e9 cd f0 ff ff       	jmp    4198b2 <printf_core+0x102>
		switch(t) {
  41a7e5:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  41a7ea:	44 89 74 24 60       	mov    DWORD PTR [rsp+0x60],r14d
  41a7ef:	48 b8 75 1e fc ff ff 	movabs rax,0xfffffffffffc1e75
  41a7f6:	ff ff ff 
  41a7f9:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  41a800:	00 
  41a801:	48 01 d0             	add    rax,rdx
  41a804:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  41a809:	e9 66 fa ff ff       	jmp    41a274 <printf_core+0xac4>
			case BARE: *(int *)arg.p = cnt; break;
  41a80e:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  41a815:	00 
  41a816:	8b 54 24 14          	mov    edx,DWORD PTR [rsp+0x14]
  41a81a:	89 10                	mov    DWORD PTR [rax],edx
  41a81c:	e9 91 f0 ff ff       	jmp    4198b2 <printf_core+0x102>
			case HPRE: *(unsigned short *)arg.p = cnt; break;
  41a821:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  41a828:	00 
  41a829:	0f b7 54 24 14       	movzx  edx,WORD PTR [rsp+0x14]
  41a82e:	66 89 10             	mov    WORD PTR [rax],dx
  41a831:	e9 7c f0 ff ff       	jmp    4198b2 <printf_core+0x102>
			case HHPRE: *(unsigned char *)arg.p = cnt; break;
  41a836:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  41a83d:	00 
  41a83e:	0f b6 54 24 14       	movzx  edx,BYTE PTR [rsp+0x14]
  41a843:	88 10                	mov    BYTE PTR [rax],dl
  41a845:	e9 68 f0 ff ff       	jmp    4198b2 <printf_core+0x102>
  41a84a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a850:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  41a855:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  41a85a:	4c 89 ea             	mov    rdx,r13
  41a85d:	4c 89 f7             	mov    rdi,r14
  41a860:	be 00 01 00 00       	mov    esi,0x100
  41a865:	48 01 c8             	add    rax,rcx
  41a868:	ff d0                	call   rax
  41a86a:	41 8b 55 00          	mov    edx,DWORD PTR [r13+0x0]
  41a86e:	89 d0                	mov    eax,edx
  41a870:	83 e0 20             	and    eax,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41a873:	41 81 ff ff 00 00 00 	cmp    r15d,0xff
  41a87a:	0f 8e e9 00 00 00    	jle    41a969 <printf_core+0x11b9>
  41a880:	41 81 ef 00 01 00 00 	sub    r15d,0x100
  41a887:	e9 1f f8 ff ff       	jmp    41a0ab <printf_core+0x8fb>
  41a88c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a890:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  41a895:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  41a89a:	4c 89 ea             	mov    rdx,r13
  41a89d:	4c 89 f7             	mov    rdi,r14
  41a8a0:	4c 89 44 24 60       	mov    QWORD PTR [rsp+0x60],r8
  41a8a5:	be 00 01 00 00       	mov    esi,0x100
  41a8aa:	48 01 c8             	add    rax,rcx
  41a8ad:	ff d0                	call   rax
  41a8af:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
	for (; l >= sizeof pad; l -= sizeof pad)
  41a8b3:	4c 8b 44 24 60       	mov    r8,QWORD PTR [rsp+0x60]
  41a8b8:	44 89 f9             	mov    ecx,r15d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a8bb:	89 c2                	mov    edx,eax
  41a8bd:	83 e2 20             	and    edx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41a8c0:	41 81 ff ff 00 00 00 	cmp    r15d,0xff
  41a8c7:	0f 8e 51 f7 ff ff    	jle    41a01e <printf_core+0x86e>
  41a8cd:	41 81 ef 00 01 00 00 	sub    r15d,0x100
  41a8d4:	e9 0b f7 ff ff       	jmp    419fe4 <printf_core+0x834>
  41a8d9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a8e0:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  41a8e5:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  41a8ea:	4c 89 ea             	mov    rdx,r13
  41a8ed:	4c 89 f7             	mov    rdi,r14
  41a8f0:	be 00 01 00 00       	mov    esi,0x100
	for (; l >= sizeof pad; l -= sizeof pad)
  41a8f5:	41 89 ec             	mov    r12d,ebp
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a8f8:	48 01 c8             	add    rax,rcx
  41a8fb:	ff d0                	call   rax
  41a8fd:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
  41a901:	89 c2                	mov    edx,eax
  41a903:	83 e2 20             	and    edx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41a906:	81 fd ff 00 00 00    	cmp    ebp,0xff
  41a90c:	0f 8e 98 f8 ff ff    	jle    41a1aa <printf_core+0x9fa>
  41a912:	81 ed 00 01 00 00    	sub    ebp,0x100
  41a918:	e9 53 f8 ff ff       	jmp    41a170 <printf_core+0x9c0>
  41a91d:	0f 1f 00             	nop    DWORD PTR [rax]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a920:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  41a925:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  41a92a:	4c 89 ea             	mov    rdx,r13
  41a92d:	4c 89 f7             	mov    rdi,r14
  41a930:	4c 89 44 24 68       	mov    QWORD PTR [rsp+0x68],r8
  41a935:	be 00 01 00 00       	mov    esi,0x100
  41a93a:	48 01 c8             	add    rax,rcx
  41a93d:	ff d0                	call   rax
  41a93f:	41 8b 55 00          	mov    edx,DWORD PTR [r13+0x0]
	for (; l >= sizeof pad; l -= sizeof pad)
  41a943:	4c 8b 44 24 68       	mov    r8,QWORD PTR [rsp+0x68]
  41a948:	44 89 f9             	mov    ecx,r15d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a94b:	89 d0                	mov    eax,edx
  41a94d:	83 e0 20             	and    eax,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41a950:	41 81 ff ff 00 00 00 	cmp    r15d,0xff
  41a957:	0f 8e d2 f5 ff ff    	jle    419f2f <printf_core+0x77f>
  41a95d:	41 81 ef 00 01 00 00 	sub    r15d,0x100
  41a964:	e9 88 f5 ff ff       	jmp    419ef1 <printf_core+0x741>
  41a969:	49 89 e8             	mov    r8,rbp
  41a96c:	44 89 fd             	mov    ebp,r15d
  41a96f:	e9 7c f7 ff ff       	jmp    41a0f0 <printf_core+0x940>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a974:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
  41a978:	83 e0 20             	and    eax,0x20
  41a97b:	85 c0                	test   eax,eax
  41a97d:	0f 85 e1 f5 ff ff    	jne    419f64 <printf_core+0x7b4>
  41a983:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  41a988:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  41a98d:	4c 89 44 24 68       	mov    QWORD PTR [rsp+0x68],r8
  41a992:	4c 89 ea             	mov    rdx,r13
		out(f, prefix, pl);
  41a995:	48 63 74 24 60       	movsxd rsi,DWORD PTR [rsp+0x60]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a99a:	48 8b 7c 24 70       	mov    rdi,QWORD PTR [rsp+0x70]
  41a99f:	48 01 c8             	add    rax,rcx
  41a9a2:	ff d0                	call   rax
  41a9a4:	4c 8b 44 24 68       	mov    r8,QWORD PTR [rsp+0x68]
  41a9a9:	e9 b6 f5 ff ff       	jmp    419f64 <printf_core+0x7b4>
  41a9ae:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
  41a9b2:	83 e0 20             	and    eax,0x20
  41a9b5:	85 c0                	test   eax,eax
  41a9b7:	0f 85 3b f7 ff ff    	jne    41a0f8 <printf_core+0x948>
  41a9bd:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  41a9c2:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  41a9c7:	4c 89 ea             	mov    rdx,r13
  41a9ca:	4c 89 c7             	mov    rdi,r8
  41a9cd:	48 8b 74 24 50       	mov    rsi,QWORD PTR [rsp+0x50]
  41a9d2:	48 01 c8             	add    rax,rcx
  41a9d5:	ff d0                	call   rax
  41a9d7:	e9 1c f7 ff ff       	jmp    41a0f8 <printf_core+0x948>
  41a9dc:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  41a9e1:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  41a9e6:	4c 89 ea             	mov    rdx,r13
  41a9e9:	4c 89 f7             	mov    rdi,r14
  41a9ec:	44 89 4c 24 5c       	mov    DWORD PTR [rsp+0x5c],r9d
  41a9f1:	be 00 01 00 00       	mov    esi,0x100
  41a9f6:	48 01 c8             	add    rax,rcx
  41a9f9:	44 89 5c 24 38       	mov    DWORD PTR [rsp+0x38],r11d
  41a9fe:	ff d0                	call   rax
  41aa00:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
	for (; l >= sizeof pad; l -= sizeof pad)
  41aa04:	44 8b 5c 24 38       	mov    r11d,DWORD PTR [rsp+0x38]
  41aa09:	44 89 f9             	mov    ecx,r15d
  41aa0c:	44 8b 4c 24 5c       	mov    r9d,DWORD PTR [rsp+0x5c]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41aa11:	89 c2                	mov    edx,eax
  41aa13:	83 e2 20             	and    edx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41aa16:	41 81 ff ff 00 00 00 	cmp    r15d,0xff
  41aa1d:	0f 8e 75 fc ff ff    	jle    41a698 <printf_core+0xee8>
  41aa23:	41 81 ef 00 01 00 00 	sub    r15d,0x100
  41aa2a:	e9 2c fc ff ff       	jmp    41a65b <printf_core+0xeab>
  41aa2f:	44 8b 5c 24 5c       	mov    r11d,DWORD PTR [rsp+0x5c]
  41aa34:	48 8b 5c 24 60       	mov    rbx,QWORD PTR [rsp+0x60]
  41aa39:	44 8b 64 24 68       	mov    r12d,DWORD PTR [rsp+0x68]
  41aa3e:	44 8b 4c 24 50       	mov    r9d,DWORD PTR [rsp+0x50]
			pad(f, ' ', w, p, fl^LEFT_ADJ);
  41aa43:	41 81 f4 00 20 00 00 	xor    r12d,0x2000
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41aa4a:	41 81 e4 00 20 01 00 	and    r12d,0x12000
  41aa51:	0f 85 85 00 00 00    	jne    41aadc <printf_core+0x132c>
  41aa57:	80 7c 24 38 00       	cmp    BYTE PTR [rsp+0x38],0x0
  41aa5c:	75 7e                	jne    41aadc <printf_core+0x132c>
	l = w - l;
  41aa5e:	44 89 cd             	mov    ebp,r9d
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41aa61:	b8 00 01 00 00       	mov    eax,0x100
	l = w - l;
  41aa66:	2b 6c 24 08          	sub    ebp,DWORD PTR [rsp+0x8]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41aa6a:	4c 8b 7c 24 18       	mov    r15,QWORD PTR [rsp+0x18]
  41aa6f:	39 c5                	cmp    ebp,eax
  41aa71:	44 89 5c 24 50       	mov    DWORD PTR [rsp+0x50],r11d
  41aa76:	be 20 00 00 00       	mov    esi,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41aa7b:	41 89 ec             	mov    r12d,ebp
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41aa7e:	0f 4e c5             	cmovle eax,ebp
  41aa81:	4c 8d b4 24 d0 00 00 	lea    r14,[rsp+0xd0]
  41aa88:	00 
	l = w - l;
  41aa89:	44 89 4c 24 38       	mov    DWORD PTR [rsp+0x38],r9d
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41aa8e:	4c 89 f7             	mov    rdi,r14
  41aa91:	48 63 d0             	movsxd rdx,eax
  41aa94:	48 b8 7c 79 fb ff ff 	movabs rax,0xfffffffffffb797c
  41aa9b:	ff ff ff 
  41aa9e:	4c 01 f8             	add    rax,r15
  41aaa1:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  41aaa3:	81 fd ff 00 00 00    	cmp    ebp,0xff
  41aaa9:	44 8b 4c 24 38       	mov    r9d,DWORD PTR [rsp+0x38]
  41aaae:	44 8b 5c 24 50       	mov    r11d,DWORD PTR [rsp+0x50]
  41aab3:	0f 8e b5 03 00 00    	jle    41ae6e <printf_core+0x16be>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41aab9:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
  41aabd:	45 89 df             	mov    r15d,r11d
  41aac0:	83 e0 20             	and    eax,0x20
  41aac3:	74 2c                	je     41aaf1 <printf_core+0x1341>
	for (; l >= sizeof pad; l -= sizeof pad)
  41aac5:	41 8d 8c 24 00 ff ff 	lea    ecx,[r12-0x100]
  41aacc:	ff 
  41aacd:	45 89 fb             	mov    r11d,r15d
  41aad0:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  41aad6:	0f 87 0a e9 ff ff    	ja     4193e6 <printf_core.cold+0xbb>
			l = w>p ? w : p;
  41aadc:	8b 44 24 08          	mov    eax,DWORD PTR [rsp+0x8]
  41aae0:	44 39 c8             	cmp    eax,r9d
  41aae3:	44 0f 4d c8          	cmovge r9d,eax
  41aae7:	44 89 4c 24 08       	mov    DWORD PTR [rsp+0x8],r9d
			continue;
  41aaec:	e9 b6 ed ff ff       	jmp    4198a7 <printf_core+0xf7>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41aaf1:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  41aaf6:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  41aafb:	4c 89 ea             	mov    rdx,r13
  41aafe:	4c 89 f7             	mov    rdi,r14
  41ab01:	44 89 4c 24 38       	mov    DWORD PTR [rsp+0x38],r9d
  41ab06:	be 00 01 00 00       	mov    esi,0x100
	for (; l >= sizeof pad; l -= sizeof pad)
  41ab0b:	41 81 ec 00 01 00 00 	sub    r12d,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41ab12:	48 01 c8             	add    rax,rcx
	for (; l >= sizeof pad; l -= sizeof pad)
  41ab15:	44 89 e5             	mov    ebp,r12d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41ab18:	ff d0                	call   rax
  41ab1a:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
	for (; l >= sizeof pad; l -= sizeof pad)
  41ab1e:	44 8b 4c 24 38       	mov    r9d,DWORD PTR [rsp+0x38]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41ab23:	89 c2                	mov    edx,eax
  41ab25:	83 e2 20             	and    edx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41ab28:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  41ab2f:	77 8f                	ja     41aac0 <printf_core+0x1310>
  41ab31:	45 89 fb             	mov    r11d,r15d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41ab34:	85 d2                	test   edx,edx
  41ab36:	75 a4                	jne    41aadc <printf_core+0x132c>
  41ab38:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  41ab3d:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
	out(f, pad, l);
  41ab42:	48 63 f5             	movsxd rsi,ebp
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41ab45:	4c 89 ea             	mov    rdx,r13
  41ab48:	44 89 4c 24 50       	mov    DWORD PTR [rsp+0x50],r9d
  41ab4d:	4c 89 f7             	mov    rdi,r14
  41ab50:	44 89 5c 24 38       	mov    DWORD PTR [rsp+0x38],r11d
  41ab55:	48 01 c8             	add    rax,rcx
  41ab58:	ff d0                	call   rax
  41ab5a:	44 8b 4c 24 50       	mov    r9d,DWORD PTR [rsp+0x50]
  41ab5f:	44 8b 5c 24 38       	mov    r11d,DWORD PTR [rsp+0x38]
  41ab64:	e9 73 ff ff ff       	jmp    41aadc <printf_core+0x132c>
  41ab69:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  41ab6e:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
	out(f, pad, l);
  41ab73:	48 63 f5             	movsxd rsi,ebp
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41ab76:	4c 89 ea             	mov    rdx,r13
  41ab79:	4c 89 44 24 60       	mov    QWORD PTR [rsp+0x60],r8
  41ab7e:	4c 89 f7             	mov    rdi,r14
  41ab81:	48 01 c8             	add    rax,rcx
  41ab84:	ff d0                	call   rax
  41ab86:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
  41ab8a:	4c 8b 44 24 60       	mov    r8,QWORD PTR [rsp+0x60]
  41ab8f:	83 e0 20             	and    eax,0x20
  41ab92:	e9 1e fe ff ff       	jmp    41a9b5 <printf_core+0x1205>
  41ab97:	48 c7 44 24 50 00 00 	mov    QWORD PTR [rsp+0x50],0x0
  41ab9e:	00 00 
  41aba0:	8b 44 24 60          	mov    eax,DWORD PTR [rsp+0x60]
				a=z;
  41aba4:	4d 89 f8             	mov    r8,r15
  41aba7:	89 44 24 5c          	mov    DWORD PTR [rsp+0x5c],eax
  41abab:	e9 60 f8 ff ff       	jmp    41a410 <printf_core+0xc60>
		if (p < z-a) p = z-a;
  41abb0:	48 b8 75 1e fc ff ff 	movabs rax,0xfffffffffffc1e75
  41abb7:	ff ff ff 
  41abba:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  41abbf:	48 01 d0             	add    rax,rdx
  41abc2:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  41abc7:	e9 7f f2 ff ff       	jmp    419e4b <printf_core+0x69b>
			z = a + strnlen(a, p<0 ? INT_MAX : p);
  41abcc:	4c 8b 7c 24 18       	mov    r15,QWORD PTR [rsp+0x18]
  41abd1:	44 89 4c 24 50       	mov    DWORD PTR [rsp+0x50],r9d
  41abd6:	4c 89 c7             	mov    rdi,r8
  41abd9:	be ff ff ff 7f       	mov    esi,0x7fffffff
  41abde:	48 b8 c0 86 fb ff ff 	movabs rax,0xfffffffffffb86c0
  41abe5:	ff ff ff 
  41abe8:	44 89 5c 24 38       	mov    DWORD PTR [rsp+0x38],r11d
  41abed:	4c 89 44 24 08       	mov    QWORD PTR [rsp+0x8],r8
  41abf2:	4c 01 f8             	add    rax,r15
  41abf5:	ff d0                	call   rax
  41abf7:	4c 8b 44 24 08       	mov    r8,QWORD PTR [rsp+0x8]
			if (p<0 && *z) goto overflow;
  41abfc:	44 8b 5c 24 38       	mov    r11d,DWORD PTR [rsp+0x38]
			z = a + strnlen(a, p<0 ? INT_MAX : p);
  41ac01:	48 89 c5             	mov    rbp,rax
			if (p<0 && *z) goto overflow;
  41ac04:	44 8b 4c 24 50       	mov    r9d,DWORD PTR [rsp+0x50]
			z = a + strnlen(a, p<0 ? INT_MAX : p);
  41ac09:	49 8d 04 00          	lea    rax,[r8+rax*1]
			if (p<0 && *z) goto overflow;
  41ac0d:	80 38 00             	cmp    BYTE PTR [rax],0x0
  41ac10:	0f 84 e4 f8 ff ff    	je     41a4fa <printf_core+0xd4a>
  41ac16:	e9 ce ef ff ff       	jmp    419be9 <printf_core+0x439>
  41ac1b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41ac20:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
  41ac24:	83 e0 20             	and    eax,0x20
  41ac27:	e9 c4 f4 ff ff       	jmp    41a0f0 <printf_core+0x940>
			if (l<0) return -1;
  41ac2c:	c7 44 24 14 ff ff ff 	mov    DWORD PTR [rsp+0x14],0xffffffff
  41ac33:	ff 
  41ac34:	e9 77 ee ff ff       	jmp    419ab0 <printf_core+0x300>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41ac39:	41 8b 55 00          	mov    edx,DWORD PTR [r13+0x0]
  41ac3d:	83 e2 20             	and    edx,0x20
  41ac40:	e9 d9 f3 ff ff       	jmp    41a01e <printf_core+0x86e>
  41ac45:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
  41ac49:	83 e0 20             	and    eax,0x20
  41ac4c:	e9 de f2 ff ff       	jmp    419f2f <printf_core+0x77f>
  41ac51:	41 8b 55 00          	mov    edx,DWORD PTR [r13+0x0]
  41ac55:	83 e2 20             	and    edx,0x20
  41ac58:	e9 4d f5 ff ff       	jmp    41a1aa <printf_core+0x9fa>
		prefix = "-+   0X0x";
  41ac5d:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
				arg.i=-arg.i;
  41ac62:	48 f7 d9             	neg    rcx
		prefix = "-+   0X0x";
  41ac65:	48 b8 75 1e fc ff ff 	movabs rax,0xfffffffffffc1e75
  41ac6c:	ff ff ff 
			pl=1;
  41ac6f:	c7 44 24 60 01 00 00 	mov    DWORD PTR [rsp+0x60],0x1
  41ac76:	00 
				arg.i=-arg.i;
  41ac77:	48 89 8c 24 90 00 00 	mov    QWORD PTR [rsp+0x90],rcx
  41ac7e:	00 
		prefix = "-+   0X0x";
  41ac7f:	48 01 d0             	add    rax,rdx
  41ac82:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  41ac87:	e9 f1 f5 ff ff       	jmp    41a27d <printf_core+0xacd>
				prefix++;
  41ac8c:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
			pl=1;
  41ac91:	c7 44 24 60 01 00 00 	mov    DWORD PTR [rsp+0x60],0x1
  41ac98:	00 
				prefix++;
  41ac99:	48 b8 76 1e fc ff ff 	movabs rax,0xfffffffffffc1e76
  41aca0:	ff ff ff 
  41aca3:	48 01 d0             	add    rax,rdx
  41aca6:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  41acab:	e9 c4 f5 ff ff       	jmp    41a274 <printf_core+0xac4>
			else return 0;
  41acb0:	c7 44 24 14 00 00 00 	mov    DWORD PTR [rsp+0x14],0x0
  41acb7:	00 
  41acb8:	e9 f3 ed ff ff       	jmp    419ab0 <printf_core+0x300>
			a = arg.p ? arg.p : "(null)";
  41acbd:	48 b8 7f 1e fc ff ff 	movabs rax,0xfffffffffffc1e7f
  41acc4:	ff ff ff 
  41acc7:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  41accc:	4c 8d 04 02          	lea    r8,[rdx+rax*1]
  41acd0:	e9 de f7 ff ff       	jmp    41a4b3 <printf_core+0xd03>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41acd5:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
	out(f, pad, l);
  41acda:	48 63 f1             	movsxd rsi,ecx
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41acdd:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  41ace2:	4c 89 ea             	mov    rdx,r13
  41ace5:	44 89 4c 24 5c       	mov    DWORD PTR [rsp+0x5c],r9d
  41acea:	4c 89 f7             	mov    rdi,r14
  41aced:	44 89 5c 24 38       	mov    DWORD PTR [rsp+0x38],r11d
  41acf2:	48 01 c8             	add    rax,rcx
  41acf5:	ff d0                	call   rax
  41acf7:	44 8b 4c 24 5c       	mov    r9d,DWORD PTR [rsp+0x5c]
  41acfc:	44 8b 5c 24 38       	mov    r11d,DWORD PTR [rsp+0x38]
  41ad01:	e9 9a f9 ff ff       	jmp    41a6a0 <printf_core+0xef0>
		prefix = "-+   0X0x";
  41ad06:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
	for (; x; x>>=4) *--s = xdigits[(x&15)]|lower;
  41ad0b:	4c 8d bc 24 cb 00 00 	lea    r15,[rsp+0xcb]
  41ad12:	00 
		pl = 0;
  41ad13:	44 89 74 24 60       	mov    DWORD PTR [rsp+0x60],r14d
		prefix = "-+   0X0x";
  41ad18:	48 b8 75 1e fc ff ff 	movabs rax,0xfffffffffffc1e75
  41ad1f:	ff ff ff 
	for (; x; x>>=4) *--s = xdigits[(x&15)]|lower;
  41ad22:	4d 89 f8             	mov    r8,r15
		prefix = "-+   0X0x";
  41ad25:	48 01 d0             	add    rax,rdx
  41ad28:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  41ad2d:	e9 93 f5 ff ff       	jmp    41a2c5 <printf_core+0xb15>
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  41ad32:	4c 8d bc 24 cb 00 00 	lea    r15,[rsp+0xcb]
  41ad39:	00 
  41ad3a:	4d 89 f8             	mov    r8,r15
  41ad3d:	e9 83 f5 ff ff       	jmp    41a2c5 <printf_core+0xb15>
	for (; i<=NL_ARGMAX && !nl_type[i]; i++);
  41ad42:	49 8d 50 01          	lea    rdx,[r8+0x1]
  41ad46:	49 83 f8 09          	cmp    r8,0x9
  41ad4a:	0f 84 a1 f0 ff ff    	je     419df1 <printf_core+0x641>
  41ad50:	48 8b 7c 24 40       	mov    rdi,QWORD PTR [rsp+0x40]
  41ad55:	48 8d 04 95 00 00 00 	lea    rax,[rdx*4+0x0]
  41ad5c:	00 
  41ad5d:	8b 2c 97             	mov    ebp,DWORD PTR [rdi+rdx*4]
  41ad60:	85 ed                	test   ebp,ebp
  41ad62:	0f 85 26 ed ff ff    	jne    419a8e <printf_core+0x2de>
  41ad68:	49 83 f8 08          	cmp    r8,0x8
  41ad6c:	0f 84 7f f0 ff ff    	je     419df1 <printf_core+0x641>
  41ad72:	8b 5c 07 04          	mov    ebx,DWORD PTR [rdi+rax*1+0x4]
  41ad76:	85 db                	test   ebx,ebx
  41ad78:	0f 85 10 ed ff ff    	jne    419a8e <printf_core+0x2de>
  41ad7e:	49 83 f8 07          	cmp    r8,0x7
  41ad82:	0f 84 69 f0 ff ff    	je     419df1 <printf_core+0x641>
  41ad88:	44 8b 5c 07 08       	mov    r11d,DWORD PTR [rdi+rax*1+0x8]
  41ad8d:	45 85 db             	test   r11d,r11d
  41ad90:	0f 85 f8 ec ff ff    	jne    419a8e <printf_core+0x2de>
  41ad96:	49 83 f8 06          	cmp    r8,0x6
  41ad9a:	0f 84 51 f0 ff ff    	je     419df1 <printf_core+0x641>
  41ada0:	44 8b 54 07 0c       	mov    r10d,DWORD PTR [rdi+rax*1+0xc]
  41ada5:	45 85 d2             	test   r10d,r10d
  41ada8:	0f 85 e0 ec ff ff    	jne    419a8e <printf_core+0x2de>
  41adae:	49 83 f8 05          	cmp    r8,0x5
  41adb2:	0f 84 39 f0 ff ff    	je     419df1 <printf_core+0x641>
  41adb8:	44 8b 4c 07 10       	mov    r9d,DWORD PTR [rdi+rax*1+0x10]
  41adbd:	45 85 c9             	test   r9d,r9d
  41adc0:	0f 85 c8 ec ff ff    	jne    419a8e <printf_core+0x2de>
  41adc6:	49 83 f8 04          	cmp    r8,0x4
  41adca:	0f 84 21 f0 ff ff    	je     419df1 <printf_core+0x641>
  41add0:	8b 74 07 14          	mov    esi,DWORD PTR [rdi+rax*1+0x14]
  41add4:	85 f6                	test   esi,esi
  41add6:	0f 85 b2 ec ff ff    	jne    419a8e <printf_core+0x2de>
  41addc:	49 8d 50 07          	lea    rdx,[r8+0x7]
  41ade0:	49 83 f8 03          	cmp    r8,0x3
  41ade4:	0f 84 07 f0 ff ff    	je     419df1 <printf_core+0x641>
  41adea:	8b 4c 07 18          	mov    ecx,DWORD PTR [rdi+rax*1+0x18]
  41adee:	85 c9                	test   ecx,ecx
  41adf0:	0f 85 98 ec ff ff    	jne    419a8e <printf_core+0x2de>
  41adf6:	48 83 fa 08          	cmp    rdx,0x8
  41adfa:	0f 85 f1 ef ff ff    	jne    419df1 <printf_core+0x641>
  41ae00:	8b 44 07 1c          	mov    eax,DWORD PTR [rdi+rax*1+0x1c]
  41ae04:	85 c0                	test   eax,eax
  41ae06:	0f 84 e5 ef ff ff    	je     419df1 <printf_core+0x641>
  41ae0c:	e9 7d ec ff ff       	jmp    419a8e <printf_core+0x2de>
  41ae11:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
				prefix+=2;
  41ae18:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
			pl=1;
  41ae1d:	c7 44 24 60 01 00 00 	mov    DWORD PTR [rsp+0x60],0x1
  41ae24:	00 
				prefix+=2;
  41ae25:	48 b8 77 1e fc ff ff 	movabs rax,0xfffffffffffc1e77
  41ae2c:	ff ff ff 
  41ae2f:	48 01 d0             	add    rax,rdx
  41ae32:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  41ae37:	e9 38 f4 ff ff       	jmp    41a274 <printf_core+0xac4>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41ae3c:	41 8b 55 00          	mov    edx,DWORD PTR [r13+0x0]
  41ae40:	83 e2 20             	and    edx,0x20
  41ae43:	e9 50 f8 ff ff       	jmp    41a698 <printf_core+0xee8>
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41ae48:	45 85 c9             	test   r9d,r9d
  41ae4b:	0f 9e c0             	setle  al
  41ae4e:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  41ae52:	41 f7 c4 00 20 01 00 	test   r12d,0x12000
  41ae59:	0f 85 e4 fb ff ff    	jne    41aa43 <printf_core+0x1293>
			for (i=l=0; i<p && *ws && (l=wctomb(mb, *ws++))>=0 && l<=p-i; i+=l);
  41ae5f:	31 ed                	xor    ebp,ebp
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41ae61:	84 c0                	test   al,al
  41ae63:	0f 84 84 f7 ff ff    	je     41a5ed <printf_core+0xe3d>
  41ae69:	e9 d5 fb ff ff       	jmp    41aa43 <printf_core+0x1293>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41ae6e:	41 8b 55 00          	mov    edx,DWORD PTR [r13+0x0]
  41ae72:	83 e2 20             	and    edx,0x20
  41ae75:	e9 ba fc ff ff       	jmp    41ab34 <printf_core+0x1384>
  41ae7a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000041ae80 <vfprintf>:

int vfprintf(FILE *restrict f, const char *restrict fmt, va_list ap)
{
  41ae80:	f3 0f 1e fa          	endbr64 
  41ae84:	41 57                	push   r15
	va_list ap2;
	int nl_type[NL_ARGMAX+1] = {0};
  41ae86:	66 0f ef c0          	pxor   xmm0,xmm0
  41ae8a:	49 bb 8c 25 04 00 00 	movabs r11,0x4258c
  41ae91:	00 00 00 
{
  41ae94:	41 56                	push   r14
  41ae96:	49 89 f6             	mov    r14,rsi
  41ae99:	41 55                	push   r13
  41ae9b:	41 54                	push   r12
  41ae9d:	55                   	push   rbp
  41ae9e:	48 89 fd             	mov    rbp,rdi
	int olderr;
	int ret;

	/* the copy allows passing va_list* even if va_list is an array */
	va_copy(ap2, ap);
	if (printf_core(0, fmt, &ap2, nl_arg, nl_type) < 0) {
  41aea1:	31 ff                	xor    edi,edi
{
  41aea3:	53                   	push   rbx
  41aea4:	48 8d 1d d9 ff ff ff 	lea    rbx,[rip+0xffffffffffffffd9]        # 41ae84 <vfprintf+0x4>
  41aeab:	4c 01 db             	add    rbx,r11
  41aeae:	48 81 ec 78 01 00 00 	sub    rsp,0x178
	int nl_type[NL_ARGMAX+1] = {0};
  41aeb5:	0f 29 44 24 50       	movaps XMMWORD PTR [rsp+0x50],xmm0
	va_copy(ap2, ap);
  41aeba:	4c 8d 7c 24 38       	lea    r15,[rsp+0x38]
	if (printf_core(0, fmt, &ap2, nl_arg, nl_type) < 0) {
  41aebf:	4c 8d 44 24 50       	lea    r8,[rsp+0x50]
	int nl_type[NL_ARGMAX+1] = {0};
  41aec4:	0f 29 44 24 60       	movaps XMMWORD PTR [rsp+0x60],xmm0
	if (printf_core(0, fmt, &ap2, nl_arg, nl_type) < 0) {
  41aec9:	48 8d 8c 24 d0 00 00 	lea    rcx,[rsp+0xd0]
  41aed0:	00 
	int nl_type[NL_ARGMAX+1] = {0};
  41aed1:	48 c7 44 24 70 00 00 	mov    QWORD PTR [rsp+0x70],0x0
  41aed8:	00 00 
	va_copy(ap2, ap);
  41aeda:	f3 0f 6f 0a          	movdqu xmm1,XMMWORD PTR [rdx]
  41aede:	0f 11 4c 24 38       	movups XMMWORD PTR [rsp+0x38],xmm1
  41aee3:	48 8b 42 10          	mov    rax,QWORD PTR [rdx+0x10]
	if (printf_core(0, fmt, &ap2, nl_arg, nl_type) < 0) {
  41aee7:	4c 89 fa             	mov    rdx,r15
  41aeea:	4c 89 44 24 18       	mov    QWORD PTR [rsp+0x18],r8
	va_copy(ap2, ap);
  41aeef:	48 89 44 24 48       	mov    QWORD PTR [rsp+0x48],rax
	if (printf_core(0, fmt, &ap2, nl_arg, nl_type) < 0) {
  41aef4:	48 b8 a0 c3 fb ff ff 	movabs rax,0xfffffffffffbc3a0
  41aefb:	ff ff ff 
  41aefe:	48 89 44 24 20       	mov    QWORD PTR [rsp+0x20],rax
  41af03:	48 01 d8             	add    rax,rbx
  41af06:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  41af0b:	ff d0                	call   rax
  41af0d:	85 c0                	test   eax,eax
  41af0f:	0f 88 8a 01 00 00    	js     41b09f <vfprintf+0x21f>
		va_end(ap2);
		return -1;
	}

	FLOCK(f);
  41af15:	8b 85 8c 00 00 00    	mov    eax,DWORD PTR [rbp+0x8c]
  41af1b:	c7 44 24 0c 00 00 00 	mov    DWORD PTR [rsp+0xc],0x0
  41af22:	00 
  41af23:	48 8b 4c 24 10       	mov    rcx,QWORD PTR [rsp+0x10]
  41af28:	4c 8b 44 24 18       	mov    r8,QWORD PTR [rsp+0x18]
  41af2d:	85 c0                	test   eax,eax
  41af2f:	78 2a                	js     41af5b <vfprintf+0xdb>
  41af31:	48 b8 20 e1 fb ff ff 	movabs rax,0xfffffffffffbe120
  41af38:	ff ff ff 
  41af3b:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
  41af40:	48 89 ef             	mov    rdi,rbp
  41af43:	4c 89 44 24 10       	mov    QWORD PTR [rsp+0x10],r8
  41af48:	48 01 d8             	add    rax,rbx
  41af4b:	ff d0                	call   rax
  41af4d:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  41af52:	4c 8b 44 24 10       	mov    r8,QWORD PTR [rsp+0x10]
  41af57:	89 44 24 0c          	mov    DWORD PTR [rsp+0xc],eax
	olderr = f->flags & F_ERR;
  41af5b:	8b 45 00             	mov    eax,DWORD PTR [rbp+0x0]
	if (f->mode < 1) f->flags &= ~F_ERR;
  41af5e:	8b 95 88 00 00 00    	mov    edx,DWORD PTR [rbp+0x88]
	olderr = f->flags & F_ERR;
  41af64:	89 c6                	mov    esi,eax
  41af66:	83 e6 20             	and    esi,0x20
  41af69:	89 74 24 10          	mov    DWORD PTR [rsp+0x10],esi
	if (f->mode < 1) f->flags &= ~F_ERR;
  41af6d:	85 d2                	test   edx,edx
  41af6f:	7f 06                	jg     41af77 <vfprintf+0xf7>
  41af71:	83 e0 df             	and    eax,0xffffffdf
  41af74:	89 45 00             	mov    DWORD PTR [rbp+0x0],eax
	if (!f->buf_size) {
  41af77:	48 83 7d 60 00       	cmp    QWORD PTR [rbp+0x60],0x0
  41af7c:	0f 84 9e 00 00 00    	je     41b020 <vfprintf+0x1a0>
		saved_buf = f->buf;
		f->buf = internal_buf;
		f->buf_size = sizeof internal_buf;
		f->wpos = f->wbase = f->wend = 0;
	}
	if (!f->wend && __towrite(f)) ret = -1;
  41af82:	4c 8b 6d 20          	mov    r13,QWORD PTR [rbp+0x20]
  41af86:	4d 85 ed             	test   r13,r13
  41af89:	0f 84 1b 01 00 00    	je     41b0aa <vfprintf+0x22a>
	unsigned char internal_buf[80], *saved_buf = 0;
  41af8f:	45 31 ed             	xor    r13d,r13d
	else ret = printf_core(f, fmt, &ap2, nl_arg, nl_type);
  41af92:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  41af97:	4c 89 fa             	mov    rdx,r15
  41af9a:	4c 89 f6             	mov    rsi,r14
  41af9d:	48 89 ef             	mov    rdi,rbp
  41afa0:	48 01 d8             	add    rax,rbx
  41afa3:	ff d0                	call   rax
  41afa5:	41 89 c4             	mov    r12d,eax
	if (saved_buf) {
  41afa8:	4d 85 ed             	test   r13,r13
  41afab:	74 34                	je     41afe1 <vfprintf+0x161>
		f->write(f, 0, 0);
  41afad:	31 d2                	xor    edx,edx
  41afaf:	31 f6                	xor    esi,esi
  41afb1:	48 89 ef             	mov    rdi,rbp
  41afb4:	ff 55 48             	call   QWORD PTR [rbp+0x48]
		if (!f->wpos) ret = -1;
  41afb7:	48 83 7d 28 00       	cmp    QWORD PTR [rbp+0x28],0x0
		f->buf = saved_buf;
  41afbc:	4c 89 6d 58          	mov    QWORD PTR [rbp+0x58],r13
		f->buf_size = 0;
		f->wpos = f->wbase = f->wend = 0;
  41afc0:	66 0f ef c0          	pxor   xmm0,xmm0
		if (!f->wpos) ret = -1;
  41afc4:	b8 ff ff ff ff       	mov    eax,0xffffffff
		f->buf_size = 0;
  41afc9:	48 c7 45 60 00 00 00 	mov    QWORD PTR [rbp+0x60],0x0
  41afd0:	00 
		f->wpos = f->wbase = f->wend = 0;
  41afd1:	48 c7 45 38 00 00 00 	mov    QWORD PTR [rbp+0x38],0x0
  41afd8:	00 
		if (!f->wpos) ret = -1;
  41afd9:	44 0f 44 e0          	cmove  r12d,eax
		f->wpos = f->wbase = f->wend = 0;
  41afdd:	0f 11 45 20          	movups XMMWORD PTR [rbp+0x20],xmm0
	}
	if (f->flags & F_ERR) ret = -1;
  41afe1:	8b 45 00             	mov    eax,DWORD PTR [rbp+0x0]
	f->flags |= olderr;
  41afe4:	44 8b 6c 24 10       	mov    r13d,DWORD PTR [rsp+0x10]
	if (f->flags & F_ERR) ret = -1;
  41afe9:	ba ff ff ff ff       	mov    edx,0xffffffff
  41afee:	a8 20                	test   al,0x20
  41aff0:	44 0f 45 e2          	cmovne r12d,edx
	f->flags |= olderr;
  41aff4:	41 09 c5             	or     r13d,eax
	FUNLOCK(f);
  41aff7:	8b 44 24 0c          	mov    eax,DWORD PTR [rsp+0xc]
	f->flags |= olderr;
  41affb:	44 89 6d 00          	mov    DWORD PTR [rbp+0x0],r13d
	FUNLOCK(f);
  41afff:	85 c0                	test   eax,eax
  41b001:	0f 85 81 00 00 00    	jne    41b088 <vfprintf+0x208>
	va_end(ap2);
	return ret;
}
  41b007:	48 81 c4 78 01 00 00 	add    rsp,0x178
  41b00e:	44 89 e0             	mov    eax,r12d
  41b011:	5b                   	pop    rbx
  41b012:	5d                   	pop    rbp
  41b013:	41 5c                	pop    r12
  41b015:	41 5d                	pop    r13
  41b017:	41 5e                	pop    r14
  41b019:	41 5f                	pop    r15
  41b01b:	c3                   	ret    
  41b01c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		saved_buf = f->buf;
  41b020:	4c 8b 6d 58          	mov    r13,QWORD PTR [rbp+0x58]
		f->wpos = f->wbase = f->wend = 0;
  41b024:	66 0f ef c0          	pxor   xmm0,xmm0
  41b028:	48 89 4c 24 28       	mov    QWORD PTR [rsp+0x28],rcx
	if (!f->wend && __towrite(f)) ret = -1;
  41b02d:	48 89 ef             	mov    rdi,rbp
		f->buf = internal_buf;
  41b030:	48 8d 84 24 80 00 00 	lea    rax,[rsp+0x80]
  41b037:	00 
  41b038:	4c 89 44 24 18       	mov    QWORD PTR [rsp+0x18],r8
	if (!f->wend && __towrite(f)) ret = -1;
  41b03d:	41 bc ff ff ff ff    	mov    r12d,0xffffffff
		f->buf = internal_buf;
  41b043:	48 89 45 58          	mov    QWORD PTR [rbp+0x58],rax
	if (!f->wend && __towrite(f)) ret = -1;
  41b047:	48 b8 d0 e2 fb ff ff 	movabs rax,0xfffffffffffbe2d0
  41b04e:	ff ff ff 
		f->buf_size = sizeof internal_buf;
  41b051:	48 c7 45 60 50 00 00 	mov    QWORD PTR [rbp+0x60],0x50
  41b058:	00 
	if (!f->wend && __towrite(f)) ret = -1;
  41b059:	48 01 d8             	add    rax,rbx
		f->wpos = f->wbase = f->wend = 0;
  41b05c:	48 c7 45 38 00 00 00 	mov    QWORD PTR [rbp+0x38],0x0
  41b063:	00 
  41b064:	0f 11 45 20          	movups XMMWORD PTR [rbp+0x20],xmm0
	if (!f->wend && __towrite(f)) ret = -1;
  41b068:	ff d0                	call   rax
  41b06a:	85 c0                	test   eax,eax
  41b06c:	0f 85 36 ff ff ff    	jne    41afa8 <vfprintf+0x128>
  41b072:	4c 8b 44 24 18       	mov    r8,QWORD PTR [rsp+0x18]
  41b077:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  41b07c:	e9 11 ff ff ff       	jmp    41af92 <vfprintf+0x112>
  41b081:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	FUNLOCK(f);
  41b088:	48 b8 40 e2 fb ff ff 	movabs rax,0xfffffffffffbe240
  41b08f:	ff ff ff 
  41b092:	48 89 ef             	mov    rdi,rbp
  41b095:	48 01 d8             	add    rax,rbx
  41b098:	ff d0                	call   rax
	return ret;
  41b09a:	e9 68 ff ff ff       	jmp    41b007 <vfprintf+0x187>
		return -1;
  41b09f:	41 bc ff ff ff ff    	mov    r12d,0xffffffff
  41b0a5:	e9 5d ff ff ff       	jmp    41b007 <vfprintf+0x187>
  41b0aa:	48 89 4c 24 28       	mov    QWORD PTR [rsp+0x28],rcx
	if (!f->wend && __towrite(f)) ret = -1;
  41b0af:	48 89 ef             	mov    rdi,rbp
  41b0b2:	41 83 cc ff          	or     r12d,0xffffffff
  41b0b6:	48 b8 d0 e2 fb ff ff 	movabs rax,0xfffffffffffbe2d0
  41b0bd:	ff ff ff 
  41b0c0:	4c 89 44 24 18       	mov    QWORD PTR [rsp+0x18],r8
  41b0c5:	48 01 d8             	add    rax,rbx
  41b0c8:	ff d0                	call   rax
  41b0ca:	85 c0                	test   eax,eax
  41b0cc:	0f 85 0f ff ff ff    	jne    41afe1 <vfprintf+0x161>
  41b0d2:	eb 9e                	jmp    41b072 <vfprintf+0x1f2>
  41b0d4:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41b0db:	00 00 00 
  41b0de:	66 90                	xchg   ax,ax

000000000041b0e0 <memchr>:
#define ONES ((size_t)-1/UCHAR_MAX)
#define HIGHS (ONES * (UCHAR_MAX/2+1))
#define HASZERO(x) ((x)-ONES & ~(x) & HIGHS)

void *memchr(const void *src, int c, size_t n)
{
  41b0e0:	f3 0f 1e fa          	endbr64 
  41b0e4:	48 89 f8             	mov    rax,rdi
	const unsigned char *s = src;
	c = (unsigned char)c;
  41b0e7:	44 0f b6 d6          	movzx  r10d,sil
#ifdef __GNUC__
	for (; ((uintptr_t)s & ALIGN) && n && *s != c; s++, n--);
  41b0eb:	a8 07                	test   al,0x7
  41b0ed:	75 21                	jne    41b110 <memchr+0x30>
  41b0ef:	eb 2f                	jmp    41b120 <memchr+0x40>
  41b0f1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  41b0f8:	0f b6 08             	movzx  ecx,BYTE PTR [rax]
  41b0fb:	44 39 d1             	cmp    ecx,r10d
  41b0fe:	0f 84 7f 00 00 00    	je     41b183 <memchr+0xa3>
  41b104:	48 83 c0 01          	add    rax,0x1
  41b108:	48 83 ea 01          	sub    rdx,0x1
  41b10c:	a8 07                	test   al,0x7
  41b10e:	74 10                	je     41b120 <memchr+0x40>
  41b110:	48 85 d2             	test   rdx,rdx
  41b113:	75 e3                	jne    41b0f8 <memchr+0x18>
		for (w = (const void *)s; n>=SS && !HASZERO(*w^k); w++, n-=SS);
		s = (const void *)w;
	}
#endif
	for (; n && *s != c; s++, n--);
	return n ? (void *)s : 0;
  41b115:	45 31 c0             	xor    r8d,r8d
}
  41b118:	4c 89 c0             	mov    rax,r8
  41b11b:	c3                   	ret    
  41b11c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	return n ? (void *)s : 0;
  41b120:	45 31 c0             	xor    r8d,r8d
	if (n && *s != c) {
  41b123:	48 85 d2             	test   rdx,rdx
  41b126:	74 f0                	je     41b118 <memchr+0x38>
  41b128:	0f b6 08             	movzx  ecx,BYTE PTR [rax]
  41b12b:	44 39 d1             	cmp    ecx,r10d
  41b12e:	74 53                	je     41b183 <memchr+0xa3>
		size_t k = ONES * c;
  41b130:	48 b9 01 01 01 01 01 	movabs rcx,0x101010101010101
  41b137:	01 01 01 
  41b13a:	49 63 fa             	movsxd rdi,r10d
		for (w = (const void *)s; n>=SS && !HASZERO(*w^k); w++, n-=SS);
  41b13d:	49 b9 ff fe fe fe fe 	movabs r9,0xfefefefefefefeff
  41b144:	fe fe fe 
  41b147:	49 b8 80 80 80 80 80 	movabs r8,0x8080808080808080
  41b14e:	80 80 80 
		size_t k = ONES * c;
  41b151:	48 0f af f9          	imul   rdi,rcx
		for (w = (const void *)s; n>=SS && !HASZERO(*w^k); w++, n-=SS);
  41b155:	48 83 fa 07          	cmp    rdx,0x7
  41b159:	77 13                	ja     41b16e <memchr+0x8e>
  41b15b:	eb 26                	jmp    41b183 <memchr+0xa3>
  41b15d:	0f 1f 00             	nop    DWORD PTR [rax]
  41b160:	48 83 ea 08          	sub    rdx,0x8
  41b164:	48 83 c0 08          	add    rax,0x8
  41b168:	48 83 fa 07          	cmp    rdx,0x7
  41b16c:	76 3d                	jbe    41b1ab <memchr+0xcb>
  41b16e:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  41b171:	48 31 f9             	xor    rcx,rdi
  41b174:	4a 8d 34 09          	lea    rsi,[rcx+r9*1]
  41b178:	48 f7 d1             	not    rcx
  41b17b:	48 21 f1             	and    rcx,rsi
  41b17e:	4c 85 c1             	test   rcx,r8
  41b181:	74 dd                	je     41b160 <memchr+0x80>
{
  41b183:	49 89 c0             	mov    r8,rax
  41b186:	48 01 c2             	add    rdx,rax
  41b189:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (; n && *s != c; s++, n--);
  41b190:	41 0f b6 00          	movzx  eax,BYTE PTR [r8]
  41b194:	44 39 d0             	cmp    eax,r10d
  41b197:	0f 84 7b ff ff ff    	je     41b118 <memchr+0x38>
  41b19d:	49 83 c0 01          	add    r8,0x1
  41b1a1:	49 39 d0             	cmp    r8,rdx
  41b1a4:	75 ea                	jne    41b190 <memchr+0xb0>
  41b1a6:	e9 6a ff ff ff       	jmp    41b115 <memchr+0x35>
	return n ? (void *)s : 0;
  41b1ab:	45 31 c0             	xor    r8d,r8d
	for (; n && *s != c; s++, n--);
  41b1ae:	48 85 d2             	test   rdx,rdx
  41b1b1:	0f 84 61 ff ff ff    	je     41b118 <memchr+0x38>
  41b1b7:	eb ca                	jmp    41b183 <memchr+0xa3>
  41b1b9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000041b1c0 <__strerror_l>:
static const char errmsg[] =
#include "__strerror.h"
;

char *__strerror_l(int e, locale_t loc)
{
  41b1c0:	f3 0f 1e fa          	endbr64 
	 * historical typo, so we just remap it. */
	if (EDQUOT==1133) {
		if (e==109) e=-1;
		else if (e==EDQUOT) e=109;
	}
	for (i=0; errid[i] && errid[i] != e; i++);
  41b1c4:	4c 8d 05 f9 ff ff ff 	lea    r8,[rip+0xfffffffffffffff9]        # 41b1c4 <__strerror_l+0x4>
  41b1cb:	31 d2                	xor    edx,edx
  41b1cd:	49 bb 4c 22 04 00 00 	movabs r11,0x4224c
  41b1d4:	00 00 00 
  41b1d7:	48 b8 b1 2a fc ff ff 	movabs rax,0xfffffffffffc2ab1
  41b1de:	ff ff ff 
  41b1e1:	4d 01 d8             	add    r8,r11
  41b1e4:	49 8d 0c 00          	lea    rcx,[r8+rax*1]
  41b1e8:	b8 54 00 00 00       	mov    eax,0x54
  41b1ed:	eb 0f                	jmp    41b1fe <__strerror_l+0x3e>
  41b1ef:	90                   	nop
  41b1f0:	0f b6 01             	movzx  eax,BYTE PTR [rcx]
  41b1f3:	48 83 c1 01          	add    rcx,0x1
  41b1f7:	83 c2 01             	add    edx,0x1
  41b1fa:	84 c0                	test   al,al
  41b1fc:	74 16                	je     41b214 <__strerror_l+0x54>
  41b1fe:	39 f8                	cmp    eax,edi
  41b200:	75 ee                	jne    41b1f0 <__strerror_l+0x30>
	for (s=errmsg; i; s++, i--) for (; *s; s++);
  41b202:	48 b8 90 23 fc ff ff 	movabs rax,0xfffffffffffc2390
  41b209:	ff ff ff 
  41b20c:	49 8d 3c 00          	lea    rdi,[r8+rax*1]
  41b210:	85 d2                	test   edx,edx
  41b212:	74 44                	je     41b258 <__strerror_l+0x98>
	for (i=0; errid[i] && errid[i] != e; i++);
  41b214:	48 b8 90 23 fc ff ff 	movabs rax,0xfffffffffffc2390
  41b21b:	ff ff ff 
  41b21e:	b9 49 00 00 00       	mov    ecx,0x49
  41b223:	4c 01 c0             	add    rax,r8
  41b226:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41b22d:	00 00 00 
	for (s=errmsg; i; s++, i--) for (; *s; s++);
  41b230:	84 c9                	test   cl,cl
  41b232:	74 0d                	je     41b241 <__strerror_l+0x81>
  41b234:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  41b238:	48 83 c0 01          	add    rax,0x1
  41b23c:	80 38 00             	cmp    BYTE PTR [rax],0x0
  41b23f:	75 f7                	jne    41b238 <__strerror_l+0x78>
  41b241:	48 8d 78 01          	lea    rdi,[rax+0x1]
  41b245:	83 ea 01             	sub    edx,0x1
  41b248:	74 0e                	je     41b258 <__strerror_l+0x98>
  41b24a:	0f b6 48 01          	movzx  ecx,BYTE PTR [rax+0x1]
  41b24e:	48 89 f8             	mov    rax,rdi
  41b251:	eb dd                	jmp    41b230 <__strerror_l+0x70>
  41b253:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	return (char *)LCTRANS(s, LC_MESSAGES, loc);
  41b258:	48 b8 a0 de fb ff ff 	movabs rax,0xfffffffffffbdea0
  41b25f:	ff ff ff 
  41b262:	48 8b 76 28          	mov    rsi,QWORD PTR [rsi+0x28]
  41b266:	4c 01 c0             	add    rax,r8
  41b269:	ff e0                	jmp    rax
  41b26b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000041b270 <strerror>:
}

char *strerror(int e)
{
  41b270:	f3 0f 1e fa          	endbr64 
static inline struct pthread *__pthread_self()
{
	struct pthread *self;
	__asm__ ("mov %%fs:0,%0" : "=r" (self) );
  41b274:	49 bb 9c 21 04 00 00 	movabs r11,0x4219c
  41b27b:	00 00 00 
  41b27e:	41 57                	push   r15
  41b280:	4c 8d 3d ed ff ff ff 	lea    r15,[rip+0xffffffffffffffed]        # 41b274 <strerror+0x4>
  41b287:	4d 01 df             	add    r15,r11
  41b28a:	64 48 8b 04 25 00 00 	mov    rax,QWORD PTR fs:0x0
  41b291:	00 00 
	return __strerror_l(e, CURRENT_LOCALE);
  41b293:	48 8b b0 b0 00 00 00 	mov    rsi,QWORD PTR [rax+0xb0]
  41b29a:	48 b8 b0 dd fb ff ff 	movabs rax,0xfffffffffffbddb0
  41b2a1:	ff ff ff 
  41b2a4:	4c 01 f8             	add    rax,r15
}
  41b2a7:	41 5f                	pop    r15
	return __strerror_l(e, CURRENT_LOCALE);
  41b2a9:	ff e0                	jmp    rax
  41b2ab:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000041b2b0 <__lctrans>:

weak_alias(dummy, __lctrans_impl);

const char *__lctrans(const char *msg, const struct __locale_map *lm)
{
  41b2b0:	f3 0f 1e fa          	endbr64 
	return __lctrans_impl(msg, lm);
  41b2b4:	48 8d 05 f9 ff ff ff 	lea    rax,[rip+0xfffffffffffffff9]        # 41b2b4 <__lctrans+0x4>
  41b2bb:	49 bb 5c 21 04 00 00 	movabs r11,0x4215c
  41b2c2:	00 00 00 
  41b2c5:	48 ba 90 7a fb ff ff 	movabs rdx,0xfffffffffffb7a90
  41b2cc:	ff ff ff 
  41b2cf:	4c 01 d8             	add    rax,r11
  41b2d2:	48 01 d0             	add    rax,rdx
  41b2d5:	ff e0                	jmp    rax
  41b2d7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41b2de:	00 00 

000000000041b2e0 <__lctrans_cur>:
}

const char *__lctrans_cur(const char *msg)
{
  41b2e0:	f3 0f 1e fa          	endbr64 
  41b2e4:	64 48 8b 14 25 00 00 	mov    rdx,QWORD PTR fs:0x0
  41b2eb:	00 00 
	return __lctrans_impl(msg, CURRENT_LOCALE->cat[LC_MESSAGES]);
  41b2ed:	48 8b 92 b0 00 00 00 	mov    rdx,QWORD PTR [rdx+0xb0]
  41b2f4:	48 8d 05 e9 ff ff ff 	lea    rax,[rip+0xffffffffffffffe9]        # 41b2e4 <__lctrans_cur+0x4>
  41b2fb:	49 bb 2c 21 04 00 00 	movabs r11,0x4212c
  41b302:	00 00 00 
  41b305:	4c 01 d8             	add    rax,r11
  41b308:	48 8b 72 28          	mov    rsi,QWORD PTR [rdx+0x28]
  41b30c:	48 ba 90 7a fb ff ff 	movabs rdx,0xfffffffffffb7a90
  41b313:	ff ff ff 
  41b316:	48 01 d0             	add    rax,rdx
  41b319:	ff e0                	jmp    rax
  41b31b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000041b320 <__fpclassifyl>:
{
	return __fpclassify(x);
}
#elif LDBL_MANT_DIG == 64 && LDBL_MAX_EXP == 16384
int __fpclassifyl(long double x)
{
  41b320:	f3 0f 1e fa          	endbr64 
	union ldshape u = {x};
	int e = u.i.se & 0x7fff;
  41b324:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
  41b329:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
	int msb = u.i.m>>63;
  41b32e:	48 89 d1             	mov    rcx,rdx
  41b331:	89 c6                	mov    esi,eax
	int e = u.i.se & 0x7fff;
  41b333:	25 ff 7f 00 00       	and    eax,0x7fff
	int msb = u.i.m>>63;
  41b338:	48 c1 e9 3f          	shr    rcx,0x3f
  41b33c:	66 81 e6 ff 7f       	and    si,0x7fff
	if (!e && !msb)
  41b341:	09 c8                	or     eax,ecx
  41b343:	74 2b                	je     41b370 <__fpclassifyl+0x50>
		 * the version with it clear. */
		if (__BYTE_ORDER == __LITTLE_ENDIAN && !msb)
			return FP_NAN;
		return u.i.m << 1 ? FP_NAN : FP_INFINITE;
	}
	if (!msb)
  41b345:	8d 04 8d 00 00 00 00 	lea    eax,[rcx*4+0x0]
	if (e == 0x7fff) {
  41b34c:	66 81 fe ff 7f       	cmp    si,0x7fff
  41b351:	74 05                	je     41b358 <__fpclassifyl+0x38>
		return FP_NAN;
	return FP_NORMAL;
}
  41b353:	c3                   	ret    
  41b354:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
			return FP_NAN;
  41b358:	31 c0                	xor    eax,eax
		if (__BYTE_ORDER == __LITTLE_ENDIAN && !msb)
  41b35a:	48 85 c9             	test   rcx,rcx
  41b35d:	74 f4                	je     41b353 <__fpclassifyl+0x33>
		return u.i.m << 1 ? FP_NAN : FP_INFINITE;
  41b35f:	31 c0                	xor    eax,eax
  41b361:	48 01 d2             	add    rdx,rdx
  41b364:	0f 94 c0             	sete   al
}
  41b367:	c3                   	ret    
  41b368:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41b36f:	00 
		return u.i.m ? FP_SUBNORMAL : FP_ZERO;
  41b370:	48 83 fa 01          	cmp    rdx,0x1
  41b374:	b8 02 00 00 00       	mov    eax,0x2
  41b379:	83 d8 ff             	sbb    eax,0xffffffff
  41b37c:	c3                   	ret    
  41b37d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000041b380 <__signbitl>:
#include "libm.h"

#if (LDBL_MANT_DIG == 64 || LDBL_MANT_DIG == 113) && LDBL_MAX_EXP == 16384
int __signbitl(long double x)
{
  41b380:	f3 0f 1e fa          	endbr64 
	union ldshape u = {x};
	return u.i.se >> 15;
  41b384:	0f b7 44 24 10       	movzx  eax,WORD PTR [rsp+0x10]
  41b389:	66 c1 e8 0f          	shr    ax,0xf
  41b38d:	0f b7 c0             	movzx  eax,ax
}
  41b390:	c3                   	ret    
  41b391:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41b398:	00 00 00 
  41b39b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000041b3a0 <frexpl>:
{
	return frexp(x, e);
}
#elif (LDBL_MANT_DIG == 64 || LDBL_MANT_DIG == 113) && LDBL_MAX_EXP == 16384
long double frexpl(long double x, int *e)
{
  41b3a0:	f3 0f 1e fa          	endbr64 
  41b3a4:	48 83 ec 48          	sub    rsp,0x48
  41b3a8:	48 8d 15 f5 ff ff ff 	lea    rdx,[rip+0xfffffffffffffff5]        # 41b3a4 <frexpl+0x4>
  41b3af:	49 bb 6c 20 04 00 00 	movabs r11,0x4206c
  41b3b6:	00 00 00 
	union ldshape u = {x};
  41b3b9:	db 6c 24 50          	fld    TBYTE PTR [rsp+0x50]
  41b3bd:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  41b3c2:	4c 01 da             	add    rdx,r11
	int ee = u.i.se & 0x7fff;

	if (!ee) {
  41b3c5:	89 c1                	mov    ecx,eax
	union ldshape u = {x};
  41b3c7:	d9 c0                	fld    st(0)
  41b3c9:	db 7c 24 20          	fstp   TBYTE PTR [rsp+0x20]
	if (!ee) {
  41b3cd:	66 81 e1 ff 7f       	and    cx,0x7fff
  41b3d2:	74 3c                	je     41b410 <frexpl+0x70>
  41b3d4:	dd d8                	fstp   st(0)
			x = frexpl(x*0x1p120, e);
			*e -= 120;
		} else *e = 0;
		return x;
	} else if (ee == 0x7fff) {
		return x;
  41b3d6:	db 6c 24 50          	fld    TBYTE PTR [rsp+0x50]
	int ee = u.i.se & 0x7fff;
  41b3da:	0f b7 d1             	movzx  edx,cx
		return x;
  41b3dd:	db 3c 24             	fstp   TBYTE PTR [rsp]
	} else if (ee == 0x7fff) {
  41b3e0:	66 81 f9 ff 7f       	cmp    cx,0x7fff
  41b3e5:	74 1c                	je     41b403 <frexpl+0x63>
	}

	*e = ee - 0x3ffe;
	u.i.se &= 0x8000;
  41b3e7:	66 25 00 80          	and    ax,0x8000
	*e = ee - 0x3ffe;
  41b3eb:	81 ea fe 3f 00 00    	sub    edx,0x3ffe
	u.i.se |= 0x3ffe;
  41b3f1:	66 0d fe 3f          	or     ax,0x3ffe
	*e = ee - 0x3ffe;
  41b3f5:	89 17                	mov    DWORD PTR [rdi],edx
	u.i.se |= 0x3ffe;
  41b3f7:	66 89 44 24 28       	mov    WORD PTR [rsp+0x28],ax
	return u.f;
  41b3fc:	db 6c 24 20          	fld    TBYTE PTR [rsp+0x20]
  41b400:	db 3c 24             	fstp   TBYTE PTR [rsp]
}
  41b403:	db 2c 24             	fld    TBYTE PTR [rsp]
  41b406:	48 83 c4 48          	add    rsp,0x48
  41b40a:	c3                   	ret    
  41b40b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		if (x) {
  41b410:	d9 ee                	fldz   
  41b412:	d9 c9                	fxch   st(1)
  41b414:	df e9                	fucomip st,st(1)
  41b416:	dd d8                	fstp   st(0)
  41b418:	7a 1e                	jp     41b438 <frexpl+0x98>
  41b41a:	75 1c                	jne    41b438 <frexpl+0x98>
		} else *e = 0;
  41b41c:	db 6c 24 50          	fld    TBYTE PTR [rsp+0x50]
  41b420:	c7 07 00 00 00 00    	mov    DWORD PTR [rdi],0x0
  41b426:	db 3c 24             	fstp   TBYTE PTR [rsp]
}
  41b429:	db 2c 24             	fld    TBYTE PTR [rsp]
  41b42c:	48 83 c4 48          	add    rsp,0x48
  41b430:	c3                   	ret    
  41b431:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
			x = frexpl(x*0x1p120, e);
  41b438:	48 be dc 22 fc ff ff 	movabs rsi,0xfffffffffffc22dc
  41b43f:	ff ff ff 
  41b442:	db 6c 24 50          	fld    TBYTE PTR [rsp+0x50]
  41b446:	d8 0c 16             	fmul   DWORD PTR [rsi+rdx*1]
  41b449:	d9 c0                	fld    st(0)
  41b44b:	db 3c 24             	fstp   TBYTE PTR [rsp]
	union ldshape u = {x};
  41b44e:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
	if (!ee) {
  41b453:	89 c1                	mov    ecx,eax
	union ldshape u = {x};
  41b455:	d9 c0                	fld    st(0)
  41b457:	db 7c 24 30          	fstp   TBYTE PTR [rsp+0x30]
	if (!ee) {
  41b45b:	66 81 e1 ff 7f       	and    cx,0x7fff
  41b460:	74 36                	je     41b498 <frexpl+0xf8>
  41b462:	dd d8                	fstp   st(0)
	int ee = u.i.se & 0x7fff;
  41b464:	0f b7 d1             	movzx  edx,cx
	} else if (ee == 0x7fff) {
  41b467:	66 81 f9 ff 7f       	cmp    cx,0x7fff
  41b46c:	74 72                	je     41b4e0 <frexpl+0x140>
	u.i.se &= 0x8000;
  41b46e:	66 25 00 80          	and    ax,0x8000
	u.i.se |= 0x3ffe;
  41b472:	66 0d fe 3f          	or     ax,0x3ffe
  41b476:	66 89 44 24 38       	mov    WORD PTR [rsp+0x38],ax
	return u.f;
  41b47b:	db 6c 24 30          	fld    TBYTE PTR [rsp+0x30]
			*e -= 120;
  41b47f:	8d 82 8a bf ff ff    	lea    eax,[rdx-0x4076]
	return u.f;
  41b485:	db 3c 24             	fstp   TBYTE PTR [rsp]
			*e -= 120;
  41b488:	89 07                	mov    DWORD PTR [rdi],eax
}
  41b48a:	db 2c 24             	fld    TBYTE PTR [rsp]
  41b48d:	48 83 c4 48          	add    rsp,0x48
  41b491:	c3                   	ret    
  41b492:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
		if (x) {
  41b498:	d9 ee                	fldz   
  41b49a:	d9 c9                	fxch   st(1)
  41b49c:	df e9                	fucomip st,st(1)
  41b49e:	dd d8                	fstp   st(0)
  41b4a0:	7a 07                	jp     41b4a9 <frexpl+0x109>
  41b4a2:	b8 88 ff ff ff       	mov    eax,0xffffff88
  41b4a7:	74 df                	je     41b488 <frexpl+0xe8>
			x = frexpl(x*0x1p120, e);
  41b4a9:	db 2c 24             	fld    TBYTE PTR [rsp]
  41b4ac:	d8 0c 16             	fmul   DWORD PTR [rsi+rdx*1]
  41b4af:	48 83 ec 10          	sub    rsp,0x10
  41b4b3:	48 b8 90 df fb ff ff 	movabs rax,0xfffffffffffbdf90
  41b4ba:	ff ff ff 
  41b4bd:	48 89 7c 24 28       	mov    QWORD PTR [rsp+0x28],rdi
  41b4c2:	48 01 d0             	add    rax,rdx
  41b4c5:	db 3c 24             	fstp   TBYTE PTR [rsp]
  41b4c8:	ff d0                	call   rax
			*e -= 120;
  41b4ca:	48 8b 7c 24 28       	mov    rdi,QWORD PTR [rsp+0x28]
			x = frexpl(x*0x1p120, e);
  41b4cf:	db 7c 24 10          	fstp   TBYTE PTR [rsp+0x10]
			*e -= 120;
  41b4d3:	5a                   	pop    rdx
  41b4d4:	59                   	pop    rcx
  41b4d5:	8b 07                	mov    eax,DWORD PTR [rdi]
  41b4d7:	2d f0 00 00 00       	sub    eax,0xf0
  41b4dc:	89 07                	mov    DWORD PTR [rdi],eax
  41b4de:	eb aa                	jmp    41b48a <frexpl+0xea>
  41b4e0:	8b 07                	mov    eax,DWORD PTR [rdi]
  41b4e2:	83 e8 78             	sub    eax,0x78
  41b4e5:	89 07                	mov    DWORD PTR [rdi],eax
  41b4e7:	eb a1                	jmp    41b48a <frexpl+0xea>
  41b4e9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000041b4f0 <wctomb>:
#include <stdlib.h>
#include <wchar.h>

int wctomb(char *s, wchar_t wc)
{
  41b4f0:	f3 0f 1e fa          	endbr64 
	if (!s) return 0;
  41b4f4:	49 bb 1c 1f 04 00 00 	movabs r11,0x41f1c
  41b4fb:	00 00 00 
{
  41b4fe:	41 57                	push   r15
  41b500:	31 c0                	xor    eax,eax
  41b502:	4c 8d 3d eb ff ff ff 	lea    r15,[rip+0xffffffffffffffeb]        # 41b4f4 <wctomb+0x4>
  41b509:	4d 01 df             	add    r15,r11
	if (!s) return 0;
  41b50c:	48 85 ff             	test   rdi,rdi
  41b50f:	74 11                	je     41b522 <wctomb+0x32>
	return wcrtomb(s, wc, 0);
  41b511:	48 b8 70 e6 fb ff ff 	movabs rax,0xfffffffffffbe670
  41b518:	ff ff ff 
  41b51b:	31 d2                	xor    edx,edx
  41b51d:	4c 01 f8             	add    rax,r15
  41b520:	ff d0                	call   rax
}
  41b522:	41 5f                	pop    r15
  41b524:	c3                   	ret    
  41b525:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41b52c:	00 00 00 
  41b52f:	90                   	nop

000000000041b530 <__lockfile>:
#include "stdio_impl.h"
#include "pthread_impl.h"

int __lockfile(FILE *f)
{
  41b530:	f3 0f 1e fa          	endbr64 
	int owner = f->lock, tid = __pthread_self()->tid;
  41b534:	49 bb dc 1e 04 00 00 	movabs r11,0x41edc
  41b53b:	00 00 00 
{
  41b53e:	41 57                	push   r15
	if ((owner & ~MAYBE_WAITERS) == tid)
		return 0;
  41b540:	45 31 c0             	xor    r8d,r8d
  41b543:	4c 8d 3d ea ff ff ff 	lea    r15,[rip+0xffffffffffffffea]        # 41b534 <__lockfile+0x4>
{
  41b54a:	41 56                	push   r14
  41b54c:	4d 01 df             	add    r15,r11
  41b54f:	41 55                	push   r13
  41b551:	41 54                	push   r12
  41b553:	55                   	push   rbp
  41b554:	53                   	push   rbx
  41b555:	64 48 8b 14 25 00 00 	mov    rdx,QWORD PTR fs:0x0
  41b55c:	00 00 
  41b55e:	48 83 ec 08          	sub    rsp,0x8
	int owner = f->lock, tid = __pthread_self()->tid;
  41b562:	8b 87 8c 00 00 00    	mov    eax,DWORD PTR [rdi+0x8c]
  41b568:	8b 5a 38             	mov    ebx,DWORD PTR [rdx+0x38]
	if ((owner & ~MAYBE_WAITERS) == tid)
  41b56b:	25 ff ff ff bf       	and    eax,0xbfffffff
  41b570:	39 d8                	cmp    eax,ebx
  41b572:	0f 84 c6 00 00 00    	je     41b63e <__lockfile+0x10e>
	owner = a_cas(&f->lock, 0, tid);
  41b578:	4c 8d a7 8c 00 00 00 	lea    r12,[rdi+0x8c]
	__asm__ __volatile__ (
  41b57f:	44 89 c0             	mov    eax,r8d
  41b582:	f0 0f b1 9f 8c 00 00 	lock cmpxchg DWORD PTR [rdi+0x8c],ebx
  41b589:	00 
	if (!owner) return 1;
  41b58a:	85 c0                	test   eax,eax
  41b58c:	0f 84 a6 00 00 00    	je     41b638 <__lockfile+0x108>
	while ((owner = a_cas(&f->lock, 0, tid|MAYBE_WAITERS))) {
  41b592:	81 cb 00 00 00 40    	or     ebx,0x40000000
  41b598:	44 89 c0             	mov    eax,r8d
  41b59b:	f0 0f b1 9f 8c 00 00 	lock cmpxchg DWORD PTR [rdi+0x8c],ebx
  41b5a2:	00 
  41b5a3:	89 c2                	mov    edx,eax
  41b5a5:	85 c0                	test   eax,eax
  41b5a7:	0f 84 8b 00 00 00    	je     41b638 <__lockfile+0x108>
	return __cos_syscall(n, a1, a2, a3, a4, 0, 0, 0);
  41b5ad:	48 bd d0 ce fa ff ff 	movabs rbp,0xfffffffffffaced0
  41b5b4:	ff ff ff 
  41b5b7:	eb 21                	jmp    41b5da <__lockfile+0xaa>
  41b5b9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  41b5c0:	89 d0                	mov    eax,edx
  41b5c2:	f0 41 0f b1 0c 24    	lock cmpxchg DWORD PTR [r12],ecx
		if ((owner & MAYBE_WAITERS) ||
  41b5c8:	39 d0                	cmp    eax,edx
  41b5ca:	74 1e                	je     41b5ea <__lockfile+0xba>
  41b5cc:	31 c0                	xor    eax,eax
  41b5ce:	f0 41 0f b1 1c 24    	lock cmpxchg DWORD PTR [r12],ebx
  41b5d4:	89 c2                	mov    edx,eax
	while ((owner = a_cas(&f->lock, 0, tid|MAYBE_WAITERS))) {
  41b5d6:	85 c0                	test   eax,eax
  41b5d8:	74 5e                	je     41b638 <__lockfile+0x108>
		    a_cas(&f->lock, owner, owner|MAYBE_WAITERS)==owner)
  41b5da:	89 d1                	mov    ecx,edx
  41b5dc:	81 c9 00 00 00 40    	or     ecx,0x40000000
		if ((owner & MAYBE_WAITERS) ||
  41b5e2:	f7 c2 00 00 00 40    	test   edx,0x40000000
  41b5e8:	74 d6                	je     41b5c0 <__lockfile+0x90>
	__syscall(SYS_futex, addr, FUTEX_WAKE, cnt);
}
static inline void __futexwait(volatile void *addr, int val, int priv)
{
	if (priv) priv = FUTEX_PRIVATE;
	__syscall(SYS_futex, addr, FUTEX_WAIT|priv, val, 0) != -ENOSYS ||
  41b5ea:	4c 63 e9             	movsxd r13,ecx
  41b5ed:	6a 00                	push   0x0
  41b5ef:	4c 89 e6             	mov    rsi,r12
  41b5f2:	45 31 c9             	xor    r9d,r9d
  41b5f5:	6a 00                	push   0x0
  41b5f7:	4c 89 e9             	mov    rcx,r13
  41b5fa:	45 31 c0             	xor    r8d,r8d
  41b5fd:	ba 80 00 00 00       	mov    edx,0x80
  41b602:	bf ca 00 00 00       	mov    edi,0xca
  41b607:	4e 8d 74 3d 00       	lea    r14,[rbp+r15*1+0x0]
  41b60c:	41 ff d6             	call   r14
  41b60f:	59                   	pop    rcx
  41b610:	5e                   	pop    rsi
  41b611:	48 83 f8 da          	cmp    rax,0xffffffffffffffda
  41b615:	75 b5                	jne    41b5cc <__lockfile+0x9c>
  41b617:	6a 00                	push   0x0
  41b619:	31 d2                	xor    edx,edx
  41b61b:	45 31 c9             	xor    r9d,r9d
  41b61e:	45 31 c0             	xor    r8d,r8d
  41b621:	6a 00                	push   0x0
  41b623:	4c 89 e9             	mov    rcx,r13
  41b626:	4c 89 e6             	mov    rsi,r12
  41b629:	bf ca 00 00 00       	mov    edi,0xca
  41b62e:	41 ff d6             	call   r14
  41b631:	58                   	pop    rax
  41b632:	5a                   	pop    rdx
  41b633:	eb 97                	jmp    41b5cc <__lockfile+0x9c>
  41b635:	0f 1f 00             	nop    DWORD PTR [rax]
	if (!owner) return 1;
  41b638:	41 b8 01 00 00 00    	mov    r8d,0x1
			__futexwait(&f->lock, owner|MAYBE_WAITERS, 1);
	}
	return 1;
}
  41b63e:	48 83 c4 08          	add    rsp,0x8
  41b642:	44 89 c0             	mov    eax,r8d
  41b645:	5b                   	pop    rbx
  41b646:	5d                   	pop    rbp
  41b647:	41 5c                	pop    r12
  41b649:	41 5d                	pop    r13
  41b64b:	41 5e                	pop    r14
  41b64d:	41 5f                	pop    r15
  41b64f:	c3                   	ret    

000000000041b650 <__unlockfile>:

void __unlockfile(FILE *f)
{
  41b650:	f3 0f 1e fa          	endbr64 
	__asm__ __volatile__(
  41b654:	49 bb bc 1d 04 00 00 	movabs r11,0x41dbc
  41b65b:	00 00 00 
  41b65e:	41 57                	push   r15
  41b660:	31 c0                	xor    eax,eax
  41b662:	4c 8d 3d eb ff ff ff 	lea    r15,[rip+0xffffffffffffffeb]        # 41b654 <__unlockfile+0x4>
  41b669:	55                   	push   rbp
  41b66a:	4d 01 df             	add    r15,r11
  41b66d:	53                   	push   rbx
  41b66e:	87 87 8c 00 00 00    	xchg   DWORD PTR [rdi+0x8c],eax
	if (a_swap(&f->lock, 0) & MAYBE_WAITERS)
  41b674:	a9 00 00 00 40       	test   eax,0x40000000
  41b679:	75 05                	jne    41b680 <__unlockfile+0x30>
		__wake(&f->lock, 1, 1);
}
  41b67b:	5b                   	pop    rbx
  41b67c:	5d                   	pop    rbp
  41b67d:	41 5f                	pop    r15
  41b67f:	c3                   	ret    
  41b680:	48 8d af 8c 00 00 00 	lea    rbp,[rdi+0x8c]
	return __cos_syscall(n, a1, a2, a3, 0, 0, 0, 0);
  41b687:	6a 00                	push   0x0
  41b689:	45 31 c9             	xor    r9d,r9d
  41b68c:	45 31 c0             	xor    r8d,r8d
  41b68f:	6a 00                	push   0x0
  41b691:	b9 01 00 00 00       	mov    ecx,0x1
  41b696:	48 89 ee             	mov    rsi,rbp
  41b699:	ba 81 00 00 00       	mov    edx,0x81
  41b69e:	48 bb d0 ce fa ff ff 	movabs rbx,0xfffffffffffaced0
  41b6a5:	ff ff ff 
  41b6a8:	bf ca 00 00 00       	mov    edi,0xca
  41b6ad:	4c 01 fb             	add    rbx,r15
  41b6b0:	ff d3                	call   rbx
	__syscall(SYS_futex, addr, FUTEX_WAKE|priv, cnt) != -ENOSYS ||
  41b6b2:	59                   	pop    rcx
  41b6b3:	5e                   	pop    rsi
  41b6b4:	48 83 f8 da          	cmp    rax,0xffffffffffffffda
  41b6b8:	75 c1                	jne    41b67b <__unlockfile+0x2b>
  41b6ba:	6a 00                	push   0x0
  41b6bc:	ba 01 00 00 00       	mov    edx,0x1
  41b6c1:	45 31 c9             	xor    r9d,r9d
  41b6c4:	45 31 c0             	xor    r8d,r8d
  41b6c7:	6a 00                	push   0x0
  41b6c9:	b9 01 00 00 00       	mov    ecx,0x1
  41b6ce:	48 89 ee             	mov    rsi,rbp
  41b6d1:	bf ca 00 00 00       	mov    edi,0xca
  41b6d6:	ff d3                	call   rbx
  41b6d8:	58                   	pop    rax
  41b6d9:	5a                   	pop    rdx
  41b6da:	eb 9f                	jmp    41b67b <__unlockfile+0x2b>
  41b6dc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000041b6e0 <__towrite>:
#include "stdio_impl.h"

int __towrite(FILE *f)
{
  41b6e0:	f3 0f 1e fa          	endbr64 
	f->mode |= f->mode-1;
  41b6e4:	8b 97 88 00 00 00    	mov    edx,DWORD PTR [rdi+0x88]
  41b6ea:	8d 42 ff             	lea    eax,[rdx-0x1]
  41b6ed:	09 d0                	or     eax,edx
  41b6ef:	89 87 88 00 00 00    	mov    DWORD PTR [rdi+0x88],eax
	if (f->flags & F_NOWR) {
  41b6f5:	8b 07                	mov    eax,DWORD PTR [rdi]
  41b6f7:	a8 08                	test   al,0x8
  41b6f9:	75 35                	jne    41b730 <__towrite+0x50>
	}
	/* Clear read buffer (easier than summoning nasal demons) */
	f->rpos = f->rend = 0;

	/* Activate write through the buffer. */
	f->wpos = f->wbase = f->buf;
  41b6fb:	48 8b 47 58          	mov    rax,QWORD PTR [rdi+0x58]
	f->wend = f->buf + f->buf_size;
  41b6ff:	48 8b 4f 60          	mov    rcx,QWORD PTR [rdi+0x60]
	f->rpos = f->rend = 0;
  41b703:	66 0f ef c0          	pxor   xmm0,xmm0
  41b707:	0f 11 47 08          	movups XMMWORD PTR [rdi+0x8],xmm0
	f->wend = f->buf + f->buf_size;
  41b70b:	48 01 c1             	add    rcx,rax
  41b70e:	66 48 0f 6e c8       	movq   xmm1,rax
	f->wpos = f->wbase = f->buf;
  41b713:	48 89 47 38          	mov    QWORD PTR [rdi+0x38],rax

	return 0;
  41b717:	31 c0                	xor    eax,eax
	f->wend = f->buf + f->buf_size;
  41b719:	66 48 0f 6e c1       	movq   xmm0,rcx
  41b71e:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  41b722:	0f 11 47 20          	movups XMMWORD PTR [rdi+0x20],xmm0
}
  41b726:	c3                   	ret    
  41b727:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41b72e:	00 00 
		f->flags |= F_ERR;
  41b730:	83 c8 20             	or     eax,0x20
  41b733:	89 07                	mov    DWORD PTR [rdi],eax
		return EOF;
  41b735:	b8 ff ff ff ff       	mov    eax,0xffffffff
  41b73a:	c3                   	ret    
  41b73b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000041b740 <__towrite_needs_stdio_exit>:

hidden void __towrite_needs_stdio_exit()
{
  41b740:	f3 0f 1e fa          	endbr64 
	__stdio_exit_needed();
  41b744:	48 8d 05 f9 ff ff ff 	lea    rax,[rip+0xfffffffffffffff9]        # 41b744 <__towrite_needs_stdio_exit+0x4>
  41b74b:	49 bb cc 1c 04 00 00 	movabs r11,0x41ccc
  41b752:	00 00 00 
  41b755:	48 ba d0 e7 fb ff ff 	movabs rdx,0xfffffffffffbe7d0
  41b75c:	ff ff ff 
  41b75f:	4c 01 d8             	add    rax,r11
  41b762:	48 01 d0             	add    rax,rdx
  41b765:	ff e0                	jmp    rax
  41b767:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41b76e:	00 00 

000000000041b770 <__fwritex>:
#include "stdio_impl.h"
#include <string.h>

size_t __fwritex(const unsigned char *restrict s, size_t l, FILE *restrict f)
{
  41b770:	f3 0f 1e fa          	endbr64 
	size_t i=0;

	if (!f->wend && __towrite(f)) return 0;
  41b774:	49 bb 9c 1c 04 00 00 	movabs r11,0x41c9c
  41b77b:	00 00 00 
{
  41b77e:	41 57                	push   r15
  41b780:	4c 8d 3d ed ff ff ff 	lea    r15,[rip+0xffffffffffffffed]        # 41b774 <__fwritex+0x4>
  41b787:	41 56                	push   r14
  41b789:	4d 01 df             	add    r15,r11
  41b78c:	41 55                	push   r13
  41b78e:	49 89 f5             	mov    r13,rsi
  41b791:	41 54                	push   r12
  41b793:	49 89 d4             	mov    r12,rdx
  41b796:	55                   	push   rbp
  41b797:	48 89 fd             	mov    rbp,rdi
  41b79a:	53                   	push   rbx
  41b79b:	48 83 ec 08          	sub    rsp,0x8
	if (!f->wend && __towrite(f)) return 0;
  41b79f:	48 8b 42 20          	mov    rax,QWORD PTR [rdx+0x20]
  41b7a3:	48 85 c0             	test   rax,rax
  41b7a6:	0f 84 c4 00 00 00    	je     41b870 <__fwritex+0x100>

	if (l > f->wend - f->wpos) return f->write(f, s, l);
  41b7ac:	49 8b 7c 24 28       	mov    rdi,QWORD PTR [r12+0x28]
  41b7b1:	48 29 f8             	sub    rax,rdi
  41b7b4:	4c 39 e8             	cmp    rax,r13
  41b7b7:	72 5f                	jb     41b818 <__fwritex+0xa8>

	if (f->lbf >= 0) {
  41b7b9:	41 8b 84 24 90 00 00 	mov    eax,DWORD PTR [r12+0x90]
  41b7c0:	00 
  41b7c1:	4c 89 eb             	mov    rbx,r13
  41b7c4:	85 c0                	test   eax,eax
  41b7c6:	79 46                	jns    41b80e <__fwritex+0x9e>
  41b7c8:	4d 89 ee             	mov    r14,r13
			s += i;
			l -= i;
		}
	}

	memcpy(f->wpos, s, l);
  41b7cb:	48 b8 4a 79 fb ff ff 	movabs rax,0xfffffffffffb794a
  41b7d2:	ff ff ff 
  41b7d5:	4c 89 f2             	mov    rdx,r14
  41b7d8:	48 89 ee             	mov    rsi,rbp
  41b7db:	4c 01 f8             	add    rax,r15
  41b7de:	ff d0                	call   rax
	f->wpos += l;
  41b7e0:	4d 01 74 24 28       	add    QWORD PTR [r12+0x28],r14
	return l+i;
  41b7e5:	4c 89 e8             	mov    rax,r13
}
  41b7e8:	48 83 c4 08          	add    rsp,0x8
  41b7ec:	5b                   	pop    rbx
  41b7ed:	5d                   	pop    rbp
  41b7ee:	41 5c                	pop    r12
  41b7f0:	41 5d                	pop    r13
  41b7f2:	41 5e                	pop    r14
  41b7f4:	41 5f                	pop    r15
  41b7f6:	c3                   	ret    
  41b7f7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41b7fe:	00 00 
		for (i=l; i && s[i-1] != '\n'; i--);
  41b800:	80 7c 1d ff 0a       	cmp    BYTE PTR [rbp+rbx*1-0x1],0xa
  41b805:	48 8d 43 ff          	lea    rax,[rbx-0x1]
  41b809:	74 35                	je     41b840 <__fwritex+0xd0>
  41b80b:	48 89 c3             	mov    rbx,rax
  41b80e:	48 85 db             	test   rbx,rbx
  41b811:	75 ed                	jne    41b800 <__fwritex+0x90>
  41b813:	eb b3                	jmp    41b7c8 <__fwritex+0x58>
  41b815:	0f 1f 00             	nop    DWORD PTR [rax]
	if (l > f->wend - f->wpos) return f->write(f, s, l);
  41b818:	49 8b 44 24 48       	mov    rax,QWORD PTR [r12+0x48]
}
  41b81d:	48 83 c4 08          	add    rsp,0x8
	if (l > f->wend - f->wpos) return f->write(f, s, l);
  41b821:	4c 89 ea             	mov    rdx,r13
  41b824:	48 89 ee             	mov    rsi,rbp
}
  41b827:	5b                   	pop    rbx
	if (l > f->wend - f->wpos) return f->write(f, s, l);
  41b828:	4c 89 e7             	mov    rdi,r12
}
  41b82b:	5d                   	pop    rbp
  41b82c:	41 5c                	pop    r12
  41b82e:	41 5d                	pop    r13
  41b830:	41 5e                	pop    r14
  41b832:	41 5f                	pop    r15
	if (l > f->wend - f->wpos) return f->write(f, s, l);
  41b834:	ff e0                	jmp    rax
  41b836:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41b83d:	00 00 00 
			size_t n = f->write(f, s, i);
  41b840:	48 89 da             	mov    rdx,rbx
  41b843:	48 89 ee             	mov    rsi,rbp
  41b846:	4c 89 e7             	mov    rdi,r12
  41b849:	41 ff 54 24 48       	call   QWORD PTR [r12+0x48]
			if (n < i) return n;
  41b84e:	48 39 c3             	cmp    rbx,rax
  41b851:	77 95                	ja     41b7e8 <__fwritex+0x78>
			l -= i;
  41b853:	4d 89 ee             	mov    r14,r13
	memcpy(f->wpos, s, l);
  41b856:	49 8b 7c 24 28       	mov    rdi,QWORD PTR [r12+0x28]
			s += i;
  41b85b:	48 01 dd             	add    rbp,rbx
			l -= i;
  41b85e:	49 29 de             	sub    r14,rbx
  41b861:	e9 65 ff ff ff       	jmp    41b7cb <__fwritex+0x5b>
  41b866:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41b86d:	00 00 00 
	if (!f->wend && __towrite(f)) return 0;
  41b870:	48 b8 d0 e2 fb ff ff 	movabs rax,0xfffffffffffbe2d0
  41b877:	ff ff ff 
  41b87a:	48 89 d7             	mov    rdi,rdx
  41b87d:	4c 01 f8             	add    rax,r15
  41b880:	ff d0                	call   rax
  41b882:	85 c0                	test   eax,eax
  41b884:	75 0a                	jne    41b890 <__fwritex+0x120>
	if (l > f->wend - f->wpos) return f->write(f, s, l);
  41b886:	49 8b 44 24 20       	mov    rax,QWORD PTR [r12+0x20]
  41b88b:	e9 1c ff ff ff       	jmp    41b7ac <__fwritex+0x3c>
	if (!f->wend && __towrite(f)) return 0;
  41b890:	31 c0                	xor    eax,eax
  41b892:	e9 51 ff ff ff       	jmp    41b7e8 <__fwritex+0x78>
  41b897:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41b89e:	00 00 

000000000041b8a0 <fwrite>:

size_t fwrite(const void *restrict src, size_t size, size_t nmemb, FILE *restrict f)
{
  41b8a0:	f3 0f 1e fa          	endbr64 
  41b8a4:	41 57                	push   r15
	size_t k, l = size*nmemb;
	if (!size) nmemb = 0;
  41b8a6:	31 c0                	xor    eax,eax
{
  41b8a8:	49 89 ff             	mov    r15,rdi
  41b8ab:	49 89 c8             	mov    r8,rcx
  41b8ae:	49 bb 6c 1b 04 00 00 	movabs r11,0x41b6c
  41b8b5:	00 00 00 
  41b8b8:	41 56                	push   r14
  41b8ba:	4c 8d 35 e3 ff ff ff 	lea    r14,[rip+0xffffffffffffffe3]        # 41b8a4 <fwrite+0x4>
  41b8c1:	41 55                	push   r13
	size_t k, l = size*nmemb;
  41b8c3:	49 89 f5             	mov    r13,rsi
  41b8c6:	4d 01 de             	add    r14,r11
{
  41b8c9:	41 54                	push   r12
	size_t k, l = size*nmemb;
  41b8cb:	4c 0f af ea          	imul   r13,rdx
{
  41b8cf:	49 89 f4             	mov    r12,rsi
  41b8d2:	55                   	push   rbp
  41b8d3:	48 89 d5             	mov    rbp,rdx
  41b8d6:	53                   	push   rbx
  41b8d7:	48 83 ec 28          	sub    rsp,0x28
	if (!size) nmemb = 0;
  41b8db:	48 85 f6             	test   rsi,rsi
  41b8de:	48 0f 44 e8          	cmove  rbp,rax
	FLOCK(f);
  41b8e2:	8b 81 8c 00 00 00    	mov    eax,DWORD PTR [rcx+0x8c]
  41b8e8:	c7 44 24 08 00 00 00 	mov    DWORD PTR [rsp+0x8],0x0
  41b8ef:	00 
  41b8f0:	85 c0                	test   eax,eax
  41b8f2:	78 20                	js     41b914 <fwrite+0x74>
  41b8f4:	48 b8 20 e1 fb ff ff 	movabs rax,0xfffffffffffbe120
  41b8fb:	ff ff ff 
  41b8fe:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  41b903:	48 89 cf             	mov    rdi,rcx
  41b906:	4c 01 f0             	add    rax,r14
  41b909:	ff d0                	call   rax
  41b90b:	4c 8b 44 24 10       	mov    r8,QWORD PTR [rsp+0x10]
  41b910:	89 44 24 08          	mov    DWORD PTR [rsp+0x8],eax
	if (!f->wend && __towrite(f)) return 0;
  41b914:	49 8b 40 20          	mov    rax,QWORD PTR [r8+0x20]
  41b918:	48 85 c0             	test   rax,rax
  41b91b:	0f 84 1f 01 00 00    	je     41ba40 <fwrite+0x1a0>
	if (l > f->wend - f->wpos) return f->write(f, s, l);
  41b921:	49 8b 78 28          	mov    rdi,QWORD PTR [r8+0x28]
  41b925:	48 29 f8             	sub    rax,rdi
  41b928:	49 39 c5             	cmp    r13,rax
  41b92b:	77 73                	ja     41b9a0 <fwrite+0x100>
	if (f->lbf >= 0) {
  41b92d:	41 8b b0 90 00 00 00 	mov    esi,DWORD PTR [r8+0x90]
  41b934:	4c 89 eb             	mov    rbx,r13
  41b937:	85 f6                	test   esi,esi
  41b939:	79 5c                	jns    41b997 <fwrite+0xf7>
  41b93b:	4c 89 ea             	mov    rdx,r13
	memcpy(f->wpos, s, l);
  41b93e:	48 b8 4a 79 fb ff ff 	movabs rax,0xfffffffffffb794a
  41b945:	ff ff ff 
  41b948:	4c 89 44 24 18       	mov    QWORD PTR [rsp+0x18],r8
  41b94d:	4c 89 fe             	mov    rsi,r15
  41b950:	4d 89 f7             	mov    r15,r14
  41b953:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
  41b958:	4c 01 f0             	add    rax,r14
  41b95b:	ff d0                	call   rax
	f->wpos += l;
  41b95d:	4c 8b 44 24 18       	mov    r8,QWORD PTR [rsp+0x18]
	k = __fwritex(src, l, f);
	FUNLOCK(f);
  41b962:	8b 4c 24 08          	mov    ecx,DWORD PTR [rsp+0x8]
	f->wpos += l;
  41b966:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
  41b96b:	49 01 50 28          	add    QWORD PTR [r8+0x28],rdx
	FUNLOCK(f);
  41b96f:	85 c9                	test   ecx,ecx
  41b971:	75 6d                	jne    41b9e0 <fwrite+0x140>
	return k==l ? nmemb : k/size;
}
  41b973:	48 83 c4 28          	add    rsp,0x28
	return k==l ? nmemb : k/size;
  41b977:	48 89 e8             	mov    rax,rbp
}
  41b97a:	5b                   	pop    rbx
  41b97b:	5d                   	pop    rbp
  41b97c:	41 5c                	pop    r12
  41b97e:	41 5d                	pop    r13
  41b980:	41 5e                	pop    r14
  41b982:	41 5f                	pop    r15
  41b984:	c3                   	ret    
  41b985:	0f 1f 00             	nop    DWORD PTR [rax]
		for (i=l; i && s[i-1] != '\n'; i--);
  41b988:	41 80 7c 1f ff 0a    	cmp    BYTE PTR [r15+rbx*1-0x1],0xa
  41b98e:	48 8d 43 ff          	lea    rax,[rbx-0x1]
  41b992:	74 74                	je     41ba08 <fwrite+0x168>
  41b994:	48 89 c3             	mov    rbx,rax
  41b997:	48 85 db             	test   rbx,rbx
  41b99a:	75 ec                	jne    41b988 <fwrite+0xe8>
  41b99c:	eb 9d                	jmp    41b93b <fwrite+0x9b>
  41b99e:	66 90                	xchg   ax,ax
	if (l > f->wend - f->wpos) return f->write(f, s, l);
  41b9a0:	4c 89 44 24 10       	mov    QWORD PTR [rsp+0x10],r8
  41b9a5:	4c 89 c7             	mov    rdi,r8
  41b9a8:	4c 89 ea             	mov    rdx,r13
  41b9ab:	4c 89 fe             	mov    rsi,r15
  41b9ae:	41 ff 50 48          	call   QWORD PTR [r8+0x48]
  41b9b2:	4c 8b 44 24 10       	mov    r8,QWORD PTR [rsp+0x10]
	FUNLOCK(f);
  41b9b7:	8b 54 24 08          	mov    edx,DWORD PTR [rsp+0x8]
  41b9bb:	85 d2                	test   edx,edx
  41b9bd:	75 24                	jne    41b9e3 <fwrite+0x143>
	return k==l ? nmemb : k/size;
  41b9bf:	49 39 c5             	cmp    r13,rax
  41b9c2:	74 af                	je     41b973 <fwrite+0xd3>
}
  41b9c4:	48 83 c4 28          	add    rsp,0x28
	return k==l ? nmemb : k/size;
  41b9c8:	31 d2                	xor    edx,edx
}
  41b9ca:	5b                   	pop    rbx
  41b9cb:	5d                   	pop    rbp
	return k==l ? nmemb : k/size;
  41b9cc:	49 f7 f4             	div    r12
}
  41b9cf:	41 5c                	pop    r12
  41b9d1:	41 5d                	pop    r13
  41b9d3:	41 5e                	pop    r14
  41b9d5:	41 5f                	pop    r15
  41b9d7:	c3                   	ret    
  41b9d8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41b9df:	00 
	FUNLOCK(f);
  41b9e0:	4c 89 e8             	mov    rax,r13
  41b9e3:	48 ba 40 e2 fb ff ff 	movabs rdx,0xfffffffffffbe240
  41b9ea:	ff ff ff 
  41b9ed:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  41b9f2:	4c 89 c7             	mov    rdi,r8
  41b9f5:	4c 01 f2             	add    rdx,r14
  41b9f8:	ff d2                	call   rdx
  41b9fa:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
  41b9ff:	eb be                	jmp    41b9bf <fwrite+0x11f>
  41ba01:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
			size_t n = f->write(f, s, i);
  41ba08:	4c 89 44 24 10       	mov    QWORD PTR [rsp+0x10],r8
  41ba0d:	4c 89 c7             	mov    rdi,r8
  41ba10:	48 89 da             	mov    rdx,rbx
  41ba13:	4c 89 fe             	mov    rsi,r15
  41ba16:	41 ff 50 48          	call   QWORD PTR [r8+0x48]
			if (n < i) return n;
  41ba1a:	4c 8b 44 24 10       	mov    r8,QWORD PTR [rsp+0x10]
  41ba1f:	48 39 c3             	cmp    rbx,rax
  41ba22:	77 93                	ja     41b9b7 <fwrite+0x117>
			l -= i;
  41ba24:	4c 89 ea             	mov    rdx,r13
	memcpy(f->wpos, s, l);
  41ba27:	49 8b 78 28          	mov    rdi,QWORD PTR [r8+0x28]
			s += i;
  41ba2b:	49 01 df             	add    r15,rbx
			l -= i;
  41ba2e:	48 29 da             	sub    rdx,rbx
  41ba31:	e9 08 ff ff ff       	jmp    41b93e <fwrite+0x9e>
  41ba36:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41ba3d:	00 00 00 
	if (!f->wend && __towrite(f)) return 0;
  41ba40:	48 b8 d0 e2 fb ff ff 	movabs rax,0xfffffffffffbe2d0
  41ba47:	ff ff ff 
  41ba4a:	4c 89 44 24 10       	mov    QWORD PTR [rsp+0x10],r8
  41ba4f:	4c 89 c7             	mov    rdi,r8
  41ba52:	4c 01 f0             	add    rax,r14
  41ba55:	ff d0                	call   rax
  41ba57:	4c 8b 44 24 10       	mov    r8,QWORD PTR [rsp+0x10]
  41ba5c:	85 c0                	test   eax,eax
  41ba5e:	75 10                	jne    41ba70 <fwrite+0x1d0>
	if (l > f->wend - f->wpos) return f->write(f, s, l);
  41ba60:	49 8b 40 20          	mov    rax,QWORD PTR [r8+0x20]
  41ba64:	e9 b8 fe ff ff       	jmp    41b921 <fwrite+0x81>
  41ba69:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	if (!f->wend && __towrite(f)) return 0;
  41ba70:	31 c0                	xor    eax,eax
  41ba72:	e9 40 ff ff ff       	jmp    41b9b7 <fwrite+0x117>
  41ba77:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41ba7e:	00 00 

000000000041ba80 <wcrtomb>:
#include <wchar.h>
#include <errno.h>
#include "internal.h"

size_t wcrtomb(char *restrict s, wchar_t wc, mbstate_t *restrict st)
{
  41ba80:	f3 0f 1e fa          	endbr64 
	if (!s) return 1;
  41ba84:	48 8d 15 f9 ff ff ff 	lea    rdx,[rip+0xfffffffffffffff9]        # 41ba84 <wcrtomb+0x4>
  41ba8b:	49 bb 8c 19 04 00 00 	movabs r11,0x4198c
  41ba92:	00 00 00 
  41ba95:	4c 01 da             	add    rdx,r11
  41ba98:	48 85 ff             	test   rdi,rdi
  41ba9b:	0f 84 82 00 00 00    	je     41bb23 <wcrtomb+0xa3>
  41baa1:	48 89 f9             	mov    rcx,rdi
  41baa4:	89 f0                	mov    eax,esi
	if ((unsigned)wc < 0x80) {
  41baa6:	83 fe 7f             	cmp    esi,0x7f
  41baa9:	76 75                	jbe    41bb20 <wcrtomb+0xa0>
{
  41baab:	48 83 ec 08          	sub    rsp,0x8
  41baaf:	64 48 8b 34 25 00 00 	mov    rsi,QWORD PTR fs:0x0
  41bab6:	00 00 
		*s = wc;
		return 1;
	} else if (MB_CUR_MAX == 1) {
  41bab8:	48 8b b6 b0 00 00 00 	mov    rsi,QWORD PTR [rsi+0xb0]
  41babf:	48 83 3e 00          	cmp    QWORD PTR [rsi],0x0
  41bac3:	74 6b                	je     41bb30 <wcrtomb+0xb0>
			errno = EILSEQ;
			return -1;
		}
		*s = wc;
		return 1;
	} else if ((unsigned)wc < 0x800) {
  41bac5:	3d ff 07 00 00       	cmp    eax,0x7ff
  41baca:	0f 86 c0 00 00 00    	jbe    41bb90 <wcrtomb+0x110>
		*s++ = 0xc0 | (wc>>6);
		*s = 0x80 | (wc&0x3f);
		return 2;
	} else if ((unsigned)wc < 0xd800 || (unsigned)wc-0xe000 < 0x2000) {
  41bad0:	8d b0 00 20 ff ff    	lea    esi,[rax-0xe000]
  41bad6:	81 fe ff 1f 00 00    	cmp    esi,0x1fff
  41badc:	0f 86 ce 00 00 00    	jbe    41bbb0 <wcrtomb+0x130>
  41bae2:	3d ff d7 00 00       	cmp    eax,0xd7ff
  41bae7:	0f 86 c3 00 00 00    	jbe    41bbb0 <wcrtomb+0x130>
		*s++ = 0xe0 | (wc>>12);
		*s++ = 0x80 | ((wc>>6)&0x3f);
		*s = 0x80 | (wc&0x3f);
		return 3;
	} else if ((unsigned)wc-0x10000 < 0x100000) {
  41baed:	8d b0 00 00 ff ff    	lea    esi,[rax-0x10000]
  41baf3:	81 fe ff ff 0f 00    	cmp    esi,0xfffff
  41baf9:	76 55                	jbe    41bb50 <wcrtomb+0xd0>
		*s++ = 0x80 | ((wc>>12)&0x3f);
		*s++ = 0x80 | ((wc>>6)&0x3f);
		*s = 0x80 | (wc&0x3f);
		return 4;
	}
	errno = EILSEQ;
  41bafb:	48 b8 f0 8c fb ff ff 	movabs rax,0xfffffffffffb8cf0
  41bb02:	ff ff ff 
  41bb05:	48 01 d0             	add    rax,rdx
  41bb08:	ff d0                	call   rax
  41bb0a:	c7 00 54 00 00 00    	mov    DWORD PTR [rax],0x54
	return -1;
  41bb10:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
}
  41bb17:	48 83 c4 08          	add    rsp,0x8
  41bb1b:	c3                   	ret    
  41bb1c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		*s = wc;
  41bb20:	40 88 31             	mov    BYTE PTR [rcx],sil
		return 1;
  41bb23:	b8 01 00 00 00       	mov    eax,0x1
}
  41bb28:	c3                   	ret    
  41bb29:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		if (!IS_CODEUNIT(wc)) {
  41bb30:	8d b0 80 20 ff ff    	lea    esi,[rax-0xdf80]
  41bb36:	83 fe 7f             	cmp    esi,0x7f
  41bb39:	77 c0                	ja     41bafb <wcrtomb+0x7b>
		*s = wc;
  41bb3b:	88 01                	mov    BYTE PTR [rcx],al
		return 1;
  41bb3d:	b8 01 00 00 00       	mov    eax,0x1
}
  41bb42:	48 83 c4 08          	add    rsp,0x8
  41bb46:	c3                   	ret    
  41bb47:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41bb4e:	00 00 
		*s++ = 0xf0 | (wc>>18);
  41bb50:	89 c2                	mov    edx,eax
  41bb52:	c1 fa 12             	sar    edx,0x12
  41bb55:	83 ca f0             	or     edx,0xfffffff0
  41bb58:	88 17                	mov    BYTE PTR [rdi],dl
		*s++ = 0x80 | ((wc>>12)&0x3f);
  41bb5a:	89 c2                	mov    edx,eax
  41bb5c:	c1 fa 0c             	sar    edx,0xc
  41bb5f:	83 e2 3f             	and    edx,0x3f
  41bb62:	83 ca 80             	or     edx,0xffffff80
  41bb65:	88 57 01             	mov    BYTE PTR [rdi+0x1],dl
		*s++ = 0x80 | ((wc>>6)&0x3f);
  41bb68:	89 c2                	mov    edx,eax
		*s = 0x80 | (wc&0x3f);
  41bb6a:	83 e0 3f             	and    eax,0x3f
		*s++ = 0x80 | ((wc>>6)&0x3f);
  41bb6d:	c1 fa 06             	sar    edx,0x6
		*s = 0x80 | (wc&0x3f);
  41bb70:	83 c8 80             	or     eax,0xffffff80
		*s++ = 0x80 | ((wc>>6)&0x3f);
  41bb73:	83 e2 3f             	and    edx,0x3f
		*s = 0x80 | (wc&0x3f);
  41bb76:	88 47 03             	mov    BYTE PTR [rdi+0x3],al
		return 4;
  41bb79:	b8 04 00 00 00       	mov    eax,0x4
		*s++ = 0x80 | ((wc>>6)&0x3f);
  41bb7e:	83 ca 80             	or     edx,0xffffff80
  41bb81:	88 57 02             	mov    BYTE PTR [rdi+0x2],dl
		return 4;
  41bb84:	eb 91                	jmp    41bb17 <wcrtomb+0x97>
  41bb86:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41bb8d:	00 00 00 
		*s++ = 0xc0 | (wc>>6);
  41bb90:	89 c2                	mov    edx,eax
		*s = 0x80 | (wc&0x3f);
  41bb92:	83 e0 3f             	and    eax,0x3f
		*s++ = 0xc0 | (wc>>6);
  41bb95:	c1 fa 06             	sar    edx,0x6
		*s = 0x80 | (wc&0x3f);
  41bb98:	83 c8 80             	or     eax,0xffffff80
		*s++ = 0xc0 | (wc>>6);
  41bb9b:	83 ca c0             	or     edx,0xffffffc0
		*s = 0x80 | (wc&0x3f);
  41bb9e:	88 47 01             	mov    BYTE PTR [rdi+0x1],al
		return 2;
  41bba1:	b8 02 00 00 00       	mov    eax,0x2
		*s++ = 0xc0 | (wc>>6);
  41bba6:	88 17                	mov    BYTE PTR [rdi],dl
		return 2;
  41bba8:	e9 6a ff ff ff       	jmp    41bb17 <wcrtomb+0x97>
  41bbad:	0f 1f 00             	nop    DWORD PTR [rax]
		*s++ = 0xe0 | (wc>>12);
  41bbb0:	89 c2                	mov    edx,eax
  41bbb2:	c1 fa 0c             	sar    edx,0xc
  41bbb5:	83 ca e0             	or     edx,0xffffffe0
  41bbb8:	88 11                	mov    BYTE PTR [rcx],dl
		*s++ = 0x80 | ((wc>>6)&0x3f);
  41bbba:	89 c2                	mov    edx,eax
		*s = 0x80 | (wc&0x3f);
  41bbbc:	83 e0 3f             	and    eax,0x3f
		*s++ = 0x80 | ((wc>>6)&0x3f);
  41bbbf:	c1 fa 06             	sar    edx,0x6
		*s = 0x80 | (wc&0x3f);
  41bbc2:	83 c8 80             	or     eax,0xffffff80
		*s++ = 0x80 | ((wc>>6)&0x3f);
  41bbc5:	83 e2 3f             	and    edx,0x3f
		*s = 0x80 | (wc&0x3f);
  41bbc8:	88 41 02             	mov    BYTE PTR [rcx+0x2],al
		return 3;
  41bbcb:	b8 03 00 00 00       	mov    eax,0x3
		*s++ = 0x80 | ((wc>>6)&0x3f);
  41bbd0:	83 ca 80             	or     edx,0xffffff80
  41bbd3:	88 51 01             	mov    BYTE PTR [rcx+0x1],dl
		return 3;
  41bbd6:	e9 3c ff ff ff       	jmp    41bb17 <wcrtomb+0x97>
  41bbdb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000041bbe0 <__stdio_exit>:
	if (f->wpos != f->wbase) f->write(f, 0, 0);
	if (f->rpos != f->rend) f->seek(f, f->rpos-f->rend, SEEK_CUR);
}

void __stdio_exit(void)
{
  41bbe0:	f3 0f 1e fa          	endbr64 
	FILE *f;
	for (f=*__ofl_lock(); f; f=f->next) close_file(f);
  41bbe4:	49 bb 2c 18 04 00 00 	movabs r11,0x4182c
  41bbeb:	00 00 00 
{
  41bbee:	41 54                	push   r12
	for (f=*__ofl_lock(); f; f=f->next) close_file(f);
  41bbf0:	48 b8 f0 e9 fb ff ff 	movabs rax,0xfffffffffffbe9f0
  41bbf7:	ff ff ff 
{
  41bbfa:	55                   	push   rbp
  41bbfb:	48 8d 2d e2 ff ff ff 	lea    rbp,[rip+0xffffffffffffffe2]        # 41bbe4 <__stdio_exit+0x4>
  41bc02:	4c 01 dd             	add    rbp,r11
  41bc05:	53                   	push   rbx
	for (f=*__ofl_lock(); f; f=f->next) close_file(f);
  41bc06:	48 01 e8             	add    rax,rbp
  41bc09:	ff d0                	call   rax
  41bc0b:	48 8b 18             	mov    rbx,QWORD PTR [rax]
  41bc0e:	48 85 db             	test   rbx,rbx
  41bc11:	74 5d                	je     41bc70 <__stdio_exit+0x90>
	FFINALLOCK(f);
  41bc13:	49 bc 20 e1 fb ff ff 	movabs r12,0xfffffffffffbe120
  41bc1a:	ff ff ff 
  41bc1d:	0f 1f 00             	nop    DWORD PTR [rax]
  41bc20:	8b 83 8c 00 00 00    	mov    eax,DWORD PTR [rbx+0x8c]
  41bc26:	85 c0                	test   eax,eax
  41bc28:	78 0a                	js     41bc34 <__stdio_exit+0x54>
  41bc2a:	48 89 df             	mov    rdi,rbx
  41bc2d:	4a 8d 44 25 00       	lea    rax,[rbp+r12*1+0x0]
  41bc32:	ff d0                	call   rax
	if (f->wpos != f->wbase) f->write(f, 0, 0);
  41bc34:	48 8b 43 38          	mov    rax,QWORD PTR [rbx+0x38]
  41bc38:	48 39 43 28          	cmp    QWORD PTR [rbx+0x28],rax
  41bc3c:	74 0a                	je     41bc48 <__stdio_exit+0x68>
  41bc3e:	31 d2                	xor    edx,edx
  41bc40:	31 f6                	xor    esi,esi
  41bc42:	48 89 df             	mov    rdi,rbx
  41bc45:	ff 53 48             	call   QWORD PTR [rbx+0x48]
	if (f->rpos != f->rend) f->seek(f, f->rpos-f->rend, SEEK_CUR);
  41bc48:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
  41bc4c:	48 8b 43 10          	mov    rax,QWORD PTR [rbx+0x10]
  41bc50:	48 39 c6             	cmp    rsi,rax
  41bc53:	0f 84 27 01 00 00    	je     41bd80 <__stdio_exit+0x1a0>
  41bc59:	48 89 df             	mov    rdi,rbx
  41bc5c:	48 29 c6             	sub    rsi,rax
  41bc5f:	ba 01 00 00 00       	mov    edx,0x1
  41bc64:	ff 53 50             	call   QWORD PTR [rbx+0x50]
	for (f=*__ofl_lock(); f; f=f->next) close_file(f);
  41bc67:	48 8b 5b 70          	mov    rbx,QWORD PTR [rbx+0x70]
  41bc6b:	48 85 db             	test   rbx,rbx
  41bc6e:	75 b0                	jne    41bc20 <__stdio_exit+0x40>
	close_file(__stdin_used);
  41bc70:	48 b8 60 4e 14 00 00 	movabs rax,0x144e60
  41bc77:	00 00 00 
  41bc7a:	48 8b 5c 05 00       	mov    rbx,QWORD PTR [rbp+rax*1+0x0]
	if (!f) return;
  41bc7f:	48 85 db             	test   rbx,rbx
  41bc82:	74 3d                	je     41bcc1 <__stdio_exit+0xe1>
	FFINALLOCK(f);
  41bc84:	8b 83 8c 00 00 00    	mov    eax,DWORD PTR [rbx+0x8c]
  41bc8a:	85 c0                	test   eax,eax
  41bc8c:	0f 89 3e 01 00 00    	jns    41bdd0 <__stdio_exit+0x1f0>
	if (f->wpos != f->wbase) f->write(f, 0, 0);
  41bc92:	48 8b 43 38          	mov    rax,QWORD PTR [rbx+0x38]
  41bc96:	48 39 43 28          	cmp    QWORD PTR [rbx+0x28],rax
  41bc9a:	74 0a                	je     41bca6 <__stdio_exit+0xc6>
  41bc9c:	31 d2                	xor    edx,edx
  41bc9e:	31 f6                	xor    esi,esi
  41bca0:	48 89 df             	mov    rdi,rbx
  41bca3:	ff 53 48             	call   QWORD PTR [rbx+0x48]
	if (f->rpos != f->rend) f->seek(f, f->rpos-f->rend, SEEK_CUR);
  41bca6:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
  41bcaa:	48 8b 43 10          	mov    rax,QWORD PTR [rbx+0x10]
  41bcae:	48 39 c6             	cmp    rsi,rax
  41bcb1:	74 0e                	je     41bcc1 <__stdio_exit+0xe1>
  41bcb3:	48 29 c6             	sub    rsi,rax
  41bcb6:	ba 01 00 00 00       	mov    edx,0x1
  41bcbb:	48 89 df             	mov    rdi,rbx
  41bcbe:	ff 53 50             	call   QWORD PTR [rbx+0x50]
	close_file(__stdout_used);
  41bcc1:	48 b8 60 4e 14 00 00 	movabs rax,0x144e60
  41bcc8:	00 00 00 
  41bccb:	48 8b 5c 05 00       	mov    rbx,QWORD PTR [rbp+rax*1+0x0]
	if (!f) return;
  41bcd0:	48 85 db             	test   rbx,rbx
  41bcd3:	74 3d                	je     41bd12 <__stdio_exit+0x132>
	FFINALLOCK(f);
  41bcd5:	8b 83 8c 00 00 00    	mov    eax,DWORD PTR [rbx+0x8c]
  41bcdb:	85 c0                	test   eax,eax
  41bcdd:	0f 89 cd 00 00 00    	jns    41bdb0 <__stdio_exit+0x1d0>
	if (f->wpos != f->wbase) f->write(f, 0, 0);
  41bce3:	48 8b 43 38          	mov    rax,QWORD PTR [rbx+0x38]
  41bce7:	48 39 43 28          	cmp    QWORD PTR [rbx+0x28],rax
  41bceb:	74 0a                	je     41bcf7 <__stdio_exit+0x117>
  41bced:	31 d2                	xor    edx,edx
  41bcef:	31 f6                	xor    esi,esi
  41bcf1:	48 89 df             	mov    rdi,rbx
  41bcf4:	ff 53 48             	call   QWORD PTR [rbx+0x48]
	if (f->rpos != f->rend) f->seek(f, f->rpos-f->rend, SEEK_CUR);
  41bcf7:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
  41bcfb:	48 8b 43 10          	mov    rax,QWORD PTR [rbx+0x10]
  41bcff:	48 39 c6             	cmp    rsi,rax
  41bd02:	74 0e                	je     41bd12 <__stdio_exit+0x132>
  41bd04:	48 29 c6             	sub    rsi,rax
  41bd07:	ba 01 00 00 00       	mov    edx,0x1
  41bd0c:	48 89 df             	mov    rdi,rbx
  41bd0f:	ff 53 50             	call   QWORD PTR [rbx+0x50]
	close_file(__stderr_used);
  41bd12:	48 b8 60 4e 14 00 00 	movabs rax,0x144e60
  41bd19:	00 00 00 
  41bd1c:	4c 8b 64 05 00       	mov    r12,QWORD PTR [rbp+rax*1+0x0]
	if (!f) return;
  41bd21:	4d 85 e4             	test   r12,r12
  41bd24:	0f 84 c6 00 00 00    	je     41bdf0 <__stdio_exit+0x210>
	FFINALLOCK(f);
  41bd2a:	41 8b 84 24 8c 00 00 	mov    eax,DWORD PTR [r12+0x8c]
  41bd31:	00 
  41bd32:	85 c0                	test   eax,eax
  41bd34:	79 62                	jns    41bd98 <__stdio_exit+0x1b8>
	if (f->wpos != f->wbase) f->write(f, 0, 0);
  41bd36:	49 8b 44 24 38       	mov    rax,QWORD PTR [r12+0x38]
  41bd3b:	49 39 44 24 28       	cmp    QWORD PTR [r12+0x28],rax
  41bd40:	74 0c                	je     41bd4e <__stdio_exit+0x16e>
  41bd42:	31 d2                	xor    edx,edx
  41bd44:	31 f6                	xor    esi,esi
  41bd46:	4c 89 e7             	mov    rdi,r12
  41bd49:	41 ff 54 24 48       	call   QWORD PTR [r12+0x48]
	if (f->rpos != f->rend) f->seek(f, f->rpos-f->rend, SEEK_CUR);
  41bd4e:	49 8b 74 24 08       	mov    rsi,QWORD PTR [r12+0x8]
  41bd53:	49 8b 44 24 10       	mov    rax,QWORD PTR [r12+0x10]
  41bd58:	48 39 c6             	cmp    rsi,rax
  41bd5b:	0f 84 8f 00 00 00    	je     41bdf0 <__stdio_exit+0x210>
}
  41bd61:	5b                   	pop    rbx
	if (f->rpos != f->rend) f->seek(f, f->rpos-f->rend, SEEK_CUR);
  41bd62:	48 29 c6             	sub    rsi,rax
  41bd65:	4c 89 e7             	mov    rdi,r12
  41bd68:	49 8b 44 24 50       	mov    rax,QWORD PTR [r12+0x50]
}
  41bd6d:	5d                   	pop    rbp
	if (f->rpos != f->rend) f->seek(f, f->rpos-f->rend, SEEK_CUR);
  41bd6e:	ba 01 00 00 00       	mov    edx,0x1
}
  41bd73:	41 5c                	pop    r12
	if (f->rpos != f->rend) f->seek(f, f->rpos-f->rend, SEEK_CUR);
  41bd75:	ff e0                	jmp    rax
  41bd77:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41bd7e:	00 00 
	for (f=*__ofl_lock(); f; f=f->next) close_file(f);
  41bd80:	48 8b 5b 70          	mov    rbx,QWORD PTR [rbx+0x70]
  41bd84:	48 85 db             	test   rbx,rbx
  41bd87:	0f 85 93 fe ff ff    	jne    41bc20 <__stdio_exit+0x40>
  41bd8d:	e9 de fe ff ff       	jmp    41bc70 <__stdio_exit+0x90>
  41bd92:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	FFINALLOCK(f);
  41bd98:	48 b8 20 e1 fb ff ff 	movabs rax,0xfffffffffffbe120
  41bd9f:	ff ff ff 
  41bda2:	4c 89 e7             	mov    rdi,r12
  41bda5:	48 01 e8             	add    rax,rbp
  41bda8:	ff d0                	call   rax
  41bdaa:	eb 8a                	jmp    41bd36 <__stdio_exit+0x156>
  41bdac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  41bdb0:	48 b8 20 e1 fb ff ff 	movabs rax,0xfffffffffffbe120
  41bdb7:	ff ff ff 
  41bdba:	48 89 df             	mov    rdi,rbx
  41bdbd:	48 01 e8             	add    rax,rbp
  41bdc0:	ff d0                	call   rax
  41bdc2:	e9 1c ff ff ff       	jmp    41bce3 <__stdio_exit+0x103>
  41bdc7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41bdce:	00 00 
  41bdd0:	48 b8 20 e1 fb ff ff 	movabs rax,0xfffffffffffbe120
  41bdd7:	ff ff ff 
  41bdda:	48 89 df             	mov    rdi,rbx
  41bddd:	48 01 e8             	add    rax,rbp
  41bde0:	ff d0                	call   rax
  41bde2:	e9 ab fe ff ff       	jmp    41bc92 <__stdio_exit+0xb2>
  41bde7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41bdee:	00 00 
}
  41bdf0:	5b                   	pop    rbx
  41bdf1:	5d                   	pop    rbp
  41bdf2:	41 5c                	pop    r12
  41bdf4:	c3                   	ret    
  41bdf5:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41bdfc:	00 00 00 
  41bdff:	90                   	nop

000000000041be00 <__ofl_lock>:

static FILE *ofl_head;
static volatile int ofl_lock[1];

FILE **__ofl_lock()
{
  41be00:	f3 0f 1e fa          	endbr64 
	LOCK(ofl_lock);
  41be04:	49 bb 0c 16 04 00 00 	movabs r11,0x4160c
  41be0b:	00 00 00 
{
  41be0e:	53                   	push   rbx
  41be0f:	48 8d 1d ee ff ff ff 	lea    rbx,[rip+0xffffffffffffffee]        # 41be04 <__ofl_lock+0x4>
	LOCK(ofl_lock);
  41be16:	48 b8 68 4e 14 00 00 	movabs rax,0x144e68
  41be1d:	00 00 00 
  41be20:	4c 01 db             	add    rbx,r11
  41be23:	48 8d 3c 03          	lea    rdi,[rbx+rax*1]
  41be27:	48 b8 80 ea fb ff ff 	movabs rax,0xfffffffffffbea80
  41be2e:	ff ff ff 
  41be31:	48 01 d8             	add    rax,rbx
  41be34:	ff d0                	call   rax
	return &ofl_head;
  41be36:	48 b8 70 4e 14 00 00 	movabs rax,0x144e70
  41be3d:	00 00 00 
  41be40:	48 01 d8             	add    rax,rbx
}
  41be43:	5b                   	pop    rbx
  41be44:	c3                   	ret    
  41be45:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41be4c:	00 00 00 
  41be4f:	90                   	nop

000000000041be50 <__ofl_unlock>:

void __ofl_unlock()
{
  41be50:	f3 0f 1e fa          	endbr64 
	UNLOCK(ofl_lock);
  41be54:	48 8d 05 f9 ff ff ff 	lea    rax,[rip+0xfffffffffffffff9]        # 41be54 <__ofl_unlock+0x4>
  41be5b:	49 bb bc 15 04 00 00 	movabs r11,0x415bc
  41be62:	00 00 00 
  41be65:	48 ba 68 4e 14 00 00 	movabs rdx,0x144e68
  41be6c:	00 00 00 
  41be6f:	4c 01 d8             	add    rax,r11
  41be72:	48 8d 3c 10          	lea    rdi,[rax+rdx*1]
  41be76:	48 ba 20 ed fb ff ff 	movabs rdx,0xfffffffffffbed20
  41be7d:	ff ff ff 
  41be80:	48 01 d0             	add    rax,rdx
  41be83:	ff e0                	jmp    rax
  41be85:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41be8c:	00 00 00 
  41be8f:	90                   	nop

000000000041be90 <__lock>:
 * or in an equivalent formulation x is the congestion count or'ed
 * with INT_MIN as a lock flag.
 */

void __lock(volatile int *l)
{
  41be90:	f3 0f 1e fa          	endbr64 
	if (!libc.threads_minus_1) return;
  41be94:	49 bb 7c 15 04 00 00 	movabs r11,0x4157c
  41be9b:	00 00 00 
{
  41be9e:	41 57                	push   r15
  41bea0:	4c 8d 3d ed ff ff ff 	lea    r15,[rip+0xffffffffffffffed]        # 41be94 <__lock+0x4>
	if (!libc.threads_minus_1) return;
  41bea7:	48 b8 30 4c 14 00 00 	movabs rax,0x144c30
  41beae:	00 00 00 
{
  41beb1:	41 56                	push   r14
  41beb3:	4d 01 df             	add    r15,r11
  41beb6:	41 55                	push   r13
  41beb8:	41 54                	push   r12
  41beba:	55                   	push   rbp
  41bebb:	53                   	push   rbx
  41bebc:	48 83 ec 08          	sub    rsp,0x8
	if (!libc.threads_minus_1) return;
  41bec0:	41 8b 44 07 0c       	mov    eax,DWORD PTR [r15+rax*1+0xc]
  41bec5:	85 c0                	test   eax,eax
  41bec7:	0f 84 d3 01 00 00    	je     41c0a0 <__lock+0x210>
  41becd:	49 89 fc             	mov    r12,rdi
	__asm__ __volatile__ (
  41bed0:	31 c0                	xor    eax,eax
  41bed2:	ba 01 00 00 80       	mov    edx,0x80000001
  41bed7:	f0 0f b1 17          	lock cmpxchg DWORD PTR [rdi],edx
  41bedb:	89 c2                	mov    edx,eax
	/* fast path: INT_MIN for the lock, +1 for the congestion */
	int current = a_cas(l, 0, INT_MIN + 1);
	if (!current) return;
  41bedd:	85 c0                	test   eax,eax
  41bedf:	0f 84 bb 01 00 00    	je     41c0a0 <__lock+0x210>
	/* A first spin loop, for medium congestion. */
	for (unsigned i = 0; i < 10; ++i) {
		if (current < 0) current -= INT_MIN + 1;
		// assertion: current >= 0
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41bee5:	8d 88 01 00 00 80    	lea    ecx,[rax-0x7fffffff]
		if (current < 0) current -= INT_MIN + 1;
  41beeb:	79 08                	jns    41bef5 <__lock+0x65>
  41beed:	89 c1                	mov    ecx,eax
  41beef:	81 c2 ff ff ff 7f    	add    edx,0x7fffffff
  41bef5:	89 d0                	mov    eax,edx
  41bef7:	f0 41 0f b1 0c 24    	lock cmpxchg DWORD PTR [r12],ecx
  41befd:	89 c1                	mov    ecx,eax
		if (val == current) return;
  41beff:	39 d0                	cmp    eax,edx
  41bf01:	0f 84 99 01 00 00    	je     41c0a0 <__lock+0x210>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41bf07:	8d 90 01 00 00 80    	lea    edx,[rax-0x7fffffff]
		if (current < 0) current -= INT_MIN + 1;
  41bf0d:	85 c0                	test   eax,eax
  41bf0f:	79 08                	jns    41bf19 <__lock+0x89>
  41bf11:	89 c2                	mov    edx,eax
  41bf13:	81 c1 ff ff ff 7f    	add    ecx,0x7fffffff
  41bf19:	89 c8                	mov    eax,ecx
  41bf1b:	f0 41 0f b1 14 24    	lock cmpxchg DWORD PTR [r12],edx
  41bf21:	89 c2                	mov    edx,eax
		if (val == current) return;
  41bf23:	39 c1                	cmp    ecx,eax
  41bf25:	0f 84 75 01 00 00    	je     41c0a0 <__lock+0x210>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41bf2b:	8d 88 01 00 00 80    	lea    ecx,[rax-0x7fffffff]
		if (current < 0) current -= INT_MIN + 1;
  41bf31:	85 c0                	test   eax,eax
  41bf33:	79 08                	jns    41bf3d <__lock+0xad>
  41bf35:	89 c1                	mov    ecx,eax
  41bf37:	81 c2 ff ff ff 7f    	add    edx,0x7fffffff
  41bf3d:	89 d0                	mov    eax,edx
  41bf3f:	f0 41 0f b1 0c 24    	lock cmpxchg DWORD PTR [r12],ecx
  41bf45:	89 c1                	mov    ecx,eax
		if (val == current) return;
  41bf47:	39 c2                	cmp    edx,eax
  41bf49:	0f 84 51 01 00 00    	je     41c0a0 <__lock+0x210>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41bf4f:	8d 90 01 00 00 80    	lea    edx,[rax-0x7fffffff]
		if (current < 0) current -= INT_MIN + 1;
  41bf55:	85 c0                	test   eax,eax
  41bf57:	79 08                	jns    41bf61 <__lock+0xd1>
  41bf59:	89 c2                	mov    edx,eax
  41bf5b:	81 c1 ff ff ff 7f    	add    ecx,0x7fffffff
  41bf61:	89 c8                	mov    eax,ecx
  41bf63:	f0 41 0f b1 14 24    	lock cmpxchg DWORD PTR [r12],edx
  41bf69:	89 c2                	mov    edx,eax
		if (val == current) return;
  41bf6b:	39 c1                	cmp    ecx,eax
  41bf6d:	0f 84 2d 01 00 00    	je     41c0a0 <__lock+0x210>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41bf73:	8d 88 01 00 00 80    	lea    ecx,[rax-0x7fffffff]
		if (current < 0) current -= INT_MIN + 1;
  41bf79:	85 c0                	test   eax,eax
  41bf7b:	79 08                	jns    41bf85 <__lock+0xf5>
  41bf7d:	89 c1                	mov    ecx,eax
  41bf7f:	81 c2 ff ff ff 7f    	add    edx,0x7fffffff
  41bf85:	89 d0                	mov    eax,edx
  41bf87:	f0 41 0f b1 0c 24    	lock cmpxchg DWORD PTR [r12],ecx
  41bf8d:	89 c1                	mov    ecx,eax
		if (val == current) return;
  41bf8f:	39 c2                	cmp    edx,eax
  41bf91:	0f 84 09 01 00 00    	je     41c0a0 <__lock+0x210>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41bf97:	8d 90 01 00 00 80    	lea    edx,[rax-0x7fffffff]
		if (current < 0) current -= INT_MIN + 1;
  41bf9d:	85 c0                	test   eax,eax
  41bf9f:	0f 88 0b 01 00 00    	js     41c0b0 <__lock+0x220>
  41bfa5:	89 c8                	mov    eax,ecx
  41bfa7:	f0 41 0f b1 14 24    	lock cmpxchg DWORD PTR [r12],edx
  41bfad:	89 c2                	mov    edx,eax
		if (val == current) return;
  41bfaf:	39 c1                	cmp    ecx,eax
  41bfb1:	0f 84 e9 00 00 00    	je     41c0a0 <__lock+0x210>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41bfb7:	8d 88 01 00 00 80    	lea    ecx,[rax-0x7fffffff]
		if (current < 0) current -= INT_MIN + 1;
  41bfbd:	85 c0                	test   eax,eax
  41bfbf:	0f 88 fb 00 00 00    	js     41c0c0 <__lock+0x230>
  41bfc5:	89 d0                	mov    eax,edx
  41bfc7:	f0 41 0f b1 0c 24    	lock cmpxchg DWORD PTR [r12],ecx
  41bfcd:	89 c1                	mov    ecx,eax
		if (val == current) return;
  41bfcf:	39 c2                	cmp    edx,eax
  41bfd1:	0f 84 c9 00 00 00    	je     41c0a0 <__lock+0x210>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41bfd7:	8d 90 01 00 00 80    	lea    edx,[rax-0x7fffffff]
		if (current < 0) current -= INT_MIN + 1;
  41bfdd:	85 c0                	test   eax,eax
  41bfdf:	0f 88 eb 00 00 00    	js     41c0d0 <__lock+0x240>
  41bfe5:	89 c8                	mov    eax,ecx
  41bfe7:	f0 41 0f b1 14 24    	lock cmpxchg DWORD PTR [r12],edx
  41bfed:	89 c2                	mov    edx,eax
		if (val == current) return;
  41bfef:	39 c1                	cmp    ecx,eax
  41bff1:	0f 84 a9 00 00 00    	je     41c0a0 <__lock+0x210>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41bff7:	8d 88 01 00 00 80    	lea    ecx,[rax-0x7fffffff]
		if (current < 0) current -= INT_MIN + 1;
  41bffd:	85 c0                	test   eax,eax
  41bfff:	0f 88 db 00 00 00    	js     41c0e0 <__lock+0x250>
  41c005:	89 d0                	mov    eax,edx
  41c007:	f0 41 0f b1 0c 24    	lock cmpxchg DWORD PTR [r12],ecx
  41c00d:	89 c1                	mov    ecx,eax
		if (val == current) return;
  41c00f:	39 c2                	cmp    edx,eax
  41c011:	0f 84 89 00 00 00    	je     41c0a0 <__lock+0x210>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41c017:	8d 90 01 00 00 80    	lea    edx,[rax-0x7fffffff]
		if (current < 0) current -= INT_MIN + 1;
  41c01d:	85 c0                	test   eax,eax
  41c01f:	0f 88 cb 00 00 00    	js     41c0f0 <__lock+0x260>
  41c025:	89 c8                	mov    eax,ecx
  41c027:	f0 41 0f b1 14 24    	lock cmpxchg DWORD PTR [r12],edx
		if (val == current) return;
  41c02d:	39 c1                	cmp    ecx,eax
  41c02f:	74 6f                	je     41c0a0 <__lock+0x210>
	__asm__ __volatile__(
  41c031:	bb 01 00 00 00       	mov    ebx,0x1
  41c036:	f0 41 0f c1 1c 24    	lock xadd DWORD PTR [r12],ebx
	return __cos_syscall(n, a1, a2, a3, a4, 0, 0, 0);
  41c03c:	48 bd d0 ce fa ff ff 	movabs rbp,0xfffffffffffaced0
  41c043:	ff ff ff 
		current = val;
	}
	// Spinning failed, so mark ourselves as being inside the CS.
	current = a_fetch_add(l, 1) + 1;
  41c046:	83 c3 01             	add    ebx,0x1
  41c049:	eb 19                	jmp    41c064 <__lock+0x1d4>
  41c04b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		if (current < 0) {
			__futexwait(l, current, 1);
			current -= INT_MIN + 1;
		}
		/* assertion: current > 0, the count includes us already. */
		int val = a_cas(l, current, INT_MIN + current);
  41c050:	8d 9a 00 00 00 80    	lea    ebx,[rdx-0x80000000]
	__asm__ __volatile__ (
  41c056:	89 d0                	mov    eax,edx
  41c058:	f0 41 0f b1 1c 24    	lock cmpxchg DWORD PTR [r12],ebx
  41c05e:	89 c3                	mov    ebx,eax
		if (val == current) return;
  41c060:	39 c2                	cmp    edx,eax
  41c062:	74 3c                	je     41c0a0 <__lock+0x210>
		if (current < 0) {
  41c064:	89 da                	mov    edx,ebx
  41c066:	85 db                	test   ebx,ebx
  41c068:	79 e6                	jns    41c050 <__lock+0x1c0>
	__syscall(SYS_futex, addr, FUTEX_WAIT|priv, val, 0) != -ENOSYS ||
  41c06a:	4c 63 f3             	movsxd r14,ebx
  41c06d:	6a 00                	push   0x0
  41c06f:	4c 89 e6             	mov    rsi,r12
  41c072:	45 31 c9             	xor    r9d,r9d
  41c075:	6a 00                	push   0x0
  41c077:	4c 89 f1             	mov    rcx,r14
  41c07a:	45 31 c0             	xor    r8d,r8d
  41c07d:	ba 80 00 00 00       	mov    edx,0x80
  41c082:	bf ca 00 00 00       	mov    edi,0xca
  41c087:	4e 8d 6c 3d 00       	lea    r13,[rbp+r15*1+0x0]
  41c08c:	41 ff d5             	call   r13
  41c08f:	59                   	pop    rcx
  41c090:	5e                   	pop    rsi
  41c091:	48 83 f8 da          	cmp    rax,0xffffffffffffffda
  41c095:	74 69                	je     41c100 <__lock+0x270>
			current -= INT_MIN + 1;
  41c097:	8d 93 ff ff ff 7f    	lea    edx,[rbx+0x7fffffff]
  41c09d:	eb b1                	jmp    41c050 <__lock+0x1c0>
  41c09f:	90                   	nop
		current = val;
	}
}
  41c0a0:	48 83 c4 08          	add    rsp,0x8
  41c0a4:	5b                   	pop    rbx
  41c0a5:	5d                   	pop    rbp
  41c0a6:	41 5c                	pop    r12
  41c0a8:	41 5d                	pop    r13
  41c0aa:	41 5e                	pop    r14
  41c0ac:	41 5f                	pop    r15
  41c0ae:	c3                   	ret    
  41c0af:	90                   	nop
		if (current < 0) current -= INT_MIN + 1;
  41c0b0:	89 c2                	mov    edx,eax
  41c0b2:	81 c1 ff ff ff 7f    	add    ecx,0x7fffffff
  41c0b8:	e9 e8 fe ff ff       	jmp    41bfa5 <__lock+0x115>
  41c0bd:	0f 1f 00             	nop    DWORD PTR [rax]
  41c0c0:	89 c1                	mov    ecx,eax
  41c0c2:	81 c2 ff ff ff 7f    	add    edx,0x7fffffff
  41c0c8:	e9 f8 fe ff ff       	jmp    41bfc5 <__lock+0x135>
  41c0cd:	0f 1f 00             	nop    DWORD PTR [rax]
  41c0d0:	89 c2                	mov    edx,eax
  41c0d2:	81 c1 ff ff ff 7f    	add    ecx,0x7fffffff
  41c0d8:	e9 08 ff ff ff       	jmp    41bfe5 <__lock+0x155>
  41c0dd:	0f 1f 00             	nop    DWORD PTR [rax]
  41c0e0:	89 c1                	mov    ecx,eax
  41c0e2:	81 c2 ff ff ff 7f    	add    edx,0x7fffffff
  41c0e8:	e9 18 ff ff ff       	jmp    41c005 <__lock+0x175>
  41c0ed:	0f 1f 00             	nop    DWORD PTR [rax]
  41c0f0:	89 c2                	mov    edx,eax
  41c0f2:	81 c1 ff ff ff 7f    	add    ecx,0x7fffffff
  41c0f8:	e9 28 ff ff ff       	jmp    41c025 <__lock+0x195>
  41c0fd:	0f 1f 00             	nop    DWORD PTR [rax]
  41c100:	6a 00                	push   0x0
  41c102:	31 d2                	xor    edx,edx
  41c104:	45 31 c9             	xor    r9d,r9d
  41c107:	45 31 c0             	xor    r8d,r8d
  41c10a:	6a 00                	push   0x0
  41c10c:	4c 89 f1             	mov    rcx,r14
  41c10f:	4c 89 e6             	mov    rsi,r12
  41c112:	bf ca 00 00 00       	mov    edi,0xca
  41c117:	41 ff d5             	call   r13
  41c11a:	58                   	pop    rax
  41c11b:	5a                   	pop    rdx
  41c11c:	e9 76 ff ff ff       	jmp    41c097 <__lock+0x207>
  41c121:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41c128:	00 00 00 
  41c12b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000041c130 <__unlock>:

void __unlock(volatile int *l)
{
  41c130:	f3 0f 1e fa          	endbr64 
	/* Check l[0] to see if we are multi-threaded. */
	if (l[0] < 0) {
  41c134:	49 bb dc 12 04 00 00 	movabs r11,0x412dc
  41c13b:	00 00 00 
{
  41c13e:	41 57                	push   r15
  41c140:	4c 8d 3d ed ff ff ff 	lea    r15,[rip+0xffffffffffffffed]        # 41c134 <__unlock+0x4>
  41c147:	55                   	push   rbp
  41c148:	4d 01 df             	add    r15,r11
  41c14b:	53                   	push   rbx
	if (l[0] < 0) {
  41c14c:	8b 07                	mov    eax,DWORD PTR [rdi]
  41c14e:	85 c0                	test   eax,eax
  41c150:	78 0e                	js     41c160 <__unlock+0x30>
		if (a_fetch_add(l, -(INT_MIN + 1)) != (INT_MIN + 1)) {
			__wake(l, 1, 1);
		}
	}
}
  41c152:	5b                   	pop    rbx
  41c153:	5d                   	pop    rbp
  41c154:	41 5f                	pop    r15
  41c156:	c3                   	ret    
  41c157:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41c15e:	00 00 
  41c160:	48 89 fd             	mov    rbp,rdi
	__asm__ __volatile__(
  41c163:	b8 ff ff ff 7f       	mov    eax,0x7fffffff
  41c168:	f0 0f c1 07          	lock xadd DWORD PTR [rdi],eax
		if (a_fetch_add(l, -(INT_MIN + 1)) != (INT_MIN + 1)) {
  41c16c:	3d 01 00 00 80       	cmp    eax,0x80000001
  41c171:	74 df                	je     41c152 <__unlock+0x22>
	return __cos_syscall(n, a1, a2, a3, 0, 0, 0, 0);
  41c173:	6a 00                	push   0x0
  41c175:	48 89 fe             	mov    rsi,rdi
  41c178:	b9 01 00 00 00       	mov    ecx,0x1
  41c17d:	45 31 c9             	xor    r9d,r9d
  41c180:	6a 00                	push   0x0
  41c182:	45 31 c0             	xor    r8d,r8d
  41c185:	ba 81 00 00 00       	mov    edx,0x81
  41c18a:	bf ca 00 00 00       	mov    edi,0xca
  41c18f:	48 bb d0 ce fa ff ff 	movabs rbx,0xfffffffffffaced0
  41c196:	ff ff ff 
  41c199:	4c 01 fb             	add    rbx,r15
  41c19c:	ff d3                	call   rbx
	__syscall(SYS_futex, addr, FUTEX_WAKE|priv, cnt) != -ENOSYS ||
  41c19e:	59                   	pop    rcx
  41c19f:	5e                   	pop    rsi
  41c1a0:	48 83 f8 da          	cmp    rax,0xffffffffffffffda
  41c1a4:	75 ac                	jne    41c152 <__unlock+0x22>
  41c1a6:	6a 00                	push   0x0
  41c1a8:	ba 01 00 00 00       	mov    edx,0x1
  41c1ad:	45 31 c9             	xor    r9d,r9d
  41c1b0:	45 31 c0             	xor    r8d,r8d
  41c1b3:	6a 00                	push   0x0
  41c1b5:	b9 01 00 00 00       	mov    ecx,0x1
  41c1ba:	48 89 ee             	mov    rsi,rbp
  41c1bd:	bf ca 00 00 00       	mov    edi,0xca
  41c1c2:	ff d3                	call   rbx
  41c1c4:	58                   	pop    rax
  41c1c5:	5a                   	pop    rdx
}
  41c1c6:	eb 8a                	jmp    41c152 <__unlock+0x22>
