
sched.pfprr_quantum_static.global.sched:     file format elf64-x86-64


Disassembly of section .text:

0000000000400000 <printc>:
	return cos_print_str(s, strlen(s));
}

static int  __attribute__((format(printf, 1, 2)))
printc(char *fmt, ...)
{
  400000:	f3 0f 1e fa          	endbr64 
  400004:	55                   	push   rbp
  400005:	49 89 fa             	mov    r10,rdi
  400008:	48 89 e5             	mov    rbp,rsp
  40000b:	48 81 ec 90 01 00 00 	sub    rsp,0x190
  400012:	48 89 b5 58 ff ff ff 	mov    QWORD PTR [rbp-0xa8],rsi
  400019:	48 89 95 60 ff ff ff 	mov    QWORD PTR [rbp-0xa0],rdx
  400020:	48 89 8d 68 ff ff ff 	mov    QWORD PTR [rbp-0x98],rcx
  400027:	4c 89 85 70 ff ff ff 	mov    QWORD PTR [rbp-0x90],r8
  40002e:	4c 89 8d 78 ff ff ff 	mov    QWORD PTR [rbp-0x88],r9
  400035:	84 c0                	test   al,al
  400037:	74 20                	je     400059 <printc+0x59>
  400039:	0f 29 45 80          	movaps XMMWORD PTR [rbp-0x80],xmm0
  40003d:	0f 29 4d 90          	movaps XMMWORD PTR [rbp-0x70],xmm1
  400041:	0f 29 55 a0          	movaps XMMWORD PTR [rbp-0x60],xmm2
  400045:	0f 29 5d b0          	movaps XMMWORD PTR [rbp-0x50],xmm3
  400049:	0f 29 65 c0          	movaps XMMWORD PTR [rbp-0x40],xmm4
  40004d:	0f 29 6d d0          	movaps XMMWORD PTR [rbp-0x30],xmm5
  400051:	0f 29 75 e0          	movaps XMMWORD PTR [rbp-0x20],xmm6
  400055:	0f 29 7d f0          	movaps XMMWORD PTR [rbp-0x10],xmm7
	char    s[180];
	va_list arg_ptr;
	size_t  ret;

	va_start(arg_ptr, fmt);
  400059:	48 8d 45 10          	lea    rax,[rbp+0x10]
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40005d:	4c 89 d2             	mov    rdx,r10
  400060:	48 8d 8d 78 fe ff ff 	lea    rcx,[rbp-0x188]
	va_start(arg_ptr, fmt);
  400067:	c7 85 78 fe ff ff 08 	mov    DWORD PTR [rbp-0x188],0x8
  40006e:	00 00 00 
  400071:	48 89 85 80 fe ff ff 	mov    QWORD PTR [rbp-0x180],rax
  400078:	48 8d 85 50 ff ff ff 	lea    rax,[rbp-0xb0]
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40007f:	be b4 00 00 00       	mov    esi,0xb4
  400084:	48 8d bd 90 fe ff ff 	lea    rdi,[rbp-0x170]
	va_start(arg_ptr, fmt);
  40008b:	48 89 85 88 fe ff ff 	mov    QWORD PTR [rbp-0x178],rax
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  400092:	48 b8 20 80 41 00 00 	movabs rax,0x418020
  400099:	00 00 00 
	va_start(arg_ptr, fmt);
  40009c:	c7 85 7c fe ff ff 30 	mov    DWORD PTR [rbp-0x184],0x30
  4000a3:	00 00 00 
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  4000a6:	ff d0                	call   rax
	va_end(arg_ptr);
	ret = cos_print_str(s, ret);
  4000a8:	48 8d bd 90 fe ff ff 	lea    rdi,[rbp-0x170]
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  4000af:	89 c6                	mov    esi,eax
	ret = cos_print_str(s, ret);
  4000b1:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4000b8:	00 00 00 
  4000bb:	ff d0                	call   rax

	return ret;
}
  4000bd:	c9                   	leave  
  4000be:	c3                   	ret    
  4000bf:	90                   	nop

00000000004000c0 <exit_init_thd>:

struct slm_thd *slm_thd_current_extern(void);

static __attribute__((noreturn)) void
exit_init_thd(void)
{
  4000c0:	f3 0f 1e fa          	endbr64 
	struct slm_thd *current = slm_thd_current_extern();
  4000c4:	48 b8 90 1e 40 00 00 	movabs rax,0x401e90
  4000cb:	00 00 00 
{
  4000ce:	55                   	push   rbp
  4000cf:	48 89 e5             	mov    rbp,rsp
  4000d2:	41 56                	push   r14
  4000d4:	41 55                	push   r13
  4000d6:	49 bd c0 5e 5a 00 00 	movabs r13,0x5a5ec0
  4000dd:	00 00 00 
  4000e0:	41 54                	push   r12
		cached = __slm_cs_data(cs, &owner, &contended);

		if (unlikely(owner)) {
			int ret;

			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  4000e2:	49 bc 50 5f 41 00 00 	movabs r12,0x415f50
  4000e9:	00 00 00 
  4000ec:	53                   	push   rbx
  4000ed:	48 bb d0 35 41 00 00 	movabs rbx,0x4135d0
  4000f4:	00 00 00 
	struct slm_thd *current = slm_thd_current_extern();
  4000f7:	ff d0                	call   rax

	if (cos_coreid() == 0) printc("\tScheduler %ld: Exiting thread %ld from component %ld\n", cos_compid(), cos_thdid(), (compid_t)cos_inv_token());
  4000f9:	48 bf a0 ec 41 00 00 	movabs rdi,0x41eca0
  400100:	00 00 00 
  400103:	49 b8 00 00 40 00 00 	movabs r8,0x400000
  40010a:	00 00 00 
	struct slm_thd *current = slm_thd_current_extern();
  40010d:	49 89 c6             	mov    r14,rax
static inline long
get_stk_data(int offset)
{
	unsigned long curr_stk_pointer;

	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  400110:	48 89 e0             	mov    rax,rsp
	 * access.  We want to find the struct cos_stk (see the stkmgr
	 * interface) so that we can then offset into it and get the
	 * cpu_id.  This struct is at the _top_ of the current stack,
	 * and cpu_id is at the top of the struct (it is a u32_t).
	 */
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  400113:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
	if (cos_coreid() == 0) printc("\tScheduler %ld: Exiting thread %ld from component %ld\n", cos_compid(), cos_thdid(), (compid_t)cos_inv_token());
  400119:	48 8b 88 e8 1f 00 00 	mov    rcx,QWORD PTR [rax+0x1fe8]
typedef u16_t cos_thdid_t;

static thdid_t
cos_thdid(void)
{
	return cos_get_thd_id();
  400120:	0f b7 90 f0 1f 00 00 	movzx  edx,WORD PTR [rax+0x1ff0]
  400127:	48 b8 40 b0 42 00 00 	movabs rax,0x42b040
  40012e:	00 00 00 
  400131:	48 8b 30             	mov    rsi,QWORD PTR [rax]
  400134:	31 c0                	xor    eax,eax
  400136:	41 ff d0             	call   r8
	assert(current);
  400139:	4d 85 f6             	test   r14,r14
  40013c:	0f 84 23 01 00 00    	je     400265 <exit_init_thd+0x1a5>
		tok    = cos_sched_sync();
  400142:	ff d3                	call   rbx
  400144:	41 89 c1             	mov    r9d,eax
 * - @ret - a *cached* version of the critical section metadata to be passed into `__slm_cs_cas`.
 */
static inline slm_cs_cached_t
__slm_cs_data(struct slm_cs *cs, struct slm_thd **thd, int *contention)
{
	unsigned long oc = ps_load(&cs->owner_contention);
  400147:	49 8b 45 00          	mov    rax,QWORD PTR [r13+0x0]
		if (unlikely(owner)) {
  40014b:	48 89 c1             	mov    rcx,rax
  40014e:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  400152:	0f 85 c9 00 00 00    	jne    400221 <exit_init_thd+0x161>
 */
static inline int
ps_cas(unsigned long *target, unsigned long old, unsigned long updated)
{
        char z;
        __asm__ __volatile__("lock " PS_CAS_STR
  400158:	f0 4d 0f b1 75 00    	lock cmpxchg QWORD PTR [r13+0x0],r14
  40015e:	0f 94 c0             	sete   al

			continue;
		}

		/* success! common case */
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  400161:	84 c0                	test   al,al
  400163:	74 dd                	je     400142 <exit_init_thd+0x82>

	slm_cs_enter(current, SLM_CS_NONE);
	slm_thd_deinit(current);		/* I'm out! */
  400165:	48 b8 10 5f 41 00 00 	movabs rax,0x415f10
  40016c:	00 00 00 
  40016f:	4c 89 f7             	mov    rdi,r14

		tok    = cos_sched_sync();
		cached = __slm_cs_data(cs, &current, &contention);
		/* Another thread attempted to enter the critical section */
		if (unlikely(contention)) {
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  400172:	49 bc b0 5f 41 00 00 	movabs r12,0x415fb0
  400179:	00 00 00 
  40017c:	ff d0                	call   rax
	while (ret != 0) {
  40017e:	eb 0d                	jmp    40018d <exit_init_thd+0xcd>
  400180:	f0 49 0f b1 55 00    	lock cmpxchg QWORD PTR [r13+0x0],rdx
  400186:	0f 94 c0             	sete   al
  400189:	84 c0                	test   al,al
  40018b:	75 24                	jne    4001b1 <exit_init_thd+0xf1>
		tok    = cos_sched_sync();
  40018d:	ff d3                	call   rbx
  40018f:	89 c1                	mov    ecx,eax
  400191:	49 8b 45 00          	mov    rax,QWORD PTR [r13+0x0]
		if (unlikely(contention)) {
  400195:	48 89 c2             	mov    rdx,rax
  400198:	83 e2 01             	and    edx,0x1
  40019b:	74 e3                	je     400180 <exit_init_thd+0xc0>
	/* least significant bit signifies contention */
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  40019d:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  4001a0:	48 89 c2             	mov    rdx,rax
  4001a3:	4c 89 ef             	mov    rdi,r13
  4001a6:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  4001aa:	41 ff d4             	call   r12
  4001ad:	85 c0                	test   eax,eax
  4001af:	75 dc                	jne    40018d <exit_init_thd+0xcd>
	slm_cs_exit(NULL, SLM_CS_NONE);

	/* Switch to the scheduler thread */
	if (cos_defswitch(BOOT_CAPTBL_SELF_INITTHD_CPU_BASE, TCAP_PRIO_MAX, TCAP_RES_INF, cos_sched_sync())) BUG();
  4001b1:	ff d3                	call   rbx
  4001b3:	be 01 00 00 00       	mov    esi,0x1
  4001b8:	48 c7 c2 ff ff ff ff 	mov    rdx,0xffffffffffffffff
  4001bf:	bf 28 00 00 00       	mov    edi,0x28
  4001c4:	89 c1                	mov    ecx,eax
  4001c6:	48 b8 70 e1 40 00 00 	movabs rax,0x40e170
  4001cd:	00 00 00 
  4001d0:	ff d0                	call   rax
	return cos_print_str(s, strlen(s));
  4001d2:	be 11 00 00 00       	mov    esi,0x11
  4001d7:	85 c0                	test   eax,eax
  4001d9:	75 23                	jne    4001fe <exit_init_thd+0x13e>
  4001db:	48 bf a4 ed 41 00 00 	movabs rdi,0x41eda4
  4001e2:	00 00 00 
  4001e5:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4001ec:	00 00 00 
  4001ef:	ff d0                	call   rax

	BUG();
  4001f1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4001f8:	00 00 00 00 
  4001fc:	0f 0b                	ud2    
  4001fe:	48 bf 92 ed 41 00 00 	movabs rdi,0x41ed92
  400205:	00 00 00 
  400208:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40020f:	00 00 00 
  400212:	ff d0                	call   rax
	if (cos_defswitch(BOOT_CAPTBL_SELF_INITTHD_CPU_BASE, TCAP_PRIO_MAX, TCAP_RES_INF, cos_sched_sync())) BUG();
  400214:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40021b:	00 00 00 00 
  40021f:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  400221:	41 89 c0             	mov    r8d,eax
  400224:	4c 89 f2             	mov    rdx,r14
  400227:	48 89 c6             	mov    rsi,rax
  40022a:	4c 89 ef             	mov    rdi,r13
  40022d:	41 83 e0 01          	and    r8d,0x1
  400231:	41 ff d4             	call   r12
			assert(ret != -EBUSY);
  400234:	83 f8 f0             	cmp    eax,0xfffffff0
  400237:	0f 85 05 ff ff ff    	jne    400142 <exit_init_thd+0x82>
  40023d:	48 bf 38 ed 41 00 00 	movabs rdi,0x41ed38
  400244:	00 00 00 
  400247:	be 59 00 00 00       	mov    esi,0x59
  40024c:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  400253:	00 00 00 
  400256:	ff d0                	call   rax
  400258:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40025f:	00 00 00 00 
  400263:	0f 0b                	ud2    
  400265:	48 bf d8 ec 41 00 00 	movabs rdi,0x41ecd8
  40026c:	00 00 00 
  40026f:	be 59 00 00 00       	mov    esi,0x59
  400274:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40027b:	00 00 00 
  40027e:	ff d0                	call   rax
	assert(current);
  400280:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400287:	00 00 00 00 
  40028b:	0f 0b                	ud2    
  40028d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000400290 <calculate_initialization_schedule>:
{
  400290:	f3 0f 1e fa          	endbr64 
	ret = args_get_entry("execute", &exec_entries);
  400294:	48 bf b6 ed 41 00 00 	movabs rdi,0x41edb6
  40029b:	00 00 00 
{
  40029e:	55                   	push   rbp
	ret = args_get_entry("execute", &exec_entries);
  40029f:	48 b8 90 c5 40 00 00 	movabs rax,0x40c590
  4002a6:	00 00 00 
{
  4002a9:	48 89 e5             	mov    rbp,rsp
  4002ac:	41 57                	push   r15
  4002ae:	41 56                	push   r14
	ret = args_get_entry("execute", &exec_entries);
  4002b0:	48 8d b5 70 ff ff ff 	lea    rsi,[rbp-0x90]
{
  4002b7:	41 55                	push   r13
  4002b9:	41 54                	push   r12
  4002bb:	53                   	push   rbx
  4002bc:	48 83 ec 78          	sub    rsp,0x78
	ret = args_get_entry("execute", &exec_entries);
  4002c0:	ff d0                	call   rax
	assert(!ret);
  4002c2:	85 c0                	test   eax,eax
  4002c4:	0f 85 4e 02 00 00    	jne    400518 <calculate_initialization_schedule+0x288>
	printc("\tSched %ld: %d components that need execution\n", cos_compid(), args_len(&exec_entries));
  4002ca:	48 8d bd 70 ff ff ff 	lea    rdi,[rbp-0x90]
  4002d1:	48 b8 e0 be 40 00 00 	movabs rax,0x40bee0
  4002d8:	00 00 00 
		if (strcmp(exec_type, "init")) BUG();	/* TODO: no support for hierarchical scheduling yet */
  4002db:	49 bf 65 ee 41 00 00 	movabs r15,0x41ee65
  4002e2:	00 00 00 
	printc("\tSched %ld: %ld is the %ldth component to initialize\n", cos_compid(), cid, init_schedule_off);
  4002e5:	48 bb 40 20 46 00 00 	movabs rbx,0x462040
  4002ec:	00 00 00 
	printc("\tSched %ld: %d components that need execution\n", cos_compid(), args_len(&exec_entries));
  4002ef:	ff d0                	call   rax
  4002f1:	48 bf e8 ed 41 00 00 	movabs rdi,0x41ede8
  4002f8:	00 00 00 
  4002fb:	48 b9 00 00 40 00 00 	movabs rcx,0x400000
  400302:	00 00 00 
	printc("\tSched %ld: %ld is the %ldth component to initialize\n", cos_compid(), cid, init_schedule_off);
  400305:	49 be 80 ee 41 00 00 	movabs r14,0x41ee80
  40030c:	00 00 00 
	printc("\tSched %ld: %d components that need execution\n", cos_compid(), args_len(&exec_entries));
  40030f:	89 c2                	mov    edx,eax
  400311:	48 b8 40 b0 42 00 00 	movabs rax,0x42b040
  400318:	00 00 00 
  40031b:	48 8b 30             	mov    rsi,QWORD PTR [rax]
  40031e:	31 c0                	xor    eax,eax
  400320:	ff d1                	call   rcx
	for (cont = args_iter(&exec_entries, &i, &curr) ; cont ; cont = args_iter_next(&i, &curr)) {
  400322:	48 8d 55 90          	lea    rdx,[rbp-0x70]
  400326:	48 8d 75 b0          	lea    rsi,[rbp-0x50]
  40032a:	48 b8 b0 bf 40 00 00 	movabs rax,0x40bfb0
  400331:	00 00 00 
  400334:	48 8d bd 70 ff ff ff 	lea    rdi,[rbp-0x90]
  40033b:	ff d0                	call   rax
  40033d:	85 c0                	test   eax,eax
  40033f:	0f 84 1e 01 00 00    	je     400463 <calculate_initialization_schedule+0x1d3>
		compid_t id        = atoi(args_key(&curr, &keylen));
  400345:	48 8d b5 6c ff ff ff 	lea    rsi,[rbp-0x94]
  40034c:	48 8d 7d 90          	lea    rdi,[rbp-0x70]
  400350:	48 b8 30 be 40 00 00 	movabs rax,0x40be30
  400357:	00 00 00 
  40035a:	ff d0                	call   rax
  40035c:	48 89 c7             	mov    rdi,rax
  40035f:	48 b8 70 81 41 00 00 	movabs rax,0x418170
  400366:	00 00 00 
  400369:	ff d0                	call   rax
		char    *exec_type = args_value(&curr);
  40036b:	48 8d 7d 90          	lea    rdi,[rbp-0x70]
		compid_t id        = atoi(args_key(&curr, &keylen));
  40036f:	4c 63 e8             	movsxd r13,eax
		char    *exec_type = args_value(&curr);
  400372:	48 b8 a0 be 40 00 00 	movabs rax,0x40bea0
  400379:	00 00 00 
  40037c:	ff d0                	call   rax
  40037e:	48 89 c7             	mov    rdi,rax
		assert(exec_type);
  400381:	48 85 c0             	test   rax,rax
  400384:	0f 84 16 01 00 00    	je     4004a0 <calculate_initialization_schedule+0x210>
	} while (0)

static inline long
cos_spd_id(void)
{
	return __cosrt_comp_info.cos_this_spd_id;
  40038a:	48 b8 40 b0 42 00 00 	movabs rax,0x42b040
  400391:	00 00 00 
  400394:	4c 8b 20             	mov    r12,QWORD PTR [rax]
		assert(id != cos_compid());
  400397:	4d 39 e5             	cmp    r13,r12
  40039a:	0f 84 28 01 00 00    	je     4004c8 <calculate_initialization_schedule+0x238>
		if (strcmp(exec_type, "init")) BUG();	/* TODO: no support for hierarchical scheduling yet */
  4003a0:	48 b8 50 84 41 00 00 	movabs rax,0x418450
  4003a7:	00 00 00 
  4003aa:	4c 89 fe             	mov    rsi,r15
  4003ad:	ff d0                	call   rax
  4003af:	85 c0                	test   eax,eax
  4003b1:	0f 85 c1 00 00 00    	jne    400478 <calculate_initialization_schedule+0x1e8>
	printc("\tSched %ld: %ld is the %ldth component to initialize\n", cos_compid(), cid, init_schedule_off);
  4003b7:	4c 89 ea             	mov    rdx,r13
  4003ba:	48 8b 0b             	mov    rcx,QWORD PTR [rbx]
  4003bd:	4c 89 e6             	mov    rsi,r12
  4003c0:	4c 89 f7             	mov    rdi,r14
  4003c3:	49 b8 00 00 40 00 00 	movabs r8,0x400000
  4003ca:	00 00 00 
  4003cd:	31 c0                	xor    eax,eax
  4003cf:	41 ff d0             	call   r8
	init_schedule[init_schedule_off] = cid;
  4003d2:	48 8b 03             	mov    rax,QWORD PTR [rbx]
	assert(s->status == SCHEDINIT_FREE);
  4003d5:	4b 8d 54 ad 00       	lea    rdx,[r13+r13*4+0x0]
	init_schedule[init_schedule_off] = cid;
  4003da:	48 b9 40 1e 46 00 00 	movabs rcx,0x461e40
  4003e1:	00 00 00 
  4003e4:	4c 89 2c c1          	mov    QWORD PTR [rcx+rax*8],r13
	init_schedule_off++;
  4003e8:	48 83 c0 01          	add    rax,0x1
  4003ec:	48 89 03             	mov    QWORD PTR [rbx],rax
	assert(s->status == SCHEDINIT_FREE);
  4003ef:	48 b8 40 14 46 00 00 	movabs rax,0x461440
  4003f6:	00 00 00 
  4003f9:	4c 8d 2c d0          	lea    r13,[rax+rdx*8]
  4003fd:	41 8b 45 10          	mov    eax,DWORD PTR [r13+0x10]
  400401:	85 c0                	test   eax,eax
  400403:	0f 85 e7 00 00 00    	jne    4004f0 <calculate_initialization_schedule+0x260>
	*s = (struct schedinit_status) {
  400409:	66 0f ef c0          	pxor   xmm0,xmm0
  40040d:	49 c7 45 20 00 00 00 	mov    QWORD PTR [r13+0x20],0x0
  400414:	00 
	simple_barrier_init(&s->barrier, init_parallelism());
  400415:	48 b8 e0 ae 40 00 00 	movabs rax,0x40aee0
  40041c:	00 00 00 
	*s = (struct schedinit_status) {
  40041f:	41 0f 11 45 10       	movups XMMWORD PTR [r13+0x10],xmm0
  400424:	41 0f 11 45 00       	movups XMMWORD PTR [r13+0x0],xmm0
  400429:	41 c7 45 10 01 00 00 	mov    DWORD PTR [r13+0x10],0x1
  400430:	00 
  400431:	49 c7 45 18 ff ff ff 	mov    QWORD PTR [r13+0x18],0xffffffffffffffff
  400438:	ff 
	simple_barrier_init(&s->barrier, init_parallelism());
  400439:	ff d0                	call   rax
}

static inline void
simple_barrier_init(struct simple_barrier *b, unsigned int ncores)
{
	*b = (struct simple_barrier) {
  40043b:	49 c7 45 00 00 00 00 	mov    QWORD PTR [r13+0x0],0x0
  400442:	00 
	for (cont = args_iter(&exec_entries, &i, &curr) ; cont ; cont = args_iter_next(&i, &curr)) {
  400443:	48 8d 75 90          	lea    rsi,[rbp-0x70]
  400447:	48 8d 7d b0          	lea    rdi,[rbp-0x50]
  40044b:	41 89 45 08          	mov    DWORD PTR [r13+0x8],eax
  40044f:	48 b8 30 bf 40 00 00 	movabs rax,0x40bf30
  400456:	00 00 00 
  400459:	ff d0                	call   rax
  40045b:	85 c0                	test   eax,eax
  40045d:	0f 85 e2 fe ff ff    	jne    400345 <calculate_initialization_schedule+0xb5>
}
  400463:	48 83 c4 78          	add    rsp,0x78
  400467:	5b                   	pop    rbx
  400468:	41 5c                	pop    r12
  40046a:	41 5d                	pop    r13
  40046c:	41 5e                	pop    r14
  40046e:	41 5f                	pop    r15
  400470:	5d                   	pop    rbp
  400471:	c3                   	ret    
  400472:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  400478:	48 bf 6a ee 41 00 00 	movabs rdi,0x41ee6a
  40047f:	00 00 00 
  400482:	be 11 00 00 00       	mov    esi,0x11
  400487:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40048e:	00 00 00 
  400491:	ff d0                	call   rax
		if (strcmp(exec_type, "init")) BUG();	/* TODO: no support for hierarchical scheduling yet */
  400493:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40049a:	00 00 00 00 
  40049e:	0f 0b                	ud2    
  4004a0:	48 bf 18 ee 41 00 00 	movabs rdi,0x41ee18
  4004a7:	00 00 00 
  4004aa:	be 24 00 00 00       	mov    esi,0x24
  4004af:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4004b6:	00 00 00 
  4004b9:	ff d0                	call   rax
		assert(exec_type);
  4004bb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4004c2:	00 00 00 00 
  4004c6:	0f 0b                	ud2    
  4004c8:	48 bf 40 ee 41 00 00 	movabs rdi,0x41ee40
  4004cf:	00 00 00 
  4004d2:	be 24 00 00 00       	mov    esi,0x24
  4004d7:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4004de:	00 00 00 
  4004e1:	ff d0                	call   rax
		assert(id != cos_compid());
  4004e3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4004ea:	00 00 00 00 
  4004ee:	0f 0b                	ud2    
  4004f0:	48 bf b8 ee 41 00 00 	movabs rdi,0x41eeb8
  4004f7:	00 00 00 
  4004fa:	be 23 00 00 00       	mov    esi,0x23
  4004ff:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  400506:	00 00 00 
  400509:	ff d0                	call   rax
	assert(s->status == SCHEDINIT_FREE);
  40050b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400512:	00 00 00 00 
  400516:	0f 0b                	ud2    
  400518:	48 bf c0 ed 41 00 00 	movabs rdi,0x41edc0
  40051f:	00 00 00 
  400522:	be 23 00 00 00       	mov    esi,0x23
  400527:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40052e:	00 00 00 
  400531:	ff d0                	call   rax
	assert(!ret);
  400533:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40053a:	00 00 00 00 
  40053e:	0f 0b                	ud2    

0000000000400540 <init_done>:
	while (1) ;
}

void
init_done(int parallel_init, init_main_t cont)
{
  400540:	f3 0f 1e fa          	endbr64 
  400544:	55                   	push   rbp
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  400545:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  400548:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  40054e:	48 89 e5             	mov    rbp,rsp
  400551:	41 54                	push   r12
  400553:	53                   	push   rbx
	return get_stk_data(INVTOKEN_OFFSET);
  400554:	48 8b b8 e8 1f 00 00 	mov    rdi,QWORD PTR [rax+0x1fe8]
  40055b:	89 f3                	mov    ebx,esi
	compid_t client = (compid_t)cos_inv_token();
	struct schedinit_status *s;

	s = &initialization_state[client];
	assert(s->status != SCHEDINIT_FREE);
  40055d:	48 be 40 14 46 00 00 	movabs rsi,0x461440
  400564:	00 00 00 
  400567:	48 8d 0c bf          	lea    rcx,[rdi+rdi*4]
  40056b:	48 c1 e1 03          	shl    rcx,0x3
  40056f:	48 8d 14 0e          	lea    rdx,[rsi+rcx*1]
  400573:	8b 42 10             	mov    eax,DWORD PTR [rdx+0x10]
  400576:	85 c0                	test   eax,eax
  400578:	0f 84 9e 00 00 00    	je     40061c <init_done+0xdc>
  40057e:	45 31 c0             	xor    r8d,r8d
  400581:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
  400588:	f0 4c 0f b1 44 0e 18 	lock cmpxchg QWORD PTR [rsi+rcx*1+0x18],r8
  40058f:	0f 94 c0             	sete   al

	/*
	 * `init_done` should not be called once initialization is
	 * completed. This is an error.
	 */
	if (s->status == SCHEDINIT_MAIN) {
  400592:	8b 42 10             	mov    eax,DWORD PTR [rdx+0x10]
  400595:	83 f8 03             	cmp    eax,0x3
  400598:	0f 84 ce 00 00 00    	je     40066c <init_done+0x12c>

	/*
	 * This should *ONLY* happen for the initialization thread
	 * *after* it executes `cos_init`.
	 */
	if (s->status == SCHEDINIT_INITING) {
  40059e:	83 f8 01             	cmp    eax,0x1
  4005a1:	74 6d                	je     400610 <init_done+0xd0>
	assert(*barrier <= ncore);
  4005a3:	8b 4a 08             	mov    ecx,DWORD PTR [rdx+0x8]
  4005a6:	48 39 0a             	cmp    QWORD PTR [rdx],rcx
  4005a9:	0f 87 95 00 00 00    	ja     400644 <init_done+0x104>
ps_faa(unsigned long *target, long inc)
{
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Warray-bounds"
/* GCC has bug of processing a warning(-Warray-bounds) and not get fixed, thus close the warning in this function */
        __asm__ __volatile__("lock " PS_FAA_STR
  4005af:	b8 01 00 00 00       	mov    eax,0x1
  4005b4:	f0 48 0f c1 02       	lock xadd QWORD PTR [rdx],rax
                             : "+m" (*target), "+q" (inc)
                             : : "memory", "cc");
        return inc;
  4005b9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	while (ps_load(barrier) < ncore) ;
  4005c0:	48 8b 02             	mov    rax,QWORD PTR [rdx]
  4005c3:	48 39 c1             	cmp    rcx,rax
  4005c6:	77 f8                	ja     4005c0 <init_done+0x80>
 	 * If this barrier is hit *after* the parallel initialization
	 * has finished, no blocking will occur as its count has
	 * already been hit.
	 */
	simple_barrier(&s->barrier);
	s->status = SCHEDINIT_MAIN;
  4005c8:	48 8d 04 bf          	lea    rax,[rdi+rdi*4]
  4005cc:	4c 8d 24 c6          	lea    r12,[rsi+rax*8]

	s->initialization_thds[cos_coreid()] = slm_thd_current_extern();
  4005d0:	48 b8 90 1e 40 00 00 	movabs rax,0x401e90
  4005d7:	00 00 00 
	s->status = SCHEDINIT_MAIN;
  4005da:	41 c7 44 24 10 03 00 	mov    DWORD PTR [r12+0x10],0x3
  4005e1:	00 00 
	s->initialization_thds[cos_coreid()] = slm_thd_current_extern();
  4005e3:	ff d0                	call   rax
  4005e5:	49 89 44 24 20       	mov    QWORD PTR [r12+0x20],rax
	extern int thd_block(void);
	thd_block(); 		/* block until initialization is completed */
  4005ea:	48 b8 40 2b 40 00 00 	movabs rax,0x402b40
  4005f1:	00 00 00 
  4005f4:	ff d0                	call   rax

 	/*
	 * After initialization, we're done with the parallel threads
	 * in some cases.
	 */
	if ((cos_coreid() != s->init_core && cont == INIT_MAIN_SINGLE) || cont == INIT_MAIN_NONE) {
  4005f6:	49 83 7c 24 18 00    	cmp    QWORD PTR [r12+0x18],0x0
  4005fc:	74 05                	je     400603 <init_done+0xc3>
  4005fe:	83 fb 01             	cmp    ebx,0x1
  400601:	74 69                	je     40066c <init_done+0x12c>
  400603:	85 db                	test   ebx,ebx
  400605:	74 65                	je     40066c <init_done+0x12c>
	 * main execution. We'd expect the next API call here to be
	 * `init_exit`.
	 */

	return;
}
  400607:	5b                   	pop    rbx
  400608:	41 5c                	pop    r12
  40060a:	5d                   	pop    rbp
  40060b:	c3                   	ret    
  40060c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		ps_store(&s->status, SCHEDINIT_PARINIT);
  400610:	c7 42 10 02 00 00 00 	mov    DWORD PTR [rdx+0x10],0x2
}
  400617:	5b                   	pop    rbx
  400618:	41 5c                	pop    r12
  40061a:	5d                   	pop    rbp
  40061b:	c3                   	ret    
  40061c:	48 bf e0 ee 41 00 00 	movabs rdi,0x41eee0
  400623:	00 00 00 
  400626:	be 24 00 00 00       	mov    esi,0x24
  40062b:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  400632:	00 00 00 
  400635:	ff d0                	call   rax
	assert(s->status != SCHEDINIT_FREE);
  400637:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40063e:	00 00 00 00 
  400642:	0f 0b                	ud2    
  400644:	48 bf 08 ef 41 00 00 	movabs rdi,0x41ef08
  40064b:	00 00 00 
  40064e:	be 5d 00 00 00       	mov    esi,0x5d
  400653:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40065a:	00 00 00 
  40065d:	ff d0                	call   rax
	assert(*barrier <= ncore);
  40065f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400666:	00 00 00 00 
  40066a:	0f 0b                	ud2    
		exit_init_thd();
  40066c:	48 b8 c0 00 40 00 00 	movabs rax,0x4000c0
  400673:	00 00 00 
  400676:	ff d0                	call   rax
  400678:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40067f:	00 

0000000000400680 <init_exit>:

void
init_exit(int retval)
{
  400680:	f3 0f 1e fa          	endbr64 
	exit_init_thd();
  400684:	48 b8 c0 00 40 00 00 	movabs rax,0x4000c0
  40068b:	00 00 00 
{
  40068e:	55                   	push   rbp
  40068f:	48 89 e5             	mov    rbp,rsp
	exit_init_thd();
  400692:	ff d0                	call   rax
  400694:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40069b:	00 00 00 00 
  40069f:	90                   	nop

00000000004006a0 <slm_idle_comp_initialization>:
	return;
}

void
slm_idle_comp_initialization(void)
{
  4006a0:	f3 0f 1e fa          	endbr64 
	if (cos_coreid() == 0) printc("Scheduler %ld: Running initialization thread.\n", cos_compid());
  4006a4:	48 b8 40 b0 42 00 00 	movabs rax,0x42b040
  4006ab:	00 00 00 
{
  4006ae:	55                   	push   rbp
	if (cos_coreid() == 0) printc("Scheduler %ld: Running initialization thread.\n", cos_compid());
  4006af:	48 bf 68 ef 41 00 00 	movabs rdi,0x41ef68
  4006b6:	00 00 00 
{
  4006b9:	48 89 e5             	mov    rbp,rsp
  4006bc:	41 57                	push   r15
  4006be:	41 56                	push   r14
  4006c0:	41 55                	push   r13
  4006c2:	41 54                	push   r12
	while (init_schedule_current != ps_load(&init_schedule_off)) {
  4006c4:	49 bc 40 20 46 00 00 	movabs r12,0x462040
  4006cb:	00 00 00 
{
  4006ce:	53                   	push   rbx
	if (cos_coreid() == 0) printc("Scheduler %ld: Running initialization thread.\n", cos_compid());
  4006cf:	48 bb 00 00 40 00 00 	movabs rbx,0x400000
  4006d6:	00 00 00 
{
  4006d9:	48 83 ec 28          	sub    rsp,0x28
	if (cos_coreid() == 0) printc("Scheduler %ld: Running initialization thread.\n", cos_compid());
  4006dd:	48 8b 30             	mov    rsi,QWORD PTR [rax]
  4006e0:	31 c0                	xor    eax,eax
  4006e2:	ff d3                	call   rbx
	while (init_schedule_current != ps_load(&init_schedule_off)) {
  4006e4:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  4006e8:	48 85 c0             	test   rax,rax
  4006eb:	0f 84 b5 00 00 00    	je     4007a6 <slm_idle_comp_initialization+0x106>
		param[0] = sched_param_pack(SCHEDP_INIT, 0);
  4006f1:	48 b8 f8 f1 41 00 00 	movabs rax,0x41f1f8
  4006f8:	00 00 00 
  4006fb:	31 db                	xor    ebx,ebx
  4006fd:	49 bd 40 1e 46 00 00 	movabs r13,0x461e40
  400704:	00 00 00 
		if (cos_coreid() == 0)	printc("\tScheduler %ld: initializing component %ld with thread %ld.\n", cos_compid(), client, t->tid);
  400707:	49 bf f0 ef 41 00 00 	movabs r15,0x41eff0
  40070e:	00 00 00 
		param[0] = sched_param_pack(SCHEDP_INIT, 0);
  400711:	48 8b 00             	mov    rax,QWORD PTR [rax]
  400714:	48 89 45 b8          	mov    QWORD PTR [rbp-0x48],rax
  400718:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40071f:	00 
  400720:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
		compid_t client = init_schedule[init_schedule_current];
  400724:	4d 8b 74 dd 00       	mov    r14,QWORD PTR [r13+rbx*8+0x0]
		t = thd_alloc_in(client, 0, param, 1);
  400729:	31 f6                	xor    esi,esi
  40072b:	b9 01 00 00 00       	mov    ecx,0x1
  400730:	48 8d 55 c8          	lea    rdx,[rbp-0x38]
		param[0] = sched_param_pack(SCHEDP_INIT, 0);
  400734:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
		t = thd_alloc_in(client, 0, param, 1);
  400738:	4c 89 f7             	mov    rdi,r14
  40073b:	48 b8 e0 5d 40 00 00 	movabs rax,0x405de0
  400742:	00 00 00 
  400745:	ff d0                	call   rax
		assert(t);
  400747:	48 85 c0             	test   rax,rax
  40074a:	0f 84 56 01 00 00    	je     4008a6 <slm_idle_comp_initialization+0x206>
		if (cos_coreid() == 0)	printc("\tScheduler %ld: initializing component %ld with thread %ld.\n", cos_compid(), client, t->tid);
  400750:	48 8b 48 18          	mov    rcx,QWORD PTR [rax+0x18]
  400754:	4c 89 f2             	mov    rdx,r14
  400757:	4c 89 ff             	mov    rdi,r15
		init_schedule_current++;
  40075a:	48 83 c3 01          	add    rbx,0x1
		if (cos_coreid() == 0)	printc("\tScheduler %ld: initializing component %ld with thread %ld.\n", cos_compid(), client, t->tid);
  40075e:	48 b8 40 b0 42 00 00 	movabs rax,0x42b040
  400765:	00 00 00 
  400768:	48 8b 30             	mov    rsi,QWORD PTR [rax]
  40076b:	31 c0                	xor    eax,eax
  40076d:	49 bb 00 00 40 00 00 	movabs r11,0x400000
  400774:	00 00 00 
  400777:	41 ff d3             	call   r11
		while (ps_load(&n->initialization_thds[cos_coreid()]) == NULL) ;
  40077a:	4b 8d 04 b6          	lea    rax,[r14+r14*4]
  40077e:	48 be 40 14 46 00 00 	movabs rsi,0x461440
  400785:	00 00 00 
  400788:	48 8d 14 c6          	lea    rdx,[rsi+rax*8]
  40078c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  400790:	48 8b 42 20          	mov    rax,QWORD PTR [rdx+0x20]
  400794:	48 85 c0             	test   rax,rax
  400797:	74 f7                	je     400790 <slm_idle_comp_initialization+0xf0>
	while (init_schedule_current != ps_load(&init_schedule_off)) {
  400799:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  40079d:	48 39 c3             	cmp    rbx,rax
  4007a0:	0f 85 7a ff ff ff    	jne    400720 <slm_idle_comp_initialization+0x80>
	if (cos_coreid() == 0) printc("Scheduler %ld, initialization completed.\n", cos_compid());
  4007a6:	48 b8 40 b0 42 00 00 	movabs rax,0x42b040
  4007ad:	00 00 00 
  4007b0:	48 8b 30             	mov    rsi,QWORD PTR [rax]
  4007b3:	31 c0                	xor    eax,eax
  4007b5:	48 bf 98 ef 41 00 00 	movabs rdi,0x41ef98
  4007bc:	00 00 00 
  4007bf:	48 bb 00 00 40 00 00 	movabs rbx,0x400000
  4007c6:	00 00 00 
  4007c9:	49 bf c0 5e 5a 00 00 	movabs r15,0x5a5ec0
  4007d0:	00 00 00 
  4007d3:	ff d3                	call   rbx
	slm_cs_enter(slm_thd_special(), SLM_CS_NONE);
  4007d5:	48 b8 e0 5d 41 00 00 	movabs rax,0x415de0
  4007dc:	00 00 00 
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  4007df:	48 bb 50 5f 41 00 00 	movabs rbx,0x415f50
  4007e6:	00 00 00 
  4007e9:	ff d0                	call   rax
  4007eb:	49 89 c5             	mov    r13,rax
	assert(current);
  4007ee:	48 85 c0             	test   rax,rax
  4007f1:	0f 84 1e 02 00 00    	je     400a15 <slm_idle_comp_initialization+0x375>
		tok    = cos_sched_sync();
  4007f7:	48 b8 d0 35 41 00 00 	movabs rax,0x4135d0
  4007fe:	00 00 00 
  400801:	ff d0                	call   rax
  400803:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  400806:	49 8b 07             	mov    rax,QWORD PTR [r15]
		if (unlikely(owner)) {
  400809:	48 89 c1             	mov    rcx,rax
  40080c:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  400810:	0f 85 bc 01 00 00    	jne    4009d2 <slm_idle_comp_initialization+0x332>
        __asm__ __volatile__("lock " PS_CAS_STR
  400816:	f0 4d 0f b1 2f       	lock cmpxchg QWORD PTR [r15],r13
  40081b:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  40081e:	84 c0                	test   al,al
  400820:	74 d5                	je     4007f7 <slm_idle_comp_initialization+0x157>
	for (i = 0; i < ps_load(&init_schedule_off); i++) {
  400822:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  400826:	45 31 f6             	xor    r14d,r14d
  400829:	49 bd 40 1e 46 00 00 	movabs r13,0x461e40
  400830:	00 00 00 
  400833:	48 bb 40 14 46 00 00 	movabs rbx,0x461440
  40083a:	00 00 00 
  40083d:	48 85 c0             	test   rax,rax
  400840:	75 29                	jne    40086b <slm_idle_comp_initialization+0x1cb>
  400842:	e9 87 00 00 00       	jmp    4008ce <slm_idle_comp_initialization+0x22e>
  400847:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40084e:	00 00 
		slm_thd_wakeup(t, 0);
  400850:	48 b8 c0 66 41 00 00 	movabs rax,0x4166c0
  400857:	00 00 00 
  40085a:	31 f6                	xor    esi,esi
	for (i = 0; i < ps_load(&init_schedule_off); i++) {
  40085c:	49 83 c6 01          	add    r14,0x1
		slm_thd_wakeup(t, 0);
  400860:	ff d0                	call   rax
	for (i = 0; i < ps_load(&init_schedule_off); i++) {
  400862:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  400866:	49 39 c6             	cmp    r14,rax
  400869:	73 63                	jae    4008ce <slm_idle_comp_initialization+0x22e>
		t = initialization_state[client].initialization_thds[cos_coreid()];
  40086b:	4b 8b 44 f5 00       	mov    rax,QWORD PTR [r13+r14*8+0x0]
  400870:	48 8d 04 80          	lea    rax,[rax+rax*4]
  400874:	48 8b 7c c3 20       	mov    rdi,QWORD PTR [rbx+rax*8+0x20]
		assert(t != NULL);
  400879:	48 85 ff             	test   rdi,rdi
  40087c:	75 d2                	jne    400850 <slm_idle_comp_initialization+0x1b0>
  40087e:	48 bf 30 f0 41 00 00 	movabs rdi,0x41f030
  400885:	00 00 00 
  400888:	be 24 00 00 00       	mov    esi,0x24
  40088d:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  400894:	00 00 00 
  400897:	ff d0                	call   rax
  400899:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4008a0:	00 00 00 00 
  4008a4:	0f 0b                	ud2    
  4008a6:	48 bf c8 ef 41 00 00 	movabs rdi,0x41efc8
  4008ad:	00 00 00 
  4008b0:	be 24 00 00 00       	mov    esi,0x24
  4008b5:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4008bc:	00 00 00 
  4008bf:	ff d0                	call   rax
		assert(t);
  4008c1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4008c8:	00 00 00 00 
  4008cc:	0f 0b                	ud2    
	slm_cs_exit_reschedule(slm_thd_special(), SLM_CS_NONE);
  4008ce:	48 b8 e0 5d 41 00 00 	movabs rax,0x415de0
  4008d5:	00 00 00 
		}
	}

	/* Make a policy decision! */
	t = slm_sched_schedule();
	if (unlikely(!t)) t = &g->idle_thd;
  4008d8:	49 be 40 5f 5a 00 00 	movabs r14,0x5a5f40
  4008df:	00 00 00 
  4008e2:	ff d0                	call   rax
  4008e4:	49 89 c5             	mov    r13,rax
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  4008e7:	48 b8 10 ce 40 00 00 	movabs rax,0x40ce10
  4008ee:	00 00 00 
  4008f1:	ff d0                	call   rax
	tok  = cos_sched_sync();
  4008f3:	48 b8 d0 35 41 00 00 	movabs rax,0x4135d0
  4008fa:	00 00 00 
  4008fd:	ff d0                	call   rax
  4008ff:	41 89 c4             	mov    r12d,eax
	t = slm_sched_schedule();
  400902:	48 b8 e0 1c 40 00 00 	movabs rax,0x401ce0
  400909:	00 00 00 
  40090c:	ff d0                	call   rax
	if (unlikely(!t)) t = &g->idle_thd;
  40090e:	48 85 c0             	test   rax,rax
	t = slm_sched_schedule();
  400911:	48 89 c3             	mov    rbx,rax
	if (unlikely(!t)) t = &g->idle_thd;
  400914:	49 0f 44 de          	cmove  rbx,r14
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  400918:	8b 43 04             	mov    eax,DWORD PTR [rbx+0x4]
  40091b:	83 e8 02             	sub    eax,0x2

	assert(slm_state_is_runnable(t->state));
  40091e:	83 f8 01             	cmp    eax,0x1
  400921:	76 19                	jbe    40093c <slm_idle_comp_initialization+0x29c>
  400923:	e9 15 01 00 00       	jmp    400a3d <slm_idle_comp_initialization+0x39d>
  400928:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40092f:	00 
  400930:	f0 49 0f b1 17       	lock cmpxchg QWORD PTR [r15],rdx
  400935:	0f 94 c0             	sete   al
	while (ret != 0) {
  400938:	84 c0                	test   al,al
  40093a:	75 36                	jne    400972 <slm_idle_comp_initialization+0x2d2>
		tok    = cos_sched_sync();
  40093c:	48 b8 d0 35 41 00 00 	movabs rax,0x4135d0
  400943:	00 00 00 
  400946:	ff d0                	call   rax
  400948:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  40094a:	49 8b 07             	mov    rax,QWORD PTR [r15]
		if (unlikely(contention)) {
  40094d:	48 89 c2             	mov    rdx,rax
  400950:	83 e2 01             	and    edx,0x1
  400953:	74 db                	je     400930 <slm_idle_comp_initialization+0x290>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  400955:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  400958:	48 89 c2             	mov    rdx,rax
  40095b:	4c 89 ff             	mov    rdi,r15
  40095e:	48 b8 b0 5f 41 00 00 	movabs rax,0x415fb0
  400965:	00 00 00 
  400968:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  40096c:	ff d0                	call   rax
  40096e:	85 c0                	test   eax,eax
  400970:	75 ca                	jne    40093c <slm_idle_comp_initialization+0x29c>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  400972:	48 b8 10 ce 40 00 00 	movabs rax,0x40ce10
  400979:	00 00 00 
  40097c:	ff d0                	call   rax
	prio = inherit_prio ? curr->priority : t->priority;
  40097e:	4c 8b 53 30          	mov    r10,QWORD PTR [rbx+0x30]
	timeout = g->timeout_next;
  400982:	48 b8 c8 5f 5a 00 00 	movabs rax,0x5a5fc8
  400989:	00 00 00 
  40098c:	48 8b 30             	mov    rsi,QWORD PTR [rax]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  40098f:	8b 03                	mov    eax,DWORD PTR [rbx]
  400991:	a8 0b                	test   al,0xb
  400993:	0f 85 10 01 00 00    	jne    400aa9 <slm_idle_comp_initialization+0x409>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  400999:	48 89 f2             	mov    rdx,rsi
  40099c:	44 89 e1             	mov    ecx,r12d
  40099f:	4c 89 d6             	mov    rsi,r10
  4009a2:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  4009a6:	48 b8 70 e1 40 00 00 	movabs rax,0x40e170
  4009ad:	00 00 00 
  4009b0:	ff d0                	call   rax
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  4009b2:	83 f8 ff             	cmp    eax,0xffffffff
  4009b5:	0f 84 aa 00 00 00    	je     400a65 <slm_idle_comp_initialization+0x3c5>
	slm_cs_exit(NULL, flags);

	ret = slm_thd_activate(curr, t, tok, 0);
	
	if (unlikely(ret != 0)) {
  4009bb:	85 c0                	test   eax,eax
  4009bd:	0f 85 47 01 00 00    	jne    400b0a <slm_idle_comp_initialization+0x46a>
	slm_comp_init_loop();
}
  4009c3:	48 83 c4 28          	add    rsp,0x28
  4009c7:	5b                   	pop    rbx
  4009c8:	41 5c                	pop    r12
  4009ca:	41 5d                	pop    r13
  4009cc:	41 5e                	pop    r14
  4009ce:	41 5f                	pop    r15
  4009d0:	5d                   	pop    rbp
  4009d1:	c3                   	ret    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  4009d2:	41 89 c0             	mov    r8d,eax
  4009d5:	4c 89 ea             	mov    rdx,r13
  4009d8:	48 89 c6             	mov    rsi,rax
  4009db:	4c 89 ff             	mov    rdi,r15
  4009de:	41 83 e0 01          	and    r8d,0x1
  4009e2:	ff d3                	call   rbx
			assert(ret != -EBUSY);
  4009e4:	83 f8 f0             	cmp    eax,0xfffffff0
  4009e7:	0f 85 0a fe ff ff    	jne    4007f7 <slm_idle_comp_initialization+0x157>
  4009ed:	48 bf 38 ed 41 00 00 	movabs rdi,0x41ed38
  4009f4:	00 00 00 
  4009f7:	be 59 00 00 00       	mov    esi,0x59
  4009fc:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  400a03:	00 00 00 
  400a06:	ff d0                	call   rax
  400a08:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400a0f:	00 00 00 00 
  400a13:	0f 0b                	ud2    
  400a15:	48 bf d8 ec 41 00 00 	movabs rdi,0x41ecd8
  400a1c:	00 00 00 
  400a1f:	be 59 00 00 00       	mov    esi,0x59
  400a24:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  400a2b:	00 00 00 
  400a2e:	ff d0                	call   rax
	assert(current);
  400a30:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400a37:	00 00 00 00 
  400a3b:	0f 0b                	ud2    
  400a3d:	48 bf 58 f0 41 00 00 	movabs rdi,0x41f058
  400a44:	00 00 00 
  400a47:	be 61 00 00 00       	mov    esi,0x61
  400a4c:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  400a53:	00 00 00 
  400a56:	ff d0                	call   rax
	assert(slm_state_is_runnable(t->state));
  400a58:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400a5f:	00 00 00 00 
  400a63:	0f 0b                	ud2    
	return t != &g->idle_thd && t != &g->sched_thd;
  400a65:	4c 39 f3             	cmp    rbx,r14
  400a68:	0f 84 05 01 00 00    	je     400b73 <slm_idle_comp_initialization+0x4d3>
  400a6e:	48 b8 c8 5e 5a 00 00 	movabs rax,0x5a5ec8
  400a75:	00 00 00 
  400a78:	48 39 c3             	cmp    rbx,rax
  400a7b:	0f 84 f2 00 00 00    	je     400b73 <slm_idle_comp_initialization+0x4d3>
  400a81:	48 bf c0 f0 41 00 00 	movabs rdi,0x41f0c0
  400a88:	00 00 00 
  400a8b:	be 61 00 00 00       	mov    esi,0x61
  400a90:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  400a97:	00 00 00 
  400a9a:	ff d0                	call   rax
		/* Assuming only the single tcap with infinite budget...should not get EPERM */
		assert(ret != -EPERM);
  400a9c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400aa3:	00 00 00 00 
  400aa7:	0f 0b                	ud2    
		if (t == &g->sched_thd) {
  400aa9:	48 ba c8 5e 5a 00 00 	movabs rdx,0x5a5ec8
  400ab0:	00 00 00 
	timeout = g->timeout_next;
  400ab3:	48 89 f1             	mov    rcx,rsi
		if (t == &g->sched_thd) {
  400ab6:	48 39 d3             	cmp    rbx,rdx
  400ab9:	0f 84 a9 00 00 00    	je     400b68 <slm_idle_comp_initialization+0x4c8>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  400abf:	a8 02                	test   al,0x2
  400ac1:	0f 85 d9 00 00 00    	jne    400ba0 <slm_idle_comp_initialization+0x500>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  400ac7:	48 89 ce             	mov    rsi,rcx
  400aca:	a8 01                	test   al,0x1
  400acc:	0f 84 c7 fe ff ff    	je     400999 <slm_idle_comp_initialization+0x2f9>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  400ad2:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
  400ad6:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  400ada:	45 89 e1             	mov    r9d,r12d
  400add:	4c 89 d2             	mov    rdx,r10
  400ae0:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  400ae7:	00 00 00 
  400aea:	4c 8b 00             	mov    r8,QWORD PTR [rax]
  400aed:	48 b8 f0 35 41 00 00 	movabs rax,0x4135f0
  400af4:	00 00 00 
  400af7:	ff d0                	call   rax
	if (unlikely(ret != 0)) {
  400af9:	85 c0                	test   eax,eax
  400afb:	0f 84 c2 fe ff ff    	je     4009c3 <slm_idle_comp_initialization+0x323>
		assert(ret != -EPERM);
  400b01:	83 f8 ff             	cmp    eax,0xffffffff
  400b04:	0f 84 77 ff ff ff    	je     400a81 <slm_idle_comp_initialization+0x3e1>
		assert(ret != -EINVAL);
  400b0a:	83 f8 ea             	cmp    eax,0xffffffea
  400b0d:	0f 84 f7 00 00 00    	je     400c0a <slm_idle_comp_initialization+0x56a>

		/*
		 * If the slm_thd_activate returns -EBUSY, this means we are trying to switch to the scheduler thread,
		 * and scheduler thread still has pending events. Directly return to process pending events.
		 */
		if (ret == -EBUSY) return ret;
  400b13:	83 f8 f0             	cmp    eax,0xfffffff0
  400b16:	0f 84 a7 fe ff ff    	je     4009c3 <slm_idle_comp_initialization+0x323>
		/* If the slm_thd_activate returns -EAGAIN, this means this scheduling token is outdated, try again */
		assert(ret == -EAGAIN);
  400b1c:	83 f8 f5             	cmp    eax,0xfffffff5
  400b1f:	0f 85 bd 00 00 00    	jne    400be2 <slm_idle_comp_initialization+0x542>
  400b25:	4d 85 ed             	test   r13,r13
  400b28:	0f 84 e7 fe ff ff    	je     400a15 <slm_idle_comp_initialization+0x375>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  400b2e:	48 bb 50 5f 41 00 00 	movabs rbx,0x415f50
  400b35:	00 00 00 
		tok    = cos_sched_sync();
  400b38:	48 b8 d0 35 41 00 00 	movabs rax,0x4135d0
  400b3f:	00 00 00 
  400b42:	ff d0                	call   rax
	unsigned long oc = ps_load(&cs->owner_contention);
  400b44:	49 8b 37             	mov    rsi,QWORD PTR [r15]
  400b47:	41 89 c1             	mov    r9d,eax
		if (unlikely(owner)) {
  400b4a:	48 89 f1             	mov    rcx,rsi
  400b4d:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  400b51:	75 72                	jne    400bc5 <slm_idle_comp_initialization+0x525>
  400b53:	48 89 f0             	mov    rax,rsi
  400b56:	f0 4d 0f b1 2f       	lock cmpxchg QWORD PTR [r15],r13
  400b5b:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  400b5e:	84 c0                	test   al,al
  400b60:	0f 85 8d fd ff ff    	jne    4008f3 <slm_idle_comp_initialization+0x253>
  400b66:	eb d0                	jmp    400b38 <slm_idle_comp_initialization+0x498>
			prio    = curr->priority;
  400b68:	4d 8b 55 30          	mov    r10,QWORD PTR [r13+0x30]
			timeout = TCAP_TIME_NIL;
  400b6c:	31 c9                	xor    ecx,ecx
  400b6e:	e9 4c ff ff ff       	jmp    400abf <slm_idle_comp_initialization+0x41f>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  400b73:	49 8b 55 30          	mov    rdx,QWORD PTR [r13+0x30]
  400b77:	45 89 e1             	mov    r9d,r12d
  400b7a:	31 c9                	xor    ecx,ecx
  400b7c:	31 f6                	xor    esi,esi
  400b7e:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  400b85:	00 00 00 
  400b88:	4c 8b 00             	mov    r8,QWORD PTR [rax]
  400b8b:	48 8b 78 f0          	mov    rdi,QWORD PTR [rax-0x10]
  400b8f:	48 b8 f0 35 41 00 00 	movabs rax,0x4135f0
  400b96:	00 00 00 
  400b99:	ff d0                	call   rax
  400b9b:	e9 59 ff ff ff       	jmp    400af9 <slm_idle_comp_initialization+0x459>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  400ba0:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  400ba7:	00 00 00 
  400baa:	48 8b 7b 28          	mov    rdi,QWORD PTR [rbx+0x28]
  400bae:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  400bb1:	44 89 e1             	mov    ecx,r12d
  400bb4:	48 b8 60 36 41 00 00 	movabs rax,0x413660
  400bbb:	00 00 00 
  400bbe:	ff d0                	call   rax
  400bc0:	e9 34 ff ff ff       	jmp    400af9 <slm_idle_comp_initialization+0x459>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  400bc5:	41 89 f0             	mov    r8d,esi
  400bc8:	4c 89 ea             	mov    rdx,r13
  400bcb:	4c 89 ff             	mov    rdi,r15
  400bce:	41 83 e0 01          	and    r8d,0x1
  400bd2:	ff d3                	call   rbx
			assert(ret != -EBUSY);
  400bd4:	83 f8 f0             	cmp    eax,0xfffffff0
  400bd7:	0f 85 5b ff ff ff    	jne    400b38 <slm_idle_comp_initialization+0x498>
  400bdd:	e9 0b fe ff ff       	jmp    4009ed <slm_idle_comp_initialization+0x34d>
  400be2:	48 bf 90 f1 41 00 00 	movabs rdi,0x41f190
  400be9:	00 00 00 
  400bec:	be 61 00 00 00       	mov    esi,0x61
  400bf1:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  400bf8:	00 00 00 
  400bfb:	ff d0                	call   rax
		assert(ret == -EAGAIN);
  400bfd:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400c04:	00 00 00 00 
  400c08:	0f 0b                	ud2    
  400c0a:	48 bf 28 f1 41 00 00 	movabs rdi,0x41f128
  400c11:	00 00 00 
  400c14:	be 61 00 00 00       	mov    esi,0x61
  400c19:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  400c20:	00 00 00 
  400c23:	ff d0                	call   rax
		assert(ret != -EINVAL);
  400c25:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400c2c:	00 00 00 00 
  400c30:	0f 0b                	ud2    
  400c32:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  400c39:	00 00 00 
  400c3c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000400c40 <printc.constprop.0>:
printc(char *fmt, ...)
  400c40:	f3 0f 1e fa          	endbr64 
  400c44:	55                   	push   rbp
  400c45:	48 89 e5             	mov    rbp,rsp
  400c48:	48 81 ec 90 01 00 00 	sub    rsp,0x190
  400c4f:	48 89 b5 58 ff ff ff 	mov    QWORD PTR [rbp-0xa8],rsi
  400c56:	48 89 95 60 ff ff ff 	mov    QWORD PTR [rbp-0xa0],rdx
  400c5d:	48 89 8d 68 ff ff ff 	mov    QWORD PTR [rbp-0x98],rcx
  400c64:	4c 89 85 70 ff ff ff 	mov    QWORD PTR [rbp-0x90],r8
  400c6b:	4c 89 8d 78 ff ff ff 	mov    QWORD PTR [rbp-0x88],r9
  400c72:	84 c0                	test   al,al
  400c74:	74 20                	je     400c96 <printc.constprop.0+0x56>
  400c76:	0f 29 45 80          	movaps XMMWORD PTR [rbp-0x80],xmm0
  400c7a:	0f 29 4d 90          	movaps XMMWORD PTR [rbp-0x70],xmm1
  400c7e:	0f 29 55 a0          	movaps XMMWORD PTR [rbp-0x60],xmm2
  400c82:	0f 29 5d b0          	movaps XMMWORD PTR [rbp-0x50],xmm3
  400c86:	0f 29 65 c0          	movaps XMMWORD PTR [rbp-0x40],xmm4
  400c8a:	0f 29 6d d0          	movaps XMMWORD PTR [rbp-0x30],xmm5
  400c8e:	0f 29 75 e0          	movaps XMMWORD PTR [rbp-0x20],xmm6
  400c92:	0f 29 7d f0          	movaps XMMWORD PTR [rbp-0x10],xmm7
	va_start(arg_ptr, fmt);
  400c96:	48 8d 45 10          	lea    rax,[rbp+0x10]
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  400c9a:	be b4 00 00 00       	mov    esi,0xb4
  400c9f:	48 8d 8d 78 fe ff ff 	lea    rcx,[rbp-0x188]
	va_start(arg_ptr, fmt);
  400ca6:	c7 85 78 fe ff ff 08 	mov    DWORD PTR [rbp-0x188],0x8
  400cad:	00 00 00 
  400cb0:	48 89 85 80 fe ff ff 	mov    QWORD PTR [rbp-0x180],rax
  400cb7:	48 8d 85 50 ff ff ff 	lea    rax,[rbp-0xb0]
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  400cbe:	48 8d bd 90 fe ff ff 	lea    rdi,[rbp-0x170]
  400cc5:	48 ba 00 f2 41 00 00 	movabs rdx,0x41f200
  400ccc:	00 00 00 
	va_start(arg_ptr, fmt);
  400ccf:	48 89 85 88 fe ff ff 	mov    QWORD PTR [rbp-0x178],rax
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  400cd6:	48 b8 20 80 41 00 00 	movabs rax,0x418020
  400cdd:	00 00 00 
	va_start(arg_ptr, fmt);
  400ce0:	c7 85 7c fe ff ff 30 	mov    DWORD PTR [rbp-0x184],0x30
  400ce7:	00 00 00 
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  400cea:	ff d0                	call   rax
	ret = cos_print_str(s, ret);
  400cec:	48 8d bd 90 fe ff ff 	lea    rdi,[rbp-0x170]
  400cf3:	be 1b 00 00 00       	mov    esi,0x1b
  400cf8:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  400cff:	00 00 00 
  400d02:	ff d0                	call   rax
}
  400d04:	c9                   	leave  
  400d05:	c3                   	ret    
  400d06:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  400d0d:	00 00 00 

0000000000400d10 <slm_ipi_process>:
	goto done;
}

void
slm_ipi_process(void *d)
{
  400d10:	f3 0f 1e fa          	endbr64 
	int rcvd, ret;
	struct slm_ipi_percore *ipi_data = slm_ipi_percore_get(cos_cpuid());
  400d14:	48 b8 c0 5d 41 00 00 	movabs rax,0x415dc0
  400d1b:	00 00 00 
{
  400d1e:	55                   	push   rbp
	struct slm_ipi_percore *ipi_data = slm_ipi_percore_get(cos_cpuid());
  400d1f:	31 ff                	xor    edi,edi
{
  400d21:	48 89 e5             	mov    rbp,rsp
  400d24:	41 57                	push   r15
  400d26:	41 56                	push   r14
  400d28:	41 55                	push   r13
  400d2a:	41 54                	push   r12
  400d2c:	53                   	push   rbx
  400d2d:	48 83 ec 28          	sub    rsp,0x28
	struct slm_ipi_percore *ipi_data = slm_ipi_percore_get(cos_cpuid());
  400d31:	ff d0                	call   rax
	struct slm_ipi_thd     *r        = &ipi_data->ipi_thd;
	struct slm_ipi_event    event    = { 0 };
  400d33:	48 c7 45 c8 00 00 00 	mov    QWORD PTR [rbp-0x38],0x0
  400d3a:	00 
	struct slm_ipi_percore *ipi_data = slm_ipi_percore_get(cos_cpuid());
  400d3b:	48 89 45 b8          	mov    QWORD PTR [rbp-0x48],rax
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  400d3f:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  400d42:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  400d48:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  400d4f:	48 85 c0             	test   rax,rax
  400d52:	0f 84 3d 02 00 00    	je     400f95 <slm_ipi_process+0x285>
  400d58:	83 e8 01             	sub    eax,0x1
  400d5b:	83 f8 18             	cmp    eax,0x18
  400d5e:	0f 87 31 02 00 00    	ja     400f95 <slm_ipi_process+0x285>
  400d64:	48 b9 00 27 46 00 00 	movabs rcx,0x462700
  400d6b:	00 00 00 
  400d6e:	48 c7 45 b0 00 00 00 	mov    QWORD PTR [rbp-0x50],0x0
  400d75:	00 
  400d76:	48 8b 14 c1          	mov    rdx,QWORD PTR [rcx+rax*8]
}

static inline int
ss_state_is_allocated(ss_state_t state)
{
	return ((state & ~1) != 0) && ((state & 1) == SS_STATE_ALLOC);
  400d7a:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  400d81:	0f 85 c5 01 00 00    	jne    400f4c <slm_ipi_process+0x23c>
  400d87:	49 be d0 37 41 00 00 	movabs r14,0x4137d0
  400d8e:	00 00 00 
  400d91:	49 bc 80 5d 41 00 00 	movabs r12,0x415d80
  400d98:	00 00 00 
  400d9b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	struct slm_thd         *current  = slm_thd_current();
	struct slm_thd         *thd;

	while (1) {
		cos_rcv(r->rcv, RCV_ALL_PENDING, &rcvd);
  400da0:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  400da4:	48 8d 55 c4          	lea    rdx,[rbp-0x3c]
  400da8:	be 02 00 00 00       	mov    esi,0x2
  400dad:	48 8b 38             	mov    rdi,QWORD PTR [rax]
  400db0:	41 ff d6             	call   r14

		while (!slm_ipi_event_empty(cos_cpuid())) {
  400db3:	48 bb d0 35 41 00 00 	movabs rbx,0x4135d0
  400dba:	00 00 00 
  400dbd:	31 ff                	xor    edi,edi
  400dbf:	41 ff d4             	call   r12
  400dc2:	85 c0                	test   eax,eax
  400dc4:	75 da                	jne    400da0 <slm_ipi_process+0x90>
			slm_ipi_event_dequeue(&event, cos_cpuid());
  400dc6:	48 b8 20 5d 41 00 00 	movabs rax,0x415d20
  400dcd:	00 00 00 
  400dd0:	31 f6                	xor    esi,esi
  400dd2:	48 8d 7d c8          	lea    rdi,[rbp-0x38]
  400dd6:	ff d0                	call   rax
	return &ss_thd_get(id)->thd;
  400dd8:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  400ddc:	85 c0                	test   eax,eax
  400dde:	0f 84 e4 00 00 00    	je     400ec8 <slm_ipi_process+0x1b8>
  400de4:	83 e8 01             	sub    eax,0x1
  400de7:	83 f8 18             	cmp    eax,0x18
  400dea:	0f 87 d8 00 00 00    	ja     400ec8 <slm_ipi_process+0x1b8>
  400df0:	48 be 00 27 46 00 00 	movabs rsi,0x462700
  400df7:	00 00 00 
  400dfa:	45 31 ed             	xor    r13d,r13d
  400dfd:	48 8b 14 c6          	mov    rdx,QWORD PTR [rsi+rax*8]
  400e01:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  400e08:	74 19                	je     400e23 <slm_ipi_process+0x113>
  400e0a:	83 e2 01             	and    edx,0x1
  400e0d:	75 14                	jne    400e23 <slm_ipi_process+0x113>
  400e0f:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  400e13:	48 8d 04 50          	lea    rax,[rax+rdx*2]
  400e17:	48 c1 e0 04          	shl    rax,0x4
  400e1b:	4c 8d ac 06 c8 00 00 	lea    r13,[rsi+rax*1+0xc8]
  400e22:	00 
	assert(current);
  400e23:	48 83 7d b0 00       	cmp    QWORD PTR [rbp-0x50],0x0
  400e28:	0f 84 a8 00 00 00    	je     400ed6 <slm_ipi_process+0x1c6>
  400e2e:	49 bf c0 5e 5a 00 00 	movabs r15,0x5a5ec0
  400e35:	00 00 00 
		tok    = cos_sched_sync();
  400e38:	ff d3                	call   rbx
  400e3a:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  400e3d:	49 8b 07             	mov    rax,QWORD PTR [r15]
		if (unlikely(owner)) {
  400e40:	48 89 c1             	mov    rcx,rax
  400e43:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  400e47:	0f 85 b1 00 00 00    	jne    400efe <slm_ipi_process+0x1ee>
  400e4d:	48 8b 75 b0          	mov    rsi,QWORD PTR [rbp-0x50]
  400e51:	f0 49 0f b1 37       	lock cmpxchg QWORD PTR [r15],rsi
  400e56:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  400e59:	84 c0                	test   al,al
  400e5b:	74 db                	je     400e38 <slm_ipi_process+0x128>

			thd = slm_thd_static_cm_lookup(event.tid);
			slm_cs_enter(current, SLM_CS_NONE);
			ret = slm_thd_wakeup(thd, 0);
  400e5d:	48 b8 c0 66 41 00 00 	movabs rax,0x4166c0
  400e64:	00 00 00 
  400e67:	31 f6                	xor    esi,esi
  400e69:	4c 89 ef             	mov    rdi,r13
  400e6c:	ff d0                	call   rax
			/*
			 * Return "0" means the thread is woken up in this call.
			 * Return "1" means the thread is already `RUNNABLE`.
			 */
			assert(ret == 0 || ret == 1);
  400e6e:	83 f8 01             	cmp    eax,0x1
  400e71:	0f 87 f6 00 00 00    	ja     400f6d <slm_ipi_process+0x25d>
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  400e77:	49 bd b0 5f 41 00 00 	movabs r13,0x415fb0
  400e7e:	00 00 00 
  400e81:	eb 15                	jmp    400e98 <slm_ipi_process+0x188>
  400e83:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  400e88:	f0 49 0f b1 17       	lock cmpxchg QWORD PTR [r15],rdx
  400e8d:	0f 94 c0             	sete   al
	while (ret != 0) {
  400e90:	84 c0                	test   al,al
  400e92:	0f 85 25 ff ff ff    	jne    400dbd <slm_ipi_process+0xad>
		tok    = cos_sched_sync();
  400e98:	ff d3                	call   rbx
  400e9a:	89 c1                	mov    ecx,eax
  400e9c:	49 8b 07             	mov    rax,QWORD PTR [r15]
		if (unlikely(contention)) {
  400e9f:	48 89 c2             	mov    rdx,rax
  400ea2:	83 e2 01             	and    edx,0x1
  400ea5:	74 e1                	je     400e88 <slm_ipi_process+0x178>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  400ea7:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  400eaa:	48 89 c2             	mov    rdx,rax
  400ead:	4c 89 ff             	mov    rdi,r15
  400eb0:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  400eb4:	41 ff d5             	call   r13
  400eb7:	85 c0                	test   eax,eax
  400eb9:	0f 84 f4 fe ff ff    	je     400db3 <slm_ipi_process+0xa3>
  400ebf:	eb d7                	jmp    400e98 <slm_ipi_process+0x188>
  400ec1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  400ec8:	45 31 ed             	xor    r13d,r13d
	assert(current);
  400ecb:	48 83 7d b0 00       	cmp    QWORD PTR [rbp-0x50],0x0
  400ed0:	0f 85 58 ff ff ff    	jne    400e2e <slm_ipi_process+0x11e>
	return cos_print_str(s, strlen(s));
  400ed6:	48 bf 20 f2 41 00 00 	movabs rdi,0x41f220
  400edd:	00 00 00 
  400ee0:	be 59 00 00 00       	mov    esi,0x59
  400ee5:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  400eec:	00 00 00 
  400eef:	ff d0                	call   rax
  400ef1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400ef8:	00 00 00 00 
  400efc:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  400efe:	41 89 c0             	mov    r8d,eax
  400f01:	48 89 c6             	mov    rsi,rax
  400f04:	48 8b 55 b0          	mov    rdx,QWORD PTR [rbp-0x50]
  400f08:	4c 89 ff             	mov    rdi,r15
  400f0b:	48 b8 50 5f 41 00 00 	movabs rax,0x415f50
  400f12:	00 00 00 
  400f15:	41 83 e0 01          	and    r8d,0x1
  400f19:	ff d0                	call   rax
			assert(ret != -EBUSY);
  400f1b:	83 f8 f0             	cmp    eax,0xfffffff0
  400f1e:	0f 85 14 ff ff ff    	jne    400e38 <slm_ipi_process+0x128>
  400f24:	48 bf 80 f2 41 00 00 	movabs rdi,0x41f280
  400f2b:	00 00 00 
  400f2e:	be 59 00 00 00       	mov    esi,0x59
  400f33:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  400f3a:	00 00 00 
  400f3d:	ff d0                	call   rax
  400f3f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400f46:	00 00 00 00 
  400f4a:	0f 0b                	ud2    
  400f4c:	80 e2 01             	and    dl,0x1
  400f4f:	0f 85 32 fe ff ff    	jne    400d87 <slm_ipi_process+0x77>
  400f55:	48 69 c0 b0 00 00 00 	imul   rax,rax,0xb0
  400f5c:	48 8d 84 01 c8 00 00 	lea    rax,[rcx+rax*1+0xc8]
  400f63:	00 
  400f64:	48 89 45 b0          	mov    QWORD PTR [rbp-0x50],rax
  400f68:	e9 1a fe ff ff       	jmp    400d87 <slm_ipi_process+0x77>
  400f6d:	48 bf e0 f2 41 00 00 	movabs rdi,0x41f2e0
  400f74:	00 00 00 
  400f77:	be 24 00 00 00       	mov    esi,0x24
  400f7c:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  400f83:	00 00 00 
  400f86:	ff d0                	call   rax
			assert(ret == 0 || ret == 1);
  400f88:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400f8f:	00 00 00 00 
  400f93:	0f 0b                	ud2    
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  400f95:	48 c7 45 b0 00 00 00 	mov    QWORD PTR [rbp-0x50],0x0
  400f9c:	00 
  400f9d:	e9 e5 fd ff ff       	jmp    400d87 <slm_ipi_process+0x77>
  400fa2:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  400fa9:	00 00 00 00 
  400fad:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000400fb0 <slm_blkpt_alloc>:
	return &__blkpts[id-1];
}

sched_blkpt_id_t
slm_blkpt_alloc(struct slm_thd *current)
{
  400fb0:	f3 0f 1e fa          	endbr64 
  400fb4:	55                   	push   rbp
  400fb5:	48 89 e5             	mov    rbp,rsp
  400fb8:	41 56                	push   r14
  400fba:	49 be c0 5e 5a 00 00 	movabs r14,0x5a5ec0
  400fc1:	00 00 00 
  400fc4:	41 55                	push   r13
  400fc6:	49 89 fd             	mov    r13,rdi
  400fc9:	41 54                	push   r12
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  400fcb:	49 bc 50 5f 41 00 00 	movabs r12,0x415f50
  400fd2:	00 00 00 
  400fd5:	53                   	push   rbx
  400fd6:	48 bb d0 35 41 00 00 	movabs rbx,0x4135d0
  400fdd:	00 00 00 
	assert(current);
  400fe0:	48 85 ff             	test   rdi,rdi
  400fe3:	0f 84 0b 01 00 00    	je     4010f4 <slm_blkpt_alloc+0x144>
		tok    = cos_sched_sync();
  400fe9:	ff d3                	call   rbx
  400feb:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  400fee:	49 8b 06             	mov    rax,QWORD PTR [r14]
		if (unlikely(owner)) {
  400ff1:	48 89 c1             	mov    rcx,rax
  400ff4:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  400ff8:	0f 85 b2 00 00 00    	jne    4010b0 <slm_blkpt_alloc+0x100>
  400ffe:	f0 4d 0f b1 2e       	lock cmpxchg QWORD PTR [r14],r13
  401003:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  401006:	84 c0                	test   al,al
  401008:	74 df                	je     400fe9 <slm_blkpt_alloc+0x39>
	struct blkpt_mem *m;
	sched_blkpt_id_t ret = SCHED_BLKPT_NULL;

	slm_cs_enter(current, SLM_CS_NONE);

	id = (sched_blkpt_id_t)__blkpt_offset;
  40100a:	48 ba 00 80 42 00 00 	movabs rdx,0x428000
  401011:	00 00 00 
  401014:	44 8b 22             	mov    r12d,DWORD PTR [rdx]
	if (id - 1 == NBLKPTS) return NULL;
  401017:	41 81 fc 01 a0 00 00 	cmp    r12d,0xa001
  40101e:	0f 84 f8 00 00 00    	je     40111c <slm_blkpt_alloc+0x16c>
	return &__blkpts[id-1];
  401024:	48 b9 00 39 46 00 00 	movabs rcx,0x463900
  40102b:	00 00 00 
  40102e:	41 8d 44 24 ff       	lea    eax,[r12-0x1]
  401033:	48 c1 e0 05          	shl    rax,0x5
  401037:	48 01 c8             	add    rax,rcx
	m  = blkpt_get(id);
	if (!m) ERR_THROW(SCHED_BLKPT_NULL, unlock);

	m->id    = id;
  40103a:	44 89 20             	mov    DWORD PTR [rax],r12d
	ret      = id;
	m->epoch = 0;
  40103d:	48 c7 40 08 00 00 00 	mov    QWORD PTR [rax+0x8],0x0
  401044:	00 
};

static inline void
stacklist_init(struct stacklist_head *h)
{
	h->head = NULL;
  401045:	48 c7 40 10 00 00 00 	mov    QWORD PTR [rax+0x10],0x0
  40104c:	00 
ps_lock_release(struct ps_lock *l)
{ l->o = 0; }

static inline void
ps_lock_init(struct ps_lock *l)
{ l->o = 0; }
  40104d:	48 c7 40 18 00 00 00 	mov    QWORD PTR [rax+0x18],0x0
  401054:	00 
	stacklist_init(&m->blocked);
	ps_lock_init(&m->lock);
	__blkpt_offset++;
  401055:	41 8d 44 24 01       	lea    eax,[r12+0x1]
  40105a:	89 02                	mov    DWORD PTR [rdx],eax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  40105c:	49 bd b0 5f 41 00 00 	movabs r13,0x415fb0
  401063:	00 00 00 
  401066:	eb 14                	jmp    40107c <slm_blkpt_alloc+0xcc>
  401068:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40106f:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  401070:	f0 49 0f b1 16       	lock cmpxchg QWORD PTR [r14],rdx
  401075:	0f 94 c0             	sete   al
	while (ret != 0) {
  401078:	84 c0                	test   al,al
  40107a:	75 23                	jne    40109f <slm_blkpt_alloc+0xef>
		tok    = cos_sched_sync();
  40107c:	ff d3                	call   rbx
  40107e:	89 c1                	mov    ecx,eax
  401080:	49 8b 06             	mov    rax,QWORD PTR [r14]
		if (unlikely(contention)) {
  401083:	48 89 c2             	mov    rdx,rax
  401086:	83 e2 01             	and    edx,0x1
  401089:	74 e5                	je     401070 <slm_blkpt_alloc+0xc0>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  40108b:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  40108e:	48 89 c2             	mov    rdx,rax
  401091:	4c 89 f7             	mov    rdi,r14
  401094:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  401098:	41 ff d5             	call   r13
  40109b:	85 c0                	test   eax,eax
  40109d:	75 dd                	jne    40107c <slm_blkpt_alloc+0xcc>
unlock:
	slm_cs_exit(NULL, SLM_CS_NONE);

	return ret;
}
  40109f:	5b                   	pop    rbx
  4010a0:	44 89 e0             	mov    eax,r12d
  4010a3:	41 5c                	pop    r12
  4010a5:	41 5d                	pop    r13
  4010a7:	41 5e                	pop    r14
  4010a9:	5d                   	pop    rbp
  4010aa:	c3                   	ret    
  4010ab:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  4010b0:	41 89 c0             	mov    r8d,eax
  4010b3:	4c 89 ea             	mov    rdx,r13
  4010b6:	48 89 c6             	mov    rsi,rax
  4010b9:	4c 89 f7             	mov    rdi,r14
  4010bc:	41 83 e0 01          	and    r8d,0x1
  4010c0:	41 ff d4             	call   r12
			assert(ret != -EBUSY);
  4010c3:	83 f8 f0             	cmp    eax,0xfffffff0
  4010c6:	0f 85 1d ff ff ff    	jne    400fe9 <slm_blkpt_alloc+0x39>
  4010cc:	48 bf 80 f2 41 00 00 	movabs rdi,0x41f280
  4010d3:	00 00 00 
  4010d6:	be 59 00 00 00       	mov    esi,0x59
  4010db:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4010e2:	00 00 00 
  4010e5:	ff d0                	call   rax
  4010e7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4010ee:	00 00 00 00 
  4010f2:	0f 0b                	ud2    
  4010f4:	48 bf 20 f2 41 00 00 	movabs rdi,0x41f220
  4010fb:	00 00 00 
  4010fe:	be 59 00 00 00       	mov    esi,0x59
  401103:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40110a:	00 00 00 
  40110d:	ff d0                	call   rax
	assert(current);
  40110f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401116:	00 00 00 00 
  40111a:	0f 0b                	ud2    
	if (!m) ERR_THROW(SCHED_BLKPT_NULL, unlock);
  40111c:	45 31 e4             	xor    r12d,r12d
  40111f:	e9 38 ff ff ff       	jmp    40105c <slm_blkpt_alloc+0xac>
  401124:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40112b:	00 00 00 00 
  40112f:	90                   	nop

0000000000401130 <slm_blkpt_free>:

int
slm_blkpt_free(sched_blkpt_id_t id)
{
  401130:	f3 0f 1e fa          	endbr64 
	/* alloc only for now */
	return 0;
}
  401134:	31 c0                	xor    eax,eax
  401136:	c3                   	ret    
  401137:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40113e:	00 00 

0000000000401140 <slm_blkpt_trigger>:

int
slm_blkpt_trigger(sched_blkpt_id_t blkpt, struct slm_thd *current, sched_blkpt_epoch_t epoch, int single)
{
  401140:	f3 0f 1e fa          	endbr64 
  401144:	55                   	push   rbp
  401145:	48 89 e5             	mov    rbp,rsp
  401148:	41 57                	push   r15
  40114a:	49 89 d7             	mov    r15,rdx
  40114d:	41 56                	push   r14
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  40114f:	49 be 50 5f 41 00 00 	movabs r14,0x415f50
  401156:	00 00 00 
  401159:	41 55                	push   r13
  40115b:	41 89 fd             	mov    r13d,edi
  40115e:	41 54                	push   r12
  401160:	49 bc d0 35 41 00 00 	movabs r12,0x4135d0
  401167:	00 00 00 
  40116a:	53                   	push   rbx
  40116b:	48 bb c0 5e 5a 00 00 	movabs rbx,0x5a5ec0
  401172:	00 00 00 
  401175:	48 83 ec 18          	sub    rsp,0x18
  401179:	48 89 75 c0          	mov    QWORD PTR [rbp-0x40],rsi
  40117d:	89 4d cc             	mov    DWORD PTR [rbp-0x34],ecx
	assert(current);
  401180:	48 85 f6             	test   rsi,rsi
  401183:	0f 84 75 02 00 00    	je     4013fe <slm_blkpt_trigger+0x2be>
		tok    = cos_sched_sync();
  401189:	41 ff d4             	call   r12
  40118c:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  40118f:	48 8b 03             	mov    rax,QWORD PTR [rbx]
		if (unlikely(owner)) {
  401192:	48 89 c1             	mov    rcx,rax
  401195:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  401199:	0f 85 1a 02 00 00    	jne    4013b9 <slm_blkpt_trigger+0x279>
  40119f:	48 8b 7d c0          	mov    rdi,QWORD PTR [rbp-0x40]
  4011a3:	f0 48 0f b1 3b       	lock cmpxchg QWORD PTR [rbx],rdi
  4011a8:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4011ab:	84 c0                	test   al,al
  4011ad:	74 da                	je     401189 <slm_blkpt_trigger+0x49>
	if (id - 1 == NBLKPTS) return NULL;
  4011af:	41 81 fd 01 a0 00 00 	cmp    r13d,0xa001
  4011b6:	0f 84 6a 02 00 00    	je     401426 <slm_blkpt_trigger+0x2e6>
	return &__blkpts[id-1];
  4011bc:	45 8d 4d ff          	lea    r9d,[r13-0x1]
  4011c0:	41 ba 01 00 00 00    	mov    r10d,0x1
  4011c6:	31 ff                	xor    edi,edi
  4011c8:	48 b9 00 39 46 00 00 	movabs rcx,0x463900
  4011cf:	00 00 00 
  4011d2:	4c 89 ce             	mov    rsi,r9
  4011d5:	48 c1 e6 05          	shl    rsi,0x5
  4011d9:	4c 8d 34 31          	lea    r14,[rcx+rsi*1]
{ while (!ps_cas(&l->o, 0, 1)) ; }
  4011dd:	49 8d 56 18          	lea    rdx,[r14+0x18]
  4011e1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  4011e8:	48 89 f8             	mov    rax,rdi
  4011eb:	f0 4c 0f b1 12       	lock cmpxchg QWORD PTR [rdx],r10
  4011f0:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  4011f3:	84 c0                	test   al,al
  4011f5:	74 f1                	je     4011e8 <slm_blkpt_trigger+0xa8>

		if (!blkpt_epoch_is_higher(pre, epoch)) {
			ps_lock_release(&m->lock);
			ERR_THROW(0, unlock); 
		}
		if (ps_cas(&m->epoch, pre, epoch)) break;
  4011f7:	48 8d 54 31 08       	lea    rdx,[rcx+rsi*1+0x8]
  4011fc:	eb 0e                	jmp    40120c <slm_blkpt_trigger+0xcc>
  4011fe:	66 90                	xchg   ax,ax
        __asm__ __volatile__("lock " PS_CAS_STR
  401200:	f0 4c 0f b1 3a       	lock cmpxchg QWORD PTR [rdx],r15
  401205:	0f 94 c0             	sete   al
  401208:	84 c0                	test   al,al
  40120a:	75 6c                	jne    401278 <slm_blkpt_trigger+0x138>
		sched_blkpt_epoch_t pre = ps_load(&m->epoch);
  40120c:	49 8b 46 08          	mov    rax,QWORD PTR [r14+0x8]
		if (!blkpt_epoch_is_higher(pre, epoch)) {
  401210:	4c 39 f8             	cmp    rax,r15
  401213:	76 eb                	jbe    401200 <slm_blkpt_trigger+0xc0>
{ l->o = 0; }
  401215:	49 c7 46 18 00 00 00 	mov    QWORD PTR [r14+0x18],0x0
  40121c:	00 
			ERR_THROW(0, unlock); 
  40121d:	45 31 ed             	xor    r13d,r13d
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  401220:	49 be b0 5f 41 00 00 	movabs r14,0x415fb0
  401227:	00 00 00 
  40122a:	eb 10                	jmp    40123c <slm_blkpt_trigger+0xfc>
  40122c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  401230:	f0 48 0f b1 13       	lock cmpxchg QWORD PTR [rbx],rdx
  401235:	0f 94 c0             	sete   al
	while (ret != 0) {
  401238:	84 c0                	test   al,al
  40123a:	75 24                	jne    401260 <slm_blkpt_trigger+0x120>
		tok    = cos_sched_sync();
  40123c:	41 ff d4             	call   r12
  40123f:	89 c1                	mov    ecx,eax
  401241:	48 8b 03             	mov    rax,QWORD PTR [rbx]
		if (unlikely(contention)) {
  401244:	48 89 c2             	mov    rdx,rax
  401247:	83 e2 01             	and    edx,0x1
  40124a:	74 e4                	je     401230 <slm_blkpt_trigger+0xf0>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  40124c:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  40124f:	48 89 c2             	mov    rdx,rax
  401252:	48 89 df             	mov    rdi,rbx
  401255:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  401259:	41 ff d6             	call   r14
  40125c:	85 c0                	test   eax,eax
  40125e:	75 dc                	jne    40123c <slm_blkpt_trigger+0xfc>
	return 0;
unlock:
	slm_cs_exit(NULL, SLM_CS_NONE);

	return ret;
}
  401260:	48 83 c4 18          	add    rsp,0x18
  401264:	44 89 e8             	mov    eax,r13d
  401267:	5b                   	pop    rbx
  401268:	41 5c                	pop    r12
  40126a:	41 5d                	pop    r13
  40126c:	41 5e                	pop    r14
  40126e:	41 5f                	pop    r15
  401270:	5d                   	pop    rbp
  401271:	c3                   	ret    
  401272:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	 * threads, but we'll implement this conservatively. Given
	 * this, please note that this should *not* iterate more than
	 * once.
	 */
	while (1) {
		sl = ps_load(&h->head);
  401278:	49 c1 e1 05          	shl    r9,0x5
		/*
		 * Check sl again in case other thread updating the head,
		 * which might causes dereferencing a NULL pointer.
		 */
		if (!sl) return NULL;
		if (ps_cas((unsigned long *)&h->head, (unsigned long)sl, (unsigned long)sl->next)) break;
  40127c:	4c 8d 7c 31 10       	lea    r15,[rcx+rsi*1+0x10]
		sl = ps_load(&h->head);
  401281:	4e 8d 2c 09          	lea    r13,[rcx+r9*1]
  401285:	0f 1f 00             	nop    DWORD PTR [rax]
	if (!h->head) return NULL;
  401288:	49 83 7e 10 00       	cmp    QWORD PTR [r14+0x10],0x0
  40128d:	75 1f                	jne    4012ae <slm_blkpt_trigger+0x16e>
  40128f:	eb 26                	jmp    4012b7 <slm_blkpt_trigger+0x177>
  401291:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  401298:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
  40129b:	48 89 d0             	mov    rax,rdx
  40129e:	f0 49 0f b1 0f       	lock cmpxchg QWORD PTR [r15],rcx
  4012a3:	0f 94 c0             	sete   al
		if (ps_cas((unsigned long *)&h->head, (unsigned long)sl, (unsigned long)sl->next)) break;
  4012a6:	84 c0                	test   al,al
  4012a8:	0f 85 e2 00 00 00    	jne    401390 <slm_blkpt_trigger+0x250>
		sl = ps_load(&h->head);
  4012ae:	49 8b 55 10          	mov    rdx,QWORD PTR [r13+0x10]
		if (!sl) return NULL;
  4012b2:	48 85 d2             	test   rdx,rdx
  4012b5:	75 e1                	jne    401298 <slm_blkpt_trigger+0x158>
{ l->o = 0; }
  4012b7:	49 c7 46 18 00 00 00 	mov    QWORD PTR [r14+0x18],0x0
  4012be:	00 
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  4012bf:	49 bf 50 48 41 00 00 	movabs r15,0x414850
  4012c6:	00 00 00 
  4012c9:	49 be 10 ce 40 00 00 	movabs r14,0x40ce10
  4012d0:	00 00 00 
  4012d3:	41 ff d6             	call   r14
	tok  = cos_sched_sync();
  4012d6:	41 ff d4             	call   r12
  4012d9:	89 45 cc             	mov    DWORD PTR [rbp-0x34],eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  4012dc:	41 ff d7             	call   r15
	if (unlikely(!t)) t = &g->idle_thd;
  4012df:	48 85 c0             	test   rax,rax
  4012e2:	49 89 c5             	mov    r13,rax
  4012e5:	48 b8 40 5f 5a 00 00 	movabs rax,0x5a5f40
  4012ec:	00 00 00 
  4012ef:	4c 0f 44 e8          	cmove  r13,rax
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  4012f3:	41 8b 45 04          	mov    eax,DWORD PTR [r13+0x4]
  4012f7:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  4012fa:	83 f8 01             	cmp    eax,0x1
  4012fd:	76 15                	jbe    401314 <slm_blkpt_trigger+0x1d4>
  4012ff:	e9 2d 01 00 00       	jmp    401431 <slm_blkpt_trigger+0x2f1>
  401304:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  401308:	f0 48 0f b1 13       	lock cmpxchg QWORD PTR [rbx],rdx
  40130d:	0f 94 c0             	sete   al
	while (ret != 0) {
  401310:	84 c0                	test   al,al
  401312:	75 2d                	jne    401341 <slm_blkpt_trigger+0x201>
		tok    = cos_sched_sync();
  401314:	41 ff d4             	call   r12
  401317:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  401319:	48 8b 03             	mov    rax,QWORD PTR [rbx]
		if (unlikely(contention)) {
  40131c:	48 89 c2             	mov    rdx,rax
  40131f:	83 e2 01             	and    edx,0x1
  401322:	74 e4                	je     401308 <slm_blkpt_trigger+0x1c8>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  401324:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  401327:	48 89 c2             	mov    rdx,rax
  40132a:	48 89 df             	mov    rdi,rbx
  40132d:	48 b8 b0 5f 41 00 00 	movabs rax,0x415fb0
  401334:	00 00 00 
  401337:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  40133b:	ff d0                	call   rax
  40133d:	85 c0                	test   eax,eax
  40133f:	75 d3                	jne    401314 <slm_blkpt_trigger+0x1d4>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  401341:	41 ff d6             	call   r14
	prio = inherit_prio ? curr->priority : t->priority;
  401344:	49 8b 75 30          	mov    rsi,QWORD PTR [r13+0x30]
	timeout = g->timeout_next;
  401348:	48 b8 c8 5f 5a 00 00 	movabs rax,0x5a5fc8
  40134f:	00 00 00 
  401352:	4c 8b 00             	mov    r8,QWORD PTR [rax]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  401355:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
  401359:	a8 0b                	test   al,0xb
  40135b:	0f 85 f8 00 00 00    	jne    401459 <slm_blkpt_trigger+0x319>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  401361:	49 8b 7d 10          	mov    rdi,QWORD PTR [r13+0x10]
  401365:	8b 4d cc             	mov    ecx,DWORD PTR [rbp-0x34]
  401368:	4c 89 c2             	mov    rdx,r8
  40136b:	48 b8 70 e1 40 00 00 	movabs rax,0x40e170
  401372:	00 00 00 
  401375:	ff d0                	call   rax
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  401377:	83 f8 ff             	cmp    eax,0xffffffff
  40137a:	0f 84 90 01 00 00    	je     401510 <slm_blkpt_trigger+0x3d0>
	if (unlikely(ret != 0)) {
  401380:	85 c0                	test   eax,eax
  401382:	0f 85 32 01 00 00    	jne    4014ba <slm_blkpt_trigger+0x37a>
	return 0;
  401388:	45 31 ed             	xor    r13d,r13d
  40138b:	e9 d0 fe ff ff       	jmp    401260 <slm_blkpt_trigger+0x120>
	}
	sl->next = NULL;
  401390:	48 c7 02 00 00 00 00 	mov    QWORD PTR [rdx],0x0
		slm_thd_wakeup(t, 0); /* ignore retval: process next thread */
  401397:	48 8b 7a 08          	mov    rdi,QWORD PTR [rdx+0x8]
  40139b:	31 f6                	xor    esi,esi
  40139d:	48 b8 c0 66 41 00 00 	movabs rax,0x4166c0
  4013a4:	00 00 00 
  4013a7:	ff d0                	call   rax
		if (single) break;
  4013a9:	8b 45 cc             	mov    eax,DWORD PTR [rbp-0x34]
  4013ac:	85 c0                	test   eax,eax
  4013ae:	0f 84 d4 fe ff ff    	je     401288 <slm_blkpt_trigger+0x148>
  4013b4:	e9 fe fe ff ff       	jmp    4012b7 <slm_blkpt_trigger+0x177>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  4013b9:	41 89 c0             	mov    r8d,eax
  4013bc:	48 8b 55 c0          	mov    rdx,QWORD PTR [rbp-0x40]
  4013c0:	48 89 c6             	mov    rsi,rax
  4013c3:	48 89 df             	mov    rdi,rbx
  4013c6:	41 83 e0 01          	and    r8d,0x1
  4013ca:	41 ff d6             	call   r14
			assert(ret != -EBUSY);
  4013cd:	83 f8 f0             	cmp    eax,0xfffffff0
  4013d0:	0f 85 b3 fd ff ff    	jne    401189 <slm_blkpt_trigger+0x49>
  4013d6:	48 bf 80 f2 41 00 00 	movabs rdi,0x41f280
  4013dd:	00 00 00 
  4013e0:	be 59 00 00 00       	mov    esi,0x59
  4013e5:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4013ec:	00 00 00 
  4013ef:	ff d0                	call   rax
  4013f1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4013f8:	00 00 00 00 
  4013fc:	0f 0b                	ud2    
  4013fe:	48 bf 20 f2 41 00 00 	movabs rdi,0x41f220
  401405:	00 00 00 
  401408:	be 59 00 00 00       	mov    esi,0x59
  40140d:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  401414:	00 00 00 
  401417:	ff d0                	call   rax
	assert(current);
  401419:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401420:	00 00 00 00 
  401424:	0f 0b                	ud2    
	if (!m) ERR_THROW(-1, unlock);
  401426:	41 bd ff ff ff ff    	mov    r13d,0xffffffff
  40142c:	e9 ef fd ff ff       	jmp    401220 <slm_blkpt_trigger+0xe0>
  401431:	48 bf 08 f3 41 00 00 	movabs rdi,0x41f308
  401438:	00 00 00 
  40143b:	be 61 00 00 00       	mov    esi,0x61
  401440:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  401447:	00 00 00 
  40144a:	ff d0                	call   rax
	assert(slm_state_is_runnable(t->state));
  40144c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401453:	00 00 00 00 
  401457:	0f 0b                	ud2    
		if (t == &g->sched_thd) {
  401459:	48 ba c8 5e 5a 00 00 	movabs rdx,0x5a5ec8
  401460:	00 00 00 
	timeout = g->timeout_next;
  401463:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  401466:	49 39 d5             	cmp    r13,rdx
  401469:	0f 84 e1 00 00 00    	je     401550 <slm_blkpt_trigger+0x410>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  40146f:	a8 02                	test   al,0x2
  401471:	0f 85 e8 00 00 00    	jne    40155f <slm_blkpt_trigger+0x41f>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  401477:	49 89 c8             	mov    r8,rcx
  40147a:	a8 01                	test   al,0x1
  40147c:	0f 84 df fe ff ff    	je     401361 <slm_blkpt_trigger+0x221>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  401482:	4d 8b 55 08          	mov    r10,QWORD PTR [r13+0x8]
  401486:	48 89 f2             	mov    rdx,rsi
  401489:	49 8b 7d 10          	mov    rdi,QWORD PTR [r13+0x10]
  40148d:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  401494:	00 00 00 
  401497:	44 8b 4d cc          	mov    r9d,DWORD PTR [rbp-0x34]
  40149b:	4c 8b 00             	mov    r8,QWORD PTR [rax]
  40149e:	48 b8 f0 35 41 00 00 	movabs rax,0x4135f0
  4014a5:	00 00 00 
  4014a8:	4c 89 d6             	mov    rsi,r10
  4014ab:	ff d0                	call   rax
	if (unlikely(ret != 0)) {
  4014ad:	85 c0                	test   eax,eax
  4014af:	0f 84 d3 fe ff ff    	je     401388 <slm_blkpt_trigger+0x248>
		assert(ret != -EPERM);
  4014b5:	83 f8 ff             	cmp    eax,0xffffffff
  4014b8:	74 6e                	je     401528 <slm_blkpt_trigger+0x3e8>
		assert(ret != -EINVAL);
  4014ba:	83 f8 ea             	cmp    eax,0xffffffea
  4014bd:	0f 84 45 01 00 00    	je     401608 <slm_blkpt_trigger+0x4c8>
		if (ret == -EBUSY) return ret;
  4014c3:	83 f8 f0             	cmp    eax,0xfffffff0
  4014c6:	0f 84 bc fe ff ff    	je     401388 <slm_blkpt_trigger+0x248>
		assert(ret == -EAGAIN);
  4014cc:	83 f8 f5             	cmp    eax,0xfffffff5
  4014cf:	0f 85 0b 01 00 00    	jne    4015e0 <slm_blkpt_trigger+0x4a0>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  4014d5:	49 bd 50 5f 41 00 00 	movabs r13,0x415f50
  4014dc:	00 00 00 
		tok    = cos_sched_sync();
  4014df:	41 ff d4             	call   r12
	unsigned long oc = ps_load(&cs->owner_contention);
  4014e2:	48 8b 33             	mov    rsi,QWORD PTR [rbx]
  4014e5:	41 89 c1             	mov    r9d,eax
		if (unlikely(owner)) {
  4014e8:	48 89 f1             	mov    rcx,rsi
  4014eb:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  4014ef:	0f 85 c4 00 00 00    	jne    4015b9 <slm_blkpt_trigger+0x479>
  4014f5:	48 8b 7d c0          	mov    rdi,QWORD PTR [rbp-0x40]
  4014f9:	48 89 f0             	mov    rax,rsi
  4014fc:	f0 48 0f b1 3b       	lock cmpxchg QWORD PTR [rbx],rdi
  401501:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  401504:	84 c0                	test   al,al
  401506:	0f 85 ca fd ff ff    	jne    4012d6 <slm_blkpt_trigger+0x196>
  40150c:	eb d1                	jmp    4014df <slm_blkpt_trigger+0x39f>
  40150e:	66 90                	xchg   ax,ax
	return t != &g->idle_thd && t != &g->sched_thd;
  401510:	48 b8 40 5f 5a 00 00 	movabs rax,0x5a5f40
  401517:	00 00 00 
  40151a:	49 39 c5             	cmp    r13,rax
  40151d:	74 68                	je     401587 <slm_blkpt_trigger+0x447>
  40151f:	48 83 e8 78          	sub    rax,0x78
  401523:	49 39 c5             	cmp    r13,rax
  401526:	74 5f                	je     401587 <slm_blkpt_trigger+0x447>
  401528:	48 bf 70 f3 41 00 00 	movabs rdi,0x41f370
  40152f:	00 00 00 
  401532:	be 61 00 00 00       	mov    esi,0x61
  401537:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40153e:	00 00 00 
  401541:	ff d0                	call   rax
		assert(ret != -EPERM);
  401543:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40154a:	00 00 00 00 
  40154e:	0f 0b                	ud2    
			prio    = curr->priority;
  401550:	48 8b 7d c0          	mov    rdi,QWORD PTR [rbp-0x40]
			timeout = TCAP_TIME_NIL;
  401554:	31 c9                	xor    ecx,ecx
			prio    = curr->priority;
  401556:	48 8b 77 30          	mov    rsi,QWORD PTR [rdi+0x30]
  40155a:	e9 10 ff ff ff       	jmp    40146f <slm_blkpt_trigger+0x32f>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  40155f:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  401566:	00 00 00 
  401569:	49 8b 7d 28          	mov    rdi,QWORD PTR [r13+0x28]
  40156d:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  401570:	4c 89 c6             	mov    rsi,r8
  401573:	48 b8 60 36 41 00 00 	movabs rax,0x413660
  40157a:	00 00 00 
  40157d:	8b 4d cc             	mov    ecx,DWORD PTR [rbp-0x34]
  401580:	ff d0                	call   rax
  401582:	e9 26 ff ff ff       	jmp    4014ad <slm_blkpt_trigger+0x36d>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  401587:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
  40158b:	44 8b 4d cc          	mov    r9d,DWORD PTR [rbp-0x34]
  40158f:	31 c9                	xor    ecx,ecx
  401591:	31 f6                	xor    esi,esi
  401593:	48 8b 50 30          	mov    rdx,QWORD PTR [rax+0x30]
  401597:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  40159e:	00 00 00 
  4015a1:	4c 8b 00             	mov    r8,QWORD PTR [rax]
  4015a4:	48 8b 78 f0          	mov    rdi,QWORD PTR [rax-0x10]
  4015a8:	48 b8 f0 35 41 00 00 	movabs rax,0x4135f0
  4015af:	00 00 00 
  4015b2:	ff d0                	call   rax
  4015b4:	e9 f4 fe ff ff       	jmp    4014ad <slm_blkpt_trigger+0x36d>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  4015b9:	41 89 f0             	mov    r8d,esi
  4015bc:	48 8b 55 c0          	mov    rdx,QWORD PTR [rbp-0x40]
  4015c0:	48 89 df             	mov    rdi,rbx
  4015c3:	41 83 e0 01          	and    r8d,0x1
  4015c7:	41 ff d5             	call   r13
			assert(ret != -EBUSY);
  4015ca:	83 f8 f0             	cmp    eax,0xfffffff0
  4015cd:	0f 85 0c ff ff ff    	jne    4014df <slm_blkpt_trigger+0x39f>
  4015d3:	e9 fe fd ff ff       	jmp    4013d6 <slm_blkpt_trigger+0x296>
  4015d8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4015df:	00 
  4015e0:	48 bf 40 f4 41 00 00 	movabs rdi,0x41f440
  4015e7:	00 00 00 
  4015ea:	be 61 00 00 00       	mov    esi,0x61
  4015ef:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4015f6:	00 00 00 
  4015f9:	ff d0                	call   rax
		assert(ret == -EAGAIN);
  4015fb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401602:	00 00 00 00 
  401606:	0f 0b                	ud2    
  401608:	48 bf d8 f3 41 00 00 	movabs rdi,0x41f3d8
  40160f:	00 00 00 
  401612:	be 61 00 00 00       	mov    esi,0x61
  401617:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40161e:	00 00 00 
  401621:	ff d0                	call   rax
		assert(ret != -EINVAL);
  401623:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40162a:	00 00 00 00 
  40162e:	0f 0b                	ud2    

0000000000401630 <slm_blkpt_block>:

int
slm_blkpt_block(sched_blkpt_id_t blkpt, struct slm_thd *current, sched_blkpt_epoch_t epoch, thdid_t dependency)
{
  401630:	f3 0f 1e fa          	endbr64 
  401634:	55                   	push   rbp
  401635:	48 89 e5             	mov    rbp,rsp
  401638:	41 57                	push   r15
  40163a:	49 bf c0 5e 5a 00 00 	movabs r15,0x5a5ec0
  401641:	00 00 00 
  401644:	41 56                	push   r14
  401646:	41 89 fe             	mov    r14d,edi
  401649:	41 55                	push   r13
  40164b:	49 89 d5             	mov    r13,rdx
  40164e:	41 54                	push   r12
  401650:	49 89 f4             	mov    r12,rsi
  401653:	53                   	push   rbx
  401654:	48 bb d0 35 41 00 00 	movabs rbx,0x4135d0
  40165b:	00 00 00 
  40165e:	48 83 ec 28          	sub    rsp,0x28
	assert(current);
  401662:	48 85 f6             	test   rsi,rsi
  401665:	0f 84 2a 02 00 00    	je     401895 <slm_blkpt_block+0x265>
		tok    = cos_sched_sync();
  40166b:	ff d3                	call   rbx
  40166d:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  401670:	49 8b 07             	mov    rax,QWORD PTR [r15]
		if (unlikely(owner)) {
  401673:	48 89 c1             	mov    rcx,rax
  401676:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  40167a:	0f 85 c8 01 00 00    	jne    401848 <slm_blkpt_block+0x218>
  401680:	f0 4d 0f b1 27       	lock cmpxchg QWORD PTR [r15],r12
  401685:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  401688:	84 c0                	test   al,al
  40168a:	74 df                	je     40166b <slm_blkpt_block+0x3b>
	if (id - 1 == NBLKPTS) return NULL;
  40168c:	41 81 fe 01 a0 00 00 	cmp    r14d,0xa001
  401693:	0f 84 24 02 00 00    	je     4018bd <slm_blkpt_block+0x28d>
	return &__blkpts[id-1];
  401699:	45 8d 46 ff          	lea    r8d,[r14-0x1]
  40169d:	be 01 00 00 00       	mov    esi,0x1
  4016a2:	31 c9                	xor    ecx,ecx
  4016a4:	48 bf 00 39 46 00 00 	movabs rdi,0x463900
  4016ab:	00 00 00 
  4016ae:	4d 89 c1             	mov    r9,r8
  4016b1:	49 c1 e1 05          	shl    r9,0x5
  4016b5:	4e 8d 34 0f          	lea    r14,[rdi+r9*1]
{ while (!ps_cas(&l->o, 0, 1)) ; }
  4016b9:	49 8d 56 18          	lea    rdx,[r14+0x18]
  4016bd:	0f 1f 00             	nop    DWORD PTR [rax]
        __asm__ __volatile__("lock " PS_CAS_STR
  4016c0:	48 89 c8             	mov    rax,rcx
  4016c3:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  4016c8:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  4016cb:	84 c0                	test   al,al
  4016cd:	74 f1                	je     4016c0 <slm_blkpt_block+0x90>
		ERR_THROW(-1, unlock);
	}

	ps_lock_take(&m->lock);
	/* Outdated event? don't block! */
	pre = ps_load(&m->epoch);
  4016cf:	49 8b 76 08          	mov    rsi,QWORD PTR [r14+0x8]
	if (!blkpt_epoch_is_higher(pre, epoch)) {
  4016d3:	4c 39 ee             	cmp    rsi,r13
  4016d6:	76 60                	jbe    401738 <slm_blkpt_block+0x108>
{ l->o = 0; }
  4016d8:	49 c7 46 18 00 00 00 	mov    QWORD PTR [r14+0x18],0x0
  4016df:	00 
			 */
			assert(_sl == &sl);
		}
		assert(stacklist_is_removed(&sl));
		ps_lock_release(&m->lock);
		ERR_THROW(0, unlock);
  4016e0:	45 31 ed             	xor    r13d,r13d
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  4016e3:	49 bc b0 5f 41 00 00 	movabs r12,0x415fb0
  4016ea:	00 00 00 
  4016ed:	eb 0d                	jmp    4016fc <slm_blkpt_block+0xcc>
  4016ef:	90                   	nop
        __asm__ __volatile__("lock " PS_CAS_STR
  4016f0:	f0 49 0f b1 17       	lock cmpxchg QWORD PTR [r15],rdx
  4016f5:	0f 94 c0             	sete   al
	while (ret != 0) {
  4016f8:	84 c0                	test   al,al
  4016fa:	75 23                	jne    40171f <slm_blkpt_block+0xef>
		tok    = cos_sched_sync();
  4016fc:	ff d3                	call   rbx
  4016fe:	89 c1                	mov    ecx,eax
  401700:	49 8b 07             	mov    rax,QWORD PTR [r15]
		if (unlikely(contention)) {
  401703:	48 89 c2             	mov    rdx,rax
  401706:	83 e2 01             	and    edx,0x1
  401709:	74 e5                	je     4016f0 <slm_blkpt_block+0xc0>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  40170b:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  40170e:	48 89 c2             	mov    rdx,rax
  401711:	4c 89 ff             	mov    rdi,r15
  401714:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  401718:	41 ff d4             	call   r12
  40171b:	85 c0                	test   eax,eax
  40171d:	75 dd                	jne    4016fc <slm_blkpt_block+0xcc>
	return 0;
unlock:
	slm_cs_exit(NULL, SLM_CS_NONE);

	return ret;
}
  40171f:	48 83 c4 28          	add    rsp,0x28
  401723:	44 89 e8             	mov    eax,r13d
  401726:	5b                   	pop    rbx
  401727:	41 5c                	pop    r12
  401729:	41 5d                	pop    r13
  40172b:	41 5e                	pop    r14
  40172d:	41 5f                	pop    r15
  40172f:	5d                   	pop    rbp
  401730:	c3                   	ret    
  401731:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		struct stacklist *n = ps_load(&h->head);
  401738:	4c 89 c1             	mov    rcx,r8
	l->data = data;
  40173b:	4c 89 65 c8          	mov    QWORD PTR [rbp-0x38],r12
		if (ps_cas((unsigned long *)&h->head, (unsigned long)n, (unsigned long)l)) break;
  40173f:	4a 8d 54 0f 10       	lea    rdx,[rdi+r9*1+0x10]
  401744:	4c 8d 4d c0          	lea    r9,[rbp-0x40]
		struct stacklist *n = ps_load(&h->head);
  401748:	48 c1 e1 05          	shl    rcx,0x5
  40174c:	48 01 f9             	add    rcx,rdi
  40174f:	90                   	nop
  401750:	48 8b 41 10          	mov    rax,QWORD PTR [rcx+0x10]
		l->next = n;
  401754:	48 89 45 c0          	mov    QWORD PTR [rbp-0x40],rax
  401758:	f0 4c 0f b1 0a       	lock cmpxchg QWORD PTR [rdx],r9
  40175d:	0f 94 c0             	sete   al
		if (ps_cas((unsigned long *)&h->head, (unsigned long)n, (unsigned long)l)) break;
  401760:	84 c0                	test   al,al
  401762:	74 ec                	je     401750 <slm_blkpt_block+0x120>
	if (!blkpt_epoch_is_higher(ps_load(&m->epoch), pre)) {
  401764:	49 8b 46 08          	mov    rax,QWORD PTR [r14+0x8]
  401768:	48 39 f0             	cmp    rax,rsi
  40176b:	0f 86 a7 00 00 00    	jbe    401818 <slm_blkpt_block+0x1e8>
	if (!h->head) return NULL;
  401771:	49 83 7e 10 00       	cmp    QWORD PTR [r14+0x10],0x0
  401776:	74 2b                	je     4017a3 <slm_blkpt_block+0x173>
		sl = ps_load(&h->head);
  401778:	49 c1 e0 05          	shl    r8,0x5
  40177c:	4c 01 c7             	add    rdi,r8
  40177f:	eb 19                	jmp    40179a <slm_blkpt_block+0x16a>
  401781:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  401788:	48 8b 31             	mov    rsi,QWORD PTR [rcx]
  40178b:	48 89 c8             	mov    rax,rcx
  40178e:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  401793:	0f 94 c0             	sete   al
		if (ps_cas((unsigned long *)&h->head, (unsigned long)sl, (unsigned long)sl->next)) break;
  401796:	84 c0                	test   al,al
  401798:	75 46                	jne    4017e0 <slm_blkpt_block+0x1b0>
		sl = ps_load(&h->head);
  40179a:	48 8b 4f 10          	mov    rcx,QWORD PTR [rdi+0x10]
		if (!sl) return NULL;
  40179e:	48 85 c9             	test   rcx,rcx
  4017a1:	75 e5                	jne    401788 <slm_blkpt_block+0x158>
		assert(stacklist_is_removed(&sl));
  4017a3:	48 83 7d c0 00       	cmp    QWORD PTR [rbp-0x40],0x0
  4017a8:	0f 84 2a ff ff ff    	je     4016d8 <slm_blkpt_block+0xa8>
  4017ae:	48 bf 08 f5 41 00 00 	movabs rdi,0x41f508
  4017b5:	00 00 00 
  4017b8:	be 5f 00 00 00       	mov    esi,0x5f
  4017bd:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4017c4:	00 00 00 
  4017c7:	ff d0                	call   rax
  4017c9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4017d0:	00 00 00 00 
  4017d4:	0f 0b                	ud2    
  4017d6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4017dd:	00 00 00 
	sl->next = NULL;
  4017e0:	48 c7 01 00 00 00 00 	mov    QWORD PTR [rcx],0x0
			assert(_sl == &sl);
  4017e7:	4c 39 c9             	cmp    rcx,r9
  4017ea:	74 b7                	je     4017a3 <slm_blkpt_block+0x173>
  4017ec:	48 bf a8 f4 41 00 00 	movabs rdi,0x41f4a8
  4017f3:	00 00 00 
  4017f6:	be 5f 00 00 00       	mov    esi,0x5f
  4017fb:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  401802:	00 00 00 
  401805:	ff d0                	call   rax
  401807:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40180e:	00 00 00 00 
  401812:	0f 0b                	ud2    
  401814:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	if (slm_thd_block(current)) {
  401818:	48 b8 30 60 41 00 00 	movabs rax,0x416030
  40181f:	00 00 00 
  401822:	4c 89 e7             	mov    rdi,r12
  401825:	ff d0                	call   rax
{ l->o = 0; }
  401827:	49 c7 46 18 00 00 00 	mov    QWORD PTR [r14+0x18],0x0
  40182e:	00 
  40182f:	41 89 c5             	mov    r13d,eax
  401832:	85 c0                	test   eax,eax
  401834:	0f 84 8e 00 00 00    	je     4018c8 <slm_blkpt_block+0x298>
		ERR_THROW(0, unlock);
  40183a:	45 31 ed             	xor    r13d,r13d
  40183d:	e9 a1 fe ff ff       	jmp    4016e3 <slm_blkpt_block+0xb3>
  401842:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  401848:	41 89 c0             	mov    r8d,eax
  40184b:	48 89 c6             	mov    rsi,rax
  40184e:	4c 89 e2             	mov    rdx,r12
  401851:	4c 89 ff             	mov    rdi,r15
  401854:	48 b8 50 5f 41 00 00 	movabs rax,0x415f50
  40185b:	00 00 00 
  40185e:	41 83 e0 01          	and    r8d,0x1
  401862:	ff d0                	call   rax
			assert(ret != -EBUSY);
  401864:	83 f8 f0             	cmp    eax,0xfffffff0
  401867:	0f 85 fe fd ff ff    	jne    40166b <slm_blkpt_block+0x3b>
  40186d:	48 bf 80 f2 41 00 00 	movabs rdi,0x41f280
  401874:	00 00 00 
  401877:	be 59 00 00 00       	mov    esi,0x59
  40187c:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  401883:	00 00 00 
  401886:	ff d0                	call   rax
  401888:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40188f:	00 00 00 00 
  401893:	0f 0b                	ud2    
  401895:	48 bf 20 f2 41 00 00 	movabs rdi,0x41f220
  40189c:	00 00 00 
  40189f:	be 59 00 00 00       	mov    esi,0x59
  4018a4:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4018ab:	00 00 00 
  4018ae:	ff d0                	call   rax
	assert(current);
  4018b0:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4018b7:	00 00 00 00 
  4018bb:	0f 0b                	ud2    
		ERR_THROW(-1, unlock);
  4018bd:	41 bd ff ff ff ff    	mov    r13d,0xffffffff
  4018c3:	e9 1b fe ff ff       	jmp    4016e3 <slm_blkpt_block+0xb3>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  4018c8:	48 b8 10 ce 40 00 00 	movabs rax,0x40ce10
  4018cf:	00 00 00 
  4018d2:	ff d0                	call   rax
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  4018d4:	44 89 6d bc          	mov    DWORD PTR [rbp-0x44],r13d
  4018d8:	4d 89 e5             	mov    r13,r12
	tok  = cos_sched_sync();
  4018db:	ff d3                	call   rbx
  4018dd:	41 89 c6             	mov    r14d,eax
  4018e0:	48 b8 50 48 41 00 00 	movabs rax,0x414850
  4018e7:	00 00 00 
  4018ea:	ff d0                	call   rax
	if (unlikely(!t)) t = &g->idle_thd;
  4018ec:	48 85 c0             	test   rax,rax
  4018ef:	49 89 c4             	mov    r12,rax
  4018f2:	48 b8 40 5f 5a 00 00 	movabs rax,0x5a5f40
  4018f9:	00 00 00 
  4018fc:	4c 0f 44 e0          	cmove  r12,rax
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  401900:	41 8b 44 24 04       	mov    eax,DWORD PTR [r12+0x4]
  401905:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  401908:	83 f8 01             	cmp    eax,0x1
  40190b:	76 17                	jbe    401924 <slm_blkpt_block+0x2f4>
  40190d:	e9 c6 01 00 00       	jmp    401ad8 <slm_blkpt_block+0x4a8>
  401912:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  401918:	f0 49 0f b1 17       	lock cmpxchg QWORD PTR [r15],rdx
  40191d:	0f 94 c0             	sete   al
	while (ret != 0) {
  401920:	84 c0                	test   al,al
  401922:	75 2c                	jne    401950 <slm_blkpt_block+0x320>
		tok    = cos_sched_sync();
  401924:	ff d3                	call   rbx
  401926:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  401928:	49 8b 07             	mov    rax,QWORD PTR [r15]
		if (unlikely(contention)) {
  40192b:	48 89 c2             	mov    rdx,rax
  40192e:	83 e2 01             	and    edx,0x1
  401931:	74 e5                	je     401918 <slm_blkpt_block+0x2e8>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  401933:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  401936:	48 89 c2             	mov    rdx,rax
  401939:	4c 89 ff             	mov    rdi,r15
  40193c:	48 b8 b0 5f 41 00 00 	movabs rax,0x415fb0
  401943:	00 00 00 
  401946:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  40194a:	ff d0                	call   rax
  40194c:	85 c0                	test   eax,eax
  40194e:	75 d4                	jne    401924 <slm_blkpt_block+0x2f4>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  401950:	48 b8 10 ce 40 00 00 	movabs rax,0x40ce10
  401957:	00 00 00 
  40195a:	ff d0                	call   rax
	prio = inherit_prio ? curr->priority : t->priority;
  40195c:	49 8b 74 24 30       	mov    rsi,QWORD PTR [r12+0x30]
	timeout = g->timeout_next;
  401961:	48 b8 c8 5f 5a 00 00 	movabs rax,0x5a5fc8
  401968:	00 00 00 
  40196b:	4c 8b 00             	mov    r8,QWORD PTR [rax]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  40196e:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  401972:	a8 0b                	test   al,0xb
  401974:	0f 85 a3 00 00 00    	jne    401a1d <slm_blkpt_block+0x3ed>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  40197a:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  40197f:	44 89 f1             	mov    ecx,r14d
  401982:	4c 89 c2             	mov    rdx,r8
  401985:	48 b8 70 e1 40 00 00 	movabs rax,0x40e170
  40198c:	00 00 00 
  40198f:	ff d0                	call   rax
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  401991:	83 f8 ff             	cmp    eax,0xffffffff
  401994:	74 3f                	je     4019d5 <slm_blkpt_block+0x3a5>
	if (unlikely(ret != 0)) {
  401996:	85 c0                	test   eax,eax
  401998:	0f 85 e5 00 00 00    	jne    401a83 <slm_blkpt_block+0x453>
	assert(stacklist_is_removed(&sl));
  40199e:	48 83 7d c0 00       	cmp    QWORD PTR [rbp-0x40],0x0
  4019a3:	44 8b 6d bc          	mov    r13d,DWORD PTR [rbp-0x44]
  4019a7:	0f 84 72 fd ff ff    	je     40171f <slm_blkpt_block+0xef>
  4019ad:	48 bf 68 f5 41 00 00 	movabs rdi,0x41f568
  4019b4:	00 00 00 
  4019b7:	be 5f 00 00 00       	mov    esi,0x5f
  4019bc:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4019c3:	00 00 00 
  4019c6:	ff d0                	call   rax
  4019c8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4019cf:	00 00 00 00 
  4019d3:	0f 0b                	ud2    
	return t != &g->idle_thd && t != &g->sched_thd;
  4019d5:	48 b8 c8 5e 5a 00 00 	movabs rax,0x5a5ec8
  4019dc:	00 00 00 
  4019df:	49 39 c4             	cmp    r12,rax
  4019e2:	0f 84 4c 01 00 00    	je     401b34 <slm_blkpt_block+0x504>
  4019e8:	48 83 c0 78          	add    rax,0x78
  4019ec:	49 39 c4             	cmp    r12,rax
  4019ef:	0f 84 3f 01 00 00    	je     401b34 <slm_blkpt_block+0x504>
  4019f5:	48 bf 70 f3 41 00 00 	movabs rdi,0x41f370
  4019fc:	00 00 00 
  4019ff:	be 61 00 00 00       	mov    esi,0x61
  401a04:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  401a0b:	00 00 00 
  401a0e:	ff d0                	call   rax
		assert(ret != -EPERM);
  401a10:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401a17:	00 00 00 00 
  401a1b:	0f 0b                	ud2    
		if (t == &g->sched_thd) {
  401a1d:	48 ba c8 5e 5a 00 00 	movabs rdx,0x5a5ec8
  401a24:	00 00 00 
	timeout = g->timeout_next;
  401a27:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  401a2a:	49 39 d4             	cmp    r12,rdx
  401a2d:	0f 84 cd 00 00 00    	je     401b00 <slm_blkpt_block+0x4d0>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  401a33:	a8 02                	test   al,0x2
  401a35:	0f 85 d0 00 00 00    	jne    401b0b <slm_blkpt_block+0x4db>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  401a3b:	49 89 c8             	mov    r8,rcx
  401a3e:	a8 01                	test   al,0x1
  401a40:	0f 84 34 ff ff ff    	je     40197a <slm_blkpt_block+0x34a>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  401a46:	4d 8b 54 24 08       	mov    r10,QWORD PTR [r12+0x8]
  401a4b:	48 89 f2             	mov    rdx,rsi
  401a4e:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  401a53:	45 89 f1             	mov    r9d,r14d
  401a56:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  401a5d:	00 00 00 
  401a60:	4c 8b 00             	mov    r8,QWORD PTR [rax]
  401a63:	48 b8 f0 35 41 00 00 	movabs rax,0x4135f0
  401a6a:	00 00 00 
  401a6d:	4c 89 d6             	mov    rsi,r10
  401a70:	ff d0                	call   rax
	if (unlikely(ret != 0)) {
  401a72:	85 c0                	test   eax,eax
  401a74:	0f 84 24 ff ff ff    	je     40199e <slm_blkpt_block+0x36e>
		assert(ret != -EPERM);
  401a7a:	83 f8 ff             	cmp    eax,0xffffffff
  401a7d:	0f 84 72 ff ff ff    	je     4019f5 <slm_blkpt_block+0x3c5>
		assert(ret != -EINVAL);
  401a83:	83 f8 ea             	cmp    eax,0xffffffea
  401a86:	0f 84 1b 01 00 00    	je     401ba7 <slm_blkpt_block+0x577>
		if (ret == -EBUSY) return ret;
  401a8c:	83 f8 f0             	cmp    eax,0xfffffff0
  401a8f:	0f 84 09 ff ff ff    	je     40199e <slm_blkpt_block+0x36e>
		assert(ret == -EAGAIN);
  401a95:	83 f8 f5             	cmp    eax,0xfffffff5
  401a98:	0f 85 e1 00 00 00    	jne    401b7f <slm_blkpt_block+0x54f>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  401a9e:	49 bc 50 5f 41 00 00 	movabs r12,0x415f50
  401aa5:	00 00 00 
		tok    = cos_sched_sync();
  401aa8:	ff d3                	call   rbx
	unsigned long oc = ps_load(&cs->owner_contention);
  401aaa:	49 8b 37             	mov    rsi,QWORD PTR [r15]
  401aad:	41 89 c1             	mov    r9d,eax
		if (unlikely(owner)) {
  401ab0:	48 89 f1             	mov    rcx,rsi
  401ab3:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  401ab7:	0f 85 a4 00 00 00    	jne    401b61 <slm_blkpt_block+0x531>
  401abd:	48 89 f0             	mov    rax,rsi
  401ac0:	f0 4d 0f b1 2f       	lock cmpxchg QWORD PTR [r15],r13
  401ac5:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  401ac8:	84 c0                	test   al,al
  401aca:	0f 85 0b fe ff ff    	jne    4018db <slm_blkpt_block+0x2ab>
  401ad0:	eb d6                	jmp    401aa8 <slm_blkpt_block+0x478>
  401ad2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  401ad8:	48 bf 08 f3 41 00 00 	movabs rdi,0x41f308
  401adf:	00 00 00 
  401ae2:	be 61 00 00 00       	mov    esi,0x61
  401ae7:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  401aee:	00 00 00 
  401af1:	ff d0                	call   rax
	assert(slm_state_is_runnable(t->state));
  401af3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401afa:	00 00 00 00 
  401afe:	0f 0b                	ud2    
			prio    = curr->priority;
  401b00:	49 8b 75 30          	mov    rsi,QWORD PTR [r13+0x30]
			timeout = TCAP_TIME_NIL;
  401b04:	31 c9                	xor    ecx,ecx
  401b06:	e9 28 ff ff ff       	jmp    401a33 <slm_blkpt_block+0x403>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  401b0b:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  401b12:	00 00 00 
  401b15:	49 8b 7c 24 28       	mov    rdi,QWORD PTR [r12+0x28]
  401b1a:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  401b1d:	44 89 f1             	mov    ecx,r14d
  401b20:	48 b8 60 36 41 00 00 	movabs rax,0x413660
  401b27:	00 00 00 
  401b2a:	4c 89 c6             	mov    rsi,r8
  401b2d:	ff d0                	call   rax
  401b2f:	e9 3e ff ff ff       	jmp    401a72 <slm_blkpt_block+0x442>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  401b34:	49 8b 55 30          	mov    rdx,QWORD PTR [r13+0x30]
  401b38:	45 89 f1             	mov    r9d,r14d
  401b3b:	31 c9                	xor    ecx,ecx
  401b3d:	31 f6                	xor    esi,esi
  401b3f:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  401b46:	00 00 00 
  401b49:	4c 8b 00             	mov    r8,QWORD PTR [rax]
  401b4c:	48 8b 78 f0          	mov    rdi,QWORD PTR [rax-0x10]
  401b50:	48 b8 f0 35 41 00 00 	movabs rax,0x4135f0
  401b57:	00 00 00 
  401b5a:	ff d0                	call   rax
  401b5c:	e9 11 ff ff ff       	jmp    401a72 <slm_blkpt_block+0x442>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  401b61:	41 89 f0             	mov    r8d,esi
  401b64:	4c 89 ea             	mov    rdx,r13
  401b67:	4c 89 ff             	mov    rdi,r15
  401b6a:	41 83 e0 01          	and    r8d,0x1
  401b6e:	41 ff d4             	call   r12
			assert(ret != -EBUSY);
  401b71:	83 f8 f0             	cmp    eax,0xfffffff0
  401b74:	0f 85 2e ff ff ff    	jne    401aa8 <slm_blkpt_block+0x478>
  401b7a:	e9 ee fc ff ff       	jmp    40186d <slm_blkpt_block+0x23d>
  401b7f:	48 bf 40 f4 41 00 00 	movabs rdi,0x41f440
  401b86:	00 00 00 
  401b89:	be 61 00 00 00       	mov    esi,0x61
  401b8e:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  401b95:	00 00 00 
  401b98:	ff d0                	call   rax
		assert(ret == -EAGAIN);
  401b9a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401ba1:	00 00 00 00 
  401ba5:	0f 0b                	ud2    
  401ba7:	48 bf d8 f3 41 00 00 	movabs rdi,0x41f3d8
  401bae:	00 00 00 
  401bb1:	be 61 00 00 00       	mov    esi,0x61
  401bb6:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  401bbd:	00 00 00 
  401bc0:	ff d0                	call   rax
		assert(ret != -EINVAL);
  401bc2:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401bc9:	00 00 00 00 
  401bcd:	0f 0b                	ud2    
  401bcf:	90                   	nop

0000000000401bd0 <slm_thd_timer_policy>:
SLM_MODULES_COMPOSE_DATA();
  401bd0:	f3 0f 1e fa          	endbr64 
  401bd4:	48 8d 87 88 00 00 00 	lea    rax,[rdi+0x88]
  401bdb:	c3                   	ret    
  401bdc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000401be0 <slm_thd_sched_policy>:
  401be0:	f3 0f 1e fa          	endbr64 
  401be4:	48 8d 47 78          	lea    rax,[rdi+0x78]
  401be8:	c3                   	ret    
  401be9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401bf0 <slm_thd_from_timer>:
  401bf0:	f3 0f 1e fa          	endbr64 
  401bf4:	48 8d 87 78 ff ff ff 	lea    rax,[rdi-0x88]
  401bfb:	c3                   	ret    
  401bfc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000401c00 <slm_thd_from_sched>:
  401c00:	f3 0f 1e fa          	endbr64 
  401c04:	48 8d 47 88          	lea    rax,[rdi-0x78]
  401c08:	c3                   	ret    
  401c09:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401c10 <slm_timer_expire>:
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  401c10:	f3 0f 1e fa          	endbr64 
  401c14:	48 b8 30 4f 41 00 00 	movabs rax,0x414f30
  401c1b:	00 00 00 
  401c1e:	ff e0                	jmp    rax

0000000000401c20 <slm_timer_thd_init>:
  401c20:	f3 0f 1e fa          	endbr64 
  401c24:	48 b8 c0 52 41 00 00 	movabs rax,0x4152c0
  401c2b:	00 00 00 
  401c2e:	ff e0                	jmp    rax

0000000000401c30 <slm_timer_thd_deinit>:
  401c30:	f3 0f 1e fa          	endbr64 
  401c34:	48 b8 f0 52 41 00 00 	movabs rax,0x4152f0
  401c3b:	00 00 00 
  401c3e:	ff e0                	jmp    rax

0000000000401c40 <slm_timer_add>:
  401c40:	f3 0f 1e fa          	endbr64 
  401c44:	48 b8 50 51 41 00 00 	movabs rax,0x415150
  401c4b:	00 00 00 
  401c4e:	ff e0                	jmp    rax

0000000000401c50 <slm_timer_cancel>:
  401c50:	f3 0f 1e fa          	endbr64 
  401c54:	48 b8 10 52 41 00 00 	movabs rax,0x415210
  401c5b:	00 00 00 
  401c5e:	ff e0                	jmp    rax

0000000000401c60 <slm_timer_init>:
  401c60:	f3 0f 1e fa          	endbr64 
  401c64:	48 b8 00 53 41 00 00 	movabs rax,0x415300
  401c6b:	00 00 00 
  401c6e:	ff e0                	jmp    rax

0000000000401c70 <slm_sched_init>:
  401c70:	f3 0f 1e fa          	endbr64 
  401c74:	48 b8 f0 4b 41 00 00 	movabs rax,0x414bf0
  401c7b:	00 00 00 
  401c7e:	ff e0                	jmp    rax

0000000000401c80 <slm_sched_thd_init>:
  401c80:	f3 0f 1e fa          	endbr64 
  401c84:	48 b8 10 4a 41 00 00 	movabs rax,0x414a10
  401c8b:	00 00 00 
  401c8e:	ff e0                	jmp    rax

0000000000401c90 <slm_sched_thd_deinit>:
  401c90:	f3 0f 1e fa          	endbr64 
  401c94:	48 b8 40 4a 41 00 00 	movabs rax,0x414a40
  401c9b:	00 00 00 
  401c9e:	ff e0                	jmp    rax

0000000000401ca0 <slm_sched_thd_update>:
  401ca0:	f3 0f 1e fa          	endbr64 
  401ca4:	48 b8 70 4a 41 00 00 	movabs rax,0x414a70
  401cab:	00 00 00 
  401cae:	ff e0                	jmp    rax

0000000000401cb0 <slm_sched_block>:
  401cb0:	f3 0f 1e fa          	endbr64 
  401cb4:	48 b8 d0 48 41 00 00 	movabs rax,0x4148d0
  401cbb:	00 00 00 
  401cbe:	ff e0                	jmp    rax

0000000000401cc0 <slm_sched_wakeup>:
  401cc0:	f3 0f 1e fa          	endbr64 
  401cc4:	48 b8 10 49 41 00 00 	movabs rax,0x414910
  401ccb:	00 00 00 
  401cce:	ff e0                	jmp    rax

0000000000401cd0 <slm_sched_yield>:
  401cd0:	f3 0f 1e fa          	endbr64 
  401cd4:	48 b8 a0 49 41 00 00 	movabs rax,0x4149a0
  401cdb:	00 00 00 
  401cde:	ff e0                	jmp    rax

0000000000401ce0 <slm_sched_schedule>:
  401ce0:	f3 0f 1e fa          	endbr64 
  401ce4:	48 b8 50 48 41 00 00 	movabs rax,0x414850
  401ceb:	00 00 00 
  401cee:	ff e0                	jmp    rax

0000000000401cf0 <slm_sched_execution>:
  401cf0:	f3 0f 1e fa          	endbr64 
  401cf4:	48 b8 40 48 41 00 00 	movabs rax,0x414840
  401cfb:	00 00 00 
  401cfe:	ff e0                	jmp    rax

0000000000401d00 <slm_thd_lookup>:
  401d00:	f3 0f 1e fa          	endbr64 
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  401d04:	85 ff                	test   edi,edi
  401d06:	74 40                	je     401d48 <slm_thd_lookup+0x48>
  401d08:	83 ef 01             	sub    edi,0x1
  401d0b:	83 ff 18             	cmp    edi,0x18
  401d0e:	77 38                	ja     401d48 <slm_thd_lookup+0x48>
  401d10:	48 b9 00 27 46 00 00 	movabs rcx,0x462700
  401d17:	00 00 00 
  401d1a:	31 c0                	xor    eax,eax
  401d1c:	48 8b 14 f9          	mov    rdx,QWORD PTR [rcx+rdi*8]
  401d20:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  401d27:	74 21                	je     401d4a <slm_thd_lookup+0x4a>
  401d29:	83 e2 01             	and    edx,0x1
  401d2c:	75 1c                	jne    401d4a <slm_thd_lookup+0x4a>
  401d2e:	48 8d 04 bf          	lea    rax,[rdi+rdi*4]
  401d32:	48 8d 04 47          	lea    rax,[rdi+rax*2]
  401d36:	48 c1 e0 04          	shl    rax,0x4
  401d3a:	48 8d 84 01 c8 00 00 	lea    rax,[rcx+rax*1+0xc8]
  401d41:	00 
  401d42:	c3                   	ret    
  401d43:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  401d48:	31 c0                	xor    eax,eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  401d4a:	c3                   	ret    
  401d4b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000401d50 <ss_thd_intern_is_allocated>:
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  401d50:	f3 0f 1e fa          	endbr64 
  401d54:	48 8d 87 c8 00 00 00 	lea    rax,[rdi+0xc8]
  401d5b:	48 39 c6             	cmp    rsi,rax
  401d5e:	72 32                	jb     401d92 <ss_thd_intern_is_allocated+0x42>
  401d60:	48 8d 97 48 11 00 00 	lea    rdx,[rdi+0x1148]
  401d67:	48 39 d6             	cmp    rsi,rdx
  401d6a:	77 26                	ja     401d92 <ss_thd_intern_is_allocated+0x42>
  401d6c:	48 29 c6             	sub    rsi,rax
  401d6f:	48 c1 fe 04          	sar    rsi,0x4
  401d73:	69 c6 a3 8b 2e ba    	imul   eax,esi,0xba2e8ba3
  401d79:	48 8b 04 c7          	mov    rax,QWORD PTR [rdi+rax*8]
  401d7d:	48 89 c2             	mov    rdx,rax
  401d80:	83 e2 01             	and    edx,0x1
  401d83:	48 a9 fe ff ff ff    	test   rax,0xfffffffffffffffe
  401d89:	b8 01 00 00 00       	mov    eax,0x1
  401d8e:	0f 45 c2             	cmovne eax,edx
  401d91:	c3                   	ret    
  401d92:	48 bf c8 f5 41 00 00 	movabs rdi,0x41f5c8
  401d99:	00 00 00 
  401d9c:	55                   	push   rbp
  401d9d:	be 23 00 00 00       	mov    esi,0x23
  401da2:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  401da9:	00 00 00 
  401dac:	48 89 e5             	mov    rbp,rsp
  401daf:	ff d0                	call   rax
  401db1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401db8:	00 00 00 00 
  401dbc:	0f 0b                	ud2    
  401dbe:	66 90                	xchg   ax,ax

0000000000401dc0 <ss_thd_is_allocated>:
  401dc0:	f3 0f 1e fa          	endbr64 
  401dc4:	48 b8 48 38 46 00 00 	movabs rax,0x463848
  401dcb:	00 00 00 
  401dce:	48 39 c7             	cmp    rdi,rax
  401dd1:	77 3b                	ja     401e0e <ss_thd_is_allocated+0x4e>
  401dd3:	48 2d 80 10 00 00    	sub    rax,0x1080
  401dd9:	48 39 c7             	cmp    rdi,rax
  401ddc:	72 30                	jb     401e0e <ss_thd_is_allocated+0x4e>
  401dde:	48 ba 00 27 46 00 00 	movabs rdx,0x462700
  401de5:	00 00 00 
  401de8:	48 29 c7             	sub    rdi,rax
  401deb:	48 c1 ff 04          	sar    rdi,0x4
  401def:	69 c7 a3 8b 2e ba    	imul   eax,edi,0xba2e8ba3
  401df5:	48 8b 04 c2          	mov    rax,QWORD PTR [rdx+rax*8]
  401df9:	48 89 c2             	mov    rdx,rax
  401dfc:	83 e2 01             	and    edx,0x1
  401dff:	48 a9 fe ff ff ff    	test   rax,0xfffffffffffffffe
  401e05:	b8 01 00 00 00       	mov    eax,0x1
  401e0a:	0f 45 c2             	cmovne eax,edx
  401e0d:	c3                   	ret    
  401e0e:	48 bf c8 f5 41 00 00 	movabs rdi,0x41f5c8
  401e15:	00 00 00 
  401e18:	55                   	push   rbp
  401e19:	be 23 00 00 00       	mov    esi,0x23
  401e1e:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  401e25:	00 00 00 
  401e28:	48 89 e5             	mov    rbp,rsp
  401e2b:	ff d0                	call   rax
  401e2d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401e34:	00 00 00 00 
  401e38:	0f 0b                	ud2    
  401e3a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000401e40 <slm_thd_static_cm_lookup>:
  401e40:	f3 0f 1e fa          	endbr64 
  401e44:	85 ff                	test   edi,edi
  401e46:	74 40                	je     401e88 <slm_thd_static_cm_lookup+0x48>
  401e48:	83 ef 01             	sub    edi,0x1
  401e4b:	83 ff 18             	cmp    edi,0x18
  401e4e:	77 38                	ja     401e88 <slm_thd_static_cm_lookup+0x48>
  401e50:	48 b9 00 27 46 00 00 	movabs rcx,0x462700
  401e57:	00 00 00 
  401e5a:	31 c0                	xor    eax,eax
  401e5c:	48 8b 14 f9          	mov    rdx,QWORD PTR [rcx+rdi*8]
  401e60:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  401e67:	74 21                	je     401e8a <slm_thd_static_cm_lookup+0x4a>
  401e69:	83 e2 01             	and    edx,0x1
  401e6c:	75 1c                	jne    401e8a <slm_thd_static_cm_lookup+0x4a>
  401e6e:	48 8d 04 bf          	lea    rax,[rdi+rdi*4]
  401e72:	48 8d 04 47          	lea    rax,[rdi+rax*2]
  401e76:	48 c1 e0 04          	shl    rax,0x4
  401e7a:	48 8d 84 01 c8 00 00 	lea    rax,[rcx+rax*1+0xc8]
  401e81:	00 
  401e82:	c3                   	ret    
  401e83:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  401e88:	31 c0                	xor    eax,eax
  401e8a:	c3                   	ret    
  401e8b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000401e90 <slm_thd_current_extern>:
{
  401e90:	f3 0f 1e fa          	endbr64 
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  401e94:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  401e97:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  401e9d:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  401ea4:	48 85 c0             	test   rax,rax
  401ea7:	74 47                	je     401ef0 <slm_thd_current_extern+0x60>
  401ea9:	83 e8 01             	sub    eax,0x1
  401eac:	83 f8 18             	cmp    eax,0x18
  401eaf:	77 3f                	ja     401ef0 <slm_thd_current_extern+0x60>
  401eb1:	48 b9 00 27 46 00 00 	movabs rcx,0x462700
  401eb8:	00 00 00 
  401ebb:	45 31 c0             	xor    r8d,r8d
  401ebe:	48 8b 14 c1          	mov    rdx,QWORD PTR [rcx+rax*8]
  401ec2:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  401ec9:	74 19                	je     401ee4 <slm_thd_current_extern+0x54>
  401ecb:	83 e2 01             	and    edx,0x1
  401ece:	75 14                	jne    401ee4 <slm_thd_current_extern+0x54>
  401ed0:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  401ed4:	48 8d 04 50          	lea    rax,[rax+rdx*2]
  401ed8:	48 c1 e0 04          	shl    rax,0x4
  401edc:	4c 8d 84 01 c8 00 00 	lea    r8,[rcx+rax*1+0xc8]
  401ee3:	00 
}
  401ee4:	4c 89 c0             	mov    rax,r8
  401ee7:	c3                   	ret    
  401ee8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  401eef:	00 
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  401ef0:	45 31 c0             	xor    r8d,r8d
}
  401ef3:	4c 89 c0             	mov    rax,r8
  401ef6:	c3                   	ret    
  401ef7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  401efe:	00 00 

0000000000401f00 <slm_thd_from_container>:
slm_thd_from_container(struct slm_thd_container *c) {
  401f00:	f3 0f 1e fa          	endbr64 
  401f04:	48 89 f8             	mov    rax,rdi
}
  401f07:	c3                   	ret    
  401f08:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  401f0f:	00 

0000000000401f10 <slm_thd_mem_alloc>:
{
  401f10:	f3 0f 1e fa          	endbr64 
  401f14:	55                   	push   rbp
  401f15:	66 48 0f 6e c7       	movq   xmm0,rdi
  401f1a:	66 48 0f 6e ce       	movq   xmm1,rsi
  401f1f:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  401f23:	48 89 e5             	mov    rbp,rsp
  401f26:	41 54                	push   r12
  401f28:	53                   	push   rbx
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  401f29:	85 f6                	test   esi,esi
  401f2b:	0f 84 9f 00 00 00    	je     401fd0 <slm_thd_mem_alloc+0xc0>
  401f31:	49 89 d3             	mov    r11,rdx
  401f34:	8d 56 ff             	lea    edx,[rsi-0x1]
  401f37:	83 fa 18             	cmp    edx,0x18
  401f3a:	0f 87 90 00 00 00    	ja     401fd0 <slm_thd_mem_alloc+0xc0>
	if (*state != SS_STATE_FREE ||
  401f40:	49 ba 00 27 46 00 00 	movabs r10,0x462700
  401f47:	00 00 00 
  401f4a:	49 83 3c d2 00       	cmp    QWORD PTR [r10+rdx*8],0x0
  401f4f:	75 7f                	jne    401fd0 <slm_thd_mem_alloc+0xc0>
  401f51:	31 db                	xor    ebx,ebx
  401f53:	49 89 c9             	mov    r9,rcx
  401f56:	b9 01 00 00 00       	mov    ecx,0x1
  401f5b:	48 89 d8             	mov    rax,rbx
  401f5e:	f0 49 0f b1 0c d2    	lock cmpxchg QWORD PTR [r10+rdx*8],rcx
  401f64:	0f 94 c0             	sete   al
  401f67:	84 c0                	test   al,al
  401f69:	74 65                	je     401fd0 <slm_thd_mem_alloc+0xc0>
  401f6b:	48 8d 04 92          	lea    rax,[rdx+rdx*4]
  401f6f:	49 89 f8             	mov    r8,rdi
  401f72:	b9 16 00 00 00       	mov    ecx,0x16
  401f77:	48 8d 14 42          	lea    rdx,[rdx+rax*2]
  401f7b:	48 89 d8             	mov    rax,rbx
  401f7e:	48 c1 e2 04          	shl    rdx,0x4
  401f82:	4d 8d a4 12 c8 00 00 	lea    r12,[r10+rdx*1+0xc8]
  401f89:	00 
  401f8a:	4c 89 e7             	mov    rdi,r12
  401f8d:	f3 48 ab             	rep stos QWORD PTR es:[rdi],rax
	assert(_cap != 0 && _tid != 0);
  401f90:	4d 85 c0             	test   r8,r8
  401f93:	74 63                	je     401ff8 <slm_thd_mem_alloc+0xe8>
	t->resources = (struct slm_resources_thd) {
  401f95:	48 b8 10 27 46 00 00 	movabs rax,0x462710
  401f9c:	00 00 00 
  401f9f:	0f 29 84 10 50 01 00 	movaps XMMWORD PTR [rax+rdx*1+0x150],xmm0
  401fa6:	00 
  401fa7:	48 a1 40 b0 42 00 00 	movabs rax,ds:0x42b040
  401fae:	00 00 00 
  401fb1:	49 89 84 12 70 01 00 	mov    QWORD PTR [r10+rdx*1+0x170],rax
  401fb8:	00 
}
  401fb9:	4c 89 e0             	mov    rax,r12
	*thd = _cap;
  401fbc:	4d 89 03             	mov    QWORD PTR [r11],r8
	*tid = _tid;
  401fbf:	49 89 31             	mov    QWORD PTR [r9],rsi
}
  401fc2:	5b                   	pop    rbx
  401fc3:	41 5c                	pop    r12
  401fc5:	5d                   	pop    rbp
  401fc6:	c3                   	ret    
  401fc7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  401fce:	00 00 
  401fd0:	48 bf f0 f5 41 00 00 	movabs rdi,0x41f5f0
  401fd7:	00 00 00 
  401fda:	be 23 00 00 00       	mov    esi,0x23
  401fdf:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  401fe6:	00 00 00 
  401fe9:	ff d0                	call   rax
	if (!t) assert(0);
  401feb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401ff2:	00 00 00 00 
  401ff6:	0f 0b                	ud2    
  401ff8:	48 bf 18 f6 41 00 00 	movabs rdi,0x41f618
  401fff:	00 00 00 
  402002:	be 23 00 00 00       	mov    esi,0x23
  402007:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40200e:	00 00 00 
  402011:	ff d0                	call   rax
	assert(_cap != 0 && _tid != 0);
  402013:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40201a:	00 00 00 00 
  40201e:	0f 0b                	ud2    

0000000000402020 <slm_thd_mem_activate>:
void slm_thd_mem_activate(struct slm_thd_container *t) { ss_thd_activate(t); }
  402020:	f3 0f 1e fa          	endbr64 
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  402024:	48 b8 c8 27 46 00 00 	movabs rax,0x4627c8
  40202b:	00 00 00 
void slm_thd_mem_activate(struct slm_thd_container *t) { ss_thd_activate(t); }
  40202e:	55                   	push   rbp
  40202f:	48 89 e5             	mov    rbp,rsp
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  402032:	48 39 c7             	cmp    rdi,rax
  402035:	72 49                	jb     402080 <slm_thd_mem_activate+0x60>
  402037:	48 8d 90 80 10 00 00 	lea    rdx,[rax+0x1080]
  40203e:	48 39 d7             	cmp    rdi,rdx
  402041:	77 3d                	ja     402080 <slm_thd_mem_activate+0x60>
 */
static inline void
ss_state_activate_with(ss_state_t *state, word_t val)
{
	assert(val != 0);
	*state = val | (*state & 1);
  402043:	48 b9 00 27 46 00 00 	movabs rcx,0x462700
  40204a:	00 00 00 
  40204d:	48 29 c7             	sub    rdi,rax
  402050:	48 c1 ff 04          	sar    rdi,0x4
  402054:	69 c7 a3 8b 2e ba    	imul   eax,edi,0xba2e8ba3
  40205a:	48 8b 14 c1          	mov    rdx,QWORD PTR [rcx+rax*8]
  40205e:	48 83 ca fe          	or     rdx,0xfffffffffffffffe
  402062:	48 89 14 c1          	mov    QWORD PTR [rcx+rax*8],rdx
	assert((*state & 1) == SS_STATE_CONS);
  402066:	48 83 fa ff          	cmp    rdx,0xffffffffffffffff
  40206a:	75 3c                	jne    4020a8 <slm_thd_mem_activate+0x88>
	*state &= ~SS_STATE_CONS;
  40206c:	48 c7 04 c1 fe ff ff 	mov    QWORD PTR [rcx+rax*8],0xfffffffffffffffe
  402073:	ff 
{ __asm__ __volatile__("mfence" ::: "memory"); }
  402074:	0f ae f0             	mfence 
	assert(*state != 0);
  402077:	48 83 3c c1 00       	cmp    QWORD PTR [rcx+rax*8],0x0
  40207c:	74 52                	je     4020d0 <slm_thd_mem_activate+0xb0>
void slm_thd_mem_activate(struct slm_thd_container *t) { ss_thd_activate(t); }
  40207e:	5d                   	pop    rbp
  40207f:	c3                   	ret    
  402080:	48 bf c8 f5 41 00 00 	movabs rdi,0x41f5c8
  402087:	00 00 00 
  40208a:	be 23 00 00 00       	mov    esi,0x23
  40208f:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  402096:	00 00 00 
  402099:	ff d0                	call   rax
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  40209b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4020a2:	00 00 00 00 
  4020a6:	0f 0b                	ud2    
  4020a8:	48 bf 40 f6 41 00 00 	movabs rdi,0x41f640
  4020af:	00 00 00 
  4020b2:	be 61 00 00 00       	mov    esi,0x61
  4020b7:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4020be:	00 00 00 
  4020c1:	ff d0                	call   rax
	assert((*state & 1) == SS_STATE_CONS);
  4020c3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4020ca:	00 00 00 00 
  4020ce:	0f 0b                	ud2    
  4020d0:	48 bf a8 f6 41 00 00 	movabs rdi,0x41f6a8
  4020d7:	00 00 00 
  4020da:	be 61 00 00 00       	mov    esi,0x61
  4020df:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4020e6:	00 00 00 
  4020e9:	ff d0                	call   rax
	assert(*state != 0);
  4020eb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4020f2:	00 00 00 00 
  4020f6:	0f 0b                	ud2    
  4020f8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4020ff:	00 

0000000000402100 <slm_thd_mem_free>:
void slm_thd_mem_free(struct slm_thd_container *t) { return; }
  402100:	f3 0f 1e fa          	endbr64 
  402104:	c3                   	ret    
  402105:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40210c:	00 00 00 00 

0000000000402110 <sched_thd_create_closure>:
{
  402110:	f3 0f 1e fa          	endbr64 
  402114:	55                   	push   rbp
  402115:	89 fe                	mov    esi,edi
	struct slm_thd *t = thd_alloc_in(cos_inv_token(), idx, &p, 0);
  402117:	31 c9                	xor    ecx,ecx
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  402119:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  40211c:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
{
  402122:	48 89 e5             	mov    rbp,rsp
  402125:	48 83 ec 10          	sub    rsp,0x10
	struct slm_thd *t = thd_alloc_in(cos_inv_token(), idx, &p, 0);
  402129:	48 8b b8 e8 1f 00 00 	mov    rdi,QWORD PTR [rax+0x1fe8]
  402130:	48 b8 e0 5d 40 00 00 	movabs rax,0x405de0
  402137:	00 00 00 
	sched_param_t p = 0;
  40213a:	c7 45 fc 00 00 00 00 	mov    DWORD PTR [rbp-0x4],0x0
	struct slm_thd *t = thd_alloc_in(cos_inv_token(), idx, &p, 0);
  402141:	48 8d 55 fc          	lea    rdx,[rbp-0x4]
  402145:	ff d0                	call   rax
	if (!t) return 0;
  402147:	48 85 c0             	test   rax,rax
  40214a:	74 0c                	je     402158 <sched_thd_create_closure+0x48>
	return t->tid;
  40214c:	48 8b 40 18          	mov    rax,QWORD PTR [rax+0x18]
}
  402150:	c9                   	leave  
  402151:	c3                   	ret    
  402152:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  402158:	c9                   	leave  
	if (!t) return 0;
  402159:	31 c0                	xor    eax,eax
}
  40215b:	c3                   	ret    
  40215c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000402160 <sched_thd_param_set>:
{
  402160:	f3 0f 1e fa          	endbr64 

static inline void
sched_param_get(sched_param_t sp, sched_param_type_t *type, unsigned int *value)
{
	if (type)  *type  = (sched_param_type_t)(sp &  SCHED_PARAM_TYPE_MASK);
	if (value) *value = (unsigned int)      (sp >> SCHED_PARAM_TYPE_BITS);
  402164:	41 89 f0             	mov    r8d,esi
	if (type)  *type  = (sched_param_type_t)(sp &  SCHED_PARAM_TYPE_MASK);
  402167:	83 e6 3f             	and    esi,0x3f
	if (value) *value = (unsigned int)      (sp >> SCHED_PARAM_TYPE_BITS);
  40216a:	41 c1 e8 06          	shr    r8d,0x6
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  40216e:	85 ff                	test   edi,edi
  402170:	74 4e                	je     4021c0 <sched_thd_param_set+0x60>
  402172:	83 ef 01             	sub    edi,0x1
  402175:	83 ff 18             	cmp    edi,0x18
  402178:	77 46                	ja     4021c0 <sched_thd_param_set+0x60>
  40217a:	48 ba 00 27 46 00 00 	movabs rdx,0x462700
  402181:	00 00 00 
  402184:	48 8b 04 fa          	mov    rax,QWORD PTR [rdx+rdi*8]
	return ((state & ~1) != 0) && ((state & 1) == SS_STATE_ALLOC);
  402188:	48 a9 fe ff ff ff    	test   rax,0xfffffffffffffffe
  40218e:	74 30                	je     4021c0 <sched_thd_param_set+0x60>
  402190:	a8 01                	test   al,0x1
  402192:	75 2c                	jne    4021c0 <sched_thd_param_set+0x60>
	return &ss_thd_get(id)->thd;
  402194:	48 8d 04 bf          	lea    rax,[rdi+rdi*4]
  402198:	48 8d 04 47          	lea    rax,[rdi+rax*2]
  40219c:	48 c1 e0 04          	shl    rax,0x4
  4021a0:	48 8d bc 02 c8 00 00 	lea    rdi,[rdx+rax*1+0xc8]
  4021a7:	00 
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  4021a8:	44 89 c2             	mov    edx,r8d
  4021ab:	48 b8 70 4a 41 00 00 	movabs rax,0x414a70
  4021b2:	00 00 00 
  4021b5:	ff e0                	jmp    rax
  4021b7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  4021be:	00 00 
}
  4021c0:	b8 ff ff ff ff       	mov    eax,0xffffffff
  4021c5:	c3                   	ret    
  4021c6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4021cd:	00 00 00 

00000000004021d0 <sched_thd_delete>:
{
  4021d0:	f3 0f 1e fa          	endbr64 
}
  4021d4:	31 c0                	xor    eax,eax
  4021d6:	c3                   	ret    
  4021d7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  4021de:	00 00 

00000000004021e0 <sched_thd_exit>:
{
  4021e0:	f3 0f 1e fa          	endbr64 
  4021e4:	55                   	push   rbp
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  4021e5:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  4021e8:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  4021ee:	48 89 e5             	mov    rbp,rsp
  4021f1:	41 57                	push   r15
  4021f3:	41 56                	push   r14
  4021f5:	41 55                	push   r13
  4021f7:	41 54                	push   r12
  4021f9:	53                   	push   rbx
  4021fa:	48 83 ec 18          	sub    rsp,0x18
  4021fe:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  402205:	48 85 c0             	test   rax,rax
  402208:	0f 84 b3 02 00 00    	je     4024c1 <sched_thd_exit+0x2e1>
  40220e:	83 e8 01             	sub    eax,0x1
  402211:	83 f8 18             	cmp    eax,0x18
  402214:	0f 87 a7 02 00 00    	ja     4024c1 <sched_thd_exit+0x2e1>
  40221a:	48 ba 00 27 46 00 00 	movabs rdx,0x462700
  402221:	00 00 00 
  402224:	48 8b 0c c2          	mov    rcx,QWORD PTR [rdx+rax*8]
  402228:	48 f7 c1 fe ff ff ff 	test   rcx,0xfffffffffffffffe
  40222f:	0f 84 8c 02 00 00    	je     4024c1 <sched_thd_exit+0x2e1>
  402235:	80 e1 01             	and    cl,0x1
  402238:	0f 85 83 02 00 00    	jne    4024c1 <sched_thd_exit+0x2e1>
  40223e:	49 bd d0 35 41 00 00 	movabs r13,0x4135d0
  402245:	00 00 00 
  402248:	48 8d 0c 80          	lea    rcx,[rax+rax*4]
  40224c:	48 bb c0 5e 5a 00 00 	movabs rbx,0x5a5ec0
  402253:	00 00 00 
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  402256:	49 bc 50 5f 41 00 00 	movabs r12,0x415f50
  40225d:	00 00 00 
  402260:	48 8d 04 48          	lea    rax,[rax+rcx*2]
  402264:	48 c1 e0 04          	shl    rax,0x4
  402268:	48 8d 84 02 c8 00 00 	lea    rax,[rdx+rax*1+0xc8]
  40226f:	00 
  402270:	48 89 45 c0          	mov    QWORD PTR [rbp-0x40],rax
		tok    = cos_sched_sync();
  402274:	41 ff d5             	call   r13
  402277:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  40227a:	48 8b 03             	mov    rax,QWORD PTR [rbx]
		if (unlikely(owner)) {
  40227d:	48 89 c1             	mov    rcx,rax
  402280:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  402284:	0f 85 84 02 00 00    	jne    40250e <sched_thd_exit+0x32e>
        __asm__ __volatile__("lock " PS_CAS_STR
  40228a:	48 8b 7d c0          	mov    rdi,QWORD PTR [rbp-0x40]
  40228e:	f0 48 0f b1 3b       	lock cmpxchg QWORD PTR [rbx],rdi
  402293:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  402296:	84 c0                	test   al,al
  402298:	74 da                	je     402274 <sched_thd_exit+0x94>
	slm_thd_deinit(current);
  40229a:	48 b8 10 5f 41 00 00 	movabs rax,0x415f10
  4022a1:	00 00 00 
  4022a4:	49 bf 10 ce 40 00 00 	movabs r15,0x40ce10
  4022ab:	00 00 00 
  4022ae:	ff d0                	call   rax
	for (i = 0; slm_cs_exit_reschedule(current, SLM_CS_NONE) && i < 16; i++) ;
  4022b0:	c7 45 cc 11 00 00 00 	mov    DWORD PTR [rbp-0x34],0x11
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  4022b7:	41 ff d7             	call   r15
	tok  = cos_sched_sync();
  4022ba:	41 ff d5             	call   r13
  4022bd:	41 89 c6             	mov    r14d,eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  4022c0:	48 b8 50 48 41 00 00 	movabs rax,0x414850
  4022c7:	00 00 00 
  4022ca:	ff d0                	call   rax
	if (unlikely(!t)) t = &g->idle_thd;
  4022cc:	48 85 c0             	test   rax,rax
  4022cf:	49 89 c4             	mov    r12,rax
  4022d2:	48 b8 40 5f 5a 00 00 	movabs rax,0x5a5f40
  4022d9:	00 00 00 
  4022dc:	4c 0f 44 e0          	cmove  r12,rax
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  4022e0:	41 8b 44 24 04       	mov    eax,DWORD PTR [r12+0x4]
  4022e5:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  4022e8:	83 f8 01             	cmp    eax,0x1
  4022eb:	76 17                	jbe    402304 <sched_thd_exit+0x124>
  4022ed:	e9 ac 00 00 00       	jmp    40239e <sched_thd_exit+0x1be>
  4022f2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4022f8:	f0 48 0f b1 13       	lock cmpxchg QWORD PTR [rbx],rdx
  4022fd:	0f 94 c0             	sete   al
	while (ret != 0) {
  402300:	84 c0                	test   al,al
  402302:	75 2d                	jne    402331 <sched_thd_exit+0x151>
		tok    = cos_sched_sync();
  402304:	41 ff d5             	call   r13
  402307:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  402309:	48 8b 03             	mov    rax,QWORD PTR [rbx]
		if (unlikely(contention)) {
  40230c:	48 89 c2             	mov    rdx,rax
  40230f:	83 e2 01             	and    edx,0x1
  402312:	74 e4                	je     4022f8 <sched_thd_exit+0x118>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  402314:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  402317:	48 89 c2             	mov    rdx,rax
  40231a:	48 89 df             	mov    rdi,rbx
  40231d:	48 b8 b0 5f 41 00 00 	movabs rax,0x415fb0
  402324:	00 00 00 
  402327:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  40232b:	ff d0                	call   rax
  40232d:	85 c0                	test   eax,eax
  40232f:	75 d3                	jne    402304 <sched_thd_exit+0x124>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  402331:	41 ff d7             	call   r15
	prio = inherit_prio ? curr->priority : t->priority;
  402334:	49 8b 74 24 30       	mov    rsi,QWORD PTR [r12+0x30]
	timeout = g->timeout_next;
  402339:	48 b8 c8 5f 5a 00 00 	movabs rax,0x5a5fc8
  402340:	00 00 00 
  402343:	4c 8b 00             	mov    r8,QWORD PTR [rax]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  402346:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  40234a:	a8 0b                	test   al,0xb
  40234c:	75 78                	jne    4023c6 <sched_thd_exit+0x1e6>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  40234e:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  402353:	44 89 f1             	mov    ecx,r14d
  402356:	4c 89 c2             	mov    rdx,r8
  402359:	48 b8 70 e1 40 00 00 	movabs rax,0x40e170
  402360:	00 00 00 
  402363:	ff d0                	call   rax
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  402365:	83 f8 ff             	cmp    eax,0xffffffff
  402368:	0f 84 0b 01 00 00    	je     402479 <sched_thd_exit+0x299>
	if (unlikely(ret != 0)) {
  40236e:	85 c0                	test   eax,eax
  402370:	0f 85 b2 00 00 00    	jne    402428 <sched_thd_exit+0x248>
  402376:	48 bf 0a f7 41 00 00 	movabs rdi,0x41f70a
  40237d:	00 00 00 
  402380:	be 11 00 00 00       	mov    esi,0x11
  402385:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40238c:	00 00 00 
  40238f:	ff d0                	call   rax
	BUG();
  402391:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402398:	00 00 00 00 
  40239c:	0f 0b                	ud2    
  40239e:	48 bf 08 f3 41 00 00 	movabs rdi,0x41f308
  4023a5:	00 00 00 
  4023a8:	be 61 00 00 00       	mov    esi,0x61
  4023ad:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4023b4:	00 00 00 
  4023b7:	ff d0                	call   rax
	assert(slm_state_is_runnable(t->state));
  4023b9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4023c0:	00 00 00 00 
  4023c4:	0f 0b                	ud2    
		if (t == &g->sched_thd) {
  4023c6:	48 ba c8 5e 5a 00 00 	movabs rdx,0x5a5ec8
  4023cd:	00 00 00 
	timeout = g->timeout_next;
  4023d0:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  4023d3:	49 39 d4             	cmp    r12,rdx
  4023d6:	0f 84 23 01 00 00    	je     4024ff <sched_thd_exit+0x31f>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  4023dc:	a8 02                	test   al,0x2
  4023de:	0f 85 6f 01 00 00    	jne    402553 <sched_thd_exit+0x373>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  4023e4:	49 89 c8             	mov    r8,rcx
  4023e7:	a8 01                	test   al,0x1
  4023e9:	0f 84 5f ff ff ff    	je     40234e <sched_thd_exit+0x16e>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  4023ef:	4d 8b 54 24 08       	mov    r10,QWORD PTR [r12+0x8]
  4023f4:	48 89 f2             	mov    rdx,rsi
  4023f7:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  4023fc:	45 89 f1             	mov    r9d,r14d
  4023ff:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  402406:	00 00 00 
  402409:	4c 8b 00             	mov    r8,QWORD PTR [rax]
  40240c:	48 b8 f0 35 41 00 00 	movabs rax,0x4135f0
  402413:	00 00 00 
  402416:	4c 89 d6             	mov    rsi,r10
  402419:	ff d0                	call   rax
	if (unlikely(ret != 0)) {
  40241b:	85 c0                	test   eax,eax
  40241d:	0f 84 53 ff ff ff    	je     402376 <sched_thd_exit+0x196>
		assert(ret != -EPERM);
  402423:	83 f8 ff             	cmp    eax,0xffffffff
  402426:	74 71                	je     402499 <sched_thd_exit+0x2b9>
		assert(ret != -EINVAL);
  402428:	83 f8 ea             	cmp    eax,0xffffffea
  40242b:	0f 84 7c 01 00 00    	je     4025ad <sched_thd_exit+0x3cd>
		if (ret == -EBUSY) return ret;
  402431:	83 f8 f0             	cmp    eax,0xfffffff0
  402434:	0f 84 b6 00 00 00    	je     4024f0 <sched_thd_exit+0x310>
		assert(ret == -EAGAIN);
  40243a:	83 f8 f5             	cmp    eax,0xfffffff5
  40243d:	0f 85 b4 01 00 00    	jne    4025f7 <sched_thd_exit+0x417>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  402443:	49 bc 50 5f 41 00 00 	movabs r12,0x415f50
  40244a:	00 00 00 
		tok    = cos_sched_sync();
  40244d:	41 ff d5             	call   r13
  402450:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  402453:	48 8b 03             	mov    rax,QWORD PTR [rbx]
		if (unlikely(owner)) {
  402456:	48 89 c1             	mov    rcx,rax
  402459:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  40245d:	0f 85 72 01 00 00    	jne    4025d5 <sched_thd_exit+0x3f5>
  402463:	48 8b 7d c0          	mov    rdi,QWORD PTR [rbp-0x40]
  402467:	f0 48 0f b1 3b       	lock cmpxchg QWORD PTR [rbx],rdi
  40246c:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  40246f:	84 c0                	test   al,al
  402471:	0f 85 43 fe ff ff    	jne    4022ba <sched_thd_exit+0xda>
  402477:	eb d4                	jmp    40244d <sched_thd_exit+0x26d>
	return t != &g->idle_thd && t != &g->sched_thd;
  402479:	48 b8 40 5f 5a 00 00 	movabs rax,0x5a5f40
  402480:	00 00 00 
  402483:	49 39 c4             	cmp    r12,rax
  402486:	0f 84 f0 00 00 00    	je     40257c <sched_thd_exit+0x39c>
  40248c:	48 83 e8 78          	sub    rax,0x78
  402490:	49 39 c4             	cmp    r12,rax
  402493:	0f 84 e3 00 00 00    	je     40257c <sched_thd_exit+0x39c>
  402499:	48 bf 70 f3 41 00 00 	movabs rdi,0x41f370
  4024a0:	00 00 00 
  4024a3:	be 61 00 00 00       	mov    esi,0x61
  4024a8:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4024af:	00 00 00 
  4024b2:	ff d0                	call   rax
		assert(ret != -EPERM);
  4024b4:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4024bb:	00 00 00 00 
  4024bf:	0f 0b                	ud2    
  4024c1:	48 bf 20 f2 41 00 00 	movabs rdi,0x41f220
  4024c8:	00 00 00 
  4024cb:	be 59 00 00 00       	mov    esi,0x59
  4024d0:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4024d7:	00 00 00 
  4024da:	ff d0                	call   rax
	assert(current);
  4024dc:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4024e3:	00 00 00 00 
  4024e7:	0f 0b                	ud2    
  4024e9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (i = 0; slm_cs_exit_reschedule(current, SLM_CS_NONE) && i < 16; i++) ;
  4024f0:	83 6d cc 01          	sub    DWORD PTR [rbp-0x34],0x1
  4024f4:	0f 85 bd fd ff ff    	jne    4022b7 <sched_thd_exit+0xd7>
  4024fa:	e9 77 fe ff ff       	jmp    402376 <sched_thd_exit+0x196>
			prio    = curr->priority;
  4024ff:	48 8b 7d c0          	mov    rdi,QWORD PTR [rbp-0x40]
			timeout = TCAP_TIME_NIL;
  402503:	31 c9                	xor    ecx,ecx
			prio    = curr->priority;
  402505:	48 8b 77 30          	mov    rsi,QWORD PTR [rdi+0x30]
  402509:	e9 ce fe ff ff       	jmp    4023dc <sched_thd_exit+0x1fc>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  40250e:	41 89 c0             	mov    r8d,eax
  402511:	48 8b 55 c0          	mov    rdx,QWORD PTR [rbp-0x40]
  402515:	48 89 c6             	mov    rsi,rax
  402518:	48 89 df             	mov    rdi,rbx
  40251b:	41 83 e0 01          	and    r8d,0x1
  40251f:	41 ff d4             	call   r12
			assert(ret != -EBUSY);
  402522:	83 f8 f0             	cmp    eax,0xfffffff0
  402525:	0f 85 49 fd ff ff    	jne    402274 <sched_thd_exit+0x94>
  40252b:	48 bf 80 f2 41 00 00 	movabs rdi,0x41f280
  402532:	00 00 00 
  402535:	be 59 00 00 00       	mov    esi,0x59
  40253a:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  402541:	00 00 00 
  402544:	ff d0                	call   rax
  402546:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40254d:	00 00 00 00 
  402551:	0f 0b                	ud2    
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  402553:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  40255a:	00 00 00 
  40255d:	49 8b 7c 24 28       	mov    rdi,QWORD PTR [r12+0x28]
  402562:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  402565:	44 89 f1             	mov    ecx,r14d
  402568:	48 b8 60 36 41 00 00 	movabs rax,0x413660
  40256f:	00 00 00 
  402572:	4c 89 c6             	mov    rsi,r8
  402575:	ff d0                	call   rax
  402577:	e9 9f fe ff ff       	jmp    40241b <sched_thd_exit+0x23b>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  40257c:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
  402580:	45 89 f1             	mov    r9d,r14d
  402583:	31 c9                	xor    ecx,ecx
  402585:	31 f6                	xor    esi,esi
  402587:	48 8b 50 30          	mov    rdx,QWORD PTR [rax+0x30]
  40258b:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  402592:	00 00 00 
  402595:	4c 8b 00             	mov    r8,QWORD PTR [rax]
  402598:	48 8b 78 f0          	mov    rdi,QWORD PTR [rax-0x10]
  40259c:	48 b8 f0 35 41 00 00 	movabs rax,0x4135f0
  4025a3:	00 00 00 
  4025a6:	ff d0                	call   rax
  4025a8:	e9 6e fe ff ff       	jmp    40241b <sched_thd_exit+0x23b>
  4025ad:	48 bf d8 f3 41 00 00 	movabs rdi,0x41f3d8
  4025b4:	00 00 00 
  4025b7:	be 61 00 00 00       	mov    esi,0x61
  4025bc:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4025c3:	00 00 00 
  4025c6:	ff d0                	call   rax
		assert(ret != -EINVAL);
  4025c8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4025cf:	00 00 00 00 
  4025d3:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  4025d5:	41 89 c0             	mov    r8d,eax
  4025d8:	48 8b 55 c0          	mov    rdx,QWORD PTR [rbp-0x40]
  4025dc:	48 89 c6             	mov    rsi,rax
  4025df:	48 89 df             	mov    rdi,rbx
  4025e2:	41 83 e0 01          	and    r8d,0x1
  4025e6:	41 ff d4             	call   r12
			assert(ret != -EBUSY);
  4025e9:	83 f8 f0             	cmp    eax,0xfffffff0
  4025ec:	0f 85 5b fe ff ff    	jne    40244d <sched_thd_exit+0x26d>
  4025f2:	e9 34 ff ff ff       	jmp    40252b <sched_thd_exit+0x34b>
  4025f7:	48 bf 40 f4 41 00 00 	movabs rdi,0x41f440
  4025fe:	00 00 00 
  402601:	be 61 00 00 00       	mov    esi,0x61
  402606:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40260d:	00 00 00 
  402610:	ff d0                	call   rax
		assert(ret == -EAGAIN);
  402612:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402619:	00 00 00 00 
  40261d:	0f 0b                	ud2    
  40261f:	90                   	nop

0000000000402620 <sched_thd_yield_to>:
{
  402620:	f3 0f 1e fa          	endbr64 
  402624:	55                   	push   rbp
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  402625:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  402628:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  40262e:	48 89 e5             	mov    rbp,rsp
  402631:	41 57                	push   r15
  402633:	41 56                	push   r14
  402635:	41 55                	push   r13
  402637:	41 54                	push   r12
  402639:	53                   	push   rbx
  40263a:	48 83 ec 08          	sub    rsp,0x8
  40263e:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  402645:	48 85 c0             	test   rax,rax
  402648:	0f 84 12 02 00 00    	je     402860 <sched_thd_yield_to+0x240>
  40264e:	83 e8 01             	sub    eax,0x1
  402651:	83 f8 18             	cmp    eax,0x18
  402654:	0f 87 06 02 00 00    	ja     402860 <sched_thd_yield_to+0x240>
  40265a:	48 b9 00 27 46 00 00 	movabs rcx,0x462700
  402661:	00 00 00 
  402664:	45 31 ed             	xor    r13d,r13d
  402667:	48 8b 14 c1          	mov    rdx,QWORD PTR [rcx+rax*8]
  40266b:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  402672:	0f 85 90 01 00 00    	jne    402808 <sched_thd_yield_to+0x1e8>
  402678:	85 ff                	test   edi,edi
  40267a:	0f 84 b0 01 00 00    	je     402830 <sched_thd_yield_to+0x210>
  402680:	83 ef 01             	sub    edi,0x1
  402683:	83 ff 18             	cmp    edi,0x18
  402686:	0f 87 a4 01 00 00    	ja     402830 <sched_thd_yield_to+0x210>
  40268c:	48 ba 00 27 46 00 00 	movabs rdx,0x462700
  402693:	00 00 00 
  402696:	89 f8                	mov    eax,edi
  402698:	48 8b 0c c2          	mov    rcx,QWORD PTR [rdx+rax*8]
  40269c:	48 f7 c1 fe ff ff ff 	test   rcx,0xfffffffffffffffe
  4026a3:	0f 84 87 01 00 00    	je     402830 <sched_thd_yield_to+0x210>
  4026a9:	83 e1 01             	and    ecx,0x1
  4026ac:	0f 85 7e 01 00 00    	jne    402830 <sched_thd_yield_to+0x210>
	return &ss_thd_get(id)->thd;
  4026b2:	48 8d 0c 80          	lea    rcx,[rax+rax*4]
  4026b6:	48 8d 04 48          	lea    rax,[rax+rcx*2]
  4026ba:	48 c1 e0 04          	shl    rax,0x4
  4026be:	4c 8d b4 02 c8 00 00 	lea    r14,[rdx+rax*1+0xc8]
  4026c5:	00 
	assert(current);
  4026c6:	4d 85 ed             	test   r13,r13
  4026c9:	0f 84 dd 01 00 00    	je     4028ac <sched_thd_yield_to+0x28c>
  4026cf:	48 bb d0 35 41 00 00 	movabs rbx,0x4135d0
  4026d6:	00 00 00 
  4026d9:	49 bf c0 5e 5a 00 00 	movabs r15,0x5a5ec0
  4026e0:	00 00 00 
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  4026e3:	49 bc 50 5f 41 00 00 	movabs r12,0x415f50
  4026ea:	00 00 00 
		tok    = cos_sched_sync();
  4026ed:	ff d3                	call   rbx
  4026ef:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4026f2:	49 8b 07             	mov    rax,QWORD PTR [r15]
		if (unlikely(owner)) {
  4026f5:	48 89 c1             	mov    rcx,rax
  4026f8:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  4026fc:	0f 85 66 01 00 00    	jne    402868 <sched_thd_yield_to+0x248>
  402702:	f0 4d 0f b1 2f       	lock cmpxchg QWORD PTR [r15],r13
  402707:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  40270a:	84 c0                	test   al,al
  40270c:	74 df                	je     4026ed <sched_thd_yield_to+0xcd>
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  40270e:	48 b8 a0 49 41 00 00 	movabs rax,0x4149a0
  402715:	00 00 00 
  402718:	4c 89 f6             	mov    rsi,r14
  40271b:	4c 89 ef             	mov    rdi,r13
  40271e:	ff d0                	call   rax
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  402720:	48 b8 10 ce 40 00 00 	movabs rax,0x40ce10
  402727:	00 00 00 
  40272a:	ff d0                	call   rax
	tok  = cos_sched_sync();
  40272c:	ff d3                	call   rbx
  40272e:	41 89 c6             	mov    r14d,eax
  402731:	48 b8 50 48 41 00 00 	movabs rax,0x414850
  402738:	00 00 00 
  40273b:	ff d0                	call   rax
	if (unlikely(!t)) t = &g->idle_thd;
  40273d:	48 85 c0             	test   rax,rax
  402740:	49 89 c4             	mov    r12,rax
  402743:	48 b8 40 5f 5a 00 00 	movabs rax,0x5a5f40
  40274a:	00 00 00 
  40274d:	4c 0f 44 e0          	cmove  r12,rax
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  402751:	41 8b 44 24 04       	mov    eax,DWORD PTR [r12+0x4]
  402756:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  402759:	83 f8 01             	cmp    eax,0x1
  40275c:	76 16                	jbe    402774 <sched_thd_yield_to+0x154>
  40275e:	e9 71 01 00 00       	jmp    4028d4 <sched_thd_yield_to+0x2b4>
  402763:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  402768:	f0 49 0f b1 17       	lock cmpxchg QWORD PTR [r15],rdx
  40276d:	0f 94 c0             	sete   al
	while (ret != 0) {
  402770:	84 c0                	test   al,al
  402772:	75 2c                	jne    4027a0 <sched_thd_yield_to+0x180>
		tok    = cos_sched_sync();
  402774:	ff d3                	call   rbx
  402776:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  402778:	49 8b 07             	mov    rax,QWORD PTR [r15]
		if (unlikely(contention)) {
  40277b:	48 89 c2             	mov    rdx,rax
  40277e:	83 e2 01             	and    edx,0x1
  402781:	74 e5                	je     402768 <sched_thd_yield_to+0x148>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  402783:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  402786:	48 89 c2             	mov    rdx,rax
  402789:	4c 89 ff             	mov    rdi,r15
  40278c:	48 b8 b0 5f 41 00 00 	movabs rax,0x415fb0
  402793:	00 00 00 
  402796:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  40279a:	ff d0                	call   rax
  40279c:	85 c0                	test   eax,eax
  40279e:	75 d4                	jne    402774 <sched_thd_yield_to+0x154>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  4027a0:	48 b8 10 ce 40 00 00 	movabs rax,0x40ce10
  4027a7:	00 00 00 
  4027aa:	ff d0                	call   rax
	prio = inherit_prio ? curr->priority : t->priority;
  4027ac:	49 8b 74 24 30       	mov    rsi,QWORD PTR [r12+0x30]
	timeout = g->timeout_next;
  4027b1:	48 b8 c8 5f 5a 00 00 	movabs rax,0x5a5fc8
  4027b8:	00 00 00 
  4027bb:	4c 8b 00             	mov    r8,QWORD PTR [rax]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4027be:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  4027c2:	a8 0b                	test   al,0xb
  4027c4:	0f 85 32 01 00 00    	jne    4028fc <sched_thd_yield_to+0x2dc>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  4027ca:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  4027cf:	44 89 f1             	mov    ecx,r14d
  4027d2:	4c 89 c2             	mov    rdx,r8
  4027d5:	48 b8 70 e1 40 00 00 	movabs rax,0x40e170
  4027dc:	00 00 00 
  4027df:	ff d0                	call   rax
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  4027e1:	83 f8 ff             	cmp    eax,0xffffffff
  4027e4:	0f 84 69 01 00 00    	je     402953 <sched_thd_yield_to+0x333>
	if (unlikely(ret != 0)) {
  4027ea:	85 c0                	test   eax,eax
  4027ec:	0f 85 d6 01 00 00    	jne    4029c8 <sched_thd_yield_to+0x3a8>
  4027f2:	31 c0                	xor    eax,eax
}
  4027f4:	48 83 c4 08          	add    rsp,0x8
  4027f8:	5b                   	pop    rbx
  4027f9:	41 5c                	pop    r12
  4027fb:	41 5d                	pop    r13
  4027fd:	41 5e                	pop    r14
  4027ff:	41 5f                	pop    r15
  402801:	5d                   	pop    rbp
  402802:	c3                   	ret    
  402803:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  402808:	83 e2 01             	and    edx,0x1
  40280b:	0f 85 67 fe ff ff    	jne    402678 <sched_thd_yield_to+0x58>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  402811:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  402815:	48 8d 04 50          	lea    rax,[rax+rdx*2]
  402819:	48 c1 e0 04          	shl    rax,0x4
  40281d:	4c 8d ac 01 c8 00 00 	lea    r13,[rcx+rax*1+0xc8]
  402824:	00 
  402825:	85 ff                	test   edi,edi
  402827:	0f 85 53 fe ff ff    	jne    402680 <sched_thd_yield_to+0x60>
  40282d:	0f 1f 00             	nop    DWORD PTR [rax]
  402830:	48 bf 20 f7 41 00 00 	movabs rdi,0x41f720
  402837:	00 00 00 
  40283a:	be 24 00 00 00       	mov    esi,0x24
  40283f:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  402846:	00 00 00 
  402849:	ff d0                	call   rax
	assert(to);
  40284b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402852:	00 00 00 00 
  402856:	0f 0b                	ud2    
  402858:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40285f:	00 
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  402860:	45 31 ed             	xor    r13d,r13d
  402863:	e9 10 fe ff ff       	jmp    402678 <sched_thd_yield_to+0x58>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  402868:	41 89 c0             	mov    r8d,eax
  40286b:	4c 89 ea             	mov    rdx,r13
  40286e:	48 89 c6             	mov    rsi,rax
  402871:	4c 89 ff             	mov    rdi,r15
  402874:	41 83 e0 01          	and    r8d,0x1
  402878:	41 ff d4             	call   r12
			assert(ret != -EBUSY);
  40287b:	83 f8 f0             	cmp    eax,0xfffffff0
  40287e:	0f 85 69 fe ff ff    	jne    4026ed <sched_thd_yield_to+0xcd>
  402884:	48 bf 80 f2 41 00 00 	movabs rdi,0x41f280
  40288b:	00 00 00 
  40288e:	be 59 00 00 00       	mov    esi,0x59
  402893:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40289a:	00 00 00 
  40289d:	ff d0                	call   rax
  40289f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4028a6:	00 00 00 00 
  4028aa:	0f 0b                	ud2    
  4028ac:	48 bf 20 f2 41 00 00 	movabs rdi,0x41f220
  4028b3:	00 00 00 
  4028b6:	be 59 00 00 00       	mov    esi,0x59
  4028bb:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4028c2:	00 00 00 
  4028c5:	ff d0                	call   rax
	assert(current);
  4028c7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4028ce:	00 00 00 00 
  4028d2:	0f 0b                	ud2    
  4028d4:	48 bf 08 f3 41 00 00 	movabs rdi,0x41f308
  4028db:	00 00 00 
  4028de:	be 61 00 00 00       	mov    esi,0x61
  4028e3:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4028ea:	00 00 00 
  4028ed:	ff d0                	call   rax
	assert(slm_state_is_runnable(t->state));
  4028ef:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4028f6:	00 00 00 00 
  4028fa:	0f 0b                	ud2    
		if (t == &g->sched_thd) {
  4028fc:	48 ba c8 5e 5a 00 00 	movabs rdx,0x5a5ec8
  402903:	00 00 00 
	timeout = g->timeout_next;
  402906:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  402909:	49 39 d4             	cmp    r12,rdx
  40290c:	0f 84 fa 00 00 00    	je     402a0c <sched_thd_yield_to+0x3ec>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  402912:	a8 02                	test   al,0x2
  402914:	0f 85 fd 00 00 00    	jne    402a17 <sched_thd_yield_to+0x3f7>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  40291a:	49 89 c8             	mov    r8,rcx
  40291d:	a8 01                	test   al,0x1
  40291f:	0f 84 a5 fe ff ff    	je     4027ca <sched_thd_yield_to+0x1aa>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  402925:	4d 8b 54 24 08       	mov    r10,QWORD PTR [r12+0x8]
  40292a:	48 89 f2             	mov    rdx,rsi
  40292d:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  402932:	45 89 f1             	mov    r9d,r14d
  402935:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  40293c:	00 00 00 
  40293f:	4c 8b 00             	mov    r8,QWORD PTR [rax]
  402942:	48 b8 f0 35 41 00 00 	movabs rax,0x4135f0
  402949:	00 00 00 
  40294c:	4c 89 d6             	mov    rsi,r10
  40294f:	ff d0                	call   rax
  402951:	eb 68                	jmp    4029bb <sched_thd_yield_to+0x39b>
	return t != &g->idle_thd && t != &g->sched_thd;
  402953:	48 b8 c8 5e 5a 00 00 	movabs rax,0x5a5ec8
  40295a:	00 00 00 
  40295d:	49 39 c4             	cmp    r12,rax
  402960:	74 31                	je     402993 <sched_thd_yield_to+0x373>
  402962:	48 83 c0 78          	add    rax,0x78
  402966:	49 39 c4             	cmp    r12,rax
  402969:	74 28                	je     402993 <sched_thd_yield_to+0x373>
  40296b:	48 bf 70 f3 41 00 00 	movabs rdi,0x41f370
  402972:	00 00 00 
  402975:	be 61 00 00 00       	mov    esi,0x61
  40297a:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  402981:	00 00 00 
  402984:	ff d0                	call   rax
		assert(ret != -EPERM);
  402986:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40298d:	00 00 00 00 
  402991:	0f 0b                	ud2    
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  402993:	49 8b 55 30          	mov    rdx,QWORD PTR [r13+0x30]
  402997:	45 89 f1             	mov    r9d,r14d
  40299a:	31 c9                	xor    ecx,ecx
  40299c:	31 f6                	xor    esi,esi
  40299e:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  4029a5:	00 00 00 
  4029a8:	4c 8b 00             	mov    r8,QWORD PTR [rax]
  4029ab:	48 8b 78 f0          	mov    rdi,QWORD PTR [rax-0x10]
  4029af:	48 b8 f0 35 41 00 00 	movabs rax,0x4135f0
  4029b6:	00 00 00 
  4029b9:	ff d0                	call   rax
	if (unlikely(ret != 0)) {
  4029bb:	85 c0                	test   eax,eax
  4029bd:	0f 84 2f fe ff ff    	je     4027f2 <sched_thd_yield_to+0x1d2>
		assert(ret != -EPERM);
  4029c3:	83 f8 ff             	cmp    eax,0xffffffff
  4029c6:	74 a3                	je     40296b <sched_thd_yield_to+0x34b>
		assert(ret != -EINVAL);
  4029c8:	83 f8 ea             	cmp    eax,0xffffffea
  4029cb:	74 73                	je     402a40 <sched_thd_yield_to+0x420>
		if (ret == -EBUSY) return ret;
  4029cd:	83 f8 f0             	cmp    eax,0xfffffff0
  4029d0:	0f 84 1e fe ff ff    	je     4027f4 <sched_thd_yield_to+0x1d4>
		assert(ret == -EAGAIN);
  4029d6:	83 f8 f5             	cmp    eax,0xfffffff5
  4029d9:	0f 85 b1 00 00 00    	jne    402a90 <sched_thd_yield_to+0x470>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  4029df:	49 bc 50 5f 41 00 00 	movabs r12,0x415f50
  4029e6:	00 00 00 
		tok    = cos_sched_sync();
  4029e9:	ff d3                	call   rbx
  4029eb:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4029ee:	49 8b 07             	mov    rax,QWORD PTR [r15]
		if (unlikely(owner)) {
  4029f1:	48 89 c1             	mov    rcx,rax
  4029f4:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  4029f8:	75 6e                	jne    402a68 <sched_thd_yield_to+0x448>
  4029fa:	f0 4d 0f b1 2f       	lock cmpxchg QWORD PTR [r15],r13
  4029ff:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  402a02:	84 c0                	test   al,al
  402a04:	0f 85 22 fd ff ff    	jne    40272c <sched_thd_yield_to+0x10c>
  402a0a:	eb dd                	jmp    4029e9 <sched_thd_yield_to+0x3c9>
			prio    = curr->priority;
  402a0c:	49 8b 75 30          	mov    rsi,QWORD PTR [r13+0x30]
			timeout = TCAP_TIME_NIL;
  402a10:	31 c9                	xor    ecx,ecx
  402a12:	e9 fb fe ff ff       	jmp    402912 <sched_thd_yield_to+0x2f2>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  402a17:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  402a1e:	00 00 00 
  402a21:	49 8b 7c 24 28       	mov    rdi,QWORD PTR [r12+0x28]
  402a26:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  402a29:	44 89 f1             	mov    ecx,r14d
  402a2c:	48 b8 60 36 41 00 00 	movabs rax,0x413660
  402a33:	00 00 00 
  402a36:	4c 89 c6             	mov    rsi,r8
  402a39:	ff d0                	call   rax
  402a3b:	e9 7b ff ff ff       	jmp    4029bb <sched_thd_yield_to+0x39b>
  402a40:	48 bf d8 f3 41 00 00 	movabs rdi,0x41f3d8
  402a47:	00 00 00 
  402a4a:	be 61 00 00 00       	mov    esi,0x61
  402a4f:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  402a56:	00 00 00 
  402a59:	ff d0                	call   rax
		assert(ret != -EINVAL);
  402a5b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402a62:	00 00 00 00 
  402a66:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  402a68:	41 89 c0             	mov    r8d,eax
  402a6b:	4c 89 ea             	mov    rdx,r13
  402a6e:	48 89 c6             	mov    rsi,rax
  402a71:	4c 89 ff             	mov    rdi,r15
  402a74:	41 83 e0 01          	and    r8d,0x1
  402a78:	41 ff d4             	call   r12
			assert(ret != -EBUSY);
  402a7b:	83 f8 f0             	cmp    eax,0xfffffff0
  402a7e:	0f 85 65 ff ff ff    	jne    4029e9 <sched_thd_yield_to+0x3c9>
  402a84:	e9 fb fd ff ff       	jmp    402884 <sched_thd_yield_to+0x264>
  402a89:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  402a90:	48 bf 40 f4 41 00 00 	movabs rdi,0x41f440
  402a97:	00 00 00 
  402a9a:	be 61 00 00 00       	mov    esi,0x61
  402a9f:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  402aa6:	00 00 00 
  402aa9:	ff d0                	call   rax
		assert(ret == -EAGAIN);
  402aab:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402ab2:	00 00 00 00 
  402ab6:	0f 0b                	ud2    
  402ab8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  402abf:	00 

0000000000402ac0 <sched_set_tls>:
{
  402ac0:	f3 0f 1e fa          	endbr64 
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  402ac4:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  402ac7:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  402acd:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  402ad4:	48 85 c0             	test   rax,rax
  402ad7:	0f 84 43 4e 01 00    	je     417920 <sched_set_tls.cold>
  402add:	83 e8 01             	sub    eax,0x1
  402ae0:	83 f8 18             	cmp    eax,0x18
  402ae3:	0f 87 37 4e 01 00    	ja     417920 <sched_set_tls.cold>
  402ae9:	48 ba 00 27 46 00 00 	movabs rdx,0x462700
  402af0:	00 00 00 
  402af3:	48 8b 14 c2          	mov    rdx,QWORD PTR [rdx+rax*8]
  402af7:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  402afe:	0f 84 1c 4e 01 00    	je     417920 <sched_set_tls.cold>
  402b04:	83 e2 01             	and    edx,0x1
  402b07:	0f 85 13 4e 01 00    	jne    417920 <sched_set_tls.cold>
	thdcap_t thdcap = current->thd;
  402b0d:	48 8d 14 80          	lea    rdx,[rax+rax*4]
	capmgr_set_tls(thdcap, tls_addr);
  402b11:	48 89 fe             	mov    rsi,rdi
	thdcap_t thdcap = current->thd;
  402b14:	48 8d 04 50          	lea    rax,[rax+rdx*2]
	capmgr_set_tls(thdcap, tls_addr);
  402b18:	48 ba c8 27 46 00 00 	movabs rdx,0x4627c8
  402b1f:	00 00 00 
	thdcap_t thdcap = current->thd;
  402b22:	48 c1 e0 04          	shl    rax,0x4
	capmgr_set_tls(thdcap, tls_addr);
  402b26:	4c 8b 44 02 10       	mov    r8,QWORD PTR [rdx+rax*1+0x10]
  402b2b:	48 b8 a0 85 40 00 00 	movabs rax,0x4085a0
  402b32:	00 00 00 
  402b35:	4c 89 c7             	mov    rdi,r8
  402b38:	ff e0                	jmp    rax
  402b3a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000402b40 <thd_block>:
{
  402b40:	f3 0f 1e fa          	endbr64 
  402b44:	55                   	push   rbp
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  402b45:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  402b48:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  402b4e:	48 89 e5             	mov    rbp,rsp
  402b51:	41 57                	push   r15
  402b53:	41 56                	push   r14
  402b55:	41 55                	push   r13
  402b57:	41 54                	push   r12
  402b59:	53                   	push   rbx
  402b5a:	48 83 ec 18          	sub    rsp,0x18
  402b5e:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  402b65:	48 85 c0             	test   rax,rax
  402b68:	0f 84 ca 01 00 00    	je     402d38 <thd_block+0x1f8>
  402b6e:	83 e8 01             	sub    eax,0x1
  402b71:	83 f8 18             	cmp    eax,0x18
  402b74:	0f 87 be 01 00 00    	ja     402d38 <thd_block+0x1f8>
  402b7a:	48 ba 00 27 46 00 00 	movabs rdx,0x462700
  402b81:	00 00 00 
  402b84:	48 8b 0c c2          	mov    rcx,QWORD PTR [rdx+rax*8]
  402b88:	48 f7 c1 fe ff ff ff 	test   rcx,0xfffffffffffffffe
  402b8f:	0f 84 a3 01 00 00    	je     402d38 <thd_block+0x1f8>
  402b95:	83 e1 01             	and    ecx,0x1
  402b98:	0f 85 9a 01 00 00    	jne    402d38 <thd_block+0x1f8>
  402b9e:	48 bb d0 35 41 00 00 	movabs rbx,0x4135d0
  402ba5:	00 00 00 
  402ba8:	48 8d 0c 80          	lea    rcx,[rax+rax*4]
  402bac:	49 bf c0 5e 5a 00 00 	movabs r15,0x5a5ec0
  402bb3:	00 00 00 
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  402bb6:	49 bc 50 5f 41 00 00 	movabs r12,0x415f50
  402bbd:	00 00 00 
  402bc0:	48 8d 04 48          	lea    rax,[rax+rcx*2]
  402bc4:	48 c1 e0 04          	shl    rax,0x4
  402bc8:	4c 8d b4 02 c8 00 00 	lea    r14,[rdx+rax*1+0xc8]
  402bcf:	00 
		tok    = cos_sched_sync();
  402bd0:	ff d3                	call   rbx
  402bd2:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  402bd5:	49 8b 07             	mov    rax,QWORD PTR [r15]
		if (unlikely(owner)) {
  402bd8:	48 89 c1             	mov    rcx,rax
  402bdb:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  402bdf:	0f 85 7b 01 00 00    	jne    402d60 <thd_block+0x220>
  402be5:	f0 4d 0f b1 37       	lock cmpxchg QWORD PTR [r15],r14
  402bea:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  402bed:	84 c0                	test   al,al
  402bef:	74 df                	je     402bd0 <thd_block+0x90>
        ret = slm_thd_block(current);
  402bf1:	48 b8 30 60 41 00 00 	movabs rax,0x416030
  402bf8:	00 00 00 
  402bfb:	4c 89 f7             	mov    rdi,r14
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  402bfe:	49 bc b0 5f 41 00 00 	movabs r12,0x415fb0
  402c05:	00 00 00 
  402c08:	ff d0                	call   rax
  402c0a:	41 89 c5             	mov    r13d,eax
	if (!ret) ret = slm_cs_exit_reschedule(current, SLM_CS_NONE);
  402c0d:	85 c0                	test   eax,eax
  402c0f:	0f 85 f7 00 00 00    	jne    402d0c <thd_block+0x1cc>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  402c15:	48 b8 10 ce 40 00 00 	movabs rax,0x40ce10
  402c1c:	00 00 00 
  402c1f:	ff d0                	call   rax
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  402c21:	4c 89 75 c8          	mov    QWORD PTR [rbp-0x38],r14
	tok  = cos_sched_sync();
  402c25:	ff d3                	call   rbx
  402c27:	41 89 c6             	mov    r14d,eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  402c2a:	48 b8 50 48 41 00 00 	movabs rax,0x414850
  402c31:	00 00 00 
  402c34:	ff d0                	call   rax
	if (unlikely(!t)) t = &g->idle_thd;
  402c36:	48 85 c0             	test   rax,rax
  402c39:	49 89 c4             	mov    r12,rax
  402c3c:	48 b8 40 5f 5a 00 00 	movabs rax,0x5a5f40
  402c43:	00 00 00 
  402c46:	4c 0f 44 e0          	cmove  r12,rax
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  402c4a:	41 8b 44 24 04       	mov    eax,DWORD PTR [r12+0x4]
  402c4f:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  402c52:	83 f8 01             	cmp    eax,0x1
  402c55:	76 15                	jbe    402c6c <thd_block+0x12c>
  402c57:	e9 9c 01 00 00       	jmp    402df8 <thd_block+0x2b8>
  402c5c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  402c60:	f0 49 0f b1 17       	lock cmpxchg QWORD PTR [r15],rdx
  402c65:	0f 94 c0             	sete   al
	while (ret != 0) {
  402c68:	84 c0                	test   al,al
  402c6a:	75 2c                	jne    402c98 <thd_block+0x158>
		tok    = cos_sched_sync();
  402c6c:	ff d3                	call   rbx
  402c6e:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  402c70:	49 8b 07             	mov    rax,QWORD PTR [r15]
		if (unlikely(contention)) {
  402c73:	48 89 c2             	mov    rdx,rax
  402c76:	83 e2 01             	and    edx,0x1
  402c79:	74 e5                	je     402c60 <thd_block+0x120>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  402c7b:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  402c7e:	48 89 c2             	mov    rdx,rax
  402c81:	4c 89 ff             	mov    rdi,r15
  402c84:	48 b8 b0 5f 41 00 00 	movabs rax,0x415fb0
  402c8b:	00 00 00 
  402c8e:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  402c92:	ff d0                	call   rax
  402c94:	85 c0                	test   eax,eax
  402c96:	75 d4                	jne    402c6c <thd_block+0x12c>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  402c98:	48 b8 10 ce 40 00 00 	movabs rax,0x40ce10
  402c9f:	00 00 00 
  402ca2:	ff d0                	call   rax
	prio = inherit_prio ? curr->priority : t->priority;
  402ca4:	49 8b 74 24 30       	mov    rsi,QWORD PTR [r12+0x30]
	timeout = g->timeout_next;
  402ca9:	48 b8 c8 5f 5a 00 00 	movabs rax,0x5a5fc8
  402cb0:	00 00 00 
  402cb3:	4c 8b 00             	mov    r8,QWORD PTR [rax]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  402cb6:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  402cba:	a8 0b                	test   al,0xb
  402cbc:	0f 85 5e 01 00 00    	jne    402e20 <thd_block+0x2e0>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  402cc2:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  402cc7:	44 89 f1             	mov    ecx,r14d
  402cca:	4c 89 c2             	mov    rdx,r8
  402ccd:	48 b8 70 e1 40 00 00 	movabs rax,0x40e170
  402cd4:	00 00 00 
  402cd7:	ff d0                	call   rax
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  402cd9:	83 f8 ff             	cmp    eax,0xffffffff
  402cdc:	0f 84 cc 01 00 00    	je     402eae <thd_block+0x36e>
	if (unlikely(ret != 0)) {
  402ce2:	85 c0                	test   eax,eax
  402ce4:	0f 85 ba 00 00 00    	jne    402da4 <thd_block+0x264>
}
  402cea:	48 83 c4 18          	add    rsp,0x18
  402cee:	44 89 e8             	mov    eax,r13d
  402cf1:	5b                   	pop    rbx
  402cf2:	41 5c                	pop    r12
  402cf4:	41 5d                	pop    r13
  402cf6:	41 5e                	pop    r14
  402cf8:	41 5f                	pop    r15
  402cfa:	5d                   	pop    rbp
  402cfb:	c3                   	ret    
  402cfc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  402d00:	f0 49 0f b1 17       	lock cmpxchg QWORD PTR [r15],rdx
  402d05:	0f 94 c0             	sete   al
	while (ret != 0) {
  402d08:	84 c0                	test   al,al
  402d0a:	75 de                	jne    402cea <thd_block+0x1aa>
		tok    = cos_sched_sync();
  402d0c:	ff d3                	call   rbx
  402d0e:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  402d10:	49 8b 07             	mov    rax,QWORD PTR [r15]
		if (unlikely(contention)) {
  402d13:	48 89 c2             	mov    rdx,rax
  402d16:	83 e2 01             	and    edx,0x1
  402d19:	74 e5                	je     402d00 <thd_block+0x1c0>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  402d1b:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  402d1e:	48 89 c2             	mov    rdx,rax
  402d21:	4c 89 ff             	mov    rdi,r15
  402d24:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  402d28:	41 ff d4             	call   r12
  402d2b:	85 c0                	test   eax,eax
  402d2d:	74 bb                	je     402cea <thd_block+0x1aa>
  402d2f:	eb db                	jmp    402d0c <thd_block+0x1cc>
  402d31:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  402d38:	48 bf 20 f2 41 00 00 	movabs rdi,0x41f220
  402d3f:	00 00 00 
  402d42:	be 59 00 00 00       	mov    esi,0x59
  402d47:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  402d4e:	00 00 00 
  402d51:	ff d0                	call   rax
	assert(current);
  402d53:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402d5a:	00 00 00 00 
  402d5e:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  402d60:	41 89 c0             	mov    r8d,eax
  402d63:	4c 89 f2             	mov    rdx,r14
  402d66:	48 89 c6             	mov    rsi,rax
  402d69:	4c 89 ff             	mov    rdi,r15
  402d6c:	41 83 e0 01          	and    r8d,0x1
  402d70:	41 ff d4             	call   r12
			assert(ret != -EBUSY);
  402d73:	83 f8 f0             	cmp    eax,0xfffffff0
  402d76:	0f 85 54 fe ff ff    	jne    402bd0 <thd_block+0x90>
  402d7c:	48 bf 80 f2 41 00 00 	movabs rdi,0x41f280
  402d83:	00 00 00 
  402d86:	be 59 00 00 00       	mov    esi,0x59
  402d8b:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  402d92:	00 00 00 
  402d95:	ff d0                	call   rax
  402d97:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402d9e:	00 00 00 00 
  402da2:	0f 0b                	ud2    
		assert(ret != -EINVAL);
  402da4:	83 f8 ea             	cmp    eax,0xffffffea
  402da7:	0f 84 7f 01 00 00    	je     402f2c <thd_block+0x3ec>
		if (ret == -EBUSY) return ret;
  402dad:	83 f8 f0             	cmp    eax,0xfffffff0
  402db0:	0f 84 f2 01 00 00    	je     402fa8 <thd_block+0x468>
		assert(ret == -EAGAIN);
  402db6:	83 f8 f5             	cmp    eax,0xfffffff5
  402db9:	0f 85 c1 01 00 00    	jne    402f80 <thd_block+0x440>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  402dbf:	49 bc 50 5f 41 00 00 	movabs r12,0x415f50
  402dc6:	00 00 00 
		tok    = cos_sched_sync();
  402dc9:	ff d3                	call   rbx
  402dcb:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  402dce:	49 8b 07             	mov    rax,QWORD PTR [r15]
		if (unlikely(owner)) {
  402dd1:	48 89 c1             	mov    rcx,rax
  402dd4:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  402dd8:	0f 85 76 01 00 00    	jne    402f54 <thd_block+0x414>
  402dde:	48 8b 7d c8          	mov    rdi,QWORD PTR [rbp-0x38]
  402de2:	f0 49 0f b1 3f       	lock cmpxchg QWORD PTR [r15],rdi
  402de7:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  402dea:	84 c0                	test   al,al
  402dec:	0f 85 33 fe ff ff    	jne    402c25 <thd_block+0xe5>
  402df2:	eb d5                	jmp    402dc9 <thd_block+0x289>
  402df4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  402df8:	48 bf 08 f3 41 00 00 	movabs rdi,0x41f308
  402dff:	00 00 00 
  402e02:	be 61 00 00 00       	mov    esi,0x61
  402e07:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  402e0e:	00 00 00 
  402e11:	ff d0                	call   rax
	assert(slm_state_is_runnable(t->state));
  402e13:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402e1a:	00 00 00 00 
  402e1e:	0f 0b                	ud2    
		if (t == &g->sched_thd) {
  402e20:	48 ba c8 5e 5a 00 00 	movabs rdx,0x5a5ec8
  402e27:	00 00 00 
	timeout = g->timeout_next;
  402e2a:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  402e2d:	49 39 d4             	cmp    r12,rdx
  402e30:	0f 84 be 00 00 00    	je     402ef4 <thd_block+0x3b4>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  402e36:	a8 02                	test   al,0x2
  402e38:	0f 85 c5 00 00 00    	jne    402f03 <thd_block+0x3c3>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  402e3e:	49 89 c8             	mov    r8,rcx
  402e41:	a8 01                	test   al,0x1
  402e43:	0f 84 79 fe ff ff    	je     402cc2 <thd_block+0x182>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  402e49:	4d 8b 54 24 08       	mov    r10,QWORD PTR [r12+0x8]
  402e4e:	48 89 f2             	mov    rdx,rsi
  402e51:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  402e56:	45 89 f1             	mov    r9d,r14d
  402e59:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  402e60:	00 00 00 
  402e63:	4c 8b 00             	mov    r8,QWORD PTR [rax]
  402e66:	48 b8 f0 35 41 00 00 	movabs rax,0x4135f0
  402e6d:	00 00 00 
  402e70:	4c 89 d6             	mov    rsi,r10
  402e73:	ff d0                	call   rax
	if (unlikely(ret != 0)) {
  402e75:	85 c0                	test   eax,eax
  402e77:	0f 84 6d fe ff ff    	je     402cea <thd_block+0x1aa>
		assert(ret != -EPERM);
  402e7d:	83 f8 ff             	cmp    eax,0xffffffff
  402e80:	0f 85 1e ff ff ff    	jne    402da4 <thd_block+0x264>
  402e86:	48 bf 70 f3 41 00 00 	movabs rdi,0x41f370
  402e8d:	00 00 00 
  402e90:	be 61 00 00 00       	mov    esi,0x61
  402e95:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  402e9c:	00 00 00 
  402e9f:	ff d0                	call   rax
  402ea1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402ea8:	00 00 00 00 
  402eac:	0f 0b                	ud2    
	return t != &g->idle_thd && t != &g->sched_thd;
  402eae:	48 b8 40 5f 5a 00 00 	movabs rax,0x5a5f40
  402eb5:	00 00 00 
  402eb8:	49 39 c4             	cmp    r12,rax
  402ebb:	74 09                	je     402ec6 <thd_block+0x386>
  402ebd:	48 83 e8 78          	sub    rax,0x78
  402ec1:	49 39 c4             	cmp    r12,rax
  402ec4:	75 c0                	jne    402e86 <thd_block+0x346>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  402ec6:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  402eca:	45 89 f1             	mov    r9d,r14d
  402ecd:	31 c9                	xor    ecx,ecx
  402ecf:	31 f6                	xor    esi,esi
  402ed1:	48 8b 50 30          	mov    rdx,QWORD PTR [rax+0x30]
  402ed5:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  402edc:	00 00 00 
  402edf:	4c 8b 00             	mov    r8,QWORD PTR [rax]
  402ee2:	48 8b 78 f0          	mov    rdi,QWORD PTR [rax-0x10]
  402ee6:	48 b8 f0 35 41 00 00 	movabs rax,0x4135f0
  402eed:	00 00 00 
  402ef0:	ff d0                	call   rax
  402ef2:	eb 81                	jmp    402e75 <thd_block+0x335>
			prio    = curr->priority;
  402ef4:	48 8b 7d c8          	mov    rdi,QWORD PTR [rbp-0x38]
			timeout = TCAP_TIME_NIL;
  402ef8:	31 c9                	xor    ecx,ecx
			prio    = curr->priority;
  402efa:	48 8b 77 30          	mov    rsi,QWORD PTR [rdi+0x30]
  402efe:	e9 33 ff ff ff       	jmp    402e36 <thd_block+0x2f6>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  402f03:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  402f0a:	00 00 00 
  402f0d:	49 8b 7c 24 28       	mov    rdi,QWORD PTR [r12+0x28]
  402f12:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  402f15:	44 89 f1             	mov    ecx,r14d
  402f18:	48 b8 60 36 41 00 00 	movabs rax,0x413660
  402f1f:	00 00 00 
  402f22:	4c 89 c6             	mov    rsi,r8
  402f25:	ff d0                	call   rax
  402f27:	e9 49 ff ff ff       	jmp    402e75 <thd_block+0x335>
  402f2c:	48 bf d8 f3 41 00 00 	movabs rdi,0x41f3d8
  402f33:	00 00 00 
  402f36:	be 61 00 00 00       	mov    esi,0x61
  402f3b:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  402f42:	00 00 00 
  402f45:	ff d0                	call   rax
		assert(ret != -EINVAL);
  402f47:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402f4e:	00 00 00 00 
  402f52:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  402f54:	41 89 c0             	mov    r8d,eax
  402f57:	48 8b 55 c8          	mov    rdx,QWORD PTR [rbp-0x38]
  402f5b:	48 89 c6             	mov    rsi,rax
  402f5e:	4c 89 ff             	mov    rdi,r15
  402f61:	41 83 e0 01          	and    r8d,0x1
  402f65:	41 ff d4             	call   r12
			assert(ret != -EBUSY);
  402f68:	83 f8 f0             	cmp    eax,0xfffffff0
  402f6b:	0f 85 58 fe ff ff    	jne    402dc9 <thd_block+0x289>
  402f71:	e9 06 fe ff ff       	jmp    402d7c <thd_block+0x23c>
  402f76:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  402f7d:	00 00 00 
  402f80:	48 bf 40 f4 41 00 00 	movabs rdi,0x41f440
  402f87:	00 00 00 
  402f8a:	be 61 00 00 00       	mov    esi,0x61
  402f8f:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  402f96:	00 00 00 
  402f99:	ff d0                	call   rax
		assert(ret == -EAGAIN);
  402f9b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402fa2:	00 00 00 00 
  402fa6:	0f 0b                	ud2    
	ret = slm_thd_activate(curr, t, tok, 0);
  402fa8:	41 bd f0 ff ff ff    	mov    r13d,0xfffffff0
	return ret;
  402fae:	e9 37 fd ff ff       	jmp    402cea <thd_block+0x1aa>
  402fb3:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  402fba:	00 00 00 00 
  402fbe:	66 90                	xchg   ax,ax

0000000000402fc0 <sched_thd_block>:
{
  402fc0:	f3 0f 1e fa          	endbr64 
  402fc4:	55                   	push   rbp
  402fc5:	48 89 e5             	mov    rbp,rsp
  402fc8:	41 57                	push   r15
  402fca:	41 56                	push   r14
  402fcc:	41 55                	push   r13
  402fce:	41 54                	push   r12
  402fd0:	53                   	push   rbx
  402fd1:	48 83 ec 18          	sub    rsp,0x18
	if (dep_id) return -1;
  402fd5:	48 85 ff             	test   rdi,rdi
  402fd8:	0f 85 a6 03 00 00    	jne    403384 <sched_thd_block+0x3c4>
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  402fde:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  402fe1:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  402fe7:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  402fee:	48 85 c0             	test   rax,rax
  402ff1:	0f 84 c9 01 00 00    	je     4031c0 <sched_thd_block+0x200>
  402ff7:	83 e8 01             	sub    eax,0x1
  402ffa:	83 f8 18             	cmp    eax,0x18
  402ffd:	0f 87 bd 01 00 00    	ja     4031c0 <sched_thd_block+0x200>
  403003:	48 ba 00 27 46 00 00 	movabs rdx,0x462700
  40300a:	00 00 00 
  40300d:	48 8b 0c c2          	mov    rcx,QWORD PTR [rdx+rax*8]
  403011:	48 f7 c1 fe ff ff ff 	test   rcx,0xfffffffffffffffe
  403018:	0f 84 a2 01 00 00    	je     4031c0 <sched_thd_block+0x200>
  40301e:	83 e1 01             	and    ecx,0x1
  403021:	0f 85 99 01 00 00    	jne    4031c0 <sched_thd_block+0x200>
  403027:	48 bb d0 35 41 00 00 	movabs rbx,0x4135d0
  40302e:	00 00 00 
  403031:	48 8d 0c 80          	lea    rcx,[rax+rax*4]
  403035:	49 bf c0 5e 5a 00 00 	movabs r15,0x5a5ec0
  40303c:	00 00 00 
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  40303f:	49 bc 50 5f 41 00 00 	movabs r12,0x415f50
  403046:	00 00 00 
  403049:	48 8d 04 48          	lea    rax,[rax+rcx*2]
  40304d:	48 c1 e0 04          	shl    rax,0x4
  403051:	4c 8d b4 02 c8 00 00 	lea    r14,[rdx+rax*1+0xc8]
  403058:	00 
		tok    = cos_sched_sync();
  403059:	ff d3                	call   rbx
  40305b:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  40305e:	49 8b 07             	mov    rax,QWORD PTR [r15]
		if (unlikely(owner)) {
  403061:	48 89 c1             	mov    rcx,rax
  403064:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  403068:	0f 85 82 01 00 00    	jne    4031f0 <sched_thd_block+0x230>
  40306e:	f0 4d 0f b1 37       	lock cmpxchg QWORD PTR [r15],r14
  403073:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  403076:	84 c0                	test   al,al
  403078:	74 df                	je     403059 <sched_thd_block+0x99>
        ret = slm_thd_block(current);
  40307a:	48 b8 30 60 41 00 00 	movabs rax,0x416030
  403081:	00 00 00 
  403084:	4c 89 f7             	mov    rdi,r14
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  403087:	49 bc b0 5f 41 00 00 	movabs r12,0x415fb0
  40308e:	00 00 00 
  403091:	ff d0                	call   rax
  403093:	41 89 c5             	mov    r13d,eax
	if (!ret) ret = slm_cs_exit_reschedule(current, SLM_CS_NONE);
  403096:	85 c0                	test   eax,eax
  403098:	0f 85 f6 00 00 00    	jne    403194 <sched_thd_block+0x1d4>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  40309e:	48 b8 10 ce 40 00 00 	movabs rax,0x40ce10
  4030a5:	00 00 00 
  4030a8:	ff d0                	call   rax
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  4030aa:	4c 89 75 c8          	mov    QWORD PTR [rbp-0x38],r14
	tok  = cos_sched_sync();
  4030ae:	ff d3                	call   rbx
  4030b0:	41 89 c6             	mov    r14d,eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  4030b3:	48 b8 50 48 41 00 00 	movabs rax,0x414850
  4030ba:	00 00 00 
  4030bd:	ff d0                	call   rax
	if (unlikely(!t)) t = &g->idle_thd;
  4030bf:	48 85 c0             	test   rax,rax
  4030c2:	49 89 c4             	mov    r12,rax
  4030c5:	48 b8 40 5f 5a 00 00 	movabs rax,0x5a5f40
  4030cc:	00 00 00 
  4030cf:	4c 0f 44 e0          	cmove  r12,rax
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  4030d3:	41 8b 44 24 04       	mov    eax,DWORD PTR [r12+0x4]
  4030d8:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  4030db:	83 f8 01             	cmp    eax,0x1
  4030de:	76 14                	jbe    4030f4 <sched_thd_block+0x134>
  4030e0:	e9 a3 01 00 00       	jmp    403288 <sched_thd_block+0x2c8>
  4030e5:	0f 1f 00             	nop    DWORD PTR [rax]
  4030e8:	f0 49 0f b1 17       	lock cmpxchg QWORD PTR [r15],rdx
  4030ed:	0f 94 c0             	sete   al
	while (ret != 0) {
  4030f0:	84 c0                	test   al,al
  4030f2:	75 2c                	jne    403120 <sched_thd_block+0x160>
		tok    = cos_sched_sync();
  4030f4:	ff d3                	call   rbx
  4030f6:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4030f8:	49 8b 07             	mov    rax,QWORD PTR [r15]
		if (unlikely(contention)) {
  4030fb:	48 89 c2             	mov    rdx,rax
  4030fe:	83 e2 01             	and    edx,0x1
  403101:	74 e5                	je     4030e8 <sched_thd_block+0x128>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  403103:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  403106:	48 89 c2             	mov    rdx,rax
  403109:	4c 89 ff             	mov    rdi,r15
  40310c:	48 b8 b0 5f 41 00 00 	movabs rax,0x415fb0
  403113:	00 00 00 
  403116:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  40311a:	ff d0                	call   rax
  40311c:	85 c0                	test   eax,eax
  40311e:	75 d4                	jne    4030f4 <sched_thd_block+0x134>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  403120:	48 b8 10 ce 40 00 00 	movabs rax,0x40ce10
  403127:	00 00 00 
  40312a:	ff d0                	call   rax
	prio = inherit_prio ? curr->priority : t->priority;
  40312c:	49 8b 74 24 30       	mov    rsi,QWORD PTR [r12+0x30]
	timeout = g->timeout_next;
  403131:	48 b8 c8 5f 5a 00 00 	movabs rax,0x5a5fc8
  403138:	00 00 00 
  40313b:	4c 8b 00             	mov    r8,QWORD PTR [rax]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  40313e:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  403142:	a8 0b                	test   al,0xb
  403144:	0f 85 66 01 00 00    	jne    4032b0 <sched_thd_block+0x2f0>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  40314a:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  40314f:	44 89 f1             	mov    ecx,r14d
  403152:	4c 89 c2             	mov    rdx,r8
  403155:	48 b8 70 e1 40 00 00 	movabs rax,0x40e170
  40315c:	00 00 00 
  40315f:	ff d0                	call   rax
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  403161:	83 f8 ff             	cmp    eax,0xffffffff
  403164:	0f 84 d4 01 00 00    	je     40333e <sched_thd_block+0x37e>
	if (unlikely(ret != 0)) {
  40316a:	85 c0                	test   eax,eax
  40316c:	0f 85 c2 00 00 00    	jne    403234 <sched_thd_block+0x274>
}
  403172:	48 83 c4 18          	add    rsp,0x18
  403176:	44 89 e8             	mov    eax,r13d
  403179:	5b                   	pop    rbx
  40317a:	41 5c                	pop    r12
  40317c:	41 5d                	pop    r13
  40317e:	41 5e                	pop    r14
  403180:	41 5f                	pop    r15
  403182:	5d                   	pop    rbp
  403183:	c3                   	ret    
  403184:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  403188:	f0 49 0f b1 17       	lock cmpxchg QWORD PTR [r15],rdx
  40318d:	0f 94 c0             	sete   al
	while (ret != 0) {
  403190:	84 c0                	test   al,al
  403192:	75 de                	jne    403172 <sched_thd_block+0x1b2>
		tok    = cos_sched_sync();
  403194:	ff d3                	call   rbx
  403196:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  403198:	49 8b 07             	mov    rax,QWORD PTR [r15]
		if (unlikely(contention)) {
  40319b:	48 89 c2             	mov    rdx,rax
  40319e:	83 e2 01             	and    edx,0x1
  4031a1:	74 e5                	je     403188 <sched_thd_block+0x1c8>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  4031a3:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  4031a6:	48 89 c2             	mov    rdx,rax
  4031a9:	4c 89 ff             	mov    rdi,r15
  4031ac:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  4031b0:	41 ff d4             	call   r12
  4031b3:	85 c0                	test   eax,eax
  4031b5:	74 bb                	je     403172 <sched_thd_block+0x1b2>
  4031b7:	eb db                	jmp    403194 <sched_thd_block+0x1d4>
  4031b9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  4031c0:	48 bf 20 f2 41 00 00 	movabs rdi,0x41f220
  4031c7:	00 00 00 
  4031ca:	be 59 00 00 00       	mov    esi,0x59
  4031cf:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4031d6:	00 00 00 
  4031d9:	ff d0                	call   rax
	assert(current);
  4031db:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4031e2:	00 00 00 00 
  4031e6:	0f 0b                	ud2    
  4031e8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4031ef:	00 
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  4031f0:	41 89 c0             	mov    r8d,eax
  4031f3:	4c 89 f2             	mov    rdx,r14
  4031f6:	48 89 c6             	mov    rsi,rax
  4031f9:	4c 89 ff             	mov    rdi,r15
  4031fc:	41 83 e0 01          	and    r8d,0x1
  403200:	41 ff d4             	call   r12
			assert(ret != -EBUSY);
  403203:	83 f8 f0             	cmp    eax,0xfffffff0
  403206:	0f 85 4d fe ff ff    	jne    403059 <sched_thd_block+0x99>
  40320c:	48 bf 80 f2 41 00 00 	movabs rdi,0x41f280
  403213:	00 00 00 
  403216:	be 59 00 00 00       	mov    esi,0x59
  40321b:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  403222:	00 00 00 
  403225:	ff d0                	call   rax
  403227:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40322e:	00 00 00 00 
  403232:	0f 0b                	ud2    
		assert(ret != -EINVAL);
  403234:	83 f8 ea             	cmp    eax,0xffffffea
  403237:	0f 84 8a 01 00 00    	je     4033c7 <sched_thd_block+0x407>
		if (ret == -EBUSY) return ret;
  40323d:	83 f8 f0             	cmp    eax,0xfffffff0
  403240:	0f 84 fa 01 00 00    	je     403440 <sched_thd_block+0x480>
		assert(ret == -EAGAIN);
  403246:	83 f8 f5             	cmp    eax,0xfffffff5
  403249:	0f 85 c9 01 00 00    	jne    403418 <sched_thd_block+0x458>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  40324f:	49 bc 50 5f 41 00 00 	movabs r12,0x415f50
  403256:	00 00 00 
		tok    = cos_sched_sync();
  403259:	ff d3                	call   rbx
  40325b:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  40325e:	49 8b 07             	mov    rax,QWORD PTR [r15]
		if (unlikely(owner)) {
  403261:	48 89 c1             	mov    rcx,rax
  403264:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  403268:	0f 85 81 01 00 00    	jne    4033ef <sched_thd_block+0x42f>
  40326e:	48 8b 75 c8          	mov    rsi,QWORD PTR [rbp-0x38]
  403272:	f0 49 0f b1 37       	lock cmpxchg QWORD PTR [r15],rsi
  403277:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  40327a:	84 c0                	test   al,al
  40327c:	0f 85 2c fe ff ff    	jne    4030ae <sched_thd_block+0xee>
  403282:	eb d5                	jmp    403259 <sched_thd_block+0x299>
  403284:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  403288:	48 bf 08 f3 41 00 00 	movabs rdi,0x41f308
  40328f:	00 00 00 
  403292:	be 61 00 00 00       	mov    esi,0x61
  403297:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40329e:	00 00 00 
  4032a1:	ff d0                	call   rax
	assert(slm_state_is_runnable(t->state));
  4032a3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4032aa:	00 00 00 00 
  4032ae:	0f 0b                	ud2    
		if (t == &g->sched_thd) {
  4032b0:	48 ba c8 5e 5a 00 00 	movabs rdx,0x5a5ec8
  4032b7:	00 00 00 
	timeout = g->timeout_next;
  4032ba:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  4032bd:	49 39 d4             	cmp    r12,rdx
  4032c0:	0f 84 c9 00 00 00    	je     40338f <sched_thd_block+0x3cf>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  4032c6:	a8 02                	test   al,0x2
  4032c8:	0f 85 d0 00 00 00    	jne    40339e <sched_thd_block+0x3de>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  4032ce:	49 89 c8             	mov    r8,rcx
  4032d1:	a8 01                	test   al,0x1
  4032d3:	0f 84 71 fe ff ff    	je     40314a <sched_thd_block+0x18a>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  4032d9:	4d 8b 54 24 08       	mov    r10,QWORD PTR [r12+0x8]
  4032de:	48 89 f2             	mov    rdx,rsi
  4032e1:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  4032e6:	45 89 f1             	mov    r9d,r14d
  4032e9:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  4032f0:	00 00 00 
  4032f3:	4c 8b 00             	mov    r8,QWORD PTR [rax]
  4032f6:	48 b8 f0 35 41 00 00 	movabs rax,0x4135f0
  4032fd:	00 00 00 
  403300:	4c 89 d6             	mov    rsi,r10
  403303:	ff d0                	call   rax
	if (unlikely(ret != 0)) {
  403305:	85 c0                	test   eax,eax
  403307:	0f 84 65 fe ff ff    	je     403172 <sched_thd_block+0x1b2>
		assert(ret != -EPERM);
  40330d:	83 f8 ff             	cmp    eax,0xffffffff
  403310:	0f 85 1e ff ff ff    	jne    403234 <sched_thd_block+0x274>
  403316:	48 bf 70 f3 41 00 00 	movabs rdi,0x41f370
  40331d:	00 00 00 
  403320:	be 61 00 00 00       	mov    esi,0x61
  403325:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40332c:	00 00 00 
  40332f:	ff d0                	call   rax
  403331:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403338:	00 00 00 00 
  40333c:	0f 0b                	ud2    
	return t != &g->idle_thd && t != &g->sched_thd;
  40333e:	48 b8 40 5f 5a 00 00 	movabs rax,0x5a5f40
  403345:	00 00 00 
  403348:	49 39 c4             	cmp    r12,rax
  40334b:	74 09                	je     403356 <sched_thd_block+0x396>
  40334d:	48 83 e8 78          	sub    rax,0x78
  403351:	49 39 c4             	cmp    r12,rax
  403354:	75 c0                	jne    403316 <sched_thd_block+0x356>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  403356:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  40335a:	45 89 f1             	mov    r9d,r14d
  40335d:	31 c9                	xor    ecx,ecx
  40335f:	31 f6                	xor    esi,esi
  403361:	48 8b 50 30          	mov    rdx,QWORD PTR [rax+0x30]
  403365:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  40336c:	00 00 00 
  40336f:	4c 8b 00             	mov    r8,QWORD PTR [rax]
  403372:	48 8b 78 f0          	mov    rdi,QWORD PTR [rax-0x10]
  403376:	48 b8 f0 35 41 00 00 	movabs rax,0x4135f0
  40337d:	00 00 00 
  403380:	ff d0                	call   rax
  403382:	eb 81                	jmp    403305 <sched_thd_block+0x345>
	if (dep_id) return -1;
  403384:	41 bd ff ff ff ff    	mov    r13d,0xffffffff
  40338a:	e9 e3 fd ff ff       	jmp    403172 <sched_thd_block+0x1b2>
			prio    = curr->priority;
  40338f:	48 8b 75 c8          	mov    rsi,QWORD PTR [rbp-0x38]
			timeout = TCAP_TIME_NIL;
  403393:	31 c9                	xor    ecx,ecx
			prio    = curr->priority;
  403395:	48 8b 76 30          	mov    rsi,QWORD PTR [rsi+0x30]
  403399:	e9 28 ff ff ff       	jmp    4032c6 <sched_thd_block+0x306>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  40339e:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  4033a5:	00 00 00 
  4033a8:	49 8b 7c 24 28       	mov    rdi,QWORD PTR [r12+0x28]
  4033ad:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  4033b0:	44 89 f1             	mov    ecx,r14d
  4033b3:	48 b8 60 36 41 00 00 	movabs rax,0x413660
  4033ba:	00 00 00 
  4033bd:	4c 89 c6             	mov    rsi,r8
  4033c0:	ff d0                	call   rax
  4033c2:	e9 3e ff ff ff       	jmp    403305 <sched_thd_block+0x345>
  4033c7:	48 bf d8 f3 41 00 00 	movabs rdi,0x41f3d8
  4033ce:	00 00 00 
  4033d1:	be 61 00 00 00       	mov    esi,0x61
  4033d6:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4033dd:	00 00 00 
  4033e0:	ff d0                	call   rax
		assert(ret != -EINVAL);
  4033e2:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4033e9:	00 00 00 00 
  4033ed:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  4033ef:	41 89 c0             	mov    r8d,eax
  4033f2:	48 8b 55 c8          	mov    rdx,QWORD PTR [rbp-0x38]
  4033f6:	48 89 c6             	mov    rsi,rax
  4033f9:	4c 89 ff             	mov    rdi,r15
  4033fc:	41 83 e0 01          	and    r8d,0x1
  403400:	41 ff d4             	call   r12
			assert(ret != -EBUSY);
  403403:	83 f8 f0             	cmp    eax,0xfffffff0
  403406:	0f 85 4d fe ff ff    	jne    403259 <sched_thd_block+0x299>
  40340c:	e9 fb fd ff ff       	jmp    40320c <sched_thd_block+0x24c>
  403411:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  403418:	48 bf 40 f4 41 00 00 	movabs rdi,0x41f440
  40341f:	00 00 00 
  403422:	be 61 00 00 00       	mov    esi,0x61
  403427:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40342e:	00 00 00 
  403431:	ff d0                	call   rax
		assert(ret == -EAGAIN);
  403433:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40343a:	00 00 00 00 
  40343e:	0f 0b                	ud2    
	ret = slm_thd_activate(curr, t, tok, 0);
  403440:	41 bd f0 ff ff ff    	mov    r13d,0xfffffff0
  403446:	e9 27 fd ff ff       	jmp    403172 <sched_thd_block+0x1b2>
  40344b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000403450 <thd_wakeup>:
{
  403450:	f3 0f 1e fa          	endbr64 
  403454:	55                   	push   rbp
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  403455:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  403458:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  40345e:	48 89 e5             	mov    rbp,rsp
  403461:	41 57                	push   r15
  403463:	41 56                	push   r14
  403465:	41 55                	push   r13
  403467:	41 54                	push   r12
  403469:	53                   	push   rbx
  40346a:	48 83 ec 08          	sub    rsp,0x8
  40346e:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403475:	48 85 c0             	test   rax,rax
  403478:	0f 84 da 01 00 00    	je     403658 <thd_wakeup+0x208>
  40347e:	83 e8 01             	sub    eax,0x1
  403481:	83 f8 18             	cmp    eax,0x18
  403484:	0f 87 ce 01 00 00    	ja     403658 <thd_wakeup+0x208>
  40348a:	48 ba 00 27 46 00 00 	movabs rdx,0x462700
  403491:	00 00 00 
  403494:	48 8b 0c c2          	mov    rcx,QWORD PTR [rdx+rax*8]
  403498:	48 f7 c1 fe ff ff ff 	test   rcx,0xfffffffffffffffe
  40349f:	0f 84 b3 01 00 00    	je     403658 <thd_wakeup+0x208>
  4034a5:	83 e1 01             	and    ecx,0x1
  4034a8:	0f 85 aa 01 00 00    	jne    403658 <thd_wakeup+0x208>
  4034ae:	48 8d 0c 80          	lea    rcx,[rax+rax*4]
  4034b2:	49 89 fc             	mov    r12,rdi
  4034b5:	48 bb d0 35 41 00 00 	movabs rbx,0x4135d0
  4034bc:	00 00 00 
  4034bf:	49 bf c0 5e 5a 00 00 	movabs r15,0x5a5ec0
  4034c6:	00 00 00 
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  4034c9:	49 be 50 5f 41 00 00 	movabs r14,0x415f50
  4034d0:	00 00 00 
  4034d3:	48 8d 04 48          	lea    rax,[rax+rcx*2]
  4034d7:	48 c1 e0 04          	shl    rax,0x4
  4034db:	4c 8d ac 02 c8 00 00 	lea    r13,[rdx+rax*1+0xc8]
  4034e2:	00 
		tok    = cos_sched_sync();
  4034e3:	ff d3                	call   rbx
  4034e5:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4034e8:	49 8b 07             	mov    rax,QWORD PTR [r15]
		if (unlikely(owner)) {
  4034eb:	48 89 c1             	mov    rcx,rax
  4034ee:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  4034f2:	0f 85 88 01 00 00    	jne    403680 <thd_wakeup+0x230>
  4034f8:	f0 4d 0f b1 2f       	lock cmpxchg QWORD PTR [r15],r13
  4034fd:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  403500:	84 c0                	test   al,al
  403502:	74 df                	je     4034e3 <thd_wakeup+0x93>
	ret = slm_thd_wakeup(t, 0);
  403504:	48 b8 c0 66 41 00 00 	movabs rax,0x4166c0
  40350b:	00 00 00 
  40350e:	31 f6                	xor    esi,esi
  403510:	4c 89 e7             	mov    rdi,r12
  403513:	ff d0                	call   rax
  403515:	41 89 c6             	mov    r14d,eax
	if (ret < 0) {
  403518:	85 c0                	test   eax,eax
  40351a:	0f 88 f0 00 00 00    	js     403610 <thd_wakeup+0x1c0>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  403520:	48 b8 10 ce 40 00 00 	movabs rax,0x40ce10
  403527:	00 00 00 
  40352a:	ff d0                	call   rax
	tok  = cos_sched_sync();
  40352c:	ff d3                	call   rbx
  40352e:	41 89 c6             	mov    r14d,eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  403531:	48 b8 50 48 41 00 00 	movabs rax,0x414850
  403538:	00 00 00 
  40353b:	ff d0                	call   rax
	if (unlikely(!t)) t = &g->idle_thd;
  40353d:	48 85 c0             	test   rax,rax
  403540:	49 89 c4             	mov    r12,rax
  403543:	48 b8 40 5f 5a 00 00 	movabs rax,0x5a5f40
  40354a:	00 00 00 
  40354d:	4c 0f 44 e0          	cmove  r12,rax
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  403551:	41 8b 44 24 04       	mov    eax,DWORD PTR [r12+0x4]
  403556:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  403559:	83 f8 01             	cmp    eax,0x1
  40355c:	76 16                	jbe    403574 <thd_wakeup+0x124>
  40355e:	e9 61 01 00 00       	jmp    4036c4 <thd_wakeup+0x274>
  403563:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  403568:	f0 49 0f b1 17       	lock cmpxchg QWORD PTR [r15],rdx
  40356d:	0f 94 c0             	sete   al
	while (ret != 0) {
  403570:	84 c0                	test   al,al
  403572:	75 2c                	jne    4035a0 <thd_wakeup+0x150>
		tok    = cos_sched_sync();
  403574:	ff d3                	call   rbx
  403576:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  403578:	49 8b 07             	mov    rax,QWORD PTR [r15]
		if (unlikely(contention)) {
  40357b:	48 89 c2             	mov    rdx,rax
  40357e:	83 e2 01             	and    edx,0x1
  403581:	74 e5                	je     403568 <thd_wakeup+0x118>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  403583:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  403586:	48 89 c2             	mov    rdx,rax
  403589:	4c 89 ff             	mov    rdi,r15
  40358c:	48 b8 b0 5f 41 00 00 	movabs rax,0x415fb0
  403593:	00 00 00 
  403596:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  40359a:	ff d0                	call   rax
  40359c:	85 c0                	test   eax,eax
  40359e:	75 d4                	jne    403574 <thd_wakeup+0x124>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  4035a0:	48 b8 10 ce 40 00 00 	movabs rax,0x40ce10
  4035a7:	00 00 00 
  4035aa:	ff d0                	call   rax
	prio = inherit_prio ? curr->priority : t->priority;
  4035ac:	49 8b 74 24 30       	mov    rsi,QWORD PTR [r12+0x30]
	timeout = g->timeout_next;
  4035b1:	48 b8 c8 5f 5a 00 00 	movabs rax,0x5a5fc8
  4035b8:	00 00 00 
  4035bb:	4c 8b 00             	mov    r8,QWORD PTR [rax]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4035be:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  4035c2:	a8 0b                	test   al,0xb
  4035c4:	0f 85 22 01 00 00    	jne    4036ec <thd_wakeup+0x29c>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  4035ca:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  4035cf:	44 89 f1             	mov    ecx,r14d
  4035d2:	4c 89 c2             	mov    rdx,r8
  4035d5:	48 b8 70 e1 40 00 00 	movabs rax,0x40e170
  4035dc:	00 00 00 
  4035df:	ff d0                	call   rax
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  4035e1:	83 f8 ff             	cmp    eax,0xffffffff
  4035e4:	0f 84 b6 01 00 00    	je     4037a0 <thd_wakeup+0x350>
	if (unlikely(ret != 0)) {
  4035ea:	85 c0                	test   eax,eax
  4035ec:	0f 85 5c 01 00 00    	jne    40374e <thd_wakeup+0x2fe>
  4035f2:	45 31 f6             	xor    r14d,r14d
}
  4035f5:	48 83 c4 08          	add    rsp,0x8
  4035f9:	44 89 f0             	mov    eax,r14d
  4035fc:	5b                   	pop    rbx
  4035fd:	41 5c                	pop    r12
  4035ff:	41 5d                	pop    r13
  403601:	41 5e                	pop    r14
  403603:	41 5f                	pop    r15
  403605:	5d                   	pop    rbp
  403606:	c3                   	ret    
  403607:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40360e:	00 00 
  403610:	49 bc b0 5f 41 00 00 	movabs r12,0x415fb0
  403617:	00 00 00 
  40361a:	eb 10                	jmp    40362c <thd_wakeup+0x1dc>
  40361c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  403620:	f0 49 0f b1 17       	lock cmpxchg QWORD PTR [r15],rdx
  403625:	0f 94 c0             	sete   al
	while (ret != 0) {
  403628:	84 c0                	test   al,al
  40362a:	75 c9                	jne    4035f5 <thd_wakeup+0x1a5>
		tok    = cos_sched_sync();
  40362c:	ff d3                	call   rbx
  40362e:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  403630:	49 8b 07             	mov    rax,QWORD PTR [r15]
		if (unlikely(contention)) {
  403633:	48 89 c2             	mov    rdx,rax
  403636:	83 e2 01             	and    edx,0x1
  403639:	74 e5                	je     403620 <thd_wakeup+0x1d0>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  40363b:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  40363e:	48 89 c2             	mov    rdx,rax
  403641:	4c 89 ff             	mov    rdi,r15
  403644:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  403648:	41 ff d4             	call   r12
  40364b:	85 c0                	test   eax,eax
  40364d:	74 a6                	je     4035f5 <thd_wakeup+0x1a5>
  40364f:	eb db                	jmp    40362c <thd_wakeup+0x1dc>
  403651:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  403658:	48 bf 20 f2 41 00 00 	movabs rdi,0x41f220
  40365f:	00 00 00 
  403662:	be 59 00 00 00       	mov    esi,0x59
  403667:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40366e:	00 00 00 
  403671:	ff d0                	call   rax
	assert(current);
  403673:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40367a:	00 00 00 00 
  40367e:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  403680:	41 89 c0             	mov    r8d,eax
  403683:	4c 89 ea             	mov    rdx,r13
  403686:	48 89 c6             	mov    rsi,rax
  403689:	4c 89 ff             	mov    rdi,r15
  40368c:	41 83 e0 01          	and    r8d,0x1
  403690:	41 ff d6             	call   r14
			assert(ret != -EBUSY);
  403693:	83 f8 f0             	cmp    eax,0xfffffff0
  403696:	0f 85 47 fe ff ff    	jne    4034e3 <thd_wakeup+0x93>
  40369c:	48 bf 80 f2 41 00 00 	movabs rdi,0x41f280
  4036a3:	00 00 00 
  4036a6:	be 59 00 00 00       	mov    esi,0x59
  4036ab:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4036b2:	00 00 00 
  4036b5:	ff d0                	call   rax
  4036b7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4036be:	00 00 00 00 
  4036c2:	0f 0b                	ud2    
  4036c4:	48 bf 08 f3 41 00 00 	movabs rdi,0x41f308
  4036cb:	00 00 00 
  4036ce:	be 61 00 00 00       	mov    esi,0x61
  4036d3:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4036da:	00 00 00 
  4036dd:	ff d0                	call   rax
	assert(slm_state_is_runnable(t->state));
  4036df:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4036e6:	00 00 00 00 
  4036ea:	0f 0b                	ud2    
		if (t == &g->sched_thd) {
  4036ec:	48 ba c8 5e 5a 00 00 	movabs rdx,0x5a5ec8
  4036f3:	00 00 00 
	timeout = g->timeout_next;
  4036f6:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  4036f9:	49 39 d4             	cmp    r12,rdx
  4036fc:	0f 84 de 00 00 00    	je     4037e0 <thd_wakeup+0x390>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  403702:	a8 02                	test   al,0x2
  403704:	0f 85 0e 01 00 00    	jne    403818 <thd_wakeup+0x3c8>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  40370a:	49 89 c8             	mov    r8,rcx
  40370d:	a8 01                	test   al,0x1
  40370f:	0f 84 b5 fe ff ff    	je     4035ca <thd_wakeup+0x17a>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  403715:	4d 8b 54 24 08       	mov    r10,QWORD PTR [r12+0x8]
  40371a:	48 89 f2             	mov    rdx,rsi
  40371d:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  403722:	45 89 f1             	mov    r9d,r14d
  403725:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  40372c:	00 00 00 
  40372f:	4c 8b 00             	mov    r8,QWORD PTR [rax]
  403732:	48 b8 f0 35 41 00 00 	movabs rax,0x4135f0
  403739:	00 00 00 
  40373c:	4c 89 d6             	mov    rsi,r10
  40373f:	ff d0                	call   rax
	if (unlikely(ret != 0)) {
  403741:	85 c0                	test   eax,eax
  403743:	0f 84 a9 fe ff ff    	je     4035f2 <thd_wakeup+0x1a2>
		assert(ret != -EPERM);
  403749:	83 f8 ff             	cmp    eax,0xffffffff
  40374c:	74 6a                	je     4037b8 <thd_wakeup+0x368>
		assert(ret != -EINVAL);
  40374e:	83 f8 ea             	cmp    eax,0xffffffea
  403751:	0f 84 ea 00 00 00    	je     403841 <thd_wakeup+0x3f1>
		if (ret == -EBUSY) return ret;
  403757:	83 f8 f0             	cmp    eax,0xfffffff0
  40375a:	0f 84 58 01 00 00    	je     4038b8 <thd_wakeup+0x468>
		assert(ret == -EAGAIN);
  403760:	83 f8 f5             	cmp    eax,0xfffffff5
  403763:	0f 85 27 01 00 00    	jne    403890 <thd_wakeup+0x440>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  403769:	49 bc 50 5f 41 00 00 	movabs r12,0x415f50
  403770:	00 00 00 
		tok    = cos_sched_sync();
  403773:	ff d3                	call   rbx
  403775:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  403778:	49 8b 07             	mov    rax,QWORD PTR [r15]
		if (unlikely(owner)) {
  40377b:	48 89 c1             	mov    rcx,rax
  40377e:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  403782:	0f 85 e1 00 00 00    	jne    403869 <thd_wakeup+0x419>
  403788:	f0 4d 0f b1 2f       	lock cmpxchg QWORD PTR [r15],r13
  40378d:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  403790:	84 c0                	test   al,al
  403792:	0f 85 94 fd ff ff    	jne    40352c <thd_wakeup+0xdc>
  403798:	eb d9                	jmp    403773 <thd_wakeup+0x323>
  40379a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	return t != &g->idle_thd && t != &g->sched_thd;
  4037a0:	48 b8 40 5f 5a 00 00 	movabs rax,0x5a5f40
  4037a7:	00 00 00 
  4037aa:	49 39 c4             	cmp    r12,rax
  4037ad:	74 3c                	je     4037eb <thd_wakeup+0x39b>
  4037af:	48 83 e8 78          	sub    rax,0x78
  4037b3:	49 39 c4             	cmp    r12,rax
  4037b6:	74 33                	je     4037eb <thd_wakeup+0x39b>
  4037b8:	48 bf 70 f3 41 00 00 	movabs rdi,0x41f370
  4037bf:	00 00 00 
  4037c2:	be 61 00 00 00       	mov    esi,0x61
  4037c7:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4037ce:	00 00 00 
  4037d1:	ff d0                	call   rax
		assert(ret != -EPERM);
  4037d3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4037da:	00 00 00 00 
  4037de:	0f 0b                	ud2    
			prio    = curr->priority;
  4037e0:	49 8b 75 30          	mov    rsi,QWORD PTR [r13+0x30]
			timeout = TCAP_TIME_NIL;
  4037e4:	31 c9                	xor    ecx,ecx
  4037e6:	e9 17 ff ff ff       	jmp    403702 <thd_wakeup+0x2b2>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  4037eb:	49 8b 55 30          	mov    rdx,QWORD PTR [r13+0x30]
  4037ef:	45 89 f1             	mov    r9d,r14d
  4037f2:	31 c9                	xor    ecx,ecx
  4037f4:	31 f6                	xor    esi,esi
  4037f6:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  4037fd:	00 00 00 
  403800:	4c 8b 00             	mov    r8,QWORD PTR [rax]
  403803:	48 8b 78 f0          	mov    rdi,QWORD PTR [rax-0x10]
  403807:	48 b8 f0 35 41 00 00 	movabs rax,0x4135f0
  40380e:	00 00 00 
  403811:	ff d0                	call   rax
  403813:	e9 29 ff ff ff       	jmp    403741 <thd_wakeup+0x2f1>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  403818:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  40381f:	00 00 00 
  403822:	49 8b 7c 24 28       	mov    rdi,QWORD PTR [r12+0x28]
  403827:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  40382a:	44 89 f1             	mov    ecx,r14d
  40382d:	48 b8 60 36 41 00 00 	movabs rax,0x413660
  403834:	00 00 00 
  403837:	4c 89 c6             	mov    rsi,r8
  40383a:	ff d0                	call   rax
  40383c:	e9 00 ff ff ff       	jmp    403741 <thd_wakeup+0x2f1>
  403841:	48 bf d8 f3 41 00 00 	movabs rdi,0x41f3d8
  403848:	00 00 00 
  40384b:	be 61 00 00 00       	mov    esi,0x61
  403850:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  403857:	00 00 00 
  40385a:	ff d0                	call   rax
		assert(ret != -EINVAL);
  40385c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403863:	00 00 00 00 
  403867:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  403869:	41 89 c0             	mov    r8d,eax
  40386c:	4c 89 ea             	mov    rdx,r13
  40386f:	48 89 c6             	mov    rsi,rax
  403872:	4c 89 ff             	mov    rdi,r15
  403875:	41 83 e0 01          	and    r8d,0x1
  403879:	41 ff d4             	call   r12
			assert(ret != -EBUSY);
  40387c:	83 f8 f0             	cmp    eax,0xfffffff0
  40387f:	0f 85 ee fe ff ff    	jne    403773 <thd_wakeup+0x323>
  403885:	e9 12 fe ff ff       	jmp    40369c <thd_wakeup+0x24c>
  40388a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  403890:	48 bf 40 f4 41 00 00 	movabs rdi,0x41f440
  403897:	00 00 00 
  40389a:	be 61 00 00 00       	mov    esi,0x61
  40389f:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4038a6:	00 00 00 
  4038a9:	ff d0                	call   rax
		assert(ret == -EAGAIN);
  4038ab:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4038b2:	00 00 00 00 
  4038b6:	0f 0b                	ud2    
  4038b8:	41 89 c6             	mov    r14d,eax
  4038bb:	e9 35 fd ff ff       	jmp    4035f5 <thd_wakeup+0x1a5>

00000000004038c0 <sched_thd_wakeup>:
{
  4038c0:	f3 0f 1e fa          	endbr64 
  4038c4:	55                   	push   rbp
  4038c5:	48 89 e5             	mov    rbp,rsp
  4038c8:	41 57                	push   r15
  4038ca:	41 56                	push   r14
  4038cc:	41 55                	push   r13
  4038ce:	41 54                	push   r12
  4038d0:	53                   	push   rbx
  4038d1:	48 83 ec 08          	sub    rsp,0x8
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  4038d5:	85 ff                	test   edi,edi
  4038d7:	74 21                	je     4038fa <sched_thd_wakeup+0x3a>
  4038d9:	83 ef 01             	sub    edi,0x1
  4038dc:	83 ff 18             	cmp    edi,0x18
  4038df:	77 19                	ja     4038fa <sched_thd_wakeup+0x3a>
  4038e1:	48 ba 00 27 46 00 00 	movabs rdx,0x462700
  4038e8:	00 00 00 
  4038eb:	89 f8                	mov    eax,edi
  4038ed:	48 8b 0c c2          	mov    rcx,QWORD PTR [rdx+rax*8]
  4038f1:	48 f7 c1 fe ff ff ff 	test   rcx,0xfffffffffffffffe
  4038f8:	75 1e                	jne    403918 <sched_thd_wakeup+0x58>
	if (!t) return -1;
  4038fa:	41 be ff ff ff ff    	mov    r14d,0xffffffff
}
  403900:	48 83 c4 08          	add    rsp,0x8
  403904:	44 89 f0             	mov    eax,r14d
  403907:	5b                   	pop    rbx
  403908:	41 5c                	pop    r12
  40390a:	41 5d                	pop    r13
  40390c:	41 5e                	pop    r14
  40390e:	41 5f                	pop    r15
  403910:	5d                   	pop    rbp
  403911:	c3                   	ret    
  403912:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  403918:	83 e1 01             	and    ecx,0x1
  40391b:	75 dd                	jne    4038fa <sched_thd_wakeup+0x3a>
	return &ss_thd_get(id)->thd;
  40391d:	48 8d 0c 80          	lea    rcx,[rax+rax*4]
  403921:	48 8d 04 48          	lea    rax,[rax+rcx*2]
  403925:	48 c1 e0 04          	shl    rax,0x4
  403929:	4c 8d a4 02 c8 00 00 	lea    r12,[rdx+rax*1+0xc8]
  403930:	00 
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  403931:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  403934:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  40393a:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403941:	48 85 c0             	test   rax,rax
  403944:	74 15                	je     40395b <sched_thd_wakeup+0x9b>
  403946:	83 e8 01             	sub    eax,0x1
  403949:	83 f8 18             	cmp    eax,0x18
  40394c:	77 0d                	ja     40395b <sched_thd_wakeup+0x9b>
  40394e:	48 8b 0c c2          	mov    rcx,QWORD PTR [rdx+rax*8]
  403952:	48 f7 c1 fe ff ff ff 	test   rcx,0xfffffffffffffffe
  403959:	75 2d                	jne    403988 <sched_thd_wakeup+0xc8>
  40395b:	48 bf 20 f2 41 00 00 	movabs rdi,0x41f220
  403962:	00 00 00 
  403965:	be 59 00 00 00       	mov    esi,0x59
  40396a:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  403971:	00 00 00 
  403974:	ff d0                	call   rax
	assert(current);
  403976:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40397d:	00 00 00 00 
  403981:	0f 0b                	ud2    
  403983:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  403988:	83 e1 01             	and    ecx,0x1
  40398b:	75 ce                	jne    40395b <sched_thd_wakeup+0x9b>
  40398d:	48 bb d0 35 41 00 00 	movabs rbx,0x4135d0
  403994:	00 00 00 
  403997:	48 8d 0c 80          	lea    rcx,[rax+rax*4]
  40399b:	49 bf c0 5e 5a 00 00 	movabs r15,0x5a5ec0
  4039a2:	00 00 00 
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  4039a5:	49 be 50 5f 41 00 00 	movabs r14,0x415f50
  4039ac:	00 00 00 
  4039af:	48 8d 04 48          	lea    rax,[rax+rcx*2]
  4039b3:	48 c1 e0 04          	shl    rax,0x4
  4039b7:	4c 8d ac 02 c8 00 00 	lea    r13,[rdx+rax*1+0xc8]
  4039be:	00 
		tok    = cos_sched_sync();
  4039bf:	ff d3                	call   rbx
  4039c1:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4039c4:	49 8b 07             	mov    rax,QWORD PTR [r15]
		if (unlikely(owner)) {
  4039c7:	48 89 c1             	mov    rcx,rax
  4039ca:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  4039ce:	0f 85 54 01 00 00    	jne    403b28 <sched_thd_wakeup+0x268>
  4039d4:	f0 4d 0f b1 2f       	lock cmpxchg QWORD PTR [r15],r13
  4039d9:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4039dc:	84 c0                	test   al,al
  4039de:	74 df                	je     4039bf <sched_thd_wakeup+0xff>
	ret = slm_thd_wakeup(t, 0);
  4039e0:	48 b8 c0 66 41 00 00 	movabs rax,0x4166c0
  4039e7:	00 00 00 
  4039ea:	31 f6                	xor    esi,esi
  4039ec:	4c 89 e7             	mov    rdi,r12
  4039ef:	ff d0                	call   rax
  4039f1:	41 89 c6             	mov    r14d,eax
	if (ret < 0) {
  4039f4:	85 c0                	test   eax,eax
  4039f6:	0f 88 dc 00 00 00    	js     403ad8 <sched_thd_wakeup+0x218>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  4039fc:	48 b8 10 ce 40 00 00 	movabs rax,0x40ce10
  403a03:	00 00 00 
  403a06:	ff d0                	call   rax
	tok  = cos_sched_sync();
  403a08:	ff d3                	call   rbx
  403a0a:	41 89 c6             	mov    r14d,eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  403a0d:	48 b8 50 48 41 00 00 	movabs rax,0x414850
  403a14:	00 00 00 
  403a17:	ff d0                	call   rax
	if (unlikely(!t)) t = &g->idle_thd;
  403a19:	48 85 c0             	test   rax,rax
  403a1c:	49 89 c4             	mov    r12,rax
  403a1f:	48 b8 40 5f 5a 00 00 	movabs rax,0x5a5f40
  403a26:	00 00 00 
  403a29:	4c 0f 44 e0          	cmove  r12,rax
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  403a2d:	41 8b 44 24 04       	mov    eax,DWORD PTR [r12+0x4]
  403a32:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  403a35:	83 f8 01             	cmp    eax,0x1
  403a38:	76 12                	jbe    403a4c <sched_thd_wakeup+0x18c>
  403a3a:	e9 2d 01 00 00       	jmp    403b6c <sched_thd_wakeup+0x2ac>
  403a3f:	90                   	nop
  403a40:	f0 49 0f b1 17       	lock cmpxchg QWORD PTR [r15],rdx
  403a45:	0f 94 c0             	sete   al
	while (ret != 0) {
  403a48:	84 c0                	test   al,al
  403a4a:	75 2c                	jne    403a78 <sched_thd_wakeup+0x1b8>
		tok    = cos_sched_sync();
  403a4c:	ff d3                	call   rbx
  403a4e:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  403a50:	49 8b 07             	mov    rax,QWORD PTR [r15]
		if (unlikely(contention)) {
  403a53:	48 89 c2             	mov    rdx,rax
  403a56:	83 e2 01             	and    edx,0x1
  403a59:	74 e5                	je     403a40 <sched_thd_wakeup+0x180>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  403a5b:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  403a5e:	48 89 c2             	mov    rdx,rax
  403a61:	4c 89 ff             	mov    rdi,r15
  403a64:	48 b8 b0 5f 41 00 00 	movabs rax,0x415fb0
  403a6b:	00 00 00 
  403a6e:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  403a72:	ff d0                	call   rax
  403a74:	85 c0                	test   eax,eax
  403a76:	75 d4                	jne    403a4c <sched_thd_wakeup+0x18c>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  403a78:	48 b8 10 ce 40 00 00 	movabs rax,0x40ce10
  403a7f:	00 00 00 
  403a82:	ff d0                	call   rax
	prio = inherit_prio ? curr->priority : t->priority;
  403a84:	49 8b 74 24 30       	mov    rsi,QWORD PTR [r12+0x30]
	timeout = g->timeout_next;
  403a89:	48 b8 c8 5f 5a 00 00 	movabs rax,0x5a5fc8
  403a90:	00 00 00 
  403a93:	4c 8b 00             	mov    r8,QWORD PTR [rax]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  403a96:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  403a9a:	a8 0b                	test   al,0xb
  403a9c:	0f 85 f2 00 00 00    	jne    403b94 <sched_thd_wakeup+0x2d4>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  403aa2:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  403aa7:	44 89 f1             	mov    ecx,r14d
  403aaa:	4c 89 c2             	mov    rdx,r8
  403aad:	48 b8 70 e1 40 00 00 	movabs rax,0x40e170
  403ab4:	00 00 00 
  403ab7:	ff d0                	call   rax
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  403ab9:	83 f8 ff             	cmp    eax,0xffffffff
  403abc:	0f 84 86 01 00 00    	je     403c48 <sched_thd_wakeup+0x388>
	if (unlikely(ret != 0)) {
  403ac2:	85 c0                	test   eax,eax
  403ac4:	0f 85 2c 01 00 00    	jne    403bf6 <sched_thd_wakeup+0x336>
	if (!t) return -1;
  403aca:	45 31 f6             	xor    r14d,r14d
  403acd:	e9 2e fe ff ff       	jmp    403900 <sched_thd_wakeup+0x40>
  403ad2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  403ad8:	49 bc b0 5f 41 00 00 	movabs r12,0x415fb0
  403adf:	00 00 00 
  403ae2:	eb 14                	jmp    403af8 <sched_thd_wakeup+0x238>
  403ae4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  403ae8:	f0 49 0f b1 17       	lock cmpxchg QWORD PTR [r15],rdx
  403aed:	0f 94 c0             	sete   al
	while (ret != 0) {
  403af0:	84 c0                	test   al,al
  403af2:	0f 85 08 fe ff ff    	jne    403900 <sched_thd_wakeup+0x40>
		tok    = cos_sched_sync();
  403af8:	ff d3                	call   rbx
  403afa:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  403afc:	49 8b 07             	mov    rax,QWORD PTR [r15]
		if (unlikely(contention)) {
  403aff:	48 89 c2             	mov    rdx,rax
  403b02:	83 e2 01             	and    edx,0x1
  403b05:	74 e1                	je     403ae8 <sched_thd_wakeup+0x228>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  403b07:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  403b0a:	48 89 c2             	mov    rdx,rax
  403b0d:	4c 89 ff             	mov    rdi,r15
  403b10:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  403b14:	41 ff d4             	call   r12
  403b17:	85 c0                	test   eax,eax
  403b19:	0f 84 e1 fd ff ff    	je     403900 <sched_thd_wakeup+0x40>
  403b1f:	eb d7                	jmp    403af8 <sched_thd_wakeup+0x238>
  403b21:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  403b28:	41 89 c0             	mov    r8d,eax
  403b2b:	4c 89 ea             	mov    rdx,r13
  403b2e:	48 89 c6             	mov    rsi,rax
  403b31:	4c 89 ff             	mov    rdi,r15
  403b34:	41 83 e0 01          	and    r8d,0x1
  403b38:	41 ff d6             	call   r14
			assert(ret != -EBUSY);
  403b3b:	83 f8 f0             	cmp    eax,0xfffffff0
  403b3e:	0f 85 7b fe ff ff    	jne    4039bf <sched_thd_wakeup+0xff>
  403b44:	48 bf 80 f2 41 00 00 	movabs rdi,0x41f280
  403b4b:	00 00 00 
  403b4e:	be 59 00 00 00       	mov    esi,0x59
  403b53:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  403b5a:	00 00 00 
  403b5d:	ff d0                	call   rax
  403b5f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403b66:	00 00 00 00 
  403b6a:	0f 0b                	ud2    
  403b6c:	48 bf 08 f3 41 00 00 	movabs rdi,0x41f308
  403b73:	00 00 00 
  403b76:	be 61 00 00 00       	mov    esi,0x61
  403b7b:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  403b82:	00 00 00 
  403b85:	ff d0                	call   rax
	assert(slm_state_is_runnable(t->state));
  403b87:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403b8e:	00 00 00 00 
  403b92:	0f 0b                	ud2    
		if (t == &g->sched_thd) {
  403b94:	48 ba c8 5e 5a 00 00 	movabs rdx,0x5a5ec8
  403b9b:	00 00 00 
	timeout = g->timeout_next;
  403b9e:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  403ba1:	49 39 d4             	cmp    r12,rdx
  403ba4:	0f 84 de 00 00 00    	je     403c88 <sched_thd_wakeup+0x3c8>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  403baa:	a8 02                	test   al,0x2
  403bac:	0f 85 0e 01 00 00    	jne    403cc0 <sched_thd_wakeup+0x400>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  403bb2:	49 89 c8             	mov    r8,rcx
  403bb5:	a8 01                	test   al,0x1
  403bb7:	0f 84 e5 fe ff ff    	je     403aa2 <sched_thd_wakeup+0x1e2>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  403bbd:	4d 8b 54 24 08       	mov    r10,QWORD PTR [r12+0x8]
  403bc2:	48 89 f2             	mov    rdx,rsi
  403bc5:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  403bca:	45 89 f1             	mov    r9d,r14d
  403bcd:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  403bd4:	00 00 00 
  403bd7:	4c 8b 00             	mov    r8,QWORD PTR [rax]
  403bda:	48 b8 f0 35 41 00 00 	movabs rax,0x4135f0
  403be1:	00 00 00 
  403be4:	4c 89 d6             	mov    rsi,r10
  403be7:	ff d0                	call   rax
	if (unlikely(ret != 0)) {
  403be9:	85 c0                	test   eax,eax
  403beb:	0f 84 d9 fe ff ff    	je     403aca <sched_thd_wakeup+0x20a>
		assert(ret != -EPERM);
  403bf1:	83 f8 ff             	cmp    eax,0xffffffff
  403bf4:	74 6a                	je     403c60 <sched_thd_wakeup+0x3a0>
		assert(ret != -EINVAL);
  403bf6:	83 f8 ea             	cmp    eax,0xffffffea
  403bf9:	0f 84 ea 00 00 00    	je     403ce9 <sched_thd_wakeup+0x429>
		if (ret == -EBUSY) return ret;
  403bff:	83 f8 f0             	cmp    eax,0xfffffff0
  403c02:	0f 84 58 01 00 00    	je     403d60 <sched_thd_wakeup+0x4a0>
		assert(ret == -EAGAIN);
  403c08:	83 f8 f5             	cmp    eax,0xfffffff5
  403c0b:	0f 85 27 01 00 00    	jne    403d38 <sched_thd_wakeup+0x478>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  403c11:	49 bc 50 5f 41 00 00 	movabs r12,0x415f50
  403c18:	00 00 00 
		tok    = cos_sched_sync();
  403c1b:	ff d3                	call   rbx
  403c1d:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  403c20:	49 8b 07             	mov    rax,QWORD PTR [r15]
		if (unlikely(owner)) {
  403c23:	48 89 c1             	mov    rcx,rax
  403c26:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  403c2a:	0f 85 e1 00 00 00    	jne    403d11 <sched_thd_wakeup+0x451>
  403c30:	f0 4d 0f b1 2f       	lock cmpxchg QWORD PTR [r15],r13
  403c35:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  403c38:	84 c0                	test   al,al
  403c3a:	0f 85 c8 fd ff ff    	jne    403a08 <sched_thd_wakeup+0x148>
  403c40:	eb d9                	jmp    403c1b <sched_thd_wakeup+0x35b>
  403c42:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	return t != &g->idle_thd && t != &g->sched_thd;
  403c48:	48 b8 40 5f 5a 00 00 	movabs rax,0x5a5f40
  403c4f:	00 00 00 
  403c52:	49 39 c4             	cmp    r12,rax
  403c55:	74 3c                	je     403c93 <sched_thd_wakeup+0x3d3>
  403c57:	48 83 e8 78          	sub    rax,0x78
  403c5b:	49 39 c4             	cmp    r12,rax
  403c5e:	74 33                	je     403c93 <sched_thd_wakeup+0x3d3>
  403c60:	48 bf 70 f3 41 00 00 	movabs rdi,0x41f370
  403c67:	00 00 00 
  403c6a:	be 61 00 00 00       	mov    esi,0x61
  403c6f:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  403c76:	00 00 00 
  403c79:	ff d0                	call   rax
		assert(ret != -EPERM);
  403c7b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403c82:	00 00 00 00 
  403c86:	0f 0b                	ud2    
			prio    = curr->priority;
  403c88:	49 8b 75 30          	mov    rsi,QWORD PTR [r13+0x30]
			timeout = TCAP_TIME_NIL;
  403c8c:	31 c9                	xor    ecx,ecx
  403c8e:	e9 17 ff ff ff       	jmp    403baa <sched_thd_wakeup+0x2ea>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  403c93:	49 8b 55 30          	mov    rdx,QWORD PTR [r13+0x30]
  403c97:	45 89 f1             	mov    r9d,r14d
  403c9a:	31 c9                	xor    ecx,ecx
  403c9c:	31 f6                	xor    esi,esi
  403c9e:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  403ca5:	00 00 00 
  403ca8:	4c 8b 00             	mov    r8,QWORD PTR [rax]
  403cab:	48 8b 78 f0          	mov    rdi,QWORD PTR [rax-0x10]
  403caf:	48 b8 f0 35 41 00 00 	movabs rax,0x4135f0
  403cb6:	00 00 00 
  403cb9:	ff d0                	call   rax
  403cbb:	e9 29 ff ff ff       	jmp    403be9 <sched_thd_wakeup+0x329>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  403cc0:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  403cc7:	00 00 00 
  403cca:	49 8b 7c 24 28       	mov    rdi,QWORD PTR [r12+0x28]
  403ccf:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  403cd2:	44 89 f1             	mov    ecx,r14d
  403cd5:	48 b8 60 36 41 00 00 	movabs rax,0x413660
  403cdc:	00 00 00 
  403cdf:	4c 89 c6             	mov    rsi,r8
  403ce2:	ff d0                	call   rax
  403ce4:	e9 00 ff ff ff       	jmp    403be9 <sched_thd_wakeup+0x329>
  403ce9:	48 bf d8 f3 41 00 00 	movabs rdi,0x41f3d8
  403cf0:	00 00 00 
  403cf3:	be 61 00 00 00       	mov    esi,0x61
  403cf8:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  403cff:	00 00 00 
  403d02:	ff d0                	call   rax
		assert(ret != -EINVAL);
  403d04:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403d0b:	00 00 00 00 
  403d0f:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  403d11:	41 89 c0             	mov    r8d,eax
  403d14:	4c 89 ea             	mov    rdx,r13
  403d17:	48 89 c6             	mov    rsi,rax
  403d1a:	4c 89 ff             	mov    rdi,r15
  403d1d:	41 83 e0 01          	and    r8d,0x1
  403d21:	41 ff d4             	call   r12
			assert(ret != -EBUSY);
  403d24:	83 f8 f0             	cmp    eax,0xfffffff0
  403d27:	0f 85 ee fe ff ff    	jne    403c1b <sched_thd_wakeup+0x35b>
  403d2d:	e9 12 fe ff ff       	jmp    403b44 <sched_thd_wakeup+0x284>
  403d32:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  403d38:	48 bf 40 f4 41 00 00 	movabs rdi,0x41f440
  403d3f:	00 00 00 
  403d42:	be 61 00 00 00       	mov    esi,0x61
  403d47:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  403d4e:	00 00 00 
  403d51:	ff d0                	call   rax
		assert(ret == -EAGAIN);
  403d53:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403d5a:	00 00 00 00 
  403d5e:	0f 0b                	ud2    
  403d60:	41 89 c6             	mov    r14d,eax
  403d63:	e9 98 fb ff ff       	jmp    403900 <sched_thd_wakeup+0x40>
  403d68:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  403d6f:	00 

0000000000403d70 <sched_debug_thd_state>:
{
  403d70:	f3 0f 1e fa          	endbr64 
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403d74:	85 ff                	test   edi,edi
  403d76:	0f 84 ae 3b 01 00    	je     41792a <sched_debug_thd_state.cold>
  403d7c:	83 ef 01             	sub    edi,0x1
  403d7f:	83 ff 18             	cmp    edi,0x18
  403d82:	0f 87 a2 3b 01 00    	ja     41792a <sched_debug_thd_state.cold>
  403d88:	48 b8 00 27 46 00 00 	movabs rax,0x462700
  403d8f:	00 00 00 
  403d92:	48 8b 04 f8          	mov    rax,QWORD PTR [rax+rdi*8]
  403d96:	48 a9 fe ff ff ff    	test   rax,0xfffffffffffffffe
  403d9c:	0f 84 88 3b 01 00    	je     41792a <sched_debug_thd_state.cold>
  403da2:	a8 01                	test   al,0x1
  403da4:	0f 85 80 3b 01 00    	jne    41792a <sched_debug_thd_state.cold>
	return t->state;
  403daa:	48 ba c8 27 46 00 00 	movabs rdx,0x4627c8
  403db1:	00 00 00 
  403db4:	48 8d 04 bf          	lea    rax,[rdi+rdi*4]
  403db8:	48 8d 04 47          	lea    rax,[rdi+rax*2]
  403dbc:	48 c1 e0 04          	shl    rax,0x4
  403dc0:	8b 44 02 04          	mov    eax,DWORD PTR [rdx+rax*1+0x4]
}
  403dc4:	c3                   	ret    
  403dc5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  403dcc:	00 00 00 00 

0000000000403dd0 <sched_thd_block_timeout>:
{
  403dd0:	f3 0f 1e fa          	endbr64 
	if (dep_id) return 0;
  403dd4:	48 85 ff             	test   rdi,rdi
  403dd7:	74 07                	je     403de0 <sched_thd_block_timeout+0x10>
  403dd9:	31 c0                	xor    eax,eax
}
  403ddb:	c3                   	ret    
  403ddc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
{
  403de0:	55                   	push   rbp
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  403de1:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  403de4:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  403dea:	48 89 e5             	mov    rbp,rsp
  403ded:	41 57                	push   r15
  403def:	41 56                	push   r14
  403df1:	49 89 f6             	mov    r14,rsi
  403df4:	41 55                	push   r13
  403df6:	41 54                	push   r12
  403df8:	53                   	push   rbx
  403df9:	48 83 ec 18          	sub    rsp,0x18
  403dfd:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403e04:	48 85 c0             	test   rax,rax
  403e07:	0f 84 0b 02 00 00    	je     404018 <sched_thd_block_timeout+0x248>
  403e0d:	83 e8 01             	sub    eax,0x1
  403e10:	83 f8 18             	cmp    eax,0x18
  403e13:	0f 87 ff 01 00 00    	ja     404018 <sched_thd_block_timeout+0x248>
  403e19:	48 b9 00 27 46 00 00 	movabs rcx,0x462700
  403e20:	00 00 00 
  403e23:	45 31 ed             	xor    r13d,r13d
  403e26:	48 8b 14 c1          	mov    rdx,QWORD PTR [rcx+rax*8]
  403e2a:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  403e31:	0f 85 a1 01 00 00    	jne    403fd8 <sched_thd_block_timeout+0x208>
static inline ps_tsc_t
ps_tsc(void)
{
	unsigned long a, d, c;

	__asm__ __volatile__("rdtsc" : "=a" (a), "=d" (d), "=c" (c) : : );
  403e37:	0f 31                	rdtsc  

	return ((u64_t)d << 32) | (u64_t)a;
  403e39:	48 c1 e2 20          	shl    rdx,0x20
  403e3d:	48 09 c2             	or     rdx,rax
 * more than 2^63 into the future.
 */
static inline int
cycles_greater_than(cycles_t g, cycles_t l)
{
	return (s64_t)(g - l) > 0;
  403e40:	4c 89 f0             	mov    rax,r14
  403e43:	48 29 d0             	sub    rax,rdx
	while (cycles_greater_than(timeout, slm_now())) {
  403e46:	48 85 c0             	test   rax,rax
  403e49:	0f 8e 19 03 00 00    	jle    404168 <sched_thd_block_timeout+0x398>
	assert(current);
  403e4f:	49 bc d0 35 41 00 00 	movabs r12,0x4135d0
  403e56:	00 00 00 
  403e59:	49 bf c0 5e 5a 00 00 	movabs r15,0x5a5ec0
  403e60:	00 00 00 
  403e63:	4d 85 ed             	test   r13,r13
  403e66:	0f 84 01 02 00 00    	je     40406d <sched_thd_block_timeout+0x29d>
		tok    = cos_sched_sync();
  403e6c:	41 ff d4             	call   r12
  403e6f:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  403e72:	49 8b 07             	mov    rax,QWORD PTR [r15]
		if (unlikely(owner)) {
  403e75:	48 89 c1             	mov    rcx,rax
  403e78:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  403e7c:	0f 85 9e 01 00 00    	jne    404020 <sched_thd_block_timeout+0x250>
        __asm__ __volatile__("lock " PS_CAS_STR
  403e82:	f0 4d 0f b1 2f       	lock cmpxchg QWORD PTR [r15],r13
  403e87:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  403e8a:	84 c0                	test   al,al
  403e8c:	74 de                	je     403e6c <sched_thd_block_timeout+0x9c>
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  403e8e:	48 b8 50 51 41 00 00 	movabs rax,0x415150
  403e95:	00 00 00 
  403e98:	4c 89 f6             	mov    rsi,r14
  403e9b:	4c 89 ef             	mov    rdi,r13
  403e9e:	ff d0                	call   rax
		if (slm_timer_add(current, timeout)) goto done;
  403ea0:	85 c0                	test   eax,eax
  403ea2:	75 17                	jne    403ebb <sched_thd_block_timeout+0xeb>
		if (slm_thd_block(current)) {
  403ea4:	48 b8 30 60 41 00 00 	movabs rax,0x416030
  403eab:	00 00 00 
  403eae:	4c 89 ef             	mov    rdi,r13
  403eb1:	ff d0                	call   rax
  403eb3:	85 c0                	test   eax,eax
  403eb5:	0f 85 45 01 00 00    	jne    404000 <sched_thd_block_timeout+0x230>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  403ebb:	48 b8 10 ce 40 00 00 	movabs rax,0x40ce10
  403ec2:	00 00 00 
  403ec5:	ff d0                	call   rax
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  403ec7:	4c 89 75 c8          	mov    QWORD PTR [rbp-0x38],r14
	tok  = cos_sched_sync();
  403ecb:	41 ff d4             	call   r12
  403ece:	41 89 c6             	mov    r14d,eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  403ed1:	48 b8 50 48 41 00 00 	movabs rax,0x414850
  403ed8:	00 00 00 
  403edb:	ff d0                	call   rax
	if (unlikely(!t)) t = &g->idle_thd;
  403edd:	48 85 c0             	test   rax,rax
  403ee0:	48 89 c3             	mov    rbx,rax
  403ee3:	48 b8 40 5f 5a 00 00 	movabs rax,0x5a5f40
  403eea:	00 00 00 
  403eed:	48 0f 44 d8          	cmove  rbx,rax
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  403ef1:	8b 43 04             	mov    eax,DWORD PTR [rbx+0x4]
  403ef4:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  403ef7:	83 f8 01             	cmp    eax,0x1
  403efa:	76 18                	jbe    403f14 <sched_thd_block_timeout+0x144>
  403efc:	e9 94 01 00 00       	jmp    404095 <sched_thd_block_timeout+0x2c5>
  403f01:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  403f08:	f0 49 0f b1 17       	lock cmpxchg QWORD PTR [r15],rdx
  403f0d:	0f 94 c0             	sete   al
	while (ret != 0) {
  403f10:	84 c0                	test   al,al
  403f12:	75 2d                	jne    403f41 <sched_thd_block_timeout+0x171>
		tok    = cos_sched_sync();
  403f14:	41 ff d4             	call   r12
  403f17:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  403f19:	49 8b 07             	mov    rax,QWORD PTR [r15]
		if (unlikely(contention)) {
  403f1c:	48 89 c2             	mov    rdx,rax
  403f1f:	83 e2 01             	and    edx,0x1
  403f22:	74 e4                	je     403f08 <sched_thd_block_timeout+0x138>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  403f24:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  403f27:	48 89 c2             	mov    rdx,rax
  403f2a:	4c 89 ff             	mov    rdi,r15
  403f2d:	48 b8 b0 5f 41 00 00 	movabs rax,0x415fb0
  403f34:	00 00 00 
  403f37:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  403f3b:	ff d0                	call   rax
  403f3d:	85 c0                	test   eax,eax
  403f3f:	75 d3                	jne    403f14 <sched_thd_block_timeout+0x144>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  403f41:	48 b8 10 ce 40 00 00 	movabs rax,0x40ce10
  403f48:	00 00 00 
  403f4b:	ff d0                	call   rax
	prio = inherit_prio ? curr->priority : t->priority;
  403f4d:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
	timeout = g->timeout_next;
  403f51:	48 b8 c8 5f 5a 00 00 	movabs rax,0x5a5fc8
  403f58:	00 00 00 
  403f5b:	4c 8b 00             	mov    r8,QWORD PTR [rax]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  403f5e:	8b 03                	mov    eax,DWORD PTR [rbx]
  403f60:	a8 0b                	test   al,0xb
  403f62:	0f 85 55 01 00 00    	jne    4040bd <sched_thd_block_timeout+0x2ed>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  403f68:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  403f6c:	44 89 f1             	mov    ecx,r14d
  403f6f:	4c 89 c2             	mov    rdx,r8
  403f72:	48 b8 70 e1 40 00 00 	movabs rax,0x40e170
  403f79:	00 00 00 
  403f7c:	ff d0                	call   rax
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  403f7e:	83 f8 ff             	cmp    eax,0xffffffff
  403f81:	0f 84 29 02 00 00    	je     4041b0 <sched_thd_block_timeout+0x3e0>
	if (unlikely(ret != 0)) {
  403f87:	85 c0                	test   eax,eax
  403f89:	0f 85 92 01 00 00    	jne    404121 <sched_thd_block_timeout+0x351>
  403f8f:	4c 8b 75 c8          	mov    r14,QWORD PTR [rbp-0x38]
  403f93:	31 db                	xor    ebx,ebx
  403f95:	48 b8 10 52 41 00 00 	movabs rax,0x415210
  403f9c:	00 00 00 
  403f9f:	4c 89 ef             	mov    rdi,r13
  403fa2:	ff d0                	call   rax
	__asm__ __volatile__("rdtsc" : "=a" (a), "=d" (d), "=c" (c) : : );
  403fa4:	0f 31                	rdtsc  
	return ((u64_t)d << 32) | (u64_t)a;
  403fa6:	48 c1 e2 20          	shl    rdx,0x20
  403faa:	48 09 c2             	or     rdx,rax
  403fad:	4c 89 f0             	mov    rax,r14
  403fb0:	48 29 d0             	sub    rax,rdx
	while (cycles_greater_than(timeout, slm_now())) {
  403fb3:	48 85 c0             	test   rax,rax
  403fb6:	0f 8f b0 fe ff ff    	jg     403e6c <sched_thd_block_timeout+0x9c>
	if (dep_id) return 0;
  403fbc:	31 c0                	xor    eax,eax
	if (thd_block_until(abs_timeout)) return 0;
  403fbe:	85 db                	test   ebx,ebx
  403fc0:	0f 84 a2 01 00 00    	je     404168 <sched_thd_block_timeout+0x398>
}
  403fc6:	48 83 c4 18          	add    rsp,0x18
  403fca:	5b                   	pop    rbx
  403fcb:	41 5c                	pop    r12
  403fcd:	41 5d                	pop    r13
  403fcf:	41 5e                	pop    r14
  403fd1:	41 5f                	pop    r15
  403fd3:	5d                   	pop    rbp
  403fd4:	c3                   	ret    
  403fd5:	0f 1f 00             	nop    DWORD PTR [rax]
  403fd8:	83 e2 01             	and    edx,0x1
  403fdb:	0f 85 56 fe ff ff    	jne    403e37 <sched_thd_block_timeout+0x67>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403fe1:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  403fe5:	48 8d 04 50          	lea    rax,[rax+rdx*2]
  403fe9:	48 c1 e0 04          	shl    rax,0x4
  403fed:	4c 8d ac 01 c8 00 00 	lea    r13,[rcx+rax*1+0xc8]
  403ff4:	00 
  403ff5:	e9 3d fe ff ff       	jmp    403e37 <sched_thd_block_timeout+0x67>
  403ffa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  404000:	48 b8 10 52 41 00 00 	movabs rax,0x415210
  404007:	00 00 00 
  40400a:	4c 89 ef             	mov    rdi,r13
  40400d:	ff d0                	call   rax
  40400f:	e9 a7 fe ff ff       	jmp    403ebb <sched_thd_block_timeout+0xeb>
  404014:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  404018:	45 31 ed             	xor    r13d,r13d
  40401b:	e9 17 fe ff ff       	jmp    403e37 <sched_thd_block_timeout+0x67>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  404020:	41 89 c0             	mov    r8d,eax
  404023:	48 89 c6             	mov    rsi,rax
  404026:	4c 89 ea             	mov    rdx,r13
  404029:	4c 89 ff             	mov    rdi,r15
  40402c:	48 b8 50 5f 41 00 00 	movabs rax,0x415f50
  404033:	00 00 00 
  404036:	41 83 e0 01          	and    r8d,0x1
  40403a:	ff d0                	call   rax
			assert(ret != -EBUSY);
  40403c:	83 f8 f0             	cmp    eax,0xfffffff0
  40403f:	0f 85 27 fe ff ff    	jne    403e6c <sched_thd_block_timeout+0x9c>
  404045:	48 bf 80 f2 41 00 00 	movabs rdi,0x41f280
  40404c:	00 00 00 
  40404f:	be 59 00 00 00       	mov    esi,0x59
  404054:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40405b:	00 00 00 
  40405e:	ff d0                	call   rax
  404060:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404067:	00 00 00 00 
  40406b:	0f 0b                	ud2    
  40406d:	48 bf 20 f2 41 00 00 	movabs rdi,0x41f220
  404074:	00 00 00 
  404077:	be 59 00 00 00       	mov    esi,0x59
  40407c:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  404083:	00 00 00 
  404086:	ff d0                	call   rax
	assert(current);
  404088:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40408f:	00 00 00 00 
  404093:	0f 0b                	ud2    
  404095:	48 bf 08 f3 41 00 00 	movabs rdi,0x41f308
  40409c:	00 00 00 
  40409f:	be 61 00 00 00       	mov    esi,0x61
  4040a4:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4040ab:	00 00 00 
  4040ae:	ff d0                	call   rax
	assert(slm_state_is_runnable(t->state));
  4040b0:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4040b7:	00 00 00 00 
  4040bb:	0f 0b                	ud2    
		if (t == &g->sched_thd) {
  4040bd:	48 ba c8 5e 5a 00 00 	movabs rdx,0x5a5ec8
  4040c4:	00 00 00 
	timeout = g->timeout_next;
  4040c7:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  4040ca:	48 39 d3             	cmp    rbx,rdx
  4040cd:	0f 84 2d 01 00 00    	je     404200 <sched_thd_block_timeout+0x430>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  4040d3:	a8 02                	test   al,0x2
  4040d5:	0f 85 30 01 00 00    	jne    40420b <sched_thd_block_timeout+0x43b>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  4040db:	49 89 c8             	mov    r8,rcx
  4040de:	a8 01                	test   al,0x1
  4040e0:	0f 84 82 fe ff ff    	je     403f68 <sched_thd_block_timeout+0x198>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  4040e6:	4c 8b 53 08          	mov    r10,QWORD PTR [rbx+0x8]
  4040ea:	48 89 f2             	mov    rdx,rsi
  4040ed:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  4040f1:	45 89 f1             	mov    r9d,r14d
  4040f4:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  4040fb:	00 00 00 
  4040fe:	4c 8b 00             	mov    r8,QWORD PTR [rax]
  404101:	48 b8 f0 35 41 00 00 	movabs rax,0x4135f0
  404108:	00 00 00 
  40410b:	4c 89 d6             	mov    rsi,r10
  40410e:	ff d0                	call   rax
	if (unlikely(ret != 0)) {
  404110:	85 c0                	test   eax,eax
  404112:	0f 84 77 fe ff ff    	je     403f8f <sched_thd_block_timeout+0x1bf>
		assert(ret != -EPERM);
  404118:	83 f8 ff             	cmp    eax,0xffffffff
  40411b:	0f 84 a7 00 00 00    	je     4041c8 <sched_thd_block_timeout+0x3f8>
		assert(ret != -EINVAL);
  404121:	83 f8 ea             	cmp    eax,0xffffffea
  404124:	0f 84 36 01 00 00    	je     404260 <sched_thd_block_timeout+0x490>
		if (ret == -EBUSY) return ret;
  40412a:	83 f8 f0             	cmp    eax,0xfffffff0
  40412d:	0f 84 bd 00 00 00    	je     4041f0 <sched_thd_block_timeout+0x420>
		assert(ret == -EAGAIN);
  404133:	83 f8 f5             	cmp    eax,0xfffffff5
  404136:	0f 85 4c 01 00 00    	jne    404288 <sched_thd_block_timeout+0x4b8>
		tok    = cos_sched_sync();
  40413c:	41 ff d4             	call   r12
  40413f:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  404142:	49 8b 07             	mov    rax,QWORD PTR [r15]
		if (unlikely(owner)) {
  404145:	48 89 c1             	mov    rcx,rax
  404148:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  40414c:	0f 85 5e 01 00 00    	jne    4042b0 <sched_thd_block_timeout+0x4e0>
        __asm__ __volatile__("lock " PS_CAS_STR
  404152:	f0 4d 0f b1 2f       	lock cmpxchg QWORD PTR [r15],r13
  404157:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  40415a:	84 c0                	test   al,al
  40415c:	0f 85 69 fd ff ff    	jne    403ecb <sched_thd_block_timeout+0xfb>
  404162:	eb d8                	jmp    40413c <sched_thd_block_timeout+0x36c>
  404164:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	__asm__ __volatile__("rdtsc" : "=a" (a), "=d" (d), "=c" (c) : : );
  404168:	0f 31                	rdtsc  
	return ((u64_t)d << 32) | (u64_t)a;
  40416a:	48 c1 e2 20          	shl    rdx,0x20
  40416e:	48 09 d0             	or     rax,rdx
  404171:	48 89 c2             	mov    rdx,rax
  404174:	4c 29 f2             	sub    rdx,r14
	assert(cycles_greater_than(now, abs_timeout));
  404177:	48 85 d2             	test   rdx,rdx
  40417a:	0f 8f 46 fe ff ff    	jg     403fc6 <sched_thd_block_timeout+0x1f6>
  404180:	48 bf 48 f7 41 00 00 	movabs rdi,0x41f748
  404187:	00 00 00 
  40418a:	be 24 00 00 00       	mov    esi,0x24
  40418f:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  404196:	00 00 00 
  404199:	ff d0                	call   rax
  40419b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4041a2:	00 00 00 00 
  4041a6:	0f 0b                	ud2    
  4041a8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4041af:	00 
	return t != &g->idle_thd && t != &g->sched_thd;
  4041b0:	48 b8 40 5f 5a 00 00 	movabs rax,0x5a5f40
  4041b7:	00 00 00 
  4041ba:	48 39 c3             	cmp    rbx,rax
  4041bd:	74 74                	je     404233 <sched_thd_block_timeout+0x463>
  4041bf:	48 83 e8 78          	sub    rax,0x78
  4041c3:	48 39 c3             	cmp    rbx,rax
  4041c6:	74 6b                	je     404233 <sched_thd_block_timeout+0x463>
  4041c8:	48 bf 70 f3 41 00 00 	movabs rdi,0x41f370
  4041cf:	00 00 00 
  4041d2:	be 61 00 00 00       	mov    esi,0x61
  4041d7:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4041de:	00 00 00 
  4041e1:	ff d0                	call   rax
		assert(ret != -EPERM);
  4041e3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4041ea:	00 00 00 00 
  4041ee:	0f 0b                	ud2    
  4041f0:	4c 8b 75 c8          	mov    r14,QWORD PTR [rbp-0x38]
  4041f4:	89 c3                	mov    ebx,eax
  4041f6:	e9 9a fd ff ff       	jmp    403f95 <sched_thd_block_timeout+0x1c5>
  4041fb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
			prio    = curr->priority;
  404200:	49 8b 75 30          	mov    rsi,QWORD PTR [r13+0x30]
			timeout = TCAP_TIME_NIL;
  404204:	31 c9                	xor    ecx,ecx
  404206:	e9 c8 fe ff ff       	jmp    4040d3 <sched_thd_block_timeout+0x303>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  40420b:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  404212:	00 00 00 
  404215:	48 8b 7b 28          	mov    rdi,QWORD PTR [rbx+0x28]
  404219:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  40421c:	44 89 f1             	mov    ecx,r14d
  40421f:	48 b8 60 36 41 00 00 	movabs rax,0x413660
  404226:	00 00 00 
  404229:	4c 89 c6             	mov    rsi,r8
  40422c:	ff d0                	call   rax
  40422e:	e9 dd fe ff ff       	jmp    404110 <sched_thd_block_timeout+0x340>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  404233:	49 8b 55 30          	mov    rdx,QWORD PTR [r13+0x30]
  404237:	45 89 f1             	mov    r9d,r14d
  40423a:	31 c9                	xor    ecx,ecx
  40423c:	31 f6                	xor    esi,esi
  40423e:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  404245:	00 00 00 
  404248:	4c 8b 00             	mov    r8,QWORD PTR [rax]
  40424b:	48 8b 78 f0          	mov    rdi,QWORD PTR [rax-0x10]
  40424f:	48 b8 f0 35 41 00 00 	movabs rax,0x4135f0
  404256:	00 00 00 
  404259:	ff d0                	call   rax
  40425b:	e9 b0 fe ff ff       	jmp    404110 <sched_thd_block_timeout+0x340>
  404260:	48 bf d8 f3 41 00 00 	movabs rdi,0x41f3d8
  404267:	00 00 00 
  40426a:	be 61 00 00 00       	mov    esi,0x61
  40426f:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  404276:	00 00 00 
  404279:	ff d0                	call   rax
		assert(ret != -EINVAL);
  40427b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404282:	00 00 00 00 
  404286:	0f 0b                	ud2    
  404288:	48 bf 40 f4 41 00 00 	movabs rdi,0x41f440
  40428f:	00 00 00 
  404292:	be 61 00 00 00       	mov    esi,0x61
  404297:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40429e:	00 00 00 
  4042a1:	ff d0                	call   rax
		assert(ret == -EAGAIN);
  4042a3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4042aa:	00 00 00 00 
  4042ae:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  4042b0:	41 89 c0             	mov    r8d,eax
  4042b3:	48 89 c6             	mov    rsi,rax
  4042b6:	4c 89 ea             	mov    rdx,r13
  4042b9:	4c 89 ff             	mov    rdi,r15
  4042bc:	48 b8 50 5f 41 00 00 	movabs rax,0x415f50
  4042c3:	00 00 00 
  4042c6:	41 83 e0 01          	and    r8d,0x1
  4042ca:	ff d0                	call   rax
			assert(ret != -EBUSY);
  4042cc:	83 f8 f0             	cmp    eax,0xfffffff0
  4042cf:	0f 85 67 fe ff ff    	jne    40413c <sched_thd_block_timeout+0x36c>
  4042d5:	48 bf 80 f2 41 00 00 	movabs rdi,0x41f280
  4042dc:	00 00 00 
  4042df:	be 59 00 00 00       	mov    esi,0x59
  4042e4:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4042eb:	00 00 00 
  4042ee:	ff d0                	call   rax
  4042f0:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4042f7:	00 00 00 00 
  4042fb:	0f 0b                	ud2    
  4042fd:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000404300 <thd_sleep>:
{
  404300:	f3 0f 1e fa          	endbr64 
  404304:	55                   	push   rbp
  404305:	48 89 e5             	mov    rbp,rsp
  404308:	41 57                	push   r15
  40430a:	41 56                	push   r14
  40430c:	41 55                	push   r13
  40430e:	41 54                	push   r12
  404310:	53                   	push   rbx
  404311:	48 83 ec 18          	sub    rsp,0x18
	__asm__ __volatile__("rdtsc" : "=a" (a), "=d" (d), "=c" (c) : : );
  404315:	0f 31                	rdtsc  
	return ((u64_t)d << 32) | (u64_t)a;
  404317:	48 c1 e2 20          	shl    rdx,0x20
  40431b:	48 09 c2             	or     rdx,rax
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  40431e:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  404321:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
	cycles_t timeout = c + slm_now();
  404327:	4c 8d 24 3a          	lea    r12,[rdx+rdi*1]
  40432b:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  404332:	48 85 c0             	test   rax,rax
  404335:	0f 84 05 02 00 00    	je     404540 <thd_sleep+0x240>
  40433b:	83 e8 01             	sub    eax,0x1
  40433e:	83 f8 18             	cmp    eax,0x18
  404341:	0f 87 f9 01 00 00    	ja     404540 <thd_sleep+0x240>
  404347:	48 b9 00 27 46 00 00 	movabs rcx,0x462700
  40434e:	00 00 00 
  404351:	45 31 ed             	xor    r13d,r13d
  404354:	48 8b 14 c1          	mov    rdx,QWORD PTR [rcx+rax*8]
  404358:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  40435f:	0f 85 9b 01 00 00    	jne    404500 <thd_sleep+0x200>
	__asm__ __volatile__("rdtsc" : "=a" (a), "=d" (d), "=c" (c) : : );
  404365:	0f 31                	rdtsc  
	return ((u64_t)d << 32) | (u64_t)a;
  404367:	48 c1 e2 20          	shl    rdx,0x20
  40436b:	48 09 c2             	or     rdx,rax
  40436e:	4c 89 e0             	mov    rax,r12
  404371:	48 29 d0             	sub    rax,rdx
	while (cycles_greater_than(timeout, slm_now())) {
  404374:	48 85 c0             	test   rax,rax
  404377:	0f 8e 7c 03 00 00    	jle    4046f9 <thd_sleep+0x3f9>
	assert(current);
  40437d:	49 bf d0 35 41 00 00 	movabs r15,0x4135d0
  404384:	00 00 00 
  404387:	49 be c0 5e 5a 00 00 	movabs r14,0x5a5ec0
  40438e:	00 00 00 
  404391:	4d 85 ed             	test   r13,r13
  404394:	0f 84 03 02 00 00    	je     40459d <thd_sleep+0x29d>
		tok    = cos_sched_sync();
  40439a:	41 ff d7             	call   r15
  40439d:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4043a0:	49 8b 06             	mov    rax,QWORD PTR [r14]
		if (unlikely(owner)) {
  4043a3:	48 89 c1             	mov    rcx,rax
  4043a6:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  4043aa:	0f 85 a0 01 00 00    	jne    404550 <thd_sleep+0x250>
        __asm__ __volatile__("lock " PS_CAS_STR
  4043b0:	f0 4d 0f b1 2e       	lock cmpxchg QWORD PTR [r14],r13
  4043b5:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4043b8:	84 c0                	test   al,al
  4043ba:	74 de                	je     40439a <thd_sleep+0x9a>
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  4043bc:	48 b8 50 51 41 00 00 	movabs rax,0x415150
  4043c3:	00 00 00 
  4043c6:	4c 89 e6             	mov    rsi,r12
  4043c9:	4c 89 ef             	mov    rdi,r13
  4043cc:	ff d0                	call   rax
		if (slm_timer_add(current, timeout)) goto done;
  4043ce:	85 c0                	test   eax,eax
  4043d0:	75 17                	jne    4043e9 <thd_sleep+0xe9>
		if (slm_thd_block(current)) {
  4043d2:	48 b8 30 60 41 00 00 	movabs rax,0x416030
  4043d9:	00 00 00 
  4043dc:	4c 89 ef             	mov    rdi,r13
  4043df:	ff d0                	call   rax
  4043e1:	85 c0                	test   eax,eax
  4043e3:	0f 85 3f 01 00 00    	jne    404528 <thd_sleep+0x228>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  4043e9:	48 b8 10 ce 40 00 00 	movabs rax,0x40ce10
  4043f0:	00 00 00 
  4043f3:	ff d0                	call   rax
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  4043f5:	4c 89 65 c8          	mov    QWORD PTR [rbp-0x38],r12
	tok  = cos_sched_sync();
  4043f9:	41 ff d7             	call   r15
  4043fc:	41 89 c4             	mov    r12d,eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  4043ff:	48 b8 50 48 41 00 00 	movabs rax,0x414850
  404406:	00 00 00 
  404409:	ff d0                	call   rax
	if (unlikely(!t)) t = &g->idle_thd;
  40440b:	48 85 c0             	test   rax,rax
  40440e:	48 89 c3             	mov    rbx,rax
  404411:	48 b8 40 5f 5a 00 00 	movabs rax,0x5a5f40
  404418:	00 00 00 
  40441b:	48 0f 44 d8          	cmove  rbx,rax
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  40441f:	8b 43 04             	mov    eax,DWORD PTR [rbx+0x4]
  404422:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  404425:	83 f8 01             	cmp    eax,0x1
  404428:	76 12                	jbe    40443c <thd_sleep+0x13c>
  40442a:	e9 96 01 00 00       	jmp    4045c5 <thd_sleep+0x2c5>
  40442f:	90                   	nop
  404430:	f0 49 0f b1 16       	lock cmpxchg QWORD PTR [r14],rdx
  404435:	0f 94 c0             	sete   al
	while (ret != 0) {
  404438:	84 c0                	test   al,al
  40443a:	75 2d                	jne    404469 <thd_sleep+0x169>
		tok    = cos_sched_sync();
  40443c:	41 ff d7             	call   r15
  40443f:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  404441:	49 8b 06             	mov    rax,QWORD PTR [r14]
		if (unlikely(contention)) {
  404444:	48 89 c2             	mov    rdx,rax
  404447:	83 e2 01             	and    edx,0x1
  40444a:	74 e4                	je     404430 <thd_sleep+0x130>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  40444c:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  40444f:	48 89 c2             	mov    rdx,rax
  404452:	4c 89 f7             	mov    rdi,r14
  404455:	48 b8 b0 5f 41 00 00 	movabs rax,0x415fb0
  40445c:	00 00 00 
  40445f:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  404463:	ff d0                	call   rax
  404465:	85 c0                	test   eax,eax
  404467:	75 d3                	jne    40443c <thd_sleep+0x13c>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  404469:	48 b8 10 ce 40 00 00 	movabs rax,0x40ce10
  404470:	00 00 00 
  404473:	ff d0                	call   rax
	prio = inherit_prio ? curr->priority : t->priority;
  404475:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
	timeout = g->timeout_next;
  404479:	48 b8 c8 5f 5a 00 00 	movabs rax,0x5a5fc8
  404480:	00 00 00 
  404483:	4c 8b 00             	mov    r8,QWORD PTR [rax]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  404486:	8b 03                	mov    eax,DWORD PTR [rbx]
  404488:	a8 0b                	test   al,0xb
  40448a:	0f 85 5d 01 00 00    	jne    4045ed <thd_sleep+0x2ed>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  404490:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  404494:	44 89 e1             	mov    ecx,r12d
  404497:	4c 89 c2             	mov    rdx,r8
  40449a:	48 b8 70 e1 40 00 00 	movabs rax,0x40e170
  4044a1:	00 00 00 
  4044a4:	ff d0                	call   rax
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  4044a6:	83 f8 ff             	cmp    eax,0xffffffff
  4044a9:	0f 84 8f 01 00 00    	je     40463e <thd_sleep+0x33e>
	if (unlikely(ret != 0)) {
  4044af:	85 c0                	test   eax,eax
  4044b1:	0f 85 07 02 00 00    	jne    4046be <thd_sleep+0x3be>
  4044b7:	4c 8b 65 c8          	mov    r12,QWORD PTR [rbp-0x38]
  4044bb:	31 db                	xor    ebx,ebx
  4044bd:	48 b8 10 52 41 00 00 	movabs rax,0x415210
  4044c4:	00 00 00 
  4044c7:	4c 89 ef             	mov    rdi,r13
  4044ca:	ff d0                	call   rax
	__asm__ __volatile__("rdtsc" : "=a" (a), "=d" (d), "=c" (c) : : );
  4044cc:	0f 31                	rdtsc  
	return ((u64_t)d << 32) | (u64_t)a;
  4044ce:	48 c1 e2 20          	shl    rdx,0x20
  4044d2:	48 09 c2             	or     rdx,rax
  4044d5:	4c 89 e0             	mov    rax,r12
  4044d8:	48 29 d0             	sub    rax,rdx
	while (cycles_greater_than(timeout, slm_now())) {
  4044db:	48 85 c0             	test   rax,rax
  4044de:	0f 8f b6 fe ff ff    	jg     40439a <thd_sleep+0x9a>
  4044e4:	41 89 d8             	mov    r8d,ebx
}
  4044e7:	48 83 c4 18          	add    rsp,0x18
  4044eb:	44 89 c0             	mov    eax,r8d
  4044ee:	5b                   	pop    rbx
  4044ef:	41 5c                	pop    r12
  4044f1:	41 5d                	pop    r13
  4044f3:	41 5e                	pop    r14
  4044f5:	41 5f                	pop    r15
  4044f7:	5d                   	pop    rbp
  4044f8:	c3                   	ret    
  4044f9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  404500:	83 e2 01             	and    edx,0x1
  404503:	0f 85 5c fe ff ff    	jne    404365 <thd_sleep+0x65>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  404509:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  40450d:	48 8d 04 50          	lea    rax,[rax+rdx*2]
  404511:	48 c1 e0 04          	shl    rax,0x4
  404515:	4c 8d ac 01 c8 00 00 	lea    r13,[rcx+rax*1+0xc8]
  40451c:	00 
  40451d:	e9 43 fe ff ff       	jmp    404365 <thd_sleep+0x65>
  404522:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  404528:	48 b8 10 52 41 00 00 	movabs rax,0x415210
  40452f:	00 00 00 
  404532:	4c 89 ef             	mov    rdi,r13
  404535:	ff d0                	call   rax
  404537:	e9 ad fe ff ff       	jmp    4043e9 <thd_sleep+0xe9>
  40453c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  404540:	45 31 ed             	xor    r13d,r13d
  404543:	e9 1d fe ff ff       	jmp    404365 <thd_sleep+0x65>
  404548:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40454f:	00 
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  404550:	41 89 c0             	mov    r8d,eax
  404553:	48 89 c6             	mov    rsi,rax
  404556:	4c 89 ea             	mov    rdx,r13
  404559:	4c 89 f7             	mov    rdi,r14
  40455c:	48 b8 50 5f 41 00 00 	movabs rax,0x415f50
  404563:	00 00 00 
  404566:	41 83 e0 01          	and    r8d,0x1
  40456a:	ff d0                	call   rax
			assert(ret != -EBUSY);
  40456c:	83 f8 f0             	cmp    eax,0xfffffff0
  40456f:	0f 85 25 fe ff ff    	jne    40439a <thd_sleep+0x9a>
  404575:	48 bf 80 f2 41 00 00 	movabs rdi,0x41f280
  40457c:	00 00 00 
  40457f:	be 59 00 00 00       	mov    esi,0x59
  404584:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40458b:	00 00 00 
  40458e:	ff d0                	call   rax
  404590:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404597:	00 00 00 00 
  40459b:	0f 0b                	ud2    
  40459d:	48 bf 20 f2 41 00 00 	movabs rdi,0x41f220
  4045a4:	00 00 00 
  4045a7:	be 59 00 00 00       	mov    esi,0x59
  4045ac:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4045b3:	00 00 00 
  4045b6:	ff d0                	call   rax
	assert(current);
  4045b8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4045bf:	00 00 00 00 
  4045c3:	0f 0b                	ud2    
  4045c5:	48 bf 08 f3 41 00 00 	movabs rdi,0x41f308
  4045cc:	00 00 00 
  4045cf:	be 61 00 00 00       	mov    esi,0x61
  4045d4:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4045db:	00 00 00 
  4045de:	ff d0                	call   rax
	assert(slm_state_is_runnable(t->state));
  4045e0:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4045e7:	00 00 00 00 
  4045eb:	0f 0b                	ud2    
		if (t == &g->sched_thd) {
  4045ed:	48 ba c8 5e 5a 00 00 	movabs rdx,0x5a5ec8
  4045f4:	00 00 00 
	timeout = g->timeout_next;
  4045f7:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  4045fa:	48 39 d3             	cmp    rbx,rdx
  4045fd:	74 7f                	je     40467e <thd_sleep+0x37e>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  4045ff:	a8 02                	test   al,0x2
  404601:	0f 85 fa 00 00 00    	jne    404701 <thd_sleep+0x401>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  404607:	49 89 c8             	mov    r8,rcx
  40460a:	a8 01                	test   al,0x1
  40460c:	0f 84 7e fe ff ff    	je     404490 <thd_sleep+0x190>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  404612:	4c 8b 53 08          	mov    r10,QWORD PTR [rbx+0x8]
  404616:	48 89 f2             	mov    rdx,rsi
  404619:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  40461d:	45 89 e1             	mov    r9d,r12d
  404620:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  404627:	00 00 00 
  40462a:	4c 8b 00             	mov    r8,QWORD PTR [rax]
  40462d:	48 b8 f0 35 41 00 00 	movabs rax,0x4135f0
  404634:	00 00 00 
  404637:	4c 89 d6             	mov    rsi,r10
  40463a:	ff d0                	call   rax
  40463c:	eb 73                	jmp    4046b1 <thd_sleep+0x3b1>
	return t != &g->idle_thd && t != &g->sched_thd;
  40463e:	48 b8 40 5f 5a 00 00 	movabs rax,0x5a5f40
  404645:	00 00 00 
  404648:	48 39 c3             	cmp    rbx,rax
  40464b:	74 3c                	je     404689 <thd_sleep+0x389>
  40464d:	48 83 e8 78          	sub    rax,0x78
  404651:	48 39 c3             	cmp    rbx,rax
  404654:	74 33                	je     404689 <thd_sleep+0x389>
  404656:	48 bf 70 f3 41 00 00 	movabs rdi,0x41f370
  40465d:	00 00 00 
  404660:	be 61 00 00 00       	mov    esi,0x61
  404665:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40466c:	00 00 00 
  40466f:	ff d0                	call   rax
		assert(ret != -EPERM);
  404671:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404678:	00 00 00 00 
  40467c:	0f 0b                	ud2    
			prio    = curr->priority;
  40467e:	49 8b 75 30          	mov    rsi,QWORD PTR [r13+0x30]
			timeout = TCAP_TIME_NIL;
  404682:	31 c9                	xor    ecx,ecx
  404684:	e9 76 ff ff ff       	jmp    4045ff <thd_sleep+0x2ff>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  404689:	49 8b 55 30          	mov    rdx,QWORD PTR [r13+0x30]
  40468d:	45 89 e1             	mov    r9d,r12d
  404690:	31 c9                	xor    ecx,ecx
  404692:	31 f6                	xor    esi,esi
  404694:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  40469b:	00 00 00 
  40469e:	4c 8b 00             	mov    r8,QWORD PTR [rax]
  4046a1:	48 8b 78 f0          	mov    rdi,QWORD PTR [rax-0x10]
  4046a5:	48 b8 f0 35 41 00 00 	movabs rax,0x4135f0
  4046ac:	00 00 00 
  4046af:	ff d0                	call   rax
	if (unlikely(ret != 0)) {
  4046b1:	85 c0                	test   eax,eax
  4046b3:	0f 84 fe fd ff ff    	je     4044b7 <thd_sleep+0x1b7>
		assert(ret != -EPERM);
  4046b9:	83 f8 ff             	cmp    eax,0xffffffff
  4046bc:	74 98                	je     404656 <thd_sleep+0x356>
		assert(ret != -EINVAL);
  4046be:	83 f8 ea             	cmp    eax,0xffffffea
  4046c1:	74 63                	je     404726 <thd_sleep+0x426>
		if (ret == -EBUSY) return ret;
  4046c3:	83 f8 f0             	cmp    eax,0xfffffff0
  4046c6:	0f 84 d4 00 00 00    	je     4047a0 <thd_sleep+0x4a0>
		assert(ret == -EAGAIN);
  4046cc:	83 f8 f5             	cmp    eax,0xfffffff5
  4046cf:	75 7d                	jne    40474e <thd_sleep+0x44e>
		tok    = cos_sched_sync();
  4046d1:	41 ff d7             	call   r15
  4046d4:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4046d7:	49 8b 06             	mov    rax,QWORD PTR [r14]
		if (unlikely(owner)) {
  4046da:	48 89 c1             	mov    rcx,rax
  4046dd:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  4046e1:	0f 85 8f 00 00 00    	jne    404776 <thd_sleep+0x476>
        __asm__ __volatile__("lock " PS_CAS_STR
  4046e7:	f0 4d 0f b1 2e       	lock cmpxchg QWORD PTR [r14],r13
  4046ec:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4046ef:	84 c0                	test   al,al
  4046f1:	0f 85 02 fd ff ff    	jne    4043f9 <thd_sleep+0xf9>
  4046f7:	eb d8                	jmp    4046d1 <thd_sleep+0x3d1>
	int ret = 0;
  4046f9:	45 31 c0             	xor    r8d,r8d
	return thd_block_until(timeout);
  4046fc:	e9 e6 fd ff ff       	jmp    4044e7 <thd_sleep+0x1e7>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  404701:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  404708:	00 00 00 
  40470b:	48 8b 7b 28          	mov    rdi,QWORD PTR [rbx+0x28]
  40470f:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  404712:	44 89 e1             	mov    ecx,r12d
  404715:	48 b8 60 36 41 00 00 	movabs rax,0x413660
  40471c:	00 00 00 
  40471f:	4c 89 c6             	mov    rsi,r8
  404722:	ff d0                	call   rax
  404724:	eb 8b                	jmp    4046b1 <thd_sleep+0x3b1>
  404726:	48 bf d8 f3 41 00 00 	movabs rdi,0x41f3d8
  40472d:	00 00 00 
  404730:	be 61 00 00 00       	mov    esi,0x61
  404735:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40473c:	00 00 00 
  40473f:	ff d0                	call   rax
		assert(ret != -EINVAL);
  404741:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404748:	00 00 00 00 
  40474c:	0f 0b                	ud2    
  40474e:	48 bf 40 f4 41 00 00 	movabs rdi,0x41f440
  404755:	00 00 00 
  404758:	be 61 00 00 00       	mov    esi,0x61
  40475d:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  404764:	00 00 00 
  404767:	ff d0                	call   rax
		assert(ret == -EAGAIN);
  404769:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404770:	00 00 00 00 
  404774:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  404776:	41 89 c0             	mov    r8d,eax
  404779:	48 89 c6             	mov    rsi,rax
  40477c:	4c 89 ea             	mov    rdx,r13
  40477f:	4c 89 f7             	mov    rdi,r14
  404782:	48 b8 50 5f 41 00 00 	movabs rax,0x415f50
  404789:	00 00 00 
  40478c:	41 83 e0 01          	and    r8d,0x1
  404790:	ff d0                	call   rax
			assert(ret != -EBUSY);
  404792:	83 f8 f0             	cmp    eax,0xfffffff0
  404795:	0f 85 36 ff ff ff    	jne    4046d1 <thd_sleep+0x3d1>
  40479b:	e9 d5 fd ff ff       	jmp    404575 <thd_sleep+0x275>
  4047a0:	4c 8b 65 c8          	mov    r12,QWORD PTR [rbp-0x38]
  4047a4:	89 c3                	mov    ebx,eax
  4047a6:	e9 12 fd ff ff       	jmp    4044bd <thd_sleep+0x1bd>
  4047ab:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000004047b0 <sched_blkpt_alloc>:
{
  4047b0:	f3 0f 1e fa          	endbr64 
  4047b4:	55                   	push   rbp
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  4047b5:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  4047b8:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  4047be:	48 89 e5             	mov    rbp,rsp
  4047c1:	41 56                	push   r14
  4047c3:	41 55                	push   r13
  4047c5:	41 54                	push   r12
  4047c7:	53                   	push   rbx
  4047c8:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  4047cf:	48 85 c0             	test   rax,rax
  4047d2:	0f 84 28 01 00 00    	je     404900 <sched_blkpt_alloc+0x150>
  4047d8:	83 e8 01             	sub    eax,0x1
  4047db:	83 f8 18             	cmp    eax,0x18
  4047de:	0f 87 1c 01 00 00    	ja     404900 <sched_blkpt_alloc+0x150>
  4047e4:	48 ba 00 27 46 00 00 	movabs rdx,0x462700
  4047eb:	00 00 00 
  4047ee:	48 8b 0c c2          	mov    rcx,QWORD PTR [rdx+rax*8]
  4047f2:	48 f7 c1 fe ff ff ff 	test   rcx,0xfffffffffffffffe
  4047f9:	0f 84 01 01 00 00    	je     404900 <sched_blkpt_alloc+0x150>
  4047ff:	83 e1 01             	and    ecx,0x1
  404802:	0f 85 f8 00 00 00    	jne    404900 <sched_blkpt_alloc+0x150>
  404808:	48 bb d0 35 41 00 00 	movabs rbx,0x4135d0
  40480f:	00 00 00 
	return &ss_thd_get(cos_thdid())->thd;
  404812:	48 8d 0c 80          	lea    rcx,[rax+rax*4]
  404816:	49 be c0 5e 5a 00 00 	movabs r14,0x5a5ec0
  40481d:	00 00 00 
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  404820:	49 bd 50 5f 41 00 00 	movabs r13,0x415f50
  404827:	00 00 00 
  40482a:	48 8d 04 48          	lea    rax,[rax+rcx*2]
  40482e:	48 c1 e0 04          	shl    rax,0x4
  404832:	4c 8d a4 02 c8 00 00 	lea    r12,[rdx+rax*1+0xc8]
  404839:	00 
		tok    = cos_sched_sync();
  40483a:	ff d3                	call   rbx
  40483c:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  40483f:	49 8b 06             	mov    rax,QWORD PTR [r14]
		if (unlikely(owner)) {
  404842:	48 89 c1             	mov    rcx,rax
  404845:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  404849:	0f 85 e1 00 00 00    	jne    404930 <sched_blkpt_alloc+0x180>
  40484f:	f0 4d 0f b1 26       	lock cmpxchg QWORD PTR [r14],r12
  404854:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  404857:	84 c0                	test   al,al
  404859:	74 df                	je     40483a <sched_blkpt_alloc+0x8a>
	id = (sched_blkpt_id_t)__blkpt_offset;
  40485b:	48 ba 00 80 42 00 00 	movabs rdx,0x428000
  404862:	00 00 00 
  404865:	44 8b 22             	mov    r12d,DWORD PTR [rdx]
	if (id - 1 == NBLKPTS) return NULL;
  404868:	41 81 fc 01 a0 00 00 	cmp    r12d,0xa001
  40486f:	0f 84 ff 00 00 00    	je     404974 <sched_blkpt_alloc+0x1c4>
	return &__blkpts[id-1];
  404875:	48 b9 00 39 46 00 00 	movabs rcx,0x463900
  40487c:	00 00 00 
  40487f:	41 8d 44 24 ff       	lea    eax,[r12-0x1]
  404884:	48 c1 e0 05          	shl    rax,0x5
  404888:	48 01 c8             	add    rax,rcx
	m->id    = id;
  40488b:	44 89 20             	mov    DWORD PTR [rax],r12d
	m->epoch = 0;
  40488e:	48 c7 40 08 00 00 00 	mov    QWORD PTR [rax+0x8],0x0
  404895:	00 
	h->head = NULL;
  404896:	48 c7 40 10 00 00 00 	mov    QWORD PTR [rax+0x10],0x0
  40489d:	00 
{ l->o = 0; }
  40489e:	48 c7 40 18 00 00 00 	mov    QWORD PTR [rax+0x18],0x0
  4048a5:	00 
	__blkpt_offset++;
  4048a6:	41 8d 44 24 01       	lea    eax,[r12+0x1]
  4048ab:	89 02                	mov    DWORD PTR [rdx],eax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  4048ad:	49 bd b0 5f 41 00 00 	movabs r13,0x415fb0
  4048b4:	00 00 00 
  4048b7:	eb 13                	jmp    4048cc <sched_blkpt_alloc+0x11c>
  4048b9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  4048c0:	f0 49 0f b1 16       	lock cmpxchg QWORD PTR [r14],rdx
  4048c5:	0f 94 c0             	sete   al
	while (ret != 0) {
  4048c8:	84 c0                	test   al,al
  4048ca:	75 23                	jne    4048ef <sched_blkpt_alloc+0x13f>
		tok    = cos_sched_sync();
  4048cc:	ff d3                	call   rbx
  4048ce:	89 c1                	mov    ecx,eax
  4048d0:	49 8b 06             	mov    rax,QWORD PTR [r14]
		if (unlikely(contention)) {
  4048d3:	48 89 c2             	mov    rdx,rax
  4048d6:	83 e2 01             	and    edx,0x1
  4048d9:	74 e5                	je     4048c0 <sched_blkpt_alloc+0x110>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  4048db:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  4048de:	48 89 c2             	mov    rdx,rax
  4048e1:	4c 89 f7             	mov    rdi,r14
  4048e4:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  4048e8:	41 ff d5             	call   r13
  4048eb:	85 c0                	test   eax,eax
  4048ed:	75 dd                	jne    4048cc <sched_blkpt_alloc+0x11c>
}
  4048ef:	5b                   	pop    rbx
  4048f0:	44 89 e0             	mov    eax,r12d
  4048f3:	41 5c                	pop    r12
  4048f5:	41 5d                	pop    r13
  4048f7:	41 5e                	pop    r14
  4048f9:	5d                   	pop    rbp
  4048fa:	c3                   	ret    
  4048fb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  404900:	48 bf 20 f2 41 00 00 	movabs rdi,0x41f220
  404907:	00 00 00 
  40490a:	be 59 00 00 00       	mov    esi,0x59
  40490f:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  404916:	00 00 00 
  404919:	ff d0                	call   rax
	assert(current);
  40491b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404922:	00 00 00 00 
  404926:	0f 0b                	ud2    
  404928:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40492f:	00 
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  404930:	41 89 c0             	mov    r8d,eax
  404933:	4c 89 e2             	mov    rdx,r12
  404936:	48 89 c6             	mov    rsi,rax
  404939:	4c 89 f7             	mov    rdi,r14
  40493c:	41 83 e0 01          	and    r8d,0x1
  404940:	41 ff d5             	call   r13
			assert(ret != -EBUSY);
  404943:	83 f8 f0             	cmp    eax,0xfffffff0
  404946:	0f 85 ee fe ff ff    	jne    40483a <sched_blkpt_alloc+0x8a>
  40494c:	48 bf 80 f2 41 00 00 	movabs rdi,0x41f280
  404953:	00 00 00 
  404956:	be 59 00 00 00       	mov    esi,0x59
  40495b:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  404962:	00 00 00 
  404965:	ff d0                	call   rax
  404967:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40496e:	00 00 00 00 
  404972:	0f 0b                	ud2    
	if (!m) ERR_THROW(SCHED_BLKPT_NULL, unlock);
  404974:	45 31 e4             	xor    r12d,r12d
  404977:	e9 31 ff ff ff       	jmp    4048ad <sched_blkpt_alloc+0xfd>
  40497c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000404980 <sched_blkpt_free>:
  404980:	f3 0f 1e fa          	endbr64 
  404984:	31 c0                	xor    eax,eax
  404986:	c3                   	ret    
  404987:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40498e:	00 00 

0000000000404990 <sched_blkpt_trigger>:
{
  404990:	f3 0f 1e fa          	endbr64 
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  404994:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  404997:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  40499d:	49 89 f0             	mov    r8,rsi
  4049a0:	89 d1                	mov    ecx,edx
  4049a2:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  4049a9:	48 85 c0             	test   rax,rax
  4049ac:	74 52                	je     404a00 <sched_blkpt_trigger+0x70>
  4049ae:	83 e8 01             	sub    eax,0x1
  4049b1:	83 f8 18             	cmp    eax,0x18
  4049b4:	77 4a                	ja     404a00 <sched_blkpt_trigger+0x70>
  4049b6:	49 b9 00 27 46 00 00 	movabs r9,0x462700
  4049bd:	00 00 00 
  4049c0:	31 f6                	xor    esi,esi
  4049c2:	49 8b 14 c1          	mov    rdx,QWORD PTR [r9+rax*8]
  4049c6:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  4049cd:	74 19                	je     4049e8 <sched_blkpt_trigger+0x58>
  4049cf:	83 e2 01             	and    edx,0x1
  4049d2:	75 14                	jne    4049e8 <sched_blkpt_trigger+0x58>
  4049d4:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  4049d8:	48 8d 04 50          	lea    rax,[rax+rdx*2]
  4049dc:	48 c1 e0 04          	shl    rax,0x4
  4049e0:	49 8d b4 01 c8 00 00 	lea    rsi,[r9+rax*1+0xc8]
  4049e7:	00 
	return slm_blkpt_trigger(blkpt, current, epoch, single);
  4049e8:	48 b8 40 11 40 00 00 	movabs rax,0x401140
  4049ef:	00 00 00 
  4049f2:	4c 89 c2             	mov    rdx,r8
  4049f5:	ff e0                	jmp    rax
  4049f7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  4049fe:	00 00 
  404a00:	48 b8 40 11 40 00 00 	movabs rax,0x401140
  404a07:	00 00 00 
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  404a0a:	31 f6                	xor    esi,esi
	return slm_blkpt_trigger(blkpt, current, epoch, single);
  404a0c:	4c 89 c2             	mov    rdx,r8
  404a0f:	ff e0                	jmp    rax
  404a11:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  404a18:	00 00 00 00 
  404a1c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000404a20 <sched_blkpt_block>:
{
  404a20:	f3 0f 1e fa          	endbr64 
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  404a24:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  404a27:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  404a2d:	49 89 f0             	mov    r8,rsi
  404a30:	48 89 d1             	mov    rcx,rdx
  404a33:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  404a3a:	48 85 c0             	test   rax,rax
  404a3d:	74 51                	je     404a90 <sched_blkpt_block+0x70>
  404a3f:	83 e8 01             	sub    eax,0x1
  404a42:	83 f8 18             	cmp    eax,0x18
  404a45:	77 49                	ja     404a90 <sched_blkpt_block+0x70>
  404a47:	49 b9 00 27 46 00 00 	movabs r9,0x462700
  404a4e:	00 00 00 
  404a51:	31 f6                	xor    esi,esi
  404a53:	49 8b 14 c1          	mov    rdx,QWORD PTR [r9+rax*8]
  404a57:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  404a5e:	74 19                	je     404a79 <sched_blkpt_block+0x59>
  404a60:	83 e2 01             	and    edx,0x1
  404a63:	75 14                	jne    404a79 <sched_blkpt_block+0x59>
  404a65:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  404a69:	48 8d 04 50          	lea    rax,[rax+rdx*2]
  404a6d:	48 c1 e0 04          	shl    rax,0x4
  404a71:	49 8d b4 01 c8 00 00 	lea    rsi,[r9+rax*1+0xc8]
  404a78:	00 
	return slm_blkpt_block(blkpt, current, epoch, dependency);
  404a79:	48 b8 30 16 40 00 00 	movabs rax,0x401630
  404a80:	00 00 00 
  404a83:	4c 89 c2             	mov    rdx,r8
  404a86:	ff e0                	jmp    rax
  404a88:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  404a8f:	00 
  404a90:	48 b8 30 16 40 00 00 	movabs rax,0x401630
  404a97:	00 00 00 
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  404a9a:	31 f6                	xor    esi,esi
	return slm_blkpt_block(blkpt, current, epoch, dependency);
  404a9c:	4c 89 c2             	mov    rdx,r8
  404a9f:	ff e0                	jmp    rax
  404aa1:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  404aa8:	00 00 00 00 
  404aac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000404ab0 <syncipc_call>:
{
  404ab0:	f3 0f 1e fa          	endbr64 
  404ab4:	55                   	push   rbp
  404ab5:	66 48 0f 6e ce       	movq   xmm1,rsi
  404aba:	66 48 0f 6e d2       	movq   xmm2,rdx
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  404abf:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  404ac2:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  404ac8:	66 0f 6c ca          	punpcklqdq xmm1,xmm2
  404acc:	48 89 e5             	mov    rbp,rsp
  404acf:	41 57                	push   r15
  404ad1:	41 56                	push   r14
  404ad3:	41 55                	push   r13
  404ad5:	41 54                	push   r12
  404ad7:	53                   	push   rbx
  404ad8:	48 83 ec 48          	sub    rsp,0x48
  404adc:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
  404ae3:	48 89 4d 98          	mov    QWORD PTR [rbp-0x68],rcx
  404ae7:	4c 89 45 90          	mov    QWORD PTR [rbp-0x70],r8
  404aeb:	0f 29 4d a0          	movaps XMMWORD PTR [rbp-0x60],xmm1
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  404aef:	48 85 c0             	test   rax,rax
  404af2:	0f 84 c0 01 00 00    	je     404cb8 <syncipc_call+0x208>
  404af8:	83 e8 01             	sub    eax,0x1
  404afb:	83 f8 18             	cmp    eax,0x18
  404afe:	0f 87 b4 01 00 00    	ja     404cb8 <syncipc_call+0x208>
  404b04:	48 b9 00 27 46 00 00 	movabs rcx,0x462700
  404b0b:	00 00 00 
  404b0e:	31 db                	xor    ebx,ebx
  404b10:	48 8b 14 c1          	mov    rdx,QWORD PTR [rcx+rax*8]
  404b14:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  404b1b:	0f 85 6f 01 00 00    	jne    404c90 <syncipc_call+0x1e0>
	counts[type]++;
  404b21:	48 b8 00 21 46 00 00 	movabs rax,0x462100
  404b28:	00 00 00 
	struct ipc_retvals retvals = { .ready = 0 };
  404b2b:	66 0f ef c0          	pxor   xmm0,xmm0
	if (ep->server == NULL) return -EAGAIN;
  404b2f:	49 bd 40 21 46 00 00 	movabs r13,0x462140
  404b36:	00 00 00 
	struct ipc_retvals retvals = { .ready = 0 };
  404b39:	48 c7 45 c0 00 00 00 	mov    QWORD PTR [rbp-0x40],0x0
  404b40:	00 
	counts[type]++;
  404b41:	48 83 00 01          	add    QWORD PTR [rax],0x1
	if (ep->server == NULL) return -EAGAIN;
  404b45:	49 83 7d 08 00       	cmp    QWORD PTR [r13+0x8],0x0
	struct ipc_retvals retvals = { .ready = 0 };
  404b4a:	0f 29 45 b0          	movaps XMMWORD PTR [rbp-0x50],xmm0
	if (ep->server == NULL) return -EAGAIN;
  404b4e:	0f 84 ce 02 00 00    	je     404e22 <syncipc_call+0x372>
  404b54:	49 be d0 35 41 00 00 	movabs r14,0x4135d0
  404b5b:	00 00 00 
		tok      = cos_sched_sync();
  404b5e:	41 ff d6             	call   r14
  404b61:	41 89 c4             	mov    r12d,eax
		switchto = ps_load(&ep->server);
  404b64:	48 b8 48 21 46 00 00 	movabs rax,0x462148
  404b6b:	00 00 00 
  404b6e:	4c 8b 38             	mov    r15,QWORD PTR [rax]
  404b71:	31 c0                	xor    eax,eax
  404b73:	f0 49 0f b1 5d 00    	lock cmpxchg QWORD PTR [r13+0x0],rbx
  404b79:	0f 94 c0             	sete   al
		if (likely(ps_cas((unsigned long *)&ep->client, 0, (unsigned long)t))) {
  404b7c:	84 c0                	test   al,al
  404b7e:	0f 84 3c 01 00 00    	je     404cc0 <syncipc_call+0x210>
			ep->retvals = &retvals;
  404b84:	48 8d 45 b0          	lea    rax,[rbp-0x50]
			ep->a0      = arg0;
  404b88:	66 0f 6f 5d a0       	movdqa xmm3,XMMWORD PTR [rbp-0x60]
			ep->retvals = &retvals;
  404b8d:	48 a3 60 21 46 00 00 	movabs ds:0x462160,rax
  404b94:	00 00 00 
			assert(ps_load(&ep->client) == t);
  404b97:	49 8b 45 00          	mov    rax,QWORD PTR [r13+0x0]
			ep->a0      = arg0;
  404b9b:	41 0f 29 5d 10       	movaps XMMWORD PTR [r13+0x10],xmm3
			assert(ps_load(&ep->client) == t);
  404ba0:	48 39 d8             	cmp    rax,rbx
  404ba3:	0f 85 5c 01 00 00    	jne    404d05 <syncipc_call+0x255>
		client = ps_load(&ep->client);
  404ba9:	49 8b 45 00          	mov    rax,QWORD PTR [r13+0x0]
	__asm__ __volatile__("rdtsc" : "=a" (a), "=d" (d), "=c" (c) : : );
  404bad:	0f 31                	rdtsc  
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  404baf:	41 8b 47 04          	mov    eax,DWORD PTR [r15+0x4]
  404bb3:	83 e8 02             	sub    eax,0x2
 * - `inherit_prio` - should `to` inherit `curr`'s priority?
 */
static inline int
slm_switch_to(struct slm_thd *curr, struct slm_thd *to, sched_tok_t tok, int inherit_prio)
{
	if (unlikely(!slm_state_is_runnable(to->state))) return 1;
  404bb6:	83 f8 01             	cmp    eax,0x1
  404bb9:	0f 87 21 01 00 00    	ja     404ce0 <syncipc_call+0x230>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  404bbf:	48 b8 10 ce 40 00 00 	movabs rax,0x40ce10
  404bc6:	00 00 00 
  404bc9:	ff d0                	call   rax
	prio = inherit_prio ? curr->priority : t->priority;
  404bcb:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
	timeout = g->timeout_next;
  404bcf:	48 b8 c8 5f 5a 00 00 	movabs rax,0x5a5fc8
  404bd6:	00 00 00 
  404bd9:	4c 8b 00             	mov    r8,QWORD PTR [rax]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  404bdc:	41 8b 07             	mov    eax,DWORD PTR [r15]
  404bdf:	a8 0b                	test   al,0xb
  404be1:	0f 85 46 01 00 00    	jne    404d2d <syncipc_call+0x27d>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  404be7:	49 8b 7f 10          	mov    rdi,QWORD PTR [r15+0x10]
  404beb:	44 89 e1             	mov    ecx,r12d
  404bee:	4c 89 c2             	mov    rdx,r8
  404bf1:	48 b8 70 e1 40 00 00 	movabs rax,0x40e170
  404bf8:	00 00 00 
  404bfb:	ff d0                	call   rax
  404bfd:	41 89 c1             	mov    r9d,eax
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  404c00:	83 f8 ff             	cmp    eax,0xffffffff
  404c03:	0f 84 7f 01 00 00    	je     404d88 <syncipc_call+0x2d8>
		if (unlikely(ret)) {
  404c09:	45 85 c9             	test   r9d,r9d
  404c0c:	40 0f 95 c6          	setne  sil
			if (ret != -EAGAIN) return ret;
  404c10:	41 83 f9 f5          	cmp    r9d,0xfffffff5
  404c14:	0f 95 c0             	setne  al
  404c17:	21 c6                	and    esi,eax
  404c19:	0f 31                	rdtsc  
	counts[type]++;
  404c1b:	48 a1 08 21 46 00 00 	movabs rax,ds:0x462108
  404c22:	00 00 00 
  404c25:	48 83 c0 01          	add    rax,0x1
  404c29:	48 a3 08 21 46 00 00 	movabs ds:0x462108,rax
  404c30:	00 00 00 
			if (ret != -EAGAIN) return ret;
  404c33:	40 84 f6             	test   sil,sil
  404c36:	75 3c                	jne    404c74 <syncipc_call+0x1c4>
		if (likely(ps_load(&retvals.ready))) break;
  404c38:	8b 45 b0             	mov    eax,DWORD PTR [rbp-0x50]
  404c3b:	85 c0                	test   eax,eax
  404c3d:	0f 84 1b ff ff ff    	je     404b5e <syncipc_call+0xae>
	counts[type]++;
  404c43:	48 a1 10 21 46 00 00 	movabs rax,ds:0x462110
  404c4a:	00 00 00 
	*ret0 = ps_load(&retvals.r0);
  404c4d:	48 8b 7d 98          	mov    rdi,QWORD PTR [rbp-0x68]
	return 0;
  404c51:	45 31 c9             	xor    r9d,r9d
	counts[type]++;
  404c54:	48 83 c0 01          	add    rax,0x1
  404c58:	48 a3 10 21 46 00 00 	movabs ds:0x462110,rax
  404c5f:	00 00 00 
	*ret0 = ps_load(&retvals.r0);
  404c62:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  404c66:	48 89 07             	mov    QWORD PTR [rdi],rax
	*ret1 = ps_load(&retvals.r1);
  404c69:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
  404c6d:	48 8b 7d 90          	mov    rdi,QWORD PTR [rbp-0x70]
  404c71:	48 89 07             	mov    QWORD PTR [rdi],rax
}
  404c74:	48 83 c4 48          	add    rsp,0x48
  404c78:	44 89 c8             	mov    eax,r9d
  404c7b:	5b                   	pop    rbx
  404c7c:	41 5c                	pop    r12
  404c7e:	41 5d                	pop    r13
  404c80:	41 5e                	pop    r14
  404c82:	41 5f                	pop    r15
  404c84:	5d                   	pop    rbp
  404c85:	c3                   	ret    
  404c86:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  404c8d:	00 00 00 
  404c90:	83 e2 01             	and    edx,0x1
  404c93:	0f 85 88 fe ff ff    	jne    404b21 <syncipc_call+0x71>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  404c99:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  404c9d:	48 8d 04 50          	lea    rax,[rax+rdx*2]
  404ca1:	48 c1 e0 04          	shl    rax,0x4
  404ca5:	48 8d 9c 01 c8 00 00 	lea    rbx,[rcx+rax*1+0xc8]
  404cac:	00 
  404cad:	e9 6f fe ff ff       	jmp    404b21 <syncipc_call+0x71>
  404cb2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  404cb8:	31 db                	xor    ebx,ebx
  404cba:	e9 62 fe ff ff       	jmp    404b21 <syncipc_call+0x71>
  404cbf:	90                   	nop
		client = ps_load(&ep->client);
  404cc0:	49 8b 45 00          	mov    rax,QWORD PTR [r13+0x0]
		if (unlikely(ep->client != t && ep->retvals == NULL)) switchto = client;
  404cc4:	49 39 5d 00          	cmp    QWORD PTR [r13+0x0],rbx
  404cc8:	0f 84 df fe ff ff    	je     404bad <syncipc_call+0xfd>
		client = ps_load(&ep->client);
  404cce:	49 83 7d 20 00       	cmp    QWORD PTR [r13+0x20],0x0
  404cd3:	4c 0f 44 f8          	cmove  r15,rax
  404cd7:	e9 d1 fe ff ff       	jmp    404bad <syncipc_call+0xfd>
  404cdc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  404ce0:	0f 31                	rdtsc  
	counts[type]++;
  404ce2:	48 a1 08 21 46 00 00 	movabs rax,ds:0x462108
  404ce9:	00 00 00 
  404cec:	41 b9 01 00 00 00    	mov    r9d,0x1
  404cf2:	48 83 c0 01          	add    rax,0x1
  404cf6:	48 a3 08 21 46 00 00 	movabs ds:0x462108,rax
  404cfd:	00 00 00 
			if (ret != -EAGAIN) return ret;
  404d00:	e9 6f ff ff ff       	jmp    404c74 <syncipc_call+0x1c4>
  404d05:	48 bf 70 f7 41 00 00 	movabs rdi,0x41f770
  404d0c:	00 00 00 
  404d0f:	be 24 00 00 00       	mov    esi,0x24
  404d14:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  404d1b:	00 00 00 
  404d1e:	ff d0                	call   rax
			assert(ps_load(&ep->client) == t);
  404d20:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404d27:	00 00 00 00 
  404d2b:	0f 0b                	ud2    
			timeout = TCAP_TIME_NIL;
  404d2d:	48 ba c8 5e 5a 00 00 	movabs rdx,0x5a5ec8
  404d34:	00 00 00 
  404d37:	b9 00 00 00 00       	mov    ecx,0x0
  404d3c:	49 39 d7             	cmp    r15,rdx
  404d3f:	49 0f 45 c8          	cmovne rcx,r8
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  404d43:	a8 02                	test   al,0x2
  404d45:	0f 85 b2 00 00 00    	jne    404dfd <syncipc_call+0x34d>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  404d4b:	49 89 c8             	mov    r8,rcx
  404d4e:	a8 01                	test   al,0x1
  404d50:	0f 84 91 fe ff ff    	je     404be7 <syncipc_call+0x137>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  404d56:	4d 8b 57 08          	mov    r10,QWORD PTR [r15+0x8]
  404d5a:	45 89 e1             	mov    r9d,r12d
  404d5d:	48 89 f2             	mov    rdx,rsi
  404d60:	49 8b 7f 10          	mov    rdi,QWORD PTR [r15+0x10]
  404d64:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  404d6b:	00 00 00 
  404d6e:	4c 8b 00             	mov    r8,QWORD PTR [rax]
  404d71:	48 b8 f0 35 41 00 00 	movabs rax,0x4135f0
  404d78:	00 00 00 
  404d7b:	4c 89 d6             	mov    rsi,r10
  404d7e:	ff d0                	call   rax
  404d80:	41 89 c1             	mov    r9d,eax
  404d83:	e9 81 fe ff ff       	jmp    404c09 <syncipc_call+0x159>
	return t != &g->idle_thd && t != &g->sched_thd;
  404d88:	48 b8 40 5f 5a 00 00 	movabs rax,0x5a5f40
  404d8f:	00 00 00 
  404d92:	49 39 c7             	cmp    r15,rax
  404d95:	74 28                	je     404dbf <syncipc_call+0x30f>
  404d97:	48 83 e8 78          	sub    rax,0x78
  404d9b:	49 39 c7             	cmp    r15,rax
  404d9e:	74 1f                	je     404dbf <syncipc_call+0x30f>
  404da0:	0f 31                	rdtsc  
	counts[type]++;
  404da2:	48 a1 08 21 46 00 00 	movabs rax,ds:0x462108
  404da9:	00 00 00 
  404dac:	48 83 c0 01          	add    rax,0x1
  404db0:	48 a3 08 21 46 00 00 	movabs ds:0x462108,rax
  404db7:	00 00 00 
			if (ret != -EAGAIN) return ret;
  404dba:	e9 b5 fe ff ff       	jmp    404c74 <syncipc_call+0x1c4>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  404dbf:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]
  404dc3:	45 89 e1             	mov    r9d,r12d
  404dc6:	31 c9                	xor    ecx,ecx
  404dc8:	31 f6                	xor    esi,esi
  404dca:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  404dd1:	00 00 00 
  404dd4:	4c 8b 00             	mov    r8,QWORD PTR [rax]
  404dd7:	48 8b 78 f0          	mov    rdi,QWORD PTR [rax-0x10]
  404ddb:	48 b8 f0 35 41 00 00 	movabs rax,0x4135f0
  404de2:	00 00 00 
  404de5:	ff d0                	call   rax
  404de7:	83 f8 f5             	cmp    eax,0xfffffff5
  404dea:	41 89 c1             	mov    r9d,eax
  404ded:	40 0f 95 c6          	setne  sil
		if (unlikely(ret)) {
  404df1:	85 c0                	test   eax,eax
  404df3:	0f 95 c0             	setne  al
			if (ret != -EAGAIN) return ret;
  404df6:	21 c6                	and    esi,eax
  404df8:	e9 1c fe ff ff       	jmp    404c19 <syncipc_call+0x169>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  404dfd:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  404e04:	00 00 00 
  404e07:	49 8b 7f 28          	mov    rdi,QWORD PTR [r15+0x28]
  404e0b:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  404e0e:	44 89 e1             	mov    ecx,r12d
  404e11:	48 b8 60 36 41 00 00 	movabs rax,0x413660
  404e18:	00 00 00 
  404e1b:	4c 89 c6             	mov    rsi,r8
  404e1e:	ff d0                	call   rax
  404e20:	eb c5                	jmp    404de7 <syncipc_call+0x337>
	if (ep->server == NULL) return -EAGAIN;
  404e22:	41 b9 f5 ff ff ff    	mov    r9d,0xfffffff5
  404e28:	e9 47 fe ff ff       	jmp    404c74 <syncipc_call+0x1c4>
  404e2d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000404e30 <syncipc_reply_wait>:
{
  404e30:	f3 0f 1e fa          	endbr64 
  404e34:	55                   	push   rbp
  404e35:	66 48 0f 6e c6       	movq   xmm0,rsi
  404e3a:	66 48 0f 6e ca       	movq   xmm1,rdx
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  404e3f:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  404e42:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  404e48:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  404e4c:	48 89 e5             	mov    rbp,rsp
  404e4f:	41 57                	push   r15
  404e51:	41 56                	push   r14
  404e53:	41 55                	push   r13
  404e55:	41 54                	push   r12
  404e57:	53                   	push   rbx
  404e58:	48 83 ec 28          	sub    rsp,0x28
  404e5c:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
  404e63:	48 89 4d c0          	mov    QWORD PTR [rbp-0x40],rcx
  404e67:	4c 89 45 b8          	mov    QWORD PTR [rbp-0x48],r8
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  404e6b:	48 85 c0             	test   rax,rax
  404e6e:	0f 84 4c 03 00 00    	je     4051c0 <syncipc_reply_wait+0x390>
  404e74:	83 e8 01             	sub    eax,0x1
  404e77:	83 f8 18             	cmp    eax,0x18
  404e7a:	0f 87 40 03 00 00    	ja     4051c0 <syncipc_reply_wait+0x390>
  404e80:	48 b9 00 27 46 00 00 	movabs rcx,0x462700
  404e87:	00 00 00 
  404e8a:	45 31 ed             	xor    r13d,r13d
  404e8d:	48 8b 14 c1          	mov    rdx,QWORD PTR [rcx+rax*8]
  404e91:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  404e98:	0f 85 52 02 00 00    	jne    4050f0 <syncipc_reply_wait+0x2c0>
	if (unlikely(ep->server != t)) {
  404e9e:	48 a1 48 21 46 00 00 	movabs rax,ds:0x462148
  404ea5:	00 00 00 
  404ea8:	4c 39 e8             	cmp    rax,r13
  404eab:	0f 85 6f 02 00 00    	jne    405120 <syncipc_reply_wait+0x2f0>
	counts[type]++;
  404eb1:	48 a1 18 21 46 00 00 	movabs rax,ds:0x462118
  404eb8:	00 00 00 
	client             = ps_load(&ep->client);
  404ebb:	48 bf 40 21 46 00 00 	movabs rdi,0x462140
  404ec2:	00 00 00 
  404ec5:	49 be d0 35 41 00 00 	movabs r14,0x4135d0
  404ecc:	00 00 00 
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  404ecf:	49 bf 10 ce 40 00 00 	movabs r15,0x40ce10
  404ed6:	00 00 00 
  404ed9:	48 8b 1f             	mov    rbx,QWORD PTR [rdi]
	counts[type]++;
  404edc:	48 83 c0 01          	add    rax,0x1
  404ee0:	48 a3 18 21 46 00 00 	movabs ds:0x462118,rax
  404ee7:	00 00 00 
	ep->retvals->r0    = arg0;
  404eea:	48 a1 60 21 46 00 00 	movabs rax,ds:0x462160
  404ef1:	00 00 00 
	ep->retvals->ready = 1;
  404ef4:	c7 00 01 00 00 00    	mov    DWORD PTR [rax],0x1
	ep->retvals->r0    = arg0;
  404efa:	0f 11 40 08          	movups XMMWORD PTR [rax+0x8],xmm0
	return t != &g->idle_thd && t != &g->sched_thd;
  404efe:	48 b8 40 5f 5a 00 00 	movabs rax,0x5a5f40
  404f05:	00 00 00 
  404f08:	48 39 c3             	cmp    rbx,rax
	ep->retvals       = NULL;
  404f0b:	48 c7 47 20 00 00 00 	mov    QWORD PTR [rdi+0x20],0x0
  404f12:	00 
  404f13:	0f 95 c2             	setne  dl
  404f16:	48 83 e8 78          	sub    rax,0x78
	ep->client        = NULL;
  404f1a:	48 c7 07 00 00 00 00 	mov    QWORD PTR [rdi],0x0
  404f21:	48 39 c3             	cmp    rbx,rax
  404f24:	0f 95 c0             	setne  al
  404f27:	21 c2                	and    edx,eax
  404f29:	88 55 cf             	mov    BYTE PTR [rbp-0x31],dl
  404f2c:	0f 31                	rdtsc  
		ret = slm_switch_to(t, client, cos_sched_sync(), 1);
  404f2e:	41 ff d6             	call   r14
  404f31:	41 89 c4             	mov    r12d,eax
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  404f34:	8b 43 04             	mov    eax,DWORD PTR [rbx+0x4]
  404f37:	83 e8 02             	sub    eax,0x2
  404f3a:	83 f8 01             	cmp    eax,0x1
  404f3d:	0f 87 cd 00 00 00    	ja     405010 <syncipc_reply_wait+0x1e0>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  404f43:	41 ff d7             	call   r15
	prio = inherit_prio ? curr->priority : t->priority;
  404f46:	49 8b 75 30          	mov    rsi,QWORD PTR [r13+0x30]
	timeout = g->timeout_next;
  404f4a:	48 b8 c8 5f 5a 00 00 	movabs rax,0x5a5fc8
  404f51:	00 00 00 
  404f54:	4c 8b 00             	mov    r8,QWORD PTR [rax]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  404f57:	8b 03                	mov    eax,DWORD PTR [rbx]
  404f59:	a8 0b                	test   al,0xb
  404f5b:	0f 85 df 00 00 00    	jne    405040 <syncipc_reply_wait+0x210>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  404f61:	4c 89 c2             	mov    rdx,r8
  404f64:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  404f68:	44 89 e1             	mov    ecx,r12d
  404f6b:	48 b8 70 e1 40 00 00 	movabs rax,0x40e170
  404f72:	00 00 00 
  404f75:	ff d0                	call   rax
  404f77:	41 89 c0             	mov    r8d,eax
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  404f7a:	83 f8 ff             	cmp    eax,0xffffffff
  404f7d:	0f 84 1d 01 00 00    	je     4050a0 <syncipc_reply_wait+0x270>
  404f83:	0f 31                	rdtsc  
		if (unlikely(ret) && ret != -EAGAIN) return ret;
  404f85:	45 85 c0             	test   r8d,r8d
  404f88:	0f 85 8c 00 00 00    	jne    40501a <syncipc_reply_wait+0x1ea>
	counts[type]++;
  404f8e:	48 b8 00 21 46 00 00 	movabs rax,0x462100
  404f95:	00 00 00 
  404f98:	48 ba 10 f8 41 00 00 	movabs rdx,0x41f810
  404f9f:	00 00 00 
  404fa2:	66 0f 6f 02          	movdqa xmm0,XMMWORD PTR [rdx]
  404fa6:	66 0f d4 40 20       	paddq  xmm0,XMMWORD PTR [rax+0x20]
  404fab:	0f 29 40 20          	movaps XMMWORD PTR [rax+0x20],xmm0
  404faf:	90                   	nop
	while (ps_load(&ep->client) == NULL) ;
  404fb0:	48 b8 40 21 46 00 00 	movabs rax,0x462140
  404fb7:	00 00 00 
  404fba:	48 8b 00             	mov    rax,QWORD PTR [rax]
  404fbd:	48 85 c0             	test   rax,rax
  404fc0:	74 ee                	je     404fb0 <syncipc_reply_wait+0x180>
	*ret0 = ep->a0;
  404fc2:	48 a1 50 21 46 00 00 	movabs rax,ds:0x462150
  404fc9:	00 00 00 
  404fcc:	48 8b 75 c0          	mov    rsi,QWORD PTR [rbp-0x40]
  404fd0:	48 89 06             	mov    QWORD PTR [rsi],rax
	*ret1 = ep->a1;
  404fd3:	48 8b 75 b8          	mov    rsi,QWORD PTR [rbp-0x48]
  404fd7:	48 a1 58 21 46 00 00 	movabs rax,ds:0x462158
  404fde:	00 00 00 
  404fe1:	48 89 06             	mov    QWORD PTR [rsi],rax
	counts[type]++;
  404fe4:	48 a1 30 21 46 00 00 	movabs rax,ds:0x462130
  404feb:	00 00 00 
  404fee:	48 83 c0 01          	add    rax,0x1
  404ff2:	48 a3 30 21 46 00 00 	movabs ds:0x462130,rax
  404ff9:	00 00 00 
}
  404ffc:	48 83 c4 28          	add    rsp,0x28
  405000:	44 89 c0             	mov    eax,r8d
  405003:	5b                   	pop    rbx
  405004:	41 5c                	pop    r12
  405006:	41 5d                	pop    r13
  405008:	41 5e                	pop    r14
  40500a:	41 5f                	pop    r15
  40500c:	5d                   	pop    rbp
  40500d:	c3                   	ret    
  40500e:	66 90                	xchg   ax,ax
  405010:	0f 31                	rdtsc  
  405012:	41 b8 01 00 00 00    	mov    r8d,0x1
  405018:	eb e2                	jmp    404ffc <syncipc_reply_wait+0x1cc>
		if (unlikely(ret) && ret != -EAGAIN) return ret;
  40501a:	41 83 f8 f5          	cmp    r8d,0xfffffff5
  40501e:	75 dc                	jne    404ffc <syncipc_reply_wait+0x1cc>
	counts[type]++;
  405020:	48 a1 20 21 46 00 00 	movabs rax,ds:0x462120
  405027:	00 00 00 
  40502a:	48 83 c0 01          	add    rax,0x1
  40502e:	48 a3 20 21 46 00 00 	movabs ds:0x462120,rax
  405035:	00 00 00 
	} while (ret == -EAGAIN);
  405038:	e9 ef fe ff ff       	jmp    404f2c <syncipc_reply_wait+0xfc>
  40503d:	0f 1f 00             	nop    DWORD PTR [rax]
			timeout = TCAP_TIME_NIL;
  405040:	48 bf c8 5e 5a 00 00 	movabs rdi,0x5a5ec8
  405047:	00 00 00 
  40504a:	31 c9                	xor    ecx,ecx
  40504c:	48 39 fb             	cmp    rbx,rdi
  40504f:	49 0f 45 c8          	cmovne rcx,r8
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  405053:	a8 02                	test   al,0x2
  405055:	0f 85 75 01 00 00    	jne    4051d0 <syncipc_reply_wait+0x3a0>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  40505b:	49 89 c8             	mov    r8,rcx
  40505e:	a8 01                	test   al,0x1
  405060:	0f 84 fb fe ff ff    	je     404f61 <syncipc_reply_wait+0x131>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  405066:	4c 8b 53 08          	mov    r10,QWORD PTR [rbx+0x8]
  40506a:	48 89 f2             	mov    rdx,rsi
  40506d:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  405071:	45 89 e1             	mov    r9d,r12d
  405074:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  40507b:	00 00 00 
  40507e:	4c 8b 00             	mov    r8,QWORD PTR [rax]
  405081:	48 b8 f0 35 41 00 00 	movabs rax,0x4135f0
  405088:	00 00 00 
  40508b:	4c 89 d6             	mov    rsi,r10
  40508e:	ff d0                	call   rax
  405090:	41 89 c0             	mov    r8d,eax
  405093:	e9 eb fe ff ff       	jmp    404f83 <syncipc_reply_wait+0x153>
  405098:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40509f:	00 
	return t != &g->idle_thd && t != &g->sched_thd;
  4050a0:	80 7d cf 00          	cmp    BYTE PTR [rbp-0x31],0x0
  4050a4:	75 3a                	jne    4050e0 <syncipc_reply_wait+0x2b0>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  4050a6:	49 8b 55 30          	mov    rdx,QWORD PTR [r13+0x30]
  4050aa:	45 89 e1             	mov    r9d,r12d
  4050ad:	31 c9                	xor    ecx,ecx
  4050af:	31 f6                	xor    esi,esi
  4050b1:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  4050b8:	00 00 00 
  4050bb:	4c 8b 00             	mov    r8,QWORD PTR [rax]
  4050be:	48 8b 78 f0          	mov    rdi,QWORD PTR [rax-0x10]
  4050c2:	48 b8 f0 35 41 00 00 	movabs rax,0x4135f0
  4050c9:	00 00 00 
  4050cc:	ff d0                	call   rax
  4050ce:	41 89 c0             	mov    r8d,eax
  4050d1:	e9 ad fe ff ff       	jmp    404f83 <syncipc_reply_wait+0x153>
  4050d6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4050dd:	00 00 00 
  4050e0:	0f 31                	rdtsc  
		if (unlikely(ret) && ret != -EAGAIN) return ret;
  4050e2:	e9 15 ff ff ff       	jmp    404ffc <syncipc_reply_wait+0x1cc>
  4050e7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  4050ee:	00 00 
  4050f0:	83 e2 01             	and    edx,0x1
  4050f3:	0f 85 a5 fd ff ff    	jne    404e9e <syncipc_reply_wait+0x6e>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  4050f9:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  4050fd:	48 8d 04 50          	lea    rax,[rax+rdx*2]
  405101:	48 c1 e0 04          	shl    rax,0x4
  405105:	4c 8d ac 01 c8 00 00 	lea    r13,[rcx+rax*1+0xc8]
  40510c:	00 
	if (unlikely(ep->server != t)) {
  40510d:	48 a1 48 21 46 00 00 	movabs rax,ds:0x462148
  405114:	00 00 00 
  405117:	4c 39 e8             	cmp    rax,r13
  40511a:	0f 84 91 fd ff ff    	je     404eb1 <syncipc_reply_wait+0x81>
		if (ep->server != NULL)         return -1;
  405120:	48 85 c0             	test   rax,rax
  405123:	0f 85 22 01 00 00    	jne    40524b <syncipc_reply_wait+0x41b>
        __asm__ __volatile__("lock " PS_CAS_STR
  405129:	48 be 40 21 46 00 00 	movabs rsi,0x462140
  405130:	00 00 00 
  405133:	f0 4c 0f b1 6e 08    	lock cmpxchg QWORD PTR [rsi+0x8],r13
  405139:	0f 94 c0             	sete   al
		if (!ps_cas((unsigned long *)&ep->server, 0, (unsigned long)t)) return -1;
  40513c:	84 c0                	test   al,al
  40513e:	0f 84 07 01 00 00    	je     40524b <syncipc_reply_wait+0x41b>
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  405144:	31 d2                	xor    edx,edx
  405146:	be 0b 00 00 00       	mov    esi,0xb
  40514b:	4c 89 ef             	mov    rdi,r13
  40514e:	48 b8 70 4a 41 00 00 	movabs rax,0x414a70
  405155:	00 00 00 
  405158:	ff d0                	call   rax
  40515a:	41 89 c0             	mov    r8d,eax
		assert(ret == 0);
  40515d:	85 c0                	test   eax,eax
  40515f:	0f 85 96 00 00 00    	jne    4051fb <syncipc_reply_wait+0x3cb>
		assert(ep->server == t);
  405165:	48 b8 40 21 46 00 00 	movabs rax,0x462140
  40516c:	00 00 00 
  40516f:	4c 39 68 08          	cmp    QWORD PTR [rax+0x8],r13
  405173:	0f 85 aa 00 00 00    	jne    405223 <syncipc_reply_wait+0x3f3>
  405179:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		while (ps_load(&ep->client) == NULL) ;
  405180:	48 b8 40 21 46 00 00 	movabs rax,0x462140
  405187:	00 00 00 
  40518a:	48 8b 00             	mov    rax,QWORD PTR [rax]
  40518d:	48 85 c0             	test   rax,rax
  405190:	74 ee                	je     405180 <syncipc_reply_wait+0x350>
		*ret0 = ep->a0;
  405192:	48 a1 50 21 46 00 00 	movabs rax,ds:0x462150
  405199:	00 00 00 
  40519c:	48 8b 75 c0          	mov    rsi,QWORD PTR [rbp-0x40]
  4051a0:	48 89 06             	mov    QWORD PTR [rsi],rax
		*ret1 = ep->a1;
  4051a3:	48 8b 75 b8          	mov    rsi,QWORD PTR [rbp-0x48]
  4051a7:	48 a1 58 21 46 00 00 	movabs rax,ds:0x462158
  4051ae:	00 00 00 
  4051b1:	48 89 06             	mov    QWORD PTR [rsi],rax
		return 0;
  4051b4:	e9 43 fe ff ff       	jmp    404ffc <syncipc_reply_wait+0x1cc>
  4051b9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  4051c0:	45 31 ed             	xor    r13d,r13d
  4051c3:	e9 d6 fc ff ff       	jmp    404e9e <syncipc_reply_wait+0x6e>
  4051c8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4051cf:	00 
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  4051d0:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  4051d7:	00 00 00 
  4051da:	4c 89 c6             	mov    rsi,r8
  4051dd:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  4051e0:	48 8b 7b 28          	mov    rdi,QWORD PTR [rbx+0x28]
  4051e4:	48 b8 60 36 41 00 00 	movabs rax,0x413660
  4051eb:	00 00 00 
  4051ee:	44 89 e1             	mov    ecx,r12d
  4051f1:	ff d0                	call   rax
  4051f3:	41 89 c0             	mov    r8d,eax
  4051f6:	e9 88 fd ff ff       	jmp    404f83 <syncipc_reply_wait+0x153>
  4051fb:	48 bf 98 f7 41 00 00 	movabs rdi,0x41f798
  405202:	00 00 00 
  405205:	be 24 00 00 00       	mov    esi,0x24
  40520a:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  405211:	00 00 00 
  405214:	ff d0                	call   rax
		assert(ret == 0);
  405216:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40521d:	00 00 00 00 
  405221:	0f 0b                	ud2    
  405223:	48 bf c0 f7 41 00 00 	movabs rdi,0x41f7c0
  40522a:	00 00 00 
  40522d:	be 24 00 00 00       	mov    esi,0x24
  405232:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  405239:	00 00 00 
  40523c:	ff d0                	call   rax
		assert(ep->server == t);
  40523e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  405245:	00 00 00 00 
  405249:	0f 0b                	ud2    
		if (ep->server != NULL)         return -1;
  40524b:	41 b8 ff ff ff ff    	mov    r8d,0xffffffff
  405251:	e9 a6 fd ff ff       	jmp    404ffc <syncipc_reply_wait+0x1cc>
  405256:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40525d:	00 00 00 

0000000000405260 <sched_aep_create_closure>:
{
  405260:	f3 0f 1e fa          	endbr64 
}
  405264:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
  40526b:	c3                   	ret    
  40526c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000405270 <sched_get_cpu_freq>:
{
  405270:	f3 0f 1e fa          	endbr64 
	return slm_get_cycs_per_usec();
  405274:	48 b8 e0 6d 41 00 00 	movabs rax,0x416de0
  40527b:	00 00 00 
  40527e:	ff e0                	jmp    rax

0000000000405280 <slm_ipithd_create>:
{
  405280:	f3 0f 1e fa          	endbr64 
	struct slm_ipi_percore   *ipi_data = slm_ipi_percore_get(cos_cpuid());
  405284:	48 b8 c0 5d 41 00 00 	movabs rax,0x415dc0
  40528b:	00 00 00 
{
  40528e:	55                   	push   rbp
  40528f:	48 89 e5             	mov    rbp,rsp
  405292:	41 57                	push   r15
  405294:	49 89 f7             	mov    r15,rsi
  405297:	41 56                	push   r14
  405299:	49 89 ce             	mov    r14,rcx
  40529c:	41 55                	push   r13
  40529e:	4d 89 c5             	mov    r13,r8
  4052a1:	41 54                	push   r12
  4052a3:	49 89 fc             	mov    r12,rdi
	struct slm_ipi_percore   *ipi_data = slm_ipi_percore_get(cos_cpuid());
  4052a6:	31 ff                	xor    edi,edi
{
  4052a8:	53                   	push   rbx
  4052a9:	48 83 ec 28          	sub    rsp,0x28
  4052ad:	89 55 bc             	mov    DWORD PTR [rbp-0x44],edx
	struct slm_ipi_percore   *ipi_data = slm_ipi_percore_get(cos_cpuid());
  4052b0:	ff d0                	call   rax
	r->rcv = capmgr_rcv_alloc(fn, data, flags, &r->asnd, &_thd, &_tid);
  4052b2:	4c 8d 45 c0          	lea    r8,[rbp-0x40]
  4052b6:	4c 89 fe             	mov    rsi,r15
  4052b9:	8b 55 bc             	mov    edx,DWORD PTR [rbp-0x44]
	struct slm_ipi_percore   *ipi_data = slm_ipi_percore_get(cos_cpuid());
  4052bc:	48 89 c3             	mov    rbx,rax
	r->rcv = capmgr_rcv_alloc(fn, data, flags, &r->asnd, &_thd, &_tid);
  4052bf:	48 8d 48 08          	lea    rcx,[rax+0x8]
  4052c3:	4c 8d 4d c8          	lea    r9,[rbp-0x38]
  4052c7:	4c 89 e7             	mov    rdi,r12
  4052ca:	48 b8 f0 af 40 00 00 	movabs rax,0x40aff0
  4052d1:	00 00 00 
  4052d4:	ff d0                	call   rax
	r->tid = _tid;
  4052d6:	48 8b 75 c8          	mov    rsi,QWORD PTR [rbp-0x38]
	t = slm_thd_mem_alloc(_thd, _tid, thdcap, tid);
  4052da:	4c 8b 45 c0          	mov    r8,QWORD PTR [rbp-0x40]
	r->cpuid = cos_cpuid();
  4052de:	c7 43 10 00 00 00 00 	mov    DWORD PTR [rbx+0x10],0x0
	r->rcv = capmgr_rcv_alloc(fn, data, flags, &r->asnd, &_thd, &_tid);
  4052e5:	48 89 03             	mov    QWORD PTR [rbx],rax
	r->tid = _tid;
  4052e8:	66 49 0f 6e c0       	movq   xmm0,r8
  4052ed:	66 48 0f 6e ce       	movq   xmm1,rsi
  4052f2:	48 89 73 18          	mov    QWORD PTR [rbx+0x18],rsi
	t = slm_thd_mem_alloc(_thd, _tid, thdcap, tid);
  4052f6:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  4052fa:	85 f6                	test   esi,esi
  4052fc:	0f 84 a6 01 00 00    	je     4054a8 <slm_ipithd_create+0x228>
  405302:	8d 56 ff             	lea    edx,[rsi-0x1]
  405305:	83 fa 18             	cmp    edx,0x18
  405308:	0f 87 9a 01 00 00    	ja     4054a8 <slm_ipithd_create+0x228>
	if (*state != SS_STATE_FREE ||
  40530e:	49 bf 00 27 46 00 00 	movabs r15,0x462700
  405315:	00 00 00 
  405318:	49 83 3c d7 00       	cmp    QWORD PTR [r15+rdx*8],0x0
  40531d:	0f 85 85 01 00 00    	jne    4054a8 <slm_ipithd_create+0x228>
  405323:	45 31 c9             	xor    r9d,r9d
  405326:	b9 01 00 00 00       	mov    ecx,0x1
  40532b:	4c 89 c8             	mov    rax,r9
  40532e:	f0 49 0f b1 0c d7    	lock cmpxchg QWORD PTR [r15+rdx*8],rcx
  405334:	0f 94 c0             	sete   al
  405337:	84 c0                	test   al,al
  405339:	0f 84 69 01 00 00    	je     4054a8 <slm_ipithd_create+0x228>
  40533f:	48 8d 04 92          	lea    rax,[rdx+rdx*4]
  405343:	b9 16 00 00 00       	mov    ecx,0x16
  405348:	48 8d 14 42          	lea    rdx,[rdx+rax*2]
  40534c:	4c 89 c8             	mov    rax,r9
  40534f:	48 c1 e2 04          	shl    rdx,0x4
  405353:	4d 8d a4 17 c8 00 00 	lea    r12,[r15+rdx*1+0xc8]
  40535a:	00 
  40535b:	4c 89 e7             	mov    rdi,r12
  40535e:	f3 48 ab             	rep stos QWORD PTR es:[rdi],rax
	assert(_cap != 0 && _tid != 0);
  405361:	4d 85 c0             	test   r8,r8
  405364:	0f 84 93 01 00 00    	je     4054fd <slm_ipithd_create+0x27d>
	t->resources = (struct slm_resources_thd) {
  40536a:	48 b8 10 27 46 00 00 	movabs rax,0x462710
  405371:	00 00 00 
  405374:	48 bb c0 5e 5a 00 00 	movabs rbx,0x5a5ec0
  40537b:	00 00 00 
  40537e:	0f 29 84 10 50 01 00 	movaps XMMWORD PTR [rax+rdx*1+0x150],xmm0
  405385:	00 
  405386:	48 a1 40 b0 42 00 00 	movabs rax,ds:0x42b040
  40538d:	00 00 00 
  405390:	49 89 84 17 70 01 00 	mov    QWORD PTR [r15+rdx*1+0x170],rax
  405397:	00 
	*thd = _cap;
  405398:	4d 89 06             	mov    QWORD PTR [r14],r8
	*tid = _tid;
  40539b:	4c 8d 73 08          	lea    r14,[rbx+0x8]
  40539f:	49 89 75 00          	mov    QWORD PTR [r13+0x0],rsi
	assert(current);
  4053a3:	49 bd d0 35 41 00 00 	movabs r13,0x4135d0
  4053aa:	00 00 00 
		tok    = cos_sched_sync();
  4053ad:	41 ff d5             	call   r13
  4053b0:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4053b3:	48 8b 03             	mov    rax,QWORD PTR [rbx]
		if (unlikely(owner)) {
  4053b6:	48 89 c1             	mov    rcx,rax
  4053b9:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  4053bd:	0f 85 62 01 00 00    	jne    405525 <slm_ipithd_create+0x2a5>
  4053c3:	f0 4c 0f b1 33       	lock cmpxchg QWORD PTR [rbx],r14
  4053c8:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4053cb:	84 c0                	test   al,al
  4053cd:	74 de                	je     4053ad <slm_ipithd_create+0x12d>
	if (slm_thd_init(thd, _thd, _tid)) ERR_THROW(NULL, free);
  4053cf:	48 8b 55 c8          	mov    rdx,QWORD PTR [rbp-0x38]
  4053d3:	48 8b 75 c0          	mov    rsi,QWORD PTR [rbp-0x40]
  4053d7:	4c 89 e7             	mov    rdi,r12
  4053da:	48 b8 20 5e 41 00 00 	movabs rax,0x415e20
  4053e1:	00 00 00 
  4053e4:	ff d0                	call   rax
  4053e6:	85 c0                	test   eax,eax
  4053e8:	0f 85 e2 00 00 00    	jne    4054d0 <slm_ipithd_create+0x250>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  4053ee:	48 ba c8 27 46 00 00 	movabs rdx,0x4627c8
  4053f5:	00 00 00 
  4053f8:	49 39 d4             	cmp    r12,rdx
  4053fb:	0f 82 d4 00 00 00    	jb     4054d5 <slm_ipithd_create+0x255>
  405401:	48 8d 82 80 10 00 00 	lea    rax,[rdx+0x1080]
  405408:	49 39 c4             	cmp    r12,rax
  40540b:	0f 87 c4 00 00 00    	ja     4054d5 <slm_ipithd_create+0x255>
  405411:	4c 89 e0             	mov    rax,r12
  405414:	48 29 d0             	sub    rax,rdx
  405417:	48 c1 f8 04          	sar    rax,0x4
	*state = val | (*state & 1);
  40541b:	69 c0 a3 8b 2e ba    	imul   eax,eax,0xba2e8ba3
  405421:	49 8b 14 c7          	mov    rdx,QWORD PTR [r15+rax*8]
  405425:	48 83 ca fe          	or     rdx,0xfffffffffffffffe
  405429:	49 89 14 c7          	mov    QWORD PTR [r15+rax*8],rdx
	assert((*state & 1) == SS_STATE_CONS);
  40542d:	48 83 fa ff          	cmp    rdx,0xffffffffffffffff
  405431:	0f 85 63 01 00 00    	jne    40559a <slm_ipithd_create+0x31a>
	*state &= ~SS_STATE_CONS;
  405437:	49 c7 04 c7 fe ff ff 	mov    QWORD PTR [r15+rax*8],0xfffffffffffffffe
  40543e:	ff 
{ __asm__ __volatile__("mfence" ::: "memory"); }
  40543f:	0f ae f0             	mfence 
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  405442:	49 be b0 5f 41 00 00 	movabs r14,0x415fb0
  405449:	00 00 00 
	assert(*state != 0);
  40544c:	49 83 3c c7 00       	cmp    QWORD PTR [r15+rax*8],0x0
  405451:	75 19                	jne    40546c <slm_ipithd_create+0x1ec>
  405453:	e9 1a 01 00 00       	jmp    405572 <slm_ipithd_create+0x2f2>
  405458:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40545f:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  405460:	f0 48 0f b1 13       	lock cmpxchg QWORD PTR [rbx],rdx
  405465:	0f 94 c0             	sete   al
	while (ret != 0) {
  405468:	84 c0                	test   al,al
  40546a:	75 24                	jne    405490 <slm_ipithd_create+0x210>
		tok    = cos_sched_sync();
  40546c:	41 ff d5             	call   r13
  40546f:	89 c1                	mov    ecx,eax
  405471:	48 8b 03             	mov    rax,QWORD PTR [rbx]
		if (unlikely(contention)) {
  405474:	48 89 c2             	mov    rdx,rax
  405477:	83 e2 01             	and    edx,0x1
  40547a:	74 e4                	je     405460 <slm_ipithd_create+0x1e0>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  40547c:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  40547f:	48 89 c2             	mov    rdx,rax
  405482:	48 89 df             	mov    rdi,rbx
  405485:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  405489:	41 ff d6             	call   r14
  40548c:	85 c0                	test   eax,eax
  40548e:	75 dc                	jne    40546c <slm_ipithd_create+0x1ec>
}
  405490:	48 83 c4 28          	add    rsp,0x28
  405494:	4c 89 e0             	mov    rax,r12
  405497:	5b                   	pop    rbx
  405498:	41 5c                	pop    r12
  40549a:	41 5d                	pop    r13
  40549c:	41 5e                	pop    r14
  40549e:	41 5f                	pop    r15
  4054a0:	5d                   	pop    rbp
  4054a1:	c3                   	ret    
  4054a2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4054a8:	48 bf f0 f5 41 00 00 	movabs rdi,0x41f5f0
  4054af:	00 00 00 
  4054b2:	be 23 00 00 00       	mov    esi,0x23
  4054b7:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4054be:	00 00 00 
  4054c1:	ff d0                	call   rax
	if (!t) assert(0);
  4054c3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4054ca:	00 00 00 00 
  4054ce:	0f 0b                	ud2    
	ret = NULL;
  4054d0:	45 31 e4             	xor    r12d,r12d
	return ret;
  4054d3:	eb bb                	jmp    405490 <slm_ipithd_create+0x210>
  4054d5:	48 bf c8 f5 41 00 00 	movabs rdi,0x41f5c8
  4054dc:	00 00 00 
  4054df:	be 23 00 00 00       	mov    esi,0x23
  4054e4:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4054eb:	00 00 00 
  4054ee:	ff d0                	call   rax
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  4054f0:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4054f7:	00 00 00 00 
  4054fb:	0f 0b                	ud2    
  4054fd:	48 bf 18 f6 41 00 00 	movabs rdi,0x41f618
  405504:	00 00 00 
  405507:	be 23 00 00 00       	mov    esi,0x23
  40550c:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  405513:	00 00 00 
  405516:	ff d0                	call   rax
	assert(_cap != 0 && _tid != 0);
  405518:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40551f:	00 00 00 00 
  405523:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  405525:	41 89 c0             	mov    r8d,eax
  405528:	48 89 c6             	mov    rsi,rax
  40552b:	4c 89 f2             	mov    rdx,r14
  40552e:	48 89 df             	mov    rdi,rbx
  405531:	48 b8 50 5f 41 00 00 	movabs rax,0x415f50
  405538:	00 00 00 
  40553b:	41 83 e0 01          	and    r8d,0x1
  40553f:	ff d0                	call   rax
			assert(ret != -EBUSY);
  405541:	83 f8 f0             	cmp    eax,0xfffffff0
  405544:	0f 85 63 fe ff ff    	jne    4053ad <slm_ipithd_create+0x12d>
  40554a:	48 bf 80 f2 41 00 00 	movabs rdi,0x41f280
  405551:	00 00 00 
  405554:	be 59 00 00 00       	mov    esi,0x59
  405559:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  405560:	00 00 00 
  405563:	ff d0                	call   rax
  405565:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40556c:	00 00 00 00 
  405570:	0f 0b                	ud2    
  405572:	48 bf a8 f6 41 00 00 	movabs rdi,0x41f6a8
  405579:	00 00 00 
  40557c:	be 61 00 00 00       	mov    esi,0x61
  405581:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  405588:	00 00 00 
  40558b:	ff d0                	call   rax
  40558d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  405594:	00 00 00 00 
  405598:	0f 0b                	ud2    
  40559a:	48 bf 40 f6 41 00 00 	movabs rdi,0x41f640
  4055a1:	00 00 00 
  4055a4:	be 61 00 00 00       	mov    esi,0x61
  4055a9:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4055b0:	00 00 00 
  4055b3:	ff d0                	call   rax
	assert((*state & 1) == SS_STATE_CONS);
  4055b5:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4055bc:	00 00 00 00 
  4055c0:	0f 0b                	ud2    
  4055c2:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4055c9:	00 00 00 00 
  4055cd:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004055d0 <parallel_main>:

static coreid_t _init_core_id = 0;

void
parallel_main(coreid_t cid)
{
  4055d0:	f3 0f 1e fa          	endbr64 
	if (cid == _init_core_id) printc("Starting scheduler loop...\n");
  4055d4:	48 b8 e8 26 46 00 00 	movabs rax,0x4626e8
  4055db:	00 00 00 
  4055de:	66 39 38             	cmp    WORD PTR [rax],di
  4055e1:	74 0d                	je     4055f0 <parallel_main+0x20>
	slm_sched_loop_nonblock();
  4055e3:	48 b8 10 6e 41 00 00 	movabs rax,0x416e10
  4055ea:	00 00 00 
  4055ed:	ff e0                	jmp    rax
  4055ef:	90                   	nop
	if (cid == _init_core_id) printc("Starting scheduler loop...\n");
  4055f0:	48 bf 00 f2 41 00 00 	movabs rdi,0x41f200
  4055f7:	00 00 00 
{
  4055fa:	55                   	push   rbp
	if (cid == _init_core_id) printc("Starting scheduler loop...\n");
  4055fb:	31 c0                	xor    eax,eax
  4055fd:	48 ba 40 0c 40 00 00 	movabs rdx,0x400c40
  405604:	00 00 00 
{
  405607:	48 89 e5             	mov    rbp,rsp
	if (cid == _init_core_id) printc("Starting scheduler loop...\n");
  40560a:	ff d2                	call   rdx
}
  40560c:	5d                   	pop    rbp
	slm_sched_loop_nonblock();
  40560d:	48 b8 10 6e 41 00 00 	movabs rax,0x416e10
  405614:	00 00 00 
  405617:	ff e0                	jmp    rax
  405619:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000405620 <cos_parallel_init>:

void
cos_parallel_init(coreid_t cid, int init_core, int ncores)
{
  405620:	f3 0f 1e fa          	endbr64 
  405624:	55                   	push   rbp
  405625:	48 89 e5             	mov    rbp,rsp
  405628:	53                   	push   rbx
  405629:	48 83 ec 28          	sub    rsp,0x28
	struct slm_thd_container *t;
	struct slm_thd *r;
	thdcap_t thdcap, ipithdcap;
	arcvcap_t rcvcap;
	thdid_t tid, ipitid;
	if (init_core) {
  40562d:	85 f6                	test   esi,esi
  40562f:	74 0c                	je     40563d <cos_parallel_init+0x1d>
		_init_core_id = cid;
  405631:	89 f8                	mov    eax,edi
  405633:	66 a3 e8 26 46 00 00 	movabs ds:0x4626e8,ax
  40563a:	00 00 00 
	} 
	struct slm_ipi_percore *ipi_data = slm_ipi_percore_get(cos_cpuid());
  40563d:	48 b8 c0 5d 41 00 00 	movabs rax,0x415dc0
  405644:	00 00 00 
  405647:	31 ff                	xor    edi,edi
  405649:	ff d0                	call   rax
  40564b:	48 89 c3             	mov    rbx,rax

	cos_defcompinfo_sched_init();
  40564e:	48 b8 50 d1 40 00 00 	movabs rax,0x40d150
  405655:	00 00 00 
  405658:	ff d0                	call   rax

	t = slm_thd_alloc(slm_idle, NULL, &thdcap, &tid);
  40565a:	31 f6                	xor    esi,esi
  40565c:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  405660:	48 8d 55 d0          	lea    rdx,[rbp-0x30]
  405664:	48 bf 90 4e 41 00 00 	movabs rdi,0x414e90
  40566b:	00 00 00 
  40566e:	48 b8 10 58 40 00 00 	movabs rax,0x405810
  405675:	00 00 00 
  405678:	ff d0                	call   rax
	if (!t) BUG();
  40567a:	48 85 c0             	test   rax,rax
  40567d:	0f 84 ed 00 00 00    	je     405770 <cos_parallel_init+0x150>

	slm_init(thdcap, tid);
  405683:	48 8b 75 e0          	mov    rsi,QWORD PTR [rbp-0x20]
  405687:	48 8b 7d d0          	mov    rdi,QWORD PTR [rbp-0x30]
  40568b:	48 b8 30 6e 41 00 00 	movabs rax,0x416e30
  405692:	00 00 00 
  405695:	ff d0                	call   rax

	r = slm_ipithd_create(slm_ipi_process, NULL, 0, &ipithdcap, &ipitid);
  405697:	31 d2                	xor    edx,edx
  405699:	31 f6                	xor    esi,esi
  40569b:	4c 8d 45 e8          	lea    r8,[rbp-0x18]
  40569f:	48 bf 10 0d 40 00 00 	movabs rdi,0x400d10
  4056a6:	00 00 00 
  4056a9:	48 8d 4d d8          	lea    rcx,[rbp-0x28]
  4056ad:	48 b8 80 52 40 00 00 	movabs rax,0x405280
  4056b4:	00 00 00 
  4056b7:	ff d0                	call   rax
	if (!r) BUG();
  4056b9:	48 85 c0             	test   rax,rax
  4056bc:	0f 84 86 00 00 00    	je     405748 <cos_parallel_init+0x128>
	return &ss_thd_get(id)->thd;
  4056c2:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  4056c6:	85 c0                	test   eax,eax
  4056c8:	74 4e                	je     405718 <cos_parallel_init+0xf8>
  4056ca:	83 e8 01             	sub    eax,0x1
  4056cd:	83 f8 18             	cmp    eax,0x18
  4056d0:	77 46                	ja     405718 <cos_parallel_init+0xf8>
  4056d2:	48 ba 00 27 46 00 00 	movabs rdx,0x462700
  4056d9:	00 00 00 
  4056dc:	48 8b 0c c2          	mov    rcx,QWORD PTR [rdx+rax*8]
	return ((state & ~1) != 0) && ((state & 1) == SS_STATE_ALLOC);
  4056e0:	48 f7 c1 fe ff ff ff 	test   rcx,0xfffffffffffffffe
  4056e7:	74 2f                	je     405718 <cos_parallel_init+0xf8>
  4056e9:	83 e1 01             	and    ecx,0x1
  4056ec:	75 2a                	jne    405718 <cos_parallel_init+0xf8>
	return &ss_thd_get(id)->thd;
  4056ee:	48 8d 0c 80          	lea    rcx,[rax+rax*4]
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  4056f2:	be 01 00 00 00       	mov    esi,0x1
	return &ss_thd_get(id)->thd;
  4056f7:	48 8d 04 48          	lea    rax,[rax+rcx*2]
  4056fb:	48 c1 e0 04          	shl    rax,0x4
  4056ff:	48 8d bc 02 c8 00 00 	lea    rdi,[rdx+rax*1+0xc8]
  405706:	00 
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  405707:	ba 14 00 00 00       	mov    edx,0x14
  40570c:	48 b8 70 4a 41 00 00 	movabs rax,0x414a70
  405713:	00 00 00 
  405716:	ff d0                	call   rax

CK_CC_INLINE static void
ck_ring_init(struct ck_ring *ring, unsigned int size)
{

	ring->size = size;
  405718:	48 b8 20 f8 41 00 00 	movabs rax,0x41f820
  40571f:	00 00 00 
	ring->mask = size - 1;
	ring->p_tail = 0;
  405722:	48 c7 43 60 00 00 00 	mov    QWORD PTR [rbx+0x60],0x0
  405729:	00 
	ring->size = size;
  40572a:	48 8b 00             	mov    rax,QWORD PTR [rax]
	ring->p_head = 0;
	ring->c_head = 0;
  40572d:	c7 43 20 00 00 00 00 	mov    DWORD PTR [rbx+0x20],0x0
	ring->size = size;
  405734:	48 89 83 a0 00 00 00 	mov    QWORD PTR [rbx+0xa0],rax
	sched_thd_param_set(ipitid, sched_param_pack(SCHEDP_PRIO, SLM_IPI_THD_PRIO));
	ck_ring_init(&ipi_data->ring, PAGE_SIZE / sizeof(struct slm_ipi_event));
}
  40573b:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
  40573f:	c9                   	leave  
  405740:	c3                   	ret    
  405741:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  405748:	48 bf f7 f7 41 00 00 	movabs rdi,0x41f7f7
  40574f:	00 00 00 
  405752:	be 11 00 00 00       	mov    esi,0x11
  405757:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40575e:	00 00 00 
  405761:	ff d0                	call   rax
	if (!r) BUG();
  405763:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40576a:	00 00 00 00 
  40576e:	0f 0b                	ud2    
  405770:	48 bf e5 f7 41 00 00 	movabs rdi,0x41f7e5
  405777:	00 00 00 
  40577a:	be 11 00 00 00       	mov    esi,0x11
  40577f:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  405786:	00 00 00 
  405789:	ff d0                	call   rax
	if (!t) BUG();
  40578b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  405792:	00 00 00 00 
  405796:	0f 0b                	ud2    
  405798:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40579f:	00 

00000000004057a0 <cos_init>:

void
cos_init(void)
{
  4057a0:	f3 0f 1e fa          	endbr64 
	struct cos_compinfo *boot_info = cos_compinfo_get(cos_defcompinfo_curr_get());
  4057a4:	48 b8 10 ce 40 00 00 	movabs rax,0x40ce10
  4057ab:	00 00 00 
{
  4057ae:	55                   	push   rbp
  4057af:	48 89 e5             	mov    rbp,rsp
	struct cos_compinfo *boot_info = cos_compinfo_get(cos_defcompinfo_curr_get());
  4057b2:	ff d0                	call   rax
  4057b4:	48 89 c7             	mov    rdi,rax
  4057b7:	48 b8 20 ce 40 00 00 	movabs rax,0x40ce20
  4057be:	00 00 00 
  4057c1:	ff d0                	call   rax

	cos_meminfo_init(&(boot_info->mi), BOOT_MEM_KM_BASE, COS_MEM_KERN_PA_SZ, BOOT_CAPTBL_SELF_UNTYPED_PT);
  4057c3:	b9 14 00 00 00       	mov    ecx,0x14
  4057c8:	48 ba 00 00 00 fc 01 	movabs rdx,0x1fc000000
  4057cf:	00 00 00 
  4057d2:	48 be 00 00 00 00 80 	movabs rsi,0x8000000000
  4057d9:	00 00 00 
  4057dc:	48 8d 78 68          	lea    rdi,[rax+0x68]
  4057e0:	48 b8 c0 f2 40 00 00 	movabs rax,0x40f2c0
  4057e7:	00 00 00 
  4057ea:	ff d0                	call   rax
	extern void calculate_initialization_schedule(void);
	calculate_initialization_schedule();
  4057ec:	48 b8 90 02 40 00 00 	movabs rax,0x400290
  4057f3:	00 00 00 
  4057f6:	ff d0                	call   rax
	cos_defcompinfo_init();
}
  4057f8:	5d                   	pop    rbp
	cos_defcompinfo_init();
  4057f9:	48 b8 a0 ce 40 00 00 	movabs rax,0x40cea0
  405800:	00 00 00 
  405803:	ff e0                	jmp    rax
  405805:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40580c:	00 00 00 
  40580f:	90                   	nop

0000000000405810 <slm_thd_alloc>:
#include <slm_modules.h>
#include <capmgr.h>

struct slm_thd_container *
slm_thd_alloc(thd_fn_t fn, void *data, thdcap_t *thd, thdid_t *tid)
{
  405810:	f3 0f 1e fa          	endbr64 
	thdid_t _tid;
	thdcap_t _cap;
	struct slm_thd_container *ret = NULL;

	_cap = capmgr_thd_create(fn, data, &_tid);
  405814:	48 b8 30 af 40 00 00 	movabs rax,0x40af30
  40581b:	00 00 00 
{
  40581e:	55                   	push   rbp
  40581f:	48 89 e5             	mov    rbp,rsp
  405822:	41 55                	push   r13
  405824:	49 89 cd             	mov    r13,rcx
  405827:	41 54                	push   r12
  405829:	49 89 d4             	mov    r12,rdx
	_cap = capmgr_thd_create(fn, data, &_tid);
  40582c:	48 8d 55 e8          	lea    rdx,[rbp-0x18]
{
  405830:	48 83 ec 10          	sub    rsp,0x10
	_cap = capmgr_thd_create(fn, data, &_tid);
  405834:	ff d0                	call   rax
  405836:	48 89 c7             	mov    rdi,rax
	if (_cap <= 0) return NULL;
  405839:	31 c0                	xor    eax,eax
  40583b:	48 85 ff             	test   rdi,rdi
  40583e:	74 16                	je     405856 <slm_thd_alloc+0x46>

	return slm_thd_mem_alloc(_cap, _tid, thd, tid);
  405840:	48 8b 75 e8          	mov    rsi,QWORD PTR [rbp-0x18]
  405844:	4c 89 e9             	mov    rcx,r13
  405847:	4c 89 e2             	mov    rdx,r12
  40584a:	48 b8 10 1f 40 00 00 	movabs rax,0x401f10
  405851:	00 00 00 
  405854:	ff d0                	call   rax
}
  405856:	48 83 c4 10          	add    rsp,0x10
  40585a:	41 5c                	pop    r12
  40585c:	41 5d                	pop    r13
  40585e:	5d                   	pop    rbp
  40585f:	c3                   	ret    

0000000000405860 <slm_thd_alloc_in>:

struct slm_thd_container *
slm_thd_alloc_in(compid_t cid, thdclosure_index_t idx, thdcap_t *thd, thdid_t *tid)
{
  405860:	f3 0f 1e fa          	endbr64 
	struct slm_thd_container *ret = NULL;
	thdid_t _tid;
	thdcap_t _cap;

	_cap = capmgr_thd_create_ext(cid, idx, &_tid);
  405864:	48 b8 30 7d 40 00 00 	movabs rax,0x407d30
  40586b:	00 00 00 
{
  40586e:	55                   	push   rbp
	_cap = capmgr_thd_create_ext(cid, idx, &_tid);
  40586f:	0f b7 ff             	movzx  edi,di
{
  405872:	48 89 e5             	mov    rbp,rsp
  405875:	41 55                	push   r13
  405877:	49 89 cd             	mov    r13,rcx
  40587a:	41 54                	push   r12
  40587c:	49 89 d4             	mov    r12,rdx
	_cap = capmgr_thd_create_ext(cid, idx, &_tid);
  40587f:	48 8d 55 e8          	lea    rdx,[rbp-0x18]
{
  405883:	48 83 ec 10          	sub    rsp,0x10
	_cap = capmgr_thd_create_ext(cid, idx, &_tid);
  405887:	ff d0                	call   rax
  405889:	48 89 c7             	mov    rdi,rax
	if (_cap <= 0) return NULL;
  40588c:	31 c0                	xor    eax,eax
  40588e:	48 85 ff             	test   rdi,rdi
  405891:	74 16                	je     4058a9 <slm_thd_alloc_in+0x49>

	return slm_thd_mem_alloc(_cap, _tid, thd, tid);
  405893:	48 8b 75 e8          	mov    rsi,QWORD PTR [rbp-0x18]
  405897:	4c 89 e9             	mov    rcx,r13
  40589a:	4c 89 e2             	mov    rdx,r12
  40589d:	48 b8 10 1f 40 00 00 	movabs rax,0x401f10
  4058a4:	00 00 00 
  4058a7:	ff d0                	call   rax
}
  4058a9:	48 83 c4 10          	add    rsp,0x10
  4058ad:	41 5c                	pop    r12
  4058af:	41 5d                	pop    r13
  4058b1:	5d                   	pop    rbp
  4058b2:	c3                   	ret    
  4058b3:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4058ba:	00 00 00 00 
  4058be:	66 90                	xchg   ax,ax

00000000004058c0 <thd_alloc>:
extern struct slm_thd *slm_thd_current_extern(void);
extern struct slm_thd *slm_thd_from_container(struct slm_thd_container *c);

struct slm_thd *
thd_alloc(thd_fn_t fn, void *data, sched_param_t *parameters, int reschedule)
{
  4058c0:	f3 0f 1e fa          	endbr64 
	struct slm_thd_container *t;
	struct slm_thd *thd;
	struct slm_thd *ret     = NULL;
	struct slm_thd *current = slm_thd_current_extern();
  4058c4:	48 b8 90 1e 40 00 00 	movabs rax,0x401e90
  4058cb:	00 00 00 
{
  4058ce:	55                   	push   rbp
  4058cf:	48 89 e5             	mov    rbp,rsp
  4058d2:	41 57                	push   r15
  4058d4:	41 56                	push   r14
  4058d6:	41 55                	push   r13
  4058d8:	49 89 fd             	mov    r13,rdi
  4058db:	41 54                	push   r12
  4058dd:	49 89 f4             	mov    r12,rsi
  4058e0:	53                   	push   rbx
  4058e1:	48 89 d3             	mov    rbx,rdx
  4058e4:	48 83 ec 48          	sub    rsp,0x48
  4058e8:	89 4d 98             	mov    DWORD PTR [rbp-0x68],ecx
	struct slm_thd *current = slm_thd_current_extern();
  4058eb:	ff d0                	call   rax
  4058ed:	48 89 45 a8          	mov    QWORD PTR [rbp-0x58],rax

	/*
	 * If this condition is true, we are likely in the
	 * initialization sequence in the idle or scheduler threads...
	 */
	if (!current) {
  4058f1:	48 85 c0             	test   rax,rax
  4058f4:	0f 84 5e 02 00 00    	je     405b58 <thd_alloc+0x298>
	_cap = capmgr_thd_create(fn, data, &_tid);
  4058fa:	4c 89 ef             	mov    rdi,r13
  4058fd:	48 8d 55 c8          	lea    rdx,[rbp-0x38]
  405901:	4c 89 e6             	mov    rsi,r12
  405904:	48 b8 30 af 40 00 00 	movabs rax,0x40af30
  40590b:	00 00 00 
  40590e:	ff d0                	call   rax
  405910:	48 89 c7             	mov    rdi,rax
	if (_cap <= 0) return NULL;
  405913:	48 85 c0             	test   rax,rax
  405916:	0f 84 e0 00 00 00    	je     4059fc <thd_alloc+0x13c>
	return slm_thd_mem_alloc(_cap, _tid, thd, tid);
  40591c:	48 8b 75 c8          	mov    rsi,QWORD PTR [rbp-0x38]
  405920:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  405924:	48 8d 55 b8          	lea    rdx,[rbp-0x48]
  405928:	48 b8 10 1f 40 00 00 	movabs rax,0x401f10
  40592f:	00 00 00 
  405932:	ff d0                	call   rax
  405934:	48 89 45 a0          	mov    QWORD PTR [rbp-0x60],rax
  405938:	48 89 c7             	mov    rdi,rax
		current = slm_thd_special();
		assert(current);
	}

	t = slm_thd_alloc(fn, data, &thdcap, &tid);
	if (!t) ERR_THROW(NULL, done);
  40593b:	48 85 c0             	test   rax,rax
  40593e:	0f 84 b8 00 00 00    	je     4059fc <thd_alloc+0x13c>
	thd = slm_thd_from_container(t);
  405944:	48 b8 00 1f 40 00 00 	movabs rax,0x401f00
  40594b:	00 00 00 
  40594e:	49 be d0 35 41 00 00 	movabs r14,0x4135d0
  405955:	00 00 00 
  405958:	49 bc c0 5e 5a 00 00 	movabs r12,0x5a5ec0
  40595f:	00 00 00 
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  405962:	49 bf 50 5f 41 00 00 	movabs r15,0x415f50
  405969:	00 00 00 
  40596c:	ff d0                	call   rax
  40596e:	49 89 c5             	mov    r13,rax
		tok    = cos_sched_sync();
  405971:	41 ff d6             	call   r14
  405974:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  405977:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
		if (unlikely(owner)) {
  40597b:	48 89 c1             	mov    rcx,rax
  40597e:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  405982:	0f 85 18 02 00 00    	jne    405ba0 <thd_alloc+0x2e0>
  405988:	48 8b 4d a8          	mov    rcx,QWORD PTR [rbp-0x58]
  40598c:	f0 49 0f b1 0c 24    	lock cmpxchg QWORD PTR [r12],rcx
  405992:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  405995:	84 c0                	test   al,al
  405997:	74 d8                	je     405971 <thd_alloc+0xb1>

	slm_cs_enter(current, SLM_CS_NONE);
	if (slm_thd_init(thd, thdcap, tid)) ERR_THROW(NULL, free);
  405999:	48 8b 55 c0          	mov    rdx,QWORD PTR [rbp-0x40]
  40599d:	48 8b 75 b8          	mov    rsi,QWORD PTR [rbp-0x48]
  4059a1:	4c 89 ef             	mov    rdi,r13
  4059a4:	48 b8 20 5e 41 00 00 	movabs rax,0x415e20
  4059ab:	00 00 00 
  4059ae:	ff d0                	call   rax
  4059b0:	85 c0                	test   eax,eax
  4059b2:	75 38                	jne    4059ec <thd_alloc+0x12c>

	for (i = 0; parameters[i] != 0; i++) {
  4059b4:	49 bf a0 1c 40 00 00 	movabs r15,0x401ca0
  4059bb:	00 00 00 
  4059be:	8b 03                	mov    eax,DWORD PTR [rbx]
  4059c0:	48 83 c3 04          	add    rbx,0x4
  4059c4:	89 c6                	mov    esi,eax
  4059c6:	85 c0                	test   eax,eax
  4059c8:	75 10                	jne    4059da <thd_alloc+0x11a>
  4059ca:	eb 4c                	jmp    405a18 <thd_alloc+0x158>
  4059cc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  4059d0:	8b 33                	mov    esi,DWORD PTR [rbx]
  4059d2:	48 83 c3 04          	add    rbx,0x4
  4059d6:	85 f6                	test   esi,esi
  4059d8:	74 3e                	je     405a18 <thd_alloc+0x158>
  4059da:	89 f2                	mov    edx,esi
		sched_param_type_t type;
		unsigned int value;

		sched_param_get(parameters[i], &type, &value);
		if (slm_sched_thd_update(thd, type, value)) ERR_THROW(NULL, free);
  4059dc:	4c 89 ef             	mov    rdi,r13
	if (type)  *type  = (sched_param_type_t)(sp &  SCHED_PARAM_TYPE_MASK);
  4059df:	83 e6 3f             	and    esi,0x3f
	if (value) *value = (unsigned int)      (sp >> SCHED_PARAM_TYPE_BITS);
  4059e2:	c1 ea 06             	shr    edx,0x6
  4059e5:	41 ff d7             	call   r15
  4059e8:	85 c0                	test   eax,eax
  4059ea:	74 e4                	je     4059d0 <thd_alloc+0x110>

	ret = thd;
done:
	return ret;
free:
	slm_thd_mem_free(t);
  4059ec:	48 b8 00 21 40 00 00 	movabs rax,0x402100
  4059f3:	00 00 00 
  4059f6:	48 8b 7d a0          	mov    rdi,QWORD PTR [rbp-0x60]
  4059fa:	ff d0                	call   rax
	ret = NULL;
  4059fc:	45 31 ed             	xor    r13d,r13d
	goto done;
}
  4059ff:	48 83 c4 48          	add    rsp,0x48
  405a03:	4c 89 e8             	mov    rax,r13
  405a06:	5b                   	pop    rbx
  405a07:	41 5c                	pop    r12
  405a09:	41 5d                	pop    r13
  405a0b:	41 5e                	pop    r14
  405a0d:	41 5f                	pop    r15
  405a0f:	5d                   	pop    rbp
  405a10:	c3                   	ret    
  405a11:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	slm_thd_mem_activate(t);
  405a18:	48 b8 20 20 40 00 00 	movabs rax,0x402020
  405a1f:	00 00 00 
  405a22:	48 8b 7d a0          	mov    rdi,QWORD PTR [rbp-0x60]
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  405a26:	48 bb b0 5f 41 00 00 	movabs rbx,0x415fb0
  405a2d:	00 00 00 
  405a30:	ff d0                	call   rax
	if (reschedule) {
  405a32:	8b 45 98             	mov    eax,DWORD PTR [rbp-0x68]
  405a35:	85 c0                	test   eax,eax
  405a37:	0f 84 ec 00 00 00    	je     405b29 <thd_alloc+0x269>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  405a3d:	49 bf 10 ce 40 00 00 	movabs r15,0x40ce10
  405a44:	00 00 00 
  405a47:	41 ff d7             	call   r15
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  405a4a:	4c 89 6d 98          	mov    QWORD PTR [rbp-0x68],r13
	tok  = cos_sched_sync();
  405a4e:	41 ff d6             	call   r14
  405a51:	41 89 c5             	mov    r13d,eax
	t = slm_sched_schedule();
  405a54:	48 b8 e0 1c 40 00 00 	movabs rax,0x401ce0
  405a5b:	00 00 00 
  405a5e:	ff d0                	call   rax
	if (unlikely(!t)) t = &g->idle_thd;
  405a60:	48 85 c0             	test   rax,rax
	t = slm_sched_schedule();
  405a63:	48 89 c3             	mov    rbx,rax
	if (unlikely(!t)) t = &g->idle_thd;
  405a66:	48 b8 40 5f 5a 00 00 	movabs rax,0x5a5f40
  405a6d:	00 00 00 
  405a70:	48 0f 44 d8          	cmove  rbx,rax
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  405a74:	8b 43 04             	mov    eax,DWORD PTR [rbx+0x4]
  405a77:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  405a7a:	83 f8 01             	cmp    eax,0x1
  405a7d:	76 16                	jbe    405a95 <thd_alloc+0x1d5>
  405a7f:	e9 61 01 00 00       	jmp    405be5 <thd_alloc+0x325>
  405a84:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  405a88:	f0 49 0f b1 14 24    	lock cmpxchg QWORD PTR [r12],rdx
  405a8e:	0f 94 c0             	sete   al
	while (ret != 0) {
  405a91:	84 c0                	test   al,al
  405a93:	75 2e                	jne    405ac3 <thd_alloc+0x203>
		tok    = cos_sched_sync();
  405a95:	41 ff d6             	call   r14
  405a98:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  405a9a:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
		if (unlikely(contention)) {
  405a9e:	48 89 c2             	mov    rdx,rax
  405aa1:	83 e2 01             	and    edx,0x1
  405aa4:	74 e2                	je     405a88 <thd_alloc+0x1c8>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  405aa6:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  405aa9:	48 89 c2             	mov    rdx,rax
  405aac:	4c 89 e7             	mov    rdi,r12
  405aaf:	48 b8 b0 5f 41 00 00 	movabs rax,0x415fb0
  405ab6:	00 00 00 
  405ab9:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  405abd:	ff d0                	call   rax
  405abf:	85 c0                	test   eax,eax
  405ac1:	75 d2                	jne    405a95 <thd_alloc+0x1d5>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  405ac3:	41 ff d7             	call   r15
	prio = inherit_prio ? curr->priority : t->priority;
  405ac6:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
	timeout = g->timeout_next;
  405aca:	48 b8 c8 5f 5a 00 00 	movabs rax,0x5a5fc8
  405ad1:	00 00 00 
  405ad4:	4c 8b 00             	mov    r8,QWORD PTR [rax]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  405ad7:	8b 03                	mov    eax,DWORD PTR [rbx]
  405ad9:	a8 0b                	test   al,0xb
  405adb:	0f 85 2c 01 00 00    	jne    405c0d <thd_alloc+0x34d>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  405ae1:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  405ae5:	44 89 e9             	mov    ecx,r13d
  405ae8:	4c 89 c2             	mov    rdx,r8
  405aeb:	48 b8 70 e1 40 00 00 	movabs rax,0x40e170
  405af2:	00 00 00 
  405af5:	ff d0                	call   rax
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  405af7:	83 f8 ff             	cmp    eax,0xffffffff
  405afa:	0f 84 c8 01 00 00    	je     405cc8 <thd_alloc+0x408>
	if (unlikely(ret != 0)) {
  405b00:	85 c0                	test   eax,eax
  405b02:	0f 85 65 01 00 00    	jne    405c6d <thd_alloc+0x3ad>
  405b08:	4c 8b 6d 98          	mov    r13,QWORD PTR [rbp-0x68]
  405b0c:	e9 ee fe ff ff       	jmp    4059ff <thd_alloc+0x13f>
  405b11:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  405b18:	f0 49 0f b1 14 24    	lock cmpxchg QWORD PTR [r12],rdx
  405b1e:	0f 94 c0             	sete   al
	while (ret != 0) {
  405b21:	84 c0                	test   al,al
  405b23:	0f 85 d6 fe ff ff    	jne    4059ff <thd_alloc+0x13f>
		tok    = cos_sched_sync();
  405b29:	41 ff d6             	call   r14
  405b2c:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  405b2e:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
		if (unlikely(contention)) {
  405b32:	48 89 c2             	mov    rdx,rax
  405b35:	83 e2 01             	and    edx,0x1
  405b38:	74 de                	je     405b18 <thd_alloc+0x258>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  405b3a:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  405b3d:	48 89 c2             	mov    rdx,rax
  405b40:	4c 89 e7             	mov    rdi,r12
  405b43:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  405b47:	ff d3                	call   rbx
  405b49:	85 c0                	test   eax,eax
  405b4b:	0f 84 ae fe ff ff    	je     4059ff <thd_alloc+0x13f>
  405b51:	eb d6                	jmp    405b29 <thd_alloc+0x269>
  405b53:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		current = slm_thd_special();
  405b58:	48 b8 e0 5d 41 00 00 	movabs rax,0x415de0
  405b5f:	00 00 00 
  405b62:	ff d0                	call   rax
  405b64:	48 89 45 a8          	mov    QWORD PTR [rbp-0x58],rax
		assert(current);
  405b68:	48 85 c0             	test   rax,rax
  405b6b:	0f 85 89 fd ff ff    	jne    4058fa <thd_alloc+0x3a>
  405b71:	48 bf 28 f8 41 00 00 	movabs rdi,0x41f828
  405b78:	00 00 00 
  405b7b:	be 28 00 00 00       	mov    esi,0x28
  405b80:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  405b87:	00 00 00 
  405b8a:	ff d0                	call   rax
  405b8c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  405b93:	00 00 00 00 
  405b97:	0f 0b                	ud2    
  405b99:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  405ba0:	41 89 c0             	mov    r8d,eax
  405ba3:	48 8b 55 a8          	mov    rdx,QWORD PTR [rbp-0x58]
  405ba7:	48 89 c6             	mov    rsi,rax
  405baa:	4c 89 e7             	mov    rdi,r12
  405bad:	41 83 e0 01          	and    r8d,0x1
  405bb1:	41 ff d7             	call   r15
			assert(ret != -EBUSY);
  405bb4:	83 f8 f0             	cmp    eax,0xfffffff0
  405bb7:	0f 85 b4 fd ff ff    	jne    405971 <thd_alloc+0xb1>
  405bbd:	48 bf 58 f8 41 00 00 	movabs rdi,0x41f858
  405bc4:	00 00 00 
  405bc7:	be 59 00 00 00       	mov    esi,0x59
  405bcc:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  405bd3:	00 00 00 
  405bd6:	ff d0                	call   rax
  405bd8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  405bdf:	00 00 00 00 
  405be3:	0f 0b                	ud2    
  405be5:	48 bf b8 f8 41 00 00 	movabs rdi,0x41f8b8
  405bec:	00 00 00 
  405bef:	be 61 00 00 00       	mov    esi,0x61
  405bf4:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  405bfb:	00 00 00 
  405bfe:	ff d0                	call   rax
	assert(slm_state_is_runnable(t->state));
  405c00:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  405c07:	00 00 00 00 
  405c0b:	0f 0b                	ud2    
		if (t == &g->sched_thd) {
  405c0d:	48 ba c8 5e 5a 00 00 	movabs rdx,0x5a5ec8
  405c14:	00 00 00 
	timeout = g->timeout_next;
  405c17:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  405c1a:	48 39 d3             	cmp    rbx,rdx
  405c1d:	0f 84 e5 00 00 00    	je     405d08 <thd_alloc+0x448>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  405c23:	a8 02                	test   al,0x2
  405c25:	0f 85 ec 00 00 00    	jne    405d17 <thd_alloc+0x457>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  405c2b:	49 89 c8             	mov    r8,rcx
  405c2e:	a8 01                	test   al,0x1
  405c30:	0f 84 ab fe ff ff    	je     405ae1 <thd_alloc+0x221>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  405c36:	4c 8b 53 08          	mov    r10,QWORD PTR [rbx+0x8]
  405c3a:	48 89 f2             	mov    rdx,rsi
  405c3d:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  405c41:	45 89 e9             	mov    r9d,r13d
  405c44:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  405c4b:	00 00 00 
  405c4e:	4c 8b 00             	mov    r8,QWORD PTR [rax]
  405c51:	48 b8 f0 35 41 00 00 	movabs rax,0x4135f0
  405c58:	00 00 00 
  405c5b:	4c 89 d6             	mov    rsi,r10
  405c5e:	ff d0                	call   rax
	if (unlikely(ret != 0)) {
  405c60:	85 c0                	test   eax,eax
  405c62:	0f 84 a0 fe ff ff    	je     405b08 <thd_alloc+0x248>
		assert(ret != -EPERM);
  405c68:	83 f8 ff             	cmp    eax,0xffffffff
  405c6b:	74 73                	je     405ce0 <thd_alloc+0x420>
		assert(ret != -EINVAL);
  405c6d:	83 f8 ea             	cmp    eax,0xffffffea
  405c70:	0f 84 fa 00 00 00    	je     405d70 <thd_alloc+0x4b0>
		if (ret == -EBUSY) return ret;
  405c76:	83 f8 f0             	cmp    eax,0xfffffff0
  405c79:	0f 84 6d fd ff ff    	je     4059ec <thd_alloc+0x12c>
		assert(ret == -EAGAIN);
  405c7f:	83 f8 f5             	cmp    eax,0xfffffff5
  405c82:	0f 85 30 01 00 00    	jne    405db8 <thd_alloc+0x4f8>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  405c88:	48 bb 50 5f 41 00 00 	movabs rbx,0x415f50
  405c8f:	00 00 00 
  405c92:	4c 8b 6d a8          	mov    r13,QWORD PTR [rbp-0x58]
		tok    = cos_sched_sync();
  405c96:	41 ff d6             	call   r14
	unsigned long oc = ps_load(&cs->owner_contention);
  405c99:	49 8b 34 24          	mov    rsi,QWORD PTR [r12]
  405c9d:	41 89 c1             	mov    r9d,eax
		if (unlikely(owner)) {
  405ca0:	48 89 f1             	mov    rcx,rsi
  405ca3:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  405ca7:	0f 85 eb 00 00 00    	jne    405d98 <thd_alloc+0x4d8>
  405cad:	48 89 f0             	mov    rax,rsi
  405cb0:	f0 4d 0f b1 2c 24    	lock cmpxchg QWORD PTR [r12],r13
  405cb6:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  405cb9:	84 c0                	test   al,al
  405cbb:	0f 85 8d fd ff ff    	jne    405a4e <thd_alloc+0x18e>
  405cc1:	eb d3                	jmp    405c96 <thd_alloc+0x3d6>
  405cc3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	return t != &g->idle_thd && t != &g->sched_thd;
  405cc8:	48 b8 40 5f 5a 00 00 	movabs rax,0x5a5f40
  405ccf:	00 00 00 
  405cd2:	48 39 c3             	cmp    rbx,rax
  405cd5:	74 68                	je     405d3f <thd_alloc+0x47f>
  405cd7:	48 83 e8 78          	sub    rax,0x78
  405cdb:	48 39 c3             	cmp    rbx,rax
  405cde:	74 5f                	je     405d3f <thd_alloc+0x47f>
  405ce0:	48 bf 20 f9 41 00 00 	movabs rdi,0x41f920
  405ce7:	00 00 00 
  405cea:	be 61 00 00 00       	mov    esi,0x61
  405cef:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  405cf6:	00 00 00 
  405cf9:	ff d0                	call   rax
		assert(ret != -EPERM);
  405cfb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  405d02:	00 00 00 00 
  405d06:	0f 0b                	ud2    
			prio    = curr->priority;
  405d08:	48 8b 4d a8          	mov    rcx,QWORD PTR [rbp-0x58]
  405d0c:	48 8b 71 30          	mov    rsi,QWORD PTR [rcx+0x30]
			timeout = TCAP_TIME_NIL;
  405d10:	31 c9                	xor    ecx,ecx
  405d12:	e9 0c ff ff ff       	jmp    405c23 <thd_alloc+0x363>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  405d17:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  405d1e:	00 00 00 
  405d21:	48 8b 7b 28          	mov    rdi,QWORD PTR [rbx+0x28]
  405d25:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  405d28:	44 89 e9             	mov    ecx,r13d
  405d2b:	48 b8 60 36 41 00 00 	movabs rax,0x413660
  405d32:	00 00 00 
  405d35:	4c 89 c6             	mov    rsi,r8
  405d38:	ff d0                	call   rax
  405d3a:	e9 21 ff ff ff       	jmp    405c60 <thd_alloc+0x3a0>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  405d3f:	48 8b 45 a8          	mov    rax,QWORD PTR [rbp-0x58]
  405d43:	45 89 e9             	mov    r9d,r13d
  405d46:	31 c9                	xor    ecx,ecx
  405d48:	31 f6                	xor    esi,esi
  405d4a:	48 8b 50 30          	mov    rdx,QWORD PTR [rax+0x30]
  405d4e:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  405d55:	00 00 00 
  405d58:	4c 8b 00             	mov    r8,QWORD PTR [rax]
  405d5b:	48 8b 78 f0          	mov    rdi,QWORD PTR [rax-0x10]
  405d5f:	48 b8 f0 35 41 00 00 	movabs rax,0x4135f0
  405d66:	00 00 00 
  405d69:	ff d0                	call   rax
  405d6b:	e9 f0 fe ff ff       	jmp    405c60 <thd_alloc+0x3a0>
  405d70:	48 bf 88 f9 41 00 00 	movabs rdi,0x41f988
  405d77:	00 00 00 
  405d7a:	be 61 00 00 00       	mov    esi,0x61
  405d7f:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  405d86:	00 00 00 
  405d89:	ff d0                	call   rax
		assert(ret != -EINVAL);
  405d8b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  405d92:	00 00 00 00 
  405d96:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  405d98:	41 89 f0             	mov    r8d,esi
  405d9b:	4c 89 ea             	mov    rdx,r13
  405d9e:	4c 89 e7             	mov    rdi,r12
  405da1:	41 83 e0 01          	and    r8d,0x1
  405da5:	ff d3                	call   rbx
			assert(ret != -EBUSY);
  405da7:	83 f8 f0             	cmp    eax,0xfffffff0
  405daa:	0f 85 e6 fe ff ff    	jne    405c96 <thd_alloc+0x3d6>
  405db0:	e9 08 fe ff ff       	jmp    405bbd <thd_alloc+0x2fd>
  405db5:	0f 1f 00             	nop    DWORD PTR [rax]
  405db8:	48 bf f0 f9 41 00 00 	movabs rdi,0x41f9f0
  405dbf:	00 00 00 
  405dc2:	be 61 00 00 00       	mov    esi,0x61
  405dc7:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  405dce:	00 00 00 
  405dd1:	ff d0                	call   rax
		assert(ret == -EAGAIN);
  405dd3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  405dda:	00 00 00 00 
  405dde:	0f 0b                	ud2    

0000000000405de0 <thd_alloc_in>:

struct slm_thd *
thd_alloc_in(compid_t id, thdclosure_index_t idx, sched_param_t *parameters, int reschedule)
{
  405de0:	f3 0f 1e fa          	endbr64 
	struct slm_thd_container *t;
	struct slm_thd *ret     = NULL, *thd;
	struct slm_thd *current = slm_thd_current_extern();
  405de4:	48 b8 90 1e 40 00 00 	movabs rax,0x401e90
  405deb:	00 00 00 
{
  405dee:	55                   	push   rbp
  405def:	48 89 e5             	mov    rbp,rsp
  405df2:	41 57                	push   r15
  405df4:	41 56                	push   r14
  405df6:	41 55                	push   r13
  405df8:	41 89 f5             	mov    r13d,esi
  405dfb:	41 54                	push   r12
  405dfd:	49 89 fc             	mov    r12,rdi
  405e00:	53                   	push   rbx
  405e01:	48 89 d3             	mov    rbx,rdx
  405e04:	48 83 ec 38          	sub    rsp,0x38
  405e08:	89 4d a4             	mov    DWORD PTR [rbp-0x5c],ecx
	struct slm_thd *current = slm_thd_current_extern();
  405e0b:	ff d0                	call   rax
  405e0d:	48 89 45 a8          	mov    QWORD PTR [rbp-0x58],rax

	/*
	 * If this condition is true, we are likely in the
	 * initialization sequence in the idle or scheduler threads...
	 */
	if (!current) {
  405e11:	48 85 c0             	test   rax,rax
  405e14:	0f 84 be 02 00 00    	je     4060d8 <thd_alloc_in+0x2f8>
	_cap = capmgr_thd_create_ext(cid, idx, &_tid);
  405e1a:	41 0f b7 fc          	movzx  edi,r12w
  405e1e:	48 8d 55 c8          	lea    rdx,[rbp-0x38]
  405e22:	44 89 ee             	mov    esi,r13d
  405e25:	48 b8 30 7d 40 00 00 	movabs rax,0x407d30
  405e2c:	00 00 00 
  405e2f:	ff d0                	call   rax
  405e31:	48 89 c7             	mov    rdi,rax
	if (_cap <= 0) return NULL;
  405e34:	48 85 c0             	test   rax,rax
  405e37:	0f 84 de 00 00 00    	je     405f1b <thd_alloc_in+0x13b>
	return slm_thd_mem_alloc(_cap, _tid, thd, tid);
  405e3d:	48 8b 75 c8          	mov    rsi,QWORD PTR [rbp-0x38]
  405e41:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  405e45:	48 8d 55 b8          	lea    rdx,[rbp-0x48]
  405e49:	48 b8 10 1f 40 00 00 	movabs rax,0x401f10
  405e50:	00 00 00 
  405e53:	ff d0                	call   rax
  405e55:	49 89 c5             	mov    r13,rax
		current = slm_thd_special();
		assert(current);
	}

	t = slm_thd_alloc_in(id, idx, &thdcap, &tid);
	if (!t) ERR_THROW(NULL, done);
  405e58:	48 85 c0             	test   rax,rax
  405e5b:	0f 84 ba 00 00 00    	je     405f1b <thd_alloc_in+0x13b>
	thd = slm_thd_from_container(t);
  405e61:	49 be c0 5e 5a 00 00 	movabs r14,0x5a5ec0
  405e68:	00 00 00 
  405e6b:	48 89 c7             	mov    rdi,rax
  405e6e:	48 b8 00 1f 40 00 00 	movabs rax,0x401f00
  405e75:	00 00 00 
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  405e78:	49 bf 50 5f 41 00 00 	movabs r15,0x415f50
  405e7f:	00 00 00 
  405e82:	ff d0                	call   rax
  405e84:	49 89 c4             	mov    r12,rax
		tok    = cos_sched_sync();
  405e87:	48 b8 d0 35 41 00 00 	movabs rax,0x4135d0
  405e8e:	00 00 00 
  405e91:	ff d0                	call   rax
  405e93:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  405e96:	49 8b 06             	mov    rax,QWORD PTR [r14]
		if (unlikely(owner)) {
  405e99:	48 89 c1             	mov    rcx,rax
  405e9c:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  405ea0:	0f 85 7a 02 00 00    	jne    406120 <thd_alloc_in+0x340>
  405ea6:	48 8b 4d a8          	mov    rcx,QWORD PTR [rbp-0x58]
  405eaa:	f0 49 0f b1 0e       	lock cmpxchg QWORD PTR [r14],rcx
  405eaf:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  405eb2:	84 c0                	test   al,al
  405eb4:	74 d1                	je     405e87 <thd_alloc_in+0xa7>

	slm_cs_enter(current, SLM_CS_NONE);
	if (slm_thd_init(thd, thdcap, tid)) ERR_THROW(NULL, free);
  405eb6:	48 8b 55 c0          	mov    rdx,QWORD PTR [rbp-0x40]
  405eba:	48 8b 75 b8          	mov    rsi,QWORD PTR [rbp-0x48]
  405ebe:	4c 89 e7             	mov    rdi,r12
  405ec1:	48 b8 20 5e 41 00 00 	movabs rax,0x415e20
  405ec8:	00 00 00 
  405ecb:	ff d0                	call   rax
  405ecd:	85 c0                	test   eax,eax
  405ecf:	75 3b                	jne    405f0c <thd_alloc_in+0x12c>

	for (i = 0; parameters[i] != 0; i++) {
  405ed1:	49 bf a0 1c 40 00 00 	movabs r15,0x401ca0
  405ed8:	00 00 00 
  405edb:	8b 03                	mov    eax,DWORD PTR [rbx]
  405edd:	48 83 c3 04          	add    rbx,0x4
  405ee1:	89 c6                	mov    esi,eax
  405ee3:	85 c0                	test   eax,eax
  405ee5:	75 13                	jne    405efa <thd_alloc_in+0x11a>
  405ee7:	eb 47                	jmp    405f30 <thd_alloc_in+0x150>
  405ee9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  405ef0:	8b 33                	mov    esi,DWORD PTR [rbx]
  405ef2:	48 83 c3 04          	add    rbx,0x4
  405ef6:	85 f6                	test   esi,esi
  405ef8:	74 36                	je     405f30 <thd_alloc_in+0x150>
  405efa:	89 f2                	mov    edx,esi
		sched_param_type_t type;
		unsigned int value;

		sched_param_get(parameters[i], &type, &value);
		if (slm_sched_thd_update(thd, type, value)) ERR_THROW(NULL, free);
  405efc:	4c 89 e7             	mov    rdi,r12
	if (type)  *type  = (sched_param_type_t)(sp &  SCHED_PARAM_TYPE_MASK);
  405eff:	83 e6 3f             	and    esi,0x3f
	if (value) *value = (unsigned int)      (sp >> SCHED_PARAM_TYPE_BITS);
  405f02:	c1 ea 06             	shr    edx,0x6
  405f05:	41 ff d7             	call   r15
  405f08:	85 c0                	test   eax,eax
  405f0a:	74 e4                	je     405ef0 <thd_alloc_in+0x110>

	ret = thd;
done:
	return ret;
free:
	slm_thd_mem_free(t);
  405f0c:	48 b8 00 21 40 00 00 	movabs rax,0x402100
  405f13:	00 00 00 
  405f16:	4c 89 ef             	mov    rdi,r13
  405f19:	ff d0                	call   rax
	ret = NULL;
  405f1b:	45 31 e4             	xor    r12d,r12d
	goto done;
}
  405f1e:	48 83 c4 38          	add    rsp,0x38
  405f22:	4c 89 e0             	mov    rax,r12
  405f25:	5b                   	pop    rbx
  405f26:	41 5c                	pop    r12
  405f28:	41 5d                	pop    r13
  405f2a:	41 5e                	pop    r14
  405f2c:	41 5f                	pop    r15
  405f2e:	5d                   	pop    rbp
  405f2f:	c3                   	ret    
	slm_thd_mem_activate(t);
  405f30:	48 b8 20 20 40 00 00 	movabs rax,0x402020
  405f37:	00 00 00 
  405f3a:	4c 89 ef             	mov    rdi,r13
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  405f3d:	48 bb b0 5f 41 00 00 	movabs rbx,0x415fb0
  405f44:	00 00 00 
  405f47:	ff d0                	call   rax
	if (reschedule) {
  405f49:	8b 45 a4             	mov    eax,DWORD PTR [rbp-0x5c]
  405f4c:	85 c0                	test   eax,eax
  405f4e:	0f 84 4c 01 00 00    	je     4060a0 <thd_alloc_in+0x2c0>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  405f54:	48 b8 10 ce 40 00 00 	movabs rax,0x40ce10
  405f5b:	00 00 00 
  405f5e:	49 bf e0 1c 40 00 00 	movabs r15,0x401ce0
  405f65:	00 00 00 
  405f68:	ff d0                	call   rax
	tok  = cos_sched_sync();
  405f6a:	48 b8 d0 35 41 00 00 	movabs rax,0x4135d0
  405f71:	00 00 00 
  405f74:	ff d0                	call   rax
  405f76:	41 89 c5             	mov    r13d,eax
	t = slm_sched_schedule();
  405f79:	41 ff d7             	call   r15
	if (unlikely(!t)) t = &g->idle_thd;
  405f7c:	48 85 c0             	test   rax,rax
	t = slm_sched_schedule();
  405f7f:	48 89 c3             	mov    rbx,rax
	if (unlikely(!t)) t = &g->idle_thd;
  405f82:	48 b8 40 5f 5a 00 00 	movabs rax,0x5a5f40
  405f89:	00 00 00 
  405f8c:	48 0f 44 d8          	cmove  rbx,rax
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  405f90:	8b 43 04             	mov    eax,DWORD PTR [rbx+0x4]
  405f93:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  405f96:	83 f8 01             	cmp    eax,0x1
  405f99:	76 11                	jbe    405fac <thd_alloc_in+0x1cc>
  405f9b:	e9 c5 01 00 00       	jmp    406165 <thd_alloc_in+0x385>
  405fa0:	f0 49 0f b1 16       	lock cmpxchg QWORD PTR [r14],rdx
  405fa5:	0f 94 c0             	sete   al
	while (ret != 0) {
  405fa8:	84 c0                	test   al,al
  405faa:	75 36                	jne    405fe2 <thd_alloc_in+0x202>
		tok    = cos_sched_sync();
  405fac:	48 b8 d0 35 41 00 00 	movabs rax,0x4135d0
  405fb3:	00 00 00 
  405fb6:	ff d0                	call   rax
  405fb8:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  405fba:	49 8b 06             	mov    rax,QWORD PTR [r14]
		if (unlikely(contention)) {
  405fbd:	48 89 c2             	mov    rdx,rax
  405fc0:	83 e2 01             	and    edx,0x1
  405fc3:	74 db                	je     405fa0 <thd_alloc_in+0x1c0>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  405fc5:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  405fc8:	48 89 c2             	mov    rdx,rax
  405fcb:	4c 89 f7             	mov    rdi,r14
  405fce:	48 b8 b0 5f 41 00 00 	movabs rax,0x415fb0
  405fd5:	00 00 00 
  405fd8:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  405fdc:	ff d0                	call   rax
  405fde:	85 c0                	test   eax,eax
  405fe0:	75 ca                	jne    405fac <thd_alloc_in+0x1cc>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  405fe2:	48 b8 10 ce 40 00 00 	movabs rax,0x40ce10
  405fe9:	00 00 00 
  405fec:	ff d0                	call   rax
	prio = inherit_prio ? curr->priority : t->priority;
  405fee:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
	timeout = g->timeout_next;
  405ff2:	48 b8 c8 5f 5a 00 00 	movabs rax,0x5a5fc8
  405ff9:	00 00 00 
  405ffc:	4c 8b 00             	mov    r8,QWORD PTR [rax]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  405fff:	8b 03                	mov    eax,DWORD PTR [rbx]
  406001:	a8 0b                	test   al,0xb
  406003:	0f 85 84 01 00 00    	jne    40618d <thd_alloc_in+0x3ad>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  406009:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  40600d:	44 89 e9             	mov    ecx,r13d
  406010:	4c 89 c2             	mov    rdx,r8
  406013:	48 b8 70 e1 40 00 00 	movabs rax,0x40e170
  40601a:	00 00 00 
  40601d:	ff d0                	call   rax
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  40601f:	83 f8 ff             	cmp    eax,0xffffffff
  406022:	0f 84 f1 01 00 00    	je     406219 <thd_alloc_in+0x439>
	if (unlikely(ret != 0)) {
  406028:	85 c0                	test   eax,eax
  40602a:	0f 84 ee fe ff ff    	je     405f1e <thd_alloc_in+0x13e>
		assert(ret != -EINVAL);
  406030:	83 f8 ea             	cmp    eax,0xffffffea
  406033:	0f 84 5d 02 00 00    	je     406296 <thd_alloc_in+0x4b6>
		if (ret == -EBUSY) return ret;
  406039:	83 f8 f0             	cmp    eax,0xfffffff0
  40603c:	0f 84 d9 fe ff ff    	je     405f1b <thd_alloc_in+0x13b>
		assert(ret == -EAGAIN);
  406042:	83 f8 f5             	cmp    eax,0xfffffff5
  406045:	0f 85 95 02 00 00    	jne    4062e0 <thd_alloc_in+0x500>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  40604b:	48 bb 50 5f 41 00 00 	movabs rbx,0x415f50
  406052:	00 00 00 
  406055:	4c 8b 6d a8          	mov    r13,QWORD PTR [rbp-0x58]
		tok    = cos_sched_sync();
  406059:	48 b8 d0 35 41 00 00 	movabs rax,0x4135d0
  406060:	00 00 00 
  406063:	ff d0                	call   rax
	unsigned long oc = ps_load(&cs->owner_contention);
  406065:	49 8b 36             	mov    rsi,QWORD PTR [r14]
  406068:	41 89 c1             	mov    r9d,eax
		if (unlikely(owner)) {
  40606b:	48 89 f1             	mov    rcx,rsi
  40606e:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  406072:	0f 85 46 02 00 00    	jne    4062be <thd_alloc_in+0x4de>
  406078:	48 89 f0             	mov    rax,rsi
  40607b:	f0 4d 0f b1 2e       	lock cmpxchg QWORD PTR [r14],r13
  406080:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  406083:	84 c0                	test   al,al
  406085:	0f 85 df fe ff ff    	jne    405f6a <thd_alloc_in+0x18a>
  40608b:	eb cc                	jmp    406059 <thd_alloc_in+0x279>
  40608d:	0f 1f 00             	nop    DWORD PTR [rax]
  406090:	f0 49 0f b1 16       	lock cmpxchg QWORD PTR [r14],rdx
  406095:	0f 94 c0             	sete   al
	while (ret != 0) {
  406098:	84 c0                	test   al,al
  40609a:	0f 85 7e fe ff ff    	jne    405f1e <thd_alloc_in+0x13e>
		tok    = cos_sched_sync();
  4060a0:	48 b8 d0 35 41 00 00 	movabs rax,0x4135d0
  4060a7:	00 00 00 
  4060aa:	ff d0                	call   rax
  4060ac:	89 c1                	mov    ecx,eax
  4060ae:	49 8b 06             	mov    rax,QWORD PTR [r14]
		if (unlikely(contention)) {
  4060b1:	48 89 c2             	mov    rdx,rax
  4060b4:	83 e2 01             	and    edx,0x1
  4060b7:	74 d7                	je     406090 <thd_alloc_in+0x2b0>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  4060b9:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  4060bc:	48 89 c2             	mov    rdx,rax
  4060bf:	4c 89 f7             	mov    rdi,r14
  4060c2:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  4060c6:	ff d3                	call   rbx
  4060c8:	85 c0                	test   eax,eax
  4060ca:	0f 84 4e fe ff ff    	je     405f1e <thd_alloc_in+0x13e>
  4060d0:	eb ce                	jmp    4060a0 <thd_alloc_in+0x2c0>
  4060d2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
		current = slm_thd_special();
  4060d8:	48 b8 e0 5d 41 00 00 	movabs rax,0x415de0
  4060df:	00 00 00 
  4060e2:	ff d0                	call   rax
  4060e4:	48 89 45 a8          	mov    QWORD PTR [rbp-0x58],rax
		assert(current);
  4060e8:	48 85 c0             	test   rax,rax
  4060eb:	0f 85 29 fd ff ff    	jne    405e1a <thd_alloc_in+0x3a>
  4060f1:	48 bf 58 fa 41 00 00 	movabs rdi,0x41fa58
  4060f8:	00 00 00 
  4060fb:	be 29 00 00 00       	mov    esi,0x29
  406100:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  406107:	00 00 00 
  40610a:	ff d0                	call   rax
  40610c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  406113:	00 00 00 00 
  406117:	0f 0b                	ud2    
  406119:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  406120:	41 89 c0             	mov    r8d,eax
  406123:	48 8b 55 a8          	mov    rdx,QWORD PTR [rbp-0x58]
  406127:	48 89 c6             	mov    rsi,rax
  40612a:	4c 89 f7             	mov    rdi,r14
  40612d:	41 83 e0 01          	and    r8d,0x1
  406131:	41 ff d7             	call   r15
			assert(ret != -EBUSY);
  406134:	83 f8 f0             	cmp    eax,0xfffffff0
  406137:	0f 85 4a fd ff ff    	jne    405e87 <thd_alloc_in+0xa7>
  40613d:	48 bf 58 f8 41 00 00 	movabs rdi,0x41f858
  406144:	00 00 00 
  406147:	be 59 00 00 00       	mov    esi,0x59
  40614c:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  406153:	00 00 00 
  406156:	ff d0                	call   rax
  406158:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40615f:	00 00 00 00 
  406163:	0f 0b                	ud2    
  406165:	48 bf b8 f8 41 00 00 	movabs rdi,0x41f8b8
  40616c:	00 00 00 
  40616f:	be 61 00 00 00       	mov    esi,0x61
  406174:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40617b:	00 00 00 
  40617e:	ff d0                	call   rax
	assert(slm_state_is_runnable(t->state));
  406180:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  406187:	00 00 00 00 
  40618b:	0f 0b                	ud2    
		if (t == &g->sched_thd) {
  40618d:	48 ba c8 5e 5a 00 00 	movabs rdx,0x5a5ec8
  406194:	00 00 00 
	timeout = g->timeout_next;
  406197:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  40619a:	48 39 d3             	cmp    rbx,rdx
  40619d:	0f 84 bc 00 00 00    	je     40625f <thd_alloc_in+0x47f>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  4061a3:	a8 02                	test   al,0x2
  4061a5:	0f 85 c3 00 00 00    	jne    40626e <thd_alloc_in+0x48e>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  4061ab:	49 89 c8             	mov    r8,rcx
  4061ae:	a8 01                	test   al,0x1
  4061b0:	0f 84 53 fe ff ff    	je     406009 <thd_alloc_in+0x229>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  4061b6:	4c 8b 53 08          	mov    r10,QWORD PTR [rbx+0x8]
  4061ba:	48 89 f2             	mov    rdx,rsi
  4061bd:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  4061c1:	45 89 e9             	mov    r9d,r13d
  4061c4:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  4061cb:	00 00 00 
  4061ce:	4c 8b 00             	mov    r8,QWORD PTR [rax]
  4061d1:	48 b8 f0 35 41 00 00 	movabs rax,0x4135f0
  4061d8:	00 00 00 
  4061db:	4c 89 d6             	mov    rsi,r10
  4061de:	ff d0                	call   rax
	if (unlikely(ret != 0)) {
  4061e0:	85 c0                	test   eax,eax
  4061e2:	0f 84 36 fd ff ff    	je     405f1e <thd_alloc_in+0x13e>
		assert(ret != -EPERM);
  4061e8:	83 f8 ff             	cmp    eax,0xffffffff
  4061eb:	0f 85 3f fe ff ff    	jne    406030 <thd_alloc_in+0x250>
  4061f1:	48 bf 20 f9 41 00 00 	movabs rdi,0x41f920
  4061f8:	00 00 00 
  4061fb:	be 61 00 00 00       	mov    esi,0x61
  406200:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  406207:	00 00 00 
  40620a:	ff d0                	call   rax
  40620c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  406213:	00 00 00 00 
  406217:	0f 0b                	ud2    
	return t != &g->idle_thd && t != &g->sched_thd;
  406219:	48 b8 40 5f 5a 00 00 	movabs rax,0x5a5f40
  406220:	00 00 00 
  406223:	48 39 c3             	cmp    rbx,rax
  406226:	74 09                	je     406231 <thd_alloc_in+0x451>
  406228:	48 83 e8 78          	sub    rax,0x78
  40622c:	48 39 c3             	cmp    rbx,rax
  40622f:	75 c0                	jne    4061f1 <thd_alloc_in+0x411>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  406231:	48 8b 45 a8          	mov    rax,QWORD PTR [rbp-0x58]
  406235:	45 89 e9             	mov    r9d,r13d
  406238:	31 c9                	xor    ecx,ecx
  40623a:	31 f6                	xor    esi,esi
  40623c:	48 8b 50 30          	mov    rdx,QWORD PTR [rax+0x30]
  406240:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  406247:	00 00 00 
  40624a:	4c 8b 00             	mov    r8,QWORD PTR [rax]
  40624d:	48 8b 78 f0          	mov    rdi,QWORD PTR [rax-0x10]
  406251:	48 b8 f0 35 41 00 00 	movabs rax,0x4135f0
  406258:	00 00 00 
  40625b:	ff d0                	call   rax
  40625d:	eb 81                	jmp    4061e0 <thd_alloc_in+0x400>
			prio    = curr->priority;
  40625f:	48 8b 4d a8          	mov    rcx,QWORD PTR [rbp-0x58]
  406263:	48 8b 71 30          	mov    rsi,QWORD PTR [rcx+0x30]
			timeout = TCAP_TIME_NIL;
  406267:	31 c9                	xor    ecx,ecx
  406269:	e9 35 ff ff ff       	jmp    4061a3 <thd_alloc_in+0x3c3>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  40626e:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  406275:	00 00 00 
  406278:	48 8b 7b 28          	mov    rdi,QWORD PTR [rbx+0x28]
  40627c:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  40627f:	44 89 e9             	mov    ecx,r13d
  406282:	48 b8 60 36 41 00 00 	movabs rax,0x413660
  406289:	00 00 00 
  40628c:	4c 89 c6             	mov    rsi,r8
  40628f:	ff d0                	call   rax
  406291:	e9 4a ff ff ff       	jmp    4061e0 <thd_alloc_in+0x400>
  406296:	48 bf 88 f9 41 00 00 	movabs rdi,0x41f988
  40629d:	00 00 00 
  4062a0:	be 61 00 00 00       	mov    esi,0x61
  4062a5:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4062ac:	00 00 00 
  4062af:	ff d0                	call   rax
		assert(ret != -EINVAL);
  4062b1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4062b8:	00 00 00 00 
  4062bc:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  4062be:	41 89 f0             	mov    r8d,esi
  4062c1:	4c 89 ea             	mov    rdx,r13
  4062c4:	4c 89 f7             	mov    rdi,r14
  4062c7:	41 83 e0 01          	and    r8d,0x1
  4062cb:	ff d3                	call   rbx
			assert(ret != -EBUSY);
  4062cd:	83 f8 f0             	cmp    eax,0xfffffff0
  4062d0:	0f 85 83 fd ff ff    	jne    406059 <thd_alloc_in+0x279>
  4062d6:	e9 62 fe ff ff       	jmp    40613d <thd_alloc_in+0x35d>
  4062db:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  4062e0:	48 bf f0 f9 41 00 00 	movabs rdi,0x41f9f0
  4062e7:	00 00 00 
  4062ea:	be 61 00 00 00       	mov    esi,0x61
  4062ef:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4062f6:	00 00 00 
  4062f9:	ff d0                	call   rax
		assert(ret == -EAGAIN);
  4062fb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  406302:	00 00 00 00 
  406306:	0f 0b                	ud2    
  406308:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40630f:	00 

0000000000406310 <__cosrt_s_sched_get_cpu_freq>:
  406310:	48 b9 1f 63 40 00 00 	movabs rcx,0x40631f
  406317:	00 00 00 
  40631a:	e9 e1 59 00 00       	jmp    40bd00 <custom_acquire_stack>
  40631f:	52                   	push   rdx
  406320:	50                   	push   rax
  406321:	55                   	push   rbp
  406322:	4c 89 e1             	mov    rcx,r12
  406325:	48 31 ed             	xor    rbp,rbp
  406328:	48 89 f8             	mov    rax,rdi
  40632b:	48 89 df             	mov    rdi,rbx
  40632e:	48 89 c2             	mov    rdx,rax
  406331:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  406335:	e8 36 ef ff ff       	call   405270 <sched_get_cpu_freq>
  40633a:	49 89 c0             	mov    r8,rax
  40633d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  406344:	0f 05                	syscall 
  406346:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40634d:	00 00 00 

0000000000406350 <__cosrt_alts_sched_get_cpu_freq>:
  406350:	4c 89 e8             	mov    rax,r13
  406353:	48 b9 62 63 40 00 00 	movabs rcx,0x406362
  40635a:	00 00 00 
  40635d:	e9 9e 59 00 00       	jmp    40bd00 <custom_acquire_stack>
  406362:	52                   	push   rdx
  406363:	50                   	push   rax
  406364:	55                   	push   rbp
  406365:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  406369:	48 31 ed             	xor    rbp,rbp
  40636c:	51                   	push   rcx
  40636d:	51                   	push   rcx
  40636e:	4c 89 c1             	mov    rcx,r8
  406371:	4c 89 ca             	mov    rdx,r9
  406374:	e8 f7 ee ff ff       	call   405270 <sched_get_cpu_freq>
  406379:	59                   	pop    rcx
  40637a:	c3                   	ret    
  40637b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000406380 <__cosrt_s_sched_thd_yield_to>:
  406380:	48 b9 8f 63 40 00 00 	movabs rcx,0x40638f
  406387:	00 00 00 
  40638a:	e9 71 59 00 00       	jmp    40bd00 <custom_acquire_stack>
  40638f:	52                   	push   rdx
  406390:	50                   	push   rax
  406391:	55                   	push   rbp
  406392:	4c 89 e1             	mov    rcx,r12
  406395:	48 31 ed             	xor    rbp,rbp
  406398:	48 89 f8             	mov    rax,rdi
  40639b:	48 89 df             	mov    rdi,rbx
  40639e:	48 89 c2             	mov    rdx,rax
  4063a1:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4063a5:	e8 76 c2 ff ff       	call   402620 <sched_thd_yield_to>
  4063aa:	49 89 c0             	mov    r8,rax
  4063ad:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  4063b4:	0f 05                	syscall 
  4063b6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4063bd:	00 00 00 

00000000004063c0 <__cosrt_alts_sched_thd_yield_to>:
  4063c0:	4c 89 e8             	mov    rax,r13
  4063c3:	48 b9 d2 63 40 00 00 	movabs rcx,0x4063d2
  4063ca:	00 00 00 
  4063cd:	e9 2e 59 00 00       	jmp    40bd00 <custom_acquire_stack>
  4063d2:	52                   	push   rdx
  4063d3:	50                   	push   rax
  4063d4:	55                   	push   rbp
  4063d5:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4063d9:	48 31 ed             	xor    rbp,rbp
  4063dc:	51                   	push   rcx
  4063dd:	51                   	push   rcx
  4063de:	4c 89 c1             	mov    rcx,r8
  4063e1:	4c 89 ca             	mov    rdx,r9
  4063e4:	e8 37 c2 ff ff       	call   402620 <sched_thd_yield_to>
  4063e9:	59                   	pop    rcx
  4063ea:	c3                   	ret    
  4063eb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000004063f0 <__cosrt_s_sched_thd_wakeup>:
  4063f0:	48 b9 ff 63 40 00 00 	movabs rcx,0x4063ff
  4063f7:	00 00 00 
  4063fa:	e9 01 59 00 00       	jmp    40bd00 <custom_acquire_stack>
  4063ff:	52                   	push   rdx
  406400:	50                   	push   rax
  406401:	55                   	push   rbp
  406402:	4c 89 e1             	mov    rcx,r12
  406405:	48 31 ed             	xor    rbp,rbp
  406408:	48 89 f8             	mov    rax,rdi
  40640b:	48 89 df             	mov    rdi,rbx
  40640e:	48 89 c2             	mov    rdx,rax
  406411:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  406415:	e8 a6 d4 ff ff       	call   4038c0 <sched_thd_wakeup>
  40641a:	49 89 c0             	mov    r8,rax
  40641d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  406424:	0f 05                	syscall 
  406426:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40642d:	00 00 00 

0000000000406430 <__cosrt_alts_sched_thd_wakeup>:
  406430:	4c 89 e8             	mov    rax,r13
  406433:	48 b9 42 64 40 00 00 	movabs rcx,0x406442
  40643a:	00 00 00 
  40643d:	e9 be 58 00 00       	jmp    40bd00 <custom_acquire_stack>
  406442:	52                   	push   rdx
  406443:	50                   	push   rax
  406444:	55                   	push   rbp
  406445:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  406449:	48 31 ed             	xor    rbp,rbp
  40644c:	51                   	push   rcx
  40644d:	51                   	push   rcx
  40644e:	4c 89 c1             	mov    rcx,r8
  406451:	4c 89 ca             	mov    rdx,r9
  406454:	e8 67 d4 ff ff       	call   4038c0 <sched_thd_wakeup>
  406459:	59                   	pop    rcx
  40645a:	c3                   	ret    
  40645b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000406460 <__cosrt_s_sched_debug_thd_state>:
  406460:	48 b9 6f 64 40 00 00 	movabs rcx,0x40646f
  406467:	00 00 00 
  40646a:	e9 91 58 00 00       	jmp    40bd00 <custom_acquire_stack>
  40646f:	52                   	push   rdx
  406470:	50                   	push   rax
  406471:	55                   	push   rbp
  406472:	4c 89 e1             	mov    rcx,r12
  406475:	48 31 ed             	xor    rbp,rbp
  406478:	48 89 f8             	mov    rax,rdi
  40647b:	48 89 df             	mov    rdi,rbx
  40647e:	48 89 c2             	mov    rdx,rax
  406481:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  406485:	e8 e6 d8 ff ff       	call   403d70 <sched_debug_thd_state>
  40648a:	49 89 c0             	mov    r8,rax
  40648d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  406494:	0f 05                	syscall 
  406496:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40649d:	00 00 00 

00000000004064a0 <__cosrt_alts_sched_debug_thd_state>:
  4064a0:	4c 89 e8             	mov    rax,r13
  4064a3:	48 b9 b2 64 40 00 00 	movabs rcx,0x4064b2
  4064aa:	00 00 00 
  4064ad:	e9 4e 58 00 00       	jmp    40bd00 <custom_acquire_stack>
  4064b2:	52                   	push   rdx
  4064b3:	50                   	push   rax
  4064b4:	55                   	push   rbp
  4064b5:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4064b9:	48 31 ed             	xor    rbp,rbp
  4064bc:	51                   	push   rcx
  4064bd:	51                   	push   rcx
  4064be:	4c 89 c1             	mov    rcx,r8
  4064c1:	4c 89 ca             	mov    rdx,r9
  4064c4:	e8 a7 d8 ff ff       	call   403d70 <sched_debug_thd_state>
  4064c9:	59                   	pop    rcx
  4064ca:	c3                   	ret    
  4064cb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000004064d0 <__cosrt_s_sched_thd_block>:
  4064d0:	48 b9 df 64 40 00 00 	movabs rcx,0x4064df
  4064d7:	00 00 00 
  4064da:	e9 21 58 00 00       	jmp    40bd00 <custom_acquire_stack>
  4064df:	52                   	push   rdx
  4064e0:	50                   	push   rax
  4064e1:	55                   	push   rbp
  4064e2:	4c 89 e1             	mov    rcx,r12
  4064e5:	48 31 ed             	xor    rbp,rbp
  4064e8:	48 89 f8             	mov    rax,rdi
  4064eb:	48 89 df             	mov    rdi,rbx
  4064ee:	48 89 c2             	mov    rdx,rax
  4064f1:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4064f5:	e8 c6 ca ff ff       	call   402fc0 <sched_thd_block>
  4064fa:	49 89 c0             	mov    r8,rax
  4064fd:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  406504:	0f 05                	syscall 
  406506:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40650d:	00 00 00 

0000000000406510 <__cosrt_alts_sched_thd_block>:
  406510:	4c 89 e8             	mov    rax,r13
  406513:	48 b9 22 65 40 00 00 	movabs rcx,0x406522
  40651a:	00 00 00 
  40651d:	e9 de 57 00 00       	jmp    40bd00 <custom_acquire_stack>
  406522:	52                   	push   rdx
  406523:	50                   	push   rax
  406524:	55                   	push   rbp
  406525:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  406529:	48 31 ed             	xor    rbp,rbp
  40652c:	51                   	push   rcx
  40652d:	51                   	push   rcx
  40652e:	4c 89 c1             	mov    rcx,r8
  406531:	4c 89 ca             	mov    rdx,r9
  406534:	e8 87 ca ff ff       	call   402fc0 <sched_thd_block>
  406539:	59                   	pop    rcx
  40653a:	c3                   	ret    
  40653b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000406540 <__cosrt_s_sched_blkpt_alloc>:
  406540:	48 b9 4f 65 40 00 00 	movabs rcx,0x40654f
  406547:	00 00 00 
  40654a:	e9 b1 57 00 00       	jmp    40bd00 <custom_acquire_stack>
  40654f:	52                   	push   rdx
  406550:	50                   	push   rax
  406551:	55                   	push   rbp
  406552:	4c 89 e1             	mov    rcx,r12
  406555:	48 31 ed             	xor    rbp,rbp
  406558:	48 89 f8             	mov    rax,rdi
  40655b:	48 89 df             	mov    rdi,rbx
  40655e:	48 89 c2             	mov    rdx,rax
  406561:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  406565:	e8 46 e2 ff ff       	call   4047b0 <sched_blkpt_alloc>
  40656a:	49 89 c0             	mov    r8,rax
  40656d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  406574:	0f 05                	syscall 
  406576:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40657d:	00 00 00 

0000000000406580 <__cosrt_alts_sched_blkpt_alloc>:
  406580:	4c 89 e8             	mov    rax,r13
  406583:	48 b9 92 65 40 00 00 	movabs rcx,0x406592
  40658a:	00 00 00 
  40658d:	e9 6e 57 00 00       	jmp    40bd00 <custom_acquire_stack>
  406592:	52                   	push   rdx
  406593:	50                   	push   rax
  406594:	55                   	push   rbp
  406595:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  406599:	48 31 ed             	xor    rbp,rbp
  40659c:	51                   	push   rcx
  40659d:	51                   	push   rcx
  40659e:	4c 89 c1             	mov    rcx,r8
  4065a1:	4c 89 ca             	mov    rdx,r9
  4065a4:	e8 07 e2 ff ff       	call   4047b0 <sched_blkpt_alloc>
  4065a9:	59                   	pop    rcx
  4065aa:	c3                   	ret    
  4065ab:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000004065b0 <__cosrt_s_sched_blkpt_free>:
  4065b0:	48 b9 bf 65 40 00 00 	movabs rcx,0x4065bf
  4065b7:	00 00 00 
  4065ba:	e9 41 57 00 00       	jmp    40bd00 <custom_acquire_stack>
  4065bf:	52                   	push   rdx
  4065c0:	50                   	push   rax
  4065c1:	55                   	push   rbp
  4065c2:	4c 89 e1             	mov    rcx,r12
  4065c5:	48 31 ed             	xor    rbp,rbp
  4065c8:	48 89 f8             	mov    rax,rdi
  4065cb:	48 89 df             	mov    rdi,rbx
  4065ce:	48 89 c2             	mov    rdx,rax
  4065d1:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4065d5:	e8 a6 e3 ff ff       	call   404980 <sched_blkpt_free>
  4065da:	49 89 c0             	mov    r8,rax
  4065dd:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  4065e4:	0f 05                	syscall 
  4065e6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4065ed:	00 00 00 

00000000004065f0 <__cosrt_alts_sched_blkpt_free>:
  4065f0:	4c 89 e8             	mov    rax,r13
  4065f3:	48 b9 02 66 40 00 00 	movabs rcx,0x406602
  4065fa:	00 00 00 
  4065fd:	e9 fe 56 00 00       	jmp    40bd00 <custom_acquire_stack>
  406602:	52                   	push   rdx
  406603:	50                   	push   rax
  406604:	55                   	push   rbp
  406605:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  406609:	48 31 ed             	xor    rbp,rbp
  40660c:	51                   	push   rcx
  40660d:	51                   	push   rcx
  40660e:	4c 89 c1             	mov    rcx,r8
  406611:	4c 89 ca             	mov    rdx,r9
  406614:	e8 67 e3 ff ff       	call   404980 <sched_blkpt_free>
  406619:	59                   	pop    rcx
  40661a:	c3                   	ret    
  40661b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000406620 <__cosrt_s_sched_blkpt_trigger>:
  406620:	48 b9 2f 66 40 00 00 	movabs rcx,0x40662f
  406627:	00 00 00 
  40662a:	e9 d1 56 00 00       	jmp    40bd00 <custom_acquire_stack>
  40662f:	52                   	push   rdx
  406630:	50                   	push   rax
  406631:	55                   	push   rbp
  406632:	4c 89 e1             	mov    rcx,r12
  406635:	48 31 ed             	xor    rbp,rbp
  406638:	48 89 f8             	mov    rax,rdi
  40663b:	48 89 df             	mov    rdi,rbx
  40663e:	48 89 c2             	mov    rdx,rax
  406641:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  406645:	e8 46 e3 ff ff       	call   404990 <sched_blkpt_trigger>
  40664a:	49 89 c0             	mov    r8,rax
  40664d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  406654:	0f 05                	syscall 
  406656:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40665d:	00 00 00 

0000000000406660 <__cosrt_alts_sched_blkpt_trigger>:
  406660:	4c 89 e8             	mov    rax,r13
  406663:	48 b9 72 66 40 00 00 	movabs rcx,0x406672
  40666a:	00 00 00 
  40666d:	e9 8e 56 00 00       	jmp    40bd00 <custom_acquire_stack>
  406672:	52                   	push   rdx
  406673:	50                   	push   rax
  406674:	55                   	push   rbp
  406675:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  406679:	48 31 ed             	xor    rbp,rbp
  40667c:	51                   	push   rcx
  40667d:	51                   	push   rcx
  40667e:	4c 89 c1             	mov    rcx,r8
  406681:	4c 89 ca             	mov    rdx,r9
  406684:	e8 07 e3 ff ff       	call   404990 <sched_blkpt_trigger>
  406689:	59                   	pop    rcx
  40668a:	c3                   	ret    
  40668b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000406690 <__cosrt_s_sched_blkpt_block>:
  406690:	48 b9 9f 66 40 00 00 	movabs rcx,0x40669f
  406697:	00 00 00 
  40669a:	e9 61 56 00 00       	jmp    40bd00 <custom_acquire_stack>
  40669f:	52                   	push   rdx
  4066a0:	50                   	push   rax
  4066a1:	55                   	push   rbp
  4066a2:	4c 89 e1             	mov    rcx,r12
  4066a5:	48 31 ed             	xor    rbp,rbp
  4066a8:	48 89 f8             	mov    rax,rdi
  4066ab:	48 89 df             	mov    rdi,rbx
  4066ae:	48 89 c2             	mov    rdx,rax
  4066b1:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4066b5:	e8 66 e3 ff ff       	call   404a20 <sched_blkpt_block>
  4066ba:	49 89 c0             	mov    r8,rax
  4066bd:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  4066c4:	0f 05                	syscall 
  4066c6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4066cd:	00 00 00 

00000000004066d0 <__cosrt_alts_sched_blkpt_block>:
  4066d0:	4c 89 e8             	mov    rax,r13
  4066d3:	48 b9 e2 66 40 00 00 	movabs rcx,0x4066e2
  4066da:	00 00 00 
  4066dd:	e9 1e 56 00 00       	jmp    40bd00 <custom_acquire_stack>
  4066e2:	52                   	push   rdx
  4066e3:	50                   	push   rax
  4066e4:	55                   	push   rbp
  4066e5:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4066e9:	48 31 ed             	xor    rbp,rbp
  4066ec:	51                   	push   rcx
  4066ed:	51                   	push   rcx
  4066ee:	4c 89 c1             	mov    rcx,r8
  4066f1:	4c 89 ca             	mov    rdx,r9
  4066f4:	e8 27 e3 ff ff       	call   404a20 <sched_blkpt_block>
  4066f9:	59                   	pop    rcx
  4066fa:	c3                   	ret    
  4066fb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000406700 <__cosrt_s_sched_thd_block_timeout>:
  406700:	48 b9 0f 67 40 00 00 	movabs rcx,0x40670f
  406707:	00 00 00 
  40670a:	e9 f1 55 00 00       	jmp    40bd00 <custom_acquire_stack>
  40670f:	52                   	push   rdx
  406710:	50                   	push   rax
  406711:	55                   	push   rbp
  406712:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  406716:	6a 00                	push   0x0
  406718:	49 89 e0             	mov    r8,rsp
  40671b:	6a 00                	push   0x0
  40671d:	49 89 e1             	mov    r9,rsp
  406720:	4c 89 e1             	mov    rcx,r12
  406723:	48 31 ed             	xor    rbp,rbp
  406726:	49 89 fc             	mov    r12,rdi
  406729:	48 89 df             	mov    rdi,rbx
  40672c:	4c 89 e2             	mov    rdx,r12
  40672f:	e8 1c 03 00 00       	call   406a50 <__cosrt_s_cstub_sched_thd_block_timeout>
  406734:	5f                   	pop    rdi
  406735:	5e                   	pop    rsi
  406736:	49 89 c0             	mov    r8,rax
  406739:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  406740:	0f 05                	syscall 
  406742:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  406749:	00 00 00 00 
  40674d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000406750 <__cosrt_alts_sched_thd_block_timeout>:
  406750:	4c 89 e8             	mov    rax,r13
  406753:	48 b9 62 67 40 00 00 	movabs rcx,0x406762
  40675a:	00 00 00 
  40675d:	e9 9e 55 00 00       	jmp    40bd00 <custom_acquire_stack>
  406762:	52                   	push   rdx
  406763:	50                   	push   rax
  406764:	55                   	push   rbp
  406765:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  406769:	48 31 ed             	xor    rbp,rbp
  40676c:	51                   	push   rcx
  40676d:	51                   	push   rcx
  40676e:	4c 89 c1             	mov    rcx,r8
  406771:	4c 89 ca             	mov    rdx,r9
  406774:	6a 00                	push   0x0
  406776:	49 89 e0             	mov    r8,rsp
  406779:	6a 00                	push   0x0
  40677b:	49 89 e1             	mov    r9,rsp
  40677e:	e8 cd 02 00 00       	call   406a50 <__cosrt_s_cstub_sched_thd_block_timeout>
  406783:	5f                   	pop    rdi
  406784:	5e                   	pop    rsi
  406785:	59                   	pop    rcx
  406786:	c3                   	ret    
  406787:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40678e:	00 00 

0000000000406790 <__cosrt_s_sched_thd_create_closure>:
  406790:	48 b9 9f 67 40 00 00 	movabs rcx,0x40679f
  406797:	00 00 00 
  40679a:	e9 61 55 00 00       	jmp    40bd00 <custom_acquire_stack>
  40679f:	52                   	push   rdx
  4067a0:	50                   	push   rax
  4067a1:	55                   	push   rbp
  4067a2:	4c 89 e1             	mov    rcx,r12
  4067a5:	48 31 ed             	xor    rbp,rbp
  4067a8:	48 89 f8             	mov    rax,rdi
  4067ab:	48 89 df             	mov    rdi,rbx
  4067ae:	48 89 c2             	mov    rdx,rax
  4067b1:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4067b5:	e8 56 b9 ff ff       	call   402110 <sched_thd_create_closure>
  4067ba:	49 89 c0             	mov    r8,rax
  4067bd:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  4067c4:	0f 05                	syscall 
  4067c6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4067cd:	00 00 00 

00000000004067d0 <__cosrt_alts_sched_thd_create_closure>:
  4067d0:	4c 89 e8             	mov    rax,r13
  4067d3:	48 b9 e2 67 40 00 00 	movabs rcx,0x4067e2
  4067da:	00 00 00 
  4067dd:	e9 1e 55 00 00       	jmp    40bd00 <custom_acquire_stack>
  4067e2:	52                   	push   rdx
  4067e3:	50                   	push   rax
  4067e4:	55                   	push   rbp
  4067e5:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4067e9:	48 31 ed             	xor    rbp,rbp
  4067ec:	51                   	push   rcx
  4067ed:	51                   	push   rcx
  4067ee:	4c 89 c1             	mov    rcx,r8
  4067f1:	4c 89 ca             	mov    rdx,r9
  4067f4:	e8 17 b9 ff ff       	call   402110 <sched_thd_create_closure>
  4067f9:	59                   	pop    rcx
  4067fa:	c3                   	ret    
  4067fb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000406800 <__cosrt_s_sched_aep_create_closure>:
  406800:	48 b9 0f 68 40 00 00 	movabs rcx,0x40680f
  406807:	00 00 00 
  40680a:	e9 f1 54 00 00       	jmp    40bd00 <custom_acquire_stack>
  40680f:	52                   	push   rdx
  406810:	50                   	push   rax
  406811:	55                   	push   rbp
  406812:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  406816:	6a 00                	push   0x0
  406818:	49 89 e0             	mov    r8,rsp
  40681b:	6a 00                	push   0x0
  40681d:	49 89 e1             	mov    r9,rsp
  406820:	4c 89 e1             	mov    rcx,r12
  406823:	48 31 ed             	xor    rbp,rbp
  406826:	49 89 fc             	mov    r12,rdi
  406829:	48 89 df             	mov    rdi,rbx
  40682c:	4c 89 e2             	mov    rdx,r12
  40682f:	e8 5c 02 00 00       	call   406a90 <__cosrt_s_cstub_sched_aep_create_closure>
  406834:	5f                   	pop    rdi
  406835:	5e                   	pop    rsi
  406836:	49 89 c0             	mov    r8,rax
  406839:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  406840:	0f 05                	syscall 
  406842:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  406849:	00 00 00 00 
  40684d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000406850 <__cosrt_alts_sched_aep_create_closure>:
  406850:	4c 89 e8             	mov    rax,r13
  406853:	48 b9 62 68 40 00 00 	movabs rcx,0x406862
  40685a:	00 00 00 
  40685d:	e9 9e 54 00 00       	jmp    40bd00 <custom_acquire_stack>
  406862:	52                   	push   rdx
  406863:	50                   	push   rax
  406864:	55                   	push   rbp
  406865:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  406869:	48 31 ed             	xor    rbp,rbp
  40686c:	51                   	push   rcx
  40686d:	51                   	push   rcx
  40686e:	4c 89 c1             	mov    rcx,r8
  406871:	4c 89 ca             	mov    rdx,r9
  406874:	6a 00                	push   0x0
  406876:	49 89 e0             	mov    r8,rsp
  406879:	6a 00                	push   0x0
  40687b:	49 89 e1             	mov    r9,rsp
  40687e:	e8 0d 02 00 00       	call   406a90 <__cosrt_s_cstub_sched_aep_create_closure>
  406883:	5f                   	pop    rdi
  406884:	5e                   	pop    rsi
  406885:	59                   	pop    rcx
  406886:	c3                   	ret    
  406887:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40688e:	00 00 

0000000000406890 <__cosrt_s_sched_thd_param_set>:
  406890:	48 b9 9f 68 40 00 00 	movabs rcx,0x40689f
  406897:	00 00 00 
  40689a:	e9 61 54 00 00       	jmp    40bd00 <custom_acquire_stack>
  40689f:	52                   	push   rdx
  4068a0:	50                   	push   rax
  4068a1:	55                   	push   rbp
  4068a2:	4c 89 e1             	mov    rcx,r12
  4068a5:	48 31 ed             	xor    rbp,rbp
  4068a8:	48 89 f8             	mov    rax,rdi
  4068ab:	48 89 df             	mov    rdi,rbx
  4068ae:	48 89 c2             	mov    rdx,rax
  4068b1:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4068b5:	e8 a6 b8 ff ff       	call   402160 <sched_thd_param_set>
  4068ba:	49 89 c0             	mov    r8,rax
  4068bd:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  4068c4:	0f 05                	syscall 
  4068c6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4068cd:	00 00 00 

00000000004068d0 <__cosrt_alts_sched_thd_param_set>:
  4068d0:	4c 89 e8             	mov    rax,r13
  4068d3:	48 b9 e2 68 40 00 00 	movabs rcx,0x4068e2
  4068da:	00 00 00 
  4068dd:	e9 1e 54 00 00       	jmp    40bd00 <custom_acquire_stack>
  4068e2:	52                   	push   rdx
  4068e3:	50                   	push   rax
  4068e4:	55                   	push   rbp
  4068e5:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4068e9:	48 31 ed             	xor    rbp,rbp
  4068ec:	51                   	push   rcx
  4068ed:	51                   	push   rcx
  4068ee:	4c 89 c1             	mov    rcx,r8
  4068f1:	4c 89 ca             	mov    rdx,r9
  4068f4:	e8 67 b8 ff ff       	call   402160 <sched_thd_param_set>
  4068f9:	59                   	pop    rcx
  4068fa:	c3                   	ret    
  4068fb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000406900 <__cosrt_s_sched_thd_exit>:
  406900:	48 b9 0f 69 40 00 00 	movabs rcx,0x40690f
  406907:	00 00 00 
  40690a:	e9 f1 53 00 00       	jmp    40bd00 <custom_acquire_stack>
  40690f:	52                   	push   rdx
  406910:	50                   	push   rax
  406911:	55                   	push   rbp
  406912:	4c 89 e1             	mov    rcx,r12
  406915:	48 31 ed             	xor    rbp,rbp
  406918:	48 89 f8             	mov    rax,rdi
  40691b:	48 89 df             	mov    rdi,rbx
  40691e:	48 89 c2             	mov    rdx,rax
  406921:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  406925:	e8 b6 b8 ff ff       	call   4021e0 <sched_thd_exit>
  40692a:	49 89 c0             	mov    r8,rax
  40692d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  406934:	0f 05                	syscall 
  406936:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40693d:	00 00 00 

0000000000406940 <__cosrt_alts_sched_thd_exit>:
  406940:	4c 89 e8             	mov    rax,r13
  406943:	48 b9 52 69 40 00 00 	movabs rcx,0x406952
  40694a:	00 00 00 
  40694d:	e9 ae 53 00 00       	jmp    40bd00 <custom_acquire_stack>
  406952:	52                   	push   rdx
  406953:	50                   	push   rax
  406954:	55                   	push   rbp
  406955:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  406959:	48 31 ed             	xor    rbp,rbp
  40695c:	51                   	push   rcx
  40695d:	51                   	push   rcx
  40695e:	4c 89 c1             	mov    rcx,r8
  406961:	4c 89 ca             	mov    rdx,r9
  406964:	e8 77 b8 ff ff       	call   4021e0 <sched_thd_exit>
  406969:	59                   	pop    rcx
  40696a:	c3                   	ret    
  40696b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000406970 <__cosrt_s_sched_thd_delete>:
  406970:	48 b9 7f 69 40 00 00 	movabs rcx,0x40697f
  406977:	00 00 00 
  40697a:	e9 81 53 00 00       	jmp    40bd00 <custom_acquire_stack>
  40697f:	52                   	push   rdx
  406980:	50                   	push   rax
  406981:	55                   	push   rbp
  406982:	4c 89 e1             	mov    rcx,r12
  406985:	48 31 ed             	xor    rbp,rbp
  406988:	48 89 f8             	mov    rax,rdi
  40698b:	48 89 df             	mov    rdi,rbx
  40698e:	48 89 c2             	mov    rdx,rax
  406991:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  406995:	e8 36 b8 ff ff       	call   4021d0 <sched_thd_delete>
  40699a:	49 89 c0             	mov    r8,rax
  40699d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  4069a4:	0f 05                	syscall 
  4069a6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4069ad:	00 00 00 

00000000004069b0 <__cosrt_alts_sched_thd_delete>:
  4069b0:	4c 89 e8             	mov    rax,r13
  4069b3:	48 b9 c2 69 40 00 00 	movabs rcx,0x4069c2
  4069ba:	00 00 00 
  4069bd:	e9 3e 53 00 00       	jmp    40bd00 <custom_acquire_stack>
  4069c2:	52                   	push   rdx
  4069c3:	50                   	push   rax
  4069c4:	55                   	push   rbp
  4069c5:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4069c9:	48 31 ed             	xor    rbp,rbp
  4069cc:	51                   	push   rcx
  4069cd:	51                   	push   rcx
  4069ce:	4c 89 c1             	mov    rcx,r8
  4069d1:	4c 89 ca             	mov    rdx,r9
  4069d4:	e8 f7 b7 ff ff       	call   4021d0 <sched_thd_delete>
  4069d9:	59                   	pop    rcx
  4069da:	c3                   	ret    
  4069db:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000004069e0 <__cosrt_s_sched_set_tls>:
  4069e0:	48 b9 ef 69 40 00 00 	movabs rcx,0x4069ef
  4069e7:	00 00 00 
  4069ea:	e9 11 53 00 00       	jmp    40bd00 <custom_acquire_stack>
  4069ef:	52                   	push   rdx
  4069f0:	50                   	push   rax
  4069f1:	55                   	push   rbp
  4069f2:	4c 89 e1             	mov    rcx,r12
  4069f5:	48 31 ed             	xor    rbp,rbp
  4069f8:	48 89 f8             	mov    rax,rdi
  4069fb:	48 89 df             	mov    rdi,rbx
  4069fe:	48 89 c2             	mov    rdx,rax
  406a01:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  406a05:	e8 b6 c0 ff ff       	call   402ac0 <sched_set_tls>
  406a0a:	49 89 c0             	mov    r8,rax
  406a0d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  406a14:	0f 05                	syscall 
  406a16:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  406a1d:	00 00 00 

0000000000406a20 <__cosrt_alts_sched_set_tls>:
  406a20:	4c 89 e8             	mov    rax,r13
  406a23:	48 b9 32 6a 40 00 00 	movabs rcx,0x406a32
  406a2a:	00 00 00 
  406a2d:	e9 ce 52 00 00       	jmp    40bd00 <custom_acquire_stack>
  406a32:	52                   	push   rdx
  406a33:	50                   	push   rax
  406a34:	55                   	push   rbp
  406a35:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  406a39:	48 31 ed             	xor    rbp,rbp
  406a3c:	51                   	push   rcx
  406a3d:	51                   	push   rcx
  406a3e:	4c 89 c1             	mov    rcx,r8
  406a41:	4c 89 ca             	mov    rdx,r9
  406a44:	e8 77 c0 ff ff       	call   402ac0 <sched_set_tls>
  406a49:	59                   	pop    rcx
  406a4a:	c3                   	ret    
  406a4b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000406a50 <__cosrt_s_cstub_sched_thd_block_timeout>:
#include <cos_stubs.h>
#include <sched.h>

COS_SERVER_3RET_STUB(int, sched_thd_block_timeout)
{
  406a50:	f3 0f 1e fa          	endbr64 
	cycles_t elapsed = 0, abs_timeout;

	/* works on armv7a too, as we control where hi and lo are passed for timeout */
	COS_ARG_WORDS_TO_DWORD(p1, p2, abs_timeout);
	elapsed = sched_thd_block_timeout((thdid_t)p0, abs_timeout);
  406a54:	48 b8 d0 3d 40 00 00 	movabs rax,0x403dd0
  406a5b:	00 00 00 
{
  406a5e:	55                   	push   rbp
  406a5f:	48 89 e5             	mov    rbp,rsp
  406a62:	41 54                	push   r12
  406a64:	4d 89 c4             	mov    r12,r8
  406a67:	53                   	push   rbx
  406a68:	4c 89 cb             	mov    rbx,r9
	elapsed = sched_thd_block_timeout((thdid_t)p0, abs_timeout);
  406a6b:	ff d0                	call   rax
	*r1 = (elapsed >> 32);
  406a6d:	48 89 c2             	mov    rdx,rax
	*r2 = (elapsed << 32) >> 32;
  406a70:	83 e0 ff             	and    eax,0xffffffff
	*r1 = (elapsed >> 32);
  406a73:	48 c1 ea 20          	shr    rdx,0x20
  406a77:	49 89 14 24          	mov    QWORD PTR [r12],rdx
	*r2 = (elapsed << 32) >> 32;
  406a7b:	48 89 03             	mov    QWORD PTR [rbx],rax

	return 0;
}
  406a7e:	5b                   	pop    rbx
  406a7f:	31 c0                	xor    eax,eax
  406a81:	41 5c                	pop    r12
  406a83:	5d                   	pop    rbp
  406a84:	c3                   	ret    
  406a85:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  406a8c:	00 00 00 00 

0000000000406a90 <__cosrt_s_cstub_sched_aep_create_closure>:

COS_SERVER_3RET_STUB(thdid_t, sched_aep_create_closure)
{
  406a90:	f3 0f 1e fa          	endbr64 
  406a94:	55                   	push   rbp
  406a95:	48 89 f8             	mov    rax,rdi
  406a98:	48 89 d1             	mov    rcx,rdx
	u32_t               ipimax = (p1 << 16) >> 16;
	cos_channelkey_t    key    = (p1 >> 16);
	arcvcap_t rcv;
	thdid_t ret;

	ret = sched_aep_create_closure(idx, owntc, key, ipiwin, ipimax, &rcv);
  406a9b:	89 f2                	mov    edx,esi
  406a9d:	c1 ea 10             	shr    edx,0x10
	thdclosure_index_t  idx    = (p0 >> 16);
  406aa0:	48 c1 ef 10          	shr    rdi,0x10
{
  406aa4:	48 89 e5             	mov    rbp,rsp
  406aa7:	41 54                	push   r12
  406aa9:	4d 89 c4             	mov    r12,r8
	ret = sched_aep_create_closure(idx, owntc, key, ipiwin, ipimax, &rcv);
  406aac:	41 89 f0             	mov    r8d,esi
{
  406aaf:	53                   	push   rbx
	ret = sched_aep_create_closure(idx, owntc, key, ipiwin, ipimax, &rcv);
  406ab0:	89 c6                	mov    esi,eax
{
  406ab2:	4c 89 cb             	mov    rbx,r9
	ret = sched_aep_create_closure(idx, owntc, key, ipiwin, ipimax, &rcv);
  406ab5:	4c 8d 4d e8          	lea    r9,[rbp-0x18]
  406ab9:	48 b8 60 52 40 00 00 	movabs rax,0x405260
  406ac0:	00 00 00 
{
  406ac3:	48 83 ec 10          	sub    rsp,0x10
	ret = sched_aep_create_closure(idx, owntc, key, ipiwin, ipimax, &rcv);
  406ac7:	ff d0                	call   rax

	*r1 = rcv;
  406ac9:	48 8b 55 e8          	mov    rdx,QWORD PTR [rbp-0x18]
  406acd:	49 89 14 24          	mov    QWORD PTR [r12],rdx
	*r2 = 0;
  406ad1:	48 c7 03 00 00 00 00 	mov    QWORD PTR [rbx],0x0

	return ret;
}
  406ad8:	48 83 c4 10          	add    rsp,0x10
  406adc:	5b                   	pop    rbx
  406add:	41 5c                	pop    r12
  406adf:	5d                   	pop    rbp
  406ae0:	c3                   	ret    
  406ae1:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  406ae8:	00 00 00 
  406aeb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000406af0 <__cosrt_s_init_done>:
  406af0:	48 b9 ff 6a 40 00 00 	movabs rcx,0x406aff
  406af7:	00 00 00 
  406afa:	e9 01 52 00 00       	jmp    40bd00 <custom_acquire_stack>
  406aff:	52                   	push   rdx
  406b00:	50                   	push   rax
  406b01:	55                   	push   rbp
  406b02:	4c 89 e1             	mov    rcx,r12
  406b05:	48 31 ed             	xor    rbp,rbp
  406b08:	48 89 f8             	mov    rax,rdi
  406b0b:	48 89 df             	mov    rdi,rbx
  406b0e:	48 89 c2             	mov    rdx,rax
  406b11:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  406b15:	e8 26 9a ff ff       	call   400540 <init_done>
  406b1a:	49 89 c0             	mov    r8,rax
  406b1d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  406b24:	0f 05                	syscall 
  406b26:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  406b2d:	00 00 00 

0000000000406b30 <__cosrt_alts_init_done>:
  406b30:	4c 89 e8             	mov    rax,r13
  406b33:	48 b9 42 6b 40 00 00 	movabs rcx,0x406b42
  406b3a:	00 00 00 
  406b3d:	e9 be 51 00 00       	jmp    40bd00 <custom_acquire_stack>
  406b42:	52                   	push   rdx
  406b43:	50                   	push   rax
  406b44:	55                   	push   rbp
  406b45:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  406b49:	48 31 ed             	xor    rbp,rbp
  406b4c:	51                   	push   rcx
  406b4d:	51                   	push   rcx
  406b4e:	4c 89 c1             	mov    rcx,r8
  406b51:	4c 89 ca             	mov    rdx,r9
  406b54:	e8 e7 99 ff ff       	call   400540 <init_done>
  406b59:	59                   	pop    rcx
  406b5a:	c3                   	ret    
  406b5b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000406b60 <__cosrt_s_init_exit>:
  406b60:	48 b9 6f 6b 40 00 00 	movabs rcx,0x406b6f
  406b67:	00 00 00 
  406b6a:	e9 91 51 00 00       	jmp    40bd00 <custom_acquire_stack>
  406b6f:	52                   	push   rdx
  406b70:	50                   	push   rax
  406b71:	55                   	push   rbp
  406b72:	4c 89 e1             	mov    rcx,r12
  406b75:	48 31 ed             	xor    rbp,rbp
  406b78:	48 89 f8             	mov    rax,rdi
  406b7b:	48 89 df             	mov    rdi,rbx
  406b7e:	48 89 c2             	mov    rdx,rax
  406b81:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  406b85:	e8 f6 9a ff ff       	call   400680 <init_exit>
  406b8a:	49 89 c0             	mov    r8,rax
  406b8d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  406b94:	0f 05                	syscall 
  406b96:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  406b9d:	00 00 00 

0000000000406ba0 <__cosrt_alts_init_exit>:
  406ba0:	4c 89 e8             	mov    rax,r13
  406ba3:	48 b9 b2 6b 40 00 00 	movabs rcx,0x406bb2
  406baa:	00 00 00 
  406bad:	e9 4e 51 00 00       	jmp    40bd00 <custom_acquire_stack>
  406bb2:	52                   	push   rdx
  406bb3:	50                   	push   rax
  406bb4:	55                   	push   rbp
  406bb5:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  406bb9:	48 31 ed             	xor    rbp,rbp
  406bbc:	51                   	push   rcx
  406bbd:	51                   	push   rcx
  406bbe:	4c 89 c1             	mov    rcx,r8
  406bc1:	4c 89 ca             	mov    rdx,r9
  406bc4:	e8 b7 9a ff ff       	call   400680 <init_exit>
  406bc9:	59                   	pop    rcx
  406bca:	c3                   	ret    
  406bcb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000406bd0 <__cosrt_c_init_done>:
 * to serialize and deserialize arguments. In contrast, this code
 * doesn't have a corresponding client-side stub as it only
 * orchestrates the coordination with the await_init function.
 */
COS_CLIENT_STUB(int, init_done, int parallel_init, init_main_t cont)
{
  406bd0:	f3 0f 1e fa          	endbr64 
  406bd4:	55                   	push   rbp
	COS_CLIENT_INVCAP;
	int ret;

	ret = cos_sinv(uc, parallel_init, cont, 0, 0);
  406bd5:	89 f6                	mov    esi,esi
  406bd7:	4c 63 d7             	movsxd r10,edi
{
  406bda:	48 89 e5             	mov    rbp,rsp
  406bdd:	41 55                	push   r13
  406bdf:	41 54                	push   r12
  406be1:	53                   	push   rbx
  406be2:	48 83 ec 28          	sub    rsp,0x28
  406be6:	4c 8b 68 10          	mov    r13,QWORD PTR [rax+0x10]
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, &r1, &r2);
  406bea:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  406bee:	4d 85 ed             	test   r13,r13
  406bf1:	74 2d                	je     406c20 <__cosrt_c_init_done+0x50>
  406bf3:	4c 8d 4d d0          	lea    r9,[rbp-0x30]
  406bf7:	4c 8d 45 c8          	lea    r8,[rbp-0x38]
  406bfb:	31 c9                	xor    ecx,ecx
  406bfd:	31 d2                	xor    edx,edx
  406bff:	4c 89 d7             	mov    rdi,r10
  406c02:	41 ff d5             	call   r13
	ps_store(&awaiting_init, 0);
  406c05:	48 bb 04 80 42 00 00 	movabs rbx,0x428004
  406c0c:	00 00 00 
  406c0f:	c7 03 00 00 00 00    	mov    DWORD PTR [rbx],0x0

	return ret;
}
  406c15:	48 83 c4 28          	add    rsp,0x28
  406c19:	5b                   	pop    rbx
  406c1a:	41 5c                	pop    r12
  406c1c:	41 5d                	pop    r13
  406c1e:	5d                   	pop    rbp
  406c1f:	c3                   	ret    
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  406c20:	8d 42 01             	lea    eax,[rdx+0x1]
	__asm__ __volatile__(
  406c23:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  406c27:	4c 89 d3             	mov    rbx,r10
  406c2a:	4c 89 ef             	mov    rdi,r13
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  406c2d:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  406c30:	4c 89 ea             	mov    rdx,r13
  406c33:	48 89 29             	mov    QWORD PTR [rcx],rbp
  406c36:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  406c3a:	48 89 cd             	mov    rbp,rcx
  406c3d:	49 b8 58 6c 40 00 00 	movabs r8,0x406c58
  406c44:	00 00 00 
  406c47:	0f 05                	syscall 
  406c49:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  406c50:	eb 0d                	jmp    406c5f <__cosrt_c_init_done+0x8f>
  406c52:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  406c58:	b9 00 00 00 00       	mov    ecx,0x0
  406c5d:	eb 05                	jmp    406c64 <__cosrt_c_init_done+0x94>
  406c5f:	b9 01 00 00 00       	mov    ecx,0x1
  406c64:	5d                   	pop    rbp
  406c65:	5c                   	pop    rsp
	return call_cap_op(uc->cap_no, 0, arg1, arg2, arg3, arg4);
  406c66:	eb 9d                	jmp    406c05 <__cosrt_c_init_done+0x35>
  406c68:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  406c6f:	00 

0000000000406c70 <__cosrt_extern_init_parallel_await_init>:
 * This function is implemented as a library compiled directly into
 * the client component.
 */
void
COS_STUB_LIBFN(init_parallel_await_init)(void)
{
  406c70:	f3 0f 1e fa          	endbr64 
	while (ps_load(&awaiting_init)) ;
  406c74:	48 ba 04 80 42 00 00 	movabs rdx,0x428004
  406c7b:	00 00 00 
  406c7e:	66 90                	xchg   ax,ax
  406c80:	8b 02                	mov    eax,DWORD PTR [rdx]
  406c82:	85 c0                	test   eax,eax
  406c84:	75 fa                	jne    406c80 <__cosrt_extern_init_parallel_await_init+0x10>
}
  406c86:	c3                   	ret    
  406c87:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  406c8e:	00 00 

0000000000406c90 <__cosrt_extern_init_done>:
  406c90:	48 b8 cc 00 46 00 00 	movabs rax,0x4600cc
  406c97:	00 00 00 
  406c9a:	ff 10                	call   QWORD PTR [rax]
  406c9c:	c3                   	ret    
  406c9d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000406ca0 <__cosrt_fast_callgate_init_done>:
  406ca0:	55                   	push   rbp
  406ca1:	41 55                	push   r13
  406ca3:	41 56                	push   r14
  406ca5:	41 57                	push   r15
  406ca7:	49 89 c8             	mov    r8,rcx
  406caa:	49 89 d1             	mov    r9,rdx
  406cad:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  406cb4:	be ad de 
  406cb7:	0f 01 f9             	rdtscp 
  406cba:	48 89 c8             	mov    rax,rcx
  406cbd:	48 25 ff 0f 00 00    	and    rax,0xfff
  406cc3:	48 89 e2             	mov    rdx,rsp
  406cc6:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  406ccd:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  406cd4:	00 
  406cd5:	48 c1 e0 10          	shl    rax,0x10
  406cd9:	49 09 c5             	or     r13,rax
  406cdc:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  406ce3:	7f 00 00 
  406ce6:	4c 89 e8             	mov    rax,r13
  406ce9:	48 25 ff ff 00 00    	and    rax,0xffff
  406cef:	48 c1 e0 08          	shl    rax,0x8
  406cf3:	49 01 c6             	add    r14,rax
  406cf6:	b9 01 00 00 00       	mov    ecx,0x1
  406cfb:	01 c9                	add    ecx,ecx
  406cfd:	b8 03 00 00 00       	mov    eax,0x3
  406d02:	d3 e0                	shl    eax,cl
  406d04:	f7 d0                	not    eax
  406d06:	83 e0 fc             	and    eax,0xfffffffc
  406d09:	48 31 c9             	xor    rcx,rcx
  406d0c:	48 31 d2             	xor    rdx,rdx
  406d0f:	0f 01 ef             	wrpkru 
  406d12:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  406d15:	48 83 c2 01          	add    rdx,0x1
  406d19:	48 c1 e2 04          	shl    rdx,0x4
  406d1d:	4c 01 f2             	add    rdx,r14
  406d20:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  406d27:	45 23 01 
  406d2a:	48 89 02             	mov    QWORD PTR [rdx],rax
  406d2d:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  406d31:	49 8b 06             	mov    rax,QWORD PTR [r14]
  406d34:	48 83 c0 01          	add    rax,0x1
  406d38:	49 89 06             	mov    QWORD PTR [r14],rax
  406d3b:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  406d40:	01 c9                	add    ecx,ecx
  406d42:	b8 03 00 00 00       	mov    eax,0x3
  406d47:	d3 e0                	shl    eax,cl
  406d49:	f7 d0                	not    eax
  406d4b:	83 e0 fc             	and    eax,0xfffffffc
  406d4e:	48 31 c9             	xor    rcx,rcx
  406d51:	48 31 d2             	xor    rdx,rdx
  406d54:	0f 01 ef             	wrpkru 
  406d57:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  406d5e:	45 23 01 
  406d61:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  406d68:	be ad de 
  406d6b:	49 39 c7             	cmp    r15,rax
  406d6e:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  406d75:	12 12 12 
  406d78:	48 b9 84 6d 40 00 00 	movabs rcx,0x406d84
  406d7f:	00 00 00 
  406d82:	ff e0                	jmp    rax

0000000000406d84 <srv_call_ret_init_done>:
  406d84:	49 89 c0             	mov    r8,rax
  406d87:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  406d8e:	be ad de 
  406d91:	48 89 e2             	mov    rdx,rsp
  406d94:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  406d9b:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  406da2:	00 
  406da3:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  406daa:	7f 00 00 
  406dad:	4c 89 e8             	mov    rax,r13
  406db0:	48 25 ff ff 00 00    	and    rax,0xffff
  406db6:	48 c1 e0 08          	shl    rax,0x8
  406dba:	49 01 c6             	add    r14,rax
  406dbd:	b9 01 00 00 00       	mov    ecx,0x1
  406dc2:	01 c9                	add    ecx,ecx
  406dc4:	b8 03 00 00 00       	mov    eax,0x3
  406dc9:	d3 e0                	shl    eax,cl
  406dcb:	f7 d0                	not    eax
  406dcd:	83 e0 fc             	and    eax,0xfffffffc
  406dd0:	48 31 c9             	xor    rcx,rcx
  406dd3:	48 31 d2             	xor    rdx,rdx
  406dd6:	0f 01 ef             	wrpkru 
  406dd9:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  406ddc:	48 c1 e2 04          	shl    rdx,0x4
  406de0:	4c 01 f2             	add    rdx,r14
  406de3:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  406de7:	49 8b 06             	mov    rax,QWORD PTR [r14]
  406dea:	48 83 e8 01          	sub    rax,0x1
  406dee:	49 89 06             	mov    QWORD PTR [r14],rax
  406df1:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  406df6:	01 c9                	add    ecx,ecx
  406df8:	b8 03 00 00 00       	mov    eax,0x3
  406dfd:	d3 e0                	shl    eax,cl
  406dff:	f7 d0                	not    eax
  406e01:	83 e0 fc             	and    eax,0xfffffffc
  406e04:	48 31 c9             	xor    rcx,rcx
  406e07:	48 31 d2             	xor    rdx,rdx
  406e0a:	0f 01 ef             	wrpkru 
  406e0d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  406e14:	be ad de 
  406e17:	49 39 c7             	cmp    r15,rax
  406e1a:	4c 89 c0             	mov    rax,r8
  406e1d:	41 5f                	pop    r15
  406e1f:	41 5e                	pop    r14
  406e21:	41 5d                	pop    r13
  406e23:	5d                   	pop    rbp
  406e24:	c3                   	ret    
  406e25:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  406e2c:	00 00 00 00 

0000000000406e30 <__cosrt_extern_init_exit>:
  406e30:	48 b8 e4 00 46 00 00 	movabs rax,0x4600e4
  406e37:	00 00 00 
  406e3a:	ff 10                	call   QWORD PTR [rax]
  406e3c:	c3                   	ret    
  406e3d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000406e40 <__cosrt_fast_callgate_init_exit>:
  406e40:	55                   	push   rbp
  406e41:	41 55                	push   r13
  406e43:	41 56                	push   r14
  406e45:	41 57                	push   r15
  406e47:	49 89 c8             	mov    r8,rcx
  406e4a:	49 89 d1             	mov    r9,rdx
  406e4d:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  406e54:	be ad de 
  406e57:	0f 01 f9             	rdtscp 
  406e5a:	48 89 c8             	mov    rax,rcx
  406e5d:	48 25 ff 0f 00 00    	and    rax,0xfff
  406e63:	48 89 e2             	mov    rdx,rsp
  406e66:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  406e6d:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  406e74:	00 
  406e75:	48 c1 e0 10          	shl    rax,0x10
  406e79:	49 09 c5             	or     r13,rax
  406e7c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  406e83:	7f 00 00 
  406e86:	4c 89 e8             	mov    rax,r13
  406e89:	48 25 ff ff 00 00    	and    rax,0xffff
  406e8f:	48 c1 e0 08          	shl    rax,0x8
  406e93:	49 01 c6             	add    r14,rax
  406e96:	b9 01 00 00 00       	mov    ecx,0x1
  406e9b:	01 c9                	add    ecx,ecx
  406e9d:	b8 03 00 00 00       	mov    eax,0x3
  406ea2:	d3 e0                	shl    eax,cl
  406ea4:	f7 d0                	not    eax
  406ea6:	83 e0 fc             	and    eax,0xfffffffc
  406ea9:	48 31 c9             	xor    rcx,rcx
  406eac:	48 31 d2             	xor    rdx,rdx
  406eaf:	0f 01 ef             	wrpkru 
  406eb2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  406eb5:	48 83 c2 01          	add    rdx,0x1
  406eb9:	48 c1 e2 04          	shl    rdx,0x4
  406ebd:	4c 01 f2             	add    rdx,r14
  406ec0:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  406ec7:	45 23 01 
  406eca:	48 89 02             	mov    QWORD PTR [rdx],rax
  406ecd:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  406ed1:	49 8b 06             	mov    rax,QWORD PTR [r14]
  406ed4:	48 83 c0 01          	add    rax,0x1
  406ed8:	49 89 06             	mov    QWORD PTR [r14],rax
  406edb:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  406ee0:	01 c9                	add    ecx,ecx
  406ee2:	b8 03 00 00 00       	mov    eax,0x3
  406ee7:	d3 e0                	shl    eax,cl
  406ee9:	f7 d0                	not    eax
  406eeb:	83 e0 fc             	and    eax,0xfffffffc
  406eee:	48 31 c9             	xor    rcx,rcx
  406ef1:	48 31 d2             	xor    rdx,rdx
  406ef4:	0f 01 ef             	wrpkru 
  406ef7:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  406efe:	45 23 01 
  406f01:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  406f08:	be ad de 
  406f0b:	49 39 c7             	cmp    r15,rax
  406f0e:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  406f15:	12 12 12 
  406f18:	48 b9 24 6f 40 00 00 	movabs rcx,0x406f24
  406f1f:	00 00 00 
  406f22:	ff e0                	jmp    rax

0000000000406f24 <srv_call_ret_init_exit>:
  406f24:	49 89 c0             	mov    r8,rax
  406f27:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  406f2e:	be ad de 
  406f31:	48 89 e2             	mov    rdx,rsp
  406f34:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  406f3b:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  406f42:	00 
  406f43:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  406f4a:	7f 00 00 
  406f4d:	4c 89 e8             	mov    rax,r13
  406f50:	48 25 ff ff 00 00    	and    rax,0xffff
  406f56:	48 c1 e0 08          	shl    rax,0x8
  406f5a:	49 01 c6             	add    r14,rax
  406f5d:	b9 01 00 00 00       	mov    ecx,0x1
  406f62:	01 c9                	add    ecx,ecx
  406f64:	b8 03 00 00 00       	mov    eax,0x3
  406f69:	d3 e0                	shl    eax,cl
  406f6b:	f7 d0                	not    eax
  406f6d:	83 e0 fc             	and    eax,0xfffffffc
  406f70:	48 31 c9             	xor    rcx,rcx
  406f73:	48 31 d2             	xor    rdx,rdx
  406f76:	0f 01 ef             	wrpkru 
  406f79:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  406f7c:	48 c1 e2 04          	shl    rdx,0x4
  406f80:	4c 01 f2             	add    rdx,r14
  406f83:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  406f87:	49 8b 06             	mov    rax,QWORD PTR [r14]
  406f8a:	48 83 e8 01          	sub    rax,0x1
  406f8e:	49 89 06             	mov    QWORD PTR [r14],rax
  406f91:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  406f96:	01 c9                	add    ecx,ecx
  406f98:	b8 03 00 00 00       	mov    eax,0x3
  406f9d:	d3 e0                	shl    eax,cl
  406f9f:	f7 d0                	not    eax
  406fa1:	83 e0 fc             	and    eax,0xfffffffc
  406fa4:	48 31 c9             	xor    rcx,rcx
  406fa7:	48 31 d2             	xor    rdx,rdx
  406faa:	0f 01 ef             	wrpkru 
  406fad:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  406fb4:	be ad de 
  406fb7:	49 39 c7             	cmp    r15,rax
  406fba:	4c 89 c0             	mov    rax,r8
  406fbd:	41 5f                	pop    r15
  406fbf:	41 5e                	pop    r14
  406fc1:	41 5d                	pop    r13
  406fc3:	5d                   	pop    rbp
  406fc4:	c3                   	ret    
  406fc5:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  406fcc:	00 00 00 
  406fcf:	90                   	nop

0000000000406fd0 <__cosrt_c_capmgr_rcv_create>:
#include <cos_thd_init.h>
#include <cos_defkernel_api.h>
#include <cos_stubs.h>

COS_CLIENT_STUB(arcvcap_t, capmgr_rcv_create, thdclosure_index_t idx, int flags, asndcap_t *asnd, thdcap_t *thdcap, thdid_t *tid)
{
  406fd0:	f3 0f 1e fa          	endbr64 
  406fd4:	55                   	push   rbp
	COS_CLIENT_INVCAP;
	word_t thdret, asnd_ret;
	arcvcap_t ret;

	ret = cos_sinv_2rets(uc, idx, flags, 0, 0, &asnd_ret, &thdret);
  406fd5:	48 63 f6             	movsxd rsi,esi
{
  406fd8:	48 89 e5             	mov    rbp,rsp
  406fdb:	41 57                	push   r15
  406fdd:	41 56                	push   r14
  406fdf:	49 89 d6             	mov    r14,rdx
  406fe2:	41 55                	push   r13
  406fe4:	49 89 cd             	mov    r13,rcx
  406fe7:	41 54                	push   r12
  406fe9:	53                   	push   rbx
	ret = cos_sinv_2rets(uc, idx, flags, 0, 0, &asnd_ret, &thdret);
  406fea:	48 63 df             	movsxd rbx,edi
{
  406fed:	48 83 ec 38          	sub    rsp,0x38
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  406ff1:	4c 8b 78 10          	mov    r15,QWORD PTR [rax+0x10]
  406ff5:	4c 89 45 a8          	mov    QWORD PTR [rbp-0x58],r8
  406ff9:	4d 85 ff             	test   r15,r15
  406ffc:	74 4a                	je     407048 <__cosrt_c_capmgr_rcv_create+0x78>
  406ffe:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  407002:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  407006:	31 c9                	xor    ecx,ecx
  407008:	31 d2                	xor    edx,edx
  40700a:	48 89 df             	mov    rdi,rbx
  40700d:	41 ff d7             	call   r15
	*asnd   = asnd_ret;
  407010:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
	*thdcap = (thdcap_t)thdret >> 16;
	*tid    = (thdid_t)thdret & 0xFFFF;
  407014:	48 8b 5d a8          	mov    rbx,QWORD PTR [rbp-0x58]
	ret = cos_sinv_2rets(uc, idx, flags, 0, 0, &asnd_ret, &thdret);
  407018:	48 98                	cdqe   
	*asnd   = asnd_ret;
  40701a:	49 89 16             	mov    QWORD PTR [r14],rdx
	*thdcap = (thdcap_t)thdret >> 16;
  40701d:	48 8b 55 b0          	mov    rdx,QWORD PTR [rbp-0x50]
  407021:	48 89 d1             	mov    rcx,rdx
	*tid    = (thdid_t)thdret & 0xFFFF;
  407024:	81 e2 ff ff 00 00    	and    edx,0xffff
	*thdcap = (thdcap_t)thdret >> 16;
  40702a:	48 c1 e9 10          	shr    rcx,0x10
  40702e:	49 89 4d 00          	mov    QWORD PTR [r13+0x0],rcx
	*tid    = (thdid_t)thdret & 0xFFFF;
  407032:	48 89 13             	mov    QWORD PTR [rbx],rdx

	return ret;
}
  407035:	48 83 c4 38          	add    rsp,0x38
  407039:	5b                   	pop    rbx
  40703a:	41 5c                	pop    r12
  40703c:	41 5d                	pop    r13
  40703e:	41 5e                	pop    r14
  407040:	41 5f                	pop    r15
  407042:	5d                   	pop    rbp
  407043:	c3                   	ret    
  407044:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  407048:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  40704c:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  407050:	4c 89 ff             	mov    rdi,r15
  407053:	4c 89 fa             	mov    rdx,r15
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  407056:	83 c0 01             	add    eax,0x1
  407059:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40705c:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40705f:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  407063:	48 89 cd             	mov    rbp,rcx
  407066:	49 b8 80 70 40 00 00 	movabs r8,0x407080
  40706d:	00 00 00 
  407070:	0f 05                	syscall 
  407072:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  407078:	eb 0f                	jmp    407089 <__cosrt_c_capmgr_rcv_create+0xb9>
  40707a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  407080:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  407087:	eb 07                	jmp    407090 <__cosrt_c_capmgr_rcv_create+0xc0>
  407089:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  407090:	5d                   	pop    rbp
  407091:	5c                   	pop    rsp
  407092:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
  407096:	48 89 7d b0          	mov    QWORD PTR [rbp-0x50],rdi
	return ret;
  40709a:	e9 71 ff ff ff       	jmp    407010 <__cosrt_c_capmgr_rcv_create+0x40>
  40709f:	90                   	nop

00000000004070a0 <__cosrt_c_capmgr_shared_kernel_page_create>:

COS_CLIENT_STUB(vaddr_t, capmgr_shared_kernel_page_create, vaddr_t *resource)
{
  4070a0:	f3 0f 1e fa          	endbr64 
  4070a4:	55                   	push   rbp
  4070a5:	48 89 e5             	mov    rbp,rsp
  4070a8:	41 55                	push   r13
  4070aa:	49 89 fd             	mov    r13,rdi
  4070ad:	41 54                	push   r12
  4070af:	53                   	push   rbx
  4070b0:	48 83 ec 28          	sub    rsp,0x28
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  4070b4:	48 8b 58 10          	mov    rbx,QWORD PTR [rax+0x10]
  4070b8:	48 85 db             	test   rbx,rbx
  4070bb:	74 2b                	je     4070e8 <__cosrt_c_capmgr_shared_kernel_page_create+0x48>
  4070bd:	4c 8d 4d c8          	lea    r9,[rbp-0x38]
  4070c1:	4c 8d 45 c0          	lea    r8,[rbp-0x40]
  4070c5:	31 c9                	xor    ecx,ecx
  4070c7:	31 d2                	xor    edx,edx
  4070c9:	31 f6                	xor    esi,esi
  4070cb:	31 ff                	xor    edi,edi
  4070cd:	ff d3                	call   rbx
	COS_CLIENT_INVCAP;
	word_t ret1, ret2;
	vaddr_t ret;

	ret = cos_sinv_2rets(uc, 0, 0, 0, 0, &ret1, &ret2);
	*resource   = ret1;
  4070cf:	48 8b 55 c0          	mov    rdx,QWORD PTR [rbp-0x40]
	ret = cos_sinv_2rets(uc, 0, 0, 0, 0, &ret1, &ret2);
  4070d3:	48 98                	cdqe   
	*resource   = ret1;
  4070d5:	49 89 55 00          	mov    QWORD PTR [r13+0x0],rdx

	return ret;
}
  4070d9:	48 83 c4 28          	add    rsp,0x28
  4070dd:	5b                   	pop    rbx
  4070de:	41 5c                	pop    r12
  4070e0:	41 5d                	pop    r13
  4070e2:	5d                   	pop    rbp
  4070e3:	c3                   	ret    
  4070e4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  4070e8:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  4070ec:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  4070f0:	48 89 de             	mov    rsi,rbx
  4070f3:	48 89 df             	mov    rdi,rbx
  4070f6:	48 89 da             	mov    rdx,rbx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4070f9:	83 c0 01             	add    eax,0x1
  4070fc:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  4070ff:	48 89 29             	mov    QWORD PTR [rcx],rbp
  407102:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  407106:	48 89 cd             	mov    rbp,rcx
  407109:	49 b8 20 71 40 00 00 	movabs r8,0x407120
  407110:	00 00 00 
  407113:	0f 05                	syscall 
  407115:	0f 1f 00             	nop    DWORD PTR [rax]
  407118:	eb 0f                	jmp    407129 <__cosrt_c_capmgr_shared_kernel_page_create+0x89>
  40711a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  407120:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  407127:	eb 07                	jmp    407130 <__cosrt_c_capmgr_shared_kernel_page_create+0x90>
  407129:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  407130:	5d                   	pop    rbp
  407131:	5c                   	pop    rsp
  407132:	48 89 75 c0          	mov    QWORD PTR [rbp-0x40],rsi
	return ret;
  407136:	eb 97                	jmp    4070cf <__cosrt_c_capmgr_shared_kernel_page_create+0x2f>
  407138:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40713f:	00 

0000000000407140 <__cosrt_c_capmgr_vm_lapic_create>:
  407140:	f3 0f 1e fa          	endbr64 
  407144:	55                   	push   rbp
  407145:	48 89 e5             	mov    rbp,rsp
  407148:	41 55                	push   r13
  40714a:	49 89 fd             	mov    r13,rdi
  40714d:	41 54                	push   r12
  40714f:	53                   	push   rbx
  407150:	48 83 ec 28          	sub    rsp,0x28
  407154:	48 8b 58 10          	mov    rbx,QWORD PTR [rax+0x10]
  407158:	48 85 db             	test   rbx,rbx
  40715b:	74 2b                	je     407188 <__cosrt_c_capmgr_vm_lapic_create+0x48>
  40715d:	4c 8d 4d c8          	lea    r9,[rbp-0x38]
  407161:	4c 8d 45 c0          	lea    r8,[rbp-0x40]
  407165:	31 c9                	xor    ecx,ecx
  407167:	31 d2                	xor    edx,edx
  407169:	31 f6                	xor    esi,esi
  40716b:	31 ff                	xor    edi,edi
  40716d:	ff d3                	call   rbx
  40716f:	48 8b 55 c0          	mov    rdx,QWORD PTR [rbp-0x40]
  407173:	48 98                	cdqe   
  407175:	49 89 55 00          	mov    QWORD PTR [r13+0x0],rdx
  407179:	48 83 c4 28          	add    rsp,0x28
  40717d:	5b                   	pop    rbx
  40717e:	41 5c                	pop    r12
  407180:	41 5d                	pop    r13
  407182:	5d                   	pop    rbp
  407183:	c3                   	ret    
  407184:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  407188:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  40718c:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  407190:	48 89 de             	mov    rsi,rbx
  407193:	48 89 df             	mov    rdi,rbx
  407196:	48 89 da             	mov    rdx,rbx
  407199:	83 c0 01             	add    eax,0x1
  40719c:	c1 e0 10             	shl    eax,0x10
  40719f:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4071a2:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4071a6:	48 89 cd             	mov    rbp,rcx
  4071a9:	49 b8 c0 71 40 00 00 	movabs r8,0x4071c0
  4071b0:	00 00 00 
  4071b3:	0f 05                	syscall 
  4071b5:	0f 1f 00             	nop    DWORD PTR [rax]
  4071b8:	eb 0f                	jmp    4071c9 <__cosrt_c_capmgr_vm_lapic_create+0x89>
  4071ba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4071c0:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  4071c7:	eb 07                	jmp    4071d0 <__cosrt_c_capmgr_vm_lapic_create+0x90>
  4071c9:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  4071d0:	5d                   	pop    rbp
  4071d1:	5c                   	pop    rsp
  4071d2:	48 89 75 c0          	mov    QWORD PTR [rbp-0x40],rsi
  4071d6:	eb 97                	jmp    40716f <__cosrt_c_capmgr_vm_lapic_create+0x2f>
  4071d8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4071df:	00 

00000000004071e0 <__cosrt_c_capmgr_vm_shared_region_create>:
  4071e0:	f3 0f 1e fa          	endbr64 
  4071e4:	55                   	push   rbp
  4071e5:	48 89 e5             	mov    rbp,rsp
  4071e8:	41 55                	push   r13
  4071ea:	49 89 fd             	mov    r13,rdi
  4071ed:	41 54                	push   r12
  4071ef:	53                   	push   rbx
  4071f0:	48 83 ec 28          	sub    rsp,0x28
  4071f4:	48 8b 58 10          	mov    rbx,QWORD PTR [rax+0x10]
  4071f8:	48 85 db             	test   rbx,rbx
  4071fb:	74 2b                	je     407228 <__cosrt_c_capmgr_vm_shared_region_create+0x48>
  4071fd:	4c 8d 4d c8          	lea    r9,[rbp-0x38]
  407201:	4c 8d 45 c0          	lea    r8,[rbp-0x40]
  407205:	31 c9                	xor    ecx,ecx
  407207:	31 d2                	xor    edx,edx
  407209:	31 f6                	xor    esi,esi
  40720b:	31 ff                	xor    edi,edi
  40720d:	ff d3                	call   rbx
  40720f:	48 8b 55 c0          	mov    rdx,QWORD PTR [rbp-0x40]
  407213:	48 98                	cdqe   
  407215:	49 89 55 00          	mov    QWORD PTR [r13+0x0],rdx
  407219:	48 83 c4 28          	add    rsp,0x28
  40721d:	5b                   	pop    rbx
  40721e:	41 5c                	pop    r12
  407220:	41 5d                	pop    r13
  407222:	5d                   	pop    rbp
  407223:	c3                   	ret    
  407224:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  407228:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  40722c:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  407230:	48 89 de             	mov    rsi,rbx
  407233:	48 89 df             	mov    rdi,rbx
  407236:	48 89 da             	mov    rdx,rbx
  407239:	83 c0 01             	add    eax,0x1
  40723c:	c1 e0 10             	shl    eax,0x10
  40723f:	48 89 29             	mov    QWORD PTR [rcx],rbp
  407242:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  407246:	48 89 cd             	mov    rbp,rcx
  407249:	49 b8 60 72 40 00 00 	movabs r8,0x407260
  407250:	00 00 00 
  407253:	0f 05                	syscall 
  407255:	0f 1f 00             	nop    DWORD PTR [rax]
  407258:	eb 0f                	jmp    407269 <__cosrt_c_capmgr_vm_shared_region_create+0x89>
  40725a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  407260:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  407267:	eb 07                	jmp    407270 <__cosrt_c_capmgr_vm_shared_region_create+0x90>
  407269:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  407270:	5d                   	pop    rbp
  407271:	5c                   	pop    rsp
  407272:	48 89 75 c0          	mov    QWORD PTR [rbp-0x40],rsi
  407276:	eb 97                	jmp    40720f <__cosrt_c_capmgr_vm_shared_region_create+0x2f>
  407278:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40727f:	00 

0000000000407280 <__cosrt_c_capmgr_vm_vcpu_create>:

	return ret;
}

COS_CLIENT_STUB(thdcap_t, capmgr_vm_vcpu_create, compid_t vm_comp, vm_vmcb_t vmcb_cap, thdid_t *tid)
{
  407280:	f3 0f 1e fa          	endbr64 
  407284:	55                   	push   rbp
  407285:	48 89 e5             	mov    rbp,rsp
  407288:	41 57                	push   r15
  40728a:	49 89 d7             	mov    r15,rdx
  40728d:	41 56                	push   r14
  40728f:	41 55                	push   r13
  407291:	41 54                	push   r12
  407293:	53                   	push   rbx
  407294:	48 83 ec 28          	sub    rsp,0x28
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  407298:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  40729c:	4d 85 f6             	test   r14,r14
  40729f:	74 2f                	je     4072d0 <__cosrt_c_capmgr_vm_vcpu_create+0x50>
  4072a1:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  4072a5:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  4072a9:	31 c9                	xor    ecx,ecx
  4072ab:	31 d2                	xor    edx,edx
  4072ad:	41 ff d6             	call   r14
	COS_CLIENT_INVCAP;
	word_t unused, tid_ret;
	thdcap_t ret;

	ret = cos_sinv_2rets(uc, vm_comp, vmcb_cap, 0, 0, &tid_ret, &unused);
	*tid = tid_ret;
  4072b0:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
	ret = cos_sinv_2rets(uc, vm_comp, vmcb_cap, 0, 0, &tid_ret, &unused);
  4072b4:	48 98                	cdqe   
	*tid = tid_ret;
  4072b6:	49 89 17             	mov    QWORD PTR [r15],rdx

	return ret;
}
  4072b9:	48 83 c4 28          	add    rsp,0x28
  4072bd:	5b                   	pop    rbx
  4072be:	41 5c                	pop    r12
  4072c0:	41 5d                	pop    r13
  4072c2:	41 5e                	pop    r14
  4072c4:	41 5f                	pop    r15
  4072c6:	5d                   	pop    rbp
  4072c7:	c3                   	ret    
  4072c8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4072cf:	00 
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  4072d0:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  4072d4:	48 89 fb             	mov    rbx,rdi
  4072d7:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  4072db:	4c 89 f7             	mov    rdi,r14
  4072de:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4072e1:	83 c0 01             	add    eax,0x1
  4072e4:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  4072e7:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4072ea:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4072ee:	48 89 cd             	mov    rbp,rcx
  4072f1:	49 b8 08 73 40 00 00 	movabs r8,0x407308
  4072f8:	00 00 00 
  4072fb:	0f 05                	syscall 
  4072fd:	0f 1f 00             	nop    DWORD PTR [rax]
  407300:	eb 0f                	jmp    407311 <__cosrt_c_capmgr_vm_vcpu_create+0x91>
  407302:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  407308:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  40730f:	eb 07                	jmp    407318 <__cosrt_c_capmgr_vm_vcpu_create+0x98>
  407311:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  407318:	5d                   	pop    rbp
  407319:	5c                   	pop    rsp
  40731a:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  40731e:	eb 90                	jmp    4072b0 <__cosrt_c_capmgr_vm_vcpu_create+0x30>

0000000000407320 <__cosrt_c_capmgr_initthd_create>:

COS_CLIENT_STUB(thdcap_t, capmgr_initthd_create, spdid_t child, thdid_t *tid)
{
  407320:	f3 0f 1e fa          	endbr64 
  407324:	55                   	push   rbp
  407325:	48 89 e5             	mov    rbp,rsp
  407328:	41 57                	push   r15
	COS_CLIENT_INVCAP;
	word_t unused, tid_ret;
	thdcap_t ret;

	ret = cos_sinv_2rets(uc, child, 0, 0, 0, &tid_ret, &unused);
  40732a:	44 0f b7 ff          	movzx  r15d,di
{
  40732e:	41 56                	push   r14
  407330:	41 55                	push   r13
  407332:	49 89 f5             	mov    r13,rsi
  407335:	41 54                	push   r12
  407337:	53                   	push   rbx
  407338:	48 83 ec 28          	sub    rsp,0x28
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  40733c:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  407340:	4d 85 f6             	test   r14,r14
  407343:	74 33                	je     407378 <__cosrt_c_capmgr_initthd_create+0x58>
  407345:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  407349:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  40734d:	31 c9                	xor    ecx,ecx
  40734f:	31 d2                	xor    edx,edx
  407351:	31 f6                	xor    esi,esi
  407353:	4c 89 ff             	mov    rdi,r15
  407356:	41 ff d6             	call   r14
	*tid = tid_ret;
  407359:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
	ret = cos_sinv_2rets(uc, child, 0, 0, 0, &tid_ret, &unused);
  40735d:	48 98                	cdqe   
	*tid = tid_ret;
  40735f:	49 89 55 00          	mov    QWORD PTR [r13+0x0],rdx

	return ret;
}
  407363:	48 83 c4 28          	add    rsp,0x28
  407367:	5b                   	pop    rbx
  407368:	41 5c                	pop    r12
  40736a:	41 5d                	pop    r13
  40736c:	41 5e                	pop    r14
  40736e:	41 5f                	pop    r15
  407370:	5d                   	pop    rbp
  407371:	c3                   	ret    
  407372:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  407378:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  40737c:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  407380:	4c 89 fb             	mov    rbx,r15
  407383:	4c 89 f6             	mov    rsi,r14
  407386:	4c 89 f7             	mov    rdi,r14
  407389:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40738c:	83 c0 01             	add    eax,0x1
  40738f:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  407392:	48 89 29             	mov    QWORD PTR [rcx],rbp
  407395:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  407399:	48 89 cd             	mov    rbp,rcx
  40739c:	49 b8 b0 73 40 00 00 	movabs r8,0x4073b0
  4073a3:	00 00 00 
  4073a6:	0f 05                	syscall 
  4073a8:	eb 0f                	jmp    4073b9 <__cosrt_c_capmgr_initthd_create+0x99>
  4073aa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4073b0:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  4073b7:	eb 07                	jmp    4073c0 <__cosrt_c_capmgr_initthd_create+0xa0>
  4073b9:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  4073c0:	5d                   	pop    rbp
  4073c1:	5c                   	pop    rsp
  4073c2:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  4073c6:	eb 91                	jmp    407359 <__cosrt_c_capmgr_initthd_create+0x39>
  4073c8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4073cf:	00 

00000000004073d0 <__cosrt_c_capmgr_thd_create_thunk>:

COS_CLIENT_STUB(thdcap_t, capmgr_thd_create_thunk, thdclosure_index_t id, thdid_t *tid)
{
  4073d0:	f3 0f 1e fa          	endbr64 
  4073d4:	55                   	push   rbp
  4073d5:	48 89 e5             	mov    rbp,rsp
  4073d8:	41 57                	push   r15
	COS_CLIENT_INVCAP;
	word_t unused, tid_ret;
	thdcap_t ret;

	ret = cos_sinv_2rets(uc, id, 0, 0, 0, &tid_ret, &unused);
  4073da:	4c 63 ff             	movsxd r15,edi
{
  4073dd:	41 56                	push   r14
  4073df:	41 55                	push   r13
  4073e1:	49 89 f5             	mov    r13,rsi
  4073e4:	41 54                	push   r12
  4073e6:	53                   	push   rbx
  4073e7:	48 83 ec 28          	sub    rsp,0x28
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  4073eb:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  4073ef:	4d 85 f6             	test   r14,r14
  4073f2:	74 34                	je     407428 <__cosrt_c_capmgr_thd_create_thunk+0x58>
  4073f4:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  4073f8:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  4073fc:	31 c9                	xor    ecx,ecx
  4073fe:	31 d2                	xor    edx,edx
  407400:	31 f6                	xor    esi,esi
  407402:	4c 89 ff             	mov    rdi,r15
  407405:	41 ff d6             	call   r14
	*tid = tid_ret;
  407408:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
	ret = cos_sinv_2rets(uc, id, 0, 0, 0, &tid_ret, &unused);
  40740c:	48 98                	cdqe   
	*tid = tid_ret;
  40740e:	49 89 55 00          	mov    QWORD PTR [r13+0x0],rdx

	return ret;
}
  407412:	48 83 c4 28          	add    rsp,0x28
  407416:	5b                   	pop    rbx
  407417:	41 5c                	pop    r12
  407419:	41 5d                	pop    r13
  40741b:	41 5e                	pop    r14
  40741d:	41 5f                	pop    r15
  40741f:	5d                   	pop    rbp
  407420:	c3                   	ret    
  407421:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  407428:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  40742c:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  407430:	4c 89 fb             	mov    rbx,r15
  407433:	4c 89 f6             	mov    rsi,r14
  407436:	4c 89 f7             	mov    rdi,r14
  407439:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40743c:	83 c0 01             	add    eax,0x1
  40743f:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  407442:	48 89 29             	mov    QWORD PTR [rcx],rbp
  407445:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  407449:	48 89 cd             	mov    rbp,rcx
  40744c:	49 b8 60 74 40 00 00 	movabs r8,0x407460
  407453:	00 00 00 
  407456:	0f 05                	syscall 
  407458:	eb 0f                	jmp    407469 <__cosrt_c_capmgr_thd_create_thunk+0x99>
  40745a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  407460:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  407467:	eb 07                	jmp    407470 <__cosrt_c_capmgr_thd_create_thunk+0xa0>
  407469:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  407470:	5d                   	pop    rbp
  407471:	5c                   	pop    rsp
  407472:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  407476:	eb 90                	jmp    407408 <__cosrt_c_capmgr_thd_create_thunk+0x38>
  407478:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40747f:	00 

0000000000407480 <__cosrt_c_capmgr_thd_create_ext>:

COS_CLIENT_STUB(thdcap_t, capmgr_thd_create_ext, spdid_t child, thdclosure_index_t idx, thdid_t *tid)
{
  407480:	f3 0f 1e fa          	endbr64 
  407484:	55                   	push   rbp
	COS_CLIENT_INVCAP;
	word_t unused, tid_ret;
	thdcap_t ret;

	ret = cos_sinv_2rets(uc, child, idx, 0, 0, &tid_ret, &unused);
  407485:	48 63 f6             	movsxd rsi,esi
{
  407488:	48 89 e5             	mov    rbp,rsp
  40748b:	41 57                	push   r15
  40748d:	49 89 d7             	mov    r15,rdx
  407490:	41 56                	push   r14
  407492:	41 55                	push   r13
	ret = cos_sinv_2rets(uc, child, idx, 0, 0, &tid_ret, &unused);
  407494:	44 0f b7 ef          	movzx  r13d,di
{
  407498:	41 54                	push   r12
  40749a:	53                   	push   rbx
  40749b:	48 83 ec 28          	sub    rsp,0x28
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  40749f:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  4074a3:	4d 85 f6             	test   r14,r14
  4074a6:	74 30                	je     4074d8 <__cosrt_c_capmgr_thd_create_ext+0x58>
  4074a8:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  4074ac:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  4074b0:	31 c9                	xor    ecx,ecx
  4074b2:	31 d2                	xor    edx,edx
  4074b4:	4c 89 ef             	mov    rdi,r13
  4074b7:	41 ff d6             	call   r14
	*tid = tid_ret;
  4074ba:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
	ret = cos_sinv_2rets(uc, child, idx, 0, 0, &tid_ret, &unused);
  4074be:	48 98                	cdqe   
	*tid = tid_ret;
  4074c0:	49 89 17             	mov    QWORD PTR [r15],rdx

	return ret;
}
  4074c3:	48 83 c4 28          	add    rsp,0x28
  4074c7:	5b                   	pop    rbx
  4074c8:	41 5c                	pop    r12
  4074ca:	41 5d                	pop    r13
  4074cc:	41 5e                	pop    r14
  4074ce:	41 5f                	pop    r15
  4074d0:	5d                   	pop    rbp
  4074d1:	c3                   	ret    
  4074d2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  4074d8:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  4074dc:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  4074e0:	4c 89 eb             	mov    rbx,r13
  4074e3:	4c 89 f7             	mov    rdi,r14
  4074e6:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4074e9:	83 c0 01             	add    eax,0x1
  4074ec:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  4074ef:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4074f2:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4074f6:	48 89 cd             	mov    rbp,rcx
  4074f9:	49 b8 10 75 40 00 00 	movabs r8,0x407510
  407500:	00 00 00 
  407503:	0f 05                	syscall 
  407505:	0f 1f 00             	nop    DWORD PTR [rax]
  407508:	eb 0f                	jmp    407519 <__cosrt_c_capmgr_thd_create_ext+0x99>
  40750a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  407510:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  407517:	eb 07                	jmp    407520 <__cosrt_c_capmgr_thd_create_ext+0xa0>
  407519:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  407520:	5d                   	pop    rbp
  407521:	5c                   	pop    rsp
  407522:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  407526:	eb 92                	jmp    4074ba <__cosrt_c_capmgr_thd_create_ext+0x3a>
  407528:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40752f:	00 

0000000000407530 <__cosrt_c_capmgr_aep_create_thunk>:

COS_CLIENT_STUB(thdcap_t, capmgr_aep_create_thunk, struct cos_aep_info *aep, thdclosure_index_t idx, int owntc, cos_channelkey_t key, microsec_t ipiwin, u32_t ipimax)
{
  407530:	f3 0f 1e fa          	endbr64 
  407534:	55                   	push   rbp
  407535:	48 89 e5             	mov    rbp,rsp
  407538:	41 57                	push   r15
  40753a:	41 56                	push   r14
  40753c:	41 55                	push   r13
  40753e:	41 54                	push   r12
  407540:	53                   	push   rbx
  407541:	48 83 ec 28          	sub    rsp,0x28
	COS_CLIENT_INVCAP;
	word_t tcrcvret   = 0;
  407545:	48 c7 45 b0 00 00 00 	mov    QWORD PTR [rbp-0x50],0x0
  40754c:	00 
	thdcap_t thd     = 0;
	thdid_t tid      = 0;
  40754d:	48 c7 45 b8 00 00 00 	mov    QWORD PTR [rbp-0x48],0x0
  407554:	00 
	u32_t owntc_idx  = (owntc << 16) | idx;
	u32_t key_ipimax = (key << 16) | ((ipimax << 16) >> 16);
	u32_t ipiwin32b  = (u32_t)ipiwin;

	if (idx < 1) return 0;
  407555:	85 f6                	test   esi,esi
  407557:	0f 8e 93 00 00 00    	jle    4075f0 <__cosrt_c_capmgr_aep_create_thunk+0xc0>
  40755d:	41 89 d5             	mov    r13d,edx
	u32_t key_ipimax = (key << 16) | ((ipimax << 16) >> 16);
  407560:	c1 e1 10             	shl    ecx,0x10
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  407563:	4c 8b 78 10          	mov    r15,QWORD PTR [rax+0x10]
  407567:	41 89 f2             	mov    r10d,esi
  40756a:	45 0f b7 c9          	movzx  r9d,r9w

	thd = cos_sinv_2rets(uc, owntc_idx, key_ipimax, ipiwin32b, 0, &tid, &tcrcvret);
  40756e:	89 ce                	mov    esi,ecx
	u32_t owntc_idx  = (owntc << 16) | idx;
  407570:	41 c1 e5 10          	shl    r13d,0x10
  407574:	49 89 fe             	mov    r14,rdi
	thd = cos_sinv_2rets(uc, owntc_idx, key_ipimax, ipiwin32b, 0, &tid, &tcrcvret);
  407577:	44 09 ce             	or     esi,r9d
  40757a:	44 89 c7             	mov    edi,r8d
  40757d:	45 09 d5             	or     r13d,r10d
  407580:	4d 85 ff             	test   r15,r15
  407583:	0f 84 7f 00 00 00    	je     407608 <__cosrt_c_capmgr_aep_create_thunk+0xd8>
  407589:	48 89 fa             	mov    rdx,rdi
  40758c:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  407590:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  407594:	31 c9                	xor    ecx,ecx
  407596:	4c 89 ef             	mov    rdi,r13
  407599:	41 ff d7             	call   r15
  40759c:	48 98                	cdqe   
	if (!thd) return 0;
  40759e:	48 85 c0             	test   rax,rax
  4075a1:	74 3a                	je     4075dd <__cosrt_c_capmgr_aep_create_thunk+0xad>

	aep->thd  = thd;
	aep->rcv  = (tcrcvret << 16) >> 16;
  4075a3:	48 8b 55 b0          	mov    rdx,QWORD PTR [rbp-0x50]
	aep->tc   = (tcrcvret >> 16);
	aep->tid  = tid;
  4075a7:	f3 0f 7e 4d b8       	movq   xmm1,QWORD PTR [rbp-0x48]
	aep->tc   = (tcrcvret >> 16);
  4075ac:	66 48 0f 6e d8       	movq   xmm3,rax
	aep->rcv  = (tcrcvret << 16) >> 16;
  4075b1:	48 b9 ff ff ff ff ff 	movabs rcx,0xffffffffffff
  4075b8:	ff 00 00 
  4075bb:	48 21 d1             	and    rcx,rdx
	aep->tc   = (tcrcvret >> 16);
  4075be:	48 c1 ea 10          	shr    rdx,0x10
  4075c2:	66 48 0f 6e d1       	movq   xmm2,rcx
  4075c7:	66 48 0f 6e c2       	movq   xmm0,rdx
  4075cc:	66 0f 6c ca          	punpcklqdq xmm1,xmm2
  4075d0:	66 0f 6c c3          	punpcklqdq xmm0,xmm3
  4075d4:	41 0f 11 06          	movups XMMWORD PTR [r14],xmm0
  4075d8:	41 0f 11 4e 10       	movups XMMWORD PTR [r14+0x10],xmm1

	return thd;
}
  4075dd:	48 83 c4 28          	add    rsp,0x28
  4075e1:	5b                   	pop    rbx
  4075e2:	41 5c                	pop    r12
  4075e4:	41 5d                	pop    r13
  4075e6:	41 5e                	pop    r14
  4075e8:	41 5f                	pop    r15
  4075ea:	5d                   	pop    rbp
  4075eb:	c3                   	ret    
  4075ec:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  4075f0:	48 83 c4 28          	add    rsp,0x28
	if (idx < 1) return 0;
  4075f4:	31 c0                	xor    eax,eax
}
  4075f6:	5b                   	pop    rbx
  4075f7:	41 5c                	pop    r12
  4075f9:	41 5d                	pop    r13
  4075fb:	41 5e                	pop    r14
  4075fd:	41 5f                	pop    r15
  4075ff:	5d                   	pop    rbp
  407600:	c3                   	ret    
  407601:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  407608:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  40760c:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  407610:	4c 89 eb             	mov    rbx,r13
  407613:	4c 89 fa             	mov    rdx,r15
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  407616:	83 c0 01             	add    eax,0x1
  407619:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40761c:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40761f:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  407623:	48 89 cd             	mov    rbp,rcx
  407626:	49 b8 40 76 40 00 00 	movabs r8,0x407640
  40762d:	00 00 00 
  407630:	0f 05                	syscall 
  407632:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  407638:	eb 0f                	jmp    407649 <__cosrt_c_capmgr_aep_create_thunk+0x119>
  40763a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  407640:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  407647:	eb 07                	jmp    407650 <__cosrt_c_capmgr_aep_create_thunk+0x120>
  407649:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  407650:	5d                   	pop    rbp
  407651:	5c                   	pop    rsp
  407652:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
  407656:	48 89 7d b0          	mov    QWORD PTR [rbp-0x50],rdi
	return ret;
  40765a:	e9 3d ff ff ff       	jmp    40759c <__cosrt_c_capmgr_aep_create_thunk+0x6c>
  40765f:	90                   	nop

0000000000407660 <__cosrt_c_capmgr_aep_create_ext>:

COS_CLIENT_STUB(thdcap_t, capmgr_aep_create_ext, spdid_t child, struct cos_aep_info *aep, thdclosure_index_t idx, int owntc, cos_channelkey_t key, microsec_t ipiwin, u32_t ipimax, arcvcap_t *extrcv)
{
  407660:	f3 0f 1e fa          	endbr64 
  407664:	55                   	push   rbp
	COS_CLIENT_INVCAP;
	word_t drcvtidret  = 0;
	word_t tcrcvret    = 0;
	thdcap_t thd       = 0;
	u32_t spdid_thdidx = (child << 16) | ((idx << 16) >> 16);
	u32_t key_ipimax   = (key << 16) | ((ipimax << 16) >> 16);
  407665:	41 c1 e0 10          	shl    r8d,0x10
	u32_t spdid_thdidx = (child << 16) | ((idx << 16) >> 16);
  407669:	c1 e7 10             	shl    edi,0x10
{
  40766c:	48 89 e5             	mov    rbp,rsp
  40766f:	41 57                	push   r15
  407671:	41 89 d7             	mov    r15d,edx
  407674:	44 89 ca             	mov    edx,r9d
  407677:	41 56                	push   r14
	u32_t spdid_thdidx = (child << 16) | ((idx << 16) >> 16);
  407679:	45 0f bf ff          	movsx  r15d,r15w
	u32_t ipiwin32b    = (u32_t)ipiwin;

	thd = cos_sinv_2rets(uc, spdid_thdidx, owntc, key_ipimax, ipiwin32b, &drcvtidret, &tcrcvret);
  40767d:	45 89 c6             	mov    r14d,r8d
{
  407680:	41 55                	push   r13
  407682:	49 89 f5             	mov    r13,rsi
	thd = cos_sinv_2rets(uc, spdid_thdidx, owntc, key_ipimax, ipiwin32b, &drcvtidret, &tcrcvret);
  407685:	41 09 ff             	or     r15d,edi
{
  407688:	41 54                	push   r12
  40768a:	53                   	push   rbx
  40768b:	48 83 ec 28          	sub    rsp,0x28
	u32_t key_ipimax   = (key << 16) | ((ipimax << 16) >> 16);
  40768f:	0f b7 75 10          	movzx  esi,WORD PTR [rbp+0x10]
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  407693:	4c 8b 50 10          	mov    r10,QWORD PTR [rax+0x10]
	word_t drcvtidret  = 0;
  407697:	48 c7 45 b0 00 00 00 	mov    QWORD PTR [rbp-0x50],0x0
  40769e:	00 
	word_t tcrcvret    = 0;
  40769f:	48 c7 45 b8 00 00 00 	mov    QWORD PTR [rbp-0x48],0x0
  4076a6:	00 
	thd = cos_sinv_2rets(uc, spdid_thdidx, owntc, key_ipimax, ipiwin32b, &drcvtidret, &tcrcvret);
  4076a7:	41 09 f6             	or     r14d,esi
  4076aa:	48 63 f1             	movsxd rsi,ecx
  4076ad:	4d 85 d2             	test   r10,r10
  4076b0:	0f 84 8a 00 00 00    	je     407740 <__cosrt_c_capmgr_aep_create_ext+0xe0>
  4076b6:	48 89 d1             	mov    rcx,rdx
  4076b9:	4c 8d 4d b8          	lea    r9,[rbp-0x48]
  4076bd:	4c 8d 45 b0          	lea    r8,[rbp-0x50]
  4076c1:	4c 89 f2             	mov    rdx,r14
  4076c4:	4c 89 ff             	mov    rdi,r15
  4076c7:	41 ff d2             	call   r10
  4076ca:	48 98                	cdqe   
	if (!thd) return thd;
  4076cc:	48 85 c0             	test   rax,rax
  4076cf:	74 60                	je     407731 <__cosrt_c_capmgr_aep_create_ext+0xd1>

	aep->fn   = NULL;
	aep->data = NULL;
	aep->thd  = thd;
	aep->tid  = (drcvtidret << 16) >> 16;
	aep->rcv  = tcrcvret >> 16;
  4076d1:	48 8b 75 b8          	mov    rsi,QWORD PTR [rbp-0x48]
	aep->tid  = (drcvtidret << 16) >> 16;
  4076d5:	48 8b 4d b0          	mov    rcx,QWORD PTR [rbp-0x50]
	aep->tc   = (tcrcvret << 16) >> 16;
  4076d9:	48 ba ff ff ff ff ff 	movabs rdx,0xffffffffffff
  4076e0:	ff 00 00 
  4076e3:	66 48 0f 6e c8       	movq   xmm1,rax
	aep->fn   = NULL;
  4076e8:	49 c7 45 20 00 00 00 	mov    QWORD PTR [r13+0x20],0x0
  4076ef:	00 
	aep->tc   = (tcrcvret << 16) >> 16;
  4076f0:	48 89 f3             	mov    rbx,rsi
	aep->rcv  = tcrcvret >> 16;
  4076f3:	48 c1 ee 10          	shr    rsi,0x10
	aep->data = NULL;
  4076f7:	49 c7 45 28 00 00 00 	mov    QWORD PTR [r13+0x28],0x0
  4076fe:	00 
	aep->tc   = (tcrcvret << 16) >> 16;
  4076ff:	48 21 d3             	and    rbx,rdx
	aep->tid  = (drcvtidret << 16) >> 16;
  407702:	48 21 ca             	and    rdx,rcx
	aep->tc   = (tcrcvret << 16) >> 16;
  407705:	66 48 0f 6e d6       	movq   xmm2,rsi
	*extrcv   = drcvtidret >> 16;
  40770a:	48 c1 e9 10          	shr    rcx,0x10
	aep->tc   = (tcrcvret << 16) >> 16;
  40770e:	66 48 0f 6e c3       	movq   xmm0,rbx
  407713:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  407717:	41 0f 11 45 00       	movups XMMWORD PTR [r13+0x0],xmm0
  40771c:	66 48 0f 6e c2       	movq   xmm0,rdx
	*extrcv   = drcvtidret >> 16;
  407721:	48 8b 55 18          	mov    rdx,QWORD PTR [rbp+0x18]
	aep->tc   = (tcrcvret << 16) >> 16;
  407725:	66 0f 6c c2          	punpcklqdq xmm0,xmm2
  407729:	41 0f 11 45 10       	movups XMMWORD PTR [r13+0x10],xmm0
	*extrcv   = drcvtidret >> 16;
  40772e:	48 89 0a             	mov    QWORD PTR [rdx],rcx

	return thd;
}
  407731:	48 83 c4 28          	add    rsp,0x28
  407735:	5b                   	pop    rbx
  407736:	41 5c                	pop    r12
  407738:	41 5d                	pop    r13
  40773a:	41 5e                	pop    r14
  40773c:	41 5f                	pop    r15
  40773e:	5d                   	pop    rbp
  40773f:	c3                   	ret    
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  407740:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  407744:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  407748:	4c 89 fb             	mov    rbx,r15
  40774b:	4c 89 f7             	mov    rdi,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40774e:	83 c0 01             	add    eax,0x1
  407751:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  407754:	48 89 29             	mov    QWORD PTR [rcx],rbp
  407757:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40775b:	48 89 cd             	mov    rbp,rcx
  40775e:	49 b8 78 77 40 00 00 	movabs r8,0x407778
  407765:	00 00 00 
  407768:	0f 05                	syscall 
  40776a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  407770:	eb 0f                	jmp    407781 <__cosrt_c_capmgr_aep_create_ext+0x121>
  407772:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  407778:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  40777f:	eb 07                	jmp    407788 <__cosrt_c_capmgr_aep_create_ext+0x128>
  407781:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  407788:	5d                   	pop    rbp
  407789:	5c                   	pop    rsp
  40778a:	48 89 75 b0          	mov    QWORD PTR [rbp-0x50],rsi
  40778e:	48 89 7d b8          	mov    QWORD PTR [rbp-0x48],rdi
	return ret;
  407792:	e9 33 ff ff ff       	jmp    4076ca <__cosrt_c_capmgr_aep_create_ext+0x6a>
  407797:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40779e:	00 00 

00000000004077a0 <__cosrt_c_capmgr_vm_vmcb_create>:

COS_CLIENT_STUB(capid_t, capmgr_vm_vmcb_create, vm_vmcscap_t vmcs_cap, vm_msrbitmapcap_t msr_bitmap_cap, vm_lapicaccesscap_t lapic_access_cap, vm_lapiccap_t lapic_cap, vm_shared_mem_t shared_mem_cap, thdid_t handler_thd_id, word_t vpid)
{
  4077a0:	f3 0f 1e fa          	endbr64 
  4077a4:	55                   	push   rbp

	/* FIXME: MPK call gate make indirect call complicated, arguments passed via stack gets wrong, walk around now by avoiding pass that argument */
	vpid = handler_thd_id & 0xFFFF;
	handler_thd_id = (handler_thd_id >> 16) & 0xFFFF;

	arg1 = 0 | vmcs_cap << (16 * 1) | msr_bitmap_cap << (16 * 2) |  lapic_access_cap << (16 * 3);
  4077a5:	48 c1 e2 30          	shl    rdx,0x30
  4077a9:	48 c1 e6 20          	shl    rsi,0x20
  4077ad:	48 c1 e7 10          	shl    rdi,0x10
  4077b1:	48 09 d6             	or     rsi,rdx
	arg2 = lapic_cap | shared_mem_cap << (16 * 1) | handler_thd_id << (16 * 2) | vpid << (16 * 3);
  4077b4:	49 c1 e0 10          	shl    r8,0x10
  4077b8:	4c 89 ca             	mov    rdx,r9
  4077bb:	48 c1 e2 30          	shl    rdx,0x30
	arg1 = 0 | vmcs_cap << (16 * 1) | msr_bitmap_cap << (16 * 2) |  lapic_access_cap << (16 * 3);
  4077bf:	48 09 fe             	or     rsi,rdi
	arg2 = lapic_cap | shared_mem_cap << (16 * 1) | handler_thd_id << (16 * 2) | vpid << (16 * 3);
  4077c2:	49 09 c8             	or     r8,rcx
  4077c5:	49 c1 e1 10          	shl    r9,0x10
{
  4077c9:	48 89 e5             	mov    rbp,rsp
  4077cc:	41 56                	push   r14
  4077ce:	41 55                	push   r13
	arg1 = 0 | vmcs_cap << (16 * 1) | msr_bitmap_cap << (16 * 2) |  lapic_access_cap << (16 * 3);
  4077d0:	49 89 f5             	mov    r13,rsi
	arg2 = lapic_cap | shared_mem_cap << (16 * 1) | handler_thd_id << (16 * 2) | vpid << (16 * 3);
  4077d3:	4c 89 c6             	mov    rsi,r8
{
  4077d6:	41 54                	push   r12
	arg2 = lapic_cap | shared_mem_cap << (16 * 1) | handler_thd_id << (16 * 2) | vpid << (16 * 3);
  4077d8:	48 09 d6             	or     rsi,rdx
  4077db:	48 ba 00 00 00 00 ff 	movabs rdx,0xffff00000000
  4077e2:	ff 00 00 
{
  4077e5:	53                   	push   rbx
	arg2 = lapic_cap | shared_mem_cap << (16 * 1) | handler_thd_id << (16 * 2) | vpid << (16 * 3);
  4077e6:	49 21 d1             	and    r9,rdx
  4077e9:	4c 09 ce             	or     rsi,r9
{
  4077ec:	48 83 ec 20          	sub    rsp,0x20
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  4077f0:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
	word_t ret1 = 0;
  4077f4:	48 c7 45 c0 00 00 00 	mov    QWORD PTR [rbp-0x40],0x0
  4077fb:	00 
	word_t ret2 = 0;
  4077fc:	48 c7 45 c8 00 00 00 	mov    QWORD PTR [rbp-0x38],0x0
  407803:	00 
  407804:	4d 85 f6             	test   r14,r14
  407807:	74 27                	je     407830 <__cosrt_c_capmgr_vm_vmcb_create+0x90>
  407809:	4c 8d 4d c8          	lea    r9,[rbp-0x38]
  40780d:	4c 8d 45 c0          	lea    r8,[rbp-0x40]
  407811:	4c 89 ef             	mov    rdi,r13
  407814:	31 c9                	xor    ecx,ecx
  407816:	31 d2                	xor    edx,edx
  407818:	41 ff d6             	call   r14
	cap = cos_sinv_2rets(uc, arg1, arg2, 0, 0, &ret1, &ret2);

	return cap;
}
  40781b:	48 83 c4 20          	add    rsp,0x20
  40781f:	5b                   	pop    rbx
	cap = cos_sinv_2rets(uc, arg1, arg2, 0, 0, &ret1, &ret2);
  407820:	48 98                	cdqe   
}
  407822:	41 5c                	pop    r12
  407824:	41 5d                	pop    r13
  407826:	41 5e                	pop    r14
  407828:	5d                   	pop    rbp
  407829:	c3                   	ret    
  40782a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  407830:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  407834:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  407838:	4c 89 eb             	mov    rbx,r13
  40783b:	4c 89 f7             	mov    rdi,r14
  40783e:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  407841:	83 c0 01             	add    eax,0x1
  407844:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  407847:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40784a:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40784e:	48 89 cd             	mov    rbp,rcx
  407851:	49 b8 68 78 40 00 00 	movabs r8,0x407868
  407858:	00 00 00 
  40785b:	0f 05                	syscall 
  40785d:	0f 1f 00             	nop    DWORD PTR [rax]
  407860:	eb 0f                	jmp    407871 <__cosrt_c_capmgr_vm_vmcb_create+0xd1>
  407862:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  407868:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  40786f:	eb 07                	jmp    407878 <__cosrt_c_capmgr_vm_vmcb_create+0xd8>
  407871:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  407878:	5d                   	pop    rbp
  407879:	5c                   	pop    rsp
  40787a:	48 83 c4 20          	add    rsp,0x20
	cap = cos_sinv_2rets(uc, arg1, arg2, 0, 0, &ret1, &ret2);
  40787e:	48 98                	cdqe   
}
  407880:	5b                   	pop    rbx
  407881:	41 5c                	pop    r12
  407883:	41 5d                	pop    r13
  407885:	41 5e                	pop    r14
  407887:	5d                   	pop    rbp
  407888:	c3                   	ret    
  407889:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000407890 <__cosrt_c_capmgr_initaep_create>:

COS_CLIENT_STUB(thdcap_t, capmgr_initaep_create, spdid_t child, struct cos_aep_info *aep, int owntc, cos_channelkey_t key, microsec_t ipiwin, u32_t ipimax, asndcap_t *snd)
{
  407890:	f3 0f 1e fa          	endbr64 
  407894:	55                   	push   rbp
	COS_CLIENT_INVCAP;
	u32_t child_owntc = (child << 16) | owntc;
	u32_t key_ipimax  = (key << 16) >> ipimax;
  407895:	c1 e1 10             	shl    ecx,0x10
	u32_t child_owntc = (child << 16) | owntc;
  407898:	c1 e7 10             	shl    edi,0x10
{
  40789b:	48 89 e5             	mov    rbp,rsp
  40789e:	41 57                	push   r15
  4078a0:	41 56                	push   r14
	u32_t child_owntc = (child << 16) | owntc;
  4078a2:	41 89 fe             	mov    r14d,edi
{
  4078a5:	41 55                	push   r13
  4078a7:	49 89 f5             	mov    r13,rsi
	u32_t key_ipimax  = (key << 16) >> ipimax;
  4078aa:	89 ce                	mov    esi,ecx
	u32_t ipiwin32b   = (u32_t)ipiwin;
	thdcap_t thd = 0;
	word_t sndtidret = 0, rcvtcret = 0;

	thd = cos_sinv_2rets(uc, child_owntc, key_ipimax, ipiwin32b, 0, &sndtidret, &rcvtcret);
  4078ac:	44 89 c9             	mov    ecx,r9d
{
  4078af:	41 54                	push   r12
	thd = cos_sinv_2rets(uc, child_owntc, key_ipimax, ipiwin32b, 0, &sndtidret, &rcvtcret);
  4078b1:	d3 fe                	sar    esi,cl
  4078b3:	41 09 d6             	or     r14d,edx
{
  4078b6:	53                   	push   rbx
  4078b7:	44 89 c3             	mov    ebx,r8d
  4078ba:	48 83 ec 28          	sub    rsp,0x28
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  4078be:	4c 8b 78 10          	mov    r15,QWORD PTR [rax+0x10]
	word_t sndtidret = 0, rcvtcret = 0;
  4078c2:	48 c7 45 b0 00 00 00 	mov    QWORD PTR [rbp-0x50],0x0
  4078c9:	00 
  4078ca:	48 c7 45 b8 00 00 00 	mov    QWORD PTR [rbp-0x48],0x0
  4078d1:	00 
  4078d2:	4d 85 ff             	test   r15,r15
  4078d5:	0f 84 95 00 00 00    	je     407970 <__cosrt_c_capmgr_initaep_create+0xe0>
  4078db:	4c 8d 4d b8          	lea    r9,[rbp-0x48]
  4078df:	4c 8d 45 b0          	lea    r8,[rbp-0x50]
  4078e3:	31 c9                	xor    ecx,ecx
  4078e5:	48 89 da             	mov    rdx,rbx
  4078e8:	4c 89 f7             	mov    rdi,r14
  4078eb:	41 ff d7             	call   r15
	thd = cos_sinv_2rets(uc, child_owntc, key_ipimax, ipiwin32b, 0, &sndtidret, &rcvtcret);
  4078ee:	48 98                	cdqe   
	if (!thd) return thd;
  4078f0:	48 85 c0             	test   rax,rax
  4078f3:	74 64                	je     407959 <__cosrt_c_capmgr_initaep_create+0xc9>

	aep->fn   = NULL;
	aep->data = NULL;
	aep->thd  = thd;
	aep->tid  = (sndtidret << 16) >> 16;
	aep->rcv  = rcvtcret >> 16;
  4078f5:	48 8b 75 b8          	mov    rsi,QWORD PTR [rbp-0x48]
	aep->tid  = (sndtidret << 16) >> 16;
  4078f9:	48 8b 4d b0          	mov    rcx,QWORD PTR [rbp-0x50]
	aep->tc   = (rcvtcret << 16) >> 16;
  4078fd:	48 ba ff ff ff ff ff 	movabs rdx,0xffffffffffff
  407904:	ff 00 00 
  407907:	66 48 0f 6e c8       	movq   xmm1,rax
	*snd      = sndtidret >> 16;
  40790c:	48 8b 45 10          	mov    rax,QWORD PTR [rbp+0x10]
	aep->fn   = NULL;
  407910:	49 c7 45 20 00 00 00 	mov    QWORD PTR [r13+0x20],0x0
  407917:	00 
	aep->tc   = (rcvtcret << 16) >> 16;
  407918:	48 89 f3             	mov    rbx,rsi
	aep->rcv  = rcvtcret >> 16;
  40791b:	48 c1 ee 10          	shr    rsi,0x10
	aep->data = NULL;
  40791f:	49 c7 45 28 00 00 00 	mov    QWORD PTR [r13+0x28],0x0
  407926:	00 
	aep->tc   = (rcvtcret << 16) >> 16;
  407927:	48 21 d3             	and    rbx,rdx
	aep->tid  = (sndtidret << 16) >> 16;
  40792a:	48 21 ca             	and    rdx,rcx
	aep->tc   = (rcvtcret << 16) >> 16;
  40792d:	66 48 0f 6e d6       	movq   xmm2,rsi
	*snd      = sndtidret >> 16;
  407932:	48 c1 e9 10          	shr    rcx,0x10
	aep->tc   = (rcvtcret << 16) >> 16;
  407936:	66 48 0f 6e c3       	movq   xmm0,rbx
  40793b:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  40793f:	41 0f 11 45 00       	movups XMMWORD PTR [r13+0x0],xmm0
  407944:	66 48 0f 6e c2       	movq   xmm0,rdx
  407949:	66 0f 6c c2          	punpcklqdq xmm0,xmm2
  40794d:	41 0f 11 45 10       	movups XMMWORD PTR [r13+0x10],xmm0
	*snd      = sndtidret >> 16;
  407952:	48 89 08             	mov    QWORD PTR [rax],rcx

	/* initcaps are copied to INITXXX offsets in the dst component */
	return aep->thd;
  407955:	49 8b 45 08          	mov    rax,QWORD PTR [r13+0x8]
}
  407959:	48 83 c4 28          	add    rsp,0x28
  40795d:	5b                   	pop    rbx
  40795e:	41 5c                	pop    r12
  407960:	41 5d                	pop    r13
  407962:	41 5e                	pop    r14
  407964:	41 5f                	pop    r15
  407966:	5d                   	pop    rbp
  407967:	c3                   	ret    
  407968:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40796f:	00 
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  407970:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  407974:	49 89 da             	mov    r10,rbx
	__asm__ __volatile__(
  407977:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  40797b:	4c 89 f3             	mov    rbx,r14
  40797e:	4c 89 d7             	mov    rdi,r10
  407981:	4c 89 fa             	mov    rdx,r15
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  407984:	83 c0 01             	add    eax,0x1
  407987:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40798a:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40798d:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  407991:	48 89 cd             	mov    rbp,rcx
  407994:	49 b8 a8 79 40 00 00 	movabs r8,0x4079a8
  40799b:	00 00 00 
  40799e:	0f 05                	syscall 
  4079a0:	eb 0f                	jmp    4079b1 <__cosrt_c_capmgr_initaep_create+0x121>
  4079a2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4079a8:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  4079af:	eb 07                	jmp    4079b8 <__cosrt_c_capmgr_initaep_create+0x128>
  4079b1:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  4079b8:	5d                   	pop    rbp
  4079b9:	5c                   	pop    rsp
  4079ba:	48 89 75 b0          	mov    QWORD PTR [rbp-0x50],rsi
  4079be:	48 89 7d b8          	mov    QWORD PTR [rbp-0x48],rdi
	return ret;
  4079c2:	e9 27 ff ff ff       	jmp    4078ee <__cosrt_c_capmgr_initaep_create+0x5e>
  4079c7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  4079ce:	00 00 

00000000004079d0 <__cosrt_extern_capmgr_initthd_create>:
  4079d0:	48 b8 fc 00 46 00 00 	movabs rax,0x4600fc
  4079d7:	00 00 00 
  4079da:	ff 10                	call   QWORD PTR [rax]
  4079dc:	c3                   	ret    
  4079dd:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004079e0 <__cosrt_fast_callgate_capmgr_initthd_create>:
  4079e0:	55                   	push   rbp
  4079e1:	53                   	push   rbx
  4079e2:	41 54                	push   r12
  4079e4:	41 55                	push   r13
  4079e6:	41 56                	push   r14
  4079e8:	41 57                	push   r15
  4079ea:	4d 89 c4             	mov    r12,r8
  4079ed:	4c 89 cb             	mov    rbx,r9
  4079f0:	49 89 c8             	mov    r8,rcx
  4079f3:	49 89 d1             	mov    r9,rdx
  4079f6:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4079fd:	be ad de 
  407a00:	0f 01 f9             	rdtscp 
  407a03:	48 89 ca             	mov    rdx,rcx
  407a06:	48 25 ff 0f 00 00    	and    rax,0xfff
  407a0c:	48 89 e2             	mov    rdx,rsp
  407a0f:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  407a16:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  407a1d:	00 
  407a1e:	48 c1 e0 10          	shl    rax,0x10
  407a22:	49 09 c5             	or     r13,rax
  407a25:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  407a2c:	7f 00 00 
  407a2f:	4c 89 e8             	mov    rax,r13
  407a32:	48 25 ff ff 00 00    	and    rax,0xffff
  407a38:	48 c1 e0 08          	shl    rax,0x8
  407a3c:	49 01 c6             	add    r14,rax
  407a3f:	b9 01 00 00 00       	mov    ecx,0x1
  407a44:	01 c9                	add    ecx,ecx
  407a46:	b8 03 00 00 00       	mov    eax,0x3
  407a4b:	d3 e0                	shl    eax,cl
  407a4d:	f7 d0                	not    eax
  407a4f:	83 e0 fc             	and    eax,0xfffffffc
  407a52:	48 31 c9             	xor    rcx,rcx
  407a55:	48 31 d2             	xor    rdx,rdx
  407a58:	0f 01 ef             	wrpkru 
  407a5b:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  407a5e:	48 83 c2 01          	add    rdx,0x1
  407a62:	48 c1 e2 04          	shl    rdx,0x4
  407a66:	4c 01 f2             	add    rdx,r14
  407a69:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  407a70:	45 23 01 
  407a73:	48 89 02             	mov    QWORD PTR [rdx],rax
  407a76:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  407a7a:	49 8b 06             	mov    rax,QWORD PTR [r14]
  407a7d:	48 83 c0 01          	add    rax,0x1
  407a81:	49 89 06             	mov    QWORD PTR [r14],rax
  407a84:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407a89:	01 c9                	add    ecx,ecx
  407a8b:	b8 03 00 00 00       	mov    eax,0x3
  407a90:	d3 e0                	shl    eax,cl
  407a92:	f7 d0                	not    eax
  407a94:	83 e0 fc             	and    eax,0xfffffffc
  407a97:	48 31 c9             	xor    rcx,rcx
  407a9a:	48 31 d2             	xor    rdx,rdx
  407a9d:	0f 01 ef             	wrpkru 
  407aa0:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  407aa7:	45 23 01 
  407aaa:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407ab1:	be ad de 
  407ab4:	49 39 c7             	cmp    r15,rax
  407ab7:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  407abe:	12 12 12 
  407ac1:	48 b9 cd 7a 40 00 00 	movabs rcx,0x407acd
  407ac8:	00 00 00 
  407acb:	ff e0                	jmp    rax

0000000000407acd <srv_call_ret_capmgr_initthd_create>:
  407acd:	49 89 c0             	mov    r8,rax
  407ad0:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  407ad7:	be ad de 
  407ada:	48 89 e2             	mov    rdx,rsp
  407add:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  407ae4:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  407aeb:	00 
  407aec:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  407af3:	7f 00 00 
  407af6:	4c 89 e8             	mov    rax,r13
  407af9:	48 25 ff ff 00 00    	and    rax,0xffff
  407aff:	48 c1 e0 08          	shl    rax,0x8
  407b03:	49 01 c6             	add    r14,rax
  407b06:	b9 01 00 00 00       	mov    ecx,0x1
  407b0b:	01 c9                	add    ecx,ecx
  407b0d:	b8 03 00 00 00       	mov    eax,0x3
  407b12:	d3 e0                	shl    eax,cl
  407b14:	f7 d0                	not    eax
  407b16:	83 e0 fc             	and    eax,0xfffffffc
  407b19:	48 31 c9             	xor    rcx,rcx
  407b1c:	48 31 d2             	xor    rdx,rdx
  407b1f:	0f 01 ef             	wrpkru 
  407b22:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  407b25:	48 c1 e2 04          	shl    rdx,0x4
  407b29:	4c 01 f2             	add    rdx,r14
  407b2c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  407b30:	49 8b 06             	mov    rax,QWORD PTR [r14]
  407b33:	48 83 e8 01          	sub    rax,0x1
  407b37:	49 89 06             	mov    QWORD PTR [r14],rax
  407b3a:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407b3f:	01 c9                	add    ecx,ecx
  407b41:	b8 03 00 00 00       	mov    eax,0x3
  407b46:	d3 e0                	shl    eax,cl
  407b48:	f7 d0                	not    eax
  407b4a:	83 e0 fc             	and    eax,0xfffffffc
  407b4d:	48 31 c9             	xor    rcx,rcx
  407b50:	48 31 d2             	xor    rdx,rdx
  407b53:	0f 01 ef             	wrpkru 
  407b56:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407b5d:	be ad de 
  407b60:	49 39 c7             	cmp    r15,rax
  407b63:	4c 89 c0             	mov    rax,r8
  407b66:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  407b6a:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  407b6d:	41 5f                	pop    r15
  407b6f:	41 5e                	pop    r14
  407b71:	41 5d                	pop    r13
  407b73:	41 5c                	pop    r12
  407b75:	5b                   	pop    rbx
  407b76:	5d                   	pop    rbp
  407b77:	c3                   	ret    
  407b78:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  407b7f:	00 

0000000000407b80 <__cosrt_extern_capmgr_thd_create_thunk>:
  407b80:	48 b8 14 01 46 00 00 	movabs rax,0x460114
  407b87:	00 00 00 
  407b8a:	ff 10                	call   QWORD PTR [rax]
  407b8c:	c3                   	ret    
  407b8d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000407b90 <__cosrt_fast_callgate_capmgr_thd_create_thunk>:
  407b90:	55                   	push   rbp
  407b91:	53                   	push   rbx
  407b92:	41 54                	push   r12
  407b94:	41 55                	push   r13
  407b96:	41 56                	push   r14
  407b98:	41 57                	push   r15
  407b9a:	4d 89 c4             	mov    r12,r8
  407b9d:	4c 89 cb             	mov    rbx,r9
  407ba0:	49 89 c8             	mov    r8,rcx
  407ba3:	49 89 d1             	mov    r9,rdx
  407ba6:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  407bad:	be ad de 
  407bb0:	0f 01 f9             	rdtscp 
  407bb3:	48 89 ca             	mov    rdx,rcx
  407bb6:	48 25 ff 0f 00 00    	and    rax,0xfff
  407bbc:	48 89 e2             	mov    rdx,rsp
  407bbf:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  407bc6:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  407bcd:	00 
  407bce:	48 c1 e0 10          	shl    rax,0x10
  407bd2:	49 09 c5             	or     r13,rax
  407bd5:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  407bdc:	7f 00 00 
  407bdf:	4c 89 e8             	mov    rax,r13
  407be2:	48 25 ff ff 00 00    	and    rax,0xffff
  407be8:	48 c1 e0 08          	shl    rax,0x8
  407bec:	49 01 c6             	add    r14,rax
  407bef:	b9 01 00 00 00       	mov    ecx,0x1
  407bf4:	01 c9                	add    ecx,ecx
  407bf6:	b8 03 00 00 00       	mov    eax,0x3
  407bfb:	d3 e0                	shl    eax,cl
  407bfd:	f7 d0                	not    eax
  407bff:	83 e0 fc             	and    eax,0xfffffffc
  407c02:	48 31 c9             	xor    rcx,rcx
  407c05:	48 31 d2             	xor    rdx,rdx
  407c08:	0f 01 ef             	wrpkru 
  407c0b:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  407c0e:	48 83 c2 01          	add    rdx,0x1
  407c12:	48 c1 e2 04          	shl    rdx,0x4
  407c16:	4c 01 f2             	add    rdx,r14
  407c19:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  407c20:	45 23 01 
  407c23:	48 89 02             	mov    QWORD PTR [rdx],rax
  407c26:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  407c2a:	49 8b 06             	mov    rax,QWORD PTR [r14]
  407c2d:	48 83 c0 01          	add    rax,0x1
  407c31:	49 89 06             	mov    QWORD PTR [r14],rax
  407c34:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407c39:	01 c9                	add    ecx,ecx
  407c3b:	b8 03 00 00 00       	mov    eax,0x3
  407c40:	d3 e0                	shl    eax,cl
  407c42:	f7 d0                	not    eax
  407c44:	83 e0 fc             	and    eax,0xfffffffc
  407c47:	48 31 c9             	xor    rcx,rcx
  407c4a:	48 31 d2             	xor    rdx,rdx
  407c4d:	0f 01 ef             	wrpkru 
  407c50:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  407c57:	45 23 01 
  407c5a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407c61:	be ad de 
  407c64:	49 39 c7             	cmp    r15,rax
  407c67:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  407c6e:	12 12 12 
  407c71:	48 b9 7d 7c 40 00 00 	movabs rcx,0x407c7d
  407c78:	00 00 00 
  407c7b:	ff e0                	jmp    rax

0000000000407c7d <srv_call_ret_capmgr_thd_create_thunk>:
  407c7d:	49 89 c0             	mov    r8,rax
  407c80:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  407c87:	be ad de 
  407c8a:	48 89 e2             	mov    rdx,rsp
  407c8d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  407c94:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  407c9b:	00 
  407c9c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  407ca3:	7f 00 00 
  407ca6:	4c 89 e8             	mov    rax,r13
  407ca9:	48 25 ff ff 00 00    	and    rax,0xffff
  407caf:	48 c1 e0 08          	shl    rax,0x8
  407cb3:	49 01 c6             	add    r14,rax
  407cb6:	b9 01 00 00 00       	mov    ecx,0x1
  407cbb:	01 c9                	add    ecx,ecx
  407cbd:	b8 03 00 00 00       	mov    eax,0x3
  407cc2:	d3 e0                	shl    eax,cl
  407cc4:	f7 d0                	not    eax
  407cc6:	83 e0 fc             	and    eax,0xfffffffc
  407cc9:	48 31 c9             	xor    rcx,rcx
  407ccc:	48 31 d2             	xor    rdx,rdx
  407ccf:	0f 01 ef             	wrpkru 
  407cd2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  407cd5:	48 c1 e2 04          	shl    rdx,0x4
  407cd9:	4c 01 f2             	add    rdx,r14
  407cdc:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  407ce0:	49 8b 06             	mov    rax,QWORD PTR [r14]
  407ce3:	48 83 e8 01          	sub    rax,0x1
  407ce7:	49 89 06             	mov    QWORD PTR [r14],rax
  407cea:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407cef:	01 c9                	add    ecx,ecx
  407cf1:	b8 03 00 00 00       	mov    eax,0x3
  407cf6:	d3 e0                	shl    eax,cl
  407cf8:	f7 d0                	not    eax
  407cfa:	83 e0 fc             	and    eax,0xfffffffc
  407cfd:	48 31 c9             	xor    rcx,rcx
  407d00:	48 31 d2             	xor    rdx,rdx
  407d03:	0f 01 ef             	wrpkru 
  407d06:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407d0d:	be ad de 
  407d10:	49 39 c7             	cmp    r15,rax
  407d13:	4c 89 c0             	mov    rax,r8
  407d16:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  407d1a:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  407d1d:	41 5f                	pop    r15
  407d1f:	41 5e                	pop    r14
  407d21:	41 5d                	pop    r13
  407d23:	41 5c                	pop    r12
  407d25:	5b                   	pop    rbx
  407d26:	5d                   	pop    rbp
  407d27:	c3                   	ret    
  407d28:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  407d2f:	00 

0000000000407d30 <__cosrt_extern_capmgr_thd_create_ext>:
  407d30:	48 b8 2c 01 46 00 00 	movabs rax,0x46012c
  407d37:	00 00 00 
  407d3a:	ff 10                	call   QWORD PTR [rax]
  407d3c:	c3                   	ret    
  407d3d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000407d40 <__cosrt_fast_callgate_capmgr_thd_create_ext>:
  407d40:	55                   	push   rbp
  407d41:	53                   	push   rbx
  407d42:	41 54                	push   r12
  407d44:	41 55                	push   r13
  407d46:	41 56                	push   r14
  407d48:	41 57                	push   r15
  407d4a:	4d 89 c4             	mov    r12,r8
  407d4d:	4c 89 cb             	mov    rbx,r9
  407d50:	49 89 c8             	mov    r8,rcx
  407d53:	49 89 d1             	mov    r9,rdx
  407d56:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  407d5d:	be ad de 
  407d60:	0f 01 f9             	rdtscp 
  407d63:	48 89 ca             	mov    rdx,rcx
  407d66:	48 25 ff 0f 00 00    	and    rax,0xfff
  407d6c:	48 89 e2             	mov    rdx,rsp
  407d6f:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  407d76:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  407d7d:	00 
  407d7e:	48 c1 e0 10          	shl    rax,0x10
  407d82:	49 09 c5             	or     r13,rax
  407d85:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  407d8c:	7f 00 00 
  407d8f:	4c 89 e8             	mov    rax,r13
  407d92:	48 25 ff ff 00 00    	and    rax,0xffff
  407d98:	48 c1 e0 08          	shl    rax,0x8
  407d9c:	49 01 c6             	add    r14,rax
  407d9f:	b9 01 00 00 00       	mov    ecx,0x1
  407da4:	01 c9                	add    ecx,ecx
  407da6:	b8 03 00 00 00       	mov    eax,0x3
  407dab:	d3 e0                	shl    eax,cl
  407dad:	f7 d0                	not    eax
  407daf:	83 e0 fc             	and    eax,0xfffffffc
  407db2:	48 31 c9             	xor    rcx,rcx
  407db5:	48 31 d2             	xor    rdx,rdx
  407db8:	0f 01 ef             	wrpkru 
  407dbb:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  407dbe:	48 83 c2 01          	add    rdx,0x1
  407dc2:	48 c1 e2 04          	shl    rdx,0x4
  407dc6:	4c 01 f2             	add    rdx,r14
  407dc9:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  407dd0:	45 23 01 
  407dd3:	48 89 02             	mov    QWORD PTR [rdx],rax
  407dd6:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  407dda:	49 8b 06             	mov    rax,QWORD PTR [r14]
  407ddd:	48 83 c0 01          	add    rax,0x1
  407de1:	49 89 06             	mov    QWORD PTR [r14],rax
  407de4:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407de9:	01 c9                	add    ecx,ecx
  407deb:	b8 03 00 00 00       	mov    eax,0x3
  407df0:	d3 e0                	shl    eax,cl
  407df2:	f7 d0                	not    eax
  407df4:	83 e0 fc             	and    eax,0xfffffffc
  407df7:	48 31 c9             	xor    rcx,rcx
  407dfa:	48 31 d2             	xor    rdx,rdx
  407dfd:	0f 01 ef             	wrpkru 
  407e00:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  407e07:	45 23 01 
  407e0a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407e11:	be ad de 
  407e14:	49 39 c7             	cmp    r15,rax
  407e17:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  407e1e:	12 12 12 
  407e21:	48 b9 2d 7e 40 00 00 	movabs rcx,0x407e2d
  407e28:	00 00 00 
  407e2b:	ff e0                	jmp    rax

0000000000407e2d <srv_call_ret_capmgr_thd_create_ext>:
  407e2d:	49 89 c0             	mov    r8,rax
  407e30:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  407e37:	be ad de 
  407e3a:	48 89 e2             	mov    rdx,rsp
  407e3d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  407e44:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  407e4b:	00 
  407e4c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  407e53:	7f 00 00 
  407e56:	4c 89 e8             	mov    rax,r13
  407e59:	48 25 ff ff 00 00    	and    rax,0xffff
  407e5f:	48 c1 e0 08          	shl    rax,0x8
  407e63:	49 01 c6             	add    r14,rax
  407e66:	b9 01 00 00 00       	mov    ecx,0x1
  407e6b:	01 c9                	add    ecx,ecx
  407e6d:	b8 03 00 00 00       	mov    eax,0x3
  407e72:	d3 e0                	shl    eax,cl
  407e74:	f7 d0                	not    eax
  407e76:	83 e0 fc             	and    eax,0xfffffffc
  407e79:	48 31 c9             	xor    rcx,rcx
  407e7c:	48 31 d2             	xor    rdx,rdx
  407e7f:	0f 01 ef             	wrpkru 
  407e82:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  407e85:	48 c1 e2 04          	shl    rdx,0x4
  407e89:	4c 01 f2             	add    rdx,r14
  407e8c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  407e90:	49 8b 06             	mov    rax,QWORD PTR [r14]
  407e93:	48 83 e8 01          	sub    rax,0x1
  407e97:	49 89 06             	mov    QWORD PTR [r14],rax
  407e9a:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407e9f:	01 c9                	add    ecx,ecx
  407ea1:	b8 03 00 00 00       	mov    eax,0x3
  407ea6:	d3 e0                	shl    eax,cl
  407ea8:	f7 d0                	not    eax
  407eaa:	83 e0 fc             	and    eax,0xfffffffc
  407ead:	48 31 c9             	xor    rcx,rcx
  407eb0:	48 31 d2             	xor    rdx,rdx
  407eb3:	0f 01 ef             	wrpkru 
  407eb6:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407ebd:	be ad de 
  407ec0:	49 39 c7             	cmp    r15,rax
  407ec3:	4c 89 c0             	mov    rax,r8
  407ec6:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  407eca:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  407ecd:	41 5f                	pop    r15
  407ecf:	41 5e                	pop    r14
  407ed1:	41 5d                	pop    r13
  407ed3:	41 5c                	pop    r12
  407ed5:	5b                   	pop    rbx
  407ed6:	5d                   	pop    rbp
  407ed7:	c3                   	ret    
  407ed8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  407edf:	00 

0000000000407ee0 <__cosrt_extern_capmgr_initaep_create>:
  407ee0:	48 b8 44 01 46 00 00 	movabs rax,0x460144
  407ee7:	00 00 00 
  407eea:	ff 10                	call   QWORD PTR [rax]
  407eec:	c3                   	ret    
  407eed:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000407ef0 <__cosrt_fast_callgate_capmgr_initaep_create>:
  407ef0:	55                   	push   rbp
  407ef1:	53                   	push   rbx
  407ef2:	41 54                	push   r12
  407ef4:	41 55                	push   r13
  407ef6:	41 56                	push   r14
  407ef8:	41 57                	push   r15
  407efa:	4d 89 c4             	mov    r12,r8
  407efd:	4c 89 cb             	mov    rbx,r9
  407f00:	49 89 c8             	mov    r8,rcx
  407f03:	49 89 d1             	mov    r9,rdx
  407f06:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  407f0d:	be ad de 
  407f10:	0f 01 f9             	rdtscp 
  407f13:	48 89 ca             	mov    rdx,rcx
  407f16:	48 25 ff 0f 00 00    	and    rax,0xfff
  407f1c:	48 89 e2             	mov    rdx,rsp
  407f1f:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  407f26:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  407f2d:	00 
  407f2e:	48 c1 e0 10          	shl    rax,0x10
  407f32:	49 09 c5             	or     r13,rax
  407f35:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  407f3c:	7f 00 00 
  407f3f:	4c 89 e8             	mov    rax,r13
  407f42:	48 25 ff ff 00 00    	and    rax,0xffff
  407f48:	48 c1 e0 08          	shl    rax,0x8
  407f4c:	49 01 c6             	add    r14,rax
  407f4f:	b9 01 00 00 00       	mov    ecx,0x1
  407f54:	01 c9                	add    ecx,ecx
  407f56:	b8 03 00 00 00       	mov    eax,0x3
  407f5b:	d3 e0                	shl    eax,cl
  407f5d:	f7 d0                	not    eax
  407f5f:	83 e0 fc             	and    eax,0xfffffffc
  407f62:	48 31 c9             	xor    rcx,rcx
  407f65:	48 31 d2             	xor    rdx,rdx
  407f68:	0f 01 ef             	wrpkru 
  407f6b:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  407f6e:	48 83 c2 01          	add    rdx,0x1
  407f72:	48 c1 e2 04          	shl    rdx,0x4
  407f76:	4c 01 f2             	add    rdx,r14
  407f79:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  407f80:	45 23 01 
  407f83:	48 89 02             	mov    QWORD PTR [rdx],rax
  407f86:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  407f8a:	49 8b 06             	mov    rax,QWORD PTR [r14]
  407f8d:	48 83 c0 01          	add    rax,0x1
  407f91:	49 89 06             	mov    QWORD PTR [r14],rax
  407f94:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407f99:	01 c9                	add    ecx,ecx
  407f9b:	b8 03 00 00 00       	mov    eax,0x3
  407fa0:	d3 e0                	shl    eax,cl
  407fa2:	f7 d0                	not    eax
  407fa4:	83 e0 fc             	and    eax,0xfffffffc
  407fa7:	48 31 c9             	xor    rcx,rcx
  407faa:	48 31 d2             	xor    rdx,rdx
  407fad:	0f 01 ef             	wrpkru 
  407fb0:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  407fb7:	45 23 01 
  407fba:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407fc1:	be ad de 
  407fc4:	49 39 c7             	cmp    r15,rax
  407fc7:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  407fce:	12 12 12 
  407fd1:	48 b9 dd 7f 40 00 00 	movabs rcx,0x407fdd
  407fd8:	00 00 00 
  407fdb:	ff e0                	jmp    rax

0000000000407fdd <srv_call_ret_capmgr_initaep_create>:
  407fdd:	49 89 c0             	mov    r8,rax
  407fe0:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  407fe7:	be ad de 
  407fea:	48 89 e2             	mov    rdx,rsp
  407fed:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  407ff4:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  407ffb:	00 
  407ffc:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  408003:	7f 00 00 
  408006:	4c 89 e8             	mov    rax,r13
  408009:	48 25 ff ff 00 00    	and    rax,0xffff
  40800f:	48 c1 e0 08          	shl    rax,0x8
  408013:	49 01 c6             	add    r14,rax
  408016:	b9 01 00 00 00       	mov    ecx,0x1
  40801b:	01 c9                	add    ecx,ecx
  40801d:	b8 03 00 00 00       	mov    eax,0x3
  408022:	d3 e0                	shl    eax,cl
  408024:	f7 d0                	not    eax
  408026:	83 e0 fc             	and    eax,0xfffffffc
  408029:	48 31 c9             	xor    rcx,rcx
  40802c:	48 31 d2             	xor    rdx,rdx
  40802f:	0f 01 ef             	wrpkru 
  408032:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  408035:	48 c1 e2 04          	shl    rdx,0x4
  408039:	4c 01 f2             	add    rdx,r14
  40803c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  408040:	49 8b 06             	mov    rax,QWORD PTR [r14]
  408043:	48 83 e8 01          	sub    rax,0x1
  408047:	49 89 06             	mov    QWORD PTR [r14],rax
  40804a:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40804f:	01 c9                	add    ecx,ecx
  408051:	b8 03 00 00 00       	mov    eax,0x3
  408056:	d3 e0                	shl    eax,cl
  408058:	f7 d0                	not    eax
  40805a:	83 e0 fc             	and    eax,0xfffffffc
  40805d:	48 31 c9             	xor    rcx,rcx
  408060:	48 31 d2             	xor    rdx,rdx
  408063:	0f 01 ef             	wrpkru 
  408066:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40806d:	be ad de 
  408070:	49 39 c7             	cmp    r15,rax
  408073:	4c 89 c0             	mov    rax,r8
  408076:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  40807a:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  40807d:	41 5f                	pop    r15
  40807f:	41 5e                	pop    r14
  408081:	41 5d                	pop    r13
  408083:	41 5c                	pop    r12
  408085:	5b                   	pop    rbx
  408086:	5d                   	pop    rbp
  408087:	c3                   	ret    
  408088:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40808f:	00 

0000000000408090 <__cosrt_extern_capmgr_aep_create_thunk>:
  408090:	48 b8 5c 01 46 00 00 	movabs rax,0x46015c
  408097:	00 00 00 
  40809a:	ff 10                	call   QWORD PTR [rax]
  40809c:	c3                   	ret    
  40809d:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004080a0 <__cosrt_fast_callgate_capmgr_aep_create_thunk>:
  4080a0:	55                   	push   rbp
  4080a1:	53                   	push   rbx
  4080a2:	41 54                	push   r12
  4080a4:	41 55                	push   r13
  4080a6:	41 56                	push   r14
  4080a8:	41 57                	push   r15
  4080aa:	4d 89 c4             	mov    r12,r8
  4080ad:	4c 89 cb             	mov    rbx,r9
  4080b0:	49 89 c8             	mov    r8,rcx
  4080b3:	49 89 d1             	mov    r9,rdx
  4080b6:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4080bd:	be ad de 
  4080c0:	0f 01 f9             	rdtscp 
  4080c3:	48 89 ca             	mov    rdx,rcx
  4080c6:	48 25 ff 0f 00 00    	and    rax,0xfff
  4080cc:	48 89 e2             	mov    rdx,rsp
  4080cf:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4080d6:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4080dd:	00 
  4080de:	48 c1 e0 10          	shl    rax,0x10
  4080e2:	49 09 c5             	or     r13,rax
  4080e5:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4080ec:	7f 00 00 
  4080ef:	4c 89 e8             	mov    rax,r13
  4080f2:	48 25 ff ff 00 00    	and    rax,0xffff
  4080f8:	48 c1 e0 08          	shl    rax,0x8
  4080fc:	49 01 c6             	add    r14,rax
  4080ff:	b9 01 00 00 00       	mov    ecx,0x1
  408104:	01 c9                	add    ecx,ecx
  408106:	b8 03 00 00 00       	mov    eax,0x3
  40810b:	d3 e0                	shl    eax,cl
  40810d:	f7 d0                	not    eax
  40810f:	83 e0 fc             	and    eax,0xfffffffc
  408112:	48 31 c9             	xor    rcx,rcx
  408115:	48 31 d2             	xor    rdx,rdx
  408118:	0f 01 ef             	wrpkru 
  40811b:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40811e:	48 83 c2 01          	add    rdx,0x1
  408122:	48 c1 e2 04          	shl    rdx,0x4
  408126:	4c 01 f2             	add    rdx,r14
  408129:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  408130:	45 23 01 
  408133:	48 89 02             	mov    QWORD PTR [rdx],rax
  408136:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  40813a:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40813d:	48 83 c0 01          	add    rax,0x1
  408141:	49 89 06             	mov    QWORD PTR [r14],rax
  408144:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  408149:	01 c9                	add    ecx,ecx
  40814b:	b8 03 00 00 00       	mov    eax,0x3
  408150:	d3 e0                	shl    eax,cl
  408152:	f7 d0                	not    eax
  408154:	83 e0 fc             	and    eax,0xfffffffc
  408157:	48 31 c9             	xor    rcx,rcx
  40815a:	48 31 d2             	xor    rdx,rdx
  40815d:	0f 01 ef             	wrpkru 
  408160:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  408167:	45 23 01 
  40816a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408171:	be ad de 
  408174:	49 39 c7             	cmp    r15,rax
  408177:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  40817e:	12 12 12 
  408181:	48 b9 8d 81 40 00 00 	movabs rcx,0x40818d
  408188:	00 00 00 
  40818b:	ff e0                	jmp    rax

000000000040818d <srv_call_ret_capmgr_aep_create_thunk>:
  40818d:	49 89 c0             	mov    r8,rax
  408190:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  408197:	be ad de 
  40819a:	48 89 e2             	mov    rdx,rsp
  40819d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4081a4:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4081ab:	00 
  4081ac:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4081b3:	7f 00 00 
  4081b6:	4c 89 e8             	mov    rax,r13
  4081b9:	48 25 ff ff 00 00    	and    rax,0xffff
  4081bf:	48 c1 e0 08          	shl    rax,0x8
  4081c3:	49 01 c6             	add    r14,rax
  4081c6:	b9 01 00 00 00       	mov    ecx,0x1
  4081cb:	01 c9                	add    ecx,ecx
  4081cd:	b8 03 00 00 00       	mov    eax,0x3
  4081d2:	d3 e0                	shl    eax,cl
  4081d4:	f7 d0                	not    eax
  4081d6:	83 e0 fc             	and    eax,0xfffffffc
  4081d9:	48 31 c9             	xor    rcx,rcx
  4081dc:	48 31 d2             	xor    rdx,rdx
  4081df:	0f 01 ef             	wrpkru 
  4081e2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4081e5:	48 c1 e2 04          	shl    rdx,0x4
  4081e9:	4c 01 f2             	add    rdx,r14
  4081ec:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  4081f0:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4081f3:	48 83 e8 01          	sub    rax,0x1
  4081f7:	49 89 06             	mov    QWORD PTR [r14],rax
  4081fa:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4081ff:	01 c9                	add    ecx,ecx
  408201:	b8 03 00 00 00       	mov    eax,0x3
  408206:	d3 e0                	shl    eax,cl
  408208:	f7 d0                	not    eax
  40820a:	83 e0 fc             	and    eax,0xfffffffc
  40820d:	48 31 c9             	xor    rcx,rcx
  408210:	48 31 d2             	xor    rdx,rdx
  408213:	0f 01 ef             	wrpkru 
  408216:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40821d:	be ad de 
  408220:	49 39 c7             	cmp    r15,rax
  408223:	4c 89 c0             	mov    rax,r8
  408226:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  40822a:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  40822d:	41 5f                	pop    r15
  40822f:	41 5e                	pop    r14
  408231:	41 5d                	pop    r13
  408233:	41 5c                	pop    r12
  408235:	5b                   	pop    rbx
  408236:	5d                   	pop    rbp
  408237:	c3                   	ret    
  408238:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40823f:	00 

0000000000408240 <__cosrt_extern_capmgr_aep_create_ext>:
  408240:	48 b8 74 01 46 00 00 	movabs rax,0x460174
  408247:	00 00 00 
  40824a:	ff 10                	call   QWORD PTR [rax]
  40824c:	c3                   	ret    
  40824d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000408250 <__cosrt_fast_callgate_capmgr_aep_create_ext>:
  408250:	55                   	push   rbp
  408251:	53                   	push   rbx
  408252:	41 54                	push   r12
  408254:	41 55                	push   r13
  408256:	41 56                	push   r14
  408258:	41 57                	push   r15
  40825a:	4d 89 c4             	mov    r12,r8
  40825d:	4c 89 cb             	mov    rbx,r9
  408260:	49 89 c8             	mov    r8,rcx
  408263:	49 89 d1             	mov    r9,rdx
  408266:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40826d:	be ad de 
  408270:	0f 01 f9             	rdtscp 
  408273:	48 89 ca             	mov    rdx,rcx
  408276:	48 25 ff 0f 00 00    	and    rax,0xfff
  40827c:	48 89 e2             	mov    rdx,rsp
  40827f:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  408286:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40828d:	00 
  40828e:	48 c1 e0 10          	shl    rax,0x10
  408292:	49 09 c5             	or     r13,rax
  408295:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40829c:	7f 00 00 
  40829f:	4c 89 e8             	mov    rax,r13
  4082a2:	48 25 ff ff 00 00    	and    rax,0xffff
  4082a8:	48 c1 e0 08          	shl    rax,0x8
  4082ac:	49 01 c6             	add    r14,rax
  4082af:	b9 01 00 00 00       	mov    ecx,0x1
  4082b4:	01 c9                	add    ecx,ecx
  4082b6:	b8 03 00 00 00       	mov    eax,0x3
  4082bb:	d3 e0                	shl    eax,cl
  4082bd:	f7 d0                	not    eax
  4082bf:	83 e0 fc             	and    eax,0xfffffffc
  4082c2:	48 31 c9             	xor    rcx,rcx
  4082c5:	48 31 d2             	xor    rdx,rdx
  4082c8:	0f 01 ef             	wrpkru 
  4082cb:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4082ce:	48 83 c2 01          	add    rdx,0x1
  4082d2:	48 c1 e2 04          	shl    rdx,0x4
  4082d6:	4c 01 f2             	add    rdx,r14
  4082d9:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  4082e0:	45 23 01 
  4082e3:	48 89 02             	mov    QWORD PTR [rdx],rax
  4082e6:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  4082ea:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4082ed:	48 83 c0 01          	add    rax,0x1
  4082f1:	49 89 06             	mov    QWORD PTR [r14],rax
  4082f4:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4082f9:	01 c9                	add    ecx,ecx
  4082fb:	b8 03 00 00 00       	mov    eax,0x3
  408300:	d3 e0                	shl    eax,cl
  408302:	f7 d0                	not    eax
  408304:	83 e0 fc             	and    eax,0xfffffffc
  408307:	48 31 c9             	xor    rcx,rcx
  40830a:	48 31 d2             	xor    rdx,rdx
  40830d:	0f 01 ef             	wrpkru 
  408310:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  408317:	45 23 01 
  40831a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408321:	be ad de 
  408324:	49 39 c7             	cmp    r15,rax
  408327:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  40832e:	12 12 12 
  408331:	48 b9 3d 83 40 00 00 	movabs rcx,0x40833d
  408338:	00 00 00 
  40833b:	ff e0                	jmp    rax

000000000040833d <srv_call_ret_capmgr_aep_create_ext>:
  40833d:	49 89 c0             	mov    r8,rax
  408340:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  408347:	be ad de 
  40834a:	48 89 e2             	mov    rdx,rsp
  40834d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  408354:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40835b:	00 
  40835c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  408363:	7f 00 00 
  408366:	4c 89 e8             	mov    rax,r13
  408369:	48 25 ff ff 00 00    	and    rax,0xffff
  40836f:	48 c1 e0 08          	shl    rax,0x8
  408373:	49 01 c6             	add    r14,rax
  408376:	b9 01 00 00 00       	mov    ecx,0x1
  40837b:	01 c9                	add    ecx,ecx
  40837d:	b8 03 00 00 00       	mov    eax,0x3
  408382:	d3 e0                	shl    eax,cl
  408384:	f7 d0                	not    eax
  408386:	83 e0 fc             	and    eax,0xfffffffc
  408389:	48 31 c9             	xor    rcx,rcx
  40838c:	48 31 d2             	xor    rdx,rdx
  40838f:	0f 01 ef             	wrpkru 
  408392:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  408395:	48 c1 e2 04          	shl    rdx,0x4
  408399:	4c 01 f2             	add    rdx,r14
  40839c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  4083a0:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4083a3:	48 83 e8 01          	sub    rax,0x1
  4083a7:	49 89 06             	mov    QWORD PTR [r14],rax
  4083aa:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4083af:	01 c9                	add    ecx,ecx
  4083b1:	b8 03 00 00 00       	mov    eax,0x3
  4083b6:	d3 e0                	shl    eax,cl
  4083b8:	f7 d0                	not    eax
  4083ba:	83 e0 fc             	and    eax,0xfffffffc
  4083bd:	48 31 c9             	xor    rcx,rcx
  4083c0:	48 31 d2             	xor    rdx,rdx
  4083c3:	0f 01 ef             	wrpkru 
  4083c6:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4083cd:	be ad de 
  4083d0:	49 39 c7             	cmp    r15,rax
  4083d3:	4c 89 c0             	mov    rax,r8
  4083d6:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  4083da:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  4083dd:	41 5f                	pop    r15
  4083df:	41 5e                	pop    r14
  4083e1:	41 5d                	pop    r13
  4083e3:	41 5c                	pop    r12
  4083e5:	5b                   	pop    rbx
  4083e6:	5d                   	pop    rbp
  4083e7:	c3                   	ret    
  4083e8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4083ef:	00 

00000000004083f0 <__cosrt_extern_capmgr_rcv_create>:
  4083f0:	48 b8 8c 01 46 00 00 	movabs rax,0x46018c
  4083f7:	00 00 00 
  4083fa:	ff 10                	call   QWORD PTR [rax]
  4083fc:	c3                   	ret    
  4083fd:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000408400 <__cosrt_fast_callgate_capmgr_rcv_create>:
  408400:	55                   	push   rbp
  408401:	53                   	push   rbx
  408402:	41 54                	push   r12
  408404:	41 55                	push   r13
  408406:	41 56                	push   r14
  408408:	41 57                	push   r15
  40840a:	4d 89 c4             	mov    r12,r8
  40840d:	4c 89 cb             	mov    rbx,r9
  408410:	49 89 c8             	mov    r8,rcx
  408413:	49 89 d1             	mov    r9,rdx
  408416:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40841d:	be ad de 
  408420:	0f 01 f9             	rdtscp 
  408423:	48 89 ca             	mov    rdx,rcx
  408426:	48 25 ff 0f 00 00    	and    rax,0xfff
  40842c:	48 89 e2             	mov    rdx,rsp
  40842f:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  408436:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40843d:	00 
  40843e:	48 c1 e0 10          	shl    rax,0x10
  408442:	49 09 c5             	or     r13,rax
  408445:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40844c:	7f 00 00 
  40844f:	4c 89 e8             	mov    rax,r13
  408452:	48 25 ff ff 00 00    	and    rax,0xffff
  408458:	48 c1 e0 08          	shl    rax,0x8
  40845c:	49 01 c6             	add    r14,rax
  40845f:	b9 01 00 00 00       	mov    ecx,0x1
  408464:	01 c9                	add    ecx,ecx
  408466:	b8 03 00 00 00       	mov    eax,0x3
  40846b:	d3 e0                	shl    eax,cl
  40846d:	f7 d0                	not    eax
  40846f:	83 e0 fc             	and    eax,0xfffffffc
  408472:	48 31 c9             	xor    rcx,rcx
  408475:	48 31 d2             	xor    rdx,rdx
  408478:	0f 01 ef             	wrpkru 
  40847b:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40847e:	48 83 c2 01          	add    rdx,0x1
  408482:	48 c1 e2 04          	shl    rdx,0x4
  408486:	4c 01 f2             	add    rdx,r14
  408489:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  408490:	45 23 01 
  408493:	48 89 02             	mov    QWORD PTR [rdx],rax
  408496:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  40849a:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40849d:	48 83 c0 01          	add    rax,0x1
  4084a1:	49 89 06             	mov    QWORD PTR [r14],rax
  4084a4:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4084a9:	01 c9                	add    ecx,ecx
  4084ab:	b8 03 00 00 00       	mov    eax,0x3
  4084b0:	d3 e0                	shl    eax,cl
  4084b2:	f7 d0                	not    eax
  4084b4:	83 e0 fc             	and    eax,0xfffffffc
  4084b7:	48 31 c9             	xor    rcx,rcx
  4084ba:	48 31 d2             	xor    rdx,rdx
  4084bd:	0f 01 ef             	wrpkru 
  4084c0:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  4084c7:	45 23 01 
  4084ca:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4084d1:	be ad de 
  4084d4:	49 39 c7             	cmp    r15,rax
  4084d7:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  4084de:	12 12 12 
  4084e1:	48 b9 ed 84 40 00 00 	movabs rcx,0x4084ed
  4084e8:	00 00 00 
  4084eb:	ff e0                	jmp    rax

00000000004084ed <srv_call_ret_capmgr_rcv_create>:
  4084ed:	49 89 c0             	mov    r8,rax
  4084f0:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4084f7:	be ad de 
  4084fa:	48 89 e2             	mov    rdx,rsp
  4084fd:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  408504:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40850b:	00 
  40850c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  408513:	7f 00 00 
  408516:	4c 89 e8             	mov    rax,r13
  408519:	48 25 ff ff 00 00    	and    rax,0xffff
  40851f:	48 c1 e0 08          	shl    rax,0x8
  408523:	49 01 c6             	add    r14,rax
  408526:	b9 01 00 00 00       	mov    ecx,0x1
  40852b:	01 c9                	add    ecx,ecx
  40852d:	b8 03 00 00 00       	mov    eax,0x3
  408532:	d3 e0                	shl    eax,cl
  408534:	f7 d0                	not    eax
  408536:	83 e0 fc             	and    eax,0xfffffffc
  408539:	48 31 c9             	xor    rcx,rcx
  40853c:	48 31 d2             	xor    rdx,rdx
  40853f:	0f 01 ef             	wrpkru 
  408542:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  408545:	48 c1 e2 04          	shl    rdx,0x4
  408549:	4c 01 f2             	add    rdx,r14
  40854c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  408550:	49 8b 06             	mov    rax,QWORD PTR [r14]
  408553:	48 83 e8 01          	sub    rax,0x1
  408557:	49 89 06             	mov    QWORD PTR [r14],rax
  40855a:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40855f:	01 c9                	add    ecx,ecx
  408561:	b8 03 00 00 00       	mov    eax,0x3
  408566:	d3 e0                	shl    eax,cl
  408568:	f7 d0                	not    eax
  40856a:	83 e0 fc             	and    eax,0xfffffffc
  40856d:	48 31 c9             	xor    rcx,rcx
  408570:	48 31 d2             	xor    rdx,rdx
  408573:	0f 01 ef             	wrpkru 
  408576:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40857d:	be ad de 
  408580:	49 39 c7             	cmp    r15,rax
  408583:	4c 89 c0             	mov    rax,r8
  408586:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  40858a:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  40858d:	41 5f                	pop    r15
  40858f:	41 5e                	pop    r14
  408591:	41 5d                	pop    r13
  408593:	41 5c                	pop    r12
  408595:	5b                   	pop    rbx
  408596:	5d                   	pop    rbp
  408597:	c3                   	ret    
  408598:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40859f:	00 

00000000004085a0 <__cosrt_extern_capmgr_set_tls>:
  4085a0:	48 b8 a4 01 46 00 00 	movabs rax,0x4601a4
  4085a7:	00 00 00 
  4085aa:	ff 10                	call   QWORD PTR [rax]
  4085ac:	c3                   	ret    
  4085ad:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004085b0 <__cosrt_fast_callgate_capmgr_set_tls>:
  4085b0:	55                   	push   rbp
  4085b1:	41 55                	push   r13
  4085b3:	41 56                	push   r14
  4085b5:	41 57                	push   r15
  4085b7:	49 89 c8             	mov    r8,rcx
  4085ba:	49 89 d1             	mov    r9,rdx
  4085bd:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4085c4:	be ad de 
  4085c7:	0f 01 f9             	rdtscp 
  4085ca:	48 89 c8             	mov    rax,rcx
  4085cd:	48 25 ff 0f 00 00    	and    rax,0xfff
  4085d3:	48 89 e2             	mov    rdx,rsp
  4085d6:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4085dd:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4085e4:	00 
  4085e5:	48 c1 e0 10          	shl    rax,0x10
  4085e9:	49 09 c5             	or     r13,rax
  4085ec:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4085f3:	7f 00 00 
  4085f6:	4c 89 e8             	mov    rax,r13
  4085f9:	48 25 ff ff 00 00    	and    rax,0xffff
  4085ff:	48 c1 e0 08          	shl    rax,0x8
  408603:	49 01 c6             	add    r14,rax
  408606:	b9 01 00 00 00       	mov    ecx,0x1
  40860b:	01 c9                	add    ecx,ecx
  40860d:	b8 03 00 00 00       	mov    eax,0x3
  408612:	d3 e0                	shl    eax,cl
  408614:	f7 d0                	not    eax
  408616:	83 e0 fc             	and    eax,0xfffffffc
  408619:	48 31 c9             	xor    rcx,rcx
  40861c:	48 31 d2             	xor    rdx,rdx
  40861f:	0f 01 ef             	wrpkru 
  408622:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  408625:	48 83 c2 01          	add    rdx,0x1
  408629:	48 c1 e2 04          	shl    rdx,0x4
  40862d:	4c 01 f2             	add    rdx,r14
  408630:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  408637:	45 23 01 
  40863a:	48 89 02             	mov    QWORD PTR [rdx],rax
  40863d:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  408641:	49 8b 06             	mov    rax,QWORD PTR [r14]
  408644:	48 83 c0 01          	add    rax,0x1
  408648:	49 89 06             	mov    QWORD PTR [r14],rax
  40864b:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  408650:	01 c9                	add    ecx,ecx
  408652:	b8 03 00 00 00       	mov    eax,0x3
  408657:	d3 e0                	shl    eax,cl
  408659:	f7 d0                	not    eax
  40865b:	83 e0 fc             	and    eax,0xfffffffc
  40865e:	48 31 c9             	xor    rcx,rcx
  408661:	48 31 d2             	xor    rdx,rdx
  408664:	0f 01 ef             	wrpkru 
  408667:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  40866e:	45 23 01 
  408671:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408678:	be ad de 
  40867b:	49 39 c7             	cmp    r15,rax
  40867e:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  408685:	12 12 12 
  408688:	48 b9 94 86 40 00 00 	movabs rcx,0x408694
  40868f:	00 00 00 
  408692:	ff e0                	jmp    rax

0000000000408694 <srv_call_ret_capmgr_set_tls>:
  408694:	49 89 c0             	mov    r8,rax
  408697:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40869e:	be ad de 
  4086a1:	48 89 e2             	mov    rdx,rsp
  4086a4:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4086ab:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4086b2:	00 
  4086b3:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4086ba:	7f 00 00 
  4086bd:	4c 89 e8             	mov    rax,r13
  4086c0:	48 25 ff ff 00 00    	and    rax,0xffff
  4086c6:	48 c1 e0 08          	shl    rax,0x8
  4086ca:	49 01 c6             	add    r14,rax
  4086cd:	b9 01 00 00 00       	mov    ecx,0x1
  4086d2:	01 c9                	add    ecx,ecx
  4086d4:	b8 03 00 00 00       	mov    eax,0x3
  4086d9:	d3 e0                	shl    eax,cl
  4086db:	f7 d0                	not    eax
  4086dd:	83 e0 fc             	and    eax,0xfffffffc
  4086e0:	48 31 c9             	xor    rcx,rcx
  4086e3:	48 31 d2             	xor    rdx,rdx
  4086e6:	0f 01 ef             	wrpkru 
  4086e9:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4086ec:	48 c1 e2 04          	shl    rdx,0x4
  4086f0:	4c 01 f2             	add    rdx,r14
  4086f3:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  4086f7:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4086fa:	48 83 e8 01          	sub    rax,0x1
  4086fe:	49 89 06             	mov    QWORD PTR [r14],rax
  408701:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  408706:	01 c9                	add    ecx,ecx
  408708:	b8 03 00 00 00       	mov    eax,0x3
  40870d:	d3 e0                	shl    eax,cl
  40870f:	f7 d0                	not    eax
  408711:	83 e0 fc             	and    eax,0xfffffffc
  408714:	48 31 c9             	xor    rcx,rcx
  408717:	48 31 d2             	xor    rdx,rdx
  40871a:	0f 01 ef             	wrpkru 
  40871d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408724:	be ad de 
  408727:	49 39 c7             	cmp    r15,rax
  40872a:	4c 89 c0             	mov    rax,r8
  40872d:	41 5f                	pop    r15
  40872f:	41 5e                	pop    r14
  408731:	41 5d                	pop    r13
  408733:	5d                   	pop    rbp
  408734:	c3                   	ret    
  408735:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40873c:	00 00 00 00 

0000000000408740 <__cosrt_extern_capmgr_asnd_create>:
  408740:	48 b8 bc 01 46 00 00 	movabs rax,0x4601bc
  408747:	00 00 00 
  40874a:	ff 10                	call   QWORD PTR [rax]
  40874c:	c3                   	ret    
  40874d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000408750 <__cosrt_fast_callgate_capmgr_asnd_create>:
  408750:	55                   	push   rbp
  408751:	41 55                	push   r13
  408753:	41 56                	push   r14
  408755:	41 57                	push   r15
  408757:	49 89 c8             	mov    r8,rcx
  40875a:	49 89 d1             	mov    r9,rdx
  40875d:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  408764:	be ad de 
  408767:	0f 01 f9             	rdtscp 
  40876a:	48 89 c8             	mov    rax,rcx
  40876d:	48 25 ff 0f 00 00    	and    rax,0xfff
  408773:	48 89 e2             	mov    rdx,rsp
  408776:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40877d:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  408784:	00 
  408785:	48 c1 e0 10          	shl    rax,0x10
  408789:	49 09 c5             	or     r13,rax
  40878c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  408793:	7f 00 00 
  408796:	4c 89 e8             	mov    rax,r13
  408799:	48 25 ff ff 00 00    	and    rax,0xffff
  40879f:	48 c1 e0 08          	shl    rax,0x8
  4087a3:	49 01 c6             	add    r14,rax
  4087a6:	b9 01 00 00 00       	mov    ecx,0x1
  4087ab:	01 c9                	add    ecx,ecx
  4087ad:	b8 03 00 00 00       	mov    eax,0x3
  4087b2:	d3 e0                	shl    eax,cl
  4087b4:	f7 d0                	not    eax
  4087b6:	83 e0 fc             	and    eax,0xfffffffc
  4087b9:	48 31 c9             	xor    rcx,rcx
  4087bc:	48 31 d2             	xor    rdx,rdx
  4087bf:	0f 01 ef             	wrpkru 
  4087c2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4087c5:	48 83 c2 01          	add    rdx,0x1
  4087c9:	48 c1 e2 04          	shl    rdx,0x4
  4087cd:	4c 01 f2             	add    rdx,r14
  4087d0:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  4087d7:	45 23 01 
  4087da:	48 89 02             	mov    QWORD PTR [rdx],rax
  4087dd:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  4087e1:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4087e4:	48 83 c0 01          	add    rax,0x1
  4087e8:	49 89 06             	mov    QWORD PTR [r14],rax
  4087eb:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4087f0:	01 c9                	add    ecx,ecx
  4087f2:	b8 03 00 00 00       	mov    eax,0x3
  4087f7:	d3 e0                	shl    eax,cl
  4087f9:	f7 d0                	not    eax
  4087fb:	83 e0 fc             	and    eax,0xfffffffc
  4087fe:	48 31 c9             	xor    rcx,rcx
  408801:	48 31 d2             	xor    rdx,rdx
  408804:	0f 01 ef             	wrpkru 
  408807:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  40880e:	45 23 01 
  408811:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408818:	be ad de 
  40881b:	49 39 c7             	cmp    r15,rax
  40881e:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  408825:	12 12 12 
  408828:	48 b9 34 88 40 00 00 	movabs rcx,0x408834
  40882f:	00 00 00 
  408832:	ff e0                	jmp    rax

0000000000408834 <srv_call_ret_capmgr_asnd_create>:
  408834:	49 89 c0             	mov    r8,rax
  408837:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40883e:	be ad de 
  408841:	48 89 e2             	mov    rdx,rsp
  408844:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40884b:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  408852:	00 
  408853:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40885a:	7f 00 00 
  40885d:	4c 89 e8             	mov    rax,r13
  408860:	48 25 ff ff 00 00    	and    rax,0xffff
  408866:	48 c1 e0 08          	shl    rax,0x8
  40886a:	49 01 c6             	add    r14,rax
  40886d:	b9 01 00 00 00       	mov    ecx,0x1
  408872:	01 c9                	add    ecx,ecx
  408874:	b8 03 00 00 00       	mov    eax,0x3
  408879:	d3 e0                	shl    eax,cl
  40887b:	f7 d0                	not    eax
  40887d:	83 e0 fc             	and    eax,0xfffffffc
  408880:	48 31 c9             	xor    rcx,rcx
  408883:	48 31 d2             	xor    rdx,rdx
  408886:	0f 01 ef             	wrpkru 
  408889:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40888c:	48 c1 e2 04          	shl    rdx,0x4
  408890:	4c 01 f2             	add    rdx,r14
  408893:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  408897:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40889a:	48 83 e8 01          	sub    rax,0x1
  40889e:	49 89 06             	mov    QWORD PTR [r14],rax
  4088a1:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4088a6:	01 c9                	add    ecx,ecx
  4088a8:	b8 03 00 00 00       	mov    eax,0x3
  4088ad:	d3 e0                	shl    eax,cl
  4088af:	f7 d0                	not    eax
  4088b1:	83 e0 fc             	and    eax,0xfffffffc
  4088b4:	48 31 c9             	xor    rcx,rcx
  4088b7:	48 31 d2             	xor    rdx,rdx
  4088ba:	0f 01 ef             	wrpkru 
  4088bd:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4088c4:	be ad de 
  4088c7:	49 39 c7             	cmp    r15,rax
  4088ca:	4c 89 c0             	mov    rax,r8
  4088cd:	41 5f                	pop    r15
  4088cf:	41 5e                	pop    r14
  4088d1:	41 5d                	pop    r13
  4088d3:	5d                   	pop    rbp
  4088d4:	c3                   	ret    
  4088d5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4088dc:	00 00 00 00 

00000000004088e0 <__cosrt_extern_capmgr_asnd_rcv_create>:
  4088e0:	48 b8 d4 01 46 00 00 	movabs rax,0x4601d4
  4088e7:	00 00 00 
  4088ea:	ff 10                	call   QWORD PTR [rax]
  4088ec:	c3                   	ret    
  4088ed:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004088f0 <__cosrt_fast_callgate_capmgr_asnd_rcv_create>:
  4088f0:	55                   	push   rbp
  4088f1:	41 55                	push   r13
  4088f3:	41 56                	push   r14
  4088f5:	41 57                	push   r15
  4088f7:	49 89 c8             	mov    r8,rcx
  4088fa:	49 89 d1             	mov    r9,rdx
  4088fd:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  408904:	be ad de 
  408907:	0f 01 f9             	rdtscp 
  40890a:	48 89 c8             	mov    rax,rcx
  40890d:	48 25 ff 0f 00 00    	and    rax,0xfff
  408913:	48 89 e2             	mov    rdx,rsp
  408916:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40891d:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  408924:	00 
  408925:	48 c1 e0 10          	shl    rax,0x10
  408929:	49 09 c5             	or     r13,rax
  40892c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  408933:	7f 00 00 
  408936:	4c 89 e8             	mov    rax,r13
  408939:	48 25 ff ff 00 00    	and    rax,0xffff
  40893f:	48 c1 e0 08          	shl    rax,0x8
  408943:	49 01 c6             	add    r14,rax
  408946:	b9 01 00 00 00       	mov    ecx,0x1
  40894b:	01 c9                	add    ecx,ecx
  40894d:	b8 03 00 00 00       	mov    eax,0x3
  408952:	d3 e0                	shl    eax,cl
  408954:	f7 d0                	not    eax
  408956:	83 e0 fc             	and    eax,0xfffffffc
  408959:	48 31 c9             	xor    rcx,rcx
  40895c:	48 31 d2             	xor    rdx,rdx
  40895f:	0f 01 ef             	wrpkru 
  408962:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  408965:	48 83 c2 01          	add    rdx,0x1
  408969:	48 c1 e2 04          	shl    rdx,0x4
  40896d:	4c 01 f2             	add    rdx,r14
  408970:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  408977:	45 23 01 
  40897a:	48 89 02             	mov    QWORD PTR [rdx],rax
  40897d:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  408981:	49 8b 06             	mov    rax,QWORD PTR [r14]
  408984:	48 83 c0 01          	add    rax,0x1
  408988:	49 89 06             	mov    QWORD PTR [r14],rax
  40898b:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  408990:	01 c9                	add    ecx,ecx
  408992:	b8 03 00 00 00       	mov    eax,0x3
  408997:	d3 e0                	shl    eax,cl
  408999:	f7 d0                	not    eax
  40899b:	83 e0 fc             	and    eax,0xfffffffc
  40899e:	48 31 c9             	xor    rcx,rcx
  4089a1:	48 31 d2             	xor    rdx,rdx
  4089a4:	0f 01 ef             	wrpkru 
  4089a7:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  4089ae:	45 23 01 
  4089b1:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4089b8:	be ad de 
  4089bb:	49 39 c7             	cmp    r15,rax
  4089be:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  4089c5:	12 12 12 
  4089c8:	48 b9 d4 89 40 00 00 	movabs rcx,0x4089d4
  4089cf:	00 00 00 
  4089d2:	ff e0                	jmp    rax

00000000004089d4 <srv_call_ret_capmgr_asnd_rcv_create>:
  4089d4:	49 89 c0             	mov    r8,rax
  4089d7:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4089de:	be ad de 
  4089e1:	48 89 e2             	mov    rdx,rsp
  4089e4:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4089eb:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4089f2:	00 
  4089f3:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4089fa:	7f 00 00 
  4089fd:	4c 89 e8             	mov    rax,r13
  408a00:	48 25 ff ff 00 00    	and    rax,0xffff
  408a06:	48 c1 e0 08          	shl    rax,0x8
  408a0a:	49 01 c6             	add    r14,rax
  408a0d:	b9 01 00 00 00       	mov    ecx,0x1
  408a12:	01 c9                	add    ecx,ecx
  408a14:	b8 03 00 00 00       	mov    eax,0x3
  408a19:	d3 e0                	shl    eax,cl
  408a1b:	f7 d0                	not    eax
  408a1d:	83 e0 fc             	and    eax,0xfffffffc
  408a20:	48 31 c9             	xor    rcx,rcx
  408a23:	48 31 d2             	xor    rdx,rdx
  408a26:	0f 01 ef             	wrpkru 
  408a29:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  408a2c:	48 c1 e2 04          	shl    rdx,0x4
  408a30:	4c 01 f2             	add    rdx,r14
  408a33:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  408a37:	49 8b 06             	mov    rax,QWORD PTR [r14]
  408a3a:	48 83 e8 01          	sub    rax,0x1
  408a3e:	49 89 06             	mov    QWORD PTR [r14],rax
  408a41:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  408a46:	01 c9                	add    ecx,ecx
  408a48:	b8 03 00 00 00       	mov    eax,0x3
  408a4d:	d3 e0                	shl    eax,cl
  408a4f:	f7 d0                	not    eax
  408a51:	83 e0 fc             	and    eax,0xfffffffc
  408a54:	48 31 c9             	xor    rcx,rcx
  408a57:	48 31 d2             	xor    rdx,rdx
  408a5a:	0f 01 ef             	wrpkru 
  408a5d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408a64:	be ad de 
  408a67:	49 39 c7             	cmp    r15,rax
  408a6a:	4c 89 c0             	mov    rax,r8
  408a6d:	41 5f                	pop    r15
  408a6f:	41 5e                	pop    r14
  408a71:	41 5d                	pop    r13
  408a73:	5d                   	pop    rbp
  408a74:	c3                   	ret    
  408a75:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  408a7c:	00 00 00 00 

0000000000408a80 <__cosrt_extern_capmgr_asnd_key_create>:
  408a80:	48 b8 ec 01 46 00 00 	movabs rax,0x4601ec
  408a87:	00 00 00 
  408a8a:	ff 10                	call   QWORD PTR [rax]
  408a8c:	c3                   	ret    
  408a8d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000408a90 <__cosrt_fast_callgate_capmgr_asnd_key_create>:
  408a90:	55                   	push   rbp
  408a91:	41 55                	push   r13
  408a93:	41 56                	push   r14
  408a95:	41 57                	push   r15
  408a97:	49 89 c8             	mov    r8,rcx
  408a9a:	49 89 d1             	mov    r9,rdx
  408a9d:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  408aa4:	be ad de 
  408aa7:	0f 01 f9             	rdtscp 
  408aaa:	48 89 c8             	mov    rax,rcx
  408aad:	48 25 ff 0f 00 00    	and    rax,0xfff
  408ab3:	48 89 e2             	mov    rdx,rsp
  408ab6:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  408abd:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  408ac4:	00 
  408ac5:	48 c1 e0 10          	shl    rax,0x10
  408ac9:	49 09 c5             	or     r13,rax
  408acc:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  408ad3:	7f 00 00 
  408ad6:	4c 89 e8             	mov    rax,r13
  408ad9:	48 25 ff ff 00 00    	and    rax,0xffff
  408adf:	48 c1 e0 08          	shl    rax,0x8
  408ae3:	49 01 c6             	add    r14,rax
  408ae6:	b9 01 00 00 00       	mov    ecx,0x1
  408aeb:	01 c9                	add    ecx,ecx
  408aed:	b8 03 00 00 00       	mov    eax,0x3
  408af2:	d3 e0                	shl    eax,cl
  408af4:	f7 d0                	not    eax
  408af6:	83 e0 fc             	and    eax,0xfffffffc
  408af9:	48 31 c9             	xor    rcx,rcx
  408afc:	48 31 d2             	xor    rdx,rdx
  408aff:	0f 01 ef             	wrpkru 
  408b02:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  408b05:	48 83 c2 01          	add    rdx,0x1
  408b09:	48 c1 e2 04          	shl    rdx,0x4
  408b0d:	4c 01 f2             	add    rdx,r14
  408b10:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  408b17:	45 23 01 
  408b1a:	48 89 02             	mov    QWORD PTR [rdx],rax
  408b1d:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  408b21:	49 8b 06             	mov    rax,QWORD PTR [r14]
  408b24:	48 83 c0 01          	add    rax,0x1
  408b28:	49 89 06             	mov    QWORD PTR [r14],rax
  408b2b:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  408b30:	01 c9                	add    ecx,ecx
  408b32:	b8 03 00 00 00       	mov    eax,0x3
  408b37:	d3 e0                	shl    eax,cl
  408b39:	f7 d0                	not    eax
  408b3b:	83 e0 fc             	and    eax,0xfffffffc
  408b3e:	48 31 c9             	xor    rcx,rcx
  408b41:	48 31 d2             	xor    rdx,rdx
  408b44:	0f 01 ef             	wrpkru 
  408b47:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  408b4e:	45 23 01 
  408b51:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408b58:	be ad de 
  408b5b:	49 39 c7             	cmp    r15,rax
  408b5e:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  408b65:	12 12 12 
  408b68:	48 b9 74 8b 40 00 00 	movabs rcx,0x408b74
  408b6f:	00 00 00 
  408b72:	ff e0                	jmp    rax

0000000000408b74 <srv_call_ret_capmgr_asnd_key_create>:
  408b74:	49 89 c0             	mov    r8,rax
  408b77:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  408b7e:	be ad de 
  408b81:	48 89 e2             	mov    rdx,rsp
  408b84:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  408b8b:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  408b92:	00 
  408b93:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  408b9a:	7f 00 00 
  408b9d:	4c 89 e8             	mov    rax,r13
  408ba0:	48 25 ff ff 00 00    	and    rax,0xffff
  408ba6:	48 c1 e0 08          	shl    rax,0x8
  408baa:	49 01 c6             	add    r14,rax
  408bad:	b9 01 00 00 00       	mov    ecx,0x1
  408bb2:	01 c9                	add    ecx,ecx
  408bb4:	b8 03 00 00 00       	mov    eax,0x3
  408bb9:	d3 e0                	shl    eax,cl
  408bbb:	f7 d0                	not    eax
  408bbd:	83 e0 fc             	and    eax,0xfffffffc
  408bc0:	48 31 c9             	xor    rcx,rcx
  408bc3:	48 31 d2             	xor    rdx,rdx
  408bc6:	0f 01 ef             	wrpkru 
  408bc9:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  408bcc:	48 c1 e2 04          	shl    rdx,0x4
  408bd0:	4c 01 f2             	add    rdx,r14
  408bd3:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  408bd7:	49 8b 06             	mov    rax,QWORD PTR [r14]
  408bda:	48 83 e8 01          	sub    rax,0x1
  408bde:	49 89 06             	mov    QWORD PTR [r14],rax
  408be1:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  408be6:	01 c9                	add    ecx,ecx
  408be8:	b8 03 00 00 00       	mov    eax,0x3
  408bed:	d3 e0                	shl    eax,cl
  408bef:	f7 d0                	not    eax
  408bf1:	83 e0 fc             	and    eax,0xfffffffc
  408bf4:	48 31 c9             	xor    rcx,rcx
  408bf7:	48 31 d2             	xor    rdx,rdx
  408bfa:	0f 01 ef             	wrpkru 
  408bfd:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408c04:	be ad de 
  408c07:	49 39 c7             	cmp    r15,rax
  408c0a:	4c 89 c0             	mov    rax,r8
  408c0d:	41 5f                	pop    r15
  408c0f:	41 5e                	pop    r14
  408c11:	41 5d                	pop    r13
  408c13:	5d                   	pop    rbp
  408c14:	c3                   	ret    
  408c15:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  408c1c:	00 00 00 00 

0000000000408c20 <__cosrt_extern_capmgr_vm_comp_create>:
  408c20:	48 b8 04 02 46 00 00 	movabs rax,0x460204
  408c27:	00 00 00 
  408c2a:	ff 10                	call   QWORD PTR [rax]
  408c2c:	c3                   	ret    
  408c2d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000408c30 <__cosrt_fast_callgate_capmgr_vm_comp_create>:
  408c30:	55                   	push   rbp
  408c31:	41 55                	push   r13
  408c33:	41 56                	push   r14
  408c35:	41 57                	push   r15
  408c37:	49 89 c8             	mov    r8,rcx
  408c3a:	49 89 d1             	mov    r9,rdx
  408c3d:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  408c44:	be ad de 
  408c47:	0f 01 f9             	rdtscp 
  408c4a:	48 89 c8             	mov    rax,rcx
  408c4d:	48 25 ff 0f 00 00    	and    rax,0xfff
  408c53:	48 89 e2             	mov    rdx,rsp
  408c56:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  408c5d:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  408c64:	00 
  408c65:	48 c1 e0 10          	shl    rax,0x10
  408c69:	49 09 c5             	or     r13,rax
  408c6c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  408c73:	7f 00 00 
  408c76:	4c 89 e8             	mov    rax,r13
  408c79:	48 25 ff ff 00 00    	and    rax,0xffff
  408c7f:	48 c1 e0 08          	shl    rax,0x8
  408c83:	49 01 c6             	add    r14,rax
  408c86:	b9 01 00 00 00       	mov    ecx,0x1
  408c8b:	01 c9                	add    ecx,ecx
  408c8d:	b8 03 00 00 00       	mov    eax,0x3
  408c92:	d3 e0                	shl    eax,cl
  408c94:	f7 d0                	not    eax
  408c96:	83 e0 fc             	and    eax,0xfffffffc
  408c99:	48 31 c9             	xor    rcx,rcx
  408c9c:	48 31 d2             	xor    rdx,rdx
  408c9f:	0f 01 ef             	wrpkru 
  408ca2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  408ca5:	48 83 c2 01          	add    rdx,0x1
  408ca9:	48 c1 e2 04          	shl    rdx,0x4
  408cad:	4c 01 f2             	add    rdx,r14
  408cb0:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  408cb7:	45 23 01 
  408cba:	48 89 02             	mov    QWORD PTR [rdx],rax
  408cbd:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  408cc1:	49 8b 06             	mov    rax,QWORD PTR [r14]
  408cc4:	48 83 c0 01          	add    rax,0x1
  408cc8:	49 89 06             	mov    QWORD PTR [r14],rax
  408ccb:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  408cd0:	01 c9                	add    ecx,ecx
  408cd2:	b8 03 00 00 00       	mov    eax,0x3
  408cd7:	d3 e0                	shl    eax,cl
  408cd9:	f7 d0                	not    eax
  408cdb:	83 e0 fc             	and    eax,0xfffffffc
  408cde:	48 31 c9             	xor    rcx,rcx
  408ce1:	48 31 d2             	xor    rdx,rdx
  408ce4:	0f 01 ef             	wrpkru 
  408ce7:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  408cee:	45 23 01 
  408cf1:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408cf8:	be ad de 
  408cfb:	49 39 c7             	cmp    r15,rax
  408cfe:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  408d05:	12 12 12 
  408d08:	48 b9 14 8d 40 00 00 	movabs rcx,0x408d14
  408d0f:	00 00 00 
  408d12:	ff e0                	jmp    rax

0000000000408d14 <srv_call_ret_capmgr_vm_comp_create>:
  408d14:	49 89 c0             	mov    r8,rax
  408d17:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  408d1e:	be ad de 
  408d21:	48 89 e2             	mov    rdx,rsp
  408d24:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  408d2b:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  408d32:	00 
  408d33:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  408d3a:	7f 00 00 
  408d3d:	4c 89 e8             	mov    rax,r13
  408d40:	48 25 ff ff 00 00    	and    rax,0xffff
  408d46:	48 c1 e0 08          	shl    rax,0x8
  408d4a:	49 01 c6             	add    r14,rax
  408d4d:	b9 01 00 00 00       	mov    ecx,0x1
  408d52:	01 c9                	add    ecx,ecx
  408d54:	b8 03 00 00 00       	mov    eax,0x3
  408d59:	d3 e0                	shl    eax,cl
  408d5b:	f7 d0                	not    eax
  408d5d:	83 e0 fc             	and    eax,0xfffffffc
  408d60:	48 31 c9             	xor    rcx,rcx
  408d63:	48 31 d2             	xor    rdx,rdx
  408d66:	0f 01 ef             	wrpkru 
  408d69:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  408d6c:	48 c1 e2 04          	shl    rdx,0x4
  408d70:	4c 01 f2             	add    rdx,r14
  408d73:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  408d77:	49 8b 06             	mov    rax,QWORD PTR [r14]
  408d7a:	48 83 e8 01          	sub    rax,0x1
  408d7e:	49 89 06             	mov    QWORD PTR [r14],rax
  408d81:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  408d86:	01 c9                	add    ecx,ecx
  408d88:	b8 03 00 00 00       	mov    eax,0x3
  408d8d:	d3 e0                	shl    eax,cl
  408d8f:	f7 d0                	not    eax
  408d91:	83 e0 fc             	and    eax,0xfffffffc
  408d94:	48 31 c9             	xor    rcx,rcx
  408d97:	48 31 d2             	xor    rdx,rdx
  408d9a:	0f 01 ef             	wrpkru 
  408d9d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408da4:	be ad de 
  408da7:	49 39 c7             	cmp    r15,rax
  408daa:	4c 89 c0             	mov    rax,r8
  408dad:	41 5f                	pop    r15
  408daf:	41 5e                	pop    r14
  408db1:	41 5d                	pop    r13
  408db3:	5d                   	pop    rbp
  408db4:	c3                   	ret    
  408db5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  408dbc:	00 00 00 00 

0000000000408dc0 <__cosrt_extern_capmgr_vm_shared_kernel_page_create_at>:
  408dc0:	48 b8 1c 02 46 00 00 	movabs rax,0x46021c
  408dc7:	00 00 00 
  408dca:	ff 10                	call   QWORD PTR [rax]
  408dcc:	c3                   	ret    
  408dcd:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000408dd0 <__cosrt_fast_callgate_capmgr_vm_shared_kernel_page_create_at>:
  408dd0:	55                   	push   rbp
  408dd1:	41 55                	push   r13
  408dd3:	41 56                	push   r14
  408dd5:	41 57                	push   r15
  408dd7:	49 89 c8             	mov    r8,rcx
  408dda:	49 89 d1             	mov    r9,rdx
  408ddd:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  408de4:	be ad de 
  408de7:	0f 01 f9             	rdtscp 
  408dea:	48 89 c8             	mov    rax,rcx
  408ded:	48 25 ff 0f 00 00    	and    rax,0xfff
  408df3:	48 89 e2             	mov    rdx,rsp
  408df6:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  408dfd:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  408e04:	00 
  408e05:	48 c1 e0 10          	shl    rax,0x10
  408e09:	49 09 c5             	or     r13,rax
  408e0c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  408e13:	7f 00 00 
  408e16:	4c 89 e8             	mov    rax,r13
  408e19:	48 25 ff ff 00 00    	and    rax,0xffff
  408e1f:	48 c1 e0 08          	shl    rax,0x8
  408e23:	49 01 c6             	add    r14,rax
  408e26:	b9 01 00 00 00       	mov    ecx,0x1
  408e2b:	01 c9                	add    ecx,ecx
  408e2d:	b8 03 00 00 00       	mov    eax,0x3
  408e32:	d3 e0                	shl    eax,cl
  408e34:	f7 d0                	not    eax
  408e36:	83 e0 fc             	and    eax,0xfffffffc
  408e39:	48 31 c9             	xor    rcx,rcx
  408e3c:	48 31 d2             	xor    rdx,rdx
  408e3f:	0f 01 ef             	wrpkru 
  408e42:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  408e45:	48 83 c2 01          	add    rdx,0x1
  408e49:	48 c1 e2 04          	shl    rdx,0x4
  408e4d:	4c 01 f2             	add    rdx,r14
  408e50:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  408e57:	45 23 01 
  408e5a:	48 89 02             	mov    QWORD PTR [rdx],rax
  408e5d:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  408e61:	49 8b 06             	mov    rax,QWORD PTR [r14]
  408e64:	48 83 c0 01          	add    rax,0x1
  408e68:	49 89 06             	mov    QWORD PTR [r14],rax
  408e6b:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  408e70:	01 c9                	add    ecx,ecx
  408e72:	b8 03 00 00 00       	mov    eax,0x3
  408e77:	d3 e0                	shl    eax,cl
  408e79:	f7 d0                	not    eax
  408e7b:	83 e0 fc             	and    eax,0xfffffffc
  408e7e:	48 31 c9             	xor    rcx,rcx
  408e81:	48 31 d2             	xor    rdx,rdx
  408e84:	0f 01 ef             	wrpkru 
  408e87:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  408e8e:	45 23 01 
  408e91:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408e98:	be ad de 
  408e9b:	49 39 c7             	cmp    r15,rax
  408e9e:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  408ea5:	12 12 12 
  408ea8:	48 b9 b4 8e 40 00 00 	movabs rcx,0x408eb4
  408eaf:	00 00 00 
  408eb2:	ff e0                	jmp    rax

0000000000408eb4 <srv_call_ret_capmgr_vm_shared_kernel_page_create_at>:
  408eb4:	49 89 c0             	mov    r8,rax
  408eb7:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  408ebe:	be ad de 
  408ec1:	48 89 e2             	mov    rdx,rsp
  408ec4:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  408ecb:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  408ed2:	00 
  408ed3:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  408eda:	7f 00 00 
  408edd:	4c 89 e8             	mov    rax,r13
  408ee0:	48 25 ff ff 00 00    	and    rax,0xffff
  408ee6:	48 c1 e0 08          	shl    rax,0x8
  408eea:	49 01 c6             	add    r14,rax
  408eed:	b9 01 00 00 00       	mov    ecx,0x1
  408ef2:	01 c9                	add    ecx,ecx
  408ef4:	b8 03 00 00 00       	mov    eax,0x3
  408ef9:	d3 e0                	shl    eax,cl
  408efb:	f7 d0                	not    eax
  408efd:	83 e0 fc             	and    eax,0xfffffffc
  408f00:	48 31 c9             	xor    rcx,rcx
  408f03:	48 31 d2             	xor    rdx,rdx
  408f06:	0f 01 ef             	wrpkru 
  408f09:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  408f0c:	48 c1 e2 04          	shl    rdx,0x4
  408f10:	4c 01 f2             	add    rdx,r14
  408f13:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  408f17:	49 8b 06             	mov    rax,QWORD PTR [r14]
  408f1a:	48 83 e8 01          	sub    rax,0x1
  408f1e:	49 89 06             	mov    QWORD PTR [r14],rax
  408f21:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  408f26:	01 c9                	add    ecx,ecx
  408f28:	b8 03 00 00 00       	mov    eax,0x3
  408f2d:	d3 e0                	shl    eax,cl
  408f2f:	f7 d0                	not    eax
  408f31:	83 e0 fc             	and    eax,0xfffffffc
  408f34:	48 31 c9             	xor    rcx,rcx
  408f37:	48 31 d2             	xor    rdx,rdx
  408f3a:	0f 01 ef             	wrpkru 
  408f3d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408f44:	be ad de 
  408f47:	49 39 c7             	cmp    r15,rax
  408f4a:	4c 89 c0             	mov    rax,r8
  408f4d:	41 5f                	pop    r15
  408f4f:	41 5e                	pop    r14
  408f51:	41 5d                	pop    r13
  408f53:	5d                   	pop    rbp
  408f54:	c3                   	ret    
  408f55:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  408f5c:	00 00 00 00 

0000000000408f60 <__cosrt_extern_capmgr_vm_vmcs_create>:
  408f60:	48 b8 34 02 46 00 00 	movabs rax,0x460234
  408f67:	00 00 00 
  408f6a:	ff 10                	call   QWORD PTR [rax]
  408f6c:	c3                   	ret    
  408f6d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000408f70 <__cosrt_fast_callgate_capmgr_vm_vmcs_create>:
  408f70:	55                   	push   rbp
  408f71:	41 55                	push   r13
  408f73:	41 56                	push   r14
  408f75:	41 57                	push   r15
  408f77:	49 89 c8             	mov    r8,rcx
  408f7a:	49 89 d1             	mov    r9,rdx
  408f7d:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  408f84:	be ad de 
  408f87:	0f 01 f9             	rdtscp 
  408f8a:	48 89 c8             	mov    rax,rcx
  408f8d:	48 25 ff 0f 00 00    	and    rax,0xfff
  408f93:	48 89 e2             	mov    rdx,rsp
  408f96:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  408f9d:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  408fa4:	00 
  408fa5:	48 c1 e0 10          	shl    rax,0x10
  408fa9:	49 09 c5             	or     r13,rax
  408fac:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  408fb3:	7f 00 00 
  408fb6:	4c 89 e8             	mov    rax,r13
  408fb9:	48 25 ff ff 00 00    	and    rax,0xffff
  408fbf:	48 c1 e0 08          	shl    rax,0x8
  408fc3:	49 01 c6             	add    r14,rax
  408fc6:	b9 01 00 00 00       	mov    ecx,0x1
  408fcb:	01 c9                	add    ecx,ecx
  408fcd:	b8 03 00 00 00       	mov    eax,0x3
  408fd2:	d3 e0                	shl    eax,cl
  408fd4:	f7 d0                	not    eax
  408fd6:	83 e0 fc             	and    eax,0xfffffffc
  408fd9:	48 31 c9             	xor    rcx,rcx
  408fdc:	48 31 d2             	xor    rdx,rdx
  408fdf:	0f 01 ef             	wrpkru 
  408fe2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  408fe5:	48 83 c2 01          	add    rdx,0x1
  408fe9:	48 c1 e2 04          	shl    rdx,0x4
  408fed:	4c 01 f2             	add    rdx,r14
  408ff0:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  408ff7:	45 23 01 
  408ffa:	48 89 02             	mov    QWORD PTR [rdx],rax
  408ffd:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  409001:	49 8b 06             	mov    rax,QWORD PTR [r14]
  409004:	48 83 c0 01          	add    rax,0x1
  409008:	49 89 06             	mov    QWORD PTR [r14],rax
  40900b:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  409010:	01 c9                	add    ecx,ecx
  409012:	b8 03 00 00 00       	mov    eax,0x3
  409017:	d3 e0                	shl    eax,cl
  409019:	f7 d0                	not    eax
  40901b:	83 e0 fc             	and    eax,0xfffffffc
  40901e:	48 31 c9             	xor    rcx,rcx
  409021:	48 31 d2             	xor    rdx,rdx
  409024:	0f 01 ef             	wrpkru 
  409027:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  40902e:	45 23 01 
  409031:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409038:	be ad de 
  40903b:	49 39 c7             	cmp    r15,rax
  40903e:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  409045:	12 12 12 
  409048:	48 b9 54 90 40 00 00 	movabs rcx,0x409054
  40904f:	00 00 00 
  409052:	ff e0                	jmp    rax

0000000000409054 <srv_call_ret_capmgr_vm_vmcs_create>:
  409054:	49 89 c0             	mov    r8,rax
  409057:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40905e:	be ad de 
  409061:	48 89 e2             	mov    rdx,rsp
  409064:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40906b:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  409072:	00 
  409073:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40907a:	7f 00 00 
  40907d:	4c 89 e8             	mov    rax,r13
  409080:	48 25 ff ff 00 00    	and    rax,0xffff
  409086:	48 c1 e0 08          	shl    rax,0x8
  40908a:	49 01 c6             	add    r14,rax
  40908d:	b9 01 00 00 00       	mov    ecx,0x1
  409092:	01 c9                	add    ecx,ecx
  409094:	b8 03 00 00 00       	mov    eax,0x3
  409099:	d3 e0                	shl    eax,cl
  40909b:	f7 d0                	not    eax
  40909d:	83 e0 fc             	and    eax,0xfffffffc
  4090a0:	48 31 c9             	xor    rcx,rcx
  4090a3:	48 31 d2             	xor    rdx,rdx
  4090a6:	0f 01 ef             	wrpkru 
  4090a9:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4090ac:	48 c1 e2 04          	shl    rdx,0x4
  4090b0:	4c 01 f2             	add    rdx,r14
  4090b3:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  4090b7:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4090ba:	48 83 e8 01          	sub    rax,0x1
  4090be:	49 89 06             	mov    QWORD PTR [r14],rax
  4090c1:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4090c6:	01 c9                	add    ecx,ecx
  4090c8:	b8 03 00 00 00       	mov    eax,0x3
  4090cd:	d3 e0                	shl    eax,cl
  4090cf:	f7 d0                	not    eax
  4090d1:	83 e0 fc             	and    eax,0xfffffffc
  4090d4:	48 31 c9             	xor    rcx,rcx
  4090d7:	48 31 d2             	xor    rdx,rdx
  4090da:	0f 01 ef             	wrpkru 
  4090dd:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4090e4:	be ad de 
  4090e7:	49 39 c7             	cmp    r15,rax
  4090ea:	4c 89 c0             	mov    rax,r8
  4090ed:	41 5f                	pop    r15
  4090ef:	41 5e                	pop    r14
  4090f1:	41 5d                	pop    r13
  4090f3:	5d                   	pop    rbp
  4090f4:	c3                   	ret    
  4090f5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4090fc:	00 00 00 00 

0000000000409100 <__cosrt_extern_capmgr_vm_msr_bitmap_create>:
  409100:	48 b8 4c 02 46 00 00 	movabs rax,0x46024c
  409107:	00 00 00 
  40910a:	ff 10                	call   QWORD PTR [rax]
  40910c:	c3                   	ret    
  40910d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000409110 <__cosrt_fast_callgate_capmgr_vm_msr_bitmap_create>:
  409110:	55                   	push   rbp
  409111:	41 55                	push   r13
  409113:	41 56                	push   r14
  409115:	41 57                	push   r15
  409117:	49 89 c8             	mov    r8,rcx
  40911a:	49 89 d1             	mov    r9,rdx
  40911d:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  409124:	be ad de 
  409127:	0f 01 f9             	rdtscp 
  40912a:	48 89 c8             	mov    rax,rcx
  40912d:	48 25 ff 0f 00 00    	and    rax,0xfff
  409133:	48 89 e2             	mov    rdx,rsp
  409136:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40913d:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  409144:	00 
  409145:	48 c1 e0 10          	shl    rax,0x10
  409149:	49 09 c5             	or     r13,rax
  40914c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  409153:	7f 00 00 
  409156:	4c 89 e8             	mov    rax,r13
  409159:	48 25 ff ff 00 00    	and    rax,0xffff
  40915f:	48 c1 e0 08          	shl    rax,0x8
  409163:	49 01 c6             	add    r14,rax
  409166:	b9 01 00 00 00       	mov    ecx,0x1
  40916b:	01 c9                	add    ecx,ecx
  40916d:	b8 03 00 00 00       	mov    eax,0x3
  409172:	d3 e0                	shl    eax,cl
  409174:	f7 d0                	not    eax
  409176:	83 e0 fc             	and    eax,0xfffffffc
  409179:	48 31 c9             	xor    rcx,rcx
  40917c:	48 31 d2             	xor    rdx,rdx
  40917f:	0f 01 ef             	wrpkru 
  409182:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  409185:	48 83 c2 01          	add    rdx,0x1
  409189:	48 c1 e2 04          	shl    rdx,0x4
  40918d:	4c 01 f2             	add    rdx,r14
  409190:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  409197:	45 23 01 
  40919a:	48 89 02             	mov    QWORD PTR [rdx],rax
  40919d:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  4091a1:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4091a4:	48 83 c0 01          	add    rax,0x1
  4091a8:	49 89 06             	mov    QWORD PTR [r14],rax
  4091ab:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4091b0:	01 c9                	add    ecx,ecx
  4091b2:	b8 03 00 00 00       	mov    eax,0x3
  4091b7:	d3 e0                	shl    eax,cl
  4091b9:	f7 d0                	not    eax
  4091bb:	83 e0 fc             	and    eax,0xfffffffc
  4091be:	48 31 c9             	xor    rcx,rcx
  4091c1:	48 31 d2             	xor    rdx,rdx
  4091c4:	0f 01 ef             	wrpkru 
  4091c7:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  4091ce:	45 23 01 
  4091d1:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4091d8:	be ad de 
  4091db:	49 39 c7             	cmp    r15,rax
  4091de:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  4091e5:	12 12 12 
  4091e8:	48 b9 f4 91 40 00 00 	movabs rcx,0x4091f4
  4091ef:	00 00 00 
  4091f2:	ff e0                	jmp    rax

00000000004091f4 <srv_call_ret_capmgr_vm_msr_bitmap_create>:
  4091f4:	49 89 c0             	mov    r8,rax
  4091f7:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4091fe:	be ad de 
  409201:	48 89 e2             	mov    rdx,rsp
  409204:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40920b:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  409212:	00 
  409213:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40921a:	7f 00 00 
  40921d:	4c 89 e8             	mov    rax,r13
  409220:	48 25 ff ff 00 00    	and    rax,0xffff
  409226:	48 c1 e0 08          	shl    rax,0x8
  40922a:	49 01 c6             	add    r14,rax
  40922d:	b9 01 00 00 00       	mov    ecx,0x1
  409232:	01 c9                	add    ecx,ecx
  409234:	b8 03 00 00 00       	mov    eax,0x3
  409239:	d3 e0                	shl    eax,cl
  40923b:	f7 d0                	not    eax
  40923d:	83 e0 fc             	and    eax,0xfffffffc
  409240:	48 31 c9             	xor    rcx,rcx
  409243:	48 31 d2             	xor    rdx,rdx
  409246:	0f 01 ef             	wrpkru 
  409249:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40924c:	48 c1 e2 04          	shl    rdx,0x4
  409250:	4c 01 f2             	add    rdx,r14
  409253:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  409257:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40925a:	48 83 e8 01          	sub    rax,0x1
  40925e:	49 89 06             	mov    QWORD PTR [r14],rax
  409261:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  409266:	01 c9                	add    ecx,ecx
  409268:	b8 03 00 00 00       	mov    eax,0x3
  40926d:	d3 e0                	shl    eax,cl
  40926f:	f7 d0                	not    eax
  409271:	83 e0 fc             	and    eax,0xfffffffc
  409274:	48 31 c9             	xor    rcx,rcx
  409277:	48 31 d2             	xor    rdx,rdx
  40927a:	0f 01 ef             	wrpkru 
  40927d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409284:	be ad de 
  409287:	49 39 c7             	cmp    r15,rax
  40928a:	4c 89 c0             	mov    rax,r8
  40928d:	41 5f                	pop    r15
  40928f:	41 5e                	pop    r14
  409291:	41 5d                	pop    r13
  409293:	5d                   	pop    rbp
  409294:	c3                   	ret    
  409295:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40929c:	00 00 00 00 

00000000004092a0 <__cosrt_extern_capmgr_vm_lapic_access_create>:
  4092a0:	48 b8 64 02 46 00 00 	movabs rax,0x460264
  4092a7:	00 00 00 
  4092aa:	ff 10                	call   QWORD PTR [rax]
  4092ac:	c3                   	ret    
  4092ad:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004092b0 <__cosrt_fast_callgate_capmgr_vm_lapic_access_create>:
  4092b0:	55                   	push   rbp
  4092b1:	41 55                	push   r13
  4092b3:	41 56                	push   r14
  4092b5:	41 57                	push   r15
  4092b7:	49 89 c8             	mov    r8,rcx
  4092ba:	49 89 d1             	mov    r9,rdx
  4092bd:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4092c4:	be ad de 
  4092c7:	0f 01 f9             	rdtscp 
  4092ca:	48 89 c8             	mov    rax,rcx
  4092cd:	48 25 ff 0f 00 00    	and    rax,0xfff
  4092d3:	48 89 e2             	mov    rdx,rsp
  4092d6:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4092dd:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4092e4:	00 
  4092e5:	48 c1 e0 10          	shl    rax,0x10
  4092e9:	49 09 c5             	or     r13,rax
  4092ec:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4092f3:	7f 00 00 
  4092f6:	4c 89 e8             	mov    rax,r13
  4092f9:	48 25 ff ff 00 00    	and    rax,0xffff
  4092ff:	48 c1 e0 08          	shl    rax,0x8
  409303:	49 01 c6             	add    r14,rax
  409306:	b9 01 00 00 00       	mov    ecx,0x1
  40930b:	01 c9                	add    ecx,ecx
  40930d:	b8 03 00 00 00       	mov    eax,0x3
  409312:	d3 e0                	shl    eax,cl
  409314:	f7 d0                	not    eax
  409316:	83 e0 fc             	and    eax,0xfffffffc
  409319:	48 31 c9             	xor    rcx,rcx
  40931c:	48 31 d2             	xor    rdx,rdx
  40931f:	0f 01 ef             	wrpkru 
  409322:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  409325:	48 83 c2 01          	add    rdx,0x1
  409329:	48 c1 e2 04          	shl    rdx,0x4
  40932d:	4c 01 f2             	add    rdx,r14
  409330:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  409337:	45 23 01 
  40933a:	48 89 02             	mov    QWORD PTR [rdx],rax
  40933d:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  409341:	49 8b 06             	mov    rax,QWORD PTR [r14]
  409344:	48 83 c0 01          	add    rax,0x1
  409348:	49 89 06             	mov    QWORD PTR [r14],rax
  40934b:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  409350:	01 c9                	add    ecx,ecx
  409352:	b8 03 00 00 00       	mov    eax,0x3
  409357:	d3 e0                	shl    eax,cl
  409359:	f7 d0                	not    eax
  40935b:	83 e0 fc             	and    eax,0xfffffffc
  40935e:	48 31 c9             	xor    rcx,rcx
  409361:	48 31 d2             	xor    rdx,rdx
  409364:	0f 01 ef             	wrpkru 
  409367:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  40936e:	45 23 01 
  409371:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409378:	be ad de 
  40937b:	49 39 c7             	cmp    r15,rax
  40937e:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  409385:	12 12 12 
  409388:	48 b9 94 93 40 00 00 	movabs rcx,0x409394
  40938f:	00 00 00 
  409392:	ff e0                	jmp    rax

0000000000409394 <srv_call_ret_capmgr_vm_lapic_access_create>:
  409394:	49 89 c0             	mov    r8,rax
  409397:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40939e:	be ad de 
  4093a1:	48 89 e2             	mov    rdx,rsp
  4093a4:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4093ab:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4093b2:	00 
  4093b3:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4093ba:	7f 00 00 
  4093bd:	4c 89 e8             	mov    rax,r13
  4093c0:	48 25 ff ff 00 00    	and    rax,0xffff
  4093c6:	48 c1 e0 08          	shl    rax,0x8
  4093ca:	49 01 c6             	add    r14,rax
  4093cd:	b9 01 00 00 00       	mov    ecx,0x1
  4093d2:	01 c9                	add    ecx,ecx
  4093d4:	b8 03 00 00 00       	mov    eax,0x3
  4093d9:	d3 e0                	shl    eax,cl
  4093db:	f7 d0                	not    eax
  4093dd:	83 e0 fc             	and    eax,0xfffffffc
  4093e0:	48 31 c9             	xor    rcx,rcx
  4093e3:	48 31 d2             	xor    rdx,rdx
  4093e6:	0f 01 ef             	wrpkru 
  4093e9:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4093ec:	48 c1 e2 04          	shl    rdx,0x4
  4093f0:	4c 01 f2             	add    rdx,r14
  4093f3:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  4093f7:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4093fa:	48 83 e8 01          	sub    rax,0x1
  4093fe:	49 89 06             	mov    QWORD PTR [r14],rax
  409401:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  409406:	01 c9                	add    ecx,ecx
  409408:	b8 03 00 00 00       	mov    eax,0x3
  40940d:	d3 e0                	shl    eax,cl
  40940f:	f7 d0                	not    eax
  409411:	83 e0 fc             	and    eax,0xfffffffc
  409414:	48 31 c9             	xor    rcx,rcx
  409417:	48 31 d2             	xor    rdx,rdx
  40941a:	0f 01 ef             	wrpkru 
  40941d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409424:	be ad de 
  409427:	49 39 c7             	cmp    r15,rax
  40942a:	4c 89 c0             	mov    rax,r8
  40942d:	41 5f                	pop    r15
  40942f:	41 5e                	pop    r14
  409431:	41 5d                	pop    r13
  409433:	5d                   	pop    rbp
  409434:	c3                   	ret    
  409435:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40943c:	00 00 00 00 

0000000000409440 <__cosrt_extern_capmgr_shared_kernel_page_create>:
  409440:	48 b8 7c 02 46 00 00 	movabs rax,0x46027c
  409447:	00 00 00 
  40944a:	ff 10                	call   QWORD PTR [rax]
  40944c:	c3                   	ret    
  40944d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000409450 <__cosrt_fast_callgate_capmgr_shared_kernel_page_create>:
  409450:	55                   	push   rbp
  409451:	53                   	push   rbx
  409452:	41 54                	push   r12
  409454:	41 55                	push   r13
  409456:	41 56                	push   r14
  409458:	41 57                	push   r15
  40945a:	4d 89 c4             	mov    r12,r8
  40945d:	4c 89 cb             	mov    rbx,r9
  409460:	49 89 c8             	mov    r8,rcx
  409463:	49 89 d1             	mov    r9,rdx
  409466:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40946d:	be ad de 
  409470:	0f 01 f9             	rdtscp 
  409473:	48 89 ca             	mov    rdx,rcx
  409476:	48 25 ff 0f 00 00    	and    rax,0xfff
  40947c:	48 89 e2             	mov    rdx,rsp
  40947f:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  409486:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40948d:	00 
  40948e:	48 c1 e0 10          	shl    rax,0x10
  409492:	49 09 c5             	or     r13,rax
  409495:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40949c:	7f 00 00 
  40949f:	4c 89 e8             	mov    rax,r13
  4094a2:	48 25 ff ff 00 00    	and    rax,0xffff
  4094a8:	48 c1 e0 08          	shl    rax,0x8
  4094ac:	49 01 c6             	add    r14,rax
  4094af:	b9 01 00 00 00       	mov    ecx,0x1
  4094b4:	01 c9                	add    ecx,ecx
  4094b6:	b8 03 00 00 00       	mov    eax,0x3
  4094bb:	d3 e0                	shl    eax,cl
  4094bd:	f7 d0                	not    eax
  4094bf:	83 e0 fc             	and    eax,0xfffffffc
  4094c2:	48 31 c9             	xor    rcx,rcx
  4094c5:	48 31 d2             	xor    rdx,rdx
  4094c8:	0f 01 ef             	wrpkru 
  4094cb:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4094ce:	48 83 c2 01          	add    rdx,0x1
  4094d2:	48 c1 e2 04          	shl    rdx,0x4
  4094d6:	4c 01 f2             	add    rdx,r14
  4094d9:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  4094e0:	45 23 01 
  4094e3:	48 89 02             	mov    QWORD PTR [rdx],rax
  4094e6:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  4094ea:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4094ed:	48 83 c0 01          	add    rax,0x1
  4094f1:	49 89 06             	mov    QWORD PTR [r14],rax
  4094f4:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4094f9:	01 c9                	add    ecx,ecx
  4094fb:	b8 03 00 00 00       	mov    eax,0x3
  409500:	d3 e0                	shl    eax,cl
  409502:	f7 d0                	not    eax
  409504:	83 e0 fc             	and    eax,0xfffffffc
  409507:	48 31 c9             	xor    rcx,rcx
  40950a:	48 31 d2             	xor    rdx,rdx
  40950d:	0f 01 ef             	wrpkru 
  409510:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  409517:	45 23 01 
  40951a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409521:	be ad de 
  409524:	49 39 c7             	cmp    r15,rax
  409527:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  40952e:	12 12 12 
  409531:	48 b9 3d 95 40 00 00 	movabs rcx,0x40953d
  409538:	00 00 00 
  40953b:	ff e0                	jmp    rax

000000000040953d <srv_call_ret_capmgr_shared_kernel_page_create>:
  40953d:	49 89 c0             	mov    r8,rax
  409540:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  409547:	be ad de 
  40954a:	48 89 e2             	mov    rdx,rsp
  40954d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  409554:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40955b:	00 
  40955c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  409563:	7f 00 00 
  409566:	4c 89 e8             	mov    rax,r13
  409569:	48 25 ff ff 00 00    	and    rax,0xffff
  40956f:	48 c1 e0 08          	shl    rax,0x8
  409573:	49 01 c6             	add    r14,rax
  409576:	b9 01 00 00 00       	mov    ecx,0x1
  40957b:	01 c9                	add    ecx,ecx
  40957d:	b8 03 00 00 00       	mov    eax,0x3
  409582:	d3 e0                	shl    eax,cl
  409584:	f7 d0                	not    eax
  409586:	83 e0 fc             	and    eax,0xfffffffc
  409589:	48 31 c9             	xor    rcx,rcx
  40958c:	48 31 d2             	xor    rdx,rdx
  40958f:	0f 01 ef             	wrpkru 
  409592:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  409595:	48 c1 e2 04          	shl    rdx,0x4
  409599:	4c 01 f2             	add    rdx,r14
  40959c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  4095a0:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4095a3:	48 83 e8 01          	sub    rax,0x1
  4095a7:	49 89 06             	mov    QWORD PTR [r14],rax
  4095aa:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4095af:	01 c9                	add    ecx,ecx
  4095b1:	b8 03 00 00 00       	mov    eax,0x3
  4095b6:	d3 e0                	shl    eax,cl
  4095b8:	f7 d0                	not    eax
  4095ba:	83 e0 fc             	and    eax,0xfffffffc
  4095bd:	48 31 c9             	xor    rcx,rcx
  4095c0:	48 31 d2             	xor    rdx,rdx
  4095c3:	0f 01 ef             	wrpkru 
  4095c6:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4095cd:	be ad de 
  4095d0:	49 39 c7             	cmp    r15,rax
  4095d3:	4c 89 c0             	mov    rax,r8
  4095d6:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  4095da:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  4095dd:	41 5f                	pop    r15
  4095df:	41 5e                	pop    r14
  4095e1:	41 5d                	pop    r13
  4095e3:	41 5c                	pop    r12
  4095e5:	5b                   	pop    rbx
  4095e6:	5d                   	pop    rbp
  4095e7:	c3                   	ret    
  4095e8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4095ef:	00 

00000000004095f0 <__cosrt_extern_capmgr_vm_lapic_create>:
  4095f0:	48 b8 94 02 46 00 00 	movabs rax,0x460294
  4095f7:	00 00 00 
  4095fa:	ff 10                	call   QWORD PTR [rax]
  4095fc:	c3                   	ret    
  4095fd:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000409600 <__cosrt_fast_callgate_capmgr_vm_lapic_create>:
  409600:	55                   	push   rbp
  409601:	53                   	push   rbx
  409602:	41 54                	push   r12
  409604:	41 55                	push   r13
  409606:	41 56                	push   r14
  409608:	41 57                	push   r15
  40960a:	4d 89 c4             	mov    r12,r8
  40960d:	4c 89 cb             	mov    rbx,r9
  409610:	49 89 c8             	mov    r8,rcx
  409613:	49 89 d1             	mov    r9,rdx
  409616:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40961d:	be ad de 
  409620:	0f 01 f9             	rdtscp 
  409623:	48 89 ca             	mov    rdx,rcx
  409626:	48 25 ff 0f 00 00    	and    rax,0xfff
  40962c:	48 89 e2             	mov    rdx,rsp
  40962f:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  409636:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40963d:	00 
  40963e:	48 c1 e0 10          	shl    rax,0x10
  409642:	49 09 c5             	or     r13,rax
  409645:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40964c:	7f 00 00 
  40964f:	4c 89 e8             	mov    rax,r13
  409652:	48 25 ff ff 00 00    	and    rax,0xffff
  409658:	48 c1 e0 08          	shl    rax,0x8
  40965c:	49 01 c6             	add    r14,rax
  40965f:	b9 01 00 00 00       	mov    ecx,0x1
  409664:	01 c9                	add    ecx,ecx
  409666:	b8 03 00 00 00       	mov    eax,0x3
  40966b:	d3 e0                	shl    eax,cl
  40966d:	f7 d0                	not    eax
  40966f:	83 e0 fc             	and    eax,0xfffffffc
  409672:	48 31 c9             	xor    rcx,rcx
  409675:	48 31 d2             	xor    rdx,rdx
  409678:	0f 01 ef             	wrpkru 
  40967b:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40967e:	48 83 c2 01          	add    rdx,0x1
  409682:	48 c1 e2 04          	shl    rdx,0x4
  409686:	4c 01 f2             	add    rdx,r14
  409689:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  409690:	45 23 01 
  409693:	48 89 02             	mov    QWORD PTR [rdx],rax
  409696:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  40969a:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40969d:	48 83 c0 01          	add    rax,0x1
  4096a1:	49 89 06             	mov    QWORD PTR [r14],rax
  4096a4:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4096a9:	01 c9                	add    ecx,ecx
  4096ab:	b8 03 00 00 00       	mov    eax,0x3
  4096b0:	d3 e0                	shl    eax,cl
  4096b2:	f7 d0                	not    eax
  4096b4:	83 e0 fc             	and    eax,0xfffffffc
  4096b7:	48 31 c9             	xor    rcx,rcx
  4096ba:	48 31 d2             	xor    rdx,rdx
  4096bd:	0f 01 ef             	wrpkru 
  4096c0:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  4096c7:	45 23 01 
  4096ca:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4096d1:	be ad de 
  4096d4:	49 39 c7             	cmp    r15,rax
  4096d7:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  4096de:	12 12 12 
  4096e1:	48 b9 ed 96 40 00 00 	movabs rcx,0x4096ed
  4096e8:	00 00 00 
  4096eb:	ff e0                	jmp    rax

00000000004096ed <srv_call_ret_capmgr_vm_lapic_create>:
  4096ed:	49 89 c0             	mov    r8,rax
  4096f0:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4096f7:	be ad de 
  4096fa:	48 89 e2             	mov    rdx,rsp
  4096fd:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  409704:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40970b:	00 
  40970c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  409713:	7f 00 00 
  409716:	4c 89 e8             	mov    rax,r13
  409719:	48 25 ff ff 00 00    	and    rax,0xffff
  40971f:	48 c1 e0 08          	shl    rax,0x8
  409723:	49 01 c6             	add    r14,rax
  409726:	b9 01 00 00 00       	mov    ecx,0x1
  40972b:	01 c9                	add    ecx,ecx
  40972d:	b8 03 00 00 00       	mov    eax,0x3
  409732:	d3 e0                	shl    eax,cl
  409734:	f7 d0                	not    eax
  409736:	83 e0 fc             	and    eax,0xfffffffc
  409739:	48 31 c9             	xor    rcx,rcx
  40973c:	48 31 d2             	xor    rdx,rdx
  40973f:	0f 01 ef             	wrpkru 
  409742:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  409745:	48 c1 e2 04          	shl    rdx,0x4
  409749:	4c 01 f2             	add    rdx,r14
  40974c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  409750:	49 8b 06             	mov    rax,QWORD PTR [r14]
  409753:	48 83 e8 01          	sub    rax,0x1
  409757:	49 89 06             	mov    QWORD PTR [r14],rax
  40975a:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40975f:	01 c9                	add    ecx,ecx
  409761:	b8 03 00 00 00       	mov    eax,0x3
  409766:	d3 e0                	shl    eax,cl
  409768:	f7 d0                	not    eax
  40976a:	83 e0 fc             	and    eax,0xfffffffc
  40976d:	48 31 c9             	xor    rcx,rcx
  409770:	48 31 d2             	xor    rdx,rdx
  409773:	0f 01 ef             	wrpkru 
  409776:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40977d:	be ad de 
  409780:	49 39 c7             	cmp    r15,rax
  409783:	4c 89 c0             	mov    rax,r8
  409786:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  40978a:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  40978d:	41 5f                	pop    r15
  40978f:	41 5e                	pop    r14
  409791:	41 5d                	pop    r13
  409793:	41 5c                	pop    r12
  409795:	5b                   	pop    rbx
  409796:	5d                   	pop    rbp
  409797:	c3                   	ret    
  409798:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40979f:	00 

00000000004097a0 <__cosrt_extern_capmgr_vm_shared_region_create>:
  4097a0:	48 b8 ac 02 46 00 00 	movabs rax,0x4602ac
  4097a7:	00 00 00 
  4097aa:	ff 10                	call   QWORD PTR [rax]
  4097ac:	c3                   	ret    
  4097ad:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004097b0 <__cosrt_fast_callgate_capmgr_vm_shared_region_create>:
  4097b0:	55                   	push   rbp
  4097b1:	53                   	push   rbx
  4097b2:	41 54                	push   r12
  4097b4:	41 55                	push   r13
  4097b6:	41 56                	push   r14
  4097b8:	41 57                	push   r15
  4097ba:	4d 89 c4             	mov    r12,r8
  4097bd:	4c 89 cb             	mov    rbx,r9
  4097c0:	49 89 c8             	mov    r8,rcx
  4097c3:	49 89 d1             	mov    r9,rdx
  4097c6:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4097cd:	be ad de 
  4097d0:	0f 01 f9             	rdtscp 
  4097d3:	48 89 ca             	mov    rdx,rcx
  4097d6:	48 25 ff 0f 00 00    	and    rax,0xfff
  4097dc:	48 89 e2             	mov    rdx,rsp
  4097df:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4097e6:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4097ed:	00 
  4097ee:	48 c1 e0 10          	shl    rax,0x10
  4097f2:	49 09 c5             	or     r13,rax
  4097f5:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4097fc:	7f 00 00 
  4097ff:	4c 89 e8             	mov    rax,r13
  409802:	48 25 ff ff 00 00    	and    rax,0xffff
  409808:	48 c1 e0 08          	shl    rax,0x8
  40980c:	49 01 c6             	add    r14,rax
  40980f:	b9 01 00 00 00       	mov    ecx,0x1
  409814:	01 c9                	add    ecx,ecx
  409816:	b8 03 00 00 00       	mov    eax,0x3
  40981b:	d3 e0                	shl    eax,cl
  40981d:	f7 d0                	not    eax
  40981f:	83 e0 fc             	and    eax,0xfffffffc
  409822:	48 31 c9             	xor    rcx,rcx
  409825:	48 31 d2             	xor    rdx,rdx
  409828:	0f 01 ef             	wrpkru 
  40982b:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40982e:	48 83 c2 01          	add    rdx,0x1
  409832:	48 c1 e2 04          	shl    rdx,0x4
  409836:	4c 01 f2             	add    rdx,r14
  409839:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  409840:	45 23 01 
  409843:	48 89 02             	mov    QWORD PTR [rdx],rax
  409846:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  40984a:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40984d:	48 83 c0 01          	add    rax,0x1
  409851:	49 89 06             	mov    QWORD PTR [r14],rax
  409854:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  409859:	01 c9                	add    ecx,ecx
  40985b:	b8 03 00 00 00       	mov    eax,0x3
  409860:	d3 e0                	shl    eax,cl
  409862:	f7 d0                	not    eax
  409864:	83 e0 fc             	and    eax,0xfffffffc
  409867:	48 31 c9             	xor    rcx,rcx
  40986a:	48 31 d2             	xor    rdx,rdx
  40986d:	0f 01 ef             	wrpkru 
  409870:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  409877:	45 23 01 
  40987a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409881:	be ad de 
  409884:	49 39 c7             	cmp    r15,rax
  409887:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  40988e:	12 12 12 
  409891:	48 b9 9d 98 40 00 00 	movabs rcx,0x40989d
  409898:	00 00 00 
  40989b:	ff e0                	jmp    rax

000000000040989d <srv_call_ret_capmgr_vm_shared_region_create>:
  40989d:	49 89 c0             	mov    r8,rax
  4098a0:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4098a7:	be ad de 
  4098aa:	48 89 e2             	mov    rdx,rsp
  4098ad:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4098b4:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4098bb:	00 
  4098bc:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4098c3:	7f 00 00 
  4098c6:	4c 89 e8             	mov    rax,r13
  4098c9:	48 25 ff ff 00 00    	and    rax,0xffff
  4098cf:	48 c1 e0 08          	shl    rax,0x8
  4098d3:	49 01 c6             	add    r14,rax
  4098d6:	b9 01 00 00 00       	mov    ecx,0x1
  4098db:	01 c9                	add    ecx,ecx
  4098dd:	b8 03 00 00 00       	mov    eax,0x3
  4098e2:	d3 e0                	shl    eax,cl
  4098e4:	f7 d0                	not    eax
  4098e6:	83 e0 fc             	and    eax,0xfffffffc
  4098e9:	48 31 c9             	xor    rcx,rcx
  4098ec:	48 31 d2             	xor    rdx,rdx
  4098ef:	0f 01 ef             	wrpkru 
  4098f2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4098f5:	48 c1 e2 04          	shl    rdx,0x4
  4098f9:	4c 01 f2             	add    rdx,r14
  4098fc:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  409900:	49 8b 06             	mov    rax,QWORD PTR [r14]
  409903:	48 83 e8 01          	sub    rax,0x1
  409907:	49 89 06             	mov    QWORD PTR [r14],rax
  40990a:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40990f:	01 c9                	add    ecx,ecx
  409911:	b8 03 00 00 00       	mov    eax,0x3
  409916:	d3 e0                	shl    eax,cl
  409918:	f7 d0                	not    eax
  40991a:	83 e0 fc             	and    eax,0xfffffffc
  40991d:	48 31 c9             	xor    rcx,rcx
  409920:	48 31 d2             	xor    rdx,rdx
  409923:	0f 01 ef             	wrpkru 
  409926:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40992d:	be ad de 
  409930:	49 39 c7             	cmp    r15,rax
  409933:	4c 89 c0             	mov    rax,r8
  409936:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  40993a:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  40993d:	41 5f                	pop    r15
  40993f:	41 5e                	pop    r14
  409941:	41 5d                	pop    r13
  409943:	41 5c                	pop    r12
  409945:	5b                   	pop    rbx
  409946:	5d                   	pop    rbp
  409947:	c3                   	ret    
  409948:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40994f:	00 

0000000000409950 <__cosrt_extern_capmgr_vm_vmcb_create>:
  409950:	48 b8 c4 02 46 00 00 	movabs rax,0x4602c4
  409957:	00 00 00 
  40995a:	ff 10                	call   QWORD PTR [rax]
  40995c:	c3                   	ret    
  40995d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000409960 <__cosrt_fast_callgate_capmgr_vm_vmcb_create>:
  409960:	55                   	push   rbp
  409961:	53                   	push   rbx
  409962:	41 54                	push   r12
  409964:	41 55                	push   r13
  409966:	41 56                	push   r14
  409968:	41 57                	push   r15
  40996a:	4d 89 c4             	mov    r12,r8
  40996d:	4c 89 cb             	mov    rbx,r9
  409970:	49 89 c8             	mov    r8,rcx
  409973:	49 89 d1             	mov    r9,rdx
  409976:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40997d:	be ad de 
  409980:	0f 01 f9             	rdtscp 
  409983:	48 89 ca             	mov    rdx,rcx
  409986:	48 25 ff 0f 00 00    	and    rax,0xfff
  40998c:	48 89 e2             	mov    rdx,rsp
  40998f:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  409996:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40999d:	00 
  40999e:	48 c1 e0 10          	shl    rax,0x10
  4099a2:	49 09 c5             	or     r13,rax
  4099a5:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4099ac:	7f 00 00 
  4099af:	4c 89 e8             	mov    rax,r13
  4099b2:	48 25 ff ff 00 00    	and    rax,0xffff
  4099b8:	48 c1 e0 08          	shl    rax,0x8
  4099bc:	49 01 c6             	add    r14,rax
  4099bf:	b9 01 00 00 00       	mov    ecx,0x1
  4099c4:	01 c9                	add    ecx,ecx
  4099c6:	b8 03 00 00 00       	mov    eax,0x3
  4099cb:	d3 e0                	shl    eax,cl
  4099cd:	f7 d0                	not    eax
  4099cf:	83 e0 fc             	and    eax,0xfffffffc
  4099d2:	48 31 c9             	xor    rcx,rcx
  4099d5:	48 31 d2             	xor    rdx,rdx
  4099d8:	0f 01 ef             	wrpkru 
  4099db:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4099de:	48 83 c2 01          	add    rdx,0x1
  4099e2:	48 c1 e2 04          	shl    rdx,0x4
  4099e6:	4c 01 f2             	add    rdx,r14
  4099e9:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  4099f0:	45 23 01 
  4099f3:	48 89 02             	mov    QWORD PTR [rdx],rax
  4099f6:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  4099fa:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4099fd:	48 83 c0 01          	add    rax,0x1
  409a01:	49 89 06             	mov    QWORD PTR [r14],rax
  409a04:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  409a09:	01 c9                	add    ecx,ecx
  409a0b:	b8 03 00 00 00       	mov    eax,0x3
  409a10:	d3 e0                	shl    eax,cl
  409a12:	f7 d0                	not    eax
  409a14:	83 e0 fc             	and    eax,0xfffffffc
  409a17:	48 31 c9             	xor    rcx,rcx
  409a1a:	48 31 d2             	xor    rdx,rdx
  409a1d:	0f 01 ef             	wrpkru 
  409a20:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  409a27:	45 23 01 
  409a2a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409a31:	be ad de 
  409a34:	49 39 c7             	cmp    r15,rax
  409a37:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  409a3e:	12 12 12 
  409a41:	48 b9 4d 9a 40 00 00 	movabs rcx,0x409a4d
  409a48:	00 00 00 
  409a4b:	ff e0                	jmp    rax

0000000000409a4d <srv_call_ret_capmgr_vm_vmcb_create>:
  409a4d:	49 89 c0             	mov    r8,rax
  409a50:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  409a57:	be ad de 
  409a5a:	48 89 e2             	mov    rdx,rsp
  409a5d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  409a64:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  409a6b:	00 
  409a6c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  409a73:	7f 00 00 
  409a76:	4c 89 e8             	mov    rax,r13
  409a79:	48 25 ff ff 00 00    	and    rax,0xffff
  409a7f:	48 c1 e0 08          	shl    rax,0x8
  409a83:	49 01 c6             	add    r14,rax
  409a86:	b9 01 00 00 00       	mov    ecx,0x1
  409a8b:	01 c9                	add    ecx,ecx
  409a8d:	b8 03 00 00 00       	mov    eax,0x3
  409a92:	d3 e0                	shl    eax,cl
  409a94:	f7 d0                	not    eax
  409a96:	83 e0 fc             	and    eax,0xfffffffc
  409a99:	48 31 c9             	xor    rcx,rcx
  409a9c:	48 31 d2             	xor    rdx,rdx
  409a9f:	0f 01 ef             	wrpkru 
  409aa2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  409aa5:	48 c1 e2 04          	shl    rdx,0x4
  409aa9:	4c 01 f2             	add    rdx,r14
  409aac:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  409ab0:	49 8b 06             	mov    rax,QWORD PTR [r14]
  409ab3:	48 83 e8 01          	sub    rax,0x1
  409ab7:	49 89 06             	mov    QWORD PTR [r14],rax
  409aba:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  409abf:	01 c9                	add    ecx,ecx
  409ac1:	b8 03 00 00 00       	mov    eax,0x3
  409ac6:	d3 e0                	shl    eax,cl
  409ac8:	f7 d0                	not    eax
  409aca:	83 e0 fc             	and    eax,0xfffffffc
  409acd:	48 31 c9             	xor    rcx,rcx
  409ad0:	48 31 d2             	xor    rdx,rdx
  409ad3:	0f 01 ef             	wrpkru 
  409ad6:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409add:	be ad de 
  409ae0:	49 39 c7             	cmp    r15,rax
  409ae3:	4c 89 c0             	mov    rax,r8
  409ae6:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  409aea:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  409aed:	41 5f                	pop    r15
  409aef:	41 5e                	pop    r14
  409af1:	41 5d                	pop    r13
  409af3:	41 5c                	pop    r12
  409af5:	5b                   	pop    rbx
  409af6:	5d                   	pop    rbp
  409af7:	c3                   	ret    
  409af8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  409aff:	00 

0000000000409b00 <__cosrt_extern_capmgr_vm_vcpu_create>:
  409b00:	48 b8 dc 02 46 00 00 	movabs rax,0x4602dc
  409b07:	00 00 00 
  409b0a:	ff 10                	call   QWORD PTR [rax]
  409b0c:	c3                   	ret    
  409b0d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000409b10 <__cosrt_fast_callgate_capmgr_vm_vcpu_create>:
  409b10:	55                   	push   rbp
  409b11:	53                   	push   rbx
  409b12:	41 54                	push   r12
  409b14:	41 55                	push   r13
  409b16:	41 56                	push   r14
  409b18:	41 57                	push   r15
  409b1a:	4d 89 c4             	mov    r12,r8
  409b1d:	4c 89 cb             	mov    rbx,r9
  409b20:	49 89 c8             	mov    r8,rcx
  409b23:	49 89 d1             	mov    r9,rdx
  409b26:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  409b2d:	be ad de 
  409b30:	0f 01 f9             	rdtscp 
  409b33:	48 89 ca             	mov    rdx,rcx
  409b36:	48 25 ff 0f 00 00    	and    rax,0xfff
  409b3c:	48 89 e2             	mov    rdx,rsp
  409b3f:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  409b46:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  409b4d:	00 
  409b4e:	48 c1 e0 10          	shl    rax,0x10
  409b52:	49 09 c5             	or     r13,rax
  409b55:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  409b5c:	7f 00 00 
  409b5f:	4c 89 e8             	mov    rax,r13
  409b62:	48 25 ff ff 00 00    	and    rax,0xffff
  409b68:	48 c1 e0 08          	shl    rax,0x8
  409b6c:	49 01 c6             	add    r14,rax
  409b6f:	b9 01 00 00 00       	mov    ecx,0x1
  409b74:	01 c9                	add    ecx,ecx
  409b76:	b8 03 00 00 00       	mov    eax,0x3
  409b7b:	d3 e0                	shl    eax,cl
  409b7d:	f7 d0                	not    eax
  409b7f:	83 e0 fc             	and    eax,0xfffffffc
  409b82:	48 31 c9             	xor    rcx,rcx
  409b85:	48 31 d2             	xor    rdx,rdx
  409b88:	0f 01 ef             	wrpkru 
  409b8b:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  409b8e:	48 83 c2 01          	add    rdx,0x1
  409b92:	48 c1 e2 04          	shl    rdx,0x4
  409b96:	4c 01 f2             	add    rdx,r14
  409b99:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  409ba0:	45 23 01 
  409ba3:	48 89 02             	mov    QWORD PTR [rdx],rax
  409ba6:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  409baa:	49 8b 06             	mov    rax,QWORD PTR [r14]
  409bad:	48 83 c0 01          	add    rax,0x1
  409bb1:	49 89 06             	mov    QWORD PTR [r14],rax
  409bb4:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  409bb9:	01 c9                	add    ecx,ecx
  409bbb:	b8 03 00 00 00       	mov    eax,0x3
  409bc0:	d3 e0                	shl    eax,cl
  409bc2:	f7 d0                	not    eax
  409bc4:	83 e0 fc             	and    eax,0xfffffffc
  409bc7:	48 31 c9             	xor    rcx,rcx
  409bca:	48 31 d2             	xor    rdx,rdx
  409bcd:	0f 01 ef             	wrpkru 
  409bd0:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  409bd7:	45 23 01 
  409bda:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409be1:	be ad de 
  409be4:	49 39 c7             	cmp    r15,rax
  409be7:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  409bee:	12 12 12 
  409bf1:	48 b9 fd 9b 40 00 00 	movabs rcx,0x409bfd
  409bf8:	00 00 00 
  409bfb:	ff e0                	jmp    rax

0000000000409bfd <srv_call_ret_capmgr_vm_vcpu_create>:
  409bfd:	49 89 c0             	mov    r8,rax
  409c00:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  409c07:	be ad de 
  409c0a:	48 89 e2             	mov    rdx,rsp
  409c0d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  409c14:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  409c1b:	00 
  409c1c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  409c23:	7f 00 00 
  409c26:	4c 89 e8             	mov    rax,r13
  409c29:	48 25 ff ff 00 00    	and    rax,0xffff
  409c2f:	48 c1 e0 08          	shl    rax,0x8
  409c33:	49 01 c6             	add    r14,rax
  409c36:	b9 01 00 00 00       	mov    ecx,0x1
  409c3b:	01 c9                	add    ecx,ecx
  409c3d:	b8 03 00 00 00       	mov    eax,0x3
  409c42:	d3 e0                	shl    eax,cl
  409c44:	f7 d0                	not    eax
  409c46:	83 e0 fc             	and    eax,0xfffffffc
  409c49:	48 31 c9             	xor    rcx,rcx
  409c4c:	48 31 d2             	xor    rdx,rdx
  409c4f:	0f 01 ef             	wrpkru 
  409c52:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  409c55:	48 c1 e2 04          	shl    rdx,0x4
  409c59:	4c 01 f2             	add    rdx,r14
  409c5c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  409c60:	49 8b 06             	mov    rax,QWORD PTR [r14]
  409c63:	48 83 e8 01          	sub    rax,0x1
  409c67:	49 89 06             	mov    QWORD PTR [r14],rax
  409c6a:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  409c6f:	01 c9                	add    ecx,ecx
  409c71:	b8 03 00 00 00       	mov    eax,0x3
  409c76:	d3 e0                	shl    eax,cl
  409c78:	f7 d0                	not    eax
  409c7a:	83 e0 fc             	and    eax,0xfffffffc
  409c7d:	48 31 c9             	xor    rcx,rcx
  409c80:	48 31 d2             	xor    rdx,rdx
  409c83:	0f 01 ef             	wrpkru 
  409c86:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409c8d:	be ad de 
  409c90:	49 39 c7             	cmp    r15,rax
  409c93:	4c 89 c0             	mov    rax,r8
  409c96:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  409c9a:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  409c9d:	41 5f                	pop    r15
  409c9f:	41 5e                	pop    r14
  409ca1:	41 5d                	pop    r13
  409ca3:	41 5c                	pop    r12
  409ca5:	5b                   	pop    rbx
  409ca6:	5d                   	pop    rbp
  409ca7:	c3                   	ret    
  409ca8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  409caf:	00 

0000000000409cb0 <__cosrt_c_memmgr_shared_page_allocn>:
#include <cos_component.h>
#include <cos_stubs.h>
#include <memmgr.h>

COS_CLIENT_STUB(cbuf_t, memmgr_shared_page_allocn, unsigned long num_pages, vaddr_t *pgaddr)
{
  409cb0:	f3 0f 1e fa          	endbr64 
  409cb4:	55                   	push   rbp
  409cb5:	48 89 e5             	mov    rbp,rsp
  409cb8:	41 57                	push   r15
  409cba:	41 56                	push   r14
  409cbc:	41 55                	push   r13
  409cbe:	49 89 f5             	mov    r13,rsi
  409cc1:	41 54                	push   r12
  409cc3:	53                   	push   rbx
  409cc4:	48 83 ec 28          	sub    rsp,0x28
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  409cc8:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  409ccc:	4d 85 f6             	test   r14,r14
  409ccf:	74 2f                	je     409d00 <__cosrt_c_memmgr_shared_page_allocn+0x50>
  409cd1:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  409cd5:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  409cd9:	31 c9                	xor    ecx,ecx
  409cdb:	31 d2                	xor    edx,edx
  409cdd:	31 f6                	xor    esi,esi
  409cdf:	41 ff d6             	call   r14
	COS_CLIENT_INVCAP;
	word_t unused, addrret;
	cbuf_t ret;

	ret = cos_sinv_2rets(uc, num_pages, 0, 0, 0, &addrret, &unused);
	*pgaddr = addrret;
  409ce2:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
  409ce6:	49 89 55 00          	mov    QWORD PTR [r13+0x0],rdx

	return ret;
}
  409cea:	48 83 c4 28          	add    rsp,0x28
  409cee:	5b                   	pop    rbx
  409cef:	41 5c                	pop    r12
  409cf1:	41 5d                	pop    r13
  409cf3:	41 5e                	pop    r14
  409cf5:	41 5f                	pop    r15
  409cf7:	5d                   	pop    rbp
  409cf8:	c3                   	ret    
  409cf9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  409d00:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  409d04:	48 89 fb             	mov    rbx,rdi
  409d07:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  409d0b:	4c 89 f6             	mov    rsi,r14
  409d0e:	4c 89 f7             	mov    rdi,r14
  409d11:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  409d14:	83 c0 01             	add    eax,0x1
  409d17:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  409d1a:	48 89 29             	mov    QWORD PTR [rcx],rbp
  409d1d:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  409d21:	48 89 cd             	mov    rbp,rcx
  409d24:	49 b8 38 9d 40 00 00 	movabs r8,0x409d38
  409d2b:	00 00 00 
  409d2e:	0f 05                	syscall 
  409d30:	eb 0f                	jmp    409d41 <__cosrt_c_memmgr_shared_page_allocn+0x91>
  409d32:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  409d38:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  409d3f:	eb 07                	jmp    409d48 <__cosrt_c_memmgr_shared_page_allocn+0x98>
  409d41:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  409d48:	5d                   	pop    rbp
  409d49:	5c                   	pop    rsp
  409d4a:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  409d4e:	eb 92                	jmp    409ce2 <__cosrt_c_memmgr_shared_page_allocn+0x32>

0000000000409d50 <__cosrt_c_memmgr_shared_page_map>:

COS_CLIENT_STUB(unsigned long, memmgr_shared_page_map, cbuf_t id, vaddr_t *pgaddr)
{
  409d50:	f3 0f 1e fa          	endbr64 
  409d54:	55                   	push   rbp
  409d55:	48 89 e5             	mov    rbp,rsp
  409d58:	41 57                	push   r15
	COS_CLIENT_INVCAP;
	word_t unused, addrret;
	unsigned long ret;

	ret = cos_sinv_2rets(uc, id, 0, 0, 0, &addrret, &unused);
  409d5a:	41 89 ff             	mov    r15d,edi
{
  409d5d:	41 56                	push   r14
  409d5f:	41 55                	push   r13
  409d61:	49 89 f5             	mov    r13,rsi
  409d64:	41 54                	push   r12
  409d66:	53                   	push   rbx
  409d67:	48 83 ec 28          	sub    rsp,0x28
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  409d6b:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  409d6f:	4d 85 f6             	test   r14,r14
  409d72:	74 34                	je     409da8 <__cosrt_c_memmgr_shared_page_map+0x58>
  409d74:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  409d78:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  409d7c:	31 c9                	xor    ecx,ecx
  409d7e:	31 d2                	xor    edx,edx
  409d80:	31 f6                	xor    esi,esi
  409d82:	4c 89 ff             	mov    rdi,r15
  409d85:	41 ff d6             	call   r14
	*pgaddr = addrret;
  409d88:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
	ret = cos_sinv_2rets(uc, id, 0, 0, 0, &addrret, &unused);
  409d8c:	48 98                	cdqe   
	*pgaddr = addrret;
  409d8e:	49 89 55 00          	mov    QWORD PTR [r13+0x0],rdx

	return ret;
}
  409d92:	48 83 c4 28          	add    rsp,0x28
  409d96:	5b                   	pop    rbx
  409d97:	41 5c                	pop    r12
  409d99:	41 5d                	pop    r13
  409d9b:	41 5e                	pop    r14
  409d9d:	41 5f                	pop    r15
  409d9f:	5d                   	pop    rbp
  409da0:	c3                   	ret    
  409da1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  409da8:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  409dac:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  409db0:	4c 89 fb             	mov    rbx,r15
  409db3:	4c 89 f6             	mov    rsi,r14
  409db6:	4c 89 f7             	mov    rdi,r14
  409db9:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  409dbc:	83 c0 01             	add    eax,0x1
  409dbf:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  409dc2:	48 89 29             	mov    QWORD PTR [rcx],rbp
  409dc5:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  409dc9:	48 89 cd             	mov    rbp,rcx
  409dcc:	49 b8 e0 9d 40 00 00 	movabs r8,0x409de0
  409dd3:	00 00 00 
  409dd6:	0f 05                	syscall 
  409dd8:	eb 0f                	jmp    409de9 <__cosrt_c_memmgr_shared_page_map+0x99>
  409dda:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  409de0:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  409de7:	eb 07                	jmp    409df0 <__cosrt_c_memmgr_shared_page_map+0xa0>
  409de9:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  409df0:	5d                   	pop    rbp
  409df1:	5c                   	pop    rsp
  409df2:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  409df6:	eb 90                	jmp    409d88 <__cosrt_c_memmgr_shared_page_map+0x38>
  409df8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  409dff:	00 

0000000000409e00 <__cosrt_c_memmgr_shared_page_allocn_aligned>:

COS_CLIENT_STUB(cbuf_t, memmgr_shared_page_allocn_aligned, unsigned long num_pages, unsigned long align, vaddr_t *pgaddr)
{
  409e00:	f3 0f 1e fa          	endbr64 
  409e04:	55                   	push   rbp
  409e05:	48 89 e5             	mov    rbp,rsp
  409e08:	41 57                	push   r15
  409e0a:	49 89 d7             	mov    r15,rdx
  409e0d:	41 56                	push   r14
  409e0f:	41 55                	push   r13
  409e11:	41 54                	push   r12
  409e13:	53                   	push   rbx
  409e14:	48 83 ec 28          	sub    rsp,0x28
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  409e18:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  409e1c:	4d 85 f6             	test   r14,r14
  409e1f:	74 2f                	je     409e50 <__cosrt_c_memmgr_shared_page_allocn_aligned+0x50>
  409e21:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  409e25:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  409e29:	31 c9                	xor    ecx,ecx
  409e2b:	31 d2                	xor    edx,edx
  409e2d:	41 ff d6             	call   r14
	COS_CLIENT_INVCAP;
	word_t unused, addrret;
	cbuf_t ret;

	ret = cos_sinv_2rets(uc, num_pages, align, 0, 0, &addrret, &unused);
	*pgaddr = addrret;
  409e30:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
  409e34:	49 89 17             	mov    QWORD PTR [r15],rdx

	return ret;
}
  409e37:	48 83 c4 28          	add    rsp,0x28
  409e3b:	5b                   	pop    rbx
  409e3c:	41 5c                	pop    r12
  409e3e:	41 5d                	pop    r13
  409e40:	41 5e                	pop    r14
  409e42:	41 5f                	pop    r15
  409e44:	5d                   	pop    rbp
  409e45:	c3                   	ret    
  409e46:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  409e4d:	00 00 00 
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  409e50:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  409e54:	48 89 fb             	mov    rbx,rdi
  409e57:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  409e5b:	4c 89 f7             	mov    rdi,r14
  409e5e:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  409e61:	83 c0 01             	add    eax,0x1
  409e64:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  409e67:	48 89 29             	mov    QWORD PTR [rcx],rbp
  409e6a:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  409e6e:	48 89 cd             	mov    rbp,rcx
  409e71:	49 b8 88 9e 40 00 00 	movabs r8,0x409e88
  409e78:	00 00 00 
  409e7b:	0f 05                	syscall 
  409e7d:	0f 1f 00             	nop    DWORD PTR [rax]
  409e80:	eb 0f                	jmp    409e91 <__cosrt_c_memmgr_shared_page_allocn_aligned+0x91>
  409e82:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  409e88:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  409e8f:	eb 07                	jmp    409e98 <__cosrt_c_memmgr_shared_page_allocn_aligned+0x98>
  409e91:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  409e98:	5d                   	pop    rbp
  409e99:	5c                   	pop    rsp
  409e9a:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  409e9e:	eb 90                	jmp    409e30 <__cosrt_c_memmgr_shared_page_allocn_aligned+0x30>

0000000000409ea0 <__cosrt_c_memmgr_shared_page_map_aligned>:

COS_CLIENT_STUB(unsigned long, memmgr_shared_page_map_aligned, cbuf_t id, unsigned long align, vaddr_t *pgaddr)
{
  409ea0:	f3 0f 1e fa          	endbr64 
  409ea4:	55                   	push   rbp
  409ea5:	48 89 e5             	mov    rbp,rsp
  409ea8:	41 57                	push   r15
  409eaa:	49 89 d7             	mov    r15,rdx
  409ead:	41 56                	push   r14
  409eaf:	41 55                	push   r13
	COS_CLIENT_INVCAP;
	word_t unused, addrret;
	unsigned long ret;

	ret = cos_sinv_2rets(uc, id, align, 0, 0, &addrret, &unused);
  409eb1:	41 89 fd             	mov    r13d,edi
{
  409eb4:	41 54                	push   r12
  409eb6:	53                   	push   rbx
  409eb7:	48 83 ec 28          	sub    rsp,0x28
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  409ebb:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  409ebf:	4d 85 f6             	test   r14,r14
  409ec2:	74 2c                	je     409ef0 <__cosrt_c_memmgr_shared_page_map_aligned+0x50>
  409ec4:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  409ec8:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  409ecc:	31 c9                	xor    ecx,ecx
  409ece:	31 d2                	xor    edx,edx
  409ed0:	4c 89 ef             	mov    rdi,r13
  409ed3:	41 ff d6             	call   r14
	*pgaddr = addrret;
  409ed6:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
	ret = cos_sinv_2rets(uc, id, align, 0, 0, &addrret, &unused);
  409eda:	48 98                	cdqe   
	*pgaddr = addrret;
  409edc:	49 89 17             	mov    QWORD PTR [r15],rdx

	return ret;
}
  409edf:	48 83 c4 28          	add    rsp,0x28
  409ee3:	5b                   	pop    rbx
  409ee4:	41 5c                	pop    r12
  409ee6:	41 5d                	pop    r13
  409ee8:	41 5e                	pop    r14
  409eea:	41 5f                	pop    r15
  409eec:	5d                   	pop    rbp
  409eed:	c3                   	ret    
  409eee:	66 90                	xchg   ax,ax
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  409ef0:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  409ef4:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  409ef8:	4c 89 eb             	mov    rbx,r13
  409efb:	4c 89 f7             	mov    rdi,r14
  409efe:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  409f01:	83 c0 01             	add    eax,0x1
  409f04:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  409f07:	48 89 29             	mov    QWORD PTR [rcx],rbp
  409f0a:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  409f0e:	48 89 cd             	mov    rbp,rcx
  409f11:	49 b8 28 9f 40 00 00 	movabs r8,0x409f28
  409f18:	00 00 00 
  409f1b:	0f 05                	syscall 
  409f1d:	0f 1f 00             	nop    DWORD PTR [rax]
  409f20:	eb 0f                	jmp    409f31 <__cosrt_c_memmgr_shared_page_map_aligned+0x91>
  409f22:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  409f28:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  409f2f:	eb 07                	jmp    409f38 <__cosrt_c_memmgr_shared_page_map_aligned+0x98>
  409f31:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  409f38:	5d                   	pop    rbp
  409f39:	5c                   	pop    rsp
  409f3a:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  409f3e:	eb 96                	jmp    409ed6 <__cosrt_c_memmgr_shared_page_map_aligned+0x36>

0000000000409f40 <__cosrt_c_memmgr_shared_page_map_aligned_in_vm>:

COS_CLIENT_STUB(unsigned long, memmgr_shared_page_map_aligned_in_vm, cbuf_t id, unsigned long align, vaddr_t *pgaddr, compid_t cid)
{
  409f40:	f3 0f 1e fa          	endbr64 
  409f44:	55                   	push   rbp
  409f45:	48 89 e5             	mov    rbp,rsp
  409f48:	41 57                	push   r15
	COS_CLIENT_INVCAP;
	word_t unused, addrret;
	unsigned long ret;

	ret = cos_sinv_2rets(uc, id, align, cid, 0, &addrret, &unused);
  409f4a:	41 89 ff             	mov    r15d,edi
{
  409f4d:	41 56                	push   r14
  409f4f:	41 55                	push   r13
  409f51:	49 89 cd             	mov    r13,rcx
  409f54:	41 54                	push   r12
  409f56:	53                   	push   rbx
  409f57:	48 83 ec 38          	sub    rsp,0x38
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  409f5b:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  409f5f:	48 89 55 a8          	mov    QWORD PTR [rbp-0x58],rdx
  409f63:	4d 85 f6             	test   r14,r14
  409f66:	74 38                	je     409fa0 <__cosrt_c_memmgr_shared_page_map_aligned_in_vm+0x60>
  409f68:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  409f6c:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  409f70:	31 c9                	xor    ecx,ecx
  409f72:	4c 89 ea             	mov    rdx,r13
  409f75:	4c 89 ff             	mov    rdi,r15
  409f78:	41 ff d6             	call   r14
	*pgaddr = addrret;
  409f7b:	48 8b 5d a8          	mov    rbx,QWORD PTR [rbp-0x58]
  409f7f:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
	ret = cos_sinv_2rets(uc, id, align, cid, 0, &addrret, &unused);
  409f83:	48 98                	cdqe   
	*pgaddr = addrret;
  409f85:	48 89 13             	mov    QWORD PTR [rbx],rdx

	return ret;
}
  409f88:	48 83 c4 38          	add    rsp,0x38
  409f8c:	5b                   	pop    rbx
  409f8d:	41 5c                	pop    r12
  409f8f:	41 5d                	pop    r13
  409f91:	41 5e                	pop    r14
  409f93:	41 5f                	pop    r15
  409f95:	5d                   	pop    rbp
  409f96:	c3                   	ret    
  409f97:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  409f9e:	00 00 
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  409fa0:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  409fa4:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  409fa8:	4c 89 fb             	mov    rbx,r15
  409fab:	4c 89 ef             	mov    rdi,r13
  409fae:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  409fb1:	83 c0 01             	add    eax,0x1
  409fb4:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  409fb7:	48 89 29             	mov    QWORD PTR [rcx],rbp
  409fba:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  409fbe:	48 89 cd             	mov    rbp,rcx
  409fc1:	49 b8 d8 9f 40 00 00 	movabs r8,0x409fd8
  409fc8:	00 00 00 
  409fcb:	0f 05                	syscall 
  409fcd:	0f 1f 00             	nop    DWORD PTR [rax]
  409fd0:	eb 0f                	jmp    409fe1 <__cosrt_c_memmgr_shared_page_map_aligned_in_vm+0xa1>
  409fd2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  409fd8:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  409fdf:	eb 07                	jmp    409fe8 <__cosrt_c_memmgr_shared_page_map_aligned_in_vm+0xa8>
  409fe1:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  409fe8:	5d                   	pop    rbp
  409fe9:	5c                   	pop    rsp
  409fea:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  409fee:	eb 8b                	jmp    409f7b <__cosrt_c_memmgr_shared_page_map_aligned_in_vm+0x3b>

0000000000409ff0 <__cosrt_extern_memmgr_heap_page_allocn>:
  409ff0:	48 b8 f4 02 46 00 00 	movabs rax,0x4602f4
  409ff7:	00 00 00 
  409ffa:	ff 10                	call   QWORD PTR [rax]
  409ffc:	c3                   	ret    
  409ffd:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040a000 <__cosrt_fast_callgate_memmgr_heap_page_allocn>:
  40a000:	55                   	push   rbp
  40a001:	41 55                	push   r13
  40a003:	41 56                	push   r14
  40a005:	41 57                	push   r15
  40a007:	49 89 c8             	mov    r8,rcx
  40a00a:	49 89 d1             	mov    r9,rdx
  40a00d:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40a014:	be ad de 
  40a017:	0f 01 f9             	rdtscp 
  40a01a:	48 89 c8             	mov    rax,rcx
  40a01d:	48 25 ff 0f 00 00    	and    rax,0xfff
  40a023:	48 89 e2             	mov    rdx,rsp
  40a026:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40a02d:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40a034:	00 
  40a035:	48 c1 e0 10          	shl    rax,0x10
  40a039:	49 09 c5             	or     r13,rax
  40a03c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40a043:	7f 00 00 
  40a046:	4c 89 e8             	mov    rax,r13
  40a049:	48 25 ff ff 00 00    	and    rax,0xffff
  40a04f:	48 c1 e0 08          	shl    rax,0x8
  40a053:	49 01 c6             	add    r14,rax
  40a056:	b9 01 00 00 00       	mov    ecx,0x1
  40a05b:	01 c9                	add    ecx,ecx
  40a05d:	b8 03 00 00 00       	mov    eax,0x3
  40a062:	d3 e0                	shl    eax,cl
  40a064:	f7 d0                	not    eax
  40a066:	83 e0 fc             	and    eax,0xfffffffc
  40a069:	48 31 c9             	xor    rcx,rcx
  40a06c:	48 31 d2             	xor    rdx,rdx
  40a06f:	0f 01 ef             	wrpkru 
  40a072:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40a075:	48 83 c2 01          	add    rdx,0x1
  40a079:	48 c1 e2 04          	shl    rdx,0x4
  40a07d:	4c 01 f2             	add    rdx,r14
  40a080:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  40a087:	45 23 01 
  40a08a:	48 89 02             	mov    QWORD PTR [rdx],rax
  40a08d:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  40a091:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40a094:	48 83 c0 01          	add    rax,0x1
  40a098:	49 89 06             	mov    QWORD PTR [r14],rax
  40a09b:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40a0a0:	01 c9                	add    ecx,ecx
  40a0a2:	b8 03 00 00 00       	mov    eax,0x3
  40a0a7:	d3 e0                	shl    eax,cl
  40a0a9:	f7 d0                	not    eax
  40a0ab:	83 e0 fc             	and    eax,0xfffffffc
  40a0ae:	48 31 c9             	xor    rcx,rcx
  40a0b1:	48 31 d2             	xor    rdx,rdx
  40a0b4:	0f 01 ef             	wrpkru 
  40a0b7:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  40a0be:	45 23 01 
  40a0c1:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40a0c8:	be ad de 
  40a0cb:	49 39 c7             	cmp    r15,rax
  40a0ce:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  40a0d5:	12 12 12 
  40a0d8:	48 b9 e4 a0 40 00 00 	movabs rcx,0x40a0e4
  40a0df:	00 00 00 
  40a0e2:	ff e0                	jmp    rax

000000000040a0e4 <srv_call_ret_memmgr_heap_page_allocn>:
  40a0e4:	49 89 c0             	mov    r8,rax
  40a0e7:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40a0ee:	be ad de 
  40a0f1:	48 89 e2             	mov    rdx,rsp
  40a0f4:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40a0fb:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40a102:	00 
  40a103:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40a10a:	7f 00 00 
  40a10d:	4c 89 e8             	mov    rax,r13
  40a110:	48 25 ff ff 00 00    	and    rax,0xffff
  40a116:	48 c1 e0 08          	shl    rax,0x8
  40a11a:	49 01 c6             	add    r14,rax
  40a11d:	b9 01 00 00 00       	mov    ecx,0x1
  40a122:	01 c9                	add    ecx,ecx
  40a124:	b8 03 00 00 00       	mov    eax,0x3
  40a129:	d3 e0                	shl    eax,cl
  40a12b:	f7 d0                	not    eax
  40a12d:	83 e0 fc             	and    eax,0xfffffffc
  40a130:	48 31 c9             	xor    rcx,rcx
  40a133:	48 31 d2             	xor    rdx,rdx
  40a136:	0f 01 ef             	wrpkru 
  40a139:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40a13c:	48 c1 e2 04          	shl    rdx,0x4
  40a140:	4c 01 f2             	add    rdx,r14
  40a143:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  40a147:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40a14a:	48 83 e8 01          	sub    rax,0x1
  40a14e:	49 89 06             	mov    QWORD PTR [r14],rax
  40a151:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40a156:	01 c9                	add    ecx,ecx
  40a158:	b8 03 00 00 00       	mov    eax,0x3
  40a15d:	d3 e0                	shl    eax,cl
  40a15f:	f7 d0                	not    eax
  40a161:	83 e0 fc             	and    eax,0xfffffffc
  40a164:	48 31 c9             	xor    rcx,rcx
  40a167:	48 31 d2             	xor    rdx,rdx
  40a16a:	0f 01 ef             	wrpkru 
  40a16d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40a174:	be ad de 
  40a177:	49 39 c7             	cmp    r15,rax
  40a17a:	4c 89 c0             	mov    rax,r8
  40a17d:	41 5f                	pop    r15
  40a17f:	41 5e                	pop    r14
  40a181:	41 5d                	pop    r13
  40a183:	5d                   	pop    rbp
  40a184:	c3                   	ret    
  40a185:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a18c:	00 00 00 00 

000000000040a190 <__cosrt_extern_memmgr_heap_page_allocn_aligned>:
  40a190:	48 b8 0c 03 46 00 00 	movabs rax,0x46030c
  40a197:	00 00 00 
  40a19a:	ff 10                	call   QWORD PTR [rax]
  40a19c:	c3                   	ret    
  40a19d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040a1a0 <__cosrt_fast_callgate_memmgr_heap_page_allocn_aligned>:
  40a1a0:	55                   	push   rbp
  40a1a1:	41 55                	push   r13
  40a1a3:	41 56                	push   r14
  40a1a5:	41 57                	push   r15
  40a1a7:	49 89 c8             	mov    r8,rcx
  40a1aa:	49 89 d1             	mov    r9,rdx
  40a1ad:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40a1b4:	be ad de 
  40a1b7:	0f 01 f9             	rdtscp 
  40a1ba:	48 89 c8             	mov    rax,rcx
  40a1bd:	48 25 ff 0f 00 00    	and    rax,0xfff
  40a1c3:	48 89 e2             	mov    rdx,rsp
  40a1c6:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40a1cd:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40a1d4:	00 
  40a1d5:	48 c1 e0 10          	shl    rax,0x10
  40a1d9:	49 09 c5             	or     r13,rax
  40a1dc:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40a1e3:	7f 00 00 
  40a1e6:	4c 89 e8             	mov    rax,r13
  40a1e9:	48 25 ff ff 00 00    	and    rax,0xffff
  40a1ef:	48 c1 e0 08          	shl    rax,0x8
  40a1f3:	49 01 c6             	add    r14,rax
  40a1f6:	b9 01 00 00 00       	mov    ecx,0x1
  40a1fb:	01 c9                	add    ecx,ecx
  40a1fd:	b8 03 00 00 00       	mov    eax,0x3
  40a202:	d3 e0                	shl    eax,cl
  40a204:	f7 d0                	not    eax
  40a206:	83 e0 fc             	and    eax,0xfffffffc
  40a209:	48 31 c9             	xor    rcx,rcx
  40a20c:	48 31 d2             	xor    rdx,rdx
  40a20f:	0f 01 ef             	wrpkru 
  40a212:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40a215:	48 83 c2 01          	add    rdx,0x1
  40a219:	48 c1 e2 04          	shl    rdx,0x4
  40a21d:	4c 01 f2             	add    rdx,r14
  40a220:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  40a227:	45 23 01 
  40a22a:	48 89 02             	mov    QWORD PTR [rdx],rax
  40a22d:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  40a231:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40a234:	48 83 c0 01          	add    rax,0x1
  40a238:	49 89 06             	mov    QWORD PTR [r14],rax
  40a23b:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40a240:	01 c9                	add    ecx,ecx
  40a242:	b8 03 00 00 00       	mov    eax,0x3
  40a247:	d3 e0                	shl    eax,cl
  40a249:	f7 d0                	not    eax
  40a24b:	83 e0 fc             	and    eax,0xfffffffc
  40a24e:	48 31 c9             	xor    rcx,rcx
  40a251:	48 31 d2             	xor    rdx,rdx
  40a254:	0f 01 ef             	wrpkru 
  40a257:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  40a25e:	45 23 01 
  40a261:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40a268:	be ad de 
  40a26b:	49 39 c7             	cmp    r15,rax
  40a26e:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  40a275:	12 12 12 
  40a278:	48 b9 84 a2 40 00 00 	movabs rcx,0x40a284
  40a27f:	00 00 00 
  40a282:	ff e0                	jmp    rax

000000000040a284 <srv_call_ret_memmgr_heap_page_allocn_aligned>:
  40a284:	49 89 c0             	mov    r8,rax
  40a287:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40a28e:	be ad de 
  40a291:	48 89 e2             	mov    rdx,rsp
  40a294:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40a29b:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40a2a2:	00 
  40a2a3:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40a2aa:	7f 00 00 
  40a2ad:	4c 89 e8             	mov    rax,r13
  40a2b0:	48 25 ff ff 00 00    	and    rax,0xffff
  40a2b6:	48 c1 e0 08          	shl    rax,0x8
  40a2ba:	49 01 c6             	add    r14,rax
  40a2bd:	b9 01 00 00 00       	mov    ecx,0x1
  40a2c2:	01 c9                	add    ecx,ecx
  40a2c4:	b8 03 00 00 00       	mov    eax,0x3
  40a2c9:	d3 e0                	shl    eax,cl
  40a2cb:	f7 d0                	not    eax
  40a2cd:	83 e0 fc             	and    eax,0xfffffffc
  40a2d0:	48 31 c9             	xor    rcx,rcx
  40a2d3:	48 31 d2             	xor    rdx,rdx
  40a2d6:	0f 01 ef             	wrpkru 
  40a2d9:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40a2dc:	48 c1 e2 04          	shl    rdx,0x4
  40a2e0:	4c 01 f2             	add    rdx,r14
  40a2e3:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  40a2e7:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40a2ea:	48 83 e8 01          	sub    rax,0x1
  40a2ee:	49 89 06             	mov    QWORD PTR [r14],rax
  40a2f1:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40a2f6:	01 c9                	add    ecx,ecx
  40a2f8:	b8 03 00 00 00       	mov    eax,0x3
  40a2fd:	d3 e0                	shl    eax,cl
  40a2ff:	f7 d0                	not    eax
  40a301:	83 e0 fc             	and    eax,0xfffffffc
  40a304:	48 31 c9             	xor    rcx,rcx
  40a307:	48 31 d2             	xor    rdx,rdx
  40a30a:	0f 01 ef             	wrpkru 
  40a30d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40a314:	be ad de 
  40a317:	49 39 c7             	cmp    r15,rax
  40a31a:	4c 89 c0             	mov    rax,r8
  40a31d:	41 5f                	pop    r15
  40a31f:	41 5e                	pop    r14
  40a321:	41 5d                	pop    r13
  40a323:	5d                   	pop    rbp
  40a324:	c3                   	ret    
  40a325:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a32c:	00 00 00 00 

000000000040a330 <__cosrt_extern_memmgr_virt_to_phys>:
  40a330:	48 b8 24 03 46 00 00 	movabs rax,0x460324
  40a337:	00 00 00 
  40a33a:	ff 10                	call   QWORD PTR [rax]
  40a33c:	c3                   	ret    
  40a33d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040a340 <__cosrt_fast_callgate_memmgr_virt_to_phys>:
  40a340:	55                   	push   rbp
  40a341:	41 55                	push   r13
  40a343:	41 56                	push   r14
  40a345:	41 57                	push   r15
  40a347:	49 89 c8             	mov    r8,rcx
  40a34a:	49 89 d1             	mov    r9,rdx
  40a34d:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40a354:	be ad de 
  40a357:	0f 01 f9             	rdtscp 
  40a35a:	48 89 c8             	mov    rax,rcx
  40a35d:	48 25 ff 0f 00 00    	and    rax,0xfff
  40a363:	48 89 e2             	mov    rdx,rsp
  40a366:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40a36d:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40a374:	00 
  40a375:	48 c1 e0 10          	shl    rax,0x10
  40a379:	49 09 c5             	or     r13,rax
  40a37c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40a383:	7f 00 00 
  40a386:	4c 89 e8             	mov    rax,r13
  40a389:	48 25 ff ff 00 00    	and    rax,0xffff
  40a38f:	48 c1 e0 08          	shl    rax,0x8
  40a393:	49 01 c6             	add    r14,rax
  40a396:	b9 01 00 00 00       	mov    ecx,0x1
  40a39b:	01 c9                	add    ecx,ecx
  40a39d:	b8 03 00 00 00       	mov    eax,0x3
  40a3a2:	d3 e0                	shl    eax,cl
  40a3a4:	f7 d0                	not    eax
  40a3a6:	83 e0 fc             	and    eax,0xfffffffc
  40a3a9:	48 31 c9             	xor    rcx,rcx
  40a3ac:	48 31 d2             	xor    rdx,rdx
  40a3af:	0f 01 ef             	wrpkru 
  40a3b2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40a3b5:	48 83 c2 01          	add    rdx,0x1
  40a3b9:	48 c1 e2 04          	shl    rdx,0x4
  40a3bd:	4c 01 f2             	add    rdx,r14
  40a3c0:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  40a3c7:	45 23 01 
  40a3ca:	48 89 02             	mov    QWORD PTR [rdx],rax
  40a3cd:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  40a3d1:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40a3d4:	48 83 c0 01          	add    rax,0x1
  40a3d8:	49 89 06             	mov    QWORD PTR [r14],rax
  40a3db:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40a3e0:	01 c9                	add    ecx,ecx
  40a3e2:	b8 03 00 00 00       	mov    eax,0x3
  40a3e7:	d3 e0                	shl    eax,cl
  40a3e9:	f7 d0                	not    eax
  40a3eb:	83 e0 fc             	and    eax,0xfffffffc
  40a3ee:	48 31 c9             	xor    rcx,rcx
  40a3f1:	48 31 d2             	xor    rdx,rdx
  40a3f4:	0f 01 ef             	wrpkru 
  40a3f7:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  40a3fe:	45 23 01 
  40a401:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40a408:	be ad de 
  40a40b:	49 39 c7             	cmp    r15,rax
  40a40e:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  40a415:	12 12 12 
  40a418:	48 b9 24 a4 40 00 00 	movabs rcx,0x40a424
  40a41f:	00 00 00 
  40a422:	ff e0                	jmp    rax

000000000040a424 <srv_call_ret_memmgr_virt_to_phys>:
  40a424:	49 89 c0             	mov    r8,rax
  40a427:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40a42e:	be ad de 
  40a431:	48 89 e2             	mov    rdx,rsp
  40a434:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40a43b:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40a442:	00 
  40a443:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40a44a:	7f 00 00 
  40a44d:	4c 89 e8             	mov    rax,r13
  40a450:	48 25 ff ff 00 00    	and    rax,0xffff
  40a456:	48 c1 e0 08          	shl    rax,0x8
  40a45a:	49 01 c6             	add    r14,rax
  40a45d:	b9 01 00 00 00       	mov    ecx,0x1
  40a462:	01 c9                	add    ecx,ecx
  40a464:	b8 03 00 00 00       	mov    eax,0x3
  40a469:	d3 e0                	shl    eax,cl
  40a46b:	f7 d0                	not    eax
  40a46d:	83 e0 fc             	and    eax,0xfffffffc
  40a470:	48 31 c9             	xor    rcx,rcx
  40a473:	48 31 d2             	xor    rdx,rdx
  40a476:	0f 01 ef             	wrpkru 
  40a479:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40a47c:	48 c1 e2 04          	shl    rdx,0x4
  40a480:	4c 01 f2             	add    rdx,r14
  40a483:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  40a487:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40a48a:	48 83 e8 01          	sub    rax,0x1
  40a48e:	49 89 06             	mov    QWORD PTR [r14],rax
  40a491:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40a496:	01 c9                	add    ecx,ecx
  40a498:	b8 03 00 00 00       	mov    eax,0x3
  40a49d:	d3 e0                	shl    eax,cl
  40a49f:	f7 d0                	not    eax
  40a4a1:	83 e0 fc             	and    eax,0xfffffffc
  40a4a4:	48 31 c9             	xor    rcx,rcx
  40a4a7:	48 31 d2             	xor    rdx,rdx
  40a4aa:	0f 01 ef             	wrpkru 
  40a4ad:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40a4b4:	be ad de 
  40a4b7:	49 39 c7             	cmp    r15,rax
  40a4ba:	4c 89 c0             	mov    rax,r8
  40a4bd:	41 5f                	pop    r15
  40a4bf:	41 5e                	pop    r14
  40a4c1:	41 5d                	pop    r13
  40a4c3:	5d                   	pop    rbp
  40a4c4:	c3                   	ret    
  40a4c5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a4cc:	00 00 00 00 

000000000040a4d0 <__cosrt_extern_memmgr_map_phys_to_virt>:
  40a4d0:	48 b8 3c 03 46 00 00 	movabs rax,0x46033c
  40a4d7:	00 00 00 
  40a4da:	ff 10                	call   QWORD PTR [rax]
  40a4dc:	c3                   	ret    
  40a4dd:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040a4e0 <__cosrt_fast_callgate_memmgr_map_phys_to_virt>:
  40a4e0:	55                   	push   rbp
  40a4e1:	41 55                	push   r13
  40a4e3:	41 56                	push   r14
  40a4e5:	41 57                	push   r15
  40a4e7:	49 89 c8             	mov    r8,rcx
  40a4ea:	49 89 d1             	mov    r9,rdx
  40a4ed:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40a4f4:	be ad de 
  40a4f7:	0f 01 f9             	rdtscp 
  40a4fa:	48 89 c8             	mov    rax,rcx
  40a4fd:	48 25 ff 0f 00 00    	and    rax,0xfff
  40a503:	48 89 e2             	mov    rdx,rsp
  40a506:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40a50d:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40a514:	00 
  40a515:	48 c1 e0 10          	shl    rax,0x10
  40a519:	49 09 c5             	or     r13,rax
  40a51c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40a523:	7f 00 00 
  40a526:	4c 89 e8             	mov    rax,r13
  40a529:	48 25 ff ff 00 00    	and    rax,0xffff
  40a52f:	48 c1 e0 08          	shl    rax,0x8
  40a533:	49 01 c6             	add    r14,rax
  40a536:	b9 01 00 00 00       	mov    ecx,0x1
  40a53b:	01 c9                	add    ecx,ecx
  40a53d:	b8 03 00 00 00       	mov    eax,0x3
  40a542:	d3 e0                	shl    eax,cl
  40a544:	f7 d0                	not    eax
  40a546:	83 e0 fc             	and    eax,0xfffffffc
  40a549:	48 31 c9             	xor    rcx,rcx
  40a54c:	48 31 d2             	xor    rdx,rdx
  40a54f:	0f 01 ef             	wrpkru 
  40a552:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40a555:	48 83 c2 01          	add    rdx,0x1
  40a559:	48 c1 e2 04          	shl    rdx,0x4
  40a55d:	4c 01 f2             	add    rdx,r14
  40a560:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  40a567:	45 23 01 
  40a56a:	48 89 02             	mov    QWORD PTR [rdx],rax
  40a56d:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  40a571:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40a574:	48 83 c0 01          	add    rax,0x1
  40a578:	49 89 06             	mov    QWORD PTR [r14],rax
  40a57b:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40a580:	01 c9                	add    ecx,ecx
  40a582:	b8 03 00 00 00       	mov    eax,0x3
  40a587:	d3 e0                	shl    eax,cl
  40a589:	f7 d0                	not    eax
  40a58b:	83 e0 fc             	and    eax,0xfffffffc
  40a58e:	48 31 c9             	xor    rcx,rcx
  40a591:	48 31 d2             	xor    rdx,rdx
  40a594:	0f 01 ef             	wrpkru 
  40a597:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  40a59e:	45 23 01 
  40a5a1:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40a5a8:	be ad de 
  40a5ab:	49 39 c7             	cmp    r15,rax
  40a5ae:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  40a5b5:	12 12 12 
  40a5b8:	48 b9 c4 a5 40 00 00 	movabs rcx,0x40a5c4
  40a5bf:	00 00 00 
  40a5c2:	ff e0                	jmp    rax

000000000040a5c4 <srv_call_ret_memmgr_map_phys_to_virt>:
  40a5c4:	49 89 c0             	mov    r8,rax
  40a5c7:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40a5ce:	be ad de 
  40a5d1:	48 89 e2             	mov    rdx,rsp
  40a5d4:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40a5db:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40a5e2:	00 
  40a5e3:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40a5ea:	7f 00 00 
  40a5ed:	4c 89 e8             	mov    rax,r13
  40a5f0:	48 25 ff ff 00 00    	and    rax,0xffff
  40a5f6:	48 c1 e0 08          	shl    rax,0x8
  40a5fa:	49 01 c6             	add    r14,rax
  40a5fd:	b9 01 00 00 00       	mov    ecx,0x1
  40a602:	01 c9                	add    ecx,ecx
  40a604:	b8 03 00 00 00       	mov    eax,0x3
  40a609:	d3 e0                	shl    eax,cl
  40a60b:	f7 d0                	not    eax
  40a60d:	83 e0 fc             	and    eax,0xfffffffc
  40a610:	48 31 c9             	xor    rcx,rcx
  40a613:	48 31 d2             	xor    rdx,rdx
  40a616:	0f 01 ef             	wrpkru 
  40a619:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40a61c:	48 c1 e2 04          	shl    rdx,0x4
  40a620:	4c 01 f2             	add    rdx,r14
  40a623:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  40a627:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40a62a:	48 83 e8 01          	sub    rax,0x1
  40a62e:	49 89 06             	mov    QWORD PTR [r14],rax
  40a631:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40a636:	01 c9                	add    ecx,ecx
  40a638:	b8 03 00 00 00       	mov    eax,0x3
  40a63d:	d3 e0                	shl    eax,cl
  40a63f:	f7 d0                	not    eax
  40a641:	83 e0 fc             	and    eax,0xfffffffc
  40a644:	48 31 c9             	xor    rcx,rcx
  40a647:	48 31 d2             	xor    rdx,rdx
  40a64a:	0f 01 ef             	wrpkru 
  40a64d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40a654:	be ad de 
  40a657:	49 39 c7             	cmp    r15,rax
  40a65a:	4c 89 c0             	mov    rax,r8
  40a65d:	41 5f                	pop    r15
  40a65f:	41 5e                	pop    r14
  40a661:	41 5d                	pop    r13
  40a663:	5d                   	pop    rbp
  40a664:	c3                   	ret    
  40a665:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a66c:	00 00 00 00 

000000000040a670 <__cosrt_extern_memmgr_shared_page_allocn>:
  40a670:	48 b8 54 03 46 00 00 	movabs rax,0x460354
  40a677:	00 00 00 
  40a67a:	ff 10                	call   QWORD PTR [rax]
  40a67c:	c3                   	ret    
  40a67d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040a680 <__cosrt_fast_callgate_memmgr_shared_page_allocn>:
  40a680:	55                   	push   rbp
  40a681:	53                   	push   rbx
  40a682:	41 54                	push   r12
  40a684:	41 55                	push   r13
  40a686:	41 56                	push   r14
  40a688:	41 57                	push   r15
  40a68a:	4d 89 c4             	mov    r12,r8
  40a68d:	4c 89 cb             	mov    rbx,r9
  40a690:	49 89 c8             	mov    r8,rcx
  40a693:	49 89 d1             	mov    r9,rdx
  40a696:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40a69d:	be ad de 
  40a6a0:	0f 01 f9             	rdtscp 
  40a6a3:	48 89 ca             	mov    rdx,rcx
  40a6a6:	48 25 ff 0f 00 00    	and    rax,0xfff
  40a6ac:	48 89 e2             	mov    rdx,rsp
  40a6af:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40a6b6:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40a6bd:	00 
  40a6be:	48 c1 e0 10          	shl    rax,0x10
  40a6c2:	49 09 c5             	or     r13,rax
  40a6c5:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40a6cc:	7f 00 00 
  40a6cf:	4c 89 e8             	mov    rax,r13
  40a6d2:	48 25 ff ff 00 00    	and    rax,0xffff
  40a6d8:	48 c1 e0 08          	shl    rax,0x8
  40a6dc:	49 01 c6             	add    r14,rax
  40a6df:	b9 01 00 00 00       	mov    ecx,0x1
  40a6e4:	01 c9                	add    ecx,ecx
  40a6e6:	b8 03 00 00 00       	mov    eax,0x3
  40a6eb:	d3 e0                	shl    eax,cl
  40a6ed:	f7 d0                	not    eax
  40a6ef:	83 e0 fc             	and    eax,0xfffffffc
  40a6f2:	48 31 c9             	xor    rcx,rcx
  40a6f5:	48 31 d2             	xor    rdx,rdx
  40a6f8:	0f 01 ef             	wrpkru 
  40a6fb:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40a6fe:	48 83 c2 01          	add    rdx,0x1
  40a702:	48 c1 e2 04          	shl    rdx,0x4
  40a706:	4c 01 f2             	add    rdx,r14
  40a709:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  40a710:	45 23 01 
  40a713:	48 89 02             	mov    QWORD PTR [rdx],rax
  40a716:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  40a71a:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40a71d:	48 83 c0 01          	add    rax,0x1
  40a721:	49 89 06             	mov    QWORD PTR [r14],rax
  40a724:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40a729:	01 c9                	add    ecx,ecx
  40a72b:	b8 03 00 00 00       	mov    eax,0x3
  40a730:	d3 e0                	shl    eax,cl
  40a732:	f7 d0                	not    eax
  40a734:	83 e0 fc             	and    eax,0xfffffffc
  40a737:	48 31 c9             	xor    rcx,rcx
  40a73a:	48 31 d2             	xor    rdx,rdx
  40a73d:	0f 01 ef             	wrpkru 
  40a740:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  40a747:	45 23 01 
  40a74a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40a751:	be ad de 
  40a754:	49 39 c7             	cmp    r15,rax
  40a757:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  40a75e:	12 12 12 
  40a761:	48 b9 6d a7 40 00 00 	movabs rcx,0x40a76d
  40a768:	00 00 00 
  40a76b:	ff e0                	jmp    rax

000000000040a76d <srv_call_ret_memmgr_shared_page_allocn>:
  40a76d:	49 89 c0             	mov    r8,rax
  40a770:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40a777:	be ad de 
  40a77a:	48 89 e2             	mov    rdx,rsp
  40a77d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40a784:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40a78b:	00 
  40a78c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40a793:	7f 00 00 
  40a796:	4c 89 e8             	mov    rax,r13
  40a799:	48 25 ff ff 00 00    	and    rax,0xffff
  40a79f:	48 c1 e0 08          	shl    rax,0x8
  40a7a3:	49 01 c6             	add    r14,rax
  40a7a6:	b9 01 00 00 00       	mov    ecx,0x1
  40a7ab:	01 c9                	add    ecx,ecx
  40a7ad:	b8 03 00 00 00       	mov    eax,0x3
  40a7b2:	d3 e0                	shl    eax,cl
  40a7b4:	f7 d0                	not    eax
  40a7b6:	83 e0 fc             	and    eax,0xfffffffc
  40a7b9:	48 31 c9             	xor    rcx,rcx
  40a7bc:	48 31 d2             	xor    rdx,rdx
  40a7bf:	0f 01 ef             	wrpkru 
  40a7c2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40a7c5:	48 c1 e2 04          	shl    rdx,0x4
  40a7c9:	4c 01 f2             	add    rdx,r14
  40a7cc:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  40a7d0:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40a7d3:	48 83 e8 01          	sub    rax,0x1
  40a7d7:	49 89 06             	mov    QWORD PTR [r14],rax
  40a7da:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40a7df:	01 c9                	add    ecx,ecx
  40a7e1:	b8 03 00 00 00       	mov    eax,0x3
  40a7e6:	d3 e0                	shl    eax,cl
  40a7e8:	f7 d0                	not    eax
  40a7ea:	83 e0 fc             	and    eax,0xfffffffc
  40a7ed:	48 31 c9             	xor    rcx,rcx
  40a7f0:	48 31 d2             	xor    rdx,rdx
  40a7f3:	0f 01 ef             	wrpkru 
  40a7f6:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40a7fd:	be ad de 
  40a800:	49 39 c7             	cmp    r15,rax
  40a803:	4c 89 c0             	mov    rax,r8
  40a806:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  40a80a:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  40a80d:	41 5f                	pop    r15
  40a80f:	41 5e                	pop    r14
  40a811:	41 5d                	pop    r13
  40a813:	41 5c                	pop    r12
  40a815:	5b                   	pop    rbx
  40a816:	5d                   	pop    rbp
  40a817:	c3                   	ret    
  40a818:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40a81f:	00 

000000000040a820 <__cosrt_extern_memmgr_shared_page_allocn_aligned>:
  40a820:	48 b8 6c 03 46 00 00 	movabs rax,0x46036c
  40a827:	00 00 00 
  40a82a:	ff 10                	call   QWORD PTR [rax]
  40a82c:	c3                   	ret    
  40a82d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040a830 <__cosrt_fast_callgate_memmgr_shared_page_allocn_aligned>:
  40a830:	55                   	push   rbp
  40a831:	53                   	push   rbx
  40a832:	41 54                	push   r12
  40a834:	41 55                	push   r13
  40a836:	41 56                	push   r14
  40a838:	41 57                	push   r15
  40a83a:	4d 89 c4             	mov    r12,r8
  40a83d:	4c 89 cb             	mov    rbx,r9
  40a840:	49 89 c8             	mov    r8,rcx
  40a843:	49 89 d1             	mov    r9,rdx
  40a846:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40a84d:	be ad de 
  40a850:	0f 01 f9             	rdtscp 
  40a853:	48 89 ca             	mov    rdx,rcx
  40a856:	48 25 ff 0f 00 00    	and    rax,0xfff
  40a85c:	48 89 e2             	mov    rdx,rsp
  40a85f:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40a866:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40a86d:	00 
  40a86e:	48 c1 e0 10          	shl    rax,0x10
  40a872:	49 09 c5             	or     r13,rax
  40a875:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40a87c:	7f 00 00 
  40a87f:	4c 89 e8             	mov    rax,r13
  40a882:	48 25 ff ff 00 00    	and    rax,0xffff
  40a888:	48 c1 e0 08          	shl    rax,0x8
  40a88c:	49 01 c6             	add    r14,rax
  40a88f:	b9 01 00 00 00       	mov    ecx,0x1
  40a894:	01 c9                	add    ecx,ecx
  40a896:	b8 03 00 00 00       	mov    eax,0x3
  40a89b:	d3 e0                	shl    eax,cl
  40a89d:	f7 d0                	not    eax
  40a89f:	83 e0 fc             	and    eax,0xfffffffc
  40a8a2:	48 31 c9             	xor    rcx,rcx
  40a8a5:	48 31 d2             	xor    rdx,rdx
  40a8a8:	0f 01 ef             	wrpkru 
  40a8ab:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40a8ae:	48 83 c2 01          	add    rdx,0x1
  40a8b2:	48 c1 e2 04          	shl    rdx,0x4
  40a8b6:	4c 01 f2             	add    rdx,r14
  40a8b9:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  40a8c0:	45 23 01 
  40a8c3:	48 89 02             	mov    QWORD PTR [rdx],rax
  40a8c6:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  40a8ca:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40a8cd:	48 83 c0 01          	add    rax,0x1
  40a8d1:	49 89 06             	mov    QWORD PTR [r14],rax
  40a8d4:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40a8d9:	01 c9                	add    ecx,ecx
  40a8db:	b8 03 00 00 00       	mov    eax,0x3
  40a8e0:	d3 e0                	shl    eax,cl
  40a8e2:	f7 d0                	not    eax
  40a8e4:	83 e0 fc             	and    eax,0xfffffffc
  40a8e7:	48 31 c9             	xor    rcx,rcx
  40a8ea:	48 31 d2             	xor    rdx,rdx
  40a8ed:	0f 01 ef             	wrpkru 
  40a8f0:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  40a8f7:	45 23 01 
  40a8fa:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40a901:	be ad de 
  40a904:	49 39 c7             	cmp    r15,rax
  40a907:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  40a90e:	12 12 12 
  40a911:	48 b9 1d a9 40 00 00 	movabs rcx,0x40a91d
  40a918:	00 00 00 
  40a91b:	ff e0                	jmp    rax

000000000040a91d <srv_call_ret_memmgr_shared_page_allocn_aligned>:
  40a91d:	49 89 c0             	mov    r8,rax
  40a920:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40a927:	be ad de 
  40a92a:	48 89 e2             	mov    rdx,rsp
  40a92d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40a934:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40a93b:	00 
  40a93c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40a943:	7f 00 00 
  40a946:	4c 89 e8             	mov    rax,r13
  40a949:	48 25 ff ff 00 00    	and    rax,0xffff
  40a94f:	48 c1 e0 08          	shl    rax,0x8
  40a953:	49 01 c6             	add    r14,rax
  40a956:	b9 01 00 00 00       	mov    ecx,0x1
  40a95b:	01 c9                	add    ecx,ecx
  40a95d:	b8 03 00 00 00       	mov    eax,0x3
  40a962:	d3 e0                	shl    eax,cl
  40a964:	f7 d0                	not    eax
  40a966:	83 e0 fc             	and    eax,0xfffffffc
  40a969:	48 31 c9             	xor    rcx,rcx
  40a96c:	48 31 d2             	xor    rdx,rdx
  40a96f:	0f 01 ef             	wrpkru 
  40a972:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40a975:	48 c1 e2 04          	shl    rdx,0x4
  40a979:	4c 01 f2             	add    rdx,r14
  40a97c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  40a980:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40a983:	48 83 e8 01          	sub    rax,0x1
  40a987:	49 89 06             	mov    QWORD PTR [r14],rax
  40a98a:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40a98f:	01 c9                	add    ecx,ecx
  40a991:	b8 03 00 00 00       	mov    eax,0x3
  40a996:	d3 e0                	shl    eax,cl
  40a998:	f7 d0                	not    eax
  40a99a:	83 e0 fc             	and    eax,0xfffffffc
  40a99d:	48 31 c9             	xor    rcx,rcx
  40a9a0:	48 31 d2             	xor    rdx,rdx
  40a9a3:	0f 01 ef             	wrpkru 
  40a9a6:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40a9ad:	be ad de 
  40a9b0:	49 39 c7             	cmp    r15,rax
  40a9b3:	4c 89 c0             	mov    rax,r8
  40a9b6:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  40a9ba:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  40a9bd:	41 5f                	pop    r15
  40a9bf:	41 5e                	pop    r14
  40a9c1:	41 5d                	pop    r13
  40a9c3:	41 5c                	pop    r12
  40a9c5:	5b                   	pop    rbx
  40a9c6:	5d                   	pop    rbp
  40a9c7:	c3                   	ret    
  40a9c8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40a9cf:	00 

000000000040a9d0 <__cosrt_extern_memmgr_shared_page_map>:
  40a9d0:	48 b8 84 03 46 00 00 	movabs rax,0x460384
  40a9d7:	00 00 00 
  40a9da:	ff 10                	call   QWORD PTR [rax]
  40a9dc:	c3                   	ret    
  40a9dd:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040a9e0 <__cosrt_fast_callgate_memmgr_shared_page_map>:
  40a9e0:	55                   	push   rbp
  40a9e1:	53                   	push   rbx
  40a9e2:	41 54                	push   r12
  40a9e4:	41 55                	push   r13
  40a9e6:	41 56                	push   r14
  40a9e8:	41 57                	push   r15
  40a9ea:	4d 89 c4             	mov    r12,r8
  40a9ed:	4c 89 cb             	mov    rbx,r9
  40a9f0:	49 89 c8             	mov    r8,rcx
  40a9f3:	49 89 d1             	mov    r9,rdx
  40a9f6:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40a9fd:	be ad de 
  40aa00:	0f 01 f9             	rdtscp 
  40aa03:	48 89 ca             	mov    rdx,rcx
  40aa06:	48 25 ff 0f 00 00    	and    rax,0xfff
  40aa0c:	48 89 e2             	mov    rdx,rsp
  40aa0f:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40aa16:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40aa1d:	00 
  40aa1e:	48 c1 e0 10          	shl    rax,0x10
  40aa22:	49 09 c5             	or     r13,rax
  40aa25:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40aa2c:	7f 00 00 
  40aa2f:	4c 89 e8             	mov    rax,r13
  40aa32:	48 25 ff ff 00 00    	and    rax,0xffff
  40aa38:	48 c1 e0 08          	shl    rax,0x8
  40aa3c:	49 01 c6             	add    r14,rax
  40aa3f:	b9 01 00 00 00       	mov    ecx,0x1
  40aa44:	01 c9                	add    ecx,ecx
  40aa46:	b8 03 00 00 00       	mov    eax,0x3
  40aa4b:	d3 e0                	shl    eax,cl
  40aa4d:	f7 d0                	not    eax
  40aa4f:	83 e0 fc             	and    eax,0xfffffffc
  40aa52:	48 31 c9             	xor    rcx,rcx
  40aa55:	48 31 d2             	xor    rdx,rdx
  40aa58:	0f 01 ef             	wrpkru 
  40aa5b:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40aa5e:	48 83 c2 01          	add    rdx,0x1
  40aa62:	48 c1 e2 04          	shl    rdx,0x4
  40aa66:	4c 01 f2             	add    rdx,r14
  40aa69:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  40aa70:	45 23 01 
  40aa73:	48 89 02             	mov    QWORD PTR [rdx],rax
  40aa76:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  40aa7a:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40aa7d:	48 83 c0 01          	add    rax,0x1
  40aa81:	49 89 06             	mov    QWORD PTR [r14],rax
  40aa84:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40aa89:	01 c9                	add    ecx,ecx
  40aa8b:	b8 03 00 00 00       	mov    eax,0x3
  40aa90:	d3 e0                	shl    eax,cl
  40aa92:	f7 d0                	not    eax
  40aa94:	83 e0 fc             	and    eax,0xfffffffc
  40aa97:	48 31 c9             	xor    rcx,rcx
  40aa9a:	48 31 d2             	xor    rdx,rdx
  40aa9d:	0f 01 ef             	wrpkru 
  40aaa0:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  40aaa7:	45 23 01 
  40aaaa:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40aab1:	be ad de 
  40aab4:	49 39 c7             	cmp    r15,rax
  40aab7:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  40aabe:	12 12 12 
  40aac1:	48 b9 cd aa 40 00 00 	movabs rcx,0x40aacd
  40aac8:	00 00 00 
  40aacb:	ff e0                	jmp    rax

000000000040aacd <srv_call_ret_memmgr_shared_page_map>:
  40aacd:	49 89 c0             	mov    r8,rax
  40aad0:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40aad7:	be ad de 
  40aada:	48 89 e2             	mov    rdx,rsp
  40aadd:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40aae4:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40aaeb:	00 
  40aaec:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40aaf3:	7f 00 00 
  40aaf6:	4c 89 e8             	mov    rax,r13
  40aaf9:	48 25 ff ff 00 00    	and    rax,0xffff
  40aaff:	48 c1 e0 08          	shl    rax,0x8
  40ab03:	49 01 c6             	add    r14,rax
  40ab06:	b9 01 00 00 00       	mov    ecx,0x1
  40ab0b:	01 c9                	add    ecx,ecx
  40ab0d:	b8 03 00 00 00       	mov    eax,0x3
  40ab12:	d3 e0                	shl    eax,cl
  40ab14:	f7 d0                	not    eax
  40ab16:	83 e0 fc             	and    eax,0xfffffffc
  40ab19:	48 31 c9             	xor    rcx,rcx
  40ab1c:	48 31 d2             	xor    rdx,rdx
  40ab1f:	0f 01 ef             	wrpkru 
  40ab22:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40ab25:	48 c1 e2 04          	shl    rdx,0x4
  40ab29:	4c 01 f2             	add    rdx,r14
  40ab2c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  40ab30:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40ab33:	48 83 e8 01          	sub    rax,0x1
  40ab37:	49 89 06             	mov    QWORD PTR [r14],rax
  40ab3a:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40ab3f:	01 c9                	add    ecx,ecx
  40ab41:	b8 03 00 00 00       	mov    eax,0x3
  40ab46:	d3 e0                	shl    eax,cl
  40ab48:	f7 d0                	not    eax
  40ab4a:	83 e0 fc             	and    eax,0xfffffffc
  40ab4d:	48 31 c9             	xor    rcx,rcx
  40ab50:	48 31 d2             	xor    rdx,rdx
  40ab53:	0f 01 ef             	wrpkru 
  40ab56:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40ab5d:	be ad de 
  40ab60:	49 39 c7             	cmp    r15,rax
  40ab63:	4c 89 c0             	mov    rax,r8
  40ab66:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  40ab6a:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  40ab6d:	41 5f                	pop    r15
  40ab6f:	41 5e                	pop    r14
  40ab71:	41 5d                	pop    r13
  40ab73:	41 5c                	pop    r12
  40ab75:	5b                   	pop    rbx
  40ab76:	5d                   	pop    rbp
  40ab77:	c3                   	ret    
  40ab78:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40ab7f:	00 

000000000040ab80 <__cosrt_extern_memmgr_shared_page_map_aligned>:
  40ab80:	48 b8 9c 03 46 00 00 	movabs rax,0x46039c
  40ab87:	00 00 00 
  40ab8a:	ff 10                	call   QWORD PTR [rax]
  40ab8c:	c3                   	ret    
  40ab8d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040ab90 <__cosrt_fast_callgate_memmgr_shared_page_map_aligned>:
  40ab90:	55                   	push   rbp
  40ab91:	53                   	push   rbx
  40ab92:	41 54                	push   r12
  40ab94:	41 55                	push   r13
  40ab96:	41 56                	push   r14
  40ab98:	41 57                	push   r15
  40ab9a:	4d 89 c4             	mov    r12,r8
  40ab9d:	4c 89 cb             	mov    rbx,r9
  40aba0:	49 89 c8             	mov    r8,rcx
  40aba3:	49 89 d1             	mov    r9,rdx
  40aba6:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40abad:	be ad de 
  40abb0:	0f 01 f9             	rdtscp 
  40abb3:	48 89 ca             	mov    rdx,rcx
  40abb6:	48 25 ff 0f 00 00    	and    rax,0xfff
  40abbc:	48 89 e2             	mov    rdx,rsp
  40abbf:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40abc6:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40abcd:	00 
  40abce:	48 c1 e0 10          	shl    rax,0x10
  40abd2:	49 09 c5             	or     r13,rax
  40abd5:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40abdc:	7f 00 00 
  40abdf:	4c 89 e8             	mov    rax,r13
  40abe2:	48 25 ff ff 00 00    	and    rax,0xffff
  40abe8:	48 c1 e0 08          	shl    rax,0x8
  40abec:	49 01 c6             	add    r14,rax
  40abef:	b9 01 00 00 00       	mov    ecx,0x1
  40abf4:	01 c9                	add    ecx,ecx
  40abf6:	b8 03 00 00 00       	mov    eax,0x3
  40abfb:	d3 e0                	shl    eax,cl
  40abfd:	f7 d0                	not    eax
  40abff:	83 e0 fc             	and    eax,0xfffffffc
  40ac02:	48 31 c9             	xor    rcx,rcx
  40ac05:	48 31 d2             	xor    rdx,rdx
  40ac08:	0f 01 ef             	wrpkru 
  40ac0b:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40ac0e:	48 83 c2 01          	add    rdx,0x1
  40ac12:	48 c1 e2 04          	shl    rdx,0x4
  40ac16:	4c 01 f2             	add    rdx,r14
  40ac19:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  40ac20:	45 23 01 
  40ac23:	48 89 02             	mov    QWORD PTR [rdx],rax
  40ac26:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  40ac2a:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40ac2d:	48 83 c0 01          	add    rax,0x1
  40ac31:	49 89 06             	mov    QWORD PTR [r14],rax
  40ac34:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40ac39:	01 c9                	add    ecx,ecx
  40ac3b:	b8 03 00 00 00       	mov    eax,0x3
  40ac40:	d3 e0                	shl    eax,cl
  40ac42:	f7 d0                	not    eax
  40ac44:	83 e0 fc             	and    eax,0xfffffffc
  40ac47:	48 31 c9             	xor    rcx,rcx
  40ac4a:	48 31 d2             	xor    rdx,rdx
  40ac4d:	0f 01 ef             	wrpkru 
  40ac50:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  40ac57:	45 23 01 
  40ac5a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40ac61:	be ad de 
  40ac64:	49 39 c7             	cmp    r15,rax
  40ac67:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  40ac6e:	12 12 12 
  40ac71:	48 b9 7d ac 40 00 00 	movabs rcx,0x40ac7d
  40ac78:	00 00 00 
  40ac7b:	ff e0                	jmp    rax

000000000040ac7d <srv_call_ret_memmgr_shared_page_map_aligned>:
  40ac7d:	49 89 c0             	mov    r8,rax
  40ac80:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40ac87:	be ad de 
  40ac8a:	48 89 e2             	mov    rdx,rsp
  40ac8d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40ac94:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40ac9b:	00 
  40ac9c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40aca3:	7f 00 00 
  40aca6:	4c 89 e8             	mov    rax,r13
  40aca9:	48 25 ff ff 00 00    	and    rax,0xffff
  40acaf:	48 c1 e0 08          	shl    rax,0x8
  40acb3:	49 01 c6             	add    r14,rax
  40acb6:	b9 01 00 00 00       	mov    ecx,0x1
  40acbb:	01 c9                	add    ecx,ecx
  40acbd:	b8 03 00 00 00       	mov    eax,0x3
  40acc2:	d3 e0                	shl    eax,cl
  40acc4:	f7 d0                	not    eax
  40acc6:	83 e0 fc             	and    eax,0xfffffffc
  40acc9:	48 31 c9             	xor    rcx,rcx
  40accc:	48 31 d2             	xor    rdx,rdx
  40accf:	0f 01 ef             	wrpkru 
  40acd2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40acd5:	48 c1 e2 04          	shl    rdx,0x4
  40acd9:	4c 01 f2             	add    rdx,r14
  40acdc:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  40ace0:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40ace3:	48 83 e8 01          	sub    rax,0x1
  40ace7:	49 89 06             	mov    QWORD PTR [r14],rax
  40acea:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40acef:	01 c9                	add    ecx,ecx
  40acf1:	b8 03 00 00 00       	mov    eax,0x3
  40acf6:	d3 e0                	shl    eax,cl
  40acf8:	f7 d0                	not    eax
  40acfa:	83 e0 fc             	and    eax,0xfffffffc
  40acfd:	48 31 c9             	xor    rcx,rcx
  40ad00:	48 31 d2             	xor    rdx,rdx
  40ad03:	0f 01 ef             	wrpkru 
  40ad06:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40ad0d:	be ad de 
  40ad10:	49 39 c7             	cmp    r15,rax
  40ad13:	4c 89 c0             	mov    rax,r8
  40ad16:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  40ad1a:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  40ad1d:	41 5f                	pop    r15
  40ad1f:	41 5e                	pop    r14
  40ad21:	41 5d                	pop    r13
  40ad23:	41 5c                	pop    r12
  40ad25:	5b                   	pop    rbx
  40ad26:	5d                   	pop    rbp
  40ad27:	c3                   	ret    
  40ad28:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40ad2f:	00 

000000000040ad30 <__cosrt_extern_memmgr_shared_page_map_aligned_in_vm>:
  40ad30:	48 b8 b4 03 46 00 00 	movabs rax,0x4603b4
  40ad37:	00 00 00 
  40ad3a:	ff 10                	call   QWORD PTR [rax]
  40ad3c:	c3                   	ret    
  40ad3d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040ad40 <__cosrt_fast_callgate_memmgr_shared_page_map_aligned_in_vm>:
  40ad40:	55                   	push   rbp
  40ad41:	53                   	push   rbx
  40ad42:	41 54                	push   r12
  40ad44:	41 55                	push   r13
  40ad46:	41 56                	push   r14
  40ad48:	41 57                	push   r15
  40ad4a:	4d 89 c4             	mov    r12,r8
  40ad4d:	4c 89 cb             	mov    rbx,r9
  40ad50:	49 89 c8             	mov    r8,rcx
  40ad53:	49 89 d1             	mov    r9,rdx
  40ad56:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40ad5d:	be ad de 
  40ad60:	0f 01 f9             	rdtscp 
  40ad63:	48 89 ca             	mov    rdx,rcx
  40ad66:	48 25 ff 0f 00 00    	and    rax,0xfff
  40ad6c:	48 89 e2             	mov    rdx,rsp
  40ad6f:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40ad76:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40ad7d:	00 
  40ad7e:	48 c1 e0 10          	shl    rax,0x10
  40ad82:	49 09 c5             	or     r13,rax
  40ad85:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40ad8c:	7f 00 00 
  40ad8f:	4c 89 e8             	mov    rax,r13
  40ad92:	48 25 ff ff 00 00    	and    rax,0xffff
  40ad98:	48 c1 e0 08          	shl    rax,0x8
  40ad9c:	49 01 c6             	add    r14,rax
  40ad9f:	b9 01 00 00 00       	mov    ecx,0x1
  40ada4:	01 c9                	add    ecx,ecx
  40ada6:	b8 03 00 00 00       	mov    eax,0x3
  40adab:	d3 e0                	shl    eax,cl
  40adad:	f7 d0                	not    eax
  40adaf:	83 e0 fc             	and    eax,0xfffffffc
  40adb2:	48 31 c9             	xor    rcx,rcx
  40adb5:	48 31 d2             	xor    rdx,rdx
  40adb8:	0f 01 ef             	wrpkru 
  40adbb:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40adbe:	48 83 c2 01          	add    rdx,0x1
  40adc2:	48 c1 e2 04          	shl    rdx,0x4
  40adc6:	4c 01 f2             	add    rdx,r14
  40adc9:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  40add0:	45 23 01 
  40add3:	48 89 02             	mov    QWORD PTR [rdx],rax
  40add6:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  40adda:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40addd:	48 83 c0 01          	add    rax,0x1
  40ade1:	49 89 06             	mov    QWORD PTR [r14],rax
  40ade4:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40ade9:	01 c9                	add    ecx,ecx
  40adeb:	b8 03 00 00 00       	mov    eax,0x3
  40adf0:	d3 e0                	shl    eax,cl
  40adf2:	f7 d0                	not    eax
  40adf4:	83 e0 fc             	and    eax,0xfffffffc
  40adf7:	48 31 c9             	xor    rcx,rcx
  40adfa:	48 31 d2             	xor    rdx,rdx
  40adfd:	0f 01 ef             	wrpkru 
  40ae00:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  40ae07:	45 23 01 
  40ae0a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40ae11:	be ad de 
  40ae14:	49 39 c7             	cmp    r15,rax
  40ae17:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  40ae1e:	12 12 12 
  40ae21:	48 b9 2d ae 40 00 00 	movabs rcx,0x40ae2d
  40ae28:	00 00 00 
  40ae2b:	ff e0                	jmp    rax

000000000040ae2d <srv_call_ret_memmgr_shared_page_map_aligned_in_vm>:
  40ae2d:	49 89 c0             	mov    r8,rax
  40ae30:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40ae37:	be ad de 
  40ae3a:	48 89 e2             	mov    rdx,rsp
  40ae3d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40ae44:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40ae4b:	00 
  40ae4c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40ae53:	7f 00 00 
  40ae56:	4c 89 e8             	mov    rax,r13
  40ae59:	48 25 ff ff 00 00    	and    rax,0xffff
  40ae5f:	48 c1 e0 08          	shl    rax,0x8
  40ae63:	49 01 c6             	add    r14,rax
  40ae66:	b9 01 00 00 00       	mov    ecx,0x1
  40ae6b:	01 c9                	add    ecx,ecx
  40ae6d:	b8 03 00 00 00       	mov    eax,0x3
  40ae72:	d3 e0                	shl    eax,cl
  40ae74:	f7 d0                	not    eax
  40ae76:	83 e0 fc             	and    eax,0xfffffffc
  40ae79:	48 31 c9             	xor    rcx,rcx
  40ae7c:	48 31 d2             	xor    rdx,rdx
  40ae7f:	0f 01 ef             	wrpkru 
  40ae82:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40ae85:	48 c1 e2 04          	shl    rdx,0x4
  40ae89:	4c 01 f2             	add    rdx,r14
  40ae8c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  40ae90:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40ae93:	48 83 e8 01          	sub    rax,0x1
  40ae97:	49 89 06             	mov    QWORD PTR [r14],rax
  40ae9a:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40ae9f:	01 c9                	add    ecx,ecx
  40aea1:	b8 03 00 00 00       	mov    eax,0x3
  40aea6:	d3 e0                	shl    eax,cl
  40aea8:	f7 d0                	not    eax
  40aeaa:	83 e0 fc             	and    eax,0xfffffffc
  40aead:	48 31 c9             	xor    rcx,rcx
  40aeb0:	48 31 d2             	xor    rdx,rdx
  40aeb3:	0f 01 ef             	wrpkru 
  40aeb6:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40aebd:	be ad de 
  40aec0:	49 39 c7             	cmp    r15,rax
  40aec3:	4c 89 c0             	mov    rax,r8
  40aec6:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  40aeca:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  40aecd:	41 5f                	pop    r15
  40aecf:	41 5e                	pop    r14
  40aed1:	41 5d                	pop    r13
  40aed3:	41 5c                	pop    r12
  40aed5:	5b                   	pop    rbx
  40aed6:	5d                   	pop    rbp
  40aed7:	c3                   	ret    
  40aed8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40aedf:	00 

000000000040aee0 <init_parallelism>:
 * functions) are found in the c files in this directory. They
 * generate a .a static library that is linked on-demand.
 */
int
init_parallelism(void)
{
  40aee0:	f3 0f 1e fa          	endbr64 
	return NUM_CPU;
}
  40aee4:	b8 01 00 00 00       	mov    eax,0x1
  40aee9:	c3                   	ret    
  40aeea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000040aef0 <cos_aepthd_fn>:
	struct cos_aep_info sched_aep[NUM_CPU];
};

static void
cos_aepthd_fn(void *data)
{
  40aef0:	f3 0f 1e fa          	endbr64 
  40aef4:	55                   	push   rbp
  40aef5:	48 89 f8             	mov    rax,rdi
	struct cos_aep_info *aep_info = (struct cos_aep_info *)data;
	cos_aepthd_fn_t      aep_fn   = aep_info->fn;
	void *               fn_data  = aep_info->data;

	(aep_fn)(aep_info->rcv, fn_data);
  40aef8:	48 8b 77 28          	mov    rsi,QWORD PTR [rdi+0x28]
  40aefc:	48 8b 7f 18          	mov    rdi,QWORD PTR [rdi+0x18]
{
  40af00:	48 89 e5             	mov    rbp,rsp
	(aep_fn)(aep_info->rcv, fn_data);
  40af03:	ff 50 20             	call   QWORD PTR [rax+0x20]
  40af06:	be 69 00 00 00       	mov    esi,0x69
  40af0b:	48 bf b0 fa 41 00 00 	movabs rdi,0x41fab0
  40af12:	00 00 00 
  40af15:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40af1c:	00 00 00 
  40af1f:	ff d0                	call   rax

	/* TODO: handling destruction */
	assert(0);
  40af21:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40af28:	00 00 00 00 
  40af2c:	0f 0b                	ud2    
  40af2e:	66 90                	xchg   ax,ax

000000000040af30 <capmgr_thd_create>:
#include <capmgr.h>
#include <cos_thd_init.h>

thdcap_t
capmgr_thd_create(cos_thd_fn_t fn, void *data, thdid_t *tid)
{
  40af30:	f3 0f 1e fa          	endbr64 

/* See comments of cos_thd_create_remote. */
static thdclosure_index_t
cos_thd_init_alloc(void *fn, void *data)
{
	if (!fn) return -1;
  40af34:	48 85 ff             	test   rdi,rdi
  40af37:	0f 84 aa 00 00 00    	je     40afe7 <capmgr_thd_create+0xb7>
  40af3d:	49 89 f1             	mov    r9,rsi
  40af40:	49 89 f8             	mov    r8,rdi
  40af43:	48 89 d6             	mov    rsi,rdx
  40af46:	41 ba 02 00 00 00    	mov    r10d,0x2
static inline int
cos_cas(unsigned long *target, unsigned long old, unsigned long updated)
{
	char z;
	#if defined(__x86_64__)
	__asm__ __volatile__("lock cmpxchgq %2, %0; setz %1"
  40af4c:	31 d2                	xor    edx,edx
	for (i = 0; i < COS_THD_INIT_REGION_SIZE; i++) {
  40af4e:	48 b9 40 39 5a 00 00 	movabs rcx,0x5a3940
  40af55:	00 00 00 
  40af58:	31 ff                	xor    edi,edi
		if (__thd_init_data[i].fn == NULL) {
  40af5a:	48 83 39 00          	cmp    QWORD PTR [rcx],0x0
  40af5e:	74 20                	je     40af80 <capmgr_thd_create+0x50>
	for (i = 0; i < COS_THD_INIT_REGION_SIZE; i++) {
  40af60:	83 c7 01             	add    edi,0x1
  40af63:	48 83 c1 10          	add    rcx,0x10
  40af67:	81 ff 00 01 00 00    	cmp    edi,0x100
  40af6d:	75 eb                	jne    40af5a <capmgr_thd_create+0x2a>
	if (!tried) {
  40af6f:	41 83 fa 01          	cmp    r10d,0x1
  40af73:	74 72                	je     40afe7 <capmgr_thd_create+0xb7>
  40af75:	41 ba 01 00 00 00    	mov    r10d,0x1
  40af7b:	eb d1                	jmp    40af4e <capmgr_thd_create+0x1e>
  40af7d:	0f 1f 00             	nop    DWORD PTR [rax]
  40af80:	48 89 d0             	mov    rax,rdx
  40af83:	f0 4c 0f b1 01       	lock cmpxchg QWORD PTR [rcx],r8
  40af88:	0f 94 c0             	sete   al
			if (!ret) continue;
  40af8b:	84 c0                	test   al,al
  40af8d:	74 d1                	je     40af60 <capmgr_thd_create+0x30>
			assert(__thd_init_data[i].fn == fn);
  40af8f:	48 b8 40 39 5a 00 00 	movabs rax,0x5a3940
  40af96:	00 00 00 
  40af99:	48 63 d7             	movsxd rdx,edi
  40af9c:	48 c1 e2 04          	shl    rdx,0x4
  40afa0:	48 01 d0             	add    rax,rdx
  40afa3:	4c 3b 00             	cmp    r8,QWORD PTR [rax]
  40afa6:	75 13                	jne    40afbb <capmgr_thd_create+0x8b>
			__thd_init_data[i].data = data;
  40afa8:	4c 89 48 08          	mov    QWORD PTR [rax+0x8],r9
			return i + 1;
  40afac:	83 c7 01             	add    edi,0x1
	thdclosure_index_t idx = cos_thd_init_alloc(fn, data);

	if (idx < 1) return 0;

	return capmgr_thd_create_thunk(idx, tid);
  40afaf:	48 b8 80 7b 40 00 00 	movabs rax,0x407b80
  40afb6:	00 00 00 
  40afb9:	ff e0                	jmp    rax
  40afbb:	48 bf 20 fb 41 00 00 	movabs rdi,0x41fb20
  40afc2:	00 00 00 
{
  40afc5:	55                   	push   rbp
  40afc6:	be 67 00 00 00       	mov    esi,0x67
  40afcb:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40afd2:	00 00 00 
  40afd5:	48 89 e5             	mov    rbp,rsp
  40afd8:	ff d0                	call   rax
			assert(__thd_init_data[i].fn == fn);
  40afda:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40afe1:	00 00 00 00 
  40afe5:	0f 0b                	ud2    
}
  40afe7:	31 c0                	xor    eax,eax
  40afe9:	c3                   	ret    
  40afea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000040aff0 <capmgr_rcv_alloc>:

arcvcap_t
capmgr_rcv_alloc(cos_thd_fn_t fn, void *data, int flags, asndcap_t *asnd, thdcap_t *thdcap, thdid_t *tid)
{
  40aff0:	f3 0f 1e fa          	endbr64 
	if (!fn) return -1;
  40aff4:	48 85 ff             	test   rdi,rdi
  40aff7:	0f 84 c4 00 00 00    	je     40b0c1 <capmgr_rcv_alloc+0xd1>
  40affd:	55                   	push   rbp
  40affe:	49 89 cb             	mov    r11,rcx
  40b001:	49 89 fa             	mov    r10,rdi
  40b004:	4c 89 c1             	mov    rcx,r8
  40b007:	4d 89 c8             	mov    r8,r9
  40b00a:	45 31 c9             	xor    r9d,r9d
  40b00d:	48 89 e5             	mov    rbp,rsp
  40b010:	41 54                	push   r12
  40b012:	41 bc 02 00 00 00    	mov    r12d,0x2
  40b018:	53                   	push   rbx
  40b019:	48 89 f3             	mov    rbx,rsi
  40b01c:	89 d6                	mov    esi,edx
	for (i = 0; i < COS_THD_INIT_REGION_SIZE; i++) {
  40b01e:	48 ba 40 39 5a 00 00 	movabs rdx,0x5a3940
  40b025:	00 00 00 
  40b028:	31 ff                	xor    edi,edi
		if (__thd_init_data[i].fn == NULL) {
  40b02a:	48 83 3a 00          	cmp    QWORD PTR [rdx],0x0
  40b02e:	74 20                	je     40b050 <capmgr_rcv_alloc+0x60>
	for (i = 0; i < COS_THD_INIT_REGION_SIZE; i++) {
  40b030:	83 c7 01             	add    edi,0x1
  40b033:	48 83 c2 10          	add    rdx,0x10
  40b037:	81 ff 00 01 00 00    	cmp    edi,0x100
  40b03d:	75 eb                	jne    40b02a <capmgr_rcv_alloc+0x3a>
	if (!tried) {
  40b03f:	41 83 fc 01          	cmp    r12d,0x1
  40b043:	74 75                	je     40b0ba <capmgr_rcv_alloc+0xca>
  40b045:	41 bc 01 00 00 00    	mov    r12d,0x1
  40b04b:	eb d1                	jmp    40b01e <capmgr_rcv_alloc+0x2e>
  40b04d:	0f 1f 00             	nop    DWORD PTR [rax]
  40b050:	4c 89 c8             	mov    rax,r9
  40b053:	f0 4c 0f b1 12       	lock cmpxchg QWORD PTR [rdx],r10
  40b058:	0f 94 c0             	sete   al
			if (!ret) continue;
  40b05b:	84 c0                	test   al,al
  40b05d:	74 d1                	je     40b030 <capmgr_rcv_alloc+0x40>
			assert(__thd_init_data[i].fn == fn);
  40b05f:	48 b8 40 39 5a 00 00 	movabs rax,0x5a3940
  40b066:	00 00 00 
  40b069:	48 63 d7             	movsxd rdx,edi
  40b06c:	48 c1 e2 04          	shl    rdx,0x4
  40b070:	48 01 d0             	add    rax,rdx
  40b073:	4c 3b 10             	cmp    r10,QWORD PTR [rax]
  40b076:	75 1a                	jne    40b092 <capmgr_rcv_alloc+0xa2>
			__thd_init_data[i].data = data;
  40b078:	48 89 58 08          	mov    QWORD PTR [rax+0x8],rbx
			return i + 1;
  40b07c:	83 c7 01             	add    edi,0x1
	thdclosure_index_t idx = cos_thd_init_alloc(fn, data);

	if (idx < 1) return 0;

	return capmgr_rcv_create(idx, flags, asnd, thdcap, tid);
}
  40b07f:	5b                   	pop    rbx
	return capmgr_rcv_create(idx, flags, asnd, thdcap, tid);
  40b080:	4c 89 da             	mov    rdx,r11
  40b083:	48 b8 f0 83 40 00 00 	movabs rax,0x4083f0
  40b08a:	00 00 00 
}
  40b08d:	41 5c                	pop    r12
  40b08f:	5d                   	pop    rbp
	return capmgr_rcv_create(idx, flags, asnd, thdcap, tid);
  40b090:	ff e0                	jmp    rax
  40b092:	48 bf 20 fb 41 00 00 	movabs rdi,0x41fb20
  40b099:	00 00 00 
  40b09c:	be 67 00 00 00       	mov    esi,0x67
  40b0a1:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40b0a8:	00 00 00 
  40b0ab:	ff d0                	call   rax
			assert(__thd_init_data[i].fn == fn);
  40b0ad:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40b0b4:	00 00 00 00 
  40b0b8:	0f 0b                	ud2    
}
  40b0ba:	5b                   	pop    rbx
  40b0bb:	31 c0                	xor    eax,eax
  40b0bd:	41 5c                	pop    r12
  40b0bf:	5d                   	pop    rbp
  40b0c0:	c3                   	ret    
  40b0c1:	31 c0                	xor    eax,eax
  40b0c3:	c3                   	ret    
  40b0c4:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40b0cb:	00 00 00 00 
  40b0cf:	90                   	nop

000000000040b0d0 <capmgr_aep_create>:

thdcap_t
capmgr_aep_create(struct cos_aep_info *a, cos_aepthd_fn_t fn, void *data, int owntc, cos_channelkey_t key, microsec_t ipiwin, u32_t ipimax)
{
  40b0d0:	f3 0f 1e fa          	endbr64 
  40b0d4:	49 ba f0 ae 40 00 00 	movabs r10,0x40aef0
  40b0db:	00 00 00 
  40b0de:	55                   	push   rbp
  40b0df:	41 89 cb             	mov    r11d,ecx
  40b0e2:	44 89 c1             	mov    ecx,r8d
  40b0e5:	4d 89 c8             	mov    r8,r9
  40b0e8:	48 89 e5             	mov    rbp,rsp
  40b0eb:	41 56                	push   r14
again:
  40b0ed:	41 be 02 00 00 00    	mov    r14d,0x2
  40b0f3:	44 8b 4d 10          	mov    r9d,DWORD PTR [rbp+0x10]
  40b0f7:	41 55                	push   r13
  40b0f9:	45 31 ed             	xor    r13d,r13d
  40b0fc:	41 54                	push   r12
  40b0fe:	49 89 d4             	mov    r12,rdx
  40b101:	53                   	push   rbx
  40b102:	48 89 f3             	mov    rbx,rsi
	for (i = 0; i < COS_THD_INIT_REGION_SIZE; i++) {
  40b105:	48 ba 40 39 5a 00 00 	movabs rdx,0x5a3940
  40b10c:	00 00 00 
  40b10f:	31 f6                	xor    esi,esi
		if (__thd_init_data[i].fn == NULL) {
  40b111:	48 83 3a 00          	cmp    QWORD PTR [rdx],0x0
  40b115:	74 29                	je     40b140 <capmgr_aep_create+0x70>
	for (i = 0; i < COS_THD_INIT_REGION_SIZE; i++) {
  40b117:	83 c6 01             	add    esi,0x1
  40b11a:	48 83 c2 10          	add    rdx,0x10
  40b11e:	81 fe 00 01 00 00    	cmp    esi,0x100
  40b124:	75 eb                	jne    40b111 <capmgr_aep_create+0x41>
	if (!tried) {
  40b126:	41 83 fe 01          	cmp    r14d,0x1
  40b12a:	0f 85 89 00 00 00    	jne    40b1b9 <capmgr_aep_create+0xe9>
	if (idx < 1) return 0;
	a->fn   = fn;
	a->data = data;

	return capmgr_aep_create_thunk(a, idx, owntc, key, ipiwin, ipimax);
}
  40b130:	5b                   	pop    rbx
  40b131:	31 c0                	xor    eax,eax
  40b133:	41 5c                	pop    r12
  40b135:	41 5d                	pop    r13
  40b137:	41 5e                	pop    r14
  40b139:	5d                   	pop    rbp
  40b13a:	c3                   	ret    
  40b13b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40b140:	4c 89 e8             	mov    rax,r13
  40b143:	f0 4c 0f b1 12       	lock cmpxchg QWORD PTR [rdx],r10
  40b148:	0f 94 c0             	sete   al
			if (!ret) continue;
  40b14b:	84 c0                	test   al,al
  40b14d:	74 c8                	je     40b117 <capmgr_aep_create+0x47>
			assert(__thd_init_data[i].fn == fn);
  40b14f:	48 b8 40 39 5a 00 00 	movabs rax,0x5a3940
  40b156:	00 00 00 
  40b159:	48 63 d6             	movsxd rdx,esi
  40b15c:	48 c1 e2 04          	shl    rdx,0x4
  40b160:	48 01 d0             	add    rax,rdx
  40b163:	4c 39 10             	cmp    QWORD PTR [rax],r10
  40b166:	75 29                	jne    40b191 <capmgr_aep_create+0xc1>
			__thd_init_data[i].data = data;
  40b168:	48 89 78 08          	mov    QWORD PTR [rax+0x8],rdi
	return capmgr_aep_create_thunk(a, idx, owntc, key, ipiwin, ipimax);
  40b16c:	0f b7 c9             	movzx  ecx,cx
			return i + 1;
  40b16f:	83 c6 01             	add    esi,0x1
  40b172:	44 89 da             	mov    edx,r11d
  40b175:	48 b8 90 80 40 00 00 	movabs rax,0x408090
  40b17c:	00 00 00 
	a->fn   = fn;
  40b17f:	48 89 5f 20          	mov    QWORD PTR [rdi+0x20],rbx
	a->data = data;
  40b183:	4c 89 67 28          	mov    QWORD PTR [rdi+0x28],r12
}
  40b187:	5b                   	pop    rbx
  40b188:	41 5c                	pop    r12
  40b18a:	41 5d                	pop    r13
  40b18c:	41 5e                	pop    r14
  40b18e:	5d                   	pop    rbp
	return capmgr_aep_create_thunk(a, idx, owntc, key, ipiwin, ipimax);
  40b18f:	ff e0                	jmp    rax
  40b191:	48 bf 20 fb 41 00 00 	movabs rdi,0x41fb20
  40b198:	00 00 00 
  40b19b:	be 67 00 00 00       	mov    esi,0x67
  40b1a0:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40b1a7:	00 00 00 
  40b1aa:	ff d0                	call   rax
			assert(__thd_init_data[i].fn == fn);
  40b1ac:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40b1b3:	00 00 00 00 
  40b1b7:	0f 0b                	ud2    
  40b1b9:	41 be 01 00 00 00    	mov    r14d,0x1
  40b1bf:	e9 41 ff ff ff       	jmp    40b105 <capmgr_aep_create+0x35>
  40b1c4:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40b1cb:	00 00 00 
  40b1ce:	66 90                	xchg   ax,ax

000000000040b1d0 <main>:
 * __crt_main is just used to identify if the user has defined their
 * own main (thus overriding the weak place-holder below)
 */
static int
__crt_main(void)
{
  40b1d0:	f3 0f 1e fa          	endbr64 
	return 0;
}
  40b1d4:	31 c0                	xor    eax,eax
  40b1d6:	c3                   	ret    
  40b1d7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40b1de:	00 00 

000000000040b1e0 <__crt_parallel_main>:
	return;
}

static void
__crt_parallel_main(coreid_t cid, int init_core, int ncores)
{
  40b1e0:	f3 0f 1e fa          	endbr64 
	return;
}
  40b1e4:	c3                   	ret    
  40b1e5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40b1ec:	00 00 00 00 

000000000040b1f0 <__crt_cos_parallel_init>:
  40b1f0:	f3 0f 1e fa          	endbr64 
  40b1f4:	c3                   	ret    
  40b1f5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40b1fc:	00 00 00 00 
{
  40b200:	f3 0f 1e fa          	endbr64 
}
  40b204:	c3                   	ret    
  40b205:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40b20c:	00 00 00 00 

000000000040b210 <cos_main_defined>:
}
COS_FN_WEAKALIAS(cos_parallel_init, __crt_cos_parallel_init);

int
cos_main_defined(void)
{
  40b210:	f3 0f 1e fa          	endbr64 
	return __crt_main != main;
  40b214:	48 ba d0 b1 40 00 00 	movabs rdx,0x40b1d0
  40b21b:	00 00 00 
  40b21e:	48 b8 d0 b1 40 00 00 	movabs rax,0x40b1d0
  40b225:	00 00 00 
  40b228:	48 39 c2             	cmp    rdx,rax
  40b22b:	0f 95 c0             	setne  al
  40b22e:	0f b6 c0             	movzx  eax,al
}
  40b231:	c3                   	ret    
  40b232:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40b239:	00 00 00 00 
  40b23d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040b240 <pre_syscall_default_setup>:
  40b240:	f3 0f 1e fa          	endbr64 
  40b244:	c3                   	ret    
  40b245:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40b24c:	00 00 00 00 

000000000040b250 <pre_syscall_setup>:
}

/* Intended to be overriden by components */
CWEAKSYMB void
pre_syscall_setup()
{
  40b250:	f3 0f 1e fa          	endbr64 
	pre_syscall_default_setup();
  40b254:	48 ba 40 b2 40 00 00 	movabs rdx,0x40b240
  40b25b:	00 00 00 
  40b25e:	31 c0                	xor    eax,eax
  40b260:	ff e2                	jmp    rdx
  40b262:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40b269:	00 00 00 00 
  40b26d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040b270 <syscall_emulation_setup>:
  40b270:	f3 0f 1e fa          	endbr64 
  40b274:	c3                   	ret    
  40b275:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40b27c:	00 00 00 00 

000000000040b280 <libc_initialization_handler>:
  40b280:	f3 0f 1e fa          	endbr64 
  40b284:	c3                   	ret    
  40b285:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40b28c:	00 00 00 00 

000000000040b290 <libc_posixcap_initialization_handler>:
  40b290:	f3 0f 1e fa          	endbr64 
  40b294:	c3                   	ret    
  40b295:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40b29c:	00 00 00 00 

000000000040b2a0 <libc_posixsched_initialization_handler>:
  40b2a0:	f3 0f 1e fa          	endbr64 
  40b2a4:	c3                   	ret    
  40b2a5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40b2ac:	00 00 00 00 

000000000040b2b0 <libc_tls_init>:
{
}

CWEAKSYMB void
libc_tls_init(unsigned int cpuid)
{
  40b2b0:	f3 0f 1e fa          	endbr64 

}
  40b2b4:	c3                   	ret    
  40b2b5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40b2bc:	00 00 00 00 

000000000040b2c0 <libc_init>:
/* TODO: Make this a weak symbol (currently doing so makes this fail) */
void __init_libc(char **envp, char *pn);

void
libc_init()
{
  40b2c0:	f3 0f 1e fa          	endbr64 
                               (char *)AT_SECURE,
                               (char *)0, /* Whether the program is being run under sudo */
                               NULL
	};
	char *program_name = "composite component";
	__init_libc(envp, program_name);
  40b2c4:	48 be 88 fb 41 00 00 	movabs rsi,0x41fb88
  40b2cb:	00 00 00 
  40b2ce:	48 bf 20 a0 42 00 00 	movabs rdi,0x42a020
  40b2d5:	00 00 00 
  40b2d8:	48 b8 80 79 41 00 00 	movabs rax,0x417980
  40b2df:	00 00 00 
  40b2e2:	ff e0                	jmp    rax
  40b2e4:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40b2eb:	00 00 00 00 
  40b2ef:	90                   	nop

000000000040b2f0 <cos_upcall_exec>:
}

CWEAKSYMB void
cos_upcall_exec(void *arg)
{
  40b2f0:	f3 0f 1e fa          	endbr64 
}
  40b2f4:	c3                   	ret    
  40b2f5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40b2fc:	00 00 00 00 

000000000040b300 <cos_async_inv>:

CWEAKSYMB int
cos_async_inv(struct usr_inv_cap *ucap, int *params)
{
  40b300:	f3 0f 1e fa          	endbr64 
	return 0;
}
  40b304:	31 c0                	xor    eax,eax
  40b306:	c3                   	ret    
  40b307:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40b30e:	00 00 

000000000040b310 <cos_print_str>:
	return 0;
}

CWEAKSYMB int
cos_print_str(char *s, int len)
{
  40b310:	f3 0f 1e fa          	endbr64 
	int written = 0;

	while (written < len) {
  40b314:	85 f6                	test   esi,esi
  40b316:	0f 8e a4 00 00 00    	jle    40b3c0 <cos_print_str+0xb0>
{
  40b31c:	55                   	push   rbp
	int written = 0;
  40b31d:	45 31 d2             	xor    r10d,r10d
{
  40b320:	48 89 e5             	mov    rbp,rsp
  40b323:	41 57                	push   r15
  40b325:	41 56                	push   r14
  40b327:	4c 8d 7d c0          	lea    r15,[rbp-0x40]
  40b32b:	49 89 fe             	mov    r14,rdi
  40b32e:	41 55                	push   r13
  40b330:	41 89 f5             	mov    r13d,esi
  40b333:	41 54                	push   r12
  40b335:	53                   	push   rbx
  40b336:	eb 10                	jmp    40b348 <cos_print_str+0x38>
  40b338:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40b33f:	00 
		int ret;

		ret = call_cap(PRINT_CAP_TEMP, s_ints[0], s_ints[1], s_ints[2], len - written);
		/* Bomb out. Can't use a print out here as we must avoid recursion. */
		if (ret < 0) written = *(int *)NULL;
		written += ret;
  40b340:	41 01 c2             	add    r10d,eax
	while (written < len) {
  40b343:	45 39 d5             	cmp    r13d,r10d
  40b346:	7e 60                	jle    40b3a8 <cos_print_str+0x98>
		u32_t *s_ints = (u32_t *)&s[written];
  40b348:	49 63 c2             	movsxd rax,r10d
		ret = call_cap(PRINT_CAP_TEMP, s_ints[0], s_ints[1], s_ints[2], len - written);
  40b34b:	44 89 ea             	mov    edx,r13d
	__asm__ __volatile__(
  40b34e:	4c 89 f9             	mov    rcx,r15
		u32_t *s_ints = (u32_t *)&s[written];
  40b351:	4c 01 f0             	add    rax,r14
		ret = call_cap(PRINT_CAP_TEMP, s_ints[0], s_ints[1], s_ints[2], len - written);
  40b354:	44 29 d2             	sub    edx,r10d
  40b357:	8b 18                	mov    ebx,DWORD PTR [rax]
  40b359:	8b 70 04             	mov    esi,DWORD PTR [rax+0x4]
  40b35c:	48 63 d2             	movsxd rdx,edx
  40b35f:	8b 78 08             	mov    edi,DWORD PTR [rax+0x8]
  40b362:	b8 00 00 03 00       	mov    eax,0x30000
  40b367:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40b36a:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40b36e:	48 89 cd             	mov    rbp,rcx
  40b371:	49 b8 88 b3 40 00 00 	movabs r8,0x40b388
  40b378:	00 00 00 
  40b37b:	0f 05                	syscall 
  40b37d:	0f 1f 00             	nop    DWORD PTR [rax]
  40b380:	eb 0d                	jmp    40b38f <cos_print_str+0x7f>
  40b382:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40b388:	b9 00 00 00 00       	mov    ecx,0x0
  40b38d:	eb 05                	jmp    40b394 <cos_print_str+0x84>
  40b38f:	b9 01 00 00 00       	mov    ecx,0x1
  40b394:	5d                   	pop    rbp
  40b395:	5c                   	pop    rsp
		if (ret < 0) written = *(int *)NULL;
  40b396:	85 c0                	test   eax,eax
  40b398:	79 a6                	jns    40b340 <cos_print_str+0x30>
  40b39a:	8b 04 25 00 00 00 00 	mov    eax,DWORD PTR ds:0x0
  40b3a1:	0f 0b                	ud2    
  40b3a3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	}

	return written;
}
  40b3a8:	44 89 d0             	mov    eax,r10d
  40b3ab:	5b                   	pop    rbx
  40b3ac:	41 5c                	pop    r12
  40b3ae:	41 5d                	pop    r13
  40b3b0:	41 5e                	pop    r14
  40b3b2:	41 5f                	pop    r15
  40b3b4:	5d                   	pop    rbp
  40b3b5:	c3                   	ret    
  40b3b6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40b3bd:	00 00 00 
  40b3c0:	31 c0                	xor    eax,eax
  40b3c2:	c3                   	ret    
  40b3c3:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40b3ca:	00 00 00 00 
  40b3ce:	66 90                	xchg   ax,ax

000000000040b3d0 <printc.constprop.0>:
printc(char *fmt, ...)
  40b3d0:	f3 0f 1e fa          	endbr64 
  40b3d4:	55                   	push   rbp
  40b3d5:	48 89 e5             	mov    rbp,rsp
  40b3d8:	48 81 ec 90 01 00 00 	sub    rsp,0x190
  40b3df:	48 89 b5 58 ff ff ff 	mov    QWORD PTR [rbp-0xa8],rsi
  40b3e6:	48 89 95 60 ff ff ff 	mov    QWORD PTR [rbp-0xa0],rdx
  40b3ed:	48 89 8d 68 ff ff ff 	mov    QWORD PTR [rbp-0x98],rcx
  40b3f4:	4c 89 85 70 ff ff ff 	mov    QWORD PTR [rbp-0x90],r8
  40b3fb:	4c 89 8d 78 ff ff ff 	mov    QWORD PTR [rbp-0x88],r9
  40b402:	84 c0                	test   al,al
  40b404:	74 20                	je     40b426 <printc.constprop.0+0x56>
  40b406:	0f 29 45 80          	movaps XMMWORD PTR [rbp-0x80],xmm0
  40b40a:	0f 29 4d 90          	movaps XMMWORD PTR [rbp-0x70],xmm1
  40b40e:	0f 29 55 a0          	movaps XMMWORD PTR [rbp-0x60],xmm2
  40b412:	0f 29 5d b0          	movaps XMMWORD PTR [rbp-0x50],xmm3
  40b416:	0f 29 65 c0          	movaps XMMWORD PTR [rbp-0x40],xmm4
  40b41a:	0f 29 6d d0          	movaps XMMWORD PTR [rbp-0x30],xmm5
  40b41e:	0f 29 75 e0          	movaps XMMWORD PTR [rbp-0x20],xmm6
  40b422:	0f 29 7d f0          	movaps XMMWORD PTR [rbp-0x10],xmm7
	va_start(arg_ptr, fmt);
  40b426:	48 8d 45 10          	lea    rax,[rbp+0x10]
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40b42a:	be b4 00 00 00       	mov    esi,0xb4
  40b42f:	48 8d 8d 78 fe ff ff 	lea    rcx,[rbp-0x188]
	va_start(arg_ptr, fmt);
  40b436:	c7 85 78 fe ff ff 08 	mov    DWORD PTR [rbp-0x188],0x8
  40b43d:	00 00 00 
  40b440:	48 89 85 80 fe ff ff 	mov    QWORD PTR [rbp-0x180],rax
  40b447:	48 8d 85 50 ff ff ff 	lea    rax,[rbp-0xb0]
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40b44e:	48 8d bd 90 fe ff ff 	lea    rdi,[rbp-0x170]
  40b455:	48 ba a0 fb 41 00 00 	movabs rdx,0x41fba0
  40b45c:	00 00 00 
	va_start(arg_ptr, fmt);
  40b45f:	48 89 85 88 fe ff ff 	mov    QWORD PTR [rbp-0x178],rax
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40b466:	48 b8 20 80 41 00 00 	movabs rax,0x418020
  40b46d:	00 00 00 
	va_start(arg_ptr, fmt);
  40b470:	c7 85 7c fe ff ff 30 	mov    DWORD PTR [rbp-0x184],0x30
  40b477:	00 00 00 
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40b47a:	ff d0                	call   rax
	ret = cos_print_str(s, ret);
  40b47c:	48 8d bd 90 fe ff ff 	lea    rdi,[rbp-0x170]
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40b483:	89 c6                	mov    esi,eax
	ret = cos_print_str(s, ret);
  40b485:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40b48c:	00 00 00 
  40b48f:	ff d0                	call   rax
}
  40b491:	c9                   	leave  
  40b492:	c3                   	ret    
  40b493:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40b49a:	00 00 00 00 
  40b49e:	66 90                	xchg   ax,ax

000000000040b4a0 <prints.isra.0>:
prints(char *s)
  40b4a0:	f3 0f 1e fa          	endbr64 
	return cos_print_str(s, strlen(s));
  40b4a4:	48 b8 90 84 41 00 00 	movabs rax,0x418490
  40b4ab:	00 00 00 
prints(char *s)
  40b4ae:	55                   	push   rbp
  40b4af:	48 89 e5             	mov    rbp,rsp
  40b4b2:	41 54                	push   r12
  40b4b4:	49 89 fc             	mov    r12,rdi
  40b4b7:	48 83 ec 08          	sub    rsp,0x8
	return cos_print_str(s, strlen(s));
  40b4bb:	ff d0                	call   rax
  40b4bd:	4c 89 e7             	mov    rdi,r12
}
  40b4c0:	4c 8b 65 f8          	mov    r12,QWORD PTR [rbp-0x8]
  40b4c4:	c9                   	leave  
	return cos_print_str(s, strlen(s));
  40b4c5:	89 c6                	mov    esi,eax
  40b4c7:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40b4ce:	00 00 00 
  40b4d1:	ff e0                	jmp    rax
  40b4d3:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40b4da:	00 00 00 00 
  40b4de:	66 90                	xchg   ax,ax

000000000040b4e0 <cos_thd_entry_static>:
{
  40b4e0:	f3 0f 1e fa          	endbr64 
  40b4e4:	48 bf e8 fb 41 00 00 	movabs rdi,0x41fbe8
  40b4eb:	00 00 00 
  40b4ee:	55                   	push   rbp
  40b4ef:	be 2d 00 00 00       	mov    esi,0x2d
  40b4f4:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40b4fb:	00 00 00 
  40b4fe:	48 89 e5             	mov    rbp,rsp
  40b501:	ff d0                	call   rax
	assert(0);
  40b503:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40b50a:	00 00 00 00 
  40b50e:	0f 0b                	ud2    

000000000040b510 <cos_syscall_handler>:
{
  40b510:	f3 0f 1e fa          	endbr64 
	printc("Default syscall handler called (syscall: %d, first arg: %ld), faulting!", syscall_num, a);
  40b514:	48 b9 d0 b3 40 00 00 	movabs rcx,0x40b3d0
  40b51b:	00 00 00 
{
  40b51e:	55                   	push   rbp
  40b51f:	48 89 f2             	mov    rdx,rsi
	printc("Default syscall handler called (syscall: %d, first arg: %ld), faulting!", syscall_num, a);
  40b522:	31 c0                	xor    eax,eax
  40b524:	89 fe                	mov    esi,edi
  40b526:	48 bf a0 fb 41 00 00 	movabs rdi,0x41fba0
  40b52d:	00 00 00 
{
  40b530:	48 89 e5             	mov    rbp,rsp
	printc("Default syscall handler called (syscall: %d, first arg: %ld), faulting!", syscall_num, a);
  40b533:	ff d1                	call   rcx
  40b535:	be 2c 00 00 00       	mov    esi,0x2c
  40b53a:	48 bf 18 fc 41 00 00 	movabs rdi,0x41fc18
  40b541:	00 00 00 
  40b544:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40b54b:	00 00 00 
  40b54e:	ff d0                	call   rax
	assert(0);
  40b550:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40b557:	00 00 00 00 
  40b55b:	0f 0b                	ud2    
  40b55d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040b560 <__cos_syscall>:
{
  40b560:	f3 0f 1e fa          	endbr64 
	return cos_syscall_handler(syscall_num, a, b, c, d, e, f, g);
  40b564:	48 b8 10 b5 40 00 00 	movabs rax,0x40b510
  40b56b:	00 00 00 
  40b56e:	ff e0                	jmp    rax

000000000040b570 <cos_main>:
{
  40b570:	f3 0f 1e fa          	endbr64 
	assert(cos_main_defined());
  40b574:	48 b8 d0 b1 40 00 00 	movabs rax,0x40b1d0
  40b57b:	00 00 00 
  40b57e:	48 ba d0 b1 40 00 00 	movabs rdx,0x40b1d0
  40b585:	00 00 00 
  40b588:	48 39 c2             	cmp    rdx,rax
  40b58b:	74 02                	je     40b58f <cos_main+0x1f>
	return main();
  40b58d:	ff e0                	jmp    rax
  40b58f:	48 bf 48 fc 41 00 00 	movabs rdi,0x41fc48
  40b596:	00 00 00 
{
  40b599:	55                   	push   rbp
  40b59a:	be 2c 00 00 00       	mov    esi,0x2c
  40b59f:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40b5a6:	00 00 00 
  40b5a9:	48 89 e5             	mov    rbp,rsp
  40b5ac:	ff d0                	call   rax
	assert(cos_main_defined());
  40b5ae:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40b5b5:	00 00 00 00 
  40b5b9:	0f 0b                	ud2    
  40b5bb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000040b5c0 <cos_print_level_set>:
int cos_print_level   = PRINT_ERROR;
int cos_print_lvl_str = 0;

CWEAKSYMB void
cos_print_level_set(cos_print_level_t lvl, int print_str)
{
  40b5c0:	f3 0f 1e fa          	endbr64 
	cos_print_level   = lvl;
  40b5c4:	89 f8                	mov    eax,edi
  40b5c6:	a3 44 49 5a 00 00 00 	movabs ds:0x5a4944,eax
  40b5cd:	00 00 
	cos_print_lvl_str = print_str;
  40b5cf:	89 f0                	mov    eax,esi
  40b5d1:	a3 40 49 5a 00 00 00 	movabs ds:0x5a4940,eax
  40b5d8:	00 00 
}
  40b5da:	c3                   	ret    
  40b5db:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000040b5e0 <cos_upcall_fn>:
}
#endif

CWEAKSYMB void
cos_upcall_fn(upcall_type_t t, void *arg1, void *arg2, void *arg3)
{
  40b5e0:	f3 0f 1e fa          	endbr64 
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40b5e4:	48 ba 50 49 5a 00 00 	movabs rdx,0x5a4950
  40b5eb:	00 00 00 
  40b5ee:	55                   	push   rbp
        __asm__ __volatile__("lock " PS_CAS_STR
  40b5ef:	31 c9                	xor    ecx,ecx
  40b5f1:	48 89 e5             	mov    rbp,rsp
  40b5f4:	41 57                	push   r15
  40b5f6:	41 56                	push   r14
  40b5f8:	41 55                	push   r13
  40b5fa:	41 54                	push   r12
  40b5fc:	41 89 fc             	mov    r12d,edi
  40b5ff:	53                   	push   rbx
  40b600:	48 83 ec 18          	sub    rsp,0x18
  40b604:	48 89 75 c8          	mov    QWORD PTR [rbp-0x38],rsi
  40b608:	be 01 00 00 00       	mov    esi,0x1
  40b60d:	0f 1f 00             	nop    DWORD PTR [rax]
  40b610:	48 89 c8             	mov    rax,rcx
  40b613:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40b618:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40b61b:	84 c0                	test   al,al
  40b61d:	74 f1                	je     40b610 <cos_upcall_fn+0x30>
	 * There should be no concurrency at initialization (the init
	 * interface ensures this), so atomic operations aren't
	 * required here to update first.
	 */
	ps_lock_take(&_lock);
	libc_tls_init(cos_cpuid());
  40b61f:	48 b8 b0 b2 40 00 00 	movabs rax,0x40b2b0
  40b626:	00 00 00 
  40b629:	31 ff                	xor    edi,edi
  40b62b:	ff d0                	call   rax
	if (first) {
  40b62d:	48 b8 08 a0 42 00 00 	movabs rax,0x42a008
  40b634:	00 00 00 
  40b637:	8b 00                	mov    eax,DWORD PTR [rax]
  40b639:	85 c0                	test   eax,eax
  40b63b:	0f 85 9a 00 00 00    	jne    40b6db <cos_upcall_fn+0xfb>
  40b641:	49 bf 00 b0 42 00 00 	movabs r15,0x42b000
  40b648:	00 00 00 
{ l->o = 0; }
  40b64b:	48 b8 50 49 5a 00 00 	movabs rax,0x5a4950
  40b652:	00 00 00 
	ps_lock_release(&_lock);
	/*
	 * if it's the first component.. wait for timer calibration.
	 * NOTE: for "fork"ing components and not updating "spdid"s, this call will just fail and should be fine.
	 */
	if (cos_compid_uninitialized()) { /* we must be in the initial booter! */
  40b655:	49 83 7f 40 00       	cmp    QWORD PTR [r15+0x40],0x0
  40b65a:	48 c7 00 00 00 00 00 	mov    QWORD PTR [rax],0x0
  40b661:	0f 84 7e 01 00 00    	je     40b7e5 <cos_upcall_fn+0x205>
		cos_hw_cycles_per_usec(BOOT_CAPTBL_SELF_INITHW_BASE);
		perfcntr_init();
	}

	switch (t) {
  40b667:	45 85 e4             	test   r12d,r12d
  40b66a:	0f 85 8f 01 00 00    	jne    40b7ff <cos_upcall_fn+0x21f>
	{
		/* A new thread is created in this comp. */

		/* arg1 is the thread init data. 0 means
		 * bootstrap. */
		if (arg1 == 0) {
  40b670:	48 83 7d c8 00       	cmp    QWORD PTR [rbp-0x38],0x0
  40b675:	0f 84 c3 01 00 00    	je     40b83e <cos_upcall_fn+0x25e>
			static unsigned long first_core = 1;

			/* FIXME: assume that core 0 is the initial core for now */
			start_execution(cos_coreid(), ps_cas(&first_core, 1, 0), init_parallelism());
		} else {
			word_t idx = (word_t)arg1 - 1;
  40b67b:	48 8b 5d c8          	mov    rbx,QWORD PTR [rbp-0x38]
  40b67f:	48 83 eb 01          	sub    rbx,0x1
			if (idx >= COS_THD_INIT_REGION_SIZE) {
  40b683:	48 81 fb ff 00 00 00 	cmp    rbx,0xff
  40b68a:	0f 87 97 01 00 00    	ja     40b827 <cos_upcall_fn+0x247>
	fn   = __thd_init_data[idx].fn;
  40b690:	48 b8 40 39 5a 00 00 	movabs rax,0x5a3940
  40b697:	00 00 00 
  40b69a:	89 db                	mov    ebx,ebx
	__thd_init_data[idx].fn   = NULL;
  40b69c:	66 0f ef c0          	pxor   xmm0,xmm0
	fn   = __thd_init_data[idx].fn;
  40b6a0:	48 c1 e3 04          	shl    rbx,0x4
  40b6a4:	48 01 d8             	add    rax,rbx
  40b6a7:	48 8b 10             	mov    rdx,QWORD PTR [rax]
	data = __thd_init_data[idx].data;
  40b6aa:	48 8b 78 08          	mov    rdi,QWORD PTR [rax+0x8]
	__thd_init_data[idx].fn   = NULL;
  40b6ae:	0f 29 00             	movaps XMMWORD PTR [rax],xmm0
	(fn)(data);
  40b6b1:	ff d2                	call   rdx
  40b6b3:	48 bf 38 fd 41 00 00 	movabs rdi,0x41fd38
  40b6ba:	00 00 00 
  40b6bd:	be 2d 00 00 00       	mov    esi,0x2d
  40b6c2:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40b6c9:	00 00 00 
  40b6cc:	ff d0                	call   rax
	}
	default:
		/* fault! */
		assert(0);
	}
	assert(0); 		/* should *not* return from threads */
  40b6ce:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40b6d5:	00 00 00 00 
  40b6d9:	0f 0b                	ud2    
		if (__cosrt_comp_info.cos_heap_ptr == 0) {
  40b6db:	49 bf 00 b0 42 00 00 	movabs r15,0x42b000
  40b6e2:	00 00 00 
		first = 0;
  40b6e5:	48 b8 08 a0 42 00 00 	movabs rax,0x42a008
  40b6ec:	00 00 00 
		if (__cosrt_comp_info.cos_heap_ptr == 0) {
  40b6ef:	49 83 7f 58 00       	cmp    QWORD PTR [r15+0x58],0x0
		first = 0;
  40b6f4:	c7 00 00 00 00 00    	mov    DWORD PTR [rax],0x0
		if (__cosrt_comp_info.cos_heap_ptr == 0) {
  40b6fa:	75 1a                	jne    40b716 <cos_upcall_fn+0x136>
			__cosrt_comp_info.cos_heap_ptr = round_up_to_page((vaddr_t)&__crt_static_heap_ptr);
  40b6fc:	48 b8 87 72 5a 00 00 	movabs rax,0x5a7287
  40b703:	00 00 00 
  40b706:	48 25 00 f0 ff ff    	and    rax,0xfffffffffffff000
  40b70c:	48 a3 58 b0 42 00 00 	movabs ds:0x42b058,rax
  40b713:	00 00 00 
		cos_print_level_set(PRINT_DEBUG, 1);
  40b716:	be 01 00 00 00       	mov    esi,0x1
  40b71b:	bf 02 00 00 00       	mov    edi,0x2
static inline void
section_fnptrs_execute(long *list)
{
	int i;

	for (i = 0; i < list[0]; i++) {
  40b720:	31 db                	xor    ebx,ebx
  40b722:	49 bd 00 60 42 00 00 	movabs r13,0x426000
  40b729:	00 00 00 
  40b72c:	48 b8 c0 b5 40 00 00 	movabs rax,0x40b5c0
  40b733:	00 00 00 
  40b736:	4d 8d 75 08          	lea    r14,[r13+0x8]
  40b73a:	ff d0                	call   rax
		pre_syscall_setup();
  40b73c:	31 c0                	xor    eax,eax
  40b73e:	48 ba 50 b2 40 00 00 	movabs rdx,0x40b250
  40b745:	00 00 00 
  40b748:	ff d2                	call   rdx
		syscall_emulation_setup();
  40b74a:	31 c0                	xor    eax,eax
  40b74c:	48 ba 70 b2 40 00 00 	movabs rdx,0x40b270
  40b753:	00 00 00 
  40b756:	ff d2                	call   rdx
		libc_initialization_handler();
  40b758:	31 c0                	xor    eax,eax
  40b75a:	48 ba 80 b2 40 00 00 	movabs rdx,0x40b280
  40b761:	00 00 00 
  40b764:	ff d2                	call   rdx
		libc_posixcap_initialization_handler();
  40b766:	31 c0                	xor    eax,eax
  40b768:	48 ba 90 b2 40 00 00 	movabs rdx,0x40b290
  40b76f:	00 00 00 
  40b772:	ff d2                	call   rdx
		libc_posixsched_initialization_handler();
  40b774:	31 c0                	xor    eax,eax
  40b776:	48 ba a0 b2 40 00 00 	movabs rdx,0x40b2a0
  40b77d:	00 00 00 
  40b780:	ff d2                	call   rdx
  40b782:	49 83 7d 00 00       	cmp    QWORD PTR [r13+0x0],0x0
  40b787:	7e 15                	jle    40b79e <cos_upcall_fn+0x1be>
  40b789:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		typedef void (*ctors_t)(void);
		ctors_t ctors = (ctors_t)list[i + 1];
		ctors();
  40b790:	41 ff 14 de          	call   QWORD PTR [r14+rbx*8]
	for (i = 0; i < list[0]; i++) {
  40b794:	48 83 c3 01          	add    rbx,0x1
  40b798:	49 3b 5d 00          	cmp    rbx,QWORD PTR [r13+0x0]
  40b79c:	7c f2                	jl     40b790 <cos_upcall_fn+0x1b0>
  40b79e:	49 bd 20 60 42 00 00 	movabs r13,0x426020
  40b7a5:	00 00 00 
  40b7a8:	31 db                	xor    ebx,ebx
  40b7aa:	49 83 7d 00 00       	cmp    QWORD PTR [r13+0x0],0x0
  40b7af:	4d 8d 75 08          	lea    r14,[r13+0x8]
  40b7b3:	0f 8e 92 fe ff ff    	jle    40b64b <cos_upcall_fn+0x6b>
  40b7b9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		ctors();
  40b7c0:	41 ff 14 de          	call   QWORD PTR [r14+rbx*8]
	for (i = 0; i < list[0]; i++) {
  40b7c4:	48 83 c3 01          	add    rbx,0x1
  40b7c8:	49 39 5d 00          	cmp    QWORD PTR [r13+0x0],rbx
  40b7cc:	0f 8e 79 fe ff ff    	jle    40b64b <cos_upcall_fn+0x6b>
		ctors();
  40b7d2:	41 ff 14 de          	call   QWORD PTR [r14+rbx*8]
	for (i = 0; i < list[0]; i++) {
  40b7d6:	48 83 c3 01          	add    rbx,0x1
  40b7da:	49 39 5d 00          	cmp    QWORD PTR [r13+0x0],rbx
  40b7de:	7f e0                	jg     40b7c0 <cos_upcall_fn+0x1e0>
  40b7e0:	e9 66 fe ff ff       	jmp    40b64b <cos_upcall_fn+0x6b>
		cos_hw_cycles_per_usec(BOOT_CAPTBL_SELF_INITHW_BASE);
  40b7e5:	48 b8 e0 42 41 00 00 	movabs rax,0x4142e0
  40b7ec:	00 00 00 
  40b7ef:	bf 24 00 00 00       	mov    edi,0x24
  40b7f4:	ff d0                	call   rax
	switch (t) {
  40b7f6:	45 85 e4             	test   r12d,r12d
  40b7f9:	0f 84 71 fe ff ff    	je     40b670 <cos_upcall_fn+0x90>
  40b7ff:	48 bf 08 fd 41 00 00 	movabs rdi,0x41fd08
  40b806:	00 00 00 
  40b809:	be 2d 00 00 00       	mov    esi,0x2d
  40b80e:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40b815:	00 00 00 
  40b818:	ff d0                	call   rax
		assert(0);
  40b81a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40b821:	00 00 00 00 
  40b825:	0f 0b                	ud2    
				cos_thd_entry_static(idx - COS_THD_INIT_REGION_SIZE);
  40b827:	48 b8 e0 b4 40 00 00 	movabs rax,0x40b4e0
  40b82e:	00 00 00 
  40b831:	8d bb 00 ff ff ff    	lea    edi,[rbx-0x100]
  40b837:	ff d0                	call   rax
  40b839:	e9 75 fe ff ff       	jmp    40b6b3 <cos_upcall_fn+0xd3>
			start_execution(cos_coreid(), ps_cas(&first_core, 1, 0), init_parallelism());
  40b83e:	48 b8 e0 ae 40 00 00 	movabs rax,0x40aee0
  40b845:	00 00 00 
  40b848:	ff d0                	call   rax
        __asm__ __volatile__("lock " PS_CAS_STR
  40b84a:	48 8b 7d c8          	mov    rdi,QWORD PTR [rbp-0x38]
  40b84e:	b8 01 00 00 00       	mov    eax,0x1
  40b853:	48 ba 00 a0 42 00 00 	movabs rdx,0x42a000
  40b85a:	00 00 00 
  40b85d:	f0 48 0f b1 3a       	lock cmpxchg QWORD PTR [rdx],rdi
  40b862:	0f 94 c0             	sete   al
	if (parallel_main != __crt_parallel_main) {
  40b865:	48 b9 d0 55 40 00 00 	movabs rcx,0x4055d0
  40b86c:	00 00 00 
        return (int)z;
  40b86f:	44 0f be e8          	movsx  r13d,al
  40b873:	48 b8 e0 b1 40 00 00 	movabs rax,0x40b1e0
  40b87a:	00 00 00 
  40b87d:	48 39 c1             	cmp    rcx,rax
  40b880:	0f 84 e4 00 00 00    	je     40b96a <cos_upcall_fn+0x38a>
	if (initialization_completed == 0) {
  40b886:	a1 4c 49 5a 00 00 00 	movabs eax,ds:0x5a494c
  40b88d:	00 00 
  40b88f:	85 c0                	test   eax,eax
  40b891:	0f 85 a6 00 00 00    	jne    40b93d <cos_upcall_fn+0x35d>
		main_type = INIT_MAIN_PARALLEL;
  40b897:	41 bc 02 00 00 00    	mov    r12d,0x2
		if (init_core) {
  40b89d:	45 85 ed             	test   r13d,r13d
  40b8a0:	0f 85 f5 00 00 00    	jne    40b99b <cos_upcall_fn+0x3bb>
  40b8a6:	49 be 20 56 40 00 00 	movabs r14,0x405620
  40b8ad:	00 00 00 
  40b8b0:	49 bf f0 b1 40 00 00 	movabs r15,0x40b1f0
  40b8b7:	00 00 00 
  40b8ba:	48 bb 90 6c 40 00 00 	movabs rbx,0x406c90
  40b8c1:	00 00 00 
		COS_EXTERN_INV(init_parallel_await_init)();
  40b8c4:	48 ba 70 6c 40 00 00 	movabs rdx,0x406c70
  40b8cb:	00 00 00 
  40b8ce:	ff d2                	call   rdx
		if (parallel_init) {
  40b8d0:	4d 39 fe             	cmp    r14,r15
  40b8d3:	74 16                	je     40b8eb <cos_upcall_fn+0x30b>
			cos_parallel_init(cid, init_core, init_parallelism());
  40b8d5:	48 b8 e0 ae 40 00 00 	movabs rax,0x40aee0
  40b8dc:	00 00 00 
  40b8df:	ff d0                	call   rax
  40b8e1:	44 89 ee             	mov    esi,r13d
  40b8e4:	31 ff                	xor    edi,edi
  40b8e6:	89 c2                	mov    edx,eax
  40b8e8:	41 ff d6             	call   r14
		COS_EXTERN_INV(init_done)(0, main_type);
  40b8eb:	44 89 e6             	mov    esi,r12d
  40b8ee:	31 ff                	xor    edi,edi
  40b8f0:	ff d3                	call   rbx
		initialization_completed = 1;
  40b8f2:	48 b8 4c 49 5a 00 00 	movabs rax,0x5a494c
  40b8f9:	00 00 00 
  40b8fc:	c7 00 01 00 00 00    	mov    DWORD PTR [rax],0x1
	assert(main_type != INIT_MAIN_NONE);
  40b902:	45 85 e4             	test   r12d,r12d
  40b905:	0f 84 cf 00 00 00    	je     40b9da <cos_upcall_fn+0x3fa>
	assert(main_type == INIT_MAIN_PARALLEL || (main_type == INIT_MAIN_SINGLE && init_core));
  40b90b:	41 83 fc 02          	cmp    r12d,0x2
  40b90f:	74 2c                	je     40b93d <cos_upcall_fn+0x35d>
  40b911:	45 85 ed             	test   r13d,r13d
  40b914:	0f 84 81 01 00 00    	je     40ba9b <cos_upcall_fn+0x4bb>
	assert(cos_main_defined());
  40b91a:	48 b8 d0 b1 40 00 00 	movabs rax,0x40b1d0
  40b921:	00 00 00 
  40b924:	48 ba d0 b1 40 00 00 	movabs rdx,0x40b1d0
  40b92b:	00 00 00 
  40b92e:	48 39 c2             	cmp    rdx,rax
  40b931:	0f 84 41 01 00 00    	je     40ba78 <cos_upcall_fn+0x498>
	return main();
  40b937:	ff d0                	call   rax
  40b939:	89 c7                	mov    edi,eax
  40b93b:	eb 21                	jmp    40b95e <cos_upcall_fn+0x37e>
		parallel_main(cid, init_core, init_parallelism());
  40b93d:	48 b8 e0 ae 40 00 00 	movabs rax,0x40aee0
  40b944:	00 00 00 
  40b947:	ff d0                	call   rax
  40b949:	31 ff                	xor    edi,edi
  40b94b:	44 89 ee             	mov    esi,r13d
  40b94e:	89 c2                	mov    edx,eax
  40b950:	48 b8 d0 55 40 00 00 	movabs rax,0x4055d0
  40b957:	00 00 00 
  40b95a:	ff d0                	call   rax
	int ret = 0;
  40b95c:	31 ff                	xor    edi,edi
	COS_EXTERN_INV(init_exit)(ret);
  40b95e:	48 b8 30 6e 40 00 00 	movabs rax,0x406e30
  40b965:	00 00 00 
  40b968:	ff d0                	call   rax
	} else if (cos_main_defined()) {
  40b96a:	48 ba d0 b1 40 00 00 	movabs rdx,0x40b1d0
  40b971:	00 00 00 
  40b974:	48 b8 d0 b1 40 00 00 	movabs rax,0x40b1d0
  40b97b:	00 00 00 
  40b97e:	48 39 c2             	cmp    rdx,rax
  40b981:	74 7a                	je     40b9fd <cos_upcall_fn+0x41d>
	if (initialization_completed == 0) {
  40b983:	a1 4c 49 5a 00 00 00 	movabs eax,ds:0x5a494c
  40b98a:	00 00 
  40b98c:	85 c0                	test   eax,eax
  40b98e:	75 81                	jne    40b911 <cos_upcall_fn+0x331>
		main_type = INIT_MAIN_SINGLE;
  40b990:	41 bc 01 00 00 00    	mov    r12d,0x1
  40b996:	e9 02 ff ff ff       	jmp    40b89d <cos_upcall_fn+0x2bd>
	const int parallel_init = cos_parallel_init != __crt_cos_parallel_init;
  40b99b:	49 be 20 56 40 00 00 	movabs r14,0x405620
  40b9a2:	00 00 00 
			cos_init();
  40b9a5:	31 c0                	xor    eax,eax
	const int parallel_init = cos_parallel_init != __crt_cos_parallel_init;
  40b9a7:	49 bf f0 b1 40 00 00 	movabs r15,0x40b1f0
  40b9ae:	00 00 00 
			cos_init();
  40b9b1:	48 ba a0 57 40 00 00 	movabs rdx,0x4057a0
  40b9b8:	00 00 00 
  40b9bb:	ff d2                	call   rdx
	const int parallel_init = cos_parallel_init != __crt_cos_parallel_init;
  40b9bd:	31 ff                	xor    edi,edi
  40b9bf:	4d 39 fe             	cmp    r14,r15
			COS_EXTERN_INV(init_done)(parallel_init, main_type);
  40b9c2:	44 89 e6             	mov    esi,r12d
  40b9c5:	48 bb 90 6c 40 00 00 	movabs rbx,0x406c90
  40b9cc:	00 00 00 
	const int parallel_init = cos_parallel_init != __crt_cos_parallel_init;
  40b9cf:	40 0f 95 c7          	setne  dil
			COS_EXTERN_INV(init_done)(parallel_init, main_type);
  40b9d3:	ff d3                	call   rbx
			assert(parallel_init || main_type != INIT_MAIN_NONE);
  40b9d5:	e9 ea fe ff ff       	jmp    40b8c4 <cos_upcall_fn+0x2e4>
	assert(main_type != INIT_MAIN_NONE);
  40b9da:	48 bf a8 fc 41 00 00 	movabs rdi,0x41fca8
  40b9e1:	00 00 00 
  40b9e4:	48 b8 a0 b4 40 00 00 	movabs rax,0x40b4a0
  40b9eb:	00 00 00 
  40b9ee:	ff d0                	call   rax
  40b9f0:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40b9f7:	00 00 00 00 
  40b9fb:	0f 0b                	ud2    
	if (initialization_completed == 0) {
  40b9fd:	a1 4c 49 5a 00 00 00 	movabs eax,ds:0x5a494c
  40ba04:	00 00 
  40ba06:	85 c0                	test   eax,eax
  40ba08:	75 d0                	jne    40b9da <cos_upcall_fn+0x3fa>
		if (init_core) {
  40ba0a:	45 85 ed             	test   r13d,r13d
  40ba0d:	0f 84 93 fe ff ff    	je     40b8a6 <cos_upcall_fn+0x2c6>
	const int parallel_init = cos_parallel_init != __crt_cos_parallel_init;
  40ba13:	49 be 20 56 40 00 00 	movabs r14,0x405620
  40ba1a:	00 00 00 
			cos_init();
  40ba1d:	31 c0                	xor    eax,eax
	const int parallel_init = cos_parallel_init != __crt_cos_parallel_init;
  40ba1f:	49 bf f0 b1 40 00 00 	movabs r15,0x40b1f0
  40ba26:	00 00 00 
			cos_init();
  40ba29:	48 ba a0 57 40 00 00 	movabs rdx,0x4057a0
  40ba30:	00 00 00 
  40ba33:	ff d2                	call   rdx
	const int parallel_init = cos_parallel_init != __crt_cos_parallel_init;
  40ba35:	31 ff                	xor    edi,edi
  40ba37:	4d 39 fe             	cmp    r14,r15
			COS_EXTERN_INV(init_done)(parallel_init, main_type);
  40ba3a:	48 bb 90 6c 40 00 00 	movabs rbx,0x406c90
  40ba41:	00 00 00 
	const int parallel_init = cos_parallel_init != __crt_cos_parallel_init;
  40ba44:	40 0f 95 c7          	setne  dil
			COS_EXTERN_INV(init_done)(parallel_init, main_type);
  40ba48:	31 f6                	xor    esi,esi
  40ba4a:	ff d3                	call   rbx
			assert(parallel_init || main_type != INIT_MAIN_NONE);
  40ba4c:	4d 39 fe             	cmp    r14,r15
  40ba4f:	0f 85 6f fe ff ff    	jne    40b8c4 <cos_upcall_fn+0x2e4>
  40ba55:	48 bf 78 fc 41 00 00 	movabs rdi,0x41fc78
  40ba5c:	00 00 00 
  40ba5f:	48 b8 a0 b4 40 00 00 	movabs rax,0x40b4a0
  40ba66:	00 00 00 
  40ba69:	ff d0                	call   rax
  40ba6b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ba72:	00 00 00 00 
  40ba76:	0f 0b                	ud2    
	assert(cos_main_defined());
  40ba78:	48 bf 48 fc 41 00 00 	movabs rdi,0x41fc48
  40ba7f:	00 00 00 
  40ba82:	48 b8 a0 b4 40 00 00 	movabs rax,0x40b4a0
  40ba89:	00 00 00 
  40ba8c:	ff d0                	call   rax
  40ba8e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ba95:	00 00 00 00 
  40ba99:	0f 0b                	ud2    
	assert(main_type == INIT_MAIN_PARALLEL || (main_type == INIT_MAIN_SINGLE && init_core));
  40ba9b:	48 bf d8 fc 41 00 00 	movabs rdi,0x41fcd8
  40baa2:	00 00 00 
  40baa5:	48 b8 a0 b4 40 00 00 	movabs rax,0x40b4a0
  40baac:	00 00 00 
  40baaf:	ff d0                	call   rax
  40bab1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40bab8:	00 00 00 00 
  40babc:	0f 0b                	ud2    
  40babe:	66 90                	xchg   ax,ax

000000000040bac0 <cos_get_vas_page>:
	return;
}

CWEAKSYMB void *
cos_get_vas_page(void)
{
  40bac0:	f3 0f 1e fa          	endbr64 
  40bac4:	55                   	push   rbp
  40bac5:	48 89 e5             	mov    rbp,rsp
  40bac8:	53                   	push   rbx
  40bac9:	48 bb 58 b0 42 00 00 	movabs rbx,0x42b058
  40bad0:	00 00 00 
  40bad3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	return (void *)__cosrt_comp_info.cos_heap_ptr;
  40bad8:	48 a1 58 b0 42 00 00 	movabs rax,ds:0x42b058
  40badf:	00 00 00 
	char *h;
	long  r;
	do {
		h = cos_get_heap_ptr();
		r = (long)h + PAGE_SIZE;
  40bae2:	48 8d 88 00 10 00 00 	lea    rcx,[rax+0x1000]
	__asm__ __volatile__("call cos_atomic_cmpxchg"
  40bae9:	e8 92 02 00 00       	call   40bd80 <cos_atomic_cmpxchg>
	} while (cos_cmpxchg(&__cosrt_comp_info.cos_heap_ptr, (long)h, r) != r);
  40baee:	48 39 ca             	cmp    rdx,rcx
  40baf1:	75 e5                	jne    40bad8 <cos_get_vas_page+0x18>
	return h;
}
  40baf3:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
  40baf7:	c9                   	leave  
  40baf8:	c3                   	ret    
  40baf9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000040bb00 <cos_release_vas_page>:

CWEAKSYMB void
cos_release_vas_page(void *p)
{
  40bb00:	f3 0f 1e fa          	endbr64 
  40bb04:	55                   	push   rbp
  40bb05:	48 89 f9             	mov    rcx,rdi
	cos_set_heap_ptr_conditional(p + PAGE_SIZE, p);
  40bb08:	48 8d 87 00 10 00 00 	lea    rax,[rdi+0x1000]
{
  40bb0f:	48 89 e5             	mov    rbp,rsp
  40bb12:	53                   	push   rbx
  40bb13:	48 bb 58 b0 42 00 00 	movabs rbx,0x42b058
  40bb1a:	00 00 00 
  40bb1d:	e8 5e 02 00 00       	call   40bd80 <cos_atomic_cmpxchg>
}
  40bb22:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
  40bb26:	c9                   	leave  
  40bb27:	c3                   	ret    
  40bb28:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40bb2f:	00 

000000000040bb30 <cos_initargs_tar>:
CWEAKSYMB long _binary_tar_binary_start = 0;
CWEAKSYMB long _binary_tar_binary_end = 0;

char *
cos_initargs_tar(void)
{
  40bb30:	f3 0f 1e fa          	endbr64 
	/* Tar files are at least one record, which is 512 bytes */
	if (_binary_tar_binary_end - _binary_tar_binary_start < 512) return NULL;
  40bb34:	48 b8 08 39 5a 00 00 	movabs rax,0x5a3908
  40bb3b:	00 00 00 
  40bb3e:	4c 8b 00             	mov    r8,QWORD PTR [rax]
  40bb41:	48 a1 00 39 5a 00 00 	movabs rax,ds:0x5a3900
  40bb48:	00 00 00 
  40bb4b:	4c 29 c0             	sub    rax,r8
  40bb4e:	48 3d ff 01 00 00    	cmp    rax,0x1ff
  40bb54:	b8 00 00 00 00       	mov    eax,0x0
  40bb59:	4c 0f 4e c0          	cmovle r8,rax
	return (char *)_binary_tar_binary_start;
}
  40bb5d:	4c 89 c0             	mov    rax,r8
  40bb60:	c3                   	ret    
  40bb61:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40bb68:	00 00 00 
  40bb6b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000040bb70 <__cosrt_c_cosrtdefault>:
#include <cos_kernel_api.h>
#include <cos_types.h>
#include <c_stub.h>

COS_CLIENT_STUB(int, cosrtdefault, word_t p0, word_t p1, word_t p2, word_t p3)
{
  40bb70:	f3 0f 1e fa          	endbr64 
  40bb74:	55                   	push   rbp
  40bb75:	48 89 e5             	mov    rbp,rsp
  40bb78:	41 56                	push   r14
  40bb7a:	49 89 ce             	mov    r14,rcx
  40bb7d:	41 55                	push   r13
  40bb7f:	41 54                	push   r12
  40bb81:	53                   	push   rbx
  40bb82:	48 83 ec 20          	sub    rsp,0x20
  40bb86:	4c 8b 40 08          	mov    r8,QWORD PTR [rax+0x8]
  40bb8a:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, &r1, &r2);
  40bb8e:	48 85 c0             	test   rax,rax
  40bb91:	74 1d                	je     40bbb0 <__cosrt_c_cosrtdefault+0x40>
  40bb93:	4c 8d 4d d0          	lea    r9,[rbp-0x30]
  40bb97:	4c 8d 45 c8          	lea    r8,[rbp-0x38]
  40bb9b:	ff d0                	call   rax
	COS_CLIENT_INVCAP;
	return cos_sinv(uc, p0, p1, p2, p3);
}
  40bb9d:	48 83 c4 20          	add    rsp,0x20
  40bba1:	5b                   	pop    rbx
  40bba2:	41 5c                	pop    r12
  40bba4:	41 5d                	pop    r13
  40bba6:	41 5e                	pop    r14
  40bba8:	5d                   	pop    rbp
  40bba9:	c3                   	ret    
  40bbaa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40bbb0:	41 8d 40 01          	lea    eax,[r8+0x1]
	__asm__ __volatile__(
  40bbb4:	48 89 fb             	mov    rbx,rdi
  40bbb7:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  40bbbb:	48 89 d7             	mov    rdi,rdx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40bbbe:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40bbc1:	4c 89 f2             	mov    rdx,r14
  40bbc4:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40bbc7:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40bbcb:	48 89 cd             	mov    rbp,rcx
  40bbce:	49 b8 e8 bb 40 00 00 	movabs r8,0x40bbe8
  40bbd5:	00 00 00 
  40bbd8:	0f 05                	syscall 
  40bbda:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40bbe0:	eb 0d                	jmp    40bbef <__cosrt_c_cosrtdefault+0x7f>
  40bbe2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40bbe8:	b9 00 00 00 00       	mov    ecx,0x0
  40bbed:	eb 05                	jmp    40bbf4 <__cosrt_c_cosrtdefault+0x84>
  40bbef:	b9 01 00 00 00       	mov    ecx,0x1
  40bbf4:	5d                   	pop    rbp
  40bbf5:	5c                   	pop    rsp
  40bbf6:	48 83 c4 20          	add    rsp,0x20
  40bbfa:	5b                   	pop    rbx
  40bbfb:	41 5c                	pop    r12
  40bbfd:	41 5d                	pop    r13
  40bbff:	41 5e                	pop    r14
  40bc01:	5d                   	pop    rbp
  40bc02:	c3                   	ret    
  40bc03:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40bc0a:	00 00 00 00 
  40bc0e:	66 90                	xchg   ax,ax

000000000040bc10 <__cosrt_c_cosrtretdefault>:

COS_CLIENT_STUB(int, cosrtretdefault, word_t p0, word_t p1, word_t p2, word_t p3, word_t *r1, word_t *r2)
{
  40bc10:	f3 0f 1e fa          	endbr64 
  40bc14:	55                   	push   rbp
  40bc15:	48 89 e5             	mov    rbp,rsp
  40bc18:	41 57                	push   r15
  40bc1a:	4d 89 c7             	mov    r15,r8
  40bc1d:	41 56                	push   r14
  40bc1f:	4d 89 ce             	mov    r14,r9
  40bc22:	41 55                	push   r13
  40bc24:	49 89 d5             	mov    r13,rdx
  40bc27:	48 89 ca             	mov    rdx,rcx
  40bc2a:	41 54                	push   r12
  40bc2c:	53                   	push   rbx
  40bc2d:	48 89 fb             	mov    rbx,rdi
  40bc30:	4c 8b 50 10          	mov    r10,QWORD PTR [rax+0x10]
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  40bc34:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  40bc38:	4d 85 d2             	test   r10,r10
  40bc3b:	74 13                	je     40bc50 <__cosrt_c_cosrtretdefault+0x40>
  40bc3d:	48 89 d1             	mov    rcx,rdx
  40bc40:	4c 89 ea             	mov    rdx,r13
	COS_CLIENT_INVCAP;

	return cos_sinv_2rets(uc, p0, p1, p2, p3, r1, r2);
}
  40bc43:	5b                   	pop    rbx
  40bc44:	41 5c                	pop    r12
  40bc46:	41 5d                	pop    r13
  40bc48:	41 5e                	pop    r14
  40bc4a:	41 5f                	pop    r15
  40bc4c:	5d                   	pop    rbp
  40bc4d:	41 ff e2             	jmp    r10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40bc50:	8d 41 01             	lea    eax,[rcx+0x1]
	__asm__ __volatile__(
  40bc53:	4c 89 ef             	mov    rdi,r13
  40bc56:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40bc5a:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40bc5d:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40bc60:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40bc64:	48 89 cd             	mov    rbp,rcx
  40bc67:	49 b8 80 bc 40 00 00 	movabs r8,0x40bc80
  40bc6e:	00 00 00 
  40bc71:	0f 05                	syscall 
  40bc73:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40bc78:	eb 0f                	jmp    40bc89 <__cosrt_c_cosrtretdefault+0x79>
  40bc7a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40bc80:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  40bc87:	eb 07                	jmp    40bc90 <__cosrt_c_cosrtretdefault+0x80>
  40bc89:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  40bc90:	5d                   	pop    rbp
  40bc91:	5c                   	pop    rsp
  40bc92:	49 89 37             	mov    QWORD PTR [r15],rsi
  40bc95:	49 89 3e             	mov    QWORD PTR [r14],rdi
  40bc98:	5b                   	pop    rbx
  40bc99:	41 5c                	pop    r12
  40bc9b:	41 5d                	pop    r13
  40bc9d:	41 5e                	pop    r14
  40bc9f:	41 5f                	pop    r15
  40bca1:	5d                   	pop    rbp
  40bca2:	c3                   	ret    
  40bca3:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40bcaa:	00 00 00 
  40bcad:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040bcb0 <cos_ainv_entry>:
  40bcb0:	53                   	push   rbx
  40bcb1:	56                   	push   rsi
  40bcb2:	57                   	push   rdi
  40bcb3:	52                   	push   rdx
  40bcb4:	55                   	push   rbp
  40bcb5:	89 e3                	mov    ebx,esp
  40bcb7:	83 c3 18             	add    ebx,0x18
  40bcba:	53                   	push   rbx
  40bcbb:	50                   	push   rax
  40bcbc:	e8 3f f6 ff ff       	call   40b300 <cos_async_inv>
  40bcc1:	83 c4 08             	add    esp,0x8
  40bcc4:	83 f8 00             	cmp    eax,0x0
  40bcc7:	74 22                	je     40bceb <ainv_ret>
  40bcc9:	67 8b 5c 24 18       	mov    ebx,DWORD PTR [esp+0x18]
  40bcce:	67 8b 74 24 1c       	mov    esi,DWORD PTR [esp+0x1c]
  40bcd3:	67 8b 7c 24 20       	mov    edi,DWORD PTR [esp+0x20]
  40bcd8:	67 8b 54 24 24       	mov    edx,DWORD PTR [esp+0x24]
  40bcdd:	89 e5                	mov    ebp,esp
  40bcdf:	48 b9 eb bc 40 00 00 	movabs rcx,0x40bceb
  40bce6:	00 00 00 
  40bce9:	0f 34                	sysenter 

000000000040bceb <ainv_ret>:
  40bceb:	5d                   	pop    rbp
  40bcec:	5a                   	pop    rdx
  40bced:	5f                   	pop    rdi
  40bcee:	5e                   	pop    rsi
  40bcef:	5b                   	pop    rbx
  40bcf0:	c3                   	ret    
  40bcf1:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40bcf8:	00 00 00 
  40bcfb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000040bd00 <custom_acquire_stack>:
  40bd00:	48 89 c2             	mov    rdx,rax
  40bd03:	48 bc 00 e0 42 00 00 	movabs rsp,0x42e000
  40bd0a:	00 00 00 
  40bd0d:	48 25 ff ff 00 00    	and    rax,0xffff
  40bd13:	48 c1 e0 0d          	shl    rax,0xd
  40bd17:	48 01 c4             	add    rsp,rax
  40bd1a:	48 c1 e8 0d          	shr    rax,0xd
  40bd1e:	48 c1 ea 10          	shr    rdx,0x10
  40bd22:	ff e1                	jmp    rcx
  40bd24:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40bd2b:	00 00 00 00 
  40bd2f:	90                   	nop

000000000040bd30 <__cosrt_upcall_entry>:
  40bd30:	48 b9 3f bd 40 00 00 	movabs rcx,0x40bd3f
  40bd37:	00 00 00 
  40bd3a:	e9 c1 ff ff ff       	jmp    40bd00 <custom_acquire_stack>
  40bd3f:	52                   	push   rdx
  40bd40:	50                   	push   rax
  40bd41:	6a 00                	push   0x0
  40bd43:	6a 00                	push   0x0
  40bd45:	48 89 64 24 f0       	mov    QWORD PTR [rsp-0x10],rsp
  40bd4a:	6a 00                	push   0x0
  40bd4c:	48 89 64 24 f0       	mov    QWORD PTR [rsp-0x10],rsp
  40bd51:	48 83 ec 10          	sub    rsp,0x10
  40bd55:	48 89 f1             	mov    rcx,rsi
  40bd58:	48 89 fa             	mov    rdx,rdi
  40bd5b:	48 89 de             	mov    rsi,rbx
  40bd5e:	48 31 ed             	xor    rbp,rbp
  40bd61:	4c 89 e7             	mov    rdi,r12
  40bd64:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  40bd68:	e8 73 f8 ff ff       	call   40b5e0 <cos_upcall_fn>
  40bd6d:	83 c4 18             	add    esp,0x18
  40bd70:	5e                   	pop    rsi
  40bd71:	5f                   	pop    rdi
  40bd72:	89 c1                	mov    ecx,eax
  40bd74:	b8 00 00 01 00       	mov    eax,0x10000
  40bd79:	0f 34                	sysenter 
  40bd7b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000040bd80 <cos_atomic_cmpxchg>:
  40bd80:	c3                   	ret    

000000000040bd81 <cos_atomic_user1>:
  40bd81:	b8 00 00 00 00       	mov    eax,0x0
  40bd86:	67 8b 00             	mov    eax,DWORD PTR [eax]
  40bd89:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000040bd90 <args_iter.part.0.isra.0>:
	default:            return 0;
	}
}

int
args_iter(struct initargs *arg, struct initargs_iter *i, struct initargs *ent)
  40bd90:	f3 0f 1e fa          	endbr64 
	if (!kv) return 0;
  40bd94:	48 85 ff             	test   rdi,rdi
  40bd97:	74 77                	je     40be10 <args_iter.part.0.isra.0+0x80>
	switch (kv->vtype) {
  40bd99:	8b 47 08             	mov    eax,DWORD PTR [rdi+0x8]
  40bd9c:	85 c0                	test   eax,eax
  40bd9e:	74 50                	je     40bdf0 <args_iter.part.0.isra.0+0x60>
  40bda0:	83 f8 01             	cmp    eax,0x1
  40bda3:	74 13                	je     40bdb8 <args_iter.part.0.isra.0+0x28>
	*i = (struct kv_iter){
  40bda5:	48 89 7e 08          	mov    QWORD PTR [rsi+0x8],rdi
	if (i->start->vtype != VTYPE_ARR) return 0;
  40bda9:	31 c0                	xor    eax,eax
	*i = (struct kv_iter){
  40bdab:	48 c7 46 10 00 00 00 	mov    QWORD PTR [rsi+0x10],0x0
  40bdb2:	00 
	if (i->start->vtype != VTYPE_ARR) return 0;
  40bdb3:	c3                   	ret    
  40bdb4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	case VTYPE_ARR: return kv->val.arr.sz;
  40bdb8:	8b 47 10             	mov    eax,DWORD PTR [rdi+0x10]
	*i = (struct kv_iter){
  40bdbb:	48 89 7e 08          	mov    QWORD PTR [rsi+0x8],rdi
  40bdbf:	c7 46 10 00 00 00 00 	mov    DWORD PTR [rsi+0x10],0x0
  40bdc6:	89 46 14             	mov    DWORD PTR [rsi+0x14],eax
	if (i->curr == i->len) return 0;
  40bdc9:	85 c0                	test   eax,eax
  40bdcb:	75 03                	jne    40bdd0 <args_iter.part.0.isra.0+0x40>
	switch (arg->type) {
	case ARGS_IMPL_KV:  return kv_iter(arg->d.kv_ent, &i->i.kv_i, &ent->d.kv_ent);
	case ARGS_IMPL_TAR: return tar_iter(&arg->d.tar_ent, &i->i.tar_i, &ent->d.tar_ent);
	default:            return 0;
	}
}
  40bdcd:	c3                   	ret    
  40bdce:	66 90                	xchg   ax,ax
	*ent = __kv_index(i->start, i->curr++);
  40bdd0:	c7 46 10 01 00 00 00 	mov    DWORD PTR [rsi+0x10],0x1
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  40bdd7:	7e 4f                	jle    40be28 <args_iter.part.0.isra.0+0x98>
	return kv->val.arr.kvs[idx];
  40bdd9:	48 8b 47 18          	mov    rax,QWORD PTR [rdi+0x18]
  40bddd:	48 8b 00             	mov    rax,QWORD PTR [rax]
	*ent = __kv_index(i->start, i->curr++);
  40bde0:	48 89 42 08          	mov    QWORD PTR [rdx+0x8],rax
	return 1;
  40bde4:	b8 01 00 00 00       	mov    eax,0x1
  40bde9:	c3                   	ret    
  40bdea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	*i = (struct kv_iter){
  40bdf0:	48 b8 d8 fd 41 00 00 	movabs rax,0x41fdd8
  40bdf7:	00 00 00 
  40bdfa:	48 89 7e 08          	mov    QWORD PTR [rsi+0x8],rdi
  40bdfe:	48 8b 00             	mov    rax,QWORD PTR [rax]
  40be01:	48 89 46 10          	mov    QWORD PTR [rsi+0x10],rax
	if (i->start->vtype != VTYPE_ARR) return 0;
  40be05:	31 c0                	xor    eax,eax
  40be07:	c3                   	ret    
  40be08:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40be0f:	00 
	*i = (struct kv_iter){
  40be10:	48 c7 46 08 00 00 00 	mov    QWORD PTR [rsi+0x8],0x0
  40be17:	00 
	if (i->start->vtype != VTYPE_ARR) return 0;
  40be18:	31 c0                	xor    eax,eax
	*i = (struct kv_iter){
  40be1a:	48 c7 46 10 00 00 00 	mov    QWORD PTR [rsi+0x10],0x0
  40be21:	00 
	if (i->start->vtype != VTYPE_ARR) return 0;
  40be22:	c3                   	ret    
  40be23:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  40be28:	31 c0                	xor    eax,eax
  40be2a:	eb b4                	jmp    40bde0 <args_iter.part.0.isra.0+0x50>
  40be2c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000040be30 <args_key>:
{
  40be30:	f3 0f 1e fa          	endbr64 
  40be34:	55                   	push   rbp
  40be35:	48 89 e5             	mov    rbp,rsp
  40be38:	41 55                	push   r13
  40be3a:	49 89 f5             	mov    r13,rsi
  40be3d:	41 54                	push   r12
	switch (arg->type) {
  40be3f:	8b 07                	mov    eax,DWORD PTR [rdi]
  40be41:	85 c0                	test   eax,eax
  40be43:	74 23                	je     40be68 <args_key+0x38>
  40be45:	45 31 e4             	xor    r12d,r12d
  40be48:	83 f8 01             	cmp    eax,0x1
  40be4b:	75 3b                	jne    40be88 <args_key+0x58>
	case ARGS_IMPL_TAR: return tar_key(&arg->d.tar_ent, arg_len);
  40be4d:	48 b8 f0 c6 40 00 00 	movabs rax,0x40c6f0
  40be54:	00 00 00 
}
  40be57:	41 5c                	pop    r12
	case ARGS_IMPL_TAR: return tar_key(&arg->d.tar_ent, arg_len);
  40be59:	48 83 c7 08          	add    rdi,0x8
}
  40be5d:	41 5d                	pop    r13
  40be5f:	5d                   	pop    rbp
	case ARGS_IMPL_TAR: return tar_key(&arg->d.tar_ent, arg_len);
  40be60:	ff e0                	jmp    rax
  40be62:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40be68:	4c 8b 67 08          	mov    r12,QWORD PTR [rdi+0x8]
	if (!kv) return NULL;
  40be6c:	4d 85 e4             	test   r12,r12
  40be6f:	74 17                	je     40be88 <args_key+0x58>
	*key_len = strlen(kv->key);
  40be71:	48 b8 90 84 41 00 00 	movabs rax,0x418490
  40be78:	00 00 00 
  40be7b:	4d 8b 24 24          	mov    r12,QWORD PTR [r12]
  40be7f:	4c 89 e7             	mov    rdi,r12
  40be82:	ff d0                	call   rax
  40be84:	41 89 45 00          	mov    DWORD PTR [r13+0x0],eax
}
  40be88:	4c 89 e0             	mov    rax,r12
  40be8b:	41 5c                	pop    r12
  40be8d:	41 5d                	pop    r13
  40be8f:	5d                   	pop    rbp
  40be90:	c3                   	ret    
  40be91:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40be98:	00 00 00 00 
  40be9c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000040bea0 <args_value>:
{
  40bea0:	f3 0f 1e fa          	endbr64 
	switch (arg->type) {
  40bea4:	8b 07                	mov    eax,DWORD PTR [rdi]
  40bea6:	85 c0                	test   eax,eax
  40bea8:	74 1e                	je     40bec8 <args_value+0x28>
  40beaa:	83 f8 01             	cmp    eax,0x1
  40bead:	75 11                	jne    40bec0 <args_value+0x20>
	case ARGS_IMPL_TAR: return tar_value(&arg->d.tar_ent);
  40beaf:	48 b8 c0 c7 40 00 00 	movabs rax,0x40c7c0
  40beb6:	00 00 00 
  40beb9:	48 83 c7 08          	add    rdi,0x8
  40bebd:	ff e0                	jmp    rax
  40bebf:	90                   	nop
	if (!kv) return NULL;
  40bec0:	31 c0                	xor    eax,eax
}
  40bec2:	c3                   	ret    
  40bec3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40bec8:	48 8b 47 08          	mov    rax,QWORD PTR [rdi+0x8]
	if (!kv) return NULL;
  40becc:	48 85 c0             	test   rax,rax
  40becf:	74 f1                	je     40bec2 <args_value+0x22>
	switch (kv->vtype) {
  40bed1:	8b 50 08             	mov    edx,DWORD PTR [rax+0x8]
  40bed4:	85 d2                	test   edx,edx
  40bed6:	75 e8                	jne    40bec0 <args_value+0x20>
	case VTYPE_STR: return kv->val.str;
  40bed8:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
  40bedc:	c3                   	ret    
  40bedd:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040bee0 <args_len>:
{
  40bee0:	f3 0f 1e fa          	endbr64 
	switch (arg->type) {
  40bee4:	8b 07                	mov    eax,DWORD PTR [rdi]
  40bee6:	85 c0                	test   eax,eax
  40bee8:	74 1e                	je     40bf08 <args_len+0x28>
  40beea:	83 f8 01             	cmp    eax,0x1
  40beed:	75 11                	jne    40bf00 <args_len+0x20>
	case ARGS_IMPL_TAR: return tar_len(&arg->d.tar_ent);
  40beef:	48 b8 f0 cc 40 00 00 	movabs rax,0x40ccf0
  40bef6:	00 00 00 
  40bef9:	48 83 c7 08          	add    rdi,0x8
  40befd:	ff e0                	jmp    rax
  40beff:	90                   	nop
	if (!kv) return 0;
  40bf00:	31 c0                	xor    eax,eax
}
  40bf02:	c3                   	ret    
  40bf03:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	case ARGS_IMPL_KV:  return kv_len(arg->d.kv_ent);
  40bf08:	48 8b 57 08          	mov    rdx,QWORD PTR [rdi+0x8]
	if (!kv) return 0;
  40bf0c:	48 85 d2             	test   rdx,rdx
  40bf0f:	74 ef                	je     40bf00 <args_len+0x20>
	switch (kv->vtype) {
  40bf11:	8b 4a 08             	mov    ecx,DWORD PTR [rdx+0x8]
  40bf14:	b8 01 00 00 00       	mov    eax,0x1
  40bf19:	85 c9                	test   ecx,ecx
  40bf1b:	74 e5                	je     40bf02 <args_len+0x22>
	default:        return 0;
  40bf1d:	31 c0                	xor    eax,eax
	switch (kv->vtype) {
  40bf1f:	83 f9 01             	cmp    ecx,0x1
  40bf22:	75 de                	jne    40bf02 <args_len+0x22>
	case VTYPE_ARR: return kv->val.arr.sz;
  40bf24:	8b 42 10             	mov    eax,DWORD PTR [rdx+0x10]
  40bf27:	c3                   	ret    
  40bf28:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40bf2f:	00 

000000000040bf30 <args_iter_next>:
{
  40bf30:	f3 0f 1e fa          	endbr64 
	arg->type = i->type;
  40bf34:	8b 07                	mov    eax,DWORD PTR [rdi]
  40bf36:	89 06                	mov    DWORD PTR [rsi],eax
	switch (i->type) {
  40bf38:	85 c0                	test   eax,eax
  40bf3a:	74 24                	je     40bf60 <args_iter_next+0x30>
  40bf3c:	83 f8 01             	cmp    eax,0x1
  40bf3f:	75 17                	jne    40bf58 <args_iter_next+0x28>
	case ARGS_IMPL_TAR: return tar_iter_next(&i->i.tar_i, &arg->d.tar_ent);
  40bf41:	48 83 c6 08          	add    rsi,0x8
  40bf45:	48 83 c7 08          	add    rdi,0x8
  40bf49:	48 b8 40 c9 40 00 00 	movabs rax,0x40c940
  40bf50:	00 00 00 
  40bf53:	ff e0                	jmp    rax
  40bf55:	0f 1f 00             	nop    DWORD PTR [rax]
	switch (i->type) {
  40bf58:	31 c0                	xor    eax,eax
  40bf5a:	c3                   	ret    
  40bf5b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	if (i->start->vtype != VTYPE_ARR) return 0;
  40bf60:	48 8b 4f 08          	mov    rcx,QWORD PTR [rdi+0x8]
  40bf64:	31 c0                	xor    eax,eax
  40bf66:	83 79 08 01          	cmp    DWORD PTR [rcx+0x8],0x1
  40bf6a:	75 34                	jne    40bfa0 <args_iter_next+0x70>
	if (i->curr == i->len) return 0;
  40bf6c:	48 63 57 10          	movsxd rdx,DWORD PTR [rdi+0x10]
  40bf70:	3b 57 14             	cmp    edx,DWORD PTR [rdi+0x14]
  40bf73:	74 2b                	je     40bfa0 <args_iter_next+0x70>
	*ent = __kv_index(i->start, i->curr++);
  40bf75:	8d 42 01             	lea    eax,[rdx+0x1]
  40bf78:	89 47 10             	mov    DWORD PTR [rdi+0x10],eax
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  40bf7b:	3b 51 10             	cmp    edx,DWORD PTR [rcx+0x10]
  40bf7e:	7d 28                	jge    40bfa8 <args_iter_next+0x78>
  40bf80:	85 d2                	test   edx,edx
  40bf82:	78 24                	js     40bfa8 <args_iter_next+0x78>
	return kv->val.arr.kvs[idx];
  40bf84:	48 8b 41 18          	mov    rax,QWORD PTR [rcx+0x18]
  40bf88:	48 8b 04 d0          	mov    rax,QWORD PTR [rax+rdx*8]
	*ent = __kv_index(i->start, i->curr++);
  40bf8c:	48 89 46 08          	mov    QWORD PTR [rsi+0x8],rax
	return 1;
  40bf90:	b8 01 00 00 00       	mov    eax,0x1
  40bf95:	c3                   	ret    
  40bf96:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40bf9d:	00 00 00 
}
  40bfa0:	c3                   	ret    
  40bfa1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  40bfa8:	31 c0                	xor    eax,eax
  40bfaa:	eb e0                	jmp    40bf8c <args_iter_next+0x5c>
  40bfac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000040bfb0 <args_iter>:
{
  40bfb0:	f3 0f 1e fa          	endbr64 
	i->type = ent->type = arg->type;
  40bfb4:	8b 07                	mov    eax,DWORD PTR [rdi]
  40bfb6:	89 02                	mov    DWORD PTR [rdx],eax
  40bfb8:	89 06                	mov    DWORD PTR [rsi],eax
	switch (arg->type) {
  40bfba:	85 c0                	test   eax,eax
  40bfbc:	74 3a                	je     40bff8 <args_iter+0x48>
  40bfbe:	83 f8 01             	cmp    eax,0x1
  40bfc1:	75 2d                	jne    40bff0 <args_iter+0x40>
	case ARGS_IMPL_TAR: return tar_iter(&arg->d.tar_ent, &i->i.tar_i, &ent->d.tar_ent);
  40bfc3:	48 83 c2 08          	add    rdx,0x8
  40bfc7:	48 83 c6 08          	add    rsi,0x8
  40bfcb:	48 83 c7 08          	add    rdi,0x8
  40bfcf:	48 b8 80 cc 40 00 00 	movabs rax,0x40cc80
  40bfd6:	00 00 00 
  40bfd9:	ff e0                	jmp    rax
  40bfdb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	*i = (struct kv_iter){
  40bfe0:	48 c7 46 08 00 00 00 	mov    QWORD PTR [rsi+0x8],0x0
  40bfe7:	00 
  40bfe8:	48 c7 46 10 00 00 00 	mov    QWORD PTR [rsi+0x10],0x0
  40bfef:	00 
	if (i->start->vtype != VTYPE_ARR) return 0;
  40bff0:	31 c0                	xor    eax,eax
  40bff2:	c3                   	ret    
  40bff3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40bff8:	48 8b 4f 08          	mov    rcx,QWORD PTR [rdi+0x8]
	if (!kv) return 0;
  40bffc:	48 85 c9             	test   rcx,rcx
  40bfff:	74 df                	je     40bfe0 <args_iter+0x30>
	switch (kv->vtype) {
  40c001:	8b 41 08             	mov    eax,DWORD PTR [rcx+0x8]
  40c004:	85 c0                	test   eax,eax
  40c006:	74 38                	je     40c040 <args_iter+0x90>
  40c008:	83 f8 01             	cmp    eax,0x1
  40c00b:	74 13                	je     40c020 <args_iter+0x70>
	*i = (struct kv_iter){
  40c00d:	48 89 4e 08          	mov    QWORD PTR [rsi+0x8],rcx
	if (i->start->vtype != VTYPE_ARR) return 0;
  40c011:	31 c0                	xor    eax,eax
	*i = (struct kv_iter){
  40c013:	48 c7 46 10 00 00 00 	mov    QWORD PTR [rsi+0x10],0x0
  40c01a:	00 
	if (i->start->vtype != VTYPE_ARR) return 0;
  40c01b:	c3                   	ret    
  40c01c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	case VTYPE_ARR: return kv->val.arr.sz;
  40c020:	8b 41 10             	mov    eax,DWORD PTR [rcx+0x10]
	*i = (struct kv_iter){
  40c023:	48 89 4e 08          	mov    QWORD PTR [rsi+0x8],rcx
  40c027:	c7 46 10 00 00 00 00 	mov    DWORD PTR [rsi+0x10],0x0
  40c02e:	89 46 14             	mov    DWORD PTR [rsi+0x14],eax
	if (i->curr == i->len) return 0;
  40c031:	85 c0                	test   eax,eax
  40c033:	75 2b                	jne    40c060 <args_iter+0xb0>
}
  40c035:	c3                   	ret    
  40c036:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40c03d:	00 00 00 
	*i = (struct kv_iter){
  40c040:	48 b8 d8 fd 41 00 00 	movabs rax,0x41fdd8
  40c047:	00 00 00 
  40c04a:	48 89 4e 08          	mov    QWORD PTR [rsi+0x8],rcx
  40c04e:	48 8b 00             	mov    rax,QWORD PTR [rax]
  40c051:	48 89 46 10          	mov    QWORD PTR [rsi+0x10],rax
	if (i->start->vtype != VTYPE_ARR) return 0;
  40c055:	31 c0                	xor    eax,eax
  40c057:	c3                   	ret    
  40c058:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40c05f:	00 
	*ent = __kv_index(i->start, i->curr++);
  40c060:	c7 46 10 01 00 00 00 	mov    DWORD PTR [rsi+0x10],0x1
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  40c067:	7e 17                	jle    40c080 <args_iter+0xd0>
	return kv->val.arr.kvs[idx];
  40c069:	48 8b 41 18          	mov    rax,QWORD PTR [rcx+0x18]
  40c06d:	48 8b 00             	mov    rax,QWORD PTR [rax]
	*ent = __kv_index(i->start, i->curr++);
  40c070:	48 89 42 08          	mov    QWORD PTR [rdx+0x8],rax
	return 1;
  40c074:	b8 01 00 00 00       	mov    eax,0x1
  40c079:	c3                   	ret    
  40c07a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  40c080:	31 c0                	xor    eax,eax
  40c082:	eb ec                	jmp    40c070 <args_iter+0xc0>
  40c084:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40c08b:	00 00 00 00 
  40c08f:	90                   	nop

000000000040c090 <args_foreach>:

typedef void (*args_visitor_fn_t)(struct initargs *ent, void *data);

int
args_foreach(struct initargs *ent, args_visitor_fn_t fn, void *data)
{
  40c090:	f3 0f 1e fa          	endbr64 
	struct initargs_iter i;
	struct initargs curr;
	int cont;

	if (!ent) return -1;
  40c094:	48 85 ff             	test   rdi,rdi
  40c097:	0f 84 e7 00 00 00    	je     40c184 <args_foreach+0xf4>
{
  40c09d:	55                   	push   rbp
  40c09e:	48 89 e5             	mov    rbp,rsp
  40c0a1:	41 56                	push   r14
  40c0a3:	41 55                	push   r13
  40c0a5:	41 54                	push   r12
  40c0a7:	49 89 d4             	mov    r12,rdx
  40c0aa:	53                   	push   rbx
  40c0ab:	48 89 f3             	mov    rbx,rsi
  40c0ae:	48 83 ec 40          	sub    rsp,0x40
	i->type = ent->type = arg->type;
  40c0b2:	8b 07                	mov    eax,DWORD PTR [rdi]
  40c0b4:	89 45 a0             	mov    DWORD PTR [rbp-0x60],eax
  40c0b7:	89 45 c0             	mov    DWORD PTR [rbp-0x40],eax
	switch (arg->type) {
  40c0ba:	85 c0                	test   eax,eax
  40c0bc:	0f 84 9e 00 00 00    	je     40c160 <args_foreach+0xd0>
  40c0c2:	83 f8 01             	cmp    eax,0x1
  40c0c5:	75 57                	jne    40c11e <args_foreach+0x8e>
	case ARGS_IMPL_TAR: return tar_iter(&arg->d.tar_ent, &i->i.tar_i, &ent->d.tar_ent);
  40c0c7:	48 83 c7 08          	add    rdi,0x8
  40c0cb:	48 8d 55 a8          	lea    rdx,[rbp-0x58]
  40c0cf:	48 8d 75 c8          	lea    rsi,[rbp-0x38]
  40c0d3:	48 b8 80 cc 40 00 00 	movabs rax,0x40cc80
  40c0da:	00 00 00 
  40c0dd:	ff d0                	call   rax
	for (cont = args_iter(ent, &i, &curr); cont; cont = args_iter_next(&i, &curr)) {
  40c0df:	85 c0                	test   eax,eax
  40c0e1:	74 3b                	je     40c11e <args_foreach+0x8e>
	case ARGS_IMPL_TAR: return tar_iter_next(&i->i.tar_i, &arg->d.tar_ent);
  40c0e3:	49 be 40 c9 40 00 00 	movabs r14,0x40c940
  40c0ea:	00 00 00 
  40c0ed:	4c 8d 6d a0          	lea    r13,[rbp-0x60]
  40c0f1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		fn(&curr, data);
  40c0f8:	4c 89 e6             	mov    rsi,r12
  40c0fb:	4c 89 ef             	mov    rdi,r13
  40c0fe:	ff d3                	call   rbx
	arg->type = i->type;
  40c100:	8b 45 c0             	mov    eax,DWORD PTR [rbp-0x40]
  40c103:	89 45 a0             	mov    DWORD PTR [rbp-0x60],eax
	switch (i->type) {
  40c106:	85 c0                	test   eax,eax
  40c108:	74 26                	je     40c130 <args_foreach+0xa0>
  40c10a:	83 f8 01             	cmp    eax,0x1
  40c10d:	75 0f                	jne    40c11e <args_foreach+0x8e>
	case ARGS_IMPL_TAR: return tar_iter_next(&i->i.tar_i, &arg->d.tar_ent);
  40c10f:	48 8d 75 a8          	lea    rsi,[rbp-0x58]
  40c113:	48 8d 7d c8          	lea    rdi,[rbp-0x38]
  40c117:	41 ff d6             	call   r14
	for (cont = args_iter(ent, &i, &curr); cont; cont = args_iter_next(&i, &curr)) {
  40c11a:	85 c0                	test   eax,eax
  40c11c:	75 da                	jne    40c0f8 <args_foreach+0x68>
	}

	return 0;
}
  40c11e:	48 83 c4 40          	add    rsp,0x40
	return 0;
  40c122:	31 c0                	xor    eax,eax
}
  40c124:	5b                   	pop    rbx
  40c125:	41 5c                	pop    r12
  40c127:	41 5d                	pop    r13
  40c129:	41 5e                	pop    r14
  40c12b:	5d                   	pop    rbp
  40c12c:	c3                   	ret    
  40c12d:	0f 1f 00             	nop    DWORD PTR [rax]
	if (i->start->vtype != VTYPE_ARR) return 0;
  40c130:	48 8b 55 c8          	mov    rdx,QWORD PTR [rbp-0x38]
  40c134:	83 7a 08 01          	cmp    DWORD PTR [rdx+0x8],0x1
  40c138:	75 e4                	jne    40c11e <args_foreach+0x8e>
	if (i->curr == i->len) return 0;
  40c13a:	48 63 45 d0          	movsxd rax,DWORD PTR [rbp-0x30]
  40c13e:	3b 45 d4             	cmp    eax,DWORD PTR [rbp-0x2c]
  40c141:	74 db                	je     40c11e <args_foreach+0x8e>
	*ent = __kv_index(i->start, i->curr++);
  40c143:	8d 48 01             	lea    ecx,[rax+0x1]
  40c146:	89 4d d0             	mov    DWORD PTR [rbp-0x30],ecx
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  40c149:	3b 42 10             	cmp    eax,DWORD PTR [rdx+0x10]
  40c14c:	7d 32                	jge    40c180 <args_foreach+0xf0>
  40c14e:	85 c0                	test   eax,eax
  40c150:	78 2e                	js     40c180 <args_foreach+0xf0>
	return kv->val.arr.kvs[idx];
  40c152:	48 8b 52 18          	mov    rdx,QWORD PTR [rdx+0x18]
  40c156:	48 8b 04 c2          	mov    rax,QWORD PTR [rdx+rax*8]
	*ent = __kv_index(i->start, i->curr++);
  40c15a:	48 89 45 a8          	mov    QWORD PTR [rbp-0x58],rax
	for (cont = args_iter(ent, &i, &curr); cont; cont = args_iter_next(&i, &curr)) {
  40c15e:	eb 98                	jmp    40c0f8 <args_foreach+0x68>
  40c160:	4c 8d 6d a0          	lea    r13,[rbp-0x60]
  40c164:	48 8b 7f 08          	mov    rdi,QWORD PTR [rdi+0x8]
  40c168:	48 8d 75 c0          	lea    rsi,[rbp-0x40]
  40c16c:	48 b8 90 bd 40 00 00 	movabs rax,0x40bd90
  40c173:	00 00 00 
  40c176:	4c 89 ea             	mov    rdx,r13
  40c179:	ff d0                	call   rax
  40c17b:	e9 5f ff ff ff       	jmp    40c0df <args_foreach+0x4f>
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  40c180:	31 c0                	xor    eax,eax
  40c182:	eb d6                	jmp    40c15a <args_foreach+0xca>
	if (!ent) return -1;
  40c184:	b8 ff ff ff ff       	mov    eax,0xffffffff
}
  40c189:	c3                   	ret    
  40c18a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000040c190 <args_lkup_entry>:
 * not including a '/').  This enables this function to be used to
 * walk through the data-structure guided by a path through the k/v.
 */
int
args_lkup_entry(struct initargs *arg, char *path, struct initargs *ret)
{
  40c190:	f3 0f 1e fa          	endbr64 
  40c194:	55                   	push   rbp
  40c195:	48 89 e5             	mov    rbp,rsp
  40c198:	41 57                	push   r15
  40c19a:	41 56                	push   r14
  40c19c:	41 55                	push   r13
  40c19e:	41 54                	push   r12
  40c1a0:	53                   	push   rbx
  40c1a1:	48 81 ec 98 00 00 00 	sub    rsp,0x98
	struct initargs_iter i;
	struct initargs curr, start;
	unsigned int len, cont;
	char *slash, *key = path;

	if (!arg || !key || !ret) return -1;
  40c1a8:	48 85 ff             	test   rdi,rdi
{
  40c1ab:	48 89 95 48 ff ff ff 	mov    QWORD PTR [rbp-0xb8],rdx
	if (!arg || !key || !ret) return -1;
  40c1b2:	0f 94 c0             	sete   al
  40c1b5:	48 85 d2             	test   rdx,rdx
  40c1b8:	0f 94 c2             	sete   dl
  40c1bb:	08 d0                	or     al,dl
  40c1bd:	0f 85 cd 01 00 00    	jne    40c390 <args_lkup_entry+0x200>
  40c1c3:	49 89 f4             	mov    r12,rsi
  40c1c6:	48 85 f6             	test   rsi,rsi
  40c1c9:	0f 84 c1 01 00 00    	je     40c390 <args_lkup_entry+0x200>
	start = *arg;
  40c1cf:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  40c1d3:	f3 0f 6f 07          	movdqu xmm0,XMMWORD PTR [rdi]
  40c1d7:	48 89 45 a0          	mov    QWORD PTR [rbp-0x60],rax
  40c1db:	0f 29 45 90          	movaps XMMWORD PTR [rbp-0x70],xmm0
	/* Iterate through the path... */
	do {
		int found = 0;

		slash = strchr(key, '/');
  40c1df:	be 2f 00 00 00       	mov    esi,0x2f
  40c1e4:	4c 89 e7             	mov    rdi,r12
  40c1e7:	48 b8 e0 82 41 00 00 	movabs rax,0x4182e0
  40c1ee:	00 00 00 
  40c1f1:	ff d0                	call   rax
  40c1f3:	48 89 85 50 ff ff ff 	mov    QWORD PTR [rbp-0xb0],rax
		len = slash ? (unsigned int)(slash - key) : strlen(key);
  40c1fa:	48 85 c0             	test   rax,rax
  40c1fd:	0f 84 2d 02 00 00    	je     40c430 <args_lkup_entry+0x2a0>
  40c203:	89 c3                	mov    ebx,eax
  40c205:	44 29 e3             	sub    ebx,r12d
	i->type = ent->type = arg->type;
  40c208:	8b 45 90             	mov    eax,DWORD PTR [rbp-0x70]
  40c20b:	89 85 70 ff ff ff    	mov    DWORD PTR [rbp-0x90],eax
  40c211:	89 45 b0             	mov    DWORD PTR [rbp-0x50],eax
	switch (arg->type) {
  40c214:	85 c0                	test   eax,eax
  40c216:	0f 84 f4 01 00 00    	je     40c410 <args_lkup_entry+0x280>
  40c21c:	83 f8 01             	cmp    eax,0x1
  40c21f:	0f 85 6b 01 00 00    	jne    40c390 <args_lkup_entry+0x200>
	case ARGS_IMPL_TAR: return tar_iter(&arg->d.tar_ent, &i->i.tar_i, &ent->d.tar_ent);
  40c225:	48 8d 95 78 ff ff ff 	lea    rdx,[rbp-0x88]
  40c22c:	48 8d 75 b8          	lea    rsi,[rbp-0x48]
  40c230:	48 b8 80 cc 40 00 00 	movabs rax,0x40cc80
  40c237:	00 00 00 
  40c23a:	48 8d 7d 98          	lea    rdi,[rbp-0x68]
  40c23e:	ff d0                	call   rax

		/* ...and look the key up in the KV */
		for (cont = args_iter(&start, &i, &curr) ; cont ; cont = args_iter_next(&i, &curr)) {
  40c240:	85 c0                	test   eax,eax
  40c242:	0f 84 48 01 00 00    	je     40c390 <args_lkup_entry+0x200>
			int key_len;
			char *k = args_key(&curr, &key_len);

			if ((unsigned int)key_len == len && strncmp(k, key, len) == 0) {
  40c248:	49 be 10 85 41 00 00 	movabs r14,0x418510
  40c24f:	00 00 00 
	switch (arg->type) {
  40c252:	8b 85 70 ff ff ff    	mov    eax,DWORD PTR [rbp-0x90]
	case ARGS_IMPL_TAR: return tar_iter_next(&i->i.tar_i, &arg->d.tar_ent);
  40c258:	49 bd 40 c9 40 00 00 	movabs r13,0x40c940
  40c25f:	00 00 00 
  40c262:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	switch (arg->type) {
  40c268:	85 c0                	test   eax,eax
  40c26a:	74 7b                	je     40c2e7 <args_lkup_entry+0x157>
  40c26c:	83 f8 01             	cmp    eax,0x1
  40c26f:	0f 84 63 01 00 00    	je     40c3d8 <args_lkup_entry+0x248>
			if ((unsigned int)key_len == len && strncmp(k, key, len) == 0) {
  40c275:	8b 95 6c ff ff ff    	mov    edx,DWORD PTR [rbp-0x94]
	default:            return NULL;
  40c27b:	31 ff                	xor    edi,edi
			if ((unsigned int)key_len == len && strncmp(k, key, len) == 0) {
  40c27d:	39 da                	cmp    edx,ebx
  40c27f:	75 14                	jne    40c295 <args_lkup_entry+0x105>
  40c281:	41 89 d7             	mov    r15d,edx
  40c284:	4c 89 e6             	mov    rsi,r12
  40c287:	4c 89 fa             	mov    rdx,r15
  40c28a:	41 ff d6             	call   r14
  40c28d:	85 c0                	test   eax,eax
  40c28f:	0f 84 a3 00 00 00    	je     40c338 <args_lkup_entry+0x1a8>
	arg->type = i->type;
  40c295:	8b 45 b0             	mov    eax,DWORD PTR [rbp-0x50]
  40c298:	89 85 70 ff ff ff    	mov    DWORD PTR [rbp-0x90],eax
	switch (i->type) {
  40c29e:	85 c0                	test   eax,eax
  40c2a0:	0f 85 0a 01 00 00    	jne    40c3b0 <args_lkup_entry+0x220>
	if (i->start->vtype != VTYPE_ARR) return 0;
  40c2a6:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
  40c2aa:	83 7a 08 01          	cmp    DWORD PTR [rdx+0x8],0x1
  40c2ae:	0f 85 dc 00 00 00    	jne    40c390 <args_lkup_entry+0x200>
	if (i->curr == i->len) return 0;
  40c2b4:	48 63 45 c0          	movsxd rax,DWORD PTR [rbp-0x40]
  40c2b8:	3b 45 c4             	cmp    eax,DWORD PTR [rbp-0x3c]
  40c2bb:	0f 84 cf 00 00 00    	je     40c390 <args_lkup_entry+0x200>
	*ent = __kv_index(i->start, i->curr++);
  40c2c1:	8d 48 01             	lea    ecx,[rax+0x1]
  40c2c4:	89 4d c0             	mov    DWORD PTR [rbp-0x40],ecx
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  40c2c7:	3b 42 10             	cmp    eax,DWORD PTR [rdx+0x10]
  40c2ca:	0f 8d 30 01 00 00    	jge    40c400 <args_lkup_entry+0x270>
  40c2d0:	85 c0                	test   eax,eax
  40c2d2:	0f 88 28 01 00 00    	js     40c400 <args_lkup_entry+0x270>
	return kv->val.arr.kvs[idx];
  40c2d8:	48 8b 52 18          	mov    rdx,QWORD PTR [rdx+0x18]
  40c2dc:	48 8b 04 c2          	mov    rax,QWORD PTR [rdx+rax*8]
	*ent = __kv_index(i->start, i->curr++);
  40c2e0:	48 89 85 78 ff ff ff 	mov    QWORD PTR [rbp-0x88],rax
	switch (arg->type) {
  40c2e7:	48 8b bd 78 ff ff ff 	mov    rdi,QWORD PTR [rbp-0x88]
	if (!kv) return NULL;
  40c2ee:	48 85 ff             	test   rdi,rdi
  40c2f1:	0f 84 fe 00 00 00    	je     40c3f5 <args_lkup_entry+0x265>
	*key_len = strlen(kv->key);
  40c2f7:	48 b8 90 84 41 00 00 	movabs rax,0x418490
  40c2fe:	00 00 00 
  40c301:	48 8b 3f             	mov    rdi,QWORD PTR [rdi]
  40c304:	48 89 bd 58 ff ff ff 	mov    QWORD PTR [rbp-0xa8],rdi
  40c30b:	ff d0                	call   rax
	return kv->key;
  40c30d:	48 8b bd 58 ff ff ff 	mov    rdi,QWORD PTR [rbp-0xa8]
	*key_len = strlen(kv->key);
  40c314:	89 c2                	mov    edx,eax
  40c316:	89 85 6c ff ff ff    	mov    DWORD PTR [rbp-0x94],eax
			if ((unsigned int)key_len == len && strncmp(k, key, len) == 0) {
  40c31c:	39 da                	cmp    edx,ebx
  40c31e:	0f 85 71 ff ff ff    	jne    40c295 <args_lkup_entry+0x105>
  40c324:	41 89 d7             	mov    r15d,edx
  40c327:	4c 89 e6             	mov    rsi,r12
  40c32a:	4c 89 fa             	mov    rdx,r15
  40c32d:	41 ff d6             	call   r14
  40c330:	85 c0                	test   eax,eax
  40c332:	0f 85 5d ff ff ff    	jne    40c295 <args_lkup_entry+0x105>
  40c338:	89 85 58 ff ff ff    	mov    DWORD PTR [rbp-0xa8],eax
				if (strlen(key) == len) {
  40c33e:	4c 89 e7             	mov    rdi,r12
  40c341:	48 b8 90 84 41 00 00 	movabs rax,0x418490
  40c348:	00 00 00 
  40c34b:	ff d0                	call   rax
  40c34d:	44 8b 85 58 ff ff ff 	mov    r8d,DWORD PTR [rbp-0xa8]
  40c354:	49 39 c7             	cmp    r15,rax
  40c357:	0f 84 e9 00 00 00    	je     40c446 <args_lkup_entry+0x2b6>
					*ret = curr;
					return 0;
				}
				start = curr;
  40c35d:	66 0f 6f 8d 70 ff ff 	movdqa xmm1,XMMWORD PTR [rbp-0x90]
  40c364:	ff 
  40c365:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
				break;
			}
		}
		if (!found) return -1;

		if (slash) key = slash + 1;
  40c369:	48 83 bd 50 ff ff ff 	cmp    QWORD PTR [rbp-0xb0],0x0
  40c370:	00 
				start = curr;
  40c371:	48 89 45 a0          	mov    QWORD PTR [rbp-0x60],rax
  40c375:	0f 29 4d 90          	movaps XMMWORD PTR [rbp-0x70],xmm1
		if (slash) key = slash + 1;
  40c379:	74 15                	je     40c390 <args_lkup_entry+0x200>
  40c37b:	48 8b 85 50 ff ff ff 	mov    rax,QWORD PTR [rbp-0xb0]
	} while (slash && *key != '\0');
  40c382:	80 78 01 00          	cmp    BYTE PTR [rax+0x1],0x0
		if (slash) key = slash + 1;
  40c386:	4c 8d 60 01          	lea    r12,[rax+0x1]
	} while (slash && *key != '\0');
  40c38a:	0f 85 4f fe ff ff    	jne    40c1df <args_lkup_entry+0x4f>
		if (!found) return -1;
  40c390:	41 b8 ff ff ff ff    	mov    r8d,0xffffffff

	return -1;
}
  40c396:	48 81 c4 98 00 00 00 	add    rsp,0x98
  40c39d:	44 89 c0             	mov    eax,r8d
  40c3a0:	5b                   	pop    rbx
  40c3a1:	41 5c                	pop    r12
  40c3a3:	41 5d                	pop    r13
  40c3a5:	41 5e                	pop    r14
  40c3a7:	41 5f                	pop    r15
  40c3a9:	5d                   	pop    rbp
  40c3aa:	c3                   	ret    
  40c3ab:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	switch (i->type) {
  40c3b0:	83 f8 01             	cmp    eax,0x1
  40c3b3:	75 db                	jne    40c390 <args_lkup_entry+0x200>
	case ARGS_IMPL_TAR: return tar_iter_next(&i->i.tar_i, &arg->d.tar_ent);
  40c3b5:	48 8d b5 78 ff ff ff 	lea    rsi,[rbp-0x88]
  40c3bc:	48 8d 7d b8          	lea    rdi,[rbp-0x48]
  40c3c0:	41 ff d5             	call   r13
		for (cont = args_iter(&start, &i, &curr) ; cont ; cont = args_iter_next(&i, &curr)) {
  40c3c3:	85 c0                	test   eax,eax
  40c3c5:	74 c9                	je     40c390 <args_lkup_entry+0x200>
	switch (arg->type) {
  40c3c7:	8b 85 70 ff ff ff    	mov    eax,DWORD PTR [rbp-0x90]
  40c3cd:	e9 96 fe ff ff       	jmp    40c268 <args_lkup_entry+0xd8>
  40c3d2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	case ARGS_IMPL_TAR: return tar_key(&arg->d.tar_ent, arg_len);
  40c3d8:	48 8d bd 78 ff ff ff 	lea    rdi,[rbp-0x88]
  40c3df:	48 8d b5 6c ff ff ff 	lea    rsi,[rbp-0x94]
  40c3e6:	48 b8 f0 c6 40 00 00 	movabs rax,0x40c6f0
  40c3ed:	00 00 00 
  40c3f0:	ff d0                	call   rax
  40c3f2:	48 89 c7             	mov    rdi,rax
			if ((unsigned int)key_len == len && strncmp(k, key, len) == 0) {
  40c3f5:	8b 95 6c ff ff ff    	mov    edx,DWORD PTR [rbp-0x94]
	case ARGS_IMPL_TAR: return tar_key(&arg->d.tar_ent, arg_len);
  40c3fb:	e9 7d fe ff ff       	jmp    40c27d <args_lkup_entry+0xed>
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  40c400:	31 c0                	xor    eax,eax
  40c402:	e9 d9 fe ff ff       	jmp    40c2e0 <args_lkup_entry+0x150>
  40c407:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40c40e:	00 00 
  40c410:	48 8b 7d 98          	mov    rdi,QWORD PTR [rbp-0x68]
  40c414:	48 8d 75 b0          	lea    rsi,[rbp-0x50]
  40c418:	48 8d 95 70 ff ff ff 	lea    rdx,[rbp-0x90]
  40c41f:	48 b8 90 bd 40 00 00 	movabs rax,0x40bd90
  40c426:	00 00 00 
  40c429:	ff d0                	call   rax
  40c42b:	e9 10 fe ff ff       	jmp    40c240 <args_lkup_entry+0xb0>
		len = slash ? (unsigned int)(slash - key) : strlen(key);
  40c430:	48 b8 90 84 41 00 00 	movabs rax,0x418490
  40c437:	00 00 00 
  40c43a:	4c 89 e7             	mov    rdi,r12
  40c43d:	ff d0                	call   rax
  40c43f:	89 c3                	mov    ebx,eax
  40c441:	e9 c2 fd ff ff       	jmp    40c208 <args_lkup_entry+0x78>
					*ret = curr;
  40c446:	48 8b 8d 48 ff ff ff 	mov    rcx,QWORD PTR [rbp-0xb8]
  40c44d:	66 0f 6f 95 70 ff ff 	movdqa xmm2,XMMWORD PTR [rbp-0x90]
  40c454:	ff 
  40c455:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  40c459:	0f 11 11             	movups XMMWORD PTR [rcx],xmm2
  40c45c:	48 89 41 10          	mov    QWORD PTR [rcx+0x10],rax
					return 0;
  40c460:	e9 31 ff ff ff       	jmp    40c396 <args_lkup_entry+0x206>
  40c465:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40c46c:	00 00 00 00 

000000000040c470 <args_type>:

args_type_t
args_type(struct initargs *ent)
{
  40c470:	f3 0f 1e fa          	endbr64 
  40c474:	55                   	push   rbp
  40c475:	48 89 e5             	mov    rbp,rsp
  40c478:	41 54                	push   r12
  40c47a:	48 83 ec 08          	sub    rsp,0x8
	switch (ent->type) {
  40c47e:	44 8b 27             	mov    r12d,DWORD PTR [rdi]
  40c481:	45 85 e4             	test   r12d,r12d
  40c484:	74 3a                	je     40c4c0 <args_type+0x50>
  40c486:	41 83 fc 01          	cmp    r12d,0x1
  40c48a:	75 24                	jne    40c4b0 <args_type+0x40>
	case ARGS_IMPL_KV:  return kv_type(ent->d.kv_ent);
	case ARGS_IMPL_TAR: return tar_is_value(&ent->d.tar_ent) ? ARGS_VAL : ARGS_MAP;
  40c48c:	48 b8 e0 c8 40 00 00 	movabs rax,0x40c8e0
  40c493:	00 00 00 
  40c496:	48 83 c7 08          	add    rdi,0x8
  40c49a:	ff d0                	call   rax
  40c49c:	85 c0                	test   eax,eax
  40c49e:	b8 02 00 00 00       	mov    eax,0x2
  40c4a3:	44 0f 45 e0          	cmovne r12d,eax
	default:            return ARGS_ERR;
	}
}
  40c4a7:	44 89 e0             	mov    eax,r12d
  40c4aa:	4c 8b 65 f8          	mov    r12,QWORD PTR [rbp-0x8]
  40c4ae:	c9                   	leave  
  40c4af:	c3                   	ret    
	switch (ent->type) {
  40c4b0:	45 31 e4             	xor    r12d,r12d
}
  40c4b3:	44 89 e0             	mov    eax,r12d
  40c4b6:	4c 8b 65 f8          	mov    r12,QWORD PTR [rbp-0x8]
  40c4ba:	c9                   	leave  
  40c4bb:	c3                   	ret    
  40c4bc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	switch (kv->vtype) {
  40c4c0:	48 8b 47 08          	mov    rax,QWORD PTR [rdi+0x8]
	case VTYPE_STR: return ARGS_VAL;
  40c4c4:	41 bc 02 00 00 00    	mov    r12d,0x2
	switch (kv->vtype) {
  40c4ca:	8b 40 08             	mov    eax,DWORD PTR [rax+0x8]
  40c4cd:	85 c0                	test   eax,eax
  40c4cf:	74 d6                	je     40c4a7 <args_type+0x37>
  40c4d1:	45 31 e4             	xor    r12d,r12d
  40c4d4:	83 f8 01             	cmp    eax,0x1
  40c4d7:	41 0f 94 c4          	sete   r12b
}
  40c4db:	44 89 e0             	mov    eax,r12d
  40c4de:	4c 8b 65 f8          	mov    r12,QWORD PTR [rbp-0x8]
  40c4e2:	c9                   	leave  
  40c4e3:	c3                   	ret    
  40c4e4:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40c4eb:	00 00 00 00 
  40c4ef:	90                   	nop

000000000040c4f0 <args_get_entry_from>:

int
args_get_entry_from(char *path, struct initargs *from, struct initargs *ent)
{
  40c4f0:	f3 0f 1e fa          	endbr64 
	return args_lkup_entry(from, path, ent);
  40c4f4:	48 b8 90 c1 40 00 00 	movabs rax,0x40c190
  40c4fb:	00 00 00 
{
  40c4fe:	49 89 f8             	mov    r8,rdi
  40c501:	48 89 f7             	mov    rdi,rsi
	return args_lkup_entry(from, path, ent);
  40c504:	4c 89 c6             	mov    rsi,r8
  40c507:	ff e0                	jmp    rax
  40c509:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000040c510 <args_get_from>:
}

char *
args_get_from(char *path, struct initargs *from)
{
  40c510:	f3 0f 1e fa          	endbr64 
	return args_lkup_entry(from, path, ent);
  40c514:	48 b8 90 c1 40 00 00 	movabs rax,0x40c190
  40c51b:	00 00 00 
{
  40c51e:	55                   	push   rbp
  40c51f:	49 89 f8             	mov    r8,rdi
  40c522:	48 89 f7             	mov    rdi,rsi
	return args_lkup_entry(from, path, ent);
  40c525:	4c 89 c6             	mov    rsi,r8
{
  40c528:	48 89 e5             	mov    rbp,rsp
  40c52b:	48 83 ec 20          	sub    rsp,0x20
	return args_lkup_entry(from, path, ent);
  40c52f:	48 8d 55 e0          	lea    rdx,[rbp-0x20]
  40c533:	ff d0                	call   rax
  40c535:	41 89 c0             	mov    r8d,eax
	struct initargs ent;

	if (args_get_entry_from(path, from, &ent)) return NULL;
  40c538:	31 c0                	xor    eax,eax
  40c53a:	45 85 c0             	test   r8d,r8d
  40c53d:	75 0c                	jne    40c54b <args_get_from+0x3b>
	switch (arg->type) {
  40c53f:	8b 55 e0             	mov    edx,DWORD PTR [rbp-0x20]
  40c542:	85 d2                	test   edx,edx
  40c544:	74 22                	je     40c568 <args_get_from+0x58>
  40c546:	83 fa 01             	cmp    edx,0x1
  40c549:	74 05                	je     40c550 <args_get_from+0x40>

	return args_value(&ent);
}
  40c54b:	c9                   	leave  
  40c54c:	c3                   	ret    
  40c54d:	0f 1f 00             	nop    DWORD PTR [rax]
	case ARGS_IMPL_TAR: return tar_value(&arg->d.tar_ent);
  40c550:	48 b8 c0 c7 40 00 00 	movabs rax,0x40c7c0
  40c557:	00 00 00 
  40c55a:	48 8d 7d e8          	lea    rdi,[rbp-0x18]
  40c55e:	ff d0                	call   rax
}
  40c560:	c9                   	leave  
  40c561:	c3                   	ret    
  40c562:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40c568:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
	if (!kv) return NULL;
  40c56c:	48 85 c0             	test   rax,rax
  40c56f:	74 da                	je     40c54b <args_get_from+0x3b>
	switch (kv->vtype) {
  40c571:	8b 50 08             	mov    edx,DWORD PTR [rax+0x8]
  40c574:	85 d2                	test   edx,edx
  40c576:	75 08                	jne    40c580 <args_get_from+0x70>
	case VTYPE_STR: return kv->val.str;
  40c578:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
}
  40c57c:	c9                   	leave  
  40c57d:	c3                   	ret    
  40c57e:	66 90                	xchg   ax,ax
  40c580:	c9                   	leave  
	if (args_get_entry_from(path, from, &ent)) return NULL;
  40c581:	31 c0                	xor    eax,eax
}
  40c583:	c3                   	ret    
  40c584:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40c58b:	00 00 00 00 
  40c58f:	90                   	nop

000000000040c590 <args_get_entry>:
 * structure, which is just a /-separated set of keys used to lookup
 * in the corresponding maps.
 */
int
args_get_entry(char *path, struct initargs *ent)
{
  40c590:	f3 0f 1e fa          	endbr64 
  40c594:	55                   	push   rbp
	return args_lkup_entry(from, path, ent);
  40c595:	48 89 f2             	mov    rdx,rsi
{
  40c598:	48 89 e5             	mov    rbp,rsp
  40c59b:	41 55                	push   r13
  40c59d:	49 89 f5             	mov    r13,rsi
	return args_lkup_entry(from, path, ent);
  40c5a0:	48 89 fe             	mov    rsi,rdi
{
  40c5a3:	41 54                	push   r12
  40c5a5:	49 89 fc             	mov    r12,rdi
	return args_lkup_entry(from, path, ent);
  40c5a8:	48 bf 20 80 42 00 00 	movabs rdi,0x428020
  40c5af:	00 00 00 
{
  40c5b2:	53                   	push   rbx
	return args_lkup_entry(from, path, ent);
  40c5b3:	48 bb 90 c1 40 00 00 	movabs rbx,0x40c190
  40c5ba:	00 00 00 
{
  40c5bd:	48 83 ec 28          	sub    rsp,0x28
	return args_lkup_entry(from, path, ent);
  40c5c1:	ff d3                	call   rbx
	struct initargs tarroot;
	struct tar_entry *tarent;

	if (!args_get_entry_from(path, &__initargs_root, ent)) return 0;
  40c5c3:	85 c0                	test   eax,eax
  40c5c5:	75 11                	jne    40c5d8 <args_get_entry+0x48>
		.type = ARGS_IMPL_TAR,
		.d.tar_ent = *tarent
	};

	return args_get_entry_from(path, &tarroot, ent);
}
  40c5c7:	48 83 c4 28          	add    rsp,0x28
  40c5cb:	5b                   	pop    rbx
  40c5cc:	41 5c                	pop    r12
  40c5ce:	41 5d                	pop    r13
  40c5d0:	5d                   	pop    rbp
  40c5d1:	c3                   	ret    
  40c5d2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	tarent = tar_root();
  40c5d8:	48 b8 90 cd 40 00 00 	movabs rax,0x40cd90
  40c5df:	00 00 00 
  40c5e2:	ff d0                	call   rax
	if (!tarent) return -1;
  40c5e4:	48 85 c0             	test   rax,rax
  40c5e7:	74 2b                	je     40c614 <args_get_entry+0x84>
		.d.tar_ent = *tarent
  40c5e9:	8b 10                	mov    edx,DWORD PTR [rax]
  40c5eb:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	tarroot = (struct initargs) {
  40c5ef:	c7 45 c0 01 00 00 00 	mov    DWORD PTR [rbp-0x40],0x1
	return args_lkup_entry(from, path, ent);
  40c5f6:	4c 89 e6             	mov    rsi,r12
  40c5f9:	48 8d 7d c0          	lea    rdi,[rbp-0x40]
	tarroot = (struct initargs) {
  40c5fd:	89 55 c8             	mov    DWORD PTR [rbp-0x38],edx
	return args_lkup_entry(from, path, ent);
  40c600:	4c 89 ea             	mov    rdx,r13
	tarroot = (struct initargs) {
  40c603:	48 89 45 d0          	mov    QWORD PTR [rbp-0x30],rax
	return args_lkup_entry(from, path, ent);
  40c607:	ff d3                	call   rbx
}
  40c609:	48 83 c4 28          	add    rsp,0x28
  40c60d:	5b                   	pop    rbx
  40c60e:	41 5c                	pop    r12
  40c610:	41 5d                	pop    r13
  40c612:	5d                   	pop    rbp
  40c613:	c3                   	ret    
	if (!tarent) return -1;
  40c614:	b8 ff ff ff ff       	mov    eax,0xffffffff
  40c619:	eb ac                	jmp    40c5c7 <args_get_entry+0x37>
  40c61b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000040c620 <args_get>:

char *
args_get(char *path)
{
  40c620:	f3 0f 1e fa          	endbr64 
  40c624:	55                   	push   rbp
	return args_lkup_entry(from, path, ent);
  40c625:	48 89 fe             	mov    rsi,rdi
{
  40c628:	48 89 e5             	mov    rbp,rsp
  40c62b:	41 54                	push   r12
  40c62d:	49 89 fc             	mov    r12,rdi
	return args_lkup_entry(from, path, ent);
  40c630:	48 bf 20 80 42 00 00 	movabs rdi,0x428020
  40c637:	00 00 00 
{
  40c63a:	53                   	push   rbx
	return args_lkup_entry(from, path, ent);
  40c63b:	48 8d 55 b0          	lea    rdx,[rbp-0x50]
  40c63f:	48 bb 90 c1 40 00 00 	movabs rbx,0x40c190
  40c646:	00 00 00 
{
  40c649:	48 83 ec 40          	sub    rsp,0x40
	return args_lkup_entry(from, path, ent);
  40c64d:	ff d3                	call   rbx
	if (!args_get_entry_from(path, &__initargs_root, ent)) return 0;
  40c64f:	85 c0                	test   eax,eax
  40c651:	75 5d                	jne    40c6b0 <args_get+0x90>
	switch (arg->type) {
  40c653:	8b 45 b0             	mov    eax,DWORD PTR [rbp-0x50]
  40c656:	85 c0                	test   eax,eax
  40c658:	74 36                	je     40c690 <args_get+0x70>
  40c65a:	83 f8 01             	cmp    eax,0x1
  40c65d:	74 11                	je     40c670 <args_get+0x50>
	struct initargs ent;

	if (args_get_entry(path, &ent)) return NULL;
  40c65f:	31 c0                	xor    eax,eax

	return args_value(&ent);
}
  40c661:	48 83 c4 40          	add    rsp,0x40
  40c665:	5b                   	pop    rbx
  40c666:	41 5c                	pop    r12
  40c668:	5d                   	pop    rbp
  40c669:	c3                   	ret    
  40c66a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	case ARGS_IMPL_TAR: return tar_value(&arg->d.tar_ent);
  40c670:	48 b8 c0 c7 40 00 00 	movabs rax,0x40c7c0
  40c677:	00 00 00 
  40c67a:	48 8d 7d b8          	lea    rdi,[rbp-0x48]
  40c67e:	ff d0                	call   rax
}
  40c680:	48 83 c4 40          	add    rsp,0x40
  40c684:	5b                   	pop    rbx
  40c685:	41 5c                	pop    r12
  40c687:	5d                   	pop    rbp
  40c688:	c3                   	ret    
  40c689:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  40c690:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
	if (!kv) return NULL;
  40c694:	48 85 c0             	test   rax,rax
  40c697:	74 c6                	je     40c65f <args_get+0x3f>
	switch (kv->vtype) {
  40c699:	8b 50 08             	mov    edx,DWORD PTR [rax+0x8]
  40c69c:	85 d2                	test   edx,edx
  40c69e:	75 bf                	jne    40c65f <args_get+0x3f>
	case VTYPE_STR: return kv->val.str;
  40c6a0:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
}
  40c6a4:	48 83 c4 40          	add    rsp,0x40
  40c6a8:	5b                   	pop    rbx
  40c6a9:	41 5c                	pop    r12
  40c6ab:	5d                   	pop    rbp
  40c6ac:	c3                   	ret    
  40c6ad:	0f 1f 00             	nop    DWORD PTR [rax]
	tarent = tar_root();
  40c6b0:	48 b8 90 cd 40 00 00 	movabs rax,0x40cd90
  40c6b7:	00 00 00 
  40c6ba:	ff d0                	call   rax
	if (!tarent) return -1;
  40c6bc:	48 85 c0             	test   rax,rax
  40c6bf:	74 a0                	je     40c661 <args_get+0x41>
		.d.tar_ent = *tarent
  40c6c1:	8b 10                	mov    edx,DWORD PTR [rax]
  40c6c3:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	tarroot = (struct initargs) {
  40c6c7:	c7 45 d0 01 00 00 00 	mov    DWORD PTR [rbp-0x30],0x1
	return args_lkup_entry(from, path, ent);
  40c6ce:	4c 89 e6             	mov    rsi,r12
  40c6d1:	48 8d 7d d0          	lea    rdi,[rbp-0x30]
	tarroot = (struct initargs) {
  40c6d5:	89 55 d8             	mov    DWORD PTR [rbp-0x28],edx
	return args_lkup_entry(from, path, ent);
  40c6d8:	48 8d 55 b0          	lea    rdx,[rbp-0x50]
	tarroot = (struct initargs) {
  40c6dc:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax
	return args_lkup_entry(from, path, ent);
  40c6e0:	ff d3                	call   rbx
	if (args_get_entry(path, &ent)) return NULL;
  40c6e2:	85 c0                	test   eax,eax
  40c6e4:	0f 85 75 ff ff ff    	jne    40c65f <args_get+0x3f>
  40c6ea:	e9 64 ff ff ff       	jmp    40c653 <args_get+0x33>
  40c6ef:	90                   	nop

000000000040c6f0 <tar_key>:
	return r;
}

char *
tar_key(struct tar_entry *ent, int *str_len)
{
  40c6f0:	f3 0f 1e fa          	endbr64 
  40c6f4:	55                   	push   rbp
  40c6f5:	48 89 f8             	mov    rax,rdi
  40c6f8:	48 89 e5             	mov    rbp,rsp
  40c6fb:	41 56                	push   r14
  40c6fd:	41 55                	push   r13
  40c6ff:	49 89 f5             	mov    r13,rsi
  40c702:	41 54                	push   r12
  40c704:	49 bc e0 82 41 00 00 	movabs r12,0x4182e0
  40c70b:	00 00 00 
  40c70e:	53                   	push   rbx
  40c70f:	48 83 ec 10          	sub    rsp,0x10
	return tar_nesting(ent->nesting_lvl, ent->record->name, str_len);
  40c713:	8b 18                	mov    ebx,DWORD PTR [rax]
  40c715:	48 8b 7f 08          	mov    rdi,QWORD PTR [rdi+0x8]
	for (i = 0 ; i < nesting_lvl ; i++) {
  40c719:	85 db                	test   ebx,ebx
  40c71b:	7e 43                	jle    40c760 <tar_key+0x70>
  40c71d:	49 bc e0 82 41 00 00 	movabs r12,0x4182e0
  40c724:	00 00 00 
  40c727:	45 31 f6             	xor    r14d,r14d
  40c72a:	eb 11                	jmp    40c73d <tar_key+0x4d>
  40c72c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  40c730:	41 83 c6 01          	add    r14d,0x1
		key++;		/* one past the / */
  40c734:	48 83 c7 01          	add    rdi,0x1
	for (i = 0 ; i < nesting_lvl ; i++) {
  40c738:	44 39 f3             	cmp    ebx,r14d
  40c73b:	74 23                	je     40c760 <tar_key+0x70>
		key = strchr(key, '/');
  40c73d:	be 2f 00 00 00       	mov    esi,0x2f
  40c742:	41 ff d4             	call   r12
  40c745:	48 89 c7             	mov    rdi,rax
		if (!key) return NULL;
  40c748:	48 85 c0             	test   rax,rax
  40c74b:	75 e3                	jne    40c730 <tar_key+0x40>
}
  40c74d:	48 83 c4 10          	add    rsp,0x10
  40c751:	48 89 f8             	mov    rax,rdi
  40c754:	5b                   	pop    rbx
  40c755:	41 5c                	pop    r12
  40c757:	41 5d                	pop    r13
  40c759:	41 5e                	pop    r14
  40c75b:	5d                   	pop    rbp
  40c75c:	c3                   	ret    
  40c75d:	0f 1f 00             	nop    DWORD PTR [rax]
	end = strchr(key, '/');
  40c760:	48 89 7d d8          	mov    QWORD PTR [rbp-0x28],rdi
  40c764:	be 2f 00 00 00       	mov    esi,0x2f
  40c769:	41 ff d4             	call   r12
	if (!end) *key_len = strlen(key);
  40c76c:	48 8b 7d d8          	mov    rdi,QWORD PTR [rbp-0x28]
  40c770:	48 85 c0             	test   rax,rax
  40c773:	74 1b                	je     40c790 <tar_key+0xa0>
	else      *key_len = end - key;
  40c775:	48 29 f8             	sub    rax,rdi
  40c778:	41 89 45 00          	mov    DWORD PTR [r13+0x0],eax
}
  40c77c:	48 83 c4 10          	add    rsp,0x10
  40c780:	48 89 f8             	mov    rax,rdi
  40c783:	5b                   	pop    rbx
  40c784:	41 5c                	pop    r12
  40c786:	41 5d                	pop    r13
  40c788:	41 5e                	pop    r14
  40c78a:	5d                   	pop    rbp
  40c78b:	c3                   	ret    
  40c78c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	if (!end) *key_len = strlen(key);
  40c790:	48 b8 90 84 41 00 00 	movabs rax,0x418490
  40c797:	00 00 00 
  40c79a:	ff d0                	call   rax
  40c79c:	48 8b 7d d8          	mov    rdi,QWORD PTR [rbp-0x28]
  40c7a0:	41 89 45 00          	mov    DWORD PTR [r13+0x0],eax
}
  40c7a4:	48 83 c4 10          	add    rsp,0x10
  40c7a8:	5b                   	pop    rbx
  40c7a9:	48 89 f8             	mov    rax,rdi
  40c7ac:	41 5c                	pop    r12
  40c7ae:	41 5d                	pop    r13
  40c7b0:	41 5e                	pop    r14
  40c7b2:	5d                   	pop    rbp
  40c7b3:	c3                   	ret    
  40c7b4:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40c7bb:	00 00 00 00 
  40c7bf:	90                   	nop

000000000040c7c0 <tar_value>:

char *
tar_value(struct tar_entry *ent)
{
  40c7c0:	f3 0f 1e fa          	endbr64 
	if (!tar_valid(ent)) return NULL;
  40c7c4:	45 31 c0             	xor    r8d,r8d
	return !(!ent || !ent->record || tar_end(ent->record));
  40c7c7:	48 85 ff             	test   rdi,rdi
  40c7ca:	74 41                	je     40c80d <tar_value+0x4d>
  40c7cc:	4c 8b 47 08          	mov    r8,QWORD PTR [rdi+0x8]
  40c7d0:	4d 85 c0             	test   r8,r8
  40c7d3:	74 38                	je     40c80d <tar_value+0x4d>
  40c7d5:	4c 89 c0             	mov    rax,r8
  40c7d8:	49 8d 90 00 04 00 00 	lea    rdx,[r8+0x400]
  40c7df:	eb 10                	jmp    40c7f1 <tar_value+0x31>
  40c7e1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40c7e8:	48 83 c0 01          	add    rax,0x1
  40c7ec:	48 39 d0             	cmp    rax,rdx
  40c7ef:	74 27                	je     40c818 <tar_value+0x58>
		if (((char *)r)[i]) return 0;
  40c7f1:	80 38 00             	cmp    BYTE PTR [rax],0x0
  40c7f4:	74 f2                	je     40c7e8 <tar_value+0x28>
	return *r->linkflag == '0' || *r->linkflag == '\0';
  40c7f6:	41 0f b6 80 9c 00 00 	movzx  eax,BYTE PTR [r8+0x9c]
  40c7fd:	00 
	if (!tar_is_file(ent->record)) return NULL;
  40c7fe:	3c 30                	cmp    al,0x30
  40c800:	74 04                	je     40c806 <tar_value+0x46>
  40c802:	84 c0                	test   al,al
  40c804:	75 12                	jne    40c818 <tar_value+0x58>

	return (char *)&ent->record[1];
  40c806:	49 81 c0 00 02 00 00 	add    r8,0x200
}
  40c80d:	4c 89 c0             	mov    rax,r8
  40c810:	c3                   	ret    
  40c811:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	if (!tar_valid(ent)) return NULL;
  40c818:	45 31 c0             	xor    r8d,r8d
}
  40c81b:	4c 89 c0             	mov    rax,r8
  40c81e:	c3                   	ret    
  40c81f:	90                   	nop

000000000040c820 <tar_value_sz>:

int
tar_value_sz(struct tar_entry *ent)
{
  40c820:	f3 0f 1e fa          	endbr64 
	if (!tar_valid(ent)) return 0;
  40c824:	45 31 c0             	xor    r8d,r8d
	return !(!ent || !ent->record || tar_end(ent->record));
  40c827:	48 85 ff             	test   rdi,rdi
  40c82a:	74 54                	je     40c880 <tar_value_sz+0x60>
{
  40c82c:	55                   	push   rbp
  40c82d:	48 89 e5             	mov    rbp,rsp
  40c830:	53                   	push   rbx
  40c831:	48 83 ec 08          	sub    rsp,0x8
	return !(!ent || !ent->record || tar_end(ent->record));
  40c835:	48 8b 5f 08          	mov    rbx,QWORD PTR [rdi+0x8]
  40c839:	48 85 db             	test   rbx,rbx
  40c83c:	74 32                	je     40c870 <tar_value_sz+0x50>
  40c83e:	48 89 d8             	mov    rax,rbx
  40c841:	48 8d 93 00 04 00 00 	lea    rdx,[rbx+0x400]
  40c848:	eb 0f                	jmp    40c859 <tar_value_sz+0x39>
  40c84a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40c850:	48 83 c0 01          	add    rax,0x1
  40c854:	48 39 d0             	cmp    rax,rdx
  40c857:	74 14                	je     40c86d <tar_value_sz+0x4d>
		if (((char *)r)[i]) return 0;
  40c859:	80 38 00             	cmp    BYTE PTR [rax],0x0
  40c85c:	74 f2                	je     40c850 <tar_value_sz+0x30>
	return *r->linkflag == '0' || *r->linkflag == '\0';
  40c85e:	0f b6 83 9c 00 00 00 	movzx  eax,BYTE PTR [rbx+0x9c]
	if (!tar_is_file(ent->record)) return 0;
  40c865:	3c 30                	cmp    al,0x30
  40c867:	74 1f                	je     40c888 <tar_value_sz+0x68>
  40c869:	84 c0                	test   al,al
  40c86b:	74 1b                	je     40c888 <tar_value_sz+0x68>
	if (!tar_valid(ent)) return 0;
  40c86d:	45 31 c0             	xor    r8d,r8d

	return oct2dec(ent->record->size);
}
  40c870:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
  40c874:	44 89 c0             	mov    eax,r8d
  40c877:	c9                   	leave  
  40c878:	c3                   	ret    
  40c879:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  40c880:	44 89 c0             	mov    eax,r8d
  40c883:	c3                   	ret    
  40c884:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	i = strnlen(oct, TAR_SZ) - 1;
  40c888:	48 8d 7b 7c          	lea    rdi,[rbx+0x7c]
  40c88c:	be 0c 00 00 00       	mov    esi,0xc
  40c891:	48 b8 90 85 41 00 00 	movabs rax,0x418590
  40c898:	00 00 00 
  40c89b:	ff d0                	call   rax
  40c89d:	8d 50 ff             	lea    edx,[rax-0x1]
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40c8a0:	85 c0                	test   eax,eax
  40c8a2:	74 c9                	je     40c86d <tar_value_sz+0x4d>
  40c8a4:	48 63 d2             	movsxd rdx,edx
  40c8a7:	45 31 c0             	xor    r8d,r8d
  40c8aa:	b9 01 00 00 00       	mov    ecx,0x1
  40c8af:	eb 1b                	jmp    40c8cc <tar_value_sz+0xac>
  40c8b1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		tot = tot + (val * base);
  40c8b8:	0f b6 c0             	movzx  eax,al
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40c8bb:	48 83 ea 01          	sub    rdx,0x1
		tot = tot + (val * base);
  40c8bf:	0f af c1             	imul   eax,ecx
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40c8c2:	c1 e1 03             	shl    ecx,0x3
		tot = tot + (val * base);
  40c8c5:	41 01 c0             	add    r8d,eax
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40c8c8:	85 d2                	test   edx,edx
  40c8ca:	78 a4                	js     40c870 <tar_value_sz+0x50>
		if (val > '7' || val < '0') return -1;
  40c8cc:	0f b6 44 13 7c       	movzx  eax,BYTE PTR [rbx+rdx*1+0x7c]
  40c8d1:	83 e8 30             	sub    eax,0x30
  40c8d4:	3c 07                	cmp    al,0x7
  40c8d6:	76 e0                	jbe    40c8b8 <tar_value_sz+0x98>
	if (i == TAR_RECORD_SIZE) return -1;
  40c8d8:	41 b8 ff ff ff ff    	mov    r8d,0xffffffff
  40c8de:	eb 90                	jmp    40c870 <tar_value_sz+0x50>

000000000040c8e0 <tar_is_value>:

int
tar_is_value(struct tar_entry *ent)
{
  40c8e0:	f3 0f 1e fa          	endbr64 
	if (!tar_valid(ent)) return 0;
  40c8e4:	31 c0                	xor    eax,eax
	return !(!ent || !ent->record || tar_end(ent->record));
  40c8e6:	48 85 ff             	test   rdi,rdi
  40c8e9:	74 3a                	je     40c925 <tar_is_value+0x45>
  40c8eb:	48 8b 4f 08          	mov    rcx,QWORD PTR [rdi+0x8]
  40c8ef:	48 85 c9             	test   rcx,rcx
  40c8f2:	74 31                	je     40c925 <tar_is_value+0x45>
  40c8f4:	48 89 c8             	mov    rax,rcx
  40c8f7:	48 8d 91 00 04 00 00 	lea    rdx,[rcx+0x400]
  40c8fe:	eb 09                	jmp    40c909 <tar_is_value+0x29>
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40c900:	48 83 c0 01          	add    rax,0x1
  40c904:	48 39 d0             	cmp    rax,rdx
  40c907:	74 27                	je     40c930 <tar_is_value+0x50>
		if (((char *)r)[i]) return 0;
  40c909:	80 38 00             	cmp    BYTE PTR [rax],0x0
  40c90c:	74 f2                	je     40c900 <tar_is_value+0x20>
	return *r->linkflag == '0' || *r->linkflag == '\0';
  40c90e:	0f b6 91 9c 00 00 00 	movzx  edx,BYTE PTR [rcx+0x9c]
  40c915:	80 fa 30             	cmp    dl,0x30
  40c918:	0f 94 c0             	sete   al
  40c91b:	84 d2                	test   dl,dl
  40c91d:	0f 94 c2             	sete   dl
  40c920:	09 d0                	or     eax,edx
  40c922:	0f b6 c0             	movzx  eax,al

	return tar_is_file(ent->record);
}
  40c925:	c3                   	ret    
  40c926:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40c92d:	00 00 00 
	if (!tar_valid(ent)) return 0;
  40c930:	31 c0                	xor    eax,eax
  40c932:	c3                   	ret    
  40c933:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40c93a:	00 00 00 00 
  40c93e:	66 90                	xchg   ax,ax

000000000040c940 <tar_iter_next>:

int
tar_iter_next(struct tar_iter *i, struct tar_entry *next)
{
  40c940:	f3 0f 1e fa          	endbr64 
  40c944:	55                   	push   rbp
  40c945:	48 89 e5             	mov    rbp,rsp
  40c948:	41 57                	push   r15
  40c94a:	41 56                	push   r14
  40c94c:	41 55                	push   r13
  40c94e:	41 54                	push   r12
  40c950:	53                   	push   rbx
  40c951:	48 83 ec 28          	sub    rsp,0x28
  40c955:	48 89 75 c8          	mov    QWORD PTR [rbp-0x38],rsi
	struct tar_record *r;

	if (!i || !tar_valid(&i->entry)) return 0;
  40c959:	48 85 ff             	test   rdi,rdi
  40c95c:	0f 84 f6 00 00 00    	je     40ca58 <tar_iter_next+0x118>
	return !(!ent || !ent->record || tar_end(ent->record));
  40c962:	4c 8b 77 08          	mov    r14,QWORD PTR [rdi+0x8]
  40c966:	49 89 f9             	mov    r9,rdi
	if (!i || !tar_valid(&i->entry)) return 0;
  40c969:	31 c0                	xor    eax,eax
	return !(!ent || !ent->record || tar_end(ent->record));
  40c96b:	4d 85 f6             	test   r14,r14
  40c96e:	0f 84 e6 00 00 00    	je     40ca5a <tar_iter_next+0x11a>
  40c974:	4d 8d ae 00 04 00 00 	lea    r13,[r14+0x400]
  40c97b:	4c 89 f0             	mov    rax,r14
  40c97e:	eb 0d                	jmp    40c98d <tar_iter_next+0x4d>
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40c980:	48 83 c0 01          	add    rax,0x1
  40c984:	4c 39 e8             	cmp    rax,r13
  40c987:	0f 84 cb 00 00 00    	je     40ca58 <tar_iter_next+0x118>
		if (((char *)r)[i]) return 0;
  40c98d:	80 38 00             	cmp    BYTE PTR [rax],0x0
  40c990:	74 ee                	je     40c980 <tar_iter_next+0x40>
  40c992:	4c 89 f0             	mov    rax,r14
  40c995:	eb 16                	jmp    40c9ad <tar_iter_next+0x6d>
  40c997:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40c99e:	00 00 
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40c9a0:	48 83 c0 01          	add    rax,0x1
  40c9a4:	4c 39 e8             	cmp    rax,r13
  40c9a7:	0f 84 ab 00 00 00    	je     40ca58 <tar_iter_next+0x118>
		if (((char *)r)[i]) return 0;
  40c9ad:	80 38 00             	cmp    BYTE PTR [rax],0x0
  40c9b0:	74 ee                	je     40c9a0 <tar_iter_next+0x60>
	if (!tar_valid(path) || iter == NULL || *iter == NULL) return NULL;
  40c9b2:	4d 8b 79 10          	mov    r15,QWORD PTR [r9+0x10]
  40c9b6:	4d 85 ff             	test   r15,r15
  40c9b9:	0f 84 99 00 00 00    	je     40ca58 <tar_iter_next+0x118>
  40c9bf:	90                   	nop
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40c9c0:	4c 89 fb             	mov    rbx,r15
  40c9c3:	4d 8d a7 00 04 00 00 	lea    r12,[r15+0x400]
  40c9ca:	4c 89 f8             	mov    rax,r15
  40c9cd:	eb 0a                	jmp    40c9d9 <tar_iter_next+0x99>
  40c9cf:	90                   	nop
  40c9d0:	48 83 c0 01          	add    rax,0x1
  40c9d4:	49 39 c4             	cmp    r12,rax
  40c9d7:	74 5f                	je     40ca38 <tar_iter_next+0xf8>
		if (((char *)r)[i]) return 0;
  40c9d9:	80 38 00             	cmp    BYTE PTR [rax],0x0
  40c9dc:	74 f2                	je     40c9d0 <tar_iter_next+0x90>
  40c9de:	4c 89 f0             	mov    rax,r14
  40c9e1:	eb 12                	jmp    40c9f5 <tar_iter_next+0xb5>
  40c9e3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40c9e8:	48 83 c0 01          	add    rax,0x1
  40c9ec:	4c 39 e8             	cmp    rax,r13
  40c9ef:	0f 84 84 00 00 00    	je     40ca79 <tar_iter_next+0x139>
		if (((char *)r)[i]) return 0;
  40c9f5:	80 38 00             	cmp    BYTE PTR [rax],0x0
  40c9f8:	74 ee                	je     40c9e8 <tar_iter_next+0xa8>
	if (ent->nesting_lvl == 0) {
  40c9fa:	41 8b 01             	mov    eax,DWORD PTR [r9]
  40c9fd:	4c 89 4d c0          	mov    QWORD PTR [rbp-0x40],r9
	end = strchr(key, '/');
  40ca01:	be 2f 00 00 00       	mov    esi,0x2f
  40ca06:	4c 89 ff             	mov    rdi,r15
  40ca09:	48 ba e0 82 41 00 00 	movabs rdx,0x4182e0
  40ca10:	00 00 00 
	if (ent->nesting_lvl == 0) {
  40ca13:	89 45 b4             	mov    DWORD PTR [rbp-0x4c],eax
	end = strchr(key, '/');
  40ca16:	ff d2                	call   rdx
	if (ent->nesting_lvl == 0) {
  40ca18:	8b 55 b4             	mov    edx,DWORD PTR [rbp-0x4c]
  40ca1b:	4c 8b 4d c0          	mov    r9,QWORD PTR [rbp-0x40]
  40ca1f:	85 d2                	test   edx,edx
  40ca21:	0f 85 7e 01 00 00    	jne    40cba5 <tar_iter_next+0x265>
	return !((cmp == 0) && (end == NULL || end[1] == '\0'));
  40ca27:	48 85 c0             	test   rax,rax
  40ca2a:	74 0c                	je     40ca38 <tar_iter_next+0xf8>
  40ca2c:	80 78 01 00          	cmp    BYTE PTR [rax+0x1],0x0
  40ca30:	75 47                	jne    40ca79 <tar_iter_next+0x139>
  40ca32:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40ca38:	4c 89 f8             	mov    rax,r15
  40ca3b:	eb 0c                	jmp    40ca49 <tar_iter_next+0x109>
  40ca3d:	0f 1f 00             	nop    DWORD PTR [rax]
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40ca40:	48 83 c0 01          	add    rax,0x1
  40ca44:	49 39 c4             	cmp    r12,rax
  40ca47:	74 0f                	je     40ca58 <tar_iter_next+0x118>
		if (((char *)r)[i]) return 0;
  40ca49:	80 38 00             	cmp    BYTE PTR [rax],0x0
  40ca4c:	74 f2                	je     40ca40 <tar_iter_next+0x100>
  40ca4e:	e9 a2 00 00 00       	jmp    40caf5 <tar_iter_next+0x1b5>
  40ca53:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	if (!i || !tar_valid(&i->entry)) return 0;
  40ca58:	31 c0                	xor    eax,eax

	next->nesting_lvl = i->entry.nesting_lvl;
	next->record = r;

	return 1;
}
  40ca5a:	48 83 c4 28          	add    rsp,0x28
  40ca5e:	5b                   	pop    rbx
  40ca5f:	41 5c                	pop    r12
  40ca61:	41 5d                	pop    r13
  40ca63:	41 5e                	pop    r14
  40ca65:	41 5f                	pop    r15
  40ca67:	5d                   	pop    rbp
  40ca68:	c3                   	ret    
  40ca69:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40ca70:	48 83 c3 01          	add    rbx,0x1
  40ca74:	49 39 dc             	cmp    r12,rbx
  40ca77:	74 df                	je     40ca58 <tar_iter_next+0x118>
		if (((char *)r)[i]) return 0;
  40ca79:	80 3b 00             	cmp    BYTE PTR [rbx],0x0
  40ca7c:	74 f2                	je     40ca70 <tar_iter_next+0x130>
  40ca7e:	4c 89 4d c0          	mov    QWORD PTR [rbp-0x40],r9
	i = strnlen(oct, TAR_SZ) - 1;
  40ca82:	49 8d 7f 7c          	lea    rdi,[r15+0x7c]
  40ca86:	be 0c 00 00 00       	mov    esi,0xc
  40ca8b:	48 b8 90 85 41 00 00 	movabs rax,0x418590
  40ca92:	00 00 00 
  40ca95:	ff d0                	call   rax
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40ca97:	31 ff                	xor    edi,edi
  40ca99:	4c 8b 4d c0          	mov    r9,QWORD PTR [rbp-0x40]
  40ca9d:	be 01 00 00 00       	mov    esi,0x1
	i = strnlen(oct, TAR_SZ) - 1;
  40caa2:	83 e8 01             	sub    eax,0x1
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40caa5:	83 f8 ff             	cmp    eax,0xffffffff
  40caa8:	48 63 d0             	movsxd rdx,eax
  40caab:	75 1a                	jne    40cac7 <tar_iter_next+0x187>
  40caad:	eb 25                	jmp    40cad4 <tar_iter_next+0x194>
  40caaf:	90                   	nop
		tot = tot + (val * base);
  40cab0:	0f b6 c0             	movzx  eax,al
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40cab3:	48 83 ea 01          	sub    rdx,0x1
		tot = tot + (val * base);
  40cab7:	0f af c6             	imul   eax,esi
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40caba:	c1 e6 03             	shl    esi,0x3
		tot = tot + (val * base);
  40cabd:	01 c7                	add    edi,eax
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40cabf:	85 d2                	test   edx,edx
  40cac1:	0f 88 c1 00 00 00    	js     40cb88 <tar_iter_next+0x248>
		if (val > '7' || val < '0') return -1;
  40cac7:	41 0f b6 44 17 7c    	movzx  eax,BYTE PTR [r15+rdx*1+0x7c]
  40cacd:	83 e8 30             	sub    eax,0x30
  40cad0:	3c 07                	cmp    al,0x7
  40cad2:	76 dc                	jbe    40cab0 <tar_iter_next+0x170>
  40cad4:	b8 00 02 00 00       	mov    eax,0x200
	return &r[n_records + 1];
  40cad9:	49 01 c7             	add    r15,rax
	for (r = *iter; r && !tar_end(r) && tar_pathcmp(path, r->name); r = tar_next_record(r)) ;
  40cadc:	e9 df fe ff ff       	jmp    40c9c0 <tar_iter_next+0x80>
  40cae1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40cae8:	48 83 c3 01          	add    rbx,0x1
  40caec:	49 39 dc             	cmp    r12,rbx
  40caef:	0f 84 6a 01 00 00    	je     40cc5f <tar_iter_next+0x31f>
		if (((char *)r)[i]) return 0;
  40caf5:	80 3b 00             	cmp    BYTE PTR [rbx],0x0
  40caf8:	74 ee                	je     40cae8 <tar_iter_next+0x1a8>
  40cafa:	4c 89 4d c0          	mov    QWORD PTR [rbp-0x40],r9
	i = strnlen(oct, TAR_SZ) - 1;
  40cafe:	be 0c 00 00 00       	mov    esi,0xc
  40cb03:	49 8d 7f 7c          	lea    rdi,[r15+0x7c]
  40cb07:	48 b8 90 85 41 00 00 	movabs rax,0x418590
  40cb0e:	00 00 00 
  40cb11:	ff d0                	call   rax
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40cb13:	31 f6                	xor    esi,esi
  40cb15:	4c 8b 4d c0          	mov    r9,QWORD PTR [rbp-0x40]
  40cb19:	b9 01 00 00 00       	mov    ecx,0x1
	i = strnlen(oct, TAR_SZ) - 1;
  40cb1e:	83 e8 01             	sub    eax,0x1
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40cb21:	83 f8 ff             	cmp    eax,0xffffffff
  40cb24:	48 63 d0             	movsxd rdx,eax
  40cb27:	75 1e                	jne    40cb47 <tar_iter_next+0x207>
  40cb29:	eb 29                	jmp    40cb54 <tar_iter_next+0x214>
  40cb2b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		tot = tot + (val * base);
  40cb30:	0f b6 c0             	movzx  eax,al
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40cb33:	48 83 ea 01          	sub    rdx,0x1
		tot = tot + (val * base);
  40cb37:	0f af c1             	imul   eax,ecx
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40cb3a:	c1 e1 03             	shl    ecx,0x3
		tot = tot + (val * base);
  40cb3d:	01 c6                	add    esi,eax
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  40cb3f:	85 d2                	test   edx,edx
  40cb41:	0f 88 fe 00 00 00    	js     40cc45 <tar_iter_next+0x305>
		if (val > '7' || val < '0') return -1;
  40cb47:	41 0f b6 44 17 7c    	movzx  eax,BYTE PTR [r15+rdx*1+0x7c]
  40cb4d:	83 e8 30             	sub    eax,0x30
  40cb50:	3c 07                	cmp    al,0x7
  40cb52:	76 dc                	jbe    40cb30 <tar_iter_next+0x1f0>
  40cb54:	b8 00 02 00 00       	mov    eax,0x200
	return &r[n_records + 1];
  40cb59:	4c 01 f8             	add    rax,r15
	*iter = tar_next_record(r);
  40cb5c:	49 89 41 10          	mov    QWORD PTR [r9+0x10],rax
	next->nesting_lvl = i->entry.nesting_lvl;
  40cb60:	48 8b 4d c8          	mov    rcx,QWORD PTR [rbp-0x38]
  40cb64:	41 8b 01             	mov    eax,DWORD PTR [r9]
	next->record = r;
  40cb67:	4c 89 79 08          	mov    QWORD PTR [rcx+0x8],r15
	next->nesting_lvl = i->entry.nesting_lvl;
  40cb6b:	89 01                	mov    DWORD PTR [rcx],eax
}
  40cb6d:	48 83 c4 28          	add    rsp,0x28
	return 1;
  40cb71:	b8 01 00 00 00       	mov    eax,0x1
}
  40cb76:	5b                   	pop    rbx
  40cb77:	41 5c                	pop    r12
  40cb79:	41 5d                	pop    r13
  40cb7b:	41 5e                	pop    r14
  40cb7d:	41 5f                	pop    r15
  40cb7f:	5d                   	pop    rbp
  40cb80:	c3                   	ret    
  40cb81:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	n_records = round_up_to_pow2(sz, TAR_RECORD_SIZE) / TAR_RECORD_SIZE;
  40cb88:	48 63 ff             	movsxd rdi,edi
  40cb8b:	48 81 c7 ff 01 00 00 	add    rdi,0x1ff
	return &r[n_records + 1];
  40cb92:	48 81 e7 00 fe ff ff 	and    rdi,0xfffffffffffffe00
  40cb99:	48 8d 87 00 02 00 00 	lea    rax,[rdi+0x200]
  40cba0:	e9 34 ff ff ff       	jmp    40cad9 <tar_iter_next+0x199>
	for (i = 0 ; i < nesting_lvl ; i++) {
  40cba5:	0f 8e bb 00 00 00    	jle    40cc66 <tar_iter_next+0x326>
  40cbab:	4d 89 fb             	mov    r11,r15
  40cbae:	31 d2                	xor    edx,edx
  40cbb0:	4c 89 4d c0          	mov    QWORD PTR [rbp-0x40],r9
		key = strchr(key, '/');
  40cbb4:	be 2f 00 00 00       	mov    esi,0x2f
  40cbb9:	4c 89 df             	mov    rdi,r11
  40cbbc:	48 b8 e0 82 41 00 00 	movabs rax,0x4182e0
  40cbc3:	00 00 00 
  40cbc6:	89 55 b8             	mov    DWORD PTR [rbp-0x48],edx
  40cbc9:	ff d0                	call   rax
		if (!key) return NULL;
  40cbcb:	4c 8b 4d c0          	mov    r9,QWORD PTR [rbp-0x40]
  40cbcf:	48 85 c0             	test   rax,rax
  40cbd2:	0f 84 a1 fe ff ff    	je     40ca79 <tar_iter_next+0x139>
	for (i = 0 ; i < nesting_lvl ; i++) {
  40cbd8:	8b 55 b8             	mov    edx,DWORD PTR [rbp-0x48]
		key++;		/* one past the / */
  40cbdb:	4c 8d 58 01          	lea    r11,[rax+0x1]
	for (i = 0 ; i < nesting_lvl ; i++) {
  40cbdf:	83 c2 01             	add    edx,0x1
  40cbe2:	39 55 b4             	cmp    DWORD PTR [rbp-0x4c],edx
  40cbe5:	75 c9                	jne    40cbb0 <tar_iter_next+0x270>
	if (*key == '\0') return 1; /* if we have the actual directory, avoid it */
  40cbe7:	80 78 01 00          	cmp    BYTE PTR [rax+0x1],0x0
  40cbeb:	0f 84 88 fe ff ff    	je     40ca79 <tar_iter_next+0x139>
	len = (int)(key - path);
  40cbf1:	4c 89 da             	mov    rdx,r11
  40cbf4:	4c 89 4d b8          	mov    QWORD PTR [rbp-0x48],r9
	cmp = strncmp(p, path, len);
  40cbf8:	4c 89 fe             	mov    rsi,r15
  40cbfb:	4c 89 f7             	mov    rdi,r14
	len = (int)(key - path);
  40cbfe:	4c 29 fa             	sub    rdx,r15
  40cc01:	4c 89 5d c0          	mov    QWORD PTR [rbp-0x40],r11
	cmp = strncmp(p, path, len);
  40cc05:	48 b8 10 85 41 00 00 	movabs rax,0x418510
  40cc0c:	00 00 00 
	len = (int)(key - path);
  40cc0f:	48 63 d2             	movsxd rdx,edx
	cmp = strncmp(p, path, len);
  40cc12:	ff d0                	call   rax
	return !((cmp == 0) && (end == NULL || end[1] == '\0'));
  40cc14:	4c 8b 5d c0          	mov    r11,QWORD PTR [rbp-0x40]
  40cc18:	4c 8b 4d b8          	mov    r9,QWORD PTR [rbp-0x48]
  40cc1c:	85 c0                	test   eax,eax
  40cc1e:	0f 85 55 fe ff ff    	jne    40ca79 <tar_iter_next+0x139>
  40cc24:	4c 89 4d c0          	mov    QWORD PTR [rbp-0x40],r9
	end = strchr(key, '/');
  40cc28:	be 2f 00 00 00       	mov    esi,0x2f
  40cc2d:	4c 89 df             	mov    rdi,r11
  40cc30:	48 b8 e0 82 41 00 00 	movabs rax,0x4182e0
  40cc37:	00 00 00 
  40cc3a:	ff d0                	call   rax
  40cc3c:	4c 8b 4d c0          	mov    r9,QWORD PTR [rbp-0x40]
  40cc40:	e9 e2 fd ff ff       	jmp    40ca27 <tar_iter_next+0xe7>
	n_records = round_up_to_pow2(sz, TAR_RECORD_SIZE) / TAR_RECORD_SIZE;
  40cc45:	48 63 c6             	movsxd rax,esi
  40cc48:	48 05 ff 01 00 00    	add    rax,0x1ff
	return &r[n_records + 1];
  40cc4e:	48 25 00 fe ff ff    	and    rax,0xfffffffffffffe00
  40cc54:	48 05 00 02 00 00    	add    rax,0x200
  40cc5a:	e9 fa fe ff ff       	jmp    40cb59 <tar_iter_next+0x219>
	if (tar_end(r)) return NULL;
  40cc5f:	31 c0                	xor    eax,eax
  40cc61:	e9 f6 fe ff ff       	jmp    40cb5c <tar_iter_next+0x21c>
	if (*key == '\0') return 1; /* if we have the actual directory, avoid it */
  40cc66:	41 80 3f 00          	cmp    BYTE PTR [r15],0x0
  40cc6a:	0f 85 b7 fd ff ff    	jne    40ca27 <tar_iter_next+0xe7>
  40cc70:	e9 04 fe ff ff       	jmp    40ca79 <tar_iter_next+0x139>
  40cc75:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40cc7c:	00 00 00 00 

000000000040cc80 <tar_iter>:
 * assumptions is wrong, we will skip all of those entries in a
 * directory that come *before* the directory record.
 */
int
tar_iter(struct tar_entry *ent, struct tar_iter *i, struct tar_entry *first)
{
  40cc80:	f3 0f 1e fa          	endbr64 
  40cc84:	49 89 f8             	mov    r8,rdi
  40cc87:	48 89 f7             	mov    rdi,rsi
	return !(!ent || !ent->record || tar_end(ent->record));
  40cc8a:	4d 85 c0             	test   r8,r8
  40cc8d:	74 30                	je     40ccbf <tar_iter+0x3f>
  40cc8f:	49 8b 70 08          	mov    rsi,QWORD PTR [r8+0x8]
  40cc93:	48 85 f6             	test   rsi,rsi
  40cc96:	74 27                	je     40ccbf <tar_iter+0x3f>
  40cc98:	48 89 f0             	mov    rax,rsi
  40cc9b:	48 8d 8e 00 04 00 00 	lea    rcx,[rsi+0x400]
  40cca2:	eb 0d                	jmp    40ccb1 <tar_iter+0x31>
  40cca4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40cca8:	48 83 c0 01          	add    rax,0x1
  40ccac:	48 39 c1             	cmp    rcx,rax
  40ccaf:	74 0e                	je     40ccbf <tar_iter+0x3f>
		if (((char *)r)[i]) return 0;
  40ccb1:	80 38 00             	cmp    BYTE PTR [rax],0x0
  40ccb4:	74 f2                	je     40cca8 <tar_iter+0x28>
	if (!tar_valid(ent)) return 0;
	if (!tar_is_dir(ent->record)) return 0;
  40ccb6:	80 be 9c 00 00 00 35 	cmp    BYTE PTR [rsi+0x9c],0x35
  40ccbd:	74 09                	je     40ccc8 <tar_iter+0x48>
	i->entry    = *ent;
	i->iter_rec = ent->record;
	i->entry.nesting_lvl++;	/* look *in* the entry */

	return tar_iter_next(i, first);
}
  40ccbf:	31 c0                	xor    eax,eax
  40ccc1:	c3                   	ret    
  40ccc2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	i->entry    = *ent;
  40ccc8:	f3 41 0f 6f 00       	movdqu xmm0,XMMWORD PTR [r8]
	return tar_iter_next(i, first);
  40cccd:	48 89 d6             	mov    rsi,rdx
	i->entry    = *ent;
  40ccd0:	0f 11 07             	movups XMMWORD PTR [rdi],xmm0
	i->iter_rec = ent->record;
  40ccd3:	49 8b 40 08          	mov    rax,QWORD PTR [r8+0x8]
	i->entry.nesting_lvl++;	/* look *in* the entry */
  40ccd7:	83 07 01             	add    DWORD PTR [rdi],0x1
	i->iter_rec = ent->record;
  40ccda:	48 89 47 10          	mov    QWORD PTR [rdi+0x10],rax
	return tar_iter_next(i, first);
  40ccde:	48 b8 40 c9 40 00 00 	movabs rax,0x40c940
  40cce5:	00 00 00 
  40cce8:	ff e0                	jmp    rax
  40ccea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000040ccf0 <tar_len>:

int
tar_len(struct tar_entry *start)
{
  40ccf0:	f3 0f 1e fa          	endbr64 
  40ccf4:	55                   	push   rbp
  40ccf5:	48 89 e5             	mov    rbp,rsp
  40ccf8:	41 54                	push   r12
  40ccfa:	53                   	push   rbx
  40ccfb:	48 83 ec 30          	sub    rsp,0x30
	return !(!ent || !ent->record || tar_end(ent->record));
  40ccff:	48 85 ff             	test   rdi,rdi
  40cd02:	74 33                	je     40cd37 <tar_len+0x47>
  40cd04:	48 8b 4f 08          	mov    rcx,QWORD PTR [rdi+0x8]
  40cd08:	48 85 c9             	test   rcx,rcx
  40cd0b:	74 2a                	je     40cd37 <tar_len+0x47>
  40cd0d:	48 89 c8             	mov    rax,rcx
  40cd10:	48 8d 91 00 04 00 00 	lea    rdx,[rcx+0x400]
  40cd17:	eb 10                	jmp    40cd29 <tar_len+0x39>
  40cd19:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  40cd20:	48 83 c0 01          	add    rax,0x1
  40cd24:	48 39 d0             	cmp    rax,rdx
  40cd27:	74 0e                	je     40cd37 <tar_len+0x47>
		if (((char *)r)[i]) return 0;
  40cd29:	80 38 00             	cmp    BYTE PTR [rax],0x0
  40cd2c:	74 f2                	je     40cd20 <tar_len+0x30>
	if (!tar_is_dir(ent->record)) return 0;
  40cd2e:	80 b9 9c 00 00 00 35 	cmp    BYTE PTR [rcx+0x9c],0x35
  40cd35:	74 0f                	je     40cd46 <tar_len+0x56>
	int cont = 0, cnt = 0;
	struct tar_iter i;
	struct tar_entry entry;	/* data placed in here; don't care about it for calculating len */
	for (cont = tar_iter(start, &i, &entry); cont ; cont = tar_iter_next(&i, &entry)) {
  40cd37:	45 31 e4             	xor    r12d,r12d
		cnt++;
	}

	return cnt;
}
  40cd3a:	48 83 c4 30          	add    rsp,0x30
  40cd3e:	44 89 e0             	mov    eax,r12d
  40cd41:	5b                   	pop    rbx
  40cd42:	41 5c                	pop    r12
  40cd44:	5d                   	pop    rbp
  40cd45:	c3                   	ret    
	i->entry    = *ent;
  40cd46:	f3 0f 6f 07          	movdqu xmm0,XMMWORD PTR [rdi]
	i->iter_rec = ent->record;
  40cd4a:	48 89 4d e0          	mov    QWORD PTR [rbp-0x20],rcx
	return tar_iter_next(i, first);
  40cd4e:	48 8d 75 c0          	lea    rsi,[rbp-0x40]
  40cd52:	48 8d 7d d0          	lea    rdi,[rbp-0x30]
  40cd56:	48 bb 40 c9 40 00 00 	movabs rbx,0x40c940
  40cd5d:	00 00 00 
	i->entry    = *ent;
  40cd60:	0f 29 45 d0          	movaps XMMWORD PTR [rbp-0x30],xmm0
	i->entry.nesting_lvl++;	/* look *in* the entry */
  40cd64:	83 45 d0 01          	add    DWORD PTR [rbp-0x30],0x1
	return tar_iter_next(i, first);
  40cd68:	ff d3                	call   rbx
	for (cont = tar_iter(start, &i, &entry); cont ; cont = tar_iter_next(&i, &entry)) {
  40cd6a:	85 c0                	test   eax,eax
  40cd6c:	74 c9                	je     40cd37 <tar_len+0x47>
  40cd6e:	45 31 e4             	xor    r12d,r12d
  40cd71:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		cnt++;
  40cd78:	41 83 c4 01          	add    r12d,0x1
	for (cont = tar_iter(start, &i, &entry); cont ; cont = tar_iter_next(&i, &entry)) {
  40cd7c:	48 8d 75 c0          	lea    rsi,[rbp-0x40]
  40cd80:	48 8d 7d d0          	lea    rdi,[rbp-0x30]
  40cd84:	ff d3                	call   rbx
  40cd86:	85 c0                	test   eax,eax
  40cd88:	75 ee                	jne    40cd78 <tar_len+0x88>
  40cd8a:	eb ae                	jmp    40cd3a <tar_len+0x4a>
  40cd8c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000040cd90 <tar_root>:
	return (unsigned int)((char *)_binary_crt_init_tar_end - (char *)_binary_crt_init_tar_start);
}

struct tar_entry *
tar_root(void)
{
  40cd90:	f3 0f 1e fa          	endbr64 
	if ((char *)_binary_crt_init_tar_end - (char *)_binary_crt_init_tar_start < 512) return NULL;
  40cd94:	48 ba 59 49 5a 00 00 	movabs rdx,0x5a4959
  40cd9b:	00 00 00 
  40cd9e:	48 b8 58 49 5a 00 00 	movabs rax,0x5a4958
  40cda5:	00 00 00 
  40cda8:	48 29 d0             	sub    rax,rdx
  40cdab:	ba 00 00 00 00       	mov    edx,0x0
  40cdb0:	48 3d ff 01 00 00    	cmp    rax,0x1ff
  40cdb6:	48 b8 40 00 46 00 00 	movabs rax,0x460040
  40cdbd:	00 00 00 
  40cdc0:	48 0f 4e c2          	cmovle rax,rdx

	return &__tar_root;
}
  40cdc4:	c3                   	ret    
  40cdc5:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40cdcc:	00 00 00 
  40cdcf:	90                   	nop

000000000040cdd0 <cos_aepthd_fn>:
{
  40cdd0:	f3 0f 1e fa          	endbr64 
  40cdd4:	55                   	push   rbp
  40cdd5:	48 89 f8             	mov    rax,rdi
	(aep_fn)(aep_info->rcv, fn_data);
  40cdd8:	48 8b 77 28          	mov    rsi,QWORD PTR [rdi+0x28]
  40cddc:	48 8b 7f 18          	mov    rdi,QWORD PTR [rdi+0x18]
{
  40cde0:	48 89 e5             	mov    rbp,rsp
	(aep_fn)(aep_info->rcv, fn_data);
  40cde3:	ff 50 20             	call   QWORD PTR [rax+0x20]
  40cde6:	be 32 00 00 00       	mov    esi,0x32
  40cdeb:	48 bf e0 fd 41 00 00 	movabs rdi,0x41fde0
  40cdf2:	00 00 00 
  40cdf5:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40cdfc:	00 00 00 
  40cdff:	ff d0                	call   rax
	assert(0);
  40ce01:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ce08:	00 00 00 00 
  40ce0c:	0f 0b                	ud2    
  40ce0e:	66 90                	xchg   ax,ax

000000000040ce10 <cos_defcompinfo_curr_get>:
static int                    curr_defci_init_status;
static struct cos_defcompinfo curr_defci;

struct cos_defcompinfo *
cos_defcompinfo_curr_get(void)
{
  40ce10:	f3 0f 1e fa          	endbr64 
	return &curr_defci;
  40ce14:	48 b8 60 49 5a 00 00 	movabs rax,0x5a4960
  40ce1b:	00 00 00 
}
  40ce1e:	c3                   	ret    
  40ce1f:	90                   	nop

000000000040ce20 <cos_compinfo_get>:

struct cos_compinfo *
cos_compinfo_get(struct cos_defcompinfo *defci)
{
  40ce20:	f3 0f 1e fa          	endbr64 
	assert(defci);
  40ce24:	48 85 ff             	test   rdi,rdi
  40ce27:	74 04                	je     40ce2d <cos_compinfo_get+0xd>
  40ce29:	48 89 f8             	mov    rax,rdi
	return &(defci->ci);
}
  40ce2c:	c3                   	ret    
  40ce2d:	48 bf 18 fe 41 00 00 	movabs rdi,0x41fe18
  40ce34:	00 00 00 
{
  40ce37:	55                   	push   rbp
  40ce38:	be 30 00 00 00       	mov    esi,0x30
  40ce3d:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40ce44:	00 00 00 
  40ce47:	48 89 e5             	mov    rbp,rsp
  40ce4a:	ff d0                	call   rax
	assert(defci);
  40ce4c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ce53:	00 00 00 00 
  40ce57:	0f 0b                	ud2    
  40ce59:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000040ce60 <cos_sched_aep_get>:

struct cos_aep_info *
cos_sched_aep_get(struct cos_defcompinfo *defci)
{
  40ce60:	f3 0f 1e fa          	endbr64 
	assert(defci);
  40ce64:	48 85 ff             	test   rdi,rdi
  40ce67:	74 08                	je     40ce71 <cos_sched_aep_get+0x11>
	return &(defci->sched_aep[cos_cpuid()]);
  40ce69:	48 8d 87 e0 00 00 00 	lea    rax,[rdi+0xe0]
}
  40ce70:	c3                   	ret    
  40ce71:	48 bf 50 fe 41 00 00 	movabs rdi,0x41fe50
  40ce78:	00 00 00 
{
  40ce7b:	55                   	push   rbp
  40ce7c:	be 30 00 00 00       	mov    esi,0x30
  40ce81:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40ce88:	00 00 00 
  40ce8b:	48 89 e5             	mov    rbp,rsp
  40ce8e:	ff d0                	call   rax
	assert(defci);
  40ce90:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ce97:	00 00 00 00 
  40ce9b:	0f 0b                	ud2    
  40ce9d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040cea0 <cos_defcompinfo_init>:

void
cos_defcompinfo_init(void)
{
  40cea0:	f3 0f 1e fa          	endbr64 
	capid_t cap_frontier = atol(args_get("captbl_end"));
  40cea4:	48 bf 81 fe 41 00 00 	movabs rdi,0x41fe81
  40ceab:	00 00 00 
{
  40ceae:	55                   	push   rbp
	capid_t cap_frontier = atol(args_get("captbl_end"));
  40ceaf:	48 b8 20 c6 40 00 00 	movabs rax,0x40c620
  40ceb6:	00 00 00 
{
  40ceb9:	48 89 e5             	mov    rbp,rsp
  40cebc:	41 54                	push   r12
  40cebe:	48 83 ec 08          	sub    rsp,0x8
	capid_t cap_frontier = atol(args_get("captbl_end"));
  40cec2:	ff d0                	call   rax
  40cec4:	48 89 c7             	mov    rdi,rax
  40cec7:	48 b8 20 82 41 00 00 	movabs rax,0x418220
  40cece:	00 00 00 
  40ced1:	ff d0                	call   rax

	assert(cap_frontier > 0);
  40ced3:	48 85 c0             	test   rax,rax
  40ced6:	0f 84 c6 00 00 00    	je     40cfa2 <cos_defcompinfo_init+0x102>
  40cedc:	49 89 c1             	mov    r9,rax
	if (curr_defci_init_status == INITIALIZED) return;
  40cedf:	48 b8 70 4a 5a 00 00 	movabs rax,0x5a4a70
  40cee6:	00 00 00 
  40cee9:	83 38 01             	cmp    DWORD PTR [rax],0x1
  40ceec:	0f 84 aa 00 00 00    	je     40cf9c <cos_defcompinfo_init+0xfc>
	struct cos_defcompinfo *defci = cos_defcompinfo_curr_get();
	struct cos_compinfo    *ci    = cos_compinfo_get(defci);

	if (curr_defci_init_status == INITIALIZED) return;

	cos_compinfo_init(ci, pgtbl_cap, captbl_cap, comp_cap, heap_ptr, cap_frontier, ci);
  40cef2:	48 83 ec 08          	sub    rsp,0x8
  40cef6:	b9 0c 00 00 00       	mov    ecx,0xc
  40cefb:	ba 04 00 00 00       	mov    edx,0x4
  40cf00:	49 bc 60 49 5a 00 00 	movabs r12,0x5a4960
  40cf07:	00 00 00 
  40cf0a:	41 54                	push   r12
  40cf0c:	be 08 00 00 00       	mov    esi,0x8
  40cf11:	4c 89 e7             	mov    rdi,r12
  40cf14:	48 b8 58 b0 42 00 00 	movabs rax,0x42b058
  40cf1b:	00 00 00 
  40cf1e:	4c 8b 00             	mov    r8,QWORD PTR [rax]
  40cf21:	48 b8 f0 f2 40 00 00 	movabs rax,0x40f2f0
  40cf28:	00 00 00 
  40cf2b:	ff d0                	call   rax
	sched_aep->tc   = sched_tc;
	sched_aep->thd  = sched_thd;
	sched_aep->rcv  = sched_rcv;
	sched_aep->fn   = NULL;
	sched_aep->data = NULL;
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40cf2d:	31 d2                	xor    edx,edx
  40cf2f:	be 28 00 00 00       	mov    esi,0x28
  40cf34:	4c 89 e7             	mov    rdi,r12
	curr_defci_init_status = INITIALIZED;
  40cf37:	48 b8 70 4a 5a 00 00 	movabs rax,0x5a4a70
  40cf3e:	00 00 00 
	sched_aep->rcv  = sched_rcv;
  40cf41:	49 c7 84 24 f8 00 00 	mov    QWORD PTR [r12+0xf8],0x30
  40cf48:	00 30 00 00 00 
	curr_defci_init_status = INITIALIZED;
  40cf4d:	c7 00 01 00 00 00    	mov    DWORD PTR [rax],0x1
	sched_aep->tc   = sched_tc;
  40cf53:	48 b8 70 01 42 00 00 	movabs rax,0x420170
  40cf5a:	00 00 00 
	sched_aep->fn   = NULL;
  40cf5d:	49 c7 84 24 00 01 00 	mov    QWORD PTR [r12+0x100],0x0
  40cf64:	00 00 00 00 00 
	sched_aep->tc   = sched_tc;
  40cf69:	66 0f 6f 00          	movdqa xmm0,XMMWORD PTR [rax]
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40cf6d:	48 b8 d0 3e 41 00 00 	movabs rax,0x413ed0
  40cf74:	00 00 00 
	sched_aep->data = NULL;
  40cf77:	49 c7 84 24 08 01 00 	mov    QWORD PTR [r12+0x108],0x0
  40cf7e:	00 00 00 00 00 
	sched_aep->tc   = sched_tc;
  40cf83:	41 0f 29 84 24 e0 00 	movaps XMMWORD PTR [r12+0xe0],xmm0
  40cf8a:	00 00 
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40cf8c:	ff d0                	call   rax
  40cf8e:	48 98                	cdqe   
  40cf90:	48 a3 50 4a 5a 00 00 	movabs ds:0x5a4a50,rax
  40cf97:	00 00 00 
}
  40cf9a:	58                   	pop    rax
  40cf9b:	5a                   	pop    rdx
}
  40cf9c:	4c 8b 65 f8          	mov    r12,QWORD PTR [rbp-0x8]
  40cfa0:	c9                   	leave  
  40cfa1:	c3                   	ret    
  40cfa2:	48 bf 90 fe 41 00 00 	movabs rdi,0x41fe90
  40cfa9:	00 00 00 
  40cfac:	be 30 00 00 00       	mov    esi,0x30
  40cfb1:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40cfb8:	00 00 00 
  40cfbb:	ff d0                	call   rax
	assert(cap_frontier > 0);
  40cfbd:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40cfc4:	00 00 00 00 
  40cfc8:	0f 0b                	ud2    
  40cfca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000040cfd0 <cos_defcompinfo_init_ext>:
{
  40cfd0:	f3 0f 1e fa          	endbr64 
  40cfd4:	55                   	push   rbp
  40cfd5:	66 48 0f 6e c7       	movq   xmm0,rdi
  40cfda:	66 48 0f 6e ce       	movq   xmm1,rsi
	if (curr_defci_init_status == INITIALIZED) return;
  40cfdf:	48 b8 70 4a 5a 00 00 	movabs rax,0x5a4a70
  40cfe6:	00 00 00 
  40cfe9:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
{
  40cfed:	48 89 e5             	mov    rbp,rsp
  40cff0:	41 55                	push   r13
  40cff2:	41 54                	push   r12
  40cff4:	49 89 f4             	mov    r12,rsi
  40cff7:	53                   	push   rbx
  40cff8:	48 83 ec 18          	sub    rsp,0x18
	if (curr_defci_init_status == INITIALIZED) return;
  40cffc:	83 38 01             	cmp    DWORD PTR [rax],0x1
  40cfff:	0f 29 45 d0          	movaps XMMWORD PTR [rbp-0x30],xmm0
  40d003:	0f 84 95 00 00 00    	je     40d09e <cos_defcompinfo_init_ext+0xce>
	cos_compinfo_init(ci, pgtbl_cap, captbl_cap, comp_cap, heap_ptr, cap_frontier, ci);
  40d009:	49 bd 60 49 5a 00 00 	movabs r13,0x5a4960
  40d010:	00 00 00 
  40d013:	48 83 ec 08          	sub    rsp,0x8
  40d017:	48 89 ce             	mov    rsi,rcx
  40d01a:	48 89 d3             	mov    rbx,rdx
  40d01d:	41 55                	push   r13
  40d01f:	4c 89 c2             	mov    rdx,r8
  40d022:	4c 89 c9             	mov    rcx,r9
  40d025:	4c 8b 45 10          	mov    r8,QWORD PTR [rbp+0x10]
  40d029:	4c 8b 4d 18          	mov    r9,QWORD PTR [rbp+0x18]
  40d02d:	4c 89 ef             	mov    rdi,r13
  40d030:	48 b8 f0 f2 40 00 00 	movabs rax,0x40f2f0
  40d037:	00 00 00 
  40d03a:	ff d0                	call   rax
	sched_aep->tc   = sched_tc;
  40d03c:	66 0f 6f 45 d0       	movdqa xmm0,XMMWORD PTR [rbp-0x30]
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40d041:	31 d2                	xor    edx,edx
  40d043:	4c 89 e6             	mov    rsi,r12
	curr_defci_init_status = INITIALIZED;
  40d046:	48 b8 70 4a 5a 00 00 	movabs rax,0x5a4a70
  40d04d:	00 00 00 
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40d050:	4c 89 ef             	mov    rdi,r13
	sched_aep->fn   = NULL;
  40d053:	49 c7 85 00 01 00 00 	mov    QWORD PTR [r13+0x100],0x0
  40d05a:	00 00 00 00 
	curr_defci_init_status = INITIALIZED;
  40d05e:	c7 00 01 00 00 00    	mov    DWORD PTR [rax],0x1
	sched_aep->rcv  = sched_rcv;
  40d064:	48 89 d8             	mov    rax,rbx
  40d067:	48 a3 58 4a 5a 00 00 	movabs ds:0x5a4a58,rax
  40d06e:	00 00 00 
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40d071:	48 b8 d0 3e 41 00 00 	movabs rax,0x413ed0
  40d078:	00 00 00 
	sched_aep->data = NULL;
  40d07b:	49 c7 85 08 01 00 00 	mov    QWORD PTR [r13+0x108],0x0
  40d082:	00 00 00 00 
	sched_aep->tc   = sched_tc;
  40d086:	41 0f 29 85 e0 00 00 	movaps XMMWORD PTR [r13+0xe0],xmm0
  40d08d:	00 
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40d08e:	ff d0                	call   rax
  40d090:	48 98                	cdqe   
  40d092:	48 a3 50 4a 5a 00 00 	movabs ds:0x5a4a50,rax
  40d099:	00 00 00 
}
  40d09c:	58                   	pop    rax
  40d09d:	5a                   	pop    rdx
}
  40d09e:	48 8d 65 e8          	lea    rsp,[rbp-0x18]
  40d0a2:	5b                   	pop    rbx
  40d0a3:	41 5c                	pop    r12
  40d0a5:	41 5d                	pop    r13
  40d0a7:	5d                   	pop    rbp
  40d0a8:	c3                   	ret    
  40d0a9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000040d0b0 <cos_defcompinfo_sched_init_ext>:
{
  40d0b0:	f3 0f 1e fa          	endbr64 
  40d0b4:	55                   	push   rbp
  40d0b5:	66 48 0f 6e c7       	movq   xmm0,rdi
  40d0ba:	66 48 0f 6e ce       	movq   xmm1,rsi
	assert(curr_defci_init_status == INITIALIZED);
  40d0bf:	48 b8 70 4a 5a 00 00 	movabs rax,0x5a4a70
  40d0c6:	00 00 00 
  40d0c9:	83 38 01             	cmp    DWORD PTR [rax],0x1
  40d0cc:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
{
  40d0d0:	48 89 e5             	mov    rbp,rsp
	assert(curr_defci_init_status == INITIALIZED);
  40d0d3:	75 50                	jne    40d125 <cos_defcompinfo_sched_init_ext+0x75>
	sched_aep->tc   = sched_tc;
  40d0d5:	48 bf 60 49 5a 00 00 	movabs rdi,0x5a4960
  40d0dc:	00 00 00 
	sched_aep->rcv  = sched_rcv;
  40d0df:	48 89 d0             	mov    rax,rdx
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40d0e2:	31 d2                	xor    edx,edx
	sched_aep->rcv  = sched_rcv;
  40d0e4:	48 a3 58 4a 5a 00 00 	movabs ds:0x5a4a58,rax
  40d0eb:	00 00 00 
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40d0ee:	48 b8 d0 3e 41 00 00 	movabs rax,0x413ed0
  40d0f5:	00 00 00 
	sched_aep->fn   = NULL;
  40d0f8:	48 c7 87 00 01 00 00 	mov    QWORD PTR [rdi+0x100],0x0
  40d0ff:	00 00 00 00 
	sched_aep->data = NULL;
  40d103:	48 c7 87 08 01 00 00 	mov    QWORD PTR [rdi+0x108],0x0
  40d10a:	00 00 00 00 
	sched_aep->tc   = sched_tc;
  40d10e:	0f 29 87 e0 00 00 00 	movaps XMMWORD PTR [rdi+0xe0],xmm0
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40d115:	ff d0                	call   rax
}
  40d117:	5d                   	pop    rbp
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40d118:	48 98                	cdqe   
  40d11a:	48 a3 50 4a 5a 00 00 	movabs ds:0x5a4a50,rax
  40d121:	00 00 00 
}
  40d124:	c3                   	ret    
  40d125:	48 bf c8 fe 41 00 00 	movabs rdi,0x41fec8
  40d12c:	00 00 00 
  40d12f:	be 30 00 00 00       	mov    esi,0x30
  40d134:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40d13b:	00 00 00 
  40d13e:	ff d0                	call   rax
	assert(curr_defci_init_status == INITIALIZED);
  40d140:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d147:	00 00 00 00 
  40d14b:	0f 0b                	ud2    
  40d14d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040d150 <cos_defcompinfo_sched_init>:

void
cos_defcompinfo_sched_init(void)
{
  40d150:	f3 0f 1e fa          	endbr64 
	assert(curr_defci_init_status == INITIALIZED);
  40d154:	48 b8 70 4a 5a 00 00 	movabs rax,0x5a4a70
  40d15b:	00 00 00 
{
  40d15e:	55                   	push   rbp
	assert(curr_defci_init_status == INITIALIZED);
  40d15f:	83 38 01             	cmp    DWORD PTR [rax],0x1
{
  40d162:	48 89 e5             	mov    rbp,rsp
	assert(curr_defci_init_status == INITIALIZED);
  40d165:	75 61                	jne    40d1c8 <cos_defcompinfo_sched_init+0x78>
	sched_aep->tc   = sched_tc;
  40d167:	48 b8 70 01 42 00 00 	movabs rax,0x420170
  40d16e:	00 00 00 
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40d171:	31 d2                	xor    edx,edx
  40d173:	be 28 00 00 00       	mov    esi,0x28
	sched_aep->tc   = sched_tc;
  40d178:	48 bf 60 49 5a 00 00 	movabs rdi,0x5a4960
  40d17f:	00 00 00 
	sched_aep->rcv  = sched_rcv;
  40d182:	48 c7 87 f8 00 00 00 	mov    QWORD PTR [rdi+0xf8],0x30
  40d189:	30 00 00 00 
	sched_aep->tc   = sched_tc;
  40d18d:	66 0f 6f 00          	movdqa xmm0,XMMWORD PTR [rax]
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40d191:	48 b8 d0 3e 41 00 00 	movabs rax,0x413ed0
  40d198:	00 00 00 
	sched_aep->fn   = NULL;
  40d19b:	48 c7 87 00 01 00 00 	mov    QWORD PTR [rdi+0x100],0x0
  40d1a2:	00 00 00 00 
	sched_aep->data = NULL;
  40d1a6:	48 c7 87 08 01 00 00 	mov    QWORD PTR [rdi+0x108],0x0
  40d1ad:	00 00 00 00 
	sched_aep->tc   = sched_tc;
  40d1b1:	0f 29 87 e0 00 00 00 	movaps XMMWORD PTR [rdi+0xe0],xmm0
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40d1b8:	ff d0                	call   rax

	cos_defcompinfo_sched_init_ext(BOOT_CAPTBL_SELF_INITTCAP_CPU_BASE, BOOT_CAPTBL_SELF_INITTHD_CPU_BASE,
				       BOOT_CAPTBL_SELF_INITRCV_CPU_BASE);
}
  40d1ba:	5d                   	pop    rbp
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40d1bb:	48 98                	cdqe   
  40d1bd:	48 a3 50 4a 5a 00 00 	movabs ds:0x5a4a50,rax
  40d1c4:	00 00 00 
}
  40d1c7:	c3                   	ret    
  40d1c8:	48 bf 00 ff 41 00 00 	movabs rdi,0x41ff00
  40d1cf:	00 00 00 
  40d1d2:	be 30 00 00 00       	mov    esi,0x30
  40d1d7:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40d1de:	00 00 00 
  40d1e1:	ff d0                	call   rax
	assert(curr_defci_init_status == INITIALIZED);
  40d1e3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d1ea:	00 00 00 00 
  40d1ee:	0f 0b                	ud2    

000000000040d1f0 <cos_defcompinfo_child_alloc>:
}

int
cos_defcompinfo_child_alloc(struct cos_defcompinfo *child_defci, vaddr_t entry, vaddr_t heap_ptr, capid_t cap_frontier,
                            int is_sched)
{
  40d1f0:	f3 0f 1e fa          	endbr64 
  40d1f4:	55                   	push   rbp
  40d1f5:	48 89 e5             	mov    rbp,rsp
  40d1f8:	41 56                	push   r14
  40d1fa:	41 55                	push   r13
  40d1fc:	41 54                	push   r12
  40d1fe:	53                   	push   rbx
	assert(defci);
  40d1ff:	48 85 ff             	test   rdi,rdi
  40d202:	0f 84 4d 01 00 00    	je     40d355 <cos_defcompinfo_child_alloc+0x165>
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);
	struct cos_compinfo    *ci        = cos_compinfo_get(defci);
	struct cos_compinfo    *child_ci  = cos_compinfo_get(child_defci);
	struct cos_aep_info    *child_aep = cos_sched_aep_get(child_defci);

	assert(curr_defci_init_status == INITIALIZED);
  40d208:	49 be 70 4a 5a 00 00 	movabs r14,0x5a4a70
  40d20f:	00 00 00 
  40d212:	41 83 3e 01          	cmp    DWORD PTR [r14],0x1
  40d216:	0f 85 61 01 00 00    	jne    40d37d <cos_defcompinfo_child_alloc+0x18d>
  40d21c:	49 89 f2             	mov    r10,rsi
  40d21f:	48 89 fb             	mov    rbx,rdi
  40d222:	48 89 d6             	mov    rsi,rdx
  40d225:	45 89 c5             	mov    r13d,r8d
	ret = cos_compinfo_alloc(child_ci, heap_ptr, cap_frontier, entry, ci, 0);
  40d228:	48 b8 d0 28 41 00 00 	movabs rax,0x4128d0
  40d22f:	00 00 00 
  40d232:	48 89 ca             	mov    rdx,rcx
  40d235:	45 31 c9             	xor    r9d,r9d
  40d238:	49 b8 60 49 5a 00 00 	movabs r8,0x5a4960
  40d23f:	00 00 00 
  40d242:	4c 89 d1             	mov    rcx,r10
  40d245:	ff d0                	call   rax
  40d247:	41 89 c4             	mov    r12d,eax
	if (ret) return ret;
  40d24a:	85 c0                	test   eax,eax
  40d24c:	0f 85 f7 00 00 00    	jne    40d349 <cos_defcompinfo_child_alloc+0x159>
	ret = cos_aep_alloc_intern(child_aep, child_defci, 0, is_sched ? sched_aep : NULL, NULL, NULL, 0);
  40d252:	45 85 ed             	test   r13d,r13d
  40d255:	b8 00 00 00 00       	mov    eax,0x0
  40d25a:	49 bd 40 4a 5a 00 00 	movabs r13,0x5a4a40
  40d261:	00 00 00 
  40d264:	4c 0f 44 e8          	cmove  r13,rax
	assert(curr_defci_init_status == INITIALIZED);
  40d268:	41 83 3e 01          	cmp    DWORD PTR [r14],0x1
  40d26c:	0f 85 33 01 00 00    	jne    40d3a5 <cos_defcompinfo_child_alloc+0x1b5>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40d272:	66 0f ef c0          	pxor   xmm0,xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40d276:	48 8b 73 10          	mov    rsi,QWORD PTR [rbx+0x10]
  40d27a:	49 be 60 49 5a 00 00 	movabs r14,0x5a4960
  40d281:	00 00 00 
  40d284:	48 b8 70 17 41 00 00 	movabs rax,0x411770
  40d28b:	00 00 00 
	memset(aep, 0, sizeof(struct cos_aep_info));
  40d28e:	0f 11 83 e0 00 00 00 	movups XMMWORD PTR [rbx+0xe0],xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40d295:	4c 89 f7             	mov    rdi,r14
	memset(aep, 0, sizeof(struct cos_aep_info));
  40d298:	0f 11 83 f0 00 00 00 	movups XMMWORD PTR [rbx+0xf0],xmm0
  40d29f:	0f 11 83 00 01 00 00 	movups XMMWORD PTR [rbx+0x100],xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40d2a6:	ff d0                	call   rax
  40d2a8:	48 89 83 e8 00 00 00 	mov    QWORD PTR [rbx+0xe8],rax
  40d2af:	48 89 c6             	mov    rsi,rax
	assert(aep->thd);
  40d2b2:	48 85 c0             	test   rax,rax
  40d2b5:	0f 84 12 01 00 00    	je     40d3cd <cos_defcompinfo_child_alloc+0x1dd>
	aep->tid  = cos_introspect(ci, aep->thd, THD_GET_TID);
  40d2bb:	48 b8 d0 3e 41 00 00 	movabs rax,0x413ed0
  40d2c2:	00 00 00 
  40d2c5:	31 d2                	xor    edx,edx
  40d2c7:	4c 89 f7             	mov    rdi,r14
  40d2ca:	ff d0                	call   rax
  40d2cc:	48 98                	cdqe   
  40d2ce:	48 89 83 f0 00 00 00 	mov    QWORD PTR [rbx+0xf0],rax
	if (!sched && is_init) return 0;
  40d2d5:	4d 85 ed             	test   r13,r13
  40d2d8:	74 6f                	je     40d349 <cos_defcompinfo_child_alloc+0x159>
		aep->tc = cos_tcap_alloc(ci);
  40d2da:	48 b8 30 3f 41 00 00 	movabs rax,0x413f30
  40d2e1:	00 00 00 
  40d2e4:	4c 89 f7             	mov    rdi,r14
  40d2e7:	ff d0                	call   rax
  40d2e9:	48 89 83 e0 00 00 00 	mov    QWORD PTR [rbx+0xe0],rax
  40d2f0:	48 89 c2             	mov    rdx,rax
		assert(aep->tc);
  40d2f3:	48 85 c0             	test   rax,rax
  40d2f6:	0f 84 f9 00 00 00    	je     40d3f5 <cos_defcompinfo_child_alloc+0x205>
	aep->rcv  = cos_arcv_alloc(ci, aep->thd, aep->tc, ci->comp_cap, sched->rcv);
  40d2fc:	48 8b b3 e8 00 00 00 	mov    rsi,QWORD PTR [rbx+0xe8]
  40d303:	4d 8b 45 18          	mov    r8,QWORD PTR [r13+0x18]
  40d307:	4c 89 f7             	mov    rdi,r14
  40d30a:	48 b8 70 49 5a 00 00 	movabs rax,0x5a4970
  40d311:	00 00 00 
  40d314:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  40d317:	48 b8 a0 2c 41 00 00 	movabs rax,0x412ca0
  40d31e:	00 00 00 
  40d321:	ff d0                	call   rax
  40d323:	48 89 83 f8 00 00 00 	mov    QWORD PTR [rbx+0xf8],rax
	assert(aep->rcv);
  40d32a:	48 85 c0             	test   rax,rax
  40d32d:	0f 84 ea 00 00 00    	je     40d41d <cos_defcompinfo_child_alloc+0x22d>
	aep->fn   = fn;
  40d333:	48 c7 83 00 01 00 00 	mov    QWORD PTR [rbx+0x100],0x0
  40d33a:	00 00 00 00 
	aep->data = data;
  40d33e:	48 c7 83 08 01 00 00 	mov    QWORD PTR [rbx+0x108],0x0
  40d345:	00 00 00 00 

	return ret;
}
  40d349:	5b                   	pop    rbx
  40d34a:	44 89 e0             	mov    eax,r12d
  40d34d:	41 5c                	pop    r12
  40d34f:	41 5d                	pop    r13
  40d351:	41 5e                	pop    r14
  40d353:	5d                   	pop    rbp
  40d354:	c3                   	ret    
  40d355:	48 bf 18 fe 41 00 00 	movabs rdi,0x41fe18
  40d35c:	00 00 00 
  40d35f:	be 30 00 00 00       	mov    esi,0x30
  40d364:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40d36b:	00 00 00 
  40d36e:	ff d0                	call   rax
	assert(defci);
  40d370:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d377:	00 00 00 00 
  40d37b:	0f 0b                	ud2    
  40d37d:	48 bf 38 ff 41 00 00 	movabs rdi,0x41ff38
  40d384:	00 00 00 
  40d387:	be 31 00 00 00       	mov    esi,0x31
  40d38c:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40d393:	00 00 00 
  40d396:	ff d0                	call   rax
	assert(curr_defci_init_status == INITIALIZED);
  40d398:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d39f:	00 00 00 00 
  40d3a3:	0f 0b                	ud2    
  40d3a5:	48 bf 70 ff 41 00 00 	movabs rdi,0x41ff70
  40d3ac:	00 00 00 
  40d3af:	be 31 00 00 00       	mov    esi,0x31
  40d3b4:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40d3bb:	00 00 00 
  40d3be:	ff d0                	call   rax
	assert(curr_defci_init_status == INITIALIZED);
  40d3c0:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d3c7:	00 00 00 00 
  40d3cb:	0f 0b                	ud2    
  40d3cd:	48 bf a8 ff 41 00 00 	movabs rdi,0x41ffa8
  40d3d4:	00 00 00 
  40d3d7:	be 31 00 00 00       	mov    esi,0x31
  40d3dc:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40d3e3:	00 00 00 
  40d3e6:	ff d0                	call   rax
	assert(aep->thd);
  40d3e8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d3ef:	00 00 00 00 
  40d3f3:	0f 0b                	ud2    
  40d3f5:	48 bf e0 ff 41 00 00 	movabs rdi,0x41ffe0
  40d3fc:	00 00 00 
  40d3ff:	be 31 00 00 00       	mov    esi,0x31
  40d404:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40d40b:	00 00 00 
  40d40e:	ff d0                	call   rax
		assert(aep->tc);
  40d410:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d417:	00 00 00 00 
  40d41b:	0f 0b                	ud2    
  40d41d:	48 bf 18 00 42 00 00 	movabs rdi,0x420018
  40d424:	00 00 00 
  40d427:	be 31 00 00 00       	mov    esi,0x31
  40d42c:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40d433:	00 00 00 
  40d436:	ff d0                	call   rax
	assert(aep->rcv);
  40d438:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d43f:	00 00 00 00 
  40d443:	0f 0b                	ud2    
  40d445:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40d44c:	00 00 00 00 

000000000040d450 <cos_defcompinfo_childid_init>:

void
cos_defcompinfo_childid_init(struct cos_defcompinfo *child_defci, spdid_t c)
{
  40d450:	f3 0f 1e fa          	endbr64 
	assert(child_defci != cos_defcompinfo_curr_get());
  40d454:	48 b8 60 49 5a 00 00 	movabs rax,0x5a4960
  40d45b:	00 00 00 
  40d45e:	48 39 c7             	cmp    rdi,rax
  40d461:	74 04                	je     40d467 <cos_defcompinfo_childid_init+0x17>

	child_defci->id = c;
  40d463:	66 89 37             	mov    WORD PTR [rdi],si
  40d466:	c3                   	ret    
  40d467:	48 bf 50 00 42 00 00 	movabs rdi,0x420050
  40d46e:	00 00 00 
{
  40d471:	55                   	push   rbp
  40d472:	be 31 00 00 00       	mov    esi,0x31
  40d477:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40d47e:	00 00 00 
  40d481:	48 89 e5             	mov    rbp,rsp
  40d484:	ff d0                	call   rax
	assert(child_defci != cos_defcompinfo_curr_get());
  40d486:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d48d:	00 00 00 00 
  40d491:	0f 0b                	ud2    
  40d493:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40d49a:	00 00 00 00 
  40d49e:	66 90                	xchg   ax,ax

000000000040d4a0 <cos_initaep_alloc>:
}

int
cos_initaep_alloc(struct cos_defcompinfo *dst_dci, struct cos_aep_info *sched, int is_sched)
{
  40d4a0:	f3 0f 1e fa          	endbr64 
  40d4a4:	55                   	push   rbp
  40d4a5:	48 89 e5             	mov    rbp,rsp
  40d4a8:	41 55                	push   r13
  40d4aa:	41 54                	push   r12
  40d4ac:	53                   	push   rbx
  40d4ad:	48 83 ec 08          	sub    rsp,0x8
	assert(defci);
  40d4b1:	48 85 ff             	test   rdi,rdi
  40d4b4:	0f 84 27 01 00 00    	je     40d5e1 <cos_initaep_alloc+0x141>
  40d4ba:	48 89 fb             	mov    rbx,rdi
	return &(defci->sched_aep[cos_cpuid()]);
  40d4bd:	48 8d 87 e0 00 00 00 	lea    rax,[rdi+0xe0]
	struct cos_defcompinfo *defci     = cos_defcompinfo_curr_get();
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);
	struct cos_aep_info    *child_aep = cos_sched_aep_get(dst_dci);
	struct cos_aep_info    *sched_use = is_sched ? (sched ? sched : sched_aep) : NULL;
  40d4c4:	45 31 e4             	xor    r12d,r12d
  40d4c7:	85 d2                	test   edx,edx
  40d4c9:	0f 85 f9 00 00 00    	jne    40d5c8 <cos_initaep_alloc+0x128>
	assert(curr_defci_init_status == INITIALIZED);
  40d4cf:	48 ba 70 4a 5a 00 00 	movabs rdx,0x5a4a70
  40d4d6:	00 00 00 
  40d4d9:	83 3a 01             	cmp    DWORD PTR [rdx],0x1
  40d4dc:	0f 85 27 01 00 00    	jne    40d609 <cos_initaep_alloc+0x169>
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40d4e2:	49 bd 60 49 5a 00 00 	movabs r13,0x5a4960
  40d4e9:	00 00 00 
	memset(aep, 0, sizeof(struct cos_aep_info));
  40d4ec:	66 0f ef c0          	pxor   xmm0,xmm0
  40d4f0:	0f 11 83 e0 00 00 00 	movups XMMWORD PTR [rbx+0xe0],xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40d4f7:	4c 89 ef             	mov    rdi,r13
	memset(aep, 0, sizeof(struct cos_aep_info));
  40d4fa:	0f 11 40 10          	movups XMMWORD PTR [rax+0x10],xmm0
  40d4fe:	0f 11 40 20          	movups XMMWORD PTR [rax+0x20],xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40d502:	48 8b 73 10          	mov    rsi,QWORD PTR [rbx+0x10]
  40d506:	48 b8 70 17 41 00 00 	movabs rax,0x411770
  40d50d:	00 00 00 
  40d510:	ff d0                	call   rax
  40d512:	48 89 83 e8 00 00 00 	mov    QWORD PTR [rbx+0xe8],rax
  40d519:	48 89 c6             	mov    rsi,rax
	assert(aep->thd);
  40d51c:	48 85 c0             	test   rax,rax
  40d51f:	0f 84 0c 01 00 00    	je     40d631 <cos_initaep_alloc+0x191>
	aep->tid  = cos_introspect(ci, aep->thd, THD_GET_TID);
  40d525:	48 b8 d0 3e 41 00 00 	movabs rax,0x413ed0
  40d52c:	00 00 00 
  40d52f:	31 d2                	xor    edx,edx
  40d531:	4c 89 ef             	mov    rdi,r13
  40d534:	ff d0                	call   rax
  40d536:	48 98                	cdqe   
  40d538:	48 89 83 f0 00 00 00 	mov    QWORD PTR [rbx+0xf0],rax
	if (!sched && is_init) return 0;
  40d53f:	4d 85 e4             	test   r12,r12
  40d542:	74 70                	je     40d5b4 <cos_initaep_alloc+0x114>
		aep->tc = cos_tcap_alloc(ci);
  40d544:	48 b8 30 3f 41 00 00 	movabs rax,0x413f30
  40d54b:	00 00 00 
  40d54e:	4c 89 ef             	mov    rdi,r13
  40d551:	ff d0                	call   rax
  40d553:	48 89 83 e0 00 00 00 	mov    QWORD PTR [rbx+0xe0],rax
  40d55a:	48 89 c2             	mov    rdx,rax
		assert(aep->tc);
  40d55d:	48 85 c0             	test   rax,rax
  40d560:	0f 84 f3 00 00 00    	je     40d659 <cos_initaep_alloc+0x1b9>
	aep->rcv  = cos_arcv_alloc(ci, aep->thd, aep->tc, ci->comp_cap, sched->rcv);
  40d566:	48 8b b3 e8 00 00 00 	mov    rsi,QWORD PTR [rbx+0xe8]
  40d56d:	4d 8b 44 24 18       	mov    r8,QWORD PTR [r12+0x18]
  40d572:	4c 89 ef             	mov    rdi,r13
  40d575:	48 b8 70 49 5a 00 00 	movabs rax,0x5a4970
  40d57c:	00 00 00 
  40d57f:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  40d582:	48 b8 a0 2c 41 00 00 	movabs rax,0x412ca0
  40d589:	00 00 00 
  40d58c:	ff d0                	call   rax
  40d58e:	48 89 83 f8 00 00 00 	mov    QWORD PTR [rbx+0xf8],rax
	assert(aep->rcv);
  40d595:	48 85 c0             	test   rax,rax
  40d598:	0f 84 e3 00 00 00    	je     40d681 <cos_initaep_alloc+0x1e1>
	aep->fn   = fn;
  40d59e:	48 c7 83 00 01 00 00 	mov    QWORD PTR [rbx+0x100],0x0
  40d5a5:	00 00 00 00 
	aep->data = data;
  40d5a9:	48 c7 83 08 01 00 00 	mov    QWORD PTR [rbx+0x108],0x0
  40d5b0:	00 00 00 00 

	return cos_aep_alloc_intern(child_aep, dst_dci, 0, sched_use, NULL, NULL, 0);
}
  40d5b4:	48 83 c4 08          	add    rsp,0x8
  40d5b8:	31 c0                	xor    eax,eax
  40d5ba:	5b                   	pop    rbx
  40d5bb:	41 5c                	pop    r12
  40d5bd:	41 5d                	pop    r13
  40d5bf:	5d                   	pop    rbp
  40d5c0:	c3                   	ret    
  40d5c1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	struct cos_aep_info    *sched_use = is_sched ? (sched ? sched : sched_aep) : NULL;
  40d5c8:	48 ba 40 4a 5a 00 00 	movabs rdx,0x5a4a40
  40d5cf:	00 00 00 
  40d5d2:	49 89 f4             	mov    r12,rsi
  40d5d5:	48 85 f6             	test   rsi,rsi
  40d5d8:	4c 0f 44 e2          	cmove  r12,rdx
  40d5dc:	e9 ee fe ff ff       	jmp    40d4cf <cos_initaep_alloc+0x2f>
  40d5e1:	48 bf 50 fe 41 00 00 	movabs rdi,0x41fe50
  40d5e8:	00 00 00 
  40d5eb:	be 30 00 00 00       	mov    esi,0x30
  40d5f0:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40d5f7:	00 00 00 
  40d5fa:	ff d0                	call   rax
	assert(defci);
  40d5fc:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d603:	00 00 00 00 
  40d607:	0f 0b                	ud2    
  40d609:	48 bf 70 ff 41 00 00 	movabs rdi,0x41ff70
  40d610:	00 00 00 
  40d613:	be 31 00 00 00       	mov    esi,0x31
  40d618:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40d61f:	00 00 00 
  40d622:	ff d0                	call   rax
	assert(curr_defci_init_status == INITIALIZED);
  40d624:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d62b:	00 00 00 00 
  40d62f:	0f 0b                	ud2    
  40d631:	48 bf a8 ff 41 00 00 	movabs rdi,0x41ffa8
  40d638:	00 00 00 
  40d63b:	be 31 00 00 00       	mov    esi,0x31
  40d640:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40d647:	00 00 00 
  40d64a:	ff d0                	call   rax
	assert(aep->thd);
  40d64c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d653:	00 00 00 00 
  40d657:	0f 0b                	ud2    
  40d659:	48 bf e0 ff 41 00 00 	movabs rdi,0x41ffe0
  40d660:	00 00 00 
  40d663:	be 31 00 00 00       	mov    esi,0x31
  40d668:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40d66f:	00 00 00 
  40d672:	ff d0                	call   rax
		assert(aep->tc);
  40d674:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d67b:	00 00 00 00 
  40d67f:	0f 0b                	ud2    
  40d681:	48 bf 18 00 42 00 00 	movabs rdi,0x420018
  40d688:	00 00 00 
  40d68b:	be 31 00 00 00       	mov    esi,0x31
  40d690:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40d697:	00 00 00 
  40d69a:	ff d0                	call   rax
	assert(aep->rcv);
  40d69c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d6a3:	00 00 00 00 
  40d6a7:	0f 0b                	ud2    
  40d6a9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000040d6b0 <cos_initaep_tcap_alloc>:

int
cos_initaep_tcap_alloc(struct cos_defcompinfo *dst_dci, tcap_t tc, struct cos_aep_info *sched)
{
  40d6b0:	f3 0f 1e fa          	endbr64 
  40d6b4:	55                   	push   rbp
  40d6b5:	48 89 e5             	mov    rbp,rsp
  40d6b8:	41 56                	push   r14
  40d6ba:	41 55                	push   r13
  40d6bc:	41 54                	push   r12
  40d6be:	53                   	push   rbx
	assert(defci);
  40d6bf:	48 85 ff             	test   rdi,rdi
  40d6c2:	0f 84 4a 01 00 00    	je     40d812 <cos_initaep_tcap_alloc+0x162>
	struct cos_defcompinfo *defci     = cos_defcompinfo_curr_get();
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);
	struct cos_aep_info    *child_aep = cos_sched_aep_get(dst_dci);
	struct cos_aep_info    *sched_use = sched ? sched : sched_aep;
  40d6c8:	48 85 d2             	test   rdx,rdx
  40d6cb:	49 89 d4             	mov    r12,rdx
	return &(defci->sched_aep[cos_cpuid()]);
  40d6ce:	48 8d 87 e0 00 00 00 	lea    rax,[rdi+0xe0]
	struct cos_aep_info    *sched_use = sched ? sched : sched_aep;
  40d6d5:	48 89 fb             	mov    rbx,rdi
  40d6d8:	48 ba 40 4a 5a 00 00 	movabs rdx,0x5a4a40
  40d6df:	00 00 00 
  40d6e2:	4c 0f 44 e2          	cmove  r12,rdx
	assert(curr_defci_init_status == INITIALIZED);
  40d6e6:	48 ba 70 4a 5a 00 00 	movabs rdx,0x5a4a70
  40d6ed:	00 00 00 
  40d6f0:	83 3a 01             	cmp    DWORD PTR [rdx],0x1
  40d6f3:	0f 85 41 01 00 00    	jne    40d83a <cos_initaep_tcap_alloc+0x18a>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40d6f9:	66 0f ef c0          	pxor   xmm0,xmm0
  40d6fd:	49 89 f5             	mov    r13,rsi
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40d700:	49 be 60 49 5a 00 00 	movabs r14,0x5a4960
  40d707:	00 00 00 
	memset(aep, 0, sizeof(struct cos_aep_info));
  40d70a:	0f 11 87 e0 00 00 00 	movups XMMWORD PTR [rdi+0xe0],xmm0
  40d711:	0f 11 40 10          	movups XMMWORD PTR [rax+0x10],xmm0
  40d715:	0f 11 40 20          	movups XMMWORD PTR [rax+0x20],xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40d719:	48 8b 77 10          	mov    rsi,QWORD PTR [rdi+0x10]
  40d71d:	4c 89 f7             	mov    rdi,r14
  40d720:	48 b8 70 17 41 00 00 	movabs rax,0x411770
  40d727:	00 00 00 
  40d72a:	ff d0                	call   rax
  40d72c:	48 89 83 e8 00 00 00 	mov    QWORD PTR [rbx+0xe8],rax
  40d733:	48 89 c6             	mov    rsi,rax
	assert(aep->thd);
  40d736:	48 85 c0             	test   rax,rax
  40d739:	0f 84 23 01 00 00    	je     40d862 <cos_initaep_tcap_alloc+0x1b2>
	aep->tid  = cos_introspect(ci, aep->thd, THD_GET_TID);
  40d73f:	48 b8 d0 3e 41 00 00 	movabs rax,0x413ed0
  40d746:	00 00 00 
  40d749:	31 d2                	xor    edx,edx
  40d74b:	4c 89 f7             	mov    rdi,r14
  40d74e:	ff d0                	call   rax
  40d750:	48 98                	cdqe   
  40d752:	48 89 83 f0 00 00 00 	mov    QWORD PTR [rbx+0xf0],rax
	if (tc) {
  40d759:	4d 85 ed             	test   r13,r13
  40d75c:	74 6a                	je     40d7c8 <cos_initaep_tcap_alloc+0x118>
		aep->tc = tc;
  40d75e:	4c 89 ab e0 00 00 00 	mov    QWORD PTR [rbx+0xe0],r13
	aep->rcv  = cos_arcv_alloc(ci, aep->thd, aep->tc, ci->comp_cap, sched->rcv);
  40d765:	48 b8 70 49 5a 00 00 	movabs rax,0x5a4970
  40d76c:	00 00 00 
  40d76f:	48 8b b3 e8 00 00 00 	mov    rsi,QWORD PTR [rbx+0xe8]
  40d776:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  40d779:	4c 89 ea             	mov    rdx,r13
  40d77c:	4d 8b 44 24 18       	mov    r8,QWORD PTR [r12+0x18]
  40d781:	4c 89 f7             	mov    rdi,r14
  40d784:	48 b8 a0 2c 41 00 00 	movabs rax,0x412ca0
  40d78b:	00 00 00 
  40d78e:	ff d0                	call   rax
  40d790:	48 89 83 f8 00 00 00 	mov    QWORD PTR [rbx+0xf8],rax
	assert(aep->rcv);
  40d797:	48 85 c0             	test   rax,rax
  40d79a:	0f 84 ea 00 00 00    	je     40d88a <cos_initaep_tcap_alloc+0x1da>
	aep->fn   = fn;
  40d7a0:	48 c7 83 00 01 00 00 	mov    QWORD PTR [rbx+0x100],0x0
  40d7a7:	00 00 00 00 

	return cos_aep_alloc_intern(child_aep, dst_dci, tc, sched_use, NULL, NULL, 0);
}
  40d7ab:	31 c0                	xor    eax,eax
	aep->data = data;
  40d7ad:	48 c7 83 08 01 00 00 	mov    QWORD PTR [rbx+0x108],0x0
  40d7b4:	00 00 00 00 
}
  40d7b8:	5b                   	pop    rbx
  40d7b9:	41 5c                	pop    r12
  40d7bb:	41 5d                	pop    r13
  40d7bd:	41 5e                	pop    r14
  40d7bf:	5d                   	pop    rbp
  40d7c0:	c3                   	ret    
  40d7c1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		aep->tc = cos_tcap_alloc(ci);
  40d7c8:	48 b8 30 3f 41 00 00 	movabs rax,0x413f30
  40d7cf:	00 00 00 
  40d7d2:	4c 89 f7             	mov    rdi,r14
  40d7d5:	ff d0                	call   rax
  40d7d7:	48 89 83 e0 00 00 00 	mov    QWORD PTR [rbx+0xe0],rax
  40d7de:	49 89 c5             	mov    r13,rax
		assert(aep->tc);
  40d7e1:	48 85 c0             	test   rax,rax
  40d7e4:	0f 85 7b ff ff ff    	jne    40d765 <cos_initaep_tcap_alloc+0xb5>
  40d7ea:	48 bf e0 ff 41 00 00 	movabs rdi,0x41ffe0
  40d7f1:	00 00 00 
  40d7f4:	be 31 00 00 00       	mov    esi,0x31
  40d7f9:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40d800:	00 00 00 
  40d803:	ff d0                	call   rax
  40d805:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d80c:	00 00 00 00 
  40d810:	0f 0b                	ud2    
  40d812:	48 bf 50 fe 41 00 00 	movabs rdi,0x41fe50
  40d819:	00 00 00 
  40d81c:	be 30 00 00 00       	mov    esi,0x30
  40d821:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40d828:	00 00 00 
  40d82b:	ff d0                	call   rax
	assert(defci);
  40d82d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d834:	00 00 00 00 
  40d838:	0f 0b                	ud2    
  40d83a:	48 bf 70 ff 41 00 00 	movabs rdi,0x41ff70
  40d841:	00 00 00 
  40d844:	be 31 00 00 00       	mov    esi,0x31
  40d849:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40d850:	00 00 00 
  40d853:	ff d0                	call   rax
	assert(curr_defci_init_status == INITIALIZED);
  40d855:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d85c:	00 00 00 00 
  40d860:	0f 0b                	ud2    
  40d862:	48 bf a8 ff 41 00 00 	movabs rdi,0x41ffa8
  40d869:	00 00 00 
  40d86c:	be 31 00 00 00       	mov    esi,0x31
  40d871:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40d878:	00 00 00 
  40d87b:	ff d0                	call   rax
	assert(aep->thd);
  40d87d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d884:	00 00 00 00 
  40d888:	0f 0b                	ud2    
  40d88a:	48 bf 18 00 42 00 00 	movabs rdi,0x420018
  40d891:	00 00 00 
  40d894:	be 31 00 00 00       	mov    esi,0x31
  40d899:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40d8a0:	00 00 00 
  40d8a3:	ff d0                	call   rax
	assert(aep->rcv);
  40d8a5:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d8ac:	00 00 00 00 
  40d8b0:	0f 0b                	ud2    
  40d8b2:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40d8b9:	00 00 00 00 
  40d8bd:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040d8c0 <cos_aep_alloc_ext>:

int
cos_aep_alloc_ext(struct cos_aep_info *aep, struct cos_defcompinfo *dst_dci, struct cos_aep_info *sched, thdclosure_index_t idx)
{
  40d8c0:	f3 0f 1e fa          	endbr64 
  40d8c4:	55                   	push   rbp
  40d8c5:	48 89 e5             	mov    rbp,rsp
  40d8c8:	41 55                	push   r13
  40d8ca:	41 54                	push   r12
  40d8cc:	53                   	push   rbx
  40d8cd:	48 83 ec 08          	sub    rsp,0x8
	struct cos_defcompinfo *defci     = cos_defcompinfo_curr_get();
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);

	assert(aep && idx > 0);
  40d8d1:	48 85 ff             	test   rdi,rdi
  40d8d4:	0f 84 29 01 00 00    	je     40da03 <cos_aep_alloc_ext+0x143>
  40d8da:	49 89 d4             	mov    r12,rdx
  40d8dd:	89 ca                	mov    edx,ecx
  40d8df:	85 c9                	test   ecx,ecx
  40d8e1:	0f 8e 1c 01 00 00    	jle    40da03 <cos_aep_alloc_ext+0x143>
  40d8e7:	48 89 fb             	mov    rbx,rdi
	if (!sched) sched_aep = cos_sched_aep_get(dst_dci);
  40d8ea:	4d 85 e4             	test   r12,r12
  40d8ed:	74 31                	je     40d920 <cos_aep_alloc_ext+0x60>
	assert(defci);
  40d8ef:	48 85 f6             	test   rsi,rsi
  40d8f2:	75 3c                	jne    40d930 <cos_aep_alloc_ext+0x70>
  40d8f4:	48 bf 18 fe 41 00 00 	movabs rdi,0x41fe18
  40d8fb:	00 00 00 
  40d8fe:	be 30 00 00 00       	mov    esi,0x30
  40d903:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40d90a:	00 00 00 
  40d90d:	ff d0                	call   rax
  40d90f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d916:	00 00 00 00 
  40d91a:	0f 0b                	ud2    
  40d91c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	return &(defci->sched_aep[cos_cpuid()]);
  40d920:	4c 8d a6 e0 00 00 00 	lea    r12,[rsi+0xe0]
	assert(defci);
  40d927:	48 85 f6             	test   rsi,rsi
  40d92a:	0f 84 80 01 00 00    	je     40dab0 <cos_aep_alloc_ext+0x1f0>
	assert(curr_defci_init_status == INITIALIZED);
  40d930:	48 b8 70 4a 5a 00 00 	movabs rax,0x5a4a70
  40d937:	00 00 00 
  40d93a:	83 38 01             	cmp    DWORD PTR [rax],0x1
  40d93d:	0f 85 ed 00 00 00    	jne    40da30 <cos_aep_alloc_ext+0x170>
	else if (idx > 0) aep->thd = cos_thd_alloc_ext(ci, dst_ci->comp_cap, idx);
  40d943:	49 bd 60 49 5a 00 00 	movabs r13,0x5a4960
  40d94a:	00 00 00 
	memset(aep, 0, sizeof(struct cos_aep_info));
  40d94d:	66 0f ef c0          	pxor   xmm0,xmm0
	else if (idx > 0) aep->thd = cos_thd_alloc_ext(ci, dst_ci->comp_cap, idx);
  40d951:	48 b8 00 09 41 00 00 	movabs rax,0x410900
  40d958:	00 00 00 
	memset(aep, 0, sizeof(struct cos_aep_info));
  40d95b:	0f 11 03             	movups XMMWORD PTR [rbx],xmm0
	else if (idx > 0) aep->thd = cos_thd_alloc_ext(ci, dst_ci->comp_cap, idx);
  40d95e:	4c 89 ef             	mov    rdi,r13
	memset(aep, 0, sizeof(struct cos_aep_info));
  40d961:	0f 11 43 10          	movups XMMWORD PTR [rbx+0x10],xmm0
  40d965:	0f 11 43 20          	movups XMMWORD PTR [rbx+0x20],xmm0
	else if (idx > 0) aep->thd = cos_thd_alloc_ext(ci, dst_ci->comp_cap, idx);
  40d969:	48 8b 76 10          	mov    rsi,QWORD PTR [rsi+0x10]
  40d96d:	ff d0                	call   rax
  40d96f:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  40d973:	48 89 c6             	mov    rsi,rax
	assert(aep->thd);
  40d976:	48 85 c0             	test   rax,rax
  40d979:	0f 84 e1 00 00 00    	je     40da60 <cos_aep_alloc_ext+0x1a0>
	aep->tid  = cos_introspect(ci, aep->thd, THD_GET_TID);
  40d97f:	48 b8 d0 3e 41 00 00 	movabs rax,0x413ed0
  40d986:	00 00 00 
  40d989:	31 d2                	xor    edx,edx
  40d98b:	4c 89 ef             	mov    rdi,r13
  40d98e:	ff d0                	call   rax
		aep->tc = cos_tcap_alloc(ci);
  40d990:	4c 89 ef             	mov    rdi,r13
	aep->tid  = cos_introspect(ci, aep->thd, THD_GET_TID);
  40d993:	48 98                	cdqe   
  40d995:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
		aep->tc = cos_tcap_alloc(ci);
  40d999:	48 b8 30 3f 41 00 00 	movabs rax,0x413f30
  40d9a0:	00 00 00 
  40d9a3:	ff d0                	call   rax
  40d9a5:	48 89 03             	mov    QWORD PTR [rbx],rax
  40d9a8:	48 89 c2             	mov    rdx,rax
		assert(aep->tc);
  40d9ab:	48 85 c0             	test   rax,rax
  40d9ae:	0f 84 d4 00 00 00    	je     40da88 <cos_aep_alloc_ext+0x1c8>
	aep->rcv  = cos_arcv_alloc(ci, aep->thd, aep->tc, ci->comp_cap, sched->rcv);
  40d9b4:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
  40d9b8:	4d 8b 44 24 18       	mov    r8,QWORD PTR [r12+0x18]
  40d9bd:	4c 89 ef             	mov    rdi,r13
  40d9c0:	48 b8 70 49 5a 00 00 	movabs rax,0x5a4970
  40d9c7:	00 00 00 
  40d9ca:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  40d9cd:	48 b8 a0 2c 41 00 00 	movabs rax,0x412ca0
  40d9d4:	00 00 00 
  40d9d7:	ff d0                	call   rax
  40d9d9:	48 89 43 18          	mov    QWORD PTR [rbx+0x18],rax
	assert(aep->rcv);
  40d9dd:	48 85 c0             	test   rax,rax
  40d9e0:	0f 84 f2 00 00 00    	je     40dad8 <cos_aep_alloc_ext+0x218>
	aep->fn   = fn;
  40d9e6:	48 c7 43 20 00 00 00 	mov    QWORD PTR [rbx+0x20],0x0
  40d9ed:	00 
	else        sched_aep = sched;

	return cos_aep_alloc_intern(aep, dst_dci, 0, sched_aep, NULL, NULL, idx);
}
  40d9ee:	31 c0                	xor    eax,eax
	aep->data = data;
  40d9f0:	48 c7 43 28 00 00 00 	mov    QWORD PTR [rbx+0x28],0x0
  40d9f7:	00 
}
  40d9f8:	48 83 c4 08          	add    rsp,0x8
  40d9fc:	5b                   	pop    rbx
  40d9fd:	41 5c                	pop    r12
  40d9ff:	41 5d                	pop    r13
  40da01:	5d                   	pop    rbp
  40da02:	c3                   	ret    
  40da03:	48 bf 88 00 42 00 00 	movabs rdi,0x420088
  40da0a:	00 00 00 
  40da0d:	be 31 00 00 00       	mov    esi,0x31
  40da12:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40da19:	00 00 00 
  40da1c:	ff d0                	call   rax
	assert(aep && idx > 0);
  40da1e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40da25:	00 00 00 00 
  40da29:	0f 0b                	ud2    
  40da2b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40da30:	48 bf 70 ff 41 00 00 	movabs rdi,0x41ff70
  40da37:	00 00 00 
  40da3a:	be 31 00 00 00       	mov    esi,0x31
  40da3f:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40da46:	00 00 00 
  40da49:	ff d0                	call   rax
	assert(curr_defci_init_status == INITIALIZED);
  40da4b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40da52:	00 00 00 00 
  40da56:	0f 0b                	ud2    
  40da58:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40da5f:	00 
  40da60:	48 bf a8 ff 41 00 00 	movabs rdi,0x41ffa8
  40da67:	00 00 00 
  40da6a:	be 31 00 00 00       	mov    esi,0x31
  40da6f:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40da76:	00 00 00 
  40da79:	ff d0                	call   rax
	assert(aep->thd);
  40da7b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40da82:	00 00 00 00 
  40da86:	0f 0b                	ud2    
  40da88:	48 bf e0 ff 41 00 00 	movabs rdi,0x41ffe0
  40da8f:	00 00 00 
  40da92:	be 31 00 00 00       	mov    esi,0x31
  40da97:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40da9e:	00 00 00 
  40daa1:	ff d0                	call   rax
		assert(aep->tc);
  40daa3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40daaa:	00 00 00 00 
  40daae:	0f 0b                	ud2    
  40dab0:	48 bf 50 fe 41 00 00 	movabs rdi,0x41fe50
  40dab7:	00 00 00 
  40daba:	be 30 00 00 00       	mov    esi,0x30
  40dabf:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40dac6:	00 00 00 
  40dac9:	ff d0                	call   rax
	assert(defci);
  40dacb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40dad2:	00 00 00 00 
  40dad6:	0f 0b                	ud2    
  40dad8:	48 bf 18 00 42 00 00 	movabs rdi,0x420018
  40dadf:	00 00 00 
  40dae2:	be 31 00 00 00       	mov    esi,0x31
  40dae7:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40daee:	00 00 00 
  40daf1:	ff d0                	call   rax
	assert(aep->rcv);
  40daf3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40dafa:	00 00 00 00 
  40dafe:	0f 0b                	ud2    

000000000040db00 <cos_aep_tcap_alloc_ext>:

int
cos_aep_tcap_alloc_ext(struct cos_aep_info *aep, struct cos_defcompinfo *dst_dci, struct cos_aep_info *sched, tcap_t tc, thdclosure_index_t idx)
{
  40db00:	f3 0f 1e fa          	endbr64 
  40db04:	55                   	push   rbp
  40db05:	48 89 e5             	mov    rbp,rsp
  40db08:	41 56                	push   r14
  40db0a:	41 55                	push   r13
  40db0c:	41 54                	push   r12
  40db0e:	53                   	push   rbx
	struct cos_defcompinfo *defci     = cos_defcompinfo_curr_get();
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);

	assert(aep);
  40db0f:	48 85 ff             	test   rdi,rdi
  40db12:	0f 84 6e 01 00 00    	je     40dc86 <cos_aep_tcap_alloc_ext+0x186>
	assert(idx > 0);
  40db18:	45 85 c0             	test   r8d,r8d
  40db1b:	0f 8e 8d 01 00 00    	jle    40dcae <cos_aep_tcap_alloc_ext+0x1ae>
  40db21:	48 89 fb             	mov    rbx,rdi
  40db24:	49 89 d5             	mov    r13,rdx
  40db27:	49 89 cc             	mov    r12,rcx
	if (!sched) sched_aep = cos_sched_aep_get(dst_dci);
  40db2a:	48 85 d2             	test   rdx,rdx
  40db2d:	0f 84 cd 00 00 00    	je     40dc00 <cos_aep_tcap_alloc_ext+0x100>
	assert(defci);
  40db33:	48 85 f6             	test   rsi,rsi
  40db36:	0f 84 9a 01 00 00    	je     40dcd6 <cos_aep_tcap_alloc_ext+0x1d6>
	assert(curr_defci_init_status == INITIALIZED);
  40db3c:	48 b8 70 4a 5a 00 00 	movabs rax,0x5a4a70
  40db43:	00 00 00 
  40db46:	83 38 01             	cmp    DWORD PTR [rax],0x1
  40db49:	0f 85 af 01 00 00    	jne    40dcfe <cos_aep_tcap_alloc_ext+0x1fe>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40db4f:	66 0f ef c0          	pxor   xmm0,xmm0
	else if (idx > 0) aep->thd = cos_thd_alloc_ext(ci, dst_ci->comp_cap, idx);
  40db53:	44 89 c2             	mov    edx,r8d
  40db56:	49 be 60 49 5a 00 00 	movabs r14,0x5a4960
  40db5d:	00 00 00 
  40db60:	48 b8 00 09 41 00 00 	movabs rax,0x410900
  40db67:	00 00 00 
	memset(aep, 0, sizeof(struct cos_aep_info));
  40db6a:	0f 11 03             	movups XMMWORD PTR [rbx],xmm0
	else if (idx > 0) aep->thd = cos_thd_alloc_ext(ci, dst_ci->comp_cap, idx);
  40db6d:	4c 89 f7             	mov    rdi,r14
	memset(aep, 0, sizeof(struct cos_aep_info));
  40db70:	0f 11 43 10          	movups XMMWORD PTR [rbx+0x10],xmm0
  40db74:	0f 11 43 20          	movups XMMWORD PTR [rbx+0x20],xmm0
	else if (idx > 0) aep->thd = cos_thd_alloc_ext(ci, dst_ci->comp_cap, idx);
  40db78:	48 8b 76 10          	mov    rsi,QWORD PTR [rsi+0x10]
  40db7c:	ff d0                	call   rax
  40db7e:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  40db82:	48 89 c6             	mov    rsi,rax
	assert(aep->thd);
  40db85:	48 85 c0             	test   rax,rax
  40db88:	0f 84 98 01 00 00    	je     40dd26 <cos_aep_tcap_alloc_ext+0x226>
	aep->tid  = cos_introspect(ci, aep->thd, THD_GET_TID);
  40db8e:	48 b8 d0 3e 41 00 00 	movabs rax,0x413ed0
  40db95:	00 00 00 
  40db98:	31 d2                	xor    edx,edx
  40db9a:	4c 89 f7             	mov    rdi,r14
  40db9d:	ff d0                	call   rax
  40db9f:	48 98                	cdqe   
  40dba1:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
	if (tc) {
  40dba5:	4d 85 e4             	test   r12,r12
  40dba8:	0f 84 92 00 00 00    	je     40dc40 <cos_aep_tcap_alloc_ext+0x140>
		aep->tc = tc;
  40dbae:	4c 89 23             	mov    QWORD PTR [rbx],r12
	aep->rcv  = cos_arcv_alloc(ci, aep->thd, aep->tc, ci->comp_cap, sched->rcv);
  40dbb1:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
  40dbb5:	4d 8b 45 18          	mov    r8,QWORD PTR [r13+0x18]
  40dbb9:	4c 89 e2             	mov    rdx,r12
  40dbbc:	4c 89 f7             	mov    rdi,r14
  40dbbf:	48 b8 70 49 5a 00 00 	movabs rax,0x5a4970
  40dbc6:	00 00 00 
  40dbc9:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  40dbcc:	48 b8 a0 2c 41 00 00 	movabs rax,0x412ca0
  40dbd3:	00 00 00 
  40dbd6:	ff d0                	call   rax
  40dbd8:	48 89 43 18          	mov    QWORD PTR [rbx+0x18],rax
	assert(aep->rcv);
  40dbdc:	48 85 c0             	test   rax,rax
  40dbdf:	0f 84 69 01 00 00    	je     40dd4e <cos_aep_tcap_alloc_ext+0x24e>
	aep->fn   = fn;
  40dbe5:	48 c7 43 20 00 00 00 	mov    QWORD PTR [rbx+0x20],0x0
  40dbec:	00 
	else        sched_aep = sched;

	return cos_aep_alloc_intern(aep, dst_dci, tc, sched_aep, NULL, NULL, idx);
}
  40dbed:	31 c0                	xor    eax,eax
	aep->data = data;
  40dbef:	48 c7 43 28 00 00 00 	mov    QWORD PTR [rbx+0x28],0x0
  40dbf6:	00 
}
  40dbf7:	5b                   	pop    rbx
  40dbf8:	41 5c                	pop    r12
  40dbfa:	41 5d                	pop    r13
  40dbfc:	41 5e                	pop    r14
  40dbfe:	5d                   	pop    rbp
  40dbff:	c3                   	ret    
	return &(defci->sched_aep[cos_cpuid()]);
  40dc00:	4c 8d ae e0 00 00 00 	lea    r13,[rsi+0xe0]
	assert(defci);
  40dc07:	48 85 f6             	test   rsi,rsi
  40dc0a:	0f 85 2c ff ff ff    	jne    40db3c <cos_aep_tcap_alloc_ext+0x3c>
  40dc10:	48 bf 50 fe 41 00 00 	movabs rdi,0x41fe50
  40dc17:	00 00 00 
  40dc1a:	be 30 00 00 00       	mov    esi,0x30
  40dc1f:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40dc26:	00 00 00 
  40dc29:	ff d0                	call   rax
  40dc2b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40dc32:	00 00 00 00 
  40dc36:	0f 0b                	ud2    
  40dc38:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40dc3f:	00 
		aep->tc = cos_tcap_alloc(ci);
  40dc40:	48 b8 30 3f 41 00 00 	movabs rax,0x413f30
  40dc47:	00 00 00 
  40dc4a:	4c 89 f7             	mov    rdi,r14
  40dc4d:	ff d0                	call   rax
  40dc4f:	48 89 03             	mov    QWORD PTR [rbx],rax
  40dc52:	49 89 c4             	mov    r12,rax
		assert(aep->tc);
  40dc55:	48 85 c0             	test   rax,rax
  40dc58:	0f 85 53 ff ff ff    	jne    40dbb1 <cos_aep_tcap_alloc_ext+0xb1>
  40dc5e:	48 bf e0 ff 41 00 00 	movabs rdi,0x41ffe0
  40dc65:	00 00 00 
  40dc68:	be 31 00 00 00       	mov    esi,0x31
  40dc6d:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40dc74:	00 00 00 
  40dc77:	ff d0                	call   rax
  40dc79:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40dc80:	00 00 00 00 
  40dc84:	0f 0b                	ud2    
  40dc86:	48 bf c0 00 42 00 00 	movabs rdi,0x4200c0
  40dc8d:	00 00 00 
  40dc90:	be 31 00 00 00       	mov    esi,0x31
  40dc95:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40dc9c:	00 00 00 
  40dc9f:	ff d0                	call   rax
	assert(aep);
  40dca1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40dca8:	00 00 00 00 
  40dcac:	0f 0b                	ud2    
  40dcae:	48 bf f8 00 42 00 00 	movabs rdi,0x4200f8
  40dcb5:	00 00 00 
  40dcb8:	be 31 00 00 00       	mov    esi,0x31
  40dcbd:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40dcc4:	00 00 00 
  40dcc7:	ff d0                	call   rax
	assert(idx > 0);
  40dcc9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40dcd0:	00 00 00 00 
  40dcd4:	0f 0b                	ud2    
  40dcd6:	48 bf 18 fe 41 00 00 	movabs rdi,0x41fe18
  40dcdd:	00 00 00 
  40dce0:	be 30 00 00 00       	mov    esi,0x30
  40dce5:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40dcec:	00 00 00 
  40dcef:	ff d0                	call   rax
	assert(defci);
  40dcf1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40dcf8:	00 00 00 00 
  40dcfc:	0f 0b                	ud2    
  40dcfe:	48 bf 70 ff 41 00 00 	movabs rdi,0x41ff70
  40dd05:	00 00 00 
  40dd08:	be 31 00 00 00       	mov    esi,0x31
  40dd0d:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40dd14:	00 00 00 
  40dd17:	ff d0                	call   rax
	assert(curr_defci_init_status == INITIALIZED);
  40dd19:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40dd20:	00 00 00 00 
  40dd24:	0f 0b                	ud2    
  40dd26:	48 bf a8 ff 41 00 00 	movabs rdi,0x41ffa8
  40dd2d:	00 00 00 
  40dd30:	be 31 00 00 00       	mov    esi,0x31
  40dd35:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40dd3c:	00 00 00 
  40dd3f:	ff d0                	call   rax
	assert(aep->thd);
  40dd41:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40dd48:	00 00 00 00 
  40dd4c:	0f 0b                	ud2    
  40dd4e:	48 bf 18 00 42 00 00 	movabs rdi,0x420018
  40dd55:	00 00 00 
  40dd58:	be 31 00 00 00       	mov    esi,0x31
  40dd5d:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40dd64:	00 00 00 
  40dd67:	ff d0                	call   rax
	assert(aep->rcv);
  40dd69:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40dd70:	00 00 00 00 
  40dd74:	0f 0b                	ud2    
  40dd76:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40dd7d:	00 00 00 

000000000040dd80 <cos_aep_alloc>:

int
cos_aep_alloc(struct cos_aep_info *aep, cos_aepthd_fn_t fn, void *data)
{
  40dd80:	f3 0f 1e fa          	endbr64 
	assert(curr_defci_init_status == INITIALIZED);
  40dd84:	a1 70 4a 5a 00 00 00 	movabs eax,ds:0x5a4a70
  40dd8b:	00 00 
{
  40dd8d:	55                   	push   rbp
	int                     is_init = (!fn && !data && !idx);
  40dd8e:	48 89 d1             	mov    rcx,rdx
  40dd91:	48 09 f1             	or     rcx,rsi
{
  40dd94:	48 89 e5             	mov    rbp,rsp
  40dd97:	41 56                	push   r14
  40dd99:	41 55                	push   r13
  40dd9b:	49 89 d5             	mov    r13,rdx
  40dd9e:	41 54                	push   r12
  40dda0:	49 89 f4             	mov    r12,rsi
  40dda3:	53                   	push   rbx
  40dda4:	48 89 fb             	mov    rbx,rdi
	int                     is_init = (!fn && !data && !idx);
  40dda7:	0f 85 c3 00 00 00    	jne    40de70 <cos_aep_alloc+0xf0>
	assert(curr_defci_init_status == INITIALIZED);
  40ddad:	83 f8 01             	cmp    eax,0x1
  40ddb0:	0f 85 0a 01 00 00    	jne    40dec0 <cos_aep_alloc+0x140>
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40ddb6:	49 be 60 49 5a 00 00 	movabs r14,0x5a4960
  40ddbd:	00 00 00 
	memset(aep, 0, sizeof(struct cos_aep_info));
  40ddc0:	66 0f ef c0          	pxor   xmm0,xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40ddc4:	48 b8 70 17 41 00 00 	movabs rax,0x411770
  40ddcb:	00 00 00 
	memset(aep, 0, sizeof(struct cos_aep_info));
  40ddce:	0f 11 03             	movups XMMWORD PTR [rbx],xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40ddd1:	4c 89 f7             	mov    rdi,r14
	memset(aep, 0, sizeof(struct cos_aep_info));
  40ddd4:	0f 11 43 10          	movups XMMWORD PTR [rbx+0x10],xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40ddd8:	49 8b 76 10          	mov    rsi,QWORD PTR [r14+0x10]
	memset(aep, 0, sizeof(struct cos_aep_info));
  40dddc:	0f 11 43 20          	movups XMMWORD PTR [rbx+0x20],xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40dde0:	ff d0                	call   rax
  40dde2:	48 89 c6             	mov    rsi,rax
  40dde5:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
	assert(aep->thd);
  40dde9:	48 85 f6             	test   rsi,rsi
  40ddec:	0f 84 f6 00 00 00    	je     40dee8 <cos_aep_alloc+0x168>
	aep->tid  = cos_introspect(ci, aep->thd, THD_GET_TID);
  40ddf2:	48 b8 d0 3e 41 00 00 	movabs rax,0x413ed0
  40ddf9:	00 00 00 
  40ddfc:	31 d2                	xor    edx,edx
  40ddfe:	4c 89 f7             	mov    rdi,r14
  40de01:	ff d0                	call   rax
		aep->tc = cos_tcap_alloc(ci);
  40de03:	4c 89 f7             	mov    rdi,r14
	aep->tid  = cos_introspect(ci, aep->thd, THD_GET_TID);
  40de06:	48 98                	cdqe   
  40de08:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
		aep->tc = cos_tcap_alloc(ci);
  40de0c:	48 b8 30 3f 41 00 00 	movabs rax,0x413f30
  40de13:	00 00 00 
  40de16:	ff d0                	call   rax
  40de18:	48 89 03             	mov    QWORD PTR [rbx],rax
  40de1b:	48 89 c2             	mov    rdx,rax
		assert(aep->tc);
  40de1e:	48 85 c0             	test   rax,rax
  40de21:	0f 84 e9 00 00 00    	je     40df10 <cos_aep_alloc+0x190>
	aep->rcv  = cos_arcv_alloc(ci, aep->thd, aep->tc, ci->comp_cap, sched->rcv);
  40de27:	48 b8 58 4a 5a 00 00 	movabs rax,0x5a4a58
  40de2e:	00 00 00 
  40de31:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
  40de35:	4c 8b 00             	mov    r8,QWORD PTR [rax]
  40de38:	4c 89 f7             	mov    rdi,r14
  40de3b:	48 8b 88 18 ff ff ff 	mov    rcx,QWORD PTR [rax-0xe8]
  40de42:	48 b8 a0 2c 41 00 00 	movabs rax,0x412ca0
  40de49:	00 00 00 
  40de4c:	ff d0                	call   rax
  40de4e:	48 89 43 18          	mov    QWORD PTR [rbx+0x18],rax
	assert(aep->rcv);
  40de52:	48 85 c0             	test   rax,rax
  40de55:	0f 84 dd 00 00 00    	je     40df38 <cos_aep_alloc+0x1b8>
	aep->fn   = fn;
  40de5b:	4c 89 63 20          	mov    QWORD PTR [rbx+0x20],r12
	struct cos_defcompinfo *defci     = cos_defcompinfo_curr_get();
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);

	return cos_aep_alloc_intern(aep, defci, 0, sched_aep, fn, data, 0);
}
  40de5f:	31 c0                	xor    eax,eax
	aep->data = data;
  40de61:	4c 89 6b 28          	mov    QWORD PTR [rbx+0x28],r13
}
  40de65:	5b                   	pop    rbx
  40de66:	41 5c                	pop    r12
  40de68:	41 5d                	pop    r13
  40de6a:	41 5e                	pop    r14
  40de6c:	5d                   	pop    rbp
  40de6d:	c3                   	ret    
  40de6e:	66 90                	xchg   ax,ax
	assert(curr_defci_init_status == INITIALIZED);
  40de70:	83 f8 01             	cmp    eax,0x1
  40de73:	75 4b                	jne    40dec0 <cos_aep_alloc+0x140>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40de75:	66 0f ef c0          	pxor   xmm0,xmm0
	else              aep->thd = cos_thd_alloc(ci, dst_ci->comp_cap, cos_aepthd_fn, (void *)aep);
  40de79:	48 89 d9             	mov    rcx,rbx
  40de7c:	49 be 60 49 5a 00 00 	movabs r14,0x5a4960
  40de83:	00 00 00 
  40de86:	48 ba d0 cd 40 00 00 	movabs rdx,0x40cdd0
  40de8d:	00 00 00 
	memset(aep, 0, sizeof(struct cos_aep_info));
  40de90:	0f 11 03             	movups XMMWORD PTR [rbx],xmm0
	else              aep->thd = cos_thd_alloc(ci, dst_ci->comp_cap, cos_aepthd_fn, (void *)aep);
  40de93:	4c 89 f7             	mov    rdi,r14
  40de96:	48 b8 40 09 41 00 00 	movabs rax,0x410940
  40de9d:	00 00 00 
	memset(aep, 0, sizeof(struct cos_aep_info));
  40dea0:	0f 11 43 10          	movups XMMWORD PTR [rbx+0x10],xmm0
	else              aep->thd = cos_thd_alloc(ci, dst_ci->comp_cap, cos_aepthd_fn, (void *)aep);
  40dea4:	49 8b 76 10          	mov    rsi,QWORD PTR [r14+0x10]
	memset(aep, 0, sizeof(struct cos_aep_info));
  40dea8:	0f 11 43 20          	movups XMMWORD PTR [rbx+0x20],xmm0
	else              aep->thd = cos_thd_alloc(ci, dst_ci->comp_cap, cos_aepthd_fn, (void *)aep);
  40deac:	ff d0                	call   rax
  40deae:	48 89 c6             	mov    rsi,rax
  40deb1:	e9 2f ff ff ff       	jmp    40dde5 <cos_aep_alloc+0x65>
  40deb6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40debd:	00 00 00 
  40dec0:	48 bf 70 ff 41 00 00 	movabs rdi,0x41ff70
  40dec7:	00 00 00 
  40deca:	be 31 00 00 00       	mov    esi,0x31
  40decf:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40ded6:	00 00 00 
  40ded9:	ff d0                	call   rax
	assert(curr_defci_init_status == INITIALIZED);
  40dedb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40dee2:	00 00 00 00 
  40dee6:	0f 0b                	ud2    
  40dee8:	48 bf a8 ff 41 00 00 	movabs rdi,0x41ffa8
  40deef:	00 00 00 
  40def2:	be 31 00 00 00       	mov    esi,0x31
  40def7:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40defe:	00 00 00 
  40df01:	ff d0                	call   rax
	assert(aep->thd);
  40df03:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40df0a:	00 00 00 00 
  40df0e:	0f 0b                	ud2    
  40df10:	48 bf e0 ff 41 00 00 	movabs rdi,0x41ffe0
  40df17:	00 00 00 
  40df1a:	be 31 00 00 00       	mov    esi,0x31
  40df1f:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40df26:	00 00 00 
  40df29:	ff d0                	call   rax
		assert(aep->tc);
  40df2b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40df32:	00 00 00 00 
  40df36:	0f 0b                	ud2    
  40df38:	48 bf 18 00 42 00 00 	movabs rdi,0x420018
  40df3f:	00 00 00 
  40df42:	be 31 00 00 00       	mov    esi,0x31
  40df47:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40df4e:	00 00 00 
  40df51:	ff d0                	call   rax
	assert(aep->rcv);
  40df53:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40df5a:	00 00 00 00 
  40df5e:	0f 0b                	ud2    

000000000040df60 <cos_aep_tcap_alloc>:

int
cos_aep_tcap_alloc(struct cos_aep_info *aep, tcap_t tc, cos_aepthd_fn_t fn, void *data)
{
  40df60:	f3 0f 1e fa          	endbr64 
  40df64:	55                   	push   rbp
  40df65:	48 89 e5             	mov    rbp,rsp
  40df68:	41 57                	push   r15
  40df6a:	41 56                	push   r14
  40df6c:	49 89 ce             	mov    r14,rcx
  40df6f:	41 55                	push   r13
  40df71:	49 89 d5             	mov    r13,rdx
  40df74:	41 54                	push   r12
  40df76:	49 89 f4             	mov    r12,rsi
  40df79:	53                   	push   rbx
  40df7a:	48 89 fb             	mov    rbx,rdi
  40df7d:	48 83 ec 08          	sub    rsp,0x8
	int                     is_init = (!fn && !data && !idx);
  40df81:	48 09 d1             	or     rcx,rdx
	assert(curr_defci_init_status == INITIALIZED);
  40df84:	a1 70 4a 5a 00 00 00 	movabs eax,ds:0x5a4a70
  40df8b:	00 00 
	int                     is_init = (!fn && !data && !idx);
  40df8d:	0f 85 bd 00 00 00    	jne    40e050 <cos_aep_tcap_alloc+0xf0>
	assert(curr_defci_init_status == INITIALIZED);
  40df93:	83 f8 01             	cmp    eax,0x1
  40df96:	0f 85 04 01 00 00    	jne    40e0a0 <cos_aep_tcap_alloc+0x140>
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40df9c:	49 bf 60 49 5a 00 00 	movabs r15,0x5a4960
  40dfa3:	00 00 00 
	memset(aep, 0, sizeof(struct cos_aep_info));
  40dfa6:	66 0f ef c0          	pxor   xmm0,xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40dfaa:	48 b8 70 17 41 00 00 	movabs rax,0x411770
  40dfb1:	00 00 00 
	memset(aep, 0, sizeof(struct cos_aep_info));
  40dfb4:	0f 11 03             	movups XMMWORD PTR [rbx],xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40dfb7:	4c 89 ff             	mov    rdi,r15
	memset(aep, 0, sizeof(struct cos_aep_info));
  40dfba:	0f 11 43 10          	movups XMMWORD PTR [rbx+0x10],xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40dfbe:	49 8b 77 10          	mov    rsi,QWORD PTR [r15+0x10]
	memset(aep, 0, sizeof(struct cos_aep_info));
  40dfc2:	0f 11 43 20          	movups XMMWORD PTR [rbx+0x20],xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40dfc6:	ff d0                	call   rax
  40dfc8:	48 89 c6             	mov    rsi,rax
  40dfcb:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
	assert(aep->thd);
  40dfcf:	48 85 f6             	test   rsi,rsi
  40dfd2:	0f 84 3e 01 00 00    	je     40e116 <cos_aep_tcap_alloc+0x1b6>
	aep->tid  = cos_introspect(ci, aep->thd, THD_GET_TID);
  40dfd8:	48 b8 d0 3e 41 00 00 	movabs rax,0x413ed0
  40dfdf:	00 00 00 
  40dfe2:	31 d2                	xor    edx,edx
  40dfe4:	4c 89 ff             	mov    rdi,r15
  40dfe7:	ff d0                	call   rax
  40dfe9:	48 98                	cdqe   
  40dfeb:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
	if (tc) {
  40dfef:	4d 85 e4             	test   r12,r12
  40dff2:	0f 84 d8 00 00 00    	je     40e0d0 <cos_aep_tcap_alloc+0x170>
		aep->tc = tc;
  40dff8:	4c 89 23             	mov    QWORD PTR [rbx],r12
	aep->rcv  = cos_arcv_alloc(ci, aep->thd, aep->tc, ci->comp_cap, sched->rcv);
  40dffb:	48 b8 58 4a 5a 00 00 	movabs rax,0x5a4a58
  40e002:	00 00 00 
  40e005:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
  40e009:	4c 8b 00             	mov    r8,QWORD PTR [rax]
  40e00c:	4c 89 e2             	mov    rdx,r12
  40e00f:	48 8b 88 18 ff ff ff 	mov    rcx,QWORD PTR [rax-0xe8]
  40e016:	4c 89 ff             	mov    rdi,r15
  40e019:	48 b8 a0 2c 41 00 00 	movabs rax,0x412ca0
  40e020:	00 00 00 
  40e023:	ff d0                	call   rax
  40e025:	48 89 43 18          	mov    QWORD PTR [rbx+0x18],rax
	assert(aep->rcv);
  40e029:	48 85 c0             	test   rax,rax
  40e02c:	0f 84 0c 01 00 00    	je     40e13e <cos_aep_tcap_alloc+0x1de>
	aep->fn   = fn;
  40e032:	4c 89 6b 20          	mov    QWORD PTR [rbx+0x20],r13
	struct cos_defcompinfo *defci     = cos_defcompinfo_curr_get();
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);

	return cos_aep_alloc_intern(aep, defci, tc, sched_aep, fn, data, 0);
}
  40e036:	31 c0                	xor    eax,eax
	aep->data = data;
  40e038:	4c 89 73 28          	mov    QWORD PTR [rbx+0x28],r14
}
  40e03c:	48 83 c4 08          	add    rsp,0x8
  40e040:	5b                   	pop    rbx
  40e041:	41 5c                	pop    r12
  40e043:	41 5d                	pop    r13
  40e045:	41 5e                	pop    r14
  40e047:	41 5f                	pop    r15
  40e049:	5d                   	pop    rbp
  40e04a:	c3                   	ret    
  40e04b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	assert(curr_defci_init_status == INITIALIZED);
  40e050:	83 f8 01             	cmp    eax,0x1
  40e053:	75 4b                	jne    40e0a0 <cos_aep_tcap_alloc+0x140>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40e055:	66 0f ef c0          	pxor   xmm0,xmm0
	else              aep->thd = cos_thd_alloc(ci, dst_ci->comp_cap, cos_aepthd_fn, (void *)aep);
  40e059:	48 89 d9             	mov    rcx,rbx
  40e05c:	49 bf 60 49 5a 00 00 	movabs r15,0x5a4960
  40e063:	00 00 00 
  40e066:	48 ba d0 cd 40 00 00 	movabs rdx,0x40cdd0
  40e06d:	00 00 00 
	memset(aep, 0, sizeof(struct cos_aep_info));
  40e070:	0f 11 03             	movups XMMWORD PTR [rbx],xmm0
	else              aep->thd = cos_thd_alloc(ci, dst_ci->comp_cap, cos_aepthd_fn, (void *)aep);
  40e073:	4c 89 ff             	mov    rdi,r15
  40e076:	48 b8 40 09 41 00 00 	movabs rax,0x410940
  40e07d:	00 00 00 
	memset(aep, 0, sizeof(struct cos_aep_info));
  40e080:	0f 11 43 10          	movups XMMWORD PTR [rbx+0x10],xmm0
	else              aep->thd = cos_thd_alloc(ci, dst_ci->comp_cap, cos_aepthd_fn, (void *)aep);
  40e084:	49 8b 77 10          	mov    rsi,QWORD PTR [r15+0x10]
	memset(aep, 0, sizeof(struct cos_aep_info));
  40e088:	0f 11 43 20          	movups XMMWORD PTR [rbx+0x20],xmm0
	else              aep->thd = cos_thd_alloc(ci, dst_ci->comp_cap, cos_aepthd_fn, (void *)aep);
  40e08c:	ff d0                	call   rax
  40e08e:	48 89 c6             	mov    rsi,rax
  40e091:	e9 35 ff ff ff       	jmp    40dfcb <cos_aep_tcap_alloc+0x6b>
  40e096:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40e09d:	00 00 00 
  40e0a0:	48 bf 70 ff 41 00 00 	movabs rdi,0x41ff70
  40e0a7:	00 00 00 
  40e0aa:	be 31 00 00 00       	mov    esi,0x31
  40e0af:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40e0b6:	00 00 00 
  40e0b9:	ff d0                	call   rax
	assert(curr_defci_init_status == INITIALIZED);
  40e0bb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e0c2:	00 00 00 00 
  40e0c6:	0f 0b                	ud2    
  40e0c8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40e0cf:	00 
		aep->tc = cos_tcap_alloc(ci);
  40e0d0:	48 b8 30 3f 41 00 00 	movabs rax,0x413f30
  40e0d7:	00 00 00 
  40e0da:	4c 89 ff             	mov    rdi,r15
  40e0dd:	ff d0                	call   rax
  40e0df:	48 89 03             	mov    QWORD PTR [rbx],rax
  40e0e2:	49 89 c4             	mov    r12,rax
		assert(aep->tc);
  40e0e5:	48 85 c0             	test   rax,rax
  40e0e8:	0f 85 0d ff ff ff    	jne    40dffb <cos_aep_tcap_alloc+0x9b>
  40e0ee:	48 bf e0 ff 41 00 00 	movabs rdi,0x41ffe0
  40e0f5:	00 00 00 
  40e0f8:	be 31 00 00 00       	mov    esi,0x31
  40e0fd:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40e104:	00 00 00 
  40e107:	ff d0                	call   rax
  40e109:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e110:	00 00 00 00 
  40e114:	0f 0b                	ud2    
  40e116:	48 bf a8 ff 41 00 00 	movabs rdi,0x41ffa8
  40e11d:	00 00 00 
  40e120:	be 31 00 00 00       	mov    esi,0x31
  40e125:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40e12c:	00 00 00 
  40e12f:	ff d0                	call   rax
	assert(aep->thd);
  40e131:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e138:	00 00 00 00 
  40e13c:	0f 0b                	ud2    
  40e13e:	48 bf 18 00 42 00 00 	movabs rdi,0x420018
  40e145:	00 00 00 
  40e148:	be 31 00 00 00       	mov    esi,0x31
  40e14d:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40e154:	00 00 00 
  40e157:	ff d0                	call   rax
	assert(aep->rcv);
  40e159:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e160:	00 00 00 00 
  40e164:	0f 0b                	ud2    
  40e166:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40e16d:	00 00 00 

000000000040e170 <cos_defswitch>:

int
cos_defswitch(thdcap_t c, tcap_prio_t p, tcap_time_t r, sched_tok_t stok)
{
  40e170:	f3 0f 1e fa          	endbr64 
	struct cos_defcompinfo *defci     = cos_defcompinfo_curr_get();
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);

	assert(curr_defci_init_status == INITIALIZED);
  40e174:	48 b8 70 4a 5a 00 00 	movabs rax,0x5a4a70
  40e17b:	00 00 00 
  40e17e:	83 38 01             	cmp    DWORD PTR [rax],0x1
  40e181:	75 26                	jne    40e1a9 <cos_defswitch+0x39>

	return cos_switch(c, sched_aep->tc, p, r, sched_aep->rcv, stok);
  40e183:	48 b8 58 4a 5a 00 00 	movabs rax,0x5a4a58
  40e18a:	00 00 00 
  40e18d:	41 89 c9             	mov    r9d,ecx
  40e190:	4c 8b 00             	mov    r8,QWORD PTR [rax]
  40e193:	48 89 d1             	mov    rcx,rdx
  40e196:	48 89 f2             	mov    rdx,rsi
  40e199:	48 8b 70 e8          	mov    rsi,QWORD PTR [rax-0x18]
  40e19d:	48 b8 f0 35 41 00 00 	movabs rax,0x4135f0
  40e1a4:	00 00 00 
  40e1a7:	ff e0                	jmp    rax
  40e1a9:	48 bf 30 01 42 00 00 	movabs rdi,0x420130
  40e1b0:	00 00 00 
{
  40e1b3:	55                   	push   rbp
  40e1b4:	be 31 00 00 00       	mov    esi,0x31
  40e1b9:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40e1c0:	00 00 00 
  40e1c3:	48 89 e5             	mov    rbp,rsp
  40e1c6:	ff d0                	call   rax
	assert(curr_defci_init_status == INITIALIZED);
  40e1c8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e1cf:	00 00 00 00 
  40e1d3:	0f 0b                	ud2    
  40e1d5:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40e1dc:	00 00 00 
  40e1df:	90                   	nop

000000000040e1e0 <printc.constprop.0>:
printc(char *fmt, ...)
  40e1e0:	f3 0f 1e fa          	endbr64 
  40e1e4:	55                   	push   rbp
  40e1e5:	48 89 e5             	mov    rbp,rsp
  40e1e8:	48 81 ec 90 01 00 00 	sub    rsp,0x190
  40e1ef:	48 89 b5 58 ff ff ff 	mov    QWORD PTR [rbp-0xa8],rsi
  40e1f6:	48 89 95 60 ff ff ff 	mov    QWORD PTR [rbp-0xa0],rdx
  40e1fd:	48 89 8d 68 ff ff ff 	mov    QWORD PTR [rbp-0x98],rcx
  40e204:	4c 89 85 70 ff ff ff 	mov    QWORD PTR [rbp-0x90],r8
  40e20b:	4c 89 8d 78 ff ff ff 	mov    QWORD PTR [rbp-0x88],r9
  40e212:	84 c0                	test   al,al
  40e214:	74 20                	je     40e236 <printc.constprop.0+0x56>
  40e216:	0f 29 45 80          	movaps XMMWORD PTR [rbp-0x80],xmm0
  40e21a:	0f 29 4d 90          	movaps XMMWORD PTR [rbp-0x70],xmm1
  40e21e:	0f 29 55 a0          	movaps XMMWORD PTR [rbp-0x60],xmm2
  40e222:	0f 29 5d b0          	movaps XMMWORD PTR [rbp-0x50],xmm3
  40e226:	0f 29 65 c0          	movaps XMMWORD PTR [rbp-0x40],xmm4
  40e22a:	0f 29 6d d0          	movaps XMMWORD PTR [rbp-0x30],xmm5
  40e22e:	0f 29 75 e0          	movaps XMMWORD PTR [rbp-0x20],xmm6
  40e232:	0f 29 7d f0          	movaps XMMWORD PTR [rbp-0x10],xmm7
	va_start(arg_ptr, fmt);
  40e236:	48 8d 45 10          	lea    rax,[rbp+0x10]
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40e23a:	be b4 00 00 00       	mov    esi,0xb4
  40e23f:	48 8d 8d 78 fe ff ff 	lea    rcx,[rbp-0x188]
	va_start(arg_ptr, fmt);
  40e246:	c7 85 78 fe ff ff 08 	mov    DWORD PTR [rbp-0x188],0x8
  40e24d:	00 00 00 
  40e250:	48 89 85 80 fe ff ff 	mov    QWORD PTR [rbp-0x180],rax
  40e257:	48 8d 85 50 ff ff ff 	lea    rax,[rbp-0xb0]
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40e25e:	48 8d bd 90 fe ff ff 	lea    rdi,[rbp-0x170]
  40e265:	48 ba 80 01 42 00 00 	movabs rdx,0x420180
  40e26c:	00 00 00 
	va_start(arg_ptr, fmt);
  40e26f:	48 89 85 88 fe ff ff 	mov    QWORD PTR [rbp-0x178],rax
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40e276:	48 b8 20 80 41 00 00 	movabs rax,0x418020
  40e27d:	00 00 00 
	va_start(arg_ptr, fmt);
  40e280:	c7 85 7c fe ff ff 30 	mov    DWORD PTR [rbp-0x184],0x30
  40e287:	00 00 00 
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40e28a:	ff d0                	call   rax
	ret = cos_print_str(s, ret);
  40e28c:	48 8d bd 90 fe ff ff 	lea    rdi,[rbp-0x170]
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40e293:	89 c6                	mov    esi,eax
	ret = cos_print_str(s, ret);
  40e295:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40e29c:	00 00 00 
  40e29f:	ff d0                	call   rax
}
  40e2a1:	c9                   	leave  
  40e2a2:	c3                   	ret    
  40e2a3:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40e2aa:	00 00 00 00 
  40e2ae:	66 90                	xchg   ax,ax

000000000040e2b0 <__mem_bump_alloc.constprop.0>:
}

/**************** [Memory Capability Allocation Functions] ***************/

static vaddr_t
__mem_bump_alloc(struct cos_compinfo *__ci, int km, int retype)
  40e2b0:	f3 0f 1e fa          	endbr64 
  40e2b4:	55                   	push   rbp
  40e2b5:	48 89 e5             	mov    rbp,rsp
  40e2b8:	41 55                	push   r13
  40e2ba:	41 54                	push   r12
  40e2bc:	53                   	push   rbx
  40e2bd:	48 83 ec 18          	sub    rsp,0x18
	struct cos_compinfo *ci;
	vaddr_t *            ptr, *frontier;

	printd("__mem_bump_alloc\n");

	assert(__ci);
  40e2c1:	48 85 ff             	test   rdi,rdi
  40e2c4:	0f 84 2b 01 00 00    	je     40e3f5 <__mem_bump_alloc.constprop.0+0x145>
	return ci->memsrc;
  40e2ca:	4c 8b 57 60          	mov    r10,QWORD PTR [rdi+0x60]
        __asm__ __volatile__("lock " PS_CAS_STR
  40e2ce:	be 01 00 00 00       	mov    esi,0x1
  40e2d3:	31 c9                	xor    ecx,ecx
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40e2d5:	49 8d 92 b8 00 00 00 	lea    rdx,[r10+0xb8]
	ci = __compinfo_metacap(__ci);
	assert(ci && ci == __compinfo_metacap(__ci));
  40e2dc:	4d 85 d2             	test   r10,r10
  40e2df:	0f 84 38 01 00 00    	je     40e41d <__mem_bump_alloc.constprop.0+0x16d>
  40e2e5:	0f 1f 00             	nop    DWORD PTR [rax]
        __asm__ __volatile__("lock " PS_CAS_STR
  40e2e8:	48 89 c8             	mov    rax,rcx
  40e2eb:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40e2f0:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40e2f3:	84 c0                	test   al,al
  40e2f5:	74 f1                	je     40e2e8 <__mem_bump_alloc.constprop.0+0x38>
        __asm__ __volatile__("lock " PS_FAA_STR
  40e2f7:	41 bd 00 10 00 00    	mov    r13d,0x1000
  40e2fd:	f0 4d 0f c1 6a 78    	lock xadd QWORD PTR [r10+0x78],r13
		frontier = &ci->mi.umem_frontier;
	}

	ret = ps_faa(ptr, PAGE_SIZE);

	if (ret >= *frontier || *frontier - ret > RETYPE_MEM_SIZE) {
  40e303:	49 8b 92 90 00 00 00 	mov    rdx,QWORD PTR [r10+0x90]
  40e30a:	49 39 d5             	cmp    r13,rdx
  40e30d:	0f 82 bd 00 00 00    	jb     40e3d0 <__mem_bump_alloc.constprop.0+0x120>
		vaddr_t ptr_tmp = *ptr, front_tmp = *frontier;
  40e313:	49 8b 42 78          	mov    rax,QWORD PTR [r10+0x78]

		/* TODO: expand frontier if introspection says there is more memory */
		if (ci->mi.untyped_ptr == ci->mi.untyped_frontier) goto error;
  40e317:	49 8b 9a 80 00 00 00 	mov    rbx,QWORD PTR [r10+0x80]
  40e31e:	49 39 5a 68          	cmp    QWORD PTR [r10+0x68],rbx
  40e322:	0f 84 c8 00 00 00    	je     40e3f0 <__mem_bump_alloc.constprop.0+0x140>
  40e328:	41 bd 00 10 00 00    	mov    r13d,0x1000
  40e32e:	f0 4d 0f c1 6a 68    	lock xadd QWORD PTR [r10+0x68],r13
		/* this is the overall frontier, so we know we can use this value... */
		ret = ps_faa(&ci->mi.untyped_ptr, RETYPE_MEM_SIZE);
		/* failure here means that someone else already advanced the frontier/ptr */
		if (ps_cas(ptr, ptr_tmp, ret + PAGE_SIZE)) {
  40e334:	49 8d 8d 00 10 00 00 	lea    rcx,[r13+0x1000]
        __asm__ __volatile__("lock " PS_CAS_STR
  40e33b:	f0 49 0f b1 4a 78    	lock cmpxchg QWORD PTR [r10+0x78],rcx
  40e341:	0f 94 c0             	sete   al
  40e344:	84 c0                	test   al,al
  40e346:	74 0f                	je     40e357 <__mem_bump_alloc.constprop.0+0xa7>
  40e348:	48 89 d0             	mov    rax,rdx
  40e34b:	f0 49 0f b1 8a 90 00 	lock cmpxchg QWORD PTR [r10+0x90],rcx
  40e352:	00 00 
  40e354:	0f 94 c0             	sete   al
			ps_cas(frontier, front_tmp, ret + RETYPE_MEM_SIZE);
		}
	}

	if (retype && (ret % RETYPE_MEM_SIZE == 0)) {
  40e357:	4c 89 ea             	mov    rdx,r13
  40e35a:	81 e2 ff 0f 00 00    	and    edx,0xfff
  40e360:	75 50                	jne    40e3b2 <__mem_bump_alloc.constprop.0+0x102>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e362:	41 8b 82 98 00 00 00 	mov    eax,DWORD PTR [r10+0x98]
	__asm__ __volatile__(
  40e369:	4c 89 eb             	mov    rbx,r13
  40e36c:	48 89 d6             	mov    rsi,rdx
  40e36f:	48 89 d7             	mov    rdi,rdx
  40e372:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e376:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40e379:	05 1a 00 01 00       	add    eax,0x1001a
	__asm__ __volatile__(
  40e37e:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40e381:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40e385:	48 89 cd             	mov    rbp,rcx
  40e388:	49 b8 a0 e3 40 00 00 	movabs r8,0x40e3a0
  40e38f:	00 00 00 
  40e392:	0f 05                	syscall 
  40e394:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  40e398:	eb 0d                	jmp    40e3a7 <__mem_bump_alloc.constprop.0+0xf7>
  40e39a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e3a0:	b9 00 00 00 00       	mov    ecx,0x0
  40e3a5:	eb 05                	jmp    40e3ac <__mem_bump_alloc.constprop.0+0xfc>
  40e3a7:	b9 01 00 00 00       	mov    ecx,0x1
  40e3ac:	5d                   	pop    rbp
  40e3ad:	5c                   	pop    rsp
		/* are we dealing with a kernel memory allocation? */
		syscall_op_t op = km ? CAPTBL_OP_MEM_RETYPE2KERN : CAPTBL_OP_MEM_RETYPE2USER;
		if (call_cap_op(ci->mi.pgtbl_cap, op, ret, 0, 0, 0)) goto error;
  40e3ae:	85 c0                	test   eax,eax
  40e3b0:	75 3e                	jne    40e3f0 <__mem_bump_alloc.constprop.0+0x140>
  40e3b2:	49 c7 82 b8 00 00 00 	mov    QWORD PTR [r10+0xb8],0x0
  40e3b9:	00 00 00 00 
	return ret;
error:
	ps_lock_release(&ci->mem_lock);

	return 0;
}
  40e3bd:	48 83 c4 18          	add    rsp,0x18
  40e3c1:	4c 89 e8             	mov    rax,r13
  40e3c4:	5b                   	pop    rbx
  40e3c5:	41 5c                	pop    r12
  40e3c7:	41 5d                	pop    r13
  40e3c9:	5d                   	pop    rbp
  40e3ca:	c3                   	ret    
  40e3cb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	if (ret >= *frontier || *frontier - ret > RETYPE_MEM_SIZE) {
  40e3d0:	48 89 d0             	mov    rax,rdx
  40e3d3:	4c 29 e8             	sub    rax,r13
  40e3d6:	48 3d 00 10 00 00    	cmp    rax,0x1000
  40e3dc:	0f 86 75 ff ff ff    	jbe    40e357 <__mem_bump_alloc.constprop.0+0xa7>
  40e3e2:	e9 2c ff ff ff       	jmp    40e313 <__mem_bump_alloc.constprop.0+0x63>
  40e3e7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40e3ee:	00 00 
	return 0;
  40e3f0:	45 31 ed             	xor    r13d,r13d
  40e3f3:	eb bd                	jmp    40e3b2 <__mem_bump_alloc.constprop.0+0x102>
	return cos_print_str(s, strlen(s));
  40e3f5:	48 bf 90 01 42 00 00 	movabs rdi,0x420190
  40e3fc:	00 00 00 
  40e3ff:	be 2e 00 00 00       	mov    esi,0x2e
  40e404:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40e40b:	00 00 00 
  40e40e:	ff d0                	call   rax
	assert(__ci);
  40e410:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e417:	00 00 00 00 
  40e41b:	0f 0b                	ud2    
  40e41d:	48 bf c0 01 42 00 00 	movabs rdi,0x4201c0
  40e424:	00 00 00 
  40e427:	be 2e 00 00 00       	mov    esi,0x2e
  40e42c:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40e433:	00 00 00 
  40e436:	ff d0                	call   rax
	assert(ci && ci == __compinfo_metacap(__ci));
  40e438:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e43f:	00 00 00 00 
  40e443:	0f 0b                	ud2    
  40e445:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40e44c:	00 00 00 00 

000000000040e450 <__capid_captbl_check_expand>:

static capid_t __capid_bump_alloc(struct cos_compinfo *ci, cap_t cap);

static int
__capid_captbl_check_expand(struct cos_compinfo *ci)
{
  40e450:	f3 0f 1e fa          	endbr64 
  40e454:	55                   	push   rbp
  40e455:	48 89 e5             	mov    rbp,rsp
  40e458:	41 57                	push   r15
  40e45a:	41 56                	push   r14
  40e45c:	41 55                	push   r13
  40e45e:	41 54                	push   r12
  40e460:	53                   	push   rbx
  40e461:	48 83 ec 28          	sub    rsp,0x28
	return ci->memsrc;
  40e465:	4c 8b 67 60          	mov    r12,QWORD PTR [rdi+0x60]
	capid_t captblcap;
	capid_t captblid_add;
	vaddr_t kmem;

	/* ensure that we have bounded structure, and bounded recursion */
	assert(__compinfo_metacap(meta) == meta);
  40e469:	4d 39 64 24 60       	cmp    QWORD PTR [r12+0x60],r12
  40e46e:	75 2e                	jne    40e49e <__capid_captbl_check_expand+0x4e>
	 * rest of the entry (internal fragmentation WRT the captbl
	 * capability).  Oh well.
	 */

	if (self_resources) {
		frontier = ps_load(&ci->caprange_frontier) - CAPMAX_ENTRY_SZ;
  40e470:	48 8b 5f 20          	mov    rbx,QWORD PTR [rdi+0x20]
  40e474:	49 89 fd             	mov    r13,rdi
	if (self_resources) {
  40e477:	4c 39 e7             	cmp    rdi,r12
  40e47a:	74 1c                	je     40e498 <__capid_captbl_check_expand+0x48>
	} else {
		frontier = ps_load(&ci->caprange_frontier);
	}
	assert(ci->cap_frontier <= frontier);
  40e47c:	49 39 5d 18          	cmp    QWORD PTR [r13+0x18],rbx
  40e480:	77 44                	ja     40e4c6 <__capid_captbl_check_expand+0x76>

	/* Common case: */
	if (likely(ci->cap_frontier != frontier)) return 0;
  40e482:	74 6a                	je     40e4ee <__capid_captbl_check_expand+0x9e>
	frontier       = ps_load(&ci->cap_frontier);
	range_frontier = ps_faa(&ci->caprange_frontier, CAPTBL_EXPAND_SZ * 2);
	ps_cas(&ci->cap_frontier, frontier, range_frontier);

	return 0;
}
  40e484:	48 83 c4 28          	add    rsp,0x28
  40e488:	31 c0                	xor    eax,eax
  40e48a:	5b                   	pop    rbx
  40e48b:	41 5c                	pop    r12
  40e48d:	41 5d                	pop    r13
  40e48f:	41 5e                	pop    r14
  40e491:	41 5f                	pop    r15
  40e493:	5d                   	pop    rbp
  40e494:	c3                   	ret    
  40e495:	0f 1f 00             	nop    DWORD PTR [rax]
		frontier = ps_load(&ci->caprange_frontier) - CAPMAX_ENTRY_SZ;
  40e498:	48 83 eb 04          	sub    rbx,0x4
  40e49c:	eb de                	jmp    40e47c <__capid_captbl_check_expand+0x2c>
  40e49e:	48 bf f0 01 42 00 00 	movabs rdi,0x4201f0
  40e4a5:	00 00 00 
  40e4a8:	be 2e 00 00 00       	mov    esi,0x2e
  40e4ad:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40e4b4:	00 00 00 
  40e4b7:	ff d0                	call   rax
	assert(__compinfo_metacap(meta) == meta);
  40e4b9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e4c0:	00 00 00 00 
  40e4c4:	0f 0b                	ud2    
  40e4c6:	48 bf 20 02 42 00 00 	movabs rdi,0x420220
  40e4cd:	00 00 00 
  40e4d0:	be 2e 00 00 00       	mov    esi,0x2e
  40e4d5:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40e4dc:	00 00 00 
  40e4df:	ff d0                	call   rax
	assert(ci->cap_frontier <= frontier);
  40e4e1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e4e8:	00 00 00 00 
  40e4ec:	0f 0b                	ud2    
	return __mem_bump_alloc(ci, 1, 1);
  40e4ee:	48 b8 b0 e2 40 00 00 	movabs rax,0x40e2b0
  40e4f5:	00 00 00 
  40e4f8:	4c 89 ef             	mov    rdi,r13
  40e4fb:	ff d0                	call   rax
  40e4fd:	49 89 c6             	mov    r14,rax
	assert(kmem); /* FIXME: should have a failure semantics for capids */
  40e500:	48 85 c0             	test   rax,rax
  40e503:	0f 84 c7 01 00 00    	je     40e6d0 <__capid_captbl_check_expand+0x280>
	if (self_resources) {
  40e509:	4d 39 e5             	cmp    r13,r12
  40e50c:	74 72                	je     40e580 <__capid_captbl_check_expand+0x130>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40e50e:	49 8d 94 24 b0 00 00 	lea    rdx,[r12+0xb0]
  40e515:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  40e516:	be 01 00 00 00       	mov    esi,0x1
  40e51b:	31 c9                	xor    ecx,ecx
  40e51d:	0f 1f 00             	nop    DWORD PTR [rax]
  40e520:	48 89 c8             	mov    rax,rcx
  40e523:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40e528:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40e52b:	84 c0                	test   al,al
  40e52d:	74 f1                	je     40e520 <__capid_captbl_check_expand+0xd0>
	ps_lock_take(&ci->cap_lock);
	/*
	 * Do we need a new cache-line in the capability table for
	 * this size of capability?
	 */
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40e52f:	41 f6 44 24 38 03    	test   BYTE PTR [r12+0x38],0x3
  40e535:	0f 84 6c 01 00 00    	je     40e6a7 <__capid_captbl_check_expand+0x257>
        __asm__ __volatile__("lock " PS_FAA_STR
  40e53b:	bb 04 00 00 00       	mov    ebx,0x4
  40e540:	f0 49 0f c1 5c 24 38 	lock xadd QWORD PTR [r12+0x38],rbx
{ l->o = 0; }
  40e547:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40e54e:	00 00 00 00 00 
		assert(captblcap);
  40e553:	48 85 db             	test   rbx,rbx
  40e556:	75 28                	jne    40e580 <__capid_captbl_check_expand+0x130>
  40e558:	48 bf 80 02 42 00 00 	movabs rdi,0x420280
  40e55f:	00 00 00 
  40e562:	be 2e 00 00 00       	mov    esi,0x2e
  40e567:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40e56e:	00 00 00 
  40e571:	ff d0                	call   rax
  40e573:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e57a:	00 00 00 00 
  40e57e:	0f 0b                	ud2    
	captblid_add = ps_load(&ci->caprange_frontier);
  40e580:	4d 8b 7d 20          	mov    r15,QWORD PTR [r13+0x20]
	assert(captblid_add % CAPTBL_EXPAND_SZ == 0);
  40e584:	4c 89 f8             	mov    rax,r15
  40e587:	83 e0 7f             	and    eax,0x7f
  40e58a:	48 89 45 b8          	mov    QWORD PTR [rbp-0x48],rax
  40e58e:	0f 85 64 01 00 00    	jne    40e6f8 <__capid_captbl_check_expand+0x2a8>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e594:	41 8b 44 24 08       	mov    eax,DWORD PTR [r12+0x8]
	__asm__ __volatile__(
  40e599:	4c 8d 55 c0          	lea    r10,[rbp-0x40]
  40e59d:	ba 01 00 00 00       	mov    edx,0x1
  40e5a2:	4c 89 f7             	mov    rdi,r14
  40e5a5:	49 8b b4 24 98 00 00 	mov    rsi,QWORD PTR [r12+0x98]
  40e5ac:	00 
  40e5ad:	4c 89 d1             	mov    rcx,r10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e5b0:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40e5b3:	05 1e 00 01 00       	add    eax,0x1001e
	__asm__ __volatile__(
  40e5b8:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40e5bb:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40e5bf:	48 89 cd             	mov    rbp,rcx
  40e5c2:	49 b8 d8 e5 40 00 00 	movabs r8,0x40e5d8
  40e5c9:	00 00 00 
  40e5cc:	0f 05                	syscall 
  40e5ce:	66 90                	xchg   ax,ax
  40e5d0:	eb 0d                	jmp    40e5df <__capid_captbl_check_expand+0x18f>
  40e5d2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e5d8:	b9 00 00 00 00       	mov    ecx,0x0
  40e5dd:	eb 05                	jmp    40e5e4 <__capid_captbl_check_expand+0x194>
  40e5df:	b9 01 00 00 00       	mov    ecx,0x1
  40e5e4:	5d                   	pop    rbp
  40e5e5:	5c                   	pop    rsp
	if (call_cap_op(meta->captbl_cap, CAPTBL_OP_CAPTBLACTIVATE, captblcap, meta->mi.pgtbl_cap, kmem, 1)) {
  40e5e6:	85 c0                	test   eax,eax
  40e5e8:	75 6d                	jne    40e657 <__capid_captbl_check_expand+0x207>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e5ea:	41 8b 45 08          	mov    eax,DWORD PTR [r13+0x8]
	__asm__ __volatile__(
  40e5ee:	48 8b 7d b8          	mov    rdi,QWORD PTR [rbp-0x48]
  40e5f2:	4c 89 fe             	mov    rsi,r15
  40e5f5:	4c 89 d1             	mov    rcx,r10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e5f8:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40e5fb:	48 89 fa             	mov    rdx,rdi
	cap_no += op;
  40e5fe:	05 01 00 01 00       	add    eax,0x10001
	__asm__ __volatile__(
  40e603:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40e606:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40e60a:	48 89 cd             	mov    rbp,rcx
  40e60d:	49 b8 28 e6 40 00 00 	movabs r8,0x40e628
  40e614:	00 00 00 
  40e617:	0f 05                	syscall 
  40e619:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  40e620:	eb 0d                	jmp    40e62f <__capid_captbl_check_expand+0x1df>
  40e622:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e628:	b9 00 00 00 00       	mov    ecx,0x0
  40e62d:	eb 05                	jmp    40e634 <__capid_captbl_check_expand+0x1e4>
  40e62f:	b9 01 00 00 00       	mov    ecx,0x1
  40e634:	5d                   	pop    rbp
  40e635:	5c                   	pop    rsp
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_CONS, captblcap, captblid_add, 0, 0)) {
  40e636:	85 c0                	test   eax,eax
  40e638:	75 45                	jne    40e67f <__capid_captbl_check_expand+0x22f>
	frontier       = ps_load(&ci->cap_frontier);
  40e63a:	49 8b 45 18          	mov    rax,QWORD PTR [r13+0x18]
        __asm__ __volatile__("lock " PS_FAA_STR
  40e63e:	ba 00 01 00 00       	mov    edx,0x100
  40e643:	f0 49 0f c1 55 20    	lock xadd QWORD PTR [r13+0x20],rdx
        __asm__ __volatile__("lock " PS_CAS_STR
  40e649:	f0 49 0f b1 55 18    	lock cmpxchg QWORD PTR [r13+0x18],rdx
  40e64f:	0f 94 c0             	sete   al
	return 0;
  40e652:	e9 2d fe ff ff       	jmp    40e484 <__capid_captbl_check_expand+0x34>
  40e657:	48 bf e0 02 42 00 00 	movabs rdi,0x4202e0
  40e65e:	00 00 00 
  40e661:	be 2e 00 00 00       	mov    esi,0x2e
  40e666:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40e66d:	00 00 00 
  40e670:	ff d0                	call   rax
		assert(0); /* race condition? */
  40e672:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e679:	00 00 00 00 
  40e67d:	0f 0b                	ud2    
  40e67f:	48 bf 10 03 42 00 00 	movabs rdi,0x420310
  40e686:	00 00 00 
  40e689:	be 2e 00 00 00       	mov    esi,0x2e
  40e68e:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40e695:	00 00 00 
  40e698:	ff d0                	call   rax
		assert(0); /* race? */
  40e69a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e6a1:	00 00 00 00 
  40e6a5:	0f 0b                	ud2    
		if (__capid_captbl_check_expand(ci)) goto error;
  40e6a7:	48 b8 50 e4 40 00 00 	movabs rax,0x40e450
  40e6ae:	00 00 00 
  40e6b1:	4c 89 e7             	mov    rdi,r12
  40e6b4:	ff d0                	call   rax
  40e6b6:	85 c0                	test   eax,eax
  40e6b8:	75 66                	jne    40e720 <__capid_captbl_check_expand+0x2d0>
        __asm__ __volatile__("lock " PS_FAA_STR
  40e6ba:	b8 04 00 00 00       	mov    eax,0x4
  40e6bf:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40e6c6:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  40e6cb:	e9 6b fe ff ff       	jmp    40e53b <__capid_captbl_check_expand+0xeb>
  40e6d0:	48 bf 50 02 42 00 00 	movabs rdi,0x420250
  40e6d7:	00 00 00 
  40e6da:	be 2e 00 00 00       	mov    esi,0x2e
  40e6df:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40e6e6:	00 00 00 
  40e6e9:	ff d0                	call   rax
	assert(kmem); /* FIXME: should have a failure semantics for capids */
  40e6eb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e6f2:	00 00 00 00 
  40e6f6:	0f 0b                	ud2    
  40e6f8:	48 bf b0 02 42 00 00 	movabs rdi,0x4202b0
  40e6ff:	00 00 00 
  40e702:	be 2e 00 00 00       	mov    esi,0x2e
  40e707:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40e70e:	00 00 00 
  40e711:	ff d0                	call   rax
	assert(captblid_add % CAPTBL_EXPAND_SZ == 0);
  40e713:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e71a:	00 00 00 00 
  40e71e:	0f 0b                	ud2    
{ l->o = 0; }
  40e720:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40e727:	00 00 00 00 00 
		assert(captblcap);
  40e72c:	e9 27 fe ff ff       	jmp    40e558 <__capid_captbl_check_expand+0x108>
  40e731:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40e738:	00 00 00 00 
  40e73c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000040e740 <__bump_mem_expand_range>:
	return pte_cap;
}

static vaddr_t
__bump_mem_expand_range(struct cos_compinfo *meta, pgtblcap_t cipgtbl, vaddr_t mem_ptr, unsigned long mem_sz, u32_t pgtbl_lvl)
{
  40e740:	f3 0f 1e fa          	endbr64 
  40e744:	55                   	push   rbp
  40e745:	48 89 e5             	mov    rbp,rsp
  40e748:	41 57                	push   r15
  40e74a:	41 56                	push   r14
  40e74c:	41 55                	push   r13
  40e74e:	41 54                	push   r12
  40e750:	53                   	push   rbx
  40e751:	48 83 ec 48          	sub    rsp,0x48
  40e755:	48 89 55 b0          	mov    QWORD PTR [rbp-0x50],rdx
  40e759:	44 89 45 bc          	mov    DWORD PTR [rbp-0x44],r8d
	vaddr_t addr, range;
	u8_t lvl = (u8_t)pgtbl_lvl;
	assert(lvl >= 0 && lvl < COS_PGTBL_DEPTH - 1);
  40e75d:	41 80 f8 02          	cmp    r8b,0x2
  40e761:	0f 87 b1 02 00 00    	ja     40ea18 <__bump_mem_expand_range+0x2d8>


#if defined(__x86_64__)
	vaddr_t tmp_frontier;
	range		 = cos_pgtbl_get_range(lvl);
  40e767:	41 0f b6 d0          	movzx  edx,r8b
  40e76b:	41 80 f8 02          	cmp    r8b,0x2
  40e76f:	76 17                	jbe    40e788 <__bump_mem_expand_range+0x48>
	}
	assert(round_up_to_pgd_page(addr) == round_up_to_pgd_page(mem_ptr + mem_sz));
#endif

	return mem_ptr;
}
  40e771:	48 8b 45 b0          	mov    rax,QWORD PTR [rbp-0x50]
  40e775:	48 83 c4 48          	add    rsp,0x48
  40e779:	5b                   	pop    rbx
  40e77a:	41 5c                	pop    r12
  40e77c:	41 5d                	pop    r13
  40e77e:	41 5e                	pop    r14
  40e780:	41 5f                	pop    r15
  40e782:	5d                   	pop    rbp
  40e783:	c3                   	ret    
  40e784:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  40e788:	49 89 ff             	mov    r15,rdi
  40e78b:	48 89 f0             	mov    rax,rsi
	tmp_frontier = cos_pgtbl_round_up_to_page(lvl, mem_ptr + mem_sz);
  40e78e:	48 03 4d b0          	add    rcx,QWORD PTR [rbp-0x50]
	switch (pgtbl_lvl)
  40e792:	83 fa 01             	cmp    edx,0x1
  40e795:	0f 84 ca 01 00 00    	je     40e965 <__bump_mem_expand_range+0x225>
  40e79b:	83 fa 02             	cmp    edx,0x2
  40e79e:	75 1f                	jne    40e7bf <__bump_mem_expand_range+0x7f>
		return round_up_to_pgt2_page(vaddr);
  40e7a0:	48 81 c1 ff ff 1f 00 	add    rcx,0x1fffff
  40e7a7:	48 c7 45 98 00 00 20 	mov    QWORD PTR [rbp-0x68],0x200000
  40e7ae:	00 
  40e7af:	48 81 e1 00 00 e0 ff 	and    rcx,0xffffffffffe00000
  40e7b6:	48 89 4d a8          	mov    QWORD PTR [rbp-0x58],rcx
  40e7ba:	48 89 cf             	mov    rdi,rcx
  40e7bd:	eb 33                	jmp    40e7f2 <__bump_mem_expand_range+0xb2>
	switch (pgtbl_lvl)
  40e7bf:	85 d2                	test   edx,edx
  40e7c1:	75 ae                	jne    40e771 <__bump_mem_expand_range+0x31>
		return round_up_to_pgt0_page(vaddr);
  40e7c3:	48 ba ff ff ff ff 7f 	movabs rdx,0x7fffffffff
  40e7ca:	00 00 00 
  40e7cd:	48 be 00 00 00 00 80 	movabs rsi,0x8000000000
  40e7d4:	00 00 00 
  40e7d7:	48 01 d1             	add    rcx,rdx
  40e7da:	48 89 75 98          	mov    QWORD PTR [rbp-0x68],rsi
  40e7de:	48 ba 00 00 00 00 80 	movabs rdx,0xffffff8000000000
  40e7e5:	ff ff ff 
  40e7e8:	48 21 d1             	and    rcx,rdx
  40e7eb:	48 89 4d a8          	mov    QWORD PTR [rbp-0x58],rcx
  40e7ef:	48 89 cf             	mov    rdi,rcx
	for (addr = mem_ptr; addr < tmp_frontier; addr += range) {
  40e7f2:	48 8b 5d b0          	mov    rbx,QWORD PTR [rbp-0x50]
  40e7f6:	48 39 fb             	cmp    rbx,rdi
  40e7f9:	0f 83 72 ff ff ff    	jae    40e771 <__bump_mem_expand_range+0x31>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e7ff:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40e802:	48 89 5d a0          	mov    QWORD PTR [rbp-0x60],rbx
        __asm__ __volatile__("lock " PS_CAS_STR
  40e806:	41 be 01 00 00 00    	mov    r14d,0x1
  40e80c:	45 31 ed             	xor    r13d,r13d
  40e80f:	05 01 00 01 00       	add    eax,0x10001
  40e814:	89 45 b8             	mov    DWORD PTR [rbp-0x48],eax
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  40e817:	4d 3b 7f 60          	cmp    r15,QWORD PTR [r15+0x60]
  40e81b:	0f 85 1c 01 00 00    	jne    40e93d <__bump_mem_expand_range+0x1fd>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40e821:	49 8d 97 b0 00 00 00 	lea    rdx,[r15+0xb0]
  40e828:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40e82f:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  40e830:	4c 89 e8             	mov    rax,r13
  40e833:	f0 4c 0f b1 32       	lock cmpxchg QWORD PTR [rdx],r14
  40e838:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40e83b:	84 c0                	test   al,al
  40e83d:	74 f1                	je     40e830 <__bump_mem_expand_range+0xf0>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40e83f:	41 f6 47 38 03       	test   BYTE PTR [r15+0x38],0x3
  40e844:	0f 84 3d 01 00 00    	je     40e987 <__bump_mem_expand_range+0x247>
        __asm__ __volatile__("lock " PS_FAA_STR
  40e84a:	bb 04 00 00 00       	mov    ebx,0x4
  40e84f:	f0 49 0f c1 5f 38    	lock xadd QWORD PTR [r15+0x38],rbx
	return __mem_bump_alloc(ci, 1, 1);
  40e855:	48 b8 b0 e2 40 00 00 	movabs rax,0x40e2b0
  40e85c:	00 00 00 
  40e85f:	4c 89 ff             	mov    rdi,r15
{ l->o = 0; }
  40e862:	49 c7 87 b0 00 00 00 	mov    QWORD PTR [r15+0xb0],0x0
  40e869:	00 00 00 00 
  40e86d:	ff d0                	call   rax
  40e86f:	48 89 c7             	mov    rdi,rax
		if (pte_cap == 0 || ptemem_cap == 0) {
  40e872:	48 85 db             	test   rbx,rbx
  40e875:	0f 84 39 01 00 00    	je     40e9b4 <__bump_mem_expand_range+0x274>
  40e87b:	48 85 c0             	test   rax,rax
  40e87e:	0f 84 30 01 00 00    	je     40e9b4 <__bump_mem_expand_range+0x274>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e884:	41 8b 47 08          	mov    eax,DWORD PTR [r15+0x8]
		if (call_cap_op(meta->captbl_cap, CAPTBL_OP_PGTBLACTIVATE, pte_cap, meta->mi.pgtbl_cap, ptemem_cap,
  40e888:	8b 4d bc             	mov    ecx,DWORD PTR [rbp-0x44]
	__asm__ __volatile__(
  40e88b:	4c 8d 55 c0          	lea    r10,[rbp-0x40]
  40e88f:	49 8b b7 98 00 00 00 	mov    rsi,QWORD PTR [r15+0x98]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e896:	c1 e0 10             	shl    eax,0x10
  40e899:	8d 51 01             	lea    edx,[rcx+0x1]
	__asm__ __volatile__(
  40e89c:	4c 89 d1             	mov    rcx,r10
	cap_no += op;
  40e89f:	05 1c 00 01 00       	add    eax,0x1001c
	__asm__ __volatile__(
  40e8a4:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40e8a7:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40e8ab:	48 89 cd             	mov    rbp,rcx
  40e8ae:	49 b8 c8 e8 40 00 00 	movabs r8,0x40e8c8
  40e8b5:	00 00 00 
  40e8b8:	0f 05                	syscall 
  40e8ba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e8c0:	eb 0d                	jmp    40e8cf <__bump_mem_expand_range+0x18f>
  40e8c2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e8c8:	b9 00 00 00 00       	mov    ecx,0x0
  40e8cd:	eb 05                	jmp    40e8d4 <__bump_mem_expand_range+0x194>
  40e8cf:	b9 01 00 00 00       	mov    ecx,0x1
  40e8d4:	5d                   	pop    rbp
  40e8d5:	5c                   	pop    rsp
  40e8d6:	85 c0                	test   eax,eax
  40e8d8:	0f 85 fe 00 00 00    	jne    40e9dc <__bump_mem_expand_range+0x29c>
  40e8de:	8b 45 b8             	mov    eax,DWORD PTR [rbp-0x48]
  40e8e1:	48 8b 75 a0          	mov    rsi,QWORD PTR [rbp-0x60]
  40e8e5:	4c 89 ef             	mov    rdi,r13
  40e8e8:	4c 89 ea             	mov    rdx,r13
  40e8eb:	4c 89 d1             	mov    rcx,r10
  40e8ee:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40e8f1:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40e8f5:	48 89 cd             	mov    rbp,rcx
  40e8f8:	49 b8 10 e9 40 00 00 	movabs r8,0x40e910
  40e8ff:	00 00 00 
  40e902:	0f 05                	syscall 
  40e904:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  40e908:	eb 0d                	jmp    40e917 <__bump_mem_expand_range+0x1d7>
  40e90a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e910:	b9 00 00 00 00       	mov    ecx,0x0
  40e915:	eb 05                	jmp    40e91c <__bump_mem_expand_range+0x1dc>
  40e917:	b9 01 00 00 00       	mov    ecx,0x1
  40e91c:	5d                   	pop    rbp
  40e91d:	5c                   	pop    rsp
	for (addr = mem_ptr; addr < tmp_frontier; addr += range) {
  40e91e:	48 8b 45 98          	mov    rax,QWORD PTR [rbp-0x68]
  40e922:	48 01 c6             	add    rsi,rax
  40e925:	48 89 75 a0          	mov    QWORD PTR [rbp-0x60],rsi
  40e929:	48 3b 75 a8          	cmp    rsi,QWORD PTR [rbp-0x58]
  40e92d:	0f 83 3e fe ff ff    	jae    40e771 <__bump_mem_expand_range+0x31>
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  40e933:	4d 3b 7f 60          	cmp    r15,QWORD PTR [r15+0x60]
  40e937:	0f 84 e4 fe ff ff    	je     40e821 <__bump_mem_expand_range+0xe1>
  40e93d:	48 bf 70 03 42 00 00 	movabs rdi,0x420370
  40e944:	00 00 00 
  40e947:	be 2e 00 00 00       	mov    esi,0x2e
  40e94c:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40e953:	00 00 00 
  40e956:	ff d0                	call   rax
  40e958:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e95f:	00 00 00 00 
  40e963:	0f 0b                	ud2    
		return round_up_to_pgt1_page(vaddr);
  40e965:	48 81 c1 ff ff ff 3f 	add    rcx,0x3fffffff
  40e96c:	48 c7 45 98 00 00 00 	mov    QWORD PTR [rbp-0x68],0x40000000
  40e973:	40 
  40e974:	48 81 e1 00 00 00 c0 	and    rcx,0xffffffffc0000000
  40e97b:	48 89 4d a8          	mov    QWORD PTR [rbp-0x58],rcx
  40e97f:	48 89 cf             	mov    rdi,rcx
  40e982:	e9 6b fe ff ff       	jmp    40e7f2 <__bump_mem_expand_range+0xb2>
		if (__capid_captbl_check_expand(ci)) goto error;
  40e987:	48 b8 50 e4 40 00 00 	movabs rax,0x40e450
  40e98e:	00 00 00 
  40e991:	4c 89 ff             	mov    rdi,r15
  40e994:	ff d0                	call   rax
  40e996:	85 c0                	test   eax,eax
  40e998:	74 6a                	je     40ea04 <__bump_mem_expand_range+0x2c4>
  40e99a:	49 c7 87 b0 00 00 00 	mov    QWORD PTR [r15+0xb0],0x0
  40e9a1:	00 00 00 00 
	return __mem_bump_alloc(ci, 1, 1);
  40e9a5:	4c 89 ff             	mov    rdi,r15
  40e9a8:	48 b8 b0 e2 40 00 00 	movabs rax,0x40e2b0
  40e9af:	00 00 00 
  40e9b2:	ff d0                	call   rax
  40e9b4:	48 bf a0 03 42 00 00 	movabs rdi,0x4203a0
  40e9bb:	00 00 00 
  40e9be:	be 2e 00 00 00       	mov    esi,0x2e
  40e9c3:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40e9ca:	00 00 00 
  40e9cd:	ff d0                	call   rax
			assert(0);
  40e9cf:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e9d6:	00 00 00 00 
  40e9da:	0f 0b                	ud2    
  40e9dc:	48 bf d0 03 42 00 00 	movabs rdi,0x4203d0
  40e9e3:	00 00 00 
  40e9e6:	be 2e 00 00 00       	mov    esi,0x2e
  40e9eb:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40e9f2:	00 00 00 
  40e9f5:	ff d0                	call   rax
				assert(0); /* race? */
  40e9f7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e9fe:	00 00 00 00 
  40ea02:	0f 0b                	ud2    
        __asm__ __volatile__("lock " PS_FAA_STR
  40ea04:	b8 04 00 00 00       	mov    eax,0x4
  40ea09:	f0 49 0f c1 47 18    	lock xadd QWORD PTR [r15+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40ea0f:	49 89 47 38          	mov    QWORD PTR [r15+0x38],rax
  40ea13:	e9 32 fe ff ff       	jmp    40e84a <__bump_mem_expand_range+0x10a>
  40ea18:	48 bf 40 03 42 00 00 	movabs rdi,0x420340
  40ea1f:	00 00 00 
  40ea22:	be 2e 00 00 00       	mov    esi,0x2e
  40ea27:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40ea2e:	00 00 00 
  40ea31:	ff d0                	call   rax
	assert(lvl >= 0 && lvl < COS_PGTBL_DEPTH - 1);
  40ea33:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ea3a:	00 00 00 00 
  40ea3e:	0f 0b                	ud2    

000000000040ea40 <__page_bump_valloc>:
	return heap_vaddr;
}

static vaddr_t
__page_bump_valloc(struct cos_compinfo *ci, size_t sz, size_t align)
{
  40ea40:	f3 0f 1e fa          	endbr64 
  40ea44:	55                   	push   rbp
        __asm__ __volatile__("lock " PS_CAS_STR
  40ea45:	31 c9                	xor    ecx,ecx
  40ea47:	48 89 e5             	mov    rbp,rsp
  40ea4a:	41 57                	push   r15
  40ea4c:	49 89 d7             	mov    r15,rdx
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40ea4f:	48 8d 97 c0 00 00 00 	lea    rdx,[rdi+0xc0]
  40ea56:	41 56                	push   r14
  40ea58:	41 55                	push   r13
  40ea5a:	41 54                	push   r12
  40ea5c:	49 89 f4             	mov    r12,rsi
        __asm__ __volatile__("lock " PS_CAS_STR
  40ea5f:	be 01 00 00 00       	mov    esi,0x1
  40ea64:	53                   	push   rbx
  40ea65:	48 89 fb             	mov    rbx,rdi
  40ea68:	48 83 ec 38          	sub    rsp,0x38
  40ea6c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  40ea70:	48 89 c8             	mov    rax,rcx
  40ea73:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40ea78:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40ea7b:	84 c0                	test   al,al
  40ea7d:	74 f1                	je     40ea70 <__page_bump_valloc+0x30>
	vaddr_t ret_addr = 0;
	vaddr_t rounding; // how much we need to round up sz to handle alignment

	ps_lock_take(&ci->va_lock);
	rounding = round_up_to_pow2(ci->vas_frontier, align) - ci->vas_frontier;
  40ea7f:	48 8b 53 40          	mov    rdx,QWORD PTR [rbx+0x40]
  40ea83:	4c 89 f9             	mov    rcx,r15
	return ci->memsrc;
  40ea86:	48 8b 7b 60          	mov    rdi,QWORD PTR [rbx+0x60]
	rounding = round_up_to_pow2(ci->vas_frontier, align) - ci->vas_frontier;
  40ea8a:	48 f7 d9             	neg    rcx
  40ea8d:	4a 8d 44 3a ff       	lea    rax,[rdx+r15*1-0x1]
  40ea92:	48 21 c8             	and    rax,rcx
  40ea95:	48 29 d0             	sub    rax,rdx
	sz += rounding;
  40ea98:	49 01 c4             	add    r12,rax
	rounding = round_up_to_pow2(ci->vas_frontier, align) - ci->vas_frontier;
  40ea9b:	49 89 c3             	mov    r11,rax
	assert(sz % PAGE_SIZE == 0);
  40ea9e:	4d 89 e6             	mov    r14,r12
  40eaa1:	41 81 e6 ff 0f 00 00 	and    r14d,0xfff
  40eaa8:	0f 85 39 01 00 00    	jne    40ebe7 <__page_bump_valloc+0x1a7>
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  40eaae:	48 3b 7f 60          	cmp    rdi,QWORD PTR [rdi+0x60]
  40eab2:	0f 85 57 01 00 00    	jne    40ec0f <__page_bump_valloc+0x1cf>
        __asm__ __volatile__("lock " PS_FAA_STR
  40eab8:	4c 89 e2             	mov    rdx,r12
  40eabb:	f0 48 0f c1 53 40    	lock xadd QWORD PTR [rbx+0x40],rdx
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) pgtbl_flag = PGTBL_LVL_FLAG_VM;
  40eac1:	31 c0                	xor    eax,eax
		if (heap_vaddr + sz > ci->vasrange_frontier[pgtbl_lvl]) {
  40eac3:	4d 8d 0c 14          	lea    r9,[r12+rdx*1]
		return round_up_to_pgt0_page(vaddr);
  40eac7:	48 89 7d b8          	mov    QWORD PTR [rbp-0x48],rdi
  40eacb:	4c 8d 6b 48          	lea    r13,[rbx+0x48]
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) pgtbl_flag = PGTBL_LVL_FLAG_VM;
  40eacf:	80 bb d8 00 00 00 01 	cmp    BYTE PTR [rbx+0xd8],0x1
		return round_up_to_pgt0_page(vaddr);
  40ead6:	48 b9 00 00 00 00 80 	movabs rcx,0xffffff8000000000
  40eadd:	ff ff ff 
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) pgtbl_flag = PGTBL_LVL_FLAG_VM;
  40eae0:	0f 94 c0             	sete   al
  40eae3:	c1 e0 1f             	shl    eax,0x1f
  40eae6:	89 45 c4             	mov    DWORD PTR [rbp-0x3c],eax
		return round_up_to_pgt0_page(vaddr);
  40eae9:	48 b8 ff ff ff ff 7f 	movabs rax,0x7fffffffff
  40eaf0:	00 00 00 
  40eaf3:	4c 01 c8             	add    rax,r9
  40eaf6:	48 21 c8             	and    rax,rcx
  40eaf9:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
		if (heap_vaddr + sz > ci->vasrange_frontier[pgtbl_lvl]) {
  40eafd:	4d 39 4d 00          	cmp    QWORD PTR [r13+0x0],r9
  40eb01:	72 45                	jb     40eb48 <__page_bump_valloc+0x108>
	for (pgtbl_lvl = 0; pgtbl_lvl < COS_PGTBL_DEPTH - 1; pgtbl_lvl++) {
  40eb03:	49 83 c6 01          	add    r14,0x1
  40eb07:	49 83 c5 08          	add    r13,0x8
  40eb0b:	49 83 fe 03          	cmp    r14,0x3
  40eb0f:	75 ec                	jne    40eafd <__page_bump_valloc+0xbd>
{ l->o = 0; }
  40eb11:	48 c7 83 c0 00 00 00 	mov    QWORD PTR [rbx+0xc0],0x0
  40eb18:	00 00 00 00 
	ret_addr = __page_bump_mem_alloc(ci, &ci->vas_frontier, &ci->vasrange_frontier[0], sz);
	ret_addr += rounding;
  40eb1c:	4d 8d 04 13          	lea    r8,[r11+rdx*1]
	ps_lock_release(&ci->va_lock);
	assert(ret_addr % align == 0);
  40eb20:	31 d2                	xor    edx,edx
  40eb22:	4c 89 c0             	mov    rax,r8
  40eb25:	49 f7 f7             	div    r15
  40eb28:	48 85 d2             	test   rdx,rdx
  40eb2b:	0f 85 06 01 00 00    	jne    40ec37 <__page_bump_valloc+0x1f7>

	return ret_addr;
}
  40eb31:	48 83 c4 38          	add    rsp,0x38
  40eb35:	4c 89 c0             	mov    rax,r8
  40eb38:	5b                   	pop    rbx
  40eb39:	41 5c                	pop    r12
  40eb3b:	41 5d                	pop    r13
  40eb3d:	41 5e                	pop    r14
  40eb3f:	41 5f                	pop    r15
  40eb41:	5d                   	pop    rbp
  40eb42:	c3                   	ret    
  40eb43:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
			retaddr = __bump_mem_expand_range(meta, ci->pgtbl_cap, heap_vaddr, sz, pgtbl_lvl | pgtbl_flag);
  40eb48:	44 8b 45 c4          	mov    r8d,DWORD PTR [rbp-0x3c]
  40eb4c:	48 8b 33             	mov    rsi,QWORD PTR [rbx]
  40eb4f:	4c 89 4d a0          	mov    QWORD PTR [rbp-0x60],r9
  40eb53:	4c 89 e1             	mov    rcx,r12
  40eb56:	4c 89 5d a8          	mov    QWORD PTR [rbp-0x58],r11
  40eb5a:	48 8b 7d b8          	mov    rdi,QWORD PTR [rbp-0x48]
  40eb5e:	48 b8 40 e7 40 00 00 	movabs rax,0x40e740
  40eb65:	00 00 00 
  40eb68:	45 09 f0             	or     r8d,r14d
  40eb6b:	48 89 55 b0          	mov    QWORD PTR [rbp-0x50],rdx
  40eb6f:	ff d0                	call   rax
			assert(retaddr);
  40eb71:	48 85 c0             	test   rax,rax
  40eb74:	0f 84 e5 00 00 00    	je     40ec5f <__page_bump_valloc+0x21f>
		return round_up_to_pgt1_page(vaddr);
  40eb7a:	4c 8b 4d a0          	mov    r9,QWORD PTR [rbp-0x60]
  40eb7e:	4d 8d 56 08          	lea    r10,[r14+0x8]
  40eb82:	4c 8b 5d a8          	mov    r11,QWORD PTR [rbp-0x58]
				tmp_frontier = cos_pgtbl_round_up_to_page(pgtbl_lvl, heap_vaddr + sz);
  40eb86:	45 89 f0             	mov    r8d,r14d
  40eb89:	48 8b 55 b0          	mov    rdx,QWORD PTR [rbp-0x50]
		return round_up_to_pgt1_page(vaddr);
  40eb8d:	49 8d 81 ff ff ff 3f 	lea    rax,[r9+0x3fffffff]
		return round_up_to_pgt2_page(vaddr);
  40eb94:	49 8d b1 ff ff 1f 00 	lea    rsi,[r9+0x1fffff]
		return round_up_to_pgt1_page(vaddr);
  40eb9b:	48 25 00 00 00 c0    	and    rax,0xffffffffc0000000
		return round_up_to_pgt2_page(vaddr);
  40eba1:	48 81 e6 00 00 e0 ff 	and    rsi,0xffffffffffe00000
		return round_up_to_pgt1_page(vaddr);
  40eba8:	48 89 c7             	mov    rdi,rax
				vaddr_t tmp = ps_load(&ci->vasrange_frontier[pgtbl_lvl]);
  40ebab:	4a 8b 44 d3 08       	mov    rax,QWORD PTR [rbx+r10*8+0x8]
		return round_up_to_pgt1_page(vaddr);
  40ebb0:	48 89 f9             	mov    rcx,rdi
	switch (pgtbl_lvl)
  40ebb3:	49 83 fe 01          	cmp    r14,0x1
  40ebb7:	74 0c                	je     40ebc5 <__page_bump_valloc+0x185>
		return round_up_to_pgt0_page(vaddr);
  40ebb9:	48 8b 4d c8          	mov    rcx,QWORD PTR [rbp-0x38]
	switch (pgtbl_lvl)
  40ebbd:	41 83 f8 02          	cmp    r8d,0x2
		return round_up_to_pgt0_page(vaddr);
  40ebc1:	48 0f 44 ce          	cmove  rcx,rsi
				if (tmp >= heap_vaddr + sz) break;
  40ebc5:	49 39 c1             	cmp    r9,rax
  40ebc8:	0f 86 35 ff ff ff    	jbe    40eb03 <__page_bump_valloc+0xc3>
        __asm__ __volatile__("lock " PS_CAS_STR
  40ebce:	f0 49 0f b1 4d 00    	lock cmpxchg QWORD PTR [r13+0x0],rcx
  40ebd4:	0f 94 c0             	sete   al
				vaddr_t tmp = ps_load(&ci->vasrange_frontier[pgtbl_lvl]);
  40ebd7:	4a 8b 44 d3 08       	mov    rax,QWORD PTR [rbx+r10*8+0x8]
		return round_up_to_pgt1_page(vaddr);
  40ebdc:	48 89 f9             	mov    rcx,rdi
	switch (pgtbl_lvl)
  40ebdf:	49 83 fe 01          	cmp    r14,0x1
  40ebe3:	75 d4                	jne    40ebb9 <__page_bump_valloc+0x179>
  40ebe5:	eb de                	jmp    40ebc5 <__page_bump_valloc+0x185>
  40ebe7:	48 bf 00 04 42 00 00 	movabs rdi,0x420400
  40ebee:	00 00 00 
  40ebf1:	be 2e 00 00 00       	mov    esi,0x2e
  40ebf6:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40ebfd:	00 00 00 
  40ec00:	ff d0                	call   rax
	assert(sz % PAGE_SIZE == 0);
  40ec02:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ec09:	00 00 00 00 
  40ec0d:	0f 0b                	ud2    
  40ec0f:	48 bf 30 04 42 00 00 	movabs rdi,0x420430
  40ec16:	00 00 00 
  40ec19:	be 2e 00 00 00       	mov    esi,0x2e
  40ec1e:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40ec25:	00 00 00 
  40ec28:	ff d0                	call   rax
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  40ec2a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ec31:	00 00 00 00 
  40ec35:	0f 0b                	ud2    
  40ec37:	48 bf 90 04 42 00 00 	movabs rdi,0x420490
  40ec3e:	00 00 00 
  40ec41:	be 2e 00 00 00       	mov    esi,0x2e
  40ec46:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40ec4d:	00 00 00 
  40ec50:	ff d0                	call   rax
	assert(ret_addr % align == 0);
  40ec52:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ec59:	00 00 00 00 
  40ec5d:	0f 0b                	ud2    
  40ec5f:	48 bf 60 04 42 00 00 	movabs rdi,0x420460
  40ec66:	00 00 00 
  40ec69:	be 2e 00 00 00       	mov    esi,0x2e
  40ec6e:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40ec75:	00 00 00 
  40ec78:	ff d0                	call   rax
			assert(retaddr);
  40ec7a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ec81:	00 00 00 00 
  40ec85:	0f 0b                	ud2    
  40ec87:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40ec8e:	00 00 

000000000040ec90 <__page_bump_alloc>:

static vaddr_t
__page_bump_alloc(struct cos_compinfo *ci, size_t sz, size_t align)
{
  40ec90:	f3 0f 1e fa          	endbr64 
  40ec94:	55                   	push   rbp
  40ec95:	48 89 e5             	mov    rbp,rsp
  40ec98:	41 57                	push   r15
  40ec9a:	49 89 ff             	mov    r15,rdi
  40ec9d:	41 56                	push   r14
  40ec9f:	41 55                	push   r13
  40eca1:	41 54                	push   r12
  40eca3:	53                   	push   rbx
  40eca4:	48 89 f3             	mov    rbx,rsi
  40eca7:	48 83 ec 48          	sub    rsp,0x48
	return ci->memsrc;
  40ecab:	48 8b 47 60          	mov    rax,QWORD PTR [rdi+0x60]
  40ecaf:	48 89 45 a8          	mov    QWORD PTR [rbp-0x58],rax

	/*
	 * Allocate the virtual address range to map into.  This is
	 * atomic, so we will get a contiguous range of sz.
	 */
	heap_vaddr = __page_bump_valloc(ci, sz, align);
  40ecb3:	48 b8 40 ea 40 00 00 	movabs rax,0x40ea40
  40ecba:	00 00 00 
  40ecbd:	ff d0                	call   rax
  40ecbf:	48 89 45 98          	mov    QWORD PTR [rbp-0x68],rax
	if (unlikely(!heap_vaddr)) return 0;
  40ecc3:	48 85 c0             	test   rax,rax
  40ecc6:	0f 84 ef 01 00 00    	je     40eebb <__page_bump_alloc+0x22b>
  40eccc:	48 89 c7             	mov    rdi,rax
	heap_limit = heap_vaddr + sz;
  40eccf:	48 89 d8             	mov    rax,rbx
  40ecd2:	48 01 f8             	add    rax,rdi
  40ecd5:	48 89 7d b8          	mov    QWORD PTR [rbp-0x48],rdi
  40ecd9:	48 89 45 a0          	mov    QWORD PTR [rbp-0x60],rax
	assert(heap_limit > heap_vaddr);
  40ecdd:	48 39 c7             	cmp    rdi,rax
  40ece0:	0f 83 f0 01 00 00    	jae    40eed6 <__page_bump_alloc+0x246>
	return ci->memsrc;
  40ece6:	4d 8b 77 60          	mov    r14,QWORD PTR [r15+0x60]
  40ecea:	41 bd 01 00 00 00    	mov    r13d,0x1
  40ecf0:	45 31 d2             	xor    r10d,r10d
	assert(ci && ci == __compinfo_metacap(__ci));
  40ecf3:	4d 85 f6             	test   r14,r14
  40ecf6:	0f 84 79 01 00 00    	je     40ee75 <__page_bump_alloc+0x1e5>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40ecfc:	49 8d 96 b8 00 00 00 	lea    rdx,[r14+0xb8]
  40ed03:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  40ed08:	4c 89 d0             	mov    rax,r10
  40ed0b:	f0 4c 0f b1 2a       	lock cmpxchg QWORD PTR [rdx],r13
  40ed10:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40ed13:	84 c0                	test   al,al
  40ed15:	74 f1                	je     40ed08 <__page_bump_alloc+0x78>
        __asm__ __volatile__("lock " PS_FAA_STR
  40ed17:	bb 00 10 00 00       	mov    ebx,0x1000
  40ed1c:	f0 49 0f c1 5e 70    	lock xadd QWORD PTR [r14+0x70],rbx
	if (ret >= *frontier || *frontier - ret > RETYPE_MEM_SIZE) {
  40ed22:	49 8b 96 88 00 00 00 	mov    rdx,QWORD PTR [r14+0x88]
  40ed29:	48 39 d3             	cmp    rbx,rdx
  40ed2c:	73 0e                	jae    40ed3c <__page_bump_alloc+0xac>
  40ed2e:	48 89 d0             	mov    rax,rdx
  40ed31:	48 29 d8             	sub    rax,rbx
  40ed34:	48 3d 00 10 00 00    	cmp    rax,0x1000
  40ed3a:	76 43                	jbe    40ed7f <__page_bump_alloc+0xef>
		vaddr_t ptr_tmp = *ptr, front_tmp = *frontier;
  40ed3c:	49 8b 46 70          	mov    rax,QWORD PTR [r14+0x70]
		if (ci->mi.untyped_ptr == ci->mi.untyped_frontier) goto error;
  40ed40:	49 8b 8e 80 00 00 00 	mov    rcx,QWORD PTR [r14+0x80]
  40ed47:	49 39 4e 68          	cmp    QWORD PTR [r14+0x68],rcx
  40ed4b:	0f 84 5f 01 00 00    	je     40eeb0 <__page_bump_alloc+0x220>
  40ed51:	bb 00 10 00 00       	mov    ebx,0x1000
  40ed56:	f0 49 0f c1 5e 68    	lock xadd QWORD PTR [r14+0x68],rbx
		if (ps_cas(ptr, ptr_tmp, ret + PAGE_SIZE)) {
  40ed5c:	48 8d 8b 00 10 00 00 	lea    rcx,[rbx+0x1000]
        __asm__ __volatile__("lock " PS_CAS_STR
  40ed63:	f0 49 0f b1 4e 70    	lock cmpxchg QWORD PTR [r14+0x70],rcx
  40ed69:	0f 94 c0             	sete   al
  40ed6c:	84 c0                	test   al,al
  40ed6e:	74 0f                	je     40ed7f <__page_bump_alloc+0xef>
  40ed70:	48 89 d0             	mov    rax,rdx
  40ed73:	f0 49 0f b1 8e 88 00 	lock cmpxchg QWORD PTR [r14+0x88],rcx
  40ed7a:	00 00 
  40ed7c:	0f 94 c0             	sete   al
	if (retype && (ret % RETYPE_MEM_SIZE == 0)) {
  40ed7f:	48 89 da             	mov    rdx,rbx
  40ed82:	81 e2 ff 0f 00 00    	and    edx,0xfff
  40ed88:	0f 85 12 01 00 00    	jne    40eea0 <__page_bump_alloc+0x210>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40ed8e:	41 8b 86 98 00 00 00 	mov    eax,DWORD PTR [r14+0x98]
	__asm__ __volatile__(
  40ed95:	48 89 d6             	mov    rsi,rdx
  40ed98:	48 89 d7             	mov    rdi,rdx
  40ed9b:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40ed9f:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40eda2:	05 19 00 01 00       	add    eax,0x10019
	__asm__ __volatile__(
  40eda7:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40edaa:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40edae:	48 89 cd             	mov    rbp,rcx
  40edb1:	49 b8 c8 ed 40 00 00 	movabs r8,0x40edc8
  40edb8:	00 00 00 
  40edbb:	0f 05                	syscall 
  40edbd:	0f 1f 00             	nop    DWORD PTR [rax]
  40edc0:	eb 0d                	jmp    40edcf <__page_bump_alloc+0x13f>
  40edc2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40edc8:	b9 00 00 00 00       	mov    ecx,0x0
  40edcd:	eb 05                	jmp    40edd4 <__page_bump_alloc+0x144>
  40edcf:	b9 01 00 00 00       	mov    ecx,0x1
  40edd4:	5d                   	pop    rbp
  40edd5:	5c                   	pop    rsp
		if (call_cap_op(ci->mi.pgtbl_cap, op, ret, 0, 0, 0)) goto error;
  40edd6:	85 c0                	test   eax,eax
  40edd8:	0f 85 d2 00 00 00    	jne    40eeb0 <__page_bump_alloc+0x220>
{ l->o = 0; }
  40edde:	49 c7 86 b8 00 00 00 	mov    QWORD PTR [r14+0xb8],0x0
  40ede5:	00 00 00 00 
	 */
	for (heap_cursor = heap_vaddr; heap_cursor < heap_limit; heap_cursor += PAGE_SIZE) {
		vaddr_t umem;

		umem = __umem_bump_alloc(ci);
		if (!umem) return 0;
  40ede9:	48 85 db             	test   rbx,rbx
  40edec:	0f 84 c9 00 00 00    	je     40eebb <__page_bump_alloc+0x22b>

		/* Actually map in the memory. */
		if (call_cap_op(meta->mi.pgtbl_cap, CAPTBL_OP_MEMACTIVATE, umem, ci->pgtbl_cap, heap_cursor, PAGE_ORDER)) {
  40edf2:	48 8b 45 a8          	mov    rax,QWORD PTR [rbp-0x58]
  40edf6:	49 8b 37             	mov    rsi,QWORD PTR [r15]
  40edf9:	ba 0c 00 00 00       	mov    edx,0xc
  40edfe:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  40ee02:	48 8b 7d b8          	mov    rdi,QWORD PTR [rbp-0x48]
  40ee06:	48 8b 80 98 00 00 00 	mov    rax,QWORD PTR [rax+0x98]
  40ee0d:	48 89 45 b0          	mov    QWORD PTR [rbp-0x50],rax
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40ee11:	8b 45 b0             	mov    eax,DWORD PTR [rbp-0x50]
  40ee14:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40ee17:	05 17 00 01 00       	add    eax,0x10017
	__asm__ __volatile__(
  40ee1c:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40ee1f:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40ee23:	48 89 cd             	mov    rbp,rcx
  40ee26:	49 b8 40 ee 40 00 00 	movabs r8,0x40ee40
  40ee2d:	00 00 00 
  40ee30:	0f 05                	syscall 
  40ee32:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40ee38:	eb 0d                	jmp    40ee47 <__page_bump_alloc+0x1b7>
  40ee3a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40ee40:	b9 00 00 00 00       	mov    ecx,0x0
  40ee45:	eb 05                	jmp    40ee4c <__page_bump_alloc+0x1bc>
  40ee47:	b9 01 00 00 00       	mov    ecx,0x1
  40ee4c:	5d                   	pop    rbp
  40ee4d:	5c                   	pop    rsp
  40ee4e:	85 c0                	test   eax,eax
  40ee50:	0f 85 a8 00 00 00    	jne    40eefe <__page_bump_alloc+0x26e>
	for (heap_cursor = heap_vaddr; heap_cursor < heap_limit; heap_cursor += PAGE_SIZE) {
  40ee56:	48 81 45 b8 00 10 00 	add    QWORD PTR [rbp-0x48],0x1000
  40ee5d:	00 
  40ee5e:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  40ee62:	48 39 45 a0          	cmp    QWORD PTR [rbp-0x60],rax
  40ee66:	76 5b                	jbe    40eec3 <__page_bump_alloc+0x233>
	return ci->memsrc;
  40ee68:	4d 8b 77 60          	mov    r14,QWORD PTR [r15+0x60]
	assert(ci && ci == __compinfo_metacap(__ci));
  40ee6c:	4d 85 f6             	test   r14,r14
  40ee6f:	0f 85 87 fe ff ff    	jne    40ecfc <__page_bump_alloc+0x6c>
  40ee75:	48 bf c0 01 42 00 00 	movabs rdi,0x4201c0
  40ee7c:	00 00 00 
  40ee7f:	be 2e 00 00 00       	mov    esi,0x2e
  40ee84:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40ee8b:	00 00 00 
  40ee8e:	ff d0                	call   rax
  40ee90:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ee97:	00 00 00 00 
  40ee9b:	0f 0b                	ud2    
  40ee9d:	0f 1f 00             	nop    DWORD PTR [rax]
  40eea0:	49 c7 86 b8 00 00 00 	mov    QWORD PTR [r14+0xb8],0x0
  40eea7:	00 00 00 00 
		if (!umem) return 0;
  40eeab:	e9 42 ff ff ff       	jmp    40edf2 <__page_bump_alloc+0x162>
  40eeb0:	49 c7 86 b8 00 00 00 	mov    QWORD PTR [r14+0xb8],0x0
  40eeb7:	00 00 00 00 
  40eebb:	48 c7 45 98 00 00 00 	mov    QWORD PTR [rbp-0x68],0x0
  40eec2:	00 
			return 0;
		}
	}

	return heap_vaddr;
}
  40eec3:	48 8b 45 98          	mov    rax,QWORD PTR [rbp-0x68]
  40eec7:	48 83 c4 48          	add    rsp,0x48
  40eecb:	5b                   	pop    rbx
  40eecc:	41 5c                	pop    r12
  40eece:	41 5d                	pop    r13
  40eed0:	41 5e                	pop    r14
  40eed2:	41 5f                	pop    r15
  40eed4:	5d                   	pop    rbp
  40eed5:	c3                   	ret    
  40eed6:	48 bf c0 04 42 00 00 	movabs rdi,0x4204c0
  40eedd:	00 00 00 
  40eee0:	be 2e 00 00 00       	mov    esi,0x2e
  40eee5:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40eeec:	00 00 00 
  40eeef:	ff d0                	call   rax
	assert(heap_limit > heap_vaddr);
  40eef1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40eef8:	00 00 00 00 
  40eefc:	0f 0b                	ud2    
  40eefe:	48 bf f0 04 42 00 00 	movabs rdi,0x4204f0
  40ef05:	00 00 00 
  40ef08:	be 2e 00 00 00       	mov    esi,0x2e
  40ef0d:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40ef14:	00 00 00 
  40ef17:	ff d0                	call   rax
			assert(0);
  40ef19:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ef20:	00 00 00 00 
  40ef24:	0f 0b                	ud2    
  40ef26:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40ef2d:	00 00 00 

000000000040ef30 <__bump_mem_expand_intern>:
{
  40ef30:	f3 0f 1e fa          	endbr64 
  40ef34:	55                   	push   rbp
  40ef35:	48 89 e5             	mov    rbp,rsp
  40ef38:	41 57                	push   r15
  40ef3a:	41 56                	push   r14
  40ef3c:	41 55                	push   r13
  40ef3e:	41 54                	push   r12
  40ef40:	53                   	push   rbx
  40ef41:	48 83 ec 28          	sub    rsp,0x28
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  40ef45:	48 3b 7f 60          	cmp    rdi,QWORD PTR [rdi+0x60]
  40ef49:	0f 85 dd 01 00 00    	jne    40f12c <__bump_mem_expand_intern+0x1fc>
  40ef4f:	49 89 f6             	mov    r14,rsi
  40ef52:	49 89 d7             	mov    r15,rdx
  40ef55:	4c 8d 55 c0          	lea    r10,[rbp-0x40]
  40ef59:	49 89 cd             	mov    r13,rcx
	if (!intern) {
  40ef5c:	48 85 c9             	test   rcx,rcx
  40ef5f:	0f 85 cd 00 00 00    	jne    40f032 <__bump_mem_expand_intern+0x102>
  40ef65:	49 89 fc             	mov    r12,rdi
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40ef68:	48 8d 97 b0 00 00 00 	lea    rdx,[rdi+0xb0]
        __asm__ __volatile__("lock " PS_CAS_STR
  40ef6f:	be 01 00 00 00       	mov    esi,0x1
  40ef74:	31 c9                	xor    ecx,ecx
  40ef76:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40ef7d:	00 00 00 
  40ef80:	48 89 c8             	mov    rax,rcx
  40ef83:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40ef88:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40ef8b:	84 c0                	test   al,al
  40ef8d:	74 f1                	je     40ef80 <__bump_mem_expand_intern+0x50>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40ef8f:	41 f6 44 24 38 03    	test   BYTE PTR [r12+0x38],0x3
  40ef95:	0f 84 60 01 00 00    	je     40f0fb <__bump_mem_expand_intern+0x1cb>
  40ef9b:	4c 89 45 b8          	mov    QWORD PTR [rbp-0x48],r8
        __asm__ __volatile__("lock " PS_FAA_STR
  40ef9f:	bb 04 00 00 00       	mov    ebx,0x4
  40efa4:	f0 49 0f c1 5c 24 38 	lock xadd QWORD PTR [r12+0x38],rbx
	return __mem_bump_alloc(ci, 1, 1);
  40efab:	48 b8 b0 e2 40 00 00 	movabs rax,0x40e2b0
  40efb2:	00 00 00 
  40efb5:	4c 89 e7             	mov    rdi,r12
	ret = ps_faa(capsz_frontier, sz);
  40efb8:	49 89 dd             	mov    r13,rbx
{ l->o = 0; }
  40efbb:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40efc2:	00 00 00 00 00 
	return __mem_bump_alloc(ci, 1, 1);
  40efc7:	ff d0                	call   rax
  40efc9:	48 89 c7             	mov    rdi,rax
		if (pte_cap == 0 || ptemem_cap == 0) {
  40efcc:	48 85 db             	test   rbx,rbx
  40efcf:	0f 84 fe 00 00 00    	je     40f0d3 <__bump_mem_expand_intern+0x1a3>
  40efd5:	48 85 c0             	test   rax,rax
  40efd8:	4c 8b 45 b8          	mov    r8,QWORD PTR [rbp-0x48]
  40efdc:	0f 84 f1 00 00 00    	je     40f0d3 <__bump_mem_expand_intern+0x1a3>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40efe2:	41 8b 44 24 08       	mov    eax,DWORD PTR [r12+0x8]
	__asm__ __volatile__(
  40efe7:	4c 8d 55 c0          	lea    r10,[rbp-0x40]
  40efeb:	49 8b b4 24 98 00 00 	mov    rsi,QWORD PTR [r12+0x98]
  40eff2:	00 
		if (call_cap_op(meta->captbl_cap, CAPTBL_OP_PGTBLACTIVATE, pte_cap, meta->mi.pgtbl_cap, ptemem_cap,
  40eff3:	49 8d 50 01          	lea    rdx,[r8+0x1]
  40eff7:	4c 89 d1             	mov    rcx,r10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40effa:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40effd:	05 1c 00 01 00       	add    eax,0x1001c
	__asm__ __volatile__(
  40f002:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40f005:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40f009:	48 89 cd             	mov    rbp,rcx
  40f00c:	49 b8 20 f0 40 00 00 	movabs r8,0x40f020
  40f013:	00 00 00 
  40f016:	0f 05                	syscall 
  40f018:	eb 0d                	jmp    40f027 <__bump_mem_expand_intern+0xf7>
  40f01a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40f020:	b9 00 00 00 00       	mov    ecx,0x0
  40f025:	eb 05                	jmp    40f02c <__bump_mem_expand_intern+0xfc>
  40f027:	b9 01 00 00 00       	mov    ecx,0x1
  40f02c:	5d                   	pop    rbp
  40f02d:	5c                   	pop    rsp
  40f02e:	85 c0                	test   eax,eax
  40f030:	75 5e                	jne    40f090 <__bump_mem_expand_intern+0x160>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f032:	41 c1 e6 10          	shl    r14d,0x10
	__asm__ __volatile__(
  40f036:	31 d2                	xor    edx,edx
  40f038:	4c 89 eb             	mov    rbx,r13
  40f03b:	4c 89 fe             	mov    rsi,r15
	cap_no += op;
  40f03e:	41 8d 86 01 00 01 00 	lea    eax,[r14+0x10001]
	__asm__ __volatile__(
  40f045:	48 89 d7             	mov    rdi,rdx
  40f048:	4c 89 d1             	mov    rcx,r10
  40f04b:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40f04e:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40f052:	48 89 cd             	mov    rbp,rcx
  40f055:	49 b8 70 f0 40 00 00 	movabs r8,0x40f070
  40f05c:	00 00 00 
  40f05f:	0f 05                	syscall 
  40f061:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  40f068:	eb 0d                	jmp    40f077 <__bump_mem_expand_intern+0x147>
  40f06a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40f070:	b9 00 00 00 00       	mov    ecx,0x0
  40f075:	eb 05                	jmp    40f07c <__bump_mem_expand_intern+0x14c>
  40f077:	b9 01 00 00 00       	mov    ecx,0x1
  40f07c:	5d                   	pop    rbp
  40f07d:	5c                   	pop    rsp
}
  40f07e:	48 83 c4 28          	add    rsp,0x28
  40f082:	4c 89 e8             	mov    rax,r13
  40f085:	5b                   	pop    rbx
  40f086:	41 5c                	pop    r12
  40f088:	41 5d                	pop    r13
  40f08a:	41 5e                	pop    r14
  40f08c:	41 5f                	pop    r15
  40f08e:	5d                   	pop    rbp
  40f08f:	c3                   	ret    
  40f090:	48 bf d0 03 42 00 00 	movabs rdi,0x4203d0
  40f097:	00 00 00 
  40f09a:	be 2e 00 00 00       	mov    esi,0x2e
  40f09f:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40f0a6:	00 00 00 
  40f0a9:	ff d0                	call   rax
				assert(0); /* race? */
  40f0ab:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f0b2:	00 00 00 00 
  40f0b6:	0f 0b                	ud2    
  40f0b8:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  40f0bf:	00 00 00 00 00 
	return __mem_bump_alloc(ci, 1, 1);
  40f0c4:	4c 89 e7             	mov    rdi,r12
  40f0c7:	48 b8 b0 e2 40 00 00 	movabs rax,0x40e2b0
  40f0ce:	00 00 00 
  40f0d1:	ff d0                	call   rax
  40f0d3:	48 bf a0 03 42 00 00 	movabs rdi,0x4203a0
  40f0da:	00 00 00 
  40f0dd:	be 2e 00 00 00       	mov    esi,0x2e
  40f0e2:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40f0e9:	00 00 00 
  40f0ec:	ff d0                	call   rax
			assert(0);
  40f0ee:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f0f5:	00 00 00 00 
  40f0f9:	0f 0b                	ud2    
  40f0fb:	4c 89 45 b8          	mov    QWORD PTR [rbp-0x48],r8
		if (__capid_captbl_check_expand(ci)) goto error;
  40f0ff:	4c 89 e7             	mov    rdi,r12
  40f102:	48 b8 50 e4 40 00 00 	movabs rax,0x40e450
  40f109:	00 00 00 
  40f10c:	ff d0                	call   rax
  40f10e:	4c 8b 45 b8          	mov    r8,QWORD PTR [rbp-0x48]
  40f112:	85 c0                	test   eax,eax
  40f114:	75 a2                	jne    40f0b8 <__bump_mem_expand_intern+0x188>
        __asm__ __volatile__("lock " PS_FAA_STR
  40f116:	b8 04 00 00 00       	mov    eax,0x4
  40f11b:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40f122:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  40f127:	e9 6f fe ff ff       	jmp    40ef9b <__bump_mem_expand_intern+0x6b>
  40f12c:	48 bf 70 03 42 00 00 	movabs rdi,0x420370
  40f133:	00 00 00 
  40f136:	be 2e 00 00 00       	mov    esi,0x2e
  40f13b:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40f142:	00 00 00 
  40f145:	ff d0                	call   rax
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  40f147:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f14e:	00 00 00 00 
  40f152:	0f 0b                	ud2    
  40f154:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40f15b:	00 00 00 00 
  40f15f:	90                   	nop

000000000040f160 <__round_to_pgt0_page>:
vaddr_t __round_to_pgt0_page(vaddr_t vaddr) { return round_to_pgt0_page(vaddr); }
  40f160:	f3 0f 1e fa          	endbr64 
  40f164:	48 b8 00 00 00 00 80 	movabs rax,0xffffff8000000000
  40f16b:	ff ff ff 
  40f16e:	48 21 f8             	and    rax,rdi
  40f171:	c3                   	ret    
  40f172:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40f179:	00 00 00 00 
  40f17d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040f180 <__round_up_to_pgt0_page>:
vaddr_t __round_up_to_pgt0_page(vaddr_t vaddr) { return round_up_to_pgt0_page(vaddr); }
  40f180:	f3 0f 1e fa          	endbr64 
  40f184:	48 b8 ff ff ff ff 7f 	movabs rax,0x7fffffffff
  40f18b:	00 00 00 
  40f18e:	48 ba 00 00 00 00 80 	movabs rdx,0xffffff8000000000
  40f195:	ff ff ff 
  40f198:	48 01 f8             	add    rax,rdi
  40f19b:	48 21 d0             	and    rax,rdx
  40f19e:	c3                   	ret    
  40f19f:	90                   	nop

000000000040f1a0 <__round_to_pgt1_page>:
vaddr_t __round_to_pgt1_page(vaddr_t vaddr) { return round_to_pgt1_page(vaddr); }
  40f1a0:	f3 0f 1e fa          	endbr64 
  40f1a4:	48 89 f8             	mov    rax,rdi
  40f1a7:	48 25 00 00 00 c0    	and    rax,0xffffffffc0000000
  40f1ad:	c3                   	ret    
  40f1ae:	66 90                	xchg   ax,ax

000000000040f1b0 <__round_up_to_pgt1_page>:
vaddr_t __round_up_to_pgt1_page(vaddr_t vaddr) { return round_up_to_pgt1_page(vaddr); }
  40f1b0:	f3 0f 1e fa          	endbr64 
  40f1b4:	48 8d 87 ff ff ff 3f 	lea    rax,[rdi+0x3fffffff]
  40f1bb:	48 25 00 00 00 c0    	and    rax,0xffffffffc0000000
  40f1c1:	c3                   	ret    
  40f1c2:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40f1c9:	00 00 00 00 
  40f1cd:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040f1d0 <__round_to_pgt2_page>:
vaddr_t __round_to_pgt2_page(vaddr_t vaddr) { return round_to_pgt2_page(vaddr); }
  40f1d0:	f3 0f 1e fa          	endbr64 
  40f1d4:	48 89 f8             	mov    rax,rdi
  40f1d7:	48 25 00 00 e0 ff    	and    rax,0xffffffffffe00000
  40f1dd:	c3                   	ret    
  40f1de:	66 90                	xchg   ax,ax

000000000040f1e0 <__round_up_to_pgt2_page>:
vaddr_t __round_up_to_pgt2_page(vaddr_t vaddr) { return round_up_to_pgt2_page(vaddr); }
  40f1e0:	f3 0f 1e fa          	endbr64 
  40f1e4:	48 8d 87 ff ff 1f 00 	lea    rax,[rdi+0x1fffff]
  40f1eb:	48 25 00 00 e0 ff    	and    rax,0xffffffffffe00000
  40f1f1:	c3                   	ret    
  40f1f2:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40f1f9:	00 00 00 00 
  40f1fd:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040f200 <cos_pgtbl_get_range>:
{
  40f200:	f3 0f 1e fa          	endbr64 
  40f204:	31 c0                	xor    eax,eax
  40f206:	83 ff 02             	cmp    edi,0x2
  40f209:	77 10                	ja     40f21b <cos_pgtbl_get_range+0x1b>
  40f20b:	48 b8 30 15 42 00 00 	movabs rax,0x421530
  40f212:	00 00 00 
  40f215:	89 ff                	mov    edi,edi
  40f217:	48 8b 04 f8          	mov    rax,QWORD PTR [rax+rdi*8]
}
  40f21b:	c3                   	ret    
  40f21c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000040f220 <cos_pgtbl_round_to_page>:
{
  40f220:	f3 0f 1e fa          	endbr64 
		return round_to_pgt1_page(vaddr);
  40f224:	48 89 f0             	mov    rax,rsi
  40f227:	48 25 00 00 00 c0    	and    rax,0xffffffffc0000000
	switch (pgtbl_lvl)
  40f22d:	83 ff 01             	cmp    edi,0x1
  40f230:	74 14                	je     40f246 <cos_pgtbl_round_to_page+0x26>
		return round_to_pgt2_page(vaddr);
  40f232:	48 89 f0             	mov    rax,rsi
  40f235:	48 25 00 00 e0 ff    	and    rax,0xffffffffffe00000
	switch (pgtbl_lvl)
  40f23b:	83 ff 02             	cmp    edi,0x2
  40f23e:	74 06                	je     40f246 <cos_pgtbl_round_to_page+0x26>
  40f240:	31 c0                	xor    eax,eax
  40f242:	85 ff                	test   edi,edi
  40f244:	74 0a                	je     40f250 <cos_pgtbl_round_to_page+0x30>
}
  40f246:	c3                   	ret    
  40f247:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40f24e:	00 00 
		return round_to_pgt0_page(vaddr);
  40f250:	48 b8 00 00 00 00 80 	movabs rax,0xffffff8000000000
  40f257:	ff ff ff 
  40f25a:	48 21 f0             	and    rax,rsi
}
  40f25d:	c3                   	ret    
  40f25e:	66 90                	xchg   ax,ax

000000000040f260 <cos_pgtbl_round_up_to_page>:
{
  40f260:	f3 0f 1e fa          	endbr64 
	switch (pgtbl_lvl)
  40f264:	83 ff 01             	cmp    edi,0x1
  40f267:	74 47                	je     40f2b0 <cos_pgtbl_round_up_to_page+0x50>
  40f269:	83 ff 02             	cmp    edi,0x2
  40f26c:	74 2a                	je     40f298 <cos_pgtbl_round_up_to_page+0x38>
  40f26e:	31 c0                	xor    eax,eax
  40f270:	85 ff                	test   edi,edi
  40f272:	74 04                	je     40f278 <cos_pgtbl_round_up_to_page+0x18>
}
  40f274:	c3                   	ret    
  40f275:	0f 1f 00             	nop    DWORD PTR [rax]
		return round_up_to_pgt0_page(vaddr);
  40f278:	48 b8 ff ff ff ff 7f 	movabs rax,0x7fffffffff
  40f27f:	00 00 00 
  40f282:	48 ba 00 00 00 00 80 	movabs rdx,0xffffff8000000000
  40f289:	ff ff ff 
  40f28c:	48 01 f0             	add    rax,rsi
  40f28f:	48 21 d0             	and    rax,rdx
  40f292:	c3                   	ret    
  40f293:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		return round_up_to_pgt2_page(vaddr);
  40f298:	48 8d 86 ff ff 1f 00 	lea    rax,[rsi+0x1fffff]
  40f29f:	48 25 00 00 e0 ff    	and    rax,0xffffffffffe00000
}
  40f2a5:	c3                   	ret    
  40f2a6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40f2ad:	00 00 00 
		return round_up_to_pgt1_page(vaddr);
  40f2b0:	48 8d 86 ff ff ff 3f 	lea    rax,[rsi+0x3fffffff]
  40f2b7:	48 25 00 00 00 c0    	and    rax,0xffffffffc0000000
  40f2bd:	c3                   	ret    
  40f2be:	66 90                	xchg   ax,ax

000000000040f2c0 <cos_meminfo_init>:
{
  40f2c0:	f3 0f 1e fa          	endbr64 
	mi->untyped_frontier = untyped_ptr + untyped_sz;
  40f2c4:	48 01 f2             	add    rdx,rsi
  40f2c7:	66 48 0f 6e ce       	movq   xmm1,rsi
	mi->untyped_ptr = mi->umem_ptr = mi->kmem_ptr = mi->umem_frontier = mi->kmem_frontier = untyped_ptr;
  40f2cc:	66 48 0f 6e c6       	movq   xmm0,rsi
	mi->pgtbl_cap        = pgtbl_cap;
  40f2d1:	48 89 4f 30          	mov    QWORD PTR [rdi+0x30],rcx
	mi->untyped_ptr = mi->umem_ptr = mi->kmem_ptr = mi->umem_frontier = mi->kmem_frontier = untyped_ptr;
  40f2d5:	66 48 0f 6e d2       	movq   xmm2,rdx
  40f2da:	66 0f 6c c9          	punpcklqdq xmm1,xmm1
  40f2de:	66 0f 6c c2          	punpcklqdq xmm0,xmm2
  40f2e2:	0f 11 0f             	movups XMMWORD PTR [rdi],xmm1
  40f2e5:	0f 11 47 10          	movups XMMWORD PTR [rdi+0x10],xmm0
  40f2e9:	0f 11 4f 20          	movups XMMWORD PTR [rdi+0x20],xmm1
}
  40f2ed:	c3                   	ret    
  40f2ee:	66 90                	xchg   ax,ax

000000000040f2f0 <cos_compinfo_init>:
{
  40f2f0:	f3 0f 1e fa          	endbr64 
  40f2f4:	55                   	push   rbp
  40f2f5:	49 89 d2             	mov    r10,rdx
  40f2f8:	66 48 0f 6e c6       	movq   xmm0,rsi
  40f2fd:	66 49 0f 6e d2       	movq   xmm2,r10
  40f302:	66 0f 6c c2          	punpcklqdq xmm0,xmm2
  40f306:	48 89 e5             	mov    rbp,rsp
  40f309:	48 8b 55 10          	mov    rdx,QWORD PTR [rbp+0x10]
	assert(ci && ci_resources);
  40f30d:	48 85 ff             	test   rdi,rdi
  40f310:	0f 84 19 01 00 00    	je     40f42f <cos_compinfo_init+0x13f>
  40f316:	48 85 d2             	test   rdx,rdx
  40f319:	0f 84 10 01 00 00    	je     40f42f <cos_compinfo_init+0x13f>
	assert(cap_frontier % CAPMAX_ENTRY_SZ == 0);
  40f31f:	41 f6 c1 03          	test   r9b,0x3
  40f323:	0f 85 2e 01 00 00    	jne    40f457 <cos_compinfo_init+0x167>
	ci->memsrc = ci_resources;
  40f329:	48 89 57 60          	mov    QWORD PTR [rdi+0x60],rdx
  40f32d:	48 89 f8             	mov    rax,rdi
	assert(ci_resources->memsrc == ci_resources); /* prevent infinite data-structs */
  40f330:	48 39 52 60          	cmp    QWORD PTR [rdx+0x60],rdx
  40f334:	0f 85 45 01 00 00    	jne    40f47f <cos_compinfo_init+0x18f>
	vaddr_t last_page = round_to_page(heap_ptr - 1);
  40f33a:	49 8d 50 ff          	lea    rdx,[r8-0x1]
	ci->comp_cap     		= comp_cap;
  40f33e:	48 89 4f 10          	mov    QWORD PTR [rdi+0x10],rcx
		return round_up_to_pgt0_page(vaddr);
  40f342:	48 b9 ff ff ff ff 7f 	movabs rcx,0x7fffffffff
  40f349:	00 00 00 
  40f34c:	48 be 00 00 00 00 80 	movabs rsi,0xffffff8000000000
  40f353:	ff ff ff 
	vaddr_t last_page = round_to_page(heap_ptr - 1);
  40f356:	48 81 e2 00 f0 ff ff 	and    rdx,0xfffffffffffff000
	ci->pgtbl_cap    		= pgtbl_cap;
  40f35d:	0f 11 07             	movups XMMWORD PTR [rdi],xmm0
	ci->comp_cap_shared 	= 0;
  40f360:	66 0f ef c0          	pxor   xmm0,xmm0
		return round_up_to_pgt0_page(vaddr);
  40f364:	48 01 d1             	add    rcx,rdx
	ci->comp_cap_shared 	= 0;
  40f367:	0f 11 87 c8 00 00 00 	movups XMMWORD PTR [rdi+0xc8],xmm0
	ci->vas_frontier = heap_ptr;
  40f36e:	66 49 0f 6e c0       	movq   xmm0,r8
		return round_up_to_pgt0_page(vaddr);
  40f373:	48 21 f1             	and    rcx,rsi
	ci->cap_frontier 		= 0;
  40f376:	48 c7 47 18 00 00 00 	mov    QWORD PTR [rdi+0x18],0x0
  40f37d:	00 
	ci->vas_frontier = heap_ptr;
  40f37e:	66 48 0f 6e d9       	movq   xmm3,rcx
		return round_up_to_pgt1_page(vaddr);
  40f383:	48 8d 8a ff ff ff 3f 	lea    rcx,[rdx+0x3fffffff]
		return round_up_to_pgt2_page(vaddr);
  40f38a:	48 81 c2 ff ff 1f 00 	add    rdx,0x1fffff
	ci->vas_frontier = heap_ptr;
  40f391:	66 0f 6c c3          	punpcklqdq xmm0,xmm3
		return round_up_to_pgt2_page(vaddr);
  40f395:	48 81 e2 00 00 e0 ff 	and    rdx,0xffffffffffe00000
		return round_up_to_pgt1_page(vaddr);
  40f39c:	48 81 e1 00 00 00 c0 	and    rcx,0xffffffffc0000000
	ci->vas_frontier = heap_ptr;
  40f3a3:	66 48 0f 6e e2       	movq   xmm4,rdx
  40f3a8:	0f 11 47 40          	movups XMMWORD PTR [rdi+0x40],xmm0
	assert(round_up_to_pow2(cap_frontier, CAPMAX_ENTRY_SZ) == cap_frontier);
  40f3ac:	49 8d 51 03          	lea    rdx,[r9+0x3]
	ci->vas_frontier = heap_ptr;
  40f3b0:	66 48 0f 6e c1       	movq   xmm0,rcx
  40f3b5:	66 0f 6c c4          	punpcklqdq xmm0,xmm4
	assert(round_up_to_pow2(cap_frontier, CAPMAX_ENTRY_SZ) == cap_frontier);
  40f3b9:	48 83 e2 fc          	and    rdx,0xfffffffffffffffc
	ci->vas_frontier = heap_ptr;
  40f3bd:	0f 11 47 50          	movups XMMWORD PTR [rdi+0x50],xmm0
	assert(round_up_to_pow2(cap_frontier, CAPMAX_ENTRY_SZ) == cap_frontier);
  40f3c1:	49 39 d1             	cmp    r9,rdx
  40f3c4:	0f 85 dd 00 00 00    	jne    40f4a7 <cos_compinfo_init+0x1b7>
  40f3ca:	66 49 0f 6e c9       	movq   xmm1,r9
	ci->cap_frontier = cap_frontier;
  40f3cf:	4c 89 4f 18          	mov    QWORD PTR [rdi+0x18],r9
  40f3d3:	66 0f 6c c9          	punpcklqdq xmm1,xmm1
	if (cap_frontier < CAPTBL_EXPAND_SZ) {
  40f3d7:	49 83 f9 7f          	cmp    r9,0x7f
  40f3db:	76 43                	jbe    40f420 <cos_compinfo_init+0x130>
		ci->caprange_frontier = round_up_to_pow2(cap_frontier + CAPTBL_EXPAND_SZ, CAPTBL_EXPAND_SZ * 2) - CAPTBL_EXPAND_SZ;
  40f3dd:	49 8d 91 7f 01 00 00 	lea    rdx,[r9+0x17f]
  40f3e4:	30 d2                	xor    dl,dl
  40f3e6:	48 8d 7a 80          	lea    rdi,[rdx-0x80]
  40f3ea:	66 48 0f 6e c7       	movq   xmm0,rdi
		ci->cap16_frontier[i] = ci->cap32_frontier[i] = ci->cap64_frontier[i] = cap_frontier;
  40f3ef:	66 49 0f 6e e9       	movq   xmm5,r9
  40f3f4:	0f 11 48 30          	movups XMMWORD PTR [rax+0x30],xmm1
{ l->o = 0; }
  40f3f8:	48 c7 80 c0 00 00 00 	mov    QWORD PTR [rax+0xc0],0x0
  40f3ff:	00 00 00 00 
  40f403:	66 0f 6c c5          	punpcklqdq xmm0,xmm5
  40f407:	0f 11 40 20          	movups XMMWORD PTR [rax+0x20],xmm0
  40f40b:	66 0f ef c0          	pxor   xmm0,xmm0
  40f40f:	0f 11 80 b0 00 00 00 	movups XMMWORD PTR [rax+0xb0],xmm0
}
  40f416:	5d                   	pop    rbp
  40f417:	c3                   	ret    
  40f418:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40f41f:	00 
		ci->caprange_frontier = round_up_to_pow2(cap_frontier, CAPTBL_EXPAND_SZ);
  40f420:	49 8d 51 7f          	lea    rdx,[r9+0x7f]
  40f424:	48 83 e2 80          	and    rdx,0xffffffffffffff80
  40f428:	66 48 0f 6e c2       	movq   xmm0,rdx
  40f42d:	eb c0                	jmp    40f3ef <cos_compinfo_init+0xff>
  40f42f:	48 bf 20 05 42 00 00 	movabs rdi,0x420520
  40f436:	00 00 00 
  40f439:	be 2e 00 00 00       	mov    esi,0x2e
  40f43e:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40f445:	00 00 00 
  40f448:	ff d0                	call   rax
	assert(ci && ci_resources);
  40f44a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f451:	00 00 00 00 
  40f455:	0f 0b                	ud2    
  40f457:	48 bf 50 05 42 00 00 	movabs rdi,0x420550
  40f45e:	00 00 00 
  40f461:	be 2e 00 00 00       	mov    esi,0x2e
  40f466:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40f46d:	00 00 00 
  40f470:	ff d0                	call   rax
	assert(cap_frontier % CAPMAX_ENTRY_SZ == 0);
  40f472:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f479:	00 00 00 00 
  40f47d:	0f 0b                	ud2    
  40f47f:	48 bf 80 05 42 00 00 	movabs rdi,0x420580
  40f486:	00 00 00 
  40f489:	be 2e 00 00 00       	mov    esi,0x2e
  40f48e:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40f495:	00 00 00 
  40f498:	ff d0                	call   rax
	assert(ci_resources->memsrc == ci_resources); /* prevent infinite data-structs */
  40f49a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f4a1:	00 00 00 00 
  40f4a5:	0f 0b                	ud2    
  40f4a7:	48 bf b0 05 42 00 00 	movabs rdi,0x4205b0
  40f4ae:	00 00 00 
  40f4b1:	be 2e 00 00 00       	mov    esi,0x2e
  40f4b6:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40f4bd:	00 00 00 
  40f4c0:	ff d0                	call   rax
	assert(round_up_to_pow2(cap_frontier, CAPMAX_ENTRY_SZ) == cap_frontier);
  40f4c2:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f4c9:	00 00 00 00 
  40f4cd:	0f 0b                	ud2    
  40f4cf:	90                   	nop

000000000040f4d0 <cos_capid_bump_alloc>:
{ return __capid_bump_alloc(ci, cap); }
  40f4d0:	f3 0f 1e fa          	endbr64 
  40f4d4:	55                   	push   rbp
  40f4d5:	48 89 e5             	mov    rbp,rsp
  40f4d8:	41 56                	push   r14
  40f4da:	41 55                	push   r13
  40f4dc:	41 54                	push   r12
  40f4de:	53                   	push   rbx
/* a function instead of a struct to enable inlining + constant prop */
static inline cap_sz_t
__captbl_cap2sz(cap_t c)
{
	/* TODO: optimize for invocation and return */
	switch (c) {
  40f4df:	83 fe 14             	cmp    esi,0x14
  40f4e2:	77 78                	ja     40f55c <cos_capid_bump_alloc+0x8c>
  40f4e4:	b8 01 00 00 00       	mov    eax,0x1
  40f4e9:	89 f1                	mov    ecx,esi
  40f4eb:	48 89 fb             	mov    rbx,rdi
		break;
  40f4ee:	41 bc 04 00 00 00    	mov    r12d,0x4
  40f4f4:	48 d3 e0             	shl    rax,cl
		frontier = &ci->cap64_frontier[cos_cpuid()];
  40f4f7:	4c 8d 77 38          	lea    r14,[rdi+0x38]
  40f4fb:	a9 da 81 1f 00       	test   eax,0x1f81da
  40f500:	74 4e                	je     40f550 <cos_capid_bump_alloc+0x80>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f502:	48 8d 93 b0 00 00 00 	lea    rdx,[rbx+0xb0]
        __asm__ __volatile__("lock " PS_CAS_STR
  40f509:	be 01 00 00 00       	mov    esi,0x1
  40f50e:	31 c9                	xor    ecx,ecx
  40f510:	48 89 c8             	mov    rax,rcx
  40f513:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40f518:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f51b:	84 c0                	test   al,al
  40f51d:	74 f1                	je     40f510 <cos_capid_bump_alloc+0x40>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40f51f:	4d 8b 2e             	mov    r13,QWORD PTR [r14]
  40f522:	41 83 e5 03          	and    r13d,0x3
  40f526:	74 68                	je     40f590 <cos_capid_bump_alloc+0xc0>
        __asm__ __volatile__("lock " PS_FAA_STR
  40f528:	4c 89 e0             	mov    rax,r12
  40f52b:	f0 49 0f c1 06       	lock xadd QWORD PTR [r14],rax
  40f530:	49 89 c5             	mov    r13,rax
{ l->o = 0; }
  40f533:	48 c7 83 b0 00 00 00 	mov    QWORD PTR [rbx+0xb0],0x0
  40f53a:	00 00 00 00 
{ return __capid_bump_alloc(ci, cap); }
  40f53e:	4c 89 e8             	mov    rax,r13
  40f541:	5b                   	pop    rbx
  40f542:	41 5c                	pop    r12
  40f544:	41 5d                	pop    r13
  40f546:	41 5e                	pop    r14
  40f548:	5d                   	pop    rbp
  40f549:	c3                   	ret    
  40f54a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40f550:	a9 24 10 00 00       	test   eax,0x1024
  40f555:	75 29                	jne    40f580 <cos_capid_bump_alloc+0xb0>
  40f557:	f6 c4 60             	test   ah,0x60
  40f55a:	75 14                	jne    40f570 <cos_capid_bump_alloc+0xa0>
  40f55c:	49 c7 c5 ff ff ff ff 	mov    r13,0xffffffffffffffff
  40f563:	5b                   	pop    rbx
  40f564:	41 5c                	pop    r12
  40f566:	4c 89 e8             	mov    rax,r13
  40f569:	41 5d                	pop    r13
  40f56b:	41 5e                	pop    r14
  40f56d:	5d                   	pop    rbp
  40f56e:	c3                   	ret    
  40f56f:	90                   	nop
		frontier = &ci->cap32_frontier[cos_cpuid()];
  40f570:	4c 8d 77 30          	lea    r14,[rdi+0x30]
		break;
  40f574:	41 bc 02 00 00 00    	mov    r12d,0x2
  40f57a:	eb 86                	jmp    40f502 <cos_capid_bump_alloc+0x32>
  40f57c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		frontier = &ci->cap16_frontier[cos_cpuid()];
  40f580:	4c 8d 77 28          	lea    r14,[rdi+0x28]
		break;
  40f584:	41 bc 01 00 00 00    	mov    r12d,0x1
  40f58a:	e9 73 ff ff ff       	jmp    40f502 <cos_capid_bump_alloc+0x32>
  40f58f:	90                   	nop
		if (__capid_captbl_check_expand(ci)) goto error;
  40f590:	48 b8 50 e4 40 00 00 	movabs rax,0x40e450
  40f597:	00 00 00 
  40f59a:	48 89 df             	mov    rdi,rbx
  40f59d:	ff d0                	call   rax
  40f59f:	85 c0                	test   eax,eax
  40f5a1:	75 90                	jne    40f533 <cos_capid_bump_alloc+0x63>
        __asm__ __volatile__("lock " PS_FAA_STR
  40f5a3:	b8 04 00 00 00       	mov    eax,0x4
  40f5a8:	f0 48 0f c1 43 18    	lock xadd QWORD PTR [rbx+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40f5ae:	49 89 06             	mov    QWORD PTR [r14],rax
  40f5b1:	e9 72 ff ff ff       	jmp    40f528 <cos_capid_bump_alloc+0x58>
  40f5b6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40f5bd:	00 00 00 

000000000040f5c0 <cos_pgtbl_intern_alloc>:
{
  40f5c0:	f3 0f 1e fa          	endbr64 
		ret = __bump_mem_expand_range(__compinfo_metacap(ci), cipgtbl, mem_ptr, mem_sz, i | pgtbl_lvl_flag);	
  40f5c4:	49 b9 40 e7 40 00 00 	movabs r9,0x40e740
  40f5cb:	00 00 00 
{
  40f5ce:	55                   	push   rbp
  40f5cf:	48 89 e5             	mov    rbp,rsp
  40f5d2:	41 57                	push   r15
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  40f5d4:	45 31 ff             	xor    r15d,r15d
{
  40f5d7:	41 56                	push   r14
  40f5d9:	49 89 ce             	mov    r14,rcx
  40f5dc:	41 55                	push   r13
  40f5de:	49 89 d5             	mov    r13,rdx
  40f5e1:	41 54                	push   r12
  40f5e3:	49 89 f4             	mov    r12,rsi
  40f5e6:	53                   	push   rbx
  40f5e7:	48 89 fb             	mov    rbx,rdi
  40f5ea:	48 83 ec 08          	sub    rsp,0x8
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  40f5ee:	80 bf d8 00 00 00 01 	cmp    BYTE PTR [rdi+0xd8],0x1
		ret = __bump_mem_expand_range(__compinfo_metacap(ci), cipgtbl, mem_ptr, mem_sz, i | pgtbl_lvl_flag);	
  40f5f5:	48 8b 7f 60          	mov    rdi,QWORD PTR [rdi+0x60]
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  40f5f9:	41 0f 94 c7          	sete   r15b
  40f5fd:	49 c1 e7 1f          	shl    r15,0x1f
		ret = __bump_mem_expand_range(__compinfo_metacap(ci), cipgtbl, mem_ptr, mem_sz, i | pgtbl_lvl_flag);	
  40f601:	45 89 f8             	mov    r8d,r15d
  40f604:	41 83 c8 01          	or     r8d,0x1
  40f608:	41 ff d1             	call   r9
  40f60b:	48 8b 7b 60          	mov    rdi,QWORD PTR [rbx+0x60]
  40f60f:	45 89 f8             	mov    r8d,r15d
}
  40f612:	48 83 c4 08          	add    rsp,0x8
  40f616:	5b                   	pop    rbx
		ret = __bump_mem_expand_range(__compinfo_metacap(ci), cipgtbl, mem_ptr, mem_sz, i | pgtbl_lvl_flag);	
  40f617:	4c 89 f1             	mov    rcx,r14
  40f61a:	4c 89 ea             	mov    rdx,r13
  40f61d:	4c 89 e6             	mov    rsi,r12
  40f620:	49 b9 40 e7 40 00 00 	movabs r9,0x40e740
  40f627:	00 00 00 
}
  40f62a:	41 5c                	pop    r12
		ret = __bump_mem_expand_range(__compinfo_metacap(ci), cipgtbl, mem_ptr, mem_sz, i | pgtbl_lvl_flag);	
  40f62c:	41 83 c8 02          	or     r8d,0x2
}
  40f630:	41 5d                	pop    r13
  40f632:	41 5e                	pop    r14
  40f634:	41 5f                	pop    r15
  40f636:	5d                   	pop    rbp
		ret = __bump_mem_expand_range(__compinfo_metacap(ci), cipgtbl, mem_ptr, mem_sz, i | pgtbl_lvl_flag);	
  40f637:	41 ff e1             	jmp    r9
  40f63a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000040f640 <cos_pgtbl_intern_expand>:
{
  40f640:	f3 0f 1e fa          	endbr64 
  40f644:	55                   	push   rbp
  40f645:	48 89 e5             	mov    rbp,rsp
  40f648:	41 56                	push   r14
  40f64a:	41 55                	push   r13
  40f64c:	41 54                	push   r12
  40f64e:	53                   	push   rbx
	assert(lvl > 0);
  40f64f:	85 d2                	test   edx,edx
  40f651:	0f 8e c0 00 00 00    	jle    40f717 <cos_pgtbl_intern_expand+0xd7>
  40f657:	48 89 fb             	mov    rbx,rdi
  40f65a:	49 89 f4             	mov    r12,rsi
  40f65d:	48 8d 8f c0 00 00 00 	lea    rcx,[rdi+0xc0]
  40f664:	31 f6                	xor    esi,esi
  40f666:	bf 01 00 00 00       	mov    edi,0x1
  40f66b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  40f670:	48 89 f0             	mov    rax,rsi
  40f673:	f0 48 0f b1 39       	lock cmpxchg QWORD PTR [rcx],rdi
  40f678:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f67b:	84 c0                	test   al,al
  40f67d:	74 f1                	je     40f670 <cos_pgtbl_intern_expand+0x30>
	if (ci->vasrange_frontier[lvl] != round_to_pgd_page(mem_ptr)) goto error;
  40f67f:	48 b8 00 00 00 00 80 	movabs rax,0xffffff8000000000
  40f686:	ff ff ff 
  40f689:	4c 63 ea             	movsxd r13,edx
  40f68c:	4e 8d 34 eb          	lea    r14,[rbx+r13*8]
  40f690:	4c 21 e0             	and    rax,r12
  40f693:	49 39 46 48          	cmp    QWORD PTR [r14+0x48],rax
  40f697:	74 1f                	je     40f6b8 <cos_pgtbl_intern_expand+0x78>
	return 0;
  40f699:	45 31 c0             	xor    r8d,r8d
{ l->o = 0; }
  40f69c:	48 c7 83 c0 00 00 00 	mov    QWORD PTR [rbx+0xc0],0x0
  40f6a3:	00 00 00 00 
}
  40f6a7:	4c 89 c0             	mov    rax,r8
  40f6aa:	5b                   	pop    rbx
  40f6ab:	41 5c                	pop    r12
  40f6ad:	41 5d                	pop    r13
  40f6af:	41 5e                	pop    r14
  40f6b1:	5d                   	pop    rbp
  40f6b2:	c3                   	ret    
  40f6b3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	cap = __bump_mem_expand_intern(__compinfo_metacap(ci), ci->pgtbl_cap, mem_ptr, 0, 0);
  40f6b8:	45 31 c0             	xor    r8d,r8d
  40f6bb:	48 8b 7b 60          	mov    rdi,QWORD PTR [rbx+0x60]
  40f6bf:	48 8b 33             	mov    rsi,QWORD PTR [rbx]
  40f6c2:	31 c9                	xor    ecx,ecx
  40f6c4:	48 b8 30 ef 40 00 00 	movabs rax,0x40ef30
  40f6cb:	00 00 00 
  40f6ce:	4c 89 e2             	mov    rdx,r12
  40f6d1:	ff d0                	call   rax
  40f6d3:	49 89 c0             	mov    r8,rax
	if (!cap) goto error;
  40f6d6:	48 85 c0             	test   rax,rax
  40f6d9:	74 be                	je     40f699 <cos_pgtbl_intern_expand+0x59>
		if (tmp >= mem_ptr + PGD_RANGE) break;
  40f6db:	48 be 00 00 00 00 80 	movabs rsi,0x8000000000
  40f6e2:	00 00 00 
		vaddr_t tmp = ps_load(&ci->vasrange_frontier[lvl]);
  40f6e5:	49 8b 46 48          	mov    rax,QWORD PTR [r14+0x48]
		ps_cas(&ci->vasrange_frontier[lvl], tmp, tmp + PGD_RANGE);
  40f6e9:	4a 8d 4c eb 48       	lea    rcx,[rbx+r13*8+0x48]
		if (tmp >= mem_ptr + PGD_RANGE) break;
  40f6ee:	49 01 f4             	add    r12,rsi
  40f6f1:	4c 39 e0             	cmp    rax,r12
  40f6f4:	73 a6                	jae    40f69c <cos_pgtbl_intern_expand+0x5c>
  40f6f6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40f6fd:	00 00 00 
		ps_cas(&ci->vasrange_frontier[lvl], tmp, tmp + PGD_RANGE);
  40f700:	48 8d 14 30          	lea    rdx,[rax+rsi*1]
        __asm__ __volatile__("lock " PS_CAS_STR
  40f704:	f0 48 0f b1 11       	lock cmpxchg QWORD PTR [rcx],rdx
  40f709:	0f 94 c0             	sete   al
		vaddr_t tmp = ps_load(&ci->vasrange_frontier[lvl]);
  40f70c:	49 8b 46 48          	mov    rax,QWORD PTR [r14+0x48]
		if (tmp >= mem_ptr + PGD_RANGE) break;
  40f710:	4c 39 e0             	cmp    rax,r12
  40f713:	72 eb                	jb     40f700 <cos_pgtbl_intern_expand+0xc0>
  40f715:	eb 85                	jmp    40f69c <cos_pgtbl_intern_expand+0x5c>
  40f717:	48 bf e0 05 42 00 00 	movabs rdi,0x4205e0
  40f71e:	00 00 00 
  40f721:	be 2e 00 00 00       	mov    esi,0x2e
  40f726:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40f72d:	00 00 00 
  40f730:	ff d0                	call   rax
	assert(lvl > 0);
  40f732:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f739:	00 00 00 00 
  40f73d:	0f 0b                	ud2    
  40f73f:	90                   	nop

000000000040f740 <cos_pgtbl_intern_expandwith>:
{
  40f740:	f3 0f 1e fa          	endbr64 
  40f744:	55                   	push   rbp
  40f745:	49 89 d1             	mov    r9,rdx
  40f748:	31 c9                	xor    ecx,ecx
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f74a:	48 8d 97 c0 00 00 00 	lea    rdx,[rdi+0xc0]
  40f751:	48 89 e5             	mov    rbp,rsp
  40f754:	41 54                	push   r12
  40f756:	49 89 f4             	mov    r12,rsi
        __asm__ __volatile__("lock " PS_CAS_STR
  40f759:	be 01 00 00 00       	mov    esi,0x1
  40f75e:	53                   	push   rbx
  40f75f:	48 89 fb             	mov    rbx,rdi
  40f762:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40f768:	48 89 c8             	mov    rax,rcx
  40f76b:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40f770:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f773:	84 c0                	test   al,al
  40f775:	74 f1                	je     40f768 <cos_pgtbl_intern_expandwith+0x28>
	if (ci->vasrange_frontier[0] != round_to_pgd_page(mem)) goto error;
  40f777:	48 b8 00 00 00 00 80 	movabs rax,0xffffff8000000000
  40f77e:	ff ff ff 
  40f781:	4c 21 c8             	and    rax,r9
  40f784:	48 39 43 48          	cmp    QWORD PTR [rbx+0x48],rax
  40f788:	75 23                	jne    40f7ad <cos_pgtbl_intern_expandwith+0x6d>
        __asm__ __volatile__("lock " PS_FAA_STR
  40f78a:	48 ba 00 00 00 00 80 	movabs rdx,0x8000000000
  40f791:	00 00 00 
  40f794:	48 89 d1             	mov    rcx,rdx
  40f797:	f0 48 0f c1 4b 48    	lock xadd QWORD PTR [rbx+0x48],rcx
	if ((unsigned long)ps_faa(&ci->vasrange_frontier[0], PGD_RANGE) > round_to_pgd_page(mem)) goto error;
  40f79d:	48 39 c8             	cmp    rax,rcx
  40f7a0:	72 0b                	jb     40f7ad <cos_pgtbl_intern_expandwith+0x6d>
  40f7a2:	f0 48 0f c1 53 40    	lock xadd QWORD PTR [rbx+0x40],rdx
	if ((unsigned long)ps_faa(&ci->vas_frontier, PGD_RANGE) > round_to_pgd_page(mem)) goto error;
  40f7a8:	48 39 d0             	cmp    rax,rdx
  40f7ab:	73 1b                	jae    40f7c8 <cos_pgtbl_intern_expandwith+0x88>
{ l->o = 0; }
  40f7ad:	48 c7 83 c0 00 00 00 	mov    QWORD PTR [rbx+0xc0],0x0
  40f7b4:	00 00 00 00 
	return -1;
  40f7b8:	b8 ff ff ff ff       	mov    eax,0xffffffff
}
  40f7bd:	5b                   	pop    rbx
  40f7be:	41 5c                	pop    r12
  40f7c0:	5d                   	pop    rbp
  40f7c1:	c3                   	ret    
  40f7c2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	if (__bump_mem_expand_intern(__compinfo_metacap(ci), ci->pgtbl_cap, mem, intern, 0) != intern) {
  40f7c8:	48 8b 7b 60          	mov    rdi,QWORD PTR [rbx+0x60]
  40f7cc:	48 8b 33             	mov    rsi,QWORD PTR [rbx]
  40f7cf:	45 31 c0             	xor    r8d,r8d
  40f7d2:	4c 89 e1             	mov    rcx,r12
  40f7d5:	48 b8 30 ef 40 00 00 	movabs rax,0x40ef30
  40f7dc:	00 00 00 
  40f7df:	4c 89 ca             	mov    rdx,r9
  40f7e2:	ff d0                	call   rax
  40f7e4:	48 c7 83 c0 00 00 00 	mov    QWORD PTR [rbx+0xc0],0x0
  40f7eb:	00 00 00 00 
}
  40f7ef:	5b                   	pop    rbx
	if (__bump_mem_expand_intern(__compinfo_metacap(ci), ci->pgtbl_cap, mem, intern, 0) != intern) {
  40f7f0:	4c 39 e0             	cmp    rax,r12
}
  40f7f3:	41 5c                	pop    r12
  40f7f5:	5d                   	pop    rbp
	if (__bump_mem_expand_intern(__compinfo_metacap(ci), ci->pgtbl_cap, mem, intern, 0) != intern) {
  40f7f6:	0f 95 c0             	setne  al
  40f7f9:	0f b6 c0             	movzx  eax,al
}
  40f7fc:	c3                   	ret    
  40f7fd:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040f800 <cos_meminfo_alloc>:
{
  40f800:	f3 0f 1e fa          	endbr64 
	assert(untyped_ptr == round_up_to_pgd_page(untyped_ptr));
  40f804:	48 b8 ff ff ff ff 7f 	movabs rax,0x7fffffffff
  40f80b:	00 00 00 
{
  40f80e:	55                   	push   rbp
	assert(untyped_ptr == round_up_to_pgd_page(untyped_ptr));
  40f80f:	48 01 f0             	add    rax,rsi
{
  40f812:	48 89 e5             	mov    rbp,rsp
  40f815:	41 57                	push   r15
  40f817:	41 56                	push   r14
  40f819:	41 55                	push   r13
  40f81b:	41 54                	push   r12
  40f81d:	49 89 d4             	mov    r12,rdx
	assert(untyped_ptr == round_up_to_pgd_page(untyped_ptr));
  40f820:	48 ba 00 00 00 00 80 	movabs rdx,0xffffff8000000000
  40f827:	ff ff ff 
{
  40f82a:	53                   	push   rbx
	assert(untyped_ptr == round_up_to_pgd_page(untyped_ptr));
  40f82b:	48 21 d0             	and    rax,rdx
{
  40f82e:	48 83 ec 28          	sub    rsp,0x28
	return ci->memsrc;
  40f832:	4c 8b 7f 60          	mov    r15,QWORD PTR [rdi+0x60]
	assert(untyped_ptr == round_up_to_pgd_page(untyped_ptr));
  40f836:	48 39 c6             	cmp    rsi,rax
  40f839:	0f 85 ac 01 00 00    	jne    40f9eb <cos_meminfo_alloc+0x1eb>
  40f83f:	49 89 fd             	mov    r13,rdi
  40f842:	48 89 f3             	mov    rbx,rsi
  40f845:	4c 89 ff             	mov    rdi,r15
  40f848:	45 31 f6             	xor    r14d,r14d
		retaddr = __bump_mem_expand_range(__compinfo_metacap(ci), ci->mi.pgtbl_cap, untyped_ptr, untyped_sz, pgtbl_lvl);
  40f84b:	49 8b b5 98 00 00 00 	mov    rsi,QWORD PTR [r13+0x98]
  40f852:	45 89 f0             	mov    r8d,r14d
  40f855:	4c 89 e1             	mov    rcx,r12
  40f858:	48 89 da             	mov    rdx,rbx
  40f85b:	48 b8 40 e7 40 00 00 	movabs rax,0x40e740
  40f862:	00 00 00 
  40f865:	ff d0                	call   rax
  40f867:	49 89 c2             	mov    r10,rax
		assert(retaddr);
  40f86a:	48 85 c0             	test   rax,rax
  40f86d:	0f 84 50 01 00 00    	je     40f9c3 <cos_meminfo_alloc+0x1c3>
	for(pgtbl_lvl = 0; pgtbl_lvl < COS_PGTBL_DEPTH - 1; pgtbl_lvl++) {
  40f873:	49 83 c6 01          	add    r14,0x1
  40f877:	49 83 fe 03          	cmp    r14,0x3
  40f87b:	74 0b                	je     40f888 <cos_meminfo_alloc+0x88>
	return ci->memsrc;
  40f87d:	49 8b 7d 60          	mov    rdi,QWORD PTR [r13+0x60]
  40f881:	eb c8                	jmp    40f84b <cos_meminfo_alloc+0x4b>
  40f883:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40f888:	66 48 0f 6e c0       	movq   xmm0,rax
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f88d:	49 8d 95 b8 00 00 00 	lea    rdx,[r13+0xb8]
        __asm__ __volatile__("lock " PS_CAS_STR
  40f894:	be 01 00 00 00       	mov    esi,0x1
  40f899:	31 c9                	xor    ecx,ecx
  40f89b:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
	assert(retaddr == untyped_ptr);
  40f89f:	48 39 c3             	cmp    rbx,rax
  40f8a2:	0f 85 6b 01 00 00    	jne    40fa13 <cos_meminfo_alloc+0x213>
  40f8a8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40f8af:	00 
  40f8b0:	48 89 c8             	mov    rax,rcx
  40f8b3:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40f8b8:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f8bb:	84 c0                	test   al,al
  40f8bd:	74 f1                	je     40f8b0 <cos_meminfo_alloc+0xb0>
        __asm__ __volatile__("lock " PS_FAA_STR
  40f8bf:	4c 89 e0             	mov    rax,r12
  40f8c2:	f0 49 0f c1 47 68    	lock xadd QWORD PTR [r15+0x68],rax
  40f8c8:	4c 89 e2             	mov    rdx,r12
  40f8cb:	f0 49 0f c1 97 80 00 	lock xadd QWORD PTR [r15+0x80],rdx
  40f8d2:	00 00 
	for (addr = untyped_ptr; addr < untyped_ptr + untyped_sz; addr += PAGE_SIZE, start_addr += PAGE_SIZE) {
  40f8d4:	4b 8d 1c 14          	lea    rbx,[r12+r10*1]
  40f8d8:	66 49 0f 6e d2       	movq   xmm2,r10
  40f8dd:	4c 29 d0             	sub    rax,r10
  40f8e0:	4c 89 d7             	mov    rdi,r10
  40f8e3:	66 48 0f 6e cb       	movq   xmm1,rbx
  40f8e8:	49 89 c6             	mov    r14,rax
  40f8eb:	31 d2                	xor    edx,edx
{ l->o = 0; }
  40f8ed:	49 c7 85 b8 00 00 00 	mov    QWORD PTR [r13+0xb8],0x0
  40f8f4:	00 00 00 00 
  40f8f8:	66 0f 6c ca          	punpcklqdq xmm1,xmm2
  40f8fc:	4c 39 d3             	cmp    rbx,r10
  40f8ff:	0f 86 97 00 00 00    	jbe    40f99c <cos_meminfo_alloc+0x19c>
  40f905:	4c 89 55 b8          	mov    QWORD PTR [rbp-0x48],r10
  40f909:	49 89 da             	mov    r10,rbx
  40f90c:	eb 0e                	jmp    40f91c <cos_meminfo_alloc+0x11c>
  40f90e:	66 90                	xchg   ax,ax
  40f910:	48 81 c7 00 10 00 00 	add    rdi,0x1000
  40f917:	49 39 fa             	cmp    r10,rdi
  40f91a:	76 7c                	jbe    40f998 <cos_meminfo_alloc+0x198>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f91c:	41 8b 87 98 00 00 00 	mov    eax,DWORD PTR [r15+0x98]
	__asm__ __volatile__(
  40f923:	49 8b b5 98 00 00 00 	mov    rsi,QWORD PTR [r13+0x98]
  40f92a:	49 8d 1c 3e          	lea    rbx,[r14+rdi*1]
  40f92e:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f932:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40f935:	05 24 00 01 00       	add    eax,0x10024
	__asm__ __volatile__(
  40f93a:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40f93d:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40f941:	48 89 cd             	mov    rbp,rcx
  40f944:	49 b8 58 f9 40 00 00 	movabs r8,0x40f958
  40f94b:	00 00 00 
  40f94e:	0f 05                	syscall 
  40f950:	eb 0d                	jmp    40f95f <cos_meminfo_alloc+0x15f>
  40f952:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40f958:	b9 00 00 00 00       	mov    ecx,0x0
  40f95d:	eb 05                	jmp    40f964 <cos_meminfo_alloc+0x164>
  40f95f:	b9 01 00 00 00       	mov    ecx,0x1
  40f964:	5d                   	pop    rbp
  40f965:	5c                   	pop    rsp
		if (call_cap_op(meta->mi.pgtbl_cap, CAPTBL_OP_MEMMOVE, start_addr, ci->mi.pgtbl_cap, addr, 0)) BUG();
  40f966:	85 c0                	test   eax,eax
  40f968:	74 a6                	je     40f910 <cos_meminfo_alloc+0x110>
  40f96a:	48 bf 9f 06 42 00 00 	movabs rdi,0x42069f
  40f971:	00 00 00 
  40f974:	be 1b 00 00 00       	mov    esi,0x1b
  40f979:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40f980:	00 00 00 
  40f983:	ff d0                	call   rax
  40f985:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f98c:	00 00 00 00 
  40f990:	0f 0b                	ud2    
  40f992:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40f998:	4c 8b 55 b8          	mov    r10,QWORD PTR [rbp-0x48]
	ci->mi.untyped_ptr = ci->mi.umem_ptr = ci->mi.kmem_ptr = ci->mi.umem_frontier = ci->mi.kmem_frontier =
  40f99c:	4d 89 95 90 00 00 00 	mov    QWORD PTR [r13+0x90],r10
  40f9a3:	4d 89 55 78          	mov    QWORD PTR [r13+0x78],r10
  40f9a7:	41 0f 11 45 68       	movups XMMWORD PTR [r13+0x68],xmm0
	ci->mi.untyped_frontier = untyped_ptr + untyped_sz;
  40f9ac:	41 0f 11 8d 80 00 00 	movups XMMWORD PTR [r13+0x80],xmm1
  40f9b3:	00 
}
  40f9b4:	48 83 c4 28          	add    rsp,0x28
  40f9b8:	5b                   	pop    rbx
  40f9b9:	41 5c                	pop    r12
  40f9bb:	41 5d                	pop    r13
  40f9bd:	41 5e                	pop    r14
  40f9bf:	41 5f                	pop    r15
  40f9c1:	5d                   	pop    rbp
  40f9c2:	c3                   	ret    
  40f9c3:	48 bf 40 06 42 00 00 	movabs rdi,0x420640
  40f9ca:	00 00 00 
  40f9cd:	be 2e 00 00 00       	mov    esi,0x2e
  40f9d2:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40f9d9:	00 00 00 
  40f9dc:	ff d0                	call   rax
		assert(retaddr);
  40f9de:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f9e5:	00 00 00 00 
  40f9e9:	0f 0b                	ud2    
  40f9eb:	48 bf 10 06 42 00 00 	movabs rdi,0x420610
  40f9f2:	00 00 00 
  40f9f5:	be 2e 00 00 00       	mov    esi,0x2e
  40f9fa:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40fa01:	00 00 00 
  40fa04:	ff d0                	call   rax
	assert(untyped_ptr == round_up_to_pgd_page(untyped_ptr));
  40fa06:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40fa0d:	00 00 00 00 
  40fa11:	0f 0b                	ud2    
  40fa13:	48 bf 70 06 42 00 00 	movabs rdi,0x420670
  40fa1a:	00 00 00 
  40fa1d:	be 2e 00 00 00       	mov    esi,0x2e
  40fa22:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40fa29:	00 00 00 
  40fa2c:	ff d0                	call   rax
	assert(retaddr == untyped_ptr);
  40fa2e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40fa35:	00 00 00 00 
  40fa39:	0f 0b                	ud2    
  40fa3b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000040fa40 <missing_captbl_node_expand>:

void
missing_captbl_node_expand(struct cos_compinfo *ci)
{
  40fa40:	f3 0f 1e fa          	endbr64 
  40fa44:	55                   	push   rbp
  40fa45:	48 89 e5             	mov    rbp,rsp
  40fa48:	41 57                	push   r15
  40fa4a:	41 56                	push   r14
  40fa4c:	41 55                	push   r13
  40fa4e:	41 54                	push   r12
  40fa50:	53                   	push   rbx
  40fa51:	48 83 ec 38          	sub    rsp,0x38
	return ci->memsrc;
  40fa55:	4c 8b 77 60          	mov    r14,QWORD PTR [rdi+0x60]
	int self_resource = (root_source == ci);
	vaddr_t kmem;
	int ret;

	cap_frontier = root_source->cap_frontier;
	caprange_frontier = root_source->caprange_frontier;
  40fa59:	49 8b 5e 20          	mov    rbx,QWORD PTR [r14+0x20]
	cap_frontier = root_source->cap_frontier;
  40fa5d:	49 8b 46 18          	mov    rax,QWORD PTR [r14+0x18]
	caprange_frontier = root_source->caprange_frontier;
  40fa61:	48 89 5d b0          	mov    QWORD PTR [rbp-0x50],rbx

	test_cap = CAPTBL_EXPAND_SZ;
	if (self_resource) {
  40fa65:	4c 39 f7             	cmp    rdi,r14
  40fa68:	0f 84 c2 02 00 00    	je     40fd30 <missing_captbl_node_expand+0x2f0>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40fa6e:	41 8b 46 08          	mov    eax,DWORD PTR [r14+0x8]
	__asm__ __volatile__(
  40fa72:	31 d2                	xor    edx,edx
  40fa74:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  40fa78:	48 8b 5f 08          	mov    rbx,QWORD PTR [rdi+0x8]
  40fa7c:	49 89 ff             	mov    r15,rdi
  40fa7f:	48 89 4d b8          	mov    QWORD PTR [rbp-0x48],rcx
  40fa83:	bf 01 00 00 00       	mov    edi,0x1
  40fa88:	48 89 d6             	mov    rsi,rdx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40fa8b:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40fa8e:	05 03 00 01 00       	add    eax,0x10003
	__asm__ __volatile__(
  40fa93:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40fa96:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40fa9a:	48 89 cd             	mov    rbp,rcx
  40fa9d:	49 b8 b8 fa 40 00 00 	movabs r8,0x40fab8
  40faa4:	00 00 00 
  40faa7:	0f 05                	syscall 
  40faa9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  40fab0:	eb 0d                	jmp    40fabf <missing_captbl_node_expand+0x7f>
  40fab2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40fab8:	b9 00 00 00 00       	mov    ecx,0x0
  40fabd:	eb 05                	jmp    40fac4 <missing_captbl_node_expand+0x84>
  40fabf:	b9 01 00 00 00       	mov    ecx,0x1
  40fac4:	5d                   	pop    rbp
  40fac5:	5c                   	pop    rsp
	} else {
		printd("cap check before:%d\n", ci->captbl_cap);
		ret = call_cap_op(root_source->captbl_cap, CAPTBL_OP_CAPCHECK, ci->captbl_cap, 0, 1, 0);
		// printc("after cap check:%d\n", ret);
		/* make sure the sub captbl exists */
		assert(!ret);
  40fac6:	85 c0                	test   eax,eax
  40fac8:	0f 85 40 04 00 00    	jne    40ff0e <missing_captbl_node_expand+0x4ce>
		cap_frontier = ci->cap_frontier;
		caprange_frontier = ci->caprange_frontier;
  40face:	49 8b 5f 20          	mov    rbx,QWORD PTR [r15+0x20]
		/* we make sure before expanding the missing node of sub captbl, we make sure its root captbl is in a good state */
		printd("begin to expanding a SUB source:%d, %d\n", cap_frontier, caprange_frontier);
		missing_captbl_node_expand(root_source);
  40fad2:	4c 89 f7             	mov    rdi,r14
  40fad5:	48 b8 40 fa 40 00 00 	movabs rax,0x40fa40
  40fadc:	00 00 00 
		caprange_frontier = ci->caprange_frontier;
  40fadf:	48 89 5d b0          	mov    QWORD PTR [rbp-0x50],rbx
		missing_captbl_node_expand(root_source);
  40fae3:	ff d0                	call   rax
		while (test_cap < caprange_frontier) {
  40fae5:	48 81 fb 80 00 00 00 	cmp    rbx,0x80
  40faec:	0f 86 44 02 00 00    	jbe    40fd36 <missing_captbl_node_expand+0x2f6>
	test_cap = CAPTBL_EXPAND_SZ;
  40faf2:	41 bd 80 00 00 00    	mov    r13d,0x80
  40faf8:	45 31 d2             	xor    r10d,r10d
  40fafb:	eb 14                	jmp    40fb11 <missing_captbl_node_expand+0xd1>
  40fafd:	0f 1f 00             	nop    DWORD PTR [rax]
					printc("assert ret:%d\n", ret);
					assert(0); /* race? */
				}
				printd("try to expand a SUB node: DONE once\n");
			}
			test_cap += CAPTBL_EXPAND_SZ * 2;
  40fb00:	49 81 c5 00 01 00 00 	add    r13,0x100
		while (test_cap < caprange_frontier) {
  40fb07:	4c 39 6d b0          	cmp    QWORD PTR [rbp-0x50],r13
  40fb0b:	0f 86 25 02 00 00    	jbe    40fd36 <missing_captbl_node_expand+0x2f6>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40fb11:	41 8b 46 08          	mov    eax,DWORD PTR [r14+0x8]
	__asm__ __volatile__(
  40fb15:	49 8b 5f 08          	mov    rbx,QWORD PTR [r15+0x8]
  40fb19:	4c 89 ee             	mov    rsi,r13
  40fb1c:	4c 89 d7             	mov    rdi,r10
  40fb1f:	48 8b 4d b8          	mov    rcx,QWORD PTR [rbp-0x48]
  40fb23:	4c 89 d2             	mov    rdx,r10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40fb26:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40fb29:	05 03 00 01 00       	add    eax,0x10003
	__asm__ __volatile__(
  40fb2e:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40fb31:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40fb35:	48 89 cd             	mov    rbp,rcx
  40fb38:	49 b8 50 fb 40 00 00 	movabs r8,0x40fb50
  40fb3f:	00 00 00 
  40fb42:	0f 05                	syscall 
  40fb44:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  40fb48:	eb 0d                	jmp    40fb57 <missing_captbl_node_expand+0x117>
  40fb4a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40fb50:	b9 00 00 00 00       	mov    ecx,0x0
  40fb55:	eb 05                	jmp    40fb5c <missing_captbl_node_expand+0x11c>
  40fb57:	b9 01 00 00 00       	mov    ecx,0x1
  40fb5c:	5d                   	pop    rbp
  40fb5d:	5c                   	pop    rsp
			if (ret) {
  40fb5e:	85 c0                	test   eax,eax
  40fb60:	74 9e                	je     40fb00 <missing_captbl_node_expand+0xc0>
	return __mem_bump_alloc(ci, 1, 1);
  40fb62:	48 b8 b0 e2 40 00 00 	movabs rax,0x40e2b0
  40fb69:	00 00 00 
  40fb6c:	4c 89 f7             	mov    rdi,r14
  40fb6f:	ff d0                	call   rax
				assert(kmem); /* FIXME: should have a failure semantics for capids */
  40fb71:	45 31 d2             	xor    r10d,r10d
	return __mem_bump_alloc(ci, 1, 1);
  40fb74:	49 89 c4             	mov    r12,rax
				assert(kmem); /* FIXME: should have a failure semantics for capids */
  40fb77:	48 85 c0             	test   rax,rax
  40fb7a:	0f 84 c5 01 00 00    	je     40fd45 <missing_captbl_node_expand+0x305>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40fb80:	49 8d 96 b0 00 00 00 	lea    rdx,[r14+0xb0]
  40fb87:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40fb8e:	00 00 
        __asm__ __volatile__("lock " PS_CAS_STR
  40fb90:	be 01 00 00 00       	mov    esi,0x1
  40fb95:	4c 89 d0             	mov    rax,r10
  40fb98:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40fb9d:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40fba0:	84 c0                	test   al,al
  40fba2:	74 ec                	je     40fb90 <missing_captbl_node_expand+0x150>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40fba4:	49 8b 5e 38          	mov    rbx,QWORD PTR [r14+0x38]
  40fba8:	83 e3 03             	and    ebx,0x3
  40fbab:	0f 84 4f 01 00 00    	je     40fd00 <missing_captbl_node_expand+0x2c0>
        __asm__ __volatile__("lock " PS_FAA_STR
  40fbb1:	bb 04 00 00 00       	mov    ebx,0x4
  40fbb6:	f0 49 0f c1 5e 38    	lock xadd QWORD PTR [r14+0x38],rbx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40fbbc:	41 8b 46 08          	mov    eax,DWORD PTR [r14+0x8]
	__asm__ __volatile__(
  40fbc0:	48 8b 4d b8          	mov    rcx,QWORD PTR [rbp-0x48]
  40fbc4:	4c 89 e7             	mov    rdi,r12
  40fbc7:	ba 01 00 00 00       	mov    edx,0x1
{ l->o = 0; }
  40fbcc:	49 c7 86 b0 00 00 00 	mov    QWORD PTR [r14+0xb0],0x0
  40fbd3:	00 00 00 00 
  40fbd7:	49 8b b6 98 00 00 00 	mov    rsi,QWORD PTR [r14+0x98]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40fbde:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40fbe1:	05 1e 00 01 00       	add    eax,0x1001e
	__asm__ __volatile__(
  40fbe6:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40fbe9:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40fbed:	48 89 cd             	mov    rbp,rcx
  40fbf0:	49 b8 08 fc 40 00 00 	movabs r8,0x40fc08
  40fbf7:	00 00 00 
  40fbfa:	0f 05                	syscall 
  40fbfc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  40fc00:	eb 0d                	jmp    40fc0f <missing_captbl_node_expand+0x1cf>
  40fc02:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40fc08:	b9 00 00 00 00       	mov    ecx,0x0
  40fc0d:	eb 05                	jmp    40fc14 <missing_captbl_node_expand+0x1d4>
  40fc0f:	b9 01 00 00 00       	mov    ecx,0x1
  40fc14:	5d                   	pop    rbp
  40fc15:	5c                   	pop    rsp
				if (call_cap_op(root_source->captbl_cap, CAPTBL_OP_CAPTBLACTIVATE, frontier, root_source->mi.pgtbl_cap, kmem, 1)) {
  40fc16:	85 c0                	test   eax,eax
  40fc18:	0f 85 18 03 00 00    	jne    40ff36 <missing_captbl_node_expand+0x4f6>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40fc1e:	41 8b 47 08          	mov    eax,DWORD PTR [r15+0x8]
	__asm__ __volatile__(
  40fc22:	48 8b 4d b8          	mov    rcx,QWORD PTR [rbp-0x48]
  40fc26:	4c 89 ee             	mov    rsi,r13
  40fc29:	4c 89 d7             	mov    rdi,r10
  40fc2c:	4c 89 d2             	mov    rdx,r10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40fc2f:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40fc32:	05 01 00 01 00       	add    eax,0x10001
	__asm__ __volatile__(
  40fc37:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40fc3a:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40fc3e:	48 89 cd             	mov    rbp,rcx
  40fc41:	49 b8 58 fc 40 00 00 	movabs r8,0x40fc58
  40fc48:	00 00 00 
  40fc4b:	0f 05                	syscall 
  40fc4d:	0f 1f 00             	nop    DWORD PTR [rax]
  40fc50:	eb 0d                	jmp    40fc5f <missing_captbl_node_expand+0x21f>
  40fc52:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40fc58:	b9 00 00 00 00       	mov    ecx,0x0
  40fc5d:	eb 05                	jmp    40fc64 <missing_captbl_node_expand+0x224>
  40fc5f:	b9 01 00 00 00       	mov    ecx,0x1
  40fc64:	5d                   	pop    rbp
  40fc65:	5c                   	pop    rsp
				if (call_cap_op(ci->captbl_cap, CAPTBL_OP_CONS, frontier, test_cap, 0, 0)) {
  40fc66:	85 c0                	test   eax,eax
  40fc68:	0f 84 92 fe ff ff    	je     40fb00 <missing_captbl_node_expand+0xc0>
					ret = call_cap_op(root_source->captbl_cap, CAPTBL_OP_CAPCHECK, ci->captbl_cap, 384, 0, 0);
  40fc6e:	49 8b 46 08          	mov    rax,QWORD PTR [r14+0x8]
  40fc72:	49 8b 5f 08          	mov    rbx,QWORD PTR [r15+0x8]
  40fc76:	be 80 01 00 00       	mov    esi,0x180
  40fc7b:	48 8b 4d b8          	mov    rcx,QWORD PTR [rbp-0x48]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40fc7f:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40fc82:	05 03 00 01 00       	add    eax,0x10003
	__asm__ __volatile__(
  40fc87:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40fc8a:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40fc8e:	48 89 cd             	mov    rbp,rcx
  40fc91:	49 b8 a8 fc 40 00 00 	movabs r8,0x40fca8
  40fc98:	00 00 00 
  40fc9b:	0f 05                	syscall 
  40fc9d:	0f 1f 00             	nop    DWORD PTR [rax]
  40fca0:	eb 0d                	jmp    40fcaf <missing_captbl_node_expand+0x26f>
  40fca2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40fca8:	b9 00 00 00 00       	mov    ecx,0x0
  40fcad:	eb 05                	jmp    40fcb4 <missing_captbl_node_expand+0x274>
  40fcaf:	b9 01 00 00 00       	mov    ecx,0x1
  40fcb4:	5d                   	pop    rbp
  40fcb5:	5c                   	pop    rsp
					printc("assert ret:%d\n", ret);
  40fcb6:	48 ba e0 e1 40 00 00 	movabs rdx,0x40e1e0
  40fcbd:	00 00 00 
  40fcc0:	89 c6                	mov    esi,eax
  40fcc2:	31 c0                	xor    eax,eax
  40fcc4:	48 bf 80 01 42 00 00 	movabs rdi,0x420180
  40fccb:	00 00 00 
  40fcce:	ff d2                	call   rdx
  40fcd0:	be 2e 00 00 00       	mov    esi,0x2e
  40fcd5:	48 bf e0 07 42 00 00 	movabs rdi,0x4207e0
  40fcdc:	00 00 00 
  40fcdf:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40fce6:	00 00 00 
  40fce9:	ff d0                	call   rax
					assert(0); /* race? */
  40fceb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40fcf2:	00 00 00 00 
  40fcf6:	0f 0b                	ud2    
  40fcf8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40fcff:	00 
		if (__capid_captbl_check_expand(ci)) goto error;
  40fd00:	48 b8 50 e4 40 00 00 	movabs rax,0x40e450
  40fd07:	00 00 00 
  40fd0a:	4c 89 f7             	mov    rdi,r14
  40fd0d:	ff d0                	call   rax
  40fd0f:	45 31 d2             	xor    r10d,r10d
  40fd12:	85 c0                	test   eax,eax
  40fd14:	0f 85 a2 fe ff ff    	jne    40fbbc <missing_captbl_node_expand+0x17c>
        __asm__ __volatile__("lock " PS_FAA_STR
  40fd1a:	b8 04 00 00 00       	mov    eax,0x4
  40fd1f:	f0 49 0f c1 46 18    	lock xadd QWORD PTR [r14+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40fd25:	49 89 46 38          	mov    QWORD PTR [r14+0x38],rax
  40fd29:	e9 83 fe ff ff       	jmp    40fbb1 <missing_captbl_node_expand+0x171>
  40fd2e:	66 90                	xchg   ax,ax
		if (cap_frontier >= CAPTBL_EXPAND_SZ) {
  40fd30:	48 83 f8 7f          	cmp    rax,0x7f
  40fd34:	76 37                	jbe    40fd6d <missing_captbl_node_expand+0x32d>
		}
		printd("begin to expanding a SUB source:%d, %d, done\n", cap_frontier, caprange_frontier);
	}
}
  40fd36:	48 83 c4 38          	add    rsp,0x38
  40fd3a:	5b                   	pop    rbx
  40fd3b:	41 5c                	pop    r12
  40fd3d:	41 5d                	pop    r13
  40fd3f:	41 5e                	pop    r14
  40fd41:	41 5f                	pop    r15
  40fd43:	5d                   	pop    rbp
  40fd44:	c3                   	ret    
  40fd45:	48 bf 80 07 42 00 00 	movabs rdi,0x420780
  40fd4c:	00 00 00 
  40fd4f:	be 2e 00 00 00       	mov    esi,0x2e
  40fd54:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40fd5b:	00 00 00 
  40fd5e:	ff d0                	call   rax
				assert(kmem); /* FIXME: should have a failure semantics for capids */
  40fd60:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40fd67:	00 00 00 00 
  40fd6b:	0f 0b                	ud2    
		while (test_cap < caprange_frontier) {
  40fd6d:	48 81 fb 80 00 00 00 	cmp    rbx,0x80
  40fd74:	76 c0                	jbe    40fd36 <missing_captbl_node_expand+0x2f6>
  40fd76:	48 8d 45 c0          	lea    rax,[rbp-0x40]
	test_cap = CAPTBL_EXPAND_SZ;
  40fd7a:	41 bf 80 00 00 00    	mov    r15d,0x80
	return __mem_bump_alloc(ci, 1, 1);
  40fd80:	4d 89 f2             	mov    r10,r14
  40fd83:	48 89 45 b8          	mov    QWORD PTR [rbp-0x48],rax
  40fd87:	eb 14                	jmp    40fd9d <missing_captbl_node_expand+0x35d>
  40fd89:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
			test_cap += CAPTBL_EXPAND_SZ * 2;
  40fd90:	49 81 c7 00 01 00 00 	add    r15,0x100
		while (test_cap < caprange_frontier) {
  40fd97:	4c 39 7d b0          	cmp    QWORD PTR [rbp-0x50],r15
  40fd9b:	76 99                	jbe    40fd36 <missing_captbl_node_expand+0x2f6>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40fd9d:	41 8b 42 08          	mov    eax,DWORD PTR [r10+0x8]
	__asm__ __volatile__(
  40fda1:	45 31 ed             	xor    r13d,r13d
  40fda4:	41 be 01 00 00 00    	mov    r14d,0x1
  40fdaa:	4c 89 fb             	mov    rbx,r15
  40fdad:	48 8b 4d b8          	mov    rcx,QWORD PTR [rbp-0x48]
  40fdb1:	4c 89 ee             	mov    rsi,r13
  40fdb4:	4c 89 f7             	mov    rdi,r14
  40fdb7:	4c 89 ea             	mov    rdx,r13
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40fdba:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40fdbd:	05 03 00 01 00       	add    eax,0x10003
	__asm__ __volatile__(
  40fdc2:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40fdc5:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40fdc9:	48 89 cd             	mov    rbp,rcx
  40fdcc:	49 b8 e0 fd 40 00 00 	movabs r8,0x40fde0
  40fdd3:	00 00 00 
  40fdd6:	0f 05                	syscall 
  40fdd8:	eb 0d                	jmp    40fde7 <missing_captbl_node_expand+0x3a7>
  40fdda:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40fde0:	b9 00 00 00 00       	mov    ecx,0x0
  40fde5:	eb 05                	jmp    40fdec <missing_captbl_node_expand+0x3ac>
  40fde7:	b9 01 00 00 00       	mov    ecx,0x1
  40fdec:	5d                   	pop    rbp
  40fded:	5c                   	pop    rsp
			if (ret) {
  40fdee:	85 c0                	test   eax,eax
  40fdf0:	74 9e                	je     40fd90 <missing_captbl_node_expand+0x350>
	return __mem_bump_alloc(ci, 1, 1);
  40fdf2:	4c 89 d7             	mov    rdi,r10
  40fdf5:	4c 89 55 a8          	mov    QWORD PTR [rbp-0x58],r10
				frontier = test_cap - CAPMAX_ENTRY_SZ;
  40fdf9:	49 8d 5f fc          	lea    rbx,[r15-0x4]
	return __mem_bump_alloc(ci, 1, 1);
  40fdfd:	48 b8 b0 e2 40 00 00 	movabs rax,0x40e2b0
  40fe04:	00 00 00 
  40fe07:	ff d0                	call   rax
				assert(kmem); /* FIXME: should have a failure semantics for capids */
  40fe09:	4c 8b 55 a8          	mov    r10,QWORD PTR [rbp-0x58]
  40fe0d:	48 85 c0             	test   rax,rax
	return __mem_bump_alloc(ci, 1, 1);
  40fe10:	48 89 c7             	mov    rdi,rax
				assert(kmem); /* FIXME: should have a failure semantics for capids */
  40fe13:	0f 84 cd 00 00 00    	je     40fee6 <missing_captbl_node_expand+0x4a6>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40fe19:	41 8b 42 08          	mov    eax,DWORD PTR [r10+0x8]
	__asm__ __volatile__(
  40fe1d:	49 8b b2 98 00 00 00 	mov    rsi,QWORD PTR [r10+0x98]
  40fe24:	4c 89 f2             	mov    rdx,r14
  40fe27:	48 8b 4d b8          	mov    rcx,QWORD PTR [rbp-0x48]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40fe2b:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40fe2e:	05 1e 00 01 00       	add    eax,0x1001e
	__asm__ __volatile__(
  40fe33:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40fe36:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40fe3a:	48 89 cd             	mov    rbp,rcx
  40fe3d:	49 b8 58 fe 40 00 00 	movabs r8,0x40fe58
  40fe44:	00 00 00 
  40fe47:	0f 05                	syscall 
  40fe49:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  40fe50:	eb 0d                	jmp    40fe5f <missing_captbl_node_expand+0x41f>
  40fe52:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40fe58:	b9 00 00 00 00       	mov    ecx,0x0
  40fe5d:	eb 05                	jmp    40fe64 <missing_captbl_node_expand+0x424>
  40fe5f:	b9 01 00 00 00       	mov    ecx,0x1
  40fe64:	5d                   	pop    rbp
  40fe65:	5c                   	pop    rsp
				if (call_cap_op(root_source->captbl_cap, CAPTBL_OP_CAPTBLACTIVATE, frontier, root_source->mi.pgtbl_cap, kmem, 1)) {
  40fe66:	85 c0                	test   eax,eax
  40fe68:	0f 85 f0 00 00 00    	jne    40ff5e <missing_captbl_node_expand+0x51e>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40fe6e:	41 8b 42 08          	mov    eax,DWORD PTR [r10+0x8]
	__asm__ __volatile__(
  40fe72:	48 8b 4d b8          	mov    rcx,QWORD PTR [rbp-0x48]
  40fe76:	4c 89 fe             	mov    rsi,r15
  40fe79:	4c 89 ef             	mov    rdi,r13
  40fe7c:	4c 89 ea             	mov    rdx,r13
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40fe7f:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40fe82:	05 01 00 01 00       	add    eax,0x10001
	__asm__ __volatile__(
  40fe87:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40fe8a:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40fe8e:	48 89 cd             	mov    rbp,rcx
  40fe91:	49 b8 a8 fe 40 00 00 	movabs r8,0x40fea8
  40fe98:	00 00 00 
  40fe9b:	0f 05                	syscall 
  40fe9d:	0f 1f 00             	nop    DWORD PTR [rax]
  40fea0:	eb 0d                	jmp    40feaf <missing_captbl_node_expand+0x46f>
  40fea2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40fea8:	b9 00 00 00 00       	mov    ecx,0x0
  40fead:	eb 05                	jmp    40feb4 <missing_captbl_node_expand+0x474>
  40feaf:	b9 01 00 00 00       	mov    ecx,0x1
  40feb4:	5d                   	pop    rbp
  40feb5:	5c                   	pop    rsp
				if (call_cap_op(root_source->captbl_cap, CAPTBL_OP_CONS, frontier, test_cap, 0, 0)) {
  40feb6:	85 c0                	test   eax,eax
  40feb8:	0f 84 d2 fe ff ff    	je     40fd90 <missing_captbl_node_expand+0x350>
  40febe:	48 bf 20 07 42 00 00 	movabs rdi,0x420720
  40fec5:	00 00 00 
  40fec8:	be 2e 00 00 00       	mov    esi,0x2e
  40fecd:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40fed4:	00 00 00 
  40fed7:	ff d0                	call   rax
					assert(0); /* race? */
  40fed9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40fee0:	00 00 00 00 
  40fee4:	0f 0b                	ud2    
  40fee6:	48 bf c0 06 42 00 00 	movabs rdi,0x4206c0
  40feed:	00 00 00 
  40fef0:	be 2e 00 00 00       	mov    esi,0x2e
  40fef5:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40fefc:	00 00 00 
  40feff:	ff d0                	call   rax
				assert(kmem); /* FIXME: should have a failure semantics for capids */
  40ff01:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ff08:	00 00 00 00 
  40ff0c:	0f 0b                	ud2    
  40ff0e:	48 bf 50 07 42 00 00 	movabs rdi,0x420750
  40ff15:	00 00 00 
  40ff18:	be 2e 00 00 00       	mov    esi,0x2e
  40ff1d:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40ff24:	00 00 00 
  40ff27:	ff d0                	call   rax
		assert(!ret);
  40ff29:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ff30:	00 00 00 00 
  40ff34:	0f 0b                	ud2    
  40ff36:	48 bf b0 07 42 00 00 	movabs rdi,0x4207b0
  40ff3d:	00 00 00 
  40ff40:	be 2e 00 00 00       	mov    esi,0x2e
  40ff45:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40ff4c:	00 00 00 
  40ff4f:	ff d0                	call   rax
					assert(0); /* race condition? */
  40ff51:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ff58:	00 00 00 00 
  40ff5c:	0f 0b                	ud2    
  40ff5e:	48 bf f0 06 42 00 00 	movabs rdi,0x4206f0
  40ff65:	00 00 00 
  40ff68:	be 2e 00 00 00       	mov    esi,0x2e
  40ff6d:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  40ff74:	00 00 00 
  40ff77:	ff d0                	call   rax
					assert(0); /* race condition? */
  40ff79:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ff80:	00 00 00 00 
  40ff84:	0f 0b                	ud2    
  40ff86:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40ff8d:	00 00 00 

000000000040ff90 <cos_comp_capfrontier_update>:

void
cos_comp_capfrontier_update(struct cos_compinfo *ci, capid_t cap_frontier, int try_expand)
{
  40ff90:	f3 0f 1e fa          	endbr64 
	missing_captbl_node_expand(ci);
  40ff94:	48 b8 40 fa 40 00 00 	movabs rax,0x40fa40
  40ff9b:	00 00 00 
{
  40ff9e:	55                   	push   rbp
  40ff9f:	66 48 0f 6e ce       	movq   xmm1,rsi
  40ffa4:	66 0f 6c c9          	punpcklqdq xmm1,xmm1
  40ffa8:	48 89 e5             	mov    rbp,rsp
  40ffab:	41 57                	push   r15
  40ffad:	41 89 d7             	mov    r15d,edx
  40ffb0:	41 56                	push   r14
  40ffb2:	49 89 f6             	mov    r14,rsi
  40ffb5:	41 55                	push   r13
  40ffb7:	49 89 fd             	mov    r13,rdi
  40ffba:	41 54                	push   r12
  40ffbc:	53                   	push   rbx
  40ffbd:	48 83 ec 38          	sub    rsp,0x38
  40ffc1:	0f 29 4d b0          	movaps XMMWORD PTR [rbp-0x50],xmm1
	missing_captbl_node_expand(ci);
  40ffc5:	ff d0                	call   rax
	// printc("mmp???:cap_frontier:%d, ci->cap_frontier:%d, ci->caprange_frontier:%d\n", cap_frontier, ci->cap_frontier, ci->caprange_frontier);
	if (cap_frontier <= ci->cap_frontier) return;
  40ffc7:	4d 39 75 18          	cmp    QWORD PTR [r13+0x18],r14
  40ffcb:	0f 83 2c 01 00 00    	jae    4100fd <cos_comp_capfrontier_update+0x16d>

	if (try_expand) {
  40ffd1:	45 85 ff             	test   r15d,r15d
  40ffd4:	0f 84 de 00 00 00    	je     4100b8 <cos_comp_capfrontier_update+0x128>
        __asm__ __volatile__("lock " PS_CAS_STR
  40ffda:	41 bf 01 00 00 00    	mov    r15d,0x1
		while (cap_frontier > ci->caprange_frontier) {
  40ffe0:	49 8b 45 20          	mov    rax,QWORD PTR [r13+0x20]
  40ffe4:	4c 39 f0             	cmp    rax,r14
  40ffe7:	0f 83 cb 00 00 00    	jae    4100b8 <cos_comp_capfrontier_update+0x128>
  40ffed:	4d 8b 65 60          	mov    r12,QWORD PTR [r13+0x60]
	return ci->memsrc;
  40fff1:	49 8b 54 24 60       	mov    rdx,QWORD PTR [r12+0x60]
			ci->cap_frontier = ci->caprange_frontier;	
  40fff6:	49 89 45 18          	mov    QWORD PTR [r13+0x18],rax
	assert(__compinfo_metacap(meta) == meta);
  40fffa:	4c 39 e2             	cmp    rdx,r12
  40fffd:	0f 85 08 02 00 00    	jne    41020b <cos_comp_capfrontier_update+0x27b>
		frontier = ps_load(&ci->caprange_frontier) - CAPMAX_ENTRY_SZ;
  410003:	49 8b 5d 20          	mov    rbx,QWORD PTR [r13+0x20]
	if (self_resources) {
  410007:	49 39 d5             	cmp    r13,rdx
  41000a:	0f 84 00 01 00 00    	je     410110 <cos_comp_capfrontier_update+0x180>
	assert(ci->cap_frontier <= frontier);
  410010:	48 39 d8             	cmp    rax,rbx
  410013:	0f 87 1a 02 00 00    	ja     410233 <cos_comp_capfrontier_update+0x2a3>
	if (likely(ci->cap_frontier != frontier)) return 0;
  410019:	75 db                	jne    40fff6 <cos_comp_capfrontier_update+0x66>
	return __mem_bump_alloc(ci, 1, 1);
  41001b:	48 b8 b0 e2 40 00 00 	movabs rax,0x40e2b0
  410022:	00 00 00 
  410025:	4c 89 ef             	mov    rdi,r13
  410028:	ff d0                	call   rax
	assert(kmem); /* FIXME: should have a failure semantics for capids */
  41002a:	45 31 d2             	xor    r10d,r10d
	return __mem_bump_alloc(ci, 1, 1);
  41002d:	48 89 45 a8          	mov    QWORD PTR [rbp-0x58],rax
	assert(kmem); /* FIXME: should have a failure semantics for capids */
  410031:	48 85 c0             	test   rax,rax
  410034:	0f 84 c2 02 00 00    	je     4102fc <cos_comp_capfrontier_update+0x36c>
	if (self_resources) {
  41003a:	4d 39 e5             	cmp    r13,r12
  41003d:	0f 84 ec 00 00 00    	je     41012f <cos_comp_capfrontier_update+0x19f>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  410043:	49 8d 94 24 b0 00 00 	lea    rdx,[r12+0xb0]
  41004a:	00 
  41004b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  410050:	4c 89 d0             	mov    rax,r10
  410053:	f0 4c 0f b1 3a       	lock cmpxchg QWORD PTR [rdx],r15
  410058:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  41005b:	84 c0                	test   al,al
  41005d:	74 f1                	je     410050 <cos_comp_capfrontier_update+0xc0>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  41005f:	41 f6 44 24 38 03    	test   BYTE PTR [r12+0x38],0x3
  410065:	0f 84 68 02 00 00    	je     4102d3 <cos_comp_capfrontier_update+0x343>
        __asm__ __volatile__("lock " PS_FAA_STR
  41006b:	bb 04 00 00 00       	mov    ebx,0x4
  410070:	f0 49 0f c1 5c 24 38 	lock xadd QWORD PTR [r12+0x38],rbx
{ l->o = 0; }
  410077:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  41007e:	00 00 00 00 00 
		assert(captblcap);
  410083:	48 85 db             	test   rbx,rbx
  410086:	0f 85 a3 00 00 00    	jne    41012f <cos_comp_capfrontier_update+0x19f>
  41008c:	48 bf 80 02 42 00 00 	movabs rdi,0x420280
  410093:	00 00 00 
  410096:	be 2e 00 00 00       	mov    esi,0x2e
  41009b:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4100a2:	00 00 00 
  4100a5:	ff d0                	call   rax
  4100a7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4100ae:	00 00 00 00 
  4100b2:	0f 0b                	ud2    
  4100b4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	assert(round_up_to_pow2(cap_frontier, CAPMAX_ENTRY_SZ) == cap_frontier);
  4100b8:	49 8d 46 03          	lea    rax,[r14+0x3]
  4100bc:	48 83 e0 fc          	and    rax,0xfffffffffffffffc
  4100c0:	49 39 c6             	cmp    r14,rax
  4100c3:	0f 85 ba 01 00 00    	jne    410283 <cos_comp_capfrontier_update+0x2f3>
	ci->cap_frontier = cap_frontier;
  4100c9:	4d 89 75 18          	mov    QWORD PTR [r13+0x18],r14
	if (cap_frontier < CAPTBL_EXPAND_SZ) {
  4100cd:	49 83 fe 7f          	cmp    r14,0x7f
  4100d1:	76 4d                	jbe    410120 <cos_comp_capfrontier_update+0x190>
		ci->caprange_frontier = round_up_to_pow2(cap_frontier + CAPTBL_EXPAND_SZ, CAPTBL_EXPAND_SZ * 2) - CAPTBL_EXPAND_SZ;
  4100d3:	49 8d 86 7f 01 00 00 	lea    rax,[r14+0x17f]
  4100da:	30 c0                	xor    al,al
  4100dc:	48 83 c0 80          	add    rax,0xffffffffffffff80
  4100e0:	66 48 0f 6e c0       	movq   xmm0,rax
		ci->cap16_frontier[i] = ci->cap32_frontier[i] = ci->cap64_frontier[i] = cap_frontier;
  4100e5:	66 0f 6f 5d b0       	movdqa xmm3,XMMWORD PTR [rbp-0x50]
  4100ea:	66 49 0f 6e d6       	movq   xmm2,r14
  4100ef:	66 0f 6c c2          	punpcklqdq xmm0,xmm2
  4100f3:	41 0f 11 45 20       	movups XMMWORD PTR [r13+0x20],xmm0
  4100f8:	41 0f 11 5d 30       	movups XMMWORD PTR [r13+0x30],xmm3
			__capid_captbl_check_expand(ci);
		}
	}

	cos_capfrontier_init(ci, cap_frontier);
}
  4100fd:	48 83 c4 38          	add    rsp,0x38
  410101:	5b                   	pop    rbx
  410102:	41 5c                	pop    r12
  410104:	41 5d                	pop    r13
  410106:	41 5e                	pop    r14
  410108:	41 5f                	pop    r15
  41010a:	5d                   	pop    rbp
  41010b:	c3                   	ret    
  41010c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		frontier = ps_load(&ci->caprange_frontier) - CAPMAX_ENTRY_SZ;
  410110:	48 83 eb 04          	sub    rbx,0x4
  410114:	e9 f7 fe ff ff       	jmp    410010 <cos_comp_capfrontier_update+0x80>
  410119:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		ci->caprange_frontier = round_up_to_pow2(cap_frontier, CAPTBL_EXPAND_SZ);
  410120:	49 8d 46 7f          	lea    rax,[r14+0x7f]
  410124:	48 83 e0 80          	and    rax,0xffffffffffffff80
  410128:	66 48 0f 6e c0       	movq   xmm0,rax
  41012d:	eb b6                	jmp    4100e5 <cos_comp_capfrontier_update+0x155>
	captblid_add = ps_load(&ci->caprange_frontier);
  41012f:	49 8b 45 20          	mov    rax,QWORD PTR [r13+0x20]
  410133:	49 89 c2             	mov    r10,rax
	assert(captblid_add % CAPTBL_EXPAND_SZ == 0);
  410136:	83 e0 7f             	and    eax,0x7f
  410139:	48 89 45 a0          	mov    QWORD PTR [rbp-0x60],rax
  41013d:	0f 85 e1 01 00 00    	jne    410324 <cos_comp_capfrontier_update+0x394>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  410143:	41 8b 44 24 08       	mov    eax,DWORD PTR [r12+0x8]
	__asm__ __volatile__(
  410148:	48 8b 7d a8          	mov    rdi,QWORD PTR [rbp-0x58]
  41014c:	4c 89 fa             	mov    rdx,r15
  41014f:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  410153:	49 8b b4 24 98 00 00 	mov    rsi,QWORD PTR [r12+0x98]
  41015a:	00 
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  41015b:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  41015e:	05 1e 00 01 00       	add    eax,0x1001e
	__asm__ __volatile__(
  410163:	48 89 29             	mov    QWORD PTR [rcx],rbp
  410166:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  41016a:	48 89 cd             	mov    rbp,rcx
  41016d:	49 b8 88 01 41 00 00 	movabs r8,0x410188
  410174:	00 00 00 
  410177:	0f 05                	syscall 
  410179:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  410180:	eb 0d                	jmp    41018f <cos_comp_capfrontier_update+0x1ff>
  410182:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410188:	b9 00 00 00 00       	mov    ecx,0x0
  41018d:	eb 05                	jmp    410194 <cos_comp_capfrontier_update+0x204>
  41018f:	b9 01 00 00 00       	mov    ecx,0x1
  410194:	5d                   	pop    rbp
  410195:	5c                   	pop    rsp
	if (call_cap_op(meta->captbl_cap, CAPTBL_OP_CAPTBLACTIVATE, captblcap, meta->mi.pgtbl_cap, kmem, 1)) {
  410196:	85 c0                	test   eax,eax
  410198:	0f 85 bd 00 00 00    	jne    41025b <cos_comp_capfrontier_update+0x2cb>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  41019e:	41 8b 45 08          	mov    eax,DWORD PTR [r13+0x8]
	__asm__ __volatile__(
  4101a2:	48 8b 7d a0          	mov    rdi,QWORD PTR [rbp-0x60]
  4101a6:	4c 89 d6             	mov    rsi,r10
  4101a9:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4101ad:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  4101b0:	48 89 fa             	mov    rdx,rdi
	cap_no += op;
  4101b3:	05 01 00 01 00       	add    eax,0x10001
	__asm__ __volatile__(
  4101b8:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4101bb:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4101bf:	48 89 cd             	mov    rbp,rcx
  4101c2:	49 b8 d8 01 41 00 00 	movabs r8,0x4101d8
  4101c9:	00 00 00 
  4101cc:	0f 05                	syscall 
  4101ce:	66 90                	xchg   ax,ax
  4101d0:	eb 0d                	jmp    4101df <cos_comp_capfrontier_update+0x24f>
  4101d2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4101d8:	b9 00 00 00 00       	mov    ecx,0x0
  4101dd:	eb 05                	jmp    4101e4 <cos_comp_capfrontier_update+0x254>
  4101df:	b9 01 00 00 00       	mov    ecx,0x1
  4101e4:	5d                   	pop    rbp
  4101e5:	5c                   	pop    rsp
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_CONS, captblcap, captblid_add, 0, 0)) {
  4101e6:	85 c0                	test   eax,eax
  4101e8:	0f 85 bd 00 00 00    	jne    4102ab <cos_comp_capfrontier_update+0x31b>
	frontier       = ps_load(&ci->cap_frontier);
  4101ee:	49 8b 45 18          	mov    rax,QWORD PTR [r13+0x18]
        __asm__ __volatile__("lock " PS_FAA_STR
  4101f2:	ba 00 01 00 00       	mov    edx,0x100
  4101f7:	f0 49 0f c1 55 20    	lock xadd QWORD PTR [r13+0x20],rdx
        __asm__ __volatile__("lock " PS_CAS_STR
  4101fd:	f0 49 0f b1 55 18    	lock cmpxchg QWORD PTR [r13+0x18],rdx
  410203:	0f 94 c0             	sete   al
	return 0;
  410206:	e9 d5 fd ff ff       	jmp    40ffe0 <cos_comp_capfrontier_update+0x50>
  41020b:	48 bf f0 01 42 00 00 	movabs rdi,0x4201f0
  410212:	00 00 00 
  410215:	be 2e 00 00 00       	mov    esi,0x2e
  41021a:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  410221:	00 00 00 
  410224:	ff d0                	call   rax
	assert(__compinfo_metacap(meta) == meta);
  410226:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41022d:	00 00 00 00 
  410231:	0f 0b                	ud2    
  410233:	48 bf 20 02 42 00 00 	movabs rdi,0x420220
  41023a:	00 00 00 
  41023d:	be 2e 00 00 00       	mov    esi,0x2e
  410242:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  410249:	00 00 00 
  41024c:	ff d0                	call   rax
	assert(ci->cap_frontier <= frontier);
  41024e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410255:	00 00 00 00 
  410259:	0f 0b                	ud2    
  41025b:	48 bf e0 02 42 00 00 	movabs rdi,0x4202e0
  410262:	00 00 00 
  410265:	be 2e 00 00 00       	mov    esi,0x2e
  41026a:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  410271:	00 00 00 
  410274:	ff d0                	call   rax
		assert(0); /* race condition? */
  410276:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41027d:	00 00 00 00 
  410281:	0f 0b                	ud2    
  410283:	48 bf b0 05 42 00 00 	movabs rdi,0x4205b0
  41028a:	00 00 00 
  41028d:	be 2e 00 00 00       	mov    esi,0x2e
  410292:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  410299:	00 00 00 
  41029c:	ff d0                	call   rax
	assert(round_up_to_pow2(cap_frontier, CAPMAX_ENTRY_SZ) == cap_frontier);
  41029e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4102a5:	00 00 00 00 
  4102a9:	0f 0b                	ud2    
  4102ab:	48 bf 10 03 42 00 00 	movabs rdi,0x420310
  4102b2:	00 00 00 
  4102b5:	be 2e 00 00 00       	mov    esi,0x2e
  4102ba:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4102c1:	00 00 00 
  4102c4:	ff d0                	call   rax
		assert(0); /* race? */
  4102c6:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4102cd:	00 00 00 00 
  4102d1:	0f 0b                	ud2    
		if (__capid_captbl_check_expand(ci)) goto error;
  4102d3:	48 b8 50 e4 40 00 00 	movabs rax,0x40e450
  4102da:	00 00 00 
  4102dd:	4c 89 e7             	mov    rdi,r12
  4102e0:	ff d0                	call   rax
  4102e2:	85 c0                	test   eax,eax
  4102e4:	75 66                	jne    41034c <cos_comp_capfrontier_update+0x3bc>
        __asm__ __volatile__("lock " PS_FAA_STR
  4102e6:	b8 04 00 00 00       	mov    eax,0x4
  4102eb:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  4102f2:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  4102f7:	e9 6f fd ff ff       	jmp    41006b <cos_comp_capfrontier_update+0xdb>
  4102fc:	48 bf 50 02 42 00 00 	movabs rdi,0x420250
  410303:	00 00 00 
  410306:	be 2e 00 00 00       	mov    esi,0x2e
  41030b:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  410312:	00 00 00 
  410315:	ff d0                	call   rax
	assert(kmem); /* FIXME: should have a failure semantics for capids */
  410317:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41031e:	00 00 00 00 
  410322:	0f 0b                	ud2    
  410324:	48 bf b0 02 42 00 00 	movabs rdi,0x4202b0
  41032b:	00 00 00 
  41032e:	be 2e 00 00 00       	mov    esi,0x2e
  410333:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  41033a:	00 00 00 
  41033d:	ff d0                	call   rax
	assert(captblid_add % CAPTBL_EXPAND_SZ == 0);
  41033f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410346:	00 00 00 00 
  41034a:	0f 0b                	ud2    
{ l->o = 0; }
  41034c:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  410353:	00 00 00 00 00 
		assert(captblcap);
  410358:	e9 2f fd ff ff       	jmp    41008c <cos_comp_capfrontier_update+0xfc>
  41035d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000410360 <cos_thd_id_alloc>:
 */
unsigned long __thdid_alloc = NUM_CPU + 2;

thdid_t
cos_thd_id_alloc(void)
{
  410360:	f3 0f 1e fa          	endbr64 
        __asm__ __volatile__("lock " PS_FAA_STR
  410364:	48 ba 80 00 46 00 00 	movabs rdx,0x460080
  41036b:	00 00 00 
  41036e:	b8 01 00 00 00       	mov    eax,0x1
  410373:	f0 48 0f c1 02       	lock xadd QWORD PTR [rdx],rax
  thdid_t assignment = (thdid_t)id;

  assert((unsigned long)assignment == id);

  return assignment;
}
  410378:	c3                   	ret    
  410379:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000410380 <cos_ulk_page_alloc>:
	return toplvl;
}

ulkcap_t
cos_ulk_page_alloc(struct cos_compinfo *ci, pgtblcap_t ulkpt, vaddr_t uaddr)
{
  410380:	f3 0f 1e fa          	endbr64 
	return livenessid_frontier++;
  410384:	48 b8 c0 00 46 00 00 	movabs rax,0x4600c0
  41038b:	00 00 00 
{
  41038e:	55                   	push   rbp
  41038f:	48 89 e5             	mov    rbp,rsp
  410392:	41 57                	push   r15
  410394:	41 56                	push   r14
  410396:	41 55                	push   r13
  410398:	41 54                	push   r12
  41039a:	53                   	push   rbx
  41039b:	48 83 ec 28          	sub    rsp,0x28
	return livenessid_frontier++;
  41039f:	44 8b 08             	mov    r9d,DWORD PTR [rax]
	return ci->memsrc;
  4103a2:	4c 8b 67 60          	mov    r12,QWORD PTR [rdi+0x60]
{
  4103a6:	48 89 55 b0          	mov    QWORD PTR [rbp-0x50],rdx
	return livenessid_frontier++;
  4103aa:	41 8d 51 01          	lea    edx,[r9+0x1]
  4103ae:	89 10                	mov    DWORD PTR [rax],edx
	vaddr_t kmem;
	capid_t cap;
	u32_t   lid = livenessid_bump_alloc();

	printd("cos_ulk_pgtbl_create\n");
	assert(ci_resources && ulkpt);
  4103b0:	4d 85 e4             	test   r12,r12
  4103b3:	0f 84 b0 01 00 00    	je     410569 <cos_ulk_page_alloc+0x1e9>
  4103b9:	49 89 f5             	mov    r13,rsi
  4103bc:	48 85 f6             	test   rsi,rsi
  4103bf:	0f 84 a4 01 00 00    	je     410569 <cos_ulk_page_alloc+0x1e9>
  4103c5:	44 89 4d bc          	mov    DWORD PTR [rbp-0x44],r9d
	return __mem_bump_alloc(ci, 1, 1);
  4103c9:	4c 89 e7             	mov    rdi,r12
  4103cc:	48 b8 b0 e2 40 00 00 	movabs rax,0x40e2b0
  4103d3:	00 00 00 
  4103d6:	ff d0                	call   rax
  4103d8:	49 89 c6             	mov    r14,rax
	if (!*kmem) return -1;
  4103db:	48 85 c0             	test   rax,rax
  4103de:	0f 84 ad 01 00 00    	je     410591 <cos_ulk_page_alloc+0x211>
        __asm__ __volatile__("lock " PS_CAS_STR
  4103e4:	44 8b 4d bc          	mov    r9d,DWORD PTR [rbp-0x44]
{ while (!ps_cas(&l->o, 0, 1)) ; }
  4103e8:	49 8d 8c 24 b0 00 00 	lea    rcx,[r12+0xb0]
  4103ef:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  4103f0:	ba 01 00 00 00       	mov    edx,0x1
  4103f5:	45 31 c0             	xor    r8d,r8d
  4103f8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4103ff:	00 
  410400:	4c 89 c0             	mov    rax,r8
  410403:	f0 48 0f b1 11       	lock cmpxchg QWORD PTR [rcx],rdx
  410408:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  41040b:	84 c0                	test   al,al
  41040d:	74 f1                	je     410400 <cos_ulk_page_alloc+0x80>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  41040f:	4d 8b 7c 24 30       	mov    r15,QWORD PTR [r12+0x30]
  410414:	41 83 e7 03          	and    r15d,0x3
  410418:	0f 84 b2 00 00 00    	je     4104d0 <cos_ulk_page_alloc+0x150>
        __asm__ __volatile__("lock " PS_FAA_STR
  41041e:	bb 02 00 00 00       	mov    ebx,0x2
  410423:	f0 49 0f c1 5c 24 30 	lock xadd QWORD PTR [r12+0x30],rbx
{ l->o = 0; }
  41042a:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  410431:	00 00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  410436:	49 89 df             	mov    r15,rbx
	if (!*cap) return -1;
  410439:	48 85 db             	test   rbx,rbx
  41043c:	0f 84 4f 01 00 00    	je     410591 <cos_ulk_page_alloc+0x211>

	if (__alloc_mem_cap(ci_resources, CAP_ULK, &kmem, &cap)) return 0;
	assert(kmem && (round_to_page(kmem) == kmem));
  410442:	41 f7 c6 ff 0f 00 00 	test   r14d,0xfff
  410449:	0f 85 f2 00 00 00    	jne    410541 <cos_ulk_page_alloc+0x1c1>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  41044f:	41 8b 44 24 08       	mov    eax,DWORD PTR [r12+0x8]
	if (call_cap_op(ci_resources->captbl_cap, CAPTBL_OP_ULK_MEMACTIVATE, cap << 16 | lid, ci_resources->mi.pgtbl_cap << 16 | ulkpt, kmem, uaddr))
  410454:	48 c1 e3 10          	shl    rbx,0x10
  410458:	45 89 c9             	mov    r9d,r9d
	__asm__ __volatile__(
  41045b:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  41045f:	49 8b 94 24 98 00 00 	mov    rdx,QWORD PTR [r12+0x98]
  410466:	00 
  410467:	4c 09 cb             	or     rbx,r9
  41046a:	4c 89 f7             	mov    rdi,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  41046d:	c1 e0 10             	shl    eax,0x10
  410470:	48 c1 e2 10          	shl    rdx,0x10
	cap_no += op;
  410474:	05 38 00 01 00       	add    eax,0x10038
  410479:	48 89 d6             	mov    rsi,rdx
	__asm__ __volatile__(
  41047c:	48 8b 55 b0          	mov    rdx,QWORD PTR [rbp-0x50]
  410480:	4c 09 ee             	or     rsi,r13
  410483:	48 89 29             	mov    QWORD PTR [rcx],rbp
  410486:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  41048a:	48 89 cd             	mov    rbp,rcx
  41048d:	49 b8 a8 04 41 00 00 	movabs r8,0x4104a8
  410494:	00 00 00 
  410497:	0f 05                	syscall 
  410499:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  4104a0:	eb 0d                	jmp    4104af <cos_ulk_page_alloc+0x12f>
  4104a2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4104a8:	b9 00 00 00 00       	mov    ecx,0x0
  4104ad:	eb 05                	jmp    4104b4 <cos_ulk_page_alloc+0x134>
  4104af:	b9 01 00 00 00       	mov    ecx,0x1
  4104b4:	5d                   	pop    rbp
  4104b5:	5c                   	pop    rsp
  4104b6:	85 c0                	test   eax,eax
  4104b8:	75 4e                	jne    410508 <cos_ulk_page_alloc+0x188>
		BUG();

	return cap;
}
  4104ba:	48 83 c4 28          	add    rsp,0x28
  4104be:	4c 89 f8             	mov    rax,r15
  4104c1:	5b                   	pop    rbx
  4104c2:	41 5c                	pop    r12
  4104c4:	41 5d                	pop    r13
  4104c6:	41 5e                	pop    r14
  4104c8:	41 5f                	pop    r15
  4104ca:	5d                   	pop    rbp
  4104cb:	c3                   	ret    
  4104cc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  4104d0:	44 89 4d bc          	mov    DWORD PTR [rbp-0x44],r9d
		if (__capid_captbl_check_expand(ci)) goto error;
  4104d4:	4c 89 e7             	mov    rdi,r12
  4104d7:	48 b8 50 e4 40 00 00 	movabs rax,0x40e450
  4104de:	00 00 00 
  4104e1:	ff d0                	call   rax
  4104e3:	44 8b 4d bc          	mov    r9d,DWORD PTR [rbp-0x44]
  4104e7:	85 c0                	test   eax,eax
  4104e9:	75 45                	jne    410530 <cos_ulk_page_alloc+0x1b0>
        __asm__ __volatile__("lock " PS_FAA_STR
  4104eb:	b8 04 00 00 00       	mov    eax,0x4
  4104f0:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  4104f7:	49 89 44 24 30       	mov    QWORD PTR [r12+0x30],rax
  4104fc:	e9 1d ff ff ff       	jmp    41041e <cos_ulk_page_alloc+0x9e>
  410501:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  410508:	48 bf 6f 08 42 00 00 	movabs rdi,0x42086f
  41050f:	00 00 00 
  410512:	be 1b 00 00 00       	mov    esi,0x1b
  410517:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  41051e:	00 00 00 
  410521:	ff d0                	call   rax
		BUG();
  410523:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41052a:	00 00 00 00 
  41052e:	0f 0b                	ud2    
{ l->o = 0; }
  410530:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  410537:	00 00 00 00 00 
	if (!*cap) return -1;
  41053c:	e9 79 ff ff ff       	jmp    4104ba <cos_ulk_page_alloc+0x13a>
  410541:	48 bf 40 08 42 00 00 	movabs rdi,0x420840
  410548:	00 00 00 
  41054b:	be 2e 00 00 00       	mov    esi,0x2e
  410550:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  410557:	00 00 00 
  41055a:	ff d0                	call   rax
	assert(kmem && (round_to_page(kmem) == kmem));
  41055c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410563:	00 00 00 00 
  410567:	0f 0b                	ud2    
  410569:	48 bf 10 08 42 00 00 	movabs rdi,0x420810
  410570:	00 00 00 
  410573:	be 2e 00 00 00       	mov    esi,0x2e
  410578:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  41057f:	00 00 00 
  410582:	ff d0                	call   rax
	assert(ci_resources && ulkpt);
  410584:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41058b:	00 00 00 00 
  41058f:	0f 0b                	ud2    
	if (__alloc_mem_cap(ci_resources, CAP_ULK, &kmem, &cap)) return 0;
  410591:	45 31 ff             	xor    r15d,r15d
  410594:	e9 21 ff ff ff       	jmp    4104ba <cos_ulk_page_alloc+0x13a>
  410599:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

00000000004105a0 <__cos_thd_alloc>:
	return __cos_ulk_info.curr_pg;
}

static thdcap_t
__cos_thd_alloc(struct cos_compinfo *ci, compcap_t comp, thdclosure_index_t init_data, thdid_t tid)
{
  4105a0:	f3 0f 1e fa          	endbr64 
  4105a4:	55                   	push   rbp
  4105a5:	48 89 e5             	mov    rbp,rsp
  4105a8:	41 57                	push   r15
  4105aa:	41 56                	push   r14
  4105ac:	41 55                	push   r13
  4105ae:	41 54                	push   r12
  4105b0:	53                   	push   rbx
  4105b1:	48 83 ec 28          	sub    rsp,0x28
  4105b5:	48 89 4d b8          	mov    QWORD PTR [rbp-0x48],rcx
	capid_t  cap;
	int      ret;

	printd("cos_thd_alloc\n");

	assert(ci && comp > 0);
  4105b9:	48 85 ff             	test   rdi,rdi
  4105bc:	0f 84 06 02 00 00    	je     4107c8 <__cos_thd_alloc+0x228>
  4105c2:	49 89 f7             	mov    r15,rsi
  4105c5:	48 85 f6             	test   rsi,rsi
  4105c8:	0f 84 fa 01 00 00    	je     4107c8 <__cos_thd_alloc+0x228>
	if (!__cos_ulk_info.toplvl) return 0;
  4105ce:	48 b8 80 4a 5a 00 00 	movabs rax,0x5a4a80
  4105d5:	00 00 00 
  4105d8:	4c 8b 20             	mov    r12,QWORD PTR [rax]
  4105db:	49 89 fd             	mov    r13,rdi
  4105de:	89 d3                	mov    ebx,edx
  4105e0:	4d 85 e4             	test   r12,r12
  4105e3:	74 68                	je     41064d <__cos_thd_alloc+0xad>
	if (!__cos_ulk_info.curr_pg || tid % ULK_STACKS_PER_PAGE == 0) {
  4105e5:	48 a1 90 4a 5a 00 00 	movabs rax,ds:0x5a4a90
  4105ec:	00 00 00 
  4105ef:	48 85 c0             	test   rax,rax
  4105f2:	74 0a                	je     4105fe <__cos_thd_alloc+0x5e>
  4105f4:	f6 45 b8 0f          	test   BYTE PTR [rbp-0x48],0xf
  4105f8:	0f 85 82 01 00 00    	jne    410780 <__cos_thd_alloc+0x1e0>
		__cos_ulk_info.curr_pg = cos_ulk_page_alloc(ci, __cos_ulk_info.toplvl, __cos_ulk_info.pg_frontier);
  4105fe:	48 b8 98 4a 5a 00 00 	movabs rax,0x5a4a98
  410605:	00 00 00 
  410608:	4c 89 e6             	mov    rsi,r12
  41060b:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  41060e:	4c 89 ef             	mov    rdi,r13
  410611:	48 b8 80 03 41 00 00 	movabs rax,0x410380
  410618:	00 00 00 
  41061b:	ff d0                	call   rax
  41061d:	48 a3 90 4a 5a 00 00 	movabs ds:0x5a4a90,rax
  410624:	00 00 00 
  410627:	49 89 c4             	mov    r12,rax
		assert(__cos_ulk_info.curr_pg);
  41062a:	48 85 c0             	test   rax,rax
  41062d:	0f 84 e5 01 00 00    	je     410818 <__cos_thd_alloc+0x278>
		__cos_ulk_info.pg_frontier += PAGE_SIZE;
  410633:	48 a1 98 4a 5a 00 00 	movabs rax,ds:0x5a4a98
  41063a:	00 00 00 
  41063d:	48 05 00 10 00 00    	add    rax,0x1000
  410643:	48 a3 98 4a 5a 00 00 	movabs ds:0x5a4a98,rax
  41064a:	00 00 00 
	return __mem_bump_alloc(ci, 1, 1);
  41064d:	48 b8 b0 e2 40 00 00 	movabs rax,0x40e2b0
  410654:	00 00 00 
  410657:	4c 89 ef             	mov    rdi,r13
  41065a:	ff d0                	call   rax
  41065c:	49 89 c2             	mov    r10,rax
	if (!*kmem) return -1;
  41065f:	48 85 c0             	test   rax,rax
  410662:	0f 84 d8 01 00 00    	je     410840 <__cos_thd_alloc+0x2a0>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  410668:	49 8d 8d b0 00 00 00 	lea    rcx,[r13+0xb0]
        __asm__ __volatile__("lock " PS_CAS_STR
  41066f:	ba 01 00 00 00       	mov    edx,0x1
  410674:	31 f6                	xor    esi,esi
  410676:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41067d:	00 00 00 
  410680:	48 89 f0             	mov    rax,rsi
  410683:	f0 48 0f b1 11       	lock cmpxchg QWORD PTR [rcx],rdx
  410688:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  41068b:	84 c0                	test   al,al
  41068d:	74 f1                	je     410680 <__cos_thd_alloc+0xe0>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  41068f:	4d 8b 75 28          	mov    r14,QWORD PTR [r13+0x28]
  410693:	41 83 e6 03          	and    r14d,0x3
  410697:	0f 84 b3 00 00 00    	je     410750 <__cos_thd_alloc+0x1b0>
        __asm__ __volatile__("lock " PS_FAA_STR
  41069d:	ba 01 00 00 00       	mov    edx,0x1
  4106a2:	f0 49 0f c1 55 28    	lock xadd QWORD PTR [r13+0x28],rdx
{ l->o = 0; }
  4106a8:	49 c7 85 b0 00 00 00 	mov    QWORD PTR [r13+0xb0],0x0
  4106af:	00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  4106b3:	49 89 d6             	mov    r14,rdx
	if (!*cap) return -1;
  4106b6:	48 85 d2             	test   rdx,rdx
  4106b9:	0f 84 81 01 00 00    	je     410840 <__cos_thd_alloc+0x2a0>

	ulkcap = __cos_thd_ulk_page_alloc(ci, tid);

	if (__alloc_mem_cap(ci, CAP_THD, &kmem, &cap)) return 0;
	assert(!(init_data & ~((1 << 16) - 1)));
  4106bf:	f7 c3 00 00 ff ff    	test   ebx,0xffff0000
  4106c5:	0f 85 25 01 00 00    	jne    4107f0 <__cos_thd_alloc+0x250>
	/* TODO: Add cap size checking */
	ret = call_cap_op(ci->captbl_cap, CAPTBL_OP_THDACTIVATE, (init_data << 16) | cap,
  4106cb:	c1 e3 10             	shl    ebx,0x10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4106ce:	41 8b 45 08          	mov    eax,DWORD PTR [r13+0x8]
	__asm__ __volatile__(
  4106d2:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  4106d6:	4c 89 d7             	mov    rdi,r10
  4106d9:	48 63 db             	movsxd rbx,ebx
  4106dc:	48 09 d3             	or     rbx,rdx
			  __compinfo_metacap(ci)->mi.pgtbl_cap << 16 | comp, kmem, ulkcap << 16 | tid);
  4106df:	49 8b 55 60          	mov    rdx,QWORD PTR [r13+0x60]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4106e3:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  4106e6:	05 04 00 01 00       	add    eax,0x10004
  4106eb:	48 8b b2 98 00 00 00 	mov    rsi,QWORD PTR [rdx+0x98]
  4106f2:	4c 89 e2             	mov    rdx,r12
  4106f5:	48 c1 e2 10          	shl    rdx,0x10
	ret = call_cap_op(ci->captbl_cap, CAPTBL_OP_THDACTIVATE, (init_data << 16) | cap,
  4106f9:	48 0b 55 b8          	or     rdx,QWORD PTR [rbp-0x48]
			  __compinfo_metacap(ci)->mi.pgtbl_cap << 16 | comp, kmem, ulkcap << 16 | tid);
  4106fd:	48 c1 e6 10          	shl    rsi,0x10
	ret = call_cap_op(ci->captbl_cap, CAPTBL_OP_THDACTIVATE, (init_data << 16) | cap,
  410701:	4c 09 fe             	or     rsi,r15
	__asm__ __volatile__(
  410704:	48 89 29             	mov    QWORD PTR [rcx],rbp
  410707:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  41070b:	48 89 cd             	mov    rbp,rcx
  41070e:	49 b8 28 07 41 00 00 	movabs r8,0x410728
  410715:	00 00 00 
  410718:	0f 05                	syscall 
  41071a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410720:	eb 0d                	jmp    41072f <__cos_thd_alloc+0x18f>
  410722:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410728:	b9 00 00 00 00       	mov    ecx,0x0
  41072d:	eb 05                	jmp    410734 <__cos_thd_alloc+0x194>
  41072f:	b9 01 00 00 00       	mov    ecx,0x1
  410734:	5d                   	pop    rbp
  410735:	5c                   	pop    rsp
	if (ret) BUG();
  410736:	85 c0                	test   eax,eax
  410738:	75 56                	jne    410790 <__cos_thd_alloc+0x1f0>

	return cap;
}
  41073a:	48 83 c4 28          	add    rsp,0x28
  41073e:	4c 89 f0             	mov    rax,r14
  410741:	5b                   	pop    rbx
  410742:	41 5c                	pop    r12
  410744:	41 5d                	pop    r13
  410746:	41 5e                	pop    r14
  410748:	41 5f                	pop    r15
  41074a:	5d                   	pop    rbp
  41074b:	c3                   	ret    
  41074c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  410750:	4c 89 55 b0          	mov    QWORD PTR [rbp-0x50],r10
		if (__capid_captbl_check_expand(ci)) goto error;
  410754:	4c 89 ef             	mov    rdi,r13
  410757:	48 b8 50 e4 40 00 00 	movabs rax,0x40e450
  41075e:	00 00 00 
  410761:	ff d0                	call   rax
  410763:	4c 8b 55 b0          	mov    r10,QWORD PTR [rbp-0x50]
  410767:	85 c0                	test   eax,eax
  410769:	75 4d                	jne    4107b8 <__cos_thd_alloc+0x218>
        __asm__ __volatile__("lock " PS_FAA_STR
  41076b:	b8 04 00 00 00       	mov    eax,0x4
  410770:	f0 49 0f c1 45 18    	lock xadd QWORD PTR [r13+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  410776:	49 89 45 28          	mov    QWORD PTR [r13+0x28],rax
  41077a:	e9 1e ff ff ff       	jmp    41069d <__cos_thd_alloc+0xfd>
  41077f:	90                   	nop
  410780:	49 89 c4             	mov    r12,rax
	return __cos_ulk_info.curr_pg;
  410783:	e9 c5 fe ff ff       	jmp    41064d <__cos_thd_alloc+0xad>
  410788:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41078f:	00 
  410790:	48 bf 1f 09 42 00 00 	movabs rdi,0x42091f
  410797:	00 00 00 
  41079a:	be 1b 00 00 00       	mov    esi,0x1b
  41079f:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4107a6:	00 00 00 
  4107a9:	ff d0                	call   rax
	if (ret) BUG();
  4107ab:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4107b2:	00 00 00 00 
  4107b6:	0f 0b                	ud2    
{ l->o = 0; }
  4107b8:	49 c7 85 b0 00 00 00 	mov    QWORD PTR [r13+0xb0],0x0
  4107bf:	00 00 00 00 
	if (!*cap) return -1;
  4107c3:	e9 72 ff ff ff       	jmp    41073a <__cos_thd_alloc+0x19a>
  4107c8:	48 bf 90 08 42 00 00 	movabs rdi,0x420890
  4107cf:	00 00 00 
  4107d2:	be 2e 00 00 00       	mov    esi,0x2e
  4107d7:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4107de:	00 00 00 
  4107e1:	ff d0                	call   rax
	assert(ci && comp > 0);
  4107e3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4107ea:	00 00 00 00 
  4107ee:	0f 0b                	ud2    
  4107f0:	48 bf f0 08 42 00 00 	movabs rdi,0x4208f0
  4107f7:	00 00 00 
  4107fa:	be 2e 00 00 00       	mov    esi,0x2e
  4107ff:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  410806:	00 00 00 
  410809:	ff d0                	call   rax
	assert(!(init_data & ~((1 << 16) - 1)));
  41080b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410812:	00 00 00 00 
  410816:	0f 0b                	ud2    
  410818:	48 bf c0 08 42 00 00 	movabs rdi,0x4208c0
  41081f:	00 00 00 
  410822:	be 2e 00 00 00       	mov    esi,0x2e
  410827:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  41082e:	00 00 00 
  410831:	ff d0                	call   rax
		assert(__cos_ulk_info.curr_pg);
  410833:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41083a:	00 00 00 00 
  41083e:	0f 0b                	ud2    
	if (__alloc_mem_cap(ci, CAP_THD, &kmem, &cap)) return 0;
  410840:	45 31 f6             	xor    r14d,r14d
  410843:	e9 f2 fe ff ff       	jmp    41073a <__cos_thd_alloc+0x19a>
  410848:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41084f:	00 

0000000000410850 <cos_ulk_map_in>:
{
  410850:	f3 0f 1e fa          	endbr64 
  410854:	55                   	push   rbp
  410855:	48 89 e5             	mov    rbp,rsp
  410858:	41 54                	push   r12
  41085a:	53                   	push   rbx
  41085b:	48 83 ec 10          	sub    rsp,0x10
	assert(ptc && __cos_ulk_info.secondlvl);
  41085f:	48 85 ff             	test   rdi,rdi
  410862:	74 67                	je     4108cb <cos_ulk_map_in+0x7b>
  410864:	48 b8 88 4a 5a 00 00 	movabs rax,0x5a4a88
  41086b:	00 00 00 
  41086e:	48 8b 18             	mov    rbx,QWORD PTR [rax]
  410871:	48 85 db             	test   rbx,rbx
  410874:	74 55                	je     4108cb <cos_ulk_map_in+0x7b>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  410876:	c1 e7 10             	shl    edi,0x10
	__asm__ __volatile__(
  410879:	31 d2                	xor    edx,edx
  41087b:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  41087f:	48 be 00 00 00 00 80 	movabs rsi,0x7f8000000000
  410886:	7f 00 00 
	cap_no += op;
  410889:	8d 87 01 00 01 00    	lea    eax,[rdi+0x10001]
	__asm__ __volatile__(
  41088f:	48 89 d7             	mov    rdi,rdx
  410892:	48 89 29             	mov    QWORD PTR [rcx],rbp
  410895:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  410899:	48 89 cd             	mov    rbp,rcx
  41089c:	49 b8 b0 08 41 00 00 	movabs r8,0x4108b0
  4108a3:	00 00 00 
  4108a6:	0f 05                	syscall 
  4108a8:	eb 0d                	jmp    4108b7 <cos_ulk_map_in+0x67>
  4108aa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4108b0:	b9 00 00 00 00       	mov    ecx,0x0
  4108b5:	eb 05                	jmp    4108bc <cos_ulk_map_in+0x6c>
  4108b7:	b9 01 00 00 00       	mov    ecx,0x1
  4108bc:	5d                   	pop    rbp
  4108bd:	5c                   	pop    rsp
	if (call_cap_op(ptc, CAPTBL_OP_CONS, __cos_ulk_info.secondlvl, ULK_BASE_ADDR, 0, 0)) {
  4108be:	f7 d8                	neg    eax
  4108c0:	19 c0                	sbb    eax,eax
}
  4108c2:	48 83 c4 10          	add    rsp,0x10
  4108c6:	5b                   	pop    rbx
  4108c7:	41 5c                	pop    r12
  4108c9:	5d                   	pop    rbp
  4108ca:	c3                   	ret    
  4108cb:	48 bf 40 09 42 00 00 	movabs rdi,0x420940
  4108d2:	00 00 00 
  4108d5:	be 2e 00 00 00       	mov    esi,0x2e
  4108da:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4108e1:	00 00 00 
  4108e4:	ff d0                	call   rax
	assert(ptc && __cos_ulk_info.secondlvl);
  4108e6:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4108ed:	00 00 00 00 
  4108f1:	0f 0b                	ud2    
  4108f3:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4108fa:	00 00 00 00 
  4108fe:	66 90                	xchg   ax,ax

0000000000410900 <cos_thd_alloc_ext>:

#include <cos_thd_init.h>

thdcap_t
cos_thd_alloc_ext(struct cos_compinfo *ci, compcap_t comp, thdclosure_index_t idx)
{
  410900:	f3 0f 1e fa          	endbr64 
        __asm__ __volatile__("lock " PS_FAA_STR
  410904:	48 b8 80 00 46 00 00 	movabs rax,0x460080
  41090b:	00 00 00 
  41090e:	b9 01 00 00 00       	mov    ecx,0x1
  410913:	f0 48 0f c1 08       	lock xadd QWORD PTR [rax],rcx
	thdid_t tid = cos_thd_id_alloc();

	if (idx < 1) return 0;
  410918:	85 d2                	test   edx,edx
  41091a:	7e 14                	jle    410930 <cos_thd_alloc_ext+0x30>

	return __cos_thd_alloc(ci, comp, idx, tid);
  41091c:	48 b8 a0 05 41 00 00 	movabs rax,0x4105a0
  410923:	00 00 00 
  410926:	ff e0                	jmp    rax
  410928:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41092f:	00 
}
  410930:	31 c0                	xor    eax,eax
  410932:	c3                   	ret    
  410933:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41093a:	00 00 00 00 
  41093e:	66 90                	xchg   ax,ax

0000000000410940 <cos_thd_alloc>:

thdcap_t
cos_thd_alloc(struct cos_compinfo *ci, compcap_t comp, cos_thd_fn_t fn, void *data)
{
  410940:	f3 0f 1e fa          	endbr64 
  410944:	48 b8 80 00 46 00 00 	movabs rax,0x460080
  41094b:	00 00 00 
  41094e:	41 b8 01 00 00 00    	mov    r8d,0x1
  410954:	f0 4c 0f c1 00       	lock xadd QWORD PTR [rax],r8
	if (!fn) return -1;
  410959:	48 85 d2             	test   rdx,rdx
  41095c:	0f 84 f6 00 00 00    	je     410a58 <cos_thd_alloc+0x118>
  410962:	55                   	push   rbp
  410963:	49 89 f1             	mov    r9,rsi
  410966:	49 89 ca             	mov    r10,rcx
  410969:	48 89 d6             	mov    rsi,rdx
  41096c:	45 31 db             	xor    r11d,r11d
  41096f:	48 89 e5             	mov    rbp,rsp
  410972:	41 55                	push   r13
  410974:	49 bd 40 39 5a 00 00 	movabs r13,0x5a3940
  41097b:	00 00 00 
  41097e:	41 54                	push   r12
  410980:	53                   	push   rbx
  410981:	bb 02 00 00 00       	mov    ebx,0x2
  410986:	48 83 ec 08          	sub    rsp,0x8
	for (i = 0; i < COS_THD_INIT_REGION_SIZE; i++) {
  41098a:	48 ba 40 39 5a 00 00 	movabs rdx,0x5a3940
  410991:	00 00 00 
  410994:	31 c9                	xor    ecx,ecx
		if (__thd_init_data[i].fn == NULL) {
  410996:	48 83 3a 00          	cmp    QWORD PTR [rdx],0x0
  41099a:	74 24                	je     4109c0 <cos_thd_alloc+0x80>
	for (i = 0; i < COS_THD_INIT_REGION_SIZE; i++) {
  41099c:	83 c1 01             	add    ecx,0x1
  41099f:	48 83 c2 10          	add    rdx,0x10
  4109a3:	81 f9 00 01 00 00    	cmp    ecx,0x100
  4109a9:	75 eb                	jne    410996 <cos_thd_alloc+0x56>
	if (!tried) {
  4109ab:	83 fb 01             	cmp    ebx,0x1
  4109ae:	74 73                	je     410a23 <cos_thd_alloc+0xe3>
  4109b0:	bb 01 00 00 00       	mov    ebx,0x1
  4109b5:	eb d3                	jmp    41098a <cos_thd_alloc+0x4a>
  4109b7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  4109be:	00 00 
  4109c0:	4c 89 d8             	mov    rax,r11
  4109c3:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  4109c8:	0f 94 c0             	sete   al
			if (!ret) continue;
  4109cb:	84 c0                	test   al,al
  4109cd:	74 cd                	je     41099c <cos_thd_alloc+0x5c>
			assert(__thd_init_data[i].fn == fn);
  4109cf:	4c 63 e1             	movsxd r12,ecx
  4109d2:	49 c1 e4 04          	shl    r12,0x4
  4109d6:	4d 01 ec             	add    r12,r13
  4109d9:	49 3b 34 24          	cmp    rsi,QWORD PTR [r12]
  4109dd:	75 51                	jne    410a30 <cos_thd_alloc+0xf0>
			return i + 1;
  4109df:	8d 59 01             	lea    ebx,[rcx+0x1]
	thdid_t  tid = cos_thd_id_alloc();
	int      idx = cos_thd_init_alloc(fn, data);
	thdcap_t ret;

	if (idx < 1) return 0;
	ret = __cos_thd_alloc(ci, comp, idx, tid);
  4109e2:	4c 89 ce             	mov    rsi,r9
  4109e5:	4c 89 c1             	mov    rcx,r8
			__thd_init_data[i].data = data;
  4109e8:	4d 89 54 24 08       	mov    QWORD PTR [r12+0x8],r10
  4109ed:	48 b8 a0 05 41 00 00 	movabs rax,0x4105a0
  4109f4:	00 00 00 
  4109f7:	89 da                	mov    edx,ebx
  4109f9:	ff d0                	call   rax
	if (!ret) cos_thd_init_free(idx);
  4109fb:	48 85 c0             	test   rax,rax
  4109fe:	75 18                	jne    410a18 <cos_thd_alloc+0xd8>
 * thread creation failed for some reason.
 */
static void
cos_thd_init_free(thdclosure_index_t idx)
{
	if (idx > COS_THD_INIT_REGION_SIZE || idx <= 0 || !__thd_init_data[idx].fn) return;
  410a00:	48 63 cb             	movsxd rcx,ebx
  410a03:	48 c1 e1 04          	shl    rcx,0x4
  410a07:	49 83 7c 0d 00 00    	cmp    QWORD PTR [r13+rcx*1+0x0],0x0
  410a0d:	74 14                	je     410a23 <cos_thd_alloc+0xe3>
	__thd_init_data[idx].fn   = NULL;
  410a0f:	66 0f ef c0          	pxor   xmm0,xmm0
  410a13:	41 0f 11 04 24       	movups XMMWORD PTR [r12],xmm0

	return ret;
}
  410a18:	48 83 c4 08          	add    rsp,0x8
  410a1c:	5b                   	pop    rbx
  410a1d:	41 5c                	pop    r12
  410a1f:	41 5d                	pop    r13
  410a21:	5d                   	pop    rbp
  410a22:	c3                   	ret    
  410a23:	48 83 c4 08          	add    rsp,0x8
	if (idx < 1) return 0;
  410a27:	31 c0                	xor    eax,eax
}
  410a29:	5b                   	pop    rbx
  410a2a:	41 5c                	pop    r12
  410a2c:	41 5d                	pop    r13
  410a2e:	5d                   	pop    rbp
  410a2f:	c3                   	ret    
  410a30:	48 bf 70 09 42 00 00 	movabs rdi,0x420970
  410a37:	00 00 00 
  410a3a:	be 67 00 00 00       	mov    esi,0x67
  410a3f:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  410a46:	00 00 00 
  410a49:	ff d0                	call   rax
			assert(__thd_init_data[i].fn == fn);
  410a4b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410a52:	00 00 00 00 
  410a56:	0f 0b                	ud2    
	if (idx < 1) return 0;
  410a58:	31 c0                	xor    eax,eax
}
  410a5a:	c3                   	ret    
  410a5b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000410a60 <cos_shared_kernel_page_alloc_at>:

vaddr_t
cos_shared_kernel_page_alloc_at(struct cos_compinfo *ci, vaddr_t mem_ptr)
{
  410a60:	f3 0f 1e fa          	endbr64 
  410a64:	55                   	push   rbp
  410a65:	48 89 e5             	mov    rbp,rsp
  410a68:	41 55                	push   r13
  410a6a:	41 54                	push   r12
  410a6c:	53                   	push   rbx
  410a6d:	48 83 ec 18          	sub    rsp,0x18
	return ci->memsrc;
  410a71:	4c 8b 67 60          	mov    r12,QWORD PTR [rdi+0x60]
	vaddr_t ptemem_cap;
	int ret;

	struct cos_compinfo *meta = __compinfo_metacap(ci);

	assert(meta == __compinfo_metacap(meta));
  410a75:	4d 39 64 24 60       	cmp    QWORD PTR [r12+0x60],r12
  410a7a:	0f 85 b8 00 00 00    	jne    410b38 <cos_shared_kernel_page_alloc_at+0xd8>
	return __mem_bump_alloc(ci, 1, 1);
  410a80:	48 b8 b0 e2 40 00 00 	movabs rax,0x40e2b0
  410a87:	00 00 00 
  410a8a:	48 89 fb             	mov    rbx,rdi
  410a8d:	49 89 f5             	mov    r13,rsi
  410a90:	4c 89 e7             	mov    rdi,r12
  410a93:	ff d0                	call   rax
  410a95:	49 89 c2             	mov    r10,rax

	ptemem_cap = __kmem_bump_alloc(meta);

	assert(ptemem_cap != 0);
  410a98:	48 85 c0             	test   rax,rax
  410a9b:	0f 84 bf 00 00 00    	je     410b60 <cos_shared_kernel_page_alloc_at+0x100>
  410aa1:	48 8b 33             	mov    rsi,QWORD PTR [rbx]
  410aa4:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  410aa8:	ba 0c 00 00 00       	mov    edx,0xc
  410aad:	4c 89 d3             	mov    rbx,r10

	/* Actually map in the memory. */
	ret = call_cap_op(meta->mi.pgtbl_cap, CAPTBL_OP_MEMACTIVATE, ptemem_cap, ci->pgtbl_cap, mem_ptr, PAGE_ORDER);
  410ab0:	49 8b 84 24 98 00 00 	mov    rax,QWORD PTR [r12+0x98]
  410ab7:	00 
  410ab8:	4c 89 ef             	mov    rdi,r13
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  410abb:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  410abe:	05 17 00 01 00       	add    eax,0x10017
	__asm__ __volatile__(
  410ac3:	48 89 29             	mov    QWORD PTR [rcx],rbp
  410ac6:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  410aca:	48 89 cd             	mov    rbp,rcx
  410acd:	49 b8 e8 0a 41 00 00 	movabs r8,0x410ae8
  410ad4:	00 00 00 
  410ad7:	0f 05                	syscall 
  410ad9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  410ae0:	eb 0d                	jmp    410aef <cos_shared_kernel_page_alloc_at+0x8f>
  410ae2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410ae8:	b9 00 00 00 00       	mov    ecx,0x0
  410aed:	eb 05                	jmp    410af4 <cos_shared_kernel_page_alloc_at+0x94>
  410aef:	b9 01 00 00 00       	mov    ecx,0x1
  410af4:	5d                   	pop    rbp
  410af5:	5c                   	pop    rsp
	if (ret) {
  410af6:	85 c0                	test   eax,eax
  410af8:	75 16                	jne    410b10 <cos_shared_kernel_page_alloc_at+0xb0>
		BUG();
	}

	return ptemem_cap;
}
  410afa:	48 83 c4 18          	add    rsp,0x18
  410afe:	4c 89 d0             	mov    rax,r10
  410b01:	5b                   	pop    rbx
  410b02:	41 5c                	pop    r12
  410b04:	41 5d                	pop    r13
  410b06:	5d                   	pop    rbp
  410b07:	c3                   	ret    
  410b08:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  410b0f:	00 
  410b10:	48 bf 38 0a 42 00 00 	movabs rdi,0x420a38
  410b17:	00 00 00 
  410b1a:	be 1c 00 00 00       	mov    esi,0x1c
  410b1f:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  410b26:	00 00 00 
  410b29:	ff d0                	call   rax
		BUG();
  410b2b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410b32:	00 00 00 00 
  410b36:	0f 0b                	ud2    
  410b38:	48 bf d8 09 42 00 00 	movabs rdi,0x4209d8
  410b3f:	00 00 00 
  410b42:	be 2f 00 00 00       	mov    esi,0x2f
  410b47:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  410b4e:	00 00 00 
  410b51:	ff d0                	call   rax
	assert(meta == __compinfo_metacap(meta));
  410b53:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410b5a:	00 00 00 00 
  410b5e:	0f 0b                	ud2    
  410b60:	48 bf 08 0a 42 00 00 	movabs rdi,0x420a08
  410b67:	00 00 00 
  410b6a:	be 2f 00 00 00       	mov    esi,0x2f
  410b6f:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  410b76:	00 00 00 
  410b79:	ff d0                	call   rax
	assert(ptemem_cap != 0);
  410b7b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410b82:	00 00 00 00 
  410b86:	0f 0b                	ud2    
  410b88:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  410b8f:	00 

0000000000410b90 <cos_shared_kernel_page_alloc>:

vaddr_t
cos_shared_kernel_page_alloc(struct cos_compinfo *ci, vaddr_t *resource)
{
  410b90:	f3 0f 1e fa          	endbr64 
  410b94:	55                   	push   rbp
  410b95:	48 89 e5             	mov    rbp,rsp
  410b98:	41 56                	push   r14
  410b9a:	41 55                	push   r13
  410b9c:	41 54                	push   r12
  410b9e:	53                   	push   rbx
  410b9f:	48 83 ec 10          	sub    rsp,0x10
	return ci->memsrc;
  410ba3:	4c 8b 77 60          	mov    r14,QWORD PTR [rdi+0x60]
	int ret;
	vaddr_t heap_vaddr = 0;
	vaddr_t kmem = 0;
	struct cos_compinfo *meta = __compinfo_metacap(ci);

	assert(meta == __compinfo_metacap(meta));
  410ba7:	4d 39 76 60          	cmp    QWORD PTR [r14+0x60],r14
  410bab:	0f 85 d7 00 00 00    	jne    410c88 <cos_shared_kernel_page_alloc+0xf8>
	return __mem_bump_alloc(ci, 1, 1);
  410bb1:	48 b8 b0 e2 40 00 00 	movabs rax,0x40e2b0
  410bb8:	00 00 00 
  410bbb:	49 89 fc             	mov    r12,rdi
  410bbe:	49 89 f5             	mov    r13,rsi
  410bc1:	ff d0                	call   rax
  410bc3:	48 89 c3             	mov    rbx,rax

	kmem = __kmem_bump_alloc(ci);
	assert(kmem);
  410bc6:	48 85 c0             	test   rax,rax
  410bc9:	0f 84 e1 00 00 00    	je     410cb0 <cos_shared_kernel_page_alloc+0x120>

	heap_vaddr = __page_bump_valloc(ci, PAGE_SIZE, PAGE_SIZE);
  410bcf:	4c 89 e7             	mov    rdi,r12
  410bd2:	ba 00 10 00 00       	mov    edx,0x1000
  410bd7:	be 00 10 00 00       	mov    esi,0x1000
  410bdc:	48 b8 40 ea 40 00 00 	movabs rax,0x40ea40
  410be3:	00 00 00 
  410be6:	ff d0                	call   rax
  410be8:	48 89 c7             	mov    rdi,rax
	assert(heap_vaddr);
  410beb:	48 85 c0             	test   rax,rax
  410bee:	0f 84 e4 00 00 00    	je     410cd8 <cos_shared_kernel_page_alloc+0x148>

	ret = call_cap_op(meta->mi.pgtbl_cap, CAPTBL_OP_MEMACTIVATE, kmem, ci->pgtbl_cap, heap_vaddr, PAGE_ORDER);
  410bf4:	49 8b 86 98 00 00 00 	mov    rax,QWORD PTR [r14+0x98]
  410bfb:	49 8b 34 24          	mov    rsi,QWORD PTR [r12]
  410bff:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  410c03:	ba 0c 00 00 00       	mov    edx,0xc
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  410c08:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  410c0b:	05 17 00 01 00       	add    eax,0x10017
	__asm__ __volatile__(
  410c10:	48 89 29             	mov    QWORD PTR [rcx],rbp
  410c13:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  410c17:	48 89 cd             	mov    rbp,rcx
  410c1a:	49 b8 30 0c 41 00 00 	movabs r8,0x410c30
  410c21:	00 00 00 
  410c24:	0f 05                	syscall 
  410c26:	66 90                	xchg   ax,ax
  410c28:	eb 0d                	jmp    410c37 <cos_shared_kernel_page_alloc+0xa7>
  410c2a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410c30:	b9 00 00 00 00       	mov    ecx,0x0
  410c35:	eb 05                	jmp    410c3c <cos_shared_kernel_page_alloc+0xac>
  410c37:	b9 01 00 00 00       	mov    ecx,0x1
  410c3c:	5d                   	pop    rbp
  410c3d:	5c                   	pop    rsp
	if (ret) {
  410c3e:	85 c0                	test   eax,eax
  410c40:	75 1e                	jne    410c60 <cos_shared_kernel_page_alloc+0xd0>
		BUG();
	}

	*resource = kmem;
  410c42:	49 89 5d 00          	mov    QWORD PTR [r13+0x0],rbx

	return heap_vaddr;
}
  410c46:	48 83 c4 10          	add    rsp,0x10
  410c4a:	48 89 f8             	mov    rax,rdi
  410c4d:	5b                   	pop    rbx
  410c4e:	41 5c                	pop    r12
  410c50:	41 5d                	pop    r13
  410c52:	41 5e                	pop    r14
  410c54:	5d                   	pop    rbp
  410c55:	c3                   	ret    
  410c56:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  410c5d:	00 00 00 
  410c60:	48 bf e8 0a 42 00 00 	movabs rdi,0x420ae8
  410c67:	00 00 00 
  410c6a:	be 1c 00 00 00       	mov    esi,0x1c
  410c6f:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  410c76:	00 00 00 
  410c79:	ff d0                	call   rax
		BUG();
  410c7b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410c82:	00 00 00 00 
  410c86:	0f 0b                	ud2    
  410c88:	48 bf 58 0a 42 00 00 	movabs rdi,0x420a58
  410c8f:	00 00 00 
  410c92:	be 2f 00 00 00       	mov    esi,0x2f
  410c97:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  410c9e:	00 00 00 
  410ca1:	ff d0                	call   rax
	assert(meta == __compinfo_metacap(meta));
  410ca3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410caa:	00 00 00 00 
  410cae:	0f 0b                	ud2    
  410cb0:	48 bf 88 0a 42 00 00 	movabs rdi,0x420a88
  410cb7:	00 00 00 
  410cba:	be 2f 00 00 00       	mov    esi,0x2f
  410cbf:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  410cc6:	00 00 00 
  410cc9:	ff d0                	call   rax
	assert(kmem);
  410ccb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410cd2:	00 00 00 00 
  410cd6:	0f 0b                	ud2    
  410cd8:	48 bf b8 0a 42 00 00 	movabs rdi,0x420ab8
  410cdf:	00 00 00 
  410ce2:	be 2f 00 00 00       	mov    esi,0x2f
  410ce7:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  410cee:	00 00 00 
  410cf1:	ff d0                	call   rax
	assert(heap_vaddr);
  410cf3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410cfa:	00 00 00 00 
  410cfe:	0f 0b                	ud2    

0000000000410d00 <cos_vm_kernel_page_create>:

vaddr_t
cos_vm_kernel_page_create(struct cos_compinfo *ci)
{
  410d00:	f3 0f 1e fa          	endbr64 
  410d04:	55                   	push   rbp
  410d05:	48 89 e5             	mov    rbp,rsp
  410d08:	41 55                	push   r13
  410d0a:	41 54                	push   r12
  410d0c:	53                   	push   rbx
  410d0d:	48 83 ec 18          	sub    rsp,0x18
	assert(__ci);
  410d11:	48 85 ff             	test   rdi,rdi
  410d14:	0f 84 77 01 00 00    	je     410e91 <cos_vm_kernel_page_create+0x191>
	return ci->memsrc;
  410d1a:	4c 8b 57 60          	mov    r10,QWORD PTR [rdi+0x60]
        __asm__ __volatile__("lock " PS_CAS_STR
  410d1e:	be 01 00 00 00       	mov    esi,0x1
  410d23:	31 c9                	xor    ecx,ecx
{ while (!ps_cas(&l->o, 0, 1)) ; }
  410d25:	49 8d 92 b8 00 00 00 	lea    rdx,[r10+0xb8]
	assert(ci && ci == __compinfo_metacap(__ci));
  410d2c:	4d 85 d2             	test   r10,r10
  410d2f:	0f 84 84 01 00 00    	je     410eb9 <cos_vm_kernel_page_create+0x1b9>
  410d35:	0f 1f 00             	nop    DWORD PTR [rax]
        __asm__ __volatile__("lock " PS_CAS_STR
  410d38:	48 89 c8             	mov    rax,rcx
  410d3b:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  410d40:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  410d43:	84 c0                	test   al,al
  410d45:	74 f1                	je     410d38 <cos_vm_kernel_page_create+0x38>
        __asm__ __volatile__("lock " PS_FAA_STR
  410d47:	41 bd 00 10 00 00    	mov    r13d,0x1000
  410d4d:	f0 4d 0f c1 6a 78    	lock xadd QWORD PTR [r10+0x78],r13
	if (ret >= *frontier || *frontier - ret > RETYPE_MEM_SIZE) {
  410d53:	49 8b 92 90 00 00 00 	mov    rdx,QWORD PTR [r10+0x90]
  410d5a:	49 39 d5             	cmp    r13,rdx
  410d5d:	0f 82 bd 00 00 00    	jb     410e20 <cos_vm_kernel_page_create+0x120>
		vaddr_t ptr_tmp = *ptr, front_tmp = *frontier;
  410d63:	49 8b 42 78          	mov    rax,QWORD PTR [r10+0x78]
		if (ci->mi.untyped_ptr == ci->mi.untyped_frontier) goto error;
  410d67:	49 8b 9a 80 00 00 00 	mov    rbx,QWORD PTR [r10+0x80]
  410d6e:	49 39 5a 68          	cmp    QWORD PTR [r10+0x68],rbx
  410d72:	0f 84 c8 00 00 00    	je     410e40 <cos_vm_kernel_page_create+0x140>
  410d78:	41 bd 00 10 00 00    	mov    r13d,0x1000
  410d7e:	f0 4d 0f c1 6a 68    	lock xadd QWORD PTR [r10+0x68],r13
		if (ps_cas(ptr, ptr_tmp, ret + PAGE_SIZE)) {
  410d84:	49 8d 8d 00 10 00 00 	lea    rcx,[r13+0x1000]
        __asm__ __volatile__("lock " PS_CAS_STR
  410d8b:	f0 49 0f b1 4a 78    	lock cmpxchg QWORD PTR [r10+0x78],rcx
  410d91:	0f 94 c0             	sete   al
  410d94:	84 c0                	test   al,al
  410d96:	74 0f                	je     410da7 <cos_vm_kernel_page_create+0xa7>
  410d98:	48 89 d0             	mov    rax,rdx
  410d9b:	f0 49 0f b1 8a 90 00 	lock cmpxchg QWORD PTR [r10+0x90],rcx
  410da2:	00 00 
  410da4:	0f 94 c0             	sete   al
	if (retype && (ret % RETYPE_MEM_SIZE == 0)) {
  410da7:	4c 89 ea             	mov    rdx,r13
  410daa:	81 e2 ff 0f 00 00    	and    edx,0xfff
  410db0:	0f 85 c2 00 00 00    	jne    410e78 <cos_vm_kernel_page_create+0x178>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  410db6:	41 8b 82 98 00 00 00 	mov    eax,DWORD PTR [r10+0x98]
	__asm__ __volatile__(
  410dbd:	4c 89 eb             	mov    rbx,r13
  410dc0:	48 89 d6             	mov    rsi,rdx
  410dc3:	48 89 d7             	mov    rdi,rdx
  410dc6:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  410dca:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  410dcd:	05 1a 00 01 00       	add    eax,0x1001a
	__asm__ __volatile__(
  410dd2:	48 89 29             	mov    QWORD PTR [rcx],rbp
  410dd5:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  410dd9:	48 89 cd             	mov    rbp,rcx
  410ddc:	49 b8 f0 0d 41 00 00 	movabs r8,0x410df0
  410de3:	00 00 00 
  410de6:	0f 05                	syscall 
  410de8:	eb 0d                	jmp    410df7 <cos_vm_kernel_page_create+0xf7>
  410dea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410df0:	b9 00 00 00 00       	mov    ecx,0x0
  410df5:	eb 05                	jmp    410dfc <cos_vm_kernel_page_create+0xfc>
  410df7:	b9 01 00 00 00       	mov    ecx,0x1
  410dfc:	5d                   	pop    rbp
  410dfd:	5c                   	pop    rsp
		if (call_cap_op(ci->mi.pgtbl_cap, op, ret, 0, 0, 0)) goto error;
  410dfe:	85 c0                	test   eax,eax
  410e00:	75 3e                	jne    410e40 <cos_vm_kernel_page_create+0x140>
{ l->o = 0; }
  410e02:	49 c7 82 b8 00 00 00 	mov    QWORD PTR [r10+0xb8],0x0
  410e09:	00 00 00 00 
	vaddr_t kmem = 0;

	kmem = __kmem_bump_alloc(ci);
	assert(kmem);
  410e0d:	4d 85 ed             	test   r13,r13
  410e10:	74 39                	je     410e4b <cos_vm_kernel_page_create+0x14b>

	return kmem;
}
  410e12:	48 83 c4 18          	add    rsp,0x18
  410e16:	4c 89 e8             	mov    rax,r13
  410e19:	5b                   	pop    rbx
  410e1a:	41 5c                	pop    r12
  410e1c:	41 5d                	pop    r13
  410e1e:	5d                   	pop    rbp
  410e1f:	c3                   	ret    
	if (ret >= *frontier || *frontier - ret > RETYPE_MEM_SIZE) {
  410e20:	48 89 d0             	mov    rax,rdx
  410e23:	4c 29 e8             	sub    rax,r13
  410e26:	48 3d 00 10 00 00    	cmp    rax,0x1000
  410e2c:	0f 86 75 ff ff ff    	jbe    410da7 <cos_vm_kernel_page_create+0xa7>
  410e32:	e9 2c ff ff ff       	jmp    410d63 <cos_vm_kernel_page_create+0x63>
  410e37:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  410e3e:	00 00 
  410e40:	49 c7 82 b8 00 00 00 	mov    QWORD PTR [r10+0xb8],0x0
  410e47:	00 00 00 00 
  410e4b:	48 bf 08 0b 42 00 00 	movabs rdi,0x420b08
  410e52:	00 00 00 
  410e55:	be 2f 00 00 00       	mov    esi,0x2f
  410e5a:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  410e61:	00 00 00 
  410e64:	ff d0                	call   rax
	assert(kmem);
  410e66:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410e6d:	00 00 00 00 
  410e71:	0f 0b                	ud2    
  410e73:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  410e78:	49 c7 82 b8 00 00 00 	mov    QWORD PTR [r10+0xb8],0x0
  410e7f:	00 00 00 00 
}
  410e83:	48 83 c4 18          	add    rsp,0x18
  410e87:	4c 89 e8             	mov    rax,r13
  410e8a:	5b                   	pop    rbx
  410e8b:	41 5c                	pop    r12
  410e8d:	41 5d                	pop    r13
  410e8f:	5d                   	pop    rbp
  410e90:	c3                   	ret    
  410e91:	48 bf 90 01 42 00 00 	movabs rdi,0x420190
  410e98:	00 00 00 
  410e9b:	be 2e 00 00 00       	mov    esi,0x2e
  410ea0:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  410ea7:	00 00 00 
  410eaa:	ff d0                	call   rax
	assert(__ci);
  410eac:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410eb3:	00 00 00 00 
  410eb7:	0f 0b                	ud2    
  410eb9:	48 bf c0 01 42 00 00 	movabs rdi,0x4201c0
  410ec0:	00 00 00 
  410ec3:	be 2e 00 00 00       	mov    esi,0x2e
  410ec8:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  410ecf:	00 00 00 
  410ed2:	ff d0                	call   rax
	assert(ci && ci == __compinfo_metacap(__ci));
  410ed4:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410edb:	00 00 00 00 
  410edf:	0f 0b                	ud2    
  410ee1:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  410ee8:	00 00 00 00 
  410eec:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000410ef0 <cos_vm_vmcs_alloc>:

capid_t
cos_vm_vmcs_alloc(struct cos_compinfo *ci, vaddr_t kmem)
{
  410ef0:	f3 0f 1e fa          	endbr64 
  410ef4:	55                   	push   rbp
        __asm__ __volatile__("lock " PS_CAS_STR
  410ef5:	31 c9                	xor    ecx,ecx
  410ef7:	48 89 e5             	mov    rbp,rsp
  410efa:	41 55                	push   r13
  410efc:	49 89 fd             	mov    r13,rdi
  410eff:	41 54                	push   r12
  410f01:	53                   	push   rbx
  410f02:	48 89 f3             	mov    rbx,rsi
  410f05:	be 01 00 00 00       	mov    esi,0x1
  410f0a:	48 83 ec 18          	sub    rsp,0x18
	return ci->memsrc;
  410f0e:	4c 8b 67 60          	mov    r12,QWORD PTR [rdi+0x60]
{ while (!ps_cas(&l->o, 0, 1)) ; }
  410f12:	49 8d 94 24 b0 00 00 	lea    rdx,[r12+0xb0]
  410f19:	00 
  410f1a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  410f20:	48 89 c8             	mov    rax,rcx
  410f23:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  410f28:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  410f2b:	84 c0                	test   al,al
  410f2d:	74 f1                	je     410f20 <cos_vm_vmcs_alloc+0x30>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  410f2f:	41 f6 44 24 38 03    	test   BYTE PTR [r12+0x38],0x3
  410f35:	0f 84 ad 00 00 00    	je     410fe8 <cos_vm_vmcs_alloc+0xf8>
        __asm__ __volatile__("lock " PS_FAA_STR
  410f3b:	bf 04 00 00 00       	mov    edi,0x4
  410f40:	f0 49 0f c1 7c 24 38 	lock xadd QWORD PTR [r12+0x38],rdi
{ l->o = 0; }
  410f47:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  410f4e:	00 00 00 00 00 
	capid_t cap = 0;

	cap = __capid_bump_alloc(__compinfo_metacap(ci), CAP_VM_VMCS);

	if (cap == 0 || kmem == 0) {
  410f53:	48 85 ff             	test   rdi,rdi
  410f56:	0f 84 ab 00 00 00    	je     411007 <cos_vm_vmcs_alloc+0x117>
  410f5c:	48 85 db             	test   rbx,rbx
  410f5f:	0f 84 a2 00 00 00    	je     411007 <cos_vm_vmcs_alloc+0x117>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  410f65:	41 8b 45 08          	mov    eax,DWORD PTR [r13+0x8]
		assert(0);
	}

	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_VMCS_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  410f69:	49 8b 55 60          	mov    rdx,QWORD PTR [r13+0x60]
	__asm__ __volatile__(
  410f6d:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  410f71:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  410f74:	48 8b b2 98 00 00 00 	mov    rsi,QWORD PTR [rdx+0x98]
  410f7b:	31 d2                	xor    edx,edx
	cap_no += op;
  410f7d:	05 07 00 01 00       	add    eax,0x10007
	__asm__ __volatile__(
  410f82:	48 89 29             	mov    QWORD PTR [rcx],rbp
  410f85:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  410f89:	48 89 cd             	mov    rbp,rcx
  410f8c:	49 b8 a0 0f 41 00 00 	movabs r8,0x410fa0
  410f93:	00 00 00 
  410f96:	0f 05                	syscall 
  410f98:	eb 0d                	jmp    410fa7 <cos_vm_vmcs_alloc+0xb7>
  410f9a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410fa0:	b9 00 00 00 00       	mov    ecx,0x0
  410fa5:	eb 05                	jmp    410fac <cos_vm_vmcs_alloc+0xbc>
  410fa7:	b9 01 00 00 00       	mov    ecx,0x1
  410fac:	5d                   	pop    rbp
  410fad:	5c                   	pop    rsp
  410fae:	85 c0                	test   eax,eax
  410fb0:	75 0e                	jne    410fc0 <cos_vm_vmcs_alloc+0xd0>

	return cap;
}
  410fb2:	48 83 c4 18          	add    rsp,0x18
  410fb6:	48 89 f8             	mov    rax,rdi
  410fb9:	5b                   	pop    rbx
  410fba:	41 5c                	pop    r12
  410fbc:	41 5d                	pop    r13
  410fbe:	5d                   	pop    rbp
  410fbf:	c3                   	ret    
  410fc0:	48 bf 68 0b 42 00 00 	movabs rdi,0x420b68
  410fc7:	00 00 00 
  410fca:	be 1c 00 00 00       	mov    esi,0x1c
  410fcf:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  410fd6:	00 00 00 
  410fd9:	ff d0                	call   rax
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_VMCS_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  410fdb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410fe2:	00 00 00 00 
  410fe6:	0f 0b                	ud2    
		if (__capid_captbl_check_expand(ci)) goto error;
  410fe8:	48 b8 50 e4 40 00 00 	movabs rax,0x40e450
  410fef:	00 00 00 
  410ff2:	4c 89 e7             	mov    rdi,r12
  410ff5:	ff d0                	call   rax
  410ff7:	85 c0                	test   eax,eax
  410ff9:	74 34                	je     41102f <cos_vm_vmcs_alloc+0x13f>
  410ffb:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  411002:	00 00 00 00 00 
  411007:	48 bf 38 0b 42 00 00 	movabs rdi,0x420b38
  41100e:	00 00 00 
  411011:	be 2f 00 00 00       	mov    esi,0x2f
  411016:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  41101d:	00 00 00 
  411020:	ff d0                	call   rax
		assert(0);
  411022:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411029:	00 00 00 00 
  41102d:	0f 0b                	ud2    
        __asm__ __volatile__("lock " PS_FAA_STR
  41102f:	b8 04 00 00 00       	mov    eax,0x4
  411034:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  41103b:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  411040:	e9 f6 fe ff ff       	jmp    410f3b <cos_vm_vmcs_alloc+0x4b>
  411045:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41104c:	00 00 00 00 

0000000000411050 <cos_vm_msr_bitmap_alloc>:

capid_t
cos_vm_msr_bitmap_alloc(struct cos_compinfo *ci, vaddr_t kmem)
{
  411050:	f3 0f 1e fa          	endbr64 
  411054:	55                   	push   rbp
        __asm__ __volatile__("lock " PS_CAS_STR
  411055:	31 c9                	xor    ecx,ecx
  411057:	48 89 e5             	mov    rbp,rsp
  41105a:	41 55                	push   r13
  41105c:	49 89 fd             	mov    r13,rdi
  41105f:	41 54                	push   r12
  411061:	53                   	push   rbx
  411062:	48 89 f3             	mov    rbx,rsi
  411065:	be 01 00 00 00       	mov    esi,0x1
  41106a:	48 83 ec 18          	sub    rsp,0x18
	return ci->memsrc;
  41106e:	4c 8b 67 60          	mov    r12,QWORD PTR [rdi+0x60]
{ while (!ps_cas(&l->o, 0, 1)) ; }
  411072:	49 8d 94 24 b0 00 00 	lea    rdx,[r12+0xb0]
  411079:	00 
  41107a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  411080:	48 89 c8             	mov    rax,rcx
  411083:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  411088:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  41108b:	84 c0                	test   al,al
  41108d:	74 f1                	je     411080 <cos_vm_msr_bitmap_alloc+0x30>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  41108f:	41 f6 44 24 38 03    	test   BYTE PTR [r12+0x38],0x3
  411095:	0f 84 ad 00 00 00    	je     411148 <cos_vm_msr_bitmap_alloc+0xf8>
        __asm__ __volatile__("lock " PS_FAA_STR
  41109b:	bf 04 00 00 00       	mov    edi,0x4
  4110a0:	f0 49 0f c1 7c 24 38 	lock xadd QWORD PTR [r12+0x38],rdi
{ l->o = 0; }
  4110a7:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  4110ae:	00 00 00 00 00 
	capid_t cap = 0;

	cap = __capid_bump_alloc(__compinfo_metacap(ci), CAP_VM_MSR_BITMAP);

	if (cap == 0 || kmem == 0) {
  4110b3:	48 85 ff             	test   rdi,rdi
  4110b6:	0f 84 ab 00 00 00    	je     411167 <cos_vm_msr_bitmap_alloc+0x117>
  4110bc:	48 85 db             	test   rbx,rbx
  4110bf:	0f 84 a2 00 00 00    	je     411167 <cos_vm_msr_bitmap_alloc+0x117>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4110c5:	41 8b 45 08          	mov    eax,DWORD PTR [r13+0x8]
		assert(0);
	}

	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_MSR_BITMAP_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  4110c9:	49 8b 55 60          	mov    rdx,QWORD PTR [r13+0x60]
	__asm__ __volatile__(
  4110cd:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4110d1:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  4110d4:	48 8b b2 98 00 00 00 	mov    rsi,QWORD PTR [rdx+0x98]
  4110db:	31 d2                	xor    edx,edx
	cap_no += op;
  4110dd:	05 08 00 01 00       	add    eax,0x10008
	__asm__ __volatile__(
  4110e2:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4110e5:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4110e9:	48 89 cd             	mov    rbp,rcx
  4110ec:	49 b8 00 11 41 00 00 	movabs r8,0x411100
  4110f3:	00 00 00 
  4110f6:	0f 05                	syscall 
  4110f8:	eb 0d                	jmp    411107 <cos_vm_msr_bitmap_alloc+0xb7>
  4110fa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411100:	b9 00 00 00 00       	mov    ecx,0x0
  411105:	eb 05                	jmp    41110c <cos_vm_msr_bitmap_alloc+0xbc>
  411107:	b9 01 00 00 00       	mov    ecx,0x1
  41110c:	5d                   	pop    rbp
  41110d:	5c                   	pop    rsp
  41110e:	85 c0                	test   eax,eax
  411110:	75 0e                	jne    411120 <cos_vm_msr_bitmap_alloc+0xd0>

	return cap;
}
  411112:	48 83 c4 18          	add    rsp,0x18
  411116:	48 89 f8             	mov    rax,rdi
  411119:	5b                   	pop    rbx
  41111a:	41 5c                	pop    r12
  41111c:	41 5d                	pop    r13
  41111e:	5d                   	pop    rbp
  41111f:	c3                   	ret    
  411120:	48 bf b8 0b 42 00 00 	movabs rdi,0x420bb8
  411127:	00 00 00 
  41112a:	be 1c 00 00 00       	mov    esi,0x1c
  41112f:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  411136:	00 00 00 
  411139:	ff d0                	call   rax
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_MSR_BITMAP_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  41113b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411142:	00 00 00 00 
  411146:	0f 0b                	ud2    
		if (__capid_captbl_check_expand(ci)) goto error;
  411148:	48 b8 50 e4 40 00 00 	movabs rax,0x40e450
  41114f:	00 00 00 
  411152:	4c 89 e7             	mov    rdi,r12
  411155:	ff d0                	call   rax
  411157:	85 c0                	test   eax,eax
  411159:	74 34                	je     41118f <cos_vm_msr_bitmap_alloc+0x13f>
  41115b:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  411162:	00 00 00 00 00 
  411167:	48 bf 88 0b 42 00 00 	movabs rdi,0x420b88
  41116e:	00 00 00 
  411171:	be 2f 00 00 00       	mov    esi,0x2f
  411176:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  41117d:	00 00 00 
  411180:	ff d0                	call   rax
		assert(0);
  411182:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411189:	00 00 00 00 
  41118d:	0f 0b                	ud2    
        __asm__ __volatile__("lock " PS_FAA_STR
  41118f:	b8 04 00 00 00       	mov    eax,0x4
  411194:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  41119b:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  4111a0:	e9 f6 fe ff ff       	jmp    41109b <cos_vm_msr_bitmap_alloc+0x4b>
  4111a5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4111ac:	00 00 00 00 

00000000004111b0 <cos_vm_lapic_alloc>:

capid_t
cos_vm_lapic_alloc(struct cos_compinfo *ci, vaddr_t kmem)
{
  4111b0:	f3 0f 1e fa          	endbr64 
  4111b4:	55                   	push   rbp
        __asm__ __volatile__("lock " PS_CAS_STR
  4111b5:	31 c9                	xor    ecx,ecx
  4111b7:	48 89 e5             	mov    rbp,rsp
  4111ba:	41 55                	push   r13
  4111bc:	49 89 fd             	mov    r13,rdi
  4111bf:	41 54                	push   r12
  4111c1:	53                   	push   rbx
  4111c2:	48 89 f3             	mov    rbx,rsi
  4111c5:	be 01 00 00 00       	mov    esi,0x1
  4111ca:	48 83 ec 18          	sub    rsp,0x18
	return ci->memsrc;
  4111ce:	4c 8b 67 60          	mov    r12,QWORD PTR [rdi+0x60]
{ while (!ps_cas(&l->o, 0, 1)) ; }
  4111d2:	49 8d 94 24 b0 00 00 	lea    rdx,[r12+0xb0]
  4111d9:	00 
  4111da:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  4111e0:	48 89 c8             	mov    rax,rcx
  4111e3:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  4111e8:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  4111eb:	84 c0                	test   al,al
  4111ed:	74 f1                	je     4111e0 <cos_vm_lapic_alloc+0x30>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  4111ef:	41 f6 44 24 38 03    	test   BYTE PTR [r12+0x38],0x3
  4111f5:	0f 84 ad 00 00 00    	je     4112a8 <cos_vm_lapic_alloc+0xf8>
        __asm__ __volatile__("lock " PS_FAA_STR
  4111fb:	bf 04 00 00 00       	mov    edi,0x4
  411200:	f0 49 0f c1 7c 24 38 	lock xadd QWORD PTR [r12+0x38],rdi
{ l->o = 0; }
  411207:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  41120e:	00 00 00 00 00 
	capid_t cap = 0;

	cap = __capid_bump_alloc(__compinfo_metacap(ci), CAP_VM_LAPIC);
	if (cap == 0 || kmem == 0) {
  411213:	48 85 ff             	test   rdi,rdi
  411216:	0f 84 ab 00 00 00    	je     4112c7 <cos_vm_lapic_alloc+0x117>
  41121c:	48 85 db             	test   rbx,rbx
  41121f:	0f 84 a2 00 00 00    	je     4112c7 <cos_vm_lapic_alloc+0x117>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411225:	41 8b 45 08          	mov    eax,DWORD PTR [r13+0x8]
		assert(0);
	}

	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_LAPIC_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  411229:	49 8b 55 60          	mov    rdx,QWORD PTR [r13+0x60]
	__asm__ __volatile__(
  41122d:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411231:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  411234:	48 8b b2 98 00 00 00 	mov    rsi,QWORD PTR [rdx+0x98]
  41123b:	31 d2                	xor    edx,edx
	cap_no += op;
  41123d:	05 0a 00 01 00       	add    eax,0x1000a
	__asm__ __volatile__(
  411242:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411245:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411249:	48 89 cd             	mov    rbp,rcx
  41124c:	49 b8 60 12 41 00 00 	movabs r8,0x411260
  411253:	00 00 00 
  411256:	0f 05                	syscall 
  411258:	eb 0d                	jmp    411267 <cos_vm_lapic_alloc+0xb7>
  41125a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411260:	b9 00 00 00 00       	mov    ecx,0x0
  411265:	eb 05                	jmp    41126c <cos_vm_lapic_alloc+0xbc>
  411267:	b9 01 00 00 00       	mov    ecx,0x1
  41126c:	5d                   	pop    rbp
  41126d:	5c                   	pop    rsp
  41126e:	85 c0                	test   eax,eax
  411270:	75 0e                	jne    411280 <cos_vm_lapic_alloc+0xd0>

	return cap;

}
  411272:	48 83 c4 18          	add    rsp,0x18
  411276:	48 89 f8             	mov    rax,rdi
  411279:	5b                   	pop    rbx
  41127a:	41 5c                	pop    r12
  41127c:	41 5d                	pop    r13
  41127e:	5d                   	pop    rbp
  41127f:	c3                   	ret    
  411280:	48 bf 08 0c 42 00 00 	movabs rdi,0x420c08
  411287:	00 00 00 
  41128a:	be 1c 00 00 00       	mov    esi,0x1c
  41128f:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  411296:	00 00 00 
  411299:	ff d0                	call   rax
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_LAPIC_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  41129b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4112a2:	00 00 00 00 
  4112a6:	0f 0b                	ud2    
		if (__capid_captbl_check_expand(ci)) goto error;
  4112a8:	48 b8 50 e4 40 00 00 	movabs rax,0x40e450
  4112af:	00 00 00 
  4112b2:	4c 89 e7             	mov    rdi,r12
  4112b5:	ff d0                	call   rax
  4112b7:	85 c0                	test   eax,eax
  4112b9:	74 34                	je     4112ef <cos_vm_lapic_alloc+0x13f>
  4112bb:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  4112c2:	00 00 00 00 00 
  4112c7:	48 bf d8 0b 42 00 00 	movabs rdi,0x420bd8
  4112ce:	00 00 00 
  4112d1:	be 2f 00 00 00       	mov    esi,0x2f
  4112d6:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4112dd:	00 00 00 
  4112e0:	ff d0                	call   rax
		assert(0);
  4112e2:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4112e9:	00 00 00 00 
  4112ed:	0f 0b                	ud2    
        __asm__ __volatile__("lock " PS_FAA_STR
  4112ef:	b8 04 00 00 00       	mov    eax,0x4
  4112f4:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  4112fb:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  411300:	e9 f6 fe ff ff       	jmp    4111fb <cos_vm_lapic_alloc+0x4b>
  411305:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41130c:	00 00 00 00 

0000000000411310 <cos_vm_shared_region_alloc>:

capid_t
cos_vm_shared_region_alloc(struct cos_compinfo *ci, vaddr_t kmem)
{
  411310:	f3 0f 1e fa          	endbr64 
  411314:	55                   	push   rbp
        __asm__ __volatile__("lock " PS_CAS_STR
  411315:	31 c9                	xor    ecx,ecx
  411317:	48 89 e5             	mov    rbp,rsp
  41131a:	41 55                	push   r13
  41131c:	49 89 fd             	mov    r13,rdi
  41131f:	41 54                	push   r12
  411321:	53                   	push   rbx
  411322:	48 89 f3             	mov    rbx,rsi
  411325:	be 01 00 00 00       	mov    esi,0x1
  41132a:	48 83 ec 18          	sub    rsp,0x18
	return ci->memsrc;
  41132e:	4c 8b 67 60          	mov    r12,QWORD PTR [rdi+0x60]
{ while (!ps_cas(&l->o, 0, 1)) ; }
  411332:	49 8d 94 24 b0 00 00 	lea    rdx,[r12+0xb0]
  411339:	00 
  41133a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  411340:	48 89 c8             	mov    rax,rcx
  411343:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  411348:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  41134b:	84 c0                	test   al,al
  41134d:	74 f1                	je     411340 <cos_vm_shared_region_alloc+0x30>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  41134f:	41 f6 44 24 38 03    	test   BYTE PTR [r12+0x38],0x3
  411355:	0f 84 ad 00 00 00    	je     411408 <cos_vm_shared_region_alloc+0xf8>
        __asm__ __volatile__("lock " PS_FAA_STR
  41135b:	bf 04 00 00 00       	mov    edi,0x4
  411360:	f0 49 0f c1 7c 24 38 	lock xadd QWORD PTR [r12+0x38],rdi
{ l->o = 0; }
  411367:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  41136e:	00 00 00 00 00 
	capid_t cap = 0;

	cap = __capid_bump_alloc(__compinfo_metacap(ci), CAP_VM_SHARED_MEM);
	if (cap == 0 || kmem == 0) {
  411373:	48 85 ff             	test   rdi,rdi
  411376:	0f 84 ab 00 00 00    	je     411427 <cos_vm_shared_region_alloc+0x117>
  41137c:	48 85 db             	test   rbx,rbx
  41137f:	0f 84 a2 00 00 00    	je     411427 <cos_vm_shared_region_alloc+0x117>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411385:	41 8b 45 08          	mov    eax,DWORD PTR [r13+0x8]
		assert(0);
	}

	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_SHARED_MEM_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  411389:	49 8b 55 60          	mov    rdx,QWORD PTR [r13+0x60]
	__asm__ __volatile__(
  41138d:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411391:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  411394:	48 8b b2 98 00 00 00 	mov    rsi,QWORD PTR [rdx+0x98]
  41139b:	31 d2                	xor    edx,edx
	cap_no += op;
  41139d:	05 0b 00 01 00       	add    eax,0x1000b
	__asm__ __volatile__(
  4113a2:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4113a5:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4113a9:	48 89 cd             	mov    rbp,rcx
  4113ac:	49 b8 c0 13 41 00 00 	movabs r8,0x4113c0
  4113b3:	00 00 00 
  4113b6:	0f 05                	syscall 
  4113b8:	eb 0d                	jmp    4113c7 <cos_vm_shared_region_alloc+0xb7>
  4113ba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4113c0:	b9 00 00 00 00       	mov    ecx,0x0
  4113c5:	eb 05                	jmp    4113cc <cos_vm_shared_region_alloc+0xbc>
  4113c7:	b9 01 00 00 00       	mov    ecx,0x1
  4113cc:	5d                   	pop    rbp
  4113cd:	5c                   	pop    rsp
  4113ce:	85 c0                	test   eax,eax
  4113d0:	75 0e                	jne    4113e0 <cos_vm_shared_region_alloc+0xd0>

	return cap;

}
  4113d2:	48 83 c4 18          	add    rsp,0x18
  4113d6:	48 89 f8             	mov    rax,rdi
  4113d9:	5b                   	pop    rbx
  4113da:	41 5c                	pop    r12
  4113dc:	41 5d                	pop    r13
  4113de:	5d                   	pop    rbp
  4113df:	c3                   	ret    
  4113e0:	48 bf 58 0c 42 00 00 	movabs rdi,0x420c58
  4113e7:	00 00 00 
  4113ea:	be 1c 00 00 00       	mov    esi,0x1c
  4113ef:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4113f6:	00 00 00 
  4113f9:	ff d0                	call   rax
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_SHARED_MEM_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  4113fb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411402:	00 00 00 00 
  411406:	0f 0b                	ud2    
		if (__capid_captbl_check_expand(ci)) goto error;
  411408:	48 b8 50 e4 40 00 00 	movabs rax,0x40e450
  41140f:	00 00 00 
  411412:	4c 89 e7             	mov    rdi,r12
  411415:	ff d0                	call   rax
  411417:	85 c0                	test   eax,eax
  411419:	74 34                	je     41144f <cos_vm_shared_region_alloc+0x13f>
  41141b:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  411422:	00 00 00 00 00 
  411427:	48 bf 28 0c 42 00 00 	movabs rdi,0x420c28
  41142e:	00 00 00 
  411431:	be 2f 00 00 00       	mov    esi,0x2f
  411436:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  41143d:	00 00 00 
  411440:	ff d0                	call   rax
		assert(0);
  411442:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411449:	00 00 00 00 
  41144d:	0f 0b                	ud2    
        __asm__ __volatile__("lock " PS_FAA_STR
  41144f:	b8 04 00 00 00       	mov    eax,0x4
  411454:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  41145b:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  411460:	e9 f6 fe ff ff       	jmp    41135b <cos_vm_shared_region_alloc+0x4b>
  411465:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41146c:	00 00 00 00 

0000000000411470 <cos_vm_lapic_access_alloc>:

capid_t
cos_vm_lapic_access_alloc(struct cos_compinfo *ci, vaddr_t kmem)
{
  411470:	f3 0f 1e fa          	endbr64 
  411474:	55                   	push   rbp
        __asm__ __volatile__("lock " PS_CAS_STR
  411475:	31 c9                	xor    ecx,ecx
  411477:	48 89 e5             	mov    rbp,rsp
  41147a:	41 55                	push   r13
  41147c:	49 89 fd             	mov    r13,rdi
  41147f:	41 54                	push   r12
  411481:	53                   	push   rbx
  411482:	48 89 f3             	mov    rbx,rsi
  411485:	be 01 00 00 00       	mov    esi,0x1
  41148a:	48 83 ec 18          	sub    rsp,0x18
	return ci->memsrc;
  41148e:	4c 8b 67 60          	mov    r12,QWORD PTR [rdi+0x60]
{ while (!ps_cas(&l->o, 0, 1)) ; }
  411492:	49 8d 94 24 b0 00 00 	lea    rdx,[r12+0xb0]
  411499:	00 
  41149a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  4114a0:	48 89 c8             	mov    rax,rcx
  4114a3:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  4114a8:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  4114ab:	84 c0                	test   al,al
  4114ad:	74 f1                	je     4114a0 <cos_vm_lapic_access_alloc+0x30>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  4114af:	41 f6 44 24 38 03    	test   BYTE PTR [r12+0x38],0x3
  4114b5:	0f 84 ad 00 00 00    	je     411568 <cos_vm_lapic_access_alloc+0xf8>
        __asm__ __volatile__("lock " PS_FAA_STR
  4114bb:	bf 04 00 00 00       	mov    edi,0x4
  4114c0:	f0 49 0f c1 7c 24 38 	lock xadd QWORD PTR [r12+0x38],rdi
{ l->o = 0; }
  4114c7:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  4114ce:	00 00 00 00 00 
	capid_t cap = 0;

	cap = __capid_bump_alloc(__compinfo_metacap(ci), CAP_VM_LAPIC_ACCESS);
	if (cap == 0 || kmem == 0) {
  4114d3:	48 85 ff             	test   rdi,rdi
  4114d6:	0f 84 ab 00 00 00    	je     411587 <cos_vm_lapic_access_alloc+0x117>
  4114dc:	48 85 db             	test   rbx,rbx
  4114df:	0f 84 a2 00 00 00    	je     411587 <cos_vm_lapic_access_alloc+0x117>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4114e5:	41 8b 45 08          	mov    eax,DWORD PTR [r13+0x8]
		assert(0);
	}

	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_LAPIC_ACCESS_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  4114e9:	49 8b 55 60          	mov    rdx,QWORD PTR [r13+0x60]
	__asm__ __volatile__(
  4114ed:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4114f1:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  4114f4:	48 8b b2 98 00 00 00 	mov    rsi,QWORD PTR [rdx+0x98]
  4114fb:	31 d2                	xor    edx,edx
	cap_no += op;
  4114fd:	05 09 00 01 00       	add    eax,0x10009
	__asm__ __volatile__(
  411502:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411505:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411509:	48 89 cd             	mov    rbp,rcx
  41150c:	49 b8 20 15 41 00 00 	movabs r8,0x411520
  411513:	00 00 00 
  411516:	0f 05                	syscall 
  411518:	eb 0d                	jmp    411527 <cos_vm_lapic_access_alloc+0xb7>
  41151a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411520:	b9 00 00 00 00       	mov    ecx,0x0
  411525:	eb 05                	jmp    41152c <cos_vm_lapic_access_alloc+0xbc>
  411527:	b9 01 00 00 00       	mov    ecx,0x1
  41152c:	5d                   	pop    rbp
  41152d:	5c                   	pop    rsp
  41152e:	85 c0                	test   eax,eax
  411530:	75 0e                	jne    411540 <cos_vm_lapic_access_alloc+0xd0>

	return cap;

}
  411532:	48 83 c4 18          	add    rsp,0x18
  411536:	48 89 f8             	mov    rax,rdi
  411539:	5b                   	pop    rbx
  41153a:	41 5c                	pop    r12
  41153c:	41 5d                	pop    r13
  41153e:	5d                   	pop    rbp
  41153f:	c3                   	ret    
  411540:	48 bf a8 0c 42 00 00 	movabs rdi,0x420ca8
  411547:	00 00 00 
  41154a:	be 1c 00 00 00       	mov    esi,0x1c
  41154f:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  411556:	00 00 00 
  411559:	ff d0                	call   rax
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_LAPIC_ACCESS_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  41155b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411562:	00 00 00 00 
  411566:	0f 0b                	ud2    
		if (__capid_captbl_check_expand(ci)) goto error;
  411568:	48 b8 50 e4 40 00 00 	movabs rax,0x40e450
  41156f:	00 00 00 
  411572:	4c 89 e7             	mov    rdi,r12
  411575:	ff d0                	call   rax
  411577:	85 c0                	test   eax,eax
  411579:	74 34                	je     4115af <cos_vm_lapic_access_alloc+0x13f>
  41157b:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  411582:	00 00 00 00 00 
  411587:	48 bf 78 0c 42 00 00 	movabs rdi,0x420c78
  41158e:	00 00 00 
  411591:	be 2f 00 00 00       	mov    esi,0x2f
  411596:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  41159d:	00 00 00 
  4115a0:	ff d0                	call   rax
		assert(0);
  4115a2:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4115a9:	00 00 00 00 
  4115ad:	0f 0b                	ud2    
        __asm__ __volatile__("lock " PS_FAA_STR
  4115af:	b8 04 00 00 00       	mov    eax,0x4
  4115b4:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  4115bb:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  4115c0:	e9 f6 fe ff ff       	jmp    4114bb <cos_vm_lapic_access_alloc+0x4b>
  4115c5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4115cc:	00 00 00 00 

00000000004115d0 <cos_vm_vmcb_alloc>:

capid_t
cos_vm_vmcb_alloc(struct cos_compinfo *ci, vm_vmcscap_t vmcs_cap, vm_msrbitmapcap_t msr_bitmap_cap, vm_lapicaccesscap_t lapic_access_cap, vm_lapiccap_t lapic_cap, vm_shared_mem_t shared_mem_cap, thdcap_t handler_cap, word_t vpid)
{
  4115d0:	f3 0f 1e fa          	endbr64 
  4115d4:	55                   	push   rbp
  4115d5:	48 89 e5             	mov    rbp,rsp
  4115d8:	41 57                	push   r15
  4115da:	4d 89 c7             	mov    r15,r8
  4115dd:	41 56                	push   r14
  4115df:	49 89 ce             	mov    r14,rcx
        __asm__ __volatile__("lock " PS_CAS_STR
  4115e2:	31 c9                	xor    ecx,ecx
  4115e4:	41 55                	push   r13
  4115e6:	49 89 f5             	mov    r13,rsi
  4115e9:	41 54                	push   r12
  4115eb:	49 89 fc             	mov    r12,rdi
  4115ee:	53                   	push   rbx
  4115ef:	48 89 d3             	mov    rbx,rdx
  4115f2:	48 83 ec 28          	sub    rsp,0x28
	return ci->memsrc;
  4115f6:	48 8b 77 60          	mov    rsi,QWORD PTR [rdi+0x60]
  4115fa:	bf 01 00 00 00       	mov    edi,0x1
{ while (!ps_cas(&l->o, 0, 1)) ; }
  4115ff:	48 8d 96 b0 00 00 00 	lea    rdx,[rsi+0xb0]
  411606:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41160d:	00 00 00 
        __asm__ __volatile__("lock " PS_CAS_STR
  411610:	48 89 c8             	mov    rax,rcx
  411613:	f0 48 0f b1 3a       	lock cmpxchg QWORD PTR [rdx],rdi
  411618:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  41161b:	84 c0                	test   al,al
  41161d:	74 f1                	je     411610 <cos_vm_vmcb_alloc+0x40>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  41161f:	f6 46 38 03          	test   BYTE PTR [rsi+0x38],0x3
  411623:	0f 84 ab 00 00 00    	je     4116d4 <cos_vm_vmcb_alloc+0x104>
        __asm__ __volatile__("lock " PS_FAA_STR
  411629:	41 ba 04 00 00 00    	mov    r10d,0x4
  41162f:	f0 4c 0f c1 56 38    	lock xadd QWORD PTR [rsi+0x38],r10
{ l->o = 0; }
  411635:	48 c7 86 b0 00 00 00 	mov    QWORD PTR [rsi+0xb0],0x0
  41163c:	00 00 00 00 
	capid_t cap = 0;
	word_t arg1 = 0;
	word_t arg2 = 0;

	cap = __capid_bump_alloc(__compinfo_metacap(ci), CAP_VM_VMCB);
	if (cap == 0) {
  411640:	4d 85 d2             	test   r10,r10
  411643:	0f 84 f5 00 00 00    	je     41173e <cos_vm_vmcb_alloc+0x16e>
		assert(0);
	}

	arg1 = cap | vmcs_cap << (16 * 1) | msr_bitmap_cap << (16 * 2) |  lapic_access_cap << (16 * 3);
	arg2 = lapic_cap | shared_mem_cap << (16 * 1) | handler_cap << (16 * 2) | vpid << (16 * 3);
  411649:	48 8b 75 10          	mov    rsi,QWORD PTR [rbp+0x10]
  41164d:	48 8b 55 18          	mov    rdx,QWORD PTR [rbp+0x18]
	arg1 = cap | vmcs_cap << (16 * 1) | msr_bitmap_cap << (16 * 2) |  lapic_access_cap << (16 * 3);
  411651:	48 c1 e3 20          	shl    rbx,0x20
  411655:	49 c1 e6 30          	shl    r14,0x30

	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_VMCB_ACTIVATE, arg1, arg2, 0, 0)) BUG();
  411659:	49 8b 44 24 08       	mov    rax,QWORD PTR [r12+0x8]
	arg1 = cap | vmcs_cap << (16 * 1) | msr_bitmap_cap << (16 * 2) |  lapic_access_cap << (16 * 3);
  41165e:	4c 09 f3             	or     rbx,r14
  411661:	49 c1 e5 10          	shl    r13,0x10
  411665:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
	arg2 = lapic_cap | shared_mem_cap << (16 * 1) | handler_cap << (16 * 2) | vpid << (16 * 3);
  411669:	48 c1 e6 20          	shl    rsi,0x20
  41166d:	48 c1 e2 30          	shl    rdx,0x30
	arg1 = cap | vmcs_cap << (16 * 1) | msr_bitmap_cap << (16 * 2) |  lapic_access_cap << (16 * 3);
  411671:	4c 09 eb             	or     rbx,r13
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411674:	c1 e0 10             	shl    eax,0x10
	arg2 = lapic_cap | shared_mem_cap << (16 * 1) | handler_cap << (16 * 2) | vpid << (16 * 3);
  411677:	4c 09 fe             	or     rsi,r15
  41167a:	49 c1 e1 10          	shl    r9,0x10
	arg1 = cap | vmcs_cap << (16 * 1) | msr_bitmap_cap << (16 * 2) |  lapic_access_cap << (16 * 3);
  41167e:	4c 09 d3             	or     rbx,r10
	arg2 = lapic_cap | shared_mem_cap << (16 * 1) | handler_cap << (16 * 2) | vpid << (16 * 3);
  411681:	48 09 d6             	or     rsi,rdx
	__asm__ __volatile__(
  411684:	31 d2                	xor    edx,edx
	cap_no += op;
  411686:	05 0c 00 01 00       	add    eax,0x1000c
  41168b:	4c 09 ce             	or     rsi,r9
	__asm__ __volatile__(
  41168e:	48 89 d7             	mov    rdi,rdx
  411691:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411694:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411698:	48 89 cd             	mov    rbp,rcx
  41169b:	49 b8 b0 16 41 00 00 	movabs r8,0x4116b0
  4116a2:	00 00 00 
  4116a5:	0f 05                	syscall 
  4116a7:	90                   	nop
  4116a8:	eb 0d                	jmp    4116b7 <cos_vm_vmcb_alloc+0xe7>
  4116aa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4116b0:	b9 00 00 00 00       	mov    ecx,0x0
  4116b5:	eb 05                	jmp    4116bc <cos_vm_vmcb_alloc+0xec>
  4116b7:	b9 01 00 00 00       	mov    ecx,0x1
  4116bc:	5d                   	pop    rbp
  4116bd:	5c                   	pop    rsp
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_VMCB_ACTIVATE, arg1, arg2, 0, 0)) BUG();
  4116be:	85 c0                	test   eax,eax
  4116c0:	75 49                	jne    41170b <cos_vm_vmcb_alloc+0x13b>

	return cap;

}
  4116c2:	48 83 c4 28          	add    rsp,0x28
  4116c6:	4c 89 d0             	mov    rax,r10
  4116c9:	5b                   	pop    rbx
  4116ca:	41 5c                	pop    r12
  4116cc:	41 5d                	pop    r13
  4116ce:	41 5e                	pop    r14
  4116d0:	41 5f                	pop    r15
  4116d2:	5d                   	pop    rbp
  4116d3:	c3                   	ret    
  4116d4:	4c 89 4d b0          	mov    QWORD PTR [rbp-0x50],r9
		if (__capid_captbl_check_expand(ci)) goto error;
  4116d8:	48 89 f7             	mov    rdi,rsi
  4116db:	48 b8 50 e4 40 00 00 	movabs rax,0x40e450
  4116e2:	00 00 00 
  4116e5:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
  4116e9:	ff d0                	call   rax
  4116eb:	48 8b 75 b8          	mov    rsi,QWORD PTR [rbp-0x48]
  4116ef:	4c 8b 4d b0          	mov    r9,QWORD PTR [rbp-0x50]
  4116f3:	85 c0                	test   eax,eax
  4116f5:	75 3c                	jne    411733 <cos_vm_vmcb_alloc+0x163>
        __asm__ __volatile__("lock " PS_FAA_STR
  4116f7:	b8 04 00 00 00       	mov    eax,0x4
  4116fc:	f0 48 0f c1 46 18    	lock xadd QWORD PTR [rsi+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  411702:	48 89 46 38          	mov    QWORD PTR [rsi+0x38],rax
  411706:	e9 1e ff ff ff       	jmp    411629 <cos_vm_vmcb_alloc+0x59>
  41170b:	48 bf f8 0c 42 00 00 	movabs rdi,0x420cf8
  411712:	00 00 00 
  411715:	be 1c 00 00 00       	mov    esi,0x1c
  41171a:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  411721:	00 00 00 
  411724:	ff d0                	call   rax
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_VMCB_ACTIVATE, arg1, arg2, 0, 0)) BUG();
  411726:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41172d:	00 00 00 00 
  411731:	0f 0b                	ud2    
{ l->o = 0; }
  411733:	48 c7 86 b0 00 00 00 	mov    QWORD PTR [rsi+0xb0],0x0
  41173a:	00 00 00 00 
  41173e:	48 bf c8 0c 42 00 00 	movabs rdi,0x420cc8
  411745:	00 00 00 
  411748:	be 2f 00 00 00       	mov    esi,0x2f
  41174d:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  411754:	00 00 00 
  411757:	ff d0                	call   rax
		assert(0);
  411759:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411760:	00 00 00 00 
  411764:	0f 0b                	ud2    
  411766:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41176d:	00 00 00 

0000000000411770 <cos_initthd_alloc>:

thdcap_t
cos_initthd_alloc(struct cos_compinfo *ci, compcap_t comp)
{
  411770:	f3 0f 1e fa          	endbr64 
        __asm__ __volatile__("lock " PS_FAA_STR
  411774:	48 b8 80 00 46 00 00 	movabs rax,0x460080
  41177b:	00 00 00 
  41177e:	55                   	push   rbp
  41177f:	48 89 e5             	mov    rbp,rsp
  411782:	41 57                	push   r15
  411784:	41 56                	push   r14
  411786:	41 55                	push   r13
  411788:	41 bd 01 00 00 00    	mov    r13d,0x1
  41178e:	41 54                	push   r12
  411790:	53                   	push   rbx
  411791:	48 83 ec 28          	sub    rsp,0x28
  411795:	f0 4c 0f c1 28       	lock xadd QWORD PTR [rax],r13
	assert(ci && comp > 0);
  41179a:	48 85 ff             	test   rdi,rdi
  41179d:	0f 84 ed 01 00 00    	je     411990 <cos_initthd_alloc+0x220>
  4117a3:	49 89 f4             	mov    r12,rsi
  4117a6:	48 85 f6             	test   rsi,rsi
  4117a9:	0f 84 e1 01 00 00    	je     411990 <cos_initthd_alloc+0x220>
	if (!__cos_ulk_info.toplvl) return 0;
  4117af:	48 b8 80 4a 5a 00 00 	movabs rax,0x5a4a80
  4117b6:	00 00 00 
  4117b9:	4c 8b 18             	mov    r11,QWORD PTR [rax]
  4117bc:	49 89 fe             	mov    r14,rdi
  4117bf:	4d 85 db             	test   r11,r11
  4117c2:	74 68                	je     41182c <cos_initthd_alloc+0xbc>
	if (!__cos_ulk_info.curr_pg || tid % ULK_STACKS_PER_PAGE == 0) {
  4117c4:	48 a1 90 4a 5a 00 00 	movabs rax,ds:0x5a4a90
  4117cb:	00 00 00 
  4117ce:	48 85 c0             	test   rax,rax
  4117d1:	74 0a                	je     4117dd <cos_initthd_alloc+0x6d>
  4117d3:	41 f6 c5 0f          	test   r13b,0xf
  4117d7:	0f 85 73 01 00 00    	jne    411950 <cos_initthd_alloc+0x1e0>
		__cos_ulk_info.curr_pg = cos_ulk_page_alloc(ci, __cos_ulk_info.toplvl, __cos_ulk_info.pg_frontier);
  4117dd:	48 b8 98 4a 5a 00 00 	movabs rax,0x5a4a98
  4117e4:	00 00 00 
  4117e7:	4c 89 de             	mov    rsi,r11
  4117ea:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  4117ed:	4c 89 f7             	mov    rdi,r14
  4117f0:	48 b8 80 03 41 00 00 	movabs rax,0x410380
  4117f7:	00 00 00 
  4117fa:	ff d0                	call   rax
  4117fc:	48 a3 90 4a 5a 00 00 	movabs ds:0x5a4a90,rax
  411803:	00 00 00 
  411806:	49 89 c3             	mov    r11,rax
		assert(__cos_ulk_info.curr_pg);
  411809:	48 85 c0             	test   rax,rax
  41180c:	0f 84 a6 01 00 00    	je     4119b8 <cos_initthd_alloc+0x248>
		__cos_ulk_info.pg_frontier += PAGE_SIZE;
  411812:	48 a1 98 4a 5a 00 00 	movabs rax,ds:0x5a4a98
  411819:	00 00 00 
  41181c:	48 05 00 10 00 00    	add    rax,0x1000
  411822:	48 a3 98 4a 5a 00 00 	movabs ds:0x5a4a98,rax
  411829:	00 00 00 
  41182c:	4c 89 5d b8          	mov    QWORD PTR [rbp-0x48],r11
	return __mem_bump_alloc(ci, 1, 1);
  411830:	4c 89 f7             	mov    rdi,r14
  411833:	48 b8 b0 e2 40 00 00 	movabs rax,0x40e2b0
  41183a:	00 00 00 
  41183d:	ff d0                	call   rax
  41183f:	49 89 c2             	mov    r10,rax
	if (!*kmem) return -1;
  411842:	48 85 c0             	test   rax,rax
  411845:	0f 84 95 01 00 00    	je     4119e0 <cos_initthd_alloc+0x270>
        __asm__ __volatile__("lock " PS_CAS_STR
  41184b:	4c 8b 5d b8          	mov    r11,QWORD PTR [rbp-0x48]
{ while (!ps_cas(&l->o, 0, 1)) ; }
  41184f:	49 8d 8e b0 00 00 00 	lea    rcx,[r14+0xb0]
        __asm__ __volatile__("lock " PS_CAS_STR
  411856:	41 b9 01 00 00 00    	mov    r9d,0x1
  41185c:	45 31 c0             	xor    r8d,r8d
  41185f:	90                   	nop
  411860:	4c 89 c0             	mov    rax,r8
  411863:	f0 4c 0f b1 09       	lock cmpxchg QWORD PTR [rcx],r9
  411868:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  41186b:	84 c0                	test   al,al
  41186d:	74 f1                	je     411860 <cos_initthd_alloc+0xf0>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  41186f:	4d 8b 7e 28          	mov    r15,QWORD PTR [r14+0x28]
  411873:	41 83 e7 03          	and    r15d,0x3
  411877:	0f 84 9b 00 00 00    	je     411918 <cos_initthd_alloc+0x1a8>
        __asm__ __volatile__("lock " PS_FAA_STR
  41187d:	bb 01 00 00 00       	mov    ebx,0x1
  411882:	f0 49 0f c1 5e 28    	lock xadd QWORD PTR [r14+0x28],rbx
{ l->o = 0; }
  411888:	49 c7 86 b0 00 00 00 	mov    QWORD PTR [r14+0xb0],0x0
  41188f:	00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  411893:	49 89 df             	mov    r15,rbx
	if (!*cap) return -1;
  411896:	48 85 db             	test   rbx,rbx
  411899:	0f 84 41 01 00 00    	je     4119e0 <cos_initthd_alloc+0x270>
			  __compinfo_metacap(ci)->mi.pgtbl_cap << 16 | comp, kmem, ulkcap << 16 | tid);
  41189f:	49 8b 56 60          	mov    rdx,QWORD PTR [r14+0x60]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4118a3:	41 8b 46 08          	mov    eax,DWORD PTR [r14+0x8]
	__asm__ __volatile__(
  4118a7:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  4118ab:	4c 89 d7             	mov    rdi,r10
  4118ae:	48 8b b2 98 00 00 00 	mov    rsi,QWORD PTR [rdx+0x98]
  4118b5:	4c 89 da             	mov    rdx,r11
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4118b8:	c1 e0 10             	shl    eax,0x10
  4118bb:	48 c1 e2 10          	shl    rdx,0x10
	cap_no += op;
  4118bf:	05 04 00 01 00       	add    eax,0x10004
  4118c4:	48 c1 e6 10          	shl    rsi,0x10
	ret = call_cap_op(ci->captbl_cap, CAPTBL_OP_THDACTIVATE, (init_data << 16) | cap,
  4118c8:	4c 09 ea             	or     rdx,r13
  4118cb:	4c 09 e6             	or     rsi,r12
	__asm__ __volatile__(
  4118ce:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4118d1:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4118d5:	48 89 cd             	mov    rbp,rcx
  4118d8:	49 b8 f0 18 41 00 00 	movabs r8,0x4118f0
  4118df:	00 00 00 
  4118e2:	0f 05                	syscall 
  4118e4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  4118e8:	eb 0d                	jmp    4118f7 <cos_initthd_alloc+0x187>
  4118ea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4118f0:	b9 00 00 00 00       	mov    ecx,0x0
  4118f5:	eb 05                	jmp    4118fc <cos_initthd_alloc+0x18c>
  4118f7:	b9 01 00 00 00       	mov    ecx,0x1
  4118fc:	5d                   	pop    rbp
  4118fd:	5c                   	pop    rsp
	if (ret) BUG();
  4118fe:	85 c0                	test   eax,eax
  411900:	75 66                	jne    411968 <cos_initthd_alloc+0x1f8>
	thdid_t tid = cos_thd_id_alloc();

	return __cos_thd_alloc(ci, comp, 0, tid);
}
  411902:	48 83 c4 28          	add    rsp,0x28
  411906:	4c 89 f8             	mov    rax,r15
  411909:	5b                   	pop    rbx
  41190a:	41 5c                	pop    r12
  41190c:	41 5d                	pop    r13
  41190e:	41 5e                	pop    r14
  411910:	41 5f                	pop    r15
  411912:	5d                   	pop    rbp
  411913:	c3                   	ret    
  411914:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  411918:	4c 89 5d b0          	mov    QWORD PTR [rbp-0x50],r11
		if (__capid_captbl_check_expand(ci)) goto error;
  41191c:	4c 89 f7             	mov    rdi,r14
  41191f:	48 b8 50 e4 40 00 00 	movabs rax,0x40e450
  411926:	00 00 00 
  411929:	4c 89 55 b8          	mov    QWORD PTR [rbp-0x48],r10
  41192d:	ff d0                	call   rax
  41192f:	4c 8b 55 b8          	mov    r10,QWORD PTR [rbp-0x48]
  411933:	4c 8b 5d b0          	mov    r11,QWORD PTR [rbp-0x50]
  411937:	85 c0                	test   eax,eax
  411939:	75 1d                	jne    411958 <cos_initthd_alloc+0x1e8>
        __asm__ __volatile__("lock " PS_FAA_STR
  41193b:	b8 04 00 00 00       	mov    eax,0x4
  411940:	f0 49 0f c1 46 18    	lock xadd QWORD PTR [r14+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  411946:	49 89 46 28          	mov    QWORD PTR [r14+0x28],rax
  41194a:	e9 2e ff ff ff       	jmp    41187d <cos_initthd_alloc+0x10d>
  41194f:	90                   	nop
  411950:	49 89 c3             	mov    r11,rax
	return __cos_ulk_info.curr_pg;
  411953:	e9 d4 fe ff ff       	jmp    41182c <cos_initthd_alloc+0xbc>
{ l->o = 0; }
  411958:	49 c7 86 b0 00 00 00 	mov    QWORD PTR [r14+0xb0],0x0
  41195f:	00 00 00 00 
	if (!*cap) return -1;
  411963:	eb 9d                	jmp    411902 <cos_initthd_alloc+0x192>
  411965:	0f 1f 00             	nop    DWORD PTR [rax]
  411968:	48 bf 1f 09 42 00 00 	movabs rdi,0x42091f
  41196f:	00 00 00 
  411972:	be 1b 00 00 00       	mov    esi,0x1b
  411977:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  41197e:	00 00 00 
  411981:	ff d0                	call   rax
	if (ret) BUG();
  411983:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41198a:	00 00 00 00 
  41198e:	0f 0b                	ud2    
  411990:	48 bf 90 08 42 00 00 	movabs rdi,0x420890
  411997:	00 00 00 
  41199a:	be 2e 00 00 00       	mov    esi,0x2e
  41199f:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4119a6:	00 00 00 
  4119a9:	ff d0                	call   rax
	assert(ci && comp > 0);
  4119ab:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4119b2:	00 00 00 00 
  4119b6:	0f 0b                	ud2    
  4119b8:	48 bf c0 08 42 00 00 	movabs rdi,0x4208c0
  4119bf:	00 00 00 
  4119c2:	be 2e 00 00 00       	mov    esi,0x2e
  4119c7:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4119ce:	00 00 00 
  4119d1:	ff d0                	call   rax
		assert(__cos_ulk_info.curr_pg);
  4119d3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4119da:	00 00 00 00 
  4119de:	0f 0b                	ud2    
	if (__alloc_mem_cap(ci, CAP_THD, &kmem, &cap)) return 0;
  4119e0:	45 31 ff             	xor    r15d,r15d
	return __cos_thd_alloc(ci, comp, 0, tid);
  4119e3:	e9 1a ff ff ff       	jmp    411902 <cos_initthd_alloc+0x192>
  4119e8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4119ef:	00 

00000000004119f0 <cos_captbl_alloc>:

captblcap_t
cos_captbl_alloc(struct cos_compinfo *ci)
{
  4119f0:	f3 0f 1e fa          	endbr64 
  4119f4:	55                   	push   rbp
  4119f5:	48 89 e5             	mov    rbp,rsp
  4119f8:	41 56                	push   r14
  4119fa:	41 55                	push   r13
  4119fc:	41 54                	push   r12
  4119fe:	53                   	push   rbx
  4119ff:	48 83 ec 10          	sub    rsp,0x10
	vaddr_t kmem;
	capid_t cap;

	printd("cos_captbl_alloc\n");

	assert(ci);
  411a03:	48 85 ff             	test   rdi,rdi
  411a06:	0f 84 4c 01 00 00    	je     411b58 <cos_captbl_alloc+0x168>
	return __mem_bump_alloc(ci, 1, 1);
  411a0c:	48 b8 b0 e2 40 00 00 	movabs rax,0x40e2b0
  411a13:	00 00 00 
  411a16:	49 89 fc             	mov    r12,rdi
  411a19:	ff d0                	call   rax
  411a1b:	49 89 c5             	mov    r13,rax
	if (!*kmem) return -1;
  411a1e:	48 85 c0             	test   rax,rax
  411a21:	0f 84 59 01 00 00    	je     411b80 <cos_captbl_alloc+0x190>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  411a27:	49 8d 94 24 b0 00 00 	lea    rdx,[r12+0xb0]
  411a2e:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  411a2f:	be 01 00 00 00       	mov    esi,0x1
  411a34:	31 c9                	xor    ecx,ecx
  411a36:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  411a3d:	00 00 00 
  411a40:	48 89 c8             	mov    rax,rcx
  411a43:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  411a48:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  411a4b:	84 c0                	test   al,al
  411a4d:	74 f1                	je     411a40 <cos_captbl_alloc+0x50>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  411a4f:	4d 8b 74 24 38       	mov    r14,QWORD PTR [r12+0x38]
  411a54:	41 83 e6 03          	and    r14d,0x3
  411a58:	0f 84 92 00 00 00    	je     411af0 <cos_captbl_alloc+0x100>
        __asm__ __volatile__("lock " PS_FAA_STR
  411a5e:	bb 04 00 00 00       	mov    ebx,0x4
  411a63:	f0 49 0f c1 5c 24 38 	lock xadd QWORD PTR [r12+0x38],rbx
{ l->o = 0; }
  411a6a:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  411a71:	00 00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  411a76:	49 89 de             	mov    r14,rbx
	if (!*cap) return -1;
  411a79:	48 85 db             	test   rbx,rbx
  411a7c:	0f 84 fe 00 00 00    	je     411b80 <cos_captbl_alloc+0x190>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411a82:	41 8b 44 24 08       	mov    eax,DWORD PTR [r12+0x8]

	if (__alloc_mem_cap(ci, CAP_CAPTBL, &kmem, &cap)) return 0;
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_CAPTBLACTIVATE, cap, __compinfo_metacap(ci)->mi.pgtbl_cap, kmem, 0))
  411a87:	49 8b 54 24 60       	mov    rdx,QWORD PTR [r12+0x60]
	__asm__ __volatile__(
  411a8c:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  411a90:	4c 89 ef             	mov    rdi,r13
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411a93:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  411a96:	48 8b b2 98 00 00 00 	mov    rsi,QWORD PTR [rdx+0x98]
  411a9d:	31 d2                	xor    edx,edx
	cap_no += op;
  411a9f:	05 1e 00 01 00       	add    eax,0x1001e
	__asm__ __volatile__(
  411aa4:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411aa7:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411aab:	48 89 cd             	mov    rbp,rcx
  411aae:	49 b8 c8 1a 41 00 00 	movabs r8,0x411ac8
  411ab5:	00 00 00 
  411ab8:	0f 05                	syscall 
  411aba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411ac0:	eb 0d                	jmp    411acf <cos_captbl_alloc+0xdf>
  411ac2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411ac8:	b9 00 00 00 00       	mov    ecx,0x0
  411acd:	eb 05                	jmp    411ad4 <cos_captbl_alloc+0xe4>
  411acf:	b9 01 00 00 00       	mov    ecx,0x1
  411ad4:	5d                   	pop    rbp
  411ad5:	5c                   	pop    rsp
  411ad6:	85 c0                	test   eax,eax
  411ad8:	75 56                	jne    411b30 <cos_captbl_alloc+0x140>
		BUG();

	return cap;
}
  411ada:	48 83 c4 10          	add    rsp,0x10
  411ade:	4c 89 f0             	mov    rax,r14
  411ae1:	5b                   	pop    rbx
  411ae2:	41 5c                	pop    r12
  411ae4:	41 5d                	pop    r13
  411ae6:	41 5e                	pop    r14
  411ae8:	5d                   	pop    rbp
  411ae9:	c3                   	ret    
  411aea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  411af0:	48 b8 50 e4 40 00 00 	movabs rax,0x40e450
  411af7:	00 00 00 
  411afa:	4c 89 e7             	mov    rdi,r12
  411afd:	ff d0                	call   rax
  411aff:	85 c0                	test   eax,eax
  411b01:	75 16                	jne    411b19 <cos_captbl_alloc+0x129>
        __asm__ __volatile__("lock " PS_FAA_STR
  411b03:	b8 04 00 00 00       	mov    eax,0x4
  411b08:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  411b0f:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  411b14:	e9 45 ff ff ff       	jmp    411a5e <cos_captbl_alloc+0x6e>
{ l->o = 0; }
  411b19:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  411b20:	00 00 00 00 00 
	if (!*cap) return -1;
  411b25:	eb b3                	jmp    411ada <cos_captbl_alloc+0xea>
  411b27:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  411b2e:	00 00 
  411b30:	48 bf 48 0d 42 00 00 	movabs rdi,0x420d48
  411b37:	00 00 00 
  411b3a:	be 1c 00 00 00       	mov    esi,0x1c
  411b3f:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  411b46:	00 00 00 
  411b49:	ff d0                	call   rax
		BUG();
  411b4b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411b52:	00 00 00 00 
  411b56:	0f 0b                	ud2    
  411b58:	48 bf 18 0d 42 00 00 	movabs rdi,0x420d18
  411b5f:	00 00 00 
  411b62:	be 2f 00 00 00       	mov    esi,0x2f
  411b67:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  411b6e:	00 00 00 
  411b71:	ff d0                	call   rax
	assert(ci);
  411b73:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411b7a:	00 00 00 00 
  411b7e:	0f 0b                	ud2    
	if (__alloc_mem_cap(ci, CAP_CAPTBL, &kmem, &cap)) return 0;
  411b80:	45 31 f6             	xor    r14d,r14d
  411b83:	e9 52 ff ff ff       	jmp    411ada <cos_captbl_alloc+0xea>
  411b88:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  411b8f:	00 

0000000000411b90 <cos_pgtbl_alloc>:

pgtblcap_t
cos_pgtbl_alloc(struct cos_compinfo *ci, u8_t type)
{
  411b90:	f3 0f 1e fa          	endbr64 
  411b94:	55                   	push   rbp
  411b95:	48 89 e5             	mov    rbp,rsp
  411b98:	41 57                	push   r15
  411b9a:	41 56                	push   r14
  411b9c:	41 55                	push   r13
  411b9e:	41 54                	push   r12
  411ba0:	53                   	push   rbx
  411ba1:	48 83 ec 18          	sub    rsp,0x18
	capid_t cap;
	word_t lvl = 0;

	printd("cos_pgtbl_alloc\n");

	assert(ci);
  411ba5:	48 85 ff             	test   rdi,rdi
  411ba8:	0f 84 42 01 00 00    	je     411cf0 <cos_pgtbl_alloc+0x160>
	return __mem_bump_alloc(ci, 1, 1);
  411bae:	48 b8 b0 e2 40 00 00 	movabs rax,0x40e2b0
  411bb5:	00 00 00 
  411bb8:	49 89 fe             	mov    r14,rdi
  411bbb:	41 89 f4             	mov    r12d,esi
  411bbe:	ff d0                	call   rax
  411bc0:	49 89 c5             	mov    r13,rax
	if (!*kmem) return -1;
  411bc3:	48 85 c0             	test   rax,rax
  411bc6:	0f 84 4c 01 00 00    	je     411d18 <cos_pgtbl_alloc+0x188>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  411bcc:	49 8d 96 b0 00 00 00 	lea    rdx,[r14+0xb0]
        __asm__ __volatile__("lock " PS_CAS_STR
  411bd3:	be 01 00 00 00       	mov    esi,0x1
  411bd8:	31 c9                	xor    ecx,ecx
  411bda:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411be0:	48 89 c8             	mov    rax,rcx
  411be3:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  411be8:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  411beb:	84 c0                	test   al,al
  411bed:	74 f1                	je     411be0 <cos_pgtbl_alloc+0x50>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  411bef:	4d 8b 7e 38          	mov    r15,QWORD PTR [r14+0x38]
  411bf3:	41 83 e7 03          	and    r15d,0x3
  411bf7:	0f 84 93 00 00 00    	je     411c90 <cos_pgtbl_alloc+0x100>
        __asm__ __volatile__("lock " PS_FAA_STR
  411bfd:	bb 04 00 00 00       	mov    ebx,0x4
  411c02:	f0 49 0f c1 5e 38    	lock xadd QWORD PTR [r14+0x38],rbx
{ l->o = 0; }
  411c08:	49 c7 86 b0 00 00 00 	mov    QWORD PTR [r14+0xb0],0x0
  411c0f:	00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  411c13:	49 89 df             	mov    r15,rbx
	if (!*cap) return -1;
  411c16:	48 85 db             	test   rbx,rbx
  411c19:	0f 84 f9 00 00 00    	je     411d18 <cos_pgtbl_alloc+0x188>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411c1f:	41 8b 46 08          	mov    eax,DWORD PTR [r14+0x8]

	if (__alloc_mem_cap(ci, CAP_PGTBL, &kmem, &cap)) return 0;

	if (unlikely(type)) lvl |= PGTBL_LVL_FLAG_VM;
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_PGTBLACTIVATE, cap, __compinfo_metacap(ci)->mi.pgtbl_cap, kmem, lvl))
  411c23:	49 8b 56 60          	mov    rdx,QWORD PTR [r14+0x60]
	__asm__ __volatile__(
  411c27:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  411c2b:	4c 89 ef             	mov    rdi,r13
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411c2e:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  411c31:	48 8b b2 98 00 00 00 	mov    rsi,QWORD PTR [rdx+0x98]
	if (unlikely(type)) lvl |= PGTBL_LVL_FLAG_VM;
  411c38:	31 d2                	xor    edx,edx
	cap_no += op;
  411c3a:	05 1c 00 01 00       	add    eax,0x1001c
  411c3f:	45 84 e4             	test   r12b,r12b
  411c42:	0f 95 c2             	setne  dl
  411c45:	48 c1 e2 1f          	shl    rdx,0x1f
	__asm__ __volatile__(
  411c49:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411c4c:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411c50:	48 89 cd             	mov    rbp,rcx
  411c53:	49 b8 68 1c 41 00 00 	movabs r8,0x411c68
  411c5a:	00 00 00 
  411c5d:	0f 05                	syscall 
  411c5f:	90                   	nop
  411c60:	eb 0d                	jmp    411c6f <cos_pgtbl_alloc+0xdf>
  411c62:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411c68:	b9 00 00 00 00       	mov    ecx,0x0
  411c6d:	eb 05                	jmp    411c74 <cos_pgtbl_alloc+0xe4>
  411c6f:	b9 01 00 00 00       	mov    ecx,0x1
  411c74:	5d                   	pop    rbp
  411c75:	5c                   	pop    rsp
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_PGTBLACTIVATE, cap, __compinfo_metacap(ci)->mi.pgtbl_cap, kmem, lvl))
  411c76:	85 c0                	test   eax,eax
  411c78:	75 4e                	jne    411cc8 <cos_pgtbl_alloc+0x138>
		BUG();

	return cap;
}
  411c7a:	48 83 c4 18          	add    rsp,0x18
  411c7e:	4c 89 f8             	mov    rax,r15
  411c81:	5b                   	pop    rbx
  411c82:	41 5c                	pop    r12
  411c84:	41 5d                	pop    r13
  411c86:	41 5e                	pop    r14
  411c88:	41 5f                	pop    r15
  411c8a:	5d                   	pop    rbp
  411c8b:	c3                   	ret    
  411c8c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  411c90:	48 b8 50 e4 40 00 00 	movabs rax,0x40e450
  411c97:	00 00 00 
  411c9a:	4c 89 f7             	mov    rdi,r14
  411c9d:	ff d0                	call   rax
  411c9f:	85 c0                	test   eax,eax
  411ca1:	75 14                	jne    411cb7 <cos_pgtbl_alloc+0x127>
        __asm__ __volatile__("lock " PS_FAA_STR
  411ca3:	b8 04 00 00 00       	mov    eax,0x4
  411ca8:	f0 49 0f c1 46 18    	lock xadd QWORD PTR [r14+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  411cae:	49 89 46 38          	mov    QWORD PTR [r14+0x38],rax
  411cb2:	e9 46 ff ff ff       	jmp    411bfd <cos_pgtbl_alloc+0x6d>
{ l->o = 0; }
  411cb7:	49 c7 86 b0 00 00 00 	mov    QWORD PTR [r14+0xb0],0x0
  411cbe:	00 00 00 00 
	if (!*cap) return -1;
  411cc2:	eb b6                	jmp    411c7a <cos_pgtbl_alloc+0xea>
  411cc4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  411cc8:	48 bf 98 0d 42 00 00 	movabs rdi,0x420d98
  411ccf:	00 00 00 
  411cd2:	be 1c 00 00 00       	mov    esi,0x1c
  411cd7:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  411cde:	00 00 00 
  411ce1:	ff d0                	call   rax
		BUG();
  411ce3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411cea:	00 00 00 00 
  411cee:	0f 0b                	ud2    
  411cf0:	48 bf 68 0d 42 00 00 	movabs rdi,0x420d68
  411cf7:	00 00 00 
  411cfa:	be 2f 00 00 00       	mov    esi,0x2f
  411cff:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  411d06:	00 00 00 
  411d09:	ff d0                	call   rax
	assert(ci);
  411d0b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411d12:	00 00 00 00 
  411d16:	0f 0b                	ud2    
	if (__alloc_mem_cap(ci, CAP_PGTBL, &kmem, &cap)) return 0;
  411d18:	45 31 ff             	xor    r15d,r15d
  411d1b:	e9 5a ff ff ff       	jmp    411c7a <cos_pgtbl_alloc+0xea>

0000000000411d20 <cos_ulk_pgtbl_create>:
{
  411d20:	f3 0f 1e fa          	endbr64 
  411d24:	55                   	push   rbp
  411d25:	48 89 e5             	mov    rbp,rsp
  411d28:	41 57                	push   r15
  411d2a:	41 56                	push   r14
  411d2c:	41 55                	push   r13
  411d2e:	41 54                	push   r12
  411d30:	53                   	push   rbx
  411d31:	48 83 ec 58          	sub    rsp,0x58
	assert(ci && secondlvl);
  411d35:	48 85 ff             	test   rdi,rdi
  411d38:	0f 84 34 02 00 00    	je     411f72 <cos_ulk_pgtbl_create+0x252>
  411d3e:	48 89 f3             	mov    rbx,rsi
  411d41:	48 85 f6             	test   rsi,rsi
  411d44:	0f 84 28 02 00 00    	je     411f72 <cos_ulk_pgtbl_create+0x252>
	toplvl = cos_pgtbl_alloc(__compinfo_metacap(ci), PGTBL_TYPE_DEF);
  411d4a:	48 b8 90 1b 41 00 00 	movabs rax,0x411b90
  411d51:	00 00 00 
  411d54:	49 89 fd             	mov    r13,rdi
  411d57:	31 f6                	xor    esi,esi
  411d59:	48 8b 7f 60          	mov    rdi,QWORD PTR [rdi+0x60]
  411d5d:	ff d0                	call   rax
	*secondlvl = __bump_mem_expand_intern(__compinfo_metacap(ci), toplvl, ULK_BASE_ADDR, 0, 0);
  411d5f:	49 8b 7d 60          	mov    rdi,QWORD PTR [r13+0x60]
  411d63:	45 31 c0             	xor    r8d,r8d
  411d66:	31 c9                	xor    ecx,ecx
  411d68:	48 ba 00 00 00 00 80 	movabs rdx,0x7f8000000000
  411d6f:	7f 00 00 
	toplvl = cos_pgtbl_alloc(__compinfo_metacap(ci), PGTBL_TYPE_DEF);
  411d72:	49 89 c7             	mov    r15,rax
	*secondlvl = __bump_mem_expand_intern(__compinfo_metacap(ci), toplvl, ULK_BASE_ADDR, 0, 0);
  411d75:	48 89 c6             	mov    rsi,rax
  411d78:	49 be 30 ef 40 00 00 	movabs r14,0x40ef30
  411d7f:	00 00 00 
  411d82:	41 ff d6             	call   r14
  411d85:	48 89 03             	mov    QWORD PTR [rbx],rax
	if (!*secondlvl) return 0;
  411d88:	48 85 c0             	test   rax,rax
  411d8b:	75 1b                	jne    411da8 <cos_ulk_pgtbl_create+0x88>
  411d8d:	45 31 ff             	xor    r15d,r15d
}
  411d90:	48 83 c4 58          	add    rsp,0x58
  411d94:	4c 89 f8             	mov    rax,r15
  411d97:	5b                   	pop    rbx
  411d98:	41 5c                	pop    r12
  411d9a:	41 5d                	pop    r13
  411d9c:	41 5e                	pop    r14
  411d9e:	41 5f                	pop    r15
  411da0:	5d                   	pop    rbp
  411da1:	c3                   	ret    
  411da2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
		if (__bump_mem_expand_intern(meta, cipgtbl, addr, 0, pgtbl_lvl) == 0) return 0;
  411da8:	45 31 c0             	xor    r8d,r8d
  411dab:	31 c9                	xor    ecx,ecx
  411dad:	49 8b 7d 60          	mov    rdi,QWORD PTR [r13+0x60]
  411db1:	4c 89 fe             	mov    rsi,r15
  411db4:	48 ba 00 10 00 00 80 	movabs rdx,0x7f8000001000
  411dbb:	7f 00 00 
  411dbe:	41 ff d6             	call   r14
  411dc1:	48 85 c0             	test   rax,rax
  411dc4:	74 c7                	je     411d8d <cos_ulk_pgtbl_create+0x6d>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411dc6:	44 89 f8             	mov    eax,r15d
	cap_no += op;
  411dc9:	48 c7 45 b8 01 00 00 	mov    QWORD PTR [rbp-0x48],0x1
  411dd0:	00 
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411dd1:	c1 e0 10             	shl    eax,0x10
		if (__capid_captbl_check_expand(ci)) goto error;
  411dd4:	4c 89 7d a0          	mov    QWORD PTR [rbp-0x60],r15
	cap_no += op;
  411dd8:	05 01 00 01 00       	add    eax,0x10001
  411ddd:	4c 89 6d b0          	mov    QWORD PTR [rbp-0x50],r13
  411de1:	89 45 ac             	mov    DWORD PTR [rbp-0x54],eax
	return ci->memsrc;
  411de4:	48 8b 45 b0          	mov    rax,QWORD PTR [rbp-0x50]
        __asm__ __volatile__("lock " PS_CAS_STR
  411de8:	41 bf 01 00 00 00    	mov    r15d,0x1
  411dee:	48 b9 30 15 42 00 00 	movabs rcx,0x421530
  411df5:	00 00 00 
  411df8:	4c 8b 70 60          	mov    r14,QWORD PTR [rax+0x60]
	range		 = cos_pgtbl_get_range(lvl);
  411dfc:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  411e00:	48 8b 0c c1          	mov    rcx,QWORD PTR [rcx+rax*8]
		return round_up_to_pgt2_page(vaddr);
  411e04:	48 83 f8 02          	cmp    rax,0x2
  411e08:	48 b8 00 00 20 00 80 	movabs rax,0x7f8000200000
  411e0f:	7f 00 00 
  411e12:	48 89 4d 88          	mov    QWORD PTR [rbp-0x78],rcx
  411e16:	48 b9 00 00 00 40 80 	movabs rcx,0x7f8040000000
  411e1d:	7f 00 00 
  411e20:	48 0f 45 c1          	cmovne rax,rcx
  411e24:	45 31 ed             	xor    r13d,r13d
  411e27:	48 89 45 90          	mov    QWORD PTR [rbp-0x70],rax
	for (addr = mem_ptr; addr < tmp_frontier; addr += range) {
  411e2b:	48 b8 00 00 00 00 80 	movabs rax,0x7f8000000000
  411e32:	7f 00 00 
  411e35:	48 89 45 98          	mov    QWORD PTR [rbp-0x68],rax
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  411e39:	4d 3b 76 60          	cmp    r14,QWORD PTR [r14+0x60]
  411e3d:	0f 85 e8 01 00 00    	jne    41202b <cos_ulk_pgtbl_create+0x30b>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  411e43:	49 8d 96 b0 00 00 00 	lea    rdx,[r14+0xb0]
  411e4a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  411e50:	4c 89 e8             	mov    rax,r13
  411e53:	f0 4c 0f b1 3a       	lock cmpxchg QWORD PTR [rdx],r15
  411e58:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  411e5b:	84 c0                	test   al,al
  411e5d:	74 f1                	je     411e50 <cos_ulk_pgtbl_create+0x130>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  411e5f:	41 f6 46 38 03       	test   BYTE PTR [r14+0x38],0x3
  411e64:	0f 84 30 01 00 00    	je     411f9a <cos_ulk_pgtbl_create+0x27a>
        __asm__ __volatile__("lock " PS_FAA_STR
  411e6a:	bb 04 00 00 00       	mov    ebx,0x4
  411e6f:	f0 49 0f c1 5e 38    	lock xadd QWORD PTR [r14+0x38],rbx
	return __mem_bump_alloc(ci, 1, 1);
  411e75:	48 b8 b0 e2 40 00 00 	movabs rax,0x40e2b0
  411e7c:	00 00 00 
  411e7f:	4c 89 f7             	mov    rdi,r14
{ l->o = 0; }
  411e82:	49 c7 86 b0 00 00 00 	mov    QWORD PTR [r14+0xb0],0x0
  411e89:	00 00 00 00 
  411e8d:	ff d0                	call   rax
  411e8f:	48 89 c7             	mov    rdi,rax
		if (pte_cap == 0 || ptemem_cap == 0) {
  411e92:	48 85 db             	test   rbx,rbx
  411e95:	0f 84 2c 01 00 00    	je     411fc7 <cos_ulk_pgtbl_create+0x2a7>
  411e9b:	48 85 c0             	test   rax,rax
  411e9e:	0f 84 23 01 00 00    	je     411fc7 <cos_ulk_pgtbl_create+0x2a7>
		if (call_cap_op(meta->captbl_cap, CAPTBL_OP_PGTBLACTIVATE, pte_cap, meta->mi.pgtbl_cap, ptemem_cap,
  411ea4:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
	__asm__ __volatile__(
  411ea8:	4c 8d 55 c0          	lea    r10,[rbp-0x40]
  411eac:	49 8b b6 98 00 00 00 	mov    rsi,QWORD PTR [r14+0x98]
  411eb3:	4c 89 d1             	mov    rcx,r10
  411eb6:	48 8d 50 01          	lea    rdx,[rax+0x1]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411eba:	41 8b 46 08          	mov    eax,DWORD PTR [r14+0x8]
  411ebe:	48 89 55 80          	mov    QWORD PTR [rbp-0x80],rdx
  411ec2:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  411ec5:	05 1c 00 01 00       	add    eax,0x1001c
	__asm__ __volatile__(
  411eca:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411ecd:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411ed1:	48 89 cd             	mov    rbp,rcx
  411ed4:	49 b8 e8 1e 41 00 00 	movabs r8,0x411ee8
  411edb:	00 00 00 
  411ede:	0f 05                	syscall 
  411ee0:	eb 0d                	jmp    411eef <cos_ulk_pgtbl_create+0x1cf>
  411ee2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411ee8:	b9 00 00 00 00       	mov    ecx,0x0
  411eed:	eb 05                	jmp    411ef4 <cos_ulk_pgtbl_create+0x1d4>
  411eef:	b9 01 00 00 00       	mov    ecx,0x1
  411ef4:	5d                   	pop    rbp
  411ef5:	5c                   	pop    rsp
  411ef6:	85 c0                	test   eax,eax
  411ef8:	0f 85 05 01 00 00    	jne    412003 <cos_ulk_pgtbl_create+0x2e3>
  411efe:	8b 45 ac             	mov    eax,DWORD PTR [rbp-0x54]
  411f01:	48 8b 75 98          	mov    rsi,QWORD PTR [rbp-0x68]
  411f05:	4c 89 ef             	mov    rdi,r13
  411f08:	4c 89 ea             	mov    rdx,r13
  411f0b:	4c 89 d1             	mov    rcx,r10
  411f0e:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411f11:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411f15:	48 89 cd             	mov    rbp,rcx
  411f18:	49 b8 30 1f 41 00 00 	movabs r8,0x411f30
  411f1f:	00 00 00 
  411f22:	0f 05                	syscall 
  411f24:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  411f28:	eb 0d                	jmp    411f37 <cos_ulk_pgtbl_create+0x217>
  411f2a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411f30:	b9 00 00 00 00       	mov    ecx,0x0
  411f35:	eb 05                	jmp    411f3c <cos_ulk_pgtbl_create+0x21c>
  411f37:	b9 01 00 00 00       	mov    ecx,0x1
  411f3c:	5d                   	pop    rbp
  411f3d:	5c                   	pop    rsp
	for (addr = mem_ptr; addr < tmp_frontier; addr += range) {
  411f3e:	48 8b 45 88          	mov    rax,QWORD PTR [rbp-0x78]
  411f42:	48 01 c6             	add    rsi,rax
  411f45:	48 89 75 98          	mov    QWORD PTR [rbp-0x68],rsi
  411f49:	48 39 75 90          	cmp    QWORD PTR [rbp-0x70],rsi
  411f4d:	0f 87 e6 fe ff ff    	ja     411e39 <cos_ulk_pgtbl_create+0x119>
  411f53:	4c 8b 55 80          	mov    r10,QWORD PTR [rbp-0x80]
	for (pgtbl_lvl = 1; pgtbl_lvl < COS_PGTBL_DEPTH - 1; pgtbl_lvl++) {
  411f57:	48 c7 45 b8 02 00 00 	mov    QWORD PTR [rbp-0x48],0x2
  411f5e:	00 
  411f5f:	49 83 fa 03          	cmp    r10,0x3
  411f63:	0f 85 7b fe ff ff    	jne    411de4 <cos_ulk_pgtbl_create+0xc4>
  411f69:	4c 8b 7d a0          	mov    r15,QWORD PTR [rbp-0x60]
  411f6d:	e9 1e fe ff ff       	jmp    411d90 <cos_ulk_pgtbl_create+0x70>
  411f72:	48 bf b8 0d 42 00 00 	movabs rdi,0x420db8
  411f79:	00 00 00 
  411f7c:	be 2e 00 00 00       	mov    esi,0x2e
  411f81:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  411f88:	00 00 00 
  411f8b:	ff d0                	call   rax
	assert(ci && secondlvl);
  411f8d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411f94:	00 00 00 00 
  411f98:	0f 0b                	ud2    
		if (__capid_captbl_check_expand(ci)) goto error;
  411f9a:	48 b8 50 e4 40 00 00 	movabs rax,0x40e450
  411fa1:	00 00 00 
  411fa4:	4c 89 f7             	mov    rdi,r14
  411fa7:	ff d0                	call   rax
  411fa9:	85 c0                	test   eax,eax
  411fab:	74 42                	je     411fef <cos_ulk_pgtbl_create+0x2cf>
  411fad:	49 c7 86 b0 00 00 00 	mov    QWORD PTR [r14+0xb0],0x0
  411fb4:	00 00 00 00 
	return __mem_bump_alloc(ci, 1, 1);
  411fb8:	4c 89 f7             	mov    rdi,r14
  411fbb:	48 b8 b0 e2 40 00 00 	movabs rax,0x40e2b0
  411fc2:	00 00 00 
  411fc5:	ff d0                	call   rax
  411fc7:	48 bf a0 03 42 00 00 	movabs rdi,0x4203a0
  411fce:	00 00 00 
  411fd1:	be 2e 00 00 00       	mov    esi,0x2e
  411fd6:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  411fdd:	00 00 00 
  411fe0:	ff d0                	call   rax
			assert(0);
  411fe2:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411fe9:	00 00 00 00 
  411fed:	0f 0b                	ud2    
        __asm__ __volatile__("lock " PS_FAA_STR
  411fef:	b8 04 00 00 00       	mov    eax,0x4
  411ff4:	f0 49 0f c1 46 18    	lock xadd QWORD PTR [r14+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  411ffa:	49 89 46 38          	mov    QWORD PTR [r14+0x38],rax
  411ffe:	e9 67 fe ff ff       	jmp    411e6a <cos_ulk_pgtbl_create+0x14a>
  412003:	48 bf d0 03 42 00 00 	movabs rdi,0x4203d0
  41200a:	00 00 00 
  41200d:	be 2e 00 00 00       	mov    esi,0x2e
  412012:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  412019:	00 00 00 
  41201c:	ff d0                	call   rax
				assert(0); /* race? */
  41201e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412025:	00 00 00 00 
  412029:	0f 0b                	ud2    
  41202b:	48 bf 70 03 42 00 00 	movabs rdi,0x420370
  412032:	00 00 00 
  412035:	be 2e 00 00 00       	mov    esi,0x2e
  41203a:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  412041:	00 00 00 
  412044:	ff d0                	call   rax
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  412046:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41204d:	00 00 00 00 
  412051:	0f 0b                	ud2    
  412053:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41205a:	00 00 00 00 
  41205e:	66 90                	xchg   ax,ax

0000000000412060 <cos_ulk_info_init>:
{
  412060:	f3 0f 1e fa          	endbr64 
  412064:	55                   	push   rbp
  412065:	48 89 e5             	mov    rbp,rsp
  412068:	41 57                	push   r15
  41206a:	41 56                	push   r14
  41206c:	41 55                	push   r13
  41206e:	41 54                	push   r12
  412070:	53                   	push   rbx
  412071:	48 83 ec 58          	sub    rsp,0x58
	assert(ci && secondlvl);
  412075:	48 85 ff             	test   rdi,rdi
  412078:	0f 84 c1 02 00 00    	je     41233f <cos_ulk_info_init+0x2df>
	toplvl = cos_pgtbl_alloc(__compinfo_metacap(ci), PGTBL_TYPE_DEF);
  41207e:	48 b8 90 1b 41 00 00 	movabs rax,0x411b90
  412085:	00 00 00 
  412088:	49 89 fe             	mov    r14,rdi
  41208b:	31 f6                	xor    esi,esi
  41208d:	48 8b 7f 60          	mov    rdi,QWORD PTR [rdi+0x60]
  412091:	ff d0                	call   rax
	*secondlvl = __bump_mem_expand_intern(__compinfo_metacap(ci), toplvl, ULK_BASE_ADDR, 0, 0);
  412093:	49 8b 7e 60          	mov    rdi,QWORD PTR [r14+0x60]
  412097:	45 31 c0             	xor    r8d,r8d
  41209a:	31 c9                	xor    ecx,ecx
  41209c:	48 ba 00 00 00 00 80 	movabs rdx,0x7f8000000000
  4120a3:	7f 00 00 
	toplvl = cos_pgtbl_alloc(__compinfo_metacap(ci), PGTBL_TYPE_DEF);
  4120a6:	49 89 c7             	mov    r15,rax
	*secondlvl = __bump_mem_expand_intern(__compinfo_metacap(ci), toplvl, ULK_BASE_ADDR, 0, 0);
  4120a9:	48 89 c6             	mov    rsi,rax
  4120ac:	49 bd 30 ef 40 00 00 	movabs r13,0x40ef30
  4120b3:	00 00 00 
  4120b6:	41 ff d5             	call   r13
  4120b9:	48 a3 88 4a 5a 00 00 	movabs ds:0x5a4a88,rax
  4120c0:	00 00 00 
	if (!*secondlvl) return 0;
  4120c3:	48 85 c0             	test   rax,rax
  4120c6:	75 68                	jne    412130 <cos_ulk_info_init+0xd0>
	__cos_ulk_info.toplvl = cos_ulk_pgtbl_create(ci, &__cos_ulk_info.secondlvl);
  4120c8:	48 b8 80 4a 5a 00 00 	movabs rax,0x5a4a80
  4120cf:	00 00 00 
	__cos_ulk_info.pg_frontier = ULK_BASE_ADDR + __thdid_alloc * sizeof(struct ulk_invstk);
  4120d2:	48 ba 00 00 00 80 7f 	movabs rdx,0x7f80000000
  4120d9:	00 00 00 
	__cos_ulk_info.toplvl = cos_ulk_pgtbl_create(ci, &__cos_ulk_info.secondlvl);
  4120dc:	48 c7 00 00 00 00 00 	mov    QWORD PTR [rax],0x0
	__cos_ulk_info.pg_frontier = ULK_BASE_ADDR + __thdid_alloc * sizeof(struct ulk_invstk);
  4120e3:	48 a1 80 00 46 00 00 	movabs rax,ds:0x460080
  4120ea:	00 00 00 
  4120ed:	48 01 d0             	add    rax,rdx
  4120f0:	48 c1 e0 08          	shl    rax,0x8
  4120f4:	48 a3 98 4a 5a 00 00 	movabs ds:0x5a4a98,rax
  4120fb:	00 00 00 
  4120fe:	48 bf e8 0d 42 00 00 	movabs rdi,0x420de8
  412105:	00 00 00 
  412108:	be 2e 00 00 00       	mov    esi,0x2e
  41210d:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  412114:	00 00 00 
  412117:	ff d0                	call   rax
	assert(__cos_ulk_info.toplvl);
  412119:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412120:	00 00 00 00 
  412124:	0f 0b                	ud2    
  412126:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41212d:	00 00 00 
		if (__bump_mem_expand_intern(meta, cipgtbl, addr, 0, pgtbl_lvl) == 0) return 0;
  412130:	45 31 c0             	xor    r8d,r8d
  412133:	31 c9                	xor    ecx,ecx
  412135:	49 8b 7e 60          	mov    rdi,QWORD PTR [r14+0x60]
  412139:	4c 89 fe             	mov    rsi,r15
  41213c:	48 ba 00 10 00 00 80 	movabs rdx,0x7f8000001000
  412143:	7f 00 00 
  412146:	41 ff d5             	call   r13
  412149:	48 85 c0             	test   rax,rax
  41214c:	0f 84 76 ff ff ff    	je     4120c8 <cos_ulk_info_init+0x68>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  412152:	44 89 f8             	mov    eax,r15d
	cap_no += op;
  412155:	48 c7 45 b8 01 00 00 	mov    QWORD PTR [rbp-0x48],0x1
  41215c:	00 
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  41215d:	c1 e0 10             	shl    eax,0x10
		if (__capid_captbl_check_expand(ci)) goto error;
  412160:	4c 89 7d a8          	mov    QWORD PTR [rbp-0x58],r15
  412164:	4c 89 75 b0          	mov    QWORD PTR [rbp-0x50],r14
	cap_no += op;
  412168:	05 01 00 01 00       	add    eax,0x10001
  41216d:	89 45 a4             	mov    DWORD PTR [rbp-0x5c],eax
  412170:	4c 89 f0             	mov    rax,r14
	return ci->memsrc;
  412173:	4c 8b 78 60          	mov    r15,QWORD PTR [rax+0x60]
	range		 = cos_pgtbl_get_range(lvl);
  412177:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
        __asm__ __volatile__("lock " PS_CAS_STR
  41217b:	41 be 01 00 00 00    	mov    r14d,0x1
  412181:	48 bb 30 15 42 00 00 	movabs rbx,0x421530
  412188:	00 00 00 
  41218b:	48 8b 1c c3          	mov    rbx,QWORD PTR [rbx+rax*8]
		return round_up_to_pgt2_page(vaddr);
  41218f:	48 83 f8 02          	cmp    rax,0x2
  412193:	48 b8 00 00 20 00 80 	movabs rax,0x7f8000200000
  41219a:	7f 00 00 
  41219d:	48 89 5d 88          	mov    QWORD PTR [rbp-0x78],rbx
  4121a1:	48 bb 00 00 00 40 80 	movabs rbx,0x7f8040000000
  4121a8:	7f 00 00 
  4121ab:	48 0f 45 c3          	cmovne rax,rbx
  4121af:	45 31 ed             	xor    r13d,r13d
  4121b2:	48 89 45 90          	mov    QWORD PTR [rbp-0x70],rax
	for (addr = mem_ptr; addr < tmp_frontier; addr += range) {
  4121b6:	48 b8 00 00 00 00 80 	movabs rax,0x7f8000000000
  4121bd:	7f 00 00 
  4121c0:	48 89 45 98          	mov    QWORD PTR [rbp-0x68],rax
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  4121c4:	4d 3b 7f 60          	cmp    r15,QWORD PTR [r15+0x60]
  4121c8:	0f 85 2a 02 00 00    	jne    4123f8 <cos_ulk_info_init+0x398>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  4121ce:	49 8d 97 b0 00 00 00 	lea    rdx,[r15+0xb0]
  4121d5:	0f 1f 00             	nop    DWORD PTR [rax]
        __asm__ __volatile__("lock " PS_CAS_STR
  4121d8:	4c 89 e8             	mov    rax,r13
  4121db:	f0 4c 0f b1 32       	lock cmpxchg QWORD PTR [rdx],r14
  4121e0:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  4121e3:	84 c0                	test   al,al
  4121e5:	74 f1                	je     4121d8 <cos_ulk_info_init+0x178>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  4121e7:	41 f6 47 38 03       	test   BYTE PTR [r15+0x38],0x3
  4121ec:	0f 84 75 01 00 00    	je     412367 <cos_ulk_info_init+0x307>
        __asm__ __volatile__("lock " PS_FAA_STR
  4121f2:	bb 04 00 00 00       	mov    ebx,0x4
  4121f7:	f0 49 0f c1 5f 38    	lock xadd QWORD PTR [r15+0x38],rbx
	return __mem_bump_alloc(ci, 1, 1);
  4121fd:	48 b8 b0 e2 40 00 00 	movabs rax,0x40e2b0
  412204:	00 00 00 
  412207:	4c 89 ff             	mov    rdi,r15
{ l->o = 0; }
  41220a:	49 c7 87 b0 00 00 00 	mov    QWORD PTR [r15+0xb0],0x0
  412211:	00 00 00 00 
  412215:	ff d0                	call   rax
  412217:	48 89 c7             	mov    rdi,rax
		if (pte_cap == 0 || ptemem_cap == 0) {
  41221a:	48 85 db             	test   rbx,rbx
  41221d:	0f 84 71 01 00 00    	je     412394 <cos_ulk_info_init+0x334>
  412223:	48 85 c0             	test   rax,rax
  412226:	0f 84 68 01 00 00    	je     412394 <cos_ulk_info_init+0x334>
		if (call_cap_op(meta->captbl_cap, CAPTBL_OP_PGTBLACTIVATE, pte_cap, meta->mi.pgtbl_cap, ptemem_cap,
  41222c:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
	__asm__ __volatile__(
  412230:	4c 8d 55 c0          	lea    r10,[rbp-0x40]
  412234:	49 8b b7 98 00 00 00 	mov    rsi,QWORD PTR [r15+0x98]
  41223b:	4c 89 d1             	mov    rcx,r10
  41223e:	48 8d 50 01          	lea    rdx,[rax+0x1]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  412242:	41 8b 47 08          	mov    eax,DWORD PTR [r15+0x8]
  412246:	48 89 55 80          	mov    QWORD PTR [rbp-0x80],rdx
  41224a:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  41224d:	05 1c 00 01 00       	add    eax,0x1001c
	__asm__ __volatile__(
  412252:	48 89 29             	mov    QWORD PTR [rcx],rbp
  412255:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  412259:	48 89 cd             	mov    rbp,rcx
  41225c:	49 b8 70 22 41 00 00 	movabs r8,0x412270
  412263:	00 00 00 
  412266:	0f 05                	syscall 
  412268:	eb 0d                	jmp    412277 <cos_ulk_info_init+0x217>
  41226a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  412270:	b9 00 00 00 00       	mov    ecx,0x0
  412275:	eb 05                	jmp    41227c <cos_ulk_info_init+0x21c>
  412277:	b9 01 00 00 00       	mov    ecx,0x1
  41227c:	5d                   	pop    rbp
  41227d:	5c                   	pop    rsp
  41227e:	85 c0                	test   eax,eax
  412280:	0f 85 4a 01 00 00    	jne    4123d0 <cos_ulk_info_init+0x370>
  412286:	8b 45 a4             	mov    eax,DWORD PTR [rbp-0x5c]
  412289:	48 8b 75 98          	mov    rsi,QWORD PTR [rbp-0x68]
  41228d:	4c 89 ef             	mov    rdi,r13
  412290:	4c 89 ea             	mov    rdx,r13
  412293:	4c 89 d1             	mov    rcx,r10
  412296:	48 89 29             	mov    QWORD PTR [rcx],rbp
  412299:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  41229d:	48 89 cd             	mov    rbp,rcx
  4122a0:	49 b8 b8 22 41 00 00 	movabs r8,0x4122b8
  4122a7:	00 00 00 
  4122aa:	0f 05                	syscall 
  4122ac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  4122b0:	eb 0d                	jmp    4122bf <cos_ulk_info_init+0x25f>
  4122b2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4122b8:	b9 00 00 00 00       	mov    ecx,0x0
  4122bd:	eb 05                	jmp    4122c4 <cos_ulk_info_init+0x264>
  4122bf:	b9 01 00 00 00       	mov    ecx,0x1
  4122c4:	5d                   	pop    rbp
  4122c5:	5c                   	pop    rsp
	for (addr = mem_ptr; addr < tmp_frontier; addr += range) {
  4122c6:	48 8b 45 88          	mov    rax,QWORD PTR [rbp-0x78]
  4122ca:	48 01 c6             	add    rsi,rax
  4122cd:	48 89 75 98          	mov    QWORD PTR [rbp-0x68],rsi
  4122d1:	48 39 75 90          	cmp    QWORD PTR [rbp-0x70],rsi
  4122d5:	0f 87 e9 fe ff ff    	ja     4121c4 <cos_ulk_info_init+0x164>
  4122db:	4c 8b 55 80          	mov    r10,QWORD PTR [rbp-0x80]
	for (pgtbl_lvl = 1; pgtbl_lvl < COS_PGTBL_DEPTH - 1; pgtbl_lvl++) {
  4122df:	48 c7 45 b8 02 00 00 	mov    QWORD PTR [rbp-0x48],0x2
  4122e6:	00 
  4122e7:	49 83 fa 03          	cmp    r10,0x3
  4122eb:	0f 85 2f 01 00 00    	jne    412420 <cos_ulk_info_init+0x3c0>
	__cos_ulk_info.pg_frontier = ULK_BASE_ADDR + __thdid_alloc * sizeof(struct ulk_invstk);
  4122f1:	48 ba 00 00 00 80 7f 	movabs rdx,0x7f80000000
  4122f8:	00 00 00 
	__cos_ulk_info.toplvl = cos_ulk_pgtbl_create(ci, &__cos_ulk_info.secondlvl);
  4122fb:	4c 8b 7d a8          	mov    r15,QWORD PTR [rbp-0x58]
  4122ff:	4c 89 f8             	mov    rax,r15
  412302:	48 a3 80 4a 5a 00 00 	movabs ds:0x5a4a80,rax
  412309:	00 00 00 
	__cos_ulk_info.pg_frontier = ULK_BASE_ADDR + __thdid_alloc * sizeof(struct ulk_invstk);
  41230c:	48 a1 80 00 46 00 00 	movabs rax,ds:0x460080
  412313:	00 00 00 
  412316:	48 01 d0             	add    rax,rdx
  412319:	48 c1 e0 08          	shl    rax,0x8
  41231d:	48 a3 98 4a 5a 00 00 	movabs ds:0x5a4a98,rax
  412324:	00 00 00 
	assert(__cos_ulk_info.toplvl);
  412327:	4d 85 ff             	test   r15,r15
  41232a:	0f 84 ce fd ff ff    	je     4120fe <cos_ulk_info_init+0x9e>
}
  412330:	48 83 c4 58          	add    rsp,0x58
  412334:	5b                   	pop    rbx
  412335:	41 5c                	pop    r12
  412337:	41 5d                	pop    r13
  412339:	41 5e                	pop    r14
  41233b:	41 5f                	pop    r15
  41233d:	5d                   	pop    rbp
  41233e:	c3                   	ret    
  41233f:	48 bf b8 0d 42 00 00 	movabs rdi,0x420db8
  412346:	00 00 00 
  412349:	be 2e 00 00 00       	mov    esi,0x2e
  41234e:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  412355:	00 00 00 
  412358:	ff d0                	call   rax
	assert(ci && secondlvl);
  41235a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412361:	00 00 00 00 
  412365:	0f 0b                	ud2    
		if (__capid_captbl_check_expand(ci)) goto error;
  412367:	48 b8 50 e4 40 00 00 	movabs rax,0x40e450
  41236e:	00 00 00 
  412371:	4c 89 ff             	mov    rdi,r15
  412374:	ff d0                	call   rax
  412376:	85 c0                	test   eax,eax
  412378:	74 42                	je     4123bc <cos_ulk_info_init+0x35c>
  41237a:	49 c7 87 b0 00 00 00 	mov    QWORD PTR [r15+0xb0],0x0
  412381:	00 00 00 00 
	return __mem_bump_alloc(ci, 1, 1);
  412385:	4c 89 ff             	mov    rdi,r15
  412388:	48 b8 b0 e2 40 00 00 	movabs rax,0x40e2b0
  41238f:	00 00 00 
  412392:	ff d0                	call   rax
  412394:	48 bf a0 03 42 00 00 	movabs rdi,0x4203a0
  41239b:	00 00 00 
  41239e:	be 2e 00 00 00       	mov    esi,0x2e
  4123a3:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4123aa:	00 00 00 
  4123ad:	ff d0                	call   rax
			assert(0);
  4123af:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4123b6:	00 00 00 00 
  4123ba:	0f 0b                	ud2    
        __asm__ __volatile__("lock " PS_FAA_STR
  4123bc:	b8 04 00 00 00       	mov    eax,0x4
  4123c1:	f0 49 0f c1 47 18    	lock xadd QWORD PTR [r15+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  4123c7:	49 89 47 38          	mov    QWORD PTR [r15+0x38],rax
  4123cb:	e9 22 fe ff ff       	jmp    4121f2 <cos_ulk_info_init+0x192>
  4123d0:	48 bf d0 03 42 00 00 	movabs rdi,0x4203d0
  4123d7:	00 00 00 
  4123da:	be 2e 00 00 00       	mov    esi,0x2e
  4123df:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4123e6:	00 00 00 
  4123e9:	ff d0                	call   rax
				assert(0); /* race? */
  4123eb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4123f2:	00 00 00 00 
  4123f6:	0f 0b                	ud2    
  4123f8:	48 bf 70 03 42 00 00 	movabs rdi,0x420370
  4123ff:	00 00 00 
  412402:	be 2e 00 00 00       	mov    esi,0x2e
  412407:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  41240e:	00 00 00 
  412411:	ff d0                	call   rax
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  412413:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41241a:	00 00 00 00 
  41241e:	0f 0b                	ud2    
  412420:	48 8b 45 b0          	mov    rax,QWORD PTR [rbp-0x50]
  412424:	e9 4a fd ff ff       	jmp    412173 <cos_ulk_info_init+0x113>
  412429:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000412430 <cos_comp_alloc_with>:

int
cos_comp_alloc_with(struct cos_compinfo *ci, compcap_t comp, u32_t lid, captblcap_t ctc, pgtblcap_t ptc, vaddr_t entry, prot_domain_t protdom)
{
  412430:	f3 0f 1e fa          	endbr64 
  412434:	55                   	push   rbp
  412435:	41 89 d3             	mov    r11d,edx
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_COMPACTIVATE, comp, (ctc << 16) | ptc, ((unsigned long)lid << 32) | protdom, entry)) return 1;
  412438:	48 c1 e1 10          	shl    rcx,0x10
{
  41243c:	49 89 f2             	mov    r10,rsi
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_COMPACTIVATE, comp, (ctc << 16) | ptc, ((unsigned long)lid << 32) | protdom, entry)) return 1;
  41243f:	48 89 ce             	mov    rsi,rcx
{
  412442:	4c 89 ca             	mov    rdx,r9
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_COMPACTIVATE, comp, (ctc << 16) | ptc, ((unsigned long)lid << 32) | protdom, entry)) return 1;
  412445:	4c 09 c6             	or     rsi,r8
{
  412448:	48 89 e5             	mov    rbp,rsp
  41244b:	41 54                	push   r12
  41244d:	53                   	push   rbx
  41244e:	4c 89 d3             	mov    rbx,r10
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_COMPACTIVATE, comp, (ctc << 16) | ptc, ((unsigned long)lid << 32) | protdom, entry)) return 1;
  412451:	48 8b 47 08          	mov    rax,QWORD PTR [rdi+0x8]
  412455:	8b 4d 10             	mov    ecx,DWORD PTR [rbp+0x10]
  412458:	4c 89 df             	mov    rdi,r11
  41245b:	48 c1 e7 20          	shl    rdi,0x20
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  41245f:	c1 e0 10             	shl    eax,0x10
  412462:	48 09 cf             	or     rdi,rcx
	__asm__ __volatile__(
  412465:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
	cap_no += op;
  412469:	05 0d 00 01 00       	add    eax,0x1000d
	__asm__ __volatile__(
  41246e:	48 89 29             	mov    QWORD PTR [rcx],rbp
  412471:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  412475:	48 89 cd             	mov    rbp,rcx
  412478:	49 b8 90 24 41 00 00 	movabs r8,0x412490
  41247f:	00 00 00 
  412482:	0f 05                	syscall 
  412484:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  412488:	eb 0d                	jmp    412497 <cos_comp_alloc_with+0x67>
  41248a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  412490:	b9 00 00 00 00       	mov    ecx,0x0
  412495:	eb 05                	jmp    41249c <cos_comp_alloc_with+0x6c>
  412497:	b9 01 00 00 00       	mov    ecx,0x1
  41249c:	5d                   	pop    rbp
  41249d:	5c                   	pop    rsp
  41249e:	85 c0                	test   eax,eax
  4124a0:	0f 95 c0             	setne  al

	return 0;
}
  4124a3:	5b                   	pop    rbx
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_COMPACTIVATE, comp, (ctc << 16) | ptc, ((unsigned long)lid << 32) | protdom, entry)) return 1;
  4124a4:	0f b6 c0             	movzx  eax,al
}
  4124a7:	41 5c                	pop    r12
  4124a9:	5d                   	pop    rbp
  4124aa:	c3                   	ret    
  4124ab:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000004124b0 <cos_comp_alloc>:

compcap_t
cos_comp_alloc(struct cos_compinfo *ci, captblcap_t ctc, pgtblcap_t ptc, vaddr_t entry, prot_domain_t protdom)
{
  4124b0:	f3 0f 1e fa          	endbr64 
	return livenessid_frontier++;
  4124b4:	48 b8 c0 00 46 00 00 	movabs rax,0x4600c0
  4124bb:	00 00 00 
{
  4124be:	55                   	push   rbp
  4124bf:	49 89 d1             	mov    r9,rdx
  4124c2:	48 89 e5             	mov    rbp,rsp
  4124c5:	41 57                	push   r15
  4124c7:	41 56                	push   r14
  4124c9:	41 55                	push   r13
  4124cb:	41 54                	push   r12
  4124cd:	53                   	push   rbx
  4124ce:	48 83 ec 28          	sub    rsp,0x28
	return livenessid_frontier++;
  4124d2:	44 8b 10             	mov    r10d,DWORD PTR [rax]
  4124d5:	41 8d 52 01          	lea    edx,[r10+0x1]
  4124d9:	89 10                	mov    DWORD PTR [rax],edx
	capid_t cap;
	u32_t   lid = livenessid_bump_alloc();

	printd("cos_comp_alloc\n");

	assert(ci && ctc && ptc && lid);
  4124db:	48 85 ff             	test   rdi,rdi
  4124de:	0f 84 6e 01 00 00    	je     412652 <cos_comp_alloc+0x1a2>
  4124e4:	49 89 f7             	mov    r15,rsi
  4124e7:	48 85 f6             	test   rsi,rsi
  4124ea:	0f 84 62 01 00 00    	je     412652 <cos_comp_alloc+0x1a2>
  4124f0:	4d 85 c9             	test   r9,r9
  4124f3:	0f 84 59 01 00 00    	je     412652 <cos_comp_alloc+0x1a2>
  4124f9:	45 85 d2             	test   r10d,r10d
  4124fc:	49 89 cd             	mov    r13,rcx
  4124ff:	49 89 fc             	mov    r12,rdi
        __asm__ __volatile__("lock " PS_CAS_STR
  412502:	be 01 00 00 00       	mov    esi,0x1
  412507:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  41250a:	48 8d 97 b0 00 00 00 	lea    rdx,[rdi+0xb0]
        __asm__ __volatile__("lock " PS_CAS_STR
  412511:	31 c9                	xor    ecx,ecx
  412513:	84 c0                	test   al,al
  412515:	0f 85 37 01 00 00    	jne    412652 <cos_comp_alloc+0x1a2>
  41251b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  412520:	48 89 c8             	mov    rax,rcx
  412523:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  412528:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  41252b:	84 c0                	test   al,al
  41252d:	74 f1                	je     412520 <cos_comp_alloc+0x70>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  41252f:	4d 8b 74 24 38       	mov    r14,QWORD PTR [r12+0x38]
  412534:	41 83 e6 03          	and    r14d,0x3
  412538:	0f 84 c2 00 00 00    	je     412600 <cos_comp_alloc+0x150>
        __asm__ __volatile__("lock " PS_FAA_STR
  41253e:	bb 04 00 00 00       	mov    ebx,0x4
  412543:	f0 49 0f c1 5c 24 38 	lock xadd QWORD PTR [r12+0x38],rbx
{ l->o = 0; }
  41254a:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  412551:	00 00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  412556:	49 89 de             	mov    r14,rbx

	cap = __capid_bump_alloc(ci, CAP_COMP);
	if (!cap) return 0;
  412559:	48 85 db             	test   rbx,rbx
  41255c:	74 5c                	je     4125ba <cos_comp_alloc+0x10a>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_COMPACTIVATE, comp, (ctc << 16) | ptc, ((unsigned long)lid << 32) | protdom, entry)) return 1;
  41255e:	49 8b 44 24 08       	mov    rax,QWORD PTR [r12+0x8]
  412563:	49 c1 e7 10          	shl    r15,0x10
  412567:	4c 89 d7             	mov    rdi,r10
  41256a:	45 89 c0             	mov    r8d,r8d
  41256d:	4c 89 fe             	mov    rsi,r15
  412570:	48 c1 e7 20          	shl    rdi,0x20
  412574:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  412578:	4c 89 ea             	mov    rdx,r13
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  41257b:	c1 e0 10             	shl    eax,0x10
  41257e:	4c 09 ce             	or     rsi,r9
  412581:	4c 09 c7             	or     rdi,r8
	cap_no += op;
  412584:	05 0d 00 01 00       	add    eax,0x1000d
	__asm__ __volatile__(
  412589:	48 89 29             	mov    QWORD PTR [rcx],rbp
  41258c:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  412590:	48 89 cd             	mov    rbp,rcx
  412593:	49 b8 a8 25 41 00 00 	movabs r8,0x4125a8
  41259a:	00 00 00 
  41259d:	0f 05                	syscall 
  41259f:	90                   	nop
  4125a0:	eb 0d                	jmp    4125af <cos_comp_alloc+0xff>
  4125a2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4125a8:	b9 00 00 00 00       	mov    ecx,0x0
  4125ad:	eb 05                	jmp    4125b4 <cos_comp_alloc+0x104>
  4125af:	b9 01 00 00 00       	mov    ecx,0x1
  4125b4:	5d                   	pop    rbp
  4125b5:	5c                   	pop    rsp
  4125b6:	85 c0                	test   eax,eax
  4125b8:	75 16                	jne    4125d0 <cos_comp_alloc+0x120>
	if (cos_comp_alloc_with(ci, cap, lid, ctc, ptc, entry, protdom)) BUG();

	return cap;
}
  4125ba:	48 83 c4 28          	add    rsp,0x28
  4125be:	4c 89 f0             	mov    rax,r14
  4125c1:	5b                   	pop    rbx
  4125c2:	41 5c                	pop    r12
  4125c4:	41 5d                	pop    r13
  4125c6:	41 5e                	pop    r14
  4125c8:	41 5f                	pop    r15
  4125ca:	5d                   	pop    rbp
  4125cb:	c3                   	ret    
  4125cc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  4125d0:	48 bf 48 0e 42 00 00 	movabs rdi,0x420e48
  4125d7:	00 00 00 
  4125da:	be 1c 00 00 00       	mov    esi,0x1c
  4125df:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4125e6:	00 00 00 
  4125e9:	ff d0                	call   rax
	if (cos_comp_alloc_with(ci, cap, lid, ctc, ptc, entry, protdom)) BUG();
  4125eb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4125f2:	00 00 00 00 
  4125f6:	0f 0b                	ud2    
  4125f8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4125ff:	00 
  412600:	44 89 45 b8          	mov    DWORD PTR [rbp-0x48],r8d
		if (__capid_captbl_check_expand(ci)) goto error;
  412604:	4c 89 e7             	mov    rdi,r12
  412607:	48 b8 50 e4 40 00 00 	movabs rax,0x40e450
  41260e:	00 00 00 
  412611:	4c 89 4d b0          	mov    QWORD PTR [rbp-0x50],r9
  412615:	44 89 55 bc          	mov    DWORD PTR [rbp-0x44],r10d
  412619:	ff d0                	call   rax
  41261b:	44 8b 55 bc          	mov    r10d,DWORD PTR [rbp-0x44]
  41261f:	4c 8b 4d b0          	mov    r9,QWORD PTR [rbp-0x50]
  412623:	85 c0                	test   eax,eax
  412625:	44 8b 45 b8          	mov    r8d,DWORD PTR [rbp-0x48]
  412629:	75 16                	jne    412641 <cos_comp_alloc+0x191>
        __asm__ __volatile__("lock " PS_FAA_STR
  41262b:	b8 04 00 00 00       	mov    eax,0x4
  412630:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  412637:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  41263c:	e9 fd fe ff ff       	jmp    41253e <cos_comp_alloc+0x8e>
{ l->o = 0; }
  412641:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  412648:	00 00 00 00 00 
	if (!cap) return 0;
  41264d:	e9 68 ff ff ff       	jmp    4125ba <cos_comp_alloc+0x10a>
  412652:	48 bf 18 0e 42 00 00 	movabs rdi,0x420e18
  412659:	00 00 00 
  41265c:	be 2f 00 00 00       	mov    esi,0x2f
  412661:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  412668:	00 00 00 
  41266b:	ff d0                	call   rax
	assert(ci && ctc && ptc && lid);
  41266d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412674:	00 00 00 00 
  412678:	0f 0b                	ud2    
  41267a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000412680 <cos_comp_alloc_shared>:

int
cos_comp_alloc_shared(struct cos_compinfo *ci, pgtblcap_t ptc, vaddr_t entry, struct cos_compinfo *ci_resources, prot_domain_t protdom)
{
  412680:	f3 0f 1e fa          	endbr64 
  412684:	55                   	push   rbp
  412685:	48 89 e5             	mov    rbp,rsp
  412688:	41 57                	push   r15
  41268a:	49 89 f7             	mov    r15,rsi
  41268d:	41 56                	push   r14
  41268f:	41 55                	push   r13
  412691:	41 54                	push   r12
  412693:	53                   	push   rbx
  412694:	48 83 ec 28          	sub    rsp,0x28
	compcap_t   compc;
	captblcap_t ctc = ci->captbl_cap;
  412698:	48 8b 77 08          	mov    rsi,QWORD PTR [rdi+0x8]

	printd("cos_compinfo_alloc_shared\n");
	assert(ptc);
  41269c:	4d 85 ff             	test   r15,r15
  41269f:	0f 84 a6 01 00 00    	je     41284b <cos_comp_alloc_shared+0x1cb>
	assert(ctc);
  4126a5:	48 85 f6             	test   rsi,rsi
  4126a8:	0f 84 c5 01 00 00    	je     412873 <cos_comp_alloc_shared+0x1f3>
	return livenessid_frontier++;
  4126ae:	48 b8 c0 00 46 00 00 	movabs rax,0x4600c0
  4126b5:	00 00 00 
  4126b8:	49 89 d6             	mov    r14,rdx
  4126bb:	49 89 cc             	mov    r12,rcx
  4126be:	8b 10                	mov    edx,DWORD PTR [rax]
  4126c0:	8d 4a 01             	lea    ecx,[rdx+0x1]
  4126c3:	89 08                	mov    DWORD PTR [rax],ecx
	assert(ci && ctc && ptc && lid);
  4126c5:	4d 85 e4             	test   r12,r12
  4126c8:	0f 84 55 01 00 00    	je     412823 <cos_comp_alloc_shared+0x1a3>
  4126ce:	49 89 fd             	mov    r13,rdi
{ while (!ps_cas(&l->o, 0, 1)) ; }
  4126d1:	49 8d 8c 24 b0 00 00 	lea    rcx,[r12+0xb0]
  4126d8:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  4126d9:	41 ba 01 00 00 00    	mov    r10d,0x1
  4126df:	45 31 c9             	xor    r9d,r9d
  4126e2:	85 d2                	test   edx,edx
  4126e4:	0f 84 39 01 00 00    	je     412823 <cos_comp_alloc_shared+0x1a3>
  4126ea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4126f0:	4c 89 c8             	mov    rax,r9
  4126f3:	f0 4c 0f b1 11       	lock cmpxchg QWORD PTR [rcx],r10
  4126f8:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  4126fb:	84 c0                	test   al,al
  4126fd:	74 f1                	je     4126f0 <cos_comp_alloc_shared+0x70>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  4126ff:	41 f6 44 24 38 03    	test   BYTE PTR [r12+0x38],0x3
  412705:	0f 84 d5 00 00 00    	je     4127e0 <cos_comp_alloc_shared+0x160>
        __asm__ __volatile__("lock " PS_FAA_STR
  41270b:	bb 04 00 00 00       	mov    ebx,0x4
  412710:	f0 49 0f c1 5c 24 38 	lock xadd QWORD PTR [r12+0x38],rbx
        return inc;
  412717:	66 48 0f 6e c3       	movq   xmm0,rbx
  41271c:	66 49 0f 6e cf       	movq   xmm1,r15
{ l->o = 0; }
  412721:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  412728:	00 00 00 00 00 
  41272d:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
	if (!cap) return 0;
  412731:	48 85 db             	test   rbx,rbx
  412734:	0f 84 6d 01 00 00    	je     4128a7 <cos_comp_alloc_shared+0x227>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_COMPACTIVATE, comp, (ctc << 16) | ptc, ((unsigned long)lid << 32) | protdom, entry)) return 1;
  41273a:	49 8b 44 24 08       	mov    rax,QWORD PTR [r12+0x8]
  41273f:	48 c1 e2 20          	shl    rdx,0x20
  412743:	48 c1 e6 10          	shl    rsi,0x10
  412747:	45 89 c0             	mov    r8d,r8d
  41274a:	48 89 d7             	mov    rdi,rdx
  41274d:	4c 09 fe             	or     rsi,r15
  412750:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  412754:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  412757:	c1 e0 10             	shl    eax,0x10
  41275a:	4c 09 c7             	or     rdi,r8
	cap_no += op;
  41275d:	05 0d 00 01 00       	add    eax,0x1000d
	__asm__ __volatile__(
  412762:	48 89 29             	mov    QWORD PTR [rcx],rbp
  412765:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  412769:	48 89 cd             	mov    rbp,rcx
  41276c:	49 b8 80 27 41 00 00 	movabs r8,0x412780
  412773:	00 00 00 
  412776:	0f 05                	syscall 
  412778:	eb 0d                	jmp    412787 <cos_comp_alloc_shared+0x107>
  41277a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  412780:	b9 00 00 00 00       	mov    ecx,0x0
  412785:	eb 05                	jmp    41278c <cos_comp_alloc_shared+0x10c>
  412787:	b9 01 00 00 00       	mov    ecx,0x1
  41278c:	5d                   	pop    rbp
  41278d:	5c                   	pop    rsp
  41278e:	85 c0                	test   eax,eax
  412790:	75 1e                	jne    4127b0 <cos_comp_alloc_shared+0x130>
	compc = cos_comp_alloc(ci_resources, ctc, ptc, entry, protdom);
	assert(compc);

	ci->comp_cap_shared = compc;
  412792:	41 0f 11 85 c8 00 00 	movups XMMWORD PTR [r13+0xc8],xmm0
  412799:	00 
	ci->pgtbl_cap_shared = ptc;

	return 0;
}
  41279a:	48 83 c4 28          	add    rsp,0x28
  41279e:	31 c0                	xor    eax,eax
  4127a0:	5b                   	pop    rbx
  4127a1:	41 5c                	pop    r12
  4127a3:	41 5d                	pop    r13
  4127a5:	41 5e                	pop    r14
  4127a7:	41 5f                	pop    r15
  4127a9:	5d                   	pop    rbp
  4127aa:	c3                   	ret    
  4127ab:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  4127b0:	48 bf 48 0e 42 00 00 	movabs rdi,0x420e48
  4127b7:	00 00 00 
  4127ba:	be 1c 00 00 00       	mov    esi,0x1c
  4127bf:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4127c6:	00 00 00 
  4127c9:	ff d0                	call   rax
	if (cos_comp_alloc_with(ci, cap, lid, ctc, ptc, entry, protdom)) BUG();
  4127cb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4127d2:	00 00 00 00 
  4127d6:	0f 0b                	ud2    
  4127d8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4127df:	00 
  4127e0:	44 89 45 b0          	mov    DWORD PTR [rbp-0x50],r8d
		if (__capid_captbl_check_expand(ci)) goto error;
  4127e4:	4c 89 e7             	mov    rdi,r12
  4127e7:	48 b8 50 e4 40 00 00 	movabs rax,0x40e450
  4127ee:	00 00 00 
  4127f1:	89 55 b4             	mov    DWORD PTR [rbp-0x4c],edx
  4127f4:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
  4127f8:	ff d0                	call   rax
  4127fa:	48 8b 75 b8          	mov    rsi,QWORD PTR [rbp-0x48]
  4127fe:	8b 55 b4             	mov    edx,DWORD PTR [rbp-0x4c]
  412801:	85 c0                	test   eax,eax
  412803:	44 8b 45 b0          	mov    r8d,DWORD PTR [rbp-0x50]
  412807:	0f 85 8e 00 00 00    	jne    41289b <cos_comp_alloc_shared+0x21b>
        __asm__ __volatile__("lock " PS_FAA_STR
  41280d:	b8 04 00 00 00       	mov    eax,0x4
  412812:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  412819:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  41281e:	e9 e8 fe ff ff       	jmp    41270b <cos_comp_alloc_shared+0x8b>
  412823:	48 bf 18 0e 42 00 00 	movabs rdi,0x420e18
  41282a:	00 00 00 
  41282d:	be 2f 00 00 00       	mov    esi,0x2f
  412832:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  412839:	00 00 00 
  41283c:	ff d0                	call   rax
	assert(ci && ctc && ptc && lid);
  41283e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412845:	00 00 00 00 
  412849:	0f 0b                	ud2    
  41284b:	48 bf 68 0e 42 00 00 	movabs rdi,0x420e68
  412852:	00 00 00 
  412855:	be 2f 00 00 00       	mov    esi,0x2f
  41285a:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  412861:	00 00 00 
  412864:	ff d0                	call   rax
	assert(ptc);
  412866:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41286d:	00 00 00 00 
  412871:	0f 0b                	ud2    
  412873:	48 bf 98 0e 42 00 00 	movabs rdi,0x420e98
  41287a:	00 00 00 
  41287d:	be 2f 00 00 00       	mov    esi,0x2f
  412882:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  412889:	00 00 00 
  41288c:	ff d0                	call   rax
	assert(ctc);
  41288e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412895:	00 00 00 00 
  412899:	0f 0b                	ud2    
{ l->o = 0; }
  41289b:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  4128a2:	00 00 00 00 00 
  4128a7:	48 bf c8 0e 42 00 00 	movabs rdi,0x420ec8
  4128ae:	00 00 00 
  4128b1:	be 2f 00 00 00       	mov    esi,0x2f
  4128b6:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4128bd:	00 00 00 
  4128c0:	ff d0                	call   rax
	assert(compc);
  4128c2:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4128c9:	00 00 00 00 
  4128cd:	0f 0b                	ud2    
  4128cf:	90                   	nop

00000000004128d0 <cos_compinfo_alloc>:
}

int
cos_compinfo_alloc(struct cos_compinfo *ci, vaddr_t heap_ptr, capid_t cap_frontier, vaddr_t entry,
                   struct cos_compinfo *ci_resources, prot_domain_t protdom)
{
  4128d0:	f3 0f 1e fa          	endbr64 
  4128d4:	55                   	push   rbp
	vaddr_t     last_page;
	word_t      pgtbl_lvl;
	u8_t        mem_type = PGTBL_TYPE_DEF;
	word_t      pgtbl_lvl_flag = 0;

	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  4128d5:	b8 01 00 00 80       	mov    eax,0x80000001
{
  4128da:	48 89 e5             	mov    rbp,rsp
  4128dd:	41 57                	push   r15
  4128df:	41 56                	push   r14
  4128e1:	49 89 fe             	mov    r14,rdi
  4128e4:	41 55                	push   r13
  4128e6:	4d 89 c5             	mov    r13,r8
  4128e9:	41 54                	push   r12
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  4128eb:	41 bc 00 00 00 00    	mov    r12d,0x0
{
  4128f1:	53                   	push   rbx
  4128f2:	48 89 f3             	mov    rbx,rsi
  4128f5:	48 83 ec 38          	sub    rsp,0x38
  4128f9:	48 89 55 a8          	mov    QWORD PTR [rbp-0x58],rdx
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  4128fd:	80 bf d8 00 00 00 01 	cmp    BYTE PTR [rdi+0xd8],0x1
		pgtbl_lvl_flag = PGTBL_LVL_FLAG_VM;
	}

	printd("cos_compinfo_alloc\n");

	ptc = cos_pgtbl_alloc(ci_resources, mem_type);
  412904:	4c 89 c7             	mov    rdi,r8
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  412907:	ba 01 00 00 00       	mov    edx,0x1
  41290c:	40 0f 94 c6          	sete   sil
{
  412910:	48 89 4d c8          	mov    QWORD PTR [rbp-0x38],rcx
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  412914:	48 0f 45 c2          	cmovne rax,rdx
  412918:	ba 02 00 00 00       	mov    edx,0x2
{
  41291d:	44 89 4d c4          	mov    DWORD PTR [rbp-0x3c],r9d
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  412921:	40 0f b6 f6          	movzx  esi,sil
  412925:	48 89 45 b8          	mov    QWORD PTR [rbp-0x48],rax
  412929:	b8 02 00 00 80       	mov    eax,0x80000002
  41292e:	48 0f 45 c2          	cmovne rax,rdx
  412932:	48 89 45 b0          	mov    QWORD PTR [rbp-0x50],rax
  412936:	b8 00 00 00 80       	mov    eax,0x80000000
  41293b:	4c 0f 44 e0          	cmove  r12,rax
	ptc = cos_pgtbl_alloc(ci_resources, mem_type);
  41293f:	48 b8 90 1b 41 00 00 	movabs rax,0x411b90
  412946:	00 00 00 
  412949:	ff d0                	call   rax
	assert(ptc);
  41294b:	48 85 c0             	test   rax,rax
  41294e:	0f 84 3c 01 00 00    	je     412a90 <cos_compinfo_alloc+0x1c0>
  412954:	49 89 c7             	mov    r15,rax
	ctc = cos_captbl_alloc(ci_resources);
  412957:	4c 89 ef             	mov    rdi,r13
  41295a:	48 b8 f0 19 41 00 00 	movabs rax,0x4119f0
  412961:	00 00 00 
  412964:	ff d0                	call   rax
	assert(ctc);
  412966:	48 85 c0             	test   rax,rax
  412969:	0f 84 49 01 00 00    	je     412ab8 <cos_compinfo_alloc+0x1e8>
	compc = cos_comp_alloc(ci_resources, ctc, ptc, entry, protdom);
  41296f:	48 8b 4d c8          	mov    rcx,QWORD PTR [rbp-0x38]
  412973:	48 89 c6             	mov    rsi,rax
  412976:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
  41297a:	4c 89 fa             	mov    rdx,r15
  41297d:	44 8b 45 c4          	mov    r8d,DWORD PTR [rbp-0x3c]
  412981:	4c 89 ef             	mov    rdi,r13
  412984:	48 b8 b0 24 41 00 00 	movabs rax,0x4124b0
  41298b:	00 00 00 
  41298e:	ff d0                	call   rax
	assert(compc);
  412990:	4c 8b 55 c8          	mov    r10,QWORD PTR [rbp-0x38]
  412994:	48 85 c0             	test   rax,rax
	compc = cos_comp_alloc(ci_resources, ctc, ptc, entry, protdom);
  412997:	48 89 c1             	mov    rcx,rax
	assert(compc);
  41299a:	0f 84 40 01 00 00    	je     412ae0 <cos_compinfo_alloc+0x210>

	cos_compinfo_init(ci, ptc, ctc, compc, heap_ptr, cap_frontier, ci_resources);
  4129a0:	48 83 ec 08          	sub    rsp,0x8
  4129a4:	49 89 d8             	mov    r8,rbx
  4129a7:	4c 89 d2             	mov    rdx,r10
  4129aa:	4c 8b 4d a8          	mov    r9,QWORD PTR [rbp-0x58]
  4129ae:	41 55                	push   r13
  4129b0:	4c 89 fe             	mov    rsi,r15
  4129b3:	4c 89 f7             	mov    rdi,r14
  4129b6:	48 b8 f0 f2 40 00 00 	movabs rax,0x40f2f0
  4129bd:	00 00 00 

	ci->mi.second_lvl_pgtbl_cap  = __bump_mem_expand_intern(__compinfo_metacap(ci), ci->pgtbl_cap, heap_ptr, 0, 0 | pgtbl_lvl_flag);
  4129c0:	49 bd 30 ef 40 00 00 	movabs r13,0x40ef30
  4129c7:	00 00 00 
	cos_compinfo_init(ci, ptc, ctc, compc, heap_ptr, cap_frontier, ci_resources);
  4129ca:	ff d0                	call   rax
	ci->mi.second_lvl_pgtbl_cap  = __bump_mem_expand_intern(__compinfo_metacap(ci), ci->pgtbl_cap, heap_ptr, 0, 0 | pgtbl_lvl_flag);
  4129cc:	48 89 da             	mov    rdx,rbx
  4129cf:	31 c9                	xor    ecx,ecx
  4129d1:	49 8b 7e 60          	mov    rdi,QWORD PTR [r14+0x60]
  4129d5:	49 8b 36             	mov    rsi,QWORD PTR [r14]
  4129d8:	4d 89 e0             	mov    r8,r12
  4129db:	41 ff d5             	call   r13
  4129de:	66 48 0f 6e cb       	movq   xmm1,rbx
  4129e3:	66 48 0f 6e c0       	movq   xmm0,rax

	/* 
	 * This is to make sure that "the address below vas_frontier has been allocated, 
	 * follow the assumption we put in cos_vasfrontier_init()"
	 */
	last_page = round_to_page(ci->vas_frontier - 1);
  4129e8:	49 8b 46 40          	mov    rax,QWORD PTR [r14+0x40]
	ci->mi.second_lvl_pgtbl_cap  = __bump_mem_expand_intern(__compinfo_metacap(ci), ci->pgtbl_cap, heap_ptr, 0, 0 | pgtbl_lvl_flag);
  4129ec:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
	last_page = round_to_page(ci->vas_frontier - 1);
  4129f0:	48 8d 50 ff          	lea    rdx,[rax-0x1]
	ci->mi.second_lvl_pgtbl_cap  = __bump_mem_expand_intern(__compinfo_metacap(ci), ci->pgtbl_cap, heap_ptr, 0, 0 | pgtbl_lvl_flag);
  4129f4:	41 0f 11 86 a0 00 00 	movups XMMWORD PTR [r14+0xa0],xmm0
  4129fb:	00 
		return round_up_to_pgt0_page(vaddr);
  4129fc:	48 b8 ff ff ff ff 7f 	movabs rax,0x7fffffffff
  412a03:	00 00 00 
	last_page = round_to_page(ci->vas_frontier - 1);
  412a06:	48 81 e2 00 f0 ff ff 	and    rdx,0xfffffffffffff000
		return round_up_to_pgt0_page(vaddr);
  412a0d:	48 01 c3             	add    rbx,rax
  412a10:	48 01 d0             	add    rax,rdx

	/* If previous page is in a different second level pagetable, need to allocate */
	if (cos_pgtbl_round_up_to_page(0, last_page) != cos_pgtbl_round_up_to_page(0, heap_ptr)) {
  412a13:	48 31 c3             	xor    rbx,rax
  412a16:	58                   	pop    rax
  412a17:	59                   	pop    rcx
  412a18:	48 b8 00 00 00 00 80 	movabs rax,0xffffff8000000000
  412a1f:	ff ff ff 
  412a22:	48 85 c3             	test   rbx,rax
  412a25:	75 49                	jne    412a70 <cos_compinfo_alloc+0x1a0>

	}

	/* Allocate the rest of the levels */
	for (pgtbl_lvl = 1; pgtbl_lvl < COS_PGTBL_DEPTH - 1; pgtbl_lvl++) {
		__bump_mem_expand_intern(__compinfo_metacap(ci), ptc, round_to_page(ci->vas_frontier - 1), 0, pgtbl_lvl | pgtbl_lvl_flag);	
  412a27:	49 8b 7e 60          	mov    rdi,QWORD PTR [r14+0x60]
  412a2b:	4c 8b 45 b8          	mov    r8,QWORD PTR [rbp-0x48]
  412a2f:	4c 89 fe             	mov    rsi,r15
  412a32:	31 c9                	xor    ecx,ecx
  412a34:	41 ff d5             	call   r13
  412a37:	49 8b 46 40          	mov    rax,QWORD PTR [r14+0x40]
  412a3b:	49 8b 7e 60          	mov    rdi,QWORD PTR [r14+0x60]
  412a3f:	4c 89 fe             	mov    rsi,r15
  412a42:	4c 8b 45 b0          	mov    r8,QWORD PTR [rbp-0x50]
  412a46:	31 c9                	xor    ecx,ecx
  412a48:	48 8d 50 ff          	lea    rdx,[rax-0x1]
  412a4c:	48 81 e2 00 f0 ff ff 	and    rdx,0xfffffffffffff000
  412a53:	41 ff d5             	call   r13
	}

	return 0;
}
  412a56:	48 8d 65 d8          	lea    rsp,[rbp-0x28]
  412a5a:	31 c0                	xor    eax,eax
  412a5c:	5b                   	pop    rbx
  412a5d:	41 5c                	pop    r12
  412a5f:	41 5d                	pop    r13
  412a61:	41 5e                	pop    r14
  412a63:	41 5f                	pop    r15
  412a65:	5d                   	pop    rbp
  412a66:	c3                   	ret    
  412a67:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  412a6e:	00 00 
		__bump_mem_expand_intern(__compinfo_metacap(ci), ptc, round_to_page(ci->vas_frontier - 1), 0, 0 | pgtbl_lvl_flag);
  412a70:	49 8b 7e 60          	mov    rdi,QWORD PTR [r14+0x60]
  412a74:	4d 89 e0             	mov    r8,r12
  412a77:	31 c9                	xor    ecx,ecx
  412a79:	4c 89 fe             	mov    rsi,r15
  412a7c:	41 ff d5             	call   r13
		__bump_mem_expand_intern(__compinfo_metacap(ci), ptc, round_to_page(ci->vas_frontier - 1), 0, pgtbl_lvl | pgtbl_lvl_flag);	
  412a7f:	49 8b 46 40          	mov    rax,QWORD PTR [r14+0x40]
  412a83:	48 8d 50 ff          	lea    rdx,[rax-0x1]
  412a87:	48 81 e2 00 f0 ff ff 	and    rdx,0xfffffffffffff000
  412a8e:	eb 97                	jmp    412a27 <cos_compinfo_alloc+0x157>
  412a90:	48 bf f8 0e 42 00 00 	movabs rdi,0x420ef8
  412a97:	00 00 00 
  412a9a:	be 2f 00 00 00       	mov    esi,0x2f
  412a9f:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  412aa6:	00 00 00 
  412aa9:	ff d0                	call   rax
	assert(ptc);
  412aab:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412ab2:	00 00 00 00 
  412ab6:	0f 0b                	ud2    
  412ab8:	48 bf 28 0f 42 00 00 	movabs rdi,0x420f28
  412abf:	00 00 00 
  412ac2:	be 2f 00 00 00       	mov    esi,0x2f
  412ac7:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  412ace:	00 00 00 
  412ad1:	ff d0                	call   rax
	assert(ctc);
  412ad3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412ada:	00 00 00 00 
  412ade:	0f 0b                	ud2    
  412ae0:	48 bf 58 0f 42 00 00 	movabs rdi,0x420f58
  412ae7:	00 00 00 
  412aea:	be 2f 00 00 00       	mov    esi,0x2f
  412aef:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  412af6:	00 00 00 
  412af9:	ff d0                	call   rax
	assert(compc);
  412afb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412b02:	00 00 00 00 
  412b06:	0f 0b                	ud2    
  412b08:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  412b0f:	00 

0000000000412b10 <cos_sinv_alloc>:

sinvcap_t
cos_sinv_alloc(struct cos_compinfo *srcci, compcap_t dstcomp, vaddr_t entry, invtoken_t token)
{
  412b10:	f3 0f 1e fa          	endbr64 
  412b14:	55                   	push   rbp
  412b15:	48 89 e5             	mov    rbp,rsp
  412b18:	41 57                	push   r15
  412b1a:	41 56                	push   r14
  412b1c:	41 55                	push   r13
  412b1e:	41 54                	push   r12
  412b20:	53                   	push   rbx
  412b21:	48 83 ec 28          	sub    rsp,0x28
	capid_t cap;

	printd("cos_sinv_alloc\n");

	assert(srcci && dstcomp);
  412b25:	48 85 ff             	test   rdi,rdi
  412b28:	0f 84 43 01 00 00    	je     412c71 <cos_sinv_alloc+0x161>
  412b2e:	49 89 f7             	mov    r15,rsi
  412b31:	48 85 f6             	test   rsi,rsi
  412b34:	0f 84 37 01 00 00    	je     412c71 <cos_sinv_alloc+0x161>
  412b3a:	49 89 fc             	mov    r12,rdi
  412b3d:	49 89 d5             	mov    r13,rdx
  412b40:	49 89 ce             	mov    r14,rcx
	missing_captbl_node_expand(srcci);
  412b43:	48 b8 40 fa 40 00 00 	movabs rax,0x40fa40
  412b4a:	00 00 00 
  412b4d:	ff d0                	call   rax
{ while (!ps_cas(&l->o, 0, 1)) ; }
  412b4f:	49 8d 8c 24 b0 00 00 	lea    rcx,[r12+0xb0]
  412b56:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  412b57:	be 01 00 00 00       	mov    esi,0x1
  412b5c:	31 d2                	xor    edx,edx
  412b5e:	66 90                	xchg   ax,ax
  412b60:	48 89 d0             	mov    rax,rdx
  412b63:	f0 48 0f b1 31       	lock cmpxchg QWORD PTR [rcx],rsi
  412b68:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  412b6b:	84 c0                	test   al,al
  412b6d:	74 f1                	je     412b60 <cos_sinv_alloc+0x50>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  412b6f:	4d 8b 54 24 38       	mov    r10,QWORD PTR [r12+0x38]
  412b74:	41 83 e2 03          	and    r10d,0x3
  412b78:	0f 84 82 00 00 00    	je     412c00 <cos_sinv_alloc+0xf0>
        __asm__ __volatile__("lock " PS_FAA_STR
  412b7e:	bb 04 00 00 00       	mov    ebx,0x4
  412b83:	f0 49 0f c1 5c 24 38 	lock xadd QWORD PTR [r12+0x38],rbx
{ l->o = 0; }
  412b8a:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  412b91:	00 00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  412b96:	49 89 da             	mov    r10,rbx
	cap = __capid_bump_alloc(srcci, CAP_COMP);
	if (!cap) return 0;
  412b99:	48 85 db             	test   rbx,rbx
  412b9c:	74 4c                	je     412bea <cos_sinv_alloc+0xda>
	if (call_cap_op(srcci->captbl_cap, CAPTBL_OP_SINVACTIVATE, cap, dstcomp, entry, token)) BUG();
  412b9e:	49 8b 44 24 08       	mov    rax,QWORD PTR [r12+0x8]
  412ba3:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  412ba7:	4c 89 fe             	mov    rsi,r15
  412baa:	4c 89 ef             	mov    rdi,r13
  412bad:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  412bb0:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  412bb3:	05 0f 00 01 00       	add    eax,0x1000f
	__asm__ __volatile__(
  412bb8:	48 89 29             	mov    QWORD PTR [rcx],rbp
  412bbb:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  412bbf:	48 89 cd             	mov    rbp,rcx
  412bc2:	49 b8 d8 2b 41 00 00 	movabs r8,0x412bd8
  412bc9:	00 00 00 
  412bcc:	0f 05                	syscall 
  412bce:	66 90                	xchg   ax,ax
  412bd0:	eb 0d                	jmp    412bdf <cos_sinv_alloc+0xcf>
  412bd2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  412bd8:	b9 00 00 00 00       	mov    ecx,0x0
  412bdd:	eb 05                	jmp    412be4 <cos_sinv_alloc+0xd4>
  412bdf:	b9 01 00 00 00       	mov    ecx,0x1
  412be4:	5d                   	pop    rbp
  412be5:	5c                   	pop    rsp
  412be6:	85 c0                	test   eax,eax
  412be8:	75 4e                	jne    412c38 <cos_sinv_alloc+0x128>

	return cap;
}
  412bea:	48 83 c4 28          	add    rsp,0x28
  412bee:	4c 89 d0             	mov    rax,r10
  412bf1:	5b                   	pop    rbx
  412bf2:	41 5c                	pop    r12
  412bf4:	41 5d                	pop    r13
  412bf6:	41 5e                	pop    r14
  412bf8:	41 5f                	pop    r15
  412bfa:	5d                   	pop    rbp
  412bfb:	c3                   	ret    
  412bfc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  412c00:	4c 89 55 b8          	mov    QWORD PTR [rbp-0x48],r10
		if (__capid_captbl_check_expand(ci)) goto error;
  412c04:	4c 89 e7             	mov    rdi,r12
  412c07:	48 b8 50 e4 40 00 00 	movabs rax,0x40e450
  412c0e:	00 00 00 
  412c11:	ff d0                	call   rax
  412c13:	4c 8b 55 b8          	mov    r10,QWORD PTR [rbp-0x48]
  412c17:	85 c0                	test   eax,eax
  412c19:	75 45                	jne    412c60 <cos_sinv_alloc+0x150>
        __asm__ __volatile__("lock " PS_FAA_STR
  412c1b:	b8 04 00 00 00       	mov    eax,0x4
  412c20:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  412c27:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  412c2c:	e9 4d ff ff ff       	jmp    412b7e <cos_sinv_alloc+0x6e>
  412c31:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  412c38:	48 bf b8 0f 42 00 00 	movabs rdi,0x420fb8
  412c3f:	00 00 00 
  412c42:	be 1c 00 00 00       	mov    esi,0x1c
  412c47:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  412c4e:	00 00 00 
  412c51:	ff d0                	call   rax
	if (call_cap_op(srcci->captbl_cap, CAPTBL_OP_SINVACTIVATE, cap, dstcomp, entry, token)) BUG();
  412c53:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412c5a:	00 00 00 00 
  412c5e:	0f 0b                	ud2    
{ l->o = 0; }
  412c60:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  412c67:	00 00 00 00 00 
	if (!cap) return 0;
  412c6c:	e9 79 ff ff ff       	jmp    412bea <cos_sinv_alloc+0xda>
  412c71:	48 bf 88 0f 42 00 00 	movabs rdi,0x420f88
  412c78:	00 00 00 
  412c7b:	be 2f 00 00 00       	mov    esi,0x2f
  412c80:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  412c87:	00 00 00 
  412c8a:	ff d0                	call   rax
	assert(srcci && dstcomp);
  412c8c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412c93:	00 00 00 00 
  412c97:	0f 0b                	ud2    
  412c99:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000412ca0 <cos_arcv_alloc>:
 * arcvcap: the rcv * endpoint that is the scheduler to be activated
 *          when the thread blocks on this endpoint.
 */
arcvcap_t
cos_arcv_alloc(struct cos_compinfo *ci, thdcap_t thdcap, tcap_t tcapcap, compcap_t compcap, arcvcap_t arcvcap)
{
  412ca0:	f3 0f 1e fa          	endbr64 
  412ca4:	55                   	push   rbp
  412ca5:	48 89 e5             	mov    rbp,rsp
  412ca8:	41 57                	push   r15
  412caa:	41 56                	push   r14
  412cac:	41 55                	push   r13
  412cae:	41 54                	push   r12
  412cb0:	53                   	push   rbx
  412cb1:	48 83 ec 28          	sub    rsp,0x28
	capid_t cap;
	int ret;

	assert(ci && thdcap && tcapcap && compcap);
  412cb5:	48 85 ff             	test   rdi,rdi
  412cb8:	0f 84 63 01 00 00    	je     412e21 <cos_arcv_alloc+0x181>
  412cbe:	48 85 f6             	test   rsi,rsi
  412cc1:	0f 84 5a 01 00 00    	je     412e21 <cos_arcv_alloc+0x181>
  412cc7:	48 85 d2             	test   rdx,rdx
  412cca:	0f 84 51 01 00 00    	je     412e21 <cos_arcv_alloc+0x181>
  412cd0:	48 85 c9             	test   rcx,rcx
  412cd3:	49 89 cd             	mov    r13,rcx
  412cd6:	49 89 fc             	mov    r12,rdi
  412cd9:	4d 89 c6             	mov    r14,r8
  412cdc:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  412cdf:	48 8d 8f b0 00 00 00 	lea    rcx,[rdi+0xb0]
        __asm__ __volatile__("lock " PS_CAS_STR
  412ce6:	41 ba 01 00 00 00    	mov    r10d,0x1
  412cec:	45 31 c9             	xor    r9d,r9d
  412cef:	84 c0                	test   al,al
  412cf1:	0f 85 2a 01 00 00    	jne    412e21 <cos_arcv_alloc+0x181>
  412cf7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  412cfe:	00 00 
  412d00:	4c 89 c8             	mov    rax,r9
  412d03:	f0 4c 0f b1 11       	lock cmpxchg QWORD PTR [rcx],r10
  412d08:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  412d0b:	84 c0                	test   al,al
  412d0d:	74 f1                	je     412d00 <cos_arcv_alloc+0x60>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  412d0f:	4d 8b 7c 24 38       	mov    r15,QWORD PTR [r12+0x38]
  412d14:	41 83 e7 03          	and    r15d,0x3
  412d18:	0f 84 8a 00 00 00    	je     412da8 <cos_arcv_alloc+0x108>
        __asm__ __volatile__("lock " PS_FAA_STR
  412d1e:	bb 04 00 00 00       	mov    ebx,0x4
  412d23:	f0 49 0f c1 5c 24 38 	lock xadd QWORD PTR [r12+0x38],rbx
{ l->o = 0; }
  412d2a:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  412d31:	00 00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  412d36:	49 89 df             	mov    r15,rbx

	printd("arcv_alloc: tcap cap %d\n", (int)tcapcap);

	cap = __capid_bump_alloc(ci, CAP_ARCV);
	if (!cap) return 0;
  412d39:	48 85 db             	test   rbx,rbx
  412d3c:	74 54                	je     412d92 <cos_arcv_alloc+0xf2>
	if ((ret = call_cap_op(ci->captbl_cap, CAPTBL_OP_ARCVACTIVATE, cap, thdcap | (tcapcap << 16), compcap, arcvcap))) BUG();
  412d3e:	49 8b 44 24 08       	mov    rax,QWORD PTR [r12+0x8]
  412d43:	48 c1 e2 10          	shl    rdx,0x10
  412d47:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  412d4b:	4c 89 ef             	mov    rdi,r13
  412d4e:	48 09 d6             	or     rsi,rdx
  412d51:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  412d54:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  412d57:	05 15 00 01 00       	add    eax,0x10015
	__asm__ __volatile__(
  412d5c:	48 89 29             	mov    QWORD PTR [rcx],rbp
  412d5f:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  412d63:	48 89 cd             	mov    rbp,rcx
  412d66:	49 b8 80 2d 41 00 00 	movabs r8,0x412d80
  412d6d:	00 00 00 
  412d70:	0f 05                	syscall 
  412d72:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  412d78:	eb 0d                	jmp    412d87 <cos_arcv_alloc+0xe7>
  412d7a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  412d80:	b9 00 00 00 00       	mov    ecx,0x0
  412d85:	eb 05                	jmp    412d8c <cos_arcv_alloc+0xec>
  412d87:	b9 01 00 00 00       	mov    ecx,0x1
  412d8c:	5d                   	pop    rbp
  412d8d:	5c                   	pop    rsp
  412d8e:	85 c0                	test   eax,eax
  412d90:	75 56                	jne    412de8 <cos_arcv_alloc+0x148>

	return cap;
}
  412d92:	48 83 c4 28          	add    rsp,0x28
  412d96:	4c 89 f8             	mov    rax,r15
  412d99:	5b                   	pop    rbx
  412d9a:	41 5c                	pop    r12
  412d9c:	41 5d                	pop    r13
  412d9e:	41 5e                	pop    r14
  412da0:	41 5f                	pop    r15
  412da2:	5d                   	pop    rbp
  412da3:	c3                   	ret    
  412da4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  412da8:	48 89 55 b0          	mov    QWORD PTR [rbp-0x50],rdx
		if (__capid_captbl_check_expand(ci)) goto error;
  412dac:	4c 89 e7             	mov    rdi,r12
  412daf:	48 b8 50 e4 40 00 00 	movabs rax,0x40e450
  412db6:	00 00 00 
  412db9:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
  412dbd:	ff d0                	call   rax
  412dbf:	48 8b 75 b8          	mov    rsi,QWORD PTR [rbp-0x48]
  412dc3:	48 8b 55 b0          	mov    rdx,QWORD PTR [rbp-0x50]
  412dc7:	85 c0                	test   eax,eax
  412dc9:	75 45                	jne    412e10 <cos_arcv_alloc+0x170>
        __asm__ __volatile__("lock " PS_FAA_STR
  412dcb:	b8 04 00 00 00       	mov    eax,0x4
  412dd0:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  412dd7:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  412ddc:	e9 3d ff ff ff       	jmp    412d1e <cos_arcv_alloc+0x7e>
  412de1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  412de8:	48 bf 08 10 42 00 00 	movabs rdi,0x421008
  412def:	00 00 00 
  412df2:	be 1c 00 00 00       	mov    esi,0x1c
  412df7:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  412dfe:	00 00 00 
  412e01:	ff d0                	call   rax
	if ((ret = call_cap_op(ci->captbl_cap, CAPTBL_OP_ARCVACTIVATE, cap, thdcap | (tcapcap << 16), compcap, arcvcap))) BUG();
  412e03:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412e0a:	00 00 00 00 
  412e0e:	0f 0b                	ud2    
{ l->o = 0; }
  412e10:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  412e17:	00 00 00 00 00 
	if (!cap) return 0;
  412e1c:	e9 71 ff ff ff       	jmp    412d92 <cos_arcv_alloc+0xf2>
  412e21:	48 bf d8 0f 42 00 00 	movabs rdi,0x420fd8
  412e28:	00 00 00 
  412e2b:	be 2f 00 00 00       	mov    esi,0x2f
  412e30:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  412e37:	00 00 00 
  412e3a:	ff d0                	call   rax
	assert(ci && thdcap && tcapcap && compcap);
  412e3c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412e43:	00 00 00 00 
  412e47:	0f 0b                	ud2    
  412e49:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000412e50 <cos_asnd_alloc>:

asndcap_t
cos_asnd_alloc(struct cos_compinfo *ci, arcvcap_t arcvcap, captblcap_t ctcap)
{
  412e50:	f3 0f 1e fa          	endbr64 
  412e54:	55                   	push   rbp
  412e55:	48 89 e5             	mov    rbp,rsp
  412e58:	41 57                	push   r15
  412e5a:	41 56                	push   r14
  412e5c:	49 89 d6             	mov    r14,rdx
  412e5f:	41 55                	push   r13
  412e61:	41 54                	push   r12
  412e63:	53                   	push   rbx
  412e64:	48 83 ec 18          	sub    rsp,0x18
	capid_t cap;

	assert(ci && arcvcap && ctcap);
  412e68:	48 85 f6             	test   rsi,rsi
  412e6b:	0f 94 c0             	sete   al
  412e6e:	48 85 d2             	test   rdx,rdx
  412e71:	0f 94 c2             	sete   dl
  412e74:	08 d0                	or     al,dl
  412e76:	0f 85 2a 01 00 00    	jne    412fa6 <cos_asnd_alloc+0x156>
  412e7c:	48 85 ff             	test   rdi,rdi
  412e7f:	49 89 fc             	mov    r12,rdi
  412e82:	49 89 f5             	mov    r13,rsi
        __asm__ __volatile__("lock " PS_CAS_STR
  412e85:	41 b8 01 00 00 00    	mov    r8d,0x1
  412e8b:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  412e8e:	48 8d 97 b0 00 00 00 	lea    rdx,[rdi+0xb0]
        __asm__ __volatile__("lock " PS_CAS_STR
  412e95:	31 c9                	xor    ecx,ecx
  412e97:	84 c0                	test   al,al
  412e99:	0f 85 07 01 00 00    	jne    412fa6 <cos_asnd_alloc+0x156>
  412e9f:	90                   	nop
  412ea0:	48 89 c8             	mov    rax,rcx
  412ea3:	f0 4c 0f b1 02       	lock cmpxchg QWORD PTR [rdx],r8
  412ea8:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  412eab:	84 c0                	test   al,al
  412ead:	74 f1                	je     412ea0 <cos_asnd_alloc+0x50>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  412eaf:	4d 8b 7c 24 38       	mov    r15,QWORD PTR [r12+0x38]
  412eb4:	41 83 e7 03          	and    r15d,0x3
  412eb8:	0f 84 82 00 00 00    	je     412f40 <cos_asnd_alloc+0xf0>
        __asm__ __volatile__("lock " PS_FAA_STR
  412ebe:	bb 04 00 00 00       	mov    ebx,0x4
  412ec3:	f0 49 0f c1 5c 24 38 	lock xadd QWORD PTR [r12+0x38],rbx
{ l->o = 0; }
  412eca:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  412ed1:	00 00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  412ed6:	49 89 df             	mov    r15,rbx

	cap = __capid_bump_alloc(ci, CAP_ASND);
	if (!cap) return 0;
  412ed9:	48 85 db             	test   rbx,rbx
  412edc:	74 4c                	je     412f2a <cos_asnd_alloc+0xda>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_ASNDACTIVATE, cap, ctcap, arcvcap, 0)) BUG();
  412ede:	49 8b 44 24 08       	mov    rax,QWORD PTR [r12+0x8]
  412ee3:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  412ee7:	31 d2                	xor    edx,edx
  412ee9:	4c 89 f6             	mov    rsi,r14
  412eec:	4c 89 ef             	mov    rdi,r13
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  412eef:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  412ef2:	05 13 00 01 00       	add    eax,0x10013
	__asm__ __volatile__(
  412ef7:	48 89 29             	mov    QWORD PTR [rcx],rbp
  412efa:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  412efe:	48 89 cd             	mov    rbp,rcx
  412f01:	49 b8 18 2f 41 00 00 	movabs r8,0x412f18
  412f08:	00 00 00 
  412f0b:	0f 05                	syscall 
  412f0d:	0f 1f 00             	nop    DWORD PTR [rax]
  412f10:	eb 0d                	jmp    412f1f <cos_asnd_alloc+0xcf>
  412f12:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  412f18:	b9 00 00 00 00       	mov    ecx,0x0
  412f1d:	eb 05                	jmp    412f24 <cos_asnd_alloc+0xd4>
  412f1f:	b9 01 00 00 00       	mov    ecx,0x1
  412f24:	5d                   	pop    rbp
  412f25:	5c                   	pop    rsp
  412f26:	85 c0                	test   eax,eax
  412f28:	75 46                	jne    412f70 <cos_asnd_alloc+0x120>

	return cap;
}
  412f2a:	48 83 c4 18          	add    rsp,0x18
  412f2e:	4c 89 f8             	mov    rax,r15
  412f31:	5b                   	pop    rbx
  412f32:	41 5c                	pop    r12
  412f34:	41 5d                	pop    r13
  412f36:	41 5e                	pop    r14
  412f38:	41 5f                	pop    r15
  412f3a:	5d                   	pop    rbp
  412f3b:	c3                   	ret    
  412f3c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  412f40:	48 b8 50 e4 40 00 00 	movabs rax,0x40e450
  412f47:	00 00 00 
  412f4a:	4c 89 e7             	mov    rdi,r12
  412f4d:	ff d0                	call   rax
  412f4f:	85 c0                	test   eax,eax
  412f51:	75 45                	jne    412f98 <cos_asnd_alloc+0x148>
        __asm__ __volatile__("lock " PS_FAA_STR
  412f53:	b8 04 00 00 00       	mov    eax,0x4
  412f58:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  412f5f:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
  412f64:	e9 55 ff ff ff       	jmp    412ebe <cos_asnd_alloc+0x6e>
  412f69:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  412f70:	48 bf 58 10 42 00 00 	movabs rdi,0x421058
  412f77:	00 00 00 
  412f7a:	be 1c 00 00 00       	mov    esi,0x1c
  412f7f:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  412f86:	00 00 00 
  412f89:	ff d0                	call   rax
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_ASNDACTIVATE, cap, ctcap, arcvcap, 0)) BUG();
  412f8b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412f92:	00 00 00 00 
  412f96:	0f 0b                	ud2    
{ l->o = 0; }
  412f98:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  412f9f:	00 00 00 00 00 
	if (!cap) return 0;
  412fa4:	eb 84                	jmp    412f2a <cos_asnd_alloc+0xda>
  412fa6:	48 bf 28 10 42 00 00 	movabs rdi,0x421028
  412fad:	00 00 00 
  412fb0:	be 2f 00 00 00       	mov    esi,0x2f
  412fb5:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  412fbc:	00 00 00 
  412fbf:	ff d0                	call   rax
	assert(ci && arcvcap && ctcap);
  412fc1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412fc8:	00 00 00 00 
  412fcc:	0f 0b                	ud2    
  412fce:	66 90                	xchg   ax,ax

0000000000412fd0 <cos_hw_alloc>:
 * TODO: bitmap must be a subset of existing one.
 *       but there is no such check now, violates access control policy.
 */
hwcap_t
cos_hw_alloc(struct cos_compinfo *ci, u32_t bitmap)
{
  412fd0:	f3 0f 1e fa          	endbr64 
  412fd4:	55                   	push   rbp
  412fd5:	48 89 e5             	mov    rbp,rsp
  412fd8:	41 56                	push   r14
  412fda:	41 55                	push   r13
  412fdc:	41 54                	push   r12
  412fde:	53                   	push   rbx
  412fdf:	48 83 ec 10          	sub    rsp,0x10
	capid_t cap;

	assert(ci);
  412fe3:	48 85 ff             	test   rdi,rdi
  412fe6:	0f 84 22 01 00 00    	je     41310e <cos_hw_alloc+0x13e>
  412fec:	49 89 fc             	mov    r12,rdi
  412fef:	41 89 f6             	mov    r14d,esi
  412ff2:	48 8d 97 b0 00 00 00 	lea    rdx,[rdi+0xb0]
  412ff9:	31 c9                	xor    ecx,ecx
  412ffb:	41 b8 01 00 00 00    	mov    r8d,0x1
  413001:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  413008:	48 89 c8             	mov    rax,rcx
  41300b:	f0 4c 0f b1 02       	lock cmpxchg QWORD PTR [rdx],r8
  413010:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  413013:	84 c0                	test   al,al
  413015:	74 f1                	je     413008 <cos_hw_alloc+0x38>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  413017:	4d 8b 6c 24 30       	mov    r13,QWORD PTR [r12+0x30]
  41301c:	41 83 e5 03          	and    r13d,0x3
  413020:	0f 84 82 00 00 00    	je     4130a8 <cos_hw_alloc+0xd8>
        __asm__ __volatile__("lock " PS_FAA_STR
  413026:	bb 02 00 00 00       	mov    ebx,0x2
  41302b:	f0 49 0f c1 5c 24 30 	lock xadd QWORD PTR [r12+0x30],rbx
{ l->o = 0; }
  413032:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  413039:	00 00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  41303e:	49 89 dd             	mov    r13,rbx

	cap = __capid_bump_alloc(ci, CAP_HW);
	if (!cap) return 0;
  413041:	48 85 db             	test   rbx,rbx
  413044:	74 4c                	je     413092 <cos_hw_alloc+0xc2>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_HW_ACTIVATE, cap, bitmap, 0, 0)) BUG();
  413046:	49 8b 44 24 08       	mov    rax,QWORD PTR [r12+0x8]
  41304b:	31 d2                	xor    edx,edx
  41304d:	44 89 f6             	mov    esi,r14d
  413050:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  413054:	48 89 d7             	mov    rdi,rdx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  413057:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  41305a:	05 2b 00 01 00       	add    eax,0x1002b
	__asm__ __volatile__(
  41305f:	48 89 29             	mov    QWORD PTR [rcx],rbp
  413062:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  413066:	48 89 cd             	mov    rbp,rcx
  413069:	49 b8 80 30 41 00 00 	movabs r8,0x413080
  413070:	00 00 00 
  413073:	0f 05                	syscall 
  413075:	0f 1f 00             	nop    DWORD PTR [rax]
  413078:	eb 0d                	jmp    413087 <cos_hw_alloc+0xb7>
  41307a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  413080:	b9 00 00 00 00       	mov    ecx,0x0
  413085:	eb 05                	jmp    41308c <cos_hw_alloc+0xbc>
  413087:	b9 01 00 00 00       	mov    ecx,0x1
  41308c:	5d                   	pop    rbp
  41308d:	5c                   	pop    rsp
  41308e:	85 c0                	test   eax,eax
  413090:	75 46                	jne    4130d8 <cos_hw_alloc+0x108>

	return cap;
}
  413092:	48 83 c4 10          	add    rsp,0x10
  413096:	4c 89 e8             	mov    rax,r13
  413099:	5b                   	pop    rbx
  41309a:	41 5c                	pop    r12
  41309c:	41 5d                	pop    r13
  41309e:	41 5e                	pop    r14
  4130a0:	5d                   	pop    rbp
  4130a1:	c3                   	ret    
  4130a2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  4130a8:	48 b8 50 e4 40 00 00 	movabs rax,0x40e450
  4130af:	00 00 00 
  4130b2:	4c 89 e7             	mov    rdi,r12
  4130b5:	ff d0                	call   rax
  4130b7:	85 c0                	test   eax,eax
  4130b9:	75 45                	jne    413100 <cos_hw_alloc+0x130>
        __asm__ __volatile__("lock " PS_FAA_STR
  4130bb:	b8 04 00 00 00       	mov    eax,0x4
  4130c0:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  4130c7:	49 89 44 24 30       	mov    QWORD PTR [r12+0x30],rax
  4130cc:	e9 55 ff ff ff       	jmp    413026 <cos_hw_alloc+0x56>
  4130d1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  4130d8:	48 bf a8 10 42 00 00 	movabs rdi,0x4210a8
  4130df:	00 00 00 
  4130e2:	be 1c 00 00 00       	mov    esi,0x1c
  4130e7:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4130ee:	00 00 00 
  4130f1:	ff d0                	call   rax
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_HW_ACTIVATE, cap, bitmap, 0, 0)) BUG();
  4130f3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4130fa:	00 00 00 00 
  4130fe:	0f 0b                	ud2    
{ l->o = 0; }
  413100:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  413107:	00 00 00 00 00 
	if (!cap) return 0;
  41310c:	eb 84                	jmp    413092 <cos_hw_alloc+0xc2>
  41310e:	48 bf 78 10 42 00 00 	movabs rdi,0x421078
  413115:	00 00 00 
  413118:	be 2f 00 00 00       	mov    esi,0x2f
  41311d:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  413124:	00 00 00 
  413127:	ff d0                	call   rax
	assert(ci);
  413129:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413130:	00 00 00 00 
  413134:	0f 0b                	ud2    
  413136:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41313d:	00 00 00 

0000000000413140 <cos_page_bump_allocn>:

void *
cos_page_bump_allocn(struct cos_compinfo *ci, size_t sz)
{
  413140:	f3 0f 1e fa          	endbr64 
	assert(sz % PAGE_SIZE == 0);
  413144:	f7 c6 ff 0f 00 00    	test   esi,0xfff
  41314a:	75 11                	jne    41315d <cos_page_bump_allocn+0x1d>
	return (void *)__page_bump_alloc(ci, sz, PAGE_SIZE);
  41314c:	48 b8 90 ec 40 00 00 	movabs rax,0x40ec90
  413153:	00 00 00 
  413156:	ba 00 10 00 00       	mov    edx,0x1000
  41315b:	ff e0                	jmp    rax
  41315d:	48 bf c8 10 42 00 00 	movabs rdi,0x4210c8
  413164:	00 00 00 
{
  413167:	55                   	push   rbp
  413168:	be 2f 00 00 00       	mov    esi,0x2f
  41316d:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  413174:	00 00 00 
  413177:	48 89 e5             	mov    rbp,rsp
  41317a:	ff d0                	call   rax
	assert(sz % PAGE_SIZE == 0);
  41317c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413183:	00 00 00 00 
  413187:	0f 0b                	ud2    
  413189:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000413190 <cos_page_bump_allocn_aligned>:
}

void *
cos_page_bump_allocn_aligned(struct cos_compinfo *ci, size_t sz, size_t align)
{
  413190:	f3 0f 1e fa          	endbr64 
  413194:	55                   	push   rbp
  413195:	48 89 e5             	mov    rbp,rsp
	assert(sz % PAGE_SIZE == 0);
  413198:	f7 c6 ff 0f 00 00    	test   esi,0xfff
  41319e:	75 15                	jne    4131b5 <cos_page_bump_allocn_aligned+0x25>
	assert(align % PAGE_SIZE == 0);
  4131a0:	f7 c2 ff 0f 00 00    	test   edx,0xfff
  4131a6:	75 35                	jne    4131dd <cos_page_bump_allocn_aligned+0x4d>

	return (void *)__page_bump_alloc(ci, sz, align);
  4131a8:	48 b8 90 ec 40 00 00 	movabs rax,0x40ec90
  4131af:	00 00 00 
}
  4131b2:	5d                   	pop    rbp
	return (void *)__page_bump_alloc(ci, sz, align);
  4131b3:	ff e0                	jmp    rax
  4131b5:	48 bf f8 10 42 00 00 	movabs rdi,0x4210f8
  4131bc:	00 00 00 
  4131bf:	be 2f 00 00 00       	mov    esi,0x2f
  4131c4:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4131cb:	00 00 00 
  4131ce:	ff d0                	call   rax
	assert(sz % PAGE_SIZE == 0);
  4131d0:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4131d7:	00 00 00 00 
  4131db:	0f 0b                	ud2    
  4131dd:	48 bf 28 11 42 00 00 	movabs rdi,0x421128
  4131e4:	00 00 00 
  4131e7:	be 2f 00 00 00       	mov    esi,0x2f
  4131ec:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4131f3:	00 00 00 
  4131f6:	ff d0                	call   rax
	assert(align % PAGE_SIZE == 0);
  4131f8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4131ff:	00 00 00 00 
  413203:	0f 0b                	ud2    
  413205:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41320c:	00 00 00 00 

0000000000413210 <cos_page_bump_alloc>:

void *
cos_page_bump_alloc(struct cos_compinfo *ci)
{
  413210:	f3 0f 1e fa          	endbr64 
	return (void *)__page_bump_alloc(ci, sz, PAGE_SIZE);
  413214:	ba 00 10 00 00       	mov    edx,0x1000
  413219:	be 00 10 00 00       	mov    esi,0x1000
  41321e:	48 b8 90 ec 40 00 00 	movabs rax,0x40ec90
  413225:	00 00 00 
  413228:	ff e0                	jmp    rax
  41322a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000413230 <cos_cap_cpy>:

}

capid_t
cos_cap_cpy(struct cos_compinfo *dstci, struct cos_compinfo *srcci, cap_t srcctype, capid_t srccap)
{
  413230:	f3 0f 1e fa          	endbr64 
  413234:	55                   	push   rbp
  413235:	48 89 e5             	mov    rbp,rsp
  413238:	41 57                	push   r15
  41323a:	41 56                	push   r14
  41323c:	41 55                	push   r13
  41323e:	41 54                	push   r12
  413240:	53                   	push   rbx
  413241:	48 83 ec 28          	sub    rsp,0x28
	capid_t dstcap;

	assert(srcci && dstci);
  413245:	48 85 f6             	test   rsi,rsi
  413248:	0f 84 9b 01 00 00    	je     4133e9 <cos_cap_cpy+0x1b9>
  41324e:	49 89 fc             	mov    r12,rdi
  413251:	48 85 ff             	test   rdi,rdi
  413254:	0f 84 8f 01 00 00    	je     4133e9 <cos_cap_cpy+0x1b9>
  41325a:	49 89 f6             	mov    r14,rsi
  41325d:	48 89 cb             	mov    rbx,rcx
  413260:	83 fa 14             	cmp    edx,0x14
  413263:	0f 87 37 01 00 00    	ja     4133a0 <cos_cap_cpy+0x170>
  413269:	b8 01 00 00 00       	mov    eax,0x1
  41326e:	89 d1                	mov    ecx,edx
		frontier = &ci->cap64_frontier[cos_cpuid()];
  413270:	4c 8d 47 38          	lea    r8,[rdi+0x38]
		break;
  413274:	41 bf 04 00 00 00    	mov    r15d,0x4
  41327a:	48 d3 e0             	shl    rax,cl
  41327d:	a9 da 81 1f 00       	test   eax,0x1f81da
  413282:	0f 84 b8 00 00 00    	je     413340 <cos_cap_cpy+0x110>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  413288:	49 8d 94 24 b0 00 00 	lea    rdx,[r12+0xb0]
  41328f:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  413290:	be 01 00 00 00       	mov    esi,0x1
  413295:	31 c9                	xor    ecx,ecx
  413297:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41329e:	00 00 
  4132a0:	48 89 c8             	mov    rax,rcx
  4132a3:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  4132a8:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  4132ab:	84 c0                	test   al,al
  4132ad:	74 f1                	je     4132a0 <cos_cap_cpy+0x70>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  4132af:	4d 8b 28             	mov    r13,QWORD PTR [r8]
  4132b2:	41 83 e5 03          	and    r13d,0x3
  4132b6:	0f 84 a4 00 00 00    	je     413360 <cos_cap_cpy+0x130>
        __asm__ __volatile__("lock " PS_FAA_STR
  4132bc:	4c 89 f8             	mov    rax,r15
  4132bf:	f0 49 0f c1 00       	lock xadd QWORD PTR [r8],rax
{ l->o = 0; }
  4132c4:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  4132cb:	00 00 00 00 00 
        __asm__ __volatile__("lock " PS_FAA_STR
  4132d0:	49 89 c5             	mov    r13,rax

	dstcap = __capid_bump_alloc(dstci, srcctype);
	if (!dstcap) return 0;
  4132d3:	48 85 c0             	test   rax,rax
  4132d6:	74 4e                	je     413326 <cos_cap_cpy+0xf6>

	if (call_cap_op(srcci->captbl_cap, CAPTBL_OP_CPY, srccap, dstci->captbl_cap, dstcap, 0)) BUG();
  4132d8:	49 8b 46 08          	mov    rax,QWORD PTR [r14+0x8]
  4132dc:	49 8b 74 24 08       	mov    rsi,QWORD PTR [r12+0x8]
  4132e1:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  4132e5:	31 d2                	xor    edx,edx
  4132e7:	4c 89 ef             	mov    rdi,r13
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4132ea:	83 c0 01             	add    eax,0x1
  4132ed:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  4132f0:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4132f3:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4132f7:	48 89 cd             	mov    rbp,rcx
  4132fa:	49 b8 10 33 41 00 00 	movabs r8,0x413310
  413301:	00 00 00 
  413304:	0f 05                	syscall 
  413306:	66 90                	xchg   ax,ax
  413308:	eb 0d                	jmp    413317 <cos_cap_cpy+0xe7>
  41330a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  413310:	b9 00 00 00 00       	mov    ecx,0x0
  413315:	eb 05                	jmp    41331c <cos_cap_cpy+0xec>
  413317:	b9 01 00 00 00       	mov    ecx,0x1
  41331c:	5d                   	pop    rbp
  41331d:	5c                   	pop    rsp
  41331e:	85 c0                	test   eax,eax
  413320:	0f 85 8a 00 00 00    	jne    4133b0 <cos_cap_cpy+0x180>

	return dstcap;
}
  413326:	48 83 c4 28          	add    rsp,0x28
  41332a:	4c 89 e8             	mov    rax,r13
  41332d:	5b                   	pop    rbx
  41332e:	41 5c                	pop    r12
  413330:	41 5d                	pop    r13
  413332:	41 5e                	pop    r14
  413334:	41 5f                	pop    r15
  413336:	5d                   	pop    rbp
  413337:	c3                   	ret    
  413338:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41333f:	00 
  413340:	a9 24 10 00 00       	test   eax,0x1024
  413345:	75 49                	jne    413390 <cos_cap_cpy+0x160>
  413347:	f6 c4 60             	test   ah,0x60
  41334a:	74 54                	je     4133a0 <cos_cap_cpy+0x170>
		frontier = &ci->cap32_frontier[cos_cpuid()];
  41334c:	4c 8d 47 30          	lea    r8,[rdi+0x30]
		break;
  413350:	41 bf 02 00 00 00    	mov    r15d,0x2
  413356:	e9 2d ff ff ff       	jmp    413288 <cos_cap_cpy+0x58>
  41335b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  413360:	4c 89 45 b8          	mov    QWORD PTR [rbp-0x48],r8
		if (__capid_captbl_check_expand(ci)) goto error;
  413364:	4c 89 e7             	mov    rdi,r12
  413367:	48 b8 50 e4 40 00 00 	movabs rax,0x40e450
  41336e:	00 00 00 
  413371:	ff d0                	call   rax
  413373:	4c 8b 45 b8          	mov    r8,QWORD PTR [rbp-0x48]
  413377:	85 c0                	test   eax,eax
  413379:	75 5d                	jne    4133d8 <cos_cap_cpy+0x1a8>
  41337b:	b8 04 00 00 00       	mov    eax,0x4
  413380:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  413387:	49 89 00             	mov    QWORD PTR [r8],rax
  41338a:	e9 2d ff ff ff       	jmp    4132bc <cos_cap_cpy+0x8c>
  41338f:	90                   	nop
		frontier = &ci->cap16_frontier[cos_cpuid()];
  413390:	4c 8d 47 28          	lea    r8,[rdi+0x28]
		break;
  413394:	41 bf 01 00 00 00    	mov    r15d,0x1
  41339a:	e9 e9 fe ff ff       	jmp    413288 <cos_cap_cpy+0x58>
  41339f:	90                   	nop
  4133a0:	49 c7 c5 ff ff ff ff 	mov    r13,0xffffffffffffffff
  4133a7:	e9 2c ff ff ff       	jmp    4132d8 <cos_cap_cpy+0xa8>
  4133ac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  4133b0:	48 bf 88 11 42 00 00 	movabs rdi,0x421188
  4133b7:	00 00 00 
  4133ba:	be 1c 00 00 00       	mov    esi,0x1c
  4133bf:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4133c6:	00 00 00 
  4133c9:	ff d0                	call   rax
	if (call_cap_op(srcci->captbl_cap, CAPTBL_OP_CPY, srccap, dstci->captbl_cap, dstcap, 0)) BUG();
  4133cb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4133d2:	00 00 00 00 
  4133d6:	0f 0b                	ud2    
{ l->o = 0; }
  4133d8:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  4133df:	00 00 00 00 00 
	if (!dstcap) return 0;
  4133e4:	e9 3d ff ff ff       	jmp    413326 <cos_cap_cpy+0xf6>
  4133e9:	48 bf 58 11 42 00 00 	movabs rdi,0x421158
  4133f0:	00 00 00 
  4133f3:	be 2f 00 00 00       	mov    esi,0x2f
  4133f8:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4133ff:	00 00 00 
  413402:	ff d0                	call   rax
	assert(srcci && dstci);
  413404:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41340b:	00 00 00 00 
  41340f:	0f 0b                	ud2    
  413411:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  413418:	00 00 00 00 
  41341c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000413420 <cos_cap_cpy_at>:

int
cos_cap_cpy_at(struct cos_compinfo *dstci, capid_t dstcap, struct cos_compinfo *srcci, capid_t srccap)
{
  413420:	f3 0f 1e fa          	endbr64 
  413424:	55                   	push   rbp
  413425:	48 89 e5             	mov    rbp,rsp
  413428:	41 54                	push   r12
  41342a:	53                   	push   rbx
  41342b:	48 83 ec 10          	sub    rsp,0x10
	assert(srcci && dstci);
  41342f:	48 85 d2             	test   rdx,rdx
  413432:	0f 84 98 00 00 00    	je     4134d0 <cos_cap_cpy_at+0xb0>
  413438:	49 89 f8             	mov    r8,rdi
  41343b:	48 85 ff             	test   rdi,rdi
  41343e:	0f 84 8c 00 00 00    	je     4134d0 <cos_cap_cpy_at+0xb0>
  413444:	48 89 f7             	mov    rdi,rsi

	if (!dstcap) return 0;
  413447:	48 85 f6             	test   rsi,rsi
  41344a:	74 4e                	je     41349a <cos_cap_cpy_at+0x7a>

	if (call_cap_op(srcci->captbl_cap, CAPTBL_OP_CPY, srccap, dstci->captbl_cap, dstcap, 0)) BUG();
  41344c:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  413450:	48 89 cb             	mov    rbx,rcx
  413453:	49 8b 70 08          	mov    rsi,QWORD PTR [r8+0x8]
  413457:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  41345b:	31 d2                	xor    edx,edx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  41345d:	83 c0 01             	add    eax,0x1
  413460:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  413463:	48 89 29             	mov    QWORD PTR [rcx],rbp
  413466:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  41346a:	48 89 cd             	mov    rbp,rcx
  41346d:	49 b8 88 34 41 00 00 	movabs r8,0x413488
  413474:	00 00 00 
  413477:	0f 05                	syscall 
  413479:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  413480:	eb 0d                	jmp    41348f <cos_cap_cpy_at+0x6f>
  413482:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  413488:	b9 00 00 00 00       	mov    ecx,0x0
  41348d:	eb 05                	jmp    413494 <cos_cap_cpy_at+0x74>
  41348f:	b9 01 00 00 00       	mov    ecx,0x1
  413494:	5d                   	pop    rbp
  413495:	5c                   	pop    rsp
  413496:	85 c0                	test   eax,eax
  413498:	75 0e                	jne    4134a8 <cos_cap_cpy_at+0x88>

	return 0;
}
  41349a:	48 83 c4 10          	add    rsp,0x10
  41349e:	31 c0                	xor    eax,eax
  4134a0:	5b                   	pop    rbx
  4134a1:	41 5c                	pop    r12
  4134a3:	5d                   	pop    rbp
  4134a4:	c3                   	ret    
  4134a5:	0f 1f 00             	nop    DWORD PTR [rax]
  4134a8:	48 bf d8 11 42 00 00 	movabs rdi,0x4211d8
  4134af:	00 00 00 
  4134b2:	be 1c 00 00 00       	mov    esi,0x1c
  4134b7:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4134be:	00 00 00 
  4134c1:	ff d0                	call   rax
	if (call_cap_op(srcci->captbl_cap, CAPTBL_OP_CPY, srccap, dstci->captbl_cap, dstcap, 0)) BUG();
  4134c3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4134ca:	00 00 00 00 
  4134ce:	0f 0b                	ud2    
  4134d0:	48 bf a8 11 42 00 00 	movabs rdi,0x4211a8
  4134d7:	00 00 00 
  4134da:	be 2f 00 00 00       	mov    esi,0x2f
  4134df:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4134e6:	00 00 00 
  4134e9:	ff d0                	call   rax
	assert(srcci && dstci);
  4134eb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4134f2:	00 00 00 00 
  4134f6:	0f 0b                	ud2    
  4134f8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4134ff:	00 

0000000000413500 <cos_thd_switch>:

/**************** [Kernel Object Operations] ****************/

int
cos_thd_switch(thdcap_t c)
{
  413500:	f3 0f 1e fa          	endbr64 
  413504:	55                   	push   rbp
  413505:	31 d2                	xor    edx,edx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  413507:	8d 47 01             	lea    eax,[rdi+0x1]
  41350a:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  41350d:	48 89 d6             	mov    rsi,rdx
  413510:	48 89 d7             	mov    rdi,rdx
  413513:	48 89 e5             	mov    rbp,rsp
  413516:	41 54                	push   r12
  413518:	53                   	push   rbx
  413519:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  41351d:	48 89 d3             	mov    rbx,rdx
  413520:	48 89 29             	mov    QWORD PTR [rcx],rbp
  413523:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  413527:	48 89 cd             	mov    rbp,rcx
  41352a:	49 b8 40 35 41 00 00 	movabs r8,0x413540
  413531:	00 00 00 
  413534:	0f 05                	syscall 
  413536:	66 90                	xchg   ax,ax
  413538:	eb 0d                	jmp    413547 <cos_thd_switch+0x47>
  41353a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  413540:	b9 00 00 00 00       	mov    ecx,0x0
  413545:	eb 05                	jmp    41354c <cos_thd_switch+0x4c>
  413547:	b9 01 00 00 00       	mov    ecx,0x1
  41354c:	5d                   	pop    rbp
  41354d:	5c                   	pop    rsp
	return call_cap_op(c, 0, 0, 0, 0, 0);
}
  41354e:	5b                   	pop    rbx
  41354f:	41 5c                	pop    r12
  413551:	5d                   	pop    rbp
  413552:	c3                   	ret    
  413553:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41355a:	00 00 00 00 
  41355e:	66 90                	xchg   ax,ax

0000000000413560 <cos_thd_wakeup>:

int
cos_thd_wakeup(thdcap_t thd, tcap_t tc, tcap_prio_t prio, tcap_res_t res)
{
  413560:	f3 0f 1e fa          	endbr64 
  413564:	55                   	push   rbp
  413565:	49 89 fa             	mov    r10,rdi
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  413568:	c1 e6 10             	shl    esi,0x10
  41356b:	48 89 d7             	mov    rdi,rdx
	cap_no += op;
  41356e:	8d 86 2a 00 01 00    	lea    eax,[rsi+0x1002a]
	return call_cap_op(tc, CAPTBL_OP_TCAP_WAKEUP, thd, (prio << 32) >> 32, prio >> 32, res);
  413574:	48 c1 ef 20          	shr    rdi,0x20
  413578:	89 d6                	mov    esi,edx
{
  41357a:	48 89 e5             	mov    rbp,rsp
  41357d:	41 55                	push   r13
  41357f:	49 89 cd             	mov    r13,rcx
  413582:	41 54                	push   r12
	__asm__ __volatile__(
  413584:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  413588:	4c 89 ea             	mov    rdx,r13
  41358b:	53                   	push   rbx
  41358c:	4c 89 d3             	mov    rbx,r10
  41358f:	48 89 29             	mov    QWORD PTR [rcx],rbp
  413592:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  413596:	48 89 cd             	mov    rbp,rcx
  413599:	49 b8 b0 35 41 00 00 	movabs r8,0x4135b0
  4135a0:	00 00 00 
  4135a3:	0f 05                	syscall 
  4135a5:	0f 1f 00             	nop    DWORD PTR [rax]
  4135a8:	eb 0d                	jmp    4135b7 <cos_thd_wakeup+0x57>
  4135aa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4135b0:	b9 00 00 00 00       	mov    ecx,0x0
  4135b5:	eb 05                	jmp    4135bc <cos_thd_wakeup+0x5c>
  4135b7:	b9 01 00 00 00       	mov    ecx,0x1
  4135bc:	5d                   	pop    rbp
  4135bd:	5c                   	pop    rsp
}
  4135be:	5b                   	pop    rbx
  4135bf:	41 5c                	pop    r12
  4135c1:	41 5d                	pop    r13
  4135c3:	5d                   	pop    rbp
  4135c4:	c3                   	ret    
  4135c5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4135cc:	00 00 00 00 

00000000004135d0 <cos_sched_sync>:

sched_tok_t
cos_sched_sync(void)
{
  4135d0:	f3 0f 1e fa          	endbr64 
        __asm__ __volatile__("lock " PS_FAA_STR
  4135d4:	48 ba c0 4a 5a 00 00 	movabs rdx,0x5a4ac0
  4135db:	00 00 00 
  4135de:	b8 01 00 00 00       	mov    eax,0x1
  4135e3:	f0 48 0f c1 02       	lock xadd QWORD PTR [rdx],rax
	static sched_tok_t stok[NUM_CPU] CACHE_ALIGNED;

	return ps_faa((unsigned long *)&stok[cos_cpuid()], 1);
}
  4135e8:	c3                   	ret    
  4135e9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

00000000004135f0 <cos_switch>:

int
cos_switch(thdcap_t c, tcap_t tc, tcap_prio_t prio, tcap_time_t timeout, arcvcap_t rcv, sched_tok_t stok)
{
  4135f0:	f3 0f 1e fa          	endbr64 
  4135f4:	55                   	push   rbp
  4135f5:	49 89 fa             	mov    r10,rdi
  4135f8:	49 89 f3             	mov    r11,rsi
  4135fb:	4c 89 c7             	mov    rdi,r8
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4135fe:	41 83 c2 01          	add    r10d,0x1
  413602:	48 89 d6             	mov    rsi,rdx
  413605:	48 89 ca             	mov    rdx,rcx
  413608:	41 c1 e2 10          	shl    r10d,0x10
  41360c:	48 89 e5             	mov    rbp,rsp
  41360f:	41 54                	push   r12
	cap_no += op;
  413611:	43 8d 04 1a          	lea    eax,[r10+r11*1]
  413615:	53                   	push   rbx
	__asm__ __volatile__(
  413616:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
#if defined(__x86_64__)
	return call_cap_op(c, tc, stok, prio, rcv, timeout);
  41361a:	44 89 cb             	mov    ebx,r9d
  41361d:	48 89 29             	mov    QWORD PTR [rcx],rbp
  413620:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  413624:	48 89 cd             	mov    rbp,rcx
  413627:	49 b8 40 36 41 00 00 	movabs r8,0x413640
  41362e:	00 00 00 
  413631:	0f 05                	syscall 
  413633:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  413638:	eb 0d                	jmp    413647 <cos_switch+0x57>
  41363a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  413640:	b9 00 00 00 00       	mov    ecx,0x0
  413645:	eb 05                	jmp    41364c <cos_switch+0x5c>
  413647:	b9 01 00 00 00       	mov    ecx,0x1
  41364c:	5d                   	pop    rbp
  41364d:	5c                   	pop    rsp
#else
	return call_cap_op(c, (stok >> 16), tc << 16 | rcv, (prio << 32) >> 32,
	                   (((prio << 16) >> 48) << 16) | ((stok << 16) >> 16), timeout);
#endif
}
  41364e:	5b                   	pop    rbx
  41364f:	41 5c                	pop    r12
  413651:	5d                   	pop    rbp
  413652:	c3                   	ret    
  413653:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41365a:	00 00 00 00 
  41365e:	66 90                	xchg   ax,ax

0000000000413660 <cos_sched_asnd>:

int
cos_sched_asnd(asndcap_t snd, tcap_time_t timeout, arcvcap_t srcv, sched_tok_t stok)
{
  413660:	f3 0f 1e fa          	endbr64 
  413664:	55                   	push   rbp
  413665:	49 89 d2             	mov    r10,rdx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  413668:	8d 47 01             	lea    eax,[rdi+0x1]
	__asm__ __volatile__(
  41366b:	31 d2                	xor    edx,edx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  41366d:	c1 e0 10             	shl    eax,0x10
  413670:	48 89 e5             	mov    rbp,rsp
  413673:	41 55                	push   r13
  413675:	49 89 f5             	mov    r13,rsi
	return call_cap_op(snd, 0, srcv, stok, timeout, 0);
  413678:	89 ce                	mov    esi,ecx
{
  41367a:	41 54                	push   r12
	__asm__ __volatile__(
  41367c:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  413680:	4c 89 ef             	mov    rdi,r13
  413683:	53                   	push   rbx
  413684:	4c 89 d3             	mov    rbx,r10
  413687:	48 89 29             	mov    QWORD PTR [rcx],rbp
  41368a:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  41368e:	48 89 cd             	mov    rbp,rcx
  413691:	49 b8 a8 36 41 00 00 	movabs r8,0x4136a8
  413698:	00 00 00 
  41369b:	0f 05                	syscall 
  41369d:	0f 1f 00             	nop    DWORD PTR [rax]
  4136a0:	eb 0d                	jmp    4136af <cos_sched_asnd+0x4f>
  4136a2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4136a8:	b9 00 00 00 00       	mov    ecx,0x0
  4136ad:	eb 05                	jmp    4136b4 <cos_sched_asnd+0x54>
  4136af:	b9 01 00 00 00       	mov    ecx,0x1
  4136b4:	5d                   	pop    rbp
  4136b5:	5c                   	pop    rsp
}
  4136b6:	5b                   	pop    rbx
  4136b7:	41 5c                	pop    r12
  4136b9:	41 5d                	pop    r13
  4136bb:	5d                   	pop    rbp
  4136bc:	c3                   	ret    
  4136bd:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004136c0 <cos_asnd>:

int
cos_asnd(asndcap_t snd, int yield)
{
  4136c0:	f3 0f 1e fa          	endbr64 
  4136c4:	55                   	push   rbp
  4136c5:	48 63 d6             	movsxd rdx,esi
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4136c8:	8d 47 01             	lea    eax,[rdi+0x1]
	__asm__ __volatile__(
  4136cb:	31 f6                	xor    esi,esi
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4136cd:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  4136d0:	48 89 f7             	mov    rdi,rsi
  4136d3:	48 89 e5             	mov    rbp,rsp
  4136d6:	41 54                	push   r12
  4136d8:	53                   	push   rbx
  4136d9:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  4136dd:	48 89 f3             	mov    rbx,rsi
  4136e0:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4136e3:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4136e7:	48 89 cd             	mov    rbp,rcx
  4136ea:	49 b8 00 37 41 00 00 	movabs r8,0x413700
  4136f1:	00 00 00 
  4136f4:	0f 05                	syscall 
  4136f6:	66 90                	xchg   ax,ax
  4136f8:	eb 0d                	jmp    413707 <cos_asnd+0x47>
  4136fa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  413700:	b9 00 00 00 00       	mov    ecx,0x0
  413705:	eb 05                	jmp    41370c <cos_asnd+0x4c>
  413707:	b9 01 00 00 00       	mov    ecx,0x1
  41370c:	5d                   	pop    rbp
  41370d:	5c                   	pop    rsp
	return call_cap_op(snd, 0, 0, 0, 0, yield);
}
  41370e:	5b                   	pop    rbx
  41370f:	41 5c                	pop    r12
  413711:	5d                   	pop    rbp
  413712:	c3                   	ret    
  413713:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41371a:	00 00 00 00 
  41371e:	66 90                	xchg   ax,ax

0000000000413720 <cos_sched_rcv>:

int
cos_sched_rcv(arcvcap_t rcv, rcv_flags_t flags, tcap_time_t timeout,
	      int *rcvd, thdid_t *thdid, int *blocked, cycles_t *cycles, tcap_time_t *thd_timeout)
{
  413720:	f3 0f 1e fa          	endbr64 
  413724:	55                   	push   rbp
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  413725:	8d 47 01             	lea    eax,[rdi+0x1]
	__asm__ __volatile__(
  413728:	31 ff                	xor    edi,edi
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  41372a:	c1 e0 10             	shl    eax,0x10
  41372d:	48 89 e5             	mov    rbp,rsp
  413730:	41 57                	push   r15
  413732:	49 89 cf             	mov    r15,rcx
  413735:	41 56                	push   r14
	__asm__ __volatile__(
  413737:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  41373b:	4d 89 c6             	mov    r14,r8
  41373e:	41 55                	push   r13
  413740:	4d 89 cd             	mov    r13,r9
  413743:	41 54                	push   r12
  413745:	53                   	push   rbx
  413746:	89 f3                	mov    ebx,esi
  413748:	48 89 d6             	mov    rsi,rdx
  41374b:	48 89 fa             	mov    rdx,rdi
  41374e:	49 89 da             	mov    r10,rbx
  413751:	48 89 29             	mov    QWORD PTR [rcx],rbp
  413754:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  413758:	48 89 cd             	mov    rbp,rcx
  41375b:	49 b8 70 37 41 00 00 	movabs r8,0x413770
  413762:	00 00 00 
  413765:	0f 05                	syscall 
  413767:	90                   	nop
  413768:	eb 0f                	jmp    413779 <cos_sched_rcv+0x59>
  41376a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  413770:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  413777:	eb 07                	jmp    413780 <cos_sched_rcv+0x60>
  413779:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  413780:	5d                   	pop    rbp
  413781:	5c                   	pop    rsp
  413782:	48 8b 55 18          	mov    rdx,QWORD PTR [rbp+0x18]
  413786:	48 89 1a             	mov    QWORD PTR [rdx],rbx
	unsigned long cyc       = 0;
	int           ret;

	ret = call_cap_retvals_asm(rcv, 0, flags, timeout, 0, 0, &thd_state, &cyc, thd_timeout);

	*blocked = (int)(thd_state >> (sizeof(thd_state) * 8 - 1));
  413789:	48 89 f2             	mov    rdx,rsi
	*thdid   = (thdid_t)(thd_state & ((1 << (sizeof(unsigned short int) * 8)) - 1));
  41378c:	81 e6 ff ff 00 00    	and    esi,0xffff
	*blocked = (int)(thd_state >> (sizeof(thd_state) * 8 - 1));
  413792:	48 c1 ea 3f          	shr    rdx,0x3f
  413796:	41 89 55 00          	mov    DWORD PTR [r13+0x0],edx
	*cycles  = cyc;
  41379a:	48 8b 55 10          	mov    rdx,QWORD PTR [rbp+0x10]
	*thdid   = (thdid_t)(thd_state & ((1 << (sizeof(unsigned short int) * 8)) - 1));
  41379e:	49 89 36             	mov    QWORD PTR [r14],rsi
	*cycles  = cyc;
  4137a1:	48 89 3a             	mov    QWORD PTR [rdx],rdi

	if (ret >= 0 && flags & RCV_ALL_PENDING) {
  4137a4:	85 c0                	test   eax,eax
  4137a6:	78 10                	js     4137b8 <cos_sched_rcv+0x98>
  4137a8:	41 83 e2 02          	and    r10d,0x2
  4137ac:	74 0a                	je     4137b8 <cos_sched_rcv+0x98>
		*rcvd = (ret >> 1);
  4137ae:	89 c2                	mov    edx,eax
		ret &= 1;
  4137b0:	83 e0 01             	and    eax,0x1
		*rcvd = (ret >> 1);
  4137b3:	d1 fa                	sar    edx,1
  4137b5:	41 89 17             	mov    DWORD PTR [r15],edx
	}

	return ret;
}
  4137b8:	5b                   	pop    rbx
  4137b9:	41 5c                	pop    r12
  4137bb:	41 5d                	pop    r13
  4137bd:	41 5e                	pop    r14
  4137bf:	41 5f                	pop    r15
  4137c1:	5d                   	pop    rbp
  4137c2:	c3                   	ret    
  4137c3:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4137ca:	00 00 00 00 
  4137ce:	66 90                	xchg   ax,ax

00000000004137d0 <cos_rcv>:

int
cos_rcv(arcvcap_t rcv, rcv_flags_t flags, int *rcvd)
{
  4137d0:	f3 0f 1e fa          	endbr64 
  4137d4:	55                   	push   rbp
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4137d5:	8d 47 01             	lea    eax,[rdi+0x1]
	__asm__ __volatile__(
  4137d8:	31 ff                	xor    edi,edi
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4137da:	c1 e0 10             	shl    eax,0x10
  4137dd:	48 89 e5             	mov    rbp,rsp
  4137e0:	41 55                	push   r13
  4137e2:	49 89 d5             	mov    r13,rdx
	__asm__ __volatile__(
  4137e5:	48 89 fa             	mov    rdx,rdi
  4137e8:	41 54                	push   r12
  4137ea:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  4137ee:	53                   	push   rbx
  4137ef:	89 f3                	mov    ebx,esi
  4137f1:	48 89 fe             	mov    rsi,rdi
  4137f4:	49 89 da             	mov    r10,rbx
  4137f7:	48 83 ec 18          	sub    rsp,0x18
  4137fb:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4137fe:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  413802:	48 89 cd             	mov    rbp,rcx
  413805:	49 b8 20 38 41 00 00 	movabs r8,0x413820
  41380c:	00 00 00 
  41380f:	0f 05                	syscall 
  413811:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  413818:	eb 0f                	jmp    413829 <cos_rcv+0x59>
  41381a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  413820:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  413827:	eb 07                	jmp    413830 <cos_rcv+0x60>
  413829:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  413830:	5d                   	pop    rbp
  413831:	5c                   	pop    rsp
	*thdid   = (thdid_t)(thd_state & ((1 << (sizeof(unsigned short int) * 8)) - 1));
  413832:	0f b7 f6             	movzx  esi,si
	if (ret >= 0 && flags & RCV_ALL_PENDING) {
  413835:	85 c0                	test   eax,eax
  413837:	78 06                	js     41383f <cos_rcv+0x6f>
  413839:	41 83 e2 02          	and    r10d,0x2
  41383d:	75 11                	jne    413850 <cos_rcv+0x80>
	cycles_t    cyc;
	int         ret;
	tcap_time_t thd_timeout;

	ret = cos_sched_rcv(rcv, flags, 0, rcvd, &tid, &blocked, &cyc, &thd_timeout);
	assert(tid == 0);
  41383f:	48 85 f6             	test   rsi,rsi
  413842:	75 1c                	jne    413860 <cos_rcv+0x90>

	return ret;
}
  413844:	48 83 c4 18          	add    rsp,0x18
  413848:	5b                   	pop    rbx
  413849:	41 5c                	pop    r12
  41384b:	41 5d                	pop    r13
  41384d:	5d                   	pop    rbp
  41384e:	c3                   	ret    
  41384f:	90                   	nop
		*rcvd = (ret >> 1);
  413850:	89 c2                	mov    edx,eax
		ret &= 1;
  413852:	83 e0 01             	and    eax,0x1
		*rcvd = (ret >> 1);
  413855:	d1 fa                	sar    edx,1
  413857:	41 89 55 00          	mov    DWORD PTR [r13+0x0],edx
	assert(tid == 0);
  41385b:	48 85 f6             	test   rsi,rsi
  41385e:	74 e4                	je     413844 <cos_rcv+0x74>
  413860:	48 bf f8 11 42 00 00 	movabs rdi,0x4211f8
  413867:	00 00 00 
  41386a:	be 2f 00 00 00       	mov    esi,0x2f
  41386f:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  413876:	00 00 00 
  413879:	ff d0                	call   rax
  41387b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413882:	00 00 00 00 
  413886:	0f 0b                	ud2    
  413888:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41388f:	00 

0000000000413890 <cos_mem_aliasn_aligned>:

vaddr_t
cos_mem_aliasn_aligned(struct cos_compinfo *dstci, struct cos_compinfo *srcci, vaddr_t src, size_t sz, size_t align, unsigned long perm_flags)
{
  413890:	f3 0f 1e fa          	endbr64 
  413894:	55                   	push   rbp
  413895:	48 89 e5             	mov    rbp,rsp
  413898:	41 57                	push   r15
  41389a:	41 56                	push   r14
  41389c:	41 55                	push   r13
  41389e:	41 54                	push   r12
  4138a0:	53                   	push   rbx
  4138a1:	48 83 ec 28          	sub    rsp,0x28
  4138a5:	48 89 55 b0          	mov    QWORD PTR [rbp-0x50],rdx
  4138a9:	48 89 4d b8          	mov    QWORD PTR [rbp-0x48],rcx
	size_t i;
	vaddr_t dst, first_dst;

	assert(srcci && dstci);
  4138ad:	48 85 f6             	test   rsi,rsi
  4138b0:	0f 84 ff 00 00 00    	je     4139b5 <cos_mem_aliasn_aligned+0x125>
  4138b6:	49 89 fd             	mov    r13,rdi
  4138b9:	48 85 ff             	test   rdi,rdi
  4138bc:	0f 84 f3 00 00 00    	je     4139b5 <cos_mem_aliasn_aligned+0x125>
	assert(sz && (sz % PAGE_SIZE == 0));
  4138c2:	48 85 c9             	test   rcx,rcx
  4138c5:	0f 84 c2 00 00 00    	je     41398d <cos_mem_aliasn_aligned+0xfd>
  4138cb:	f7 c1 ff 0f 00 00    	test   ecx,0xfff
  4138d1:	0f 85 b6 00 00 00    	jne    41398d <cos_mem_aliasn_aligned+0xfd>
  4138d7:	4c 89 c2             	mov    rdx,r8
	assert(align % PAGE_SIZE == 0);
  4138da:	41 f7 c0 ff 0f 00 00 	test   r8d,0xfff
  4138e1:	0f 85 f6 00 00 00    	jne    4139dd <cos_mem_aliasn_aligned+0x14d>

	dst = __page_bump_valloc(dstci, sz, align);
  4138e7:	48 b8 40 ea 40 00 00 	movabs rax,0x40ea40
  4138ee:	00 00 00 
  4138f1:	49 89 f6             	mov    r14,rsi
  4138f4:	4c 89 cb             	mov    rbx,r9
  4138f7:	48 89 ce             	mov    rsi,rcx
  4138fa:	ff d0                	call   rax
  4138fc:	49 89 c7             	mov    r15,rax
	if (unlikely(!dst)) return 0;
  4138ff:	48 85 c0             	test   rax,rax
  413902:	0f 84 80 00 00 00    	je     413988 <cos_mem_aliasn_aligned+0xf8>
	first_dst = dst;

	for (i = 0; i < sz; i += PAGE_SIZE, src += PAGE_SIZE, dst += PAGE_SIZE) {
  413908:	45 31 d2             	xor    r10d,r10d
  41390b:	48 89 da             	mov    rdx,rbx
  41390e:	66 90                	xchg   ax,ax
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  413910:	41 8b 06             	mov    eax,DWORD PTR [r14]
	__asm__ __volatile__(
  413913:	48 8b 5d b0          	mov    rbx,QWORD PTR [rbp-0x50]
  413917:	4b 8d 3c 3a          	lea    rdi,[r10+r15*1]
  41391b:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  41391f:	49 8b 75 00          	mov    rsi,QWORD PTR [r13+0x0]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  413923:	83 c0 01             	add    eax,0x1
	__asm__ __volatile__(
  413926:	4c 01 d3             	add    rbx,r10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  413929:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  41392c:	48 89 29             	mov    QWORD PTR [rcx],rbp
  41392f:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  413933:	48 89 cd             	mov    rbp,rcx
  413936:	49 b8 50 39 41 00 00 	movabs r8,0x413950
  41393d:	00 00 00 
  413940:	0f 05                	syscall 
  413942:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  413948:	eb 0d                	jmp    413957 <cos_mem_aliasn_aligned+0xc7>
  41394a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  413950:	b9 00 00 00 00       	mov    ecx,0x0
  413955:	eb 05                	jmp    41395c <cos_mem_aliasn_aligned+0xcc>
  413957:	b9 01 00 00 00       	mov    ecx,0x1
  41395c:	5d                   	pop    rbp
  41395d:	5c                   	pop    rsp
		if (call_cap_op(srcci->pgtbl_cap, CAPTBL_OP_CPY, src, dstci->pgtbl_cap, dst, perm_flags)) return 0;
  41395e:	85 c0                	test   eax,eax
  413960:	75 26                	jne    413988 <cos_mem_aliasn_aligned+0xf8>
	for (i = 0; i < sz; i += PAGE_SIZE, src += PAGE_SIZE, dst += PAGE_SIZE) {
  413962:	49 81 c2 00 10 00 00 	add    r10,0x1000
  413969:	4c 39 55 b8          	cmp    QWORD PTR [rbp-0x48],r10
  41396d:	77 a1                	ja     413910 <cos_mem_aliasn_aligned+0x80>
	}

	return first_dst;
}
  41396f:	48 83 c4 28          	add    rsp,0x28
  413973:	4c 89 f8             	mov    rax,r15
  413976:	5b                   	pop    rbx
  413977:	41 5c                	pop    r12
  413979:	41 5d                	pop    r13
  41397b:	41 5e                	pop    r14
  41397d:	41 5f                	pop    r15
  41397f:	5d                   	pop    rbp
  413980:	c3                   	ret    
  413981:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	if (unlikely(!dst)) return 0;
  413988:	45 31 ff             	xor    r15d,r15d
  41398b:	eb e2                	jmp    41396f <cos_mem_aliasn_aligned+0xdf>
  41398d:	48 bf 58 12 42 00 00 	movabs rdi,0x421258
  413994:	00 00 00 
  413997:	be 2f 00 00 00       	mov    esi,0x2f
  41399c:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4139a3:	00 00 00 
  4139a6:	ff d0                	call   rax
	assert(sz && (sz % PAGE_SIZE == 0));
  4139a8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4139af:	00 00 00 00 
  4139b3:	0f 0b                	ud2    
  4139b5:	48 bf 28 12 42 00 00 	movabs rdi,0x421228
  4139bc:	00 00 00 
  4139bf:	be 2f 00 00 00       	mov    esi,0x2f
  4139c4:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4139cb:	00 00 00 
  4139ce:	ff d0                	call   rax
	assert(srcci && dstci);
  4139d0:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4139d7:	00 00 00 00 
  4139db:	0f 0b                	ud2    
  4139dd:	48 bf 88 12 42 00 00 	movabs rdi,0x421288
  4139e4:	00 00 00 
  4139e7:	be 2f 00 00 00       	mov    esi,0x2f
  4139ec:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4139f3:	00 00 00 
  4139f6:	ff d0                	call   rax
	assert(align % PAGE_SIZE == 0);
  4139f8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4139ff:	00 00 00 00 
  413a03:	0f 0b                	ud2    
  413a05:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  413a0c:	00 00 00 00 

0000000000413a10 <cos_mem_aliasn>:

vaddr_t
cos_mem_aliasn(struct cos_compinfo *dstci, struct cos_compinfo *srcci, vaddr_t src, size_t sz, unsigned long perm_flags)
{
  413a10:	f3 0f 1e fa          	endbr64 
	return cos_mem_aliasn_aligned(dstci, srcci, src, sz, PAGE_SIZE, perm_flags);
  413a14:	48 b8 90 38 41 00 00 	movabs rax,0x413890
  413a1b:	00 00 00 
  413a1e:	4d 89 c1             	mov    r9,r8
  413a21:	41 b8 00 10 00 00    	mov    r8d,0x1000
  413a27:	ff e0                	jmp    rax
  413a29:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000413a30 <cos_mem_alias>:
}

vaddr_t
cos_mem_alias(struct cos_compinfo *dstci, struct cos_compinfo *srcci, vaddr_t src, unsigned long perm_flags)
{
  413a30:	f3 0f 1e fa          	endbr64 
  413a34:	49 89 c9             	mov    r9,rcx
	return cos_mem_aliasn_aligned(dstci, srcci, src, sz, PAGE_SIZE, perm_flags);
  413a37:	41 b8 00 10 00 00    	mov    r8d,0x1000
  413a3d:	b9 00 10 00 00       	mov    ecx,0x1000
  413a42:	48 b8 90 38 41 00 00 	movabs rax,0x413890
  413a49:	00 00 00 
  413a4c:	ff e0                	jmp    rax
  413a4e:	66 90                	xchg   ax,ax

0000000000413a50 <cos_mem_alias_at>:
	return cos_mem_aliasn(dstci, srcci, src, PAGE_SIZE, perm_flags);
}

int
cos_mem_alias_at(struct cos_compinfo *dstci, vaddr_t dst, struct cos_compinfo *srcci, vaddr_t src, unsigned long perm_flags)
{
  413a50:	f3 0f 1e fa          	endbr64 
  413a54:	55                   	push   rbp
  413a55:	48 89 d0             	mov    rax,rdx
  413a58:	48 89 e5             	mov    rbp,rsp
  413a5b:	41 54                	push   r12
  413a5d:	53                   	push   rbx
  413a5e:	48 83 ec 10          	sub    rsp,0x10
	assert(srcci && dstci);
  413a62:	48 85 d2             	test   rdx,rdx
  413a65:	0f 84 8d 00 00 00    	je     413af8 <cos_mem_alias_at+0xa8>
  413a6b:	49 89 f9             	mov    r9,rdi
  413a6e:	48 85 ff             	test   rdi,rdi
  413a71:	0f 84 81 00 00 00    	je     413af8 <cos_mem_alias_at+0xa8>

	if (call_cap_op(srcci->pgtbl_cap, CAPTBL_OP_CPY, src, dstci->pgtbl_cap, dst, perm_flags)) BUG();
  413a77:	48 8b 00             	mov    rax,QWORD PTR [rax]
  413a7a:	48 89 f7             	mov    rdi,rsi
  413a7d:	48 89 cb             	mov    rbx,rcx
  413a80:	49 8b 31             	mov    rsi,QWORD PTR [r9]
  413a83:	4c 89 c2             	mov    rdx,r8
  413a86:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  413a8a:	83 c0 01             	add    eax,0x1
  413a8d:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  413a90:	48 89 29             	mov    QWORD PTR [rcx],rbp
  413a93:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  413a97:	48 89 cd             	mov    rbp,rcx
  413a9a:	49 b8 b0 3a 41 00 00 	movabs r8,0x413ab0
  413aa1:	00 00 00 
  413aa4:	0f 05                	syscall 
  413aa6:	66 90                	xchg   ax,ax
  413aa8:	eb 0d                	jmp    413ab7 <cos_mem_alias_at+0x67>
  413aaa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  413ab0:	b9 00 00 00 00       	mov    ecx,0x0
  413ab5:	eb 05                	jmp    413abc <cos_mem_alias_at+0x6c>
  413ab7:	b9 01 00 00 00       	mov    ecx,0x1
  413abc:	5d                   	pop    rbp
  413abd:	5c                   	pop    rsp
  413abe:	85 c0                	test   eax,eax
  413ac0:	75 0e                	jne    413ad0 <cos_mem_alias_at+0x80>

	return 0;
}
  413ac2:	48 83 c4 10          	add    rsp,0x10
  413ac6:	31 c0                	xor    eax,eax
  413ac8:	5b                   	pop    rbx
  413ac9:	41 5c                	pop    r12
  413acb:	5d                   	pop    rbp
  413acc:	c3                   	ret    
  413acd:	0f 1f 00             	nop    DWORD PTR [rax]
  413ad0:	48 bf e8 12 42 00 00 	movabs rdi,0x4212e8
  413ad7:	00 00 00 
  413ada:	be 1c 00 00 00       	mov    esi,0x1c
  413adf:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  413ae6:	00 00 00 
  413ae9:	ff d0                	call   rax
	if (call_cap_op(srcci->pgtbl_cap, CAPTBL_OP_CPY, src, dstci->pgtbl_cap, dst, perm_flags)) BUG();
  413aeb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413af2:	00 00 00 00 
  413af6:	0f 0b                	ud2    
  413af8:	48 bf b8 12 42 00 00 	movabs rdi,0x4212b8
  413aff:	00 00 00 
  413b02:	be 2f 00 00 00       	mov    esi,0x2f
  413b07:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  413b0e:	00 00 00 
  413b11:	ff d0                	call   rax
	assert(srcci && dstci);
  413b13:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413b1a:	00 00 00 00 
  413b1e:	0f 0b                	ud2    

0000000000413b20 <cos_mem_alias_atn>:

int
cos_mem_alias_atn(struct cos_compinfo *dstci, vaddr_t dst, struct cos_compinfo *srcci, vaddr_t src, size_t sz, unsigned long perm_flags)
{
  413b20:	f3 0f 1e fa          	endbr64 
  413b24:	55                   	push   rbp
  413b25:	48 89 e5             	mov    rbp,rsp
  413b28:	41 57                	push   r15
  413b2a:	41 56                	push   r14
  413b2c:	49 89 d6             	mov    r14,rdx
  413b2f:	41 55                	push   r13
  413b31:	41 54                	push   r12
  413b33:	53                   	push   rbx
  413b34:	48 83 ec 18          	sub    rsp,0x18
	size_t i;
	size_t npages;

	assert(srcci && dstci);
  413b38:	48 85 d2             	test   rdx,rdx
  413b3b:	0f 84 d0 00 00 00    	je     413c11 <cos_mem_alias_atn+0xf1>
  413b41:	49 89 ff             	mov    r15,rdi
  413b44:	48 85 ff             	test   rdi,rdi
  413b47:	0f 84 c4 00 00 00    	je     413c11 <cos_mem_alias_atn+0xf1>
	assert(sz % PAGE_SIZE == 0);
  413b4d:	41 f7 c0 ff 0f 00 00 	test   r8d,0xfff
  413b54:	0f 85 df 00 00 00    	jne    413c39 <cos_mem_alias_atn+0x119>

	npages = sz / PAGE_SIZE;
	for (i=0; i < npages; i++) {
  413b5a:	49 c1 e8 0c          	shr    r8,0xc
  413b5e:	0f 84 9c 00 00 00    	je     413c00 <cos_mem_alias_atn+0xe0>
  413b64:	49 89 f5             	mov    r13,rsi
  413b67:	49 c1 e0 0c          	shl    r8,0xc
  413b6b:	48 89 cb             	mov    rbx,rcx
  413b6e:	4c 89 ca             	mov    rdx,r9
  413b71:	4d 8d 14 08          	lea    r10,[r8+rcx*1]
  413b75:	49 29 cd             	sub    r13,rcx
  413b78:	eb 12                	jmp    413b8c <cos_mem_alias_atn+0x6c>
  413b7a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  413b80:	48 81 c3 00 10 00 00 	add    rbx,0x1000
  413b87:	49 39 da             	cmp    r10,rbx
  413b8a:	74 74                	je     413c00 <cos_mem_alias_atn+0xe0>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  413b8c:	41 8b 06             	mov    eax,DWORD PTR [r14]
	__asm__ __volatile__(
  413b8f:	49 8b 37             	mov    rsi,QWORD PTR [r15]
  413b92:	49 8d 7c 1d 00       	lea    rdi,[r13+rbx*1+0x0]
  413b97:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  413b9b:	83 c0 01             	add    eax,0x1
  413b9e:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  413ba1:	48 89 29             	mov    QWORD PTR [rcx],rbp
  413ba4:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  413ba8:	48 89 cd             	mov    rbp,rcx
  413bab:	49 b8 c0 3b 41 00 00 	movabs r8,0x413bc0
  413bb2:	00 00 00 
  413bb5:	0f 05                	syscall 
  413bb7:	90                   	nop
  413bb8:	eb 0d                	jmp    413bc7 <cos_mem_alias_atn+0xa7>
  413bba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  413bc0:	b9 00 00 00 00       	mov    ecx,0x0
  413bc5:	eb 05                	jmp    413bcc <cos_mem_alias_atn+0xac>
  413bc7:	b9 01 00 00 00       	mov    ecx,0x1
  413bcc:	5d                   	pop    rbp
  413bcd:	5c                   	pop    rsp
		if (call_cap_op(srcci->pgtbl_cap, CAPTBL_OP_CPY, src + i * PAGE_SIZE, dstci->pgtbl_cap, dst + i * PAGE_SIZE, perm_flags)) BUG();
  413bce:	85 c0                	test   eax,eax
  413bd0:	74 ae                	je     413b80 <cos_mem_alias_atn+0x60>
  413bd2:	48 bf 68 13 42 00 00 	movabs rdi,0x421368
  413bd9:	00 00 00 
  413bdc:	be 1c 00 00 00       	mov    esi,0x1c
  413be1:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  413be8:	00 00 00 
  413beb:	ff d0                	call   rax
  413bed:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413bf4:	00 00 00 00 
  413bf8:	0f 0b                	ud2    
  413bfa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	}

	return 0;
}
  413c00:	48 83 c4 18          	add    rsp,0x18
  413c04:	31 c0                	xor    eax,eax
  413c06:	5b                   	pop    rbx
  413c07:	41 5c                	pop    r12
  413c09:	41 5d                	pop    r13
  413c0b:	41 5e                	pop    r14
  413c0d:	41 5f                	pop    r15
  413c0f:	5d                   	pop    rbp
  413c10:	c3                   	ret    
  413c11:	48 bf 08 13 42 00 00 	movabs rdi,0x421308
  413c18:	00 00 00 
  413c1b:	be 2f 00 00 00       	mov    esi,0x2f
  413c20:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  413c27:	00 00 00 
  413c2a:	ff d0                	call   rax
	assert(srcci && dstci);
  413c2c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413c33:	00 00 00 00 
  413c37:	0f 0b                	ud2    
  413c39:	48 bf 38 13 42 00 00 	movabs rdi,0x421338
  413c40:	00 00 00 
  413c43:	be 2f 00 00 00       	mov    esi,0x2f
  413c48:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  413c4f:	00 00 00 
  413c52:	ff d0                	call   rax
	assert(sz % PAGE_SIZE == 0);
  413c54:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413c5b:	00 00 00 00 
  413c5f:	0f 0b                	ud2    
  413c61:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  413c68:	00 00 00 00 
  413c6c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000413c70 <cos_mem_remove>:

int
cos_mem_remove(pgtblcap_t pt, vaddr_t addr)
{
  413c70:	f3 0f 1e fa          	endbr64 
  413c74:	48 bf 88 13 42 00 00 	movabs rdi,0x421388
  413c7b:	00 00 00 
  413c7e:	55                   	push   rbp
  413c7f:	be 2f 00 00 00       	mov    esi,0x2f
  413c84:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  413c8b:	00 00 00 
  413c8e:	48 89 e5             	mov    rbp,rsp
  413c91:	ff d0                	call   rax
	assert(0);
  413c93:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413c9a:	00 00 00 00 
  413c9e:	0f 0b                	ud2    

0000000000413ca0 <cos_mem_move>:
	return 0;
}

vaddr_t
cos_mem_move(struct cos_compinfo *dstci, struct cos_compinfo *srcci, vaddr_t src)
{
  413ca0:	f3 0f 1e fa          	endbr64 
  413ca4:	55                   	push   rbp
  413ca5:	48 89 e5             	mov    rbp,rsp
  413ca8:	41 55                	push   r13
  413caa:	41 54                	push   r12
  413cac:	53                   	push   rbx
  413cad:	48 83 ec 18          	sub    rsp,0x18
	vaddr_t dst;

	assert(srcci && dstci);
  413cb1:	48 85 f6             	test   rsi,rsi
  413cb4:	0f 84 be 00 00 00    	je     413d78 <cos_mem_move+0xd8>
  413cba:	49 89 fc             	mov    r12,rdi
  413cbd:	48 85 ff             	test   rdi,rdi
  413cc0:	0f 84 b2 00 00 00    	je     413d78 <cos_mem_move+0xd8>

	dst = __page_bump_valloc(dstci, PAGE_SIZE, PAGE_SIZE);
  413cc6:	48 b8 40 ea 40 00 00 	movabs rax,0x40ea40
  413ccd:	00 00 00 
  413cd0:	49 89 f5             	mov    r13,rsi
  413cd3:	48 89 d3             	mov    rbx,rdx
  413cd6:	be 00 10 00 00       	mov    esi,0x1000
  413cdb:	ba 00 10 00 00       	mov    edx,0x1000
  413ce0:	ff d0                	call   rax
  413ce2:	49 89 c2             	mov    r10,rax
	if (unlikely(!dst)) return 0;
  413ce5:	48 85 c0             	test   rax,rax
  413ce8:	74 50                	je     413d3a <cos_mem_move+0x9a>

	if (call_cap_op(srcci->pgtbl_cap, CAPTBL_OP_MEMMOVE, src, dstci->pgtbl_cap, dst, 0)) BUG();
  413cea:	49 8b 45 00          	mov    rax,QWORD PTR [r13+0x0]
  413cee:	49 8b 34 24          	mov    rsi,QWORD PTR [r12]
  413cf2:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  413cf6:	31 d2                	xor    edx,edx
  413cf8:	4c 89 d7             	mov    rdi,r10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  413cfb:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  413cfe:	05 24 00 01 00       	add    eax,0x10024
	__asm__ __volatile__(
  413d03:	48 89 29             	mov    QWORD PTR [rcx],rbp
  413d06:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  413d0a:	48 89 cd             	mov    rbp,rcx
  413d0d:	49 b8 28 3d 41 00 00 	movabs r8,0x413d28
  413d14:	00 00 00 
  413d17:	0f 05                	syscall 
  413d19:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  413d20:	eb 0d                	jmp    413d2f <cos_mem_move+0x8f>
  413d22:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  413d28:	b9 00 00 00 00       	mov    ecx,0x0
  413d2d:	eb 05                	jmp    413d34 <cos_mem_move+0x94>
  413d2f:	b9 01 00 00 00       	mov    ecx,0x1
  413d34:	5d                   	pop    rbp
  413d35:	5c                   	pop    rsp
  413d36:	85 c0                	test   eax,eax
  413d38:	75 16                	jne    413d50 <cos_mem_move+0xb0>

	return dst;
}
  413d3a:	48 83 c4 18          	add    rsp,0x18
  413d3e:	4c 89 d0             	mov    rax,r10
  413d41:	5b                   	pop    rbx
  413d42:	41 5c                	pop    r12
  413d44:	41 5d                	pop    r13
  413d46:	5d                   	pop    rbp
  413d47:	c3                   	ret    
  413d48:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  413d4f:	00 
  413d50:	48 bf e8 13 42 00 00 	movabs rdi,0x4213e8
  413d57:	00 00 00 
  413d5a:	be 1c 00 00 00       	mov    esi,0x1c
  413d5f:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  413d66:	00 00 00 
  413d69:	ff d0                	call   rax
	if (call_cap_op(srcci->pgtbl_cap, CAPTBL_OP_MEMMOVE, src, dstci->pgtbl_cap, dst, 0)) BUG();
  413d6b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413d72:	00 00 00 00 
  413d76:	0f 0b                	ud2    
  413d78:	48 bf b8 13 42 00 00 	movabs rdi,0x4213b8
  413d7f:	00 00 00 
  413d82:	be 2f 00 00 00       	mov    esi,0x2f
  413d87:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  413d8e:	00 00 00 
  413d91:	ff d0                	call   rax
	assert(srcci && dstci);
  413d93:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413d9a:	00 00 00 00 
  413d9e:	0f 0b                	ud2    

0000000000413da0 <cos_mem_move_at>:

int
cos_mem_move_at(struct cos_compinfo *dstci, vaddr_t dst, struct cos_compinfo *srcci, vaddr_t src)
{
  413da0:	f3 0f 1e fa          	endbr64 
  413da4:	55                   	push   rbp
  413da5:	48 89 e5             	mov    rbp,rsp
  413da8:	41 54                	push   r12
  413daa:	53                   	push   rbx
  413dab:	48 83 ec 10          	sub    rsp,0x10
	assert(srcci && dstci);
  413daf:	48 85 d2             	test   rdx,rdx
  413db2:	0f 84 90 00 00 00    	je     413e48 <cos_mem_move_at+0xa8>
  413db8:	49 89 f8             	mov    r8,rdi
  413dbb:	48 85 ff             	test   rdi,rdi
  413dbe:	0f 84 84 00 00 00    	je     413e48 <cos_mem_move_at+0xa8>

	/* TODO */
	if (call_cap_op(srcci->pgtbl_cap, CAPTBL_OP_MEMMOVE, src, dstci->pgtbl_cap, dst, 0)) BUG();
  413dc4:	48 8b 02             	mov    rax,QWORD PTR [rdx]
  413dc7:	48 89 f7             	mov    rdi,rsi
  413dca:	48 89 cb             	mov    rbx,rcx
  413dcd:	49 8b 30             	mov    rsi,QWORD PTR [r8]
  413dd0:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  413dd4:	31 d2                	xor    edx,edx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  413dd6:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  413dd9:	05 24 00 01 00       	add    eax,0x10024
	__asm__ __volatile__(
  413dde:	48 89 29             	mov    QWORD PTR [rcx],rbp
  413de1:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  413de5:	48 89 cd             	mov    rbp,rcx
  413de8:	49 b8 00 3e 41 00 00 	movabs r8,0x413e00
  413def:	00 00 00 
  413df2:	0f 05                	syscall 
  413df4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  413df8:	eb 0d                	jmp    413e07 <cos_mem_move_at+0x67>
  413dfa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  413e00:	b9 00 00 00 00       	mov    ecx,0x0
  413e05:	eb 05                	jmp    413e0c <cos_mem_move_at+0x6c>
  413e07:	b9 01 00 00 00       	mov    ecx,0x1
  413e0c:	5d                   	pop    rbp
  413e0d:	5c                   	pop    rsp
  413e0e:	85 c0                	test   eax,eax
  413e10:	75 0e                	jne    413e20 <cos_mem_move_at+0x80>

	return 0;
}
  413e12:	48 83 c4 10          	add    rsp,0x10
  413e16:	31 c0                	xor    eax,eax
  413e18:	5b                   	pop    rbx
  413e19:	41 5c                	pop    r12
  413e1b:	5d                   	pop    rbp
  413e1c:	c3                   	ret    
  413e1d:	0f 1f 00             	nop    DWORD PTR [rax]
  413e20:	48 bf 38 14 42 00 00 	movabs rdi,0x421438
  413e27:	00 00 00 
  413e2a:	be 1c 00 00 00       	mov    esi,0x1c
  413e2f:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  413e36:	00 00 00 
  413e39:	ff d0                	call   rax
	if (call_cap_op(srcci->pgtbl_cap, CAPTBL_OP_MEMMOVE, src, dstci->pgtbl_cap, dst, 0)) BUG();
  413e3b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413e42:	00 00 00 00 
  413e46:	0f 0b                	ud2    
  413e48:	48 bf 08 14 42 00 00 	movabs rdi,0x421408
  413e4f:	00 00 00 
  413e52:	be 2f 00 00 00       	mov    esi,0x2f
  413e57:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  413e5e:	00 00 00 
  413e61:	ff d0                	call   rax
	assert(srcci && dstci);
  413e63:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413e6a:	00 00 00 00 
  413e6e:	0f 0b                	ud2    

0000000000413e70 <cos_thd_mod>:

/* TODO: generalize to modify all state */
int
cos_thd_mod(struct cos_compinfo *ci, thdcap_t tc, void *tlsaddr)
{
  413e70:	f3 0f 1e fa          	endbr64 
  413e74:	55                   	push   rbp
  413e75:	49 89 f2             	mov    r10,rsi
  413e78:	48 89 d6             	mov    rsi,rdx
  413e7b:	31 d2                	xor    edx,edx
  413e7d:	48 89 e5             	mov    rbp,rsp
  413e80:	41 54                	push   r12
  413e82:	53                   	push   rbx
  413e83:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  413e87:	4c 89 d3             	mov    rbx,r10
	return call_cap_op(ci->captbl_cap, CAPTBL_OP_THDTLSSET, tc, (word_t)tlsaddr, 0, 0);
  413e8a:	48 8b 47 08          	mov    rax,QWORD PTR [rdi+0x8]
  413e8e:	48 89 d7             	mov    rdi,rdx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  413e91:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  413e94:	05 06 00 01 00       	add    eax,0x10006
	__asm__ __volatile__(
  413e99:	48 89 29             	mov    QWORD PTR [rcx],rbp
  413e9c:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  413ea0:	48 89 cd             	mov    rbp,rcx
  413ea3:	49 b8 b8 3e 41 00 00 	movabs r8,0x413eb8
  413eaa:	00 00 00 
  413ead:	0f 05                	syscall 
  413eaf:	90                   	nop
  413eb0:	eb 0d                	jmp    413ebf <cos_thd_mod+0x4f>
  413eb2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  413eb8:	b9 00 00 00 00       	mov    ecx,0x0
  413ebd:	eb 05                	jmp    413ec4 <cos_thd_mod+0x54>
  413ebf:	b9 01 00 00 00       	mov    ecx,0x1
  413ec4:	5d                   	pop    rbp
  413ec5:	5c                   	pop    rsp
}
  413ec6:	5b                   	pop    rbx
  413ec7:	41 5c                	pop    r12
  413ec9:	5d                   	pop    rbp
  413eca:	c3                   	ret    
  413ecb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000413ed0 <cos_introspect>:

/* FIXME: problems when we got to 64 bit systems with the return value */
int
cos_introspect(struct cos_compinfo *ci, capid_t cap, unsigned long op)
{
  413ed0:	f3 0f 1e fa          	endbr64 
  413ed4:	55                   	push   rbp
  413ed5:	49 89 f2             	mov    r10,rsi
	return call_cap_op(ci->captbl_cap, CAPTBL_OP_INTROSPECT, cap, (int)op, 0, 0);
  413ed8:	48 63 f2             	movsxd rsi,edx
  413edb:	31 d2                	xor    edx,edx
{
  413edd:	48 89 e5             	mov    rbp,rsp
  413ee0:	41 54                	push   r12
  413ee2:	53                   	push   rbx
  413ee3:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  413ee7:	4c 89 d3             	mov    rbx,r10
	return call_cap_op(ci->captbl_cap, CAPTBL_OP_INTROSPECT, cap, (int)op, 0, 0);
  413eea:	48 8b 47 08          	mov    rax,QWORD PTR [rdi+0x8]
  413eee:	48 89 d7             	mov    rdi,rdx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  413ef1:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  413ef4:	05 25 00 01 00       	add    eax,0x10025
	__asm__ __volatile__(
  413ef9:	48 89 29             	mov    QWORD PTR [rcx],rbp
  413efc:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  413f00:	48 89 cd             	mov    rbp,rcx
  413f03:	49 b8 18 3f 41 00 00 	movabs r8,0x413f18
  413f0a:	00 00 00 
  413f0d:	0f 05                	syscall 
  413f0f:	90                   	nop
  413f10:	eb 0d                	jmp    413f1f <cos_introspect+0x4f>
  413f12:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  413f18:	b9 00 00 00 00       	mov    ecx,0x0
  413f1d:	eb 05                	jmp    413f24 <cos_introspect+0x54>
  413f1f:	b9 01 00 00 00       	mov    ecx,0x1
  413f24:	5d                   	pop    rbp
  413f25:	5c                   	pop    rsp
}
  413f26:	5b                   	pop    rbx
  413f27:	41 5c                	pop    r12
  413f29:	5d                   	pop    rbp
  413f2a:	c3                   	ret    
  413f2b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000413f30 <cos_tcap_alloc>:

/***************** [Kernel Tcap Operations] *****************/

tcap_t
cos_tcap_alloc(struct cos_compinfo *ci)
{
  413f30:	f3 0f 1e fa          	endbr64 
  413f34:	55                   	push   rbp
  413f35:	48 89 e5             	mov    rbp,rsp
  413f38:	41 56                	push   r14
  413f3a:	41 55                	push   r13
  413f3c:	41 54                	push   r12
  413f3e:	53                   	push   rbx
  413f3f:	48 83 ec 10          	sub    rsp,0x10
	vaddr_t kmem;
	capid_t cap;

	printd("cos_tcap_alloc\n");
	assert(ci);
  413f43:	48 85 ff             	test   rdi,rdi
  413f46:	0f 84 4c 01 00 00    	je     414098 <cos_tcap_alloc+0x168>
	return __mem_bump_alloc(ci, 1, 1);
  413f4c:	48 b8 b0 e2 40 00 00 	movabs rax,0x40e2b0
  413f53:	00 00 00 
  413f56:	49 89 fc             	mov    r12,rdi
  413f59:	ff d0                	call   rax
  413f5b:	49 89 c5             	mov    r13,rax
	if (!*kmem) return -1;
  413f5e:	48 85 c0             	test   rax,rax
  413f61:	0f 84 59 01 00 00    	je     4140c0 <cos_tcap_alloc+0x190>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  413f67:	49 8d 94 24 b0 00 00 	lea    rdx,[r12+0xb0]
  413f6e:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  413f6f:	bf 01 00 00 00       	mov    edi,0x1
  413f74:	31 c9                	xor    ecx,ecx
  413f76:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  413f7d:	00 00 00 
  413f80:	48 89 c8             	mov    rax,rcx
  413f83:	f0 48 0f b1 3a       	lock cmpxchg QWORD PTR [rdx],rdi
  413f88:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  413f8b:	84 c0                	test   al,al
  413f8d:	74 f1                	je     413f80 <cos_tcap_alloc+0x50>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  413f8f:	4d 8b 74 24 28       	mov    r14,QWORD PTR [r12+0x28]
  413f94:	41 83 e6 03          	and    r14d,0x3
  413f98:	0f 84 9a 00 00 00    	je     414038 <cos_tcap_alloc+0x108>
        __asm__ __volatile__("lock " PS_FAA_STR
  413f9e:	ba 01 00 00 00       	mov    edx,0x1
  413fa3:	f0 49 0f c1 54 24 28 	lock xadd QWORD PTR [r12+0x28],rdx
{ l->o = 0; }
  413faa:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  413fb1:	00 00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  413fb6:	49 89 d6             	mov    r14,rdx
	if (!*cap) return -1;
  413fb9:	48 85 d2             	test   rdx,rdx
  413fbc:	0f 84 fe 00 00 00    	je     4140c0 <cos_tcap_alloc+0x190>

	if (__alloc_mem_cap(ci, CAP_TCAP, &kmem, &cap)) return 0;
	/* TODO: Add cap size checking */
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_TCAP_ACTIVATE, (cap << 16) | __compinfo_metacap(ci)->mi.pgtbl_cap,
  413fc2:	49 8b 4c 24 60       	mov    rcx,QWORD PTR [r12+0x60]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  413fc7:	41 8b 44 24 08       	mov    eax,DWORD PTR [r12+0x8]
  413fcc:	48 c1 e2 10          	shl    rdx,0x10
	__asm__ __volatile__(
  413fd0:	4c 89 ee             	mov    rsi,r13
  413fd3:	48 8b 99 98 00 00 00 	mov    rbx,QWORD PTR [rcx+0x98]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  413fda:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  413fdd:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
	cap_no += op;
  413fe1:	05 26 00 01 00       	add    eax,0x10026
  413fe6:	48 09 d3             	or     rbx,rdx
	__asm__ __volatile__(
  413fe9:	31 d2                	xor    edx,edx
  413feb:	48 89 d7             	mov    rdi,rdx
  413fee:	48 89 29             	mov    QWORD PTR [rcx],rbp
  413ff1:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  413ff5:	48 89 cd             	mov    rbp,rcx
  413ff8:	49 b8 10 40 41 00 00 	movabs r8,0x414010
  413fff:	00 00 00 
  414002:	0f 05                	syscall 
  414004:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  414008:	eb 0d                	jmp    414017 <cos_tcap_alloc+0xe7>
  41400a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  414010:	b9 00 00 00 00       	mov    ecx,0x0
  414015:	eb 05                	jmp    41401c <cos_tcap_alloc+0xec>
  414017:	b9 01 00 00 00       	mov    ecx,0x1
  41401c:	5d                   	pop    rbp
  41401d:	5c                   	pop    rsp
  41401e:	85 c0                	test   eax,eax
  414020:	75 4e                	jne    414070 <cos_tcap_alloc+0x140>
	                kmem, 0, 0))
		BUG();

	return cap;
}
  414022:	48 83 c4 10          	add    rsp,0x10
  414026:	4c 89 f0             	mov    rax,r14
  414029:	5b                   	pop    rbx
  41402a:	41 5c                	pop    r12
  41402c:	41 5d                	pop    r13
  41402e:	41 5e                	pop    r14
  414030:	5d                   	pop    rbp
  414031:	c3                   	ret    
  414032:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  414038:	48 b8 50 e4 40 00 00 	movabs rax,0x40e450
  41403f:	00 00 00 
  414042:	4c 89 e7             	mov    rdi,r12
  414045:	ff d0                	call   rax
  414047:	85 c0                	test   eax,eax
  414049:	75 16                	jne    414061 <cos_tcap_alloc+0x131>
        __asm__ __volatile__("lock " PS_FAA_STR
  41404b:	b8 04 00 00 00       	mov    eax,0x4
  414050:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  414057:	49 89 44 24 28       	mov    QWORD PTR [r12+0x28],rax
  41405c:	e9 3d ff ff ff       	jmp    413f9e <cos_tcap_alloc+0x6e>
{ l->o = 0; }
  414061:	49 c7 84 24 b0 00 00 	mov    QWORD PTR [r12+0xb0],0x0
  414068:	00 00 00 00 00 
	if (!*cap) return -1;
  41406d:	eb b3                	jmp    414022 <cos_tcap_alloc+0xf2>
  41406f:	90                   	nop
  414070:	48 bf 88 14 42 00 00 	movabs rdi,0x421488
  414077:	00 00 00 
  41407a:	be 1c 00 00 00       	mov    esi,0x1c
  41407f:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  414086:	00 00 00 
  414089:	ff d0                	call   rax
		BUG();
  41408b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414092:	00 00 00 00 
  414096:	0f 0b                	ud2    
  414098:	48 bf 58 14 42 00 00 	movabs rdi,0x421458
  41409f:	00 00 00 
  4140a2:	be 2f 00 00 00       	mov    esi,0x2f
  4140a7:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4140ae:	00 00 00 
  4140b1:	ff d0                	call   rax
	assert(ci);
  4140b3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4140ba:	00 00 00 00 
  4140be:	0f 0b                	ud2    
	if (__alloc_mem_cap(ci, CAP_TCAP, &kmem, &cap)) return 0;
  4140c0:	45 31 f6             	xor    r14d,r14d
  4140c3:	e9 5a ff ff ff       	jmp    414022 <cos_tcap_alloc+0xf2>
  4140c8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4140cf:	00 

00000000004140d0 <cos_tcap_transfer>:

int
cos_tcap_transfer(arcvcap_t dst, tcap_t src, tcap_res_t res, tcap_prio_t prio)
{
  4140d0:	f3 0f 1e fa          	endbr64 
  4140d4:	55                   	push   rbp
  4140d5:	49 89 fa             	mov    r10,rdi
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4140d8:	c1 e6 10             	shl    esi,0x10
	int prio_higher = (u32_t)(prio >> 32);
	int prio_lower  = (u32_t)((prio << 32) >> 32);

	return call_cap_op(src, CAPTBL_OP_TCAP_TRANSFER, dst, res, prio_higher, prio_lower);
  4140db:	48 89 cf             	mov    rdi,rcx
	cap_no += op;
  4140de:	8d 86 27 00 01 00    	lea    eax,[rsi+0x10027]
  4140e4:	48 c1 ff 20          	sar    rdi,0x20
{
  4140e8:	48 89 e5             	mov    rbp,rsp
  4140eb:	41 55                	push   r13
  4140ed:	49 89 d5             	mov    r13,rdx
	return call_cap_op(src, CAPTBL_OP_TCAP_TRANSFER, dst, res, prio_higher, prio_lower);
  4140f0:	48 63 d1             	movsxd rdx,ecx
{
  4140f3:	41 54                	push   r12
	__asm__ __volatile__(
  4140f5:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  4140f9:	4c 89 ee             	mov    rsi,r13
  4140fc:	53                   	push   rbx
  4140fd:	4c 89 d3             	mov    rbx,r10
  414100:	48 89 29             	mov    QWORD PTR [rcx],rbp
  414103:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  414107:	48 89 cd             	mov    rbp,rcx
  41410a:	49 b8 20 41 41 00 00 	movabs r8,0x414120
  414111:	00 00 00 
  414114:	0f 05                	syscall 
  414116:	66 90                	xchg   ax,ax
  414118:	eb 0d                	jmp    414127 <cos_tcap_transfer+0x57>
  41411a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  414120:	b9 00 00 00 00       	mov    ecx,0x0
  414125:	eb 05                	jmp    41412c <cos_tcap_transfer+0x5c>
  414127:	b9 01 00 00 00       	mov    ecx,0x1
  41412c:	5d                   	pop    rbp
  41412d:	5c                   	pop    rsp
}
  41412e:	5b                   	pop    rbx
  41412f:	41 5c                	pop    r12
  414131:	41 5d                	pop    r13
  414133:	5d                   	pop    rbp
  414134:	c3                   	ret    
  414135:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41413c:	00 00 00 00 

0000000000414140 <cos_tcap_delegate>:

int
cos_tcap_delegate(asndcap_t dst, tcap_t src, tcap_res_t res, tcap_prio_t prio, tcap_deleg_flags_t flags)
{
  414140:	f3 0f 1e fa          	endbr64 
  414144:	55                   	push   rbp
  414145:	49 89 fa             	mov    r10,rdi
	u32_t yield = ((flags & TCAP_DELEG_YIELD) != 0);
  414148:	44 89 c7             	mov    edi,r8d
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  41414b:	c1 e6 10             	shl    esi,0x10
  41414e:	d1 ef                	shr    edi,1
	cap_no += op;
  414150:	8d 86 28 00 01 00    	lea    eax,[rsi+0x10028]
	/* top bit is if we are dispatching or not */
	int prio_higher = (u32_t)(prio >> 32) | (yield << ((sizeof(yield) * 8) - 1));
  414156:	c1 e7 1f             	shl    edi,0x1f
{
  414159:	48 89 e5             	mov    rbp,rsp
  41415c:	41 55                	push   r13
  41415e:	49 89 d5             	mov    r13,rdx
	int prio_higher = (u32_t)(prio >> 32) | (yield << ((sizeof(yield) * 8) - 1));
  414161:	48 89 ca             	mov    rdx,rcx
{
  414164:	41 54                	push   r12
	int prio_higher = (u32_t)(prio >> 32) | (yield << ((sizeof(yield) * 8) - 1));
  414166:	48 c1 ea 20          	shr    rdx,0x20
	__asm__ __volatile__(
  41416a:	4c 89 ee             	mov    rsi,r13
{
  41416d:	53                   	push   rbx
	int prio_higher = (u32_t)(prio >> 32) | (yield << ((sizeof(yield) * 8) - 1));
  41416e:	09 d7                	or     edi,edx
  414170:	4c 89 d3             	mov    rbx,r10
	int prio_lower  = (u32_t)((prio << 32) >> 32);

	return call_cap_op(src, CAPTBL_OP_TCAP_DELEGATE, dst, res, prio_higher, prio_lower);
  414173:	48 63 d1             	movsxd rdx,ecx
  414176:	48 63 ff             	movsxd rdi,edi
  414179:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  41417d:	48 89 29             	mov    QWORD PTR [rcx],rbp
  414180:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  414184:	48 89 cd             	mov    rbp,rcx
  414187:	49 b8 a0 41 41 00 00 	movabs r8,0x4141a0
  41418e:	00 00 00 
  414191:	0f 05                	syscall 
  414193:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  414198:	eb 0d                	jmp    4141a7 <cos_tcap_delegate+0x67>
  41419a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4141a0:	b9 00 00 00 00       	mov    ecx,0x0
  4141a5:	eb 05                	jmp    4141ac <cos_tcap_delegate+0x6c>
  4141a7:	b9 01 00 00 00       	mov    ecx,0x1
  4141ac:	5d                   	pop    rbp
  4141ad:	5c                   	pop    rsp
}
  4141ae:	5b                   	pop    rbx
  4141af:	41 5c                	pop    r12
  4141b1:	41 5d                	pop    r13
  4141b3:	5d                   	pop    rbp
  4141b4:	c3                   	ret    
  4141b5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4141bc:	00 00 00 00 

00000000004141c0 <cos_tcap_merge>:

int
cos_tcap_merge(tcap_t dst, tcap_t rm)
{
  4141c0:	f3 0f 1e fa          	endbr64 
  4141c4:	55                   	push   rbp
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4141c5:	c1 e7 10             	shl    edi,0x10
	__asm__ __volatile__(
  4141c8:	31 d2                	xor    edx,edx
	cap_no += op;
  4141ca:	8d 87 29 00 01 00    	lea    eax,[rdi+0x10029]
	__asm__ __volatile__(
  4141d0:	48 89 d7             	mov    rdi,rdx
  4141d3:	48 89 e5             	mov    rbp,rsp
  4141d6:	41 54                	push   r12
  4141d8:	53                   	push   rbx
  4141d9:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  4141dd:	48 89 f3             	mov    rbx,rsi
  4141e0:	48 89 d6             	mov    rsi,rdx
  4141e3:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4141e6:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4141ea:	48 89 cd             	mov    rbp,rcx
  4141ed:	49 b8 08 42 41 00 00 	movabs r8,0x414208
  4141f4:	00 00 00 
  4141f7:	0f 05                	syscall 
  4141f9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  414200:	eb 0d                	jmp    41420f <cos_tcap_merge+0x4f>
  414202:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  414208:	b9 00 00 00 00       	mov    ecx,0x0
  41420d:	eb 05                	jmp    414214 <cos_tcap_merge+0x54>
  41420f:	b9 01 00 00 00       	mov    ecx,0x1
  414214:	5d                   	pop    rbp
  414215:	5c                   	pop    rsp
	return call_cap_op(dst, CAPTBL_OP_TCAP_MERGE, rm, 0, 0, 0);
}
  414216:	5b                   	pop    rbx
  414217:	41 5c                	pop    r12
  414219:	5d                   	pop    rbp
  41421a:	c3                   	ret    
  41421b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000414220 <cos_hw_attach>:

int
cos_hw_attach(hwcap_t hwc, hwid_t hwid, arcvcap_t arcv)
{
  414220:	f3 0f 1e fa          	endbr64 
  414224:	55                   	push   rbp
  414225:	49 89 d2             	mov    r10,rdx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  414228:	c1 e7 10             	shl    edi,0x10
	__asm__ __volatile__(
  41422b:	31 d2                	xor    edx,edx
	cap_no += op;
  41422d:	8d 87 2d 00 01 00    	lea    eax,[rdi+0x1002d]
	__asm__ __volatile__(
  414233:	48 89 d7             	mov    rdi,rdx
  414236:	48 89 e5             	mov    rbp,rsp
  414239:	41 54                	push   r12
  41423b:	53                   	push   rbx
  41423c:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
	return call_cap_op(hwc, CAPTBL_OP_HW_ATTACH, hwid, arcv, 0, 0);
  414240:	89 f3                	mov    ebx,esi
  414242:	4c 89 d6             	mov    rsi,r10
  414245:	48 89 29             	mov    QWORD PTR [rcx],rbp
  414248:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  41424c:	48 89 cd             	mov    rbp,rcx
  41424f:	49 b8 68 42 41 00 00 	movabs r8,0x414268
  414256:	00 00 00 
  414259:	0f 05                	syscall 
  41425b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  414260:	eb 0d                	jmp    41426f <cos_hw_attach+0x4f>
  414262:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  414268:	b9 00 00 00 00       	mov    ecx,0x0
  41426d:	eb 05                	jmp    414274 <cos_hw_attach+0x54>
  41426f:	b9 01 00 00 00       	mov    ecx,0x1
  414274:	5d                   	pop    rbp
  414275:	5c                   	pop    rsp
}
  414276:	5b                   	pop    rbx
  414277:	41 5c                	pop    r12
  414279:	5d                   	pop    rbp
  41427a:	c3                   	ret    
  41427b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000414280 <cos_hw_detach>:

int
cos_hw_detach(hwcap_t hwc, hwid_t hwid)
{
  414280:	f3 0f 1e fa          	endbr64 
  414284:	55                   	push   rbp
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  414285:	c1 e7 10             	shl    edi,0x10
	__asm__ __volatile__(
  414288:	31 d2                	xor    edx,edx
	cap_no += op;
  41428a:	8d 87 2e 00 01 00    	lea    eax,[rdi+0x1002e]
	__asm__ __volatile__(
  414290:	48 89 d7             	mov    rdi,rdx
  414293:	48 89 e5             	mov    rbp,rsp
  414296:	41 54                	push   r12
  414298:	53                   	push   rbx
  414299:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
	return call_cap_op(hwc, CAPTBL_OP_HW_DETACH, hwid, 0, 0, 0);
  41429d:	89 f3                	mov    ebx,esi
  41429f:	48 89 d6             	mov    rsi,rdx
  4142a2:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4142a5:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4142a9:	48 89 cd             	mov    rbp,rcx
  4142ac:	49 b8 c0 42 41 00 00 	movabs r8,0x4142c0
  4142b3:	00 00 00 
  4142b6:	0f 05                	syscall 
  4142b8:	eb 0d                	jmp    4142c7 <cos_hw_detach+0x47>
  4142ba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4142c0:	b9 00 00 00 00       	mov    ecx,0x0
  4142c5:	eb 05                	jmp    4142cc <cos_hw_detach+0x4c>
  4142c7:	b9 01 00 00 00       	mov    ecx,0x1
  4142cc:	5d                   	pop    rbp
  4142cd:	5c                   	pop    rsp
}
  4142ce:	5b                   	pop    rbx
  4142cf:	41 5c                	pop    r12
  4142d1:	5d                   	pop    rbp
  4142d2:	c3                   	ret    
  4142d3:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4142da:	00 00 00 00 
  4142de:	66 90                	xchg   ax,ax

00000000004142e0 <cos_hw_cycles_per_usec>:

int
cos_hw_cycles_per_usec(hwcap_t hwc)
{
  4142e0:	f3 0f 1e fa          	endbr64 
  4142e4:	55                   	push   rbp
  4142e5:	48 89 e5             	mov    rbp,rsp
  4142e8:	41 56                	push   r14
	static int cycs = 0;

	while (cycs <= 0) cycs = call_cap_op(hwc, CAPTBL_OP_HW_CYC_USEC, 0, 0, 0, 0);
  4142ea:	49 be a0 4a 5a 00 00 	movabs r14,0x5a4aa0
  4142f1:	00 00 00 
{
  4142f4:	41 55                	push   r13
  4142f6:	41 54                	push   r12
  4142f8:	53                   	push   rbx
	while (cycs <= 0) cycs = call_cap_op(hwc, CAPTBL_OP_HW_CYC_USEC, 0, 0, 0, 0);
  4142f9:	41 8b 06             	mov    eax,DWORD PTR [r14]
  4142fc:	85 c0                	test   eax,eax
  4142fe:	7f 55                	jg     414355 <cos_hw_cycles_per_usec+0x75>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  414300:	c1 e7 10             	shl    edi,0x10
  414303:	4c 8d 55 d0          	lea    r10,[rbp-0x30]
	__asm__ __volatile__(
  414307:	31 d2                	xor    edx,edx
	cap_no += op;
  414309:	44 8d af 30 00 01 00 	lea    r13d,[rdi+0x10030]
	__asm__ __volatile__(
  414310:	44 89 e8             	mov    eax,r13d
  414313:	48 89 d3             	mov    rbx,rdx
  414316:	48 89 d6             	mov    rsi,rdx
  414319:	48 89 d7             	mov    rdi,rdx
  41431c:	4c 89 d1             	mov    rcx,r10
  41431f:	48 89 29             	mov    QWORD PTR [rcx],rbp
  414322:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  414326:	48 89 cd             	mov    rbp,rcx
  414329:	49 b8 40 43 41 00 00 	movabs r8,0x414340
  414330:	00 00 00 
  414333:	0f 05                	syscall 
  414335:	0f 1f 00             	nop    DWORD PTR [rax]
  414338:	eb 0d                	jmp    414347 <cos_hw_cycles_per_usec+0x67>
  41433a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  414340:	b9 00 00 00 00       	mov    ecx,0x0
  414345:	eb 05                	jmp    41434c <cos_hw_cycles_per_usec+0x6c>
  414347:	b9 01 00 00 00       	mov    ecx,0x1
  41434c:	5d                   	pop    rbp
  41434d:	5c                   	pop    rsp
  41434e:	41 89 06             	mov    DWORD PTR [r14],eax
  414351:	85 c0                	test   eax,eax
  414353:	7e bb                	jle    414310 <cos_hw_cycles_per_usec+0x30>

	return cycs;
}
  414355:	5b                   	pop    rbx
  414356:	41 5c                	pop    r12
  414358:	41 5d                	pop    r13
  41435a:	41 5e                	pop    r14
  41435c:	5d                   	pop    rbp
  41435d:	c3                   	ret    
  41435e:	66 90                	xchg   ax,ax

0000000000414360 <cos_hw_tlb_lockdown>:

int
cos_hw_tlb_lockdown(hwcap_t hwc, unsigned long entryid, unsigned long vaddr, unsigned long paddr)
{
  414360:	f3 0f 1e fa          	endbr64 
  414364:	55                   	push   rbp
  414365:	49 89 f2             	mov    r10,rsi
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  414368:	c1 e7 10             	shl    edi,0x10
  41436b:	48 89 d6             	mov    rsi,rdx
	cap_no += op;
  41436e:	8d 87 33 00 01 00    	lea    eax,[rdi+0x10033]
	__asm__ __volatile__(
  414374:	31 d2                	xor    edx,edx
  414376:	48 89 e5             	mov    rbp,rsp
  414379:	41 55                	push   r13
  41437b:	49 89 cd             	mov    r13,rcx
  41437e:	41 54                	push   r12
  414380:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  414384:	4c 89 ef             	mov    rdi,r13
  414387:	53                   	push   rbx
  414388:	4c 89 d3             	mov    rbx,r10
  41438b:	48 89 29             	mov    QWORD PTR [rcx],rbp
  41438e:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  414392:	48 89 cd             	mov    rbp,rcx
  414395:	49 b8 b0 43 41 00 00 	movabs r8,0x4143b0
  41439c:	00 00 00 
  41439f:	0f 05                	syscall 
  4143a1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  4143a8:	eb 0d                	jmp    4143b7 <cos_hw_tlb_lockdown+0x57>
  4143aa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4143b0:	b9 00 00 00 00       	mov    ecx,0x0
  4143b5:	eb 05                	jmp    4143bc <cos_hw_tlb_lockdown+0x5c>
  4143b7:	b9 01 00 00 00       	mov    ecx,0x1
  4143bc:	5d                   	pop    rbp
  4143bd:	5c                   	pop    rsp
	return call_cap_op(hwc, CAPTBL_OP_HW_TLB_LOCKDOWN, entryid, vaddr, paddr, 0);
}
  4143be:	5b                   	pop    rbx
  4143bf:	41 5c                	pop    r12
  4143c1:	41 5d                	pop    r13
  4143c3:	5d                   	pop    rbp
  4143c4:	c3                   	ret    
  4143c5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4143cc:	00 00 00 00 

00000000004143d0 <cos_hw_l1flush>:

int
cos_hw_l1flush(hwcap_t hwc)
{
  4143d0:	f3 0f 1e fa          	endbr64 
  4143d4:	55                   	push   rbp
  4143d5:	31 d2                	xor    edx,edx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4143d7:	c1 e7 10             	shl    edi,0x10
	cap_no += op;
  4143da:	8d 87 34 00 01 00    	lea    eax,[rdi+0x10034]
	__asm__ __volatile__(
  4143e0:	48 89 d6             	mov    rsi,rdx
  4143e3:	48 89 d7             	mov    rdi,rdx
  4143e6:	48 89 e5             	mov    rbp,rsp
  4143e9:	41 54                	push   r12
  4143eb:	53                   	push   rbx
  4143ec:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  4143f0:	48 89 d3             	mov    rbx,rdx
  4143f3:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4143f6:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4143fa:	48 89 cd             	mov    rbp,rcx
  4143fd:	49 b8 18 44 41 00 00 	movabs r8,0x414418
  414404:	00 00 00 
  414407:	0f 05                	syscall 
  414409:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  414410:	eb 0d                	jmp    41441f <cos_hw_l1flush+0x4f>
  414412:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  414418:	b9 00 00 00 00       	mov    ecx,0x0
  41441d:	eb 05                	jmp    414424 <cos_hw_l1flush+0x54>
  41441f:	b9 01 00 00 00       	mov    ecx,0x1
  414424:	5d                   	pop    rbp
  414425:	5c                   	pop    rsp
	return call_cap_op(hwc, CAPTBL_OP_HW_L1FLUSH, 0, 0, 0, 0);
}
  414426:	5b                   	pop    rbx
  414427:	41 5c                	pop    r12
  414429:	5d                   	pop    rbp
  41442a:	c3                   	ret    
  41442b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000414430 <cos_hw_tlbflush>:

int
cos_hw_tlbflush(hwcap_t hwc)
{
  414430:	f3 0f 1e fa          	endbr64 
  414434:	55                   	push   rbp
  414435:	31 d2                	xor    edx,edx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  414437:	c1 e7 10             	shl    edi,0x10
	cap_no += op;
  41443a:	8d 87 35 00 01 00    	lea    eax,[rdi+0x10035]
	__asm__ __volatile__(
  414440:	48 89 d6             	mov    rsi,rdx
  414443:	48 89 d7             	mov    rdi,rdx
  414446:	48 89 e5             	mov    rbp,rsp
  414449:	41 54                	push   r12
  41444b:	53                   	push   rbx
  41444c:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  414450:	48 89 d3             	mov    rbx,rdx
  414453:	48 89 29             	mov    QWORD PTR [rcx],rbp
  414456:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  41445a:	48 89 cd             	mov    rbp,rcx
  41445d:	49 b8 78 44 41 00 00 	movabs r8,0x414478
  414464:	00 00 00 
  414467:	0f 05                	syscall 
  414469:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  414470:	eb 0d                	jmp    41447f <cos_hw_tlbflush+0x4f>
  414472:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  414478:	b9 00 00 00 00       	mov    ecx,0x0
  41447d:	eb 05                	jmp    414484 <cos_hw_tlbflush+0x54>
  41447f:	b9 01 00 00 00       	mov    ecx,0x1
  414484:	5d                   	pop    rbp
  414485:	5c                   	pop    rsp
	return call_cap_op(hwc, CAPTBL_OP_HW_TLBFLUSH, 0, 0, 0, 0);
}
  414486:	5b                   	pop    rbx
  414487:	41 5c                	pop    r12
  414489:	5d                   	pop    rbp
  41448a:	c3                   	ret    
  41448b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000414490 <cos_hw_tlbstall>:

int
cos_hw_tlbstall(hwcap_t hwc)
{
  414490:	f3 0f 1e fa          	endbr64 
  414494:	55                   	push   rbp
  414495:	31 d2                	xor    edx,edx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  414497:	c1 e7 10             	shl    edi,0x10
	cap_no += op;
  41449a:	8d 87 36 00 01 00    	lea    eax,[rdi+0x10036]
	__asm__ __volatile__(
  4144a0:	48 89 d6             	mov    rsi,rdx
  4144a3:	48 89 d7             	mov    rdi,rdx
  4144a6:	48 89 e5             	mov    rbp,rsp
  4144a9:	41 54                	push   r12
  4144ab:	53                   	push   rbx
  4144ac:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  4144b0:	48 89 d3             	mov    rbx,rdx
  4144b3:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4144b6:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4144ba:	48 89 cd             	mov    rbp,rcx
  4144bd:	49 b8 d8 44 41 00 00 	movabs r8,0x4144d8
  4144c4:	00 00 00 
  4144c7:	0f 05                	syscall 
  4144c9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  4144d0:	eb 0d                	jmp    4144df <cos_hw_tlbstall+0x4f>
  4144d2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4144d8:	b9 00 00 00 00       	mov    ecx,0x0
  4144dd:	eb 05                	jmp    4144e4 <cos_hw_tlbstall+0x54>
  4144df:	b9 01 00 00 00       	mov    ecx,0x1
  4144e4:	5d                   	pop    rbp
  4144e5:	5c                   	pop    rsp
	return call_cap_op(hwc, CAPTBL_OP_HW_TLBSTALL, 0, 0, 0, 0);
}
  4144e6:	5b                   	pop    rbx
  4144e7:	41 5c                	pop    r12
  4144e9:	5d                   	pop    rbp
  4144ea:	c3                   	ret    
  4144eb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000004144f0 <cos_hw_tlbstall_recount>:

int
cos_hw_tlbstall_recount(hwcap_t hwc)
{
  4144f0:	f3 0f 1e fa          	endbr64 
  4144f4:	55                   	push   rbp
  4144f5:	31 d2                	xor    edx,edx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4144f7:	c1 e7 10             	shl    edi,0x10
	cap_no += op;
  4144fa:	8d 87 37 00 01 00    	lea    eax,[rdi+0x10037]
	__asm__ __volatile__(
  414500:	48 89 d6             	mov    rsi,rdx
  414503:	48 89 d7             	mov    rdi,rdx
  414506:	48 89 e5             	mov    rbp,rsp
  414509:	41 54                	push   r12
  41450b:	53                   	push   rbx
  41450c:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  414510:	48 89 d3             	mov    rbx,rdx
  414513:	48 89 29             	mov    QWORD PTR [rcx],rbp
  414516:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  41451a:	48 89 cd             	mov    rbp,rcx
  41451d:	49 b8 38 45 41 00 00 	movabs r8,0x414538
  414524:	00 00 00 
  414527:	0f 05                	syscall 
  414529:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  414530:	eb 0d                	jmp    41453f <cos_hw_tlbstall_recount+0x4f>
  414532:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  414538:	b9 00 00 00 00       	mov    ecx,0x0
  41453d:	eb 05                	jmp    414544 <cos_hw_tlbstall_recount+0x54>
  41453f:	b9 01 00 00 00       	mov    ecx,0x1
  414544:	5d                   	pop    rbp
  414545:	5c                   	pop    rsp
	return call_cap_op(hwc, CAPTBL_OP_HW_TLBSTALL_RECOUNT, 0, 0, 0, 0);
}
  414546:	5b                   	pop    rbx
  414547:	41 5c                	pop    r12
  414549:	5d                   	pop    rbp
  41454a:	c3                   	ret    
  41454b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000414550 <cos_hw_cycles_thresh>:

int
cos_hw_cycles_thresh(hwcap_t hwc)
{
  414550:	f3 0f 1e fa          	endbr64 
  414554:	55                   	push   rbp
  414555:	31 d2                	xor    edx,edx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  414557:	c1 e7 10             	shl    edi,0x10
	cap_no += op;
  41455a:	8d 87 31 00 01 00    	lea    eax,[rdi+0x10031]
	__asm__ __volatile__(
  414560:	48 89 d6             	mov    rsi,rdx
  414563:	48 89 d7             	mov    rdi,rdx
  414566:	48 89 e5             	mov    rbp,rsp
  414569:	41 54                	push   r12
  41456b:	53                   	push   rbx
  41456c:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  414570:	48 89 d3             	mov    rbx,rdx
  414573:	48 89 29             	mov    QWORD PTR [rcx],rbp
  414576:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  41457a:	48 89 cd             	mov    rbp,rcx
  41457d:	49 b8 98 45 41 00 00 	movabs r8,0x414598
  414584:	00 00 00 
  414587:	0f 05                	syscall 
  414589:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  414590:	eb 0d                	jmp    41459f <cos_hw_cycles_thresh+0x4f>
  414592:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  414598:	b9 00 00 00 00       	mov    ecx,0x0
  41459d:	eb 05                	jmp    4145a4 <cos_hw_cycles_thresh+0x54>
  41459f:	b9 01 00 00 00       	mov    ecx,0x1
  4145a4:	5d                   	pop    rbp
  4145a5:	5c                   	pop    rsp
	return call_cap_op(hwc, CAPTBL_OP_HW_CYC_THRESH, 0, 0, 0, 0);
}
  4145a6:	5b                   	pop    rbx
  4145a7:	41 5c                	pop    r12
  4145a9:	5d                   	pop    rbp
  4145aa:	c3                   	ret    
  4145ab:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000004145b0 <cos_hw_shutdown>:

void
cos_hw_shutdown(hwcap_t hwc)
{
  4145b0:	f3 0f 1e fa          	endbr64 
  4145b4:	55                   	push   rbp
  4145b5:	31 d2                	xor    edx,edx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4145b7:	c1 e7 10             	shl    edi,0x10
	cap_no += op;
  4145ba:	8d 87 32 00 01 00    	lea    eax,[rdi+0x10032]
	__asm__ __volatile__(
  4145c0:	48 89 d6             	mov    rsi,rdx
  4145c3:	48 89 d7             	mov    rdi,rdx
  4145c6:	48 89 e5             	mov    rbp,rsp
  4145c9:	41 54                	push   r12
  4145cb:	53                   	push   rbx
  4145cc:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  4145d0:	48 89 d3             	mov    rbx,rdx
  4145d3:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4145d6:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4145da:	48 89 cd             	mov    rbp,rcx
  4145dd:	49 b8 f8 45 41 00 00 	movabs r8,0x4145f8
  4145e4:	00 00 00 
  4145e7:	0f 05                	syscall 
  4145e9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  4145f0:	eb 0d                	jmp    4145ff <cos_hw_shutdown+0x4f>
  4145f2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4145f8:	b9 00 00 00 00       	mov    ecx,0x0
  4145fd:	eb 05                	jmp    414604 <cos_hw_shutdown+0x54>
  4145ff:	b9 01 00 00 00       	mov    ecx,0x1
  414604:	5d                   	pop    rbp
  414605:	5c                   	pop    rsp
	call_cap_op(hwc, CAPTBL_OP_HW_SHUTDOWN, 0, 0, 0, 0);
}
  414606:	5b                   	pop    rbx
  414607:	41 5c                	pop    r12
  414609:	5d                   	pop    rbp
  41460a:	c3                   	ret    
  41460b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000414610 <cos_hw_map>:

void *
cos_hw_map(struct cos_compinfo *ci, hwcap_t hwc, paddr_t pa, unsigned int len)
{
  414610:	f3 0f 1e fa          	endbr64 
  414614:	55                   	push   rbp
  414615:	48 89 e5             	mov    rbp,rsp
  414618:	41 57                	push   r15
  41461a:	41 56                	push   r14
  41461c:	41 55                	push   r13
  41461e:	41 54                	push   r12
  414620:	53                   	push   rbx
  414621:	48 83 ec 28          	sub    rsp,0x28
	size_t  sz, i;
	vaddr_t va;

	assert(ci && hwc && pa && len);
  414625:	48 85 ff             	test   rdi,rdi
  414628:	0f 84 04 01 00 00    	je     414732 <cos_hw_map+0x122>
  41462e:	48 89 f3             	mov    rbx,rsi
  414631:	48 85 f6             	test   rsi,rsi
  414634:	0f 84 f8 00 00 00    	je     414732 <cos_hw_map+0x122>
  41463a:	49 89 d7             	mov    r15,rdx
  41463d:	48 85 d2             	test   rdx,rdx
  414640:	0f 84 ec 00 00 00    	je     414732 <cos_hw_map+0x122>
  414646:	85 c9                	test   ecx,ecx
  414648:	0f 84 e4 00 00 00    	je     414732 <cos_hw_map+0x122>

	sz = round_up_to_page(len);
  41464e:	89 c9                	mov    ecx,ecx
  414650:	49 89 fe             	mov    r14,rdi
	va = __page_bump_valloc(ci, sz, PAGE_SIZE);
  414653:	ba 00 10 00 00       	mov    edx,0x1000
  414658:	48 b8 40 ea 40 00 00 	movabs rax,0x40ea40
  41465f:	00 00 00 
	sz = round_up_to_page(len);
  414662:	48 81 c1 ff 0f 00 00 	add    rcx,0xfff
  414669:	48 81 e1 00 f0 ff ff 	and    rcx,0xfffffffffffff000
  414670:	48 89 4d b8          	mov    QWORD PTR [rbp-0x48],rcx
  414674:	48 89 ce             	mov    rsi,rcx
	va = __page_bump_valloc(ci, sz, PAGE_SIZE);
  414677:	ff d0                	call   rax
  414679:	49 89 c5             	mov    r13,rax
	if (unlikely(!va)) return NULL;
  41467c:	48 85 c0             	test   rax,rax
  41467f:	0f 84 d5 00 00 00    	je     41475a <cos_hw_map+0x14a>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  414685:	c1 e3 10             	shl    ebx,0x10

	for (i = 0; i < sz; i += PAGE_SIZE) {
  414688:	45 31 d2             	xor    r10d,r10d
	__asm__ __volatile__(
  41468b:	31 d2                	xor    edx,edx
	cap_no += op;
  41468d:	8d 83 2f 00 01 00    	lea    eax,[rbx+0x1002f]
  414693:	89 45 b4             	mov    DWORD PTR [rbp-0x4c],eax
  414696:	eb 15                	jmp    4146ad <cos_hw_map+0x9d>
  414698:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41469f:	00 
  4146a0:	49 81 c2 00 10 00 00 	add    r10,0x1000
  4146a7:	4c 39 55 b8          	cmp    QWORD PTR [rbp-0x48],r10
  4146ab:	76 73                	jbe    414720 <cos_hw_map+0x110>
	__asm__ __volatile__(
  4146ad:	49 8b 1e             	mov    rbx,QWORD PTR [r14]
  4146b0:	8b 45 b4             	mov    eax,DWORD PTR [rbp-0x4c]
  4146b3:	4b 8d 34 2a          	lea    rsi,[r10+r13*1]
  4146b7:	4b 8d 3c 3a          	lea    rdi,[r10+r15*1]
  4146bb:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  4146bf:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4146c2:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4146c6:	48 89 cd             	mov    rbp,rcx
  4146c9:	49 b8 e0 46 41 00 00 	movabs r8,0x4146e0
  4146d0:	00 00 00 
  4146d3:	0f 05                	syscall 
  4146d5:	0f 1f 00             	nop    DWORD PTR [rax]
  4146d8:	eb 0d                	jmp    4146e7 <cos_hw_map+0xd7>
  4146da:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4146e0:	b9 00 00 00 00       	mov    ecx,0x0
  4146e5:	eb 05                	jmp    4146ec <cos_hw_map+0xdc>
  4146e7:	b9 01 00 00 00       	mov    ecx,0x1
  4146ec:	5d                   	pop    rbp
  4146ed:	5c                   	pop    rsp
		if (call_cap_op(hwc, CAPTBL_OP_HW_MAP, ci->pgtbl_cap, va + i, pa + i, 0)) BUG();
  4146ee:	85 c0                	test   eax,eax
  4146f0:	74 ae                	je     4146a0 <cos_hw_map+0x90>
  4146f2:	48 bf d8 14 42 00 00 	movabs rdi,0x4214d8
  4146f9:	00 00 00 
  4146fc:	be 1c 00 00 00       	mov    esi,0x1c
  414701:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  414708:	00 00 00 
  41470b:	ff d0                	call   rax
  41470d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414714:	00 00 00 00 
  414718:	0f 0b                	ud2    
  41471a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	}

	return (void *)va;
  414720:	4c 89 e8             	mov    rax,r13
}
  414723:	48 83 c4 28          	add    rsp,0x28
  414727:	5b                   	pop    rbx
  414728:	41 5c                	pop    r12
  41472a:	41 5d                	pop    r13
  41472c:	41 5e                	pop    r14
  41472e:	41 5f                	pop    r15
  414730:	5d                   	pop    rbp
  414731:	c3                   	ret    
  414732:	48 bf a8 14 42 00 00 	movabs rdi,0x4214a8
  414739:	00 00 00 
  41473c:	be 2f 00 00 00       	mov    esi,0x2f
  414741:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  414748:	00 00 00 
  41474b:	ff d0                	call   rax
	assert(ci && hwc && pa && len);
  41474d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414754:	00 00 00 00 
  414758:	0f 0b                	ud2    
	if (unlikely(!va)) return NULL;
  41475a:	31 c0                	xor    eax,eax
  41475c:	eb c5                	jmp    414723 <cos_hw_map+0x113>
  41475e:	66 90                	xchg   ax,ax

0000000000414760 <cos_get_second_lvl>:


/* ----- Shared Pgtbl ------ */
int
cos_get_second_lvl(struct cos_compinfo *ci, capid_t *pgtbl_cap, vaddr_t *pgtbl_addr)
{
  414760:	f3 0f 1e fa          	endbr64 
	if(ci->mi.second_lvl_pgtbl_cap == 0) {
  414764:	48 8b 87 a0 00 00 00 	mov    rax,QWORD PTR [rdi+0xa0]
  41476b:	48 85 c0             	test   rax,rax
  41476e:	74 10                	je     414780 <cos_get_second_lvl+0x20>
		return -1;
	}
	*pgtbl_cap = ci->mi.second_lvl_pgtbl_cap;
  414770:	48 89 06             	mov    QWORD PTR [rsi],rax
	*pgtbl_addr = ci->mi.second_lvl_pgtbl_addr;
  414773:	48 8b 87 a8 00 00 00 	mov    rax,QWORD PTR [rdi+0xa8]
  41477a:	48 89 02             	mov    QWORD PTR [rdx],rax

	return 0;
  41477d:	31 c0                	xor    eax,eax
  41477f:	c3                   	ret    
		return -1;
  414780:	b8 ff ff ff ff       	mov    eax,0xffffffff
}
  414785:	c3                   	ret    
  414786:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41478d:	00 00 00 

0000000000414790 <cos_cons_into_shared_pgtbl>:

u32_t
cos_cons_into_shared_pgtbl(struct cos_compinfo *ci, pgtblcap_t top_lvl)
{
  414790:	f3 0f 1e fa          	endbr64 
  414794:	55                   	push   rbp
  414795:	48 89 e5             	mov    rbp,rsp
  414798:	41 54                	push   r12
  41479a:	53                   	push   rbx
  41479b:	48 83 ec 10          	sub    rsp,0x10
	if(ci->mi.second_lvl_pgtbl_cap == 0) {
  41479f:	48 8b 9f a0 00 00 00 	mov    rbx,QWORD PTR [rdi+0xa0]
  4147a6:	48 85 db             	test   rbx,rbx
  4147a9:	0f 84 89 00 00 00    	je     414838 <cos_cons_into_shared_pgtbl+0xa8>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4147af:	c1 e6 10             	shl    esi,0x10
	__asm__ __volatile__(
  4147b2:	31 d2                	xor    edx,edx
  4147b4:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
	cap_no += op;
  4147b8:	8d 86 01 00 01 00    	lea    eax,[rsi+0x10001]
	__asm__ __volatile__(
  4147be:	48 8b b7 a8 00 00 00 	mov    rsi,QWORD PTR [rdi+0xa8]
  4147c5:	48 89 d7             	mov    rdi,rdx
  4147c8:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4147cb:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4147cf:	48 89 cd             	mov    rbp,rcx
  4147d2:	49 b8 e8 47 41 00 00 	movabs r8,0x4147e8
  4147d9:	00 00 00 
  4147dc:	0f 05                	syscall 
  4147de:	66 90                	xchg   ax,ax
  4147e0:	eb 0d                	jmp    4147ef <cos_cons_into_shared_pgtbl+0x5f>
  4147e2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4147e8:	b9 00 00 00 00       	mov    ecx,0x0
  4147ed:	eb 05                	jmp    4147f4 <cos_cons_into_shared_pgtbl+0x64>
  4147ef:	b9 01 00 00 00       	mov    ecx,0x1
  4147f4:	5d                   	pop    rbp
  4147f5:	5c                   	pop    rsp
	if (call_cap_op(top_lvl, CAPTBL_OP_CONS, pte_cap, pgtbl_addr, 0, 0)) {
		assert(0); /* race? */
		return -1;
	}

	return 0;
  4147f6:	45 31 c0             	xor    r8d,r8d
	if (call_cap_op(top_lvl, CAPTBL_OP_CONS, pte_cap, pgtbl_addr, 0, 0)) {
  4147f9:	85 c0                	test   eax,eax
  4147fb:	75 13                	jne    414810 <cos_cons_into_shared_pgtbl+0x80>

}
  4147fd:	48 83 c4 10          	add    rsp,0x10
  414801:	44 89 c0             	mov    eax,r8d
  414804:	5b                   	pop    rbx
  414805:	41 5c                	pop    r12
  414807:	5d                   	pop    rbp
  414808:	c3                   	ret    
  414809:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  414810:	48 bf f8 14 42 00 00 	movabs rdi,0x4214f8
  414817:	00 00 00 
  41481a:	be 2f 00 00 00       	mov    esi,0x2f
  41481f:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  414826:	00 00 00 
  414829:	ff d0                	call   rax
		assert(0); /* race? */
  41482b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414832:	00 00 00 00 
  414836:	0f 0b                	ud2    
		return -1;
  414838:	41 b8 ff ff ff ff    	mov    r8d,0xffffffff
  41483e:	eb bd                	jmp    4147fd <cos_cons_into_shared_pgtbl+0x6d>

0000000000414840 <slm_sched_fprr_execution>:
struct runqueue threads[NUM_CPU];

/* No RR based on execution, yet */
void
slm_sched_fprr_execution(struct slm_thd *t, cycles_t cycles)
{ return; }
  414840:	f3 0f 1e fa          	endbr64 
  414844:	c3                   	ret    
  414845:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41484c:	00 00 00 00 

0000000000414850 <slm_sched_fprr_schedule>:
	}
}

struct slm_thd *
slm_sched_fprr_schedule(void)
{
  414850:	f3 0f 1e fa          	endbr64 

#if ENABLE_DEBUG_INFO
	debug_dump_info();
#endif

	for (i = 0 ; i < SLM_FPRR_NPRIOS ; i++) {
  414854:	48 b8 00 4b 5a 00 00 	movabs rax,0x5a4b00
  41485b:	00 00 00 
  41485e:	48 8d 90 00 02 00 00 	lea    rdx,[rax+0x200]
ps_list_head_init(struct ps_list_head *lh)
{ ps_list_ll_init(&lh->l); }

static inline int
ps_list_ll_empty(struct ps_list *l)
{ return l->n == l; }
  414865:	48 8b 38             	mov    rdi,QWORD PTR [rax]
		if (ps_list_head_empty(&prios[i])) continue;
  414868:	48 39 f8             	cmp    rax,rdi
  41486b:	74 4b                	je     4148b8 <slm_sched_fprr_schedule+0x68>
}

static inline void
ps_list_ll_rem(struct ps_list *l)
{
	l->n->p = l->p;
  41486d:	48 8b 0f             	mov    rcx,QWORD PTR [rdi]
  414870:	48 8b 57 08          	mov    rdx,QWORD PTR [rdi+0x8]
	l->p->n = l->n;
	l->p = l->n = l;
  414874:	66 48 0f 6e c7       	movq   xmm0,rdi
  414879:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
	l->n->p = l->p;
  41487d:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
	l->p->n = l->n;
  414881:	48 89 0a             	mov    QWORD PTR [rdx],rcx
	l->p = l->n = l;
  414884:	0f 11 07             	movups XMMWORD PTR [rdi],xmm0
		/*
		 * We want to move the selected thread to the back of the list.
		 * Otherwise fprr won't be truly round robin
		 */
		ps_list_rem_d(t);
		ps_list_head_append_d(&prios[i], t);
  414887:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	new->n    = l->n;
  41488b:	f3 0f 7e 00          	movq   xmm0,QWORD PTR [rax]
  41488f:	66 48 0f 6e c8       	movq   xmm1,rax
  414894:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  414898:	0f 11 07             	movups XMMWORD PTR [rdi],xmm0
	l->n      = new;
  41489b:	48 89 38             	mov    QWORD PTR [rax],rdi
	new->n->p = new;
  41489e:	48 8b 07             	mov    rax,QWORD PTR [rdi]
  4148a1:	48 89 78 08          	mov    QWORD PTR [rax+0x8],rdi

//		printc("Schedule -> %ld\n", slm_thd_from_sched(t)->tid);
		return slm_thd_from_sched(t);
  4148a5:	48 b8 00 1c 40 00 00 	movabs rax,0x401c00
  4148ac:	00 00 00 
  4148af:	ff e0                	jmp    rax
  4148b1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (i = 0 ; i < SLM_FPRR_NPRIOS ; i++) {
  4148b8:	48 83 c0 10          	add    rax,0x10
  4148bc:	48 39 d0             	cmp    rax,rdx
  4148bf:	75 a4                	jne    414865 <slm_sched_fprr_schedule+0x15>
	}
//	printc("Schedule -> idle\n");

	return NULL;
}
  4148c1:	31 c0                	xor    eax,eax
  4148c3:	c3                   	ret    
  4148c4:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4148cb:	00 00 00 00 
  4148cf:	90                   	nop

00000000004148d0 <slm_sched_fprr_block>:

int
slm_sched_fprr_block(struct slm_thd *t)
{
  4148d0:	f3 0f 1e fa          	endbr64 
	struct slm_sched_thd *p = slm_thd_sched_policy(t);
  4148d4:	48 b8 e0 1b 40 00 00 	movabs rax,0x401be0
  4148db:	00 00 00 
{
  4148de:	55                   	push   rbp
  4148df:	48 89 e5             	mov    rbp,rsp
	struct slm_sched_thd *p = slm_thd_sched_policy(t);
  4148e2:	ff d0                	call   rax
	l->n->p = l->p;
  4148e4:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  4148e7:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
	l->p = l->n = l;
  4148eb:	66 48 0f 6e c0       	movq   xmm0,rax
  4148f0:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
	l->n->p = l->p;
  4148f4:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
	l->p->n = l->n;
  4148f8:	48 89 0a             	mov    QWORD PTR [rdx],rcx
	l->p = l->n = l;
  4148fb:	0f 11 00             	movups XMMWORD PTR [rax],xmm0

	ps_list_rem_d(p);

	return 0;
}
  4148fe:	31 c0                	xor    eax,eax
  414900:	5d                   	pop    rbp
  414901:	c3                   	ret    
  414902:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  414909:	00 00 00 00 
  41490d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000414910 <slm_sched_fprr_wakeup>:

int
slm_sched_fprr_wakeup(struct slm_thd *t)
{
  414910:	f3 0f 1e fa          	endbr64 
	struct slm_sched_thd *p = slm_thd_sched_policy(t);
  414914:	48 b8 e0 1b 40 00 00 	movabs rax,0x401be0
  41491b:	00 00 00 
{
  41491e:	55                   	push   rbp
  41491f:	48 89 e5             	mov    rbp,rsp
  414922:	53                   	push   rbx
  414923:	48 89 fb             	mov    rbx,rdi
  414926:	48 83 ec 08          	sub    rsp,0x8
	struct slm_sched_thd *p = slm_thd_sched_policy(t);
  41492a:	ff d0                	call   rax

	assert(ps_list_singleton_d(p));
  41492c:	48 3b 00             	cmp    rax,QWORD PTR [rax]
  41492f:	75 39                	jne    41496a <slm_sched_fprr_wakeup+0x5a>

	ps_list_head_append_d(&threads[cos_cpuid()].prio[t->priority - 1], p);
  414931:	48 b9 00 4b 5a 00 00 	movabs rcx,0x5a4b00
  414938:	00 00 00 
  41493b:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]

	return 0;
}
  41493f:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
	ps_list_head_append_d(&threads[cos_cpuid()].prio[t->priority - 1], p);
  414943:	48 c1 e2 04          	shl    rdx,0x4
  414947:	48 8b 54 0a f8       	mov    rdx,QWORD PTR [rdx+rcx*1-0x8]
	new->n    = l->n;
  41494c:	f3 0f 7e 02          	movq   xmm0,QWORD PTR [rdx]
  414950:	66 48 0f 6e ca       	movq   xmm1,rdx
  414955:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  414959:	0f 11 00             	movups XMMWORD PTR [rax],xmm0
	l->n      = new;
  41495c:	48 89 02             	mov    QWORD PTR [rdx],rax
	new->n->p = new;
  41495f:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  414962:	48 89 42 08          	mov    QWORD PTR [rdx+0x8],rax
}
  414966:	31 c0                	xor    eax,eax
  414968:	c9                   	leave  
  414969:	c3                   	ret    
  41496a:	48 bf 48 15 42 00 00 	movabs rdi,0x421548
  414971:	00 00 00 
  414974:	be 23 00 00 00       	mov    esi,0x23
  414979:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  414980:	00 00 00 
  414983:	ff d0                	call   rax
	assert(ps_list_singleton_d(p));
  414985:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41498c:	00 00 00 00 
  414990:	0f 0b                	ud2    
  414992:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  414999:	00 00 00 00 
  41499d:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004149a0 <slm_sched_fprr_yield>:

void
slm_sched_fprr_yield(struct slm_thd *t, struct slm_thd *yield_to)
{
  4149a0:	f3 0f 1e fa          	endbr64 
	struct slm_sched_thd *p = slm_thd_sched_policy(t);
  4149a4:	48 b8 e0 1b 40 00 00 	movabs rax,0x401be0
  4149ab:	00 00 00 
{
  4149ae:	55                   	push   rbp
  4149af:	48 89 e5             	mov    rbp,rsp
  4149b2:	53                   	push   rbx
  4149b3:	48 89 fb             	mov    rbx,rdi
  4149b6:	48 83 ec 08          	sub    rsp,0x8
	struct slm_sched_thd *p = slm_thd_sched_policy(t);
  4149ba:	ff d0                	call   rax
	l->n->p = l->p;
  4149bc:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  4149bf:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
	l->p = l->n = l;
  4149c3:	66 48 0f 6e c0       	movq   xmm0,rax
  4149c8:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
	l->n->p = l->p;
  4149cc:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
	l->p->n = l->n;
  4149d0:	48 89 0a             	mov    QWORD PTR [rdx],rcx

	ps_list_rem_d(p);
	ps_list_head_append_d(&threads[cos_cpuid()].prio[t->priority], p);
  4149d3:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]
  4149d7:	48 b9 00 4b 5a 00 00 	movabs rcx,0x5a4b00
  4149de:	00 00 00 
	l->p = l->n = l;
  4149e1:	0f 11 00             	movups XMMWORD PTR [rax],xmm0
}
  4149e4:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
	ps_list_head_append_d(&threads[cos_cpuid()].prio[t->priority], p);
  4149e8:	48 c1 e2 04          	shl    rdx,0x4
  4149ec:	48 8b 54 11 08       	mov    rdx,QWORD PTR [rcx+rdx*1+0x8]
	new->n    = l->n;
  4149f1:	f3 0f 7e 02          	movq   xmm0,QWORD PTR [rdx]
  4149f5:	66 48 0f 6e ca       	movq   xmm1,rdx
  4149fa:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  4149fe:	0f 11 00             	movups XMMWORD PTR [rax],xmm0
	l->n      = new;
  414a01:	48 89 02             	mov    QWORD PTR [rdx],rax
	new->n->p = new;
  414a04:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  414a07:	48 89 42 08          	mov    QWORD PTR [rdx+0x8],rax
}
  414a0b:	c9                   	leave  
  414a0c:	c3                   	ret    
  414a0d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000414a10 <slm_sched_fprr_thd_init>:

int
slm_sched_fprr_thd_init(struct slm_thd *t)
{
  414a10:	f3 0f 1e fa          	endbr64 
	t->priority = SLM_FPRR_PRIO_LOWEST;
	ps_list_init_d(slm_thd_sched_policy(t));
  414a14:	48 b8 e0 1b 40 00 00 	movabs rax,0x401be0
  414a1b:	00 00 00 
{
  414a1e:	55                   	push   rbp
	t->priority = SLM_FPRR_PRIO_LOWEST;
  414a1f:	48 c7 47 30 1f 00 00 	mov    QWORD PTR [rdi+0x30],0x1f
  414a26:	00 
{
  414a27:	48 89 e5             	mov    rbp,rsp
	ps_list_init_d(slm_thd_sched_policy(t));
  414a2a:	ff d0                	call   rax
{ l->n = l->p = l; }
  414a2c:	66 48 0f 6e c0       	movq   xmm0,rax
  414a31:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  414a35:	0f 11 00             	movups XMMWORD PTR [rax],xmm0

	return 0;
}
  414a38:	31 c0                	xor    eax,eax
  414a3a:	5d                   	pop    rbp
  414a3b:	c3                   	ret    
  414a3c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000414a40 <slm_sched_fprr_thd_deinit>:

void
slm_sched_fprr_thd_deinit(struct slm_thd *t)
{
  414a40:	f3 0f 1e fa          	endbr64 
	ps_list_rem_d(slm_thd_sched_policy(t));
  414a44:	48 b8 e0 1b 40 00 00 	movabs rax,0x401be0
  414a4b:	00 00 00 
{
  414a4e:	55                   	push   rbp
  414a4f:	48 89 e5             	mov    rbp,rsp
	ps_list_rem_d(slm_thd_sched_policy(t));
  414a52:	ff d0                	call   rax
	l->n->p = l->p;
  414a54:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  414a57:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
	l->p = l->n = l;
  414a5b:	66 48 0f 6e c0       	movq   xmm0,rax
  414a60:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
	l->n->p = l->p;
  414a64:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
	l->p->n = l->n;
  414a68:	48 89 0a             	mov    QWORD PTR [rdx],rcx
	l->p = l->n = l;
  414a6b:	0f 11 00             	movups XMMWORD PTR [rax],xmm0
}
  414a6e:	5d                   	pop    rbp
  414a6f:	c3                   	ret    

0000000000414a70 <slm_sched_fprr_thd_update>:
	return;
}

int
slm_sched_fprr_thd_update(struct slm_thd *t, sched_param_type_t type, unsigned int v)
{
  414a70:	f3 0f 1e fa          	endbr64 
  414a74:	55                   	push   rbp
  414a75:	48 89 e5             	mov    rbp,rsp
  414a78:	41 54                	push   r12
  414a7a:	49 89 fc             	mov    r12,rdi
  414a7d:	53                   	push   rbx
	switch (type) {
  414a7e:	83 fe 0a             	cmp    esi,0xa
  414a81:	74 1d                	je     414aa0 <slm_sched_fprr_thd_update+0x30>
  414a83:	83 fe 0b             	cmp    esi,0xb
  414a86:	0f 84 e4 00 00 00    	je     414b70 <slm_sched_fprr_thd_update+0x100>
  414a8c:	b8 ff ff ff ff       	mov    eax,0xffffffff
  414a91:	83 fe 01             	cmp    esi,0x1
  414a94:	74 6a                	je     414b00 <slm_sched_fprr_thd_update+0x90>
	}
	/* Only support priority, for now */
	default:
		return -1;
	}
}
  414a96:	5b                   	pop    rbx
  414a97:	41 5c                	pop    r12
  414a99:	5d                   	pop    rbp
  414a9a:	c3                   	ret    
  414a9b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	struct slm_sched_thd *p = slm_thd_sched_policy(t);
  414aa0:	48 b8 e0 1b 40 00 00 	movabs rax,0x401be0
  414aa7:	00 00 00 
  414aaa:	ff d0                	call   rax
	t->priority = prio;
  414aac:	49 c7 44 24 30 00 00 	mov    QWORD PTR [r12+0x30],0x0
  414ab3:	00 00 
	struct slm_sched_thd *p = slm_thd_sched_policy(t);
  414ab5:	48 89 c2             	mov    rdx,rax
	l->n->p = l->p;
  414ab8:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  414abb:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	l->p = l->n = l;
  414abf:	66 48 0f 6e c2       	movq   xmm0,rdx
  414ac4:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
	l->n->p = l->p;
  414ac8:	48 89 41 08          	mov    QWORD PTR [rcx+0x8],rax
	l->p->n = l->n;
  414acc:	48 89 08             	mov    QWORD PTR [rax],rcx
	l->p = l->n = l;
  414acf:	0f 11 02             	movups XMMWORD PTR [rdx],xmm0
	ps_list_head_append_d(&threads[cos_cpuid()].prio[prio], p);
  414ad2:	48 a1 08 4b 5a 00 00 	movabs rax,ds:0x5a4b08
  414ad9:	00 00 00 
	new->n    = l->n;
  414adc:	f3 0f 7e 00          	movq   xmm0,QWORD PTR [rax]
  414ae0:	66 48 0f 6e c8       	movq   xmm1,rax
  414ae5:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  414ae9:	0f 11 02             	movups XMMWORD PTR [rdx],xmm0
	l->n      = new;
  414aec:	48 89 10             	mov    QWORD PTR [rax],rdx
	new->n->p = new;
  414aef:	48 8b 02             	mov    rax,QWORD PTR [rdx]
  414af2:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
		return 0;
  414af6:	31 c0                	xor    eax,eax
}
  414af8:	5b                   	pop    rbx
  414af9:	41 5c                	pop    r12
  414afb:	5d                   	pop    rbp
  414afc:	c3                   	ret    
  414afd:	0f 1f 00             	nop    DWORD PTR [rax]
		assert(v >= SLM_FPRR_PRIO_HIGHEST && v <= SLM_FPRR_PRIO_LOWEST);
  414b00:	8d 42 ff             	lea    eax,[rdx-0x1]
  414b03:	83 f8 1e             	cmp    eax,0x1e
  414b06:	0f 87 b2 00 00 00    	ja     414bbe <slm_sched_fprr_thd_update+0x14e>
	struct slm_sched_thd *p = slm_thd_sched_policy(t);
  414b0c:	48 b8 e0 1b 40 00 00 	movabs rax,0x401be0
  414b13:	00 00 00 
		update_queue(t, v);
  414b16:	89 d3                	mov    ebx,edx
	struct slm_sched_thd *p = slm_thd_sched_policy(t);
  414b18:	ff d0                	call   rax
	t->priority = prio;
  414b1a:	49 89 5c 24 30       	mov    QWORD PTR [r12+0x30],rbx
	ps_list_head_append_d(&threads[cos_cpuid()].prio[prio], p);
  414b1f:	48 c1 e3 04          	shl    rbx,0x4
	l->n->p = l->p;
  414b23:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  414b26:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
	l->p = l->n = l;
  414b2a:	66 48 0f 6e c0       	movq   xmm0,rax
  414b2f:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
	l->n->p = l->p;
  414b33:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
	l->p->n = l->n;
  414b37:	48 89 0a             	mov    QWORD PTR [rdx],rcx
  414b3a:	48 b9 00 4b 5a 00 00 	movabs rcx,0x5a4b00
  414b41:	00 00 00 
	l->p = l->n = l;
  414b44:	0f 11 00             	movups XMMWORD PTR [rax],xmm0
  414b47:	48 8b 54 19 08       	mov    rdx,QWORD PTR [rcx+rbx*1+0x8]
	new->n    = l->n;
  414b4c:	f3 0f 7e 02          	movq   xmm0,QWORD PTR [rdx]
  414b50:	66 48 0f 6e da       	movq   xmm3,rdx
  414b55:	66 0f 6c c3          	punpcklqdq xmm0,xmm3
  414b59:	0f 11 00             	movups XMMWORD PTR [rax],xmm0
	l->n      = new;
  414b5c:	48 89 02             	mov    QWORD PTR [rdx],rax
	new->n->p = new;
  414b5f:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  414b62:	48 89 42 08          	mov    QWORD PTR [rdx+0x8],rax
		return 0;
  414b66:	31 c0                	xor    eax,eax
}
  414b68:	5b                   	pop    rbx
  414b69:	41 5c                	pop    r12
  414b6b:	5d                   	pop    rbp
  414b6c:	c3                   	ret    
  414b6d:	0f 1f 00             	nop    DWORD PTR [rax]
	struct slm_sched_thd *p = slm_thd_sched_policy(t);
  414b70:	48 b8 e0 1b 40 00 00 	movabs rax,0x401be0
  414b77:	00 00 00 
  414b7a:	ff d0                	call   rax
	t->priority = prio;
  414b7c:	49 c7 44 24 30 1f 00 	mov    QWORD PTR [r12+0x30],0x1f
  414b83:	00 00 
	struct slm_sched_thd *p = slm_thd_sched_policy(t);
  414b85:	48 89 c2             	mov    rdx,rax
	l->n->p = l->p;
  414b88:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  414b8b:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	l->p = l->n = l;
  414b8f:	66 48 0f 6e c2       	movq   xmm0,rdx
  414b94:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
	l->n->p = l->p;
  414b98:	48 89 41 08          	mov    QWORD PTR [rcx+0x8],rax
	l->p->n = l->n;
  414b9c:	48 89 08             	mov    QWORD PTR [rax],rcx
	l->p = l->n = l;
  414b9f:	0f 11 02             	movups XMMWORD PTR [rdx],xmm0
	ps_list_head_append_d(&threads[cos_cpuid()].prio[prio], p);
  414ba2:	48 a1 f8 4c 5a 00 00 	movabs rax,ds:0x5a4cf8
  414ba9:	00 00 00 
	new->n    = l->n;
  414bac:	f3 0f 7e 00          	movq   xmm0,QWORD PTR [rax]
  414bb0:	66 48 0f 6e d0       	movq   xmm2,rax
  414bb5:	66 0f 6c c2          	punpcklqdq xmm0,xmm2
  414bb9:	e9 2b ff ff ff       	jmp    414ae9 <slm_sched_fprr_thd_update+0x79>
  414bbe:	48 bf 70 15 42 00 00 	movabs rdi,0x421570
  414bc5:	00 00 00 
  414bc8:	be 24 00 00 00       	mov    esi,0x24
  414bcd:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  414bd4:	00 00 00 
  414bd7:	ff d0                	call   rax
		assert(v >= SLM_FPRR_PRIO_HIGHEST && v <= SLM_FPRR_PRIO_LOWEST);
  414bd9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414be0:	00 00 00 00 
  414be4:	0f 0b                	ud2    
  414be6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  414bed:	00 00 00 

0000000000414bf0 <slm_sched_fprr_init>:

void
slm_sched_fprr_init(void)
{
  414bf0:	f3 0f 1e fa          	endbr64 
	int i;

	for (i = 0 ; i < SLM_FPRR_NPRIOS ; i++) {
  414bf4:	48 b8 00 4b 5a 00 00 	movabs rax,0x5a4b00
  414bfb:	00 00 00 
{ l->n = l->p = l; }
  414bfe:	66 48 0f 6e c0       	movq   xmm0,rax
		ps_list_head_init(&threads[cos_cpuid()].prio[i]);
  414c03:	48 8d 50 10          	lea    rdx,[rax+0x10]
  414c07:	48 8d 48 20          	lea    rcx,[rax+0x20]
  414c0b:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  414c0f:	48 8d 70 30          	lea    rsi,[rax+0x30]
  414c13:	48 8d 78 40          	lea    rdi,[rax+0x40]
  414c17:	0f 29 00             	movaps XMMWORD PTR [rax],xmm0
  414c1a:	66 48 0f 6e c2       	movq   xmm0,rdx
  414c1f:	48 8d 50 50          	lea    rdx,[rax+0x50]
  414c23:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  414c27:	0f 29 40 10          	movaps XMMWORD PTR [rax+0x10],xmm0
  414c2b:	66 48 0f 6e c1       	movq   xmm0,rcx
  414c30:	48 8d 48 60          	lea    rcx,[rax+0x60]
  414c34:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  414c38:	0f 29 40 20          	movaps XMMWORD PTR [rax+0x20],xmm0
  414c3c:	66 48 0f 6e c6       	movq   xmm0,rsi
  414c41:	48 8d 70 70          	lea    rsi,[rax+0x70]
  414c45:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  414c49:	0f 29 40 30          	movaps XMMWORD PTR [rax+0x30],xmm0
	for (i = 0 ; i < SLM_FPRR_NPRIOS ; i++) {
  414c4d:	66 48 0f 6e c7       	movq   xmm0,rdi
		ps_list_head_init(&threads[cos_cpuid()].prio[i]);
  414c52:	48 8d b8 80 00 00 00 	lea    rdi,[rax+0x80]
  414c59:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  414c5d:	0f 29 40 40          	movaps XMMWORD PTR [rax+0x40],xmm0
  414c61:	66 48 0f 6e c2       	movq   xmm0,rdx
  414c66:	48 83 c2 40          	add    rdx,0x40
  414c6a:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  414c6e:	0f 29 40 50          	movaps XMMWORD PTR [rax+0x50],xmm0
  414c72:	66 48 0f 6e c1       	movq   xmm0,rcx
  414c77:	48 83 c1 40          	add    rcx,0x40
  414c7b:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  414c7f:	0f 29 40 60          	movaps XMMWORD PTR [rax+0x60],xmm0
  414c83:	66 48 0f 6e c6       	movq   xmm0,rsi
  414c88:	48 83 c6 40          	add    rsi,0x40
  414c8c:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  414c90:	0f 29 40 70          	movaps XMMWORD PTR [rax+0x70],xmm0
  414c94:	66 48 0f 6e c7       	movq   xmm0,rdi
  414c99:	48 83 c7 40          	add    rdi,0x40
  414c9d:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  414ca1:	0f 29 80 80 00 00 00 	movaps XMMWORD PTR [rax+0x80],xmm0
  414ca8:	66 48 0f 6e c2       	movq   xmm0,rdx
  414cad:	48 83 c2 40          	add    rdx,0x40
  414cb1:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  414cb5:	0f 29 80 90 00 00 00 	movaps XMMWORD PTR [rax+0x90],xmm0
  414cbc:	66 48 0f 6e c1       	movq   xmm0,rcx
  414cc1:	48 83 c1 40          	add    rcx,0x40
  414cc5:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  414cc9:	0f 29 80 a0 00 00 00 	movaps XMMWORD PTR [rax+0xa0],xmm0
  414cd0:	66 48 0f 6e c6       	movq   xmm0,rsi
  414cd5:	48 83 c6 40          	add    rsi,0x40
  414cd9:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  414cdd:	0f 29 80 b0 00 00 00 	movaps XMMWORD PTR [rax+0xb0],xmm0
  414ce4:	66 48 0f 6e c7       	movq   xmm0,rdi
  414ce9:	48 83 c7 40          	add    rdi,0x40
  414ced:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  414cf1:	0f 29 80 c0 00 00 00 	movaps XMMWORD PTR [rax+0xc0],xmm0
  414cf8:	66 48 0f 6e c2       	movq   xmm0,rdx
  414cfd:	48 83 c2 40          	add    rdx,0x40
  414d01:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  414d05:	0f 29 80 d0 00 00 00 	movaps XMMWORD PTR [rax+0xd0],xmm0
  414d0c:	66 48 0f 6e c1       	movq   xmm0,rcx
  414d11:	48 83 c1 40          	add    rcx,0x40
  414d15:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  414d19:	0f 29 80 e0 00 00 00 	movaps XMMWORD PTR [rax+0xe0],xmm0
  414d20:	66 48 0f 6e c6       	movq   xmm0,rsi
  414d25:	48 83 c6 40          	add    rsi,0x40
  414d29:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  414d2d:	0f 29 80 f0 00 00 00 	movaps XMMWORD PTR [rax+0xf0],xmm0
  414d34:	66 48 0f 6e c7       	movq   xmm0,rdi
  414d39:	48 83 c7 40          	add    rdi,0x40
  414d3d:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  414d41:	0f 29 80 00 01 00 00 	movaps XMMWORD PTR [rax+0x100],xmm0
  414d48:	66 48 0f 6e c2       	movq   xmm0,rdx
  414d4d:	48 83 c2 40          	add    rdx,0x40
  414d51:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  414d55:	0f 29 80 10 01 00 00 	movaps XMMWORD PTR [rax+0x110],xmm0
  414d5c:	66 48 0f 6e c1       	movq   xmm0,rcx
  414d61:	48 83 c1 40          	add    rcx,0x40
  414d65:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  414d69:	0f 29 80 20 01 00 00 	movaps XMMWORD PTR [rax+0x120],xmm0
  414d70:	66 48 0f 6e c6       	movq   xmm0,rsi
  414d75:	48 83 c6 40          	add    rsi,0x40
  414d79:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  414d7d:	0f 29 80 30 01 00 00 	movaps XMMWORD PTR [rax+0x130],xmm0
  414d84:	66 48 0f 6e c7       	movq   xmm0,rdi
  414d89:	48 83 c7 40          	add    rdi,0x40
  414d8d:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  414d91:	0f 29 80 40 01 00 00 	movaps XMMWORD PTR [rax+0x140],xmm0
  414d98:	66 48 0f 6e c2       	movq   xmm0,rdx
  414d9d:	48 83 c2 40          	add    rdx,0x40
  414da1:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  414da5:	0f 29 80 50 01 00 00 	movaps XMMWORD PTR [rax+0x150],xmm0
  414dac:	66 48 0f 6e c1       	movq   xmm0,rcx
  414db1:	48 83 c1 40          	add    rcx,0x40
  414db5:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  414db9:	0f 29 80 60 01 00 00 	movaps XMMWORD PTR [rax+0x160],xmm0
  414dc0:	66 48 0f 6e c6       	movq   xmm0,rsi
  414dc5:	48 83 c6 40          	add    rsi,0x40
  414dc9:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  414dcd:	0f 29 80 70 01 00 00 	movaps XMMWORD PTR [rax+0x170],xmm0
  414dd4:	66 48 0f 6e c7       	movq   xmm0,rdi
  414dd9:	48 83 c7 40          	add    rdi,0x40
  414ddd:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  414de1:	0f 29 80 80 01 00 00 	movaps XMMWORD PTR [rax+0x180],xmm0
  414de8:	66 48 0f 6e c2       	movq   xmm0,rdx
  414ded:	48 83 c2 40          	add    rdx,0x40
  414df1:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  414df5:	0f 29 80 90 01 00 00 	movaps XMMWORD PTR [rax+0x190],xmm0
  414dfc:	66 48 0f 6e c1       	movq   xmm0,rcx
  414e01:	48 83 c1 40          	add    rcx,0x40
  414e05:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  414e09:	0f 29 80 a0 01 00 00 	movaps XMMWORD PTR [rax+0x1a0],xmm0
  414e10:	66 48 0f 6e c6       	movq   xmm0,rsi
  414e15:	48 83 c6 40          	add    rsi,0x40
  414e19:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  414e1d:	0f 29 80 b0 01 00 00 	movaps XMMWORD PTR [rax+0x1b0],xmm0
  414e24:	66 48 0f 6e c7       	movq   xmm0,rdi
  414e29:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  414e2d:	0f 29 80 c0 01 00 00 	movaps XMMWORD PTR [rax+0x1c0],xmm0
  414e34:	66 48 0f 6e c2       	movq   xmm0,rdx
  414e39:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  414e3d:	0f 29 80 d0 01 00 00 	movaps XMMWORD PTR [rax+0x1d0],xmm0
  414e44:	66 48 0f 6e c1       	movq   xmm0,rcx
  414e49:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  414e4d:	0f 29 80 e0 01 00 00 	movaps XMMWORD PTR [rax+0x1e0],xmm0
  414e54:	66 48 0f 6e c6       	movq   xmm0,rsi
  414e59:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  414e5d:	0f 29 80 f0 01 00 00 	movaps XMMWORD PTR [rax+0x1f0],xmm0
	}
}
  414e64:	c3                   	ret    
  414e65:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  414e6c:	00 00 00 
  414e6f:	90                   	nop
#include <cos_debug.h>

/* Override this to do initialization before idle computation */
CWEAKSYMB void slm_idle_comp_initialization(void) { return; }
  414e70:	f3 0f 1e fa          	endbr64 
  414e74:	c3                   	ret    
  414e75:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  414e7c:	00 00 00 00 

0000000000414e80 <slm_idle_iteration>:
  414e80:	f3 0f 1e fa          	endbr64 
  414e84:	c3                   	ret    
  414e85:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  414e8c:	00 00 00 00 

0000000000414e90 <slm_idle>:
/* Override this to do repetitive computation in idle */
CWEAKSYMB void slm_idle_iteration(void) { return; }

void
slm_idle(void *d)
{
  414e90:	f3 0f 1e fa          	endbr64 
	slm_idle_comp_initialization();
  414e94:	48 b8 a0 06 40 00 00 	movabs rax,0x4006a0
  414e9b:	00 00 00 
{
  414e9e:	55                   	push   rbp
  414e9f:	48 89 e5             	mov    rbp,rsp
  414ea2:	53                   	push   rbx
  414ea3:	48 bb 80 4e 41 00 00 	movabs rbx,0x414e80
  414eaa:	00 00 00 
  414ead:	48 83 ec 08          	sub    rsp,0x8
	slm_idle_comp_initialization();
  414eb1:	ff d0                	call   rax

	while (1) {
		slm_idle_iteration();
  414eb3:	ff d3                	call   rbx
  414eb5:	ff d3                	call   rbx
	while (1) {
  414eb7:	eb fa                	jmp    414eb3 <slm_idle+0x23>
  414eb9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000414ec0 <__slm_timeout_update_idx>:
	return slm_thd_timer_policy((struct slm_thd *)a)->abs_wakeup <= slm_thd_timer_policy((struct slm_thd *)b)->abs_wakeup;
}

static void
__slm_timeout_update_idx(void *e, int pos)
{ slm_thd_timer_policy((struct slm_thd *)e)->timeout_idx = pos; }
  414ec0:	f3 0f 1e fa          	endbr64 
  414ec4:	48 b8 d0 1b 40 00 00 	movabs rax,0x401bd0
  414ecb:	00 00 00 
  414ece:	55                   	push   rbp
  414ecf:	48 89 e5             	mov    rbp,rsp
  414ed2:	53                   	push   rbx
  414ed3:	89 f3                	mov    ebx,esi
  414ed5:	48 83 ec 08          	sub    rsp,0x8
  414ed9:	ff d0                	call   rax
  414edb:	89 18                	mov    DWORD PTR [rax],ebx
  414edd:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
  414ee1:	c9                   	leave  
  414ee2:	c3                   	ret    
  414ee3:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  414eea:	00 00 00 00 
  414eee:	66 90                	xchg   ax,ax

0000000000414ef0 <__slm_timeout_compare_min>:
{
  414ef0:	f3 0f 1e fa          	endbr64 
  414ef4:	55                   	push   rbp
  414ef5:	48 89 e5             	mov    rbp,rsp
  414ef8:	41 55                	push   r13
  414efa:	41 54                	push   r12
  414efc:	49 89 f4             	mov    r12,rsi
  414eff:	53                   	push   rbx
	return slm_thd_timer_policy((struct slm_thd *)a)->abs_wakeup <= slm_thd_timer_policy((struct slm_thd *)b)->abs_wakeup;
  414f00:	48 bb d0 1b 40 00 00 	movabs rbx,0x401bd0
  414f07:	00 00 00 
{
  414f0a:	48 83 ec 08          	sub    rsp,0x8
	return slm_thd_timer_policy((struct slm_thd *)a)->abs_wakeup <= slm_thd_timer_policy((struct slm_thd *)b)->abs_wakeup;
  414f0e:	ff d3                	call   rbx
  414f10:	4c 89 e7             	mov    rdi,r12
  414f13:	4c 8b 68 08          	mov    r13,QWORD PTR [rax+0x8]
  414f17:	ff d3                	call   rbx
  414f19:	4c 3b 68 08          	cmp    r13,QWORD PTR [rax+0x8]
  414f1d:	0f 96 c0             	setbe  al
}
  414f20:	48 83 c4 08          	add    rsp,0x8
  414f24:	5b                   	pop    rbx
	return slm_thd_timer_policy((struct slm_thd *)a)->abs_wakeup <= slm_thd_timer_policy((struct slm_thd *)b)->abs_wakeup;
  414f25:	0f b6 c0             	movzx  eax,al
}
  414f28:	41 5c                	pop    r12
  414f2a:	41 5d                	pop    r13
  414f2c:	5d                   	pop    rbp
  414f2d:	c3                   	ret    
  414f2e:	66 90                	xchg   ax,ax

0000000000414f30 <slm_timer_quantum_expire>:
{
  414f30:	f3 0f 1e fa          	endbr64 
  414f34:	55                   	push   rbp
  414f35:	48 89 e5             	mov    rbp,rsp
  414f38:	41 57                	push   r15
  414f3a:	41 56                	push   r14
  414f3c:	41 55                	push   r13
  414f3e:	41 54                	push   r12
	assert(now >= g->current_timeout);
  414f40:	49 bc 00 4d 5a 00 00 	movabs r12,0x5a4d00
  414f47:	00 00 00 
{
  414f4a:	53                   	push   rbx
  414f4b:	48 83 ec 08          	sub    rsp,0x8
	assert(now >= g->current_timeout);
  414f4f:	49 8b 94 24 f0 00 00 	mov    rdx,QWORD PTR [r12+0xf0]
  414f56:	00 
  414f57:	48 39 fa             	cmp    rdx,rdi
  414f5a:	0f 87 95 01 00 00    	ja     4150f5 <slm_timer_quantum_expire+0x1c5>
	offset = (now - g->current_timeout) % g->period;
  414f60:	48 b8 e8 4d 5a 00 00 	movabs rax,0x5a4de8
  414f67:	00 00 00 
  414f6a:	48 8b 30             	mov    rsi,QWORD PTR [rax]
  414f6d:	48 89 f8             	mov    rax,rdi
  414f70:	48 89 fb             	mov    rbx,rdi
  414f73:	48 29 d0             	sub    rax,rdx
  414f76:	31 d2                	xor    edx,edx
  414f78:	48 f7 f6             	div    rsi
	next_timeout = now + (g->period - offset);
  414f7b:	48 8d 0c 3e          	lea    rcx,[rsi+rdi*1]
  414f7f:	48 29 d1             	sub    rcx,rdx
	assert(next_timeout > now);
  414f82:	48 39 cf             	cmp    rdi,rcx
  414f85:	0f 83 92 01 00 00    	jae    41511d <slm_timer_quantum_expire+0x1ed>
slm_timeout_set(cycles_t timeout)
{
	struct slm_global *g = slm_global();

	g->timeout_next = tcap_cyc2time(timeout);
	g->timer_next   = timeout;
  414f8b:	48 85 c9             	test   rcx,rcx
  414f8e:	ba 01 00 00 00       	mov    edx,0x1
  414f93:	66 48 0f 6e c1       	movq   xmm0,rcx
	g->current_timeout = next_timeout;
  414f98:	48 89 c8             	mov    rax,rcx
  414f9b:	48 0f 45 d1          	cmovne rdx,rcx
	while (heap_size(&g->h) > 0) {
  414f9f:	4c 89 e7             	mov    rdi,r12
	g->current_timeout = next_timeout;
  414fa2:	48 a3 f0 4d 5a 00 00 	movabs ds:0x5a4df0,rax
  414fa9:	00 00 00 
  414fac:	49 bd 10 78 41 00 00 	movabs r13,0x417810
  414fb3:	00 00 00 
  414fb6:	66 48 0f 6e ca       	movq   xmm1,rdx
  414fbb:	48 ba c0 5e 5a 00 00 	movabs rdx,0x5a5ec0
  414fc2:	00 00 00 
	g->timer_set    = 1;
  414fc5:	c7 82 fc 00 00 00 01 	mov    DWORD PTR [rdx+0xfc],0x1
  414fcc:	00 00 00 
	g->timer_next   = timeout;
  414fcf:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  414fd3:	0f 29 82 00 01 00 00 	movaps XMMWORD PTR [rdx+0x100],xmm0
	while (heap_size(&g->h) > 0) {
  414fda:	41 ff d5             	call   r13
  414fdd:	85 c0                	test   eax,eax
  414fdf:	0f 8e 89 00 00 00    	jle    41506e <slm_timer_quantum_expire+0x13e>
		tp = heap_peek(&g->h);
  414fe5:	48 b8 d0 74 41 00 00 	movabs rax,0x4174d0
  414fec:	00 00 00 
  414fef:	4c 89 e7             	mov    rdi,r12
  414ff2:	ff d0                	call   rax
  414ff4:	49 89 c7             	mov    r15,rax
		assert(tp);
  414ff7:	48 85 c0             	test   rax,rax
  414ffa:	0f 84 a5 00 00 00    	je     4150a5 <slm_timer_quantum_expire+0x175>
		tt = slm_thd_timer_policy(tp);
  415000:	48 89 c7             	mov    rdi,rax
  415003:	48 b8 d0 1b 40 00 00 	movabs rax,0x401bd0
  41500a:	00 00 00 
  41500d:	ff d0                	call   rax
  41500f:	49 89 c6             	mov    r14,rax
		assert(tt && tt->timeout_idx > 0);
  415012:	48 85 c0             	test   rax,rax
  415015:	74 66                	je     41507d <slm_timer_quantum_expire+0x14d>
  415017:	8b 00                	mov    eax,DWORD PTR [rax]
  415019:	85 c0                	test   eax,eax
  41501b:	7e 60                	jle    41507d <slm_timer_quantum_expire+0x14d>
	return (s64_t)(g - l) > 0;
  41501d:	49 8b 46 08          	mov    rax,QWORD PTR [r14+0x8]
  415021:	48 29 d8             	sub    rax,rbx
		if (cycles_greater_than(tt->abs_wakeup, now)) break;
  415024:	48 85 c0             	test   rax,rax
  415027:	7f 45                	jg     41506e <slm_timer_quantum_expire+0x13e>
		th = heap_highest(&g->h);
  415029:	48 b8 40 73 41 00 00 	movabs rax,0x417340
  415030:	00 00 00 
  415033:	4c 89 e7             	mov    rdi,r12
  415036:	ff d0                	call   rax
		assert(th == tp);
  415038:	49 39 c7             	cmp    r15,rax
  41503b:	0f 85 8c 00 00 00    	jne    4150cd <slm_timer_quantum_expire+0x19d>
		slm_thd_wakeup(th, 1);
  415041:	4c 89 ff             	mov    rdi,r15
		tt->abs_wakeup  = now;
  415044:	49 89 5e 08          	mov    QWORD PTR [r14+0x8],rbx
		slm_thd_wakeup(th, 1);
  415048:	be 01 00 00 00       	mov    esi,0x1
  41504d:	48 b8 c0 66 41 00 00 	movabs rax,0x4166c0
  415054:	00 00 00 
		tt->timeout_idx = -1;
  415057:	41 c7 06 ff ff ff ff 	mov    DWORD PTR [r14],0xffffffff
		slm_thd_wakeup(th, 1);
  41505e:	ff d0                	call   rax
	while (heap_size(&g->h) > 0) {
  415060:	4c 89 e7             	mov    rdi,r12
  415063:	41 ff d5             	call   r13
  415066:	85 c0                	test   eax,eax
  415068:	0f 8f 77 ff ff ff    	jg     414fe5 <slm_timer_quantum_expire+0xb5>
}
  41506e:	48 83 c4 08          	add    rsp,0x8
  415072:	5b                   	pop    rbx
  415073:	41 5c                	pop    r12
  415075:	41 5d                	pop    r13
  415077:	41 5e                	pop    r14
  415079:	41 5f                	pop    r15
  41507b:	5d                   	pop    rbp
  41507c:	c3                   	ret    
  41507d:	48 bf 10 16 42 00 00 	movabs rdi,0x421610
  415084:	00 00 00 
  415087:	be 26 00 00 00       	mov    esi,0x26
  41508c:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  415093:	00 00 00 
  415096:	ff d0                	call   rax
		assert(tt && tt->timeout_idx > 0);
  415098:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41509f:	00 00 00 00 
  4150a3:	0f 0b                	ud2    
  4150a5:	48 bf e8 15 42 00 00 	movabs rdi,0x4215e8
  4150ac:	00 00 00 
  4150af:	be 26 00 00 00       	mov    esi,0x26
  4150b4:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4150bb:	00 00 00 
  4150be:	ff d0                	call   rax
		assert(tp);
  4150c0:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4150c7:	00 00 00 00 
  4150cb:	0f 0b                	ud2    
  4150cd:	48 bf 38 16 42 00 00 	movabs rdi,0x421638
  4150d4:	00 00 00 
  4150d7:	be 26 00 00 00       	mov    esi,0x26
  4150dc:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4150e3:	00 00 00 
  4150e6:	ff d0                	call   rax
		assert(th == tp);
  4150e8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4150ef:	00 00 00 00 
  4150f3:	0f 0b                	ud2    
  4150f5:	48 bf 98 15 42 00 00 	movabs rdi,0x421598
  4150fc:	00 00 00 
  4150ff:	be 26 00 00 00       	mov    esi,0x26
  415104:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  41510b:	00 00 00 
  41510e:	ff d0                	call   rax
	assert(now >= g->current_timeout);
  415110:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  415117:	00 00 00 00 
  41511b:	0f 0b                	ud2    
  41511d:	48 bf c0 15 42 00 00 	movabs rdi,0x4215c0
  415124:	00 00 00 
  415127:	be 26 00 00 00       	mov    esi,0x26
  41512c:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  415133:	00 00 00 
  415136:	ff d0                	call   rax
	assert(next_timeout > now);
  415138:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41513f:	00 00 00 00 
  415143:	0f 0b                	ud2    
  415145:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41514c:	00 00 00 00 

0000000000415150 <slm_timer_quantum_add>:
{
  415150:	f3 0f 1e fa          	endbr64 
	struct slm_timer_thd *tt = slm_thd_timer_policy(t);
  415154:	48 b8 d0 1b 40 00 00 	movabs rax,0x401bd0
  41515b:	00 00 00 
{
  41515e:	55                   	push   rbp
  41515f:	48 89 e5             	mov    rbp,rsp
  415162:	41 56                	push   r14
  415164:	41 55                	push   r13
  415166:	49 89 f5             	mov    r13,rsi
  415169:	41 54                	push   r12
  41516b:	49 89 fc             	mov    r12,rdi
  41516e:	53                   	push   rbx
	struct slm_timer_thd *tt = slm_thd_timer_policy(t);
  41516f:	ff d0                	call   rax
	assert(tt && tt->timeout_idx == -1);
  415171:	48 85 c0             	test   rax,rax
  415174:	74 47                	je     4151bd <slm_timer_quantum_add+0x6d>
  415176:	83 38 ff             	cmp    DWORD PTR [rax],0xffffffff
  415179:	48 89 c3             	mov    rbx,rax
  41517c:	75 3f                	jne    4151bd <slm_timer_quantum_add+0x6d>
	assert(heap_size(&g->h) < MAX_NUM_THREADS);
  41517e:	49 be 00 4d 5a 00 00 	movabs r14,0x5a4d00
  415185:	00 00 00 
  415188:	48 b8 10 78 41 00 00 	movabs rax,0x417810
  41518f:	00 00 00 
  415192:	4c 89 f7             	mov    rdi,r14
  415195:	ff d0                	call   rax
  415197:	83 f8 18             	cmp    eax,0x18
  41519a:	7f 49                	jg     4151e5 <slm_timer_quantum_add+0x95>
	tt->abs_wakeup = absolute_timeout;
  41519c:	4c 89 6b 08          	mov    QWORD PTR [rbx+0x8],r13
	heap_add(&g->h, t);
  4151a0:	4c 89 e6             	mov    rsi,r12
  4151a3:	4c 89 f7             	mov    rdi,r14
  4151a6:	48 b8 e0 70 41 00 00 	movabs rax,0x4170e0
  4151ad:	00 00 00 
  4151b0:	ff d0                	call   rax
}
  4151b2:	5b                   	pop    rbx
  4151b3:	31 c0                	xor    eax,eax
  4151b5:	41 5c                	pop    r12
  4151b7:	41 5d                	pop    r13
  4151b9:	41 5e                	pop    r14
  4151bb:	5d                   	pop    rbp
  4151bc:	c3                   	ret    
  4151bd:	48 bf 60 16 42 00 00 	movabs rdi,0x421660
  4151c4:	00 00 00 
  4151c7:	be 26 00 00 00       	mov    esi,0x26
  4151cc:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4151d3:	00 00 00 
  4151d6:	ff d0                	call   rax
	assert(tt && tt->timeout_idx == -1);
  4151d8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4151df:	00 00 00 00 
  4151e3:	0f 0b                	ud2    
  4151e5:	48 bf 88 16 42 00 00 	movabs rdi,0x421688
  4151ec:	00 00 00 
  4151ef:	be 26 00 00 00       	mov    esi,0x26
  4151f4:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4151fb:	00 00 00 
  4151fe:	ff d0                	call   rax
	assert(heap_size(&g->h) < MAX_NUM_THREADS);
  415200:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  415207:	00 00 00 00 
  41520b:	0f 0b                	ud2    
  41520d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000415210 <slm_timer_quantum_cancel>:
{
  415210:	f3 0f 1e fa          	endbr64 
	struct slm_timer_thd *tt = slm_thd_timer_policy(t);
  415214:	48 b8 d0 1b 40 00 00 	movabs rax,0x401bd0
  41521b:	00 00 00 
{
  41521e:	55                   	push   rbp
  41521f:	48 89 e5             	mov    rbp,rsp
  415222:	41 54                	push   r12
  415224:	53                   	push   rbx
	struct slm_timer_thd *tt = slm_thd_timer_policy(t);
  415225:	ff d0                	call   rax
	if (tt->timeout_idx == -1) return 0;
  415227:	83 38 ff             	cmp    DWORD PTR [rax],0xffffffff
  41522a:	74 3b                	je     415267 <slm_timer_quantum_cancel+0x57>
	assert(heap_size(&g->h));
  41522c:	49 bc 00 4d 5a 00 00 	movabs r12,0x5a4d00
  415233:	00 00 00 
  415236:	48 89 c3             	mov    rbx,rax
  415239:	48 b8 10 78 41 00 00 	movabs rax,0x417810
  415240:	00 00 00 
  415243:	4c 89 e7             	mov    rdi,r12
  415246:	ff d0                	call   rax
  415248:	85 c0                	test   eax,eax
  41524a:	74 22                	je     41526e <slm_timer_quantum_cancel+0x5e>
	assert(tt->timeout_idx > 0);
  41524c:	8b 33                	mov    esi,DWORD PTR [rbx]
  41524e:	85 f6                	test   esi,esi
  415250:	7e 44                	jle    415296 <slm_timer_quantum_cancel+0x86>
	heap_remove(&g->h, tt->timeout_idx);
  415252:	48 b8 30 77 41 00 00 	movabs rax,0x417730
  415259:	00 00 00 
  41525c:	4c 89 e7             	mov    rdi,r12
  41525f:	ff d0                	call   rax
	tt->timeout_idx = -1;
  415261:	c7 03 ff ff ff ff    	mov    DWORD PTR [rbx],0xffffffff
}
  415267:	5b                   	pop    rbx
  415268:	31 c0                	xor    eax,eax
  41526a:	41 5c                	pop    r12
  41526c:	5d                   	pop    rbp
  41526d:	c3                   	ret    
  41526e:	48 bf b0 16 42 00 00 	movabs rdi,0x4216b0
  415275:	00 00 00 
  415278:	be 27 00 00 00       	mov    esi,0x27
  41527d:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  415284:	00 00 00 
  415287:	ff d0                	call   rax
	assert(heap_size(&g->h));
  415289:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  415290:	00 00 00 00 
  415294:	0f 0b                	ud2    
  415296:	48 bf d8 16 42 00 00 	movabs rdi,0x4216d8
  41529d:	00 00 00 
  4152a0:	be 27 00 00 00       	mov    esi,0x27
  4152a5:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4152ac:	00 00 00 
  4152af:	ff d0                	call   rax
	assert(tt->timeout_idx > 0);
  4152b1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4152b8:	00 00 00 00 
  4152bc:	0f 0b                	ud2    
  4152be:	66 90                	xchg   ax,ax

00000000004152c0 <slm_timer_quantum_thd_init>:
{
  4152c0:	f3 0f 1e fa          	endbr64 
	struct slm_timer_thd *tt = slm_thd_timer_policy(t);
  4152c4:	48 b8 d0 1b 40 00 00 	movabs rax,0x401bd0
  4152cb:	00 00 00 
{
  4152ce:	55                   	push   rbp
  4152cf:	48 89 e5             	mov    rbp,rsp
	struct slm_timer_thd *tt = slm_thd_timer_policy(t);
  4152d2:	ff d0                	call   rax
	*tt = (struct slm_timer_thd){
  4152d4:	c7 00 ff ff ff ff    	mov    DWORD PTR [rax],0xffffffff
  4152da:	48 c7 40 08 00 00 00 	mov    QWORD PTR [rax+0x8],0x0
  4152e1:	00 
}
  4152e2:	31 c0                	xor    eax,eax
  4152e4:	5d                   	pop    rbp
  4152e5:	c3                   	ret    
  4152e6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4152ed:	00 00 00 

00000000004152f0 <slm_timer_quantum_thd_deinit>:
{
  4152f0:	f3 0f 1e fa          	endbr64 
}
  4152f4:	c3                   	ret    
  4152f5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4152fc:	00 00 00 00 

0000000000415300 <slm_timer_quantum_init>:
	slm_timeout_set(next_timeout);
}

int
slm_timer_quantum_init(void)
{
  415300:	f3 0f 1e fa          	endbr64 
  415304:	55                   	push   rbp
	memset(g, 0, sizeof(struct timer_global));
  415305:	31 c0                	xor    eax,eax
  415307:	b9 20 00 00 00       	mov    ecx,0x20
	heap_init(&g->h, MAX_NUM_THREADS, __slm_timeout_compare_min, __slm_timeout_update_idx);
  41530c:	be 19 00 00 00       	mov    esi,0x19
  415311:	48 ba f0 4e 41 00 00 	movabs rdx,0x414ef0
  415318:	00 00 00 
{
  41531b:	48 89 e5             	mov    rbp,rsp
  41531e:	41 54                	push   r12
	memset(g, 0, sizeof(struct timer_global));
  415320:	49 bc 00 4d 5a 00 00 	movabs r12,0x5a4d00
  415327:	00 00 00 
{
  41532a:	53                   	push   rbx
	memset(g, 0, sizeof(struct timer_global));
  41532b:	4c 89 e7             	mov    rdi,r12
	return usec * slm_global()->cyc_per_usec;
  41532e:	48 bb c0 5e 5a 00 00 	movabs rbx,0x5a5ec0
  415335:	00 00 00 
  415338:	f3 48 ab             	rep stos QWORD PTR es:[rdi],rax
  41533b:	48 63 83 f8 00 00 00 	movsxd rax,DWORD PTR [rbx+0xf8]
	heap_init(&g->h, MAX_NUM_THREADS, __slm_timeout_compare_min, __slm_timeout_update_idx);
  415342:	4c 89 e7             	mov    rdi,r12
  415345:	48 b9 c0 4e 41 00 00 	movabs rcx,0x414ec0
  41534c:	00 00 00 
  41534f:	48 69 c0 10 27 00 00 	imul   rax,rax,0x2710
	g->period = slm_usec2cyc(period);
  415356:	49 89 84 24 e8 00 00 	mov    QWORD PTR [r12+0xe8],rax
  41535d:	00 
	heap_init(&g->h, MAX_NUM_THREADS, __slm_timeout_compare_min, __slm_timeout_update_idx);
  41535e:	48 b8 30 70 41 00 00 	movabs rax,0x417030
  415365:	00 00 00 
  415368:	ff d0                	call   rax
	__asm__ __volatile__("rdtsc" : "=a" (a), "=d" (d), "=c" (c) : : );
  41536a:	0f 31                	rdtsc  
	g->timer_set    = 1;
  41536c:	c7 83 fc 00 00 00 01 	mov    DWORD PTR [rbx+0xfc],0x1
  415373:	00 00 00 
	return ((u64_t)d << 32) | (u64_t)a;
  415376:	48 c1 e2 20          	shl    rdx,0x20
  41537a:	48 09 c2             	or     rdx,rax
	next_timeout = slm_now() + g->period;
  41537d:	48 89 d0             	mov    rax,rdx
	g->timer_next   = timeout;
  415380:	ba 01 00 00 00       	mov    edx,0x1
  415385:	49 03 84 24 e8 00 00 	add    rax,QWORD PTR [r12+0xe8]
  41538c:	00 
  41538d:	48 0f 45 d0          	cmovne rdx,rax
  415391:	66 48 0f 6e c0       	movq   xmm0,rax
	g->current_timeout = next_timeout;
  415396:	49 89 84 24 f0 00 00 	mov    QWORD PTR [r12+0xf0],rax
  41539d:	00 
	/* 10ms */
	slm_policy_timer_init(10000);

	return 0;
}
  41539e:	31 c0                	xor    eax,eax
  4153a0:	66 48 0f 6e ca       	movq   xmm1,rdx
  4153a5:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  4153a9:	0f 29 83 00 01 00 00 	movaps XMMWORD PTR [rbx+0x100],xmm0
  4153b0:	5b                   	pop    rbx
  4153b1:	41 5c                	pop    r12
  4153b3:	5d                   	pop    rbp
  4153b4:	c3                   	ret    
  4153b5:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4153bc:	00 00 00 
  4153bf:	90                   	nop

00000000004153c0 <prints.isra.0>:
prints(char *s)
  4153c0:	f3 0f 1e fa          	endbr64 
	return cos_print_str(s, strlen(s));
  4153c4:	48 b8 90 84 41 00 00 	movabs rax,0x418490
  4153cb:	00 00 00 
prints(char *s)
  4153ce:	55                   	push   rbp
  4153cf:	48 89 e5             	mov    rbp,rsp
  4153d2:	41 54                	push   r12
  4153d4:	49 89 fc             	mov    r12,rdi
  4153d7:	48 83 ec 08          	sub    rsp,0x8
	return cos_print_str(s, strlen(s));
  4153db:	ff d0                	call   rax
  4153dd:	4c 89 e7             	mov    rdi,r12
}
  4153e0:	4c 8b 65 f8          	mov    r12,QWORD PTR [rbp-0x8]
  4153e4:	c9                   	leave  
	return cos_print_str(s, strlen(s));
  4153e5:	89 c6                	mov    esi,eax
  4153e7:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4153ee:	00 00 00 
  4153f1:	ff e0                	jmp    rax
  4153f3:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4153fa:	00 00 00 00 
  4153fe:	66 90                	xchg   ax,ax

0000000000415400 <slm_sched_loop_intern>:
	return (unsigned long)g->cyc_per_usec;
}

static void
slm_sched_loop_intern(int non_block)
{
  415400:	f3 0f 1e fa          	endbr64 
  415404:	55                   	push   rbp
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  415405:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  415408:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  41540e:	48 89 e5             	mov    rbp,rsp
  415411:	41 57                	push   r15
	struct slm_global *g = slm_global();
	rcv_flags_t      rfl = (non_block ? RCV_NON_BLOCKING : 0) | RCV_ALL_PENDING;
  415413:	44 8d 7f 02          	lea    r15d,[rdi+0x2]
{
  415417:	41 56                	push   r14
	struct slm_thd   *us = &g->sched_thd;
	struct slm_thd *t = NULL, *tn = NULL;

	/* Only the scheduler thread should call this function. */
	assert(cos_thdid() == us->tid);
  415419:	49 be c0 5e 5a 00 00 	movabs r14,0x5a5ec0
  415420:	00 00 00 
{
  415423:	41 55                	push   r13
  415425:	41 54                	push   r12
  415427:	53                   	push   rbx
  415428:	48 83 ec 38          	sub    rsp,0x38
	return cos_get_thd_id();
  41542c:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
	assert(cos_thdid() == us->tid);
  415433:	49 39 46 20          	cmp    QWORD PTR [r14+0x20],rax
  415437:	0f 85 44 05 00 00    	jne    415981 <slm_sched_loop_intern+0x581>
			 * if `non_block` is `0`.
			 *
			 * Important that this is *not* in the CS due
			 * to the potential blocking.
			 */
			pending = cos_sched_rcv(us->rcv, rfl, g->timeout_next, &rcvd, &tid, &blocked, &cycles, &thd_timeout);
  41543d:	48 8d 45 c8          	lea    rax,[rbp-0x38]
  415441:	48 8d 4d b4          	lea    rcx,[rbp-0x4c]
  415445:	44 89 fe             	mov    esi,r15d
  415448:	50                   	push   rax
  415449:	48 8d 45 c0          	lea    rax,[rbp-0x40]
  41544d:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  415451:	50                   	push   rax
  415452:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  415456:	48 b8 c8 5f 5a 00 00 	movabs rax,0x5a5fc8
  41545d:	00 00 00 
  415460:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  415463:	48 8b b8 20 ff ff ff 	mov    rdi,QWORD PTR [rax-0xe0]
  41546a:	48 b8 20 37 41 00 00 	movabs rax,0x413720
  415471:	00 00 00 
  415474:	ff d0                	call   rax
			if (!tid) goto pending_events;
  415476:	48 8b 7d b8          	mov    rdi,QWORD PTR [rbp-0x48]
  41547a:	59                   	pop    rcx
			pending = cos_sched_rcv(us->rcv, rfl, g->timeout_next, &rcvd, &tid, &blocked, &cycles, &thd_timeout);
  41547b:	89 45 ac             	mov    DWORD PTR [rbp-0x54],eax
			if (!tid) goto pending_events;
  41547e:	5e                   	pop    rsi
  41547f:	48 85 ff             	test   rdi,rdi
  415482:	74 64                	je     4154e8 <slm_sched_loop_intern+0xe8>
			 * pointer back here that we can use instead
			 * of the tid. This is the only place where
			 * slm requires the thread id -> thread
			 * mapping ;-(
			 */
			t = slm_thd_lookup(tid);
  415484:	48 b8 00 1d 40 00 00 	movabs rax,0x401d00
  41548b:	00 00 00 
  41548e:	ff d0                	call   rax
  415490:	48 89 c2             	mov    rdx,rax
			assert(t);
  415493:	48 85 c0             	test   rax,rax
  415496:	0f 84 08 05 00 00    	je     4159a4 <slm_sched_loop_intern+0x5a4>
			/* don't report the idle thread or a freed thread */
			if (unlikely(t == &g->idle_thd || slm_state_is_dead(t->state))) goto pending_events;
  41549c:	48 b8 40 5f 5a 00 00 	movabs rax,0x5a5f40
  4154a3:	00 00 00 
  4154a6:	48 39 c2             	cmp    rdx,rax
  4154a9:	74 3d                	je     4154e8 <slm_sched_loop_intern+0xe8>
  4154ab:	f7 42 04 fb ff ff ff 	test   DWORD PTR [rdx+0x4],0xfffffffb
  4154b2:	74 34                	je     4154e8 <slm_sched_loop_intern+0xe8>
			 * allow the scheduler thread to switch to the
			 * CS holder, and switch back when the CS
			 * holder releases the CS (thus allowing the
			 * events to be processed at that point.
			 */
			slm_thd_event_enqueue(t, blocked, cycles, thd_timeout);
  4154b4:	48 8b 7d c8          	mov    rdi,QWORD PTR [rbp-0x38]
  4154b8:	48 8b 4d c0          	mov    rcx,QWORD PTR [rbp-0x40]
	if (ps_list_singleton(t, thd_list)) ps_list_head_append(&g->event_head, t, thd_list);
  4154bc:	48 8d 72 58          	lea    rsi,[rdx+0x58]
			slm_thd_event_enqueue(t, blocked, cycles, thd_timeout);
  4154c0:	44 8b 45 b0          	mov    r8d,DWORD PTR [rbp-0x50]
	if (ps_list_singleton(t, thd_list)) ps_list_head_append(&g->event_head, t, thd_list);
  4154c4:	48 3b 72 58          	cmp    rsi,QWORD PTR [rdx+0x58]
  4154c8:	0f 84 c1 03 00 00    	je     41588f <slm_sched_loop_intern+0x48f>
	t->event_info.cycles += cycles;
  4154ce:	48 03 4a 48          	add    rcx,QWORD PTR [rdx+0x48]
  4154d2:	66 48 0f 6e cf       	movq   xmm1,rdi
	t->event_info.blocked = blocked;
  4154d7:	44 89 42 40          	mov    DWORD PTR [rdx+0x40],r8d
	t->event_info.cycles += cycles;
  4154db:	66 48 0f 6e c1       	movq   xmm0,rcx
  4154e0:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  4154e4:	0f 11 42 48          	movups XMMWORD PTR [rdx+0x48],xmm0

pending_events:
			/* No events? make a scheduling decision */
			if (ps_list_head_empty(&g->event_head)) break;
  4154e8:	48 b8 d0 5f 5a 00 00 	movabs rax,0x5a5fd0
  4154ef:	00 00 00 
  4154f2:	48 bb d0 35 41 00 00 	movabs rbx,0x4135d0
  4154f9:	00 00 00 
  4154fc:	49 39 86 10 01 00 00 	cmp    QWORD PTR [r14+0x110],rax
  415503:	0f 84 a8 01 00 00    	je     4156b1 <slm_sched_loop_intern+0x2b1>
		tok    = cos_sched_sync();
  415509:	ff d3                	call   rbx
  41550b:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  41550d:	49 8b 06             	mov    rax,QWORD PTR [r14]
		if (unlikely(owner)) {
  415510:	48 89 c2             	mov    rdx,rax
  415513:	48 83 e2 fe          	and    rdx,0xfffffffffffffffe
  415517:	0f 85 9d 03 00 00    	jne    4158ba <slm_sched_loop_intern+0x4ba>
        __asm__ __volatile__("lock " PS_CAS_STR
  41551d:	48 b9 c8 5e 5a 00 00 	movabs rcx,0x5a5ec8
  415524:	00 00 00 
  415527:	f0 49 0f b1 0e       	lock cmpxchg QWORD PTR [r14],rcx
  41552c:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  41552f:	84 c0                	test   al,al
  415531:	74 d6                	je     415509 <slm_sched_loop_intern+0x109>
			 *
			 * Thus we process the events now, with the CS taken.
			 */
			if (slm_cs_enter(us, SLM_CS_SCHEDEVT)) continue;

			ps_list_foreach_del(&g->event_head, t, tn, thd_list) {
  415533:	48 a1 d0 5f 5a 00 00 	movabs rax,ds:0x5a5fd0
  41553a:	00 00 00 
  41553d:	48 bf 78 5f 5a 00 00 	movabs rdi,0x5a5f78
  415544:	00 00 00 
  415547:	4c 8d 68 a8          	lea    r13,[rax-0x58]
  41554b:	48 8b 00             	mov    rax,QWORD PTR [rax]
  41554e:	4c 8d 60 a8          	lea    r12,[rax-0x58]
  415552:	49 39 fd             	cmp    r13,rdi
  415555:	0f 84 eb 00 00 00    	je     415646 <slm_sched_loop_intern+0x246>
	l->n->p = l->p;
  41555b:	49 8b 55 60          	mov    rdx,QWORD PTR [r13+0x60]
	ps_list_rem(t, thd_list);
  41555f:	49 8d 4d 58          	lea    rcx,[r13+0x58]
	*cycles  = t->event_info.cycles;
  415563:	49 8b 75 48          	mov    rsi,QWORD PTR [r13+0x48]
	ps_list_rem(t, thd_list);
  415567:	66 48 0f 6e c1       	movq   xmm0,rcx
  41556c:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
	l->p = l->n = l;
  415570:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
	l->p->n = l->n;
  415574:	48 89 02             	mov    QWORD PTR [rdx],rax
	*blocked = t->event_info.blocked;
  415577:	41 8b 45 40          	mov    eax,DWORD PTR [r13+0x40]
	l->p = l->n = l;
  41557b:	41 0f 11 45 58       	movups XMMWORD PTR [r13+0x58],xmm0
	memset(&t->event_info, 0, sizeof(struct event_info));
  415580:	66 0f ef c0          	pxor   xmm0,xmm0
	*blocked = t->event_info.blocked;
  415584:	89 45 b0             	mov    DWORD PTR [rbp-0x50],eax
	*timeout = t->event_info.timeout;
  415587:	49 8b 45 50          	mov    rax,QWORD PTR [r13+0x50]
	*cycles  = t->event_info.cycles;
  41558b:	48 89 75 c0          	mov    QWORD PTR [rbp-0x40],rsi
	*timeout = t->event_info.timeout;
  41558f:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
	memset(&t->event_info, 0, sizeof(struct event_info));
  415593:	49 c7 45 50 00 00 00 	mov    QWORD PTR [r13+0x50],0x0
  41559a:	00 
  41559b:	41 0f 11 45 40       	movups XMMWORD PTR [r13+0x40],xmm0
				/* remove the event from the list and get event info */
				slm_thd_event_dequeue(t, &blocked, &cycles, &thd_timeout);

				/* outdated event for a freed thread */
				if (unlikely(slm_state_is_dead(t->state))) continue;
  4155a0:	41 f7 45 04 fb ff ff 	test   DWORD PTR [r13+0x4],0xfffffffb
  4155a7:	ff 
  4155a8:	74 79                	je     415623 <slm_sched_loop_intern+0x223>

				/* Notify the policy that some execution has happened. */
				slm_sched_execution(t, cycles);
  4155aa:	48 b8 f0 1c 40 00 00 	movabs rax,0x401cf0
  4155b1:	00 00 00 
  4155b4:	4c 89 ef             	mov    rdi,r13
  4155b7:	ff d0                	call   rax

				if (blocked) {
  4155b9:	8b 55 b0             	mov    edx,DWORD PTR [rbp-0x50]
  4155bc:	85 d2                	test   edx,edx
  4155be:	0f 84 13 02 00 00    	je     4157d7 <slm_sched_loop_intern+0x3d7>
					assert(cycles);
  4155c4:	48 83 7d c0 00       	cmp    QWORD PTR [rbp-0x40],0x0
  4155c9:	0f 84 8f 03 00 00    	je     41595e <slm_sched_loop_intern+0x55e>
	assert(slm_state_is_runnable(t->state) || t->state == SLM_THD_BLOCKED);
  4155cf:	41 8b 45 04          	mov    eax,DWORD PTR [r13+0x4]
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  4155d3:	8d 50 fe             	lea    edx,[rax-0x2]
  4155d6:	83 e8 01             	sub    eax,0x1
  4155d9:	83 f8 02             	cmp    eax,0x2
  4155dc:	0f 87 42 05 00 00    	ja     415b24 <slm_sched_loop_intern+0x724>
	return t != &g->idle_thd && t != &g->sched_thd;
  4155e2:	48 b8 40 5f 5a 00 00 	movabs rax,0x5a5f40
  4155e9:	00 00 00 
  4155ec:	49 39 c5             	cmp    r13,rax
  4155ef:	0f 84 72 02 00 00    	je     415867 <slm_sched_loop_intern+0x467>
  4155f5:	48 83 e8 78          	sub    rax,0x78
  4155f9:	49 39 c5             	cmp    r13,rax
  4155fc:	0f 84 65 02 00 00    	je     415867 <slm_sched_loop_intern+0x467>
	if (likely(slm_state_is_runnable(t->state))) {
  415602:	83 fa 01             	cmp    edx,0x1
  415605:	77 0f                	ja     415616 <slm_sched_loop_intern+0x216>
		slm_sched_block(t);
  415607:	48 b8 b0 1c 40 00 00 	movabs rax,0x401cb0
  41560e:	00 00 00 
  415611:	4c 89 ef             	mov    rdi,r13
  415614:	ff d0                	call   rax
	t->properties |= SLM_THD_PROPERTY_SUSPENDED;
  415616:	41 83 4d 00 04       	or     DWORD PTR [r13+0x0],0x4
	t->state       = SLM_THD_BLOCKED;
  41561b:	41 c7 45 04 01 00 00 	mov    DWORD PTR [r13+0x4],0x1
  415622:	00 
			ps_list_foreach_del(&g->event_head, t, tn, thd_list) {
  415623:	49 8b 44 24 58       	mov    rax,QWORD PTR [r12+0x58]
  415628:	4d 89 e5             	mov    r13,r12
  41562b:	48 bf 78 5f 5a 00 00 	movabs rdi,0x5a5f78
  415632:	00 00 00 
  415635:	48 8d 50 a8          	lea    rdx,[rax-0x58]
  415639:	49 39 fc             	cmp    r12,rdi
  41563c:	74 08                	je     415646 <slm_sched_loop_intern+0x246>
  41563e:	49 89 d4             	mov    r12,rdx
  415641:	e9 15 ff ff ff       	jmp    41555b <slm_sched_loop_intern+0x15b>
  415646:	45 31 e4             	xor    r12d,r12d
  415649:	eb 11                	jmp    41565c <slm_sched_loop_intern+0x25c>
  41564b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  415650:	f0 49 0f b1 36       	lock cmpxchg QWORD PTR [r14],rsi
  415655:	0f 94 c0             	sete   al
	while (ret != 0) {
  415658:	84 c0                	test   al,al
  41565a:	75 4a                	jne    4156a6 <slm_sched_loop_intern+0x2a6>
		tok    = cos_sched_sync();
  41565c:	ff d3                	call   rbx
	unsigned long oc = ps_load(&cs->owner_contention);
  41565e:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  415661:	89 c1                	mov    ecx,eax
		if (unlikely(contention)) {
  415663:	48 89 d6             	mov    rsi,rdx
  415666:	48 89 d0             	mov    rax,rdx
  415669:	83 e6 01             	and    esi,0x1
  41566c:	74 e2                	je     415650 <slm_sched_loop_intern+0x250>
  41566e:	f0 4d 0f b1 26       	lock cmpxchg QWORD PTR [r14],r12
  415673:	0f 94 c0             	sete   al
	if (__slm_cs_cas(cs, cached, NULL, 0)) return 1;
  415676:	84 c0                	test   al,al
  415678:	74 e2                	je     41565c <slm_sched_loop_intern+0x25c>
	ret = cos_defswitch(s->thd, curr->priority, TCAP_TIME_NIL, tok);
  41567a:	48 b8 d8 5e 5a 00 00 	movabs rax,0x5a5ed8
  415681:	00 00 00 
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  415684:	48 83 e2 fe          	and    rdx,0xfffffffffffffffe
  415688:	48 8b 38             	mov    rdi,QWORD PTR [rax]
  41568b:	48 b8 70 e1 40 00 00 	movabs rax,0x40e170
  415692:	00 00 00 
  415695:	48 8b 72 30          	mov    rsi,QWORD PTR [rdx+0x30]
  415699:	31 d2                	xor    edx,edx
  41569b:	ff d0                	call   rax
	assert(ret != -EINVAL);
  41569d:	83 f8 ea             	cmp    eax,0xffffffea
  4156a0:	0f 84 09 01 00 00    	je     4157af <slm_sched_loop_intern+0x3af>
					slm_thd_sched_wakeup(t);
				}
			}

			slm_cs_exit(us, SLM_CS_NONE);
		} while (pending > 0);
  4156a6:	8b 45 ac             	mov    eax,DWORD PTR [rbp-0x54]
  4156a9:	85 c0                	test   eax,eax
  4156ab:	0f 8f 8c fd ff ff    	jg     41543d <slm_sched_loop_intern+0x3d>
	return !ps_cas(&cs->owner_contention, (unsigned long)cached, ((unsigned long)thd | !!contention));
  4156b1:	49 bd c8 5e 5a 00 00 	movabs r13,0x5a5ec8
  4156b8:	00 00 00 
		tok    = cos_sched_sync();
  4156bb:	ff d3                	call   rbx
  4156bd:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4156bf:	49 8b 06             	mov    rax,QWORD PTR [r14]
		if (unlikely(owner)) {
  4156c2:	48 89 c2             	mov    rdx,rax
  4156c5:	48 83 e2 fe          	and    rdx,0xfffffffffffffffe
  4156c9:	0f 85 50 01 00 00    	jne    41581f <slm_sched_loop_intern+0x41f>
  4156cf:	f0 4d 0f b1 2e       	lock cmpxchg QWORD PTR [r14],r13
  4156d4:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4156d7:	84 c0                	test   al,al
  4156d9:	74 e0                	je     4156bb <slm_sched_loop_intern+0x2bb>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  4156db:	48 b8 10 ce 40 00 00 	movabs rax,0x40ce10
  4156e2:	00 00 00 
  4156e5:	ff d0                	call   rax
	return &__slm_global[cos_coreid()];
  4156e7:	44 89 7d ac          	mov    DWORD PTR [rbp-0x54],r15d
	tok  = cos_sched_sync();
  4156eb:	ff d3                	call   rbx
	if (flags & SLM_CS_CHECK_TIMEOUT && g->timer_set) {
  4156ed:	41 83 be fc 00 00 00 	cmp    DWORD PTR [r14+0xfc],0x0
  4156f4:	00 
	tok  = cos_sched_sync();
  4156f5:	41 89 c7             	mov    r15d,eax
	if (flags & SLM_CS_CHECK_TIMEOUT && g->timer_set) {
  4156f8:	74 22                	je     41571c <slm_sched_loop_intern+0x31c>
	__asm__ __volatile__("rdtsc" : "=a" (a), "=d" (d), "=c" (c) : : );
  4156fa:	0f 31                	rdtsc  
	return ((u64_t)d << 32) | (u64_t)a;
  4156fc:	48 c1 e2 20          	shl    rdx,0x20
  415700:	48 89 d7             	mov    rdi,rdx
  415703:	48 09 c7             	or     rdi,rax
  415706:	48 a1 c0 5f 5a 00 00 	movabs rax,ds:0x5a5fc0
  41570d:	00 00 00 
  415710:	48 29 f8             	sub    rax,rdi
		if (!cycles_greater_than(g->timer_next, now)) {
  415713:	48 85 c0             	test   rax,rax
  415716:	0f 8e ab 02 00 00    	jle    4159c7 <slm_sched_loop_intern+0x5c7>
	t = slm_sched_schedule();
  41571c:	48 b8 e0 1c 40 00 00 	movabs rax,0x401ce0
  415723:	00 00 00 
  415726:	ff d0                	call   rax
	if (unlikely(!t)) t = &g->idle_thd;
  415728:	48 85 c0             	test   rax,rax
	t = slm_sched_schedule();
  41572b:	49 89 c4             	mov    r12,rax
	if (unlikely(!t)) t = &g->idle_thd;
  41572e:	48 b8 40 5f 5a 00 00 	movabs rax,0x5a5f40
  415735:	00 00 00 
  415738:	4c 0f 44 e0          	cmove  r12,rax
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  41573c:	41 8b 44 24 04       	mov    eax,DWORD PTR [r12+0x4]
  415741:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  415744:	83 f8 01             	cmp    eax,0x1
  415747:	76 1a                	jbe    415763 <slm_sched_loop_intern+0x363>
  415749:	e9 cf 02 00 00       	jmp    415a1d <slm_sched_loop_intern+0x61d>
  41574e:	66 90                	xchg   ax,ax
        __asm__ __volatile__("lock " PS_CAS_STR
  415750:	48 89 d0             	mov    rax,rdx
  415753:	f0 49 0f b1 36       	lock cmpxchg QWORD PTR [r14],rsi
  415758:	0f 94 c0             	sete   al
	while (ret != 0) {
  41575b:	84 c0                	test   al,al
  41575d:	0f 85 9f 01 00 00    	jne    415902 <slm_sched_loop_intern+0x502>
		tok    = cos_sched_sync();
  415763:	ff d3                	call   rbx
	unsigned long oc = ps_load(&cs->owner_contention);
  415765:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  415768:	89 c1                	mov    ecx,eax
		if (unlikely(contention)) {
  41576a:	48 89 d6             	mov    rsi,rdx
  41576d:	83 e6 01             	and    esi,0x1
  415770:	74 de                	je     415750 <slm_sched_loop_intern+0x350>
  415772:	31 ff                	xor    edi,edi
  415774:	48 89 d0             	mov    rax,rdx
  415777:	f0 49 0f b1 3e       	lock cmpxchg QWORD PTR [r14],rdi
  41577c:	0f 94 c0             	sete   al
	if (__slm_cs_cas(cs, cached, NULL, 0)) return 1;
  41577f:	84 c0                	test   al,al
  415781:	74 e0                	je     415763 <slm_sched_loop_intern+0x363>
	ret = cos_defswitch(s->thd, curr->priority, TCAP_TIME_NIL, tok);
  415783:	48 b8 d8 5e 5a 00 00 	movabs rax,0x5a5ed8
  41578a:	00 00 00 
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  41578d:	48 83 e2 fe          	and    rdx,0xfffffffffffffffe
  415791:	48 8b 38             	mov    rdi,QWORD PTR [rax]
  415794:	48 b8 70 e1 40 00 00 	movabs rax,0x40e170
  41579b:	00 00 00 
  41579e:	48 8b 72 30          	mov    rsi,QWORD PTR [rdx+0x30]
  4157a2:	31 d2                	xor    edx,edx
  4157a4:	ff d0                	call   rax
	assert(ret != -EINVAL);
  4157a6:	83 f8 ea             	cmp    eax,0xffffffea
  4157a9:	0f 85 53 01 00 00    	jne    415902 <slm_sched_loop_intern+0x502>
  4157af:	48 bf c8 17 42 00 00 	movabs rdi,0x4217c8
  4157b6:	00 00 00 
  4157b9:	be 23 00 00 00       	mov    esi,0x23
  4157be:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4157c5:	00 00 00 
  4157c8:	ff d0                	call   rax
  4157ca:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4157d1:	00 00 00 00 
  4157d5:	0f 0b                	ud2    
	if (unlikely(!(t->properties & SLM_THD_PROPERTY_SUSPENDED))) return 1;
  4157d7:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
  4157db:	a8 04                	test   al,0x4
  4157dd:	0f 84 40 fe ff ff    	je     415623 <slm_sched_loop_intern+0x223>
	t->properties &= ~SLM_THD_PROPERTY_SUSPENDED;
  4157e3:	83 e0 fb             	and    eax,0xfffffffb
  4157e6:	41 89 45 00          	mov    DWORD PTR [r13+0x0],eax
	if (unlikely(slm_state_is_runnable(t->state))) {
  4157ea:	41 8b 45 04          	mov    eax,DWORD PTR [r13+0x4]
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  4157ee:	8d 50 fe             	lea    edx,[rax-0x2]
  4157f1:	83 fa 01             	cmp    edx,0x1
  4157f4:	0f 86 ee 01 00 00    	jbe    4159e8 <slm_sched_loop_intern+0x5e8>
	assert(t->state == SLM_THD_BLOCKED);
  4157fa:	83 e8 01             	sub    eax,0x1
  4157fd:	0f 85 f2 01 00 00    	jne    4159f5 <slm_sched_loop_intern+0x5f5>
	t->state = SLM_THD_RUNNABLE;
  415803:	41 c7 45 04 03 00 00 	mov    DWORD PTR [r13+0x4],0x3
  41580a:	00 
	slm_sched_wakeup(t);
  41580b:	4c 89 ef             	mov    rdi,r13
  41580e:	48 b8 c0 1c 40 00 00 	movabs rax,0x401cc0
  415815:	00 00 00 
  415818:	ff d0                	call   rax
	return 0;
  41581a:	e9 04 fe ff ff       	jmp    415623 <slm_sched_loop_intern+0x223>
	if (!contended) {
  41581f:	a8 01                	test   al,0x1
  415821:	75 17                	jne    41583a <slm_sched_loop_intern+0x43a>
	return !ps_cas(&cs->owner_contention, (unsigned long)cached, ((unsigned long)thd | !!contention));
  415823:	48 89 d6             	mov    rsi,rdx
  415826:	48 83 ce 01          	or     rsi,0x1
  41582a:	f0 49 0f b1 36       	lock cmpxchg QWORD PTR [r14],rsi
  41582f:	0f 94 c0             	sete   al
		if (__slm_cs_cas(cs, cached, owner, 1)) return 1;
  415832:	84 c0                	test   al,al
  415834:	0f 84 81 fe ff ff    	je     4156bb <slm_sched_loop_intern+0x2bb>
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  41583a:	48 b8 f8 5e 5a 00 00 	movabs rax,0x5a5ef8
  415841:	00 00 00 
  415844:	48 8b 7a 10          	mov    rdi,QWORD PTR [rdx+0x10]
  415848:	48 8b 30             	mov    rsi,QWORD PTR [rax]
  41584b:	31 d2                	xor    edx,edx
  41584d:	48 b8 70 e1 40 00 00 	movabs rax,0x40e170
  415854:	00 00 00 
  415857:	ff d0                	call   rax
			if (flags & SLM_CS_SCHEDEVT && ret == -EBUSY) return ret;
  415859:	83 f8 f0             	cmp    eax,0xfffffff0
  41585c:	0f 85 59 fe ff ff    	jne    4156bb <slm_sched_loop_intern+0x2bb>
  415862:	e9 d6 fb ff ff       	jmp    41543d <slm_sched_loop_intern+0x3d>
  415867:	48 bf d8 18 42 00 00 	movabs rdi,0x4218d8
  41586e:	00 00 00 
  415871:	be 23 00 00 00       	mov    esi,0x23
  415876:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  41587d:	00 00 00 
  415880:	ff d0                	call   rax
	assert(slm_thd_normal(t));
  415882:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  415889:	00 00 00 00 
  41588d:	0f 0b                	ud2    
	if (ps_list_singleton(t, thd_list)) ps_list_head_append(&g->event_head, t, thd_list);
  41588f:	48 a1 d8 5f 5a 00 00 	movabs rax,ds:0x5a5fd8
  415896:	00 00 00 
	new->n    = l->n;
  415899:	f3 0f 7e 00          	movq   xmm0,QWORD PTR [rax]
  41589d:	66 48 0f 6e d0       	movq   xmm2,rax
  4158a2:	66 0f 6c c2          	punpcklqdq xmm0,xmm2
  4158a6:	0f 11 42 58          	movups XMMWORD PTR [rdx+0x58],xmm0
	l->n      = new;
  4158aa:	48 89 30             	mov    QWORD PTR [rax],rsi
	new->n->p = new;
  4158ad:	48 8b 42 58          	mov    rax,QWORD PTR [rdx+0x58]
  4158b1:	48 89 70 08          	mov    QWORD PTR [rax+0x8],rsi
}
  4158b5:	e9 14 fc ff ff       	jmp    4154ce <slm_sched_loop_intern+0xce>
	if (!contended) {
  4158ba:	a8 01                	test   al,0x1
  4158bc:	75 17                	jne    4158d5 <slm_sched_loop_intern+0x4d5>
  4158be:	48 89 d6             	mov    rsi,rdx
  4158c1:	48 83 ce 01          	or     rsi,0x1
  4158c5:	f0 49 0f b1 36       	lock cmpxchg QWORD PTR [r14],rsi
  4158ca:	0f 94 c0             	sete   al
		if (__slm_cs_cas(cs, cached, owner, 1)) return 1;
  4158cd:	84 c0                	test   al,al
  4158cf:	0f 84 34 fc ff ff    	je     415509 <slm_sched_loop_intern+0x109>
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  4158d5:	48 b8 f8 5e 5a 00 00 	movabs rax,0x5a5ef8
  4158dc:	00 00 00 
  4158df:	48 8b 7a 10          	mov    rdi,QWORD PTR [rdx+0x10]
  4158e3:	48 8b 30             	mov    rsi,QWORD PTR [rax]
  4158e6:	31 d2                	xor    edx,edx
  4158e8:	48 b8 70 e1 40 00 00 	movabs rax,0x40e170
  4158ef:	00 00 00 
  4158f2:	ff d0                	call   rax
  4158f4:	83 f8 f0             	cmp    eax,0xfffffff0
  4158f7:	0f 85 0c fc ff ff    	jne    415509 <slm_sched_loop_intern+0x109>
  4158fd:	e9 a4 fd ff ff       	jmp    4156a6 <slm_sched_loop_intern+0x2a6>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  415902:	48 b8 10 ce 40 00 00 	movabs rax,0x40ce10
  415909:	00 00 00 
  41590c:	ff d0                	call   rax
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  41590e:	41 8b 14 24          	mov    edx,DWORD PTR [r12]
	prio = inherit_prio ? curr->priority : t->priority;
  415912:	49 8b 74 24 30       	mov    rsi,QWORD PTR [r12+0x30]
	timeout = g->timeout_next;
  415917:	48 b8 c8 5f 5a 00 00 	movabs rax,0x5a5fc8
  41591e:	00 00 00 
  415921:	4c 8b 00             	mov    r8,QWORD PTR [rax]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  415924:	f6 c2 0b             	test   dl,0xb
  415927:	0f 85 18 01 00 00    	jne    415a45 <slm_sched_loop_intern+0x645>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  41592d:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  415932:	44 89 f9             	mov    ecx,r15d
  415935:	4c 89 c2             	mov    rdx,r8
  415938:	48 b8 70 e1 40 00 00 	movabs rax,0x40e170
  41593f:	00 00 00 
  415942:	ff d0                	call   rax
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  415944:	83 f8 ff             	cmp    eax,0xffffffff
  415947:	0f 84 93 01 00 00    	je     415ae0 <slm_sched_loop_intern+0x6e0>
	if (unlikely(ret != 0)) {
  41594d:	85 c0                	test   eax,eax
  41594f:	0f 85 4a 01 00 00    	jne    415a9f <slm_sched_loop_intern+0x69f>
  415955:	44 8b 7d ac          	mov    r15d,DWORD PTR [rbp-0x54]
  415959:	e9 df fa ff ff       	jmp    41543d <slm_sched_loop_intern+0x3d>
					assert(cycles);
  41595e:	48 bf 50 17 42 00 00 	movabs rdi,0x421750
  415965:	00 00 00 
  415968:	48 b8 c0 53 41 00 00 	movabs rax,0x4153c0
  41596f:	00 00 00 
  415972:	ff d0                	call   rax
  415974:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41597b:	00 00 00 00 
  41597f:	0f 0b                	ud2    
	assert(cos_thdid() == us->tid);
  415981:	48 bf 00 17 42 00 00 	movabs rdi,0x421700
  415988:	00 00 00 
  41598b:	48 b8 c0 53 41 00 00 	movabs rax,0x4153c0
  415992:	00 00 00 
  415995:	ff d0                	call   rax
  415997:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41599e:	00 00 00 00 
  4159a2:	0f 0b                	ud2    
			assert(t);
  4159a4:	48 bf 28 17 42 00 00 	movabs rdi,0x421728
  4159ab:	00 00 00 
  4159ae:	48 b8 c0 53 41 00 00 	movabs rax,0x4153c0
  4159b5:	00 00 00 
  4159b8:	ff d0                	call   rax
  4159ba:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4159c1:	00 00 00 00 
  4159c5:	0f 0b                	ud2    
			g->timer_set = 0;
  4159c7:	48 b8 bc 5f 5a 00 00 	movabs rax,0x5a5fbc
  4159ce:	00 00 00 
  4159d1:	c7 00 00 00 00 00    	mov    DWORD PTR [rax],0x0
			slm_timer_expire(now);
  4159d7:	48 b8 10 1c 40 00 00 	movabs rax,0x401c10
  4159de:	00 00 00 
  4159e1:	ff d0                	call   rax
  4159e3:	e9 34 fd ff ff       	jmp    41571c <slm_sched_loop_intern+0x31c>
		t->state = SLM_THD_RUNNABLE;
  4159e8:	41 c7 45 04 03 00 00 	mov    DWORD PTR [r13+0x4],0x3
  4159ef:	00 
		return 1;
  4159f0:	e9 2e fc ff ff       	jmp    415623 <slm_sched_loop_intern+0x223>
  4159f5:	48 bf a0 17 42 00 00 	movabs rdi,0x4217a0
  4159fc:	00 00 00 
  4159ff:	be 23 00 00 00       	mov    esi,0x23
  415a04:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  415a0b:	00 00 00 
  415a0e:	ff d0                	call   rax
	assert(t->state == SLM_THD_BLOCKED);
  415a10:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  415a17:	00 00 00 00 
  415a1b:	0f 0b                	ud2    
  415a1d:	48 bf f0 17 42 00 00 	movabs rdi,0x4217f0
  415a24:	00 00 00 
  415a27:	be 2d 00 00 00       	mov    esi,0x2d
  415a2c:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  415a33:	00 00 00 
  415a36:	ff d0                	call   rax
	assert(slm_state_is_runnable(t->state));
  415a38:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  415a3f:	00 00 00 00 
  415a43:	0f 0b                	ud2    
	timeout = g->timeout_next;
  415a45:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  415a48:	4d 39 ec             	cmp    r12,r13
  415a4b:	0f 84 24 01 00 00    	je     415b75 <slm_sched_loop_intern+0x775>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  415a51:	f6 c2 02             	test   dl,0x2
  415a54:	0f 85 f2 00 00 00    	jne    415b4c <slm_sched_loop_intern+0x74c>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  415a5a:	80 e2 01             	and    dl,0x1
  415a5d:	49 89 c8             	mov    r8,rcx
  415a60:	0f 84 c7 fe ff ff    	je     41592d <slm_sched_loop_intern+0x52d>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  415a66:	4d 8b 54 24 08       	mov    r10,QWORD PTR [r12+0x8]
  415a6b:	48 89 f2             	mov    rdx,rsi
  415a6e:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  415a73:	45 89 f9             	mov    r9d,r15d
  415a76:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  415a7d:	00 00 00 
  415a80:	4c 8b 00             	mov    r8,QWORD PTR [rax]
  415a83:	48 b8 f0 35 41 00 00 	movabs rax,0x4135f0
  415a8a:	00 00 00 
  415a8d:	4c 89 d6             	mov    rsi,r10
  415a90:	ff d0                	call   rax
	if (unlikely(ret != 0)) {
  415a92:	85 c0                	test   eax,eax
  415a94:	0f 84 bb fe ff ff    	je     415955 <slm_sched_loop_intern+0x555>
		assert(ret != -EPERM);
  415a9a:	83 f8 ff             	cmp    eax,0xffffffff
  415a9d:	74 5d                	je     415afc <slm_sched_loop_intern+0x6fc>
		assert(ret != -EINVAL);
  415a9f:	83 f8 ea             	cmp    eax,0xffffffea
  415aa2:	0f 84 03 01 00 00    	je     415bab <slm_sched_loop_intern+0x7ab>
		if (ret == -EBUSY) return ret;
  415aa8:	83 f8 f0             	cmp    eax,0xfffffff0
  415aab:	0f 84 a4 fe ff ff    	je     415955 <slm_sched_loop_intern+0x555>
		assert(ret == -EAGAIN);
  415ab1:	83 f8 f5             	cmp    eax,0xfffffff5
  415ab4:	0f 85 c9 00 00 00    	jne    415b83 <slm_sched_loop_intern+0x783>
		tok    = cos_sched_sync();
  415aba:	ff d3                	call   rbx
  415abc:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  415abe:	49 8b 06             	mov    rax,QWORD PTR [r14]
		if (unlikely(owner)) {
  415ac1:	48 89 c6             	mov    rsi,rax
  415ac4:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  415ac8:	0f 85 05 01 00 00    	jne    415bd3 <slm_sched_loop_intern+0x7d3>
  415ace:	f0 4d 0f b1 2e       	lock cmpxchg QWORD PTR [r14],r13
  415ad3:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  415ad6:	84 c0                	test   al,al
  415ad8:	0f 85 0d fc ff ff    	jne    4156eb <slm_sched_loop_intern+0x2eb>
  415ade:	eb da                	jmp    415aba <slm_sched_loop_intern+0x6ba>
	return t != &g->idle_thd && t != &g->sched_thd;
  415ae0:	48 b8 40 5f 5a 00 00 	movabs rax,0x5a5f40
  415ae7:	00 00 00 
  415aea:	49 39 c4             	cmp    r12,rax
  415aed:	0f 84 46 01 00 00    	je     415c39 <slm_sched_loop_intern+0x839>
  415af3:	4d 39 ec             	cmp    r12,r13
  415af6:	0f 84 3d 01 00 00    	je     415c39 <slm_sched_loop_intern+0x839>
  415afc:	48 bf 20 18 42 00 00 	movabs rdi,0x421820
  415b03:	00 00 00 
  415b06:	be 2d 00 00 00       	mov    esi,0x2d
  415b0b:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  415b12:	00 00 00 
  415b15:	ff d0                	call   rax
		assert(ret != -EPERM);
  415b17:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  415b1e:	00 00 00 00 
  415b22:	0f 0b                	ud2    
  415b24:	48 bf 78 17 42 00 00 	movabs rdi,0x421778
  415b2b:	00 00 00 
  415b2e:	be 23 00 00 00       	mov    esi,0x23
  415b33:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  415b3a:	00 00 00 
  415b3d:	ff d0                	call   rax
	assert(slm_state_is_runnable(t->state) || t->state == SLM_THD_BLOCKED);
  415b3f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  415b46:	00 00 00 00 
  415b4a:	0f 0b                	ud2    
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  415b4c:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  415b53:	00 00 00 
  415b56:	49 8b 7c 24 28       	mov    rdi,QWORD PTR [r12+0x28]
  415b5b:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  415b5e:	44 89 f9             	mov    ecx,r15d
  415b61:	48 b8 60 36 41 00 00 	movabs rax,0x413660
  415b68:	00 00 00 
  415b6b:	4c 89 c6             	mov    rsi,r8
  415b6e:	ff d0                	call   rax
  415b70:	e9 1d ff ff ff       	jmp    415a92 <slm_sched_loop_intern+0x692>
			prio    = curr->priority;
  415b75:	48 8b b0 30 ff ff ff 	mov    rsi,QWORD PTR [rax-0xd0]
			timeout = TCAP_TIME_NIL;
  415b7c:	31 c9                	xor    ecx,ecx
  415b7e:	e9 ce fe ff ff       	jmp    415a51 <slm_sched_loop_intern+0x651>
  415b83:	48 bf 80 18 42 00 00 	movabs rdi,0x421880
  415b8a:	00 00 00 
  415b8d:	be 2d 00 00 00       	mov    esi,0x2d
  415b92:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  415b99:	00 00 00 
  415b9c:	ff d0                	call   rax
		assert(ret == -EAGAIN);
  415b9e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  415ba5:	00 00 00 00 
  415ba9:	0f 0b                	ud2    
  415bab:	48 bf 50 18 42 00 00 	movabs rdi,0x421850
  415bb2:	00 00 00 
  415bb5:	be 2d 00 00 00       	mov    esi,0x2d
  415bba:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  415bc1:	00 00 00 
  415bc4:	ff d0                	call   rax
		assert(ret != -EINVAL);
  415bc6:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  415bcd:	00 00 00 00 
  415bd1:	0f 0b                	ud2    
	if (!contended) {
  415bd3:	a8 01                	test   al,0x1
  415bd5:	75 17                	jne    415bee <slm_sched_loop_intern+0x7ee>
	return !ps_cas(&cs->owner_contention, (unsigned long)cached, ((unsigned long)thd | !!contention));
  415bd7:	48 89 f2             	mov    rdx,rsi
  415bda:	48 83 ca 01          	or     rdx,0x1
  415bde:	f0 49 0f b1 16       	lock cmpxchg QWORD PTR [r14],rdx
  415be3:	0f 94 c0             	sete   al
		if (__slm_cs_cas(cs, cached, owner, 1)) return 1;
  415be6:	84 c0                	test   al,al
  415be8:	0f 84 cc fe ff ff    	je     415aba <slm_sched_loop_intern+0x6ba>
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  415bee:	48 b8 f8 5e 5a 00 00 	movabs rax,0x5a5ef8
  415bf5:	00 00 00 
  415bf8:	48 8b 7e 10          	mov    rdi,QWORD PTR [rsi+0x10]
  415bfc:	31 d2                	xor    edx,edx
  415bfe:	48 8b 30             	mov    rsi,QWORD PTR [rax]
  415c01:	48 b8 70 e1 40 00 00 	movabs rax,0x40e170
  415c08:	00 00 00 
  415c0b:	ff d0                	call   rax
			assert(ret != -EBUSY);
  415c0d:	83 f8 f0             	cmp    eax,0xfffffff0
  415c10:	0f 85 a4 fe ff ff    	jne    415aba <slm_sched_loop_intern+0x6ba>
  415c16:	48 bf b0 18 42 00 00 	movabs rdi,0x4218b0
  415c1d:	00 00 00 
  415c20:	48 b8 c0 53 41 00 00 	movabs rax,0x4153c0
  415c27:	00 00 00 
  415c2a:	ff d0                	call   rax
  415c2c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  415c33:	00 00 00 00 
  415c37:	0f 0b                	ud2    
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  415c39:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  415c40:	00 00 00 
  415c43:	45 89 f9             	mov    r9d,r15d
  415c46:	4c 8b 00             	mov    r8,QWORD PTR [rax]
  415c49:	31 c9                	xor    ecx,ecx
  415c4b:	48 8b 50 10          	mov    rdx,QWORD PTR [rax+0x10]
  415c4f:	48 8b 78 f0          	mov    rdi,QWORD PTR [rax-0x10]
  415c53:	31 f6                	xor    esi,esi
  415c55:	48 b8 f0 35 41 00 00 	movabs rax,0x4135f0
  415c5c:	00 00 00 
  415c5f:	ff d0                	call   rax
  415c61:	e9 2c fe ff ff       	jmp    415a92 <slm_sched_loop_intern+0x692>
  415c66:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  415c6d:	00 00 00 

0000000000415c70 <slm_ipi_event_enqueue>:
{
  415c70:	f3 0f 1e fa          	endbr64 
    void *buffer,
    const void *entry,
    unsigned int ts,
    unsigned int *size)
{
	const unsigned int mask = ring->mask;
  415c74:	49 ba 00 4e 5a 00 00 	movabs r10,0x5a4e00
  415c7b:	00 00 00 
  415c7e:	4c 63 ce             	movsxd r9,esi
  415c81:	55                   	push   rbp
  415c82:	4d 69 c9 c0 10 00 00 	imul   r9,r9,0x10c0
  415c89:	48 89 e5             	mov    rbp,rsp
  415c8c:	41 54                	push   r12
  415c8e:	49 89 fc             	mov    r12,rdi
  415c91:	53                   	push   rbx
  415c92:	47 8b 84 0a a4 00 00 	mov    r8d,DWORD PTR [r10+r9*1+0xa4]
  415c99:	00 
	unsigned int producer, consumer, delta;
	bool r = true;

	producer = ck_pr_load_uint(&ring->p_head);
  415c9a:	4b 8d 4c 0a 64       	lea    rcx,[r10+r9*1+0x64]
  415c9f:	4d 8d 99 a8 00 00 00 	lea    r11,[r9+0xa8]
CK_PR_LOAD(ptr, void, void *, char, "movq")

#define CK_PR_LOAD_S(S, T, I) CK_PR_LOAD(S, T, T, T, I)

CK_PR_LOAD_S(char, char, "movb")
CK_PR_LOAD_S(uint, unsigned int, "movl")
  415ca6:	8b 11                	mov    edx,DWORD PTR [rcx]
		/*
		 * The snapshot of producer must be up to date with respect to
		 * consumer.
		 */
		ck_pr_fence_load();
		consumer = ck_pr_load_uint(&ring->c_head);
  415ca8:	4b 8d 5c 0a 20       	lea    rbx,[r10+r9*1+0x20]
  415cad:	eb 0b                	jmp    415cba <slm_ipi_event_enqueue+0x4a>
  415caf:	90                   	nop

#define CK_PR_CAS_S(S, T, I) CK_PR_CAS(S, T, T, T, I)

CK_PR_CAS_S(char, char, "cmpxchgb")
CK_PR_CAS_S(int, int, "cmpxchgl")
CK_PR_CAS_S(uint, unsigned int, "cmpxchgl")
  415cb0:	89 d0                	mov    eax,edx
  415cb2:	f0 0f b1 31          	lock cmpxchg DWORD PTR [rcx],esi
  415cb6:	89 c2                	mov    edx,eax
		/*
		 * Only try to CAS if the producer is not clearly stale (not
		 * less than consumer) and the buffer is definitely not full.
		 */
		if (CK_CC_LIKELY((producer - consumer) < mask)) {
			if (ck_pr_cas_uint_value(&ring->p_head,
  415cb8:	74 1e                	je     415cd8 <slm_ipi_event_enqueue+0x68>
CK_PR_LOAD_S(uint, unsigned int, "movl")
  415cba:	8b 3b                	mov    edi,DWORD PTR [rbx]
		if (CK_CC_LIKELY((producer - consumer) < mask)) {
  415cbc:	89 d0                	mov    eax,edx
		delta = producer + 1;
  415cbe:	8d 72 01             	lea    esi,[rdx+0x1]
		if (CK_CC_LIKELY((producer - consumer) < mask)) {
  415cc1:	29 f8                	sub    eax,edi
  415cc3:	41 39 c0             	cmp    r8d,eax
  415cc6:	77 e8                	ja     415cb0 <slm_ipi_event_enqueue+0x40>
  415cc8:	8b 01                	mov    eax,DWORD PTR [rcx]
			 * Only fail if we haven't made forward progress in
			 * production: the buffer must have been full when we
			 * read new_producer (or we wrapped around UINT_MAX
			 * during this iteration).
			 */
			if (producer == new_producer) {
  415cca:	39 c2                	cmp    edx,eax
  415ccc:	74 46                	je     415d14 <slm_ipi_event_enqueue+0xa4>
  415cce:	89 c2                	mov    edx,eax
  415cd0:	eb e8                	jmp    415cba <slm_ipi_event_enqueue+0x4a>
  415cd2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
			 */
			producer = new_producer;
		}
	}

	buffer = (char *)buffer + ts * (producer & mask);
  415cd8:	41 21 c0             	and    r8d,eax
  415cdb:	49 8b 3c 24          	mov    rdi,QWORD PTR [r12]
  415cdf:	42 8d 0c c5 00 00 00 	lea    ecx,[r8*8+0x0]
  415ce6:	00 
	memcpy(buffer, entry, ts);
  415ce7:	49 01 cb             	add    r11,rcx

	/*
	 * Wait until all concurrent producers have completed writing
	 * their data into the ring buffer.
	 */
	while (ck_pr_load_uint(&ring->p_tail) != producer)
  415cea:	4b 8d 4c 0a 60       	lea    rcx,[r10+r9*1+0x60]
	memcpy(buffer, entry, ts);
  415cef:	4b 89 3c 1a          	mov    QWORD PTR [r10+r11*1],rdi
  415cf3:	8b 39                	mov    edi,DWORD PTR [rcx]
	while (ck_pr_load_uint(&ring->p_tail) != producer)
  415cf5:	39 c7                	cmp    edi,eax
  415cf7:	74 0f                	je     415d08 <slm_ipi_event_enqueue+0x98>
  415cf9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	__asm__ __volatile__("pause" ::: "memory");
  415d00:	f3 90                	pause  
CK_PR_LOAD_S(uint, unsigned int, "movl")
  415d02:	8b 11                	mov    edx,DWORD PTR [rcx]
  415d04:	39 d0                	cmp    eax,edx
  415d06:	75 f8                	jne    415d00 <slm_ipi_event_enqueue+0x90>
CK_PR_STORE_S(uint, unsigned int, "movl", CK_CC_IMM_U32)
  415d08:	89 31                	mov    DWORD PTR [rcx],esi
  415d0a:	b8 01 00 00 00       	mov    eax,0x1
}
  415d0f:	5b                   	pop    rbx
  415d10:	41 5c                	pop    r12
  415d12:	5d                   	pop    rbp
  415d13:	c3                   	ret    
  415d14:	5b                   	pop    rbx
  415d15:	31 c0                	xor    eax,eax
  415d17:	41 5c                	pop    r12
  415d19:	5d                   	pop    rbp
  415d1a:	c3                   	ret    
  415d1b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000415d20 <slm_ipi_event_dequeue>:
{
  415d20:	f3 0f 1e fa          	endbr64 
	const unsigned int mask = ring->mask;
  415d24:	49 b8 00 4e 5a 00 00 	movabs r8,0x5a4e00
  415d2b:	00 00 00 
  415d2e:	48 63 c6             	movsxd rax,esi
  415d31:	48 69 c0 c0 10 00 00 	imul   rax,rax,0x10c0
  415d38:	49 8d 0c 00          	lea    rcx,[r8+rax*1]
  415d3c:	48 8d b0 a8 00 00 00 	lea    rsi,[rax+0xa8]
  415d43:	8b 91 a4 00 00 00    	mov    edx,DWORD PTR [rcx+0xa4]
	consumer = ring->c_head;
  415d49:	8b 49 20             	mov    ecx,DWORD PTR [rcx+0x20]
CK_PR_LOAD_S(uint, unsigned int, "movl")
  415d4c:	46 8b 4c 00 60       	mov    r9d,DWORD PTR [rax+r8*1+0x60]
	if (CK_CC_UNLIKELY(consumer == producer))
  415d51:	44 39 c9             	cmp    ecx,r9d
  415d54:	74 22                	je     415d78 <slm_ipi_event_dequeue+0x58>
	buffer = (const char *)buffer + size * (consumer & mask);
  415d56:	21 ca                	and    edx,ecx
  415d58:	c1 e2 03             	shl    edx,0x3
  415d5b:	48 01 d6             	add    rsi,rdx
  415d5e:	49 8b 14 30          	mov    rdx,QWORD PTR [r8+rsi*1]
	memcpy(target, buffer, size);
  415d62:	48 89 17             	mov    QWORD PTR [rdi],rdx
	ck_pr_store_uint(&ring->c_head, consumer + 1);
  415d65:	83 c1 01             	add    ecx,0x1
CK_PR_STORE_S(uint, unsigned int, "movl", CK_CC_IMM_U32)
  415d68:	42 89 4c 00 20       	mov    DWORD PTR [rax+r8*1+0x20],ecx
  415d6d:	b8 01 00 00 00       	mov    eax,0x1
  415d72:	c3                   	ret    
  415d73:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  415d78:	31 c0                	xor    eax,eax
}
  415d7a:	c3                   	ret    
  415d7b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000415d80 <slm_ipi_event_empty>:
{
  415d80:	f3 0f 1e fa          	endbr64 
CK_PR_LOAD_S(uint, unsigned int, "movl")
  415d84:	48 b8 20 4e 5a 00 00 	movabs rax,0x5a4e20
  415d8b:	00 00 00 
  415d8e:	48 63 ff             	movsxd rdi,edi
  415d91:	48 69 ff c0 10 00 00 	imul   rdi,rdi,0x10c0
  415d98:	8b 14 38             	mov    edx,DWORD PTR [rax+rdi*1]
  415d9b:	48 83 c0 40          	add    rax,0x40
  415d9f:	8b 04 38             	mov    eax,DWORD PTR [rax+rdi*1]
	return (p - c) & ring->mask;
  415da2:	29 d0                	sub    eax,edx
  415da4:	48 ba 00 4e 5a 00 00 	movabs rdx,0x5a4e00
  415dab:	00 00 00 
  415dae:	23 84 3a a4 00 00 00 	and    eax,DWORD PTR [rdx+rdi*1+0xa4]
    return (!ck_ring_size(&ipi_data->ring));
  415db5:	0f 94 c0             	sete   al
  415db8:	0f b6 c0             	movzx  eax,al
}
  415dbb:	c3                   	ret    
  415dbc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000415dc0 <slm_ipi_percore_get>:
{
  415dc0:	f3 0f 1e fa          	endbr64 
    return &slm_ipi_percore_data[id];
  415dc4:	48 ba 00 4e 5a 00 00 	movabs rdx,0x5a4e00
  415dcb:	00 00 00 
  415dce:	48 63 c7             	movsxd rax,edi
  415dd1:	48 69 c0 c0 10 00 00 	imul   rax,rax,0x10c0
  415dd8:	48 01 d0             	add    rax,rdx
}
  415ddb:	c3                   	ret    
  415ddc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000415de0 <slm_thd_special>:
{
  415de0:	f3 0f 1e fa          	endbr64 
	if (me == g->sched_thd.tid)     return &g->sched_thd;
  415de4:	48 b9 c0 5e 5a 00 00 	movabs rcx,0x5a5ec0
  415deb:	00 00 00 
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  415dee:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  415df1:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
	return cos_get_thd_id();
  415df7:	0f b7 90 f0 1f 00 00 	movzx  edx,WORD PTR [rax+0x1ff0]
  415dfe:	48 8d 41 08          	lea    rax,[rcx+0x8]
  415e02:	48 39 51 20          	cmp    QWORD PTR [rcx+0x20],rdx
  415e06:	74 14                	je     415e1c <slm_thd_special+0x3c>
	else                            return NULL;
  415e08:	48 39 91 98 00 00 00 	cmp    QWORD PTR [rcx+0x98],rdx
  415e0f:	48 8d 40 78          	lea    rax,[rax+0x78]
  415e13:	ba 00 00 00 00       	mov    edx,0x0
  415e18:	48 0f 45 c2          	cmovne rax,rdx
}
  415e1c:	c3                   	ret    
  415e1d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000415e20 <slm_thd_init>:
{
  415e20:	f3 0f 1e fa          	endbr64 
	struct cos_defcompinfo *defci     = cos_defcompinfo_curr_get();
  415e24:	48 b8 10 ce 40 00 00 	movabs rax,0x40ce10
  415e2b:	00 00 00 
{
  415e2e:	55                   	push   rbp
  415e2f:	48 89 e5             	mov    rbp,rsp
  415e32:	41 54                	push   r12
  415e34:	49 89 fc             	mov    r12,rdi
  415e37:	53                   	push   rbx
  415e38:	48 89 d3             	mov    rbx,rdx
  415e3b:	48 83 ec 10          	sub    rsp,0x10
  415e3f:	48 89 75 e8          	mov    QWORD PTR [rbp-0x18],rsi
	struct cos_defcompinfo *defci     = cos_defcompinfo_curr_get();
  415e43:	ff d0                	call   rax
  415e45:	48 89 c7             	mov    rdi,rax
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);
  415e48:	48 b8 60 ce 40 00 00 	movabs rax,0x40ce60
  415e4f:	00 00 00 
  415e52:	ff d0                	call   rax
	memset(t, 0, sizeof(struct slm_thd));
  415e54:	49 8d 7c 24 08       	lea    rdi,[r12+0x8]
  415e59:	4c 89 e1             	mov    rcx,r12
  415e5c:	49 c7 04 24 00 00 00 	mov    QWORD PTR [r12],0x0
  415e63:	00 
  415e64:	49 c7 44 24 70 00 00 	mov    QWORD PTR [r12+0x70],0x0
  415e6b:	00 00 
  415e6d:	48 83 e7 f8          	and    rdi,0xfffffffffffffff8
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);
  415e71:	49 89 c0             	mov    r8,rax
	memset(t, 0, sizeof(struct slm_thd));
  415e74:	31 c0                	xor    eax,eax
  415e76:	48 29 f9             	sub    rcx,rdi
  415e79:	83 c1 78             	add    ecx,0x78
  415e7c:	c1 e9 03             	shr    ecx,0x3
  415e7f:	f3 48 ab             	rep stos QWORD PTR es:[rdi],rax
	if ((ret = slm_timer_thd_init(t))) return ret;
  415e82:	4c 89 e7             	mov    rdi,r12
	*t = (struct slm_thd) {
  415e85:	48 b8 ff ff ff ff ff 	movabs rax,0xffffffffffff
  415e8c:	ff 00 00 
  415e8f:	f3 41 0f 7e 00       	movq   xmm0,QWORD PTR [r8]
  415e94:	49 89 44 24 30       	mov    QWORD PTR [r12+0x30],rax
	ps_list_init(t, thd_list);
  415e99:	49 8d 44 24 58       	lea    rax,[r12+0x58]
  415e9e:	66 48 0f 6e c8       	movq   xmm1,rax
	ps_list_init(t, graveyard_list);
  415ea3:	49 8d 44 24 68       	lea    rax,[r12+0x68]
	*t = (struct slm_thd) {
  415ea8:	49 89 5c 24 18       	mov    QWORD PTR [r12+0x18],rbx
  415ead:	41 c7 44 24 04 03 00 	mov    DWORD PTR [r12+0x4],0x3
  415eb4:	00 00 
{ l->n = l->p = l; }
  415eb6:	66 0f 6c c9          	punpcklqdq xmm1,xmm1
  415eba:	41 0f 11 4c 24 58    	movups XMMWORD PTR [r12+0x58],xmm1
  415ec0:	0f 16 45 e8          	movhps xmm0,QWORD PTR [rbp-0x18]
  415ec4:	41 0f 11 44 24 08    	movups XMMWORD PTR [r12+0x8],xmm0
	ps_list_init(t, graveyard_list);
  415eca:	66 48 0f 6e c0       	movq   xmm0,rax
	if ((ret = slm_timer_thd_init(t))) return ret;
  415ecf:	48 b8 20 1c 40 00 00 	movabs rax,0x401c20
  415ed6:	00 00 00 
  415ed9:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  415edd:	41 0f 11 44 24 68    	movups XMMWORD PTR [r12+0x68],xmm0
  415ee3:	ff d0                	call   rax
  415ee5:	85 c0                	test   eax,eax
  415ee7:	74 0f                	je     415ef8 <slm_thd_init+0xd8>
}
  415ee9:	48 83 c4 10          	add    rsp,0x10
  415eed:	5b                   	pop    rbx
  415eee:	41 5c                	pop    r12
  415ef0:	5d                   	pop    rbp
  415ef1:	c3                   	ret    
  415ef2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  415ef8:	48 83 c4 10          	add    rsp,0x10
	if ((ret = slm_sched_thd_init(t))) return ret;
  415efc:	4c 89 e7             	mov    rdi,r12
  415eff:	48 b8 80 1c 40 00 00 	movabs rax,0x401c80
  415f06:	00 00 00 
}
  415f09:	5b                   	pop    rbx
  415f0a:	41 5c                	pop    r12
  415f0c:	5d                   	pop    rbp
	if ((ret = slm_sched_thd_init(t))) return ret;
  415f0d:	ff e0                	jmp    rax
  415f0f:	90                   	nop

0000000000415f10 <slm_thd_deinit>:
{
  415f10:	f3 0f 1e fa          	endbr64 
	slm_sched_thd_deinit(t);
  415f14:	48 b8 90 1c 40 00 00 	movabs rax,0x401c90
  415f1b:	00 00 00 
{
  415f1e:	55                   	push   rbp
  415f1f:	48 89 e5             	mov    rbp,rsp
  415f22:	53                   	push   rbx
  415f23:	48 89 fb             	mov    rbx,rdi
  415f26:	48 83 ec 08          	sub    rsp,0x8
	slm_sched_thd_deinit(t);
  415f2a:	ff d0                	call   rax
	slm_timer_thd_deinit(t);
  415f2c:	48 89 df             	mov    rdi,rbx
  415f2f:	48 b8 30 1c 40 00 00 	movabs rax,0x401c30
  415f36:	00 00 00 
  415f39:	ff d0                	call   rax
	t->state = SLM_THD_DYING;
  415f3b:	c7 43 04 04 00 00 00 	mov    DWORD PTR [rbx+0x4],0x4
}
  415f42:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
  415f46:	c9                   	leave  
  415f47:	c3                   	ret    
  415f48:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  415f4f:	00 

0000000000415f50 <slm_cs_enter_contention>:
{
  415f50:	f3 0f 1e fa          	endbr64 
  415f54:	49 89 ca             	mov    r10,rcx
  415f57:	44 89 c9             	mov    ecx,r9d
	if (!contended) {
  415f5a:	45 85 c0             	test   r8d,r8d
  415f5d:	75 16                	jne    415f75 <slm_cs_enter_contention+0x25>
  415f5f:	48 89 f0             	mov    rax,rsi
	return !ps_cas(&cs->owner_contention, (unsigned long)cached, ((unsigned long)thd | !!contention));
  415f62:	4c 89 d6             	mov    rsi,r10
  415f65:	48 83 ce 01          	or     rsi,0x1
  415f69:	f0 48 0f b1 37       	lock cmpxchg QWORD PTR [rdi],rsi
  415f6e:	0f 94 c0             	sete   al
		if (__slm_cs_cas(cs, cached, owner, 1)) return 1;
  415f71:	84 c0                	test   al,al
  415f73:	74 2b                	je     415fa0 <slm_cs_enter_contention+0x50>
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  415f75:	48 b8 70 e1 40 00 00 	movabs rax,0x40e170
  415f7c:	00 00 00 
{
  415f7f:	55                   	push   rbp
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  415f80:	49 8b 7a 10          	mov    rdi,QWORD PTR [r10+0x10]
  415f84:	48 8b 72 30          	mov    rsi,QWORD PTR [rdx+0x30]
  415f88:	31 d2                	xor    edx,edx
{
  415f8a:	48 89 e5             	mov    rbp,rsp
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  415f8d:	ff d0                	call   rax
	if (ret) return ret;
  415f8f:	85 c0                	test   eax,eax
  415f91:	75 05                	jne    415f98 <slm_cs_enter_contention+0x48>
	return 1;
  415f93:	b8 01 00 00 00       	mov    eax,0x1
}
  415f98:	5d                   	pop    rbp
  415f99:	c3                   	ret    
  415f9a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	return 1;
  415fa0:	b8 01 00 00 00       	mov    eax,0x1
}
  415fa5:	c3                   	ret    
  415fa6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  415fad:	00 00 00 

0000000000415fb0 <slm_cs_exit_contention>:
{
  415fb0:	f3 0f 1e fa          	endbr64 
  415fb4:	49 89 f8             	mov    r8,rdi
  415fb7:	48 89 d0             	mov    rax,rdx
  415fba:	31 ff                	xor    edi,edi
  415fbc:	f0 49 0f b1 38       	lock cmpxchg QWORD PTR [r8],rdi
  415fc1:	0f 94 c0             	sete   al
	if (__slm_cs_cas(cs, cached, NULL, 0)) return 1;
  415fc4:	84 c0                	test   al,al
  415fc6:	75 08                	jne    415fd0 <slm_cs_exit_contention+0x20>
}
  415fc8:	b8 01 00 00 00       	mov    eax,0x1
  415fcd:	c3                   	ret    
  415fce:	66 90                	xchg   ax,ax
	ret = cos_defswitch(s->thd, curr->priority, TCAP_TIME_NIL, tok);
  415fd0:	48 b8 d8 5e 5a 00 00 	movabs rax,0x5a5ed8
  415fd7:	00 00 00 
{
  415fda:	55                   	push   rbp
	ret = cos_defswitch(s->thd, curr->priority, TCAP_TIME_NIL, tok);
  415fdb:	31 d2                	xor    edx,edx
  415fdd:	48 8b 38             	mov    rdi,QWORD PTR [rax]
  415fe0:	48 b8 70 e1 40 00 00 	movabs rax,0x40e170
  415fe7:	00 00 00 
  415fea:	48 8b 76 30          	mov    rsi,QWORD PTR [rsi+0x30]
{
  415fee:	48 89 e5             	mov    rbp,rsp
	ret = cos_defswitch(s->thd, curr->priority, TCAP_TIME_NIL, tok);
  415ff1:	ff d0                	call   rax
	return 0;
  415ff3:	45 31 c0             	xor    r8d,r8d
	assert(ret != -EINVAL);
  415ff6:	83 f8 ea             	cmp    eax,0xffffffea
  415ff9:	74 05                	je     416000 <slm_cs_exit_contention+0x50>
}
  415ffb:	44 89 c0             	mov    eax,r8d
  415ffe:	5d                   	pop    rbp
  415fff:	c3                   	ret    
  416000:	48 bf c8 17 42 00 00 	movabs rdi,0x4217c8
  416007:	00 00 00 
  41600a:	be 23 00 00 00       	mov    esi,0x23
  41600f:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  416016:	00 00 00 
  416019:	ff d0                	call   rax
	assert(ret != -EINVAL);
  41601b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  416022:	00 00 00 00 
  416026:	0f 0b                	ud2    
  416028:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41602f:	00 

0000000000416030 <slm_thd_block>:
{
  416030:	f3 0f 1e fa          	endbr64 
  416034:	55                   	push   rbp
  416035:	48 89 e5             	mov    rbp,rsp
	assert(t);
  416038:	48 85 ff             	test   rdi,rdi
  41603b:	74 7b                	je     4160b8 <slm_thd_block+0x88>
	return t != &g->idle_thd && t != &g->sched_thd;
  41603d:	48 b8 c8 5e 5a 00 00 	movabs rax,0x5a5ec8
  416044:	00 00 00 
  416047:	48 39 c7             	cmp    rdi,rax
  41604a:	74 44                	je     416090 <slm_thd_block+0x60>
  41604c:	48 83 c0 78          	add    rax,0x78
  416050:	48 39 c7             	cmp    rdi,rax
  416053:	74 3b                	je     416090 <slm_thd_block+0x60>
	if (unlikely(t->state == SLM_THD_WOKEN)) {
  416055:	8b 47 04             	mov    eax,DWORD PTR [rdi+0x4]
  416058:	83 f8 02             	cmp    eax,0x2
  41605b:	0f 84 7f 00 00 00    	je     4160e0 <slm_thd_block+0xb0>
	assert(t->state == SLM_THD_RUNNABLE);
  416061:	83 f8 03             	cmp    eax,0x3
  416064:	0f 85 89 00 00 00    	jne    4160f3 <slm_thd_block+0xc3>
	if (t->properties & SLM_THD_PROPERTY_SUSPENDED) {
  41606a:	8b 07                	mov    eax,DWORD PTR [rdi]
  41606c:	a8 04                	test   al,0x4
  41606e:	74 05                	je     416075 <slm_thd_block+0x45>
		t->properties &= ~SLM_THD_PROPERTY_SUSPENDED;
  416070:	83 e0 fb             	and    eax,0xfffffffb
  416073:	89 07                	mov    DWORD PTR [rdi],eax
	t->state = SLM_THD_BLOCKED;
  416075:	c7 47 04 01 00 00 00 	mov    DWORD PTR [rdi+0x4],0x1
	slm_sched_block(t);
  41607c:	48 b8 b0 1c 40 00 00 	movabs rax,0x401cb0
  416083:	00 00 00 
  416086:	ff d0                	call   rax
	return 0;
  416088:	31 c0                	xor    eax,eax
}
  41608a:	5d                   	pop    rbp
  41608b:	c3                   	ret    
  41608c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  416090:	48 bf 78 19 42 00 00 	movabs rdi,0x421978
  416097:	00 00 00 
  41609a:	be 23 00 00 00       	mov    esi,0x23
  41609f:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4160a6:	00 00 00 
  4160a9:	ff d0                	call   rax
	assert(slm_thd_normal(t));
  4160ab:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4160b2:	00 00 00 00 
  4160b6:	0f 0b                	ud2    
  4160b8:	48 bf 00 19 42 00 00 	movabs rdi,0x421900
  4160bf:	00 00 00 
  4160c2:	be 23 00 00 00       	mov    esi,0x23
  4160c7:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4160ce:	00 00 00 
  4160d1:	ff d0                	call   rax
	assert(t);
  4160d3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4160da:	00 00 00 00 
  4160de:	0f 0b                	ud2    
		assert(!(t->properties & SLM_THD_PROPERTY_SUSPENDED));
  4160e0:	f6 07 04             	test   BYTE PTR [rdi],0x4
  4160e3:	75 36                	jne    41611b <slm_thd_block+0xeb>
		t->state = SLM_THD_RUNNABLE;
  4160e5:	c7 47 04 03 00 00 00 	mov    DWORD PTR [rdi+0x4],0x3
		return 1;
  4160ec:	b8 01 00 00 00       	mov    eax,0x1
}
  4160f1:	5d                   	pop    rbp
  4160f2:	c3                   	ret    
  4160f3:	48 bf 50 19 42 00 00 	movabs rdi,0x421950
  4160fa:	00 00 00 
  4160fd:	be 23 00 00 00       	mov    esi,0x23
  416102:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  416109:	00 00 00 
  41610c:	ff d0                	call   rax
	assert(t->state == SLM_THD_RUNNABLE);
  41610e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  416115:	00 00 00 00 
  416119:	0f 0b                	ud2    
  41611b:	48 bf 28 19 42 00 00 	movabs rdi,0x421928
  416122:	00 00 00 
  416125:	be 23 00 00 00       	mov    esi,0x23
  41612a:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  416131:	00 00 00 
  416134:	ff d0                	call   rax
		assert(!(t->properties & SLM_THD_PROPERTY_SUSPENDED));
  416136:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41613d:	00 00 00 00 
  416141:	0f 0b                	ud2    
  416143:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41614a:	00 00 00 00 
  41614e:	66 90                	xchg   ax,ax

0000000000416150 <slm_thd_block_cs>:
{
  416150:	f3 0f 1e fa          	endbr64 
  416154:	55                   	push   rbp
  416155:	48 89 e5             	mov    rbp,rsp
  416158:	41 57                	push   r15
  41615a:	41 56                	push   r14
  41615c:	49 be c0 5e 5a 00 00 	movabs r14,0x5a5ec0
  416163:	00 00 00 
  416166:	41 55                	push   r13
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  416168:	49 bd 70 e1 40 00 00 	movabs r13,0x40e170
  41616f:	00 00 00 
{
  416172:	41 54                	push   r12
  416174:	49 89 fc             	mov    r12,rdi
  416177:	53                   	push   rbx
  416178:	48 bb d0 35 41 00 00 	movabs rbx,0x4135d0
  41617f:	00 00 00 
  416182:	48 83 ec 18          	sub    rsp,0x18
	assert(current);
  416186:	48 85 ff             	test   rdi,rdi
  416189:	0f 84 1b 02 00 00    	je     4163aa <slm_thd_block_cs+0x25a>
		tok    = cos_sched_sync();
  41618f:	ff d3                	call   rbx
  416191:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  416193:	49 8b 06             	mov    rax,QWORD PTR [r14]
		if (unlikely(owner)) {
  416196:	48 89 c2             	mov    rdx,rax
  416199:	48 83 e2 fe          	and    rdx,0xfffffffffffffffe
  41619d:	0f 85 ad 01 00 00    	jne    416350 <slm_thd_block_cs+0x200>
  4161a3:	f0 4d 0f b1 26       	lock cmpxchg QWORD PTR [r14],r12
  4161a8:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4161ab:	84 c0                	test   al,al
  4161ad:	74 e0                	je     41618f <slm_thd_block_cs+0x3f>
	if (slm_thd_block(current)) {
  4161af:	48 b8 30 60 41 00 00 	movabs rax,0x416030
  4161b6:	00 00 00 
  4161b9:	4c 89 e7             	mov    rdi,r12
  4161bc:	ff d0                	call   rax
  4161be:	85 c0                	test   eax,eax
  4161c0:	0f 85 02 01 00 00    	jne    4162c8 <slm_thd_block_cs+0x178>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  4161c6:	49 bf 10 ce 40 00 00 	movabs r15,0x40ce10
  4161cd:	00 00 00 
  4161d0:	41 ff d7             	call   r15
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  4161d3:	4c 89 65 c8          	mov    QWORD PTR [rbp-0x38],r12
	tok  = cos_sched_sync();
  4161d7:	ff d3                	call   rbx
  4161d9:	41 89 c5             	mov    r13d,eax
	t = slm_sched_schedule();
  4161dc:	48 b8 e0 1c 40 00 00 	movabs rax,0x401ce0
  4161e3:	00 00 00 
  4161e6:	ff d0                	call   rax
	if (unlikely(!t)) t = &g->idle_thd;
  4161e8:	48 85 c0             	test   rax,rax
	t = slm_sched_schedule();
  4161eb:	49 89 c4             	mov    r12,rax
	if (unlikely(!t)) t = &g->idle_thd;
  4161ee:	48 b8 40 5f 5a 00 00 	movabs rax,0x5a5f40
  4161f5:	00 00 00 
  4161f8:	4c 0f 44 e0          	cmove  r12,rax
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  4161fc:	41 8b 44 24 04       	mov    eax,DWORD PTR [r12+0x4]
  416201:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  416204:	83 f8 01             	cmp    eax,0x1
  416207:	76 16                	jbe    41621f <slm_thd_block_cs+0xcf>
  416209:	e9 12 02 00 00       	jmp    416420 <slm_thd_block_cs+0x2d0>
  41620e:	66 90                	xchg   ax,ax
  416210:	48 89 d0             	mov    rax,rdx
  416213:	f0 49 0f b1 36       	lock cmpxchg QWORD PTR [r14],rsi
  416218:	0f 94 c0             	sete   al
	while (ret != 0) {
  41621b:	84 c0                	test   al,al
  41621d:	75 4c                	jne    41626b <slm_thd_block_cs+0x11b>
		tok    = cos_sched_sync();
  41621f:	ff d3                	call   rbx
	unsigned long oc = ps_load(&cs->owner_contention);
  416221:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  416224:	89 c1                	mov    ecx,eax
		if (unlikely(contention)) {
  416226:	48 89 d6             	mov    rsi,rdx
  416229:	83 e6 01             	and    esi,0x1
  41622c:	74 e2                	je     416210 <slm_thd_block_cs+0xc0>
  41622e:	31 ff                	xor    edi,edi
  416230:	48 89 d0             	mov    rax,rdx
  416233:	f0 49 0f b1 3e       	lock cmpxchg QWORD PTR [r14],rdi
  416238:	0f 94 c0             	sete   al
	if (__slm_cs_cas(cs, cached, NULL, 0)) return 1;
  41623b:	84 c0                	test   al,al
  41623d:	74 e0                	je     41621f <slm_thd_block_cs+0xcf>
	ret = cos_defswitch(s->thd, curr->priority, TCAP_TIME_NIL, tok);
  41623f:	48 b8 d8 5e 5a 00 00 	movabs rax,0x5a5ed8
  416246:	00 00 00 
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  416249:	48 83 e2 fe          	and    rdx,0xfffffffffffffffe
  41624d:	48 8b 38             	mov    rdi,QWORD PTR [rax]
  416250:	48 b8 70 e1 40 00 00 	movabs rax,0x40e170
  416257:	00 00 00 
  41625a:	48 8b 72 30          	mov    rsi,QWORD PTR [rdx+0x30]
  41625e:	31 d2                	xor    edx,edx
  416260:	ff d0                	call   rax
	assert(ret != -EINVAL);
  416262:	83 f8 ea             	cmp    eax,0xffffffea
  416265:	0f 84 b7 00 00 00    	je     416322 <slm_thd_block_cs+0x1d2>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  41626b:	41 ff d7             	call   r15
	prio = inherit_prio ? curr->priority : t->priority;
  41626e:	49 8b 74 24 30       	mov    rsi,QWORD PTR [r12+0x30]
	timeout = g->timeout_next;
  416273:	48 b8 c8 5f 5a 00 00 	movabs rax,0x5a5fc8
  41627a:	00 00 00 
  41627d:	4c 8b 00             	mov    r8,QWORD PTR [rax]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  416280:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  416284:	a8 0b                	test   al,0xb
  416286:	0f 85 bc 01 00 00    	jne    416448 <slm_thd_block_cs+0x2f8>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  41628c:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  416291:	44 89 e9             	mov    ecx,r13d
  416294:	4c 89 c2             	mov    rdx,r8
  416297:	48 b8 70 e1 40 00 00 	movabs rax,0x40e170
  41629e:	00 00 00 
  4162a1:	ff d0                	call   rax
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  4162a3:	83 f8 ff             	cmp    eax,0xffffffff
  4162a6:	0f 84 2a 02 00 00    	je     4164d6 <slm_thd_block_cs+0x386>
	if (unlikely(ret != 0)) {
  4162ac:	85 c0                	test   eax,eax
  4162ae:	0f 85 1e 01 00 00    	jne    4163d2 <slm_thd_block_cs+0x282>
}
  4162b4:	48 83 c4 18          	add    rsp,0x18
  4162b8:	5b                   	pop    rbx
  4162b9:	41 5c                	pop    r12
  4162bb:	41 5d                	pop    r13
  4162bd:	41 5e                	pop    r14
  4162bf:	41 5f                	pop    r15
  4162c1:	5d                   	pop    rbp
  4162c2:	c3                   	ret    
  4162c3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  4162c8:	45 31 e4             	xor    r12d,r12d
  4162cb:	eb 0f                	jmp    4162dc <slm_thd_block_cs+0x18c>
  4162cd:	0f 1f 00             	nop    DWORD PTR [rax]
  4162d0:	f0 49 0f b1 36       	lock cmpxchg QWORD PTR [r14],rsi
  4162d5:	0f 94 c0             	sete   al
	while (ret != 0) {
  4162d8:	84 c0                	test   al,al
  4162da:	75 d8                	jne    4162b4 <slm_thd_block_cs+0x164>
		tok    = cos_sched_sync();
  4162dc:	ff d3                	call   rbx
	unsigned long oc = ps_load(&cs->owner_contention);
  4162de:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4162e1:	89 c1                	mov    ecx,eax
		if (unlikely(contention)) {
  4162e3:	48 89 d6             	mov    rsi,rdx
  4162e6:	48 89 d0             	mov    rax,rdx
  4162e9:	83 e6 01             	and    esi,0x1
  4162ec:	74 e2                	je     4162d0 <slm_thd_block_cs+0x180>
  4162ee:	f0 4d 0f b1 26       	lock cmpxchg QWORD PTR [r14],r12
  4162f3:	0f 94 c0             	sete   al
	if (__slm_cs_cas(cs, cached, NULL, 0)) return 1;
  4162f6:	84 c0                	test   al,al
  4162f8:	74 e2                	je     4162dc <slm_thd_block_cs+0x18c>
	ret = cos_defswitch(s->thd, curr->priority, TCAP_TIME_NIL, tok);
  4162fa:	48 b8 d8 5e 5a 00 00 	movabs rax,0x5a5ed8
  416301:	00 00 00 
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  416304:	48 83 e2 fe          	and    rdx,0xfffffffffffffffe
  416308:	48 8b 38             	mov    rdi,QWORD PTR [rax]
  41630b:	48 b8 70 e1 40 00 00 	movabs rax,0x40e170
  416312:	00 00 00 
  416315:	48 8b 72 30          	mov    rsi,QWORD PTR [rdx+0x30]
  416319:	31 d2                	xor    edx,edx
  41631b:	ff d0                	call   rax
	assert(ret != -EINVAL);
  41631d:	83 f8 ea             	cmp    eax,0xffffffea
  416320:	75 92                	jne    4162b4 <slm_thd_block_cs+0x164>
  416322:	48 bf c8 17 42 00 00 	movabs rdi,0x4217c8
  416329:	00 00 00 
  41632c:	be 23 00 00 00       	mov    esi,0x23
  416331:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  416338:	00 00 00 
  41633b:	ff d0                	call   rax
  41633d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  416344:	00 00 00 00 
  416348:	0f 0b                	ud2    
  41634a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	if (!contended) {
  416350:	a8 01                	test   al,0x1
  416352:	75 17                	jne    41636b <slm_thd_block_cs+0x21b>
	return !ps_cas(&cs->owner_contention, (unsigned long)cached, ((unsigned long)thd | !!contention));
  416354:	48 89 d6             	mov    rsi,rdx
  416357:	48 83 ce 01          	or     rsi,0x1
  41635b:	f0 49 0f b1 36       	lock cmpxchg QWORD PTR [r14],rsi
  416360:	0f 94 c0             	sete   al
		if (__slm_cs_cas(cs, cached, owner, 1)) return 1;
  416363:	84 c0                	test   al,al
  416365:	0f 84 24 fe ff ff    	je     41618f <slm_thd_block_cs+0x3f>
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  41636b:	48 8b 7a 10          	mov    rdi,QWORD PTR [rdx+0x10]
  41636f:	49 8b 74 24 30       	mov    rsi,QWORD PTR [r12+0x30]
  416374:	31 d2                	xor    edx,edx
  416376:	41 ff d5             	call   r13
			assert(ret != -EBUSY);
  416379:	83 f8 f0             	cmp    eax,0xfffffff0
  41637c:	0f 85 0d fe ff ff    	jne    41618f <slm_thd_block_cs+0x3f>
  416382:	48 bf b0 18 42 00 00 	movabs rdi,0x4218b0
  416389:	00 00 00 
  41638c:	be 25 00 00 00       	mov    esi,0x25
  416391:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  416398:	00 00 00 
  41639b:	ff d0                	call   rax
  41639d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4163a4:	00 00 00 00 
  4163a8:	0f 0b                	ud2    
  4163aa:	48 bf a0 19 42 00 00 	movabs rdi,0x4219a0
  4163b1:	00 00 00 
  4163b4:	be 25 00 00 00       	mov    esi,0x25
  4163b9:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4163c0:	00 00 00 
  4163c3:	ff d0                	call   rax
	assert(current);
  4163c5:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4163cc:	00 00 00 00 
  4163d0:	0f 0b                	ud2    
		assert(ret != -EINVAL);
  4163d2:	83 f8 ea             	cmp    eax,0xffffffea
  4163d5:	0f 84 79 01 00 00    	je     416554 <slm_thd_block_cs+0x404>
		if (ret == -EBUSY) return ret;
  4163db:	83 f8 f0             	cmp    eax,0xfffffff0
  4163de:	0f 84 d0 fe ff ff    	je     4162b4 <slm_thd_block_cs+0x164>
		assert(ret == -EAGAIN);
  4163e4:	83 f8 f5             	cmp    eax,0xfffffff5
  4163e7:	0f 85 f3 01 00 00    	jne    4165e0 <slm_thd_block_cs+0x490>
  4163ed:	4c 8b 65 c8          	mov    r12,QWORD PTR [rbp-0x38]
		tok    = cos_sched_sync();
  4163f1:	ff d3                	call   rbx
  4163f3:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4163f5:	49 8b 06             	mov    rax,QWORD PTR [r14]
		if (unlikely(owner)) {
  4163f8:	48 89 c6             	mov    rsi,rax
  4163fb:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  4163ff:	0f 85 77 01 00 00    	jne    41657c <slm_thd_block_cs+0x42c>
  416405:	f0 4d 0f b1 26       	lock cmpxchg QWORD PTR [r14],r12
  41640a:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  41640d:	84 c0                	test   al,al
  41640f:	0f 85 c2 fd ff ff    	jne    4161d7 <slm_thd_block_cs+0x87>
  416415:	eb da                	jmp    4163f1 <slm_thd_block_cs+0x2a1>
  416417:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41641e:	00 00 
  416420:	48 bf f0 17 42 00 00 	movabs rdi,0x4217f0
  416427:	00 00 00 
  41642a:	be 2d 00 00 00       	mov    esi,0x2d
  41642f:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  416436:	00 00 00 
  416439:	ff d0                	call   rax
	assert(slm_state_is_runnable(t->state));
  41643b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  416442:	00 00 00 00 
  416446:	0f 0b                	ud2    
		if (t == &g->sched_thd) {
  416448:	48 ba c8 5e 5a 00 00 	movabs rdx,0x5a5ec8
  41644f:	00 00 00 
	timeout = g->timeout_next;
  416452:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  416455:	49 39 d4             	cmp    r12,rdx
  416458:	0f 84 be 00 00 00    	je     41651c <slm_thd_block_cs+0x3cc>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  41645e:	a8 02                	test   al,0x2
  416460:	0f 85 c5 00 00 00    	jne    41652b <slm_thd_block_cs+0x3db>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  416466:	49 89 c8             	mov    r8,rcx
  416469:	a8 01                	test   al,0x1
  41646b:	0f 84 1b fe ff ff    	je     41628c <slm_thd_block_cs+0x13c>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  416471:	4d 8b 54 24 08       	mov    r10,QWORD PTR [r12+0x8]
  416476:	48 89 f2             	mov    rdx,rsi
  416479:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  41647e:	45 89 e9             	mov    r9d,r13d
  416481:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  416488:	00 00 00 
  41648b:	4c 8b 00             	mov    r8,QWORD PTR [rax]
  41648e:	48 b8 f0 35 41 00 00 	movabs rax,0x4135f0
  416495:	00 00 00 
  416498:	4c 89 d6             	mov    rsi,r10
  41649b:	ff d0                	call   rax
	if (unlikely(ret != 0)) {
  41649d:	85 c0                	test   eax,eax
  41649f:	0f 84 0f fe ff ff    	je     4162b4 <slm_thd_block_cs+0x164>
		assert(ret != -EPERM);
  4164a5:	83 f8 ff             	cmp    eax,0xffffffff
  4164a8:	0f 85 24 ff ff ff    	jne    4163d2 <slm_thd_block_cs+0x282>
  4164ae:	48 bf 20 18 42 00 00 	movabs rdi,0x421820
  4164b5:	00 00 00 
  4164b8:	be 2d 00 00 00       	mov    esi,0x2d
  4164bd:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4164c4:	00 00 00 
  4164c7:	ff d0                	call   rax
  4164c9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4164d0:	00 00 00 00 
  4164d4:	0f 0b                	ud2    
	return t != &g->idle_thd && t != &g->sched_thd;
  4164d6:	48 b8 40 5f 5a 00 00 	movabs rax,0x5a5f40
  4164dd:	00 00 00 
  4164e0:	49 39 c4             	cmp    r12,rax
  4164e3:	74 09                	je     4164ee <slm_thd_block_cs+0x39e>
  4164e5:	48 83 e8 78          	sub    rax,0x78
  4164e9:	49 39 c4             	cmp    r12,rax
  4164ec:	75 c0                	jne    4164ae <slm_thd_block_cs+0x35e>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  4164ee:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  4164f2:	45 89 e9             	mov    r9d,r13d
  4164f5:	31 c9                	xor    ecx,ecx
  4164f7:	31 f6                	xor    esi,esi
  4164f9:	48 8b 50 30          	mov    rdx,QWORD PTR [rax+0x30]
  4164fd:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  416504:	00 00 00 
  416507:	4c 8b 00             	mov    r8,QWORD PTR [rax]
  41650a:	48 8b 78 f0          	mov    rdi,QWORD PTR [rax-0x10]
  41650e:	48 b8 f0 35 41 00 00 	movabs rax,0x4135f0
  416515:	00 00 00 
  416518:	ff d0                	call   rax
  41651a:	eb 81                	jmp    41649d <slm_thd_block_cs+0x34d>
			prio    = curr->priority;
  41651c:	48 8b 7d c8          	mov    rdi,QWORD PTR [rbp-0x38]
			timeout = TCAP_TIME_NIL;
  416520:	31 c9                	xor    ecx,ecx
			prio    = curr->priority;
  416522:	48 8b 77 30          	mov    rsi,QWORD PTR [rdi+0x30]
  416526:	e9 33 ff ff ff       	jmp    41645e <slm_thd_block_cs+0x30e>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  41652b:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  416532:	00 00 00 
  416535:	49 8b 7c 24 28       	mov    rdi,QWORD PTR [r12+0x28]
  41653a:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  41653d:	44 89 e9             	mov    ecx,r13d
  416540:	48 b8 60 36 41 00 00 	movabs rax,0x413660
  416547:	00 00 00 
  41654a:	4c 89 c6             	mov    rsi,r8
  41654d:	ff d0                	call   rax
  41654f:	e9 49 ff ff ff       	jmp    41649d <slm_thd_block_cs+0x34d>
  416554:	48 bf 50 18 42 00 00 	movabs rdi,0x421850
  41655b:	00 00 00 
  41655e:	be 2d 00 00 00       	mov    esi,0x2d
  416563:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  41656a:	00 00 00 
  41656d:	ff d0                	call   rax
		assert(ret != -EINVAL);
  41656f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  416576:	00 00 00 00 
  41657a:	0f 0b                	ud2    
	if (!contended) {
  41657c:	a8 01                	test   al,0x1
  41657e:	75 17                	jne    416597 <slm_thd_block_cs+0x447>
	return !ps_cas(&cs->owner_contention, (unsigned long)cached, ((unsigned long)thd | !!contention));
  416580:	48 89 f2             	mov    rdx,rsi
  416583:	48 83 ca 01          	or     rdx,0x1
  416587:	f0 49 0f b1 16       	lock cmpxchg QWORD PTR [r14],rdx
  41658c:	0f 94 c0             	sete   al
		if (__slm_cs_cas(cs, cached, owner, 1)) return 1;
  41658f:	84 c0                	test   al,al
  416591:	0f 84 5a fe ff ff    	je     4163f1 <slm_thd_block_cs+0x2a1>
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  416597:	4d 8b 44 24 30       	mov    r8,QWORD PTR [r12+0x30]
  41659c:	48 8b 7e 10          	mov    rdi,QWORD PTR [rsi+0x10]
  4165a0:	31 d2                	xor    edx,edx
  4165a2:	48 b8 70 e1 40 00 00 	movabs rax,0x40e170
  4165a9:	00 00 00 
  4165ac:	4c 89 c6             	mov    rsi,r8
  4165af:	ff d0                	call   rax
			assert(ret != -EBUSY);
  4165b1:	83 f8 f0             	cmp    eax,0xfffffff0
  4165b4:	0f 85 37 fe ff ff    	jne    4163f1 <slm_thd_block_cs+0x2a1>
  4165ba:	48 bf b0 18 42 00 00 	movabs rdi,0x4218b0
  4165c1:	00 00 00 
  4165c4:	48 b8 c0 53 41 00 00 	movabs rax,0x4153c0
  4165cb:	00 00 00 
  4165ce:	ff d0                	call   rax
  4165d0:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4165d7:	00 00 00 00 
  4165db:	0f 0b                	ud2    
  4165dd:	0f 1f 00             	nop    DWORD PTR [rax]
  4165e0:	48 bf 80 18 42 00 00 	movabs rdi,0x421880
  4165e7:	00 00 00 
  4165ea:	be 2d 00 00 00       	mov    esi,0x2d
  4165ef:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4165f6:	00 00 00 
  4165f9:	ff d0                	call   rax
		assert(ret == -EAGAIN);
  4165fb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  416602:	00 00 00 00 
  416606:	0f 0b                	ud2    
  416608:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41660f:	00 

0000000000416610 <slm_thd_sched_wakeup>:
{
  416610:	f3 0f 1e fa          	endbr64 
  416614:	55                   	push   rbp
  416615:	48 89 e5             	mov    rbp,rsp
	assert(t);
  416618:	48 85 ff             	test   rdi,rdi
  41661b:	74 32                	je     41664f <slm_thd_sched_wakeup+0x3f>
	if (unlikely(!(t->properties & SLM_THD_PROPERTY_SUSPENDED))) return 1;
  41661d:	8b 07                	mov    eax,DWORD PTR [rdi]
  41661f:	a8 04                	test   al,0x4
  416621:	74 54                	je     416677 <slm_thd_sched_wakeup+0x67>
	t->properties &= ~SLM_THD_PROPERTY_SUSPENDED;
  416623:	83 e0 fb             	and    eax,0xfffffffb
  416626:	89 07                	mov    DWORD PTR [rdi],eax
	if (unlikely(slm_state_is_runnable(t->state))) {
  416628:	8b 47 04             	mov    eax,DWORD PTR [rdi+0x4]
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  41662b:	8d 50 fe             	lea    edx,[rax-0x2]
  41662e:	83 fa 01             	cmp    edx,0x1
  416631:	76 4b                	jbe    41667e <slm_thd_sched_wakeup+0x6e>
	assert(t->state == SLM_THD_BLOCKED);
  416633:	83 f8 01             	cmp    eax,0x1
  416636:	75 54                	jne    41668c <slm_thd_sched_wakeup+0x7c>
	t->state = SLM_THD_RUNNABLE;
  416638:	c7 47 04 03 00 00 00 	mov    DWORD PTR [rdi+0x4],0x3
	slm_sched_wakeup(t);
  41663f:	48 b8 c0 1c 40 00 00 	movabs rax,0x401cc0
  416646:	00 00 00 
  416649:	ff d0                	call   rax
	return 0;
  41664b:	31 c0                	xor    eax,eax
}
  41664d:	5d                   	pop    rbp
  41664e:	c3                   	ret    
  41664f:	48 bf c8 19 42 00 00 	movabs rdi,0x4219c8
  416656:	00 00 00 
  416659:	be 23 00 00 00       	mov    esi,0x23
  41665e:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  416665:	00 00 00 
  416668:	ff d0                	call   rax
	assert(t);
  41666a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  416671:	00 00 00 00 
  416675:	0f 0b                	ud2    
	if (unlikely(!(t->properties & SLM_THD_PROPERTY_SUSPENDED))) return 1;
  416677:	b8 01 00 00 00       	mov    eax,0x1
}
  41667c:	5d                   	pop    rbp
  41667d:	c3                   	ret    
		t->state = SLM_THD_RUNNABLE;
  41667e:	c7 47 04 03 00 00 00 	mov    DWORD PTR [rdi+0x4],0x3
		return 1;
  416685:	b8 01 00 00 00       	mov    eax,0x1
}
  41668a:	5d                   	pop    rbp
  41668b:	c3                   	ret    
  41668c:	48 bf a0 17 42 00 00 	movabs rdi,0x4217a0
  416693:	00 00 00 
  416696:	be 23 00 00 00       	mov    esi,0x23
  41669b:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4166a2:	00 00 00 
  4166a5:	ff d0                	call   rax
	assert(t->state == SLM_THD_BLOCKED);
  4166a7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4166ae:	00 00 00 00 
  4166b2:	0f 0b                	ud2    
  4166b4:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4166bb:	00 00 00 00 
  4166bf:	90                   	nop

00000000004166c0 <slm_thd_wakeup>:
{
  4166c0:	f3 0f 1e fa          	endbr64 
  4166c4:	55                   	push   rbp
  4166c5:	48 89 e5             	mov    rbp,rsp
  4166c8:	41 55                	push   r13
  4166ca:	41 54                	push   r12
  4166cc:	53                   	push   rbx
  4166cd:	48 83 ec 08          	sub    rsp,0x8
	assert(t);
  4166d1:	48 85 ff             	test   rdi,rdi
  4166d4:	0f 84 8a 00 00 00    	je     416764 <slm_thd_wakeup+0xa4>
	if (unlikely(t->cpuid != cos_cpuid())) {
  4166da:	4c 63 67 38          	movsxd r12,DWORD PTR [rdi+0x38]
  4166de:	48 89 fb             	mov    rbx,rdi
  4166e1:	45 85 e4             	test   r12d,r12d
  4166e4:	0f 85 a2 00 00 00    	jne    41678c <slm_thd_wakeup+0xcc>
	if (t->state == SLM_THD_WOKEN) return 1;
  4166ea:	8b 47 04             	mov    eax,DWORD PTR [rdi+0x4]
  4166ed:	83 f8 02             	cmp    eax,0x2
  4166f0:	74 5e                	je     416750 <slm_thd_wakeup+0x90>
	if (unlikely(t->state == SLM_THD_RUNNABLE || (redundant && t->state == SLM_THD_WOKEN))) {
  4166f2:	83 f8 03             	cmp    eax,0x3
  4166f5:	0f 84 3c 01 00 00    	je     416837 <slm_thd_wakeup+0x177>
	assert(t->state == SLM_THD_BLOCKED);
  4166fb:	83 f8 01             	cmp    eax,0x1
  4166fe:	0f 85 45 01 00 00    	jne    416849 <slm_thd_wakeup+0x189>
	return t != &g->idle_thd && t != &g->sched_thd;
  416704:	48 b8 c8 5e 5a 00 00 	movabs rax,0x5a5ec8
  41670b:	00 00 00 
  41670e:	48 39 c7             	cmp    rdi,rax
  416711:	0f 84 61 01 00 00    	je     416878 <slm_thd_wakeup+0x1b8>
  416717:	48 83 c0 78          	add    rax,0x78
  41671b:	48 39 c7             	cmp    rdi,rax
  41671e:	0f 84 54 01 00 00    	je     416878 <slm_thd_wakeup+0x1b8>
	t->state = SLM_THD_RUNNABLE;
  416724:	c7 47 04 03 00 00 00 	mov    DWORD PTR [rdi+0x4],0x3
	slm_sched_wakeup(t);
  41672b:	48 b8 c0 1c 40 00 00 	movabs rax,0x401cc0
  416732:	00 00 00 
  416735:	ff d0                	call   rax
	t->properties &= ~SLM_THD_PROPERTY_SUSPENDED;
  416737:	83 23 fb             	and    DWORD PTR [rbx],0xfffffffb
}
  41673a:	48 83 c4 08          	add    rsp,0x8
  41673e:	44 89 e0             	mov    eax,r12d
  416741:	5b                   	pop    rbx
  416742:	41 5c                	pop    r12
  416744:	41 5d                	pop    r13
  416746:	5d                   	pop    rbp
  416747:	c3                   	ret    
  416748:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41674f:	00 
  416750:	48 83 c4 08          	add    rsp,0x8
	if (t->state == SLM_THD_WOKEN) return 1;
  416754:	41 bc 01 00 00 00    	mov    r12d,0x1
}
  41675a:	5b                   	pop    rbx
  41675b:	44 89 e0             	mov    eax,r12d
  41675e:	41 5c                	pop    r12
  416760:	41 5d                	pop    r13
  416762:	5d                   	pop    rbp
  416763:	c3                   	ret    
  416764:	48 bf f0 19 42 00 00 	movabs rdi,0x4219f0
  41676b:	00 00 00 
  41676e:	be 23 00 00 00       	mov    esi,0x23
  416773:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  41677a:	00 00 00 
  41677d:	ff d0                	call   rax
	assert(t);
  41677f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  416786:	00 00 00 00 
  41678a:	0f 0b                	ud2    
		event.tid = t->tid;
  41678c:	4d 69 d4 c0 10 00 00 	imul   r10,r12,0x10c0
  416793:	4c 8b 5f 18          	mov    r11,QWORD PTR [rdi+0x18]
	const unsigned int mask = ring->mask;
  416797:	49 b9 00 4e 5a 00 00 	movabs r9,0x5a4e00
  41679e:	00 00 00 
  4167a1:	47 8b 84 11 a4 00 00 	mov    r8d,DWORD PTR [r9+r10*1+0xa4]
  4167a8:	00 
  4167a9:	49 8d 9a a8 00 00 00 	lea    rbx,[r10+0xa8]
	producer = ck_pr_load_uint(&ring->p_head);
  4167b0:	4b 8d 4c 11 64       	lea    rcx,[r9+r10*1+0x64]
  4167b5:	8b 11                	mov    edx,DWORD PTR [rcx]
		consumer = ck_pr_load_uint(&ring->c_head);
  4167b7:	4f 8d 6c 11 20       	lea    r13,[r9+r10*1+0x20]
  4167bc:	eb 0c                	jmp    4167ca <slm_thd_wakeup+0x10a>
  4167be:	66 90                	xchg   ax,ax
CK_PR_CAS_S(uint, unsigned int, "cmpxchgl")
  4167c0:	89 d0                	mov    eax,edx
  4167c2:	f0 0f b1 31          	lock cmpxchg DWORD PTR [rcx],esi
  4167c6:	89 c2                	mov    edx,eax
			if (ck_pr_cas_uint_value(&ring->p_head,
  4167c8:	74 1e                	je     4167e8 <slm_thd_wakeup+0x128>
CK_PR_LOAD_S(uint, unsigned int, "movl")
  4167ca:	41 8b 7d 00          	mov    edi,DWORD PTR [r13+0x0]
		if (CK_CC_LIKELY((producer - consumer) < mask)) {
  4167ce:	89 d0                	mov    eax,edx
		delta = producer + 1;
  4167d0:	8d 72 01             	lea    esi,[rdx+0x1]
		if (CK_CC_LIKELY((producer - consumer) < mask)) {
  4167d3:	29 f8                	sub    eax,edi
  4167d5:	41 39 c0             	cmp    r8d,eax
  4167d8:	77 e6                	ja     4167c0 <slm_thd_wakeup+0x100>
  4167da:	8b 01                	mov    eax,DWORD PTR [rcx]
			if (producer == new_producer) {
  4167dc:	39 c2                	cmp    edx,eax
  4167de:	0f 84 bc 00 00 00    	je     4168a0 <slm_thd_wakeup+0x1e0>
  4167e4:	89 c2                	mov    edx,eax
  4167e6:	eb e2                	jmp    4167ca <slm_thd_wakeup+0x10a>
	buffer = (char *)buffer + ts * (producer & mask);
  4167e8:	41 21 c0             	and    r8d,eax
  4167eb:	42 8d 0c c5 00 00 00 	lea    ecx,[r8*8+0x0]
  4167f2:	00 
	memcpy(buffer, entry, ts);
  4167f3:	48 01 cb             	add    rbx,rcx
	while (ck_pr_load_uint(&ring->p_tail) != producer)
  4167f6:	4b 8d 4c 11 60       	lea    rcx,[r9+r10*1+0x60]
	memcpy(buffer, entry, ts);
  4167fb:	4d 89 1c 19          	mov    QWORD PTR [r9+rbx*1],r11
  4167ff:	8b 39                	mov    edi,DWORD PTR [rcx]
	while (ck_pr_load_uint(&ring->p_tail) != producer)
  416801:	39 c7                	cmp    edi,eax
  416803:	74 0b                	je     416810 <slm_thd_wakeup+0x150>
  416805:	0f 1f 00             	nop    DWORD PTR [rax]
	__asm__ __volatile__("pause" ::: "memory");
  416808:	f3 90                	pause  
CK_PR_LOAD_S(uint, unsigned int, "movl")
  41680a:	8b 11                	mov    edx,DWORD PTR [rcx]
  41680c:	39 d0                	cmp    eax,edx
  41680e:	75 f8                	jne    416808 <slm_thd_wakeup+0x148>
CK_PR_STORE_S(uint, unsigned int, "movl", CK_CC_IMM_U32)
  416810:	89 31                	mov    DWORD PTR [rcx],esi
		cos_asnd(ipi_data->ipi_thd.asnd, 1);
  416812:	4d 69 e4 c0 10 00 00 	imul   r12,r12,0x10c0
  416819:	be 01 00 00 00       	mov    esi,0x1
  41681e:	48 b8 c0 36 41 00 00 	movabs rax,0x4136c0
  416825:	00 00 00 
  416828:	4b 8b 7c 21 08       	mov    rdi,QWORD PTR [r9+r12*1+0x8]
		return 0;
  41682d:	45 31 e4             	xor    r12d,r12d
		cos_asnd(ipi_data->ipi_thd.asnd, 1);
  416830:	ff d0                	call   rax
		return 0;
  416832:	e9 03 ff ff ff       	jmp    41673a <slm_thd_wakeup+0x7a>
		t->state = SLM_THD_WOKEN;
  416837:	c7 47 04 02 00 00 00 	mov    DWORD PTR [rdi+0x4],0x2
		return 1;
  41683e:	41 bc 01 00 00 00    	mov    r12d,0x1
  416844:	e9 f1 fe ff ff       	jmp    41673a <slm_thd_wakeup+0x7a>
  416849:	48 bf 18 1a 42 00 00 	movabs rdi,0x421a18
  416850:	00 00 00 
  416853:	be 23 00 00 00       	mov    esi,0x23
  416858:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  41685f:	00 00 00 
  416862:	ff d0                	call   rax
	assert(t->state == SLM_THD_BLOCKED);
  416864:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41686b:	00 00 00 00 
  41686f:	0f 0b                	ud2    
  416871:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  416878:	48 bf 68 1a 42 00 00 	movabs rdi,0x421a68
  41687f:	00 00 00 
  416882:	be 23 00 00 00       	mov    esi,0x23
  416887:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  41688e:	00 00 00 
  416891:	ff d0                	call   rax
	assert(slm_thd_normal(t));
  416893:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41689a:	00 00 00 00 
  41689e:	0f 0b                	ud2    
  4168a0:	48 bf 40 1a 42 00 00 	movabs rdi,0x421a40
  4168a7:	00 00 00 
  4168aa:	be 23 00 00 00       	mov    esi,0x23
  4168af:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4168b6:	00 00 00 
  4168b9:	ff d0                	call   rax
		assert(ret);
  4168bb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4168c2:	00 00 00 00 
  4168c6:	0f 0b                	ud2    
  4168c8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4168cf:	00 

00000000004168d0 <slm_thd_wakeup_cs>:
{
  4168d0:	f3 0f 1e fa          	endbr64 
  4168d4:	55                   	push   rbp
  4168d5:	48 89 e5             	mov    rbp,rsp
  4168d8:	41 57                	push   r15
  4168da:	41 56                	push   r14
  4168dc:	41 55                	push   r13
  4168de:	41 54                	push   r12
  4168e0:	53                   	push   rbx
  4168e1:	48 83 ec 18          	sub    rsp,0x18
	assert(t);
  4168e5:	48 85 f6             	test   rsi,rsi
  4168e8:	0f 84 f4 01 00 00    	je     416ae2 <slm_thd_wakeup_cs+0x212>
  4168ee:	48 bb d0 35 41 00 00 	movabs rbx,0x4135d0
  4168f5:	00 00 00 
  4168f8:	49 89 fc             	mov    r12,rdi
  4168fb:	49 89 f6             	mov    r14,rsi
	assert(current);
  4168fe:	49 bf c0 5e 5a 00 00 	movabs r15,0x5a5ec0
  416905:	00 00 00 
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  416908:	49 bd 70 e1 40 00 00 	movabs r13,0x40e170
  41690f:	00 00 00 
  416912:	48 85 ff             	test   rdi,rdi
  416915:	0f 84 49 02 00 00    	je     416b64 <slm_thd_wakeup_cs+0x294>
		tok    = cos_sched_sync();
  41691b:	ff d3                	call   rbx
  41691d:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  41691f:	49 8b 07             	mov    rax,QWORD PTR [r15]
		if (unlikely(owner)) {
  416922:	48 89 c2             	mov    rdx,rax
  416925:	48 83 e2 fe          	and    rdx,0xfffffffffffffffe
  416929:	0f 85 db 01 00 00    	jne    416b0a <slm_thd_wakeup_cs+0x23a>
  41692f:	f0 4d 0f b1 27       	lock cmpxchg QWORD PTR [r15],r12
  416934:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  416937:	84 c0                	test   al,al
  416939:	74 e0                	je     41691b <slm_thd_wakeup_cs+0x4b>
	if (slm_thd_wakeup(t, 0)) {
  41693b:	48 b8 c0 66 41 00 00 	movabs rax,0x4166c0
  416942:	00 00 00 
  416945:	31 f6                	xor    esi,esi
  416947:	4c 89 f7             	mov    rdi,r14
  41694a:	ff d0                	call   rax
  41694c:	85 c0                	test   eax,eax
  41694e:	0f 85 0c 01 00 00    	jne    416a60 <slm_thd_wakeup_cs+0x190>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  416954:	48 b8 10 ce 40 00 00 	movabs rax,0x40ce10
  41695b:	00 00 00 
  41695e:	ff d0                	call   rax
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  416960:	4c 89 65 c8          	mov    QWORD PTR [rbp-0x38],r12
	tok  = cos_sched_sync();
  416964:	ff d3                	call   rbx
  416966:	41 89 c5             	mov    r13d,eax
	t = slm_sched_schedule();
  416969:	48 b8 e0 1c 40 00 00 	movabs rax,0x401ce0
  416970:	00 00 00 
  416973:	ff d0                	call   rax
	if (unlikely(!t)) t = &g->idle_thd;
  416975:	48 85 c0             	test   rax,rax
	t = slm_sched_schedule();
  416978:	49 89 c4             	mov    r12,rax
	if (unlikely(!t)) t = &g->idle_thd;
  41697b:	48 b8 40 5f 5a 00 00 	movabs rax,0x5a5f40
  416982:	00 00 00 
  416985:	4c 0f 44 e0          	cmove  r12,rax
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  416989:	41 8b 44 24 04       	mov    eax,DWORD PTR [r12+0x4]
  41698e:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  416991:	83 f8 01             	cmp    eax,0x1
  416994:	0f 87 3e 02 00 00    	ja     416bd8 <slm_thd_wakeup_cs+0x308>
  41699a:	45 31 f6             	xor    r14d,r14d
  41699d:	eb 0d                	jmp    4169ac <slm_thd_wakeup_cs+0xdc>
  41699f:	90                   	nop
  4169a0:	f0 49 0f b1 37       	lock cmpxchg QWORD PTR [r15],rsi
  4169a5:	0f 94 c0             	sete   al
	while (ret != 0) {
  4169a8:	84 c0                	test   al,al
  4169aa:	75 4a                	jne    4169f6 <slm_thd_wakeup_cs+0x126>
		tok    = cos_sched_sync();
  4169ac:	ff d3                	call   rbx
	unsigned long oc = ps_load(&cs->owner_contention);
  4169ae:	49 8b 17             	mov    rdx,QWORD PTR [r15]
  4169b1:	89 c1                	mov    ecx,eax
		if (unlikely(contention)) {
  4169b3:	48 89 d6             	mov    rsi,rdx
  4169b6:	48 89 d0             	mov    rax,rdx
  4169b9:	83 e6 01             	and    esi,0x1
  4169bc:	74 e2                	je     4169a0 <slm_thd_wakeup_cs+0xd0>
  4169be:	f0 4d 0f b1 37       	lock cmpxchg QWORD PTR [r15],r14
  4169c3:	0f 94 c0             	sete   al
	if (__slm_cs_cas(cs, cached, NULL, 0)) return 1;
  4169c6:	84 c0                	test   al,al
  4169c8:	74 e2                	je     4169ac <slm_thd_wakeup_cs+0xdc>
	ret = cos_defswitch(s->thd, curr->priority, TCAP_TIME_NIL, tok);
  4169ca:	48 b8 d8 5e 5a 00 00 	movabs rax,0x5a5ed8
  4169d1:	00 00 00 
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  4169d4:	48 83 e2 fe          	and    rdx,0xfffffffffffffffe
  4169d8:	48 8b 38             	mov    rdi,QWORD PTR [rax]
  4169db:	48 b8 70 e1 40 00 00 	movabs rax,0x40e170
  4169e2:	00 00 00 
  4169e5:	48 8b 72 30          	mov    rsi,QWORD PTR [rdx+0x30]
  4169e9:	31 d2                	xor    edx,edx
  4169eb:	ff d0                	call   rax
	assert(ret != -EINVAL);
  4169ed:	83 f8 ea             	cmp    eax,0xffffffea
  4169f0:	0f 84 c4 00 00 00    	je     416aba <slm_thd_wakeup_cs+0x1ea>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  4169f6:	48 b8 10 ce 40 00 00 	movabs rax,0x40ce10
  4169fd:	00 00 00 
  416a00:	ff d0                	call   rax
	prio = inherit_prio ? curr->priority : t->priority;
  416a02:	49 8b 74 24 30       	mov    rsi,QWORD PTR [r12+0x30]
	timeout = g->timeout_next;
  416a07:	48 b8 c8 5f 5a 00 00 	movabs rax,0x5a5fc8
  416a0e:	00 00 00 
  416a11:	4c 8b 00             	mov    r8,QWORD PTR [rax]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  416a14:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  416a18:	a8 0b                	test   al,0xb
  416a1a:	0f 85 e0 01 00 00    	jne    416c00 <slm_thd_wakeup_cs+0x330>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  416a20:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  416a25:	44 89 e9             	mov    ecx,r13d
  416a28:	4c 89 c2             	mov    rdx,r8
  416a2b:	48 b8 70 e1 40 00 00 	movabs rax,0x40e170
  416a32:	00 00 00 
  416a35:	ff d0                	call   rax
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  416a37:	83 f8 ff             	cmp    eax,0xffffffff
  416a3a:	0f 84 4e 02 00 00    	je     416c8e <slm_thd_wakeup_cs+0x3be>
	if (unlikely(ret != 0)) {
  416a40:	85 c0                	test   eax,eax
  416a42:	0f 85 44 01 00 00    	jne    416b8c <slm_thd_wakeup_cs+0x2bc>
}
  416a48:	48 83 c4 18          	add    rsp,0x18
  416a4c:	5b                   	pop    rbx
  416a4d:	41 5c                	pop    r12
  416a4f:	41 5d                	pop    r13
  416a51:	41 5e                	pop    r14
  416a53:	41 5f                	pop    r15
  416a55:	5d                   	pop    rbp
  416a56:	c3                   	ret    
  416a57:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  416a5e:	00 00 
  416a60:	45 31 e4             	xor    r12d,r12d
  416a63:	eb 0f                	jmp    416a74 <slm_thd_wakeup_cs+0x1a4>
  416a65:	0f 1f 00             	nop    DWORD PTR [rax]
  416a68:	f0 49 0f b1 37       	lock cmpxchg QWORD PTR [r15],rsi
  416a6d:	0f 94 c0             	sete   al
	while (ret != 0) {
  416a70:	84 c0                	test   al,al
  416a72:	75 d4                	jne    416a48 <slm_thd_wakeup_cs+0x178>
		tok    = cos_sched_sync();
  416a74:	ff d3                	call   rbx
	unsigned long oc = ps_load(&cs->owner_contention);
  416a76:	49 8b 17             	mov    rdx,QWORD PTR [r15]
  416a79:	89 c1                	mov    ecx,eax
		if (unlikely(contention)) {
  416a7b:	48 89 d6             	mov    rsi,rdx
  416a7e:	48 89 d0             	mov    rax,rdx
  416a81:	83 e6 01             	and    esi,0x1
  416a84:	74 e2                	je     416a68 <slm_thd_wakeup_cs+0x198>
  416a86:	f0 4d 0f b1 27       	lock cmpxchg QWORD PTR [r15],r12
  416a8b:	0f 94 c0             	sete   al
	if (__slm_cs_cas(cs, cached, NULL, 0)) return 1;
  416a8e:	84 c0                	test   al,al
  416a90:	74 e2                	je     416a74 <slm_thd_wakeup_cs+0x1a4>
	ret = cos_defswitch(s->thd, curr->priority, TCAP_TIME_NIL, tok);
  416a92:	48 b8 d8 5e 5a 00 00 	movabs rax,0x5a5ed8
  416a99:	00 00 00 
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  416a9c:	48 83 e2 fe          	and    rdx,0xfffffffffffffffe
  416aa0:	48 8b 38             	mov    rdi,QWORD PTR [rax]
  416aa3:	48 b8 70 e1 40 00 00 	movabs rax,0x40e170
  416aaa:	00 00 00 
  416aad:	48 8b 72 30          	mov    rsi,QWORD PTR [rdx+0x30]
  416ab1:	31 d2                	xor    edx,edx
  416ab3:	ff d0                	call   rax
	assert(ret != -EINVAL);
  416ab5:	83 f8 ea             	cmp    eax,0xffffffea
  416ab8:	75 8e                	jne    416a48 <slm_thd_wakeup_cs+0x178>
  416aba:	48 bf c8 17 42 00 00 	movabs rdi,0x4217c8
  416ac1:	00 00 00 
  416ac4:	be 23 00 00 00       	mov    esi,0x23
  416ac9:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  416ad0:	00 00 00 
  416ad3:	ff d0                	call   rax
  416ad5:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  416adc:	00 00 00 00 
  416ae0:	0f 0b                	ud2    
  416ae2:	48 bf 90 1a 42 00 00 	movabs rdi,0x421a90
  416ae9:	00 00 00 
  416aec:	be 23 00 00 00       	mov    esi,0x23
  416af1:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  416af8:	00 00 00 
  416afb:	ff d0                	call   rax
	assert(t);
  416afd:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  416b04:	00 00 00 00 
  416b08:	0f 0b                	ud2    
	if (!contended) {
  416b0a:	a8 01                	test   al,0x1
  416b0c:	75 17                	jne    416b25 <slm_thd_wakeup_cs+0x255>
	return !ps_cas(&cs->owner_contention, (unsigned long)cached, ((unsigned long)thd | !!contention));
  416b0e:	48 89 d6             	mov    rsi,rdx
  416b11:	48 83 ce 01          	or     rsi,0x1
  416b15:	f0 49 0f b1 37       	lock cmpxchg QWORD PTR [r15],rsi
  416b1a:	0f 94 c0             	sete   al
		if (__slm_cs_cas(cs, cached, owner, 1)) return 1;
  416b1d:	84 c0                	test   al,al
  416b1f:	0f 84 f6 fd ff ff    	je     41691b <slm_thd_wakeup_cs+0x4b>
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  416b25:	48 8b 7a 10          	mov    rdi,QWORD PTR [rdx+0x10]
  416b29:	49 8b 74 24 30       	mov    rsi,QWORD PTR [r12+0x30]
  416b2e:	31 d2                	xor    edx,edx
  416b30:	41 ff d5             	call   r13
			assert(ret != -EBUSY);
  416b33:	83 f8 f0             	cmp    eax,0xfffffff0
  416b36:	0f 85 df fd ff ff    	jne    41691b <slm_thd_wakeup_cs+0x4b>
  416b3c:	48 bf b0 18 42 00 00 	movabs rdi,0x4218b0
  416b43:	00 00 00 
  416b46:	be 25 00 00 00       	mov    esi,0x25
  416b4b:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  416b52:	00 00 00 
  416b55:	ff d0                	call   rax
  416b57:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  416b5e:	00 00 00 00 
  416b62:	0f 0b                	ud2    
  416b64:	48 bf a0 19 42 00 00 	movabs rdi,0x4219a0
  416b6b:	00 00 00 
  416b6e:	be 25 00 00 00       	mov    esi,0x25
  416b73:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  416b7a:	00 00 00 
  416b7d:	ff d0                	call   rax
	assert(current);
  416b7f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  416b86:	00 00 00 00 
  416b8a:	0f 0b                	ud2    
		assert(ret != -EINVAL);
  416b8c:	83 f8 ea             	cmp    eax,0xffffffea
  416b8f:	0f 84 03 02 00 00    	je     416d98 <slm_thd_wakeup_cs+0x4c8>
		if (ret == -EBUSY) return ret;
  416b95:	83 f8 f0             	cmp    eax,0xfffffff0
  416b98:	0f 84 aa fe ff ff    	je     416a48 <slm_thd_wakeup_cs+0x178>
		assert(ret == -EAGAIN);
  416b9e:	83 f8 f5             	cmp    eax,0xfffffff5
  416ba1:	0f 85 c9 01 00 00    	jne    416d70 <slm_thd_wakeup_cs+0x4a0>
  416ba7:	4c 8b 65 c8          	mov    r12,QWORD PTR [rbp-0x38]
		tok    = cos_sched_sync();
  416bab:	ff d3                	call   rbx
  416bad:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  416baf:	49 8b 07             	mov    rax,QWORD PTR [r15]
		if (unlikely(owner)) {
  416bb2:	48 89 c6             	mov    rsi,rax
  416bb5:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  416bb9:	0f 85 4d 01 00 00    	jne    416d0c <slm_thd_wakeup_cs+0x43c>
  416bbf:	f0 4d 0f b1 27       	lock cmpxchg QWORD PTR [r15],r12
  416bc4:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  416bc7:	84 c0                	test   al,al
  416bc9:	0f 85 95 fd ff ff    	jne    416964 <slm_thd_wakeup_cs+0x94>
  416bcf:	eb da                	jmp    416bab <slm_thd_wakeup_cs+0x2db>
  416bd1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  416bd8:	48 bf f0 17 42 00 00 	movabs rdi,0x4217f0
  416bdf:	00 00 00 
  416be2:	be 2d 00 00 00       	mov    esi,0x2d
  416be7:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  416bee:	00 00 00 
  416bf1:	ff d0                	call   rax
	assert(slm_state_is_runnable(t->state));
  416bf3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  416bfa:	00 00 00 00 
  416bfe:	0f 0b                	ud2    
		if (t == &g->sched_thd) {
  416c00:	48 ba c8 5e 5a 00 00 	movabs rdx,0x5a5ec8
  416c07:	00 00 00 
	timeout = g->timeout_next;
  416c0a:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  416c0d:	49 39 d4             	cmp    r12,rdx
  416c10:	0f 84 be 00 00 00    	je     416cd4 <slm_thd_wakeup_cs+0x404>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  416c16:	a8 02                	test   al,0x2
  416c18:	0f 85 c5 00 00 00    	jne    416ce3 <slm_thd_wakeup_cs+0x413>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  416c1e:	49 89 c8             	mov    r8,rcx
  416c21:	a8 01                	test   al,0x1
  416c23:	0f 84 f7 fd ff ff    	je     416a20 <slm_thd_wakeup_cs+0x150>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  416c29:	4d 8b 54 24 08       	mov    r10,QWORD PTR [r12+0x8]
  416c2e:	48 89 f2             	mov    rdx,rsi
  416c31:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  416c36:	45 89 e9             	mov    r9d,r13d
  416c39:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  416c40:	00 00 00 
  416c43:	4c 8b 00             	mov    r8,QWORD PTR [rax]
  416c46:	48 b8 f0 35 41 00 00 	movabs rax,0x4135f0
  416c4d:	00 00 00 
  416c50:	4c 89 d6             	mov    rsi,r10
  416c53:	ff d0                	call   rax
	if (unlikely(ret != 0)) {
  416c55:	85 c0                	test   eax,eax
  416c57:	0f 84 eb fd ff ff    	je     416a48 <slm_thd_wakeup_cs+0x178>
		assert(ret != -EPERM);
  416c5d:	83 f8 ff             	cmp    eax,0xffffffff
  416c60:	0f 85 26 ff ff ff    	jne    416b8c <slm_thd_wakeup_cs+0x2bc>
  416c66:	48 bf 20 18 42 00 00 	movabs rdi,0x421820
  416c6d:	00 00 00 
  416c70:	be 2d 00 00 00       	mov    esi,0x2d
  416c75:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  416c7c:	00 00 00 
  416c7f:	ff d0                	call   rax
  416c81:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  416c88:	00 00 00 00 
  416c8c:	0f 0b                	ud2    
	return t != &g->idle_thd && t != &g->sched_thd;
  416c8e:	48 b8 40 5f 5a 00 00 	movabs rax,0x5a5f40
  416c95:	00 00 00 
  416c98:	49 39 c4             	cmp    r12,rax
  416c9b:	74 09                	je     416ca6 <slm_thd_wakeup_cs+0x3d6>
  416c9d:	48 83 e8 78          	sub    rax,0x78
  416ca1:	49 39 c4             	cmp    r12,rax
  416ca4:	75 c0                	jne    416c66 <slm_thd_wakeup_cs+0x396>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  416ca6:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  416caa:	45 89 e9             	mov    r9d,r13d
  416cad:	31 c9                	xor    ecx,ecx
  416caf:	31 f6                	xor    esi,esi
  416cb1:	48 8b 50 30          	mov    rdx,QWORD PTR [rax+0x30]
  416cb5:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  416cbc:	00 00 00 
  416cbf:	4c 8b 00             	mov    r8,QWORD PTR [rax]
  416cc2:	48 8b 78 f0          	mov    rdi,QWORD PTR [rax-0x10]
  416cc6:	48 b8 f0 35 41 00 00 	movabs rax,0x4135f0
  416ccd:	00 00 00 
  416cd0:	ff d0                	call   rax
  416cd2:	eb 81                	jmp    416c55 <slm_thd_wakeup_cs+0x385>
			prio    = curr->priority;
  416cd4:	48 8b 7d c8          	mov    rdi,QWORD PTR [rbp-0x38]
			timeout = TCAP_TIME_NIL;
  416cd8:	31 c9                	xor    ecx,ecx
			prio    = curr->priority;
  416cda:	48 8b 77 30          	mov    rsi,QWORD PTR [rdi+0x30]
  416cde:	e9 33 ff ff ff       	jmp    416c16 <slm_thd_wakeup_cs+0x346>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  416ce3:	48 b8 e8 5e 5a 00 00 	movabs rax,0x5a5ee8
  416cea:	00 00 00 
  416ced:	49 8b 7c 24 28       	mov    rdi,QWORD PTR [r12+0x28]
  416cf2:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  416cf5:	44 89 e9             	mov    ecx,r13d
  416cf8:	48 b8 60 36 41 00 00 	movabs rax,0x413660
  416cff:	00 00 00 
  416d02:	4c 89 c6             	mov    rsi,r8
  416d05:	ff d0                	call   rax
  416d07:	e9 49 ff ff ff       	jmp    416c55 <slm_thd_wakeup_cs+0x385>
	if (!contended) {
  416d0c:	a8 01                	test   al,0x1
  416d0e:	75 17                	jne    416d27 <slm_thd_wakeup_cs+0x457>
	return !ps_cas(&cs->owner_contention, (unsigned long)cached, ((unsigned long)thd | !!contention));
  416d10:	48 89 f2             	mov    rdx,rsi
  416d13:	48 83 ca 01          	or     rdx,0x1
  416d17:	f0 49 0f b1 17       	lock cmpxchg QWORD PTR [r15],rdx
  416d1c:	0f 94 c0             	sete   al
		if (__slm_cs_cas(cs, cached, owner, 1)) return 1;
  416d1f:	84 c0                	test   al,al
  416d21:	0f 84 84 fe ff ff    	je     416bab <slm_thd_wakeup_cs+0x2db>
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  416d27:	4d 8b 44 24 30       	mov    r8,QWORD PTR [r12+0x30]
  416d2c:	48 8b 7e 10          	mov    rdi,QWORD PTR [rsi+0x10]
  416d30:	31 d2                	xor    edx,edx
  416d32:	48 b8 70 e1 40 00 00 	movabs rax,0x40e170
  416d39:	00 00 00 
  416d3c:	4c 89 c6             	mov    rsi,r8
  416d3f:	ff d0                	call   rax
			assert(ret != -EBUSY);
  416d41:	83 f8 f0             	cmp    eax,0xfffffff0
  416d44:	0f 85 61 fe ff ff    	jne    416bab <slm_thd_wakeup_cs+0x2db>
  416d4a:	48 bf b0 18 42 00 00 	movabs rdi,0x4218b0
  416d51:	00 00 00 
  416d54:	48 b8 c0 53 41 00 00 	movabs rax,0x4153c0
  416d5b:	00 00 00 
  416d5e:	ff d0                	call   rax
  416d60:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  416d67:	00 00 00 00 
  416d6b:	0f 0b                	ud2    
  416d6d:	0f 1f 00             	nop    DWORD PTR [rax]
  416d70:	48 bf 80 18 42 00 00 	movabs rdi,0x421880
  416d77:	00 00 00 
  416d7a:	be 2d 00 00 00       	mov    esi,0x2d
  416d7f:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  416d86:	00 00 00 
  416d89:	ff d0                	call   rax
		assert(ret == -EAGAIN);
  416d8b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  416d92:	00 00 00 00 
  416d96:	0f 0b                	ud2    
  416d98:	48 bf 50 18 42 00 00 	movabs rdi,0x421850
  416d9f:	00 00 00 
  416da2:	be 2d 00 00 00       	mov    esi,0x2d
  416da7:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  416dae:	00 00 00 
  416db1:	ff d0                	call   rax
		assert(ret != -EINVAL);
  416db3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  416dba:	00 00 00 00 
  416dbe:	0f 0b                	ud2    

0000000000416dc0 <slm_thd_event_reset>:
{
  416dc0:	f3 0f 1e fa          	endbr64 
	memset(&t->event_info, 0, sizeof(struct event_info));
  416dc4:	66 0f ef c0          	pxor   xmm0,xmm0
  416dc8:	48 c7 47 50 00 00 00 	mov    QWORD PTR [rdi+0x50],0x0
  416dcf:	00 
  416dd0:	0f 11 47 40          	movups XMMWORD PTR [rdi+0x40],xmm0
}
  416dd4:	c3                   	ret    
  416dd5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  416ddc:	00 00 00 00 

0000000000416de0 <slm_get_cycs_per_usec>:
{
  416de0:	f3 0f 1e fa          	endbr64 
	return (unsigned long)g->cyc_per_usec;
  416de4:	a1 b8 5f 5a 00 00 00 	movabs eax,ds:0x5a5fb8
  416deb:	00 00 
  416ded:	48 98                	cdqe   
}
  416def:	c3                   	ret    

0000000000416df0 <slm_sched_loop>:
	}
}

void
slm_sched_loop(void)
{
  416df0:	f3 0f 1e fa          	endbr64 
	slm_sched_loop_intern(0);
  416df4:	48 b8 00 54 41 00 00 	movabs rax,0x415400
  416dfb:	00 00 00 
{
  416dfe:	55                   	push   rbp
	slm_sched_loop_intern(0);
  416dff:	31 ff                	xor    edi,edi
{
  416e01:	48 89 e5             	mov    rbp,rsp
	slm_sched_loop_intern(0);
  416e04:	ff d0                	call   rax
  416e06:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  416e0d:	00 00 00 

0000000000416e10 <slm_sched_loop_nonblock>:
}

void
slm_sched_loop_nonblock(void)
{
  416e10:	f3 0f 1e fa          	endbr64 
	slm_sched_loop_intern(1);
  416e14:	48 b8 00 54 41 00 00 	movabs rax,0x415400
  416e1b:	00 00 00 
{
  416e1e:	55                   	push   rbp
	slm_sched_loop_intern(1);
  416e1f:	bf 01 00 00 00       	mov    edi,0x1
{
  416e24:	48 89 e5             	mov    rbp,rsp
	slm_sched_loop_intern(1);
  416e27:	ff d0                	call   rax
  416e29:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000416e30 <slm_init>:
}

void
slm_init(thdcap_t thd, thdid_t tid)
{
  416e30:	f3 0f 1e fa          	endbr64 
	struct slm_thd *s    = &g->sched_thd;
	struct slm_thd *i    = &g->idle_thd;
	struct cos_defcompinfo *defci;
	struct cos_aep_info    *sched_aep;

	defci = cos_defcompinfo_curr_get();
  416e34:	48 b8 10 ce 40 00 00 	movabs rax,0x40ce10
  416e3b:	00 00 00 
{
  416e3e:	55                   	push   rbp
  416e3f:	48 89 e5             	mov    rbp,rsp
  416e42:	41 57                	push   r15
  416e44:	49 bf 98 5f 5a 00 00 	movabs r15,0x5a5f98
  416e4b:	00 00 00 
  416e4e:	41 56                	push   r14
  416e50:	4d 8d 77 10          	lea    r14,[r15+0x10]
  416e54:	41 55                	push   r13
  416e56:	49 89 f5             	mov    r13,rsi
  416e59:	41 54                	push   r12
  416e5b:	4d 8d a6 78 ff ff ff 	lea    r12,[r14-0x88]
  416e62:	53                   	push   rbx
  416e63:	49 8d 5e 88          	lea    rbx,[r14-0x78]
  416e67:	48 83 ec 18          	sub    rsp,0x18
  416e6b:	48 89 7d c8          	mov    QWORD PTR [rbp-0x38],rdi
	defci = cos_defcompinfo_curr_get();
  416e6f:	ff d0                	call   rax
  416e71:	48 89 c7             	mov    rdi,rax
	sched_aep = cos_sched_aep_get(defci);
  416e74:	48 b8 60 ce 40 00 00 	movabs rax,0x40ce60
  416e7b:	00 00 00 
  416e7e:	ff d0                	call   rax

	*s = (struct slm_thd) {
  416e80:	49 8d 96 18 ff ff ff 	lea    rdx,[r14-0xe8]
  416e87:	66 0f ef c0          	pxor   xmm0,xmm0
		.properties = SLM_THD_PROPERTY_SPECIAL,
		.state = SLM_THD_RUNNABLE,
		.tc  = sched_aep->tc,
  416e8b:	f3 0f 6f 10          	movdqu xmm2,XMMWORD PTR [rax]
  416e8f:	f3 0f 6f 48 10       	movdqu xmm1,XMMWORD PTR [rax+0x10]
  416e94:	48 8b 00             	mov    rax,QWORD PTR [rax]
	*s = (struct slm_thd) {
  416e97:	0f 29 42 30          	movaps XMMWORD PTR [rdx+0x30],xmm0
  416e9b:	0f 29 52 10          	movaps XMMWORD PTR [rdx+0x10],xmm2
  416e9f:	66 49 0f 6e d4       	movq   xmm2,r12
  416ea4:	66 48 0f 6e d8       	movq   xmm3,rax
  416ea9:	66 0f 6c d2          	punpcklqdq xmm2,xmm2
  416ead:	0f 29 42 40          	movaps XMMWORD PTR [rdx+0x40],xmm0
  416eb1:	48 b8 e0 1a 42 00 00 	movabs rax,0x421ae0
  416eb8:	00 00 00 
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  416ebb:	48 89 e1             	mov    rcx,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  416ebe:	48 81 e1 00 e0 ff ff 	and    rcx,0xffffffffffffe000
  416ec5:	48 8b 30             	mov    rsi,QWORD PTR [rax]
  416ec8:	0f 29 42 50          	movaps XMMWORD PTR [rdx+0x50],xmm0
		.cpuid = cos_cpuid(),
		.priority = TCAP_PRIO_MAX
	};
	ps_list_init(s, thd_list);
	ps_list_init(s, graveyard_list);
	assert(s->tid == cos_thdid());
  416ecc:	66 48 0f 7e c8       	movq   rax,xmm1
	*s = (struct slm_thd) {
  416ed1:	0f 29 4a 20          	movaps XMMWORD PTR [rdx+0x20],xmm1
	return cos_get_thd_id();
  416ed5:	0f b7 89 f0 1f 00 00 	movzx  ecx,WORD PTR [rcx+0x1ff0]
  416edc:	0f 16 5d c8          	movhps xmm3,QWORD PTR [rbp-0x38]
  416ee0:	0f 29 52 60          	movaps XMMWORD PTR [rdx+0x60],xmm2
  416ee4:	66 48 0f 6e d3       	movq   xmm2,rbx
  416ee9:	66 0f 6c d2          	punpcklqdq xmm2,xmm2
  416eed:	48 89 72 08          	mov    QWORD PTR [rdx+0x8],rsi
  416ef1:	48 c7 42 38 01 00 00 	mov    QWORD PTR [rdx+0x38],0x1
  416ef8:	00 
  416ef9:	0f 29 52 70          	movaps XMMWORD PTR [rdx+0x70],xmm2
	assert(s->tid == cos_thdid());
  416efd:	48 39 c8             	cmp    rax,rcx
  416f00:	0f 85 f8 00 00 00    	jne    416ffe <slm_init+0x1ce>

	*i = (struct slm_thd) {
  416f06:	0f 29 82 a0 00 00 00 	movaps XMMWORD PTR [rdx+0xa0],xmm0
	ps_list_init(i, graveyard_list);

	ps_list_head_init(&g->event_head);
	ps_list_head_init(&g->graveyard_head);

	g->cyc_per_usec = cos_hw_cycles_per_usec(BOOT_CAPTBL_SELF_INITHW_BASE);
  416f0d:	bf 24 00 00 00       	mov    edi,0x24
	*i = (struct slm_thd) {
  416f12:	48 b8 90 5f 5a 00 00 	movabs rax,0x5a5f90
  416f19:	00 00 00 
  416f1c:	0f 29 82 b0 00 00 00 	movaps XMMWORD PTR [rdx+0xb0],xmm0
  416f23:	0f 29 82 c0 00 00 00 	movaps XMMWORD PTR [rdx+0xc0],xmm0
  416f2a:	66 49 0f 6e c7       	movq   xmm0,r15
  416f2f:	48 c7 00 00 00 00 00 	mov    QWORD PTR [rax],0x0
  416f36:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  416f3a:	4c 89 e8             	mov    rax,r13
  416f3d:	0f 11 82 d8 00 00 00 	movups XMMWORD PTR [rdx+0xd8],xmm0
  416f44:	66 49 0f 6e c6       	movq   xmm0,r14
  416f49:	48 a3 58 5f 5a 00 00 	movabs ds:0x5a5f58,rax
  416f50:	00 00 00 
  416f53:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  416f57:	48 b8 ff ff ff ff ff 	movabs rax,0xffffffffffff
  416f5e:	ff 00 00 
  416f61:	48 a3 70 5f 5a 00 00 	movabs ds:0x5a5f70,rax
  416f68:	00 00 00 
  416f6b:	48 b8 e8 1a 42 00 00 	movabs rax,0x421ae8
  416f72:	00 00 00 
  416f75:	0f 11 82 e8 00 00 00 	movups XMMWORD PTR [rdx+0xe8],xmm0
  416f7c:	f3 0f 7e 00          	movq   xmm0,QWORD PTR [rax]
  416f80:	48 b8 f0 1a 42 00 00 	movabs rax,0x421af0
  416f87:	00 00 00 
  416f8a:	48 89 b2 80 00 00 00 	mov    QWORD PTR [rdx+0x80],rsi
  416f91:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  416f95:	0f 11 9a 88 00 00 00 	movups XMMWORD PTR [rdx+0x88],xmm3
  416f9c:	0f 29 82 10 01 00 00 	movaps XMMWORD PTR [rdx+0x110],xmm0
  416fa3:	f3 0f 7e 00          	movq   xmm0,QWORD PTR [rax]
	g->cyc_per_usec = cos_hw_cycles_per_usec(BOOT_CAPTBL_SELF_INITHW_BASE);
  416fa7:	48 b8 e0 42 41 00 00 	movabs rax,0x4142e0
  416fae:	00 00 00 
  416fb1:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  416fb5:	0f 29 82 20 01 00 00 	movaps XMMWORD PTR [rdx+0x120],xmm0
  416fbc:	ff d0                	call   rax
  416fbe:	a3 b8 5f 5a 00 00 00 	movabs ds:0x5a5fb8,eax
  416fc5:	00 00 
	g->lock.owner_contention = 0;
  416fc7:	48 b8 c0 5e 5a 00 00 	movabs rax,0x5a5ec0
  416fce:	00 00 00 
  416fd1:	48 c7 00 00 00 00 00 	mov    QWORD PTR [rax],0x0

	slm_sched_init();
  416fd8:	48 b8 70 1c 40 00 00 	movabs rax,0x401c70
  416fdf:	00 00 00 
  416fe2:	ff d0                	call   rax
	slm_timer_init();
}
  416fe4:	48 83 c4 18          	add    rsp,0x18
	slm_timer_init();
  416fe8:	48 b8 60 1c 40 00 00 	movabs rax,0x401c60
  416fef:	00 00 00 
}
  416ff2:	5b                   	pop    rbx
  416ff3:	41 5c                	pop    r12
  416ff5:	41 5d                	pop    r13
  416ff7:	41 5e                	pop    r14
  416ff9:	41 5f                	pop    r15
  416ffb:	5d                   	pop    rbp
	slm_timer_init();
  416ffc:	ff e0                	jmp    rax
  416ffe:	48 bf b8 1a 42 00 00 	movabs rdi,0x421ab8
  417005:	00 00 00 
  417008:	be 23 00 00 00       	mov    esi,0x23
  41700d:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  417014:	00 00 00 
  417017:	ff d0                	call   rax
	assert(s->tid == cos_thdid());
  417019:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  417020:	00 00 00 00 
  417024:	0f 0b                	ud2    
  417026:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41702d:	00 00 00 

0000000000417030 <heap_init>:
#endif

/* public functions */
void
heap_init(struct heap *h, int max_sz, cmp_fn_t c, update_fn_t u)
{
  417030:	f3 0f 1e fa          	endbr64 
  417034:	66 48 0f 6e c2       	movq   xmm0,rdx
  417039:	66 48 0f 6e c9       	movq   xmm1,rcx
  41703e:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
	assert(h);
  417042:	48 85 ff             	test   rdi,rdi
  417045:	74 19                	je     417060 <heap_init+0x30>

	h->max_sz = max_sz + 1;
  417047:	83 c6 01             	add    esi,0x1
	h->e      = 1;
	h->c      = c;
	h->u      = u;
	h->data   = (void *)&h[1];
  41704a:	48 8d 47 20          	lea    rax,[rdi+0x20]
	h->e      = 1;
  41704e:	c7 07 01 00 00 00    	mov    DWORD PTR [rdi],0x1
	h->max_sz = max_sz + 1;
  417054:	89 77 04             	mov    DWORD PTR [rdi+0x4],esi
	h->data   = (void *)&h[1];
  417057:	48 89 47 18          	mov    QWORD PTR [rdi+0x18],rax
	h->c      = c;
  41705b:	0f 11 47 08          	movups XMMWORD PTR [rdi+0x8],xmm0
	h->data   = (void *)&h[1];
  41705f:	c3                   	ret    
  417060:	48 bf f8 1a 42 00 00 	movabs rdi,0x421af8
  417067:	00 00 00 
{
  41706a:	55                   	push   rbp
  41706b:	be 24 00 00 00       	mov    esi,0x24
  417070:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  417077:	00 00 00 
  41707a:	48 89 e5             	mov    rbp,rsp
  41707d:	ff d0                	call   rax
	assert(h);
  41707f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  417086:	00 00 00 00 
  41708a:	0f 0b                	ud2    
  41708c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000417090 <heap_alloc>:
	assert(!heap_verify(h));
}

struct heap *
heap_alloc(int max_sz, cmp_fn_t c, update_fn_t u)
{
  417090:	f3 0f 1e fa          	endbr64 

	heap_init(h, max_sz, c, u);
#endif

	return h;
}
  417094:	31 c0                	xor    eax,eax
  417096:	c3                   	ret    
  417097:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41709e:	00 00 

00000000004170a0 <heap_destroy>:

void
heap_destroy(struct heap *h)
{
  4170a0:	f3 0f 1e fa          	endbr64 
	assert(h && h->data);
  4170a4:	48 85 ff             	test   rdi,rdi
  4170a7:	74 08                	je     4170b1 <heap_destroy+0x11>
  4170a9:	48 83 7f 18 00       	cmp    QWORD PTR [rdi+0x18],0x0
  4170ae:	74 01                	je     4170b1 <heap_destroy+0x11>
  4170b0:	c3                   	ret    
  4170b1:	48 bf 20 1b 42 00 00 	movabs rdi,0x421b20
  4170b8:	00 00 00 
{
  4170bb:	55                   	push   rbp
  4170bc:	be 24 00 00 00       	mov    esi,0x24
  4170c1:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4170c8:	00 00 00 
  4170cb:	48 89 e5             	mov    rbp,rsp
  4170ce:	ff d0                	call   rax
	assert(h && h->data);
  4170d0:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4170d7:	00 00 00 00 
  4170db:	0f 0b                	ud2    
  4170dd:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004170e0 <heap_add>:
#endif
}

int
heap_add(struct heap *h, void *new)
{
  4170e0:	f3 0f 1e fa          	endbr64 
  4170e4:	55                   	push   rbp
  4170e5:	48 89 e5             	mov    rbp,rsp
  4170e8:	41 57                	push   r15
  4170ea:	41 56                	push   r14
  4170ec:	41 55                	push   r13
  4170ee:	41 54                	push   r12
  4170f0:	53                   	push   rbx
  4170f1:	48 89 fb             	mov    rbx,rdi
  4170f4:	48 83 ec 18          	sub    rsp,0x18
	int c;

	if (h->max_sz == h->e) return -1;
  4170f8:	44 8b 37             	mov    r14d,DWORD PTR [rdi]
  4170fb:	44 39 77 04          	cmp    DWORD PTR [rdi+0x4],r14d
  4170ff:	0f 84 31 02 00 00    	je     417336 <heap_add+0x256>

	debug("heap_add(%p,%d) %p\n", h, h->e, new);

	assert(!heap_verify(h));
	c          = h->e;
	h->data[c] = new;
  417105:	48 8b 53 18          	mov    rdx,QWORD PTR [rbx+0x18]
  417109:	49 63 c6             	movsxd rax,r14d
  41710c:	48 89 f7             	mov    rdi,rsi
  41710f:	48 89 34 c2          	mov    QWORD PTR [rdx+rax*8],rsi
	h->u(new, c);
  417113:	44 89 f6             	mov    esi,r14d
  417116:	ff 53 10             	call   QWORD PTR [rbx+0x10]
	h->e++;
  417119:	8b 03                	mov    eax,DWORD PTR [rbx]
  41711b:	83 c0 01             	add    eax,0x1
  41711e:	89 03                	mov    DWORD PTR [rbx],eax
	assert(c <= h->e);
  417120:	41 39 c6             	cmp    r14d,eax
  417123:	0f 8f 95 01 00 00    	jg     4172be <heap_add+0x1de>
	assert(c > 0);
  417129:	45 85 f6             	test   r14d,r14d
  41712c:	0f 8e b4 01 00 00    	jle    4172e6 <heap_add+0x206>
	while (c > 1) {
  417132:	41 83 fe 01          	cmp    r14d,0x1
  417136:	75 43                	jne    41717b <heap_add+0x9b>
  417138:	e9 65 01 00 00       	jmp    4172a2 <heap_add+0x1c2>
  41713d:	0f 1f 00             	nop    DWORD PTR [rax]
	arr[a] = arr[b];
  417140:	4c 03 63 18          	add    r12,QWORD PTR [rbx+0x18]
	t      = arr[a];
  417144:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
	u(arr[a], a);
  417148:	44 89 f6             	mov    esi,r14d
	t      = arr[a];
  41714b:	48 03 43 18          	add    rax,QWORD PTR [rbx+0x18]
	arr[a] = arr[b];
  41714f:	49 8b 0c 24          	mov    rcx,QWORD PTR [r12]
	t      = arr[a];
  417153:	48 8b 10             	mov    rdx,QWORD PTR [rax]
		swap_entries(h->data, p, c, h->u);
  417156:	4c 8b 7b 10          	mov    r15,QWORD PTR [rbx+0x10]
	arr[a] = arr[b];
  41715a:	48 89 08             	mov    QWORD PTR [rax],rcx
	arr[b] = t;
  41715d:	49 89 14 24          	mov    QWORD PTR [r12],rdx
	u(arr[a], a);
  417161:	48 8b 38             	mov    rdi,QWORD PTR [rax]
  417164:	41 ff d7             	call   r15
	u(arr[b], b);
  417167:	49 8b 3c 24          	mov    rdi,QWORD PTR [r12]
  41716b:	44 89 ee             	mov    esi,r13d
  41716e:	41 ff d7             	call   r15
	while (c > 1) {
  417171:	41 83 fe 01          	cmp    r14d,0x1
  417175:	0f 84 25 01 00 00    	je     4172a0 <heap_add+0x1c0>
		p = c / 2;
  41717b:	49 63 ce             	movsxd rcx,r14d
		if (h->c(h->data[p], h->data[c])) break; /* done? */
  41717e:	48 8b 43 18          	mov    rax,QWORD PTR [rbx+0x18]
		p = c / 2;
  417182:	41 89 ce             	mov    r14d,ecx
  417185:	49 89 cd             	mov    r13,rcx
		if (h->c(h->data[p], h->data[c])) break; /* done? */
  417188:	4c 8d 24 cd 00 00 00 	lea    r12,[rcx*8+0x0]
  41718f:	00 
		p = c / 2;
  417190:	41 d1 fe             	sar    r14d,1
		if (h->c(h->data[p], h->data[c])) break; /* done? */
  417193:	48 8b 34 c8          	mov    rsi,QWORD PTR [rax+rcx*8]
  417197:	49 63 d6             	movsxd rdx,r14d
  41719a:	48 8d 3c d5 00 00 00 	lea    rdi,[rdx*8+0x0]
  4171a1:	00 
  4171a2:	48 89 7d c8          	mov    QWORD PTR [rbp-0x38],rdi
  4171a6:	48 8b 3c d0          	mov    rdi,QWORD PTR [rax+rdx*8]
  4171aa:	ff 53 08             	call   QWORD PTR [rbx+0x8]
  4171ad:	85 c0                	test   eax,eax
  4171af:	74 8f                	je     417140 <heap_add+0x60>
	assert(c <= h->e);
  4171b1:	8b 03                	mov    eax,DWORD PTR [rbx]
  4171b3:	41 39 c5             	cmp    r13d,eax
  4171b6:	0f 8f 52 01 00 00    	jg     41730e <heap_add+0x22e>
	l = h->e - 1;
  4171bc:	83 e8 01             	sub    eax,0x1
  4171bf:	89 45 c4             	mov    DWORD PTR [rbp-0x3c],eax
	while (c <= l / 2) { /* not a leaf? */
  4171c2:	d1 f8                	sar    eax,1
  4171c4:	89 45 c0             	mov    DWORD PTR [rbp-0x40],eax
  4171c7:	41 39 c5             	cmp    r13d,eax
  4171ca:	7e 75                	jle    417241 <heap_add+0x161>
  4171cc:	e9 dc 00 00 00       	jmp    4172ad <heap_add+0x1cd>
  4171d1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		if (h->c(h->data[c], h->data[n])) break; /* done? */
  4171d8:	48 8b 43 18          	mov    rax,QWORD PTR [rbx+0x18]
  4171dc:	49 63 f7             	movsxd rsi,r15d
  4171df:	49 63 cd             	movsxd rcx,r13d
  4171e2:	4c 8d 24 f5 00 00 00 	lea    r12,[rsi*8+0x0]
  4171e9:	00 
  4171ea:	4c 8d 34 cd 00 00 00 	lea    r14,[rcx*8+0x0]
  4171f1:	00 
  4171f2:	48 8b 34 f0          	mov    rsi,QWORD PTR [rax+rsi*8]
  4171f6:	48 8b 3c c8          	mov    rdi,QWORD PTR [rax+rcx*8]
  4171fa:	ff 53 08             	call   QWORD PTR [rbx+0x8]
  4171fd:	85 c0                	test   eax,eax
  4171ff:	0f 85 a8 00 00 00    	jne    4172ad <heap_add+0x1cd>
	t      = arr[a];
  417205:	4c 03 63 18          	add    r12,QWORD PTR [rbx+0x18]
	arr[a] = arr[b];
  417209:	4c 03 73 18          	add    r14,QWORD PTR [rbx+0x18]
		swap_entries(h->data, n, c, h->u);
  41720d:	48 8b 43 10          	mov    rax,QWORD PTR [rbx+0x10]
	arr[a] = arr[b];
  417211:	49 8b 36             	mov    rsi,QWORD PTR [r14]
	t      = arr[a];
  417214:	49 8b 0c 24          	mov    rcx,QWORD PTR [r12]
	u(arr[a], a);
  417218:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
	arr[a] = arr[b];
  41721c:	49 89 34 24          	mov    QWORD PTR [r12],rsi
	u(arr[a], a);
  417220:	44 89 fe             	mov    esi,r15d
	arr[b] = t;
  417223:	49 89 0e             	mov    QWORD PTR [r14],rcx
	u(arr[a], a);
  417226:	49 8b 3c 24          	mov    rdi,QWORD PTR [r12]
  41722a:	ff d0                	call   rax
	u(arr[b], b);
  41722c:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  41722f:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  417233:	44 89 ee             	mov    esi,r13d
  417236:	ff d0                	call   rax
	while (c <= l / 2) { /* not a leaf? */
  417238:	44 3b 7d c0          	cmp    r15d,DWORD PTR [rbp-0x40]
  41723c:	7f 6f                	jg     4172ad <heap_add+0x1cd>
  41723e:	45 89 fd             	mov    r13d,r15d
		left  = 2 * c;
  417241:	47 8d 7c 2d 00       	lea    r15d,[r13+r13*1+0x0]
		right = 2 * c + 1;
  417246:	45 8d 67 01          	lea    r12d,[r15+0x1]
		if (right > l) {
  41724a:	44 39 65 c4          	cmp    DWORD PTR [rbp-0x3c],r12d
  41724e:	7c 1b                	jl     41726b <heap_add+0x18b>
		} else if (h->c(h->data[left], h->data[right])) {
  417250:	48 8b 43 18          	mov    rax,QWORD PTR [rbx+0x18]
  417254:	49 63 cc             	movsxd rcx,r12d
  417257:	48 8b 34 c8          	mov    rsi,QWORD PTR [rax+rcx*8]
  41725b:	49 63 cf             	movsxd rcx,r15d
  41725e:	48 8b 3c c8          	mov    rdi,QWORD PTR [rax+rcx*8]
  417262:	ff 53 08             	call   QWORD PTR [rbx+0x8]
  417265:	85 c0                	test   eax,eax
  417267:	45 0f 44 fc          	cmove  r15d,r12d
		assert(n < h->e);
  41726b:	44 39 3b             	cmp    DWORD PTR [rbx],r15d
  41726e:	0f 8f 64 ff ff ff    	jg     4171d8 <heap_add+0xf8>
  417274:	48 bf c0 1b 42 00 00 	movabs rdi,0x421bc0
  41727b:	00 00 00 
  41727e:	be 23 00 00 00       	mov    esi,0x23
  417283:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  41728a:	00 00 00 
  41728d:	ff d0                	call   rax
  41728f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  417296:	00 00 00 00 
  41729a:	0f 0b                	ud2    
  41729c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	assert(c <= h->e);
  4172a0:	8b 03                	mov    eax,DWORD PTR [rbx]
  4172a2:	41 bd 01 00 00 00    	mov    r13d,0x1
  4172a8:	e9 06 ff ff ff       	jmp    4171b3 <heap_add+0xd3>
	heapify(h, c);
	assert(!heap_verify(h));

	return 0;
  4172ad:	31 c0                	xor    eax,eax
}
  4172af:	48 83 c4 18          	add    rsp,0x18
  4172b3:	5b                   	pop    rbx
  4172b4:	41 5c                	pop    r12
  4172b6:	41 5d                	pop    r13
  4172b8:	41 5e                	pop    r14
  4172ba:	41 5f                	pop    r15
  4172bc:	5d                   	pop    rbp
  4172bd:	c3                   	ret    
  4172be:	48 bf 48 1b 42 00 00 	movabs rdi,0x421b48
  4172c5:	00 00 00 
  4172c8:	be 23 00 00 00       	mov    esi,0x23
  4172cd:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4172d4:	00 00 00 
  4172d7:	ff d0                	call   rax
	assert(c <= h->e);
  4172d9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4172e0:	00 00 00 00 
  4172e4:	0f 0b                	ud2    
  4172e6:	48 bf 70 1b 42 00 00 	movabs rdi,0x421b70
  4172ed:	00 00 00 
  4172f0:	be 23 00 00 00       	mov    esi,0x23
  4172f5:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4172fc:	00 00 00 
  4172ff:	ff d0                	call   rax
	assert(c > 0);
  417301:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  417308:	00 00 00 00 
  41730c:	0f 0b                	ud2    
  41730e:	48 bf 98 1b 42 00 00 	movabs rdi,0x421b98
  417315:	00 00 00 
  417318:	be 23 00 00 00       	mov    esi,0x23
  41731d:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  417324:	00 00 00 
  417327:	ff d0                	call   rax
	assert(c <= h->e);
  417329:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  417330:	00 00 00 00 
  417334:	0f 0b                	ud2    
	if (h->max_sz == h->e) return -1;
  417336:	b8 ff ff ff ff       	mov    eax,0xffffffff
  41733b:	e9 6f ff ff ff       	jmp    4172af <heap_add+0x1cf>

0000000000417340 <heap_highest>:

void *
heap_highest(struct heap *h)
{
  417340:	f3 0f 1e fa          	endbr64 
  417344:	55                   	push   rbp
  417345:	48 89 e5             	mov    rbp,rsp
  417348:	41 57                	push   r15
  41734a:	41 56                	push   r14
  41734c:	41 55                	push   r13
  41734e:	41 54                	push   r12
  417350:	53                   	push   rbx
  417351:	48 83 ec 28          	sub    rsp,0x28
	void *r;

	if (h->e == 1) return NULL;
  417355:	8b 07                	mov    eax,DWORD PTR [rdi]
  417357:	83 f8 01             	cmp    eax,0x1
  41735a:	0f 84 39 01 00 00    	je     417499 <heap_highest+0x159>

	assert(!heap_verify(h));
	r = h->data[1];
  417360:	48 8b 57 18          	mov    rdx,QWORD PTR [rdi+0x18]
	debug("heap_highest(%p,%d) %p\n", h, h->e, r);

	h->e--;
  417364:	83 e8 01             	sub    eax,0x1
  417367:	49 89 ff             	mov    r15,rdi
	h->data[1] = h->data[h->e];
	h->u(h->data[1], 1);
  41736a:	be 01 00 00 00       	mov    esi,0x1
	r = h->data[1];
  41736f:	48 8b 4a 08          	mov    rcx,QWORD PTR [rdx+0x8]
	h->e--;
  417373:	89 07                	mov    DWORD PTR [rdi],eax
	h->data[1] = h->data[h->e];
  417375:	48 98                	cdqe   
  417377:	48 8b 04 c2          	mov    rax,QWORD PTR [rdx+rax*8]
	r = h->data[1];
  41737b:	48 89 4d b8          	mov    QWORD PTR [rbp-0x48],rcx
	h->data[1] = h->data[h->e];
  41737f:	48 89 42 08          	mov    QWORD PTR [rdx+0x8],rax
	h->u(h->data[1], 1);
  417383:	48 8b 47 18          	mov    rax,QWORD PTR [rdi+0x18]
  417387:	48 8b 78 08          	mov    rdi,QWORD PTR [rax+0x8]
  41738b:	41 ff 57 10          	call   QWORD PTR [r15+0x10]
	assert(c <= h->e);
  41738f:	45 8b 2f             	mov    r13d,DWORD PTR [r15]
  417392:	45 85 ed             	test   r13d,r13d
  417395:	0f 8e 08 01 00 00    	jle    4174a3 <heap_highest+0x163>
	l = h->e - 1;
  41739b:	41 8d 45 ff          	lea    eax,[r13-0x1]
  41739f:	89 45 c4             	mov    DWORD PTR [rbp-0x3c],eax
	while (c <= l / 2) { /* not a leaf? */
  4173a2:	d1 f8                	sar    eax,1
  4173a4:	89 45 c0             	mov    DWORD PTR [rbp-0x40],eax
  4173a7:	0f 84 cf 00 00 00    	je     41747c <heap_highest+0x13c>
  4173ad:	41 bc 01 00 00 00    	mov    r12d,0x1
  4173b3:	eb 6d                	jmp    417422 <heap_highest+0xe2>
  4173b5:	0f 1f 00             	nop    DWORD PTR [rax]
		if (h->c(h->data[c], h->data[n])) break; /* done? */
  4173b8:	49 8b 47 18          	mov    rax,QWORD PTR [r15+0x18]
  4173bc:	49 63 fd             	movsxd rdi,r13d
  4173bf:	49 63 f4             	movsxd rsi,r12d
  4173c2:	48 8d 1c fd 00 00 00 	lea    rbx,[rdi*8+0x0]
  4173c9:	00 
  4173ca:	4c 8d 34 f5 00 00 00 	lea    r14,[rsi*8+0x0]
  4173d1:	00 
  4173d2:	4c 8b 04 f8          	mov    r8,QWORD PTR [rax+rdi*8]
  4173d6:	48 8b 3c f0          	mov    rdi,QWORD PTR [rax+rsi*8]
  4173da:	4c 89 c6             	mov    rsi,r8
  4173dd:	41 ff 57 08          	call   QWORD PTR [r15+0x8]
  4173e1:	85 c0                	test   eax,eax
  4173e3:	0f 85 93 00 00 00    	jne    41747c <heap_highest+0x13c>
	t      = arr[a];
  4173e9:	49 03 5f 18          	add    rbx,QWORD PTR [r15+0x18]
	arr[a] = arr[b];
  4173ed:	4d 03 77 18          	add    r14,QWORD PTR [r15+0x18]
		swap_entries(h->data, n, c, h->u);
  4173f1:	49 8b 47 10          	mov    rax,QWORD PTR [r15+0x10]
	t      = arr[a];
  4173f5:	48 8b 33             	mov    rsi,QWORD PTR [rbx]
	arr[a] = arr[b];
  4173f8:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
	u(arr[a], a);
  4173fb:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
	arr[a] = arr[b];
  4173ff:	48 89 3b             	mov    QWORD PTR [rbx],rdi
	arr[b] = t;
  417402:	49 89 36             	mov    QWORD PTR [r14],rsi
	u(arr[a], a);
  417405:	44 89 ee             	mov    esi,r13d
  417408:	48 8b 3b             	mov    rdi,QWORD PTR [rbx]
  41740b:	ff d0                	call   rax
	u(arr[b], b);
  41740d:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  417410:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  417414:	44 89 e6             	mov    esi,r12d
  417417:	ff d0                	call   rax
	while (c <= l / 2) { /* not a leaf? */
  417419:	44 3b 6d c0          	cmp    r13d,DWORD PTR [rbp-0x40]
  41741d:	7f 5d                	jg     41747c <heap_highest+0x13c>
  41741f:	45 89 ec             	mov    r12d,r13d
		left  = 2 * c;
  417422:	47 8d 2c 24          	lea    r13d,[r12+r12*1]
		right = 2 * c + 1;
  417426:	41 8d 5d 01          	lea    ebx,[r13+0x1]
		if (right > l) {
  41742a:	39 5d c4             	cmp    DWORD PTR [rbp-0x3c],ebx
  41742d:	7c 1c                	jl     41744b <heap_highest+0x10b>
		} else if (h->c(h->data[left], h->data[right])) {
  41742f:	49 8b 47 18          	mov    rax,QWORD PTR [r15+0x18]
  417433:	49 63 fd             	movsxd rdi,r13d
  417436:	48 63 f3             	movsxd rsi,ebx
  417439:	48 8b 34 f0          	mov    rsi,QWORD PTR [rax+rsi*8]
  41743d:	48 8b 3c f8          	mov    rdi,QWORD PTR [rax+rdi*8]
  417441:	41 ff 57 08          	call   QWORD PTR [r15+0x8]
  417445:	85 c0                	test   eax,eax
  417447:	44 0f 44 eb          	cmove  r13d,ebx
		assert(n < h->e);
  41744b:	45 39 2f             	cmp    DWORD PTR [r15],r13d
  41744e:	0f 8f 64 ff ff ff    	jg     4173b8 <heap_highest+0x78>
  417454:	48 bf c0 1b 42 00 00 	movabs rdi,0x421bc0
  41745b:	00 00 00 
  41745e:	be 23 00 00 00       	mov    esi,0x23
  417463:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  41746a:	00 00 00 
  41746d:	ff d0                	call   rax
  41746f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  417476:	00 00 00 00 
  41747a:	0f 0b                	ud2    
	swap_down(h, 1);
	assert(!heap_verify(h));
	h->u(r, 0);
  41747c:	48 8b 7d b8          	mov    rdi,QWORD PTR [rbp-0x48]
  417480:	31 f6                	xor    esi,esi
  417482:	41 ff 57 10          	call   QWORD PTR [r15+0x10]

	return r;
}
  417486:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  41748a:	48 83 c4 28          	add    rsp,0x28
  41748e:	5b                   	pop    rbx
  41748f:	41 5c                	pop    r12
  417491:	41 5d                	pop    r13
  417493:	41 5e                	pop    r14
  417495:	41 5f                	pop    r15
  417497:	5d                   	pop    rbp
  417498:	c3                   	ret    
	if (h->e == 1) return NULL;
  417499:	48 c7 45 b8 00 00 00 	mov    QWORD PTR [rbp-0x48],0x0
  4174a0:	00 
  4174a1:	eb e3                	jmp    417486 <heap_highest+0x146>
  4174a3:	48 bf 98 1b 42 00 00 	movabs rdi,0x421b98
  4174aa:	00 00 00 
  4174ad:	be 23 00 00 00       	mov    esi,0x23
  4174b2:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4174b9:	00 00 00 
  4174bc:	ff d0                	call   rax
	assert(c <= h->e);
  4174be:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4174c5:	00 00 00 00 
  4174c9:	0f 0b                	ud2    
  4174cb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000004174d0 <heap_peek>:

void *
heap_peek(struct heap *h)
{
  4174d0:	f3 0f 1e fa          	endbr64 
	if (h->e == 1) return NULL;
  4174d4:	83 3f 01             	cmp    DWORD PTR [rdi],0x1
  4174d7:	74 0f                	je     4174e8 <heap_peek+0x18>
	assert(!heap_verify(h));
	return h->data[1];
  4174d9:	48 8b 47 18          	mov    rax,QWORD PTR [rdi+0x18]
  4174dd:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  4174e1:	c3                   	ret    
  4174e2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	if (h->e == 1) return NULL;
  4174e8:	31 c0                	xor    eax,eax
}
  4174ea:	c3                   	ret    
  4174eb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000004174f0 <heap_adjust>:

void
heap_adjust(struct heap *h, int c)
{
  4174f0:	f3 0f 1e fa          	endbr64 
  4174f4:	55                   	push   rbp
  4174f5:	48 89 e5             	mov    rbp,rsp
  4174f8:	41 57                	push   r15
  4174fa:	41 56                	push   r14
  4174fc:	41 55                	push   r13
  4174fe:	41 54                	push   r12
  417500:	53                   	push   rbx
  417501:	48 83 ec 18          	sub    rsp,0x18
	assert(c < h->e);
  417505:	8b 07                	mov    eax,DWORD PTR [rdi]
  417507:	39 f0                	cmp    eax,esi
  417509:	0f 8e 9d 01 00 00    	jle    4176ac <heap_adjust+0x1bc>
  41750f:	41 89 f6             	mov    r14d,esi
	assert(c > 0);
  417512:	85 f6                	test   esi,esi
  417514:	0f 8e ba 01 00 00    	jle    4176d4 <heap_adjust+0x1e4>
  41751a:	48 89 fb             	mov    rbx,rdi
	while (c > 1) {
  41751d:	83 fe 01             	cmp    esi,0x1
  417520:	75 49                	jne    41756b <heap_adjust+0x7b>
  417522:	e9 6b 01 00 00       	jmp    417692 <heap_adjust+0x1a2>
  417527:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41752e:	00 00 
	arr[a] = arr[b];
  417530:	4c 03 63 18          	add    r12,QWORD PTR [rbx+0x18]
	t      = arr[a];
  417534:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
	u(arr[a], a);
  417538:	44 89 f6             	mov    esi,r14d
	t      = arr[a];
  41753b:	48 03 43 18          	add    rax,QWORD PTR [rbx+0x18]
	arr[a] = arr[b];
  41753f:	49 8b 0c 24          	mov    rcx,QWORD PTR [r12]
	t      = arr[a];
  417543:	48 8b 10             	mov    rdx,QWORD PTR [rax]
		swap_entries(h->data, p, c, h->u);
  417546:	4c 8b 7b 10          	mov    r15,QWORD PTR [rbx+0x10]
	arr[a] = arr[b];
  41754a:	48 89 08             	mov    QWORD PTR [rax],rcx
	arr[b] = t;
  41754d:	49 89 14 24          	mov    QWORD PTR [r12],rdx
	u(arr[a], a);
  417551:	48 8b 38             	mov    rdi,QWORD PTR [rax]
  417554:	41 ff d7             	call   r15
	u(arr[b], b);
  417557:	49 8b 3c 24          	mov    rdi,QWORD PTR [r12]
  41755b:	44 89 ee             	mov    esi,r13d
  41755e:	41 ff d7             	call   r15
	while (c > 1) {
  417561:	41 83 fe 01          	cmp    r14d,0x1
  417565:	0f 84 25 01 00 00    	je     417690 <heap_adjust+0x1a0>
		p = c / 2;
  41756b:	49 63 ce             	movsxd rcx,r14d
		if (h->c(h->data[p], h->data[c])) break; /* done? */
  41756e:	48 8b 43 18          	mov    rax,QWORD PTR [rbx+0x18]
		p = c / 2;
  417572:	41 89 ce             	mov    r14d,ecx
  417575:	49 89 cd             	mov    r13,rcx
		if (h->c(h->data[p], h->data[c])) break; /* done? */
  417578:	4c 8d 24 cd 00 00 00 	lea    r12,[rcx*8+0x0]
  41757f:	00 
		p = c / 2;
  417580:	41 d1 fe             	sar    r14d,1
		if (h->c(h->data[p], h->data[c])) break; /* done? */
  417583:	48 8b 34 c8          	mov    rsi,QWORD PTR [rax+rcx*8]
  417587:	49 63 d6             	movsxd rdx,r14d
  41758a:	48 8d 3c d5 00 00 00 	lea    rdi,[rdx*8+0x0]
  417591:	00 
  417592:	48 89 7d c8          	mov    QWORD PTR [rbp-0x38],rdi
  417596:	48 8b 3c d0          	mov    rdi,QWORD PTR [rax+rdx*8]
  41759a:	ff 53 08             	call   QWORD PTR [rbx+0x8]
  41759d:	85 c0                	test   eax,eax
  41759f:	74 8f                	je     417530 <heap_adjust+0x40>
	assert(c <= h->e);
  4175a1:	8b 03                	mov    eax,DWORD PTR [rbx]
  4175a3:	44 39 e8             	cmp    eax,r13d
  4175a6:	0f 8c 50 01 00 00    	jl     4176fc <heap_adjust+0x20c>
	l = h->e - 1;
  4175ac:	83 e8 01             	sub    eax,0x1
  4175af:	89 45 c4             	mov    DWORD PTR [rbp-0x3c],eax
	while (c <= l / 2) { /* not a leaf? */
  4175b2:	d1 f8                	sar    eax,1
  4175b4:	89 45 c0             	mov    DWORD PTR [rbp-0x40],eax
  4175b7:	44 39 e8             	cmp    eax,r13d
  4175ba:	7d 75                	jge    417631 <heap_adjust+0x141>
  4175bc:	e9 dc 00 00 00       	jmp    41769d <heap_adjust+0x1ad>
  4175c1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		if (h->c(h->data[c], h->data[n])) break; /* done? */
  4175c8:	48 8b 43 18          	mov    rax,QWORD PTR [rbx+0x18]
  4175cc:	49 63 f7             	movsxd rsi,r15d
  4175cf:	49 63 cd             	movsxd rcx,r13d
  4175d2:	4c 8d 24 f5 00 00 00 	lea    r12,[rsi*8+0x0]
  4175d9:	00 
  4175da:	4c 8d 34 cd 00 00 00 	lea    r14,[rcx*8+0x0]
  4175e1:	00 
  4175e2:	48 8b 34 f0          	mov    rsi,QWORD PTR [rax+rsi*8]
  4175e6:	48 8b 3c c8          	mov    rdi,QWORD PTR [rax+rcx*8]
  4175ea:	ff 53 08             	call   QWORD PTR [rbx+0x8]
  4175ed:	85 c0                	test   eax,eax
  4175ef:	0f 85 a8 00 00 00    	jne    41769d <heap_adjust+0x1ad>
	t      = arr[a];
  4175f5:	4c 03 63 18          	add    r12,QWORD PTR [rbx+0x18]
	arr[a] = arr[b];
  4175f9:	4c 03 73 18          	add    r14,QWORD PTR [rbx+0x18]
		swap_entries(h->data, n, c, h->u);
  4175fd:	48 8b 43 10          	mov    rax,QWORD PTR [rbx+0x10]
	arr[a] = arr[b];
  417601:	49 8b 36             	mov    rsi,QWORD PTR [r14]
	t      = arr[a];
  417604:	49 8b 0c 24          	mov    rcx,QWORD PTR [r12]
	u(arr[a], a);
  417608:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
	arr[a] = arr[b];
  41760c:	49 89 34 24          	mov    QWORD PTR [r12],rsi
	u(arr[a], a);
  417610:	44 89 fe             	mov    esi,r15d
	arr[b] = t;
  417613:	49 89 0e             	mov    QWORD PTR [r14],rcx
	u(arr[a], a);
  417616:	49 8b 3c 24          	mov    rdi,QWORD PTR [r12]
  41761a:	ff d0                	call   rax
	u(arr[b], b);
  41761c:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  41761f:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  417623:	44 89 ee             	mov    esi,r13d
  417626:	ff d0                	call   rax
	while (c <= l / 2) { /* not a leaf? */
  417628:	44 39 7d c0          	cmp    DWORD PTR [rbp-0x40],r15d
  41762c:	7c 6f                	jl     41769d <heap_adjust+0x1ad>
  41762e:	45 89 fd             	mov    r13d,r15d
		left  = 2 * c;
  417631:	47 8d 7c 2d 00       	lea    r15d,[r13+r13*1+0x0]
		right = 2 * c + 1;
  417636:	45 8d 67 01          	lea    r12d,[r15+0x1]
		if (right > l) {
  41763a:	44 39 65 c4          	cmp    DWORD PTR [rbp-0x3c],r12d
  41763e:	7c 1b                	jl     41765b <heap_adjust+0x16b>
		} else if (h->c(h->data[left], h->data[right])) {
  417640:	48 8b 43 18          	mov    rax,QWORD PTR [rbx+0x18]
  417644:	49 63 cc             	movsxd rcx,r12d
  417647:	48 8b 34 c8          	mov    rsi,QWORD PTR [rax+rcx*8]
  41764b:	49 63 cf             	movsxd rcx,r15d
  41764e:	48 8b 3c c8          	mov    rdi,QWORD PTR [rax+rcx*8]
  417652:	ff 53 08             	call   QWORD PTR [rbx+0x8]
  417655:	85 c0                	test   eax,eax
  417657:	45 0f 44 fc          	cmove  r15d,r12d
		assert(n < h->e);
  41765b:	44 39 3b             	cmp    DWORD PTR [rbx],r15d
  41765e:	0f 8f 64 ff ff ff    	jg     4175c8 <heap_adjust+0xd8>
  417664:	48 bf c0 1b 42 00 00 	movabs rdi,0x421bc0
  41766b:	00 00 00 
  41766e:	be 23 00 00 00       	mov    esi,0x23
  417673:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  41767a:	00 00 00 
  41767d:	ff d0                	call   rax
  41767f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  417686:	00 00 00 00 
  41768a:	0f 0b                	ud2    
  41768c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	assert(c <= h->e);
  417690:	8b 03                	mov    eax,DWORD PTR [rbx]
  417692:	41 bd 01 00 00 00    	mov    r13d,0x1
  417698:	e9 06 ff ff ff       	jmp    4175a3 <heap_adjust+0xb3>

	debug("heap_adjust(%p,%d) %p@%d\n", h, h->e, h->data[c], c);
	heapify(h, c);
	assert(!heap_verify(h));
}
  41769d:	48 83 c4 18          	add    rsp,0x18
  4176a1:	5b                   	pop    rbx
  4176a2:	41 5c                	pop    r12
  4176a4:	41 5d                	pop    r13
  4176a6:	41 5e                	pop    r14
  4176a8:	41 5f                	pop    r15
  4176aa:	5d                   	pop    rbp
  4176ab:	c3                   	ret    
  4176ac:	48 bf e8 1b 42 00 00 	movabs rdi,0x421be8
  4176b3:	00 00 00 
  4176b6:	be 24 00 00 00       	mov    esi,0x24
  4176bb:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4176c2:	00 00 00 
  4176c5:	ff d0                	call   rax
	assert(c < h->e);
  4176c7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4176ce:	00 00 00 00 
  4176d2:	0f 0b                	ud2    
  4176d4:	48 bf 10 1c 42 00 00 	movabs rdi,0x421c10
  4176db:	00 00 00 
  4176de:	be 24 00 00 00       	mov    esi,0x24
  4176e3:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4176ea:	00 00 00 
  4176ed:	ff d0                	call   rax
	assert(c > 0);
  4176ef:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4176f6:	00 00 00 00 
  4176fa:	0f 0b                	ud2    
  4176fc:	48 bf 98 1b 42 00 00 	movabs rdi,0x421b98
  417703:	00 00 00 
  417706:	be 23 00 00 00       	mov    esi,0x23
  41770b:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  417712:	00 00 00 
  417715:	ff d0                	call   rax
	assert(c <= h->e);
  417717:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41771e:	00 00 00 00 
  417722:	0f 0b                	ud2    
  417724:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41772b:	00 00 00 00 
  41772f:	90                   	nop

0000000000417730 <heap_remove>:

void *
heap_remove(struct heap *h, int c)
{
  417730:	f3 0f 1e fa          	endbr64 
  417734:	55                   	push   rbp
  417735:	48 89 e5             	mov    rbp,rsp
  417738:	41 56                	push   r14
  41773a:	41 55                	push   r13
  41773c:	41 54                	push   r12
  41773e:	53                   	push   rbx
	void *r;

	assert(c < h->e);
  41773f:	8b 07                	mov    eax,DWORD PTR [rdi]
  417741:	39 f0                	cmp    eax,esi
  417743:	7e 76                	jle    4177bb <heap_remove+0x8b>
  417745:	41 89 f5             	mov    r13d,esi
	assert(c >= 1);
  417748:	85 f6                	test   esi,esi
  41774a:	0f 8e 93 00 00 00    	jle    4177e3 <heap_remove+0xb3>
	if (h->e == 1) return NULL;
  417750:	83 f8 01             	cmp    eax,0x1
  417753:	0f 84 b2 00 00 00    	je     41780b <heap_remove+0xdb>

	assert(!heap_verify(h));
	r = h->data[c];
  417759:	48 8b 57 18          	mov    rdx,QWORD PTR [rdi+0x18]
  41775d:	48 63 de             	movsxd rbx,esi
  417760:	49 89 fc             	mov    r12,rdi
	debug("heap_remove(%p,%d) %p@%d\n", h, h->e, h->data[c], c);
	h->e--;
  417763:	83 e8 01             	sub    eax,0x1
	h->u(r, 0);
  417766:	31 f6                	xor    esi,esi
	r = h->data[c];
  417768:	4c 8b 34 da          	mov    r14,QWORD PTR [rdx+rbx*8]
	h->e--;
  41776c:	89 07                	mov    DWORD PTR [rdi],eax
	h->u(r, 0);
  41776e:	4c 89 f7             	mov    rdi,r14
  417771:	41 ff 54 24 10       	call   QWORD PTR [r12+0x10]

	if (c == h->e) {
  417776:	49 63 04 24          	movsxd rax,DWORD PTR [r12]
  41777a:	44 39 e8             	cmp    eax,r13d
  41777d:	74 30                	je     4177af <heap_remove+0x7f>
		assert(!heap_verify(h));
		return r;
	}
	h->data[c] = h->data[h->e];
  41777f:	49 8b 54 24 18       	mov    rdx,QWORD PTR [r12+0x18]
	h->u(h->data[c], c);
  417784:	44 89 ee             	mov    esi,r13d
	h->data[c] = h->data[h->e];
  417787:	48 8b 04 c2          	mov    rax,QWORD PTR [rdx+rax*8]
  41778b:	48 89 04 da          	mov    QWORD PTR [rdx+rbx*8],rax
	h->u(h->data[c], c);
  41778f:	49 8b 44 24 18       	mov    rax,QWORD PTR [r12+0x18]
  417794:	48 8b 3c d8          	mov    rdi,QWORD PTR [rax+rbx*8]
  417798:	41 ff 54 24 10       	call   QWORD PTR [r12+0x10]
	heap_adjust(h, c);
  41779d:	44 89 ee             	mov    esi,r13d
  4177a0:	4c 89 e7             	mov    rdi,r12
  4177a3:	48 b8 f0 74 41 00 00 	movabs rax,0x4174f0
  4177aa:	00 00 00 
  4177ad:	ff d0                	call   rax
	assert(!heap_verify(h));

	return r;
}
  4177af:	5b                   	pop    rbx
  4177b0:	4c 89 f0             	mov    rax,r14
  4177b3:	41 5c                	pop    r12
  4177b5:	41 5d                	pop    r13
  4177b7:	41 5e                	pop    r14
  4177b9:	5d                   	pop    rbp
  4177ba:	c3                   	ret    
  4177bb:	48 bf 38 1c 42 00 00 	movabs rdi,0x421c38
  4177c2:	00 00 00 
  4177c5:	be 24 00 00 00       	mov    esi,0x24
  4177ca:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4177d1:	00 00 00 
  4177d4:	ff d0                	call   rax
	assert(c < h->e);
  4177d6:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4177dd:	00 00 00 00 
  4177e1:	0f 0b                	ud2    
  4177e3:	48 bf 60 1c 42 00 00 	movabs rdi,0x421c60
  4177ea:	00 00 00 
  4177ed:	be 24 00 00 00       	mov    esi,0x24
  4177f2:	48 b8 10 b3 40 00 00 	movabs rax,0x40b310
  4177f9:	00 00 00 
  4177fc:	ff d0                	call   rax
	assert(c >= 1);
  4177fe:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  417805:	00 00 00 00 
  417809:	0f 0b                	ud2    
	if (h->e == 1) return NULL;
  41780b:	45 31 f6             	xor    r14d,r14d
  41780e:	eb 9f                	jmp    4177af <heap_remove+0x7f>

0000000000417810 <heap_size>:

int
heap_size(struct heap *h)
{
  417810:	f3 0f 1e fa          	endbr64 
	return h->e - 1;
  417814:	8b 07                	mov    eax,DWORD PTR [rdi]
  417816:	83 e8 01             	sub    eax,0x1
}
  417819:	c3                   	ret    

000000000041781a <memcpy>:
.global __memcpy_fwd
.hidden __memcpy_fwd
.type memcpy,@function
memcpy:
__memcpy_fwd:
	mov %rdi,%rax
  41781a:	48 89 f8             	mov    rax,rdi
	cmp $8,%rdx
  41781d:	48 83 fa 08          	cmp    rdx,0x8
	jc 1f
  417821:	72 14                	jb     417837 <memcpy+0x1d>
	test $7,%edi
  417823:	f7 c7 07 00 00 00    	test   edi,0x7
	jz 1f
  417829:	74 0c                	je     417837 <memcpy+0x1d>
2:	movsb
  41782b:	a4                   	movs   BYTE PTR es:[rdi],BYTE PTR ds:[rsi]
	dec %rdx
  41782c:	48 ff ca             	dec    rdx
	test $7,%edi
  41782f:	f7 c7 07 00 00 00    	test   edi,0x7
	jnz 2b
  417835:	75 f4                	jne    41782b <memcpy+0x11>
1:	mov %rdx,%rcx
  417837:	48 89 d1             	mov    rcx,rdx
	shr $3,%rcx
  41783a:	48 c1 e9 03          	shr    rcx,0x3
	rep
  41783e:	f3 48 a5             	rep movs QWORD PTR es:[rdi],QWORD PTR ds:[rsi]
	movsq
	and $7,%edx
  417841:	83 e2 07             	and    edx,0x7
	jz 1f
  417844:	74 05                	je     41784b <memcpy+0x31>
2:	movsb
  417846:	a4                   	movs   BYTE PTR es:[rdi],BYTE PTR ds:[rsi]
	dec %edx
  417847:	ff ca                	dec    edx
	jnz 2b
  417849:	75 fb                	jne    417846 <memcpy+0x2c>
1:	ret
  41784b:	c3                   	ret    

000000000041784c <memset>:
.global memset
.type memset,@function
memset:
	movzbq %sil,%rax
  41784c:	48 0f b6 c6          	movzx  rax,sil
	mov $0x101010101010101,%r8
  417850:	49 b8 01 01 01 01 01 	movabs r8,0x101010101010101
  417857:	01 01 01 
	imul %r8,%rax
  41785a:	49 0f af c0          	imul   rax,r8

	cmp $126,%rdx
  41785e:	48 83 fa 7e          	cmp    rdx,0x7e
	ja 2f
  417862:	77 78                	ja     4178dc <memset+0x90>

	test %edx,%edx
  417864:	85 d2                	test   edx,edx
	jz 1f
  417866:	74 70                	je     4178d8 <memset+0x8c>

	mov %sil,(%rdi)
  417868:	40 88 37             	mov    BYTE PTR [rdi],sil
	mov %sil,-1(%rdi,%rdx)
  41786b:	40 88 74 17 ff       	mov    BYTE PTR [rdi+rdx*1-0x1],sil
	cmp $2,%edx
  417870:	83 fa 02             	cmp    edx,0x2
	jbe 1f
  417873:	76 63                	jbe    4178d8 <memset+0x8c>

	mov %ax,1(%rdi)
  417875:	66 89 47 01          	mov    WORD PTR [rdi+0x1],ax
	mov %ax,(-1-2)(%rdi,%rdx)
  417879:	66 89 44 17 fd       	mov    WORD PTR [rdi+rdx*1-0x3],ax
	cmp $6,%edx
  41787e:	83 fa 06             	cmp    edx,0x6
	jbe 1f
  417881:	76 55                	jbe    4178d8 <memset+0x8c>

	mov %eax,(1+2)(%rdi)
  417883:	89 47 03             	mov    DWORD PTR [rdi+0x3],eax
	mov %eax,(-1-2-4)(%rdi,%rdx)
  417886:	89 44 17 f9          	mov    DWORD PTR [rdi+rdx*1-0x7],eax
	cmp $14,%edx
  41788a:	83 fa 0e             	cmp    edx,0xe
	jbe 1f
  41788d:	76 49                	jbe    4178d8 <memset+0x8c>

	mov %rax,(1+2+4)(%rdi)
  41788f:	48 89 47 07          	mov    QWORD PTR [rdi+0x7],rax
	mov %rax,(-1-2-4-8)(%rdi,%rdx)
  417893:	48 89 44 17 f1       	mov    QWORD PTR [rdi+rdx*1-0xf],rax
	cmp $30,%edx
  417898:	83 fa 1e             	cmp    edx,0x1e
	jbe 1f
  41789b:	76 3b                	jbe    4178d8 <memset+0x8c>

	mov %rax,(1+2+4+8)(%rdi)
  41789d:	48 89 47 0f          	mov    QWORD PTR [rdi+0xf],rax
	mov %rax,(1+2+4+8+8)(%rdi)
  4178a1:	48 89 47 17          	mov    QWORD PTR [rdi+0x17],rax
	mov %rax,(-1-2-4-8-16)(%rdi,%rdx)
  4178a5:	48 89 44 17 e1       	mov    QWORD PTR [rdi+rdx*1-0x1f],rax
	mov %rax,(-1-2-4-8-8)(%rdi,%rdx)
  4178aa:	48 89 44 17 e9       	mov    QWORD PTR [rdi+rdx*1-0x17],rax
	cmp $62,%edx
  4178af:	83 fa 3e             	cmp    edx,0x3e
	jbe 1f
  4178b2:	76 24                	jbe    4178d8 <memset+0x8c>

	mov %rax,(1+2+4+8+16)(%rdi)
  4178b4:	48 89 47 1f          	mov    QWORD PTR [rdi+0x1f],rax
	mov %rax,(1+2+4+8+16+8)(%rdi)
  4178b8:	48 89 47 27          	mov    QWORD PTR [rdi+0x27],rax
	mov %rax,(1+2+4+8+16+16)(%rdi)
  4178bc:	48 89 47 2f          	mov    QWORD PTR [rdi+0x2f],rax
	mov %rax,(1+2+4+8+16+24)(%rdi)
  4178c0:	48 89 47 37          	mov    QWORD PTR [rdi+0x37],rax
	mov %rax,(-1-2-4-8-16-32)(%rdi,%rdx)
  4178c4:	48 89 44 17 c1       	mov    QWORD PTR [rdi+rdx*1-0x3f],rax
	mov %rax,(-1-2-4-8-16-24)(%rdi,%rdx)
  4178c9:	48 89 44 17 c9       	mov    QWORD PTR [rdi+rdx*1-0x37],rax
	mov %rax,(-1-2-4-8-16-16)(%rdi,%rdx)
  4178ce:	48 89 44 17 d1       	mov    QWORD PTR [rdi+rdx*1-0x2f],rax
	mov %rax,(-1-2-4-8-16-8)(%rdi,%rdx)
  4178d3:	48 89 44 17 d9       	mov    QWORD PTR [rdi+rdx*1-0x27],rax

1:	mov %rdi,%rax
  4178d8:	48 89 f8             	mov    rax,rdi
	ret
  4178db:	c3                   	ret    

2:	test $15,%edi
  4178dc:	f7 c7 0f 00 00 00    	test   edi,0xf
	mov %rdi,%r8
  4178e2:	49 89 f8             	mov    r8,rdi
	mov %rax,-8(%rdi,%rdx)
  4178e5:	48 89 44 17 f8       	mov    QWORD PTR [rdi+rdx*1-0x8],rax
	mov %rdx,%rcx
  4178ea:	48 89 d1             	mov    rcx,rdx
	jnz 2f
  4178ed:	75 0b                	jne    4178fa <memset+0xae>

1:	shr $3,%rcx
  4178ef:	48 c1 e9 03          	shr    rcx,0x3
	rep
  4178f3:	f3 48 ab             	rep stos QWORD PTR es:[rdi],rax
	stosq
	mov %r8,%rax
  4178f6:	4c 89 c0             	mov    rax,r8
	ret
  4178f9:	c3                   	ret    

2:	xor %edx,%edx
  4178fa:	31 d2                	xor    edx,edx
	sub %edi,%edx
  4178fc:	29 fa                	sub    edx,edi
	and $15,%edx
  4178fe:	83 e2 0f             	and    edx,0xf
	mov %rax,(%rdi)
  417901:	48 89 07             	mov    QWORD PTR [rdi],rax
	mov %rax,8(%rdi)
  417904:	48 89 47 08          	mov    QWORD PTR [rdi+0x8],rax
	sub %rdx,%rcx
  417908:	48 29 d1             	sub    rcx,rdx
	add %rdx,%rdi
  41790b:	48 01 d7             	add    rdi,rdx
	jmp 1b
  41790e:	eb df                	jmp    4178ef <memset+0xa3>

0000000000417910 <__set_thread_area>:
.text
.global __set_thread_area
.hidden __set_thread_area
.type __set_thread_area,@function
__set_thread_area:
	mov %rdi,%rsi           /* shift for syscall */
  417910:	48 89 fe             	mov    rsi,rdi
	movl $0x1002,%edi       /* SET_FS register */
  417913:	bf 02 10 00 00       	mov    edi,0x1002
	movl $158,%eax          /* set fs segment to */
  417918:	b8 9e 00 00 00       	mov    eax,0x9e
	syscall                 /* arch_prctl(SET_FS, arg)*/
  41791d:	0f 05                	syscall 
	ret
  41791f:	c3                   	ret    

0000000000417920 <sched_set_tls.cold>:
	thdcap_t thdcap = current->thd;
  417920:	48 8b 04 25 10 00 00 	mov    rax,QWORD PTR ds:0x10
  417927:	00 
  417928:	0f 0b                	ud2    

000000000041792a <sched_debug_thd_state.cold>:
	return t->state;
  41792a:	8b 04 25 04 00 00 00 	mov    eax,DWORD PTR ds:0x4
  417931:	0f 0b                	ud2    
  417933:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41793a:	00 00 00 
  41793d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000417940 <_init>:
#include <unistd.h>
#include "syscall.h"
#include "atomic.h"
#include "libc.h"

static void dummy(void) {}
  417940:	f3 0f 1e fa          	endbr64 
  417944:	c3                   	ret    
  417945:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41794c:	00 00 00 
  41794f:	90                   	nop

0000000000417950 <__funcs_on_exit>:
#include <stdlib.h>
#include <stdint.h>
#include "libc.h"

static void dummy()
{
  417950:	f3 0f 1e fa          	endbr64 
}
  417954:	c3                   	ret    
  417955:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41795c:	00 00 00 
  41795f:	90                   	nop

0000000000417960 <__lctrans_impl>:
#include <locale.h>
#include "locale_impl.h"

static const char *dummy(const char *msg, const struct __locale_map *lm)
{
  417960:	f3 0f 1e fa          	endbr64 
  417964:	48 89 f8             	mov    rax,rdi
	return msg;
}
  417967:	c3                   	ret    
  417968:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41796f:	00 

0000000000417970 <__init_ssp>:
weak_alias(dummy, _init);

extern weak hidden void (*const __init_array_start)(void), (*const __init_array_end)(void);

static void dummy1(void *p) {}
  417970:	f3 0f 1e fa          	endbr64 
  417974:	c3                   	ret    
  417975:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41797c:	00 00 00 
  41797f:	90                   	nop

0000000000417980 <__init_libc>:

#ifdef __GNUC__
__attribute__((__noinline__))
#endif
void __init_libc(char **envp, char *pn)
{
  417980:	f3 0f 1e fa          	endbr64 
  417984:	41 57                	push   r15
  417986:	48 89 fa             	mov    rdx,rdi
	size_t i, *auxv, aux[AUX_CNT] = { 0 };
  417989:	31 c0                	xor    eax,eax
  41798b:	4c 8d 3d f2 ff ff ff 	lea    r15,[rip+0xfffffffffffffff2]        # 417984 <__init_libc+0x4>
{
  417992:	55                   	push   rbp
	size_t i, *auxv, aux[AUX_CNT] = { 0 };
  417993:	b9 26 00 00 00       	mov    ecx,0x26
  417998:	49 bb 8c 9a 04 00 00 	movabs r11,0x49a8c
  41799f:	00 00 00 
{
  4179a2:	53                   	push   rbx
  4179a3:	4d 01 df             	add    r15,r11
  4179a6:	48 81 ec 50 01 00 00 	sub    rsp,0x150
	__environ = envp;
	for (i=0; envp[i]; i++);
  4179ad:	48 83 3a 00          	cmp    QWORD PTR [rdx],0x0
	size_t i, *auxv, aux[AUX_CNT] = { 0 };
  4179b1:	4c 8d 44 24 20       	lea    r8,[rsp+0x20]
  4179b6:	4c 89 c7             	mov    rdi,r8
  4179b9:	f3 48 ab             	rep stos QWORD PTR es:[rdi],rax
	__environ = envp;
  4179bc:	48 b8 d0 ff ff ff ff 	movabs rax,0xffffffffffffffd0
  4179c3:	ff ff ff 
  4179c6:	49 8b 04 07          	mov    rax,QWORD PTR [r15+rax*1]
  4179ca:	48 89 10             	mov    QWORD PTR [rax],rdx
	for (i=0; envp[i]; i++);
  4179cd:	0f 84 1d 03 00 00    	je     417cf0 <__init_libc+0x370>
  4179d3:	31 c0                	xor    eax,eax
  4179d5:	0f 1f 00             	nop    DWORD PTR [rax]
  4179d8:	48 89 c1             	mov    rcx,rax
  4179db:	48 83 c0 01          	add    rax,0x1
  4179df:	48 83 3c c2 00       	cmp    QWORD PTR [rdx+rax*8],0x0
  4179e4:	75 f2                	jne    4179d8 <__init_libc+0x58>
	libc.auxv = auxv = (void *)(envp+i+1);
  4179e6:	48 8d 04 cd 10 00 00 	lea    rax,[rcx*8+0x10]
  4179ed:	00 
  4179ee:	48 bb 30 4c 14 00 00 	movabs rbx,0x144c30
  4179f5:	00 00 00 
  4179f8:	48 01 d0             	add    rax,rdx
	for (i=0; auxv[i]; i+=2) if (auxv[i]<AUX_CNT) aux[auxv[i]] = auxv[i+1];
  4179fb:	48 8b 10             	mov    rdx,QWORD PTR [rax]
	libc.auxv = auxv = (void *)(envp+i+1);
  4179fe:	4a 89 44 3b 10       	mov    QWORD PTR [rbx+r15*1+0x10],rax
	for (i=0; auxv[i]; i+=2) if (auxv[i]<AUX_CNT) aux[auxv[i]] = auxv[i+1];
  417a03:	48 83 c0 08          	add    rax,0x8
  417a07:	48 85 d2             	test   rdx,rdx
  417a0a:	0f 84 f0 02 00 00    	je     417d00 <__init_libc+0x380>
  417a10:	48 83 fa 25          	cmp    rdx,0x25
  417a14:	0f 87 76 01 00 00    	ja     417b90 <__init_libc+0x210>
  417a1a:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  417a1d:	48 83 c0 10          	add    rax,0x10
  417a21:	48 89 4c d4 20       	mov    QWORD PTR [rsp+rdx*8+0x20],rcx
  417a26:	48 8b 50 f8          	mov    rdx,QWORD PTR [rax-0x8]
  417a2a:	48 85 d2             	test   rdx,rdx
  417a2d:	75 e1                	jne    417a10 <__init_libc+0x90>
	__hwcap = aux[AT_HWCAP];
  417a2f:	48 8b bc 24 a0 00 00 	mov    rdi,QWORD PTR [rsp+0xa0]
  417a36:	00 
	if (aux[AT_SYSINFO]) __sysinfo = aux[AT_SYSINFO];
  417a37:	48 8b 84 24 20 01 00 	mov    rax,QWORD PTR [rsp+0x120]
  417a3e:	00 
	__hwcap = aux[AT_HWCAP];
  417a3f:	48 b9 28 4c 14 00 00 	movabs rcx,0x144c28
  417a46:	00 00 00 
	libc.page_size = aux[AT_PAGESZ];
  417a49:	48 8b 54 24 50       	mov    rdx,QWORD PTR [rsp+0x50]
	__hwcap = aux[AT_HWCAP];
  417a4e:	49 89 3c 0f          	mov    QWORD PTR [r15+rcx*1],rdi
	if (aux[AT_SYSINFO]) __sysinfo = aux[AT_SYSINFO];
  417a52:	48 85 c0             	test   rax,rax
  417a55:	74 0e                	je     417a65 <__init_libc+0xe5>
  417a57:	48 b9 10 4c 14 00 00 	movabs rcx,0x144c10
  417a5e:	00 00 00 
  417a61:	49 89 04 0f          	mov    QWORD PTR [r15+rcx*1],rax
	libc.page_size = aux[AT_PAGESZ];
  417a65:	4a 89 54 3b 38       	mov    QWORD PTR [rbx+r15*1+0x38],rdx

	if (!pn) pn = (void*)aux[AT_EXECFN];
  417a6a:	48 85 f6             	test   rsi,rsi
  417a6d:	0f 84 1d 02 00 00    	je     417c90 <__init_libc+0x310>
	if (!pn) pn = "";
	__progname = __progname_full = pn;
  417a73:	48 b8 f8 ff ff ff ff 	movabs rax,0xfffffffffffffff8
  417a7a:	ff ff ff 
  417a7d:	48 b9 d8 ff ff ff ff 	movabs rcx,0xffffffffffffffd8
  417a84:	ff ff ff 
  417a87:	49 8b 04 07          	mov    rax,QWORD PTR [r15+rax*1]
  417a8b:	48 89 30             	mov    QWORD PTR [rax],rsi
  417a8e:	4a 8b 04 39          	mov    rax,QWORD PTR [rcx+r15*1]
  417a92:	48 89 30             	mov    QWORD PTR [rax],rsi
	for (i=0; pn[i]; i++) if (pn[i]=='/') __progname = pn+i+1;
  417a95:	0f b6 16             	movzx  edx,BYTE PTR [rsi]
  417a98:	84 d2                	test   dl,dl
  417a9a:	74 18                	je     417ab4 <__init_libc+0x134>
  417a9c:	48 8d 46 01          	lea    rax,[rsi+0x1]
  417aa0:	80 fa 2f             	cmp    dl,0x2f
  417aa3:	0f 84 07 01 00 00    	je     417bb0 <__init_libc+0x230>
  417aa9:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  417aac:	48 83 c0 01          	add    rax,0x1
  417ab0:	84 d2                	test   dl,dl
  417ab2:	75 ec                	jne    417aa0 <__init_libc+0x120>

	__init_tls(aux);
  417ab4:	48 b8 a0 73 fb ff ff 	movabs rax,0xfffffffffffb73a0
  417abb:	ff ff ff 
  417abe:	4c 89 c7             	mov    rdi,r8
  417ac1:	4c 01 f8             	add    rax,r15
  417ac4:	ff d0                	call   rax
	__init_ssp((void *)aux[AT_RANDOM]);
  417ac6:	48 8b bc 24 e8 00 00 	mov    rdi,QWORD PTR [rsp+0xe8]
  417acd:	00 
  417ace:	48 b8 60 65 fb ff ff 	movabs rax,0xfffffffffffb6560
  417ad5:	ff ff ff 
  417ad8:	4c 01 f8             	add    rax,r15
  417adb:	ff d0                	call   rax

	if (aux[AT_UID]==aux[AT_EUID] && aux[AT_GID]==aux[AT_EGID]
  417add:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  417ae4:	00 
  417ae5:	48 39 44 24 78       	cmp    QWORD PTR [rsp+0x78],rax
  417aea:	75 16                	jne    417b02 <__init_libc+0x182>
  417aec:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  417af3:	00 
  417af4:	48 39 84 24 88 00 00 	cmp    QWORD PTR [rsp+0x88],rax
  417afb:	00 
  417afc:	0f 84 d6 01 00 00    	je     417cd8 <__init_libc+0x358>
		&& !aux[AT_SECURE]) return;

	struct pollfd pfd[3] = { {.fd=0}, {.fd=1}, {.fd=2} };
  417b02:	66 0f ef c0          	pxor   xmm0,xmm0
	int r =
#ifdef SYS_poll
	__syscall(SYS_poll, pfd, 3, 0);
  417b06:	48 89 e6             	mov    rsi,rsp
	return __cos_syscall(n, a1, a2, 0, 0, 0, 0, 0);
}

static __inline long __syscall3(long n, long a1, long a2, long a3)
{
	return __cos_syscall(n, a1, a2, a3, 0, 0, 0, 0);
  417b09:	45 31 c9             	xor    r9d,r9d
  417b0c:	45 31 c0             	xor    r8d,r8d
	struct pollfd pfd[3] = { {.fd=0}, {.fd=1}, {.fd=2} };
  417b0f:	0f 29 04 24          	movaps XMMWORD PTR [rsp],xmm0
  417b13:	31 c9                	xor    ecx,ecx
  417b15:	ba 03 00 00 00       	mov    edx,0x3
  417b1a:	bf 07 00 00 00       	mov    edi,0x7
  417b1f:	48 bd 50 a1 fa ff ff 	movabs rbp,0xfffffffffffaa150
  417b26:	ff ff ff 
  417b29:	c7 44 24 08 01 00 00 	mov    DWORD PTR [rsp+0x8],0x1
  417b30:	00 
  417b31:	48 c7 44 24 10 00 00 	mov    QWORD PTR [rsp+0x10],0x0
  417b38:	00 00 
  417b3a:	4a 8d 44 3d 00       	lea    rax,[rbp+r15*1+0x0]
  417b3f:	c7 44 24 10 02 00 00 	mov    DWORD PTR [rsp+0x10],0x2
  417b46:	00 
  417b47:	6a 00                	push   0x0
  417b49:	6a 00                	push   0x0
  417b4b:	ff d0                	call   rax
#else
	__syscall(SYS_ppoll, pfd, 3, &(struct timespec){0}, 0, _NSIG/8);
#endif
	if (r<0) a_crash();
  417b4d:	41 5a                	pop    r10
  417b4f:	41 5b                	pop    r11
  417b51:	85 c0                	test   eax,eax
  417b53:	79 01                	jns    417b56 <__init_libc+0x1d6>
}

#define a_crash a_crash
static inline void a_crash()
{
	__asm__ __volatile__( "hlt" : : : "memory" );
  417b55:	f4                   	hlt    
	for (i=0; i<3; i++) if (pfd[i].revents&POLLNVAL)
  417b56:	f6 44 24 06 20       	test   BYTE PTR [rsp+0x6],0x20
  417b5b:	0f 85 ef 00 00 00    	jne    417c50 <__init_libc+0x2d0>
  417b61:	f6 44 24 0e 20       	test   BYTE PTR [rsp+0xe],0x20
  417b66:	0f 85 a4 00 00 00    	jne    417c10 <__init_libc+0x290>
  417b6c:	f6 44 24 16 20       	test   BYTE PTR [rsp+0x16],0x20
  417b71:	75 5d                	jne    417bd0 <__init_libc+0x250>
		if (__sys_open("/dev/null", O_RDWR)<0)
			a_crash();
	libc.secure = 1;
  417b73:	42 c7 44 3b 08 01 00 	mov    DWORD PTR [rbx+r15*1+0x8],0x1
  417b7a:	00 00 
}
  417b7c:	48 81 c4 50 01 00 00 	add    rsp,0x150
  417b83:	5b                   	pop    rbx
  417b84:	5d                   	pop    rbp
  417b85:	41 5f                	pop    r15
  417b87:	c3                   	ret    
  417b88:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  417b8f:	00 
	for (i=0; auxv[i]; i+=2) if (auxv[i]<AUX_CNT) aux[auxv[i]] = auxv[i+1];
  417b90:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  417b94:	48 83 c0 10          	add    rax,0x10
  417b98:	48 85 d2             	test   rdx,rdx
  417b9b:	0f 85 6f fe ff ff    	jne    417a10 <__init_libc+0x90>
  417ba1:	e9 89 fe ff ff       	jmp    417a2f <__init_libc+0xaf>
  417ba6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  417bad:	00 00 00 
	for (i=0; pn[i]; i++) if (pn[i]=='/') __progname = pn+i+1;
  417bb0:	4a 8b 14 39          	mov    rdx,QWORD PTR [rcx+r15*1]
  417bb4:	48 89 02             	mov    QWORD PTR [rdx],rax
  417bb7:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  417bba:	48 83 c0 01          	add    rax,0x1
  417bbe:	84 d2                	test   dl,dl
  417bc0:	0f 85 da fe ff ff    	jne    417aa0 <__init_libc+0x120>
  417bc6:	e9 e9 fe ff ff       	jmp    417ab4 <__init_libc+0x134>
  417bcb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	return __cos_syscall(n, a1, a2, 0, 0, 0, 0, 0);
  417bd0:	6a 00                	push   0x0
  417bd2:	31 c9                	xor    ecx,ecx
  417bd4:	ba 02 00 00 00       	mov    edx,0x2
  417bd9:	45 31 c9             	xor    r9d,r9d
  417bdc:	6a 00                	push   0x0
  417bde:	45 31 c0             	xor    r8d,r8d
  417be1:	bf 02 00 00 00       	mov    edi,0x2
  417be6:	4c 01 fd             	add    rbp,r15
  417be9:	48 b8 75 08 fc ff ff 	movabs rax,0xfffffffffffc0875
  417bf0:	ff ff ff 
  417bf3:	49 8d 34 07          	lea    rsi,[r15+rax*1]
  417bf7:	ff d5                	call   rbp
		if (__sys_open("/dev/null", O_RDWR)<0)
  417bf9:	5a                   	pop    rdx
  417bfa:	59                   	pop    rcx
  417bfb:	48 85 c0             	test   rax,rax
  417bfe:	0f 89 6f ff ff ff    	jns    417b73 <__init_libc+0x1f3>
  417c04:	f4                   	hlt    
}
  417c05:	e9 69 ff ff ff       	jmp    417b73 <__init_libc+0x1f3>
  417c0a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  417c10:	6a 00                	push   0x0
  417c12:	bf 02 00 00 00       	mov    edi,0x2
  417c17:	45 31 c9             	xor    r9d,r9d
  417c1a:	45 31 c0             	xor    r8d,r8d
  417c1d:	48 b8 75 08 fc ff ff 	movabs rax,0xfffffffffffc0875
  417c24:	ff ff ff 
  417c27:	6a 00                	push   0x0
  417c29:	31 c9                	xor    ecx,ecx
  417c2b:	ba 02 00 00 00       	mov    edx,0x2
  417c30:	49 8d 34 07          	lea    rsi,[r15+rax*1]
  417c34:	4a 8d 44 3d 00       	lea    rax,[rbp+r15*1+0x0]
  417c39:	ff d0                	call   rax
  417c3b:	5e                   	pop    rsi
  417c3c:	5f                   	pop    rdi
  417c3d:	48 85 c0             	test   rax,rax
  417c40:	0f 89 26 ff ff ff    	jns    417b6c <__init_libc+0x1ec>
	__asm__ __volatile__( "hlt" : : : "memory" );
  417c46:	f4                   	hlt    
  417c47:	e9 20 ff ff ff       	jmp    417b6c <__init_libc+0x1ec>
  417c4c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  417c50:	6a 00                	push   0x0
  417c52:	45 31 c9             	xor    r9d,r9d
  417c55:	45 31 c0             	xor    r8d,r8d
  417c58:	31 c9                	xor    ecx,ecx
  417c5a:	6a 00                	push   0x0
  417c5c:	ba 02 00 00 00       	mov    edx,0x2
  417c61:	bf 02 00 00 00       	mov    edi,0x2
  417c66:	48 b8 75 08 fc ff ff 	movabs rax,0xfffffffffffc0875
  417c6d:	ff ff ff 
  417c70:	49 8d 34 07          	lea    rsi,[r15+rax*1]
  417c74:	4a 8d 44 3d 00       	lea    rax,[rbp+r15*1+0x0]
  417c79:	ff d0                	call   rax
  417c7b:	41 58                	pop    r8
  417c7d:	41 59                	pop    r9
  417c7f:	48 85 c0             	test   rax,rax
  417c82:	0f 89 d9 fe ff ff    	jns    417b61 <__init_libc+0x1e1>
  417c88:	f4                   	hlt    
  417c89:	e9 d3 fe ff ff       	jmp    417b61 <__init_libc+0x1e1>
  417c8e:	66 90                	xchg   ax,ax
	if (!pn) pn = (void*)aux[AT_EXECFN];
  417c90:	48 8b 84 24 18 01 00 	mov    rax,QWORD PTR [rsp+0x118]
  417c97:	00 
	if (!pn) pn = "";
  417c98:	48 85 c0             	test   rax,rax
  417c9b:	75 7a                	jne    417d17 <__init_libc+0x397>
	__progname = __progname_full = pn;
  417c9d:	48 b8 f8 ff ff ff ff 	movabs rax,0xfffffffffffffff8
  417ca4:	ff ff ff 
  417ca7:	49 8b 14 07          	mov    rdx,QWORD PTR [r15+rax*1]
  417cab:	48 b8 45 09 fc ff ff 	movabs rax,0xfffffffffffc0945
  417cb2:	ff ff ff 
  417cb5:	4c 01 f8             	add    rax,r15
  417cb8:	48 89 02             	mov    QWORD PTR [rdx],rax
  417cbb:	48 ba d8 ff ff ff ff 	movabs rdx,0xffffffffffffffd8
  417cc2:	ff ff ff 
  417cc5:	49 8b 14 17          	mov    rdx,QWORD PTR [r15+rdx*1]
  417cc9:	48 89 02             	mov    QWORD PTR [rdx],rax
	for (i=0; pn[i]; i++) if (pn[i]=='/') __progname = pn+i+1;
  417ccc:	e9 e3 fd ff ff       	jmp    417ab4 <__init_libc+0x134>
  417cd1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		&& !aux[AT_SECURE]) return;
  417cd8:	48 83 bc 24 d8 00 00 	cmp    QWORD PTR [rsp+0xd8],0x0
  417cdf:	00 00 
  417ce1:	0f 85 1b fe ff ff    	jne    417b02 <__init_libc+0x182>
  417ce7:	e9 90 fe ff ff       	jmp    417b7c <__init_libc+0x1fc>
  417cec:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	for (i=0; envp[i]; i++);
  417cf0:	b8 08 00 00 00       	mov    eax,0x8
  417cf5:	e9 f4 fc ff ff       	jmp    4179ee <__init_libc+0x6e>
  417cfa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	__hwcap = aux[AT_HWCAP];
  417d00:	48 b8 28 4c 14 00 00 	movabs rax,0x144c28
  417d07:	00 00 00 
  417d0a:	49 c7 04 07 00 00 00 	mov    QWORD PTR [r15+rax*1],0x0
  417d11:	00 
	if (aux[AT_SYSINFO]) __sysinfo = aux[AT_SYSINFO];
  417d12:	e9 4e fd ff ff       	jmp    417a65 <__init_libc+0xe5>
	if (!pn) pn = (void*)aux[AT_EXECFN];
  417d17:	48 89 c6             	mov    rsi,rax
  417d1a:	e9 54 fd ff ff       	jmp    417a73 <__init_libc+0xf3>
  417d1f:	90                   	nop

0000000000417d20 <__libc_start_init>:

static void libc_start_init(void)
{
  417d20:	f3 0f 1e fa          	endbr64 
	_init();
  417d24:	49 bb ec 96 04 00 00 	movabs r11,0x496ec
  417d2b:	00 00 00 
{
  417d2e:	41 57                	push   r15
  417d30:	4c 8d 3d ed ff ff ff 	lea    r15,[rip+0xffffffffffffffed]        # 417d24 <__libc_start_init+0x4>
	_init();
  417d37:	48 b8 30 65 fb ff ff 	movabs rax,0xfffffffffffb6530
  417d3e:	ff ff ff 
  417d41:	4d 01 df             	add    r15,r11
{
  417d44:	55                   	push   rbp
	_init();
  417d45:	4c 01 f8             	add    rax,r15
{
  417d48:	53                   	push   rbx
	_init();
  417d49:	ff d0                	call   rax
	uintptr_t a = (uintptr_t)&__init_array_start;
  417d4b:	48 b8 f0 ff ff ff ff 	movabs rax,0xfffffffffffffff0
  417d52:	ff ff ff 
  417d55:	49 8b 1c 07          	mov    rbx,QWORD PTR [r15+rax*1]
	for (; a<(uintptr_t)&__init_array_end; a+=sizeof(void(*)()))
  417d59:	48 b8 e8 ff ff ff ff 	movabs rax,0xffffffffffffffe8
  417d60:	ff ff ff 
  417d63:	49 8b 2c 07          	mov    rbp,QWORD PTR [r15+rax*1]
  417d67:	48 39 eb             	cmp    rbx,rbp
  417d6a:	73 0f                	jae    417d7b <__libc_start_init+0x5b>
  417d6c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		(*(void (**)(void))a)();
  417d70:	ff 13                	call   QWORD PTR [rbx]
	for (; a<(uintptr_t)&__init_array_end; a+=sizeof(void(*)()))
  417d72:	48 83 c3 08          	add    rbx,0x8
  417d76:	48 39 eb             	cmp    rbx,rbp
  417d79:	72 f5                	jb     417d70 <__libc_start_init+0x50>
}
  417d7b:	5b                   	pop    rbx
  417d7c:	5d                   	pop    rbp
  417d7d:	41 5f                	pop    r15
  417d7f:	c3                   	ret    

0000000000417d80 <libc_start_main_stage2>:
	__asm__ ( "" : "+r"(stage2) : : "memory" );
	return stage2(main, argc, argv);
}

static int libc_start_main_stage2(int (*main)(int,char **,char **), int argc, char **argv)
{
  417d80:	f3 0f 1e fa          	endbr64 
	char **envp = argv+argc+1;
  417d84:	49 bb 8c 96 04 00 00 	movabs r11,0x4968c
  417d8b:	00 00 00 
{
  417d8e:	41 57                	push   r15
  417d90:	48 63 c6             	movsxd rax,esi
  417d93:	4c 8d 3d ea ff ff ff 	lea    r15,[rip+0xffffffffffffffea]        # 417d84 <libc_start_main_stage2+0x4>
  417d9a:	41 55                	push   r13
  417d9c:	4d 01 df             	add    r15,r11
	char **envp = argv+argc+1;
  417d9f:	4c 8d 6c c2 08       	lea    r13,[rdx+rax*8+0x8]
{
  417da4:	41 54                	push   r12
  417da6:	49 89 d4             	mov    r12,rdx
  417da9:	55                   	push   rbp
  417daa:	48 89 c5             	mov    rbp,rax
	__libc_start_init();
  417dad:	48 b8 10 69 fb ff ff 	movabs rax,0xfffffffffffb6910
  417db4:	ff ff ff 
{
  417db7:	53                   	push   rbx
	__libc_start_init();
  417db8:	4c 01 f8             	add    rax,r15
{
  417dbb:	48 89 fb             	mov    rbx,rdi
	__libc_start_init();
  417dbe:	ff d0                	call   rax

	/* Pass control to the application */
	exit(main(argc, argv, envp));
  417dc0:	89 ef                	mov    edi,ebp
  417dc2:	4c 89 ea             	mov    rdx,r13
  417dc5:	4c 89 e6             	mov    rsi,r12
  417dc8:	ff d3                	call   rbx
  417dca:	89 c7                	mov    edi,eax
  417dcc:	48 b8 b0 6a fb ff ff 	movabs rax,0xfffffffffffb6ab0
  417dd3:	ff ff ff 
  417dd6:	4c 01 f8             	add    rax,r15
  417dd9:	ff d0                	call   rax
  417ddb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000417de0 <__libc_start_main>:
{
  417de0:	f3 0f 1e fa          	endbr64 
	char **envp = argv+argc+1;
  417de4:	49 bb 2c 96 04 00 00 	movabs r11,0x4962c
  417deb:	00 00 00 
{
  417dee:	41 55                	push   r13
  417df0:	48 63 c6             	movsxd rax,esi
  417df3:	49 89 fd             	mov    r13,rdi
  417df6:	41 54                	push   r12
	char **envp = argv+argc+1;
  417df8:	48 8d 7c c2 08       	lea    rdi,[rdx+rax*8+0x8]
{
  417dfd:	49 89 d4             	mov    r12,rdx
  417e00:	55                   	push   rbp
  417e01:	48 89 c5             	mov    rbp,rax
	__init_libc(envp, argv[0]);
  417e04:	48 b8 70 65 fb ff ff 	movabs rax,0xfffffffffffb6570
  417e0b:	ff ff ff 
{
  417e0e:	53                   	push   rbx
  417e0f:	48 8d 1d ce ff ff ff 	lea    rbx,[rip+0xffffffffffffffce]        # 417de4 <__libc_start_main+0x4>
  417e16:	4c 01 db             	add    rbx,r11
	__init_libc(envp, argv[0]);
  417e19:	48 01 d8             	add    rax,rbx
{
  417e1c:	48 83 ec 08          	sub    rsp,0x8
	__init_libc(envp, argv[0]);
  417e20:	48 8b 32             	mov    rsi,QWORD PTR [rdx]
  417e23:	ff d0                	call   rax
	return stage2(main, argc, argv);
  417e25:	4c 89 e2             	mov    rdx,r12
  417e28:	89 ee                	mov    esi,ebp
  417e2a:	4c 89 ef             	mov    rdi,r13
	__asm__ ( "" : "+r"(stage2) : : "memory" );
  417e2d:	48 b8 70 69 fb ff ff 	movabs rax,0xfffffffffffb6970
  417e34:	ff ff ff 
  417e37:	48 01 d8             	add    rax,rbx
}
  417e3a:	48 83 c4 08          	add    rsp,0x8
  417e3e:	5b                   	pop    rbx
  417e3f:	5d                   	pop    rbp
  417e40:	41 5c                	pop    r12
  417e42:	41 5d                	pop    r13
	return stage2(main, argc, argv);
  417e44:	ff e0                	jmp    rax
  417e46:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  417e4d:	00 00 00 

0000000000417e50 <__libc_exit_fini>:
weak_alias(dummy, _fini);

extern weak hidden void (*const __fini_array_start)(void), (*const __fini_array_end)(void);

static void libc_exit_fini(void)
{
  417e50:	f3 0f 1e fa          	endbr64 
	uintptr_t a = (uintptr_t)&__fini_array_end;
  417e54:	49 bb bc 95 04 00 00 	movabs r11,0x495bc
  417e5b:	00 00 00 
{
  417e5e:	41 57                	push   r15
  417e60:	4c 8d 3d ed ff ff ff 	lea    r15,[rip+0xffffffffffffffed]        # 417e54 <__libc_exit_fini+0x4>
	uintptr_t a = (uintptr_t)&__fini_array_end;
  417e67:	48 b8 c8 ff ff ff ff 	movabs rax,0xffffffffffffffc8
  417e6e:	ff ff ff 
  417e71:	4d 01 df             	add    r15,r11
{
  417e74:	55                   	push   rbp
  417e75:	53                   	push   rbx
	uintptr_t a = (uintptr_t)&__fini_array_end;
  417e76:	49 8b 1c 07          	mov    rbx,QWORD PTR [r15+rax*1]
	for (; a>(uintptr_t)&__fini_array_start; a-=sizeof(void(*)()))
  417e7a:	48 b8 e0 ff ff ff ff 	movabs rax,0xffffffffffffffe0
  417e81:	ff ff ff 
  417e84:	49 8b 2c 07          	mov    rbp,QWORD PTR [r15+rax*1]
  417e88:	48 39 eb             	cmp    rbx,rbp
  417e8b:	76 10                	jbe    417e9d <__libc_exit_fini+0x4d>
  417e8d:	0f 1f 00             	nop    DWORD PTR [rax]
		(*(void (**)())(a-sizeof(void(*)())))();
  417e90:	48 83 eb 08          	sub    rbx,0x8
  417e94:	31 c0                	xor    eax,eax
  417e96:	ff 13                	call   QWORD PTR [rbx]
	for (; a>(uintptr_t)&__fini_array_start; a-=sizeof(void(*)()))
  417e98:	48 39 eb             	cmp    rbx,rbp
  417e9b:	77 f3                	ja     417e90 <__libc_exit_fini+0x40>
	_fini();
  417e9d:	48 ba 40 65 fb ff ff 	movabs rdx,0xfffffffffffb6540
  417ea4:	ff ff ff 
}
  417ea7:	5b                   	pop    rbx
	_fini();
  417ea8:	31 c0                	xor    eax,eax
}
  417eaa:	5d                   	pop    rbp
	_fini();
  417eab:	4c 01 fa             	add    rdx,r15
}
  417eae:	41 5f                	pop    r15
	_fini();
  417eb0:	ff e2                	jmp    rdx
  417eb2:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  417eb9:	00 00 00 
  417ebc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000417ec0 <exit>:

weak_alias(libc_exit_fini, __libc_exit_fini);

_Noreturn void exit(int code)
{
  417ec0:	f3 0f 1e fa          	endbr64 
	__funcs_on_exit();
  417ec4:	49 bb 4c 95 04 00 00 	movabs r11,0x4954c
  417ecb:	00 00 00 
{
  417ece:	41 57                	push   r15
  417ed0:	4c 8d 3d ed ff ff ff 	lea    r15,[rip+0xffffffffffffffed]        # 417ec4 <exit+0x4>
	__funcs_on_exit();
  417ed7:	48 b8 40 65 fb ff ff 	movabs rax,0xfffffffffffb6540
  417ede:	ff ff ff 
{
  417ee1:	55                   	push   rbp
  417ee2:	4d 01 df             	add    r15,r11
  417ee5:	89 fd                	mov    ebp,edi
	__funcs_on_exit();
  417ee7:	4c 01 f8             	add    rax,r15
{
  417eea:	48 83 ec 08          	sub    rsp,0x8
	__funcs_on_exit();
  417eee:	ff d0                	call   rax
	__libc_exit_fini();
  417ef0:	48 b8 40 6a fb ff ff 	movabs rax,0xfffffffffffb6a40
  417ef7:	ff ff ff 
  417efa:	4c 01 f8             	add    rax,r15
  417efd:	ff d0                	call   rax
	__stdio_exit();
  417eff:	31 c0                	xor    eax,eax
  417f01:	48 ba 90 d2 fb ff ff 	movabs rdx,0xfffffffffffbd290
  417f08:	ff ff ff 
  417f0b:	4c 01 fa             	add    rdx,r15
  417f0e:	ff d2                	call   rdx
	_Exit(code);
  417f10:	89 ef                	mov    edi,ebp
  417f12:	48 b8 e0 77 fb ff ff 	movabs rax,0xfffffffffffb77e0
  417f19:	ff ff ff 
  417f1c:	4c 01 f8             	add    rax,r15
  417f1f:	ff d0                	call   rax
  417f21:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  417f28:	00 00 00 
  417f2b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000417f30 <sn_write>:
};

#define MIN(a, b) ((a) < (b) ? (a) : (b))

static size_t sn_write(FILE *f, const unsigned char *s, size_t l)
{
  417f30:	f3 0f 1e fa          	endbr64 
	struct cookie *c = f->cookie;
  417f34:	49 bb dc 94 04 00 00 	movabs r11,0x494dc
  417f3b:	00 00 00 
{
  417f3e:	41 57                	push   r15
  417f40:	4c 8d 3d ed ff ff ff 	lea    r15,[rip+0xffffffffffffffed]        # 417f34 <sn_write+0x4>
  417f47:	41 56                	push   r14
  417f49:	49 89 f6             	mov    r14,rsi
  417f4c:	4d 01 df             	add    r15,r11
  417f4f:	41 55                	push   r13
  417f51:	41 54                	push   r12
  417f53:	49 89 d4             	mov    r12,rdx
  417f56:	55                   	push   rbp
  417f57:	48 89 fd             	mov    rbp,rdi
  417f5a:	53                   	push   rbx
  417f5b:	48 83 ec 08          	sub    rsp,0x8
	struct cookie *c = f->cookie;
  417f5f:	4c 8b af 98 00 00 00 	mov    r13,QWORD PTR [rdi+0x98]
	size_t k = MIN(c->n, f->wpos - f->wbase);
  417f66:	48 8b 77 38          	mov    rsi,QWORD PTR [rdi+0x38]
  417f6a:	48 8b 57 28          	mov    rdx,QWORD PTR [rdi+0x28]
  417f6e:	49 8b 45 08          	mov    rax,QWORD PTR [r13+0x8]
	if (k) {
		memcpy(c->s, f->wbase, k);
  417f72:	49 8b 7d 00          	mov    rdi,QWORD PTR [r13+0x0]
	size_t k = MIN(c->n, f->wpos - f->wbase);
  417f76:	48 29 f2             	sub    rdx,rsi
  417f79:	48 39 c2             	cmp    rdx,rax
  417f7c:	48 89 d3             	mov    rbx,rdx
  417f7f:	48 0f 47 d8          	cmova  rbx,rax
	if (k) {
  417f83:	48 85 db             	test   rbx,rbx
  417f86:	75 38                	jne    417fc0 <sn_write+0x90>
		c->s += k;
		c->n -= k;
	}
	k = MIN(c->n, l);
  417f88:	49 39 c4             	cmp    r12,rax
  417f8b:	49 0f 46 c4          	cmovbe rax,r12
  417f8f:	48 89 c3             	mov    rbx,rax
	if (k) {
  417f92:	48 85 c0             	test   rax,rax
  417f95:	75 60                	jne    417ff7 <sn_write+0xc7>
		memcpy(c->s, s, k);
		c->s += k;
		c->n -= k;
	}
	*c->s = 0;
  417f97:	c6 07 00             	mov    BYTE PTR [rdi],0x0
	f->wpos = f->wbase = f->buf;
  417f9a:	48 8b 45 58          	mov    rax,QWORD PTR [rbp+0x58]
  417f9e:	48 89 45 38          	mov    QWORD PTR [rbp+0x38],rax
  417fa2:	48 89 45 28          	mov    QWORD PTR [rbp+0x28],rax
	/* pretend to succeed, even if we discarded extra data */
	return l;
}
  417fa6:	48 83 c4 08          	add    rsp,0x8
  417faa:	4c 89 e0             	mov    rax,r12
  417fad:	5b                   	pop    rbx
  417fae:	5d                   	pop    rbp
  417faf:	41 5c                	pop    r12
  417fb1:	41 5d                	pop    r13
  417fb3:	41 5e                	pop    r14
  417fb5:	41 5f                	pop    r15
  417fb7:	c3                   	ret    
  417fb8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  417fbf:	00 
		memcpy(c->s, f->wbase, k);
  417fc0:	48 b8 0a 64 fb ff ff 	movabs rax,0xfffffffffffb640a
  417fc7:	ff ff ff 
  417fca:	48 89 da             	mov    rdx,rbx
  417fcd:	4c 01 f8             	add    rax,r15
  417fd0:	ff d0                	call   rax
		c->n -= k;
  417fd2:	49 8b 45 08          	mov    rax,QWORD PTR [r13+0x8]
		c->s += k;
  417fd6:	49 8b 7d 00          	mov    rdi,QWORD PTR [r13+0x0]
		c->n -= k;
  417fda:	48 29 d8             	sub    rax,rbx
		c->s += k;
  417fdd:	48 01 df             	add    rdi,rbx
	k = MIN(c->n, l);
  417fe0:	49 39 c4             	cmp    r12,rax
		c->n -= k;
  417fe3:	49 89 45 08          	mov    QWORD PTR [r13+0x8],rax
	k = MIN(c->n, l);
  417fe7:	49 0f 46 c4          	cmovbe rax,r12
		c->s += k;
  417feb:	49 89 7d 00          	mov    QWORD PTR [r13+0x0],rdi
	k = MIN(c->n, l);
  417fef:	48 89 c3             	mov    rbx,rax
	if (k) {
  417ff2:	48 85 c0             	test   rax,rax
  417ff5:	74 a0                	je     417f97 <sn_write+0x67>
		memcpy(c->s, s, k);
  417ff7:	48 89 c2             	mov    rdx,rax
  417ffa:	4c 89 f6             	mov    rsi,r14
  417ffd:	48 b8 0a 64 fb ff ff 	movabs rax,0xfffffffffffb640a
  418004:	ff ff ff 
  418007:	4c 01 f8             	add    rax,r15
  41800a:	ff d0                	call   rax
		c->s += k;
  41800c:	49 8b 7d 00          	mov    rdi,QWORD PTR [r13+0x0]
		c->n -= k;
  418010:	49 29 5d 08          	sub    QWORD PTR [r13+0x8],rbx
		c->s += k;
  418014:	48 01 df             	add    rdi,rbx
  418017:	49 89 7d 00          	mov    QWORD PTR [r13+0x0],rdi
		c->n -= k;
  41801b:	e9 77 ff ff ff       	jmp    417f97 <sn_write+0x67>

0000000000418020 <vsnprintf>:

int vsnprintf(char *restrict s, size_t n, const char *restrict fmt, va_list ap)
{
  418020:	f3 0f 1e fa          	endbr64 
	unsigned char buf[1];
	char dummy[1];
	struct cookie c = { .s = n ? s : dummy, .n = n ? n-1 : 0 };
  418024:	49 bb ec 93 04 00 00 	movabs r11,0x493ec
  41802b:	00 00 00 
{
  41802e:	41 57                	push   r15
  418030:	49 89 f2             	mov    r10,rsi
  418033:	4c 8d 3d ea ff ff ff 	lea    r15,[rip+0xffffffffffffffea]        # 418024 <vsnprintf+0x4>
  41803a:	48 89 d6             	mov    rsi,rdx
  41803d:	4d 01 df             	add    r15,r11
  418040:	48 89 ca             	mov    rdx,rcx
  418043:	48 81 ec 10 01 00 00 	sub    rsp,0x110
	struct cookie c = { .s = n ? s : dummy, .n = n ? n-1 : 0 };
  41804a:	4d 85 d2             	test   r10,r10
  41804d:	0f 85 8d 00 00 00    	jne    4180e0 <vsnprintf+0xc0>
	FILE f = {
  418053:	4c 8d 4c 24 20       	lea    r9,[rsp+0x20]
  418058:	4c 89 d0             	mov    rax,r10
  41805b:	b9 1d 00 00 00       	mov    ecx,0x1d
	struct cookie c = { .s = n ? s : dummy, .n = n ? n-1 : 0 };
  418060:	48 c7 44 24 18 00 00 	mov    QWORD PTR [rsp+0x18],0x0
  418067:	00 00 
	FILE f = {
  418069:	4c 89 cf             	mov    rdi,r9
	struct cookie c = { .s = n ? s : dummy, .n = n ? n-1 : 0 };
  41806c:	4c 8d 44 24 0f       	lea    r8,[rsp+0xf]
	FILE f = {
  418071:	f3 48 ab             	rep stos QWORD PTR es:[rdi],rax
	struct cookie c = { .s = n ? s : dummy, .n = n ? n-1 : 0 };
  418074:	4c 89 44 24 10       	mov    QWORD PTR [rsp+0x10],r8
	FILE f = {
  418079:	48 b8 20 6b fb ff ff 	movabs rax,0xfffffffffffb6b20
  418080:	ff ff ff 
  418083:	c7 84 24 ac 00 00 00 	mov    DWORD PTR [rsp+0xac],0xffffffff
  41808a:	ff ff ff ff 
  41808e:	4c 01 f8             	add    rax,r15
  418091:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  418096:	48 8d 44 24 0e       	lea    rax,[rsp+0xe]
  41809b:	48 89 44 24 78       	mov    QWORD PTR [rsp+0x78],rax
  4180a0:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  4180a5:	c7 84 24 b0 00 00 00 	mov    DWORD PTR [rsp+0xb0],0xffffffff
  4180ac:	ff ff ff ff 
  4180b0:	48 89 84 24 b8 00 00 	mov    QWORD PTR [rsp+0xb8],rax
  4180b7:	00 
		errno = EOVERFLOW;
		return -1;
	}

	*c.s = 0;
	return vfprintf(&f, fmt, ap);
  4180b8:	48 b8 30 c5 fb ff ff 	movabs rax,0xfffffffffffbc530
  4180bf:	ff ff ff 
	*c.s = 0;
  4180c2:	41 c6 00 00          	mov    BYTE PTR [r8],0x0
	return vfprintf(&f, fmt, ap);
  4180c6:	4c 89 cf             	mov    rdi,r9
  4180c9:	4c 01 f8             	add    rax,r15
  4180cc:	ff d0                	call   rax
}
  4180ce:	48 81 c4 10 01 00 00 	add    rsp,0x110
  4180d5:	41 5f                	pop    r15
  4180d7:	c3                   	ret    
  4180d8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4180df:	00 
	struct cookie c = { .s = n ? s : dummy, .n = n ? n-1 : 0 };
  4180e0:	49 8d 42 ff          	lea    rax,[r10-0x1]
	FILE f = {
  4180e4:	4c 8d 4c 24 20       	lea    r9,[rsp+0x20]
	struct cookie c = { .s = n ? s : dummy, .n = n ? n-1 : 0 };
  4180e9:	48 89 7c 24 10       	mov    QWORD PTR [rsp+0x10],rdi
  4180ee:	49 89 f8             	mov    r8,rdi
  4180f1:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
	FILE f = {
  4180f6:	b9 1d 00 00 00       	mov    ecx,0x1d
  4180fb:	31 c0                	xor    eax,eax
  4180fd:	4c 89 cf             	mov    rdi,r9
  418100:	f3 48 ab             	rep stos QWORD PTR es:[rdi],rax
  418103:	48 b8 20 6b fb ff ff 	movabs rax,0xfffffffffffb6b20
  41810a:	ff ff ff 
  41810d:	c7 84 24 ac 00 00 00 	mov    DWORD PTR [rsp+0xac],0xffffffff
  418114:	ff ff ff ff 
  418118:	c7 84 24 b0 00 00 00 	mov    DWORD PTR [rsp+0xb0],0xffffffff
  41811f:	ff ff ff ff 
  418123:	4c 01 f8             	add    rax,r15
  418126:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  41812b:	48 8d 44 24 0e       	lea    rax,[rsp+0xe]
  418130:	48 89 44 24 78       	mov    QWORD PTR [rsp+0x78],rax
  418135:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  41813a:	48 89 84 24 b8 00 00 	mov    QWORD PTR [rsp+0xb8],rax
  418141:	00 
	if (n > INT_MAX) {
  418142:	49 81 fa ff ff ff 7f 	cmp    r10,0x7fffffff
  418149:	0f 86 69 ff ff ff    	jbe    4180b8 <vsnprintf+0x98>
		errno = EOVERFLOW;
  41814f:	48 b8 b0 77 fb ff ff 	movabs rax,0xfffffffffffb77b0
  418156:	ff ff ff 
  418159:	4c 01 f8             	add    rax,r15
  41815c:	ff d0                	call   rax
  41815e:	c7 00 4b 00 00 00    	mov    DWORD PTR [rax],0x4b
		return -1;
  418164:	b8 ff ff ff ff       	mov    eax,0xffffffff
  418169:	e9 60 ff ff ff       	jmp    4180ce <vsnprintf+0xae>
  41816e:	66 90                	xchg   ax,ax

0000000000418170 <atoi>:
#include <stdlib.h>
#include <ctype.h>

int atoi(const char *s)
{
  418170:	f3 0f 1e fa          	endbr64 
	int n=0, neg=0;
	while (isspace(*s)) s++;
  418174:	eb 0e                	jmp    418184 <atoi+0x14>
  418176:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41817d:	00 00 00 
  418180:	48 83 c7 01          	add    rdi,0x1
  418184:	0f be 07             	movsx  eax,BYTE PTR [rdi]
int   toupper(int);

#ifndef __cplusplus
static __inline int __isspace(int _c)
{
	return _c == ' ' || (unsigned)_c-'\t' < 5;
  418187:	8d 48 f7             	lea    ecx,[rax-0x9]
  41818a:	89 c2                	mov    edx,eax
  41818c:	83 f9 04             	cmp    ecx,0x4
  41818f:	76 ef                	jbe    418180 <atoi+0x10>
  418191:	80 fa 20             	cmp    dl,0x20
  418194:	74 ea                	je     418180 <atoi+0x10>
	switch (*s) {
  418196:	80 fa 2b             	cmp    dl,0x2b
  418199:	74 4d                	je     4181e8 <atoi+0x78>
  41819b:	80 fa 2d             	cmp    dl,0x2d
  41819e:	74 68                	je     418208 <atoi+0x98>
	case '-': neg=1;
	case '+': s++;
	}
	/* Compute n as a negative number to avoid overflow on INT_MIN */
	while (isdigit(*s))
  4181a0:	8d 50 d0             	lea    edx,[rax-0x30]
  4181a3:	48 89 f9             	mov    rcx,rdi
	int n=0, neg=0;
  4181a6:	45 31 c9             	xor    r9d,r9d
	while (isdigit(*s))
  4181a9:	83 fa 09             	cmp    edx,0x9
  4181ac:	77 4d                	ja     4181fb <atoi+0x8b>
	int n=0, neg=0;
  4181ae:	45 31 c0             	xor    r8d,r8d
  4181b1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		n = 10*n - (*s++ - '0');
  4181b8:	48 83 c1 01          	add    rcx,0x1
  4181bc:	43 8d 14 80          	lea    edx,[r8+r8*4]
  4181c0:	8d 70 d0             	lea    esi,[rax-0x30]
	while (isdigit(*s))
  4181c3:	0f be 01             	movsx  eax,BYTE PTR [rcx]
		n = 10*n - (*s++ - '0');
  4181c6:	01 d2                	add    edx,edx
  4181c8:	41 89 d0             	mov    r8d,edx
	while (isdigit(*s))
  4181cb:	8d 78 d0             	lea    edi,[rax-0x30]
		n = 10*n - (*s++ - '0');
  4181ce:	41 29 f0             	sub    r8d,esi
	while (isdigit(*s))
  4181d1:	83 ff 09             	cmp    edi,0x9
  4181d4:	76 e2                	jbe    4181b8 <atoi+0x48>
	return neg ? n : -n;
  4181d6:	29 d6                	sub    esi,edx
  4181d8:	45 85 c9             	test   r9d,r9d
  4181db:	44 0f 44 c6          	cmove  r8d,esi
}
  4181df:	44 89 c0             	mov    eax,r8d
  4181e2:	c3                   	ret    
  4181e3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	while (isdigit(*s))
  4181e8:	0f be 47 01          	movsx  eax,BYTE PTR [rdi+0x1]
	case '+': s++;
  4181ec:	48 8d 4f 01          	lea    rcx,[rdi+0x1]
	int n=0, neg=0;
  4181f0:	45 31 c9             	xor    r9d,r9d
	while (isdigit(*s))
  4181f3:	8d 50 d0             	lea    edx,[rax-0x30]
  4181f6:	83 fa 09             	cmp    edx,0x9
  4181f9:	76 b3                	jbe    4181ae <atoi+0x3e>
  4181fb:	45 31 c0             	xor    r8d,r8d
}
  4181fe:	44 89 c0             	mov    eax,r8d
  418201:	c3                   	ret    
  418202:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	while (isdigit(*s))
  418208:	0f be 47 01          	movsx  eax,BYTE PTR [rdi+0x1]
	case '+': s++;
  41820c:	48 8d 4f 01          	lea    rcx,[rdi+0x1]
	while (isdigit(*s))
  418210:	8d 50 d0             	lea    edx,[rax-0x30]
  418213:	83 fa 09             	cmp    edx,0x9
  418216:	77 e3                	ja     4181fb <atoi+0x8b>
	case '-': neg=1;
  418218:	41 b9 01 00 00 00    	mov    r9d,0x1
  41821e:	eb 8e                	jmp    4181ae <atoi+0x3e>

0000000000418220 <atol>:
#include <stdlib.h>
#include <ctype.h>

long atol(const char *s)
{
  418220:	f3 0f 1e fa          	endbr64 
	long n=0;
	int neg=0;
	while (isspace(*s)) s++;
  418224:	eb 0e                	jmp    418234 <atol+0x14>
  418226:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41822d:	00 00 00 
  418230:	48 83 c7 01          	add    rdi,0x1
  418234:	0f be 07             	movsx  eax,BYTE PTR [rdi]
  418237:	8d 48 f7             	lea    ecx,[rax-0x9]
  41823a:	89 c2                	mov    edx,eax
  41823c:	83 f9 04             	cmp    ecx,0x4
  41823f:	76 ef                	jbe    418230 <atol+0x10>
  418241:	80 fa 20             	cmp    dl,0x20
  418244:	74 ea                	je     418230 <atol+0x10>
	switch (*s) {
  418246:	80 fa 2b             	cmp    dl,0x2b
  418249:	74 55                	je     4182a0 <atol+0x80>
  41824b:	80 fa 2d             	cmp    dl,0x2d
  41824e:	74 70                	je     4182c0 <atol+0xa0>
	case '-': neg=1;
	case '+': s++;
	}
	/* Compute n as a negative number to avoid overflow on LONG_MIN */
	while (isdigit(*s))
  418250:	8d 50 d0             	lea    edx,[rax-0x30]
  418253:	48 89 f9             	mov    rcx,rdi
	int neg=0;
  418256:	45 31 c9             	xor    r9d,r9d
	while (isdigit(*s))
  418259:	83 fa 09             	cmp    edx,0x9
  41825c:	77 55                	ja     4182b3 <atol+0x93>
	int neg=0;
  41825e:	45 31 c0             	xor    r8d,r8d
  418261:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		n = 10*n - (*s++ - '0');
  418268:	83 e8 30             	sub    eax,0x30
  41826b:	48 83 c1 01          	add    rcx,0x1
  41826f:	4b 8d 14 80          	lea    rdx,[r8+r8*4]
  418273:	48 63 f0             	movsxd rsi,eax
	while (isdigit(*s))
  418276:	0f be 01             	movsx  eax,BYTE PTR [rcx]
		n = 10*n - (*s++ - '0');
  418279:	48 01 d2             	add    rdx,rdx
  41827c:	49 89 d0             	mov    r8,rdx
	while (isdigit(*s))
  41827f:	8d 78 d0             	lea    edi,[rax-0x30]
		n = 10*n - (*s++ - '0');
  418282:	49 29 f0             	sub    r8,rsi
	while (isdigit(*s))
  418285:	83 ff 09             	cmp    edi,0x9
  418288:	76 de                	jbe    418268 <atol+0x48>
	return neg ? n : -n;
  41828a:	48 29 d6             	sub    rsi,rdx
  41828d:	45 85 c9             	test   r9d,r9d
  418290:	4c 0f 44 c6          	cmove  r8,rsi
}
  418294:	4c 89 c0             	mov    rax,r8
  418297:	c3                   	ret    
  418298:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41829f:	00 
	while (isdigit(*s))
  4182a0:	0f be 47 01          	movsx  eax,BYTE PTR [rdi+0x1]
	case '+': s++;
  4182a4:	48 8d 4f 01          	lea    rcx,[rdi+0x1]
	int neg=0;
  4182a8:	45 31 c9             	xor    r9d,r9d
	while (isdigit(*s))
  4182ab:	8d 50 d0             	lea    edx,[rax-0x30]
  4182ae:	83 fa 09             	cmp    edx,0x9
  4182b1:	76 ab                	jbe    41825e <atol+0x3e>
  4182b3:	45 31 c0             	xor    r8d,r8d
}
  4182b6:	4c 89 c0             	mov    rax,r8
  4182b9:	c3                   	ret    
  4182ba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	while (isdigit(*s))
  4182c0:	0f be 47 01          	movsx  eax,BYTE PTR [rdi+0x1]
	case '+': s++;
  4182c4:	48 8d 4f 01          	lea    rcx,[rdi+0x1]
	while (isdigit(*s))
  4182c8:	8d 50 d0             	lea    edx,[rax-0x30]
  4182cb:	83 fa 09             	cmp    edx,0x9
  4182ce:	77 e3                	ja     4182b3 <atol+0x93>
	case '-': neg=1;
  4182d0:	41 b9 01 00 00 00    	mov    r9d,0x1
  4182d6:	eb 86                	jmp    41825e <atol+0x3e>
  4182d8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4182df:	00 

00000000004182e0 <strchr>:
#include <string.h>

char *strchr(const char *s, int c)
{
  4182e0:	f3 0f 1e fa          	endbr64 
	char *r = __strchrnul(s, c);
  4182e4:	49 bb 2c 91 04 00 00 	movabs r11,0x4912c
  4182eb:	00 00 00 
  4182ee:	48 8d 05 ef ff ff ff 	lea    rax,[rip+0xffffffffffffffef]        # 4182e4 <strchr+0x4>
{
  4182f5:	53                   	push   rbx
  4182f6:	89 f3                	mov    ebx,esi
	char *r = __strchrnul(s, c);
  4182f8:	48 ba 10 6f fb ff ff 	movabs rdx,0xfffffffffffb6f10
  4182ff:	ff ff ff 
  418302:	4c 01 d8             	add    rax,r11
  418305:	48 01 d0             	add    rax,rdx
  418308:	ff d0                	call   rax
	return *(unsigned char *)r == (unsigned char)c ? r : 0;
  41830a:	31 d2                	xor    edx,edx
  41830c:	38 18                	cmp    BYTE PTR [rax],bl
}
  41830e:	5b                   	pop    rbx
	return *(unsigned char *)r == (unsigned char)c ? r : 0;
  41830f:	48 0f 45 c2          	cmovne rax,rdx
}
  418313:	c3                   	ret    
  418314:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41831b:	00 00 00 
  41831e:	66 90                	xchg   ax,ax

0000000000418320 <__strchrnul>:
#define ONES ((size_t)-1/UCHAR_MAX)
#define HIGHS (ONES * (UCHAR_MAX/2+1))
#define HASZERO(x) ((x)-ONES & ~(x) & HIGHS)

char *__strchrnul(const char *s, int c)
{
  418320:	f3 0f 1e fa          	endbr64 
  418324:	49 bb ec 90 04 00 00 	movabs r11,0x490ec
  41832b:	00 00 00 
  41832e:	41 57                	push   r15
	c = (unsigned char)c;
	if (!c) return (char *)s + strlen(s);
  418330:	89 f1                	mov    ecx,esi
  418332:	4c 8d 3d eb ff ff ff 	lea    r15,[rip+0xffffffffffffffeb]        # 418324 <__strchrnul+0x4>
{
  418339:	41 54                	push   r12
  41833b:	4d 01 df             	add    r15,r11
  41833e:	49 89 fc             	mov    r12,rdi
  418341:	48 83 ec 08          	sub    rsp,0x8
	if (!c) return (char *)s + strlen(s);
  418345:	81 e1 ff 00 00 00    	and    ecx,0xff
  41834b:	75 24                	jne    418371 <__strchrnul+0x51>
  41834d:	e9 d6 00 00 00       	jmp    418428 <__strchrnul+0x108>
  418352:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

#ifdef __GNUC__
	typedef size_t __attribute__((__may_alias__)) word;
	const word *w;
	for (; (uintptr_t)s % ALIGN; s++)
		if (!*s || *(unsigned char *)s == c) return (char *)s;
  418358:	41 0f b6 04 24       	movzx  eax,BYTE PTR [r12]
  41835d:	84 c0                	test   al,al
  41835f:	0f 84 b4 00 00 00    	je     418419 <__strchrnul+0xf9>
  418365:	39 c8                	cmp    eax,ecx
  418367:	0f 84 ac 00 00 00    	je     418419 <__strchrnul+0xf9>
	for (; (uintptr_t)s % ALIGN; s++)
  41836d:	49 83 c4 01          	add    r12,0x1
  418371:	41 f6 c4 07          	test   r12b,0x7
  418375:	75 e1                	jne    418358 <__strchrnul+0x38>
	size_t k = ONES * c;
  418377:	48 bf 01 01 01 01 01 	movabs rdi,0x101010101010101
  41837e:	01 01 01 
  418381:	4c 63 c1             	movsxd r8,ecx
	for (w = (void *)s; !HASZERO(*w) && !HASZERO(*w^k); w++);
  418384:	49 8b 14 24          	mov    rdx,QWORD PTR [r12]
  418388:	49 b9 80 80 80 80 80 	movabs r9,0x8080808080808080
  41838f:	80 80 80 
	size_t k = ONES * c;
  418392:	4c 0f af c7          	imul   r8,rdi
	for (w = (void *)s; !HASZERO(*w) && !HASZERO(*w^k); w++);
  418396:	48 89 d0             	mov    rax,rdx
  418399:	48 f7 d0             	not    rax
  41839c:	4c 89 c6             	mov    rsi,r8
  41839f:	48 31 d6             	xor    rsi,rdx
  4183a2:	48 29 fa             	sub    rdx,rdi
  4183a5:	48 21 d0             	and    rax,rdx
  4183a8:	48 89 f2             	mov    rdx,rsi
  4183ab:	48 f7 d6             	not    rsi
  4183ae:	48 29 fa             	sub    rdx,rdi
  4183b1:	48 21 f2             	and    rdx,rsi
  4183b4:	48 09 d0             	or     rax,rdx
  4183b7:	4c 85 c8             	test   rax,r9
  4183ba:	75 54                	jne    418410 <__strchrnul+0xf0>
  4183bc:	48 bf ff fe fe fe fe 	movabs rdi,0xfefefefefefefeff
  4183c3:	fe fe fe 
  4183c6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4183cd:	00 00 00 
  4183d0:	49 8b 54 24 08       	mov    rdx,QWORD PTR [r12+0x8]
  4183d5:	49 83 c4 08          	add    r12,0x8
  4183d9:	48 89 d6             	mov    rsi,rdx
  4183dc:	48 8d 04 3a          	lea    rax,[rdx+rdi*1]
  4183e0:	48 f7 d2             	not    rdx
  4183e3:	4c 31 c6             	xor    rsi,r8
  4183e6:	48 21 d0             	and    rax,rdx
  4183e9:	48 8d 14 3e          	lea    rdx,[rsi+rdi*1]
  4183ed:	48 f7 d6             	not    rsi
  4183f0:	48 21 f2             	and    rdx,rsi
  4183f3:	48 09 d0             	or     rax,rdx
  4183f6:	4c 85 c8             	test   rax,r9
  4183f9:	74 d5                	je     4183d0 <__strchrnul+0xb0>
	s = (void *)w;
#endif
	for (; *s && *(unsigned char *)s != c; s++);
  4183fb:	41 0f b6 04 24       	movzx  eax,BYTE PTR [r12]
  418400:	84 c0                	test   al,al
  418402:	74 15                	je     418419 <__strchrnul+0xf9>
  418404:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  418408:	39 c8                	cmp    eax,ecx
  41840a:	74 0d                	je     418419 <__strchrnul+0xf9>
  41840c:	49 83 c4 01          	add    r12,0x1
  418410:	41 0f b6 04 24       	movzx  eax,BYTE PTR [r12]
  418415:	84 c0                	test   al,al
  418417:	75 ef                	jne    418408 <__strchrnul+0xe8>
	return (char *)s;
}
  418419:	48 83 c4 08          	add    rsp,0x8
  41841d:	4c 89 e0             	mov    rax,r12
  418420:	41 5c                	pop    r12
  418422:	41 5f                	pop    r15
  418424:	c3                   	ret    
  418425:	0f 1f 00             	nop    DWORD PTR [rax]
	if (!c) return (char *)s + strlen(s);
  418428:	48 b8 80 70 fb ff ff 	movabs rax,0xfffffffffffb7080
  41842f:	ff ff ff 
  418432:	4c 01 f8             	add    rax,r15
  418435:	ff d0                	call   rax
}
  418437:	48 83 c4 08          	add    rsp,0x8
	if (!c) return (char *)s + strlen(s);
  41843b:	49 01 c4             	add    r12,rax
}
  41843e:	4c 89 e0             	mov    rax,r12
  418441:	41 5c                	pop    r12
  418443:	41 5f                	pop    r15
  418445:	c3                   	ret    
  418446:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41844d:	00 00 00 

0000000000418450 <strcmp>:
#include <string.h>

int strcmp(const char *l, const char *r)
{
  418450:	f3 0f 1e fa          	endbr64 
	for (; *l==*r && *l; l++, r++);
  418454:	0f b6 17             	movzx  edx,BYTE PTR [rdi]
  418457:	0f b6 0e             	movzx  ecx,BYTE PTR [rsi]
  41845a:	b8 01 00 00 00       	mov    eax,0x1
  41845f:	38 d1                	cmp    cl,dl
  418461:	74 16                	je     418479 <strcmp+0x29>
  418463:	eb 23                	jmp    418488 <strcmp+0x38>
  418465:	0f 1f 00             	nop    DWORD PTR [rax]
  418468:	0f b6 14 07          	movzx  edx,BYTE PTR [rdi+rax*1]
  41846c:	48 83 c0 01          	add    rax,0x1
  418470:	0f b6 4c 06 ff       	movzx  ecx,BYTE PTR [rsi+rax*1-0x1]
  418475:	38 ca                	cmp    dl,cl
  418477:	75 0f                	jne    418488 <strcmp+0x38>
  418479:	84 d2                	test   dl,dl
  41847b:	75 eb                	jne    418468 <strcmp+0x18>
  41847d:	31 c0                	xor    eax,eax
	return *(unsigned char *)l - *(unsigned char *)r;
  41847f:	29 c8                	sub    eax,ecx
}
  418481:	c3                   	ret    
  418482:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	return *(unsigned char *)l - *(unsigned char *)r;
  418488:	0f b6 c2             	movzx  eax,dl
  41848b:	29 c8                	sub    eax,ecx
}
  41848d:	c3                   	ret    
  41848e:	66 90                	xchg   ax,ax

0000000000418490 <strlen>:
#define ONES ((size_t)-1/UCHAR_MAX)
#define HIGHS (ONES * (UCHAR_MAX/2+1))
#define HASZERO(x) ((x)-ONES & ~(x) & HIGHS)

size_t strlen(const char *s)
{
  418490:	f3 0f 1e fa          	endbr64 
	const char *a = s;
#ifdef __GNUC__
	typedef size_t __attribute__((__may_alias__)) word;
	const word *w;
	for (; (uintptr_t)s % ALIGN; s++) if (!*s) return s-a;
  418494:	48 89 f8             	mov    rax,rdi
  418497:	40 f6 c7 07          	test   dil,0x7
  41849b:	75 0b                	jne    4184a8 <strlen+0x18>
  41849d:	eb 19                	jmp    4184b8 <strlen+0x28>
  41849f:	90                   	nop
  4184a0:	48 83 c0 01          	add    rax,0x1
  4184a4:	a8 07                	test   al,0x7
  4184a6:	74 10                	je     4184b8 <strlen+0x28>
  4184a8:	80 38 00             	cmp    BYTE PTR [rax],0x0
  4184ab:	75 f3                	jne    4184a0 <strlen+0x10>
	for (w = (const void *)s; !HASZERO(*w); w++);
	s = (const void *)w;
#endif
	for (; *s; s++);
	return s-a;
  4184ad:	48 29 f8             	sub    rax,rdi
}
  4184b0:	c3                   	ret    
  4184b1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (w = (const void *)s; !HASZERO(*w); w++);
  4184b8:	49 b8 ff fe fe fe fe 	movabs r8,0xfefefefefefefeff
  4184bf:	fe fe fe 
  4184c2:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  4184c5:	48 be 80 80 80 80 80 	movabs rsi,0x8080808080808080
  4184cc:	80 80 80 
  4184cf:	4a 8d 0c 02          	lea    rcx,[rdx+r8*1]
  4184d3:	48 f7 d2             	not    rdx
  4184d6:	48 21 ca             	and    rdx,rcx
  4184d9:	48 85 f2             	test   rdx,rsi
  4184dc:	75 26                	jne    418504 <strlen+0x74>
  4184de:	66 90                	xchg   ax,ax
  4184e0:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  4184e4:	48 83 c0 08          	add    rax,0x8
  4184e8:	4a 8d 0c 02          	lea    rcx,[rdx+r8*1]
  4184ec:	48 f7 d2             	not    rdx
  4184ef:	48 21 ca             	and    rdx,rcx
  4184f2:	48 85 f2             	test   rdx,rsi
  4184f5:	74 e9                	je     4184e0 <strlen+0x50>
  4184f7:	eb 0b                	jmp    418504 <strlen+0x74>
  4184f9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (; *s; s++);
  418500:	48 83 c0 01          	add    rax,0x1
  418504:	80 38 00             	cmp    BYTE PTR [rax],0x0
  418507:	75 f7                	jne    418500 <strlen+0x70>
	return s-a;
  418509:	48 29 f8             	sub    rax,rdi
}
  41850c:	c3                   	ret    
  41850d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000418510 <strncmp>:
#include <string.h>

int strncmp(const char *_l, const char *_r, size_t n)
{
  418510:	f3 0f 1e fa          	endbr64 
  418514:	49 89 f9             	mov    r9,rdi
  418517:	49 89 f2             	mov    r10,rsi
	const unsigned char *l=(void *)_l, *r=(void *)_r;
	if (!n--) return 0;
  41851a:	31 c0                	xor    eax,eax
  41851c:	48 85 d2             	test   rdx,rdx
  41851f:	74 60                	je     418581 <strncmp+0x71>
	for (; *l && *r && n && *l == *r ; l++, r++, n--);
  418521:	0f b6 07             	movzx  eax,BYTE PTR [rdi]
  418524:	0f b6 3e             	movzx  edi,BYTE PTR [rsi]
  418527:	84 c0                	test   al,al
  418529:	74 5d                	je     418588 <strncmp+0x78>
  41852b:	48 83 ea 01          	sub    rdx,0x1
  41852f:	40 0f 95 c6          	setne  sil
  418533:	40 84 ff             	test   dil,dil
  418536:	0f 95 c1             	setne  cl
  418539:	40 84 ce             	test   sil,cl
  41853c:	74 41                	je     41857f <strncmp+0x6f>
  41853e:	b9 01 00 00 00       	mov    ecx,0x1
  418543:	40 38 f8             	cmp    al,dil
  418546:	75 37                	jne    41857f <strncmp+0x6f>
  418548:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41854f:	00 
  418550:	41 0f b6 04 09       	movzx  eax,BYTE PTR [r9+rcx*1]
  418555:	41 0f b6 3c 0a       	movzx  edi,BYTE PTR [r10+rcx*1]
  41855a:	84 c0                	test   al,al
  41855c:	74 2a                	je     418588 <strncmp+0x78>
  41855e:	40 84 ff             	test   dil,dil
  418561:	40 0f 95 c6          	setne  sil
  418565:	40 38 f8             	cmp    al,dil
  418568:	41 0f 94 c0          	sete   r8b
  41856c:	44 21 c6             	and    esi,r8d
  41856f:	48 39 ca             	cmp    rdx,rcx
  418572:	41 0f 95 c0          	setne  r8b
  418576:	48 83 c1 01          	add    rcx,0x1
  41857a:	44 84 c6             	test   sil,r8b
  41857d:	75 d1                	jne    418550 <strncmp+0x40>
	return *l - *r;
  41857f:	29 f8                	sub    eax,edi
}
  418581:	c3                   	ret    
  418582:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  418588:	31 c0                	xor    eax,eax
	return *l - *r;
  41858a:	29 f8                	sub    eax,edi
  41858c:	eb f3                	jmp    418581 <strncmp+0x71>
  41858e:	66 90                	xchg   ax,ax

0000000000418590 <strnlen>:
#include <string.h>

size_t strnlen(const char *s, size_t n)
{
  418590:	f3 0f 1e fa          	endbr64 
	const char *p = memchr(s, 0, n);
  418594:	49 bb 7c 8e 04 00 00 	movabs r11,0x48e7c
  41859b:	00 00 00 
{
  41859e:	41 57                	push   r15
  4185a0:	4c 8d 3d ed ff ff ff 	lea    r15,[rip+0xffffffffffffffed]        # 418594 <strnlen+0x4>
	const char *p = memchr(s, 0, n);
  4185a7:	48 89 f2             	mov    rdx,rsi
  4185aa:	48 b8 90 c7 fb ff ff 	movabs rax,0xfffffffffffbc790
  4185b1:	ff ff ff 
  4185b4:	4d 01 df             	add    r15,r11
{
  4185b7:	55                   	push   rbp
  4185b8:	48 89 fd             	mov    rbp,rdi
  4185bb:	53                   	push   rbx
	const char *p = memchr(s, 0, n);
  4185bc:	4c 01 f8             	add    rax,r15
{
  4185bf:	48 89 f3             	mov    rbx,rsi
	const char *p = memchr(s, 0, n);
  4185c2:	31 f6                	xor    esi,esi
  4185c4:	ff d0                	call   rax
	return p ? p-s : n;
  4185c6:	48 89 c2             	mov    rdx,rax
  4185c9:	48 29 ea             	sub    rdx,rbp
  4185cc:	48 85 c0             	test   rax,rax
  4185cf:	48 89 d8             	mov    rax,rbx
}
  4185d2:	5b                   	pop    rbx
	return p ? p-s : n;
  4185d3:	48 0f 45 c2          	cmovne rax,rdx
}
  4185d7:	5d                   	pop    rbp
  4185d8:	41 5f                	pop    r15
  4185da:	c3                   	ret    
  4185db:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000004185e0 <__init_tp>:
#include "syscall.h"

volatile int __thread_list_lock;

int __init_tp(void *p)
{
  4185e0:	f3 0f 1e fa          	endbr64 
  4185e4:	41 57                	push   r15
  4185e6:	66 48 0f 6e c7       	movq   xmm0,rdi
  4185eb:	4c 8d 3d f2 ff ff ff 	lea    r15,[rip+0xfffffffffffffff2]        # 4185e4 <__init_tp+0x4>
  4185f2:	49 bb 2c 8e 04 00 00 	movabs r11,0x48e2c
  4185f9:	00 00 00 
  4185fc:	53                   	push   rbx
  4185fd:	4d 01 df             	add    r15,r11
  418600:	48 89 fb             	mov    rbx,rdi
  418603:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
	pthread_t td = p;
	td->self = td;
	int r = __set_thread_area(TP_ADJ(p));
  418607:	48 b8 00 65 fb ff ff 	movabs rax,0xfffffffffffb6500
  41860e:	ff ff ff 
  418611:	4c 01 f8             	add    rax,r15
{
  418614:	48 83 ec 18          	sub    rsp,0x18
	td->self = td;
  418618:	48 89 3f             	mov    QWORD PTR [rdi],rdi
  41861b:	0f 29 04 24          	movaps XMMWORD PTR [rsp],xmm0
	int r = __set_thread_area(TP_ADJ(p));
  41861f:	ff d0                	call   rax
	if (r < 0) return -1;
  418621:	85 c0                	test   eax,eax
  418623:	0f 88 a6 00 00 00    	js     4186cf <__init_tp+0xef>
	if (!r) libc.can_do_threads = 1;
  418629:	0f 84 89 00 00 00    	je     4186b8 <__init_tp+0xd8>
	return __cos_syscall(n, a1, 0, 0, 0, 0, 0, 0);
  41862f:	48 b8 58 4e 14 00 00 	movabs rax,0x144e58
  418636:	00 00 00 
  418639:	6a 00                	push   0x0
  41863b:	31 d2                	xor    edx,edx
  41863d:	31 c9                	xor    ecx,ecx
  41863f:	49 8d 34 07          	lea    rsi,[r15+rax*1]
  418643:	6a 00                	push   0x0
  418645:	45 31 c9             	xor    r9d,r9d
  418648:	45 31 c0             	xor    r8d,r8d
  41864b:	48 b8 50 a1 fa ff ff 	movabs rax,0xfffffffffffaa150
  418652:	ff ff ff 
	td->detach_state = DT_JOINABLE;
  418655:	c7 43 40 01 00 00 00 	mov    DWORD PTR [rbx+0x40],0x1
  41865c:	bf da 00 00 00       	mov    edi,0xda
  418661:	4c 01 f8             	add    rax,r15
  418664:	ff d0                	call   rax
	td->tid = __syscall(SYS_set_tid_address, &__thread_list_lock);
	td->locale = &libc.global_locale;
	td->robust_list.head = &td->robust_list.head;
	td->sysinfo = __sysinfo;
	td->next = td->prev = td;
  418666:	66 0f 6f 4c 24 10    	movdqa xmm1,XMMWORD PTR [rsp+0x10]
	td->tid = __syscall(SYS_set_tid_address, &__thread_list_lock);
  41866c:	89 43 38             	mov    DWORD PTR [rbx+0x38],eax
	td->locale = &libc.global_locale;
  41866f:	48 b8 70 4c 14 00 00 	movabs rax,0x144c70
  418676:	00 00 00 
  418679:	4c 01 f8             	add    rax,r15
	td->next = td->prev = td;
  41867c:	0f 11 4b 10          	movups XMMWORD PTR [rbx+0x10],xmm1
	td->locale = &libc.global_locale;
  418680:	48 89 83 b0 00 00 00 	mov    QWORD PTR [rbx+0xb0],rax
	td->robust_list.head = &td->robust_list.head;
  418687:	48 8d 83 90 00 00 00 	lea    rax,[rbx+0x90]
  41868e:	48 89 83 90 00 00 00 	mov    QWORD PTR [rbx+0x90],rax
	td->sysinfo = __sysinfo;
  418695:	48 b8 10 4c 14 00 00 	movabs rax,0x144c10
  41869c:	00 00 00 
  41869f:	49 8b 04 07          	mov    rax,QWORD PTR [r15+rax*1]
  4186a3:	48 89 43 20          	mov    QWORD PTR [rbx+0x20],rax
	return 0;
  4186a7:	58                   	pop    rax
  4186a8:	31 c0                	xor    eax,eax
  4186aa:	5a                   	pop    rdx
}
  4186ab:	48 83 c4 18          	add    rsp,0x18
  4186af:	5b                   	pop    rbx
  4186b0:	41 5f                	pop    r15
  4186b2:	c3                   	ret    
  4186b3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	if (!r) libc.can_do_threads = 1;
  4186b8:	48 b8 30 4c 14 00 00 	movabs rax,0x144c30
  4186bf:	00 00 00 
  4186c2:	41 c7 04 07 01 00 00 	mov    DWORD PTR [r15+rax*1],0x1
  4186c9:	00 
  4186ca:	e9 60 ff ff ff       	jmp    41862f <__init_tp+0x4f>
	if (r < 0) return -1;
  4186cf:	b8 ff ff ff ff       	mov    eax,0xffffffff
  4186d4:	eb d5                	jmp    4186ab <__init_tp+0xcb>
  4186d6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4186dd:	00 00 00 

00000000004186e0 <__copy_tls>:
#define MIN_TLS_ALIGN offsetof(struct builtin_tls, pt)

static struct tls_module main_tls;

void *__copy_tls(unsigned char *mem)
{
  4186e0:	f3 0f 1e fa          	endbr64 
  4186e4:	49 bb 2c 8d 04 00 00 	movabs r11,0x48d2c
  4186eb:	00 00 00 
  4186ee:	41 57                	push   r15
  4186f0:	4c 8d 3d ed ff ff ff 	lea    r15,[rip+0xffffffffffffffed]        # 4186e4 <__copy_tls+0x4>
  4186f7:	41 56                	push   r14
  4186f9:	4d 01 df             	add    r15,r11
		memcpy(mem + p->offset, p->image, p->len);
	}
#else
	dtv = (uintptr_t *)mem;

	mem += libc.tls_size - sizeof(struct pthread);
  4186fc:	49 be 30 4c 14 00 00 	movabs r14,0x144c30
  418703:	00 00 00 
{
  418706:	41 55                	push   r13
  418708:	41 54                	push   r12
  41870a:	55                   	push   rbp
  41870b:	53                   	push   rbx
  41870c:	48 83 ec 18          	sub    rsp,0x18
	mem += libc.tls_size - sizeof(struct pthread);
  418710:	4b 8b 44 3e 20       	mov    rax,QWORD PTR [r14+r15*1+0x20]
	mem -= (uintptr_t)mem & (libc.tls_align-1);
  418715:	4f 8b 44 3e 28       	mov    r8,QWORD PTR [r14+r15*1+0x28]
	td = (pthread_t)mem;

	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
  41871a:	4b 8b 5c 3e 18       	mov    rbx,QWORD PTR [r14+r15*1+0x18]
{
  41871f:	48 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],rdi
	mem += libc.tls_size - sizeof(struct pthread);
  418724:	48 8d 84 07 20 ff ff 	lea    rax,[rdi+rax*1-0xe0]
  41872b:	ff 
	mem -= (uintptr_t)mem & (libc.tls_align-1);
  41872c:	49 f7 d8             	neg    r8
  41872f:	49 21 c0             	and    r8,rax
  418732:	4d 89 c5             	mov    r13,r8
	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
  418735:	48 85 db             	test   rbx,rbx
  418738:	74 3f                	je     418779 <__copy_tls+0x99>
  41873a:	49 bc 0a 64 fb ff ff 	movabs r12,0xfffffffffffb640a
  418741:	ff ff ff 
  418744:	48 8d 6f 08          	lea    rbp,[rdi+0x8]
		dtv[i] = (uintptr_t)(mem - p->offset) + DTP_OFFSET;
		memcpy(mem - p->offset, p->image, p->len);
  418748:	4d 01 fc             	add    r12,r15
  41874b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		dtv[i] = (uintptr_t)(mem - p->offset) + DTP_OFFSET;
  418750:	4c 89 e8             	mov    rax,r13
  418753:	48 2b 43 28          	sub    rax,QWORD PTR [rbx+0x28]
		memcpy(mem - p->offset, p->image, p->len);
  418757:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
  41875b:	4c 89 ef             	mov    rdi,r13
		dtv[i] = (uintptr_t)(mem - p->offset) + DTP_OFFSET;
  41875e:	48 89 45 00          	mov    QWORD PTR [rbp+0x0],rax
		memcpy(mem - p->offset, p->image, p->len);
  418762:	48 8b 53 10          	mov    rdx,QWORD PTR [rbx+0x10]
	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
  418766:	48 83 c5 08          	add    rbp,0x8
		memcpy(mem - p->offset, p->image, p->len);
  41876a:	48 2b 7b 28          	sub    rdi,QWORD PTR [rbx+0x28]
  41876e:	41 ff d4             	call   r12
	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
  418771:	48 8b 1b             	mov    rbx,QWORD PTR [rbx]
  418774:	48 85 db             	test   rbx,rbx
  418777:	75 d7                	jne    418750 <__copy_tls+0x70>
	}
#endif
	dtv[0] = libc.tls_cnt;
  418779:	4b 8b 44 3e 30       	mov    rax,QWORD PTR [r14+r15*1+0x30]
  41877e:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
  418783:	48 89 01             	mov    QWORD PTR [rcx],rax
	td->dtv = td->dtv_copy = dtv;
	return td;
}
  418786:	4c 89 e8             	mov    rax,r13
	td->dtv = td->dtv_copy = dtv;
  418789:	49 89 8d d8 00 00 00 	mov    QWORD PTR [r13+0xd8],rcx
  418790:	49 89 4d 08          	mov    QWORD PTR [r13+0x8],rcx
}
  418794:	48 83 c4 18          	add    rsp,0x18
  418798:	5b                   	pop    rbx
  418799:	5d                   	pop    rbp
  41879a:	41 5c                	pop    r12
  41879c:	41 5d                	pop    r13
  41879e:	41 5e                	pop    r14
  4187a0:	41 5f                	pop    r15
  4187a2:	c3                   	ret    
  4187a3:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4187aa:	00 00 00 
  4187ad:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004187b0 <__init_tls>:
#endif

extern weak hidden const size_t _DYNAMIC[];

static void static_init_tls(size_t *aux)
{
  4187b0:	f3 0f 1e fa          	endbr64 
	size_t n;
	Phdr *phdr, *tls_phdr=0;
	size_t base = 0;
	void *mem;

	for (p=(void *)aux[AT_PHDR],n=aux[AT_PHNUM]; n; n--,p+=aux[AT_PHENT]) {
  4187b4:	49 bb 5c 8c 04 00 00 	movabs r11,0x48c5c
  4187bb:	00 00 00 
{
  4187be:	41 57                	push   r15
  4187c0:	4c 8d 3d ed ff ff ff 	lea    r15,[rip+0xffffffffffffffed]        # 4187b4 <__init_tls+0x4>
  4187c7:	41 56                	push   r14
  4187c9:	4d 01 df             	add    r15,r11
  4187cc:	41 55                	push   r13
  4187ce:	41 54                	push   r12
  4187d0:	55                   	push   rbp
  4187d1:	53                   	push   rbx
  4187d2:	48 83 ec 38          	sub    rsp,0x38
	for (p=(void *)aux[AT_PHDR],n=aux[AT_PHNUM]; n; n--,p+=aux[AT_PHENT]) {
  4187d6:	4c 8b 47 28          	mov    r8,QWORD PTR [rdi+0x28]
  4187da:	4c 8b 5f 18          	mov    r11,QWORD PTR [rdi+0x18]
  4187de:	4d 85 c0             	test   r8,r8
  4187e1:	0f 84 a9 03 00 00    	je     418b90 <__init_tls+0x3e0>
  4187e7:	31 ed                	xor    ebp,ebp
	size_t base = 0;
  4187e9:	31 d2                	xor    edx,edx
	Phdr *phdr, *tls_phdr=0;
  4187eb:	45 31 d2             	xor    r10d,r10d
	for (p=(void *)aux[AT_PHDR],n=aux[AT_PHNUM]; n; n--,p+=aux[AT_PHENT]) {
  4187ee:	48 8b 7f 20          	mov    rdi,QWORD PTR [rdi+0x20]
  4187f2:	49 bc c0 ff ff ff ff 	movabs r12,0xffffffffffffffc0
  4187f9:	ff ff ff 
  4187fc:	4c 89 d8             	mov    rax,r11
  4187ff:	48 bb b8 ec ff ff ff 	movabs rbx,0xffffffffffffecb8
  418806:	ff ff ff 
  418809:	4b 83 3c 3c 00       	cmp    QWORD PTR [r12+r15*1],0x0
  41880e:	46 8b 0c 3b          	mov    r9d,DWORD PTR [rbx+r15*1]
  418812:	75 2a                	jne    41883e <__init_tls+0x8e>
  418814:	e9 61 02 00 00       	jmp    418a7a <__init_tls+0x2ca>
  418819:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		phdr = (void *)p;
		if (phdr->p_type == PT_PHDR)
			base = aux[AT_PHDR] - phdr->p_vaddr;
		if (phdr->p_type == PT_DYNAMIC && _DYNAMIC)
  418820:	83 f9 02             	cmp    ecx,0x2
  418823:	0f 84 97 02 00 00    	je     418ac0 <__init_tls+0x310>
			base = (size_t)_DYNAMIC - phdr->p_vaddr;
		if (phdr->p_type == PT_TLS)
  418829:	83 f9 07             	cmp    ecx,0x7
  41882c:	0f 85 58 02 00 00    	jne    418a8a <__init_tls+0x2da>
  418832:	49 89 c2             	mov    r10,rax
	for (p=(void *)aux[AT_PHDR],n=aux[AT_PHNUM]; n; n--,p+=aux[AT_PHENT]) {
  418835:	48 01 f8             	add    rax,rdi
  418838:	49 83 e8 01          	sub    r8,0x1
  41883c:	74 17                	je     418855 <__init_tls+0xa5>
		if (phdr->p_type == PT_PHDR)
  41883e:	8b 08                	mov    ecx,DWORD PTR [rax]
  418840:	83 f9 06             	cmp    ecx,0x6
  418843:	75 db                	jne    418820 <__init_tls+0x70>
			base = aux[AT_PHDR] - phdr->p_vaddr;
  418845:	4c 89 da             	mov    rdx,r11
  418848:	48 2b 50 10          	sub    rdx,QWORD PTR [rax+0x10]
	for (p=(void *)aux[AT_PHDR],n=aux[AT_PHNUM]; n; n--,p+=aux[AT_PHENT]) {
  41884c:	48 01 f8             	add    rax,rdi
  41884f:	49 83 e8 01          	sub    r8,0x1
  418853:	75 e9                	jne    41883e <__init_tls+0x8e>
  418855:	40 84 ed             	test   bpl,bpl
  418858:	74 04                	je     41885e <__init_tls+0xae>
  41885a:	46 89 0c 3b          	mov    DWORD PTR [rbx+r15*1],r9d
			__default_stacksize =
				phdr->p_memsz < DEFAULT_STACK_MAX ?
				phdr->p_memsz : DEFAULT_STACK_MAX;
	}

	if (tls_phdr) {
  41885e:	4d 85 d2             	test   r10,r10
  418861:	0f 84 29 03 00 00    	je     418b90 <__init_tls+0x3e0>
		main_tls.image = (void *)(base + tls_phdr->p_vaddr);
  418867:	48 b8 b0 4c 14 00 00 	movabs rax,0x144cb0
  41886e:	00 00 00 
		main_tls.len = tls_phdr->p_filesz;
		main_tls.size = tls_phdr->p_memsz;
		main_tls.align = tls_phdr->p_align;
  418871:	49 8b 72 30          	mov    rsi,QWORD PTR [r10+0x30]
		main_tls.image = (void *)(base + tls_phdr->p_vaddr);
  418875:	49 03 52 10          	add    rdx,QWORD PTR [r10+0x10]
		libc.tls_cnt = 1;
  418879:	49 bd 30 4c 14 00 00 	movabs r13,0x144c30
  418880:	00 00 00 
		libc.tls_head = &main_tls;
  418883:	4a 8d 0c 38          	lea    rcx,[rax+r15*1]
		main_tls.len = tls_phdr->p_filesz;
  418887:	f3 41 0f 6f 72 20    	movdqu xmm6,XMMWORD PTR [r10+0x20]
		main_tls.size = tls_phdr->p_memsz;
  41888d:	49 8b 7a 28          	mov    rdi,QWORD PTR [r10+0x28]
		main_tls.image = (void *)(base + tls_phdr->p_vaddr);
  418891:	4a 89 54 38 08       	mov    QWORD PTR [rax+r15*1+0x8],rdx
		main_tls.align = tls_phdr->p_align;
  418896:	4a 89 74 38 20       	mov    QWORD PTR [rax+r15*1+0x20],rsi
		libc.tls_cnt = 1;
  41889b:	4b c7 44 3d 30 01 00 	mov    QWORD PTR [r13+r15*1+0x30],0x1
  4188a2:	00 00 
		libc.tls_head = &main_tls;
  4188a4:	4b 89 4c 3d 18       	mov    QWORD PTR [r13+r15*1+0x18],rcx
		main_tls.len = tls_phdr->p_filesz;
  4188a9:	42 0f 29 74 38 10    	movaps XMMWORD PTR [rax+r15*1+0x10],xmm6
	}

	main_tls.size += (-main_tls.size - (uintptr_t)main_tls.image)
  4188af:	48 01 fa             	add    rdx,rdi
		& (main_tls.align-1);
  4188b2:	48 8d 4e ff          	lea    rcx,[rsi-0x1]
	main_tls.size += (-main_tls.size - (uintptr_t)main_tls.image)
  4188b6:	48 f7 da             	neg    rdx
		& (main_tls.align-1);
  4188b9:	48 21 ca             	and    rdx,rcx
	main_tls.size += (-main_tls.size - (uintptr_t)main_tls.image)
  4188bc:	48 01 fa             	add    rdx,rdi
  4188bf:	4a 89 54 38 18       	mov    QWORD PTR [rax+r15*1+0x18],rdx
#ifdef TLS_ABOVE_TP
	main_tls.offset = GAP_ABOVE_TP;
	main_tls.offset += (-GAP_ABOVE_TP + (uintptr_t)main_tls.image)
		& (main_tls.align-1);
#else
	main_tls.offset = main_tls.size;
  4188c4:	4a 89 54 38 28       	mov    QWORD PTR [rax+r15*1+0x28],rdx
#endif
	if (main_tls.align < MIN_TLS_ALIGN) main_tls.align = MIN_TLS_ALIGN;
  4188c9:	48 83 fe 07          	cmp    rsi,0x7
  4188cd:	0f 86 2d 02 00 00    	jbe    418b00 <__init_tls+0x350>
  4188d3:	48 8d 86 f7 00 00 00 	lea    rax,[rsi+0xf7]
	libc.tls_size = 2*sizeof(void *) + sizeof(struct pthread)
#ifdef TLS_ABOVE_TP
		+ main_tls.offset
#endif
		+ main_tls.size + main_tls.align
		+ MIN_TLS_ALIGN-1 & -MIN_TLS_ALIGN;
  4188da:	48 01 c2             	add    rdx,rax
	libc.tls_size = 2*sizeof(void *) + sizeof(struct pthread)
  4188dd:	66 48 0f 6e de       	movq   xmm3,rsi
			MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);
		/* -4095...-1 cast to void * will crash on dereference anyway,
		 * so don't bloat the init code checking for error codes and
		 * explicitly calling a_crash(). */
	} else {
		mem = builtin_tls;
  4188e2:	48 b8 f0 4c 14 00 00 	movabs rax,0x144cf0
  4188e9:	00 00 00 
		+ MIN_TLS_ALIGN-1 & -MIN_TLS_ALIGN;
  4188ec:	48 83 e2 f8          	and    rdx,0xfffffffffffffff8
		mem = builtin_tls;
  4188f0:	4c 01 f8             	add    rax,r15
	libc.tls_size = 2*sizeof(void *) + sizeof(struct pthread)
  4188f3:	66 48 0f 6e c2       	movq   xmm0,rdx
		mem = builtin_tls;
  4188f8:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
	libc.tls_size = 2*sizeof(void *) + sizeof(struct pthread)
  4188fd:	66 0f 6c c3          	punpcklqdq xmm0,xmm3
  418901:	43 0f 11 44 3d 20    	movups XMMWORD PTR [r13+r15*1+0x20],xmm0
	if (libc.tls_size > sizeof builtin_tls) {
  418907:	48 81 fa 68 01 00 00 	cmp    rdx,0x168
  41890e:	0f 87 2c 02 00 00    	ja     418b40 <__init_tls+0x390>
	mem += libc.tls_size - sizeof(struct pthread);
  418914:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
  418919:	4b 8b 5c 3d 18       	mov    rbx,QWORD PTR [r13+r15*1+0x18]
  41891e:	48 bd 0a 64 fb ff ff 	movabs rbp,0xfffffffffffb640a
  418925:	ff ff ff 
		memcpy(mem - p->offset, p->image, p->len);
  418928:	4c 01 fd             	add    rbp,r15
	mem += libc.tls_size - sizeof(struct pthread);
  41892b:	4c 8d b4 10 20 ff ff 	lea    r14,[rax+rdx*1-0xe0]
  418932:	ff 
	mem -= (uintptr_t)mem & (libc.tls_align-1);
  418933:	66 48 0f 6e f8       	movq   xmm7,rax
  418938:	4c 8d 60 08          	lea    r12,[rax+0x8]
  41893c:	4c 21 f1             	and    rcx,r14
  41893f:	49 29 ce             	sub    r14,rcx
  418942:	66 49 0f 6e ce       	movq   xmm1,r14
  418947:	66 49 0f 6e d6       	movq   xmm2,r14
  41894c:	66 0f 6c c9          	punpcklqdq xmm1,xmm1
  418950:	66 0f 6c d7          	punpcklqdq xmm2,xmm7
  418954:	0f 29 4c 24 20       	movaps XMMWORD PTR [rsp+0x20],xmm1
  418959:	0f 29 54 24 10       	movaps XMMWORD PTR [rsp+0x10],xmm2
	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
  41895e:	48 85 db             	test   rbx,rbx
  418961:	74 2d                	je     418990 <__init_tls+0x1e0>
  418963:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		dtv[i] = (uintptr_t)(mem - p->offset) + DTP_OFFSET;
  418968:	4c 89 f0             	mov    rax,r14
  41896b:	48 2b 43 28          	sub    rax,QWORD PTR [rbx+0x28]
		memcpy(mem - p->offset, p->image, p->len);
  41896f:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
  418973:	4c 89 f7             	mov    rdi,r14
		dtv[i] = (uintptr_t)(mem - p->offset) + DTP_OFFSET;
  418976:	49 89 04 24          	mov    QWORD PTR [r12],rax
		memcpy(mem - p->offset, p->image, p->len);
  41897a:	48 8b 53 10          	mov    rdx,QWORD PTR [rbx+0x10]
	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
  41897e:	49 83 c4 08          	add    r12,0x8
		memcpy(mem - p->offset, p->image, p->len);
  418982:	48 2b 7b 28          	sub    rdi,QWORD PTR [rbx+0x28]
  418986:	ff d5                	call   rbp
	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
  418988:	48 8b 1b             	mov    rbx,QWORD PTR [rbx]
  41898b:	48 85 db             	test   rbx,rbx
  41898e:	75 d8                	jne    418968 <__init_tls+0x1b8>
	dtv[0] = libc.tls_cnt;
  418990:	4b 8b 44 3d 30       	mov    rax,QWORD PTR [r13+r15*1+0x30]
  418995:	48 8b 74 24 08       	mov    rsi,QWORD PTR [rsp+0x8]
	int r = __set_thread_area(TP_ADJ(p));
  41899a:	4c 89 f7             	mov    rdi,r14
	td->self = td;
  41899d:	66 0f 6f 64 24 10    	movdqa xmm4,XMMWORD PTR [rsp+0x10]
	dtv[0] = libc.tls_cnt;
  4189a3:	48 89 06             	mov    QWORD PTR [rsi],rax
	int r = __set_thread_area(TP_ADJ(p));
  4189a6:	48 b8 00 65 fb ff ff 	movabs rax,0xfffffffffffb6500
  4189ad:	ff ff ff 
  4189b0:	4c 01 f8             	add    rax,r15
	td->dtv = td->dtv_copy = dtv;
  4189b3:	49 89 b6 d8 00 00 00 	mov    QWORD PTR [r14+0xd8],rsi
	td->self = td;
  4189ba:	41 0f 11 26          	movups XMMWORD PTR [r14],xmm4
	int r = __set_thread_area(TP_ADJ(p));
  4189be:	ff d0                	call   rax
	if (r < 0) return -1;
  4189c0:	85 c0                	test   eax,eax
  4189c2:	0f 88 66 01 00 00    	js     418b2e <__init_tls+0x37e>
	if (!r) libc.can_do_threads = 1;
  4189c8:	0f 84 52 01 00 00    	je     418b20 <__init_tls+0x370>
	td->detach_state = DT_JOINABLE;
  4189ce:	41 c7 46 40 01 00 00 	mov    DWORD PTR [r14+0x40],0x1
  4189d5:	00 
  4189d6:	31 d2                	xor    edx,edx
  4189d8:	45 31 c9             	xor    r9d,r9d
  4189db:	45 31 c0             	xor    r8d,r8d
  4189de:	48 b8 58 4e 14 00 00 	movabs rax,0x144e58
  4189e5:	00 00 00 
  4189e8:	6a 00                	push   0x0
  4189ea:	31 c9                	xor    ecx,ecx
  4189ec:	bf da 00 00 00       	mov    edi,0xda
  4189f1:	49 8d 34 07          	lea    rsi,[r15+rax*1]
  4189f5:	6a 00                	push   0x0
  4189f7:	48 b8 50 a1 fa ff ff 	movabs rax,0xfffffffffffaa150
  4189fe:	ff ff ff 
  418a01:	4c 01 f8             	add    rax,r15
  418a04:	ff d0                	call   rax
	td->next = td->prev = td;
  418a06:	66 0f 6f 6c 24 30    	movdqa xmm5,XMMWORD PTR [rsp+0x30]
	td->tid = __syscall(SYS_set_tid_address, &__thread_list_lock);
  418a0c:	41 89 46 38          	mov    DWORD PTR [r14+0x38],eax
	td->locale = &libc.global_locale;
  418a10:	48 b8 70 4c 14 00 00 	movabs rax,0x144c70
  418a17:	00 00 00 
  418a1a:	4c 01 f8             	add    rax,r15
	td->next = td->prev = td;
  418a1d:	41 0f 11 6e 10       	movups XMMWORD PTR [r14+0x10],xmm5
	td->locale = &libc.global_locale;
  418a22:	49 89 86 b0 00 00 00 	mov    QWORD PTR [r14+0xb0],rax
	td->robust_list.head = &td->robust_list.head;
  418a29:	49 8d 86 90 00 00 00 	lea    rax,[r14+0x90]
  418a30:	49 89 86 90 00 00 00 	mov    QWORD PTR [r14+0x90],rax
	td->sysinfo = __sysinfo;
  418a37:	48 b8 10 4c 14 00 00 	movabs rax,0x144c10
  418a3e:	00 00 00 
  418a41:	49 8b 04 07          	mov    rax,QWORD PTR [r15+rax*1]
  418a45:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
	td->next = td->prev = td;
  418a49:	58                   	pop    rax
  418a4a:	5a                   	pop    rdx
	}

	/* Failure to initialize thread pointer is always fatal. */
	if (__init_tp(__copy_tls(mem)) < 0)
		a_crash();
}
  418a4b:	48 83 c4 38          	add    rsp,0x38
  418a4f:	5b                   	pop    rbx
  418a50:	5d                   	pop    rbp
  418a51:	41 5c                	pop    r12
  418a53:	41 5d                	pop    r13
  418a55:	41 5e                	pop    r14
  418a57:	41 5f                	pop    r15
  418a59:	c3                   	ret    
  418a5a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
		if (phdr->p_type == PT_DYNAMIC && _DYNAMIC)
  418a60:	83 f9 02             	cmp    ecx,0x2
  418a63:	74 08                	je     418a6d <__init_tls+0x2bd>
		if (phdr->p_type == PT_TLS)
  418a65:	83 f9 07             	cmp    ecx,0x7
  418a68:	75 63                	jne    418acd <__init_tls+0x31d>
  418a6a:	49 89 c2             	mov    r10,rax
	for (p=(void *)aux[AT_PHDR],n=aux[AT_PHNUM]; n; n--,p+=aux[AT_PHENT]) {
  418a6d:	48 01 f8             	add    rax,rdi
  418a70:	49 83 e8 01          	sub    r8,0x1
  418a74:	0f 84 db fd ff ff    	je     418855 <__init_tls+0xa5>
		if (phdr->p_type == PT_PHDR)
  418a7a:	8b 08                	mov    ecx,DWORD PTR [rax]
  418a7c:	83 f9 06             	cmp    ecx,0x6
  418a7f:	75 df                	jne    418a60 <__init_tls+0x2b0>
			base = aux[AT_PHDR] - phdr->p_vaddr;
  418a81:	4c 89 da             	mov    rdx,r11
  418a84:	48 2b 50 10          	sub    rdx,QWORD PTR [rax+0x10]
		if (phdr->p_type == PT_GNU_STACK &&
  418a88:	eb e3                	jmp    418a6d <__init_tls+0x2bd>
  418a8a:	81 f9 51 e5 74 64    	cmp    ecx,0x6474e551
  418a90:	0f 85 9f fd ff ff    	jne    418835 <__init_tls+0x85>
		    phdr->p_memsz > __default_stacksize)
  418a96:	48 8b 48 28          	mov    rcx,QWORD PTR [rax+0x28]
  418a9a:	44 89 ce             	mov    esi,r9d
		if (phdr->p_type == PT_GNU_STACK &&
  418a9d:	48 39 f1             	cmp    rcx,rsi
  418aa0:	0f 86 8f fd ff ff    	jbe    418835 <__init_tls+0x85>
			__default_stacksize =
  418aa6:	41 b9 00 00 80 00    	mov    r9d,0x800000
  418aac:	bd 01 00 00 00       	mov    ebp,0x1
  418ab1:	4c 39 c9             	cmp    rcx,r9
  418ab4:	4c 0f 46 c9          	cmovbe r9,rcx
  418ab8:	e9 78 fd ff ff       	jmp    418835 <__init_tls+0x85>
  418abd:	0f 1f 00             	nop    DWORD PTR [rax]
			base = (size_t)_DYNAMIC - phdr->p_vaddr;
  418ac0:	4b 8b 14 3c          	mov    rdx,QWORD PTR [r12+r15*1]
  418ac4:	48 2b 50 10          	sub    rdx,QWORD PTR [rax+0x10]
		if (phdr->p_type == PT_GNU_STACK &&
  418ac8:	e9 68 fd ff ff       	jmp    418835 <__init_tls+0x85>
  418acd:	81 f9 51 e5 74 64    	cmp    ecx,0x6474e551
  418ad3:	75 98                	jne    418a6d <__init_tls+0x2bd>
		    phdr->p_memsz > __default_stacksize)
  418ad5:	48 8b 48 28          	mov    rcx,QWORD PTR [rax+0x28]
  418ad9:	44 89 ce             	mov    esi,r9d
		if (phdr->p_type == PT_GNU_STACK &&
  418adc:	48 39 ce             	cmp    rsi,rcx
  418adf:	73 8c                	jae    418a6d <__init_tls+0x2bd>
			__default_stacksize =
  418ae1:	41 b9 00 00 80 00    	mov    r9d,0x800000
  418ae7:	bd 01 00 00 00       	mov    ebp,0x1
  418aec:	4c 39 c9             	cmp    rcx,r9
  418aef:	4c 0f 46 c9          	cmovbe r9,rcx
  418af3:	e9 75 ff ff ff       	jmp    418a6d <__init_tls+0x2bd>
  418af8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  418aff:	00 
	if (main_tls.align < MIN_TLS_ALIGN) main_tls.align = MIN_TLS_ALIGN;
  418b00:	4a c7 44 38 20 08 00 	mov    QWORD PTR [rax+r15*1+0x20],0x8
  418b07:	00 00 
  418b09:	b9 07 00 00 00       	mov    ecx,0x7
  418b0e:	b8 ff 00 00 00       	mov    eax,0xff
  418b13:	be 08 00 00 00       	mov    esi,0x8
  418b18:	e9 bd fd ff ff       	jmp    4188da <__init_tls+0x12a>
  418b1d:	0f 1f 00             	nop    DWORD PTR [rax]
	if (!r) libc.can_do_threads = 1;
  418b20:	43 c7 44 3d 00 01 00 	mov    DWORD PTR [r13+r15*1+0x0],0x1
  418b27:	00 00 
  418b29:	e9 a0 fe ff ff       	jmp    4189ce <__init_tls+0x21e>
  418b2e:	f4                   	hlt    
}
  418b2f:	48 83 c4 38          	add    rsp,0x38
  418b33:	5b                   	pop    rbx
  418b34:	5d                   	pop    rbp
  418b35:	41 5c                	pop    r12
  418b37:	41 5d                	pop    r13
  418b39:	41 5e                	pop    r14
  418b3b:	41 5f                	pop    r15
  418b3d:	c3                   	ret    
  418b3e:	66 90                	xchg   ax,ax
	return __cos_syscall(n, a1, a2, a3, a4, a5, 0, 0);
}

static __inline long __syscall6(long n, long a1, long a2, long a3, long a4, long a5, long a6)
{
	return __cos_syscall(n, a1, a2, a3, a4, a5, a6, 0);
  418b40:	6a 00                	push   0x0
  418b42:	b9 03 00 00 00       	mov    ecx,0x3
  418b47:	31 f6                	xor    esi,esi
  418b49:	bf 09 00 00 00       	mov    edi,0x9
  418b4e:	6a 00                	push   0x0
  418b50:	49 c7 c1 ff ff ff ff 	mov    r9,0xffffffffffffffff
  418b57:	48 b8 50 a1 fa ff ff 	movabs rax,0xfffffffffffaa150
  418b5e:	ff ff ff 
  418b61:	41 b8 22 00 00 00    	mov    r8d,0x22
  418b67:	4c 01 f8             	add    rax,r15
  418b6a:	ff d0                	call   rax
	mem += libc.tls_size - sizeof(struct pthread);
  418b6c:	4b 8b 54 3d 20       	mov    rdx,QWORD PTR [r13+r15*1+0x20]
  418b71:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
	mem -= (uintptr_t)mem & (libc.tls_align-1);
  418b76:	4b 8b 44 3d 28       	mov    rax,QWORD PTR [r13+r15*1+0x28]
  418b7b:	5e                   	pop    rsi
  418b7c:	5f                   	pop    rdi
  418b7d:	48 8d 48 ff          	lea    rcx,[rax-0x1]
  418b81:	e9 8e fd ff ff       	jmp    418914 <__init_tls+0x164>
  418b86:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  418b8d:	00 00 00 
	main_tls.size += (-main_tls.size - (uintptr_t)main_tls.image)
  418b90:	48 b8 b0 4c 14 00 00 	movabs rax,0x144cb0
  418b97:	00 00 00 
  418b9a:	49 bd 30 4c 14 00 00 	movabs r13,0x144c30
  418ba1:	00 00 00 
  418ba4:	4a 8b 7c 38 18       	mov    rdi,QWORD PTR [rax+r15*1+0x18]
  418ba9:	4a 8b 54 38 08       	mov    rdx,QWORD PTR [rax+r15*1+0x8]
		& (main_tls.align-1);
  418bae:	4a 8b 74 38 20       	mov    rsi,QWORD PTR [rax+r15*1+0x20]
  418bb3:	e9 f7 fc ff ff       	jmp    4188af <__init_tls+0xff>
  418bb8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  418bbf:	00 

0000000000418bc0 <__errno_location>:
#include <errno.h>
#include "pthread_impl.h"

int *__errno_location(void)
{
  418bc0:	f3 0f 1e fa          	endbr64 
	static int e;
	return &e;
  418bc4:	49 bb 4c 88 04 00 00 	movabs r11,0x4884c
  418bcb:	00 00 00 
  418bce:	48 8d 05 ef ff ff ff 	lea    rax,[rip+0xffffffffffffffef]        # 418bc4 <__errno_location+0x4>
  418bd5:	48 ba 5c 4e 14 00 00 	movabs rdx,0x144e5c
  418bdc:	00 00 00 
  418bdf:	4c 01 d8             	add    rax,r11
  418be2:	48 01 d0             	add    rax,rdx
}
  418be5:	c3                   	ret    
  418be6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  418bed:	00 00 00 

0000000000418bf0 <_Exit>:
#include <stdlib.h>
#include "syscall.h"

_Noreturn void _Exit(int ec)
{
  418bf0:	f3 0f 1e fa          	endbr64 
  418bf4:	41 57                	push   r15
  418bf6:	4c 8d 3d f7 ff ff ff 	lea    r15,[rip+0xfffffffffffffff7]        # 418bf4 <_Exit+0x4>
	return __cos_syscall(n, a1, 0, 0, 0, 0, 0, 0);
  418bfd:	31 c9                	xor    ecx,ecx
  418bff:	45 31 c9             	xor    r9d,r9d
  418c02:	49 bb 1c 88 04 00 00 	movabs r11,0x4881c
  418c09:	00 00 00 
  418c0c:	55                   	push   rbp
	__syscall(SYS_exit_group, ec);
  418c0d:	48 63 ef             	movsxd rbp,edi
  418c10:	45 31 c0             	xor    r8d,r8d
{
  418c13:	53                   	push   rbx
  418c14:	4d 01 df             	add    r15,r11
  418c17:	48 89 ee             	mov    rsi,rbp
  418c1a:	31 d2                	xor    edx,edx
  418c1c:	48 bb 50 a1 fa ff ff 	movabs rbx,0xfffffffffffaa150
  418c23:	ff ff ff 
  418c26:	6a 00                	push   0x0
  418c28:	bf e7 00 00 00       	mov    edi,0xe7
  418c2d:	6a 00                	push   0x0
  418c2f:	4c 01 fb             	add    rbx,r15
  418c32:	ff d3                	call   rbx
  418c34:	59                   	pop    rcx
  418c35:	5e                   	pop    rsi
  418c36:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  418c3d:	00 00 00 
  418c40:	6a 00                	push   0x0
  418c42:	31 d2                	xor    edx,edx
  418c44:	45 31 c9             	xor    r9d,r9d
  418c47:	45 31 c0             	xor    r8d,r8d
  418c4a:	6a 00                	push   0x0
  418c4c:	31 c9                	xor    ecx,ecx
  418c4e:	48 89 ee             	mov    rsi,rbp
  418c51:	bf 3c 00 00 00       	mov    edi,0x3c
  418c56:	ff d3                	call   rbx
  418c58:	58                   	pop    rax
  418c59:	5a                   	pop    rdx
  418c5a:	eb e4                	jmp    418c40 <_Exit+0x50>
  418c5c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000418c60 <pop_arg>:
	long double f;
	void *p;
};

static void pop_arg(union arg *arg, int type, va_list *ap)
{
  418c60:	f3 0f 1e fa          	endbr64 
	switch (type) {
  418c64:	83 ee 09             	sub    esi,0x9
{
  418c67:	48 89 d0             	mov    rax,rdx
	switch (type) {
  418c6a:	83 fe 11             	cmp    esi,0x11
  418c6d:	77 49                	ja     418cb8 <pop_arg+0x58>
  418c6f:	48 8d 15 1a 90 00 00 	lea    rdx,[rip+0x901a]        # 421c90 <CSWTCH.186+0x760>
  418c76:	48 03 14 f2          	add    rdx,QWORD PTR [rdx+rsi*8]
  418c7a:	3e ff e2             	notrack jmp rdx
  418c7d:	0f 1f 00             	nop    DWORD PTR [rax]
	break; case LLONG:	arg->i = va_arg(*ap, long long);
	break; case SIZET:	arg->i = va_arg(*ap, size_t);
	break; case IMAX:	arg->i = va_arg(*ap, intmax_t);
	break; case UMAX:	arg->i = va_arg(*ap, uintmax_t);
	break; case PDIFF:	arg->i = va_arg(*ap, ptrdiff_t);
	break; case UIPTR:	arg->i = (uintptr_t)va_arg(*ap, void *);
  418c80:	8b 10                	mov    edx,DWORD PTR [rax]
  418c82:	83 fa 2f             	cmp    edx,0x2f
  418c85:	77 39                	ja     418cc0 <pop_arg+0x60>
  418c87:	89 d1                	mov    ecx,edx
  418c89:	83 c2 08             	add    edx,0x8
  418c8c:	48 03 48 10          	add    rcx,QWORD PTR [rax+0x10]
  418c90:	89 10                	mov    DWORD PTR [rax],edx
  418c92:	48 8b 01             	mov    rax,QWORD PTR [rcx]
  418c95:	48 89 07             	mov    QWORD PTR [rdi],rax
	break; case DBL:	arg->f = va_arg(*ap, double);
  418c98:	c3                   	ret    
  418c99:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	break; case LDBL:	arg->f = va_arg(*ap, long double);
  418ca0:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  418ca4:	48 8d 51 0f          	lea    rdx,[rcx+0xf]
  418ca8:	48 83 e2 f0          	and    rdx,0xfffffffffffffff0
  418cac:	48 8d 4a 10          	lea    rcx,[rdx+0x10]
  418cb0:	48 89 48 08          	mov    QWORD PTR [rax+0x8],rcx
  418cb4:	db 2a                	fld    TBYTE PTR [rdx]
  418cb6:	db 3f                	fstp   TBYTE PTR [rdi]
	}
}
  418cb8:	c3                   	ret    
  418cb9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	break; case UIPTR:	arg->i = (uintptr_t)va_arg(*ap, void *);
  418cc0:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  418cc4:	48 8d 51 08          	lea    rdx,[rcx+0x8]
  418cc8:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  418ccc:	48 8b 01             	mov    rax,QWORD PTR [rcx]
  418ccf:	48 89 07             	mov    QWORD PTR [rdi],rax
	break; case DBL:	arg->f = va_arg(*ap, double);
  418cd2:	c3                   	ret    
  418cd3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	break; case USHORT:	arg->i = (unsigned short)va_arg(*ap, int);
  418cd8:	8b 10                	mov    edx,DWORD PTR [rax]
  418cda:	83 fa 2f             	cmp    edx,0x2f
  418cdd:	0f 87 55 01 00 00    	ja     418e38 <pop_arg+0x1d8>
  418ce3:	89 d1                	mov    ecx,edx
  418ce5:	83 c2 08             	add    edx,0x8
  418ce8:	48 03 48 10          	add    rcx,QWORD PTR [rax+0x10]
  418cec:	89 10                	mov    DWORD PTR [rax],edx
  418cee:	0f b7 01             	movzx  eax,WORD PTR [rcx]
  418cf1:	48 89 07             	mov    QWORD PTR [rdi],rax
	break; case CHAR:	arg->i = (signed char)va_arg(*ap, int);
  418cf4:	c3                   	ret    
  418cf5:	0f 1f 00             	nop    DWORD PTR [rax]
	break; case DBL:	arg->f = va_arg(*ap, double);
  418cf8:	8b 50 04             	mov    edx,DWORD PTR [rax+0x4]
  418cfb:	81 fa af 00 00 00    	cmp    edx,0xaf
  418d01:	0f 87 19 01 00 00    	ja     418e20 <pop_arg+0x1c0>
  418d07:	89 d1                	mov    ecx,edx
  418d09:	83 c2 10             	add    edx,0x10
  418d0c:	48 03 48 10          	add    rcx,QWORD PTR [rax+0x10]
  418d10:	89 50 04             	mov    DWORD PTR [rax+0x4],edx
  418d13:	dd 01                	fld    QWORD PTR [rcx]
  418d15:	db 3f                	fstp   TBYTE PTR [rdi]
	break; case LDBL:	arg->f = va_arg(*ap, long double);
  418d17:	c3                   	ret    
  418d18:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  418d1f:	00 
	break; case INT:	arg->i = va_arg(*ap, int);
  418d20:	8b 10                	mov    edx,DWORD PTR [rax]
  418d22:	83 fa 2f             	cmp    edx,0x2f
  418d25:	0f 87 dd 00 00 00    	ja     418e08 <pop_arg+0x1a8>
  418d2b:	89 d1                	mov    ecx,edx
  418d2d:	83 c2 08             	add    edx,0x8
  418d30:	48 03 48 10          	add    rcx,QWORD PTR [rax+0x10]
  418d34:	89 10                	mov    DWORD PTR [rax],edx
  418d36:	48 63 01             	movsxd rax,DWORD PTR [rcx]
  418d39:	48 89 07             	mov    QWORD PTR [rdi],rax
	break; case UINT:	arg->i = va_arg(*ap, unsigned int);
  418d3c:	c3                   	ret    
  418d3d:	0f 1f 00             	nop    DWORD PTR [rax]
  418d40:	8b 10                	mov    edx,DWORD PTR [rax]
  418d42:	83 fa 2f             	cmp    edx,0x2f
  418d45:	0f 87 a5 00 00 00    	ja     418df0 <pop_arg+0x190>
  418d4b:	89 d1                	mov    ecx,edx
  418d4d:	83 c2 08             	add    edx,0x8
  418d50:	48 03 48 10          	add    rcx,QWORD PTR [rax+0x10]
  418d54:	89 10                	mov    DWORD PTR [rax],edx
  418d56:	8b 01                	mov    eax,DWORD PTR [rcx]
  418d58:	48 89 07             	mov    QWORD PTR [rdi],rax
	break; case LONG:	arg->i = va_arg(*ap, long);
  418d5b:	c3                   	ret    
  418d5c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	break; case UCHAR:	arg->i = (unsigned char)va_arg(*ap, int);
  418d60:	8b 10                	mov    edx,DWORD PTR [rax]
  418d62:	83 fa 2f             	cmp    edx,0x2f
  418d65:	77 79                	ja     418de0 <pop_arg+0x180>
  418d67:	89 d1                	mov    ecx,edx
  418d69:	83 c2 08             	add    edx,0x8
  418d6c:	48 03 48 10          	add    rcx,QWORD PTR [rax+0x10]
  418d70:	89 10                	mov    DWORD PTR [rax],edx
  418d72:	0f b6 01             	movzx  eax,BYTE PTR [rcx]
  418d75:	48 89 07             	mov    QWORD PTR [rdi],rax
	break; case LLONG:	arg->i = va_arg(*ap, long long);
  418d78:	c3                   	ret    
  418d79:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	break; case CHAR:	arg->i = (signed char)va_arg(*ap, int);
  418d80:	8b 10                	mov    edx,DWORD PTR [rax]
  418d82:	83 fa 2f             	cmp    edx,0x2f
  418d85:	77 49                	ja     418dd0 <pop_arg+0x170>
  418d87:	89 d1                	mov    ecx,edx
  418d89:	83 c2 08             	add    edx,0x8
  418d8c:	48 03 48 10          	add    rcx,QWORD PTR [rax+0x10]
  418d90:	89 10                	mov    DWORD PTR [rax],edx
  418d92:	48 0f be 01          	movsx  rax,BYTE PTR [rcx]
  418d96:	48 89 07             	mov    QWORD PTR [rdi],rax
	break; case UCHAR:	arg->i = (unsigned char)va_arg(*ap, int);
  418d99:	c3                   	ret    
  418d9a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	break; case SHORT:	arg->i = (short)va_arg(*ap, int);
  418da0:	8b 10                	mov    edx,DWORD PTR [rax]
  418da2:	83 fa 2f             	cmp    edx,0x2f
  418da5:	77 19                	ja     418dc0 <pop_arg+0x160>
  418da7:	89 d1                	mov    ecx,edx
  418da9:	83 c2 08             	add    edx,0x8
  418dac:	48 03 48 10          	add    rcx,QWORD PTR [rax+0x10]
  418db0:	89 10                	mov    DWORD PTR [rax],edx
  418db2:	48 0f bf 01          	movsx  rax,WORD PTR [rcx]
  418db6:	48 89 07             	mov    QWORD PTR [rdi],rax
	break; case USHORT:	arg->i = (unsigned short)va_arg(*ap, int);
  418db9:	c3                   	ret    
  418dba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	break; case SHORT:	arg->i = (short)va_arg(*ap, int);
  418dc0:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  418dc4:	48 8d 51 08          	lea    rdx,[rcx+0x8]
  418dc8:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  418dcc:	eb e4                	jmp    418db2 <pop_arg+0x152>
  418dce:	66 90                	xchg   ax,ax
	break; case CHAR:	arg->i = (signed char)va_arg(*ap, int);
  418dd0:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  418dd4:	48 8d 51 08          	lea    rdx,[rcx+0x8]
  418dd8:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  418ddc:	eb b4                	jmp    418d92 <pop_arg+0x132>
  418dde:	66 90                	xchg   ax,ax
	break; case UCHAR:	arg->i = (unsigned char)va_arg(*ap, int);
  418de0:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  418de4:	48 8d 51 08          	lea    rdx,[rcx+0x8]
  418de8:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  418dec:	eb 84                	jmp    418d72 <pop_arg+0x112>
  418dee:	66 90                	xchg   ax,ax
	break; case UINT:	arg->i = va_arg(*ap, unsigned int);
  418df0:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  418df4:	48 8d 51 08          	lea    rdx,[rcx+0x8]
  418df8:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  418dfc:	e9 55 ff ff ff       	jmp    418d56 <pop_arg+0xf6>
  418e01:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	break; case INT:	arg->i = va_arg(*ap, int);
  418e08:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  418e0c:	48 8d 51 08          	lea    rdx,[rcx+0x8]
  418e10:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  418e14:	e9 1d ff ff ff       	jmp    418d36 <pop_arg+0xd6>
  418e19:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	break; case DBL:	arg->f = va_arg(*ap, double);
  418e20:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  418e24:	48 8d 51 08          	lea    rdx,[rcx+0x8]
  418e28:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  418e2c:	e9 e2 fe ff ff       	jmp    418d13 <pop_arg+0xb3>
  418e31:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	break; case USHORT:	arg->i = (unsigned short)va_arg(*ap, int);
  418e38:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  418e3c:	48 8d 51 08          	lea    rdx,[rcx+0x8]
  418e40:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  418e44:	e9 a5 fe ff ff       	jmp    418cee <pop_arg+0x8e>

0000000000418e49 <fmt_fp.cold>:
  418e49:	41 8d bd 00 ff ff ff 	lea    edi,[r13-0x100]
  418e50:	66 41 0f 6e ed       	movd   xmm5,r13d
{
	char pad[256];
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
	l = w - l;
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
	for (; l >= sizeof pad; l -= sizeof pad)
  418e55:	45 31 c0             	xor    r8d,r8d
  418e58:	48 b8 f0 0d fc ff ff 	movabs rax,0xfffffffffffc0df0
  418e5f:	ff ff ff 
  418e62:	41 89 f9             	mov    r9d,edi
  418e65:	66 0f 70 c5 00       	pshufd xmm0,xmm5,0x0
  418e6a:	66 42 0f fe 04 38    	paddd  xmm0,XMMWORD PTR [rax+r15*1]
  418e70:	48 b8 10 0e fc ff ff 	movabs rax,0xfffffffffffc0e10
  418e77:	ff ff ff 
  418e7a:	41 c1 e9 08          	shr    r9d,0x8
  418e7e:	66 42 0f 6f 14 38    	movdqa xmm2,XMMWORD PTR [rax+r15*1]
  418e84:	48 ba 00 0e fc ff ff 	movabs rdx,0xfffffffffffc0e00
  418e8b:	ff ff ff 
  418e8e:	41 83 c1 01          	add    r9d,0x1
  418e92:	66 42 0f 6f 1c 3a    	movdqa xmm3,XMMWORD PTR [rdx+r15*1]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418e98:	89 f2                	mov    edx,esi
  418e9a:	44 89 c9             	mov    ecx,r9d
  418e9d:	c1 e9 02             	shr    ecx,0x2
  418ea0:	66 0f 6f c8          	movdqa xmm1,xmm0
  418ea4:	41 83 c0 01          	add    r8d,0x1
  418ea8:	66 0f fe c3          	paddd  xmm0,xmm3
  418eac:	89 d6                	mov    esi,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  418eae:	66 0f fe ca          	paddd  xmm1,xmm2
  418eb2:	44 39 c1             	cmp    ecx,r8d
  418eb5:	77 e9                	ja     418ea0 <fmt_fp.cold+0x57>
  418eb7:	44 89 c8             	mov    eax,r9d
  418eba:	66 0f 70 c1 ff       	pshufd xmm0,xmm1,0xff
  418ebf:	83 e0 fc             	and    eax,0xfffffffc
  418ec2:	66 0f 7e c1          	movd   ecx,xmm0
  418ec6:	69 d0 00 ff ff ff    	imul   edx,eax,0xffffff00
  418ecc:	41 39 c1             	cmp    r9d,eax
  418ecf:	0f 84 50 12 00 00    	je     41a125 <fmt_fp+0xc65>
  418ed5:	8d 04 17             	lea    eax,[rdi+rdx*1]
  418ed8:	89 c1                	mov    ecx,eax
  418eda:	3d ff 00 00 00       	cmp    eax,0xff
  418edf:	0f 86 40 12 00 00    	jbe    41a125 <fmt_fp+0xc65>
  418ee5:	81 e9 00 01 00 00    	sub    ecx,0x100
  418eeb:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  418ef1:	0f 86 2e 12 00 00    	jbe    41a125 <fmt_fp+0xc65>
  418ef7:	8d 88 00 fe ff ff    	lea    ecx,[rax-0x200]
  418efd:	e9 23 12 00 00       	jmp    41a125 <fmt_fp+0xc65>
  418f02:	44 8d 83 00 ff ff ff 	lea    r8d,[rbx-0x100]
  418f09:	66 0f 6e fb          	movd   xmm7,ebx
  418f0d:	31 c9                	xor    ecx,ecx
  418f0f:	48 b8 f0 0d fc ff ff 	movabs rax,0xfffffffffffc0df0
  418f16:	ff ff ff 
  418f19:	44 89 c7             	mov    edi,r8d
  418f1c:	66 0f 70 cf 00       	pshufd xmm1,xmm7,0x0
  418f21:	66 42 0f fe 0c 38    	paddd  xmm1,XMMWORD PTR [rax+r15*1]
  418f27:	48 b8 10 0e fc ff ff 	movabs rax,0xfffffffffffc0e10
  418f2e:	ff ff ff 
  418f31:	c1 ef 08             	shr    edi,0x8
  418f34:	66 42 0f 6f 14 38    	movdqa xmm2,XMMWORD PTR [rax+r15*1]
  418f3a:	48 ba 00 0e fc ff ff 	movabs rdx,0xfffffffffffc0e00
  418f41:	ff ff ff 
  418f44:	83 c7 01             	add    edi,0x1
  418f47:	66 42 0f 6f 1c 3a    	movdqa xmm3,XMMWORD PTR [rdx+r15*1]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418f4d:	89 f2                	mov    edx,esi
  418f4f:	41 89 f9             	mov    r9d,edi
  418f52:	41 c1 e9 02          	shr    r9d,0x2
  418f56:	66 0f 6f c1          	movdqa xmm0,xmm1
  418f5a:	83 c1 01             	add    ecx,0x1
  418f5d:	66 0f fe cb          	paddd  xmm1,xmm3
  418f61:	89 d6                	mov    esi,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  418f63:	66 0f fe c2          	paddd  xmm0,xmm2
  418f67:	44 39 c9             	cmp    ecx,r9d
  418f6a:	72 ea                	jb     418f56 <fmt_fp.cold+0x10d>
  418f6c:	89 fa                	mov    edx,edi
  418f6e:	66 0f 70 c0 ff       	pshufd xmm0,xmm0,0xff
  418f73:	83 e2 fc             	and    edx,0xfffffffc
  418f76:	66 0f 7e c5          	movd   ebp,xmm0
  418f7a:	69 c2 00 ff ff ff    	imul   eax,edx,0xffffff00
  418f80:	39 fa                	cmp    edx,edi
  418f82:	0f 84 56 0d 00 00    	je     419cde <fmt_fp+0x81e>
  418f88:	44 01 c0             	add    eax,r8d
  418f8b:	89 c5                	mov    ebp,eax
  418f8d:	3d ff 00 00 00       	cmp    eax,0xff
  418f92:	0f 86 46 0d 00 00    	jbe    419cde <fmt_fp+0x81e>
  418f98:	81 ed 00 01 00 00    	sub    ebp,0x100
  418f9e:	81 fd ff 00 00 00    	cmp    ebp,0xff
  418fa4:	0f 86 34 0d 00 00    	jbe    419cde <fmt_fp+0x81e>
  418faa:	8d a8 00 fe ff ff    	lea    ebp,[rax-0x200]
  418fb0:	e9 29 0d 00 00       	jmp    419cde <fmt_fp+0x81e>
  418fb5:	45 8d 84 24 00 ff ff 	lea    r8d,[r12-0x100]
  418fbc:	ff 
  418fbd:	66 41 0f 6e f4       	movd   xmm6,r12d
  418fc2:	31 c9                	xor    ecx,ecx
  418fc4:	48 ba 00 0e fc ff ff 	movabs rdx,0xfffffffffffc0e00
  418fcb:	ff ff ff 
  418fce:	44 89 c0             	mov    eax,r8d
  418fd1:	66 0f 70 ce 00       	pshufd xmm1,xmm6,0x0
  418fd6:	66 42 0f 6f 1c 3a    	movdqa xmm3,XMMWORD PTR [rdx+r15*1]
  418fdc:	c1 e8 08             	shr    eax,0x8
  418fdf:	8d 78 01             	lea    edi,[rax+0x1]
  418fe2:	48 b8 f0 0d fc ff ff 	movabs rax,0xfffffffffffc0df0
  418fe9:	ff ff ff 
  418fec:	66 42 0f fe 0c 38    	paddd  xmm1,XMMWORD PTR [rax+r15*1]
  418ff2:	41 89 f9             	mov    r9d,edi
  418ff5:	48 b8 10 0e fc ff ff 	movabs rax,0xfffffffffffc0e10
  418ffc:	ff ff ff 
  418fff:	66 42 0f 6f 14 38    	movdqa xmm2,XMMWORD PTR [rax+r15*1]
  419005:	41 c1 e9 02          	shr    r9d,0x2
  419009:	66 0f 6f c1          	movdqa xmm0,xmm1
  41900d:	83 c1 01             	add    ecx,0x1
  419010:	66 0f fe cb          	paddd  xmm1,xmm3
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419014:	89 f2                	mov    edx,esi
	for (; l >= sizeof pad; l -= sizeof pad)
  419016:	66 0f fe c2          	paddd  xmm0,xmm2
  41901a:	41 39 c9             	cmp    r9d,ecx
  41901d:	77 ea                	ja     419009 <fmt_fp.cold+0x1c0>
  41901f:	89 f8                	mov    eax,edi
  419021:	66 0f 70 c0 ff       	pshufd xmm0,xmm0,0xff
  419026:	83 e0 fc             	and    eax,0xfffffffc
  419029:	66 41 0f 7e c1       	movd   r9d,xmm0
  41902e:	69 c8 00 ff ff ff    	imul   ecx,eax,0xffffff00
  419034:	39 c7                	cmp    edi,eax
  419036:	0f 84 8b 16 00 00    	je     41a6c7 <fmt_fp+0x1207>
  41903c:	41 01 c8             	add    r8d,ecx
  41903f:	45 89 c1             	mov    r9d,r8d
  419042:	41 81 f8 ff 00 00 00 	cmp    r8d,0xff
  419049:	0f 86 78 16 00 00    	jbe    41a6c7 <fmt_fp+0x1207>
  41904f:	41 81 e9 00 01 00 00 	sub    r9d,0x100
  419056:	41 81 f9 ff 00 00 00 	cmp    r9d,0xff
  41905d:	0f 86 64 16 00 00    	jbe    41a6c7 <fmt_fp+0x1207>
  419063:	45 8d 88 00 fe ff ff 	lea    r9d,[r8-0x200]
  41906a:	e9 58 16 00 00       	jmp    41a6c7 <fmt_fp+0x1207>
  41906f:	41 8d b4 24 00 ff ff 	lea    esi,[r12-0x100]
  419076:	ff 
  419077:	66 41 0f 6e f4       	movd   xmm6,r12d
  41907c:	45 31 c0             	xor    r8d,r8d
  41907f:	48 b8 f0 0d fc ff ff 	movabs rax,0xfffffffffffc0df0
  419086:	ff ff ff 
  419089:	89 f7                	mov    edi,esi
  41908b:	66 0f 70 c6 00       	pshufd xmm0,xmm6,0x0
  419090:	48 ba 00 0e fc ff ff 	movabs rdx,0xfffffffffffc0e00
  419097:	ff ff ff 
  41909a:	c1 ef 08             	shr    edi,0x8
  41909d:	66 42 0f fe 04 38    	paddd  xmm0,XMMWORD PTR [rax+r15*1]
  4190a3:	66 42 0f 6f 1c 3a    	movdqa xmm3,XMMWORD PTR [rdx+r15*1]
  4190a9:	48 b8 10 0e fc ff ff 	movabs rax,0xfffffffffffc0e10
  4190b0:	ff ff ff 
  4190b3:	83 c7 01             	add    edi,0x1
  4190b6:	66 42 0f 6f 14 38    	movdqa xmm2,XMMWORD PTR [rax+r15*1]
  4190bc:	41 89 f9             	mov    r9d,edi
  4190bf:	41 c1 e9 02          	shr    r9d,0x2
  4190c3:	66 0f 6f c8          	movdqa xmm1,xmm0
  4190c7:	41 83 c0 01          	add    r8d,0x1
  4190cb:	66 0f fe c3          	paddd  xmm0,xmm3
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4190cf:	89 ca                	mov    edx,ecx
	for (; l >= sizeof pad; l -= sizeof pad)
  4190d1:	66 0f fe ca          	paddd  xmm1,xmm2
  4190d5:	45 39 c8             	cmp    r8d,r9d
  4190d8:	72 e9                	jb     4190c3 <fmt_fp.cold+0x27a>
  4190da:	89 f8                	mov    eax,edi
  4190dc:	66 0f 70 c1 ff       	pshufd xmm0,xmm1,0xff
  4190e1:	83 e0 fc             	and    eax,0xfffffffc
  4190e4:	66 41 0f 7e c5       	movd   r13d,xmm0
  4190e9:	69 c8 00 ff ff ff    	imul   ecx,eax,0xffffff00
  4190ef:	39 c7                	cmp    edi,eax
  4190f1:	0f 84 16 11 00 00    	je     41a20d <fmt_fp+0xd4d>
  4190f7:	8d 04 0e             	lea    eax,[rsi+rcx*1]
  4190fa:	41 89 c5             	mov    r13d,eax
  4190fd:	3d ff 00 00 00       	cmp    eax,0xff
  419102:	0f 86 05 11 00 00    	jbe    41a20d <fmt_fp+0xd4d>
  419108:	41 81 ed 00 01 00 00 	sub    r13d,0x100
  41910f:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  419116:	0f 86 f1 10 00 00    	jbe    41a20d <fmt_fp+0xd4d>
  41911c:	44 8d a8 00 fe ff ff 	lea    r13d,[rax-0x200]
  419123:	e9 e5 10 00 00       	jmp    41a20d <fmt_fp+0xd4d>
  419128:	44 8d 85 00 ff ff ff 	lea    r8d,[rbp-0x100]
  41912f:	66 0f 6e fd          	movd   xmm7,ebp
  419133:	31 f6                	xor    esi,esi
  419135:	48 b8 f0 0d fc ff ff 	movabs rax,0xfffffffffffc0df0
  41913c:	ff ff ff 
  41913f:	44 89 c7             	mov    edi,r8d
  419142:	66 0f 70 cf 00       	pshufd xmm1,xmm7,0x0
  419147:	48 ba 00 0e fc ff ff 	movabs rdx,0xfffffffffffc0e00
  41914e:	ff ff ff 
  419151:	c1 ef 08             	shr    edi,0x8
  419154:	66 42 0f fe 0c 38    	paddd  xmm1,XMMWORD PTR [rax+r15*1]
  41915a:	66 42 0f 6f 1c 3a    	movdqa xmm3,XMMWORD PTR [rdx+r15*1]
  419160:	48 b8 10 0e fc ff ff 	movabs rax,0xfffffffffffc0e10
  419167:	ff ff ff 
  41916a:	83 c7 01             	add    edi,0x1
  41916d:	66 42 0f 6f 14 38    	movdqa xmm2,XMMWORD PTR [rax+r15*1]
  419173:	41 89 f9             	mov    r9d,edi
  419176:	41 c1 e9 02          	shr    r9d,0x2
  41917a:	66 0f 6f c1          	movdqa xmm0,xmm1
  41917e:	83 c6 01             	add    esi,0x1
  419181:	66 0f fe cb          	paddd  xmm1,xmm3
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419185:	89 ca                	mov    edx,ecx
	for (; l >= sizeof pad; l -= sizeof pad)
  419187:	66 0f fe c2          	paddd  xmm0,xmm2
  41918b:	41 39 f1             	cmp    r9d,esi
  41918e:	77 ea                	ja     41917a <fmt_fp.cold+0x331>
  419190:	89 f9                	mov    ecx,edi
  419192:	66 0f 70 c0 ff       	pshufd xmm0,xmm0,0xff
  419197:	83 e1 fc             	and    ecx,0xfffffffc
  41919a:	66 41 0f 7e c4       	movd   r12d,xmm0
  41919f:	69 c1 00 ff ff ff    	imul   eax,ecx,0xffffff00
  4191a5:	39 f9                	cmp    ecx,edi
  4191a7:	0f 84 a4 17 00 00    	je     41a951 <fmt_fp+0x1491>
  4191ad:	44 01 c0             	add    eax,r8d
  4191b0:	41 89 c4             	mov    r12d,eax
  4191b3:	3d ff 00 00 00       	cmp    eax,0xff
  4191b8:	0f 86 93 17 00 00    	jbe    41a951 <fmt_fp+0x1491>
  4191be:	41 81 ec 00 01 00 00 	sub    r12d,0x100
  4191c5:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  4191cc:	0f 86 7f 17 00 00    	jbe    41a951 <fmt_fp+0x1491>
  4191d2:	44 8d a0 00 fe ff ff 	lea    r12d,[rax-0x200]
  4191d9:	e9 73 17 00 00       	jmp    41a951 <fmt_fp+0x1491>
  4191de:	41 8d bd 00 ff ff ff 	lea    edi,[r13-0x100]
  4191e5:	66 41 0f 6e ed       	movd   xmm5,r13d
  4191ea:	45 31 c0             	xor    r8d,r8d
  4191ed:	48 b8 f0 0d fc ff ff 	movabs rax,0xfffffffffffc0df0
  4191f4:	ff ff ff 
  4191f7:	89 fe                	mov    esi,edi
  4191f9:	66 0f 70 cd 00       	pshufd xmm1,xmm5,0x0
  4191fe:	66 42 0f fe 0c 38    	paddd  xmm1,XMMWORD PTR [rax+r15*1]
  419204:	48 b8 10 0e fc ff ff 	movabs rax,0xfffffffffffc0e10
  41920b:	ff ff ff 
  41920e:	c1 ee 08             	shr    esi,0x8
  419211:	66 42 0f 6f 14 38    	movdqa xmm2,XMMWORD PTR [rax+r15*1]
  419217:	48 ba 00 0e fc ff ff 	movabs rdx,0xfffffffffffc0e00
  41921e:	ff ff ff 
  419221:	83 c6 01             	add    esi,0x1
  419224:	66 42 0f 6f 1c 3a    	movdqa xmm3,XMMWORD PTR [rdx+r15*1]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41922a:	89 ca                	mov    edx,ecx
  41922c:	41 89 f1             	mov    r9d,esi
  41922f:	41 c1 e9 02          	shr    r9d,0x2
  419233:	66 0f 6f c1          	movdqa xmm0,xmm1
  419237:	41 83 c0 01          	add    r8d,0x1
  41923b:	66 0f fe cb          	paddd  xmm1,xmm3
  41923f:	89 d1                	mov    ecx,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  419241:	66 0f fe c2          	paddd  xmm0,xmm2
  419245:	45 39 c8             	cmp    r8d,r9d
  419248:	72 e9                	jb     419233 <fmt_fp.cold+0x3ea>
  41924a:	89 f2                	mov    edx,esi
  41924c:	66 0f 70 c0 ff       	pshufd xmm0,xmm0,0xff
  419251:	83 e2 fc             	and    edx,0xfffffffc
  419254:	66 0f 7e c5          	movd   ebp,xmm0
  419258:	69 c2 00 ff ff ff    	imul   eax,edx,0xffffff00
  41925e:	39 f2                	cmp    edx,esi
  419260:	0f 84 65 0b 00 00    	je     419dcb <fmt_fp+0x90b>
  419266:	01 f8                	add    eax,edi
  419268:	89 c5                	mov    ebp,eax
  41926a:	3d ff 00 00 00       	cmp    eax,0xff
  41926f:	0f 86 56 0b 00 00    	jbe    419dcb <fmt_fp+0x90b>
  419275:	81 ed 00 01 00 00    	sub    ebp,0x100
  41927b:	81 fd ff 00 00 00    	cmp    ebp,0xff
  419281:	0f 86 44 0b 00 00    	jbe    419dcb <fmt_fp+0x90b>
  419287:	8d a8 00 fe ff ff    	lea    ebp,[rax-0x200]
  41928d:	e9 39 0b 00 00       	jmp    419dcb <fmt_fp+0x90b>
  419292:	45 8d 84 24 00 ff ff 	lea    r8d,[r12-0x100]
  419299:	ff 
  41929a:	66 41 0f 6e ec       	movd   xmm5,r12d
  41929f:	31 c9                	xor    ecx,ecx
  4192a1:	48 ba 00 0e fc ff ff 	movabs rdx,0xfffffffffffc0e00
  4192a8:	ff ff ff 
  4192ab:	44 89 c0             	mov    eax,r8d
  4192ae:	66 0f 70 cd 00       	pshufd xmm1,xmm5,0x0
  4192b3:	66 42 0f 6f 1c 3a    	movdqa xmm3,XMMWORD PTR [rdx+r15*1]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4192b9:	89 f2                	mov    edx,esi
  4192bb:	c1 e8 08             	shr    eax,0x8
  4192be:	8d 78 01             	lea    edi,[rax+0x1]
  4192c1:	48 b8 f0 0d fc ff ff 	movabs rax,0xfffffffffffc0df0
  4192c8:	ff ff ff 
  4192cb:	66 42 0f fe 0c 38    	paddd  xmm1,XMMWORD PTR [rax+r15*1]
  4192d1:	41 89 f9             	mov    r9d,edi
  4192d4:	48 b8 10 0e fc ff ff 	movabs rax,0xfffffffffffc0e10
  4192db:	ff ff ff 
	for (; l >= sizeof pad; l -= sizeof pad)
  4192de:	66 42 0f 6f 14 38    	movdqa xmm2,XMMWORD PTR [rax+r15*1]
  4192e4:	41 c1 e9 02          	shr    r9d,0x2
  4192e8:	66 0f 6f c1          	movdqa xmm0,xmm1
  4192ec:	83 c1 01             	add    ecx,0x1
  4192ef:	66 0f fe cb          	paddd  xmm1,xmm3
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4192f3:	89 d6                	mov    esi,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  4192f5:	66 0f fe c2          	paddd  xmm0,xmm2
  4192f9:	44 39 c9             	cmp    ecx,r9d
  4192fc:	72 ea                	jb     4192e8 <fmt_fp.cold+0x49f>
  4192fe:	89 f8                	mov    eax,edi
  419300:	66 0f 70 c0 ff       	pshufd xmm0,xmm0,0xff
  419305:	83 e0 fc             	and    eax,0xfffffffc
  419308:	66 0f 7e c1          	movd   ecx,xmm0
  41930c:	69 d0 00 ff ff ff    	imul   edx,eax,0xffffff00
  419312:	39 c7                	cmp    edi,eax
  419314:	0f 84 be 12 00 00    	je     41a5d8 <fmt_fp+0x1118>
  41931a:	41 01 d0             	add    r8d,edx
  41931d:	44 89 c1             	mov    ecx,r8d
  419320:	41 81 f8 ff 00 00 00 	cmp    r8d,0xff
  419327:	0f 86 ab 12 00 00    	jbe    41a5d8 <fmt_fp+0x1118>
  41932d:	81 e9 00 01 00 00    	sub    ecx,0x100
  419333:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  419339:	0f 86 99 12 00 00    	jbe    41a5d8 <fmt_fp+0x1118>
  41933f:	41 8d 88 00 fe ff ff 	lea    ecx,[r8-0x200]
  419346:	e9 8d 12 00 00       	jmp    41a5d8 <fmt_fp+0x1118>
  41934b:	8d bb 00 ff ff ff    	lea    edi,[rbx-0x100]
  419351:	66 0f 6e f3          	movd   xmm6,ebx
  419355:	45 31 c9             	xor    r9d,r9d
  419358:	48 b8 f0 0d fc ff ff 	movabs rax,0xfffffffffffc0df0
  41935f:	ff ff ff 
  419362:	89 fe                	mov    esi,edi
  419364:	66 0f 70 ce 00       	pshufd xmm1,xmm6,0x0
  419369:	66 42 0f fe 0c 38    	paddd  xmm1,XMMWORD PTR [rax+r15*1]
  41936f:	48 b8 10 0e fc ff ff 	movabs rax,0xfffffffffffc0e10
  419376:	ff ff ff 
  419379:	c1 ee 08             	shr    esi,0x8
  41937c:	66 42 0f 6f 14 38    	movdqa xmm2,XMMWORD PTR [rax+r15*1]
  419382:	48 ba 00 0e fc ff ff 	movabs rdx,0xfffffffffffc0e00
  419389:	ff ff ff 
  41938c:	83 c6 01             	add    esi,0x1
  41938f:	66 42 0f 6f 1c 3a    	movdqa xmm3,XMMWORD PTR [rdx+r15*1]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419395:	89 ca                	mov    edx,ecx
  419397:	41 89 f0             	mov    r8d,esi
  41939a:	41 c1 e8 02          	shr    r8d,0x2
  41939e:	66 0f 6f c1          	movdqa xmm0,xmm1
  4193a2:	41 83 c1 01          	add    r9d,0x1
  4193a6:	66 0f fe cb          	paddd  xmm1,xmm3
  4193aa:	89 d1                	mov    ecx,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  4193ac:	66 0f fe c2          	paddd  xmm0,xmm2
  4193b0:	45 39 c8             	cmp    r8d,r9d
  4193b3:	77 e9                	ja     41939e <fmt_fp.cold+0x555>
  4193b5:	89 f2                	mov    edx,esi
  4193b7:	66 0f 70 c0 ff       	pshufd xmm0,xmm0,0xff
  4193bc:	83 e2 fc             	and    edx,0xfffffffc
  4193bf:	66 0f 7e 44 24 08    	movd   DWORD PTR [rsp+0x8],xmm0
  4193c5:	69 c2 00 ff ff ff    	imul   eax,edx,0xffffff00
  4193cb:	39 f2                	cmp    edx,esi
  4193cd:	0f 84 ac 0a 00 00    	je     419e7f <fmt_fp+0x9bf>
  4193d3:	01 f8                	add    eax,edi
  4193d5:	89 44 24 08          	mov    DWORD PTR [rsp+0x8],eax
  4193d9:	89 c3                	mov    ebx,eax
  4193db:	3d ff 00 00 00       	cmp    eax,0xff
  4193e0:	0f 86 99 0a 00 00    	jbe    419e7f <fmt_fp+0x9bf>
  4193e6:	81 eb 00 01 00 00    	sub    ebx,0x100
  4193ec:	89 5c 24 08          	mov    DWORD PTR [rsp+0x8],ebx
  4193f0:	81 fb ff 00 00 00    	cmp    ebx,0xff
  4193f6:	0f 86 83 0a 00 00    	jbe    419e7f <fmt_fp+0x9bf>
  4193fc:	2d 00 02 00 00       	sub    eax,0x200
  419401:	89 44 24 08          	mov    DWORD PTR [rsp+0x8],eax
  419405:	e9 75 0a 00 00       	jmp    419e7f <fmt_fp+0x9bf>
  41940a:	8d b5 00 ff ff ff    	lea    esi,[rbp-0x100]
  419410:	66 0f 6e fd          	movd   xmm7,ebp
  419414:	45 31 c0             	xor    r8d,r8d
  419417:	48 b8 f0 0d fc ff ff 	movabs rax,0xfffffffffffc0df0
  41941e:	ff ff ff 
  419421:	89 f7                	mov    edi,esi
  419423:	66 0f 70 cf 00       	pshufd xmm1,xmm7,0x0
  419428:	48 ba 00 0e fc ff ff 	movabs rdx,0xfffffffffffc0e00
  41942f:	ff ff ff 
  419432:	c1 ef 08             	shr    edi,0x8
  419435:	66 42 0f fe 0c 38    	paddd  xmm1,XMMWORD PTR [rax+r15*1]
  41943b:	66 42 0f 6f 1c 3a    	movdqa xmm3,XMMWORD PTR [rdx+r15*1]
  419441:	48 b8 10 0e fc ff ff 	movabs rax,0xfffffffffffc0e10
  419448:	ff ff ff 
  41944b:	83 c7 01             	add    edi,0x1
  41944e:	66 42 0f 6f 14 38    	movdqa xmm2,XMMWORD PTR [rax+r15*1]
  419454:	41 89 f9             	mov    r9d,edi
  419457:	41 c1 e9 02          	shr    r9d,0x2
  41945b:	66 0f 6f c1          	movdqa xmm0,xmm1
  41945f:	41 83 c0 01          	add    r8d,0x1
  419463:	66 0f fe cb          	paddd  xmm1,xmm3
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419467:	89 ca                	mov    edx,ecx
	for (; l >= sizeof pad; l -= sizeof pad)
  419469:	66 0f fe c2          	paddd  xmm0,xmm2
  41946d:	45 39 c8             	cmp    r8d,r9d
  419470:	72 e9                	jb     41945b <fmt_fp.cold+0x612>
  419472:	89 f8                	mov    eax,edi
  419474:	66 0f 70 c0 ff       	pshufd xmm0,xmm0,0xff
  419479:	83 e0 fc             	and    eax,0xfffffffc
  41947c:	66 41 0f 7e c4       	movd   r12d,xmm0
  419481:	69 c8 00 ff ff ff    	imul   ecx,eax,0xffffff00
  419487:	39 c7                	cmp    edi,eax
  419489:	0f 84 ef 0a 00 00    	je     419f7e <fmt_fp+0xabe>
  41948f:	8d 04 0e             	lea    eax,[rsi+rcx*1]
  419492:	41 89 c4             	mov    r12d,eax
  419495:	3d ff 00 00 00       	cmp    eax,0xff
  41949a:	0f 86 de 0a 00 00    	jbe    419f7e <fmt_fp+0xabe>
  4194a0:	41 81 ec 00 01 00 00 	sub    r12d,0x100
  4194a7:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  4194ae:	0f 86 ca 0a 00 00    	jbe    419f7e <fmt_fp+0xabe>
  4194b4:	44 8d a0 00 fe ff ff 	lea    r12d,[rax-0x200]
  4194bb:	e9 be 0a 00 00       	jmp    419f7e <fmt_fp+0xabe>

00000000004194c0 <fmt_fp>:
#if LDBL_MANT_DIG == 53
typedef char compiler_defines_long_double_incorrectly[9-(int)sizeof(long double)];
#endif

static int fmt_fp(FILE *f, long double y, int w, int p, int fl, int t)
{
  4194c0:	f3 0f 1e fa          	endbr64 
  4194c4:	41 57                	push   r15
  4194c6:	41 56                	push   r14
  4194c8:	41 55                	push   r13
  4194ca:	41 54                	push   r12
  4194cc:	55                   	push   rbp
  4194cd:	53                   	push   rbx
  4194ce:	48 81 ec 00 10 00 00 	sub    rsp,0x1000
  4194d5:	48 83 0c 24 00       	or     QWORD PTR [rsp],0x0
  4194da:	48 81 ec 48 0e 00 00 	sub    rsp,0xe48
  4194e1:	4c 8d 3d dc ff ff ff 	lea    r15,[rip+0xffffffffffffffdc]        # 4194c4 <fmt_fp+0x4>
  4194e8:	49 bb 4c 7f 04 00 00 	movabs r11,0x47f4c
  4194ef:	00 00 00 
	const char *prefix="-0X+0X 0X-0x+0x 0x";
	int pl;
	char ebuf0[3*sizeof(int)], *ebuf=&ebuf0[3*sizeof(int)], *estr;

	pl=1;
	if (signbit(y)) {
  4194f2:	48 b8 30 ca fb ff ff 	movabs rax,0xfffffffffffbca30
  4194f9:	ff ff ff 
  4194fc:	4d 01 df             	add    r15,r11
  4194ff:	4c 01 f8             	add    rax,r15
{
  419502:	89 74 24 58          	mov    DWORD PTR [rsp+0x58],esi
  419506:	49 89 fe             	mov    r14,rdi
  419509:	89 14 24             	mov    DWORD PTR [rsp],edx
  41950c:	89 4c 24 14          	mov    DWORD PTR [rsp+0x14],ecx
  419510:	44 89 44 24 20       	mov    DWORD PTR [rsp+0x20],r8d
	int e2=0, e, i, j, l;
  419515:	c7 44 24 60 00 00 00 	mov    DWORD PTR [rsp+0x60],0x0
  41951c:	00 
	if (signbit(y)) {
  41951d:	ff b4 24 88 1e 00 00 	push   QWORD PTR [rsp+0x1e88]
  419524:	ff b4 24 88 1e 00 00 	push   QWORD PTR [rsp+0x1e88]
  41952b:	ff d0                	call   rax
  41952d:	89 44 24 38          	mov    DWORD PTR [rsp+0x38],eax
  419531:	59                   	pop    rcx
  419532:	5e                   	pop    rsi
  419533:	85 c0                	test   eax,eax
  419535:	0f 84 1d 04 00 00    	je     419958 <fmt_fp+0x498>
		y=-y;
  41953b:	db ac 24 80 1e 00 00 	fld    TBYTE PTR [rsp+0x1e80]
	pl=1;
  419542:	c7 44 24 28 01 00 00 	mov    DWORD PTR [rsp+0x28],0x1
  419549:	00 
	const char *prefix="-0X+0X 0X-0x+0x 0x";
  41954a:	48 b8 10 09 fc ff ff 	movabs rax,0xfffffffffffc0910
  419551:	ff ff ff 
  419554:	bb 03 00 00 00       	mov    ebx,0x3
  419559:	4c 01 f8             	add    rax,r15
  41955c:	41 bd 03 00 00 00    	mov    r13d,0x3
  419562:	bd 04 00 00 00       	mov    ebp,0x4
  419567:	48 c7 44 24 38 01 00 	mov    QWORD PTR [rsp+0x38],0x1
  41956e:	00 00 
  419570:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
		y=-y;
  419575:	d9 e0                	fchs   
  419577:	db bc 24 80 1e 00 00 	fstp   TBYTE PTR [rsp+0x1e80]
		prefix+=3;
	} else if (fl & PAD_POS) {
		prefix+=6;
	} else prefix++, pl=0;

	if (!isfinite(y)) {
  41957e:	48 b8 d0 c9 fb ff ff 	movabs rax,0xfffffffffffbc9d0
  419585:	ff ff ff 
  419588:	ff b4 24 88 1e 00 00 	push   QWORD PTR [rsp+0x1e88]
  41958f:	4c 01 f8             	add    rax,r15
  419592:	ff b4 24 88 1e 00 00 	push   QWORD PTR [rsp+0x1e88]
  419599:	ff d0                	call   rax
  41959b:	41 5c                	pop    r12
  41959d:	5a                   	pop    rdx
  41959e:	83 f8 01             	cmp    eax,0x1
  4195a1:	0f 8e 61 0a 00 00    	jle    41a008 <fmt_fp+0xb48>
		out(f, s, 3);
		pad(f, ' ', w, 3+pl, fl^LEFT_ADJ);
		return MAX(w, 3+pl);
	}

	y = frexpl(y, &e2) * 2;
  4195a7:	48 b8 50 ca fb ff ff 	movabs rax,0xfffffffffffbca50
  4195ae:	ff ff ff 
  4195b1:	48 8d 7c 24 60       	lea    rdi,[rsp+0x60]
  4195b6:	ff b4 24 88 1e 00 00 	push   QWORD PTR [rsp+0x1e88]
  4195bd:	4c 01 f8             	add    rax,r15
  4195c0:	ff b4 24 88 1e 00 00 	push   QWORD PTR [rsp+0x1e88]
  4195c7:	ff d0                	call   rax
	if (y) e2--;
  4195c9:	41 5a                	pop    r10
	y = frexpl(y, &e2) * 2;
  4195cb:	d8 c0                	fadd   st,st(0)
	if (y) e2--;
  4195cd:	41 5b                	pop    r11
  4195cf:	d9 ee                	fldz   
  4195d1:	d9 c9                	fxch   st(1)
  4195d3:	db e9                	fucomi st,st(1)
  4195d5:	dd d9                	fstp   st(1)
  4195d7:	0f 8a c3 03 00 00    	jp     4199a0 <fmt_fp+0x4e0>
  4195dd:	0f 85 bd 03 00 00    	jne    4199a0 <fmt_fp+0x4e0>

	if ((t|32)=='a') {
  4195e3:	44 8b 5c 24 20       	mov    r11d,DWORD PTR [rsp+0x20]
	if (y) e2--;
  4195e8:	44 8b 4c 24 60       	mov    r9d,DWORD PTR [rsp+0x60]
	if ((t|32)=='a') {
  4195ed:	41 83 cb 20          	or     r11d,0x20
  4195f1:	41 83 fb 61          	cmp    r11d,0x61
  4195f5:	0f 84 c5 03 00 00    	je     4199c0 <fmt_fp+0x500>
		pad(f, '0', l-(ebuf-estr)-(s-buf), 0, 0);
		out(f, estr, ebuf-estr);
		pad(f, ' ', w, pl+l, fl^LEFT_ADJ);
		return MAX(w, pl+l);
	}
	if (p<0) p=6;
  4195fb:	8b 3c 24             	mov    edi,DWORD PTR [rsp]
  4195fe:	85 ff                	test   edi,edi
  419600:	0f 88 82 17 00 00    	js     41ad88 <fmt_fp+0x18c8>

	if (a<z) for (i=10, e=9*(r-a); *a>=i; i*=10, e++);
	else e=0;

	/* Perform rounding: j is precision after the radix (possibly neg) */
	j = p - ((t|32)!='f')*e - ((t|32)=='g' && p);
  419606:	0f 95 44 24 40       	setne  BYTE PTR [rsp+0x40]
	if (y) y *= 0x1p28, e2-=28;
  41960b:	d9 ee                	fldz   
  41960d:	d9 c9                	fxch   st(1)
  41960f:	db e9                	fucomi st,st(1)
  419611:	dd d9                	fstp   st(1)
  419613:	0f 8a 70 0c 00 00    	jp     41a289 <fmt_fp+0xdc9>
  419619:	0f 85 6a 0c 00 00    	jne    41a289 <fmt_fp+0xdc9>
	if (e2<0) a=r=z=big;
  41961f:	d9 7c 24 5e          	fnstcw WORD PTR [rsp+0x5e]
  419623:	45 85 c9             	test   r9d,r9d
  419626:	48 8d 84 24 90 01 00 	lea    rax,[rsp+0x190]
  41962d:	00 
  41962e:	48 8d 94 24 38 1d 00 	lea    rdx,[rsp+0x1d38]
  419635:	00 
  419636:	48 0f 49 c2          	cmovns rax,rdx
  41963a:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
	else a=r=z=big+sizeof(big)/sizeof(*big) - LDBL_MANT_DIG - 1;
  41963f:	48 89 c3             	mov    rbx,rax
  419642:	48 b8 98 0d fc ff ff 	movabs rax,0xfffffffffffc0d98
  419649:	ff ff ff 
		y = 1000000000*(y-*z++);
  41964c:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  419650:	0f b7 44 24 5e       	movzx  eax,WORD PTR [rsp+0x5e]
  419655:	80 cc 0c             	or     ah,0xc
  419658:	66 89 44 24 5c       	mov    WORD PTR [rsp+0x5c],ax
	} while (y);
  41965d:	d9 ee                	fldz   
  41965f:	d9 ca                	fxch   st(2)
  419661:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		*z = y;
  419668:	d9 c0                	fld    st(0)
  41966a:	d9 6c 24 5c          	fldcw  WORD PTR [rsp+0x5c]
  41966e:	df 7c 24 08          	fistp  QWORD PTR [rsp+0x8]
  419672:	d9 6c 24 5e          	fldcw  WORD PTR [rsp+0x5e]
		y = 1000000000*(y-*z++);
  419676:	48 83 c3 04          	add    rbx,0x4
		*z = y;
  41967a:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
  41967f:	89 43 fc             	mov    DWORD PTR [rbx-0x4],eax
		y = 1000000000*(y-*z++);
  419682:	89 c0                	mov    eax,eax
  419684:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  419689:	df 6c 24 08          	fild   QWORD PTR [rsp+0x8]
  41968d:	de e9                	fsubp  st(1),st
  41968f:	d8 c9                	fmul   st,st(1)
	} while (y);
  419691:	db ea                	fucomi st,st(2)
  419693:	7a d3                	jp     419668 <fmt_fp+0x1a8>
  419695:	75 d1                	jne    419668 <fmt_fp+0x1a8>
  419697:	dd d8                	fstp   st(0)
  419699:	dd d8                	fstp   st(0)
  41969b:	dd d8                	fstp   st(0)
	while (e2>0) {
  41969d:	48 8b 6c 24 18       	mov    rbp,QWORD PTR [rsp+0x18]
  4196a2:	45 85 c9             	test   r9d,r9d
  4196a5:	0f 8e 8a 00 00 00    	jle    419735 <fmt_fp+0x275>
			*d = x % 1000000000;
  4196ab:	49 b8 53 5a 9b a0 2f 	movabs r8,0x44b82fa09b5a53
  4196b2:	b8 44 00 
  4196b5:	0f 1f 00             	nop    DWORD PTR [rax]
		int sh=MIN(29,e2);
  4196b8:	b9 1d 00 00 00       	mov    ecx,0x1d
		for (d=z-1; d>=a; d--) {
  4196bd:	48 8d 7b fc          	lea    rdi,[rbx-0x4]
		int sh=MIN(29,e2);
  4196c1:	41 39 c9             	cmp    r9d,ecx
  4196c4:	41 0f 4e c9          	cmovle ecx,r9d
		for (d=z-1; d>=a; d--) {
  4196c8:	48 39 ef             	cmp    rdi,rbp
  4196cb:	72 3f                	jb     41970c <fmt_fp+0x24c>
		uint32_t carry=0;
  4196cd:	31 c0                	xor    eax,eax
  4196cf:	90                   	nop
			uint64_t x = ((uint64_t)*d<<sh)+carry;
  4196d0:	8b 37                	mov    esi,DWORD PTR [rdi]
		for (d=z-1; d>=a; d--) {
  4196d2:	48 83 ef 04          	sub    rdi,0x4
			uint64_t x = ((uint64_t)*d<<sh)+carry;
  4196d6:	48 d3 e6             	shl    rsi,cl
  4196d9:	48 01 c6             	add    rsi,rax
			*d = x % 1000000000;
  4196dc:	48 89 f2             	mov    rdx,rsi
  4196df:	48 c1 ea 09          	shr    rdx,0x9
  4196e3:	48 89 d0             	mov    rax,rdx
  4196e6:	49 f7 e0             	mul    r8
  4196e9:	48 c1 ea 0b          	shr    rdx,0xb
  4196ed:	48 69 c2 00 ca 9a 3b 	imul   rax,rdx,0x3b9aca00
  4196f4:	48 29 c6             	sub    rsi,rax
			carry = x / 1000000000;
  4196f7:	89 d0                	mov    eax,edx
			*d = x % 1000000000;
  4196f9:	89 77 04             	mov    DWORD PTR [rdi+0x4],esi
		for (d=z-1; d>=a; d--) {
  4196fc:	48 39 ef             	cmp    rdi,rbp
  4196ff:	73 cf                	jae    4196d0 <fmt_fp+0x210>
		if (carry) *--a = carry;
  419701:	85 c0                	test   eax,eax
  419703:	74 07                	je     41970c <fmt_fp+0x24c>
  419705:	89 55 fc             	mov    DWORD PTR [rbp-0x4],edx
  419708:	48 83 ed 04          	sub    rbp,0x4
		while (z>a && !z[-1]) z--;
  41970c:	48 39 dd             	cmp    rbp,rbx
  41970f:	72 10                	jb     419721 <fmt_fp+0x261>
  419711:	eb 15                	jmp    419728 <fmt_fp+0x268>
  419713:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  419718:	48 83 eb 04          	sub    rbx,0x4
  41971c:	48 39 eb             	cmp    rbx,rbp
  41971f:	76 07                	jbe    419728 <fmt_fp+0x268>
  419721:	8b 73 fc             	mov    esi,DWORD PTR [rbx-0x4]
  419724:	85 f6                	test   esi,esi
  419726:	74 f0                	je     419718 <fmt_fp+0x258>
		e2-=sh;
  419728:	41 29 c9             	sub    r9d,ecx
	while (e2>0) {
  41972b:	45 85 c9             	test   r9d,r9d
  41972e:	7f 88                	jg     4196b8 <fmt_fp+0x1f8>
  419730:	44 89 4c 24 60       	mov    DWORD PTR [rsp+0x60],r9d
	while (e2<0) {
  419735:	45 85 c9             	test   r9d,r9d
  419738:	0f 84 d3 00 00 00    	je     419811 <fmt_fp+0x351>
		int sh=MIN(9,-e2), need=1+(p+LDBL_MANT_DIG/3U+8)/9;
  41973e:	8b 04 24             	mov    eax,DWORD PTR [rsp]
			carry = (1000000000>>sh) * rm;
  419741:	4c 89 74 24 08       	mov    QWORD PTR [rsp+0x8],r14
  419746:	4c 8b 74 24 18       	mov    r14,QWORD PTR [rsp+0x18]
		int sh=MIN(9,-e2), need=1+(p+LDBL_MANT_DIG/3U+8)/9;
  41974b:	83 c0 1d             	add    eax,0x1d
  41974e:	48 69 c0 39 8e e3 38 	imul   rax,rax,0x38e38e39
  419755:	48 c1 e8 21          	shr    rax,0x21
		if (z-b > need) z = b+need;
  419759:	4c 8d 68 01          	lea    r13,[rax+0x1]
  41975d:	4e 8d 24 ad 00 00 00 	lea    r12,[r13*4+0x0]
  419764:	00 
  419765:	0f 1f 00             	nop    DWORD PTR [rax]
		int sh=MIN(9,-e2), need=1+(p+LDBL_MANT_DIG/3U+8)/9;
  419768:	41 83 f9 f7          	cmp    r9d,0xfffffff7
  41976c:	0f 8d 6e 08 00 00    	jge    419fe0 <fmt_fp+0xb20>
		if (!*a) a++;
  419772:	8b 45 00             	mov    eax,DWORD PTR [rbp+0x0]
		e2+=sh;
  419775:	41 83 c1 09          	add    r9d,0x9
		int sh=MIN(9,-e2), need=1+(p+LDBL_MANT_DIG/3U+8)/9;
  419779:	b9 09 00 00 00       	mov    ecx,0x9
		for (d=a; d<z; d++) {
  41977e:	48 39 dd             	cmp    rbp,rbx
  419781:	0f 83 6d 08 00 00    	jae    419ff4 <fmt_fp+0xb34>
			uint32_t rm = *d & (1<<sh)-1;
  419787:	41 b8 01 00 00 00    	mov    r8d,0x1
			carry = (1000000000>>sh) * rm;
  41978d:	41 ba 00 ca 9a 3b    	mov    r10d,0x3b9aca00
  419793:	48 89 ee             	mov    rsi,rbp
		uint32_t carry=0, *b;
  419796:	31 d2                	xor    edx,edx
			uint32_t rm = *d & (1<<sh)-1;
  419798:	41 d3 e0             	shl    r8d,cl
			carry = (1000000000>>sh) * rm;
  41979b:	41 d3 fa             	sar    r10d,cl
			uint32_t rm = *d & (1<<sh)-1;
  41979e:	41 83 e8 01          	sub    r8d,0x1
  4197a2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4197a8:	8b 06                	mov    eax,DWORD PTR [rsi]
		for (d=a; d<z; d++) {
  4197aa:	48 83 c6 04          	add    rsi,0x4
			*d = (*d>>sh) + carry;
  4197ae:	89 c7                	mov    edi,eax
			uint32_t rm = *d & (1<<sh)-1;
  4197b0:	44 21 c0             	and    eax,r8d
			carry = (1000000000>>sh) * rm;
  4197b3:	41 0f af c2          	imul   eax,r10d
			*d = (*d>>sh) + carry;
  4197b7:	d3 ef                	shr    edi,cl
  4197b9:	01 fa                	add    edx,edi
  4197bb:	89 56 fc             	mov    DWORD PTR [rsi-0x4],edx
			carry = (1000000000>>sh) * rm;
  4197be:	89 c2                	mov    edx,eax
		for (d=a; d<z; d++) {
  4197c0:	48 39 de             	cmp    rsi,rbx
  4197c3:	72 e3                	jb     4197a8 <fmt_fp+0x2e8>
		if (!*a) a++;
  4197c5:	8b 4d 00             	mov    ecx,DWORD PTR [rbp+0x0]
  4197c8:	48 8d 45 04          	lea    rax,[rbp+0x4]
  4197cc:	85 c9                	test   ecx,ecx
  4197ce:	48 0f 44 e8          	cmove  rbp,rax
		if (carry) *z++ = carry;
  4197d2:	85 d2                	test   edx,edx
  4197d4:	74 06                	je     4197dc <fmt_fp+0x31c>
  4197d6:	89 13                	mov    DWORD PTR [rbx],edx
  4197d8:	48 83 c3 04          	add    rbx,0x4
		b = (t|32)=='f' ? r : a;
  4197dc:	41 83 fb 66          	cmp    r11d,0x66
  4197e0:	4c 89 f0             	mov    rax,r14
		if (z-b > need) z = b+need;
  4197e3:	48 89 da             	mov    rdx,rbx
		b = (t|32)=='f' ? r : a;
  4197e6:	48 0f 45 c5          	cmovne rax,rbp
		if (z-b > need) z = b+need;
  4197ea:	48 29 c2             	sub    rdx,rax
  4197ed:	4c 01 e0             	add    rax,r12
  4197f0:	48 c1 fa 02          	sar    rdx,0x2
  4197f4:	4c 39 ea             	cmp    rdx,r13
  4197f7:	48 0f 4f d8          	cmovg  rbx,rax
	while (e2<0) {
  4197fb:	45 85 c9             	test   r9d,r9d
  4197fe:	0f 85 64 ff ff ff    	jne    419768 <fmt_fp+0x2a8>
  419804:	c7 44 24 60 00 00 00 	mov    DWORD PTR [rsp+0x60],0x0
  41980b:	00 
  41980c:	4c 8b 74 24 08       	mov    r14,QWORD PTR [rsp+0x8]
	if (a<z) for (i=10, e=9*(r-a); *a>=i; i*=10, e++);
  419811:	48 39 eb             	cmp    rbx,rbp
  419814:	0f 87 31 0a 00 00    	ja     41a24b <fmt_fp+0xd8b>
  41981a:	8b 04 24             	mov    eax,DWORD PTR [rsp]
	else e=0;
  41981d:	31 ff                	xor    edi,edi
	j = p - ((t|32)!='f')*e - ((t|32)=='g' && p);
  41981f:	31 d2                	xor    edx,edx
  419821:	41 83 fb 67          	cmp    r11d,0x67
	if (j < 9*(z-r-1)) {
  419825:	48 8b 74 24 18       	mov    rsi,QWORD PTR [rsp+0x18]
	j = p - ((t|32)!='f')*e - ((t|32)=='g' && p);
  41982a:	0f 94 c2             	sete   dl
  41982d:	23 54 24 40          	and    edx,DWORD PTR [rsp+0x40]
  419831:	29 d0                	sub    eax,edx
	if (j < 9*(z-r-1)) {
  419833:	48 89 da             	mov    rdx,rbx
  419836:	48 29 f2             	sub    rdx,rsi
  419839:	48 63 c8             	movsxd rcx,eax
  41983c:	48 c1 fa 02          	sar    rdx,0x2
  419840:	48 8d 54 d2 f7       	lea    rdx,[rdx+rdx*8-0x9]
  419845:	48 39 d1             	cmp    rcx,rdx
  419848:	0f 8d 9f 0b 00 00    	jge    41a3ed <fmt_fp+0xf2d>
		uint32_t x;
		/* We avoid C's broken division of negative numbers */
		d = r + 1 + ((j+9*LDBL_MAX_EXP)/9 - LDBL_MAX_EXP);
  41984e:	05 00 40 02 00       	add    eax,0x24000
  419853:	48 63 d0             	movsxd rdx,eax
  419856:	89 c1                	mov    ecx,eax
  419858:	48 69 d2 39 8e e3 38 	imul   rdx,rdx,0x38e38e39
  41985f:	c1 f9 1f             	sar    ecx,0x1f
  419862:	48 c1 fa 21          	sar    rdx,0x21
  419866:	29 ca                	sub    edx,ecx
  419868:	48 63 ca             	movsxd rcx,edx
		j += 9*LDBL_MAX_EXP;
		j %= 9;
  41986b:	8d 14 d2             	lea    edx,[rdx+rdx*8]
  41986e:	29 d0                	sub    eax,edx
		d = r + 1 + ((j+9*LDBL_MAX_EXP)/9 - LDBL_MAX_EXP);
  419870:	48 8d b4 8e 04 00 ff 	lea    rsi,[rsi+rcx*4-0xfffc]
  419877:	ff 
		for (i=10, j++; j<9; i*=10, j++);
  419878:	83 f8 08             	cmp    eax,0x8
  41987b:	0f 84 7e 23 00 00    	je     41bbff <fmt_fp+0x273f>
  419881:	ba 08 00 00 00       	mov    edx,0x8
  419886:	29 c2                	sub    edx,eax
  419888:	41 89 d0             	mov    r8d,edx
  41988b:	83 f8 07             	cmp    eax,0x7
  41988e:	0f 84 9b 23 00 00    	je     41bc2f <fmt_fp+0x276f>
  419894:	89 d0                	mov    eax,edx
  419896:	d1 e8                	shr    eax,1
  419898:	83 f8 01             	cmp    eax,0x1
  41989b:	0f 84 10 23 00 00    	je     41bbb1 <fmt_fp+0x26f1>
  4198a1:	83 f8 02             	cmp    eax,0x2
  4198a4:	0f 84 2a 23 00 00    	je     41bbd4 <fmt_fp+0x2714>
  4198aa:	83 f8 03             	cmp    eax,0x3
  4198ad:	0f 84 86 23 00 00    	je     41bc39 <fmt_fp+0x2779>
  4198b3:	83 f8 04             	cmp    eax,0x4
  4198b6:	0f 84 9c 23 00 00    	je     41bc58 <fmt_fp+0x2798>
  4198bc:	83 f8 05             	cmp    eax,0x5
  4198bf:	0f 84 c8 23 00 00    	je     41bc8d <fmt_fp+0x27cd>
  4198c5:	83 f8 06             	cmp    eax,0x6
  4198c8:	0f 84 aa 23 00 00    	je     41bc78 <fmt_fp+0x27b8>
  4198ce:	b9 00 00 8a 5d       	mov    ecx,0x5d8a0000
  4198d3:	83 f8 08             	cmp    eax,0x8
  4198d6:	0f 85 b3 21 00 00    	jne    41ba8f <fmt_fp+0x25cf>
  4198dc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		x = *d % i;
  4198e0:	41 89 ca             	mov    r10d,ecx
  4198e3:	44 8b 0e             	mov    r9d,DWORD PTR [rsi]
  4198e6:	31 d2                	xor    edx,edx
  4198e8:	44 89 c8             	mov    eax,r9d
  4198eb:	41 f7 f2             	div    r10d
  4198ee:	41 89 d0             	mov    r8d,edx
		/* Are there any significant digits past j? */
		if (x || d+1!=z) {
  4198f1:	85 d2                	test   edx,edx
  4198f3:	0f 85 68 0a 00 00    	jne    41a361 <fmt_fp+0xea1>
  4198f9:	48 8d 56 04          	lea    rdx,[rsi+0x4]
  4198fd:	48 39 d3             	cmp    rbx,rdx
  419900:	0f 84 6e 22 00 00    	je     41bb74 <fmt_fp+0x26b4>
			long double round = 2/LDBL_EPSILON;
			long double small;
			if ((*d/i & 1) || (i==1000000000 && d>a && (d[-1]&1)))
  419906:	a8 01                	test   al,0x1
  419908:	0f 85 30 21 00 00    	jne    41ba3e <fmt_fp+0x257e>
  41990e:	81 f9 00 ca 9a 3b    	cmp    ecx,0x3b9aca00
  419914:	75 09                	jne    41991f <fmt_fp+0x45f>
  419916:	48 39 ee             	cmp    rsi,rbp
  419919:	0f 87 ea 20 00 00    	ja     41ba09 <fmt_fp+0x2549>
  41991f:	48 b8 80 0d fc ff ff 	movabs rax,0xfffffffffffc0d80
  419926:	ff ff ff 
  419929:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
			long double round = 2/LDBL_EPSILON;
  41992d:	48 b8 7c 0d fc ff ff 	movabs rax,0xfffffffffffc0d7c
  419934:	ff ff ff 
  419937:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
				round += 2;
			if (x<i/2) small=0x0.8p0;
  41993b:	48 b8 84 0d fc ff ff 	movabs rax,0xfffffffffffc0d84
  419942:	ff ff ff 
  419945:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  419949:	d9 c9                	fxch   st(1)
  41994b:	d9 ca                	fxch   st(2)
  41994d:	d9 c9                	fxch   st(1)
  41994f:	e9 50 0a 00 00       	jmp    41a3a4 <fmt_fp+0xee4>
  419954:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	} else if (fl & MARK_POS) {
  419958:	8b 44 24 14          	mov    eax,DWORD PTR [rsp+0x14]
  41995c:	f6 c4 08             	test   ah,0x8
  41995f:	0f 84 33 06 00 00    	je     419f98 <fmt_fp+0xad8>
  419965:	bb 03 00 00 00       	mov    ebx,0x3
  41996a:	41 bd 03 00 00 00    	mov    r13d,0x3
  419970:	bd 04 00 00 00       	mov    ebp,0x4
		prefix+=3;
  419975:	48 b8 13 09 fc ff ff 	movabs rax,0xfffffffffffc0913
  41997c:	ff ff ff 
  41997f:	4c 01 f8             	add    rax,r15
	pl=1;
  419982:	c7 44 24 28 01 00 00 	mov    DWORD PTR [rsp+0x28],0x1
  419989:	00 
  41998a:	48 c7 44 24 38 01 00 	mov    QWORD PTR [rsp+0x38],0x1
  419991:	00 00 
		prefix+=3;
  419993:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  419998:	e9 e1 fb ff ff       	jmp    41957e <fmt_fp+0xbe>
  41999d:	0f 1f 00             	nop    DWORD PTR [rax]
	if (y) e2--;
  4199a0:	8b 44 24 60          	mov    eax,DWORD PTR [rsp+0x60]
	if ((t|32)=='a') {
  4199a4:	44 8b 5c 24 20       	mov    r11d,DWORD PTR [rsp+0x20]
	if (y) e2--;
  4199a9:	44 8d 48 ff          	lea    r9d,[rax-0x1]
	if ((t|32)=='a') {
  4199ad:	41 83 cb 20          	or     r11d,0x20
	if (y) e2--;
  4199b1:	44 89 4c 24 60       	mov    DWORD PTR [rsp+0x60],r9d
	if ((t|32)=='a') {
  4199b6:	41 83 fb 61          	cmp    r11d,0x61
  4199ba:	0f 85 3b fc ff ff    	jne    4195fb <fmt_fp+0x13b>
		if (t&32) prefix += 9;
  4199c0:	48 8b 7c 24 30       	mov    rdi,QWORD PTR [rsp+0x30]
  4199c5:	f6 44 24 20 20       	test   BYTE PTR [rsp+0x20],0x20
  4199ca:	48 8d 47 09          	lea    rax,[rdi+0x9]
  4199ce:	48 0f 44 c7          	cmove  rax,rdi
  4199d2:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
		if (p<0 || p>=LDBL_MANT_DIG/4-1) re=0;
  4199d7:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  4199da:	83 f8 0e             	cmp    eax,0xe
  4199dd:	0f 87 9b 00 00 00    	ja     419a7e <fmt_fp+0x5be>
			while (re--) round*=16;
  4199e3:	0f 84 b9 22 00 00    	je     41bca2 <fmt_fp+0x27e2>
  4199e9:	83 f8 0d             	cmp    eax,0xd
  4199ec:	0f 84 13 23 00 00    	je     41bd05 <fmt_fp+0x2845>
  4199f2:	83 f8 0c             	cmp    eax,0xc
  4199f5:	0f 84 f7 22 00 00    	je     41bcf2 <fmt_fp+0x2832>
  4199fb:	83 f8 0b             	cmp    eax,0xb
  4199fe:	0f 84 db 22 00 00    	je     41bcdf <fmt_fp+0x281f>
  419a04:	83 f8 0a             	cmp    eax,0xa
  419a07:	0f 84 16 23 00 00    	je     41bd23 <fmt_fp+0x2863>
  419a0d:	83 f8 09             	cmp    eax,0x9
  419a10:	0f 84 b2 20 00 00    	je     41bac8 <fmt_fp+0x2608>
  419a16:	83 f8 08             	cmp    eax,0x8
  419a19:	0f 84 2a 23 00 00    	je     41bd49 <fmt_fp+0x2889>
  419a1f:	83 f8 07             	cmp    eax,0x7
  419a22:	0f 84 0e 23 00 00    	je     41bd36 <fmt_fp+0x2876>
  419a28:	83 f8 06             	cmp    eax,0x6
  419a2b:	0f 84 3e 23 00 00    	je     41bd6f <fmt_fp+0x28af>
  419a31:	83 f8 05             	cmp    eax,0x5
  419a34:	0f 84 22 23 00 00    	je     41bd5c <fmt_fp+0x289c>
  419a3a:	83 f8 04             	cmp    eax,0x4
  419a3d:	0f 84 78 23 00 00    	je     41bdbb <fmt_fp+0x28fb>
  419a43:	83 f8 03             	cmp    eax,0x3
  419a46:	0f 84 5c 23 00 00    	je     41bda8 <fmt_fp+0x28e8>
  419a4c:	83 f8 02             	cmp    eax,0x2
  419a4f:	0f 84 40 23 00 00    	je     41bd95 <fmt_fp+0x28d5>
  419a55:	83 f8 01             	cmp    eax,0x1
  419a58:	0f 84 24 23 00 00    	je     41bd82 <fmt_fp+0x28c2>
  419a5e:	48 b8 40 0d fc ff ff 	movabs rax,0xfffffffffffc0d40
  419a65:	ff ff ff 
  419a68:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
			if (*prefix=='-') {
  419a6c:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  419a71:	80 38 2d             	cmp    BYTE PTR [rax],0x2d
  419a74:	0f 84 ca 20 00 00    	je     41bb44 <fmt_fp+0x2684>
				y+=round;
  419a7a:	dc c1                	fadd   st(1),st
				y-=round;
  419a7c:	de e9                	fsubp  st(1),st
		estr=fmt_u(e2<0 ? -e2 : e2, ebuf);
  419a7e:	44 89 c9             	mov    ecx,r9d
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  419a81:	4c 8d 64 24 70       	lea    r12,[rsp+0x70]
  419a86:	48 bf cd cc cc cc cc 	movabs rdi,0xcccccccccccccccd
  419a8d:	cc cc cc 
		estr=fmt_u(e2<0 ? -e2 : e2, ebuf);
  419a90:	f7 d9                	neg    ecx
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  419a92:	4c 89 e6             	mov    rsi,r12
		estr=fmt_u(e2<0 ? -e2 : e2, ebuf);
  419a95:	41 0f 48 c9          	cmovs  ecx,r9d
  419a99:	48 63 c9             	movsxd rcx,ecx
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  419a9c:	45 85 c9             	test   r9d,r9d
  419a9f:	0f 84 fe 1e 00 00    	je     41b9a3 <fmt_fp+0x24e3>
  419aa5:	0f 1f 00             	nop    DWORD PTR [rax]
  419aa8:	48 89 c8             	mov    rax,rcx
  419aab:	48 83 ee 01          	sub    rsi,0x1
  419aaf:	48 f7 e7             	mul    rdi
  419ab2:	48 89 c8             	mov    rax,rcx
  419ab5:	48 c1 ea 03          	shr    rdx,0x3
  419ab9:	4c 8d 04 92          	lea    r8,[rdx+rdx*4]
  419abd:	4d 01 c0             	add    r8,r8
  419ac0:	4c 29 c0             	sub    rax,r8
  419ac3:	83 c0 30             	add    eax,0x30
  419ac6:	88 06                	mov    BYTE PTR [rsi],al
  419ac8:	48 89 c8             	mov    rax,rcx
  419acb:	48 89 d1             	mov    rcx,rdx
  419ace:	48 83 f8 09          	cmp    rax,0x9
  419ad2:	77 d4                	ja     419aa8 <fmt_fp+0x5e8>
		if (estr==ebuf) *--estr='0';
  419ad4:	4c 39 e6             	cmp    rsi,r12
  419ad7:	0f 84 c6 1e 00 00    	je     41b9a3 <fmt_fp+0x24e3>
		*--estr = t+('p'-'a');
  419add:	8b 7c 24 20          	mov    edi,DWORD PTR [rsp+0x20]
  419ae1:	48 8d 46 fe          	lea    rax,[rsi-0x2]
		*--estr = (e2<0 ? '-' : '+');
  419ae5:	41 c1 f9 1f          	sar    r9d,0x1f
		*--estr = t+('p'-'a');
  419ae9:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
		*--estr = (e2<0 ? '-' : '+');
  419aee:	41 83 e1 02          	and    r9d,0x2
		*--estr = t+('p'-'a');
  419af2:	89 f8                	mov    eax,edi
		*--estr = (e2<0 ? '-' : '+');
  419af4:	41 83 c1 2b          	add    r9d,0x2b
		*--estr = t+('p'-'a');
  419af8:	83 c0 0f             	add    eax,0xf
		*--estr = (e2<0 ? '-' : '+');
  419afb:	44 88 4e ff          	mov    BYTE PTR [rsi-0x1],r9b
		*--estr = t+('p'-'a');
  419aff:	88 46 fe             	mov    BYTE PTR [rsi-0x2],al
			*s++=xdigits[x]|(t&32);
  419b02:	89 fe                	mov    esi,edi
  419b04:	83 e6 20             	and    esi,0x20
  419b07:	f6 44 24 14 08       	test   BYTE PTR [rsp+0x14],0x8
  419b0c:	0f 85 b8 18 00 00    	jne    41b3ca <fmt_fp+0x1f0a>
  419b12:	d9 7c 24 5e          	fnstcw WORD PTR [rsp+0x5e]
		s=buf;
  419b16:	4c 89 e2             	mov    rdx,r12
  419b19:	48 bf 90 0d fc ff ff 	movabs rdi,0xfffffffffffc0d90
  419b20:	ff ff ff 
  419b23:	48 b9 50 0b fc ff ff 	movabs rcx,0xfffffffffffc0b50
  419b2a:	ff ff ff 
			y=16*(y-x);
  419b2d:	42 d9 04 3f          	fld    DWORD PTR [rdi+r15*1]
			*s++=xdigits[x]|(t&32);
  419b31:	4c 01 f9             	add    rcx,r15
			if (s-buf==1 && (y||p>0||(fl&ALT_FORM))) *s++='.';
  419b34:	bf 01 00 00 00       	mov    edi,0x1
  419b39:	0f b7 44 24 5e       	movzx  eax,WORD PTR [rsp+0x5e]
  419b3e:	80 cc 0c             	or     ah,0xc
  419b41:	d9 ee                	fldz   
  419b43:	d9 ca                	fxch   st(2)
  419b45:	66 89 44 24 5c       	mov    WORD PTR [rsp+0x5c],ax
  419b4a:	eb 11                	jmp    419b5d <fmt_fp+0x69d>
  419b4c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
			*s++=xdigits[x]|(t&32);
  419b50:	48 89 c2             	mov    rdx,rax
		} while (y);
  419b53:	db ea                	fucomi st,st(2)
  419b55:	7a 06                	jp     419b5d <fmt_fp+0x69d>
  419b57:	0f 84 69 20 00 00    	je     41bbc6 <fmt_fp+0x2706>
			int x=y;
  419b5d:	d9 c0                	fld    st(0)
  419b5f:	d9 6c 24 5c          	fldcw  WORD PTR [rsp+0x5c]
  419b63:	db 5c 24 08          	fistp  DWORD PTR [rsp+0x8]
  419b67:	d9 6c 24 5e          	fldcw  WORD PTR [rsp+0x5e]
			y=16*(y-x);
  419b6b:	db 44 24 08          	fild   DWORD PTR [rsp+0x8]
			*s++=xdigits[x]|(t&32);
  419b6f:	48 63 44 24 08       	movsxd rax,DWORD PTR [rsp+0x8]
  419b74:	44 0f b6 1c 01       	movzx  r11d,BYTE PTR [rcx+rax*1]
			if (s-buf==1 && (y||p>0||(fl&ALT_FORM))) *s++='.';
  419b79:	48 8d 42 01          	lea    rax,[rdx+0x1]
			y=16*(y-x);
  419b7d:	de e9                	fsubp  st(1),st
			*s++=xdigits[x]|(t&32);
  419b7f:	41 09 f3             	or     r11d,esi
  419b82:	44 88 1a             	mov    BYTE PTR [rdx],r11b
			y=16*(y-x);
  419b85:	d8 c9                	fmul   st,st(1)
			if (s-buf==1 && (y||p>0||(fl&ALT_FORM))) *s++='.';
  419b87:	4c 39 e2             	cmp    rdx,r12
  419b8a:	75 c4                	jne    419b50 <fmt_fp+0x690>
  419b8c:	44 8b 0c 24          	mov    r9d,DWORD PTR [rsp]
  419b90:	45 85 c9             	test   r9d,r9d
  419b93:	0f 8f f0 10 00 00    	jg     41ac89 <fmt_fp+0x17c9>
  419b99:	db ea                	fucomi st,st(2)
  419b9b:	41 0f 9a c0          	setp   r8b
  419b9f:	44 0f 45 c7          	cmovne r8d,edi
  419ba3:	45 84 c0             	test   r8b,r8b
  419ba6:	0f 85 dd 10 00 00    	jne    41ac89 <fmt_fp+0x17c9>
  419bac:	dd d8                	fstp   st(0)
  419bae:	dd d8                	fstp   st(0)
  419bb0:	dd d8                	fstp   st(0)
  419bb2:	eb 06                	jmp    419bba <fmt_fp+0x6fa>
  419bb4:	dd d8                	fstp   st(0)
  419bb6:	dd d8                	fstp   st(0)
  419bb8:	dd d8                	fstp   st(0)
		if (p > INT_MAX-2-(ebuf-estr)-pl)
  419bba:	4c 89 e7             	mov    rdi,r12
  419bbd:	ba fd ff ff 7f       	mov    edx,0x7ffffffd
  419bc2:	48 2b 7c 24 28       	sub    rdi,QWORD PTR [rsp+0x28]
  419bc7:	48 63 0c 24          	movsxd rcx,DWORD PTR [rsp]
  419bcb:	48 29 fa             	sub    rdx,rdi
  419bce:	48 89 7c 24 20       	mov    QWORD PTR [rsp+0x20],rdi
  419bd3:	48 29 da             	sub    rdx,rbx
  419bd6:	48 39 d1             	cmp    rcx,rdx
  419bd9:	0f 8f 9f 11 00 00    	jg     41ad7e <fmt_fp+0x18be>
		if (p && s-buf-2 < p)
  419bdf:	4c 29 e0             	sub    rax,r12
  419be2:	48 89 fe             	mov    rsi,rdi
  419be5:	48 89 c3             	mov    rbx,rax
  419be8:	48 89 44 24 48       	mov    QWORD PTR [rsp+0x48],rax
			l = (s-buf) + (ebuf-estr);
  419bed:	89 f8                	mov    eax,edi
		if (p && s-buf-2 < p)
  419bef:	8b 3c 24             	mov    edi,DWORD PTR [rsp]
			l = (s-buf) + (ebuf-estr);
  419bf2:	01 d8                	add    eax,ebx
		if (p && s-buf-2 < p)
  419bf4:	85 ff                	test   edi,edi
  419bf6:	74 0d                	je     419c05 <fmt_fp+0x745>
  419bf8:	48 8d 53 ff          	lea    rdx,[rbx-0x1]
  419bfc:	48 39 d1             	cmp    rcx,rdx
  419bff:	0f 8d 21 1e 00 00    	jge    41ba26 <fmt_fp+0x2566>
			l = (s-buf) + (ebuf-estr);
  419c05:	c7 44 24 08 00 00 00 	mov    DWORD PTR [rsp+0x8],0x0
  419c0c:	00 
  419c0d:	c7 44 24 38 00 00 00 	mov    DWORD PTR [rsp+0x38],0x0
  419c14:	00 
		pad(f, ' ', w, pl+l, fl);
  419c15:	44 01 e8             	add    eax,r13d
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  419c18:	3b 44 24 58          	cmp    eax,DWORD PTR [rsp+0x58]
		pad(f, ' ', w, pl+l, fl);
  419c1c:	89 44 24 18          	mov    DWORD PTR [rsp+0x18],eax
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  419c20:	0f 9d 04 24          	setge  BYTE PTR [rsp]
  419c24:	0f b6 04 24          	movzx  eax,BYTE PTR [rsp]
  419c28:	f7 44 24 14 00 20 01 	test   DWORD PTR [rsp+0x14],0x12000
  419c2f:	00 
  419c30:	0f 85 c4 00 00 00    	jne    419cfa <fmt_fp+0x83a>
  419c36:	84 c0                	test   al,al
  419c38:	0f 85 bc 00 00 00    	jne    419cfa <fmt_fp+0x83a>
	l = w - l;
  419c3e:	8b 6c 24 58          	mov    ebp,DWORD PTR [rsp+0x58]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  419c42:	b8 00 01 00 00       	mov    eax,0x100
	l = w - l;
  419c47:	2b 6c 24 18          	sub    ebp,DWORD PTR [rsp+0x18]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  419c4b:	4c 8d 94 24 90 01 00 	lea    r10,[rsp+0x190]
  419c52:	00 
  419c53:	39 c5                	cmp    ebp,eax
  419c55:	4c 89 54 24 40       	mov    QWORD PTR [rsp+0x40],r10
  419c5a:	4c 89 d7             	mov    rdi,r10
  419c5d:	be 20 00 00 00       	mov    esi,0x20
  419c62:	0f 4e c5             	cmovle eax,ebp
  419c65:	48 63 d0             	movsxd rdx,eax
  419c68:	48 b8 3c 64 fb ff ff 	movabs rax,0xfffffffffffb643c
  419c6f:	ff ff ff 
  419c72:	4c 01 f8             	add    rax,r15
  419c75:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  419c77:	81 fd ff 00 00 00    	cmp    ebp,0xff
  419c7d:	4c 8b 54 24 40       	mov    r10,QWORD PTR [rsp+0x40]
  419c82:	0f 8e 90 20 00 00    	jle    41bd18 <fmt_fp+0x2858>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419c88:	48 bf 20 ce fb ff ff 	movabs rdi,0xfffffffffffbce20
  419c8f:	ff ff ff 
  419c92:	41 8b 06             	mov    eax,DWORD PTR [r14]
  419c95:	8d 9d 00 ff ff ff    	lea    ebx,[rbp-0x100]
  419c9b:	4c 89 d5             	mov    rbp,r10
  419c9e:	48 89 7c 24 40       	mov    QWORD PTR [rsp+0x40],rdi
  419ca3:	83 e0 20             	and    eax,0x20
  419ca6:	89 c6                	mov    esi,eax
  419ca8:	0f 84 e8 0f 00 00    	je     41ac96 <fmt_fp+0x17d6>
	for (; l >= sizeof pad; l -= sizeof pad)
  419cae:	49 89 ea             	mov    r10,rbp
  419cb1:	81 fb ff 00 00 00    	cmp    ebx,0xff
  419cb7:	7e 47                	jle    419d00 <fmt_fp+0x840>
  419cb9:	8d 83 00 e9 ff ff    	lea    eax,[rbx-0x1700]
  419cbf:	3d 00 e9 ff 7f       	cmp    eax,0x7fffe900
  419cc4:	0f 86 38 f2 ff ff    	jbe    418f02 <fmt_fp.cold+0xb9>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419cca:	89 f0                	mov    eax,esi
	for (; l >= sizeof pad; l -= sizeof pad)
  419ccc:	81 eb 00 01 00 00    	sub    ebx,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419cd2:	89 c6                	mov    esi,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  419cd4:	89 dd                	mov    ebp,ebx
  419cd6:	81 fb ff 00 00 00    	cmp    ebx,0xff
  419cdc:	77 ee                	ja     419ccc <fmt_fp+0x80c>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419cde:	85 f6                	test   esi,esi
  419ce0:	75 26                	jne    419d08 <fmt_fp+0x848>
  419ce2:	48 b8 20 ce fb ff ff 	movabs rax,0xfffffffffffbce20
  419ce9:	ff ff ff 
	out(f, pad, l);
  419cec:	48 63 f5             	movsxd rsi,ebp
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419cef:	4c 89 f2             	mov    rdx,r14
  419cf2:	4c 89 d7             	mov    rdi,r10
  419cf5:	4c 01 f8             	add    rax,r15
  419cf8:	ff d0                	call   rax
  419cfa:	41 8b 36             	mov    esi,DWORD PTR [r14]
  419cfd:	83 e6 20             	and    esi,0x20
  419d00:	85 f6                	test   esi,esi
  419d02:	0f 84 14 18 00 00    	je     41b51c <fmt_fp+0x205c>
		pad(f, '0', w, pl+l, fl^ZERO_PAD);
  419d08:	8b 44 24 14          	mov    eax,DWORD PTR [rsp+0x14]
  419d0c:	35 00 00 01 00       	xor    eax,0x10000
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  419d11:	a9 00 20 01 00       	test   eax,0x12000
  419d16:	0f 85 d0 10 00 00    	jne    41adec <fmt_fp+0x192c>
  419d1c:	80 3c 24 00          	cmp    BYTE PTR [rsp],0x0
  419d20:	0f 85 c6 10 00 00    	jne    41adec <fmt_fp+0x192c>
	l = w - l;
  419d26:	8b 6c 24 58          	mov    ebp,DWORD PTR [rsp+0x58]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  419d2a:	b8 00 01 00 00       	mov    eax,0x100
	l = w - l;
  419d2f:	2b 6c 24 18          	sub    ebp,DWORD PTR [rsp+0x18]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  419d33:	4c 8d 94 24 90 01 00 	lea    r10,[rsp+0x190]
  419d3a:	00 
  419d3b:	39 c5                	cmp    ebp,eax
  419d3d:	4c 89 54 24 30       	mov    QWORD PTR [rsp+0x30],r10
  419d42:	4c 89 d7             	mov    rdi,r10
  419d45:	be 30 00 00 00       	mov    esi,0x30
  419d4a:	0f 4e c5             	cmovle eax,ebp
  419d4d:	48 63 d0             	movsxd rdx,eax
  419d50:	48 b8 3c 64 fb ff ff 	movabs rax,0xfffffffffffb643c
  419d57:	ff ff ff 
  419d5a:	4c 01 f8             	add    rax,r15
  419d5d:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  419d5f:	81 fd ff 00 00 00    	cmp    ebp,0xff
  419d65:	4c 8b 54 24 30       	mov    r10,QWORD PTR [rsp+0x30]
  419d6a:	0f 8e 64 1f 00 00    	jle    41bcd4 <fmt_fp+0x2814>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419d70:	41 8b 06             	mov    eax,DWORD PTR [r14]
  419d73:	44 8d ad 00 ff ff ff 	lea    r13d,[rbp-0x100]
  419d7a:	4c 89 d5             	mov    rbp,r10
  419d7d:	48 bb 20 ce fb ff ff 	movabs rbx,0xfffffffffffbce20
  419d84:	ff ff ff 
  419d87:	83 e0 20             	and    eax,0x20
  419d8a:	89 c1                	mov    ecx,eax
  419d8c:	0f 84 6e 0f 00 00    	je     41ad00 <fmt_fp+0x1840>
	for (; l >= sizeof pad; l -= sizeof pad)
  419d92:	49 89 ea             	mov    r10,rbp
  419d95:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  419d9c:	0f 8e 50 10 00 00    	jle    41adf2 <fmt_fp+0x1932>
  419da2:	41 8d 85 00 e9 ff ff 	lea    eax,[r13-0x1700]
  419da9:	3d 00 e9 ff 7f       	cmp    eax,0x7fffe900
  419dae:	0f 86 2a f4 ff ff    	jbe    4191de <fmt_fp.cold+0x395>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419db4:	89 c8                	mov    eax,ecx
	for (; l >= sizeof pad; l -= sizeof pad)
  419db6:	41 81 ed 00 01 00 00 	sub    r13d,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419dbd:	89 c1                	mov    ecx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  419dbf:	44 89 ed             	mov    ebp,r13d
  419dc2:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  419dc9:	77 eb                	ja     419db6 <fmt_fp+0x8f6>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419dcb:	85 c9                	test   ecx,ecx
  419dcd:	0f 84 01 10 00 00    	je     41add4 <fmt_fp+0x1914>
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  419dd3:	8b 44 24 08          	mov    eax,DWORD PTR [rsp+0x8]
	for (; l >= sizeof pad; l -= sizeof pad)
  419dd7:	89 c3                	mov    ebx,eax
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  419dd9:	85 c0                	test   eax,eax
  419ddb:	0f 8e e2 00 00 00    	jle    419ec3 <fmt_fp+0xa03>
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  419de1:	48 63 6c 24 08       	movsxd rbp,DWORD PTR [rsp+0x8]
  419de6:	ba 00 01 00 00       	mov    edx,0x100
  419deb:	be 30 00 00 00       	mov    esi,0x30
  419df0:	81 7c 24 38 01 01 00 	cmp    DWORD PTR [rsp+0x38],0x101
  419df7:	00 
  419df8:	4c 8d 94 24 90 01 00 	lea    r10,[rsp+0x190]
  419dff:	00 
  419e00:	48 b8 3c 64 fb ff ff 	movabs rax,0xfffffffffffb643c
  419e07:	ff ff ff 
  419e0a:	48 0f 42 d5          	cmovb  rdx,rbp
  419e0e:	4c 89 54 24 30       	mov    QWORD PTR [rsp+0x30],r10
  419e13:	4c 89 d7             	mov    rdi,r10
  419e16:	4c 01 f8             	add    rax,r15
  419e19:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  419e1b:	81 fd ff 00 00 00    	cmp    ebp,0xff
  419e21:	4c 8b 54 24 30       	mov    r10,QWORD PTR [rsp+0x30]
  419e26:	0f 8e 41 1e 00 00    	jle    41bc6d <fmt_fp+0x27ad>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419e2c:	41 8b 06             	mov    eax,DWORD PTR [r14]
  419e2f:	81 eb 00 01 00 00    	sub    ebx,0x100
  419e35:	4d 89 d4             	mov    r12,r10
  419e38:	48 bd 20 ce fb ff ff 	movabs rbp,0xfffffffffffbce20
  419e3f:	ff ff ff 
  419e42:	83 e0 20             	and    eax,0x20
  419e45:	89 c1                	mov    ecx,eax
  419e47:	0f 84 83 0e 00 00    	je     41acd0 <fmt_fp+0x1810>
	for (; l >= sizeof pad; l -= sizeof pad)
  419e4d:	4d 89 e2             	mov    r10,r12
  419e50:	81 fb ff 00 00 00    	cmp    ebx,0xff
  419e56:	7e 4b                	jle    419ea3 <fmt_fp+0x9e3>
  419e58:	8d 83 00 e9 ff ff    	lea    eax,[rbx-0x1700]
  419e5e:	3d 00 e9 ff 7f       	cmp    eax,0x7fffe900
  419e63:	0f 86 e2 f4 ff ff    	jbe    41934b <fmt_fp.cold+0x502>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419e69:	89 c8                	mov    eax,ecx
	for (; l >= sizeof pad; l -= sizeof pad)
  419e6b:	81 eb 00 01 00 00    	sub    ebx,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419e71:	89 c1                	mov    ecx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  419e73:	81 fb ff 00 00 00    	cmp    ebx,0xff
  419e79:	77 f0                	ja     419e6b <fmt_fp+0x9ab>
  419e7b:	89 5c 24 08          	mov    DWORD PTR [rsp+0x8],ebx
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419e7f:	85 c9                	test   ecx,ecx
  419e81:	75 40                	jne    419ec3 <fmt_fp+0xa03>
  419e83:	48 b8 20 ce fb ff ff 	movabs rax,0xfffffffffffbce20
  419e8a:	ff ff ff 
	out(f, pad, l);
  419e8d:	48 63 74 24 08       	movsxd rsi,DWORD PTR [rsp+0x8]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419e92:	4c 89 f2             	mov    rdx,r14
  419e95:	4c 89 d7             	mov    rdi,r10
  419e98:	4c 01 f8             	add    rax,r15
  419e9b:	ff d0                	call   rax
  419e9d:	41 8b 0e             	mov    ecx,DWORD PTR [r14]
  419ea0:	83 e1 20             	and    ecx,0x20
  419ea3:	85 c9                	test   ecx,ecx
  419ea5:	75 1c                	jne    419ec3 <fmt_fp+0xa03>
  419ea7:	48 8b 74 24 20       	mov    rsi,QWORD PTR [rsp+0x20]
  419eac:	48 8b 7c 24 28       	mov    rdi,QWORD PTR [rsp+0x28]
  419eb1:	4c 89 f2             	mov    rdx,r14
  419eb4:	48 b8 20 ce fb ff ff 	movabs rax,0xfffffffffffbce20
  419ebb:	ff ff ff 
  419ebe:	4c 01 f8             	add    rax,r15
  419ec1:	ff d0                	call   rax
		pad(f, ' ', w, pl+l, fl^LEFT_ADJ);
  419ec3:	8b 44 24 14          	mov    eax,DWORD PTR [rsp+0x14]
  419ec7:	80 f4 20             	xor    ah,0x20
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  419eca:	a9 00 20 01 00       	test   eax,0x12000
  419ecf:	0f 85 b1 00 00 00    	jne    419f86 <fmt_fp+0xac6>
  419ed5:	80 3c 24 00          	cmp    BYTE PTR [rsp],0x0
  419ed9:	0f 85 a7 00 00 00    	jne    419f86 <fmt_fp+0xac6>
	l = w - l;
  419edf:	44 8b 64 24 58       	mov    r12d,DWORD PTR [rsp+0x58]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  419ee4:	b8 00 01 00 00       	mov    eax,0x100
	l = w - l;
  419ee9:	44 2b 64 24 18       	sub    r12d,DWORD PTR [rsp+0x18]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  419eee:	4c 8d 94 24 90 01 00 	lea    r10,[rsp+0x190]
  419ef5:	00 
  419ef6:	41 39 c4             	cmp    r12d,eax
  419ef9:	4c 89 14 24          	mov    QWORD PTR [rsp],r10
  419efd:	4c 89 d7             	mov    rdi,r10
  419f00:	be 20 00 00 00       	mov    esi,0x20
  419f05:	41 0f 4e c4          	cmovle eax,r12d
  419f09:	48 63 d0             	movsxd rdx,eax
  419f0c:	48 b8 3c 64 fb ff ff 	movabs rax,0xfffffffffffb643c
  419f13:	ff ff ff 
  419f16:	4c 01 f8             	add    rax,r15
  419f19:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  419f1b:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  419f22:	4c 8b 14 24          	mov    r10,QWORD PTR [rsp]
  419f26:	0f 8e 9d 1d 00 00    	jle    41bcc9 <fmt_fp+0x2809>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419f2c:	41 8b 06             	mov    eax,DWORD PTR [r14]
  419f2f:	41 8d ac 24 00 ff ff 	lea    ebp,[r12-0x100]
  419f36:	ff 
  419f37:	4d 89 d5             	mov    r13,r10
  419f3a:	48 bb 20 ce fb ff ff 	movabs rbx,0xfffffffffffbce20
  419f41:	ff ff ff 
  419f44:	89 c1                	mov    ecx,eax
  419f46:	83 e1 20             	and    ecx,0x20
  419f49:	0f 84 e3 0d 00 00    	je     41ad32 <fmt_fp+0x1872>
	for (; l >= sizeof pad; l -= sizeof pad)
  419f4f:	4d 89 ea             	mov    r10,r13
  419f52:	81 fd ff 00 00 00    	cmp    ebp,0xff
  419f58:	7e 2c                	jle    419f86 <fmt_fp+0xac6>
  419f5a:	8d 85 00 e9 ff ff    	lea    eax,[rbp-0x1700]
  419f60:	3d 00 e9 ff 7f       	cmp    eax,0x7fffe900
  419f65:	0f 86 9f f4 ff ff    	jbe    41940a <fmt_fp.cold+0x5c1>
  419f6b:	81 ed 00 01 00 00    	sub    ebp,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419f71:	89 ca                	mov    edx,ecx
	for (; l >= sizeof pad; l -= sizeof pad)
  419f73:	41 89 ec             	mov    r12d,ebp
  419f76:	81 fd ff 00 00 00    	cmp    ebp,0xff
  419f7c:	77 ed                	ja     419f6b <fmt_fp+0xaab>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419f7e:	85 d2                	test   edx,edx
  419f80:	0f 84 0e 1c 00 00    	je     41bb94 <fmt_fp+0x26d4>
		return MAX(w, pl+l);
  419f86:	8b 5c 24 18          	mov    ebx,DWORD PTR [rsp+0x18]
  419f8a:	8b 44 24 58          	mov    eax,DWORD PTR [rsp+0x58]
  419f8e:	39 c3                	cmp    ebx,eax
  419f90:	0f 4d c3             	cmovge eax,ebx
  419f93:	e9 a1 02 00 00       	jmp    41a239 <fmt_fp+0xd79>
	} else if (fl & PAD_POS) {
  419f98:	a8 01                	test   al,0x1
  419f9a:	0f 84 05 03 00 00    	je     41a2a5 <fmt_fp+0xde5>
  419fa0:	bb 03 00 00 00       	mov    ebx,0x3
  419fa5:	41 bd 03 00 00 00    	mov    r13d,0x3
  419fab:	bd 04 00 00 00       	mov    ebp,0x4
		prefix+=6;
  419fb0:	48 b8 16 09 fc ff ff 	movabs rax,0xfffffffffffc0916
  419fb7:	ff ff ff 
  419fba:	4c 01 f8             	add    rax,r15
	pl=1;
  419fbd:	c7 44 24 28 01 00 00 	mov    DWORD PTR [rsp+0x28],0x1
  419fc4:	00 
  419fc5:	48 c7 44 24 38 01 00 	mov    QWORD PTR [rsp+0x38],0x1
  419fcc:	00 00 
		prefix+=6;
  419fce:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  419fd3:	e9 a6 f5 ff ff       	jmp    41957e <fmt_fp+0xbe>
  419fd8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  419fdf:	00 
		int sh=MIN(9,-e2), need=1+(p+LDBL_MANT_DIG/3U+8)/9;
  419fe0:	44 89 c9             	mov    ecx,r9d
		if (!*a) a++;
  419fe3:	8b 45 00             	mov    eax,DWORD PTR [rbp+0x0]
  419fe6:	45 31 c9             	xor    r9d,r9d
		int sh=MIN(9,-e2), need=1+(p+LDBL_MANT_DIG/3U+8)/9;
  419fe9:	f7 d9                	neg    ecx
		for (d=a; d<z; d++) {
  419feb:	48 39 dd             	cmp    rbp,rbx
  419fee:	0f 82 93 f7 ff ff    	jb     419787 <fmt_fp+0x2c7>
		if (!*a) a++;
  419ff4:	48 8d 55 04          	lea    rdx,[rbp+0x4]
  419ff8:	85 c0                	test   eax,eax
  419ffa:	48 0f 44 ea          	cmove  rbp,rdx
  419ffe:	e9 d9 f7 ff ff       	jmp    4197dc <fmt_fp+0x31c>
  41a003:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		char *s = (t&32)?"inf":"INF";
  41a008:	48 b8 23 09 fc ff ff 	movabs rax,0xfffffffffffc0923
  41a00f:	ff ff ff 
  41a012:	4d 8d 24 07          	lea    r12,[r15+rax*1]
  41a016:	8b 44 24 20          	mov    eax,DWORD PTR [rsp+0x20]
  41a01a:	83 e0 20             	and    eax,0x20
  41a01d:	75 0e                	jne    41a02d <fmt_fp+0xb6d>
  41a01f:	48 ba 27 09 fc ff ff 	movabs rdx,0xfffffffffffc0927
  41a026:	ff ff ff 
  41a029:	4d 8d 24 17          	lea    r12,[r15+rdx*1]
		if (y!=y) s=(t&32)?"nan":"NAN";
  41a02d:	db ac 24 80 1e 00 00 	fld    TBYTE PTR [rsp+0x1e80]
  41a034:	df e8                	fucomip st,st(0)
  41a036:	7b 16                	jnp    41a04e <fmt_fp+0xb8e>
  41a038:	48 ba 2f 09 fc ff ff 	movabs rdx,0xfffffffffffc092f
  41a03f:	ff ff ff 
  41a042:	4d 8d 24 17          	lea    r12,[r15+rdx*1]
  41a046:	85 c0                	test   eax,eax
  41a048:	0f 84 87 02 00 00    	je     41a2d5 <fmt_fp+0xe15>
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41a04e:	39 6c 24 58          	cmp    DWORD PTR [rsp+0x58],ebp
  41a052:	0f 9e c3             	setle  bl
  41a055:	f7 44 24 14 00 20 00 	test   DWORD PTR [rsp+0x14],0x2000
  41a05c:	00 
  41a05d:	0f 85 de 00 00 00    	jne    41a141 <fmt_fp+0xc81>
  41a063:	84 db                	test   bl,bl
  41a065:	0f 85 d6 00 00 00    	jne    41a141 <fmt_fp+0xc81>
	l = w - l;
  41a06b:	8b 4c 24 58          	mov    ecx,DWORD PTR [rsp+0x58]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41a06f:	b8 00 01 00 00       	mov    eax,0x100
  41a074:	be 20 00 00 00       	mov    esi,0x20
  41a079:	4c 8d 94 24 90 01 00 	lea    r10,[rsp+0x190]
  41a080:	00 
  41a081:	4c 89 14 24          	mov    QWORD PTR [rsp],r10
  41a085:	4c 89 d7             	mov    rdi,r10
	l = w - l;
  41a088:	29 e9                	sub    ecx,ebp
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41a08a:	39 c1                	cmp    ecx,eax
  41a08c:	89 4c 24 08          	mov    DWORD PTR [rsp+0x8],ecx
  41a090:	0f 4e c1             	cmovle eax,ecx
  41a093:	48 63 d0             	movsxd rdx,eax
  41a096:	48 b8 3c 64 fb ff ff 	movabs rax,0xfffffffffffb643c
  41a09d:	ff ff ff 
  41a0a0:	4c 01 f8             	add    rax,r15
  41a0a3:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  41a0a5:	8b 4c 24 08          	mov    ecx,DWORD PTR [rsp+0x8]
  41a0a9:	4c 8b 14 24          	mov    r10,QWORD PTR [rsp]
  41a0ad:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  41a0b3:	0f 8e 3b 1b 00 00    	jle    41bbf4 <fmt_fp+0x2734>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a0b9:	48 bf 20 ce fb ff ff 	movabs rdi,0xfffffffffffbce20
  41a0c0:	ff ff ff 
  41a0c3:	41 8b 06             	mov    eax,DWORD PTR [r14]
  41a0c6:	89 2c 24             	mov    DWORD PTR [rsp],ebp
  41a0c9:	89 dd                	mov    ebp,ebx
  41a0cb:	48 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],rdi
  41a0d0:	44 8d a9 00 ff ff ff 	lea    r13d,[rcx-0x100]
  41a0d7:	4c 89 d3             	mov    rbx,r10
  41a0da:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  41a0e0:	83 e0 20             	and    eax,0x20
  41a0e3:	89 c6                	mov    esi,eax
  41a0e5:	0f 84 3d 02 00 00    	je     41a328 <fmt_fp+0xe68>
	for (; l >= sizeof pad; l -= sizeof pad)
  41a0eb:	49 89 da             	mov    r10,rbx
  41a0ee:	89 eb                	mov    ebx,ebp
  41a0f0:	8b 2c 24             	mov    ebp,DWORD PTR [rsp]
  41a0f3:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  41a0fa:	7e 4b                	jle    41a147 <fmt_fp+0xc87>
  41a0fc:	41 8d 85 00 e9 ff ff 	lea    eax,[r13-0x1700]
  41a103:	3d 00 e9 ff 7f       	cmp    eax,0x7fffe900
  41a108:	0f 86 3b ed ff ff    	jbe    418e49 <fmt_fp.cold>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a10e:	89 f0                	mov    eax,esi
	for (; l >= sizeof pad; l -= sizeof pad)
  41a110:	41 81 ed 00 01 00 00 	sub    r13d,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a117:	89 c6                	mov    esi,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  41a119:	44 89 e9             	mov    ecx,r13d
  41a11c:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  41a123:	77 eb                	ja     41a110 <fmt_fp+0xc50>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a125:	85 f6                	test   esi,esi
  41a127:	75 26                	jne    41a14f <fmt_fp+0xc8f>
  41a129:	48 b8 20 ce fb ff ff 	movabs rax,0xfffffffffffbce20
  41a130:	ff ff ff 
	out(f, pad, l);
  41a133:	48 63 f1             	movsxd rsi,ecx
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a136:	4c 89 f2             	mov    rdx,r14
  41a139:	4c 89 d7             	mov    rdi,r10
  41a13c:	4c 01 f8             	add    rax,r15
  41a13f:	ff d0                	call   rax
  41a141:	41 8b 36             	mov    esi,DWORD PTR [r14]
  41a144:	83 e6 20             	and    esi,0x20
  41a147:	85 f6                	test   esi,esi
  41a149:	0f 84 4a 0c 00 00    	je     41ad99 <fmt_fp+0x18d9>
		pad(f, ' ', w, 3+pl, fl^LEFT_ADJ);
  41a14f:	8b 44 24 14          	mov    eax,DWORD PTR [rsp+0x14]
  41a153:	80 f4 20             	xor    ah,0x20
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41a156:	a9 00 20 01 00       	test   eax,0x12000
  41a15b:	0f 85 cf 00 00 00    	jne    41a230 <fmt_fp+0xd70>
  41a161:	84 db                	test   bl,bl
  41a163:	0f 85 c7 00 00 00    	jne    41a230 <fmt_fp+0xd70>
	l = w - l;
  41a169:	44 8b 6c 24 58       	mov    r13d,DWORD PTR [rsp+0x58]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41a16e:	b8 00 01 00 00       	mov    eax,0x100
  41a173:	be 20 00 00 00       	mov    esi,0x20
  41a178:	4c 8d 94 24 90 01 00 	lea    r10,[rsp+0x190]
  41a17f:	00 
  41a180:	4c 89 14 24          	mov    QWORD PTR [rsp],r10
  41a184:	4c 89 d7             	mov    rdi,r10
	l = w - l;
  41a187:	41 29 ed             	sub    r13d,ebp
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41a18a:	41 39 c5             	cmp    r13d,eax
  41a18d:	41 0f 4e c5          	cmovle eax,r13d
  41a191:	48 63 d0             	movsxd rdx,eax
  41a194:	48 b8 3c 64 fb ff ff 	movabs rax,0xfffffffffffb643c
  41a19b:	ff ff ff 
  41a19e:	4c 01 f8             	add    rax,r15
  41a1a1:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  41a1a3:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  41a1aa:	4c 8b 14 24          	mov    r10,QWORD PTR [rsp]
  41a1ae:	0f 8e 35 1a 00 00    	jle    41bbe9 <fmt_fp+0x2729>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a1b4:	41 8b 06             	mov    eax,DWORD PTR [r14]
  41a1b7:	45 8d a5 00 ff ff ff 	lea    r12d,[r13-0x100]
  41a1be:	4d 89 d5             	mov    r13,r10
  41a1c1:	48 bb 20 ce fb ff ff 	movabs rbx,0xfffffffffffbce20
  41a1c8:	ff ff ff 
  41a1cb:	89 c1                	mov    ecx,eax
  41a1cd:	0f 1f 00             	nop    DWORD PTR [rax]
  41a1d0:	83 e1 20             	and    ecx,0x20
  41a1d3:	0f 84 17 01 00 00    	je     41a2f0 <fmt_fp+0xe30>
	for (; l >= sizeof pad; l -= sizeof pad)
  41a1d9:	4d 89 ea             	mov    r10,r13
  41a1dc:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  41a1e3:	7e 4b                	jle    41a230 <fmt_fp+0xd70>
  41a1e5:	41 8d 84 24 00 e9 ff 	lea    eax,[r12-0x1700]
  41a1ec:	ff 
  41a1ed:	3d 00 e9 ff 7f       	cmp    eax,0x7fffe900
  41a1f2:	0f 86 77 ee ff ff    	jbe    41906f <fmt_fp.cold+0x226>
  41a1f8:	41 81 ec 00 01 00 00 	sub    r12d,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a1ff:	89 ca                	mov    edx,ecx
	for (; l >= sizeof pad; l -= sizeof pad)
  41a201:	45 89 e5             	mov    r13d,r12d
  41a204:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  41a20b:	77 eb                	ja     41a1f8 <fmt_fp+0xd38>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a20d:	85 d2                	test   edx,edx
  41a20f:	75 1f                	jne    41a230 <fmt_fp+0xd70>
  41a211:	48 b8 20 ce fb ff ff 	movabs rax,0xfffffffffffbce20
  41a218:	ff ff ff 
	out(f, pad, l);
  41a21b:	49 63 f5             	movsxd rsi,r13d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a21e:	4c 89 f2             	mov    rdx,r14
  41a221:	4c 89 d7             	mov    rdi,r10
  41a224:	4c 01 f8             	add    rax,r15
  41a227:	ff d0                	call   rax
  41a229:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		return MAX(w, 3+pl);
  41a230:	8b 44 24 58          	mov    eax,DWORD PTR [rsp+0x58]
  41a234:	39 e8                	cmp    eax,ebp
  41a236:	0f 4c c5             	cmovl  eax,ebp
	}

	pad(f, ' ', w, pl+l, fl^LEFT_ADJ);

	return MAX(w, pl+l);
}
  41a239:	48 81 c4 48 1e 00 00 	add    rsp,0x1e48
  41a240:	5b                   	pop    rbx
  41a241:	5d                   	pop    rbp
  41a242:	41 5c                	pop    r12
  41a244:	41 5d                	pop    r13
  41a246:	41 5e                	pop    r14
  41a248:	41 5f                	pop    r15
  41a24a:	c3                   	ret    
	if (a<z) for (i=10, e=9*(r-a); *a>=i; i*=10, e++);
  41a24b:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
	j = p - ((t|32)!='f')*e - ((t|32)=='g' && p);
  41a250:	31 c9                	xor    ecx,ecx
  41a252:	41 83 fb 66          	cmp    r11d,0x66
	if (a<z) for (i=10, e=9*(r-a); *a>=i; i*=10, e++);
  41a256:	8b 55 00             	mov    edx,DWORD PTR [rbp+0x0]
	j = p - ((t|32)!='f')*e - ((t|32)=='g' && p);
  41a259:	0f 95 c1             	setne  cl
	if (a<z) for (i=10, e=9*(r-a); *a>=i; i*=10, e++);
  41a25c:	48 29 e8             	sub    rax,rbp
  41a25f:	48 c1 f8 02          	sar    rax,0x2
  41a263:	8d 3c c0             	lea    edi,[rax+rax*8]
  41a266:	b8 0a 00 00 00       	mov    eax,0xa
  41a26b:	83 fa 09             	cmp    edx,0x9
  41a26e:	76 0c                	jbe    41a27c <fmt_fp+0xdbc>
  41a270:	8d 04 80             	lea    eax,[rax+rax*4]
  41a273:	83 c7 01             	add    edi,0x1
  41a276:	01 c0                	add    eax,eax
  41a278:	39 d0                	cmp    eax,edx
  41a27a:	76 f4                	jbe    41a270 <fmt_fp+0xdb0>
	j = p - ((t|32)!='f')*e - ((t|32)=='g' && p);
  41a27c:	0f af cf             	imul   ecx,edi
  41a27f:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  41a282:	29 c8                	sub    eax,ecx
  41a284:	e9 96 f5 ff ff       	jmp    41981f <fmt_fp+0x35f>
	if (y) y *= 0x1p28, e2-=28;
  41a289:	48 b8 94 0d fc ff ff 	movabs rax,0xfffffffffffc0d94
  41a290:	ff ff ff 
  41a293:	41 83 e9 1c          	sub    r9d,0x1c
  41a297:	42 d8 0c 38          	fmul   DWORD PTR [rax+r15*1]
  41a29b:	44 89 4c 24 60       	mov    DWORD PTR [rsp+0x60],r9d
  41a2a0:	e9 7a f3 ff ff       	jmp    41961f <fmt_fp+0x15f>
	} else if (fl & PAD_POS) {
  41a2a5:	bb 02 00 00 00       	mov    ebx,0x2
  41a2aa:	41 bd 02 00 00 00    	mov    r13d,0x2
  41a2b0:	bd 03 00 00 00       	mov    ebp,0x3
	} else prefix++, pl=0;
  41a2b5:	48 b8 11 09 fc ff ff 	movabs rax,0xfffffffffffc0911
  41a2bc:	ff ff ff 
	} else if (fl & PAD_POS) {
  41a2bf:	48 c7 44 24 38 00 00 	mov    QWORD PTR [rsp+0x38],0x0
  41a2c6:	00 00 
	} else prefix++, pl=0;
  41a2c8:	4c 01 f8             	add    rax,r15
  41a2cb:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  41a2d0:	e9 a9 f2 ff ff       	jmp    41957e <fmt_fp+0xbe>
		if (y!=y) s=(t&32)?"nan":"NAN";
  41a2d5:	48 b8 2b 09 fc ff ff 	movabs rax,0xfffffffffffc092b
  41a2dc:	ff ff ff 
  41a2df:	4d 8d 24 07          	lea    r12,[r15+rax*1]
  41a2e3:	e9 66 fd ff ff       	jmp    41a04e <fmt_fp+0xb8e>
  41a2e8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41a2ef:	00 
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a2f0:	4c 89 f2             	mov    rdx,r14
  41a2f3:	be 00 01 00 00       	mov    esi,0x100
  41a2f8:	49 8d 04 1f          	lea    rax,[r15+rbx*1]
  41a2fc:	4c 89 ef             	mov    rdi,r13
  41a2ff:	ff d0                	call   rax
  41a301:	41 8b 0e             	mov    ecx,DWORD PTR [r14]
  41a304:	89 ca                	mov    edx,ecx
  41a306:	83 e2 20             	and    edx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41a309:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  41a310:	0f 8e be 16 00 00    	jle    41b9d4 <fmt_fp+0x2514>
  41a316:	41 81 ec 00 01 00 00 	sub    r12d,0x100
  41a31d:	e9 ae fe ff ff       	jmp    41a1d0 <fmt_fp+0xd10>
  41a322:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a328:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
  41a32d:	be 00 01 00 00       	mov    esi,0x100
  41a332:	4c 89 f2             	mov    rdx,r14
  41a335:	48 89 df             	mov    rdi,rbx
  41a338:	4c 01 f8             	add    rax,r15
  41a33b:	ff d0                	call   rax
  41a33d:	41 8b 06             	mov    eax,DWORD PTR [r14]
	for (; l >= sizeof pad; l -= sizeof pad)
  41a340:	44 89 e9             	mov    ecx,r13d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a343:	89 c6                	mov    esi,eax
  41a345:	83 e6 20             	and    esi,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41a348:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  41a34f:	0f 8e 5d 16 00 00    	jle    41b9b2 <fmt_fp+0x24f2>
  41a355:	41 81 ed 00 01 00 00 	sub    r13d,0x100
  41a35c:	e9 7f fd ff ff       	jmp    41a0e0 <fmt_fp+0xc20>
			if ((*d/i & 1) || (i==1000000000 && d>a && (d[-1]&1)))
  41a361:	a8 01                	test   al,0x1
  41a363:	0f 84 93 16 00 00    	je     41b9fc <fmt_fp+0x253c>
				round += 2;
  41a369:	48 b8 e0 0d fc ff ff 	movabs rax,0xfffffffffffc0de0
  41a370:	ff ff ff 
  41a373:	41 db 2c 07          	fld    TBYTE PTR [r15+rax*1]
			if (x<i/2) small=0x0.8p0;
  41a377:	d1 f9                	sar    ecx,1
  41a379:	44 39 c1             	cmp    ecx,r8d
  41a37c:	0f 87 d1 17 00 00    	ja     41bb53 <fmt_fp+0x2693>
			else if (x==i/2 && d+1==z) small=0x1.0p0;
  41a382:	0f 84 f4 17 00 00    	je     41bb7c <fmt_fp+0x26bc>
  41a388:	48 b8 88 0d fc ff ff 	movabs rax,0xfffffffffffc0d88
  41a38f:	ff ff ff 
  41a392:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
			else small=0x1.8p0;
  41a396:	48 b8 8c 0d fc ff ff 	movabs rax,0xfffffffffffc0d8c
  41a39d:	ff ff ff 
  41a3a0:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
			if (pl && *prefix=='-') round*=-1, small*=-1;
  41a3a4:	44 8b 64 24 28       	mov    r12d,DWORD PTR [rsp+0x28]
  41a3a9:	45 85 e4             	test   r12d,r12d
  41a3ac:	74 14                	je     41a3c2 <fmt_fp+0xf02>
  41a3ae:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  41a3b3:	80 38 2d             	cmp    BYTE PTR [rax],0x2d
  41a3b6:	75 0e                	jne    41a3c6 <fmt_fp+0xf06>
  41a3b8:	dd d8                	fstp   st(0)
  41a3ba:	d9 c9                	fxch   st(1)
  41a3bc:	d9 e0                	fchs   
  41a3be:	d9 c9                	fxch   st(1)
  41a3c0:	eb 06                	jmp    41a3c8 <fmt_fp+0xf08>
  41a3c2:	dd d9                	fstp   st(1)
  41a3c4:	eb 02                	jmp    41a3c8 <fmt_fp+0xf08>
  41a3c6:	dd d9                	fstp   st(1)
			if (round+small != round) {
  41a3c8:	d8 c1                	fadd   st,st(1)
			*d -= x;
  41a3ca:	44 89 c8             	mov    eax,r9d
  41a3cd:	44 29 c0             	sub    eax,r8d
			if (round+small != round) {
  41a3d0:	df e9                	fucomip st,st(1)
  41a3d2:	dd d8                	fstp   st(0)
  41a3d4:	0f 8a 9e 10 00 00    	jp     41b478 <fmt_fp+0x1fb8>
  41a3da:	0f 85 98 10 00 00    	jne    41b478 <fmt_fp+0x1fb8>
			*d -= x;
  41a3e0:	89 06                	mov    DWORD PTR [rsi],eax
		if (x || d+1!=z) {
  41a3e2:	48 83 c6 04          	add    rsi,0x4
		if (z>d+1) z=d+1;
  41a3e6:	48 39 f3             	cmp    rbx,rsi
  41a3e9:	48 0f 47 de          	cmova  rbx,rsi
	for (; z>a && !z[-1]; z--);
  41a3ed:	48 39 dd             	cmp    rbp,rbx
  41a3f0:	72 0f                	jb     41a401 <fmt_fp+0xf41>
  41a3f2:	eb 16                	jmp    41a40a <fmt_fp+0xf4a>
  41a3f4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  41a3f8:	48 83 eb 04          	sub    rbx,0x4
  41a3fc:	48 39 eb             	cmp    rbx,rbp
  41a3ff:	76 09                	jbe    41a40a <fmt_fp+0xf4a>
  41a401:	44 8b 43 fc          	mov    r8d,DWORD PTR [rbx-0x4]
  41a405:	45 85 c0             	test   r8d,r8d
  41a408:	74 ee                	je     41a3f8 <fmt_fp+0xf38>
	if ((t|32)=='g') {
  41a40a:	41 83 fb 67          	cmp    r11d,0x67
  41a40e:	0f 84 61 0a 00 00    	je     41ae75 <fmt_fp+0x19b5>
	if (p > INT_MAX-1-(p || (fl&ALT_FORM)))
  41a414:	8b 34 24             	mov    esi,DWORD PTR [rsp]
  41a417:	85 f6                	test   esi,esi
  41a419:	0f 85 46 09 00 00    	jne    41ad65 <fmt_fp+0x18a5>
	l = 1 + p + (p || (fl&ALT_FORM));
  41a41f:	44 8b 44 24 14       	mov    r8d,DWORD PTR [rsp+0x14]
  41a424:	b8 01 00 00 00       	mov    eax,0x1
  41a429:	41 c1 e8 03          	shr    r8d,0x3
  41a42d:	41 83 e0 01          	and    r8d,0x1
  41a431:	41 01 c0             	add    r8d,eax
	if ((t|32)=='f') {
  41a434:	8b 44 24 20          	mov    eax,DWORD PTR [rsp+0x20]
		if (e > INT_MAX-l) return -1;
  41a438:	41 ba ff ff ff 7f    	mov    r10d,0x7fffffff
  41a43e:	45 29 c2             	sub    r10d,r8d
	if ((t|32)=='f') {
  41a441:	83 c8 20             	or     eax,0x20
  41a444:	89 44 24 08          	mov    DWORD PTR [rsp+0x8],eax
  41a448:	83 f8 66             	cmp    eax,0x66
  41a44b:	0f 84 23 0f 00 00    	je     41b374 <fmt_fp+0x1eb4>
		estr=fmt_u(e<0 ? -e : e, ebuf);
  41a451:	89 fe                	mov    esi,edi
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  41a453:	4c 8d 64 24 70       	lea    r12,[rsp+0x70]
		estr=fmt_u(e<0 ? -e : e, ebuf);
  41a458:	f7 de                	neg    esi
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  41a45a:	4c 89 e1             	mov    rcx,r12
		estr=fmt_u(e<0 ? -e : e, ebuf);
  41a45d:	0f 48 f7             	cmovs  esi,edi
  41a460:	48 63 f6             	movsxd rsi,esi
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  41a463:	85 ff                	test   edi,edi
  41a465:	74 49                	je     41a4b0 <fmt_fp+0xff0>
  41a467:	49 b9 cd cc cc cc cc 	movabs r9,0xcccccccccccccccd
  41a46e:	cc cc cc 
  41a471:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  41a478:	48 89 f0             	mov    rax,rsi
  41a47b:	48 83 e9 01          	sub    rcx,0x1
  41a47f:	49 f7 e1             	mul    r9
  41a482:	48 89 f0             	mov    rax,rsi
  41a485:	48 c1 ea 03          	shr    rdx,0x3
  41a489:	4c 8d 1c 92          	lea    r11,[rdx+rdx*4]
  41a48d:	4d 01 db             	add    r11,r11
  41a490:	4c 29 d8             	sub    rax,r11
  41a493:	83 c0 30             	add    eax,0x30
  41a496:	88 01                	mov    BYTE PTR [rcx],al
  41a498:	48 89 f0             	mov    rax,rsi
  41a49b:	48 89 d6             	mov    rsi,rdx
  41a49e:	48 83 f8 09          	cmp    rax,0x9
  41a4a2:	77 d4                	ja     41a478 <fmt_fp+0xfb8>
		while(ebuf-estr<2) *--estr='0';
  41a4a4:	4c 89 e0             	mov    rax,r12
  41a4a7:	48 29 c8             	sub    rax,rcx
  41a4aa:	48 83 f8 01          	cmp    rax,0x1
  41a4ae:	7f 13                	jg     41a4c3 <fmt_fp+0x1003>
  41a4b0:	48 83 e9 01          	sub    rcx,0x1
  41a4b4:	4c 89 e0             	mov    rax,r12
  41a4b7:	c6 01 30             	mov    BYTE PTR [rcx],0x30
  41a4ba:	48 29 c8             	sub    rax,rcx
  41a4bd:	48 83 f8 01          	cmp    rax,0x1
  41a4c1:	7e ed                	jle    41a4b0 <fmt_fp+0xff0>
		*--estr = (e<0 ? '-' : '+');
  41a4c3:	c1 ff 1f             	sar    edi,0x1f
		*--estr = t;
  41a4c6:	48 8d 41 fe          	lea    rax,[rcx-0x2]
		if (ebuf-estr > INT_MAX-l) return -1;
  41a4ca:	4d 63 d2             	movsxd r10,r10d
		*--estr = (e<0 ? '-' : '+');
  41a4cd:	83 e7 02             	and    edi,0x2
		if (ebuf-estr > INT_MAX-l) return -1;
  41a4d0:	49 29 c4             	sub    r12,rax
		*--estr = t;
  41a4d3:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
		*--estr = (e<0 ? '-' : '+');
  41a4d8:	83 c7 2b             	add    edi,0x2b
  41a4db:	40 88 79 ff          	mov    BYTE PTR [rcx-0x1],dil
		*--estr = t;
  41a4df:	0f b6 7c 24 20       	movzx  edi,BYTE PTR [rsp+0x20]
  41a4e4:	40 88 79 fe          	mov    BYTE PTR [rcx-0x2],dil
		if (ebuf-estr > INT_MAX-l) return -1;
  41a4e8:	4d 39 d4             	cmp    r12,r10
  41a4eb:	0f 8f 8d 08 00 00    	jg     41ad7e <fmt_fp+0x18be>
		l += ebuf-estr;
  41a4f1:	45 01 e0             	add    r8d,r12d
	if (l > INT_MAX-pl) return -1;
  41a4f4:	8b 7c 24 28          	mov    edi,DWORD PTR [rsp+0x28]
  41a4f8:	89 f8                	mov    eax,edi
  41a4fa:	f7 d8                	neg    eax
  41a4fc:	19 c0                	sbb    eax,eax
  41a4fe:	05 ff ff ff 7f       	add    eax,0x7fffffff
  41a503:	44 39 c0             	cmp    eax,r8d
  41a506:	0f 8c 72 08 00 00    	jl     41ad7e <fmt_fp+0x18be>
	pad(f, ' ', w, pl+l, fl);
  41a50c:	41 01 f8             	add    r8d,edi
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41a50f:	44 3b 44 24 58       	cmp    r8d,DWORD PTR [rsp+0x58]
  41a514:	0f 9d 44 24 20       	setge  BYTE PTR [rsp+0x20]
  41a519:	0f b6 44 24 20       	movzx  eax,BYTE PTR [rsp+0x20]
	pad(f, ' ', w, pl+l, fl);
  41a51e:	44 89 44 24 40       	mov    DWORD PTR [rsp+0x40],r8d
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41a523:	f7 44 24 14 00 20 01 	test   DWORD PTR [rsp+0x14],0x12000
  41a52a:	00 
  41a52b:	0f 85 c3 00 00 00    	jne    41a5f4 <fmt_fp+0x1134>
  41a531:	84 c0                	test   al,al
  41a533:	0f 85 bb 00 00 00    	jne    41a5f4 <fmt_fp+0x1134>
	l = w - l;
  41a539:	8b 4c 24 58          	mov    ecx,DWORD PTR [rsp+0x58]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41a53d:	b8 00 01 00 00       	mov    eax,0x100
	l = w - l;
  41a542:	2b 4c 24 40          	sub    ecx,DWORD PTR [rsp+0x40]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41a546:	4c 8d ac 24 90 00 00 	lea    r13,[rsp+0x90]
  41a54d:	00 
  41a54e:	39 c1                	cmp    ecx,eax
  41a550:	89 4c 24 28          	mov    DWORD PTR [rsp+0x28],ecx
  41a554:	be 20 00 00 00       	mov    esi,0x20
  41a559:	4c 89 ef             	mov    rdi,r13
  41a55c:	0f 4e c1             	cmovle eax,ecx
  41a55f:	48 63 d0             	movsxd rdx,eax
  41a562:	48 b8 3c 64 fb ff ff 	movabs rax,0xfffffffffffb643c
  41a569:	ff ff ff 
  41a56c:	4c 01 f8             	add    rax,r15
  41a56f:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  41a571:	8b 4c 24 28          	mov    ecx,DWORD PTR [rsp+0x28]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a575:	41 8b 06             	mov    eax,DWORD PTR [r14]
	for (; l >= sizeof pad; l -= sizeof pad)
  41a578:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  41a57e:	0f 8e ca 16 00 00    	jle    41bc4e <fmt_fp+0x278e>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a584:	48 bf 20 ce fb ff ff 	movabs rdi,0xfffffffffffbce20
  41a58b:	ff ff ff 
  41a58e:	44 8d a1 00 ff ff ff 	lea    r12d,[rcx-0x100]
  41a595:	48 89 7c 24 28       	mov    QWORD PTR [rsp+0x28],rdi
  41a59a:	83 e0 20             	and    eax,0x20
  41a59d:	89 c6                	mov    esi,eax
  41a59f:	0f 84 5b 06 00 00    	je     41ac00 <fmt_fp+0x1740>
	for (; l >= sizeof pad; l -= sizeof pad)
  41a5a5:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  41a5ac:	7e 4e                	jle    41a5fc <fmt_fp+0x113c>
  41a5ae:	41 8d 84 24 00 e9 ff 	lea    eax,[r12-0x1700]
  41a5b5:	ff 
  41a5b6:	3d 00 e9 ff 7f       	cmp    eax,0x7fffe900
  41a5bb:	0f 86 d1 ec ff ff    	jbe    419292 <fmt_fp.cold+0x449>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a5c1:	89 f0                	mov    eax,esi
	for (; l >= sizeof pad; l -= sizeof pad)
  41a5c3:	41 81 ec 00 01 00 00 	sub    r12d,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a5ca:	89 c6                	mov    esi,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  41a5cc:	44 89 e1             	mov    ecx,r12d
  41a5cf:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  41a5d6:	77 eb                	ja     41a5c3 <fmt_fp+0x1103>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a5d8:	85 f6                	test   esi,esi
  41a5da:	75 28                	jne    41a604 <fmt_fp+0x1144>
  41a5dc:	48 b8 20 ce fb ff ff 	movabs rax,0xfffffffffffbce20
  41a5e3:	ff ff ff 
	out(f, pad, l);
  41a5e6:	48 63 f1             	movsxd rsi,ecx
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a5e9:	4c 89 f2             	mov    rdx,r14
  41a5ec:	4c 89 ef             	mov    rdi,r13
  41a5ef:	4c 01 f8             	add    rax,r15
  41a5f2:	ff d0                	call   rax
  41a5f4:	41 8b 06             	mov    eax,DWORD PTR [r14]
  41a5f7:	83 e0 20             	and    eax,0x20
  41a5fa:	89 c6                	mov    esi,eax
  41a5fc:	85 f6                	test   esi,esi
  41a5fe:	0f 84 88 0d 00 00    	je     41b38c <fmt_fp+0x1ecc>
	pad(f, '0', w, pl+l, fl^ZERO_PAD);
  41a604:	8b 44 24 14          	mov    eax,DWORD PTR [rsp+0x14]
  41a608:	35 00 00 01 00       	xor    eax,0x10000
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41a60d:	a9 00 20 01 00       	test   eax,0x12000
  41a612:	0f 85 d0 00 00 00    	jne    41a6e8 <fmt_fp+0x1228>
  41a618:	80 7c 24 20 00       	cmp    BYTE PTR [rsp+0x20],0x0
  41a61d:	0f 85 c5 00 00 00    	jne    41a6e8 <fmt_fp+0x1228>
	l = w - l;
  41a623:	44 8b 4c 24 58       	mov    r9d,DWORD PTR [rsp+0x58]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41a628:	b8 00 01 00 00       	mov    eax,0x100
	l = w - l;
  41a62d:	44 2b 4c 24 40       	sub    r9d,DWORD PTR [rsp+0x40]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41a632:	4c 8d ac 24 90 00 00 	lea    r13,[rsp+0x90]
  41a639:	00 
  41a63a:	41 39 c1             	cmp    r9d,eax
  41a63d:	44 89 4c 24 28       	mov    DWORD PTR [rsp+0x28],r9d
  41a642:	be 30 00 00 00       	mov    esi,0x30
  41a647:	4c 89 ef             	mov    rdi,r13
  41a64a:	41 0f 4e c1          	cmovle eax,r9d
  41a64e:	48 63 d0             	movsxd rdx,eax
  41a651:	48 b8 3c 64 fb ff ff 	movabs rax,0xfffffffffffb643c
  41a658:	ff ff ff 
  41a65b:	4c 01 f8             	add    rax,r15
  41a65e:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  41a660:	44 8b 4c 24 28       	mov    r9d,DWORD PTR [rsp+0x28]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a665:	41 8b 06             	mov    eax,DWORD PTR [r14]
	for (; l >= sizeof pad; l -= sizeof pad)
  41a668:	41 81 f9 ff 00 00 00 	cmp    r9d,0xff
  41a66f:	0f 8e b0 15 00 00    	jle    41bc25 <fmt_fp+0x2765>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a675:	48 bf 20 ce fb ff ff 	movabs rdi,0xfffffffffffbce20
  41a67c:	ff ff ff 
  41a67f:	45 8d a1 00 ff ff ff 	lea    r12d,[r9-0x100]
  41a686:	89 c6                	mov    esi,eax
  41a688:	48 89 7c 24 28       	mov    QWORD PTR [rsp+0x28],rdi
  41a68d:	83 e6 20             	and    esi,0x20
  41a690:	0f 84 2a 05 00 00    	je     41abc0 <fmt_fp+0x1700>
	for (; l >= sizeof pad; l -= sizeof pad)
  41a696:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  41a69d:	7e 49                	jle    41a6e8 <fmt_fp+0x1228>
  41a69f:	41 8d 84 24 00 e9 ff 	lea    eax,[r12-0x1700]
  41a6a6:	ff 
  41a6a7:	3d 00 e9 ff 7f       	cmp    eax,0x7fffe900
  41a6ac:	0f 86 03 e9 ff ff    	jbe    418fb5 <fmt_fp.cold+0x16c>
  41a6b2:	41 81 ec 00 01 00 00 	sub    r12d,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a6b9:	89 f2                	mov    edx,esi
	for (; l >= sizeof pad; l -= sizeof pad)
  41a6bb:	45 89 e1             	mov    r9d,r12d
  41a6be:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  41a6c5:	77 eb                	ja     41a6b2 <fmt_fp+0x11f2>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a6c7:	85 d2                	test   edx,edx
  41a6c9:	75 1d                	jne    41a6e8 <fmt_fp+0x1228>
  41a6cb:	48 b8 20 ce fb ff ff 	movabs rax,0xfffffffffffbce20
  41a6d2:	ff ff ff 
	out(f, pad, l);
  41a6d5:	49 63 f1             	movsxd rsi,r9d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a6d8:	4c 89 f2             	mov    rdx,r14
  41a6db:	4c 89 ef             	mov    rdi,r13
  41a6de:	4c 01 f8             	add    rax,r15
  41a6e1:	ff d0                	call   rax
  41a6e3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	if ((t|32)=='f') {
  41a6e8:	83 7c 24 08 66       	cmp    DWORD PTR [rsp+0x8],0x66
  41a6ed:	0f 84 48 08 00 00    	je     41af3b <fmt_fp+0x1a7b>
		for (d=a; d<z && p>=0; d++) {
  41a6f3:	4c 63 24 24          	movsxd r12,DWORD PTR [rsp]
		if (z<=a) z=a+1;
  41a6f7:	48 8d 45 04          	lea    rax,[rbp+0x4]
  41a6fb:	48 39 dd             	cmp    rbp,rbx
  41a6fe:	48 0f 43 d8          	cmovae rbx,rax
		for (d=a; d<z && p>=0; d++) {
  41a702:	45 85 e4             	test   r12d,r12d
  41a705:	0f 88 fd 00 00 00    	js     41a808 <fmt_fp+0x1348>
  41a70b:	48 39 eb             	cmp    rbx,rbp
  41a70e:	0f 86 f4 00 00 00    	jbe    41a808 <fmt_fp+0x1348>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a714:	48 b8 20 ce fb ff ff 	movabs rax,0xfffffffffffbce20
  41a71b:	ff ff ff 
  41a71e:	48 89 6c 24 08       	mov    QWORD PTR [rsp+0x8],rbp
  41a723:	4c 8d 5c 24 79       	lea    r11,[rsp+0x79]
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  41a728:	49 bd cd cc cc cc cc 	movabs r13,0xcccccccccccccccd
  41a72f:	cc cc cc 
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a732:	4c 01 f8             	add    rax,r15
  41a735:	48 89 1c 24          	mov    QWORD PTR [rsp],rbx
  41a739:	4c 89 f3             	mov    rbx,r14
  41a73c:	49 89 ee             	mov    r14,rbp
  41a73f:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  41a744:	48 b8 33 09 fc ff ff 	movabs rax,0xfffffffffffc0933
  41a74b:	ff ff ff 
  41a74e:	48 89 44 24 48       	mov    QWORD PTR [rsp+0x48],rax
  41a753:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
			char *s = fmt_u(*d, buf+9);
  41a758:	41 8b 36             	mov    esi,DWORD PTR [r14]
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  41a75b:	4c 89 df             	mov    rdi,r11
  41a75e:	48 85 f6             	test   rsi,rsi
  41a761:	0f 84 79 03 00 00    	je     41aae0 <fmt_fp+0x1620>
  41a767:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41a76e:	00 00 
  41a770:	48 89 f0             	mov    rax,rsi
  41a773:	48 89 fd             	mov    rbp,rdi
  41a776:	48 8d 7f ff          	lea    rdi,[rdi-0x1]
  41a77a:	49 f7 e5             	mul    r13
  41a77d:	48 89 f0             	mov    rax,rsi
  41a780:	48 c1 ea 03          	shr    rdx,0x3
  41a784:	48 8d 0c 92          	lea    rcx,[rdx+rdx*4]
  41a788:	48 01 c9             	add    rcx,rcx
  41a78b:	48 29 c8             	sub    rax,rcx
  41a78e:	83 c0 30             	add    eax,0x30
  41a791:	88 45 ff             	mov    BYTE PTR [rbp-0x1],al
  41a794:	48 89 f0             	mov    rax,rsi
  41a797:	48 89 d6             	mov    rsi,rdx
  41a79a:	48 83 f8 09          	cmp    rax,0x9
  41a79e:	77 d0                	ja     41a770 <fmt_fp+0x12b0>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a7a0:	44 8b 03             	mov    r8d,DWORD PTR [rbx]
			if (s==buf+9) *--s='0';
  41a7a3:	48 8d 54 24 70       	lea    rdx,[rsp+0x70]
  41a7a8:	4c 39 df             	cmp    rdi,r11
  41a7ab:	0f 84 32 03 00 00    	je     41aae3 <fmt_fp+0x1623>
			if (d!=a) while (s>buf) *--s='0';
  41a7b1:	4c 39 74 24 08       	cmp    QWORD PTR [rsp+0x8],r14
  41a7b6:	0f 85 b4 01 00 00    	jne    41a970 <fmt_fp+0x14b0>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a7bc:	41 83 e0 20          	and    r8d,0x20
  41a7c0:	0f 84 3f 03 00 00    	je     41ab05 <fmt_fp+0x1645>
				if (p>0||(fl&ALT_FORM)) out(f, ".", 1);
  41a7c6:	8b 44 24 14          	mov    eax,DWORD PTR [rsp+0x14]
  41a7ca:	45 89 e1             	mov    r9d,r12d
  41a7cd:	83 e0 08             	and    eax,0x8
  41a7d0:	44 09 e0             	or     eax,r12d
  41a7d3:	0f 85 67 03 00 00    	jne    41ab40 <fmt_fp+0x1680>
			out(f, s, MIN(buf+9-s, p));
  41a7d9:	4d 89 da             	mov    r10,r11
  41a7dc:	45 31 c9             	xor    r9d,r9d
  41a7df:	49 29 ea             	sub    r10,rbp
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a7e2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
			p -= buf+9-s;
  41a7e8:	45 29 d1             	sub    r9d,r10d
		for (d=a; d<z && p>=0; d++) {
  41a7eb:	49 83 c6 04          	add    r14,0x4
			p -= buf+9-s;
  41a7ef:	4d 63 e1             	movsxd r12,r9d
		for (d=a; d<z && p>=0; d++) {
  41a7f2:	4c 39 34 24          	cmp    QWORD PTR [rsp],r14
  41a7f6:	76 09                	jbe    41a801 <fmt_fp+0x1341>
  41a7f8:	45 85 e4             	test   r12d,r12d
  41a7fb:	0f 89 57 ff ff ff    	jns    41a758 <fmt_fp+0x1298>
  41a801:	44 89 24 24          	mov    DWORD PTR [rsp],r12d
  41a805:	49 89 de             	mov    r14,rbx
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41a808:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  41a80b:	85 c0                	test   eax,eax
  41a80d:	0f 8e 30 06 00 00    	jle    41ae43 <fmt_fp+0x1983>
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41a813:	8b 1c 24             	mov    ebx,DWORD PTR [rsp]
  41a816:	81 fb 00 01 00 00    	cmp    ebx,0x100
  41a81c:	0f 8f 2d 0c 00 00    	jg     41b44f <fmt_fp+0x1f8f>
  41a822:	48 63 eb             	movsxd rbp,ebx
  41a825:	4c 8d ac 24 90 00 00 	lea    r13,[rsp+0x90]
  41a82c:	00 
  41a82d:	be 30 00 00 00       	mov    esi,0x30
  41a832:	48 b8 3c 64 fb ff ff 	movabs rax,0xfffffffffffb643c
  41a839:	ff ff ff 
  41a83c:	4c 01 f8             	add    rax,r15
  41a83f:	48 89 ea             	mov    rdx,rbp
  41a842:	4c 89 ef             	mov    rdi,r13
  41a845:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  41a847:	81 fb 00 01 00 00    	cmp    ebx,0x100
  41a84d:	0f 85 c7 13 00 00    	jne    41bc1a <fmt_fp+0x275a>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a853:	48 bd 20 ce fb ff ff 	movabs rbp,0xfffffffffffbce20
  41a85a:	ff ff ff 
  41a85d:	8b 1c 24             	mov    ebx,DWORD PTR [rsp]
  41a860:	41 8b 16             	mov    edx,DWORD PTR [r14]
  41a863:	81 eb 00 01 00 00    	sub    ebx,0x100
  41a869:	41 89 dc             	mov    r12d,ebx
  41a86c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  41a870:	89 d0                	mov    eax,edx
  41a872:	83 e0 20             	and    eax,0x20
  41a875:	0f 84 0d 03 00 00    	je     41ab88 <fmt_fp+0x16c8>
	for (; l >= sizeof pad; l -= sizeof pad)
  41a87b:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  41a882:	76 14                	jbe    41a898 <fmt_fp+0x13d8>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a884:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  41a886:	41 81 ec 00 01 00 00 	sub    r12d,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a88d:	89 d0                	mov    eax,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  41a88f:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  41a896:	77 ee                	ja     41a886 <fmt_fp+0x13c6>
	out(f, pad, l);
  41a898:	0f b6 eb             	movzx  ebp,bl
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a89b:	85 c0                	test   eax,eax
  41a89d:	0f 84 88 05 00 00    	je     41ae2b <fmt_fp+0x196b>
	pad(f, ' ', w, pl+l, fl^LEFT_ADJ);
  41a8a3:	8b 44 24 14          	mov    eax,DWORD PTR [rsp+0x14]
  41a8a7:	80 f4 20             	xor    ah,0x20
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41a8aa:	a9 00 20 01 00       	test   eax,0x12000
  41a8af:	0f 85 a4 00 00 00    	jne    41a959 <fmt_fp+0x1499>
  41a8b5:	80 7c 24 20 00       	cmp    BYTE PTR [rsp+0x20],0x0
  41a8ba:	0f 85 99 00 00 00    	jne    41a959 <fmt_fp+0x1499>
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41a8c0:	b8 00 01 00 00       	mov    eax,0x100
	l = w - l;
  41a8c5:	44 8b 64 24 58       	mov    r12d,DWORD PTR [rsp+0x58]
  41a8ca:	44 2b 64 24 40       	sub    r12d,DWORD PTR [rsp+0x40]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41a8cf:	4c 8d ac 24 90 00 00 	lea    r13,[rsp+0x90]
  41a8d6:	00 
  41a8d7:	41 39 c4             	cmp    r12d,eax
  41a8da:	be 20 00 00 00       	mov    esi,0x20
  41a8df:	4c 89 ef             	mov    rdi,r13
  41a8e2:	41 0f 4e c4          	cmovle eax,r12d
  41a8e6:	48 63 d0             	movsxd rdx,eax
  41a8e9:	48 b8 3c 64 fb ff ff 	movabs rax,0xfffffffffffb643c
  41a8f0:	ff ff ff 
  41a8f3:	4c 01 f8             	add    rax,r15
  41a8f6:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  41a8f8:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  41a8ff:	0f 8e 0a 13 00 00    	jle    41bc0f <fmt_fp+0x274f>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a905:	41 8b 06             	mov    eax,DWORD PTR [r14]
  41a908:	41 8d ac 24 00 ff ff 	lea    ebp,[r12-0x100]
  41a90f:	ff 
  41a910:	48 bb 20 ce fb ff ff 	movabs rbx,0xfffffffffffbce20
  41a917:	ff ff ff 
  41a91a:	89 c1                	mov    ecx,eax
  41a91c:	83 e1 20             	and    ecx,0x20
  41a91f:	0f 84 2b 02 00 00    	je     41ab50 <fmt_fp+0x1690>
	for (; l >= sizeof pad; l -= sizeof pad)
  41a925:	81 fd ff 00 00 00    	cmp    ebp,0xff
  41a92b:	7e 2c                	jle    41a959 <fmt_fp+0x1499>
  41a92d:	8d 85 00 e9 ff ff    	lea    eax,[rbp-0x1700]
  41a933:	3d 00 e9 ff 7f       	cmp    eax,0x7fffe900
  41a938:	0f 86 ea e7 ff ff    	jbe    419128 <fmt_fp.cold+0x2df>
  41a93e:	81 ed 00 01 00 00    	sub    ebp,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a944:	89 ca                	mov    edx,ecx
	for (; l >= sizeof pad; l -= sizeof pad)
  41a946:	41 89 ec             	mov    r12d,ebp
  41a949:	81 fd ff 00 00 00    	cmp    ebp,0xff
  41a94f:	77 ed                	ja     41a93e <fmt_fp+0x147e>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a951:	85 d2                	test   edx,edx
  41a953:	0f 84 86 10 00 00    	je     41b9df <fmt_fp+0x251f>
	return MAX(w, pl+l);
  41a959:	8b 5c 24 40          	mov    ebx,DWORD PTR [rsp+0x40]
  41a95d:	8b 44 24 58          	mov    eax,DWORD PTR [rsp+0x58]
  41a961:	39 c3                	cmp    ebx,eax
  41a963:	0f 4d c3             	cmovge eax,ebx
  41a966:	e9 ce f8 ff ff       	jmp    41a239 <fmt_fp+0xd79>
  41a96b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
			if (d!=a) while (s>buf) *--s='0';
  41a970:	48 39 d7             	cmp    rdi,rdx
  41a973:	0f 86 42 0a 00 00    	jbe    41b3bb <fmt_fp+0x1efb>
  41a979:	4c 8d 57 ff          	lea    r10,[rdi-0x1]
  41a97d:	48 89 f8             	mov    rax,rdi
  41a980:	be 01 00 00 00       	mov    esi,0x1
  41a985:	48 29 d0             	sub    rax,rdx
  41a988:	49 39 d2             	cmp    r10,rdx
  41a98b:	48 0f 43 f0          	cmovae rsi,rax
  41a98f:	48 83 e8 01          	sub    rax,0x1
  41a993:	48 83 f8 0e          	cmp    rax,0xe
  41a997:	0f 86 a7 0a 00 00    	jbe    41b444 <fmt_fp+0x1f84>
  41a99d:	49 39 d2             	cmp    r10,rdx
  41a9a0:	0f 82 9e 0a 00 00    	jb     41b444 <fmt_fp+0x1f84>
  41a9a6:	48 bd 20 0e fc ff ff 	movabs rbp,0xfffffffffffc0e20
  41a9ad:	ff ff ff 
  41a9b0:	48 89 f0             	mov    rax,rsi
  41a9b3:	49 89 f9             	mov    r9,rdi
  41a9b6:	48 83 e0 f0          	and    rax,0xfffffffffffffff0
  41a9ba:	66 42 0f 6f 44 3d 00 	movdqa xmm0,XMMWORD PTR [rbp+r15*1+0x0]
  41a9c1:	49 29 c1             	sub    r9,rax
			if (s==buf+9) *--s='0';
  41a9c4:	48 89 f8             	mov    rax,rdi
  41a9c7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41a9ce:	00 00 
			if (d!=a) while (s>buf) *--s='0';
  41a9d0:	0f 11 40 f0          	movups XMMWORD PTR [rax-0x10],xmm0
  41a9d4:	48 83 e8 10          	sub    rax,0x10
  41a9d8:	4c 39 c8             	cmp    rax,r9
  41a9db:	75 f3                	jne    41a9d0 <fmt_fp+0x1510>
  41a9dd:	49 89 f1             	mov    r9,rsi
  41a9e0:	48 89 f8             	mov    rax,rdi
  41a9e3:	49 83 e1 f0          	and    r9,0xfffffffffffffff0
  41a9e7:	4c 29 c8             	sub    rax,r9
  41a9ea:	4c 39 ce             	cmp    rsi,r9
  41a9ed:	0f 84 86 00 00 00    	je     41aa79 <fmt_fp+0x15b9>
  41a9f3:	4c 29 ce             	sub    rsi,r9
  41a9f6:	48 8d 6e ff          	lea    rbp,[rsi-0x1]
  41a9fa:	48 83 fd 06          	cmp    rbp,0x6
  41a9fe:	76 27                	jbe    41aa27 <fmt_fp+0x1567>
  41aa00:	48 89 fd             	mov    rbp,rdi
  41aa03:	4c 29 cd             	sub    rbp,r9
  41aa06:	49 b9 20 0e fc ff ff 	movabs r9,0xfffffffffffc0e20
  41aa0d:	ff ff ff 
  41aa10:	4f 8b 0c 0f          	mov    r9,QWORD PTR [r15+r9*1]
  41aa14:	4c 89 4d f8          	mov    QWORD PTR [rbp-0x8],r9
  41aa18:	49 89 f1             	mov    r9,rsi
  41aa1b:	49 83 e1 f8          	and    r9,0xfffffffffffffff8
  41aa1f:	4c 29 c8             	sub    rax,r9
  41aa22:	4c 39 ce             	cmp    rsi,r9
  41aa25:	74 52                	je     41aa79 <fmt_fp+0x15b9>
  41aa27:	48 8d 70 ff          	lea    rsi,[rax-0x1]
  41aa2b:	c6 40 ff 30          	mov    BYTE PTR [rax-0x1],0x30
  41aa2f:	48 39 f2             	cmp    rdx,rsi
  41aa32:	73 45                	jae    41aa79 <fmt_fp+0x15b9>
  41aa34:	48 8d 70 fe          	lea    rsi,[rax-0x2]
  41aa38:	c6 40 fe 30          	mov    BYTE PTR [rax-0x2],0x30
  41aa3c:	48 39 f2             	cmp    rdx,rsi
  41aa3f:	73 38                	jae    41aa79 <fmt_fp+0x15b9>
  41aa41:	48 8d 70 fd          	lea    rsi,[rax-0x3]
  41aa45:	c6 40 fd 30          	mov    BYTE PTR [rax-0x3],0x30
  41aa49:	48 39 f2             	cmp    rdx,rsi
  41aa4c:	73 2b                	jae    41aa79 <fmt_fp+0x15b9>
  41aa4e:	48 8d 70 fc          	lea    rsi,[rax-0x4]
  41aa52:	c6 40 fc 30          	mov    BYTE PTR [rax-0x4],0x30
  41aa56:	48 39 f2             	cmp    rdx,rsi
  41aa59:	73 1e                	jae    41aa79 <fmt_fp+0x15b9>
  41aa5b:	48 8d 70 fb          	lea    rsi,[rax-0x5]
  41aa5f:	c6 40 fb 30          	mov    BYTE PTR [rax-0x5],0x30
  41aa63:	48 39 f2             	cmp    rdx,rsi
  41aa66:	73 11                	jae    41aa79 <fmt_fp+0x15b9>
  41aa68:	48 8d 70 fa          	lea    rsi,[rax-0x6]
  41aa6c:	c6 40 fa 30          	mov    BYTE PTR [rax-0x6],0x30
  41aa70:	48 39 f2             	cmp    rdx,rsi
  41aa73:	73 04                	jae    41aa79 <fmt_fp+0x15b9>
  41aa75:	c6 40 f9 30          	mov    BYTE PTR [rax-0x7],0x30
  41aa79:	48 89 d5             	mov    rbp,rdx
  41aa7c:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
  41aa83:	45 89 e1             	mov    r9d,r12d
  41aa86:	48 29 fd             	sub    rbp,rdi
  41aa89:	49 39 d2             	cmp    r10,rdx
  41aa8c:	48 0f 42 e8          	cmovb  rbp,rax
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41aa90:	41 83 e0 20          	and    r8d,0x20
			if (d!=a) while (s>buf) *--s='0';
  41aa94:	48 01 fd             	add    rbp,rdi
			out(f, s, MIN(buf+9-s, p));
  41aa97:	4d 89 da             	mov    r10,r11
  41aa9a:	49 29 ea             	sub    r10,rbp
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41aa9d:	45 85 c0             	test   r8d,r8d
  41aaa0:	0f 85 42 fd ff ff    	jne    41a7e8 <fmt_fp+0x1328>
			out(f, s, MIN(buf+9-s, p));
  41aaa6:	4d 39 d4             	cmp    r12,r10
  41aaa9:	4c 89 e6             	mov    rsi,r12
  41aaac:	4c 89 5c 24 38       	mov    QWORD PTR [rsp+0x38],r11
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41aab1:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  41aab6:	44 89 4c 24 30       	mov    DWORD PTR [rsp+0x30],r9d
			out(f, s, MIN(buf+9-s, p));
  41aabb:	49 0f 4f f2          	cmovg  rsi,r10
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41aabf:	48 89 da             	mov    rdx,rbx
  41aac2:	48 89 ef             	mov    rdi,rbp
			out(f, s, MIN(buf+9-s, p));
  41aac5:	4c 89 54 24 28       	mov    QWORD PTR [rsp+0x28],r10
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41aaca:	ff d0                	call   rax
  41aacc:	4c 8b 5c 24 38       	mov    r11,QWORD PTR [rsp+0x38]
  41aad1:	44 8b 4c 24 30       	mov    r9d,DWORD PTR [rsp+0x30]
  41aad6:	4c 8b 54 24 28       	mov    r10,QWORD PTR [rsp+0x28]
  41aadb:	e9 08 fd ff ff       	jmp    41a7e8 <fmt_fp+0x1328>
  41aae0:	44 8b 03             	mov    r8d,DWORD PTR [rbx]
			if (s==buf+9) *--s='0';
  41aae3:	c6 44 24 78 30       	mov    BYTE PTR [rsp+0x78],0x30
			if (d!=a) while (s>buf) *--s='0';
  41aae8:	4c 39 74 24 08       	cmp    QWORD PTR [rsp+0x8],r14
  41aaed:	0f 85 87 01 00 00    	jne    41ac7a <fmt_fp+0x17ba>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41aaf3:	41 83 e0 20          	and    r8d,0x20
			if (d!=a) while (s>buf) *--s='0';
  41aaf7:	4c 89 dd             	mov    rbp,r11
			if (s==buf+9) *--s='0';
  41aafa:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41aaff:	0f 85 c1 fc ff ff    	jne    41a7c6 <fmt_fp+0x1306>
  41ab05:	4c 89 5c 24 28       	mov    QWORD PTR [rsp+0x28],r11
  41ab0a:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  41ab0f:	48 89 da             	mov    rdx,rbx
  41ab12:	be 01 00 00 00       	mov    esi,0x1
  41ab17:	ff d0                	call   rax
				if (p>0||(fl&ALT_FORM)) out(f, ".", 1);
  41ab19:	8b 44 24 14          	mov    eax,DWORD PTR [rsp+0x14]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41ab1d:	44 8b 03             	mov    r8d,DWORD PTR [rbx]
  41ab20:	45 89 e1             	mov    r9d,r12d
				if (p>0||(fl&ALT_FORM)) out(f, ".", 1);
  41ab23:	4c 8b 5c 24 28       	mov    r11,QWORD PTR [rsp+0x28]
  41ab28:	83 e0 08             	and    eax,0x8
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41ab2b:	41 83 e0 20          	and    r8d,0x20
				if (p>0||(fl&ALT_FORM)) out(f, ".", 1);
  41ab2f:	44 09 e0             	or     eax,r12d
  41ab32:	0f 85 01 01 00 00    	jne    41ac39 <fmt_fp+0x1779>
  41ab38:	45 31 c9             	xor    r9d,r9d
  41ab3b:	e9 57 ff ff ff       	jmp    41aa97 <fmt_fp+0x15d7>
			out(f, s, MIN(buf+9-s, p));
  41ab40:	4d 89 da             	mov    r10,r11
  41ab43:	49 29 ea             	sub    r10,rbp
  41ab46:	e9 9d fc ff ff       	jmp    41a7e8 <fmt_fp+0x1328>
  41ab4b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41ab50:	4c 89 f2             	mov    rdx,r14
  41ab53:	be 00 01 00 00       	mov    esi,0x100
  41ab58:	4c 89 ef             	mov    rdi,r13
	for (; l >= sizeof pad; l -= sizeof pad)
  41ab5b:	41 89 ec             	mov    r12d,ebp
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41ab5e:	49 8d 04 1f          	lea    rax,[r15+rbx*1]
  41ab62:	ff d0                	call   rax
  41ab64:	41 8b 0e             	mov    ecx,DWORD PTR [r14]
  41ab67:	89 ca                	mov    edx,ecx
  41ab69:	83 e2 20             	and    edx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41ab6c:	81 fd ff 00 00 00    	cmp    ebp,0xff
  41ab72:	0f 8e d9 fd ff ff    	jle    41a951 <fmt_fp+0x1491>
  41ab78:	81 ed 00 01 00 00    	sub    ebp,0x100
  41ab7e:	e9 99 fd ff ff       	jmp    41a91c <fmt_fp+0x145c>
  41ab83:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41ab88:	4c 89 f2             	mov    rdx,r14
  41ab8b:	be 00 01 00 00       	mov    esi,0x100
  41ab90:	49 8d 04 2f          	lea    rax,[r15+rbp*1]
  41ab94:	4c 89 ef             	mov    rdi,r13
  41ab97:	ff d0                	call   rax
  41ab99:	41 8b 16             	mov    edx,DWORD PTR [r14]
  41ab9c:	89 d0                	mov    eax,edx
  41ab9e:	83 e0 20             	and    eax,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41aba1:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  41aba8:	0f 86 ea fc ff ff    	jbe    41a898 <fmt_fp+0x13d8>
  41abae:	41 81 ec 00 01 00 00 	sub    r12d,0x100
  41abb5:	e9 b6 fc ff ff       	jmp    41a870 <fmt_fp+0x13b0>
  41abba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41abc0:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  41abc5:	4c 89 f2             	mov    rdx,r14
  41abc8:	be 00 01 00 00       	mov    esi,0x100
  41abcd:	4c 89 ef             	mov    rdi,r13
  41abd0:	4c 01 f8             	add    rax,r15
  41abd3:	ff d0                	call   rax
  41abd5:	41 8b 36             	mov    esi,DWORD PTR [r14]
	for (; l >= sizeof pad; l -= sizeof pad)
  41abd8:	45 89 e1             	mov    r9d,r12d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41abdb:	89 f2                	mov    edx,esi
  41abdd:	83 e2 20             	and    edx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41abe0:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  41abe7:	0f 8e da fa ff ff    	jle    41a6c7 <fmt_fp+0x1207>
  41abed:	41 81 ec 00 01 00 00 	sub    r12d,0x100
  41abf4:	e9 94 fa ff ff       	jmp    41a68d <fmt_fp+0x11cd>
  41abf9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41ac00:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  41ac05:	be 00 01 00 00       	mov    esi,0x100
  41ac0a:	4c 89 f2             	mov    rdx,r14
  41ac0d:	4c 89 ef             	mov    rdi,r13
  41ac10:	4c 01 f8             	add    rax,r15
  41ac13:	ff d0                	call   rax
  41ac15:	41 8b 06             	mov    eax,DWORD PTR [r14]
	for (; l >= sizeof pad; l -= sizeof pad)
  41ac18:	44 89 e1             	mov    ecx,r12d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41ac1b:	89 c6                	mov    esi,eax
  41ac1d:	83 e6 20             	and    esi,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41ac20:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  41ac27:	0f 8e ab f9 ff ff    	jle    41a5d8 <fmt_fp+0x1118>
  41ac2d:	41 81 ec 00 01 00 00 	sub    r12d,0x100
  41ac34:	e9 61 f9 ff ff       	jmp    41a59a <fmt_fp+0x10da>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41ac39:	45 85 c0             	test   r8d,r8d
  41ac3c:	0f 85 fe fe ff ff    	jne    41ab40 <fmt_fp+0x1680>
  41ac42:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
  41ac47:	4c 89 5c 24 30       	mov    QWORD PTR [rsp+0x30],r11
  41ac4c:	48 89 da             	mov    rdx,rbx
  41ac4f:	be 01 00 00 00       	mov    esi,0x1
  41ac54:	44 89 64 24 28       	mov    DWORD PTR [rsp+0x28],r12d
  41ac59:	49 8d 3c 07          	lea    rdi,[r15+rax*1]
  41ac5d:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  41ac62:	ff d0                	call   rax
  41ac64:	44 8b 03             	mov    r8d,DWORD PTR [rbx]
  41ac67:	44 8b 4c 24 28       	mov    r9d,DWORD PTR [rsp+0x28]
  41ac6c:	4c 8b 5c 24 30       	mov    r11,QWORD PTR [rsp+0x30]
  41ac71:	41 83 e0 20          	and    r8d,0x20
  41ac75:	e9 1d fe ff ff       	jmp    41aa97 <fmt_fp+0x15d7>
			if (s==buf+9) *--s='0';
  41ac7a:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
  41ac7f:	48 8d 54 24 70       	lea    rdx,[rsp+0x70]
  41ac84:	e9 f0 fc ff ff       	jmp    41a979 <fmt_fp+0x14b9>
			if (s-buf==1 && (y||p>0||(fl&ALT_FORM))) *s++='.';
  41ac89:	c6 42 01 2e          	mov    BYTE PTR [rdx+0x1],0x2e
  41ac8d:	48 83 c2 02          	add    rdx,0x2
  41ac91:	e9 bd ee ff ff       	jmp    419b53 <fmt_fp+0x693>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41ac96:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  41ac9b:	be 00 01 00 00       	mov    esi,0x100
  41aca0:	4c 89 f2             	mov    rdx,r14
  41aca3:	48 89 ef             	mov    rdi,rbp
  41aca6:	4c 01 f8             	add    rax,r15
  41aca9:	ff d0                	call   rax
  41acab:	41 8b 06             	mov    eax,DWORD PTR [r14]
  41acae:	89 c6                	mov    esi,eax
  41acb0:	83 e6 20             	and    esi,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41acb3:	81 fb ff 00 00 00    	cmp    ebx,0xff
  41acb9:	0f 8e 16 11 00 00    	jle    41bdd5 <fmt_fp+0x2915>
  41acbf:	81 eb 00 01 00 00    	sub    ebx,0x100
  41acc5:	e9 d9 ef ff ff       	jmp    419ca3 <fmt_fp+0x7e3>
  41acca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41acd0:	4c 89 f2             	mov    rdx,r14
  41acd3:	be 00 01 00 00       	mov    esi,0x100
  41acd8:	49 8d 04 2f          	lea    rax,[r15+rbp*1]
  41acdc:	4c 89 e7             	mov    rdi,r12
  41acdf:	ff d0                	call   rax
  41ace1:	41 8b 06             	mov    eax,DWORD PTR [r14]
  41ace4:	89 c1                	mov    ecx,eax
  41ace6:	83 e1 20             	and    ecx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41ace9:	81 fb ff 00 00 00    	cmp    ebx,0xff
  41acef:	0f 8e ea 10 00 00    	jle    41bddf <fmt_fp+0x291f>
  41acf5:	81 eb 00 01 00 00    	sub    ebx,0x100
  41acfb:	e9 42 f1 ff ff       	jmp    419e42 <fmt_fp+0x982>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41ad00:	4c 89 f2             	mov    rdx,r14
  41ad03:	be 00 01 00 00       	mov    esi,0x100
  41ad08:	49 8d 04 1f          	lea    rax,[r15+rbx*1]
  41ad0c:	48 89 ef             	mov    rdi,rbp
  41ad0f:	ff d0                	call   rax
  41ad11:	41 8b 06             	mov    eax,DWORD PTR [r14]
  41ad14:	89 c1                	mov    ecx,eax
  41ad16:	83 e1 20             	and    ecx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41ad19:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  41ad20:	0f 8e eb 07 00 00    	jle    41b511 <fmt_fp+0x2051>
  41ad26:	41 81 ed 00 01 00 00 	sub    r13d,0x100
  41ad2d:	e9 55 f0 ff ff       	jmp    419d87 <fmt_fp+0x8c7>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41ad32:	4c 89 f2             	mov    rdx,r14
  41ad35:	be 00 01 00 00       	mov    esi,0x100
  41ad3a:	4c 89 ef             	mov    rdi,r13
	for (; l >= sizeof pad; l -= sizeof pad)
  41ad3d:	41 89 ec             	mov    r12d,ebp
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41ad40:	49 8d 04 1f          	lea    rax,[r15+rbx*1]
  41ad44:	ff d0                	call   rax
  41ad46:	41 8b 0e             	mov    ecx,DWORD PTR [r14]
  41ad49:	89 ca                	mov    edx,ecx
  41ad4b:	83 e2 20             	and    edx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41ad4e:	81 fd ff 00 00 00    	cmp    ebp,0xff
  41ad54:	0f 8e af 07 00 00    	jle    41b509 <fmt_fp+0x2049>
  41ad5a:	81 ed 00 01 00 00    	sub    ebp,0x100
  41ad60:	e9 e1 f1 ff ff       	jmp    419f46 <fmt_fp+0xa86>
	l = 1 + p + (p || (fl&ALT_FORM));
  41ad65:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  41ad68:	41 b8 01 00 00 00    	mov    r8d,0x1
  41ad6e:	83 c0 01             	add    eax,0x1
	if (p > INT_MAX-1-(p || (fl&ALT_FORM)))
  41ad71:	81 3c 24 fd ff ff 7f 	cmp    DWORD PTR [rsp],0x7ffffffd
  41ad78:	0f 8e b3 f6 ff ff    	jle    41a431 <fmt_fp+0xf71>
			return -1;
  41ad7e:	b8 ff ff ff ff       	mov    eax,0xffffffff
  41ad83:	e9 b1 f4 ff ff       	jmp    41a239 <fmt_fp+0xd79>
  41ad88:	c6 44 24 40 01       	mov    BYTE PTR [rsp+0x40],0x1
	if (p<0) p=6;
  41ad8d:	c7 04 24 06 00 00 00 	mov    DWORD PTR [rsp],0x6
  41ad94:	e9 72 e8 ff ff       	jmp    41960b <fmt_fp+0x14b>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41ad99:	48 8b 74 24 38       	mov    rsi,QWORD PTR [rsp+0x38]
  41ad9e:	48 8b 7c 24 30       	mov    rdi,QWORD PTR [rsp+0x30]
  41ada3:	4c 89 f2             	mov    rdx,r14
  41ada6:	48 b8 20 ce fb ff ff 	movabs rax,0xfffffffffffbce20
  41adad:	ff ff ff 
  41adb0:	4d 8d 2c 07          	lea    r13,[r15+rax*1]
  41adb4:	41 ff d5             	call   r13
  41adb7:	41 f6 06 20          	test   BYTE PTR [r14],0x20
  41adbb:	0f 85 8e f3 ff ff    	jne    41a14f <fmt_fp+0xc8f>
  41adc1:	4c 89 f2             	mov    rdx,r14
  41adc4:	be 03 00 00 00       	mov    esi,0x3
  41adc9:	4c 89 e7             	mov    rdi,r12
  41adcc:	41 ff d5             	call   r13
  41adcf:	e9 7b f3 ff ff       	jmp    41a14f <fmt_fp+0xc8f>
  41add4:	48 b8 20 ce fb ff ff 	movabs rax,0xfffffffffffbce20
  41addb:	ff ff ff 
	out(f, pad, l);
  41adde:	48 63 f5             	movsxd rsi,ebp
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41ade1:	4c 89 f2             	mov    rdx,r14
  41ade4:	4c 89 d7             	mov    rdi,r10
  41ade7:	4c 01 f8             	add    rax,r15
  41adea:	ff d0                	call   rax
  41adec:	41 8b 0e             	mov    ecx,DWORD PTR [r14]
  41adef:	83 e1 20             	and    ecx,0x20
  41adf2:	85 c9                	test   ecx,ecx
  41adf4:	0f 85 d9 ef ff ff    	jne    419dd3 <fmt_fp+0x913>
  41adfa:	48 b8 20 ce fb ff ff 	movabs rax,0xfffffffffffbce20
  41ae01:	ff ff ff 
  41ae04:	48 8b 74 24 48       	mov    rsi,QWORD PTR [rsp+0x48]
  41ae09:	4c 89 f2             	mov    rdx,r14
  41ae0c:	4c 89 e7             	mov    rdi,r12
  41ae0f:	4c 01 f8             	add    rax,r15
  41ae12:	ff d0                	call   rax
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41ae14:	44 8b 44 24 08       	mov    r8d,DWORD PTR [rsp+0x8]
  41ae19:	8b 5c 24 38          	mov    ebx,DWORD PTR [rsp+0x38]
  41ae1d:	45 85 c0             	test   r8d,r8d
  41ae20:	0f 8f bb ef ff ff    	jg     419de1 <fmt_fp+0x921>
  41ae26:	e9 72 f0 ff ff       	jmp    419e9d <fmt_fp+0x9dd>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41ae2b:	48 b8 20 ce fb ff ff 	movabs rax,0xfffffffffffbce20
  41ae32:	ff ff ff 
  41ae35:	4c 89 f2             	mov    rdx,r14
  41ae38:	48 89 ee             	mov    rsi,rbp
  41ae3b:	4c 89 ef             	mov    rdi,r13
  41ae3e:	4c 01 f8             	add    rax,r15
  41ae41:	ff d0                	call   rax
  41ae43:	41 8b 06             	mov    eax,DWORD PTR [r14]
  41ae46:	83 e0 20             	and    eax,0x20
  41ae49:	85 c0                	test   eax,eax
  41ae4b:	0f 85 52 fa ff ff    	jne    41a8a3 <fmt_fp+0x13e3>
		out(f, estr, ebuf-estr);
  41ae51:	48 8b 7c 24 50       	mov    rdi,QWORD PTR [rsp+0x50]
  41ae56:	48 8d 74 24 70       	lea    rsi,[rsp+0x70]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41ae5b:	4c 89 f2             	mov    rdx,r14
  41ae5e:	48 b8 20 ce fb ff ff 	movabs rax,0xfffffffffffbce20
  41ae65:	ff ff ff 
  41ae68:	4c 01 f8             	add    rax,r15
		out(f, estr, ebuf-estr);
  41ae6b:	48 29 fe             	sub    rsi,rdi
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41ae6e:	ff d0                	call   rax
  41ae70:	e9 2e fa ff ff       	jmp    41a8a3 <fmt_fp+0x13e3>
		if (!p) p++;
  41ae75:	8b 0c 24             	mov    ecx,DWORD PTR [rsp]
  41ae78:	b8 01 00 00 00       	mov    eax,0x1
  41ae7d:	85 c9                	test   ecx,ecx
  41ae7f:	0f 45 c1             	cmovne eax,ecx
  41ae82:	89 04 24             	mov    DWORD PTR [rsp],eax
  41ae85:	89 c1                	mov    ecx,eax
		if (p>e && e>=-4) {
  41ae87:	39 f8                	cmp    eax,edi
  41ae89:	0f 8e ac 06 00 00    	jle    41b53b <fmt_fp+0x207b>
  41ae8f:	83 ff fc             	cmp    edi,0xfffffffc
  41ae92:	0f 8c a3 06 00 00    	jl     41b53b <fmt_fp+0x207b>
			p-=e+1;
  41ae98:	8d 47 01             	lea    eax,[rdi+0x1]
			t--;
  41ae9b:	83 6c 24 20 01       	sub    DWORD PTR [rsp+0x20],0x1
			p-=e+1;
  41aea0:	29 c1                	sub    ecx,eax
  41aea2:	89 0c 24             	mov    DWORD PTR [rsp],ecx
		if (!(fl&ALT_FORM)) {
  41aea5:	f6 44 24 14 08       	test   BYTE PTR [rsp+0x14],0x8
  41aeaa:	0f 85 64 f5 ff ff    	jne    41a414 <fmt_fp+0xf54>
			if (z>a && z[-1]) for (i=10, j=0; z[-1]%i==0; i*=10, j++);
  41aeb0:	be 09 00 00 00       	mov    esi,0x9
  41aeb5:	48 39 dd             	cmp    rbp,rbx
  41aeb8:	73 3a                	jae    41aef4 <fmt_fp+0x1a34>
  41aeba:	44 8b 43 fc          	mov    r8d,DWORD PTR [rbx-0x4]
  41aebe:	45 85 c0             	test   r8d,r8d
  41aec1:	74 31                	je     41aef4 <fmt_fp+0x1a34>
  41aec3:	41 69 c0 cd cc cc cc 	imul   eax,r8d,0xcccccccd
  41aeca:	d1 c8                	ror    eax,1
  41aecc:	3d 99 99 99 19       	cmp    eax,0x19999999
  41aed1:	0f 87 f7 0e 00 00    	ja     41bdce <fmt_fp+0x290e>
  41aed7:	31 f6                	xor    esi,esi
  41aed9:	b9 0a 00 00 00       	mov    ecx,0xa
  41aede:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  41aee1:	44 89 c0             	mov    eax,r8d
  41aee4:	31 d2                	xor    edx,edx
  41aee6:	83 c6 01             	add    esi,0x1
  41aee9:	01 c9                	add    ecx,ecx
  41aeeb:	f7 f1                	div    ecx
  41aeed:	85 d2                	test   edx,edx
  41aeef:	74 ed                	je     41aede <fmt_fp+0x1a1e>
				p = MIN(p,MAX(0,9*(z-r-1)-j));
  41aef1:	48 63 f6             	movsxd rsi,esi
  41aef4:	48 89 d8             	mov    rax,rbx
  41aef7:	48 2b 44 24 18       	sub    rax,QWORD PTR [rsp+0x18]
  41aefc:	48 63 0c 24          	movsxd rcx,DWORD PTR [rsp]
  41af00:	48 c1 f8 02          	sar    rax,0x2
  41af04:	48 8d 54 c0 f7       	lea    rdx,[rax+rax*8-0x9]
			if ((t|32)=='f')
  41af09:	8b 44 24 20          	mov    eax,DWORD PTR [rsp+0x20]
  41af0d:	83 c8 20             	or     eax,0x20
  41af10:	83 f8 66             	cmp    eax,0x66
  41af13:	0f 84 5a 0b 00 00    	je     41ba73 <fmt_fp+0x25b3>
				p = MIN(p,MAX(0,9*(z-r-1)+e-j));
  41af19:	48 63 c7             	movsxd rax,edi
  41af1c:	48 01 d0             	add    rax,rdx
  41af1f:	ba 00 00 00 00       	mov    edx,0x0
  41af24:	48 29 f0             	sub    rax,rsi
  41af27:	48 0f 48 c2          	cmovs  rax,rdx
  41af2b:	48 39 c8             	cmp    rax,rcx
  41af2e:	48 0f 4e c8          	cmovle rcx,rax
  41af32:	48 89 0c 24          	mov    QWORD PTR [rsp],rcx
  41af36:	e9 d9 f4 ff ff       	jmp    41a414 <fmt_fp+0xf54>
			if (d!=a) while (s>buf) *--s='0';
  41af3b:	49 bc 20 0e fc ff ff 	movabs r12,0xfffffffffffc0e20
  41af42:	ff ff ff 
  41af45:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  41af4a:	48 39 e8             	cmp    rax,rbp
  41af4d:	48 0f 46 e8          	cmovbe rbp,rax
  41af51:	48 b8 20 0e fc ff ff 	movabs rax,0xfffffffffffc0e20
  41af58:	ff ff ff 
  41af5b:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41af60:	48 b8 20 ce fb ff ff 	movabs rax,0xfffffffffffbce20
  41af67:	ff ff ff 
			char *s = fmt_u(*d, buf+9);
  41af6a:	8b 4d 00             	mov    ecx,DWORD PTR [rbp+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41af6d:	4c 01 f8             	add    rax,r15
  41af70:	49 89 ed             	mov    r13,rbp
  41af73:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  41af78:	48 85 c9             	test   rcx,rcx
  41af7b:	0f 84 dc 03 00 00    	je     41b35d <fmt_fp+0x1e9d>
  41af81:	49 b8 cd cc cc cc cc 	movabs r8,0xcccccccccccccccd
  41af88:	cc cc cc 
  41af8b:	48 8d 74 24 79       	lea    rsi,[rsp+0x79]
  41af90:	48 89 f7             	mov    rdi,rsi
  41af93:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  41af98:	48 89 c8             	mov    rax,rcx
  41af9b:	48 83 ef 01          	sub    rdi,0x1
  41af9f:	49 f7 e0             	mul    r8
  41afa2:	48 89 c8             	mov    rax,rcx
  41afa5:	48 c1 ea 03          	shr    rdx,0x3
  41afa9:	4c 8d 0c 92          	lea    r9,[rdx+rdx*4]
  41afad:	4d 01 c9             	add    r9,r9
  41afb0:	4c 29 c8             	sub    rax,r9
  41afb3:	83 c0 30             	add    eax,0x30
  41afb6:	88 07                	mov    BYTE PTR [rdi],al
  41afb8:	48 89 c8             	mov    rax,rcx
  41afbb:	48 89 d1             	mov    rcx,rdx
  41afbe:	48 83 f8 09          	cmp    rax,0x9
  41afc2:	77 d4                	ja     41af98 <fmt_fp+0x1ad8>
			if (d!=a) while (s>buf) *--s='0';
  41afc4:	49 39 ed             	cmp    r13,rbp
  41afc7:	0f 84 43 03 00 00    	je     41b310 <fmt_fp+0x1e50>
  41afcd:	48 8d 4c 24 70       	lea    rcx,[rsp+0x70]
  41afd2:	48 39 cf             	cmp    rdi,rcx
  41afd5:	0f 86 ff 00 00 00    	jbe    41b0da <fmt_fp+0x1c1a>
  41afdb:	4c 8d 4f ff          	lea    r9,[rdi-0x1]
  41afdf:	48 89 f8             	mov    rax,rdi
  41afe2:	ba 01 00 00 00       	mov    edx,0x1
  41afe7:	48 29 c8             	sub    rax,rcx
  41afea:	49 39 c9             	cmp    r9,rcx
  41afed:	48 0f 43 d0          	cmovae rdx,rax
  41aff1:	48 83 e8 01          	sub    rax,0x1
  41aff5:	48 83 f8 0e          	cmp    rax,0xe
  41aff9:	0f 86 c0 09 00 00    	jbe    41b9bf <fmt_fp+0x24ff>
  41afff:	49 39 c9             	cmp    r9,rcx
  41b002:	0f 82 b7 09 00 00    	jb     41b9bf <fmt_fp+0x24ff>
  41b008:	4c 8b 5c 24 08       	mov    r11,QWORD PTR [rsp+0x8]
  41b00d:	48 89 d0             	mov    rax,rdx
  41b010:	49 89 f8             	mov    r8,rdi
  41b013:	48 83 e0 f0          	and    rax,0xfffffffffffffff0
  41b017:	66 43 0f 6f 04 3b    	movdqa xmm0,XMMWORD PTR [r11+r15*1]
  41b01d:	49 29 c0             	sub    r8,rax
  41b020:	48 89 f8             	mov    rax,rdi
  41b023:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  41b028:	0f 11 40 f0          	movups XMMWORD PTR [rax-0x10],xmm0
  41b02c:	48 83 e8 10          	sub    rax,0x10
  41b030:	49 39 c0             	cmp    r8,rax
  41b033:	75 f3                	jne    41b028 <fmt_fp+0x1b68>
  41b035:	49 89 d0             	mov    r8,rdx
  41b038:	48 89 f8             	mov    rax,rdi
  41b03b:	49 83 e0 f0          	and    r8,0xfffffffffffffff0
  41b03f:	4c 29 c0             	sub    rax,r8
  41b042:	4c 39 c2             	cmp    rdx,r8
  41b045:	74 7c                	je     41b0c3 <fmt_fp+0x1c03>
  41b047:	4c 29 c2             	sub    rdx,r8
  41b04a:	4c 8d 52 ff          	lea    r10,[rdx-0x1]
  41b04e:	49 83 fa 06          	cmp    r10,0x6
  41b052:	76 1d                	jbe    41b071 <fmt_fp+0x1bb1>
  41b054:	49 89 fa             	mov    r10,rdi
  41b057:	4d 29 c2             	sub    r10,r8
  41b05a:	4f 8b 04 27          	mov    r8,QWORD PTR [r15+r12*1]
  41b05e:	4d 89 42 f8          	mov    QWORD PTR [r10-0x8],r8
  41b062:	49 89 d0             	mov    r8,rdx
  41b065:	49 83 e0 f8          	and    r8,0xfffffffffffffff8
  41b069:	4c 29 c0             	sub    rax,r8
  41b06c:	4c 39 c2             	cmp    rdx,r8
  41b06f:	74 52                	je     41b0c3 <fmt_fp+0x1c03>
  41b071:	48 8d 50 ff          	lea    rdx,[rax-0x1]
  41b075:	c6 40 ff 30          	mov    BYTE PTR [rax-0x1],0x30
  41b079:	48 39 d1             	cmp    rcx,rdx
  41b07c:	73 45                	jae    41b0c3 <fmt_fp+0x1c03>
  41b07e:	48 8d 50 fe          	lea    rdx,[rax-0x2]
  41b082:	c6 40 fe 30          	mov    BYTE PTR [rax-0x2],0x30
  41b086:	48 39 d1             	cmp    rcx,rdx
  41b089:	73 38                	jae    41b0c3 <fmt_fp+0x1c03>
  41b08b:	48 8d 50 fd          	lea    rdx,[rax-0x3]
  41b08f:	c6 40 fd 30          	mov    BYTE PTR [rax-0x3],0x30
  41b093:	48 39 d1             	cmp    rcx,rdx
  41b096:	73 2b                	jae    41b0c3 <fmt_fp+0x1c03>
  41b098:	48 8d 50 fc          	lea    rdx,[rax-0x4]
  41b09c:	c6 40 fc 30          	mov    BYTE PTR [rax-0x4],0x30
  41b0a0:	48 39 d1             	cmp    rcx,rdx
  41b0a3:	73 1e                	jae    41b0c3 <fmt_fp+0x1c03>
  41b0a5:	48 8d 50 fb          	lea    rdx,[rax-0x5]
  41b0a9:	c6 40 fb 30          	mov    BYTE PTR [rax-0x5],0x30
  41b0ad:	48 39 d1             	cmp    rcx,rdx
  41b0b0:	73 11                	jae    41b0c3 <fmt_fp+0x1c03>
  41b0b2:	48 8d 50 fa          	lea    rdx,[rax-0x6]
  41b0b6:	c6 40 fa 30          	mov    BYTE PTR [rax-0x6],0x30
  41b0ba:	48 39 d1             	cmp    rcx,rdx
  41b0bd:	73 04                	jae    41b0c3 <fmt_fp+0x1c03>
  41b0bf:	c6 40 f9 30          	mov    BYTE PTR [rax-0x7],0x30
  41b0c3:	48 89 c8             	mov    rax,rcx
  41b0c6:	48 c7 c2 ff ff ff ff 	mov    rdx,0xffffffffffffffff
  41b0cd:	48 29 f8             	sub    rax,rdi
  41b0d0:	49 39 c9             	cmp    r9,rcx
  41b0d3:	48 0f 42 c2          	cmovb  rax,rdx
  41b0d7:	48 01 c7             	add    rdi,rax
			out(f, s, buf+9-s);
  41b0da:	48 29 fe             	sub    rsi,rdi
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b0dd:	41 f6 06 20          	test   BYTE PTR [r14],0x20
  41b0e1:	0f 84 51 02 00 00    	je     41b338 <fmt_fp+0x1e78>
		for (d=a; d<=r; d++) {
  41b0e7:	48 8d 7d 04          	lea    rdi,[rbp+0x4]
  41b0eb:	48 3b 7c 24 18       	cmp    rdi,QWORD PTR [rsp+0x18]
  41b0f0:	0f 87 84 01 00 00    	ja     41b27a <fmt_fp+0x1dba>
  41b0f6:	48 b8 20 0e fc ff ff 	movabs rax,0xfffffffffffc0e20
  41b0fd:	ff ff ff 
			if (d!=a) while (s>buf) *--s='0';
  41b100:	4c 8d 54 24 79       	lea    r10,[rsp+0x79]
  41b105:	4c 8d 4c 24 70       	lea    r9,[rsp+0x70]
  41b10a:	48 c7 c5 f8 ff ff ff 	mov    rbp,0xfffffffffffffff8
  41b111:	49 bb 20 0e fc ff ff 	movabs r11,0xfffffffffffc0e20
  41b118:	ff ff ff 
  41b11b:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  41b120:	49 b8 cd cc cc cc cc 	movabs r8,0xcccccccccccccccd
  41b127:	cc cc cc 
			char *s = fmt_u(*d, buf+9);
  41b12a:	8b 0f                	mov    ecx,DWORD PTR [rdi]
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  41b12c:	4c 89 d6             	mov    rsi,r10
  41b12f:	48 85 c9             	test   rcx,rcx
  41b132:	0f 84 75 02 00 00    	je     41b3ad <fmt_fp+0x1eed>
  41b138:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41b13f:	00 
  41b140:	48 89 c8             	mov    rax,rcx
  41b143:	48 83 ee 01          	sub    rsi,0x1
  41b147:	49 f7 e0             	mul    r8
  41b14a:	48 89 c8             	mov    rax,rcx
  41b14d:	48 c1 ea 03          	shr    rdx,0x3
  41b151:	4c 8d 24 92          	lea    r12,[rdx+rdx*4]
  41b155:	4d 01 e4             	add    r12,r12
  41b158:	4c 29 e0             	sub    rax,r12
  41b15b:	83 c0 30             	add    eax,0x30
  41b15e:	88 06                	mov    BYTE PTR [rsi],al
  41b160:	48 89 c8             	mov    rax,rcx
  41b163:	48 89 d1             	mov    rcx,rdx
  41b166:	48 83 f8 09          	cmp    rax,0x9
  41b16a:	77 d4                	ja     41b140 <fmt_fp+0x1c80>
			if (d!=a) while (s>buf) *--s='0';
  41b16c:	49 39 fd             	cmp    r13,rdi
  41b16f:	0f 84 83 01 00 00    	je     41b2f8 <fmt_fp+0x1e38>
  41b175:	4c 39 ce             	cmp    rsi,r9
  41b178:	0f 86 ed 00 00 00    	jbe    41b26b <fmt_fp+0x1dab>
  41b17e:	4c 8d 66 ff          	lea    r12,[rsi-0x1]
  41b182:	48 89 f1             	mov    rcx,rsi
  41b185:	ba 01 00 00 00       	mov    edx,0x1
  41b18a:	48 89 f0             	mov    rax,rsi
  41b18d:	4c 29 c9             	sub    rcx,r9
  41b190:	4d 39 cc             	cmp    r12,r9
  41b193:	48 0f 43 d1          	cmovae rdx,rcx
  41b197:	48 83 e9 01          	sub    rcx,0x1
  41b19b:	48 83 f9 0e          	cmp    rcx,0xe
  41b19f:	0f 86 25 08 00 00    	jbe    41b9ca <fmt_fp+0x250a>
  41b1a5:	4d 39 cc             	cmp    r12,r9
  41b1a8:	0f 82 1c 08 00 00    	jb     41b9ca <fmt_fp+0x250a>
  41b1ae:	49 89 d4             	mov    r12,rdx
  41b1b1:	48 89 f1             	mov    rcx,rsi
  41b1b4:	49 83 e4 f0          	and    r12,0xfffffffffffffff0
  41b1b8:	4c 29 e1             	sub    rcx,r12
  41b1bb:	4c 8b 64 24 08       	mov    r12,QWORD PTR [rsp+0x8]
  41b1c0:	66 43 0f 6f 04 3c    	movdqa xmm0,XMMWORD PTR [r12+r15*1]
  41b1c6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41b1cd:	00 00 00 
  41b1d0:	0f 11 40 f0          	movups XMMWORD PTR [rax-0x10],xmm0
  41b1d4:	48 83 e8 10          	sub    rax,0x10
  41b1d8:	48 39 c1             	cmp    rcx,rax
  41b1db:	75 f3                	jne    41b1d0 <fmt_fp+0x1d10>
  41b1dd:	48 89 d1             	mov    rcx,rdx
  41b1e0:	48 89 f0             	mov    rax,rsi
  41b1e3:	48 83 e1 f0          	and    rcx,0xfffffffffffffff0
  41b1e7:	48 29 c8             	sub    rax,rcx
  41b1ea:	48 39 d1             	cmp    rcx,rdx
  41b1ed:	74 7c                	je     41b26b <fmt_fp+0x1dab>
  41b1ef:	48 29 ca             	sub    rdx,rcx
  41b1f2:	4c 8d 62 ff          	lea    r12,[rdx-0x1]
  41b1f6:	49 83 fc 06          	cmp    r12,0x6
  41b1fa:	76 1d                	jbe    41b219 <fmt_fp+0x1d59>
  41b1fc:	49 89 ec             	mov    r12,rbp
  41b1ff:	49 29 cc             	sub    r12,rcx
  41b202:	4b 8b 0c 1f          	mov    rcx,QWORD PTR [r15+r11*1]
  41b206:	4a 89 0c 26          	mov    QWORD PTR [rsi+r12*1],rcx
  41b20a:	48 89 d1             	mov    rcx,rdx
  41b20d:	48 83 e1 f8          	and    rcx,0xfffffffffffffff8
  41b211:	48 29 c8             	sub    rax,rcx
  41b214:	48 39 ca             	cmp    rdx,rcx
  41b217:	74 52                	je     41b26b <fmt_fp+0x1dab>
  41b219:	48 8d 50 ff          	lea    rdx,[rax-0x1]
  41b21d:	c6 40 ff 30          	mov    BYTE PTR [rax-0x1],0x30
  41b221:	49 39 d1             	cmp    r9,rdx
  41b224:	73 45                	jae    41b26b <fmt_fp+0x1dab>
  41b226:	48 8d 50 fe          	lea    rdx,[rax-0x2]
  41b22a:	c6 40 fe 30          	mov    BYTE PTR [rax-0x2],0x30
  41b22e:	49 39 d1             	cmp    r9,rdx
  41b231:	73 38                	jae    41b26b <fmt_fp+0x1dab>
  41b233:	48 8d 50 fd          	lea    rdx,[rax-0x3]
  41b237:	c6 40 fd 30          	mov    BYTE PTR [rax-0x3],0x30
  41b23b:	49 39 d1             	cmp    r9,rdx
  41b23e:	73 2b                	jae    41b26b <fmt_fp+0x1dab>
  41b240:	48 8d 50 fc          	lea    rdx,[rax-0x4]
  41b244:	c6 40 fc 30          	mov    BYTE PTR [rax-0x4],0x30
  41b248:	49 39 d1             	cmp    r9,rdx
  41b24b:	73 1e                	jae    41b26b <fmt_fp+0x1dab>
  41b24d:	48 8d 50 fb          	lea    rdx,[rax-0x5]
  41b251:	c6 40 fb 30          	mov    BYTE PTR [rax-0x5],0x30
  41b255:	49 39 d1             	cmp    r9,rdx
  41b258:	73 11                	jae    41b26b <fmt_fp+0x1dab>
  41b25a:	48 8d 50 fa          	lea    rdx,[rax-0x6]
  41b25e:	c6 40 fa 30          	mov    BYTE PTR [rax-0x6],0x30
  41b262:	49 39 d1             	cmp    r9,rdx
  41b265:	73 04                	jae    41b26b <fmt_fp+0x1dab>
  41b267:	c6 40 f9 30          	mov    BYTE PTR [rax-0x7],0x30
		for (d=a; d<=r; d++) {
  41b26b:	48 83 c7 04          	add    rdi,0x4
  41b26f:	48 39 7c 24 18       	cmp    QWORD PTR [rsp+0x18],rdi
  41b274:	0f 83 b0 fe ff ff    	jae    41b12a <fmt_fp+0x1c6a>
  41b27a:	48 8b 7c 24 18       	mov    rdi,QWORD PTR [rsp+0x18]
		if (p || (fl&ALT_FORM)) out(f, ".", 1);
  41b27f:	8b 0c 24             	mov    ecx,DWORD PTR [rsp]
		for (d=a; d<=r; d++) {
  41b282:	48 89 f8             	mov    rax,rdi
  41b285:	48 83 c7 01          	add    rdi,0x1
  41b289:	4c 29 e8             	sub    rax,r13
  41b28c:	48 c1 e8 02          	shr    rax,0x2
  41b290:	4c 8d 04 85 04 00 00 	lea    r8,[rax*4+0x4]
  41b297:	00 
  41b298:	49 8d 45 01          	lea    rax,[r13+0x1]
  41b29c:	48 39 c7             	cmp    rdi,rax
  41b29f:	b8 04 00 00 00       	mov    eax,0x4
  41b2a4:	4c 0f 42 c0          	cmovb  r8,rax
  41b2a8:	4b 8d 6c 05 00       	lea    rbp,[r13+r8*1+0x0]
		if (p || (fl&ALT_FORM)) out(f, ".", 1);
  41b2ad:	85 c9                	test   ecx,ecx
  41b2af:	0f 85 94 02 00 00    	jne    41b549 <fmt_fp+0x2089>
  41b2b5:	f6 44 24 14 08       	test   BYTE PTR [rsp+0x14],0x8
  41b2ba:	0f 84 e3 f5 ff ff    	je     41a8a3 <fmt_fp+0x13e3>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b2c0:	41 f6 06 20          	test   BYTE PTR [r14],0x20
  41b2c4:	0f 85 d9 f5 ff ff    	jne    41a8a3 <fmt_fp+0x13e3>
  41b2ca:	48 b8 33 09 fc ff ff 	movabs rax,0xfffffffffffc0933
  41b2d1:	ff ff ff 
  41b2d4:	4c 89 f2             	mov    rdx,r14
  41b2d7:	be 01 00 00 00       	mov    esi,0x1
  41b2dc:	49 8d 3c 07          	lea    rdi,[r15+rax*1]
  41b2e0:	48 b8 20 ce fb ff ff 	movabs rax,0xfffffffffffbce20
  41b2e7:	ff ff ff 
  41b2ea:	4c 01 f8             	add    rax,r15
  41b2ed:	ff d0                	call   rax
  41b2ef:	e9 5f 02 00 00       	jmp    41b553 <fmt_fp+0x2093>
  41b2f4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
			else if (s==buf+9) *--s='0';
  41b2f8:	4c 39 d6             	cmp    rsi,r10
  41b2fb:	0f 85 6a ff ff ff    	jne    41b26b <fmt_fp+0x1dab>
  41b301:	c6 44 24 78 30       	mov    BYTE PTR [rsp+0x78],0x30
  41b306:	e9 60 ff ff ff       	jmp    41b26b <fmt_fp+0x1dab>
  41b30b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  41b310:	48 39 f7             	cmp    rdi,rsi
  41b313:	0f 85 c1 fd ff ff    	jne    41b0da <fmt_fp+0x1c1a>
  41b319:	c6 44 24 78 30       	mov    BYTE PTR [rsp+0x78],0x30
  41b31e:	be 01 00 00 00       	mov    esi,0x1
  41b323:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b328:	41 f6 06 20          	test   BYTE PTR [r14],0x20
  41b32c:	0f 85 b5 fd ff ff    	jne    41b0e7 <fmt_fp+0x1c27>
  41b332:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  41b338:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  41b33d:	4c 89 f2             	mov    rdx,r14
		for (d=a; d<=r; d++) {
  41b340:	48 83 c5 04          	add    rbp,0x4
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b344:	ff d0                	call   rax
		for (d=a; d<=r; d++) {
  41b346:	48 39 6c 24 18       	cmp    QWORD PTR [rsp+0x18],rbp
  41b34b:	0f 82 29 ff ff ff    	jb     41b27a <fmt_fp+0x1dba>
			char *s = fmt_u(*d, buf+9);
  41b351:	8b 4d 00             	mov    ecx,DWORD PTR [rbp+0x0]
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  41b354:	48 85 c9             	test   rcx,rcx
  41b357:	0f 85 24 fc ff ff    	jne    41af81 <fmt_fp+0x1ac1>
			if (d!=a) while (s>buf) *--s='0';
  41b35d:	49 39 ed             	cmp    r13,rbp
  41b360:	74 b7                	je     41b319 <fmt_fp+0x1e59>
  41b362:	48 8d 74 24 79       	lea    rsi,[rsp+0x79]
  41b367:	48 8d 4c 24 70       	lea    rcx,[rsp+0x70]
  41b36c:	48 89 f7             	mov    rdi,rsi
  41b36f:	e9 67 fc ff ff       	jmp    41afdb <fmt_fp+0x1b1b>
		if (e > INT_MAX-l) return -1;
  41b374:	44 39 d7             	cmp    edi,r10d
  41b377:	0f 8f 01 fa ff ff    	jg     41ad7e <fmt_fp+0x18be>
		if (e>0) l+=e;
  41b37d:	41 8d 04 38          	lea    eax,[r8+rdi*1]
  41b381:	85 ff                	test   edi,edi
  41b383:	44 0f 4f c0          	cmovg  r8d,eax
  41b387:	e9 68 f1 ff ff       	jmp    41a4f4 <fmt_fp+0x1034>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b38c:	48 8b 74 24 38       	mov    rsi,QWORD PTR [rsp+0x38]
  41b391:	48 8b 7c 24 30       	mov    rdi,QWORD PTR [rsp+0x30]
  41b396:	4c 89 f2             	mov    rdx,r14
  41b399:	48 b8 20 ce fb ff ff 	movabs rax,0xfffffffffffbce20
  41b3a0:	ff ff ff 
  41b3a3:	4c 01 f8             	add    rax,r15
  41b3a6:	ff d0                	call   rax
  41b3a8:	e9 57 f2 ff ff       	jmp    41a604 <fmt_fp+0x1144>
			if (d!=a) while (s>buf) *--s='0';
  41b3ad:	49 39 fd             	cmp    r13,rdi
  41b3b0:	0f 85 c8 fd ff ff    	jne    41b17e <fmt_fp+0x1cbe>
  41b3b6:	e9 46 ff ff ff       	jmp    41b301 <fmt_fp+0x1e41>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b3bb:	41 83 e0 20          	and    r8d,0x20
  41b3bf:	45 89 e1             	mov    r9d,r12d
  41b3c2:	48 89 fd             	mov    rbp,rdi
  41b3c5:	e9 cd f6 ff ff       	jmp    41aa97 <fmt_fp+0x15d7>
  41b3ca:	d9 7c 24 5e          	fnstcw WORD PTR [rsp+0x5e]
		s=buf;
  41b3ce:	4c 89 e0             	mov    rax,r12
  41b3d1:	48 bf 90 0d fc ff ff 	movabs rdi,0xfffffffffffc0d90
  41b3d8:	ff ff ff 
  41b3db:	48 b9 50 0b fc ff ff 	movabs rcx,0xfffffffffffc0b50
  41b3e2:	ff ff ff 
			y=16*(y-x);
  41b3e5:	42 d9 04 3f          	fld    DWORD PTR [rdi+r15*1]
			*s++=xdigits[x]|(t&32);
  41b3e9:	4c 01 f9             	add    rcx,r15
  41b3ec:	0f b7 54 24 5e       	movzx  edx,WORD PTR [rsp+0x5e]
  41b3f1:	80 ce 0c             	or     dh,0xc
		} while (y);
  41b3f4:	d9 ee                	fldz   
  41b3f6:	d9 ca                	fxch   st(2)
  41b3f8:	66 89 54 24 5c       	mov    WORD PTR [rsp+0x5c],dx
  41b3fd:	eb 0e                	jmp    41b40d <fmt_fp+0x1f4d>
  41b3ff:	90                   	nop
			*s++=xdigits[x]|(t&32);
  41b400:	48 89 d0             	mov    rax,rdx
		} while (y);
  41b403:	db ea                	fucomi st,st(2)
  41b405:	7a 06                	jp     41b40d <fmt_fp+0x1f4d>
  41b407:	0f 84 a7 e7 ff ff    	je     419bb4 <fmt_fp+0x6f4>
			int x=y;
  41b40d:	d9 c0                	fld    st(0)
  41b40f:	d9 6c 24 5c          	fldcw  WORD PTR [rsp+0x5c]
  41b413:	db 5c 24 08          	fistp  DWORD PTR [rsp+0x8]
  41b417:	d9 6c 24 5e          	fldcw  WORD PTR [rsp+0x5e]
			y=16*(y-x);
  41b41b:	db 44 24 08          	fild   DWORD PTR [rsp+0x8]
			*s++=xdigits[x]|(t&32);
  41b41f:	48 63 54 24 08       	movsxd rdx,DWORD PTR [rsp+0x8]
  41b424:	0f b6 3c 11          	movzx  edi,BYTE PTR [rcx+rdx*1]
			if (s-buf==1 && (y||p>0||(fl&ALT_FORM))) *s++='.';
  41b428:	48 8d 50 01          	lea    rdx,[rax+0x1]
			y=16*(y-x);
  41b42c:	de e9                	fsubp  st(1),st
			*s++=xdigits[x]|(t&32);
  41b42e:	09 f7                	or     edi,esi
  41b430:	40 88 38             	mov    BYTE PTR [rax],dil
			y=16*(y-x);
  41b433:	d8 c9                	fmul   st,st(1)
			if (s-buf==1 && (y||p>0||(fl&ALT_FORM))) *s++='.';
  41b435:	4c 39 e0             	cmp    rax,r12
  41b438:	75 c6                	jne    41b400 <fmt_fp+0x1f40>
  41b43a:	c6 40 01 2e          	mov    BYTE PTR [rax+0x1],0x2e
  41b43e:	48 83 c0 02          	add    rax,0x2
  41b442:	eb bf                	jmp    41b403 <fmt_fp+0x1f43>
			if (s==buf+9) *--s='0';
  41b444:	48 89 f8             	mov    rax,rdi
  41b447:	45 31 c9             	xor    r9d,r9d
  41b44a:	e9 a4 f5 ff ff       	jmp    41a9f3 <fmt_fp+0x1533>
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41b44f:	4c 8d ac 24 90 00 00 	lea    r13,[rsp+0x90]
  41b456:	00 
  41b457:	ba 00 01 00 00       	mov    edx,0x100
  41b45c:	be 30 00 00 00       	mov    esi,0x30
  41b461:	48 b8 3c 64 fb ff ff 	movabs rax,0xfffffffffffb643c
  41b468:	ff ff ff 
  41b46b:	4c 89 ef             	mov    rdi,r13
  41b46e:	4c 01 f8             	add    rax,r15
  41b471:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  41b473:	e9 db f3 ff ff       	jmp    41a853 <fmt_fp+0x1393>
				*d = *d + i;
  41b478:	44 01 d0             	add    eax,r10d
  41b47b:	89 06                	mov    DWORD PTR [rsi],eax
				while (*d > 999999999) {
  41b47d:	3d ff c9 9a 3b       	cmp    eax,0x3b9ac9ff
  41b482:	77 2e                	ja     41b4b2 <fmt_fp+0x1ff2>
  41b484:	e9 2c 08 00 00       	jmp    41bcb5 <fmt_fp+0x27f5>
  41b489:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
					if (d<a) *--a=0;
  41b490:	c7 45 fc 00 00 00 00 	mov    DWORD PTR [rbp-0x4],0x0
					(*d)++;
  41b497:	8b 7e fc             	mov    edi,DWORD PTR [rsi-0x4]
					if (d<a) *--a=0;
  41b49a:	48 8d 55 fc          	lea    rdx,[rbp-0x4]
  41b49e:	48 89 d5             	mov    rbp,rdx
					(*d)++;
  41b4a1:	8d 4f 01             	lea    ecx,[rdi+0x1]
  41b4a4:	89 4e fc             	mov    DWORD PTR [rsi-0x4],ecx
				while (*d > 999999999) {
  41b4a7:	81 f9 ff c9 9a 3b    	cmp    ecx,0x3b9ac9ff
  41b4ad:	76 24                	jbe    41b4d3 <fmt_fp+0x2013>
			if (pl && *prefix=='-') round*=-1, small*=-1;
  41b4af:	48 89 c6             	mov    rsi,rax
					*d--=0;
  41b4b2:	48 8d 46 fc          	lea    rax,[rsi-0x4]
  41b4b6:	c7 40 04 00 00 00 00 	mov    DWORD PTR [rax+0x4],0x0
					if (d<a) *--a=0;
  41b4bd:	48 39 e8             	cmp    rax,rbp
  41b4c0:	72 ce                	jb     41b490 <fmt_fp+0x1fd0>
					(*d)++;
  41b4c2:	8b 7e fc             	mov    edi,DWORD PTR [rsi-0x4]
  41b4c5:	8d 57 01             	lea    edx,[rdi+0x1]
  41b4c8:	89 56 fc             	mov    DWORD PTR [rsi-0x4],edx
				while (*d > 999999999) {
  41b4cb:	81 fa ff c9 9a 3b    	cmp    edx,0x3b9ac9ff
  41b4d1:	77 dc                	ja     41b4af <fmt_fp+0x1fef>
				for (i=10, e=9*(r-a); *a>=i; i*=10, e++);
  41b4d3:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  41b4d8:	8b 55 00             	mov    edx,DWORD PTR [rbp+0x0]
  41b4db:	48 29 e8             	sub    rax,rbp
  41b4de:	48 c1 f8 02          	sar    rax,0x2
  41b4e2:	8d 3c c0             	lea    edi,[rax+rax*8]
  41b4e5:	83 fa 09             	cmp    edx,0x9
  41b4e8:	0f 86 f8 ee ff ff    	jbe    41a3e6 <fmt_fp+0xf26>
  41b4ee:	b8 0a 00 00 00       	mov    eax,0xa
  41b4f3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  41b4f8:	8d 04 80             	lea    eax,[rax+rax*4]
  41b4fb:	83 c7 01             	add    edi,0x1
  41b4fe:	01 c0                	add    eax,eax
  41b500:	39 d0                	cmp    eax,edx
  41b502:	76 f4                	jbe    41b4f8 <fmt_fp+0x2038>
  41b504:	e9 dd ee ff ff       	jmp    41a3e6 <fmt_fp+0xf26>
  41b509:	4d 89 ea             	mov    r10,r13
  41b50c:	e9 6d ea ff ff       	jmp    419f7e <fmt_fp+0xabe>
  41b511:	49 89 ea             	mov    r10,rbp
  41b514:	44 89 ed             	mov    ebp,r13d
  41b517:	e9 af e8 ff ff       	jmp    419dcb <fmt_fp+0x90b>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b51c:	48 b8 20 ce fb ff ff 	movabs rax,0xfffffffffffbce20
  41b523:	ff ff ff 
  41b526:	48 8b 7c 24 30       	mov    rdi,QWORD PTR [rsp+0x30]
		out(f, prefix, pl);
  41b52b:	49 63 f5             	movsxd rsi,r13d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b52e:	4c 89 f2             	mov    rdx,r14
  41b531:	4c 01 f8             	add    rax,r15
  41b534:	ff d0                	call   rax
  41b536:	e9 cd e7 ff ff       	jmp    419d08 <fmt_fp+0x848>
			t-=2;
  41b53b:	83 6c 24 20 02       	sub    DWORD PTR [rsp+0x20],0x2
			p--;
  41b540:	83 2c 24 01          	sub    DWORD PTR [rsp],0x1
  41b544:	e9 5c f9 ff ff       	jmp    41aea5 <fmt_fp+0x19e5>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b549:	41 f6 06 20          	test   BYTE PTR [r14],0x20
  41b54d:	0f 84 77 fd ff ff    	je     41b2ca <fmt_fp+0x1e0a>
		for (; d<z && p>0; d++, p-=9) {
  41b553:	8b 14 24             	mov    edx,DWORD PTR [rsp]
  41b556:	85 d2                	test   edx,edx
  41b558:	0f 8e 45 f3 ff ff    	jle    41a8a3 <fmt_fp+0x13e3>
  41b55e:	48 39 dd             	cmp    rbp,rbx
  41b561:	0f 83 1b 03 00 00    	jae    41b882 <fmt_fp+0x23c2>
  41b567:	4c 8d 5c 24 79       	lea    r11,[rsp+0x79]
  41b56c:	48 89 d9             	mov    rcx,rbx
  41b56f:	4c 8d 64 24 70       	lea    r12,[rsp+0x70]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b574:	48 b8 20 ce fb ff ff 	movabs rax,0xfffffffffffbce20
  41b57b:	ff ff ff 
			while (s>buf) *--s='0';
  41b57e:	49 bd 20 0e fc ff ff 	movabs r13,0xfffffffffffc0e20
  41b585:	ff ff ff 
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b588:	4c 01 f8             	add    rax,r15
  41b58b:	4c 89 db             	mov    rbx,r11
  41b58e:	49 b9 20 0e fc ff ff 	movabs r9,0xfffffffffffc0e20
  41b595:	ff ff ff 
  41b598:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
			char *s = fmt_u(*d, buf+9);
  41b59d:	8b 75 00             	mov    esi,DWORD PTR [rbp+0x0]
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  41b5a0:	48 89 df             	mov    rdi,rbx
  41b5a3:	48 85 f6             	test   rsi,rsi
  41b5a6:	74 45                	je     41b5ed <fmt_fp+0x212d>
  41b5a8:	49 b8 cd cc cc cc cc 	movabs r8,0xcccccccccccccccd
  41b5af:	cc cc cc 
  41b5b2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  41b5b8:	48 89 f0             	mov    rax,rsi
  41b5bb:	48 83 ef 01          	sub    rdi,0x1
  41b5bf:	49 f7 e0             	mul    r8
  41b5c2:	48 89 f0             	mov    rax,rsi
  41b5c5:	48 c1 ea 03          	shr    rdx,0x3
  41b5c9:	4c 8d 14 92          	lea    r10,[rdx+rdx*4]
  41b5cd:	4d 01 d2             	add    r10,r10
  41b5d0:	4c 29 d0             	sub    rax,r10
  41b5d3:	83 c0 30             	add    eax,0x30
  41b5d6:	88 07                	mov    BYTE PTR [rdi],al
  41b5d8:	48 89 f0             	mov    rax,rsi
  41b5db:	48 89 d6             	mov    rsi,rdx
  41b5de:	48 83 f8 09          	cmp    rax,0x9
  41b5e2:	77 d4                	ja     41b5b8 <fmt_fp+0x20f8>
			while (s>buf) *--s='0';
  41b5e4:	4c 39 e7             	cmp    rdi,r12
  41b5e7:	0f 86 f5 00 00 00    	jbe    41b6e2 <fmt_fp+0x2222>
  41b5ed:	4c 8d 47 ff          	lea    r8,[rdi-0x1]
  41b5f1:	48 89 f8             	mov    rax,rdi
  41b5f4:	ba 01 00 00 00       	mov    edx,0x1
  41b5f9:	4c 29 e0             	sub    rax,r12
  41b5fc:	4d 39 e0             	cmp    r8,r12
  41b5ff:	48 0f 43 d0          	cmovae rdx,rax
  41b603:	48 83 e8 01          	sub    rax,0x1
  41b607:	48 83 f8 0e          	cmp    rax,0xe
  41b60b:	0f 86 88 03 00 00    	jbe    41b999 <fmt_fp+0x24d9>
  41b611:	4d 39 e0             	cmp    r8,r12
  41b614:	0f 82 7f 03 00 00    	jb     41b999 <fmt_fp+0x24d9>
  41b61a:	48 89 d0             	mov    rax,rdx
  41b61d:	48 89 fe             	mov    rsi,rdi
  41b620:	66 43 0f 6f 04 39    	movdqa xmm0,XMMWORD PTR [r9+r15*1]
  41b626:	48 83 e0 f0          	and    rax,0xfffffffffffffff0
  41b62a:	48 29 c6             	sub    rsi,rax
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  41b62d:	48 89 f8             	mov    rax,rdi
			while (s>buf) *--s='0';
  41b630:	0f 11 40 f0          	movups XMMWORD PTR [rax-0x10],xmm0
  41b634:	48 83 e8 10          	sub    rax,0x10
  41b638:	48 39 f0             	cmp    rax,rsi
  41b63b:	75 f3                	jne    41b630 <fmt_fp+0x2170>
  41b63d:	48 89 d6             	mov    rsi,rdx
  41b640:	48 89 f8             	mov    rax,rdi
  41b643:	48 83 e6 f0          	and    rsi,0xfffffffffffffff0
  41b647:	48 29 f0             	sub    rax,rsi
  41b64a:	48 39 d6             	cmp    rsi,rdx
  41b64d:	74 7c                	je     41b6cb <fmt_fp+0x220b>
  41b64f:	48 29 f2             	sub    rdx,rsi
  41b652:	4c 8d 52 ff          	lea    r10,[rdx-0x1]
  41b656:	49 83 fa 06          	cmp    r10,0x6
  41b65a:	76 1d                	jbe    41b679 <fmt_fp+0x21b9>
  41b65c:	49 89 fa             	mov    r10,rdi
  41b65f:	49 29 f2             	sub    r10,rsi
  41b662:	4b 8b 34 2f          	mov    rsi,QWORD PTR [r15+r13*1]
  41b666:	49 89 72 f8          	mov    QWORD PTR [r10-0x8],rsi
  41b66a:	48 89 d6             	mov    rsi,rdx
  41b66d:	48 83 e6 f8          	and    rsi,0xfffffffffffffff8
  41b671:	48 29 f0             	sub    rax,rsi
  41b674:	48 39 f2             	cmp    rdx,rsi
  41b677:	74 52                	je     41b6cb <fmt_fp+0x220b>
  41b679:	48 8d 50 ff          	lea    rdx,[rax-0x1]
  41b67d:	c6 40 ff 30          	mov    BYTE PTR [rax-0x1],0x30
  41b681:	49 39 d4             	cmp    r12,rdx
  41b684:	73 45                	jae    41b6cb <fmt_fp+0x220b>
  41b686:	48 8d 50 fe          	lea    rdx,[rax-0x2]
  41b68a:	c6 40 fe 30          	mov    BYTE PTR [rax-0x2],0x30
  41b68e:	49 39 d4             	cmp    r12,rdx
  41b691:	73 38                	jae    41b6cb <fmt_fp+0x220b>
  41b693:	48 8d 50 fd          	lea    rdx,[rax-0x3]
  41b697:	c6 40 fd 30          	mov    BYTE PTR [rax-0x3],0x30
  41b69b:	49 39 d4             	cmp    r12,rdx
  41b69e:	73 2b                	jae    41b6cb <fmt_fp+0x220b>
  41b6a0:	48 8d 50 fc          	lea    rdx,[rax-0x4]
  41b6a4:	c6 40 fc 30          	mov    BYTE PTR [rax-0x4],0x30
  41b6a8:	49 39 d4             	cmp    r12,rdx
  41b6ab:	73 1e                	jae    41b6cb <fmt_fp+0x220b>
  41b6ad:	48 8d 50 fb          	lea    rdx,[rax-0x5]
  41b6b1:	c6 40 fb 30          	mov    BYTE PTR [rax-0x5],0x30
  41b6b5:	49 39 d4             	cmp    r12,rdx
  41b6b8:	73 11                	jae    41b6cb <fmt_fp+0x220b>
  41b6ba:	48 8d 50 fa          	lea    rdx,[rax-0x6]
  41b6be:	c6 40 fa 30          	mov    BYTE PTR [rax-0x6],0x30
  41b6c2:	49 39 d4             	cmp    r12,rdx
  41b6c5:	73 04                	jae    41b6cb <fmt_fp+0x220b>
  41b6c7:	c6 40 f9 30          	mov    BYTE PTR [rax-0x7],0x30
  41b6cb:	4c 89 e0             	mov    rax,r12
  41b6ce:	48 c7 c2 ff ff ff ff 	mov    rdx,0xffffffffffffffff
  41b6d5:	48 29 f8             	sub    rax,rdi
  41b6d8:	4d 39 e0             	cmp    r8,r12
  41b6db:	48 0f 42 c2          	cmovb  rax,rdx
  41b6df:	48 01 c7             	add    rdi,rax
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b6e2:	41 f6 06 20          	test   BYTE PTR [r14],0x20
  41b6e6:	0f 84 54 02 00 00    	je     41b940 <fmt_fp+0x2480>
		for (; d<z && p>0; d++, p-=9) {
  41b6ec:	4c 8d 45 04          	lea    r8,[rbp+0x4]
  41b6f0:	83 2c 24 09          	sub    DWORD PTR [rsp],0x9
  41b6f4:	49 89 db             	mov    r11,rbx
  41b6f7:	8b 2c 24             	mov    ebp,DWORD PTR [rsp]
  41b6fa:	48 89 cb             	mov    rbx,rcx
  41b6fd:	49 39 c8             	cmp    r8,rcx
  41b700:	0f 83 7c 01 00 00    	jae    41b882 <fmt_fp+0x23c2>
  41b706:	85 ed                	test   ebp,ebp
  41b708:	0f 8e 95 f1 ff ff    	jle    41a8a3 <fmt_fp+0x13e3>
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  41b70e:	4c 89 34 24          	mov    QWORD PTR [rsp],r14
			while (s>buf) *--s='0';
  41b712:	49 c7 c2 f8 ff ff ff 	mov    r10,0xfffffffffffffff8
  41b719:	49 b9 20 0e fc ff ff 	movabs r9,0xfffffffffffc0e20
  41b720:	ff ff ff 
  41b723:	49 bd 20 0e fc ff ff 	movabs r13,0xfffffffffffc0e20
  41b72a:	ff ff ff 
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  41b72d:	48 bf cd cc cc cc cc 	movabs rdi,0xcccccccccccccccd
  41b734:	cc cc cc 
			char *s = fmt_u(*d, buf+9);
  41b737:	41 8b 08             	mov    ecx,DWORD PTR [r8]
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  41b73a:	4c 89 de             	mov    rsi,r11
  41b73d:	48 85 c9             	test   rcx,rcx
  41b740:	74 3b                	je     41b77d <fmt_fp+0x22bd>
  41b742:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  41b748:	48 89 c8             	mov    rax,rcx
  41b74b:	48 83 ee 01          	sub    rsi,0x1
  41b74f:	48 f7 e7             	mul    rdi
  41b752:	48 89 c8             	mov    rax,rcx
  41b755:	48 c1 ea 03          	shr    rdx,0x3
  41b759:	4c 8d 34 92          	lea    r14,[rdx+rdx*4]
  41b75d:	4d 01 f6             	add    r14,r14
  41b760:	4c 29 f0             	sub    rax,r14
  41b763:	83 c0 30             	add    eax,0x30
  41b766:	88 06                	mov    BYTE PTR [rsi],al
  41b768:	48 89 c8             	mov    rax,rcx
  41b76b:	48 89 d1             	mov    rcx,rdx
  41b76e:	48 83 f8 09          	cmp    rax,0x9
  41b772:	77 d4                	ja     41b748 <fmt_fp+0x2288>
			while (s>buf) *--s='0';
  41b774:	4c 39 e6             	cmp    rsi,r12
  41b777:	0f 86 e6 00 00 00    	jbe    41b863 <fmt_fp+0x23a3>
  41b77d:	4c 8d 76 ff          	lea    r14,[rsi-0x1]
  41b781:	48 89 f1             	mov    rcx,rsi
  41b784:	ba 01 00 00 00       	mov    edx,0x1
  41b789:	48 89 f0             	mov    rax,rsi
  41b78c:	4c 29 e1             	sub    rcx,r12
  41b78f:	4d 39 e6             	cmp    r14,r12
  41b792:	48 0f 43 d1          	cmovae rdx,rcx
  41b796:	48 83 e9 01          	sub    rcx,0x1
  41b79a:	48 83 f9 0e          	cmp    rcx,0xe
  41b79e:	0f 86 eb 01 00 00    	jbe    41b98f <fmt_fp+0x24cf>
  41b7a4:	4d 39 e6             	cmp    r14,r12
  41b7a7:	0f 82 e2 01 00 00    	jb     41b98f <fmt_fp+0x24cf>
  41b7ad:	49 89 d6             	mov    r14,rdx
  41b7b0:	48 89 f1             	mov    rcx,rsi
  41b7b3:	66 43 0f 6f 44 3d 00 	movdqa xmm0,XMMWORD PTR [r13+r15*1+0x0]
  41b7ba:	49 83 e6 f0          	and    r14,0xfffffffffffffff0
  41b7be:	4c 29 f1             	sub    rcx,r14
  41b7c1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  41b7c8:	0f 11 40 f0          	movups XMMWORD PTR [rax-0x10],xmm0
  41b7cc:	48 83 e8 10          	sub    rax,0x10
  41b7d0:	48 39 c8             	cmp    rax,rcx
  41b7d3:	75 f3                	jne    41b7c8 <fmt_fp+0x2308>
  41b7d5:	48 89 d1             	mov    rcx,rdx
  41b7d8:	48 89 f0             	mov    rax,rsi
  41b7db:	48 83 e1 f0          	and    rcx,0xfffffffffffffff0
  41b7df:	48 29 c8             	sub    rax,rcx
  41b7e2:	48 39 d1             	cmp    rcx,rdx
  41b7e5:	74 7c                	je     41b863 <fmt_fp+0x23a3>
  41b7e7:	48 29 ca             	sub    rdx,rcx
  41b7ea:	4c 8d 72 ff          	lea    r14,[rdx-0x1]
  41b7ee:	49 83 fe 06          	cmp    r14,0x6
  41b7f2:	76 1d                	jbe    41b811 <fmt_fp+0x2351>
  41b7f4:	4d 89 d6             	mov    r14,r10
  41b7f7:	49 29 ce             	sub    r14,rcx
  41b7fa:	4b 8b 0c 0f          	mov    rcx,QWORD PTR [r15+r9*1]
  41b7fe:	4a 89 0c 36          	mov    QWORD PTR [rsi+r14*1],rcx
  41b802:	48 89 d1             	mov    rcx,rdx
  41b805:	48 83 e1 f8          	and    rcx,0xfffffffffffffff8
  41b809:	48 29 c8             	sub    rax,rcx
  41b80c:	48 39 d1             	cmp    rcx,rdx
  41b80f:	74 52                	je     41b863 <fmt_fp+0x23a3>
  41b811:	48 8d 50 ff          	lea    rdx,[rax-0x1]
  41b815:	c6 40 ff 30          	mov    BYTE PTR [rax-0x1],0x30
  41b819:	49 39 d4             	cmp    r12,rdx
  41b81c:	73 45                	jae    41b863 <fmt_fp+0x23a3>
  41b81e:	48 8d 50 fe          	lea    rdx,[rax-0x2]
  41b822:	c6 40 fe 30          	mov    BYTE PTR [rax-0x2],0x30
  41b826:	49 39 d4             	cmp    r12,rdx
  41b829:	73 38                	jae    41b863 <fmt_fp+0x23a3>
  41b82b:	48 8d 50 fd          	lea    rdx,[rax-0x3]
  41b82f:	c6 40 fd 30          	mov    BYTE PTR [rax-0x3],0x30
  41b833:	49 39 d4             	cmp    r12,rdx
  41b836:	73 2b                	jae    41b863 <fmt_fp+0x23a3>
  41b838:	48 8d 50 fc          	lea    rdx,[rax-0x4]
  41b83c:	c6 40 fc 30          	mov    BYTE PTR [rax-0x4],0x30
  41b840:	49 39 d4             	cmp    r12,rdx
  41b843:	73 1e                	jae    41b863 <fmt_fp+0x23a3>
  41b845:	48 8d 50 fb          	lea    rdx,[rax-0x5]
  41b849:	c6 40 fb 30          	mov    BYTE PTR [rax-0x5],0x30
  41b84d:	49 39 d4             	cmp    r12,rdx
  41b850:	73 11                	jae    41b863 <fmt_fp+0x23a3>
  41b852:	48 8d 50 fa          	lea    rdx,[rax-0x6]
  41b856:	c6 40 fa 30          	mov    BYTE PTR [rax-0x6],0x30
  41b85a:	49 39 d4             	cmp    r12,rdx
  41b85d:	73 04                	jae    41b863 <fmt_fp+0x23a3>
  41b85f:	c6 40 f9 30          	mov    BYTE PTR [rax-0x7],0x30
		for (; d<z && p>0; d++, p-=9) {
  41b863:	83 ed 09             	sub    ebp,0x9
  41b866:	49 83 c0 04          	add    r8,0x4
  41b86a:	85 ed                	test   ebp,ebp
  41b86c:	0f 8e a0 02 00 00    	jle    41bb12 <fmt_fp+0x2652>
  41b872:	4c 39 c3             	cmp    rbx,r8
  41b875:	0f 87 bc fe ff ff    	ja     41b737 <fmt_fp+0x2277>
  41b87b:	4c 8b 34 24          	mov    r14,QWORD PTR [rsp]
  41b87f:	89 2c 24             	mov    DWORD PTR [rsp],ebp
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41b882:	8b 1c 24             	mov    ebx,DWORD PTR [rsp]
  41b885:	85 db                	test   ebx,ebx
  41b887:	0f 8e 16 f0 ff ff    	jle    41a8a3 <fmt_fp+0x13e3>
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41b88d:	81 fb 00 01 00 00    	cmp    ebx,0x100
  41b893:	0f 8f 82 02 00 00    	jg     41bb1b <fmt_fp+0x265b>
  41b899:	48 63 eb             	movsxd rbp,ebx
  41b89c:	4c 8d ac 24 90 00 00 	lea    r13,[rsp+0x90]
  41b8a3:	00 
  41b8a4:	be 30 00 00 00       	mov    esi,0x30
  41b8a9:	48 b8 3c 64 fb ff ff 	movabs rax,0xfffffffffffb643c
  41b8b0:	ff ff ff 
  41b8b3:	4c 01 f8             	add    rax,r15
  41b8b6:	48 89 ea             	mov    rdx,rbp
  41b8b9:	4c 89 ef             	mov    rdi,r13
  41b8bc:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  41b8be:	81 fb 00 01 00 00    	cmp    ebx,0x100
  41b8c4:	0f 85 f4 03 00 00    	jne    41bcbe <fmt_fp+0x27fe>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b8ca:	48 bd 20 ce fb ff ff 	movabs rbp,0xfffffffffffbce20
  41b8d1:	ff ff ff 
  41b8d4:	8b 1c 24             	mov    ebx,DWORD PTR [rsp]
  41b8d7:	41 8b 16             	mov    edx,DWORD PTR [r14]
  41b8da:	81 eb 00 01 00 00    	sub    ebx,0x100
  41b8e0:	41 89 dc             	mov    r12d,ebx
  41b8e3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  41b8e8:	89 d0                	mov    eax,edx
  41b8ea:	83 e0 20             	and    eax,0x20
  41b8ed:	0f 84 ed 01 00 00    	je     41bae0 <fmt_fp+0x2620>
	for (; l >= sizeof pad; l -= sizeof pad)
  41b8f3:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  41b8fa:	76 14                	jbe    41b910 <fmt_fp+0x2450>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b8fc:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  41b8fe:	41 81 ec 00 01 00 00 	sub    r12d,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b905:	89 d0                	mov    eax,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  41b907:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  41b90e:	77 ee                	ja     41b8fe <fmt_fp+0x243e>
	out(f, pad, l);
  41b910:	0f b6 eb             	movzx  ebp,bl
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b913:	85 c0                	test   eax,eax
  41b915:	0f 85 88 ef ff ff    	jne    41a8a3 <fmt_fp+0x13e3>
  41b91b:	48 b8 20 ce fb ff ff 	movabs rax,0xfffffffffffbce20
  41b922:	ff ff ff 
  41b925:	4c 89 f2             	mov    rdx,r14
  41b928:	48 89 ee             	mov    rsi,rbp
  41b92b:	4c 89 ef             	mov    rdi,r13
  41b92e:	4c 01 f8             	add    rax,r15
  41b931:	ff d0                	call   rax
  41b933:	e9 6b ef ff ff       	jmp    41a8a3 <fmt_fp+0x13e3>
  41b938:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41b93f:	00 
  41b940:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
			out(f, s, MIN(9,p));
  41b945:	8b 0c 24             	mov    ecx,DWORD PTR [rsp]
  41b948:	b8 09 00 00 00       	mov    eax,0x9
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b94d:	4c 89 f2             	mov    rdx,r14
  41b950:	4c 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],r9
			out(f, s, MIN(9,p));
  41b955:	39 c1                	cmp    ecx,eax
  41b957:	0f 4e c1             	cmovle eax,ecx
		for (; d<z && p>0; d++, p-=9) {
  41b95a:	48 83 c5 04          	add    rbp,0x4
			out(f, s, MIN(9,p));
  41b95e:	48 63 f0             	movsxd rsi,eax
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b961:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  41b966:	ff d0                	call   rax
		for (; d<z && p>0; d++, p-=9) {
  41b968:	83 2c 24 09          	sub    DWORD PTR [rsp],0x9
  41b96c:	8b 0c 24             	mov    ecx,DWORD PTR [rsp]
  41b96f:	85 c9                	test   ecx,ecx
  41b971:	0f 8e 2c ef ff ff    	jle    41a8a3 <fmt_fp+0x13e3>
  41b977:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  41b97c:	4c 8b 4c 24 08       	mov    r9,QWORD PTR [rsp+0x8]
  41b981:	48 39 cd             	cmp    rbp,rcx
  41b984:	0f 82 13 fc ff ff    	jb     41b59d <fmt_fp+0x20dd>
  41b98a:	e9 f3 fe ff ff       	jmp    41b882 <fmt_fp+0x23c2>
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  41b98f:	48 89 f0             	mov    rax,rsi
  41b992:	31 c9                	xor    ecx,ecx
  41b994:	e9 4e fe ff ff       	jmp    41b7e7 <fmt_fp+0x2327>
  41b999:	48 89 f8             	mov    rax,rdi
  41b99c:	31 f6                	xor    esi,esi
  41b99e:	e9 ac fc ff ff       	jmp    41b64f <fmt_fp+0x218f>
		if (estr==ebuf) *--estr='0';
  41b9a3:	c6 44 24 6f 30       	mov    BYTE PTR [rsp+0x6f],0x30
  41b9a8:	48 8d 74 24 6f       	lea    rsi,[rsp+0x6f]
  41b9ad:	e9 2b e1 ff ff       	jmp    419add <fmt_fp+0x61d>
  41b9b2:	49 89 da             	mov    r10,rbx
  41b9b5:	89 eb                	mov    ebx,ebp
  41b9b7:	8b 2c 24             	mov    ebp,DWORD PTR [rsp]
  41b9ba:	e9 66 e7 ff ff       	jmp    41a125 <fmt_fp+0xc65>
			if (d!=a) while (s>buf) *--s='0';
  41b9bf:	48 89 f8             	mov    rax,rdi
  41b9c2:	45 31 c0             	xor    r8d,r8d
  41b9c5:	e9 7d f6 ff ff       	jmp    41b047 <fmt_fp+0x1b87>
  41b9ca:	48 89 f0             	mov    rax,rsi
  41b9cd:	31 c9                	xor    ecx,ecx
  41b9cf:	e9 1b f8 ff ff       	jmp    41b1ef <fmt_fp+0x1d2f>
  41b9d4:	4d 89 ea             	mov    r10,r13
  41b9d7:	45 89 e5             	mov    r13d,r12d
  41b9da:	e9 2e e8 ff ff       	jmp    41a20d <fmt_fp+0xd4d>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b9df:	48 b8 20 ce fb ff ff 	movabs rax,0xfffffffffffbce20
  41b9e6:	ff ff ff 
	out(f, pad, l);
  41b9e9:	49 63 f4             	movsxd rsi,r12d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b9ec:	4c 89 f2             	mov    rdx,r14
  41b9ef:	4c 89 ef             	mov    rdi,r13
  41b9f2:	4c 01 f8             	add    rax,r15
  41b9f5:	ff d0                	call   rax
  41b9f7:	e9 5d ef ff ff       	jmp    41a959 <fmt_fp+0x1499>
			if ((*d/i & 1) || (i==1000000000 && d>a && (d[-1]&1)))
  41b9fc:	81 f9 00 ca 9a 3b    	cmp    ecx,0x3b9aca00
  41ba02:	75 0f                	jne    41ba13 <fmt_fp+0x2553>
  41ba04:	48 39 ee             	cmp    rsi,rbp
  41ba07:	76 0a                	jbe    41ba13 <fmt_fp+0x2553>
  41ba09:	f6 46 fc 01          	test   BYTE PTR [rsi-0x4],0x1
  41ba0d:	0f 85 56 e9 ff ff    	jne    41a369 <fmt_fp+0xea9>
			long double round = 2/LDBL_EPSILON;
  41ba13:	48 b8 7c 0d fc ff ff 	movabs rax,0xfffffffffffc0d7c
  41ba1a:	ff ff ff 
  41ba1d:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  41ba21:	e9 51 e9 ff ff       	jmp    41a377 <fmt_fp+0xeb7>
			l = (p+2) + (ebuf-estr);
  41ba26:	83 c7 02             	add    edi,0x2
  41ba29:	89 f0                	mov    eax,esi
  41ba2b:	89 fa                	mov    edx,edi
  41ba2d:	01 f8                	add    eax,edi
		pad(f, '0', l-(ebuf-estr)-(s-buf), 0, 0);
  41ba2f:	29 da                	sub    edx,ebx
  41ba31:	89 54 24 38          	mov    DWORD PTR [rsp+0x38],edx
  41ba35:	89 54 24 08          	mov    DWORD PTR [rsp+0x8],edx
			l = (p+2) + (ebuf-estr);
  41ba39:	e9 d7 e1 ff ff       	jmp    419c15 <fmt_fp+0x755>
			if ((*d/i & 1) || (i==1000000000 && d>a && (d[-1]&1)))
  41ba3e:	48 b8 80 0d fc ff ff 	movabs rax,0xfffffffffffc0d80
  41ba45:	ff ff ff 
  41ba48:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
				round += 2;
  41ba4c:	48 b8 e0 0d fc ff ff 	movabs rax,0xfffffffffffc0de0
  41ba53:	ff ff ff 
  41ba56:	41 db 2c 07          	fld    TBYTE PTR [r15+rax*1]
			if (x<i/2) small=0x0.8p0;
  41ba5a:	48 b8 84 0d fc ff ff 	movabs rax,0xfffffffffffc0d84
  41ba61:	ff ff ff 
  41ba64:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  41ba68:	d9 c9                	fxch   st(1)
  41ba6a:	d9 ca                	fxch   st(2)
  41ba6c:	d9 c9                	fxch   st(1)
  41ba6e:	e9 31 e9 ff ff       	jmp    41a3a4 <fmt_fp+0xee4>
				p = MIN(p,MAX(0,9*(z-r-1)-j));
  41ba73:	48 29 f2             	sub    rdx,rsi
  41ba76:	b8 00 00 00 00       	mov    eax,0x0
  41ba7b:	48 0f 48 d0          	cmovs  rdx,rax
  41ba7f:	48 39 ca             	cmp    rdx,rcx
  41ba82:	48 0f 4e ca          	cmovle rcx,rdx
  41ba86:	48 89 0c 24          	mov    QWORD PTR [rsp],rcx
  41ba8a:	e9 85 e9 ff ff       	jmp    41a414 <fmt_fp+0xf54>
		for (i=10, j++; j<9; i*=10, j++);
  41ba8f:	48 b8 a0 0d fc ff ff 	movabs rax,0xfffffffffffc0da0
  41ba96:	ff ff ff 
  41ba99:	f3 41 0f 7e 04 07    	movq   xmm0,QWORD PTR [r15+rax*1]
  41ba9f:	66 0f 7e c2          	movd   edx,xmm0
  41baa3:	66 0f 70 e0 e5       	pshufd xmm4,xmm0,0xe5
  41baa8:	66 0f 7e e0          	movd   eax,xmm4
  41baac:	0f af d0             	imul   edx,eax
  41baaf:	8d 0c 92             	lea    ecx,[rdx+rdx*4]
  41bab2:	01 c9                	add    ecx,ecx
  41bab4:	41 83 e0 01          	and    r8d,0x1
  41bab8:	0f 84 22 de ff ff    	je     4198e0 <fmt_fp+0x420>
  41babe:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  41bac1:	01 c9                	add    ecx,ecx
  41bac3:	e9 18 de ff ff       	jmp    4198e0 <fmt_fp+0x420>
			while (re--) round*=16;
  41bac8:	48 b8 58 0d fc ff ff 	movabs rax,0xfffffffffffc0d58
  41bacf:	ff ff ff 
  41bad2:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  41bad6:	e9 91 df ff ff       	jmp    419a6c <fmt_fp+0x5ac>
  41badb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41bae0:	4c 89 f2             	mov    rdx,r14
  41bae3:	be 00 01 00 00       	mov    esi,0x100
  41bae8:	49 8d 04 2f          	lea    rax,[r15+rbp*1]
  41baec:	4c 89 ef             	mov    rdi,r13
  41baef:	ff d0                	call   rax
  41baf1:	41 8b 16             	mov    edx,DWORD PTR [r14]
  41baf4:	89 d0                	mov    eax,edx
  41baf6:	83 e0 20             	and    eax,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41baf9:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  41bb00:	0f 86 0a fe ff ff    	jbe    41b910 <fmt_fp+0x2450>
  41bb06:	41 81 ec 00 01 00 00 	sub    r12d,0x100
  41bb0d:	e9 d6 fd ff ff       	jmp    41b8e8 <fmt_fp+0x2428>
  41bb12:	4c 8b 34 24          	mov    r14,QWORD PTR [rsp]
  41bb16:	e9 88 ed ff ff       	jmp    41a8a3 <fmt_fp+0x13e3>
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41bb1b:	4c 8d ac 24 90 00 00 	lea    r13,[rsp+0x90]
  41bb22:	00 
  41bb23:	ba 00 01 00 00       	mov    edx,0x100
  41bb28:	be 30 00 00 00       	mov    esi,0x30
  41bb2d:	48 b8 3c 64 fb ff ff 	movabs rax,0xfffffffffffb643c
  41bb34:	ff ff ff 
  41bb37:	4c 89 ef             	mov    rdi,r13
  41bb3a:	4c 01 f8             	add    rax,r15
  41bb3d:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  41bb3f:	e9 86 fd ff ff       	jmp    41b8ca <fmt_fp+0x240a>
  41bb44:	d9 c9                	fxch   st(1)
				y=-y;
  41bb46:	d9 e0                	fchs   
				y-=round;
  41bb48:	d8 e1                	fsub   st,st(1)
				y+=round;
  41bb4a:	de c1                	faddp  st(1),st
				y=-y;
  41bb4c:	d9 e0                	fchs   
  41bb4e:	e9 2b df ff ff       	jmp    419a7e <fmt_fp+0x5be>
  41bb53:	48 b8 80 0d fc ff ff 	movabs rax,0xfffffffffffc0d80
  41bb5a:	ff ff ff 
  41bb5d:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
			if (x<i/2) small=0x0.8p0;
  41bb61:	48 b8 84 0d fc ff ff 	movabs rax,0xfffffffffffc0d84
  41bb68:	ff ff ff 
  41bb6b:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  41bb6f:	e9 30 e8 ff ff       	jmp    41a3a4 <fmt_fp+0xee4>
  41bb74:	48 89 de             	mov    rsi,rbx
  41bb77:	e9 6a e8 ff ff       	jmp    41a3e6 <fmt_fp+0xf26>
			else if (x==i/2 && d+1==z) small=0x1.0p0;
  41bb7c:	48 8d 46 04          	lea    rax,[rsi+0x4]
  41bb80:	48 39 c3             	cmp    rbx,rax
  41bb83:	0f 85 ff e7 ff ff    	jne    41a388 <fmt_fp+0xec8>
  41bb89:	d9 e8                	fld1   
  41bb8b:	d9 e0                	fchs   
  41bb8d:	d9 e8                	fld1   
  41bb8f:	e9 10 e8 ff ff       	jmp    41a3a4 <fmt_fp+0xee4>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41bb94:	48 b8 20 ce fb ff ff 	movabs rax,0xfffffffffffbce20
  41bb9b:	ff ff ff 
	out(f, pad, l);
  41bb9e:	49 63 f4             	movsxd rsi,r12d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41bba1:	4c 89 f2             	mov    rdx,r14
  41bba4:	4c 89 d7             	mov    rdi,r10
  41bba7:	4c 01 f8             	add    rax,r15
  41bbaa:	ff d0                	call   rax
  41bbac:	e9 d5 e3 ff ff       	jmp    419f86 <fmt_fp+0xac6>
		for (i=10, j++; j<9; i*=10, j++);
  41bbb1:	48 b8 a8 0d fc ff ff 	movabs rax,0xfffffffffffc0da8
  41bbb8:	ff ff ff 
  41bbbb:	f3 41 0f 7e 04 07    	movq   xmm0,QWORD PTR [r15+rax*1]
  41bbc1:	e9 d9 fe ff ff       	jmp    41ba9f <fmt_fp+0x25df>
  41bbc6:	dd d8                	fstp   st(0)
  41bbc8:	dd d8                	fstp   st(0)
  41bbca:	dd d8                	fstp   st(0)
		} while (y);
  41bbcc:	48 89 d0             	mov    rax,rdx
  41bbcf:	e9 e6 df ff ff       	jmp    419bba <fmt_fp+0x6fa>
		for (i=10, j++; j<9; i*=10, j++);
  41bbd4:	48 b8 b0 0d fc ff ff 	movabs rax,0xfffffffffffc0db0
  41bbdb:	ff ff ff 
  41bbde:	f3 41 0f 7e 04 07    	movq   xmm0,QWORD PTR [r15+rax*1]
  41bbe4:	e9 b6 fe ff ff       	jmp    41ba9f <fmt_fp+0x25df>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41bbe9:	41 8b 16             	mov    edx,DWORD PTR [r14]
  41bbec:	83 e2 20             	and    edx,0x20
  41bbef:	e9 19 e6 ff ff       	jmp    41a20d <fmt_fp+0xd4d>
  41bbf4:	41 8b 36             	mov    esi,DWORD PTR [r14]
  41bbf7:	83 e6 20             	and    esi,0x20
  41bbfa:	e9 26 e5 ff ff       	jmp    41a125 <fmt_fp+0xc65>
		for (i=10, j++; j<9; i*=10, j++);
  41bbff:	41 ba 0a 00 00 00    	mov    r10d,0xa
  41bc05:	b9 0a 00 00 00       	mov    ecx,0xa
  41bc0a:	e9 d4 dc ff ff       	jmp    4198e3 <fmt_fp+0x423>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41bc0f:	41 8b 16             	mov    edx,DWORD PTR [r14]
  41bc12:	83 e2 20             	and    edx,0x20
  41bc15:	e9 37 ed ff ff       	jmp    41a951 <fmt_fp+0x1491>
  41bc1a:	41 8b 06             	mov    eax,DWORD PTR [r14]
  41bc1d:	83 e0 20             	and    eax,0x20
  41bc20:	e9 76 ec ff ff       	jmp    41a89b <fmt_fp+0x13db>
  41bc25:	83 e0 20             	and    eax,0x20
  41bc28:	89 c2                	mov    edx,eax
  41bc2a:	e9 98 ea ff ff       	jmp    41a6c7 <fmt_fp+0x1207>
		for (i=10, j++; j<9; i*=10, j++);
  41bc2f:	b9 0a 00 00 00       	mov    ecx,0xa
  41bc34:	e9 85 fe ff ff       	jmp    41babe <fmt_fp+0x25fe>
  41bc39:	48 b8 b8 0d fc ff ff 	movabs rax,0xfffffffffffc0db8
  41bc40:	ff ff ff 
  41bc43:	f3 41 0f 7e 04 07    	movq   xmm0,QWORD PTR [r15+rax*1]
  41bc49:	e9 51 fe ff ff       	jmp    41ba9f <fmt_fp+0x25df>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41bc4e:	83 e0 20             	and    eax,0x20
  41bc51:	89 c6                	mov    esi,eax
  41bc53:	e9 80 e9 ff ff       	jmp    41a5d8 <fmt_fp+0x1118>
		for (i=10, j++; j<9; i*=10, j++);
  41bc58:	48 b8 c0 0d fc ff ff 	movabs rax,0xfffffffffffc0dc0
  41bc5f:	ff ff ff 
  41bc62:	f3 41 0f 7e 04 07    	movq   xmm0,QWORD PTR [r15+rax*1]
  41bc68:	e9 32 fe ff ff       	jmp    41ba9f <fmt_fp+0x25df>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41bc6d:	41 8b 0e             	mov    ecx,DWORD PTR [r14]
  41bc70:	83 e1 20             	and    ecx,0x20
  41bc73:	e9 07 e2 ff ff       	jmp    419e7f <fmt_fp+0x9bf>
		for (i=10, j++; j<9; i*=10, j++);
  41bc78:	48 b8 d0 0d fc ff ff 	movabs rax,0xfffffffffffc0dd0
  41bc7f:	ff ff ff 
  41bc82:	f3 41 0f 7e 04 07    	movq   xmm0,QWORD PTR [r15+rax*1]
  41bc88:	e9 12 fe ff ff       	jmp    41ba9f <fmt_fp+0x25df>
  41bc8d:	48 b8 c8 0d fc ff ff 	movabs rax,0xfffffffffffc0dc8
  41bc94:	ff ff ff 
  41bc97:	f3 41 0f 7e 04 07    	movq   xmm0,QWORD PTR [r15+rax*1]
  41bc9d:	e9 fd fd ff ff       	jmp    41ba9f <fmt_fp+0x25df>
			while (re--) round*=16;
  41bca2:	48 b8 44 0d fc ff ff 	movabs rax,0xfffffffffffc0d44
  41bca9:	ff ff ff 
  41bcac:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  41bcb0:	e9 b7 dd ff ff       	jmp    419a6c <fmt_fp+0x5ac>
		if (x || d+1!=z) {
  41bcb5:	48 83 c6 04          	add    rsi,0x4
  41bcb9:	e9 15 f8 ff ff       	jmp    41b4d3 <fmt_fp+0x2013>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41bcbe:	41 8b 06             	mov    eax,DWORD PTR [r14]
  41bcc1:	83 e0 20             	and    eax,0x20
  41bcc4:	e9 4a fc ff ff       	jmp    41b913 <fmt_fp+0x2453>
  41bcc9:	41 8b 16             	mov    edx,DWORD PTR [r14]
  41bccc:	83 e2 20             	and    edx,0x20
  41bccf:	e9 aa e2 ff ff       	jmp    419f7e <fmt_fp+0xabe>
  41bcd4:	41 8b 0e             	mov    ecx,DWORD PTR [r14]
  41bcd7:	83 e1 20             	and    ecx,0x20
  41bcda:	e9 ec e0 ff ff       	jmp    419dcb <fmt_fp+0x90b>
			while (re--) round*=16;
  41bcdf:	48 b8 50 0d fc ff ff 	movabs rax,0xfffffffffffc0d50
  41bce6:	ff ff ff 
  41bce9:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  41bced:	e9 7a dd ff ff       	jmp    419a6c <fmt_fp+0x5ac>
  41bcf2:	48 b8 4c 0d fc ff ff 	movabs rax,0xfffffffffffc0d4c
  41bcf9:	ff ff ff 
  41bcfc:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  41bd00:	e9 67 dd ff ff       	jmp    419a6c <fmt_fp+0x5ac>
  41bd05:	48 b8 48 0d fc ff ff 	movabs rax,0xfffffffffffc0d48
  41bd0c:	ff ff ff 
  41bd0f:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  41bd13:	e9 54 dd ff ff       	jmp    419a6c <fmt_fp+0x5ac>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41bd18:	41 8b 36             	mov    esi,DWORD PTR [r14]
  41bd1b:	83 e6 20             	and    esi,0x20
  41bd1e:	e9 bb df ff ff       	jmp    419cde <fmt_fp+0x81e>
			while (re--) round*=16;
  41bd23:	48 b8 54 0d fc ff ff 	movabs rax,0xfffffffffffc0d54
  41bd2a:	ff ff ff 
  41bd2d:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  41bd31:	e9 36 dd ff ff       	jmp    419a6c <fmt_fp+0x5ac>
  41bd36:	48 b8 60 0d fc ff ff 	movabs rax,0xfffffffffffc0d60
  41bd3d:	ff ff ff 
  41bd40:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  41bd44:	e9 23 dd ff ff       	jmp    419a6c <fmt_fp+0x5ac>
  41bd49:	48 b8 5c 0d fc ff ff 	movabs rax,0xfffffffffffc0d5c
  41bd50:	ff ff ff 
  41bd53:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  41bd57:	e9 10 dd ff ff       	jmp    419a6c <fmt_fp+0x5ac>
  41bd5c:	48 b8 68 0d fc ff ff 	movabs rax,0xfffffffffffc0d68
  41bd63:	ff ff ff 
  41bd66:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  41bd6a:	e9 fd dc ff ff       	jmp    419a6c <fmt_fp+0x5ac>
  41bd6f:	48 b8 64 0d fc ff ff 	movabs rax,0xfffffffffffc0d64
  41bd76:	ff ff ff 
  41bd79:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  41bd7d:	e9 ea dc ff ff       	jmp    419a6c <fmt_fp+0x5ac>
  41bd82:	48 b8 78 0d fc ff ff 	movabs rax,0xfffffffffffc0d78
  41bd89:	ff ff ff 
  41bd8c:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  41bd90:	e9 d7 dc ff ff       	jmp    419a6c <fmt_fp+0x5ac>
  41bd95:	48 b8 74 0d fc ff ff 	movabs rax,0xfffffffffffc0d74
  41bd9c:	ff ff ff 
  41bd9f:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  41bda3:	e9 c4 dc ff ff       	jmp    419a6c <fmt_fp+0x5ac>
  41bda8:	48 b8 70 0d fc ff ff 	movabs rax,0xfffffffffffc0d70
  41bdaf:	ff ff ff 
  41bdb2:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  41bdb6:	e9 b1 dc ff ff       	jmp    419a6c <fmt_fp+0x5ac>
  41bdbb:	48 b8 6c 0d fc ff ff 	movabs rax,0xfffffffffffc0d6c
  41bdc2:	ff ff ff 
  41bdc5:	42 d9 04 38          	fld    DWORD PTR [rax+r15*1]
  41bdc9:	e9 9e dc ff ff       	jmp    419a6c <fmt_fp+0x5ac>
			if (z>a && z[-1]) for (i=10, j=0; z[-1]%i==0; i*=10, j++);
  41bdce:	31 f6                	xor    esi,esi
  41bdd0:	e9 1f f1 ff ff       	jmp    41aef4 <fmt_fp+0x1a34>
  41bdd5:	49 89 ea             	mov    r10,rbp
  41bdd8:	89 dd                	mov    ebp,ebx
  41bdda:	e9 ff de ff ff       	jmp    419cde <fmt_fp+0x81e>
  41bddf:	89 5c 24 08          	mov    DWORD PTR [rsp+0x8],ebx
  41bde3:	4d 89 e2             	mov    r10,r12
  41bde6:	e9 94 e0 ff ff       	jmp    419e7f <fmt_fp+0x9bf>

000000000041bdeb <printf_core.cold>:
  41bdeb:	45 8d 9f 00 ff ff ff 	lea    r11d,[r15-0x100]
  41bdf2:	4c 8b 54 24 18       	mov    r10,QWORD PTR [rsp+0x18]
	for (; l >= sizeof pad; l -= sizeof pad)
  41bdf7:	31 c9                	xor    ecx,ecx
  41bdf9:	66 41 0f 6e ff       	movd   xmm7,r15d
  41bdfe:	44 89 da             	mov    edx,r11d
  41be01:	66 0f 70 cf 00       	pshufd xmm1,xmm7,0x0
  41be06:	48 be 00 0e fc ff ff 	movabs rsi,0xfffffffffffc0e00
  41be0d:	ff ff ff 
  41be10:	c1 ea 08             	shr    edx,0x8
  41be13:	66 42 0f 6f 1c 16    	movdqa xmm3,XMMWORD PTR [rsi+r10*1]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41be19:	89 c6                	mov    esi,eax
  41be1b:	44 8d 4a 01          	lea    r9d,[rdx+0x1]
  41be1f:	48 ba f0 0d fc ff ff 	movabs rdx,0xfffffffffffc0df0
  41be26:	ff ff ff 
  41be29:	66 42 0f fe 0c 12    	paddd  xmm1,XMMWORD PTR [rdx+r10*1]
  41be2f:	44 89 cf             	mov    edi,r9d
  41be32:	48 ba 10 0e fc ff ff 	movabs rdx,0xfffffffffffc0e10
  41be39:	ff ff ff 
	for (; l >= sizeof pad; l -= sizeof pad)
  41be3c:	66 42 0f 6f 14 12    	movdqa xmm2,XMMWORD PTR [rdx+r10*1]
  41be42:	c1 ef 02             	shr    edi,0x2
  41be45:	66 0f 6f c1          	movdqa xmm0,xmm1
  41be49:	83 c1 01             	add    ecx,0x1
  41be4c:	66 0f fe cb          	paddd  xmm1,xmm3
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41be50:	89 f0                	mov    eax,esi
	for (; l >= sizeof pad; l -= sizeof pad)
  41be52:	66 0f fe c2          	paddd  xmm0,xmm2
  41be56:	39 f9                	cmp    ecx,edi
  41be58:	72 eb                	jb     41be45 <printf_core.cold+0x5a>
  41be5a:	44 89 ce             	mov    esi,r9d
  41be5d:	66 0f 70 c0 ff       	pshufd xmm0,xmm0,0xff
  41be62:	83 e6 fc             	and    esi,0xfffffffc
  41be65:	66 0f 7e c1          	movd   ecx,xmm0
  41be69:	69 d6 00 ff ff ff    	imul   edx,esi,0xffffff00
  41be6f:	44 39 ce             	cmp    esi,r9d
  41be72:	0f 84 77 0b 00 00    	je     41c9ef <printf_core+0x77f>
  41be78:	44 01 da             	add    edx,r11d
  41be7b:	89 d1                	mov    ecx,edx
  41be7d:	81 fa ff 00 00 00    	cmp    edx,0xff
  41be83:	0f 86 66 0b 00 00    	jbe    41c9ef <printf_core+0x77f>
  41be89:	81 e9 00 01 00 00    	sub    ecx,0x100
  41be8f:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  41be95:	0f 86 54 0b 00 00    	jbe    41c9ef <printf_core+0x77f>
  41be9b:	8d 8a 00 fe ff ff    	lea    ecx,[rdx-0x200]
  41bea1:	e9 49 0b 00 00       	jmp    41c9ef <printf_core+0x77f>
  41bea6:	41 8d 94 24 00 e8 ff 	lea    edx,[r12-0x1800]
  41bead:	ff 
  41beae:	81 fa 00 e9 ff 7f    	cmp    edx,0x7fffe900
  41beb4:	0f 87 b5 00 00 00    	ja     41bf6f <printf_core.cold+0x184>
  41beba:	45 8d 84 24 00 fe ff 	lea    r8d,[r12-0x200]
  41bec1:	ff 
  41bec2:	4c 8b 54 24 18       	mov    r10,QWORD PTR [rsp+0x18]
  41bec7:	66 41 0f 6e f4       	movd   xmm6,r12d
  41becc:	31 ed                	xor    ebp,ebp
  41bece:	44 89 c1             	mov    ecx,r8d
  41bed1:	66 0f 70 ce 00       	pshufd xmm1,xmm6,0x0
  41bed6:	48 ba 30 0e fc ff ff 	movabs rdx,0xfffffffffffc0e30
  41bedd:	ff ff ff 
  41bee0:	48 be 00 0e fc ff ff 	movabs rsi,0xfffffffffffc0e00
  41bee7:	ff ff ff 
  41beea:	c1 e9 08             	shr    ecx,0x8
  41beed:	66 42 0f fe 0c 12    	paddd  xmm1,XMMWORD PTR [rdx+r10*1]
  41bef3:	66 42 0f 6f 1c 16    	movdqa xmm3,XMMWORD PTR [rsi+r10*1]
  41bef9:	48 ba 10 0e fc ff ff 	movabs rdx,0xfffffffffffc0e10
  41bf00:	ff ff ff 
  41bf03:	83 c1 01             	add    ecx,0x1
  41bf06:	66 42 0f 6f 14 12    	movdqa xmm2,XMMWORD PTR [rdx+r10*1]
  41bf0c:	89 cf                	mov    edi,ecx
  41bf0e:	c1 ef 02             	shr    edi,0x2
  41bf11:	66 0f 6f c1          	movdqa xmm0,xmm1
  41bf15:	83 c5 01             	add    ebp,0x1
  41bf18:	66 0f fe cb          	paddd  xmm1,xmm3
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41bf1c:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  41bf1e:	66 0f fe c2          	paddd  xmm0,xmm2
  41bf22:	39 ef                	cmp    edi,ebp
  41bf24:	77 eb                	ja     41bf11 <printf_core.cold+0x126>
  41bf26:	89 ce                	mov    esi,ecx
  41bf28:	66 0f 70 c0 ff       	pshufd xmm0,xmm0,0xff
  41bf2d:	83 e6 fc             	and    esi,0xfffffffc
  41bf30:	66 0f 7e c5          	movd   ebp,xmm0
  41bf34:	69 c6 00 ff ff ff    	imul   eax,esi,0xffffff00
  41bf3a:	39 ce                	cmp    esi,ecx
  41bf3c:	0f 84 b2 16 00 00    	je     41d5f4 <printf_core+0x1384>
  41bf42:	44 01 c0             	add    eax,r8d
  41bf45:	89 c5                	mov    ebp,eax
  41bf47:	3d ff 00 00 00       	cmp    eax,0xff
  41bf4c:	0f 86 a2 16 00 00    	jbe    41d5f4 <printf_core+0x1384>
  41bf52:	81 ed 00 01 00 00    	sub    ebp,0x100
  41bf58:	81 fd ff 00 00 00    	cmp    ebp,0xff
  41bf5e:	0f 86 90 16 00 00    	jbe    41d5f4 <printf_core+0x1384>
  41bf64:	8d a8 00 fe ff ff    	lea    ebp,[rax-0x200]
  41bf6a:	e9 85 16 00 00       	jmp    41d5f4 <printf_core+0x1384>
  41bf6f:	81 e9 00 01 00 00    	sub    ecx,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41bf75:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  41bf77:	89 cd                	mov    ebp,ecx
  41bf79:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  41bf7f:	77 ee                	ja     41bf6f <printf_core.cold+0x184>
  41bf81:	e9 6e 16 00 00       	jmp    41d5f4 <printf_core+0x1384>
  41bf86:	41 8d b8 00 ff ff ff 	lea    edi,[r8-0x100]
  41bf8d:	4c 8b 54 24 18       	mov    r10,QWORD PTR [rsp+0x18]
  41bf92:	66 41 0f 6e e8       	movd   xmm5,r8d
  41bf97:	48 be 00 0e fc ff ff 	movabs rsi,0xfffffffffffc0e00
  41bf9e:	ff ff ff 
  41bfa1:	89 fa                	mov    edx,edi
  41bfa3:	66 0f 70 cd 00       	pshufd xmm1,xmm5,0x0
  41bfa8:	45 31 c0             	xor    r8d,r8d
  41bfab:	c1 ea 08             	shr    edx,0x8
  41bfae:	66 42 0f 6f 1c 16    	movdqa xmm3,XMMWORD PTR [rsi+r10*1]
  41bfb4:	44 8d 7a 01          	lea    r15d,[rdx+0x1]
  41bfb8:	48 ba f0 0d fc ff ff 	movabs rdx,0xfffffffffffc0df0
  41bfbf:	ff ff ff 
  41bfc2:	66 42 0f fe 0c 12    	paddd  xmm1,XMMWORD PTR [rdx+r10*1]
  41bfc8:	44 89 f9             	mov    ecx,r15d
  41bfcb:	48 ba 10 0e fc ff ff 	movabs rdx,0xfffffffffffc0e10
  41bfd2:	ff ff ff 
  41bfd5:	66 42 0f 6f 14 12    	movdqa xmm2,XMMWORD PTR [rdx+r10*1]
  41bfdb:	c1 e9 02             	shr    ecx,0x2
  41bfde:	66 0f 6f c1          	movdqa xmm0,xmm1
  41bfe2:	41 83 c0 01          	add    r8d,0x1
  41bfe6:	66 0f fe cb          	paddd  xmm1,xmm3
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41bfea:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  41bfec:	66 0f fe c2          	paddd  xmm0,xmm2
  41bff0:	44 39 c1             	cmp    ecx,r8d
  41bff3:	77 e9                	ja     41bfde <printf_core.cold+0x1f3>
  41bff5:	44 89 fe             	mov    esi,r15d
  41bff8:	66 0f 70 c0 ff       	pshufd xmm0,xmm0,0xff
  41bffd:	83 e6 fc             	and    esi,0xfffffffc
  41c000:	66 0f 7e c1          	movd   ecx,xmm0
  41c004:	69 c6 00 ff ff ff    	imul   eax,esi,0xffffff00
  41c00a:	44 39 fe             	cmp    esi,r15d
  41c00d:	0f 84 45 11 00 00    	je     41d158 <printf_core+0xee8>
  41c013:	01 f8                	add    eax,edi
  41c015:	89 c1                	mov    ecx,eax
  41c017:	3d ff 00 00 00       	cmp    eax,0xff
  41c01c:	0f 86 36 11 00 00    	jbe    41d158 <printf_core+0xee8>
  41c022:	81 e9 00 01 00 00    	sub    ecx,0x100
  41c028:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  41c02e:	0f 86 24 11 00 00    	jbe    41d158 <printf_core+0xee8>
  41c034:	8d 88 00 fe ff ff    	lea    ecx,[rax-0x200]
  41c03a:	e9 19 11 00 00       	jmp    41d158 <printf_core+0xee8>
  41c03f:	45 8d 9f 00 ff ff ff 	lea    r11d,[r15-0x100]
  41c046:	48 8b 7c 24 18       	mov    rdi,QWORD PTR [rsp+0x18]
  41c04b:	45 31 c9             	xor    r9d,r9d
  41c04e:	66 41 0f 6e f7       	movd   xmm6,r15d
  41c053:	44 89 da             	mov    edx,r11d
  41c056:	66 0f 70 ce 00       	pshufd xmm1,xmm6,0x0
  41c05b:	48 be 00 0e fc ff ff 	movabs rsi,0xfffffffffffc0e00
  41c062:	ff ff ff 
  41c065:	c1 ea 08             	shr    edx,0x8
  41c068:	66 0f 6f 1c 3e       	movdqa xmm3,XMMWORD PTR [rsi+rdi*1]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41c06d:	89 c6                	mov    esi,eax
  41c06f:	8d 4a 01             	lea    ecx,[rdx+0x1]
  41c072:	48 ba f0 0d fc ff ff 	movabs rdx,0xfffffffffffc0df0
  41c079:	ff ff ff 
  41c07c:	66 0f fe 0c 3a       	paddd  xmm1,XMMWORD PTR [rdx+rdi*1]
  41c081:	89 cd                	mov    ebp,ecx
  41c083:	48 ba 10 0e fc ff ff 	movabs rdx,0xfffffffffffc0e10
  41c08a:	ff ff ff 
	for (; l >= sizeof pad; l -= sizeof pad)
  41c08d:	66 0f 6f 14 3a       	movdqa xmm2,XMMWORD PTR [rdx+rdi*1]
  41c092:	c1 ed 02             	shr    ebp,0x2
  41c095:	66 0f 6f c1          	movdqa xmm0,xmm1
  41c099:	41 83 c1 01          	add    r9d,0x1
  41c09d:	66 0f fe cb          	paddd  xmm1,xmm3
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41c0a1:	89 f0                	mov    eax,esi
	for (; l >= sizeof pad; l -= sizeof pad)
  41c0a3:	66 0f fe c2          	paddd  xmm0,xmm2
  41c0a7:	41 39 e9             	cmp    r9d,ebp
  41c0aa:	72 e9                	jb     41c095 <printf_core.cold+0x2aa>
  41c0ac:	89 ce                	mov    esi,ecx
  41c0ae:	66 0f 70 c0 ff       	pshufd xmm0,xmm0,0xff
  41c0b3:	83 e6 fc             	and    esi,0xfffffffc
  41c0b6:	66 0f 7e c5          	movd   ebp,xmm0
  41c0ba:	69 d6 00 ff ff ff    	imul   edx,esi,0xffffff00
  41c0c0:	39 ce                	cmp    esi,ecx
  41c0c2:	0f 84 e8 0a 00 00    	je     41cbb0 <printf_core+0x940>
  41c0c8:	44 01 da             	add    edx,r11d
  41c0cb:	89 d5                	mov    ebp,edx
  41c0cd:	81 fa ff 00 00 00    	cmp    edx,0xff
  41c0d3:	0f 86 d7 0a 00 00    	jbe    41cbb0 <printf_core+0x940>
  41c0d9:	81 ed 00 01 00 00    	sub    ebp,0x100
  41c0df:	81 fd ff 00 00 00    	cmp    ebp,0xff
  41c0e5:	0f 86 c5 0a 00 00    	jbe    41cbb0 <printf_core+0x940>
  41c0eb:	8d aa 00 fe ff ff    	lea    ebp,[rdx-0x200]
  41c0f1:	e9 ba 0a 00 00       	jmp    41cbb0 <printf_core+0x940>
  41c0f6:	44 8d 85 00 ff ff ff 	lea    r8d,[rbp-0x100]
  41c0fd:	48 8b 7c 24 18       	mov    rdi,QWORD PTR [rsp+0x18]
  41c102:	66 0f 6e fd          	movd   xmm7,ebp
  41c106:	45 31 db             	xor    r11d,r11d
  41c109:	44 89 c1             	mov    ecx,r8d
  41c10c:	66 0f 70 c7 00       	pshufd xmm0,xmm7,0x0
  41c111:	48 ba f0 0d fc ff ff 	movabs rdx,0xfffffffffffc0df0
  41c118:	ff ff ff 
  41c11b:	48 be 00 0e fc ff ff 	movabs rsi,0xfffffffffffc0e00
  41c122:	ff ff ff 
  41c125:	c1 e9 08             	shr    ecx,0x8
  41c128:	66 0f fe 04 3a       	paddd  xmm0,XMMWORD PTR [rdx+rdi*1]
  41c12d:	66 0f 6f 1c 3e       	movdqa xmm3,XMMWORD PTR [rsi+rdi*1]
  41c132:	48 ba 10 0e fc ff ff 	movabs rdx,0xfffffffffffc0e10
  41c139:	ff ff ff 
  41c13c:	83 c1 01             	add    ecx,0x1
  41c13f:	66 0f 6f 14 3a       	movdqa xmm2,XMMWORD PTR [rdx+rdi*1]
  41c144:	41 89 c9             	mov    r9d,ecx
  41c147:	41 c1 e9 02          	shr    r9d,0x2
  41c14b:	66 0f 6f c8          	movdqa xmm1,xmm0
  41c14f:	41 83 c3 01          	add    r11d,0x1
  41c153:	66 0f fe c3          	paddd  xmm0,xmm3
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41c157:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  41c159:	66 0f fe ca          	paddd  xmm1,xmm2
  41c15d:	45 39 cb             	cmp    r11d,r9d
  41c160:	72 e9                	jb     41c14b <printf_core.cold+0x360>
  41c162:	89 ce                	mov    esi,ecx
  41c164:	66 0f 70 c1 ff       	pshufd xmm0,xmm1,0xff
  41c169:	83 e6 fc             	and    esi,0xfffffffc
  41c16c:	66 41 0f 7e c4       	movd   r12d,xmm0
  41c171:	69 c6 00 ff ff ff    	imul   eax,esi,0xffffff00
  41c177:	39 f1                	cmp    ecx,esi
  41c179:	0f 84 eb 0a 00 00    	je     41cc6a <printf_core+0x9fa>
  41c17f:	44 01 c0             	add    eax,r8d
  41c182:	41 89 c4             	mov    r12d,eax
  41c185:	3d ff 00 00 00       	cmp    eax,0xff
  41c18a:	0f 86 da 0a 00 00    	jbe    41cc6a <printf_core+0x9fa>
  41c190:	41 81 ec 00 01 00 00 	sub    r12d,0x100
  41c197:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  41c19e:	0f 86 c6 0a 00 00    	jbe    41cc6a <printf_core+0x9fa>
  41c1a4:	44 8d a0 00 fe ff ff 	lea    r12d,[rax-0x200]
  41c1ab:	e9 ba 0a 00 00       	jmp    41cc6a <printf_core+0x9fa>
  41c1b0:	45 8d 9f 00 ff ff ff 	lea    r11d,[r15-0x100]
  41c1b7:	4c 8b 54 24 18       	mov    r10,QWORD PTR [rsp+0x18]
  41c1bc:	31 c9                	xor    ecx,ecx
  41c1be:	66 41 0f 6e ef       	movd   xmm5,r15d
  41c1c3:	44 89 da             	mov    edx,r11d
  41c1c6:	66 0f 70 cd 00       	pshufd xmm1,xmm5,0x0
  41c1cb:	48 be 00 0e fc ff ff 	movabs rsi,0xfffffffffffc0e00
  41c1d2:	ff ff ff 
  41c1d5:	c1 ea 08             	shr    edx,0x8
  41c1d8:	66 42 0f 6f 1c 16    	movdqa xmm3,XMMWORD PTR [rsi+r10*1]
  41c1de:	44 8d 4a 01          	lea    r9d,[rdx+0x1]
  41c1e2:	48 ba f0 0d fc ff ff 	movabs rdx,0xfffffffffffc0df0
  41c1e9:	ff ff ff 
  41c1ec:	66 42 0f fe 0c 12    	paddd  xmm1,XMMWORD PTR [rdx+r10*1]
  41c1f2:	44 89 cf             	mov    edi,r9d
  41c1f5:	48 ba 10 0e fc ff ff 	movabs rdx,0xfffffffffffc0e10
  41c1fc:	ff ff ff 
  41c1ff:	66 42 0f 6f 14 12    	movdqa xmm2,XMMWORD PTR [rdx+r10*1]
  41c205:	c1 ef 02             	shr    edi,0x2
  41c208:	66 0f 6f c1          	movdqa xmm0,xmm1
  41c20c:	83 c1 01             	add    ecx,0x1
  41c20f:	66 0f fe cb          	paddd  xmm1,xmm3
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41c213:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  41c215:	66 0f fe c2          	paddd  xmm0,xmm2
  41c219:	39 f9                	cmp    ecx,edi
  41c21b:	72 eb                	jb     41c208 <printf_core.cold+0x41d>
  41c21d:	44 89 ce             	mov    esi,r9d
  41c220:	66 0f 70 c0 ff       	pshufd xmm0,xmm0,0xff
  41c225:	83 e6 fc             	and    esi,0xfffffffc
  41c228:	66 0f 7e c1          	movd   ecx,xmm0
  41c22c:	69 c6 00 ff ff ff    	imul   eax,esi,0xffffff00
  41c232:	44 39 ce             	cmp    esi,r9d
  41c235:	0f 84 a3 08 00 00    	je     41cade <printf_core+0x86e>
  41c23b:	44 01 d8             	add    eax,r11d
  41c23e:	89 c1                	mov    ecx,eax
  41c240:	3d ff 00 00 00       	cmp    eax,0xff
  41c245:	0f 86 93 08 00 00    	jbe    41cade <printf_core+0x86e>
  41c24b:	81 e9 00 01 00 00    	sub    ecx,0x100
  41c251:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  41c257:	0f 86 81 08 00 00    	jbe    41cade <printf_core+0x86e>
  41c25d:	8d 88 00 fe ff ff    	lea    ecx,[rax-0x200]
  41c263:	e9 76 08 00 00       	jmp    41cade <printf_core+0x86e>
  41c268:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41c26f:	00 

000000000041c270 <printf_core>:
	}
	return i;
}

static int printf_core(FILE *f, const char *fmt, va_list *ap, union arg *nl_arg, int *nl_type)
{
  41c270:	f3 0f 1e fa          	endbr64 
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41c274:	48 b8 20 ce fb ff ff 	movabs rax,0xfffffffffffbce20
  41c27b:	ff ff ff 
{
  41c27e:	41 57                	push   r15
  41c280:	49 bb 9c 51 04 00 00 	movabs r11,0x4519c
  41c287:	00 00 00 
  41c28a:	41 56                	push   r14
  41c28c:	41 55                	push   r13
  41c28e:	49 89 fd             	mov    r13,rdi
  41c291:	41 54                	push   r12
  41c293:	55                   	push   rbp
  41c294:	53                   	push   rbx
  41c295:	48 8d 1d d8 ff ff ff 	lea    rbx,[rip+0xffffffffffffffd8]        # 41c274 <printf_core+0x4>
  41c29c:	4c 01 db             	add    rbx,r11
  41c29f:	48 81 ec d8 01 00 00 	sub    rsp,0x1d8
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41c2a6:	48 89 44 24 20       	mov    QWORD PTR [rsp+0x20],rax
		/* Format specifier state machine */
		st=0;
		do {
			if (OOB(*s)) goto inval;
			ps=st;
			st=states[st]S(*s++);
  41c2ab:	48 b8 70 0b fc ff ff 	movabs rax,0xfffffffffffc0b70
  41c2b2:	ff ff ff 
  41c2b5:	48 01 d8             	add    rax,rbx
  41c2b8:	48 89 5c 24 18       	mov    QWORD PTR [rsp+0x18],rbx
{
  41c2bd:	48 89 54 24 30       	mov    QWORD PTR [rsp+0x30],rdx
  41c2c2:	48 89 4c 24 48       	mov    QWORD PTR [rsp+0x48],rcx
	int cnt=0, l=0;
  41c2c7:	c7 44 24 08 00 00 00 	mov    DWORD PTR [rsp+0x8],0x0
  41c2ce:	00 
  41c2cf:	c7 44 24 14 00 00 00 	mov    DWORD PTR [rsp+0x14],0x0
  41c2d6:	00 
	unsigned l10n=0, fl;
  41c2d7:	c7 44 24 58 00 00 00 	mov    DWORD PTR [rsp+0x58],0x0
  41c2de:	00 
			st=states[st]S(*s++);
  41c2df:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
{
  41c2e4:	4c 89 44 24 40       	mov    QWORD PTR [rsp+0x40],r8
  41c2e9:	49 89 f0             	mov    r8,rsi
		if (!*s) break;
  41c2ec:	41 0f b6 00          	movzx  eax,BYTE PTR [r8]
		cnt += l;
  41c2f0:	8b 54 24 08          	mov    edx,DWORD PTR [rsp+0x8]
  41c2f4:	01 54 24 14          	add    DWORD PTR [rsp+0x14],edx
		if (!*s) break;
  41c2f8:	84 c0                	test   al,al
  41c2fa:	0f 84 50 05 00 00    	je     41c850 <printf_core+0x5e0>
		for (a=s; *s && *s!='%'; s++);
  41c300:	4d 89 c6             	mov    r14,r8
  41c303:	eb 10                	jmp    41c315 <printf_core+0xa5>
  41c305:	0f 1f 00             	nop    DWORD PTR [rax]
  41c308:	41 0f b6 46 01       	movzx  eax,BYTE PTR [r14+0x1]
  41c30d:	49 83 c6 01          	add    r14,0x1
  41c311:	84 c0                	test   al,al
  41c313:	74 6b                	je     41c380 <printf_core+0x110>
  41c315:	3c 25                	cmp    al,0x25
  41c317:	75 ef                	jne    41c308 <printf_core+0x98>
  41c319:	4c 89 f3             	mov    rbx,r14
  41c31c:	eb 0f                	jmp    41c32d <printf_core+0xbd>
  41c31e:	66 90                	xchg   ax,ax
		for (z=s; s[0]=='%' && s[1]=='%'; z++, s+=2);
  41c320:	48 83 c3 02          	add    rbx,0x2
  41c324:	49 83 c6 01          	add    r14,0x1
  41c328:	80 3b 25             	cmp    BYTE PTR [rbx],0x25
  41c32b:	75 06                	jne    41c333 <printf_core+0xc3>
  41c32d:	80 7b 01 25          	cmp    BYTE PTR [rbx+0x1],0x25
  41c331:	74 ed                	je     41c320 <printf_core+0xb0>
		if (z-a > INT_MAX-cnt) goto overflow;
  41c333:	41 bb ff ff ff 7f    	mov    r11d,0x7fffffff
  41c339:	44 2b 5c 24 14       	sub    r11d,DWORD PTR [rsp+0x14]
  41c33e:	4d 29 c6             	sub    r14,r8
  41c341:	49 63 c3             	movsxd rax,r11d
  41c344:	49 39 c6             	cmp    r14,rax
  41c347:	0f 8f 5c 03 00 00    	jg     41c6a9 <printf_core+0x439>
		l = z-a;
  41c34d:	44 89 74 24 08       	mov    DWORD PTR [rsp+0x8],r14d
		if (f) out(f, a, l);
  41c352:	4d 85 ed             	test   r13,r13
  41c355:	74 0b                	je     41c362 <printf_core+0xf2>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41c357:	41 f6 45 00 20       	test   BYTE PTR [r13+0x0],0x20
  41c35c:	0f 84 6e 01 00 00    	je     41c4d0 <printf_core+0x260>
		if (l) continue;
  41c362:	45 85 f6             	test   r14d,r14d
  41c365:	74 29                	je     41c390 <printf_core+0x120>
		if (l > INT_MAX - cnt) goto overflow;
  41c367:	44 3b 5c 24 08       	cmp    r11d,DWORD PTR [rsp+0x8]
  41c36c:	0f 8c 37 03 00 00    	jl     41c6a9 <printf_core+0x439>
{
  41c372:	49 89 d8             	mov    r8,rbx
  41c375:	e9 72 ff ff ff       	jmp    41c2ec <printf_core+0x7c>
  41c37a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
		for (a=s; *s && *s!='%'; s++);
  41c380:	4c 89 f3             	mov    rbx,r14
		for (z=s; s[0]=='%' && s[1]=='%'; z++, s+=2);
  41c383:	3c 25                	cmp    al,0x25
  41c385:	74 92                	je     41c319 <printf_core+0xa9>
  41c387:	eb aa                	jmp    41c333 <printf_core+0xc3>
  41c389:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		if (isdigit(s[1]) && s[2]=='$') {
  41c390:	0f be 4b 01          	movsx  ecx,BYTE PTR [rbx+0x1]
  41c394:	8d 51 d0             	lea    edx,[rcx-0x30]
  41c397:	89 cf                	mov    edi,ecx
  41c399:	83 fa 09             	cmp    edx,0x9
  41c39c:	77 0a                	ja     41c3a8 <printf_core+0x138>
  41c39e:	80 7b 02 24          	cmp    BYTE PTR [rbx+0x2],0x24
  41c3a2:	0f 84 69 03 00 00    	je     41c711 <printf_core+0x4a1>
			s++;
  41c3a8:	48 83 c3 01          	add    rbx,0x1
			argpos = -1;
  41c3ac:	ba ff ff ff ff       	mov    edx,0xffffffff
		for (fl=0; (unsigned)*s-' '<32 && (FLAGMASK&(1U<<*s-' ')); s++)
  41c3b1:	44 8d 49 e0          	lea    r9d,[rcx-0x20]
  41c3b5:	45 31 e4             	xor    r12d,r12d
  41c3b8:	b8 89 28 01 00       	mov    eax,0x12889
			fl |= 1U<<*s-' ';
  41c3bd:	be 01 00 00 00       	mov    esi,0x1
		for (fl=0; (unsigned)*s-' '<32 && (FLAGMASK&(1U<<*s-' ')); s++)
  41c3c2:	41 83 f9 1f          	cmp    r9d,0x1f
  41c3c6:	76 22                	jbe    41c3ea <printf_core+0x17a>
  41c3c8:	eb 28                	jmp    41c3f2 <printf_core+0x182>
  41c3ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
			fl |= 1U<<*s-' ';
  41c3d0:	89 f7                	mov    edi,esi
		for (fl=0; (unsigned)*s-' '<32 && (FLAGMASK&(1U<<*s-' ')); s++)
  41c3d2:	48 83 c3 01          	add    rbx,0x1
			fl |= 1U<<*s-' ';
  41c3d6:	d3 e7                	shl    edi,cl
		for (fl=0; (unsigned)*s-' '<32 && (FLAGMASK&(1U<<*s-' ')); s++)
  41c3d8:	0f be 0b             	movsx  ecx,BYTE PTR [rbx]
			fl |= 1U<<*s-' ';
  41c3db:	41 09 fc             	or     r12d,edi
		for (fl=0; (unsigned)*s-' '<32 && (FLAGMASK&(1U<<*s-' ')); s++)
  41c3de:	44 8d 49 e0          	lea    r9d,[rcx-0x20]
  41c3e2:	89 cf                	mov    edi,ecx
  41c3e4:	41 83 f9 1f          	cmp    r9d,0x1f
  41c3e8:	77 08                	ja     41c3f2 <printf_core+0x182>
  41c3ea:	83 e9 20             	sub    ecx,0x20
  41c3ed:	0f a3 c8             	bt     eax,ecx
  41c3f0:	72 de                	jb     41c3d0 <printf_core+0x160>
		if (*s=='*') {
  41c3f2:	40 80 ff 2a          	cmp    dil,0x2a
  41c3f6:	0f 85 94 01 00 00    	jne    41c590 <printf_core+0x320>
			if (isdigit(s[1]) && s[2]=='$') {
  41c3fc:	48 0f be 43 01       	movsx  rax,BYTE PTR [rbx+0x1]
  41c401:	48 89 c6             	mov    rsi,rax
  41c404:	83 e8 30             	sub    eax,0x30
  41c407:	83 f8 09             	cmp    eax,0x9
  41c40a:	0f 86 c0 02 00 00    	jbe    41c6d0 <printf_core+0x460>
			} else if (!l10n) {
  41c410:	8b 44 24 58          	mov    eax,DWORD PTR [rsp+0x58]
  41c414:	85 c0                	test   eax,eax
  41c416:	0f 85 32 01 00 00    	jne    41c54e <printf_core+0x2de>
				s++;
  41c41c:	48 83 c3 01          	add    rbx,0x1
				w = f ? va_arg(*ap, int) : 0;
  41c420:	45 89 f1             	mov    r9d,r14d
  41c423:	4d 85 ed             	test   r13,r13
  41c426:	74 30                	je     41c458 <printf_core+0x1e8>
  41c428:	48 8b 7c 24 30       	mov    rdi,QWORD PTR [rsp+0x30]
  41c42d:	8b 07                	mov    eax,DWORD PTR [rdi]
  41c42f:	83 f8 2f             	cmp    eax,0x2f
  41c432:	0f 87 08 03 00 00    	ja     41c740 <printf_core+0x4d0>
  41c438:	89 c1                	mov    ecx,eax
  41c43a:	83 c0 08             	add    eax,0x8
  41c43d:	48 03 4f 10          	add    rcx,QWORD PTR [rdi+0x10]
  41c441:	89 07                	mov    DWORD PTR [rdi],eax
  41c443:	44 8b 09             	mov    r9d,DWORD PTR [rcx]
		if (*s=='.' && s[1]=='*') {
  41c446:	0f b6 33             	movzx  esi,BYTE PTR [rbx]
			if (w<0) fl|=LEFT_ADJ, w=-w;
  41c449:	45 85 c9             	test   r9d,r9d
  41c44c:	79 0a                	jns    41c458 <printf_core+0x1e8>
  41c44e:	41 81 cc 00 20 00 00 	or     r12d,0x2000
  41c455:	41 f7 d9             	neg    r9d
		if (*s=='.' && s[1]=='*') {
  41c458:	40 80 fe 2e          	cmp    sil,0x2e
  41c45c:	0f 85 a6 00 00 00    	jne    41c508 <printf_core+0x298>
  41c462:	0f be 43 01          	movsx  eax,BYTE PTR [rbx+0x1]
  41c466:	3c 2a                	cmp    al,0x2a
  41c468:	0f 85 ea 02 00 00    	jne    41c758 <printf_core+0x4e8>
			if (isdigit(s[2]) && s[3]=='$') {
  41c46e:	48 0f be 43 02       	movsx  rax,BYTE PTR [rbx+0x2]
  41c473:	48 89 c1             	mov    rcx,rax
  41c476:	83 e8 30             	sub    eax,0x30
  41c479:	83 f8 09             	cmp    eax,0x9
  41c47c:	77 0a                	ja     41c488 <printf_core+0x218>
  41c47e:	80 7b 03 24          	cmp    BYTE PTR [rbx+0x3],0x24
  41c482:	0f 84 81 03 00 00    	je     41c809 <printf_core+0x599>
			} else if (!l10n) {
  41c488:	8b 44 24 58          	mov    eax,DWORD PTR [rsp+0x58]
  41c48c:	85 c0                	test   eax,eax
  41c48e:	0f 85 ba 00 00 00    	jne    41c54e <printf_core+0x2de>
				p = f ? va_arg(*ap, int) : 0;
  41c494:	4d 85 ed             	test   r13,r13
  41c497:	0f 84 a5 03 00 00    	je     41c842 <printf_core+0x5d2>
  41c49d:	48 8b 7c 24 30       	mov    rdi,QWORD PTR [rsp+0x30]
  41c4a2:	8b 07                	mov    eax,DWORD PTR [rdi]
  41c4a4:	83 f8 2f             	cmp    eax,0x2f
  41c4a7:	0f 87 12 03 00 00    	ja     41c7bf <printf_core+0x54f>
  41c4ad:	89 c1                	mov    ecx,eax
  41c4af:	83 c0 08             	add    eax,0x8
  41c4b2:	48 03 4f 10          	add    rcx,QWORD PTR [rdi+0x10]
  41c4b6:	89 07                	mov    DWORD PTR [rdi],eax
  41c4b8:	8b 29                	mov    ebp,DWORD PTR [rcx]
			xp = (p>=0);
  41c4ba:	89 e8                	mov    eax,ebp
  41c4bc:	f7 d0                	not    eax
  41c4be:	c1 e8 1f             	shr    eax,0x1f
  41c4c1:	41 89 c2             	mov    r10d,eax
				s+=2;
  41c4c4:	48 83 c3 02          	add    rbx,0x2
			xp = (p>=0);
  41c4c8:	eb 46                	jmp    41c510 <printf_core+0x2a0>
  41c4ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41c4d0:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  41c4d5:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  41c4da:	4c 89 c7             	mov    rdi,r8
		if (f) out(f, a, l);
  41c4dd:	49 63 f6             	movsxd rsi,r14d
  41c4e0:	44 89 5c 24 50       	mov    DWORD PTR [rsp+0x50],r11d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41c4e5:	4c 89 ea             	mov    rdx,r13
  41c4e8:	4c 89 44 24 38       	mov    QWORD PTR [rsp+0x38],r8
  41c4ed:	48 01 c8             	add    rax,rcx
  41c4f0:	ff d0                	call   rax
  41c4f2:	44 8b 5c 24 50       	mov    r11d,DWORD PTR [rsp+0x50]
  41c4f7:	4c 8b 44 24 38       	mov    r8,QWORD PTR [rsp+0x38]
  41c4fc:	e9 61 fe ff ff       	jmp    41c362 <printf_core+0xf2>
  41c501:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
			xp = 0;
  41c508:	45 89 f2             	mov    r10d,r14d
			p = -1;
  41c50b:	bd ff ff ff ff       	mov    ebp,0xffffffff
		st=0;
  41c510:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  41c515:	45 31 ff             	xor    r15d,r15d
  41c518:	eb 29                	jmp    41c543 <printf_core+0x2d3>
  41c51a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
			st=states[st]S(*s++);
  41c520:	44 89 ff             	mov    edi,r15d
  41c523:	48 98                	cdqe   
  41c525:	48 83 c3 01          	add    rbx,0x1
  41c529:	48 6b f7 3a          	imul   rsi,rdi,0x3a
  41c52d:	48 01 c6             	add    rsi,rax
  41c530:	0f b6 34 0e          	movzx  esi,BYTE PTR [rsi+rcx*1]
		} while (st-1<STOP);
  41c534:	8d 46 ff             	lea    eax,[rsi-0x1]
  41c537:	83 f8 07             	cmp    eax,0x7
  41c53a:	0f 87 c8 00 00 00    	ja     41c608 <printf_core+0x398>
  41c540:	41 89 f7             	mov    r15d,esi
			if (OOB(*s)) goto inval;
  41c543:	0f be 03             	movsx  eax,BYTE PTR [rbx]
  41c546:	83 e8 41             	sub    eax,0x41
  41c549:	83 f8 39             	cmp    eax,0x39
  41c54c:	76 d2                	jbe    41c520 <printf_core+0x2b0>
	for (; i<=NL_ARGMAX && !nl_type[i]; i++);
	if (i<=NL_ARGMAX) goto inval;
	return 1;

inval:
	errno = EINVAL;
  41c54e:	48 b8 b0 77 fb ff ff 	movabs rax,0xfffffffffffb77b0
  41c555:	ff ff ff 
  41c558:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  41c55d:	48 01 d0             	add    rax,rdx
  41c560:	ff d0                	call   rax
	return -1;
  41c562:	c7 44 24 14 ff ff ff 	mov    DWORD PTR [rsp+0x14],0xffffffff
  41c569:	ff 
	errno = EINVAL;
  41c56a:	c7 00 16 00 00 00    	mov    DWORD PTR [rax],0x16
overflow:
	errno = EOVERFLOW;
	return -1;
}
  41c570:	8b 44 24 14          	mov    eax,DWORD PTR [rsp+0x14]
  41c574:	48 81 c4 d8 01 00 00 	add    rsp,0x1d8
  41c57b:	5b                   	pop    rbx
  41c57c:	5d                   	pop    rbp
  41c57d:	41 5c                	pop    r12
  41c57f:	41 5d                	pop    r13
  41c581:	41 5e                	pop    r14
  41c583:	41 5f                	pop    r15
  41c585:	c3                   	ret    
  41c586:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41c58d:	00 00 00 
	for (i=0; isdigit(**s); (*s)++) {
  41c590:	0f be 03             	movsx  eax,BYTE PTR [rbx]
  41c593:	45 89 f1             	mov    r9d,r14d
  41c596:	89 c1                	mov    ecx,eax
  41c598:	83 e8 30             	sub    eax,0x30
  41c59b:	89 ce                	mov    esi,ecx
  41c59d:	83 f8 09             	cmp    eax,0x9
  41c5a0:	76 3a                	jbe    41c5dc <printf_core+0x36c>
  41c5a2:	e9 b1 fe ff ff       	jmp    41c458 <printf_core+0x1e8>
  41c5a7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41c5ae:	00 00 
		if (i > INT_MAX/10U || **s-'0' > INT_MAX-10*i) i = -1;
  41c5b0:	41 6b f9 f6          	imul   edi,r9d,0xfffffff6
  41c5b4:	83 e9 30             	sub    ecx,0x30
  41c5b7:	44 8d 8f ff ff ff 7f 	lea    r9d,[rdi+0x7fffffff]
  41c5be:	44 39 c9             	cmp    ecx,r9d
  41c5c1:	7f 2f                	jg     41c5f2 <printf_core+0x382>
		else i = 10*i + (**s-'0');
  41c5c3:	29 f9                	sub    ecx,edi
  41c5c5:	41 89 c9             	mov    r9d,ecx
	for (i=0; isdigit(**s); (*s)++) {
  41c5c8:	83 f8 09             	cmp    eax,0x9
  41c5cb:	0f 87 cf 00 00 00    	ja     41c6a0 <printf_core+0x430>
  41c5d1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  41c5d8:	40 0f be ce          	movsx  ecx,sil
  41c5dc:	0f be 43 01          	movsx  eax,BYTE PTR [rbx+0x1]
  41c5e0:	48 83 c3 01          	add    rbx,0x1
  41c5e4:	89 c6                	mov    esi,eax
  41c5e6:	83 e8 30             	sub    eax,0x30
		if (i > INT_MAX/10U || **s-'0' > INT_MAX-10*i) i = -1;
  41c5e9:	41 81 f9 cc cc cc 0c 	cmp    r9d,0xccccccc
  41c5f0:	76 be                	jbe    41c5b0 <printf_core+0x340>
	for (i=0; isdigit(**s); (*s)++) {
  41c5f2:	83 f8 09             	cmp    eax,0x9
  41c5f5:	0f 87 ae 00 00 00    	ja     41c6a9 <printf_core+0x439>
  41c5fb:	41 b9 ff ff ff ff    	mov    r9d,0xffffffff
  41c601:	eb d5                	jmp    41c5d8 <printf_core+0x368>
  41c603:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		if (!st) goto inval;
  41c608:	48 89 f8             	mov    rax,rdi
  41c60b:	85 f6                	test   esi,esi
  41c60d:	0f 84 3b ff ff ff    	je     41c54e <printf_core+0x2de>
		if (st==NOARG) {
  41c613:	83 fe 1b             	cmp    esi,0x1b
  41c616:	0f 84 0c 01 00 00    	je     41c728 <printf_core+0x4b8>
			if (argpos>=0) nl_type[argpos]=st, arg=nl_arg[argpos];
  41c61c:	83 fa ff             	cmp    edx,0xffffffff
  41c61f:	0f 84 ab 01 00 00    	je     41c7d0 <printf_core+0x560>
  41c625:	48 8b 7c 24 40       	mov    rdi,QWORD PTR [rsp+0x40]
  41c62a:	48 63 d2             	movsxd rdx,edx
  41c62d:	89 34 97             	mov    DWORD PTR [rdi+rdx*4],esi
  41c630:	48 8b 7c 24 48       	mov    rdi,QWORD PTR [rsp+0x48]
  41c635:	48 c1 e2 04          	shl    rdx,0x4
  41c639:	66 0f 6f 24 17       	movdqa xmm4,XMMWORD PTR [rdi+rdx*1]
  41c63e:	0f 29 a4 24 90 00 00 	movaps XMMWORD PTR [rsp+0x90],xmm4
  41c645:	00 
		if (!f) continue;
  41c646:	4d 85 ed             	test   r13,r13
  41c649:	0f 84 23 fd ff ff    	je     41c372 <printf_core+0x102>
		t = s[-1];
  41c64f:	0f be 53 ff          	movsx  edx,BYTE PTR [rbx-0x1]
  41c653:	89 d1                	mov    ecx,edx
		if (ps && (t&15)==3) t&=~32;
  41c655:	45 85 ff             	test   r15d,r15d
  41c658:	74 12                	je     41c66c <printf_core+0x3fc>
  41c65a:	89 d6                	mov    esi,edx
  41c65c:	83 e1 df             	and    ecx,0xffffffdf
  41c65f:	83 e6 0f             	and    esi,0xf
  41c662:	0f be c9             	movsx  ecx,cl
  41c665:	40 80 fe 03          	cmp    sil,0x3
  41c669:	0f 44 d1             	cmove  edx,ecx
		if (fl & LEFT_ADJ) fl &= ~ZERO_PAD;
  41c66c:	44 89 e1             	mov    ecx,r12d
  41c66f:	81 e1 ff ff fe ff    	and    ecx,0xfffeffff
  41c675:	41 f7 c4 00 20 00 00 	test   r12d,0x2000
  41c67c:	44 0f 45 e1          	cmovne r12d,ecx
		switch(t) {
  41c680:	8d 4a bf             	lea    ecx,[rdx-0x41]
  41c683:	83 f9 37             	cmp    ecx,0x37
  41c686:	0f 87 34 02 00 00    	ja     41c8c0 <printf_core+0x650>
  41c68c:	48 8d 35 c5 56 00 00 	lea    rsi,[rip+0x56c5]        # 421d58 <CSWTCH.186+0x828>
  41c693:	48 03 34 ce          	add    rsi,QWORD PTR [rsi+rcx*8]
  41c697:	3e ff e6             	notrack jmp rsi
  41c69a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
		} else if ((w=getint(&s))<0) goto overflow;
  41c6a0:	83 f9 ff             	cmp    ecx,0xffffffff
  41c6a3:	0f 85 af fd ff ff    	jne    41c458 <printf_core+0x1e8>
	errno = EOVERFLOW;
  41c6a9:	48 b8 b0 77 fb ff ff 	movabs rax,0xfffffffffffb77b0
  41c6b0:	ff ff ff 
  41c6b3:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  41c6b8:	48 01 d0             	add    rax,rdx
  41c6bb:	ff d0                	call   rax
	return -1;
  41c6bd:	c7 44 24 14 ff ff ff 	mov    DWORD PTR [rsp+0x14],0xffffffff
  41c6c4:	ff 
	errno = EOVERFLOW;
  41c6c5:	c7 00 4b 00 00 00    	mov    DWORD PTR [rax],0x4b
	return -1;
  41c6cb:	e9 a0 fe ff ff       	jmp    41c570 <printf_core+0x300>
			if (isdigit(s[1]) && s[2]=='$') {
  41c6d0:	80 7b 02 24          	cmp    BYTE PTR [rbx+0x2],0x24
  41c6d4:	0f 85 36 fd ff ff    	jne    41c410 <printf_core+0x1a0>
				nl_type[s[1]-'0'] = INT;
  41c6da:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
				w = nl_arg[s[1]-'0'].i;
  41c6df:	48 8b 7c 24 48       	mov    rdi,QWORD PTR [rsp+0x48]
				l10n=1;
  41c6e4:	c7 44 24 58 01 00 00 	mov    DWORD PTR [rsp+0x58],0x1
  41c6eb:	00 
				s+=3;
  41c6ec:	48 83 c3 03          	add    rbx,0x3
				nl_type[s[1]-'0'] = INT;
  41c6f0:	c7 84 b0 40 ff ff ff 	mov    DWORD PTR [rax+rsi*4-0xc0],0xa
  41c6f7:	0a 00 00 00 
				w = nl_arg[s[1]-'0'].i;
  41c6fb:	48 0f be 43 fe       	movsx  rax,BYTE PTR [rbx-0x2]
  41c700:	48 c1 e0 04          	shl    rax,0x4
  41c704:	44 8b 8c 07 00 fd ff 	mov    r9d,DWORD PTR [rdi+rax*1-0x300]
  41c70b:	ff 
				s+=3;
  41c70c:	e9 35 fd ff ff       	jmp    41c446 <printf_core+0x1d6>
		for (fl=0; (unsigned)*s-' '<32 && (FLAGMASK&(1U<<*s-' ')); s++)
  41c711:	0f be 4b 03          	movsx  ecx,BYTE PTR [rbx+0x3]
			l10n=1;
  41c715:	c7 44 24 58 01 00 00 	mov    DWORD PTR [rsp+0x58],0x1
  41c71c:	00 
			s+=3;
  41c71d:	48 83 c3 03          	add    rbx,0x3
		for (fl=0; (unsigned)*s-' '<32 && (FLAGMASK&(1U<<*s-' ')); s++)
  41c721:	89 cf                	mov    edi,ecx
			s+=3;
  41c723:	e9 89 fc ff ff       	jmp    41c3b1 <printf_core+0x141>
			if (argpos>=0) goto inval;
  41c728:	83 fa ff             	cmp    edx,0xffffffff
  41c72b:	0f 84 15 ff ff ff    	je     41c646 <printf_core+0x3d6>
  41c731:	e9 18 fe ff ff       	jmp    41c54e <printf_core+0x2de>
  41c736:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41c73d:	00 00 00 
				w = f ? va_arg(*ap, int) : 0;
  41c740:	48 8b 4f 08          	mov    rcx,QWORD PTR [rdi+0x8]
  41c744:	48 8d 41 08          	lea    rax,[rcx+0x8]
  41c748:	48 89 47 08          	mov    QWORD PTR [rdi+0x8],rax
  41c74c:	e9 f2 fc ff ff       	jmp    41c443 <printf_core+0x1d3>
  41c751:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (i=0; isdigit(**s); (*s)++) {
  41c758:	8d 48 d0             	lea    ecx,[rax-0x30]
			s++;
  41c75b:	48 83 c3 01          	add    rbx,0x1
	for (i=0; isdigit(**s); (*s)++) {
  41c75f:	44 89 f5             	mov    ebp,r14d
  41c762:	83 f9 09             	cmp    ecx,0x9
  41c765:	77 4d                	ja     41c7b4 <printf_core+0x544>
		if (i > INT_MAX/10U || **s-'0' > INT_MAX-10*i) i = -1;
  41c767:	be ff ff ff ff       	mov    esi,0xffffffff
  41c76c:	eb 29                	jmp    41c797 <printf_core+0x527>
  41c76e:	66 90                	xchg   ax,ax
  41c770:	6b ed f6             	imul   ebp,ebp,0xfffffff6
  41c773:	83 e8 30             	sub    eax,0x30
  41c776:	89 c1                	mov    ecx,eax
  41c778:	8d bd ff ff ff 7f    	lea    edi,[rbp+0x7fffffff]
  41c77e:	29 e9                	sub    ecx,ebp
  41c780:	39 f8                	cmp    eax,edi
  41c782:	0f 4f ce             	cmovg  ecx,esi
	for (i=0; isdigit(**s); (*s)++) {
  41c785:	0f be 43 01          	movsx  eax,BYTE PTR [rbx+0x1]
  41c789:	48 83 c3 01          	add    rbx,0x1
  41c78d:	89 cd                	mov    ebp,ecx
  41c78f:	8d 48 d0             	lea    ecx,[rax-0x30]
  41c792:	83 f9 09             	cmp    ecx,0x9
  41c795:	77 1d                	ja     41c7b4 <printf_core+0x544>
		if (i > INT_MAX/10U || **s-'0' > INT_MAX-10*i) i = -1;
  41c797:	81 fd cc cc cc 0c    	cmp    ebp,0xccccccc
  41c79d:	76 d1                	jbe    41c770 <printf_core+0x500>
	for (i=0; isdigit(**s); (*s)++) {
  41c79f:	0f be 43 01          	movsx  eax,BYTE PTR [rbx+0x1]
  41c7a3:	48 83 c3 01          	add    rbx,0x1
		if (i > INT_MAX/10U || **s-'0' > INT_MAX-10*i) i = -1;
  41c7a7:	bd ff ff ff ff       	mov    ebp,0xffffffff
	for (i=0; isdigit(**s); (*s)++) {
  41c7ac:	8d 48 d0             	lea    ecx,[rax-0x30]
  41c7af:	83 f9 09             	cmp    ecx,0x9
  41c7b2:	76 e3                	jbe    41c797 <printf_core+0x527>
			xp = 1;
  41c7b4:	41 ba 01 00 00 00    	mov    r10d,0x1
  41c7ba:	e9 51 fd ff ff       	jmp    41c510 <printf_core+0x2a0>
				p = f ? va_arg(*ap, int) : 0;
  41c7bf:	48 8b 4f 08          	mov    rcx,QWORD PTR [rdi+0x8]
  41c7c3:	48 8d 41 08          	lea    rax,[rcx+0x8]
  41c7c7:	48 89 47 08          	mov    QWORD PTR [rdi+0x8],rax
  41c7cb:	e9 e8 fc ff ff       	jmp    41c4b8 <printf_core+0x248>
			else if (f) pop_arg(&arg, st, ap);
  41c7d0:	4d 85 ed             	test   r13,r13
  41c7d3:	0f 84 97 0f 00 00    	je     41d770 <printf_core+0x1500>
  41c7d9:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  41c7de:	48 8b 54 24 30       	mov    rdx,QWORD PTR [rsp+0x30]
  41c7e3:	48 89 7c 24 38       	mov    QWORD PTR [rsp+0x38],rdi
  41c7e8:	48 b9 50 78 fb ff ff 	movabs rcx,0xfffffffffffb7850
  41c7ef:	ff ff ff 
  41c7f2:	48 8d bc 24 90 00 00 	lea    rdi,[rsp+0x90]
  41c7f9:	00 
  41c7fa:	48 01 c1             	add    rcx,rax
  41c7fd:	ff d1                	call   rcx
		if (!f) continue;
  41c7ff:	48 8b 44 24 38       	mov    rax,QWORD PTR [rsp+0x38]
  41c804:	e9 46 fe ff ff       	jmp    41c64f <printf_core+0x3df>
				nl_type[s[2]-'0'] = INT;
  41c809:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
				p = nl_arg[s[2]-'0'].i;
  41c80e:	48 8b 7c 24 48       	mov    rdi,QWORD PTR [rsp+0x48]
				s+=4;
  41c813:	48 83 c3 04          	add    rbx,0x4
				nl_type[s[2]-'0'] = INT;
  41c817:	c7 84 88 40 ff ff ff 	mov    DWORD PTR [rax+rcx*4-0xc0],0xa
  41c81e:	0a 00 00 00 
				p = nl_arg[s[2]-'0'].i;
  41c822:	48 0f be 43 fe       	movsx  rax,BYTE PTR [rbx-0x2]
  41c827:	48 c1 e0 04          	shl    rax,0x4
  41c82b:	48 8b 84 07 00 fd ff 	mov    rax,QWORD PTR [rdi+rax*1-0x300]
  41c832:	ff 
  41c833:	89 c5                	mov    ebp,eax
			xp = (p>=0);
  41c835:	f7 d0                	not    eax
  41c837:	c1 e8 1f             	shr    eax,0x1f
  41c83a:	41 89 c2             	mov    r10d,eax
				s+=4;
  41c83d:	e9 ce fc ff ff       	jmp    41c510 <printf_core+0x2a0>
				p = f ? va_arg(*ap, int) : 0;
  41c842:	44 89 f5             	mov    ebp,r14d
  41c845:	41 ba 01 00 00 00    	mov    r10d,0x1
  41c84b:	e9 74 fc ff ff       	jmp    41c4c4 <printf_core+0x254>
	if (f) return cnt;
  41c850:	4d 85 ed             	test   r13,r13
  41c853:	0f 85 17 fd ff ff    	jne    41c570 <printf_core+0x300>
	if (!l10n) return 0;
  41c859:	44 8b 64 24 58       	mov    r12d,DWORD PTR [rsp+0x58]
  41c85e:	45 85 e4             	test   r12d,r12d
  41c861:	0f 84 09 0f 00 00    	je     41d770 <printf_core+0x1500>
  41c867:	48 8b 7c 24 48       	mov    rdi,QWORD PTR [rsp+0x48]
		pop_arg(nl_arg+i, nl_type[i], ap);
  41c86c:	4c 8b 54 24 30       	mov    r10,QWORD PTR [rsp+0x30]
	for (i=1; i<=NL_ARGMAX && nl_type[i]; i++)
  41c871:	41 b8 01 00 00 00    	mov    r8d,0x1
		pop_arg(nl_arg+i, nl_type[i], ap);
  41c877:	49 b9 50 78 fb ff ff 	movabs r9,0xfffffffffffb7850
  41c87e:	ff ff ff 
  41c881:	4c 8b 5c 24 40       	mov    r11,QWORD PTR [rsp+0x40]
  41c886:	48 83 c7 10          	add    rdi,0x10
	for (i=1; i<=NL_ARGMAX && nl_type[i]; i++)
  41c88a:	43 8b 34 83          	mov    esi,DWORD PTR [r11+r8*4]
  41c88e:	85 f6                	test   esi,esi
  41c890:	0f 84 6c 0f 00 00    	je     41d802 <printf_core+0x1592>
		pop_arg(nl_arg+i, nl_type[i], ap);
  41c896:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
	for (i=1; i<=NL_ARGMAX && nl_type[i]; i++)
  41c89b:	49 83 c0 01          	add    r8,0x1
		pop_arg(nl_arg+i, nl_type[i], ap);
  41c89f:	4c 89 d2             	mov    rdx,r10
  41c8a2:	4c 01 c8             	add    rax,r9
  41c8a5:	ff d0                	call   rax
	for (i=1; i<=NL_ARGMAX && nl_type[i]; i++)
  41c8a7:	48 83 c7 10          	add    rdi,0x10
  41c8ab:	49 83 f8 0a          	cmp    r8,0xa
  41c8af:	75 d9                	jne    41c88a <printf_core+0x61a>
	return 1;
  41c8b1:	c7 44 24 14 01 00 00 	mov    DWORD PTR [rsp+0x14],0x1
  41c8b8:	00 
  41c8b9:	e9 b2 fc ff ff       	jmp    41c570 <printf_core+0x300>
  41c8be:	66 90                	xchg   ax,ax
		if (p < z-a) p = z-a;
  41c8c0:	48 8d 84 24 cb 00 00 	lea    rax,[rsp+0xcb]
  41c8c7:	00 
  41c8c8:	4c 29 c0             	sub    rax,r8
  41c8cb:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
  41c8d0:	48 63 c5             	movsxd rax,ebp
  41c8d3:	48 39 44 24 50       	cmp    QWORD PTR [rsp+0x50],rax
  41c8d8:	44 89 74 24 60       	mov    DWORD PTR [rsp+0x60],r14d
  41c8dd:	0f 8e 8d 0d 00 00    	jle    41d670 <printf_core+0x1400>
  41c8e3:	48 8b 7c 24 18       	mov    rdi,QWORD PTR [rsp+0x18]
  41c8e8:	ba ff ff ff 7f       	mov    edx,0x7fffffff
  41c8ed:	48 b8 35 09 fc ff ff 	movabs rax,0xfffffffffffc0935
  41c8f4:	ff ff ff 
  41c8f7:	48 01 f8             	add    rax,rdi
  41c8fa:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  41c8ff:	8b 6c 24 50          	mov    ebp,DWORD PTR [rsp+0x50]
		if (p > INT_MAX-pl) goto overflow;
  41c903:	39 d5                	cmp    ebp,edx
  41c905:	0f 8f 9e fd ff ff    	jg     41c6a9 <printf_core+0x439>
		if (w < pl+p) w = pl+p;
  41c90b:	8b 44 24 60          	mov    eax,DWORD PTR [rsp+0x60]
  41c90f:	01 e8                	add    eax,ebp
  41c911:	89 44 24 5c          	mov    DWORD PTR [rsp+0x5c],eax
  41c915:	8b 44 24 5c          	mov    eax,DWORD PTR [rsp+0x5c]
  41c919:	41 39 c1             	cmp    r9d,eax
  41c91c:	44 0f 4c c8          	cmovl  r9d,eax
  41c920:	44 89 4c 24 08       	mov    DWORD PTR [rsp+0x8],r9d
		if (w > INT_MAX-cnt) goto overflow;
  41c925:	45 39 cb             	cmp    r11d,r9d
  41c928:	0f 8c 7b fd ff ff    	jl     41c6a9 <printf_core+0x439>
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41c92e:	41 39 c1             	cmp    r9d,eax
  41c931:	0f 9e 44 24 38       	setle  BYTE PTR [rsp+0x38]
  41c936:	0f b6 44 24 38       	movzx  eax,BYTE PTR [rsp+0x38]
  41c93b:	41 f7 c4 00 20 01 00 	test   r12d,0x12000
  41c942:	0f 85 ec 0a 00 00    	jne    41d434 <printf_core+0x11c4>
  41c948:	84 c0                	test   al,al
  41c94a:	0f 85 e4 0a 00 00    	jne    41d434 <printf_core+0x11c4>
  41c950:	44 89 c9             	mov    ecx,r9d
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41c953:	b8 00 01 00 00       	mov    eax,0x100
	l = w - l;
  41c958:	2b 4c 24 5c          	sub    ecx,DWORD PTR [rsp+0x5c]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41c95c:	4c 8b 7c 24 18       	mov    r15,QWORD PTR [rsp+0x18]
  41c961:	39 c1                	cmp    ecx,eax
  41c963:	4c 8d b4 24 d0 00 00 	lea    r14,[rsp+0xd0]
  41c96a:	00 
  41c96b:	4c 89 44 24 78       	mov    QWORD PTR [rsp+0x78],r8
  41c970:	be 20 00 00 00       	mov    esi,0x20
  41c975:	0f 4e c1             	cmovle eax,ecx
  41c978:	89 4c 24 68          	mov    DWORD PTR [rsp+0x68],ecx
  41c97c:	4c 89 f7             	mov    rdi,r14
  41c97f:	48 63 d0             	movsxd rdx,eax
  41c982:	48 b8 3c 64 fb ff ff 	movabs rax,0xfffffffffffb643c
  41c989:	ff ff ff 
  41c98c:	4c 01 f8             	add    rax,r15
  41c98f:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  41c991:	8b 4c 24 68          	mov    ecx,DWORD PTR [rsp+0x68]
  41c995:	4c 8b 44 24 78       	mov    r8,QWORD PTR [rsp+0x78]
  41c99a:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  41c9a0:	0f 8e 5f 0d 00 00    	jle    41d705 <printf_core+0x1495>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41c9a6:	41 8b 55 00          	mov    edx,DWORD PTR [r13+0x0]
  41c9aa:	44 8d b9 00 ff ff ff 	lea    r15d,[rcx-0x100]
  41c9b1:	89 d0                	mov    eax,edx
  41c9b3:	83 e0 20             	and    eax,0x20
  41c9b6:	0f 84 24 0a 00 00    	je     41d3e0 <printf_core+0x1170>
	for (; l >= sizeof pad; l -= sizeof pad)
  41c9bc:	41 81 ff ff 00 00 00 	cmp    r15d,0xff
  41c9c3:	7e 57                	jle    41ca1c <printf_core+0x7ac>
  41c9c5:	41 8d 97 00 e9 ff ff 	lea    edx,[r15-0x1700]
  41c9cc:	81 fa 00 e9 ff 7f    	cmp    edx,0x7fffe900
  41c9d2:	0f 86 13 f4 ff ff    	jbe    41bdeb <printf_core.cold>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41c9d8:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  41c9da:	41 81 ef 00 01 00 00 	sub    r15d,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41c9e1:	89 d0                	mov    eax,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  41c9e3:	44 89 f9             	mov    ecx,r15d
  41c9e6:	41 81 ff ff 00 00 00 	cmp    r15d,0xff
  41c9ed:	77 eb                	ja     41c9da <printf_core+0x76a>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41c9ef:	85 c0                	test   eax,eax
  41c9f1:	75 31                	jne    41ca24 <printf_core+0x7b4>
  41c9f3:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
	out(f, pad, l);
  41c9f8:	48 63 f1             	movsxd rsi,ecx
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41c9fb:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  41ca00:	4c 89 ea             	mov    rdx,r13
  41ca03:	4c 89 44 24 68       	mov    QWORD PTR [rsp+0x68],r8
  41ca08:	4c 89 f7             	mov    rdi,r14
  41ca0b:	48 01 c8             	add    rax,rcx
  41ca0e:	ff d0                	call   rax
  41ca10:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
  41ca14:	4c 8b 44 24 68       	mov    r8,QWORD PTR [rsp+0x68]
  41ca19:	83 e0 20             	and    eax,0x20
  41ca1c:	85 c0                	test   eax,eax
  41ca1e:	0f 84 1f 0a 00 00    	je     41d443 <printf_core+0x11d3>
		pad(f, '0', w, pl+p, fl^ZERO_PAD);
  41ca24:	44 89 e0             	mov    eax,r12d
  41ca27:	35 00 00 01 00       	xor    eax,0x10000
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41ca2c:	a9 00 20 01 00       	test   eax,0x12000
  41ca31:	0f 85 d1 00 00 00    	jne    41cb08 <printf_core+0x898>
  41ca37:	80 7c 24 38 00       	cmp    BYTE PTR [rsp+0x38],0x0
  41ca3c:	0f 85 c6 00 00 00    	jne    41cb08 <printf_core+0x898>
	l = w - l;
  41ca42:	8b 4c 24 08          	mov    ecx,DWORD PTR [rsp+0x8]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41ca46:	b8 00 01 00 00       	mov    eax,0x100
	l = w - l;
  41ca4b:	2b 4c 24 5c          	sub    ecx,DWORD PTR [rsp+0x5c]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41ca4f:	4c 8d b4 24 d0 00 00 	lea    r14,[rsp+0xd0]
  41ca56:	00 
  41ca57:	39 c1                	cmp    ecx,eax
  41ca59:	4c 8b 7c 24 18       	mov    r15,QWORD PTR [rsp+0x18]
  41ca5e:	4c 89 44 24 68       	mov    QWORD PTR [rsp+0x68],r8
  41ca63:	4c 89 f7             	mov    rdi,r14
  41ca66:	0f 4e c1             	cmovle eax,ecx
  41ca69:	89 4c 24 60          	mov    DWORD PTR [rsp+0x60],ecx
  41ca6d:	be 30 00 00 00       	mov    esi,0x30
  41ca72:	48 63 d0             	movsxd rdx,eax
  41ca75:	48 b8 3c 64 fb ff ff 	movabs rax,0xfffffffffffb643c
  41ca7c:	ff ff ff 
  41ca7f:	4c 01 f8             	add    rax,r15
  41ca82:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  41ca84:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  41ca88:	4c 8b 44 24 68       	mov    r8,QWORD PTR [rsp+0x68]
  41ca8d:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  41ca93:	0f 8e 60 0c 00 00    	jle    41d6f9 <printf_core+0x1489>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41ca99:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
  41ca9d:	44 8d b9 00 ff ff ff 	lea    r15d,[rcx-0x100]
  41caa4:	83 e0 20             	and    eax,0x20
  41caa7:	0f 84 a3 08 00 00    	je     41d350 <printf_core+0x10e0>
	for (; l >= sizeof pad; l -= sizeof pad)
  41caad:	41 81 ff ff 00 00 00 	cmp    r15d,0xff
  41cab4:	7e 52                	jle    41cb08 <printf_core+0x898>
  41cab6:	41 8d 97 00 e9 ff ff 	lea    edx,[r15-0x1700]
  41cabd:	81 fa 00 e9 ff 7f    	cmp    edx,0x7fffe900
  41cac3:	0f 86 e7 f6 ff ff    	jbe    41c1b0 <printf_core.cold+0x3c5>
  41cac9:	41 81 ef 00 01 00 00 	sub    r15d,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41cad0:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  41cad2:	44 89 f9             	mov    ecx,r15d
  41cad5:	41 81 ff ff 00 00 00 	cmp    r15d,0xff
  41cadc:	77 eb                	ja     41cac9 <printf_core+0x859>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41cade:	85 d2                	test   edx,edx
  41cae0:	75 26                	jne    41cb08 <printf_core+0x898>
  41cae2:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
	out(f, pad, l);
  41cae7:	48 63 f1             	movsxd rsi,ecx
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41caea:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  41caef:	4c 89 ea             	mov    rdx,r13
  41caf2:	4c 89 44 24 60       	mov    QWORD PTR [rsp+0x60],r8
  41caf7:	4c 89 f7             	mov    rdi,r14
  41cafa:	48 01 c8             	add    rax,rcx
  41cafd:	ff d0                	call   rax
  41caff:	4c 8b 44 24 60       	mov    r8,QWORD PTR [rsp+0x60]
  41cb04:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41cb08:	39 6c 24 50          	cmp    DWORD PTR [rsp+0x50],ebp
  41cb0c:	0f 8d 5c 09 00 00    	jge    41d46e <printf_core+0x11fe>
	l = w - l;
  41cb12:	2b 6c 24 50          	sub    ebp,DWORD PTR [rsp+0x50]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41cb16:	b8 00 01 00 00       	mov    eax,0x100
  41cb1b:	4c 8b 7c 24 18       	mov    r15,QWORD PTR [rsp+0x18]
  41cb20:	4c 8d b4 24 d0 00 00 	lea    r14,[rsp+0xd0]
  41cb27:	00 
  41cb28:	39 c5                	cmp    ebp,eax
  41cb2a:	4c 89 44 24 60       	mov    QWORD PTR [rsp+0x60],r8
  41cb2f:	be 30 00 00 00       	mov    esi,0x30
  41cb34:	4c 89 f7             	mov    rdi,r14
  41cb37:	0f 4e c5             	cmovle eax,ebp
  41cb3a:	48 63 d0             	movsxd rdx,eax
  41cb3d:	48 b8 3c 64 fb ff ff 	movabs rax,0xfffffffffffb643c
  41cb44:	ff ff ff 
  41cb47:	4c 01 f8             	add    rax,r15
  41cb4a:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  41cb4c:	81 fd ff 00 00 00    	cmp    ebp,0xff
  41cb52:	4c 8b 44 24 60       	mov    r8,QWORD PTR [rsp+0x60]
  41cb57:	0f 8e 83 0b 00 00    	jle    41d6e0 <printf_core+0x1470>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41cb5d:	41 8b 55 00          	mov    edx,DWORD PTR [r13+0x0]
  41cb61:	44 8d bd 00 ff ff ff 	lea    r15d,[rbp-0x100]
  41cb68:	4c 89 c5             	mov    rbp,r8
  41cb6b:	89 d0                	mov    eax,edx
  41cb6d:	83 e0 20             	and    eax,0x20
  41cb70:	0f 84 9a 07 00 00    	je     41d310 <printf_core+0x10a0>
	for (; l >= sizeof pad; l -= sizeof pad)
  41cb76:	49 89 e8             	mov    r8,rbp
  41cb79:	41 81 ff ff 00 00 00 	cmp    r15d,0xff
  41cb80:	0f 8e ef 08 00 00    	jle    41d475 <printf_core+0x1205>
  41cb86:	41 8d 97 00 e9 ff ff 	lea    edx,[r15-0x1700]
  41cb8d:	81 fa 00 e9 ff 7f    	cmp    edx,0x7fffe900
  41cb93:	0f 86 a6 f4 ff ff    	jbe    41c03f <printf_core.cold+0x254>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41cb99:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  41cb9b:	41 81 ef 00 01 00 00 	sub    r15d,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41cba2:	89 d0                	mov    eax,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  41cba4:	44 89 fd             	mov    ebp,r15d
  41cba7:	41 81 ff ff 00 00 00 	cmp    r15d,0xff
  41cbae:	77 eb                	ja     41cb9b <printf_core+0x92b>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41cbb0:	85 c0                	test   eax,eax
  41cbb2:	0f 84 71 0a 00 00    	je     41d629 <printf_core+0x13b9>
		pad(f, ' ', w, pl+p, fl^LEFT_ADJ);
  41cbb8:	41 81 f4 00 20 00 00 	xor    r12d,0x2000
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41cbbf:	41 81 e4 00 20 01 00 	and    r12d,0x12000
  41cbc6:	0f 85 a6 f7 ff ff    	jne    41c372 <printf_core+0x102>
  41cbcc:	80 7c 24 38 00       	cmp    BYTE PTR [rsp+0x38],0x0
  41cbd1:	0f 85 9b f7 ff ff    	jne    41c372 <printf_core+0x102>
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41cbd7:	b8 00 01 00 00       	mov    eax,0x100
	l = w - l;
  41cbdc:	44 8b 64 24 08       	mov    r12d,DWORD PTR [rsp+0x8]
  41cbe1:	44 2b 64 24 5c       	sub    r12d,DWORD PTR [rsp+0x5c]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41cbe6:	4c 8d b4 24 d0 00 00 	lea    r14,[rsp+0xd0]
  41cbed:	00 
  41cbee:	41 39 c4             	cmp    r12d,eax
  41cbf1:	4c 8b 7c 24 18       	mov    r15,QWORD PTR [rsp+0x18]
  41cbf6:	be 20 00 00 00       	mov    esi,0x20
  41cbfb:	4c 89 f7             	mov    rdi,r14
  41cbfe:	41 0f 4e c4          	cmovle eax,r12d
  41cc02:	48 63 d0             	movsxd rdx,eax
  41cc05:	48 b8 3c 64 fb ff ff 	movabs rax,0xfffffffffffb643c
  41cc0c:	ff ff ff 
  41cc0f:	4c 01 f8             	add    rax,r15
  41cc12:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  41cc14:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  41cc1b:	0f 8e f0 0a 00 00    	jle    41d711 <printf_core+0x14a1>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41cc21:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
  41cc25:	41 8d ac 24 00 ff ff 	lea    ebp,[r12-0x100]
  41cc2c:	ff 
  41cc2d:	0f 1f 00             	nop    DWORD PTR [rax]
  41cc30:	83 e0 20             	and    eax,0x20
  41cc33:	0f 84 67 07 00 00    	je     41d3a0 <printf_core+0x1130>
	for (; l >= sizeof pad; l -= sizeof pad)
  41cc39:	81 fd ff 00 00 00    	cmp    ebp,0xff
  41cc3f:	0f 8e 2d f7 ff ff    	jle    41c372 <printf_core+0x102>
  41cc45:	8d 95 00 e9 ff ff    	lea    edx,[rbp-0x1700]
  41cc4b:	81 fa 00 e9 ff 7f    	cmp    edx,0x7fffe900
  41cc51:	0f 86 9f f4 ff ff    	jbe    41c0f6 <printf_core.cold+0x30b>
  41cc57:	81 ed 00 01 00 00    	sub    ebp,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41cc5d:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  41cc5f:	41 89 ec             	mov    r12d,ebp
  41cc62:	81 fd ff 00 00 00    	cmp    ebp,0xff
  41cc68:	77 ed                	ja     41cc57 <printf_core+0x9e7>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41cc6a:	85 d2                	test   edx,edx
  41cc6c:	0f 85 00 f7 ff ff    	jne    41c372 <printf_core+0x102>
  41cc72:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  41cc77:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
	out(f, pad, l);
  41cc7c:	49 63 f4             	movsxd rsi,r12d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41cc7f:	4c 89 ea             	mov    rdx,r13
  41cc82:	4c 89 f7             	mov    rdi,r14
  41cc85:	48 01 c8             	add    rax,rcx
  41cc88:	ff d0                	call   rax
  41cc8a:	e9 e3 f6 ff ff       	jmp    41c372 <printf_core+0x102>
			if (xp && p<0) goto overflow;
  41cc8f:	85 ed                	test   ebp,ebp
  41cc91:	79 0a                	jns    41cc9d <printf_core+0xa2d>
  41cc93:	41 83 e2 01          	and    r10d,0x1
  41cc97:	0f 85 0c fa ff ff    	jne    41c6a9 <printf_core+0x439>
  41cc9d:	44 89 5c 24 38       	mov    DWORD PTR [rsp+0x38],r11d
			l = fmt_fp(f, arg.f, w, p, fl, t);
  41cca2:	41 89 d0             	mov    r8d,edx
  41cca5:	44 89 e1             	mov    ecx,r12d
  41cca8:	89 ea                	mov    edx,ebp
  41ccaa:	ff b4 24 98 00 00 00 	push   QWORD PTR [rsp+0x98]
  41ccb1:	44 89 ce             	mov    esi,r9d
  41ccb4:	4c 89 ef             	mov    rdi,r13
  41ccb7:	48 b8 b0 80 fb ff ff 	movabs rax,0xfffffffffffb80b0
  41ccbe:	ff ff ff 
  41ccc1:	ff b4 24 98 00 00 00 	push   QWORD PTR [rsp+0x98]
  41ccc8:	4c 8b 54 24 28       	mov    r10,QWORD PTR [rsp+0x28]
  41cccd:	4c 01 d0             	add    rax,r10
  41ccd0:	ff d0                	call   rax
			if (l<0) goto overflow;
  41ccd2:	85 c0                	test   eax,eax
			l = fmt_fp(f, arg.f, w, p, fl, t);
  41ccd4:	89 44 24 18          	mov    DWORD PTR [rsp+0x18],eax
			if (l<0) goto overflow;
  41ccd8:	41 5e                	pop    r14
  41ccda:	41 5f                	pop    r15
  41ccdc:	44 8b 5c 24 38       	mov    r11d,DWORD PTR [rsp+0x38]
  41cce1:	0f 89 80 f6 ff ff    	jns    41c367 <printf_core+0xf7>
  41cce7:	e9 bd f9 ff ff       	jmp    41c6a9 <printf_core+0x439>
  41ccec:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
			if (arg.i>INTMAX_MAX) {
  41ccf0:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  41ccf7:	00 
  41ccf8:	48 85 c9             	test   rcx,rcx
  41ccfb:	0f 88 1c 0a 00 00    	js     41d71d <printf_core+0x14ad>
			} else if (fl & MARK_POS) {
  41cd01:	41 f7 c4 00 08 00 00 	test   r12d,0x800
  41cd08:	0f 85 3e 0a 00 00    	jne    41d74c <printf_core+0x14dc>
			} else if (fl & PAD_POS) {
  41cd0e:	41 f6 c4 01          	test   r12b,0x1
  41cd12:	0f 85 c0 0b 00 00    	jne    41d8d8 <printf_core+0x1668>
		prefix = "-+   0X0x";
  41cd18:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
			} else pl=0;
  41cd1d:	44 89 74 24 60       	mov    DWORD PTR [rsp+0x60],r14d
		prefix = "-+   0X0x";
  41cd22:	48 b8 35 09 fc ff ff 	movabs rax,0xfffffffffffc0935
  41cd29:	ff ff ff 
  41cd2c:	48 01 d0             	add    rax,rdx
  41cd2f:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  41cd34:	48 85 c9             	test   rcx,rcx
  41cd37:	0f 84 b5 0a 00 00    	je     41d7f2 <printf_core+0x1582>
		prefix = "-+   0X0x";
  41cd3d:	4c 8d bc 24 cb 00 00 	lea    r15,[rsp+0xcb]
  41cd44:	00 
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  41cd45:	48 be cd cc cc cc cc 	movabs rsi,0xcccccccccccccccd
  41cd4c:	cc cc cc 
		prefix = "-+   0X0x";
  41cd4f:	4d 89 f8             	mov    r8,r15
  41cd52:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  41cd58:	48 89 c8             	mov    rax,rcx
  41cd5b:	49 83 e8 01          	sub    r8,0x1
  41cd5f:	48 f7 e6             	mul    rsi
  41cd62:	48 89 c8             	mov    rax,rcx
  41cd65:	48 c1 ea 03          	shr    rdx,0x3
  41cd69:	48 8d 3c 92          	lea    rdi,[rdx+rdx*4]
  41cd6d:	48 01 ff             	add    rdi,rdi
  41cd70:	48 29 f8             	sub    rax,rdi
  41cd73:	83 c0 30             	add    eax,0x30
  41cd76:	41 88 00             	mov    BYTE PTR [r8],al
  41cd79:	48 89 c8             	mov    rax,rcx
  41cd7c:	48 89 d1             	mov    rcx,rdx
  41cd7f:	48 83 f8 09          	cmp    rax,0x9
  41cd83:	77 d3                	ja     41cd58 <printf_core+0xae8>
			if (xp && p<0) goto overflow;
  41cd85:	85 ed                	test   ebp,ebp
  41cd87:	79 0a                	jns    41cd93 <printf_core+0xb23>
  41cd89:	41 f6 c2 01          	test   r10b,0x1
  41cd8d:	0f 85 16 f9 ff ff    	jne    41c6a9 <printf_core+0x439>
			if (xp) fl &= ~ZERO_PAD;
  41cd93:	44 89 e0             	mov    eax,r12d
  41cd96:	25 ff ff fe ff       	and    eax,0xfffeffff
  41cd9b:	45 85 d2             	test   r10d,r10d
  41cd9e:	44 0f 45 e0          	cmovne r12d,eax
			if (!arg.i && !p) {
  41cda2:	48 83 bc 24 90 00 00 	cmp    QWORD PTR [rsp+0x90],0x0
  41cda9:	00 00 
  41cdab:	0f 94 c0             	sete   al
  41cdae:	85 ed                	test   ebp,ebp
  41cdb0:	75 08                	jne    41cdba <printf_core+0xb4a>
  41cdb2:	84 c0                	test   al,al
  41cdb4:	0f 85 9d 08 00 00    	jne    41d657 <printf_core+0x13e7>
			p = MAX(p, z-a + !arg.i);
  41cdba:	4c 89 ff             	mov    rdi,r15
  41cdbd:	0f b6 c0             	movzx  eax,al
  41cdc0:	48 63 ed             	movsxd rbp,ebp
		if (p > INT_MAX-pl) goto overflow;
  41cdc3:	ba ff ff ff 7f       	mov    edx,0x7fffffff
			p = MAX(p, z-a + !arg.i);
  41cdc8:	4c 29 c7             	sub    rdi,r8
  41cdcb:	48 01 f8             	add    rax,rdi
  41cdce:	48 89 7c 24 50       	mov    QWORD PTR [rsp+0x50],rdi
  41cdd3:	48 39 e8             	cmp    rax,rbp
  41cdd6:	48 0f 4c c5          	cmovl  rax,rbp
		if (p > INT_MAX-pl) goto overflow;
  41cdda:	2b 54 24 60          	sub    edx,DWORD PTR [rsp+0x60]
			p = MAX(p, z-a + !arg.i);
  41cdde:	89 c5                	mov    ebp,eax
		if (p < z-a) p = z-a;
  41cde0:	48 98                	cdqe   
  41cde2:	48 39 c7             	cmp    rdi,rax
  41cde5:	0f 8f 14 fb ff ff    	jg     41c8ff <printf_core+0x68f>
  41cdeb:	e9 13 fb ff ff       	jmp    41c903 <printf_core+0x693>
			a = fmt_x(arg.i, z, t&32);
  41cdf0:	89 d7                	mov    edi,edx
  41cdf2:	83 e7 20             	and    edi,0x20
  41cdf5:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  41cdfc:	00 
	for (; x; x>>=4) *--s = xdigits[(x&15)]|lower;
  41cdfd:	48 85 c0             	test   rax,rax
  41ce00:	0f 84 c0 09 00 00    	je     41d7c6 <printf_core+0x1556>
  41ce06:	89 54 24 38          	mov    DWORD PTR [rsp+0x38],edx
  41ce0a:	4c 8d bc 24 cb 00 00 	lea    r15,[rsp+0xcb]
  41ce11:	00 
  41ce12:	48 be 50 0b fc ff ff 	movabs rsi,0xfffffffffffc0b50
  41ce19:	ff ff ff 
  41ce1c:	48 03 74 24 18       	add    rsi,QWORD PTR [rsp+0x18]
  41ce21:	4d 89 f8             	mov    r8,r15
  41ce24:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  41ce28:	48 89 c1             	mov    rcx,rax
  41ce2b:	49 83 e8 01          	sub    r8,0x1
  41ce2f:	83 e1 0f             	and    ecx,0xf
  41ce32:	0f b6 14 0e          	movzx  edx,BYTE PTR [rsi+rcx*1]
  41ce36:	09 fa                	or     edx,edi
  41ce38:	48 c1 e8 04          	shr    rax,0x4
  41ce3c:	41 88 10             	mov    BYTE PTR [r8],dl
  41ce3f:	75 e7                	jne    41ce28 <printf_core+0xbb8>
  41ce41:	8b 54 24 38          	mov    edx,DWORD PTR [rsp+0x38]
			if (arg.i && (fl & ALT_FORM)) prefix+=(t>>4), pl=2;
  41ce45:	41 f6 c4 08          	test   r12b,0x8
  41ce49:	0f 84 d5 00 00 00    	je     41cf24 <printf_core+0xcb4>
  41ce4f:	89 d0                	mov    eax,edx
  41ce51:	48 8b 7c 24 18       	mov    rdi,QWORD PTR [rsp+0x18]
  41ce56:	c7 44 24 60 02 00 00 	mov    DWORD PTR [rsp+0x60],0x2
  41ce5d:	00 
  41ce5e:	48 ba 35 09 fc ff ff 	movabs rdx,0xfffffffffffc0935
  41ce65:	ff ff ff 
  41ce68:	c1 f8 04             	sar    eax,0x4
  41ce6b:	48 98                	cdqe   
  41ce6d:	48 01 fa             	add    rdx,rdi
  41ce70:	48 01 d0             	add    rax,rdx
  41ce73:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  41ce78:	e9 08 ff ff ff       	jmp    41cd85 <printf_core+0xb15>
		prefix = "-+   0X0x";
  41ce7d:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
			*(a=z-(p=1))=arg.i;
  41ce82:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  41ce89:	00 
		prefix = "-+   0X0x";
  41ce8a:	48 b8 35 09 fc ff ff 	movabs rax,0xfffffffffffc0935
  41ce91:	ff ff ff 
		pl = 0;
  41ce94:	44 89 74 24 60       	mov    DWORD PTR [rsp+0x60],r14d
			break;
  41ce99:	c7 44 24 5c 01 00 00 	mov    DWORD PTR [rsp+0x5c],0x1
  41cea0:	00 
			fl &= ~ZERO_PAD;
  41cea1:	41 81 e4 ff ff fe ff 	and    r12d,0xfffeffff
			*(a=z-(p=1))=arg.i;
  41cea8:	4c 8d 84 24 ca 00 00 	lea    r8,[rsp+0xca]
  41ceaf:	00 
		prefix = "-+   0X0x";
  41ceb0:	48 01 d0             	add    rax,rdx
			*(a=z-(p=1))=arg.i;
  41ceb3:	88 8c 24 ca 00 00 00 	mov    BYTE PTR [rsp+0xca],cl
			break;
  41ceba:	48 c7 44 24 50 01 00 	mov    QWORD PTR [rsp+0x50],0x1
  41cec1:	00 00 
		prefix = "-+   0X0x";
  41cec3:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
			*(a=z-(p=1))=arg.i;
  41cec8:	c7 44 24 08 01 00 00 	mov    DWORD PTR [rsp+0x8],0x1
  41cecf:	00 
		if (p < z-a) p = z-a;
  41ced0:	8b 6c 24 08          	mov    ebp,DWORD PTR [rsp+0x8]
  41ced4:	e9 3c fa ff ff       	jmp    41c915 <printf_core+0x6a5>
			a = fmt_o(arg.i, z);
  41ced9:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  41cee0:	00 
	for (; x; x>>=3) *--s = '0' + (x&7);
  41cee1:	4c 8d bc 24 cb 00 00 	lea    r15,[rsp+0xcb]
  41cee8:	00 
  41cee9:	4d 89 f8             	mov    r8,r15
  41ceec:	48 85 c0             	test   rax,rax
  41ceef:	74 1c                	je     41cf0d <printf_core+0xc9d>
  41cef1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  41cef8:	89 c2                	mov    edx,eax
  41cefa:	49 83 e8 01          	sub    r8,0x1
  41cefe:	83 e2 07             	and    edx,0x7
  41cf01:	83 c2 30             	add    edx,0x30
  41cf04:	48 c1 e8 03          	shr    rax,0x3
  41cf08:	41 88 10             	mov    BYTE PTR [r8],dl
  41cf0b:	75 eb                	jne    41cef8 <printf_core+0xc88>
			if ((fl&ALT_FORM) && p<z-a+1) p=z-a+1;
  41cf0d:	41 f6 c4 08          	test   r12b,0x8
  41cf11:	74 11                	je     41cf24 <printf_core+0xcb4>
  41cf13:	4c 89 f8             	mov    rax,r15
  41cf16:	48 63 d5             	movsxd rdx,ebp
  41cf19:	4c 29 c0             	sub    rax,r8
  41cf1c:	48 39 d0             	cmp    rax,rdx
  41cf1f:	7c 03                	jl     41cf24 <printf_core+0xcb4>
  41cf21:	8d 68 01             	lea    ebp,[rax+0x1]
		prefix = "-+   0X0x";
  41cf24:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
		pl = 0;
  41cf29:	44 89 74 24 60       	mov    DWORD PTR [rsp+0x60],r14d
		prefix = "-+   0X0x";
  41cf2e:	48 b8 35 09 fc ff ff 	movabs rax,0xfffffffffffc0935
  41cf35:	ff ff ff 
  41cf38:	48 01 d0             	add    rax,rdx
  41cf3b:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  41cf40:	e9 40 fe ff ff       	jmp    41cd85 <printf_core+0xb15>
			p = MAX(p, 2*sizeof(void*));
  41cf45:	b8 10 00 00 00       	mov    eax,0x10
			fl |= ALT_FORM;
  41cf4a:	bf 20 00 00 00       	mov    edi,0x20
			t = 'x';
  41cf4f:	ba 78 00 00 00       	mov    edx,0x78
			p = MAX(p, 2*sizeof(void*));
  41cf54:	39 c5                	cmp    ebp,eax
  41cf56:	0f 42 e8             	cmovb  ebp,eax
			fl |= ALT_FORM;
  41cf59:	41 83 cc 08          	or     r12d,0x8
  41cf5d:	e9 93 fe ff ff       	jmp    41cdf5 <printf_core+0xb85>
			a = arg.p ? arg.p : "(null)";
  41cf62:	4c 8b 84 24 90 00 00 	mov    r8,QWORD PTR [rsp+0x90]
  41cf69:	00 
  41cf6a:	4d 85 c0             	test   r8,r8
  41cf6d:	0f 84 0a 08 00 00    	je     41d77d <printf_core+0x150d>
			z = a + strnlen(a, p<0 ? INT_MAX : p);
  41cf73:	85 ed                	test   ebp,ebp
  41cf75:	0f 88 11 07 00 00    	js     41d68c <printf_core+0x141c>
  41cf7b:	4c 8b 7c 24 18       	mov    r15,QWORD PTR [rsp+0x18]
  41cf80:	44 89 4c 24 50       	mov    DWORD PTR [rsp+0x50],r9d
  41cf85:	48 63 f5             	movsxd rsi,ebp
  41cf88:	4c 89 c7             	mov    rdi,r8
  41cf8b:	48 b8 80 71 fb ff ff 	movabs rax,0xfffffffffffb7180
  41cf92:	ff ff ff 
  41cf95:	44 89 5c 24 38       	mov    DWORD PTR [rsp+0x38],r11d
  41cf9a:	4c 89 44 24 08       	mov    QWORD PTR [rsp+0x8],r8
  41cf9f:	4c 01 f8             	add    rax,r15
  41cfa2:	ff d0                	call   rax
  41cfa4:	4c 8b 44 24 08       	mov    r8,QWORD PTR [rsp+0x8]
  41cfa9:	44 8b 5c 24 38       	mov    r11d,DWORD PTR [rsp+0x38]
  41cfae:	44 8b 4c 24 50       	mov    r9d,DWORD PTR [rsp+0x50]
  41cfb3:	48 89 c5             	mov    rbp,rax
  41cfb6:	49 8d 04 00          	lea    rax,[r8+rax*1]
		if (p < z-a) p = z-a;
  41cfba:	4c 29 c0             	sub    rax,r8
			fl &= ~ZERO_PAD;
  41cfbd:	41 81 e4 ff ff fe ff 	and    r12d,0xfffeffff
		if (p < z-a) p = z-a;
  41cfc4:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
			break;
  41cfc9:	e9 02 f9 ff ff       	jmp    41c8d0 <printf_core+0x660>
			ws = arg.p;
  41cfce:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  41cfd5:	00 
  41cfd6:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
			for (i=l=0; i<p && *ws && (l=wctomb(mb, *ws++))>=0 && l<=p-i; i+=l);
  41cfdb:	48 63 c5             	movsxd rax,ebp
  41cfde:	48 89 c2             	mov    rdx,rax
  41cfe1:	48 85 c0             	test   rax,rax
  41cfe4:	0f 84 1e 09 00 00    	je     41d908 <printf_core+0x1698>
  41cfea:	4c 8b 74 24 50       	mov    r14,QWORD PTR [rsp+0x50]
  41cfef:	31 ed                	xor    ebp,ebp
  41cff1:	48 89 5c 24 38       	mov    QWORD PTR [rsp+0x38],rbx
  41cff6:	48 8d 84 24 84 00 00 	lea    rax,[rsp+0x84]
  41cffd:	00 
  41cffe:	44 89 64 24 5c       	mov    DWORD PTR [rsp+0x5c],r12d
  41d003:	48 89 d3             	mov    rbx,rdx
  41d006:	4d 89 f4             	mov    r12,r14
  41d009:	44 89 5c 24 08       	mov    DWORD PTR [rsp+0x8],r11d
  41d00e:	4d 89 ee             	mov    r14,r13
  41d011:	49 89 ed             	mov    r13,rbp
  41d014:	44 89 4c 24 60       	mov    DWORD PTR [rsp+0x60],r9d
  41d019:	48 89 c5             	mov    rbp,rax
  41d01c:	eb 3a                	jmp    41d058 <printf_core+0xde8>
  41d01e:	66 90                	xchg   ax,ax
  41d020:	4c 8b 7c 24 18       	mov    r15,QWORD PTR [rsp+0x18]
  41d025:	49 83 c4 04          	add    r12,0x4
  41d029:	48 89 ef             	mov    rdi,rbp
  41d02c:	48 b8 a0 cb fb ff ff 	movabs rax,0xfffffffffffbcba0
  41d033:	ff ff ff 
  41d036:	4c 01 f8             	add    rax,r15
  41d039:	ff d0                	call   rax
  41d03b:	85 c0                	test   eax,eax
  41d03d:	0f 88 a9 06 00 00    	js     41d6ec <printf_core+0x147c>
  41d043:	48 89 de             	mov    rsi,rbx
  41d046:	48 98                	cdqe   
  41d048:	4c 29 ee             	sub    rsi,r13
  41d04b:	48 39 f0             	cmp    rax,rsi
  41d04e:	77 10                	ja     41d060 <printf_core+0xdf0>
  41d050:	49 01 c5             	add    r13,rax
  41d053:	49 39 dd             	cmp    r13,rbx
  41d056:	73 08                	jae    41d060 <printf_core+0xdf0>
  41d058:	41 8b 34 24          	mov    esi,DWORD PTR [r12]
  41d05c:	85 f6                	test   esi,esi
  41d05e:	75 c0                	jne    41d020 <printf_core+0xdb0>
  41d060:	4c 89 ed             	mov    rbp,r13
  41d063:	44 8b 5c 24 08       	mov    r11d,DWORD PTR [rsp+0x8]
  41d068:	48 8b 5c 24 38       	mov    rbx,QWORD PTR [rsp+0x38]
  41d06d:	4d 89 f5             	mov    r13,r14
			if (i > INT_MAX) goto overflow;
  41d070:	44 8b 64 24 5c       	mov    r12d,DWORD PTR [rsp+0x5c]
  41d075:	44 8b 4c 24 60       	mov    r9d,DWORD PTR [rsp+0x60]
  41d07a:	48 81 fd ff ff ff 7f 	cmp    rbp,0x7fffffff
  41d081:	0f 87 22 f6 ff ff    	ja     41c6a9 <printf_core+0x439>
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41d087:	41 39 e9             	cmp    r9d,ebp
			p = i;
  41d08a:	89 6c 24 08          	mov    DWORD PTR [rsp+0x8],ebp
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41d08e:	0f 9e 44 24 38       	setle  BYTE PTR [rsp+0x38]
  41d093:	0f b6 44 24 38       	movzx  eax,BYTE PTR [rsp+0x38]
  41d098:	41 f7 c4 00 20 01 00 	test   r12d,0x12000
  41d09f:	0f 85 c0 00 00 00    	jne    41d165 <printf_core+0xef5>
  41d0a5:	84 c0                	test   al,al
  41d0a7:	0f 85 b8 00 00 00    	jne    41d165 <printf_core+0xef5>
	l = w - l;
  41d0ad:	44 89 c9             	mov    ecx,r9d
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41d0b0:	b8 00 01 00 00       	mov    eax,0x100
	l = w - l;
  41d0b5:	2b 4c 24 08          	sub    ecx,DWORD PTR [rsp+0x8]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41d0b9:	4c 8b 7c 24 18       	mov    r15,QWORD PTR [rsp+0x18]
  41d0be:	39 c1                	cmp    ecx,eax
  41d0c0:	44 89 5c 24 60       	mov    DWORD PTR [rsp+0x60],r11d
  41d0c5:	be 20 00 00 00       	mov    esi,0x20
  41d0ca:	4c 8d b4 24 d0 00 00 	lea    r14,[rsp+0xd0]
  41d0d1:	00 
  41d0d2:	0f 4e c1             	cmovle eax,ecx
	l = w - l;
  41d0d5:	44 89 4c 24 5c       	mov    DWORD PTR [rsp+0x5c],r9d
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41d0da:	4c 89 f7             	mov    rdi,r14
  41d0dd:	89 4c 24 38          	mov    DWORD PTR [rsp+0x38],ecx
  41d0e1:	48 63 d0             	movsxd rdx,eax
  41d0e4:	48 b8 3c 64 fb ff ff 	movabs rax,0xfffffffffffb643c
  41d0eb:	ff ff ff 
  41d0ee:	4c 01 f8             	add    rax,r15
  41d0f1:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  41d0f3:	8b 4c 24 38          	mov    ecx,DWORD PTR [rsp+0x38]
  41d0f7:	44 8b 4c 24 5c       	mov    r9d,DWORD PTR [rsp+0x5c]
  41d0fc:	44 8b 5c 24 60       	mov    r11d,DWORD PTR [rsp+0x60]
  41d101:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  41d107:	0f 8e ef 07 00 00    	jle    41d8fc <printf_core+0x168c>
  41d10d:	44 8d 81 00 ff ff ff 	lea    r8d,[rcx-0x100]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41d114:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
  41d118:	45 89 c7             	mov    r15d,r8d
  41d11b:	83 e0 20             	and    eax,0x20
  41d11e:	0f 84 78 03 00 00    	je     41d49c <printf_core+0x122c>
	for (; l >= sizeof pad; l -= sizeof pad)
  41d124:	45 89 f8             	mov    r8d,r15d
  41d127:	41 81 ff ff 00 00 00 	cmp    r15d,0xff
  41d12e:	7e 30                	jle    41d160 <printf_core+0xef0>
  41d130:	41 8d 90 00 e9 ff ff 	lea    edx,[r8-0x1700]
  41d137:	81 fa 00 e9 ff 7f    	cmp    edx,0x7fffe900
  41d13d:	0f 86 43 ee ff ff    	jbe    41bf86 <printf_core.cold+0x19b>
  41d143:	41 81 e8 00 01 00 00 	sub    r8d,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41d14a:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  41d14c:	44 89 c1             	mov    ecx,r8d
  41d14f:	41 81 f8 ff 00 00 00 	cmp    r8d,0xff
  41d156:	77 eb                	ja     41d143 <printf_core+0xed3>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41d158:	85 d2                	test   edx,edx
  41d15a:	0f 84 35 06 00 00    	je     41d795 <printf_core+0x1525>
  41d160:	c6 44 24 38 00       	mov    BYTE PTR [rsp+0x38],0x0
			for (i=0; i<0U+p && *ws && i+(l=wctomb(mb, *ws++))<=p; i+=l)
  41d165:	45 31 f6             	xor    r14d,r14d
  41d168:	48 85 ed             	test   rbp,rbp
  41d16b:	0f 84 92 03 00 00    	je     41d503 <printf_core+0x1293>
  41d171:	48 89 5c 24 60       	mov    QWORD PTR [rsp+0x60],rbx
  41d176:	4c 89 f3             	mov    rbx,r14
  41d179:	49 89 ee             	mov    r14,rbp
  41d17c:	48 8b 6c 24 50       	mov    rbp,QWORD PTR [rsp+0x50]
  41d181:	44 89 5c 24 5c       	mov    DWORD PTR [rsp+0x5c],r11d
  41d186:	44 89 64 24 68       	mov    DWORD PTR [rsp+0x68],r12d
  41d18b:	44 89 4c 24 50       	mov    DWORD PTR [rsp+0x50],r9d
  41d190:	eb 0f                	jmp    41d1a1 <printf_core+0xf31>
  41d192:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  41d198:	4c 39 f3             	cmp    rbx,r14
  41d19b:	0f 83 4e 03 00 00    	jae    41d4ef <printf_core+0x127f>
  41d1a1:	8b 75 00             	mov    esi,DWORD PTR [rbp+0x0]
  41d1a4:	85 f6                	test   esi,esi
  41d1a6:	0f 84 43 03 00 00    	je     41d4ef <printf_core+0x127f>
  41d1ac:	4c 8b 7c 24 18       	mov    r15,QWORD PTR [rsp+0x18]
  41d1b1:	4c 8d a4 24 84 00 00 	lea    r12,[rsp+0x84]
  41d1b8:	00 
  41d1b9:	48 83 c5 04          	add    rbp,0x4
  41d1bd:	48 b8 a0 cb fb ff ff 	movabs rax,0xfffffffffffbcba0
  41d1c4:	ff ff ff 
  41d1c7:	4c 89 e7             	mov    rdi,r12
  41d1ca:	4c 01 f8             	add    rax,r15
  41d1cd:	ff d0                	call   rax
  41d1cf:	48 63 f0             	movsxd rsi,eax
  41d1d2:	48 01 f3             	add    rbx,rsi
  41d1d5:	4c 39 f3             	cmp    rbx,r14
  41d1d8:	0f 87 11 03 00 00    	ja     41d4ef <printf_core+0x127f>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41d1de:	41 f6 45 00 20       	test   BYTE PTR [r13+0x0],0x20
  41d1e3:	75 b3                	jne    41d198 <printf_core+0xf28>
  41d1e5:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  41d1ea:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  41d1ef:	4c 89 ea             	mov    rdx,r13
  41d1f2:	4c 89 e7             	mov    rdi,r12
  41d1f5:	48 01 c8             	add    rax,rcx
  41d1f8:	ff d0                	call   rax
  41d1fa:	eb 9c                	jmp    41d198 <printf_core+0xf28>
			wc[0] = arg.i;
  41d1fc:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  41d203:	00 
			for (i=l=0; i<p && *ws && (l=wctomb(mb, *ws++))>=0 && l<=p-i; i+=l);
  41d204:	48 c7 c2 ff ff ff ff 	mov    rdx,0xffffffffffffffff
			wc[1] = 0;
  41d20b:	c7 84 24 8c 00 00 00 	mov    DWORD PTR [rsp+0x8c],0x0
  41d212:	00 00 00 00 
			wc[0] = arg.i;
  41d216:	89 84 24 88 00 00 00 	mov    DWORD PTR [rsp+0x88],eax
			arg.p = wc;
  41d21d:	48 8d 84 24 88 00 00 	lea    rax,[rsp+0x88]
  41d224:	00 
  41d225:	48 89 84 24 90 00 00 	mov    QWORD PTR [rsp+0x90],rax
  41d22c:	00 
			ws = arg.p;
  41d22d:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
  41d232:	e9 b3 fd ff ff       	jmp    41cfea <printf_core+0xd7a>
			if (1) a = strerror(errno); else
  41d237:	4c 8b 7c 24 18       	mov    r15,QWORD PTR [rsp+0x18]
  41d23c:	44 89 4c 24 38       	mov    DWORD PTR [rsp+0x38],r9d
  41d241:	48 b8 b0 77 fb ff ff 	movabs rax,0xfffffffffffb77b0
  41d248:	ff ff ff 
  41d24b:	44 89 5c 24 08       	mov    DWORD PTR [rsp+0x8],r11d
  41d250:	4c 01 f8             	add    rax,r15
  41d253:	ff d0                	call   rax
  41d255:	8b 38                	mov    edi,DWORD PTR [rax]
  41d257:	48 b8 20 c9 fb ff ff 	movabs rax,0xfffffffffffbc920
  41d25e:	ff ff ff 
  41d261:	4c 01 f8             	add    rax,r15
  41d264:	ff d0                	call   rax
  41d266:	44 8b 5c 24 08       	mov    r11d,DWORD PTR [rsp+0x8]
  41d26b:	44 8b 4c 24 38       	mov    r9d,DWORD PTR [rsp+0x38]
  41d270:	49 89 c0             	mov    r8,rax
  41d273:	e9 fb fc ff ff       	jmp    41cf73 <printf_core+0xd03>
			switch(ps) {
  41d278:	41 83 ff 07          	cmp    r15d,0x7
  41d27c:	0f 87 e5 f0 ff ff    	ja     41c367 <printf_core+0xf7>
  41d282:	48 8d 15 8f 4c 00 00 	lea    rdx,[rip+0x4c8f]        # 421f18 <CSWTCH.186+0x9e8>
  41d289:	48 03 14 c2          	add    rdx,QWORD PTR [rdx+rax*8]
  41d28d:	3e ff e2             	notrack jmp rdx
			case JPRE: *(uintmax_t *)arg.p = cnt; break;
  41d290:	48 63 44 24 14       	movsxd rax,DWORD PTR [rsp+0x14]
  41d295:	48 8b 94 24 90 00 00 	mov    rdx,QWORD PTR [rsp+0x90]
  41d29c:	00 
  41d29d:	48 89 02             	mov    QWORD PTR [rdx],rax
  41d2a0:	e9 cd f0 ff ff       	jmp    41c372 <printf_core+0x102>
		switch(t) {
  41d2a5:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  41d2aa:	44 89 74 24 60       	mov    DWORD PTR [rsp+0x60],r14d
  41d2af:	48 b8 35 09 fc ff ff 	movabs rax,0xfffffffffffc0935
  41d2b6:	ff ff ff 
  41d2b9:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  41d2c0:	00 
  41d2c1:	48 01 d0             	add    rax,rdx
  41d2c4:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  41d2c9:	e9 66 fa ff ff       	jmp    41cd34 <printf_core+0xac4>
			case BARE: *(int *)arg.p = cnt; break;
  41d2ce:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  41d2d5:	00 
  41d2d6:	8b 54 24 14          	mov    edx,DWORD PTR [rsp+0x14]
  41d2da:	89 10                	mov    DWORD PTR [rax],edx
  41d2dc:	e9 91 f0 ff ff       	jmp    41c372 <printf_core+0x102>
			case HPRE: *(unsigned short *)arg.p = cnt; break;
  41d2e1:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  41d2e8:	00 
  41d2e9:	0f b7 54 24 14       	movzx  edx,WORD PTR [rsp+0x14]
  41d2ee:	66 89 10             	mov    WORD PTR [rax],dx
  41d2f1:	e9 7c f0 ff ff       	jmp    41c372 <printf_core+0x102>
			case HHPRE: *(unsigned char *)arg.p = cnt; break;
  41d2f6:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  41d2fd:	00 
  41d2fe:	0f b6 54 24 14       	movzx  edx,BYTE PTR [rsp+0x14]
  41d303:	88 10                	mov    BYTE PTR [rax],dl
  41d305:	e9 68 f0 ff ff       	jmp    41c372 <printf_core+0x102>
  41d30a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41d310:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  41d315:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  41d31a:	4c 89 ea             	mov    rdx,r13
  41d31d:	4c 89 f7             	mov    rdi,r14
  41d320:	be 00 01 00 00       	mov    esi,0x100
  41d325:	48 01 c8             	add    rax,rcx
  41d328:	ff d0                	call   rax
  41d32a:	41 8b 55 00          	mov    edx,DWORD PTR [r13+0x0]
  41d32e:	89 d0                	mov    eax,edx
  41d330:	83 e0 20             	and    eax,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41d333:	41 81 ff ff 00 00 00 	cmp    r15d,0xff
  41d33a:	0f 8e e9 00 00 00    	jle    41d429 <printf_core+0x11b9>
  41d340:	41 81 ef 00 01 00 00 	sub    r15d,0x100
  41d347:	e9 1f f8 ff ff       	jmp    41cb6b <printf_core+0x8fb>
  41d34c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41d350:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  41d355:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  41d35a:	4c 89 ea             	mov    rdx,r13
  41d35d:	4c 89 f7             	mov    rdi,r14
  41d360:	4c 89 44 24 60       	mov    QWORD PTR [rsp+0x60],r8
  41d365:	be 00 01 00 00       	mov    esi,0x100
  41d36a:	48 01 c8             	add    rax,rcx
  41d36d:	ff d0                	call   rax
  41d36f:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
	for (; l >= sizeof pad; l -= sizeof pad)
  41d373:	4c 8b 44 24 60       	mov    r8,QWORD PTR [rsp+0x60]
  41d378:	44 89 f9             	mov    ecx,r15d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41d37b:	89 c2                	mov    edx,eax
  41d37d:	83 e2 20             	and    edx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41d380:	41 81 ff ff 00 00 00 	cmp    r15d,0xff
  41d387:	0f 8e 51 f7 ff ff    	jle    41cade <printf_core+0x86e>
  41d38d:	41 81 ef 00 01 00 00 	sub    r15d,0x100
  41d394:	e9 0b f7 ff ff       	jmp    41caa4 <printf_core+0x834>
  41d399:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41d3a0:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  41d3a5:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  41d3aa:	4c 89 ea             	mov    rdx,r13
  41d3ad:	4c 89 f7             	mov    rdi,r14
  41d3b0:	be 00 01 00 00       	mov    esi,0x100
	for (; l >= sizeof pad; l -= sizeof pad)
  41d3b5:	41 89 ec             	mov    r12d,ebp
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41d3b8:	48 01 c8             	add    rax,rcx
  41d3bb:	ff d0                	call   rax
  41d3bd:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
  41d3c1:	89 c2                	mov    edx,eax
  41d3c3:	83 e2 20             	and    edx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41d3c6:	81 fd ff 00 00 00    	cmp    ebp,0xff
  41d3cc:	0f 8e 98 f8 ff ff    	jle    41cc6a <printf_core+0x9fa>
  41d3d2:	81 ed 00 01 00 00    	sub    ebp,0x100
  41d3d8:	e9 53 f8 ff ff       	jmp    41cc30 <printf_core+0x9c0>
  41d3dd:	0f 1f 00             	nop    DWORD PTR [rax]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41d3e0:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  41d3e5:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  41d3ea:	4c 89 ea             	mov    rdx,r13
  41d3ed:	4c 89 f7             	mov    rdi,r14
  41d3f0:	4c 89 44 24 68       	mov    QWORD PTR [rsp+0x68],r8
  41d3f5:	be 00 01 00 00       	mov    esi,0x100
  41d3fa:	48 01 c8             	add    rax,rcx
  41d3fd:	ff d0                	call   rax
  41d3ff:	41 8b 55 00          	mov    edx,DWORD PTR [r13+0x0]
	for (; l >= sizeof pad; l -= sizeof pad)
  41d403:	4c 8b 44 24 68       	mov    r8,QWORD PTR [rsp+0x68]
  41d408:	44 89 f9             	mov    ecx,r15d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41d40b:	89 d0                	mov    eax,edx
  41d40d:	83 e0 20             	and    eax,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41d410:	41 81 ff ff 00 00 00 	cmp    r15d,0xff
  41d417:	0f 8e d2 f5 ff ff    	jle    41c9ef <printf_core+0x77f>
  41d41d:	41 81 ef 00 01 00 00 	sub    r15d,0x100
  41d424:	e9 88 f5 ff ff       	jmp    41c9b1 <printf_core+0x741>
  41d429:	49 89 e8             	mov    r8,rbp
  41d42c:	44 89 fd             	mov    ebp,r15d
  41d42f:	e9 7c f7 ff ff       	jmp    41cbb0 <printf_core+0x940>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41d434:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
  41d438:	83 e0 20             	and    eax,0x20
  41d43b:	85 c0                	test   eax,eax
  41d43d:	0f 85 e1 f5 ff ff    	jne    41ca24 <printf_core+0x7b4>
  41d443:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  41d448:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  41d44d:	4c 89 44 24 68       	mov    QWORD PTR [rsp+0x68],r8
  41d452:	4c 89 ea             	mov    rdx,r13
		out(f, prefix, pl);
  41d455:	48 63 74 24 60       	movsxd rsi,DWORD PTR [rsp+0x60]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41d45a:	48 8b 7c 24 70       	mov    rdi,QWORD PTR [rsp+0x70]
  41d45f:	48 01 c8             	add    rax,rcx
  41d462:	ff d0                	call   rax
  41d464:	4c 8b 44 24 68       	mov    r8,QWORD PTR [rsp+0x68]
  41d469:	e9 b6 f5 ff ff       	jmp    41ca24 <printf_core+0x7b4>
  41d46e:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
  41d472:	83 e0 20             	and    eax,0x20
  41d475:	85 c0                	test   eax,eax
  41d477:	0f 85 3b f7 ff ff    	jne    41cbb8 <printf_core+0x948>
  41d47d:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  41d482:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  41d487:	4c 89 ea             	mov    rdx,r13
  41d48a:	4c 89 c7             	mov    rdi,r8
  41d48d:	48 8b 74 24 50       	mov    rsi,QWORD PTR [rsp+0x50]
  41d492:	48 01 c8             	add    rax,rcx
  41d495:	ff d0                	call   rax
  41d497:	e9 1c f7 ff ff       	jmp    41cbb8 <printf_core+0x948>
  41d49c:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  41d4a1:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  41d4a6:	4c 89 ea             	mov    rdx,r13
  41d4a9:	4c 89 f7             	mov    rdi,r14
  41d4ac:	44 89 4c 24 5c       	mov    DWORD PTR [rsp+0x5c],r9d
  41d4b1:	be 00 01 00 00       	mov    esi,0x100
  41d4b6:	48 01 c8             	add    rax,rcx
  41d4b9:	44 89 5c 24 38       	mov    DWORD PTR [rsp+0x38],r11d
  41d4be:	ff d0                	call   rax
  41d4c0:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
	for (; l >= sizeof pad; l -= sizeof pad)
  41d4c4:	44 8b 5c 24 38       	mov    r11d,DWORD PTR [rsp+0x38]
  41d4c9:	44 89 f9             	mov    ecx,r15d
  41d4cc:	44 8b 4c 24 5c       	mov    r9d,DWORD PTR [rsp+0x5c]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41d4d1:	89 c2                	mov    edx,eax
  41d4d3:	83 e2 20             	and    edx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41d4d6:	41 81 ff ff 00 00 00 	cmp    r15d,0xff
  41d4dd:	0f 8e 75 fc ff ff    	jle    41d158 <printf_core+0xee8>
  41d4e3:	41 81 ef 00 01 00 00 	sub    r15d,0x100
  41d4ea:	e9 2c fc ff ff       	jmp    41d11b <printf_core+0xeab>
  41d4ef:	44 8b 5c 24 5c       	mov    r11d,DWORD PTR [rsp+0x5c]
  41d4f4:	48 8b 5c 24 60       	mov    rbx,QWORD PTR [rsp+0x60]
  41d4f9:	44 8b 64 24 68       	mov    r12d,DWORD PTR [rsp+0x68]
  41d4fe:	44 8b 4c 24 50       	mov    r9d,DWORD PTR [rsp+0x50]
			pad(f, ' ', w, p, fl^LEFT_ADJ);
  41d503:	41 81 f4 00 20 00 00 	xor    r12d,0x2000
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41d50a:	41 81 e4 00 20 01 00 	and    r12d,0x12000
  41d511:	0f 85 85 00 00 00    	jne    41d59c <printf_core+0x132c>
  41d517:	80 7c 24 38 00       	cmp    BYTE PTR [rsp+0x38],0x0
  41d51c:	75 7e                	jne    41d59c <printf_core+0x132c>
	l = w - l;
  41d51e:	44 89 cd             	mov    ebp,r9d
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41d521:	b8 00 01 00 00       	mov    eax,0x100
	l = w - l;
  41d526:	2b 6c 24 08          	sub    ebp,DWORD PTR [rsp+0x8]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41d52a:	4c 8b 7c 24 18       	mov    r15,QWORD PTR [rsp+0x18]
  41d52f:	39 c5                	cmp    ebp,eax
  41d531:	44 89 5c 24 50       	mov    DWORD PTR [rsp+0x50],r11d
  41d536:	be 20 00 00 00       	mov    esi,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41d53b:	41 89 ec             	mov    r12d,ebp
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41d53e:	0f 4e c5             	cmovle eax,ebp
  41d541:	4c 8d b4 24 d0 00 00 	lea    r14,[rsp+0xd0]
  41d548:	00 
	l = w - l;
  41d549:	44 89 4c 24 38       	mov    DWORD PTR [rsp+0x38],r9d
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41d54e:	4c 89 f7             	mov    rdi,r14
  41d551:	48 63 d0             	movsxd rdx,eax
  41d554:	48 b8 3c 64 fb ff ff 	movabs rax,0xfffffffffffb643c
  41d55b:	ff ff ff 
  41d55e:	4c 01 f8             	add    rax,r15
  41d561:	ff d0                	call   rax
	for (; l >= sizeof pad; l -= sizeof pad)
  41d563:	81 fd ff 00 00 00    	cmp    ebp,0xff
  41d569:	44 8b 4c 24 38       	mov    r9d,DWORD PTR [rsp+0x38]
  41d56e:	44 8b 5c 24 50       	mov    r11d,DWORD PTR [rsp+0x50]
  41d573:	0f 8e b5 03 00 00    	jle    41d92e <printf_core+0x16be>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41d579:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
  41d57d:	45 89 df             	mov    r15d,r11d
  41d580:	83 e0 20             	and    eax,0x20
  41d583:	74 2c                	je     41d5b1 <printf_core+0x1341>
	for (; l >= sizeof pad; l -= sizeof pad)
  41d585:	41 8d 8c 24 00 ff ff 	lea    ecx,[r12-0x100]
  41d58c:	ff 
  41d58d:	45 89 fb             	mov    r11d,r15d
  41d590:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  41d596:	0f 87 0a e9 ff ff    	ja     41bea6 <printf_core.cold+0xbb>
			l = w>p ? w : p;
  41d59c:	8b 44 24 08          	mov    eax,DWORD PTR [rsp+0x8]
  41d5a0:	44 39 c8             	cmp    eax,r9d
  41d5a3:	44 0f 4d c8          	cmovge r9d,eax
  41d5a7:	44 89 4c 24 08       	mov    DWORD PTR [rsp+0x8],r9d
			continue;
  41d5ac:	e9 b6 ed ff ff       	jmp    41c367 <printf_core+0xf7>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41d5b1:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  41d5b6:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  41d5bb:	4c 89 ea             	mov    rdx,r13
  41d5be:	4c 89 f7             	mov    rdi,r14
  41d5c1:	44 89 4c 24 38       	mov    DWORD PTR [rsp+0x38],r9d
  41d5c6:	be 00 01 00 00       	mov    esi,0x100
	for (; l >= sizeof pad; l -= sizeof pad)
  41d5cb:	41 81 ec 00 01 00 00 	sub    r12d,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41d5d2:	48 01 c8             	add    rax,rcx
	for (; l >= sizeof pad; l -= sizeof pad)
  41d5d5:	44 89 e5             	mov    ebp,r12d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41d5d8:	ff d0                	call   rax
  41d5da:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
	for (; l >= sizeof pad; l -= sizeof pad)
  41d5de:	44 8b 4c 24 38       	mov    r9d,DWORD PTR [rsp+0x38]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41d5e3:	89 c2                	mov    edx,eax
  41d5e5:	83 e2 20             	and    edx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41d5e8:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  41d5ef:	77 8f                	ja     41d580 <printf_core+0x1310>
  41d5f1:	45 89 fb             	mov    r11d,r15d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41d5f4:	85 d2                	test   edx,edx
  41d5f6:	75 a4                	jne    41d59c <printf_core+0x132c>
  41d5f8:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  41d5fd:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
	out(f, pad, l);
  41d602:	48 63 f5             	movsxd rsi,ebp
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41d605:	4c 89 ea             	mov    rdx,r13
  41d608:	44 89 4c 24 50       	mov    DWORD PTR [rsp+0x50],r9d
  41d60d:	4c 89 f7             	mov    rdi,r14
  41d610:	44 89 5c 24 38       	mov    DWORD PTR [rsp+0x38],r11d
  41d615:	48 01 c8             	add    rax,rcx
  41d618:	ff d0                	call   rax
  41d61a:	44 8b 4c 24 50       	mov    r9d,DWORD PTR [rsp+0x50]
  41d61f:	44 8b 5c 24 38       	mov    r11d,DWORD PTR [rsp+0x38]
  41d624:	e9 73 ff ff ff       	jmp    41d59c <printf_core+0x132c>
  41d629:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  41d62e:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
	out(f, pad, l);
  41d633:	48 63 f5             	movsxd rsi,ebp
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41d636:	4c 89 ea             	mov    rdx,r13
  41d639:	4c 89 44 24 60       	mov    QWORD PTR [rsp+0x60],r8
  41d63e:	4c 89 f7             	mov    rdi,r14
  41d641:	48 01 c8             	add    rax,rcx
  41d644:	ff d0                	call   rax
  41d646:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
  41d64a:	4c 8b 44 24 60       	mov    r8,QWORD PTR [rsp+0x60]
  41d64f:	83 e0 20             	and    eax,0x20
  41d652:	e9 1e fe ff ff       	jmp    41d475 <printf_core+0x1205>
  41d657:	48 c7 44 24 50 00 00 	mov    QWORD PTR [rsp+0x50],0x0
  41d65e:	00 00 
  41d660:	8b 44 24 60          	mov    eax,DWORD PTR [rsp+0x60]
				a=z;
  41d664:	4d 89 f8             	mov    r8,r15
  41d667:	89 44 24 5c          	mov    DWORD PTR [rsp+0x5c],eax
  41d66b:	e9 60 f8 ff ff       	jmp    41ced0 <printf_core+0xc60>
		if (p < z-a) p = z-a;
  41d670:	48 b8 35 09 fc ff ff 	movabs rax,0xfffffffffffc0935
  41d677:	ff ff ff 
  41d67a:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  41d67f:	48 01 d0             	add    rax,rdx
  41d682:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  41d687:	e9 7f f2 ff ff       	jmp    41c90b <printf_core+0x69b>
			z = a + strnlen(a, p<0 ? INT_MAX : p);
  41d68c:	4c 8b 7c 24 18       	mov    r15,QWORD PTR [rsp+0x18]
  41d691:	44 89 4c 24 50       	mov    DWORD PTR [rsp+0x50],r9d
  41d696:	4c 89 c7             	mov    rdi,r8
  41d699:	be ff ff ff 7f       	mov    esi,0x7fffffff
  41d69e:	48 b8 80 71 fb ff ff 	movabs rax,0xfffffffffffb7180
  41d6a5:	ff ff ff 
  41d6a8:	44 89 5c 24 38       	mov    DWORD PTR [rsp+0x38],r11d
  41d6ad:	4c 89 44 24 08       	mov    QWORD PTR [rsp+0x8],r8
  41d6b2:	4c 01 f8             	add    rax,r15
  41d6b5:	ff d0                	call   rax
  41d6b7:	4c 8b 44 24 08       	mov    r8,QWORD PTR [rsp+0x8]
			if (p<0 && *z) goto overflow;
  41d6bc:	44 8b 5c 24 38       	mov    r11d,DWORD PTR [rsp+0x38]
			z = a + strnlen(a, p<0 ? INT_MAX : p);
  41d6c1:	48 89 c5             	mov    rbp,rax
			if (p<0 && *z) goto overflow;
  41d6c4:	44 8b 4c 24 50       	mov    r9d,DWORD PTR [rsp+0x50]
			z = a + strnlen(a, p<0 ? INT_MAX : p);
  41d6c9:	49 8d 04 00          	lea    rax,[r8+rax*1]
			if (p<0 && *z) goto overflow;
  41d6cd:	80 38 00             	cmp    BYTE PTR [rax],0x0
  41d6d0:	0f 84 e4 f8 ff ff    	je     41cfba <printf_core+0xd4a>
  41d6d6:	e9 ce ef ff ff       	jmp    41c6a9 <printf_core+0x439>
  41d6db:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41d6e0:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
  41d6e4:	83 e0 20             	and    eax,0x20
  41d6e7:	e9 c4 f4 ff ff       	jmp    41cbb0 <printf_core+0x940>
			if (l<0) return -1;
  41d6ec:	c7 44 24 14 ff ff ff 	mov    DWORD PTR [rsp+0x14],0xffffffff
  41d6f3:	ff 
  41d6f4:	e9 77 ee ff ff       	jmp    41c570 <printf_core+0x300>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41d6f9:	41 8b 55 00          	mov    edx,DWORD PTR [r13+0x0]
  41d6fd:	83 e2 20             	and    edx,0x20
  41d700:	e9 d9 f3 ff ff       	jmp    41cade <printf_core+0x86e>
  41d705:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
  41d709:	83 e0 20             	and    eax,0x20
  41d70c:	e9 de f2 ff ff       	jmp    41c9ef <printf_core+0x77f>
  41d711:	41 8b 55 00          	mov    edx,DWORD PTR [r13+0x0]
  41d715:	83 e2 20             	and    edx,0x20
  41d718:	e9 4d f5 ff ff       	jmp    41cc6a <printf_core+0x9fa>
		prefix = "-+   0X0x";
  41d71d:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
				arg.i=-arg.i;
  41d722:	48 f7 d9             	neg    rcx
		prefix = "-+   0X0x";
  41d725:	48 b8 35 09 fc ff ff 	movabs rax,0xfffffffffffc0935
  41d72c:	ff ff ff 
			pl=1;
  41d72f:	c7 44 24 60 01 00 00 	mov    DWORD PTR [rsp+0x60],0x1
  41d736:	00 
				arg.i=-arg.i;
  41d737:	48 89 8c 24 90 00 00 	mov    QWORD PTR [rsp+0x90],rcx
  41d73e:	00 
		prefix = "-+   0X0x";
  41d73f:	48 01 d0             	add    rax,rdx
  41d742:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  41d747:	e9 f1 f5 ff ff       	jmp    41cd3d <printf_core+0xacd>
				prefix++;
  41d74c:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
			pl=1;
  41d751:	c7 44 24 60 01 00 00 	mov    DWORD PTR [rsp+0x60],0x1
  41d758:	00 
				prefix++;
  41d759:	48 b8 36 09 fc ff ff 	movabs rax,0xfffffffffffc0936
  41d760:	ff ff ff 
  41d763:	48 01 d0             	add    rax,rdx
  41d766:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  41d76b:	e9 c4 f5 ff ff       	jmp    41cd34 <printf_core+0xac4>
			else return 0;
  41d770:	c7 44 24 14 00 00 00 	mov    DWORD PTR [rsp+0x14],0x0
  41d777:	00 
  41d778:	e9 f3 ed ff ff       	jmp    41c570 <printf_core+0x300>
			a = arg.p ? arg.p : "(null)";
  41d77d:	48 b8 3f 09 fc ff ff 	movabs rax,0xfffffffffffc093f
  41d784:	ff ff ff 
  41d787:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  41d78c:	4c 8d 04 02          	lea    r8,[rdx+rax*1]
  41d790:	e9 de f7 ff ff       	jmp    41cf73 <printf_core+0xd03>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41d795:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
	out(f, pad, l);
  41d79a:	48 63 f1             	movsxd rsi,ecx
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41d79d:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  41d7a2:	4c 89 ea             	mov    rdx,r13
  41d7a5:	44 89 4c 24 5c       	mov    DWORD PTR [rsp+0x5c],r9d
  41d7aa:	4c 89 f7             	mov    rdi,r14
  41d7ad:	44 89 5c 24 38       	mov    DWORD PTR [rsp+0x38],r11d
  41d7b2:	48 01 c8             	add    rax,rcx
  41d7b5:	ff d0                	call   rax
  41d7b7:	44 8b 4c 24 5c       	mov    r9d,DWORD PTR [rsp+0x5c]
  41d7bc:	44 8b 5c 24 38       	mov    r11d,DWORD PTR [rsp+0x38]
  41d7c1:	e9 9a f9 ff ff       	jmp    41d160 <printf_core+0xef0>
		prefix = "-+   0X0x";
  41d7c6:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
	for (; x; x>>=4) *--s = xdigits[(x&15)]|lower;
  41d7cb:	4c 8d bc 24 cb 00 00 	lea    r15,[rsp+0xcb]
  41d7d2:	00 
		pl = 0;
  41d7d3:	44 89 74 24 60       	mov    DWORD PTR [rsp+0x60],r14d
		prefix = "-+   0X0x";
  41d7d8:	48 b8 35 09 fc ff ff 	movabs rax,0xfffffffffffc0935
  41d7df:	ff ff ff 
	for (; x; x>>=4) *--s = xdigits[(x&15)]|lower;
  41d7e2:	4d 89 f8             	mov    r8,r15
		prefix = "-+   0X0x";
  41d7e5:	48 01 d0             	add    rax,rdx
  41d7e8:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  41d7ed:	e9 93 f5 ff ff       	jmp    41cd85 <printf_core+0xb15>
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  41d7f2:	4c 8d bc 24 cb 00 00 	lea    r15,[rsp+0xcb]
  41d7f9:	00 
  41d7fa:	4d 89 f8             	mov    r8,r15
  41d7fd:	e9 83 f5 ff ff       	jmp    41cd85 <printf_core+0xb15>
	for (; i<=NL_ARGMAX && !nl_type[i]; i++);
  41d802:	49 8d 50 01          	lea    rdx,[r8+0x1]
  41d806:	49 83 f8 09          	cmp    r8,0x9
  41d80a:	0f 84 a1 f0 ff ff    	je     41c8b1 <printf_core+0x641>
  41d810:	48 8b 7c 24 40       	mov    rdi,QWORD PTR [rsp+0x40]
  41d815:	48 8d 04 95 00 00 00 	lea    rax,[rdx*4+0x0]
  41d81c:	00 
  41d81d:	8b 2c 97             	mov    ebp,DWORD PTR [rdi+rdx*4]
  41d820:	85 ed                	test   ebp,ebp
  41d822:	0f 85 26 ed ff ff    	jne    41c54e <printf_core+0x2de>
  41d828:	49 83 f8 08          	cmp    r8,0x8
  41d82c:	0f 84 7f f0 ff ff    	je     41c8b1 <printf_core+0x641>
  41d832:	8b 5c 07 04          	mov    ebx,DWORD PTR [rdi+rax*1+0x4]
  41d836:	85 db                	test   ebx,ebx
  41d838:	0f 85 10 ed ff ff    	jne    41c54e <printf_core+0x2de>
  41d83e:	49 83 f8 07          	cmp    r8,0x7
  41d842:	0f 84 69 f0 ff ff    	je     41c8b1 <printf_core+0x641>
  41d848:	44 8b 5c 07 08       	mov    r11d,DWORD PTR [rdi+rax*1+0x8]
  41d84d:	45 85 db             	test   r11d,r11d
  41d850:	0f 85 f8 ec ff ff    	jne    41c54e <printf_core+0x2de>
  41d856:	49 83 f8 06          	cmp    r8,0x6
  41d85a:	0f 84 51 f0 ff ff    	je     41c8b1 <printf_core+0x641>
  41d860:	44 8b 54 07 0c       	mov    r10d,DWORD PTR [rdi+rax*1+0xc]
  41d865:	45 85 d2             	test   r10d,r10d
  41d868:	0f 85 e0 ec ff ff    	jne    41c54e <printf_core+0x2de>
  41d86e:	49 83 f8 05          	cmp    r8,0x5
  41d872:	0f 84 39 f0 ff ff    	je     41c8b1 <printf_core+0x641>
  41d878:	44 8b 4c 07 10       	mov    r9d,DWORD PTR [rdi+rax*1+0x10]
  41d87d:	45 85 c9             	test   r9d,r9d
  41d880:	0f 85 c8 ec ff ff    	jne    41c54e <printf_core+0x2de>
  41d886:	49 83 f8 04          	cmp    r8,0x4
  41d88a:	0f 84 21 f0 ff ff    	je     41c8b1 <printf_core+0x641>
  41d890:	8b 74 07 14          	mov    esi,DWORD PTR [rdi+rax*1+0x14]
  41d894:	85 f6                	test   esi,esi
  41d896:	0f 85 b2 ec ff ff    	jne    41c54e <printf_core+0x2de>
  41d89c:	49 8d 50 07          	lea    rdx,[r8+0x7]
  41d8a0:	49 83 f8 03          	cmp    r8,0x3
  41d8a4:	0f 84 07 f0 ff ff    	je     41c8b1 <printf_core+0x641>
  41d8aa:	8b 4c 07 18          	mov    ecx,DWORD PTR [rdi+rax*1+0x18]
  41d8ae:	85 c9                	test   ecx,ecx
  41d8b0:	0f 85 98 ec ff ff    	jne    41c54e <printf_core+0x2de>
  41d8b6:	48 83 fa 08          	cmp    rdx,0x8
  41d8ba:	0f 85 f1 ef ff ff    	jne    41c8b1 <printf_core+0x641>
  41d8c0:	8b 44 07 1c          	mov    eax,DWORD PTR [rdi+rax*1+0x1c]
  41d8c4:	85 c0                	test   eax,eax
  41d8c6:	0f 84 e5 ef ff ff    	je     41c8b1 <printf_core+0x641>
  41d8cc:	e9 7d ec ff ff       	jmp    41c54e <printf_core+0x2de>
  41d8d1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
				prefix+=2;
  41d8d8:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
			pl=1;
  41d8dd:	c7 44 24 60 01 00 00 	mov    DWORD PTR [rsp+0x60],0x1
  41d8e4:	00 
				prefix+=2;
  41d8e5:	48 b8 37 09 fc ff ff 	movabs rax,0xfffffffffffc0937
  41d8ec:	ff ff ff 
  41d8ef:	48 01 d0             	add    rax,rdx
  41d8f2:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  41d8f7:	e9 38 f4 ff ff       	jmp    41cd34 <printf_core+0xac4>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41d8fc:	41 8b 55 00          	mov    edx,DWORD PTR [r13+0x0]
  41d900:	83 e2 20             	and    edx,0x20
  41d903:	e9 50 f8 ff ff       	jmp    41d158 <printf_core+0xee8>
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41d908:	45 85 c9             	test   r9d,r9d
  41d90b:	0f 9e c0             	setle  al
  41d90e:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  41d912:	41 f7 c4 00 20 01 00 	test   r12d,0x12000
  41d919:	0f 85 e4 fb ff ff    	jne    41d503 <printf_core+0x1293>
			for (i=l=0; i<p && *ws && (l=wctomb(mb, *ws++))>=0 && l<=p-i; i+=l);
  41d91f:	31 ed                	xor    ebp,ebp
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41d921:	84 c0                	test   al,al
  41d923:	0f 84 84 f7 ff ff    	je     41d0ad <printf_core+0xe3d>
  41d929:	e9 d5 fb ff ff       	jmp    41d503 <printf_core+0x1293>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41d92e:	41 8b 55 00          	mov    edx,DWORD PTR [r13+0x0]
  41d932:	83 e2 20             	and    edx,0x20
  41d935:	e9 ba fc ff ff       	jmp    41d5f4 <printf_core+0x1384>
  41d93a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000041d940 <vfprintf>:

int vfprintf(FILE *restrict f, const char *restrict fmt, va_list ap)
{
  41d940:	f3 0f 1e fa          	endbr64 
  41d944:	41 57                	push   r15
	va_list ap2;
	int nl_type[NL_ARGMAX+1] = {0};
  41d946:	66 0f ef c0          	pxor   xmm0,xmm0
  41d94a:	49 bb cc 3a 04 00 00 	movabs r11,0x43acc
  41d951:	00 00 00 
{
  41d954:	41 56                	push   r14
  41d956:	49 89 f6             	mov    r14,rsi
  41d959:	41 55                	push   r13
  41d95b:	41 54                	push   r12
  41d95d:	55                   	push   rbp
  41d95e:	48 89 fd             	mov    rbp,rdi
	int olderr;
	int ret;

	/* the copy allows passing va_list* even if va_list is an array */
	va_copy(ap2, ap);
	if (printf_core(0, fmt, &ap2, nl_arg, nl_type) < 0) {
  41d961:	31 ff                	xor    edi,edi
{
  41d963:	53                   	push   rbx
  41d964:	48 8d 1d d9 ff ff ff 	lea    rbx,[rip+0xffffffffffffffd9]        # 41d944 <vfprintf+0x4>
  41d96b:	4c 01 db             	add    rbx,r11
  41d96e:	48 81 ec 78 01 00 00 	sub    rsp,0x178
	int nl_type[NL_ARGMAX+1] = {0};
  41d975:	0f 29 44 24 50       	movaps XMMWORD PTR [rsp+0x50],xmm0
	va_copy(ap2, ap);
  41d97a:	4c 8d 7c 24 38       	lea    r15,[rsp+0x38]
	if (printf_core(0, fmt, &ap2, nl_arg, nl_type) < 0) {
  41d97f:	4c 8d 44 24 50       	lea    r8,[rsp+0x50]
	int nl_type[NL_ARGMAX+1] = {0};
  41d984:	0f 29 44 24 60       	movaps XMMWORD PTR [rsp+0x60],xmm0
	if (printf_core(0, fmt, &ap2, nl_arg, nl_type) < 0) {
  41d989:	48 8d 8c 24 d0 00 00 	lea    rcx,[rsp+0xd0]
  41d990:	00 
	int nl_type[NL_ARGMAX+1] = {0};
  41d991:	48 c7 44 24 70 00 00 	mov    QWORD PTR [rsp+0x70],0x0
  41d998:	00 00 
	va_copy(ap2, ap);
  41d99a:	f3 0f 6f 0a          	movdqu xmm1,XMMWORD PTR [rdx]
  41d99e:	0f 11 4c 24 38       	movups XMMWORD PTR [rsp+0x38],xmm1
  41d9a3:	48 8b 42 10          	mov    rax,QWORD PTR [rdx+0x10]
	if (printf_core(0, fmt, &ap2, nl_arg, nl_type) < 0) {
  41d9a7:	4c 89 fa             	mov    rdx,r15
  41d9aa:	4c 89 44 24 18       	mov    QWORD PTR [rsp+0x18],r8
	va_copy(ap2, ap);
  41d9af:	48 89 44 24 48       	mov    QWORD PTR [rsp+0x48],rax
	if (printf_core(0, fmt, &ap2, nl_arg, nl_type) < 0) {
  41d9b4:	48 b8 60 ae fb ff ff 	movabs rax,0xfffffffffffbae60
  41d9bb:	ff ff ff 
  41d9be:	48 89 44 24 20       	mov    QWORD PTR [rsp+0x20],rax
  41d9c3:	48 01 d8             	add    rax,rbx
  41d9c6:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  41d9cb:	ff d0                	call   rax
  41d9cd:	85 c0                	test   eax,eax
  41d9cf:	0f 88 8a 01 00 00    	js     41db5f <vfprintf+0x21f>
		va_end(ap2);
		return -1;
	}

	FLOCK(f);
  41d9d5:	8b 85 8c 00 00 00    	mov    eax,DWORD PTR [rbp+0x8c]
  41d9db:	c7 44 24 0c 00 00 00 	mov    DWORD PTR [rsp+0xc],0x0
  41d9e2:	00 
  41d9e3:	48 8b 4c 24 10       	mov    rcx,QWORD PTR [rsp+0x10]
  41d9e8:	4c 8b 44 24 18       	mov    r8,QWORD PTR [rsp+0x18]
  41d9ed:	85 c0                	test   eax,eax
  41d9ef:	78 2a                	js     41da1b <vfprintf+0xdb>
  41d9f1:	48 b8 e0 cb fb ff ff 	movabs rax,0xfffffffffffbcbe0
  41d9f8:	ff ff ff 
  41d9fb:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
  41da00:	48 89 ef             	mov    rdi,rbp
  41da03:	4c 89 44 24 10       	mov    QWORD PTR [rsp+0x10],r8
  41da08:	48 01 d8             	add    rax,rbx
  41da0b:	ff d0                	call   rax
  41da0d:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  41da12:	4c 8b 44 24 10       	mov    r8,QWORD PTR [rsp+0x10]
  41da17:	89 44 24 0c          	mov    DWORD PTR [rsp+0xc],eax
	olderr = f->flags & F_ERR;
  41da1b:	8b 45 00             	mov    eax,DWORD PTR [rbp+0x0]
	if (f->mode < 1) f->flags &= ~F_ERR;
  41da1e:	8b 95 88 00 00 00    	mov    edx,DWORD PTR [rbp+0x88]
	olderr = f->flags & F_ERR;
  41da24:	89 c6                	mov    esi,eax
  41da26:	83 e6 20             	and    esi,0x20
  41da29:	89 74 24 10          	mov    DWORD PTR [rsp+0x10],esi
	if (f->mode < 1) f->flags &= ~F_ERR;
  41da2d:	85 d2                	test   edx,edx
  41da2f:	7f 06                	jg     41da37 <vfprintf+0xf7>
  41da31:	83 e0 df             	and    eax,0xffffffdf
  41da34:	89 45 00             	mov    DWORD PTR [rbp+0x0],eax
	if (!f->buf_size) {
  41da37:	48 83 7d 60 00       	cmp    QWORD PTR [rbp+0x60],0x0
  41da3c:	0f 84 9e 00 00 00    	je     41dae0 <vfprintf+0x1a0>
		saved_buf = f->buf;
		f->buf = internal_buf;
		f->buf_size = sizeof internal_buf;
		f->wpos = f->wbase = f->wend = 0;
	}
	if (!f->wend && __towrite(f)) ret = -1;
  41da42:	4c 8b 6d 20          	mov    r13,QWORD PTR [rbp+0x20]
  41da46:	4d 85 ed             	test   r13,r13
  41da49:	0f 84 1b 01 00 00    	je     41db6a <vfprintf+0x22a>
	unsigned char internal_buf[80], *saved_buf = 0;
  41da4f:	45 31 ed             	xor    r13d,r13d
	else ret = printf_core(f, fmt, &ap2, nl_arg, nl_type);
  41da52:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  41da57:	4c 89 fa             	mov    rdx,r15
  41da5a:	4c 89 f6             	mov    rsi,r14
  41da5d:	48 89 ef             	mov    rdi,rbp
  41da60:	48 01 d8             	add    rax,rbx
  41da63:	ff d0                	call   rax
  41da65:	41 89 c4             	mov    r12d,eax
	if (saved_buf) {
  41da68:	4d 85 ed             	test   r13,r13
  41da6b:	74 34                	je     41daa1 <vfprintf+0x161>
		f->write(f, 0, 0);
  41da6d:	31 d2                	xor    edx,edx
  41da6f:	31 f6                	xor    esi,esi
  41da71:	48 89 ef             	mov    rdi,rbp
  41da74:	ff 55 48             	call   QWORD PTR [rbp+0x48]
		if (!f->wpos) ret = -1;
  41da77:	48 83 7d 28 00       	cmp    QWORD PTR [rbp+0x28],0x0
		f->buf = saved_buf;
  41da7c:	4c 89 6d 58          	mov    QWORD PTR [rbp+0x58],r13
		f->buf_size = 0;
		f->wpos = f->wbase = f->wend = 0;
  41da80:	66 0f ef c0          	pxor   xmm0,xmm0
		if (!f->wpos) ret = -1;
  41da84:	b8 ff ff ff ff       	mov    eax,0xffffffff
		f->buf_size = 0;
  41da89:	48 c7 45 60 00 00 00 	mov    QWORD PTR [rbp+0x60],0x0
  41da90:	00 
		f->wpos = f->wbase = f->wend = 0;
  41da91:	48 c7 45 38 00 00 00 	mov    QWORD PTR [rbp+0x38],0x0
  41da98:	00 
		if (!f->wpos) ret = -1;
  41da99:	44 0f 44 e0          	cmove  r12d,eax
		f->wpos = f->wbase = f->wend = 0;
  41da9d:	0f 11 45 20          	movups XMMWORD PTR [rbp+0x20],xmm0
	}
	if (f->flags & F_ERR) ret = -1;
  41daa1:	8b 45 00             	mov    eax,DWORD PTR [rbp+0x0]
	f->flags |= olderr;
  41daa4:	44 8b 6c 24 10       	mov    r13d,DWORD PTR [rsp+0x10]
	if (f->flags & F_ERR) ret = -1;
  41daa9:	ba ff ff ff ff       	mov    edx,0xffffffff
  41daae:	a8 20                	test   al,0x20
  41dab0:	44 0f 45 e2          	cmovne r12d,edx
	f->flags |= olderr;
  41dab4:	41 09 c5             	or     r13d,eax
	FUNLOCK(f);
  41dab7:	8b 44 24 0c          	mov    eax,DWORD PTR [rsp+0xc]
	f->flags |= olderr;
  41dabb:	44 89 6d 00          	mov    DWORD PTR [rbp+0x0],r13d
	FUNLOCK(f);
  41dabf:	85 c0                	test   eax,eax
  41dac1:	0f 85 81 00 00 00    	jne    41db48 <vfprintf+0x208>
	va_end(ap2);
	return ret;
}
  41dac7:	48 81 c4 78 01 00 00 	add    rsp,0x178
  41dace:	44 89 e0             	mov    eax,r12d
  41dad1:	5b                   	pop    rbx
  41dad2:	5d                   	pop    rbp
  41dad3:	41 5c                	pop    r12
  41dad5:	41 5d                	pop    r13
  41dad7:	41 5e                	pop    r14
  41dad9:	41 5f                	pop    r15
  41dadb:	c3                   	ret    
  41dadc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		saved_buf = f->buf;
  41dae0:	4c 8b 6d 58          	mov    r13,QWORD PTR [rbp+0x58]
		f->wpos = f->wbase = f->wend = 0;
  41dae4:	66 0f ef c0          	pxor   xmm0,xmm0
  41dae8:	48 89 4c 24 28       	mov    QWORD PTR [rsp+0x28],rcx
	if (!f->wend && __towrite(f)) ret = -1;
  41daed:	48 89 ef             	mov    rdi,rbp
		f->buf = internal_buf;
  41daf0:	48 8d 84 24 80 00 00 	lea    rax,[rsp+0x80]
  41daf7:	00 
  41daf8:	4c 89 44 24 18       	mov    QWORD PTR [rsp+0x18],r8
	if (!f->wend && __towrite(f)) ret = -1;
  41dafd:	41 bc ff ff ff ff    	mov    r12d,0xffffffff
		f->buf = internal_buf;
  41db03:	48 89 45 58          	mov    QWORD PTR [rbp+0x58],rax
	if (!f->wend && __towrite(f)) ret = -1;
  41db07:	48 b8 90 cd fb ff ff 	movabs rax,0xfffffffffffbcd90
  41db0e:	ff ff ff 
		f->buf_size = sizeof internal_buf;
  41db11:	48 c7 45 60 50 00 00 	mov    QWORD PTR [rbp+0x60],0x50
  41db18:	00 
	if (!f->wend && __towrite(f)) ret = -1;
  41db19:	48 01 d8             	add    rax,rbx
		f->wpos = f->wbase = f->wend = 0;
  41db1c:	48 c7 45 38 00 00 00 	mov    QWORD PTR [rbp+0x38],0x0
  41db23:	00 
  41db24:	0f 11 45 20          	movups XMMWORD PTR [rbp+0x20],xmm0
	if (!f->wend && __towrite(f)) ret = -1;
  41db28:	ff d0                	call   rax
  41db2a:	85 c0                	test   eax,eax
  41db2c:	0f 85 36 ff ff ff    	jne    41da68 <vfprintf+0x128>
  41db32:	4c 8b 44 24 18       	mov    r8,QWORD PTR [rsp+0x18]
  41db37:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  41db3c:	e9 11 ff ff ff       	jmp    41da52 <vfprintf+0x112>
  41db41:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	FUNLOCK(f);
  41db48:	48 b8 00 cd fb ff ff 	movabs rax,0xfffffffffffbcd00
  41db4f:	ff ff ff 
  41db52:	48 89 ef             	mov    rdi,rbp
  41db55:	48 01 d8             	add    rax,rbx
  41db58:	ff d0                	call   rax
	return ret;
  41db5a:	e9 68 ff ff ff       	jmp    41dac7 <vfprintf+0x187>
		return -1;
  41db5f:	41 bc ff ff ff ff    	mov    r12d,0xffffffff
  41db65:	e9 5d ff ff ff       	jmp    41dac7 <vfprintf+0x187>
  41db6a:	48 89 4c 24 28       	mov    QWORD PTR [rsp+0x28],rcx
	if (!f->wend && __towrite(f)) ret = -1;
  41db6f:	48 89 ef             	mov    rdi,rbp
  41db72:	41 83 cc ff          	or     r12d,0xffffffff
  41db76:	48 b8 90 cd fb ff ff 	movabs rax,0xfffffffffffbcd90
  41db7d:	ff ff ff 
  41db80:	4c 89 44 24 18       	mov    QWORD PTR [rsp+0x18],r8
  41db85:	48 01 d8             	add    rax,rbx
  41db88:	ff d0                	call   rax
  41db8a:	85 c0                	test   eax,eax
  41db8c:	0f 85 0f ff ff ff    	jne    41daa1 <vfprintf+0x161>
  41db92:	eb 9e                	jmp    41db32 <vfprintf+0x1f2>
  41db94:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41db9b:	00 00 00 
  41db9e:	66 90                	xchg   ax,ax

000000000041dba0 <memchr>:
#define ONES ((size_t)-1/UCHAR_MAX)
#define HIGHS (ONES * (UCHAR_MAX/2+1))
#define HASZERO(x) ((x)-ONES & ~(x) & HIGHS)

void *memchr(const void *src, int c, size_t n)
{
  41dba0:	f3 0f 1e fa          	endbr64 
  41dba4:	48 89 f8             	mov    rax,rdi
	const unsigned char *s = src;
	c = (unsigned char)c;
  41dba7:	44 0f b6 d6          	movzx  r10d,sil
#ifdef __GNUC__
	for (; ((uintptr_t)s & ALIGN) && n && *s != c; s++, n--);
  41dbab:	a8 07                	test   al,0x7
  41dbad:	75 21                	jne    41dbd0 <memchr+0x30>
  41dbaf:	eb 2f                	jmp    41dbe0 <memchr+0x40>
  41dbb1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  41dbb8:	0f b6 08             	movzx  ecx,BYTE PTR [rax]
  41dbbb:	44 39 d1             	cmp    ecx,r10d
  41dbbe:	0f 84 7f 00 00 00    	je     41dc43 <memchr+0xa3>
  41dbc4:	48 83 c0 01          	add    rax,0x1
  41dbc8:	48 83 ea 01          	sub    rdx,0x1
  41dbcc:	a8 07                	test   al,0x7
  41dbce:	74 10                	je     41dbe0 <memchr+0x40>
  41dbd0:	48 85 d2             	test   rdx,rdx
  41dbd3:	75 e3                	jne    41dbb8 <memchr+0x18>
		for (w = (const void *)s; n>=SS && !HASZERO(*w^k); w++, n-=SS);
		s = (const void *)w;
	}
#endif
	for (; n && *s != c; s++, n--);
	return n ? (void *)s : 0;
  41dbd5:	45 31 c0             	xor    r8d,r8d
}
  41dbd8:	4c 89 c0             	mov    rax,r8
  41dbdb:	c3                   	ret    
  41dbdc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	return n ? (void *)s : 0;
  41dbe0:	45 31 c0             	xor    r8d,r8d
	if (n && *s != c) {
  41dbe3:	48 85 d2             	test   rdx,rdx
  41dbe6:	74 f0                	je     41dbd8 <memchr+0x38>
  41dbe8:	0f b6 08             	movzx  ecx,BYTE PTR [rax]
  41dbeb:	44 39 d1             	cmp    ecx,r10d
  41dbee:	74 53                	je     41dc43 <memchr+0xa3>
		size_t k = ONES * c;
  41dbf0:	48 b9 01 01 01 01 01 	movabs rcx,0x101010101010101
  41dbf7:	01 01 01 
  41dbfa:	49 63 fa             	movsxd rdi,r10d
		for (w = (const void *)s; n>=SS && !HASZERO(*w^k); w++, n-=SS);
  41dbfd:	49 b9 ff fe fe fe fe 	movabs r9,0xfefefefefefefeff
  41dc04:	fe fe fe 
  41dc07:	49 b8 80 80 80 80 80 	movabs r8,0x8080808080808080
  41dc0e:	80 80 80 
		size_t k = ONES * c;
  41dc11:	48 0f af f9          	imul   rdi,rcx
		for (w = (const void *)s; n>=SS && !HASZERO(*w^k); w++, n-=SS);
  41dc15:	48 83 fa 07          	cmp    rdx,0x7
  41dc19:	77 13                	ja     41dc2e <memchr+0x8e>
  41dc1b:	eb 26                	jmp    41dc43 <memchr+0xa3>
  41dc1d:	0f 1f 00             	nop    DWORD PTR [rax]
  41dc20:	48 83 ea 08          	sub    rdx,0x8
  41dc24:	48 83 c0 08          	add    rax,0x8
  41dc28:	48 83 fa 07          	cmp    rdx,0x7
  41dc2c:	76 3d                	jbe    41dc6b <memchr+0xcb>
  41dc2e:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  41dc31:	48 31 f9             	xor    rcx,rdi
  41dc34:	4a 8d 34 09          	lea    rsi,[rcx+r9*1]
  41dc38:	48 f7 d1             	not    rcx
  41dc3b:	48 21 f1             	and    rcx,rsi
  41dc3e:	4c 85 c1             	test   rcx,r8
  41dc41:	74 dd                	je     41dc20 <memchr+0x80>
{
  41dc43:	49 89 c0             	mov    r8,rax
  41dc46:	48 01 c2             	add    rdx,rax
  41dc49:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (; n && *s != c; s++, n--);
  41dc50:	41 0f b6 00          	movzx  eax,BYTE PTR [r8]
  41dc54:	44 39 d0             	cmp    eax,r10d
  41dc57:	0f 84 7b ff ff ff    	je     41dbd8 <memchr+0x38>
  41dc5d:	49 83 c0 01          	add    r8,0x1
  41dc61:	49 39 d0             	cmp    r8,rdx
  41dc64:	75 ea                	jne    41dc50 <memchr+0xb0>
  41dc66:	e9 6a ff ff ff       	jmp    41dbd5 <memchr+0x35>
	return n ? (void *)s : 0;
  41dc6b:	45 31 c0             	xor    r8d,r8d
	for (; n && *s != c; s++, n--);
  41dc6e:	48 85 d2             	test   rdx,rdx
  41dc71:	0f 84 61 ff ff ff    	je     41dbd8 <memchr+0x38>
  41dc77:	eb ca                	jmp    41dc43 <memchr+0xa3>
  41dc79:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000041dc80 <__strerror_l>:
static const char errmsg[] =
#include "__strerror.h"
;

char *__strerror_l(int e, locale_t loc)
{
  41dc80:	f3 0f 1e fa          	endbr64 
	 * historical typo, so we just remap it. */
	if (EDQUOT==1133) {
		if (e==109) e=-1;
		else if (e==EDQUOT) e=109;
	}
	for (i=0; errid[i] && errid[i] != e; i++);
  41dc84:	4c 8d 05 f9 ff ff ff 	lea    r8,[rip+0xfffffffffffffff9]        # 41dc84 <__strerror_l+0x4>
  41dc8b:	31 d2                	xor    edx,edx
  41dc8d:	49 bb 8c 37 04 00 00 	movabs r11,0x4378c
  41dc94:	00 00 00 
  41dc97:	48 b8 71 15 fc ff ff 	movabs rax,0xfffffffffffc1571
  41dc9e:	ff ff ff 
  41dca1:	4d 01 d8             	add    r8,r11
  41dca4:	49 8d 0c 00          	lea    rcx,[r8+rax*1]
  41dca8:	b8 54 00 00 00       	mov    eax,0x54
  41dcad:	eb 0f                	jmp    41dcbe <__strerror_l+0x3e>
  41dcaf:	90                   	nop
  41dcb0:	0f b6 01             	movzx  eax,BYTE PTR [rcx]
  41dcb3:	48 83 c1 01          	add    rcx,0x1
  41dcb7:	83 c2 01             	add    edx,0x1
  41dcba:	84 c0                	test   al,al
  41dcbc:	74 16                	je     41dcd4 <__strerror_l+0x54>
  41dcbe:	39 f8                	cmp    eax,edi
  41dcc0:	75 ee                	jne    41dcb0 <__strerror_l+0x30>
	for (s=errmsg; i; s++, i--) for (; *s; s++);
  41dcc2:	48 b8 50 0e fc ff ff 	movabs rax,0xfffffffffffc0e50
  41dcc9:	ff ff ff 
  41dccc:	49 8d 3c 00          	lea    rdi,[r8+rax*1]
  41dcd0:	85 d2                	test   edx,edx
  41dcd2:	74 44                	je     41dd18 <__strerror_l+0x98>
	for (i=0; errid[i] && errid[i] != e; i++);
  41dcd4:	48 b8 50 0e fc ff ff 	movabs rax,0xfffffffffffc0e50
  41dcdb:	ff ff ff 
  41dcde:	b9 49 00 00 00       	mov    ecx,0x49
  41dce3:	4c 01 c0             	add    rax,r8
  41dce6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41dced:	00 00 00 
	for (s=errmsg; i; s++, i--) for (; *s; s++);
  41dcf0:	84 c9                	test   cl,cl
  41dcf2:	74 0d                	je     41dd01 <__strerror_l+0x81>
  41dcf4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  41dcf8:	48 83 c0 01          	add    rax,0x1
  41dcfc:	80 38 00             	cmp    BYTE PTR [rax],0x0
  41dcff:	75 f7                	jne    41dcf8 <__strerror_l+0x78>
  41dd01:	48 8d 78 01          	lea    rdi,[rax+0x1]
  41dd05:	83 ea 01             	sub    edx,0x1
  41dd08:	74 0e                	je     41dd18 <__strerror_l+0x98>
  41dd0a:	0f b6 48 01          	movzx  ecx,BYTE PTR [rax+0x1]
  41dd0e:	48 89 f8             	mov    rax,rdi
  41dd11:	eb dd                	jmp    41dcf0 <__strerror_l+0x70>
  41dd13:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	return (char *)LCTRANS(s, LC_MESSAGES, loc);
  41dd18:	48 b8 60 c9 fb ff ff 	movabs rax,0xfffffffffffbc960
  41dd1f:	ff ff ff 
  41dd22:	48 8b 76 28          	mov    rsi,QWORD PTR [rsi+0x28]
  41dd26:	4c 01 c0             	add    rax,r8
  41dd29:	ff e0                	jmp    rax
  41dd2b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000041dd30 <strerror>:
}

char *strerror(int e)
{
  41dd30:	f3 0f 1e fa          	endbr64 
static inline struct pthread *__pthread_self()
{
	struct pthread *self;
	__asm__ ("mov %%fs:0,%0" : "=r" (self) );
  41dd34:	49 bb dc 36 04 00 00 	movabs r11,0x436dc
  41dd3b:	00 00 00 
  41dd3e:	41 57                	push   r15
  41dd40:	4c 8d 3d ed ff ff ff 	lea    r15,[rip+0xffffffffffffffed]        # 41dd34 <strerror+0x4>
  41dd47:	4d 01 df             	add    r15,r11
  41dd4a:	64 48 8b 04 25 00 00 	mov    rax,QWORD PTR fs:0x0
  41dd51:	00 00 
	return __strerror_l(e, CURRENT_LOCALE);
  41dd53:	48 8b b0 b0 00 00 00 	mov    rsi,QWORD PTR [rax+0xb0]
  41dd5a:	48 b8 70 c8 fb ff ff 	movabs rax,0xfffffffffffbc870
  41dd61:	ff ff ff 
  41dd64:	4c 01 f8             	add    rax,r15
}
  41dd67:	41 5f                	pop    r15
	return __strerror_l(e, CURRENT_LOCALE);
  41dd69:	ff e0                	jmp    rax
  41dd6b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000041dd70 <__lctrans>:

weak_alias(dummy, __lctrans_impl);

const char *__lctrans(const char *msg, const struct __locale_map *lm)
{
  41dd70:	f3 0f 1e fa          	endbr64 
	return __lctrans_impl(msg, lm);
  41dd74:	48 8d 05 f9 ff ff ff 	lea    rax,[rip+0xfffffffffffffff9]        # 41dd74 <__lctrans+0x4>
  41dd7b:	49 bb 9c 36 04 00 00 	movabs r11,0x4369c
  41dd82:	00 00 00 
  41dd85:	48 ba 50 65 fb ff ff 	movabs rdx,0xfffffffffffb6550
  41dd8c:	ff ff ff 
  41dd8f:	4c 01 d8             	add    rax,r11
  41dd92:	48 01 d0             	add    rax,rdx
  41dd95:	ff e0                	jmp    rax
  41dd97:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41dd9e:	00 00 

000000000041dda0 <__lctrans_cur>:
}

const char *__lctrans_cur(const char *msg)
{
  41dda0:	f3 0f 1e fa          	endbr64 
  41dda4:	64 48 8b 14 25 00 00 	mov    rdx,QWORD PTR fs:0x0
  41ddab:	00 00 
	return __lctrans_impl(msg, CURRENT_LOCALE->cat[LC_MESSAGES]);
  41ddad:	48 8b 92 b0 00 00 00 	mov    rdx,QWORD PTR [rdx+0xb0]
  41ddb4:	48 8d 05 e9 ff ff ff 	lea    rax,[rip+0xffffffffffffffe9]        # 41dda4 <__lctrans_cur+0x4>
  41ddbb:	49 bb 6c 36 04 00 00 	movabs r11,0x4366c
  41ddc2:	00 00 00 
  41ddc5:	4c 01 d8             	add    rax,r11
  41ddc8:	48 8b 72 28          	mov    rsi,QWORD PTR [rdx+0x28]
  41ddcc:	48 ba 50 65 fb ff ff 	movabs rdx,0xfffffffffffb6550
  41ddd3:	ff ff ff 
  41ddd6:	48 01 d0             	add    rax,rdx
  41ddd9:	ff e0                	jmp    rax
  41dddb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000041dde0 <__fpclassifyl>:
{
	return __fpclassify(x);
}
#elif LDBL_MANT_DIG == 64 && LDBL_MAX_EXP == 16384
int __fpclassifyl(long double x)
{
  41dde0:	f3 0f 1e fa          	endbr64 
	union ldshape u = {x};
	int e = u.i.se & 0x7fff;
  41dde4:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
  41dde9:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
	int msb = u.i.m>>63;
  41ddee:	48 89 d1             	mov    rcx,rdx
  41ddf1:	89 c6                	mov    esi,eax
	int e = u.i.se & 0x7fff;
  41ddf3:	25 ff 7f 00 00       	and    eax,0x7fff
	int msb = u.i.m>>63;
  41ddf8:	48 c1 e9 3f          	shr    rcx,0x3f
  41ddfc:	66 81 e6 ff 7f       	and    si,0x7fff
	if (!e && !msb)
  41de01:	09 c8                	or     eax,ecx
  41de03:	74 2b                	je     41de30 <__fpclassifyl+0x50>
		 * the version with it clear. */
		if (__BYTE_ORDER == __LITTLE_ENDIAN && !msb)
			return FP_NAN;
		return u.i.m << 1 ? FP_NAN : FP_INFINITE;
	}
	if (!msb)
  41de05:	8d 04 8d 00 00 00 00 	lea    eax,[rcx*4+0x0]
	if (e == 0x7fff) {
  41de0c:	66 81 fe ff 7f       	cmp    si,0x7fff
  41de11:	74 05                	je     41de18 <__fpclassifyl+0x38>
		return FP_NAN;
	return FP_NORMAL;
}
  41de13:	c3                   	ret    
  41de14:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
			return FP_NAN;
  41de18:	31 c0                	xor    eax,eax
		if (__BYTE_ORDER == __LITTLE_ENDIAN && !msb)
  41de1a:	48 85 c9             	test   rcx,rcx
  41de1d:	74 f4                	je     41de13 <__fpclassifyl+0x33>
		return u.i.m << 1 ? FP_NAN : FP_INFINITE;
  41de1f:	31 c0                	xor    eax,eax
  41de21:	48 01 d2             	add    rdx,rdx
  41de24:	0f 94 c0             	sete   al
}
  41de27:	c3                   	ret    
  41de28:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41de2f:	00 
		return u.i.m ? FP_SUBNORMAL : FP_ZERO;
  41de30:	48 83 fa 01          	cmp    rdx,0x1
  41de34:	b8 02 00 00 00       	mov    eax,0x2
  41de39:	83 d8 ff             	sbb    eax,0xffffffff
  41de3c:	c3                   	ret    
  41de3d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000041de40 <__signbitl>:
#include "libm.h"

#if (LDBL_MANT_DIG == 64 || LDBL_MANT_DIG == 113) && LDBL_MAX_EXP == 16384
int __signbitl(long double x)
{
  41de40:	f3 0f 1e fa          	endbr64 
	union ldshape u = {x};
	return u.i.se >> 15;
  41de44:	0f b7 44 24 10       	movzx  eax,WORD PTR [rsp+0x10]
  41de49:	66 c1 e8 0f          	shr    ax,0xf
  41de4d:	0f b7 c0             	movzx  eax,ax
}
  41de50:	c3                   	ret    
  41de51:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41de58:	00 00 00 
  41de5b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000041de60 <frexpl>:
{
	return frexp(x, e);
}
#elif (LDBL_MANT_DIG == 64 || LDBL_MANT_DIG == 113) && LDBL_MAX_EXP == 16384
long double frexpl(long double x, int *e)
{
  41de60:	f3 0f 1e fa          	endbr64 
  41de64:	48 83 ec 48          	sub    rsp,0x48
  41de68:	48 8d 15 f5 ff ff ff 	lea    rdx,[rip+0xfffffffffffffff5]        # 41de64 <frexpl+0x4>
  41de6f:	49 bb ac 35 04 00 00 	movabs r11,0x435ac
  41de76:	00 00 00 
	union ldshape u = {x};
  41de79:	db 6c 24 50          	fld    TBYTE PTR [rsp+0x50]
  41de7d:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  41de82:	4c 01 da             	add    rdx,r11
	int ee = u.i.se & 0x7fff;

	if (!ee) {
  41de85:	89 c1                	mov    ecx,eax
	union ldshape u = {x};
  41de87:	d9 c0                	fld    st(0)
  41de89:	db 7c 24 20          	fstp   TBYTE PTR [rsp+0x20]
	if (!ee) {
  41de8d:	66 81 e1 ff 7f       	and    cx,0x7fff
  41de92:	74 3c                	je     41ded0 <frexpl+0x70>
  41de94:	dd d8                	fstp   st(0)
			x = frexpl(x*0x1p120, e);
			*e -= 120;
		} else *e = 0;
		return x;
	} else if (ee == 0x7fff) {
		return x;
  41de96:	db 6c 24 50          	fld    TBYTE PTR [rsp+0x50]
	int ee = u.i.se & 0x7fff;
  41de9a:	0f b7 d1             	movzx  edx,cx
		return x;
  41de9d:	db 3c 24             	fstp   TBYTE PTR [rsp]
	} else if (ee == 0x7fff) {
  41dea0:	66 81 f9 ff 7f       	cmp    cx,0x7fff
  41dea5:	74 1c                	je     41dec3 <frexpl+0x63>
	}

	*e = ee - 0x3ffe;
	u.i.se &= 0x8000;
  41dea7:	66 25 00 80          	and    ax,0x8000
	*e = ee - 0x3ffe;
  41deab:	81 ea fe 3f 00 00    	sub    edx,0x3ffe
	u.i.se |= 0x3ffe;
  41deb1:	66 0d fe 3f          	or     ax,0x3ffe
	*e = ee - 0x3ffe;
  41deb5:	89 17                	mov    DWORD PTR [rdi],edx
	u.i.se |= 0x3ffe;
  41deb7:	66 89 44 24 28       	mov    WORD PTR [rsp+0x28],ax
	return u.f;
  41debc:	db 6c 24 20          	fld    TBYTE PTR [rsp+0x20]
  41dec0:	db 3c 24             	fstp   TBYTE PTR [rsp]
}
  41dec3:	db 2c 24             	fld    TBYTE PTR [rsp]
  41dec6:	48 83 c4 48          	add    rsp,0x48
  41deca:	c3                   	ret    
  41decb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		if (x) {
  41ded0:	d9 ee                	fldz   
  41ded2:	d9 c9                	fxch   st(1)
  41ded4:	df e9                	fucomip st,st(1)
  41ded6:	dd d8                	fstp   st(0)
  41ded8:	7a 1e                	jp     41def8 <frexpl+0x98>
  41deda:	75 1c                	jne    41def8 <frexpl+0x98>
		} else *e = 0;
  41dedc:	db 6c 24 50          	fld    TBYTE PTR [rsp+0x50]
  41dee0:	c7 07 00 00 00 00    	mov    DWORD PTR [rdi],0x0
  41dee6:	db 3c 24             	fstp   TBYTE PTR [rsp]
}
  41dee9:	db 2c 24             	fld    TBYTE PTR [rsp]
  41deec:	48 83 c4 48          	add    rsp,0x48
  41def0:	c3                   	ret    
  41def1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
			x = frexpl(x*0x1p120, e);
  41def8:	48 be 9c 0d fc ff ff 	movabs rsi,0xfffffffffffc0d9c
  41deff:	ff ff ff 
  41df02:	db 6c 24 50          	fld    TBYTE PTR [rsp+0x50]
  41df06:	d8 0c 16             	fmul   DWORD PTR [rsi+rdx*1]
  41df09:	d9 c0                	fld    st(0)
  41df0b:	db 3c 24             	fstp   TBYTE PTR [rsp]
	union ldshape u = {x};
  41df0e:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
	if (!ee) {
  41df13:	89 c1                	mov    ecx,eax
	union ldshape u = {x};
  41df15:	d9 c0                	fld    st(0)
  41df17:	db 7c 24 30          	fstp   TBYTE PTR [rsp+0x30]
	if (!ee) {
  41df1b:	66 81 e1 ff 7f       	and    cx,0x7fff
  41df20:	74 36                	je     41df58 <frexpl+0xf8>
  41df22:	dd d8                	fstp   st(0)
	int ee = u.i.se & 0x7fff;
  41df24:	0f b7 d1             	movzx  edx,cx
	} else if (ee == 0x7fff) {
  41df27:	66 81 f9 ff 7f       	cmp    cx,0x7fff
  41df2c:	74 72                	je     41dfa0 <frexpl+0x140>
	u.i.se &= 0x8000;
  41df2e:	66 25 00 80          	and    ax,0x8000
	u.i.se |= 0x3ffe;
  41df32:	66 0d fe 3f          	or     ax,0x3ffe
  41df36:	66 89 44 24 38       	mov    WORD PTR [rsp+0x38],ax
	return u.f;
  41df3b:	db 6c 24 30          	fld    TBYTE PTR [rsp+0x30]
			*e -= 120;
  41df3f:	8d 82 8a bf ff ff    	lea    eax,[rdx-0x4076]
	return u.f;
  41df45:	db 3c 24             	fstp   TBYTE PTR [rsp]
			*e -= 120;
  41df48:	89 07                	mov    DWORD PTR [rdi],eax
}
  41df4a:	db 2c 24             	fld    TBYTE PTR [rsp]
  41df4d:	48 83 c4 48          	add    rsp,0x48
  41df51:	c3                   	ret    
  41df52:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
		if (x) {
  41df58:	d9 ee                	fldz   
  41df5a:	d9 c9                	fxch   st(1)
  41df5c:	df e9                	fucomip st,st(1)
  41df5e:	dd d8                	fstp   st(0)
  41df60:	7a 07                	jp     41df69 <frexpl+0x109>
  41df62:	b8 88 ff ff ff       	mov    eax,0xffffff88
  41df67:	74 df                	je     41df48 <frexpl+0xe8>
			x = frexpl(x*0x1p120, e);
  41df69:	db 2c 24             	fld    TBYTE PTR [rsp]
  41df6c:	d8 0c 16             	fmul   DWORD PTR [rsi+rdx*1]
  41df6f:	48 83 ec 10          	sub    rsp,0x10
  41df73:	48 b8 50 ca fb ff ff 	movabs rax,0xfffffffffffbca50
  41df7a:	ff ff ff 
  41df7d:	48 89 7c 24 28       	mov    QWORD PTR [rsp+0x28],rdi
  41df82:	48 01 d0             	add    rax,rdx
  41df85:	db 3c 24             	fstp   TBYTE PTR [rsp]
  41df88:	ff d0                	call   rax
			*e -= 120;
  41df8a:	48 8b 7c 24 28       	mov    rdi,QWORD PTR [rsp+0x28]
			x = frexpl(x*0x1p120, e);
  41df8f:	db 7c 24 10          	fstp   TBYTE PTR [rsp+0x10]
			*e -= 120;
  41df93:	5a                   	pop    rdx
  41df94:	59                   	pop    rcx
  41df95:	8b 07                	mov    eax,DWORD PTR [rdi]
  41df97:	2d f0 00 00 00       	sub    eax,0xf0
  41df9c:	89 07                	mov    DWORD PTR [rdi],eax
  41df9e:	eb aa                	jmp    41df4a <frexpl+0xea>
  41dfa0:	8b 07                	mov    eax,DWORD PTR [rdi]
  41dfa2:	83 e8 78             	sub    eax,0x78
  41dfa5:	89 07                	mov    DWORD PTR [rdi],eax
  41dfa7:	eb a1                	jmp    41df4a <frexpl+0xea>
  41dfa9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000041dfb0 <wctomb>:
#include <stdlib.h>
#include <wchar.h>

int wctomb(char *s, wchar_t wc)
{
  41dfb0:	f3 0f 1e fa          	endbr64 
	if (!s) return 0;
  41dfb4:	49 bb 5c 34 04 00 00 	movabs r11,0x4345c
  41dfbb:	00 00 00 
{
  41dfbe:	41 57                	push   r15
  41dfc0:	31 c0                	xor    eax,eax
  41dfc2:	4c 8d 3d eb ff ff ff 	lea    r15,[rip+0xffffffffffffffeb]        # 41dfb4 <wctomb+0x4>
  41dfc9:	4d 01 df             	add    r15,r11
	if (!s) return 0;
  41dfcc:	48 85 ff             	test   rdi,rdi
  41dfcf:	74 11                	je     41dfe2 <wctomb+0x32>
	return wcrtomb(s, wc, 0);
  41dfd1:	48 b8 30 d1 fb ff ff 	movabs rax,0xfffffffffffbd130
  41dfd8:	ff ff ff 
  41dfdb:	31 d2                	xor    edx,edx
  41dfdd:	4c 01 f8             	add    rax,r15
  41dfe0:	ff d0                	call   rax
}
  41dfe2:	41 5f                	pop    r15
  41dfe4:	c3                   	ret    
  41dfe5:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41dfec:	00 00 00 
  41dfef:	90                   	nop

000000000041dff0 <__lockfile>:
#include "stdio_impl.h"
#include "pthread_impl.h"

int __lockfile(FILE *f)
{
  41dff0:	f3 0f 1e fa          	endbr64 
	int owner = f->lock, tid = __pthread_self()->tid;
  41dff4:	49 bb 1c 34 04 00 00 	movabs r11,0x4341c
  41dffb:	00 00 00 
{
  41dffe:	41 57                	push   r15
	if ((owner & ~MAYBE_WAITERS) == tid)
		return 0;
  41e000:	45 31 c0             	xor    r8d,r8d
  41e003:	4c 8d 3d ea ff ff ff 	lea    r15,[rip+0xffffffffffffffea]        # 41dff4 <__lockfile+0x4>
{
  41e00a:	41 56                	push   r14
  41e00c:	4d 01 df             	add    r15,r11
  41e00f:	41 55                	push   r13
  41e011:	41 54                	push   r12
  41e013:	55                   	push   rbp
  41e014:	53                   	push   rbx
  41e015:	64 48 8b 14 25 00 00 	mov    rdx,QWORD PTR fs:0x0
  41e01c:	00 00 
  41e01e:	48 83 ec 08          	sub    rsp,0x8
	int owner = f->lock, tid = __pthread_self()->tid;
  41e022:	8b 87 8c 00 00 00    	mov    eax,DWORD PTR [rdi+0x8c]
  41e028:	8b 5a 38             	mov    ebx,DWORD PTR [rdx+0x38]
	if ((owner & ~MAYBE_WAITERS) == tid)
  41e02b:	25 ff ff ff bf       	and    eax,0xbfffffff
  41e030:	39 d8                	cmp    eax,ebx
  41e032:	0f 84 c6 00 00 00    	je     41e0fe <__lockfile+0x10e>
	owner = a_cas(&f->lock, 0, tid);
  41e038:	4c 8d a7 8c 00 00 00 	lea    r12,[rdi+0x8c]
	__asm__ __volatile__ (
  41e03f:	44 89 c0             	mov    eax,r8d
  41e042:	f0 0f b1 9f 8c 00 00 	lock cmpxchg DWORD PTR [rdi+0x8c],ebx
  41e049:	00 
	if (!owner) return 1;
  41e04a:	85 c0                	test   eax,eax
  41e04c:	0f 84 a6 00 00 00    	je     41e0f8 <__lockfile+0x108>
	while ((owner = a_cas(&f->lock, 0, tid|MAYBE_WAITERS))) {
  41e052:	81 cb 00 00 00 40    	or     ebx,0x40000000
  41e058:	44 89 c0             	mov    eax,r8d
  41e05b:	f0 0f b1 9f 8c 00 00 	lock cmpxchg DWORD PTR [rdi+0x8c],ebx
  41e062:	00 
  41e063:	89 c2                	mov    edx,eax
  41e065:	85 c0                	test   eax,eax
  41e067:	0f 84 8b 00 00 00    	je     41e0f8 <__lockfile+0x108>
	return __cos_syscall(n, a1, a2, a3, a4, 0, 0, 0);
  41e06d:	48 bd 50 a1 fa ff ff 	movabs rbp,0xfffffffffffaa150
  41e074:	ff ff ff 
  41e077:	eb 21                	jmp    41e09a <__lockfile+0xaa>
  41e079:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  41e080:	89 d0                	mov    eax,edx
  41e082:	f0 41 0f b1 0c 24    	lock cmpxchg DWORD PTR [r12],ecx
		if ((owner & MAYBE_WAITERS) ||
  41e088:	39 d0                	cmp    eax,edx
  41e08a:	74 1e                	je     41e0aa <__lockfile+0xba>
  41e08c:	31 c0                	xor    eax,eax
  41e08e:	f0 41 0f b1 1c 24    	lock cmpxchg DWORD PTR [r12],ebx
  41e094:	89 c2                	mov    edx,eax
	while ((owner = a_cas(&f->lock, 0, tid|MAYBE_WAITERS))) {
  41e096:	85 c0                	test   eax,eax
  41e098:	74 5e                	je     41e0f8 <__lockfile+0x108>
		    a_cas(&f->lock, owner, owner|MAYBE_WAITERS)==owner)
  41e09a:	89 d1                	mov    ecx,edx
  41e09c:	81 c9 00 00 00 40    	or     ecx,0x40000000
		if ((owner & MAYBE_WAITERS) ||
  41e0a2:	f7 c2 00 00 00 40    	test   edx,0x40000000
  41e0a8:	74 d6                	je     41e080 <__lockfile+0x90>
	__syscall(SYS_futex, addr, FUTEX_WAKE, cnt);
}
static inline void __futexwait(volatile void *addr, int val, int priv)
{
	if (priv) priv = FUTEX_PRIVATE;
	__syscall(SYS_futex, addr, FUTEX_WAIT|priv, val, 0) != -ENOSYS ||
  41e0aa:	4c 63 e9             	movsxd r13,ecx
  41e0ad:	6a 00                	push   0x0
  41e0af:	4c 89 e6             	mov    rsi,r12
  41e0b2:	45 31 c9             	xor    r9d,r9d
  41e0b5:	6a 00                	push   0x0
  41e0b7:	4c 89 e9             	mov    rcx,r13
  41e0ba:	45 31 c0             	xor    r8d,r8d
  41e0bd:	ba 80 00 00 00       	mov    edx,0x80
  41e0c2:	bf ca 00 00 00       	mov    edi,0xca
  41e0c7:	4e 8d 74 3d 00       	lea    r14,[rbp+r15*1+0x0]
  41e0cc:	41 ff d6             	call   r14
  41e0cf:	59                   	pop    rcx
  41e0d0:	5e                   	pop    rsi
  41e0d1:	48 83 f8 da          	cmp    rax,0xffffffffffffffda
  41e0d5:	75 b5                	jne    41e08c <__lockfile+0x9c>
  41e0d7:	6a 00                	push   0x0
  41e0d9:	31 d2                	xor    edx,edx
  41e0db:	45 31 c9             	xor    r9d,r9d
  41e0de:	45 31 c0             	xor    r8d,r8d
  41e0e1:	6a 00                	push   0x0
  41e0e3:	4c 89 e9             	mov    rcx,r13
  41e0e6:	4c 89 e6             	mov    rsi,r12
  41e0e9:	bf ca 00 00 00       	mov    edi,0xca
  41e0ee:	41 ff d6             	call   r14
  41e0f1:	58                   	pop    rax
  41e0f2:	5a                   	pop    rdx
  41e0f3:	eb 97                	jmp    41e08c <__lockfile+0x9c>
  41e0f5:	0f 1f 00             	nop    DWORD PTR [rax]
	if (!owner) return 1;
  41e0f8:	41 b8 01 00 00 00    	mov    r8d,0x1
			__futexwait(&f->lock, owner|MAYBE_WAITERS, 1);
	}
	return 1;
}
  41e0fe:	48 83 c4 08          	add    rsp,0x8
  41e102:	44 89 c0             	mov    eax,r8d
  41e105:	5b                   	pop    rbx
  41e106:	5d                   	pop    rbp
  41e107:	41 5c                	pop    r12
  41e109:	41 5d                	pop    r13
  41e10b:	41 5e                	pop    r14
  41e10d:	41 5f                	pop    r15
  41e10f:	c3                   	ret    

000000000041e110 <__unlockfile>:

void __unlockfile(FILE *f)
{
  41e110:	f3 0f 1e fa          	endbr64 
	__asm__ __volatile__(
  41e114:	49 bb fc 32 04 00 00 	movabs r11,0x432fc
  41e11b:	00 00 00 
  41e11e:	41 57                	push   r15
  41e120:	31 c0                	xor    eax,eax
  41e122:	4c 8d 3d eb ff ff ff 	lea    r15,[rip+0xffffffffffffffeb]        # 41e114 <__unlockfile+0x4>
  41e129:	55                   	push   rbp
  41e12a:	4d 01 df             	add    r15,r11
  41e12d:	53                   	push   rbx
  41e12e:	87 87 8c 00 00 00    	xchg   DWORD PTR [rdi+0x8c],eax
	if (a_swap(&f->lock, 0) & MAYBE_WAITERS)
  41e134:	a9 00 00 00 40       	test   eax,0x40000000
  41e139:	75 05                	jne    41e140 <__unlockfile+0x30>
		__wake(&f->lock, 1, 1);
}
  41e13b:	5b                   	pop    rbx
  41e13c:	5d                   	pop    rbp
  41e13d:	41 5f                	pop    r15
  41e13f:	c3                   	ret    
  41e140:	48 8d af 8c 00 00 00 	lea    rbp,[rdi+0x8c]
	return __cos_syscall(n, a1, a2, a3, 0, 0, 0, 0);
  41e147:	6a 00                	push   0x0
  41e149:	45 31 c9             	xor    r9d,r9d
  41e14c:	45 31 c0             	xor    r8d,r8d
  41e14f:	6a 00                	push   0x0
  41e151:	b9 01 00 00 00       	mov    ecx,0x1
  41e156:	48 89 ee             	mov    rsi,rbp
  41e159:	ba 81 00 00 00       	mov    edx,0x81
  41e15e:	48 bb 50 a1 fa ff ff 	movabs rbx,0xfffffffffffaa150
  41e165:	ff ff ff 
  41e168:	bf ca 00 00 00       	mov    edi,0xca
  41e16d:	4c 01 fb             	add    rbx,r15
  41e170:	ff d3                	call   rbx
	__syscall(SYS_futex, addr, FUTEX_WAKE|priv, cnt) != -ENOSYS ||
  41e172:	59                   	pop    rcx
  41e173:	5e                   	pop    rsi
  41e174:	48 83 f8 da          	cmp    rax,0xffffffffffffffda
  41e178:	75 c1                	jne    41e13b <__unlockfile+0x2b>
  41e17a:	6a 00                	push   0x0
  41e17c:	ba 01 00 00 00       	mov    edx,0x1
  41e181:	45 31 c9             	xor    r9d,r9d
  41e184:	45 31 c0             	xor    r8d,r8d
  41e187:	6a 00                	push   0x0
  41e189:	b9 01 00 00 00       	mov    ecx,0x1
  41e18e:	48 89 ee             	mov    rsi,rbp
  41e191:	bf ca 00 00 00       	mov    edi,0xca
  41e196:	ff d3                	call   rbx
  41e198:	58                   	pop    rax
  41e199:	5a                   	pop    rdx
  41e19a:	eb 9f                	jmp    41e13b <__unlockfile+0x2b>
  41e19c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000041e1a0 <__towrite>:
#include "stdio_impl.h"

int __towrite(FILE *f)
{
  41e1a0:	f3 0f 1e fa          	endbr64 
	f->mode |= f->mode-1;
  41e1a4:	8b 97 88 00 00 00    	mov    edx,DWORD PTR [rdi+0x88]
  41e1aa:	8d 42 ff             	lea    eax,[rdx-0x1]
  41e1ad:	09 d0                	or     eax,edx
  41e1af:	89 87 88 00 00 00    	mov    DWORD PTR [rdi+0x88],eax
	if (f->flags & F_NOWR) {
  41e1b5:	8b 07                	mov    eax,DWORD PTR [rdi]
  41e1b7:	a8 08                	test   al,0x8
  41e1b9:	75 35                	jne    41e1f0 <__towrite+0x50>
	}
	/* Clear read buffer (easier than summoning nasal demons) */
	f->rpos = f->rend = 0;

	/* Activate write through the buffer. */
	f->wpos = f->wbase = f->buf;
  41e1bb:	48 8b 47 58          	mov    rax,QWORD PTR [rdi+0x58]
	f->wend = f->buf + f->buf_size;
  41e1bf:	48 8b 4f 60          	mov    rcx,QWORD PTR [rdi+0x60]
	f->rpos = f->rend = 0;
  41e1c3:	66 0f ef c0          	pxor   xmm0,xmm0
  41e1c7:	0f 11 47 08          	movups XMMWORD PTR [rdi+0x8],xmm0
	f->wend = f->buf + f->buf_size;
  41e1cb:	48 01 c1             	add    rcx,rax
  41e1ce:	66 48 0f 6e c8       	movq   xmm1,rax
	f->wpos = f->wbase = f->buf;
  41e1d3:	48 89 47 38          	mov    QWORD PTR [rdi+0x38],rax

	return 0;
  41e1d7:	31 c0                	xor    eax,eax
	f->wend = f->buf + f->buf_size;
  41e1d9:	66 48 0f 6e c1       	movq   xmm0,rcx
  41e1de:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  41e1e2:	0f 11 47 20          	movups XMMWORD PTR [rdi+0x20],xmm0
}
  41e1e6:	c3                   	ret    
  41e1e7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41e1ee:	00 00 
		f->flags |= F_ERR;
  41e1f0:	83 c8 20             	or     eax,0x20
  41e1f3:	89 07                	mov    DWORD PTR [rdi],eax
		return EOF;
  41e1f5:	b8 ff ff ff ff       	mov    eax,0xffffffff
  41e1fa:	c3                   	ret    
  41e1fb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000041e200 <__towrite_needs_stdio_exit>:

hidden void __towrite_needs_stdio_exit()
{
  41e200:	f3 0f 1e fa          	endbr64 
	__stdio_exit_needed();
  41e204:	48 8d 05 f9 ff ff ff 	lea    rax,[rip+0xfffffffffffffff9]        # 41e204 <__towrite_needs_stdio_exit+0x4>
  41e20b:	49 bb 0c 32 04 00 00 	movabs r11,0x4320c
  41e212:	00 00 00 
  41e215:	48 ba 90 d2 fb ff ff 	movabs rdx,0xfffffffffffbd290
  41e21c:	ff ff ff 
  41e21f:	4c 01 d8             	add    rax,r11
  41e222:	48 01 d0             	add    rax,rdx
  41e225:	ff e0                	jmp    rax
  41e227:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41e22e:	00 00 

000000000041e230 <__fwritex>:
#include "stdio_impl.h"
#include <string.h>

size_t __fwritex(const unsigned char *restrict s, size_t l, FILE *restrict f)
{
  41e230:	f3 0f 1e fa          	endbr64 
	size_t i=0;

	if (!f->wend && __towrite(f)) return 0;
  41e234:	49 bb dc 31 04 00 00 	movabs r11,0x431dc
  41e23b:	00 00 00 
{
  41e23e:	41 57                	push   r15
  41e240:	4c 8d 3d ed ff ff ff 	lea    r15,[rip+0xffffffffffffffed]        # 41e234 <__fwritex+0x4>
  41e247:	41 56                	push   r14
  41e249:	4d 01 df             	add    r15,r11
  41e24c:	41 55                	push   r13
  41e24e:	49 89 f5             	mov    r13,rsi
  41e251:	41 54                	push   r12
  41e253:	49 89 d4             	mov    r12,rdx
  41e256:	55                   	push   rbp
  41e257:	48 89 fd             	mov    rbp,rdi
  41e25a:	53                   	push   rbx
  41e25b:	48 83 ec 08          	sub    rsp,0x8
	if (!f->wend && __towrite(f)) return 0;
  41e25f:	48 8b 42 20          	mov    rax,QWORD PTR [rdx+0x20]
  41e263:	48 85 c0             	test   rax,rax
  41e266:	0f 84 c4 00 00 00    	je     41e330 <__fwritex+0x100>

	if (l > f->wend - f->wpos) return f->write(f, s, l);
  41e26c:	49 8b 7c 24 28       	mov    rdi,QWORD PTR [r12+0x28]
  41e271:	48 29 f8             	sub    rax,rdi
  41e274:	4c 39 e8             	cmp    rax,r13
  41e277:	72 5f                	jb     41e2d8 <__fwritex+0xa8>

	if (f->lbf >= 0) {
  41e279:	41 8b 84 24 90 00 00 	mov    eax,DWORD PTR [r12+0x90]
  41e280:	00 
  41e281:	4c 89 eb             	mov    rbx,r13
  41e284:	85 c0                	test   eax,eax
  41e286:	79 46                	jns    41e2ce <__fwritex+0x9e>
  41e288:	4d 89 ee             	mov    r14,r13
			s += i;
			l -= i;
		}
	}

	memcpy(f->wpos, s, l);
  41e28b:	48 b8 0a 64 fb ff ff 	movabs rax,0xfffffffffffb640a
  41e292:	ff ff ff 
  41e295:	4c 89 f2             	mov    rdx,r14
  41e298:	48 89 ee             	mov    rsi,rbp
  41e29b:	4c 01 f8             	add    rax,r15
  41e29e:	ff d0                	call   rax
	f->wpos += l;
  41e2a0:	4d 01 74 24 28       	add    QWORD PTR [r12+0x28],r14
	return l+i;
  41e2a5:	4c 89 e8             	mov    rax,r13
}
  41e2a8:	48 83 c4 08          	add    rsp,0x8
  41e2ac:	5b                   	pop    rbx
  41e2ad:	5d                   	pop    rbp
  41e2ae:	41 5c                	pop    r12
  41e2b0:	41 5d                	pop    r13
  41e2b2:	41 5e                	pop    r14
  41e2b4:	41 5f                	pop    r15
  41e2b6:	c3                   	ret    
  41e2b7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41e2be:	00 00 
		for (i=l; i && s[i-1] != '\n'; i--);
  41e2c0:	80 7c 1d ff 0a       	cmp    BYTE PTR [rbp+rbx*1-0x1],0xa
  41e2c5:	48 8d 43 ff          	lea    rax,[rbx-0x1]
  41e2c9:	74 35                	je     41e300 <__fwritex+0xd0>
  41e2cb:	48 89 c3             	mov    rbx,rax
  41e2ce:	48 85 db             	test   rbx,rbx
  41e2d1:	75 ed                	jne    41e2c0 <__fwritex+0x90>
  41e2d3:	eb b3                	jmp    41e288 <__fwritex+0x58>
  41e2d5:	0f 1f 00             	nop    DWORD PTR [rax]
	if (l > f->wend - f->wpos) return f->write(f, s, l);
  41e2d8:	49 8b 44 24 48       	mov    rax,QWORD PTR [r12+0x48]
}
  41e2dd:	48 83 c4 08          	add    rsp,0x8
	if (l > f->wend - f->wpos) return f->write(f, s, l);
  41e2e1:	4c 89 ea             	mov    rdx,r13
  41e2e4:	48 89 ee             	mov    rsi,rbp
}
  41e2e7:	5b                   	pop    rbx
	if (l > f->wend - f->wpos) return f->write(f, s, l);
  41e2e8:	4c 89 e7             	mov    rdi,r12
}
  41e2eb:	5d                   	pop    rbp
  41e2ec:	41 5c                	pop    r12
  41e2ee:	41 5d                	pop    r13
  41e2f0:	41 5e                	pop    r14
  41e2f2:	41 5f                	pop    r15
	if (l > f->wend - f->wpos) return f->write(f, s, l);
  41e2f4:	ff e0                	jmp    rax
  41e2f6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41e2fd:	00 00 00 
			size_t n = f->write(f, s, i);
  41e300:	48 89 da             	mov    rdx,rbx
  41e303:	48 89 ee             	mov    rsi,rbp
  41e306:	4c 89 e7             	mov    rdi,r12
  41e309:	41 ff 54 24 48       	call   QWORD PTR [r12+0x48]
			if (n < i) return n;
  41e30e:	48 39 c3             	cmp    rbx,rax
  41e311:	77 95                	ja     41e2a8 <__fwritex+0x78>
			l -= i;
  41e313:	4d 89 ee             	mov    r14,r13
	memcpy(f->wpos, s, l);
  41e316:	49 8b 7c 24 28       	mov    rdi,QWORD PTR [r12+0x28]
			s += i;
  41e31b:	48 01 dd             	add    rbp,rbx
			l -= i;
  41e31e:	49 29 de             	sub    r14,rbx
  41e321:	e9 65 ff ff ff       	jmp    41e28b <__fwritex+0x5b>
  41e326:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41e32d:	00 00 00 
	if (!f->wend && __towrite(f)) return 0;
  41e330:	48 b8 90 cd fb ff ff 	movabs rax,0xfffffffffffbcd90
  41e337:	ff ff ff 
  41e33a:	48 89 d7             	mov    rdi,rdx
  41e33d:	4c 01 f8             	add    rax,r15
  41e340:	ff d0                	call   rax
  41e342:	85 c0                	test   eax,eax
  41e344:	75 0a                	jne    41e350 <__fwritex+0x120>
	if (l > f->wend - f->wpos) return f->write(f, s, l);
  41e346:	49 8b 44 24 20       	mov    rax,QWORD PTR [r12+0x20]
  41e34b:	e9 1c ff ff ff       	jmp    41e26c <__fwritex+0x3c>
	if (!f->wend && __towrite(f)) return 0;
  41e350:	31 c0                	xor    eax,eax
  41e352:	e9 51 ff ff ff       	jmp    41e2a8 <__fwritex+0x78>
  41e357:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41e35e:	00 00 

000000000041e360 <fwrite>:

size_t fwrite(const void *restrict src, size_t size, size_t nmemb, FILE *restrict f)
{
  41e360:	f3 0f 1e fa          	endbr64 
  41e364:	41 57                	push   r15
	size_t k, l = size*nmemb;
	if (!size) nmemb = 0;
  41e366:	31 c0                	xor    eax,eax
{
  41e368:	49 89 ff             	mov    r15,rdi
  41e36b:	49 89 c8             	mov    r8,rcx
  41e36e:	49 bb ac 30 04 00 00 	movabs r11,0x430ac
  41e375:	00 00 00 
  41e378:	41 56                	push   r14
  41e37a:	4c 8d 35 e3 ff ff ff 	lea    r14,[rip+0xffffffffffffffe3]        # 41e364 <fwrite+0x4>
  41e381:	41 55                	push   r13
	size_t k, l = size*nmemb;
  41e383:	49 89 f5             	mov    r13,rsi
  41e386:	4d 01 de             	add    r14,r11
{
  41e389:	41 54                	push   r12
	size_t k, l = size*nmemb;
  41e38b:	4c 0f af ea          	imul   r13,rdx
{
  41e38f:	49 89 f4             	mov    r12,rsi
  41e392:	55                   	push   rbp
  41e393:	48 89 d5             	mov    rbp,rdx
  41e396:	53                   	push   rbx
  41e397:	48 83 ec 28          	sub    rsp,0x28
	if (!size) nmemb = 0;
  41e39b:	48 85 f6             	test   rsi,rsi
  41e39e:	48 0f 44 e8          	cmove  rbp,rax
	FLOCK(f);
  41e3a2:	8b 81 8c 00 00 00    	mov    eax,DWORD PTR [rcx+0x8c]
  41e3a8:	c7 44 24 08 00 00 00 	mov    DWORD PTR [rsp+0x8],0x0
  41e3af:	00 
  41e3b0:	85 c0                	test   eax,eax
  41e3b2:	78 20                	js     41e3d4 <fwrite+0x74>
  41e3b4:	48 b8 e0 cb fb ff ff 	movabs rax,0xfffffffffffbcbe0
  41e3bb:	ff ff ff 
  41e3be:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  41e3c3:	48 89 cf             	mov    rdi,rcx
  41e3c6:	4c 01 f0             	add    rax,r14
  41e3c9:	ff d0                	call   rax
  41e3cb:	4c 8b 44 24 10       	mov    r8,QWORD PTR [rsp+0x10]
  41e3d0:	89 44 24 08          	mov    DWORD PTR [rsp+0x8],eax
	if (!f->wend && __towrite(f)) return 0;
  41e3d4:	49 8b 40 20          	mov    rax,QWORD PTR [r8+0x20]
  41e3d8:	48 85 c0             	test   rax,rax
  41e3db:	0f 84 1f 01 00 00    	je     41e500 <fwrite+0x1a0>
	if (l > f->wend - f->wpos) return f->write(f, s, l);
  41e3e1:	49 8b 78 28          	mov    rdi,QWORD PTR [r8+0x28]
  41e3e5:	48 29 f8             	sub    rax,rdi
  41e3e8:	49 39 c5             	cmp    r13,rax
  41e3eb:	77 73                	ja     41e460 <fwrite+0x100>
	if (f->lbf >= 0) {
  41e3ed:	41 8b b0 90 00 00 00 	mov    esi,DWORD PTR [r8+0x90]
  41e3f4:	4c 89 eb             	mov    rbx,r13
  41e3f7:	85 f6                	test   esi,esi
  41e3f9:	79 5c                	jns    41e457 <fwrite+0xf7>
  41e3fb:	4c 89 ea             	mov    rdx,r13
	memcpy(f->wpos, s, l);
  41e3fe:	48 b8 0a 64 fb ff ff 	movabs rax,0xfffffffffffb640a
  41e405:	ff ff ff 
  41e408:	4c 89 44 24 18       	mov    QWORD PTR [rsp+0x18],r8
  41e40d:	4c 89 fe             	mov    rsi,r15
  41e410:	4d 89 f7             	mov    r15,r14
  41e413:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
  41e418:	4c 01 f0             	add    rax,r14
  41e41b:	ff d0                	call   rax
	f->wpos += l;
  41e41d:	4c 8b 44 24 18       	mov    r8,QWORD PTR [rsp+0x18]
	k = __fwritex(src, l, f);
	FUNLOCK(f);
  41e422:	8b 4c 24 08          	mov    ecx,DWORD PTR [rsp+0x8]
	f->wpos += l;
  41e426:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
  41e42b:	49 01 50 28          	add    QWORD PTR [r8+0x28],rdx
	FUNLOCK(f);
  41e42f:	85 c9                	test   ecx,ecx
  41e431:	75 6d                	jne    41e4a0 <fwrite+0x140>
	return k==l ? nmemb : k/size;
}
  41e433:	48 83 c4 28          	add    rsp,0x28
	return k==l ? nmemb : k/size;
  41e437:	48 89 e8             	mov    rax,rbp
}
  41e43a:	5b                   	pop    rbx
  41e43b:	5d                   	pop    rbp
  41e43c:	41 5c                	pop    r12
  41e43e:	41 5d                	pop    r13
  41e440:	41 5e                	pop    r14
  41e442:	41 5f                	pop    r15
  41e444:	c3                   	ret    
  41e445:	0f 1f 00             	nop    DWORD PTR [rax]
		for (i=l; i && s[i-1] != '\n'; i--);
  41e448:	41 80 7c 1f ff 0a    	cmp    BYTE PTR [r15+rbx*1-0x1],0xa
  41e44e:	48 8d 43 ff          	lea    rax,[rbx-0x1]
  41e452:	74 74                	je     41e4c8 <fwrite+0x168>
  41e454:	48 89 c3             	mov    rbx,rax
  41e457:	48 85 db             	test   rbx,rbx
  41e45a:	75 ec                	jne    41e448 <fwrite+0xe8>
  41e45c:	eb 9d                	jmp    41e3fb <fwrite+0x9b>
  41e45e:	66 90                	xchg   ax,ax
	if (l > f->wend - f->wpos) return f->write(f, s, l);
  41e460:	4c 89 44 24 10       	mov    QWORD PTR [rsp+0x10],r8
  41e465:	4c 89 c7             	mov    rdi,r8
  41e468:	4c 89 ea             	mov    rdx,r13
  41e46b:	4c 89 fe             	mov    rsi,r15
  41e46e:	41 ff 50 48          	call   QWORD PTR [r8+0x48]
  41e472:	4c 8b 44 24 10       	mov    r8,QWORD PTR [rsp+0x10]
	FUNLOCK(f);
  41e477:	8b 54 24 08          	mov    edx,DWORD PTR [rsp+0x8]
  41e47b:	85 d2                	test   edx,edx
  41e47d:	75 24                	jne    41e4a3 <fwrite+0x143>
	return k==l ? nmemb : k/size;
  41e47f:	49 39 c5             	cmp    r13,rax
  41e482:	74 af                	je     41e433 <fwrite+0xd3>
}
  41e484:	48 83 c4 28          	add    rsp,0x28
	return k==l ? nmemb : k/size;
  41e488:	31 d2                	xor    edx,edx
}
  41e48a:	5b                   	pop    rbx
  41e48b:	5d                   	pop    rbp
	return k==l ? nmemb : k/size;
  41e48c:	49 f7 f4             	div    r12
}
  41e48f:	41 5c                	pop    r12
  41e491:	41 5d                	pop    r13
  41e493:	41 5e                	pop    r14
  41e495:	41 5f                	pop    r15
  41e497:	c3                   	ret    
  41e498:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41e49f:	00 
	FUNLOCK(f);
  41e4a0:	4c 89 e8             	mov    rax,r13
  41e4a3:	48 ba 00 cd fb ff ff 	movabs rdx,0xfffffffffffbcd00
  41e4aa:	ff ff ff 
  41e4ad:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  41e4b2:	4c 89 c7             	mov    rdi,r8
  41e4b5:	4c 01 f2             	add    rdx,r14
  41e4b8:	ff d2                	call   rdx
  41e4ba:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
  41e4bf:	eb be                	jmp    41e47f <fwrite+0x11f>
  41e4c1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
			size_t n = f->write(f, s, i);
  41e4c8:	4c 89 44 24 10       	mov    QWORD PTR [rsp+0x10],r8
  41e4cd:	4c 89 c7             	mov    rdi,r8
  41e4d0:	48 89 da             	mov    rdx,rbx
  41e4d3:	4c 89 fe             	mov    rsi,r15
  41e4d6:	41 ff 50 48          	call   QWORD PTR [r8+0x48]
			if (n < i) return n;
  41e4da:	4c 8b 44 24 10       	mov    r8,QWORD PTR [rsp+0x10]
  41e4df:	48 39 c3             	cmp    rbx,rax
  41e4e2:	77 93                	ja     41e477 <fwrite+0x117>
			l -= i;
  41e4e4:	4c 89 ea             	mov    rdx,r13
	memcpy(f->wpos, s, l);
  41e4e7:	49 8b 78 28          	mov    rdi,QWORD PTR [r8+0x28]
			s += i;
  41e4eb:	49 01 df             	add    r15,rbx
			l -= i;
  41e4ee:	48 29 da             	sub    rdx,rbx
  41e4f1:	e9 08 ff ff ff       	jmp    41e3fe <fwrite+0x9e>
  41e4f6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41e4fd:	00 00 00 
	if (!f->wend && __towrite(f)) return 0;
  41e500:	48 b8 90 cd fb ff ff 	movabs rax,0xfffffffffffbcd90
  41e507:	ff ff ff 
  41e50a:	4c 89 44 24 10       	mov    QWORD PTR [rsp+0x10],r8
  41e50f:	4c 89 c7             	mov    rdi,r8
  41e512:	4c 01 f0             	add    rax,r14
  41e515:	ff d0                	call   rax
  41e517:	4c 8b 44 24 10       	mov    r8,QWORD PTR [rsp+0x10]
  41e51c:	85 c0                	test   eax,eax
  41e51e:	75 10                	jne    41e530 <fwrite+0x1d0>
	if (l > f->wend - f->wpos) return f->write(f, s, l);
  41e520:	49 8b 40 20          	mov    rax,QWORD PTR [r8+0x20]
  41e524:	e9 b8 fe ff ff       	jmp    41e3e1 <fwrite+0x81>
  41e529:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	if (!f->wend && __towrite(f)) return 0;
  41e530:	31 c0                	xor    eax,eax
  41e532:	e9 40 ff ff ff       	jmp    41e477 <fwrite+0x117>
  41e537:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41e53e:	00 00 

000000000041e540 <wcrtomb>:
#include <wchar.h>
#include <errno.h>
#include "internal.h"

size_t wcrtomb(char *restrict s, wchar_t wc, mbstate_t *restrict st)
{
  41e540:	f3 0f 1e fa          	endbr64 
	if (!s) return 1;
  41e544:	48 8d 15 f9 ff ff ff 	lea    rdx,[rip+0xfffffffffffffff9]        # 41e544 <wcrtomb+0x4>
  41e54b:	49 bb cc 2e 04 00 00 	movabs r11,0x42ecc
  41e552:	00 00 00 
  41e555:	4c 01 da             	add    rdx,r11
  41e558:	48 85 ff             	test   rdi,rdi
  41e55b:	0f 84 82 00 00 00    	je     41e5e3 <wcrtomb+0xa3>
  41e561:	48 89 f9             	mov    rcx,rdi
  41e564:	89 f0                	mov    eax,esi
	if ((unsigned)wc < 0x80) {
  41e566:	83 fe 7f             	cmp    esi,0x7f
  41e569:	76 75                	jbe    41e5e0 <wcrtomb+0xa0>
{
  41e56b:	48 83 ec 08          	sub    rsp,0x8
  41e56f:	64 48 8b 34 25 00 00 	mov    rsi,QWORD PTR fs:0x0
  41e576:	00 00 
		*s = wc;
		return 1;
	} else if (MB_CUR_MAX == 1) {
  41e578:	48 8b b6 b0 00 00 00 	mov    rsi,QWORD PTR [rsi+0xb0]
  41e57f:	48 83 3e 00          	cmp    QWORD PTR [rsi],0x0
  41e583:	74 6b                	je     41e5f0 <wcrtomb+0xb0>
			errno = EILSEQ;
			return -1;
		}
		*s = wc;
		return 1;
	} else if ((unsigned)wc < 0x800) {
  41e585:	3d ff 07 00 00       	cmp    eax,0x7ff
  41e58a:	0f 86 c0 00 00 00    	jbe    41e650 <wcrtomb+0x110>
		*s++ = 0xc0 | (wc>>6);
		*s = 0x80 | (wc&0x3f);
		return 2;
	} else if ((unsigned)wc < 0xd800 || (unsigned)wc-0xe000 < 0x2000) {
  41e590:	8d b0 00 20 ff ff    	lea    esi,[rax-0xe000]
  41e596:	81 fe ff 1f 00 00    	cmp    esi,0x1fff
  41e59c:	0f 86 ce 00 00 00    	jbe    41e670 <wcrtomb+0x130>
  41e5a2:	3d ff d7 00 00       	cmp    eax,0xd7ff
  41e5a7:	0f 86 c3 00 00 00    	jbe    41e670 <wcrtomb+0x130>
		*s++ = 0xe0 | (wc>>12);
		*s++ = 0x80 | ((wc>>6)&0x3f);
		*s = 0x80 | (wc&0x3f);
		return 3;
	} else if ((unsigned)wc-0x10000 < 0x100000) {
  41e5ad:	8d b0 00 00 ff ff    	lea    esi,[rax-0x10000]
  41e5b3:	81 fe ff ff 0f 00    	cmp    esi,0xfffff
  41e5b9:	76 55                	jbe    41e610 <wcrtomb+0xd0>
		*s++ = 0x80 | ((wc>>12)&0x3f);
		*s++ = 0x80 | ((wc>>6)&0x3f);
		*s = 0x80 | (wc&0x3f);
		return 4;
	}
	errno = EILSEQ;
  41e5bb:	48 b8 b0 77 fb ff ff 	movabs rax,0xfffffffffffb77b0
  41e5c2:	ff ff ff 
  41e5c5:	48 01 d0             	add    rax,rdx
  41e5c8:	ff d0                	call   rax
  41e5ca:	c7 00 54 00 00 00    	mov    DWORD PTR [rax],0x54
	return -1;
  41e5d0:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
}
  41e5d7:	48 83 c4 08          	add    rsp,0x8
  41e5db:	c3                   	ret    
  41e5dc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		*s = wc;
  41e5e0:	40 88 31             	mov    BYTE PTR [rcx],sil
		return 1;
  41e5e3:	b8 01 00 00 00       	mov    eax,0x1
}
  41e5e8:	c3                   	ret    
  41e5e9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		if (!IS_CODEUNIT(wc)) {
  41e5f0:	8d b0 80 20 ff ff    	lea    esi,[rax-0xdf80]
  41e5f6:	83 fe 7f             	cmp    esi,0x7f
  41e5f9:	77 c0                	ja     41e5bb <wcrtomb+0x7b>
		*s = wc;
  41e5fb:	88 01                	mov    BYTE PTR [rcx],al
		return 1;
  41e5fd:	b8 01 00 00 00       	mov    eax,0x1
}
  41e602:	48 83 c4 08          	add    rsp,0x8
  41e606:	c3                   	ret    
  41e607:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41e60e:	00 00 
		*s++ = 0xf0 | (wc>>18);
  41e610:	89 c2                	mov    edx,eax
  41e612:	c1 fa 12             	sar    edx,0x12
  41e615:	83 ca f0             	or     edx,0xfffffff0
  41e618:	88 17                	mov    BYTE PTR [rdi],dl
		*s++ = 0x80 | ((wc>>12)&0x3f);
  41e61a:	89 c2                	mov    edx,eax
  41e61c:	c1 fa 0c             	sar    edx,0xc
  41e61f:	83 e2 3f             	and    edx,0x3f
  41e622:	83 ca 80             	or     edx,0xffffff80
  41e625:	88 57 01             	mov    BYTE PTR [rdi+0x1],dl
		*s++ = 0x80 | ((wc>>6)&0x3f);
  41e628:	89 c2                	mov    edx,eax
		*s = 0x80 | (wc&0x3f);
  41e62a:	83 e0 3f             	and    eax,0x3f
		*s++ = 0x80 | ((wc>>6)&0x3f);
  41e62d:	c1 fa 06             	sar    edx,0x6
		*s = 0x80 | (wc&0x3f);
  41e630:	83 c8 80             	or     eax,0xffffff80
		*s++ = 0x80 | ((wc>>6)&0x3f);
  41e633:	83 e2 3f             	and    edx,0x3f
		*s = 0x80 | (wc&0x3f);
  41e636:	88 47 03             	mov    BYTE PTR [rdi+0x3],al
		return 4;
  41e639:	b8 04 00 00 00       	mov    eax,0x4
		*s++ = 0x80 | ((wc>>6)&0x3f);
  41e63e:	83 ca 80             	or     edx,0xffffff80
  41e641:	88 57 02             	mov    BYTE PTR [rdi+0x2],dl
		return 4;
  41e644:	eb 91                	jmp    41e5d7 <wcrtomb+0x97>
  41e646:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41e64d:	00 00 00 
		*s++ = 0xc0 | (wc>>6);
  41e650:	89 c2                	mov    edx,eax
		*s = 0x80 | (wc&0x3f);
  41e652:	83 e0 3f             	and    eax,0x3f
		*s++ = 0xc0 | (wc>>6);
  41e655:	c1 fa 06             	sar    edx,0x6
		*s = 0x80 | (wc&0x3f);
  41e658:	83 c8 80             	or     eax,0xffffff80
		*s++ = 0xc0 | (wc>>6);
  41e65b:	83 ca c0             	or     edx,0xffffffc0
		*s = 0x80 | (wc&0x3f);
  41e65e:	88 47 01             	mov    BYTE PTR [rdi+0x1],al
		return 2;
  41e661:	b8 02 00 00 00       	mov    eax,0x2
		*s++ = 0xc0 | (wc>>6);
  41e666:	88 17                	mov    BYTE PTR [rdi],dl
		return 2;
  41e668:	e9 6a ff ff ff       	jmp    41e5d7 <wcrtomb+0x97>
  41e66d:	0f 1f 00             	nop    DWORD PTR [rax]
		*s++ = 0xe0 | (wc>>12);
  41e670:	89 c2                	mov    edx,eax
  41e672:	c1 fa 0c             	sar    edx,0xc
  41e675:	83 ca e0             	or     edx,0xffffffe0
  41e678:	88 11                	mov    BYTE PTR [rcx],dl
		*s++ = 0x80 | ((wc>>6)&0x3f);
  41e67a:	89 c2                	mov    edx,eax
		*s = 0x80 | (wc&0x3f);
  41e67c:	83 e0 3f             	and    eax,0x3f
		*s++ = 0x80 | ((wc>>6)&0x3f);
  41e67f:	c1 fa 06             	sar    edx,0x6
		*s = 0x80 | (wc&0x3f);
  41e682:	83 c8 80             	or     eax,0xffffff80
		*s++ = 0x80 | ((wc>>6)&0x3f);
  41e685:	83 e2 3f             	and    edx,0x3f
		*s = 0x80 | (wc&0x3f);
  41e688:	88 41 02             	mov    BYTE PTR [rcx+0x2],al
		return 3;
  41e68b:	b8 03 00 00 00       	mov    eax,0x3
		*s++ = 0x80 | ((wc>>6)&0x3f);
  41e690:	83 ca 80             	or     edx,0xffffff80
  41e693:	88 51 01             	mov    BYTE PTR [rcx+0x1],dl
		return 3;
  41e696:	e9 3c ff ff ff       	jmp    41e5d7 <wcrtomb+0x97>
  41e69b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000041e6a0 <__stdio_exit>:
	if (f->wpos != f->wbase) f->write(f, 0, 0);
	if (f->rpos != f->rend) f->seek(f, f->rpos-f->rend, SEEK_CUR);
}

void __stdio_exit(void)
{
  41e6a0:	f3 0f 1e fa          	endbr64 
	FILE *f;
	for (f=*__ofl_lock(); f; f=f->next) close_file(f);
  41e6a4:	49 bb 6c 2d 04 00 00 	movabs r11,0x42d6c
  41e6ab:	00 00 00 
{
  41e6ae:	41 54                	push   r12
	for (f=*__ofl_lock(); f; f=f->next) close_file(f);
  41e6b0:	48 b8 b0 d4 fb ff ff 	movabs rax,0xfffffffffffbd4b0
  41e6b7:	ff ff ff 
{
  41e6ba:	55                   	push   rbp
  41e6bb:	48 8d 2d e2 ff ff ff 	lea    rbp,[rip+0xffffffffffffffe2]        # 41e6a4 <__stdio_exit+0x4>
  41e6c2:	4c 01 dd             	add    rbp,r11
  41e6c5:	53                   	push   rbx
	for (f=*__ofl_lock(); f; f=f->next) close_file(f);
  41e6c6:	48 01 e8             	add    rax,rbp
  41e6c9:	ff d0                	call   rax
  41e6cb:	48 8b 18             	mov    rbx,QWORD PTR [rax]
  41e6ce:	48 85 db             	test   rbx,rbx
  41e6d1:	74 5d                	je     41e730 <__stdio_exit+0x90>
	FFINALLOCK(f);
  41e6d3:	49 bc e0 cb fb ff ff 	movabs r12,0xfffffffffffbcbe0
  41e6da:	ff ff ff 
  41e6dd:	0f 1f 00             	nop    DWORD PTR [rax]
  41e6e0:	8b 83 8c 00 00 00    	mov    eax,DWORD PTR [rbx+0x8c]
  41e6e6:	85 c0                	test   eax,eax
  41e6e8:	78 0a                	js     41e6f4 <__stdio_exit+0x54>
  41e6ea:	48 89 df             	mov    rdi,rbx
  41e6ed:	4a 8d 44 25 00       	lea    rax,[rbp+r12*1+0x0]
  41e6f2:	ff d0                	call   rax
	if (f->wpos != f->wbase) f->write(f, 0, 0);
  41e6f4:	48 8b 43 38          	mov    rax,QWORD PTR [rbx+0x38]
  41e6f8:	48 39 43 28          	cmp    QWORD PTR [rbx+0x28],rax
  41e6fc:	74 0a                	je     41e708 <__stdio_exit+0x68>
  41e6fe:	31 d2                	xor    edx,edx
  41e700:	31 f6                	xor    esi,esi
  41e702:	48 89 df             	mov    rdi,rbx
  41e705:	ff 53 48             	call   QWORD PTR [rbx+0x48]
	if (f->rpos != f->rend) f->seek(f, f->rpos-f->rend, SEEK_CUR);
  41e708:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
  41e70c:	48 8b 43 10          	mov    rax,QWORD PTR [rbx+0x10]
  41e710:	48 39 c6             	cmp    rsi,rax
  41e713:	0f 84 27 01 00 00    	je     41e840 <__stdio_exit+0x1a0>
  41e719:	48 89 df             	mov    rdi,rbx
  41e71c:	48 29 c6             	sub    rsi,rax
  41e71f:	ba 01 00 00 00       	mov    edx,0x1
  41e724:	ff 53 50             	call   QWORD PTR [rbx+0x50]
	for (f=*__ofl_lock(); f; f=f->next) close_file(f);
  41e727:	48 8b 5b 70          	mov    rbx,QWORD PTR [rbx+0x70]
  41e72b:	48 85 db             	test   rbx,rbx
  41e72e:	75 b0                	jne    41e6e0 <__stdio_exit+0x40>
	close_file(__stdin_used);
  41e730:	48 b8 60 4e 14 00 00 	movabs rax,0x144e60
  41e737:	00 00 00 
  41e73a:	48 8b 5c 05 00       	mov    rbx,QWORD PTR [rbp+rax*1+0x0]
	if (!f) return;
  41e73f:	48 85 db             	test   rbx,rbx
  41e742:	74 3d                	je     41e781 <__stdio_exit+0xe1>
	FFINALLOCK(f);
  41e744:	8b 83 8c 00 00 00    	mov    eax,DWORD PTR [rbx+0x8c]
  41e74a:	85 c0                	test   eax,eax
  41e74c:	0f 89 3e 01 00 00    	jns    41e890 <__stdio_exit+0x1f0>
	if (f->wpos != f->wbase) f->write(f, 0, 0);
  41e752:	48 8b 43 38          	mov    rax,QWORD PTR [rbx+0x38]
  41e756:	48 39 43 28          	cmp    QWORD PTR [rbx+0x28],rax
  41e75a:	74 0a                	je     41e766 <__stdio_exit+0xc6>
  41e75c:	31 d2                	xor    edx,edx
  41e75e:	31 f6                	xor    esi,esi
  41e760:	48 89 df             	mov    rdi,rbx
  41e763:	ff 53 48             	call   QWORD PTR [rbx+0x48]
	if (f->rpos != f->rend) f->seek(f, f->rpos-f->rend, SEEK_CUR);
  41e766:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
  41e76a:	48 8b 43 10          	mov    rax,QWORD PTR [rbx+0x10]
  41e76e:	48 39 c6             	cmp    rsi,rax
  41e771:	74 0e                	je     41e781 <__stdio_exit+0xe1>
  41e773:	48 29 c6             	sub    rsi,rax
  41e776:	ba 01 00 00 00       	mov    edx,0x1
  41e77b:	48 89 df             	mov    rdi,rbx
  41e77e:	ff 53 50             	call   QWORD PTR [rbx+0x50]
	close_file(__stdout_used);
  41e781:	48 b8 60 4e 14 00 00 	movabs rax,0x144e60
  41e788:	00 00 00 
  41e78b:	48 8b 5c 05 00       	mov    rbx,QWORD PTR [rbp+rax*1+0x0]
	if (!f) return;
  41e790:	48 85 db             	test   rbx,rbx
  41e793:	74 3d                	je     41e7d2 <__stdio_exit+0x132>
	FFINALLOCK(f);
  41e795:	8b 83 8c 00 00 00    	mov    eax,DWORD PTR [rbx+0x8c]
  41e79b:	85 c0                	test   eax,eax
  41e79d:	0f 89 cd 00 00 00    	jns    41e870 <__stdio_exit+0x1d0>
	if (f->wpos != f->wbase) f->write(f, 0, 0);
  41e7a3:	48 8b 43 38          	mov    rax,QWORD PTR [rbx+0x38]
  41e7a7:	48 39 43 28          	cmp    QWORD PTR [rbx+0x28],rax
  41e7ab:	74 0a                	je     41e7b7 <__stdio_exit+0x117>
  41e7ad:	31 d2                	xor    edx,edx
  41e7af:	31 f6                	xor    esi,esi
  41e7b1:	48 89 df             	mov    rdi,rbx
  41e7b4:	ff 53 48             	call   QWORD PTR [rbx+0x48]
	if (f->rpos != f->rend) f->seek(f, f->rpos-f->rend, SEEK_CUR);
  41e7b7:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
  41e7bb:	48 8b 43 10          	mov    rax,QWORD PTR [rbx+0x10]
  41e7bf:	48 39 c6             	cmp    rsi,rax
  41e7c2:	74 0e                	je     41e7d2 <__stdio_exit+0x132>
  41e7c4:	48 29 c6             	sub    rsi,rax
  41e7c7:	ba 01 00 00 00       	mov    edx,0x1
  41e7cc:	48 89 df             	mov    rdi,rbx
  41e7cf:	ff 53 50             	call   QWORD PTR [rbx+0x50]
	close_file(__stderr_used);
  41e7d2:	48 b8 60 4e 14 00 00 	movabs rax,0x144e60
  41e7d9:	00 00 00 
  41e7dc:	4c 8b 64 05 00       	mov    r12,QWORD PTR [rbp+rax*1+0x0]
	if (!f) return;
  41e7e1:	4d 85 e4             	test   r12,r12
  41e7e4:	0f 84 c6 00 00 00    	je     41e8b0 <__stdio_exit+0x210>
	FFINALLOCK(f);
  41e7ea:	41 8b 84 24 8c 00 00 	mov    eax,DWORD PTR [r12+0x8c]
  41e7f1:	00 
  41e7f2:	85 c0                	test   eax,eax
  41e7f4:	79 62                	jns    41e858 <__stdio_exit+0x1b8>
	if (f->wpos != f->wbase) f->write(f, 0, 0);
  41e7f6:	49 8b 44 24 38       	mov    rax,QWORD PTR [r12+0x38]
  41e7fb:	49 39 44 24 28       	cmp    QWORD PTR [r12+0x28],rax
  41e800:	74 0c                	je     41e80e <__stdio_exit+0x16e>
  41e802:	31 d2                	xor    edx,edx
  41e804:	31 f6                	xor    esi,esi
  41e806:	4c 89 e7             	mov    rdi,r12
  41e809:	41 ff 54 24 48       	call   QWORD PTR [r12+0x48]
	if (f->rpos != f->rend) f->seek(f, f->rpos-f->rend, SEEK_CUR);
  41e80e:	49 8b 74 24 08       	mov    rsi,QWORD PTR [r12+0x8]
  41e813:	49 8b 44 24 10       	mov    rax,QWORD PTR [r12+0x10]
  41e818:	48 39 c6             	cmp    rsi,rax
  41e81b:	0f 84 8f 00 00 00    	je     41e8b0 <__stdio_exit+0x210>
}
  41e821:	5b                   	pop    rbx
	if (f->rpos != f->rend) f->seek(f, f->rpos-f->rend, SEEK_CUR);
  41e822:	48 29 c6             	sub    rsi,rax
  41e825:	4c 89 e7             	mov    rdi,r12
  41e828:	49 8b 44 24 50       	mov    rax,QWORD PTR [r12+0x50]
}
  41e82d:	5d                   	pop    rbp
	if (f->rpos != f->rend) f->seek(f, f->rpos-f->rend, SEEK_CUR);
  41e82e:	ba 01 00 00 00       	mov    edx,0x1
}
  41e833:	41 5c                	pop    r12
	if (f->rpos != f->rend) f->seek(f, f->rpos-f->rend, SEEK_CUR);
  41e835:	ff e0                	jmp    rax
  41e837:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41e83e:	00 00 
	for (f=*__ofl_lock(); f; f=f->next) close_file(f);
  41e840:	48 8b 5b 70          	mov    rbx,QWORD PTR [rbx+0x70]
  41e844:	48 85 db             	test   rbx,rbx
  41e847:	0f 85 93 fe ff ff    	jne    41e6e0 <__stdio_exit+0x40>
  41e84d:	e9 de fe ff ff       	jmp    41e730 <__stdio_exit+0x90>
  41e852:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	FFINALLOCK(f);
  41e858:	48 b8 e0 cb fb ff ff 	movabs rax,0xfffffffffffbcbe0
  41e85f:	ff ff ff 
  41e862:	4c 89 e7             	mov    rdi,r12
  41e865:	48 01 e8             	add    rax,rbp
  41e868:	ff d0                	call   rax
  41e86a:	eb 8a                	jmp    41e7f6 <__stdio_exit+0x156>
  41e86c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  41e870:	48 b8 e0 cb fb ff ff 	movabs rax,0xfffffffffffbcbe0
  41e877:	ff ff ff 
  41e87a:	48 89 df             	mov    rdi,rbx
  41e87d:	48 01 e8             	add    rax,rbp
  41e880:	ff d0                	call   rax
  41e882:	e9 1c ff ff ff       	jmp    41e7a3 <__stdio_exit+0x103>
  41e887:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41e88e:	00 00 
  41e890:	48 b8 e0 cb fb ff ff 	movabs rax,0xfffffffffffbcbe0
  41e897:	ff ff ff 
  41e89a:	48 89 df             	mov    rdi,rbx
  41e89d:	48 01 e8             	add    rax,rbp
  41e8a0:	ff d0                	call   rax
  41e8a2:	e9 ab fe ff ff       	jmp    41e752 <__stdio_exit+0xb2>
  41e8a7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41e8ae:	00 00 
}
  41e8b0:	5b                   	pop    rbx
  41e8b1:	5d                   	pop    rbp
  41e8b2:	41 5c                	pop    r12
  41e8b4:	c3                   	ret    
  41e8b5:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41e8bc:	00 00 00 
  41e8bf:	90                   	nop

000000000041e8c0 <__ofl_lock>:

static FILE *ofl_head;
static volatile int ofl_lock[1];

FILE **__ofl_lock()
{
  41e8c0:	f3 0f 1e fa          	endbr64 
	LOCK(ofl_lock);
  41e8c4:	49 bb 4c 2b 04 00 00 	movabs r11,0x42b4c
  41e8cb:	00 00 00 
{
  41e8ce:	53                   	push   rbx
  41e8cf:	48 8d 1d ee ff ff ff 	lea    rbx,[rip+0xffffffffffffffee]        # 41e8c4 <__ofl_lock+0x4>
	LOCK(ofl_lock);
  41e8d6:	48 b8 68 4e 14 00 00 	movabs rax,0x144e68
  41e8dd:	00 00 00 
  41e8e0:	4c 01 db             	add    rbx,r11
  41e8e3:	48 8d 3c 03          	lea    rdi,[rbx+rax*1]
  41e8e7:	48 b8 40 d5 fb ff ff 	movabs rax,0xfffffffffffbd540
  41e8ee:	ff ff ff 
  41e8f1:	48 01 d8             	add    rax,rbx
  41e8f4:	ff d0                	call   rax
	return &ofl_head;
  41e8f6:	48 b8 70 4e 14 00 00 	movabs rax,0x144e70
  41e8fd:	00 00 00 
  41e900:	48 01 d8             	add    rax,rbx
}
  41e903:	5b                   	pop    rbx
  41e904:	c3                   	ret    
  41e905:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41e90c:	00 00 00 
  41e90f:	90                   	nop

000000000041e910 <__ofl_unlock>:

void __ofl_unlock()
{
  41e910:	f3 0f 1e fa          	endbr64 
	UNLOCK(ofl_lock);
  41e914:	48 8d 05 f9 ff ff ff 	lea    rax,[rip+0xfffffffffffffff9]        # 41e914 <__ofl_unlock+0x4>
  41e91b:	49 bb fc 2a 04 00 00 	movabs r11,0x42afc
  41e922:	00 00 00 
  41e925:	48 ba 68 4e 14 00 00 	movabs rdx,0x144e68
  41e92c:	00 00 00 
  41e92f:	4c 01 d8             	add    rax,r11
  41e932:	48 8d 3c 10          	lea    rdi,[rax+rdx*1]
  41e936:	48 ba e0 d7 fb ff ff 	movabs rdx,0xfffffffffffbd7e0
  41e93d:	ff ff ff 
  41e940:	48 01 d0             	add    rax,rdx
  41e943:	ff e0                	jmp    rax
  41e945:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41e94c:	00 00 00 
  41e94f:	90                   	nop

000000000041e950 <__lock>:
 * or in an equivalent formulation x is the congestion count or'ed
 * with INT_MIN as a lock flag.
 */

void __lock(volatile int *l)
{
  41e950:	f3 0f 1e fa          	endbr64 
	if (!libc.threads_minus_1) return;
  41e954:	49 bb bc 2a 04 00 00 	movabs r11,0x42abc
  41e95b:	00 00 00 
{
  41e95e:	41 57                	push   r15
  41e960:	4c 8d 3d ed ff ff ff 	lea    r15,[rip+0xffffffffffffffed]        # 41e954 <__lock+0x4>
	if (!libc.threads_minus_1) return;
  41e967:	48 b8 30 4c 14 00 00 	movabs rax,0x144c30
  41e96e:	00 00 00 
{
  41e971:	41 56                	push   r14
  41e973:	4d 01 df             	add    r15,r11
  41e976:	41 55                	push   r13
  41e978:	41 54                	push   r12
  41e97a:	55                   	push   rbp
  41e97b:	53                   	push   rbx
  41e97c:	48 83 ec 08          	sub    rsp,0x8
	if (!libc.threads_minus_1) return;
  41e980:	41 8b 44 07 0c       	mov    eax,DWORD PTR [r15+rax*1+0xc]
  41e985:	85 c0                	test   eax,eax
  41e987:	0f 84 d3 01 00 00    	je     41eb60 <__lock+0x210>
  41e98d:	49 89 fc             	mov    r12,rdi
	__asm__ __volatile__ (
  41e990:	31 c0                	xor    eax,eax
  41e992:	ba 01 00 00 80       	mov    edx,0x80000001
  41e997:	f0 0f b1 17          	lock cmpxchg DWORD PTR [rdi],edx
  41e99b:	89 c2                	mov    edx,eax
	/* fast path: INT_MIN for the lock, +1 for the congestion */
	int current = a_cas(l, 0, INT_MIN + 1);
	if (!current) return;
  41e99d:	85 c0                	test   eax,eax
  41e99f:	0f 84 bb 01 00 00    	je     41eb60 <__lock+0x210>
	/* A first spin loop, for medium congestion. */
	for (unsigned i = 0; i < 10; ++i) {
		if (current < 0) current -= INT_MIN + 1;
		// assertion: current >= 0
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41e9a5:	8d 88 01 00 00 80    	lea    ecx,[rax-0x7fffffff]
		if (current < 0) current -= INT_MIN + 1;
  41e9ab:	79 08                	jns    41e9b5 <__lock+0x65>
  41e9ad:	89 c1                	mov    ecx,eax
  41e9af:	81 c2 ff ff ff 7f    	add    edx,0x7fffffff
  41e9b5:	89 d0                	mov    eax,edx
  41e9b7:	f0 41 0f b1 0c 24    	lock cmpxchg DWORD PTR [r12],ecx
  41e9bd:	89 c1                	mov    ecx,eax
		if (val == current) return;
  41e9bf:	39 d0                	cmp    eax,edx
  41e9c1:	0f 84 99 01 00 00    	je     41eb60 <__lock+0x210>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41e9c7:	8d 90 01 00 00 80    	lea    edx,[rax-0x7fffffff]
		if (current < 0) current -= INT_MIN + 1;
  41e9cd:	85 c0                	test   eax,eax
  41e9cf:	79 08                	jns    41e9d9 <__lock+0x89>
  41e9d1:	89 c2                	mov    edx,eax
  41e9d3:	81 c1 ff ff ff 7f    	add    ecx,0x7fffffff
  41e9d9:	89 c8                	mov    eax,ecx
  41e9db:	f0 41 0f b1 14 24    	lock cmpxchg DWORD PTR [r12],edx
  41e9e1:	89 c2                	mov    edx,eax
		if (val == current) return;
  41e9e3:	39 c1                	cmp    ecx,eax
  41e9e5:	0f 84 75 01 00 00    	je     41eb60 <__lock+0x210>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41e9eb:	8d 88 01 00 00 80    	lea    ecx,[rax-0x7fffffff]
		if (current < 0) current -= INT_MIN + 1;
  41e9f1:	85 c0                	test   eax,eax
  41e9f3:	79 08                	jns    41e9fd <__lock+0xad>
  41e9f5:	89 c1                	mov    ecx,eax
  41e9f7:	81 c2 ff ff ff 7f    	add    edx,0x7fffffff
  41e9fd:	89 d0                	mov    eax,edx
  41e9ff:	f0 41 0f b1 0c 24    	lock cmpxchg DWORD PTR [r12],ecx
  41ea05:	89 c1                	mov    ecx,eax
		if (val == current) return;
  41ea07:	39 c2                	cmp    edx,eax
  41ea09:	0f 84 51 01 00 00    	je     41eb60 <__lock+0x210>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41ea0f:	8d 90 01 00 00 80    	lea    edx,[rax-0x7fffffff]
		if (current < 0) current -= INT_MIN + 1;
  41ea15:	85 c0                	test   eax,eax
  41ea17:	79 08                	jns    41ea21 <__lock+0xd1>
  41ea19:	89 c2                	mov    edx,eax
  41ea1b:	81 c1 ff ff ff 7f    	add    ecx,0x7fffffff
  41ea21:	89 c8                	mov    eax,ecx
  41ea23:	f0 41 0f b1 14 24    	lock cmpxchg DWORD PTR [r12],edx
  41ea29:	89 c2                	mov    edx,eax
		if (val == current) return;
  41ea2b:	39 c1                	cmp    ecx,eax
  41ea2d:	0f 84 2d 01 00 00    	je     41eb60 <__lock+0x210>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41ea33:	8d 88 01 00 00 80    	lea    ecx,[rax-0x7fffffff]
		if (current < 0) current -= INT_MIN + 1;
  41ea39:	85 c0                	test   eax,eax
  41ea3b:	79 08                	jns    41ea45 <__lock+0xf5>
  41ea3d:	89 c1                	mov    ecx,eax
  41ea3f:	81 c2 ff ff ff 7f    	add    edx,0x7fffffff
  41ea45:	89 d0                	mov    eax,edx
  41ea47:	f0 41 0f b1 0c 24    	lock cmpxchg DWORD PTR [r12],ecx
  41ea4d:	89 c1                	mov    ecx,eax
		if (val == current) return;
  41ea4f:	39 c2                	cmp    edx,eax
  41ea51:	0f 84 09 01 00 00    	je     41eb60 <__lock+0x210>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41ea57:	8d 90 01 00 00 80    	lea    edx,[rax-0x7fffffff]
		if (current < 0) current -= INT_MIN + 1;
  41ea5d:	85 c0                	test   eax,eax
  41ea5f:	0f 88 0b 01 00 00    	js     41eb70 <__lock+0x220>
  41ea65:	89 c8                	mov    eax,ecx
  41ea67:	f0 41 0f b1 14 24    	lock cmpxchg DWORD PTR [r12],edx
  41ea6d:	89 c2                	mov    edx,eax
		if (val == current) return;
  41ea6f:	39 c1                	cmp    ecx,eax
  41ea71:	0f 84 e9 00 00 00    	je     41eb60 <__lock+0x210>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41ea77:	8d 88 01 00 00 80    	lea    ecx,[rax-0x7fffffff]
		if (current < 0) current -= INT_MIN + 1;
  41ea7d:	85 c0                	test   eax,eax
  41ea7f:	0f 88 fb 00 00 00    	js     41eb80 <__lock+0x230>
  41ea85:	89 d0                	mov    eax,edx
  41ea87:	f0 41 0f b1 0c 24    	lock cmpxchg DWORD PTR [r12],ecx
  41ea8d:	89 c1                	mov    ecx,eax
		if (val == current) return;
  41ea8f:	39 c2                	cmp    edx,eax
  41ea91:	0f 84 c9 00 00 00    	je     41eb60 <__lock+0x210>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41ea97:	8d 90 01 00 00 80    	lea    edx,[rax-0x7fffffff]
		if (current < 0) current -= INT_MIN + 1;
  41ea9d:	85 c0                	test   eax,eax
  41ea9f:	0f 88 eb 00 00 00    	js     41eb90 <__lock+0x240>
  41eaa5:	89 c8                	mov    eax,ecx
  41eaa7:	f0 41 0f b1 14 24    	lock cmpxchg DWORD PTR [r12],edx
  41eaad:	89 c2                	mov    edx,eax
		if (val == current) return;
  41eaaf:	39 c1                	cmp    ecx,eax
  41eab1:	0f 84 a9 00 00 00    	je     41eb60 <__lock+0x210>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41eab7:	8d 88 01 00 00 80    	lea    ecx,[rax-0x7fffffff]
		if (current < 0) current -= INT_MIN + 1;
  41eabd:	85 c0                	test   eax,eax
  41eabf:	0f 88 db 00 00 00    	js     41eba0 <__lock+0x250>
  41eac5:	89 d0                	mov    eax,edx
  41eac7:	f0 41 0f b1 0c 24    	lock cmpxchg DWORD PTR [r12],ecx
  41eacd:	89 c1                	mov    ecx,eax
		if (val == current) return;
  41eacf:	39 c2                	cmp    edx,eax
  41ead1:	0f 84 89 00 00 00    	je     41eb60 <__lock+0x210>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41ead7:	8d 90 01 00 00 80    	lea    edx,[rax-0x7fffffff]
		if (current < 0) current -= INT_MIN + 1;
  41eadd:	85 c0                	test   eax,eax
  41eadf:	0f 88 cb 00 00 00    	js     41ebb0 <__lock+0x260>
  41eae5:	89 c8                	mov    eax,ecx
  41eae7:	f0 41 0f b1 14 24    	lock cmpxchg DWORD PTR [r12],edx
		if (val == current) return;
  41eaed:	39 c1                	cmp    ecx,eax
  41eaef:	74 6f                	je     41eb60 <__lock+0x210>
	__asm__ __volatile__(
  41eaf1:	bb 01 00 00 00       	mov    ebx,0x1
  41eaf6:	f0 41 0f c1 1c 24    	lock xadd DWORD PTR [r12],ebx
	return __cos_syscall(n, a1, a2, a3, a4, 0, 0, 0);
  41eafc:	48 bd 50 a1 fa ff ff 	movabs rbp,0xfffffffffffaa150
  41eb03:	ff ff ff 
		current = val;
	}
	// Spinning failed, so mark ourselves as being inside the CS.
	current = a_fetch_add(l, 1) + 1;
  41eb06:	83 c3 01             	add    ebx,0x1
  41eb09:	eb 19                	jmp    41eb24 <__lock+0x1d4>
  41eb0b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		if (current < 0) {
			__futexwait(l, current, 1);
			current -= INT_MIN + 1;
		}
		/* assertion: current > 0, the count includes us already. */
		int val = a_cas(l, current, INT_MIN + current);
  41eb10:	8d 9a 00 00 00 80    	lea    ebx,[rdx-0x80000000]
	__asm__ __volatile__ (
  41eb16:	89 d0                	mov    eax,edx
  41eb18:	f0 41 0f b1 1c 24    	lock cmpxchg DWORD PTR [r12],ebx
  41eb1e:	89 c3                	mov    ebx,eax
		if (val == current) return;
  41eb20:	39 c2                	cmp    edx,eax
  41eb22:	74 3c                	je     41eb60 <__lock+0x210>
		if (current < 0) {
  41eb24:	89 da                	mov    edx,ebx
  41eb26:	85 db                	test   ebx,ebx
  41eb28:	79 e6                	jns    41eb10 <__lock+0x1c0>
	__syscall(SYS_futex, addr, FUTEX_WAIT|priv, val, 0) != -ENOSYS ||
  41eb2a:	4c 63 f3             	movsxd r14,ebx
  41eb2d:	6a 00                	push   0x0
  41eb2f:	4c 89 e6             	mov    rsi,r12
  41eb32:	45 31 c9             	xor    r9d,r9d
  41eb35:	6a 00                	push   0x0
  41eb37:	4c 89 f1             	mov    rcx,r14
  41eb3a:	45 31 c0             	xor    r8d,r8d
  41eb3d:	ba 80 00 00 00       	mov    edx,0x80
  41eb42:	bf ca 00 00 00       	mov    edi,0xca
  41eb47:	4e 8d 6c 3d 00       	lea    r13,[rbp+r15*1+0x0]
  41eb4c:	41 ff d5             	call   r13
  41eb4f:	59                   	pop    rcx
  41eb50:	5e                   	pop    rsi
  41eb51:	48 83 f8 da          	cmp    rax,0xffffffffffffffda
  41eb55:	74 69                	je     41ebc0 <__lock+0x270>
			current -= INT_MIN + 1;
  41eb57:	8d 93 ff ff ff 7f    	lea    edx,[rbx+0x7fffffff]
  41eb5d:	eb b1                	jmp    41eb10 <__lock+0x1c0>
  41eb5f:	90                   	nop
		current = val;
	}
}
  41eb60:	48 83 c4 08          	add    rsp,0x8
  41eb64:	5b                   	pop    rbx
  41eb65:	5d                   	pop    rbp
  41eb66:	41 5c                	pop    r12
  41eb68:	41 5d                	pop    r13
  41eb6a:	41 5e                	pop    r14
  41eb6c:	41 5f                	pop    r15
  41eb6e:	c3                   	ret    
  41eb6f:	90                   	nop
		if (current < 0) current -= INT_MIN + 1;
  41eb70:	89 c2                	mov    edx,eax
  41eb72:	81 c1 ff ff ff 7f    	add    ecx,0x7fffffff
  41eb78:	e9 e8 fe ff ff       	jmp    41ea65 <__lock+0x115>
  41eb7d:	0f 1f 00             	nop    DWORD PTR [rax]
  41eb80:	89 c1                	mov    ecx,eax
  41eb82:	81 c2 ff ff ff 7f    	add    edx,0x7fffffff
  41eb88:	e9 f8 fe ff ff       	jmp    41ea85 <__lock+0x135>
  41eb8d:	0f 1f 00             	nop    DWORD PTR [rax]
  41eb90:	89 c2                	mov    edx,eax
  41eb92:	81 c1 ff ff ff 7f    	add    ecx,0x7fffffff
  41eb98:	e9 08 ff ff ff       	jmp    41eaa5 <__lock+0x155>
  41eb9d:	0f 1f 00             	nop    DWORD PTR [rax]
  41eba0:	89 c1                	mov    ecx,eax
  41eba2:	81 c2 ff ff ff 7f    	add    edx,0x7fffffff
  41eba8:	e9 18 ff ff ff       	jmp    41eac5 <__lock+0x175>
  41ebad:	0f 1f 00             	nop    DWORD PTR [rax]
  41ebb0:	89 c2                	mov    edx,eax
  41ebb2:	81 c1 ff ff ff 7f    	add    ecx,0x7fffffff
  41ebb8:	e9 28 ff ff ff       	jmp    41eae5 <__lock+0x195>
  41ebbd:	0f 1f 00             	nop    DWORD PTR [rax]
  41ebc0:	6a 00                	push   0x0
  41ebc2:	31 d2                	xor    edx,edx
  41ebc4:	45 31 c9             	xor    r9d,r9d
  41ebc7:	45 31 c0             	xor    r8d,r8d
  41ebca:	6a 00                	push   0x0
  41ebcc:	4c 89 f1             	mov    rcx,r14
  41ebcf:	4c 89 e6             	mov    rsi,r12
  41ebd2:	bf ca 00 00 00       	mov    edi,0xca
  41ebd7:	41 ff d5             	call   r13
  41ebda:	58                   	pop    rax
  41ebdb:	5a                   	pop    rdx
  41ebdc:	e9 76 ff ff ff       	jmp    41eb57 <__lock+0x207>
  41ebe1:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41ebe8:	00 00 00 
  41ebeb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000041ebf0 <__unlock>:

void __unlock(volatile int *l)
{
  41ebf0:	f3 0f 1e fa          	endbr64 
	/* Check l[0] to see if we are multi-threaded. */
	if (l[0] < 0) {
  41ebf4:	49 bb 1c 28 04 00 00 	movabs r11,0x4281c
  41ebfb:	00 00 00 
{
  41ebfe:	41 57                	push   r15
  41ec00:	4c 8d 3d ed ff ff ff 	lea    r15,[rip+0xffffffffffffffed]        # 41ebf4 <__unlock+0x4>
  41ec07:	55                   	push   rbp
  41ec08:	4d 01 df             	add    r15,r11
  41ec0b:	53                   	push   rbx
	if (l[0] < 0) {
  41ec0c:	8b 07                	mov    eax,DWORD PTR [rdi]
  41ec0e:	85 c0                	test   eax,eax
  41ec10:	78 0e                	js     41ec20 <__unlock+0x30>
		if (a_fetch_add(l, -(INT_MIN + 1)) != (INT_MIN + 1)) {
			__wake(l, 1, 1);
		}
	}
}
  41ec12:	5b                   	pop    rbx
  41ec13:	5d                   	pop    rbp
  41ec14:	41 5f                	pop    r15
  41ec16:	c3                   	ret    
  41ec17:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41ec1e:	00 00 
  41ec20:	48 89 fd             	mov    rbp,rdi
	__asm__ __volatile__(
  41ec23:	b8 ff ff ff 7f       	mov    eax,0x7fffffff
  41ec28:	f0 0f c1 07          	lock xadd DWORD PTR [rdi],eax
		if (a_fetch_add(l, -(INT_MIN + 1)) != (INT_MIN + 1)) {
  41ec2c:	3d 01 00 00 80       	cmp    eax,0x80000001
  41ec31:	74 df                	je     41ec12 <__unlock+0x22>
	return __cos_syscall(n, a1, a2, a3, 0, 0, 0, 0);
  41ec33:	6a 00                	push   0x0
  41ec35:	48 89 fe             	mov    rsi,rdi
  41ec38:	b9 01 00 00 00       	mov    ecx,0x1
  41ec3d:	45 31 c9             	xor    r9d,r9d
  41ec40:	6a 00                	push   0x0
  41ec42:	45 31 c0             	xor    r8d,r8d
  41ec45:	ba 81 00 00 00       	mov    edx,0x81
  41ec4a:	bf ca 00 00 00       	mov    edi,0xca
  41ec4f:	48 bb 50 a1 fa ff ff 	movabs rbx,0xfffffffffffaa150
  41ec56:	ff ff ff 
  41ec59:	4c 01 fb             	add    rbx,r15
  41ec5c:	ff d3                	call   rbx
	__syscall(SYS_futex, addr, FUTEX_WAKE|priv, cnt) != -ENOSYS ||
  41ec5e:	59                   	pop    rcx
  41ec5f:	5e                   	pop    rsi
  41ec60:	48 83 f8 da          	cmp    rax,0xffffffffffffffda
  41ec64:	75 ac                	jne    41ec12 <__unlock+0x22>
  41ec66:	6a 00                	push   0x0
  41ec68:	ba 01 00 00 00       	mov    edx,0x1
  41ec6d:	45 31 c9             	xor    r9d,r9d
  41ec70:	45 31 c0             	xor    r8d,r8d
  41ec73:	6a 00                	push   0x0
  41ec75:	b9 01 00 00 00       	mov    ecx,0x1
  41ec7a:	48 89 ee             	mov    rsi,rbp
  41ec7d:	bf ca 00 00 00       	mov    edi,0xca
  41ec82:	ff d3                	call   rbx
  41ec84:	58                   	pop    rax
  41ec85:	5a                   	pop    rdx
}
  41ec86:	eb 8a                	jmp    41ec12 <__unlock+0x22>
