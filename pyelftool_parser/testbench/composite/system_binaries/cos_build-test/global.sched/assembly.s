
sched.pfprr_quantum_static.global.sched:     file format elf64-x86-64


Disassembly of section .text:

0000000000400000 <printc>:
	return cos_print_str(s, strlen(s));
}

static int  __attribute__((format(printf, 1, 2)))
printc(char *fmt, ...)
{
  400000:	55                   	push   rbp
  400001:	49 89 fa             	mov    r10,rdi
  400004:	48 89 e5             	mov    rbp,rsp
  400007:	48 81 ec 90 01 00 00 	sub    rsp,0x190
  40000e:	48 89 b5 58 ff ff ff 	mov    QWORD PTR [rbp-0xa8],rsi
  400015:	48 89 95 60 ff ff ff 	mov    QWORD PTR [rbp-0xa0],rdx
  40001c:	48 89 8d 68 ff ff ff 	mov    QWORD PTR [rbp-0x98],rcx
  400023:	4c 89 85 70 ff ff ff 	mov    QWORD PTR [rbp-0x90],r8
  40002a:	4c 89 8d 78 ff ff ff 	mov    QWORD PTR [rbp-0x88],r9
  400031:	84 c0                	test   al,al
  400033:	74 20                	je     400055 <printc+0x55>
  400035:	0f 29 45 80          	movaps XMMWORD PTR [rbp-0x80],xmm0
  400039:	0f 29 4d 90          	movaps XMMWORD PTR [rbp-0x70],xmm1
  40003d:	0f 29 55 a0          	movaps XMMWORD PTR [rbp-0x60],xmm2
  400041:	0f 29 5d b0          	movaps XMMWORD PTR [rbp-0x50],xmm3
  400045:	0f 29 65 c0          	movaps XMMWORD PTR [rbp-0x40],xmm4
  400049:	0f 29 6d d0          	movaps XMMWORD PTR [rbp-0x30],xmm5
  40004d:	0f 29 75 e0          	movaps XMMWORD PTR [rbp-0x20],xmm6
  400051:	0f 29 7d f0          	movaps XMMWORD PTR [rbp-0x10],xmm7
	char    s[180];
	va_list arg_ptr;
	size_t  ret;

	va_start(arg_ptr, fmt);
  400055:	48 8d 45 10          	lea    rax,[rbp+0x10]
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  400059:	48 8d 8d 78 fe ff ff 	lea    rcx,[rbp-0x188]
  400060:	4c 89 d2             	mov    rdx,r10
  400063:	be b4 00 00 00       	mov    esi,0xb4
	va_start(arg_ptr, fmt);
  400068:	48 89 85 80 fe ff ff 	mov    QWORD PTR [rbp-0x180],rax
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40006f:	48 8d bd 90 fe ff ff 	lea    rdi,[rbp-0x170]
	va_start(arg_ptr, fmt);
  400076:	48 8d 85 50 ff ff ff 	lea    rax,[rbp-0xb0]
  40007d:	c7 85 78 fe ff ff 08 	mov    DWORD PTR [rbp-0x188],0x8
  400084:	00 00 00 
  400087:	c7 85 7c fe ff ff 30 	mov    DWORD PTR [rbp-0x184],0x30
  40008e:	00 00 00 
  400091:	48 89 85 88 fe ff ff 	mov    QWORD PTR [rbp-0x178],rax
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  400098:	e8 d3 6d 01 00       	call   416e70 <vsnprintf>
	va_end(arg_ptr);
	ret = cos_print_str(s, ret);
  40009d:	48 8d bd 90 fe ff ff 	lea    rdi,[rbp-0x170]
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  4000a4:	89 c6                	mov    esi,eax
	ret = cos_print_str(s, ret);
  4000a6:	e8 d5 ab 00 00       	call   40ac80 <cos_print_str>

	return ret;
}
  4000ab:	c9                   	leave  
  4000ac:	c3                   	ret    
  4000ad:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004000b0 <exit_init_thd>:

struct slm_thd *slm_thd_current_extern(void);

static __attribute__((noreturn)) void
exit_init_thd(void)
{
  4000b0:	55                   	push   rbp
  4000b1:	48 89 e5             	mov    rbp,rsp
  4000b4:	41 54                	push   r12
  4000b6:	53                   	push   rbx
	struct slm_thd *current = slm_thd_current_extern();
  4000b7:	e8 c4 1b 00 00       	call   401c80 <slm_thd_current_extern>
  4000bc:	49 89 c4             	mov    r12,rax
static inline u64_t
cos_rdtscp(coreid_t *coreid, u16_t *numaid)
{
	unsigned long a, d, c;

	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  4000bf:	0f 01 f9             	rdtscp 

	if (cos_coreid() == 0) printc("\tScheduler %ld: Exiting thread %ld from component %ld\n", cos_compid(), cos_thdid(), (compid_t)cos_inv_token());
  4000c2:	f7 c1 ff 0f 00 00    	test   ecx,0xfff
  4000c8:	0f 84 e7 00 00 00    	je     4001b5 <exit_init_thd+0x105>
	slm_cs_cached_t cached;
	sched_tok_t     tok;
	struct slm_thd  *owner;
	int             contended;

	assert(current);
  4000ce:	4d 85 e4             	test   r12,r12
  4000d1:	0f 84 5e 01 00 00    	je     400235 <exit_init_thd+0x185>
  4000d7:	0f 01 f9             	rdtscp 
	cs = &(slm_global()->lock);
  4000da:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  4000e0:	48 8d 1c 89          	lea    rbx,[rcx+rcx*4]
  4000e4:	48 c1 e3 06          	shl    rbx,0x6
  4000e8:	48 81 c3 00 65 71 00 	add    rbx,0x716500

	while (1) {
		tok    = cos_sched_sync();
  4000ef:	e8 1c 1a 01 00       	call   411b10 <cos_sched_sync>
  4000f4:	41 89 c1             	mov    r9d,eax
 * - @ret - a *cached* version of the critical section metadata to be passed into `__slm_cs_cas`.
 */
static inline slm_cs_cached_t
__slm_cs_data(struct slm_cs *cs, struct slm_thd **thd, int *contention)
{
	unsigned long oc = ps_load(&cs->owner_contention);
  4000f7:	48 8b 03             	mov    rax,QWORD PTR [rbx]
		cached = __slm_cs_data(cs, &owner, &contended);

		if (unlikely(owner)) {
  4000fa:	48 89 c1             	mov    rcx,rax
  4000fd:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  400101:	0f 85 f4 00 00 00    	jne    4001fb <exit_init_thd+0x14b>
 */
static inline int
ps_cas(unsigned long *target, unsigned long old, unsigned long updated)
{
        char z;
        __asm__ __volatile__("lock " PS_CAS_STR
  400107:	f0 4c 0f b1 23       	lock cmpxchg QWORD PTR [rbx],r12
  40010c:	0f 94 c0             	sete   al

			continue;
		}

		/* success! common case */
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  40010f:	84 c0                	test   al,al
  400111:	74 dc                	je     4000ef <exit_init_thd+0x3f>

	slm_cs_enter(current, SLM_CS_NONE);
	slm_thd_deinit(current);		/* I'm out! */
  400113:	4c 89 e7             	mov    rdi,r12
  400116:	e8 f5 4e 01 00       	call   415010 <slm_thd_deinit>
  40011b:	0f 01 f9             	rdtscp 
 */
static inline void
slm_cs_exit(struct slm_thd *switchto, slm_cs_flags_t flags)
{
	int ret = 1;
	struct slm_cs *cs = &(slm_global()->lock);
  40011e:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  400124:	48 8d 1c 89          	lea    rbx,[rcx+rcx*4]
  400128:	48 c1 e3 06          	shl    rbx,0x6
  40012c:	48 81 c3 00 65 71 00 	add    rbx,0x716500

	while (ret != 0) {
  400133:	eb 0f                	jmp    400144 <exit_init_thd+0x94>
  400135:	0f 1f 00             	nop    DWORD PTR [rax]
  400138:	f0 48 0f b1 13       	lock cmpxchg QWORD PTR [rbx],rdx
  40013d:	0f 94 c0             	sete   al
  400140:	84 c0                	test   al,al
  400142:	75 28                	jne    40016c <exit_init_thd+0xbc>
		int             contention;
		sched_tok_t     tok;
		slm_cs_cached_t cached;
		struct slm_thd *current;

		tok    = cos_sched_sync();
  400144:	e8 c7 19 01 00       	call   411b10 <cos_sched_sync>
  400149:	89 c1                	mov    ecx,eax
  40014b:	48 8b 03             	mov    rax,QWORD PTR [rbx]
		cached = __slm_cs_data(cs, &current, &contention);
		/* Another thread attempted to enter the critical section */
		if (unlikely(contention)) {
  40014e:	48 89 c2             	mov    rdx,rax
  400151:	83 e2 01             	and    edx,0x1
  400154:	74 e2                	je     400138 <exit_init_thd+0x88>
	/* least significant bit signifies contention */
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  400156:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  400159:	48 89 c2             	mov    rdx,rax
  40015c:	48 89 df             	mov    rdi,rbx
  40015f:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  400163:	e8 38 4f 01 00       	call   4150a0 <slm_cs_exit_contention>
  400168:	85 c0                	test   eax,eax
  40016a:	75 d8                	jne    400144 <exit_init_thd+0x94>
	slm_cs_exit(NULL, SLM_CS_NONE);

	/* Switch to the scheduler thread */
	if (cos_defswitch(BOOT_CAPTBL_SELF_INITTHD_CPU_BASE, TCAP_PRIO_MAX, TCAP_RES_INF, cos_sched_sync())) BUG();
  40016c:	e8 9f 19 01 00       	call   411b10 <cos_sched_sync>
  400171:	41 89 c0             	mov    r8d,eax
  400174:	0f 01 f9             	rdtscp 
  400177:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  40017d:	be 01 00 00 00       	mov    esi,0x1
  400182:	48 c7 c2 ff ff ff ff 	mov    rdx,0xffffffffffffffff
  400189:	48 8d 79 28          	lea    rdi,[rcx+0x28]
  40018d:	44 89 c1             	mov    ecx,r8d
  400190:	e8 0b c5 00 00       	call   40c6a0 <cos_defswitch>
	return cos_print_str(s, strlen(s));
  400195:	be 11 00 00 00       	mov    esi,0x11
  40019a:	85 c0                	test   eax,eax
  40019c:	75 46                	jne    4001e4 <exit_init_thd+0x134>
  40019e:	bf 84 cc 41 00       	mov    edi,0x41cc84
  4001a3:	e8 d8 aa 00 00       	call   40ac80 <cos_print_str>

	BUG();
  4001a8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4001af:	00 00 00 00 
  4001b3:	0f 0b                	ud2    
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  4001b5:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  4001b8:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
	if (cos_coreid() == 0) printc("\tScheduler %ld: Exiting thread %ld from component %ld\n", cos_compid(), cos_thdid(), (compid_t)cos_inv_token());
  4001be:	48 8b 35 7b 8e 02 00 	mov    rsi,QWORD PTR [rip+0x28e7b]        # 429040 <__cosrt_comp_info+0x40>
  4001c5:	bf 80 cb 41 00       	mov    edi,0x41cb80
  4001ca:	48 8b 88 e8 1f 00 00 	mov    rcx,QWORD PTR [rax+0x1fe8]
typedef u16_t cos_thdid_t;

static thdid_t
cos_thdid(void)
{
	return cos_get_thd_id();
  4001d1:	0f b7 90 f0 1f 00 00 	movzx  edx,WORD PTR [rax+0x1ff0]
  4001d8:	31 c0                	xor    eax,eax
  4001da:	e8 21 fe ff ff       	call   400000 <printc>
  4001df:	e9 ea fe ff ff       	jmp    4000ce <exit_init_thd+0x1e>
  4001e4:	bf 72 cc 41 00       	mov    edi,0x41cc72
  4001e9:	e8 92 aa 00 00       	call   40ac80 <cos_print_str>
	if (cos_defswitch(BOOT_CAPTBL_SELF_INITTHD_CPU_BASE, TCAP_PRIO_MAX, TCAP_RES_INF, cos_sched_sync())) BUG();
  4001ee:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4001f5:	00 00 00 00 
  4001f9:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  4001fb:	41 89 c0             	mov    r8d,eax
  4001fe:	4c 89 e2             	mov    rdx,r12
  400201:	48 89 c6             	mov    rsi,rax
  400204:	48 89 df             	mov    rdi,rbx
  400207:	41 83 e0 01          	and    r8d,0x1
  40020b:	e8 30 4e 01 00       	call   415040 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  400210:	83 f8 f0             	cmp    eax,0xfffffff0
  400213:	0f 85 d6 fe ff ff    	jne    4000ef <exit_init_thd+0x3f>
  400219:	be 59 00 00 00       	mov    esi,0x59
  40021e:	bf 18 cc 41 00       	mov    edi,0x41cc18
  400223:	e8 58 aa 00 00       	call   40ac80 <cos_print_str>
  400228:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40022f:	00 00 00 00 
  400233:	0f 0b                	ud2    
  400235:	be 59 00 00 00       	mov    esi,0x59
  40023a:	bf b8 cb 41 00       	mov    edi,0x41cbb8
  40023f:	e8 3c aa 00 00       	call   40ac80 <cos_print_str>
	assert(current);
  400244:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40024b:	00 00 00 00 
  40024f:	0f 0b                	ud2    
  400251:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  400258:	00 00 00 00 
  40025c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000400260 <calculate_initialization_schedule>:
{
  400260:	f3 0f 1e fa          	endbr64 
  400264:	55                   	push   rbp
	ret = args_get_entry("execute", &exec_entries);
  400265:	bf 96 cc 41 00       	mov    edi,0x41cc96
{
  40026a:	48 89 e5             	mov    rbp,rsp
  40026d:	41 55                	push   r13
  40026f:	41 54                	push   r12
	ret = args_get_entry("execute", &exec_entries);
  400271:	48 8d 75 80          	lea    rsi,[rbp-0x80]
{
  400275:	53                   	push   rbx
  400276:	48 83 ec 78          	sub    rsp,0x78
	ret = args_get_entry("execute", &exec_entries);
  40027a:	e8 71 31 01 00       	call   4133f0 <args_get_entry>
	assert(!ret);
  40027f:	85 c0                	test   eax,eax
  400281:	0f 85 a1 01 00 00    	jne    400428 <calculate_initialization_schedule+0x1c8>
	printc("\tSched %ld: %d components that need execution\n", cos_compid(), args_len(&exec_entries));
  400287:	48 8d 7d 80          	lea    rdi,[rbp-0x80]
	*s = (struct schedinit_status) {
  40028b:	45 31 e4             	xor    r12d,r12d
	printc("\tSched %ld: %d components that need execution\n", cos_compid(), args_len(&exec_entries));
  40028e:	e8 5d 2b 01 00       	call   412df0 <args_len>
  400293:	48 8b 35 a6 8d 02 00 	mov    rsi,QWORD PTR [rip+0x28da6]        # 429040 <__cosrt_comp_info+0x40>
  40029a:	bf c8 cc 41 00       	mov    edi,0x41ccc8
  40029f:	89 c2                	mov    edx,eax
  4002a1:	31 c0                	xor    eax,eax
  4002a3:	e8 58 fd ff ff       	call   400000 <printc>
	for (cont = args_iter(&exec_entries, &i, &curr) ; cont ; cont = args_iter_next(&i, &curr)) {
  4002a8:	48 8d 55 a0          	lea    rdx,[rbp-0x60]
  4002ac:	48 8d 75 c0          	lea    rsi,[rbp-0x40]
  4002b0:	48 8d 7d 80          	lea    rdi,[rbp-0x80]
  4002b4:	e8 f7 2b 01 00       	call   412eb0 <args_iter>
  4002b9:	85 c0                	test   eax,eax
  4002bb:	0f 84 e9 00 00 00    	je     4003aa <calculate_initialization_schedule+0x14a>
		compid_t id        = atoi(args_key(&curr, &keylen));
  4002c1:	48 8d b5 7c ff ff ff 	lea    rsi,[rbp-0x84]
  4002c8:	48 8d 7d a0          	lea    rdi,[rbp-0x60]
  4002cc:	e8 7f 2a 01 00       	call   412d50 <args_key>
  4002d1:	48 89 c7             	mov    rdi,rax
  4002d4:	e8 a7 6c 01 00       	call   416f80 <atoi>
		char    *exec_type = args_value(&curr);
  4002d9:	48 8d 7d a0          	lea    rdi,[rbp-0x60]
		compid_t id        = atoi(args_key(&curr, &keylen));
  4002dd:	48 63 d8             	movsxd rbx,eax
		char    *exec_type = args_value(&curr);
  4002e0:	e8 cb 2a 01 00       	call   412db0 <args_value>
  4002e5:	48 89 c7             	mov    rdi,rax
		assert(exec_type);
  4002e8:	48 85 c0             	test   rax,rax
  4002eb:	0f 84 e3 00 00 00    	je     4003d4 <calculate_initialization_schedule+0x174>
	} while (0)

static inline long
cos_spd_id(void)
{
	return __cosrt_comp_info.cos_this_spd_id;
  4002f1:	4c 8b 2d 48 8d 02 00 	mov    r13,QWORD PTR [rip+0x28d48]        # 429040 <__cosrt_comp_info+0x40>
		assert(id != cos_compid());
  4002f8:	4c 39 eb             	cmp    rbx,r13
  4002fb:	0f 84 ef 00 00 00    	je     4003f0 <calculate_initialization_schedule+0x190>
		if (strcmp(exec_type, "init")) BUG();	/* TODO: no support for hierarchical scheduling yet */
  400301:	be 45 cd 41 00       	mov    esi,0x41cd45
  400306:	e8 f5 6e 01 00       	call   417200 <strcmp>
  40030b:	85 c0                	test   eax,eax
  40030d:	0f 85 a5 00 00 00    	jne    4003b8 <calculate_initialization_schedule+0x158>
	printc("\tSched %ld: %ld is the %ldth component to initialize\n", cos_compid(), cid, init_schedule_off);
  400313:	48 8b 0d a6 ea 1b 00 	mov    rcx,QWORD PTR [rip+0x1beaa6]        # 5bedc0 <init_schedule_off>
  40031a:	48 89 da             	mov    rdx,rbx
  40031d:	4c 89 ee             	mov    rsi,r13
  400320:	31 c0                	xor    eax,eax
  400322:	bf 60 cd 41 00       	mov    edi,0x41cd60
  400327:	e8 d4 fc ff ff       	call   400000 <printc>
	init_schedule[init_schedule_off] = cid;
  40032c:	48 8b 05 8d ea 1b 00 	mov    rax,QWORD PTR [rip+0x1bea8d]        # 5bedc0 <init_schedule_off>
  400333:	48 89 1c c5 c0 eb 5b 	mov    QWORD PTR [rax*8+0x5bebc0],rbx
  40033a:	00 
	assert(s->status == SCHEDINIT_FREE);
  40033b:	48 8d 1c 5b          	lea    rbx,[rbx+rbx*2]
	init_schedule_off++;
  40033f:	48 83 c0 01          	add    rax,0x1
	assert(s->status == SCHEDINIT_FREE);
  400343:	48 c1 e3 05          	shl    rbx,0x5
	init_schedule_off++;
  400347:	48 89 05 72 ea 1b 00 	mov    QWORD PTR [rip+0x1bea72],rax        # 5bedc0 <init_schedule_off>
	assert(s->status == SCHEDINIT_FREE);
  40034e:	8b 83 d0 d3 5b 00    	mov    eax,DWORD PTR [rbx+0x5bd3d0]
  400354:	4c 8d ab c0 d3 5b 00 	lea    r13,[rbx+0x5bd3c0]
  40035b:	85 c0                	test   eax,eax
  40035d:	0f 85 a9 00 00 00    	jne    40040c <calculate_initialization_schedule+0x1ac>
	*s = (struct schedinit_status) {
  400363:	4c 89 e0             	mov    rax,r12
  400366:	b9 0c 00 00 00       	mov    ecx,0xc
  40036b:	4c 89 ef             	mov    rdi,r13
  40036e:	f3 48 ab             	rep stos QWORD PTR es:[rdi],rax
  400371:	41 c7 45 10 01 00 00 	mov    DWORD PTR [r13+0x10],0x1
  400378:	00 
  400379:	49 c7 45 18 ff ff ff 	mov    QWORD PTR [r13+0x18],0xffffffffffffffff
  400380:	ff 
	simple_barrier_init(&s->barrier, init_parallelism());
  400381:	e8 4a a5 00 00       	call   40a8d0 <init_parallelism>
	for (cont = args_iter(&exec_entries, &i, &curr) ; cont ; cont = args_iter_next(&i, &curr)) {
  400386:	48 8d 75 a0          	lea    rsi,[rbp-0x60]
  40038a:	48 8d 7d c0          	lea    rdi,[rbp-0x40]
}

static inline void
simple_barrier_init(struct simple_barrier *b, unsigned int ncores)
{
	*b = (struct simple_barrier) {
  40038e:	48 c7 83 c0 d3 5b 00 	mov    QWORD PTR [rbx+0x5bd3c0],0x0
  400395:	00 00 00 00 
  400399:	41 89 45 08          	mov    DWORD PTR [r13+0x8],eax
  40039d:	e8 9e 2a 01 00       	call   412e40 <args_iter_next>
  4003a2:	85 c0                	test   eax,eax
  4003a4:	0f 85 17 ff ff ff    	jne    4002c1 <calculate_initialization_schedule+0x61>
}
  4003aa:	48 83 c4 78          	add    rsp,0x78
  4003ae:	5b                   	pop    rbx
  4003af:	41 5c                	pop    r12
  4003b1:	41 5d                	pop    r13
  4003b3:	5d                   	pop    rbp
  4003b4:	c3                   	ret    
  4003b5:	0f 1f 00             	nop    DWORD PTR [rax]
  4003b8:	be 11 00 00 00       	mov    esi,0x11
  4003bd:	bf 4a cd 41 00       	mov    edi,0x41cd4a
  4003c2:	e8 b9 a8 00 00       	call   40ac80 <cos_print_str>
		if (strcmp(exec_type, "init")) BUG();	/* TODO: no support for hierarchical scheduling yet */
  4003c7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4003ce:	00 00 00 00 
  4003d2:	0f 0b                	ud2    
  4003d4:	be 24 00 00 00       	mov    esi,0x24
  4003d9:	bf f8 cc 41 00       	mov    edi,0x41ccf8
  4003de:	e8 9d a8 00 00       	call   40ac80 <cos_print_str>
		assert(exec_type);
  4003e3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4003ea:	00 00 00 00 
  4003ee:	0f 0b                	ud2    
  4003f0:	be 24 00 00 00       	mov    esi,0x24
  4003f5:	bf 20 cd 41 00       	mov    edi,0x41cd20
  4003fa:	e8 81 a8 00 00       	call   40ac80 <cos_print_str>
		assert(id != cos_compid());
  4003ff:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400406:	00 00 00 00 
  40040a:	0f 0b                	ud2    
  40040c:	be 23 00 00 00       	mov    esi,0x23
  400411:	bf 98 cd 41 00       	mov    edi,0x41cd98
  400416:	e8 65 a8 00 00       	call   40ac80 <cos_print_str>
	assert(s->status == SCHEDINIT_FREE);
  40041b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400422:	00 00 00 00 
  400426:	0f 0b                	ud2    
  400428:	be 23 00 00 00       	mov    esi,0x23
  40042d:	bf a0 cc 41 00       	mov    edi,0x41cca0
  400432:	e8 49 a8 00 00       	call   40ac80 <cos_print_str>
	assert(!ret);
  400437:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40043e:	00 00 00 00 
  400442:	0f 0b                	ud2    
  400444:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40044b:	00 00 00 00 
  40044f:	90                   	nop

0000000000400450 <init_done>:
	while (1) ;
}

void
init_done(int parallel_init, init_main_t cont)
{
  400450:	f3 0f 1e fa          	endbr64 
  400454:	55                   	push   rbp
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  400455:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  400458:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  40045e:	48 89 e5             	mov    rbp,rsp
  400461:	41 56                	push   r14
  400463:	41 55                	push   r13
  400465:	41 54                	push   r12
  400467:	53                   	push   rbx
	return get_stk_data(INVTOKEN_OFFSET);
  400468:	4c 8b 80 e8 1f 00 00 	mov    r8,QWORD PTR [rax+0x1fe8]
  40046f:	89 f3                	mov    ebx,esi
	compid_t client = (compid_t)cos_inv_token();
	struct schedinit_status *s;

	s = &initialization_state[client];
	assert(s->status != SCHEDINIT_FREE);
  400471:	4b 8d 34 40          	lea    rsi,[r8+r8*2]
  400475:	48 c1 e6 05          	shl    rsi,0x5
  400479:	8b 86 d0 d3 5b 00    	mov    eax,DWORD PTR [rsi+0x5bd3d0]
  40047f:	85 c0                	test   eax,eax
  400481:	0f 84 d9 00 00 00    	je     400560 <init_done+0x110>
  400487:	48 8d be c0 d3 5b 00 	lea    rdi,[rsi+0x5bd3c0]
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  40048e:	0f 01 f9             	rdtscp 
  400491:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
	 * `cos_init`, thus call `init_done` first. This is a little
	 * obtuse, but we're simply trying to set the `s->init_core`
	 * only if it is still set to `-1`. Thus the first core to try
	 * (and only the first core to try), should succeed.
	 */
	ps_cas(&s->init_core, ~0, cos_coreid());
  400498:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  40049e:	f0 48 0f b1 8e d8 d3 	lock cmpxchg QWORD PTR [rsi+0x5bd3d8],rcx
  4004a5:	5b 00 
  4004a7:	0f 94 c0             	sete   al

	/*
	 * `init_done` should not be called once initialization is
	 * completed. This is an error.
	 */
	if (s->status == SCHEDINIT_MAIN) {
  4004aa:	8b 47 10             	mov    eax,DWORD PTR [rdi+0x10]
  4004ad:	83 f8 03             	cmp    eax,0x3
  4004b0:	0f 84 e2 00 00 00    	je     400598 <init_done+0x148>

	/*
	 * This should *ONLY* happen for the initialization thread
	 * *after* it executes `cos_init`.
	 */
	if (s->status == SCHEDINIT_INITING) {
  4004b6:	83 f8 01             	cmp    eax,0x1
  4004b9:	0f 84 91 00 00 00    	je     400550 <init_done+0x100>
	assert(*barrier <= ncore);
  4004bf:	8b 57 08             	mov    edx,DWORD PTR [rdi+0x8]
  4004c2:	48 39 96 c0 d3 5b 00 	cmp    QWORD PTR [rsi+0x5bd3c0],rdx
  4004c9:	0f 87 ad 00 00 00    	ja     40057c <init_done+0x12c>
ps_faa(unsigned long *target, long inc)
{
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Warray-bounds"
/* GCC has bug of processing a warning(-Warray-bounds) and not get fixed, thus close the warning in this function */
        __asm__ __volatile__("lock " PS_FAA_STR
  4004cf:	b8 01 00 00 00       	mov    eax,0x1
  4004d4:	f0 48 0f c1 86 c0 d3 	lock xadd QWORD PTR [rsi+0x5bd3c0],rax
  4004db:	5b 00 
                             : "+m" (*target), "+q" (inc)
                             : : "memory", "cc");
        return inc;
  4004dd:	0f 1f 00             	nop    DWORD PTR [rax]
	while (ps_load(barrier) < ncore) ;
  4004e0:	48 8b 07             	mov    rax,QWORD PTR [rdi]
  4004e3:	48 39 c2             	cmp    rdx,rax
  4004e6:	77 f8                	ja     4004e0 <init_done+0x90>
 	 * If this barrier is hit *after* the parallel initialization
	 * has finished, no blocking will occur as its count has
	 * already been hit.
	 */
	simple_barrier(&s->barrier);
	s->status = SCHEDINIT_MAIN;
  4004e8:	4f 8d 2c 40          	lea    r13,[r8+r8*2]
  4004ec:	4d 89 ec             	mov    r12,r13
  4004ef:	49 c1 e4 05          	shl    r12,0x5
  4004f3:	49 81 c4 c0 d3 5b 00 	add    r12,0x5bd3c0
  4004fa:	41 c7 44 24 10 03 00 	mov    DWORD PTR [r12+0x10],0x3
  400501:	00 00 
  400503:	0f 01 f9             	rdtscp 
  400506:	49 89 ce             	mov    r14,rcx

	s->initialization_thds[cos_coreid()] = slm_thd_current_extern();
  400509:	e8 72 17 00 00       	call   401c80 <slm_thd_current_extern>
  40050e:	4c 89 f1             	mov    rcx,r14
  400511:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  400517:	49 89 c0             	mov    r8,rax
  40051a:	4a 8d 44 a9 04       	lea    rax,[rcx+r13*4+0x4]
  40051f:	4c 89 04 c5 c0 d3 5b 	mov    QWORD PTR [rax*8+0x5bd3c0],r8
  400526:	00 
	extern int thd_block(void);
	thd_block(); 		/* block until initialization is completed */
  400527:	e8 44 23 00 00       	call   402870 <thd_block>
  40052c:	0f 01 f9             	rdtscp 

 	/*
	 * After initialization, we're done with the parallel threads
	 * in some cases.
	 */
	if ((cos_coreid() != s->init_core && cont == INIT_MAIN_SINGLE) || cont == INIT_MAIN_NONE) {
  40052f:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  400535:	49 3b 4c 24 18       	cmp    rcx,QWORD PTR [r12+0x18]
  40053a:	74 05                	je     400541 <init_done+0xf1>
  40053c:	83 fb 01             	cmp    ebx,0x1
  40053f:	74 57                	je     400598 <init_done+0x148>
  400541:	85 db                	test   ebx,ebx
  400543:	74 53                	je     400598 <init_done+0x148>
	 * main execution. We'd expect the next API call here to be
	 * `init_exit`.
	 */

	return;
}
  400545:	5b                   	pop    rbx
  400546:	41 5c                	pop    r12
  400548:	41 5d                	pop    r13
  40054a:	41 5e                	pop    r14
  40054c:	5d                   	pop    rbp
  40054d:	c3                   	ret    
  40054e:	66 90                	xchg   ax,ax
		ps_store(&s->status, SCHEDINIT_PARINIT);
  400550:	c7 47 10 02 00 00 00 	mov    DWORD PTR [rdi+0x10],0x2
}
  400557:	5b                   	pop    rbx
  400558:	41 5c                	pop    r12
  40055a:	41 5d                	pop    r13
  40055c:	41 5e                	pop    r14
  40055e:	5d                   	pop    rbp
  40055f:	c3                   	ret    
  400560:	be 24 00 00 00       	mov    esi,0x24
  400565:	bf c0 cd 41 00       	mov    edi,0x41cdc0
  40056a:	e8 11 a7 00 00       	call   40ac80 <cos_print_str>
	assert(s->status != SCHEDINIT_FREE);
  40056f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400576:	00 00 00 00 
  40057a:	0f 0b                	ud2    
  40057c:	be 5d 00 00 00       	mov    esi,0x5d
  400581:	bf e8 cd 41 00       	mov    edi,0x41cde8
  400586:	e8 f5 a6 00 00       	call   40ac80 <cos_print_str>
	assert(*barrier <= ncore);
  40058b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400592:	00 00 00 00 
  400596:	0f 0b                	ud2    
		exit_init_thd();
  400598:	e8 13 fb ff ff       	call   4000b0 <exit_init_thd>
  40059d:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004005a0 <init_exit>:

void
init_exit(int retval)
{
  4005a0:	f3 0f 1e fa          	endbr64 
  4005a4:	55                   	push   rbp
  4005a5:	48 89 e5             	mov    rbp,rsp
	exit_init_thd();
  4005a8:	e8 03 fb ff ff       	call   4000b0 <exit_init_thd>
  4005ad:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004005b0 <slm_idle_comp_initialization>:
	return;
}

void
slm_idle_comp_initialization(void)
{
  4005b0:	f3 0f 1e fa          	endbr64 
  4005b4:	55                   	push   rbp
  4005b5:	48 89 e5             	mov    rbp,rsp
  4005b8:	41 57                	push   r15
  4005ba:	41 56                	push   r14
  4005bc:	41 55                	push   r13
  4005be:	41 54                	push   r12
  4005c0:	53                   	push   rbx
  4005c1:	48 83 ec 18          	sub    rsp,0x18
  4005c5:	0f 01 f9             	rdtscp 
	if (cos_coreid() == 0) printc("Scheduler %ld: Running initialization thread.\n", cos_compid());
  4005c8:	f7 c1 ff 0f 00 00    	test   ecx,0xfff
  4005ce:	0f 84 a7 01 00 00    	je     40077b <slm_idle_comp_initialization+0x1cb>
	while (init_schedule_current != ps_load(&init_schedule_off)) {
  4005d4:	48 8b 05 e5 e7 1b 00 	mov    rax,QWORD PTR [rip+0x1be7e5]        # 5bedc0 <init_schedule_off>
  4005db:	48 8b 1d f6 ca 01 00 	mov    rbx,QWORD PTR [rip+0x1caf6]        # 41d0d8 <__unlock+0x5d8>
  4005e2:	45 31 e4             	xor    r12d,r12d
  4005e5:	48 85 c0             	test   rax,rax
  4005e8:	74 7d                	je     400667 <slm_idle_comp_initialization+0xb7>
  4005ea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
		t = thd_alloc_in(client, 0, param, 1);
  4005f0:	31 f6                	xor    esi,esi
  4005f2:	b9 01 00 00 00       	mov    ecx,0x1
  4005f7:	48 8d 55 c8          	lea    rdx,[rbp-0x38]
		param[0] = sched_param_pack(SCHEDP_INIT, 0);
  4005fb:	48 89 5d c8          	mov    QWORD PTR [rbp-0x38],rbx
		compid_t client = init_schedule[init_schedule_current];
  4005ff:	4e 8b 2c e5 c0 eb 5b 	mov    r13,QWORD PTR [r12*8+0x5bebc0]
  400606:	00 
		t = thd_alloc_in(client, 0, param, 1);
  400607:	4c 89 ef             	mov    rdi,r13
  40060a:	e8 41 52 00 00       	call   405850 <thd_alloc_in>
  40060f:	48 89 c6             	mov    rsi,rax
		assert(t);
  400612:	48 85 c0             	test   rax,rax
  400615:	0f 84 44 01 00 00    	je     40075f <slm_idle_comp_initialization+0x1af>
		init_schedule_current++;
  40061b:	49 83 c4 01          	add    r12,0x1
  40061f:	0f 01 f9             	rdtscp 
		if (cos_coreid() == 0)	printc("\tScheduler %ld: initializing component %ld with thread %ld.\n", cos_compid(), client, t->tid);
  400622:	f7 c1 ff 0f 00 00    	test   ecx,0xfff
  400628:	0f 84 12 01 00 00    	je     400740 <slm_idle_comp_initialization+0x190>
		while (ps_load(&n->initialization_thds[cos_coreid()]) == NULL) ;
  40062e:	4b 8d 74 6d 00       	lea    rsi,[r13+r13*2+0x0]
  400633:	48 c1 e6 02          	shl    rsi,0x2
  400637:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40063e:	00 00 
  400640:	0f 01 f9             	rdtscp 
  400643:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  400649:	48 8d 44 31 04       	lea    rax,[rcx+rsi*1+0x4]
  40064e:	48 8b 04 c5 c0 d3 5b 	mov    rax,QWORD PTR [rax*8+0x5bd3c0]
  400655:	00 
  400656:	48 85 c0             	test   rax,rax
  400659:	74 e5                	je     400640 <slm_idle_comp_initialization+0x90>
	while (init_schedule_current != ps_load(&init_schedule_off)) {
  40065b:	48 8b 05 5e e7 1b 00 	mov    rax,QWORD PTR [rip+0x1be75e]        # 5bedc0 <init_schedule_off>
  400662:	49 39 c4             	cmp    r12,rax
  400665:	75 89                	jne    4005f0 <slm_idle_comp_initialization+0x40>
  400667:	0f 01 f9             	rdtscp 
	if (cos_coreid() == 0) printc("Scheduler %ld, initialization completed.\n", cos_compid());
  40066a:	f7 c1 ff 0f 00 00    	test   ecx,0xfff
  400670:	0f 84 1d 01 00 00    	je     400793 <slm_idle_comp_initialization+0x1e3>
	slm_cs_enter(slm_thd_special(), SLM_CS_NONE);
  400676:	e8 35 48 01 00       	call   414eb0 <slm_thd_special>
  40067b:	49 89 c4             	mov    r12,rax
  40067e:	48 85 c0             	test   rax,rax
  400681:	0f 84 63 02 00 00    	je     4008ea <slm_idle_comp_initialization+0x33a>
  400687:	0f 01 f9             	rdtscp 
	cs = &(slm_global()->lock);
  40068a:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  400690:	48 8d 1c 89          	lea    rbx,[rcx+rcx*4]
  400694:	48 c1 e3 06          	shl    rbx,0x6
  400698:	48 81 c3 00 65 71 00 	add    rbx,0x716500
		tok    = cos_sched_sync();
  40069f:	e8 6c 14 01 00       	call   411b10 <cos_sched_sync>
  4006a4:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4006a7:	48 8b 03             	mov    rax,QWORD PTR [rbx]
		if (unlikely(owner)) {
  4006aa:	48 89 c1             	mov    rcx,rax
  4006ad:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  4006b1:	0f 85 f9 01 00 00    	jne    4008b0 <slm_idle_comp_initialization+0x300>
        __asm__ __volatile__("lock " PS_CAS_STR
  4006b7:	f0 4c 0f b1 23       	lock cmpxchg QWORD PTR [rbx],r12
  4006bc:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4006bf:	84 c0                	test   al,al
  4006c1:	74 dc                	je     40069f <slm_idle_comp_initialization+0xef>
	for (i = 0; i < ps_load(&init_schedule_off); i++) {
  4006c3:	48 8b 05 f6 e6 1b 00 	mov    rax,QWORD PTR [rip+0x1be6f6]        # 5bedc0 <init_schedule_off>
  4006ca:	31 db                	xor    ebx,ebx
  4006cc:	48 85 c0             	test   rax,rax
  4006cf:	75 2a                	jne    4006fb <slm_idle_comp_initialization+0x14b>
  4006d1:	e9 d5 00 00 00       	jmp    4007ab <slm_idle_comp_initialization+0x1fb>
  4006d6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4006dd:	00 00 00 
		slm_thd_wakeup(t, 0);
  4006e0:	31 f6                	xor    esi,esi
	for (i = 0; i < ps_load(&init_schedule_off); i++) {
  4006e2:	48 83 c3 01          	add    rbx,0x1
		slm_thd_wakeup(t, 0);
  4006e6:	e8 b5 50 01 00       	call   4157a0 <slm_thd_wakeup>
	for (i = 0; i < ps_load(&init_schedule_off); i++) {
  4006eb:	48 8b 05 ce e6 1b 00 	mov    rax,QWORD PTR [rip+0x1be6ce]        # 5bedc0 <init_schedule_off>
  4006f2:	48 39 c3             	cmp    rbx,rax
  4006f5:	0f 83 b0 00 00 00    	jae    4007ab <slm_idle_comp_initialization+0x1fb>
  4006fb:	0f 01 f9             	rdtscp 
		t = initialization_state[client].initialization_thds[cos_coreid()];
  4006fe:	48 8b 04 dd c0 eb 5b 	mov    rax,QWORD PTR [rbx*8+0x5bebc0]
  400705:	00 
  400706:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  40070c:	48 8d 04 40          	lea    rax,[rax+rax*2]
  400710:	48 8d 44 81 04       	lea    rax,[rcx+rax*4+0x4]
  400715:	48 8b 3c c5 c0 d3 5b 	mov    rdi,QWORD PTR [rax*8+0x5bd3c0]
  40071c:	00 
		assert(t != NULL);
  40071d:	48 85 ff             	test   rdi,rdi
  400720:	75 be                	jne    4006e0 <slm_idle_comp_initialization+0x130>
  400722:	be 24 00 00 00       	mov    esi,0x24
  400727:	bf 10 cf 41 00       	mov    edi,0x41cf10
  40072c:	e8 4f a5 00 00       	call   40ac80 <cos_print_str>
  400731:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400738:	00 00 00 00 
  40073c:	0f 0b                	ud2    
  40073e:	66 90                	xchg   ax,ax
		if (cos_coreid() == 0)	printc("\tScheduler %ld: initializing component %ld with thread %ld.\n", cos_compid(), client, t->tid);
  400740:	48 8b 4e 18          	mov    rcx,QWORD PTR [rsi+0x18]
  400744:	48 8b 35 f5 88 02 00 	mov    rsi,QWORD PTR [rip+0x288f5]        # 429040 <__cosrt_comp_info+0x40>
  40074b:	4c 89 ea             	mov    rdx,r13
  40074e:	31 c0                	xor    eax,eax
  400750:	bf a0 ce 41 00       	mov    edi,0x41cea0
  400755:	e8 a6 f8 ff ff       	call   400000 <printc>
  40075a:	e9 cf fe ff ff       	jmp    40062e <slm_idle_comp_initialization+0x7e>
  40075f:	be 24 00 00 00       	mov    esi,0x24
  400764:	bf 78 ce 41 00       	mov    edi,0x41ce78
  400769:	e8 12 a5 00 00       	call   40ac80 <cos_print_str>
		assert(t);
  40076e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400775:	00 00 00 00 
  400779:	0f 0b                	ud2    
	if (cos_coreid() == 0) printc("Scheduler %ld: Running initialization thread.\n", cos_compid());
  40077b:	48 8b 35 be 88 02 00 	mov    rsi,QWORD PTR [rip+0x288be]        # 429040 <__cosrt_comp_info+0x40>
  400782:	bf 48 ce 41 00       	mov    edi,0x41ce48
  400787:	31 c0                	xor    eax,eax
  400789:	e8 72 f8 ff ff       	call   400000 <printc>
  40078e:	e9 41 fe ff ff       	jmp    4005d4 <slm_idle_comp_initialization+0x24>
	if (cos_coreid() == 0) printc("Scheduler %ld, initialization completed.\n", cos_compid());
  400793:	48 8b 35 a6 88 02 00 	mov    rsi,QWORD PTR [rip+0x288a6]        # 429040 <__cosrt_comp_info+0x40>
  40079a:	bf e0 ce 41 00       	mov    edi,0x41cee0
  40079f:	31 c0                	xor    eax,eax
  4007a1:	e8 5a f8 ff ff       	call   400000 <printc>
  4007a6:	e9 cb fe ff ff       	jmp    400676 <slm_idle_comp_initialization+0xc6>
	slm_cs_exit_reschedule(slm_thd_special(), SLM_CS_NONE);
  4007ab:	e8 00 47 01 00       	call   414eb0 <slm_thd_special>
  4007b0:	49 89 c5             	mov    r13,rax
 * dispatch.
 */
static inline int
slm_cs_exit_reschedule(struct slm_thd *curr, slm_cs_flags_t flags)
{
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  4007b3:	e8 98 ad 00 00       	call   40b550 <cos_defcompinfo_curr_get>
  4007b8:	0f 01 f9             	rdtscp 
		}
	}

	/* Make a policy decision! */
	t = slm_sched_schedule();
	if (unlikely(!t)) t = &g->idle_thd;
  4007bb:	48 89 c8             	mov    rax,rcx
  4007be:	25 ff 0f 00 00       	and    eax,0xfff
  4007c3:	4c 8d 34 80          	lea    r14,[rax+rax*4]
  4007c7:	49 c1 e6 06          	shl    r14,0x6
  4007cb:	49 81 c6 80 65 71 00 	add    r14,0x716580
	tok  = cos_sched_sync();
  4007d2:	e8 39 13 01 00       	call   411b10 <cos_sched_sync>
  4007d7:	41 89 c4             	mov    r12d,eax
	t = slm_sched_schedule();
  4007da:	e8 01 13 00 00       	call   401ae0 <slm_sched_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  4007df:	48 85 c0             	test   rax,rax
	t = slm_sched_schedule();
  4007e2:	48 89 c3             	mov    rbx,rax
	if (unlikely(!t)) t = &g->idle_thd;
  4007e5:	49 0f 44 de          	cmove  rbx,r14
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  4007e9:	8b 43 04             	mov    eax,DWORD PTR [rbx+0x4]
  4007ec:	83 e8 02             	sub    eax,0x2

	assert(slm_state_is_runnable(t->state));
  4007ef:	83 f8 01             	cmp    eax,0x1
  4007f2:	0f 87 0e 01 00 00    	ja     400906 <slm_idle_comp_initialization+0x356>
  4007f8:	0f 01 f9             	rdtscp 
	struct slm_cs *cs = &(slm_global()->lock);
  4007fb:	48 89 c8             	mov    rax,rcx
  4007fe:	25 ff 0f 00 00       	and    eax,0xfff
  400803:	4c 8d 3c 80          	lea    r15,[rax+rax*4]
  400807:	49 c1 e7 06          	shl    r15,0x6
  40080b:	49 81 c7 00 65 71 00 	add    r15,0x716500
	while (ret != 0) {
  400812:	eb 10                	jmp    400824 <slm_idle_comp_initialization+0x274>
  400814:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  400818:	f0 49 0f b1 17       	lock cmpxchg QWORD PTR [r15],rdx
  40081d:	0f 94 c0             	sete   al
  400820:	84 c0                	test   al,al
  400822:	75 28                	jne    40084c <slm_idle_comp_initialization+0x29c>
		tok    = cos_sched_sync();
  400824:	e8 e7 12 01 00       	call   411b10 <cos_sched_sync>
  400829:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  40082b:	49 8b 07             	mov    rax,QWORD PTR [r15]
		if (unlikely(contention)) {
  40082e:	48 89 c2             	mov    rdx,rax
  400831:	83 e2 01             	and    edx,0x1
  400834:	74 e2                	je     400818 <slm_idle_comp_initialization+0x268>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  400836:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  400839:	48 89 c2             	mov    rdx,rax
  40083c:	4c 89 ff             	mov    rdi,r15
  40083f:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  400843:	e8 58 48 01 00       	call   4150a0 <slm_cs_exit_contention>
  400848:	85 c0                	test   eax,eax
  40084a:	75 d8                	jne    400824 <slm_idle_comp_initialization+0x274>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  40084c:	e8 ff ac 00 00       	call   40b550 <cos_defcompinfo_curr_get>
  400851:	0f 01 f9             	rdtscp 
	*coreid = c & 0xFFF;
  400854:	89 c8                	mov    eax,ecx
	timeout = g->timeout_next;
  400856:	81 e1 ff 0f 00 00    	and    ecx,0xfff
	prio = inherit_prio ? curr->priority : t->priority;
  40085c:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
	timeout = g->timeout_next;
  400860:	48 8d 14 89          	lea    rdx,[rcx+rcx*4]
  400864:	66 25 ff 0f          	and    ax,0xfff
  400868:	49 89 cf             	mov    r15,rcx
  40086b:	48 c1 e2 06          	shl    rdx,0x6
  40086f:	4c 8b 82 08 66 71 00 	mov    r8,QWORD PTR [rdx+0x716608]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  400876:	8b 13                	mov    edx,DWORD PTR [rbx]
  400878:	f6 c2 0b             	test   dl,0xb
  40087b:	0f 85 ef 00 00 00    	jne    400970 <slm_idle_comp_initialization+0x3c0>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  400881:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  400885:	44 89 e1             	mov    ecx,r12d
  400888:	4c 89 c2             	mov    rdx,r8
  40088b:	e8 10 be 00 00       	call   40c6a0 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  400890:	83 f8 ff             	cmp    eax,0xffffffff
  400893:	0f 84 89 00 00 00    	je     400922 <slm_idle_comp_initialization+0x372>
	slm_cs_exit(NULL, flags);

	ret = slm_thd_activate(curr, t, tok, 0);
	
	if (unlikely(ret != 0)) {
  400899:	85 c0                	test   eax,eax
  40089b:	0f 85 33 01 00 00    	jne    4009d4 <slm_idle_comp_initialization+0x424>
	slm_comp_init_loop();
}
  4008a1:	48 83 c4 18          	add    rsp,0x18
  4008a5:	5b                   	pop    rbx
  4008a6:	41 5c                	pop    r12
  4008a8:	41 5d                	pop    r13
  4008aa:	41 5e                	pop    r14
  4008ac:	41 5f                	pop    r15
  4008ae:	5d                   	pop    rbp
  4008af:	c3                   	ret    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  4008b0:	41 89 c0             	mov    r8d,eax
  4008b3:	4c 89 e2             	mov    rdx,r12
  4008b6:	48 89 c6             	mov    rsi,rax
  4008b9:	48 89 df             	mov    rdi,rbx
  4008bc:	41 83 e0 01          	and    r8d,0x1
  4008c0:	e8 7b 47 01 00       	call   415040 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  4008c5:	83 f8 f0             	cmp    eax,0xfffffff0
  4008c8:	0f 85 d1 fd ff ff    	jne    40069f <slm_idle_comp_initialization+0xef>
  4008ce:	be 59 00 00 00       	mov    esi,0x59
  4008d3:	bf 18 cc 41 00       	mov    edi,0x41cc18
  4008d8:	e8 a3 a3 00 00       	call   40ac80 <cos_print_str>
  4008dd:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4008e4:	00 00 00 00 
  4008e8:	0f 0b                	ud2    
  4008ea:	be 59 00 00 00       	mov    esi,0x59
  4008ef:	bf b8 cb 41 00       	mov    edi,0x41cbb8
  4008f4:	e8 87 a3 00 00       	call   40ac80 <cos_print_str>
	assert(current);
  4008f9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400900:	00 00 00 00 
  400904:	0f 0b                	ud2    
  400906:	be 61 00 00 00       	mov    esi,0x61
  40090b:	bf 38 cf 41 00       	mov    edi,0x41cf38
  400910:	e8 6b a3 00 00       	call   40ac80 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  400915:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40091c:	00 00 00 00 
  400920:	0f 0b                	ud2    
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  400922:	0f 01 f9             	rdtscp 
	return t != &g->idle_thd && t != &g->sched_thd;
  400925:	48 89 c8             	mov    rax,rcx
  400928:	25 ff 0f 00 00       	and    eax,0xfff
  40092d:	48 8d 04 80          	lea    rax,[rax+rax*4]
  400931:	48 c1 e0 06          	shl    rax,0x6
  400935:	48 8d 90 80 65 71 00 	lea    rdx,[rax+0x716580]
  40093c:	48 39 d3             	cmp    rbx,rdx
  40093f:	0f 84 01 01 00 00    	je     400a46 <slm_idle_comp_initialization+0x496>
  400945:	48 05 08 65 71 00    	add    rax,0x716508
  40094b:	48 39 c3             	cmp    rbx,rax
  40094e:	0f 84 f2 00 00 00    	je     400a46 <slm_idle_comp_initialization+0x496>
  400954:	be 61 00 00 00       	mov    esi,0x61
  400959:	bf a0 cf 41 00       	mov    edi,0x41cfa0
  40095e:	e8 1d a3 00 00       	call   40ac80 <cos_print_str>
		/* Assuming only the single tcap with infinite budget...should not get EPERM */
		assert(ret != -EPERM);
  400963:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40096a:	00 00 00 00 
  40096e:	0f 0b                	ud2    
		if (t == &g->sched_thd) {
  400970:	0f b7 c0             	movzx  eax,ax
	timeout = g->timeout_next;
  400973:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  400976:	48 8d 04 80          	lea    rax,[rax+rax*4]
  40097a:	48 c1 e0 06          	shl    rax,0x6
  40097e:	48 05 08 65 71 00    	add    rax,0x716508
  400984:	48 39 c3             	cmp    rbx,rax
  400987:	0f 84 ae 00 00 00    	je     400a3b <slm_idle_comp_initialization+0x48b>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  40098d:	f6 c2 02             	test   dl,0x2
  400990:	0f 85 db 00 00 00    	jne    400a71 <slm_idle_comp_initialization+0x4c1>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  400996:	83 e2 01             	and    edx,0x1
  400999:	49 89 c8             	mov    r8,rcx
  40099c:	0f 84 df fe ff ff    	je     400881 <slm_idle_comp_initialization+0x2d1>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  4009a2:	4b 8d 04 bf          	lea    rax,[r15+r15*4]
  4009a6:	4c 8b 53 08          	mov    r10,QWORD PTR [rbx+0x8]
  4009aa:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  4009ae:	48 89 f2             	mov    rdx,rsi
  4009b1:	48 c1 e0 06          	shl    rax,0x6
  4009b5:	45 89 e1             	mov    r9d,r12d
  4009b8:	4c 8b 80 28 65 71 00 	mov    r8,QWORD PTR [rax+0x716528]
  4009bf:	4c 89 d6             	mov    rsi,r10
  4009c2:	e8 69 11 01 00       	call   411b30 <cos_switch>
	if (unlikely(ret != 0)) {
  4009c7:	85 c0                	test   eax,eax
  4009c9:	0f 84 d2 fe ff ff    	je     4008a1 <slm_idle_comp_initialization+0x2f1>
		assert(ret != -EPERM);
  4009cf:	83 f8 ff             	cmp    eax,0xffffffff
  4009d2:	74 80                	je     400954 <slm_idle_comp_initialization+0x3a4>
		assert(ret != -EINVAL);
  4009d4:	83 f8 ea             	cmp    eax,0xffffffea
  4009d7:	0f 84 f3 00 00 00    	je     400ad0 <slm_idle_comp_initialization+0x520>

		/*
		 * If the slm_thd_activate returns -EBUSY, this means we are trying to switch to the scheduler thread,
		 * and scheduler thread still has pending events. Directly return to process pending events.
		 */
		if (ret == -EBUSY) return ret;
  4009dd:	83 f8 f0             	cmp    eax,0xfffffff0
  4009e0:	0f 84 bb fe ff ff    	je     4008a1 <slm_idle_comp_initialization+0x2f1>
		/* If the slm_thd_activate returns -EAGAIN, this means this scheduling token is outdated, try again */
		assert(ret == -EAGAIN);
  4009e6:	83 f8 f5             	cmp    eax,0xfffffff5
  4009e9:	0f 85 c5 00 00 00    	jne    400ab4 <slm_idle_comp_initialization+0x504>
  4009ef:	4d 85 ed             	test   r13,r13
  4009f2:	0f 84 f2 fe ff ff    	je     4008ea <slm_idle_comp_initialization+0x33a>
  4009f8:	0f 01 f9             	rdtscp 
	cs = &(slm_global()->lock);
  4009fb:	48 89 c8             	mov    rax,rcx
  4009fe:	25 ff 0f 00 00       	and    eax,0xfff
  400a03:	48 8d 04 80          	lea    rax,[rax+rax*4]
  400a07:	48 c1 e0 06          	shl    rax,0x6
  400a0b:	48 8d 98 00 65 71 00 	lea    rbx,[rax+0x716500]
		tok    = cos_sched_sync();
  400a12:	e8 f9 10 01 00       	call   411b10 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  400a17:	48 8b 33             	mov    rsi,QWORD PTR [rbx]
  400a1a:	41 89 c1             	mov    r9d,eax
		if (unlikely(owner)) {
  400a1d:	48 89 f1             	mov    rcx,rsi
  400a20:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  400a24:	75 6e                	jne    400a94 <slm_idle_comp_initialization+0x4e4>
  400a26:	48 89 f0             	mov    rax,rsi
  400a29:	f0 4c 0f b1 2b       	lock cmpxchg QWORD PTR [rbx],r13
  400a2e:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  400a31:	84 c0                	test   al,al
  400a33:	0f 85 99 fd ff ff    	jne    4007d2 <slm_idle_comp_initialization+0x222>
  400a39:	eb d7                	jmp    400a12 <slm_idle_comp_initialization+0x462>
			prio    = curr->priority;
  400a3b:	49 8b 75 30          	mov    rsi,QWORD PTR [r13+0x30]
			timeout = TCAP_TIME_NIL;
  400a3f:	31 c9                	xor    ecx,ecx
  400a41:	e9 47 ff ff ff       	jmp    40098d <slm_idle_comp_initialization+0x3dd>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  400a46:	4b 8d 04 bf          	lea    rax,[r15+r15*4]
  400a4a:	49 8b 55 30          	mov    rdx,QWORD PTR [r13+0x30]
  400a4e:	45 89 e1             	mov    r9d,r12d
  400a51:	31 c9                	xor    ecx,ecx
  400a53:	48 c1 e0 06          	shl    rax,0x6
  400a57:	31 f6                	xor    esi,esi
  400a59:	4c 8b 80 28 65 71 00 	mov    r8,QWORD PTR [rax+0x716528]
  400a60:	48 8b b8 18 65 71 00 	mov    rdi,QWORD PTR [rax+0x716518]
  400a67:	e8 c4 10 01 00       	call   411b30 <cos_switch>
  400a6c:	e9 56 ff ff ff       	jmp    4009c7 <slm_idle_comp_initialization+0x417>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  400a71:	4b 8d 04 bf          	lea    rax,[r15+r15*4]
  400a75:	48 8b 7b 28          	mov    rdi,QWORD PTR [rbx+0x28]
  400a79:	44 89 e1             	mov    ecx,r12d
  400a7c:	4c 89 c6             	mov    rsi,r8
  400a7f:	48 c1 e0 06          	shl    rax,0x6
  400a83:	48 8b 90 28 65 71 00 	mov    rdx,QWORD PTR [rax+0x716528]
  400a8a:	e8 11 11 01 00       	call   411ba0 <cos_sched_asnd>
  400a8f:	e9 33 ff ff ff       	jmp    4009c7 <slm_idle_comp_initialization+0x417>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  400a94:	41 89 f0             	mov    r8d,esi
  400a97:	4c 89 ea             	mov    rdx,r13
  400a9a:	48 89 df             	mov    rdi,rbx
  400a9d:	41 83 e0 01          	and    r8d,0x1
  400aa1:	e8 9a 45 01 00       	call   415040 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  400aa6:	83 f8 f0             	cmp    eax,0xfffffff0
  400aa9:	0f 85 63 ff ff ff    	jne    400a12 <slm_idle_comp_initialization+0x462>
  400aaf:	e9 1a fe ff ff       	jmp    4008ce <slm_idle_comp_initialization+0x31e>
  400ab4:	be 61 00 00 00       	mov    esi,0x61
  400ab9:	bf 70 d0 41 00       	mov    edi,0x41d070
  400abe:	e8 bd a1 00 00       	call   40ac80 <cos_print_str>
		assert(ret == -EAGAIN);
  400ac3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400aca:	00 00 00 00 
  400ace:	0f 0b                	ud2    
  400ad0:	be 61 00 00 00       	mov    esi,0x61
  400ad5:	bf 08 d0 41 00       	mov    edi,0x41d008
  400ada:	e8 a1 a1 00 00       	call   40ac80 <cos_print_str>
		assert(ret != -EINVAL);
  400adf:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400ae6:	00 00 00 00 
  400aea:	0f 0b                	ud2    
  400aec:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000400af0 <printc.constprop.0>:
printc(char *fmt, ...)
  400af0:	55                   	push   rbp
  400af1:	48 89 e5             	mov    rbp,rsp
  400af4:	48 81 ec 90 01 00 00 	sub    rsp,0x190
  400afb:	48 89 b5 58 ff ff ff 	mov    QWORD PTR [rbp-0xa8],rsi
  400b02:	48 89 95 60 ff ff ff 	mov    QWORD PTR [rbp-0xa0],rdx
  400b09:	48 89 8d 68 ff ff ff 	mov    QWORD PTR [rbp-0x98],rcx
  400b10:	4c 89 85 70 ff ff ff 	mov    QWORD PTR [rbp-0x90],r8
  400b17:	4c 89 8d 78 ff ff ff 	mov    QWORD PTR [rbp-0x88],r9
  400b1e:	84 c0                	test   al,al
  400b20:	74 20                	je     400b42 <printc.constprop.0+0x52>
  400b22:	0f 29 45 80          	movaps XMMWORD PTR [rbp-0x80],xmm0
  400b26:	0f 29 4d 90          	movaps XMMWORD PTR [rbp-0x70],xmm1
  400b2a:	0f 29 55 a0          	movaps XMMWORD PTR [rbp-0x60],xmm2
  400b2e:	0f 29 5d b0          	movaps XMMWORD PTR [rbp-0x50],xmm3
  400b32:	0f 29 65 c0          	movaps XMMWORD PTR [rbp-0x40],xmm4
  400b36:	0f 29 6d d0          	movaps XMMWORD PTR [rbp-0x30],xmm5
  400b3a:	0f 29 75 e0          	movaps XMMWORD PTR [rbp-0x20],xmm6
  400b3e:	0f 29 7d f0          	movaps XMMWORD PTR [rbp-0x10],xmm7
	va_start(arg_ptr, fmt);
  400b42:	48 8d 45 10          	lea    rax,[rbp+0x10]
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  400b46:	ba e0 d0 41 00       	mov    edx,0x41d0e0
  400b4b:	be b4 00 00 00       	mov    esi,0xb4
	va_start(arg_ptr, fmt);
  400b50:	c7 85 78 fe ff ff 08 	mov    DWORD PTR [rbp-0x188],0x8
  400b57:	00 00 00 
  400b5a:	48 89 85 80 fe ff ff 	mov    QWORD PTR [rbp-0x180],rax
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  400b61:	48 8d 8d 78 fe ff ff 	lea    rcx,[rbp-0x188]
	va_start(arg_ptr, fmt);
  400b68:	48 8d 85 50 ff ff ff 	lea    rax,[rbp-0xb0]
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  400b6f:	48 8d bd 90 fe ff ff 	lea    rdi,[rbp-0x170]
	va_start(arg_ptr, fmt);
  400b76:	48 89 85 88 fe ff ff 	mov    QWORD PTR [rbp-0x178],rax
  400b7d:	c7 85 7c fe ff ff 30 	mov    DWORD PTR [rbp-0x184],0x30
  400b84:	00 00 00 
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  400b87:	e8 e4 62 01 00       	call   416e70 <vsnprintf>
	ret = cos_print_str(s, ret);
  400b8c:	48 8d bd 90 fe ff ff 	lea    rdi,[rbp-0x170]
  400b93:	be 1b 00 00 00       	mov    esi,0x1b
  400b98:	e8 e3 a0 00 00       	call   40ac80 <cos_print_str>
}
  400b9d:	c9                   	leave  
  400b9e:	c3                   	ret    
  400b9f:	90                   	nop

0000000000400ba0 <slm_ipi_process>:
	goto done;
}

void
slm_ipi_process(void *d)
{
  400ba0:	f3 0f 1e fa          	endbr64 
  400ba4:	55                   	push   rbp
  400ba5:	48 89 e5             	mov    rbp,rsp
  400ba8:	41 56                	push   r14
  400baa:	41 55                	push   r13
  400bac:	41 54                	push   r12
  400bae:	53                   	push   rbx
  400baf:	48 83 ec 10          	sub    rsp,0x10
  400bb3:	0f 01 f9             	rdtscp 
	int rcvd, ret;
	struct slm_ipi_percore *ipi_data = slm_ipi_percore_get(cos_cpuid());
  400bb6:	89 cf                	mov    edi,ecx
  400bb8:	81 e7 ff 0f 00 00    	and    edi,0xfff
  400bbe:	e8 cd 42 01 00       	call   414e90 <slm_ipi_percore_get>
	struct slm_ipi_thd     *r        = &ipi_data->ipi_thd;
	struct slm_ipi_event    event    = { 0 };
  400bc3:	48 c7 45 d8 00 00 00 	mov    QWORD PTR [rbp-0x28],0x0
  400bca:	00 
	struct slm_ipi_percore *ipi_data = slm_ipi_percore_get(cos_cpuid());
  400bcb:	49 89 c4             	mov    r12,rax
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  400bce:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  400bd1:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  400bd7:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  400bde:	48 85 c0             	test   rax,rax
  400be1:	0f 84 03 02 00 00    	je     400dea <slm_ipi_process+0x24a>
  400be7:	83 e8 01             	sub    eax,0x1
  400bea:	3d c7 00 00 00       	cmp    eax,0xc7
  400bef:	0f 87 f5 01 00 00    	ja     400dea <slm_ipi_process+0x24a>
  400bf5:	48 8b 14 c5 20 f7 5b 	mov    rdx,QWORD PTR [rax*8+0x5bf720]
  400bfc:	00 
  400bfd:	31 db                	xor    ebx,ebx
}

static inline int
ss_state_is_allocated(ss_state_t state)
{
	return ((state & ~1) != 0) && ((state & 1) == SS_STATE_ALLOC);
  400bff:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  400c06:	0f 85 a6 01 00 00    	jne    400db2 <slm_ipi_process+0x212>
  400c0c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	struct slm_thd         *current  = slm_thd_current();
	struct slm_thd         *thd;

	while (1) {
		cos_rcv(r->rcv, RCV_ALL_PENDING, &rcvd);
  400c10:	49 8b 3c 24          	mov    rdi,QWORD PTR [r12]
  400c14:	48 8d 55 d4          	lea    rdx,[rbp-0x2c]
  400c18:	be 02 00 00 00       	mov    esi,0x2
  400c1d:	e8 ee 10 01 00       	call   411d10 <cos_rcv>
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  400c22:	0f 01 f9             	rdtscp 

		while (!slm_ipi_event_empty(cos_cpuid())) {
  400c25:	89 cf                	mov    edi,ecx
  400c27:	81 e7 ff 0f 00 00    	and    edi,0xfff
  400c2d:	e8 2e 42 01 00       	call   414e60 <slm_ipi_event_empty>
  400c32:	85 c0                	test   eax,eax
  400c34:	75 da                	jne    400c10 <slm_ipi_process+0x70>
  400c36:	0f 01 f9             	rdtscp 
			slm_ipi_event_dequeue(&event, cos_cpuid());
  400c39:	89 ce                	mov    esi,ecx
  400c3b:	48 8d 7d d8          	lea    rdi,[rbp-0x28]
  400c3f:	81 e6 ff 0f 00 00    	and    esi,0xfff
  400c45:	e8 b6 41 01 00       	call   414e00 <slm_ipi_event_dequeue>
	return &ss_thd_get(id)->thd;
  400c4a:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  400c4e:	85 c0                	test   eax,eax
  400c50:	0f 84 fa 00 00 00    	je     400d50 <slm_ipi_process+0x1b0>
  400c56:	83 e8 01             	sub    eax,0x1
  400c59:	3d c7 00 00 00       	cmp    eax,0xc7
  400c5e:	0f 87 ec 00 00 00    	ja     400d50 <slm_ipi_process+0x1b0>
  400c64:	48 8b 14 c5 20 f7 5b 	mov    rdx,QWORD PTR [rax*8+0x5bf720]
  400c6b:	00 
  400c6c:	45 31 f6             	xor    r14d,r14d
  400c6f:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  400c76:	74 18                	je     400c90 <slm_ipi_process+0xf0>
  400c78:	83 e2 01             	and    edx,0x1
  400c7b:	75 13                	jne    400c90 <slm_ipi_process+0xf0>
  400c7d:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  400c81:	4c 8d 34 50          	lea    r14,[rax+rdx*2]
  400c85:	49 c1 e6 04          	shl    r14,0x4
  400c89:	49 81 c6 60 fd 5b 00 	add    r14,0x5bfd60
	assert(current);
  400c90:	48 85 db             	test   rbx,rbx
  400c93:	0f 84 c3 00 00 00    	je     400d5c <slm_ipi_process+0x1bc>
  400c99:	0f 01 f9             	rdtscp 
	cs = &(slm_global()->lock);
  400c9c:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  400ca2:	4c 8d 2c 89          	lea    r13,[rcx+rcx*4]
  400ca6:	49 c1 e5 06          	shl    r13,0x6
  400caa:	49 81 c5 00 65 71 00 	add    r13,0x716500
		tok    = cos_sched_sync();
  400cb1:	e8 5a 0e 01 00       	call   411b10 <cos_sched_sync>
  400cb6:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  400cb9:	49 8b 45 00          	mov    rax,QWORD PTR [r13+0x0]
		if (unlikely(owner)) {
  400cbd:	48 89 c1             	mov    rcx,rax
  400cc0:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  400cc4:	0f 85 ae 00 00 00    	jne    400d78 <slm_ipi_process+0x1d8>
  400cca:	f0 49 0f b1 5d 00    	lock cmpxchg QWORD PTR [r13+0x0],rbx
  400cd0:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  400cd3:	84 c0                	test   al,al
  400cd5:	74 da                	je     400cb1 <slm_ipi_process+0x111>

			thd = slm_thd_static_cm_lookup(event.tid);
			slm_cs_enter(current, SLM_CS_NONE);
			ret = slm_thd_wakeup(thd, 0);
  400cd7:	31 f6                	xor    esi,esi
  400cd9:	4c 89 f7             	mov    rdi,r14
  400cdc:	e8 bf 4a 01 00       	call   4157a0 <slm_thd_wakeup>
			/*
			 * Return "0" means the thread is woken up in this call.
			 * Return "1" means the thread is already `RUNNABLE`.
			 */
			assert(ret == 0 || ret == 1);
  400ce1:	83 f8 01             	cmp    eax,0x1
  400ce4:	0f 87 e4 00 00 00    	ja     400dce <slm_ipi_process+0x22e>
  400cea:	0f 01 f9             	rdtscp 
	struct slm_cs *cs = &(slm_global()->lock);
  400ced:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  400cf3:	4c 8d 2c 89          	lea    r13,[rcx+rcx*4]
  400cf7:	49 c1 e5 06          	shl    r13,0x6
  400cfb:	49 81 c5 00 65 71 00 	add    r13,0x716500
	while (ret != 0) {
  400d02:	eb 15                	jmp    400d19 <slm_ipi_process+0x179>
  400d04:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  400d08:	f0 49 0f b1 55 00    	lock cmpxchg QWORD PTR [r13+0x0],rdx
  400d0e:	0f 94 c0             	sete   al
  400d11:	84 c0                	test   al,al
  400d13:	0f 85 09 ff ff ff    	jne    400c22 <slm_ipi_process+0x82>
		tok    = cos_sched_sync();
  400d19:	e8 f2 0d 01 00       	call   411b10 <cos_sched_sync>
  400d1e:	89 c1                	mov    ecx,eax
  400d20:	49 8b 45 00          	mov    rax,QWORD PTR [r13+0x0]
		if (unlikely(contention)) {
  400d24:	48 89 c2             	mov    rdx,rax
  400d27:	83 e2 01             	and    edx,0x1
  400d2a:	74 dc                	je     400d08 <slm_ipi_process+0x168>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  400d2c:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  400d2f:	48 89 c2             	mov    rdx,rax
  400d32:	4c 89 ef             	mov    rdi,r13
  400d35:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  400d39:	e8 62 43 01 00       	call   4150a0 <slm_cs_exit_contention>
  400d3e:	85 c0                	test   eax,eax
  400d40:	0f 84 dc fe ff ff    	je     400c22 <slm_ipi_process+0x82>
  400d46:	eb d1                	jmp    400d19 <slm_ipi_process+0x179>
  400d48:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  400d4f:	00 
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  400d50:	45 31 f6             	xor    r14d,r14d
	assert(current);
  400d53:	48 85 db             	test   rbx,rbx
  400d56:	0f 85 3d ff ff ff    	jne    400c99 <slm_ipi_process+0xf9>
	return cos_print_str(s, strlen(s));
  400d5c:	be 59 00 00 00       	mov    esi,0x59
  400d61:	bf 00 d1 41 00       	mov    edi,0x41d100
  400d66:	e8 15 9f 00 00       	call   40ac80 <cos_print_str>
  400d6b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400d72:	00 00 00 00 
  400d76:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  400d78:	41 89 c0             	mov    r8d,eax
  400d7b:	48 89 da             	mov    rdx,rbx
  400d7e:	48 89 c6             	mov    rsi,rax
  400d81:	4c 89 ef             	mov    rdi,r13
  400d84:	41 83 e0 01          	and    r8d,0x1
  400d88:	e8 b3 42 01 00       	call   415040 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  400d8d:	83 f8 f0             	cmp    eax,0xfffffff0
  400d90:	0f 85 1b ff ff ff    	jne    400cb1 <slm_ipi_process+0x111>
  400d96:	be 59 00 00 00       	mov    esi,0x59
  400d9b:	bf 60 d1 41 00       	mov    edi,0x41d160
  400da0:	e8 db 9e 00 00       	call   40ac80 <cos_print_str>
  400da5:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400dac:	00 00 00 00 
  400db0:	0f 0b                	ud2    
  400db2:	80 e2 01             	and    dl,0x1
  400db5:	0f 85 55 fe ff ff    	jne    400c10 <slm_ipi_process+0x70>
  400dbb:	48 69 c0 b0 00 00 00 	imul   rax,rax,0xb0
  400dc2:	48 8d 98 60 fd 5b 00 	lea    rbx,[rax+0x5bfd60]
  400dc9:	e9 42 fe ff ff       	jmp    400c10 <slm_ipi_process+0x70>
  400dce:	be 24 00 00 00       	mov    esi,0x24
  400dd3:	bf c0 d1 41 00       	mov    edi,0x41d1c0
  400dd8:	e8 a3 9e 00 00       	call   40ac80 <cos_print_str>
			assert(ret == 0 || ret == 1);
  400ddd:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400de4:	00 00 00 00 
  400de8:	0f 0b                	ud2    
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  400dea:	31 db                	xor    ebx,ebx
  400dec:	e9 1f fe ff ff       	jmp    400c10 <slm_ipi_process+0x70>
  400df1:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  400df8:	00 00 00 00 
  400dfc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000400e00 <slm_blkpt_alloc>:
	return &__blkpts[id-1];
}

sched_blkpt_id_t
slm_blkpt_alloc(struct slm_thd *current)
{
  400e00:	f3 0f 1e fa          	endbr64 
  400e04:	55                   	push   rbp
  400e05:	48 89 e5             	mov    rbp,rsp
  400e08:	41 54                	push   r12
  400e0a:	53                   	push   rbx
	assert(current);
  400e0b:	48 85 ff             	test   rdi,rdi
  400e0e:	0f 84 26 01 00 00    	je     400f3a <slm_blkpt_alloc+0x13a>
  400e14:	49 89 fc             	mov    r12,rdi
  400e17:	0f 01 f9             	rdtscp 
	cs = &(slm_global()->lock);
  400e1a:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  400e20:	48 8d 1c 89          	lea    rbx,[rcx+rcx*4]
  400e24:	48 c1 e3 06          	shl    rbx,0x6
  400e28:	48 81 c3 00 65 71 00 	add    rbx,0x716500
		tok    = cos_sched_sync();
  400e2f:	e8 dc 0c 01 00       	call   411b10 <cos_sched_sync>
  400e34:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  400e37:	48 8b 03             	mov    rax,QWORD PTR [rbx]
		if (unlikely(owner)) {
  400e3a:	48 89 c1             	mov    rcx,rax
  400e3d:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  400e41:	0f 85 b9 00 00 00    	jne    400f00 <slm_blkpt_alloc+0x100>
  400e47:	f0 4c 0f b1 23       	lock cmpxchg QWORD PTR [rbx],r12
  400e4c:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  400e4f:	84 c0                	test   al,al
  400e51:	74 dc                	je     400e2f <slm_blkpt_alloc+0x2f>
	struct blkpt_mem *m;
	sched_blkpt_id_t ret = SCHED_BLKPT_NULL;

	slm_cs_enter(current, SLM_CS_NONE);

	id = (sched_blkpt_id_t)__blkpt_offset;
  400e53:	44 8b 25 a6 51 02 00 	mov    r12d,DWORD PTR [rip+0x251a6]        # 426000 <__blkpt_offset>
	if (id - 1 == NBLKPTS) return NULL;
  400e5a:	41 81 fc 01 a0 00 00 	cmp    r12d,0xa001
  400e61:	0f 84 ef 00 00 00    	je     400f56 <slm_blkpt_alloc+0x156>
	return &__blkpts[id-1];
  400e67:	41 8d 44 24 ff       	lea    eax,[r12-0x1]
  400e6c:	48 c1 e0 05          	shl    rax,0x5
	m  = blkpt_get(id);
	if (!m) ERR_THROW(SCHED_BLKPT_NULL, unlock);

	m->id    = id;
  400e70:	44 89 a0 e0 86 5c 00 	mov    DWORD PTR [rax+0x5c86e0],r12d
	ret      = id;
	m->epoch = 0;
  400e77:	48 c7 80 e8 86 5c 00 	mov    QWORD PTR [rax+0x5c86e8],0x0
  400e7e:	00 00 00 00 
};

static inline void
stacklist_init(struct stacklist_head *h)
{
	h->head = NULL;
  400e82:	48 c7 80 f0 86 5c 00 	mov    QWORD PTR [rax+0x5c86f0],0x0
  400e89:	00 00 00 00 
ps_lock_release(struct ps_lock *l)
{ l->o = 0; }

static inline void
ps_lock_init(struct ps_lock *l)
{ l->o = 0; }
  400e8d:	48 c7 80 f8 86 5c 00 	mov    QWORD PTR [rax+0x5c86f8],0x0
  400e94:	00 00 00 00 
	stacklist_init(&m->blocked);
	ps_lock_init(&m->lock);
	__blkpt_offset++;
  400e98:	41 8d 44 24 01       	lea    eax,[r12+0x1]
  400e9d:	89 05 5d 51 02 00    	mov    DWORD PTR [rip+0x2515d],eax        # 426000 <__blkpt_offset>
  400ea3:	0f 01 f9             	rdtscp 
	struct slm_cs *cs = &(slm_global()->lock);
  400ea6:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  400eac:	48 8d 1c 89          	lea    rbx,[rcx+rcx*4]
  400eb0:	48 c1 e3 06          	shl    rbx,0x6
  400eb4:	48 81 c3 00 65 71 00 	add    rbx,0x716500
	while (ret != 0) {
  400ebb:	eb 0f                	jmp    400ecc <slm_blkpt_alloc+0xcc>
  400ebd:	0f 1f 00             	nop    DWORD PTR [rax]
        __asm__ __volatile__("lock " PS_CAS_STR
  400ec0:	f0 48 0f b1 13       	lock cmpxchg QWORD PTR [rbx],rdx
  400ec5:	0f 94 c0             	sete   al
  400ec8:	84 c0                	test   al,al
  400eca:	75 28                	jne    400ef4 <slm_blkpt_alloc+0xf4>
		tok    = cos_sched_sync();
  400ecc:	e8 3f 0c 01 00       	call   411b10 <cos_sched_sync>
  400ed1:	89 c1                	mov    ecx,eax
  400ed3:	48 8b 03             	mov    rax,QWORD PTR [rbx]
		if (unlikely(contention)) {
  400ed6:	48 89 c2             	mov    rdx,rax
  400ed9:	83 e2 01             	and    edx,0x1
  400edc:	74 e2                	je     400ec0 <slm_blkpt_alloc+0xc0>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  400ede:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  400ee1:	48 89 c2             	mov    rdx,rax
  400ee4:	48 89 df             	mov    rdi,rbx
  400ee7:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  400eeb:	e8 b0 41 01 00       	call   4150a0 <slm_cs_exit_contention>
  400ef0:	85 c0                	test   eax,eax
  400ef2:	75 d8                	jne    400ecc <slm_blkpt_alloc+0xcc>
unlock:
	slm_cs_exit(NULL, SLM_CS_NONE);

	return ret;
}
  400ef4:	44 89 e0             	mov    eax,r12d
  400ef7:	5b                   	pop    rbx
  400ef8:	41 5c                	pop    r12
  400efa:	5d                   	pop    rbp
  400efb:	c3                   	ret    
  400efc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  400f00:	41 89 c0             	mov    r8d,eax
  400f03:	4c 89 e2             	mov    rdx,r12
  400f06:	48 89 c6             	mov    rsi,rax
  400f09:	48 89 df             	mov    rdi,rbx
  400f0c:	41 83 e0 01          	and    r8d,0x1
  400f10:	e8 2b 41 01 00       	call   415040 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  400f15:	83 f8 f0             	cmp    eax,0xfffffff0
  400f18:	0f 85 11 ff ff ff    	jne    400e2f <slm_blkpt_alloc+0x2f>
  400f1e:	be 59 00 00 00       	mov    esi,0x59
  400f23:	bf 60 d1 41 00       	mov    edi,0x41d160
  400f28:	e8 53 9d 00 00       	call   40ac80 <cos_print_str>
  400f2d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400f34:	00 00 00 00 
  400f38:	0f 0b                	ud2    
  400f3a:	be 59 00 00 00       	mov    esi,0x59
  400f3f:	bf 00 d1 41 00       	mov    edi,0x41d100
  400f44:	e8 37 9d 00 00       	call   40ac80 <cos_print_str>
	assert(current);
  400f49:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  400f50:	00 00 00 00 
  400f54:	0f 0b                	ud2    
	if (!m) ERR_THROW(SCHED_BLKPT_NULL, unlock);
  400f56:	45 31 e4             	xor    r12d,r12d
  400f59:	e9 45 ff ff ff       	jmp    400ea3 <slm_blkpt_alloc+0xa3>
  400f5e:	66 90                	xchg   ax,ax

0000000000400f60 <slm_blkpt_free>:

int
slm_blkpt_free(sched_blkpt_id_t id)
{
  400f60:	f3 0f 1e fa          	endbr64 
	/* alloc only for now */
	return 0;
}
  400f64:	31 c0                	xor    eax,eax
  400f66:	c3                   	ret    
  400f67:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  400f6e:	00 00 

0000000000400f70 <slm_blkpt_trigger>:

int
slm_blkpt_trigger(sched_blkpt_id_t blkpt, struct slm_thd *current, sched_blkpt_epoch_t epoch, int single)
{
  400f70:	f3 0f 1e fa          	endbr64 
  400f74:	55                   	push   rbp
  400f75:	48 89 e5             	mov    rbp,rsp
  400f78:	41 57                	push   r15
  400f7a:	41 56                	push   r14
  400f7c:	41 55                	push   r13
  400f7e:	41 54                	push   r12
  400f80:	53                   	push   rbx
  400f81:	48 83 ec 08          	sub    rsp,0x8
  400f85:	48 85 f6             	test   rsi,rsi
  400f88:	0f 84 bc 02 00 00    	je     40124a <slm_blkpt_trigger+0x2da>
  400f8e:	41 89 ff             	mov    r15d,edi
  400f91:	48 89 f3             	mov    rbx,rsi
  400f94:	49 89 d5             	mov    r13,rdx
  400f97:	41 89 cc             	mov    r12d,ecx
  400f9a:	0f 01 f9             	rdtscp 
	cs = &(slm_global()->lock);
  400f9d:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  400fa3:	4c 8d 34 89          	lea    r14,[rcx+rcx*4]
  400fa7:	49 c1 e6 06          	shl    r14,0x6
  400fab:	49 81 c6 00 65 71 00 	add    r14,0x716500
		tok    = cos_sched_sync();
  400fb2:	e8 59 0b 01 00       	call   411b10 <cos_sched_sync>
  400fb7:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  400fba:	49 8b 06             	mov    rax,QWORD PTR [r14]
		if (unlikely(owner)) {
  400fbd:	48 89 c1             	mov    rcx,rax
  400fc0:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  400fc4:	0f 85 46 02 00 00    	jne    401210 <slm_blkpt_trigger+0x2a0>
  400fca:	f0 49 0f b1 1e       	lock cmpxchg QWORD PTR [r14],rbx
  400fcf:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  400fd2:	84 c0                	test   al,al
  400fd4:	74 dc                	je     400fb2 <slm_blkpt_trigger+0x42>
	if (id - 1 == NBLKPTS) return NULL;
  400fd6:	41 81 ff 01 a0 00 00 	cmp    r15d,0xa001
  400fdd:	0f 84 83 02 00 00    	je     401266 <slm_blkpt_trigger+0x2f6>
	return &__blkpts[id-1];
  400fe3:	41 8d 7f ff          	lea    edi,[r15-0x1]
  400fe7:	be 01 00 00 00       	mov    esi,0x1
  400fec:	31 c9                	xor    ecx,ecx
  400fee:	49 89 fe             	mov    r14,rdi
  400ff1:	49 c1 e6 05          	shl    r14,0x5
  400ff5:	4d 8d be e0 86 5c 00 	lea    r15,[r14+0x5c86e0]
{ while (!ps_cas(&l->o, 0, 1)) ; }
  400ffc:	49 8d 96 f8 86 5c 00 	lea    rdx,[r14+0x5c86f8]
  401003:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  401008:	48 89 c8             	mov    rax,rcx
  40100b:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  401010:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  401013:	84 c0                	test   al,al
  401015:	74 f1                	je     401008 <slm_blkpt_trigger+0x98>

		if (!blkpt_epoch_is_higher(pre, epoch)) {
			ps_lock_release(&m->lock);
			ERR_THROW(0, unlock); 
		}
		if (ps_cas(&m->epoch, pre, epoch)) break;
  401017:	49 8d 96 e8 86 5c 00 	lea    rdx,[r14+0x5c86e8]
  40101e:	eb 10                	jmp    401030 <slm_blkpt_trigger+0xc0>
        __asm__ __volatile__("lock " PS_CAS_STR
  401020:	f0 4c 0f b1 2a       	lock cmpxchg QWORD PTR [rdx],r13
  401025:	0f 94 c0             	sete   al
  401028:	84 c0                	test   al,al
  40102a:	0f 85 80 00 00 00    	jne    4010b0 <slm_blkpt_trigger+0x140>
		sched_blkpt_epoch_t pre = ps_load(&m->epoch);
  401030:	49 8b 47 08          	mov    rax,QWORD PTR [r15+0x8]
		if (!blkpt_epoch_is_higher(pre, epoch)) {
  401034:	4c 39 e8             	cmp    rax,r13
  401037:	76 e7                	jbe    401020 <slm_blkpt_trigger+0xb0>
{ l->o = 0; }
  401039:	49 c7 47 18 00 00 00 	mov    QWORD PTR [r15+0x18],0x0
  401040:	00 
			ERR_THROW(0, unlock); 
  401041:	45 31 e4             	xor    r12d,r12d
  401044:	0f 01 f9             	rdtscp 
	struct slm_cs *cs = &(slm_global()->lock);
  401047:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  40104d:	48 8d 1c 89          	lea    rbx,[rcx+rcx*4]
  401051:	48 c1 e3 06          	shl    rbx,0x6
  401055:	48 81 c3 00 65 71 00 	add    rbx,0x716500
	while (ret != 0) {
  40105c:	eb 0e                	jmp    40106c <slm_blkpt_trigger+0xfc>
  40105e:	66 90                	xchg   ax,ax
        __asm__ __volatile__("lock " PS_CAS_STR
  401060:	f0 48 0f b1 13       	lock cmpxchg QWORD PTR [rbx],rdx
  401065:	0f 94 c0             	sete   al
  401068:	84 c0                	test   al,al
  40106a:	75 28                	jne    401094 <slm_blkpt_trigger+0x124>
		tok    = cos_sched_sync();
  40106c:	e8 9f 0a 01 00       	call   411b10 <cos_sched_sync>
  401071:	89 c1                	mov    ecx,eax
  401073:	48 8b 03             	mov    rax,QWORD PTR [rbx]
		if (unlikely(contention)) {
  401076:	48 89 c2             	mov    rdx,rax
  401079:	83 e2 01             	and    edx,0x1
  40107c:	74 e2                	je     401060 <slm_blkpt_trigger+0xf0>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  40107e:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  401081:	48 89 c2             	mov    rdx,rax
  401084:	48 89 df             	mov    rdi,rbx
  401087:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  40108b:	e8 10 40 01 00       	call   4150a0 <slm_cs_exit_contention>
  401090:	85 c0                	test   eax,eax
  401092:	75 d8                	jne    40106c <slm_blkpt_trigger+0xfc>
	return 0;
unlock:
	slm_cs_exit(NULL, SLM_CS_NONE);

	return ret;
}
  401094:	48 83 c4 08          	add    rsp,0x8
  401098:	44 89 e0             	mov    eax,r12d
  40109b:	5b                   	pop    rbx
  40109c:	41 5c                	pop    r12
  40109e:	41 5d                	pop    r13
  4010a0:	41 5e                	pop    r14
  4010a2:	41 5f                	pop    r15
  4010a4:	5d                   	pop    rbp
  4010a5:	c3                   	ret    
  4010a6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4010ad:	00 00 00 
	 * threads, but we'll implement this conservatively. Given
	 * this, please note that this should *not* iterate more than
	 * once.
	 */
	while (1) {
		sl = ps_load(&h->head);
  4010b0:	48 c1 e7 05          	shl    rdi,0x5
		/*
		 * Check sl again in case other thread updating the head,
		 * which might causes dereferencing a NULL pointer.
		 */
		if (!sl) return NULL;
		if (ps_cas((unsigned long *)&h->head, (unsigned long)sl, (unsigned long)sl->next)) break;
  4010b4:	49 81 c6 f0 86 5c 00 	add    r14,0x5c86f0
		sl = ps_load(&h->head);
  4010bb:	49 89 fd             	mov    r13,rdi
  4010be:	66 90                	xchg   ax,ax
	if (!h->head) return NULL;
  4010c0:	49 83 7f 10 00       	cmp    QWORD PTR [r15+0x10],0x0
  4010c5:	74 28                	je     4010ef <slm_blkpt_trigger+0x17f>
		sl = ps_load(&h->head);
  4010c7:	49 8d b5 e0 86 5c 00 	lea    rsi,[r13+0x5c86e0]
  4010ce:	eb 16                	jmp    4010e6 <slm_blkpt_trigger+0x176>
  4010d0:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
  4010d3:	48 89 d0             	mov    rax,rdx
  4010d6:	f0 49 0f b1 0e       	lock cmpxchg QWORD PTR [r14],rcx
  4010db:	0f 94 c0             	sete   al
		if (ps_cas((unsigned long *)&h->head, (unsigned long)sl, (unsigned long)sl->next)) break;
  4010de:	84 c0                	test   al,al
  4010e0:	0f 85 0a 01 00 00    	jne    4011f0 <slm_blkpt_trigger+0x280>
		sl = ps_load(&h->head);
  4010e6:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
		if (!sl) return NULL;
  4010ea:	48 85 d2             	test   rdx,rdx
  4010ed:	75 e1                	jne    4010d0 <slm_blkpt_trigger+0x160>
{ l->o = 0; }
  4010ef:	49 c7 47 18 00 00 00 	mov    QWORD PTR [r15+0x18],0x0
  4010f6:	00 
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  4010f7:	e8 54 a4 00 00       	call   40b550 <cos_defcompinfo_curr_get>
  4010fc:	0f 01 f9             	rdtscp 
	if (unlikely(!t)) t = &g->idle_thd;
  4010ff:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  401105:	4c 8d 24 89          	lea    r12,[rcx+rcx*4]
  401109:	49 c1 e4 06          	shl    r12,0x6
  40110d:	49 81 c4 80 65 71 00 	add    r12,0x716580
	tok  = cos_sched_sync();
  401114:	e8 f7 09 01 00       	call   411b10 <cos_sched_sync>
  401119:	41 89 c6             	mov    r14d,eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  40111c:	e8 7f 2a 01 00       	call   413ba0 <slm_sched_fprr_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  401121:	48 85 c0             	test   rax,rax
  401124:	49 89 c5             	mov    r13,rax
  401127:	4d 0f 44 ec          	cmove  r13,r12
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  40112b:	41 8b 45 04          	mov    eax,DWORD PTR [r13+0x4]
  40112f:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  401132:	83 f8 01             	cmp    eax,0x1
  401135:	0f 87 36 01 00 00    	ja     401271 <slm_blkpt_trigger+0x301>
  40113b:	0f 01 f9             	rdtscp 
	struct slm_cs *cs = &(slm_global()->lock);
  40113e:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  401144:	4c 8d 3c 89          	lea    r15,[rcx+rcx*4]
  401148:	49 c1 e7 06          	shl    r15,0x6
  40114c:	49 81 c7 00 65 71 00 	add    r15,0x716500
	while (ret != 0) {
  401153:	eb 0f                	jmp    401164 <slm_blkpt_trigger+0x1f4>
  401155:	0f 1f 00             	nop    DWORD PTR [rax]
        __asm__ __volatile__("lock " PS_CAS_STR
  401158:	f0 49 0f b1 17       	lock cmpxchg QWORD PTR [r15],rdx
  40115d:	0f 94 c0             	sete   al
  401160:	84 c0                	test   al,al
  401162:	75 28                	jne    40118c <slm_blkpt_trigger+0x21c>
		tok    = cos_sched_sync();
  401164:	e8 a7 09 01 00       	call   411b10 <cos_sched_sync>
  401169:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  40116b:	49 8b 07             	mov    rax,QWORD PTR [r15]
		if (unlikely(contention)) {
  40116e:	48 89 c2             	mov    rdx,rax
  401171:	83 e2 01             	and    edx,0x1
  401174:	74 e2                	je     401158 <slm_blkpt_trigger+0x1e8>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  401176:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  401179:	48 89 c2             	mov    rdx,rax
  40117c:	4c 89 ff             	mov    rdi,r15
  40117f:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  401183:	e8 18 3f 01 00       	call   4150a0 <slm_cs_exit_contention>
  401188:	85 c0                	test   eax,eax
  40118a:	75 d8                	jne    401164 <slm_blkpt_trigger+0x1f4>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  40118c:	e8 bf a3 00 00       	call   40b550 <cos_defcompinfo_curr_get>
  401191:	0f 01 f9             	rdtscp 
	*coreid = c & 0xFFF;
  401194:	89 ca                	mov    edx,ecx
	timeout = g->timeout_next;
  401196:	81 e1 ff 0f 00 00    	and    ecx,0xfff
	prio = inherit_prio ? curr->priority : t->priority;
  40119c:	49 8b 75 30          	mov    rsi,QWORD PTR [r13+0x30]
	timeout = g->timeout_next;
  4011a0:	48 8d 04 89          	lea    rax,[rcx+rcx*4]
  4011a4:	66 81 e2 ff 0f       	and    dx,0xfff
  4011a9:	49 89 cf             	mov    r15,rcx
  4011ac:	48 c1 e0 06          	shl    rax,0x6
  4011b0:	4c 8b 80 08 66 71 00 	mov    r8,QWORD PTR [rax+0x716608]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4011b7:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
  4011bb:	a8 0b                	test   al,0xb
  4011bd:	0f 85 ca 00 00 00    	jne    40128d <slm_blkpt_trigger+0x31d>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  4011c3:	49 8b 7d 10          	mov    rdi,QWORD PTR [r13+0x10]
  4011c7:	44 89 f1             	mov    ecx,r14d
  4011ca:	4c 89 c2             	mov    rdx,r8
  4011cd:	e8 ce b4 00 00       	call   40c6a0 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  4011d2:	83 f8 ff             	cmp    eax,0xffffffff
  4011d5:	0f 84 85 01 00 00    	je     401360 <slm_blkpt_trigger+0x3f0>
	if (unlikely(ret != 0)) {
  4011db:	85 c0                	test   eax,eax
  4011dd:	0f 85 11 01 00 00    	jne    4012f4 <slm_blkpt_trigger+0x384>
	return 0;
  4011e3:	45 31 e4             	xor    r12d,r12d
  4011e6:	e9 a9 fe ff ff       	jmp    401094 <slm_blkpt_trigger+0x124>
  4011eb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	}
	sl->next = NULL;
  4011f0:	48 c7 02 00 00 00 00 	mov    QWORD PTR [rdx],0x0
		slm_thd_wakeup(t, 0); /* ignore retval: process next thread */
  4011f7:	48 8b 7a 08          	mov    rdi,QWORD PTR [rdx+0x8]
  4011fb:	31 f6                	xor    esi,esi
  4011fd:	e8 9e 45 01 00       	call   4157a0 <slm_thd_wakeup>
		if (single) break;
  401202:	45 85 e4             	test   r12d,r12d
  401205:	0f 84 b5 fe ff ff    	je     4010c0 <slm_blkpt_trigger+0x150>
  40120b:	e9 df fe ff ff       	jmp    4010ef <slm_blkpt_trigger+0x17f>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  401210:	41 89 c0             	mov    r8d,eax
  401213:	48 89 da             	mov    rdx,rbx
  401216:	48 89 c6             	mov    rsi,rax
  401219:	4c 89 f7             	mov    rdi,r14
  40121c:	41 83 e0 01          	and    r8d,0x1
  401220:	e8 1b 3e 01 00       	call   415040 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  401225:	83 f8 f0             	cmp    eax,0xfffffff0
  401228:	0f 85 84 fd ff ff    	jne    400fb2 <slm_blkpt_trigger+0x42>
  40122e:	be 59 00 00 00       	mov    esi,0x59
  401233:	bf 60 d1 41 00       	mov    edi,0x41d160
  401238:	e8 43 9a 00 00       	call   40ac80 <cos_print_str>
  40123d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401244:	00 00 00 00 
  401248:	0f 0b                	ud2    
  40124a:	be 59 00 00 00       	mov    esi,0x59
  40124f:	bf 00 d1 41 00       	mov    edi,0x41d100
  401254:	e8 27 9a 00 00       	call   40ac80 <cos_print_str>
	assert(current);
  401259:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401260:	00 00 00 00 
  401264:	0f 0b                	ud2    
	if (!m) ERR_THROW(-1, unlock);
  401266:	41 bc ff ff ff ff    	mov    r12d,0xffffffff
  40126c:	e9 d3 fd ff ff       	jmp    401044 <slm_blkpt_trigger+0xd4>
  401271:	be 61 00 00 00       	mov    esi,0x61
  401276:	bf e8 d1 41 00       	mov    edi,0x41d1e8
  40127b:	e8 00 9a 00 00       	call   40ac80 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  401280:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401287:	00 00 00 00 
  40128b:	0f 0b                	ud2    
		if (t == &g->sched_thd) {
  40128d:	0f b7 d2             	movzx  edx,dx
	timeout = g->timeout_next;
  401290:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  401293:	48 8d 14 92          	lea    rdx,[rdx+rdx*4]
  401297:	48 c1 e2 06          	shl    rdx,0x6
  40129b:	48 81 c2 08 65 71 00 	add    rdx,0x716508
  4012a2:	49 39 d5             	cmp    r13,rdx
  4012a5:	0f 84 fb 00 00 00    	je     4013a6 <slm_blkpt_trigger+0x436>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  4012ab:	a8 02                	test   al,0x2
  4012ad:	0f 85 fe 00 00 00    	jne    4013b1 <slm_blkpt_trigger+0x441>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  4012b3:	49 89 c8             	mov    r8,rcx
  4012b6:	a8 01                	test   al,0x1
  4012b8:	0f 84 05 ff ff ff    	je     4011c3 <slm_blkpt_trigger+0x253>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  4012be:	4b 8d 04 bf          	lea    rax,[r15+r15*4]
  4012c2:	4d 8b 55 08          	mov    r10,QWORD PTR [r13+0x8]
  4012c6:	49 8b 7d 10          	mov    rdi,QWORD PTR [r13+0x10]
  4012ca:	48 89 f2             	mov    rdx,rsi
  4012cd:	48 c1 e0 06          	shl    rax,0x6
  4012d1:	45 89 f1             	mov    r9d,r14d
  4012d4:	4c 8b 80 28 65 71 00 	mov    r8,QWORD PTR [rax+0x716528]
  4012db:	4c 89 d6             	mov    rsi,r10
  4012de:	e8 4d 08 01 00       	call   411b30 <cos_switch>
	if (unlikely(ret != 0)) {
  4012e3:	85 c0                	test   eax,eax
  4012e5:	0f 84 f8 fe ff ff    	je     4011e3 <slm_blkpt_trigger+0x273>
		assert(ret != -EPERM);
  4012eb:	83 f8 ff             	cmp    eax,0xffffffff
  4012ee:	0f 84 96 00 00 00    	je     40138a <slm_blkpt_trigger+0x41a>
		assert(ret != -EINVAL);
  4012f4:	83 f8 ea             	cmp    eax,0xffffffea
  4012f7:	0f 84 3f 01 00 00    	je     40143c <slm_blkpt_trigger+0x4cc>
		if (ret == -EBUSY) return ret;
  4012fd:	83 f8 f0             	cmp    eax,0xfffffff0
  401300:	0f 84 dd fe ff ff    	je     4011e3 <slm_blkpt_trigger+0x273>
		assert(ret == -EAGAIN);
  401306:	83 f8 f5             	cmp    eax,0xfffffff5
  401309:	0f 85 11 01 00 00    	jne    401420 <slm_blkpt_trigger+0x4b0>
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  40130f:	0f 01 f9             	rdtscp 
	cs = &(slm_global()->lock);
  401312:	48 89 c8             	mov    rax,rcx
  401315:	25 ff 0f 00 00       	and    eax,0xfff
  40131a:	4c 8d 2c 80          	lea    r13,[rax+rax*4]
  40131e:	49 c1 e5 06          	shl    r13,0x6
  401322:	49 81 c5 00 65 71 00 	add    r13,0x716500
		tok    = cos_sched_sync();
  401329:	e8 e2 07 01 00       	call   411b10 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  40132e:	49 8b 75 00          	mov    rsi,QWORD PTR [r13+0x0]
  401332:	41 89 c1             	mov    r9d,eax
		if (unlikely(owner)) {
  401335:	48 89 f1             	mov    rcx,rsi
  401338:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  40133c:	0f 85 bd 00 00 00    	jne    4013ff <slm_blkpt_trigger+0x48f>
  401342:	48 89 f0             	mov    rax,rsi
  401345:	f0 49 0f b1 5d 00    	lock cmpxchg QWORD PTR [r13+0x0],rbx
  40134b:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  40134e:	84 c0                	test   al,al
  401350:	0f 85 be fd ff ff    	jne    401114 <slm_blkpt_trigger+0x1a4>
  401356:	eb d1                	jmp    401329 <slm_blkpt_trigger+0x3b9>
  401358:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40135f:	00 
  401360:	0f 01 f9             	rdtscp 
	return t != &g->idle_thd && t != &g->sched_thd;
  401363:	48 89 c8             	mov    rax,rcx
  401366:	25 ff 0f 00 00       	and    eax,0xfff
  40136b:	48 8d 04 80          	lea    rax,[rax+rax*4]
  40136f:	48 c1 e0 06          	shl    rax,0x6
  401373:	48 8d 90 80 65 71 00 	lea    rdx,[rax+0x716580]
  40137a:	49 39 d5             	cmp    r13,rdx
  40137d:	74 55                	je     4013d4 <slm_blkpt_trigger+0x464>
  40137f:	48 05 08 65 71 00    	add    rax,0x716508
  401385:	49 39 c5             	cmp    r13,rax
  401388:	74 4a                	je     4013d4 <slm_blkpt_trigger+0x464>
  40138a:	be 61 00 00 00       	mov    esi,0x61
  40138f:	bf 50 d2 41 00       	mov    edi,0x41d250
  401394:	e8 e7 98 00 00       	call   40ac80 <cos_print_str>
		assert(ret != -EPERM);
  401399:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4013a0:	00 00 00 00 
  4013a4:	0f 0b                	ud2    
			prio    = curr->priority;
  4013a6:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
			timeout = TCAP_TIME_NIL;
  4013aa:	31 c9                	xor    ecx,ecx
  4013ac:	e9 fa fe ff ff       	jmp    4012ab <slm_blkpt_trigger+0x33b>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  4013b1:	4b 8d 04 bf          	lea    rax,[r15+r15*4]
  4013b5:	49 8b 7d 28          	mov    rdi,QWORD PTR [r13+0x28]
  4013b9:	44 89 f1             	mov    ecx,r14d
  4013bc:	4c 89 c6             	mov    rsi,r8
  4013bf:	48 c1 e0 06          	shl    rax,0x6
  4013c3:	48 8b 90 28 65 71 00 	mov    rdx,QWORD PTR [rax+0x716528]
  4013ca:	e8 d1 07 01 00       	call   411ba0 <cos_sched_asnd>
  4013cf:	e9 0f ff ff ff       	jmp    4012e3 <slm_blkpt_trigger+0x373>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  4013d4:	4b 8d 04 bf          	lea    rax,[r15+r15*4]
  4013d8:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]
  4013dc:	45 89 f1             	mov    r9d,r14d
  4013df:	31 c9                	xor    ecx,ecx
  4013e1:	48 c1 e0 06          	shl    rax,0x6
  4013e5:	31 f6                	xor    esi,esi
  4013e7:	4c 8b 80 28 65 71 00 	mov    r8,QWORD PTR [rax+0x716528]
  4013ee:	48 8b b8 18 65 71 00 	mov    rdi,QWORD PTR [rax+0x716518]
  4013f5:	e8 36 07 01 00       	call   411b30 <cos_switch>
  4013fa:	e9 e4 fe ff ff       	jmp    4012e3 <slm_blkpt_trigger+0x373>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  4013ff:	41 89 f0             	mov    r8d,esi
  401402:	48 89 da             	mov    rdx,rbx
  401405:	4c 89 ef             	mov    rdi,r13
  401408:	41 83 e0 01          	and    r8d,0x1
  40140c:	e8 2f 3c 01 00       	call   415040 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  401411:	83 f8 f0             	cmp    eax,0xfffffff0
  401414:	0f 85 0f ff ff ff    	jne    401329 <slm_blkpt_trigger+0x3b9>
  40141a:	e9 0f fe ff ff       	jmp    40122e <slm_blkpt_trigger+0x2be>
  40141f:	90                   	nop
  401420:	be 61 00 00 00       	mov    esi,0x61
  401425:	bf 20 d3 41 00       	mov    edi,0x41d320
  40142a:	e8 51 98 00 00       	call   40ac80 <cos_print_str>
		assert(ret == -EAGAIN);
  40142f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401436:	00 00 00 00 
  40143a:	0f 0b                	ud2    
  40143c:	be 61 00 00 00       	mov    esi,0x61
  401441:	bf b8 d2 41 00       	mov    edi,0x41d2b8
  401446:	e8 35 98 00 00       	call   40ac80 <cos_print_str>
		assert(ret != -EINVAL);
  40144b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401452:	00 00 00 00 
  401456:	0f 0b                	ud2    
  401458:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40145f:	00 

0000000000401460 <slm_blkpt_block>:

int
slm_blkpt_block(sched_blkpt_id_t blkpt, struct slm_thd *current, sched_blkpt_epoch_t epoch, thdid_t dependency)
{
  401460:	f3 0f 1e fa          	endbr64 
  401464:	55                   	push   rbp
  401465:	48 89 e5             	mov    rbp,rsp
  401468:	41 57                	push   r15
  40146a:	41 56                	push   r14
  40146c:	41 55                	push   r13
  40146e:	41 54                	push   r12
  401470:	53                   	push   rbx
  401471:	48 83 ec 28          	sub    rsp,0x28
	assert(current);
  401475:	48 85 f6             	test   rsi,rsi
  401478:	0f 84 2c 02 00 00    	je     4016aa <slm_blkpt_block+0x24a>
  40147e:	41 89 fe             	mov    r14d,edi
  401481:	48 89 f3             	mov    rbx,rsi
  401484:	49 89 d4             	mov    r12,rdx
  401487:	0f 01 f9             	rdtscp 
	cs = &(slm_global()->lock);
  40148a:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  401490:	4c 8d 2c 89          	lea    r13,[rcx+rcx*4]
  401494:	49 c1 e5 06          	shl    r13,0x6
  401498:	49 81 c5 00 65 71 00 	add    r13,0x716500
		tok    = cos_sched_sync();
  40149f:	e8 6c 06 01 00       	call   411b10 <cos_sched_sync>
  4014a4:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4014a7:	49 8b 45 00          	mov    rax,QWORD PTR [r13+0x0]
		if (unlikely(owner)) {
  4014ab:	48 89 c1             	mov    rcx,rax
  4014ae:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  4014b2:	0f 85 b8 01 00 00    	jne    401670 <slm_blkpt_block+0x210>
  4014b8:	f0 49 0f b1 5d 00    	lock cmpxchg QWORD PTR [r13+0x0],rbx
  4014be:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4014c1:	84 c0                	test   al,al
  4014c3:	74 da                	je     40149f <slm_blkpt_block+0x3f>
	if (id - 1 == NBLKPTS) return NULL;
  4014c5:	41 81 fe 01 a0 00 00 	cmp    r14d,0xa001
  4014cc:	0f 84 f4 01 00 00    	je     4016c6 <slm_blkpt_block+0x266>
	return &__blkpts[id-1];
  4014d2:	45 8d 46 ff          	lea    r8d,[r14-0x1]
  4014d6:	be 01 00 00 00       	mov    esi,0x1
  4014db:	31 c9                	xor    ecx,ecx
  4014dd:	4c 89 c7             	mov    rdi,r8
  4014e0:	48 c1 e7 05          	shl    rdi,0x5
  4014e4:	4c 8d af e0 86 5c 00 	lea    r13,[rdi+0x5c86e0]
{ while (!ps_cas(&l->o, 0, 1)) ; }
  4014eb:	48 8d 97 f8 86 5c 00 	lea    rdx,[rdi+0x5c86f8]
  4014f2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  4014f8:	48 89 c8             	mov    rax,rcx
  4014fb:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  401500:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  401503:	84 c0                	test   al,al
  401505:	74 f1                	je     4014f8 <slm_blkpt_block+0x98>
		ERR_THROW(-1, unlock);
	}

	ps_lock_take(&m->lock);
	/* Outdated event? don't block! */
	pre = ps_load(&m->epoch);
  401507:	49 8b 75 08          	mov    rsi,QWORD PTR [r13+0x8]
	if (!blkpt_epoch_is_higher(pre, epoch)) {
  40150b:	4c 39 e6             	cmp    rsi,r12
  40150e:	76 70                	jbe    401580 <slm_blkpt_block+0x120>
{ l->o = 0; }
  401510:	49 c7 45 18 00 00 00 	mov    QWORD PTR [r13+0x18],0x0
  401517:	00 
			 */
			assert(_sl == &sl);
		}
		assert(stacklist_is_removed(&sl));
		ps_lock_release(&m->lock);
		ERR_THROW(0, unlock);
  401518:	45 31 e4             	xor    r12d,r12d
  40151b:	0f 01 f9             	rdtscp 
	struct slm_cs *cs = &(slm_global()->lock);
  40151e:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  401524:	48 8d 1c 89          	lea    rbx,[rcx+rcx*4]
  401528:	48 c1 e3 06          	shl    rbx,0x6
  40152c:	48 81 c3 00 65 71 00 	add    rbx,0x716500
	while (ret != 0) {
  401533:	eb 0f                	jmp    401544 <slm_blkpt_block+0xe4>
  401535:	0f 1f 00             	nop    DWORD PTR [rax]
        __asm__ __volatile__("lock " PS_CAS_STR
  401538:	f0 48 0f b1 13       	lock cmpxchg QWORD PTR [rbx],rdx
  40153d:	0f 94 c0             	sete   al
  401540:	84 c0                	test   al,al
  401542:	75 28                	jne    40156c <slm_blkpt_block+0x10c>
		tok    = cos_sched_sync();
  401544:	e8 c7 05 01 00       	call   411b10 <cos_sched_sync>
  401549:	89 c1                	mov    ecx,eax
  40154b:	48 8b 03             	mov    rax,QWORD PTR [rbx]
		if (unlikely(contention)) {
  40154e:	48 89 c2             	mov    rdx,rax
  401551:	83 e2 01             	and    edx,0x1
  401554:	74 e2                	je     401538 <slm_blkpt_block+0xd8>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  401556:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  401559:	48 89 c2             	mov    rdx,rax
  40155c:	48 89 df             	mov    rdi,rbx
  40155f:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  401563:	e8 38 3b 01 00       	call   4150a0 <slm_cs_exit_contention>
  401568:	85 c0                	test   eax,eax
  40156a:	75 d8                	jne    401544 <slm_blkpt_block+0xe4>
	return 0;
unlock:
	slm_cs_exit(NULL, SLM_CS_NONE);

	return ret;
}
  40156c:	48 83 c4 28          	add    rsp,0x28
  401570:	44 89 e0             	mov    eax,r12d
  401573:	5b                   	pop    rbx
  401574:	41 5c                	pop    r12
  401576:	41 5d                	pop    r13
  401578:	41 5e                	pop    r14
  40157a:	41 5f                	pop    r15
  40157c:	5d                   	pop    rbp
  40157d:	c3                   	ret    
  40157e:	66 90                	xchg   ax,ax
		struct stacklist *n = ps_load(&h->head);
  401580:	4c 89 c1             	mov    rcx,r8
	l->data = data;
  401583:	48 89 5d c8          	mov    QWORD PTR [rbp-0x38],rbx
		if (ps_cas((unsigned long *)&h->head, (unsigned long)n, (unsigned long)l)) break;
  401587:	48 8d 97 f0 86 5c 00 	lea    rdx,[rdi+0x5c86f0]
  40158e:	48 8d 7d c0          	lea    rdi,[rbp-0x40]
		struct stacklist *n = ps_load(&h->head);
  401592:	48 c1 e1 05          	shl    rcx,0x5
  401596:	48 81 c1 e0 86 5c 00 	add    rcx,0x5c86e0
  40159d:	0f 1f 00             	nop    DWORD PTR [rax]
  4015a0:	48 8b 41 10          	mov    rax,QWORD PTR [rcx+0x10]
		l->next = n;
  4015a4:	48 89 45 c0          	mov    QWORD PTR [rbp-0x40],rax
  4015a8:	f0 48 0f b1 3a       	lock cmpxchg QWORD PTR [rdx],rdi
  4015ad:	0f 94 c0             	sete   al
		if (ps_cas((unsigned long *)&h->head, (unsigned long)n, (unsigned long)l)) break;
  4015b0:	84 c0                	test   al,al
  4015b2:	74 ec                	je     4015a0 <slm_blkpt_block+0x140>
	if (!blkpt_epoch_is_higher(ps_load(&m->epoch), pre)) {
  4015b4:	49 8b 45 08          	mov    rax,QWORD PTR [r13+0x8]
  4015b8:	48 39 f0             	cmp    rax,rsi
  4015bb:	0f 86 8f 00 00 00    	jbe    401650 <slm_blkpt_block+0x1f0>
	if (!h->head) return NULL;
  4015c1:	49 83 7d 10 00       	cmp    QWORD PTR [r13+0x10],0x0
  4015c6:	74 2b                	je     4015f3 <slm_blkpt_block+0x193>
		sl = ps_load(&h->head);
  4015c8:	49 c1 e0 05          	shl    r8,0x5
  4015cc:	49 81 c0 e0 86 5c 00 	add    r8,0x5c86e0
  4015d3:	eb 15                	jmp    4015ea <slm_blkpt_block+0x18a>
  4015d5:	0f 1f 00             	nop    DWORD PTR [rax]
  4015d8:	48 8b 31             	mov    rsi,QWORD PTR [rcx]
  4015db:	48 89 c8             	mov    rax,rcx
  4015de:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  4015e3:	0f 94 c0             	sete   al
		if (ps_cas((unsigned long *)&h->head, (unsigned long)sl, (unsigned long)sl->next)) break;
  4015e6:	84 c0                	test   al,al
  4015e8:	75 36                	jne    401620 <slm_blkpt_block+0x1c0>
		sl = ps_load(&h->head);
  4015ea:	49 8b 48 10          	mov    rcx,QWORD PTR [r8+0x10]
		if (!sl) return NULL;
  4015ee:	48 85 c9             	test   rcx,rcx
  4015f1:	75 e5                	jne    4015d8 <slm_blkpt_block+0x178>
		assert(stacklist_is_removed(&sl));
  4015f3:	48 83 7d c0 00       	cmp    QWORD PTR [rbp-0x40],0x0
  4015f8:	0f 84 12 ff ff ff    	je     401510 <slm_blkpt_block+0xb0>
  4015fe:	be 5f 00 00 00       	mov    esi,0x5f
  401603:	bf e8 d3 41 00       	mov    edi,0x41d3e8
  401608:	e8 73 96 00 00       	call   40ac80 <cos_print_str>
  40160d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401614:	00 00 00 00 
  401618:	0f 0b                	ud2    
  40161a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	sl->next = NULL;
  401620:	48 c7 01 00 00 00 00 	mov    QWORD PTR [rcx],0x0
			assert(_sl == &sl);
  401627:	48 39 f9             	cmp    rcx,rdi
  40162a:	74 c7                	je     4015f3 <slm_blkpt_block+0x193>
  40162c:	be 5f 00 00 00       	mov    esi,0x5f
  401631:	bf 88 d3 41 00       	mov    edi,0x41d388
  401636:	e8 45 96 00 00       	call   40ac80 <cos_print_str>
  40163b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401642:	00 00 00 00 
  401646:	0f 0b                	ud2    
  401648:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40164f:	00 
	if (slm_thd_block(current)) {
  401650:	48 89 df             	mov    rdi,rbx
  401653:	e8 c8 3a 01 00       	call   415120 <slm_thd_block>
{ l->o = 0; }
  401658:	49 c7 45 18 00 00 00 	mov    QWORD PTR [r13+0x18],0x0
  40165f:	00 
  401660:	41 89 c4             	mov    r12d,eax
  401663:	85 c0                	test   eax,eax
  401665:	74 6a                	je     4016d1 <slm_blkpt_block+0x271>
		ERR_THROW(0, unlock);
  401667:	45 31 e4             	xor    r12d,r12d
  40166a:	e9 ac fe ff ff       	jmp    40151b <slm_blkpt_block+0xbb>
  40166f:	90                   	nop
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  401670:	41 89 c0             	mov    r8d,eax
  401673:	48 89 da             	mov    rdx,rbx
  401676:	48 89 c6             	mov    rsi,rax
  401679:	4c 89 ef             	mov    rdi,r13
  40167c:	41 83 e0 01          	and    r8d,0x1
  401680:	e8 bb 39 01 00       	call   415040 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  401685:	83 f8 f0             	cmp    eax,0xfffffff0
  401688:	0f 85 11 fe ff ff    	jne    40149f <slm_blkpt_block+0x3f>
  40168e:	be 59 00 00 00       	mov    esi,0x59
  401693:	bf 60 d1 41 00       	mov    edi,0x41d160
  401698:	e8 e3 95 00 00       	call   40ac80 <cos_print_str>
  40169d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4016a4:	00 00 00 00 
  4016a8:	0f 0b                	ud2    
  4016aa:	be 59 00 00 00       	mov    esi,0x59
  4016af:	bf 00 d1 41 00       	mov    edi,0x41d100
  4016b4:	e8 c7 95 00 00       	call   40ac80 <cos_print_str>
	assert(current);
  4016b9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4016c0:	00 00 00 00 
  4016c4:	0f 0b                	ud2    
		ERR_THROW(-1, unlock);
  4016c6:	41 bc ff ff ff ff    	mov    r12d,0xffffffff
  4016cc:	e9 4a fe ff ff       	jmp    40151b <slm_blkpt_block+0xbb>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  4016d1:	e8 7a 9e 00 00       	call   40b550 <cos_defcompinfo_curr_get>
  4016d6:	0f 01 f9             	rdtscp 
	if (unlikely(!t)) t = &g->idle_thd;
  4016d9:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  4016df:	4c 8d 34 89          	lea    r14,[rcx+rcx*4]
  4016e3:	49 c1 e6 06          	shl    r14,0x6
  4016e7:	49 8d 86 80 65 71 00 	lea    rax,[r14+0x716580]
  4016ee:	48 89 45 b8          	mov    QWORD PTR [rbp-0x48],rax
	tok  = cos_sched_sync();
  4016f2:	e8 19 04 01 00       	call   411b10 <cos_sched_sync>
  4016f7:	41 89 c7             	mov    r15d,eax
  4016fa:	e8 a1 24 01 00       	call   413ba0 <slm_sched_fprr_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  4016ff:	48 85 c0             	test   rax,rax
  401702:	49 89 c5             	mov    r13,rax
  401705:	4c 0f 44 6d b8       	cmove  r13,QWORD PTR [rbp-0x48]
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  40170a:	41 8b 45 04          	mov    eax,DWORD PTR [r13+0x4]
  40170e:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  401711:	83 f8 01             	cmp    eax,0x1
  401714:	0f 87 e6 01 00 00    	ja     401900 <slm_blkpt_block+0x4a0>
  40171a:	0f 01 f9             	rdtscp 
	struct slm_cs *cs = &(slm_global()->lock);
  40171d:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  401723:	48 8d 3c 89          	lea    rdi,[rcx+rcx*4]
  401727:	48 c1 e7 06          	shl    rdi,0x6
  40172b:	4c 8d b7 00 65 71 00 	lea    r14,[rdi+0x716500]
	while (ret != 0) {
  401732:	eb 10                	jmp    401744 <slm_blkpt_block+0x2e4>
  401734:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  401738:	f0 49 0f b1 16       	lock cmpxchg QWORD PTR [r14],rdx
  40173d:	0f 94 c0             	sete   al
  401740:	84 c0                	test   al,al
  401742:	75 28                	jne    40176c <slm_blkpt_block+0x30c>
		tok    = cos_sched_sync();
  401744:	e8 c7 03 01 00       	call   411b10 <cos_sched_sync>
  401749:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  40174b:	49 8b 06             	mov    rax,QWORD PTR [r14]
		if (unlikely(contention)) {
  40174e:	48 89 c2             	mov    rdx,rax
  401751:	83 e2 01             	and    edx,0x1
  401754:	74 e2                	je     401738 <slm_blkpt_block+0x2d8>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  401756:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  401759:	48 89 c2             	mov    rdx,rax
  40175c:	4c 89 f7             	mov    rdi,r14
  40175f:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  401763:	e8 38 39 01 00       	call   4150a0 <slm_cs_exit_contention>
  401768:	85 c0                	test   eax,eax
  40176a:	75 d8                	jne    401744 <slm_blkpt_block+0x2e4>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  40176c:	e8 df 9d 00 00       	call   40b550 <cos_defcompinfo_curr_get>
  401771:	0f 01 f9             	rdtscp 
	*coreid = c & 0xFFF;
  401774:	89 ca                	mov    edx,ecx
	timeout = g->timeout_next;
  401776:	81 e1 ff 0f 00 00    	and    ecx,0xfff
	prio = inherit_prio ? curr->priority : t->priority;
  40177c:	49 8b 75 30          	mov    rsi,QWORD PTR [r13+0x30]
	timeout = g->timeout_next;
  401780:	48 8d 04 89          	lea    rax,[rcx+rcx*4]
  401784:	66 81 e2 ff 0f       	and    dx,0xfff
  401789:	49 89 ce             	mov    r14,rcx
  40178c:	48 c1 e0 06          	shl    rax,0x6
  401790:	4c 8b 88 08 66 71 00 	mov    r9,QWORD PTR [rax+0x716608]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  401797:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
  40179b:	a8 0b                	test   al,0xb
  40179d:	0f 85 91 00 00 00    	jne    401834 <slm_blkpt_block+0x3d4>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  4017a3:	49 8b 7d 10          	mov    rdi,QWORD PTR [r13+0x10]
  4017a7:	44 89 f9             	mov    ecx,r15d
  4017aa:	4c 89 ca             	mov    rdx,r9
  4017ad:	e8 ee ae 00 00       	call   40c6a0 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  4017b2:	83 f8 ff             	cmp    eax,0xffffffff
  4017b5:	74 2f                	je     4017e6 <slm_blkpt_block+0x386>
	if (unlikely(ret != 0)) {
  4017b7:	85 c0                	test   eax,eax
  4017b9:	0f 85 d7 00 00 00    	jne    401896 <slm_blkpt_block+0x436>
	assert(stacklist_is_removed(&sl));
  4017bf:	48 83 7d c0 00       	cmp    QWORD PTR [rbp-0x40],0x0
  4017c4:	0f 84 a2 fd ff ff    	je     40156c <slm_blkpt_block+0x10c>
  4017ca:	be 5f 00 00 00       	mov    esi,0x5f
  4017cf:	bf 48 d4 41 00       	mov    edi,0x41d448
  4017d4:	e8 a7 94 00 00       	call   40ac80 <cos_print_str>
  4017d9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4017e0:	00 00 00 00 
  4017e4:	0f 0b                	ud2    
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  4017e6:	0f 01 f9             	rdtscp 
	return t != &g->idle_thd && t != &g->sched_thd;
  4017e9:	48 89 c8             	mov    rax,rcx
  4017ec:	25 ff 0f 00 00       	and    eax,0xfff
  4017f1:	48 8d 04 80          	lea    rax,[rax+rax*4]
  4017f5:	48 c1 e0 06          	shl    rax,0x6
  4017f9:	48 8d 90 80 65 71 00 	lea    rdx,[rax+0x716580]
  401800:	49 39 d5             	cmp    r13,rdx
  401803:	0f 84 41 01 00 00    	je     40194a <slm_blkpt_block+0x4ea>
  401809:	48 05 08 65 71 00    	add    rax,0x716508
  40180f:	49 39 c5             	cmp    r13,rax
  401812:	0f 84 32 01 00 00    	je     40194a <slm_blkpt_block+0x4ea>
  401818:	be 61 00 00 00       	mov    esi,0x61
  40181d:	bf 50 d2 41 00       	mov    edi,0x41d250
  401822:	e8 59 94 00 00       	call   40ac80 <cos_print_str>
		assert(ret != -EPERM);
  401827:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40182e:	00 00 00 00 
  401832:	0f 0b                	ud2    
		if (t == &g->sched_thd) {
  401834:	0f b7 d2             	movzx  edx,dx
	timeout = g->timeout_next;
  401837:	4c 89 c9             	mov    rcx,r9
		if (t == &g->sched_thd) {
  40183a:	48 8d 14 92          	lea    rdx,[rdx+rdx*4]
  40183e:	48 c1 e2 06          	shl    rdx,0x6
  401842:	48 81 c2 08 65 71 00 	add    rdx,0x716508
  401849:	49 39 d5             	cmp    r13,rdx
  40184c:	0f 84 ca 00 00 00    	je     40191c <slm_blkpt_block+0x4bc>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  401852:	a8 02                	test   al,0x2
  401854:	0f 85 cd 00 00 00    	jne    401927 <slm_blkpt_block+0x4c7>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  40185a:	49 89 c9             	mov    r9,rcx
  40185d:	a8 01                	test   al,0x1
  40185f:	0f 84 3e ff ff ff    	je     4017a3 <slm_blkpt_block+0x343>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  401865:	4d 8b 55 08          	mov    r10,QWORD PTR [r13+0x8]
  401869:	49 8b 7d 10          	mov    rdi,QWORD PTR [r13+0x10]
  40186d:	48 89 f2             	mov    rdx,rsi
  401870:	45 89 f9             	mov    r9d,r15d
  401873:	4d 69 c6 40 01 00 00 	imul   r8,r14,0x140
  40187a:	4c 89 d6             	mov    rsi,r10
  40187d:	4d 8b 80 28 65 71 00 	mov    r8,QWORD PTR [r8+0x716528]
  401884:	e8 a7 02 01 00       	call   411b30 <cos_switch>
	if (unlikely(ret != 0)) {
  401889:	85 c0                	test   eax,eax
  40188b:	0f 84 2e ff ff ff    	je     4017bf <slm_blkpt_block+0x35f>
		assert(ret != -EPERM);
  401891:	83 f8 ff             	cmp    eax,0xffffffff
  401894:	74 82                	je     401818 <slm_blkpt_block+0x3b8>
		assert(ret != -EINVAL);
  401896:	83 f8 ea             	cmp    eax,0xffffffea
  401899:	0f 84 11 01 00 00    	je     4019b0 <slm_blkpt_block+0x550>
		if (ret == -EBUSY) return ret;
  40189f:	83 f8 f0             	cmp    eax,0xfffffff0
  4018a2:	0f 84 17 ff ff ff    	je     4017bf <slm_blkpt_block+0x35f>
		assert(ret == -EAGAIN);
  4018a8:	83 f8 f5             	cmp    eax,0xfffffff5
  4018ab:	0f 85 e3 00 00 00    	jne    401994 <slm_blkpt_block+0x534>
  4018b1:	0f 01 f9             	rdtscp 
	cs = &(slm_global()->lock);
  4018b4:	48 89 c8             	mov    rax,rcx
  4018b7:	25 ff 0f 00 00       	and    eax,0xfff
  4018bc:	4c 8d 2c 80          	lea    r13,[rax+rax*4]
  4018c0:	49 c1 e5 06          	shl    r13,0x6
  4018c4:	49 81 c5 00 65 71 00 	add    r13,0x716500
		tok    = cos_sched_sync();
  4018cb:	e8 40 02 01 00       	call   411b10 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  4018d0:	49 8b 75 00          	mov    rsi,QWORD PTR [r13+0x0]
  4018d4:	41 89 c1             	mov    r9d,eax
		if (unlikely(owner)) {
  4018d7:	48 89 f1             	mov    rcx,rsi
  4018da:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  4018de:	0f 85 90 00 00 00    	jne    401974 <slm_blkpt_block+0x514>
  4018e4:	48 89 f0             	mov    rax,rsi
  4018e7:	f0 49 0f b1 5d 00    	lock cmpxchg QWORD PTR [r13+0x0],rbx
  4018ed:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4018f0:	84 c0                	test   al,al
  4018f2:	0f 85 fa fd ff ff    	jne    4016f2 <slm_blkpt_block+0x292>
  4018f8:	eb d1                	jmp    4018cb <slm_blkpt_block+0x46b>
  4018fa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  401900:	be 61 00 00 00       	mov    esi,0x61
  401905:	bf e8 d1 41 00       	mov    edi,0x41d1e8
  40190a:	e8 71 93 00 00       	call   40ac80 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  40190f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401916:	00 00 00 00 
  40191a:	0f 0b                	ud2    
			prio    = curr->priority;
  40191c:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
			timeout = TCAP_TIME_NIL;
  401920:	31 c9                	xor    ecx,ecx
  401922:	e9 2b ff ff ff       	jmp    401852 <slm_blkpt_block+0x3f2>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  401927:	4b 8d 04 b6          	lea    rax,[r14+r14*4]
  40192b:	49 8b 7d 28          	mov    rdi,QWORD PTR [r13+0x28]
  40192f:	44 89 f9             	mov    ecx,r15d
  401932:	4c 89 ce             	mov    rsi,r9
  401935:	48 c1 e0 06          	shl    rax,0x6
  401939:	48 8b 90 28 65 71 00 	mov    rdx,QWORD PTR [rax+0x716528]
  401940:	e8 5b 02 01 00       	call   411ba0 <cos_sched_asnd>
  401945:	e9 3f ff ff ff       	jmp    401889 <slm_blkpt_block+0x429>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  40194a:	49 69 c6 40 01 00 00 	imul   rax,r14,0x140
  401951:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]
  401955:	45 89 f9             	mov    r9d,r15d
  401958:	31 c9                	xor    ecx,ecx
  40195a:	31 f6                	xor    esi,esi
  40195c:	4c 8b 80 28 65 71 00 	mov    r8,QWORD PTR [rax+0x716528]
  401963:	48 8b b8 18 65 71 00 	mov    rdi,QWORD PTR [rax+0x716518]
  40196a:	e8 c1 01 01 00       	call   411b30 <cos_switch>
  40196f:	e9 15 ff ff ff       	jmp    401889 <slm_blkpt_block+0x429>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  401974:	41 89 f0             	mov    r8d,esi
  401977:	48 89 da             	mov    rdx,rbx
  40197a:	4c 89 ef             	mov    rdi,r13
  40197d:	41 83 e0 01          	and    r8d,0x1
  401981:	e8 ba 36 01 00       	call   415040 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  401986:	83 f8 f0             	cmp    eax,0xfffffff0
  401989:	0f 85 3c ff ff ff    	jne    4018cb <slm_blkpt_block+0x46b>
  40198f:	e9 fa fc ff ff       	jmp    40168e <slm_blkpt_block+0x22e>
  401994:	be 61 00 00 00       	mov    esi,0x61
  401999:	bf 20 d3 41 00       	mov    edi,0x41d320
  40199e:	e8 dd 92 00 00       	call   40ac80 <cos_print_str>
		assert(ret == -EAGAIN);
  4019a3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4019aa:	00 00 00 00 
  4019ae:	0f 0b                	ud2    
  4019b0:	be 61 00 00 00       	mov    esi,0x61
  4019b5:	bf b8 d2 41 00       	mov    edi,0x41d2b8
  4019ba:	e8 c1 92 00 00       	call   40ac80 <cos_print_str>
		assert(ret != -EINVAL);
  4019bf:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4019c6:	00 00 00 00 
  4019ca:	0f 0b                	ud2    
  4019cc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

00000000004019d0 <slm_thd_timer_policy>:
SLM_MODULES_COMPOSE_DATA();
  4019d0:	f3 0f 1e fa          	endbr64 
  4019d4:	48 8d 87 88 00 00 00 	lea    rax,[rdi+0x88]
  4019db:	c3                   	ret    
  4019dc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

00000000004019e0 <slm_thd_sched_policy>:
  4019e0:	f3 0f 1e fa          	endbr64 
  4019e4:	48 8d 47 78          	lea    rax,[rdi+0x78]
  4019e8:	c3                   	ret    
  4019e9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

00000000004019f0 <slm_thd_from_timer>:
  4019f0:	f3 0f 1e fa          	endbr64 
  4019f4:	48 8d 87 78 ff ff ff 	lea    rax,[rdi-0x88]
  4019fb:	c3                   	ret    
  4019fc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000401a00 <slm_thd_from_sched>:
  401a00:	f3 0f 1e fa          	endbr64 
  401a04:	48 8d 47 88          	lea    rax,[rdi-0x78]
  401a08:	c3                   	ret    
  401a09:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401a10 <slm_timer_expire>:
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  401a10:	f3 0f 1e fa          	endbr64 
  401a14:	e9 c7 25 01 00       	jmp    413fe0 <slm_timer_quantum_expire>
  401a19:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401a20 <slm_timer_thd_init>:
  401a20:	f3 0f 1e fa          	endbr64 
  401a24:	e9 d7 28 01 00       	jmp    414300 <slm_timer_quantum_thd_init>
  401a29:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401a30 <slm_timer_thd_deinit>:
  401a30:	f3 0f 1e fa          	endbr64 
  401a34:	e9 e7 28 01 00       	jmp    414320 <slm_timer_quantum_thd_deinit>
  401a39:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401a40 <slm_timer_add>:
  401a40:	f3 0f 1e fa          	endbr64 
  401a44:	e9 67 27 01 00       	jmp    4141b0 <slm_timer_quantum_add>
  401a49:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401a50 <slm_timer_cancel>:
  401a50:	f3 0f 1e fa          	endbr64 
  401a54:	e9 07 28 01 00       	jmp    414260 <slm_timer_quantum_cancel>
  401a59:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401a60 <slm_timer_init>:
  401a60:	f3 0f 1e fa          	endbr64 
  401a64:	e9 c7 28 01 00       	jmp    414330 <slm_timer_quantum_init>
  401a69:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401a70 <slm_sched_init>:
  401a70:	f3 0f 1e fa          	endbr64 
  401a74:	e9 87 24 01 00       	jmp    413f00 <slm_sched_fprr_init>
  401a79:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401a80 <slm_sched_thd_init>:
  401a80:	f3 0f 1e fa          	endbr64 
  401a84:	e9 b7 22 01 00       	jmp    413d40 <slm_sched_fprr_thd_init>
  401a89:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401a90 <slm_sched_thd_deinit>:
  401a90:	f3 0f 1e fa          	endbr64 
  401a94:	e9 d7 22 01 00       	jmp    413d70 <slm_sched_fprr_thd_deinit>
  401a99:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401aa0 <slm_sched_thd_update>:
  401aa0:	f3 0f 1e fa          	endbr64 
  401aa4:	e9 f7 22 01 00       	jmp    413da0 <slm_sched_fprr_thd_update>
  401aa9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401ab0 <slm_sched_block>:
  401ab0:	f3 0f 1e fa          	endbr64 
  401ab4:	e9 67 21 01 00       	jmp    413c20 <slm_sched_fprr_block>
  401ab9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401ac0 <slm_sched_wakeup>:
  401ac0:	f3 0f 1e fa          	endbr64 
  401ac4:	e9 87 21 01 00       	jmp    413c50 <slm_sched_fprr_wakeup>
  401ac9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401ad0 <slm_sched_yield>:
  401ad0:	f3 0f 1e fa          	endbr64 
  401ad4:	e9 f7 21 01 00       	jmp    413cd0 <slm_sched_fprr_yield>
  401ad9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401ae0 <slm_sched_schedule>:
  401ae0:	f3 0f 1e fa          	endbr64 
  401ae4:	e9 b7 20 01 00       	jmp    413ba0 <slm_sched_fprr_schedule>
  401ae9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401af0 <slm_sched_execution>:
  401af0:	f3 0f 1e fa          	endbr64 
  401af4:	e9 97 20 01 00       	jmp    413b90 <slm_sched_fprr_execution>
  401af9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000401b00 <slm_thd_lookup>:
  401b00:	f3 0f 1e fa          	endbr64 
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  401b04:	85 ff                	test   edi,edi
  401b06:	74 38                	je     401b40 <slm_thd_lookup+0x40>
  401b08:	83 ef 01             	sub    edi,0x1
  401b0b:	81 ff c7 00 00 00    	cmp    edi,0xc7
  401b11:	77 2d                	ja     401b40 <slm_thd_lookup+0x40>
  401b13:	48 8b 14 fd 20 f7 5b 	mov    rdx,QWORD PTR [rdi*8+0x5bf720]
  401b1a:	00 
  401b1b:	31 c0                	xor    eax,eax
  401b1d:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  401b24:	74 1c                	je     401b42 <slm_thd_lookup+0x42>
  401b26:	83 e2 01             	and    edx,0x1
  401b29:	75 17                	jne    401b42 <slm_thd_lookup+0x42>
  401b2b:	48 8d 04 bf          	lea    rax,[rdi+rdi*4]
  401b2f:	48 8d 04 47          	lea    rax,[rdi+rax*2]
  401b33:	48 c1 e0 04          	shl    rax,0x4
  401b37:	48 05 60 fd 5b 00    	add    rax,0x5bfd60
  401b3d:	c3                   	ret    
  401b3e:	66 90                	xchg   ax,ax
  401b40:	31 c0                	xor    eax,eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  401b42:	c3                   	ret    
  401b43:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  401b4a:	00 00 00 00 
  401b4e:	66 90                	xchg   ax,ax

0000000000401b50 <ss_thd_intern_is_allocated>:
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  401b50:	f3 0f 1e fa          	endbr64 
  401b54:	48 8d 87 40 06 00 00 	lea    rax,[rdi+0x640]
  401b5b:	48 39 c6             	cmp    rsi,rax
  401b5e:	72 32                	jb     401b92 <ss_thd_intern_is_allocated+0x42>
  401b60:	48 8d 97 10 8f 00 00 	lea    rdx,[rdi+0x8f10]
  401b67:	48 39 d6             	cmp    rsi,rdx
  401b6a:	77 26                	ja     401b92 <ss_thd_intern_is_allocated+0x42>
  401b6c:	48 29 c6             	sub    rsi,rax
  401b6f:	48 c1 fe 04          	sar    rsi,0x4
  401b73:	69 c6 a3 8b 2e ba    	imul   eax,esi,0xba2e8ba3
  401b79:	48 8b 04 c7          	mov    rax,QWORD PTR [rdi+rax*8]
  401b7d:	48 89 c2             	mov    rdx,rax
  401b80:	83 e2 01             	and    edx,0x1
  401b83:	48 a9 fe ff ff ff    	test   rax,0xfffffffffffffffe
  401b89:	b8 01 00 00 00       	mov    eax,0x1
  401b8e:	0f 45 c2             	cmovne eax,edx
  401b91:	c3                   	ret    
  401b92:	55                   	push   rbp
  401b93:	be 23 00 00 00       	mov    esi,0x23
  401b98:	bf a8 d4 41 00       	mov    edi,0x41d4a8
  401b9d:	48 89 e5             	mov    rbp,rsp
  401ba0:	e8 db 90 00 00       	call   40ac80 <cos_print_str>
  401ba5:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401bac:	00 00 00 00 
  401bb0:	0f 0b                	ud2    
  401bb2:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  401bb9:	00 00 00 00 
  401bbd:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000401bc0 <ss_thd_is_allocated>:
  401bc0:	f3 0f 1e fa          	endbr64 
  401bc4:	48 81 ff 30 86 5c 00 	cmp    rdi,0x5c8630
  401bcb:	77 37                	ja     401c04 <ss_thd_is_allocated+0x44>
  401bcd:	48 81 ff 60 fd 5b 00 	cmp    rdi,0x5bfd60
  401bd4:	72 2e                	jb     401c04 <ss_thd_is_allocated+0x44>
  401bd6:	48 81 ef 60 fd 5b 00 	sub    rdi,0x5bfd60
  401bdd:	48 c1 ff 04          	sar    rdi,0x4
  401be1:	69 c7 a3 8b 2e ba    	imul   eax,edi,0xba2e8ba3
  401be7:	48 8b 04 c5 20 f7 5b 	mov    rax,QWORD PTR [rax*8+0x5bf720]
  401bee:	00 
  401bef:	48 89 c2             	mov    rdx,rax
  401bf2:	83 e2 01             	and    edx,0x1
  401bf5:	48 a9 fe ff ff ff    	test   rax,0xfffffffffffffffe
  401bfb:	b8 01 00 00 00       	mov    eax,0x1
  401c00:	0f 45 c2             	cmovne eax,edx
  401c03:	c3                   	ret    
  401c04:	55                   	push   rbp
  401c05:	be 23 00 00 00       	mov    esi,0x23
  401c0a:	bf a8 d4 41 00       	mov    edi,0x41d4a8
  401c0f:	48 89 e5             	mov    rbp,rsp
  401c12:	e8 69 90 00 00       	call   40ac80 <cos_print_str>
  401c17:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401c1e:	00 00 00 00 
  401c22:	0f 0b                	ud2    
  401c24:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  401c2b:	00 00 00 00 
  401c2f:	90                   	nop

0000000000401c30 <slm_thd_static_cm_lookup>:
  401c30:	f3 0f 1e fa          	endbr64 
  401c34:	85 ff                	test   edi,edi
  401c36:	74 38                	je     401c70 <slm_thd_static_cm_lookup+0x40>
  401c38:	83 ef 01             	sub    edi,0x1
  401c3b:	81 ff c7 00 00 00    	cmp    edi,0xc7
  401c41:	77 2d                	ja     401c70 <slm_thd_static_cm_lookup+0x40>
  401c43:	48 8b 14 fd 20 f7 5b 	mov    rdx,QWORD PTR [rdi*8+0x5bf720]
  401c4a:	00 
  401c4b:	31 c0                	xor    eax,eax
  401c4d:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  401c54:	74 1c                	je     401c72 <slm_thd_static_cm_lookup+0x42>
  401c56:	83 e2 01             	and    edx,0x1
  401c59:	75 17                	jne    401c72 <slm_thd_static_cm_lookup+0x42>
  401c5b:	48 8d 04 bf          	lea    rax,[rdi+rdi*4]
  401c5f:	48 8d 04 47          	lea    rax,[rdi+rax*2]
  401c63:	48 c1 e0 04          	shl    rax,0x4
  401c67:	48 05 60 fd 5b 00    	add    rax,0x5bfd60
  401c6d:	c3                   	ret    
  401c6e:	66 90                	xchg   ax,ax
  401c70:	31 c0                	xor    eax,eax
  401c72:	c3                   	ret    
  401c73:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  401c7a:	00 00 00 00 
  401c7e:	66 90                	xchg   ax,ax

0000000000401c80 <slm_thd_current_extern>:
{
  401c80:	f3 0f 1e fa          	endbr64 
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  401c84:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  401c87:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  401c8d:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  401c94:	48 85 c0             	test   rax,rax
  401c97:	74 3f                	je     401cd8 <slm_thd_current_extern+0x58>
  401c99:	83 e8 01             	sub    eax,0x1
  401c9c:	3d c7 00 00 00       	cmp    eax,0xc7
  401ca1:	77 35                	ja     401cd8 <slm_thd_current_extern+0x58>
  401ca3:	48 8b 14 c5 20 f7 5b 	mov    rdx,QWORD PTR [rax*8+0x5bf720]
  401caa:	00 
  401cab:	45 31 c0             	xor    r8d,r8d
  401cae:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  401cb5:	74 18                	je     401ccf <slm_thd_current_extern+0x4f>
  401cb7:	83 e2 01             	and    edx,0x1
  401cba:	75 13                	jne    401ccf <slm_thd_current_extern+0x4f>
  401cbc:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  401cc0:	4c 8d 04 50          	lea    r8,[rax+rdx*2]
  401cc4:	49 c1 e0 04          	shl    r8,0x4
  401cc8:	49 81 c0 60 fd 5b 00 	add    r8,0x5bfd60
}
  401ccf:	4c 89 c0             	mov    rax,r8
  401cd2:	c3                   	ret    
  401cd3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  401cd8:	45 31 c0             	xor    r8d,r8d
}
  401cdb:	4c 89 c0             	mov    rax,r8
  401cde:	c3                   	ret    
  401cdf:	90                   	nop

0000000000401ce0 <slm_thd_from_container>:
slm_thd_from_container(struct slm_thd_container *c) {
  401ce0:	f3 0f 1e fa          	endbr64 
  401ce4:	48 89 f8             	mov    rax,rdi
}
  401ce7:	c3                   	ret    
  401ce8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  401cef:	00 

0000000000401cf0 <slm_thd_mem_alloc>:
{
  401cf0:	f3 0f 1e fa          	endbr64 
  401cf4:	55                   	push   rbp
  401cf5:	66 48 0f 6e c7       	movq   xmm0,rdi
  401cfa:	66 48 0f 6e ce       	movq   xmm1,rsi
  401cff:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  401d03:	48 89 e5             	mov    rbp,rsp
  401d06:	53                   	push   rbx
  401d07:	48 83 ec 08          	sub    rsp,0x8
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  401d0b:	85 f6                	test   esi,esi
  401d0d:	0f 84 8d 00 00 00    	je     401da0 <slm_thd_mem_alloc+0xb0>
  401d13:	49 89 d2             	mov    r10,rdx
  401d16:	8d 56 ff             	lea    edx,[rsi-0x1]
  401d19:	81 fa c7 00 00 00    	cmp    edx,0xc7
  401d1f:	77 7f                	ja     401da0 <slm_thd_mem_alloc+0xb0>
	if (*state != SS_STATE_FREE ||
  401d21:	48 83 3c d5 20 f7 5b 	cmp    QWORD PTR [rdx*8+0x5bf720],0x0
  401d28:	00 00 
  401d2a:	75 74                	jne    401da0 <slm_thd_mem_alloc+0xb0>
  401d2c:	31 db                	xor    ebx,ebx
  401d2e:	49 89 c9             	mov    r9,rcx
  401d31:	b9 01 00 00 00       	mov    ecx,0x1
  401d36:	48 89 d8             	mov    rax,rbx
  401d39:	f0 48 0f b1 0c d5 20 	lock cmpxchg QWORD PTR [rdx*8+0x5bf720],rcx
  401d40:	f7 5b 00 
  401d43:	0f 94 c0             	sete   al
  401d46:	84 c0                	test   al,al
  401d48:	74 56                	je     401da0 <slm_thd_mem_alloc+0xb0>
  401d4a:	48 8d 04 92          	lea    rax,[rdx+rdx*4]
  401d4e:	49 89 f8             	mov    r8,rdi
  401d51:	b9 16 00 00 00       	mov    ecx,0x16
  401d56:	48 8d 14 42          	lea    rdx,[rdx+rax*2]
  401d5a:	48 89 d8             	mov    rax,rbx
  401d5d:	48 c1 e2 04          	shl    rdx,0x4
  401d61:	4c 8d 9a 60 fd 5b 00 	lea    r11,[rdx+0x5bfd60]
  401d68:	4c 89 df             	mov    rdi,r11
  401d6b:	f3 48 ab             	rep stos QWORD PTR es:[rdi],rax
	assert(_cap != 0 && _tid != 0);
  401d6e:	4d 85 c0             	test   r8,r8
  401d71:	74 49                	je     401dbc <slm_thd_mem_alloc+0xcc>
	t->resources = (struct slm_resources_thd) {
  401d73:	48 8b 05 c6 72 02 00 	mov    rax,QWORD PTR [rip+0x272c6]        # 429040 <__cosrt_comp_info+0x40>
  401d7a:	0f 11 82 f8 fd 5b 00 	movups XMMWORD PTR [rdx+0x5bfdf8],xmm0
}
  401d81:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
	t->resources = (struct slm_resources_thd) {
  401d85:	48 89 82 08 fe 5b 00 	mov    QWORD PTR [rdx+0x5bfe08],rax
}
  401d8c:	4c 89 d8             	mov    rax,r11
	*thd = _cap;
  401d8f:	4d 89 02             	mov    QWORD PTR [r10],r8
	*tid = _tid;
  401d92:	49 89 31             	mov    QWORD PTR [r9],rsi
}
  401d95:	c9                   	leave  
  401d96:	c3                   	ret    
  401d97:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  401d9e:	00 00 
  401da0:	be 23 00 00 00       	mov    esi,0x23
  401da5:	bf d0 d4 41 00       	mov    edi,0x41d4d0
  401daa:	e8 d1 8e 00 00       	call   40ac80 <cos_print_str>
	if (!t) assert(0);
  401daf:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401db6:	00 00 00 00 
  401dba:	0f 0b                	ud2    
  401dbc:	be 23 00 00 00       	mov    esi,0x23
  401dc1:	bf f8 d4 41 00       	mov    edi,0x41d4f8
  401dc6:	e8 b5 8e 00 00       	call   40ac80 <cos_print_str>
	assert(_cap != 0 && _tid != 0);
  401dcb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401dd2:	00 00 00 00 
  401dd6:	0f 0b                	ud2    
  401dd8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  401ddf:	00 

0000000000401de0 <slm_thd_mem_activate>:
void slm_thd_mem_activate(struct slm_thd_container *t) { ss_thd_activate(t); }
  401de0:	f3 0f 1e fa          	endbr64 
  401de4:	55                   	push   rbp
  401de5:	48 89 e5             	mov    rbp,rsp
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  401de8:	48 81 ff 60 fd 5b 00 	cmp    rdi,0x5bfd60
  401def:	72 50                	jb     401e41 <slm_thd_mem_activate+0x61>
  401df1:	48 81 ff 30 86 5c 00 	cmp    rdi,0x5c8630
  401df8:	77 47                	ja     401e41 <slm_thd_mem_activate+0x61>
  401dfa:	48 81 ef 60 fd 5b 00 	sub    rdi,0x5bfd60
  401e01:	48 c1 ff 04          	sar    rdi,0x4
 */
static inline void
ss_state_activate_with(ss_state_t *state, word_t val)
{
	assert(val != 0);
	*state = val | (*state & 1);
  401e05:	69 c7 a3 8b 2e ba    	imul   eax,edi,0xba2e8ba3
  401e0b:	48 8b 14 c5 20 f7 5b 	mov    rdx,QWORD PTR [rax*8+0x5bf720]
  401e12:	00 
  401e13:	48 83 ca fe          	or     rdx,0xfffffffffffffffe
  401e17:	48 89 14 c5 20 f7 5b 	mov    QWORD PTR [rax*8+0x5bf720],rdx
  401e1e:	00 
	assert((*state & 1) == SS_STATE_CONS);
  401e1f:	48 83 fa ff          	cmp    rdx,0xffffffffffffffff
  401e23:	75 38                	jne    401e5d <slm_thd_mem_activate+0x7d>
	*state &= ~SS_STATE_CONS;
  401e25:	48 c7 04 c5 20 f7 5b 	mov    QWORD PTR [rax*8+0x5bf720],0xfffffffffffffffe
  401e2c:	00 fe ff ff ff 
{ __asm__ __volatile__("mfence" ::: "memory"); }
  401e31:	0f ae f0             	mfence 
	assert(*state != 0);
  401e34:	48 83 3c c5 20 f7 5b 	cmp    QWORD PTR [rax*8+0x5bf720],0x0
  401e3b:	00 00 
  401e3d:	74 3a                	je     401e79 <slm_thd_mem_activate+0x99>
void slm_thd_mem_activate(struct slm_thd_container *t) { ss_thd_activate(t); }
  401e3f:	5d                   	pop    rbp
  401e40:	c3                   	ret    
  401e41:	be 23 00 00 00       	mov    esi,0x23
  401e46:	bf a8 d4 41 00       	mov    edi,0x41d4a8
  401e4b:	e8 30 8e 00 00       	call   40ac80 <cos_print_str>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  401e50:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401e57:	00 00 00 00 
  401e5b:	0f 0b                	ud2    
  401e5d:	be 61 00 00 00       	mov    esi,0x61
  401e62:	bf 20 d5 41 00       	mov    edi,0x41d520
  401e67:	e8 14 8e 00 00       	call   40ac80 <cos_print_str>
	assert((*state & 1) == SS_STATE_CONS);
  401e6c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401e73:	00 00 00 00 
  401e77:	0f 0b                	ud2    
  401e79:	be 61 00 00 00       	mov    esi,0x61
  401e7e:	bf 88 d5 41 00       	mov    edi,0x41d588
  401e83:	e8 f8 8d 00 00       	call   40ac80 <cos_print_str>
	assert(*state != 0);
  401e88:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  401e8f:	00 00 00 00 
  401e93:	0f 0b                	ud2    
  401e95:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  401e9c:	00 00 00 00 

0000000000401ea0 <slm_thd_mem_free>:
void slm_thd_mem_free(struct slm_thd_container *t) { return; }
  401ea0:	f3 0f 1e fa          	endbr64 
  401ea4:	c3                   	ret    
  401ea5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  401eac:	00 00 00 00 

0000000000401eb0 <sched_thd_create_closure>:
{
  401eb0:	f3 0f 1e fa          	endbr64 
  401eb4:	55                   	push   rbp
  401eb5:	89 fe                	mov    esi,edi
	struct slm_thd *t = thd_alloc_in(cos_inv_token(), idx, &p, 0);
  401eb7:	31 c9                	xor    ecx,ecx
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  401eb9:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  401ebc:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
{
  401ec2:	48 89 e5             	mov    rbp,rsp
  401ec5:	48 83 ec 10          	sub    rsp,0x10
	struct slm_thd *t = thd_alloc_in(cos_inv_token(), idx, &p, 0);
  401ec9:	48 8b b8 e8 1f 00 00 	mov    rdi,QWORD PTR [rax+0x1fe8]
  401ed0:	48 8d 55 fc          	lea    rdx,[rbp-0x4]
	sched_param_t p = 0;
  401ed4:	c7 45 fc 00 00 00 00 	mov    DWORD PTR [rbp-0x4],0x0
	struct slm_thd *t = thd_alloc_in(cos_inv_token(), idx, &p, 0);
  401edb:	e8 70 39 00 00       	call   405850 <thd_alloc_in>
	if (!t) return 0;
  401ee0:	48 85 c0             	test   rax,rax
  401ee3:	74 0b                	je     401ef0 <sched_thd_create_closure+0x40>
	return t->tid;
  401ee5:	48 8b 40 18          	mov    rax,QWORD PTR [rax+0x18]
}
  401ee9:	c9                   	leave  
  401eea:	c3                   	ret    
  401eeb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  401ef0:	c9                   	leave  
	if (!t) return 0;
  401ef1:	31 c0                	xor    eax,eax
}
  401ef3:	c3                   	ret    
  401ef4:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  401efb:	00 00 00 00 
  401eff:	90                   	nop

0000000000401f00 <sched_thd_param_set>:
{
  401f00:	f3 0f 1e fa          	endbr64 

static inline void
sched_param_get(sched_param_t sp, sched_param_type_t *type, unsigned int *value)
{
	if (type)  *type  = (sched_param_type_t)(sp &  SCHED_PARAM_TYPE_MASK);
	if (value) *value = (unsigned int)      (sp >> SCHED_PARAM_TYPE_BITS);
  401f04:	89 f2                	mov    edx,esi
	if (type)  *type  = (sched_param_type_t)(sp &  SCHED_PARAM_TYPE_MASK);
  401f06:	83 e6 3f             	and    esi,0x3f
	if (value) *value = (unsigned int)      (sp >> SCHED_PARAM_TYPE_BITS);
  401f09:	c1 ea 06             	shr    edx,0x6
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  401f0c:	85 ff                	test   edi,edi
  401f0e:	74 40                	je     401f50 <sched_thd_param_set+0x50>
  401f10:	83 ef 01             	sub    edi,0x1
  401f13:	81 ff c7 00 00 00    	cmp    edi,0xc7
  401f19:	77 35                	ja     401f50 <sched_thd_param_set+0x50>
  401f1b:	48 8b 04 fd 20 f7 5b 	mov    rax,QWORD PTR [rdi*8+0x5bf720]
  401f22:	00 
	return ((state & ~1) != 0) && ((state & 1) == SS_STATE_ALLOC);
  401f23:	48 a9 fe ff ff ff    	test   rax,0xfffffffffffffffe
  401f29:	74 25                	je     401f50 <sched_thd_param_set+0x50>
  401f2b:	a8 01                	test   al,0x1
  401f2d:	75 21                	jne    401f50 <sched_thd_param_set+0x50>
	return &ss_thd_get(id)->thd;
  401f2f:	48 8d 04 bf          	lea    rax,[rdi+rdi*4]
  401f33:	48 8d 3c 47          	lea    rdi,[rdi+rax*2]
  401f37:	48 c1 e7 04          	shl    rdi,0x4
  401f3b:	48 81 c7 60 fd 5b 00 	add    rdi,0x5bfd60
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  401f42:	e9 59 1e 01 00       	jmp    413da0 <slm_sched_fprr_thd_update>
  401f47:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  401f4e:	00 00 
}
  401f50:	b8 ff ff ff ff       	mov    eax,0xffffffff
  401f55:	c3                   	ret    
  401f56:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  401f5d:	00 00 00 

0000000000401f60 <sched_thd_delete>:
{
  401f60:	f3 0f 1e fa          	endbr64 
}
  401f64:	31 c0                	xor    eax,eax
  401f66:	c3                   	ret    
  401f67:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  401f6e:	00 00 

0000000000401f70 <sched_thd_exit>:
{
  401f70:	f3 0f 1e fa          	endbr64 
  401f74:	55                   	push   rbp
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  401f75:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  401f78:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  401f7e:	48 89 e5             	mov    rbp,rsp
  401f81:	41 57                	push   r15
  401f83:	41 56                	push   r14
  401f85:	41 55                	push   r13
  401f87:	41 54                	push   r12
  401f89:	53                   	push   rbx
  401f8a:	48 83 ec 18          	sub    rsp,0x18
  401f8e:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  401f95:	48 85 c0             	test   rax,rax
  401f98:	0f 84 bf 02 00 00    	je     40225d <sched_thd_exit+0x2ed>
  401f9e:	83 e8 01             	sub    eax,0x1
  401fa1:	3d c7 00 00 00       	cmp    eax,0xc7
  401fa6:	0f 87 b1 02 00 00    	ja     40225d <sched_thd_exit+0x2ed>
  401fac:	48 8b 14 c5 20 f7 5b 	mov    rdx,QWORD PTR [rax*8+0x5bf720]
  401fb3:	00 
  401fb4:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  401fbb:	0f 84 9c 02 00 00    	je     40225d <sched_thd_exit+0x2ed>
  401fc1:	80 e2 01             	and    dl,0x1
  401fc4:	0f 85 93 02 00 00    	jne    40225d <sched_thd_exit+0x2ed>
  401fca:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  401fce:	4c 8d 3c 50          	lea    r15,[rax+rdx*2]
  401fd2:	49 c1 e7 04          	shl    r15,0x4
  401fd6:	49 8d 87 60 fd 5b 00 	lea    rax,[r15+0x5bfd60]
  401fdd:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  401fe1:	0f 01 f9             	rdtscp 
	cs = &(slm_global()->lock);
  401fe4:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  401fea:	48 8d 1c 89          	lea    rbx,[rcx+rcx*4]
  401fee:	48 c1 e3 06          	shl    rbx,0x6
  401ff2:	48 81 c3 00 65 71 00 	add    rbx,0x716500
		tok    = cos_sched_sync();
  401ff9:	e8 12 fb 00 00       	call   411b10 <cos_sched_sync>
  401ffe:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  402001:	48 8b 03             	mov    rax,QWORD PTR [rbx]
		if (unlikely(owner)) {
  402004:	48 89 c1             	mov    rcx,rax
  402007:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  40200b:	0f 85 8d 02 00 00    	jne    40229e <sched_thd_exit+0x32e>
        __asm__ __volatile__("lock " PS_CAS_STR
  402011:	48 8b 7d c8          	mov    rdi,QWORD PTR [rbp-0x38]
  402015:	f0 48 0f b1 3b       	lock cmpxchg QWORD PTR [rbx],rdi
  40201a:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  40201d:	84 c0                	test   al,al
  40201f:	74 d8                	je     401ff9 <sched_thd_exit+0x89>
	slm_thd_deinit(current);
  402021:	e8 ea 2f 01 00       	call   415010 <slm_thd_deinit>
	for (i = 0; slm_cs_exit_reschedule(current, SLM_CS_NONE) && i < 16; i++) ;
  402026:	41 be 11 00 00 00    	mov    r14d,0x11
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  40202c:	e8 1f 95 00 00       	call   40b550 <cos_defcompinfo_curr_get>
  402031:	0f 01 f9             	rdtscp 
	if (unlikely(!t)) t = &g->idle_thd;
  402034:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  40203a:	4c 8d 24 89          	lea    r12,[rcx+rcx*4]
  40203e:	49 c1 e4 06          	shl    r12,0x6
  402042:	49 81 c4 80 65 71 00 	add    r12,0x716580
	tok  = cos_sched_sync();
  402049:	e8 c2 fa 00 00       	call   411b10 <cos_sched_sync>
  40204e:	41 89 c5             	mov    r13d,eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  402051:	e8 4a 1b 01 00       	call   413ba0 <slm_sched_fprr_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  402056:	48 85 c0             	test   rax,rax
  402059:	48 89 c3             	mov    rbx,rax
  40205c:	49 0f 44 dc          	cmove  rbx,r12
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  402060:	8b 43 04             	mov    eax,DWORD PTR [rbx+0x4]
  402063:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  402066:	83 f8 01             	cmp    eax,0x1
  402069:	0f 87 c2 00 00 00    	ja     402131 <sched_thd_exit+0x1c1>
  40206f:	0f 01 f9             	rdtscp 
	struct slm_cs *cs = &(slm_global()->lock);
  402072:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  402078:	48 8d 3c 89          	lea    rdi,[rcx+rcx*4]
  40207c:	48 c1 e7 06          	shl    rdi,0x6
  402080:	4c 8d bf 00 65 71 00 	lea    r15,[rdi+0x716500]
	while (ret != 0) {
  402087:	eb 13                	jmp    40209c <sched_thd_exit+0x12c>
  402089:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  402090:	f0 49 0f b1 17       	lock cmpxchg QWORD PTR [r15],rdx
  402095:	0f 94 c0             	sete   al
  402098:	84 c0                	test   al,al
  40209a:	75 28                	jne    4020c4 <sched_thd_exit+0x154>
		tok    = cos_sched_sync();
  40209c:	e8 6f fa 00 00       	call   411b10 <cos_sched_sync>
  4020a1:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4020a3:	49 8b 07             	mov    rax,QWORD PTR [r15]
		if (unlikely(contention)) {
  4020a6:	48 89 c2             	mov    rdx,rax
  4020a9:	83 e2 01             	and    edx,0x1
  4020ac:	74 e2                	je     402090 <sched_thd_exit+0x120>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  4020ae:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  4020b1:	48 89 c2             	mov    rdx,rax
  4020b4:	4c 89 ff             	mov    rdi,r15
  4020b7:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  4020bb:	e8 e0 2f 01 00       	call   4150a0 <slm_cs_exit_contention>
  4020c0:	85 c0                	test   eax,eax
  4020c2:	75 d8                	jne    40209c <sched_thd_exit+0x12c>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  4020c4:	e8 87 94 00 00       	call   40b550 <cos_defcompinfo_curr_get>
  4020c9:	0f 01 f9             	rdtscp 
	*coreid = c & 0xFFF;
  4020cc:	89 ca                	mov    edx,ecx
	timeout = g->timeout_next;
  4020ce:	81 e1 ff 0f 00 00    	and    ecx,0xfff
	prio = inherit_prio ? curr->priority : t->priority;
  4020d4:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
	timeout = g->timeout_next;
  4020d8:	48 8d 04 89          	lea    rax,[rcx+rcx*4]
  4020dc:	66 81 e2 ff 0f       	and    dx,0xfff
  4020e1:	49 89 cf             	mov    r15,rcx
  4020e4:	48 c1 e0 06          	shl    rax,0x6
  4020e8:	4c 8b 88 08 66 71 00 	mov    r9,QWORD PTR [rax+0x716608]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4020ef:	8b 03                	mov    eax,DWORD PTR [rbx]
  4020f1:	a8 0b                	test   al,0xb
  4020f3:	75 58                	jne    40214d <sched_thd_exit+0x1dd>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  4020f5:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  4020f9:	44 89 e9             	mov    ecx,r13d
  4020fc:	4c 89 ca             	mov    rdx,r9
  4020ff:	e8 9c a5 00 00       	call   40c6a0 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  402104:	83 f8 ff             	cmp    eax,0xffffffff
  402107:	0f 84 05 01 00 00    	je     402212 <sched_thd_exit+0x2a2>
	if (unlikely(ret != 0)) {
  40210d:	85 c0                	test   eax,eax
  40210f:	0f 85 9d 00 00 00    	jne    4021b2 <sched_thd_exit+0x242>
  402115:	be 11 00 00 00       	mov    esi,0x11
  40211a:	bf ea d5 41 00       	mov    edi,0x41d5ea
  40211f:	e8 5c 8b 00 00       	call   40ac80 <cos_print_str>
	BUG();
  402124:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40212b:	00 00 00 00 
  40212f:	0f 0b                	ud2    
  402131:	be 61 00 00 00       	mov    esi,0x61
  402136:	bf e8 d1 41 00       	mov    edi,0x41d1e8
  40213b:	e8 40 8b 00 00       	call   40ac80 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  402140:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402147:	00 00 00 00 
  40214b:	0f 0b                	ud2    
		if (t == &g->sched_thd) {
  40214d:	0f b7 d2             	movzx  edx,dx
	timeout = g->timeout_next;
  402150:	4c 89 c9             	mov    rcx,r9
		if (t == &g->sched_thd) {
  402153:	48 69 d2 40 01 00 00 	imul   rdx,rdx,0x140
  40215a:	48 81 c2 08 65 71 00 	add    rdx,0x716508
  402161:	48 39 d3             	cmp    rbx,rdx
  402164:	0f 84 25 01 00 00    	je     40228f <sched_thd_exit+0x31f>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  40216a:	a8 02                	test   al,0x2
  40216c:	0f 85 67 01 00 00    	jne    4022d9 <sched_thd_exit+0x369>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  402172:	49 89 c9             	mov    r9,rcx
  402175:	a8 01                	test   al,0x1
  402177:	0f 84 78 ff ff ff    	je     4020f5 <sched_thd_exit+0x185>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  40217d:	4c 8b 53 08          	mov    r10,QWORD PTR [rbx+0x8]
  402181:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  402185:	48 89 f2             	mov    rdx,rsi
  402188:	45 89 e9             	mov    r9d,r13d
  40218b:	4d 69 c7 40 01 00 00 	imul   r8,r15,0x140
  402192:	4c 89 d6             	mov    rsi,r10
  402195:	4d 8b 80 28 65 71 00 	mov    r8,QWORD PTR [r8+0x716528]
  40219c:	e8 8f f9 00 00       	call   411b30 <cos_switch>
	if (unlikely(ret != 0)) {
  4021a1:	85 c0                	test   eax,eax
  4021a3:	0f 84 6c ff ff ff    	je     402115 <sched_thd_exit+0x1a5>
		assert(ret != -EPERM);
  4021a9:	83 f8 ff             	cmp    eax,0xffffffff
  4021ac:	0f 84 8f 00 00 00    	je     402241 <sched_thd_exit+0x2d1>
		assert(ret != -EINVAL);
  4021b2:	83 f8 ea             	cmp    eax,0xffffffea
  4021b5:	0f 84 6e 01 00 00    	je     402329 <sched_thd_exit+0x3b9>
		if (ret == -EBUSY) return ret;
  4021bb:	83 f8 f0             	cmp    eax,0xfffffff0
  4021be:	0f 84 bc 00 00 00    	je     402280 <sched_thd_exit+0x310>
		assert(ret == -EAGAIN);
  4021c4:	83 f8 f5             	cmp    eax,0xfffffff5
  4021c7:	0f 85 9c 01 00 00    	jne    402369 <sched_thd_exit+0x3f9>
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  4021cd:	0f 01 f9             	rdtscp 
	cs = &(slm_global()->lock);
  4021d0:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  4021d6:	48 69 d9 40 01 00 00 	imul   rbx,rcx,0x140
  4021dd:	48 81 c3 00 65 71 00 	add    rbx,0x716500
		tok    = cos_sched_sync();
  4021e4:	e8 27 f9 00 00       	call   411b10 <cos_sched_sync>
  4021e9:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4021ec:	48 8b 03             	mov    rax,QWORD PTR [rbx]
		if (unlikely(owner)) {
  4021ef:	48 89 c1             	mov    rcx,rax
  4021f2:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  4021f6:	0f 85 49 01 00 00    	jne    402345 <sched_thd_exit+0x3d5>
  4021fc:	48 8b 75 c8          	mov    rsi,QWORD PTR [rbp-0x38]
  402200:	f0 48 0f b1 33       	lock cmpxchg QWORD PTR [rbx],rsi
  402205:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  402208:	84 c0                	test   al,al
  40220a:	0f 85 39 fe ff ff    	jne    402049 <sched_thd_exit+0xd9>
  402210:	eb d2                	jmp    4021e4 <sched_thd_exit+0x274>
  402212:	0f 01 f9             	rdtscp 
	return t != &g->idle_thd && t != &g->sched_thd;
  402215:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  40221b:	48 69 c1 40 01 00 00 	imul   rax,rcx,0x140
  402222:	48 8d 90 80 65 71 00 	lea    rdx,[rax+0x716580]
  402229:	48 39 d3             	cmp    rbx,rdx
  40222c:	0f 84 c9 00 00 00    	je     4022fb <sched_thd_exit+0x38b>
  402232:	48 05 08 65 71 00    	add    rax,0x716508
  402238:	48 39 c3             	cmp    rbx,rax
  40223b:	0f 84 ba 00 00 00    	je     4022fb <sched_thd_exit+0x38b>
  402241:	be 61 00 00 00       	mov    esi,0x61
  402246:	bf 50 d2 41 00       	mov    edi,0x41d250
  40224b:	e8 30 8a 00 00       	call   40ac80 <cos_print_str>
		assert(ret != -EPERM);
  402250:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402257:	00 00 00 00 
  40225b:	0f 0b                	ud2    
  40225d:	be 59 00 00 00       	mov    esi,0x59
  402262:	bf 00 d1 41 00       	mov    edi,0x41d100
  402267:	e8 14 8a 00 00       	call   40ac80 <cos_print_str>
	assert(current);
  40226c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402273:	00 00 00 00 
  402277:	0f 0b                	ud2    
  402279:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (i = 0; slm_cs_exit_reschedule(current, SLM_CS_NONE) && i < 16; i++) ;
  402280:	41 83 ee 01          	sub    r14d,0x1
  402284:	0f 85 a2 fd ff ff    	jne    40202c <sched_thd_exit+0xbc>
  40228a:	e9 86 fe ff ff       	jmp    402115 <sched_thd_exit+0x1a5>
			prio    = curr->priority;
  40228f:	48 8b 75 c8          	mov    rsi,QWORD PTR [rbp-0x38]
			timeout = TCAP_TIME_NIL;
  402293:	31 c9                	xor    ecx,ecx
			prio    = curr->priority;
  402295:	48 8b 76 30          	mov    rsi,QWORD PTR [rsi+0x30]
  402299:	e9 cc fe ff ff       	jmp    40216a <sched_thd_exit+0x1fa>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  40229e:	41 89 c0             	mov    r8d,eax
  4022a1:	48 8b 55 c8          	mov    rdx,QWORD PTR [rbp-0x38]
  4022a5:	48 89 c6             	mov    rsi,rax
  4022a8:	48 89 df             	mov    rdi,rbx
  4022ab:	41 83 e0 01          	and    r8d,0x1
  4022af:	e8 8c 2d 01 00       	call   415040 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  4022b4:	83 f8 f0             	cmp    eax,0xfffffff0
  4022b7:	0f 85 3c fd ff ff    	jne    401ff9 <sched_thd_exit+0x89>
  4022bd:	be 59 00 00 00       	mov    esi,0x59
  4022c2:	bf 60 d1 41 00       	mov    edi,0x41d160
  4022c7:	e8 b4 89 00 00       	call   40ac80 <cos_print_str>
  4022cc:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4022d3:	00 00 00 00 
  4022d7:	0f 0b                	ud2    
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  4022d9:	4d 69 c7 40 01 00 00 	imul   r8,r15,0x140
  4022e0:	48 8b 7b 28          	mov    rdi,QWORD PTR [rbx+0x28]
  4022e4:	44 89 e9             	mov    ecx,r13d
  4022e7:	4c 89 ce             	mov    rsi,r9
  4022ea:	49 8b 90 28 65 71 00 	mov    rdx,QWORD PTR [r8+0x716528]
  4022f1:	e8 aa f8 00 00       	call   411ba0 <cos_sched_asnd>
  4022f6:	e9 a6 fe ff ff       	jmp    4021a1 <sched_thd_exit+0x231>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  4022fb:	49 69 c7 40 01 00 00 	imul   rax,r15,0x140
  402302:	48 8b 75 c8          	mov    rsi,QWORD PTR [rbp-0x38]
  402306:	45 89 e9             	mov    r9d,r13d
  402309:	31 c9                	xor    ecx,ecx
  40230b:	48 8b 56 30          	mov    rdx,QWORD PTR [rsi+0x30]
  40230f:	31 f6                	xor    esi,esi
  402311:	4c 8b 80 28 65 71 00 	mov    r8,QWORD PTR [rax+0x716528]
  402318:	48 8b b8 18 65 71 00 	mov    rdi,QWORD PTR [rax+0x716518]
  40231f:	e8 0c f8 00 00       	call   411b30 <cos_switch>
  402324:	e9 78 fe ff ff       	jmp    4021a1 <sched_thd_exit+0x231>
  402329:	be 61 00 00 00       	mov    esi,0x61
  40232e:	bf b8 d2 41 00       	mov    edi,0x41d2b8
  402333:	e8 48 89 00 00       	call   40ac80 <cos_print_str>
		assert(ret != -EINVAL);
  402338:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40233f:	00 00 00 00 
  402343:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  402345:	41 89 c0             	mov    r8d,eax
  402348:	48 8b 55 c8          	mov    rdx,QWORD PTR [rbp-0x38]
  40234c:	48 89 c6             	mov    rsi,rax
  40234f:	48 89 df             	mov    rdi,rbx
  402352:	41 83 e0 01          	and    r8d,0x1
  402356:	e8 e5 2c 01 00       	call   415040 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  40235b:	83 f8 f0             	cmp    eax,0xfffffff0
  40235e:	0f 85 80 fe ff ff    	jne    4021e4 <sched_thd_exit+0x274>
  402364:	e9 54 ff ff ff       	jmp    4022bd <sched_thd_exit+0x34d>
  402369:	be 61 00 00 00       	mov    esi,0x61
  40236e:	bf 20 d3 41 00       	mov    edi,0x41d320
  402373:	e8 08 89 00 00       	call   40ac80 <cos_print_str>
		assert(ret == -EAGAIN);
  402378:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40237f:	00 00 00 00 
  402383:	0f 0b                	ud2    
  402385:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40238c:	00 00 00 00 

0000000000402390 <sched_thd_yield_to>:
{
  402390:	f3 0f 1e fa          	endbr64 
  402394:	55                   	push   rbp
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  402395:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  402398:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  40239e:	48 89 e5             	mov    rbp,rsp
  4023a1:	41 57                	push   r15
  4023a3:	41 56                	push   r14
  4023a5:	41 55                	push   r13
  4023a7:	41 54                	push   r12
  4023a9:	53                   	push   rbx
  4023aa:	48 83 ec 08          	sub    rsp,0x8
  4023ae:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  4023b5:	48 85 c0             	test   rax,rax
  4023b8:	0f 84 0a 02 00 00    	je     4025c8 <sched_thd_yield_to+0x238>
  4023be:	83 e8 01             	sub    eax,0x1
  4023c1:	3d c7 00 00 00       	cmp    eax,0xc7
  4023c6:	0f 87 fc 01 00 00    	ja     4025c8 <sched_thd_yield_to+0x238>
  4023cc:	48 8b 14 c5 20 f7 5b 	mov    rdx,QWORD PTR [rax*8+0x5bf720]
  4023d3:	00 
  4023d4:	45 31 e4             	xor    r12d,r12d
  4023d7:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  4023de:	0f 85 9c 01 00 00    	jne    402580 <sched_thd_yield_to+0x1f0>
  4023e4:	85 ff                	test   edi,edi
  4023e6:	0f 84 bc 01 00 00    	je     4025a8 <sched_thd_yield_to+0x218>
  4023ec:	83 ef 01             	sub    edi,0x1
  4023ef:	81 ff c7 00 00 00    	cmp    edi,0xc7
  4023f5:	0f 87 ad 01 00 00    	ja     4025a8 <sched_thd_yield_to+0x218>
  4023fb:	89 f8                	mov    eax,edi
  4023fd:	48 8b 14 c5 20 f7 5b 	mov    rdx,QWORD PTR [rax*8+0x5bf720]
  402404:	00 
  402405:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  40240c:	0f 84 96 01 00 00    	je     4025a8 <sched_thd_yield_to+0x218>
  402412:	83 e2 01             	and    edx,0x1
  402415:	0f 85 8d 01 00 00    	jne    4025a8 <sched_thd_yield_to+0x218>
	return &ss_thd_get(id)->thd;
  40241b:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  40241f:	48 8d 04 50          	lea    rax,[rax+rdx*2]
  402423:	48 c1 e0 04          	shl    rax,0x4
  402427:	4c 8d a8 60 fd 5b 00 	lea    r13,[rax+0x5bfd60]
	assert(current);
  40242e:	4d 85 e4             	test   r12,r12
  402431:	0f 84 d3 01 00 00    	je     40260a <sched_thd_yield_to+0x27a>
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  402437:	0f 01 f9             	rdtscp 
	cs = &(slm_global()->lock);
  40243a:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  402440:	48 8d 1c 89          	lea    rbx,[rcx+rcx*4]
  402444:	48 c1 e3 06          	shl    rbx,0x6
  402448:	48 81 c3 00 65 71 00 	add    rbx,0x716500
		tok    = cos_sched_sync();
  40244f:	e8 bc f6 00 00       	call   411b10 <cos_sched_sync>
  402454:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  402457:	48 8b 03             	mov    rax,QWORD PTR [rbx]
		if (unlikely(owner)) {
  40245a:	48 89 c1             	mov    rcx,rax
  40245d:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  402461:	0f 85 69 01 00 00    	jne    4025d0 <sched_thd_yield_to+0x240>
  402467:	f0 4c 0f b1 23       	lock cmpxchg QWORD PTR [rbx],r12
  40246c:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  40246f:	84 c0                	test   al,al
  402471:	74 dc                	je     40244f <sched_thd_yield_to+0xbf>
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  402473:	4c 89 ee             	mov    rsi,r13
  402476:	4c 89 e7             	mov    rdi,r12
  402479:	e8 52 18 01 00       	call   413cd0 <slm_sched_fprr_yield>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  40247e:	e8 cd 90 00 00       	call   40b550 <cos_defcompinfo_curr_get>
  402483:	0f 01 f9             	rdtscp 
	if (unlikely(!t)) t = &g->idle_thd;
  402486:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  40248c:	4c 8d 2c 89          	lea    r13,[rcx+rcx*4]
  402490:	49 c1 e5 06          	shl    r13,0x6
  402494:	49 81 c5 80 65 71 00 	add    r13,0x716580
	tok  = cos_sched_sync();
  40249b:	e8 70 f6 00 00       	call   411b10 <cos_sched_sync>
  4024a0:	41 89 c6             	mov    r14d,eax
  4024a3:	e8 f8 16 01 00       	call   413ba0 <slm_sched_fprr_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  4024a8:	48 85 c0             	test   rax,rax
  4024ab:	48 89 c3             	mov    rbx,rax
  4024ae:	49 0f 44 dd          	cmove  rbx,r13
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  4024b2:	8b 43 04             	mov    eax,DWORD PTR [rbx+0x4]
  4024b5:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  4024b8:	83 f8 01             	cmp    eax,0x1
  4024bb:	0f 87 65 01 00 00    	ja     402626 <sched_thd_yield_to+0x296>
  4024c1:	0f 01 f9             	rdtscp 
	struct slm_cs *cs = &(slm_global()->lock);
  4024c4:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  4024ca:	4c 8d 3c 89          	lea    r15,[rcx+rcx*4]
  4024ce:	49 c1 e7 06          	shl    r15,0x6
  4024d2:	49 81 c7 00 65 71 00 	add    r15,0x716500
	while (ret != 0) {
  4024d9:	eb 11                	jmp    4024ec <sched_thd_yield_to+0x15c>
  4024db:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  4024e0:	f0 49 0f b1 17       	lock cmpxchg QWORD PTR [r15],rdx
  4024e5:	0f 94 c0             	sete   al
  4024e8:	84 c0                	test   al,al
  4024ea:	75 28                	jne    402514 <sched_thd_yield_to+0x184>
		tok    = cos_sched_sync();
  4024ec:	e8 1f f6 00 00       	call   411b10 <cos_sched_sync>
  4024f1:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4024f3:	49 8b 07             	mov    rax,QWORD PTR [r15]
		if (unlikely(contention)) {
  4024f6:	48 89 c2             	mov    rdx,rax
  4024f9:	83 e2 01             	and    edx,0x1
  4024fc:	74 e2                	je     4024e0 <sched_thd_yield_to+0x150>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  4024fe:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  402501:	48 89 c2             	mov    rdx,rax
  402504:	4c 89 ff             	mov    rdi,r15
  402507:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  40250b:	e8 90 2b 01 00       	call   4150a0 <slm_cs_exit_contention>
  402510:	85 c0                	test   eax,eax
  402512:	75 d8                	jne    4024ec <sched_thd_yield_to+0x15c>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  402514:	e8 37 90 00 00       	call   40b550 <cos_defcompinfo_curr_get>
  402519:	0f 01 f9             	rdtscp 
	*coreid = c & 0xFFF;
  40251c:	89 ca                	mov    edx,ecx
	timeout = g->timeout_next;
  40251e:	81 e1 ff 0f 00 00    	and    ecx,0xfff
	prio = inherit_prio ? curr->priority : t->priority;
  402524:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
	timeout = g->timeout_next;
  402528:	48 8d 04 89          	lea    rax,[rcx+rcx*4]
  40252c:	66 81 e2 ff 0f       	and    dx,0xfff
  402531:	49 89 cf             	mov    r15,rcx
  402534:	48 c1 e0 06          	shl    rax,0x6
  402538:	4c 8b 80 08 66 71 00 	mov    r8,QWORD PTR [rax+0x716608]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  40253f:	8b 03                	mov    eax,DWORD PTR [rbx]
  402541:	a8 0b                	test   al,0xb
  402543:	0f 85 f9 00 00 00    	jne    402642 <sched_thd_yield_to+0x2b2>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  402549:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  40254d:	44 89 f1             	mov    ecx,r14d
  402550:	4c 89 c2             	mov    rdx,r8
  402553:	e8 48 a1 00 00       	call   40c6a0 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  402558:	83 f8 ff             	cmp    eax,0xffffffff
  40255b:	0f 84 39 01 00 00    	je     40269a <sched_thd_yield_to+0x30a>
	if (unlikely(ret != 0)) {
  402561:	85 c0                	test   eax,eax
  402563:	0f 85 a9 01 00 00    	jne    402712 <sched_thd_yield_to+0x382>
  402569:	31 c0                	xor    eax,eax
}
  40256b:	48 83 c4 08          	add    rsp,0x8
  40256f:	5b                   	pop    rbx
  402570:	41 5c                	pop    r12
  402572:	41 5d                	pop    r13
  402574:	41 5e                	pop    r14
  402576:	41 5f                	pop    r15
  402578:	5d                   	pop    rbp
  402579:	c3                   	ret    
  40257a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  402580:	83 e2 01             	and    edx,0x1
  402583:	0f 85 5b fe ff ff    	jne    4023e4 <sched_thd_yield_to+0x54>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  402589:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  40258d:	4c 8d 24 50          	lea    r12,[rax+rdx*2]
  402591:	49 c1 e4 04          	shl    r12,0x4
  402595:	49 81 c4 60 fd 5b 00 	add    r12,0x5bfd60
  40259c:	85 ff                	test   edi,edi
  40259e:	0f 85 48 fe ff ff    	jne    4023ec <sched_thd_yield_to+0x5c>
  4025a4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  4025a8:	be 24 00 00 00       	mov    esi,0x24
  4025ad:	bf 00 d6 41 00       	mov    edi,0x41d600
  4025b2:	e8 c9 86 00 00       	call   40ac80 <cos_print_str>
	assert(to);
  4025b7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4025be:	00 00 00 00 
  4025c2:	0f 0b                	ud2    
  4025c4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  4025c8:	45 31 e4             	xor    r12d,r12d
  4025cb:	e9 14 fe ff ff       	jmp    4023e4 <sched_thd_yield_to+0x54>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  4025d0:	41 89 c0             	mov    r8d,eax
  4025d3:	4c 89 e2             	mov    rdx,r12
  4025d6:	48 89 c6             	mov    rsi,rax
  4025d9:	48 89 df             	mov    rdi,rbx
  4025dc:	41 83 e0 01          	and    r8d,0x1
  4025e0:	e8 5b 2a 01 00       	call   415040 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  4025e5:	83 f8 f0             	cmp    eax,0xfffffff0
  4025e8:	0f 85 61 fe ff ff    	jne    40244f <sched_thd_yield_to+0xbf>
  4025ee:	be 59 00 00 00       	mov    esi,0x59
  4025f3:	bf 60 d1 41 00       	mov    edi,0x41d160
  4025f8:	e8 83 86 00 00       	call   40ac80 <cos_print_str>
  4025fd:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402604:	00 00 00 00 
  402608:	0f 0b                	ud2    
  40260a:	be 59 00 00 00       	mov    esi,0x59
  40260f:	bf 00 d1 41 00       	mov    edi,0x41d100
  402614:	e8 67 86 00 00       	call   40ac80 <cos_print_str>
	assert(current);
  402619:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402620:	00 00 00 00 
  402624:	0f 0b                	ud2    
  402626:	be 61 00 00 00       	mov    esi,0x61
  40262b:	bf e8 d1 41 00       	mov    edi,0x41d1e8
  402630:	e8 4b 86 00 00       	call   40ac80 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  402635:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40263c:	00 00 00 00 
  402640:	0f 0b                	ud2    
		if (t == &g->sched_thd) {
  402642:	0f b7 d2             	movzx  edx,dx
	timeout = g->timeout_next;
  402645:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  402648:	48 8d 14 92          	lea    rdx,[rdx+rdx*4]
  40264c:	48 c1 e2 06          	shl    rdx,0x6
  402650:	48 81 c2 08 65 71 00 	add    rdx,0x716508
  402657:	48 39 d3             	cmp    rbx,rdx
  40265a:	0f 84 07 01 00 00    	je     402767 <sched_thd_yield_to+0x3d7>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  402660:	a8 02                	test   al,0x2
  402662:	0f 85 0b 01 00 00    	jne    402773 <sched_thd_yield_to+0x3e3>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  402668:	49 89 c8             	mov    r8,rcx
  40266b:	a8 01                	test   al,0x1
  40266d:	0f 84 d6 fe ff ff    	je     402549 <sched_thd_yield_to+0x1b9>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  402673:	4b 8d 04 bf          	lea    rax,[r15+r15*4]
  402677:	4c 8b 53 08          	mov    r10,QWORD PTR [rbx+0x8]
  40267b:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  40267f:	48 89 f2             	mov    rdx,rsi
  402682:	48 c1 e0 06          	shl    rax,0x6
  402686:	45 89 f1             	mov    r9d,r14d
  402689:	4c 8b 80 28 65 71 00 	mov    r8,QWORD PTR [rax+0x716528]
  402690:	4c 89 d6             	mov    rsi,r10
  402693:	e8 98 f4 00 00       	call   411b30 <cos_switch>
  402698:	eb 6b                	jmp    402705 <sched_thd_yield_to+0x375>
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  40269a:	0f 01 f9             	rdtscp 
	return t != &g->idle_thd && t != &g->sched_thd;
  40269d:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  4026a3:	48 8d 04 89          	lea    rax,[rcx+rcx*4]
  4026a7:	48 c1 e0 06          	shl    rax,0x6
  4026ab:	48 8d 90 80 65 71 00 	lea    rdx,[rax+0x716580]
  4026b2:	48 39 d3             	cmp    rbx,rdx
  4026b5:	74 27                	je     4026de <sched_thd_yield_to+0x34e>
  4026b7:	48 05 08 65 71 00    	add    rax,0x716508
  4026bd:	48 39 c3             	cmp    rbx,rax
  4026c0:	74 1c                	je     4026de <sched_thd_yield_to+0x34e>
  4026c2:	be 61 00 00 00       	mov    esi,0x61
  4026c7:	bf 50 d2 41 00       	mov    edi,0x41d250
  4026cc:	e8 af 85 00 00       	call   40ac80 <cos_print_str>
		assert(ret != -EPERM);
  4026d1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4026d8:	00 00 00 00 
  4026dc:	0f 0b                	ud2    
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  4026de:	4b 8d 04 bf          	lea    rax,[r15+r15*4]
  4026e2:	49 8b 54 24 30       	mov    rdx,QWORD PTR [r12+0x30]
  4026e7:	45 89 f1             	mov    r9d,r14d
  4026ea:	31 c9                	xor    ecx,ecx
  4026ec:	48 c1 e0 06          	shl    rax,0x6
  4026f0:	31 f6                	xor    esi,esi
  4026f2:	4c 8b 80 28 65 71 00 	mov    r8,QWORD PTR [rax+0x716528]
  4026f9:	48 8b b8 18 65 71 00 	mov    rdi,QWORD PTR [rax+0x716518]
  402700:	e8 2b f4 00 00       	call   411b30 <cos_switch>
	if (unlikely(ret != 0)) {
  402705:	85 c0                	test   eax,eax
  402707:	0f 84 5c fe ff ff    	je     402569 <sched_thd_yield_to+0x1d9>
		assert(ret != -EPERM);
  40270d:	83 f8 ff             	cmp    eax,0xffffffff
  402710:	74 b0                	je     4026c2 <sched_thd_yield_to+0x332>
		assert(ret != -EINVAL);
  402712:	83 f8 ea             	cmp    eax,0xffffffea
  402715:	74 7f                	je     402796 <sched_thd_yield_to+0x406>
		if (ret == -EBUSY) return ret;
  402717:	83 f8 f0             	cmp    eax,0xfffffff0
  40271a:	0f 84 4b fe ff ff    	je     40256b <sched_thd_yield_to+0x1db>
		assert(ret == -EAGAIN);
  402720:	83 f8 f5             	cmp    eax,0xfffffff5
  402723:	0f 85 af 00 00 00    	jne    4027d8 <sched_thd_yield_to+0x448>
  402729:	0f 01 f9             	rdtscp 
	cs = &(slm_global()->lock);
  40272c:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  402732:	48 8d 1c 89          	lea    rbx,[rcx+rcx*4]
  402736:	48 c1 e3 06          	shl    rbx,0x6
  40273a:	48 81 c3 00 65 71 00 	add    rbx,0x716500
		tok    = cos_sched_sync();
  402741:	e8 ca f3 00 00       	call   411b10 <cos_sched_sync>
  402746:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  402749:	48 8b 03             	mov    rax,QWORD PTR [rbx]
		if (unlikely(owner)) {
  40274c:	48 89 c1             	mov    rcx,rax
  40274f:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  402753:	75 5d                	jne    4027b2 <sched_thd_yield_to+0x422>
  402755:	f0 4c 0f b1 23       	lock cmpxchg QWORD PTR [rbx],r12
  40275a:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  40275d:	84 c0                	test   al,al
  40275f:	0f 85 36 fd ff ff    	jne    40249b <sched_thd_yield_to+0x10b>
  402765:	eb da                	jmp    402741 <sched_thd_yield_to+0x3b1>
			prio    = curr->priority;
  402767:	49 8b 74 24 30       	mov    rsi,QWORD PTR [r12+0x30]
			timeout = TCAP_TIME_NIL;
  40276c:	31 c9                	xor    ecx,ecx
  40276e:	e9 ed fe ff ff       	jmp    402660 <sched_thd_yield_to+0x2d0>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  402773:	4b 8d 04 bf          	lea    rax,[r15+r15*4]
  402777:	48 8b 7b 28          	mov    rdi,QWORD PTR [rbx+0x28]
  40277b:	44 89 f1             	mov    ecx,r14d
  40277e:	4c 89 c6             	mov    rsi,r8
  402781:	48 c1 e0 06          	shl    rax,0x6
  402785:	48 8b 90 28 65 71 00 	mov    rdx,QWORD PTR [rax+0x716528]
  40278c:	e8 0f f4 00 00       	call   411ba0 <cos_sched_asnd>
  402791:	e9 6f ff ff ff       	jmp    402705 <sched_thd_yield_to+0x375>
  402796:	be 61 00 00 00       	mov    esi,0x61
  40279b:	bf b8 d2 41 00       	mov    edi,0x41d2b8
  4027a0:	e8 db 84 00 00       	call   40ac80 <cos_print_str>
		assert(ret != -EINVAL);
  4027a5:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4027ac:	00 00 00 00 
  4027b0:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  4027b2:	41 89 c0             	mov    r8d,eax
  4027b5:	4c 89 e2             	mov    rdx,r12
  4027b8:	48 89 c6             	mov    rsi,rax
  4027bb:	48 89 df             	mov    rdi,rbx
  4027be:	41 83 e0 01          	and    r8d,0x1
  4027c2:	e8 79 28 01 00       	call   415040 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  4027c7:	83 f8 f0             	cmp    eax,0xfffffff0
  4027ca:	0f 85 71 ff ff ff    	jne    402741 <sched_thd_yield_to+0x3b1>
  4027d0:	e9 19 fe ff ff       	jmp    4025ee <sched_thd_yield_to+0x25e>
  4027d5:	0f 1f 00             	nop    DWORD PTR [rax]
  4027d8:	be 61 00 00 00       	mov    esi,0x61
  4027dd:	bf 20 d3 41 00       	mov    edi,0x41d320
  4027e2:	e8 99 84 00 00       	call   40ac80 <cos_print_str>
		assert(ret == -EAGAIN);
  4027e7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4027ee:	00 00 00 00 
  4027f2:	0f 0b                	ud2    
  4027f4:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4027fb:	00 00 00 00 
  4027ff:	90                   	nop

0000000000402800 <sched_set_tls>:
{
  402800:	f3 0f 1e fa          	endbr64 
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  402804:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  402807:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  40280d:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  402814:	48 85 c0             	test   rax,rax
  402817:	0f 84 13 41 01 00    	je     416930 <sched_set_tls.cold>
  40281d:	83 e8 01             	sub    eax,0x1
  402820:	3d c7 00 00 00       	cmp    eax,0xc7
  402825:	0f 87 05 41 01 00    	ja     416930 <sched_set_tls.cold>
  40282b:	48 8b 14 c5 20 f7 5b 	mov    rdx,QWORD PTR [rax*8+0x5bf720]
  402832:	00 
  402833:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  40283a:	0f 84 f0 40 01 00    	je     416930 <sched_set_tls.cold>
  402840:	83 e2 01             	and    edx,0x1
  402843:	0f 85 e7 40 01 00    	jne    416930 <sched_set_tls.cold>
	thdcap_t thdcap = current->thd;
  402849:	48 8d 14 80          	lea    rdx,[rax+rax*4]
	capmgr_set_tls(thdcap, tls_addr);
  40284d:	48 89 fe             	mov    rsi,rdi
	thdcap_t thdcap = current->thd;
  402850:	48 8d 04 50          	lea    rax,[rax+rdx*2]
  402854:	48 c1 e0 04          	shl    rax,0x4
	capmgr_set_tls(thdcap, tls_addr);
  402858:	4c 8b 80 70 fd 5b 00 	mov    r8,QWORD PTR [rax+0x5bfd70]
  40285f:	4c 89 c7             	mov    rdi,r8
  402862:	e9 29 57 00 00       	jmp    407f90 <__cosrt_extern_capmgr_set_tls>
  402867:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40286e:	00 00 

0000000000402870 <thd_block>:
{
  402870:	f3 0f 1e fa          	endbr64 
  402874:	55                   	push   rbp
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  402875:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  402878:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  40287e:	48 89 e5             	mov    rbp,rsp
  402881:	41 57                	push   r15
  402883:	41 56                	push   r14
  402885:	41 55                	push   r13
  402887:	41 54                	push   r12
  402889:	53                   	push   rbx
  40288a:	48 83 ec 18          	sub    rsp,0x18
  40288e:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  402895:	48 85 c0             	test   rax,rax
  402898:	0f 84 02 02 00 00    	je     402aa0 <thd_block+0x230>
  40289e:	83 e8 01             	sub    eax,0x1
  4028a1:	3d c7 00 00 00       	cmp    eax,0xc7
  4028a6:	0f 87 f4 01 00 00    	ja     402aa0 <thd_block+0x230>
  4028ac:	48 8b 14 c5 20 f7 5b 	mov    rdx,QWORD PTR [rax*8+0x5bf720]
  4028b3:	00 
  4028b4:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  4028bb:	0f 84 df 01 00 00    	je     402aa0 <thd_block+0x230>
  4028c1:	83 e2 01             	and    edx,0x1
  4028c4:	0f 85 d6 01 00 00    	jne    402aa0 <thd_block+0x230>
  4028ca:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  4028ce:	48 8d 1c 50          	lea    rbx,[rax+rdx*2]
  4028d2:	48 c1 e3 04          	shl    rbx,0x4
  4028d6:	48 81 c3 60 fd 5b 00 	add    rbx,0x5bfd60
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  4028dd:	0f 01 f9             	rdtscp 
	cs = &(slm_global()->lock);
  4028e0:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  4028e6:	4c 8d 24 89          	lea    r12,[rcx+rcx*4]
  4028ea:	49 c1 e4 06          	shl    r12,0x6
  4028ee:	49 81 c4 00 65 71 00 	add    r12,0x716500
		tok    = cos_sched_sync();
  4028f5:	e8 16 f2 00 00       	call   411b10 <cos_sched_sync>
  4028fa:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4028fd:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
		if (unlikely(owner)) {
  402901:	48 89 c1             	mov    rcx,rax
  402904:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  402908:	0f 85 b2 01 00 00    	jne    402ac0 <thd_block+0x250>
  40290e:	f0 49 0f b1 1c 24    	lock cmpxchg QWORD PTR [r12],rbx
  402914:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  402917:	84 c0                	test   al,al
  402919:	74 da                	je     4028f5 <thd_block+0x85>
        ret = slm_thd_block(current);
  40291b:	48 89 df             	mov    rdi,rbx
  40291e:	e8 fd 27 01 00       	call   415120 <slm_thd_block>
  402923:	41 89 c5             	mov    r13d,eax
	if (!ret) ret = slm_cs_exit_reschedule(current, SLM_CS_NONE);
  402926:	85 c0                	test   eax,eax
  402928:	0f 85 12 01 00 00    	jne    402a40 <thd_block+0x1d0>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  40292e:	e8 1d 8c 00 00       	call   40b550 <cos_defcompinfo_curr_get>
  402933:	0f 01 f9             	rdtscp 
	if (unlikely(!t)) t = &g->idle_thd;
  402936:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  40293c:	4c 8d 34 89          	lea    r14,[rcx+rcx*4]
  402940:	49 c1 e6 06          	shl    r14,0x6
  402944:	49 8d 86 80 65 71 00 	lea    rax,[r14+0x716580]
  40294b:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
	tok  = cos_sched_sync();
  40294f:	e8 bc f1 00 00       	call   411b10 <cos_sched_sync>
  402954:	41 89 c7             	mov    r15d,eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  402957:	e8 44 12 01 00       	call   413ba0 <slm_sched_fprr_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  40295c:	48 85 c0             	test   rax,rax
  40295f:	49 89 c4             	mov    r12,rax
  402962:	4c 0f 44 65 c8       	cmove  r12,QWORD PTR [rbp-0x38]
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  402967:	41 8b 44 24 04       	mov    eax,DWORD PTR [r12+0x4]
  40296c:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  40296f:	83 f8 01             	cmp    eax,0x1
  402972:	0f 87 82 01 00 00    	ja     402afa <thd_block+0x28a>
  402978:	0f 01 f9             	rdtscp 
	struct slm_cs *cs = &(slm_global()->lock);
  40297b:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  402981:	48 8d 3c 89          	lea    rdi,[rcx+rcx*4]
  402985:	48 c1 e7 06          	shl    rdi,0x6
  402989:	4c 8d b7 00 65 71 00 	lea    r14,[rdi+0x716500]
	while (ret != 0) {
  402990:	eb 12                	jmp    4029a4 <thd_block+0x134>
  402992:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  402998:	f0 49 0f b1 16       	lock cmpxchg QWORD PTR [r14],rdx
  40299d:	0f 94 c0             	sete   al
  4029a0:	84 c0                	test   al,al
  4029a2:	75 28                	jne    4029cc <thd_block+0x15c>
		tok    = cos_sched_sync();
  4029a4:	e8 67 f1 00 00       	call   411b10 <cos_sched_sync>
  4029a9:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4029ab:	49 8b 06             	mov    rax,QWORD PTR [r14]
		if (unlikely(contention)) {
  4029ae:	48 89 c2             	mov    rdx,rax
  4029b1:	83 e2 01             	and    edx,0x1
  4029b4:	74 e2                	je     402998 <thd_block+0x128>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  4029b6:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  4029b9:	48 89 c2             	mov    rdx,rax
  4029bc:	4c 89 f7             	mov    rdi,r14
  4029bf:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  4029c3:	e8 d8 26 01 00       	call   4150a0 <slm_cs_exit_contention>
  4029c8:	85 c0                	test   eax,eax
  4029ca:	75 d8                	jne    4029a4 <thd_block+0x134>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  4029cc:	e8 7f 8b 00 00       	call   40b550 <cos_defcompinfo_curr_get>
  4029d1:	0f 01 f9             	rdtscp 
	*coreid = c & 0xFFF;
  4029d4:	89 ca                	mov    edx,ecx
	timeout = g->timeout_next;
  4029d6:	81 e1 ff 0f 00 00    	and    ecx,0xfff
	prio = inherit_prio ? curr->priority : t->priority;
  4029dc:	49 8b 74 24 30       	mov    rsi,QWORD PTR [r12+0x30]
	timeout = g->timeout_next;
  4029e1:	48 8d 04 89          	lea    rax,[rcx+rcx*4]
  4029e5:	66 81 e2 ff 0f       	and    dx,0xfff
  4029ea:	49 89 ce             	mov    r14,rcx
  4029ed:	48 c1 e0 06          	shl    rax,0x6
  4029f1:	4c 8b 88 08 66 71 00 	mov    r9,QWORD PTR [rax+0x716608]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4029f8:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  4029fc:	a8 0b                	test   al,0xb
  4029fe:	0f 85 12 01 00 00    	jne    402b16 <thd_block+0x2a6>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  402a04:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  402a09:	44 89 f9             	mov    ecx,r15d
  402a0c:	4c 89 ca             	mov    rdx,r9
  402a0f:	e8 8c 9c 00 00       	call   40c6a0 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  402a14:	83 f8 ff             	cmp    eax,0xffffffff
  402a17:	0f 84 c3 01 00 00    	je     402be0 <thd_block+0x370>
	if (unlikely(ret != 0)) {
  402a1d:	85 c0                	test   eax,eax
  402a1f:	0f 85 5a 01 00 00    	jne    402b7f <thd_block+0x30f>
}
  402a25:	48 83 c4 18          	add    rsp,0x18
  402a29:	44 89 e8             	mov    eax,r13d
  402a2c:	5b                   	pop    rbx
  402a2d:	41 5c                	pop    r12
  402a2f:	41 5d                	pop    r13
  402a31:	41 5e                	pop    r14
  402a33:	41 5f                	pop    r15
  402a35:	5d                   	pop    rbp
  402a36:	c3                   	ret    
  402a37:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  402a3e:	00 00 
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  402a40:	0f 01 f9             	rdtscp 
	struct slm_cs *cs = &(slm_global()->lock);
  402a43:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  402a49:	48 8d 1c 89          	lea    rbx,[rcx+rcx*4]
  402a4d:	48 c1 e3 06          	shl    rbx,0x6
  402a51:	48 81 c3 00 65 71 00 	add    rbx,0x716500
	while (ret != 0) {
  402a58:	eb 12                	jmp    402a6c <thd_block+0x1fc>
  402a5a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  402a60:	f0 48 0f b1 13       	lock cmpxchg QWORD PTR [rbx],rdx
  402a65:	0f 94 c0             	sete   al
  402a68:	84 c0                	test   al,al
  402a6a:	75 b9                	jne    402a25 <thd_block+0x1b5>
		tok    = cos_sched_sync();
  402a6c:	e8 9f f0 00 00       	call   411b10 <cos_sched_sync>
  402a71:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  402a73:	48 8b 03             	mov    rax,QWORD PTR [rbx]
		if (unlikely(contention)) {
  402a76:	48 89 c2             	mov    rdx,rax
  402a79:	83 e2 01             	and    edx,0x1
  402a7c:	74 e2                	je     402a60 <thd_block+0x1f0>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  402a7e:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  402a81:	48 89 c2             	mov    rdx,rax
  402a84:	48 89 df             	mov    rdi,rbx
  402a87:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  402a8b:	e8 10 26 01 00       	call   4150a0 <slm_cs_exit_contention>
  402a90:	85 c0                	test   eax,eax
  402a92:	74 91                	je     402a25 <thd_block+0x1b5>
  402a94:	eb d6                	jmp    402a6c <thd_block+0x1fc>
  402a96:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  402a9d:	00 00 00 
  402aa0:	be 59 00 00 00       	mov    esi,0x59
  402aa5:	bf 00 d1 41 00       	mov    edi,0x41d100
  402aaa:	e8 d1 81 00 00       	call   40ac80 <cos_print_str>
	assert(current);
  402aaf:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402ab6:	00 00 00 00 
  402aba:	0f 0b                	ud2    
  402abc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  402ac0:	41 89 c0             	mov    r8d,eax
  402ac3:	48 89 da             	mov    rdx,rbx
  402ac6:	48 89 c6             	mov    rsi,rax
  402ac9:	4c 89 e7             	mov    rdi,r12
  402acc:	41 83 e0 01          	and    r8d,0x1
  402ad0:	e8 6b 25 01 00       	call   415040 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  402ad5:	83 f8 f0             	cmp    eax,0xfffffff0
  402ad8:	0f 85 17 fe ff ff    	jne    4028f5 <thd_block+0x85>
  402ade:	be 59 00 00 00       	mov    esi,0x59
  402ae3:	bf 60 d1 41 00       	mov    edi,0x41d160
  402ae8:	e8 93 81 00 00       	call   40ac80 <cos_print_str>
  402aed:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402af4:	00 00 00 00 
  402af8:	0f 0b                	ud2    
  402afa:	be 61 00 00 00       	mov    esi,0x61
  402aff:	bf e8 d1 41 00       	mov    edi,0x41d1e8
  402b04:	e8 77 81 00 00       	call   40ac80 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  402b09:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402b10:	00 00 00 00 
  402b14:	0f 0b                	ud2    
		if (t == &g->sched_thd) {
  402b16:	0f b7 d2             	movzx  edx,dx
	timeout = g->timeout_next;
  402b19:	4c 89 c9             	mov    rcx,r9
		if (t == &g->sched_thd) {
  402b1c:	48 8d 14 92          	lea    rdx,[rdx+rdx*4]
  402b20:	48 c1 e2 06          	shl    rdx,0x6
  402b24:	48 81 c2 08 65 71 00 	add    rdx,0x716508
  402b2b:	49 39 d4             	cmp    r12,rdx
  402b2e:	0f 84 f0 00 00 00    	je     402c24 <thd_block+0x3b4>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  402b34:	a8 02                	test   al,0x2
  402b36:	0f 85 f3 00 00 00    	jne    402c2f <thd_block+0x3bf>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  402b3c:	49 89 c9             	mov    r9,rcx
  402b3f:	a8 01                	test   al,0x1
  402b41:	0f 84 bd fe ff ff    	je     402a04 <thd_block+0x194>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  402b47:	4b 8d 04 b6          	lea    rax,[r14+r14*4]
  402b4b:	4d 8b 54 24 08       	mov    r10,QWORD PTR [r12+0x8]
  402b50:	48 89 f2             	mov    rdx,rsi
  402b53:	45 89 f9             	mov    r9d,r15d
  402b56:	48 c1 e0 06          	shl    rax,0x6
  402b5a:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  402b5f:	4c 8b 80 28 65 71 00 	mov    r8,QWORD PTR [rax+0x716528]
  402b66:	4c 89 d6             	mov    rsi,r10
  402b69:	e8 c2 ef 00 00       	call   411b30 <cos_switch>
	if (unlikely(ret != 0)) {
  402b6e:	85 c0                	test   eax,eax
  402b70:	0f 84 af fe ff ff    	je     402a25 <thd_block+0x1b5>
		assert(ret != -EPERM);
  402b76:	83 f8 ff             	cmp    eax,0xffffffff
  402b79:	0f 84 89 00 00 00    	je     402c08 <thd_block+0x398>
		assert(ret != -EINVAL);
  402b7f:	83 f8 ea             	cmp    eax,0xffffffea
  402b82:	0f 84 f6 00 00 00    	je     402c7e <thd_block+0x40e>
		if (ret == -EBUSY) return ret;
  402b88:	83 f8 f0             	cmp    eax,0xfffffff0
  402b8b:	0f 84 4b 01 00 00    	je     402cdc <thd_block+0x46c>
		assert(ret == -EAGAIN);
  402b91:	83 f8 f5             	cmp    eax,0xfffffff5
  402b94:	0f 85 26 01 00 00    	jne    402cc0 <thd_block+0x450>
  402b9a:	0f 01 f9             	rdtscp 
	cs = &(slm_global()->lock);
  402b9d:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  402ba3:	4c 8d 24 89          	lea    r12,[rcx+rcx*4]
  402ba7:	49 c1 e4 06          	shl    r12,0x6
  402bab:	49 81 c4 00 65 71 00 	add    r12,0x716500
		tok    = cos_sched_sync();
  402bb2:	e8 59 ef 00 00       	call   411b10 <cos_sched_sync>
  402bb7:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  402bba:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
		if (unlikely(owner)) {
  402bbe:	48 89 c1             	mov    rcx,rax
  402bc1:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  402bc5:	0f 85 cf 00 00 00    	jne    402c9a <thd_block+0x42a>
  402bcb:	f0 49 0f b1 1c 24    	lock cmpxchg QWORD PTR [r12],rbx
  402bd1:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  402bd4:	84 c0                	test   al,al
  402bd6:	0f 85 73 fd ff ff    	jne    40294f <thd_block+0xdf>
  402bdc:	eb d4                	jmp    402bb2 <thd_block+0x342>
  402bde:	66 90                	xchg   ax,ax
  402be0:	0f 01 f9             	rdtscp 
	return t != &g->idle_thd && t != &g->sched_thd;
  402be3:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  402be9:	48 8d 04 89          	lea    rax,[rcx+rcx*4]
  402bed:	48 c1 e0 06          	shl    rax,0x6
  402bf1:	48 8d 90 80 65 71 00 	lea    rdx,[rax+0x716580]
  402bf8:	49 39 d4             	cmp    r12,rdx
  402bfb:	74 56                	je     402c53 <thd_block+0x3e3>
  402bfd:	48 05 08 65 71 00    	add    rax,0x716508
  402c03:	49 39 c4             	cmp    r12,rax
  402c06:	74 4b                	je     402c53 <thd_block+0x3e3>
  402c08:	be 61 00 00 00       	mov    esi,0x61
  402c0d:	bf 50 d2 41 00       	mov    edi,0x41d250
  402c12:	e8 69 80 00 00       	call   40ac80 <cos_print_str>
		assert(ret != -EPERM);
  402c17:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402c1e:	00 00 00 00 
  402c22:	0f 0b                	ud2    
			prio    = curr->priority;
  402c24:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
			timeout = TCAP_TIME_NIL;
  402c28:	31 c9                	xor    ecx,ecx
  402c2a:	e9 05 ff ff ff       	jmp    402b34 <thd_block+0x2c4>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  402c2f:	4b 8d 04 b6          	lea    rax,[r14+r14*4]
  402c33:	49 8b 7c 24 28       	mov    rdi,QWORD PTR [r12+0x28]
  402c38:	44 89 f9             	mov    ecx,r15d
  402c3b:	4c 89 ce             	mov    rsi,r9
  402c3e:	48 c1 e0 06          	shl    rax,0x6
  402c42:	48 8b 90 28 65 71 00 	mov    rdx,QWORD PTR [rax+0x716528]
  402c49:	e8 52 ef 00 00       	call   411ba0 <cos_sched_asnd>
  402c4e:	e9 1b ff ff ff       	jmp    402b6e <thd_block+0x2fe>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  402c53:	4b 8d 04 b6          	lea    rax,[r14+r14*4]
  402c57:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]
  402c5b:	45 89 f9             	mov    r9d,r15d
  402c5e:	31 c9                	xor    ecx,ecx
  402c60:	48 c1 e0 06          	shl    rax,0x6
  402c64:	31 f6                	xor    esi,esi
  402c66:	4c 8b 80 28 65 71 00 	mov    r8,QWORD PTR [rax+0x716528]
  402c6d:	48 8b b8 18 65 71 00 	mov    rdi,QWORD PTR [rax+0x716518]
  402c74:	e8 b7 ee 00 00       	call   411b30 <cos_switch>
  402c79:	e9 f0 fe ff ff       	jmp    402b6e <thd_block+0x2fe>
  402c7e:	be 61 00 00 00       	mov    esi,0x61
  402c83:	bf b8 d2 41 00       	mov    edi,0x41d2b8
  402c88:	e8 f3 7f 00 00       	call   40ac80 <cos_print_str>
		assert(ret != -EINVAL);
  402c8d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402c94:	00 00 00 00 
  402c98:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  402c9a:	41 89 c0             	mov    r8d,eax
  402c9d:	48 89 da             	mov    rdx,rbx
  402ca0:	48 89 c6             	mov    rsi,rax
  402ca3:	4c 89 e7             	mov    rdi,r12
  402ca6:	41 83 e0 01          	and    r8d,0x1
  402caa:	e8 91 23 01 00       	call   415040 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  402caf:	83 f8 f0             	cmp    eax,0xfffffff0
  402cb2:	0f 85 fa fe ff ff    	jne    402bb2 <thd_block+0x342>
  402cb8:	e9 21 fe ff ff       	jmp    402ade <thd_block+0x26e>
  402cbd:	0f 1f 00             	nop    DWORD PTR [rax]
  402cc0:	be 61 00 00 00       	mov    esi,0x61
  402cc5:	bf 20 d3 41 00       	mov    edi,0x41d320
  402cca:	e8 b1 7f 00 00       	call   40ac80 <cos_print_str>
		assert(ret == -EAGAIN);
  402ccf:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402cd6:	00 00 00 00 
  402cda:	0f 0b                	ud2    
	ret = slm_thd_activate(curr, t, tok, 0);
  402cdc:	41 bd f0 ff ff ff    	mov    r13d,0xfffffff0
	return ret;
  402ce2:	e9 3e fd ff ff       	jmp    402a25 <thd_block+0x1b5>
  402ce7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  402cee:	00 00 

0000000000402cf0 <sched_thd_block>:
{
  402cf0:	f3 0f 1e fa          	endbr64 
  402cf4:	55                   	push   rbp
  402cf5:	48 89 e5             	mov    rbp,rsp
  402cf8:	41 57                	push   r15
  402cfa:	41 56                	push   r14
  402cfc:	41 55                	push   r13
  402cfe:	41 54                	push   r12
  402d00:	53                   	push   rbx
  402d01:	48 83 ec 18          	sub    rsp,0x18
	if (dep_id) return -1;
  402d05:	48 85 ff             	test   rdi,rdi
  402d08:	0f 85 96 03 00 00    	jne    4030a4 <sched_thd_block+0x3b4>
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  402d0e:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  402d11:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  402d17:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  402d1e:	48 85 c0             	test   rax,rax
  402d21:	0f 84 f9 01 00 00    	je     402f20 <sched_thd_block+0x230>
  402d27:	83 e8 01             	sub    eax,0x1
  402d2a:	3d c7 00 00 00       	cmp    eax,0xc7
  402d2f:	0f 87 eb 01 00 00    	ja     402f20 <sched_thd_block+0x230>
  402d35:	48 8b 14 c5 20 f7 5b 	mov    rdx,QWORD PTR [rax*8+0x5bf720]
  402d3c:	00 
  402d3d:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  402d44:	0f 84 d6 01 00 00    	je     402f20 <sched_thd_block+0x230>
  402d4a:	83 e2 01             	and    edx,0x1
  402d4d:	0f 85 cd 01 00 00    	jne    402f20 <sched_thd_block+0x230>
  402d53:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  402d57:	48 8d 1c 50          	lea    rbx,[rax+rdx*2]
  402d5b:	48 c1 e3 04          	shl    rbx,0x4
  402d5f:	48 81 c3 60 fd 5b 00 	add    rbx,0x5bfd60
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  402d66:	0f 01 f9             	rdtscp 
	cs = &(slm_global()->lock);
  402d69:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  402d6f:	4c 8d 24 89          	lea    r12,[rcx+rcx*4]
  402d73:	49 c1 e4 06          	shl    r12,0x6
  402d77:	49 81 c4 00 65 71 00 	add    r12,0x716500
		tok    = cos_sched_sync();
  402d7e:	e8 8d ed 00 00       	call   411b10 <cos_sched_sync>
  402d83:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  402d86:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
		if (unlikely(owner)) {
  402d8a:	48 89 c1             	mov    rcx,rax
  402d8d:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  402d91:	0f 85 a9 01 00 00    	jne    402f40 <sched_thd_block+0x250>
  402d97:	f0 49 0f b1 1c 24    	lock cmpxchg QWORD PTR [r12],rbx
  402d9d:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  402da0:	84 c0                	test   al,al
  402da2:	74 da                	je     402d7e <sched_thd_block+0x8e>
        ret = slm_thd_block(current);
  402da4:	48 89 df             	mov    rdi,rbx
  402da7:	e8 74 23 01 00       	call   415120 <slm_thd_block>
  402dac:	41 89 c5             	mov    r13d,eax
	if (!ret) ret = slm_cs_exit_reschedule(current, SLM_CS_NONE);
  402daf:	85 c0                	test   eax,eax
  402db1:	0f 85 09 01 00 00    	jne    402ec0 <sched_thd_block+0x1d0>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  402db7:	e8 94 87 00 00       	call   40b550 <cos_defcompinfo_curr_get>
  402dbc:	0f 01 f9             	rdtscp 
	if (unlikely(!t)) t = &g->idle_thd;
  402dbf:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  402dc5:	4c 8d 34 89          	lea    r14,[rcx+rcx*4]
  402dc9:	49 c1 e6 06          	shl    r14,0x6
  402dcd:	49 8d 86 80 65 71 00 	lea    rax,[r14+0x716580]
  402dd4:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
	tok  = cos_sched_sync();
  402dd8:	e8 33 ed 00 00       	call   411b10 <cos_sched_sync>
  402ddd:	41 89 c7             	mov    r15d,eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  402de0:	e8 bb 0d 01 00       	call   413ba0 <slm_sched_fprr_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  402de5:	48 85 c0             	test   rax,rax
  402de8:	49 89 c4             	mov    r12,rax
  402deb:	4c 0f 44 65 c8       	cmove  r12,QWORD PTR [rbp-0x38]
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  402df0:	41 8b 44 24 04       	mov    eax,DWORD PTR [r12+0x4]
  402df5:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  402df8:	83 f8 01             	cmp    eax,0x1
  402dfb:	0f 87 79 01 00 00    	ja     402f7a <sched_thd_block+0x28a>
  402e01:	0f 01 f9             	rdtscp 
	struct slm_cs *cs = &(slm_global()->lock);
  402e04:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  402e0a:	48 8d 3c 89          	lea    rdi,[rcx+rcx*4]
  402e0e:	48 c1 e7 06          	shl    rdi,0x6
  402e12:	4c 8d b7 00 65 71 00 	lea    r14,[rdi+0x716500]
	while (ret != 0) {
  402e19:	eb 11                	jmp    402e2c <sched_thd_block+0x13c>
  402e1b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  402e20:	f0 49 0f b1 16       	lock cmpxchg QWORD PTR [r14],rdx
  402e25:	0f 94 c0             	sete   al
  402e28:	84 c0                	test   al,al
  402e2a:	75 28                	jne    402e54 <sched_thd_block+0x164>
		tok    = cos_sched_sync();
  402e2c:	e8 df ec 00 00       	call   411b10 <cos_sched_sync>
  402e31:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  402e33:	49 8b 06             	mov    rax,QWORD PTR [r14]
		if (unlikely(contention)) {
  402e36:	48 89 c2             	mov    rdx,rax
  402e39:	83 e2 01             	and    edx,0x1
  402e3c:	74 e2                	je     402e20 <sched_thd_block+0x130>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  402e3e:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  402e41:	48 89 c2             	mov    rdx,rax
  402e44:	4c 89 f7             	mov    rdi,r14
  402e47:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  402e4b:	e8 50 22 01 00       	call   4150a0 <slm_cs_exit_contention>
  402e50:	85 c0                	test   eax,eax
  402e52:	75 d8                	jne    402e2c <sched_thd_block+0x13c>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  402e54:	e8 f7 86 00 00       	call   40b550 <cos_defcompinfo_curr_get>
  402e59:	0f 01 f9             	rdtscp 
	*coreid = c & 0xFFF;
  402e5c:	89 ca                	mov    edx,ecx
	timeout = g->timeout_next;
  402e5e:	81 e1 ff 0f 00 00    	and    ecx,0xfff
	prio = inherit_prio ? curr->priority : t->priority;
  402e64:	49 8b 74 24 30       	mov    rsi,QWORD PTR [r12+0x30]
	timeout = g->timeout_next;
  402e69:	48 8d 04 89          	lea    rax,[rcx+rcx*4]
  402e6d:	66 81 e2 ff 0f       	and    dx,0xfff
  402e72:	49 89 ce             	mov    r14,rcx
  402e75:	48 c1 e0 06          	shl    rax,0x6
  402e79:	4c 8b 88 08 66 71 00 	mov    r9,QWORD PTR [rax+0x716608]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  402e80:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  402e84:	a8 0b                	test   al,0xb
  402e86:	0f 85 0a 01 00 00    	jne    402f96 <sched_thd_block+0x2a6>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  402e8c:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  402e91:	44 89 f9             	mov    ecx,r15d
  402e94:	4c 89 ca             	mov    rdx,r9
  402e97:	e8 04 98 00 00       	call   40c6a0 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  402e9c:	83 f8 ff             	cmp    eax,0xffffffff
  402e9f:	0f 84 bb 01 00 00    	je     403060 <sched_thd_block+0x370>
	if (unlikely(ret != 0)) {
  402ea5:	85 c0                	test   eax,eax
  402ea7:	0f 85 52 01 00 00    	jne    402fff <sched_thd_block+0x30f>
}
  402ead:	48 83 c4 18          	add    rsp,0x18
  402eb1:	44 89 e8             	mov    eax,r13d
  402eb4:	5b                   	pop    rbx
  402eb5:	41 5c                	pop    r12
  402eb7:	41 5d                	pop    r13
  402eb9:	41 5e                	pop    r14
  402ebb:	41 5f                	pop    r15
  402ebd:	5d                   	pop    rbp
  402ebe:	c3                   	ret    
  402ebf:	90                   	nop
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  402ec0:	0f 01 f9             	rdtscp 
	struct slm_cs *cs = &(slm_global()->lock);
  402ec3:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  402ec9:	48 8d 1c 89          	lea    rbx,[rcx+rcx*4]
  402ecd:	48 c1 e3 06          	shl    rbx,0x6
  402ed1:	48 81 c3 00 65 71 00 	add    rbx,0x716500
	while (ret != 0) {
  402ed8:	eb 12                	jmp    402eec <sched_thd_block+0x1fc>
  402eda:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  402ee0:	f0 48 0f b1 13       	lock cmpxchg QWORD PTR [rbx],rdx
  402ee5:	0f 94 c0             	sete   al
  402ee8:	84 c0                	test   al,al
  402eea:	75 c1                	jne    402ead <sched_thd_block+0x1bd>
		tok    = cos_sched_sync();
  402eec:	e8 1f ec 00 00       	call   411b10 <cos_sched_sync>
  402ef1:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  402ef3:	48 8b 03             	mov    rax,QWORD PTR [rbx]
		if (unlikely(contention)) {
  402ef6:	48 89 c2             	mov    rdx,rax
  402ef9:	83 e2 01             	and    edx,0x1
  402efc:	74 e2                	je     402ee0 <sched_thd_block+0x1f0>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  402efe:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  402f01:	48 89 c2             	mov    rdx,rax
  402f04:	48 89 df             	mov    rdi,rbx
  402f07:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  402f0b:	e8 90 21 01 00       	call   4150a0 <slm_cs_exit_contention>
  402f10:	85 c0                	test   eax,eax
  402f12:	74 99                	je     402ead <sched_thd_block+0x1bd>
  402f14:	eb d6                	jmp    402eec <sched_thd_block+0x1fc>
  402f16:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  402f1d:	00 00 00 
  402f20:	be 59 00 00 00       	mov    esi,0x59
  402f25:	bf 00 d1 41 00       	mov    edi,0x41d100
  402f2a:	e8 51 7d 00 00       	call   40ac80 <cos_print_str>
	assert(current);
  402f2f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402f36:	00 00 00 00 
  402f3a:	0f 0b                	ud2    
  402f3c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  402f40:	41 89 c0             	mov    r8d,eax
  402f43:	48 89 da             	mov    rdx,rbx
  402f46:	48 89 c6             	mov    rsi,rax
  402f49:	4c 89 e7             	mov    rdi,r12
  402f4c:	41 83 e0 01          	and    r8d,0x1
  402f50:	e8 eb 20 01 00       	call   415040 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  402f55:	83 f8 f0             	cmp    eax,0xfffffff0
  402f58:	0f 85 20 fe ff ff    	jne    402d7e <sched_thd_block+0x8e>
  402f5e:	be 59 00 00 00       	mov    esi,0x59
  402f63:	bf 60 d1 41 00       	mov    edi,0x41d160
  402f68:	e8 13 7d 00 00       	call   40ac80 <cos_print_str>
  402f6d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402f74:	00 00 00 00 
  402f78:	0f 0b                	ud2    
  402f7a:	be 61 00 00 00       	mov    esi,0x61
  402f7f:	bf e8 d1 41 00       	mov    edi,0x41d1e8
  402f84:	e8 f7 7c 00 00       	call   40ac80 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  402f89:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  402f90:	00 00 00 00 
  402f94:	0f 0b                	ud2    
		if (t == &g->sched_thd) {
  402f96:	0f b7 d2             	movzx  edx,dx
	timeout = g->timeout_next;
  402f99:	4c 89 c9             	mov    rcx,r9
		if (t == &g->sched_thd) {
  402f9c:	48 8d 14 92          	lea    rdx,[rdx+rdx*4]
  402fa0:	48 c1 e2 06          	shl    rdx,0x6
  402fa4:	48 81 c2 08 65 71 00 	add    rdx,0x716508
  402fab:	49 39 d4             	cmp    r12,rdx
  402fae:	0f 84 fb 00 00 00    	je     4030af <sched_thd_block+0x3bf>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  402fb4:	a8 02                	test   al,0x2
  402fb6:	0f 85 fe 00 00 00    	jne    4030ba <sched_thd_block+0x3ca>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  402fbc:	49 89 c9             	mov    r9,rcx
  402fbf:	a8 01                	test   al,0x1
  402fc1:	0f 84 c5 fe ff ff    	je     402e8c <sched_thd_block+0x19c>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  402fc7:	4b 8d 04 b6          	lea    rax,[r14+r14*4]
  402fcb:	4d 8b 54 24 08       	mov    r10,QWORD PTR [r12+0x8]
  402fd0:	48 89 f2             	mov    rdx,rsi
  402fd3:	45 89 f9             	mov    r9d,r15d
  402fd6:	48 c1 e0 06          	shl    rax,0x6
  402fda:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  402fdf:	4c 8b 80 28 65 71 00 	mov    r8,QWORD PTR [rax+0x716528]
  402fe6:	4c 89 d6             	mov    rsi,r10
  402fe9:	e8 42 eb 00 00       	call   411b30 <cos_switch>
	if (unlikely(ret != 0)) {
  402fee:	85 c0                	test   eax,eax
  402ff0:	0f 84 b7 fe ff ff    	je     402ead <sched_thd_block+0x1bd>
		assert(ret != -EPERM);
  402ff6:	83 f8 ff             	cmp    eax,0xffffffff
  402ff9:	0f 84 89 00 00 00    	je     403088 <sched_thd_block+0x398>
		assert(ret != -EINVAL);
  402fff:	83 f8 ea             	cmp    eax,0xffffffea
  403002:	0f 84 01 01 00 00    	je     403109 <sched_thd_block+0x419>
		if (ret == -EBUSY) return ret;
  403008:	83 f8 f0             	cmp    eax,0xfffffff0
  40300b:	0f 84 5b 01 00 00    	je     40316c <sched_thd_block+0x47c>
		assert(ret == -EAGAIN);
  403011:	83 f8 f5             	cmp    eax,0xfffffff5
  403014:	0f 85 36 01 00 00    	jne    403150 <sched_thd_block+0x460>
  40301a:	0f 01 f9             	rdtscp 
	cs = &(slm_global()->lock);
  40301d:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  403023:	4c 8d 24 89          	lea    r12,[rcx+rcx*4]
  403027:	49 c1 e4 06          	shl    r12,0x6
  40302b:	49 81 c4 00 65 71 00 	add    r12,0x716500
		tok    = cos_sched_sync();
  403032:	e8 d9 ea 00 00       	call   411b10 <cos_sched_sync>
  403037:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  40303a:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
		if (unlikely(owner)) {
  40303e:	48 89 c1             	mov    rcx,rax
  403041:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  403045:	0f 85 da 00 00 00    	jne    403125 <sched_thd_block+0x435>
  40304b:	f0 49 0f b1 1c 24    	lock cmpxchg QWORD PTR [r12],rbx
  403051:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  403054:	84 c0                	test   al,al
  403056:	0f 85 7c fd ff ff    	jne    402dd8 <sched_thd_block+0xe8>
  40305c:	eb d4                	jmp    403032 <sched_thd_block+0x342>
  40305e:	66 90                	xchg   ax,ax
  403060:	0f 01 f9             	rdtscp 
	return t != &g->idle_thd && t != &g->sched_thd;
  403063:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  403069:	48 8d 04 89          	lea    rax,[rcx+rcx*4]
  40306d:	48 c1 e0 06          	shl    rax,0x6
  403071:	48 8d 90 80 65 71 00 	lea    rdx,[rax+0x716580]
  403078:	49 39 d4             	cmp    r12,rdx
  40307b:	74 61                	je     4030de <sched_thd_block+0x3ee>
  40307d:	48 05 08 65 71 00    	add    rax,0x716508
  403083:	49 39 c4             	cmp    r12,rax
  403086:	74 56                	je     4030de <sched_thd_block+0x3ee>
  403088:	be 61 00 00 00       	mov    esi,0x61
  40308d:	bf 50 d2 41 00       	mov    edi,0x41d250
  403092:	e8 e9 7b 00 00       	call   40ac80 <cos_print_str>
		assert(ret != -EPERM);
  403097:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40309e:	00 00 00 00 
  4030a2:	0f 0b                	ud2    
	if (dep_id) return -1;
  4030a4:	41 bd ff ff ff ff    	mov    r13d,0xffffffff
  4030aa:	e9 fe fd ff ff       	jmp    402ead <sched_thd_block+0x1bd>
			prio    = curr->priority;
  4030af:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
			timeout = TCAP_TIME_NIL;
  4030b3:	31 c9                	xor    ecx,ecx
  4030b5:	e9 fa fe ff ff       	jmp    402fb4 <sched_thd_block+0x2c4>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  4030ba:	4b 8d 04 b6          	lea    rax,[r14+r14*4]
  4030be:	49 8b 7c 24 28       	mov    rdi,QWORD PTR [r12+0x28]
  4030c3:	44 89 f9             	mov    ecx,r15d
  4030c6:	4c 89 ce             	mov    rsi,r9
  4030c9:	48 c1 e0 06          	shl    rax,0x6
  4030cd:	48 8b 90 28 65 71 00 	mov    rdx,QWORD PTR [rax+0x716528]
  4030d4:	e8 c7 ea 00 00       	call   411ba0 <cos_sched_asnd>
  4030d9:	e9 10 ff ff ff       	jmp    402fee <sched_thd_block+0x2fe>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  4030de:	4b 8d 04 b6          	lea    rax,[r14+r14*4]
  4030e2:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]
  4030e6:	45 89 f9             	mov    r9d,r15d
  4030e9:	31 c9                	xor    ecx,ecx
  4030eb:	48 c1 e0 06          	shl    rax,0x6
  4030ef:	31 f6                	xor    esi,esi
  4030f1:	4c 8b 80 28 65 71 00 	mov    r8,QWORD PTR [rax+0x716528]
  4030f8:	48 8b b8 18 65 71 00 	mov    rdi,QWORD PTR [rax+0x716518]
  4030ff:	e8 2c ea 00 00       	call   411b30 <cos_switch>
  403104:	e9 e5 fe ff ff       	jmp    402fee <sched_thd_block+0x2fe>
  403109:	be 61 00 00 00       	mov    esi,0x61
  40310e:	bf b8 d2 41 00       	mov    edi,0x41d2b8
  403113:	e8 68 7b 00 00       	call   40ac80 <cos_print_str>
		assert(ret != -EINVAL);
  403118:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40311f:	00 00 00 00 
  403123:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  403125:	41 89 c0             	mov    r8d,eax
  403128:	48 89 da             	mov    rdx,rbx
  40312b:	48 89 c6             	mov    rsi,rax
  40312e:	4c 89 e7             	mov    rdi,r12
  403131:	41 83 e0 01          	and    r8d,0x1
  403135:	e8 06 1f 01 00       	call   415040 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  40313a:	83 f8 f0             	cmp    eax,0xfffffff0
  40313d:	0f 85 ef fe ff ff    	jne    403032 <sched_thd_block+0x342>
  403143:	e9 16 fe ff ff       	jmp    402f5e <sched_thd_block+0x26e>
  403148:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40314f:	00 
  403150:	be 61 00 00 00       	mov    esi,0x61
  403155:	bf 20 d3 41 00       	mov    edi,0x41d320
  40315a:	e8 21 7b 00 00       	call   40ac80 <cos_print_str>
		assert(ret == -EAGAIN);
  40315f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403166:	00 00 00 00 
  40316a:	0f 0b                	ud2    
	ret = slm_thd_activate(curr, t, tok, 0);
  40316c:	41 bd f0 ff ff ff    	mov    r13d,0xfffffff0
  403172:	e9 36 fd ff ff       	jmp    402ead <sched_thd_block+0x1bd>
  403177:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40317e:	00 00 

0000000000403180 <thd_wakeup>:
{
  403180:	f3 0f 1e fa          	endbr64 
  403184:	55                   	push   rbp
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  403185:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  403188:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  40318e:	48 89 e5             	mov    rbp,rsp
  403191:	41 57                	push   r15
  403193:	41 56                	push   r14
  403195:	41 55                	push   r13
  403197:	41 54                	push   r12
  403199:	53                   	push   rbx
  40319a:	48 83 ec 18          	sub    rsp,0x18
  40319e:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  4031a5:	48 85 c0             	test   rax,rax
  4031a8:	0f 84 02 02 00 00    	je     4033b0 <thd_wakeup+0x230>
  4031ae:	83 e8 01             	sub    eax,0x1
  4031b1:	3d c7 00 00 00       	cmp    eax,0xc7
  4031b6:	0f 87 f4 01 00 00    	ja     4033b0 <thd_wakeup+0x230>
  4031bc:	48 8b 14 c5 20 f7 5b 	mov    rdx,QWORD PTR [rax*8+0x5bf720]
  4031c3:	00 
  4031c4:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  4031cb:	0f 84 df 01 00 00    	je     4033b0 <thd_wakeup+0x230>
  4031d1:	83 e2 01             	and    edx,0x1
  4031d4:	0f 85 d6 01 00 00    	jne    4033b0 <thd_wakeup+0x230>
  4031da:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  4031de:	49 89 fd             	mov    r13,rdi
  4031e1:	4c 8d 24 50          	lea    r12,[rax+rdx*2]
  4031e5:	49 c1 e4 04          	shl    r12,0x4
  4031e9:	49 81 c4 60 fd 5b 00 	add    r12,0x5bfd60
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  4031f0:	0f 01 f9             	rdtscp 
	cs = &(slm_global()->lock);
  4031f3:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  4031f9:	48 8d 1c 89          	lea    rbx,[rcx+rcx*4]
  4031fd:	48 c1 e3 06          	shl    rbx,0x6
  403201:	48 81 c3 00 65 71 00 	add    rbx,0x716500
		tok    = cos_sched_sync();
  403208:	e8 03 e9 00 00       	call   411b10 <cos_sched_sync>
  40320d:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  403210:	48 8b 03             	mov    rax,QWORD PTR [rbx]
		if (unlikely(owner)) {
  403213:	48 89 c1             	mov    rcx,rax
  403216:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  40321a:	0f 85 b0 01 00 00    	jne    4033d0 <thd_wakeup+0x250>
  403220:	f0 4c 0f b1 23       	lock cmpxchg QWORD PTR [rbx],r12
  403225:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  403228:	84 c0                	test   al,al
  40322a:	74 dc                	je     403208 <thd_wakeup+0x88>
	ret = slm_thd_wakeup(t, 0);
  40322c:	31 f6                	xor    esi,esi
  40322e:	4c 89 ef             	mov    rdi,r13
  403231:	e8 6a 25 01 00       	call   4157a0 <slm_thd_wakeup>
  403236:	41 89 c7             	mov    r15d,eax
	if (ret < 0) {
  403239:	85 c0                	test   eax,eax
  40323b:	0f 88 0f 01 00 00    	js     403350 <thd_wakeup+0x1d0>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  403241:	e8 0a 83 00 00       	call   40b550 <cos_defcompinfo_curr_get>
  403246:	0f 01 f9             	rdtscp 
	if (unlikely(!t)) t = &g->idle_thd;
  403249:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  40324f:	4c 8d 2c 89          	lea    r13,[rcx+rcx*4]
  403253:	49 c1 e5 06          	shl    r13,0x6
  403257:	49 8d 85 80 65 71 00 	lea    rax,[r13+0x716580]
  40325e:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
	tok  = cos_sched_sync();
  403262:	e8 a9 e8 00 00       	call   411b10 <cos_sched_sync>
  403267:	41 89 c6             	mov    r14d,eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  40326a:	e8 31 09 01 00       	call   413ba0 <slm_sched_fprr_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  40326f:	48 85 c0             	test   rax,rax
  403272:	48 89 c3             	mov    rbx,rax
  403275:	48 0f 44 5d c8       	cmove  rbx,QWORD PTR [rbp-0x38]
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  40327a:	8b 43 04             	mov    eax,DWORD PTR [rbx+0x4]
  40327d:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  403280:	83 f8 01             	cmp    eax,0x1
  403283:	0f 87 81 01 00 00    	ja     40340a <thd_wakeup+0x28a>
  403289:	0f 01 f9             	rdtscp 
	struct slm_cs *cs = &(slm_global()->lock);
  40328c:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  403292:	4c 8d 3c 89          	lea    r15,[rcx+rcx*4]
  403296:	49 c1 e7 06          	shl    r15,0x6
  40329a:	49 81 c7 00 65 71 00 	add    r15,0x716500
	while (ret != 0) {
  4032a1:	eb 11                	jmp    4032b4 <thd_wakeup+0x134>
  4032a3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  4032a8:	f0 49 0f b1 17       	lock cmpxchg QWORD PTR [r15],rdx
  4032ad:	0f 94 c0             	sete   al
  4032b0:	84 c0                	test   al,al
  4032b2:	75 28                	jne    4032dc <thd_wakeup+0x15c>
		tok    = cos_sched_sync();
  4032b4:	e8 57 e8 00 00       	call   411b10 <cos_sched_sync>
  4032b9:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4032bb:	49 8b 07             	mov    rax,QWORD PTR [r15]
		if (unlikely(contention)) {
  4032be:	48 89 c2             	mov    rdx,rax
  4032c1:	83 e2 01             	and    edx,0x1
  4032c4:	74 e2                	je     4032a8 <thd_wakeup+0x128>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  4032c6:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  4032c9:	48 89 c2             	mov    rdx,rax
  4032cc:	4c 89 ff             	mov    rdi,r15
  4032cf:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  4032d3:	e8 c8 1d 01 00       	call   4150a0 <slm_cs_exit_contention>
  4032d8:	85 c0                	test   eax,eax
  4032da:	75 d8                	jne    4032b4 <thd_wakeup+0x134>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  4032dc:	e8 6f 82 00 00       	call   40b550 <cos_defcompinfo_curr_get>
  4032e1:	0f 01 f9             	rdtscp 
	*coreid = c & 0xFFF;
  4032e4:	89 ca                	mov    edx,ecx
	timeout = g->timeout_next;
  4032e6:	81 e1 ff 0f 00 00    	and    ecx,0xfff
	prio = inherit_prio ? curr->priority : t->priority;
  4032ec:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
	timeout = g->timeout_next;
  4032f0:	48 8d 04 89          	lea    rax,[rcx+rcx*4]
  4032f4:	66 81 e2 ff 0f       	and    dx,0xfff
  4032f9:	49 89 cd             	mov    r13,rcx
  4032fc:	48 c1 e0 06          	shl    rax,0x6
  403300:	4c 8b 88 08 66 71 00 	mov    r9,QWORD PTR [rax+0x716608]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  403307:	8b 03                	mov    eax,DWORD PTR [rbx]
  403309:	a8 0b                	test   al,0xb
  40330b:	0f 85 15 01 00 00    	jne    403426 <thd_wakeup+0x2a6>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  403311:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  403315:	44 89 f1             	mov    ecx,r14d
  403318:	4c 89 ca             	mov    rdx,r9
  40331b:	e8 80 93 00 00       	call   40c6a0 <cos_defswitch>
  403320:	41 89 c7             	mov    r15d,eax
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  403323:	83 f8 ff             	cmp    eax,0xffffffff
  403326:	0f 84 cc 01 00 00    	je     4034f8 <thd_wakeup+0x378>
	if (unlikely(ret != 0)) {
  40332c:	85 c0                	test   eax,eax
  40332e:	0f 85 5f 01 00 00    	jne    403493 <thd_wakeup+0x313>
  403334:	45 31 ff             	xor    r15d,r15d
}
  403337:	48 83 c4 18          	add    rsp,0x18
  40333b:	44 89 f8             	mov    eax,r15d
  40333e:	5b                   	pop    rbx
  40333f:	41 5c                	pop    r12
  403341:	41 5d                	pop    r13
  403343:	41 5e                	pop    r14
  403345:	41 5f                	pop    r15
  403347:	5d                   	pop    rbp
  403348:	c3                   	ret    
  403349:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  403350:	0f 01 f9             	rdtscp 
	struct slm_cs *cs = &(slm_global()->lock);
  403353:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  403359:	48 8d 1c 89          	lea    rbx,[rcx+rcx*4]
  40335d:	48 c1 e3 06          	shl    rbx,0x6
  403361:	48 81 c3 00 65 71 00 	add    rbx,0x716500
	while (ret != 0) {
  403368:	eb 12                	jmp    40337c <thd_wakeup+0x1fc>
  40336a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  403370:	f0 48 0f b1 13       	lock cmpxchg QWORD PTR [rbx],rdx
  403375:	0f 94 c0             	sete   al
  403378:	84 c0                	test   al,al
  40337a:	75 bb                	jne    403337 <thd_wakeup+0x1b7>
		tok    = cos_sched_sync();
  40337c:	e8 8f e7 00 00       	call   411b10 <cos_sched_sync>
  403381:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  403383:	48 8b 03             	mov    rax,QWORD PTR [rbx]
		if (unlikely(contention)) {
  403386:	48 89 c2             	mov    rdx,rax
  403389:	83 e2 01             	and    edx,0x1
  40338c:	74 e2                	je     403370 <thd_wakeup+0x1f0>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  40338e:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  403391:	48 89 c2             	mov    rdx,rax
  403394:	48 89 df             	mov    rdi,rbx
  403397:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  40339b:	e8 00 1d 01 00       	call   4150a0 <slm_cs_exit_contention>
  4033a0:	85 c0                	test   eax,eax
  4033a2:	74 93                	je     403337 <thd_wakeup+0x1b7>
  4033a4:	eb d6                	jmp    40337c <thd_wakeup+0x1fc>
  4033a6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4033ad:	00 00 00 
  4033b0:	be 59 00 00 00       	mov    esi,0x59
  4033b5:	bf 00 d1 41 00       	mov    edi,0x41d100
  4033ba:	e8 c1 78 00 00       	call   40ac80 <cos_print_str>
	assert(current);
  4033bf:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4033c6:	00 00 00 00 
  4033ca:	0f 0b                	ud2    
  4033cc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  4033d0:	41 89 c0             	mov    r8d,eax
  4033d3:	4c 89 e2             	mov    rdx,r12
  4033d6:	48 89 c6             	mov    rsi,rax
  4033d9:	48 89 df             	mov    rdi,rbx
  4033dc:	41 83 e0 01          	and    r8d,0x1
  4033e0:	e8 5b 1c 01 00       	call   415040 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  4033e5:	83 f8 f0             	cmp    eax,0xfffffff0
  4033e8:	0f 85 1a fe ff ff    	jne    403208 <thd_wakeup+0x88>
  4033ee:	be 59 00 00 00       	mov    esi,0x59
  4033f3:	bf 60 d1 41 00       	mov    edi,0x41d160
  4033f8:	e8 83 78 00 00       	call   40ac80 <cos_print_str>
  4033fd:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403404:	00 00 00 00 
  403408:	0f 0b                	ud2    
  40340a:	be 61 00 00 00       	mov    esi,0x61
  40340f:	bf e8 d1 41 00       	mov    edi,0x41d1e8
  403414:	e8 67 78 00 00       	call   40ac80 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  403419:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403420:	00 00 00 00 
  403424:	0f 0b                	ud2    
		if (t == &g->sched_thd) {
  403426:	0f b7 d2             	movzx  edx,dx
	timeout = g->timeout_next;
  403429:	4c 89 c9             	mov    rcx,r9
		if (t == &g->sched_thd) {
  40342c:	48 8d 14 92          	lea    rdx,[rdx+rdx*4]
  403430:	48 c1 e2 06          	shl    rdx,0x6
  403434:	48 81 c2 08 65 71 00 	add    rdx,0x716508
  40343b:	48 39 d3             	cmp    rbx,rdx
  40343e:	0f 84 f8 00 00 00    	je     40353c <thd_wakeup+0x3bc>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  403444:	a8 02                	test   al,0x2
  403446:	0f 85 2c 01 00 00    	jne    403578 <thd_wakeup+0x3f8>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  40344c:	49 89 c9             	mov    r9,rcx
  40344f:	a8 01                	test   al,0x1
  403451:	0f 84 ba fe ff ff    	je     403311 <thd_wakeup+0x191>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  403457:	4b 8d 44 ad 00       	lea    rax,[r13+r13*4+0x0]
  40345c:	4c 8b 53 08          	mov    r10,QWORD PTR [rbx+0x8]
  403460:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  403464:	48 89 f2             	mov    rdx,rsi
  403467:	48 c1 e0 06          	shl    rax,0x6
  40346b:	45 89 f1             	mov    r9d,r14d
  40346e:	4c 8b 80 28 65 71 00 	mov    r8,QWORD PTR [rax+0x716528]
  403475:	4c 89 d6             	mov    rsi,r10
  403478:	e8 b3 e6 00 00       	call   411b30 <cos_switch>
  40347d:	41 89 c7             	mov    r15d,eax
	if (unlikely(ret != 0)) {
  403480:	45 85 ff             	test   r15d,r15d
  403483:	0f 84 ab fe ff ff    	je     403334 <thd_wakeup+0x1b4>
		assert(ret != -EPERM);
  403489:	41 83 ff ff          	cmp    r15d,0xffffffff
  40348d:	0f 84 8d 00 00 00    	je     403520 <thd_wakeup+0x3a0>
		assert(ret != -EINVAL);
  403493:	41 83 ff ea          	cmp    r15d,0xffffffea
  403497:	0f 84 02 01 00 00    	je     40359f <thd_wakeup+0x41f>
		if (ret == -EBUSY) return ret;
  40349d:	41 83 ff f0          	cmp    r15d,0xfffffff0
  4034a1:	0f 84 90 fe ff ff    	je     403337 <thd_wakeup+0x1b7>
		assert(ret == -EAGAIN);
  4034a7:	41 83 ff f5          	cmp    r15d,0xfffffff5
  4034ab:	0f 85 2f 01 00 00    	jne    4035e0 <thd_wakeup+0x460>
  4034b1:	0f 01 f9             	rdtscp 
	cs = &(slm_global()->lock);
  4034b4:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  4034ba:	48 8d 1c 89          	lea    rbx,[rcx+rcx*4]
  4034be:	48 c1 e3 06          	shl    rbx,0x6
  4034c2:	48 81 c3 00 65 71 00 	add    rbx,0x716500
		tok    = cos_sched_sync();
  4034c9:	e8 42 e6 00 00       	call   411b10 <cos_sched_sync>
  4034ce:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4034d1:	48 8b 03             	mov    rax,QWORD PTR [rbx]
		if (unlikely(owner)) {
  4034d4:	48 89 c1             	mov    rcx,rax
  4034d7:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  4034db:	0f 85 da 00 00 00    	jne    4035bb <thd_wakeup+0x43b>
  4034e1:	f0 4c 0f b1 23       	lock cmpxchg QWORD PTR [rbx],r12
  4034e6:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4034e9:	84 c0                	test   al,al
  4034eb:	0f 85 71 fd ff ff    	jne    403262 <thd_wakeup+0xe2>
  4034f1:	eb d6                	jmp    4034c9 <thd_wakeup+0x349>
  4034f3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  4034f8:	0f 01 f9             	rdtscp 
	return t != &g->idle_thd && t != &g->sched_thd;
  4034fb:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  403501:	48 8d 04 89          	lea    rax,[rcx+rcx*4]
  403505:	48 c1 e0 06          	shl    rax,0x6
  403509:	48 8d 90 80 65 71 00 	lea    rdx,[rax+0x716580]
  403510:	48 39 d3             	cmp    rbx,rdx
  403513:	74 33                	je     403548 <thd_wakeup+0x3c8>
  403515:	48 05 08 65 71 00    	add    rax,0x716508
  40351b:	48 39 c3             	cmp    rbx,rax
  40351e:	74 28                	je     403548 <thd_wakeup+0x3c8>
  403520:	be 61 00 00 00       	mov    esi,0x61
  403525:	bf 50 d2 41 00       	mov    edi,0x41d250
  40352a:	e8 51 77 00 00       	call   40ac80 <cos_print_str>
		assert(ret != -EPERM);
  40352f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403536:	00 00 00 00 
  40353a:	0f 0b                	ud2    
			prio    = curr->priority;
  40353c:	49 8b 74 24 30       	mov    rsi,QWORD PTR [r12+0x30]
			timeout = TCAP_TIME_NIL;
  403541:	31 c9                	xor    ecx,ecx
  403543:	e9 fc fe ff ff       	jmp    403444 <thd_wakeup+0x2c4>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  403548:	4b 8d 44 ad 00       	lea    rax,[r13+r13*4+0x0]
  40354d:	49 8b 54 24 30       	mov    rdx,QWORD PTR [r12+0x30]
  403552:	45 89 f1             	mov    r9d,r14d
  403555:	31 c9                	xor    ecx,ecx
  403557:	48 c1 e0 06          	shl    rax,0x6
  40355b:	31 f6                	xor    esi,esi
  40355d:	4c 8b 80 28 65 71 00 	mov    r8,QWORD PTR [rax+0x716528]
  403564:	48 8b b8 18 65 71 00 	mov    rdi,QWORD PTR [rax+0x716518]
  40356b:	e8 c0 e5 00 00       	call   411b30 <cos_switch>
  403570:	41 89 c7             	mov    r15d,eax
  403573:	e9 08 ff ff ff       	jmp    403480 <thd_wakeup+0x300>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  403578:	4b 8d 44 ad 00       	lea    rax,[r13+r13*4+0x0]
  40357d:	48 8b 7b 28          	mov    rdi,QWORD PTR [rbx+0x28]
  403581:	44 89 f1             	mov    ecx,r14d
  403584:	4c 89 ce             	mov    rsi,r9
  403587:	48 c1 e0 06          	shl    rax,0x6
  40358b:	48 8b 90 28 65 71 00 	mov    rdx,QWORD PTR [rax+0x716528]
  403592:	e8 09 e6 00 00       	call   411ba0 <cos_sched_asnd>
  403597:	41 89 c7             	mov    r15d,eax
  40359a:	e9 e1 fe ff ff       	jmp    403480 <thd_wakeup+0x300>
  40359f:	be 61 00 00 00       	mov    esi,0x61
  4035a4:	bf b8 d2 41 00       	mov    edi,0x41d2b8
  4035a9:	e8 d2 76 00 00       	call   40ac80 <cos_print_str>
		assert(ret != -EINVAL);
  4035ae:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4035b5:	00 00 00 00 
  4035b9:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  4035bb:	41 89 c0             	mov    r8d,eax
  4035be:	4c 89 e2             	mov    rdx,r12
  4035c1:	48 89 c6             	mov    rsi,rax
  4035c4:	48 89 df             	mov    rdi,rbx
  4035c7:	41 83 e0 01          	and    r8d,0x1
  4035cb:	e8 70 1a 01 00       	call   415040 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  4035d0:	83 f8 f0             	cmp    eax,0xfffffff0
  4035d3:	0f 85 f0 fe ff ff    	jne    4034c9 <thd_wakeup+0x349>
  4035d9:	e9 10 fe ff ff       	jmp    4033ee <thd_wakeup+0x26e>
  4035de:	66 90                	xchg   ax,ax
  4035e0:	be 61 00 00 00       	mov    esi,0x61
  4035e5:	bf 20 d3 41 00       	mov    edi,0x41d320
  4035ea:	e8 91 76 00 00       	call   40ac80 <cos_print_str>
		assert(ret == -EAGAIN);
  4035ef:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4035f6:	00 00 00 00 
  4035fa:	0f 0b                	ud2    
  4035fc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000403600 <sched_thd_wakeup>:
{
  403600:	f3 0f 1e fa          	endbr64 
  403604:	55                   	push   rbp
  403605:	48 89 e5             	mov    rbp,rsp
  403608:	41 57                	push   r15
  40360a:	41 56                	push   r14
  40360c:	41 55                	push   r13
  40360e:	41 54                	push   r12
  403610:	53                   	push   rbx
  403611:	48 83 ec 18          	sub    rsp,0x18
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403615:	85 ff                	test   edi,edi
  403617:	74 1e                	je     403637 <sched_thd_wakeup+0x37>
  403619:	83 ef 01             	sub    edi,0x1
  40361c:	81 ff c7 00 00 00    	cmp    edi,0xc7
  403622:	77 13                	ja     403637 <sched_thd_wakeup+0x37>
  403624:	89 f8                	mov    eax,edi
  403626:	48 8b 14 c5 20 f7 5b 	mov    rdx,QWORD PTR [rax*8+0x5bf720]
  40362d:	00 
  40362e:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  403635:	75 19                	jne    403650 <sched_thd_wakeup+0x50>
	if (!t) return -1;
  403637:	41 bf ff ff ff ff    	mov    r15d,0xffffffff
}
  40363d:	48 83 c4 18          	add    rsp,0x18
  403641:	44 89 f8             	mov    eax,r15d
  403644:	5b                   	pop    rbx
  403645:	41 5c                	pop    r12
  403647:	41 5d                	pop    r13
  403649:	41 5e                	pop    r14
  40364b:	41 5f                	pop    r15
  40364d:	5d                   	pop    rbp
  40364e:	c3                   	ret    
  40364f:	90                   	nop
  403650:	83 e2 01             	and    edx,0x1
  403653:	75 e2                	jne    403637 <sched_thd_wakeup+0x37>
	return &ss_thd_get(id)->thd;
  403655:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  403659:	4c 8d 2c 50          	lea    r13,[rax+rdx*2]
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  40365d:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  403660:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  403666:	49 c1 e5 04          	shl    r13,0x4
  40366a:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
  403671:	49 81 c5 60 fd 5b 00 	add    r13,0x5bfd60
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403678:	48 85 c0             	test   rax,rax
  40367b:	74 1b                	je     403698 <sched_thd_wakeup+0x98>
  40367d:	83 e8 01             	sub    eax,0x1
  403680:	3d c7 00 00 00       	cmp    eax,0xc7
  403685:	77 11                	ja     403698 <sched_thd_wakeup+0x98>
  403687:	48 8b 14 c5 20 f7 5b 	mov    rdx,QWORD PTR [rax*8+0x5bf720]
  40368e:	00 
  40368f:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  403696:	75 20                	jne    4036b8 <sched_thd_wakeup+0xb8>
  403698:	be 59 00 00 00       	mov    esi,0x59
  40369d:	bf 00 d1 41 00       	mov    edi,0x41d100
  4036a2:	e8 d9 75 00 00       	call   40ac80 <cos_print_str>
	assert(current);
  4036a7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4036ae:	00 00 00 00 
  4036b2:	0f 0b                	ud2    
  4036b4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  4036b8:	83 e2 01             	and    edx,0x1
  4036bb:	75 db                	jne    403698 <sched_thd_wakeup+0x98>
  4036bd:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  4036c1:	4c 8d 24 50          	lea    r12,[rax+rdx*2]
  4036c5:	49 c1 e4 04          	shl    r12,0x4
  4036c9:	49 81 c4 60 fd 5b 00 	add    r12,0x5bfd60
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  4036d0:	0f 01 f9             	rdtscp 
	cs = &(slm_global()->lock);
  4036d3:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  4036d9:	48 8d 1c 89          	lea    rbx,[rcx+rcx*4]
  4036dd:	48 c1 e3 06          	shl    rbx,0x6
  4036e1:	48 81 c3 00 65 71 00 	add    rbx,0x716500
		tok    = cos_sched_sync();
  4036e8:	e8 23 e4 00 00       	call   411b10 <cos_sched_sync>
  4036ed:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4036f0:	48 8b 03             	mov    rax,QWORD PTR [rbx]
		if (unlikely(owner)) {
  4036f3:	48 89 c1             	mov    rcx,rax
  4036f6:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  4036fa:	0f 85 80 01 00 00    	jne    403880 <sched_thd_wakeup+0x280>
  403700:	f0 4c 0f b1 23       	lock cmpxchg QWORD PTR [rbx],r12
  403705:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  403708:	84 c0                	test   al,al
  40370a:	74 dc                	je     4036e8 <sched_thd_wakeup+0xe8>
	ret = slm_thd_wakeup(t, 0);
  40370c:	31 f6                	xor    esi,esi
  40370e:	4c 89 ef             	mov    rdi,r13
  403711:	e8 8a 20 01 00       	call   4157a0 <slm_thd_wakeup>
  403716:	41 89 c7             	mov    r15d,eax
	if (ret < 0) {
  403719:	85 c0                	test   eax,eax
  40371b:	0f 88 ff 00 00 00    	js     403820 <sched_thd_wakeup+0x220>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  403721:	e8 2a 7e 00 00       	call   40b550 <cos_defcompinfo_curr_get>
  403726:	0f 01 f9             	rdtscp 
	if (unlikely(!t)) t = &g->idle_thd;
  403729:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  40372f:	4c 8d 2c 89          	lea    r13,[rcx+rcx*4]
  403733:	49 c1 e5 06          	shl    r13,0x6
  403737:	49 8d 85 80 65 71 00 	lea    rax,[r13+0x716580]
  40373e:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
	tok  = cos_sched_sync();
  403742:	e8 c9 e3 00 00       	call   411b10 <cos_sched_sync>
  403747:	41 89 c6             	mov    r14d,eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  40374a:	e8 51 04 01 00       	call   413ba0 <slm_sched_fprr_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  40374f:	48 85 c0             	test   rax,rax
  403752:	48 89 c3             	mov    rbx,rax
  403755:	48 0f 44 5d c8       	cmove  rbx,QWORD PTR [rbp-0x38]
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  40375a:	8b 43 04             	mov    eax,DWORD PTR [rbx+0x4]
  40375d:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  403760:	83 f8 01             	cmp    eax,0x1
  403763:	0f 87 51 01 00 00    	ja     4038ba <sched_thd_wakeup+0x2ba>
  403769:	0f 01 f9             	rdtscp 
	struct slm_cs *cs = &(slm_global()->lock);
  40376c:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  403772:	4c 8d 3c 89          	lea    r15,[rcx+rcx*4]
  403776:	49 c1 e7 06          	shl    r15,0x6
  40377a:	49 81 c7 00 65 71 00 	add    r15,0x716500
	while (ret != 0) {
  403781:	eb 11                	jmp    403794 <sched_thd_wakeup+0x194>
  403783:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  403788:	f0 49 0f b1 17       	lock cmpxchg QWORD PTR [r15],rdx
  40378d:	0f 94 c0             	sete   al
  403790:	84 c0                	test   al,al
  403792:	75 28                	jne    4037bc <sched_thd_wakeup+0x1bc>
		tok    = cos_sched_sync();
  403794:	e8 77 e3 00 00       	call   411b10 <cos_sched_sync>
  403799:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  40379b:	49 8b 07             	mov    rax,QWORD PTR [r15]
		if (unlikely(contention)) {
  40379e:	48 89 c2             	mov    rdx,rax
  4037a1:	83 e2 01             	and    edx,0x1
  4037a4:	74 e2                	je     403788 <sched_thd_wakeup+0x188>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  4037a6:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  4037a9:	48 89 c2             	mov    rdx,rax
  4037ac:	4c 89 ff             	mov    rdi,r15
  4037af:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  4037b3:	e8 e8 18 01 00       	call   4150a0 <slm_cs_exit_contention>
  4037b8:	85 c0                	test   eax,eax
  4037ba:	75 d8                	jne    403794 <sched_thd_wakeup+0x194>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  4037bc:	e8 8f 7d 00 00       	call   40b550 <cos_defcompinfo_curr_get>
  4037c1:	0f 01 f9             	rdtscp 
	*coreid = c & 0xFFF;
  4037c4:	89 ca                	mov    edx,ecx
	timeout = g->timeout_next;
  4037c6:	81 e1 ff 0f 00 00    	and    ecx,0xfff
	prio = inherit_prio ? curr->priority : t->priority;
  4037cc:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
	timeout = g->timeout_next;
  4037d0:	48 8d 04 89          	lea    rax,[rcx+rcx*4]
  4037d4:	66 81 e2 ff 0f       	and    dx,0xfff
  4037d9:	49 89 cd             	mov    r13,rcx
  4037dc:	48 c1 e0 06          	shl    rax,0x6
  4037e0:	4c 8b 88 08 66 71 00 	mov    r9,QWORD PTR [rax+0x716608]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4037e7:	8b 03                	mov    eax,DWORD PTR [rbx]
  4037e9:	a8 0b                	test   al,0xb
  4037eb:	0f 85 e5 00 00 00    	jne    4038d6 <sched_thd_wakeup+0x2d6>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  4037f1:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  4037f5:	44 89 f1             	mov    ecx,r14d
  4037f8:	4c 89 ca             	mov    rdx,r9
  4037fb:	e8 a0 8e 00 00       	call   40c6a0 <cos_defswitch>
  403800:	41 89 c7             	mov    r15d,eax
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  403803:	83 f8 ff             	cmp    eax,0xffffffff
  403806:	0f 84 9c 01 00 00    	je     4039a8 <sched_thd_wakeup+0x3a8>
	if (unlikely(ret != 0)) {
  40380c:	85 c0                	test   eax,eax
  40380e:	0f 85 2f 01 00 00    	jne    403943 <sched_thd_wakeup+0x343>
	if (!t) return -1;
  403814:	45 31 ff             	xor    r15d,r15d
  403817:	e9 21 fe ff ff       	jmp    40363d <sched_thd_wakeup+0x3d>
  40381c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  403820:	0f 01 f9             	rdtscp 
	struct slm_cs *cs = &(slm_global()->lock);
  403823:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  403829:	48 8d 1c 89          	lea    rbx,[rcx+rcx*4]
  40382d:	48 c1 e3 06          	shl    rbx,0x6
  403831:	48 81 c3 00 65 71 00 	add    rbx,0x716500
	while (ret != 0) {
  403838:	eb 16                	jmp    403850 <sched_thd_wakeup+0x250>
  40383a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  403840:	f0 48 0f b1 13       	lock cmpxchg QWORD PTR [rbx],rdx
  403845:	0f 94 c0             	sete   al
  403848:	84 c0                	test   al,al
  40384a:	0f 85 ed fd ff ff    	jne    40363d <sched_thd_wakeup+0x3d>
		tok    = cos_sched_sync();
  403850:	e8 bb e2 00 00       	call   411b10 <cos_sched_sync>
  403855:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  403857:	48 8b 03             	mov    rax,QWORD PTR [rbx]
		if (unlikely(contention)) {
  40385a:	48 89 c2             	mov    rdx,rax
  40385d:	83 e2 01             	and    edx,0x1
  403860:	74 de                	je     403840 <sched_thd_wakeup+0x240>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  403862:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  403865:	48 89 c2             	mov    rdx,rax
  403868:	48 89 df             	mov    rdi,rbx
  40386b:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  40386f:	e8 2c 18 01 00       	call   4150a0 <slm_cs_exit_contention>
  403874:	85 c0                	test   eax,eax
  403876:	0f 84 c1 fd ff ff    	je     40363d <sched_thd_wakeup+0x3d>
  40387c:	eb d2                	jmp    403850 <sched_thd_wakeup+0x250>
  40387e:	66 90                	xchg   ax,ax
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  403880:	41 89 c0             	mov    r8d,eax
  403883:	4c 89 e2             	mov    rdx,r12
  403886:	48 89 c6             	mov    rsi,rax
  403889:	48 89 df             	mov    rdi,rbx
  40388c:	41 83 e0 01          	and    r8d,0x1
  403890:	e8 ab 17 01 00       	call   415040 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  403895:	83 f8 f0             	cmp    eax,0xfffffff0
  403898:	0f 85 4a fe ff ff    	jne    4036e8 <sched_thd_wakeup+0xe8>
  40389e:	be 59 00 00 00       	mov    esi,0x59
  4038a3:	bf 60 d1 41 00       	mov    edi,0x41d160
  4038a8:	e8 d3 73 00 00       	call   40ac80 <cos_print_str>
  4038ad:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4038b4:	00 00 00 00 
  4038b8:	0f 0b                	ud2    
  4038ba:	be 61 00 00 00       	mov    esi,0x61
  4038bf:	bf e8 d1 41 00       	mov    edi,0x41d1e8
  4038c4:	e8 b7 73 00 00       	call   40ac80 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  4038c9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4038d0:	00 00 00 00 
  4038d4:	0f 0b                	ud2    
		if (t == &g->sched_thd) {
  4038d6:	0f b7 d2             	movzx  edx,dx
	timeout = g->timeout_next;
  4038d9:	4c 89 c9             	mov    rcx,r9
		if (t == &g->sched_thd) {
  4038dc:	48 8d 14 92          	lea    rdx,[rdx+rdx*4]
  4038e0:	48 c1 e2 06          	shl    rdx,0x6
  4038e4:	48 81 c2 08 65 71 00 	add    rdx,0x716508
  4038eb:	48 39 d3             	cmp    rbx,rdx
  4038ee:	0f 84 f8 00 00 00    	je     4039ec <sched_thd_wakeup+0x3ec>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  4038f4:	a8 02                	test   al,0x2
  4038f6:	0f 85 2c 01 00 00    	jne    403a28 <sched_thd_wakeup+0x428>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  4038fc:	49 89 c9             	mov    r9,rcx
  4038ff:	a8 01                	test   al,0x1
  403901:	0f 84 ea fe ff ff    	je     4037f1 <sched_thd_wakeup+0x1f1>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  403907:	4b 8d 44 ad 00       	lea    rax,[r13+r13*4+0x0]
  40390c:	4c 8b 53 08          	mov    r10,QWORD PTR [rbx+0x8]
  403910:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  403914:	48 89 f2             	mov    rdx,rsi
  403917:	48 c1 e0 06          	shl    rax,0x6
  40391b:	45 89 f1             	mov    r9d,r14d
  40391e:	4c 8b 80 28 65 71 00 	mov    r8,QWORD PTR [rax+0x716528]
  403925:	4c 89 d6             	mov    rsi,r10
  403928:	e8 03 e2 00 00       	call   411b30 <cos_switch>
  40392d:	41 89 c7             	mov    r15d,eax
	if (unlikely(ret != 0)) {
  403930:	45 85 ff             	test   r15d,r15d
  403933:	0f 84 db fe ff ff    	je     403814 <sched_thd_wakeup+0x214>
		assert(ret != -EPERM);
  403939:	41 83 ff ff          	cmp    r15d,0xffffffff
  40393d:	0f 84 8d 00 00 00    	je     4039d0 <sched_thd_wakeup+0x3d0>
		assert(ret != -EINVAL);
  403943:	41 83 ff ea          	cmp    r15d,0xffffffea
  403947:	0f 84 02 01 00 00    	je     403a4f <sched_thd_wakeup+0x44f>
		if (ret == -EBUSY) return ret;
  40394d:	41 83 ff f0          	cmp    r15d,0xfffffff0
  403951:	0f 84 e6 fc ff ff    	je     40363d <sched_thd_wakeup+0x3d>
		assert(ret == -EAGAIN);
  403957:	41 83 ff f5          	cmp    r15d,0xfffffff5
  40395b:	0f 85 2f 01 00 00    	jne    403a90 <sched_thd_wakeup+0x490>
  403961:	0f 01 f9             	rdtscp 
	cs = &(slm_global()->lock);
  403964:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  40396a:	48 8d 1c 89          	lea    rbx,[rcx+rcx*4]
  40396e:	48 c1 e3 06          	shl    rbx,0x6
  403972:	48 81 c3 00 65 71 00 	add    rbx,0x716500
		tok    = cos_sched_sync();
  403979:	e8 92 e1 00 00       	call   411b10 <cos_sched_sync>
  40397e:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  403981:	48 8b 03             	mov    rax,QWORD PTR [rbx]
		if (unlikely(owner)) {
  403984:	48 89 c1             	mov    rcx,rax
  403987:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  40398b:	0f 85 da 00 00 00    	jne    403a6b <sched_thd_wakeup+0x46b>
  403991:	f0 4c 0f b1 23       	lock cmpxchg QWORD PTR [rbx],r12
  403996:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  403999:	84 c0                	test   al,al
  40399b:	0f 85 a1 fd ff ff    	jne    403742 <sched_thd_wakeup+0x142>
  4039a1:	eb d6                	jmp    403979 <sched_thd_wakeup+0x379>
  4039a3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  4039a8:	0f 01 f9             	rdtscp 
	return t != &g->idle_thd && t != &g->sched_thd;
  4039ab:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  4039b1:	48 8d 04 89          	lea    rax,[rcx+rcx*4]
  4039b5:	48 c1 e0 06          	shl    rax,0x6
  4039b9:	48 8d 90 80 65 71 00 	lea    rdx,[rax+0x716580]
  4039c0:	48 39 d3             	cmp    rbx,rdx
  4039c3:	74 33                	je     4039f8 <sched_thd_wakeup+0x3f8>
  4039c5:	48 05 08 65 71 00    	add    rax,0x716508
  4039cb:	48 39 c3             	cmp    rbx,rax
  4039ce:	74 28                	je     4039f8 <sched_thd_wakeup+0x3f8>
  4039d0:	be 61 00 00 00       	mov    esi,0x61
  4039d5:	bf 50 d2 41 00       	mov    edi,0x41d250
  4039da:	e8 a1 72 00 00       	call   40ac80 <cos_print_str>
		assert(ret != -EPERM);
  4039df:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4039e6:	00 00 00 00 
  4039ea:	0f 0b                	ud2    
			prio    = curr->priority;
  4039ec:	49 8b 74 24 30       	mov    rsi,QWORD PTR [r12+0x30]
			timeout = TCAP_TIME_NIL;
  4039f1:	31 c9                	xor    ecx,ecx
  4039f3:	e9 fc fe ff ff       	jmp    4038f4 <sched_thd_wakeup+0x2f4>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  4039f8:	4b 8d 44 ad 00       	lea    rax,[r13+r13*4+0x0]
  4039fd:	49 8b 54 24 30       	mov    rdx,QWORD PTR [r12+0x30]
  403a02:	45 89 f1             	mov    r9d,r14d
  403a05:	31 c9                	xor    ecx,ecx
  403a07:	48 c1 e0 06          	shl    rax,0x6
  403a0b:	31 f6                	xor    esi,esi
  403a0d:	4c 8b 80 28 65 71 00 	mov    r8,QWORD PTR [rax+0x716528]
  403a14:	48 8b b8 18 65 71 00 	mov    rdi,QWORD PTR [rax+0x716518]
  403a1b:	e8 10 e1 00 00       	call   411b30 <cos_switch>
  403a20:	41 89 c7             	mov    r15d,eax
  403a23:	e9 08 ff ff ff       	jmp    403930 <sched_thd_wakeup+0x330>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  403a28:	4b 8d 44 ad 00       	lea    rax,[r13+r13*4+0x0]
  403a2d:	48 8b 7b 28          	mov    rdi,QWORD PTR [rbx+0x28]
  403a31:	44 89 f1             	mov    ecx,r14d
  403a34:	4c 89 ce             	mov    rsi,r9
  403a37:	48 c1 e0 06          	shl    rax,0x6
  403a3b:	48 8b 90 28 65 71 00 	mov    rdx,QWORD PTR [rax+0x716528]
  403a42:	e8 59 e1 00 00       	call   411ba0 <cos_sched_asnd>
  403a47:	41 89 c7             	mov    r15d,eax
  403a4a:	e9 e1 fe ff ff       	jmp    403930 <sched_thd_wakeup+0x330>
  403a4f:	be 61 00 00 00       	mov    esi,0x61
  403a54:	bf b8 d2 41 00       	mov    edi,0x41d2b8
  403a59:	e8 22 72 00 00       	call   40ac80 <cos_print_str>
		assert(ret != -EINVAL);
  403a5e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403a65:	00 00 00 00 
  403a69:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  403a6b:	41 89 c0             	mov    r8d,eax
  403a6e:	4c 89 e2             	mov    rdx,r12
  403a71:	48 89 c6             	mov    rsi,rax
  403a74:	48 89 df             	mov    rdi,rbx
  403a77:	41 83 e0 01          	and    r8d,0x1
  403a7b:	e8 c0 15 01 00       	call   415040 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  403a80:	83 f8 f0             	cmp    eax,0xfffffff0
  403a83:	0f 85 f0 fe ff ff    	jne    403979 <sched_thd_wakeup+0x379>
  403a89:	e9 10 fe ff ff       	jmp    40389e <sched_thd_wakeup+0x29e>
  403a8e:	66 90                	xchg   ax,ax
  403a90:	be 61 00 00 00       	mov    esi,0x61
  403a95:	bf 20 d3 41 00       	mov    edi,0x41d320
  403a9a:	e8 e1 71 00 00       	call   40ac80 <cos_print_str>
		assert(ret == -EAGAIN);
  403a9f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403aa6:	00 00 00 00 
  403aaa:	0f 0b                	ud2    
  403aac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000403ab0 <sched_debug_thd_state>:
{
  403ab0:	f3 0f 1e fa          	endbr64 
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403ab4:	85 ff                	test   edi,edi
  403ab6:	0f 84 7e 2e 01 00    	je     41693a <sched_debug_thd_state.cold>
  403abc:	83 ef 01             	sub    edi,0x1
  403abf:	81 ff c7 00 00 00    	cmp    edi,0xc7
  403ac5:	0f 87 6f 2e 01 00    	ja     41693a <sched_debug_thd_state.cold>
  403acb:	48 8b 04 fd 20 f7 5b 	mov    rax,QWORD PTR [rdi*8+0x5bf720]
  403ad2:	00 
  403ad3:	48 a9 fe ff ff ff    	test   rax,0xfffffffffffffffe
  403ad9:	0f 84 5b 2e 01 00    	je     41693a <sched_debug_thd_state.cold>
  403adf:	a8 01                	test   al,0x1
  403ae1:	0f 85 53 2e 01 00    	jne    41693a <sched_debug_thd_state.cold>
	return t->state;
  403ae7:	48 8d 04 bf          	lea    rax,[rdi+rdi*4]
  403aeb:	48 8d 04 47          	lea    rax,[rdi+rax*2]
  403aef:	48 c1 e0 04          	shl    rax,0x4
  403af3:	8b 80 64 fd 5b 00    	mov    eax,DWORD PTR [rax+0x5bfd64]
}
  403af9:	c3                   	ret    
  403afa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000403b00 <sched_thd_block_timeout>:
{
  403b00:	f3 0f 1e fa          	endbr64 
	if (dep_id) return 0;
  403b04:	48 85 ff             	test   rdi,rdi
  403b07:	74 07                	je     403b10 <sched_thd_block_timeout+0x10>
  403b09:	31 c0                	xor    eax,eax
}
  403b0b:	c3                   	ret    
  403b0c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
{
  403b10:	55                   	push   rbp
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  403b11:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  403b14:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  403b1a:	48 89 e5             	mov    rbp,rsp
  403b1d:	41 57                	push   r15
  403b1f:	41 56                	push   r14
  403b21:	49 89 f6             	mov    r14,rsi
  403b24:	41 55                	push   r13
  403b26:	41 54                	push   r12
  403b28:	53                   	push   rbx
  403b29:	48 83 ec 18          	sub    rsp,0x18
  403b2d:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403b34:	48 85 c0             	test   rax,rax
  403b37:	0f 84 e3 02 00 00    	je     403e20 <sched_thd_block_timeout+0x320>
  403b3d:	83 e8 01             	sub    eax,0x1
  403b40:	3d c7 00 00 00       	cmp    eax,0xc7
  403b45:	0f 87 d5 02 00 00    	ja     403e20 <sched_thd_block_timeout+0x320>
  403b4b:	48 8b 14 c5 20 f7 5b 	mov    rdx,QWORD PTR [rax*8+0x5bf720]
  403b52:	00 
  403b53:	45 31 ed             	xor    r13d,r13d
  403b56:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  403b5d:	0f 85 bd 01 00 00    	jne    403d20 <sched_thd_block_timeout+0x220>
static inline ps_tsc_t
ps_tsc(void)
{
	unsigned long a, d, c;

	__asm__ __volatile__("rdtsc" : "=a" (a), "=d" (d), "=c" (c) : : );
  403b63:	0f 31                	rdtsc  

	return ((u64_t)d << 32) | (u64_t)a;
  403b65:	48 c1 e2 20          	shl    rdx,0x20
  403b69:	48 09 c2             	or     rdx,rax
 * more than 2^63 into the future.
 */
static inline int
cycles_greater_than(cycles_t g, cycles_t l)
{
	return (s64_t)(g - l) > 0;
  403b6c:	4c 89 f0             	mov    rax,r14
  403b6f:	48 29 d0             	sub    rax,rdx
	while (cycles_greater_than(timeout, slm_now())) {
  403b72:	48 85 c0             	test   rax,rax
  403b75:	0f 8e 73 03 00 00    	jle    403eee <sched_thd_block_timeout+0x3ee>
	assert(current);
  403b7b:	4d 85 ed             	test   r13,r13
  403b7e:	0f 84 e6 02 00 00    	je     403e6a <sched_thd_block_timeout+0x36a>
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  403b84:	0f 01 f9             	rdtscp 
	cs = &(slm_global()->lock);
  403b87:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  403b8d:	48 8d 1c 89          	lea    rbx,[rcx+rcx*4]
  403b91:	48 c1 e3 06          	shl    rbx,0x6
  403b95:	48 81 c3 00 65 71 00 	add    rbx,0x716500
		tok    = cos_sched_sync();
  403b9c:	e8 6f df 00 00       	call   411b10 <cos_sched_sync>
  403ba1:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  403ba4:	48 8b 03             	mov    rax,QWORD PTR [rbx]
		if (unlikely(owner)) {
  403ba7:	48 89 c1             	mov    rcx,rax
  403baa:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  403bae:	0f 85 7c 02 00 00    	jne    403e30 <sched_thd_block_timeout+0x330>
        __asm__ __volatile__("lock " PS_CAS_STR
  403bb4:	f0 4c 0f b1 2b       	lock cmpxchg QWORD PTR [rbx],r13
  403bb9:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  403bbc:	84 c0                	test   al,al
  403bbe:	74 dc                	je     403b9c <sched_thd_block_timeout+0x9c>
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  403bc0:	4c 89 f6             	mov    rsi,r14
  403bc3:	4c 89 ef             	mov    rdi,r13
  403bc6:	e8 e5 05 01 00       	call   4141b0 <slm_timer_quantum_add>
		if (slm_timer_add(current, timeout)) goto done;
  403bcb:	85 c0                	test   eax,eax
  403bcd:	75 10                	jne    403bdf <sched_thd_block_timeout+0xdf>
		if (slm_thd_block(current)) {
  403bcf:	4c 89 ef             	mov    rdi,r13
  403bd2:	e8 49 15 01 00       	call   415120 <slm_thd_block>
  403bd7:	85 c0                	test   eax,eax
  403bd9:	0f 85 31 02 00 00    	jne    403e10 <sched_thd_block_timeout+0x310>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  403bdf:	e8 6c 79 00 00       	call   40b550 <cos_defcompinfo_curr_get>
  403be4:	0f 01 f9             	rdtscp 
	if (unlikely(!t)) t = &g->idle_thd;
  403be7:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  403bed:	4c 8d 24 89          	lea    r12,[rcx+rcx*4]
  403bf1:	49 c1 e4 06          	shl    r12,0x6
  403bf5:	49 8d 84 24 80 65 71 	lea    rax,[r12+0x716580]
  403bfc:	00 
  403bfd:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
	tok  = cos_sched_sync();
  403c01:	e8 0a df 00 00       	call   411b10 <cos_sched_sync>
  403c06:	41 89 c7             	mov    r15d,eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  403c09:	e8 92 ff 00 00       	call   413ba0 <slm_sched_fprr_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  403c0e:	48 85 c0             	test   rax,rax
  403c11:	48 89 c3             	mov    rbx,rax
  403c14:	48 0f 44 5d c8       	cmove  rbx,QWORD PTR [rbp-0x38]
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  403c19:	8b 43 04             	mov    eax,DWORD PTR [rbx+0x4]
  403c1c:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  403c1f:	83 f8 01             	cmp    eax,0x1
  403c22:	0f 87 5e 02 00 00    	ja     403e86 <sched_thd_block_timeout+0x386>
  403c28:	0f 01 f9             	rdtscp 
	struct slm_cs *cs = &(slm_global()->lock);
  403c2b:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  403c31:	48 8d 3c 89          	lea    rdi,[rcx+rcx*4]
  403c35:	48 c1 e7 06          	shl    rdi,0x6
  403c39:	4c 8d a7 00 65 71 00 	lea    r12,[rdi+0x716500]
	while (ret != 0) {
  403c40:	eb 13                	jmp    403c55 <sched_thd_block_timeout+0x155>
  403c42:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  403c48:	f0 49 0f b1 14 24    	lock cmpxchg QWORD PTR [r12],rdx
  403c4e:	0f 94 c0             	sete   al
  403c51:	84 c0                	test   al,al
  403c53:	75 29                	jne    403c7e <sched_thd_block_timeout+0x17e>
		tok    = cos_sched_sync();
  403c55:	e8 b6 de 00 00       	call   411b10 <cos_sched_sync>
  403c5a:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  403c5c:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
		if (unlikely(contention)) {
  403c60:	48 89 c2             	mov    rdx,rax
  403c63:	83 e2 01             	and    edx,0x1
  403c66:	74 e0                	je     403c48 <sched_thd_block_timeout+0x148>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  403c68:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  403c6b:	48 89 c2             	mov    rdx,rax
  403c6e:	4c 89 e7             	mov    rdi,r12
  403c71:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  403c75:	e8 26 14 01 00       	call   4150a0 <slm_cs_exit_contention>
  403c7a:	85 c0                	test   eax,eax
  403c7c:	75 d7                	jne    403c55 <sched_thd_block_timeout+0x155>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  403c7e:	e8 cd 78 00 00       	call   40b550 <cos_defcompinfo_curr_get>
  403c83:	0f 01 f9             	rdtscp 
	*coreid = c & 0xFFF;
  403c86:	89 ca                	mov    edx,ecx
	timeout = g->timeout_next;
  403c88:	81 e1 ff 0f 00 00    	and    ecx,0xfff
	prio = inherit_prio ? curr->priority : t->priority;
  403c8e:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
	timeout = g->timeout_next;
  403c92:	48 8d 04 89          	lea    rax,[rcx+rcx*4]
  403c96:	66 81 e2 ff 0f       	and    dx,0xfff
  403c9b:	49 89 cc             	mov    r12,rcx
  403c9e:	48 c1 e0 06          	shl    rax,0x6
  403ca2:	4c 8b 88 08 66 71 00 	mov    r9,QWORD PTR [rax+0x716608]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  403ca9:	8b 03                	mov    eax,DWORD PTR [rbx]
  403cab:	a8 0b                	test   al,0xb
  403cad:	0f 85 8e 00 00 00    	jne    403d41 <sched_thd_block_timeout+0x241>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  403cb3:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  403cb7:	44 89 f9             	mov    ecx,r15d
  403cba:	4c 89 ca             	mov    rdx,r9
  403cbd:	e8 de 89 00 00       	call   40c6a0 <cos_defswitch>
  403cc2:	89 c6                	mov    esi,eax
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  403cc4:	83 f8 ff             	cmp    eax,0xffffffff
  403cc7:	0f 84 d5 01 00 00    	je     403ea2 <sched_thd_block_timeout+0x3a2>
	if (unlikely(ret != 0)) {
  403ccd:	85 c0                	test   eax,eax
  403ccf:	0f 85 d5 00 00 00    	jne    403daa <sched_thd_block_timeout+0x2aa>
  403cd5:	31 f6                	xor    esi,esi
  403cd7:	4c 89 ef             	mov    rdi,r13
  403cda:	89 75 c8             	mov    DWORD PTR [rbp-0x38],esi
  403cdd:	e8 7e 05 01 00       	call   414260 <slm_timer_quantum_cancel>
	__asm__ __volatile__("rdtsc" : "=a" (a), "=d" (d), "=c" (c) : : );
  403ce2:	0f 31                	rdtsc  
	return ((u64_t)d << 32) | (u64_t)a;
  403ce4:	48 c1 e2 20          	shl    rdx,0x20
	while (cycles_greater_than(timeout, slm_now())) {
  403ce8:	8b 75 c8             	mov    esi,DWORD PTR [rbp-0x38]
  403ceb:	48 09 c2             	or     rdx,rax
  403cee:	4c 89 f0             	mov    rax,r14
  403cf1:	48 29 d0             	sub    rax,rdx
  403cf4:	48 85 c0             	test   rax,rax
  403cf7:	0f 8f 87 fe ff ff    	jg     403b84 <sched_thd_block_timeout+0x84>
	if (dep_id) return 0;
  403cfd:	31 c0                	xor    eax,eax
	if (thd_block_until(abs_timeout)) return 0;
  403cff:	85 f6                	test   esi,esi
  403d01:	0f 84 e7 01 00 00    	je     403eee <sched_thd_block_timeout+0x3ee>
}
  403d07:	48 83 c4 18          	add    rsp,0x18
  403d0b:	5b                   	pop    rbx
  403d0c:	41 5c                	pop    r12
  403d0e:	41 5d                	pop    r13
  403d10:	41 5e                	pop    r14
  403d12:	41 5f                	pop    r15
  403d14:	5d                   	pop    rbp
  403d15:	c3                   	ret    
  403d16:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  403d1d:	00 00 00 
  403d20:	83 e2 01             	and    edx,0x1
  403d23:	0f 85 3a fe ff ff    	jne    403b63 <sched_thd_block_timeout+0x63>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403d29:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  403d2d:	4c 8d 2c 50          	lea    r13,[rax+rdx*2]
  403d31:	49 c1 e5 04          	shl    r13,0x4
  403d35:	49 81 c5 60 fd 5b 00 	add    r13,0x5bfd60
  403d3c:	e9 22 fe ff ff       	jmp    403b63 <sched_thd_block_timeout+0x63>
		if (t == &g->sched_thd) {
  403d41:	0f b7 d2             	movzx  edx,dx
	timeout = g->timeout_next;
  403d44:	4c 89 c9             	mov    rcx,r9
		if (t == &g->sched_thd) {
  403d47:	48 8d 14 92          	lea    rdx,[rdx+rdx*4]
  403d4b:	48 c1 e2 06          	shl    rdx,0x6
  403d4f:	48 81 c2 08 65 71 00 	add    rdx,0x716508
  403d56:	48 39 d3             	cmp    rbx,rdx
  403d59:	0f 84 c3 01 00 00    	je     403f22 <sched_thd_block_timeout+0x422>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  403d5f:	a8 02                	test   al,0x2
  403d61:	0f 85 c6 01 00 00    	jne    403f2d <sched_thd_block_timeout+0x42d>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  403d67:	49 89 c9             	mov    r9,rcx
  403d6a:	a8 01                	test   al,0x1
  403d6c:	0f 84 41 ff ff ff    	je     403cb3 <sched_thd_block_timeout+0x1b3>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  403d72:	4b 8d 04 a4          	lea    rax,[r12+r12*4]
  403d76:	4c 8b 53 08          	mov    r10,QWORD PTR [rbx+0x8]
  403d7a:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  403d7e:	48 89 f2             	mov    rdx,rsi
  403d81:	48 c1 e0 06          	shl    rax,0x6
  403d85:	45 89 f9             	mov    r9d,r15d
  403d88:	4c 8b 80 28 65 71 00 	mov    r8,QWORD PTR [rax+0x716528]
  403d8f:	4c 89 d6             	mov    rsi,r10
  403d92:	e8 99 dd 00 00       	call   411b30 <cos_switch>
  403d97:	89 c6                	mov    esi,eax
	if (unlikely(ret != 0)) {
  403d99:	85 f6                	test   esi,esi
  403d9b:	0f 84 34 ff ff ff    	je     403cd5 <sched_thd_block_timeout+0x1d5>
		assert(ret != -EPERM);
  403da1:	83 fe ff             	cmp    esi,0xffffffff
  403da4:	0f 84 28 01 00 00    	je     403ed2 <sched_thd_block_timeout+0x3d2>
		assert(ret != -EINVAL);
  403daa:	83 fe ea             	cmp    esi,0xffffffea
  403dad:	0f 84 cc 01 00 00    	je     403f7f <sched_thd_block_timeout+0x47f>
		if (ret == -EBUSY) return ret;
  403db3:	83 fe f0             	cmp    esi,0xfffffff0
  403db6:	0f 84 1b ff ff ff    	je     403cd7 <sched_thd_block_timeout+0x1d7>
		assert(ret == -EAGAIN);
  403dbc:	83 fe f5             	cmp    esi,0xfffffff5
  403dbf:	0f 85 d6 01 00 00    	jne    403f9b <sched_thd_block_timeout+0x49b>
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  403dc5:	0f 01 f9             	rdtscp 
	cs = &(slm_global()->lock);
  403dc8:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  403dce:	48 8d 1c 89          	lea    rbx,[rcx+rcx*4]
  403dd2:	48 c1 e3 06          	shl    rbx,0x6
  403dd6:	48 81 c3 00 65 71 00 	add    rbx,0x716500
		tok    = cos_sched_sync();
  403ddd:	e8 2e dd 00 00       	call   411b10 <cos_sched_sync>
  403de2:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  403de5:	48 8b 03             	mov    rax,QWORD PTR [rbx]
		if (unlikely(owner)) {
  403de8:	48 89 c1             	mov    rcx,rax
  403deb:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  403def:	0f 85 c2 01 00 00    	jne    403fb7 <sched_thd_block_timeout+0x4b7>
        __asm__ __volatile__("lock " PS_CAS_STR
  403df5:	f0 4c 0f b1 2b       	lock cmpxchg QWORD PTR [rbx],r13
  403dfa:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  403dfd:	84 c0                	test   al,al
  403dff:	0f 85 fc fd ff ff    	jne    403c01 <sched_thd_block_timeout+0x101>
  403e05:	eb d6                	jmp    403ddd <sched_thd_block_timeout+0x2dd>
  403e07:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  403e0e:	00 00 
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  403e10:	4c 89 ef             	mov    rdi,r13
  403e13:	e8 48 04 01 00       	call   414260 <slm_timer_quantum_cancel>
  403e18:	e9 c2 fd ff ff       	jmp    403bdf <sched_thd_block_timeout+0xdf>
  403e1d:	0f 1f 00             	nop    DWORD PTR [rax]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  403e20:	45 31 ed             	xor    r13d,r13d
  403e23:	e9 3b fd ff ff       	jmp    403b63 <sched_thd_block_timeout+0x63>
  403e28:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  403e2f:	00 
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  403e30:	41 89 c0             	mov    r8d,eax
  403e33:	4c 89 ea             	mov    rdx,r13
  403e36:	48 89 c6             	mov    rsi,rax
  403e39:	48 89 df             	mov    rdi,rbx
  403e3c:	41 83 e0 01          	and    r8d,0x1
  403e40:	e8 fb 11 01 00       	call   415040 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  403e45:	83 f8 f0             	cmp    eax,0xfffffff0
  403e48:	0f 85 4e fd ff ff    	jne    403b9c <sched_thd_block_timeout+0x9c>
  403e4e:	be 59 00 00 00       	mov    esi,0x59
  403e53:	bf 60 d1 41 00       	mov    edi,0x41d160
  403e58:	e8 23 6e 00 00       	call   40ac80 <cos_print_str>
  403e5d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403e64:	00 00 00 00 
  403e68:	0f 0b                	ud2    
  403e6a:	be 59 00 00 00       	mov    esi,0x59
  403e6f:	bf 00 d1 41 00       	mov    edi,0x41d100
  403e74:	e8 07 6e 00 00       	call   40ac80 <cos_print_str>
	assert(current);
  403e79:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403e80:	00 00 00 00 
  403e84:	0f 0b                	ud2    
  403e86:	be 61 00 00 00       	mov    esi,0x61
  403e8b:	bf e8 d1 41 00       	mov    edi,0x41d1e8
  403e90:	e8 eb 6d 00 00       	call   40ac80 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  403e95:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403e9c:	00 00 00 00 
  403ea0:	0f 0b                	ud2    
  403ea2:	0f 01 f9             	rdtscp 
	return t != &g->idle_thd && t != &g->sched_thd;
  403ea5:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  403eab:	48 8d 04 89          	lea    rax,[rcx+rcx*4]
  403eaf:	48 c1 e0 06          	shl    rax,0x6
  403eb3:	48 8d 90 80 65 71 00 	lea    rdx,[rax+0x716580]
  403eba:	48 39 d3             	cmp    rbx,rdx
  403ebd:	0f 84 8f 00 00 00    	je     403f52 <sched_thd_block_timeout+0x452>
  403ec3:	48 05 08 65 71 00    	add    rax,0x716508
  403ec9:	48 39 c3             	cmp    rbx,rax
  403ecc:	0f 84 80 00 00 00    	je     403f52 <sched_thd_block_timeout+0x452>
  403ed2:	be 61 00 00 00       	mov    esi,0x61
  403ed7:	bf 50 d2 41 00       	mov    edi,0x41d250
  403edc:	e8 9f 6d 00 00       	call   40ac80 <cos_print_str>
		assert(ret != -EPERM);
  403ee1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403ee8:	00 00 00 00 
  403eec:	0f 0b                	ud2    
	__asm__ __volatile__("rdtsc" : "=a" (a), "=d" (d), "=c" (c) : : );
  403eee:	0f 31                	rdtsc  
	return ((u64_t)d << 32) | (u64_t)a;
  403ef0:	48 c1 e2 20          	shl    rdx,0x20
  403ef4:	48 09 d0             	or     rax,rdx
  403ef7:	48 89 c2             	mov    rdx,rax
  403efa:	4c 29 f2             	sub    rdx,r14
	assert(cycles_greater_than(now, abs_timeout));
  403efd:	48 85 d2             	test   rdx,rdx
  403f00:	0f 8f 01 fe ff ff    	jg     403d07 <sched_thd_block_timeout+0x207>
  403f06:	be 24 00 00 00       	mov    esi,0x24
  403f0b:	bf 28 d6 41 00       	mov    edi,0x41d628
  403f10:	e8 6b 6d 00 00       	call   40ac80 <cos_print_str>
  403f15:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403f1c:	00 00 00 00 
  403f20:	0f 0b                	ud2    
			prio    = curr->priority;
  403f22:	49 8b 75 30          	mov    rsi,QWORD PTR [r13+0x30]
			timeout = TCAP_TIME_NIL;
  403f26:	31 c9                	xor    ecx,ecx
  403f28:	e9 32 fe ff ff       	jmp    403d5f <sched_thd_block_timeout+0x25f>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  403f2d:	4b 8d 04 a4          	lea    rax,[r12+r12*4]
  403f31:	48 8b 7b 28          	mov    rdi,QWORD PTR [rbx+0x28]
  403f35:	4c 89 ce             	mov    rsi,r9
  403f38:	44 89 f9             	mov    ecx,r15d
  403f3b:	48 c1 e0 06          	shl    rax,0x6
  403f3f:	48 8b 90 28 65 71 00 	mov    rdx,QWORD PTR [rax+0x716528]
  403f46:	e8 55 dc 00 00       	call   411ba0 <cos_sched_asnd>
  403f4b:	89 c6                	mov    esi,eax
  403f4d:	e9 47 fe ff ff       	jmp    403d99 <sched_thd_block_timeout+0x299>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  403f52:	4b 8d 04 a4          	lea    rax,[r12+r12*4]
  403f56:	49 8b 55 30          	mov    rdx,QWORD PTR [r13+0x30]
  403f5a:	31 f6                	xor    esi,esi
  403f5c:	45 89 f9             	mov    r9d,r15d
  403f5f:	48 c1 e0 06          	shl    rax,0x6
  403f63:	31 c9                	xor    ecx,ecx
  403f65:	4c 8b 80 28 65 71 00 	mov    r8,QWORD PTR [rax+0x716528]
  403f6c:	48 8b b8 18 65 71 00 	mov    rdi,QWORD PTR [rax+0x716518]
  403f73:	e8 b8 db 00 00       	call   411b30 <cos_switch>
  403f78:	89 c6                	mov    esi,eax
  403f7a:	e9 1a fe ff ff       	jmp    403d99 <sched_thd_block_timeout+0x299>
  403f7f:	be 61 00 00 00       	mov    esi,0x61
  403f84:	bf b8 d2 41 00       	mov    edi,0x41d2b8
  403f89:	e8 f2 6c 00 00       	call   40ac80 <cos_print_str>
		assert(ret != -EINVAL);
  403f8e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403f95:	00 00 00 00 
  403f99:	0f 0b                	ud2    
  403f9b:	be 61 00 00 00       	mov    esi,0x61
  403fa0:	bf 20 d3 41 00       	mov    edi,0x41d320
  403fa5:	e8 d6 6c 00 00       	call   40ac80 <cos_print_str>
		assert(ret == -EAGAIN);
  403faa:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403fb1:	00 00 00 00 
  403fb5:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  403fb7:	41 89 c0             	mov    r8d,eax
  403fba:	4c 89 ea             	mov    rdx,r13
  403fbd:	48 89 c6             	mov    rsi,rax
  403fc0:	48 89 df             	mov    rdi,rbx
  403fc3:	41 83 e0 01          	and    r8d,0x1
  403fc7:	e8 74 10 01 00       	call   415040 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  403fcc:	83 f8 f0             	cmp    eax,0xfffffff0
  403fcf:	0f 85 08 fe ff ff    	jne    403ddd <sched_thd_block_timeout+0x2dd>
  403fd5:	be 59 00 00 00       	mov    esi,0x59
  403fda:	bf 60 d1 41 00       	mov    edi,0x41d160
  403fdf:	e8 9c 6c 00 00       	call   40ac80 <cos_print_str>
  403fe4:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  403feb:	00 00 00 00 
  403fef:	0f 0b                	ud2    
  403ff1:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  403ff8:	00 00 00 00 
  403ffc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000404000 <thd_sleep>:
{
  404000:	f3 0f 1e fa          	endbr64 
  404004:	55                   	push   rbp
  404005:	48 89 e5             	mov    rbp,rsp
  404008:	41 57                	push   r15
  40400a:	41 56                	push   r14
  40400c:	41 55                	push   r13
  40400e:	41 54                	push   r12
  404010:	53                   	push   rbx
  404011:	48 83 ec 18          	sub    rsp,0x18
	__asm__ __volatile__("rdtsc" : "=a" (a), "=d" (d), "=c" (c) : : );
  404015:	0f 31                	rdtsc  
	return ((u64_t)d << 32) | (u64_t)a;
  404017:	48 c1 e2 20          	shl    rdx,0x20
  40401b:	48 09 c2             	or     rdx,rax
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  40401e:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  404021:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
	cycles_t timeout = c + slm_now();
  404027:	4c 8d 34 3a          	lea    r14,[rdx+rdi*1]
  40402b:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  404032:	48 85 c0             	test   rax,rax
  404035:	0f 84 0d 02 00 00    	je     404248 <thd_sleep+0x248>
  40403b:	83 e8 01             	sub    eax,0x1
  40403e:	3d c7 00 00 00       	cmp    eax,0xc7
  404043:	0f 87 ff 01 00 00    	ja     404248 <thd_sleep+0x248>
  404049:	48 8b 14 c5 20 f7 5b 	mov    rdx,QWORD PTR [rax*8+0x5bf720]
  404050:	00 
  404051:	45 31 ed             	xor    r13d,r13d
  404054:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  40405b:	0f 85 af 01 00 00    	jne    404210 <thd_sleep+0x210>
	__asm__ __volatile__("rdtsc" : "=a" (a), "=d" (d), "=c" (c) : : );
  404061:	0f 31                	rdtsc  
	return ((u64_t)d << 32) | (u64_t)a;
  404063:	48 c1 e2 20          	shl    rdx,0x20
  404067:	48 09 c2             	or     rdx,rax
  40406a:	4c 89 f0             	mov    rax,r14
  40406d:	48 29 d0             	sub    rax,rdx
	while (cycles_greater_than(timeout, slm_now())) {
  404070:	48 85 c0             	test   rax,rax
  404073:	0f 8e 87 03 00 00    	jle    404400 <thd_sleep+0x400>
	assert(current);
  404079:	4d 85 ed             	test   r13,r13
  40407c:	0f 84 08 02 00 00    	je     40428a <thd_sleep+0x28a>
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  404082:	0f 01 f9             	rdtscp 
	cs = &(slm_global()->lock);
  404085:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  40408b:	48 8d 1c 89          	lea    rbx,[rcx+rcx*4]
  40408f:	48 c1 e3 06          	shl    rbx,0x6
  404093:	48 81 c3 00 65 71 00 	add    rbx,0x716500
		tok    = cos_sched_sync();
  40409a:	e8 71 da 00 00       	call   411b10 <cos_sched_sync>
  40409f:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4040a2:	48 8b 03             	mov    rax,QWORD PTR [rbx]
		if (unlikely(owner)) {
  4040a5:	48 89 c1             	mov    rcx,rax
  4040a8:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  4040ac:	0f 85 9e 01 00 00    	jne    404250 <thd_sleep+0x250>
        __asm__ __volatile__("lock " PS_CAS_STR
  4040b2:	f0 4c 0f b1 2b       	lock cmpxchg QWORD PTR [rbx],r13
  4040b7:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4040ba:	84 c0                	test   al,al
  4040bc:	74 dc                	je     40409a <thd_sleep+0x9a>
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  4040be:	4c 89 f6             	mov    rsi,r14
  4040c1:	4c 89 ef             	mov    rdi,r13
  4040c4:	e8 e7 00 01 00       	call   4141b0 <slm_timer_quantum_add>
		if (slm_timer_add(current, timeout)) goto done;
  4040c9:	85 c0                	test   eax,eax
  4040cb:	75 10                	jne    4040dd <thd_sleep+0xdd>
		if (slm_thd_block(current)) {
  4040cd:	4c 89 ef             	mov    rdi,r13
  4040d0:	e8 4b 10 01 00       	call   415120 <slm_thd_block>
  4040d5:	85 c0                	test   eax,eax
  4040d7:	0f 85 5b 01 00 00    	jne    404238 <thd_sleep+0x238>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  4040dd:	e8 6e 74 00 00       	call   40b550 <cos_defcompinfo_curr_get>
  4040e2:	0f 01 f9             	rdtscp 
	if (unlikely(!t)) t = &g->idle_thd;
  4040e5:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  4040eb:	4c 8d 24 89          	lea    r12,[rcx+rcx*4]
  4040ef:	49 c1 e4 06          	shl    r12,0x6
  4040f3:	49 8d 84 24 80 65 71 	lea    rax,[r12+0x716580]
  4040fa:	00 
  4040fb:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
	tok  = cos_sched_sync();
  4040ff:	e8 0c da 00 00       	call   411b10 <cos_sched_sync>
  404104:	41 89 c7             	mov    r15d,eax
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  404107:	e8 94 fa 00 00       	call   413ba0 <slm_sched_fprr_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  40410c:	48 85 c0             	test   rax,rax
  40410f:	48 89 c3             	mov    rbx,rax
  404112:	48 0f 44 5d c8       	cmove  rbx,QWORD PTR [rbp-0x38]
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  404117:	8b 43 04             	mov    eax,DWORD PTR [rbx+0x4]
  40411a:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  40411d:	83 f8 01             	cmp    eax,0x1
  404120:	0f 87 80 01 00 00    	ja     4042a6 <thd_sleep+0x2a6>
  404126:	0f 01 f9             	rdtscp 
	struct slm_cs *cs = &(slm_global()->lock);
  404129:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  40412f:	48 8d 3c 89          	lea    rdi,[rcx+rcx*4]
  404133:	48 c1 e7 06          	shl    rdi,0x6
  404137:	4c 8d a7 00 65 71 00 	lea    r12,[rdi+0x716500]
	while (ret != 0) {
  40413e:	eb 0d                	jmp    40414d <thd_sleep+0x14d>
  404140:	f0 49 0f b1 14 24    	lock cmpxchg QWORD PTR [r12],rdx
  404146:	0f 94 c0             	sete   al
  404149:	84 c0                	test   al,al
  40414b:	75 29                	jne    404176 <thd_sleep+0x176>
		tok    = cos_sched_sync();
  40414d:	e8 be d9 00 00       	call   411b10 <cos_sched_sync>
  404152:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  404154:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
		if (unlikely(contention)) {
  404158:	48 89 c2             	mov    rdx,rax
  40415b:	83 e2 01             	and    edx,0x1
  40415e:	74 e0                	je     404140 <thd_sleep+0x140>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  404160:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  404163:	48 89 c2             	mov    rdx,rax
  404166:	4c 89 e7             	mov    rdi,r12
  404169:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  40416d:	e8 2e 0f 01 00       	call   4150a0 <slm_cs_exit_contention>
  404172:	85 c0                	test   eax,eax
  404174:	75 d7                	jne    40414d <thd_sleep+0x14d>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  404176:	e8 d5 73 00 00       	call   40b550 <cos_defcompinfo_curr_get>
  40417b:	0f 01 f9             	rdtscp 
	*coreid = c & 0xFFF;
  40417e:	89 ca                	mov    edx,ecx
	timeout = g->timeout_next;
  404180:	81 e1 ff 0f 00 00    	and    ecx,0xfff
	prio = inherit_prio ? curr->priority : t->priority;
  404186:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
	timeout = g->timeout_next;
  40418a:	48 8d 04 89          	lea    rax,[rcx+rcx*4]
  40418e:	66 81 e2 ff 0f       	and    dx,0xfff
  404193:	49 89 cc             	mov    r12,rcx
  404196:	48 c1 e0 06          	shl    rax,0x6
  40419a:	4c 8b 80 08 66 71 00 	mov    r8,QWORD PTR [rax+0x716608]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4041a1:	8b 03                	mov    eax,DWORD PTR [rbx]
  4041a3:	a8 0b                	test   al,0xb
  4041a5:	0f 85 17 01 00 00    	jne    4042c2 <thd_sleep+0x2c2>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  4041ab:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  4041af:	4c 89 c2             	mov    rdx,r8
  4041b2:	44 89 f9             	mov    ecx,r15d
  4041b5:	e8 e6 84 00 00       	call   40c6a0 <cos_defswitch>
  4041ba:	41 89 c0             	mov    r8d,eax
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  4041bd:	83 f8 ff             	cmp    eax,0xffffffff
  4041c0:	0f 84 57 01 00 00    	je     40431d <thd_sleep+0x31d>
	if (unlikely(ret != 0)) {
  4041c6:	85 c0                	test   eax,eax
  4041c8:	0f 85 d6 01 00 00    	jne    4043a4 <thd_sleep+0x3a4>
  4041ce:	45 31 c0             	xor    r8d,r8d
  4041d1:	4c 89 ef             	mov    rdi,r13
  4041d4:	44 89 45 c8          	mov    DWORD PTR [rbp-0x38],r8d
  4041d8:	e8 83 00 01 00       	call   414260 <slm_timer_quantum_cancel>
	__asm__ __volatile__("rdtsc" : "=a" (a), "=d" (d), "=c" (c) : : );
  4041dd:	0f 31                	rdtsc  
	return ((u64_t)d << 32) | (u64_t)a;
  4041df:	48 c1 e2 20          	shl    rdx,0x20
	while (cycles_greater_than(timeout, slm_now())) {
  4041e3:	44 8b 45 c8          	mov    r8d,DWORD PTR [rbp-0x38]
  4041e7:	48 09 c2             	or     rdx,rax
  4041ea:	4c 89 f0             	mov    rax,r14
  4041ed:	48 29 d0             	sub    rax,rdx
  4041f0:	48 85 c0             	test   rax,rax
  4041f3:	0f 8f 89 fe ff ff    	jg     404082 <thd_sleep+0x82>
}
  4041f9:	48 83 c4 18          	add    rsp,0x18
  4041fd:	44 89 c0             	mov    eax,r8d
  404200:	5b                   	pop    rbx
  404201:	41 5c                	pop    r12
  404203:	41 5d                	pop    r13
  404205:	41 5e                	pop    r14
  404207:	41 5f                	pop    r15
  404209:	5d                   	pop    rbp
  40420a:	c3                   	ret    
  40420b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  404210:	83 e2 01             	and    edx,0x1
  404213:	0f 85 48 fe ff ff    	jne    404061 <thd_sleep+0x61>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  404219:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  40421d:	4c 8d 2c 50          	lea    r13,[rax+rdx*2]
  404221:	49 c1 e5 04          	shl    r13,0x4
  404225:	49 81 c5 60 fd 5b 00 	add    r13,0x5bfd60
  40422c:	e9 30 fe ff ff       	jmp    404061 <thd_sleep+0x61>
  404231:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  404238:	4c 89 ef             	mov    rdi,r13
  40423b:	e8 20 00 01 00       	call   414260 <slm_timer_quantum_cancel>
  404240:	e9 98 fe ff ff       	jmp    4040dd <thd_sleep+0xdd>
  404245:	0f 1f 00             	nop    DWORD PTR [rax]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  404248:	45 31 ed             	xor    r13d,r13d
  40424b:	e9 11 fe ff ff       	jmp    404061 <thd_sleep+0x61>
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  404250:	41 89 c0             	mov    r8d,eax
  404253:	4c 89 ea             	mov    rdx,r13
  404256:	48 89 c6             	mov    rsi,rax
  404259:	48 89 df             	mov    rdi,rbx
  40425c:	41 83 e0 01          	and    r8d,0x1
  404260:	e8 db 0d 01 00       	call   415040 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  404265:	83 f8 f0             	cmp    eax,0xfffffff0
  404268:	0f 85 2c fe ff ff    	jne    40409a <thd_sleep+0x9a>
  40426e:	be 59 00 00 00       	mov    esi,0x59
  404273:	bf 60 d1 41 00       	mov    edi,0x41d160
  404278:	e8 03 6a 00 00       	call   40ac80 <cos_print_str>
  40427d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404284:	00 00 00 00 
  404288:	0f 0b                	ud2    
  40428a:	be 59 00 00 00       	mov    esi,0x59
  40428f:	bf 00 d1 41 00       	mov    edi,0x41d100
  404294:	e8 e7 69 00 00       	call   40ac80 <cos_print_str>
	assert(current);
  404299:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4042a0:	00 00 00 00 
  4042a4:	0f 0b                	ud2    
  4042a6:	be 61 00 00 00       	mov    esi,0x61
  4042ab:	bf e8 d1 41 00       	mov    edi,0x41d1e8
  4042b0:	e8 cb 69 00 00       	call   40ac80 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  4042b5:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4042bc:	00 00 00 00 
  4042c0:	0f 0b                	ud2    
		if (t == &g->sched_thd) {
  4042c2:	0f b7 d2             	movzx  edx,dx
	timeout = g->timeout_next;
  4042c5:	4c 89 c1             	mov    rcx,r8
		if (t == &g->sched_thd) {
  4042c8:	48 8d 14 92          	lea    rdx,[rdx+rdx*4]
  4042cc:	48 c1 e2 06          	shl    rdx,0x6
  4042d0:	48 81 c2 08 65 71 00 	add    rdx,0x716508
  4042d7:	48 39 d3             	cmp    rbx,rdx
  4042da:	0f 84 81 00 00 00    	je     404361 <thd_sleep+0x361>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  4042e0:	a8 02                	test   al,0x2
  4042e2:	0f 85 20 01 00 00    	jne    404408 <thd_sleep+0x408>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  4042e8:	49 89 c8             	mov    r8,rcx
  4042eb:	a8 01                	test   al,0x1
  4042ed:	0f 84 b8 fe ff ff    	je     4041ab <thd_sleep+0x1ab>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  4042f3:	4b 8d 04 a4          	lea    rax,[r12+r12*4]
  4042f7:	4c 8b 53 08          	mov    r10,QWORD PTR [rbx+0x8]
  4042fb:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  4042ff:	48 89 f2             	mov    rdx,rsi
  404302:	48 c1 e0 06          	shl    rax,0x6
  404306:	45 89 f9             	mov    r9d,r15d
  404309:	4c 8b 80 28 65 71 00 	mov    r8,QWORD PTR [rax+0x716528]
  404310:	4c 89 d6             	mov    rsi,r10
  404313:	e8 18 d8 00 00       	call   411b30 <cos_switch>
  404318:	41 89 c0             	mov    r8d,eax
  40431b:	eb 78                	jmp    404395 <thd_sleep+0x395>
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  40431d:	0f 01 f9             	rdtscp 
	return t != &g->idle_thd && t != &g->sched_thd;
  404320:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  404326:	48 8d 04 89          	lea    rax,[rcx+rcx*4]
  40432a:	48 c1 e0 06          	shl    rax,0x6
  40432e:	48 8d 90 80 65 71 00 	lea    rdx,[rax+0x716580]
  404335:	48 39 d3             	cmp    rbx,rdx
  404338:	74 32                	je     40436c <thd_sleep+0x36c>
  40433a:	48 05 08 65 71 00    	add    rax,0x716508
  404340:	48 39 c3             	cmp    rbx,rax
  404343:	74 27                	je     40436c <thd_sleep+0x36c>
  404345:	be 61 00 00 00       	mov    esi,0x61
  40434a:	bf 50 d2 41 00       	mov    edi,0x41d250
  40434f:	e8 2c 69 00 00       	call   40ac80 <cos_print_str>
		assert(ret != -EPERM);
  404354:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40435b:	00 00 00 00 
  40435f:	0f 0b                	ud2    
			prio    = curr->priority;
  404361:	49 8b 75 30          	mov    rsi,QWORD PTR [r13+0x30]
			timeout = TCAP_TIME_NIL;
  404365:	31 c9                	xor    ecx,ecx
  404367:	e9 74 ff ff ff       	jmp    4042e0 <thd_sleep+0x2e0>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  40436c:	4b 8d 04 a4          	lea    rax,[r12+r12*4]
  404370:	49 8b 55 30          	mov    rdx,QWORD PTR [r13+0x30]
  404374:	45 89 f9             	mov    r9d,r15d
  404377:	31 c9                	xor    ecx,ecx
  404379:	48 c1 e0 06          	shl    rax,0x6
  40437d:	31 f6                	xor    esi,esi
  40437f:	4c 8b 80 28 65 71 00 	mov    r8,QWORD PTR [rax+0x716528]
  404386:	48 8b b8 18 65 71 00 	mov    rdi,QWORD PTR [rax+0x716518]
  40438d:	e8 9e d7 00 00       	call   411b30 <cos_switch>
  404392:	41 89 c0             	mov    r8d,eax
	if (unlikely(ret != 0)) {
  404395:	45 85 c0             	test   r8d,r8d
  404398:	0f 84 30 fe ff ff    	je     4041ce <thd_sleep+0x1ce>
		assert(ret != -EPERM);
  40439e:	41 83 f8 ff          	cmp    r8d,0xffffffff
  4043a2:	74 a1                	je     404345 <thd_sleep+0x345>
		assert(ret != -EINVAL);
  4043a4:	41 83 f8 ea          	cmp    r8d,0xffffffea
  4043a8:	0f 84 80 00 00 00    	je     40442e <thd_sleep+0x42e>
		if (ret == -EBUSY) return ret;
  4043ae:	41 83 f8 f0          	cmp    r8d,0xfffffff0
  4043b2:	0f 84 19 fe ff ff    	je     4041d1 <thd_sleep+0x1d1>
		assert(ret == -EAGAIN);
  4043b8:	41 83 f8 f5          	cmp    r8d,0xfffffff5
  4043bc:	0f 85 88 00 00 00    	jne    40444a <thd_sleep+0x44a>
  4043c2:	0f 01 f9             	rdtscp 
	cs = &(slm_global()->lock);
  4043c5:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  4043cb:	48 8d 1c 89          	lea    rbx,[rcx+rcx*4]
  4043cf:	48 c1 e3 06          	shl    rbx,0x6
  4043d3:	48 81 c3 00 65 71 00 	add    rbx,0x716500
		tok    = cos_sched_sync();
  4043da:	e8 31 d7 00 00       	call   411b10 <cos_sched_sync>
  4043df:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4043e2:	48 8b 03             	mov    rax,QWORD PTR [rbx]
		if (unlikely(owner)) {
  4043e5:	48 89 c1             	mov    rcx,rax
  4043e8:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  4043ec:	75 78                	jne    404466 <thd_sleep+0x466>
        __asm__ __volatile__("lock " PS_CAS_STR
  4043ee:	f0 4c 0f b1 2b       	lock cmpxchg QWORD PTR [rbx],r13
  4043f3:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4043f6:	84 c0                	test   al,al
  4043f8:	0f 85 01 fd ff ff    	jne    4040ff <thd_sleep+0xff>
  4043fe:	eb da                	jmp    4043da <thd_sleep+0x3da>
	int ret = 0;
  404400:	45 31 c0             	xor    r8d,r8d
	return thd_block_until(timeout);
  404403:	e9 f1 fd ff ff       	jmp    4041f9 <thd_sleep+0x1f9>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  404408:	4b 8d 04 a4          	lea    rax,[r12+r12*4]
  40440c:	48 8b 7b 28          	mov    rdi,QWORD PTR [rbx+0x28]
  404410:	4c 89 c6             	mov    rsi,r8
  404413:	44 89 f9             	mov    ecx,r15d
  404416:	48 c1 e0 06          	shl    rax,0x6
  40441a:	48 8b 90 28 65 71 00 	mov    rdx,QWORD PTR [rax+0x716528]
  404421:	e8 7a d7 00 00       	call   411ba0 <cos_sched_asnd>
  404426:	41 89 c0             	mov    r8d,eax
  404429:	e9 67 ff ff ff       	jmp    404395 <thd_sleep+0x395>
  40442e:	be 61 00 00 00       	mov    esi,0x61
  404433:	bf b8 d2 41 00       	mov    edi,0x41d2b8
  404438:	e8 43 68 00 00       	call   40ac80 <cos_print_str>
		assert(ret != -EINVAL);
  40443d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404444:	00 00 00 00 
  404448:	0f 0b                	ud2    
  40444a:	be 61 00 00 00       	mov    esi,0x61
  40444f:	bf 20 d3 41 00       	mov    edi,0x41d320
  404454:	e8 27 68 00 00       	call   40ac80 <cos_print_str>
		assert(ret == -EAGAIN);
  404459:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404460:	00 00 00 00 
  404464:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  404466:	41 89 c0             	mov    r8d,eax
  404469:	4c 89 ea             	mov    rdx,r13
  40446c:	48 89 c6             	mov    rsi,rax
  40446f:	48 89 df             	mov    rdi,rbx
  404472:	41 83 e0 01          	and    r8d,0x1
  404476:	e8 c5 0b 01 00       	call   415040 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  40447b:	83 f8 f0             	cmp    eax,0xfffffff0
  40447e:	0f 85 56 ff ff ff    	jne    4043da <thd_sleep+0x3da>
  404484:	e9 e5 fd ff ff       	jmp    40426e <thd_sleep+0x26e>
  404489:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000404490 <sched_blkpt_alloc>:
{
  404490:	f3 0f 1e fa          	endbr64 
  404494:	55                   	push   rbp
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  404495:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  404498:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  40449e:	48 89 e5             	mov    rbp,rsp
  4044a1:	41 54                	push   r12
  4044a3:	53                   	push   rbx
  4044a4:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  4044ab:	48 85 c0             	test   rax,rax
  4044ae:	0f 84 2c 01 00 00    	je     4045e0 <sched_blkpt_alloc+0x150>
  4044b4:	83 e8 01             	sub    eax,0x1
  4044b7:	3d c7 00 00 00       	cmp    eax,0xc7
  4044bc:	0f 87 1e 01 00 00    	ja     4045e0 <sched_blkpt_alloc+0x150>
  4044c2:	48 8b 14 c5 20 f7 5b 	mov    rdx,QWORD PTR [rax*8+0x5bf720]
  4044c9:	00 
  4044ca:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  4044d1:	0f 84 09 01 00 00    	je     4045e0 <sched_blkpt_alloc+0x150>
  4044d7:	83 e2 01             	and    edx,0x1
  4044da:	0f 85 00 01 00 00    	jne    4045e0 <sched_blkpt_alloc+0x150>
	return &ss_thd_get(cos_thdid())->thd;
  4044e0:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  4044e4:	4c 8d 24 50          	lea    r12,[rax+rdx*2]
  4044e8:	49 c1 e4 04          	shl    r12,0x4
  4044ec:	49 81 c4 60 fd 5b 00 	add    r12,0x5bfd60
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  4044f3:	0f 01 f9             	rdtscp 
	cs = &(slm_global()->lock);
  4044f6:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  4044fc:	48 8d 1c 89          	lea    rbx,[rcx+rcx*4]
  404500:	48 c1 e3 06          	shl    rbx,0x6
  404504:	48 81 c3 00 65 71 00 	add    rbx,0x716500
		tok    = cos_sched_sync();
  40450b:	e8 00 d6 00 00       	call   411b10 <cos_sched_sync>
  404510:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  404513:	48 8b 03             	mov    rax,QWORD PTR [rbx]
		if (unlikely(owner)) {
  404516:	48 89 c1             	mov    rcx,rax
  404519:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  40451d:	0f 85 dd 00 00 00    	jne    404600 <sched_blkpt_alloc+0x170>
  404523:	f0 4c 0f b1 23       	lock cmpxchg QWORD PTR [rbx],r12
  404528:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  40452b:	84 c0                	test   al,al
  40452d:	74 dc                	je     40450b <sched_blkpt_alloc+0x7b>
	id = (sched_blkpt_id_t)__blkpt_offset;
  40452f:	44 8b 25 ca 1a 02 00 	mov    r12d,DWORD PTR [rip+0x21aca]        # 426000 <__blkpt_offset>
	if (id - 1 == NBLKPTS) return NULL;
  404536:	41 81 fc 01 a0 00 00 	cmp    r12d,0xa001
  40453d:	0f 84 f7 00 00 00    	je     40463a <sched_blkpt_alloc+0x1aa>
	return &__blkpts[id-1];
  404543:	41 8d 44 24 ff       	lea    eax,[r12-0x1]
  404548:	48 c1 e0 05          	shl    rax,0x5
	m->id    = id;
  40454c:	44 89 a0 e0 86 5c 00 	mov    DWORD PTR [rax+0x5c86e0],r12d
	m->epoch = 0;
  404553:	48 c7 80 e8 86 5c 00 	mov    QWORD PTR [rax+0x5c86e8],0x0
  40455a:	00 00 00 00 
	h->head = NULL;
  40455e:	48 c7 80 f0 86 5c 00 	mov    QWORD PTR [rax+0x5c86f0],0x0
  404565:	00 00 00 00 
{ l->o = 0; }
  404569:	48 c7 80 f8 86 5c 00 	mov    QWORD PTR [rax+0x5c86f8],0x0
  404570:	00 00 00 00 
	__blkpt_offset++;
  404574:	41 8d 44 24 01       	lea    eax,[r12+0x1]
  404579:	89 05 81 1a 02 00    	mov    DWORD PTR [rip+0x21a81],eax        # 426000 <__blkpt_offset>
  40457f:	0f 01 f9             	rdtscp 
	struct slm_cs *cs = &(slm_global()->lock);
  404582:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  404588:	48 8d 1c 89          	lea    rbx,[rcx+rcx*4]
  40458c:	48 c1 e3 06          	shl    rbx,0x6
  404590:	48 81 c3 00 65 71 00 	add    rbx,0x716500
	while (ret != 0) {
  404597:	eb 13                	jmp    4045ac <sched_blkpt_alloc+0x11c>
  404599:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  4045a0:	f0 48 0f b1 13       	lock cmpxchg QWORD PTR [rbx],rdx
  4045a5:	0f 94 c0             	sete   al
  4045a8:	84 c0                	test   al,al
  4045aa:	75 28                	jne    4045d4 <sched_blkpt_alloc+0x144>
		tok    = cos_sched_sync();
  4045ac:	e8 5f d5 00 00       	call   411b10 <cos_sched_sync>
  4045b1:	89 c1                	mov    ecx,eax
  4045b3:	48 8b 03             	mov    rax,QWORD PTR [rbx]
		if (unlikely(contention)) {
  4045b6:	48 89 c2             	mov    rdx,rax
  4045b9:	83 e2 01             	and    edx,0x1
  4045bc:	74 e2                	je     4045a0 <sched_blkpt_alloc+0x110>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  4045be:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  4045c1:	48 89 c2             	mov    rdx,rax
  4045c4:	48 89 df             	mov    rdi,rbx
  4045c7:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  4045cb:	e8 d0 0a 01 00       	call   4150a0 <slm_cs_exit_contention>
  4045d0:	85 c0                	test   eax,eax
  4045d2:	75 d8                	jne    4045ac <sched_blkpt_alloc+0x11c>
}
  4045d4:	44 89 e0             	mov    eax,r12d
  4045d7:	5b                   	pop    rbx
  4045d8:	41 5c                	pop    r12
  4045da:	5d                   	pop    rbp
  4045db:	c3                   	ret    
  4045dc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  4045e0:	be 59 00 00 00       	mov    esi,0x59
  4045e5:	bf 00 d1 41 00       	mov    edi,0x41d100
  4045ea:	e8 91 66 00 00       	call   40ac80 <cos_print_str>
	assert(current);
  4045ef:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4045f6:	00 00 00 00 
  4045fa:	0f 0b                	ud2    
  4045fc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  404600:	41 89 c0             	mov    r8d,eax
  404603:	4c 89 e2             	mov    rdx,r12
  404606:	48 89 c6             	mov    rsi,rax
  404609:	48 89 df             	mov    rdi,rbx
  40460c:	41 83 e0 01          	and    r8d,0x1
  404610:	e8 2b 0a 01 00       	call   415040 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  404615:	83 f8 f0             	cmp    eax,0xfffffff0
  404618:	0f 85 ed fe ff ff    	jne    40450b <sched_blkpt_alloc+0x7b>
  40461e:	be 59 00 00 00       	mov    esi,0x59
  404623:	bf 60 d1 41 00       	mov    edi,0x41d160
  404628:	e8 53 66 00 00       	call   40ac80 <cos_print_str>
  40462d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404634:	00 00 00 00 
  404638:	0f 0b                	ud2    
	if (!m) ERR_THROW(SCHED_BLKPT_NULL, unlock);
  40463a:	45 31 e4             	xor    r12d,r12d
  40463d:	e9 3d ff ff ff       	jmp    40457f <sched_blkpt_alloc+0xef>
  404642:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  404649:	00 00 00 00 
  40464d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000404650 <sched_blkpt_free>:
  404650:	f3 0f 1e fa          	endbr64 
  404654:	31 c0                	xor    eax,eax
  404656:	c3                   	ret    
  404657:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40465e:	00 00 

0000000000404660 <sched_blkpt_trigger>:
{
  404660:	f3 0f 1e fa          	endbr64 
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  404664:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  404667:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  40466d:	49 89 f0             	mov    r8,rsi
  404670:	89 d1                	mov    ecx,edx
  404672:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  404679:	48 85 c0             	test   rax,rax
  40467c:	74 42                	je     4046c0 <sched_blkpt_trigger+0x60>
  40467e:	83 e8 01             	sub    eax,0x1
  404681:	3d c7 00 00 00       	cmp    eax,0xc7
  404686:	77 38                	ja     4046c0 <sched_blkpt_trigger+0x60>
  404688:	48 8b 14 c5 20 f7 5b 	mov    rdx,QWORD PTR [rax*8+0x5bf720]
  40468f:	00 
  404690:	31 f6                	xor    esi,esi
  404692:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  404699:	74 18                	je     4046b3 <sched_blkpt_trigger+0x53>
  40469b:	83 e2 01             	and    edx,0x1
  40469e:	75 13                	jne    4046b3 <sched_blkpt_trigger+0x53>
  4046a0:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  4046a4:	48 8d 34 50          	lea    rsi,[rax+rdx*2]
  4046a8:	48 c1 e6 04          	shl    rsi,0x4
  4046ac:	48 81 c6 60 fd 5b 00 	add    rsi,0x5bfd60
	return slm_blkpt_trigger(blkpt, current, epoch, single);
  4046b3:	4c 89 c2             	mov    rdx,r8
  4046b6:	e9 b5 c8 ff ff       	jmp    400f70 <slm_blkpt_trigger>
  4046bb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  4046c0:	31 f6                	xor    esi,esi
	return slm_blkpt_trigger(blkpt, current, epoch, single);
  4046c2:	4c 89 c2             	mov    rdx,r8
  4046c5:	e9 a6 c8 ff ff       	jmp    400f70 <slm_blkpt_trigger>
  4046ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000004046d0 <sched_blkpt_block>:
{
  4046d0:	f3 0f 1e fa          	endbr64 
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  4046d4:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  4046d7:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  4046dd:	49 89 f0             	mov    r8,rsi
  4046e0:	48 89 d1             	mov    rcx,rdx
  4046e3:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  4046ea:	48 85 c0             	test   rax,rax
  4046ed:	74 41                	je     404730 <sched_blkpt_block+0x60>
  4046ef:	83 e8 01             	sub    eax,0x1
  4046f2:	3d c7 00 00 00       	cmp    eax,0xc7
  4046f7:	77 37                	ja     404730 <sched_blkpt_block+0x60>
  4046f9:	48 8b 14 c5 20 f7 5b 	mov    rdx,QWORD PTR [rax*8+0x5bf720]
  404700:	00 
  404701:	31 f6                	xor    esi,esi
  404703:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  40470a:	74 18                	je     404724 <sched_blkpt_block+0x54>
  40470c:	83 e2 01             	and    edx,0x1
  40470f:	75 13                	jne    404724 <sched_blkpt_block+0x54>
  404711:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  404715:	48 8d 34 50          	lea    rsi,[rax+rdx*2]
  404719:	48 c1 e6 04          	shl    rsi,0x4
  40471d:	48 81 c6 60 fd 5b 00 	add    rsi,0x5bfd60
	return slm_blkpt_block(blkpt, current, epoch, dependency);
  404724:	4c 89 c2             	mov    rdx,r8
  404727:	e9 34 cd ff ff       	jmp    401460 <slm_blkpt_block>
  40472c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  404730:	31 f6                	xor    esi,esi
	return slm_blkpt_block(blkpt, current, epoch, dependency);
  404732:	4c 89 c2             	mov    rdx,r8
  404735:	e9 26 cd ff ff       	jmp    401460 <slm_blkpt_block>
  40473a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000404740 <syncipc_call>:
{
  404740:	f3 0f 1e fa          	endbr64 
  404744:	55                   	push   rbp
  404745:	66 48 0f 6e ce       	movq   xmm1,rsi
  40474a:	66 48 0f 6e d2       	movq   xmm2,rdx
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  40474f:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  404752:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  404758:	66 0f 6c ca          	punpcklqdq xmm1,xmm2
  40475c:	48 89 e5             	mov    rbp,rsp
  40475f:	41 57                	push   r15
  404761:	41 56                	push   r14
  404763:	49 89 ce             	mov    r14,rcx
  404766:	41 55                	push   r13
  404768:	4d 89 c5             	mov    r13,r8
  40476b:	41 54                	push   r12
  40476d:	53                   	push   rbx
  40476e:	48 83 ec 48          	sub    rsp,0x48
  404772:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
  404779:	0f 29 4d a0          	movaps XMMWORD PTR [rbp-0x60],xmm1
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  40477d:	48 85 c0             	test   rax,rax
  404780:	0f 84 92 01 00 00    	je     404918 <syncipc_call+0x1d8>
  404786:	83 e8 01             	sub    eax,0x1
  404789:	3d c7 00 00 00       	cmp    eax,0xc7
  40478e:	0f 87 84 01 00 00    	ja     404918 <syncipc_call+0x1d8>
  404794:	48 8b 14 c5 20 f7 5b 	mov    rdx,QWORD PTR [rax*8+0x5bf720]
  40479b:	00 
  40479c:	31 db                	xor    ebx,ebx
  40479e:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  4047a5:	0f 85 45 01 00 00    	jne    4048f0 <syncipc_call+0x1b0>
	counts[type]++;
  4047ab:	48 83 05 cd a6 1b 00 	add    QWORD PTR [rip+0x1ba6cd],0x1        # 5bee80 <counts>
  4047b2:	01 
	struct ipc_retvals retvals = { .ready = 0 };
  4047b3:	66 0f ef c0          	pxor   xmm0,xmm0
	if (ep->server == NULL) return -EAGAIN;
  4047b7:	48 83 3d 09 a7 1b 00 	cmp    QWORD PTR [rip+0x1ba709],0x0        # 5beec8 <eps+0x8>
  4047be:	00 
	struct ipc_retvals retvals = { .ready = 0 };
  4047bf:	48 c7 45 c0 00 00 00 	mov    QWORD PTR [rbp-0x40],0x0
  4047c6:	00 
  4047c7:	0f 29 45 b0          	movaps XMMWORD PTR [rbp-0x50],xmm0
	if (ep->server == NULL) return -EAGAIN;
  4047cb:	0f 84 78 02 00 00    	je     404a49 <syncipc_call+0x309>
		tok      = cos_sched_sync();
  4047d1:	e8 3a d3 00 00       	call   411b10 <cos_sched_sync>
		switchto = ps_load(&ep->server);
  4047d6:	4c 8b 3d eb a6 1b 00 	mov    r15,QWORD PTR [rip+0x1ba6eb]        # 5beec8 <eps+0x8>
		tok      = cos_sched_sync();
  4047dd:	41 89 c4             	mov    r12d,eax
  4047e0:	31 c0                	xor    eax,eax
  4047e2:	f0 48 0f b1 1d d5 a6 	lock cmpxchg QWORD PTR [rip+0x1ba6d5],rbx        # 5beec0 <eps>
  4047e9:	1b 00 
  4047eb:	0f 94 c0             	sete   al
		if (likely(ps_cas((unsigned long *)&ep->client, 0, (unsigned long)t))) {
  4047ee:	84 c0                	test   al,al
  4047f0:	0f 84 2a 01 00 00    	je     404920 <syncipc_call+0x1e0>
			ep->retvals = &retvals;
  4047f6:	48 8d 45 b0          	lea    rax,[rbp-0x50]
			ep->a0      = arg0;
  4047fa:	66 0f 6f 5d a0       	movdqa xmm3,XMMWORD PTR [rbp-0x60]
			ep->retvals = &retvals;
  4047ff:	48 89 05 da a6 1b 00 	mov    QWORD PTR [rip+0x1ba6da],rax        # 5beee0 <eps+0x20>
			assert(ps_load(&ep->client) == t);
  404806:	48 8b 05 b3 a6 1b 00 	mov    rax,QWORD PTR [rip+0x1ba6b3]        # 5beec0 <eps>
			ep->a0      = arg0;
  40480d:	0f 29 1d bc a6 1b 00 	movaps XMMWORD PTR [rip+0x1ba6bc],xmm3        # 5beed0 <eps+0x10>
			assert(ps_load(&ep->client) == t);
  404814:	48 39 d8             	cmp    rax,rbx
  404817:	0f 85 40 01 00 00    	jne    40495d <syncipc_call+0x21d>
		client = ps_load(&ep->client);
  40481d:	48 8b 05 9c a6 1b 00 	mov    rax,QWORD PTR [rip+0x1ba69c]        # 5beec0 <eps>
	__asm__ __volatile__("rdtsc" : "=a" (a), "=d" (d), "=c" (c) : : );
  404824:	0f 31                	rdtsc  
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  404826:	41 8b 47 04          	mov    eax,DWORD PTR [r15+0x4]
  40482a:	83 e8 02             	sub    eax,0x2
 * - `inherit_prio` - should `to` inherit `curr`'s priority?
 */
static inline int
slm_switch_to(struct slm_thd *curr, struct slm_thd *to, sched_tok_t tok, int inherit_prio)
{
	if (unlikely(!slm_state_is_runnable(to->state))) return 1;
  40482d:	83 f8 01             	cmp    eax,0x1
  404830:	0f 87 12 01 00 00    	ja     404948 <syncipc_call+0x208>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  404836:	e8 15 6d 00 00       	call   40b550 <cos_defcompinfo_curr_get>
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  40483b:	0f 01 f9             	rdtscp 
	*coreid = c & 0xFFF;
  40483e:	89 ca                	mov    edx,ecx
	timeout = g->timeout_next;
  404840:	81 e1 ff 0f 00 00    	and    ecx,0xfff
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  404846:	41 8b 3f             	mov    edi,DWORD PTR [r15]
	prio = inherit_prio ? curr->priority : t->priority;
  404849:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
	timeout = g->timeout_next;
  40484d:	48 8d 04 89          	lea    rax,[rcx+rcx*4]
  404851:	66 81 e2 ff 0f       	and    dx,0xfff
  404856:	49 89 c9             	mov    r9,rcx
  404859:	48 c1 e0 06          	shl    rax,0x6
  40485d:	48 05 00 65 71 00    	add    rax,0x716500
  404863:	4c 8b 80 08 01 00 00 	mov    r8,QWORD PTR [rax+0x108]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  40486a:	40 f6 c7 0b          	test   dil,0xb
  40486e:	0f 85 05 01 00 00    	jne    404979 <syncipc_call+0x239>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  404874:	49 8b 7f 10          	mov    rdi,QWORD PTR [r15+0x10]
  404878:	4c 89 c2             	mov    rdx,r8
  40487b:	44 89 e1             	mov    ecx,r12d
  40487e:	4c 89 4d 98          	mov    QWORD PTR [rbp-0x68],r9
  404882:	e8 19 7e 00 00       	call   40c6a0 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  404887:	4c 8b 4d 98          	mov    r9,QWORD PTR [rbp-0x68]
  40488b:	83 f8 ff             	cmp    eax,0xffffffff
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  40488e:	41 89 c0             	mov    r8d,eax
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  404891:	0f 84 2a 01 00 00    	je     4049c1 <syncipc_call+0x281>
		if (unlikely(ret)) {
  404897:	85 c0                	test   eax,eax
  404899:	40 0f 95 c6          	setne  sil
			if (ret != -EAGAIN) return ret;
  40489d:	83 f8 f5             	cmp    eax,0xfffffff5
  4048a0:	0f 95 c0             	setne  al
  4048a3:	21 c6                	and    esi,eax
  4048a5:	0f 31                	rdtsc  
	counts[type]++;
  4048a7:	48 83 05 d9 a5 1b 00 	add    QWORD PTR [rip+0x1ba5d9],0x1        # 5bee88 <counts+0x8>
  4048ae:	01 
			if (ret != -EAGAIN) return ret;
  4048af:	40 84 f6             	test   sil,sil
  4048b2:	75 25                	jne    4048d9 <syncipc_call+0x199>
		if (likely(ps_load(&retvals.ready))) break;
  4048b4:	8b 45 b0             	mov    eax,DWORD PTR [rbp-0x50]
  4048b7:	85 c0                	test   eax,eax
  4048b9:	0f 84 12 ff ff ff    	je     4047d1 <syncipc_call+0x91>
	*ret0 = ps_load(&retvals.r0);
  4048bf:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
	counts[type]++;
  4048c3:	48 83 05 c5 a5 1b 00 	add    QWORD PTR [rip+0x1ba5c5],0x1        # 5bee90 <counts+0x10>
  4048ca:	01 
	return 0;
  4048cb:	45 31 c0             	xor    r8d,r8d
	*ret0 = ps_load(&retvals.r0);
  4048ce:	49 89 06             	mov    QWORD PTR [r14],rax
	*ret1 = ps_load(&retvals.r1);
  4048d1:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
  4048d5:	49 89 45 00          	mov    QWORD PTR [r13+0x0],rax
}
  4048d9:	48 83 c4 48          	add    rsp,0x48
  4048dd:	44 89 c0             	mov    eax,r8d
  4048e0:	5b                   	pop    rbx
  4048e1:	41 5c                	pop    r12
  4048e3:	41 5d                	pop    r13
  4048e5:	41 5e                	pop    r14
  4048e7:	41 5f                	pop    r15
  4048e9:	5d                   	pop    rbp
  4048ea:	c3                   	ret    
  4048eb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  4048f0:	83 e2 01             	and    edx,0x1
  4048f3:	0f 85 b2 fe ff ff    	jne    4047ab <syncipc_call+0x6b>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  4048f9:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  4048fd:	48 8d 1c 50          	lea    rbx,[rax+rdx*2]
  404901:	48 c1 e3 04          	shl    rbx,0x4
  404905:	48 81 c3 60 fd 5b 00 	add    rbx,0x5bfd60
  40490c:	e9 9a fe ff ff       	jmp    4047ab <syncipc_call+0x6b>
  404911:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  404918:	31 db                	xor    ebx,ebx
  40491a:	e9 8c fe ff ff       	jmp    4047ab <syncipc_call+0x6b>
  40491f:	90                   	nop
		if (unlikely(ep->client != t && ep->retvals == NULL)) switchto = client;
  404920:	48 39 1d 99 a5 1b 00 	cmp    QWORD PTR [rip+0x1ba599],rbx        # 5beec0 <eps>
		client = ps_load(&ep->client);
  404927:	48 8b 05 92 a5 1b 00 	mov    rax,QWORD PTR [rip+0x1ba592]        # 5beec0 <eps>
		if (unlikely(ep->client != t && ep->retvals == NULL)) switchto = client;
  40492e:	0f 84 f0 fe ff ff    	je     404824 <syncipc_call+0xe4>
		client = ps_load(&ep->client);
  404934:	48 83 3d a4 a5 1b 00 	cmp    QWORD PTR [rip+0x1ba5a4],0x0        # 5beee0 <eps+0x20>
  40493b:	00 
  40493c:	4c 0f 44 f8          	cmove  r15,rax
  404940:	e9 df fe ff ff       	jmp    404824 <syncipc_call+0xe4>
  404945:	0f 1f 00             	nop    DWORD PTR [rax]
  404948:	0f 31                	rdtsc  
	counts[type]++;
  40494a:	48 83 05 36 a5 1b 00 	add    QWORD PTR [rip+0x1ba536],0x1        # 5bee88 <counts+0x8>
  404951:	01 
  404952:	41 b8 01 00 00 00    	mov    r8d,0x1
  404958:	e9 7c ff ff ff       	jmp    4048d9 <syncipc_call+0x199>
  40495d:	be 24 00 00 00       	mov    esi,0x24
  404962:	bf 50 d6 41 00       	mov    edi,0x41d650
  404967:	e8 14 63 00 00       	call   40ac80 <cos_print_str>
			assert(ps_load(&ep->client) == t);
  40496c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404973:	00 00 00 00 
  404977:	0f 0b                	ud2    
		if (t == &g->sched_thd) {
  404979:	0f b7 d2             	movzx  edx,dx
			timeout = TCAP_TIME_NIL;
  40497c:	31 c9                	xor    ecx,ecx
		if (t == &g->sched_thd) {
  40497e:	48 8d 14 92          	lea    rdx,[rdx+rdx*4]
  404982:	48 c1 e2 06          	shl    rdx,0x6
  404986:	48 81 c2 08 65 71 00 	add    rdx,0x716508
			timeout = TCAP_TIME_NIL;
  40498d:	49 39 d7             	cmp    r15,rdx
  404990:	49 0f 45 c8          	cmovne rcx,r8
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  404994:	40 f6 c7 02          	test   dil,0x2
  404998:	0f 85 96 00 00 00    	jne    404a34 <syncipc_call+0x2f4>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  40499e:	83 e7 01             	and    edi,0x1
  4049a1:	49 89 c8             	mov    r8,rcx
  4049a4:	0f 84 ca fe ff ff    	je     404874 <syncipc_call+0x134>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  4049aa:	4d 8b 5f 08          	mov    r11,QWORD PTR [r15+0x8]
  4049ae:	48 89 f2             	mov    rdx,rsi
  4049b1:	49 8b 7f 10          	mov    rdi,QWORD PTR [r15+0x10]
  4049b5:	45 89 e1             	mov    r9d,r12d
  4049b8:	4c 8b 40 28          	mov    r8,QWORD PTR [rax+0x28]
  4049bc:	4c 89 de             	mov    rsi,r11
  4049bf:	eb 58                	jmp    404a19 <syncipc_call+0x2d9>
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  4049c1:	0f 01 f9             	rdtscp 
	return t != &g->idle_thd && t != &g->sched_thd;
  4049c4:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  4049ca:	48 8d 04 89          	lea    rax,[rcx+rcx*4]
  4049ce:	48 c1 e0 06          	shl    rax,0x6
  4049d2:	48 8d 90 80 65 71 00 	lea    rdx,[rax+0x716580]
  4049d9:	49 39 d7             	cmp    r15,rdx
  4049dc:	74 1a                	je     4049f8 <syncipc_call+0x2b8>
  4049de:	48 05 08 65 71 00    	add    rax,0x716508
  4049e4:	49 39 c7             	cmp    r15,rax
  4049e7:	74 0f                	je     4049f8 <syncipc_call+0x2b8>
  4049e9:	0f 31                	rdtsc  
	counts[type]++;
  4049eb:	48 83 05 95 a4 1b 00 	add    QWORD PTR [rip+0x1ba495],0x1        # 5bee88 <counts+0x8>
  4049f2:	01 
			if (ret != -EAGAIN) return ret;
  4049f3:	e9 e1 fe ff ff       	jmp    4048d9 <syncipc_call+0x199>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  4049f8:	4b 8d 04 89          	lea    rax,[r9+r9*4]
  4049fc:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]
  404a00:	45 89 e1             	mov    r9d,r12d
  404a03:	31 c9                	xor    ecx,ecx
  404a05:	48 c1 e0 06          	shl    rax,0x6
  404a09:	31 f6                	xor    esi,esi
  404a0b:	4c 8b 80 28 65 71 00 	mov    r8,QWORD PTR [rax+0x716528]
  404a12:	48 8b b8 18 65 71 00 	mov    rdi,QWORD PTR [rax+0x716518]
  404a19:	e8 12 d1 00 00       	call   411b30 <cos_switch>
  404a1e:	83 f8 f5             	cmp    eax,0xfffffff5
  404a21:	41 89 c0             	mov    r8d,eax
  404a24:	40 0f 95 c6          	setne  sil
		if (unlikely(ret)) {
  404a28:	85 c0                	test   eax,eax
  404a2a:	0f 95 c0             	setne  al
			if (ret != -EAGAIN) return ret;
  404a2d:	21 c6                	and    esi,eax
  404a2f:	e9 71 fe ff ff       	jmp    4048a5 <syncipc_call+0x165>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  404a34:	49 8b 7f 28          	mov    rdi,QWORD PTR [r15+0x28]
  404a38:	48 8b 50 28          	mov    rdx,QWORD PTR [rax+0x28]
  404a3c:	44 89 e1             	mov    ecx,r12d
  404a3f:	4c 89 c6             	mov    rsi,r8
  404a42:	e8 59 d1 00 00       	call   411ba0 <cos_sched_asnd>
  404a47:	eb d5                	jmp    404a1e <syncipc_call+0x2de>
	if (ep->server == NULL) return -EAGAIN;
  404a49:	41 b8 f5 ff ff ff    	mov    r8d,0xfffffff5
  404a4f:	e9 85 fe ff ff       	jmp    4048d9 <syncipc_call+0x199>
  404a54:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  404a5b:	00 00 00 00 
  404a5f:	90                   	nop

0000000000404a60 <syncipc_reply_wait>:
{
  404a60:	f3 0f 1e fa          	endbr64 
  404a64:	55                   	push   rbp
  404a65:	66 48 0f 6e c6       	movq   xmm0,rsi
  404a6a:	66 48 0f 6e ca       	movq   xmm1,rdx
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  404a6f:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  404a72:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
  404a78:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  404a7c:	48 89 e5             	mov    rbp,rsp
  404a7f:	41 57                	push   r15
  404a81:	4d 89 c7             	mov    r15,r8
  404a84:	41 56                	push   r14
  404a86:	41 55                	push   r13
  404a88:	41 54                	push   r12
  404a8a:	53                   	push   rbx
  404a8b:	48 83 ec 18          	sub    rsp,0x18
  404a8f:	0f b7 80 f0 1f 00 00 	movzx  eax,WORD PTR [rax+0x1ff0]
  404a96:	48 89 4d c8          	mov    QWORD PTR [rbp-0x38],rcx
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  404a9a:	48 85 c0             	test   rax,rax
  404a9d:	0f 84 8d 02 00 00    	je     404d30 <syncipc_reply_wait+0x2d0>
  404aa3:	83 e8 01             	sub    eax,0x1
  404aa6:	3d c7 00 00 00       	cmp    eax,0xc7
  404aab:	0f 87 7f 02 00 00    	ja     404d30 <syncipc_reply_wait+0x2d0>
  404ab1:	48 8b 14 c5 20 f7 5b 	mov    rdx,QWORD PTR [rax*8+0x5bf720]
  404ab8:	00 
  404ab9:	45 31 ed             	xor    r13d,r13d
  404abc:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  404ac3:	0f 85 c7 01 00 00    	jne    404c90 <syncipc_reply_wait+0x230>
	if (unlikely(ep->server != t)) {
  404ac9:	48 8b 05 f8 a3 1b 00 	mov    rax,QWORD PTR [rip+0x1ba3f8]        # 5beec8 <eps+0x8>
  404ad0:	4c 39 e8             	cmp    rax,r13
  404ad3:	0f 85 e3 01 00 00    	jne    404cbc <syncipc_reply_wait+0x25c>
	ep->retvals->r0    = arg0;
  404ad9:	48 8b 05 00 a4 1b 00 	mov    rax,QWORD PTR [rip+0x1ba400]        # 5beee0 <eps+0x20>
	counts[type]++;
  404ae0:	48 83 05 b0 a3 1b 00 	add    QWORD PTR [rip+0x1ba3b0],0x1        # 5bee98 <counts+0x18>
  404ae7:	01 
	client             = ps_load(&ep->client);
  404ae8:	48 8b 1d d1 a3 1b 00 	mov    rbx,QWORD PTR [rip+0x1ba3d1]        # 5beec0 <eps>
	ep->retvals->r0    = arg0;
  404aef:	0f 11 40 08          	movups XMMWORD PTR [rax+0x8],xmm0
	ep->retvals->ready = 1;
  404af3:	c7 00 01 00 00 00    	mov    DWORD PTR [rax],0x1
	ep->retvals       = NULL;
  404af9:	48 c7 05 dc a3 1b 00 	mov    QWORD PTR [rip+0x1ba3dc],0x0        # 5beee0 <eps+0x20>
  404b00:	00 00 00 00 
	ep->client        = NULL;
  404b04:	48 c7 05 b1 a3 1b 00 	mov    QWORD PTR [rip+0x1ba3b1],0x0        # 5beec0 <eps>
  404b0b:	00 00 00 00 
  404b0f:	0f 31                	rdtsc  
		ret = slm_switch_to(t, client, cos_sched_sync(), 1);
  404b11:	e8 fa cf 00 00       	call   411b10 <cos_sched_sync>
  404b16:	41 89 c4             	mov    r12d,eax
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  404b19:	8b 43 04             	mov    eax,DWORD PTR [rbx+0x4]
  404b1c:	83 e8 02             	sub    eax,0x2
  404b1f:	83 f8 01             	cmp    eax,0x1
  404b22:	0f 87 b8 00 00 00    	ja     404be0 <syncipc_reply_wait+0x180>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  404b28:	e8 23 6a 00 00       	call   40b550 <cos_defcompinfo_curr_get>
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  404b2d:	0f 01 f9             	rdtscp 
	*coreid = c & 0xFFF;
  404b30:	89 cf                	mov    edi,ecx
	timeout = g->timeout_next;
  404b32:	81 e1 ff 0f 00 00    	and    ecx,0xfff
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  404b38:	8b 13                	mov    edx,DWORD PTR [rbx]
	prio = inherit_prio ? curr->priority : t->priority;
  404b3a:	49 8b 75 30          	mov    rsi,QWORD PTR [r13+0x30]
	timeout = g->timeout_next;
  404b3e:	48 8d 04 89          	lea    rax,[rcx+rcx*4]
  404b42:	66 81 e7 ff 0f       	and    di,0xfff
  404b47:	49 89 ce             	mov    r14,rcx
  404b4a:	48 c1 e0 06          	shl    rax,0x6
  404b4e:	48 05 00 65 71 00    	add    rax,0x716500
  404b54:	4c 8b 80 08 01 00 00 	mov    r8,QWORD PTR [rax+0x108]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  404b5b:	f6 c2 0b             	test   dl,0xb
  404b5e:	0f 85 9c 00 00 00    	jne    404c00 <syncipc_reply_wait+0x1a0>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  404b64:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  404b68:	4c 89 c2             	mov    rdx,r8
  404b6b:	44 89 e1             	mov    ecx,r12d
  404b6e:	e8 2d 7b 00 00       	call   40c6a0 <cos_defswitch>
  404b73:	41 89 c0             	mov    r8d,eax
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  404b76:	83 f8 ff             	cmp    eax,0xffffffff
  404b79:	0f 84 d9 00 00 00    	je     404c58 <syncipc_reply_wait+0x1f8>
  404b7f:	0f 31                	rdtsc  
		if (unlikely(ret) && ret != -EAGAIN) return ret;
  404b81:	45 85 c0             	test   r8d,r8d
  404b84:	75 64                	jne    404bea <syncipc_reply_wait+0x18a>
	counts[type]++;
  404b86:	66 0f 6f 05 62 8b 01 	movdqa xmm0,XMMWORD PTR [rip+0x18b62]        # 41d6f0 <__unlock+0xbf0>
  404b8d:	00 
  404b8e:	66 0f d4 05 0a a3 1b 	paddq  xmm0,XMMWORD PTR [rip+0x1ba30a]        # 5beea0 <counts+0x20>
  404b95:	00 
  404b96:	0f 29 05 03 a3 1b 00 	movaps XMMWORD PTR [rip+0x1ba303],xmm0        # 5beea0 <counts+0x20>
  404b9d:	0f 1f 00             	nop    DWORD PTR [rax]
	while (ps_load(&ep->client) == NULL) ;
  404ba0:	48 8b 05 19 a3 1b 00 	mov    rax,QWORD PTR [rip+0x1ba319]        # 5beec0 <eps>
  404ba7:	48 85 c0             	test   rax,rax
  404baa:	74 f4                	je     404ba0 <syncipc_reply_wait+0x140>
	*ret0 = ep->a0;
  404bac:	48 8b 05 1d a3 1b 00 	mov    rax,QWORD PTR [rip+0x1ba31d]        # 5beed0 <eps+0x10>
  404bb3:	48 8b 75 c8          	mov    rsi,QWORD PTR [rbp-0x38]
  404bb7:	48 89 06             	mov    QWORD PTR [rsi],rax
	*ret1 = ep->a1;
  404bba:	48 8b 05 17 a3 1b 00 	mov    rax,QWORD PTR [rip+0x1ba317]        # 5beed8 <eps+0x18>
  404bc1:	49 89 07             	mov    QWORD PTR [r15],rax
	counts[type]++;
  404bc4:	48 83 05 e4 a2 1b 00 	add    QWORD PTR [rip+0x1ba2e4],0x1        # 5beeb0 <counts+0x30>
  404bcb:	01 
}
  404bcc:	48 83 c4 18          	add    rsp,0x18
  404bd0:	44 89 c0             	mov    eax,r8d
  404bd3:	5b                   	pop    rbx
  404bd4:	41 5c                	pop    r12
  404bd6:	41 5d                	pop    r13
  404bd8:	41 5e                	pop    r14
  404bda:	41 5f                	pop    r15
  404bdc:	5d                   	pop    rbp
  404bdd:	c3                   	ret    
  404bde:	66 90                	xchg   ax,ax
  404be0:	0f 31                	rdtsc  
  404be2:	41 b8 01 00 00 00    	mov    r8d,0x1
  404be8:	eb e2                	jmp    404bcc <syncipc_reply_wait+0x16c>
		if (unlikely(ret) && ret != -EAGAIN) return ret;
  404bea:	41 83 f8 f5          	cmp    r8d,0xfffffff5
  404bee:	75 dc                	jne    404bcc <syncipc_reply_wait+0x16c>
	counts[type]++;
  404bf0:	48 83 05 a8 a2 1b 00 	add    QWORD PTR [rip+0x1ba2a8],0x1        # 5beea0 <counts+0x20>
  404bf7:	01 
	} while (ret == -EAGAIN);
  404bf8:	e9 12 ff ff ff       	jmp    404b0f <syncipc_reply_wait+0xaf>
  404bfd:	0f 1f 00             	nop    DWORD PTR [rax]
		if (t == &g->sched_thd) {
  404c00:	0f b7 ff             	movzx  edi,di
  404c03:	48 8d 0c bf          	lea    rcx,[rdi+rdi*4]
  404c07:	48 c1 e1 06          	shl    rcx,0x6
  404c0b:	48 81 c1 08 65 71 00 	add    rcx,0x716508
			timeout = TCAP_TIME_NIL;
  404c12:	48 39 cb             	cmp    rbx,rcx
  404c15:	b9 00 00 00 00       	mov    ecx,0x0
  404c1a:	49 0f 45 c8          	cmovne rcx,r8
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  404c1e:	f6 c2 02             	test   dl,0x2
  404c21:	0f 85 19 01 00 00    	jne    404d40 <syncipc_reply_wait+0x2e0>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  404c27:	83 e2 01             	and    edx,0x1
  404c2a:	49 89 c8             	mov    r8,rcx
  404c2d:	0f 84 31 ff ff ff    	je     404b64 <syncipc_reply_wait+0x104>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  404c33:	4c 8b 53 08          	mov    r10,QWORD PTR [rbx+0x8]
  404c37:	4c 8b 40 28          	mov    r8,QWORD PTR [rax+0x28]
  404c3b:	48 89 f2             	mov    rdx,rsi
  404c3e:	45 89 e1             	mov    r9d,r12d
  404c41:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  404c45:	4c 89 d6             	mov    rsi,r10
  404c48:	e8 e3 ce 00 00       	call   411b30 <cos_switch>
  404c4d:	41 89 c0             	mov    r8d,eax
  404c50:	e9 2a ff ff ff       	jmp    404b7f <syncipc_reply_wait+0x11f>
  404c55:	0f 1f 00             	nop    DWORD PTR [rax]
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  404c58:	0f 01 f9             	rdtscp 
	return t != &g->idle_thd && t != &g->sched_thd;
  404c5b:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  404c61:	48 8d 04 89          	lea    rax,[rcx+rcx*4]
  404c65:	48 c1 e0 06          	shl    rax,0x6
  404c69:	48 8d 90 80 65 71 00 	lea    rdx,[rax+0x716580]
  404c70:	48 39 d3             	cmp    rbx,rdx
  404c73:	0f 84 e7 00 00 00    	je     404d60 <syncipc_reply_wait+0x300>
  404c79:	48 05 08 65 71 00    	add    rax,0x716508
  404c7f:	48 39 c3             	cmp    rbx,rax
  404c82:	0f 84 d8 00 00 00    	je     404d60 <syncipc_reply_wait+0x300>
  404c88:	0f 31                	rdtsc  
		if (unlikely(ret) && ret != -EAGAIN) return ret;
  404c8a:	e9 3d ff ff ff       	jmp    404bcc <syncipc_reply_wait+0x16c>
  404c8f:	90                   	nop
  404c90:	83 e2 01             	and    edx,0x1
  404c93:	0f 85 30 fe ff ff    	jne    404ac9 <syncipc_reply_wait+0x69>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  404c99:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  404c9d:	4c 8d 2c 50          	lea    r13,[rax+rdx*2]
	if (unlikely(ep->server != t)) {
  404ca1:	48 8b 05 20 a2 1b 00 	mov    rax,QWORD PTR [rip+0x1ba220]        # 5beec8 <eps+0x8>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  404ca8:	49 c1 e5 04          	shl    r13,0x4
  404cac:	49 81 c5 60 fd 5b 00 	add    r13,0x5bfd60
	if (unlikely(ep->server != t)) {
  404cb3:	4c 39 e8             	cmp    rax,r13
  404cb6:	0f 84 1d fe ff ff    	je     404ad9 <syncipc_reply_wait+0x79>
		if (ep->server != NULL)         return -1;
  404cbc:	48 85 c0             	test   rax,rax
  404cbf:	0f 85 01 01 00 00    	jne    404dc6 <syncipc_reply_wait+0x366>
        __asm__ __volatile__("lock " PS_CAS_STR
  404cc5:	f0 4c 0f b1 2d fa a1 	lock cmpxchg QWORD PTR [rip+0x1ba1fa],r13        # 5beec8 <eps+0x8>
  404ccc:	1b 00 
  404cce:	0f 94 c0             	sete   al
		if (!ps_cas((unsigned long *)&ep->server, 0, (unsigned long)t)) return -1;
  404cd1:	84 c0                	test   al,al
  404cd3:	0f 84 ed 00 00 00    	je     404dc6 <syncipc_reply_wait+0x366>
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  404cd9:	31 d2                	xor    edx,edx
  404cdb:	be 0b 00 00 00       	mov    esi,0xb
  404ce0:	4c 89 ef             	mov    rdi,r13
  404ce3:	e8 b8 f0 00 00       	call   413da0 <slm_sched_fprr_thd_update>
  404ce8:	41 89 c0             	mov    r8d,eax
		assert(ret == 0);
  404ceb:	85 c0                	test   eax,eax
  404ced:	0f 85 9b 00 00 00    	jne    404d8e <syncipc_reply_wait+0x32e>
		assert(ep->server == t);
  404cf3:	4c 39 2d ce a1 1b 00 	cmp    QWORD PTR [rip+0x1ba1ce],r13        # 5beec8 <eps+0x8>
  404cfa:	0f 85 aa 00 00 00    	jne    404daa <syncipc_reply_wait+0x34a>
		while (ps_load(&ep->client) == NULL) ;
  404d00:	48 8b 05 b9 a1 1b 00 	mov    rax,QWORD PTR [rip+0x1ba1b9]        # 5beec0 <eps>
  404d07:	48 85 c0             	test   rax,rax
  404d0a:	74 f4                	je     404d00 <syncipc_reply_wait+0x2a0>
		*ret0 = ep->a0;
  404d0c:	48 8b 05 bd a1 1b 00 	mov    rax,QWORD PTR [rip+0x1ba1bd]        # 5beed0 <eps+0x10>
  404d13:	48 8b 75 c8          	mov    rsi,QWORD PTR [rbp-0x38]
  404d17:	48 89 06             	mov    QWORD PTR [rsi],rax
		*ret1 = ep->a1;
  404d1a:	48 8b 05 b7 a1 1b 00 	mov    rax,QWORD PTR [rip+0x1ba1b7]        # 5beed8 <eps+0x18>
  404d21:	49 89 07             	mov    QWORD PTR [r15],rax
		return 0;
  404d24:	e9 a3 fe ff ff       	jmp    404bcc <syncipc_reply_wait+0x16c>
  404d29:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  404d30:	45 31 ed             	xor    r13d,r13d
  404d33:	e9 91 fd ff ff       	jmp    404ac9 <syncipc_reply_wait+0x69>
  404d38:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  404d3f:	00 
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  404d40:	48 8b 7b 28          	mov    rdi,QWORD PTR [rbx+0x28]
  404d44:	48 8b 50 28          	mov    rdx,QWORD PTR [rax+0x28]
  404d48:	4c 89 c6             	mov    rsi,r8
  404d4b:	44 89 e1             	mov    ecx,r12d
  404d4e:	e8 4d ce 00 00       	call   411ba0 <cos_sched_asnd>
  404d53:	41 89 c0             	mov    r8d,eax
  404d56:	e9 24 fe ff ff       	jmp    404b7f <syncipc_reply_wait+0x11f>
  404d5b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  404d60:	4b 8d 04 b6          	lea    rax,[r14+r14*4]
  404d64:	49 8b 55 30          	mov    rdx,QWORD PTR [r13+0x30]
  404d68:	45 89 e1             	mov    r9d,r12d
  404d6b:	31 c9                	xor    ecx,ecx
  404d6d:	48 c1 e0 06          	shl    rax,0x6
  404d71:	31 f6                	xor    esi,esi
  404d73:	4c 8b 80 28 65 71 00 	mov    r8,QWORD PTR [rax+0x716528]
  404d7a:	48 8b b8 18 65 71 00 	mov    rdi,QWORD PTR [rax+0x716518]
  404d81:	e8 aa cd 00 00       	call   411b30 <cos_switch>
  404d86:	41 89 c0             	mov    r8d,eax
  404d89:	e9 f1 fd ff ff       	jmp    404b7f <syncipc_reply_wait+0x11f>
  404d8e:	be 24 00 00 00       	mov    esi,0x24
  404d93:	bf 78 d6 41 00       	mov    edi,0x41d678
  404d98:	e8 e3 5e 00 00       	call   40ac80 <cos_print_str>
		assert(ret == 0);
  404d9d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404da4:	00 00 00 00 
  404da8:	0f 0b                	ud2    
  404daa:	be 24 00 00 00       	mov    esi,0x24
  404daf:	bf a0 d6 41 00       	mov    edi,0x41d6a0
  404db4:	e8 c7 5e 00 00       	call   40ac80 <cos_print_str>
		assert(ep->server == t);
  404db9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  404dc0:	00 00 00 00 
  404dc4:	0f 0b                	ud2    
		if (ep->server != NULL)         return -1;
  404dc6:	41 b8 ff ff ff ff    	mov    r8d,0xffffffff
  404dcc:	e9 fb fd ff ff       	jmp    404bcc <syncipc_reply_wait+0x16c>
  404dd1:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  404dd8:	00 00 00 00 
  404ddc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000404de0 <sched_aep_create_closure>:
{
  404de0:	f3 0f 1e fa          	endbr64 
}
  404de4:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
  404deb:	c3                   	ret    
  404dec:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000404df0 <sched_get_cpu_freq>:
{
  404df0:	f3 0f 1e fa          	endbr64 
	return slm_get_cycs_per_usec();
  404df4:	e9 b7 10 01 00       	jmp    415eb0 <slm_get_cycs_per_usec>
  404df9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000404e00 <slm_ipithd_create>:
{
  404e00:	f3 0f 1e fa          	endbr64 
  404e04:	55                   	push   rbp
  404e05:	48 89 e5             	mov    rbp,rsp
  404e08:	41 57                	push   r15
  404e0a:	49 89 ff             	mov    r15,rdi
  404e0d:	41 56                	push   r14
  404e0f:	49 89 f6             	mov    r14,rsi
  404e12:	41 55                	push   r13
  404e14:	49 89 cd             	mov    r13,rcx
  404e17:	41 54                	push   r12
  404e19:	41 89 d4             	mov    r12d,edx
  404e1c:	53                   	push   rbx
  404e1d:	48 83 ec 28          	sub    rsp,0x28
  404e21:	4c 89 45 b8          	mov    QWORD PTR [rbp-0x48],r8
  404e25:	0f 01 f9             	rdtscp 
	struct slm_ipi_percore   *ipi_data = slm_ipi_percore_get(cos_cpuid());
  404e28:	89 cf                	mov    edi,ecx
  404e2a:	81 e7 ff 0f 00 00    	and    edi,0xfff
  404e30:	e8 5b 00 01 00       	call   414e90 <slm_ipi_percore_get>
  404e35:	48 89 c3             	mov    rbx,rax
  404e38:	0f 01 f9             	rdtscp 
  404e3b:	48 89 4d b0          	mov    QWORD PTR [rbp-0x50],rcx
	r->rcv = capmgr_rcv_alloc(fn, data, flags, &r->asnd, &_thd, &_tid);
  404e3f:	4c 8d 4d c8          	lea    r9,[rbp-0x38]
  404e43:	48 8d 4b 08          	lea    rcx,[rbx+0x8]
  404e47:	44 89 e2             	mov    edx,r12d
  404e4a:	4c 8d 45 c0          	lea    r8,[rbp-0x40]
  404e4e:	4c 89 f6             	mov    rsi,r14
  404e51:	4c 89 ff             	mov    rdi,r15
  404e54:	e8 77 5b 00 00       	call   40a9d0 <capmgr_rcv_alloc>
  404e59:	48 89 03             	mov    QWORD PTR [rbx],rax
  404e5c:	0f 01 f9             	rdtscp 
	r->tid = _tid;
  404e5f:	48 8b 75 c8          	mov    rsi,QWORD PTR [rbp-0x38]
	t = slm_thd_mem_alloc(_thd, _tid, thdcap, tid);
  404e63:	4c 8b 45 c0          	mov    r8,QWORD PTR [rbp-0x40]
	r->cpuid = cos_cpuid();
  404e67:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  404e6d:	89 4b 10             	mov    DWORD PTR [rbx+0x10],ecx
	r->tid = _tid;
  404e70:	66 49 0f 6e c0       	movq   xmm0,r8
  404e75:	66 48 0f 6e ce       	movq   xmm1,rsi
  404e7a:	48 89 73 18          	mov    QWORD PTR [rbx+0x18],rsi
	t = slm_thd_mem_alloc(_thd, _tid, thdcap, tid);
  404e7e:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  404e82:	85 f6                	test   esi,esi
  404e84:	0f 84 c6 01 00 00    	je     405050 <slm_ipithd_create+0x250>
  404e8a:	8d 56 ff             	lea    edx,[rsi-0x1]
  404e8d:	81 fa c7 00 00 00    	cmp    edx,0xc7
  404e93:	0f 87 b7 01 00 00    	ja     405050 <slm_ipithd_create+0x250>
	if (*state != SS_STATE_FREE ||
  404e99:	48 83 3c d5 20 f7 5b 	cmp    QWORD PTR [rdx*8+0x5bf720],0x0
  404ea0:	00 00 
  404ea2:	0f 85 a8 01 00 00    	jne    405050 <slm_ipithd_create+0x250>
  404ea8:	45 31 c9             	xor    r9d,r9d
  404eab:	b9 01 00 00 00       	mov    ecx,0x1
  404eb0:	4c 89 c8             	mov    rax,r9
  404eb3:	f0 48 0f b1 0c d5 20 	lock cmpxchg QWORD PTR [rdx*8+0x5bf720],rcx
  404eba:	f7 5b 00 
  404ebd:	0f 94 c0             	sete   al
  404ec0:	84 c0                	test   al,al
  404ec2:	0f 84 88 01 00 00    	je     405050 <slm_ipithd_create+0x250>
  404ec8:	48 8d 04 92          	lea    rax,[rdx+rdx*4]
  404ecc:	b9 16 00 00 00       	mov    ecx,0x16
  404ed1:	48 8d 14 42          	lea    rdx,[rdx+rax*2]
  404ed5:	4c 89 c8             	mov    rax,r9
  404ed8:	48 c1 e2 04          	shl    rdx,0x4
  404edc:	4c 8d ba 60 fd 5b 00 	lea    r15,[rdx+0x5bfd60]
  404ee3:	4c 89 ff             	mov    rdi,r15
  404ee6:	f3 48 ab             	rep stos QWORD PTR es:[rdi],rax
	assert(_cap != 0 && _tid != 0);
  404ee9:	4d 85 c0             	test   r8,r8
  404eec:	0f 84 9b 01 00 00    	je     40508d <slm_ipithd_create+0x28d>
	struct slm_thd           *current = &g->sched_thd;
  404ef2:	4c 8b 75 b0          	mov    r14,QWORD PTR [rbp-0x50]
	t->resources = (struct slm_resources_thd) {
  404ef6:	48 8b 05 43 41 02 00 	mov    rax,QWORD PTR [rip+0x24143]        # 429040 <__cosrt_comp_info+0x40>
  404efd:	0f 11 82 f8 fd 5b 00 	movups XMMWORD PTR [rdx+0x5bfdf8],xmm0
	struct slm_thd           *current = &g->sched_thd;
  404f04:	41 81 e6 ff 0f 00 00 	and    r14d,0xfff
	t->resources = (struct slm_resources_thd) {
  404f0b:	48 89 82 08 fe 5b 00 	mov    QWORD PTR [rdx+0x5bfe08],rax
	*tid = _tid;
  404f12:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
	struct slm_thd           *current = &g->sched_thd;
  404f16:	4b 8d 1c b6          	lea    rbx,[r14+r14*4]
	*thd = _cap;
  404f1a:	4d 89 45 00          	mov    QWORD PTR [r13+0x0],r8
	struct slm_thd           *current = &g->sched_thd;
  404f1e:	48 c1 e3 06          	shl    rbx,0x6
	*tid = _tid;
  404f22:	48 89 30             	mov    QWORD PTR [rax],rsi
	struct slm_thd           *current = &g->sched_thd;
  404f25:	48 81 c3 08 65 71 00 	add    rbx,0x716508
  404f2c:	0f 01 f9             	rdtscp 
	cs = &(slm_global()->lock);
  404f2f:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  404f35:	4c 8d 24 89          	lea    r12,[rcx+rcx*4]
  404f39:	49 c1 e4 06          	shl    r12,0x6
  404f3d:	49 81 c4 00 65 71 00 	add    r12,0x716500
		tok    = cos_sched_sync();
  404f44:	e8 c7 cb 00 00       	call   411b10 <cos_sched_sync>
  404f49:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  404f4c:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
		if (unlikely(owner)) {
  404f50:	48 89 c1             	mov    rcx,rax
  404f53:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  404f57:	0f 85 4c 01 00 00    	jne    4050a9 <slm_ipithd_create+0x2a9>
  404f5d:	f0 49 0f b1 1c 24    	lock cmpxchg QWORD PTR [r12],rbx
  404f63:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  404f66:	84 c0                	test   al,al
  404f68:	74 da                	je     404f44 <slm_ipithd_create+0x144>
	if (slm_thd_init(thd, _thd, _tid)) ERR_THROW(NULL, free);
  404f6a:	48 8b 55 c8          	mov    rdx,QWORD PTR [rbp-0x38]
  404f6e:	48 8b 75 c0          	mov    rsi,QWORD PTR [rbp-0x40]
  404f72:	4c 89 ff             	mov    rdi,r15
  404f75:	e8 b6 ff 00 00       	call   414f30 <slm_thd_init>
  404f7a:	85 c0                	test   eax,eax
  404f7c:	0f 85 ea 00 00 00    	jne    40506c <slm_ipithd_create+0x26c>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  404f82:	49 81 ff 60 fd 5b 00 	cmp    r15,0x5bfd60
  404f89:	0f 82 e2 00 00 00    	jb     405071 <slm_ipithd_create+0x271>
  404f8f:	49 81 ff 30 86 5c 00 	cmp    r15,0x5c8630
  404f96:	0f 87 d5 00 00 00    	ja     405071 <slm_ipithd_create+0x271>
  404f9c:	4c 89 f8             	mov    rax,r15
  404f9f:	48 2d 60 fd 5b 00    	sub    rax,0x5bfd60
  404fa5:	48 c1 f8 04          	sar    rax,0x4
	*state = val | (*state & 1);
  404fa9:	69 c0 a3 8b 2e ba    	imul   eax,eax,0xba2e8ba3
  404faf:	48 8b 14 c5 20 f7 5b 	mov    rdx,QWORD PTR [rax*8+0x5bf720]
  404fb6:	00 
  404fb7:	48 83 ca fe          	or     rdx,0xfffffffffffffffe
  404fbb:	48 89 14 c5 20 f7 5b 	mov    QWORD PTR [rax*8+0x5bf720],rdx
  404fc2:	00 
	assert((*state & 1) == SS_STATE_CONS);
  404fc3:	48 83 fa ff          	cmp    rdx,0xffffffffffffffff
  404fc7:	0f 85 32 01 00 00    	jne    4050ff <slm_ipithd_create+0x2ff>
	*state &= ~SS_STATE_CONS;
  404fcd:	48 c7 04 c5 20 f7 5b 	mov    QWORD PTR [rax*8+0x5bf720],0xfffffffffffffffe
  404fd4:	00 fe ff ff ff 
{ __asm__ __volatile__("mfence" ::: "memory"); }
  404fd9:	0f ae f0             	mfence 
	assert(*state != 0);
  404fdc:	48 83 3c c5 20 f7 5b 	cmp    QWORD PTR [rax*8+0x5bf720],0x0
  404fe3:	00 00 
  404fe5:	0f 84 f8 00 00 00    	je     4050e3 <slm_ipithd_create+0x2e3>
  404feb:	0f 01 f9             	rdtscp 
	struct slm_cs *cs = &(slm_global()->lock);
  404fee:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  404ff4:	48 8d 1c 89          	lea    rbx,[rcx+rcx*4]
  404ff8:	48 c1 e3 06          	shl    rbx,0x6
  404ffc:	48 81 c3 00 65 71 00 	add    rbx,0x716500
	while (ret != 0) {
  405003:	eb 0f                	jmp    405014 <slm_ipithd_create+0x214>
  405005:	0f 1f 00             	nop    DWORD PTR [rax]
        __asm__ __volatile__("lock " PS_CAS_STR
  405008:	f0 48 0f b1 13       	lock cmpxchg QWORD PTR [rbx],rdx
  40500d:	0f 94 c0             	sete   al
  405010:	84 c0                	test   al,al
  405012:	75 28                	jne    40503c <slm_ipithd_create+0x23c>
		tok    = cos_sched_sync();
  405014:	e8 f7 ca 00 00       	call   411b10 <cos_sched_sync>
  405019:	89 c1                	mov    ecx,eax
  40501b:	48 8b 03             	mov    rax,QWORD PTR [rbx]
		if (unlikely(contention)) {
  40501e:	48 89 c2             	mov    rdx,rax
  405021:	83 e2 01             	and    edx,0x1
  405024:	74 e2                	je     405008 <slm_ipithd_create+0x208>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  405026:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  405029:	48 89 c2             	mov    rdx,rax
  40502c:	48 89 df             	mov    rdi,rbx
  40502f:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  405033:	e8 68 00 01 00       	call   4150a0 <slm_cs_exit_contention>
  405038:	85 c0                	test   eax,eax
  40503a:	75 d8                	jne    405014 <slm_ipithd_create+0x214>
}
  40503c:	48 83 c4 28          	add    rsp,0x28
  405040:	4c 89 f8             	mov    rax,r15
  405043:	5b                   	pop    rbx
  405044:	41 5c                	pop    r12
  405046:	41 5d                	pop    r13
  405048:	41 5e                	pop    r14
  40504a:	41 5f                	pop    r15
  40504c:	5d                   	pop    rbp
  40504d:	c3                   	ret    
  40504e:	66 90                	xchg   ax,ax
  405050:	be 23 00 00 00       	mov    esi,0x23
  405055:	bf d0 d4 41 00       	mov    edi,0x41d4d0
  40505a:	e8 21 5c 00 00       	call   40ac80 <cos_print_str>
	if (!t) assert(0);
  40505f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  405066:	00 00 00 00 
  40506a:	0f 0b                	ud2    
	ret = NULL;
  40506c:	45 31 ff             	xor    r15d,r15d
	return ret;
  40506f:	eb cb                	jmp    40503c <slm_ipithd_create+0x23c>
  405071:	be 23 00 00 00       	mov    esi,0x23
  405076:	bf a8 d4 41 00       	mov    edi,0x41d4a8
  40507b:	e8 00 5c 00 00       	call   40ac80 <cos_print_str>
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  405080:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  405087:	00 00 00 00 
  40508b:	0f 0b                	ud2    
  40508d:	be 23 00 00 00       	mov    esi,0x23
  405092:	bf f8 d4 41 00       	mov    edi,0x41d4f8
  405097:	e8 e4 5b 00 00       	call   40ac80 <cos_print_str>
	assert(_cap != 0 && _tid != 0);
  40509c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4050a3:	00 00 00 00 
  4050a7:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  4050a9:	41 89 c0             	mov    r8d,eax
  4050ac:	48 89 da             	mov    rdx,rbx
  4050af:	48 89 c6             	mov    rsi,rax
  4050b2:	4c 89 e7             	mov    rdi,r12
  4050b5:	41 83 e0 01          	and    r8d,0x1
  4050b9:	e8 82 ff 00 00       	call   415040 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  4050be:	83 f8 f0             	cmp    eax,0xfffffff0
  4050c1:	0f 85 7d fe ff ff    	jne    404f44 <slm_ipithd_create+0x144>
  4050c7:	be 59 00 00 00       	mov    esi,0x59
  4050cc:	bf 60 d1 41 00       	mov    edi,0x41d160
  4050d1:	e8 aa 5b 00 00       	call   40ac80 <cos_print_str>
  4050d6:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4050dd:	00 00 00 00 
  4050e1:	0f 0b                	ud2    
  4050e3:	be 61 00 00 00       	mov    esi,0x61
  4050e8:	bf 88 d5 41 00       	mov    edi,0x41d588
  4050ed:	e8 8e 5b 00 00       	call   40ac80 <cos_print_str>
  4050f2:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4050f9:	00 00 00 00 
  4050fd:	0f 0b                	ud2    
  4050ff:	be 61 00 00 00       	mov    esi,0x61
  405104:	bf 20 d5 41 00       	mov    edi,0x41d520
  405109:	e8 72 5b 00 00       	call   40ac80 <cos_print_str>
	assert((*state & 1) == SS_STATE_CONS);
  40510e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  405115:	00 00 00 00 
  405119:	0f 0b                	ud2    
  40511b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000405120 <parallel_main>:

static coreid_t _init_core_id = 0;

void
parallel_main(coreid_t cid)
{
  405120:	f3 0f 1e fa          	endbr64 
	if (cid == _init_core_id) printc("Starting scheduler loop...\n");
  405124:	66 39 3d dd a5 1b 00 	cmp    WORD PTR [rip+0x1ba5dd],di        # 5bf708 <_init_core_id>
  40512b:	74 0b                	je     405138 <parallel_main+0x18>
	slm_sched_loop_nonblock();
  40512d:	e9 ae 0d 01 00       	jmp    415ee0 <slm_sched_loop_nonblock>
  405132:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
{
  405138:	55                   	push   rbp
	if (cid == _init_core_id) printc("Starting scheduler loop...\n");
  405139:	bf e0 d0 41 00       	mov    edi,0x41d0e0
  40513e:	31 c0                	xor    eax,eax
{
  405140:	48 89 e5             	mov    rbp,rsp
	if (cid == _init_core_id) printc("Starting scheduler loop...\n");
  405143:	e8 a8 b9 ff ff       	call   400af0 <printc.constprop.0>
}
  405148:	5d                   	pop    rbp
	slm_sched_loop_nonblock();
  405149:	e9 92 0d 01 00       	jmp    415ee0 <slm_sched_loop_nonblock>
  40514e:	66 90                	xchg   ax,ax

0000000000405150 <cos_parallel_init>:

void
cos_parallel_init(coreid_t cid, int init_core, int ncores)
{
  405150:	f3 0f 1e fa          	endbr64 
  405154:	55                   	push   rbp
  405155:	48 89 e5             	mov    rbp,rsp
  405158:	53                   	push   rbx
  405159:	48 83 ec 28          	sub    rsp,0x28
	struct slm_thd_container *t;
	struct slm_thd *r;
	thdcap_t thdcap, ipithdcap;
	arcvcap_t rcvcap;
	thdid_t tid, ipitid;
	if (init_core) {
  40515d:	85 f6                	test   esi,esi
  40515f:	74 07                	je     405168 <cos_parallel_init+0x18>
		_init_core_id = cid;
  405161:	66 89 3d a0 a5 1b 00 	mov    WORD PTR [rip+0x1ba5a0],di        # 5bf708 <_init_core_id>
  405168:	0f 01 f9             	rdtscp 
	} 
	struct slm_ipi_percore *ipi_data = slm_ipi_percore_get(cos_cpuid());
  40516b:	89 cf                	mov    edi,ecx
  40516d:	81 e7 ff 0f 00 00    	and    edi,0xfff
  405173:	e8 18 fd 00 00       	call   414e90 <slm_ipi_percore_get>
  405178:	48 89 c3             	mov    rbx,rax

	cos_defcompinfo_sched_init();
  40517b:	e8 00 67 00 00       	call   40b880 <cos_defcompinfo_sched_init>

	t = slm_thd_alloc(slm_idle, NULL, &thdcap, &tid);
  405180:	31 f6                	xor    esi,esi
  405182:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  405186:	48 8d 55 d0          	lea    rdx,[rbp-0x30]
  40518a:	bf 70 3f 41 00       	mov    edi,0x413f70
  40518f:	e8 3c 01 00 00       	call   4052d0 <slm_thd_alloc>
	if (!t) BUG();
  405194:	48 85 c0             	test   rax,rax
  405197:	0f 84 bb 00 00 00    	je     405258 <cos_parallel_init+0x108>

	slm_init(thdcap, tid);
  40519d:	48 8b 75 e0          	mov    rsi,QWORD PTR [rbp-0x20]
  4051a1:	48 8b 7d d0          	mov    rdi,QWORD PTR [rbp-0x30]
  4051a5:	e8 56 0d 01 00       	call   415f00 <slm_init>

	r = slm_ipithd_create(slm_ipi_process, NULL, 0, &ipithdcap, &ipitid);
  4051aa:	31 d2                	xor    edx,edx
  4051ac:	31 f6                	xor    esi,esi
  4051ae:	4c 8d 45 e8          	lea    r8,[rbp-0x18]
  4051b2:	48 8d 4d d8          	lea    rcx,[rbp-0x28]
  4051b6:	bf a0 0b 40 00       	mov    edi,0x400ba0
  4051bb:	e8 40 fc ff ff       	call   404e00 <slm_ipithd_create>
	if (!r) BUG();
  4051c0:	48 85 c0             	test   rax,rax
  4051c3:	74 73                	je     405238 <cos_parallel_init+0xe8>
	return &ss_thd_get(id)->thd;
  4051c5:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
SS_STATIC_SLAB(thd, struct slm_thd_container, MAX_NUM_THREADS);
  4051c9:	85 c0                	test   eax,eax
  4051cb:	74 42                	je     40520f <cos_parallel_init+0xbf>
  4051cd:	83 e8 01             	sub    eax,0x1
  4051d0:	3d c7 00 00 00       	cmp    eax,0xc7
  4051d5:	77 38                	ja     40520f <cos_parallel_init+0xbf>
  4051d7:	48 8b 14 c5 20 f7 5b 	mov    rdx,QWORD PTR [rax*8+0x5bf720]
  4051de:	00 
	return ((state & ~1) != 0) && ((state & 1) == SS_STATE_ALLOC);
  4051df:	48 f7 c2 fe ff ff ff 	test   rdx,0xfffffffffffffffe
  4051e6:	74 27                	je     40520f <cos_parallel_init+0xbf>
  4051e8:	83 e2 01             	and    edx,0x1
  4051eb:	75 22                	jne    40520f <cos_parallel_init+0xbf>
	return &ss_thd_get(id)->thd;
  4051ed:	48 8d 14 80          	lea    rdx,[rax+rax*4]
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  4051f1:	be 01 00 00 00       	mov    esi,0x1
	return &ss_thd_get(id)->thd;
  4051f6:	48 8d 3c 50          	lea    rdi,[rax+rdx*2]
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  4051fa:	ba 14 00 00 00       	mov    edx,0x14
	return &ss_thd_get(id)->thd;
  4051ff:	48 c1 e7 04          	shl    rdi,0x4
  405203:	48 81 c7 60 fd 5b 00 	add    rdi,0x5bfd60
SLM_MODULES_COMPOSE_FNS(quantum, fprr, static_cm);
  40520a:	e8 91 eb 00 00       	call   413da0 <slm_sched_fprr_thd_update>

CK_CC_INLINE static void
ck_ring_init(struct ck_ring *ring, unsigned int size)
{

	ring->size = size;
  40520f:	48 8b 05 ea 84 01 00 	mov    rax,QWORD PTR [rip+0x184ea]        # 41d700 <__unlock+0xc00>
	ring->mask = size - 1;
	ring->p_tail = 0;
  405216:	48 c7 43 60 00 00 00 	mov    QWORD PTR [rbx+0x60],0x0
  40521d:	00 
	ring->p_head = 0;
	ring->c_head = 0;
  40521e:	c7 43 20 00 00 00 00 	mov    DWORD PTR [rbx+0x20],0x0
	ring->size = size;
  405225:	48 89 83 a0 00 00 00 	mov    QWORD PTR [rbx+0xa0],rax
	sched_thd_param_set(ipitid, sched_param_pack(SCHEDP_PRIO, SLM_IPI_THD_PRIO));
	ck_ring_init(&ipi_data->ring, PAGE_SIZE / sizeof(struct slm_ipi_event));
}
  40522c:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
  405230:	c9                   	leave  
  405231:	c3                   	ret    
  405232:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  405238:	be 11 00 00 00       	mov    esi,0x11
  40523d:	bf d7 d6 41 00       	mov    edi,0x41d6d7
  405242:	e8 39 5a 00 00       	call   40ac80 <cos_print_str>
	if (!r) BUG();
  405247:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40524e:	00 00 00 00 
  405252:	0f 0b                	ud2    
  405254:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  405258:	be 11 00 00 00       	mov    esi,0x11
  40525d:	bf c5 d6 41 00       	mov    edi,0x41d6c5
  405262:	e8 19 5a 00 00       	call   40ac80 <cos_print_str>
	if (!t) BUG();
  405267:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40526e:	00 00 00 00 
  405272:	0f 0b                	ud2    
  405274:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40527b:	00 00 00 00 
  40527f:	90                   	nop

0000000000405280 <cos_init>:

void
cos_init(void)
{
  405280:	f3 0f 1e fa          	endbr64 
  405284:	55                   	push   rbp
  405285:	48 89 e5             	mov    rbp,rsp
	struct cos_compinfo *boot_info = cos_compinfo_get(cos_defcompinfo_curr_get());
  405288:	e8 c3 62 00 00       	call   40b550 <cos_defcompinfo_curr_get>
  40528d:	48 89 c7             	mov    rdi,rax
  405290:	e8 cb 62 00 00       	call   40b560 <cos_compinfo_get>

	cos_meminfo_init(&(boot_info->mi), BOOT_MEM_KM_BASE, COS_MEM_KERN_PA_SZ, BOOT_CAPTBL_SELF_UNTYPED_PT);
  405295:	b9 14 00 00 00       	mov    ecx,0x14
  40529a:	48 ba 00 00 00 fc 01 	movabs rdx,0x1fc000000
  4052a1:	00 00 00 
  4052a4:	48 be 00 00 00 00 80 	movabs rsi,0x8000000000
  4052ab:	00 00 00 
  4052ae:	48 8d b8 10 01 00 00 	lea    rdi,[rax+0x110]
  4052b5:	e8 26 84 00 00       	call   40d6e0 <cos_meminfo_init>
	extern void calculate_initialization_schedule(void);
	calculate_initialization_schedule();
  4052ba:	e8 a1 af ff ff       	call   400260 <calculate_initialization_schedule>
	cos_defcompinfo_init();
}
  4052bf:	5d                   	pop    rbp
	cos_defcompinfo_init();
  4052c0:	e9 1b 63 00 00       	jmp    40b5e0 <cos_defcompinfo_init>
  4052c5:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4052cc:	00 00 00 
  4052cf:	90                   	nop

00000000004052d0 <slm_thd_alloc>:
#include <slm_modules.h>
#include <capmgr.h>

struct slm_thd_container *
slm_thd_alloc(thd_fn_t fn, void *data, thdcap_t *thd, thdid_t *tid)
{
  4052d0:	f3 0f 1e fa          	endbr64 
  4052d4:	55                   	push   rbp
  4052d5:	48 89 e5             	mov    rbp,rsp
  4052d8:	41 55                	push   r13
  4052da:	49 89 cd             	mov    r13,rcx
  4052dd:	41 54                	push   r12
  4052df:	49 89 d4             	mov    r12,rdx
	thdid_t _tid;
	thdcap_t _cap;
	struct slm_thd_container *ret = NULL;

	_cap = capmgr_thd_create(fn, data, &_tid);
  4052e2:	48 8d 55 e8          	lea    rdx,[rbp-0x18]
{
  4052e6:	48 83 ec 10          	sub    rsp,0x10
	_cap = capmgr_thd_create(fn, data, &_tid);
  4052ea:	e8 31 56 00 00       	call   40a920 <capmgr_thd_create>
  4052ef:	48 89 c7             	mov    rdi,rax
	if (_cap <= 0) return NULL;
  4052f2:	31 c0                	xor    eax,eax
  4052f4:	48 85 ff             	test   rdi,rdi
  4052f7:	74 0f                	je     405308 <slm_thd_alloc+0x38>

	return slm_thd_mem_alloc(_cap, _tid, thd, tid);
  4052f9:	48 8b 75 e8          	mov    rsi,QWORD PTR [rbp-0x18]
  4052fd:	4c 89 e9             	mov    rcx,r13
  405300:	4c 89 e2             	mov    rdx,r12
  405303:	e8 e8 c9 ff ff       	call   401cf0 <slm_thd_mem_alloc>
}
  405308:	48 83 c4 10          	add    rsp,0x10
  40530c:	41 5c                	pop    r12
  40530e:	41 5d                	pop    r13
  405310:	5d                   	pop    rbp
  405311:	c3                   	ret    
  405312:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  405319:	00 00 00 00 
  40531d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000405320 <slm_thd_alloc_in>:

struct slm_thd_container *
slm_thd_alloc_in(compid_t cid, thdclosure_index_t idx, thdcap_t *thd, thdid_t *tid)
{
  405320:	f3 0f 1e fa          	endbr64 
  405324:	55                   	push   rbp
	struct slm_thd_container *ret = NULL;
	thdid_t _tid;
	thdcap_t _cap;

	_cap = capmgr_thd_create_ext(cid, idx, &_tid);
  405325:	0f b7 ff             	movzx  edi,di
{
  405328:	48 89 e5             	mov    rbp,rsp
  40532b:	41 55                	push   r13
  40532d:	49 89 cd             	mov    r13,rcx
  405330:	41 54                	push   r12
  405332:	49 89 d4             	mov    r12,rdx
	_cap = capmgr_thd_create_ext(cid, idx, &_tid);
  405335:	48 8d 55 e8          	lea    rdx,[rbp-0x18]
{
  405339:	48 83 ec 10          	sub    rsp,0x10
	_cap = capmgr_thd_create_ext(cid, idx, &_tid);
  40533d:	e8 de 23 00 00       	call   407720 <__cosrt_extern_capmgr_thd_create_ext>
  405342:	48 89 c7             	mov    rdi,rax
	if (_cap <= 0) return NULL;
  405345:	31 c0                	xor    eax,eax
  405347:	48 85 ff             	test   rdi,rdi
  40534a:	74 0f                	je     40535b <slm_thd_alloc_in+0x3b>

	return slm_thd_mem_alloc(_cap, _tid, thd, tid);
  40534c:	48 8b 75 e8          	mov    rsi,QWORD PTR [rbp-0x18]
  405350:	4c 89 e9             	mov    rcx,r13
  405353:	4c 89 e2             	mov    rdx,r12
  405356:	e8 95 c9 ff ff       	call   401cf0 <slm_thd_mem_alloc>
}
  40535b:	48 83 c4 10          	add    rsp,0x10
  40535f:	41 5c                	pop    r12
  405361:	41 5d                	pop    r13
  405363:	5d                   	pop    rbp
  405364:	c3                   	ret    
  405365:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40536c:	00 00 00 00 

0000000000405370 <thd_alloc>:
extern struct slm_thd *slm_thd_current_extern(void);
extern struct slm_thd *slm_thd_from_container(struct slm_thd_container *c);

struct slm_thd *
thd_alloc(thd_fn_t fn, void *data, sched_param_t *parameters, int reschedule)
{
  405370:	f3 0f 1e fa          	endbr64 
  405374:	55                   	push   rbp
  405375:	48 89 e5             	mov    rbp,rsp
  405378:	41 57                	push   r15
  40537a:	41 56                	push   r14
  40537c:	49 89 d6             	mov    r14,rdx
  40537f:	41 55                	push   r13
  405381:	49 89 f5             	mov    r13,rsi
  405384:	41 54                	push   r12
  405386:	49 89 fc             	mov    r12,rdi
  405389:	53                   	push   rbx
  40538a:	48 83 ec 48          	sub    rsp,0x48
  40538e:	89 4d ac             	mov    DWORD PTR [rbp-0x54],ecx
	struct slm_thd_container *t;
	struct slm_thd *thd;
	struct slm_thd *ret     = NULL;
	struct slm_thd *current = slm_thd_current_extern();
  405391:	e8 ea c8 ff ff       	call   401c80 <slm_thd_current_extern>

	/*
	 * If this condition is true, we are likely in the
	 * initialization sequence in the idle or scheduler threads...
	 */
	if (!current) {
  405396:	48 89 c3             	mov    rbx,rax
  405399:	48 85 c0             	test   rax,rax
  40539c:	0f 84 56 02 00 00    	je     4055f8 <thd_alloc+0x288>
	_cap = capmgr_thd_create(fn, data, &_tid);
  4053a2:	4c 89 e7             	mov    rdi,r12
  4053a5:	48 8d 55 c8          	lea    rdx,[rbp-0x38]
  4053a9:	4c 89 ee             	mov    rsi,r13
  4053ac:	e8 6f 55 00 00       	call   40a920 <capmgr_thd_create>
  4053b1:	48 89 c7             	mov    rdi,rax
	if (_cap <= 0) return NULL;
  4053b4:	48 85 c0             	test   rax,rax
  4053b7:	0f 84 b2 00 00 00    	je     40546f <thd_alloc+0xff>
	return slm_thd_mem_alloc(_cap, _tid, thd, tid);
  4053bd:	48 8b 75 c8          	mov    rsi,QWORD PTR [rbp-0x38]
  4053c1:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  4053c5:	48 8d 55 b8          	lea    rdx,[rbp-0x48]
  4053c9:	e8 22 c9 ff ff       	call   401cf0 <slm_thd_mem_alloc>
  4053ce:	49 89 c5             	mov    r13,rax
		current = slm_thd_special();
		assert(current);
	}

	t = slm_thd_alloc(fn, data, &thdcap, &tid);
	if (!t) ERR_THROW(NULL, done);
  4053d1:	48 85 c0             	test   rax,rax
  4053d4:	0f 84 95 00 00 00    	je     40546f <thd_alloc+0xff>
	thd = slm_thd_from_container(t);
  4053da:	48 89 c7             	mov    rdi,rax
  4053dd:	e8 fe c8 ff ff       	call   401ce0 <slm_thd_from_container>
  4053e2:	49 89 c4             	mov    r12,rax
  4053e5:	0f 01 f9             	rdtscp 
	cs = &(slm_global()->lock);
  4053e8:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  4053ee:	48 8d 3c 89          	lea    rdi,[rcx+rcx*4]
  4053f2:	48 c1 e7 06          	shl    rdi,0x6
  4053f6:	4c 8d bf 00 65 71 00 	lea    r15,[rdi+0x716500]
		tok    = cos_sched_sync();
  4053fd:	e8 0e c7 00 00       	call   411b10 <cos_sched_sync>
  405402:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  405405:	49 8b 07             	mov    rax,QWORD PTR [r15]
		if (unlikely(owner)) {
  405408:	48 89 c1             	mov    rcx,rax
  40540b:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  40540f:	0f 85 7b 02 00 00    	jne    405690 <thd_alloc+0x320>
  405415:	f0 49 0f b1 1f       	lock cmpxchg QWORD PTR [r15],rbx
  40541a:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  40541d:	84 c0                	test   al,al
  40541f:	74 dc                	je     4053fd <thd_alloc+0x8d>

	slm_cs_enter(current, SLM_CS_NONE);
	if (slm_thd_init(thd, thdcap, tid)) ERR_THROW(NULL, free);
  405421:	48 8b 55 c0          	mov    rdx,QWORD PTR [rbp-0x40]
  405425:	48 8b 75 b8          	mov    rsi,QWORD PTR [rbp-0x48]
  405429:	4c 89 e7             	mov    rdi,r12
  40542c:	e8 ff fa 00 00       	call   414f30 <slm_thd_init>
  405431:	85 c0                	test   eax,eax
  405433:	75 32                	jne    405467 <thd_alloc+0xf7>

	for (i = 0; parameters[i] != 0; i++) {
  405435:	41 8b 36             	mov    esi,DWORD PTR [r14]
  405438:	49 83 c6 04          	add    r14,0x4
  40543c:	85 f6                	test   esi,esi
  40543e:	75 13                	jne    405453 <thd_alloc+0xe3>
  405440:	eb 46                	jmp    405488 <thd_alloc+0x118>
  405442:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  405448:	41 8b 36             	mov    esi,DWORD PTR [r14]
  40544b:	49 83 c6 04          	add    r14,0x4
  40544f:	85 f6                	test   esi,esi
  405451:	74 35                	je     405488 <thd_alloc+0x118>
  405453:	89 f2                	mov    edx,esi
		sched_param_type_t type;
		unsigned int value;

		sched_param_get(parameters[i], &type, &value);
		if (slm_sched_thd_update(thd, type, value)) ERR_THROW(NULL, free);
  405455:	4c 89 e7             	mov    rdi,r12
	if (type)  *type  = (sched_param_type_t)(sp &  SCHED_PARAM_TYPE_MASK);
  405458:	83 e6 3f             	and    esi,0x3f
	if (value) *value = (unsigned int)      (sp >> SCHED_PARAM_TYPE_BITS);
  40545b:	c1 ea 06             	shr    edx,0x6
  40545e:	e8 3d c6 ff ff       	call   401aa0 <slm_sched_thd_update>
  405463:	85 c0                	test   eax,eax
  405465:	74 e1                	je     405448 <thd_alloc+0xd8>

	ret = thd;
done:
	return ret;
free:
	slm_thd_mem_free(t);
  405467:	4c 89 ef             	mov    rdi,r13
  40546a:	e8 31 ca ff ff       	call   401ea0 <slm_thd_mem_free>
	ret = NULL;
  40546f:	45 31 e4             	xor    r12d,r12d
	goto done;
}
  405472:	48 83 c4 48          	add    rsp,0x48
  405476:	4c 89 e0             	mov    rax,r12
  405479:	5b                   	pop    rbx
  40547a:	41 5c                	pop    r12
  40547c:	41 5d                	pop    r13
  40547e:	41 5e                	pop    r14
  405480:	41 5f                	pop    r15
  405482:	5d                   	pop    rbp
  405483:	c3                   	ret    
  405484:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	slm_thd_mem_activate(t);
  405488:	4c 89 ef             	mov    rdi,r13
  40548b:	e8 50 c9 ff ff       	call   401de0 <slm_thd_mem_activate>
	if (reschedule) {
  405490:	8b 45 ac             	mov    eax,DWORD PTR [rbp-0x54]
  405493:	85 c0                	test   eax,eax
  405495:	0f 84 8d 01 00 00    	je     405628 <thd_alloc+0x2b8>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  40549b:	e8 b0 60 00 00       	call   40b550 <cos_defcompinfo_curr_get>
  4054a0:	0f 01 f9             	rdtscp 
	if (unlikely(!t)) t = &g->idle_thd;
  4054a3:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  4054a9:	48 8d 04 89          	lea    rax,[rcx+rcx*4]
  4054ad:	48 c1 e0 06          	shl    rax,0x6
  4054b1:	48 05 80 65 71 00    	add    rax,0x716580
  4054b7:	48 89 45 a0          	mov    QWORD PTR [rbp-0x60],rax
	tok  = cos_sched_sync();
  4054bb:	e8 50 c6 00 00       	call   411b10 <cos_sched_sync>
  4054c0:	89 45 ac             	mov    DWORD PTR [rbp-0x54],eax
	t = slm_sched_schedule();
  4054c3:	e8 18 c6 ff ff       	call   401ae0 <slm_sched_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  4054c8:	48 85 c0             	test   rax,rax
	t = slm_sched_schedule();
  4054cb:	49 89 c6             	mov    r14,rax
	if (unlikely(!t)) t = &g->idle_thd;
  4054ce:	4c 0f 44 75 a0       	cmove  r14,QWORD PTR [rbp-0x60]
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  4054d3:	41 8b 46 04          	mov    eax,DWORD PTR [r14+0x4]
  4054d7:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  4054da:	83 f8 01             	cmp    eax,0x1
  4054dd:	0f 87 e7 01 00 00    	ja     4056ca <thd_alloc+0x35a>
  4054e3:	0f 01 f9             	rdtscp 
	struct slm_cs *cs = &(slm_global()->lock);
  4054e6:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  4054ec:	48 8d 3c 89          	lea    rdi,[rcx+rcx*4]
  4054f0:	48 c1 e7 06          	shl    rdi,0x6
  4054f4:	4c 8d bf 00 65 71 00 	lea    r15,[rdi+0x716500]
	while (ret != 0) {
  4054fb:	eb 0f                	jmp    40550c <thd_alloc+0x19c>
  4054fd:	0f 1f 00             	nop    DWORD PTR [rax]
  405500:	f0 49 0f b1 17       	lock cmpxchg QWORD PTR [r15],rdx
  405505:	0f 94 c0             	sete   al
  405508:	84 c0                	test   al,al
  40550a:	75 28                	jne    405534 <thd_alloc+0x1c4>
		tok    = cos_sched_sync();
  40550c:	e8 ff c5 00 00       	call   411b10 <cos_sched_sync>
  405511:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  405513:	49 8b 07             	mov    rax,QWORD PTR [r15]
		if (unlikely(contention)) {
  405516:	48 89 c2             	mov    rdx,rax
  405519:	83 e2 01             	and    edx,0x1
  40551c:	74 e2                	je     405500 <thd_alloc+0x190>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  40551e:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  405521:	48 89 c2             	mov    rdx,rax
  405524:	4c 89 ff             	mov    rdi,r15
  405527:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  40552b:	e8 70 fb 00 00       	call   4150a0 <slm_cs_exit_contention>
  405530:	85 c0                	test   eax,eax
  405532:	75 d8                	jne    40550c <thd_alloc+0x19c>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  405534:	e8 17 60 00 00       	call   40b550 <cos_defcompinfo_curr_get>
  405539:	0f 01 f9             	rdtscp 
	*coreid = c & 0xFFF;
  40553c:	89 ca                	mov    edx,ecx
	timeout = g->timeout_next;
  40553e:	81 e1 ff 0f 00 00    	and    ecx,0xfff
	prio = inherit_prio ? curr->priority : t->priority;
  405544:	49 8b 76 30          	mov    rsi,QWORD PTR [r14+0x30]
	timeout = g->timeout_next;
  405548:	48 8d 04 89          	lea    rax,[rcx+rcx*4]
  40554c:	66 81 e2 ff 0f       	and    dx,0xfff
  405551:	49 89 c8             	mov    r8,rcx
  405554:	48 c1 e0 06          	shl    rax,0x6
  405558:	4c 8b 88 08 66 71 00 	mov    r9,QWORD PTR [rax+0x716608]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  40555f:	41 8b 06             	mov    eax,DWORD PTR [r14]
  405562:	a8 0b                	test   al,0xb
  405564:	0f 85 7c 01 00 00    	jne    4056e6 <thd_alloc+0x376>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  40556a:	49 8b 7e 10          	mov    rdi,QWORD PTR [r14+0x10]
  40556e:	8b 4d ac             	mov    ecx,DWORD PTR [rbp-0x54]
  405571:	4c 89 ca             	mov    rdx,r9
  405574:	4c 89 45 98          	mov    QWORD PTR [rbp-0x68],r8
  405578:	e8 23 71 00 00       	call   40c6a0 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  40557d:	4c 8b 45 98          	mov    r8,QWORD PTR [rbp-0x68]
  405581:	83 f8 ff             	cmp    eax,0xffffffff
  405584:	0f 84 e0 01 00 00    	je     40576a <thd_alloc+0x3fa>
	if (unlikely(ret != 0)) {
  40558a:	85 c0                	test   eax,eax
  40558c:	0f 84 e0 fe ff ff    	je     405472 <thd_alloc+0x102>
		assert(ret != -EINVAL);
  405592:	83 f8 ea             	cmp    eax,0xffffffea
  405595:	0f 84 50 02 00 00    	je     4057eb <thd_alloc+0x47b>
		if (ret == -EBUSY) return ret;
  40559b:	83 f8 f0             	cmp    eax,0xfffffff0
  40559e:	0f 84 c3 fe ff ff    	je     405467 <thd_alloc+0xf7>
		assert(ret == -EAGAIN);
  4055a4:	83 f8 f5             	cmp    eax,0xfffffff5
  4055a7:	0f 85 83 02 00 00    	jne    405830 <thd_alloc+0x4c0>
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  4055ad:	0f 01 f9             	rdtscp 
	cs = &(slm_global()->lock);
  4055b0:	48 89 c8             	mov    rax,rcx
  4055b3:	25 ff 0f 00 00       	and    eax,0xfff
  4055b8:	4c 8d 34 80          	lea    r14,[rax+rax*4]
  4055bc:	49 c1 e6 06          	shl    r14,0x6
  4055c0:	49 81 c6 00 65 71 00 	add    r14,0x716500
		tok    = cos_sched_sync();
  4055c7:	e8 44 c5 00 00       	call   411b10 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  4055cc:	49 8b 36             	mov    rsi,QWORD PTR [r14]
  4055cf:	41 89 c1             	mov    r9d,eax
		if (unlikely(owner)) {
  4055d2:	48 89 f1             	mov    rcx,rsi
  4055d5:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  4055d9:	0f 85 28 02 00 00    	jne    405807 <thd_alloc+0x497>
  4055df:	48 89 f0             	mov    rax,rsi
  4055e2:	f0 49 0f b1 1e       	lock cmpxchg QWORD PTR [r14],rbx
  4055e7:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4055ea:	84 c0                	test   al,al
  4055ec:	0f 85 c9 fe ff ff    	jne    4054bb <thd_alloc+0x14b>
  4055f2:	eb d3                	jmp    4055c7 <thd_alloc+0x257>
  4055f4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		current = slm_thd_special();
  4055f8:	e8 b3 f8 00 00       	call   414eb0 <slm_thd_special>
  4055fd:	48 89 c3             	mov    rbx,rax
		assert(current);
  405600:	48 85 c0             	test   rax,rax
  405603:	0f 85 99 fd ff ff    	jne    4053a2 <thd_alloc+0x32>
  405609:	be 28 00 00 00       	mov    esi,0x28
  40560e:	bf 08 d7 41 00       	mov    edi,0x41d708
  405613:	e8 68 56 00 00       	call   40ac80 <cos_print_str>
  405618:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40561f:	00 00 00 00 
  405623:	0f 0b                	ud2    
  405625:	0f 1f 00             	nop    DWORD PTR [rax]
  405628:	0f 01 f9             	rdtscp 
	struct slm_cs *cs = &(slm_global()->lock);
  40562b:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  405631:	48 8d 1c 89          	lea    rbx,[rcx+rcx*4]
  405635:	48 c1 e3 06          	shl    rbx,0x6
  405639:	48 81 c3 00 65 71 00 	add    rbx,0x716500
	while (ret != 0) {
  405640:	eb 16                	jmp    405658 <thd_alloc+0x2e8>
  405642:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  405648:	f0 48 0f b1 13       	lock cmpxchg QWORD PTR [rbx],rdx
  40564d:	0f 94 c0             	sete   al
  405650:	84 c0                	test   al,al
  405652:	0f 85 1a fe ff ff    	jne    405472 <thd_alloc+0x102>
		tok    = cos_sched_sync();
  405658:	e8 b3 c4 00 00       	call   411b10 <cos_sched_sync>
  40565d:	89 c1                	mov    ecx,eax
  40565f:	48 8b 03             	mov    rax,QWORD PTR [rbx]
		if (unlikely(contention)) {
  405662:	48 89 c2             	mov    rdx,rax
  405665:	83 e2 01             	and    edx,0x1
  405668:	74 de                	je     405648 <thd_alloc+0x2d8>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  40566a:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  40566d:	48 89 c2             	mov    rdx,rax
  405670:	48 89 df             	mov    rdi,rbx
  405673:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  405677:	e8 24 fa 00 00       	call   4150a0 <slm_cs_exit_contention>
  40567c:	85 c0                	test   eax,eax
  40567e:	0f 84 ee fd ff ff    	je     405472 <thd_alloc+0x102>
  405684:	eb d2                	jmp    405658 <thd_alloc+0x2e8>
  405686:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40568d:	00 00 00 
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  405690:	41 89 c0             	mov    r8d,eax
  405693:	48 89 da             	mov    rdx,rbx
  405696:	48 89 c6             	mov    rsi,rax
  405699:	4c 89 ff             	mov    rdi,r15
  40569c:	41 83 e0 01          	and    r8d,0x1
  4056a0:	e8 9b f9 00 00       	call   415040 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  4056a5:	83 f8 f0             	cmp    eax,0xfffffff0
  4056a8:	0f 85 4f fd ff ff    	jne    4053fd <thd_alloc+0x8d>
  4056ae:	be 59 00 00 00       	mov    esi,0x59
  4056b3:	bf 38 d7 41 00       	mov    edi,0x41d738
  4056b8:	e8 c3 55 00 00       	call   40ac80 <cos_print_str>
  4056bd:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4056c4:	00 00 00 00 
  4056c8:	0f 0b                	ud2    
  4056ca:	be 61 00 00 00       	mov    esi,0x61
  4056cf:	bf 98 d7 41 00       	mov    edi,0x41d798
  4056d4:	e8 a7 55 00 00       	call   40ac80 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  4056d9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4056e0:	00 00 00 00 
  4056e4:	0f 0b                	ud2    
		if (t == &g->sched_thd) {
  4056e6:	0f b7 d2             	movzx  edx,dx
	timeout = g->timeout_next;
  4056e9:	4c 89 c9             	mov    rcx,r9
		if (t == &g->sched_thd) {
  4056ec:	48 8d 14 92          	lea    rdx,[rdx+rdx*4]
  4056f0:	48 c1 e2 06          	shl    rdx,0x6
  4056f4:	48 81 c2 08 65 71 00 	add    rdx,0x716508
  4056fb:	49 39 d6             	cmp    r14,rdx
  4056fe:	0f 84 b9 00 00 00    	je     4057bd <thd_alloc+0x44d>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  405704:	a8 02                	test   al,0x2
  405706:	0f 85 bc 00 00 00    	jne    4057c8 <thd_alloc+0x458>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  40570c:	49 89 c9             	mov    r9,rcx
  40570f:	a8 01                	test   al,0x1
  405711:	0f 84 53 fe ff ff    	je     40556a <thd_alloc+0x1fa>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  405717:	4b 8d 04 80          	lea    rax,[r8+r8*4]
  40571b:	4d 8b 56 08          	mov    r10,QWORD PTR [r14+0x8]
  40571f:	49 8b 7e 10          	mov    rdi,QWORD PTR [r14+0x10]
  405723:	48 89 f2             	mov    rdx,rsi
  405726:	48 c1 e0 06          	shl    rax,0x6
  40572a:	44 8b 4d ac          	mov    r9d,DWORD PTR [rbp-0x54]
  40572e:	4c 8b 80 28 65 71 00 	mov    r8,QWORD PTR [rax+0x716528]
  405735:	4c 89 d6             	mov    rsi,r10
  405738:	e8 f3 c3 00 00       	call   411b30 <cos_switch>
	if (unlikely(ret != 0)) {
  40573d:	85 c0                	test   eax,eax
  40573f:	0f 84 2d fd ff ff    	je     405472 <thd_alloc+0x102>
		assert(ret != -EPERM);
  405745:	83 f8 ff             	cmp    eax,0xffffffff
  405748:	0f 85 44 fe ff ff    	jne    405592 <thd_alloc+0x222>
  40574e:	be 61 00 00 00       	mov    esi,0x61
  405753:	bf 00 d8 41 00       	mov    edi,0x41d800
  405758:	e8 23 55 00 00       	call   40ac80 <cos_print_str>
  40575d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  405764:	00 00 00 00 
  405768:	0f 0b                	ud2    
  40576a:	0f 01 f9             	rdtscp 
	return t != &g->idle_thd && t != &g->sched_thd;
  40576d:	48 89 c8             	mov    rax,rcx
  405770:	25 ff 0f 00 00       	and    eax,0xfff
  405775:	48 8d 04 80          	lea    rax,[rax+rax*4]
  405779:	48 c1 e0 06          	shl    rax,0x6
  40577d:	48 8d 90 80 65 71 00 	lea    rdx,[rax+0x716580]
  405784:	49 39 d6             	cmp    r14,rdx
  405787:	74 0b                	je     405794 <thd_alloc+0x424>
  405789:	48 05 08 65 71 00    	add    rax,0x716508
  40578f:	49 39 c6             	cmp    r14,rax
  405792:	75 ba                	jne    40574e <thd_alloc+0x3de>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  405794:	4b 8d 04 80          	lea    rax,[r8+r8*4]
  405798:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]
  40579c:	44 8b 4d ac          	mov    r9d,DWORD PTR [rbp-0x54]
  4057a0:	31 c9                	xor    ecx,ecx
  4057a2:	48 c1 e0 06          	shl    rax,0x6
  4057a6:	31 f6                	xor    esi,esi
  4057a8:	4c 8b 80 28 65 71 00 	mov    r8,QWORD PTR [rax+0x716528]
  4057af:	48 8b b8 18 65 71 00 	mov    rdi,QWORD PTR [rax+0x716518]
  4057b6:	e8 75 c3 00 00       	call   411b30 <cos_switch>
  4057bb:	eb 80                	jmp    40573d <thd_alloc+0x3cd>
			prio    = curr->priority;
  4057bd:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
			timeout = TCAP_TIME_NIL;
  4057c1:	31 c9                	xor    ecx,ecx
  4057c3:	e9 3c ff ff ff       	jmp    405704 <thd_alloc+0x394>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  4057c8:	4b 8d 04 80          	lea    rax,[r8+r8*4]
  4057cc:	49 8b 7e 28          	mov    rdi,QWORD PTR [r14+0x28]
  4057d0:	8b 4d ac             	mov    ecx,DWORD PTR [rbp-0x54]
  4057d3:	4c 89 ce             	mov    rsi,r9
  4057d6:	48 c1 e0 06          	shl    rax,0x6
  4057da:	48 8b 90 28 65 71 00 	mov    rdx,QWORD PTR [rax+0x716528]
  4057e1:	e8 ba c3 00 00       	call   411ba0 <cos_sched_asnd>
  4057e6:	e9 52 ff ff ff       	jmp    40573d <thd_alloc+0x3cd>
  4057eb:	be 61 00 00 00       	mov    esi,0x61
  4057f0:	bf 68 d8 41 00       	mov    edi,0x41d868
  4057f5:	e8 86 54 00 00       	call   40ac80 <cos_print_str>
		assert(ret != -EINVAL);
  4057fa:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  405801:	00 00 00 00 
  405805:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  405807:	41 89 f0             	mov    r8d,esi
  40580a:	48 89 da             	mov    rdx,rbx
  40580d:	4c 89 f7             	mov    rdi,r14
  405810:	41 83 e0 01          	and    r8d,0x1
  405814:	e8 27 f8 00 00       	call   415040 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  405819:	83 f8 f0             	cmp    eax,0xfffffff0
  40581c:	0f 85 a5 fd ff ff    	jne    4055c7 <thd_alloc+0x257>
  405822:	e9 87 fe ff ff       	jmp    4056ae <thd_alloc+0x33e>
  405827:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40582e:	00 00 
  405830:	be 61 00 00 00       	mov    esi,0x61
  405835:	bf d0 d8 41 00       	mov    edi,0x41d8d0
  40583a:	e8 41 54 00 00       	call   40ac80 <cos_print_str>
		assert(ret == -EAGAIN);
  40583f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  405846:	00 00 00 00 
  40584a:	0f 0b                	ud2    
  40584c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000405850 <thd_alloc_in>:

struct slm_thd *
thd_alloc_in(compid_t id, thdclosure_index_t idx, sched_param_t *parameters, int reschedule)
{
  405850:	f3 0f 1e fa          	endbr64 
  405854:	55                   	push   rbp
  405855:	48 89 e5             	mov    rbp,rsp
  405858:	41 57                	push   r15
  40585a:	41 56                	push   r14
  40585c:	41 89 f6             	mov    r14d,esi
  40585f:	41 55                	push   r13
  405861:	41 54                	push   r12
  405863:	49 89 fc             	mov    r12,rdi
  405866:	53                   	push   rbx
  405867:	48 89 d3             	mov    rbx,rdx
  40586a:	48 83 ec 38          	sub    rsp,0x38
  40586e:	89 4d a8             	mov    DWORD PTR [rbp-0x58],ecx
	struct slm_thd_container *t;
	struct slm_thd *ret     = NULL, *thd;
	struct slm_thd *current = slm_thd_current_extern();
  405871:	e8 0a c4 ff ff       	call   401c80 <slm_thd_current_extern>

	/*
	 * If this condition is true, we are likely in the
	 * initialization sequence in the idle or scheduler threads...
	 */
	if (!current) {
  405876:	49 89 c5             	mov    r13,rax
  405879:	48 85 c0             	test   rax,rax
  40587c:	0f 84 4e 02 00 00    	je     405ad0 <thd_alloc_in+0x280>
	_cap = capmgr_thd_create_ext(cid, idx, &_tid);
  405882:	41 0f b7 fc          	movzx  edi,r12w
  405886:	48 8d 55 c8          	lea    rdx,[rbp-0x38]
  40588a:	44 89 f6             	mov    esi,r14d
  40588d:	e8 8e 1e 00 00       	call   407720 <__cosrt_extern_capmgr_thd_create_ext>
  405892:	48 89 c7             	mov    rdi,rax
	if (_cap <= 0) return NULL;
  405895:	48 85 c0             	test   rax,rax
  405898:	0f 84 b0 00 00 00    	je     40594e <thd_alloc_in+0xfe>
	return slm_thd_mem_alloc(_cap, _tid, thd, tid);
  40589e:	48 8b 75 c8          	mov    rsi,QWORD PTR [rbp-0x38]
  4058a2:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  4058a6:	48 8d 55 b8          	lea    rdx,[rbp-0x48]
  4058aa:	e8 41 c4 ff ff       	call   401cf0 <slm_thd_mem_alloc>
  4058af:	49 89 c6             	mov    r14,rax
		current = slm_thd_special();
		assert(current);
	}

	t = slm_thd_alloc_in(id, idx, &thdcap, &tid);
	if (!t) ERR_THROW(NULL, done);
  4058b2:	48 85 c0             	test   rax,rax
  4058b5:	0f 84 93 00 00 00    	je     40594e <thd_alloc_in+0xfe>
	thd = slm_thd_from_container(t);
  4058bb:	48 89 c7             	mov    rdi,rax
  4058be:	e8 1d c4 ff ff       	call   401ce0 <slm_thd_from_container>
  4058c3:	49 89 c4             	mov    r12,rax
  4058c6:	0f 01 f9             	rdtscp 
	cs = &(slm_global()->lock);
  4058c9:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  4058cf:	48 8d 3c 89          	lea    rdi,[rcx+rcx*4]
  4058d3:	48 c1 e7 06          	shl    rdi,0x6
  4058d7:	4c 8d bf 00 65 71 00 	lea    r15,[rdi+0x716500]
		tok    = cos_sched_sync();
  4058de:	e8 2d c2 00 00       	call   411b10 <cos_sched_sync>
  4058e3:	41 89 c1             	mov    r9d,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4058e6:	49 8b 07             	mov    rax,QWORD PTR [r15]
		if (unlikely(owner)) {
  4058e9:	48 89 c1             	mov    rcx,rax
  4058ec:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  4058f0:	0f 85 6a 02 00 00    	jne    405b60 <thd_alloc_in+0x310>
  4058f6:	f0 4d 0f b1 2f       	lock cmpxchg QWORD PTR [r15],r13
  4058fb:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4058fe:	84 c0                	test   al,al
  405900:	74 dc                	je     4058de <thd_alloc_in+0x8e>

	slm_cs_enter(current, SLM_CS_NONE);
	if (slm_thd_init(thd, thdcap, tid)) ERR_THROW(NULL, free);
  405902:	48 8b 55 c0          	mov    rdx,QWORD PTR [rbp-0x40]
  405906:	48 8b 75 b8          	mov    rsi,QWORD PTR [rbp-0x48]
  40590a:	4c 89 e7             	mov    rdi,r12
  40590d:	e8 1e f6 00 00       	call   414f30 <slm_thd_init>
  405912:	85 c0                	test   eax,eax
  405914:	75 30                	jne    405946 <thd_alloc_in+0xf6>

	for (i = 0; parameters[i] != 0; i++) {
  405916:	8b 33                	mov    esi,DWORD PTR [rbx]
  405918:	48 83 c3 04          	add    rbx,0x4
  40591c:	85 f6                	test   esi,esi
  40591e:	75 12                	jne    405932 <thd_alloc_in+0xe2>
  405920:	eb 46                	jmp    405968 <thd_alloc_in+0x118>
  405922:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  405928:	8b 33                	mov    esi,DWORD PTR [rbx]
  40592a:	48 83 c3 04          	add    rbx,0x4
  40592e:	85 f6                	test   esi,esi
  405930:	74 36                	je     405968 <thd_alloc_in+0x118>
  405932:	89 f2                	mov    edx,esi
		sched_param_type_t type;
		unsigned int value;

		sched_param_get(parameters[i], &type, &value);
		if (slm_sched_thd_update(thd, type, value)) ERR_THROW(NULL, free);
  405934:	4c 89 e7             	mov    rdi,r12
	if (type)  *type  = (sched_param_type_t)(sp &  SCHED_PARAM_TYPE_MASK);
  405937:	83 e6 3f             	and    esi,0x3f
	if (value) *value = (unsigned int)      (sp >> SCHED_PARAM_TYPE_BITS);
  40593a:	c1 ea 06             	shr    edx,0x6
  40593d:	e8 5e c1 ff ff       	call   401aa0 <slm_sched_thd_update>
  405942:	85 c0                	test   eax,eax
  405944:	74 e2                	je     405928 <thd_alloc_in+0xd8>

	ret = thd;
done:
	return ret;
free:
	slm_thd_mem_free(t);
  405946:	4c 89 f7             	mov    rdi,r14
  405949:	e8 52 c5 ff ff       	call   401ea0 <slm_thd_mem_free>
	ret = NULL;
  40594e:	45 31 e4             	xor    r12d,r12d
	goto done;
}
  405951:	48 83 c4 38          	add    rsp,0x38
  405955:	4c 89 e0             	mov    rax,r12
  405958:	5b                   	pop    rbx
  405959:	41 5c                	pop    r12
  40595b:	41 5d                	pop    r13
  40595d:	41 5e                	pop    r14
  40595f:	41 5f                	pop    r15
  405961:	5d                   	pop    rbp
  405962:	c3                   	ret    
  405963:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	slm_thd_mem_activate(t);
  405968:	4c 89 f7             	mov    rdi,r14
  40596b:	e8 70 c4 ff ff       	call   401de0 <slm_thd_mem_activate>
	if (reschedule) {
  405970:	8b 45 a8             	mov    eax,DWORD PTR [rbp-0x58]
  405973:	85 c0                	test   eax,eax
  405975:	0f 84 85 01 00 00    	je     405b00 <thd_alloc_in+0x2b0>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  40597b:	e8 d0 5b 00 00       	call   40b550 <cos_defcompinfo_curr_get>
  405980:	0f 01 f9             	rdtscp 
	if (unlikely(!t)) t = &g->idle_thd;
  405983:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  405989:	4c 8d 34 89          	lea    r14,[rcx+rcx*4]
  40598d:	49 c1 e6 06          	shl    r14,0x6
  405991:	49 8d 86 80 65 71 00 	lea    rax,[r14+0x716580]
  405998:	48 89 45 a8          	mov    QWORD PTR [rbp-0x58],rax
	tok  = cos_sched_sync();
  40599c:	e8 6f c1 00 00       	call   411b10 <cos_sched_sync>
  4059a1:	41 89 c7             	mov    r15d,eax
	t = slm_sched_schedule();
  4059a4:	e8 37 c1 ff ff       	call   401ae0 <slm_sched_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  4059a9:	48 85 c0             	test   rax,rax
	t = slm_sched_schedule();
  4059ac:	48 89 c3             	mov    rbx,rax
	if (unlikely(!t)) t = &g->idle_thd;
  4059af:	48 0f 44 5d a8       	cmove  rbx,QWORD PTR [rbp-0x58]
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  4059b4:	8b 43 04             	mov    eax,DWORD PTR [rbx+0x4]
  4059b7:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  4059ba:	83 f8 01             	cmp    eax,0x1
  4059bd:	0f 87 d7 01 00 00    	ja     405b9a <thd_alloc_in+0x34a>
  4059c3:	0f 01 f9             	rdtscp 
	struct slm_cs *cs = &(slm_global()->lock);
  4059c6:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  4059cc:	48 8d 3c 89          	lea    rdi,[rcx+rcx*4]
  4059d0:	48 c1 e7 06          	shl    rdi,0x6
  4059d4:	4c 8d b7 00 65 71 00 	lea    r14,[rdi+0x716500]
	while (ret != 0) {
  4059db:	eb 0f                	jmp    4059ec <thd_alloc_in+0x19c>
  4059dd:	0f 1f 00             	nop    DWORD PTR [rax]
  4059e0:	f0 49 0f b1 16       	lock cmpxchg QWORD PTR [r14],rdx
  4059e5:	0f 94 c0             	sete   al
  4059e8:	84 c0                	test   al,al
  4059ea:	75 28                	jne    405a14 <thd_alloc_in+0x1c4>
		tok    = cos_sched_sync();
  4059ec:	e8 1f c1 00 00       	call   411b10 <cos_sched_sync>
  4059f1:	89 c1                	mov    ecx,eax
	unsigned long oc = ps_load(&cs->owner_contention);
  4059f3:	49 8b 06             	mov    rax,QWORD PTR [r14]
		if (unlikely(contention)) {
  4059f6:	48 89 c2             	mov    rdx,rax
  4059f9:	83 e2 01             	and    edx,0x1
  4059fc:	74 e2                	je     4059e0 <thd_alloc_in+0x190>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  4059fe:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  405a01:	48 89 c2             	mov    rdx,rax
  405a04:	4c 89 f7             	mov    rdi,r14
  405a07:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  405a0b:	e8 90 f6 00 00       	call   4150a0 <slm_cs_exit_contention>
  405a10:	85 c0                	test   eax,eax
  405a12:	75 d8                	jne    4059ec <thd_alloc_in+0x19c>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  405a14:	e8 37 5b 00 00       	call   40b550 <cos_defcompinfo_curr_get>
  405a19:	0f 01 f9             	rdtscp 
	*coreid = c & 0xFFF;
  405a1c:	89 ca                	mov    edx,ecx
	timeout = g->timeout_next;
  405a1e:	81 e1 ff 0f 00 00    	and    ecx,0xfff
	prio = inherit_prio ? curr->priority : t->priority;
  405a24:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
	timeout = g->timeout_next;
  405a28:	48 8d 04 89          	lea    rax,[rcx+rcx*4]
  405a2c:	66 81 e2 ff 0f       	and    dx,0xfff
  405a31:	49 89 ce             	mov    r14,rcx
  405a34:	48 c1 e0 06          	shl    rax,0x6
  405a38:	4c 8b 88 08 66 71 00 	mov    r9,QWORD PTR [rax+0x716608]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  405a3f:	8b 03                	mov    eax,DWORD PTR [rbx]
  405a41:	a8 0b                	test   al,0xb
  405a43:	0f 85 6d 01 00 00    	jne    405bb6 <thd_alloc_in+0x366>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  405a49:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  405a4d:	44 89 f9             	mov    ecx,r15d
  405a50:	4c 89 ca             	mov    rdx,r9
  405a53:	e8 48 6c 00 00       	call   40c6a0 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  405a58:	83 f8 ff             	cmp    eax,0xffffffff
  405a5b:	0f 84 d8 01 00 00    	je     405c39 <thd_alloc_in+0x3e9>
	if (unlikely(ret != 0)) {
  405a61:	85 c0                	test   eax,eax
  405a63:	0f 84 e8 fe ff ff    	je     405951 <thd_alloc_in+0x101>
		assert(ret != -EINVAL);
  405a69:	83 f8 ea             	cmp    eax,0xffffffea
  405a6c:	0f 84 47 02 00 00    	je     405cb9 <thd_alloc_in+0x469>
		if (ret == -EBUSY) return ret;
  405a72:	83 f8 f0             	cmp    eax,0xfffffff0
  405a75:	0f 84 d3 fe ff ff    	je     40594e <thd_alloc_in+0xfe>
		assert(ret == -EAGAIN);
  405a7b:	83 f8 f5             	cmp    eax,0xfffffff5
  405a7e:	0f 85 74 02 00 00    	jne    405cf8 <thd_alloc_in+0x4a8>
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  405a84:	0f 01 f9             	rdtscp 
	cs = &(slm_global()->lock);
  405a87:	48 89 c8             	mov    rax,rcx
  405a8a:	25 ff 0f 00 00       	and    eax,0xfff
  405a8f:	48 8d 1c 80          	lea    rbx,[rax+rax*4]
  405a93:	48 c1 e3 06          	shl    rbx,0x6
  405a97:	48 81 c3 00 65 71 00 	add    rbx,0x716500
		tok    = cos_sched_sync();
  405a9e:	e8 6d c0 00 00       	call   411b10 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  405aa3:	48 8b 33             	mov    rsi,QWORD PTR [rbx]
  405aa6:	41 89 c1             	mov    r9d,eax
		if (unlikely(owner)) {
  405aa9:	48 89 f1             	mov    rcx,rsi
  405aac:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
  405ab0:	0f 85 1f 02 00 00    	jne    405cd5 <thd_alloc_in+0x485>
  405ab6:	48 89 f0             	mov    rax,rsi
  405ab9:	f0 4c 0f b1 2b       	lock cmpxchg QWORD PTR [rbx],r13
  405abe:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  405ac1:	84 c0                	test   al,al
  405ac3:	0f 85 d3 fe ff ff    	jne    40599c <thd_alloc_in+0x14c>
  405ac9:	eb d3                	jmp    405a9e <thd_alloc_in+0x24e>
  405acb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		current = slm_thd_special();
  405ad0:	e8 db f3 00 00       	call   414eb0 <slm_thd_special>
  405ad5:	49 89 c5             	mov    r13,rax
		assert(current);
  405ad8:	48 85 c0             	test   rax,rax
  405adb:	0f 85 a1 fd ff ff    	jne    405882 <thd_alloc_in+0x32>
  405ae1:	be 29 00 00 00       	mov    esi,0x29
  405ae6:	bf 38 d9 41 00       	mov    edi,0x41d938
  405aeb:	e8 90 51 00 00       	call   40ac80 <cos_print_str>
  405af0:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  405af7:	00 00 00 00 
  405afb:	0f 0b                	ud2    
  405afd:	0f 1f 00             	nop    DWORD PTR [rax]
  405b00:	0f 01 f9             	rdtscp 
	struct slm_cs *cs = &(slm_global()->lock);
  405b03:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  405b09:	48 8d 1c 89          	lea    rbx,[rcx+rcx*4]
  405b0d:	48 c1 e3 06          	shl    rbx,0x6
  405b11:	48 81 c3 00 65 71 00 	add    rbx,0x716500
	while (ret != 0) {
  405b18:	eb 16                	jmp    405b30 <thd_alloc_in+0x2e0>
  405b1a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  405b20:	f0 48 0f b1 13       	lock cmpxchg QWORD PTR [rbx],rdx
  405b25:	0f 94 c0             	sete   al
  405b28:	84 c0                	test   al,al
  405b2a:	0f 85 21 fe ff ff    	jne    405951 <thd_alloc_in+0x101>
		tok    = cos_sched_sync();
  405b30:	e8 db bf 00 00       	call   411b10 <cos_sched_sync>
  405b35:	89 c1                	mov    ecx,eax
  405b37:	48 8b 03             	mov    rax,QWORD PTR [rbx]
		if (unlikely(contention)) {
  405b3a:	48 89 c2             	mov    rdx,rax
  405b3d:	83 e2 01             	and    edx,0x1
  405b40:	74 de                	je     405b20 <thd_alloc_in+0x2d0>
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  405b42:	48 89 c6             	mov    rsi,rax
			if (!slm_cs_exit_contention(cs, current, cached, tok)) return;
  405b45:	48 89 c2             	mov    rdx,rax
  405b48:	48 89 df             	mov    rdi,rbx
  405b4b:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  405b4f:	e8 4c f5 00 00       	call   4150a0 <slm_cs_exit_contention>
  405b54:	85 c0                	test   eax,eax
  405b56:	0f 84 f5 fd ff ff    	je     405951 <thd_alloc_in+0x101>
  405b5c:	eb d2                	jmp    405b30 <thd_alloc_in+0x2e0>
  405b5e:	66 90                	xchg   ax,ax
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  405b60:	41 89 c0             	mov    r8d,eax
  405b63:	4c 89 ea             	mov    rdx,r13
  405b66:	48 89 c6             	mov    rsi,rax
  405b69:	4c 89 ff             	mov    rdi,r15
  405b6c:	41 83 e0 01          	and    r8d,0x1
  405b70:	e8 cb f4 00 00       	call   415040 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  405b75:	83 f8 f0             	cmp    eax,0xfffffff0
  405b78:	0f 85 60 fd ff ff    	jne    4058de <thd_alloc_in+0x8e>
  405b7e:	be 59 00 00 00       	mov    esi,0x59
  405b83:	bf 38 d7 41 00       	mov    edi,0x41d738
  405b88:	e8 f3 50 00 00       	call   40ac80 <cos_print_str>
  405b8d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  405b94:	00 00 00 00 
  405b98:	0f 0b                	ud2    
  405b9a:	be 61 00 00 00       	mov    esi,0x61
  405b9f:	bf 98 d7 41 00       	mov    edi,0x41d798
  405ba4:	e8 d7 50 00 00       	call   40ac80 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  405ba9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  405bb0:	00 00 00 00 
  405bb4:	0f 0b                	ud2    
		if (t == &g->sched_thd) {
  405bb6:	0f b7 d2             	movzx  edx,dx
	timeout = g->timeout_next;
  405bb9:	4c 89 c9             	mov    rcx,r9
		if (t == &g->sched_thd) {
  405bbc:	48 8d 14 92          	lea    rdx,[rdx+rdx*4]
  405bc0:	48 c1 e2 06          	shl    rdx,0x6
  405bc4:	48 81 c2 08 65 71 00 	add    rdx,0x716508
  405bcb:	48 39 d3             	cmp    rbx,rdx
  405bce:	0f 84 b7 00 00 00    	je     405c8b <thd_alloc_in+0x43b>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  405bd4:	a8 02                	test   al,0x2
  405bd6:	0f 85 ba 00 00 00    	jne    405c96 <thd_alloc_in+0x446>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  405bdc:	49 89 c9             	mov    r9,rcx
  405bdf:	a8 01                	test   al,0x1
  405be1:	0f 84 62 fe ff ff    	je     405a49 <thd_alloc_in+0x1f9>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  405be7:	4b 8d 04 b6          	lea    rax,[r14+r14*4]
  405beb:	4c 8b 53 08          	mov    r10,QWORD PTR [rbx+0x8]
  405bef:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  405bf3:	48 89 f2             	mov    rdx,rsi
  405bf6:	48 c1 e0 06          	shl    rax,0x6
  405bfa:	45 89 f9             	mov    r9d,r15d
  405bfd:	4c 8b 80 28 65 71 00 	mov    r8,QWORD PTR [rax+0x716528]
  405c04:	4c 89 d6             	mov    rsi,r10
  405c07:	e8 24 bf 00 00       	call   411b30 <cos_switch>
	if (unlikely(ret != 0)) {
  405c0c:	85 c0                	test   eax,eax
  405c0e:	0f 84 3d fd ff ff    	je     405951 <thd_alloc_in+0x101>
		assert(ret != -EPERM);
  405c14:	83 f8 ff             	cmp    eax,0xffffffff
  405c17:	0f 85 4c fe ff ff    	jne    405a69 <thd_alloc_in+0x219>
  405c1d:	be 61 00 00 00       	mov    esi,0x61
  405c22:	bf 00 d8 41 00       	mov    edi,0x41d800
  405c27:	e8 54 50 00 00       	call   40ac80 <cos_print_str>
  405c2c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  405c33:	00 00 00 00 
  405c37:	0f 0b                	ud2    
  405c39:	0f 01 f9             	rdtscp 
	return t != &g->idle_thd && t != &g->sched_thd;
  405c3c:	48 89 c8             	mov    rax,rcx
  405c3f:	25 ff 0f 00 00       	and    eax,0xfff
  405c44:	48 8d 04 80          	lea    rax,[rax+rax*4]
  405c48:	48 c1 e0 06          	shl    rax,0x6
  405c4c:	48 8d 90 80 65 71 00 	lea    rdx,[rax+0x716580]
  405c53:	48 39 d3             	cmp    rbx,rdx
  405c56:	74 0b                	je     405c63 <thd_alloc_in+0x413>
  405c58:	48 05 08 65 71 00    	add    rax,0x716508
  405c5e:	48 39 c3             	cmp    rbx,rax
  405c61:	75 ba                	jne    405c1d <thd_alloc_in+0x3cd>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  405c63:	4b 8d 04 b6          	lea    rax,[r14+r14*4]
  405c67:	49 8b 55 30          	mov    rdx,QWORD PTR [r13+0x30]
  405c6b:	45 89 f9             	mov    r9d,r15d
  405c6e:	31 c9                	xor    ecx,ecx
  405c70:	48 c1 e0 06          	shl    rax,0x6
  405c74:	31 f6                	xor    esi,esi
  405c76:	4c 8b 80 28 65 71 00 	mov    r8,QWORD PTR [rax+0x716528]
  405c7d:	48 8b b8 18 65 71 00 	mov    rdi,QWORD PTR [rax+0x716518]
  405c84:	e8 a7 be 00 00       	call   411b30 <cos_switch>
  405c89:	eb 81                	jmp    405c0c <thd_alloc_in+0x3bc>
			prio    = curr->priority;
  405c8b:	49 8b 75 30          	mov    rsi,QWORD PTR [r13+0x30]
			timeout = TCAP_TIME_NIL;
  405c8f:	31 c9                	xor    ecx,ecx
  405c91:	e9 3e ff ff ff       	jmp    405bd4 <thd_alloc_in+0x384>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  405c96:	4b 8d 04 b6          	lea    rax,[r14+r14*4]
  405c9a:	48 8b 7b 28          	mov    rdi,QWORD PTR [rbx+0x28]
  405c9e:	44 89 f9             	mov    ecx,r15d
  405ca1:	4c 89 ce             	mov    rsi,r9
  405ca4:	48 c1 e0 06          	shl    rax,0x6
  405ca8:	48 8b 90 28 65 71 00 	mov    rdx,QWORD PTR [rax+0x716528]
  405caf:	e8 ec be 00 00       	call   411ba0 <cos_sched_asnd>
  405cb4:	e9 53 ff ff ff       	jmp    405c0c <thd_alloc_in+0x3bc>
  405cb9:	be 61 00 00 00       	mov    esi,0x61
  405cbe:	bf 68 d8 41 00       	mov    edi,0x41d868
  405cc3:	e8 b8 4f 00 00       	call   40ac80 <cos_print_str>
		assert(ret != -EINVAL);
  405cc8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  405ccf:	00 00 00 00 
  405cd3:	0f 0b                	ud2    
			ret = slm_cs_enter_contention(cs, cached, current, owner, contended, tok);
  405cd5:	41 89 f0             	mov    r8d,esi
  405cd8:	4c 89 ea             	mov    rdx,r13
  405cdb:	48 89 df             	mov    rdi,rbx
  405cde:	41 83 e0 01          	and    r8d,0x1
  405ce2:	e8 59 f3 00 00       	call   415040 <slm_cs_enter_contention>
			assert(ret != -EBUSY);
  405ce7:	83 f8 f0             	cmp    eax,0xfffffff0
  405cea:	0f 85 ae fd ff ff    	jne    405a9e <thd_alloc_in+0x24e>
  405cf0:	e9 89 fe ff ff       	jmp    405b7e <thd_alloc_in+0x32e>
  405cf5:	0f 1f 00             	nop    DWORD PTR [rax]
  405cf8:	be 61 00 00 00       	mov    esi,0x61
  405cfd:	bf d0 d8 41 00       	mov    edi,0x41d8d0
  405d02:	e8 79 4f 00 00       	call   40ac80 <cos_print_str>
		assert(ret == -EAGAIN);
  405d07:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  405d0e:	00 00 00 00 
  405d12:	0f 0b                	ud2    
  405d14:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  405d1b:	00 00 00 
  405d1e:	66 90                	xchg   ax,ax

0000000000405d20 <__cosrt_s_sched_get_cpu_freq>:
  405d20:	48 b9 2f 5d 40 00 00 	movabs rcx,0x405d2f
  405d27:	00 00 00 
  405d2a:	e9 51 57 00 00       	jmp    40b480 <custom_acquire_stack>
  405d2f:	52                   	push   rdx
  405d30:	50                   	push   rax
  405d31:	55                   	push   rbp
  405d32:	4c 89 e1             	mov    rcx,r12
  405d35:	48 31 ed             	xor    rbp,rbp
  405d38:	48 89 f8             	mov    rax,rdi
  405d3b:	48 89 df             	mov    rdi,rbx
  405d3e:	48 89 c2             	mov    rdx,rax
  405d41:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405d45:	e8 a6 f0 ff ff       	call   404df0 <sched_get_cpu_freq>
  405d4a:	49 89 c0             	mov    r8,rax
  405d4d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  405d54:	0f 05                	syscall 
  405d56:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  405d5d:	00 00 00 

0000000000405d60 <__cosrt_alts_sched_get_cpu_freq>:
  405d60:	4c 89 e8             	mov    rax,r13
  405d63:	48 b9 72 5d 40 00 00 	movabs rcx,0x405d72
  405d6a:	00 00 00 
  405d6d:	e9 0e 57 00 00       	jmp    40b480 <custom_acquire_stack>
  405d72:	52                   	push   rdx
  405d73:	50                   	push   rax
  405d74:	55                   	push   rbp
  405d75:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405d79:	48 31 ed             	xor    rbp,rbp
  405d7c:	51                   	push   rcx
  405d7d:	51                   	push   rcx
  405d7e:	4c 89 c1             	mov    rcx,r8
  405d81:	4c 89 ca             	mov    rdx,r9
  405d84:	e8 67 f0 ff ff       	call   404df0 <sched_get_cpu_freq>
  405d89:	59                   	pop    rcx
  405d8a:	c3                   	ret    
  405d8b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000405d90 <__cosrt_s_sched_thd_yield_to>:
  405d90:	48 b9 9f 5d 40 00 00 	movabs rcx,0x405d9f
  405d97:	00 00 00 
  405d9a:	e9 e1 56 00 00       	jmp    40b480 <custom_acquire_stack>
  405d9f:	52                   	push   rdx
  405da0:	50                   	push   rax
  405da1:	55                   	push   rbp
  405da2:	4c 89 e1             	mov    rcx,r12
  405da5:	48 31 ed             	xor    rbp,rbp
  405da8:	48 89 f8             	mov    rax,rdi
  405dab:	48 89 df             	mov    rdi,rbx
  405dae:	48 89 c2             	mov    rdx,rax
  405db1:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405db5:	e8 d6 c5 ff ff       	call   402390 <sched_thd_yield_to>
  405dba:	49 89 c0             	mov    r8,rax
  405dbd:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  405dc4:	0f 05                	syscall 
  405dc6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  405dcd:	00 00 00 

0000000000405dd0 <__cosrt_alts_sched_thd_yield_to>:
  405dd0:	4c 89 e8             	mov    rax,r13
  405dd3:	48 b9 e2 5d 40 00 00 	movabs rcx,0x405de2
  405dda:	00 00 00 
  405ddd:	e9 9e 56 00 00       	jmp    40b480 <custom_acquire_stack>
  405de2:	52                   	push   rdx
  405de3:	50                   	push   rax
  405de4:	55                   	push   rbp
  405de5:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405de9:	48 31 ed             	xor    rbp,rbp
  405dec:	51                   	push   rcx
  405ded:	51                   	push   rcx
  405dee:	4c 89 c1             	mov    rcx,r8
  405df1:	4c 89 ca             	mov    rdx,r9
  405df4:	e8 97 c5 ff ff       	call   402390 <sched_thd_yield_to>
  405df9:	59                   	pop    rcx
  405dfa:	c3                   	ret    
  405dfb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000405e00 <__cosrt_s_sched_thd_wakeup>:
  405e00:	48 b9 0f 5e 40 00 00 	movabs rcx,0x405e0f
  405e07:	00 00 00 
  405e0a:	e9 71 56 00 00       	jmp    40b480 <custom_acquire_stack>
  405e0f:	52                   	push   rdx
  405e10:	50                   	push   rax
  405e11:	55                   	push   rbp
  405e12:	4c 89 e1             	mov    rcx,r12
  405e15:	48 31 ed             	xor    rbp,rbp
  405e18:	48 89 f8             	mov    rax,rdi
  405e1b:	48 89 df             	mov    rdi,rbx
  405e1e:	48 89 c2             	mov    rdx,rax
  405e21:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405e25:	e8 d6 d7 ff ff       	call   403600 <sched_thd_wakeup>
  405e2a:	49 89 c0             	mov    r8,rax
  405e2d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  405e34:	0f 05                	syscall 
  405e36:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  405e3d:	00 00 00 

0000000000405e40 <__cosrt_alts_sched_thd_wakeup>:
  405e40:	4c 89 e8             	mov    rax,r13
  405e43:	48 b9 52 5e 40 00 00 	movabs rcx,0x405e52
  405e4a:	00 00 00 
  405e4d:	e9 2e 56 00 00       	jmp    40b480 <custom_acquire_stack>
  405e52:	52                   	push   rdx
  405e53:	50                   	push   rax
  405e54:	55                   	push   rbp
  405e55:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405e59:	48 31 ed             	xor    rbp,rbp
  405e5c:	51                   	push   rcx
  405e5d:	51                   	push   rcx
  405e5e:	4c 89 c1             	mov    rcx,r8
  405e61:	4c 89 ca             	mov    rdx,r9
  405e64:	e8 97 d7 ff ff       	call   403600 <sched_thd_wakeup>
  405e69:	59                   	pop    rcx
  405e6a:	c3                   	ret    
  405e6b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000405e70 <__cosrt_s_sched_debug_thd_state>:
  405e70:	48 b9 7f 5e 40 00 00 	movabs rcx,0x405e7f
  405e77:	00 00 00 
  405e7a:	e9 01 56 00 00       	jmp    40b480 <custom_acquire_stack>
  405e7f:	52                   	push   rdx
  405e80:	50                   	push   rax
  405e81:	55                   	push   rbp
  405e82:	4c 89 e1             	mov    rcx,r12
  405e85:	48 31 ed             	xor    rbp,rbp
  405e88:	48 89 f8             	mov    rax,rdi
  405e8b:	48 89 df             	mov    rdi,rbx
  405e8e:	48 89 c2             	mov    rdx,rax
  405e91:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405e95:	e8 16 dc ff ff       	call   403ab0 <sched_debug_thd_state>
  405e9a:	49 89 c0             	mov    r8,rax
  405e9d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  405ea4:	0f 05                	syscall 
  405ea6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  405ead:	00 00 00 

0000000000405eb0 <__cosrt_alts_sched_debug_thd_state>:
  405eb0:	4c 89 e8             	mov    rax,r13
  405eb3:	48 b9 c2 5e 40 00 00 	movabs rcx,0x405ec2
  405eba:	00 00 00 
  405ebd:	e9 be 55 00 00       	jmp    40b480 <custom_acquire_stack>
  405ec2:	52                   	push   rdx
  405ec3:	50                   	push   rax
  405ec4:	55                   	push   rbp
  405ec5:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405ec9:	48 31 ed             	xor    rbp,rbp
  405ecc:	51                   	push   rcx
  405ecd:	51                   	push   rcx
  405ece:	4c 89 c1             	mov    rcx,r8
  405ed1:	4c 89 ca             	mov    rdx,r9
  405ed4:	e8 d7 db ff ff       	call   403ab0 <sched_debug_thd_state>
  405ed9:	59                   	pop    rcx
  405eda:	c3                   	ret    
  405edb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000405ee0 <__cosrt_s_sched_thd_block>:
  405ee0:	48 b9 ef 5e 40 00 00 	movabs rcx,0x405eef
  405ee7:	00 00 00 
  405eea:	e9 91 55 00 00       	jmp    40b480 <custom_acquire_stack>
  405eef:	52                   	push   rdx
  405ef0:	50                   	push   rax
  405ef1:	55                   	push   rbp
  405ef2:	4c 89 e1             	mov    rcx,r12
  405ef5:	48 31 ed             	xor    rbp,rbp
  405ef8:	48 89 f8             	mov    rax,rdi
  405efb:	48 89 df             	mov    rdi,rbx
  405efe:	48 89 c2             	mov    rdx,rax
  405f01:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405f05:	e8 e6 cd ff ff       	call   402cf0 <sched_thd_block>
  405f0a:	49 89 c0             	mov    r8,rax
  405f0d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  405f14:	0f 05                	syscall 
  405f16:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  405f1d:	00 00 00 

0000000000405f20 <__cosrt_alts_sched_thd_block>:
  405f20:	4c 89 e8             	mov    rax,r13
  405f23:	48 b9 32 5f 40 00 00 	movabs rcx,0x405f32
  405f2a:	00 00 00 
  405f2d:	e9 4e 55 00 00       	jmp    40b480 <custom_acquire_stack>
  405f32:	52                   	push   rdx
  405f33:	50                   	push   rax
  405f34:	55                   	push   rbp
  405f35:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405f39:	48 31 ed             	xor    rbp,rbp
  405f3c:	51                   	push   rcx
  405f3d:	51                   	push   rcx
  405f3e:	4c 89 c1             	mov    rcx,r8
  405f41:	4c 89 ca             	mov    rdx,r9
  405f44:	e8 a7 cd ff ff       	call   402cf0 <sched_thd_block>
  405f49:	59                   	pop    rcx
  405f4a:	c3                   	ret    
  405f4b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000405f50 <__cosrt_s_sched_blkpt_alloc>:
  405f50:	48 b9 5f 5f 40 00 00 	movabs rcx,0x405f5f
  405f57:	00 00 00 
  405f5a:	e9 21 55 00 00       	jmp    40b480 <custom_acquire_stack>
  405f5f:	52                   	push   rdx
  405f60:	50                   	push   rax
  405f61:	55                   	push   rbp
  405f62:	4c 89 e1             	mov    rcx,r12
  405f65:	48 31 ed             	xor    rbp,rbp
  405f68:	48 89 f8             	mov    rax,rdi
  405f6b:	48 89 df             	mov    rdi,rbx
  405f6e:	48 89 c2             	mov    rdx,rax
  405f71:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405f75:	e8 16 e5 ff ff       	call   404490 <sched_blkpt_alloc>
  405f7a:	49 89 c0             	mov    r8,rax
  405f7d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  405f84:	0f 05                	syscall 
  405f86:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  405f8d:	00 00 00 

0000000000405f90 <__cosrt_alts_sched_blkpt_alloc>:
  405f90:	4c 89 e8             	mov    rax,r13
  405f93:	48 b9 a2 5f 40 00 00 	movabs rcx,0x405fa2
  405f9a:	00 00 00 
  405f9d:	e9 de 54 00 00       	jmp    40b480 <custom_acquire_stack>
  405fa2:	52                   	push   rdx
  405fa3:	50                   	push   rax
  405fa4:	55                   	push   rbp
  405fa5:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405fa9:	48 31 ed             	xor    rbp,rbp
  405fac:	51                   	push   rcx
  405fad:	51                   	push   rcx
  405fae:	4c 89 c1             	mov    rcx,r8
  405fb1:	4c 89 ca             	mov    rdx,r9
  405fb4:	e8 d7 e4 ff ff       	call   404490 <sched_blkpt_alloc>
  405fb9:	59                   	pop    rcx
  405fba:	c3                   	ret    
  405fbb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000405fc0 <__cosrt_s_sched_blkpt_free>:
  405fc0:	48 b9 cf 5f 40 00 00 	movabs rcx,0x405fcf
  405fc7:	00 00 00 
  405fca:	e9 b1 54 00 00       	jmp    40b480 <custom_acquire_stack>
  405fcf:	52                   	push   rdx
  405fd0:	50                   	push   rax
  405fd1:	55                   	push   rbp
  405fd2:	4c 89 e1             	mov    rcx,r12
  405fd5:	48 31 ed             	xor    rbp,rbp
  405fd8:	48 89 f8             	mov    rax,rdi
  405fdb:	48 89 df             	mov    rdi,rbx
  405fde:	48 89 c2             	mov    rdx,rax
  405fe1:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  405fe5:	e8 66 e6 ff ff       	call   404650 <sched_blkpt_free>
  405fea:	49 89 c0             	mov    r8,rax
  405fed:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  405ff4:	0f 05                	syscall 
  405ff6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  405ffd:	00 00 00 

0000000000406000 <__cosrt_alts_sched_blkpt_free>:
  406000:	4c 89 e8             	mov    rax,r13
  406003:	48 b9 12 60 40 00 00 	movabs rcx,0x406012
  40600a:	00 00 00 
  40600d:	e9 6e 54 00 00       	jmp    40b480 <custom_acquire_stack>
  406012:	52                   	push   rdx
  406013:	50                   	push   rax
  406014:	55                   	push   rbp
  406015:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  406019:	48 31 ed             	xor    rbp,rbp
  40601c:	51                   	push   rcx
  40601d:	51                   	push   rcx
  40601e:	4c 89 c1             	mov    rcx,r8
  406021:	4c 89 ca             	mov    rdx,r9
  406024:	e8 27 e6 ff ff       	call   404650 <sched_blkpt_free>
  406029:	59                   	pop    rcx
  40602a:	c3                   	ret    
  40602b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000406030 <__cosrt_s_sched_blkpt_trigger>:
  406030:	48 b9 3f 60 40 00 00 	movabs rcx,0x40603f
  406037:	00 00 00 
  40603a:	e9 41 54 00 00       	jmp    40b480 <custom_acquire_stack>
  40603f:	52                   	push   rdx
  406040:	50                   	push   rax
  406041:	55                   	push   rbp
  406042:	4c 89 e1             	mov    rcx,r12
  406045:	48 31 ed             	xor    rbp,rbp
  406048:	48 89 f8             	mov    rax,rdi
  40604b:	48 89 df             	mov    rdi,rbx
  40604e:	48 89 c2             	mov    rdx,rax
  406051:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  406055:	e8 06 e6 ff ff       	call   404660 <sched_blkpt_trigger>
  40605a:	49 89 c0             	mov    r8,rax
  40605d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  406064:	0f 05                	syscall 
  406066:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40606d:	00 00 00 

0000000000406070 <__cosrt_alts_sched_blkpt_trigger>:
  406070:	4c 89 e8             	mov    rax,r13
  406073:	48 b9 82 60 40 00 00 	movabs rcx,0x406082
  40607a:	00 00 00 
  40607d:	e9 fe 53 00 00       	jmp    40b480 <custom_acquire_stack>
  406082:	52                   	push   rdx
  406083:	50                   	push   rax
  406084:	55                   	push   rbp
  406085:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  406089:	48 31 ed             	xor    rbp,rbp
  40608c:	51                   	push   rcx
  40608d:	51                   	push   rcx
  40608e:	4c 89 c1             	mov    rcx,r8
  406091:	4c 89 ca             	mov    rdx,r9
  406094:	e8 c7 e5 ff ff       	call   404660 <sched_blkpt_trigger>
  406099:	59                   	pop    rcx
  40609a:	c3                   	ret    
  40609b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000004060a0 <__cosrt_s_sched_blkpt_block>:
  4060a0:	48 b9 af 60 40 00 00 	movabs rcx,0x4060af
  4060a7:	00 00 00 
  4060aa:	e9 d1 53 00 00       	jmp    40b480 <custom_acquire_stack>
  4060af:	52                   	push   rdx
  4060b0:	50                   	push   rax
  4060b1:	55                   	push   rbp
  4060b2:	4c 89 e1             	mov    rcx,r12
  4060b5:	48 31 ed             	xor    rbp,rbp
  4060b8:	48 89 f8             	mov    rax,rdi
  4060bb:	48 89 df             	mov    rdi,rbx
  4060be:	48 89 c2             	mov    rdx,rax
  4060c1:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4060c5:	e8 06 e6 ff ff       	call   4046d0 <sched_blkpt_block>
  4060ca:	49 89 c0             	mov    r8,rax
  4060cd:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  4060d4:	0f 05                	syscall 
  4060d6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4060dd:	00 00 00 

00000000004060e0 <__cosrt_alts_sched_blkpt_block>:
  4060e0:	4c 89 e8             	mov    rax,r13
  4060e3:	48 b9 f2 60 40 00 00 	movabs rcx,0x4060f2
  4060ea:	00 00 00 
  4060ed:	e9 8e 53 00 00       	jmp    40b480 <custom_acquire_stack>
  4060f2:	52                   	push   rdx
  4060f3:	50                   	push   rax
  4060f4:	55                   	push   rbp
  4060f5:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4060f9:	48 31 ed             	xor    rbp,rbp
  4060fc:	51                   	push   rcx
  4060fd:	51                   	push   rcx
  4060fe:	4c 89 c1             	mov    rcx,r8
  406101:	4c 89 ca             	mov    rdx,r9
  406104:	e8 c7 e5 ff ff       	call   4046d0 <sched_blkpt_block>
  406109:	59                   	pop    rcx
  40610a:	c3                   	ret    
  40610b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000406110 <__cosrt_s_sched_thd_block_timeout>:
  406110:	48 b9 1f 61 40 00 00 	movabs rcx,0x40611f
  406117:	00 00 00 
  40611a:	e9 61 53 00 00       	jmp    40b480 <custom_acquire_stack>
  40611f:	52                   	push   rdx
  406120:	50                   	push   rax
  406121:	55                   	push   rbp
  406122:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  406126:	6a 00                	push   0x0
  406128:	49 89 e0             	mov    r8,rsp
  40612b:	6a 00                	push   0x0
  40612d:	49 89 e1             	mov    r9,rsp
  406130:	4c 89 e1             	mov    rcx,r12
  406133:	48 31 ed             	xor    rbp,rbp
  406136:	49 89 fc             	mov    r12,rdi
  406139:	48 89 df             	mov    rdi,rbx
  40613c:	4c 89 e2             	mov    rdx,r12
  40613f:	e8 1c 03 00 00       	call   406460 <__cosrt_s_cstub_sched_thd_block_timeout>
  406144:	5f                   	pop    rdi
  406145:	5e                   	pop    rsi
  406146:	49 89 c0             	mov    r8,rax
  406149:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  406150:	0f 05                	syscall 
  406152:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  406159:	00 00 00 00 
  40615d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000406160 <__cosrt_alts_sched_thd_block_timeout>:
  406160:	4c 89 e8             	mov    rax,r13
  406163:	48 b9 72 61 40 00 00 	movabs rcx,0x406172
  40616a:	00 00 00 
  40616d:	e9 0e 53 00 00       	jmp    40b480 <custom_acquire_stack>
  406172:	52                   	push   rdx
  406173:	50                   	push   rax
  406174:	55                   	push   rbp
  406175:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  406179:	48 31 ed             	xor    rbp,rbp
  40617c:	51                   	push   rcx
  40617d:	51                   	push   rcx
  40617e:	4c 89 c1             	mov    rcx,r8
  406181:	4c 89 ca             	mov    rdx,r9
  406184:	6a 00                	push   0x0
  406186:	49 89 e0             	mov    r8,rsp
  406189:	6a 00                	push   0x0
  40618b:	49 89 e1             	mov    r9,rsp
  40618e:	e8 cd 02 00 00       	call   406460 <__cosrt_s_cstub_sched_thd_block_timeout>
  406193:	5f                   	pop    rdi
  406194:	5e                   	pop    rsi
  406195:	59                   	pop    rcx
  406196:	c3                   	ret    
  406197:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40619e:	00 00 

00000000004061a0 <__cosrt_s_sched_thd_create_closure>:
  4061a0:	48 b9 af 61 40 00 00 	movabs rcx,0x4061af
  4061a7:	00 00 00 
  4061aa:	e9 d1 52 00 00       	jmp    40b480 <custom_acquire_stack>
  4061af:	52                   	push   rdx
  4061b0:	50                   	push   rax
  4061b1:	55                   	push   rbp
  4061b2:	4c 89 e1             	mov    rcx,r12
  4061b5:	48 31 ed             	xor    rbp,rbp
  4061b8:	48 89 f8             	mov    rax,rdi
  4061bb:	48 89 df             	mov    rdi,rbx
  4061be:	48 89 c2             	mov    rdx,rax
  4061c1:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4061c5:	e8 e6 bc ff ff       	call   401eb0 <sched_thd_create_closure>
  4061ca:	49 89 c0             	mov    r8,rax
  4061cd:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  4061d4:	0f 05                	syscall 
  4061d6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4061dd:	00 00 00 

00000000004061e0 <__cosrt_alts_sched_thd_create_closure>:
  4061e0:	4c 89 e8             	mov    rax,r13
  4061e3:	48 b9 f2 61 40 00 00 	movabs rcx,0x4061f2
  4061ea:	00 00 00 
  4061ed:	e9 8e 52 00 00       	jmp    40b480 <custom_acquire_stack>
  4061f2:	52                   	push   rdx
  4061f3:	50                   	push   rax
  4061f4:	55                   	push   rbp
  4061f5:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4061f9:	48 31 ed             	xor    rbp,rbp
  4061fc:	51                   	push   rcx
  4061fd:	51                   	push   rcx
  4061fe:	4c 89 c1             	mov    rcx,r8
  406201:	4c 89 ca             	mov    rdx,r9
  406204:	e8 a7 bc ff ff       	call   401eb0 <sched_thd_create_closure>
  406209:	59                   	pop    rcx
  40620a:	c3                   	ret    
  40620b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000406210 <__cosrt_s_sched_aep_create_closure>:
  406210:	48 b9 1f 62 40 00 00 	movabs rcx,0x40621f
  406217:	00 00 00 
  40621a:	e9 61 52 00 00       	jmp    40b480 <custom_acquire_stack>
  40621f:	52                   	push   rdx
  406220:	50                   	push   rax
  406221:	55                   	push   rbp
  406222:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  406226:	6a 00                	push   0x0
  406228:	49 89 e0             	mov    r8,rsp
  40622b:	6a 00                	push   0x0
  40622d:	49 89 e1             	mov    r9,rsp
  406230:	4c 89 e1             	mov    rcx,r12
  406233:	48 31 ed             	xor    rbp,rbp
  406236:	49 89 fc             	mov    r12,rdi
  406239:	48 89 df             	mov    rdi,rbx
  40623c:	4c 89 e2             	mov    rdx,r12
  40623f:	e8 4c 02 00 00       	call   406490 <__cosrt_s_cstub_sched_aep_create_closure>
  406244:	5f                   	pop    rdi
  406245:	5e                   	pop    rsi
  406246:	49 89 c0             	mov    r8,rax
  406249:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  406250:	0f 05                	syscall 
  406252:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  406259:	00 00 00 00 
  40625d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000406260 <__cosrt_alts_sched_aep_create_closure>:
  406260:	4c 89 e8             	mov    rax,r13
  406263:	48 b9 72 62 40 00 00 	movabs rcx,0x406272
  40626a:	00 00 00 
  40626d:	e9 0e 52 00 00       	jmp    40b480 <custom_acquire_stack>
  406272:	52                   	push   rdx
  406273:	50                   	push   rax
  406274:	55                   	push   rbp
  406275:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  406279:	48 31 ed             	xor    rbp,rbp
  40627c:	51                   	push   rcx
  40627d:	51                   	push   rcx
  40627e:	4c 89 c1             	mov    rcx,r8
  406281:	4c 89 ca             	mov    rdx,r9
  406284:	6a 00                	push   0x0
  406286:	49 89 e0             	mov    r8,rsp
  406289:	6a 00                	push   0x0
  40628b:	49 89 e1             	mov    r9,rsp
  40628e:	e8 fd 01 00 00       	call   406490 <__cosrt_s_cstub_sched_aep_create_closure>
  406293:	5f                   	pop    rdi
  406294:	5e                   	pop    rsi
  406295:	59                   	pop    rcx
  406296:	c3                   	ret    
  406297:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40629e:	00 00 

00000000004062a0 <__cosrt_s_sched_thd_param_set>:
  4062a0:	48 b9 af 62 40 00 00 	movabs rcx,0x4062af
  4062a7:	00 00 00 
  4062aa:	e9 d1 51 00 00       	jmp    40b480 <custom_acquire_stack>
  4062af:	52                   	push   rdx
  4062b0:	50                   	push   rax
  4062b1:	55                   	push   rbp
  4062b2:	4c 89 e1             	mov    rcx,r12
  4062b5:	48 31 ed             	xor    rbp,rbp
  4062b8:	48 89 f8             	mov    rax,rdi
  4062bb:	48 89 df             	mov    rdi,rbx
  4062be:	48 89 c2             	mov    rdx,rax
  4062c1:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4062c5:	e8 36 bc ff ff       	call   401f00 <sched_thd_param_set>
  4062ca:	49 89 c0             	mov    r8,rax
  4062cd:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  4062d4:	0f 05                	syscall 
  4062d6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4062dd:	00 00 00 

00000000004062e0 <__cosrt_alts_sched_thd_param_set>:
  4062e0:	4c 89 e8             	mov    rax,r13
  4062e3:	48 b9 f2 62 40 00 00 	movabs rcx,0x4062f2
  4062ea:	00 00 00 
  4062ed:	e9 8e 51 00 00       	jmp    40b480 <custom_acquire_stack>
  4062f2:	52                   	push   rdx
  4062f3:	50                   	push   rax
  4062f4:	55                   	push   rbp
  4062f5:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4062f9:	48 31 ed             	xor    rbp,rbp
  4062fc:	51                   	push   rcx
  4062fd:	51                   	push   rcx
  4062fe:	4c 89 c1             	mov    rcx,r8
  406301:	4c 89 ca             	mov    rdx,r9
  406304:	e8 f7 bb ff ff       	call   401f00 <sched_thd_param_set>
  406309:	59                   	pop    rcx
  40630a:	c3                   	ret    
  40630b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000406310 <__cosrt_s_sched_thd_exit>:
  406310:	48 b9 1f 63 40 00 00 	movabs rcx,0x40631f
  406317:	00 00 00 
  40631a:	e9 61 51 00 00       	jmp    40b480 <custom_acquire_stack>
  40631f:	52                   	push   rdx
  406320:	50                   	push   rax
  406321:	55                   	push   rbp
  406322:	4c 89 e1             	mov    rcx,r12
  406325:	48 31 ed             	xor    rbp,rbp
  406328:	48 89 f8             	mov    rax,rdi
  40632b:	48 89 df             	mov    rdi,rbx
  40632e:	48 89 c2             	mov    rdx,rax
  406331:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  406335:	e8 36 bc ff ff       	call   401f70 <sched_thd_exit>
  40633a:	49 89 c0             	mov    r8,rax
  40633d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  406344:	0f 05                	syscall 
  406346:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40634d:	00 00 00 

0000000000406350 <__cosrt_alts_sched_thd_exit>:
  406350:	4c 89 e8             	mov    rax,r13
  406353:	48 b9 62 63 40 00 00 	movabs rcx,0x406362
  40635a:	00 00 00 
  40635d:	e9 1e 51 00 00       	jmp    40b480 <custom_acquire_stack>
  406362:	52                   	push   rdx
  406363:	50                   	push   rax
  406364:	55                   	push   rbp
  406365:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  406369:	48 31 ed             	xor    rbp,rbp
  40636c:	51                   	push   rcx
  40636d:	51                   	push   rcx
  40636e:	4c 89 c1             	mov    rcx,r8
  406371:	4c 89 ca             	mov    rdx,r9
  406374:	e8 f7 bb ff ff       	call   401f70 <sched_thd_exit>
  406379:	59                   	pop    rcx
  40637a:	c3                   	ret    
  40637b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000406380 <__cosrt_s_sched_thd_delete>:
  406380:	48 b9 8f 63 40 00 00 	movabs rcx,0x40638f
  406387:	00 00 00 
  40638a:	e9 f1 50 00 00       	jmp    40b480 <custom_acquire_stack>
  40638f:	52                   	push   rdx
  406390:	50                   	push   rax
  406391:	55                   	push   rbp
  406392:	4c 89 e1             	mov    rcx,r12
  406395:	48 31 ed             	xor    rbp,rbp
  406398:	48 89 f8             	mov    rax,rdi
  40639b:	48 89 df             	mov    rdi,rbx
  40639e:	48 89 c2             	mov    rdx,rax
  4063a1:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4063a5:	e8 b6 bb ff ff       	call   401f60 <sched_thd_delete>
  4063aa:	49 89 c0             	mov    r8,rax
  4063ad:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  4063b4:	0f 05                	syscall 
  4063b6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4063bd:	00 00 00 

00000000004063c0 <__cosrt_alts_sched_thd_delete>:
  4063c0:	4c 89 e8             	mov    rax,r13
  4063c3:	48 b9 d2 63 40 00 00 	movabs rcx,0x4063d2
  4063ca:	00 00 00 
  4063cd:	e9 ae 50 00 00       	jmp    40b480 <custom_acquire_stack>
  4063d2:	52                   	push   rdx
  4063d3:	50                   	push   rax
  4063d4:	55                   	push   rbp
  4063d5:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4063d9:	48 31 ed             	xor    rbp,rbp
  4063dc:	51                   	push   rcx
  4063dd:	51                   	push   rcx
  4063de:	4c 89 c1             	mov    rcx,r8
  4063e1:	4c 89 ca             	mov    rdx,r9
  4063e4:	e8 77 bb ff ff       	call   401f60 <sched_thd_delete>
  4063e9:	59                   	pop    rcx
  4063ea:	c3                   	ret    
  4063eb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000004063f0 <__cosrt_s_sched_set_tls>:
  4063f0:	48 b9 ff 63 40 00 00 	movabs rcx,0x4063ff
  4063f7:	00 00 00 
  4063fa:	e9 81 50 00 00       	jmp    40b480 <custom_acquire_stack>
  4063ff:	52                   	push   rdx
  406400:	50                   	push   rax
  406401:	55                   	push   rbp
  406402:	4c 89 e1             	mov    rcx,r12
  406405:	48 31 ed             	xor    rbp,rbp
  406408:	48 89 f8             	mov    rax,rdi
  40640b:	48 89 df             	mov    rdi,rbx
  40640e:	48 89 c2             	mov    rdx,rax
  406411:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  406415:	e8 e6 c3 ff ff       	call   402800 <sched_set_tls>
  40641a:	49 89 c0             	mov    r8,rax
  40641d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  406424:	0f 05                	syscall 
  406426:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40642d:	00 00 00 

0000000000406430 <__cosrt_alts_sched_set_tls>:
  406430:	4c 89 e8             	mov    rax,r13
  406433:	48 b9 42 64 40 00 00 	movabs rcx,0x406442
  40643a:	00 00 00 
  40643d:	e9 3e 50 00 00       	jmp    40b480 <custom_acquire_stack>
  406442:	52                   	push   rdx
  406443:	50                   	push   rax
  406444:	55                   	push   rbp
  406445:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  406449:	48 31 ed             	xor    rbp,rbp
  40644c:	51                   	push   rcx
  40644d:	51                   	push   rcx
  40644e:	4c 89 c1             	mov    rcx,r8
  406451:	4c 89 ca             	mov    rdx,r9
  406454:	e8 a7 c3 ff ff       	call   402800 <sched_set_tls>
  406459:	59                   	pop    rcx
  40645a:	c3                   	ret    
  40645b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000406460 <__cosrt_s_cstub_sched_thd_block_timeout>:
#include <cos_stubs.h>
#include <sched.h>

COS_SERVER_3RET_STUB(int, sched_thd_block_timeout)
{
  406460:	f3 0f 1e fa          	endbr64 
  406464:	55                   	push   rbp
  406465:	48 89 e5             	mov    rbp,rsp
  406468:	41 54                	push   r12
  40646a:	4d 89 c4             	mov    r12,r8
  40646d:	53                   	push   rbx
  40646e:	4c 89 cb             	mov    rbx,r9
	cycles_t elapsed = 0, abs_timeout;

	/* works on armv7a too, as we control where hi and lo are passed for timeout */
	COS_ARG_WORDS_TO_DWORD(p1, p2, abs_timeout);
	elapsed = sched_thd_block_timeout((thdid_t)p0, abs_timeout);
  406471:	e8 8a d6 ff ff       	call   403b00 <sched_thd_block_timeout>
	*r1 = (elapsed >> 32);
  406476:	48 89 c2             	mov    rdx,rax
	*r2 = (elapsed << 32) >> 32;
  406479:	83 e0 ff             	and    eax,0xffffffff
	*r1 = (elapsed >> 32);
  40647c:	48 c1 ea 20          	shr    rdx,0x20
  406480:	49 89 14 24          	mov    QWORD PTR [r12],rdx
	*r2 = (elapsed << 32) >> 32;
  406484:	48 89 03             	mov    QWORD PTR [rbx],rax

	return 0;
}
  406487:	5b                   	pop    rbx
  406488:	31 c0                	xor    eax,eax
  40648a:	41 5c                	pop    r12
  40648c:	5d                   	pop    rbp
  40648d:	c3                   	ret    
  40648e:	66 90                	xchg   ax,ax

0000000000406490 <__cosrt_s_cstub_sched_aep_create_closure>:

COS_SERVER_3RET_STUB(thdid_t, sched_aep_create_closure)
{
  406490:	f3 0f 1e fa          	endbr64 
  406494:	55                   	push   rbp
  406495:	48 89 f8             	mov    rax,rdi
  406498:	48 89 d1             	mov    rcx,rdx
	u32_t               ipimax = (p1 << 16) >> 16;
	cos_channelkey_t    key    = (p1 >> 16);
	arcvcap_t rcv;
	thdid_t ret;

	ret = sched_aep_create_closure(idx, owntc, key, ipiwin, ipimax, &rcv);
  40649b:	89 f2                	mov    edx,esi
  40649d:	c1 ea 10             	shr    edx,0x10
	thdclosure_index_t  idx    = (p0 >> 16);
  4064a0:	48 c1 ef 10          	shr    rdi,0x10
{
  4064a4:	48 89 e5             	mov    rbp,rsp
  4064a7:	41 54                	push   r12
  4064a9:	4d 89 c4             	mov    r12,r8
	ret = sched_aep_create_closure(idx, owntc, key, ipiwin, ipimax, &rcv);
  4064ac:	41 89 f0             	mov    r8d,esi
{
  4064af:	53                   	push   rbx
	ret = sched_aep_create_closure(idx, owntc, key, ipiwin, ipimax, &rcv);
  4064b0:	89 c6                	mov    esi,eax
{
  4064b2:	4c 89 cb             	mov    rbx,r9
	ret = sched_aep_create_closure(idx, owntc, key, ipiwin, ipimax, &rcv);
  4064b5:	4c 8d 4d e8          	lea    r9,[rbp-0x18]
{
  4064b9:	48 83 ec 10          	sub    rsp,0x10
	ret = sched_aep_create_closure(idx, owntc, key, ipiwin, ipimax, &rcv);
  4064bd:	e8 1e e9 ff ff       	call   404de0 <sched_aep_create_closure>

	*r1 = rcv;
  4064c2:	48 8b 55 e8          	mov    rdx,QWORD PTR [rbp-0x18]
  4064c6:	49 89 14 24          	mov    QWORD PTR [r12],rdx
	*r2 = 0;
  4064ca:	48 c7 03 00 00 00 00 	mov    QWORD PTR [rbx],0x0

	return ret;
}
  4064d1:	48 83 c4 10          	add    rsp,0x10
  4064d5:	5b                   	pop    rbx
  4064d6:	41 5c                	pop    r12
  4064d8:	5d                   	pop    rbp
  4064d9:	c3                   	ret    
  4064da:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000004064e0 <__cosrt_s_init_done>:
  4064e0:	48 b9 ef 64 40 00 00 	movabs rcx,0x4064ef
  4064e7:	00 00 00 
  4064ea:	e9 91 4f 00 00       	jmp    40b480 <custom_acquire_stack>
  4064ef:	52                   	push   rdx
  4064f0:	50                   	push   rax
  4064f1:	55                   	push   rbp
  4064f2:	4c 89 e1             	mov    rcx,r12
  4064f5:	48 31 ed             	xor    rbp,rbp
  4064f8:	48 89 f8             	mov    rax,rdi
  4064fb:	48 89 df             	mov    rdi,rbx
  4064fe:	48 89 c2             	mov    rdx,rax
  406501:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  406505:	e8 46 9f ff ff       	call   400450 <init_done>
  40650a:	49 89 c0             	mov    r8,rax
  40650d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  406514:	0f 05                	syscall 
  406516:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40651d:	00 00 00 

0000000000406520 <__cosrt_alts_init_done>:
  406520:	4c 89 e8             	mov    rax,r13
  406523:	48 b9 32 65 40 00 00 	movabs rcx,0x406532
  40652a:	00 00 00 
  40652d:	e9 4e 4f 00 00       	jmp    40b480 <custom_acquire_stack>
  406532:	52                   	push   rdx
  406533:	50                   	push   rax
  406534:	55                   	push   rbp
  406535:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  406539:	48 31 ed             	xor    rbp,rbp
  40653c:	51                   	push   rcx
  40653d:	51                   	push   rcx
  40653e:	4c 89 c1             	mov    rcx,r8
  406541:	4c 89 ca             	mov    rdx,r9
  406544:	e8 07 9f ff ff       	call   400450 <init_done>
  406549:	59                   	pop    rcx
  40654a:	c3                   	ret    
  40654b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000406550 <__cosrt_s_init_exit>:
  406550:	48 b9 5f 65 40 00 00 	movabs rcx,0x40655f
  406557:	00 00 00 
  40655a:	e9 21 4f 00 00       	jmp    40b480 <custom_acquire_stack>
  40655f:	52                   	push   rdx
  406560:	50                   	push   rax
  406561:	55                   	push   rbp
  406562:	4c 89 e1             	mov    rcx,r12
  406565:	48 31 ed             	xor    rbp,rbp
  406568:	48 89 f8             	mov    rax,rdi
  40656b:	48 89 df             	mov    rdi,rbx
  40656e:	48 89 c2             	mov    rdx,rax
  406571:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  406575:	e8 26 a0 ff ff       	call   4005a0 <init_exit>
  40657a:	49 89 c0             	mov    r8,rax
  40657d:	48 c7 c0 00 00 01 00 	mov    rax,0x10000
  406584:	0f 05                	syscall 
  406586:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40658d:	00 00 00 

0000000000406590 <__cosrt_alts_init_exit>:
  406590:	4c 89 e8             	mov    rax,r13
  406593:	48 b9 a2 65 40 00 00 	movabs rcx,0x4065a2
  40659a:	00 00 00 
  40659d:	e9 de 4e 00 00       	jmp    40b480 <custom_acquire_stack>
  4065a2:	52                   	push   rdx
  4065a3:	50                   	push   rax
  4065a4:	55                   	push   rbp
  4065a5:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  4065a9:	48 31 ed             	xor    rbp,rbp
  4065ac:	51                   	push   rcx
  4065ad:	51                   	push   rcx
  4065ae:	4c 89 c1             	mov    rcx,r8
  4065b1:	4c 89 ca             	mov    rdx,r9
  4065b4:	e8 e7 9f ff ff       	call   4005a0 <init_exit>
  4065b9:	59                   	pop    rcx
  4065ba:	c3                   	ret    
  4065bb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000004065c0 <__cosrt_c_init_done>:
 * to serialize and deserialize arguments. In contrast, this code
 * doesn't have a corresponding client-side stub as it only
 * orchestrates the coordination with the await_init function.
 */
COS_CLIENT_STUB(int, init_done, int parallel_init, init_main_t cont)
{
  4065c0:	f3 0f 1e fa          	endbr64 
  4065c4:	55                   	push   rbp
	COS_CLIENT_INVCAP;
	int ret;

	ret = cos_sinv(uc, parallel_init, cont, 0, 0);
  4065c5:	89 f6                	mov    esi,esi
  4065c7:	4c 63 d7             	movsxd r10,edi
{
  4065ca:	48 89 e5             	mov    rbp,rsp
  4065cd:	41 55                	push   r13
  4065cf:	41 54                	push   r12
  4065d1:	53                   	push   rbx
  4065d2:	48 83 ec 28          	sub    rsp,0x28
  4065d6:	4c 8b 68 10          	mov    r13,QWORD PTR [rax+0x10]
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, &r1, &r2);
  4065da:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  4065de:	4d 85 ed             	test   r13,r13
  4065e1:	74 2d                	je     406610 <__cosrt_c_init_done+0x50>
  4065e3:	4c 8d 4d d0          	lea    r9,[rbp-0x30]
  4065e7:	4c 8d 45 c8          	lea    r8,[rbp-0x38]
  4065eb:	31 c9                	xor    ecx,ecx
  4065ed:	31 d2                	xor    edx,edx
  4065ef:	4c 89 d7             	mov    rdi,r10
  4065f2:	41 ff d5             	call   r13
	ps_store(&awaiting_init, 0);
  4065f5:	c7 05 05 fa 01 00 00 	mov    DWORD PTR [rip+0x1fa05],0x0        # 426004 <awaiting_init>
  4065fc:	00 00 00 

	return ret;
}
  4065ff:	48 83 c4 28          	add    rsp,0x28
  406603:	5b                   	pop    rbx
  406604:	41 5c                	pop    r12
  406606:	41 5d                	pop    r13
  406608:	5d                   	pop    rbp
  406609:	c3                   	ret    
  40660a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  406610:	8d 42 01             	lea    eax,[rdx+0x1]
	__asm__ __volatile__(
  406613:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  406617:	4c 89 d3             	mov    rbx,r10
  40661a:	4c 89 ef             	mov    rdi,r13
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40661d:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  406620:	4c 89 ea             	mov    rdx,r13
  406623:	48 89 29             	mov    QWORD PTR [rcx],rbp
  406626:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40662a:	48 89 cd             	mov    rbp,rcx
  40662d:	49 b8 48 66 40 00 00 	movabs r8,0x406648
  406634:	00 00 00 
  406637:	0f 05                	syscall 
  406639:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  406640:	eb 0d                	jmp    40664f <__cosrt_c_init_done+0x8f>
  406642:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  406648:	b9 00 00 00 00       	mov    ecx,0x0
  40664d:	eb 05                	jmp    406654 <__cosrt_c_init_done+0x94>
  40664f:	b9 01 00 00 00       	mov    ecx,0x1
  406654:	5d                   	pop    rbp
  406655:	5c                   	pop    rsp
	return call_cap_op(uc->cap_no, 0, arg1, arg2, arg3, arg4);
  406656:	eb 9d                	jmp    4065f5 <__cosrt_c_init_done+0x35>
  406658:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40665f:	00 

0000000000406660 <__cosrt_extern_init_parallel_await_init>:
 * This function is implemented as a library compiled directly into
 * the client component.
 */
void
COS_STUB_LIBFN(init_parallel_await_init)(void)
{
  406660:	f3 0f 1e fa          	endbr64 
  406664:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	while (ps_load(&awaiting_init)) ;
  406668:	8b 05 96 f9 01 00    	mov    eax,DWORD PTR [rip+0x1f996]        # 426004 <awaiting_init>
  40666e:	85 c0                	test   eax,eax
  406670:	75 f6                	jne    406668 <__cosrt_extern_init_parallel_await_init+0x8>
}
  406672:	c3                   	ret    
  406673:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40667a:	00 00 00 
  40667d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000406680 <__cosrt_extern_init_done>:
  406680:	48 b8 b8 c0 5b 00 00 	movabs rax,0x5bc0b8
  406687:	00 00 00 
  40668a:	ff 10                	call   QWORD PTR [rax]
  40668c:	c3                   	ret    
  40668d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000406690 <__cosrt_fast_callgate_init_done>:
  406690:	55                   	push   rbp
  406691:	41 55                	push   r13
  406693:	41 56                	push   r14
  406695:	41 57                	push   r15
  406697:	49 89 c8             	mov    r8,rcx
  40669a:	49 89 d1             	mov    r9,rdx
  40669d:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4066a4:	be ad de 
  4066a7:	0f 01 f9             	rdtscp 
  4066aa:	48 89 c8             	mov    rax,rcx
  4066ad:	48 25 ff 0f 00 00    	and    rax,0xfff
  4066b3:	48 89 e2             	mov    rdx,rsp
  4066b6:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4066bd:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4066c4:	00 
  4066c5:	48 c1 e0 10          	shl    rax,0x10
  4066c9:	49 09 c5             	or     r13,rax
  4066cc:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4066d3:	7f 00 00 
  4066d6:	4c 89 e8             	mov    rax,r13
  4066d9:	48 25 ff ff 00 00    	and    rax,0xffff
  4066df:	48 c1 e0 08          	shl    rax,0x8
  4066e3:	49 01 c6             	add    r14,rax
  4066e6:	b9 01 00 00 00       	mov    ecx,0x1
  4066eb:	01 c9                	add    ecx,ecx
  4066ed:	b8 03 00 00 00       	mov    eax,0x3
  4066f2:	d3 e0                	shl    eax,cl
  4066f4:	f7 d0                	not    eax
  4066f6:	83 e0 fc             	and    eax,0xfffffffc
  4066f9:	48 31 c9             	xor    rcx,rcx
  4066fc:	48 31 d2             	xor    rdx,rdx
  4066ff:	0f 01 ef             	wrpkru 
  406702:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  406705:	48 83 c2 01          	add    rdx,0x1
  406709:	48 c1 e2 04          	shl    rdx,0x4
  40670d:	4c 01 f2             	add    rdx,r14
  406710:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  406717:	45 23 01 
  40671a:	48 89 02             	mov    QWORD PTR [rdx],rax
  40671d:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  406721:	49 8b 06             	mov    rax,QWORD PTR [r14]
  406724:	48 83 c0 01          	add    rax,0x1
  406728:	49 89 06             	mov    QWORD PTR [r14],rax
  40672b:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  406730:	01 c9                	add    ecx,ecx
  406732:	b8 03 00 00 00       	mov    eax,0x3
  406737:	d3 e0                	shl    eax,cl
  406739:	f7 d0                	not    eax
  40673b:	83 e0 fc             	and    eax,0xfffffffc
  40673e:	48 31 c9             	xor    rcx,rcx
  406741:	48 31 d2             	xor    rdx,rdx
  406744:	0f 01 ef             	wrpkru 
  406747:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  40674e:	45 23 01 
  406751:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  406758:	be ad de 
  40675b:	49 39 c7             	cmp    r15,rax
  40675e:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  406765:	12 12 12 
  406768:	48 b9 74 67 40 00 00 	movabs rcx,0x406774
  40676f:	00 00 00 
  406772:	ff e0                	jmp    rax

0000000000406774 <srv_call_ret_init_done>:
  406774:	49 89 c0             	mov    r8,rax
  406777:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40677e:	be ad de 
  406781:	48 89 e2             	mov    rdx,rsp
  406784:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40678b:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  406792:	00 
  406793:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40679a:	7f 00 00 
  40679d:	4c 89 e8             	mov    rax,r13
  4067a0:	48 25 ff ff 00 00    	and    rax,0xffff
  4067a6:	48 c1 e0 08          	shl    rax,0x8
  4067aa:	49 01 c6             	add    r14,rax
  4067ad:	b9 01 00 00 00       	mov    ecx,0x1
  4067b2:	01 c9                	add    ecx,ecx
  4067b4:	b8 03 00 00 00       	mov    eax,0x3
  4067b9:	d3 e0                	shl    eax,cl
  4067bb:	f7 d0                	not    eax
  4067bd:	83 e0 fc             	and    eax,0xfffffffc
  4067c0:	48 31 c9             	xor    rcx,rcx
  4067c3:	48 31 d2             	xor    rdx,rdx
  4067c6:	0f 01 ef             	wrpkru 
  4067c9:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4067cc:	48 c1 e2 04          	shl    rdx,0x4
  4067d0:	4c 01 f2             	add    rdx,r14
  4067d3:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  4067d7:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4067da:	48 83 e8 01          	sub    rax,0x1
  4067de:	49 89 06             	mov    QWORD PTR [r14],rax
  4067e1:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4067e6:	01 c9                	add    ecx,ecx
  4067e8:	b8 03 00 00 00       	mov    eax,0x3
  4067ed:	d3 e0                	shl    eax,cl
  4067ef:	f7 d0                	not    eax
  4067f1:	83 e0 fc             	and    eax,0xfffffffc
  4067f4:	48 31 c9             	xor    rcx,rcx
  4067f7:	48 31 d2             	xor    rdx,rdx
  4067fa:	0f 01 ef             	wrpkru 
  4067fd:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  406804:	be ad de 
  406807:	49 39 c7             	cmp    r15,rax
  40680a:	4c 89 c0             	mov    rax,r8
  40680d:	41 5f                	pop    r15
  40680f:	41 5e                	pop    r14
  406811:	41 5d                	pop    r13
  406813:	5d                   	pop    rbp
  406814:	c3                   	ret    
  406815:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40681c:	00 00 00 00 

0000000000406820 <__cosrt_extern_init_exit>:
  406820:	48 b8 d0 c0 5b 00 00 	movabs rax,0x5bc0d0
  406827:	00 00 00 
  40682a:	ff 10                	call   QWORD PTR [rax]
  40682c:	c3                   	ret    
  40682d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000406830 <__cosrt_fast_callgate_init_exit>:
  406830:	55                   	push   rbp
  406831:	41 55                	push   r13
  406833:	41 56                	push   r14
  406835:	41 57                	push   r15
  406837:	49 89 c8             	mov    r8,rcx
  40683a:	49 89 d1             	mov    r9,rdx
  40683d:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  406844:	be ad de 
  406847:	0f 01 f9             	rdtscp 
  40684a:	48 89 c8             	mov    rax,rcx
  40684d:	48 25 ff 0f 00 00    	and    rax,0xfff
  406853:	48 89 e2             	mov    rdx,rsp
  406856:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40685d:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  406864:	00 
  406865:	48 c1 e0 10          	shl    rax,0x10
  406869:	49 09 c5             	or     r13,rax
  40686c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  406873:	7f 00 00 
  406876:	4c 89 e8             	mov    rax,r13
  406879:	48 25 ff ff 00 00    	and    rax,0xffff
  40687f:	48 c1 e0 08          	shl    rax,0x8
  406883:	49 01 c6             	add    r14,rax
  406886:	b9 01 00 00 00       	mov    ecx,0x1
  40688b:	01 c9                	add    ecx,ecx
  40688d:	b8 03 00 00 00       	mov    eax,0x3
  406892:	d3 e0                	shl    eax,cl
  406894:	f7 d0                	not    eax
  406896:	83 e0 fc             	and    eax,0xfffffffc
  406899:	48 31 c9             	xor    rcx,rcx
  40689c:	48 31 d2             	xor    rdx,rdx
  40689f:	0f 01 ef             	wrpkru 
  4068a2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4068a5:	48 83 c2 01          	add    rdx,0x1
  4068a9:	48 c1 e2 04          	shl    rdx,0x4
  4068ad:	4c 01 f2             	add    rdx,r14
  4068b0:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  4068b7:	45 23 01 
  4068ba:	48 89 02             	mov    QWORD PTR [rdx],rax
  4068bd:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  4068c1:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4068c4:	48 83 c0 01          	add    rax,0x1
  4068c8:	49 89 06             	mov    QWORD PTR [r14],rax
  4068cb:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4068d0:	01 c9                	add    ecx,ecx
  4068d2:	b8 03 00 00 00       	mov    eax,0x3
  4068d7:	d3 e0                	shl    eax,cl
  4068d9:	f7 d0                	not    eax
  4068db:	83 e0 fc             	and    eax,0xfffffffc
  4068de:	48 31 c9             	xor    rcx,rcx
  4068e1:	48 31 d2             	xor    rdx,rdx
  4068e4:	0f 01 ef             	wrpkru 
  4068e7:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  4068ee:	45 23 01 
  4068f1:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4068f8:	be ad de 
  4068fb:	49 39 c7             	cmp    r15,rax
  4068fe:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  406905:	12 12 12 
  406908:	48 b9 14 69 40 00 00 	movabs rcx,0x406914
  40690f:	00 00 00 
  406912:	ff e0                	jmp    rax

0000000000406914 <srv_call_ret_init_exit>:
  406914:	49 89 c0             	mov    r8,rax
  406917:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40691e:	be ad de 
  406921:	48 89 e2             	mov    rdx,rsp
  406924:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40692b:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  406932:	00 
  406933:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40693a:	7f 00 00 
  40693d:	4c 89 e8             	mov    rax,r13
  406940:	48 25 ff ff 00 00    	and    rax,0xffff
  406946:	48 c1 e0 08          	shl    rax,0x8
  40694a:	49 01 c6             	add    r14,rax
  40694d:	b9 01 00 00 00       	mov    ecx,0x1
  406952:	01 c9                	add    ecx,ecx
  406954:	b8 03 00 00 00       	mov    eax,0x3
  406959:	d3 e0                	shl    eax,cl
  40695b:	f7 d0                	not    eax
  40695d:	83 e0 fc             	and    eax,0xfffffffc
  406960:	48 31 c9             	xor    rcx,rcx
  406963:	48 31 d2             	xor    rdx,rdx
  406966:	0f 01 ef             	wrpkru 
  406969:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40696c:	48 c1 e2 04          	shl    rdx,0x4
  406970:	4c 01 f2             	add    rdx,r14
  406973:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  406977:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40697a:	48 83 e8 01          	sub    rax,0x1
  40697e:	49 89 06             	mov    QWORD PTR [r14],rax
  406981:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  406986:	01 c9                	add    ecx,ecx
  406988:	b8 03 00 00 00       	mov    eax,0x3
  40698d:	d3 e0                	shl    eax,cl
  40698f:	f7 d0                	not    eax
  406991:	83 e0 fc             	and    eax,0xfffffffc
  406994:	48 31 c9             	xor    rcx,rcx
  406997:	48 31 d2             	xor    rdx,rdx
  40699a:	0f 01 ef             	wrpkru 
  40699d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4069a4:	be ad de 
  4069a7:	49 39 c7             	cmp    r15,rax
  4069aa:	4c 89 c0             	mov    rax,r8
  4069ad:	41 5f                	pop    r15
  4069af:	41 5e                	pop    r14
  4069b1:	41 5d                	pop    r13
  4069b3:	5d                   	pop    rbp
  4069b4:	c3                   	ret    
  4069b5:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4069bc:	00 00 00 
  4069bf:	90                   	nop

00000000004069c0 <__cosrt_c_capmgr_rcv_create>:
#include <cos_thd_init.h>
#include <cos_defkernel_api.h>
#include <cos_stubs.h>

COS_CLIENT_STUB(arcvcap_t, capmgr_rcv_create, thdclosure_index_t idx, int flags, asndcap_t *asnd, thdcap_t *thdcap, thdid_t *tid)
{
  4069c0:	f3 0f 1e fa          	endbr64 
  4069c4:	55                   	push   rbp
	COS_CLIENT_INVCAP;
	word_t thdret, asnd_ret;
	arcvcap_t ret;

	ret = cos_sinv_2rets(uc, idx, flags, 0, 0, &asnd_ret, &thdret);
  4069c5:	48 63 f6             	movsxd rsi,esi
{
  4069c8:	48 89 e5             	mov    rbp,rsp
  4069cb:	41 57                	push   r15
  4069cd:	41 56                	push   r14
  4069cf:	49 89 d6             	mov    r14,rdx
  4069d2:	41 55                	push   r13
  4069d4:	49 89 cd             	mov    r13,rcx
  4069d7:	41 54                	push   r12
  4069d9:	53                   	push   rbx
	ret = cos_sinv_2rets(uc, idx, flags, 0, 0, &asnd_ret, &thdret);
  4069da:	48 63 df             	movsxd rbx,edi
{
  4069dd:	48 83 ec 38          	sub    rsp,0x38
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  4069e1:	4c 8b 78 10          	mov    r15,QWORD PTR [rax+0x10]
  4069e5:	4c 89 45 a8          	mov    QWORD PTR [rbp-0x58],r8
  4069e9:	4d 85 ff             	test   r15,r15
  4069ec:	74 4a                	je     406a38 <__cosrt_c_capmgr_rcv_create+0x78>
  4069ee:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  4069f2:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  4069f6:	31 c9                	xor    ecx,ecx
  4069f8:	31 d2                	xor    edx,edx
  4069fa:	48 89 df             	mov    rdi,rbx
  4069fd:	41 ff d7             	call   r15
	*asnd   = asnd_ret;
  406a00:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
	*thdcap = (thdcap_t)thdret >> 16;
	*tid    = (thdid_t)thdret & 0xFFFF;
  406a04:	48 8b 5d a8          	mov    rbx,QWORD PTR [rbp-0x58]
	ret = cos_sinv_2rets(uc, idx, flags, 0, 0, &asnd_ret, &thdret);
  406a08:	48 98                	cdqe   
	*asnd   = asnd_ret;
  406a0a:	49 89 16             	mov    QWORD PTR [r14],rdx
	*thdcap = (thdcap_t)thdret >> 16;
  406a0d:	48 8b 55 b0          	mov    rdx,QWORD PTR [rbp-0x50]
  406a11:	48 89 d1             	mov    rcx,rdx
	*tid    = (thdid_t)thdret & 0xFFFF;
  406a14:	81 e2 ff ff 00 00    	and    edx,0xffff
	*thdcap = (thdcap_t)thdret >> 16;
  406a1a:	48 c1 e9 10          	shr    rcx,0x10
  406a1e:	49 89 4d 00          	mov    QWORD PTR [r13+0x0],rcx
	*tid    = (thdid_t)thdret & 0xFFFF;
  406a22:	48 89 13             	mov    QWORD PTR [rbx],rdx

	return ret;
}
  406a25:	48 83 c4 38          	add    rsp,0x38
  406a29:	5b                   	pop    rbx
  406a2a:	41 5c                	pop    r12
  406a2c:	41 5d                	pop    r13
  406a2e:	41 5e                	pop    r14
  406a30:	41 5f                	pop    r15
  406a32:	5d                   	pop    rbp
  406a33:	c3                   	ret    
  406a34:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  406a38:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  406a3c:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  406a40:	4c 89 ff             	mov    rdi,r15
  406a43:	4c 89 fa             	mov    rdx,r15
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  406a46:	83 c0 01             	add    eax,0x1
  406a49:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  406a4c:	48 89 29             	mov    QWORD PTR [rcx],rbp
  406a4f:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  406a53:	48 89 cd             	mov    rbp,rcx
  406a56:	49 b8 70 6a 40 00 00 	movabs r8,0x406a70
  406a5d:	00 00 00 
  406a60:	0f 05                	syscall 
  406a62:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  406a68:	eb 0f                	jmp    406a79 <__cosrt_c_capmgr_rcv_create+0xb9>
  406a6a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  406a70:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  406a77:	eb 07                	jmp    406a80 <__cosrt_c_capmgr_rcv_create+0xc0>
  406a79:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  406a80:	5d                   	pop    rbp
  406a81:	5c                   	pop    rsp
  406a82:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
  406a86:	48 89 7d b0          	mov    QWORD PTR [rbp-0x50],rdi
	return ret;
  406a8a:	e9 71 ff ff ff       	jmp    406a00 <__cosrt_c_capmgr_rcv_create+0x40>
  406a8f:	90                   	nop

0000000000406a90 <__cosrt_c_capmgr_shared_kernel_page_create>:

COS_CLIENT_STUB(vaddr_t, capmgr_shared_kernel_page_create, vaddr_t *resource)
{
  406a90:	f3 0f 1e fa          	endbr64 
  406a94:	55                   	push   rbp
  406a95:	48 89 e5             	mov    rbp,rsp
  406a98:	41 55                	push   r13
  406a9a:	49 89 fd             	mov    r13,rdi
  406a9d:	41 54                	push   r12
  406a9f:	53                   	push   rbx
  406aa0:	48 83 ec 28          	sub    rsp,0x28
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  406aa4:	48 8b 58 10          	mov    rbx,QWORD PTR [rax+0x10]
  406aa8:	48 85 db             	test   rbx,rbx
  406aab:	74 2b                	je     406ad8 <__cosrt_c_capmgr_shared_kernel_page_create+0x48>
  406aad:	4c 8d 4d c8          	lea    r9,[rbp-0x38]
  406ab1:	4c 8d 45 c0          	lea    r8,[rbp-0x40]
  406ab5:	31 c9                	xor    ecx,ecx
  406ab7:	31 d2                	xor    edx,edx
  406ab9:	31 f6                	xor    esi,esi
  406abb:	31 ff                	xor    edi,edi
  406abd:	ff d3                	call   rbx
	COS_CLIENT_INVCAP;
	word_t ret1, ret2;
	vaddr_t ret;

	ret = cos_sinv_2rets(uc, 0, 0, 0, 0, &ret1, &ret2);
	*resource   = ret1;
  406abf:	48 8b 55 c0          	mov    rdx,QWORD PTR [rbp-0x40]
	ret = cos_sinv_2rets(uc, 0, 0, 0, 0, &ret1, &ret2);
  406ac3:	48 98                	cdqe   
	*resource   = ret1;
  406ac5:	49 89 55 00          	mov    QWORD PTR [r13+0x0],rdx

	return ret;
}
  406ac9:	48 83 c4 28          	add    rsp,0x28
  406acd:	5b                   	pop    rbx
  406ace:	41 5c                	pop    r12
  406ad0:	41 5d                	pop    r13
  406ad2:	5d                   	pop    rbp
  406ad3:	c3                   	ret    
  406ad4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  406ad8:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  406adc:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  406ae0:	48 89 de             	mov    rsi,rbx
  406ae3:	48 89 df             	mov    rdi,rbx
  406ae6:	48 89 da             	mov    rdx,rbx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  406ae9:	83 c0 01             	add    eax,0x1
  406aec:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  406aef:	48 89 29             	mov    QWORD PTR [rcx],rbp
  406af2:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  406af6:	48 89 cd             	mov    rbp,rcx
  406af9:	49 b8 10 6b 40 00 00 	movabs r8,0x406b10
  406b00:	00 00 00 
  406b03:	0f 05                	syscall 
  406b05:	0f 1f 00             	nop    DWORD PTR [rax]
  406b08:	eb 0f                	jmp    406b19 <__cosrt_c_capmgr_shared_kernel_page_create+0x89>
  406b0a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  406b10:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  406b17:	eb 07                	jmp    406b20 <__cosrt_c_capmgr_shared_kernel_page_create+0x90>
  406b19:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  406b20:	5d                   	pop    rbp
  406b21:	5c                   	pop    rsp
  406b22:	48 89 75 c0          	mov    QWORD PTR [rbp-0x40],rsi
	return ret;
  406b26:	eb 97                	jmp    406abf <__cosrt_c_capmgr_shared_kernel_page_create+0x2f>
  406b28:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  406b2f:	00 

0000000000406b30 <__cosrt_c_capmgr_vm_lapic_create>:
  406b30:	f3 0f 1e fa          	endbr64 
  406b34:	55                   	push   rbp
  406b35:	48 89 e5             	mov    rbp,rsp
  406b38:	41 55                	push   r13
  406b3a:	49 89 fd             	mov    r13,rdi
  406b3d:	41 54                	push   r12
  406b3f:	53                   	push   rbx
  406b40:	48 83 ec 28          	sub    rsp,0x28
  406b44:	48 8b 58 10          	mov    rbx,QWORD PTR [rax+0x10]
  406b48:	48 85 db             	test   rbx,rbx
  406b4b:	74 2b                	je     406b78 <__cosrt_c_capmgr_vm_lapic_create+0x48>
  406b4d:	4c 8d 4d c8          	lea    r9,[rbp-0x38]
  406b51:	4c 8d 45 c0          	lea    r8,[rbp-0x40]
  406b55:	31 c9                	xor    ecx,ecx
  406b57:	31 d2                	xor    edx,edx
  406b59:	31 f6                	xor    esi,esi
  406b5b:	31 ff                	xor    edi,edi
  406b5d:	ff d3                	call   rbx
  406b5f:	48 8b 55 c0          	mov    rdx,QWORD PTR [rbp-0x40]
  406b63:	48 98                	cdqe   
  406b65:	49 89 55 00          	mov    QWORD PTR [r13+0x0],rdx
  406b69:	48 83 c4 28          	add    rsp,0x28
  406b6d:	5b                   	pop    rbx
  406b6e:	41 5c                	pop    r12
  406b70:	41 5d                	pop    r13
  406b72:	5d                   	pop    rbp
  406b73:	c3                   	ret    
  406b74:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  406b78:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  406b7c:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  406b80:	48 89 de             	mov    rsi,rbx
  406b83:	48 89 df             	mov    rdi,rbx
  406b86:	48 89 da             	mov    rdx,rbx
  406b89:	83 c0 01             	add    eax,0x1
  406b8c:	c1 e0 10             	shl    eax,0x10
  406b8f:	48 89 29             	mov    QWORD PTR [rcx],rbp
  406b92:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  406b96:	48 89 cd             	mov    rbp,rcx
  406b99:	49 b8 b0 6b 40 00 00 	movabs r8,0x406bb0
  406ba0:	00 00 00 
  406ba3:	0f 05                	syscall 
  406ba5:	0f 1f 00             	nop    DWORD PTR [rax]
  406ba8:	eb 0f                	jmp    406bb9 <__cosrt_c_capmgr_vm_lapic_create+0x89>
  406baa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  406bb0:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  406bb7:	eb 07                	jmp    406bc0 <__cosrt_c_capmgr_vm_lapic_create+0x90>
  406bb9:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  406bc0:	5d                   	pop    rbp
  406bc1:	5c                   	pop    rsp
  406bc2:	48 89 75 c0          	mov    QWORD PTR [rbp-0x40],rsi
  406bc6:	eb 97                	jmp    406b5f <__cosrt_c_capmgr_vm_lapic_create+0x2f>
  406bc8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  406bcf:	00 

0000000000406bd0 <__cosrt_c_capmgr_vm_shared_region_create>:
  406bd0:	f3 0f 1e fa          	endbr64 
  406bd4:	55                   	push   rbp
  406bd5:	48 89 e5             	mov    rbp,rsp
  406bd8:	41 55                	push   r13
  406bda:	49 89 fd             	mov    r13,rdi
  406bdd:	41 54                	push   r12
  406bdf:	53                   	push   rbx
  406be0:	48 83 ec 28          	sub    rsp,0x28
  406be4:	48 8b 58 10          	mov    rbx,QWORD PTR [rax+0x10]
  406be8:	48 85 db             	test   rbx,rbx
  406beb:	74 2b                	je     406c18 <__cosrt_c_capmgr_vm_shared_region_create+0x48>
  406bed:	4c 8d 4d c8          	lea    r9,[rbp-0x38]
  406bf1:	4c 8d 45 c0          	lea    r8,[rbp-0x40]
  406bf5:	31 c9                	xor    ecx,ecx
  406bf7:	31 d2                	xor    edx,edx
  406bf9:	31 f6                	xor    esi,esi
  406bfb:	31 ff                	xor    edi,edi
  406bfd:	ff d3                	call   rbx
  406bff:	48 8b 55 c0          	mov    rdx,QWORD PTR [rbp-0x40]
  406c03:	48 98                	cdqe   
  406c05:	49 89 55 00          	mov    QWORD PTR [r13+0x0],rdx
  406c09:	48 83 c4 28          	add    rsp,0x28
  406c0d:	5b                   	pop    rbx
  406c0e:	41 5c                	pop    r12
  406c10:	41 5d                	pop    r13
  406c12:	5d                   	pop    rbp
  406c13:	c3                   	ret    
  406c14:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  406c18:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  406c1c:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  406c20:	48 89 de             	mov    rsi,rbx
  406c23:	48 89 df             	mov    rdi,rbx
  406c26:	48 89 da             	mov    rdx,rbx
  406c29:	83 c0 01             	add    eax,0x1
  406c2c:	c1 e0 10             	shl    eax,0x10
  406c2f:	48 89 29             	mov    QWORD PTR [rcx],rbp
  406c32:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  406c36:	48 89 cd             	mov    rbp,rcx
  406c39:	49 b8 50 6c 40 00 00 	movabs r8,0x406c50
  406c40:	00 00 00 
  406c43:	0f 05                	syscall 
  406c45:	0f 1f 00             	nop    DWORD PTR [rax]
  406c48:	eb 0f                	jmp    406c59 <__cosrt_c_capmgr_vm_shared_region_create+0x89>
  406c4a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  406c50:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  406c57:	eb 07                	jmp    406c60 <__cosrt_c_capmgr_vm_shared_region_create+0x90>
  406c59:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  406c60:	5d                   	pop    rbp
  406c61:	5c                   	pop    rsp
  406c62:	48 89 75 c0          	mov    QWORD PTR [rbp-0x40],rsi
  406c66:	eb 97                	jmp    406bff <__cosrt_c_capmgr_vm_shared_region_create+0x2f>
  406c68:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  406c6f:	00 

0000000000406c70 <__cosrt_c_capmgr_vm_vcpu_create>:

	return ret;
}

COS_CLIENT_STUB(thdcap_t, capmgr_vm_vcpu_create, compid_t vm_comp, vm_vmcb_t vmcb_cap, thdid_t *tid)
{
  406c70:	f3 0f 1e fa          	endbr64 
  406c74:	55                   	push   rbp
  406c75:	48 89 e5             	mov    rbp,rsp
  406c78:	41 57                	push   r15
  406c7a:	49 89 d7             	mov    r15,rdx
  406c7d:	41 56                	push   r14
  406c7f:	41 55                	push   r13
  406c81:	41 54                	push   r12
  406c83:	53                   	push   rbx
  406c84:	48 83 ec 28          	sub    rsp,0x28
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  406c88:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  406c8c:	4d 85 f6             	test   r14,r14
  406c8f:	74 2f                	je     406cc0 <__cosrt_c_capmgr_vm_vcpu_create+0x50>
  406c91:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  406c95:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  406c99:	31 c9                	xor    ecx,ecx
  406c9b:	31 d2                	xor    edx,edx
  406c9d:	41 ff d6             	call   r14
	COS_CLIENT_INVCAP;
	word_t unused, tid_ret;
	thdcap_t ret;

	ret = cos_sinv_2rets(uc, vm_comp, vmcb_cap, 0, 0, &tid_ret, &unused);
	*tid = tid_ret;
  406ca0:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
	ret = cos_sinv_2rets(uc, vm_comp, vmcb_cap, 0, 0, &tid_ret, &unused);
  406ca4:	48 98                	cdqe   
	*tid = tid_ret;
  406ca6:	49 89 17             	mov    QWORD PTR [r15],rdx

	return ret;
}
  406ca9:	48 83 c4 28          	add    rsp,0x28
  406cad:	5b                   	pop    rbx
  406cae:	41 5c                	pop    r12
  406cb0:	41 5d                	pop    r13
  406cb2:	41 5e                	pop    r14
  406cb4:	41 5f                	pop    r15
  406cb6:	5d                   	pop    rbp
  406cb7:	c3                   	ret    
  406cb8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  406cbf:	00 
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  406cc0:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  406cc4:	48 89 fb             	mov    rbx,rdi
  406cc7:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  406ccb:	4c 89 f7             	mov    rdi,r14
  406cce:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  406cd1:	83 c0 01             	add    eax,0x1
  406cd4:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  406cd7:	48 89 29             	mov    QWORD PTR [rcx],rbp
  406cda:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  406cde:	48 89 cd             	mov    rbp,rcx
  406ce1:	49 b8 f8 6c 40 00 00 	movabs r8,0x406cf8
  406ce8:	00 00 00 
  406ceb:	0f 05                	syscall 
  406ced:	0f 1f 00             	nop    DWORD PTR [rax]
  406cf0:	eb 0f                	jmp    406d01 <__cosrt_c_capmgr_vm_vcpu_create+0x91>
  406cf2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  406cf8:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  406cff:	eb 07                	jmp    406d08 <__cosrt_c_capmgr_vm_vcpu_create+0x98>
  406d01:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  406d08:	5d                   	pop    rbp
  406d09:	5c                   	pop    rsp
  406d0a:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  406d0e:	eb 90                	jmp    406ca0 <__cosrt_c_capmgr_vm_vcpu_create+0x30>

0000000000406d10 <__cosrt_c_capmgr_initthd_create>:

COS_CLIENT_STUB(thdcap_t, capmgr_initthd_create, spdid_t child, thdid_t *tid)
{
  406d10:	f3 0f 1e fa          	endbr64 
  406d14:	55                   	push   rbp
  406d15:	48 89 e5             	mov    rbp,rsp
  406d18:	41 57                	push   r15
	COS_CLIENT_INVCAP;
	word_t unused, tid_ret;
	thdcap_t ret;

	ret = cos_sinv_2rets(uc, child, 0, 0, 0, &tid_ret, &unused);
  406d1a:	44 0f b7 ff          	movzx  r15d,di
{
  406d1e:	41 56                	push   r14
  406d20:	41 55                	push   r13
  406d22:	49 89 f5             	mov    r13,rsi
  406d25:	41 54                	push   r12
  406d27:	53                   	push   rbx
  406d28:	48 83 ec 28          	sub    rsp,0x28
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  406d2c:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  406d30:	4d 85 f6             	test   r14,r14
  406d33:	74 33                	je     406d68 <__cosrt_c_capmgr_initthd_create+0x58>
  406d35:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  406d39:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  406d3d:	31 c9                	xor    ecx,ecx
  406d3f:	31 d2                	xor    edx,edx
  406d41:	31 f6                	xor    esi,esi
  406d43:	4c 89 ff             	mov    rdi,r15
  406d46:	41 ff d6             	call   r14
	*tid = tid_ret;
  406d49:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
	ret = cos_sinv_2rets(uc, child, 0, 0, 0, &tid_ret, &unused);
  406d4d:	48 98                	cdqe   
	*tid = tid_ret;
  406d4f:	49 89 55 00          	mov    QWORD PTR [r13+0x0],rdx

	return ret;
}
  406d53:	48 83 c4 28          	add    rsp,0x28
  406d57:	5b                   	pop    rbx
  406d58:	41 5c                	pop    r12
  406d5a:	41 5d                	pop    r13
  406d5c:	41 5e                	pop    r14
  406d5e:	41 5f                	pop    r15
  406d60:	5d                   	pop    rbp
  406d61:	c3                   	ret    
  406d62:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  406d68:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  406d6c:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  406d70:	4c 89 fb             	mov    rbx,r15
  406d73:	4c 89 f6             	mov    rsi,r14
  406d76:	4c 89 f7             	mov    rdi,r14
  406d79:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  406d7c:	83 c0 01             	add    eax,0x1
  406d7f:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  406d82:	48 89 29             	mov    QWORD PTR [rcx],rbp
  406d85:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  406d89:	48 89 cd             	mov    rbp,rcx
  406d8c:	49 b8 a0 6d 40 00 00 	movabs r8,0x406da0
  406d93:	00 00 00 
  406d96:	0f 05                	syscall 
  406d98:	eb 0f                	jmp    406da9 <__cosrt_c_capmgr_initthd_create+0x99>
  406d9a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  406da0:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  406da7:	eb 07                	jmp    406db0 <__cosrt_c_capmgr_initthd_create+0xa0>
  406da9:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  406db0:	5d                   	pop    rbp
  406db1:	5c                   	pop    rsp
  406db2:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  406db6:	eb 91                	jmp    406d49 <__cosrt_c_capmgr_initthd_create+0x39>
  406db8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  406dbf:	00 

0000000000406dc0 <__cosrt_c_capmgr_thd_create_thunk>:

COS_CLIENT_STUB(thdcap_t, capmgr_thd_create_thunk, thdclosure_index_t id, thdid_t *tid)
{
  406dc0:	f3 0f 1e fa          	endbr64 
  406dc4:	55                   	push   rbp
  406dc5:	48 89 e5             	mov    rbp,rsp
  406dc8:	41 57                	push   r15
	COS_CLIENT_INVCAP;
	word_t unused, tid_ret;
	thdcap_t ret;

	ret = cos_sinv_2rets(uc, id, 0, 0, 0, &tid_ret, &unused);
  406dca:	4c 63 ff             	movsxd r15,edi
{
  406dcd:	41 56                	push   r14
  406dcf:	41 55                	push   r13
  406dd1:	49 89 f5             	mov    r13,rsi
  406dd4:	41 54                	push   r12
  406dd6:	53                   	push   rbx
  406dd7:	48 83 ec 28          	sub    rsp,0x28
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  406ddb:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  406ddf:	4d 85 f6             	test   r14,r14
  406de2:	74 34                	je     406e18 <__cosrt_c_capmgr_thd_create_thunk+0x58>
  406de4:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  406de8:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  406dec:	31 c9                	xor    ecx,ecx
  406dee:	31 d2                	xor    edx,edx
  406df0:	31 f6                	xor    esi,esi
  406df2:	4c 89 ff             	mov    rdi,r15
  406df5:	41 ff d6             	call   r14
	*tid = tid_ret;
  406df8:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
	ret = cos_sinv_2rets(uc, id, 0, 0, 0, &tid_ret, &unused);
  406dfc:	48 98                	cdqe   
	*tid = tid_ret;
  406dfe:	49 89 55 00          	mov    QWORD PTR [r13+0x0],rdx

	return ret;
}
  406e02:	48 83 c4 28          	add    rsp,0x28
  406e06:	5b                   	pop    rbx
  406e07:	41 5c                	pop    r12
  406e09:	41 5d                	pop    r13
  406e0b:	41 5e                	pop    r14
  406e0d:	41 5f                	pop    r15
  406e0f:	5d                   	pop    rbp
  406e10:	c3                   	ret    
  406e11:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  406e18:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  406e1c:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  406e20:	4c 89 fb             	mov    rbx,r15
  406e23:	4c 89 f6             	mov    rsi,r14
  406e26:	4c 89 f7             	mov    rdi,r14
  406e29:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  406e2c:	83 c0 01             	add    eax,0x1
  406e2f:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  406e32:	48 89 29             	mov    QWORD PTR [rcx],rbp
  406e35:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  406e39:	48 89 cd             	mov    rbp,rcx
  406e3c:	49 b8 50 6e 40 00 00 	movabs r8,0x406e50
  406e43:	00 00 00 
  406e46:	0f 05                	syscall 
  406e48:	eb 0f                	jmp    406e59 <__cosrt_c_capmgr_thd_create_thunk+0x99>
  406e4a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  406e50:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  406e57:	eb 07                	jmp    406e60 <__cosrt_c_capmgr_thd_create_thunk+0xa0>
  406e59:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  406e60:	5d                   	pop    rbp
  406e61:	5c                   	pop    rsp
  406e62:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  406e66:	eb 90                	jmp    406df8 <__cosrt_c_capmgr_thd_create_thunk+0x38>
  406e68:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  406e6f:	00 

0000000000406e70 <__cosrt_c_capmgr_thd_create_ext>:

COS_CLIENT_STUB(thdcap_t, capmgr_thd_create_ext, spdid_t child, thdclosure_index_t idx, thdid_t *tid)
{
  406e70:	f3 0f 1e fa          	endbr64 
  406e74:	55                   	push   rbp
	COS_CLIENT_INVCAP;
	word_t unused, tid_ret;
	thdcap_t ret;

	ret = cos_sinv_2rets(uc, child, idx, 0, 0, &tid_ret, &unused);
  406e75:	48 63 f6             	movsxd rsi,esi
{
  406e78:	48 89 e5             	mov    rbp,rsp
  406e7b:	41 57                	push   r15
  406e7d:	49 89 d7             	mov    r15,rdx
  406e80:	41 56                	push   r14
  406e82:	41 55                	push   r13
	ret = cos_sinv_2rets(uc, child, idx, 0, 0, &tid_ret, &unused);
  406e84:	44 0f b7 ef          	movzx  r13d,di
{
  406e88:	41 54                	push   r12
  406e8a:	53                   	push   rbx
  406e8b:	48 83 ec 28          	sub    rsp,0x28
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  406e8f:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  406e93:	4d 85 f6             	test   r14,r14
  406e96:	74 30                	je     406ec8 <__cosrt_c_capmgr_thd_create_ext+0x58>
  406e98:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  406e9c:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  406ea0:	31 c9                	xor    ecx,ecx
  406ea2:	31 d2                	xor    edx,edx
  406ea4:	4c 89 ef             	mov    rdi,r13
  406ea7:	41 ff d6             	call   r14
	*tid = tid_ret;
  406eaa:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
	ret = cos_sinv_2rets(uc, child, idx, 0, 0, &tid_ret, &unused);
  406eae:	48 98                	cdqe   
	*tid = tid_ret;
  406eb0:	49 89 17             	mov    QWORD PTR [r15],rdx

	return ret;
}
  406eb3:	48 83 c4 28          	add    rsp,0x28
  406eb7:	5b                   	pop    rbx
  406eb8:	41 5c                	pop    r12
  406eba:	41 5d                	pop    r13
  406ebc:	41 5e                	pop    r14
  406ebe:	41 5f                	pop    r15
  406ec0:	5d                   	pop    rbp
  406ec1:	c3                   	ret    
  406ec2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  406ec8:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  406ecc:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  406ed0:	4c 89 eb             	mov    rbx,r13
  406ed3:	4c 89 f7             	mov    rdi,r14
  406ed6:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  406ed9:	83 c0 01             	add    eax,0x1
  406edc:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  406edf:	48 89 29             	mov    QWORD PTR [rcx],rbp
  406ee2:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  406ee6:	48 89 cd             	mov    rbp,rcx
  406ee9:	49 b8 00 6f 40 00 00 	movabs r8,0x406f00
  406ef0:	00 00 00 
  406ef3:	0f 05                	syscall 
  406ef5:	0f 1f 00             	nop    DWORD PTR [rax]
  406ef8:	eb 0f                	jmp    406f09 <__cosrt_c_capmgr_thd_create_ext+0x99>
  406efa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  406f00:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  406f07:	eb 07                	jmp    406f10 <__cosrt_c_capmgr_thd_create_ext+0xa0>
  406f09:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  406f10:	5d                   	pop    rbp
  406f11:	5c                   	pop    rsp
  406f12:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  406f16:	eb 92                	jmp    406eaa <__cosrt_c_capmgr_thd_create_ext+0x3a>
  406f18:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  406f1f:	00 

0000000000406f20 <__cosrt_c_capmgr_aep_create_thunk>:

COS_CLIENT_STUB(thdcap_t, capmgr_aep_create_thunk, struct cos_aep_info *aep, thdclosure_index_t idx, int owntc, cos_channelkey_t key, microsec_t ipiwin, u32_t ipimax)
{
  406f20:	f3 0f 1e fa          	endbr64 
  406f24:	55                   	push   rbp
  406f25:	48 89 e5             	mov    rbp,rsp
  406f28:	41 57                	push   r15
  406f2a:	41 56                	push   r14
  406f2c:	41 55                	push   r13
  406f2e:	41 54                	push   r12
  406f30:	53                   	push   rbx
  406f31:	48 83 ec 28          	sub    rsp,0x28
	COS_CLIENT_INVCAP;
	word_t tcrcvret   = 0;
  406f35:	48 c7 45 b0 00 00 00 	mov    QWORD PTR [rbp-0x50],0x0
  406f3c:	00 
	thdcap_t thd     = 0;
	thdid_t tid      = 0;
  406f3d:	48 c7 45 b8 00 00 00 	mov    QWORD PTR [rbp-0x48],0x0
  406f44:	00 
	u32_t owntc_idx  = (owntc << 16) | idx;
	u32_t key_ipimax = (key << 16) | ((ipimax << 16) >> 16);
	u32_t ipiwin32b  = (u32_t)ipiwin;

	if (idx < 1) return 0;
  406f45:	85 f6                	test   esi,esi
  406f47:	0f 8e 93 00 00 00    	jle    406fe0 <__cosrt_c_capmgr_aep_create_thunk+0xc0>
  406f4d:	41 89 d5             	mov    r13d,edx
	u32_t key_ipimax = (key << 16) | ((ipimax << 16) >> 16);
  406f50:	c1 e1 10             	shl    ecx,0x10
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  406f53:	4c 8b 78 10          	mov    r15,QWORD PTR [rax+0x10]
  406f57:	41 89 f2             	mov    r10d,esi
  406f5a:	45 0f b7 c9          	movzx  r9d,r9w

	thd = cos_sinv_2rets(uc, owntc_idx, key_ipimax, ipiwin32b, 0, &tid, &tcrcvret);
  406f5e:	89 ce                	mov    esi,ecx
	u32_t owntc_idx  = (owntc << 16) | idx;
  406f60:	41 c1 e5 10          	shl    r13d,0x10
  406f64:	49 89 fe             	mov    r14,rdi
	thd = cos_sinv_2rets(uc, owntc_idx, key_ipimax, ipiwin32b, 0, &tid, &tcrcvret);
  406f67:	44 09 ce             	or     esi,r9d
  406f6a:	44 89 c7             	mov    edi,r8d
  406f6d:	45 09 d5             	or     r13d,r10d
  406f70:	4d 85 ff             	test   r15,r15
  406f73:	0f 84 7f 00 00 00    	je     406ff8 <__cosrt_c_capmgr_aep_create_thunk+0xd8>
  406f79:	48 89 fa             	mov    rdx,rdi
  406f7c:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  406f80:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  406f84:	31 c9                	xor    ecx,ecx
  406f86:	4c 89 ef             	mov    rdi,r13
  406f89:	41 ff d7             	call   r15
  406f8c:	48 98                	cdqe   
	if (!thd) return 0;
  406f8e:	48 85 c0             	test   rax,rax
  406f91:	74 3a                	je     406fcd <__cosrt_c_capmgr_aep_create_thunk+0xad>

	aep->thd  = thd;
	aep->rcv  = (tcrcvret << 16) >> 16;
  406f93:	48 8b 55 b0          	mov    rdx,QWORD PTR [rbp-0x50]
	aep->tc   = (tcrcvret >> 16);
	aep->tid  = tid;
  406f97:	f3 0f 7e 4d b8       	movq   xmm1,QWORD PTR [rbp-0x48]
	aep->tc   = (tcrcvret >> 16);
  406f9c:	66 48 0f 6e d8       	movq   xmm3,rax
	aep->rcv  = (tcrcvret << 16) >> 16;
  406fa1:	48 b9 ff ff ff ff ff 	movabs rcx,0xffffffffffff
  406fa8:	ff 00 00 
  406fab:	48 21 d1             	and    rcx,rdx
	aep->tc   = (tcrcvret >> 16);
  406fae:	48 c1 ea 10          	shr    rdx,0x10
  406fb2:	66 48 0f 6e d1       	movq   xmm2,rcx
  406fb7:	66 48 0f 6e c2       	movq   xmm0,rdx
  406fbc:	66 0f 6c ca          	punpcklqdq xmm1,xmm2
  406fc0:	66 0f 6c c3          	punpcklqdq xmm0,xmm3
  406fc4:	41 0f 11 06          	movups XMMWORD PTR [r14],xmm0
  406fc8:	41 0f 11 4e 10       	movups XMMWORD PTR [r14+0x10],xmm1

	return thd;
}
  406fcd:	48 83 c4 28          	add    rsp,0x28
  406fd1:	5b                   	pop    rbx
  406fd2:	41 5c                	pop    r12
  406fd4:	41 5d                	pop    r13
  406fd6:	41 5e                	pop    r14
  406fd8:	41 5f                	pop    r15
  406fda:	5d                   	pop    rbp
  406fdb:	c3                   	ret    
  406fdc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  406fe0:	48 83 c4 28          	add    rsp,0x28
	if (idx < 1) return 0;
  406fe4:	31 c0                	xor    eax,eax
}
  406fe6:	5b                   	pop    rbx
  406fe7:	41 5c                	pop    r12
  406fe9:	41 5d                	pop    r13
  406feb:	41 5e                	pop    r14
  406fed:	41 5f                	pop    r15
  406fef:	5d                   	pop    rbp
  406ff0:	c3                   	ret    
  406ff1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  406ff8:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  406ffc:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  407000:	4c 89 eb             	mov    rbx,r13
  407003:	4c 89 fa             	mov    rdx,r15
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  407006:	83 c0 01             	add    eax,0x1
  407009:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40700c:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40700f:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  407013:	48 89 cd             	mov    rbp,rcx
  407016:	49 b8 30 70 40 00 00 	movabs r8,0x407030
  40701d:	00 00 00 
  407020:	0f 05                	syscall 
  407022:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  407028:	eb 0f                	jmp    407039 <__cosrt_c_capmgr_aep_create_thunk+0x119>
  40702a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  407030:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  407037:	eb 07                	jmp    407040 <__cosrt_c_capmgr_aep_create_thunk+0x120>
  407039:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  407040:	5d                   	pop    rbp
  407041:	5c                   	pop    rsp
  407042:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
  407046:	48 89 7d b0          	mov    QWORD PTR [rbp-0x50],rdi
	return ret;
  40704a:	e9 3d ff ff ff       	jmp    406f8c <__cosrt_c_capmgr_aep_create_thunk+0x6c>
  40704f:	90                   	nop

0000000000407050 <__cosrt_c_capmgr_aep_create_ext>:

COS_CLIENT_STUB(thdcap_t, capmgr_aep_create_ext, spdid_t child, struct cos_aep_info *aep, thdclosure_index_t idx, int owntc, cos_channelkey_t key, microsec_t ipiwin, u32_t ipimax, arcvcap_t *extrcv)
{
  407050:	f3 0f 1e fa          	endbr64 
  407054:	55                   	push   rbp
	COS_CLIENT_INVCAP;
	word_t drcvtidret  = 0;
	word_t tcrcvret    = 0;
	thdcap_t thd       = 0;
	u32_t spdid_thdidx = (child << 16) | ((idx << 16) >> 16);
	u32_t key_ipimax   = (key << 16) | ((ipimax << 16) >> 16);
  407055:	41 c1 e0 10          	shl    r8d,0x10
	u32_t spdid_thdidx = (child << 16) | ((idx << 16) >> 16);
  407059:	c1 e7 10             	shl    edi,0x10
{
  40705c:	48 89 e5             	mov    rbp,rsp
  40705f:	41 57                	push   r15
  407061:	41 89 d7             	mov    r15d,edx
  407064:	44 89 ca             	mov    edx,r9d
  407067:	41 56                	push   r14
	u32_t spdid_thdidx = (child << 16) | ((idx << 16) >> 16);
  407069:	45 0f bf ff          	movsx  r15d,r15w
	u32_t ipiwin32b    = (u32_t)ipiwin;

	thd = cos_sinv_2rets(uc, spdid_thdidx, owntc, key_ipimax, ipiwin32b, &drcvtidret, &tcrcvret);
  40706d:	45 89 c6             	mov    r14d,r8d
{
  407070:	41 55                	push   r13
  407072:	49 89 f5             	mov    r13,rsi
	thd = cos_sinv_2rets(uc, spdid_thdidx, owntc, key_ipimax, ipiwin32b, &drcvtidret, &tcrcvret);
  407075:	41 09 ff             	or     r15d,edi
{
  407078:	41 54                	push   r12
  40707a:	53                   	push   rbx
  40707b:	48 83 ec 28          	sub    rsp,0x28
	u32_t key_ipimax   = (key << 16) | ((ipimax << 16) >> 16);
  40707f:	0f b7 75 10          	movzx  esi,WORD PTR [rbp+0x10]
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  407083:	4c 8b 50 10          	mov    r10,QWORD PTR [rax+0x10]
	word_t drcvtidret  = 0;
  407087:	48 c7 45 b0 00 00 00 	mov    QWORD PTR [rbp-0x50],0x0
  40708e:	00 
	word_t tcrcvret    = 0;
  40708f:	48 c7 45 b8 00 00 00 	mov    QWORD PTR [rbp-0x48],0x0
  407096:	00 
	thd = cos_sinv_2rets(uc, spdid_thdidx, owntc, key_ipimax, ipiwin32b, &drcvtidret, &tcrcvret);
  407097:	41 09 f6             	or     r14d,esi
  40709a:	48 63 f1             	movsxd rsi,ecx
  40709d:	4d 85 d2             	test   r10,r10
  4070a0:	0f 84 8a 00 00 00    	je     407130 <__cosrt_c_capmgr_aep_create_ext+0xe0>
  4070a6:	48 89 d1             	mov    rcx,rdx
  4070a9:	4c 8d 4d b8          	lea    r9,[rbp-0x48]
  4070ad:	4c 8d 45 b0          	lea    r8,[rbp-0x50]
  4070b1:	4c 89 f2             	mov    rdx,r14
  4070b4:	4c 89 ff             	mov    rdi,r15
  4070b7:	41 ff d2             	call   r10
  4070ba:	48 98                	cdqe   
	if (!thd) return thd;
  4070bc:	48 85 c0             	test   rax,rax
  4070bf:	74 60                	je     407121 <__cosrt_c_capmgr_aep_create_ext+0xd1>

	aep->fn   = NULL;
	aep->data = NULL;
	aep->thd  = thd;
	aep->tid  = (drcvtidret << 16) >> 16;
	aep->rcv  = tcrcvret >> 16;
  4070c1:	48 8b 75 b8          	mov    rsi,QWORD PTR [rbp-0x48]
	aep->tid  = (drcvtidret << 16) >> 16;
  4070c5:	48 8b 4d b0          	mov    rcx,QWORD PTR [rbp-0x50]
	aep->tc   = (tcrcvret << 16) >> 16;
  4070c9:	48 ba ff ff ff ff ff 	movabs rdx,0xffffffffffff
  4070d0:	ff 00 00 
  4070d3:	66 48 0f 6e c8       	movq   xmm1,rax
	aep->fn   = NULL;
  4070d8:	49 c7 45 20 00 00 00 	mov    QWORD PTR [r13+0x20],0x0
  4070df:	00 
	aep->tc   = (tcrcvret << 16) >> 16;
  4070e0:	48 89 f3             	mov    rbx,rsi
	aep->rcv  = tcrcvret >> 16;
  4070e3:	48 c1 ee 10          	shr    rsi,0x10
	aep->data = NULL;
  4070e7:	49 c7 45 28 00 00 00 	mov    QWORD PTR [r13+0x28],0x0
  4070ee:	00 
	aep->tc   = (tcrcvret << 16) >> 16;
  4070ef:	48 21 d3             	and    rbx,rdx
	aep->tid  = (drcvtidret << 16) >> 16;
  4070f2:	48 21 ca             	and    rdx,rcx
	aep->tc   = (tcrcvret << 16) >> 16;
  4070f5:	66 48 0f 6e d6       	movq   xmm2,rsi
	*extrcv   = drcvtidret >> 16;
  4070fa:	48 c1 e9 10          	shr    rcx,0x10
	aep->tc   = (tcrcvret << 16) >> 16;
  4070fe:	66 48 0f 6e c3       	movq   xmm0,rbx
  407103:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  407107:	41 0f 11 45 00       	movups XMMWORD PTR [r13+0x0],xmm0
  40710c:	66 48 0f 6e c2       	movq   xmm0,rdx
	*extrcv   = drcvtidret >> 16;
  407111:	48 8b 55 18          	mov    rdx,QWORD PTR [rbp+0x18]
	aep->tc   = (tcrcvret << 16) >> 16;
  407115:	66 0f 6c c2          	punpcklqdq xmm0,xmm2
  407119:	41 0f 11 45 10       	movups XMMWORD PTR [r13+0x10],xmm0
	*extrcv   = drcvtidret >> 16;
  40711e:	48 89 0a             	mov    QWORD PTR [rdx],rcx

	return thd;
}
  407121:	48 83 c4 28          	add    rsp,0x28
  407125:	5b                   	pop    rbx
  407126:	41 5c                	pop    r12
  407128:	41 5d                	pop    r13
  40712a:	41 5e                	pop    r14
  40712c:	41 5f                	pop    r15
  40712e:	5d                   	pop    rbp
  40712f:	c3                   	ret    
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  407130:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  407134:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  407138:	4c 89 fb             	mov    rbx,r15
  40713b:	4c 89 f7             	mov    rdi,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40713e:	83 c0 01             	add    eax,0x1
  407141:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  407144:	48 89 29             	mov    QWORD PTR [rcx],rbp
  407147:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40714b:	48 89 cd             	mov    rbp,rcx
  40714e:	49 b8 68 71 40 00 00 	movabs r8,0x407168
  407155:	00 00 00 
  407158:	0f 05                	syscall 
  40715a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  407160:	eb 0f                	jmp    407171 <__cosrt_c_capmgr_aep_create_ext+0x121>
  407162:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  407168:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  40716f:	eb 07                	jmp    407178 <__cosrt_c_capmgr_aep_create_ext+0x128>
  407171:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  407178:	5d                   	pop    rbp
  407179:	5c                   	pop    rsp
  40717a:	48 89 75 b0          	mov    QWORD PTR [rbp-0x50],rsi
  40717e:	48 89 7d b8          	mov    QWORD PTR [rbp-0x48],rdi
	return ret;
  407182:	e9 33 ff ff ff       	jmp    4070ba <__cosrt_c_capmgr_aep_create_ext+0x6a>
  407187:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40718e:	00 00 

0000000000407190 <__cosrt_c_capmgr_vm_vmcb_create>:

COS_CLIENT_STUB(capid_t, capmgr_vm_vmcb_create, vm_vmcscap_t vmcs_cap, vm_msrbitmapcap_t msr_bitmap_cap, vm_lapicaccesscap_t lapic_access_cap, vm_lapiccap_t lapic_cap, vm_shared_mem_t shared_mem_cap, thdid_t handler_thd_id, word_t vpid)
{
  407190:	f3 0f 1e fa          	endbr64 
  407194:	55                   	push   rbp

	/* FIXME: MPK call gate make indirect call complicated, arguments passed via stack gets wrong, walk around now by avoiding pass that argument */
	vpid = handler_thd_id & 0xFFFF;
	handler_thd_id = (handler_thd_id >> 16) & 0xFFFF;

	arg1 = 0 | vmcs_cap << (16 * 1) | msr_bitmap_cap << (16 * 2) |  lapic_access_cap << (16 * 3);
  407195:	48 c1 e2 30          	shl    rdx,0x30
  407199:	48 c1 e6 20          	shl    rsi,0x20
  40719d:	48 c1 e7 10          	shl    rdi,0x10
  4071a1:	48 09 d6             	or     rsi,rdx
	arg2 = lapic_cap | shared_mem_cap << (16 * 1) | handler_thd_id << (16 * 2) | vpid << (16 * 3);
  4071a4:	49 c1 e0 10          	shl    r8,0x10
  4071a8:	4c 89 ca             	mov    rdx,r9
  4071ab:	48 c1 e2 30          	shl    rdx,0x30
	arg1 = 0 | vmcs_cap << (16 * 1) | msr_bitmap_cap << (16 * 2) |  lapic_access_cap << (16 * 3);
  4071af:	48 09 fe             	or     rsi,rdi
	arg2 = lapic_cap | shared_mem_cap << (16 * 1) | handler_thd_id << (16 * 2) | vpid << (16 * 3);
  4071b2:	49 09 c8             	or     r8,rcx
  4071b5:	49 c1 e1 10          	shl    r9,0x10
{
  4071b9:	48 89 e5             	mov    rbp,rsp
  4071bc:	41 56                	push   r14
  4071be:	41 55                	push   r13
	arg1 = 0 | vmcs_cap << (16 * 1) | msr_bitmap_cap << (16 * 2) |  lapic_access_cap << (16 * 3);
  4071c0:	49 89 f5             	mov    r13,rsi
	arg2 = lapic_cap | shared_mem_cap << (16 * 1) | handler_thd_id << (16 * 2) | vpid << (16 * 3);
  4071c3:	4c 89 c6             	mov    rsi,r8
{
  4071c6:	41 54                	push   r12
	arg2 = lapic_cap | shared_mem_cap << (16 * 1) | handler_thd_id << (16 * 2) | vpid << (16 * 3);
  4071c8:	48 09 d6             	or     rsi,rdx
  4071cb:	48 ba 00 00 00 00 ff 	movabs rdx,0xffff00000000
  4071d2:	ff 00 00 
{
  4071d5:	53                   	push   rbx
	arg2 = lapic_cap | shared_mem_cap << (16 * 1) | handler_thd_id << (16 * 2) | vpid << (16 * 3);
  4071d6:	49 21 d1             	and    r9,rdx
  4071d9:	4c 09 ce             	or     rsi,r9
{
  4071dc:	48 83 ec 20          	sub    rsp,0x20
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  4071e0:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
	word_t ret1 = 0;
  4071e4:	48 c7 45 c0 00 00 00 	mov    QWORD PTR [rbp-0x40],0x0
  4071eb:	00 
	word_t ret2 = 0;
  4071ec:	48 c7 45 c8 00 00 00 	mov    QWORD PTR [rbp-0x38],0x0
  4071f3:	00 
  4071f4:	4d 85 f6             	test   r14,r14
  4071f7:	74 27                	je     407220 <__cosrt_c_capmgr_vm_vmcb_create+0x90>
  4071f9:	4c 8d 4d c8          	lea    r9,[rbp-0x38]
  4071fd:	4c 8d 45 c0          	lea    r8,[rbp-0x40]
  407201:	4c 89 ef             	mov    rdi,r13
  407204:	31 c9                	xor    ecx,ecx
  407206:	31 d2                	xor    edx,edx
  407208:	41 ff d6             	call   r14
	cap = cos_sinv_2rets(uc, arg1, arg2, 0, 0, &ret1, &ret2);

	return cap;
}
  40720b:	48 83 c4 20          	add    rsp,0x20
  40720f:	5b                   	pop    rbx
	cap = cos_sinv_2rets(uc, arg1, arg2, 0, 0, &ret1, &ret2);
  407210:	48 98                	cdqe   
}
  407212:	41 5c                	pop    r12
  407214:	41 5d                	pop    r13
  407216:	41 5e                	pop    r14
  407218:	5d                   	pop    rbp
  407219:	c3                   	ret    
  40721a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  407220:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  407224:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  407228:	4c 89 eb             	mov    rbx,r13
  40722b:	4c 89 f7             	mov    rdi,r14
  40722e:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  407231:	83 c0 01             	add    eax,0x1
  407234:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  407237:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40723a:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40723e:	48 89 cd             	mov    rbp,rcx
  407241:	49 b8 58 72 40 00 00 	movabs r8,0x407258
  407248:	00 00 00 
  40724b:	0f 05                	syscall 
  40724d:	0f 1f 00             	nop    DWORD PTR [rax]
  407250:	eb 0f                	jmp    407261 <__cosrt_c_capmgr_vm_vmcb_create+0xd1>
  407252:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  407258:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  40725f:	eb 07                	jmp    407268 <__cosrt_c_capmgr_vm_vmcb_create+0xd8>
  407261:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  407268:	5d                   	pop    rbp
  407269:	5c                   	pop    rsp
  40726a:	48 83 c4 20          	add    rsp,0x20
	cap = cos_sinv_2rets(uc, arg1, arg2, 0, 0, &ret1, &ret2);
  40726e:	48 98                	cdqe   
}
  407270:	5b                   	pop    rbx
  407271:	41 5c                	pop    r12
  407273:	41 5d                	pop    r13
  407275:	41 5e                	pop    r14
  407277:	5d                   	pop    rbp
  407278:	c3                   	ret    
  407279:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000407280 <__cosrt_c_capmgr_initaep_create>:

COS_CLIENT_STUB(thdcap_t, capmgr_initaep_create, spdid_t child, struct cos_aep_info *aep, int owntc, cos_channelkey_t key, microsec_t ipiwin, u32_t ipimax, asndcap_t *snd)
{
  407280:	f3 0f 1e fa          	endbr64 
  407284:	55                   	push   rbp
	COS_CLIENT_INVCAP;
	u32_t child_owntc = (child << 16) | owntc;
	u32_t key_ipimax  = (key << 16) >> ipimax;
  407285:	c1 e1 10             	shl    ecx,0x10
	u32_t child_owntc = (child << 16) | owntc;
  407288:	c1 e7 10             	shl    edi,0x10
{
  40728b:	48 89 e5             	mov    rbp,rsp
  40728e:	41 57                	push   r15
  407290:	41 56                	push   r14
	u32_t child_owntc = (child << 16) | owntc;
  407292:	41 89 fe             	mov    r14d,edi
{
  407295:	41 55                	push   r13
  407297:	49 89 f5             	mov    r13,rsi
	u32_t key_ipimax  = (key << 16) >> ipimax;
  40729a:	89 ce                	mov    esi,ecx
	u32_t ipiwin32b   = (u32_t)ipiwin;
	thdcap_t thd = 0;
	word_t sndtidret = 0, rcvtcret = 0;

	thd = cos_sinv_2rets(uc, child_owntc, key_ipimax, ipiwin32b, 0, &sndtidret, &rcvtcret);
  40729c:	44 89 c9             	mov    ecx,r9d
{
  40729f:	41 54                	push   r12
	thd = cos_sinv_2rets(uc, child_owntc, key_ipimax, ipiwin32b, 0, &sndtidret, &rcvtcret);
  4072a1:	d3 fe                	sar    esi,cl
  4072a3:	41 09 d6             	or     r14d,edx
{
  4072a6:	53                   	push   rbx
  4072a7:	44 89 c3             	mov    ebx,r8d
  4072aa:	48 83 ec 28          	sub    rsp,0x28
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  4072ae:	4c 8b 78 10          	mov    r15,QWORD PTR [rax+0x10]
	word_t sndtidret = 0, rcvtcret = 0;
  4072b2:	48 c7 45 b0 00 00 00 	mov    QWORD PTR [rbp-0x50],0x0
  4072b9:	00 
  4072ba:	48 c7 45 b8 00 00 00 	mov    QWORD PTR [rbp-0x48],0x0
  4072c1:	00 
  4072c2:	4d 85 ff             	test   r15,r15
  4072c5:	0f 84 95 00 00 00    	je     407360 <__cosrt_c_capmgr_initaep_create+0xe0>
  4072cb:	4c 8d 4d b8          	lea    r9,[rbp-0x48]
  4072cf:	4c 8d 45 b0          	lea    r8,[rbp-0x50]
  4072d3:	31 c9                	xor    ecx,ecx
  4072d5:	48 89 da             	mov    rdx,rbx
  4072d8:	4c 89 f7             	mov    rdi,r14
  4072db:	41 ff d7             	call   r15
	thd = cos_sinv_2rets(uc, child_owntc, key_ipimax, ipiwin32b, 0, &sndtidret, &rcvtcret);
  4072de:	48 98                	cdqe   
	if (!thd) return thd;
  4072e0:	48 85 c0             	test   rax,rax
  4072e3:	74 64                	je     407349 <__cosrt_c_capmgr_initaep_create+0xc9>

	aep->fn   = NULL;
	aep->data = NULL;
	aep->thd  = thd;
	aep->tid  = (sndtidret << 16) >> 16;
	aep->rcv  = rcvtcret >> 16;
  4072e5:	48 8b 75 b8          	mov    rsi,QWORD PTR [rbp-0x48]
	aep->tid  = (sndtidret << 16) >> 16;
  4072e9:	48 8b 4d b0          	mov    rcx,QWORD PTR [rbp-0x50]
	aep->tc   = (rcvtcret << 16) >> 16;
  4072ed:	48 ba ff ff ff ff ff 	movabs rdx,0xffffffffffff
  4072f4:	ff 00 00 
  4072f7:	66 48 0f 6e c8       	movq   xmm1,rax
	*snd      = sndtidret >> 16;
  4072fc:	48 8b 45 10          	mov    rax,QWORD PTR [rbp+0x10]
	aep->fn   = NULL;
  407300:	49 c7 45 20 00 00 00 	mov    QWORD PTR [r13+0x20],0x0
  407307:	00 
	aep->tc   = (rcvtcret << 16) >> 16;
  407308:	48 89 f3             	mov    rbx,rsi
	aep->rcv  = rcvtcret >> 16;
  40730b:	48 c1 ee 10          	shr    rsi,0x10
	aep->data = NULL;
  40730f:	49 c7 45 28 00 00 00 	mov    QWORD PTR [r13+0x28],0x0
  407316:	00 
	aep->tc   = (rcvtcret << 16) >> 16;
  407317:	48 21 d3             	and    rbx,rdx
	aep->tid  = (sndtidret << 16) >> 16;
  40731a:	48 21 ca             	and    rdx,rcx
	aep->tc   = (rcvtcret << 16) >> 16;
  40731d:	66 48 0f 6e d6       	movq   xmm2,rsi
	*snd      = sndtidret >> 16;
  407322:	48 c1 e9 10          	shr    rcx,0x10
	aep->tc   = (rcvtcret << 16) >> 16;
  407326:	66 48 0f 6e c3       	movq   xmm0,rbx
  40732b:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  40732f:	41 0f 11 45 00       	movups XMMWORD PTR [r13+0x0],xmm0
  407334:	66 48 0f 6e c2       	movq   xmm0,rdx
  407339:	66 0f 6c c2          	punpcklqdq xmm0,xmm2
  40733d:	41 0f 11 45 10       	movups XMMWORD PTR [r13+0x10],xmm0
	*snd      = sndtidret >> 16;
  407342:	48 89 08             	mov    QWORD PTR [rax],rcx

	/* initcaps are copied to INITXXX offsets in the dst component */
	return aep->thd;
  407345:	49 8b 45 08          	mov    rax,QWORD PTR [r13+0x8]
}
  407349:	48 83 c4 28          	add    rsp,0x28
  40734d:	5b                   	pop    rbx
  40734e:	41 5c                	pop    r12
  407350:	41 5d                	pop    r13
  407352:	41 5e                	pop    r14
  407354:	41 5f                	pop    r15
  407356:	5d                   	pop    rbp
  407357:	c3                   	ret    
  407358:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40735f:	00 
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  407360:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  407364:	49 89 da             	mov    r10,rbx
	__asm__ __volatile__(
  407367:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  40736b:	4c 89 f3             	mov    rbx,r14
  40736e:	4c 89 d7             	mov    rdi,r10
  407371:	4c 89 fa             	mov    rdx,r15
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  407374:	83 c0 01             	add    eax,0x1
  407377:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40737a:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40737d:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  407381:	48 89 cd             	mov    rbp,rcx
  407384:	49 b8 98 73 40 00 00 	movabs r8,0x407398
  40738b:	00 00 00 
  40738e:	0f 05                	syscall 
  407390:	eb 0f                	jmp    4073a1 <__cosrt_c_capmgr_initaep_create+0x121>
  407392:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  407398:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  40739f:	eb 07                	jmp    4073a8 <__cosrt_c_capmgr_initaep_create+0x128>
  4073a1:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  4073a8:	5d                   	pop    rbp
  4073a9:	5c                   	pop    rsp
  4073aa:	48 89 75 b0          	mov    QWORD PTR [rbp-0x50],rsi
  4073ae:	48 89 7d b8          	mov    QWORD PTR [rbp-0x48],rdi
	return ret;
  4073b2:	e9 27 ff ff ff       	jmp    4072de <__cosrt_c_capmgr_initaep_create+0x5e>
  4073b7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  4073be:	00 00 

00000000004073c0 <__cosrt_extern_capmgr_initthd_create>:
  4073c0:	48 b8 e8 c0 5b 00 00 	movabs rax,0x5bc0e8
  4073c7:	00 00 00 
  4073ca:	ff 10                	call   QWORD PTR [rax]
  4073cc:	c3                   	ret    
  4073cd:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004073d0 <__cosrt_fast_callgate_capmgr_initthd_create>:
  4073d0:	55                   	push   rbp
  4073d1:	53                   	push   rbx
  4073d2:	41 54                	push   r12
  4073d4:	41 55                	push   r13
  4073d6:	41 56                	push   r14
  4073d8:	41 57                	push   r15
  4073da:	4d 89 c4             	mov    r12,r8
  4073dd:	4c 89 cb             	mov    rbx,r9
  4073e0:	49 89 c8             	mov    r8,rcx
  4073e3:	49 89 d1             	mov    r9,rdx
  4073e6:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4073ed:	be ad de 
  4073f0:	0f 01 f9             	rdtscp 
  4073f3:	48 89 ca             	mov    rdx,rcx
  4073f6:	48 25 ff 0f 00 00    	and    rax,0xfff
  4073fc:	48 89 e2             	mov    rdx,rsp
  4073ff:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  407406:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40740d:	00 
  40740e:	48 c1 e0 10          	shl    rax,0x10
  407412:	49 09 c5             	or     r13,rax
  407415:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40741c:	7f 00 00 
  40741f:	4c 89 e8             	mov    rax,r13
  407422:	48 25 ff ff 00 00    	and    rax,0xffff
  407428:	48 c1 e0 08          	shl    rax,0x8
  40742c:	49 01 c6             	add    r14,rax
  40742f:	b9 01 00 00 00       	mov    ecx,0x1
  407434:	01 c9                	add    ecx,ecx
  407436:	b8 03 00 00 00       	mov    eax,0x3
  40743b:	d3 e0                	shl    eax,cl
  40743d:	f7 d0                	not    eax
  40743f:	83 e0 fc             	and    eax,0xfffffffc
  407442:	48 31 c9             	xor    rcx,rcx
  407445:	48 31 d2             	xor    rdx,rdx
  407448:	0f 01 ef             	wrpkru 
  40744b:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40744e:	48 83 c2 01          	add    rdx,0x1
  407452:	48 c1 e2 04          	shl    rdx,0x4
  407456:	4c 01 f2             	add    rdx,r14
  407459:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  407460:	45 23 01 
  407463:	48 89 02             	mov    QWORD PTR [rdx],rax
  407466:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  40746a:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40746d:	48 83 c0 01          	add    rax,0x1
  407471:	49 89 06             	mov    QWORD PTR [r14],rax
  407474:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407479:	01 c9                	add    ecx,ecx
  40747b:	b8 03 00 00 00       	mov    eax,0x3
  407480:	d3 e0                	shl    eax,cl
  407482:	f7 d0                	not    eax
  407484:	83 e0 fc             	and    eax,0xfffffffc
  407487:	48 31 c9             	xor    rcx,rcx
  40748a:	48 31 d2             	xor    rdx,rdx
  40748d:	0f 01 ef             	wrpkru 
  407490:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  407497:	45 23 01 
  40749a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4074a1:	be ad de 
  4074a4:	49 39 c7             	cmp    r15,rax
  4074a7:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  4074ae:	12 12 12 
  4074b1:	48 b9 bd 74 40 00 00 	movabs rcx,0x4074bd
  4074b8:	00 00 00 
  4074bb:	ff e0                	jmp    rax

00000000004074bd <srv_call_ret_capmgr_initthd_create>:
  4074bd:	49 89 c0             	mov    r8,rax
  4074c0:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4074c7:	be ad de 
  4074ca:	48 89 e2             	mov    rdx,rsp
  4074cd:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4074d4:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4074db:	00 
  4074dc:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4074e3:	7f 00 00 
  4074e6:	4c 89 e8             	mov    rax,r13
  4074e9:	48 25 ff ff 00 00    	and    rax,0xffff
  4074ef:	48 c1 e0 08          	shl    rax,0x8
  4074f3:	49 01 c6             	add    r14,rax
  4074f6:	b9 01 00 00 00       	mov    ecx,0x1
  4074fb:	01 c9                	add    ecx,ecx
  4074fd:	b8 03 00 00 00       	mov    eax,0x3
  407502:	d3 e0                	shl    eax,cl
  407504:	f7 d0                	not    eax
  407506:	83 e0 fc             	and    eax,0xfffffffc
  407509:	48 31 c9             	xor    rcx,rcx
  40750c:	48 31 d2             	xor    rdx,rdx
  40750f:	0f 01 ef             	wrpkru 
  407512:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  407515:	48 c1 e2 04          	shl    rdx,0x4
  407519:	4c 01 f2             	add    rdx,r14
  40751c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  407520:	49 8b 06             	mov    rax,QWORD PTR [r14]
  407523:	48 83 e8 01          	sub    rax,0x1
  407527:	49 89 06             	mov    QWORD PTR [r14],rax
  40752a:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40752f:	01 c9                	add    ecx,ecx
  407531:	b8 03 00 00 00       	mov    eax,0x3
  407536:	d3 e0                	shl    eax,cl
  407538:	f7 d0                	not    eax
  40753a:	83 e0 fc             	and    eax,0xfffffffc
  40753d:	48 31 c9             	xor    rcx,rcx
  407540:	48 31 d2             	xor    rdx,rdx
  407543:	0f 01 ef             	wrpkru 
  407546:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40754d:	be ad de 
  407550:	49 39 c7             	cmp    r15,rax
  407553:	4c 89 c0             	mov    rax,r8
  407556:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  40755a:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  40755d:	41 5f                	pop    r15
  40755f:	41 5e                	pop    r14
  407561:	41 5d                	pop    r13
  407563:	41 5c                	pop    r12
  407565:	5b                   	pop    rbx
  407566:	5d                   	pop    rbp
  407567:	c3                   	ret    
  407568:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40756f:	00 

0000000000407570 <__cosrt_extern_capmgr_thd_create_thunk>:
  407570:	48 b8 00 c1 5b 00 00 	movabs rax,0x5bc100
  407577:	00 00 00 
  40757a:	ff 10                	call   QWORD PTR [rax]
  40757c:	c3                   	ret    
  40757d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000407580 <__cosrt_fast_callgate_capmgr_thd_create_thunk>:
  407580:	55                   	push   rbp
  407581:	53                   	push   rbx
  407582:	41 54                	push   r12
  407584:	41 55                	push   r13
  407586:	41 56                	push   r14
  407588:	41 57                	push   r15
  40758a:	4d 89 c4             	mov    r12,r8
  40758d:	4c 89 cb             	mov    rbx,r9
  407590:	49 89 c8             	mov    r8,rcx
  407593:	49 89 d1             	mov    r9,rdx
  407596:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40759d:	be ad de 
  4075a0:	0f 01 f9             	rdtscp 
  4075a3:	48 89 ca             	mov    rdx,rcx
  4075a6:	48 25 ff 0f 00 00    	and    rax,0xfff
  4075ac:	48 89 e2             	mov    rdx,rsp
  4075af:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4075b6:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4075bd:	00 
  4075be:	48 c1 e0 10          	shl    rax,0x10
  4075c2:	49 09 c5             	or     r13,rax
  4075c5:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4075cc:	7f 00 00 
  4075cf:	4c 89 e8             	mov    rax,r13
  4075d2:	48 25 ff ff 00 00    	and    rax,0xffff
  4075d8:	48 c1 e0 08          	shl    rax,0x8
  4075dc:	49 01 c6             	add    r14,rax
  4075df:	b9 01 00 00 00       	mov    ecx,0x1
  4075e4:	01 c9                	add    ecx,ecx
  4075e6:	b8 03 00 00 00       	mov    eax,0x3
  4075eb:	d3 e0                	shl    eax,cl
  4075ed:	f7 d0                	not    eax
  4075ef:	83 e0 fc             	and    eax,0xfffffffc
  4075f2:	48 31 c9             	xor    rcx,rcx
  4075f5:	48 31 d2             	xor    rdx,rdx
  4075f8:	0f 01 ef             	wrpkru 
  4075fb:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4075fe:	48 83 c2 01          	add    rdx,0x1
  407602:	48 c1 e2 04          	shl    rdx,0x4
  407606:	4c 01 f2             	add    rdx,r14
  407609:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  407610:	45 23 01 
  407613:	48 89 02             	mov    QWORD PTR [rdx],rax
  407616:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  40761a:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40761d:	48 83 c0 01          	add    rax,0x1
  407621:	49 89 06             	mov    QWORD PTR [r14],rax
  407624:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407629:	01 c9                	add    ecx,ecx
  40762b:	b8 03 00 00 00       	mov    eax,0x3
  407630:	d3 e0                	shl    eax,cl
  407632:	f7 d0                	not    eax
  407634:	83 e0 fc             	and    eax,0xfffffffc
  407637:	48 31 c9             	xor    rcx,rcx
  40763a:	48 31 d2             	xor    rdx,rdx
  40763d:	0f 01 ef             	wrpkru 
  407640:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  407647:	45 23 01 
  40764a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407651:	be ad de 
  407654:	49 39 c7             	cmp    r15,rax
  407657:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  40765e:	12 12 12 
  407661:	48 b9 6d 76 40 00 00 	movabs rcx,0x40766d
  407668:	00 00 00 
  40766b:	ff e0                	jmp    rax

000000000040766d <srv_call_ret_capmgr_thd_create_thunk>:
  40766d:	49 89 c0             	mov    r8,rax
  407670:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  407677:	be ad de 
  40767a:	48 89 e2             	mov    rdx,rsp
  40767d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  407684:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40768b:	00 
  40768c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  407693:	7f 00 00 
  407696:	4c 89 e8             	mov    rax,r13
  407699:	48 25 ff ff 00 00    	and    rax,0xffff
  40769f:	48 c1 e0 08          	shl    rax,0x8
  4076a3:	49 01 c6             	add    r14,rax
  4076a6:	b9 01 00 00 00       	mov    ecx,0x1
  4076ab:	01 c9                	add    ecx,ecx
  4076ad:	b8 03 00 00 00       	mov    eax,0x3
  4076b2:	d3 e0                	shl    eax,cl
  4076b4:	f7 d0                	not    eax
  4076b6:	83 e0 fc             	and    eax,0xfffffffc
  4076b9:	48 31 c9             	xor    rcx,rcx
  4076bc:	48 31 d2             	xor    rdx,rdx
  4076bf:	0f 01 ef             	wrpkru 
  4076c2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4076c5:	48 c1 e2 04          	shl    rdx,0x4
  4076c9:	4c 01 f2             	add    rdx,r14
  4076cc:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  4076d0:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4076d3:	48 83 e8 01          	sub    rax,0x1
  4076d7:	49 89 06             	mov    QWORD PTR [r14],rax
  4076da:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4076df:	01 c9                	add    ecx,ecx
  4076e1:	b8 03 00 00 00       	mov    eax,0x3
  4076e6:	d3 e0                	shl    eax,cl
  4076e8:	f7 d0                	not    eax
  4076ea:	83 e0 fc             	and    eax,0xfffffffc
  4076ed:	48 31 c9             	xor    rcx,rcx
  4076f0:	48 31 d2             	xor    rdx,rdx
  4076f3:	0f 01 ef             	wrpkru 
  4076f6:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4076fd:	be ad de 
  407700:	49 39 c7             	cmp    r15,rax
  407703:	4c 89 c0             	mov    rax,r8
  407706:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  40770a:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  40770d:	41 5f                	pop    r15
  40770f:	41 5e                	pop    r14
  407711:	41 5d                	pop    r13
  407713:	41 5c                	pop    r12
  407715:	5b                   	pop    rbx
  407716:	5d                   	pop    rbp
  407717:	c3                   	ret    
  407718:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40771f:	00 

0000000000407720 <__cosrt_extern_capmgr_thd_create_ext>:
  407720:	48 b8 18 c1 5b 00 00 	movabs rax,0x5bc118
  407727:	00 00 00 
  40772a:	ff 10                	call   QWORD PTR [rax]
  40772c:	c3                   	ret    
  40772d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000407730 <__cosrt_fast_callgate_capmgr_thd_create_ext>:
  407730:	55                   	push   rbp
  407731:	53                   	push   rbx
  407732:	41 54                	push   r12
  407734:	41 55                	push   r13
  407736:	41 56                	push   r14
  407738:	41 57                	push   r15
  40773a:	4d 89 c4             	mov    r12,r8
  40773d:	4c 89 cb             	mov    rbx,r9
  407740:	49 89 c8             	mov    r8,rcx
  407743:	49 89 d1             	mov    r9,rdx
  407746:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40774d:	be ad de 
  407750:	0f 01 f9             	rdtscp 
  407753:	48 89 ca             	mov    rdx,rcx
  407756:	48 25 ff 0f 00 00    	and    rax,0xfff
  40775c:	48 89 e2             	mov    rdx,rsp
  40775f:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  407766:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40776d:	00 
  40776e:	48 c1 e0 10          	shl    rax,0x10
  407772:	49 09 c5             	or     r13,rax
  407775:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40777c:	7f 00 00 
  40777f:	4c 89 e8             	mov    rax,r13
  407782:	48 25 ff ff 00 00    	and    rax,0xffff
  407788:	48 c1 e0 08          	shl    rax,0x8
  40778c:	49 01 c6             	add    r14,rax
  40778f:	b9 01 00 00 00       	mov    ecx,0x1
  407794:	01 c9                	add    ecx,ecx
  407796:	b8 03 00 00 00       	mov    eax,0x3
  40779b:	d3 e0                	shl    eax,cl
  40779d:	f7 d0                	not    eax
  40779f:	83 e0 fc             	and    eax,0xfffffffc
  4077a2:	48 31 c9             	xor    rcx,rcx
  4077a5:	48 31 d2             	xor    rdx,rdx
  4077a8:	0f 01 ef             	wrpkru 
  4077ab:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4077ae:	48 83 c2 01          	add    rdx,0x1
  4077b2:	48 c1 e2 04          	shl    rdx,0x4
  4077b6:	4c 01 f2             	add    rdx,r14
  4077b9:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  4077c0:	45 23 01 
  4077c3:	48 89 02             	mov    QWORD PTR [rdx],rax
  4077c6:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  4077ca:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4077cd:	48 83 c0 01          	add    rax,0x1
  4077d1:	49 89 06             	mov    QWORD PTR [r14],rax
  4077d4:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4077d9:	01 c9                	add    ecx,ecx
  4077db:	b8 03 00 00 00       	mov    eax,0x3
  4077e0:	d3 e0                	shl    eax,cl
  4077e2:	f7 d0                	not    eax
  4077e4:	83 e0 fc             	and    eax,0xfffffffc
  4077e7:	48 31 c9             	xor    rcx,rcx
  4077ea:	48 31 d2             	xor    rdx,rdx
  4077ed:	0f 01 ef             	wrpkru 
  4077f0:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  4077f7:	45 23 01 
  4077fa:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407801:	be ad de 
  407804:	49 39 c7             	cmp    r15,rax
  407807:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  40780e:	12 12 12 
  407811:	48 b9 1d 78 40 00 00 	movabs rcx,0x40781d
  407818:	00 00 00 
  40781b:	ff e0                	jmp    rax

000000000040781d <srv_call_ret_capmgr_thd_create_ext>:
  40781d:	49 89 c0             	mov    r8,rax
  407820:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  407827:	be ad de 
  40782a:	48 89 e2             	mov    rdx,rsp
  40782d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  407834:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40783b:	00 
  40783c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  407843:	7f 00 00 
  407846:	4c 89 e8             	mov    rax,r13
  407849:	48 25 ff ff 00 00    	and    rax,0xffff
  40784f:	48 c1 e0 08          	shl    rax,0x8
  407853:	49 01 c6             	add    r14,rax
  407856:	b9 01 00 00 00       	mov    ecx,0x1
  40785b:	01 c9                	add    ecx,ecx
  40785d:	b8 03 00 00 00       	mov    eax,0x3
  407862:	d3 e0                	shl    eax,cl
  407864:	f7 d0                	not    eax
  407866:	83 e0 fc             	and    eax,0xfffffffc
  407869:	48 31 c9             	xor    rcx,rcx
  40786c:	48 31 d2             	xor    rdx,rdx
  40786f:	0f 01 ef             	wrpkru 
  407872:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  407875:	48 c1 e2 04          	shl    rdx,0x4
  407879:	4c 01 f2             	add    rdx,r14
  40787c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  407880:	49 8b 06             	mov    rax,QWORD PTR [r14]
  407883:	48 83 e8 01          	sub    rax,0x1
  407887:	49 89 06             	mov    QWORD PTR [r14],rax
  40788a:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40788f:	01 c9                	add    ecx,ecx
  407891:	b8 03 00 00 00       	mov    eax,0x3
  407896:	d3 e0                	shl    eax,cl
  407898:	f7 d0                	not    eax
  40789a:	83 e0 fc             	and    eax,0xfffffffc
  40789d:	48 31 c9             	xor    rcx,rcx
  4078a0:	48 31 d2             	xor    rdx,rdx
  4078a3:	0f 01 ef             	wrpkru 
  4078a6:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4078ad:	be ad de 
  4078b0:	49 39 c7             	cmp    r15,rax
  4078b3:	4c 89 c0             	mov    rax,r8
  4078b6:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  4078ba:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  4078bd:	41 5f                	pop    r15
  4078bf:	41 5e                	pop    r14
  4078c1:	41 5d                	pop    r13
  4078c3:	41 5c                	pop    r12
  4078c5:	5b                   	pop    rbx
  4078c6:	5d                   	pop    rbp
  4078c7:	c3                   	ret    
  4078c8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4078cf:	00 

00000000004078d0 <__cosrt_extern_capmgr_initaep_create>:
  4078d0:	48 b8 30 c1 5b 00 00 	movabs rax,0x5bc130
  4078d7:	00 00 00 
  4078da:	ff 10                	call   QWORD PTR [rax]
  4078dc:	c3                   	ret    
  4078dd:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004078e0 <__cosrt_fast_callgate_capmgr_initaep_create>:
  4078e0:	55                   	push   rbp
  4078e1:	53                   	push   rbx
  4078e2:	41 54                	push   r12
  4078e4:	41 55                	push   r13
  4078e6:	41 56                	push   r14
  4078e8:	41 57                	push   r15
  4078ea:	4d 89 c4             	mov    r12,r8
  4078ed:	4c 89 cb             	mov    rbx,r9
  4078f0:	49 89 c8             	mov    r8,rcx
  4078f3:	49 89 d1             	mov    r9,rdx
  4078f6:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4078fd:	be ad de 
  407900:	0f 01 f9             	rdtscp 
  407903:	48 89 ca             	mov    rdx,rcx
  407906:	48 25 ff 0f 00 00    	and    rax,0xfff
  40790c:	48 89 e2             	mov    rdx,rsp
  40790f:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  407916:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40791d:	00 
  40791e:	48 c1 e0 10          	shl    rax,0x10
  407922:	49 09 c5             	or     r13,rax
  407925:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40792c:	7f 00 00 
  40792f:	4c 89 e8             	mov    rax,r13
  407932:	48 25 ff ff 00 00    	and    rax,0xffff
  407938:	48 c1 e0 08          	shl    rax,0x8
  40793c:	49 01 c6             	add    r14,rax
  40793f:	b9 01 00 00 00       	mov    ecx,0x1
  407944:	01 c9                	add    ecx,ecx
  407946:	b8 03 00 00 00       	mov    eax,0x3
  40794b:	d3 e0                	shl    eax,cl
  40794d:	f7 d0                	not    eax
  40794f:	83 e0 fc             	and    eax,0xfffffffc
  407952:	48 31 c9             	xor    rcx,rcx
  407955:	48 31 d2             	xor    rdx,rdx
  407958:	0f 01 ef             	wrpkru 
  40795b:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40795e:	48 83 c2 01          	add    rdx,0x1
  407962:	48 c1 e2 04          	shl    rdx,0x4
  407966:	4c 01 f2             	add    rdx,r14
  407969:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  407970:	45 23 01 
  407973:	48 89 02             	mov    QWORD PTR [rdx],rax
  407976:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  40797a:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40797d:	48 83 c0 01          	add    rax,0x1
  407981:	49 89 06             	mov    QWORD PTR [r14],rax
  407984:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407989:	01 c9                	add    ecx,ecx
  40798b:	b8 03 00 00 00       	mov    eax,0x3
  407990:	d3 e0                	shl    eax,cl
  407992:	f7 d0                	not    eax
  407994:	83 e0 fc             	and    eax,0xfffffffc
  407997:	48 31 c9             	xor    rcx,rcx
  40799a:	48 31 d2             	xor    rdx,rdx
  40799d:	0f 01 ef             	wrpkru 
  4079a0:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  4079a7:	45 23 01 
  4079aa:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4079b1:	be ad de 
  4079b4:	49 39 c7             	cmp    r15,rax
  4079b7:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  4079be:	12 12 12 
  4079c1:	48 b9 cd 79 40 00 00 	movabs rcx,0x4079cd
  4079c8:	00 00 00 
  4079cb:	ff e0                	jmp    rax

00000000004079cd <srv_call_ret_capmgr_initaep_create>:
  4079cd:	49 89 c0             	mov    r8,rax
  4079d0:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4079d7:	be ad de 
  4079da:	48 89 e2             	mov    rdx,rsp
  4079dd:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4079e4:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4079eb:	00 
  4079ec:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4079f3:	7f 00 00 
  4079f6:	4c 89 e8             	mov    rax,r13
  4079f9:	48 25 ff ff 00 00    	and    rax,0xffff
  4079ff:	48 c1 e0 08          	shl    rax,0x8
  407a03:	49 01 c6             	add    r14,rax
  407a06:	b9 01 00 00 00       	mov    ecx,0x1
  407a0b:	01 c9                	add    ecx,ecx
  407a0d:	b8 03 00 00 00       	mov    eax,0x3
  407a12:	d3 e0                	shl    eax,cl
  407a14:	f7 d0                	not    eax
  407a16:	83 e0 fc             	and    eax,0xfffffffc
  407a19:	48 31 c9             	xor    rcx,rcx
  407a1c:	48 31 d2             	xor    rdx,rdx
  407a1f:	0f 01 ef             	wrpkru 
  407a22:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  407a25:	48 c1 e2 04          	shl    rdx,0x4
  407a29:	4c 01 f2             	add    rdx,r14
  407a2c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  407a30:	49 8b 06             	mov    rax,QWORD PTR [r14]
  407a33:	48 83 e8 01          	sub    rax,0x1
  407a37:	49 89 06             	mov    QWORD PTR [r14],rax
  407a3a:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407a3f:	01 c9                	add    ecx,ecx
  407a41:	b8 03 00 00 00       	mov    eax,0x3
  407a46:	d3 e0                	shl    eax,cl
  407a48:	f7 d0                	not    eax
  407a4a:	83 e0 fc             	and    eax,0xfffffffc
  407a4d:	48 31 c9             	xor    rcx,rcx
  407a50:	48 31 d2             	xor    rdx,rdx
  407a53:	0f 01 ef             	wrpkru 
  407a56:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407a5d:	be ad de 
  407a60:	49 39 c7             	cmp    r15,rax
  407a63:	4c 89 c0             	mov    rax,r8
  407a66:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  407a6a:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  407a6d:	41 5f                	pop    r15
  407a6f:	41 5e                	pop    r14
  407a71:	41 5d                	pop    r13
  407a73:	41 5c                	pop    r12
  407a75:	5b                   	pop    rbx
  407a76:	5d                   	pop    rbp
  407a77:	c3                   	ret    
  407a78:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  407a7f:	00 

0000000000407a80 <__cosrt_extern_capmgr_aep_create_thunk>:
  407a80:	48 b8 48 c1 5b 00 00 	movabs rax,0x5bc148
  407a87:	00 00 00 
  407a8a:	ff 10                	call   QWORD PTR [rax]
  407a8c:	c3                   	ret    
  407a8d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000407a90 <__cosrt_fast_callgate_capmgr_aep_create_thunk>:
  407a90:	55                   	push   rbp
  407a91:	53                   	push   rbx
  407a92:	41 54                	push   r12
  407a94:	41 55                	push   r13
  407a96:	41 56                	push   r14
  407a98:	41 57                	push   r15
  407a9a:	4d 89 c4             	mov    r12,r8
  407a9d:	4c 89 cb             	mov    rbx,r9
  407aa0:	49 89 c8             	mov    r8,rcx
  407aa3:	49 89 d1             	mov    r9,rdx
  407aa6:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  407aad:	be ad de 
  407ab0:	0f 01 f9             	rdtscp 
  407ab3:	48 89 ca             	mov    rdx,rcx
  407ab6:	48 25 ff 0f 00 00    	and    rax,0xfff
  407abc:	48 89 e2             	mov    rdx,rsp
  407abf:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  407ac6:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  407acd:	00 
  407ace:	48 c1 e0 10          	shl    rax,0x10
  407ad2:	49 09 c5             	or     r13,rax
  407ad5:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  407adc:	7f 00 00 
  407adf:	4c 89 e8             	mov    rax,r13
  407ae2:	48 25 ff ff 00 00    	and    rax,0xffff
  407ae8:	48 c1 e0 08          	shl    rax,0x8
  407aec:	49 01 c6             	add    r14,rax
  407aef:	b9 01 00 00 00       	mov    ecx,0x1
  407af4:	01 c9                	add    ecx,ecx
  407af6:	b8 03 00 00 00       	mov    eax,0x3
  407afb:	d3 e0                	shl    eax,cl
  407afd:	f7 d0                	not    eax
  407aff:	83 e0 fc             	and    eax,0xfffffffc
  407b02:	48 31 c9             	xor    rcx,rcx
  407b05:	48 31 d2             	xor    rdx,rdx
  407b08:	0f 01 ef             	wrpkru 
  407b0b:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  407b0e:	48 83 c2 01          	add    rdx,0x1
  407b12:	48 c1 e2 04          	shl    rdx,0x4
  407b16:	4c 01 f2             	add    rdx,r14
  407b19:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  407b20:	45 23 01 
  407b23:	48 89 02             	mov    QWORD PTR [rdx],rax
  407b26:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  407b2a:	49 8b 06             	mov    rax,QWORD PTR [r14]
  407b2d:	48 83 c0 01          	add    rax,0x1
  407b31:	49 89 06             	mov    QWORD PTR [r14],rax
  407b34:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407b39:	01 c9                	add    ecx,ecx
  407b3b:	b8 03 00 00 00       	mov    eax,0x3
  407b40:	d3 e0                	shl    eax,cl
  407b42:	f7 d0                	not    eax
  407b44:	83 e0 fc             	and    eax,0xfffffffc
  407b47:	48 31 c9             	xor    rcx,rcx
  407b4a:	48 31 d2             	xor    rdx,rdx
  407b4d:	0f 01 ef             	wrpkru 
  407b50:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  407b57:	45 23 01 
  407b5a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407b61:	be ad de 
  407b64:	49 39 c7             	cmp    r15,rax
  407b67:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  407b6e:	12 12 12 
  407b71:	48 b9 7d 7b 40 00 00 	movabs rcx,0x407b7d
  407b78:	00 00 00 
  407b7b:	ff e0                	jmp    rax

0000000000407b7d <srv_call_ret_capmgr_aep_create_thunk>:
  407b7d:	49 89 c0             	mov    r8,rax
  407b80:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  407b87:	be ad de 
  407b8a:	48 89 e2             	mov    rdx,rsp
  407b8d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  407b94:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  407b9b:	00 
  407b9c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  407ba3:	7f 00 00 
  407ba6:	4c 89 e8             	mov    rax,r13
  407ba9:	48 25 ff ff 00 00    	and    rax,0xffff
  407baf:	48 c1 e0 08          	shl    rax,0x8
  407bb3:	49 01 c6             	add    r14,rax
  407bb6:	b9 01 00 00 00       	mov    ecx,0x1
  407bbb:	01 c9                	add    ecx,ecx
  407bbd:	b8 03 00 00 00       	mov    eax,0x3
  407bc2:	d3 e0                	shl    eax,cl
  407bc4:	f7 d0                	not    eax
  407bc6:	83 e0 fc             	and    eax,0xfffffffc
  407bc9:	48 31 c9             	xor    rcx,rcx
  407bcc:	48 31 d2             	xor    rdx,rdx
  407bcf:	0f 01 ef             	wrpkru 
  407bd2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  407bd5:	48 c1 e2 04          	shl    rdx,0x4
  407bd9:	4c 01 f2             	add    rdx,r14
  407bdc:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  407be0:	49 8b 06             	mov    rax,QWORD PTR [r14]
  407be3:	48 83 e8 01          	sub    rax,0x1
  407be7:	49 89 06             	mov    QWORD PTR [r14],rax
  407bea:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407bef:	01 c9                	add    ecx,ecx
  407bf1:	b8 03 00 00 00       	mov    eax,0x3
  407bf6:	d3 e0                	shl    eax,cl
  407bf8:	f7 d0                	not    eax
  407bfa:	83 e0 fc             	and    eax,0xfffffffc
  407bfd:	48 31 c9             	xor    rcx,rcx
  407c00:	48 31 d2             	xor    rdx,rdx
  407c03:	0f 01 ef             	wrpkru 
  407c06:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407c0d:	be ad de 
  407c10:	49 39 c7             	cmp    r15,rax
  407c13:	4c 89 c0             	mov    rax,r8
  407c16:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  407c1a:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  407c1d:	41 5f                	pop    r15
  407c1f:	41 5e                	pop    r14
  407c21:	41 5d                	pop    r13
  407c23:	41 5c                	pop    r12
  407c25:	5b                   	pop    rbx
  407c26:	5d                   	pop    rbp
  407c27:	c3                   	ret    
  407c28:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  407c2f:	00 

0000000000407c30 <__cosrt_extern_capmgr_aep_create_ext>:
  407c30:	48 b8 60 c1 5b 00 00 	movabs rax,0x5bc160
  407c37:	00 00 00 
  407c3a:	ff 10                	call   QWORD PTR [rax]
  407c3c:	c3                   	ret    
  407c3d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000407c40 <__cosrt_fast_callgate_capmgr_aep_create_ext>:
  407c40:	55                   	push   rbp
  407c41:	53                   	push   rbx
  407c42:	41 54                	push   r12
  407c44:	41 55                	push   r13
  407c46:	41 56                	push   r14
  407c48:	41 57                	push   r15
  407c4a:	4d 89 c4             	mov    r12,r8
  407c4d:	4c 89 cb             	mov    rbx,r9
  407c50:	49 89 c8             	mov    r8,rcx
  407c53:	49 89 d1             	mov    r9,rdx
  407c56:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  407c5d:	be ad de 
  407c60:	0f 01 f9             	rdtscp 
  407c63:	48 89 ca             	mov    rdx,rcx
  407c66:	48 25 ff 0f 00 00    	and    rax,0xfff
  407c6c:	48 89 e2             	mov    rdx,rsp
  407c6f:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  407c76:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  407c7d:	00 
  407c7e:	48 c1 e0 10          	shl    rax,0x10
  407c82:	49 09 c5             	or     r13,rax
  407c85:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  407c8c:	7f 00 00 
  407c8f:	4c 89 e8             	mov    rax,r13
  407c92:	48 25 ff ff 00 00    	and    rax,0xffff
  407c98:	48 c1 e0 08          	shl    rax,0x8
  407c9c:	49 01 c6             	add    r14,rax
  407c9f:	b9 01 00 00 00       	mov    ecx,0x1
  407ca4:	01 c9                	add    ecx,ecx
  407ca6:	b8 03 00 00 00       	mov    eax,0x3
  407cab:	d3 e0                	shl    eax,cl
  407cad:	f7 d0                	not    eax
  407caf:	83 e0 fc             	and    eax,0xfffffffc
  407cb2:	48 31 c9             	xor    rcx,rcx
  407cb5:	48 31 d2             	xor    rdx,rdx
  407cb8:	0f 01 ef             	wrpkru 
  407cbb:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  407cbe:	48 83 c2 01          	add    rdx,0x1
  407cc2:	48 c1 e2 04          	shl    rdx,0x4
  407cc6:	4c 01 f2             	add    rdx,r14
  407cc9:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  407cd0:	45 23 01 
  407cd3:	48 89 02             	mov    QWORD PTR [rdx],rax
  407cd6:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  407cda:	49 8b 06             	mov    rax,QWORD PTR [r14]
  407cdd:	48 83 c0 01          	add    rax,0x1
  407ce1:	49 89 06             	mov    QWORD PTR [r14],rax
  407ce4:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407ce9:	01 c9                	add    ecx,ecx
  407ceb:	b8 03 00 00 00       	mov    eax,0x3
  407cf0:	d3 e0                	shl    eax,cl
  407cf2:	f7 d0                	not    eax
  407cf4:	83 e0 fc             	and    eax,0xfffffffc
  407cf7:	48 31 c9             	xor    rcx,rcx
  407cfa:	48 31 d2             	xor    rdx,rdx
  407cfd:	0f 01 ef             	wrpkru 
  407d00:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  407d07:	45 23 01 
  407d0a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407d11:	be ad de 
  407d14:	49 39 c7             	cmp    r15,rax
  407d17:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  407d1e:	12 12 12 
  407d21:	48 b9 2d 7d 40 00 00 	movabs rcx,0x407d2d
  407d28:	00 00 00 
  407d2b:	ff e0                	jmp    rax

0000000000407d2d <srv_call_ret_capmgr_aep_create_ext>:
  407d2d:	49 89 c0             	mov    r8,rax
  407d30:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  407d37:	be ad de 
  407d3a:	48 89 e2             	mov    rdx,rsp
  407d3d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  407d44:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  407d4b:	00 
  407d4c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  407d53:	7f 00 00 
  407d56:	4c 89 e8             	mov    rax,r13
  407d59:	48 25 ff ff 00 00    	and    rax,0xffff
  407d5f:	48 c1 e0 08          	shl    rax,0x8
  407d63:	49 01 c6             	add    r14,rax
  407d66:	b9 01 00 00 00       	mov    ecx,0x1
  407d6b:	01 c9                	add    ecx,ecx
  407d6d:	b8 03 00 00 00       	mov    eax,0x3
  407d72:	d3 e0                	shl    eax,cl
  407d74:	f7 d0                	not    eax
  407d76:	83 e0 fc             	and    eax,0xfffffffc
  407d79:	48 31 c9             	xor    rcx,rcx
  407d7c:	48 31 d2             	xor    rdx,rdx
  407d7f:	0f 01 ef             	wrpkru 
  407d82:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  407d85:	48 c1 e2 04          	shl    rdx,0x4
  407d89:	4c 01 f2             	add    rdx,r14
  407d8c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  407d90:	49 8b 06             	mov    rax,QWORD PTR [r14]
  407d93:	48 83 e8 01          	sub    rax,0x1
  407d97:	49 89 06             	mov    QWORD PTR [r14],rax
  407d9a:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407d9f:	01 c9                	add    ecx,ecx
  407da1:	b8 03 00 00 00       	mov    eax,0x3
  407da6:	d3 e0                	shl    eax,cl
  407da8:	f7 d0                	not    eax
  407daa:	83 e0 fc             	and    eax,0xfffffffc
  407dad:	48 31 c9             	xor    rcx,rcx
  407db0:	48 31 d2             	xor    rdx,rdx
  407db3:	0f 01 ef             	wrpkru 
  407db6:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407dbd:	be ad de 
  407dc0:	49 39 c7             	cmp    r15,rax
  407dc3:	4c 89 c0             	mov    rax,r8
  407dc6:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  407dca:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  407dcd:	41 5f                	pop    r15
  407dcf:	41 5e                	pop    r14
  407dd1:	41 5d                	pop    r13
  407dd3:	41 5c                	pop    r12
  407dd5:	5b                   	pop    rbx
  407dd6:	5d                   	pop    rbp
  407dd7:	c3                   	ret    
  407dd8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  407ddf:	00 

0000000000407de0 <__cosrt_extern_capmgr_rcv_create>:
  407de0:	48 b8 78 c1 5b 00 00 	movabs rax,0x5bc178
  407de7:	00 00 00 
  407dea:	ff 10                	call   QWORD PTR [rax]
  407dec:	c3                   	ret    
  407ded:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000407df0 <__cosrt_fast_callgate_capmgr_rcv_create>:
  407df0:	55                   	push   rbp
  407df1:	53                   	push   rbx
  407df2:	41 54                	push   r12
  407df4:	41 55                	push   r13
  407df6:	41 56                	push   r14
  407df8:	41 57                	push   r15
  407dfa:	4d 89 c4             	mov    r12,r8
  407dfd:	4c 89 cb             	mov    rbx,r9
  407e00:	49 89 c8             	mov    r8,rcx
  407e03:	49 89 d1             	mov    r9,rdx
  407e06:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  407e0d:	be ad de 
  407e10:	0f 01 f9             	rdtscp 
  407e13:	48 89 ca             	mov    rdx,rcx
  407e16:	48 25 ff 0f 00 00    	and    rax,0xfff
  407e1c:	48 89 e2             	mov    rdx,rsp
  407e1f:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  407e26:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  407e2d:	00 
  407e2e:	48 c1 e0 10          	shl    rax,0x10
  407e32:	49 09 c5             	or     r13,rax
  407e35:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  407e3c:	7f 00 00 
  407e3f:	4c 89 e8             	mov    rax,r13
  407e42:	48 25 ff ff 00 00    	and    rax,0xffff
  407e48:	48 c1 e0 08          	shl    rax,0x8
  407e4c:	49 01 c6             	add    r14,rax
  407e4f:	b9 01 00 00 00       	mov    ecx,0x1
  407e54:	01 c9                	add    ecx,ecx
  407e56:	b8 03 00 00 00       	mov    eax,0x3
  407e5b:	d3 e0                	shl    eax,cl
  407e5d:	f7 d0                	not    eax
  407e5f:	83 e0 fc             	and    eax,0xfffffffc
  407e62:	48 31 c9             	xor    rcx,rcx
  407e65:	48 31 d2             	xor    rdx,rdx
  407e68:	0f 01 ef             	wrpkru 
  407e6b:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  407e6e:	48 83 c2 01          	add    rdx,0x1
  407e72:	48 c1 e2 04          	shl    rdx,0x4
  407e76:	4c 01 f2             	add    rdx,r14
  407e79:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  407e80:	45 23 01 
  407e83:	48 89 02             	mov    QWORD PTR [rdx],rax
  407e86:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  407e8a:	49 8b 06             	mov    rax,QWORD PTR [r14]
  407e8d:	48 83 c0 01          	add    rax,0x1
  407e91:	49 89 06             	mov    QWORD PTR [r14],rax
  407e94:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407e99:	01 c9                	add    ecx,ecx
  407e9b:	b8 03 00 00 00       	mov    eax,0x3
  407ea0:	d3 e0                	shl    eax,cl
  407ea2:	f7 d0                	not    eax
  407ea4:	83 e0 fc             	and    eax,0xfffffffc
  407ea7:	48 31 c9             	xor    rcx,rcx
  407eaa:	48 31 d2             	xor    rdx,rdx
  407ead:	0f 01 ef             	wrpkru 
  407eb0:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  407eb7:	45 23 01 
  407eba:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407ec1:	be ad de 
  407ec4:	49 39 c7             	cmp    r15,rax
  407ec7:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  407ece:	12 12 12 
  407ed1:	48 b9 dd 7e 40 00 00 	movabs rcx,0x407edd
  407ed8:	00 00 00 
  407edb:	ff e0                	jmp    rax

0000000000407edd <srv_call_ret_capmgr_rcv_create>:
  407edd:	49 89 c0             	mov    r8,rax
  407ee0:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  407ee7:	be ad de 
  407eea:	48 89 e2             	mov    rdx,rsp
  407eed:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  407ef4:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  407efb:	00 
  407efc:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  407f03:	7f 00 00 
  407f06:	4c 89 e8             	mov    rax,r13
  407f09:	48 25 ff ff 00 00    	and    rax,0xffff
  407f0f:	48 c1 e0 08          	shl    rax,0x8
  407f13:	49 01 c6             	add    r14,rax
  407f16:	b9 01 00 00 00       	mov    ecx,0x1
  407f1b:	01 c9                	add    ecx,ecx
  407f1d:	b8 03 00 00 00       	mov    eax,0x3
  407f22:	d3 e0                	shl    eax,cl
  407f24:	f7 d0                	not    eax
  407f26:	83 e0 fc             	and    eax,0xfffffffc
  407f29:	48 31 c9             	xor    rcx,rcx
  407f2c:	48 31 d2             	xor    rdx,rdx
  407f2f:	0f 01 ef             	wrpkru 
  407f32:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  407f35:	48 c1 e2 04          	shl    rdx,0x4
  407f39:	4c 01 f2             	add    rdx,r14
  407f3c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  407f40:	49 8b 06             	mov    rax,QWORD PTR [r14]
  407f43:	48 83 e8 01          	sub    rax,0x1
  407f47:	49 89 06             	mov    QWORD PTR [r14],rax
  407f4a:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  407f4f:	01 c9                	add    ecx,ecx
  407f51:	b8 03 00 00 00       	mov    eax,0x3
  407f56:	d3 e0                	shl    eax,cl
  407f58:	f7 d0                	not    eax
  407f5a:	83 e0 fc             	and    eax,0xfffffffc
  407f5d:	48 31 c9             	xor    rcx,rcx
  407f60:	48 31 d2             	xor    rdx,rdx
  407f63:	0f 01 ef             	wrpkru 
  407f66:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  407f6d:	be ad de 
  407f70:	49 39 c7             	cmp    r15,rax
  407f73:	4c 89 c0             	mov    rax,r8
  407f76:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  407f7a:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  407f7d:	41 5f                	pop    r15
  407f7f:	41 5e                	pop    r14
  407f81:	41 5d                	pop    r13
  407f83:	41 5c                	pop    r12
  407f85:	5b                   	pop    rbx
  407f86:	5d                   	pop    rbp
  407f87:	c3                   	ret    
  407f88:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  407f8f:	00 

0000000000407f90 <__cosrt_extern_capmgr_set_tls>:
  407f90:	48 b8 90 c1 5b 00 00 	movabs rax,0x5bc190
  407f97:	00 00 00 
  407f9a:	ff 10                	call   QWORD PTR [rax]
  407f9c:	c3                   	ret    
  407f9d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000407fa0 <__cosrt_fast_callgate_capmgr_set_tls>:
  407fa0:	55                   	push   rbp
  407fa1:	41 55                	push   r13
  407fa3:	41 56                	push   r14
  407fa5:	41 57                	push   r15
  407fa7:	49 89 c8             	mov    r8,rcx
  407faa:	49 89 d1             	mov    r9,rdx
  407fad:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  407fb4:	be ad de 
  407fb7:	0f 01 f9             	rdtscp 
  407fba:	48 89 c8             	mov    rax,rcx
  407fbd:	48 25 ff 0f 00 00    	and    rax,0xfff
  407fc3:	48 89 e2             	mov    rdx,rsp
  407fc6:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  407fcd:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  407fd4:	00 
  407fd5:	48 c1 e0 10          	shl    rax,0x10
  407fd9:	49 09 c5             	or     r13,rax
  407fdc:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  407fe3:	7f 00 00 
  407fe6:	4c 89 e8             	mov    rax,r13
  407fe9:	48 25 ff ff 00 00    	and    rax,0xffff
  407fef:	48 c1 e0 08          	shl    rax,0x8
  407ff3:	49 01 c6             	add    r14,rax
  407ff6:	b9 01 00 00 00       	mov    ecx,0x1
  407ffb:	01 c9                	add    ecx,ecx
  407ffd:	b8 03 00 00 00       	mov    eax,0x3
  408002:	d3 e0                	shl    eax,cl
  408004:	f7 d0                	not    eax
  408006:	83 e0 fc             	and    eax,0xfffffffc
  408009:	48 31 c9             	xor    rcx,rcx
  40800c:	48 31 d2             	xor    rdx,rdx
  40800f:	0f 01 ef             	wrpkru 
  408012:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  408015:	48 83 c2 01          	add    rdx,0x1
  408019:	48 c1 e2 04          	shl    rdx,0x4
  40801d:	4c 01 f2             	add    rdx,r14
  408020:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  408027:	45 23 01 
  40802a:	48 89 02             	mov    QWORD PTR [rdx],rax
  40802d:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  408031:	49 8b 06             	mov    rax,QWORD PTR [r14]
  408034:	48 83 c0 01          	add    rax,0x1
  408038:	49 89 06             	mov    QWORD PTR [r14],rax
  40803b:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  408040:	01 c9                	add    ecx,ecx
  408042:	b8 03 00 00 00       	mov    eax,0x3
  408047:	d3 e0                	shl    eax,cl
  408049:	f7 d0                	not    eax
  40804b:	83 e0 fc             	and    eax,0xfffffffc
  40804e:	48 31 c9             	xor    rcx,rcx
  408051:	48 31 d2             	xor    rdx,rdx
  408054:	0f 01 ef             	wrpkru 
  408057:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  40805e:	45 23 01 
  408061:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408068:	be ad de 
  40806b:	49 39 c7             	cmp    r15,rax
  40806e:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  408075:	12 12 12 
  408078:	48 b9 84 80 40 00 00 	movabs rcx,0x408084
  40807f:	00 00 00 
  408082:	ff e0                	jmp    rax

0000000000408084 <srv_call_ret_capmgr_set_tls>:
  408084:	49 89 c0             	mov    r8,rax
  408087:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40808e:	be ad de 
  408091:	48 89 e2             	mov    rdx,rsp
  408094:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40809b:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4080a2:	00 
  4080a3:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4080aa:	7f 00 00 
  4080ad:	4c 89 e8             	mov    rax,r13
  4080b0:	48 25 ff ff 00 00    	and    rax,0xffff
  4080b6:	48 c1 e0 08          	shl    rax,0x8
  4080ba:	49 01 c6             	add    r14,rax
  4080bd:	b9 01 00 00 00       	mov    ecx,0x1
  4080c2:	01 c9                	add    ecx,ecx
  4080c4:	b8 03 00 00 00       	mov    eax,0x3
  4080c9:	d3 e0                	shl    eax,cl
  4080cb:	f7 d0                	not    eax
  4080cd:	83 e0 fc             	and    eax,0xfffffffc
  4080d0:	48 31 c9             	xor    rcx,rcx
  4080d3:	48 31 d2             	xor    rdx,rdx
  4080d6:	0f 01 ef             	wrpkru 
  4080d9:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4080dc:	48 c1 e2 04          	shl    rdx,0x4
  4080e0:	4c 01 f2             	add    rdx,r14
  4080e3:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  4080e7:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4080ea:	48 83 e8 01          	sub    rax,0x1
  4080ee:	49 89 06             	mov    QWORD PTR [r14],rax
  4080f1:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4080f6:	01 c9                	add    ecx,ecx
  4080f8:	b8 03 00 00 00       	mov    eax,0x3
  4080fd:	d3 e0                	shl    eax,cl
  4080ff:	f7 d0                	not    eax
  408101:	83 e0 fc             	and    eax,0xfffffffc
  408104:	48 31 c9             	xor    rcx,rcx
  408107:	48 31 d2             	xor    rdx,rdx
  40810a:	0f 01 ef             	wrpkru 
  40810d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408114:	be ad de 
  408117:	49 39 c7             	cmp    r15,rax
  40811a:	4c 89 c0             	mov    rax,r8
  40811d:	41 5f                	pop    r15
  40811f:	41 5e                	pop    r14
  408121:	41 5d                	pop    r13
  408123:	5d                   	pop    rbp
  408124:	c3                   	ret    
  408125:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40812c:	00 00 00 00 

0000000000408130 <__cosrt_extern_capmgr_asnd_create>:
  408130:	48 b8 a8 c1 5b 00 00 	movabs rax,0x5bc1a8
  408137:	00 00 00 
  40813a:	ff 10                	call   QWORD PTR [rax]
  40813c:	c3                   	ret    
  40813d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000408140 <__cosrt_fast_callgate_capmgr_asnd_create>:
  408140:	55                   	push   rbp
  408141:	41 55                	push   r13
  408143:	41 56                	push   r14
  408145:	41 57                	push   r15
  408147:	49 89 c8             	mov    r8,rcx
  40814a:	49 89 d1             	mov    r9,rdx
  40814d:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  408154:	be ad de 
  408157:	0f 01 f9             	rdtscp 
  40815a:	48 89 c8             	mov    rax,rcx
  40815d:	48 25 ff 0f 00 00    	and    rax,0xfff
  408163:	48 89 e2             	mov    rdx,rsp
  408166:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40816d:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  408174:	00 
  408175:	48 c1 e0 10          	shl    rax,0x10
  408179:	49 09 c5             	or     r13,rax
  40817c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  408183:	7f 00 00 
  408186:	4c 89 e8             	mov    rax,r13
  408189:	48 25 ff ff 00 00    	and    rax,0xffff
  40818f:	48 c1 e0 08          	shl    rax,0x8
  408193:	49 01 c6             	add    r14,rax
  408196:	b9 01 00 00 00       	mov    ecx,0x1
  40819b:	01 c9                	add    ecx,ecx
  40819d:	b8 03 00 00 00       	mov    eax,0x3
  4081a2:	d3 e0                	shl    eax,cl
  4081a4:	f7 d0                	not    eax
  4081a6:	83 e0 fc             	and    eax,0xfffffffc
  4081a9:	48 31 c9             	xor    rcx,rcx
  4081ac:	48 31 d2             	xor    rdx,rdx
  4081af:	0f 01 ef             	wrpkru 
  4081b2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4081b5:	48 83 c2 01          	add    rdx,0x1
  4081b9:	48 c1 e2 04          	shl    rdx,0x4
  4081bd:	4c 01 f2             	add    rdx,r14
  4081c0:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  4081c7:	45 23 01 
  4081ca:	48 89 02             	mov    QWORD PTR [rdx],rax
  4081cd:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  4081d1:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4081d4:	48 83 c0 01          	add    rax,0x1
  4081d8:	49 89 06             	mov    QWORD PTR [r14],rax
  4081db:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4081e0:	01 c9                	add    ecx,ecx
  4081e2:	b8 03 00 00 00       	mov    eax,0x3
  4081e7:	d3 e0                	shl    eax,cl
  4081e9:	f7 d0                	not    eax
  4081eb:	83 e0 fc             	and    eax,0xfffffffc
  4081ee:	48 31 c9             	xor    rcx,rcx
  4081f1:	48 31 d2             	xor    rdx,rdx
  4081f4:	0f 01 ef             	wrpkru 
  4081f7:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  4081fe:	45 23 01 
  408201:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408208:	be ad de 
  40820b:	49 39 c7             	cmp    r15,rax
  40820e:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  408215:	12 12 12 
  408218:	48 b9 24 82 40 00 00 	movabs rcx,0x408224
  40821f:	00 00 00 
  408222:	ff e0                	jmp    rax

0000000000408224 <srv_call_ret_capmgr_asnd_create>:
  408224:	49 89 c0             	mov    r8,rax
  408227:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40822e:	be ad de 
  408231:	48 89 e2             	mov    rdx,rsp
  408234:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40823b:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  408242:	00 
  408243:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40824a:	7f 00 00 
  40824d:	4c 89 e8             	mov    rax,r13
  408250:	48 25 ff ff 00 00    	and    rax,0xffff
  408256:	48 c1 e0 08          	shl    rax,0x8
  40825a:	49 01 c6             	add    r14,rax
  40825d:	b9 01 00 00 00       	mov    ecx,0x1
  408262:	01 c9                	add    ecx,ecx
  408264:	b8 03 00 00 00       	mov    eax,0x3
  408269:	d3 e0                	shl    eax,cl
  40826b:	f7 d0                	not    eax
  40826d:	83 e0 fc             	and    eax,0xfffffffc
  408270:	48 31 c9             	xor    rcx,rcx
  408273:	48 31 d2             	xor    rdx,rdx
  408276:	0f 01 ef             	wrpkru 
  408279:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40827c:	48 c1 e2 04          	shl    rdx,0x4
  408280:	4c 01 f2             	add    rdx,r14
  408283:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  408287:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40828a:	48 83 e8 01          	sub    rax,0x1
  40828e:	49 89 06             	mov    QWORD PTR [r14],rax
  408291:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  408296:	01 c9                	add    ecx,ecx
  408298:	b8 03 00 00 00       	mov    eax,0x3
  40829d:	d3 e0                	shl    eax,cl
  40829f:	f7 d0                	not    eax
  4082a1:	83 e0 fc             	and    eax,0xfffffffc
  4082a4:	48 31 c9             	xor    rcx,rcx
  4082a7:	48 31 d2             	xor    rdx,rdx
  4082aa:	0f 01 ef             	wrpkru 
  4082ad:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4082b4:	be ad de 
  4082b7:	49 39 c7             	cmp    r15,rax
  4082ba:	4c 89 c0             	mov    rax,r8
  4082bd:	41 5f                	pop    r15
  4082bf:	41 5e                	pop    r14
  4082c1:	41 5d                	pop    r13
  4082c3:	5d                   	pop    rbp
  4082c4:	c3                   	ret    
  4082c5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4082cc:	00 00 00 00 

00000000004082d0 <__cosrt_extern_capmgr_asnd_rcv_create>:
  4082d0:	48 b8 c0 c1 5b 00 00 	movabs rax,0x5bc1c0
  4082d7:	00 00 00 
  4082da:	ff 10                	call   QWORD PTR [rax]
  4082dc:	c3                   	ret    
  4082dd:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004082e0 <__cosrt_fast_callgate_capmgr_asnd_rcv_create>:
  4082e0:	55                   	push   rbp
  4082e1:	41 55                	push   r13
  4082e3:	41 56                	push   r14
  4082e5:	41 57                	push   r15
  4082e7:	49 89 c8             	mov    r8,rcx
  4082ea:	49 89 d1             	mov    r9,rdx
  4082ed:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4082f4:	be ad de 
  4082f7:	0f 01 f9             	rdtscp 
  4082fa:	48 89 c8             	mov    rax,rcx
  4082fd:	48 25 ff 0f 00 00    	and    rax,0xfff
  408303:	48 89 e2             	mov    rdx,rsp
  408306:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40830d:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  408314:	00 
  408315:	48 c1 e0 10          	shl    rax,0x10
  408319:	49 09 c5             	or     r13,rax
  40831c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  408323:	7f 00 00 
  408326:	4c 89 e8             	mov    rax,r13
  408329:	48 25 ff ff 00 00    	and    rax,0xffff
  40832f:	48 c1 e0 08          	shl    rax,0x8
  408333:	49 01 c6             	add    r14,rax
  408336:	b9 01 00 00 00       	mov    ecx,0x1
  40833b:	01 c9                	add    ecx,ecx
  40833d:	b8 03 00 00 00       	mov    eax,0x3
  408342:	d3 e0                	shl    eax,cl
  408344:	f7 d0                	not    eax
  408346:	83 e0 fc             	and    eax,0xfffffffc
  408349:	48 31 c9             	xor    rcx,rcx
  40834c:	48 31 d2             	xor    rdx,rdx
  40834f:	0f 01 ef             	wrpkru 
  408352:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  408355:	48 83 c2 01          	add    rdx,0x1
  408359:	48 c1 e2 04          	shl    rdx,0x4
  40835d:	4c 01 f2             	add    rdx,r14
  408360:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  408367:	45 23 01 
  40836a:	48 89 02             	mov    QWORD PTR [rdx],rax
  40836d:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  408371:	49 8b 06             	mov    rax,QWORD PTR [r14]
  408374:	48 83 c0 01          	add    rax,0x1
  408378:	49 89 06             	mov    QWORD PTR [r14],rax
  40837b:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  408380:	01 c9                	add    ecx,ecx
  408382:	b8 03 00 00 00       	mov    eax,0x3
  408387:	d3 e0                	shl    eax,cl
  408389:	f7 d0                	not    eax
  40838b:	83 e0 fc             	and    eax,0xfffffffc
  40838e:	48 31 c9             	xor    rcx,rcx
  408391:	48 31 d2             	xor    rdx,rdx
  408394:	0f 01 ef             	wrpkru 
  408397:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  40839e:	45 23 01 
  4083a1:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4083a8:	be ad de 
  4083ab:	49 39 c7             	cmp    r15,rax
  4083ae:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  4083b5:	12 12 12 
  4083b8:	48 b9 c4 83 40 00 00 	movabs rcx,0x4083c4
  4083bf:	00 00 00 
  4083c2:	ff e0                	jmp    rax

00000000004083c4 <srv_call_ret_capmgr_asnd_rcv_create>:
  4083c4:	49 89 c0             	mov    r8,rax
  4083c7:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4083ce:	be ad de 
  4083d1:	48 89 e2             	mov    rdx,rsp
  4083d4:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4083db:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4083e2:	00 
  4083e3:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4083ea:	7f 00 00 
  4083ed:	4c 89 e8             	mov    rax,r13
  4083f0:	48 25 ff ff 00 00    	and    rax,0xffff
  4083f6:	48 c1 e0 08          	shl    rax,0x8
  4083fa:	49 01 c6             	add    r14,rax
  4083fd:	b9 01 00 00 00       	mov    ecx,0x1
  408402:	01 c9                	add    ecx,ecx
  408404:	b8 03 00 00 00       	mov    eax,0x3
  408409:	d3 e0                	shl    eax,cl
  40840b:	f7 d0                	not    eax
  40840d:	83 e0 fc             	and    eax,0xfffffffc
  408410:	48 31 c9             	xor    rcx,rcx
  408413:	48 31 d2             	xor    rdx,rdx
  408416:	0f 01 ef             	wrpkru 
  408419:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40841c:	48 c1 e2 04          	shl    rdx,0x4
  408420:	4c 01 f2             	add    rdx,r14
  408423:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  408427:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40842a:	48 83 e8 01          	sub    rax,0x1
  40842e:	49 89 06             	mov    QWORD PTR [r14],rax
  408431:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  408436:	01 c9                	add    ecx,ecx
  408438:	b8 03 00 00 00       	mov    eax,0x3
  40843d:	d3 e0                	shl    eax,cl
  40843f:	f7 d0                	not    eax
  408441:	83 e0 fc             	and    eax,0xfffffffc
  408444:	48 31 c9             	xor    rcx,rcx
  408447:	48 31 d2             	xor    rdx,rdx
  40844a:	0f 01 ef             	wrpkru 
  40844d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408454:	be ad de 
  408457:	49 39 c7             	cmp    r15,rax
  40845a:	4c 89 c0             	mov    rax,r8
  40845d:	41 5f                	pop    r15
  40845f:	41 5e                	pop    r14
  408461:	41 5d                	pop    r13
  408463:	5d                   	pop    rbp
  408464:	c3                   	ret    
  408465:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40846c:	00 00 00 00 

0000000000408470 <__cosrt_extern_capmgr_asnd_key_create>:
  408470:	48 b8 d8 c1 5b 00 00 	movabs rax,0x5bc1d8
  408477:	00 00 00 
  40847a:	ff 10                	call   QWORD PTR [rax]
  40847c:	c3                   	ret    
  40847d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000408480 <__cosrt_fast_callgate_capmgr_asnd_key_create>:
  408480:	55                   	push   rbp
  408481:	41 55                	push   r13
  408483:	41 56                	push   r14
  408485:	41 57                	push   r15
  408487:	49 89 c8             	mov    r8,rcx
  40848a:	49 89 d1             	mov    r9,rdx
  40848d:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  408494:	be ad de 
  408497:	0f 01 f9             	rdtscp 
  40849a:	48 89 c8             	mov    rax,rcx
  40849d:	48 25 ff 0f 00 00    	and    rax,0xfff
  4084a3:	48 89 e2             	mov    rdx,rsp
  4084a6:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4084ad:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4084b4:	00 
  4084b5:	48 c1 e0 10          	shl    rax,0x10
  4084b9:	49 09 c5             	or     r13,rax
  4084bc:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4084c3:	7f 00 00 
  4084c6:	4c 89 e8             	mov    rax,r13
  4084c9:	48 25 ff ff 00 00    	and    rax,0xffff
  4084cf:	48 c1 e0 08          	shl    rax,0x8
  4084d3:	49 01 c6             	add    r14,rax
  4084d6:	b9 01 00 00 00       	mov    ecx,0x1
  4084db:	01 c9                	add    ecx,ecx
  4084dd:	b8 03 00 00 00       	mov    eax,0x3
  4084e2:	d3 e0                	shl    eax,cl
  4084e4:	f7 d0                	not    eax
  4084e6:	83 e0 fc             	and    eax,0xfffffffc
  4084e9:	48 31 c9             	xor    rcx,rcx
  4084ec:	48 31 d2             	xor    rdx,rdx
  4084ef:	0f 01 ef             	wrpkru 
  4084f2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4084f5:	48 83 c2 01          	add    rdx,0x1
  4084f9:	48 c1 e2 04          	shl    rdx,0x4
  4084fd:	4c 01 f2             	add    rdx,r14
  408500:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  408507:	45 23 01 
  40850a:	48 89 02             	mov    QWORD PTR [rdx],rax
  40850d:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  408511:	49 8b 06             	mov    rax,QWORD PTR [r14]
  408514:	48 83 c0 01          	add    rax,0x1
  408518:	49 89 06             	mov    QWORD PTR [r14],rax
  40851b:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  408520:	01 c9                	add    ecx,ecx
  408522:	b8 03 00 00 00       	mov    eax,0x3
  408527:	d3 e0                	shl    eax,cl
  408529:	f7 d0                	not    eax
  40852b:	83 e0 fc             	and    eax,0xfffffffc
  40852e:	48 31 c9             	xor    rcx,rcx
  408531:	48 31 d2             	xor    rdx,rdx
  408534:	0f 01 ef             	wrpkru 
  408537:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  40853e:	45 23 01 
  408541:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408548:	be ad de 
  40854b:	49 39 c7             	cmp    r15,rax
  40854e:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  408555:	12 12 12 
  408558:	48 b9 64 85 40 00 00 	movabs rcx,0x408564
  40855f:	00 00 00 
  408562:	ff e0                	jmp    rax

0000000000408564 <srv_call_ret_capmgr_asnd_key_create>:
  408564:	49 89 c0             	mov    r8,rax
  408567:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40856e:	be ad de 
  408571:	48 89 e2             	mov    rdx,rsp
  408574:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40857b:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  408582:	00 
  408583:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40858a:	7f 00 00 
  40858d:	4c 89 e8             	mov    rax,r13
  408590:	48 25 ff ff 00 00    	and    rax,0xffff
  408596:	48 c1 e0 08          	shl    rax,0x8
  40859a:	49 01 c6             	add    r14,rax
  40859d:	b9 01 00 00 00       	mov    ecx,0x1
  4085a2:	01 c9                	add    ecx,ecx
  4085a4:	b8 03 00 00 00       	mov    eax,0x3
  4085a9:	d3 e0                	shl    eax,cl
  4085ab:	f7 d0                	not    eax
  4085ad:	83 e0 fc             	and    eax,0xfffffffc
  4085b0:	48 31 c9             	xor    rcx,rcx
  4085b3:	48 31 d2             	xor    rdx,rdx
  4085b6:	0f 01 ef             	wrpkru 
  4085b9:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4085bc:	48 c1 e2 04          	shl    rdx,0x4
  4085c0:	4c 01 f2             	add    rdx,r14
  4085c3:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  4085c7:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4085ca:	48 83 e8 01          	sub    rax,0x1
  4085ce:	49 89 06             	mov    QWORD PTR [r14],rax
  4085d1:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4085d6:	01 c9                	add    ecx,ecx
  4085d8:	b8 03 00 00 00       	mov    eax,0x3
  4085dd:	d3 e0                	shl    eax,cl
  4085df:	f7 d0                	not    eax
  4085e1:	83 e0 fc             	and    eax,0xfffffffc
  4085e4:	48 31 c9             	xor    rcx,rcx
  4085e7:	48 31 d2             	xor    rdx,rdx
  4085ea:	0f 01 ef             	wrpkru 
  4085ed:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4085f4:	be ad de 
  4085f7:	49 39 c7             	cmp    r15,rax
  4085fa:	4c 89 c0             	mov    rax,r8
  4085fd:	41 5f                	pop    r15
  4085ff:	41 5e                	pop    r14
  408601:	41 5d                	pop    r13
  408603:	5d                   	pop    rbp
  408604:	c3                   	ret    
  408605:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40860c:	00 00 00 00 

0000000000408610 <__cosrt_extern_capmgr_vm_comp_create>:
  408610:	48 b8 f0 c1 5b 00 00 	movabs rax,0x5bc1f0
  408617:	00 00 00 
  40861a:	ff 10                	call   QWORD PTR [rax]
  40861c:	c3                   	ret    
  40861d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000408620 <__cosrt_fast_callgate_capmgr_vm_comp_create>:
  408620:	55                   	push   rbp
  408621:	41 55                	push   r13
  408623:	41 56                	push   r14
  408625:	41 57                	push   r15
  408627:	49 89 c8             	mov    r8,rcx
  40862a:	49 89 d1             	mov    r9,rdx
  40862d:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  408634:	be ad de 
  408637:	0f 01 f9             	rdtscp 
  40863a:	48 89 c8             	mov    rax,rcx
  40863d:	48 25 ff 0f 00 00    	and    rax,0xfff
  408643:	48 89 e2             	mov    rdx,rsp
  408646:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40864d:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  408654:	00 
  408655:	48 c1 e0 10          	shl    rax,0x10
  408659:	49 09 c5             	or     r13,rax
  40865c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  408663:	7f 00 00 
  408666:	4c 89 e8             	mov    rax,r13
  408669:	48 25 ff ff 00 00    	and    rax,0xffff
  40866f:	48 c1 e0 08          	shl    rax,0x8
  408673:	49 01 c6             	add    r14,rax
  408676:	b9 01 00 00 00       	mov    ecx,0x1
  40867b:	01 c9                	add    ecx,ecx
  40867d:	b8 03 00 00 00       	mov    eax,0x3
  408682:	d3 e0                	shl    eax,cl
  408684:	f7 d0                	not    eax
  408686:	83 e0 fc             	and    eax,0xfffffffc
  408689:	48 31 c9             	xor    rcx,rcx
  40868c:	48 31 d2             	xor    rdx,rdx
  40868f:	0f 01 ef             	wrpkru 
  408692:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  408695:	48 83 c2 01          	add    rdx,0x1
  408699:	48 c1 e2 04          	shl    rdx,0x4
  40869d:	4c 01 f2             	add    rdx,r14
  4086a0:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  4086a7:	45 23 01 
  4086aa:	48 89 02             	mov    QWORD PTR [rdx],rax
  4086ad:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  4086b1:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4086b4:	48 83 c0 01          	add    rax,0x1
  4086b8:	49 89 06             	mov    QWORD PTR [r14],rax
  4086bb:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4086c0:	01 c9                	add    ecx,ecx
  4086c2:	b8 03 00 00 00       	mov    eax,0x3
  4086c7:	d3 e0                	shl    eax,cl
  4086c9:	f7 d0                	not    eax
  4086cb:	83 e0 fc             	and    eax,0xfffffffc
  4086ce:	48 31 c9             	xor    rcx,rcx
  4086d1:	48 31 d2             	xor    rdx,rdx
  4086d4:	0f 01 ef             	wrpkru 
  4086d7:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  4086de:	45 23 01 
  4086e1:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4086e8:	be ad de 
  4086eb:	49 39 c7             	cmp    r15,rax
  4086ee:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  4086f5:	12 12 12 
  4086f8:	48 b9 04 87 40 00 00 	movabs rcx,0x408704
  4086ff:	00 00 00 
  408702:	ff e0                	jmp    rax

0000000000408704 <srv_call_ret_capmgr_vm_comp_create>:
  408704:	49 89 c0             	mov    r8,rax
  408707:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40870e:	be ad de 
  408711:	48 89 e2             	mov    rdx,rsp
  408714:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40871b:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  408722:	00 
  408723:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40872a:	7f 00 00 
  40872d:	4c 89 e8             	mov    rax,r13
  408730:	48 25 ff ff 00 00    	and    rax,0xffff
  408736:	48 c1 e0 08          	shl    rax,0x8
  40873a:	49 01 c6             	add    r14,rax
  40873d:	b9 01 00 00 00       	mov    ecx,0x1
  408742:	01 c9                	add    ecx,ecx
  408744:	b8 03 00 00 00       	mov    eax,0x3
  408749:	d3 e0                	shl    eax,cl
  40874b:	f7 d0                	not    eax
  40874d:	83 e0 fc             	and    eax,0xfffffffc
  408750:	48 31 c9             	xor    rcx,rcx
  408753:	48 31 d2             	xor    rdx,rdx
  408756:	0f 01 ef             	wrpkru 
  408759:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40875c:	48 c1 e2 04          	shl    rdx,0x4
  408760:	4c 01 f2             	add    rdx,r14
  408763:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  408767:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40876a:	48 83 e8 01          	sub    rax,0x1
  40876e:	49 89 06             	mov    QWORD PTR [r14],rax
  408771:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  408776:	01 c9                	add    ecx,ecx
  408778:	b8 03 00 00 00       	mov    eax,0x3
  40877d:	d3 e0                	shl    eax,cl
  40877f:	f7 d0                	not    eax
  408781:	83 e0 fc             	and    eax,0xfffffffc
  408784:	48 31 c9             	xor    rcx,rcx
  408787:	48 31 d2             	xor    rdx,rdx
  40878a:	0f 01 ef             	wrpkru 
  40878d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408794:	be ad de 
  408797:	49 39 c7             	cmp    r15,rax
  40879a:	4c 89 c0             	mov    rax,r8
  40879d:	41 5f                	pop    r15
  40879f:	41 5e                	pop    r14
  4087a1:	41 5d                	pop    r13
  4087a3:	5d                   	pop    rbp
  4087a4:	c3                   	ret    
  4087a5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4087ac:	00 00 00 00 

00000000004087b0 <__cosrt_extern_capmgr_vm_shared_kernel_page_create_at>:
  4087b0:	48 b8 08 c2 5b 00 00 	movabs rax,0x5bc208
  4087b7:	00 00 00 
  4087ba:	ff 10                	call   QWORD PTR [rax]
  4087bc:	c3                   	ret    
  4087bd:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004087c0 <__cosrt_fast_callgate_capmgr_vm_shared_kernel_page_create_at>:
  4087c0:	55                   	push   rbp
  4087c1:	41 55                	push   r13
  4087c3:	41 56                	push   r14
  4087c5:	41 57                	push   r15
  4087c7:	49 89 c8             	mov    r8,rcx
  4087ca:	49 89 d1             	mov    r9,rdx
  4087cd:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4087d4:	be ad de 
  4087d7:	0f 01 f9             	rdtscp 
  4087da:	48 89 c8             	mov    rax,rcx
  4087dd:	48 25 ff 0f 00 00    	and    rax,0xfff
  4087e3:	48 89 e2             	mov    rdx,rsp
  4087e6:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4087ed:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4087f4:	00 
  4087f5:	48 c1 e0 10          	shl    rax,0x10
  4087f9:	49 09 c5             	or     r13,rax
  4087fc:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  408803:	7f 00 00 
  408806:	4c 89 e8             	mov    rax,r13
  408809:	48 25 ff ff 00 00    	and    rax,0xffff
  40880f:	48 c1 e0 08          	shl    rax,0x8
  408813:	49 01 c6             	add    r14,rax
  408816:	b9 01 00 00 00       	mov    ecx,0x1
  40881b:	01 c9                	add    ecx,ecx
  40881d:	b8 03 00 00 00       	mov    eax,0x3
  408822:	d3 e0                	shl    eax,cl
  408824:	f7 d0                	not    eax
  408826:	83 e0 fc             	and    eax,0xfffffffc
  408829:	48 31 c9             	xor    rcx,rcx
  40882c:	48 31 d2             	xor    rdx,rdx
  40882f:	0f 01 ef             	wrpkru 
  408832:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  408835:	48 83 c2 01          	add    rdx,0x1
  408839:	48 c1 e2 04          	shl    rdx,0x4
  40883d:	4c 01 f2             	add    rdx,r14
  408840:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  408847:	45 23 01 
  40884a:	48 89 02             	mov    QWORD PTR [rdx],rax
  40884d:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  408851:	49 8b 06             	mov    rax,QWORD PTR [r14]
  408854:	48 83 c0 01          	add    rax,0x1
  408858:	49 89 06             	mov    QWORD PTR [r14],rax
  40885b:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  408860:	01 c9                	add    ecx,ecx
  408862:	b8 03 00 00 00       	mov    eax,0x3
  408867:	d3 e0                	shl    eax,cl
  408869:	f7 d0                	not    eax
  40886b:	83 e0 fc             	and    eax,0xfffffffc
  40886e:	48 31 c9             	xor    rcx,rcx
  408871:	48 31 d2             	xor    rdx,rdx
  408874:	0f 01 ef             	wrpkru 
  408877:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  40887e:	45 23 01 
  408881:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408888:	be ad de 
  40888b:	49 39 c7             	cmp    r15,rax
  40888e:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  408895:	12 12 12 
  408898:	48 b9 a4 88 40 00 00 	movabs rcx,0x4088a4
  40889f:	00 00 00 
  4088a2:	ff e0                	jmp    rax

00000000004088a4 <srv_call_ret_capmgr_vm_shared_kernel_page_create_at>:
  4088a4:	49 89 c0             	mov    r8,rax
  4088a7:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4088ae:	be ad de 
  4088b1:	48 89 e2             	mov    rdx,rsp
  4088b4:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4088bb:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4088c2:	00 
  4088c3:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4088ca:	7f 00 00 
  4088cd:	4c 89 e8             	mov    rax,r13
  4088d0:	48 25 ff ff 00 00    	and    rax,0xffff
  4088d6:	48 c1 e0 08          	shl    rax,0x8
  4088da:	49 01 c6             	add    r14,rax
  4088dd:	b9 01 00 00 00       	mov    ecx,0x1
  4088e2:	01 c9                	add    ecx,ecx
  4088e4:	b8 03 00 00 00       	mov    eax,0x3
  4088e9:	d3 e0                	shl    eax,cl
  4088eb:	f7 d0                	not    eax
  4088ed:	83 e0 fc             	and    eax,0xfffffffc
  4088f0:	48 31 c9             	xor    rcx,rcx
  4088f3:	48 31 d2             	xor    rdx,rdx
  4088f6:	0f 01 ef             	wrpkru 
  4088f9:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4088fc:	48 c1 e2 04          	shl    rdx,0x4
  408900:	4c 01 f2             	add    rdx,r14
  408903:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  408907:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40890a:	48 83 e8 01          	sub    rax,0x1
  40890e:	49 89 06             	mov    QWORD PTR [r14],rax
  408911:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  408916:	01 c9                	add    ecx,ecx
  408918:	b8 03 00 00 00       	mov    eax,0x3
  40891d:	d3 e0                	shl    eax,cl
  40891f:	f7 d0                	not    eax
  408921:	83 e0 fc             	and    eax,0xfffffffc
  408924:	48 31 c9             	xor    rcx,rcx
  408927:	48 31 d2             	xor    rdx,rdx
  40892a:	0f 01 ef             	wrpkru 
  40892d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408934:	be ad de 
  408937:	49 39 c7             	cmp    r15,rax
  40893a:	4c 89 c0             	mov    rax,r8
  40893d:	41 5f                	pop    r15
  40893f:	41 5e                	pop    r14
  408941:	41 5d                	pop    r13
  408943:	5d                   	pop    rbp
  408944:	c3                   	ret    
  408945:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40894c:	00 00 00 00 

0000000000408950 <__cosrt_extern_capmgr_vm_vmcs_create>:
  408950:	48 b8 20 c2 5b 00 00 	movabs rax,0x5bc220
  408957:	00 00 00 
  40895a:	ff 10                	call   QWORD PTR [rax]
  40895c:	c3                   	ret    
  40895d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000408960 <__cosrt_fast_callgate_capmgr_vm_vmcs_create>:
  408960:	55                   	push   rbp
  408961:	41 55                	push   r13
  408963:	41 56                	push   r14
  408965:	41 57                	push   r15
  408967:	49 89 c8             	mov    r8,rcx
  40896a:	49 89 d1             	mov    r9,rdx
  40896d:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  408974:	be ad de 
  408977:	0f 01 f9             	rdtscp 
  40897a:	48 89 c8             	mov    rax,rcx
  40897d:	48 25 ff 0f 00 00    	and    rax,0xfff
  408983:	48 89 e2             	mov    rdx,rsp
  408986:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40898d:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  408994:	00 
  408995:	48 c1 e0 10          	shl    rax,0x10
  408999:	49 09 c5             	or     r13,rax
  40899c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4089a3:	7f 00 00 
  4089a6:	4c 89 e8             	mov    rax,r13
  4089a9:	48 25 ff ff 00 00    	and    rax,0xffff
  4089af:	48 c1 e0 08          	shl    rax,0x8
  4089b3:	49 01 c6             	add    r14,rax
  4089b6:	b9 01 00 00 00       	mov    ecx,0x1
  4089bb:	01 c9                	add    ecx,ecx
  4089bd:	b8 03 00 00 00       	mov    eax,0x3
  4089c2:	d3 e0                	shl    eax,cl
  4089c4:	f7 d0                	not    eax
  4089c6:	83 e0 fc             	and    eax,0xfffffffc
  4089c9:	48 31 c9             	xor    rcx,rcx
  4089cc:	48 31 d2             	xor    rdx,rdx
  4089cf:	0f 01 ef             	wrpkru 
  4089d2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4089d5:	48 83 c2 01          	add    rdx,0x1
  4089d9:	48 c1 e2 04          	shl    rdx,0x4
  4089dd:	4c 01 f2             	add    rdx,r14
  4089e0:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  4089e7:	45 23 01 
  4089ea:	48 89 02             	mov    QWORD PTR [rdx],rax
  4089ed:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  4089f1:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4089f4:	48 83 c0 01          	add    rax,0x1
  4089f8:	49 89 06             	mov    QWORD PTR [r14],rax
  4089fb:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  408a00:	01 c9                	add    ecx,ecx
  408a02:	b8 03 00 00 00       	mov    eax,0x3
  408a07:	d3 e0                	shl    eax,cl
  408a09:	f7 d0                	not    eax
  408a0b:	83 e0 fc             	and    eax,0xfffffffc
  408a0e:	48 31 c9             	xor    rcx,rcx
  408a11:	48 31 d2             	xor    rdx,rdx
  408a14:	0f 01 ef             	wrpkru 
  408a17:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  408a1e:	45 23 01 
  408a21:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408a28:	be ad de 
  408a2b:	49 39 c7             	cmp    r15,rax
  408a2e:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  408a35:	12 12 12 
  408a38:	48 b9 44 8a 40 00 00 	movabs rcx,0x408a44
  408a3f:	00 00 00 
  408a42:	ff e0                	jmp    rax

0000000000408a44 <srv_call_ret_capmgr_vm_vmcs_create>:
  408a44:	49 89 c0             	mov    r8,rax
  408a47:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  408a4e:	be ad de 
  408a51:	48 89 e2             	mov    rdx,rsp
  408a54:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  408a5b:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  408a62:	00 
  408a63:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  408a6a:	7f 00 00 
  408a6d:	4c 89 e8             	mov    rax,r13
  408a70:	48 25 ff ff 00 00    	and    rax,0xffff
  408a76:	48 c1 e0 08          	shl    rax,0x8
  408a7a:	49 01 c6             	add    r14,rax
  408a7d:	b9 01 00 00 00       	mov    ecx,0x1
  408a82:	01 c9                	add    ecx,ecx
  408a84:	b8 03 00 00 00       	mov    eax,0x3
  408a89:	d3 e0                	shl    eax,cl
  408a8b:	f7 d0                	not    eax
  408a8d:	83 e0 fc             	and    eax,0xfffffffc
  408a90:	48 31 c9             	xor    rcx,rcx
  408a93:	48 31 d2             	xor    rdx,rdx
  408a96:	0f 01 ef             	wrpkru 
  408a99:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  408a9c:	48 c1 e2 04          	shl    rdx,0x4
  408aa0:	4c 01 f2             	add    rdx,r14
  408aa3:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  408aa7:	49 8b 06             	mov    rax,QWORD PTR [r14]
  408aaa:	48 83 e8 01          	sub    rax,0x1
  408aae:	49 89 06             	mov    QWORD PTR [r14],rax
  408ab1:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  408ab6:	01 c9                	add    ecx,ecx
  408ab8:	b8 03 00 00 00       	mov    eax,0x3
  408abd:	d3 e0                	shl    eax,cl
  408abf:	f7 d0                	not    eax
  408ac1:	83 e0 fc             	and    eax,0xfffffffc
  408ac4:	48 31 c9             	xor    rcx,rcx
  408ac7:	48 31 d2             	xor    rdx,rdx
  408aca:	0f 01 ef             	wrpkru 
  408acd:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408ad4:	be ad de 
  408ad7:	49 39 c7             	cmp    r15,rax
  408ada:	4c 89 c0             	mov    rax,r8
  408add:	41 5f                	pop    r15
  408adf:	41 5e                	pop    r14
  408ae1:	41 5d                	pop    r13
  408ae3:	5d                   	pop    rbp
  408ae4:	c3                   	ret    
  408ae5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  408aec:	00 00 00 00 

0000000000408af0 <__cosrt_extern_capmgr_vm_msr_bitmap_create>:
  408af0:	48 b8 38 c2 5b 00 00 	movabs rax,0x5bc238
  408af7:	00 00 00 
  408afa:	ff 10                	call   QWORD PTR [rax]
  408afc:	c3                   	ret    
  408afd:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000408b00 <__cosrt_fast_callgate_capmgr_vm_msr_bitmap_create>:
  408b00:	55                   	push   rbp
  408b01:	41 55                	push   r13
  408b03:	41 56                	push   r14
  408b05:	41 57                	push   r15
  408b07:	49 89 c8             	mov    r8,rcx
  408b0a:	49 89 d1             	mov    r9,rdx
  408b0d:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  408b14:	be ad de 
  408b17:	0f 01 f9             	rdtscp 
  408b1a:	48 89 c8             	mov    rax,rcx
  408b1d:	48 25 ff 0f 00 00    	and    rax,0xfff
  408b23:	48 89 e2             	mov    rdx,rsp
  408b26:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  408b2d:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  408b34:	00 
  408b35:	48 c1 e0 10          	shl    rax,0x10
  408b39:	49 09 c5             	or     r13,rax
  408b3c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  408b43:	7f 00 00 
  408b46:	4c 89 e8             	mov    rax,r13
  408b49:	48 25 ff ff 00 00    	and    rax,0xffff
  408b4f:	48 c1 e0 08          	shl    rax,0x8
  408b53:	49 01 c6             	add    r14,rax
  408b56:	b9 01 00 00 00       	mov    ecx,0x1
  408b5b:	01 c9                	add    ecx,ecx
  408b5d:	b8 03 00 00 00       	mov    eax,0x3
  408b62:	d3 e0                	shl    eax,cl
  408b64:	f7 d0                	not    eax
  408b66:	83 e0 fc             	and    eax,0xfffffffc
  408b69:	48 31 c9             	xor    rcx,rcx
  408b6c:	48 31 d2             	xor    rdx,rdx
  408b6f:	0f 01 ef             	wrpkru 
  408b72:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  408b75:	48 83 c2 01          	add    rdx,0x1
  408b79:	48 c1 e2 04          	shl    rdx,0x4
  408b7d:	4c 01 f2             	add    rdx,r14
  408b80:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  408b87:	45 23 01 
  408b8a:	48 89 02             	mov    QWORD PTR [rdx],rax
  408b8d:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  408b91:	49 8b 06             	mov    rax,QWORD PTR [r14]
  408b94:	48 83 c0 01          	add    rax,0x1
  408b98:	49 89 06             	mov    QWORD PTR [r14],rax
  408b9b:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  408ba0:	01 c9                	add    ecx,ecx
  408ba2:	b8 03 00 00 00       	mov    eax,0x3
  408ba7:	d3 e0                	shl    eax,cl
  408ba9:	f7 d0                	not    eax
  408bab:	83 e0 fc             	and    eax,0xfffffffc
  408bae:	48 31 c9             	xor    rcx,rcx
  408bb1:	48 31 d2             	xor    rdx,rdx
  408bb4:	0f 01 ef             	wrpkru 
  408bb7:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  408bbe:	45 23 01 
  408bc1:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408bc8:	be ad de 
  408bcb:	49 39 c7             	cmp    r15,rax
  408bce:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  408bd5:	12 12 12 
  408bd8:	48 b9 e4 8b 40 00 00 	movabs rcx,0x408be4
  408bdf:	00 00 00 
  408be2:	ff e0                	jmp    rax

0000000000408be4 <srv_call_ret_capmgr_vm_msr_bitmap_create>:
  408be4:	49 89 c0             	mov    r8,rax
  408be7:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  408bee:	be ad de 
  408bf1:	48 89 e2             	mov    rdx,rsp
  408bf4:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  408bfb:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  408c02:	00 
  408c03:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  408c0a:	7f 00 00 
  408c0d:	4c 89 e8             	mov    rax,r13
  408c10:	48 25 ff ff 00 00    	and    rax,0xffff
  408c16:	48 c1 e0 08          	shl    rax,0x8
  408c1a:	49 01 c6             	add    r14,rax
  408c1d:	b9 01 00 00 00       	mov    ecx,0x1
  408c22:	01 c9                	add    ecx,ecx
  408c24:	b8 03 00 00 00       	mov    eax,0x3
  408c29:	d3 e0                	shl    eax,cl
  408c2b:	f7 d0                	not    eax
  408c2d:	83 e0 fc             	and    eax,0xfffffffc
  408c30:	48 31 c9             	xor    rcx,rcx
  408c33:	48 31 d2             	xor    rdx,rdx
  408c36:	0f 01 ef             	wrpkru 
  408c39:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  408c3c:	48 c1 e2 04          	shl    rdx,0x4
  408c40:	4c 01 f2             	add    rdx,r14
  408c43:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  408c47:	49 8b 06             	mov    rax,QWORD PTR [r14]
  408c4a:	48 83 e8 01          	sub    rax,0x1
  408c4e:	49 89 06             	mov    QWORD PTR [r14],rax
  408c51:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  408c56:	01 c9                	add    ecx,ecx
  408c58:	b8 03 00 00 00       	mov    eax,0x3
  408c5d:	d3 e0                	shl    eax,cl
  408c5f:	f7 d0                	not    eax
  408c61:	83 e0 fc             	and    eax,0xfffffffc
  408c64:	48 31 c9             	xor    rcx,rcx
  408c67:	48 31 d2             	xor    rdx,rdx
  408c6a:	0f 01 ef             	wrpkru 
  408c6d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408c74:	be ad de 
  408c77:	49 39 c7             	cmp    r15,rax
  408c7a:	4c 89 c0             	mov    rax,r8
  408c7d:	41 5f                	pop    r15
  408c7f:	41 5e                	pop    r14
  408c81:	41 5d                	pop    r13
  408c83:	5d                   	pop    rbp
  408c84:	c3                   	ret    
  408c85:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  408c8c:	00 00 00 00 

0000000000408c90 <__cosrt_extern_capmgr_vm_lapic_access_create>:
  408c90:	48 b8 50 c2 5b 00 00 	movabs rax,0x5bc250
  408c97:	00 00 00 
  408c9a:	ff 10                	call   QWORD PTR [rax]
  408c9c:	c3                   	ret    
  408c9d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000408ca0 <__cosrt_fast_callgate_capmgr_vm_lapic_access_create>:
  408ca0:	55                   	push   rbp
  408ca1:	41 55                	push   r13
  408ca3:	41 56                	push   r14
  408ca5:	41 57                	push   r15
  408ca7:	49 89 c8             	mov    r8,rcx
  408caa:	49 89 d1             	mov    r9,rdx
  408cad:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  408cb4:	be ad de 
  408cb7:	0f 01 f9             	rdtscp 
  408cba:	48 89 c8             	mov    rax,rcx
  408cbd:	48 25 ff 0f 00 00    	and    rax,0xfff
  408cc3:	48 89 e2             	mov    rdx,rsp
  408cc6:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  408ccd:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  408cd4:	00 
  408cd5:	48 c1 e0 10          	shl    rax,0x10
  408cd9:	49 09 c5             	or     r13,rax
  408cdc:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  408ce3:	7f 00 00 
  408ce6:	4c 89 e8             	mov    rax,r13
  408ce9:	48 25 ff ff 00 00    	and    rax,0xffff
  408cef:	48 c1 e0 08          	shl    rax,0x8
  408cf3:	49 01 c6             	add    r14,rax
  408cf6:	b9 01 00 00 00       	mov    ecx,0x1
  408cfb:	01 c9                	add    ecx,ecx
  408cfd:	b8 03 00 00 00       	mov    eax,0x3
  408d02:	d3 e0                	shl    eax,cl
  408d04:	f7 d0                	not    eax
  408d06:	83 e0 fc             	and    eax,0xfffffffc
  408d09:	48 31 c9             	xor    rcx,rcx
  408d0c:	48 31 d2             	xor    rdx,rdx
  408d0f:	0f 01 ef             	wrpkru 
  408d12:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  408d15:	48 83 c2 01          	add    rdx,0x1
  408d19:	48 c1 e2 04          	shl    rdx,0x4
  408d1d:	4c 01 f2             	add    rdx,r14
  408d20:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  408d27:	45 23 01 
  408d2a:	48 89 02             	mov    QWORD PTR [rdx],rax
  408d2d:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  408d31:	49 8b 06             	mov    rax,QWORD PTR [r14]
  408d34:	48 83 c0 01          	add    rax,0x1
  408d38:	49 89 06             	mov    QWORD PTR [r14],rax
  408d3b:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  408d40:	01 c9                	add    ecx,ecx
  408d42:	b8 03 00 00 00       	mov    eax,0x3
  408d47:	d3 e0                	shl    eax,cl
  408d49:	f7 d0                	not    eax
  408d4b:	83 e0 fc             	and    eax,0xfffffffc
  408d4e:	48 31 c9             	xor    rcx,rcx
  408d51:	48 31 d2             	xor    rdx,rdx
  408d54:	0f 01 ef             	wrpkru 
  408d57:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  408d5e:	45 23 01 
  408d61:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408d68:	be ad de 
  408d6b:	49 39 c7             	cmp    r15,rax
  408d6e:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  408d75:	12 12 12 
  408d78:	48 b9 84 8d 40 00 00 	movabs rcx,0x408d84
  408d7f:	00 00 00 
  408d82:	ff e0                	jmp    rax

0000000000408d84 <srv_call_ret_capmgr_vm_lapic_access_create>:
  408d84:	49 89 c0             	mov    r8,rax
  408d87:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  408d8e:	be ad de 
  408d91:	48 89 e2             	mov    rdx,rsp
  408d94:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  408d9b:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  408da2:	00 
  408da3:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  408daa:	7f 00 00 
  408dad:	4c 89 e8             	mov    rax,r13
  408db0:	48 25 ff ff 00 00    	and    rax,0xffff
  408db6:	48 c1 e0 08          	shl    rax,0x8
  408dba:	49 01 c6             	add    r14,rax
  408dbd:	b9 01 00 00 00       	mov    ecx,0x1
  408dc2:	01 c9                	add    ecx,ecx
  408dc4:	b8 03 00 00 00       	mov    eax,0x3
  408dc9:	d3 e0                	shl    eax,cl
  408dcb:	f7 d0                	not    eax
  408dcd:	83 e0 fc             	and    eax,0xfffffffc
  408dd0:	48 31 c9             	xor    rcx,rcx
  408dd3:	48 31 d2             	xor    rdx,rdx
  408dd6:	0f 01 ef             	wrpkru 
  408dd9:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  408ddc:	48 c1 e2 04          	shl    rdx,0x4
  408de0:	4c 01 f2             	add    rdx,r14
  408de3:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  408de7:	49 8b 06             	mov    rax,QWORD PTR [r14]
  408dea:	48 83 e8 01          	sub    rax,0x1
  408dee:	49 89 06             	mov    QWORD PTR [r14],rax
  408df1:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  408df6:	01 c9                	add    ecx,ecx
  408df8:	b8 03 00 00 00       	mov    eax,0x3
  408dfd:	d3 e0                	shl    eax,cl
  408dff:	f7 d0                	not    eax
  408e01:	83 e0 fc             	and    eax,0xfffffffc
  408e04:	48 31 c9             	xor    rcx,rcx
  408e07:	48 31 d2             	xor    rdx,rdx
  408e0a:	0f 01 ef             	wrpkru 
  408e0d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408e14:	be ad de 
  408e17:	49 39 c7             	cmp    r15,rax
  408e1a:	4c 89 c0             	mov    rax,r8
  408e1d:	41 5f                	pop    r15
  408e1f:	41 5e                	pop    r14
  408e21:	41 5d                	pop    r13
  408e23:	5d                   	pop    rbp
  408e24:	c3                   	ret    
  408e25:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  408e2c:	00 00 00 00 

0000000000408e30 <__cosrt_extern_capmgr_shared_kernel_page_create>:
  408e30:	48 b8 68 c2 5b 00 00 	movabs rax,0x5bc268
  408e37:	00 00 00 
  408e3a:	ff 10                	call   QWORD PTR [rax]
  408e3c:	c3                   	ret    
  408e3d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000408e40 <__cosrt_fast_callgate_capmgr_shared_kernel_page_create>:
  408e40:	55                   	push   rbp
  408e41:	53                   	push   rbx
  408e42:	41 54                	push   r12
  408e44:	41 55                	push   r13
  408e46:	41 56                	push   r14
  408e48:	41 57                	push   r15
  408e4a:	4d 89 c4             	mov    r12,r8
  408e4d:	4c 89 cb             	mov    rbx,r9
  408e50:	49 89 c8             	mov    r8,rcx
  408e53:	49 89 d1             	mov    r9,rdx
  408e56:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  408e5d:	be ad de 
  408e60:	0f 01 f9             	rdtscp 
  408e63:	48 89 ca             	mov    rdx,rcx
  408e66:	48 25 ff 0f 00 00    	and    rax,0xfff
  408e6c:	48 89 e2             	mov    rdx,rsp
  408e6f:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  408e76:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  408e7d:	00 
  408e7e:	48 c1 e0 10          	shl    rax,0x10
  408e82:	49 09 c5             	or     r13,rax
  408e85:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  408e8c:	7f 00 00 
  408e8f:	4c 89 e8             	mov    rax,r13
  408e92:	48 25 ff ff 00 00    	and    rax,0xffff
  408e98:	48 c1 e0 08          	shl    rax,0x8
  408e9c:	49 01 c6             	add    r14,rax
  408e9f:	b9 01 00 00 00       	mov    ecx,0x1
  408ea4:	01 c9                	add    ecx,ecx
  408ea6:	b8 03 00 00 00       	mov    eax,0x3
  408eab:	d3 e0                	shl    eax,cl
  408ead:	f7 d0                	not    eax
  408eaf:	83 e0 fc             	and    eax,0xfffffffc
  408eb2:	48 31 c9             	xor    rcx,rcx
  408eb5:	48 31 d2             	xor    rdx,rdx
  408eb8:	0f 01 ef             	wrpkru 
  408ebb:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  408ebe:	48 83 c2 01          	add    rdx,0x1
  408ec2:	48 c1 e2 04          	shl    rdx,0x4
  408ec6:	4c 01 f2             	add    rdx,r14
  408ec9:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  408ed0:	45 23 01 
  408ed3:	48 89 02             	mov    QWORD PTR [rdx],rax
  408ed6:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  408eda:	49 8b 06             	mov    rax,QWORD PTR [r14]
  408edd:	48 83 c0 01          	add    rax,0x1
  408ee1:	49 89 06             	mov    QWORD PTR [r14],rax
  408ee4:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  408ee9:	01 c9                	add    ecx,ecx
  408eeb:	b8 03 00 00 00       	mov    eax,0x3
  408ef0:	d3 e0                	shl    eax,cl
  408ef2:	f7 d0                	not    eax
  408ef4:	83 e0 fc             	and    eax,0xfffffffc
  408ef7:	48 31 c9             	xor    rcx,rcx
  408efa:	48 31 d2             	xor    rdx,rdx
  408efd:	0f 01 ef             	wrpkru 
  408f00:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  408f07:	45 23 01 
  408f0a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408f11:	be ad de 
  408f14:	49 39 c7             	cmp    r15,rax
  408f17:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  408f1e:	12 12 12 
  408f21:	48 b9 2d 8f 40 00 00 	movabs rcx,0x408f2d
  408f28:	00 00 00 
  408f2b:	ff e0                	jmp    rax

0000000000408f2d <srv_call_ret_capmgr_shared_kernel_page_create>:
  408f2d:	49 89 c0             	mov    r8,rax
  408f30:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  408f37:	be ad de 
  408f3a:	48 89 e2             	mov    rdx,rsp
  408f3d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  408f44:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  408f4b:	00 
  408f4c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  408f53:	7f 00 00 
  408f56:	4c 89 e8             	mov    rax,r13
  408f59:	48 25 ff ff 00 00    	and    rax,0xffff
  408f5f:	48 c1 e0 08          	shl    rax,0x8
  408f63:	49 01 c6             	add    r14,rax
  408f66:	b9 01 00 00 00       	mov    ecx,0x1
  408f6b:	01 c9                	add    ecx,ecx
  408f6d:	b8 03 00 00 00       	mov    eax,0x3
  408f72:	d3 e0                	shl    eax,cl
  408f74:	f7 d0                	not    eax
  408f76:	83 e0 fc             	and    eax,0xfffffffc
  408f79:	48 31 c9             	xor    rcx,rcx
  408f7c:	48 31 d2             	xor    rdx,rdx
  408f7f:	0f 01 ef             	wrpkru 
  408f82:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  408f85:	48 c1 e2 04          	shl    rdx,0x4
  408f89:	4c 01 f2             	add    rdx,r14
  408f8c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  408f90:	49 8b 06             	mov    rax,QWORD PTR [r14]
  408f93:	48 83 e8 01          	sub    rax,0x1
  408f97:	49 89 06             	mov    QWORD PTR [r14],rax
  408f9a:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  408f9f:	01 c9                	add    ecx,ecx
  408fa1:	b8 03 00 00 00       	mov    eax,0x3
  408fa6:	d3 e0                	shl    eax,cl
  408fa8:	f7 d0                	not    eax
  408faa:	83 e0 fc             	and    eax,0xfffffffc
  408fad:	48 31 c9             	xor    rcx,rcx
  408fb0:	48 31 d2             	xor    rdx,rdx
  408fb3:	0f 01 ef             	wrpkru 
  408fb6:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  408fbd:	be ad de 
  408fc0:	49 39 c7             	cmp    r15,rax
  408fc3:	4c 89 c0             	mov    rax,r8
  408fc6:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  408fca:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  408fcd:	41 5f                	pop    r15
  408fcf:	41 5e                	pop    r14
  408fd1:	41 5d                	pop    r13
  408fd3:	41 5c                	pop    r12
  408fd5:	5b                   	pop    rbx
  408fd6:	5d                   	pop    rbp
  408fd7:	c3                   	ret    
  408fd8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  408fdf:	00 

0000000000408fe0 <__cosrt_extern_capmgr_vm_lapic_create>:
  408fe0:	48 b8 80 c2 5b 00 00 	movabs rax,0x5bc280
  408fe7:	00 00 00 
  408fea:	ff 10                	call   QWORD PTR [rax]
  408fec:	c3                   	ret    
  408fed:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000408ff0 <__cosrt_fast_callgate_capmgr_vm_lapic_create>:
  408ff0:	55                   	push   rbp
  408ff1:	53                   	push   rbx
  408ff2:	41 54                	push   r12
  408ff4:	41 55                	push   r13
  408ff6:	41 56                	push   r14
  408ff8:	41 57                	push   r15
  408ffa:	4d 89 c4             	mov    r12,r8
  408ffd:	4c 89 cb             	mov    rbx,r9
  409000:	49 89 c8             	mov    r8,rcx
  409003:	49 89 d1             	mov    r9,rdx
  409006:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40900d:	be ad de 
  409010:	0f 01 f9             	rdtscp 
  409013:	48 89 ca             	mov    rdx,rcx
  409016:	48 25 ff 0f 00 00    	and    rax,0xfff
  40901c:	48 89 e2             	mov    rdx,rsp
  40901f:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  409026:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40902d:	00 
  40902e:	48 c1 e0 10          	shl    rax,0x10
  409032:	49 09 c5             	or     r13,rax
  409035:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40903c:	7f 00 00 
  40903f:	4c 89 e8             	mov    rax,r13
  409042:	48 25 ff ff 00 00    	and    rax,0xffff
  409048:	48 c1 e0 08          	shl    rax,0x8
  40904c:	49 01 c6             	add    r14,rax
  40904f:	b9 01 00 00 00       	mov    ecx,0x1
  409054:	01 c9                	add    ecx,ecx
  409056:	b8 03 00 00 00       	mov    eax,0x3
  40905b:	d3 e0                	shl    eax,cl
  40905d:	f7 d0                	not    eax
  40905f:	83 e0 fc             	and    eax,0xfffffffc
  409062:	48 31 c9             	xor    rcx,rcx
  409065:	48 31 d2             	xor    rdx,rdx
  409068:	0f 01 ef             	wrpkru 
  40906b:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40906e:	48 83 c2 01          	add    rdx,0x1
  409072:	48 c1 e2 04          	shl    rdx,0x4
  409076:	4c 01 f2             	add    rdx,r14
  409079:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  409080:	45 23 01 
  409083:	48 89 02             	mov    QWORD PTR [rdx],rax
  409086:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  40908a:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40908d:	48 83 c0 01          	add    rax,0x1
  409091:	49 89 06             	mov    QWORD PTR [r14],rax
  409094:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  409099:	01 c9                	add    ecx,ecx
  40909b:	b8 03 00 00 00       	mov    eax,0x3
  4090a0:	d3 e0                	shl    eax,cl
  4090a2:	f7 d0                	not    eax
  4090a4:	83 e0 fc             	and    eax,0xfffffffc
  4090a7:	48 31 c9             	xor    rcx,rcx
  4090aa:	48 31 d2             	xor    rdx,rdx
  4090ad:	0f 01 ef             	wrpkru 
  4090b0:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  4090b7:	45 23 01 
  4090ba:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4090c1:	be ad de 
  4090c4:	49 39 c7             	cmp    r15,rax
  4090c7:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  4090ce:	12 12 12 
  4090d1:	48 b9 dd 90 40 00 00 	movabs rcx,0x4090dd
  4090d8:	00 00 00 
  4090db:	ff e0                	jmp    rax

00000000004090dd <srv_call_ret_capmgr_vm_lapic_create>:
  4090dd:	49 89 c0             	mov    r8,rax
  4090e0:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4090e7:	be ad de 
  4090ea:	48 89 e2             	mov    rdx,rsp
  4090ed:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4090f4:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4090fb:	00 
  4090fc:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  409103:	7f 00 00 
  409106:	4c 89 e8             	mov    rax,r13
  409109:	48 25 ff ff 00 00    	and    rax,0xffff
  40910f:	48 c1 e0 08          	shl    rax,0x8
  409113:	49 01 c6             	add    r14,rax
  409116:	b9 01 00 00 00       	mov    ecx,0x1
  40911b:	01 c9                	add    ecx,ecx
  40911d:	b8 03 00 00 00       	mov    eax,0x3
  409122:	d3 e0                	shl    eax,cl
  409124:	f7 d0                	not    eax
  409126:	83 e0 fc             	and    eax,0xfffffffc
  409129:	48 31 c9             	xor    rcx,rcx
  40912c:	48 31 d2             	xor    rdx,rdx
  40912f:	0f 01 ef             	wrpkru 
  409132:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  409135:	48 c1 e2 04          	shl    rdx,0x4
  409139:	4c 01 f2             	add    rdx,r14
  40913c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  409140:	49 8b 06             	mov    rax,QWORD PTR [r14]
  409143:	48 83 e8 01          	sub    rax,0x1
  409147:	49 89 06             	mov    QWORD PTR [r14],rax
  40914a:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40914f:	01 c9                	add    ecx,ecx
  409151:	b8 03 00 00 00       	mov    eax,0x3
  409156:	d3 e0                	shl    eax,cl
  409158:	f7 d0                	not    eax
  40915a:	83 e0 fc             	and    eax,0xfffffffc
  40915d:	48 31 c9             	xor    rcx,rcx
  409160:	48 31 d2             	xor    rdx,rdx
  409163:	0f 01 ef             	wrpkru 
  409166:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40916d:	be ad de 
  409170:	49 39 c7             	cmp    r15,rax
  409173:	4c 89 c0             	mov    rax,r8
  409176:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  40917a:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  40917d:	41 5f                	pop    r15
  40917f:	41 5e                	pop    r14
  409181:	41 5d                	pop    r13
  409183:	41 5c                	pop    r12
  409185:	5b                   	pop    rbx
  409186:	5d                   	pop    rbp
  409187:	c3                   	ret    
  409188:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40918f:	00 

0000000000409190 <__cosrt_extern_capmgr_vm_shared_region_create>:
  409190:	48 b8 98 c2 5b 00 00 	movabs rax,0x5bc298
  409197:	00 00 00 
  40919a:	ff 10                	call   QWORD PTR [rax]
  40919c:	c3                   	ret    
  40919d:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004091a0 <__cosrt_fast_callgate_capmgr_vm_shared_region_create>:
  4091a0:	55                   	push   rbp
  4091a1:	53                   	push   rbx
  4091a2:	41 54                	push   r12
  4091a4:	41 55                	push   r13
  4091a6:	41 56                	push   r14
  4091a8:	41 57                	push   r15
  4091aa:	4d 89 c4             	mov    r12,r8
  4091ad:	4c 89 cb             	mov    rbx,r9
  4091b0:	49 89 c8             	mov    r8,rcx
  4091b3:	49 89 d1             	mov    r9,rdx
  4091b6:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4091bd:	be ad de 
  4091c0:	0f 01 f9             	rdtscp 
  4091c3:	48 89 ca             	mov    rdx,rcx
  4091c6:	48 25 ff 0f 00 00    	and    rax,0xfff
  4091cc:	48 89 e2             	mov    rdx,rsp
  4091cf:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4091d6:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4091dd:	00 
  4091de:	48 c1 e0 10          	shl    rax,0x10
  4091e2:	49 09 c5             	or     r13,rax
  4091e5:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4091ec:	7f 00 00 
  4091ef:	4c 89 e8             	mov    rax,r13
  4091f2:	48 25 ff ff 00 00    	and    rax,0xffff
  4091f8:	48 c1 e0 08          	shl    rax,0x8
  4091fc:	49 01 c6             	add    r14,rax
  4091ff:	b9 01 00 00 00       	mov    ecx,0x1
  409204:	01 c9                	add    ecx,ecx
  409206:	b8 03 00 00 00       	mov    eax,0x3
  40920b:	d3 e0                	shl    eax,cl
  40920d:	f7 d0                	not    eax
  40920f:	83 e0 fc             	and    eax,0xfffffffc
  409212:	48 31 c9             	xor    rcx,rcx
  409215:	48 31 d2             	xor    rdx,rdx
  409218:	0f 01 ef             	wrpkru 
  40921b:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40921e:	48 83 c2 01          	add    rdx,0x1
  409222:	48 c1 e2 04          	shl    rdx,0x4
  409226:	4c 01 f2             	add    rdx,r14
  409229:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  409230:	45 23 01 
  409233:	48 89 02             	mov    QWORD PTR [rdx],rax
  409236:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  40923a:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40923d:	48 83 c0 01          	add    rax,0x1
  409241:	49 89 06             	mov    QWORD PTR [r14],rax
  409244:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  409249:	01 c9                	add    ecx,ecx
  40924b:	b8 03 00 00 00       	mov    eax,0x3
  409250:	d3 e0                	shl    eax,cl
  409252:	f7 d0                	not    eax
  409254:	83 e0 fc             	and    eax,0xfffffffc
  409257:	48 31 c9             	xor    rcx,rcx
  40925a:	48 31 d2             	xor    rdx,rdx
  40925d:	0f 01 ef             	wrpkru 
  409260:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  409267:	45 23 01 
  40926a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409271:	be ad de 
  409274:	49 39 c7             	cmp    r15,rax
  409277:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  40927e:	12 12 12 
  409281:	48 b9 8d 92 40 00 00 	movabs rcx,0x40928d
  409288:	00 00 00 
  40928b:	ff e0                	jmp    rax

000000000040928d <srv_call_ret_capmgr_vm_shared_region_create>:
  40928d:	49 89 c0             	mov    r8,rax
  409290:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  409297:	be ad de 
  40929a:	48 89 e2             	mov    rdx,rsp
  40929d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  4092a4:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  4092ab:	00 
  4092ac:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  4092b3:	7f 00 00 
  4092b6:	4c 89 e8             	mov    rax,r13
  4092b9:	48 25 ff ff 00 00    	and    rax,0xffff
  4092bf:	48 c1 e0 08          	shl    rax,0x8
  4092c3:	49 01 c6             	add    r14,rax
  4092c6:	b9 01 00 00 00       	mov    ecx,0x1
  4092cb:	01 c9                	add    ecx,ecx
  4092cd:	b8 03 00 00 00       	mov    eax,0x3
  4092d2:	d3 e0                	shl    eax,cl
  4092d4:	f7 d0                	not    eax
  4092d6:	83 e0 fc             	and    eax,0xfffffffc
  4092d9:	48 31 c9             	xor    rcx,rcx
  4092dc:	48 31 d2             	xor    rdx,rdx
  4092df:	0f 01 ef             	wrpkru 
  4092e2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4092e5:	48 c1 e2 04          	shl    rdx,0x4
  4092e9:	4c 01 f2             	add    rdx,r14
  4092ec:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  4092f0:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4092f3:	48 83 e8 01          	sub    rax,0x1
  4092f7:	49 89 06             	mov    QWORD PTR [r14],rax
  4092fa:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4092ff:	01 c9                	add    ecx,ecx
  409301:	b8 03 00 00 00       	mov    eax,0x3
  409306:	d3 e0                	shl    eax,cl
  409308:	f7 d0                	not    eax
  40930a:	83 e0 fc             	and    eax,0xfffffffc
  40930d:	48 31 c9             	xor    rcx,rcx
  409310:	48 31 d2             	xor    rdx,rdx
  409313:	0f 01 ef             	wrpkru 
  409316:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40931d:	be ad de 
  409320:	49 39 c7             	cmp    r15,rax
  409323:	4c 89 c0             	mov    rax,r8
  409326:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  40932a:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  40932d:	41 5f                	pop    r15
  40932f:	41 5e                	pop    r14
  409331:	41 5d                	pop    r13
  409333:	41 5c                	pop    r12
  409335:	5b                   	pop    rbx
  409336:	5d                   	pop    rbp
  409337:	c3                   	ret    
  409338:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40933f:	00 

0000000000409340 <__cosrt_extern_capmgr_vm_vmcb_create>:
  409340:	48 b8 b0 c2 5b 00 00 	movabs rax,0x5bc2b0
  409347:	00 00 00 
  40934a:	ff 10                	call   QWORD PTR [rax]
  40934c:	c3                   	ret    
  40934d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000409350 <__cosrt_fast_callgate_capmgr_vm_vmcb_create>:
  409350:	55                   	push   rbp
  409351:	53                   	push   rbx
  409352:	41 54                	push   r12
  409354:	41 55                	push   r13
  409356:	41 56                	push   r14
  409358:	41 57                	push   r15
  40935a:	4d 89 c4             	mov    r12,r8
  40935d:	4c 89 cb             	mov    rbx,r9
  409360:	49 89 c8             	mov    r8,rcx
  409363:	49 89 d1             	mov    r9,rdx
  409366:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40936d:	be ad de 
  409370:	0f 01 f9             	rdtscp 
  409373:	48 89 ca             	mov    rdx,rcx
  409376:	48 25 ff 0f 00 00    	and    rax,0xfff
  40937c:	48 89 e2             	mov    rdx,rsp
  40937f:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  409386:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40938d:	00 
  40938e:	48 c1 e0 10          	shl    rax,0x10
  409392:	49 09 c5             	or     r13,rax
  409395:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40939c:	7f 00 00 
  40939f:	4c 89 e8             	mov    rax,r13
  4093a2:	48 25 ff ff 00 00    	and    rax,0xffff
  4093a8:	48 c1 e0 08          	shl    rax,0x8
  4093ac:	49 01 c6             	add    r14,rax
  4093af:	b9 01 00 00 00       	mov    ecx,0x1
  4093b4:	01 c9                	add    ecx,ecx
  4093b6:	b8 03 00 00 00       	mov    eax,0x3
  4093bb:	d3 e0                	shl    eax,cl
  4093bd:	f7 d0                	not    eax
  4093bf:	83 e0 fc             	and    eax,0xfffffffc
  4093c2:	48 31 c9             	xor    rcx,rcx
  4093c5:	48 31 d2             	xor    rdx,rdx
  4093c8:	0f 01 ef             	wrpkru 
  4093cb:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  4093ce:	48 83 c2 01          	add    rdx,0x1
  4093d2:	48 c1 e2 04          	shl    rdx,0x4
  4093d6:	4c 01 f2             	add    rdx,r14
  4093d9:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  4093e0:	45 23 01 
  4093e3:	48 89 02             	mov    QWORD PTR [rdx],rax
  4093e6:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  4093ea:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4093ed:	48 83 c0 01          	add    rax,0x1
  4093f1:	49 89 06             	mov    QWORD PTR [r14],rax
  4093f4:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4093f9:	01 c9                	add    ecx,ecx
  4093fb:	b8 03 00 00 00       	mov    eax,0x3
  409400:	d3 e0                	shl    eax,cl
  409402:	f7 d0                	not    eax
  409404:	83 e0 fc             	and    eax,0xfffffffc
  409407:	48 31 c9             	xor    rcx,rcx
  40940a:	48 31 d2             	xor    rdx,rdx
  40940d:	0f 01 ef             	wrpkru 
  409410:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  409417:	45 23 01 
  40941a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409421:	be ad de 
  409424:	49 39 c7             	cmp    r15,rax
  409427:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  40942e:	12 12 12 
  409431:	48 b9 3d 94 40 00 00 	movabs rcx,0x40943d
  409438:	00 00 00 
  40943b:	ff e0                	jmp    rax

000000000040943d <srv_call_ret_capmgr_vm_vmcb_create>:
  40943d:	49 89 c0             	mov    r8,rax
  409440:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  409447:	be ad de 
  40944a:	48 89 e2             	mov    rdx,rsp
  40944d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  409454:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40945b:	00 
  40945c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  409463:	7f 00 00 
  409466:	4c 89 e8             	mov    rax,r13
  409469:	48 25 ff ff 00 00    	and    rax,0xffff
  40946f:	48 c1 e0 08          	shl    rax,0x8
  409473:	49 01 c6             	add    r14,rax
  409476:	b9 01 00 00 00       	mov    ecx,0x1
  40947b:	01 c9                	add    ecx,ecx
  40947d:	b8 03 00 00 00       	mov    eax,0x3
  409482:	d3 e0                	shl    eax,cl
  409484:	f7 d0                	not    eax
  409486:	83 e0 fc             	and    eax,0xfffffffc
  409489:	48 31 c9             	xor    rcx,rcx
  40948c:	48 31 d2             	xor    rdx,rdx
  40948f:	0f 01 ef             	wrpkru 
  409492:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  409495:	48 c1 e2 04          	shl    rdx,0x4
  409499:	4c 01 f2             	add    rdx,r14
  40949c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  4094a0:	49 8b 06             	mov    rax,QWORD PTR [r14]
  4094a3:	48 83 e8 01          	sub    rax,0x1
  4094a7:	49 89 06             	mov    QWORD PTR [r14],rax
  4094aa:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4094af:	01 c9                	add    ecx,ecx
  4094b1:	b8 03 00 00 00       	mov    eax,0x3
  4094b6:	d3 e0                	shl    eax,cl
  4094b8:	f7 d0                	not    eax
  4094ba:	83 e0 fc             	and    eax,0xfffffffc
  4094bd:	48 31 c9             	xor    rcx,rcx
  4094c0:	48 31 d2             	xor    rdx,rdx
  4094c3:	0f 01 ef             	wrpkru 
  4094c6:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4094cd:	be ad de 
  4094d0:	49 39 c7             	cmp    r15,rax
  4094d3:	4c 89 c0             	mov    rax,r8
  4094d6:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  4094da:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  4094dd:	41 5f                	pop    r15
  4094df:	41 5e                	pop    r14
  4094e1:	41 5d                	pop    r13
  4094e3:	41 5c                	pop    r12
  4094e5:	5b                   	pop    rbx
  4094e6:	5d                   	pop    rbp
  4094e7:	c3                   	ret    
  4094e8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4094ef:	00 

00000000004094f0 <__cosrt_extern_capmgr_vm_vcpu_create>:
  4094f0:	48 b8 c8 c2 5b 00 00 	movabs rax,0x5bc2c8
  4094f7:	00 00 00 
  4094fa:	ff 10                	call   QWORD PTR [rax]
  4094fc:	c3                   	ret    
  4094fd:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000409500 <__cosrt_fast_callgate_capmgr_vm_vcpu_create>:
  409500:	55                   	push   rbp
  409501:	53                   	push   rbx
  409502:	41 54                	push   r12
  409504:	41 55                	push   r13
  409506:	41 56                	push   r14
  409508:	41 57                	push   r15
  40950a:	4d 89 c4             	mov    r12,r8
  40950d:	4c 89 cb             	mov    rbx,r9
  409510:	49 89 c8             	mov    r8,rcx
  409513:	49 89 d1             	mov    r9,rdx
  409516:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40951d:	be ad de 
  409520:	0f 01 f9             	rdtscp 
  409523:	48 89 ca             	mov    rdx,rcx
  409526:	48 25 ff 0f 00 00    	and    rax,0xfff
  40952c:	48 89 e2             	mov    rdx,rsp
  40952f:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  409536:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40953d:	00 
  40953e:	48 c1 e0 10          	shl    rax,0x10
  409542:	49 09 c5             	or     r13,rax
  409545:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40954c:	7f 00 00 
  40954f:	4c 89 e8             	mov    rax,r13
  409552:	48 25 ff ff 00 00    	and    rax,0xffff
  409558:	48 c1 e0 08          	shl    rax,0x8
  40955c:	49 01 c6             	add    r14,rax
  40955f:	b9 01 00 00 00       	mov    ecx,0x1
  409564:	01 c9                	add    ecx,ecx
  409566:	b8 03 00 00 00       	mov    eax,0x3
  40956b:	d3 e0                	shl    eax,cl
  40956d:	f7 d0                	not    eax
  40956f:	83 e0 fc             	and    eax,0xfffffffc
  409572:	48 31 c9             	xor    rcx,rcx
  409575:	48 31 d2             	xor    rdx,rdx
  409578:	0f 01 ef             	wrpkru 
  40957b:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40957e:	48 83 c2 01          	add    rdx,0x1
  409582:	48 c1 e2 04          	shl    rdx,0x4
  409586:	4c 01 f2             	add    rdx,r14
  409589:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  409590:	45 23 01 
  409593:	48 89 02             	mov    QWORD PTR [rdx],rax
  409596:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  40959a:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40959d:	48 83 c0 01          	add    rax,0x1
  4095a1:	49 89 06             	mov    QWORD PTR [r14],rax
  4095a4:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  4095a9:	01 c9                	add    ecx,ecx
  4095ab:	b8 03 00 00 00       	mov    eax,0x3
  4095b0:	d3 e0                	shl    eax,cl
  4095b2:	f7 d0                	not    eax
  4095b4:	83 e0 fc             	and    eax,0xfffffffc
  4095b7:	48 31 c9             	xor    rcx,rcx
  4095ba:	48 31 d2             	xor    rdx,rdx
  4095bd:	0f 01 ef             	wrpkru 
  4095c0:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  4095c7:	45 23 01 
  4095ca:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  4095d1:	be ad de 
  4095d4:	49 39 c7             	cmp    r15,rax
  4095d7:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  4095de:	12 12 12 
  4095e1:	48 b9 ed 95 40 00 00 	movabs rcx,0x4095ed
  4095e8:	00 00 00 
  4095eb:	ff e0                	jmp    rax

00000000004095ed <srv_call_ret_capmgr_vm_vcpu_create>:
  4095ed:	49 89 c0             	mov    r8,rax
  4095f0:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  4095f7:	be ad de 
  4095fa:	48 89 e2             	mov    rdx,rsp
  4095fd:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  409604:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40960b:	00 
  40960c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  409613:	7f 00 00 
  409616:	4c 89 e8             	mov    rax,r13
  409619:	48 25 ff ff 00 00    	and    rax,0xffff
  40961f:	48 c1 e0 08          	shl    rax,0x8
  409623:	49 01 c6             	add    r14,rax
  409626:	b9 01 00 00 00       	mov    ecx,0x1
  40962b:	01 c9                	add    ecx,ecx
  40962d:	b8 03 00 00 00       	mov    eax,0x3
  409632:	d3 e0                	shl    eax,cl
  409634:	f7 d0                	not    eax
  409636:	83 e0 fc             	and    eax,0xfffffffc
  409639:	48 31 c9             	xor    rcx,rcx
  40963c:	48 31 d2             	xor    rdx,rdx
  40963f:	0f 01 ef             	wrpkru 
  409642:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  409645:	48 c1 e2 04          	shl    rdx,0x4
  409649:	4c 01 f2             	add    rdx,r14
  40964c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  409650:	49 8b 06             	mov    rax,QWORD PTR [r14]
  409653:	48 83 e8 01          	sub    rax,0x1
  409657:	49 89 06             	mov    QWORD PTR [r14],rax
  40965a:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40965f:	01 c9                	add    ecx,ecx
  409661:	b8 03 00 00 00       	mov    eax,0x3
  409666:	d3 e0                	shl    eax,cl
  409668:	f7 d0                	not    eax
  40966a:	83 e0 fc             	and    eax,0xfffffffc
  40966d:	48 31 c9             	xor    rcx,rcx
  409670:	48 31 d2             	xor    rdx,rdx
  409673:	0f 01 ef             	wrpkru 
  409676:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40967d:	be ad de 
  409680:	49 39 c7             	cmp    r15,rax
  409683:	4c 89 c0             	mov    rax,r8
  409686:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  40968a:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  40968d:	41 5f                	pop    r15
  40968f:	41 5e                	pop    r14
  409691:	41 5d                	pop    r13
  409693:	41 5c                	pop    r12
  409695:	5b                   	pop    rbx
  409696:	5d                   	pop    rbp
  409697:	c3                   	ret    
  409698:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40969f:	00 

00000000004096a0 <__cosrt_c_memmgr_shared_page_allocn>:
#include <cos_component.h>
#include <cos_stubs.h>
#include <memmgr.h>

COS_CLIENT_STUB(cbuf_t, memmgr_shared_page_allocn, unsigned long num_pages, vaddr_t *pgaddr)
{
  4096a0:	f3 0f 1e fa          	endbr64 
  4096a4:	55                   	push   rbp
  4096a5:	48 89 e5             	mov    rbp,rsp
  4096a8:	41 57                	push   r15
  4096aa:	41 56                	push   r14
  4096ac:	41 55                	push   r13
  4096ae:	49 89 f5             	mov    r13,rsi
  4096b1:	41 54                	push   r12
  4096b3:	53                   	push   rbx
  4096b4:	48 83 ec 28          	sub    rsp,0x28
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  4096b8:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  4096bc:	4d 85 f6             	test   r14,r14
  4096bf:	74 2f                	je     4096f0 <__cosrt_c_memmgr_shared_page_allocn+0x50>
  4096c1:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  4096c5:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  4096c9:	31 c9                	xor    ecx,ecx
  4096cb:	31 d2                	xor    edx,edx
  4096cd:	31 f6                	xor    esi,esi
  4096cf:	41 ff d6             	call   r14
	COS_CLIENT_INVCAP;
	word_t unused, addrret;
	cbuf_t ret;

	ret = cos_sinv_2rets(uc, num_pages, 0, 0, 0, &addrret, &unused);
	*pgaddr = addrret;
  4096d2:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
  4096d6:	49 89 55 00          	mov    QWORD PTR [r13+0x0],rdx

	return ret;
}
  4096da:	48 83 c4 28          	add    rsp,0x28
  4096de:	5b                   	pop    rbx
  4096df:	41 5c                	pop    r12
  4096e1:	41 5d                	pop    r13
  4096e3:	41 5e                	pop    r14
  4096e5:	41 5f                	pop    r15
  4096e7:	5d                   	pop    rbp
  4096e8:	c3                   	ret    
  4096e9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  4096f0:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  4096f4:	48 89 fb             	mov    rbx,rdi
  4096f7:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  4096fb:	4c 89 f6             	mov    rsi,r14
  4096fe:	4c 89 f7             	mov    rdi,r14
  409701:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  409704:	83 c0 01             	add    eax,0x1
  409707:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40970a:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40970d:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  409711:	48 89 cd             	mov    rbp,rcx
  409714:	49 b8 28 97 40 00 00 	movabs r8,0x409728
  40971b:	00 00 00 
  40971e:	0f 05                	syscall 
  409720:	eb 0f                	jmp    409731 <__cosrt_c_memmgr_shared_page_allocn+0x91>
  409722:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  409728:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  40972f:	eb 07                	jmp    409738 <__cosrt_c_memmgr_shared_page_allocn+0x98>
  409731:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  409738:	5d                   	pop    rbp
  409739:	5c                   	pop    rsp
  40973a:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  40973e:	eb 92                	jmp    4096d2 <__cosrt_c_memmgr_shared_page_allocn+0x32>

0000000000409740 <__cosrt_c_memmgr_shared_page_map>:

COS_CLIENT_STUB(unsigned long, memmgr_shared_page_map, cbuf_t id, vaddr_t *pgaddr)
{
  409740:	f3 0f 1e fa          	endbr64 
  409744:	55                   	push   rbp
  409745:	48 89 e5             	mov    rbp,rsp
  409748:	41 57                	push   r15
	COS_CLIENT_INVCAP;
	word_t unused, addrret;
	unsigned long ret;

	ret = cos_sinv_2rets(uc, id, 0, 0, 0, &addrret, &unused);
  40974a:	41 89 ff             	mov    r15d,edi
{
  40974d:	41 56                	push   r14
  40974f:	41 55                	push   r13
  409751:	49 89 f5             	mov    r13,rsi
  409754:	41 54                	push   r12
  409756:	53                   	push   rbx
  409757:	48 83 ec 28          	sub    rsp,0x28
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  40975b:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  40975f:	4d 85 f6             	test   r14,r14
  409762:	74 34                	je     409798 <__cosrt_c_memmgr_shared_page_map+0x58>
  409764:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  409768:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  40976c:	31 c9                	xor    ecx,ecx
  40976e:	31 d2                	xor    edx,edx
  409770:	31 f6                	xor    esi,esi
  409772:	4c 89 ff             	mov    rdi,r15
  409775:	41 ff d6             	call   r14
	*pgaddr = addrret;
  409778:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
	ret = cos_sinv_2rets(uc, id, 0, 0, 0, &addrret, &unused);
  40977c:	48 98                	cdqe   
	*pgaddr = addrret;
  40977e:	49 89 55 00          	mov    QWORD PTR [r13+0x0],rdx

	return ret;
}
  409782:	48 83 c4 28          	add    rsp,0x28
  409786:	5b                   	pop    rbx
  409787:	41 5c                	pop    r12
  409789:	41 5d                	pop    r13
  40978b:	41 5e                	pop    r14
  40978d:	41 5f                	pop    r15
  40978f:	5d                   	pop    rbp
  409790:	c3                   	ret    
  409791:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  409798:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  40979c:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  4097a0:	4c 89 fb             	mov    rbx,r15
  4097a3:	4c 89 f6             	mov    rsi,r14
  4097a6:	4c 89 f7             	mov    rdi,r14
  4097a9:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4097ac:	83 c0 01             	add    eax,0x1
  4097af:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  4097b2:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4097b5:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4097b9:	48 89 cd             	mov    rbp,rcx
  4097bc:	49 b8 d0 97 40 00 00 	movabs r8,0x4097d0
  4097c3:	00 00 00 
  4097c6:	0f 05                	syscall 
  4097c8:	eb 0f                	jmp    4097d9 <__cosrt_c_memmgr_shared_page_map+0x99>
  4097ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4097d0:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  4097d7:	eb 07                	jmp    4097e0 <__cosrt_c_memmgr_shared_page_map+0xa0>
  4097d9:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  4097e0:	5d                   	pop    rbp
  4097e1:	5c                   	pop    rsp
  4097e2:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  4097e6:	eb 90                	jmp    409778 <__cosrt_c_memmgr_shared_page_map+0x38>
  4097e8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4097ef:	00 

00000000004097f0 <__cosrt_c_memmgr_shared_page_allocn_aligned>:

COS_CLIENT_STUB(cbuf_t, memmgr_shared_page_allocn_aligned, unsigned long num_pages, unsigned long align, vaddr_t *pgaddr)
{
  4097f0:	f3 0f 1e fa          	endbr64 
  4097f4:	55                   	push   rbp
  4097f5:	48 89 e5             	mov    rbp,rsp
  4097f8:	41 57                	push   r15
  4097fa:	49 89 d7             	mov    r15,rdx
  4097fd:	41 56                	push   r14
  4097ff:	41 55                	push   r13
  409801:	41 54                	push   r12
  409803:	53                   	push   rbx
  409804:	48 83 ec 28          	sub    rsp,0x28
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  409808:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  40980c:	4d 85 f6             	test   r14,r14
  40980f:	74 2f                	je     409840 <__cosrt_c_memmgr_shared_page_allocn_aligned+0x50>
  409811:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  409815:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  409819:	31 c9                	xor    ecx,ecx
  40981b:	31 d2                	xor    edx,edx
  40981d:	41 ff d6             	call   r14
	COS_CLIENT_INVCAP;
	word_t unused, addrret;
	cbuf_t ret;

	ret = cos_sinv_2rets(uc, num_pages, align, 0, 0, &addrret, &unused);
	*pgaddr = addrret;
  409820:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
  409824:	49 89 17             	mov    QWORD PTR [r15],rdx

	return ret;
}
  409827:	48 83 c4 28          	add    rsp,0x28
  40982b:	5b                   	pop    rbx
  40982c:	41 5c                	pop    r12
  40982e:	41 5d                	pop    r13
  409830:	41 5e                	pop    r14
  409832:	41 5f                	pop    r15
  409834:	5d                   	pop    rbp
  409835:	c3                   	ret    
  409836:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40983d:	00 00 00 
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  409840:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  409844:	48 89 fb             	mov    rbx,rdi
  409847:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  40984b:	4c 89 f7             	mov    rdi,r14
  40984e:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  409851:	83 c0 01             	add    eax,0x1
  409854:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  409857:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40985a:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40985e:	48 89 cd             	mov    rbp,rcx
  409861:	49 b8 78 98 40 00 00 	movabs r8,0x409878
  409868:	00 00 00 
  40986b:	0f 05                	syscall 
  40986d:	0f 1f 00             	nop    DWORD PTR [rax]
  409870:	eb 0f                	jmp    409881 <__cosrt_c_memmgr_shared_page_allocn_aligned+0x91>
  409872:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  409878:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  40987f:	eb 07                	jmp    409888 <__cosrt_c_memmgr_shared_page_allocn_aligned+0x98>
  409881:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  409888:	5d                   	pop    rbp
  409889:	5c                   	pop    rsp
  40988a:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  40988e:	eb 90                	jmp    409820 <__cosrt_c_memmgr_shared_page_allocn_aligned+0x30>

0000000000409890 <__cosrt_c_memmgr_shared_page_map_aligned>:

COS_CLIENT_STUB(unsigned long, memmgr_shared_page_map_aligned, cbuf_t id, unsigned long align, vaddr_t *pgaddr)
{
  409890:	f3 0f 1e fa          	endbr64 
  409894:	55                   	push   rbp
  409895:	48 89 e5             	mov    rbp,rsp
  409898:	41 57                	push   r15
  40989a:	49 89 d7             	mov    r15,rdx
  40989d:	41 56                	push   r14
  40989f:	41 55                	push   r13
	COS_CLIENT_INVCAP;
	word_t unused, addrret;
	unsigned long ret;

	ret = cos_sinv_2rets(uc, id, align, 0, 0, &addrret, &unused);
  4098a1:	41 89 fd             	mov    r13d,edi
{
  4098a4:	41 54                	push   r12
  4098a6:	53                   	push   rbx
  4098a7:	48 83 ec 28          	sub    rsp,0x28
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  4098ab:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  4098af:	4d 85 f6             	test   r14,r14
  4098b2:	74 2c                	je     4098e0 <__cosrt_c_memmgr_shared_page_map_aligned+0x50>
  4098b4:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  4098b8:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  4098bc:	31 c9                	xor    ecx,ecx
  4098be:	31 d2                	xor    edx,edx
  4098c0:	4c 89 ef             	mov    rdi,r13
  4098c3:	41 ff d6             	call   r14
	*pgaddr = addrret;
  4098c6:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
	ret = cos_sinv_2rets(uc, id, align, 0, 0, &addrret, &unused);
  4098ca:	48 98                	cdqe   
	*pgaddr = addrret;
  4098cc:	49 89 17             	mov    QWORD PTR [r15],rdx

	return ret;
}
  4098cf:	48 83 c4 28          	add    rsp,0x28
  4098d3:	5b                   	pop    rbx
  4098d4:	41 5c                	pop    r12
  4098d6:	41 5d                	pop    r13
  4098d8:	41 5e                	pop    r14
  4098da:	41 5f                	pop    r15
  4098dc:	5d                   	pop    rbp
  4098dd:	c3                   	ret    
  4098de:	66 90                	xchg   ax,ax
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  4098e0:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  4098e4:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  4098e8:	4c 89 eb             	mov    rbx,r13
  4098eb:	4c 89 f7             	mov    rdi,r14
  4098ee:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4098f1:	83 c0 01             	add    eax,0x1
  4098f4:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  4098f7:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4098fa:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4098fe:	48 89 cd             	mov    rbp,rcx
  409901:	49 b8 18 99 40 00 00 	movabs r8,0x409918
  409908:	00 00 00 
  40990b:	0f 05                	syscall 
  40990d:	0f 1f 00             	nop    DWORD PTR [rax]
  409910:	eb 0f                	jmp    409921 <__cosrt_c_memmgr_shared_page_map_aligned+0x91>
  409912:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  409918:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  40991f:	eb 07                	jmp    409928 <__cosrt_c_memmgr_shared_page_map_aligned+0x98>
  409921:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  409928:	5d                   	pop    rbp
  409929:	5c                   	pop    rsp
  40992a:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  40992e:	eb 96                	jmp    4098c6 <__cosrt_c_memmgr_shared_page_map_aligned+0x36>

0000000000409930 <__cosrt_c_memmgr_shared_page_map_aligned_in_vm>:

COS_CLIENT_STUB(unsigned long, memmgr_shared_page_map_aligned_in_vm, cbuf_t id, unsigned long align, vaddr_t *pgaddr, compid_t cid)
{
  409930:	f3 0f 1e fa          	endbr64 
  409934:	55                   	push   rbp
  409935:	48 89 e5             	mov    rbp,rsp
  409938:	41 57                	push   r15
	COS_CLIENT_INVCAP;
	word_t unused, addrret;
	unsigned long ret;

	ret = cos_sinv_2rets(uc, id, align, cid, 0, &addrret, &unused);
  40993a:	41 89 ff             	mov    r15d,edi
{
  40993d:	41 56                	push   r14
  40993f:	41 55                	push   r13
  409941:	49 89 cd             	mov    r13,rcx
  409944:	41 54                	push   r12
  409946:	53                   	push   rbx
  409947:	48 83 ec 38          	sub    rsp,0x38
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  40994b:	4c 8b 70 10          	mov    r14,QWORD PTR [rax+0x10]
  40994f:	48 89 55 a8          	mov    QWORD PTR [rbp-0x58],rdx
  409953:	4d 85 f6             	test   r14,r14
  409956:	74 38                	je     409990 <__cosrt_c_memmgr_shared_page_map_aligned_in_vm+0x60>
  409958:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  40995c:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  409960:	31 c9                	xor    ecx,ecx
  409962:	4c 89 ea             	mov    rdx,r13
  409965:	4c 89 ff             	mov    rdi,r15
  409968:	41 ff d6             	call   r14
	*pgaddr = addrret;
  40996b:	48 8b 5d a8          	mov    rbx,QWORD PTR [rbp-0x58]
  40996f:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
	ret = cos_sinv_2rets(uc, id, align, cid, 0, &addrret, &unused);
  409973:	48 98                	cdqe   
	*pgaddr = addrret;
  409975:	48 89 13             	mov    QWORD PTR [rbx],rdx

	return ret;
}
  409978:	48 83 c4 38          	add    rsp,0x38
  40997c:	5b                   	pop    rbx
  40997d:	41 5c                	pop    r12
  40997f:	41 5d                	pop    r13
  409981:	41 5e                	pop    r14
  409983:	41 5f                	pop    r15
  409985:	5d                   	pop    rbp
  409986:	c3                   	ret    
  409987:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40998e:	00 00 
	return call_cap_2retvals_asm(uc->cap_no, 0, arg1, arg2, arg3, arg4, ret1, ret2);
  409990:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	__asm__ __volatile__(
  409994:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  409998:	4c 89 fb             	mov    rbx,r15
  40999b:	4c 89 ef             	mov    rdi,r13
  40999e:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4099a1:	83 c0 01             	add    eax,0x1
  4099a4:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  4099a7:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4099aa:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4099ae:	48 89 cd             	mov    rbp,rcx
  4099b1:	49 b8 c8 99 40 00 00 	movabs r8,0x4099c8
  4099b8:	00 00 00 
  4099bb:	0f 05                	syscall 
  4099bd:	0f 1f 00             	nop    DWORD PTR [rax]
  4099c0:	eb 0f                	jmp    4099d1 <__cosrt_c_memmgr_shared_page_map_aligned_in_vm+0xa1>
  4099c2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4099c8:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  4099cf:	eb 07                	jmp    4099d8 <__cosrt_c_memmgr_shared_page_map_aligned_in_vm+0xa8>
  4099d1:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  4099d8:	5d                   	pop    rbp
  4099d9:	5c                   	pop    rsp
  4099da:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
	return ret;
  4099de:	eb 8b                	jmp    40996b <__cosrt_c_memmgr_shared_page_map_aligned_in_vm+0x3b>

00000000004099e0 <__cosrt_extern_memmgr_heap_page_allocn>:
  4099e0:	48 b8 e0 c2 5b 00 00 	movabs rax,0x5bc2e0
  4099e7:	00 00 00 
  4099ea:	ff 10                	call   QWORD PTR [rax]
  4099ec:	c3                   	ret    
  4099ed:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004099f0 <__cosrt_fast_callgate_memmgr_heap_page_allocn>:
  4099f0:	55                   	push   rbp
  4099f1:	41 55                	push   r13
  4099f3:	41 56                	push   r14
  4099f5:	41 57                	push   r15
  4099f7:	49 89 c8             	mov    r8,rcx
  4099fa:	49 89 d1             	mov    r9,rdx
  4099fd:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  409a04:	be ad de 
  409a07:	0f 01 f9             	rdtscp 
  409a0a:	48 89 c8             	mov    rax,rcx
  409a0d:	48 25 ff 0f 00 00    	and    rax,0xfff
  409a13:	48 89 e2             	mov    rdx,rsp
  409a16:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  409a1d:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  409a24:	00 
  409a25:	48 c1 e0 10          	shl    rax,0x10
  409a29:	49 09 c5             	or     r13,rax
  409a2c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  409a33:	7f 00 00 
  409a36:	4c 89 e8             	mov    rax,r13
  409a39:	48 25 ff ff 00 00    	and    rax,0xffff
  409a3f:	48 c1 e0 08          	shl    rax,0x8
  409a43:	49 01 c6             	add    r14,rax
  409a46:	b9 01 00 00 00       	mov    ecx,0x1
  409a4b:	01 c9                	add    ecx,ecx
  409a4d:	b8 03 00 00 00       	mov    eax,0x3
  409a52:	d3 e0                	shl    eax,cl
  409a54:	f7 d0                	not    eax
  409a56:	83 e0 fc             	and    eax,0xfffffffc
  409a59:	48 31 c9             	xor    rcx,rcx
  409a5c:	48 31 d2             	xor    rdx,rdx
  409a5f:	0f 01 ef             	wrpkru 
  409a62:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  409a65:	48 83 c2 01          	add    rdx,0x1
  409a69:	48 c1 e2 04          	shl    rdx,0x4
  409a6d:	4c 01 f2             	add    rdx,r14
  409a70:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  409a77:	45 23 01 
  409a7a:	48 89 02             	mov    QWORD PTR [rdx],rax
  409a7d:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  409a81:	49 8b 06             	mov    rax,QWORD PTR [r14]
  409a84:	48 83 c0 01          	add    rax,0x1
  409a88:	49 89 06             	mov    QWORD PTR [r14],rax
  409a8b:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  409a90:	01 c9                	add    ecx,ecx
  409a92:	b8 03 00 00 00       	mov    eax,0x3
  409a97:	d3 e0                	shl    eax,cl
  409a99:	f7 d0                	not    eax
  409a9b:	83 e0 fc             	and    eax,0xfffffffc
  409a9e:	48 31 c9             	xor    rcx,rcx
  409aa1:	48 31 d2             	xor    rdx,rdx
  409aa4:	0f 01 ef             	wrpkru 
  409aa7:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  409aae:	45 23 01 
  409ab1:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409ab8:	be ad de 
  409abb:	49 39 c7             	cmp    r15,rax
  409abe:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  409ac5:	12 12 12 
  409ac8:	48 b9 d4 9a 40 00 00 	movabs rcx,0x409ad4
  409acf:	00 00 00 
  409ad2:	ff e0                	jmp    rax

0000000000409ad4 <srv_call_ret_memmgr_heap_page_allocn>:
  409ad4:	49 89 c0             	mov    r8,rax
  409ad7:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  409ade:	be ad de 
  409ae1:	48 89 e2             	mov    rdx,rsp
  409ae4:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  409aeb:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  409af2:	00 
  409af3:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  409afa:	7f 00 00 
  409afd:	4c 89 e8             	mov    rax,r13
  409b00:	48 25 ff ff 00 00    	and    rax,0xffff
  409b06:	48 c1 e0 08          	shl    rax,0x8
  409b0a:	49 01 c6             	add    r14,rax
  409b0d:	b9 01 00 00 00       	mov    ecx,0x1
  409b12:	01 c9                	add    ecx,ecx
  409b14:	b8 03 00 00 00       	mov    eax,0x3
  409b19:	d3 e0                	shl    eax,cl
  409b1b:	f7 d0                	not    eax
  409b1d:	83 e0 fc             	and    eax,0xfffffffc
  409b20:	48 31 c9             	xor    rcx,rcx
  409b23:	48 31 d2             	xor    rdx,rdx
  409b26:	0f 01 ef             	wrpkru 
  409b29:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  409b2c:	48 c1 e2 04          	shl    rdx,0x4
  409b30:	4c 01 f2             	add    rdx,r14
  409b33:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  409b37:	49 8b 06             	mov    rax,QWORD PTR [r14]
  409b3a:	48 83 e8 01          	sub    rax,0x1
  409b3e:	49 89 06             	mov    QWORD PTR [r14],rax
  409b41:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  409b46:	01 c9                	add    ecx,ecx
  409b48:	b8 03 00 00 00       	mov    eax,0x3
  409b4d:	d3 e0                	shl    eax,cl
  409b4f:	f7 d0                	not    eax
  409b51:	83 e0 fc             	and    eax,0xfffffffc
  409b54:	48 31 c9             	xor    rcx,rcx
  409b57:	48 31 d2             	xor    rdx,rdx
  409b5a:	0f 01 ef             	wrpkru 
  409b5d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409b64:	be ad de 
  409b67:	49 39 c7             	cmp    r15,rax
  409b6a:	4c 89 c0             	mov    rax,r8
  409b6d:	41 5f                	pop    r15
  409b6f:	41 5e                	pop    r14
  409b71:	41 5d                	pop    r13
  409b73:	5d                   	pop    rbp
  409b74:	c3                   	ret    
  409b75:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  409b7c:	00 00 00 00 

0000000000409b80 <__cosrt_extern_memmgr_heap_page_allocn_aligned>:
  409b80:	48 b8 f8 c2 5b 00 00 	movabs rax,0x5bc2f8
  409b87:	00 00 00 
  409b8a:	ff 10                	call   QWORD PTR [rax]
  409b8c:	c3                   	ret    
  409b8d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000409b90 <__cosrt_fast_callgate_memmgr_heap_page_allocn_aligned>:
  409b90:	55                   	push   rbp
  409b91:	41 55                	push   r13
  409b93:	41 56                	push   r14
  409b95:	41 57                	push   r15
  409b97:	49 89 c8             	mov    r8,rcx
  409b9a:	49 89 d1             	mov    r9,rdx
  409b9d:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  409ba4:	be ad de 
  409ba7:	0f 01 f9             	rdtscp 
  409baa:	48 89 c8             	mov    rax,rcx
  409bad:	48 25 ff 0f 00 00    	and    rax,0xfff
  409bb3:	48 89 e2             	mov    rdx,rsp
  409bb6:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  409bbd:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  409bc4:	00 
  409bc5:	48 c1 e0 10          	shl    rax,0x10
  409bc9:	49 09 c5             	or     r13,rax
  409bcc:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  409bd3:	7f 00 00 
  409bd6:	4c 89 e8             	mov    rax,r13
  409bd9:	48 25 ff ff 00 00    	and    rax,0xffff
  409bdf:	48 c1 e0 08          	shl    rax,0x8
  409be3:	49 01 c6             	add    r14,rax
  409be6:	b9 01 00 00 00       	mov    ecx,0x1
  409beb:	01 c9                	add    ecx,ecx
  409bed:	b8 03 00 00 00       	mov    eax,0x3
  409bf2:	d3 e0                	shl    eax,cl
  409bf4:	f7 d0                	not    eax
  409bf6:	83 e0 fc             	and    eax,0xfffffffc
  409bf9:	48 31 c9             	xor    rcx,rcx
  409bfc:	48 31 d2             	xor    rdx,rdx
  409bff:	0f 01 ef             	wrpkru 
  409c02:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  409c05:	48 83 c2 01          	add    rdx,0x1
  409c09:	48 c1 e2 04          	shl    rdx,0x4
  409c0d:	4c 01 f2             	add    rdx,r14
  409c10:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  409c17:	45 23 01 
  409c1a:	48 89 02             	mov    QWORD PTR [rdx],rax
  409c1d:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  409c21:	49 8b 06             	mov    rax,QWORD PTR [r14]
  409c24:	48 83 c0 01          	add    rax,0x1
  409c28:	49 89 06             	mov    QWORD PTR [r14],rax
  409c2b:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  409c30:	01 c9                	add    ecx,ecx
  409c32:	b8 03 00 00 00       	mov    eax,0x3
  409c37:	d3 e0                	shl    eax,cl
  409c39:	f7 d0                	not    eax
  409c3b:	83 e0 fc             	and    eax,0xfffffffc
  409c3e:	48 31 c9             	xor    rcx,rcx
  409c41:	48 31 d2             	xor    rdx,rdx
  409c44:	0f 01 ef             	wrpkru 
  409c47:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  409c4e:	45 23 01 
  409c51:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409c58:	be ad de 
  409c5b:	49 39 c7             	cmp    r15,rax
  409c5e:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  409c65:	12 12 12 
  409c68:	48 b9 74 9c 40 00 00 	movabs rcx,0x409c74
  409c6f:	00 00 00 
  409c72:	ff e0                	jmp    rax

0000000000409c74 <srv_call_ret_memmgr_heap_page_allocn_aligned>:
  409c74:	49 89 c0             	mov    r8,rax
  409c77:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  409c7e:	be ad de 
  409c81:	48 89 e2             	mov    rdx,rsp
  409c84:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  409c8b:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  409c92:	00 
  409c93:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  409c9a:	7f 00 00 
  409c9d:	4c 89 e8             	mov    rax,r13
  409ca0:	48 25 ff ff 00 00    	and    rax,0xffff
  409ca6:	48 c1 e0 08          	shl    rax,0x8
  409caa:	49 01 c6             	add    r14,rax
  409cad:	b9 01 00 00 00       	mov    ecx,0x1
  409cb2:	01 c9                	add    ecx,ecx
  409cb4:	b8 03 00 00 00       	mov    eax,0x3
  409cb9:	d3 e0                	shl    eax,cl
  409cbb:	f7 d0                	not    eax
  409cbd:	83 e0 fc             	and    eax,0xfffffffc
  409cc0:	48 31 c9             	xor    rcx,rcx
  409cc3:	48 31 d2             	xor    rdx,rdx
  409cc6:	0f 01 ef             	wrpkru 
  409cc9:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  409ccc:	48 c1 e2 04          	shl    rdx,0x4
  409cd0:	4c 01 f2             	add    rdx,r14
  409cd3:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  409cd7:	49 8b 06             	mov    rax,QWORD PTR [r14]
  409cda:	48 83 e8 01          	sub    rax,0x1
  409cde:	49 89 06             	mov    QWORD PTR [r14],rax
  409ce1:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  409ce6:	01 c9                	add    ecx,ecx
  409ce8:	b8 03 00 00 00       	mov    eax,0x3
  409ced:	d3 e0                	shl    eax,cl
  409cef:	f7 d0                	not    eax
  409cf1:	83 e0 fc             	and    eax,0xfffffffc
  409cf4:	48 31 c9             	xor    rcx,rcx
  409cf7:	48 31 d2             	xor    rdx,rdx
  409cfa:	0f 01 ef             	wrpkru 
  409cfd:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409d04:	be ad de 
  409d07:	49 39 c7             	cmp    r15,rax
  409d0a:	4c 89 c0             	mov    rax,r8
  409d0d:	41 5f                	pop    r15
  409d0f:	41 5e                	pop    r14
  409d11:	41 5d                	pop    r13
  409d13:	5d                   	pop    rbp
  409d14:	c3                   	ret    
  409d15:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  409d1c:	00 00 00 00 

0000000000409d20 <__cosrt_extern_memmgr_virt_to_phys>:
  409d20:	48 b8 10 c3 5b 00 00 	movabs rax,0x5bc310
  409d27:	00 00 00 
  409d2a:	ff 10                	call   QWORD PTR [rax]
  409d2c:	c3                   	ret    
  409d2d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000409d30 <__cosrt_fast_callgate_memmgr_virt_to_phys>:
  409d30:	55                   	push   rbp
  409d31:	41 55                	push   r13
  409d33:	41 56                	push   r14
  409d35:	41 57                	push   r15
  409d37:	49 89 c8             	mov    r8,rcx
  409d3a:	49 89 d1             	mov    r9,rdx
  409d3d:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  409d44:	be ad de 
  409d47:	0f 01 f9             	rdtscp 
  409d4a:	48 89 c8             	mov    rax,rcx
  409d4d:	48 25 ff 0f 00 00    	and    rax,0xfff
  409d53:	48 89 e2             	mov    rdx,rsp
  409d56:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  409d5d:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  409d64:	00 
  409d65:	48 c1 e0 10          	shl    rax,0x10
  409d69:	49 09 c5             	or     r13,rax
  409d6c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  409d73:	7f 00 00 
  409d76:	4c 89 e8             	mov    rax,r13
  409d79:	48 25 ff ff 00 00    	and    rax,0xffff
  409d7f:	48 c1 e0 08          	shl    rax,0x8
  409d83:	49 01 c6             	add    r14,rax
  409d86:	b9 01 00 00 00       	mov    ecx,0x1
  409d8b:	01 c9                	add    ecx,ecx
  409d8d:	b8 03 00 00 00       	mov    eax,0x3
  409d92:	d3 e0                	shl    eax,cl
  409d94:	f7 d0                	not    eax
  409d96:	83 e0 fc             	and    eax,0xfffffffc
  409d99:	48 31 c9             	xor    rcx,rcx
  409d9c:	48 31 d2             	xor    rdx,rdx
  409d9f:	0f 01 ef             	wrpkru 
  409da2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  409da5:	48 83 c2 01          	add    rdx,0x1
  409da9:	48 c1 e2 04          	shl    rdx,0x4
  409dad:	4c 01 f2             	add    rdx,r14
  409db0:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  409db7:	45 23 01 
  409dba:	48 89 02             	mov    QWORD PTR [rdx],rax
  409dbd:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  409dc1:	49 8b 06             	mov    rax,QWORD PTR [r14]
  409dc4:	48 83 c0 01          	add    rax,0x1
  409dc8:	49 89 06             	mov    QWORD PTR [r14],rax
  409dcb:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  409dd0:	01 c9                	add    ecx,ecx
  409dd2:	b8 03 00 00 00       	mov    eax,0x3
  409dd7:	d3 e0                	shl    eax,cl
  409dd9:	f7 d0                	not    eax
  409ddb:	83 e0 fc             	and    eax,0xfffffffc
  409dde:	48 31 c9             	xor    rcx,rcx
  409de1:	48 31 d2             	xor    rdx,rdx
  409de4:	0f 01 ef             	wrpkru 
  409de7:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  409dee:	45 23 01 
  409df1:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409df8:	be ad de 
  409dfb:	49 39 c7             	cmp    r15,rax
  409dfe:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  409e05:	12 12 12 
  409e08:	48 b9 14 9e 40 00 00 	movabs rcx,0x409e14
  409e0f:	00 00 00 
  409e12:	ff e0                	jmp    rax

0000000000409e14 <srv_call_ret_memmgr_virt_to_phys>:
  409e14:	49 89 c0             	mov    r8,rax
  409e17:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  409e1e:	be ad de 
  409e21:	48 89 e2             	mov    rdx,rsp
  409e24:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  409e2b:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  409e32:	00 
  409e33:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  409e3a:	7f 00 00 
  409e3d:	4c 89 e8             	mov    rax,r13
  409e40:	48 25 ff ff 00 00    	and    rax,0xffff
  409e46:	48 c1 e0 08          	shl    rax,0x8
  409e4a:	49 01 c6             	add    r14,rax
  409e4d:	b9 01 00 00 00       	mov    ecx,0x1
  409e52:	01 c9                	add    ecx,ecx
  409e54:	b8 03 00 00 00       	mov    eax,0x3
  409e59:	d3 e0                	shl    eax,cl
  409e5b:	f7 d0                	not    eax
  409e5d:	83 e0 fc             	and    eax,0xfffffffc
  409e60:	48 31 c9             	xor    rcx,rcx
  409e63:	48 31 d2             	xor    rdx,rdx
  409e66:	0f 01 ef             	wrpkru 
  409e69:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  409e6c:	48 c1 e2 04          	shl    rdx,0x4
  409e70:	4c 01 f2             	add    rdx,r14
  409e73:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  409e77:	49 8b 06             	mov    rax,QWORD PTR [r14]
  409e7a:	48 83 e8 01          	sub    rax,0x1
  409e7e:	49 89 06             	mov    QWORD PTR [r14],rax
  409e81:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  409e86:	01 c9                	add    ecx,ecx
  409e88:	b8 03 00 00 00       	mov    eax,0x3
  409e8d:	d3 e0                	shl    eax,cl
  409e8f:	f7 d0                	not    eax
  409e91:	83 e0 fc             	and    eax,0xfffffffc
  409e94:	48 31 c9             	xor    rcx,rcx
  409e97:	48 31 d2             	xor    rdx,rdx
  409e9a:	0f 01 ef             	wrpkru 
  409e9d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409ea4:	be ad de 
  409ea7:	49 39 c7             	cmp    r15,rax
  409eaa:	4c 89 c0             	mov    rax,r8
  409ead:	41 5f                	pop    r15
  409eaf:	41 5e                	pop    r14
  409eb1:	41 5d                	pop    r13
  409eb3:	5d                   	pop    rbp
  409eb4:	c3                   	ret    
  409eb5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  409ebc:	00 00 00 00 

0000000000409ec0 <__cosrt_extern_memmgr_map_phys_to_virt>:
  409ec0:	48 b8 28 c3 5b 00 00 	movabs rax,0x5bc328
  409ec7:	00 00 00 
  409eca:	ff 10                	call   QWORD PTR [rax]
  409ecc:	c3                   	ret    
  409ecd:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000409ed0 <__cosrt_fast_callgate_memmgr_map_phys_to_virt>:
  409ed0:	55                   	push   rbp
  409ed1:	41 55                	push   r13
  409ed3:	41 56                	push   r14
  409ed5:	41 57                	push   r15
  409ed7:	49 89 c8             	mov    r8,rcx
  409eda:	49 89 d1             	mov    r9,rdx
  409edd:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  409ee4:	be ad de 
  409ee7:	0f 01 f9             	rdtscp 
  409eea:	48 89 c8             	mov    rax,rcx
  409eed:	48 25 ff 0f 00 00    	and    rax,0xfff
  409ef3:	48 89 e2             	mov    rdx,rsp
  409ef6:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  409efd:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  409f04:	00 
  409f05:	48 c1 e0 10          	shl    rax,0x10
  409f09:	49 09 c5             	or     r13,rax
  409f0c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  409f13:	7f 00 00 
  409f16:	4c 89 e8             	mov    rax,r13
  409f19:	48 25 ff ff 00 00    	and    rax,0xffff
  409f1f:	48 c1 e0 08          	shl    rax,0x8
  409f23:	49 01 c6             	add    r14,rax
  409f26:	b9 01 00 00 00       	mov    ecx,0x1
  409f2b:	01 c9                	add    ecx,ecx
  409f2d:	b8 03 00 00 00       	mov    eax,0x3
  409f32:	d3 e0                	shl    eax,cl
  409f34:	f7 d0                	not    eax
  409f36:	83 e0 fc             	and    eax,0xfffffffc
  409f39:	48 31 c9             	xor    rcx,rcx
  409f3c:	48 31 d2             	xor    rdx,rdx
  409f3f:	0f 01 ef             	wrpkru 
  409f42:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  409f45:	48 83 c2 01          	add    rdx,0x1
  409f49:	48 c1 e2 04          	shl    rdx,0x4
  409f4d:	4c 01 f2             	add    rdx,r14
  409f50:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  409f57:	45 23 01 
  409f5a:	48 89 02             	mov    QWORD PTR [rdx],rax
  409f5d:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  409f61:	49 8b 06             	mov    rax,QWORD PTR [r14]
  409f64:	48 83 c0 01          	add    rax,0x1
  409f68:	49 89 06             	mov    QWORD PTR [r14],rax
  409f6b:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  409f70:	01 c9                	add    ecx,ecx
  409f72:	b8 03 00 00 00       	mov    eax,0x3
  409f77:	d3 e0                	shl    eax,cl
  409f79:	f7 d0                	not    eax
  409f7b:	83 e0 fc             	and    eax,0xfffffffc
  409f7e:	48 31 c9             	xor    rcx,rcx
  409f81:	48 31 d2             	xor    rdx,rdx
  409f84:	0f 01 ef             	wrpkru 
  409f87:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  409f8e:	45 23 01 
  409f91:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  409f98:	be ad de 
  409f9b:	49 39 c7             	cmp    r15,rax
  409f9e:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  409fa5:	12 12 12 
  409fa8:	48 b9 b4 9f 40 00 00 	movabs rcx,0x409fb4
  409faf:	00 00 00 
  409fb2:	ff e0                	jmp    rax

0000000000409fb4 <srv_call_ret_memmgr_map_phys_to_virt>:
  409fb4:	49 89 c0             	mov    r8,rax
  409fb7:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  409fbe:	be ad de 
  409fc1:	48 89 e2             	mov    rdx,rsp
  409fc4:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  409fcb:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  409fd2:	00 
  409fd3:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  409fda:	7f 00 00 
  409fdd:	4c 89 e8             	mov    rax,r13
  409fe0:	48 25 ff ff 00 00    	and    rax,0xffff
  409fe6:	48 c1 e0 08          	shl    rax,0x8
  409fea:	49 01 c6             	add    r14,rax
  409fed:	b9 01 00 00 00       	mov    ecx,0x1
  409ff2:	01 c9                	add    ecx,ecx
  409ff4:	b8 03 00 00 00       	mov    eax,0x3
  409ff9:	d3 e0                	shl    eax,cl
  409ffb:	f7 d0                	not    eax
  409ffd:	83 e0 fc             	and    eax,0xfffffffc
  40a000:	48 31 c9             	xor    rcx,rcx
  40a003:	48 31 d2             	xor    rdx,rdx
  40a006:	0f 01 ef             	wrpkru 
  40a009:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40a00c:	48 c1 e2 04          	shl    rdx,0x4
  40a010:	4c 01 f2             	add    rdx,r14
  40a013:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  40a017:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40a01a:	48 83 e8 01          	sub    rax,0x1
  40a01e:	49 89 06             	mov    QWORD PTR [r14],rax
  40a021:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40a026:	01 c9                	add    ecx,ecx
  40a028:	b8 03 00 00 00       	mov    eax,0x3
  40a02d:	d3 e0                	shl    eax,cl
  40a02f:	f7 d0                	not    eax
  40a031:	83 e0 fc             	and    eax,0xfffffffc
  40a034:	48 31 c9             	xor    rcx,rcx
  40a037:	48 31 d2             	xor    rdx,rdx
  40a03a:	0f 01 ef             	wrpkru 
  40a03d:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40a044:	be ad de 
  40a047:	49 39 c7             	cmp    r15,rax
  40a04a:	4c 89 c0             	mov    rax,r8
  40a04d:	41 5f                	pop    r15
  40a04f:	41 5e                	pop    r14
  40a051:	41 5d                	pop    r13
  40a053:	5d                   	pop    rbp
  40a054:	c3                   	ret    
  40a055:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a05c:	00 00 00 00 

000000000040a060 <__cosrt_extern_memmgr_shared_page_allocn>:
  40a060:	48 b8 40 c3 5b 00 00 	movabs rax,0x5bc340
  40a067:	00 00 00 
  40a06a:	ff 10                	call   QWORD PTR [rax]
  40a06c:	c3                   	ret    
  40a06d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040a070 <__cosrt_fast_callgate_memmgr_shared_page_allocn>:
  40a070:	55                   	push   rbp
  40a071:	53                   	push   rbx
  40a072:	41 54                	push   r12
  40a074:	41 55                	push   r13
  40a076:	41 56                	push   r14
  40a078:	41 57                	push   r15
  40a07a:	4d 89 c4             	mov    r12,r8
  40a07d:	4c 89 cb             	mov    rbx,r9
  40a080:	49 89 c8             	mov    r8,rcx
  40a083:	49 89 d1             	mov    r9,rdx
  40a086:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40a08d:	be ad de 
  40a090:	0f 01 f9             	rdtscp 
  40a093:	48 89 ca             	mov    rdx,rcx
  40a096:	48 25 ff 0f 00 00    	and    rax,0xfff
  40a09c:	48 89 e2             	mov    rdx,rsp
  40a09f:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40a0a6:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40a0ad:	00 
  40a0ae:	48 c1 e0 10          	shl    rax,0x10
  40a0b2:	49 09 c5             	or     r13,rax
  40a0b5:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40a0bc:	7f 00 00 
  40a0bf:	4c 89 e8             	mov    rax,r13
  40a0c2:	48 25 ff ff 00 00    	and    rax,0xffff
  40a0c8:	48 c1 e0 08          	shl    rax,0x8
  40a0cc:	49 01 c6             	add    r14,rax
  40a0cf:	b9 01 00 00 00       	mov    ecx,0x1
  40a0d4:	01 c9                	add    ecx,ecx
  40a0d6:	b8 03 00 00 00       	mov    eax,0x3
  40a0db:	d3 e0                	shl    eax,cl
  40a0dd:	f7 d0                	not    eax
  40a0df:	83 e0 fc             	and    eax,0xfffffffc
  40a0e2:	48 31 c9             	xor    rcx,rcx
  40a0e5:	48 31 d2             	xor    rdx,rdx
  40a0e8:	0f 01 ef             	wrpkru 
  40a0eb:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40a0ee:	48 83 c2 01          	add    rdx,0x1
  40a0f2:	48 c1 e2 04          	shl    rdx,0x4
  40a0f6:	4c 01 f2             	add    rdx,r14
  40a0f9:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  40a100:	45 23 01 
  40a103:	48 89 02             	mov    QWORD PTR [rdx],rax
  40a106:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  40a10a:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40a10d:	48 83 c0 01          	add    rax,0x1
  40a111:	49 89 06             	mov    QWORD PTR [r14],rax
  40a114:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40a119:	01 c9                	add    ecx,ecx
  40a11b:	b8 03 00 00 00       	mov    eax,0x3
  40a120:	d3 e0                	shl    eax,cl
  40a122:	f7 d0                	not    eax
  40a124:	83 e0 fc             	and    eax,0xfffffffc
  40a127:	48 31 c9             	xor    rcx,rcx
  40a12a:	48 31 d2             	xor    rdx,rdx
  40a12d:	0f 01 ef             	wrpkru 
  40a130:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  40a137:	45 23 01 
  40a13a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40a141:	be ad de 
  40a144:	49 39 c7             	cmp    r15,rax
  40a147:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  40a14e:	12 12 12 
  40a151:	48 b9 5d a1 40 00 00 	movabs rcx,0x40a15d
  40a158:	00 00 00 
  40a15b:	ff e0                	jmp    rax

000000000040a15d <srv_call_ret_memmgr_shared_page_allocn>:
  40a15d:	49 89 c0             	mov    r8,rax
  40a160:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40a167:	be ad de 
  40a16a:	48 89 e2             	mov    rdx,rsp
  40a16d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40a174:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40a17b:	00 
  40a17c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40a183:	7f 00 00 
  40a186:	4c 89 e8             	mov    rax,r13
  40a189:	48 25 ff ff 00 00    	and    rax,0xffff
  40a18f:	48 c1 e0 08          	shl    rax,0x8
  40a193:	49 01 c6             	add    r14,rax
  40a196:	b9 01 00 00 00       	mov    ecx,0x1
  40a19b:	01 c9                	add    ecx,ecx
  40a19d:	b8 03 00 00 00       	mov    eax,0x3
  40a1a2:	d3 e0                	shl    eax,cl
  40a1a4:	f7 d0                	not    eax
  40a1a6:	83 e0 fc             	and    eax,0xfffffffc
  40a1a9:	48 31 c9             	xor    rcx,rcx
  40a1ac:	48 31 d2             	xor    rdx,rdx
  40a1af:	0f 01 ef             	wrpkru 
  40a1b2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40a1b5:	48 c1 e2 04          	shl    rdx,0x4
  40a1b9:	4c 01 f2             	add    rdx,r14
  40a1bc:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  40a1c0:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40a1c3:	48 83 e8 01          	sub    rax,0x1
  40a1c7:	49 89 06             	mov    QWORD PTR [r14],rax
  40a1ca:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40a1cf:	01 c9                	add    ecx,ecx
  40a1d1:	b8 03 00 00 00       	mov    eax,0x3
  40a1d6:	d3 e0                	shl    eax,cl
  40a1d8:	f7 d0                	not    eax
  40a1da:	83 e0 fc             	and    eax,0xfffffffc
  40a1dd:	48 31 c9             	xor    rcx,rcx
  40a1e0:	48 31 d2             	xor    rdx,rdx
  40a1e3:	0f 01 ef             	wrpkru 
  40a1e6:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40a1ed:	be ad de 
  40a1f0:	49 39 c7             	cmp    r15,rax
  40a1f3:	4c 89 c0             	mov    rax,r8
  40a1f6:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  40a1fa:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  40a1fd:	41 5f                	pop    r15
  40a1ff:	41 5e                	pop    r14
  40a201:	41 5d                	pop    r13
  40a203:	41 5c                	pop    r12
  40a205:	5b                   	pop    rbx
  40a206:	5d                   	pop    rbp
  40a207:	c3                   	ret    
  40a208:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40a20f:	00 

000000000040a210 <__cosrt_extern_memmgr_shared_page_allocn_aligned>:
  40a210:	48 b8 58 c3 5b 00 00 	movabs rax,0x5bc358
  40a217:	00 00 00 
  40a21a:	ff 10                	call   QWORD PTR [rax]
  40a21c:	c3                   	ret    
  40a21d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040a220 <__cosrt_fast_callgate_memmgr_shared_page_allocn_aligned>:
  40a220:	55                   	push   rbp
  40a221:	53                   	push   rbx
  40a222:	41 54                	push   r12
  40a224:	41 55                	push   r13
  40a226:	41 56                	push   r14
  40a228:	41 57                	push   r15
  40a22a:	4d 89 c4             	mov    r12,r8
  40a22d:	4c 89 cb             	mov    rbx,r9
  40a230:	49 89 c8             	mov    r8,rcx
  40a233:	49 89 d1             	mov    r9,rdx
  40a236:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40a23d:	be ad de 
  40a240:	0f 01 f9             	rdtscp 
  40a243:	48 89 ca             	mov    rdx,rcx
  40a246:	48 25 ff 0f 00 00    	and    rax,0xfff
  40a24c:	48 89 e2             	mov    rdx,rsp
  40a24f:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40a256:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40a25d:	00 
  40a25e:	48 c1 e0 10          	shl    rax,0x10
  40a262:	49 09 c5             	or     r13,rax
  40a265:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40a26c:	7f 00 00 
  40a26f:	4c 89 e8             	mov    rax,r13
  40a272:	48 25 ff ff 00 00    	and    rax,0xffff
  40a278:	48 c1 e0 08          	shl    rax,0x8
  40a27c:	49 01 c6             	add    r14,rax
  40a27f:	b9 01 00 00 00       	mov    ecx,0x1
  40a284:	01 c9                	add    ecx,ecx
  40a286:	b8 03 00 00 00       	mov    eax,0x3
  40a28b:	d3 e0                	shl    eax,cl
  40a28d:	f7 d0                	not    eax
  40a28f:	83 e0 fc             	and    eax,0xfffffffc
  40a292:	48 31 c9             	xor    rcx,rcx
  40a295:	48 31 d2             	xor    rdx,rdx
  40a298:	0f 01 ef             	wrpkru 
  40a29b:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40a29e:	48 83 c2 01          	add    rdx,0x1
  40a2a2:	48 c1 e2 04          	shl    rdx,0x4
  40a2a6:	4c 01 f2             	add    rdx,r14
  40a2a9:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  40a2b0:	45 23 01 
  40a2b3:	48 89 02             	mov    QWORD PTR [rdx],rax
  40a2b6:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  40a2ba:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40a2bd:	48 83 c0 01          	add    rax,0x1
  40a2c1:	49 89 06             	mov    QWORD PTR [r14],rax
  40a2c4:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40a2c9:	01 c9                	add    ecx,ecx
  40a2cb:	b8 03 00 00 00       	mov    eax,0x3
  40a2d0:	d3 e0                	shl    eax,cl
  40a2d2:	f7 d0                	not    eax
  40a2d4:	83 e0 fc             	and    eax,0xfffffffc
  40a2d7:	48 31 c9             	xor    rcx,rcx
  40a2da:	48 31 d2             	xor    rdx,rdx
  40a2dd:	0f 01 ef             	wrpkru 
  40a2e0:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  40a2e7:	45 23 01 
  40a2ea:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40a2f1:	be ad de 
  40a2f4:	49 39 c7             	cmp    r15,rax
  40a2f7:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  40a2fe:	12 12 12 
  40a301:	48 b9 0d a3 40 00 00 	movabs rcx,0x40a30d
  40a308:	00 00 00 
  40a30b:	ff e0                	jmp    rax

000000000040a30d <srv_call_ret_memmgr_shared_page_allocn_aligned>:
  40a30d:	49 89 c0             	mov    r8,rax
  40a310:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40a317:	be ad de 
  40a31a:	48 89 e2             	mov    rdx,rsp
  40a31d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40a324:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40a32b:	00 
  40a32c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40a333:	7f 00 00 
  40a336:	4c 89 e8             	mov    rax,r13
  40a339:	48 25 ff ff 00 00    	and    rax,0xffff
  40a33f:	48 c1 e0 08          	shl    rax,0x8
  40a343:	49 01 c6             	add    r14,rax
  40a346:	b9 01 00 00 00       	mov    ecx,0x1
  40a34b:	01 c9                	add    ecx,ecx
  40a34d:	b8 03 00 00 00       	mov    eax,0x3
  40a352:	d3 e0                	shl    eax,cl
  40a354:	f7 d0                	not    eax
  40a356:	83 e0 fc             	and    eax,0xfffffffc
  40a359:	48 31 c9             	xor    rcx,rcx
  40a35c:	48 31 d2             	xor    rdx,rdx
  40a35f:	0f 01 ef             	wrpkru 
  40a362:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40a365:	48 c1 e2 04          	shl    rdx,0x4
  40a369:	4c 01 f2             	add    rdx,r14
  40a36c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  40a370:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40a373:	48 83 e8 01          	sub    rax,0x1
  40a377:	49 89 06             	mov    QWORD PTR [r14],rax
  40a37a:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40a37f:	01 c9                	add    ecx,ecx
  40a381:	b8 03 00 00 00       	mov    eax,0x3
  40a386:	d3 e0                	shl    eax,cl
  40a388:	f7 d0                	not    eax
  40a38a:	83 e0 fc             	and    eax,0xfffffffc
  40a38d:	48 31 c9             	xor    rcx,rcx
  40a390:	48 31 d2             	xor    rdx,rdx
  40a393:	0f 01 ef             	wrpkru 
  40a396:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40a39d:	be ad de 
  40a3a0:	49 39 c7             	cmp    r15,rax
  40a3a3:	4c 89 c0             	mov    rax,r8
  40a3a6:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  40a3aa:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  40a3ad:	41 5f                	pop    r15
  40a3af:	41 5e                	pop    r14
  40a3b1:	41 5d                	pop    r13
  40a3b3:	41 5c                	pop    r12
  40a3b5:	5b                   	pop    rbx
  40a3b6:	5d                   	pop    rbp
  40a3b7:	c3                   	ret    
  40a3b8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40a3bf:	00 

000000000040a3c0 <__cosrt_extern_memmgr_shared_page_map>:
  40a3c0:	48 b8 70 c3 5b 00 00 	movabs rax,0x5bc370
  40a3c7:	00 00 00 
  40a3ca:	ff 10                	call   QWORD PTR [rax]
  40a3cc:	c3                   	ret    
  40a3cd:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040a3d0 <__cosrt_fast_callgate_memmgr_shared_page_map>:
  40a3d0:	55                   	push   rbp
  40a3d1:	53                   	push   rbx
  40a3d2:	41 54                	push   r12
  40a3d4:	41 55                	push   r13
  40a3d6:	41 56                	push   r14
  40a3d8:	41 57                	push   r15
  40a3da:	4d 89 c4             	mov    r12,r8
  40a3dd:	4c 89 cb             	mov    rbx,r9
  40a3e0:	49 89 c8             	mov    r8,rcx
  40a3e3:	49 89 d1             	mov    r9,rdx
  40a3e6:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40a3ed:	be ad de 
  40a3f0:	0f 01 f9             	rdtscp 
  40a3f3:	48 89 ca             	mov    rdx,rcx
  40a3f6:	48 25 ff 0f 00 00    	and    rax,0xfff
  40a3fc:	48 89 e2             	mov    rdx,rsp
  40a3ff:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40a406:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40a40d:	00 
  40a40e:	48 c1 e0 10          	shl    rax,0x10
  40a412:	49 09 c5             	or     r13,rax
  40a415:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40a41c:	7f 00 00 
  40a41f:	4c 89 e8             	mov    rax,r13
  40a422:	48 25 ff ff 00 00    	and    rax,0xffff
  40a428:	48 c1 e0 08          	shl    rax,0x8
  40a42c:	49 01 c6             	add    r14,rax
  40a42f:	b9 01 00 00 00       	mov    ecx,0x1
  40a434:	01 c9                	add    ecx,ecx
  40a436:	b8 03 00 00 00       	mov    eax,0x3
  40a43b:	d3 e0                	shl    eax,cl
  40a43d:	f7 d0                	not    eax
  40a43f:	83 e0 fc             	and    eax,0xfffffffc
  40a442:	48 31 c9             	xor    rcx,rcx
  40a445:	48 31 d2             	xor    rdx,rdx
  40a448:	0f 01 ef             	wrpkru 
  40a44b:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40a44e:	48 83 c2 01          	add    rdx,0x1
  40a452:	48 c1 e2 04          	shl    rdx,0x4
  40a456:	4c 01 f2             	add    rdx,r14
  40a459:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  40a460:	45 23 01 
  40a463:	48 89 02             	mov    QWORD PTR [rdx],rax
  40a466:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  40a46a:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40a46d:	48 83 c0 01          	add    rax,0x1
  40a471:	49 89 06             	mov    QWORD PTR [r14],rax
  40a474:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40a479:	01 c9                	add    ecx,ecx
  40a47b:	b8 03 00 00 00       	mov    eax,0x3
  40a480:	d3 e0                	shl    eax,cl
  40a482:	f7 d0                	not    eax
  40a484:	83 e0 fc             	and    eax,0xfffffffc
  40a487:	48 31 c9             	xor    rcx,rcx
  40a48a:	48 31 d2             	xor    rdx,rdx
  40a48d:	0f 01 ef             	wrpkru 
  40a490:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  40a497:	45 23 01 
  40a49a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40a4a1:	be ad de 
  40a4a4:	49 39 c7             	cmp    r15,rax
  40a4a7:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  40a4ae:	12 12 12 
  40a4b1:	48 b9 bd a4 40 00 00 	movabs rcx,0x40a4bd
  40a4b8:	00 00 00 
  40a4bb:	ff e0                	jmp    rax

000000000040a4bd <srv_call_ret_memmgr_shared_page_map>:
  40a4bd:	49 89 c0             	mov    r8,rax
  40a4c0:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40a4c7:	be ad de 
  40a4ca:	48 89 e2             	mov    rdx,rsp
  40a4cd:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40a4d4:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40a4db:	00 
  40a4dc:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40a4e3:	7f 00 00 
  40a4e6:	4c 89 e8             	mov    rax,r13
  40a4e9:	48 25 ff ff 00 00    	and    rax,0xffff
  40a4ef:	48 c1 e0 08          	shl    rax,0x8
  40a4f3:	49 01 c6             	add    r14,rax
  40a4f6:	b9 01 00 00 00       	mov    ecx,0x1
  40a4fb:	01 c9                	add    ecx,ecx
  40a4fd:	b8 03 00 00 00       	mov    eax,0x3
  40a502:	d3 e0                	shl    eax,cl
  40a504:	f7 d0                	not    eax
  40a506:	83 e0 fc             	and    eax,0xfffffffc
  40a509:	48 31 c9             	xor    rcx,rcx
  40a50c:	48 31 d2             	xor    rdx,rdx
  40a50f:	0f 01 ef             	wrpkru 
  40a512:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40a515:	48 c1 e2 04          	shl    rdx,0x4
  40a519:	4c 01 f2             	add    rdx,r14
  40a51c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  40a520:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40a523:	48 83 e8 01          	sub    rax,0x1
  40a527:	49 89 06             	mov    QWORD PTR [r14],rax
  40a52a:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40a52f:	01 c9                	add    ecx,ecx
  40a531:	b8 03 00 00 00       	mov    eax,0x3
  40a536:	d3 e0                	shl    eax,cl
  40a538:	f7 d0                	not    eax
  40a53a:	83 e0 fc             	and    eax,0xfffffffc
  40a53d:	48 31 c9             	xor    rcx,rcx
  40a540:	48 31 d2             	xor    rdx,rdx
  40a543:	0f 01 ef             	wrpkru 
  40a546:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40a54d:	be ad de 
  40a550:	49 39 c7             	cmp    r15,rax
  40a553:	4c 89 c0             	mov    rax,r8
  40a556:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  40a55a:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  40a55d:	41 5f                	pop    r15
  40a55f:	41 5e                	pop    r14
  40a561:	41 5d                	pop    r13
  40a563:	41 5c                	pop    r12
  40a565:	5b                   	pop    rbx
  40a566:	5d                   	pop    rbp
  40a567:	c3                   	ret    
  40a568:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40a56f:	00 

000000000040a570 <__cosrt_extern_memmgr_shared_page_map_aligned>:
  40a570:	48 b8 88 c3 5b 00 00 	movabs rax,0x5bc388
  40a577:	00 00 00 
  40a57a:	ff 10                	call   QWORD PTR [rax]
  40a57c:	c3                   	ret    
  40a57d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040a580 <__cosrt_fast_callgate_memmgr_shared_page_map_aligned>:
  40a580:	55                   	push   rbp
  40a581:	53                   	push   rbx
  40a582:	41 54                	push   r12
  40a584:	41 55                	push   r13
  40a586:	41 56                	push   r14
  40a588:	41 57                	push   r15
  40a58a:	4d 89 c4             	mov    r12,r8
  40a58d:	4c 89 cb             	mov    rbx,r9
  40a590:	49 89 c8             	mov    r8,rcx
  40a593:	49 89 d1             	mov    r9,rdx
  40a596:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40a59d:	be ad de 
  40a5a0:	0f 01 f9             	rdtscp 
  40a5a3:	48 89 ca             	mov    rdx,rcx
  40a5a6:	48 25 ff 0f 00 00    	and    rax,0xfff
  40a5ac:	48 89 e2             	mov    rdx,rsp
  40a5af:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40a5b6:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40a5bd:	00 
  40a5be:	48 c1 e0 10          	shl    rax,0x10
  40a5c2:	49 09 c5             	or     r13,rax
  40a5c5:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40a5cc:	7f 00 00 
  40a5cf:	4c 89 e8             	mov    rax,r13
  40a5d2:	48 25 ff ff 00 00    	and    rax,0xffff
  40a5d8:	48 c1 e0 08          	shl    rax,0x8
  40a5dc:	49 01 c6             	add    r14,rax
  40a5df:	b9 01 00 00 00       	mov    ecx,0x1
  40a5e4:	01 c9                	add    ecx,ecx
  40a5e6:	b8 03 00 00 00       	mov    eax,0x3
  40a5eb:	d3 e0                	shl    eax,cl
  40a5ed:	f7 d0                	not    eax
  40a5ef:	83 e0 fc             	and    eax,0xfffffffc
  40a5f2:	48 31 c9             	xor    rcx,rcx
  40a5f5:	48 31 d2             	xor    rdx,rdx
  40a5f8:	0f 01 ef             	wrpkru 
  40a5fb:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40a5fe:	48 83 c2 01          	add    rdx,0x1
  40a602:	48 c1 e2 04          	shl    rdx,0x4
  40a606:	4c 01 f2             	add    rdx,r14
  40a609:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  40a610:	45 23 01 
  40a613:	48 89 02             	mov    QWORD PTR [rdx],rax
  40a616:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  40a61a:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40a61d:	48 83 c0 01          	add    rax,0x1
  40a621:	49 89 06             	mov    QWORD PTR [r14],rax
  40a624:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40a629:	01 c9                	add    ecx,ecx
  40a62b:	b8 03 00 00 00       	mov    eax,0x3
  40a630:	d3 e0                	shl    eax,cl
  40a632:	f7 d0                	not    eax
  40a634:	83 e0 fc             	and    eax,0xfffffffc
  40a637:	48 31 c9             	xor    rcx,rcx
  40a63a:	48 31 d2             	xor    rdx,rdx
  40a63d:	0f 01 ef             	wrpkru 
  40a640:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  40a647:	45 23 01 
  40a64a:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40a651:	be ad de 
  40a654:	49 39 c7             	cmp    r15,rax
  40a657:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  40a65e:	12 12 12 
  40a661:	48 b9 6d a6 40 00 00 	movabs rcx,0x40a66d
  40a668:	00 00 00 
  40a66b:	ff e0                	jmp    rax

000000000040a66d <srv_call_ret_memmgr_shared_page_map_aligned>:
  40a66d:	49 89 c0             	mov    r8,rax
  40a670:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40a677:	be ad de 
  40a67a:	48 89 e2             	mov    rdx,rsp
  40a67d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40a684:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40a68b:	00 
  40a68c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40a693:	7f 00 00 
  40a696:	4c 89 e8             	mov    rax,r13
  40a699:	48 25 ff ff 00 00    	and    rax,0xffff
  40a69f:	48 c1 e0 08          	shl    rax,0x8
  40a6a3:	49 01 c6             	add    r14,rax
  40a6a6:	b9 01 00 00 00       	mov    ecx,0x1
  40a6ab:	01 c9                	add    ecx,ecx
  40a6ad:	b8 03 00 00 00       	mov    eax,0x3
  40a6b2:	d3 e0                	shl    eax,cl
  40a6b4:	f7 d0                	not    eax
  40a6b6:	83 e0 fc             	and    eax,0xfffffffc
  40a6b9:	48 31 c9             	xor    rcx,rcx
  40a6bc:	48 31 d2             	xor    rdx,rdx
  40a6bf:	0f 01 ef             	wrpkru 
  40a6c2:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40a6c5:	48 c1 e2 04          	shl    rdx,0x4
  40a6c9:	4c 01 f2             	add    rdx,r14
  40a6cc:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  40a6d0:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40a6d3:	48 83 e8 01          	sub    rax,0x1
  40a6d7:	49 89 06             	mov    QWORD PTR [r14],rax
  40a6da:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40a6df:	01 c9                	add    ecx,ecx
  40a6e1:	b8 03 00 00 00       	mov    eax,0x3
  40a6e6:	d3 e0                	shl    eax,cl
  40a6e8:	f7 d0                	not    eax
  40a6ea:	83 e0 fc             	and    eax,0xfffffffc
  40a6ed:	48 31 c9             	xor    rcx,rcx
  40a6f0:	48 31 d2             	xor    rdx,rdx
  40a6f3:	0f 01 ef             	wrpkru 
  40a6f6:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40a6fd:	be ad de 
  40a700:	49 39 c7             	cmp    r15,rax
  40a703:	4c 89 c0             	mov    rax,r8
  40a706:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  40a70a:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  40a70d:	41 5f                	pop    r15
  40a70f:	41 5e                	pop    r14
  40a711:	41 5d                	pop    r13
  40a713:	41 5c                	pop    r12
  40a715:	5b                   	pop    rbx
  40a716:	5d                   	pop    rbp
  40a717:	c3                   	ret    
  40a718:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40a71f:	00 

000000000040a720 <__cosrt_extern_memmgr_shared_page_map_aligned_in_vm>:
  40a720:	48 b8 a0 c3 5b 00 00 	movabs rax,0x5bc3a0
  40a727:	00 00 00 
  40a72a:	ff 10                	call   QWORD PTR [rax]
  40a72c:	c3                   	ret    
  40a72d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040a730 <__cosrt_fast_callgate_memmgr_shared_page_map_aligned_in_vm>:
  40a730:	55                   	push   rbp
  40a731:	53                   	push   rbx
  40a732:	41 54                	push   r12
  40a734:	41 55                	push   r13
  40a736:	41 56                	push   r14
  40a738:	41 57                	push   r15
  40a73a:	4d 89 c4             	mov    r12,r8
  40a73d:	4c 89 cb             	mov    rbx,r9
  40a740:	49 89 c8             	mov    r8,rcx
  40a743:	49 89 d1             	mov    r9,rdx
  40a746:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40a74d:	be ad de 
  40a750:	0f 01 f9             	rdtscp 
  40a753:	48 89 ca             	mov    rdx,rcx
  40a756:	48 25 ff 0f 00 00    	and    rax,0xfff
  40a75c:	48 89 e2             	mov    rdx,rsp
  40a75f:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40a766:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40a76d:	00 
  40a76e:	48 c1 e0 10          	shl    rax,0x10
  40a772:	49 09 c5             	or     r13,rax
  40a775:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40a77c:	7f 00 00 
  40a77f:	4c 89 e8             	mov    rax,r13
  40a782:	48 25 ff ff 00 00    	and    rax,0xffff
  40a788:	48 c1 e0 08          	shl    rax,0x8
  40a78c:	49 01 c6             	add    r14,rax
  40a78f:	b9 01 00 00 00       	mov    ecx,0x1
  40a794:	01 c9                	add    ecx,ecx
  40a796:	b8 03 00 00 00       	mov    eax,0x3
  40a79b:	d3 e0                	shl    eax,cl
  40a79d:	f7 d0                	not    eax
  40a79f:	83 e0 fc             	and    eax,0xfffffffc
  40a7a2:	48 31 c9             	xor    rcx,rcx
  40a7a5:	48 31 d2             	xor    rdx,rdx
  40a7a8:	0f 01 ef             	wrpkru 
  40a7ab:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40a7ae:	48 83 c2 01          	add    rdx,0x1
  40a7b2:	48 c1 e2 04          	shl    rdx,0x4
  40a7b6:	4c 01 f2             	add    rdx,r14
  40a7b9:	48 b8 ef cd ab 89 67 	movabs rax,0x123456789abcdef
  40a7c0:	45 23 01 
  40a7c3:	48 89 02             	mov    QWORD PTR [rdx],rax
  40a7c6:	48 89 62 08          	mov    QWORD PTR [rdx+0x8],rsp
  40a7ca:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40a7cd:	48 83 c0 01          	add    rax,0x1
  40a7d1:	49 89 06             	mov    QWORD PTR [r14],rax
  40a7d4:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40a7d9:	01 c9                	add    ecx,ecx
  40a7db:	b8 03 00 00 00       	mov    eax,0x3
  40a7e0:	d3 e0                	shl    eax,cl
  40a7e2:	f7 d0                	not    eax
  40a7e4:	83 e0 fc             	and    eax,0xfffffffc
  40a7e7:	48 31 c9             	xor    rcx,rcx
  40a7ea:	48 31 d2             	xor    rdx,rdx
  40a7ed:	0f 01 ef             	wrpkru 
  40a7f0:	48 bd ef cd ab 89 67 	movabs rbp,0x123456789abcdef
  40a7f7:	45 23 01 
  40a7fa:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40a801:	be ad de 
  40a804:	49 39 c7             	cmp    r15,rax
  40a807:	48 b8 12 12 12 12 12 	movabs rax,0x1212121212121212
  40a80e:	12 12 12 
  40a811:	48 b9 1d a8 40 00 00 	movabs rcx,0x40a81d
  40a818:	00 00 00 
  40a81b:	ff e0                	jmp    rax

000000000040a81d <srv_call_ret_memmgr_shared_page_map_aligned_in_vm>:
  40a81d:	49 89 c0             	mov    r8,rax
  40a820:	49 bf ef be ad de ef 	movabs r15,0xdeadbeefdeadbeef
  40a827:	be ad de 
  40a82a:	48 89 e2             	mov    rdx,rsp
  40a82d:	48 81 e2 00 00 fe ff 	and    rdx,0xfffffffffffe0000
  40a834:	4c 0f b7 aa f0 ff 01 	movzx  r13,WORD PTR [rdx+0x1fff0]
  40a83b:	00 
  40a83c:	49 be 00 00 00 00 80 	movabs r14,0x7f8000000000
  40a843:	7f 00 00 
  40a846:	4c 89 e8             	mov    rax,r13
  40a849:	48 25 ff ff 00 00    	and    rax,0xffff
  40a84f:	48 c1 e0 08          	shl    rax,0x8
  40a853:	49 01 c6             	add    r14,rax
  40a856:	b9 01 00 00 00       	mov    ecx,0x1
  40a85b:	01 c9                	add    ecx,ecx
  40a85d:	b8 03 00 00 00       	mov    eax,0x3
  40a862:	d3 e0                	shl    eax,cl
  40a864:	f7 d0                	not    eax
  40a866:	83 e0 fc             	and    eax,0xfffffffc
  40a869:	48 31 c9             	xor    rcx,rcx
  40a86c:	48 31 d2             	xor    rdx,rdx
  40a86f:	0f 01 ef             	wrpkru 
  40a872:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  40a875:	48 c1 e2 04          	shl    rdx,0x4
  40a879:	4c 01 f2             	add    rdx,r14
  40a87c:	48 8b 62 08          	mov    rsp,QWORD PTR [rdx+0x8]
  40a880:	49 8b 06             	mov    rax,QWORD PTR [r14]
  40a883:	48 83 e8 01          	sub    rax,0x1
  40a887:	49 89 06             	mov    QWORD PTR [r14],rax
  40a88a:	b9 fe ff ff ff       	mov    ecx,0xfffffffe
  40a88f:	01 c9                	add    ecx,ecx
  40a891:	b8 03 00 00 00       	mov    eax,0x3
  40a896:	d3 e0                	shl    eax,cl
  40a898:	f7 d0                	not    eax
  40a89a:	83 e0 fc             	and    eax,0xfffffffc
  40a89d:	48 31 c9             	xor    rcx,rcx
  40a8a0:	48 31 d2             	xor    rdx,rdx
  40a8a3:	0f 01 ef             	wrpkru 
  40a8a6:	48 b8 ef be ad de ef 	movabs rax,0xdeadbeefdeadbeef
  40a8ad:	be ad de 
  40a8b0:	49 39 c7             	cmp    r15,rax
  40a8b3:	4c 89 c0             	mov    rax,r8
  40a8b6:	49 89 34 24          	mov    QWORD PTR [r12],rsi
  40a8ba:	48 89 3b             	mov    QWORD PTR [rbx],rdi
  40a8bd:	41 5f                	pop    r15
  40a8bf:	41 5e                	pop    r14
  40a8c1:	41 5d                	pop    r13
  40a8c3:	41 5c                	pop    r12
  40a8c5:	5b                   	pop    rbx
  40a8c6:	5d                   	pop    rbp
  40a8c7:	c3                   	ret    
  40a8c8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40a8cf:	00 

000000000040a8d0 <init_parallelism>:
 * functions) are found in the c files in this directory. They
 * generate a .a static library that is linked on-demand.
 */
int
init_parallelism(void)
{
  40a8d0:	f3 0f 1e fa          	endbr64 
	return NUM_CPU;
}
  40a8d4:	b8 08 00 00 00       	mov    eax,0x8
  40a8d9:	c3                   	ret    
  40a8da:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000040a8e0 <cos_aepthd_fn>:
	struct cos_aep_info sched_aep[NUM_CPU];
};

static void
cos_aepthd_fn(void *data)
{
  40a8e0:	f3 0f 1e fa          	endbr64 
  40a8e4:	55                   	push   rbp
  40a8e5:	48 89 f8             	mov    rax,rdi
	struct cos_aep_info *aep_info = (struct cos_aep_info *)data;
	cos_aepthd_fn_t      aep_fn   = aep_info->fn;
	void *               fn_data  = aep_info->data;

	(aep_fn)(aep_info->rcv, fn_data);
  40a8e8:	48 8b 77 28          	mov    rsi,QWORD PTR [rdi+0x28]
  40a8ec:	48 8b 7f 18          	mov    rdi,QWORD PTR [rdi+0x18]
{
  40a8f0:	48 89 e5             	mov    rbp,rsp
	(aep_fn)(aep_info->rcv, fn_data);
  40a8f3:	ff 50 20             	call   QWORD PTR [rax+0x20]
  40a8f6:	be 69 00 00 00       	mov    esi,0x69
  40a8fb:	bf 90 d9 41 00       	mov    edi,0x41d990
  40a900:	e8 7b 03 00 00       	call   40ac80 <cos_print_str>

	/* TODO: handling destruction */
	assert(0);
  40a905:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40a90c:	00 00 00 00 
  40a910:	0f 0b                	ud2    
  40a912:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a919:	00 00 00 00 
  40a91d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040a920 <capmgr_thd_create>:
#include <capmgr.h>
#include <cos_thd_init.h>

thdcap_t
capmgr_thd_create(cos_thd_fn_t fn, void *data, thdid_t *tid)
{
  40a920:	f3 0f 1e fa          	endbr64 

/* See comments of cos_thd_create_remote. */
static thdclosure_index_t
cos_thd_init_alloc(void *fn, void *data)
{
	if (!fn) return -1;
  40a924:	48 85 ff             	test   rdi,rdi
  40a927:	0f 84 95 00 00 00    	je     40a9c2 <capmgr_thd_create+0xa2>
  40a92d:	49 89 f1             	mov    r9,rsi
  40a930:	49 89 f8             	mov    r8,rdi
  40a933:	48 89 d6             	mov    rsi,rdx
  40a936:	41 ba 02 00 00 00    	mov    r10d,0x2
static inline int
cos_cas(unsigned long *target, unsigned long old, unsigned long updated)
{
	char z;
	#if defined(__x86_64__)
	__asm__ __volatile__("lock cmpxchgq %2, %0; setz %1"
  40a93c:	31 d2                	xor    edx,edx
	for (i = 0; i < COS_THD_INIT_REGION_SIZE; i++) {
  40a93e:	b9 40 87 70 00       	mov    ecx,0x708740
  40a943:	31 ff                	xor    edi,edi
		if (__thd_init_data[i].fn == NULL) {
  40a945:	48 83 39 00          	cmp    QWORD PTR [rcx],0x0
  40a949:	74 25                	je     40a970 <capmgr_thd_create+0x50>
	for (i = 0; i < COS_THD_INIT_REGION_SIZE; i++) {
  40a94b:	83 c7 01             	add    edi,0x1
  40a94e:	48 83 c1 10          	add    rcx,0x10
  40a952:	81 ff 00 01 00 00    	cmp    edi,0x100
  40a958:	75 eb                	jne    40a945 <capmgr_thd_create+0x25>
	if (!tried) {
  40a95a:	41 83 fa 01          	cmp    r10d,0x1
  40a95e:	74 62                	je     40a9c2 <capmgr_thd_create+0xa2>
  40a960:	41 ba 01 00 00 00    	mov    r10d,0x1
  40a966:	eb d6                	jmp    40a93e <capmgr_thd_create+0x1e>
  40a968:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40a96f:	00 
  40a970:	48 89 d0             	mov    rax,rdx
  40a973:	f0 4c 0f b1 01       	lock cmpxchg QWORD PTR [rcx],r8
  40a978:	0f 94 c0             	sete   al
			if (!ret) continue;
  40a97b:	84 c0                	test   al,al
  40a97d:	74 cc                	je     40a94b <capmgr_thd_create+0x2b>
			assert(__thd_init_data[i].fn == fn);
  40a97f:	48 63 c7             	movsxd rax,edi
  40a982:	48 c1 e0 04          	shl    rax,0x4
  40a986:	48 8d 90 40 87 70 00 	lea    rdx,[rax+0x708740]
  40a98d:	4c 3b 80 40 87 70 00 	cmp    r8,QWORD PTR [rax+0x708740]
  40a994:	75 0c                	jne    40a9a2 <capmgr_thd_create+0x82>
			__thd_init_data[i].data = data;
  40a996:	4c 89 4a 08          	mov    QWORD PTR [rdx+0x8],r9
			return i + 1;
  40a99a:	83 c7 01             	add    edi,0x1
	thdclosure_index_t idx = cos_thd_init_alloc(fn, data);

	if (idx < 1) return 0;

	return capmgr_thd_create_thunk(idx, tid);
  40a99d:	e9 ce cb ff ff       	jmp    407570 <__cosrt_extern_capmgr_thd_create_thunk>
{
  40a9a2:	55                   	push   rbp
  40a9a3:	be 67 00 00 00       	mov    esi,0x67
  40a9a8:	bf 00 da 41 00       	mov    edi,0x41da00
  40a9ad:	48 89 e5             	mov    rbp,rsp
  40a9b0:	e8 cb 02 00 00       	call   40ac80 <cos_print_str>
			assert(__thd_init_data[i].fn == fn);
  40a9b5:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40a9bc:	00 00 00 00 
  40a9c0:	0f 0b                	ud2    
}
  40a9c2:	31 c0                	xor    eax,eax
  40a9c4:	c3                   	ret    
  40a9c5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40a9cc:	00 00 00 00 

000000000040a9d0 <capmgr_rcv_alloc>:

arcvcap_t
capmgr_rcv_alloc(cos_thd_fn_t fn, void *data, int flags, asndcap_t *asnd, thdcap_t *thdcap, thdid_t *tid)
{
  40a9d0:	f3 0f 1e fa          	endbr64 
	if (!fn) return -1;
  40a9d4:	48 85 ff             	test   rdi,rdi
  40a9d7:	0f 84 af 00 00 00    	je     40aa8c <capmgr_rcv_alloc+0xbc>
  40a9dd:	55                   	push   rbp
  40a9de:	49 89 cb             	mov    r11,rcx
  40a9e1:	49 89 fa             	mov    r10,rdi
  40a9e4:	4c 89 c1             	mov    rcx,r8
  40a9e7:	4d 89 c8             	mov    r8,r9
  40a9ea:	41 b9 02 00 00 00    	mov    r9d,0x2
  40a9f0:	48 89 e5             	mov    rbp,rsp
  40a9f3:	41 54                	push   r12
  40a9f5:	45 31 e4             	xor    r12d,r12d
  40a9f8:	53                   	push   rbx
  40a9f9:	48 89 f3             	mov    rbx,rsi
  40a9fc:	89 d6                	mov    esi,edx
	for (i = 0; i < COS_THD_INIT_REGION_SIZE; i++) {
  40a9fe:	ba 40 87 70 00       	mov    edx,0x708740
  40aa03:	31 ff                	xor    edi,edi
		if (__thd_init_data[i].fn == NULL) {
  40aa05:	48 83 3a 00          	cmp    QWORD PTR [rdx],0x0
  40aa09:	74 25                	je     40aa30 <capmgr_rcv_alloc+0x60>
	for (i = 0; i < COS_THD_INIT_REGION_SIZE; i++) {
  40aa0b:	83 c7 01             	add    edi,0x1
  40aa0e:	48 83 c2 10          	add    rdx,0x10
  40aa12:	81 ff 00 01 00 00    	cmp    edi,0x100
  40aa18:	75 eb                	jne    40aa05 <capmgr_rcv_alloc+0x35>
	if (!tried) {
  40aa1a:	41 83 f9 01          	cmp    r9d,0x1
  40aa1e:	74 65                	je     40aa85 <capmgr_rcv_alloc+0xb5>
  40aa20:	41 b9 01 00 00 00    	mov    r9d,0x1
  40aa26:	eb d6                	jmp    40a9fe <capmgr_rcv_alloc+0x2e>
  40aa28:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40aa2f:	00 
  40aa30:	4c 89 e0             	mov    rax,r12
  40aa33:	f0 4c 0f b1 12       	lock cmpxchg QWORD PTR [rdx],r10
  40aa38:	0f 94 c0             	sete   al
			if (!ret) continue;
  40aa3b:	84 c0                	test   al,al
  40aa3d:	74 cc                	je     40aa0b <capmgr_rcv_alloc+0x3b>
			assert(__thd_init_data[i].fn == fn);
  40aa3f:	48 63 c7             	movsxd rax,edi
  40aa42:	48 c1 e0 04          	shl    rax,0x4
  40aa46:	48 8d 90 40 87 70 00 	lea    rdx,[rax+0x708740]
  40aa4d:	4c 3b 90 40 87 70 00 	cmp    r10,QWORD PTR [rax+0x708740]
  40aa54:	75 13                	jne    40aa69 <capmgr_rcv_alloc+0x99>
			__thd_init_data[i].data = data;
  40aa56:	48 89 5a 08          	mov    QWORD PTR [rdx+0x8],rbx
			return i + 1;
  40aa5a:	83 c7 01             	add    edi,0x1
	thdclosure_index_t idx = cos_thd_init_alloc(fn, data);

	if (idx < 1) return 0;

	return capmgr_rcv_create(idx, flags, asnd, thdcap, tid);
}
  40aa5d:	5b                   	pop    rbx
	return capmgr_rcv_create(idx, flags, asnd, thdcap, tid);
  40aa5e:	4c 89 da             	mov    rdx,r11
}
  40aa61:	41 5c                	pop    r12
  40aa63:	5d                   	pop    rbp
	return capmgr_rcv_create(idx, flags, asnd, thdcap, tid);
  40aa64:	e9 77 d3 ff ff       	jmp    407de0 <__cosrt_extern_capmgr_rcv_create>
  40aa69:	be 67 00 00 00       	mov    esi,0x67
  40aa6e:	bf 00 da 41 00       	mov    edi,0x41da00
  40aa73:	e8 08 02 00 00       	call   40ac80 <cos_print_str>
			assert(__thd_init_data[i].fn == fn);
  40aa78:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40aa7f:	00 00 00 00 
  40aa83:	0f 0b                	ud2    
}
  40aa85:	5b                   	pop    rbx
  40aa86:	31 c0                	xor    eax,eax
  40aa88:	41 5c                	pop    r12
  40aa8a:	5d                   	pop    rbp
  40aa8b:	c3                   	ret    
  40aa8c:	31 c0                	xor    eax,eax
  40aa8e:	c3                   	ret    
  40aa8f:	90                   	nop

000000000040aa90 <capmgr_aep_create>:

thdcap_t
capmgr_aep_create(struct cos_aep_info *a, cos_aepthd_fn_t fn, void *data, int owntc, cos_channelkey_t key, microsec_t ipiwin, u32_t ipimax)
{
  40aa90:	f3 0f 1e fa          	endbr64 
  40aa94:	55                   	push   rbp
  40aa95:	41 89 ca             	mov    r10d,ecx
  40aa98:	44 89 c1             	mov    ecx,r8d
  40aa9b:	4d 89 c8             	mov    r8,r9
  40aa9e:	49 89 f3             	mov    r11,rsi
  40aaa1:	48 89 e5             	mov    rbp,rsp
  40aaa4:	41 56                	push   r14
again:
  40aaa6:	41 be 02 00 00 00    	mov    r14d,0x2
  40aaac:	44 8b 4d 10          	mov    r9d,DWORD PTR [rbp+0x10]
  40aab0:	41 55                	push   r13
  40aab2:	41 bd e0 a8 40 00    	mov    r13d,0x40a8e0
  40aab8:	41 54                	push   r12
  40aaba:	45 31 e4             	xor    r12d,r12d
  40aabd:	53                   	push   rbx
  40aabe:	48 89 d3             	mov    rbx,rdx
	for (i = 0; i < COS_THD_INIT_REGION_SIZE; i++) {
  40aac1:	ba 40 87 70 00       	mov    edx,0x708740
  40aac6:	31 f6                	xor    esi,esi
		if (__thd_init_data[i].fn == NULL) {
  40aac8:	48 83 3a 00          	cmp    QWORD PTR [rdx],0x0
  40aacc:	74 22                	je     40aaf0 <capmgr_aep_create+0x60>
	for (i = 0; i < COS_THD_INIT_REGION_SIZE; i++) {
  40aace:	83 c6 01             	add    esi,0x1
  40aad1:	48 83 c2 10          	add    rdx,0x10
  40aad5:	81 fe 00 01 00 00    	cmp    esi,0x100
  40aadb:	75 eb                	jne    40aac8 <capmgr_aep_create+0x38>
	if (!tried) {
  40aadd:	41 83 fe 01          	cmp    r14d,0x1
  40aae1:	75 75                	jne    40ab58 <capmgr_aep_create+0xc8>
	if (idx < 1) return 0;
	a->fn   = fn;
	a->data = data;

	return capmgr_aep_create_thunk(a, idx, owntc, key, ipiwin, ipimax);
}
  40aae3:	5b                   	pop    rbx
  40aae4:	31 c0                	xor    eax,eax
  40aae6:	41 5c                	pop    r12
  40aae8:	41 5d                	pop    r13
  40aaea:	41 5e                	pop    r14
  40aaec:	5d                   	pop    rbp
  40aaed:	c3                   	ret    
  40aaee:	66 90                	xchg   ax,ax
  40aaf0:	4c 89 e0             	mov    rax,r12
  40aaf3:	f0 4c 0f b1 2a       	lock cmpxchg QWORD PTR [rdx],r13
  40aaf8:	0f 94 c0             	sete   al
			if (!ret) continue;
  40aafb:	84 c0                	test   al,al
  40aafd:	74 cf                	je     40aace <capmgr_aep_create+0x3e>
			assert(__thd_init_data[i].fn == fn);
  40aaff:	48 63 c6             	movsxd rax,esi
  40ab02:	48 c1 e0 04          	shl    rax,0x4
  40ab06:	48 8d 90 40 87 70 00 	lea    rdx,[rax+0x708740]
  40ab0d:	48 81 b8 40 87 70 00 	cmp    QWORD PTR [rax+0x708740],0x40a8e0
  40ab14:	e0 a8 40 00 
  40ab18:	75 22                	jne    40ab3c <capmgr_aep_create+0xac>
			__thd_init_data[i].data = data;
  40ab1a:	48 89 7a 08          	mov    QWORD PTR [rdx+0x8],rdi
	return capmgr_aep_create_thunk(a, idx, owntc, key, ipiwin, ipimax);
  40ab1e:	0f b7 c9             	movzx  ecx,cx
			return i + 1;
  40ab21:	83 c6 01             	add    esi,0x1
  40ab24:	44 89 d2             	mov    edx,r10d
	a->fn   = fn;
  40ab27:	4c 89 5f 20          	mov    QWORD PTR [rdi+0x20],r11
	a->data = data;
  40ab2b:	48 89 5f 28          	mov    QWORD PTR [rdi+0x28],rbx
}
  40ab2f:	5b                   	pop    rbx
  40ab30:	41 5c                	pop    r12
  40ab32:	41 5d                	pop    r13
  40ab34:	41 5e                	pop    r14
  40ab36:	5d                   	pop    rbp
	return capmgr_aep_create_thunk(a, idx, owntc, key, ipiwin, ipimax);
  40ab37:	e9 44 cf ff ff       	jmp    407a80 <__cosrt_extern_capmgr_aep_create_thunk>
  40ab3c:	be 67 00 00 00       	mov    esi,0x67
  40ab41:	bf 00 da 41 00       	mov    edi,0x41da00
  40ab46:	e8 35 01 00 00       	call   40ac80 <cos_print_str>
			assert(__thd_init_data[i].fn == fn);
  40ab4b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ab52:	00 00 00 00 
  40ab56:	0f 0b                	ud2    
  40ab58:	41 be 01 00 00 00    	mov    r14d,0x1
  40ab5e:	e9 5e ff ff ff       	jmp    40aac1 <capmgr_aep_create+0x31>
  40ab63:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40ab6a:	00 00 00 
  40ab6d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040ab70 <main>:
 * __crt_main is just used to identify if the user has defined their
 * own main (thus overriding the weak place-holder below)
 */
static int
__crt_main(void)
{
  40ab70:	f3 0f 1e fa          	endbr64 
	return 0;
}
  40ab74:	31 c0                	xor    eax,eax
  40ab76:	c3                   	ret    
  40ab77:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40ab7e:	00 00 

000000000040ab80 <__crt_parallel_main>:
	return;
}

static void
__crt_parallel_main(coreid_t cid, int init_core, int ncores)
{
  40ab80:	f3 0f 1e fa          	endbr64 
	return;
}
  40ab84:	c3                   	ret    
  40ab85:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40ab8c:	00 00 00 00 

000000000040ab90 <__crt_cos_parallel_init>:
  40ab90:	f3 0f 1e fa          	endbr64 
  40ab94:	c3                   	ret    
  40ab95:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40ab9c:	00 00 00 00 
{
  40aba0:	f3 0f 1e fa          	endbr64 
}
  40aba4:	c3                   	ret    
  40aba5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40abac:	00 00 00 00 

000000000040abb0 <cos_main_defined>:
}
COS_FN_WEAKALIAS(cos_parallel_init, __crt_cos_parallel_init);

int
cos_main_defined(void)
{
  40abb0:	f3 0f 1e fa          	endbr64 
	return __crt_main != main;
  40abb4:	b8 70 ab 40 00       	mov    eax,0x40ab70
  40abb9:	48 3d 70 ab 40 00    	cmp    rax,0x40ab70
  40abbf:	0f 95 c0             	setne  al
  40abc2:	0f b6 c0             	movzx  eax,al
}
  40abc5:	c3                   	ret    
  40abc6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40abcd:	00 00 00 

000000000040abd0 <pre_syscall_default_setup>:
  40abd0:	f3 0f 1e fa          	endbr64 
  40abd4:	c3                   	ret    
  40abd5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40abdc:	00 00 00 00 

000000000040abe0 <pre_syscall_setup>:
}

/* Intended to be overriden by components */
CWEAKSYMB void
pre_syscall_setup()
{
  40abe0:	f3 0f 1e fa          	endbr64 
	pre_syscall_default_setup();
  40abe4:	31 c0                	xor    eax,eax
  40abe6:	e9 e5 ff ff ff       	jmp    40abd0 <pre_syscall_default_setup>
  40abeb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000040abf0 <syscall_emulation_setup>:
  40abf0:	f3 0f 1e fa          	endbr64 
  40abf4:	c3                   	ret    
  40abf5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40abfc:	00 00 00 00 

000000000040ac00 <libc_initialization_handler>:
  40ac00:	f3 0f 1e fa          	endbr64 
  40ac04:	c3                   	ret    
  40ac05:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40ac0c:	00 00 00 00 

000000000040ac10 <libc_posixcap_initialization_handler>:
  40ac10:	f3 0f 1e fa          	endbr64 
  40ac14:	c3                   	ret    
  40ac15:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40ac1c:	00 00 00 00 

000000000040ac20 <libc_posixsched_initialization_handler>:
  40ac20:	f3 0f 1e fa          	endbr64 
  40ac24:	c3                   	ret    
  40ac25:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40ac2c:	00 00 00 00 

000000000040ac30 <libc_tls_init>:
{
}

CWEAKSYMB void
libc_tls_init(unsigned int cpuid)
{
  40ac30:	f3 0f 1e fa          	endbr64 

}
  40ac34:	c3                   	ret    
  40ac35:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40ac3c:	00 00 00 00 

000000000040ac40 <libc_init>:
/* TODO: Make this a weak symbol (currently doing so makes this fail) */
void __init_libc(char **envp, char *pn);

void
libc_init()
{
  40ac40:	f3 0f 1e fa          	endbr64 
                               (char *)AT_SECURE,
                               (char *)0, /* Whether the program is being run under sudo */
                               NULL
	};
	char *program_name = "composite component";
	__init_libc(envp, program_name);
  40ac44:	be 68 da 41 00       	mov    esi,0x41da68
  40ac49:	bf 20 80 42 00       	mov    edi,0x428020
  40ac4e:	e9 3d bd 00 00       	jmp    416990 <__init_libc>
  40ac53:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40ac5a:	00 00 00 00 
  40ac5e:	66 90                	xchg   ax,ax

000000000040ac60 <cos_upcall_exec>:
}

CWEAKSYMB void
cos_upcall_exec(void *arg)
{
  40ac60:	f3 0f 1e fa          	endbr64 
}
  40ac64:	c3                   	ret    
  40ac65:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40ac6c:	00 00 00 00 

000000000040ac70 <cos_async_inv>:

CWEAKSYMB int
cos_async_inv(struct usr_inv_cap *ucap, int *params)
{
  40ac70:	f3 0f 1e fa          	endbr64 
	return 0;
}
  40ac74:	31 c0                	xor    eax,eax
  40ac76:	c3                   	ret    
  40ac77:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40ac7e:	00 00 

000000000040ac80 <cos_print_str>:
	return 0;
}

CWEAKSYMB int
cos_print_str(char *s, int len)
{
  40ac80:	f3 0f 1e fa          	endbr64 
	int written = 0;

	while (written < len) {
  40ac84:	85 f6                	test   esi,esi
  40ac86:	0f 8e a4 00 00 00    	jle    40ad30 <cos_print_str+0xb0>
{
  40ac8c:	55                   	push   rbp
	int written = 0;
  40ac8d:	45 31 d2             	xor    r10d,r10d
{
  40ac90:	48 89 e5             	mov    rbp,rsp
  40ac93:	41 57                	push   r15
  40ac95:	41 56                	push   r14
  40ac97:	4c 8d 7d c0          	lea    r15,[rbp-0x40]
  40ac9b:	49 89 fe             	mov    r14,rdi
  40ac9e:	41 55                	push   r13
  40aca0:	41 89 f5             	mov    r13d,esi
  40aca3:	41 54                	push   r12
  40aca5:	53                   	push   rbx
  40aca6:	eb 10                	jmp    40acb8 <cos_print_str+0x38>
  40aca8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40acaf:	00 
		int ret;

		ret = call_cap(PRINT_CAP_TEMP, s_ints[0], s_ints[1], s_ints[2], len - written);
		/* Bomb out. Can't use a print out here as we must avoid recursion. */
		if (ret < 0) written = *(int *)NULL;
		written += ret;
  40acb0:	41 01 c2             	add    r10d,eax
	while (written < len) {
  40acb3:	45 39 d5             	cmp    r13d,r10d
  40acb6:	7e 60                	jle    40ad18 <cos_print_str+0x98>
		u32_t *s_ints = (u32_t *)&s[written];
  40acb8:	49 63 c2             	movsxd rax,r10d
		ret = call_cap(PRINT_CAP_TEMP, s_ints[0], s_ints[1], s_ints[2], len - written);
  40acbb:	44 89 ea             	mov    edx,r13d
	__asm__ __volatile__(
  40acbe:	4c 89 f9             	mov    rcx,r15
		u32_t *s_ints = (u32_t *)&s[written];
  40acc1:	4c 01 f0             	add    rax,r14
		ret = call_cap(PRINT_CAP_TEMP, s_ints[0], s_ints[1], s_ints[2], len - written);
  40acc4:	44 29 d2             	sub    edx,r10d
  40acc7:	8b 18                	mov    ebx,DWORD PTR [rax]
  40acc9:	8b 70 04             	mov    esi,DWORD PTR [rax+0x4]
  40accc:	48 63 d2             	movsxd rdx,edx
  40accf:	8b 78 08             	mov    edi,DWORD PTR [rax+0x8]
  40acd2:	b8 00 00 03 00       	mov    eax,0x30000
  40acd7:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40acda:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40acde:	48 89 cd             	mov    rbp,rcx
  40ace1:	49 b8 f8 ac 40 00 00 	movabs r8,0x40acf8
  40ace8:	00 00 00 
  40aceb:	0f 05                	syscall 
  40aced:	0f 1f 00             	nop    DWORD PTR [rax]
  40acf0:	eb 0d                	jmp    40acff <cos_print_str+0x7f>
  40acf2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40acf8:	b9 00 00 00 00       	mov    ecx,0x0
  40acfd:	eb 05                	jmp    40ad04 <cos_print_str+0x84>
  40acff:	b9 01 00 00 00       	mov    ecx,0x1
  40ad04:	5d                   	pop    rbp
  40ad05:	5c                   	pop    rsp
		if (ret < 0) written = *(int *)NULL;
  40ad06:	85 c0                	test   eax,eax
  40ad08:	79 a6                	jns    40acb0 <cos_print_str+0x30>
  40ad0a:	8b 04 25 00 00 00 00 	mov    eax,DWORD PTR ds:0x0
  40ad11:	0f 0b                	ud2    
  40ad13:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	}

	return written;
}
  40ad18:	44 89 d0             	mov    eax,r10d
  40ad1b:	5b                   	pop    rbx
  40ad1c:	41 5c                	pop    r12
  40ad1e:	41 5d                	pop    r13
  40ad20:	41 5e                	pop    r14
  40ad22:	41 5f                	pop    r15
  40ad24:	5d                   	pop    rbp
  40ad25:	c3                   	ret    
  40ad26:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40ad2d:	00 00 00 
  40ad30:	31 c0                	xor    eax,eax
  40ad32:	c3                   	ret    
  40ad33:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40ad3a:	00 00 00 00 
  40ad3e:	66 90                	xchg   ax,ax

000000000040ad40 <printc.constprop.0>:
printc(char *fmt, ...)
  40ad40:	55                   	push   rbp
  40ad41:	48 89 e5             	mov    rbp,rsp
  40ad44:	48 81 ec 90 01 00 00 	sub    rsp,0x190
  40ad4b:	48 89 b5 58 ff ff ff 	mov    QWORD PTR [rbp-0xa8],rsi
  40ad52:	48 89 95 60 ff ff ff 	mov    QWORD PTR [rbp-0xa0],rdx
  40ad59:	48 89 8d 68 ff ff ff 	mov    QWORD PTR [rbp-0x98],rcx
  40ad60:	4c 89 85 70 ff ff ff 	mov    QWORD PTR [rbp-0x90],r8
  40ad67:	4c 89 8d 78 ff ff ff 	mov    QWORD PTR [rbp-0x88],r9
  40ad6e:	84 c0                	test   al,al
  40ad70:	74 20                	je     40ad92 <printc.constprop.0+0x52>
  40ad72:	0f 29 45 80          	movaps XMMWORD PTR [rbp-0x80],xmm0
  40ad76:	0f 29 4d 90          	movaps XMMWORD PTR [rbp-0x70],xmm1
  40ad7a:	0f 29 55 a0          	movaps XMMWORD PTR [rbp-0x60],xmm2
  40ad7e:	0f 29 5d b0          	movaps XMMWORD PTR [rbp-0x50],xmm3
  40ad82:	0f 29 65 c0          	movaps XMMWORD PTR [rbp-0x40],xmm4
  40ad86:	0f 29 6d d0          	movaps XMMWORD PTR [rbp-0x30],xmm5
  40ad8a:	0f 29 75 e0          	movaps XMMWORD PTR [rbp-0x20],xmm6
  40ad8e:	0f 29 7d f0          	movaps XMMWORD PTR [rbp-0x10],xmm7
	va_start(arg_ptr, fmt);
  40ad92:	48 8d 45 10          	lea    rax,[rbp+0x10]
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40ad96:	ba 80 da 41 00       	mov    edx,0x41da80
  40ad9b:	be b4 00 00 00       	mov    esi,0xb4
	va_start(arg_ptr, fmt);
  40ada0:	c7 85 78 fe ff ff 08 	mov    DWORD PTR [rbp-0x188],0x8
  40ada7:	00 00 00 
  40adaa:	48 89 85 80 fe ff ff 	mov    QWORD PTR [rbp-0x180],rax
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40adb1:	48 8d 8d 78 fe ff ff 	lea    rcx,[rbp-0x188]
	va_start(arg_ptr, fmt);
  40adb8:	48 8d 85 50 ff ff ff 	lea    rax,[rbp-0xb0]
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40adbf:	48 8d bd 90 fe ff ff 	lea    rdi,[rbp-0x170]
	va_start(arg_ptr, fmt);
  40adc6:	48 89 85 88 fe ff ff 	mov    QWORD PTR [rbp-0x178],rax
  40adcd:	c7 85 7c fe ff ff 30 	mov    DWORD PTR [rbp-0x184],0x30
  40add4:	00 00 00 
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40add7:	e8 94 c0 00 00       	call   416e70 <vsnprintf>
	ret = cos_print_str(s, ret);
  40addc:	48 8d bd 90 fe ff ff 	lea    rdi,[rbp-0x170]
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40ade3:	89 c6                	mov    esi,eax
	ret = cos_print_str(s, ret);
  40ade5:	e8 96 fe ff ff       	call   40ac80 <cos_print_str>
}
  40adea:	c9                   	leave  
  40adeb:	c3                   	ret    
  40adec:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000040adf0 <prints.isra.0>:
prints(char *s)
  40adf0:	55                   	push   rbp
  40adf1:	48 89 e5             	mov    rbp,rsp
  40adf4:	41 54                	push   r12
  40adf6:	49 89 fc             	mov    r12,rdi
  40adf9:	48 83 ec 08          	sub    rsp,0x8
	return cos_print_str(s, strlen(s));
  40adfd:	e8 3e c4 00 00       	call   417240 <strlen>
  40ae02:	4c 89 e7             	mov    rdi,r12
}
  40ae05:	4c 8b 65 f8          	mov    r12,QWORD PTR [rbp-0x8]
  40ae09:	c9                   	leave  
	return cos_print_str(s, strlen(s));
  40ae0a:	89 c6                	mov    esi,eax
  40ae0c:	e9 6f fe ff ff       	jmp    40ac80 <cos_print_str>
  40ae11:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40ae18:	00 00 00 00 
  40ae1c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000040ae20 <cos_thd_entry_static>:
{
  40ae20:	f3 0f 1e fa          	endbr64 
  40ae24:	55                   	push   rbp
  40ae25:	be 2d 00 00 00       	mov    esi,0x2d
  40ae2a:	bf c8 da 41 00       	mov    edi,0x41dac8
  40ae2f:	48 89 e5             	mov    rbp,rsp
  40ae32:	e8 49 fe ff ff       	call   40ac80 <cos_print_str>
	assert(0);
  40ae37:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ae3e:	00 00 00 00 
  40ae42:	0f 0b                	ud2    
  40ae44:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40ae4b:	00 00 00 00 
  40ae4f:	90                   	nop

000000000040ae50 <cos_syscall_handler>:
{
  40ae50:	f3 0f 1e fa          	endbr64 
  40ae54:	55                   	push   rbp
  40ae55:	48 89 f2             	mov    rdx,rsi
	printc("Default syscall handler called (syscall: %d, first arg: %ld), faulting!", syscall_num, a);
  40ae58:	31 c0                	xor    eax,eax
  40ae5a:	89 fe                	mov    esi,edi
  40ae5c:	bf 80 da 41 00       	mov    edi,0x41da80
{
  40ae61:	48 89 e5             	mov    rbp,rsp
	printc("Default syscall handler called (syscall: %d, first arg: %ld), faulting!", syscall_num, a);
  40ae64:	e8 d7 fe ff ff       	call   40ad40 <printc.constprop.0>
  40ae69:	be 2c 00 00 00       	mov    esi,0x2c
  40ae6e:	bf f8 da 41 00       	mov    edi,0x41daf8
  40ae73:	e8 08 fe ff ff       	call   40ac80 <cos_print_str>
	assert(0);
  40ae78:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ae7f:	00 00 00 00 
  40ae83:	0f 0b                	ud2    
  40ae85:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40ae8c:	00 00 00 00 

000000000040ae90 <__cos_syscall>:
{
  40ae90:	f3 0f 1e fa          	endbr64 
	return cos_syscall_handler(syscall_num, a, b, c, d, e, f, g);
  40ae94:	e9 b7 ff ff ff       	jmp    40ae50 <cos_syscall_handler>
  40ae99:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000040aea0 <cos_main>:
{
  40aea0:	f3 0f 1e fa          	endbr64 
	assert(cos_main_defined());
  40aea4:	b8 70 ab 40 00       	mov    eax,0x40ab70
  40aea9:	48 3d 70 ab 40 00    	cmp    rax,0x40ab70
  40aeaf:	74 05                	je     40aeb6 <cos_main+0x16>
	return main();
  40aeb1:	e9 ba fc ff ff       	jmp    40ab70 <main>
{
  40aeb6:	55                   	push   rbp
  40aeb7:	be 2c 00 00 00       	mov    esi,0x2c
  40aebc:	bf 28 db 41 00       	mov    edi,0x41db28
  40aec1:	48 89 e5             	mov    rbp,rsp
  40aec4:	e8 b7 fd ff ff       	call   40ac80 <cos_print_str>
	assert(cos_main_defined());
  40aec9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40aed0:	00 00 00 00 
  40aed4:	0f 0b                	ud2    
  40aed6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40aedd:	00 00 00 

000000000040aee0 <cos_print_level_set>:
int cos_print_level   = PRINT_ERROR;
int cos_print_lvl_str = 0;

CWEAKSYMB void
cos_print_level_set(cos_print_level_t lvl, int print_str)
{
  40aee0:	f3 0f 1e fa          	endbr64 
	cos_print_level   = lvl;
  40aee4:	89 3d 5a e8 2f 00    	mov    DWORD PTR [rip+0x2fe85a],edi        # 709744 <cos_print_level>
	cos_print_lvl_str = print_str;
  40aeea:	89 35 50 e8 2f 00    	mov    DWORD PTR [rip+0x2fe850],esi        # 709740 <cos_print_lvl_str>
}
  40aef0:	c3                   	ret    
  40aef1:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40aef8:	00 00 00 00 
  40aefc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000040af00 <cos_upcall_fn>:
}
#endif

CWEAKSYMB void
cos_upcall_fn(upcall_type_t t, void *arg1, void *arg2, void *arg3)
{
  40af00:	f3 0f 1e fa          	endbr64 
  40af04:	55                   	push   rbp
  40af05:	b9 01 00 00 00       	mov    ecx,0x1
  40af0a:	31 d2                	xor    edx,edx
  40af0c:	48 89 e5             	mov    rbp,rsp
  40af0f:	41 56                	push   r14
  40af11:	41 55                	push   r13
  40af13:	41 54                	push   r12
  40af15:	41 89 fc             	mov    r12d,edi
  40af18:	53                   	push   rbx
  40af19:	48 89 f3             	mov    rbx,rsi
  40af1c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  40af20:	48 89 d0             	mov    rax,rdx
  40af23:	f0 48 0f b1 0d 24 e8 	lock cmpxchg QWORD PTR [rip+0x2fe824],rcx        # 709750 <_lock.1>
  40af2a:	2f 00 
  40af2c:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40af2f:	84 c0                	test   al,al
  40af31:	74 ed                	je     40af20 <cos_upcall_fn+0x20>
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  40af33:	0f 01 f9             	rdtscp 
	 * There should be no concurrency at initialization (the init
	 * interface ensures this), so atomic operations aren't
	 * required here to update first.
	 */
	ps_lock_take(&_lock);
	libc_tls_init(cos_cpuid());
  40af36:	89 cf                	mov    edi,ecx
  40af38:	81 e7 ff 0f 00 00    	and    edi,0xfff
  40af3e:	e8 ed fc ff ff       	call   40ac30 <libc_tls_init>
	if (first) {
  40af43:	8b 05 bf d0 01 00    	mov    eax,DWORD PTR [rip+0x1d0bf]        # 428008 <first.2>
  40af49:	85 c0                	test   eax,eax
  40af4b:	0f 84 ac 00 00 00    	je     40affd <cos_upcall_fn+0xfd>
		/*
		 * Use the heap pointer as calculated from the linker
		 * script *if* the loader doesn't pass in its own
		 * value.
		 */
		if (__cosrt_comp_info.cos_heap_ptr == 0) {
  40af51:	48 83 3d ff e0 01 00 	cmp    QWORD PTR [rip+0x1e0ff],0x0        # 429058 <__cosrt_comp_info+0x58>
  40af58:	00 
		first = 0;
  40af59:	c7 05 a5 d0 01 00 00 	mov    DWORD PTR [rip+0x1d0a5],0x0        # 428008 <first.2>
  40af60:	00 00 00 
		if (__cosrt_comp_info.cos_heap_ptr == 0) {
  40af63:	75 12                	jne    40af77 <cos_upcall_fn+0x77>
			extern const vaddr_t __crt_static_heap_ptr;

			__cosrt_comp_info.cos_heap_ptr = round_up_to_page((vaddr_t)&__crt_static_heap_ptr);
  40af65:	b8 87 81 71 00       	mov    eax,0x718187
  40af6a:	48 25 00 f0 ff ff    	and    rax,0xfffffffffffff000
  40af70:	48 89 05 e1 e0 01 00 	mov    QWORD PTR [rip+0x1e0e1],rax        # 429058 <__cosrt_comp_info+0x58>
		}

		cos_print_level_set(PRINT_DEBUG, 1);
  40af77:	be 01 00 00 00       	mov    esi,0x1
  40af7c:	bf 02 00 00 00       	mov    edi,0x2
static inline void
section_fnptrs_execute(long *list)
{
	int i;

	for (i = 0; i < list[0]; i++) {
  40af81:	45 31 ed             	xor    r13d,r13d
  40af84:	e8 57 ff ff ff       	call   40aee0 <cos_print_level_set>
		/* The syscall enumlator might need something to be setup before it can work */
		pre_syscall_setup();
  40af89:	31 c0                	xor    eax,eax
  40af8b:	e8 50 fc ff ff       	call   40abe0 <pre_syscall_setup>
		/* libc needs syscall emulation to work */
		syscall_emulation_setup();
  40af90:	31 c0                	xor    eax,eax
  40af92:	e8 59 fc ff ff       	call   40abf0 <syscall_emulation_setup>
		/* With all that setup, we can invoke the libc_initialization_handler */
		libc_initialization_handler();
  40af97:	31 c0                	xor    eax,eax
  40af99:	e8 62 fc ff ff       	call   40ac00 <libc_initialization_handler>
		/* init lib posix variants */
		libc_posixcap_initialization_handler();
  40af9e:	31 c0                	xor    eax,eax
  40afa0:	e8 6b fc ff ff       	call   40ac10 <libc_posixcap_initialization_handler>
		libc_posixsched_initialization_handler();
  40afa5:	31 c0                	xor    eax,eax
  40afa7:	e8 74 fc ff ff       	call   40ac20 <libc_posixsched_initialization_handler>
  40afac:	48 83 3d 4c 90 01 00 	cmp    QWORD PTR [rip+0x1904c],0x0        # 424000 <__CTOR_LIST__>
  40afb3:	00 
  40afb4:	7e 1f                	jle    40afd5 <cos_upcall_fn+0xd5>
  40afb6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40afbd:	00 00 00 
		typedef void (*ctors_t)(void);
		ctors_t ctors = (ctors_t)list[i + 1];
		ctors();
  40afc0:	42 ff 14 ed 08 40 42 	call   QWORD PTR [r13*8+0x424008]
  40afc7:	00 
	for (i = 0; i < list[0]; i++) {
  40afc8:	49 83 c5 01          	add    r13,0x1
  40afcc:	4c 3b 2d 2d 90 01 00 	cmp    r13,QWORD PTR [rip+0x1902d]        # 424000 <__CTOR_LIST__>
  40afd3:	7c eb                	jl     40afc0 <cos_upcall_fn+0xc0>
  40afd5:	45 31 ed             	xor    r13d,r13d
  40afd8:	48 83 3d 40 90 01 00 	cmp    QWORD PTR [rip+0x19040],0x0        # 424020 <__DTOR_END__>
  40afdf:	00 
  40afe0:	7e 1b                	jle    40affd <cos_upcall_fn+0xfd>
  40afe2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
		ctors();
  40afe8:	42 ff 14 ed 28 40 42 	call   QWORD PTR [r13*8+0x424028]
  40afef:	00 
	for (i = 0; i < list[0]; i++) {
  40aff0:	49 83 c5 01          	add    r13,0x1
  40aff4:	4c 39 2d 25 90 01 00 	cmp    QWORD PTR [rip+0x19025],r13        # 424020 <__DTOR_END__>
  40affb:	7f eb                	jg     40afe8 <cos_upcall_fn+0xe8>
	ps_lock_release(&_lock);
	/*
	 * if it's the first component.. wait for timer calibration.
	 * NOTE: for "fork"ing components and not updating "spdid"s, this call will just fail and should be fine.
	 */
	if (cos_compid_uninitialized()) { /* we must be in the initial booter! */
  40affd:	48 83 3d 3b e0 01 00 	cmp    QWORD PTR [rip+0x1e03b],0x0        # 429040 <__cosrt_comp_info+0x40>
  40b004:	00 
{ l->o = 0; }
  40b005:	48 c7 05 40 e7 2f 00 	mov    QWORD PTR [rip+0x2fe740],0x0        # 709750 <_lock.1>
  40b00c:	00 00 00 00 
  40b010:	74 58                	je     40b06a <cos_upcall_fn+0x16a>
		cos_hw_cycles_per_usec(BOOT_CAPTBL_SELF_INITHW_BASE);
		perfcntr_init();
	}

	switch (t) {
  40b012:	45 85 e4             	test   r12d,r12d
  40b015:	75 62                	jne    40b079 <cos_upcall_fn+0x179>
	{
		/* A new thread is created in this comp. */

		/* arg1 is the thread init data. 0 means
		 * bootstrap. */
		if (arg1 == 0) {
  40b017:	48 85 db             	test   rbx,rbx
  40b01a:	0f 84 82 00 00 00    	je     40b0a2 <cos_upcall_fn+0x1a2>
			static unsigned long first_core = 1;

			/* FIXME: assume that core 0 is the initial core for now */
			start_execution(cos_coreid(), ps_cas(&first_core, 1, 0), init_parallelism());
		} else {
			word_t idx = (word_t)arg1 - 1;
  40b020:	48 83 eb 01          	sub    rbx,0x1
			if (idx >= COS_THD_INIT_REGION_SIZE) {
  40b024:	48 81 fb ff 00 00 00 	cmp    rbx,0xff
  40b02b:	77 68                	ja     40b095 <cos_upcall_fn+0x195>
	fn   = __thd_init_data[idx].fn;
  40b02d:	89 db                	mov    ebx,ebx
	__thd_init_data[idx].fn   = NULL;
  40b02f:	66 0f ef c0          	pxor   xmm0,xmm0
	fn   = __thd_init_data[idx].fn;
  40b033:	48 c1 e3 04          	shl    rbx,0x4
  40b037:	48 8b 83 40 87 70 00 	mov    rax,QWORD PTR [rbx+0x708740]
	data = __thd_init_data[idx].data;
  40b03e:	48 8b bb 48 87 70 00 	mov    rdi,QWORD PTR [rbx+0x708748]
	__thd_init_data[idx].fn   = NULL;
  40b045:	0f 29 83 40 87 70 00 	movaps XMMWORD PTR [rbx+0x708740],xmm0
	(fn)(data);
  40b04c:	ff d0                	call   rax
  40b04e:	be 2d 00 00 00       	mov    esi,0x2d
  40b053:	bf 18 dc 41 00       	mov    edi,0x41dc18
  40b058:	e8 23 fc ff ff       	call   40ac80 <cos_print_str>
	}
	default:
		/* fault! */
		assert(0);
	}
	assert(0); 		/* should *not* return from threads */
  40b05d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40b064:	00 00 00 00 
  40b068:	0f 0b                	ud2    
		cos_hw_cycles_per_usec(BOOT_CAPTBL_SELF_INITHW_BASE);
  40b06a:	bf 24 00 00 00       	mov    edi,0x24
  40b06f:	e8 dc 76 00 00       	call   412750 <cos_hw_cycles_per_usec>
	switch (t) {
  40b074:	45 85 e4             	test   r12d,r12d
  40b077:	74 9e                	je     40b017 <cos_upcall_fn+0x117>
  40b079:	be 2d 00 00 00       	mov    esi,0x2d
  40b07e:	bf e8 db 41 00       	mov    edi,0x41dbe8
  40b083:	e8 f8 fb ff ff       	call   40ac80 <cos_print_str>
		assert(0);
  40b088:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40b08f:	00 00 00 00 
  40b093:	0f 0b                	ud2    
				cos_thd_entry_static(idx - COS_THD_INIT_REGION_SIZE);
  40b095:	8d bb 00 ff ff ff    	lea    edi,[rbx-0x100]
  40b09b:	e8 80 fd ff ff       	call   40ae20 <cos_thd_entry_static>
  40b0a0:	eb ac                	jmp    40b04e <cos_upcall_fn+0x14e>
			start_execution(cos_coreid(), ps_cas(&first_core, 1, 0), init_parallelism());
  40b0a2:	e8 29 f8 ff ff       	call   40a8d0 <init_parallelism>
        __asm__ __volatile__("lock " PS_CAS_STR
  40b0a7:	b8 01 00 00 00       	mov    eax,0x1
  40b0ac:	f0 48 0f b1 1d 4b cf 	lock cmpxchg QWORD PTR [rip+0x1cf4b],rbx        # 428000 <first_core.3>
  40b0b3:	01 00 
  40b0b5:	0f 94 c0             	sete   al
        return (int)z;
  40b0b8:	44 0f be e8          	movsx  r13d,al
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  40b0bc:	0f 01 f9             	rdtscp 
	if (parallel_main != __crt_parallel_main) {
  40b0bf:	b8 20 51 40 00       	mov    eax,0x405120
			start_execution(cos_coreid(), ps_cas(&first_core, 1, 0), init_parallelism());
  40b0c4:	41 89 ce             	mov    r14d,ecx
  40b0c7:	41 81 e6 ff 0f 00 00 	and    r14d,0xfff
	if (parallel_main != __crt_parallel_main) {
  40b0ce:	48 3d 80 ab 40 00    	cmp    rax,0x40ab80
  40b0d4:	0f 84 9d 00 00 00    	je     40b177 <cos_upcall_fn+0x277>
	if (initialization_completed == 0) {
  40b0da:	8b 05 6c e6 2f 00    	mov    eax,DWORD PTR [rip+0x2fe66c]        # 70974c <initialization_completed.4>
  40b0e0:	85 c0                	test   eax,eax
  40b0e2:	75 7a                	jne    40b15e <cos_upcall_fn+0x25e>
		main_type = INIT_MAIN_PARALLEL;
  40b0e4:	41 bc 02 00 00 00    	mov    r12d,0x2
		if (init_core) {
  40b0ea:	45 85 ed             	test   r13d,r13d
  40b0ed:	0f 85 a6 00 00 00    	jne    40b199 <cos_upcall_fn+0x299>
  40b0f3:	bb 50 51 40 00       	mov    ebx,0x405150
		COS_EXTERN_INV(init_parallel_await_init)();
  40b0f8:	e8 63 b5 ff ff       	call   406660 <__cosrt_extern_init_parallel_await_init>
		if (parallel_init) {
  40b0fd:	48 81 fb 90 ab 40 00 	cmp    rbx,0x40ab90
  40b104:	74 12                	je     40b118 <cos_upcall_fn+0x218>
			cos_parallel_init(cid, init_core, init_parallelism());
  40b106:	e8 c5 f7 ff ff       	call   40a8d0 <init_parallelism>
  40b10b:	44 89 ee             	mov    esi,r13d
  40b10e:	44 89 f7             	mov    edi,r14d
  40b111:	89 c2                	mov    edx,eax
  40b113:	e8 38 a0 ff ff       	call   405150 <cos_parallel_init>
		COS_EXTERN_INV(init_done)(0, main_type);
  40b118:	44 89 e6             	mov    esi,r12d
  40b11b:	31 ff                	xor    edi,edi
  40b11d:	e8 5e b5 ff ff       	call   406680 <__cosrt_extern_init_done>
		initialization_completed = 1;
  40b122:	c7 05 20 e6 2f 00 01 	mov    DWORD PTR [rip+0x2fe620],0x1        # 70974c <initialization_completed.4>
  40b129:	00 00 00 
	assert(main_type != INIT_MAIN_NONE);
  40b12c:	45 85 e4             	test   r12d,r12d
  40b12f:	0f 84 8a 00 00 00    	je     40b1bf <cos_upcall_fn+0x2bf>
	assert(main_type == INIT_MAIN_PARALLEL || (main_type == INIT_MAIN_SINGLE && init_core));
  40b135:	41 83 fc 02          	cmp    r12d,0x2
  40b139:	74 23                	je     40b15e <cos_upcall_fn+0x25e>
  40b13b:	45 85 ed             	test   r13d,r13d
  40b13e:	0f 84 00 01 00 00    	je     40b244 <cos_upcall_fn+0x344>
	assert(cos_main_defined());
  40b144:	b8 70 ab 40 00       	mov    eax,0x40ab70
  40b149:	48 3d 70 ab 40 00    	cmp    rax,0x40ab70
  40b14f:	0f 84 d8 00 00 00    	je     40b22d <cos_upcall_fn+0x32d>
	return main();
  40b155:	e8 16 fa ff ff       	call   40ab70 <main>
  40b15a:	89 c7                	mov    edi,eax
  40b15c:	eb 14                	jmp    40b172 <cos_upcall_fn+0x272>
		parallel_main(cid, init_core, init_parallelism());
  40b15e:	e8 6d f7 ff ff       	call   40a8d0 <init_parallelism>
  40b163:	44 89 f7             	mov    edi,r14d
  40b166:	44 89 ee             	mov    esi,r13d
  40b169:	89 c2                	mov    edx,eax
  40b16b:	e8 b0 9f ff ff       	call   405120 <parallel_main>
	int ret = 0;
  40b170:	31 ff                	xor    edi,edi
	COS_EXTERN_INV(init_exit)(ret);
  40b172:	e8 a9 b6 ff ff       	call   406820 <__cosrt_extern_init_exit>
	} else if (cos_main_defined()) {
  40b177:	b8 70 ab 40 00       	mov    eax,0x40ab70
  40b17c:	48 3d 70 ab 40 00    	cmp    rax,0x40ab70
  40b182:	74 52                	je     40b1d6 <cos_upcall_fn+0x2d6>
	if (initialization_completed == 0) {
  40b184:	8b 05 c2 e5 2f 00    	mov    eax,DWORD PTR [rip+0x2fe5c2]        # 70974c <initialization_completed.4>
  40b18a:	85 c0                	test   eax,eax
  40b18c:	75 ad                	jne    40b13b <cos_upcall_fn+0x23b>
		main_type = INIT_MAIN_SINGLE;
  40b18e:	41 bc 01 00 00 00    	mov    r12d,0x1
  40b194:	e9 51 ff ff ff       	jmp    40b0ea <cos_upcall_fn+0x1ea>
			cos_init();
  40b199:	31 c0                	xor    eax,eax
	const int parallel_init = cos_parallel_init != __crt_cos_parallel_init;
  40b19b:	bb 50 51 40 00       	mov    ebx,0x405150
			cos_init();
  40b1a0:	e8 db a0 ff ff       	call   405280 <cos_init>
	const int parallel_init = cos_parallel_init != __crt_cos_parallel_init;
  40b1a5:	31 ff                	xor    edi,edi
  40b1a7:	48 81 fb 90 ab 40 00 	cmp    rbx,0x40ab90
			COS_EXTERN_INV(init_done)(parallel_init, main_type);
  40b1ae:	44 89 e6             	mov    esi,r12d
	const int parallel_init = cos_parallel_init != __crt_cos_parallel_init;
  40b1b1:	40 0f 95 c7          	setne  dil
			COS_EXTERN_INV(init_done)(parallel_init, main_type);
  40b1b5:	e8 c6 b4 ff ff       	call   406680 <__cosrt_extern_init_done>
			assert(parallel_init || main_type != INIT_MAIN_NONE);
  40b1ba:	e9 39 ff ff ff       	jmp    40b0f8 <cos_upcall_fn+0x1f8>
	assert(main_type != INIT_MAIN_NONE);
  40b1bf:	bf 88 db 41 00       	mov    edi,0x41db88
  40b1c4:	e8 27 fc ff ff       	call   40adf0 <prints.isra.0>
  40b1c9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40b1d0:	00 00 00 00 
  40b1d4:	0f 0b                	ud2    
	if (initialization_completed == 0) {
  40b1d6:	8b 05 70 e5 2f 00    	mov    eax,DWORD PTR [rip+0x2fe570]        # 70974c <initialization_completed.4>
  40b1dc:	85 c0                	test   eax,eax
  40b1de:	75 df                	jne    40b1bf <cos_upcall_fn+0x2bf>
		if (init_core) {
  40b1e0:	45 85 ed             	test   r13d,r13d
  40b1e3:	0f 84 0a ff ff ff    	je     40b0f3 <cos_upcall_fn+0x1f3>
			cos_init();
  40b1e9:	31 c0                	xor    eax,eax
	const int parallel_init = cos_parallel_init != __crt_cos_parallel_init;
  40b1eb:	bb 50 51 40 00       	mov    ebx,0x405150
			cos_init();
  40b1f0:	e8 8b a0 ff ff       	call   405280 <cos_init>
	const int parallel_init = cos_parallel_init != __crt_cos_parallel_init;
  40b1f5:	31 ff                	xor    edi,edi
  40b1f7:	48 81 fb 90 ab 40 00 	cmp    rbx,0x40ab90
  40b1fe:	40 0f 95 c7          	setne  dil
			COS_EXTERN_INV(init_done)(parallel_init, main_type);
  40b202:	31 f6                	xor    esi,esi
  40b204:	e8 77 b4 ff ff       	call   406680 <__cosrt_extern_init_done>
			assert(parallel_init || main_type != INIT_MAIN_NONE);
  40b209:	48 81 fb 90 ab 40 00 	cmp    rbx,0x40ab90
  40b210:	0f 85 e2 fe ff ff    	jne    40b0f8 <cos_upcall_fn+0x1f8>
  40b216:	bf 58 db 41 00       	mov    edi,0x41db58
  40b21b:	e8 d0 fb ff ff       	call   40adf0 <prints.isra.0>
  40b220:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40b227:	00 00 00 00 
  40b22b:	0f 0b                	ud2    
	assert(cos_main_defined());
  40b22d:	bf 28 db 41 00       	mov    edi,0x41db28
  40b232:	e8 b9 fb ff ff       	call   40adf0 <prints.isra.0>
  40b237:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40b23e:	00 00 00 00 
  40b242:	0f 0b                	ud2    
	assert(main_type == INIT_MAIN_PARALLEL || (main_type == INIT_MAIN_SINGLE && init_core));
  40b244:	bf b8 db 41 00       	mov    edi,0x41dbb8
  40b249:	e8 a2 fb ff ff       	call   40adf0 <prints.isra.0>
  40b24e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40b255:	00 00 00 00 
  40b259:	0f 0b                	ud2    
  40b25b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000040b260 <cos_get_vas_page>:
	return;
}

CWEAKSYMB void *
cos_get_vas_page(void)
{
  40b260:	f3 0f 1e fa          	endbr64 
  40b264:	55                   	push   rbp
  40b265:	48 89 e5             	mov    rbp,rsp
  40b268:	53                   	push   rbx
  40b269:	bb 58 90 42 00       	mov    ebx,0x429058
  40b26e:	66 90                	xchg   ax,ax
	return (void *)__cosrt_comp_info.cos_heap_ptr;
  40b270:	48 8b 05 e1 dd 01 00 	mov    rax,QWORD PTR [rip+0x1dde1]        # 429058 <__cosrt_comp_info+0x58>
	char *h;
	long  r;
	do {
		h = cos_get_heap_ptr();
		r = (long)h + PAGE_SIZE;
  40b277:	48 8d 88 00 10 00 00 	lea    rcx,[rax+0x1000]
	__asm__ __volatile__("call cos_atomic_cmpxchg"
  40b27e:	e8 7d 02 00 00       	call   40b500 <cos_atomic_cmpxchg>
	} while (cos_cmpxchg(&__cosrt_comp_info.cos_heap_ptr, (long)h, r) != r);
  40b283:	48 39 ca             	cmp    rdx,rcx
  40b286:	75 e8                	jne    40b270 <cos_get_vas_page+0x10>
	return h;
}
  40b288:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
  40b28c:	c9                   	leave  
  40b28d:	c3                   	ret    
  40b28e:	66 90                	xchg   ax,ax

000000000040b290 <cos_release_vas_page>:

CWEAKSYMB void
cos_release_vas_page(void *p)
{
  40b290:	f3 0f 1e fa          	endbr64 
  40b294:	55                   	push   rbp
  40b295:	48 89 f9             	mov    rcx,rdi
	cos_set_heap_ptr_conditional(p + PAGE_SIZE, p);
  40b298:	48 8d 87 00 10 00 00 	lea    rax,[rdi+0x1000]
{
  40b29f:	48 89 e5             	mov    rbp,rsp
  40b2a2:	53                   	push   rbx
  40b2a3:	bb 58 90 42 00       	mov    ebx,0x429058
  40b2a8:	e8 53 02 00 00       	call   40b500 <cos_atomic_cmpxchg>
}
  40b2ad:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
  40b2b1:	c9                   	leave  
  40b2b2:	c3                   	ret    
  40b2b3:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40b2ba:	00 00 00 00 
  40b2be:	66 90                	xchg   ax,ax

000000000040b2c0 <cos_initargs_tar>:
CWEAKSYMB long _binary_tar_binary_start = 0;
CWEAKSYMB long _binary_tar_binary_end = 0;

char *
cos_initargs_tar(void)
{
  40b2c0:	f3 0f 1e fa          	endbr64 
	/* Tar files are at least one record, which is 512 bytes */
	if (_binary_tar_binary_end - _binary_tar_binary_start < 512) return NULL;
  40b2c4:	48 8b 05 3d d4 2f 00 	mov    rax,QWORD PTR [rip+0x2fd43d]        # 708708 <_binary_tar_binary_start>
  40b2cb:	48 8b 15 2e d4 2f 00 	mov    rdx,QWORD PTR [rip+0x2fd42e]        # 708700 <_binary_tar_binary_end>
  40b2d2:	48 29 c2             	sub    rdx,rax
  40b2d5:	48 81 fa ff 01 00 00 	cmp    rdx,0x1ff
  40b2dc:	ba 00 00 00 00       	mov    edx,0x0
  40b2e1:	48 0f 4e c2          	cmovle rax,rdx
	return (char *)_binary_tar_binary_start;
}
  40b2e5:	c3                   	ret    
  40b2e6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40b2ed:	00 00 00 

000000000040b2f0 <__cosrt_c_cosrtdefault>:
#include <cos_kernel_api.h>
#include <cos_types.h>
#include <c_stub.h>

COS_CLIENT_STUB(int, cosrtdefault, word_t p0, word_t p1, word_t p2, word_t p3)
{
  40b2f0:	f3 0f 1e fa          	endbr64 
  40b2f4:	55                   	push   rbp
  40b2f5:	48 89 e5             	mov    rbp,rsp
  40b2f8:	41 56                	push   r14
  40b2fa:	49 89 ce             	mov    r14,rcx
  40b2fd:	41 55                	push   r13
  40b2ff:	41 54                	push   r12
  40b301:	53                   	push   rbx
  40b302:	48 83 ec 20          	sub    rsp,0x20
  40b306:	4c 8b 40 08          	mov    r8,QWORD PTR [rax+0x8]
  40b30a:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, &r1, &r2);
  40b30e:	48 85 c0             	test   rax,rax
  40b311:	74 1d                	je     40b330 <__cosrt_c_cosrtdefault+0x40>
  40b313:	4c 8d 4d d0          	lea    r9,[rbp-0x30]
  40b317:	4c 8d 45 c8          	lea    r8,[rbp-0x38]
  40b31b:	ff d0                	call   rax
	COS_CLIENT_INVCAP;
	return cos_sinv(uc, p0, p1, p2, p3);
}
  40b31d:	48 83 c4 20          	add    rsp,0x20
  40b321:	5b                   	pop    rbx
  40b322:	41 5c                	pop    r12
  40b324:	41 5d                	pop    r13
  40b326:	41 5e                	pop    r14
  40b328:	5d                   	pop    rbp
  40b329:	c3                   	ret    
  40b32a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40b330:	41 8d 40 01          	lea    eax,[r8+0x1]
	__asm__ __volatile__(
  40b334:	48 89 fb             	mov    rbx,rdi
  40b337:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  40b33b:	48 89 d7             	mov    rdi,rdx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40b33e:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40b341:	4c 89 f2             	mov    rdx,r14
  40b344:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40b347:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40b34b:	48 89 cd             	mov    rbp,rcx
  40b34e:	49 b8 68 b3 40 00 00 	movabs r8,0x40b368
  40b355:	00 00 00 
  40b358:	0f 05                	syscall 
  40b35a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40b360:	eb 0d                	jmp    40b36f <__cosrt_c_cosrtdefault+0x7f>
  40b362:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40b368:	b9 00 00 00 00       	mov    ecx,0x0
  40b36d:	eb 05                	jmp    40b374 <__cosrt_c_cosrtdefault+0x84>
  40b36f:	b9 01 00 00 00       	mov    ecx,0x1
  40b374:	5d                   	pop    rbp
  40b375:	5c                   	pop    rsp
  40b376:	48 83 c4 20          	add    rsp,0x20
  40b37a:	5b                   	pop    rbx
  40b37b:	41 5c                	pop    r12
  40b37d:	41 5d                	pop    r13
  40b37f:	41 5e                	pop    r14
  40b381:	5d                   	pop    rbp
  40b382:	c3                   	ret    
  40b383:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40b38a:	00 00 00 00 
  40b38e:	66 90                	xchg   ax,ax

000000000040b390 <__cosrt_c_cosrtretdefault>:

COS_CLIENT_STUB(int, cosrtretdefault, word_t p0, word_t p1, word_t p2, word_t p3, word_t *r1, word_t *r2)
{
  40b390:	f3 0f 1e fa          	endbr64 
  40b394:	55                   	push   rbp
  40b395:	48 89 e5             	mov    rbp,rsp
  40b398:	41 57                	push   r15
  40b39a:	4d 89 c7             	mov    r15,r8
  40b39d:	41 56                	push   r14
  40b39f:	4d 89 ce             	mov    r14,r9
  40b3a2:	41 55                	push   r13
  40b3a4:	49 89 d5             	mov    r13,rdx
  40b3a7:	48 89 ca             	mov    rdx,rcx
  40b3aa:	41 54                	push   r12
  40b3ac:	53                   	push   rbx
  40b3ad:	48 89 fb             	mov    rbx,rdi
  40b3b0:	4c 8b 50 10          	mov    r10,QWORD PTR [rax+0x10]
	if (likely(uc->alt_fn)) return (uc->alt_fn)(arg1, arg2, arg3, arg4, ret1, ret2);
  40b3b4:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  40b3b8:	4d 85 d2             	test   r10,r10
  40b3bb:	74 13                	je     40b3d0 <__cosrt_c_cosrtretdefault+0x40>
  40b3bd:	48 89 d1             	mov    rcx,rdx
  40b3c0:	4c 89 ea             	mov    rdx,r13
	COS_CLIENT_INVCAP;

	return cos_sinv_2rets(uc, p0, p1, p2, p3, r1, r2);
}
  40b3c3:	5b                   	pop    rbx
  40b3c4:	41 5c                	pop    r12
  40b3c6:	41 5d                	pop    r13
  40b3c8:	41 5e                	pop    r14
  40b3ca:	41 5f                	pop    r15
  40b3cc:	5d                   	pop    rbp
  40b3cd:	41 ff e2             	jmp    r10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40b3d0:	8d 41 01             	lea    eax,[rcx+0x1]
	__asm__ __volatile__(
  40b3d3:	4c 89 ef             	mov    rdi,r13
  40b3d6:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40b3da:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40b3dd:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40b3e0:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40b3e4:	48 89 cd             	mov    rbp,rcx
  40b3e7:	49 b8 00 b4 40 00 00 	movabs r8,0x40b400
  40b3ee:	00 00 00 
  40b3f1:	0f 05                	syscall 
  40b3f3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40b3f8:	eb 0f                	jmp    40b409 <__cosrt_c_cosrtretdefault+0x79>
  40b3fa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40b400:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  40b407:	eb 07                	jmp    40b410 <__cosrt_c_cosrtretdefault+0x80>
  40b409:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  40b410:	5d                   	pop    rbp
  40b411:	5c                   	pop    rsp
  40b412:	49 89 37             	mov    QWORD PTR [r15],rsi
  40b415:	49 89 3e             	mov    QWORD PTR [r14],rdi
  40b418:	5b                   	pop    rbx
  40b419:	41 5c                	pop    r12
  40b41b:	41 5d                	pop    r13
  40b41d:	41 5e                	pop    r14
  40b41f:	41 5f                	pop    r15
  40b421:	5d                   	pop    rbp
  40b422:	c3                   	ret    
  40b423:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40b42a:	00 00 00 
  40b42d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040b430 <cos_ainv_entry>:
  40b430:	53                   	push   rbx
  40b431:	56                   	push   rsi
  40b432:	57                   	push   rdi
  40b433:	52                   	push   rdx
  40b434:	55                   	push   rbp
  40b435:	89 e3                	mov    ebx,esp
  40b437:	83 c3 18             	add    ebx,0x18
  40b43a:	53                   	push   rbx
  40b43b:	50                   	push   rax
  40b43c:	e8 2f f8 ff ff       	call   40ac70 <cos_async_inv>
  40b441:	83 c4 08             	add    esp,0x8
  40b444:	83 f8 00             	cmp    eax,0x0
  40b447:	74 22                	je     40b46b <ainv_ret>
  40b449:	67 8b 5c 24 18       	mov    ebx,DWORD PTR [esp+0x18]
  40b44e:	67 8b 74 24 1c       	mov    esi,DWORD PTR [esp+0x1c]
  40b453:	67 8b 7c 24 20       	mov    edi,DWORD PTR [esp+0x20]
  40b458:	67 8b 54 24 24       	mov    edx,DWORD PTR [esp+0x24]
  40b45d:	89 e5                	mov    ebp,esp
  40b45f:	48 b9 6b b4 40 00 00 	movabs rcx,0x40b46b
  40b466:	00 00 00 
  40b469:	0f 34                	sysenter 

000000000040b46b <ainv_ret>:
  40b46b:	5d                   	pop    rbp
  40b46c:	5a                   	pop    rdx
  40b46d:	5f                   	pop    rdi
  40b46e:	5e                   	pop    rsi
  40b46f:	5b                   	pop    rbx
  40b470:	c3                   	ret    
  40b471:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40b478:	00 00 00 
  40b47b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000040b480 <custom_acquire_stack>:
  40b480:	48 89 c2             	mov    rdx,rax
  40b483:	48 bc 00 c0 42 00 00 	movabs rsp,0x42c000
  40b48a:	00 00 00 
  40b48d:	48 25 ff ff 00 00    	and    rax,0xffff
  40b493:	48 c1 e0 0d          	shl    rax,0xd
  40b497:	48 01 c4             	add    rsp,rax
  40b49a:	48 c1 e8 0d          	shr    rax,0xd
  40b49e:	48 c1 ea 10          	shr    rdx,0x10
  40b4a2:	ff e1                	jmp    rcx
  40b4a4:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40b4ab:	00 00 00 00 
  40b4af:	90                   	nop

000000000040b4b0 <__cosrt_upcall_entry>:
  40b4b0:	48 b9 bf b4 40 00 00 	movabs rcx,0x40b4bf
  40b4b7:	00 00 00 
  40b4ba:	e9 c1 ff ff ff       	jmp    40b480 <custom_acquire_stack>
  40b4bf:	52                   	push   rdx
  40b4c0:	50                   	push   rax
  40b4c1:	6a 00                	push   0x0
  40b4c3:	6a 00                	push   0x0
  40b4c5:	48 89 64 24 f0       	mov    QWORD PTR [rsp-0x10],rsp
  40b4ca:	6a 00                	push   0x0
  40b4cc:	48 89 64 24 f0       	mov    QWORD PTR [rsp-0x10],rsp
  40b4d1:	48 83 ec 10          	sub    rsp,0x10
  40b4d5:	48 89 f1             	mov    rcx,rsi
  40b4d8:	48 89 fa             	mov    rdx,rdi
  40b4db:	48 89 de             	mov    rsi,rbx
  40b4de:	48 31 ed             	xor    rbp,rbp
  40b4e1:	4c 89 e7             	mov    rdi,r12
  40b4e4:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  40b4e8:	e8 13 fa ff ff       	call   40af00 <cos_upcall_fn>
  40b4ed:	83 c4 18             	add    esp,0x18
  40b4f0:	5e                   	pop    rsi
  40b4f1:	5f                   	pop    rdi
  40b4f2:	89 c1                	mov    ecx,eax
  40b4f4:	b8 00 00 01 00       	mov    eax,0x10000
  40b4f9:	0f 34                	sysenter 
  40b4fb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000040b500 <cos_atomic_cmpxchg>:
  40b500:	c3                   	ret    

000000000040b501 <cos_atomic_user1>:
  40b501:	b8 00 00 00 00       	mov    eax,0x0
  40b506:	67 8b 00             	mov    eax,DWORD PTR [eax]
  40b509:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000040b510 <cos_aepthd_fn>:
{
  40b510:	f3 0f 1e fa          	endbr64 
  40b514:	55                   	push   rbp
  40b515:	48 89 f8             	mov    rax,rdi
	(aep_fn)(aep_info->rcv, fn_data);
  40b518:	48 8b 77 28          	mov    rsi,QWORD PTR [rdi+0x28]
  40b51c:	48 8b 7f 18          	mov    rdi,QWORD PTR [rdi+0x18]
{
  40b520:	48 89 e5             	mov    rbp,rsp
	(aep_fn)(aep_info->rcv, fn_data);
  40b523:	ff 50 20             	call   QWORD PTR [rax+0x20]
  40b526:	be 32 00 00 00       	mov    esi,0x32
  40b52b:	bf b0 dc 41 00       	mov    edi,0x41dcb0
  40b530:	e8 4b f7 ff ff       	call   40ac80 <cos_print_str>
	assert(0);
  40b535:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40b53c:	00 00 00 00 
  40b540:	0f 0b                	ud2    
  40b542:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40b549:	00 00 00 00 
  40b54d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040b550 <cos_defcompinfo_curr_get>:
static int                    curr_defci_init_status;
static struct cos_defcompinfo curr_defci;

struct cos_defcompinfo *
cos_defcompinfo_curr_get(void)
{
  40b550:	f3 0f 1e fa          	endbr64 
	return &curr_defci;
}
  40b554:	b8 60 97 70 00       	mov    eax,0x709760
  40b559:	c3                   	ret    
  40b55a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000040b560 <cos_compinfo_get>:

struct cos_compinfo *
cos_compinfo_get(struct cos_defcompinfo *defci)
{
  40b560:	f3 0f 1e fa          	endbr64 
	assert(defci);
  40b564:	48 85 ff             	test   rdi,rdi
  40b567:	74 04                	je     40b56d <cos_compinfo_get+0xd>
  40b569:	48 89 f8             	mov    rax,rdi
	return &(defci->ci);
}
  40b56c:	c3                   	ret    
{
  40b56d:	55                   	push   rbp
  40b56e:	be 30 00 00 00       	mov    esi,0x30
  40b573:	bf e8 dc 41 00       	mov    edi,0x41dce8
  40b578:	48 89 e5             	mov    rbp,rsp
  40b57b:	e8 00 f7 ff ff       	call   40ac80 <cos_print_str>
	assert(defci);
  40b580:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40b587:	00 00 00 00 
  40b58b:	0f 0b                	ud2    
  40b58d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040b590 <cos_sched_aep_get>:

struct cos_aep_info *
cos_sched_aep_get(struct cos_defcompinfo *defci)
{
  40b590:	f3 0f 1e fa          	endbr64 
	assert(defci);
  40b594:	48 85 ff             	test   rdi,rdi
  40b597:	74 1a                	je     40b5b3 <cos_sched_aep_get+0x23>
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  40b599:	0f 01 f9             	rdtscp 
	return &(defci->sched_aep[cos_cpuid()]);
  40b59c:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  40b5a2:	48 8d 04 49          	lea    rax,[rcx+rcx*2]
  40b5a6:	48 c1 e0 04          	shl    rax,0x4
  40b5aa:	48 8d 84 07 88 01 00 	lea    rax,[rdi+rax*1+0x188]
  40b5b1:	00 
}
  40b5b2:	c3                   	ret    
{
  40b5b3:	55                   	push   rbp
  40b5b4:	be 30 00 00 00       	mov    esi,0x30
  40b5b9:	bf 20 dd 41 00       	mov    edi,0x41dd20
  40b5be:	48 89 e5             	mov    rbp,rsp
  40b5c1:	e8 ba f6 ff ff       	call   40ac80 <cos_print_str>
	assert(defci);
  40b5c6:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40b5cd:	00 00 00 00 
  40b5d1:	0f 0b                	ud2    
  40b5d3:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40b5da:	00 00 00 00 
  40b5de:	66 90                	xchg   ax,ax

000000000040b5e0 <cos_defcompinfo_init>:

void
cos_defcompinfo_init(void)
{
  40b5e0:	f3 0f 1e fa          	endbr64 
  40b5e4:	55                   	push   rbp
	capid_t cap_frontier = atol(args_get("captbl_end"));
  40b5e5:	bf 51 dd 41 00       	mov    edi,0x41dd51
{
  40b5ea:	48 89 e5             	mov    rbp,rsp
  40b5ed:	41 55                	push   r13
  40b5ef:	41 54                	push   r12
  40b5f1:	53                   	push   rbx
  40b5f2:	48 83 ec 18          	sub    rsp,0x18
	capid_t cap_frontier = atol(args_get("captbl_end"));
  40b5f6:	e8 75 7e 00 00       	call   413470 <args_get>
  40b5fb:	48 89 c7             	mov    rdi,rax
  40b5fe:	e8 2d ba 00 00       	call   417030 <atol>

	assert(cap_frontier > 0);
  40b603:	48 85 c0             	test   rax,rax
  40b606:	0f 84 e3 00 00 00    	je     40b6ef <cos_defcompinfo_init+0x10f>
	if (curr_defci_init_status == INITIALIZED) return;
  40b60c:	83 3d 55 e4 2f 00 01 	cmp    DWORD PTR [rip+0x2fe455],0x1        # 709a68 <curr_defci_init_status>
  40b613:	0f 84 cb 00 00 00    	je     40b6e4 <cos_defcompinfo_init+0x104>
  40b619:	49 89 c1             	mov    r9,rax
  40b61c:	0f 01 f9             	rdtscp 
  40b61f:	49 89 cc             	mov    r12,rcx
  40b622:	0f 01 f9             	rdtscp 

	cos_defcompinfo_init_ext(BOOT_CAPTBL_SELF_INITTCAP_CPU_BASE, BOOT_CAPTBL_SELF_INITTHD_CPU_BASE,
  40b625:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  40b62b:	4c 8d 69 28          	lea    r13,[rcx+0x28]
  40b62f:	0f 01 f9             	rdtscp 
  40b632:	81 e1 ff 0f 00 00    	and    ecx,0xfff
	struct cos_defcompinfo *defci = cos_defcompinfo_curr_get();
	struct cos_compinfo    *ci    = cos_compinfo_get(defci);

	if (curr_defci_init_status == INITIALIZED) return;

	cos_compinfo_init(ci, pgtbl_cap, captbl_cap, comp_cap, heap_ptr, cap_frontier, ci);
  40b638:	48 83 ec 08          	sub    rsp,0x8
  40b63c:	66 49 0f 6e cd       	movq   xmm1,r13
  40b641:	4c 8b 05 10 da 01 00 	mov    r8,QWORD PTR [rip+0x1da10]        # 429058 <__cosrt_comp_info+0x58>
	cos_defcompinfo_init_ext(BOOT_CAPTBL_SELF_INITTCAP_CPU_BASE, BOOT_CAPTBL_SELF_INITTHD_CPU_BASE,
  40b648:	48 8d 41 30          	lea    rax,[rcx+0x30]
	cos_compinfo_init(ci, pgtbl_cap, captbl_cap, comp_cap, heap_ptr, cap_frontier, ci);
  40b64c:	68 60 97 70 00       	push   0x709760
  40b651:	b9 0c 00 00 00       	mov    ecx,0xc
  40b656:	ba 04 00 00 00       	mov    edx,0x4
	cos_defcompinfo_init_ext(BOOT_CAPTBL_SELF_INITTCAP_CPU_BASE, BOOT_CAPTBL_SELF_INITTHD_CPU_BASE,
  40b65b:	66 48 0f 6e c0       	movq   xmm0,rax
	cos_compinfo_init(ci, pgtbl_cap, captbl_cap, comp_cap, heap_ptr, cap_frontier, ci);
  40b660:	be 08 00 00 00       	mov    esi,0x8
  40b665:	bf 60 97 70 00       	mov    edi,0x709760
  40b66a:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  40b66e:	0f 29 45 d0          	movaps XMMWORD PTR [rbp-0x30],xmm0
  40b672:	e8 99 20 00 00       	call   40d710 <cos_compinfo_init>
	curr_defci_init_status = INITIALIZED;
  40b677:	c7 05 e7 e3 2f 00 01 	mov    DWORD PTR [rip+0x2fe3e7],0x1        # 709a68 <curr_defci_init_status>
  40b67e:	00 00 00 
  40b681:	0f 01 f9             	rdtscp 
	return (long)coreid;
  40b684:	81 e1 ff 0f 00 00    	and    ecx,0xfff
	struct cos_compinfo    *ci        = cos_compinfo_get(defci);
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);

	assert(curr_defci_init_status == INITIALIZED);

	sched_aep->tc   = sched_tc;
  40b68a:	66 0f 6f 45 d0       	movdqa xmm0,XMMWORD PTR [rbp-0x30]
	sched_aep->thd  = sched_thd;
	sched_aep->rcv  = sched_rcv;
	sched_aep->fn   = NULL;
	sched_aep->data = NULL;
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40b68f:	31 d2                	xor    edx,edx
  40b691:	4c 89 ee             	mov    rsi,r13
	sched_aep->tc   = sched_tc;
  40b694:	48 8d 1c 49          	lea    rbx,[rcx+rcx*2]
	                         BOOT_CAPTBL_SELF_INITRCV_CPU_BASE, BOOT_CAPTBL_SELF_PT, BOOT_CAPTBL_SELF_CT,
  40b698:	41 81 e4 ff 0f 00 00 	and    r12d,0xfff
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40b69f:	bf 60 97 70 00       	mov    edi,0x709760
	sched_aep->tc   = sched_tc;
  40b6a4:	48 c1 e3 04          	shl    rbx,0x4
	                         BOOT_CAPTBL_SELF_INITRCV_CPU_BASE, BOOT_CAPTBL_SELF_PT, BOOT_CAPTBL_SELF_CT,
  40b6a8:	4a 8d 04 a5 38 00 00 	lea    rax,[r12*4+0x38]
  40b6af:	00 
  40b6b0:	48 89 83 00 99 70 00 	mov    QWORD PTR [rbx+0x709900],rax
	sched_aep->fn   = NULL;
  40b6b7:	48 c7 83 08 99 70 00 	mov    QWORD PTR [rbx+0x709908],0x0
  40b6be:	00 00 00 00 
	sched_aep->data = NULL;
  40b6c2:	48 c7 83 10 99 70 00 	mov    QWORD PTR [rbx+0x709910],0x0
  40b6c9:	00 00 00 00 
	sched_aep->tc   = sched_tc;
  40b6cd:	0f 11 83 e8 98 70 00 	movups XMMWORD PTR [rbx+0x7098e8],xmm0
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40b6d4:	e8 77 6c 00 00       	call   412350 <cos_introspect>
  40b6d9:	48 98                	cdqe   
  40b6db:	48 89 83 f8 98 70 00 	mov    QWORD PTR [rbx+0x7098f8],rax
}
  40b6e2:	58                   	pop    rax
  40b6e3:	5a                   	pop    rdx
}
  40b6e4:	48 8d 65 e8          	lea    rsp,[rbp-0x18]
  40b6e8:	5b                   	pop    rbx
  40b6e9:	41 5c                	pop    r12
  40b6eb:	41 5d                	pop    r13
  40b6ed:	5d                   	pop    rbp
  40b6ee:	c3                   	ret    
  40b6ef:	be 30 00 00 00       	mov    esi,0x30
  40b6f4:	bf 60 dd 41 00       	mov    edi,0x41dd60
  40b6f9:	e8 82 f5 ff ff       	call   40ac80 <cos_print_str>
	assert(cap_frontier > 0);
  40b6fe:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40b705:	00 00 00 00 
  40b709:	0f 0b                	ud2    
  40b70b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000040b710 <cos_defcompinfo_init_ext>:
{
  40b710:	f3 0f 1e fa          	endbr64 
  40b714:	55                   	push   rbp
  40b715:	66 48 0f 6e c7       	movq   xmm0,rdi
  40b71a:	66 48 0f 6e ce       	movq   xmm1,rsi
  40b71f:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  40b723:	48 89 e5             	mov    rbp,rsp
  40b726:	41 55                	push   r13
  40b728:	41 54                	push   r12
  40b72a:	49 89 f4             	mov    r12,rsi
  40b72d:	53                   	push   rbx
  40b72e:	48 83 ec 18          	sub    rsp,0x18
	if (curr_defci_init_status == INITIALIZED) return;
  40b732:	83 3d 2f e3 2f 00 01 	cmp    DWORD PTR [rip+0x2fe32f],0x1        # 709a68 <curr_defci_init_status>
  40b739:	0f 29 45 d0          	movaps XMMWORD PTR [rbp-0x30],xmm0
  40b73d:	0f 84 85 00 00 00    	je     40b7c8 <cos_defcompinfo_init_ext+0xb8>
	cos_compinfo_init(ci, pgtbl_cap, captbl_cap, comp_cap, heap_ptr, cap_frontier, ci);
  40b743:	48 83 ec 08          	sub    rsp,0x8
  40b747:	48 89 ce             	mov    rsi,rcx
  40b74a:	49 89 d5             	mov    r13,rdx
  40b74d:	4c 89 c9             	mov    rcx,r9
  40b750:	68 60 97 70 00       	push   0x709760
  40b755:	4c 89 c2             	mov    rdx,r8
  40b758:	4c 8b 4d 18          	mov    r9,QWORD PTR [rbp+0x18]
  40b75c:	bf 60 97 70 00       	mov    edi,0x709760
  40b761:	4c 8b 45 10          	mov    r8,QWORD PTR [rbp+0x10]
  40b765:	e8 a6 1f 00 00       	call   40d710 <cos_compinfo_init>
	curr_defci_init_status = INITIALIZED;
  40b76a:	c7 05 f4 e2 2f 00 01 	mov    DWORD PTR [rip+0x2fe2f4],0x1        # 709a68 <curr_defci_init_status>
  40b771:	00 00 00 
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  40b774:	0f 01 f9             	rdtscp 
	return (long)coreid;
  40b777:	81 e1 ff 0f 00 00    	and    ecx,0xfff
	sched_aep->tc   = sched_tc;
  40b77d:	66 0f 6f 45 d0       	movdqa xmm0,XMMWORD PTR [rbp-0x30]
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40b782:	31 d2                	xor    edx,edx
  40b784:	4c 89 e6             	mov    rsi,r12
	sched_aep->tc   = sched_tc;
  40b787:	48 8d 1c 49          	lea    rbx,[rcx+rcx*2]
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40b78b:	bf 60 97 70 00       	mov    edi,0x709760
	sched_aep->tc   = sched_tc;
  40b790:	48 c1 e3 04          	shl    rbx,0x4
	sched_aep->rcv  = sched_rcv;
  40b794:	4c 89 ab 00 99 70 00 	mov    QWORD PTR [rbx+0x709900],r13
	sched_aep->fn   = NULL;
  40b79b:	48 c7 83 08 99 70 00 	mov    QWORD PTR [rbx+0x709908],0x0
  40b7a2:	00 00 00 00 
	sched_aep->data = NULL;
  40b7a6:	48 c7 83 10 99 70 00 	mov    QWORD PTR [rbx+0x709910],0x0
  40b7ad:	00 00 00 00 
	sched_aep->tc   = sched_tc;
  40b7b1:	0f 11 83 e8 98 70 00 	movups XMMWORD PTR [rbx+0x7098e8],xmm0
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40b7b8:	e8 93 6b 00 00       	call   412350 <cos_introspect>
  40b7bd:	48 98                	cdqe   
  40b7bf:	48 89 83 f8 98 70 00 	mov    QWORD PTR [rbx+0x7098f8],rax
}
  40b7c6:	58                   	pop    rax
  40b7c7:	5a                   	pop    rdx
}
  40b7c8:	48 8d 65 e8          	lea    rsp,[rbp-0x18]
  40b7cc:	5b                   	pop    rbx
  40b7cd:	41 5c                	pop    r12
  40b7cf:	41 5d                	pop    r13
  40b7d1:	5d                   	pop    rbp
  40b7d2:	c3                   	ret    
  40b7d3:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40b7da:	00 00 00 00 
  40b7de:	66 90                	xchg   ax,ax

000000000040b7e0 <cos_defcompinfo_sched_init_ext>:
{
  40b7e0:	f3 0f 1e fa          	endbr64 
  40b7e4:	55                   	push   rbp
  40b7e5:	49 89 f8             	mov    r8,rdi
  40b7e8:	66 48 0f 6e ce       	movq   xmm1,rsi
  40b7ed:	48 89 d7             	mov    rdi,rdx
  40b7f0:	66 49 0f 6e c0       	movq   xmm0,r8
  40b7f5:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  40b7f9:	48 89 e5             	mov    rbp,rsp
  40b7fc:	53                   	push   rbx
  40b7fd:	48 83 ec 08          	sub    rsp,0x8
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  40b801:	0f 01 f9             	rdtscp 
	return (long)coreid;
  40b804:	81 e1 ff 0f 00 00    	and    ecx,0xfff
	assert(curr_defci_init_status == INITIALIZED);
  40b80a:	83 3d 57 e2 2f 00 01 	cmp    DWORD PTR [rip+0x2fe257],0x1        # 709a68 <curr_defci_init_status>
  40b811:	75 47                	jne    40b85a <cos_defcompinfo_sched_init_ext+0x7a>
	sched_aep->tc   = sched_tc;
  40b813:	48 8d 1c 49          	lea    rbx,[rcx+rcx*2]
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40b817:	31 d2                	xor    edx,edx
	sched_aep->tc   = sched_tc;
  40b819:	48 c1 e3 04          	shl    rbx,0x4
	sched_aep->rcv  = sched_rcv;
  40b81d:	48 89 bb 00 99 70 00 	mov    QWORD PTR [rbx+0x709900],rdi
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40b824:	bf 60 97 70 00       	mov    edi,0x709760
	sched_aep->fn   = NULL;
  40b829:	48 c7 83 08 99 70 00 	mov    QWORD PTR [rbx+0x709908],0x0
  40b830:	00 00 00 00 
	sched_aep->data = NULL;
  40b834:	48 c7 83 10 99 70 00 	mov    QWORD PTR [rbx+0x709910],0x0
  40b83b:	00 00 00 00 
	sched_aep->tc   = sched_tc;
  40b83f:	0f 11 83 e8 98 70 00 	movups XMMWORD PTR [rbx+0x7098e8],xmm0
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40b846:	e8 05 6b 00 00       	call   412350 <cos_introspect>
  40b84b:	48 98                	cdqe   
  40b84d:	48 89 83 f8 98 70 00 	mov    QWORD PTR [rbx+0x7098f8],rax
}
  40b854:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
  40b858:	c9                   	leave  
  40b859:	c3                   	ret    
  40b85a:	be 30 00 00 00       	mov    esi,0x30
  40b85f:	bf 98 dd 41 00       	mov    edi,0x41dd98
  40b864:	e8 17 f4 ff ff       	call   40ac80 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40b869:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40b870:	00 00 00 00 
  40b874:	0f 0b                	ud2    
  40b876:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40b87d:	00 00 00 

000000000040b880 <cos_defcompinfo_sched_init>:

void
cos_defcompinfo_sched_init(void)
{
  40b880:	f3 0f 1e fa          	endbr64 
  40b884:	55                   	push   rbp
  40b885:	48 89 e5             	mov    rbp,rsp
  40b888:	53                   	push   rbx
  40b889:	48 83 ec 08          	sub    rsp,0x8
	assert(curr_defci_init_status == INITIALIZED);
  40b88d:	83 3d d4 e1 2f 00 01 	cmp    DWORD PTR [rip+0x2fe1d4],0x1        # 709a68 <curr_defci_init_status>
  40b894:	0f 85 92 00 00 00    	jne    40b92c <cos_defcompinfo_sched_init+0xac>
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  40b89a:	0f 01 f9             	rdtscp 
  40b89d:	48 89 ce             	mov    rsi,rcx
  40b8a0:	0f 01 f9             	rdtscp 

	cos_defcompinfo_sched_init_ext(BOOT_CAPTBL_SELF_INITTCAP_CPU_BASE, BOOT_CAPTBL_SELF_INITTHD_CPU_BASE,
  40b8a3:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  40b8a9:	4c 8d 41 28          	lea    r8,[rcx+0x28]
  40b8ad:	0f 01 f9             	rdtscp 
  40b8b0:	48 89 cf             	mov    rdi,rcx
  40b8b3:	0f 01 f9             	rdtscp 
  40b8b6:	81 e7 ff 0f 00 00    	and    edi,0xfff
	return (long)coreid;
  40b8bc:	81 e1 ff 0f 00 00    	and    ecx,0xfff
	sched_aep->tc   = sched_tc;
  40b8c2:	66 49 0f 6e c8       	movq   xmm1,r8
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40b8c7:	31 d2                	xor    edx,edx
	cos_defcompinfo_sched_init_ext(BOOT_CAPTBL_SELF_INITTCAP_CPU_BASE, BOOT_CAPTBL_SELF_INITTHD_CPU_BASE,
  40b8c9:	48 8d 47 30          	lea    rax,[rdi+0x30]
	sched_aep->tc   = sched_tc;
  40b8cd:	48 8d 1c 49          	lea    rbx,[rcx+rcx*2]
				       BOOT_CAPTBL_SELF_INITRCV_CPU_BASE);
  40b8d1:	81 e6 ff 0f 00 00    	and    esi,0xfff
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40b8d7:	bf 60 97 70 00       	mov    edi,0x709760
	cos_defcompinfo_sched_init_ext(BOOT_CAPTBL_SELF_INITTCAP_CPU_BASE, BOOT_CAPTBL_SELF_INITTHD_CPU_BASE,
  40b8dc:	66 48 0f 6e c0       	movq   xmm0,rax
	sched_aep->tc   = sched_tc;
  40b8e1:	48 c1 e3 04          	shl    rbx,0x4
				       BOOT_CAPTBL_SELF_INITRCV_CPU_BASE);
  40b8e5:	48 8d 04 b5 38 00 00 	lea    rax,[rsi*4+0x38]
  40b8ec:	00 
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40b8ed:	4c 89 c6             	mov    rsi,r8
	sched_aep->tc   = sched_tc;
  40b8f0:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
				       BOOT_CAPTBL_SELF_INITRCV_CPU_BASE);
  40b8f4:	48 89 83 00 99 70 00 	mov    QWORD PTR [rbx+0x709900],rax
	sched_aep->fn   = NULL;
  40b8fb:	48 c7 83 08 99 70 00 	mov    QWORD PTR [rbx+0x709908],0x0
  40b902:	00 00 00 00 
	sched_aep->data = NULL;
  40b906:	48 c7 83 10 99 70 00 	mov    QWORD PTR [rbx+0x709910],0x0
  40b90d:	00 00 00 00 
	sched_aep->tc   = sched_tc;
  40b911:	0f 11 83 e8 98 70 00 	movups XMMWORD PTR [rbx+0x7098e8],xmm0
	sched_aep->tid  = cos_introspect(ci, sched_thd, THD_GET_TID);
  40b918:	e8 33 6a 00 00       	call   412350 <cos_introspect>
  40b91d:	48 98                	cdqe   
  40b91f:	48 89 83 f8 98 70 00 	mov    QWORD PTR [rbx+0x7098f8],rax
}
  40b926:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
  40b92a:	c9                   	leave  
  40b92b:	c3                   	ret    
  40b92c:	be 30 00 00 00       	mov    esi,0x30
  40b931:	bf d0 dd 41 00       	mov    edi,0x41ddd0
  40b936:	e8 45 f3 ff ff       	call   40ac80 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40b93b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40b942:	00 00 00 00 
  40b946:	0f 0b                	ud2    
  40b948:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40b94f:	00 

000000000040b950 <cos_defcompinfo_child_alloc>:
}

int
cos_defcompinfo_child_alloc(struct cos_defcompinfo *child_defci, vaddr_t entry, vaddr_t heap_ptr, capid_t cap_frontier,
                            int is_sched)
{
  40b950:	f3 0f 1e fa          	endbr64 
  40b954:	55                   	push   rbp
  40b955:	49 89 f3             	mov    r11,rsi
  40b958:	49 89 ca             	mov    r10,rcx
  40b95b:	48 89 d6             	mov    rsi,rdx
  40b95e:	48 89 e5             	mov    rbp,rsp
  40b961:	41 57                	push   r15
  40b963:	41 56                	push   r14
  40b965:	41 55                	push   r13
  40b967:	41 54                	push   r12
  40b969:	53                   	push   rbx
  40b96a:	48 83 ec 08          	sub    rsp,0x8
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  40b96e:	0f 01 f9             	rdtscp 
	assert(defci);
  40b971:	48 85 ff             	test   rdi,rdi
  40b974:	0f 84 4b 01 00 00    	je     40bac5 <cos_defcompinfo_child_alloc+0x175>
  40b97a:	49 89 cf             	mov    r15,rcx
  40b97d:	0f 01 f9             	rdtscp 
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);
	struct cos_compinfo    *ci        = cos_compinfo_get(defci);
	struct cos_compinfo    *child_ci  = cos_compinfo_get(child_defci);
	struct cos_aep_info    *child_aep = cos_sched_aep_get(child_defci);

	assert(curr_defci_init_status == INITIALIZED);
  40b980:	83 3d e1 e0 2f 00 01 	cmp    DWORD PTR [rip+0x2fe0e1],0x1        # 709a68 <curr_defci_init_status>
  40b987:	49 89 cd             	mov    r13,rcx
  40b98a:	0f 85 51 01 00 00    	jne    40bae1 <cos_defcompinfo_child_alloc+0x191>
  40b990:	45 89 c4             	mov    r12d,r8d
	ret = cos_compinfo_alloc(child_ci, heap_ptr, cap_frontier, entry, ci, 0);
  40b993:	45 31 c9             	xor    r9d,r9d
  40b996:	41 b8 60 97 70 00    	mov    r8d,0x709760
  40b99c:	4c 89 d9             	mov    rcx,r11
  40b99f:	4c 89 d2             	mov    rdx,r10
  40b9a2:	48 89 fb             	mov    rbx,rdi
  40b9a5:	e8 36 55 00 00       	call   410ee0 <cos_compinfo_alloc>
  40b9aa:	41 89 c6             	mov    r14d,eax
	if (ret) return ret;
  40b9ad:	85 c0                	test   eax,eax
  40b9af:	0f 85 de 00 00 00    	jne    40ba93 <cos_defcompinfo_child_alloc+0x143>
	ret = cos_aep_alloc_intern(child_aep, child_defci, 0, is_sched ? sched_aep : NULL, NULL, NULL, 0);
  40b9b5:	45 85 e4             	test   r12d,r12d
  40b9b8:	0f 85 ea 00 00 00    	jne    40baa8 <cos_defcompinfo_child_alloc+0x158>
  40b9be:	45 31 e4             	xor    r12d,r12d
	assert(curr_defci_init_status == INITIALIZED);
  40b9c1:	83 3d a0 e0 2f 00 01 	cmp    DWORD PTR [rip+0x2fe0a0],0x1        # 709a68 <curr_defci_init_status>
  40b9c8:	0f 85 2f 01 00 00    	jne    40bafd <cos_defcompinfo_child_alloc+0x1ad>
	return (long)coreid;
  40b9ce:	41 81 e5 ff 0f 00 00 	and    r13d,0xfff
	memset(aep, 0, sizeof(struct cos_aep_info));
  40b9d5:	66 0f ef c0          	pxor   xmm0,xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40b9d9:	bf 60 97 70 00       	mov    edi,0x709760
	return &(defci->sched_aep[cos_cpuid()]);
  40b9de:	4f 8d 6c 6d 00       	lea    r13,[r13+r13*2+0x0]
  40b9e3:	49 c1 e5 04          	shl    r13,0x4
  40b9e7:	4a 8d 84 2b 88 01 00 	lea    rax,[rbx+r13*1+0x188]
  40b9ee:	00 
	memset(aep, 0, sizeof(struct cos_aep_info));
  40b9ef:	0f 11 00             	movups XMMWORD PTR [rax],xmm0
  40b9f2:	0f 11 40 10          	movups XMMWORD PTR [rax+0x10],xmm0
  40b9f6:	0f 11 40 20          	movups XMMWORD PTR [rax+0x20],xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40b9fa:	48 8b 73 10          	mov    rsi,QWORD PTR [rbx+0x10]
  40b9fe:	4c 01 eb             	add    rbx,r13
  40ba01:	e8 5a 42 00 00       	call   40fc60 <cos_initthd_alloc>
  40ba06:	48 89 83 90 01 00 00 	mov    QWORD PTR [rbx+0x190],rax
  40ba0d:	48 89 c6             	mov    rsi,rax
	assert(aep->thd);
  40ba10:	48 85 c0             	test   rax,rax
  40ba13:	0f 84 00 01 00 00    	je     40bb19 <cos_defcompinfo_child_alloc+0x1c9>
	aep->tid  = cos_introspect(ci, aep->thd, THD_GET_TID);
  40ba19:	31 d2                	xor    edx,edx
  40ba1b:	bf 60 97 70 00       	mov    edi,0x709760
  40ba20:	e8 2b 69 00 00       	call   412350 <cos_introspect>
  40ba25:	48 98                	cdqe   
  40ba27:	48 89 83 98 01 00 00 	mov    QWORD PTR [rbx+0x198],rax
	if (!sched && is_init) return 0;
  40ba2e:	4d 85 e4             	test   r12,r12
  40ba31:	74 60                	je     40ba93 <cos_defcompinfo_child_alloc+0x143>
		aep->tc = cos_tcap_alloc(ci);
  40ba33:	bf 60 97 70 00       	mov    edi,0x709760
  40ba38:	e8 73 69 00 00       	call   4123b0 <cos_tcap_alloc>
  40ba3d:	48 89 83 88 01 00 00 	mov    QWORD PTR [rbx+0x188],rax
  40ba44:	48 89 c2             	mov    rdx,rax
		assert(aep->tc);
  40ba47:	48 85 c0             	test   rax,rax
  40ba4a:	0f 84 e5 00 00 00    	je     40bb35 <cos_defcompinfo_child_alloc+0x1e5>
	aep->rcv  = cos_arcv_alloc(ci, aep->thd, aep->tc, ci->comp_cap, sched->rcv);
  40ba50:	4d 8b 44 24 18       	mov    r8,QWORD PTR [r12+0x18]
  40ba55:	48 8b 0d 14 dd 2f 00 	mov    rcx,QWORD PTR [rip+0x2fdd14]        # 709770 <curr_defci+0x10>
  40ba5c:	bf 60 97 70 00       	mov    edi,0x709760
  40ba61:	48 8b b3 90 01 00 00 	mov    rsi,QWORD PTR [rbx+0x190]
  40ba68:	e8 03 58 00 00       	call   411270 <cos_arcv_alloc>
  40ba6d:	48 89 83 a0 01 00 00 	mov    QWORD PTR [rbx+0x1a0],rax
	assert(aep->rcv);
  40ba74:	48 85 c0             	test   rax,rax
  40ba77:	0f 84 d4 00 00 00    	je     40bb51 <cos_defcompinfo_child_alloc+0x201>
	aep->fn   = fn;
  40ba7d:	48 c7 83 a8 01 00 00 	mov    QWORD PTR [rbx+0x1a8],0x0
  40ba84:	00 00 00 00 
	aep->data = data;
  40ba88:	48 c7 83 b0 01 00 00 	mov    QWORD PTR [rbx+0x1b0],0x0
  40ba8f:	00 00 00 00 

	return ret;
}
  40ba93:	48 83 c4 08          	add    rsp,0x8
  40ba97:	44 89 f0             	mov    eax,r14d
  40ba9a:	5b                   	pop    rbx
  40ba9b:	41 5c                	pop    r12
  40ba9d:	41 5d                	pop    r13
  40ba9f:	41 5e                	pop    r14
  40baa1:	41 5f                	pop    r15
  40baa3:	5d                   	pop    rbp
  40baa4:	c3                   	ret    
  40baa5:	0f 1f 00             	nop    DWORD PTR [rax]
	return &(defci->sched_aep[cos_cpuid()]);
  40baa8:	4c 89 f9             	mov    rcx,r15
  40baab:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  40bab1:	4c 8d 24 49          	lea    r12,[rcx+rcx*2]
  40bab5:	49 c1 e4 04          	shl    r12,0x4
  40bab9:	49 81 c4 e8 98 70 00 	add    r12,0x7098e8
  40bac0:	e9 fc fe ff ff       	jmp    40b9c1 <cos_defcompinfo_child_alloc+0x71>
  40bac5:	be 30 00 00 00       	mov    esi,0x30
  40baca:	bf e8 dc 41 00       	mov    edi,0x41dce8
  40bacf:	e8 ac f1 ff ff       	call   40ac80 <cos_print_str>
	assert(defci);
  40bad4:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40badb:	00 00 00 00 
  40badf:	0f 0b                	ud2    
  40bae1:	be 31 00 00 00       	mov    esi,0x31
  40bae6:	bf 08 de 41 00       	mov    edi,0x41de08
  40baeb:	e8 90 f1 ff ff       	call   40ac80 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40baf0:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40baf7:	00 00 00 00 
  40bafb:	0f 0b                	ud2    
  40bafd:	be 31 00 00 00       	mov    esi,0x31
  40bb02:	bf 40 de 41 00       	mov    edi,0x41de40
  40bb07:	e8 74 f1 ff ff       	call   40ac80 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40bb0c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40bb13:	00 00 00 00 
  40bb17:	0f 0b                	ud2    
  40bb19:	be 31 00 00 00       	mov    esi,0x31
  40bb1e:	bf 78 de 41 00       	mov    edi,0x41de78
  40bb23:	e8 58 f1 ff ff       	call   40ac80 <cos_print_str>
	assert(aep->thd);
  40bb28:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40bb2f:	00 00 00 00 
  40bb33:	0f 0b                	ud2    
  40bb35:	be 31 00 00 00       	mov    esi,0x31
  40bb3a:	bf b0 de 41 00       	mov    edi,0x41deb0
  40bb3f:	e8 3c f1 ff ff       	call   40ac80 <cos_print_str>
		assert(aep->tc);
  40bb44:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40bb4b:	00 00 00 00 
  40bb4f:	0f 0b                	ud2    
  40bb51:	be 31 00 00 00       	mov    esi,0x31
  40bb56:	bf e8 de 41 00       	mov    edi,0x41dee8
  40bb5b:	e8 20 f1 ff ff       	call   40ac80 <cos_print_str>
	assert(aep->rcv);
  40bb60:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40bb67:	00 00 00 00 
  40bb6b:	0f 0b                	ud2    
  40bb6d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040bb70 <cos_defcompinfo_childid_init>:

void
cos_defcompinfo_childid_init(struct cos_defcompinfo *child_defci, spdid_t c)
{
  40bb70:	f3 0f 1e fa          	endbr64 
	assert(child_defci != cos_defcompinfo_curr_get());
  40bb74:	48 81 ff 60 97 70 00 	cmp    rdi,0x709760
  40bb7b:	74 04                	je     40bb81 <cos_defcompinfo_childid_init+0x11>

	child_defci->id = c;
  40bb7d:	66 89 37             	mov    WORD PTR [rdi],si
  40bb80:	c3                   	ret    
{
  40bb81:	55                   	push   rbp
  40bb82:	be 31 00 00 00       	mov    esi,0x31
  40bb87:	bf 20 df 41 00       	mov    edi,0x41df20
  40bb8c:	48 89 e5             	mov    rbp,rsp
  40bb8f:	e8 ec f0 ff ff       	call   40ac80 <cos_print_str>
	assert(child_defci != cos_defcompinfo_curr_get());
  40bb94:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40bb9b:	00 00 00 00 
  40bb9f:	0f 0b                	ud2    
  40bba1:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40bba8:	00 00 00 00 
  40bbac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000040bbb0 <cos_initaep_alloc>:
}

int
cos_initaep_alloc(struct cos_defcompinfo *dst_dci, struct cos_aep_info *sched, int is_sched)
{
  40bbb0:	f3 0f 1e fa          	endbr64 
  40bbb4:	55                   	push   rbp
  40bbb5:	48 89 e5             	mov    rbp,rsp
  40bbb8:	41 55                	push   r13
  40bbba:	49 89 fd             	mov    r13,rdi
  40bbbd:	41 54                	push   r12
  40bbbf:	49 89 f4             	mov    r12,rsi
  40bbc2:	89 d6                	mov    esi,edx
  40bbc4:	53                   	push   rbx
  40bbc5:	48 83 ec 08          	sub    rsp,0x8
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  40bbc9:	0f 01 f9             	rdtscp 
	assert(defci);
  40bbcc:	48 85 ff             	test   rdi,rdi
  40bbcf:	0f 84 1e 01 00 00    	je     40bcf3 <cos_initaep_alloc+0x143>
  40bbd5:	48 89 cf             	mov    rdi,rcx
  40bbd8:	0f 01 f9             	rdtscp 
  40bbdb:	48 89 cb             	mov    rbx,rcx
	return (long)coreid;
  40bbde:	81 e3 ff 0f 00 00    	and    ebx,0xfff
	return &(defci->sched_aep[cos_cpuid()]);
  40bbe4:	48 8d 04 5b          	lea    rax,[rbx+rbx*2]
  40bbe8:	48 c1 e0 04          	shl    rax,0x4
  40bbec:	49 8d 84 05 88 01 00 	lea    rax,[r13+rax*1+0x188]
  40bbf3:	00 
	struct cos_defcompinfo *defci     = cos_defcompinfo_curr_get();
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);
	struct cos_aep_info    *child_aep = cos_sched_aep_get(dst_dci);
	struct cos_aep_info    *sched_use = is_sched ? (sched ? sched : sched_aep) : NULL;
  40bbf4:	85 f6                	test   esi,esi
  40bbf6:	0f 85 d4 00 00 00    	jne    40bcd0 <cos_initaep_alloc+0x120>
  40bbfc:	45 31 e4             	xor    r12d,r12d
	assert(curr_defci_init_status == INITIALIZED);
  40bbff:	83 3d 62 de 2f 00 01 	cmp    DWORD PTR [rip+0x2fde62],0x1        # 709a68 <curr_defci_init_status>
  40bc06:	0f 85 03 01 00 00    	jne    40bd0f <cos_initaep_alloc+0x15f>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40bc0c:	66 0f ef c0          	pxor   xmm0,xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40bc10:	48 8d 1c 5b          	lea    rbx,[rbx+rbx*2]
  40bc14:	bf 60 97 70 00       	mov    edi,0x709760
	memset(aep, 0, sizeof(struct cos_aep_info));
  40bc19:	0f 11 00             	movups XMMWORD PTR [rax],xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40bc1c:	48 c1 e3 04          	shl    rbx,0x4
	memset(aep, 0, sizeof(struct cos_aep_info));
  40bc20:	0f 11 40 10          	movups XMMWORD PTR [rax+0x10],xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40bc24:	4c 01 eb             	add    rbx,r13
	memset(aep, 0, sizeof(struct cos_aep_info));
  40bc27:	0f 11 40 20          	movups XMMWORD PTR [rax+0x20],xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40bc2b:	49 8b 75 10          	mov    rsi,QWORD PTR [r13+0x10]
  40bc2f:	e8 2c 40 00 00       	call   40fc60 <cos_initthd_alloc>
  40bc34:	48 89 83 90 01 00 00 	mov    QWORD PTR [rbx+0x190],rax
  40bc3b:	48 89 c6             	mov    rsi,rax
	assert(aep->thd);
  40bc3e:	48 85 c0             	test   rax,rax
  40bc41:	0f 84 e4 00 00 00    	je     40bd2b <cos_initaep_alloc+0x17b>
	aep->tid  = cos_introspect(ci, aep->thd, THD_GET_TID);
  40bc47:	31 d2                	xor    edx,edx
  40bc49:	bf 60 97 70 00       	mov    edi,0x709760
  40bc4e:	e8 fd 66 00 00       	call   412350 <cos_introspect>
  40bc53:	48 98                	cdqe   
  40bc55:	48 89 83 98 01 00 00 	mov    QWORD PTR [rbx+0x198],rax
	if (!sched && is_init) return 0;
  40bc5c:	4d 85 e4             	test   r12,r12
  40bc5f:	74 60                	je     40bcc1 <cos_initaep_alloc+0x111>
		aep->tc = cos_tcap_alloc(ci);
  40bc61:	bf 60 97 70 00       	mov    edi,0x709760
  40bc66:	e8 45 67 00 00       	call   4123b0 <cos_tcap_alloc>
  40bc6b:	48 89 83 88 01 00 00 	mov    QWORD PTR [rbx+0x188],rax
  40bc72:	48 89 c2             	mov    rdx,rax
		assert(aep->tc);
  40bc75:	48 85 c0             	test   rax,rax
  40bc78:	0f 84 c9 00 00 00    	je     40bd47 <cos_initaep_alloc+0x197>
	aep->rcv  = cos_arcv_alloc(ci, aep->thd, aep->tc, ci->comp_cap, sched->rcv);
  40bc7e:	4d 8b 44 24 18       	mov    r8,QWORD PTR [r12+0x18]
  40bc83:	48 8b 0d e6 da 2f 00 	mov    rcx,QWORD PTR [rip+0x2fdae6]        # 709770 <curr_defci+0x10>
  40bc8a:	bf 60 97 70 00       	mov    edi,0x709760
  40bc8f:	48 8b b3 90 01 00 00 	mov    rsi,QWORD PTR [rbx+0x190]
  40bc96:	e8 d5 55 00 00       	call   411270 <cos_arcv_alloc>
  40bc9b:	48 89 83 a0 01 00 00 	mov    QWORD PTR [rbx+0x1a0],rax
	assert(aep->rcv);
  40bca2:	48 85 c0             	test   rax,rax
  40bca5:	0f 84 b8 00 00 00    	je     40bd63 <cos_initaep_alloc+0x1b3>
	aep->fn   = fn;
  40bcab:	48 c7 83 a8 01 00 00 	mov    QWORD PTR [rbx+0x1a8],0x0
  40bcb2:	00 00 00 00 
	aep->data = data;
  40bcb6:	48 c7 83 b0 01 00 00 	mov    QWORD PTR [rbx+0x1b0],0x0
  40bcbd:	00 00 00 00 

	return cos_aep_alloc_intern(child_aep, dst_dci, 0, sched_use, NULL, NULL, 0);
}
  40bcc1:	48 83 c4 08          	add    rsp,0x8
  40bcc5:	31 c0                	xor    eax,eax
  40bcc7:	5b                   	pop    rbx
  40bcc8:	41 5c                	pop    r12
  40bcca:	41 5d                	pop    r13
  40bccc:	5d                   	pop    rbp
  40bccd:	c3                   	ret    
  40bcce:	66 90                	xchg   ax,ax
	struct cos_aep_info    *sched_use = is_sched ? (sched ? sched : sched_aep) : NULL;
  40bcd0:	4d 85 e4             	test   r12,r12
  40bcd3:	0f 85 26 ff ff ff    	jne    40bbff <cos_initaep_alloc+0x4f>
	return &(defci->sched_aep[cos_cpuid()]);
  40bcd9:	81 e7 ff 0f 00 00    	and    edi,0xfff
  40bcdf:	4c 8d 24 7f          	lea    r12,[rdi+rdi*2]
  40bce3:	49 c1 e4 04          	shl    r12,0x4
  40bce7:	49 81 c4 e8 98 70 00 	add    r12,0x7098e8
  40bcee:	e9 0c ff ff ff       	jmp    40bbff <cos_initaep_alloc+0x4f>
  40bcf3:	be 30 00 00 00       	mov    esi,0x30
  40bcf8:	bf 20 dd 41 00       	mov    edi,0x41dd20
  40bcfd:	e8 7e ef ff ff       	call   40ac80 <cos_print_str>
	assert(defci);
  40bd02:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40bd09:	00 00 00 00 
  40bd0d:	0f 0b                	ud2    
  40bd0f:	be 31 00 00 00       	mov    esi,0x31
  40bd14:	bf 40 de 41 00       	mov    edi,0x41de40
  40bd19:	e8 62 ef ff ff       	call   40ac80 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40bd1e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40bd25:	00 00 00 00 
  40bd29:	0f 0b                	ud2    
  40bd2b:	be 31 00 00 00       	mov    esi,0x31
  40bd30:	bf 78 de 41 00       	mov    edi,0x41de78
  40bd35:	e8 46 ef ff ff       	call   40ac80 <cos_print_str>
	assert(aep->thd);
  40bd3a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40bd41:	00 00 00 00 
  40bd45:	0f 0b                	ud2    
  40bd47:	be 31 00 00 00       	mov    esi,0x31
  40bd4c:	bf b0 de 41 00       	mov    edi,0x41deb0
  40bd51:	e8 2a ef ff ff       	call   40ac80 <cos_print_str>
		assert(aep->tc);
  40bd56:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40bd5d:	00 00 00 00 
  40bd61:	0f 0b                	ud2    
  40bd63:	be 31 00 00 00       	mov    esi,0x31
  40bd68:	bf e8 de 41 00       	mov    edi,0x41dee8
  40bd6d:	e8 0e ef ff ff       	call   40ac80 <cos_print_str>
	assert(aep->rcv);
  40bd72:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40bd79:	00 00 00 00 
  40bd7d:	0f 0b                	ud2    
  40bd7f:	90                   	nop

000000000040bd80 <cos_initaep_tcap_alloc>:

int
cos_initaep_tcap_alloc(struct cos_defcompinfo *dst_dci, tcap_t tc, struct cos_aep_info *sched)
{
  40bd80:	f3 0f 1e fa          	endbr64 
  40bd84:	55                   	push   rbp
  40bd85:	48 89 e5             	mov    rbp,rsp
  40bd88:	41 57                	push   r15
  40bd8a:	41 56                	push   r14
  40bd8c:	41 55                	push   r13
  40bd8e:	49 89 d5             	mov    r13,rdx
  40bd91:	41 54                	push   r12
  40bd93:	53                   	push   rbx
  40bd94:	48 83 ec 08          	sub    rsp,0x8
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  40bd98:	0f 01 f9             	rdtscp 
	assert(defci);
  40bd9b:	48 85 ff             	test   rdi,rdi
  40bd9e:	0f 84 5d 01 00 00    	je     40bf01 <cos_initaep_tcap_alloc+0x181>
  40bda4:	49 89 f7             	mov    r15,rsi
  40bda7:	49 89 fc             	mov    r12,rdi
  40bdaa:	48 89 ce             	mov    rsi,rcx
  40bdad:	0f 01 f9             	rdtscp 
	return (long)coreid;
  40bdb0:	81 e1 ff 0f 00 00    	and    ecx,0xfff
	return &(defci->sched_aep[cos_cpuid()]);
  40bdb6:	48 8d 04 49          	lea    rax,[rcx+rcx*2]
  40bdba:	48 89 cb             	mov    rbx,rcx
  40bdbd:	48 c1 e0 04          	shl    rax,0x4
  40bdc1:	48 8d 84 07 88 01 00 	lea    rax,[rdi+rax*1+0x188]
  40bdc8:	00 
	struct cos_defcompinfo *defci     = cos_defcompinfo_curr_get();
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);
	struct cos_aep_info    *child_aep = cos_sched_aep_get(dst_dci);
	struct cos_aep_info    *sched_use = sched ? sched : sched_aep;
  40bdc9:	4d 85 ed             	test   r13,r13
  40bdcc:	0f 84 d6 00 00 00    	je     40bea8 <cos_initaep_tcap_alloc+0x128>
	assert(curr_defci_init_status == INITIALIZED);
  40bdd2:	83 3d 8f dc 2f 00 01 	cmp    DWORD PTR [rip+0x2fdc8f],0x1        # 709a68 <curr_defci_init_status>
  40bdd9:	0f 85 3e 01 00 00    	jne    40bf1d <cos_initaep_tcap_alloc+0x19d>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40bddf:	66 0f ef c0          	pxor   xmm0,xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40bde3:	4c 8d 34 5b          	lea    r14,[rbx+rbx*2]
  40bde7:	bf 60 97 70 00       	mov    edi,0x709760
	memset(aep, 0, sizeof(struct cos_aep_info));
  40bdec:	0f 11 00             	movups XMMWORD PTR [rax],xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40bdef:	49 c1 e6 04          	shl    r14,0x4
	memset(aep, 0, sizeof(struct cos_aep_info));
  40bdf3:	0f 11 40 10          	movups XMMWORD PTR [rax+0x10],xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40bdf7:	4d 01 e6             	add    r14,r12
	memset(aep, 0, sizeof(struct cos_aep_info));
  40bdfa:	0f 11 40 20          	movups XMMWORD PTR [rax+0x20],xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40bdfe:	49 8b 74 24 10       	mov    rsi,QWORD PTR [r12+0x10]
  40be03:	e8 58 3e 00 00       	call   40fc60 <cos_initthd_alloc>
  40be08:	49 89 86 90 01 00 00 	mov    QWORD PTR [r14+0x190],rax
  40be0f:	48 89 c6             	mov    rsi,rax
	assert(aep->thd);
  40be12:	48 85 c0             	test   rax,rax
  40be15:	0f 84 1e 01 00 00    	je     40bf39 <cos_initaep_tcap_alloc+0x1b9>
	aep->tid  = cos_introspect(ci, aep->thd, THD_GET_TID);
  40be1b:	31 d2                	xor    edx,edx
  40be1d:	bf 60 97 70 00       	mov    edi,0x709760
  40be22:	e8 29 65 00 00       	call   412350 <cos_introspect>
  40be27:	48 98                	cdqe   
  40be29:	49 89 86 98 01 00 00 	mov    QWORD PTR [r14+0x198],rax
	if (tc) {
  40be30:	4d 85 ff             	test   r15,r15
  40be33:	0f 84 8f 00 00 00    	je     40bec8 <cos_initaep_tcap_alloc+0x148>
		aep->tc = tc;
  40be39:	4d 89 be 88 01 00 00 	mov    QWORD PTR [r14+0x188],r15
	aep->rcv  = cos_arcv_alloc(ci, aep->thd, aep->tc, ci->comp_cap, sched->rcv);
  40be40:	48 8d 1c 5b          	lea    rbx,[rbx+rbx*2]
  40be44:	4d 8b 45 18          	mov    r8,QWORD PTR [r13+0x18]
  40be48:	4c 89 fa             	mov    rdx,r15
  40be4b:	bf 60 97 70 00       	mov    edi,0x709760
  40be50:	48 c1 e3 04          	shl    rbx,0x4
  40be54:	48 8b 0d 15 d9 2f 00 	mov    rcx,QWORD PTR [rip+0x2fd915]        # 709770 <curr_defci+0x10>
  40be5b:	4c 01 e3             	add    rbx,r12
  40be5e:	48 8b b3 90 01 00 00 	mov    rsi,QWORD PTR [rbx+0x190]
  40be65:	e8 06 54 00 00       	call   411270 <cos_arcv_alloc>
  40be6a:	48 89 83 a0 01 00 00 	mov    QWORD PTR [rbx+0x1a0],rax
	assert(aep->rcv);
  40be71:	48 85 c0             	test   rax,rax
  40be74:	0f 84 db 00 00 00    	je     40bf55 <cos_initaep_tcap_alloc+0x1d5>
	aep->fn   = fn;
  40be7a:	48 c7 83 a8 01 00 00 	mov    QWORD PTR [rbx+0x1a8],0x0
  40be81:	00 00 00 00 

	return cos_aep_alloc_intern(child_aep, dst_dci, tc, sched_use, NULL, NULL, 0);
}
  40be85:	31 c0                	xor    eax,eax
	aep->data = data;
  40be87:	48 c7 83 b0 01 00 00 	mov    QWORD PTR [rbx+0x1b0],0x0
  40be8e:	00 00 00 00 
}
  40be92:	48 83 c4 08          	add    rsp,0x8
  40be96:	5b                   	pop    rbx
  40be97:	41 5c                	pop    r12
  40be99:	41 5d                	pop    r13
  40be9b:	41 5e                	pop    r14
  40be9d:	41 5f                	pop    r15
  40be9f:	5d                   	pop    rbp
  40bea0:	c3                   	ret    
  40bea1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	return &(defci->sched_aep[cos_cpuid()]);
  40bea8:	81 e6 ff 0f 00 00    	and    esi,0xfff
  40beae:	4c 8d 2c 76          	lea    r13,[rsi+rsi*2]
  40beb2:	49 c1 e5 04          	shl    r13,0x4
  40beb6:	49 81 c5 e8 98 70 00 	add    r13,0x7098e8
  40bebd:	e9 10 ff ff ff       	jmp    40bdd2 <cos_initaep_tcap_alloc+0x52>
  40bec2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
		aep->tc = cos_tcap_alloc(ci);
  40bec8:	bf 60 97 70 00       	mov    edi,0x709760
  40becd:	e8 de 64 00 00       	call   4123b0 <cos_tcap_alloc>
  40bed2:	49 89 86 88 01 00 00 	mov    QWORD PTR [r14+0x188],rax
  40bed9:	49 89 c7             	mov    r15,rax
		assert(aep->tc);
  40bedc:	48 85 c0             	test   rax,rax
  40bedf:	0f 85 5b ff ff ff    	jne    40be40 <cos_initaep_tcap_alloc+0xc0>
  40bee5:	be 31 00 00 00       	mov    esi,0x31
  40beea:	bf b0 de 41 00       	mov    edi,0x41deb0
  40beef:	e8 8c ed ff ff       	call   40ac80 <cos_print_str>
  40bef4:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40befb:	00 00 00 00 
  40beff:	0f 0b                	ud2    
  40bf01:	be 30 00 00 00       	mov    esi,0x30
  40bf06:	bf 20 dd 41 00       	mov    edi,0x41dd20
  40bf0b:	e8 70 ed ff ff       	call   40ac80 <cos_print_str>
	assert(defci);
  40bf10:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40bf17:	00 00 00 00 
  40bf1b:	0f 0b                	ud2    
  40bf1d:	be 31 00 00 00       	mov    esi,0x31
  40bf22:	bf 40 de 41 00       	mov    edi,0x41de40
  40bf27:	e8 54 ed ff ff       	call   40ac80 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40bf2c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40bf33:	00 00 00 00 
  40bf37:	0f 0b                	ud2    
  40bf39:	be 31 00 00 00       	mov    esi,0x31
  40bf3e:	bf 78 de 41 00       	mov    edi,0x41de78
  40bf43:	e8 38 ed ff ff       	call   40ac80 <cos_print_str>
	assert(aep->thd);
  40bf48:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40bf4f:	00 00 00 00 
  40bf53:	0f 0b                	ud2    
  40bf55:	be 31 00 00 00       	mov    esi,0x31
  40bf5a:	bf e8 de 41 00       	mov    edi,0x41dee8
  40bf5f:	e8 1c ed ff ff       	call   40ac80 <cos_print_str>
	assert(aep->rcv);
  40bf64:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40bf6b:	00 00 00 00 
  40bf6f:	0f 0b                	ud2    
  40bf71:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40bf78:	00 00 00 00 
  40bf7c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000040bf80 <cos_aep_alloc_ext>:

int
cos_aep_alloc_ext(struct cos_aep_info *aep, struct cos_defcompinfo *dst_dci, struct cos_aep_info *sched, thdclosure_index_t idx)
{
  40bf80:	f3 0f 1e fa          	endbr64 
  40bf84:	55                   	push   rbp
  40bf85:	41 89 c8             	mov    r8d,ecx
  40bf88:	48 89 e5             	mov    rbp,rsp
  40bf8b:	41 54                	push   r12
  40bf8d:	49 89 d4             	mov    r12,rdx
  40bf90:	53                   	push   rbx
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  40bf91:	0f 01 f9             	rdtscp 
	struct cos_defcompinfo *defci     = cos_defcompinfo_curr_get();
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);

	assert(aep && idx > 0);
  40bf94:	48 85 ff             	test   rdi,rdi
  40bf97:	0f 84 fb 00 00 00    	je     40c098 <cos_aep_alloc_ext+0x118>
  40bf9d:	45 85 c0             	test   r8d,r8d
  40bfa0:	0f 8e f2 00 00 00    	jle    40c098 <cos_aep_alloc_ext+0x118>
  40bfa6:	48 89 fb             	mov    rbx,rdi
	if (!sched) sched_aep = cos_sched_aep_get(dst_dci);
  40bfa9:	4d 85 e4             	test   r12,r12
  40bfac:	74 22                	je     40bfd0 <cos_aep_alloc_ext+0x50>
	assert(defci);
  40bfae:	48 85 f6             	test   rsi,rsi
  40bfb1:	75 3f                	jne    40bff2 <cos_aep_alloc_ext+0x72>
  40bfb3:	be 30 00 00 00       	mov    esi,0x30
  40bfb8:	bf e8 dc 41 00       	mov    edi,0x41dce8
  40bfbd:	e8 be ec ff ff       	call   40ac80 <cos_print_str>
  40bfc2:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40bfc9:	00 00 00 00 
  40bfcd:	0f 0b                	ud2    
  40bfcf:	90                   	nop
	assert(defci);
  40bfd0:	48 85 f6             	test   rsi,rsi
  40bfd3:	0f 84 37 01 00 00    	je     40c110 <cos_aep_alloc_ext+0x190>
  40bfd9:	0f 01 f9             	rdtscp 
	return &(defci->sched_aep[cos_cpuid()]);
  40bfdc:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  40bfe2:	48 8d 04 49          	lea    rax,[rcx+rcx*2]
  40bfe6:	48 c1 e0 04          	shl    rax,0x4
  40bfea:	4c 8d a4 06 88 01 00 	lea    r12,[rsi+rax*1+0x188]
  40bff1:	00 
	assert(curr_defci_init_status == INITIALIZED);
  40bff2:	83 3d 6f da 2f 00 01 	cmp    DWORD PTR [rip+0x2fda6f],0x1        # 709a68 <curr_defci_init_status>
  40bff9:	0f 85 b9 00 00 00    	jne    40c0b8 <cos_aep_alloc_ext+0x138>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40bfff:	66 0f ef c0          	pxor   xmm0,xmm0
	else if (idx > 0) aep->thd = cos_thd_alloc_ext(ci, dst_ci->comp_cap, idx);
  40c003:	44 89 c2             	mov    edx,r8d
  40c006:	bf 60 97 70 00       	mov    edi,0x709760
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c00b:	0f 11 03             	movups XMMWORD PTR [rbx],xmm0
  40c00e:	0f 11 43 10          	movups XMMWORD PTR [rbx+0x10],xmm0
  40c012:	0f 11 43 20          	movups XMMWORD PTR [rbx+0x20],xmm0
	else if (idx > 0) aep->thd = cos_thd_alloc_ext(ci, dst_ci->comp_cap, idx);
  40c016:	48 8b 76 10          	mov    rsi,QWORD PTR [rsi+0x10]
  40c01a:	e8 f1 29 00 00       	call   40ea10 <cos_thd_alloc_ext>
  40c01f:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  40c023:	48 89 c6             	mov    rsi,rax
	assert(aep->thd);
  40c026:	48 85 c0             	test   rax,rax
  40c029:	0f 84 a9 00 00 00    	je     40c0d8 <cos_aep_alloc_ext+0x158>
	aep->tid  = cos_introspect(ci, aep->thd, THD_GET_TID);
  40c02f:	31 d2                	xor    edx,edx
  40c031:	bf 60 97 70 00       	mov    edi,0x709760
  40c036:	e8 15 63 00 00       	call   412350 <cos_introspect>
		aep->tc = cos_tcap_alloc(ci);
  40c03b:	bf 60 97 70 00       	mov    edi,0x709760
	aep->tid  = cos_introspect(ci, aep->thd, THD_GET_TID);
  40c040:	48 98                	cdqe   
  40c042:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
		aep->tc = cos_tcap_alloc(ci);
  40c046:	e8 65 63 00 00       	call   4123b0 <cos_tcap_alloc>
  40c04b:	48 89 03             	mov    QWORD PTR [rbx],rax
  40c04e:	48 89 c2             	mov    rdx,rax
		assert(aep->tc);
  40c051:	48 85 c0             	test   rax,rax
  40c054:	0f 84 9a 00 00 00    	je     40c0f4 <cos_aep_alloc_ext+0x174>
	aep->rcv  = cos_arcv_alloc(ci, aep->thd, aep->tc, ci->comp_cap, sched->rcv);
  40c05a:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
  40c05e:	4d 8b 44 24 18       	mov    r8,QWORD PTR [r12+0x18]
  40c063:	bf 60 97 70 00       	mov    edi,0x709760
  40c068:	48 8b 0d 01 d7 2f 00 	mov    rcx,QWORD PTR [rip+0x2fd701]        # 709770 <curr_defci+0x10>
  40c06f:	e8 fc 51 00 00       	call   411270 <cos_arcv_alloc>
  40c074:	48 89 43 18          	mov    QWORD PTR [rbx+0x18],rax
	assert(aep->rcv);
  40c078:	48 85 c0             	test   rax,rax
  40c07b:	0f 84 ab 00 00 00    	je     40c12c <cos_aep_alloc_ext+0x1ac>
	aep->fn   = fn;
  40c081:	48 c7 43 20 00 00 00 	mov    QWORD PTR [rbx+0x20],0x0
  40c088:	00 
	else        sched_aep = sched;

	return cos_aep_alloc_intern(aep, dst_dci, 0, sched_aep, NULL, NULL, idx);
}
  40c089:	31 c0                	xor    eax,eax
	aep->data = data;
  40c08b:	48 c7 43 28 00 00 00 	mov    QWORD PTR [rbx+0x28],0x0
  40c092:	00 
}
  40c093:	5b                   	pop    rbx
  40c094:	41 5c                	pop    r12
  40c096:	5d                   	pop    rbp
  40c097:	c3                   	ret    
  40c098:	be 31 00 00 00       	mov    esi,0x31
  40c09d:	bf 58 df 41 00       	mov    edi,0x41df58
  40c0a2:	e8 d9 eb ff ff       	call   40ac80 <cos_print_str>
	assert(aep && idx > 0);
  40c0a7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c0ae:	00 00 00 00 
  40c0b2:	0f 0b                	ud2    
  40c0b4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  40c0b8:	be 31 00 00 00       	mov    esi,0x31
  40c0bd:	bf 40 de 41 00       	mov    edi,0x41de40
  40c0c2:	e8 b9 eb ff ff       	call   40ac80 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40c0c7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c0ce:	00 00 00 00 
  40c0d2:	0f 0b                	ud2    
  40c0d4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  40c0d8:	be 31 00 00 00       	mov    esi,0x31
  40c0dd:	bf 78 de 41 00       	mov    edi,0x41de78
  40c0e2:	e8 99 eb ff ff       	call   40ac80 <cos_print_str>
	assert(aep->thd);
  40c0e7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c0ee:	00 00 00 00 
  40c0f2:	0f 0b                	ud2    
  40c0f4:	be 31 00 00 00       	mov    esi,0x31
  40c0f9:	bf b0 de 41 00       	mov    edi,0x41deb0
  40c0fe:	e8 7d eb ff ff       	call   40ac80 <cos_print_str>
		assert(aep->tc);
  40c103:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c10a:	00 00 00 00 
  40c10e:	0f 0b                	ud2    
  40c110:	be 30 00 00 00       	mov    esi,0x30
  40c115:	bf 20 dd 41 00       	mov    edi,0x41dd20
  40c11a:	e8 61 eb ff ff       	call   40ac80 <cos_print_str>
	assert(defci);
  40c11f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c126:	00 00 00 00 
  40c12a:	0f 0b                	ud2    
  40c12c:	be 31 00 00 00       	mov    esi,0x31
  40c131:	bf e8 de 41 00       	mov    edi,0x41dee8
  40c136:	e8 45 eb ff ff       	call   40ac80 <cos_print_str>
	assert(aep->rcv);
  40c13b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c142:	00 00 00 00 
  40c146:	0f 0b                	ud2    
  40c148:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40c14f:	00 

000000000040c150 <cos_aep_tcap_alloc_ext>:

int
cos_aep_tcap_alloc_ext(struct cos_aep_info *aep, struct cos_defcompinfo *dst_dci, struct cos_aep_info *sched, tcap_t tc, thdclosure_index_t idx)
{
  40c150:	f3 0f 1e fa          	endbr64 
  40c154:	55                   	push   rbp
  40c155:	48 89 e5             	mov    rbp,rsp
  40c158:	41 55                	push   r13
  40c15a:	49 89 d5             	mov    r13,rdx
  40c15d:	41 54                	push   r12
  40c15f:	49 89 cc             	mov    r12,rcx
  40c162:	53                   	push   rbx
  40c163:	48 83 ec 08          	sub    rsp,0x8
  40c167:	0f 01 f9             	rdtscp 
	struct cos_defcompinfo *defci     = cos_defcompinfo_curr_get();
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);

	assert(aep);
  40c16a:	48 85 ff             	test   rdi,rdi
  40c16d:	0f 84 22 01 00 00    	je     40c295 <cos_aep_tcap_alloc_ext+0x145>
	assert(idx > 0);
  40c173:	45 85 c0             	test   r8d,r8d
  40c176:	0f 8e 35 01 00 00    	jle    40c2b1 <cos_aep_tcap_alloc_ext+0x161>
  40c17c:	48 89 fb             	mov    rbx,rdi
	if (!sched) sched_aep = cos_sched_aep_get(dst_dci);
  40c17f:	4d 85 ed             	test   r13,r13
  40c182:	0f 84 a8 00 00 00    	je     40c230 <cos_aep_tcap_alloc_ext+0xe0>
	assert(defci);
  40c188:	48 85 f6             	test   rsi,rsi
  40c18b:	0f 84 3c 01 00 00    	je     40c2cd <cos_aep_tcap_alloc_ext+0x17d>
	assert(curr_defci_init_status == INITIALIZED);
  40c191:	83 3d d0 d8 2f 00 01 	cmp    DWORD PTR [rip+0x2fd8d0],0x1        # 709a68 <curr_defci_init_status>
  40c198:	0f 85 4b 01 00 00    	jne    40c2e9 <cos_aep_tcap_alloc_ext+0x199>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c19e:	66 0f ef c0          	pxor   xmm0,xmm0
	else if (idx > 0) aep->thd = cos_thd_alloc_ext(ci, dst_ci->comp_cap, idx);
  40c1a2:	44 89 c2             	mov    edx,r8d
  40c1a5:	bf 60 97 70 00       	mov    edi,0x709760
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c1aa:	0f 11 03             	movups XMMWORD PTR [rbx],xmm0
  40c1ad:	0f 11 43 10          	movups XMMWORD PTR [rbx+0x10],xmm0
  40c1b1:	0f 11 43 20          	movups XMMWORD PTR [rbx+0x20],xmm0
	else if (idx > 0) aep->thd = cos_thd_alloc_ext(ci, dst_ci->comp_cap, idx);
  40c1b5:	48 8b 76 10          	mov    rsi,QWORD PTR [rsi+0x10]
  40c1b9:	e8 52 28 00 00       	call   40ea10 <cos_thd_alloc_ext>
  40c1be:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  40c1c2:	48 89 c6             	mov    rsi,rax
	assert(aep->thd);
  40c1c5:	48 85 c0             	test   rax,rax
  40c1c8:	0f 84 37 01 00 00    	je     40c305 <cos_aep_tcap_alloc_ext+0x1b5>
	aep->tid  = cos_introspect(ci, aep->thd, THD_GET_TID);
  40c1ce:	31 d2                	xor    edx,edx
  40c1d0:	bf 60 97 70 00       	mov    edi,0x709760
  40c1d5:	e8 76 61 00 00       	call   412350 <cos_introspect>
  40c1da:	48 98                	cdqe   
  40c1dc:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
	if (tc) {
  40c1e0:	4d 85 e4             	test   r12,r12
  40c1e3:	74 7b                	je     40c260 <cos_aep_tcap_alloc_ext+0x110>
		aep->tc = tc;
  40c1e5:	4c 89 23             	mov    QWORD PTR [rbx],r12
	aep->rcv  = cos_arcv_alloc(ci, aep->thd, aep->tc, ci->comp_cap, sched->rcv);
  40c1e8:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
  40c1ec:	4d 8b 45 18          	mov    r8,QWORD PTR [r13+0x18]
  40c1f0:	4c 89 e2             	mov    rdx,r12
  40c1f3:	bf 60 97 70 00       	mov    edi,0x709760
  40c1f8:	48 8b 0d 71 d5 2f 00 	mov    rcx,QWORD PTR [rip+0x2fd571]        # 709770 <curr_defci+0x10>
  40c1ff:	e8 6c 50 00 00       	call   411270 <cos_arcv_alloc>
  40c204:	48 89 43 18          	mov    QWORD PTR [rbx+0x18],rax
	assert(aep->rcv);
  40c208:	48 85 c0             	test   rax,rax
  40c20b:	0f 84 2c 01 00 00    	je     40c33d <cos_aep_tcap_alloc_ext+0x1ed>
	aep->fn   = fn;
  40c211:	48 c7 43 20 00 00 00 	mov    QWORD PTR [rbx+0x20],0x0
  40c218:	00 
	else        sched_aep = sched;

	return cos_aep_alloc_intern(aep, dst_dci, tc, sched_aep, NULL, NULL, idx);
}
  40c219:	31 c0                	xor    eax,eax
	aep->data = data;
  40c21b:	48 c7 43 28 00 00 00 	mov    QWORD PTR [rbx+0x28],0x0
  40c222:	00 
}
  40c223:	48 83 c4 08          	add    rsp,0x8
  40c227:	5b                   	pop    rbx
  40c228:	41 5c                	pop    r12
  40c22a:	41 5d                	pop    r13
  40c22c:	5d                   	pop    rbp
  40c22d:	c3                   	ret    
  40c22e:	66 90                	xchg   ax,ax
	assert(defci);
  40c230:	48 85 f6             	test   rsi,rsi
  40c233:	0f 84 e8 00 00 00    	je     40c321 <cos_aep_tcap_alloc_ext+0x1d1>
  40c239:	0f 01 f9             	rdtscp 
	return &(defci->sched_aep[cos_cpuid()]);
  40c23c:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  40c242:	48 8d 04 49          	lea    rax,[rcx+rcx*2]
  40c246:	48 c1 e0 04          	shl    rax,0x4
  40c24a:	4c 8d ac 06 88 01 00 	lea    r13,[rsi+rax*1+0x188]
  40c251:	00 
	assert(defci);
  40c252:	e9 3a ff ff ff       	jmp    40c191 <cos_aep_tcap_alloc_ext+0x41>
  40c257:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40c25e:	00 00 
		aep->tc = cos_tcap_alloc(ci);
  40c260:	bf 60 97 70 00       	mov    edi,0x709760
  40c265:	e8 46 61 00 00       	call   4123b0 <cos_tcap_alloc>
  40c26a:	48 89 03             	mov    QWORD PTR [rbx],rax
  40c26d:	49 89 c4             	mov    r12,rax
		assert(aep->tc);
  40c270:	48 85 c0             	test   rax,rax
  40c273:	0f 85 6f ff ff ff    	jne    40c1e8 <cos_aep_tcap_alloc_ext+0x98>
  40c279:	be 31 00 00 00       	mov    esi,0x31
  40c27e:	bf b0 de 41 00       	mov    edi,0x41deb0
  40c283:	e8 f8 e9 ff ff       	call   40ac80 <cos_print_str>
  40c288:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c28f:	00 00 00 00 
  40c293:	0f 0b                	ud2    
  40c295:	be 31 00 00 00       	mov    esi,0x31
  40c29a:	bf 90 df 41 00       	mov    edi,0x41df90
  40c29f:	e8 dc e9 ff ff       	call   40ac80 <cos_print_str>
	assert(aep);
  40c2a4:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c2ab:	00 00 00 00 
  40c2af:	0f 0b                	ud2    
  40c2b1:	be 31 00 00 00       	mov    esi,0x31
  40c2b6:	bf c8 df 41 00       	mov    edi,0x41dfc8
  40c2bb:	e8 c0 e9 ff ff       	call   40ac80 <cos_print_str>
	assert(idx > 0);
  40c2c0:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c2c7:	00 00 00 00 
  40c2cb:	0f 0b                	ud2    
  40c2cd:	be 30 00 00 00       	mov    esi,0x30
  40c2d2:	bf e8 dc 41 00       	mov    edi,0x41dce8
  40c2d7:	e8 a4 e9 ff ff       	call   40ac80 <cos_print_str>
	assert(defci);
  40c2dc:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c2e3:	00 00 00 00 
  40c2e7:	0f 0b                	ud2    
  40c2e9:	be 31 00 00 00       	mov    esi,0x31
  40c2ee:	bf 40 de 41 00       	mov    edi,0x41de40
  40c2f3:	e8 88 e9 ff ff       	call   40ac80 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40c2f8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c2ff:	00 00 00 00 
  40c303:	0f 0b                	ud2    
  40c305:	be 31 00 00 00       	mov    esi,0x31
  40c30a:	bf 78 de 41 00       	mov    edi,0x41de78
  40c30f:	e8 6c e9 ff ff       	call   40ac80 <cos_print_str>
	assert(aep->thd);
  40c314:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c31b:	00 00 00 00 
  40c31f:	0f 0b                	ud2    
  40c321:	be 30 00 00 00       	mov    esi,0x30
  40c326:	bf 20 dd 41 00       	mov    edi,0x41dd20
  40c32b:	e8 50 e9 ff ff       	call   40ac80 <cos_print_str>
	assert(defci);
  40c330:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c337:	00 00 00 00 
  40c33b:	0f 0b                	ud2    
  40c33d:	be 31 00 00 00       	mov    esi,0x31
  40c342:	bf e8 de 41 00       	mov    edi,0x41dee8
  40c347:	e8 34 e9 ff ff       	call   40ac80 <cos_print_str>
	assert(aep->rcv);
  40c34c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c353:	00 00 00 00 
  40c357:	0f 0b                	ud2    
  40c359:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000040c360 <cos_aep_alloc>:

int
cos_aep_alloc(struct cos_aep_info *aep, cos_aepthd_fn_t fn, void *data)
{
  40c360:	f3 0f 1e fa          	endbr64 
  40c364:	55                   	push   rbp
  40c365:	48 89 e5             	mov    rbp,rsp
  40c368:	41 56                	push   r14
  40c36a:	41 55                	push   r13
  40c36c:	49 89 d5             	mov    r13,rdx
  40c36f:	41 54                	push   r12
  40c371:	49 89 f4             	mov    r12,rsi
  40c374:	53                   	push   rbx
  40c375:	48 89 fb             	mov    rbx,rdi
  40c378:	0f 01 f9             	rdtscp 
  40c37b:	49 89 ce             	mov    r14,rcx
	int                     is_init = (!fn && !data && !idx);
  40c37e:	4c 89 e9             	mov    rcx,r13
	assert(curr_defci_init_status == INITIALIZED);
  40c381:	8b 05 e1 d6 2f 00    	mov    eax,DWORD PTR [rip+0x2fd6e1]        # 709a68 <curr_defci_init_status>
	int                     is_init = (!fn && !data && !idx);
  40c387:	48 09 f1             	or     rcx,rsi
  40c38a:	0f 85 b0 00 00 00    	jne    40c440 <cos_aep_alloc+0xe0>
	assert(curr_defci_init_status == INITIALIZED);
  40c390:	83 f8 01             	cmp    eax,0x1
  40c393:	0f 85 df 00 00 00    	jne    40c478 <cos_aep_alloc+0x118>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c399:	66 0f ef c0          	pxor   xmm0,xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40c39d:	bf 60 97 70 00       	mov    edi,0x709760
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c3a2:	0f 11 03             	movups XMMWORD PTR [rbx],xmm0
  40c3a5:	0f 11 43 10          	movups XMMWORD PTR [rbx+0x10],xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40c3a9:	48 8b 35 c0 d3 2f 00 	mov    rsi,QWORD PTR [rip+0x2fd3c0]        # 709770 <curr_defci+0x10>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c3b0:	0f 11 43 20          	movups XMMWORD PTR [rbx+0x20],xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40c3b4:	e8 a7 38 00 00       	call   40fc60 <cos_initthd_alloc>
  40c3b9:	48 89 c6             	mov    rsi,rax
  40c3bc:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
	assert(aep->thd);
  40c3c0:	48 85 f6             	test   rsi,rsi
  40c3c3:	0f 84 cb 00 00 00    	je     40c494 <cos_aep_alloc+0x134>
	aep->tid  = cos_introspect(ci, aep->thd, THD_GET_TID);
  40c3c9:	31 d2                	xor    edx,edx
  40c3cb:	bf 60 97 70 00       	mov    edi,0x709760
  40c3d0:	e8 7b 5f 00 00       	call   412350 <cos_introspect>
		aep->tc = cos_tcap_alloc(ci);
  40c3d5:	bf 60 97 70 00       	mov    edi,0x709760
	aep->tid  = cos_introspect(ci, aep->thd, THD_GET_TID);
  40c3da:	48 98                	cdqe   
  40c3dc:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
		aep->tc = cos_tcap_alloc(ci);
  40c3e0:	e8 cb 5f 00 00       	call   4123b0 <cos_tcap_alloc>
  40c3e5:	48 89 03             	mov    QWORD PTR [rbx],rax
  40c3e8:	48 89 c2             	mov    rdx,rax
		assert(aep->tc);
  40c3eb:	48 85 c0             	test   rax,rax
  40c3ee:	0f 84 bc 00 00 00    	je     40c4b0 <cos_aep_alloc+0x150>
	return (long)coreid;
  40c3f4:	41 81 e6 ff 0f 00 00 	and    r14d,0xfff
	aep->rcv  = cos_arcv_alloc(ci, aep->thd, aep->tc, ci->comp_cap, sched->rcv);
  40c3fb:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
  40c3ff:	bf 60 97 70 00       	mov    edi,0x709760
  40c404:	48 8b 0d 65 d3 2f 00 	mov    rcx,QWORD PTR [rip+0x2fd365]        # 709770 <curr_defci+0x10>
  40c40b:	4b 8d 04 76          	lea    rax,[r14+r14*2]
  40c40f:	48 c1 e0 04          	shl    rax,0x4
  40c413:	4c 8b 80 00 99 70 00 	mov    r8,QWORD PTR [rax+0x709900]
  40c41a:	e8 51 4e 00 00       	call   411270 <cos_arcv_alloc>
  40c41f:	48 89 43 18          	mov    QWORD PTR [rbx+0x18],rax
	assert(aep->rcv);
  40c423:	48 85 c0             	test   rax,rax
  40c426:	0f 84 a0 00 00 00    	je     40c4cc <cos_aep_alloc+0x16c>
	aep->fn   = fn;
  40c42c:	4c 89 63 20          	mov    QWORD PTR [rbx+0x20],r12
	struct cos_defcompinfo *defci     = cos_defcompinfo_curr_get();
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);

	return cos_aep_alloc_intern(aep, defci, 0, sched_aep, fn, data, 0);
}
  40c430:	31 c0                	xor    eax,eax
	aep->data = data;
  40c432:	4c 89 6b 28          	mov    QWORD PTR [rbx+0x28],r13
}
  40c436:	5b                   	pop    rbx
  40c437:	41 5c                	pop    r12
  40c439:	41 5d                	pop    r13
  40c43b:	41 5e                	pop    r14
  40c43d:	5d                   	pop    rbp
  40c43e:	c3                   	ret    
  40c43f:	90                   	nop
	assert(curr_defci_init_status == INITIALIZED);
  40c440:	83 f8 01             	cmp    eax,0x1
  40c443:	75 33                	jne    40c478 <cos_aep_alloc+0x118>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c445:	66 0f ef c0          	pxor   xmm0,xmm0
	else              aep->thd = cos_thd_alloc(ci, dst_ci->comp_cap, cos_aepthd_fn, (void *)aep);
  40c449:	48 89 d9             	mov    rcx,rbx
  40c44c:	ba 10 b5 40 00       	mov    edx,0x40b510
  40c451:	bf 60 97 70 00       	mov    edi,0x709760
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c456:	0f 11 03             	movups XMMWORD PTR [rbx],xmm0
  40c459:	0f 11 43 10          	movups XMMWORD PTR [rbx+0x10],xmm0
	else              aep->thd = cos_thd_alloc(ci, dst_ci->comp_cap, cos_aepthd_fn, (void *)aep);
  40c45d:	48 8b 35 0c d3 2f 00 	mov    rsi,QWORD PTR [rip+0x2fd30c]        # 709770 <curr_defci+0x10>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c464:	0f 11 43 20          	movups XMMWORD PTR [rbx+0x20],xmm0
	else              aep->thd = cos_thd_alloc(ci, dst_ci->comp_cap, cos_aepthd_fn, (void *)aep);
  40c468:	e8 33 28 00 00       	call   40eca0 <cos_thd_alloc>
  40c46d:	48 89 c6             	mov    rsi,rax
  40c470:	e9 47 ff ff ff       	jmp    40c3bc <cos_aep_alloc+0x5c>
  40c475:	0f 1f 00             	nop    DWORD PTR [rax]
  40c478:	be 31 00 00 00       	mov    esi,0x31
  40c47d:	bf 40 de 41 00       	mov    edi,0x41de40
  40c482:	e8 f9 e7 ff ff       	call   40ac80 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40c487:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c48e:	00 00 00 00 
  40c492:	0f 0b                	ud2    
  40c494:	be 31 00 00 00       	mov    esi,0x31
  40c499:	bf 78 de 41 00       	mov    edi,0x41de78
  40c49e:	e8 dd e7 ff ff       	call   40ac80 <cos_print_str>
	assert(aep->thd);
  40c4a3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c4aa:	00 00 00 00 
  40c4ae:	0f 0b                	ud2    
  40c4b0:	be 31 00 00 00       	mov    esi,0x31
  40c4b5:	bf b0 de 41 00       	mov    edi,0x41deb0
  40c4ba:	e8 c1 e7 ff ff       	call   40ac80 <cos_print_str>
		assert(aep->tc);
  40c4bf:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c4c6:	00 00 00 00 
  40c4ca:	0f 0b                	ud2    
  40c4cc:	be 31 00 00 00       	mov    esi,0x31
  40c4d1:	bf e8 de 41 00       	mov    edi,0x41dee8
  40c4d6:	e8 a5 e7 ff ff       	call   40ac80 <cos_print_str>
	assert(aep->rcv);
  40c4db:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c4e2:	00 00 00 00 
  40c4e6:	0f 0b                	ud2    
  40c4e8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40c4ef:	00 

000000000040c4f0 <cos_aep_tcap_alloc>:

int
cos_aep_tcap_alloc(struct cos_aep_info *aep, tcap_t tc, cos_aepthd_fn_t fn, void *data)
{
  40c4f0:	f3 0f 1e fa          	endbr64 
  40c4f4:	55                   	push   rbp
  40c4f5:	48 89 e5             	mov    rbp,rsp
  40c4f8:	41 57                	push   r15
  40c4fa:	41 56                	push   r14
  40c4fc:	49 89 ce             	mov    r14,rcx
  40c4ff:	41 55                	push   r13
  40c501:	49 89 d5             	mov    r13,rdx
  40c504:	41 54                	push   r12
  40c506:	49 89 f4             	mov    r12,rsi
  40c509:	53                   	push   rbx
  40c50a:	48 89 fb             	mov    rbx,rdi
  40c50d:	48 83 ec 08          	sub    rsp,0x8
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  40c511:	0f 01 f9             	rdtscp 
	int                     is_init = (!fn && !data && !idx);
  40c514:	4c 89 f7             	mov    rdi,r14
	assert(curr_defci_init_status == INITIALIZED);
  40c517:	8b 05 4b d5 2f 00    	mov    eax,DWORD PTR [rip+0x2fd54b]        # 709a68 <curr_defci_init_status>
  40c51d:	49 89 cf             	mov    r15,rcx
	int                     is_init = (!fn && !data && !idx);
  40c520:	4c 09 ef             	or     rdi,r13
  40c523:	0f 85 af 00 00 00    	jne    40c5d8 <cos_aep_tcap_alloc+0xe8>
	assert(curr_defci_init_status == INITIALIZED);
  40c529:	83 f8 01             	cmp    eax,0x1
  40c52c:	0f 85 de 00 00 00    	jne    40c610 <cos_aep_tcap_alloc+0x120>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c532:	66 0f ef c0          	pxor   xmm0,xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40c536:	bf 60 97 70 00       	mov    edi,0x709760
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c53b:	0f 11 03             	movups XMMWORD PTR [rbx],xmm0
  40c53e:	0f 11 43 10          	movups XMMWORD PTR [rbx+0x10],xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40c542:	48 8b 35 27 d2 2f 00 	mov    rsi,QWORD PTR [rip+0x2fd227]        # 709770 <curr_defci+0x10>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c549:	0f 11 43 20          	movups XMMWORD PTR [rbx+0x20],xmm0
	if (is_init)      aep->thd = cos_initthd_alloc(ci, dst_ci->comp_cap);
  40c54d:	e8 0e 37 00 00       	call   40fc60 <cos_initthd_alloc>
  40c552:	48 89 c6             	mov    rsi,rax
  40c555:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
	assert(aep->thd);
  40c559:	48 85 f6             	test   rsi,rsi
  40c55c:	0f 84 03 01 00 00    	je     40c665 <cos_aep_tcap_alloc+0x175>
	aep->tid  = cos_introspect(ci, aep->thd, THD_GET_TID);
  40c562:	31 d2                	xor    edx,edx
  40c564:	bf 60 97 70 00       	mov    edi,0x709760
  40c569:	e8 e2 5d 00 00       	call   412350 <cos_introspect>
  40c56e:	48 98                	cdqe   
  40c570:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
	if (tc) {
  40c574:	4d 85 e4             	test   r12,r12
  40c577:	0f 84 b3 00 00 00    	je     40c630 <cos_aep_tcap_alloc+0x140>
		aep->tc = tc;
  40c57d:	4c 89 23             	mov    QWORD PTR [rbx],r12
	return (long)coreid;
  40c580:	41 81 e7 ff 0f 00 00 	and    r15d,0xfff
	aep->rcv  = cos_arcv_alloc(ci, aep->thd, aep->tc, ci->comp_cap, sched->rcv);
  40c587:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
  40c58b:	4c 89 e2             	mov    rdx,r12
  40c58e:	bf 60 97 70 00       	mov    edi,0x709760
  40c593:	4b 8d 04 7f          	lea    rax,[r15+r15*2]
  40c597:	48 8b 0d d2 d1 2f 00 	mov    rcx,QWORD PTR [rip+0x2fd1d2]        # 709770 <curr_defci+0x10>
  40c59e:	48 c1 e0 04          	shl    rax,0x4
  40c5a2:	4c 8b 80 00 99 70 00 	mov    r8,QWORD PTR [rax+0x709900]
  40c5a9:	e8 c2 4c 00 00       	call   411270 <cos_arcv_alloc>
  40c5ae:	48 89 43 18          	mov    QWORD PTR [rbx+0x18],rax
	assert(aep->rcv);
  40c5b2:	48 85 c0             	test   rax,rax
  40c5b5:	0f 84 c6 00 00 00    	je     40c681 <cos_aep_tcap_alloc+0x191>
	aep->fn   = fn;
  40c5bb:	4c 89 6b 20          	mov    QWORD PTR [rbx+0x20],r13
	struct cos_defcompinfo *defci     = cos_defcompinfo_curr_get();
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);

	return cos_aep_alloc_intern(aep, defci, tc, sched_aep, fn, data, 0);
}
  40c5bf:	31 c0                	xor    eax,eax
	aep->data = data;
  40c5c1:	4c 89 73 28          	mov    QWORD PTR [rbx+0x28],r14
}
  40c5c5:	48 83 c4 08          	add    rsp,0x8
  40c5c9:	5b                   	pop    rbx
  40c5ca:	41 5c                	pop    r12
  40c5cc:	41 5d                	pop    r13
  40c5ce:	41 5e                	pop    r14
  40c5d0:	41 5f                	pop    r15
  40c5d2:	5d                   	pop    rbp
  40c5d3:	c3                   	ret    
  40c5d4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	assert(curr_defci_init_status == INITIALIZED);
  40c5d8:	83 f8 01             	cmp    eax,0x1
  40c5db:	75 33                	jne    40c610 <cos_aep_tcap_alloc+0x120>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c5dd:	66 0f ef c0          	pxor   xmm0,xmm0
	else              aep->thd = cos_thd_alloc(ci, dst_ci->comp_cap, cos_aepthd_fn, (void *)aep);
  40c5e1:	48 89 d9             	mov    rcx,rbx
  40c5e4:	ba 10 b5 40 00       	mov    edx,0x40b510
  40c5e9:	bf 60 97 70 00       	mov    edi,0x709760
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c5ee:	0f 11 03             	movups XMMWORD PTR [rbx],xmm0
  40c5f1:	0f 11 43 10          	movups XMMWORD PTR [rbx+0x10],xmm0
	else              aep->thd = cos_thd_alloc(ci, dst_ci->comp_cap, cos_aepthd_fn, (void *)aep);
  40c5f5:	48 8b 35 74 d1 2f 00 	mov    rsi,QWORD PTR [rip+0x2fd174]        # 709770 <curr_defci+0x10>
	memset(aep, 0, sizeof(struct cos_aep_info));
  40c5fc:	0f 11 43 20          	movups XMMWORD PTR [rbx+0x20],xmm0
	else              aep->thd = cos_thd_alloc(ci, dst_ci->comp_cap, cos_aepthd_fn, (void *)aep);
  40c600:	e8 9b 26 00 00       	call   40eca0 <cos_thd_alloc>
  40c605:	48 89 c6             	mov    rsi,rax
  40c608:	e9 48 ff ff ff       	jmp    40c555 <cos_aep_tcap_alloc+0x65>
  40c60d:	0f 1f 00             	nop    DWORD PTR [rax]
  40c610:	be 31 00 00 00       	mov    esi,0x31
  40c615:	bf 40 de 41 00       	mov    edi,0x41de40
  40c61a:	e8 61 e6 ff ff       	call   40ac80 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40c61f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c626:	00 00 00 00 
  40c62a:	0f 0b                	ud2    
  40c62c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		aep->tc = cos_tcap_alloc(ci);
  40c630:	bf 60 97 70 00       	mov    edi,0x709760
  40c635:	e8 76 5d 00 00       	call   4123b0 <cos_tcap_alloc>
  40c63a:	48 89 03             	mov    QWORD PTR [rbx],rax
  40c63d:	49 89 c4             	mov    r12,rax
		assert(aep->tc);
  40c640:	48 85 c0             	test   rax,rax
  40c643:	0f 85 37 ff ff ff    	jne    40c580 <cos_aep_tcap_alloc+0x90>
  40c649:	be 31 00 00 00       	mov    esi,0x31
  40c64e:	bf b0 de 41 00       	mov    edi,0x41deb0
  40c653:	e8 28 e6 ff ff       	call   40ac80 <cos_print_str>
  40c658:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c65f:	00 00 00 00 
  40c663:	0f 0b                	ud2    
  40c665:	be 31 00 00 00       	mov    esi,0x31
  40c66a:	bf 78 de 41 00       	mov    edi,0x41de78
  40c66f:	e8 0c e6 ff ff       	call   40ac80 <cos_print_str>
	assert(aep->thd);
  40c674:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c67b:	00 00 00 00 
  40c67f:	0f 0b                	ud2    
  40c681:	be 31 00 00 00       	mov    esi,0x31
  40c686:	bf e8 de 41 00       	mov    edi,0x41dee8
  40c68b:	e8 f0 e5 ff ff       	call   40ac80 <cos_print_str>
	assert(aep->rcv);
  40c690:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c697:	00 00 00 00 
  40c69b:	0f 0b                	ud2    
  40c69d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040c6a0 <cos_defswitch>:

int
cos_defswitch(thdcap_t c, tcap_prio_t p, tcap_time_t r, sched_tok_t stok)
{
  40c6a0:	f3 0f 1e fa          	endbr64 
  40c6a4:	49 89 d3             	mov    r11,rdx
  40c6a7:	41 89 c9             	mov    r9d,ecx
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  40c6aa:	0f 01 f9             	rdtscp 
	return (long)coreid;
  40c6ad:	81 e1 ff 0f 00 00    	and    ecx,0xfff
	struct cos_defcompinfo *defci     = cos_defcompinfo_curr_get();
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);

	assert(curr_defci_init_status == INITIALIZED);
  40c6b3:	83 3d ae d3 2f 00 01 	cmp    DWORD PTR [rip+0x2fd3ae],0x1        # 709a68 <curr_defci_init_status>
  40c6ba:	75 21                	jne    40c6dd <cos_defswitch+0x3d>

	return cos_switch(c, sched_aep->tc, p, r, sched_aep->rcv, stok);
  40c6bc:	48 8d 04 49          	lea    rax,[rcx+rcx*2]
  40c6c0:	48 89 f2             	mov    rdx,rsi
  40c6c3:	4c 89 d9             	mov    rcx,r11
  40c6c6:	48 c1 e0 04          	shl    rax,0x4
  40c6ca:	4c 8b 80 00 99 70 00 	mov    r8,QWORD PTR [rax+0x709900]
  40c6d1:	48 8b b0 e8 98 70 00 	mov    rsi,QWORD PTR [rax+0x7098e8]
  40c6d8:	e9 53 54 00 00       	jmp    411b30 <cos_switch>
{
  40c6dd:	55                   	push   rbp
  40c6de:	be 31 00 00 00       	mov    esi,0x31
  40c6e3:	bf 00 e0 41 00       	mov    edi,0x41e000
  40c6e8:	48 89 e5             	mov    rbp,rsp
  40c6eb:	e8 90 e5 ff ff       	call   40ac80 <cos_print_str>
	assert(curr_defci_init_status == INITIALIZED);
  40c6f0:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c6f7:	00 00 00 00 
  40c6fb:	0f 0b                	ud2    
  40c6fd:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040c700 <printc.constprop.0>:
printc(char *fmt, ...)
  40c700:	55                   	push   rbp
  40c701:	48 89 e5             	mov    rbp,rsp
  40c704:	48 81 ec 90 01 00 00 	sub    rsp,0x190
  40c70b:	48 89 b5 58 ff ff ff 	mov    QWORD PTR [rbp-0xa8],rsi
  40c712:	48 89 95 60 ff ff ff 	mov    QWORD PTR [rbp-0xa0],rdx
  40c719:	48 89 8d 68 ff ff ff 	mov    QWORD PTR [rbp-0x98],rcx
  40c720:	4c 89 85 70 ff ff ff 	mov    QWORD PTR [rbp-0x90],r8
  40c727:	4c 89 8d 78 ff ff ff 	mov    QWORD PTR [rbp-0x88],r9
  40c72e:	84 c0                	test   al,al
  40c730:	74 20                	je     40c752 <printc.constprop.0+0x52>
  40c732:	0f 29 45 80          	movaps XMMWORD PTR [rbp-0x80],xmm0
  40c736:	0f 29 4d 90          	movaps XMMWORD PTR [rbp-0x70],xmm1
  40c73a:	0f 29 55 a0          	movaps XMMWORD PTR [rbp-0x60],xmm2
  40c73e:	0f 29 5d b0          	movaps XMMWORD PTR [rbp-0x50],xmm3
  40c742:	0f 29 65 c0          	movaps XMMWORD PTR [rbp-0x40],xmm4
  40c746:	0f 29 6d d0          	movaps XMMWORD PTR [rbp-0x30],xmm5
  40c74a:	0f 29 75 e0          	movaps XMMWORD PTR [rbp-0x20],xmm6
  40c74e:	0f 29 7d f0          	movaps XMMWORD PTR [rbp-0x10],xmm7
	va_start(arg_ptr, fmt);
  40c752:	48 8d 45 10          	lea    rax,[rbp+0x10]
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40c756:	ba 40 e0 41 00       	mov    edx,0x41e040
  40c75b:	be b4 00 00 00       	mov    esi,0xb4
	va_start(arg_ptr, fmt);
  40c760:	c7 85 78 fe ff ff 08 	mov    DWORD PTR [rbp-0x188],0x8
  40c767:	00 00 00 
  40c76a:	48 89 85 80 fe ff ff 	mov    QWORD PTR [rbp-0x180],rax
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40c771:	48 8d 8d 78 fe ff ff 	lea    rcx,[rbp-0x188]
	va_start(arg_ptr, fmt);
  40c778:	48 8d 85 50 ff ff ff 	lea    rax,[rbp-0xb0]
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40c77f:	48 8d bd 90 fe ff ff 	lea    rdi,[rbp-0x170]
	va_start(arg_ptr, fmt);
  40c786:	48 89 85 88 fe ff ff 	mov    QWORD PTR [rbp-0x178],rax
  40c78d:	c7 85 7c fe ff ff 30 	mov    DWORD PTR [rbp-0x184],0x30
  40c794:	00 00 00 
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40c797:	e8 d4 a6 00 00       	call   416e70 <vsnprintf>
	ret = cos_print_str(s, ret);
  40c79c:	48 8d bd 90 fe ff ff 	lea    rdi,[rbp-0x170]
	ret = vsnprintf(s, 180, fmt, arg_ptr);
  40c7a3:	89 c6                	mov    esi,eax
	ret = cos_print_str(s, ret);
  40c7a5:	e8 d6 e4 ff ff       	call   40ac80 <cos_print_str>
}
  40c7aa:	c9                   	leave  
  40c7ab:	c3                   	ret    
  40c7ac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000040c7b0 <__mem_bump_alloc.constprop.0>:
}

/**************** [Memory Capability Allocation Functions] ***************/

static vaddr_t
__mem_bump_alloc(struct cos_compinfo *__ci, int km, int retype)
  40c7b0:	55                   	push   rbp
  40c7b1:	48 89 e5             	mov    rbp,rsp
  40c7b4:	41 55                	push   r13
  40c7b6:	41 54                	push   r12
  40c7b8:	53                   	push   rbx
  40c7b9:	48 83 ec 18          	sub    rsp,0x18
	struct cos_compinfo *ci;
	vaddr_t *            ptr, *frontier;

	printd("__mem_bump_alloc\n");

	assert(__ci);
  40c7bd:	48 85 ff             	test   rdi,rdi
  40c7c0:	0f 84 3f 01 00 00    	je     40c905 <__mem_bump_alloc.constprop.0+0x155>
	return ci->memsrc;
  40c7c6:	4c 8b 97 08 01 00 00 	mov    r10,QWORD PTR [rdi+0x108]
        __asm__ __volatile__("lock " PS_CAS_STR
  40c7cd:	be 01 00 00 00       	mov    esi,0x1
  40c7d2:	31 c9                	xor    ecx,ecx
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40c7d4:	49 8d 92 60 01 00 00 	lea    rdx,[r10+0x160]
	ci = __compinfo_metacap(__ci);
	assert(ci && ci == __compinfo_metacap(__ci));
  40c7db:	4d 85 d2             	test   r10,r10
  40c7de:	0f 84 3d 01 00 00    	je     40c921 <__mem_bump_alloc.constprop.0+0x171>
  40c7e4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  40c7e8:	48 89 c8             	mov    rax,rcx
  40c7eb:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40c7f0:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40c7f3:	84 c0                	test   al,al
  40c7f5:	74 f1                	je     40c7e8 <__mem_bump_alloc.constprop.0+0x38>
        __asm__ __volatile__("lock " PS_FAA_STR
  40c7f7:	41 bd 00 10 00 00    	mov    r13d,0x1000
  40c7fd:	f0 4d 0f c1 aa 20 01 	lock xadd QWORD PTR [r10+0x120],r13
  40c804:	00 00 
		frontier = &ci->mi.umem_frontier;
	}

	ret = ps_faa(ptr, PAGE_SIZE);

	if (ret >= *frontier || *frontier - ret > RETYPE_MEM_SIZE) {
  40c806:	49 8b 92 38 01 00 00 	mov    rdx,QWORD PTR [r10+0x138]
  40c80d:	49 39 d5             	cmp    r13,rdx
  40c810:	0f 82 ca 00 00 00    	jb     40c8e0 <__mem_bump_alloc.constprop.0+0x130>
		vaddr_t ptr_tmp = *ptr, front_tmp = *frontier;
  40c816:	49 8b 82 20 01 00 00 	mov    rax,QWORD PTR [r10+0x120]

		/* TODO: expand frontier if introspection says there is more memory */
		if (ci->mi.untyped_ptr == ci->mi.untyped_frontier) goto error;
  40c81d:	49 8b 9a 28 01 00 00 	mov    rbx,QWORD PTR [r10+0x128]
  40c824:	49 39 9a 10 01 00 00 	cmp    QWORD PTR [r10+0x110],rbx
  40c82b:	0f 84 cf 00 00 00    	je     40c900 <__mem_bump_alloc.constprop.0+0x150>
  40c831:	41 bd 00 10 00 00    	mov    r13d,0x1000
  40c837:	f0 4d 0f c1 aa 10 01 	lock xadd QWORD PTR [r10+0x110],r13
  40c83e:	00 00 
		/* this is the overall frontier, so we know we can use this value... */
		ret = ps_faa(&ci->mi.untyped_ptr, RETYPE_MEM_SIZE);
		/* failure here means that someone else already advanced the frontier/ptr */
		if (ps_cas(ptr, ptr_tmp, ret + PAGE_SIZE)) {
  40c840:	49 8d 8d 00 10 00 00 	lea    rcx,[r13+0x1000]
        __asm__ __volatile__("lock " PS_CAS_STR
  40c847:	f0 49 0f b1 8a 20 01 	lock cmpxchg QWORD PTR [r10+0x120],rcx
  40c84e:	00 00 
  40c850:	0f 94 c0             	sete   al
  40c853:	84 c0                	test   al,al
  40c855:	74 0f                	je     40c866 <__mem_bump_alloc.constprop.0+0xb6>
  40c857:	48 89 d0             	mov    rax,rdx
  40c85a:	f0 49 0f b1 8a 38 01 	lock cmpxchg QWORD PTR [r10+0x138],rcx
  40c861:	00 00 
  40c863:	0f 94 c0             	sete   al
			ps_cas(frontier, front_tmp, ret + RETYPE_MEM_SIZE);
		}
	}

	if (retype && (ret % RETYPE_MEM_SIZE == 0)) {
  40c866:	4c 89 ea             	mov    rdx,r13
  40c869:	81 e2 ff 0f 00 00    	and    edx,0xfff
  40c86f:	75 51                	jne    40c8c2 <__mem_bump_alloc.constprop.0+0x112>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40c871:	41 8b 82 40 01 00 00 	mov    eax,DWORD PTR [r10+0x140]
	__asm__ __volatile__(
  40c878:	4c 89 eb             	mov    rbx,r13
  40c87b:	48 89 d6             	mov    rsi,rdx
  40c87e:	48 89 d7             	mov    rdi,rdx
  40c881:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40c885:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40c888:	05 1a 00 01 00       	add    eax,0x1001a
	__asm__ __volatile__(
  40c88d:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40c890:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40c894:	48 89 cd             	mov    rbp,rcx
  40c897:	49 b8 b0 c8 40 00 00 	movabs r8,0x40c8b0
  40c89e:	00 00 00 
  40c8a1:	0f 05                	syscall 
  40c8a3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40c8a8:	eb 0d                	jmp    40c8b7 <__mem_bump_alloc.constprop.0+0x107>
  40c8aa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40c8b0:	b9 00 00 00 00       	mov    ecx,0x0
  40c8b5:	eb 05                	jmp    40c8bc <__mem_bump_alloc.constprop.0+0x10c>
  40c8b7:	b9 01 00 00 00       	mov    ecx,0x1
  40c8bc:	5d                   	pop    rbp
  40c8bd:	5c                   	pop    rsp
		/* are we dealing with a kernel memory allocation? */
		syscall_op_t op = km ? CAPTBL_OP_MEM_RETYPE2KERN : CAPTBL_OP_MEM_RETYPE2USER;
		if (call_cap_op(ci->mi.pgtbl_cap, op, ret, 0, 0, 0)) goto error;
  40c8be:	85 c0                	test   eax,eax
  40c8c0:	75 3e                	jne    40c900 <__mem_bump_alloc.constprop.0+0x150>
  40c8c2:	49 c7 82 60 01 00 00 	mov    QWORD PTR [r10+0x160],0x0
  40c8c9:	00 00 00 00 
	return ret;
error:
	ps_lock_release(&ci->mem_lock);

	return 0;
}
  40c8cd:	48 83 c4 18          	add    rsp,0x18
  40c8d1:	4c 89 e8             	mov    rax,r13
  40c8d4:	5b                   	pop    rbx
  40c8d5:	41 5c                	pop    r12
  40c8d7:	41 5d                	pop    r13
  40c8d9:	5d                   	pop    rbp
  40c8da:	c3                   	ret    
  40c8db:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	if (ret >= *frontier || *frontier - ret > RETYPE_MEM_SIZE) {
  40c8e0:	48 89 d0             	mov    rax,rdx
  40c8e3:	4c 29 e8             	sub    rax,r13
  40c8e6:	48 3d 00 10 00 00    	cmp    rax,0x1000
  40c8ec:	0f 86 74 ff ff ff    	jbe    40c866 <__mem_bump_alloc.constprop.0+0xb6>
  40c8f2:	e9 1f ff ff ff       	jmp    40c816 <__mem_bump_alloc.constprop.0+0x66>
  40c8f7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40c8fe:	00 00 
	return 0;
  40c900:	45 31 ed             	xor    r13d,r13d
  40c903:	eb bd                	jmp    40c8c2 <__mem_bump_alloc.constprop.0+0x112>
	return cos_print_str(s, strlen(s));
  40c905:	be 2e 00 00 00       	mov    esi,0x2e
  40c90a:	bf 50 e0 41 00       	mov    edi,0x41e050
  40c90f:	e8 6c e3 ff ff       	call   40ac80 <cos_print_str>
	assert(__ci);
  40c914:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c91b:	00 00 00 00 
  40c91f:	0f 0b                	ud2    
  40c921:	be 2e 00 00 00       	mov    esi,0x2e
  40c926:	bf 80 e0 41 00       	mov    edi,0x41e080
  40c92b:	e8 50 e3 ff ff       	call   40ac80 <cos_print_str>
	assert(ci && ci == __compinfo_metacap(__ci));
  40c930:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c937:	00 00 00 00 
  40c93b:	0f 0b                	ud2    
  40c93d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040c940 <__capid_captbl_check_expand>:

static capid_t __capid_bump_alloc(struct cos_compinfo *ci, cap_t cap);

static int
__capid_captbl_check_expand(struct cos_compinfo *ci)
{
  40c940:	55                   	push   rbp
  40c941:	48 89 e5             	mov    rbp,rsp
  40c944:	41 57                	push   r15
  40c946:	41 56                	push   r14
  40c948:	41 55                	push   r13
  40c94a:	41 54                	push   r12
  40c94c:	53                   	push   rbx
  40c94d:	48 83 ec 28          	sub    rsp,0x28
	return ci->memsrc;
  40c951:	4c 8b a7 08 01 00 00 	mov    r12,QWORD PTR [rdi+0x108]
	capid_t captblcap;
	capid_t captblid_add;
	vaddr_t kmem;

	/* ensure that we have bounded structure, and bounded recursion */
	assert(__compinfo_metacap(meta) == meta);
  40c958:	4d 39 a4 24 08 01 00 	cmp    QWORD PTR [r12+0x108],r12
  40c95f:	00 
  40c960:	75 34                	jne    40c996 <__capid_captbl_check_expand+0x56>
	 * rest of the entry (internal fragmentation WRT the captbl
	 * capability).  Oh well.
	 */

	if (self_resources) {
		frontier = ps_load(&ci->caprange_frontier) - CAPMAX_ENTRY_SZ;
  40c962:	48 8b 5f 20          	mov    rbx,QWORD PTR [rdi+0x20]
  40c966:	49 89 fd             	mov    r13,rdi
	if (self_resources) {
  40c969:	4c 39 e7             	cmp    rdi,r12
  40c96c:	74 22                	je     40c990 <__capid_captbl_check_expand+0x50>
	} else {
		frontier = ps_load(&ci->caprange_frontier);
	}
	assert(ci->cap_frontier <= frontier);
  40c96e:	49 39 5d 18          	cmp    QWORD PTR [r13+0x18],rbx
  40c972:	77 3e                	ja     40c9b2 <__capid_captbl_check_expand+0x72>

	/* Common case: */
	if (likely(ci->cap_frontier != frontier)) return 0;
  40c974:	74 58                	je     40c9ce <__capid_captbl_check_expand+0x8e>
	frontier       = ps_load(&ci->cap_frontier);
	range_frontier = ps_faa(&ci->caprange_frontier, CAPTBL_EXPAND_SZ * 2);
	ps_cas(&ci->cap_frontier, frontier, range_frontier);

	return 0;
}
  40c976:	48 83 c4 28          	add    rsp,0x28
  40c97a:	31 c0                	xor    eax,eax
  40c97c:	5b                   	pop    rbx
  40c97d:	41 5c                	pop    r12
  40c97f:	41 5d                	pop    r13
  40c981:	41 5e                	pop    r14
  40c983:	41 5f                	pop    r15
  40c985:	5d                   	pop    rbp
  40c986:	c3                   	ret    
  40c987:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40c98e:	00 00 
		frontier = ps_load(&ci->caprange_frontier) - CAPMAX_ENTRY_SZ;
  40c990:	48 83 eb 04          	sub    rbx,0x4
  40c994:	eb d8                	jmp    40c96e <__capid_captbl_check_expand+0x2e>
  40c996:	be 2e 00 00 00       	mov    esi,0x2e
  40c99b:	bf b0 e0 41 00       	mov    edi,0x41e0b0
  40c9a0:	e8 db e2 ff ff       	call   40ac80 <cos_print_str>
	assert(__compinfo_metacap(meta) == meta);
  40c9a5:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c9ac:	00 00 00 00 
  40c9b0:	0f 0b                	ud2    
  40c9b2:	be 2e 00 00 00       	mov    esi,0x2e
  40c9b7:	bf e0 e0 41 00       	mov    edi,0x41e0e0
  40c9bc:	e8 bf e2 ff ff       	call   40ac80 <cos_print_str>
	assert(ci->cap_frontier <= frontier);
  40c9c1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40c9c8:	00 00 00 00 
  40c9cc:	0f 0b                	ud2    
	return __mem_bump_alloc(ci, 1, 1);
  40c9ce:	4c 89 ef             	mov    rdi,r13
  40c9d1:	e8 da fd ff ff       	call   40c7b0 <__mem_bump_alloc.constprop.0>
  40c9d6:	49 89 c6             	mov    r14,rax
	assert(kmem); /* FIXME: should have a failure semantics for capids */
  40c9d9:	48 85 c0             	test   rax,rax
  40c9dc:	0f 84 bf 01 00 00    	je     40cba1 <__capid_captbl_check_expand+0x261>
	if (self_resources) {
  40c9e2:	4d 39 e5             	cmp    r13,r12
  40c9e5:	0f 84 85 00 00 00    	je     40ca70 <__capid_captbl_check_expand+0x130>
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  40c9eb:	0f 01 f9             	rdtscp 
	return (long)coreid;
  40c9ee:	48 89 cf             	mov    rdi,rcx
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40c9f1:	49 8d 94 24 58 01 00 	lea    rdx,[r12+0x158]
  40c9f8:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  40c9f9:	be 01 00 00 00       	mov    esi,0x1
  40c9fe:	31 c9                	xor    ecx,ecx
  40ca00:	81 e7 ff 0f 00 00    	and    edi,0xfff
		break;
	case CAP32B_IDSZ:
		frontier = &ci->cap32_frontier[cos_cpuid()];
		break;
	case CAP64B_IDSZ:
		frontier = &ci->cap64_frontier[cos_cpuid()];
  40ca06:	4d 8d bc fc a8 00 00 	lea    r15,[r12+rdi*8+0xa8]
  40ca0d:	00 
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40ca0e:	66 90                	xchg   ax,ax
        __asm__ __volatile__("lock " PS_CAS_STR
  40ca10:	48 89 c8             	mov    rax,rcx
  40ca13:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40ca18:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40ca1b:	84 c0                	test   al,al
  40ca1d:	74 f1                	je     40ca10 <__capid_captbl_check_expand+0xd0>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40ca1f:	48 8d 5f 14          	lea    rbx,[rdi+0x14]
  40ca23:	41 f6 84 fc a8 00 00 	test   BYTE PTR [r12+rdi*8+0xa8],0x3
  40ca2a:	00 03 
  40ca2c:	0f 84 4d 01 00 00    	je     40cb7f <__capid_captbl_check_expand+0x23f>
        __asm__ __volatile__("lock " PS_FAA_STR
  40ca32:	bb 04 00 00 00       	mov    ebx,0x4
  40ca37:	f0 49 0f c1 1f       	lock xadd QWORD PTR [r15],rbx
{ l->o = 0; }
  40ca3c:	49 c7 84 24 58 01 00 	mov    QWORD PTR [r12+0x158],0x0
  40ca43:	00 00 00 00 00 
		assert(captblcap);
  40ca48:	48 85 db             	test   rbx,rbx
  40ca4b:	75 23                	jne    40ca70 <__capid_captbl_check_expand+0x130>
  40ca4d:	be 2e 00 00 00       	mov    esi,0x2e
  40ca52:	bf 40 e1 41 00       	mov    edi,0x41e140
  40ca57:	e8 24 e2 ff ff       	call   40ac80 <cos_print_str>
  40ca5c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ca63:	00 00 00 00 
  40ca67:	0f 0b                	ud2    
  40ca69:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	captblid_add = ps_load(&ci->caprange_frontier);
  40ca70:	4d 8b 7d 20          	mov    r15,QWORD PTR [r13+0x20]
	assert(captblid_add % CAPTBL_EXPAND_SZ == 0);
  40ca74:	4c 89 f8             	mov    rax,r15
  40ca77:	83 e0 7f             	and    eax,0x7f
  40ca7a:	48 89 45 b8          	mov    QWORD PTR [rbp-0x48],rax
  40ca7e:	0f 85 39 01 00 00    	jne    40cbbd <__capid_captbl_check_expand+0x27d>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40ca84:	41 8b 44 24 08       	mov    eax,DWORD PTR [r12+0x8]
	__asm__ __volatile__(
  40ca89:	4c 8d 55 c0          	lea    r10,[rbp-0x40]
  40ca8d:	ba 01 00 00 00       	mov    edx,0x1
  40ca92:	4c 89 f7             	mov    rdi,r14
  40ca95:	49 8b b4 24 40 01 00 	mov    rsi,QWORD PTR [r12+0x140]
  40ca9c:	00 
  40ca9d:	4c 89 d1             	mov    rcx,r10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40caa0:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40caa3:	05 1e 00 01 00       	add    eax,0x1001e
	__asm__ __volatile__(
  40caa8:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40caab:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40caaf:	48 89 cd             	mov    rbp,rcx
  40cab2:	49 b8 c8 ca 40 00 00 	movabs r8,0x40cac8
  40cab9:	00 00 00 
  40cabc:	0f 05                	syscall 
  40cabe:	66 90                	xchg   ax,ax
  40cac0:	eb 0d                	jmp    40cacf <__capid_captbl_check_expand+0x18f>
  40cac2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40cac8:	b9 00 00 00 00       	mov    ecx,0x0
  40cacd:	eb 05                	jmp    40cad4 <__capid_captbl_check_expand+0x194>
  40cacf:	b9 01 00 00 00       	mov    ecx,0x1
  40cad4:	5d                   	pop    rbp
  40cad5:	5c                   	pop    rsp
	if (call_cap_op(meta->captbl_cap, CAPTBL_OP_CAPTBLACTIVATE, captblcap, meta->mi.pgtbl_cap, kmem, 1)) {
  40cad6:	85 c0                	test   eax,eax
  40cad8:	75 6d                	jne    40cb47 <__capid_captbl_check_expand+0x207>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40cada:	41 8b 45 08          	mov    eax,DWORD PTR [r13+0x8]
	__asm__ __volatile__(
  40cade:	48 8b 7d b8          	mov    rdi,QWORD PTR [rbp-0x48]
  40cae2:	4c 89 fe             	mov    rsi,r15
  40cae5:	4c 89 d1             	mov    rcx,r10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40cae8:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40caeb:	48 89 fa             	mov    rdx,rdi
	cap_no += op;
  40caee:	05 01 00 01 00       	add    eax,0x10001
	__asm__ __volatile__(
  40caf3:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40caf6:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40cafa:	48 89 cd             	mov    rbp,rcx
  40cafd:	49 b8 18 cb 40 00 00 	movabs r8,0x40cb18
  40cb04:	00 00 00 
  40cb07:	0f 05                	syscall 
  40cb09:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  40cb10:	eb 0d                	jmp    40cb1f <__capid_captbl_check_expand+0x1df>
  40cb12:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40cb18:	b9 00 00 00 00       	mov    ecx,0x0
  40cb1d:	eb 05                	jmp    40cb24 <__capid_captbl_check_expand+0x1e4>
  40cb1f:	b9 01 00 00 00       	mov    ecx,0x1
  40cb24:	5d                   	pop    rbp
  40cb25:	5c                   	pop    rsp
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_CONS, captblcap, captblid_add, 0, 0)) {
  40cb26:	85 c0                	test   eax,eax
  40cb28:	75 39                	jne    40cb63 <__capid_captbl_check_expand+0x223>
	frontier       = ps_load(&ci->cap_frontier);
  40cb2a:	49 8b 45 18          	mov    rax,QWORD PTR [r13+0x18]
        __asm__ __volatile__("lock " PS_FAA_STR
  40cb2e:	ba 00 01 00 00       	mov    edx,0x100
  40cb33:	f0 49 0f c1 55 20    	lock xadd QWORD PTR [r13+0x20],rdx
        __asm__ __volatile__("lock " PS_CAS_STR
  40cb39:	f0 49 0f b1 55 18    	lock cmpxchg QWORD PTR [r13+0x18],rdx
  40cb3f:	0f 94 c0             	sete   al
	return 0;
  40cb42:	e9 2f fe ff ff       	jmp    40c976 <__capid_captbl_check_expand+0x36>
  40cb47:	be 2e 00 00 00       	mov    esi,0x2e
  40cb4c:	bf a0 e1 41 00       	mov    edi,0x41e1a0
  40cb51:	e8 2a e1 ff ff       	call   40ac80 <cos_print_str>
		assert(0); /* race condition? */
  40cb56:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40cb5d:	00 00 00 00 
  40cb61:	0f 0b                	ud2    
  40cb63:	be 2e 00 00 00       	mov    esi,0x2e
  40cb68:	bf d0 e1 41 00       	mov    edi,0x41e1d0
  40cb6d:	e8 0e e1 ff ff       	call   40ac80 <cos_print_str>
		assert(0); /* race? */
  40cb72:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40cb79:	00 00 00 00 
  40cb7d:	0f 0b                	ud2    
		if (__capid_captbl_check_expand(ci)) goto error;
  40cb7f:	4c 89 e7             	mov    rdi,r12
  40cb82:	e8 b9 fd ff ff       	call   40c940 <__capid_captbl_check_expand>
  40cb87:	85 c0                	test   eax,eax
  40cb89:	75 4e                	jne    40cbd9 <__capid_captbl_check_expand+0x299>
        __asm__ __volatile__("lock " PS_FAA_STR
  40cb8b:	b8 04 00 00 00       	mov    eax,0x4
  40cb90:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40cb97:	49 89 44 dc 08       	mov    QWORD PTR [r12+rbx*8+0x8],rax
  40cb9c:	e9 91 fe ff ff       	jmp    40ca32 <__capid_captbl_check_expand+0xf2>
  40cba1:	be 2e 00 00 00       	mov    esi,0x2e
  40cba6:	bf 10 e1 41 00       	mov    edi,0x41e110
  40cbab:	e8 d0 e0 ff ff       	call   40ac80 <cos_print_str>
	assert(kmem); /* FIXME: should have a failure semantics for capids */
  40cbb0:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40cbb7:	00 00 00 00 
  40cbbb:	0f 0b                	ud2    
  40cbbd:	be 2e 00 00 00       	mov    esi,0x2e
  40cbc2:	bf 70 e1 41 00       	mov    edi,0x41e170
  40cbc7:	e8 b4 e0 ff ff       	call   40ac80 <cos_print_str>
	assert(captblid_add % CAPTBL_EXPAND_SZ == 0);
  40cbcc:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40cbd3:	00 00 00 00 
  40cbd7:	0f 0b                	ud2    
{ l->o = 0; }
  40cbd9:	49 c7 84 24 58 01 00 	mov    QWORD PTR [r12+0x158],0x0
  40cbe0:	00 00 00 00 00 
		assert(captblcap);
  40cbe5:	e9 63 fe ff ff       	jmp    40ca4d <__capid_captbl_check_expand+0x10d>
  40cbea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000040cbf0 <__bump_mem_expand_range>:
	return pte_cap;
}

static vaddr_t
__bump_mem_expand_range(struct cos_compinfo *meta, pgtblcap_t cipgtbl, vaddr_t mem_ptr, unsigned long mem_sz, u32_t pgtbl_lvl)
{
  40cbf0:	55                   	push   rbp
  40cbf1:	48 89 e5             	mov    rbp,rsp
  40cbf4:	41 57                	push   r15
  40cbf6:	41 56                	push   r14
  40cbf8:	41 55                	push   r13
  40cbfa:	41 54                	push   r12
  40cbfc:	53                   	push   rbx
  40cbfd:	48 83 ec 48          	sub    rsp,0x48
  40cc01:	48 89 55 b8          	mov    QWORD PTR [rbp-0x48],rdx
	vaddr_t addr, range;
	u8_t lvl = (u8_t)pgtbl_lvl;
	assert(lvl >= 0 && lvl < COS_PGTBL_DEPTH - 1);
  40cc05:	41 80 f8 02          	cmp    r8b,0x2
  40cc09:	0f 87 9b 02 00 00    	ja     40ceaa <__bump_mem_expand_range+0x2ba>
  40cc0f:	45 89 c7             	mov    r15d,r8d


#if defined(__x86_64__)
	vaddr_t tmp_frontier;
	range		 = cos_pgtbl_get_range(lvl);
  40cc12:	41 0f b6 d0          	movzx  edx,r8b
  40cc16:	76 18                	jbe    40cc30 <__bump_mem_expand_range+0x40>
	}
	assert(round_up_to_pgd_page(addr) == round_up_to_pgd_page(mem_ptr + mem_sz));
#endif

	return mem_ptr;
}
  40cc18:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  40cc1c:	48 83 c4 48          	add    rsp,0x48
  40cc20:	5b                   	pop    rbx
  40cc21:	41 5c                	pop    r12
  40cc23:	41 5d                	pop    r13
  40cc25:	41 5e                	pop    r14
  40cc27:	41 5f                	pop    r15
  40cc29:	5d                   	pop    rbp
  40cc2a:	c3                   	ret    
  40cc2b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40cc30:	49 89 fe             	mov    r14,rdi
  40cc33:	48 89 f0             	mov    rax,rsi
	tmp_frontier = cos_pgtbl_round_up_to_page(lvl, mem_ptr + mem_sz);
  40cc36:	48 03 4d b8          	add    rcx,QWORD PTR [rbp-0x48]
	switch (pgtbl_lvl)
  40cc3a:	83 fa 01             	cmp    edx,0x1
  40cc3d:	0f 84 d9 01 00 00    	je     40ce1c <__bump_mem_expand_range+0x22c>
  40cc43:	83 fa 02             	cmp    edx,0x2
  40cc46:	75 1f                	jne    40cc67 <__bump_mem_expand_range+0x77>
		return round_up_to_pgt2_page(vaddr);
  40cc48:	48 81 c1 ff ff 1f 00 	add    rcx,0x1fffff
  40cc4f:	48 c7 45 98 00 00 20 	mov    QWORD PTR [rbp-0x68],0x200000
  40cc56:	00 
  40cc57:	48 81 e1 00 00 e0 ff 	and    rcx,0xffffffffffe00000
  40cc5e:	48 89 4d b0          	mov    QWORD PTR [rbp-0x50],rcx
  40cc62:	48 89 cf             	mov    rdi,rcx
  40cc65:	eb 33                	jmp    40cc9a <__bump_mem_expand_range+0xaa>
	switch (pgtbl_lvl)
  40cc67:	85 d2                	test   edx,edx
  40cc69:	75 ad                	jne    40cc18 <__bump_mem_expand_range+0x28>
		return round_up_to_pgt0_page(vaddr);
  40cc6b:	48 ba ff ff ff ff 7f 	movabs rdx,0x7fffffffff
  40cc72:	00 00 00 
  40cc75:	48 bf 00 00 00 00 80 	movabs rdi,0x8000000000
  40cc7c:	00 00 00 
  40cc7f:	48 01 d1             	add    rcx,rdx
  40cc82:	48 89 7d 98          	mov    QWORD PTR [rbp-0x68],rdi
  40cc86:	48 ba 00 00 00 00 80 	movabs rdx,0xffffff8000000000
  40cc8d:	ff ff ff 
  40cc90:	48 21 d1             	and    rcx,rdx
  40cc93:	48 89 4d b0          	mov    QWORD PTR [rbp-0x50],rcx
  40cc97:	48 89 cf             	mov    rdi,rcx
	for (addr = mem_ptr; addr < tmp_frontier; addr += range) {
  40cc9a:	48 8b 5d b8          	mov    rbx,QWORD PTR [rbp-0x48]
  40cc9e:	48 39 fb             	cmp    rbx,rdi
  40cca1:	0f 83 71 ff ff ff    	jae    40cc18 <__bump_mem_expand_range+0x28>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40cca7:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40ccaa:	48 89 5d a8          	mov    QWORD PTR [rbp-0x58],rbx
        __asm__ __volatile__("lock " PS_CAS_STR
  40ccae:	41 bd 01 00 00 00    	mov    r13d,0x1
  40ccb4:	05 01 00 01 00       	add    eax,0x10001
  40ccb9:	89 45 a4             	mov    DWORD PTR [rbp-0x5c],eax
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  40ccbc:	4d 3b b6 08 01 00 00 	cmp    r14,QWORD PTR [r14+0x108]
  40ccc3:	0f 85 37 01 00 00    	jne    40ce00 <__bump_mem_expand_range+0x210>
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  40ccc9:	0f 01 f9             	rdtscp 
	return (long)coreid;
  40cccc:	48 89 ce             	mov    rsi,rcx
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40cccf:	49 8d 96 58 01 00 00 	lea    rdx,[r14+0x158]
        __asm__ __volatile__("lock " PS_CAS_STR
  40ccd6:	31 c9                	xor    ecx,ecx
  40ccd8:	81 e6 ff 0f 00 00    	and    esi,0xfff
		frontier = &ci->cap64_frontier[cos_cpuid()];
  40ccde:	4d 8d a4 f6 a8 00 00 	lea    r12,[r14+rsi*8+0xa8]
  40cce5:	00 
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40cce6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40cced:	00 00 00 
        __asm__ __volatile__("lock " PS_CAS_STR
  40ccf0:	48 89 c8             	mov    rax,rcx
  40ccf3:	f0 4c 0f b1 2a       	lock cmpxchg QWORD PTR [rdx],r13
  40ccf8:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40ccfb:	84 c0                	test   al,al
  40ccfd:	74 f1                	je     40ccf0 <__bump_mem_expand_range+0x100>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40ccff:	48 8d 5e 14          	lea    rbx,[rsi+0x14]
  40cd03:	41 f6 84 f6 a8 00 00 	test   BYTE PTR [r14+rsi*8+0xa8],0x3
  40cd0a:	00 03 
  40cd0c:	0f 84 2c 01 00 00    	je     40ce3e <__bump_mem_expand_range+0x24e>
        __asm__ __volatile__("lock " PS_FAA_STR
  40cd12:	bb 04 00 00 00       	mov    ebx,0x4
  40cd17:	f0 49 0f c1 1c 24    	lock xadd QWORD PTR [r12],rbx
{ l->o = 0; }
  40cd1d:	49 c7 86 58 01 00 00 	mov    QWORD PTR [r14+0x158],0x0
  40cd24:	00 00 00 00 
	return __mem_bump_alloc(ci, 1, 1);
  40cd28:	4c 89 f7             	mov    rdi,r14
  40cd2b:	e8 80 fa ff ff       	call   40c7b0 <__mem_bump_alloc.constprop.0>
  40cd30:	48 89 c7             	mov    rdi,rax
		if (pte_cap == 0 || ptemem_cap == 0) {
  40cd33:	48 85 db             	test   rbx,rbx
  40cd36:	0f 84 21 01 00 00    	je     40ce5d <__bump_mem_expand_range+0x26d>
  40cd3c:	48 85 c0             	test   rax,rax
  40cd3f:	0f 84 18 01 00 00    	je     40ce5d <__bump_mem_expand_range+0x26d>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40cd45:	41 8b 46 08          	mov    eax,DWORD PTR [r14+0x8]
	__asm__ __volatile__(
  40cd49:	4c 8d 55 c0          	lea    r10,[rbp-0x40]
  40cd4d:	49 8b b6 40 01 00 00 	mov    rsi,QWORD PTR [r14+0x140]
		if (call_cap_op(meta->captbl_cap, CAPTBL_OP_PGTBLACTIVATE, pte_cap, meta->mi.pgtbl_cap, ptemem_cap,
  40cd54:	41 8d 57 01          	lea    edx,[r15+0x1]
  40cd58:	4c 89 d1             	mov    rcx,r10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40cd5b:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40cd5e:	05 1c 00 01 00       	add    eax,0x1001c
	__asm__ __volatile__(
  40cd63:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40cd66:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40cd6a:	48 89 cd             	mov    rbp,rcx
  40cd6d:	49 b8 88 cd 40 00 00 	movabs r8,0x40cd88
  40cd74:	00 00 00 
  40cd77:	0f 05                	syscall 
  40cd79:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  40cd80:	eb 0d                	jmp    40cd8f <__bump_mem_expand_range+0x19f>
  40cd82:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40cd88:	b9 00 00 00 00       	mov    ecx,0x0
  40cd8d:	eb 05                	jmp    40cd94 <__bump_mem_expand_range+0x1a4>
  40cd8f:	b9 01 00 00 00       	mov    ecx,0x1
  40cd94:	5d                   	pop    rbp
  40cd95:	5c                   	pop    rsp
  40cd96:	85 c0                	test   eax,eax
  40cd98:	0f 85 db 00 00 00    	jne    40ce79 <__bump_mem_expand_range+0x289>
  40cd9e:	31 d2                	xor    edx,edx
  40cda0:	8b 45 a4             	mov    eax,DWORD PTR [rbp-0x5c]
  40cda3:	48 8b 75 a8          	mov    rsi,QWORD PTR [rbp-0x58]
  40cda7:	4c 89 d1             	mov    rcx,r10
  40cdaa:	48 89 d7             	mov    rdi,rdx
  40cdad:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40cdb0:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40cdb4:	48 89 cd             	mov    rbp,rcx
  40cdb7:	49 b8 d0 cd 40 00 00 	movabs r8,0x40cdd0
  40cdbe:	00 00 00 
  40cdc1:	0f 05                	syscall 
  40cdc3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40cdc8:	eb 0d                	jmp    40cdd7 <__bump_mem_expand_range+0x1e7>
  40cdca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40cdd0:	b9 00 00 00 00       	mov    ecx,0x0
  40cdd5:	eb 05                	jmp    40cddc <__bump_mem_expand_range+0x1ec>
  40cdd7:	b9 01 00 00 00       	mov    ecx,0x1
  40cddc:	5d                   	pop    rbp
  40cddd:	5c                   	pop    rsp
	for (addr = mem_ptr; addr < tmp_frontier; addr += range) {
  40cdde:	48 8b 45 98          	mov    rax,QWORD PTR [rbp-0x68]
  40cde2:	48 01 c6             	add    rsi,rax
  40cde5:	48 89 75 a8          	mov    QWORD PTR [rbp-0x58],rsi
  40cde9:	48 3b 75 b0          	cmp    rsi,QWORD PTR [rbp-0x50]
  40cded:	0f 83 25 fe ff ff    	jae    40cc18 <__bump_mem_expand_range+0x28>
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  40cdf3:	4d 3b b6 08 01 00 00 	cmp    r14,QWORD PTR [r14+0x108]
  40cdfa:	0f 84 c9 fe ff ff    	je     40ccc9 <__bump_mem_expand_range+0xd9>
  40ce00:	be 2e 00 00 00       	mov    esi,0x2e
  40ce05:	bf 30 e2 41 00       	mov    edi,0x41e230
  40ce0a:	e8 71 de ff ff       	call   40ac80 <cos_print_str>
  40ce0f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ce16:	00 00 00 00 
  40ce1a:	0f 0b                	ud2    
		return round_up_to_pgt1_page(vaddr);
  40ce1c:	48 81 c1 ff ff ff 3f 	add    rcx,0x3fffffff
  40ce23:	48 c7 45 98 00 00 00 	mov    QWORD PTR [rbp-0x68],0x40000000
  40ce2a:	40 
  40ce2b:	48 81 e1 00 00 00 c0 	and    rcx,0xffffffffc0000000
  40ce32:	48 89 4d b0          	mov    QWORD PTR [rbp-0x50],rcx
  40ce36:	48 89 cf             	mov    rdi,rcx
  40ce39:	e9 5c fe ff ff       	jmp    40cc9a <__bump_mem_expand_range+0xaa>
		if (__capid_captbl_check_expand(ci)) goto error;
  40ce3e:	4c 89 f7             	mov    rdi,r14
  40ce41:	e8 fa fa ff ff       	call   40c940 <__capid_captbl_check_expand>
  40ce46:	85 c0                	test   eax,eax
  40ce48:	74 4b                	je     40ce95 <__bump_mem_expand_range+0x2a5>
  40ce4a:	49 c7 86 58 01 00 00 	mov    QWORD PTR [r14+0x158],0x0
  40ce51:	00 00 00 00 
	return __mem_bump_alloc(ci, 1, 1);
  40ce55:	4c 89 f7             	mov    rdi,r14
  40ce58:	e8 53 f9 ff ff       	call   40c7b0 <__mem_bump_alloc.constprop.0>
  40ce5d:	be 2e 00 00 00       	mov    esi,0x2e
  40ce62:	bf 60 e2 41 00       	mov    edi,0x41e260
  40ce67:	e8 14 de ff ff       	call   40ac80 <cos_print_str>
			assert(0);
  40ce6c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ce73:	00 00 00 00 
  40ce77:	0f 0b                	ud2    
  40ce79:	be 2e 00 00 00       	mov    esi,0x2e
  40ce7e:	bf 90 e2 41 00       	mov    edi,0x41e290
  40ce83:	e8 f8 dd ff ff       	call   40ac80 <cos_print_str>
				assert(0); /* race? */
  40ce88:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ce8f:	00 00 00 00 
  40ce93:	0f 0b                	ud2    
        __asm__ __volatile__("lock " PS_FAA_STR
  40ce95:	b8 04 00 00 00       	mov    eax,0x4
  40ce9a:	f0 49 0f c1 46 18    	lock xadd QWORD PTR [r14+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40cea0:	49 89 44 de 08       	mov    QWORD PTR [r14+rbx*8+0x8],rax
  40cea5:	e9 68 fe ff ff       	jmp    40cd12 <__bump_mem_expand_range+0x122>
  40ceaa:	be 2e 00 00 00       	mov    esi,0x2e
  40ceaf:	bf 00 e2 41 00       	mov    edi,0x41e200
  40ceb4:	e8 c7 dd ff ff       	call   40ac80 <cos_print_str>
	assert(lvl >= 0 && lvl < COS_PGTBL_DEPTH - 1);
  40ceb9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40cec0:	00 00 00 00 
  40cec4:	0f 0b                	ud2    
  40cec6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40cecd:	00 00 00 

000000000040ced0 <__page_bump_valloc>:
	return heap_vaddr;
}

static vaddr_t
__page_bump_valloc(struct cos_compinfo *ci, size_t sz, size_t align)
{
  40ced0:	55                   	push   rbp
        __asm__ __volatile__("lock " PS_CAS_STR
  40ced1:	31 c9                	xor    ecx,ecx
  40ced3:	48 89 e5             	mov    rbp,rsp
  40ced6:	41 57                	push   r15
  40ced8:	49 89 d7             	mov    r15,rdx
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40cedb:	48 8d 97 68 01 00 00 	lea    rdx,[rdi+0x168]
  40cee2:	41 56                	push   r14
  40cee4:	41 55                	push   r13
  40cee6:	41 54                	push   r12
  40cee8:	49 89 f4             	mov    r12,rsi
        __asm__ __volatile__("lock " PS_CAS_STR
  40ceeb:	be 01 00 00 00       	mov    esi,0x1
  40cef0:	53                   	push   rbx
  40cef1:	48 89 fb             	mov    rbx,rdi
  40cef4:	48 83 ec 38          	sub    rsp,0x38
  40cef8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40ceff:	00 
  40cf00:	48 89 c8             	mov    rax,rcx
  40cf03:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40cf08:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40cf0b:	84 c0                	test   al,al
  40cf0d:	74 f1                	je     40cf00 <__page_bump_valloc+0x30>
	vaddr_t ret_addr = 0;
	vaddr_t rounding; // how much we need to round up sz to handle alignment

	ps_lock_take(&ci->va_lock);
	rounding = round_up_to_pow2(ci->vas_frontier, align) - ci->vas_frontier;
  40cf0f:	48 8b 93 e8 00 00 00 	mov    rdx,QWORD PTR [rbx+0xe8]
  40cf16:	4c 89 f9             	mov    rcx,r15
	return ci->memsrc;
  40cf19:	48 8b bb 08 01 00 00 	mov    rdi,QWORD PTR [rbx+0x108]
	rounding = round_up_to_pow2(ci->vas_frontier, align) - ci->vas_frontier;
  40cf20:	48 f7 d9             	neg    rcx
  40cf23:	4a 8d 44 3a ff       	lea    rax,[rdx+r15*1-0x1]
  40cf28:	48 21 c8             	and    rax,rcx
  40cf2b:	48 29 d0             	sub    rax,rdx
	sz += rounding;
  40cf2e:	49 01 c4             	add    r12,rax
	rounding = round_up_to_pow2(ci->vas_frontier, align) - ci->vas_frontier;
  40cf31:	49 89 c3             	mov    r11,rax
	assert(sz % PAGE_SIZE == 0);
  40cf34:	4d 89 e6             	mov    r14,r12
  40cf37:	41 81 e6 ff 0f 00 00 	and    r14d,0xfff
  40cf3e:	0f 85 3a 01 00 00    	jne    40d07e <__page_bump_valloc+0x1ae>
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  40cf44:	48 3b bf 08 01 00 00 	cmp    rdi,QWORD PTR [rdi+0x108]
  40cf4b:	0f 85 49 01 00 00    	jne    40d09a <__page_bump_valloc+0x1ca>
        __asm__ __volatile__("lock " PS_FAA_STR
  40cf51:	4c 89 e2             	mov    rdx,r12
  40cf54:	f0 48 0f c1 93 e8 00 	lock xadd QWORD PTR [rbx+0xe8],rdx
  40cf5b:	00 00 
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) pgtbl_flag = PGTBL_LVL_FLAG_VM;
  40cf5d:	31 c0                	xor    eax,eax
  40cf5f:	80 bb 80 01 00 00 01 	cmp    BYTE PTR [rbx+0x180],0x1
		if (heap_vaddr + sz > ci->vasrange_frontier[pgtbl_lvl]) {
  40cf66:	4d 8d 0c 14          	lea    r9,[r12+rdx*1]
		return round_up_to_pgt0_page(vaddr);
  40cf6a:	48 b9 00 00 00 00 80 	movabs rcx,0xffffff8000000000
  40cf71:	ff ff ff 
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) pgtbl_flag = PGTBL_LVL_FLAG_VM;
  40cf74:	0f 94 c0             	sete   al
		return round_up_to_pgt0_page(vaddr);
  40cf77:	48 89 7d b8          	mov    QWORD PTR [rbp-0x48],rdi
  40cf7b:	4c 8d ab f0 00 00 00 	lea    r13,[rbx+0xf0]
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) pgtbl_flag = PGTBL_LVL_FLAG_VM;
  40cf82:	c1 e0 1f             	shl    eax,0x1f
  40cf85:	89 45 c4             	mov    DWORD PTR [rbp-0x3c],eax
		return round_up_to_pgt0_page(vaddr);
  40cf88:	48 b8 ff ff ff ff 7f 	movabs rax,0x7fffffffff
  40cf8f:	00 00 00 
  40cf92:	4c 01 c8             	add    rax,r9
  40cf95:	48 21 c8             	and    rax,rcx
  40cf98:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
		if (heap_vaddr + sz > ci->vasrange_frontier[pgtbl_lvl]) {
  40cf9c:	4d 39 4d 00          	cmp    QWORD PTR [r13+0x0],r9
  40cfa0:	72 46                	jb     40cfe8 <__page_bump_valloc+0x118>
	for (pgtbl_lvl = 0; pgtbl_lvl < COS_PGTBL_DEPTH - 1; pgtbl_lvl++) {
  40cfa2:	49 83 c6 01          	add    r14,0x1
  40cfa6:	49 83 c5 08          	add    r13,0x8
  40cfaa:	49 83 fe 03          	cmp    r14,0x3
  40cfae:	75 ec                	jne    40cf9c <__page_bump_valloc+0xcc>
{ l->o = 0; }
  40cfb0:	48 c7 83 68 01 00 00 	mov    QWORD PTR [rbx+0x168],0x0
  40cfb7:	00 00 00 00 
	ret_addr = __page_bump_mem_alloc(ci, &ci->vas_frontier, &ci->vasrange_frontier[0], sz);
	ret_addr += rounding;
  40cfbb:	4d 8d 04 13          	lea    r8,[r11+rdx*1]
	ps_lock_release(&ci->va_lock);
	assert(ret_addr % align == 0);
  40cfbf:	31 d2                	xor    edx,edx
  40cfc1:	4c 89 c0             	mov    rax,r8
  40cfc4:	49 f7 f7             	div    r15
  40cfc7:	48 85 d2             	test   rdx,rdx
  40cfca:	0f 85 e6 00 00 00    	jne    40d0b6 <__page_bump_valloc+0x1e6>

	return ret_addr;
}
  40cfd0:	48 83 c4 38          	add    rsp,0x38
  40cfd4:	4c 89 c0             	mov    rax,r8
  40cfd7:	5b                   	pop    rbx
  40cfd8:	41 5c                	pop    r12
  40cfda:	41 5d                	pop    r13
  40cfdc:	41 5e                	pop    r14
  40cfde:	41 5f                	pop    r15
  40cfe0:	5d                   	pop    rbp
  40cfe1:	c3                   	ret    
  40cfe2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
			retaddr = __bump_mem_expand_range(meta, ci->pgtbl_cap, heap_vaddr, sz, pgtbl_lvl | pgtbl_flag);
  40cfe8:	44 8b 45 c4          	mov    r8d,DWORD PTR [rbp-0x3c]
  40cfec:	48 8b 33             	mov    rsi,QWORD PTR [rbx]
  40cfef:	4c 89 e1             	mov    rcx,r12
  40cff2:	4c 89 4d a0          	mov    QWORD PTR [rbp-0x60],r9
  40cff6:	48 8b 7d b8          	mov    rdi,QWORD PTR [rbp-0x48]
  40cffa:	4c 89 5d a8          	mov    QWORD PTR [rbp-0x58],r11
  40cffe:	45 09 f0             	or     r8d,r14d
  40d001:	48 89 55 b0          	mov    QWORD PTR [rbp-0x50],rdx
  40d005:	e8 e6 fb ff ff       	call   40cbf0 <__bump_mem_expand_range>
			assert(retaddr);
  40d00a:	48 85 c0             	test   rax,rax
  40d00d:	0f 84 bf 00 00 00    	je     40d0d2 <__page_bump_valloc+0x202>
		return round_up_to_pgt1_page(vaddr);
  40d013:	4c 8b 4d a0          	mov    r9,QWORD PTR [rbp-0x60]
  40d017:	4d 8d 56 1e          	lea    r10,[r14+0x1e]
  40d01b:	4c 8b 5d a8          	mov    r11,QWORD PTR [rbp-0x58]
				tmp_frontier = cos_pgtbl_round_up_to_page(pgtbl_lvl, heap_vaddr + sz);
  40d01f:	45 89 f0             	mov    r8d,r14d
  40d022:	48 8b 55 b0          	mov    rdx,QWORD PTR [rbp-0x50]
		return round_up_to_pgt1_page(vaddr);
  40d026:	49 8d 81 ff ff ff 3f 	lea    rax,[r9+0x3fffffff]
		return round_up_to_pgt2_page(vaddr);
  40d02d:	49 8d b1 ff ff 1f 00 	lea    rsi,[r9+0x1fffff]
		return round_up_to_pgt1_page(vaddr);
  40d034:	48 25 00 00 00 c0    	and    rax,0xffffffffc0000000
		return round_up_to_pgt2_page(vaddr);
  40d03a:	48 81 e6 00 00 e0 ff 	and    rsi,0xffffffffffe00000
		return round_up_to_pgt1_page(vaddr);
  40d041:	48 89 c7             	mov    rdi,rax
				vaddr_t tmp = ps_load(&ci->vasrange_frontier[pgtbl_lvl]);
  40d044:	4a 8b 04 d3          	mov    rax,QWORD PTR [rbx+r10*8]
		return round_up_to_pgt1_page(vaddr);
  40d048:	48 89 f9             	mov    rcx,rdi
	switch (pgtbl_lvl)
  40d04b:	49 83 fe 01          	cmp    r14,0x1
  40d04f:	74 0c                	je     40d05d <__page_bump_valloc+0x18d>
		return round_up_to_pgt0_page(vaddr);
  40d051:	48 8b 4d c8          	mov    rcx,QWORD PTR [rbp-0x38]
	switch (pgtbl_lvl)
  40d055:	41 83 f8 02          	cmp    r8d,0x2
		return round_up_to_pgt0_page(vaddr);
  40d059:	48 0f 44 ce          	cmove  rcx,rsi
				if (tmp >= heap_vaddr + sz) break;
  40d05d:	49 39 c1             	cmp    r9,rax
  40d060:	0f 86 3c ff ff ff    	jbe    40cfa2 <__page_bump_valloc+0xd2>
        __asm__ __volatile__("lock " PS_CAS_STR
  40d066:	f0 49 0f b1 4d 00    	lock cmpxchg QWORD PTR [r13+0x0],rcx
  40d06c:	0f 94 c0             	sete   al
				vaddr_t tmp = ps_load(&ci->vasrange_frontier[pgtbl_lvl]);
  40d06f:	4a 8b 04 d3          	mov    rax,QWORD PTR [rbx+r10*8]
		return round_up_to_pgt1_page(vaddr);
  40d073:	48 89 f9             	mov    rcx,rdi
	switch (pgtbl_lvl)
  40d076:	49 83 fe 01          	cmp    r14,0x1
  40d07a:	75 d5                	jne    40d051 <__page_bump_valloc+0x181>
  40d07c:	eb df                	jmp    40d05d <__page_bump_valloc+0x18d>
  40d07e:	be 2e 00 00 00       	mov    esi,0x2e
  40d083:	bf c0 e2 41 00       	mov    edi,0x41e2c0
  40d088:	e8 f3 db ff ff       	call   40ac80 <cos_print_str>
	assert(sz % PAGE_SIZE == 0);
  40d08d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d094:	00 00 00 00 
  40d098:	0f 0b                	ud2    
  40d09a:	be 2e 00 00 00       	mov    esi,0x2e
  40d09f:	bf f0 e2 41 00       	mov    edi,0x41e2f0
  40d0a4:	e8 d7 db ff ff       	call   40ac80 <cos_print_str>
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  40d0a9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d0b0:	00 00 00 00 
  40d0b4:	0f 0b                	ud2    
  40d0b6:	be 2e 00 00 00       	mov    esi,0x2e
  40d0bb:	bf 50 e3 41 00       	mov    edi,0x41e350
  40d0c0:	e8 bb db ff ff       	call   40ac80 <cos_print_str>
	assert(ret_addr % align == 0);
  40d0c5:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d0cc:	00 00 00 00 
  40d0d0:	0f 0b                	ud2    
  40d0d2:	be 2e 00 00 00       	mov    esi,0x2e
  40d0d7:	bf 20 e3 41 00       	mov    edi,0x41e320
  40d0dc:	e8 9f db ff ff       	call   40ac80 <cos_print_str>
			assert(retaddr);
  40d0e1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d0e8:	00 00 00 00 
  40d0ec:	0f 0b                	ud2    
  40d0ee:	66 90                	xchg   ax,ax

000000000040d0f0 <__page_bump_alloc>:

static vaddr_t
__page_bump_alloc(struct cos_compinfo *ci, size_t sz, size_t align)
{
  40d0f0:	55                   	push   rbp
  40d0f1:	48 89 e5             	mov    rbp,rsp
  40d0f4:	41 57                	push   r15
  40d0f6:	49 89 ff             	mov    r15,rdi
  40d0f9:	41 56                	push   r14
  40d0fb:	41 55                	push   r13
  40d0fd:	41 54                	push   r12
  40d0ff:	53                   	push   rbx
  40d100:	48 89 f3             	mov    rbx,rsi
  40d103:	48 83 ec 48          	sub    rsp,0x48
	return ci->memsrc;
  40d107:	48 8b 87 08 01 00 00 	mov    rax,QWORD PTR [rdi+0x108]
  40d10e:	48 89 45 a8          	mov    QWORD PTR [rbp-0x58],rax

	/*
	 * Allocate the virtual address range to map into.  This is
	 * atomic, so we will get a contiguous range of sz.
	 */
	heap_vaddr = __page_bump_valloc(ci, sz, align);
  40d112:	e8 b9 fd ff ff       	call   40ced0 <__page_bump_valloc>
  40d117:	48 89 45 98          	mov    QWORD PTR [rbp-0x68],rax
	if (unlikely(!heap_vaddr)) return 0;
  40d11b:	48 85 c0             	test   rax,rax
  40d11e:	0f 84 f7 01 00 00    	je     40d31b <__page_bump_alloc+0x22b>
  40d124:	48 89 c7             	mov    rdi,rax
	heap_limit = heap_vaddr + sz;
  40d127:	48 89 d8             	mov    rax,rbx
  40d12a:	48 01 f8             	add    rax,rdi
  40d12d:	48 89 7d b8          	mov    QWORD PTR [rbp-0x48],rdi
  40d131:	48 89 45 a0          	mov    QWORD PTR [rbp-0x60],rax
	assert(heap_limit > heap_vaddr);
  40d135:	48 39 c7             	cmp    rdi,rax
  40d138:	0f 83 f8 01 00 00    	jae    40d336 <__page_bump_alloc+0x246>
	return ci->memsrc;
  40d13e:	4d 8b b7 08 01 00 00 	mov    r14,QWORD PTR [r15+0x108]
  40d145:	41 bd 01 00 00 00    	mov    r13d,0x1
  40d14b:	45 31 d2             	xor    r10d,r10d
	assert(ci && ci == __compinfo_metacap(__ci));
  40d14e:	4d 85 f6             	test   r14,r14
  40d151:	0f 84 89 01 00 00    	je     40d2e0 <__page_bump_alloc+0x1f0>
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40d157:	49 8d 96 60 01 00 00 	lea    rdx,[r14+0x160]
  40d15e:	66 90                	xchg   ax,ax
        __asm__ __volatile__("lock " PS_CAS_STR
  40d160:	4c 89 d0             	mov    rax,r10
  40d163:	f0 4c 0f b1 2a       	lock cmpxchg QWORD PTR [rdx],r13
  40d168:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40d16b:	84 c0                	test   al,al
  40d16d:	74 f1                	je     40d160 <__page_bump_alloc+0x70>
        __asm__ __volatile__("lock " PS_FAA_STR
  40d16f:	bb 00 10 00 00       	mov    ebx,0x1000
  40d174:	f0 49 0f c1 9e 18 01 	lock xadd QWORD PTR [r14+0x118],rbx
  40d17b:	00 00 
	if (ret >= *frontier || *frontier - ret > RETYPE_MEM_SIZE) {
  40d17d:	49 8b 96 30 01 00 00 	mov    rdx,QWORD PTR [r14+0x130]
  40d184:	48 39 d3             	cmp    rbx,rdx
  40d187:	73 0e                	jae    40d197 <__page_bump_alloc+0xa7>
  40d189:	48 89 d0             	mov    rax,rdx
  40d18c:	48 29 d8             	sub    rax,rbx
  40d18f:	48 3d 00 10 00 00    	cmp    rax,0x1000
  40d195:	76 4f                	jbe    40d1e6 <__page_bump_alloc+0xf6>
		vaddr_t ptr_tmp = *ptr, front_tmp = *frontier;
  40d197:	49 8b 86 18 01 00 00 	mov    rax,QWORD PTR [r14+0x118]
		if (ci->mi.untyped_ptr == ci->mi.untyped_frontier) goto error;
  40d19e:	49 8b 8e 28 01 00 00 	mov    rcx,QWORD PTR [r14+0x128]
  40d1a5:	49 39 8e 10 01 00 00 	cmp    QWORD PTR [r14+0x110],rcx
  40d1ac:	0f 84 5e 01 00 00    	je     40d310 <__page_bump_alloc+0x220>
  40d1b2:	bb 00 10 00 00       	mov    ebx,0x1000
  40d1b7:	f0 49 0f c1 9e 10 01 	lock xadd QWORD PTR [r14+0x110],rbx
  40d1be:	00 00 
		if (ps_cas(ptr, ptr_tmp, ret + PAGE_SIZE)) {
  40d1c0:	48 8d 8b 00 10 00 00 	lea    rcx,[rbx+0x1000]
        __asm__ __volatile__("lock " PS_CAS_STR
  40d1c7:	f0 49 0f b1 8e 18 01 	lock cmpxchg QWORD PTR [r14+0x118],rcx
  40d1ce:	00 00 
  40d1d0:	0f 94 c0             	sete   al
  40d1d3:	84 c0                	test   al,al
  40d1d5:	74 0f                	je     40d1e6 <__page_bump_alloc+0xf6>
  40d1d7:	48 89 d0             	mov    rax,rdx
  40d1da:	f0 49 0f b1 8e 30 01 	lock cmpxchg QWORD PTR [r14+0x130],rcx
  40d1e1:	00 00 
  40d1e3:	0f 94 c0             	sete   al
	if (retype && (ret % RETYPE_MEM_SIZE == 0)) {
  40d1e6:	48 89 da             	mov    rdx,rbx
  40d1e9:	81 e2 ff 0f 00 00    	and    edx,0xfff
  40d1ef:	0f 85 0b 01 00 00    	jne    40d300 <__page_bump_alloc+0x210>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40d1f5:	41 8b 86 40 01 00 00 	mov    eax,DWORD PTR [r14+0x140]
	__asm__ __volatile__(
  40d1fc:	48 89 d6             	mov    rsi,rdx
  40d1ff:	48 89 d7             	mov    rdi,rdx
  40d202:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40d206:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40d209:	05 19 00 01 00       	add    eax,0x10019
	__asm__ __volatile__(
  40d20e:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40d211:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40d215:	48 89 cd             	mov    rbp,rcx
  40d218:	49 b8 30 d2 40 00 00 	movabs r8,0x40d230
  40d21f:	00 00 00 
  40d222:	0f 05                	syscall 
  40d224:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  40d228:	eb 0d                	jmp    40d237 <__page_bump_alloc+0x147>
  40d22a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40d230:	b9 00 00 00 00       	mov    ecx,0x0
  40d235:	eb 05                	jmp    40d23c <__page_bump_alloc+0x14c>
  40d237:	b9 01 00 00 00       	mov    ecx,0x1
  40d23c:	5d                   	pop    rbp
  40d23d:	5c                   	pop    rsp
		if (call_cap_op(ci->mi.pgtbl_cap, op, ret, 0, 0, 0)) goto error;
  40d23e:	85 c0                	test   eax,eax
  40d240:	0f 85 ca 00 00 00    	jne    40d310 <__page_bump_alloc+0x220>
{ l->o = 0; }
  40d246:	49 c7 86 60 01 00 00 	mov    QWORD PTR [r14+0x160],0x0
  40d24d:	00 00 00 00 
	 */
	for (heap_cursor = heap_vaddr; heap_cursor < heap_limit; heap_cursor += PAGE_SIZE) {
		vaddr_t umem;

		umem = __umem_bump_alloc(ci);
		if (!umem) return 0;
  40d251:	48 85 db             	test   rbx,rbx
  40d254:	0f 84 c1 00 00 00    	je     40d31b <__page_bump_alloc+0x22b>

		/* Actually map in the memory. */
		if (call_cap_op(meta->mi.pgtbl_cap, CAPTBL_OP_MEMACTIVATE, umem, ci->pgtbl_cap, heap_cursor, PAGE_ORDER)) {
  40d25a:	48 8b 45 a8          	mov    rax,QWORD PTR [rbp-0x58]
  40d25e:	49 8b 37             	mov    rsi,QWORD PTR [r15]
  40d261:	ba 0c 00 00 00       	mov    edx,0xc
  40d266:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  40d26a:	48 8b 7d b8          	mov    rdi,QWORD PTR [rbp-0x48]
  40d26e:	48 8b 80 40 01 00 00 	mov    rax,QWORD PTR [rax+0x140]
  40d275:	48 89 45 b0          	mov    QWORD PTR [rbp-0x50],rax
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40d279:	8b 45 b0             	mov    eax,DWORD PTR [rbp-0x50]
  40d27c:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40d27f:	05 17 00 01 00       	add    eax,0x10017
	__asm__ __volatile__(
  40d284:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40d287:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40d28b:	48 89 cd             	mov    rbp,rcx
  40d28e:	49 b8 a8 d2 40 00 00 	movabs r8,0x40d2a8
  40d295:	00 00 00 
  40d298:	0f 05                	syscall 
  40d29a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40d2a0:	eb 0d                	jmp    40d2af <__page_bump_alloc+0x1bf>
  40d2a2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40d2a8:	b9 00 00 00 00       	mov    ecx,0x0
  40d2ad:	eb 05                	jmp    40d2b4 <__page_bump_alloc+0x1c4>
  40d2af:	b9 01 00 00 00       	mov    ecx,0x1
  40d2b4:	5d                   	pop    rbp
  40d2b5:	5c                   	pop    rsp
  40d2b6:	85 c0                	test   eax,eax
  40d2b8:	0f 85 94 00 00 00    	jne    40d352 <__page_bump_alloc+0x262>
	for (heap_cursor = heap_vaddr; heap_cursor < heap_limit; heap_cursor += PAGE_SIZE) {
  40d2be:	48 81 45 b8 00 10 00 	add    QWORD PTR [rbp-0x48],0x1000
  40d2c5:	00 
  40d2c6:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  40d2ca:	48 39 45 a0          	cmp    QWORD PTR [rbp-0x60],rax
  40d2ce:	76 53                	jbe    40d323 <__page_bump_alloc+0x233>
	return ci->memsrc;
  40d2d0:	4d 8b b7 08 01 00 00 	mov    r14,QWORD PTR [r15+0x108]
	assert(ci && ci == __compinfo_metacap(__ci));
  40d2d7:	4d 85 f6             	test   r14,r14
  40d2da:	0f 85 77 fe ff ff    	jne    40d157 <__page_bump_alloc+0x67>
  40d2e0:	be 2e 00 00 00       	mov    esi,0x2e
  40d2e5:	bf 80 e0 41 00       	mov    edi,0x41e080
  40d2ea:	e8 91 d9 ff ff       	call   40ac80 <cos_print_str>
  40d2ef:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d2f6:	00 00 00 00 
  40d2fa:	0f 0b                	ud2    
  40d2fc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  40d300:	49 c7 86 60 01 00 00 	mov    QWORD PTR [r14+0x160],0x0
  40d307:	00 00 00 00 
		if (!umem) return 0;
  40d30b:	e9 4a ff ff ff       	jmp    40d25a <__page_bump_alloc+0x16a>
  40d310:	49 c7 86 60 01 00 00 	mov    QWORD PTR [r14+0x160],0x0
  40d317:	00 00 00 00 
  40d31b:	48 c7 45 98 00 00 00 	mov    QWORD PTR [rbp-0x68],0x0
  40d322:	00 
			return 0;
		}
	}

	return heap_vaddr;
}
  40d323:	48 8b 45 98          	mov    rax,QWORD PTR [rbp-0x68]
  40d327:	48 83 c4 48          	add    rsp,0x48
  40d32b:	5b                   	pop    rbx
  40d32c:	41 5c                	pop    r12
  40d32e:	41 5d                	pop    r13
  40d330:	41 5e                	pop    r14
  40d332:	41 5f                	pop    r15
  40d334:	5d                   	pop    rbp
  40d335:	c3                   	ret    
  40d336:	be 2e 00 00 00       	mov    esi,0x2e
  40d33b:	bf 80 e3 41 00       	mov    edi,0x41e380
  40d340:	e8 3b d9 ff ff       	call   40ac80 <cos_print_str>
	assert(heap_limit > heap_vaddr);
  40d345:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d34c:	00 00 00 00 
  40d350:	0f 0b                	ud2    
  40d352:	be 2e 00 00 00       	mov    esi,0x2e
  40d357:	bf b0 e3 41 00       	mov    edi,0x41e3b0
  40d35c:	e8 1f d9 ff ff       	call   40ac80 <cos_print_str>
			assert(0);
  40d361:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d368:	00 00 00 00 
  40d36c:	0f 0b                	ud2    
  40d36e:	66 90                	xchg   ax,ax

000000000040d370 <__bump_mem_expand_intern>:
{
  40d370:	55                   	push   rbp
  40d371:	48 89 e5             	mov    rbp,rsp
  40d374:	41 57                	push   r15
  40d376:	41 56                	push   r14
  40d378:	41 55                	push   r13
  40d37a:	41 54                	push   r12
  40d37c:	53                   	push   rbx
  40d37d:	48 83 ec 28          	sub    rsp,0x28
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  40d381:	48 3b bf 08 01 00 00 	cmp    rdi,QWORD PTR [rdi+0x108]
  40d388:	0f 85 ce 01 00 00    	jne    40d55c <__bump_mem_expand_intern+0x1ec>
  40d38e:	49 89 f6             	mov    r14,rsi
  40d391:	49 89 d7             	mov    r15,rdx
  40d394:	4c 8d 55 c0          	lea    r10,[rbp-0x40]
  40d398:	49 89 cd             	mov    r13,rcx
	if (!intern) {
  40d39b:	48 85 c9             	test   rcx,rcx
  40d39e:	74 60                	je     40d400 <__bump_mem_expand_intern+0x90>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40d3a0:	41 c1 e6 10          	shl    r14d,0x10
	__asm__ __volatile__(
  40d3a4:	31 d2                	xor    edx,edx
  40d3a6:	4c 89 eb             	mov    rbx,r13
  40d3a9:	4c 89 fe             	mov    rsi,r15
	cap_no += op;
  40d3ac:	41 8d 86 01 00 01 00 	lea    eax,[r14+0x10001]
	__asm__ __volatile__(
  40d3b3:	48 89 d7             	mov    rdi,rdx
  40d3b6:	4c 89 d1             	mov    rcx,r10
  40d3b9:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40d3bc:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40d3c0:	48 89 cd             	mov    rbp,rcx
  40d3c3:	49 b8 d8 d3 40 00 00 	movabs r8,0x40d3d8
  40d3ca:	00 00 00 
  40d3cd:	0f 05                	syscall 
  40d3cf:	90                   	nop
  40d3d0:	eb 0d                	jmp    40d3df <__bump_mem_expand_intern+0x6f>
  40d3d2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40d3d8:	b9 00 00 00 00       	mov    ecx,0x0
  40d3dd:	eb 05                	jmp    40d3e4 <__bump_mem_expand_intern+0x74>
  40d3df:	b9 01 00 00 00       	mov    ecx,0x1
  40d3e4:	5d                   	pop    rbp
  40d3e5:	5c                   	pop    rsp
}
  40d3e6:	48 83 c4 28          	add    rsp,0x28
  40d3ea:	4c 89 e8             	mov    rax,r13
  40d3ed:	5b                   	pop    rbx
  40d3ee:	41 5c                	pop    r12
  40d3f0:	41 5d                	pop    r13
  40d3f2:	41 5e                	pop    r14
  40d3f4:	41 5f                	pop    r15
  40d3f6:	5d                   	pop    rbp
  40d3f7:	c3                   	ret    
  40d3f8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40d3ff:	00 
  40d400:	49 89 fc             	mov    r12,rdi
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  40d403:	0f 01 f9             	rdtscp 
	return (long)coreid;
  40d406:	48 89 cf             	mov    rdi,rcx
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40d409:	49 8d 94 24 58 01 00 	lea    rdx,[r12+0x158]
  40d410:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  40d411:	be 01 00 00 00       	mov    esi,0x1
  40d416:	31 c9                	xor    ecx,ecx
  40d418:	81 e7 ff 0f 00 00    	and    edi,0xfff
		frontier = &ci->cap64_frontier[cos_cpuid()];
  40d41e:	4d 8d ac fc a8 00 00 	lea    r13,[r12+rdi*8+0xa8]
  40d425:	00 
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40d426:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40d42d:	00 00 00 
        __asm__ __volatile__("lock " PS_CAS_STR
  40d430:	48 89 c8             	mov    rax,rcx
  40d433:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40d438:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40d43b:	84 c0                	test   al,al
  40d43d:	74 f1                	je     40d430 <__bump_mem_expand_intern+0xc0>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40d43f:	48 8d 5f 14          	lea    rbx,[rdi+0x14]
  40d443:	41 f6 84 fc a8 00 00 	test   BYTE PTR [r12+rdi*8+0xa8],0x3
  40d44a:	00 03 
  40d44c:	0f 84 b0 00 00 00    	je     40d502 <__bump_mem_expand_intern+0x192>
  40d452:	4c 89 45 b8          	mov    QWORD PTR [rbp-0x48],r8
        __asm__ __volatile__("lock " PS_FAA_STR
  40d456:	bb 04 00 00 00       	mov    ebx,0x4
  40d45b:	f0 49 0f c1 5d 00    	lock xadd QWORD PTR [r13+0x0],rbx
{ l->o = 0; }
  40d461:	49 c7 84 24 58 01 00 	mov    QWORD PTR [r12+0x158],0x0
  40d468:	00 00 00 00 00 
	return __mem_bump_alloc(ci, 1, 1);
  40d46d:	4c 89 e7             	mov    rdi,r12
	ret = ps_faa(capsz_frontier, sz);
  40d470:	49 89 dd             	mov    r13,rbx
	return __mem_bump_alloc(ci, 1, 1);
  40d473:	e8 38 f3 ff ff       	call   40c7b0 <__mem_bump_alloc.constprop.0>
  40d478:	48 89 c7             	mov    rdi,rax
		if (pte_cap == 0 || ptemem_cap == 0) {
  40d47b:	48 85 db             	test   rbx,rbx
  40d47e:	0f 84 bc 00 00 00    	je     40d540 <__bump_mem_expand_intern+0x1d0>
  40d484:	48 85 c0             	test   rax,rax
  40d487:	4c 8b 45 b8          	mov    r8,QWORD PTR [rbp-0x48]
  40d48b:	0f 84 af 00 00 00    	je     40d540 <__bump_mem_expand_intern+0x1d0>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40d491:	41 8b 44 24 08       	mov    eax,DWORD PTR [r12+0x8]
	__asm__ __volatile__(
  40d496:	4c 8d 55 c0          	lea    r10,[rbp-0x40]
  40d49a:	49 8b b4 24 40 01 00 	mov    rsi,QWORD PTR [r12+0x140]
  40d4a1:	00 
		if (call_cap_op(meta->captbl_cap, CAPTBL_OP_PGTBLACTIVATE, pte_cap, meta->mi.pgtbl_cap, ptemem_cap,
  40d4a2:	49 8d 50 01          	lea    rdx,[r8+0x1]
  40d4a6:	4c 89 d1             	mov    rcx,r10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40d4a9:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40d4ac:	05 1c 00 01 00       	add    eax,0x1001c
	__asm__ __volatile__(
  40d4b1:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40d4b4:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40d4b8:	48 89 cd             	mov    rbp,rcx
  40d4bb:	49 b8 d0 d4 40 00 00 	movabs r8,0x40d4d0
  40d4c2:	00 00 00 
  40d4c5:	0f 05                	syscall 
  40d4c7:	90                   	nop
  40d4c8:	eb 0d                	jmp    40d4d7 <__bump_mem_expand_intern+0x167>
  40d4ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40d4d0:	b9 00 00 00 00       	mov    ecx,0x0
  40d4d5:	eb 05                	jmp    40d4dc <__bump_mem_expand_intern+0x16c>
  40d4d7:	b9 01 00 00 00       	mov    ecx,0x1
  40d4dc:	5d                   	pop    rbp
  40d4dd:	5c                   	pop    rsp
  40d4de:	85 c0                	test   eax,eax
  40d4e0:	0f 84 ba fe ff ff    	je     40d3a0 <__bump_mem_expand_intern+0x30>
  40d4e6:	be 2e 00 00 00       	mov    esi,0x2e
  40d4eb:	bf 90 e2 41 00       	mov    edi,0x41e290
  40d4f0:	e8 8b d7 ff ff       	call   40ac80 <cos_print_str>
				assert(0); /* race? */
  40d4f5:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d4fc:	00 00 00 00 
  40d500:	0f 0b                	ud2    
		if (__capid_captbl_check_expand(ci)) goto error;
  40d502:	4c 89 e7             	mov    rdi,r12
  40d505:	4c 89 45 b8          	mov    QWORD PTR [rbp-0x48],r8
  40d509:	e8 32 f4 ff ff       	call   40c940 <__capid_captbl_check_expand>
  40d50e:	4c 8b 45 b8          	mov    r8,QWORD PTR [rbp-0x48]
  40d512:	85 c0                	test   eax,eax
  40d514:	75 16                	jne    40d52c <__bump_mem_expand_intern+0x1bc>
        __asm__ __volatile__("lock " PS_FAA_STR
  40d516:	b8 04 00 00 00       	mov    eax,0x4
  40d51b:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40d522:	49 89 44 dc 08       	mov    QWORD PTR [r12+rbx*8+0x8],rax
  40d527:	e9 26 ff ff ff       	jmp    40d452 <__bump_mem_expand_intern+0xe2>
{ l->o = 0; }
  40d52c:	49 c7 84 24 58 01 00 	mov    QWORD PTR [r12+0x158],0x0
  40d533:	00 00 00 00 00 
	return __mem_bump_alloc(ci, 1, 1);
  40d538:	4c 89 e7             	mov    rdi,r12
  40d53b:	e8 70 f2 ff ff       	call   40c7b0 <__mem_bump_alloc.constprop.0>
  40d540:	be 2e 00 00 00       	mov    esi,0x2e
  40d545:	bf 60 e2 41 00       	mov    edi,0x41e260
  40d54a:	e8 31 d7 ff ff       	call   40ac80 <cos_print_str>
			assert(0);
  40d54f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d556:	00 00 00 00 
  40d55a:	0f 0b                	ud2    
  40d55c:	be 2e 00 00 00       	mov    esi,0x2e
  40d561:	bf 30 e2 41 00       	mov    edi,0x41e230
  40d566:	e8 15 d7 ff ff       	call   40ac80 <cos_print_str>
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  40d56b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d572:	00 00 00 00 
  40d576:	0f 0b                	ud2    
  40d578:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40d57f:	00 

000000000040d580 <__round_to_pgt0_page>:
vaddr_t __round_to_pgt0_page(vaddr_t vaddr) { return round_to_pgt0_page(vaddr); }
  40d580:	f3 0f 1e fa          	endbr64 
  40d584:	48 b8 00 00 00 00 80 	movabs rax,0xffffff8000000000
  40d58b:	ff ff ff 
  40d58e:	48 21 f8             	and    rax,rdi
  40d591:	c3                   	ret    
  40d592:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40d599:	00 00 00 00 
  40d59d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040d5a0 <__round_up_to_pgt0_page>:
vaddr_t __round_up_to_pgt0_page(vaddr_t vaddr) { return round_up_to_pgt0_page(vaddr); }
  40d5a0:	f3 0f 1e fa          	endbr64 
  40d5a4:	48 b8 ff ff ff ff 7f 	movabs rax,0x7fffffffff
  40d5ab:	00 00 00 
  40d5ae:	48 ba 00 00 00 00 80 	movabs rdx,0xffffff8000000000
  40d5b5:	ff ff ff 
  40d5b8:	48 01 f8             	add    rax,rdi
  40d5bb:	48 21 d0             	and    rax,rdx
  40d5be:	c3                   	ret    
  40d5bf:	90                   	nop

000000000040d5c0 <__round_to_pgt1_page>:
vaddr_t __round_to_pgt1_page(vaddr_t vaddr) { return round_to_pgt1_page(vaddr); }
  40d5c0:	f3 0f 1e fa          	endbr64 
  40d5c4:	48 89 f8             	mov    rax,rdi
  40d5c7:	48 25 00 00 00 c0    	and    rax,0xffffffffc0000000
  40d5cd:	c3                   	ret    
  40d5ce:	66 90                	xchg   ax,ax

000000000040d5d0 <__round_up_to_pgt1_page>:
vaddr_t __round_up_to_pgt1_page(vaddr_t vaddr) { return round_up_to_pgt1_page(vaddr); }
  40d5d0:	f3 0f 1e fa          	endbr64 
  40d5d4:	48 8d 87 ff ff ff 3f 	lea    rax,[rdi+0x3fffffff]
  40d5db:	48 25 00 00 00 c0    	and    rax,0xffffffffc0000000
  40d5e1:	c3                   	ret    
  40d5e2:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40d5e9:	00 00 00 00 
  40d5ed:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040d5f0 <__round_to_pgt2_page>:
vaddr_t __round_to_pgt2_page(vaddr_t vaddr) { return round_to_pgt2_page(vaddr); }
  40d5f0:	f3 0f 1e fa          	endbr64 
  40d5f4:	48 89 f8             	mov    rax,rdi
  40d5f7:	48 25 00 00 e0 ff    	and    rax,0xffffffffffe00000
  40d5fd:	c3                   	ret    
  40d5fe:	66 90                	xchg   ax,ax

000000000040d600 <__round_up_to_pgt2_page>:
vaddr_t __round_up_to_pgt2_page(vaddr_t vaddr) { return round_up_to_pgt2_page(vaddr); }
  40d600:	f3 0f 1e fa          	endbr64 
  40d604:	48 8d 87 ff ff 1f 00 	lea    rax,[rdi+0x1fffff]
  40d60b:	48 25 00 00 e0 ff    	and    rax,0xffffffffffe00000
  40d611:	c3                   	ret    
  40d612:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40d619:	00 00 00 00 
  40d61d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040d620 <cos_pgtbl_get_range>:
{
  40d620:	f3 0f 1e fa          	endbr64 
  40d624:	31 c0                	xor    eax,eax
  40d626:	83 ff 02             	cmp    edi,0x2
  40d629:	77 0a                	ja     40d635 <cos_pgtbl_get_range+0x15>
  40d62b:	89 ff                	mov    edi,edi
  40d62d:	48 8b 04 fd f0 f3 41 	mov    rax,QWORD PTR [rdi*8+0x41f3f0]
  40d634:	00 
}
  40d635:	c3                   	ret    
  40d636:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40d63d:	00 00 00 

000000000040d640 <cos_pgtbl_round_to_page>:
{
  40d640:	f3 0f 1e fa          	endbr64 
		return round_to_pgt1_page(vaddr);
  40d644:	48 89 f0             	mov    rax,rsi
  40d647:	48 25 00 00 00 c0    	and    rax,0xffffffffc0000000
	switch (pgtbl_lvl)
  40d64d:	83 ff 01             	cmp    edi,0x1
  40d650:	74 14                	je     40d666 <cos_pgtbl_round_to_page+0x26>
		return round_to_pgt2_page(vaddr);
  40d652:	48 89 f0             	mov    rax,rsi
  40d655:	48 25 00 00 e0 ff    	and    rax,0xffffffffffe00000
	switch (pgtbl_lvl)
  40d65b:	83 ff 02             	cmp    edi,0x2
  40d65e:	74 06                	je     40d666 <cos_pgtbl_round_to_page+0x26>
  40d660:	31 c0                	xor    eax,eax
  40d662:	85 ff                	test   edi,edi
  40d664:	74 0a                	je     40d670 <cos_pgtbl_round_to_page+0x30>
}
  40d666:	c3                   	ret    
  40d667:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40d66e:	00 00 
		return round_to_pgt0_page(vaddr);
  40d670:	48 b8 00 00 00 00 80 	movabs rax,0xffffff8000000000
  40d677:	ff ff ff 
  40d67a:	48 21 f0             	and    rax,rsi
}
  40d67d:	c3                   	ret    
  40d67e:	66 90                	xchg   ax,ax

000000000040d680 <cos_pgtbl_round_up_to_page>:
{
  40d680:	f3 0f 1e fa          	endbr64 
	switch (pgtbl_lvl)
  40d684:	83 ff 01             	cmp    edi,0x1
  40d687:	74 47                	je     40d6d0 <cos_pgtbl_round_up_to_page+0x50>
  40d689:	83 ff 02             	cmp    edi,0x2
  40d68c:	74 2a                	je     40d6b8 <cos_pgtbl_round_up_to_page+0x38>
  40d68e:	31 c0                	xor    eax,eax
  40d690:	85 ff                	test   edi,edi
  40d692:	74 04                	je     40d698 <cos_pgtbl_round_up_to_page+0x18>
}
  40d694:	c3                   	ret    
  40d695:	0f 1f 00             	nop    DWORD PTR [rax]
		return round_up_to_pgt0_page(vaddr);
  40d698:	48 b8 ff ff ff ff 7f 	movabs rax,0x7fffffffff
  40d69f:	00 00 00 
  40d6a2:	48 ba 00 00 00 00 80 	movabs rdx,0xffffff8000000000
  40d6a9:	ff ff ff 
  40d6ac:	48 01 f0             	add    rax,rsi
  40d6af:	48 21 d0             	and    rax,rdx
  40d6b2:	c3                   	ret    
  40d6b3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		return round_up_to_pgt2_page(vaddr);
  40d6b8:	48 8d 86 ff ff 1f 00 	lea    rax,[rsi+0x1fffff]
  40d6bf:	48 25 00 00 e0 ff    	and    rax,0xffffffffffe00000
}
  40d6c5:	c3                   	ret    
  40d6c6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40d6cd:	00 00 00 
		return round_up_to_pgt1_page(vaddr);
  40d6d0:	48 8d 86 ff ff ff 3f 	lea    rax,[rsi+0x3fffffff]
  40d6d7:	48 25 00 00 00 c0    	and    rax,0xffffffffc0000000
  40d6dd:	c3                   	ret    
  40d6de:	66 90                	xchg   ax,ax

000000000040d6e0 <cos_meminfo_init>:
{
  40d6e0:	f3 0f 1e fa          	endbr64 
	mi->untyped_frontier = untyped_ptr + untyped_sz;
  40d6e4:	48 01 f2             	add    rdx,rsi
  40d6e7:	66 48 0f 6e ce       	movq   xmm1,rsi
	mi->untyped_ptr = mi->umem_ptr = mi->kmem_ptr = mi->umem_frontier = mi->kmem_frontier = untyped_ptr;
  40d6ec:	66 48 0f 6e c6       	movq   xmm0,rsi
	mi->pgtbl_cap        = pgtbl_cap;
  40d6f1:	48 89 4f 30          	mov    QWORD PTR [rdi+0x30],rcx
	mi->untyped_ptr = mi->umem_ptr = mi->kmem_ptr = mi->umem_frontier = mi->kmem_frontier = untyped_ptr;
  40d6f5:	66 48 0f 6e d2       	movq   xmm2,rdx
  40d6fa:	66 0f 6c c9          	punpcklqdq xmm1,xmm1
  40d6fe:	66 0f 6c c2          	punpcklqdq xmm0,xmm2
  40d702:	0f 11 0f             	movups XMMWORD PTR [rdi],xmm1
  40d705:	0f 11 47 10          	movups XMMWORD PTR [rdi+0x10],xmm0
  40d709:	0f 11 4f 20          	movups XMMWORD PTR [rdi+0x20],xmm1
}
  40d70d:	c3                   	ret    
  40d70e:	66 90                	xchg   ax,ax

000000000040d710 <cos_compinfo_init>:
{
  40d710:	f3 0f 1e fa          	endbr64 
  40d714:	55                   	push   rbp
  40d715:	49 89 d2             	mov    r10,rdx
  40d718:	66 48 0f 6e c6       	movq   xmm0,rsi
  40d71d:	66 49 0f 6e ca       	movq   xmm1,r10
  40d722:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  40d726:	48 89 e5             	mov    rbp,rsp
  40d729:	48 8b 55 10          	mov    rdx,QWORD PTR [rbp+0x10]
	assert(ci && ci_resources);
  40d72d:	48 85 ff             	test   rdi,rdi
  40d730:	0f 84 4c 01 00 00    	je     40d882 <cos_compinfo_init+0x172>
  40d736:	48 85 d2             	test   rdx,rdx
  40d739:	0f 84 43 01 00 00    	je     40d882 <cos_compinfo_init+0x172>
	assert(cap_frontier % CAPMAX_ENTRY_SZ == 0);
  40d73f:	41 f6 c1 03          	test   r9b,0x3
  40d743:	0f 85 55 01 00 00    	jne    40d89e <cos_compinfo_init+0x18e>
	ci->memsrc = ci_resources;
  40d749:	48 89 97 08 01 00 00 	mov    QWORD PTR [rdi+0x108],rdx
  40d750:	48 89 f8             	mov    rax,rdi
	assert(ci_resources->memsrc == ci_resources); /* prevent infinite data-structs */
  40d753:	48 39 92 08 01 00 00 	cmp    QWORD PTR [rdx+0x108],rdx
  40d75a:	0f 85 5a 01 00 00    	jne    40d8ba <cos_compinfo_init+0x1aa>
	vaddr_t last_page = round_to_page(heap_ptr - 1);
  40d760:	49 8d 50 ff          	lea    rdx,[r8-0x1]
	ci->comp_cap     		= comp_cap;
  40d764:	48 89 4f 10          	mov    QWORD PTR [rdi+0x10],rcx
		return round_up_to_pgt0_page(vaddr);
  40d768:	48 b9 ff ff ff ff 7f 	movabs rcx,0x7fffffffff
  40d76f:	00 00 00 
  40d772:	48 be 00 00 00 00 80 	movabs rsi,0xffffff8000000000
  40d779:	ff ff ff 
	vaddr_t last_page = round_to_page(heap_ptr - 1);
  40d77c:	48 81 e2 00 f0 ff ff 	and    rdx,0xfffffffffffff000
	ci->pgtbl_cap    		= pgtbl_cap;
  40d783:	0f 11 07             	movups XMMWORD PTR [rdi],xmm0
	ci->comp_cap_shared 	= 0;
  40d786:	66 0f ef c0          	pxor   xmm0,xmm0
		return round_up_to_pgt0_page(vaddr);
  40d78a:	48 01 d1             	add    rcx,rdx
	ci->comp_cap_shared 	= 0;
  40d78d:	0f 11 87 70 01 00 00 	movups XMMWORD PTR [rdi+0x170],xmm0
	ci->vas_frontier = heap_ptr;
  40d794:	66 49 0f 6e c0       	movq   xmm0,r8
		return round_up_to_pgt0_page(vaddr);
  40d799:	48 21 f1             	and    rcx,rsi
	ci->cap_frontier 		= 0;
  40d79c:	48 c7 47 18 00 00 00 	mov    QWORD PTR [rdi+0x18],0x0
  40d7a3:	00 
	ci->vas_frontier = heap_ptr;
  40d7a4:	66 48 0f 6e d1       	movq   xmm2,rcx
		return round_up_to_pgt1_page(vaddr);
  40d7a9:	48 8d 8a ff ff ff 3f 	lea    rcx,[rdx+0x3fffffff]
		return round_up_to_pgt2_page(vaddr);
  40d7b0:	48 81 c2 ff ff 1f 00 	add    rdx,0x1fffff
	ci->vas_frontier = heap_ptr;
  40d7b7:	66 0f 6c c2          	punpcklqdq xmm0,xmm2
		return round_up_to_pgt2_page(vaddr);
  40d7bb:	48 81 e2 00 00 e0 ff 	and    rdx,0xffffffffffe00000
		return round_up_to_pgt1_page(vaddr);
  40d7c2:	48 81 e1 00 00 00 c0 	and    rcx,0xffffffffc0000000
	ci->vas_frontier = heap_ptr;
  40d7c9:	66 48 0f 6e da       	movq   xmm3,rdx
  40d7ce:	0f 11 87 e8 00 00 00 	movups XMMWORD PTR [rdi+0xe8],xmm0
	assert(round_up_to_pow2(cap_frontier, CAPMAX_ENTRY_SZ) == cap_frontier);
  40d7d5:	49 8d 51 03          	lea    rdx,[r9+0x3]
	ci->vas_frontier = heap_ptr;
  40d7d9:	66 48 0f 6e c1       	movq   xmm0,rcx
  40d7de:	66 0f 6c c3          	punpcklqdq xmm0,xmm3
	assert(round_up_to_pow2(cap_frontier, CAPMAX_ENTRY_SZ) == cap_frontier);
  40d7e2:	48 83 e2 fc          	and    rdx,0xfffffffffffffffc
	ci->vas_frontier = heap_ptr;
  40d7e6:	0f 11 87 f8 00 00 00 	movups XMMWORD PTR [rdi+0xf8],xmm0
	assert(round_up_to_pow2(cap_frontier, CAPMAX_ENTRY_SZ) == cap_frontier);
  40d7ed:	49 39 d1             	cmp    r9,rdx
  40d7f0:	0f 85 e0 00 00 00    	jne    40d8d6 <cos_compinfo_init+0x1c6>
	ci->cap_frontier = cap_frontier;
  40d7f6:	4c 89 4f 18          	mov    QWORD PTR [rdi+0x18],r9
	if (cap_frontier < CAPTBL_EXPAND_SZ) {
  40d7fa:	49 83 f9 7f          	cmp    r9,0x7f
  40d7fe:	76 78                	jbe    40d878 <cos_compinfo_init+0x168>
		ci->caprange_frontier = round_up_to_pow2(cap_frontier + CAPTBL_EXPAND_SZ, CAPTBL_EXPAND_SZ * 2) - CAPTBL_EXPAND_SZ;
  40d800:	49 8d 91 7f 01 00 00 	lea    rdx,[r9+0x17f]
  40d807:	30 d2                	xor    dl,dl
  40d809:	48 83 c2 80          	add    rdx,0xffffffffffffff80
  40d80d:	66 49 0f 6e c1       	movq   xmm0,r9
  40d812:	48 89 50 20          	mov    QWORD PTR [rax+0x20],rdx
{ l->o = 0; }
  40d816:	48 c7 80 68 01 00 00 	mov    QWORD PTR [rax+0x168],0x0
  40d81d:	00 00 00 00 
  40d821:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
		ci->cap16_frontier[i] = ci->cap32_frontier[i] = ci->cap64_frontier[i] = cap_frontier;
  40d825:	0f 11 80 a8 00 00 00 	movups XMMWORD PTR [rax+0xa8],xmm0
  40d82c:	0f 11 40 68          	movups XMMWORD PTR [rax+0x68],xmm0
  40d830:	0f 11 40 28          	movups XMMWORD PTR [rax+0x28],xmm0
  40d834:	0f 11 80 b8 00 00 00 	movups XMMWORD PTR [rax+0xb8],xmm0
  40d83b:	0f 11 40 78          	movups XMMWORD PTR [rax+0x78],xmm0
  40d83f:	0f 11 40 38          	movups XMMWORD PTR [rax+0x38],xmm0
  40d843:	0f 11 80 c8 00 00 00 	movups XMMWORD PTR [rax+0xc8],xmm0
  40d84a:	0f 11 80 88 00 00 00 	movups XMMWORD PTR [rax+0x88],xmm0
  40d851:	0f 11 40 48          	movups XMMWORD PTR [rax+0x48],xmm0
  40d855:	0f 11 80 d8 00 00 00 	movups XMMWORD PTR [rax+0xd8],xmm0
  40d85c:	0f 11 80 98 00 00 00 	movups XMMWORD PTR [rax+0x98],xmm0
  40d863:	0f 11 40 58          	movups XMMWORD PTR [rax+0x58],xmm0
  40d867:	66 0f ef c0          	pxor   xmm0,xmm0
  40d86b:	0f 11 80 58 01 00 00 	movups XMMWORD PTR [rax+0x158],xmm0
}
  40d872:	5d                   	pop    rbp
  40d873:	c3                   	ret    
  40d874:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		ci->caprange_frontier = round_up_to_pow2(cap_frontier, CAPTBL_EXPAND_SZ);
  40d878:	49 8d 51 7f          	lea    rdx,[r9+0x7f]
  40d87c:	48 83 e2 80          	and    rdx,0xffffffffffffff80
  40d880:	eb 8b                	jmp    40d80d <cos_compinfo_init+0xfd>
  40d882:	be 2e 00 00 00       	mov    esi,0x2e
  40d887:	bf e0 e3 41 00       	mov    edi,0x41e3e0
  40d88c:	e8 ef d3 ff ff       	call   40ac80 <cos_print_str>
	assert(ci && ci_resources);
  40d891:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d898:	00 00 00 00 
  40d89c:	0f 0b                	ud2    
  40d89e:	be 2e 00 00 00       	mov    esi,0x2e
  40d8a3:	bf 10 e4 41 00       	mov    edi,0x41e410
  40d8a8:	e8 d3 d3 ff ff       	call   40ac80 <cos_print_str>
	assert(cap_frontier % CAPMAX_ENTRY_SZ == 0);
  40d8ad:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d8b4:	00 00 00 00 
  40d8b8:	0f 0b                	ud2    
  40d8ba:	be 2e 00 00 00       	mov    esi,0x2e
  40d8bf:	bf 40 e4 41 00       	mov    edi,0x41e440
  40d8c4:	e8 b7 d3 ff ff       	call   40ac80 <cos_print_str>
	assert(ci_resources->memsrc == ci_resources); /* prevent infinite data-structs */
  40d8c9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d8d0:	00 00 00 00 
  40d8d4:	0f 0b                	ud2    
  40d8d6:	be 2e 00 00 00       	mov    esi,0x2e
  40d8db:	bf 70 e4 41 00       	mov    edi,0x41e470
  40d8e0:	e8 9b d3 ff ff       	call   40ac80 <cos_print_str>
	assert(round_up_to_pow2(cap_frontier, CAPMAX_ENTRY_SZ) == cap_frontier);
  40d8e5:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40d8ec:	00 00 00 00 
  40d8f0:	0f 0b                	ud2    
  40d8f2:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40d8f9:	00 00 00 00 
  40d8fd:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040d900 <cos_capid_bump_alloc>:
{ return __capid_bump_alloc(ci, cap); }
  40d900:	f3 0f 1e fa          	endbr64 
  40d904:	55                   	push   rbp
  40d905:	48 89 e5             	mov    rbp,rsp
  40d908:	41 56                	push   r14
  40d90a:	41 55                	push   r13
  40d90c:	41 54                	push   r12
  40d90e:	53                   	push   rbx
/* a function instead of a struct to enable inlining + constant prop */
static inline cap_sz_t
__captbl_cap2sz(cap_t c)
{
	/* TODO: optimize for invocation and return */
	switch (c) {
  40d90f:	83 fe 14             	cmp    esi,0x14
  40d912:	0f 87 94 00 00 00    	ja     40d9ac <cos_capid_bump_alloc+0xac>
  40d918:	b8 01 00 00 00       	mov    eax,0x1
  40d91d:	89 f1                	mov    ecx,esi
  40d91f:	48 89 fb             	mov    rbx,rdi
  40d922:	48 d3 e0             	shl    rax,cl
  40d925:	a9 da 81 1f 00       	test   eax,0x1f81da
  40d92a:	74 74                	je     40d9a0 <cos_capid_bump_alloc+0xa0>
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  40d92c:	0f 01 f9             	rdtscp 
		frontier = &ci->cap64_frontier[cos_cpuid()];
  40d92f:	81 e1 ff 0f 00 00    	and    ecx,0xfff
		break;
  40d935:	41 bd 04 00 00 00    	mov    r13d,0x4
		frontier = &ci->cap64_frontier[cos_cpuid()];
  40d93b:	4c 8d b4 cf a8 00 00 	lea    r14,[rdi+rcx*8+0xa8]
  40d942:	00 
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40d943:	48 8d 93 58 01 00 00 	lea    rdx,[rbx+0x158]
        __asm__ __volatile__("lock " PS_CAS_STR
  40d94a:	be 01 00 00 00       	mov    esi,0x1
  40d94f:	31 c9                	xor    ecx,ecx
  40d951:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  40d958:	48 89 c8             	mov    rax,rcx
  40d95b:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40d960:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40d963:	84 c0                	test   al,al
  40d965:	74 f1                	je     40d958 <cos_capid_bump_alloc+0x58>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40d967:	4d 8b 26             	mov    r12,QWORD PTR [r14]
  40d96a:	41 83 e4 03          	and    r12d,0x3
  40d96e:	0f 84 8c 00 00 00    	je     40da00 <cos_capid_bump_alloc+0x100>
        __asm__ __volatile__("lock " PS_FAA_STR
  40d974:	4c 89 e8             	mov    rax,r13
  40d977:	f0 49 0f c1 06       	lock xadd QWORD PTR [r14],rax
  40d97c:	49 89 c4             	mov    r12,rax
{ l->o = 0; }
  40d97f:	48 c7 83 58 01 00 00 	mov    QWORD PTR [rbx+0x158],0x0
  40d986:	00 00 00 00 
{ return __capid_bump_alloc(ci, cap); }
  40d98a:	4c 89 e0             	mov    rax,r12
  40d98d:	5b                   	pop    rbx
  40d98e:	41 5c                	pop    r12
  40d990:	41 5d                	pop    r13
  40d992:	41 5e                	pop    r14
  40d994:	5d                   	pop    rbp
  40d995:	c3                   	ret    
  40d996:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40d99d:	00 00 00 
  40d9a0:	a9 24 10 00 00       	test   eax,0x1024
  40d9a5:	75 39                	jne    40d9e0 <cos_capid_bump_alloc+0xe0>
  40d9a7:	f6 c4 60             	test   ah,0x60
  40d9aa:	75 14                	jne    40d9c0 <cos_capid_bump_alloc+0xc0>
  40d9ac:	49 c7 c4 ff ff ff ff 	mov    r12,0xffffffffffffffff
  40d9b3:	5b                   	pop    rbx
  40d9b4:	4c 89 e0             	mov    rax,r12
  40d9b7:	41 5c                	pop    r12
  40d9b9:	41 5d                	pop    r13
  40d9bb:	41 5e                	pop    r14
  40d9bd:	5d                   	pop    rbp
  40d9be:	c3                   	ret    
  40d9bf:	90                   	nop
  40d9c0:	0f 01 f9             	rdtscp 
		frontier = &ci->cap32_frontier[cos_cpuid()];
  40d9c3:	81 e1 ff 0f 00 00    	and    ecx,0xfff
		break;
  40d9c9:	41 bd 02 00 00 00    	mov    r13d,0x2
		frontier = &ci->cap32_frontier[cos_cpuid()];
  40d9cf:	4c 8d 74 cf 68       	lea    r14,[rdi+rcx*8+0x68]
		break;
  40d9d4:	e9 6a ff ff ff       	jmp    40d943 <cos_capid_bump_alloc+0x43>
  40d9d9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  40d9e0:	0f 01 f9             	rdtscp 
		frontier = &ci->cap16_frontier[cos_cpuid()];
  40d9e3:	81 e1 ff 0f 00 00    	and    ecx,0xfff
		break;
  40d9e9:	41 bd 01 00 00 00    	mov    r13d,0x1
		frontier = &ci->cap16_frontier[cos_cpuid()];
  40d9ef:	4c 8d 74 cf 28       	lea    r14,[rdi+rcx*8+0x28]
		break;
  40d9f4:	e9 4a ff ff ff       	jmp    40d943 <cos_capid_bump_alloc+0x43>
  40d9f9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  40da00:	48 89 df             	mov    rdi,rbx
  40da03:	e8 38 ef ff ff       	call   40c940 <__capid_captbl_check_expand>
  40da08:	85 c0                	test   eax,eax
  40da0a:	0f 85 6f ff ff ff    	jne    40d97f <cos_capid_bump_alloc+0x7f>
        __asm__ __volatile__("lock " PS_FAA_STR
  40da10:	b8 04 00 00 00       	mov    eax,0x4
  40da15:	f0 48 0f c1 43 18    	lock xadd QWORD PTR [rbx+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40da1b:	49 89 06             	mov    QWORD PTR [r14],rax
  40da1e:	e9 51 ff ff ff       	jmp    40d974 <cos_capid_bump_alloc+0x74>
  40da23:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40da2a:	00 00 00 00 
  40da2e:	66 90                	xchg   ax,ax

000000000040da30 <cos_pgtbl_intern_alloc>:
{
  40da30:	f3 0f 1e fa          	endbr64 
  40da34:	55                   	push   rbp
  40da35:	48 89 e5             	mov    rbp,rsp
  40da38:	41 57                	push   r15
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  40da3a:	45 31 ff             	xor    r15d,r15d
{
  40da3d:	41 56                	push   r14
  40da3f:	49 89 ce             	mov    r14,rcx
  40da42:	41 55                	push   r13
  40da44:	49 89 d5             	mov    r13,rdx
  40da47:	41 54                	push   r12
  40da49:	49 89 f4             	mov    r12,rsi
  40da4c:	53                   	push   rbx
  40da4d:	48 89 fb             	mov    rbx,rdi
  40da50:	48 83 ec 08          	sub    rsp,0x8
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  40da54:	80 bf 80 01 00 00 01 	cmp    BYTE PTR [rdi+0x180],0x1
		ret = __bump_mem_expand_range(__compinfo_metacap(ci), cipgtbl, mem_ptr, mem_sz, i | pgtbl_lvl_flag);	
  40da5b:	48 8b bf 08 01 00 00 	mov    rdi,QWORD PTR [rdi+0x108]
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  40da62:	41 0f 94 c7          	sete   r15b
  40da66:	49 c1 e7 1f          	shl    r15,0x1f
		ret = __bump_mem_expand_range(__compinfo_metacap(ci), cipgtbl, mem_ptr, mem_sz, i | pgtbl_lvl_flag);	
  40da6a:	45 89 f8             	mov    r8d,r15d
  40da6d:	41 83 c8 01          	or     r8d,0x1
  40da71:	e8 7a f1 ff ff       	call   40cbf0 <__bump_mem_expand_range>
  40da76:	45 89 f8             	mov    r8d,r15d
  40da79:	4c 89 f1             	mov    rcx,r14
  40da7c:	4c 89 ea             	mov    rdx,r13
  40da7f:	48 8b bb 08 01 00 00 	mov    rdi,QWORD PTR [rbx+0x108]
}
  40da86:	48 83 c4 08          	add    rsp,0x8
		ret = __bump_mem_expand_range(__compinfo_metacap(ci), cipgtbl, mem_ptr, mem_sz, i | pgtbl_lvl_flag);	
  40da8a:	4c 89 e6             	mov    rsi,r12
  40da8d:	41 83 c8 02          	or     r8d,0x2
}
  40da91:	5b                   	pop    rbx
  40da92:	41 5c                	pop    r12
  40da94:	41 5d                	pop    r13
  40da96:	41 5e                	pop    r14
  40da98:	41 5f                	pop    r15
  40da9a:	5d                   	pop    rbp
		ret = __bump_mem_expand_range(__compinfo_metacap(ci), cipgtbl, mem_ptr, mem_sz, i | pgtbl_lvl_flag);	
  40da9b:	e9 50 f1 ff ff       	jmp    40cbf0 <__bump_mem_expand_range>

000000000040daa0 <cos_pgtbl_intern_expand>:
{
  40daa0:	f3 0f 1e fa          	endbr64 
  40daa4:	55                   	push   rbp
  40daa5:	48 89 e5             	mov    rbp,rsp
  40daa8:	41 56                	push   r14
  40daaa:	41 55                	push   r13
  40daac:	41 54                	push   r12
  40daae:	53                   	push   rbx
	assert(lvl > 0);
  40daaf:	85 d2                	test   edx,edx
  40dab1:	0f 8e c3 00 00 00    	jle    40db7a <cos_pgtbl_intern_expand+0xda>
  40dab7:	48 89 fb             	mov    rbx,rdi
  40daba:	49 89 f4             	mov    r12,rsi
  40dabd:	48 8d 8f 68 01 00 00 	lea    rcx,[rdi+0x168]
  40dac4:	31 f6                	xor    esi,esi
  40dac6:	bf 01 00 00 00       	mov    edi,0x1
  40dacb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  40dad0:	48 89 f0             	mov    rax,rsi
  40dad3:	f0 48 0f b1 39       	lock cmpxchg QWORD PTR [rcx],rdi
  40dad8:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40dadb:	84 c0                	test   al,al
  40dadd:	74 f1                	je     40dad0 <cos_pgtbl_intern_expand+0x30>
	if (ci->vasrange_frontier[lvl] != round_to_pgd_page(mem_ptr)) goto error;
  40dadf:	48 b8 00 00 00 00 80 	movabs rax,0xffffff8000000000
  40dae6:	ff ff ff 
  40dae9:	4c 63 ea             	movsxd r13,edx
  40daec:	4e 8d 34 eb          	lea    r14,[rbx+r13*8]
  40daf0:	4c 21 e0             	and    rax,r12
  40daf3:	49 39 86 f0 00 00 00 	cmp    QWORD PTR [r14+0xf0],rax
  40dafa:	74 24                	je     40db20 <cos_pgtbl_intern_expand+0x80>
	return 0;
  40dafc:	45 31 c0             	xor    r8d,r8d
{ l->o = 0; }
  40daff:	48 c7 83 68 01 00 00 	mov    QWORD PTR [rbx+0x168],0x0
  40db06:	00 00 00 00 
}
  40db0a:	4c 89 c0             	mov    rax,r8
  40db0d:	5b                   	pop    rbx
  40db0e:	41 5c                	pop    r12
  40db10:	41 5d                	pop    r13
  40db12:	41 5e                	pop    r14
  40db14:	5d                   	pop    rbp
  40db15:	c3                   	ret    
  40db16:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40db1d:	00 00 00 
	cap = __bump_mem_expand_intern(__compinfo_metacap(ci), ci->pgtbl_cap, mem_ptr, 0, 0);
  40db20:	48 8b bb 08 01 00 00 	mov    rdi,QWORD PTR [rbx+0x108]
  40db27:	48 8b 33             	mov    rsi,QWORD PTR [rbx]
  40db2a:	45 31 c0             	xor    r8d,r8d
  40db2d:	31 c9                	xor    ecx,ecx
  40db2f:	4c 89 e2             	mov    rdx,r12
  40db32:	e8 39 f8 ff ff       	call   40d370 <__bump_mem_expand_intern>
  40db37:	49 89 c0             	mov    r8,rax
	if (!cap) goto error;
  40db3a:	48 85 c0             	test   rax,rax
  40db3d:	74 bd                	je     40dafc <cos_pgtbl_intern_expand+0x5c>
		vaddr_t tmp = ps_load(&ci->vasrange_frontier[lvl]);
  40db3f:	49 8b 86 f0 00 00 00 	mov    rax,QWORD PTR [r14+0xf0]
		ps_cas(&ci->vasrange_frontier[lvl], tmp, tmp + PGD_RANGE);
  40db46:	4a 8d 8c eb f0 00 00 	lea    rcx,[rbx+r13*8+0xf0]
  40db4d:	00 
		if (tmp >= mem_ptr + PGD_RANGE) break;
  40db4e:	48 be 00 00 00 00 80 	movabs rsi,0x8000000000
  40db55:	00 00 00 
  40db58:	49 01 f4             	add    r12,rsi
  40db5b:	4c 39 e0             	cmp    rax,r12
  40db5e:	73 9f                	jae    40daff <cos_pgtbl_intern_expand+0x5f>
		ps_cas(&ci->vasrange_frontier[lvl], tmp, tmp + PGD_RANGE);
  40db60:	48 8d 14 30          	lea    rdx,[rax+rsi*1]
        __asm__ __volatile__("lock " PS_CAS_STR
  40db64:	f0 48 0f b1 11       	lock cmpxchg QWORD PTR [rcx],rdx
  40db69:	0f 94 c0             	sete   al
		vaddr_t tmp = ps_load(&ci->vasrange_frontier[lvl]);
  40db6c:	49 8b 86 f0 00 00 00 	mov    rax,QWORD PTR [r14+0xf0]
		if (tmp >= mem_ptr + PGD_RANGE) break;
  40db73:	4c 39 e0             	cmp    rax,r12
  40db76:	72 e8                	jb     40db60 <cos_pgtbl_intern_expand+0xc0>
  40db78:	eb 85                	jmp    40daff <cos_pgtbl_intern_expand+0x5f>
  40db7a:	be 2e 00 00 00       	mov    esi,0x2e
  40db7f:	bf a0 e4 41 00       	mov    edi,0x41e4a0
  40db84:	e8 f7 d0 ff ff       	call   40ac80 <cos_print_str>
	assert(lvl > 0);
  40db89:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40db90:	00 00 00 00 
  40db94:	0f 0b                	ud2    
  40db96:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40db9d:	00 00 00 

000000000040dba0 <cos_pgtbl_intern_expandwith>:
{
  40dba0:	f3 0f 1e fa          	endbr64 
  40dba4:	55                   	push   rbp
  40dba5:	49 89 d1             	mov    r9,rdx
  40dba8:	31 c9                	xor    ecx,ecx
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40dbaa:	48 8d 97 68 01 00 00 	lea    rdx,[rdi+0x168]
  40dbb1:	48 89 e5             	mov    rbp,rsp
  40dbb4:	41 54                	push   r12
  40dbb6:	49 89 f4             	mov    r12,rsi
        __asm__ __volatile__("lock " PS_CAS_STR
  40dbb9:	be 01 00 00 00       	mov    esi,0x1
  40dbbe:	53                   	push   rbx
  40dbbf:	48 89 fb             	mov    rbx,rdi
  40dbc2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40dbc8:	48 89 c8             	mov    rax,rcx
  40dbcb:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40dbd0:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40dbd3:	84 c0                	test   al,al
  40dbd5:	74 f1                	je     40dbc8 <cos_pgtbl_intern_expandwith+0x28>
	if (ci->vasrange_frontier[0] != round_to_pgd_page(mem)) goto error;
  40dbd7:	48 b8 00 00 00 00 80 	movabs rax,0xffffff8000000000
  40dbde:	ff ff ff 
  40dbe1:	4c 21 c8             	and    rax,r9
  40dbe4:	48 39 83 f0 00 00 00 	cmp    QWORD PTR [rbx+0xf0],rax
  40dbeb:	75 29                	jne    40dc16 <cos_pgtbl_intern_expandwith+0x76>
        __asm__ __volatile__("lock " PS_FAA_STR
  40dbed:	48 ba 00 00 00 00 80 	movabs rdx,0x8000000000
  40dbf4:	00 00 00 
  40dbf7:	48 89 d1             	mov    rcx,rdx
  40dbfa:	f0 48 0f c1 8b f0 00 	lock xadd QWORD PTR [rbx+0xf0],rcx
  40dc01:	00 00 
	if ((unsigned long)ps_faa(&ci->vasrange_frontier[0], PGD_RANGE) > round_to_pgd_page(mem)) goto error;
  40dc03:	48 39 c8             	cmp    rax,rcx
  40dc06:	72 0e                	jb     40dc16 <cos_pgtbl_intern_expandwith+0x76>
  40dc08:	f0 48 0f c1 93 e8 00 	lock xadd QWORD PTR [rbx+0xe8],rdx
  40dc0f:	00 00 
	if ((unsigned long)ps_faa(&ci->vas_frontier, PGD_RANGE) > round_to_pgd_page(mem)) goto error;
  40dc11:	48 39 d0             	cmp    rax,rdx
  40dc14:	73 1a                	jae    40dc30 <cos_pgtbl_intern_expandwith+0x90>
{ l->o = 0; }
  40dc16:	48 c7 83 68 01 00 00 	mov    QWORD PTR [rbx+0x168],0x0
  40dc1d:	00 00 00 00 
	return -1;
  40dc21:	b8 ff ff ff ff       	mov    eax,0xffffffff
}
  40dc26:	5b                   	pop    rbx
  40dc27:	41 5c                	pop    r12
  40dc29:	5d                   	pop    rbp
  40dc2a:	c3                   	ret    
  40dc2b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	if (__bump_mem_expand_intern(__compinfo_metacap(ci), ci->pgtbl_cap, mem, intern, 0) != intern) {
  40dc30:	48 8b bb 08 01 00 00 	mov    rdi,QWORD PTR [rbx+0x108]
  40dc37:	48 8b 33             	mov    rsi,QWORD PTR [rbx]
  40dc3a:	45 31 c0             	xor    r8d,r8d
  40dc3d:	4c 89 e1             	mov    rcx,r12
  40dc40:	4c 89 ca             	mov    rdx,r9
  40dc43:	e8 28 f7 ff ff       	call   40d370 <__bump_mem_expand_intern>
  40dc48:	48 c7 83 68 01 00 00 	mov    QWORD PTR [rbx+0x168],0x0
  40dc4f:	00 00 00 00 
}
  40dc53:	5b                   	pop    rbx
	if (__bump_mem_expand_intern(__compinfo_metacap(ci), ci->pgtbl_cap, mem, intern, 0) != intern) {
  40dc54:	4c 39 e0             	cmp    rax,r12
}
  40dc57:	41 5c                	pop    r12
  40dc59:	5d                   	pop    rbp
	if (__bump_mem_expand_intern(__compinfo_metacap(ci), ci->pgtbl_cap, mem, intern, 0) != intern) {
  40dc5a:	0f 95 c0             	setne  al
  40dc5d:	0f b6 c0             	movzx  eax,al
}
  40dc60:	c3                   	ret    
  40dc61:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40dc68:	00 00 00 00 
  40dc6c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000040dc70 <cos_meminfo_alloc>:
{
  40dc70:	f3 0f 1e fa          	endbr64 
	assert(untyped_ptr == round_up_to_pgd_page(untyped_ptr));
  40dc74:	48 b8 ff ff ff ff 7f 	movabs rax,0x7fffffffff
  40dc7b:	00 00 00 
{
  40dc7e:	55                   	push   rbp
	assert(untyped_ptr == round_up_to_pgd_page(untyped_ptr));
  40dc7f:	48 01 f0             	add    rax,rsi
{
  40dc82:	48 89 e5             	mov    rbp,rsp
  40dc85:	41 57                	push   r15
  40dc87:	41 56                	push   r14
  40dc89:	49 89 d6             	mov    r14,rdx
	assert(untyped_ptr == round_up_to_pgd_page(untyped_ptr));
  40dc8c:	48 ba 00 00 00 00 80 	movabs rdx,0xffffff8000000000
  40dc93:	ff ff ff 
{
  40dc96:	41 55                	push   r13
	assert(untyped_ptr == round_up_to_pgd_page(untyped_ptr));
  40dc98:	48 21 d0             	and    rax,rdx
{
  40dc9b:	41 54                	push   r12
  40dc9d:	53                   	push   rbx
  40dc9e:	48 83 ec 28          	sub    rsp,0x28
	return ci->memsrc;
  40dca2:	4c 8b bf 08 01 00 00 	mov    r15,QWORD PTR [rdi+0x108]
	assert(untyped_ptr == round_up_to_pgd_page(untyped_ptr));
  40dca9:	48 39 c6             	cmp    rsi,rax
  40dcac:	0f 85 9b 01 00 00    	jne    40de4d <cos_meminfo_alloc+0x1dd>
  40dcb2:	49 89 fd             	mov    r13,rdi
  40dcb5:	48 89 f3             	mov    rbx,rsi
  40dcb8:	4c 89 ff             	mov    rdi,r15
  40dcbb:	45 31 e4             	xor    r12d,r12d
		retaddr = __bump_mem_expand_range(__compinfo_metacap(ci), ci->mi.pgtbl_cap, untyped_ptr, untyped_sz, pgtbl_lvl);
  40dcbe:	49 8b b5 40 01 00 00 	mov    rsi,QWORD PTR [r13+0x140]
  40dcc5:	45 89 e0             	mov    r8d,r12d
  40dcc8:	4c 89 f1             	mov    rcx,r14
  40dccb:	48 89 da             	mov    rdx,rbx
  40dcce:	e8 1d ef ff ff       	call   40cbf0 <__bump_mem_expand_range>
  40dcd3:	49 89 c2             	mov    r10,rax
		assert(retaddr);
  40dcd6:	48 85 c0             	test   rax,rax
  40dcd9:	0f 84 52 01 00 00    	je     40de31 <cos_meminfo_alloc+0x1c1>
	for(pgtbl_lvl = 0; pgtbl_lvl < COS_PGTBL_DEPTH - 1; pgtbl_lvl++) {
  40dcdf:	49 83 c4 01          	add    r12,0x1
  40dce3:	49 83 fc 03          	cmp    r12,0x3
  40dce7:	74 0f                	je     40dcf8 <cos_meminfo_alloc+0x88>
	return ci->memsrc;
  40dce9:	49 8b bd 08 01 00 00 	mov    rdi,QWORD PTR [r13+0x108]
  40dcf0:	eb cc                	jmp    40dcbe <cos_meminfo_alloc+0x4e>
  40dcf2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40dcf8:	66 48 0f 6e c0       	movq   xmm0,rax
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40dcfd:	49 8d 95 60 01 00 00 	lea    rdx,[r13+0x160]
        __asm__ __volatile__("lock " PS_CAS_STR
  40dd04:	be 01 00 00 00       	mov    esi,0x1
  40dd09:	31 c9                	xor    ecx,ecx
  40dd0b:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
	assert(retaddr == untyped_ptr);
  40dd0f:	48 39 c3             	cmp    rbx,rax
  40dd12:	0f 85 51 01 00 00    	jne    40de69 <cos_meminfo_alloc+0x1f9>
  40dd18:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40dd1f:	00 
  40dd20:	48 89 c8             	mov    rax,rcx
  40dd23:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40dd28:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40dd2b:	84 c0                	test   al,al
  40dd2d:	74 f1                	je     40dd20 <cos_meminfo_alloc+0xb0>
        __asm__ __volatile__("lock " PS_FAA_STR
  40dd2f:	4c 89 f0             	mov    rax,r14
  40dd32:	f0 49 0f c1 87 10 01 	lock xadd QWORD PTR [r15+0x110],rax
  40dd39:	00 00 
  40dd3b:	4c 89 f2             	mov    rdx,r14
  40dd3e:	f0 49 0f c1 97 28 01 	lock xadd QWORD PTR [r15+0x128],rdx
  40dd45:	00 00 
	for (addr = untyped_ptr; addr < untyped_ptr + untyped_sz; addr += PAGE_SIZE, start_addr += PAGE_SIZE) {
  40dd47:	4b 8d 1c 16          	lea    rbx,[r14+r10*1]
  40dd4b:	66 49 0f 6e d2       	movq   xmm2,r10
	__asm__ __volatile__(
  40dd50:	4c 29 d0             	sub    rax,r10
  40dd53:	4c 89 d7             	mov    rdi,r10
  40dd56:	66 48 0f 6e cb       	movq   xmm1,rbx
  40dd5b:	49 89 c6             	mov    r14,rax
  40dd5e:	31 d2                	xor    edx,edx
{ l->o = 0; }
  40dd60:	49 c7 85 60 01 00 00 	mov    QWORD PTR [r13+0x160],0x0
  40dd67:	00 00 00 00 
  40dd6b:	66 0f 6c ca          	punpcklqdq xmm1,xmm2
  40dd6f:	4c 39 d3             	cmp    rbx,r10
  40dd72:	0f 86 8c 00 00 00    	jbe    40de04 <cos_meminfo_alloc+0x194>
  40dd78:	4c 89 55 b8          	mov    QWORD PTR [rbp-0x48],r10
  40dd7c:	49 89 da             	mov    r10,rbx
  40dd7f:	eb 13                	jmp    40dd94 <cos_meminfo_alloc+0x124>
  40dd81:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  40dd88:	48 81 c7 00 10 00 00 	add    rdi,0x1000
  40dd8f:	49 39 fa             	cmp    r10,rdi
  40dd92:	76 6c                	jbe    40de00 <cos_meminfo_alloc+0x190>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40dd94:	41 8b 87 40 01 00 00 	mov    eax,DWORD PTR [r15+0x140]
	__asm__ __volatile__(
  40dd9b:	49 8b b5 40 01 00 00 	mov    rsi,QWORD PTR [r13+0x140]
  40dda2:	49 8d 1c 3e          	lea    rbx,[r14+rdi*1]
  40dda6:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40ddaa:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40ddad:	05 24 00 01 00       	add    eax,0x10024
	__asm__ __volatile__(
  40ddb2:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40ddb5:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40ddb9:	48 89 cd             	mov    rbp,rcx
  40ddbc:	49 b8 d0 dd 40 00 00 	movabs r8,0x40ddd0
  40ddc3:	00 00 00 
  40ddc6:	0f 05                	syscall 
  40ddc8:	eb 0d                	jmp    40ddd7 <cos_meminfo_alloc+0x167>
  40ddca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40ddd0:	b9 00 00 00 00       	mov    ecx,0x0
  40ddd5:	eb 05                	jmp    40dddc <cos_meminfo_alloc+0x16c>
  40ddd7:	b9 01 00 00 00       	mov    ecx,0x1
  40dddc:	5d                   	pop    rbp
  40dddd:	5c                   	pop    rsp
		if (call_cap_op(meta->mi.pgtbl_cap, CAPTBL_OP_MEMMOVE, start_addr, ci->mi.pgtbl_cap, addr, 0)) BUG();
  40ddde:	85 c0                	test   eax,eax
  40dde0:	74 a6                	je     40dd88 <cos_meminfo_alloc+0x118>
  40dde2:	be 1b 00 00 00       	mov    esi,0x1b
  40dde7:	bf 5f e5 41 00       	mov    edi,0x41e55f
  40ddec:	e8 8f ce ff ff       	call   40ac80 <cos_print_str>
  40ddf1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ddf8:	00 00 00 00 
  40ddfc:	0f 0b                	ud2    
  40ddfe:	66 90                	xchg   ax,ax
  40de00:	4c 8b 55 b8          	mov    r10,QWORD PTR [rbp-0x48]
	ci->mi.untyped_ptr = ci->mi.umem_ptr = ci->mi.kmem_ptr = ci->mi.umem_frontier = ci->mi.kmem_frontier =
  40de04:	4d 89 95 38 01 00 00 	mov    QWORD PTR [r13+0x138],r10
  40de0b:	4d 89 95 20 01 00 00 	mov    QWORD PTR [r13+0x120],r10
  40de12:	41 0f 11 85 10 01 00 	movups XMMWORD PTR [r13+0x110],xmm0
  40de19:	00 
	ci->mi.untyped_frontier = untyped_ptr + untyped_sz;
  40de1a:	41 0f 11 8d 28 01 00 	movups XMMWORD PTR [r13+0x128],xmm1
  40de21:	00 
}
  40de22:	48 83 c4 28          	add    rsp,0x28
  40de26:	5b                   	pop    rbx
  40de27:	41 5c                	pop    r12
  40de29:	41 5d                	pop    r13
  40de2b:	41 5e                	pop    r14
  40de2d:	41 5f                	pop    r15
  40de2f:	5d                   	pop    rbp
  40de30:	c3                   	ret    
  40de31:	be 2e 00 00 00       	mov    esi,0x2e
  40de36:	bf 00 e5 41 00       	mov    edi,0x41e500
  40de3b:	e8 40 ce ff ff       	call   40ac80 <cos_print_str>
		assert(retaddr);
  40de40:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40de47:	00 00 00 00 
  40de4b:	0f 0b                	ud2    
  40de4d:	be 2e 00 00 00       	mov    esi,0x2e
  40de52:	bf d0 e4 41 00       	mov    edi,0x41e4d0
  40de57:	e8 24 ce ff ff       	call   40ac80 <cos_print_str>
	assert(untyped_ptr == round_up_to_pgd_page(untyped_ptr));
  40de5c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40de63:	00 00 00 00 
  40de67:	0f 0b                	ud2    
  40de69:	be 2e 00 00 00       	mov    esi,0x2e
  40de6e:	bf 30 e5 41 00       	mov    edi,0x41e530
  40de73:	e8 08 ce ff ff       	call   40ac80 <cos_print_str>
	assert(retaddr == untyped_ptr);
  40de78:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40de7f:	00 00 00 00 
  40de83:	0f 0b                	ud2    
  40de85:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40de8c:	00 00 00 00 

000000000040de90 <missing_captbl_node_expand>:

void
missing_captbl_node_expand(struct cos_compinfo *ci)
{
  40de90:	f3 0f 1e fa          	endbr64 
  40de94:	55                   	push   rbp
  40de95:	48 89 e5             	mov    rbp,rsp
  40de98:	41 57                	push   r15
  40de9a:	41 56                	push   r14
  40de9c:	41 55                	push   r13
  40de9e:	41 54                	push   r12
  40dea0:	53                   	push   rbx
  40dea1:	48 83 ec 48          	sub    rsp,0x48
	return ci->memsrc;
  40dea5:	4c 8b bf 08 01 00 00 	mov    r15,QWORD PTR [rdi+0x108]
	int self_resource = (root_source == ci);
	vaddr_t kmem;
	int ret;

	cap_frontier = root_source->cap_frontier;
	caprange_frontier = root_source->caprange_frontier;
  40deac:	49 8b 5f 20          	mov    rbx,QWORD PTR [r15+0x20]
	cap_frontier = root_source->cap_frontier;
  40deb0:	49 8b 47 18          	mov    rax,QWORD PTR [r15+0x18]
	caprange_frontier = root_source->caprange_frontier;
  40deb4:	48 89 5d b0          	mov    QWORD PTR [rbp-0x50],rbx

	test_cap = CAPTBL_EXPAND_SZ;
	if (self_resource) {
  40deb8:	4c 39 ff             	cmp    rdi,r15
  40debb:	0f 84 c7 02 00 00    	je     40e188 <missing_captbl_node_expand+0x2f8>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40dec1:	41 8b 47 08          	mov    eax,DWORD PTR [r15+0x8]
	__asm__ __volatile__(
  40dec5:	31 d2                	xor    edx,edx
  40dec7:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  40decb:	48 8b 5f 08          	mov    rbx,QWORD PTR [rdi+0x8]
  40decf:	49 89 fa             	mov    r10,rdi
  40ded2:	48 89 4d b8          	mov    QWORD PTR [rbp-0x48],rcx
  40ded6:	bf 01 00 00 00       	mov    edi,0x1
  40dedb:	48 89 d6             	mov    rsi,rdx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40dede:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40dee1:	05 03 00 01 00       	add    eax,0x10003
	__asm__ __volatile__(
  40dee6:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40dee9:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40deed:	48 89 cd             	mov    rbp,rcx
  40def0:	49 b8 08 df 40 00 00 	movabs r8,0x40df08
  40def7:	00 00 00 
  40defa:	0f 05                	syscall 
  40defc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  40df00:	eb 0d                	jmp    40df0f <missing_captbl_node_expand+0x7f>
  40df02:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40df08:	b9 00 00 00 00       	mov    ecx,0x0
  40df0d:	eb 05                	jmp    40df14 <missing_captbl_node_expand+0x84>
  40df0f:	b9 01 00 00 00       	mov    ecx,0x1
  40df14:	5d                   	pop    rbp
  40df15:	5c                   	pop    rsp
	} else {
		printd("cap check before:%d\n", ci->captbl_cap);
		ret = call_cap_op(root_source->captbl_cap, CAPTBL_OP_CAPCHECK, ci->captbl_cap, 0, 1, 0);
		// printc("after cap check:%d\n", ret);
		/* make sure the sub captbl exists */
		assert(!ret);
  40df16:	85 c0                	test   eax,eax
  40df18:	0f 85 10 04 00 00    	jne    40e32e <missing_captbl_node_expand+0x49e>
		cap_frontier = ci->cap_frontier;
		caprange_frontier = ci->caprange_frontier;
  40df1e:	49 8b 42 20          	mov    rax,QWORD PTR [r10+0x20]
		/* we make sure before expanding the missing node of sub captbl, we make sure its root captbl is in a good state */
		printd("begin to expanding a SUB source:%d, %d\n", cap_frontier, caprange_frontier);
		missing_captbl_node_expand(root_source);
  40df22:	4c 89 ff             	mov    rdi,r15
		caprange_frontier = ci->caprange_frontier;
  40df25:	4c 89 55 a8          	mov    QWORD PTR [rbp-0x58],r10
  40df29:	48 89 c3             	mov    rbx,rax
  40df2c:	48 89 45 b0          	mov    QWORD PTR [rbp-0x50],rax
		missing_captbl_node_expand(root_source);
  40df30:	e8 5b ff ff ff       	call   40de90 <missing_captbl_node_expand>
		while (test_cap < caprange_frontier) {
  40df35:	48 81 fb 80 00 00 00 	cmp    rbx,0x80
  40df3c:	0f 86 4c 02 00 00    	jbe    40e18e <missing_captbl_node_expand+0x2fe>
  40df42:	4c 8b 55 a8          	mov    r10,QWORD PTR [rbp-0x58]
	test_cap = CAPTBL_EXPAND_SZ;
  40df46:	41 be 80 00 00 00    	mov    r14d,0x80
  40df4c:	45 31 ed             	xor    r13d,r13d
  40df4f:	eb 18                	jmp    40df69 <missing_captbl_node_expand+0xd9>
  40df51:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
					printc("assert ret:%d\n", ret);
					assert(0); /* race? */
				}
				printd("try to expand a SUB node: DONE once\n");
			}
			test_cap += CAPTBL_EXPAND_SZ * 2;
  40df58:	49 81 c6 00 01 00 00 	add    r14,0x100
		while (test_cap < caprange_frontier) {
  40df5f:	4c 39 75 b0          	cmp    QWORD PTR [rbp-0x50],r14
  40df63:	0f 86 25 02 00 00    	jbe    40e18e <missing_captbl_node_expand+0x2fe>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40df69:	41 8b 47 08          	mov    eax,DWORD PTR [r15+0x8]
	__asm__ __volatile__(
  40df6d:	49 8b 5a 08          	mov    rbx,QWORD PTR [r10+0x8]
  40df71:	4c 89 f6             	mov    rsi,r14
  40df74:	4c 89 ef             	mov    rdi,r13
  40df77:	48 8b 4d b8          	mov    rcx,QWORD PTR [rbp-0x48]
  40df7b:	4c 89 ea             	mov    rdx,r13
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40df7e:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40df81:	05 03 00 01 00       	add    eax,0x10003
	__asm__ __volatile__(
  40df86:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40df89:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40df8d:	48 89 cd             	mov    rbp,rcx
  40df90:	49 b8 a8 df 40 00 00 	movabs r8,0x40dfa8
  40df97:	00 00 00 
  40df9a:	0f 05                	syscall 
  40df9c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  40dfa0:	eb 0d                	jmp    40dfaf <missing_captbl_node_expand+0x11f>
  40dfa2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40dfa8:	b9 00 00 00 00       	mov    ecx,0x0
  40dfad:	eb 05                	jmp    40dfb4 <missing_captbl_node_expand+0x124>
  40dfaf:	b9 01 00 00 00       	mov    ecx,0x1
  40dfb4:	5d                   	pop    rbp
  40dfb5:	5c                   	pop    rsp
			if (ret) {
  40dfb6:	85 c0                	test   eax,eax
  40dfb8:	74 9e                	je     40df58 <missing_captbl_node_expand+0xc8>
	return __mem_bump_alloc(ci, 1, 1);
  40dfba:	4c 89 ff             	mov    rdi,r15
  40dfbd:	4c 89 55 a8          	mov    QWORD PTR [rbp-0x58],r10
  40dfc1:	e8 ea e7 ff ff       	call   40c7b0 <__mem_bump_alloc.constprop.0>
				assert(kmem); /* FIXME: should have a failure semantics for capids */
  40dfc6:	4c 8b 55 a8          	mov    r10,QWORD PTR [rbp-0x58]
  40dfca:	48 85 c0             	test   rax,rax
	return __mem_bump_alloc(ci, 1, 1);
  40dfcd:	48 89 45 a0          	mov    QWORD PTR [rbp-0x60],rax
				assert(kmem); /* FIXME: should have a failure semantics for capids */
  40dfd1:	0f 84 c6 01 00 00    	je     40e19d <missing_captbl_node_expand+0x30d>
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  40dfd7:	0f 01 f9             	rdtscp 
	return (long)coreid;
  40dfda:	49 89 cc             	mov    r12,rcx
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40dfdd:	49 8d 97 58 01 00 00 	lea    rdx,[r15+0x158]
        __asm__ __volatile__("lock " PS_CAS_STR
  40dfe4:	b9 01 00 00 00       	mov    ecx,0x1
  40dfe9:	41 81 e4 ff 0f 00 00 	and    r12d,0xfff
		frontier = &ci->cap64_frontier[cos_cpuid()];
  40dff0:	4b 8d b4 e7 a8 00 00 	lea    rsi,[r15+r12*8+0xa8]
  40dff7:	00 
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40dff8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40dfff:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  40e000:	4c 89 e8             	mov    rax,r13
  40e003:	f0 48 0f b1 0a       	lock cmpxchg QWORD PTR [rdx],rcx
  40e008:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40e00b:	84 c0                	test   al,al
  40e00d:	74 f1                	je     40e000 <missing_captbl_node_expand+0x170>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40e00f:	49 83 c4 14          	add    r12,0x14
  40e013:	4b 8b 5c e7 08       	mov    rbx,QWORD PTR [r15+r12*8+0x8]
  40e018:	83 e3 03             	and    ebx,0x3
  40e01b:	0f 84 2f 01 00 00    	je     40e150 <missing_captbl_node_expand+0x2c0>
        __asm__ __volatile__("lock " PS_FAA_STR
  40e021:	bb 04 00 00 00       	mov    ebx,0x4
  40e026:	f0 48 0f c1 1e       	lock xadd QWORD PTR [rsi],rbx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e02b:	41 8b 47 08          	mov    eax,DWORD PTR [r15+0x8]
	__asm__ __volatile__(
  40e02f:	49 8b b7 40 01 00 00 	mov    rsi,QWORD PTR [r15+0x140]
  40e036:	ba 01 00 00 00       	mov    edx,0x1
{ l->o = 0; }
  40e03b:	49 c7 87 58 01 00 00 	mov    QWORD PTR [r15+0x158],0x0
  40e042:	00 00 00 00 
  40e046:	48 8b 7d a0          	mov    rdi,QWORD PTR [rbp-0x60]
  40e04a:	48 8b 4d b8          	mov    rcx,QWORD PTR [rbp-0x48]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e04e:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40e051:	05 1e 00 01 00       	add    eax,0x1001e
	__asm__ __volatile__(
  40e056:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40e059:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40e05d:	48 89 cd             	mov    rbp,rcx
  40e060:	49 b8 78 e0 40 00 00 	movabs r8,0x40e078
  40e067:	00 00 00 
  40e06a:	0f 05                	syscall 
  40e06c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  40e070:	eb 0d                	jmp    40e07f <missing_captbl_node_expand+0x1ef>
  40e072:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e078:	b9 00 00 00 00       	mov    ecx,0x0
  40e07d:	eb 05                	jmp    40e084 <missing_captbl_node_expand+0x1f4>
  40e07f:	b9 01 00 00 00       	mov    ecx,0x1
  40e084:	5d                   	pop    rbp
  40e085:	5c                   	pop    rsp
				if (call_cap_op(root_source->captbl_cap, CAPTBL_OP_CAPTBLACTIVATE, frontier, root_source->mi.pgtbl_cap, kmem, 1)) {
  40e086:	85 c0                	test   eax,eax
  40e088:	0f 85 bc 02 00 00    	jne    40e34a <missing_captbl_node_expand+0x4ba>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e08e:	41 8b 42 08          	mov    eax,DWORD PTR [r10+0x8]
	__asm__ __volatile__(
  40e092:	48 8b 4d b8          	mov    rcx,QWORD PTR [rbp-0x48]
  40e096:	4c 89 f6             	mov    rsi,r14
  40e099:	4c 89 ef             	mov    rdi,r13
  40e09c:	4c 89 ea             	mov    rdx,r13
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e09f:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40e0a2:	05 01 00 01 00       	add    eax,0x10001
	__asm__ __volatile__(
  40e0a7:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40e0aa:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40e0ae:	48 89 cd             	mov    rbp,rcx
  40e0b1:	49 b8 c8 e0 40 00 00 	movabs r8,0x40e0c8
  40e0b8:	00 00 00 
  40e0bb:	0f 05                	syscall 
  40e0bd:	0f 1f 00             	nop    DWORD PTR [rax]
  40e0c0:	eb 0d                	jmp    40e0cf <missing_captbl_node_expand+0x23f>
  40e0c2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e0c8:	b9 00 00 00 00       	mov    ecx,0x0
  40e0cd:	eb 05                	jmp    40e0d4 <missing_captbl_node_expand+0x244>
  40e0cf:	b9 01 00 00 00       	mov    ecx,0x1
  40e0d4:	5d                   	pop    rbp
  40e0d5:	5c                   	pop    rsp
				if (call_cap_op(ci->captbl_cap, CAPTBL_OP_CONS, frontier, test_cap, 0, 0)) {
  40e0d6:	85 c0                	test   eax,eax
  40e0d8:	0f 84 7a fe ff ff    	je     40df58 <missing_captbl_node_expand+0xc8>
					ret = call_cap_op(root_source->captbl_cap, CAPTBL_OP_CAPCHECK, ci->captbl_cap, 384, 0, 0);
  40e0de:	49 8b 47 08          	mov    rax,QWORD PTR [r15+0x8]
  40e0e2:	49 8b 5a 08          	mov    rbx,QWORD PTR [r10+0x8]
  40e0e6:	be 80 01 00 00       	mov    esi,0x180
  40e0eb:	48 8b 4d b8          	mov    rcx,QWORD PTR [rbp-0x48]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e0ef:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40e0f2:	05 03 00 01 00       	add    eax,0x10003
	__asm__ __volatile__(
  40e0f7:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40e0fa:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40e0fe:	48 89 cd             	mov    rbp,rcx
  40e101:	49 b8 18 e1 40 00 00 	movabs r8,0x40e118
  40e108:	00 00 00 
  40e10b:	0f 05                	syscall 
  40e10d:	0f 1f 00             	nop    DWORD PTR [rax]
  40e110:	eb 0d                	jmp    40e11f <missing_captbl_node_expand+0x28f>
  40e112:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e118:	b9 00 00 00 00       	mov    ecx,0x0
  40e11d:	eb 05                	jmp    40e124 <missing_captbl_node_expand+0x294>
  40e11f:	b9 01 00 00 00       	mov    ecx,0x1
  40e124:	5d                   	pop    rbp
  40e125:	5c                   	pop    rsp
					printc("assert ret:%d\n", ret);
  40e126:	bf 40 e0 41 00       	mov    edi,0x41e040
  40e12b:	89 c6                	mov    esi,eax
  40e12d:	31 c0                	xor    eax,eax
  40e12f:	e8 cc e5 ff ff       	call   40c700 <printc.constprop.0>
  40e134:	be 2e 00 00 00       	mov    esi,0x2e
  40e139:	bf a0 e6 41 00       	mov    edi,0x41e6a0
  40e13e:	e8 3d cb ff ff       	call   40ac80 <cos_print_str>
					assert(0); /* race? */
  40e143:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e14a:	00 00 00 00 
  40e14e:	0f 0b                	ud2    
		if (__capid_captbl_check_expand(ci)) goto error;
  40e150:	4c 89 ff             	mov    rdi,r15
  40e153:	4c 89 55 a8          	mov    QWORD PTR [rbp-0x58],r10
  40e157:	48 89 75 98          	mov    QWORD PTR [rbp-0x68],rsi
  40e15b:	e8 e0 e7 ff ff       	call   40c940 <__capid_captbl_check_expand>
  40e160:	4c 8b 55 a8          	mov    r10,QWORD PTR [rbp-0x58]
  40e164:	85 c0                	test   eax,eax
  40e166:	0f 85 bf fe ff ff    	jne    40e02b <missing_captbl_node_expand+0x19b>
        __asm__ __volatile__("lock " PS_FAA_STR
  40e16c:	b8 04 00 00 00       	mov    eax,0x4
  40e171:	f0 49 0f c1 47 18    	lock xadd QWORD PTR [r15+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40e177:	4b 89 44 e7 08       	mov    QWORD PTR [r15+r12*8+0x8],rax
  40e17c:	48 8b 75 98          	mov    rsi,QWORD PTR [rbp-0x68]
  40e180:	e9 9c fe ff ff       	jmp    40e021 <missing_captbl_node_expand+0x191>
  40e185:	0f 1f 00             	nop    DWORD PTR [rax]
		if (cap_frontier >= CAPTBL_EXPAND_SZ) {
  40e188:	48 83 f8 7f          	cmp    rax,0x7f
  40e18c:	76 2b                	jbe    40e1b9 <missing_captbl_node_expand+0x329>
		}
		printd("begin to expanding a SUB source:%d, %d, done\n", cap_frontier, caprange_frontier);
	}
}
  40e18e:	48 83 c4 48          	add    rsp,0x48
  40e192:	5b                   	pop    rbx
  40e193:	41 5c                	pop    r12
  40e195:	41 5d                	pop    r13
  40e197:	41 5e                	pop    r14
  40e199:	41 5f                	pop    r15
  40e19b:	5d                   	pop    rbp
  40e19c:	c3                   	ret    
  40e19d:	be 2e 00 00 00       	mov    esi,0x2e
  40e1a2:	bf 40 e6 41 00       	mov    edi,0x41e640
  40e1a7:	e8 d4 ca ff ff       	call   40ac80 <cos_print_str>
				assert(kmem); /* FIXME: should have a failure semantics for capids */
  40e1ac:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e1b3:	00 00 00 00 
  40e1b7:	0f 0b                	ud2    
		while (test_cap < caprange_frontier) {
  40e1b9:	48 81 fb 80 00 00 00 	cmp    rbx,0x80
  40e1c0:	76 cc                	jbe    40e18e <missing_captbl_node_expand+0x2fe>
  40e1c2:	48 8d 45 c0          	lea    rax,[rbp-0x40]
	test_cap = CAPTBL_EXPAND_SZ;
  40e1c6:	41 bd 80 00 00 00    	mov    r13d,0x80
  40e1cc:	45 31 d2             	xor    r10d,r10d
  40e1cf:	48 89 45 b8          	mov    QWORD PTR [rbp-0x48],rax
  40e1d3:	eb 10                	jmp    40e1e5 <missing_captbl_node_expand+0x355>
  40e1d5:	0f 1f 00             	nop    DWORD PTR [rax]
			test_cap += CAPTBL_EXPAND_SZ * 2;
  40e1d8:	49 81 c5 00 01 00 00 	add    r13,0x100
		while (test_cap < caprange_frontier) {
  40e1df:	4c 39 6d b0          	cmp    QWORD PTR [rbp-0x50],r13
  40e1e3:	76 a9                	jbe    40e18e <missing_captbl_node_expand+0x2fe>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e1e5:	41 8b 47 08          	mov    eax,DWORD PTR [r15+0x8]
	__asm__ __volatile__(
  40e1e9:	41 be 01 00 00 00    	mov    r14d,0x1
  40e1ef:	4c 89 eb             	mov    rbx,r13
  40e1f2:	4c 89 d6             	mov    rsi,r10
  40e1f5:	48 8b 4d b8          	mov    rcx,QWORD PTR [rbp-0x48]
  40e1f9:	4c 89 f7             	mov    rdi,r14
  40e1fc:	4c 89 d2             	mov    rdx,r10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e1ff:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40e202:	05 03 00 01 00       	add    eax,0x10003
	__asm__ __volatile__(
  40e207:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40e20a:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40e20e:	48 89 cd             	mov    rbp,rcx
  40e211:	49 b8 28 e2 40 00 00 	movabs r8,0x40e228
  40e218:	00 00 00 
  40e21b:	0f 05                	syscall 
  40e21d:	0f 1f 00             	nop    DWORD PTR [rax]
  40e220:	eb 0d                	jmp    40e22f <missing_captbl_node_expand+0x39f>
  40e222:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e228:	b9 00 00 00 00       	mov    ecx,0x0
  40e22d:	eb 05                	jmp    40e234 <missing_captbl_node_expand+0x3a4>
  40e22f:	b9 01 00 00 00       	mov    ecx,0x1
  40e234:	5d                   	pop    rbp
  40e235:	5c                   	pop    rsp
			if (ret) {
  40e236:	85 c0                	test   eax,eax
  40e238:	74 9e                	je     40e1d8 <missing_captbl_node_expand+0x348>
	return __mem_bump_alloc(ci, 1, 1);
  40e23a:	4c 89 ff             	mov    rdi,r15
				frontier = test_cap - CAPMAX_ENTRY_SZ;
  40e23d:	49 8d 5d fc          	lea    rbx,[r13-0x4]
	return __mem_bump_alloc(ci, 1, 1);
  40e241:	e8 6a e5 ff ff       	call   40c7b0 <__mem_bump_alloc.constprop.0>
				assert(kmem); /* FIXME: should have a failure semantics for capids */
  40e246:	45 31 d2             	xor    r10d,r10d
	return __mem_bump_alloc(ci, 1, 1);
  40e249:	48 89 c7             	mov    rdi,rax
				assert(kmem); /* FIXME: should have a failure semantics for capids */
  40e24c:	48 85 c0             	test   rax,rax
  40e24f:	0f 84 bd 00 00 00    	je     40e312 <missing_captbl_node_expand+0x482>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e255:	41 8b 47 08          	mov    eax,DWORD PTR [r15+0x8]
	__asm__ __volatile__(
  40e259:	49 8b b7 40 01 00 00 	mov    rsi,QWORD PTR [r15+0x140]
  40e260:	4c 89 f2             	mov    rdx,r14
  40e263:	48 8b 4d b8          	mov    rcx,QWORD PTR [rbp-0x48]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e267:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40e26a:	05 1e 00 01 00       	add    eax,0x1001e
	__asm__ __volatile__(
  40e26f:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40e272:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40e276:	48 89 cd             	mov    rbp,rcx
  40e279:	49 b8 90 e2 40 00 00 	movabs r8,0x40e290
  40e280:	00 00 00 
  40e283:	0f 05                	syscall 
  40e285:	0f 1f 00             	nop    DWORD PTR [rax]
  40e288:	eb 0d                	jmp    40e297 <missing_captbl_node_expand+0x407>
  40e28a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e290:	b9 00 00 00 00       	mov    ecx,0x0
  40e295:	eb 05                	jmp    40e29c <missing_captbl_node_expand+0x40c>
  40e297:	b9 01 00 00 00       	mov    ecx,0x1
  40e29c:	5d                   	pop    rbp
  40e29d:	5c                   	pop    rsp
				if (call_cap_op(root_source->captbl_cap, CAPTBL_OP_CAPTBLACTIVATE, frontier, root_source->mi.pgtbl_cap, kmem, 1)) {
  40e29e:	85 c0                	test   eax,eax
  40e2a0:	0f 85 c0 00 00 00    	jne    40e366 <missing_captbl_node_expand+0x4d6>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e2a6:	41 8b 47 08          	mov    eax,DWORD PTR [r15+0x8]
	__asm__ __volatile__(
  40e2aa:	48 8b 4d b8          	mov    rcx,QWORD PTR [rbp-0x48]
  40e2ae:	4c 89 ee             	mov    rsi,r13
  40e2b1:	4c 89 d7             	mov    rdi,r10
  40e2b4:	4c 89 d2             	mov    rdx,r10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e2b7:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40e2ba:	05 01 00 01 00       	add    eax,0x10001
	__asm__ __volatile__(
  40e2bf:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40e2c2:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40e2c6:	48 89 cd             	mov    rbp,rcx
  40e2c9:	49 b8 e0 e2 40 00 00 	movabs r8,0x40e2e0
  40e2d0:	00 00 00 
  40e2d3:	0f 05                	syscall 
  40e2d5:	0f 1f 00             	nop    DWORD PTR [rax]
  40e2d8:	eb 0d                	jmp    40e2e7 <missing_captbl_node_expand+0x457>
  40e2da:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e2e0:	b9 00 00 00 00       	mov    ecx,0x0
  40e2e5:	eb 05                	jmp    40e2ec <missing_captbl_node_expand+0x45c>
  40e2e7:	b9 01 00 00 00       	mov    ecx,0x1
  40e2ec:	5d                   	pop    rbp
  40e2ed:	5c                   	pop    rsp
				if (call_cap_op(root_source->captbl_cap, CAPTBL_OP_CONS, frontier, test_cap, 0, 0)) {
  40e2ee:	85 c0                	test   eax,eax
  40e2f0:	0f 84 e2 fe ff ff    	je     40e1d8 <missing_captbl_node_expand+0x348>
  40e2f6:	be 2e 00 00 00       	mov    esi,0x2e
  40e2fb:	bf e0 e5 41 00       	mov    edi,0x41e5e0
  40e300:	e8 7b c9 ff ff       	call   40ac80 <cos_print_str>
					assert(0); /* race? */
  40e305:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e30c:	00 00 00 00 
  40e310:	0f 0b                	ud2    
  40e312:	be 2e 00 00 00       	mov    esi,0x2e
  40e317:	bf 80 e5 41 00       	mov    edi,0x41e580
  40e31c:	e8 5f c9 ff ff       	call   40ac80 <cos_print_str>
				assert(kmem); /* FIXME: should have a failure semantics for capids */
  40e321:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e328:	00 00 00 00 
  40e32c:	0f 0b                	ud2    
  40e32e:	be 2e 00 00 00       	mov    esi,0x2e
  40e333:	bf 10 e6 41 00       	mov    edi,0x41e610
  40e338:	e8 43 c9 ff ff       	call   40ac80 <cos_print_str>
		assert(!ret);
  40e33d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e344:	00 00 00 00 
  40e348:	0f 0b                	ud2    
  40e34a:	be 2e 00 00 00       	mov    esi,0x2e
  40e34f:	bf 70 e6 41 00       	mov    edi,0x41e670
  40e354:	e8 27 c9 ff ff       	call   40ac80 <cos_print_str>
					assert(0); /* race condition? */
  40e359:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e360:	00 00 00 00 
  40e364:	0f 0b                	ud2    
  40e366:	be 2e 00 00 00       	mov    esi,0x2e
  40e36b:	bf b0 e5 41 00       	mov    edi,0x41e5b0
  40e370:	e8 0b c9 ff ff       	call   40ac80 <cos_print_str>
					assert(0); /* race condition? */
  40e375:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e37c:	00 00 00 00 
  40e380:	0f 0b                	ud2    
  40e382:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40e389:	00 00 00 00 
  40e38d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040e390 <cos_comp_capfrontier_update>:

void
cos_comp_capfrontier_update(struct cos_compinfo *ci, capid_t cap_frontier, int try_expand)
{
  40e390:	f3 0f 1e fa          	endbr64 
  40e394:	55                   	push   rbp
  40e395:	48 89 e5             	mov    rbp,rsp
  40e398:	41 57                	push   r15
  40e39a:	41 89 d7             	mov    r15d,edx
  40e39d:	41 56                	push   r14
  40e39f:	49 89 f6             	mov    r14,rsi
  40e3a2:	41 55                	push   r13
  40e3a4:	49 89 fd             	mov    r13,rdi
  40e3a7:	41 54                	push   r12
  40e3a9:	53                   	push   rbx
  40e3aa:	48 83 ec 28          	sub    rsp,0x28
	missing_captbl_node_expand(ci);
  40e3ae:	e8 dd fa ff ff       	call   40de90 <missing_captbl_node_expand>
	// printc("mmp???:cap_frontier:%d, ci->cap_frontier:%d, ci->caprange_frontier:%d\n", cap_frontier, ci->cap_frontier, ci->caprange_frontier);
	if (cap_frontier <= ci->cap_frontier) return;
  40e3b3:	4d 39 75 18          	cmp    QWORD PTR [r13+0x18],r14
  40e3b7:	0f 83 7a 01 00 00    	jae    40e537 <cos_comp_capfrontier_update+0x1a7>

	if (try_expand) {
  40e3bd:	45 85 ff             	test   r15d,r15d
  40e3c0:	0f 84 ea 00 00 00    	je     40e4b0 <cos_comp_capfrontier_update+0x120>
        __asm__ __volatile__("lock " PS_CAS_STR
  40e3c6:	41 bf 01 00 00 00    	mov    r15d,0x1
		while (cap_frontier > ci->caprange_frontier) {
  40e3cc:	49 8b 45 20          	mov    rax,QWORD PTR [r13+0x20]
  40e3d0:	4c 39 f0             	cmp    rax,r14
  40e3d3:	0f 83 d7 00 00 00    	jae    40e4b0 <cos_comp_capfrontier_update+0x120>
  40e3d9:	4d 8b a5 08 01 00 00 	mov    r12,QWORD PTR [r13+0x108]
	return ci->memsrc;
  40e3e0:	49 8b 94 24 08 01 00 	mov    rdx,QWORD PTR [r12+0x108]
  40e3e7:	00 
			ci->cap_frontier = ci->caprange_frontier;	
  40e3e8:	49 89 45 18          	mov    QWORD PTR [r13+0x18],rax
	assert(__compinfo_metacap(meta) == meta);
  40e3ec:	4c 39 e2             	cmp    rdx,r12
  40e3ef:	0f 85 4e 02 00 00    	jne    40e643 <cos_comp_capfrontier_update+0x2b3>
		frontier = ps_load(&ci->caprange_frontier) - CAPMAX_ENTRY_SZ;
  40e3f5:	49 8b 5d 20          	mov    rbx,QWORD PTR [r13+0x20]
	if (self_resources) {
  40e3f9:	49 39 d5             	cmp    r13,rdx
  40e3fc:	0f 84 4e 01 00 00    	je     40e550 <cos_comp_capfrontier_update+0x1c0>
	assert(ci->cap_frontier <= frontier);
  40e402:	48 39 d8             	cmp    rax,rbx
  40e405:	0f 87 54 02 00 00    	ja     40e65f <cos_comp_capfrontier_update+0x2cf>
	if (likely(ci->cap_frontier != frontier)) return 0;
  40e40b:	75 db                	jne    40e3e8 <cos_comp_capfrontier_update+0x58>
	return __mem_bump_alloc(ci, 1, 1);
  40e40d:	4c 89 ef             	mov    rdi,r13
  40e410:	e8 9b e3 ff ff       	call   40c7b0 <__mem_bump_alloc.constprop.0>
  40e415:	49 89 c2             	mov    r10,rax
	assert(kmem); /* FIXME: should have a failure semantics for capids */
  40e418:	48 85 c0             	test   rax,rax
  40e41b:	0f 84 e0 02 00 00    	je     40e701 <cos_comp_capfrontier_update+0x371>
	if (self_resources) {
  40e421:	4d 39 e5             	cmp    r13,r12
  40e424:	0f 84 43 01 00 00    	je     40e56d <cos_comp_capfrontier_update+0x1dd>
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  40e42a:	0f 01 f9             	rdtscp 
	return (long)coreid;
  40e42d:	48 89 cf             	mov    rdi,rcx
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40e430:	49 8d 94 24 58 01 00 	lea    rdx,[r12+0x158]
  40e437:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  40e438:	31 c9                	xor    ecx,ecx
  40e43a:	81 e7 ff 0f 00 00    	and    edi,0xfff
		frontier = &ci->cap64_frontier[cos_cpuid()];
  40e440:	49 8d b4 fc a8 00 00 	lea    rsi,[r12+rdi*8+0xa8]
  40e447:	00 
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40e448:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40e44f:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  40e450:	48 89 c8             	mov    rax,rcx
  40e453:	f0 4c 0f b1 3a       	lock cmpxchg QWORD PTR [rdx],r15
  40e458:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40e45b:	84 c0                	test   al,al
  40e45d:	74 f1                	je     40e450 <cos_comp_capfrontier_update+0xc0>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40e45f:	48 8d 5f 14          	lea    rbx,[rdi+0x14]
  40e463:	41 f6 84 fc a8 00 00 	test   BYTE PTR [r12+rdi*8+0xa8],0x3
  40e46a:	00 03 
  40e46c:	0f 84 5d 02 00 00    	je     40e6cf <cos_comp_capfrontier_update+0x33f>
        __asm__ __volatile__("lock " PS_FAA_STR
  40e472:	bb 04 00 00 00       	mov    ebx,0x4
  40e477:	f0 48 0f c1 1e       	lock xadd QWORD PTR [rsi],rbx
{ l->o = 0; }
  40e47c:	49 c7 84 24 58 01 00 	mov    QWORD PTR [r12+0x158],0x0
  40e483:	00 00 00 00 00 
		assert(captblcap);
  40e488:	48 85 db             	test   rbx,rbx
  40e48b:	0f 85 dc 00 00 00    	jne    40e56d <cos_comp_capfrontier_update+0x1dd>
  40e491:	be 2e 00 00 00       	mov    esi,0x2e
  40e496:	bf 40 e1 41 00       	mov    edi,0x41e140
  40e49b:	e8 e0 c7 ff ff       	call   40ac80 <cos_print_str>
  40e4a0:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e4a7:	00 00 00 00 
  40e4ab:	0f 0b                	ud2    
  40e4ad:	0f 1f 00             	nop    DWORD PTR [rax]
	assert(round_up_to_pow2(cap_frontier, CAPMAX_ENTRY_SZ) == cap_frontier);
  40e4b0:	49 8d 46 03          	lea    rax,[r14+0x3]
  40e4b4:	48 83 e0 fc          	and    rax,0xfffffffffffffffc
  40e4b8:	49 39 c6             	cmp    r14,rax
  40e4bb:	0f 85 d6 01 00 00    	jne    40e697 <cos_comp_capfrontier_update+0x307>
	ci->cap_frontier = cap_frontier;
  40e4c1:	4d 89 75 18          	mov    QWORD PTR [r13+0x18],r14
	if (cap_frontier < CAPTBL_EXPAND_SZ) {
  40e4c5:	49 83 fe 7f          	cmp    r14,0x7f
  40e4c9:	0f 86 91 00 00 00    	jbe    40e560 <cos_comp_capfrontier_update+0x1d0>
		ci->caprange_frontier = round_up_to_pow2(cap_frontier + CAPTBL_EXPAND_SZ, CAPTBL_EXPAND_SZ * 2) - CAPTBL_EXPAND_SZ;
  40e4cf:	49 8d 86 7f 01 00 00 	lea    rax,[r14+0x17f]
  40e4d6:	30 c0                	xor    al,al
  40e4d8:	48 83 c0 80          	add    rax,0xffffffffffffff80
  40e4dc:	66 49 0f 6e c6       	movq   xmm0,r14
  40e4e1:	49 89 45 20          	mov    QWORD PTR [r13+0x20],rax
	for (i = 0; i < NUM_CPU; i++) {
  40e4e5:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
		ci->cap16_frontier[i] = ci->cap32_frontier[i] = ci->cap64_frontier[i] = cap_frontier;
  40e4e9:	41 0f 11 85 a8 00 00 	movups XMMWORD PTR [r13+0xa8],xmm0
  40e4f0:	00 
  40e4f1:	41 0f 11 45 68       	movups XMMWORD PTR [r13+0x68],xmm0
  40e4f6:	41 0f 11 45 28       	movups XMMWORD PTR [r13+0x28],xmm0
  40e4fb:	41 0f 11 85 b8 00 00 	movups XMMWORD PTR [r13+0xb8],xmm0
  40e502:	00 
  40e503:	41 0f 11 45 78       	movups XMMWORD PTR [r13+0x78],xmm0
  40e508:	41 0f 11 45 38       	movups XMMWORD PTR [r13+0x38],xmm0
  40e50d:	41 0f 11 85 c8 00 00 	movups XMMWORD PTR [r13+0xc8],xmm0
  40e514:	00 
  40e515:	41 0f 11 85 88 00 00 	movups XMMWORD PTR [r13+0x88],xmm0
  40e51c:	00 
  40e51d:	41 0f 11 45 48       	movups XMMWORD PTR [r13+0x48],xmm0
  40e522:	41 0f 11 85 d8 00 00 	movups XMMWORD PTR [r13+0xd8],xmm0
  40e529:	00 
  40e52a:	41 0f 11 85 98 00 00 	movups XMMWORD PTR [r13+0x98],xmm0
  40e531:	00 
  40e532:	41 0f 11 45 58       	movups XMMWORD PTR [r13+0x58],xmm0
			__capid_captbl_check_expand(ci);
		}
	}

	cos_capfrontier_init(ci, cap_frontier);
}
  40e537:	48 83 c4 28          	add    rsp,0x28
  40e53b:	5b                   	pop    rbx
  40e53c:	41 5c                	pop    r12
  40e53e:	41 5d                	pop    r13
  40e540:	41 5e                	pop    r14
  40e542:	41 5f                	pop    r15
  40e544:	5d                   	pop    rbp
  40e545:	c3                   	ret    
  40e546:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40e54d:	00 00 00 
		frontier = ps_load(&ci->caprange_frontier) - CAPMAX_ENTRY_SZ;
  40e550:	48 83 eb 04          	sub    rbx,0x4
  40e554:	e9 a9 fe ff ff       	jmp    40e402 <cos_comp_capfrontier_update+0x72>
  40e559:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		ci->caprange_frontier = round_up_to_pow2(cap_frontier, CAPTBL_EXPAND_SZ);
  40e560:	49 8d 46 7f          	lea    rax,[r14+0x7f]
  40e564:	48 83 e0 80          	and    rax,0xffffffffffffff80
  40e568:	e9 6f ff ff ff       	jmp    40e4dc <cos_comp_capfrontier_update+0x14c>
	captblid_add = ps_load(&ci->caprange_frontier);
  40e56d:	49 8b 45 20          	mov    rax,QWORD PTR [r13+0x20]
  40e571:	48 89 45 b8          	mov    QWORD PTR [rbp-0x48],rax
	assert(captblid_add % CAPTBL_EXPAND_SZ == 0);
  40e575:	83 e0 7f             	and    eax,0x7f
  40e578:	48 89 45 b0          	mov    QWORD PTR [rbp-0x50],rax
  40e57c:	0f 85 9b 01 00 00    	jne    40e71d <cos_comp_capfrontier_update+0x38d>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e582:	41 8b 44 24 08       	mov    eax,DWORD PTR [r12+0x8]
	__asm__ __volatile__(
  40e587:	4c 89 d7             	mov    rdi,r10
  40e58a:	4c 89 fa             	mov    rdx,r15
  40e58d:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  40e591:	49 8b b4 24 40 01 00 	mov    rsi,QWORD PTR [r12+0x140]
  40e598:	00 
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e599:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40e59c:	05 1e 00 01 00       	add    eax,0x1001e
	__asm__ __volatile__(
  40e5a1:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40e5a4:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40e5a8:	48 89 cd             	mov    rbp,rcx
  40e5ab:	49 b8 c0 e5 40 00 00 	movabs r8,0x40e5c0
  40e5b2:	00 00 00 
  40e5b5:	0f 05                	syscall 
  40e5b7:	90                   	nop
  40e5b8:	eb 0d                	jmp    40e5c7 <cos_comp_capfrontier_update+0x237>
  40e5ba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e5c0:	b9 00 00 00 00       	mov    ecx,0x0
  40e5c5:	eb 05                	jmp    40e5cc <cos_comp_capfrontier_update+0x23c>
  40e5c7:	b9 01 00 00 00       	mov    ecx,0x1
  40e5cc:	5d                   	pop    rbp
  40e5cd:	5c                   	pop    rsp
	if (call_cap_op(meta->captbl_cap, CAPTBL_OP_CAPTBLACTIVATE, captblcap, meta->mi.pgtbl_cap, kmem, 1)) {
  40e5ce:	85 c0                	test   eax,eax
  40e5d0:	0f 85 a5 00 00 00    	jne    40e67b <cos_comp_capfrontier_update+0x2eb>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e5d6:	41 8b 45 08          	mov    eax,DWORD PTR [r13+0x8]
	__asm__ __volatile__(
  40e5da:	48 8b 7d b0          	mov    rdi,QWORD PTR [rbp-0x50]
  40e5de:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  40e5e2:	48 8b 75 b8          	mov    rsi,QWORD PTR [rbp-0x48]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e5e6:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40e5e9:	48 89 fa             	mov    rdx,rdi
	cap_no += op;
  40e5ec:	05 01 00 01 00       	add    eax,0x10001
	__asm__ __volatile__(
  40e5f1:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40e5f4:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40e5f8:	48 89 cd             	mov    rbp,rcx
  40e5fb:	49 b8 10 e6 40 00 00 	movabs r8,0x40e610
  40e602:	00 00 00 
  40e605:	0f 05                	syscall 
  40e607:	90                   	nop
  40e608:	eb 0d                	jmp    40e617 <cos_comp_capfrontier_update+0x287>
  40e60a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e610:	b9 00 00 00 00       	mov    ecx,0x0
  40e615:	eb 05                	jmp    40e61c <cos_comp_capfrontier_update+0x28c>
  40e617:	b9 01 00 00 00       	mov    ecx,0x1
  40e61c:	5d                   	pop    rbp
  40e61d:	5c                   	pop    rsp
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_CONS, captblcap, captblid_add, 0, 0)) {
  40e61e:	85 c0                	test   eax,eax
  40e620:	0f 85 8d 00 00 00    	jne    40e6b3 <cos_comp_capfrontier_update+0x323>
	frontier       = ps_load(&ci->cap_frontier);
  40e626:	49 8b 45 18          	mov    rax,QWORD PTR [r13+0x18]
        __asm__ __volatile__("lock " PS_FAA_STR
  40e62a:	ba 00 01 00 00       	mov    edx,0x100
  40e62f:	f0 49 0f c1 55 20    	lock xadd QWORD PTR [r13+0x20],rdx
        __asm__ __volatile__("lock " PS_CAS_STR
  40e635:	f0 49 0f b1 55 18    	lock cmpxchg QWORD PTR [r13+0x18],rdx
  40e63b:	0f 94 c0             	sete   al
	return 0;
  40e63e:	e9 89 fd ff ff       	jmp    40e3cc <cos_comp_capfrontier_update+0x3c>
  40e643:	be 2e 00 00 00       	mov    esi,0x2e
  40e648:	bf b0 e0 41 00       	mov    edi,0x41e0b0
  40e64d:	e8 2e c6 ff ff       	call   40ac80 <cos_print_str>
	assert(__compinfo_metacap(meta) == meta);
  40e652:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e659:	00 00 00 00 
  40e65d:	0f 0b                	ud2    
  40e65f:	be 2e 00 00 00       	mov    esi,0x2e
  40e664:	bf e0 e0 41 00       	mov    edi,0x41e0e0
  40e669:	e8 12 c6 ff ff       	call   40ac80 <cos_print_str>
	assert(ci->cap_frontier <= frontier);
  40e66e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e675:	00 00 00 00 
  40e679:	0f 0b                	ud2    
  40e67b:	be 2e 00 00 00       	mov    esi,0x2e
  40e680:	bf a0 e1 41 00       	mov    edi,0x41e1a0
  40e685:	e8 f6 c5 ff ff       	call   40ac80 <cos_print_str>
		assert(0); /* race condition? */
  40e68a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e691:	00 00 00 00 
  40e695:	0f 0b                	ud2    
  40e697:	be 2e 00 00 00       	mov    esi,0x2e
  40e69c:	bf 70 e4 41 00       	mov    edi,0x41e470
  40e6a1:	e8 da c5 ff ff       	call   40ac80 <cos_print_str>
	assert(round_up_to_pow2(cap_frontier, CAPMAX_ENTRY_SZ) == cap_frontier);
  40e6a6:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e6ad:	00 00 00 00 
  40e6b1:	0f 0b                	ud2    
  40e6b3:	be 2e 00 00 00       	mov    esi,0x2e
  40e6b8:	bf d0 e1 41 00       	mov    edi,0x41e1d0
  40e6bd:	e8 be c5 ff ff       	call   40ac80 <cos_print_str>
		assert(0); /* race? */
  40e6c2:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e6c9:	00 00 00 00 
  40e6cd:	0f 0b                	ud2    
		if (__capid_captbl_check_expand(ci)) goto error;
  40e6cf:	4c 89 e7             	mov    rdi,r12
  40e6d2:	48 89 75 b0          	mov    QWORD PTR [rbp-0x50],rsi
  40e6d6:	4c 89 55 b8          	mov    QWORD PTR [rbp-0x48],r10
  40e6da:	e8 61 e2 ff ff       	call   40c940 <__capid_captbl_check_expand>
  40e6df:	4c 8b 55 b8          	mov    r10,QWORD PTR [rbp-0x48]
  40e6e3:	48 8b 75 b0          	mov    rsi,QWORD PTR [rbp-0x50]
  40e6e7:	85 c0                	test   eax,eax
  40e6e9:	75 4e                	jne    40e739 <cos_comp_capfrontier_update+0x3a9>
        __asm__ __volatile__("lock " PS_FAA_STR
  40e6eb:	b8 04 00 00 00       	mov    eax,0x4
  40e6f0:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40e6f7:	49 89 44 dc 08       	mov    QWORD PTR [r12+rbx*8+0x8],rax
  40e6fc:	e9 71 fd ff ff       	jmp    40e472 <cos_comp_capfrontier_update+0xe2>
  40e701:	be 2e 00 00 00       	mov    esi,0x2e
  40e706:	bf 10 e1 41 00       	mov    edi,0x41e110
  40e70b:	e8 70 c5 ff ff       	call   40ac80 <cos_print_str>
	assert(kmem); /* FIXME: should have a failure semantics for capids */
  40e710:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e717:	00 00 00 00 
  40e71b:	0f 0b                	ud2    
  40e71d:	be 2e 00 00 00       	mov    esi,0x2e
  40e722:	bf 70 e1 41 00       	mov    edi,0x41e170
  40e727:	e8 54 c5 ff ff       	call   40ac80 <cos_print_str>
	assert(captblid_add % CAPTBL_EXPAND_SZ == 0);
  40e72c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e733:	00 00 00 00 
  40e737:	0f 0b                	ud2    
{ l->o = 0; }
  40e739:	49 c7 84 24 58 01 00 	mov    QWORD PTR [r12+0x158],0x0
  40e740:	00 00 00 00 00 
		assert(captblcap);
  40e745:	e9 47 fd ff ff       	jmp    40e491 <cos_comp_capfrontier_update+0x101>
  40e74a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000040e750 <cos_thd_id_alloc>:
 */
unsigned long __thdid_alloc = NUM_CPU + 2;

thdid_t
cos_thd_id_alloc(void)
{
  40e750:	f3 0f 1e fa          	endbr64 
        __asm__ __volatile__("lock " PS_FAA_STR
  40e754:	b8 01 00 00 00       	mov    eax,0x1
  40e759:	f0 48 0f c1 05 9e d8 	lock xadd QWORD PTR [rip+0x1ad89e],rax        # 5bc000 <__thdid_alloc>
  40e760:	1a 00 
  thdid_t assignment = (thdid_t)id;

  assert((unsigned long)assignment == id);

  return assignment;
}
  40e762:	c3                   	ret    
  40e763:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40e76a:	00 00 00 00 
  40e76e:	66 90                	xchg   ax,ax

000000000040e770 <cos_ulk_page_alloc>:
	return toplvl;
}

ulkcap_t
cos_ulk_page_alloc(struct cos_compinfo *ci, pgtblcap_t ulkpt, vaddr_t uaddr)
{
  40e770:	f3 0f 1e fa          	endbr64 
  40e774:	55                   	push   rbp
  40e775:	48 89 e5             	mov    rbp,rsp
  40e778:	41 57                	push   r15
  40e77a:	41 56                	push   r14
  40e77c:	41 55                	push   r13
  40e77e:	41 54                	push   r12
  40e780:	53                   	push   rbx
  40e781:	48 83 ec 38          	sub    rsp,0x38
	return livenessid_frontier++;
  40e785:	8b 1d b5 d8 1a 00    	mov    ebx,DWORD PTR [rip+0x1ad8b5]        # 5bc040 <livenessid_frontier>
	return ci->memsrc;
  40e78b:	4c 8b a7 08 01 00 00 	mov    r12,QWORD PTR [rdi+0x108]
{
  40e792:	48 89 55 b8          	mov    QWORD PTR [rbp-0x48],rdx
	return livenessid_frontier++;
  40e796:	8d 43 01             	lea    eax,[rbx+0x1]
  40e799:	89 05 a1 d8 1a 00    	mov    DWORD PTR [rip+0x1ad8a1],eax        # 5bc040 <livenessid_frontier>
	vaddr_t kmem;
	capid_t cap;
	u32_t   lid = livenessid_bump_alloc();

	printd("cos_ulk_pgtbl_create\n");
	assert(ci_resources && ulkpt);
  40e79f:	4d 85 e4             	test   r12,r12
  40e7a2:	0f 84 96 01 00 00    	je     40e93e <cos_ulk_page_alloc+0x1ce>
  40e7a8:	49 89 f5             	mov    r13,rsi
  40e7ab:	48 85 f6             	test   rsi,rsi
  40e7ae:	0f 84 8a 01 00 00    	je     40e93e <cos_ulk_page_alloc+0x1ce>
	return __mem_bump_alloc(ci, 1, 1);
  40e7b4:	4c 89 e7             	mov    rdi,r12
  40e7b7:	e8 f4 df ff ff       	call   40c7b0 <__mem_bump_alloc.constprop.0>
  40e7bc:	49 89 c6             	mov    r14,rax
	if (!*kmem) return -1;
  40e7bf:	48 85 c0             	test   rax,rax
  40e7c2:	0f 84 92 01 00 00    	je     40e95a <cos_ulk_page_alloc+0x1ea>
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  40e7c8:	0f 01 f9             	rdtscp 
	return (long)coreid;
  40e7cb:	48 89 cf             	mov    rdi,rcx
        __asm__ __volatile__("lock " PS_CAS_STR
  40e7ce:	ba 01 00 00 00       	mov    edx,0x1
  40e7d3:	45 31 c0             	xor    r8d,r8d
  40e7d6:	81 e7 ff 0f 00 00    	and    edi,0xfff
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40e7dc:	49 8d 8c 24 58 01 00 	lea    rcx,[r12+0x158]
  40e7e3:	00 
		frontier = &ci->cap32_frontier[cos_cpuid()];
  40e7e4:	4d 8d 4c fc 68       	lea    r9,[r12+rdi*8+0x68]
  40e7e9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  40e7f0:	4c 89 c0             	mov    rax,r8
  40e7f3:	f0 48 0f b1 11       	lock cmpxchg QWORD PTR [rcx],rdx
  40e7f8:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40e7fb:	84 c0                	test   al,al
  40e7fd:	74 f1                	je     40e7f0 <cos_ulk_page_alloc+0x80>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40e7ff:	48 8d 57 0c          	lea    rdx,[rdi+0xc]
  40e803:	4d 8b 7c d4 08       	mov    r15,QWORD PTR [r12+rdx*8+0x8]
  40e808:	41 83 e7 03          	and    r15d,0x3
  40e80c:	0f 84 ae 00 00 00    	je     40e8c0 <cos_ulk_page_alloc+0x150>
        __asm__ __volatile__("lock " PS_FAA_STR
  40e812:	ba 02 00 00 00       	mov    edx,0x2
  40e817:	f0 49 0f c1 11       	lock xadd QWORD PTR [r9],rdx
{ l->o = 0; }
  40e81c:	49 c7 84 24 58 01 00 	mov    QWORD PTR [r12+0x158],0x0
  40e823:	00 00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  40e828:	49 89 d7             	mov    r15,rdx
	if (!*cap) return -1;
  40e82b:	48 85 d2             	test   rdx,rdx
  40e82e:	0f 84 26 01 00 00    	je     40e95a <cos_ulk_page_alloc+0x1ea>

	if (__alloc_mem_cap(ci_resources, CAP_ULK, &kmem, &cap)) return 0;
	assert(kmem && (round_to_page(kmem) == kmem));
  40e834:	41 f7 c6 ff 0f 00 00 	test   r14d,0xfff
  40e83b:	0f 85 e1 00 00 00    	jne    40e922 <cos_ulk_page_alloc+0x1b2>
	if (call_cap_op(ci_resources->captbl_cap, CAPTBL_OP_ULK_MEMACTIVATE, cap << 16 | lid, ci_resources->mi.pgtbl_cap << 16 | ulkpt, kmem, uaddr))
  40e841:	48 c1 e2 10          	shl    rdx,0x10
  40e845:	89 db                	mov    ebx,ebx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e847:	41 8b 44 24 08       	mov    eax,DWORD PTR [r12+0x8]
	__asm__ __volatile__(
  40e84c:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  40e850:	48 09 d3             	or     rbx,rdx
  40e853:	49 8b 94 24 40 01 00 	mov    rdx,QWORD PTR [r12+0x140]
  40e85a:	00 
  40e85b:	4c 89 f7             	mov    rdi,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e85e:	c1 e0 10             	shl    eax,0x10
  40e861:	48 c1 e2 10          	shl    rdx,0x10
	cap_no += op;
  40e865:	05 38 00 01 00       	add    eax,0x10038
  40e86a:	48 89 d6             	mov    rsi,rdx
	__asm__ __volatile__(
  40e86d:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
  40e871:	4c 09 ee             	or     rsi,r13
  40e874:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40e877:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40e87b:	48 89 cd             	mov    rbp,rcx
  40e87e:	49 b8 98 e8 40 00 00 	movabs r8,0x40e898
  40e885:	00 00 00 
  40e888:	0f 05                	syscall 
  40e88a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e890:	eb 0d                	jmp    40e89f <cos_ulk_page_alloc+0x12f>
  40e892:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e898:	b9 00 00 00 00       	mov    ecx,0x0
  40e89d:	eb 05                	jmp    40e8a4 <cos_ulk_page_alloc+0x134>
  40e89f:	b9 01 00 00 00       	mov    ecx,0x1
  40e8a4:	5d                   	pop    rbp
  40e8a5:	5c                   	pop    rsp
  40e8a6:	85 c0                	test   eax,eax
  40e8a8:	75 4e                	jne    40e8f8 <cos_ulk_page_alloc+0x188>
		BUG();

	return cap;
}
  40e8aa:	48 83 c4 38          	add    rsp,0x38
  40e8ae:	4c 89 f8             	mov    rax,r15
  40e8b1:	5b                   	pop    rbx
  40e8b2:	41 5c                	pop    r12
  40e8b4:	41 5d                	pop    r13
  40e8b6:	41 5e                	pop    r14
  40e8b8:	41 5f                	pop    r15
  40e8ba:	5d                   	pop    rbp
  40e8bb:	c3                   	ret    
  40e8bc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  40e8c0:	4c 89 e7             	mov    rdi,r12
  40e8c3:	48 89 55 a8          	mov    QWORD PTR [rbp-0x58],rdx
  40e8c7:	4c 89 4d b0          	mov    QWORD PTR [rbp-0x50],r9
  40e8cb:	e8 70 e0 ff ff       	call   40c940 <__capid_captbl_check_expand>
  40e8d0:	4c 8b 4d b0          	mov    r9,QWORD PTR [rbp-0x50]
  40e8d4:	48 8b 55 a8          	mov    rdx,QWORD PTR [rbp-0x58]
  40e8d8:	85 c0                	test   eax,eax
  40e8da:	75 38                	jne    40e914 <cos_ulk_page_alloc+0x1a4>
        __asm__ __volatile__("lock " PS_FAA_STR
  40e8dc:	b8 04 00 00 00       	mov    eax,0x4
  40e8e1:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40e8e8:	49 89 44 d4 08       	mov    QWORD PTR [r12+rdx*8+0x8],rax
  40e8ed:	e9 20 ff ff ff       	jmp    40e812 <cos_ulk_page_alloc+0xa2>
  40e8f2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e8f8:	be 1b 00 00 00       	mov    esi,0x1b
  40e8fd:	bf 2f e7 41 00       	mov    edi,0x41e72f
  40e902:	e8 79 c3 ff ff       	call   40ac80 <cos_print_str>
		BUG();
  40e907:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e90e:	00 00 00 00 
  40e912:	0f 0b                	ud2    
{ l->o = 0; }
  40e914:	49 c7 84 24 58 01 00 	mov    QWORD PTR [r12+0x158],0x0
  40e91b:	00 00 00 00 00 
	if (!*cap) return -1;
  40e920:	eb 88                	jmp    40e8aa <cos_ulk_page_alloc+0x13a>
  40e922:	be 2e 00 00 00       	mov    esi,0x2e
  40e927:	bf 00 e7 41 00       	mov    edi,0x41e700
  40e92c:	e8 4f c3 ff ff       	call   40ac80 <cos_print_str>
	assert(kmem && (round_to_page(kmem) == kmem));
  40e931:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e938:	00 00 00 00 
  40e93c:	0f 0b                	ud2    
  40e93e:	be 2e 00 00 00       	mov    esi,0x2e
  40e943:	bf d0 e6 41 00       	mov    edi,0x41e6d0
  40e948:	e8 33 c3 ff ff       	call   40ac80 <cos_print_str>
	assert(ci_resources && ulkpt);
  40e94d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40e954:	00 00 00 00 
  40e958:	0f 0b                	ud2    
	if (__alloc_mem_cap(ci_resources, CAP_ULK, &kmem, &cap)) return 0;
  40e95a:	45 31 ff             	xor    r15d,r15d
  40e95d:	e9 48 ff ff ff       	jmp    40e8aa <cos_ulk_page_alloc+0x13a>
  40e962:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40e969:	00 00 00 00 
  40e96d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000040e970 <cos_ulk_map_in>:

int
cos_ulk_map_in(pgtblcap_t ptc)
{
  40e970:	f3 0f 1e fa          	endbr64 
  40e974:	55                   	push   rbp
  40e975:	48 89 e5             	mov    rbp,rsp
  40e978:	41 54                	push   r12
  40e97a:	53                   	push   rbx
  40e97b:	48 83 ec 10          	sub    rsp,0x10
	printd("cos_ulk_map_in\n");
	assert(ptc && __cos_ulk_info.secondlvl);
  40e97f:	48 85 ff             	test   rdi,rdi
  40e982:	74 67                	je     40e9eb <cos_ulk_map_in+0x7b>
  40e984:	48 8b 1d fd b0 2f 00 	mov    rbx,QWORD PTR [rip+0x2fb0fd]        # 709a88 <__cos_ulk_info+0x8>
  40e98b:	48 85 db             	test   rbx,rbx
  40e98e:	74 5b                	je     40e9eb <cos_ulk_map_in+0x7b>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40e990:	c1 e7 10             	shl    edi,0x10
	__asm__ __volatile__(
  40e993:	31 d2                	xor    edx,edx
  40e995:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  40e999:	48 be 00 00 00 00 80 	movabs rsi,0x7f8000000000
  40e9a0:	7f 00 00 
	cap_no += op;
  40e9a3:	8d 87 01 00 01 00    	lea    eax,[rdi+0x10001]
	__asm__ __volatile__(
  40e9a9:	48 89 d7             	mov    rdi,rdx
  40e9ac:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40e9af:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40e9b3:	48 89 cd             	mov    rbp,rcx
  40e9b6:	49 b8 d0 e9 40 00 00 	movabs r8,0x40e9d0
  40e9bd:	00 00 00 
  40e9c0:	0f 05                	syscall 
  40e9c2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e9c8:	eb 0d                	jmp    40e9d7 <cos_ulk_map_in+0x67>
  40e9ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40e9d0:	b9 00 00 00 00       	mov    ecx,0x0
  40e9d5:	eb 05                	jmp    40e9dc <cos_ulk_map_in+0x6c>
  40e9d7:	b9 01 00 00 00       	mov    ecx,0x1
  40e9dc:	5d                   	pop    rbp
  40e9dd:	5c                   	pop    rsp
	
	if (call_cap_op(ptc, CAPTBL_OP_CONS, __cos_ulk_info.secondlvl, ULK_BASE_ADDR, 0, 0)) {
  40e9de:	f7 d8                	neg    eax
  40e9e0:	19 c0                	sbb    eax,eax
		return -1; /* page is already mapped */
	}

	return 0;
}
  40e9e2:	48 83 c4 10          	add    rsp,0x10
  40e9e6:	5b                   	pop    rbx
  40e9e7:	41 5c                	pop    r12
  40e9e9:	5d                   	pop    rbp
  40e9ea:	c3                   	ret    
  40e9eb:	be 2e 00 00 00       	mov    esi,0x2e
  40e9f0:	bf 50 e7 41 00       	mov    edi,0x41e750
  40e9f5:	e8 86 c2 ff ff       	call   40ac80 <cos_print_str>
	assert(ptc && __cos_ulk_info.secondlvl);
  40e9fa:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ea01:	00 00 00 00 
  40ea05:	0f 0b                	ud2    
  40ea07:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40ea0e:	00 00 

000000000040ea10 <cos_thd_alloc_ext>:

#include <cos_thd_init.h>

thdcap_t
cos_thd_alloc_ext(struct cos_compinfo *ci, compcap_t comp, thdclosure_index_t idx)
{
  40ea10:	f3 0f 1e fa          	endbr64 
  40ea14:	55                   	push   rbp
  40ea15:	48 89 e5             	mov    rbp,rsp
  40ea18:	41 57                	push   r15
        __asm__ __volatile__("lock " PS_FAA_STR
  40ea1a:	41 bf 01 00 00 00    	mov    r15d,0x1
  40ea20:	41 56                	push   r14
  40ea22:	41 55                	push   r13
  40ea24:	41 54                	push   r12
  40ea26:	53                   	push   rbx
  40ea27:	48 83 ec 38          	sub    rsp,0x38
  40ea2b:	f0 4c 0f c1 3d cc d5 	lock xadd QWORD PTR [rip+0x1ad5cc],r15        # 5bc000 <__thdid_alloc>
  40ea32:	1a 00 
	thdid_t tid = cos_thd_id_alloc();

	if (idx < 1) return 0;
  40ea34:	85 d2                	test   edx,edx
  40ea36:	0f 8e 84 01 00 00    	jle    40ebc0 <cos_thd_alloc_ext+0x1b0>
  40ea3c:	49 89 fc             	mov    r12,rdi
	assert(ci && comp > 0);
  40ea3f:	48 85 ff             	test   rdi,rdi
  40ea42:	0f 84 ea 01 00 00    	je     40ec32 <cos_thd_alloc_ext+0x222>
  40ea48:	49 89 f5             	mov    r13,rsi
  40ea4b:	48 85 f6             	test   rsi,rsi
  40ea4e:	0f 84 de 01 00 00    	je     40ec32 <cos_thd_alloc_ext+0x222>
	if (!__cos_ulk_info.toplvl) return 0;
  40ea54:	4c 8b 0d 25 b0 2f 00 	mov    r9,QWORD PTR [rip+0x2fb025]        # 709a80 <__cos_ulk_info>
  40ea5b:	89 d3                	mov    ebx,edx
  40ea5d:	4d 85 c9             	test   r9,r9
  40ea60:	74 46                	je     40eaa8 <cos_thd_alloc_ext+0x98>
	if (!__cos_ulk_info.curr_pg || tid % ULK_STACKS_PER_PAGE == 0) {
  40ea62:	48 8b 05 27 b0 2f 00 	mov    rax,QWORD PTR [rip+0x2fb027]        # 709a90 <__cos_ulk_info+0x10>
  40ea69:	48 85 c0             	test   rax,rax
  40ea6c:	74 0a                	je     40ea78 <cos_thd_alloc_ext+0x68>
  40ea6e:	41 f6 c7 0f          	test   r15b,0xf
  40ea72:	0f 85 50 01 00 00    	jne    40ebc8 <cos_thd_alloc_ext+0x1b8>
		__cos_ulk_info.curr_pg = cos_ulk_page_alloc(ci, __cos_ulk_info.toplvl, __cos_ulk_info.pg_frontier);
  40ea78:	48 8b 15 19 b0 2f 00 	mov    rdx,QWORD PTR [rip+0x2fb019]        # 709a98 <__cos_ulk_info+0x18>
  40ea7f:	4c 89 ce             	mov    rsi,r9
  40ea82:	4c 89 e7             	mov    rdi,r12
  40ea85:	e8 e6 fc ff ff       	call   40e770 <cos_ulk_page_alloc>
  40ea8a:	48 89 05 ff af 2f 00 	mov    QWORD PTR [rip+0x2fafff],rax        # 709a90 <__cos_ulk_info+0x10>
  40ea91:	49 89 c1             	mov    r9,rax
		assert(__cos_ulk_info.curr_pg);
  40ea94:	48 85 c0             	test   rax,rax
  40ea97:	0f 84 de 01 00 00    	je     40ec7b <cos_thd_alloc_ext+0x26b>
		__cos_ulk_info.pg_frontier += PAGE_SIZE;
  40ea9d:	48 81 05 f0 af 2f 00 	add    QWORD PTR [rip+0x2faff0],0x1000        # 709a98 <__cos_ulk_info+0x18>
  40eaa4:	00 10 00 00 
	return __mem_bump_alloc(ci, 1, 1);
  40eaa8:	4c 89 e7             	mov    rdi,r12
  40eaab:	4c 89 4d b8          	mov    QWORD PTR [rbp-0x48],r9
  40eaaf:	e8 fc dc ff ff       	call   40c7b0 <__mem_bump_alloc.constprop.0>
  40eab4:	49 89 c2             	mov    r10,rax
	if (!*kmem) return -1;
  40eab7:	48 85 c0             	test   rax,rax
  40eaba:	0f 84 00 01 00 00    	je     40ebc0 <cos_thd_alloc_ext+0x1b0>
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  40eac0:	0f 01 f9             	rdtscp 
	return (long)coreid;
  40eac3:	48 89 cf             	mov    rdi,rcx
        __asm__ __volatile__("lock " PS_CAS_STR
  40eac6:	4c 8b 4d b8          	mov    r9,QWORD PTR [rbp-0x48]
  40eaca:	ba 01 00 00 00       	mov    edx,0x1
  40eacf:	45 31 c0             	xor    r8d,r8d
  40ead2:	81 e7 ff 0f 00 00    	and    edi,0xfff
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40ead8:	49 8d 8c 24 58 01 00 	lea    rcx,[r12+0x158]
  40eadf:	00 
		frontier = &ci->cap16_frontier[cos_cpuid()];
  40eae0:	49 8d 74 fc 28       	lea    rsi,[r12+rdi*8+0x28]
  40eae5:	0f 1f 00             	nop    DWORD PTR [rax]
        __asm__ __volatile__("lock " PS_CAS_STR
  40eae8:	4c 89 c0             	mov    rax,r8
  40eaeb:	f0 48 0f b1 11       	lock cmpxchg QWORD PTR [rcx],rdx
  40eaf0:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40eaf3:	84 c0                	test   al,al
  40eaf5:	74 f1                	je     40eae8 <cos_thd_alloc_ext+0xd8>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40eaf7:	48 8d 57 04          	lea    rdx,[rdi+0x4]
  40eafb:	4d 8b 74 d4 08       	mov    r14,QWORD PTR [r12+rdx*8+0x8]
  40eb00:	41 83 e6 03          	and    r14d,0x3
  40eb04:	0f 84 e6 00 00 00    	je     40ebf0 <cos_thd_alloc_ext+0x1e0>
        __asm__ __volatile__("lock " PS_FAA_STR
  40eb0a:	ba 01 00 00 00       	mov    edx,0x1
  40eb0f:	f0 48 0f c1 16       	lock xadd QWORD PTR [rsi],rdx
{ l->o = 0; }
  40eb14:	49 c7 84 24 58 01 00 	mov    QWORD PTR [r12+0x158],0x0
  40eb1b:	00 00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  40eb20:	49 89 d6             	mov    r14,rdx
	if (!*cap) return -1;
  40eb23:	48 85 d2             	test   rdx,rdx
  40eb26:	0f 84 94 00 00 00    	je     40ebc0 <cos_thd_alloc_ext+0x1b0>
	assert(!(init_data & ~((1 << 16) - 1)));
  40eb2c:	f7 c3 00 00 ff ff    	test   ebx,0xffff0000
  40eb32:	0f 85 27 01 00 00    	jne    40ec5f <cos_thd_alloc_ext+0x24f>
	ret = call_cap_op(ci->captbl_cap, CAPTBL_OP_THDACTIVATE, (init_data << 16) | cap,
  40eb38:	c1 e3 10             	shl    ebx,0x10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40eb3b:	41 8b 44 24 08       	mov    eax,DWORD PTR [r12+0x8]
			  __compinfo_metacap(ci)->mi.pgtbl_cap << 16 | comp, kmem, ulkcap << 16 | tid);
  40eb40:	49 c1 e1 10          	shl    r9,0x10
	__asm__ __volatile__(
  40eb44:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
	ret = call_cap_op(ci->captbl_cap, CAPTBL_OP_THDACTIVATE, (init_data << 16) | cap,
  40eb48:	48 63 db             	movsxd rbx,ebx
  40eb4b:	4c 89 d7             	mov    rdi,r10
  40eb4e:	48 09 d3             	or     rbx,rdx
			  __compinfo_metacap(ci)->mi.pgtbl_cap << 16 | comp, kmem, ulkcap << 16 | tid);
  40eb51:	49 8b 94 24 08 01 00 	mov    rdx,QWORD PTR [r12+0x108]
  40eb58:	00 
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40eb59:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40eb5c:	05 04 00 01 00       	add    eax,0x10004
  40eb61:	48 8b b2 40 01 00 00 	mov    rsi,QWORD PTR [rdx+0x140]
	ret = call_cap_op(ci->captbl_cap, CAPTBL_OP_THDACTIVATE, (init_data << 16) | cap,
  40eb68:	4c 89 ca             	mov    rdx,r9
  40eb6b:	4c 09 fa             	or     rdx,r15
			  __compinfo_metacap(ci)->mi.pgtbl_cap << 16 | comp, kmem, ulkcap << 16 | tid);
  40eb6e:	48 c1 e6 10          	shl    rsi,0x10
	ret = call_cap_op(ci->captbl_cap, CAPTBL_OP_THDACTIVATE, (init_data << 16) | cap,
  40eb72:	4c 09 ee             	or     rsi,r13
	__asm__ __volatile__(
  40eb75:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40eb78:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40eb7c:	48 89 cd             	mov    rbp,rcx
  40eb7f:	49 b8 98 eb 40 00 00 	movabs r8,0x40eb98
  40eb86:	00 00 00 
  40eb89:	0f 05                	syscall 
  40eb8b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  40eb90:	eb 0d                	jmp    40eb9f <cos_thd_alloc_ext+0x18f>
  40eb92:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40eb98:	b9 00 00 00 00       	mov    ecx,0x0
  40eb9d:	eb 05                	jmp    40eba4 <cos_thd_alloc_ext+0x194>
  40eb9f:	b9 01 00 00 00       	mov    ecx,0x1
  40eba4:	5d                   	pop    rbp
  40eba5:	5c                   	pop    rsp
	if (ret) BUG();
  40eba6:	85 c0                	test   eax,eax
  40eba8:	75 26                	jne    40ebd0 <cos_thd_alloc_ext+0x1c0>

	return __cos_thd_alloc(ci, comp, idx, tid);
}
  40ebaa:	48 83 c4 38          	add    rsp,0x38
  40ebae:	4c 89 f0             	mov    rax,r14
  40ebb1:	5b                   	pop    rbx
  40ebb2:	41 5c                	pop    r12
  40ebb4:	41 5d                	pop    r13
  40ebb6:	41 5e                	pop    r14
  40ebb8:	41 5f                	pop    r15
  40ebba:	5d                   	pop    rbp
  40ebbb:	c3                   	ret    
  40ebbc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	if (idx < 1) return 0;
  40ebc0:	45 31 f6             	xor    r14d,r14d
  40ebc3:	eb e5                	jmp    40ebaa <cos_thd_alloc_ext+0x19a>
  40ebc5:	0f 1f 00             	nop    DWORD PTR [rax]
  40ebc8:	49 89 c1             	mov    r9,rax
	return __cos_ulk_info.curr_pg;
  40ebcb:	e9 d8 fe ff ff       	jmp    40eaa8 <cos_thd_alloc_ext+0x98>
  40ebd0:	be 1b 00 00 00       	mov    esi,0x1b
  40ebd5:	bf 0f e8 41 00       	mov    edi,0x41e80f
  40ebda:	e8 a1 c0 ff ff       	call   40ac80 <cos_print_str>
	if (ret) BUG();
  40ebdf:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ebe6:	00 00 00 00 
  40ebea:	0f 0b                	ud2    
  40ebec:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  40ebf0:	4c 89 e7             	mov    rdi,r12
  40ebf3:	48 89 55 a0          	mov    QWORD PTR [rbp-0x60],rdx
  40ebf7:	48 89 75 a8          	mov    QWORD PTR [rbp-0x58],rsi
  40ebfb:	4c 89 4d b0          	mov    QWORD PTR [rbp-0x50],r9
  40ebff:	4c 89 55 b8          	mov    QWORD PTR [rbp-0x48],r10
  40ec03:	e8 38 dd ff ff       	call   40c940 <__capid_captbl_check_expand>
  40ec08:	4c 8b 55 b8          	mov    r10,QWORD PTR [rbp-0x48]
  40ec0c:	4c 8b 4d b0          	mov    r9,QWORD PTR [rbp-0x50]
  40ec10:	85 c0                	test   eax,eax
  40ec12:	48 8b 75 a8          	mov    rsi,QWORD PTR [rbp-0x58]
  40ec16:	48 8b 55 a0          	mov    rdx,QWORD PTR [rbp-0x60]
  40ec1a:	75 32                	jne    40ec4e <cos_thd_alloc_ext+0x23e>
        __asm__ __volatile__("lock " PS_FAA_STR
  40ec1c:	b8 04 00 00 00       	mov    eax,0x4
  40ec21:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40ec28:	49 89 44 d4 08       	mov    QWORD PTR [r12+rdx*8+0x8],rax
  40ec2d:	e9 d8 fe ff ff       	jmp    40eb0a <cos_thd_alloc_ext+0xfa>
  40ec32:	be 2e 00 00 00       	mov    esi,0x2e
  40ec37:	bf 80 e7 41 00       	mov    edi,0x41e780
  40ec3c:	e8 3f c0 ff ff       	call   40ac80 <cos_print_str>
	assert(ci && comp > 0);
  40ec41:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ec48:	00 00 00 00 
  40ec4c:	0f 0b                	ud2    
{ l->o = 0; }
  40ec4e:	49 c7 84 24 58 01 00 	mov    QWORD PTR [r12+0x158],0x0
  40ec55:	00 00 00 00 00 
	if (!*cap) return -1;
  40ec5a:	e9 4b ff ff ff       	jmp    40ebaa <cos_thd_alloc_ext+0x19a>
  40ec5f:	be 2e 00 00 00       	mov    esi,0x2e
  40ec64:	bf e0 e7 41 00       	mov    edi,0x41e7e0
  40ec69:	e8 12 c0 ff ff       	call   40ac80 <cos_print_str>
	assert(!(init_data & ~((1 << 16) - 1)));
  40ec6e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ec75:	00 00 00 00 
  40ec79:	0f 0b                	ud2    
  40ec7b:	be 2e 00 00 00       	mov    esi,0x2e
  40ec80:	bf b0 e7 41 00       	mov    edi,0x41e7b0
  40ec85:	e8 f6 bf ff ff       	call   40ac80 <cos_print_str>
		assert(__cos_ulk_info.curr_pg);
  40ec8a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ec91:	00 00 00 00 
  40ec95:	0f 0b                	ud2    
  40ec97:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40ec9e:	00 00 

000000000040eca0 <cos_thd_alloc>:

thdcap_t
cos_thd_alloc(struct cos_compinfo *ci, compcap_t comp, cos_thd_fn_t fn, void *data)
{
  40eca0:	f3 0f 1e fa          	endbr64 
  40eca4:	55                   	push   rbp
  40eca5:	48 89 e5             	mov    rbp,rsp
  40eca8:	41 57                	push   r15
  40ecaa:	41 56                	push   r14
        __asm__ __volatile__("lock " PS_FAA_STR
  40ecac:	41 be 01 00 00 00    	mov    r14d,0x1
  40ecb2:	41 55                	push   r13
  40ecb4:	41 54                	push   r12
  40ecb6:	53                   	push   rbx
  40ecb7:	48 83 ec 38          	sub    rsp,0x38
  40ecbb:	f0 4c 0f c1 35 3c d3 	lock xadd QWORD PTR [rip+0x1ad33c],r14        # 5bc000 <__thdid_alloc>
  40ecc2:	1a 00 
	if (!fn) return -1;
  40ecc4:	48 85 d2             	test   rdx,rdx
  40ecc7:	0f 84 60 02 00 00    	je     40ef2d <cos_thd_alloc+0x28d>
  40eccd:	49 89 fc             	mov    r12,rdi
  40ecd0:	49 89 f7             	mov    r15,rsi
  40ecd3:	41 b8 02 00 00 00    	mov    r8d,0x2
  40ecd9:	48 89 d6             	mov    rsi,rdx
  40ecdc:	31 ff                	xor    edi,edi
	for (i = 0; i < COS_THD_INIT_REGION_SIZE; i++) {
  40ecde:	ba 40 87 70 00       	mov    edx,0x708740
  40ece3:	31 db                	xor    ebx,ebx
		if (__thd_init_data[i].fn == NULL) {
  40ece5:	48 83 3a 00          	cmp    QWORD PTR [rdx],0x0
  40ece9:	74 25                	je     40ed10 <cos_thd_alloc+0x70>
	for (i = 0; i < COS_THD_INIT_REGION_SIZE; i++) {
  40eceb:	83 c3 01             	add    ebx,0x1
  40ecee:	48 83 c2 10          	add    rdx,0x10
  40ecf2:	81 fb 00 01 00 00    	cmp    ebx,0x100
  40ecf8:	75 eb                	jne    40ece5 <cos_thd_alloc+0x45>
	if (!tried) {
  40ecfa:	41 83 f8 01          	cmp    r8d,0x1
  40ecfe:	0f 84 29 02 00 00    	je     40ef2d <cos_thd_alloc+0x28d>
  40ed04:	41 b8 01 00 00 00    	mov    r8d,0x1
  40ed0a:	eb d2                	jmp    40ecde <cos_thd_alloc+0x3e>
  40ed0c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  40ed10:	48 89 f8             	mov    rax,rdi
  40ed13:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40ed18:	0f 94 c0             	sete   al
			if (!ret) continue;
  40ed1b:	84 c0                	test   al,al
  40ed1d:	74 cc                	je     40eceb <cos_thd_alloc+0x4b>
			assert(__thd_init_data[i].fn == fn);
  40ed1f:	4c 63 eb             	movsxd r13,ebx
  40ed22:	4c 89 e8             	mov    rax,r13
  40ed25:	48 c1 e0 04          	shl    rax,0x4
  40ed29:	48 8d 90 40 87 70 00 	lea    rdx,[rax+0x708740]
  40ed30:	48 3b b0 40 87 70 00 	cmp    rsi,QWORD PTR [rax+0x708740]
  40ed37:	0f 85 f8 01 00 00    	jne    40ef35 <cos_thd_alloc+0x295>
			__thd_init_data[i].data = data;
  40ed3d:	48 89 4a 08          	mov    QWORD PTR [rdx+0x8],rcx
	assert(ci && comp > 0);
  40ed41:	4d 85 e4             	test   r12,r12
  40ed44:	0f 84 2a 02 00 00    	je     40ef74 <cos_thd_alloc+0x2d4>
  40ed4a:	4d 85 ff             	test   r15,r15
  40ed4d:	0f 84 21 02 00 00    	je     40ef74 <cos_thd_alloc+0x2d4>
	if (!__cos_ulk_info.toplvl) return 0;
  40ed53:	4c 8b 05 26 ad 2f 00 	mov    r8,QWORD PTR [rip+0x2fad26]        # 709a80 <__cos_ulk_info>
  40ed5a:	4d 85 c0             	test   r8,r8
  40ed5d:	74 1d                	je     40ed7c <cos_thd_alloc+0xdc>
	if (!__cos_ulk_info.curr_pg || tid % ULK_STACKS_PER_PAGE == 0) {
  40ed5f:	48 8b 05 2a ad 2f 00 	mov    rax,QWORD PTR [rip+0x2fad2a]        # 709a90 <__cos_ulk_info+0x10>
  40ed66:	48 85 c0             	test   rax,rax
  40ed69:	0f 84 59 01 00 00    	je     40eec8 <cos_thd_alloc+0x228>
  40ed6f:	41 f6 c6 0f          	test   r14b,0xf
  40ed73:	0f 84 4f 01 00 00    	je     40eec8 <cos_thd_alloc+0x228>
  40ed79:	49 89 c0             	mov    r8,rax
	return __mem_bump_alloc(ci, 1, 1);
  40ed7c:	4c 89 e7             	mov    rdi,r12
  40ed7f:	4c 89 45 b0          	mov    QWORD PTR [rbp-0x50],r8
			return i + 1;
  40ed83:	83 c3 01             	add    ebx,0x1
  40ed86:	e8 25 da ff ff       	call   40c7b0 <__mem_bump_alloc.constprop.0>
  40ed8b:	48 89 45 b8          	mov    QWORD PTR [rbp-0x48],rax
	if (!*kmem) return -1;
  40ed8f:	48 85 c0             	test   rax,rax
  40ed92:	0f 84 71 01 00 00    	je     40ef09 <cos_thd_alloc+0x269>
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  40ed98:	0f 01 f9             	rdtscp 
	return (long)coreid;
  40ed9b:	48 89 cf             	mov    rdi,rcx
        __asm__ __volatile__("lock " PS_CAS_STR
  40ed9e:	4c 8b 45 b0          	mov    r8,QWORD PTR [rbp-0x50]
  40eda2:	be 01 00 00 00       	mov    esi,0x1
  40eda7:	31 c9                	xor    ecx,ecx
  40eda9:	81 e7 ff 0f 00 00    	and    edi,0xfff
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40edaf:	49 8d 94 24 58 01 00 	lea    rdx,[r12+0x158]
  40edb6:	00 
		frontier = &ci->cap16_frontier[cos_cpuid()];
  40edb7:	4d 8d 54 fc 28       	lea    r10,[r12+rdi*8+0x28]
  40edbc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  40edc0:	48 89 c8             	mov    rax,rcx
  40edc3:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40edc8:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40edcb:	84 c0                	test   al,al
  40edcd:	74 f1                	je     40edc0 <cos_thd_alloc+0x120>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40edcf:	48 8d 57 04          	lea    rdx,[rdi+0x4]
  40edd3:	41 f6 44 fc 28 03    	test   BYTE PTR [r12+rdi*8+0x28],0x3
  40edd9:	0f 84 a9 00 00 00    	je     40ee88 <cos_thd_alloc+0x1e8>
        __asm__ __volatile__("lock " PS_FAA_STR
  40eddf:	ba 01 00 00 00       	mov    edx,0x1
  40ede4:	f0 49 0f c1 12       	lock xadd QWORD PTR [r10],rdx
{ l->o = 0; }
  40ede9:	49 c7 84 24 58 01 00 	mov    QWORD PTR [r12+0x158],0x0
  40edf0:	00 00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  40edf5:	49 89 d2             	mov    r10,rdx
	if (!*cap) return -1;
  40edf8:	48 85 d2             	test   rdx,rdx
  40edfb:	0f 84 08 01 00 00    	je     40ef09 <cos_thd_alloc+0x269>
	ret = call_cap_op(ci->captbl_cap, CAPTBL_OP_THDACTIVATE, (init_data << 16) | cap,
  40ee01:	c1 e3 10             	shl    ebx,0x10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40ee04:	41 8b 44 24 08       	mov    eax,DWORD PTR [r12+0x8]
	__asm__ __volatile__(
  40ee09:	48 8b 7d b8          	mov    rdi,QWORD PTR [rbp-0x48]
  40ee0d:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  40ee11:	48 63 db             	movsxd rbx,ebx
  40ee14:	48 09 d3             	or     rbx,rdx
			  __compinfo_metacap(ci)->mi.pgtbl_cap << 16 | comp, kmem, ulkcap << 16 | tid);
  40ee17:	49 8b 94 24 08 01 00 	mov    rdx,QWORD PTR [r12+0x108]
  40ee1e:	00 
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40ee1f:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40ee22:	05 04 00 01 00       	add    eax,0x10004
  40ee27:	48 8b b2 40 01 00 00 	mov    rsi,QWORD PTR [rdx+0x140]
  40ee2e:	4c 89 c2             	mov    rdx,r8
  40ee31:	48 c1 e2 10          	shl    rdx,0x10
  40ee35:	48 c1 e6 10          	shl    rsi,0x10
	ret = call_cap_op(ci->captbl_cap, CAPTBL_OP_THDACTIVATE, (init_data << 16) | cap,
  40ee39:	4c 09 f2             	or     rdx,r14
  40ee3c:	4c 09 fe             	or     rsi,r15
	__asm__ __volatile__(
  40ee3f:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40ee42:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40ee46:	48 89 cd             	mov    rbp,rcx
  40ee49:	49 b8 60 ee 40 00 00 	movabs r8,0x40ee60
  40ee50:	00 00 00 
  40ee53:	0f 05                	syscall 
  40ee55:	0f 1f 00             	nop    DWORD PTR [rax]
  40ee58:	eb 0d                	jmp    40ee67 <cos_thd_alloc+0x1c7>
  40ee5a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40ee60:	b9 00 00 00 00       	mov    ecx,0x0
  40ee65:	eb 05                	jmp    40ee6c <cos_thd_alloc+0x1cc>
  40ee67:	b9 01 00 00 00       	mov    ecx,0x1
  40ee6c:	5d                   	pop    rbp
  40ee6d:	5c                   	pop    rsp
	if (ret) BUG();
  40ee6e:	85 c0                	test   eax,eax
  40ee70:	0f 85 e2 00 00 00    	jne    40ef58 <cos_thd_alloc+0x2b8>
	if (idx < 1) return 0;
	ret = __cos_thd_alloc(ci, comp, idx, tid);
	if (!ret) cos_thd_init_free(idx);

	return ret;
}
  40ee76:	48 83 c4 38          	add    rsp,0x38
  40ee7a:	4c 89 d0             	mov    rax,r10
  40ee7d:	5b                   	pop    rbx
  40ee7e:	41 5c                	pop    r12
  40ee80:	41 5d                	pop    r13
  40ee82:	41 5e                	pop    r14
  40ee84:	41 5f                	pop    r15
  40ee86:	5d                   	pop    rbp
  40ee87:	c3                   	ret    
		if (__capid_captbl_check_expand(ci)) goto error;
  40ee88:	4c 89 e7             	mov    rdi,r12
  40ee8b:	48 89 55 a0          	mov    QWORD PTR [rbp-0x60],rdx
  40ee8f:	4c 89 55 a8          	mov    QWORD PTR [rbp-0x58],r10
  40ee93:	4c 89 45 b0          	mov    QWORD PTR [rbp-0x50],r8
  40ee97:	e8 a4 da ff ff       	call   40c940 <__capid_captbl_check_expand>
  40ee9c:	4c 8b 45 b0          	mov    r8,QWORD PTR [rbp-0x50]
  40eea0:	4c 8b 55 a8          	mov    r10,QWORD PTR [rbp-0x58]
  40eea4:	85 c0                	test   eax,eax
  40eea6:	48 8b 55 a0          	mov    rdx,QWORD PTR [rbp-0x60]
  40eeaa:	75 51                	jne    40eefd <cos_thd_alloc+0x25d>
        __asm__ __volatile__("lock " PS_FAA_STR
  40eeac:	b8 04 00 00 00       	mov    eax,0x4
  40eeb1:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40eeb8:	49 89 44 d4 08       	mov    QWORD PTR [r12+rdx*8+0x8],rax
  40eebd:	e9 1d ff ff ff       	jmp    40eddf <cos_thd_alloc+0x13f>
  40eec2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
		__cos_ulk_info.curr_pg = cos_ulk_page_alloc(ci, __cos_ulk_info.toplvl, __cos_ulk_info.pg_frontier);
  40eec8:	48 8b 15 c9 ab 2f 00 	mov    rdx,QWORD PTR [rip+0x2fabc9]        # 709a98 <__cos_ulk_info+0x18>
  40eecf:	4c 89 c6             	mov    rsi,r8
  40eed2:	4c 89 e7             	mov    rdi,r12
  40eed5:	e8 96 f8 ff ff       	call   40e770 <cos_ulk_page_alloc>
  40eeda:	48 89 05 af ab 2f 00 	mov    QWORD PTR [rip+0x2fabaf],rax        # 709a90 <__cos_ulk_info+0x10>
  40eee1:	49 89 c0             	mov    r8,rax
		assert(__cos_ulk_info.curr_pg);
  40eee4:	48 85 c0             	test   rax,rax
  40eee7:	0f 84 a3 00 00 00    	je     40ef90 <cos_thd_alloc+0x2f0>
		__cos_ulk_info.pg_frontier += PAGE_SIZE;
  40eeed:	48 81 05 a0 ab 2f 00 	add    QWORD PTR [rip+0x2faba0],0x1000        # 709a98 <__cos_ulk_info+0x18>
  40eef4:	00 10 00 00 
  40eef8:	e9 7f fe ff ff       	jmp    40ed7c <cos_thd_alloc+0xdc>
{ l->o = 0; }
  40eefd:	49 c7 84 24 58 01 00 	mov    QWORD PTR [r12+0x158],0x0
  40ef04:	00 00 00 00 00 
 * thread creation failed for some reason.
 */
static void
cos_thd_init_free(thdclosure_index_t idx)
{
	if (idx > COS_THD_INIT_REGION_SIZE || idx <= 0 || !__thd_init_data[idx].fn) return;
  40ef09:	48 63 db             	movsxd rbx,ebx
  40ef0c:	48 c1 e3 04          	shl    rbx,0x4
  40ef10:	48 83 bb 40 87 70 00 	cmp    QWORD PTR [rbx+0x708740],0x0
  40ef17:	00 
  40ef18:	74 13                	je     40ef2d <cos_thd_alloc+0x28d>
	__thd_init_data[idx].fn   = NULL;
  40ef1a:	4d 89 e9             	mov    r9,r13
  40ef1d:	66 0f ef c0          	pxor   xmm0,xmm0
  40ef21:	49 c1 e1 04          	shl    r9,0x4
  40ef25:	41 0f 11 81 40 87 70 	movups XMMWORD PTR [r9+0x708740],xmm0
  40ef2c:	00 
	return;
  40ef2d:	45 31 d2             	xor    r10d,r10d
  40ef30:	e9 41 ff ff ff       	jmp    40ee76 <cos_thd_alloc+0x1d6>
  40ef35:	be 67 00 00 00       	mov    esi,0x67
  40ef3a:	bf 30 e8 41 00       	mov    edi,0x41e830
  40ef3f:	e8 3c bd ff ff       	call   40ac80 <cos_print_str>
			assert(__thd_init_data[i].fn == fn);
  40ef44:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ef4b:	00 00 00 00 
  40ef4f:	0f 0b                	ud2    
  40ef51:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  40ef58:	be 1b 00 00 00       	mov    esi,0x1b
  40ef5d:	bf 0f e8 41 00       	mov    edi,0x41e80f
  40ef62:	e8 19 bd ff ff       	call   40ac80 <cos_print_str>
	if (ret) BUG();
  40ef67:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ef6e:	00 00 00 00 
  40ef72:	0f 0b                	ud2    
  40ef74:	be 2e 00 00 00       	mov    esi,0x2e
  40ef79:	bf 80 e7 41 00       	mov    edi,0x41e780
  40ef7e:	e8 fd bc ff ff       	call   40ac80 <cos_print_str>
	assert(ci && comp > 0);
  40ef83:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40ef8a:	00 00 00 00 
  40ef8e:	0f 0b                	ud2    
  40ef90:	be 2e 00 00 00       	mov    esi,0x2e
  40ef95:	bf b0 e7 41 00       	mov    edi,0x41e7b0
  40ef9a:	e8 e1 bc ff ff       	call   40ac80 <cos_print_str>
		assert(__cos_ulk_info.curr_pg);
  40ef9f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40efa6:	00 00 00 00 
  40efaa:	0f 0b                	ud2    
  40efac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000040efb0 <cos_shared_kernel_page_alloc_at>:

vaddr_t
cos_shared_kernel_page_alloc_at(struct cos_compinfo *ci, vaddr_t mem_ptr)
{
  40efb0:	f3 0f 1e fa          	endbr64 
  40efb4:	55                   	push   rbp
  40efb5:	48 89 e5             	mov    rbp,rsp
  40efb8:	41 55                	push   r13
  40efba:	41 54                	push   r12
  40efbc:	53                   	push   rbx
  40efbd:	48 83 ec 18          	sub    rsp,0x18
	return ci->memsrc;
  40efc1:	4c 8b a7 08 01 00 00 	mov    r12,QWORD PTR [rdi+0x108]
	vaddr_t ptemem_cap;
	int ret;

	struct cos_compinfo *meta = __compinfo_metacap(ci);

	assert(meta == __compinfo_metacap(meta));
  40efc8:	4d 39 a4 24 08 01 00 	cmp    QWORD PTR [r12+0x108],r12
  40efcf:	00 
  40efd0:	0f 85 96 00 00 00    	jne    40f06c <cos_shared_kernel_page_alloc_at+0xbc>
  40efd6:	48 89 fb             	mov    rbx,rdi
	return __mem_bump_alloc(ci, 1, 1);
  40efd9:	4c 89 e7             	mov    rdi,r12
  40efdc:	49 89 f5             	mov    r13,rsi
  40efdf:	e8 cc d7 ff ff       	call   40c7b0 <__mem_bump_alloc.constprop.0>
  40efe4:	49 89 c2             	mov    r10,rax

	ptemem_cap = __kmem_bump_alloc(meta);

	assert(ptemem_cap != 0);
  40efe7:	48 85 c0             	test   rax,rax
  40efea:	0f 84 98 00 00 00    	je     40f088 <cos_shared_kernel_page_alloc_at+0xd8>
  40eff0:	48 8b 33             	mov    rsi,QWORD PTR [rbx]
  40eff3:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  40eff7:	ba 0c 00 00 00       	mov    edx,0xc
  40effc:	4c 89 d3             	mov    rbx,r10

	/* Actually map in the memory. */
	ret = call_cap_op(meta->mi.pgtbl_cap, CAPTBL_OP_MEMACTIVATE, ptemem_cap, ci->pgtbl_cap, mem_ptr, PAGE_ORDER);
  40efff:	49 8b 84 24 40 01 00 	mov    rax,QWORD PTR [r12+0x140]
  40f006:	00 
  40f007:	4c 89 ef             	mov    rdi,r13
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f00a:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40f00d:	05 17 00 01 00       	add    eax,0x10017
	__asm__ __volatile__(
  40f012:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40f015:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40f019:	48 89 cd             	mov    rbp,rcx
  40f01c:	49 b8 30 f0 40 00 00 	movabs r8,0x40f030
  40f023:	00 00 00 
  40f026:	0f 05                	syscall 
  40f028:	eb 0d                	jmp    40f037 <cos_shared_kernel_page_alloc_at+0x87>
  40f02a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40f030:	b9 00 00 00 00       	mov    ecx,0x0
  40f035:	eb 05                	jmp    40f03c <cos_shared_kernel_page_alloc_at+0x8c>
  40f037:	b9 01 00 00 00       	mov    ecx,0x1
  40f03c:	5d                   	pop    rbp
  40f03d:	5c                   	pop    rsp
	if (ret) {
  40f03e:	85 c0                	test   eax,eax
  40f040:	75 0e                	jne    40f050 <cos_shared_kernel_page_alloc_at+0xa0>
		BUG();
	}

	return ptemem_cap;
}
  40f042:	48 83 c4 18          	add    rsp,0x18
  40f046:	4c 89 d0             	mov    rax,r10
  40f049:	5b                   	pop    rbx
  40f04a:	41 5c                	pop    r12
  40f04c:	41 5d                	pop    r13
  40f04e:	5d                   	pop    rbp
  40f04f:	c3                   	ret    
  40f050:	be 1c 00 00 00       	mov    esi,0x1c
  40f055:	bf f8 e8 41 00       	mov    edi,0x41e8f8
  40f05a:	e8 21 bc ff ff       	call   40ac80 <cos_print_str>
		BUG();
  40f05f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f066:	00 00 00 00 
  40f06a:	0f 0b                	ud2    
  40f06c:	be 2f 00 00 00       	mov    esi,0x2f
  40f071:	bf 98 e8 41 00       	mov    edi,0x41e898
  40f076:	e8 05 bc ff ff       	call   40ac80 <cos_print_str>
	assert(meta == __compinfo_metacap(meta));
  40f07b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f082:	00 00 00 00 
  40f086:	0f 0b                	ud2    
  40f088:	be 2f 00 00 00       	mov    esi,0x2f
  40f08d:	bf c8 e8 41 00       	mov    edi,0x41e8c8
  40f092:	e8 e9 bb ff ff       	call   40ac80 <cos_print_str>
	assert(ptemem_cap != 0);
  40f097:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f09e:	00 00 00 00 
  40f0a2:	0f 0b                	ud2    
  40f0a4:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40f0ab:	00 00 00 00 
  40f0af:	90                   	nop

000000000040f0b0 <cos_shared_kernel_page_alloc>:

vaddr_t
cos_shared_kernel_page_alloc(struct cos_compinfo *ci, vaddr_t *resource)
{
  40f0b0:	f3 0f 1e fa          	endbr64 
  40f0b4:	55                   	push   rbp
  40f0b5:	48 89 e5             	mov    rbp,rsp
  40f0b8:	41 56                	push   r14
  40f0ba:	41 55                	push   r13
  40f0bc:	41 54                	push   r12
  40f0be:	53                   	push   rbx
  40f0bf:	48 83 ec 10          	sub    rsp,0x10
	return ci->memsrc;
  40f0c3:	4c 8b b7 08 01 00 00 	mov    r14,QWORD PTR [rdi+0x108]
	int ret;
	vaddr_t heap_vaddr = 0;
	vaddr_t kmem = 0;
	struct cos_compinfo *meta = __compinfo_metacap(ci);

	assert(meta == __compinfo_metacap(meta));
  40f0ca:	4d 39 b6 08 01 00 00 	cmp    QWORD PTR [r14+0x108],r14
  40f0d1:	0f 85 c5 00 00 00    	jne    40f19c <cos_shared_kernel_page_alloc+0xec>
  40f0d7:	49 89 fc             	mov    r12,rdi
  40f0da:	49 89 f5             	mov    r13,rsi
	return __mem_bump_alloc(ci, 1, 1);
  40f0dd:	e8 ce d6 ff ff       	call   40c7b0 <__mem_bump_alloc.constprop.0>
  40f0e2:	48 89 c3             	mov    rbx,rax

	kmem = __kmem_bump_alloc(ci);
	assert(kmem);
  40f0e5:	48 85 c0             	test   rax,rax
  40f0e8:	0f 84 ca 00 00 00    	je     40f1b8 <cos_shared_kernel_page_alloc+0x108>

	heap_vaddr = __page_bump_valloc(ci, PAGE_SIZE, PAGE_SIZE);
  40f0ee:	ba 00 10 00 00       	mov    edx,0x1000
  40f0f3:	be 00 10 00 00       	mov    esi,0x1000
  40f0f8:	4c 89 e7             	mov    rdi,r12
  40f0fb:	e8 d0 dd ff ff       	call   40ced0 <__page_bump_valloc>
  40f100:	49 89 c2             	mov    r10,rax
	assert(heap_vaddr);
  40f103:	48 85 c0             	test   rax,rax
  40f106:	0f 84 c8 00 00 00    	je     40f1d4 <cos_shared_kernel_page_alloc+0x124>
  40f10c:	49 8b 34 24          	mov    rsi,QWORD PTR [r12]
  40f110:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  40f114:	ba 0c 00 00 00       	mov    edx,0xc
  40f119:	4c 89 d7             	mov    rdi,r10

	ret = call_cap_op(meta->mi.pgtbl_cap, CAPTBL_OP_MEMACTIVATE, kmem, ci->pgtbl_cap, heap_vaddr, PAGE_ORDER);
  40f11c:	49 8b 86 40 01 00 00 	mov    rax,QWORD PTR [r14+0x140]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f123:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40f126:	05 17 00 01 00       	add    eax,0x10017
	__asm__ __volatile__(
  40f12b:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40f12e:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40f132:	48 89 cd             	mov    rbp,rcx
  40f135:	49 b8 50 f1 40 00 00 	movabs r8,0x40f150
  40f13c:	00 00 00 
  40f13f:	0f 05                	syscall 
  40f141:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  40f148:	eb 0d                	jmp    40f157 <cos_shared_kernel_page_alloc+0xa7>
  40f14a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40f150:	b9 00 00 00 00       	mov    ecx,0x0
  40f155:	eb 05                	jmp    40f15c <cos_shared_kernel_page_alloc+0xac>
  40f157:	b9 01 00 00 00       	mov    ecx,0x1
  40f15c:	5d                   	pop    rbp
  40f15d:	5c                   	pop    rsp
	if (ret) {
  40f15e:	85 c0                	test   eax,eax
  40f160:	75 1e                	jne    40f180 <cos_shared_kernel_page_alloc+0xd0>
		BUG();
	}

	*resource = kmem;
  40f162:	49 89 5d 00          	mov    QWORD PTR [r13+0x0],rbx

	return heap_vaddr;
}
  40f166:	48 83 c4 10          	add    rsp,0x10
  40f16a:	4c 89 d0             	mov    rax,r10
  40f16d:	5b                   	pop    rbx
  40f16e:	41 5c                	pop    r12
  40f170:	41 5d                	pop    r13
  40f172:	41 5e                	pop    r14
  40f174:	5d                   	pop    rbp
  40f175:	c3                   	ret    
  40f176:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  40f17d:	00 00 00 
  40f180:	be 1c 00 00 00       	mov    esi,0x1c
  40f185:	bf a8 e9 41 00       	mov    edi,0x41e9a8
  40f18a:	e8 f1 ba ff ff       	call   40ac80 <cos_print_str>
		BUG();
  40f18f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f196:	00 00 00 00 
  40f19a:	0f 0b                	ud2    
  40f19c:	be 2f 00 00 00       	mov    esi,0x2f
  40f1a1:	bf 18 e9 41 00       	mov    edi,0x41e918
  40f1a6:	e8 d5 ba ff ff       	call   40ac80 <cos_print_str>
	assert(meta == __compinfo_metacap(meta));
  40f1ab:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f1b2:	00 00 00 00 
  40f1b6:	0f 0b                	ud2    
  40f1b8:	be 2f 00 00 00       	mov    esi,0x2f
  40f1bd:	bf 48 e9 41 00       	mov    edi,0x41e948
  40f1c2:	e8 b9 ba ff ff       	call   40ac80 <cos_print_str>
	assert(kmem);
  40f1c7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f1ce:	00 00 00 00 
  40f1d2:	0f 0b                	ud2    
  40f1d4:	be 2f 00 00 00       	mov    esi,0x2f
  40f1d9:	bf 78 e9 41 00       	mov    edi,0x41e978
  40f1de:	e8 9d ba ff ff       	call   40ac80 <cos_print_str>
	assert(heap_vaddr);
  40f1e3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f1ea:	00 00 00 00 
  40f1ee:	0f 0b                	ud2    

000000000040f1f0 <cos_vm_kernel_page_create>:

vaddr_t
cos_vm_kernel_page_create(struct cos_compinfo *ci)
{
  40f1f0:	f3 0f 1e fa          	endbr64 
  40f1f4:	55                   	push   rbp
  40f1f5:	48 89 e5             	mov    rbp,rsp
  40f1f8:	41 55                	push   r13
  40f1fa:	41 54                	push   r12
  40f1fc:	53                   	push   rbx
  40f1fd:	48 83 ec 18          	sub    rsp,0x18
	assert(__ci);
  40f201:	48 85 ff             	test   rdi,rdi
  40f204:	0f 84 8f 01 00 00    	je     40f399 <cos_vm_kernel_page_create+0x1a9>
	return ci->memsrc;
  40f20a:	4c 8b 97 08 01 00 00 	mov    r10,QWORD PTR [rdi+0x108]
        __asm__ __volatile__("lock " PS_CAS_STR
  40f211:	be 01 00 00 00       	mov    esi,0x1
  40f216:	31 c9                	xor    ecx,ecx
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f218:	49 8d 92 60 01 00 00 	lea    rdx,[r10+0x160]
	assert(ci && ci == __compinfo_metacap(__ci));
  40f21f:	4d 85 d2             	test   r10,r10
  40f222:	0f 84 8d 01 00 00    	je     40f3b5 <cos_vm_kernel_page_create+0x1c5>
  40f228:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40f22f:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  40f230:	48 89 c8             	mov    rax,rcx
  40f233:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40f238:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f23b:	84 c0                	test   al,al
  40f23d:	74 f1                	je     40f230 <cos_vm_kernel_page_create+0x40>
        __asm__ __volatile__("lock " PS_FAA_STR
  40f23f:	41 bd 00 10 00 00    	mov    r13d,0x1000
  40f245:	f0 4d 0f c1 aa 20 01 	lock xadd QWORD PTR [r10+0x120],r13
  40f24c:	00 00 
	if (ret >= *frontier || *frontier - ret > RETYPE_MEM_SIZE) {
  40f24e:	49 8b 92 38 01 00 00 	mov    rdx,QWORD PTR [r10+0x138]
  40f255:	49 39 d5             	cmp    r13,rdx
  40f258:	0f 82 d2 00 00 00    	jb     40f330 <cos_vm_kernel_page_create+0x140>
		vaddr_t ptr_tmp = *ptr, front_tmp = *frontier;
  40f25e:	49 8b 82 20 01 00 00 	mov    rax,QWORD PTR [r10+0x120]
		if (ci->mi.untyped_ptr == ci->mi.untyped_frontier) goto error;
  40f265:	49 8b 9a 28 01 00 00 	mov    rbx,QWORD PTR [r10+0x128]
  40f26c:	49 39 9a 10 01 00 00 	cmp    QWORD PTR [r10+0x110],rbx
  40f273:	0f 84 d7 00 00 00    	je     40f350 <cos_vm_kernel_page_create+0x160>
  40f279:	41 bd 00 10 00 00    	mov    r13d,0x1000
  40f27f:	f0 4d 0f c1 aa 10 01 	lock xadd QWORD PTR [r10+0x110],r13
  40f286:	00 00 
		if (ps_cas(ptr, ptr_tmp, ret + PAGE_SIZE)) {
  40f288:	49 8d 8d 00 10 00 00 	lea    rcx,[r13+0x1000]
        __asm__ __volatile__("lock " PS_CAS_STR
  40f28f:	f0 49 0f b1 8a 20 01 	lock cmpxchg QWORD PTR [r10+0x120],rcx
  40f296:	00 00 
  40f298:	0f 94 c0             	sete   al
  40f29b:	84 c0                	test   al,al
  40f29d:	74 0f                	je     40f2ae <cos_vm_kernel_page_create+0xbe>
  40f29f:	48 89 d0             	mov    rax,rdx
  40f2a2:	f0 49 0f b1 8a 38 01 	lock cmpxchg QWORD PTR [r10+0x138],rcx
  40f2a9:	00 00 
  40f2ab:	0f 94 c0             	sete   al
	if (retype && (ret % RETYPE_MEM_SIZE == 0)) {
  40f2ae:	4c 89 ea             	mov    rdx,r13
  40f2b1:	81 e2 ff 0f 00 00    	and    edx,0xfff
  40f2b7:	0f 85 c3 00 00 00    	jne    40f380 <cos_vm_kernel_page_create+0x190>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f2bd:	41 8b 82 40 01 00 00 	mov    eax,DWORD PTR [r10+0x140]
	__asm__ __volatile__(
  40f2c4:	4c 89 eb             	mov    rbx,r13
  40f2c7:	48 89 d6             	mov    rsi,rdx
  40f2ca:	48 89 d7             	mov    rdi,rdx
  40f2cd:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f2d1:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40f2d4:	05 1a 00 01 00       	add    eax,0x1001a
	__asm__ __volatile__(
  40f2d9:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40f2dc:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40f2e0:	48 89 cd             	mov    rbp,rcx
  40f2e3:	49 b8 f8 f2 40 00 00 	movabs r8,0x40f2f8
  40f2ea:	00 00 00 
  40f2ed:	0f 05                	syscall 
  40f2ef:	90                   	nop
  40f2f0:	eb 0d                	jmp    40f2ff <cos_vm_kernel_page_create+0x10f>
  40f2f2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40f2f8:	b9 00 00 00 00       	mov    ecx,0x0
  40f2fd:	eb 05                	jmp    40f304 <cos_vm_kernel_page_create+0x114>
  40f2ff:	b9 01 00 00 00       	mov    ecx,0x1
  40f304:	5d                   	pop    rbp
  40f305:	5c                   	pop    rsp
		if (call_cap_op(ci->mi.pgtbl_cap, op, ret, 0, 0, 0)) goto error;
  40f306:	85 c0                	test   eax,eax
  40f308:	75 46                	jne    40f350 <cos_vm_kernel_page_create+0x160>
{ l->o = 0; }
  40f30a:	49 c7 82 60 01 00 00 	mov    QWORD PTR [r10+0x160],0x0
  40f311:	00 00 00 00 
	vaddr_t kmem = 0;

	kmem = __kmem_bump_alloc(ci);
	assert(kmem);
  40f315:	4d 85 ed             	test   r13,r13
  40f318:	74 41                	je     40f35b <cos_vm_kernel_page_create+0x16b>

	return kmem;
}
  40f31a:	48 83 c4 18          	add    rsp,0x18
  40f31e:	4c 89 e8             	mov    rax,r13
  40f321:	5b                   	pop    rbx
  40f322:	41 5c                	pop    r12
  40f324:	41 5d                	pop    r13
  40f326:	5d                   	pop    rbp
  40f327:	c3                   	ret    
  40f328:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40f32f:	00 
	if (ret >= *frontier || *frontier - ret > RETYPE_MEM_SIZE) {
  40f330:	48 89 d0             	mov    rax,rdx
  40f333:	4c 29 e8             	sub    rax,r13
  40f336:	48 3d 00 10 00 00    	cmp    rax,0x1000
  40f33c:	0f 86 6c ff ff ff    	jbe    40f2ae <cos_vm_kernel_page_create+0xbe>
  40f342:	e9 17 ff ff ff       	jmp    40f25e <cos_vm_kernel_page_create+0x6e>
  40f347:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40f34e:	00 00 
  40f350:	49 c7 82 60 01 00 00 	mov    QWORD PTR [r10+0x160],0x0
  40f357:	00 00 00 00 
  40f35b:	be 2f 00 00 00       	mov    esi,0x2f
  40f360:	bf c8 e9 41 00       	mov    edi,0x41e9c8
  40f365:	e8 16 b9 ff ff       	call   40ac80 <cos_print_str>
	assert(kmem);
  40f36a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f371:	00 00 00 00 
  40f375:	0f 0b                	ud2    
  40f377:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  40f37e:	00 00 
  40f380:	49 c7 82 60 01 00 00 	mov    QWORD PTR [r10+0x160],0x0
  40f387:	00 00 00 00 
}
  40f38b:	48 83 c4 18          	add    rsp,0x18
  40f38f:	4c 89 e8             	mov    rax,r13
  40f392:	5b                   	pop    rbx
  40f393:	41 5c                	pop    r12
  40f395:	41 5d                	pop    r13
  40f397:	5d                   	pop    rbp
  40f398:	c3                   	ret    
  40f399:	be 2e 00 00 00       	mov    esi,0x2e
  40f39e:	bf 50 e0 41 00       	mov    edi,0x41e050
  40f3a3:	e8 d8 b8 ff ff       	call   40ac80 <cos_print_str>
	assert(__ci);
  40f3a8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f3af:	00 00 00 00 
  40f3b3:	0f 0b                	ud2    
  40f3b5:	be 2e 00 00 00       	mov    esi,0x2e
  40f3ba:	bf 80 e0 41 00       	mov    edi,0x41e080
  40f3bf:	e8 bc b8 ff ff       	call   40ac80 <cos_print_str>
	assert(ci && ci == __compinfo_metacap(__ci));
  40f3c4:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f3cb:	00 00 00 00 
  40f3cf:	0f 0b                	ud2    
  40f3d1:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40f3d8:	00 00 00 00 
  40f3dc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000040f3e0 <cos_vm_vmcs_alloc>:

capid_t
cos_vm_vmcs_alloc(struct cos_compinfo *ci, vaddr_t kmem)
{
  40f3e0:	f3 0f 1e fa          	endbr64 
  40f3e4:	55                   	push   rbp
  40f3e5:	48 89 e5             	mov    rbp,rsp
  40f3e8:	41 57                	push   r15
  40f3ea:	41 56                	push   r14
  40f3ec:	41 55                	push   r13
  40f3ee:	49 89 fd             	mov    r13,rdi
  40f3f1:	41 54                	push   r12
  40f3f3:	53                   	push   rbx
  40f3f4:	48 89 f3             	mov    rbx,rsi
  40f3f7:	48 83 ec 18          	sub    rsp,0x18
	return ci->memsrc;
  40f3fb:	4c 8b a7 08 01 00 00 	mov    r12,QWORD PTR [rdi+0x108]
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  40f402:	0f 01 f9             	rdtscp 
	return (long)coreid;
  40f405:	48 89 cf             	mov    rdi,rcx
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f408:	49 8d 94 24 58 01 00 	lea    rdx,[r12+0x158]
  40f40f:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  40f410:	be 01 00 00 00       	mov    esi,0x1
  40f415:	31 c9                	xor    ecx,ecx
  40f417:	81 e7 ff 0f 00 00    	and    edi,0xfff
		frontier = &ci->cap64_frontier[cos_cpuid()];
  40f41d:	4d 8d b4 fc a8 00 00 	lea    r14,[r12+rdi*8+0xa8]
  40f424:	00 
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f425:	0f 1f 00             	nop    DWORD PTR [rax]
        __asm__ __volatile__("lock " PS_CAS_STR
  40f428:	48 89 c8             	mov    rax,rcx
  40f42b:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40f430:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f433:	84 c0                	test   al,al
  40f435:	74 f1                	je     40f428 <cos_vm_vmcs_alloc+0x48>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40f437:	4c 8d 7f 14          	lea    r15,[rdi+0x14]
  40f43b:	41 f6 84 fc a8 00 00 	test   BYTE PTR [r12+rdi*8+0xa8],0x3
  40f442:	00 03 
  40f444:	0f 84 a6 00 00 00    	je     40f4f0 <cos_vm_vmcs_alloc+0x110>
        __asm__ __volatile__("lock " PS_FAA_STR
  40f44a:	bf 04 00 00 00       	mov    edi,0x4
  40f44f:	f0 49 0f c1 3e       	lock xadd QWORD PTR [r14],rdi
{ l->o = 0; }
  40f454:	49 c7 84 24 58 01 00 	mov    QWORD PTR [r12+0x158],0x0
  40f45b:	00 00 00 00 00 
	capid_t cap = 0;

	cap = __capid_bump_alloc(__compinfo_metacap(ci), CAP_VM_VMCS);

	if (cap == 0 || kmem == 0) {
  40f460:	48 85 ff             	test   rdi,rdi
  40f463:	0f 84 9f 00 00 00    	je     40f508 <cos_vm_vmcs_alloc+0x128>
  40f469:	48 85 db             	test   rbx,rbx
  40f46c:	0f 84 96 00 00 00    	je     40f508 <cos_vm_vmcs_alloc+0x128>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f472:	41 8b 45 08          	mov    eax,DWORD PTR [r13+0x8]
		assert(0);
	}

	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_VMCS_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  40f476:	49 8b 95 08 01 00 00 	mov    rdx,QWORD PTR [r13+0x108]
	__asm__ __volatile__(
  40f47d:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f481:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40f484:	48 8b b2 40 01 00 00 	mov    rsi,QWORD PTR [rdx+0x140]
  40f48b:	31 d2                	xor    edx,edx
	cap_no += op;
  40f48d:	05 07 00 01 00       	add    eax,0x10007
	__asm__ __volatile__(
  40f492:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40f495:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40f499:	48 89 cd             	mov    rbp,rcx
  40f49c:	49 b8 b0 f4 40 00 00 	movabs r8,0x40f4b0
  40f4a3:	00 00 00 
  40f4a6:	0f 05                	syscall 
  40f4a8:	eb 0d                	jmp    40f4b7 <cos_vm_vmcs_alloc+0xd7>
  40f4aa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40f4b0:	b9 00 00 00 00       	mov    ecx,0x0
  40f4b5:	eb 05                	jmp    40f4bc <cos_vm_vmcs_alloc+0xdc>
  40f4b7:	b9 01 00 00 00       	mov    ecx,0x1
  40f4bc:	5d                   	pop    rbp
  40f4bd:	5c                   	pop    rsp
  40f4be:	85 c0                	test   eax,eax
  40f4c0:	75 12                	jne    40f4d4 <cos_vm_vmcs_alloc+0xf4>

	return cap;
}
  40f4c2:	48 83 c4 18          	add    rsp,0x18
  40f4c6:	48 89 f8             	mov    rax,rdi
  40f4c9:	5b                   	pop    rbx
  40f4ca:	41 5c                	pop    r12
  40f4cc:	41 5d                	pop    r13
  40f4ce:	41 5e                	pop    r14
  40f4d0:	41 5f                	pop    r15
  40f4d2:	5d                   	pop    rbp
  40f4d3:	c3                   	ret    
  40f4d4:	be 1c 00 00 00       	mov    esi,0x1c
  40f4d9:	bf 28 ea 41 00       	mov    edi,0x41ea28
  40f4de:	e8 9d b7 ff ff       	call   40ac80 <cos_print_str>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_VMCS_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  40f4e3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f4ea:	00 00 00 00 
  40f4ee:	0f 0b                	ud2    
		if (__capid_captbl_check_expand(ci)) goto error;
  40f4f0:	4c 89 e7             	mov    rdi,r12
  40f4f3:	e8 48 d4 ff ff       	call   40c940 <__capid_captbl_check_expand>
  40f4f8:	85 c0                	test   eax,eax
  40f4fa:	74 28                	je     40f524 <cos_vm_vmcs_alloc+0x144>
  40f4fc:	49 c7 84 24 58 01 00 	mov    QWORD PTR [r12+0x158],0x0
  40f503:	00 00 00 00 00 
  40f508:	be 2f 00 00 00       	mov    esi,0x2f
  40f50d:	bf f8 e9 41 00       	mov    edi,0x41e9f8
  40f512:	e8 69 b7 ff ff       	call   40ac80 <cos_print_str>
		assert(0);
  40f517:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f51e:	00 00 00 00 
  40f522:	0f 0b                	ud2    
        __asm__ __volatile__("lock " PS_FAA_STR
  40f524:	b8 04 00 00 00       	mov    eax,0x4
  40f529:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40f530:	4b 89 44 fc 08       	mov    QWORD PTR [r12+r15*8+0x8],rax
  40f535:	e9 10 ff ff ff       	jmp    40f44a <cos_vm_vmcs_alloc+0x6a>
  40f53a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000040f540 <cos_vm_msr_bitmap_alloc>:

capid_t
cos_vm_msr_bitmap_alloc(struct cos_compinfo *ci, vaddr_t kmem)
{
  40f540:	f3 0f 1e fa          	endbr64 
  40f544:	55                   	push   rbp
  40f545:	48 89 e5             	mov    rbp,rsp
  40f548:	41 57                	push   r15
  40f54a:	41 56                	push   r14
  40f54c:	41 55                	push   r13
  40f54e:	49 89 fd             	mov    r13,rdi
  40f551:	41 54                	push   r12
  40f553:	53                   	push   rbx
  40f554:	48 89 f3             	mov    rbx,rsi
  40f557:	48 83 ec 18          	sub    rsp,0x18
	return ci->memsrc;
  40f55b:	4c 8b a7 08 01 00 00 	mov    r12,QWORD PTR [rdi+0x108]
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  40f562:	0f 01 f9             	rdtscp 
	return (long)coreid;
  40f565:	48 89 cf             	mov    rdi,rcx
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f568:	49 8d 94 24 58 01 00 	lea    rdx,[r12+0x158]
  40f56f:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  40f570:	be 01 00 00 00       	mov    esi,0x1
  40f575:	31 c9                	xor    ecx,ecx
  40f577:	81 e7 ff 0f 00 00    	and    edi,0xfff
		frontier = &ci->cap64_frontier[cos_cpuid()];
  40f57d:	4d 8d b4 fc a8 00 00 	lea    r14,[r12+rdi*8+0xa8]
  40f584:	00 
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f585:	0f 1f 00             	nop    DWORD PTR [rax]
        __asm__ __volatile__("lock " PS_CAS_STR
  40f588:	48 89 c8             	mov    rax,rcx
  40f58b:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40f590:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f593:	84 c0                	test   al,al
  40f595:	74 f1                	je     40f588 <cos_vm_msr_bitmap_alloc+0x48>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40f597:	4c 8d 7f 14          	lea    r15,[rdi+0x14]
  40f59b:	41 f6 84 fc a8 00 00 	test   BYTE PTR [r12+rdi*8+0xa8],0x3
  40f5a2:	00 03 
  40f5a4:	0f 84 a6 00 00 00    	je     40f650 <cos_vm_msr_bitmap_alloc+0x110>
        __asm__ __volatile__("lock " PS_FAA_STR
  40f5aa:	bf 04 00 00 00       	mov    edi,0x4
  40f5af:	f0 49 0f c1 3e       	lock xadd QWORD PTR [r14],rdi
{ l->o = 0; }
  40f5b4:	49 c7 84 24 58 01 00 	mov    QWORD PTR [r12+0x158],0x0
  40f5bb:	00 00 00 00 00 
	capid_t cap = 0;

	cap = __capid_bump_alloc(__compinfo_metacap(ci), CAP_VM_MSR_BITMAP);

	if (cap == 0 || kmem == 0) {
  40f5c0:	48 85 ff             	test   rdi,rdi
  40f5c3:	0f 84 9f 00 00 00    	je     40f668 <cos_vm_msr_bitmap_alloc+0x128>
  40f5c9:	48 85 db             	test   rbx,rbx
  40f5cc:	0f 84 96 00 00 00    	je     40f668 <cos_vm_msr_bitmap_alloc+0x128>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f5d2:	41 8b 45 08          	mov    eax,DWORD PTR [r13+0x8]
		assert(0);
	}

	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_MSR_BITMAP_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  40f5d6:	49 8b 95 08 01 00 00 	mov    rdx,QWORD PTR [r13+0x108]
	__asm__ __volatile__(
  40f5dd:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f5e1:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40f5e4:	48 8b b2 40 01 00 00 	mov    rsi,QWORD PTR [rdx+0x140]
  40f5eb:	31 d2                	xor    edx,edx
	cap_no += op;
  40f5ed:	05 08 00 01 00       	add    eax,0x10008
	__asm__ __volatile__(
  40f5f2:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40f5f5:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40f5f9:	48 89 cd             	mov    rbp,rcx
  40f5fc:	49 b8 10 f6 40 00 00 	movabs r8,0x40f610
  40f603:	00 00 00 
  40f606:	0f 05                	syscall 
  40f608:	eb 0d                	jmp    40f617 <cos_vm_msr_bitmap_alloc+0xd7>
  40f60a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40f610:	b9 00 00 00 00       	mov    ecx,0x0
  40f615:	eb 05                	jmp    40f61c <cos_vm_msr_bitmap_alloc+0xdc>
  40f617:	b9 01 00 00 00       	mov    ecx,0x1
  40f61c:	5d                   	pop    rbp
  40f61d:	5c                   	pop    rsp
  40f61e:	85 c0                	test   eax,eax
  40f620:	75 12                	jne    40f634 <cos_vm_msr_bitmap_alloc+0xf4>

	return cap;
}
  40f622:	48 83 c4 18          	add    rsp,0x18
  40f626:	48 89 f8             	mov    rax,rdi
  40f629:	5b                   	pop    rbx
  40f62a:	41 5c                	pop    r12
  40f62c:	41 5d                	pop    r13
  40f62e:	41 5e                	pop    r14
  40f630:	41 5f                	pop    r15
  40f632:	5d                   	pop    rbp
  40f633:	c3                   	ret    
  40f634:	be 1c 00 00 00       	mov    esi,0x1c
  40f639:	bf 78 ea 41 00       	mov    edi,0x41ea78
  40f63e:	e8 3d b6 ff ff       	call   40ac80 <cos_print_str>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_MSR_BITMAP_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  40f643:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f64a:	00 00 00 00 
  40f64e:	0f 0b                	ud2    
		if (__capid_captbl_check_expand(ci)) goto error;
  40f650:	4c 89 e7             	mov    rdi,r12
  40f653:	e8 e8 d2 ff ff       	call   40c940 <__capid_captbl_check_expand>
  40f658:	85 c0                	test   eax,eax
  40f65a:	74 28                	je     40f684 <cos_vm_msr_bitmap_alloc+0x144>
  40f65c:	49 c7 84 24 58 01 00 	mov    QWORD PTR [r12+0x158],0x0
  40f663:	00 00 00 00 00 
  40f668:	be 2f 00 00 00       	mov    esi,0x2f
  40f66d:	bf 48 ea 41 00       	mov    edi,0x41ea48
  40f672:	e8 09 b6 ff ff       	call   40ac80 <cos_print_str>
		assert(0);
  40f677:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f67e:	00 00 00 00 
  40f682:	0f 0b                	ud2    
        __asm__ __volatile__("lock " PS_FAA_STR
  40f684:	b8 04 00 00 00       	mov    eax,0x4
  40f689:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40f690:	4b 89 44 fc 08       	mov    QWORD PTR [r12+r15*8+0x8],rax
  40f695:	e9 10 ff ff ff       	jmp    40f5aa <cos_vm_msr_bitmap_alloc+0x6a>
  40f69a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000040f6a0 <cos_vm_lapic_alloc>:

capid_t
cos_vm_lapic_alloc(struct cos_compinfo *ci, vaddr_t kmem)
{
  40f6a0:	f3 0f 1e fa          	endbr64 
  40f6a4:	55                   	push   rbp
  40f6a5:	48 89 e5             	mov    rbp,rsp
  40f6a8:	41 57                	push   r15
  40f6aa:	41 56                	push   r14
  40f6ac:	41 55                	push   r13
  40f6ae:	49 89 fd             	mov    r13,rdi
  40f6b1:	41 54                	push   r12
  40f6b3:	53                   	push   rbx
  40f6b4:	48 89 f3             	mov    rbx,rsi
  40f6b7:	48 83 ec 18          	sub    rsp,0x18
	return ci->memsrc;
  40f6bb:	4c 8b a7 08 01 00 00 	mov    r12,QWORD PTR [rdi+0x108]
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  40f6c2:	0f 01 f9             	rdtscp 
	return (long)coreid;
  40f6c5:	48 89 cf             	mov    rdi,rcx
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f6c8:	49 8d 94 24 58 01 00 	lea    rdx,[r12+0x158]
  40f6cf:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  40f6d0:	be 01 00 00 00       	mov    esi,0x1
  40f6d5:	31 c9                	xor    ecx,ecx
  40f6d7:	81 e7 ff 0f 00 00    	and    edi,0xfff
		frontier = &ci->cap64_frontier[cos_cpuid()];
  40f6dd:	4d 8d b4 fc a8 00 00 	lea    r14,[r12+rdi*8+0xa8]
  40f6e4:	00 
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f6e5:	0f 1f 00             	nop    DWORD PTR [rax]
        __asm__ __volatile__("lock " PS_CAS_STR
  40f6e8:	48 89 c8             	mov    rax,rcx
  40f6eb:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40f6f0:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f6f3:	84 c0                	test   al,al
  40f6f5:	74 f1                	je     40f6e8 <cos_vm_lapic_alloc+0x48>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40f6f7:	4c 8d 7f 14          	lea    r15,[rdi+0x14]
  40f6fb:	41 f6 84 fc a8 00 00 	test   BYTE PTR [r12+rdi*8+0xa8],0x3
  40f702:	00 03 
  40f704:	0f 84 a6 00 00 00    	je     40f7b0 <cos_vm_lapic_alloc+0x110>
        __asm__ __volatile__("lock " PS_FAA_STR
  40f70a:	bf 04 00 00 00       	mov    edi,0x4
  40f70f:	f0 49 0f c1 3e       	lock xadd QWORD PTR [r14],rdi
{ l->o = 0; }
  40f714:	49 c7 84 24 58 01 00 	mov    QWORD PTR [r12+0x158],0x0
  40f71b:	00 00 00 00 00 
	capid_t cap = 0;

	cap = __capid_bump_alloc(__compinfo_metacap(ci), CAP_VM_LAPIC);
	if (cap == 0 || kmem == 0) {
  40f720:	48 85 ff             	test   rdi,rdi
  40f723:	0f 84 9f 00 00 00    	je     40f7c8 <cos_vm_lapic_alloc+0x128>
  40f729:	48 85 db             	test   rbx,rbx
  40f72c:	0f 84 96 00 00 00    	je     40f7c8 <cos_vm_lapic_alloc+0x128>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f732:	41 8b 45 08          	mov    eax,DWORD PTR [r13+0x8]
		assert(0);
	}

	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_LAPIC_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  40f736:	49 8b 95 08 01 00 00 	mov    rdx,QWORD PTR [r13+0x108]
	__asm__ __volatile__(
  40f73d:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f741:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40f744:	48 8b b2 40 01 00 00 	mov    rsi,QWORD PTR [rdx+0x140]
  40f74b:	31 d2                	xor    edx,edx
	cap_no += op;
  40f74d:	05 0a 00 01 00       	add    eax,0x1000a
	__asm__ __volatile__(
  40f752:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40f755:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40f759:	48 89 cd             	mov    rbp,rcx
  40f75c:	49 b8 70 f7 40 00 00 	movabs r8,0x40f770
  40f763:	00 00 00 
  40f766:	0f 05                	syscall 
  40f768:	eb 0d                	jmp    40f777 <cos_vm_lapic_alloc+0xd7>
  40f76a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40f770:	b9 00 00 00 00       	mov    ecx,0x0
  40f775:	eb 05                	jmp    40f77c <cos_vm_lapic_alloc+0xdc>
  40f777:	b9 01 00 00 00       	mov    ecx,0x1
  40f77c:	5d                   	pop    rbp
  40f77d:	5c                   	pop    rsp
  40f77e:	85 c0                	test   eax,eax
  40f780:	75 12                	jne    40f794 <cos_vm_lapic_alloc+0xf4>

	return cap;

}
  40f782:	48 83 c4 18          	add    rsp,0x18
  40f786:	48 89 f8             	mov    rax,rdi
  40f789:	5b                   	pop    rbx
  40f78a:	41 5c                	pop    r12
  40f78c:	41 5d                	pop    r13
  40f78e:	41 5e                	pop    r14
  40f790:	41 5f                	pop    r15
  40f792:	5d                   	pop    rbp
  40f793:	c3                   	ret    
  40f794:	be 1c 00 00 00       	mov    esi,0x1c
  40f799:	bf c8 ea 41 00       	mov    edi,0x41eac8
  40f79e:	e8 dd b4 ff ff       	call   40ac80 <cos_print_str>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_LAPIC_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  40f7a3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f7aa:	00 00 00 00 
  40f7ae:	0f 0b                	ud2    
		if (__capid_captbl_check_expand(ci)) goto error;
  40f7b0:	4c 89 e7             	mov    rdi,r12
  40f7b3:	e8 88 d1 ff ff       	call   40c940 <__capid_captbl_check_expand>
  40f7b8:	85 c0                	test   eax,eax
  40f7ba:	74 28                	je     40f7e4 <cos_vm_lapic_alloc+0x144>
  40f7bc:	49 c7 84 24 58 01 00 	mov    QWORD PTR [r12+0x158],0x0
  40f7c3:	00 00 00 00 00 
  40f7c8:	be 2f 00 00 00       	mov    esi,0x2f
  40f7cd:	bf 98 ea 41 00       	mov    edi,0x41ea98
  40f7d2:	e8 a9 b4 ff ff       	call   40ac80 <cos_print_str>
		assert(0);
  40f7d7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f7de:	00 00 00 00 
  40f7e2:	0f 0b                	ud2    
        __asm__ __volatile__("lock " PS_FAA_STR
  40f7e4:	b8 04 00 00 00       	mov    eax,0x4
  40f7e9:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40f7f0:	4b 89 44 fc 08       	mov    QWORD PTR [r12+r15*8+0x8],rax
  40f7f5:	e9 10 ff ff ff       	jmp    40f70a <cos_vm_lapic_alloc+0x6a>
  40f7fa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000040f800 <cos_vm_shared_region_alloc>:

capid_t
cos_vm_shared_region_alloc(struct cos_compinfo *ci, vaddr_t kmem)
{
  40f800:	f3 0f 1e fa          	endbr64 
  40f804:	55                   	push   rbp
  40f805:	48 89 e5             	mov    rbp,rsp
  40f808:	41 57                	push   r15
  40f80a:	41 56                	push   r14
  40f80c:	41 55                	push   r13
  40f80e:	49 89 fd             	mov    r13,rdi
  40f811:	41 54                	push   r12
  40f813:	53                   	push   rbx
  40f814:	48 89 f3             	mov    rbx,rsi
  40f817:	48 83 ec 18          	sub    rsp,0x18
	return ci->memsrc;
  40f81b:	4c 8b a7 08 01 00 00 	mov    r12,QWORD PTR [rdi+0x108]
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  40f822:	0f 01 f9             	rdtscp 
	return (long)coreid;
  40f825:	48 89 cf             	mov    rdi,rcx
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f828:	49 8d 94 24 58 01 00 	lea    rdx,[r12+0x158]
  40f82f:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  40f830:	be 01 00 00 00       	mov    esi,0x1
  40f835:	31 c9                	xor    ecx,ecx
  40f837:	81 e7 ff 0f 00 00    	and    edi,0xfff
		frontier = &ci->cap64_frontier[cos_cpuid()];
  40f83d:	4d 8d b4 fc a8 00 00 	lea    r14,[r12+rdi*8+0xa8]
  40f844:	00 
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f845:	0f 1f 00             	nop    DWORD PTR [rax]
        __asm__ __volatile__("lock " PS_CAS_STR
  40f848:	48 89 c8             	mov    rax,rcx
  40f84b:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40f850:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f853:	84 c0                	test   al,al
  40f855:	74 f1                	je     40f848 <cos_vm_shared_region_alloc+0x48>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40f857:	4c 8d 7f 14          	lea    r15,[rdi+0x14]
  40f85b:	41 f6 84 fc a8 00 00 	test   BYTE PTR [r12+rdi*8+0xa8],0x3
  40f862:	00 03 
  40f864:	0f 84 a6 00 00 00    	je     40f910 <cos_vm_shared_region_alloc+0x110>
        __asm__ __volatile__("lock " PS_FAA_STR
  40f86a:	bf 04 00 00 00       	mov    edi,0x4
  40f86f:	f0 49 0f c1 3e       	lock xadd QWORD PTR [r14],rdi
{ l->o = 0; }
  40f874:	49 c7 84 24 58 01 00 	mov    QWORD PTR [r12+0x158],0x0
  40f87b:	00 00 00 00 00 
	capid_t cap = 0;

	cap = __capid_bump_alloc(__compinfo_metacap(ci), CAP_VM_SHARED_MEM);
	if (cap == 0 || kmem == 0) {
  40f880:	48 85 ff             	test   rdi,rdi
  40f883:	0f 84 9f 00 00 00    	je     40f928 <cos_vm_shared_region_alloc+0x128>
  40f889:	48 85 db             	test   rbx,rbx
  40f88c:	0f 84 96 00 00 00    	je     40f928 <cos_vm_shared_region_alloc+0x128>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f892:	41 8b 45 08          	mov    eax,DWORD PTR [r13+0x8]
		assert(0);
	}

	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_SHARED_MEM_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  40f896:	49 8b 95 08 01 00 00 	mov    rdx,QWORD PTR [r13+0x108]
	__asm__ __volatile__(
  40f89d:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f8a1:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40f8a4:	48 8b b2 40 01 00 00 	mov    rsi,QWORD PTR [rdx+0x140]
  40f8ab:	31 d2                	xor    edx,edx
	cap_no += op;
  40f8ad:	05 0b 00 01 00       	add    eax,0x1000b
	__asm__ __volatile__(
  40f8b2:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40f8b5:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40f8b9:	48 89 cd             	mov    rbp,rcx
  40f8bc:	49 b8 d0 f8 40 00 00 	movabs r8,0x40f8d0
  40f8c3:	00 00 00 
  40f8c6:	0f 05                	syscall 
  40f8c8:	eb 0d                	jmp    40f8d7 <cos_vm_shared_region_alloc+0xd7>
  40f8ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40f8d0:	b9 00 00 00 00       	mov    ecx,0x0
  40f8d5:	eb 05                	jmp    40f8dc <cos_vm_shared_region_alloc+0xdc>
  40f8d7:	b9 01 00 00 00       	mov    ecx,0x1
  40f8dc:	5d                   	pop    rbp
  40f8dd:	5c                   	pop    rsp
  40f8de:	85 c0                	test   eax,eax
  40f8e0:	75 12                	jne    40f8f4 <cos_vm_shared_region_alloc+0xf4>

	return cap;

}
  40f8e2:	48 83 c4 18          	add    rsp,0x18
  40f8e6:	48 89 f8             	mov    rax,rdi
  40f8e9:	5b                   	pop    rbx
  40f8ea:	41 5c                	pop    r12
  40f8ec:	41 5d                	pop    r13
  40f8ee:	41 5e                	pop    r14
  40f8f0:	41 5f                	pop    r15
  40f8f2:	5d                   	pop    rbp
  40f8f3:	c3                   	ret    
  40f8f4:	be 1c 00 00 00       	mov    esi,0x1c
  40f8f9:	bf 18 eb 41 00       	mov    edi,0x41eb18
  40f8fe:	e8 7d b3 ff ff       	call   40ac80 <cos_print_str>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_SHARED_MEM_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  40f903:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f90a:	00 00 00 00 
  40f90e:	0f 0b                	ud2    
		if (__capid_captbl_check_expand(ci)) goto error;
  40f910:	4c 89 e7             	mov    rdi,r12
  40f913:	e8 28 d0 ff ff       	call   40c940 <__capid_captbl_check_expand>
  40f918:	85 c0                	test   eax,eax
  40f91a:	74 28                	je     40f944 <cos_vm_shared_region_alloc+0x144>
  40f91c:	49 c7 84 24 58 01 00 	mov    QWORD PTR [r12+0x158],0x0
  40f923:	00 00 00 00 00 
  40f928:	be 2f 00 00 00       	mov    esi,0x2f
  40f92d:	bf e8 ea 41 00       	mov    edi,0x41eae8
  40f932:	e8 49 b3 ff ff       	call   40ac80 <cos_print_str>
		assert(0);
  40f937:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40f93e:	00 00 00 00 
  40f942:	0f 0b                	ud2    
        __asm__ __volatile__("lock " PS_FAA_STR
  40f944:	b8 04 00 00 00       	mov    eax,0x4
  40f949:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40f950:	4b 89 44 fc 08       	mov    QWORD PTR [r12+r15*8+0x8],rax
  40f955:	e9 10 ff ff ff       	jmp    40f86a <cos_vm_shared_region_alloc+0x6a>
  40f95a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000040f960 <cos_vm_lapic_access_alloc>:

capid_t
cos_vm_lapic_access_alloc(struct cos_compinfo *ci, vaddr_t kmem)
{
  40f960:	f3 0f 1e fa          	endbr64 
  40f964:	55                   	push   rbp
  40f965:	48 89 e5             	mov    rbp,rsp
  40f968:	41 57                	push   r15
  40f96a:	41 56                	push   r14
  40f96c:	41 55                	push   r13
  40f96e:	49 89 fd             	mov    r13,rdi
  40f971:	41 54                	push   r12
  40f973:	53                   	push   rbx
  40f974:	48 89 f3             	mov    rbx,rsi
  40f977:	48 83 ec 18          	sub    rsp,0x18
	return ci->memsrc;
  40f97b:	4c 8b a7 08 01 00 00 	mov    r12,QWORD PTR [rdi+0x108]
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  40f982:	0f 01 f9             	rdtscp 
	return (long)coreid;
  40f985:	48 89 cf             	mov    rdi,rcx
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f988:	49 8d 94 24 58 01 00 	lea    rdx,[r12+0x158]
  40f98f:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  40f990:	be 01 00 00 00       	mov    esi,0x1
  40f995:	31 c9                	xor    ecx,ecx
  40f997:	81 e7 ff 0f 00 00    	and    edi,0xfff
		frontier = &ci->cap64_frontier[cos_cpuid()];
  40f99d:	4d 8d b4 fc a8 00 00 	lea    r14,[r12+rdi*8+0xa8]
  40f9a4:	00 
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f9a5:	0f 1f 00             	nop    DWORD PTR [rax]
        __asm__ __volatile__("lock " PS_CAS_STR
  40f9a8:	48 89 c8             	mov    rax,rcx
  40f9ab:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40f9b0:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40f9b3:	84 c0                	test   al,al
  40f9b5:	74 f1                	je     40f9a8 <cos_vm_lapic_access_alloc+0x48>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40f9b7:	4c 8d 7f 14          	lea    r15,[rdi+0x14]
  40f9bb:	41 f6 84 fc a8 00 00 	test   BYTE PTR [r12+rdi*8+0xa8],0x3
  40f9c2:	00 03 
  40f9c4:	0f 84 a6 00 00 00    	je     40fa70 <cos_vm_lapic_access_alloc+0x110>
        __asm__ __volatile__("lock " PS_FAA_STR
  40f9ca:	bf 04 00 00 00       	mov    edi,0x4
  40f9cf:	f0 49 0f c1 3e       	lock xadd QWORD PTR [r14],rdi
{ l->o = 0; }
  40f9d4:	49 c7 84 24 58 01 00 	mov    QWORD PTR [r12+0x158],0x0
  40f9db:	00 00 00 00 00 
	capid_t cap = 0;

	cap = __capid_bump_alloc(__compinfo_metacap(ci), CAP_VM_LAPIC_ACCESS);
	if (cap == 0 || kmem == 0) {
  40f9e0:	48 85 ff             	test   rdi,rdi
  40f9e3:	0f 84 9f 00 00 00    	je     40fa88 <cos_vm_lapic_access_alloc+0x128>
  40f9e9:	48 85 db             	test   rbx,rbx
  40f9ec:	0f 84 96 00 00 00    	je     40fa88 <cos_vm_lapic_access_alloc+0x128>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40f9f2:	41 8b 45 08          	mov    eax,DWORD PTR [r13+0x8]
		assert(0);
	}

	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_LAPIC_ACCESS_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  40f9f6:	49 8b 95 08 01 00 00 	mov    rdx,QWORD PTR [r13+0x108]
	__asm__ __volatile__(
  40f9fd:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40fa01:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40fa04:	48 8b b2 40 01 00 00 	mov    rsi,QWORD PTR [rdx+0x140]
  40fa0b:	31 d2                	xor    edx,edx
	cap_no += op;
  40fa0d:	05 09 00 01 00       	add    eax,0x10009
	__asm__ __volatile__(
  40fa12:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40fa15:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40fa19:	48 89 cd             	mov    rbp,rcx
  40fa1c:	49 b8 30 fa 40 00 00 	movabs r8,0x40fa30
  40fa23:	00 00 00 
  40fa26:	0f 05                	syscall 
  40fa28:	eb 0d                	jmp    40fa37 <cos_vm_lapic_access_alloc+0xd7>
  40fa2a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40fa30:	b9 00 00 00 00       	mov    ecx,0x0
  40fa35:	eb 05                	jmp    40fa3c <cos_vm_lapic_access_alloc+0xdc>
  40fa37:	b9 01 00 00 00       	mov    ecx,0x1
  40fa3c:	5d                   	pop    rbp
  40fa3d:	5c                   	pop    rsp
  40fa3e:	85 c0                	test   eax,eax
  40fa40:	75 12                	jne    40fa54 <cos_vm_lapic_access_alloc+0xf4>

	return cap;

}
  40fa42:	48 83 c4 18          	add    rsp,0x18
  40fa46:	48 89 f8             	mov    rax,rdi
  40fa49:	5b                   	pop    rbx
  40fa4a:	41 5c                	pop    r12
  40fa4c:	41 5d                	pop    r13
  40fa4e:	41 5e                	pop    r14
  40fa50:	41 5f                	pop    r15
  40fa52:	5d                   	pop    rbp
  40fa53:	c3                   	ret    
  40fa54:	be 1c 00 00 00       	mov    esi,0x1c
  40fa59:	bf 68 eb 41 00       	mov    edi,0x41eb68
  40fa5e:	e8 1d b2 ff ff       	call   40ac80 <cos_print_str>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_LAPIC_ACCESS_ACTIVATE, kmem, __compinfo_metacap(ci)->mi.pgtbl_cap, cap, 0)) BUG();
  40fa63:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40fa6a:	00 00 00 00 
  40fa6e:	0f 0b                	ud2    
		if (__capid_captbl_check_expand(ci)) goto error;
  40fa70:	4c 89 e7             	mov    rdi,r12
  40fa73:	e8 c8 ce ff ff       	call   40c940 <__capid_captbl_check_expand>
  40fa78:	85 c0                	test   eax,eax
  40fa7a:	74 28                	je     40faa4 <cos_vm_lapic_access_alloc+0x144>
  40fa7c:	49 c7 84 24 58 01 00 	mov    QWORD PTR [r12+0x158],0x0
  40fa83:	00 00 00 00 00 
  40fa88:	be 2f 00 00 00       	mov    esi,0x2f
  40fa8d:	bf 38 eb 41 00       	mov    edi,0x41eb38
  40fa92:	e8 e9 b1 ff ff       	call   40ac80 <cos_print_str>
		assert(0);
  40fa97:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40fa9e:	00 00 00 00 
  40faa2:	0f 0b                	ud2    
        __asm__ __volatile__("lock " PS_FAA_STR
  40faa4:	b8 04 00 00 00       	mov    eax,0x4
  40faa9:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40fab0:	4b 89 44 fc 08       	mov    QWORD PTR [r12+r15*8+0x8],rax
  40fab5:	e9 10 ff ff ff       	jmp    40f9ca <cos_vm_lapic_access_alloc+0x6a>
  40faba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000040fac0 <cos_vm_vmcb_alloc>:

capid_t
cos_vm_vmcb_alloc(struct cos_compinfo *ci, vm_vmcscap_t vmcs_cap, vm_msrbitmapcap_t msr_bitmap_cap, vm_lapicaccesscap_t lapic_access_cap, vm_lapiccap_t lapic_cap, vm_shared_mem_t shared_mem_cap, thdcap_t handler_cap, word_t vpid)
{
  40fac0:	f3 0f 1e fa          	endbr64 
  40fac4:	55                   	push   rbp
  40fac5:	48 89 e5             	mov    rbp,rsp
  40fac8:	41 57                	push   r15
  40faca:	4d 89 c7             	mov    r15,r8
  40facd:	41 56                	push   r14
  40facf:	49 89 ce             	mov    r14,rcx
  40fad2:	41 55                	push   r13
  40fad4:	49 89 fd             	mov    r13,rdi
  40fad7:	41 54                	push   r12
  40fad9:	49 89 f4             	mov    r12,rsi
  40fadc:	53                   	push   rbx
  40fadd:	48 89 d3             	mov    rbx,rdx
  40fae0:	48 83 ec 38          	sub    rsp,0x38
	return ci->memsrc;
  40fae4:	48 8b b7 08 01 00 00 	mov    rsi,QWORD PTR [rdi+0x108]
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  40faeb:	0f 01 f9             	rdtscp 
	return (long)coreid;
  40faee:	49 89 ca             	mov    r10,rcx
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40faf1:	48 8d 96 58 01 00 00 	lea    rdx,[rsi+0x158]
        __asm__ __volatile__("lock " PS_CAS_STR
  40faf8:	bf 01 00 00 00       	mov    edi,0x1
  40fafd:	31 c9                	xor    ecx,ecx
  40faff:	41 81 e2 ff 0f 00 00 	and    r10d,0xfff
		frontier = &ci->cap64_frontier[cos_cpuid()];
  40fb06:	4e 8d 84 d6 a8 00 00 	lea    r8,[rsi+r10*8+0xa8]
  40fb0d:	00 
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40fb0e:	66 90                	xchg   ax,ax
        __asm__ __volatile__("lock " PS_CAS_STR
  40fb10:	48 89 c8             	mov    rax,rcx
  40fb13:	f0 48 0f b1 3a       	lock cmpxchg QWORD PTR [rdx],rdi
  40fb18:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40fb1b:	84 c0                	test   al,al
  40fb1d:	74 f1                	je     40fb10 <cos_vm_vmcb_alloc+0x50>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40fb1f:	49 8d 52 14          	lea    rdx,[r10+0x14]
  40fb23:	42 f6 84 d6 a8 00 00 	test   BYTE PTR [rsi+r10*8+0xa8],0x3
  40fb2a:	00 03 
  40fb2c:	0f 84 c6 00 00 00    	je     40fbf8 <cos_vm_vmcb_alloc+0x138>
        __asm__ __volatile__("lock " PS_FAA_STR
  40fb32:	41 ba 04 00 00 00    	mov    r10d,0x4
  40fb38:	f0 4d 0f c1 10       	lock xadd QWORD PTR [r8],r10
{ l->o = 0; }
  40fb3d:	48 c7 86 58 01 00 00 	mov    QWORD PTR [rsi+0x158],0x0
  40fb44:	00 00 00 00 
	capid_t cap = 0;
	word_t arg1 = 0;
	word_t arg2 = 0;

	cap = __capid_bump_alloc(__compinfo_metacap(ci), CAP_VM_VMCB);
	if (cap == 0) {
  40fb48:	4d 85 d2             	test   r10,r10
  40fb4b:	0f 84 de 00 00 00    	je     40fc2f <cos_vm_vmcb_alloc+0x16f>
		assert(0);
	}

	arg1 = cap | vmcs_cap << (16 * 1) | msr_bitmap_cap << (16 * 2) |  lapic_access_cap << (16 * 3);
	arg2 = lapic_cap | shared_mem_cap << (16 * 1) | handler_cap << (16 * 2) | vpid << (16 * 3);
  40fb51:	48 8b 75 10          	mov    rsi,QWORD PTR [rbp+0x10]
  40fb55:	48 8b 55 18          	mov    rdx,QWORD PTR [rbp+0x18]
	arg1 = cap | vmcs_cap << (16 * 1) | msr_bitmap_cap << (16 * 2) |  lapic_access_cap << (16 * 3);
  40fb59:	48 c1 e3 20          	shl    rbx,0x20
  40fb5d:	49 c1 e6 30          	shl    r14,0x30

	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_VMCB_ACTIVATE, arg1, arg2, 0, 0)) BUG();
  40fb61:	49 8b 45 08          	mov    rax,QWORD PTR [r13+0x8]
	arg1 = cap | vmcs_cap << (16 * 1) | msr_bitmap_cap << (16 * 2) |  lapic_access_cap << (16 * 3);
  40fb65:	4c 09 f3             	or     rbx,r14
  40fb68:	49 c1 e4 10          	shl    r12,0x10
	__asm__ __volatile__(
  40fb6c:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
	arg2 = lapic_cap | shared_mem_cap << (16 * 1) | handler_cap << (16 * 2) | vpid << (16 * 3);
  40fb70:	48 c1 e6 20          	shl    rsi,0x20
  40fb74:	48 c1 e2 30          	shl    rdx,0x30
	arg1 = cap | vmcs_cap << (16 * 1) | msr_bitmap_cap << (16 * 2) |  lapic_access_cap << (16 * 3);
  40fb78:	4c 09 e3             	or     rbx,r12
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40fb7b:	c1 e0 10             	shl    eax,0x10
	arg2 = lapic_cap | shared_mem_cap << (16 * 1) | handler_cap << (16 * 2) | vpid << (16 * 3);
  40fb7e:	4c 09 fe             	or     rsi,r15
  40fb81:	49 c1 e1 10          	shl    r9,0x10
	arg1 = cap | vmcs_cap << (16 * 1) | msr_bitmap_cap << (16 * 2) |  lapic_access_cap << (16 * 3);
  40fb85:	4c 09 d3             	or     rbx,r10
	arg2 = lapic_cap | shared_mem_cap << (16 * 1) | handler_cap << (16 * 2) | vpid << (16 * 3);
  40fb88:	48 09 d6             	or     rsi,rdx
	__asm__ __volatile__(
  40fb8b:	31 d2                	xor    edx,edx
	cap_no += op;
  40fb8d:	05 0c 00 01 00       	add    eax,0x1000c
  40fb92:	4c 09 ce             	or     rsi,r9
	__asm__ __volatile__(
  40fb95:	48 89 d7             	mov    rdi,rdx
  40fb98:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40fb9b:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40fb9f:	48 89 cd             	mov    rbp,rcx
  40fba2:	49 b8 b8 fb 40 00 00 	movabs r8,0x40fbb8
  40fba9:	00 00 00 
  40fbac:	0f 05                	syscall 
  40fbae:	66 90                	xchg   ax,ax
  40fbb0:	eb 0d                	jmp    40fbbf <cos_vm_vmcb_alloc+0xff>
  40fbb2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40fbb8:	b9 00 00 00 00       	mov    ecx,0x0
  40fbbd:	eb 05                	jmp    40fbc4 <cos_vm_vmcb_alloc+0x104>
  40fbbf:	b9 01 00 00 00       	mov    ecx,0x1
  40fbc4:	5d                   	pop    rbp
  40fbc5:	5c                   	pop    rsp
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_VMCB_ACTIVATE, arg1, arg2, 0, 0)) BUG();
  40fbc6:	85 c0                	test   eax,eax
  40fbc8:	75 12                	jne    40fbdc <cos_vm_vmcb_alloc+0x11c>

	return cap;

}
  40fbca:	48 83 c4 38          	add    rsp,0x38
  40fbce:	4c 89 d0             	mov    rax,r10
  40fbd1:	5b                   	pop    rbx
  40fbd2:	41 5c                	pop    r12
  40fbd4:	41 5d                	pop    r13
  40fbd6:	41 5e                	pop    r14
  40fbd8:	41 5f                	pop    r15
  40fbda:	5d                   	pop    rbp
  40fbdb:	c3                   	ret    
  40fbdc:	be 1c 00 00 00       	mov    esi,0x1c
  40fbe1:	bf b8 eb 41 00       	mov    edi,0x41ebb8
  40fbe6:	e8 95 b0 ff ff       	call   40ac80 <cos_print_str>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_VM_VMCB_ACTIVATE, arg1, arg2, 0, 0)) BUG();
  40fbeb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40fbf2:	00 00 00 00 
  40fbf6:	0f 0b                	ud2    
		if (__capid_captbl_check_expand(ci)) goto error;
  40fbf8:	48 89 f7             	mov    rdi,rsi
  40fbfb:	48 89 55 a0          	mov    QWORD PTR [rbp-0x60],rdx
  40fbff:	4c 89 4d a8          	mov    QWORD PTR [rbp-0x58],r9
  40fc03:	4c 89 45 b0          	mov    QWORD PTR [rbp-0x50],r8
  40fc07:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
  40fc0b:	e8 30 cd ff ff       	call   40c940 <__capid_captbl_check_expand>
  40fc10:	48 8b 75 b8          	mov    rsi,QWORD PTR [rbp-0x48]
  40fc14:	4c 8b 45 b0          	mov    r8,QWORD PTR [rbp-0x50]
  40fc18:	85 c0                	test   eax,eax
  40fc1a:	4c 8b 4d a8          	mov    r9,QWORD PTR [rbp-0x58]
  40fc1e:	48 8b 55 a0          	mov    rdx,QWORD PTR [rbp-0x60]
  40fc22:	74 27                	je     40fc4b <cos_vm_vmcb_alloc+0x18b>
  40fc24:	48 c7 86 58 01 00 00 	mov    QWORD PTR [rsi+0x158],0x0
  40fc2b:	00 00 00 00 
  40fc2f:	be 2f 00 00 00       	mov    esi,0x2f
  40fc34:	bf 88 eb 41 00       	mov    edi,0x41eb88
  40fc39:	e8 42 b0 ff ff       	call   40ac80 <cos_print_str>
		assert(0);
  40fc3e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40fc45:	00 00 00 00 
  40fc49:	0f 0b                	ud2    
        __asm__ __volatile__("lock " PS_FAA_STR
  40fc4b:	b8 04 00 00 00       	mov    eax,0x4
  40fc50:	f0 48 0f c1 46 18    	lock xadd QWORD PTR [rsi+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40fc56:	48 89 44 d6 08       	mov    QWORD PTR [rsi+rdx*8+0x8],rax
  40fc5b:	e9 d2 fe ff ff       	jmp    40fb32 <cos_vm_vmcb_alloc+0x72>

000000000040fc60 <cos_initthd_alloc>:

thdcap_t
cos_initthd_alloc(struct cos_compinfo *ci, compcap_t comp)
{
  40fc60:	f3 0f 1e fa          	endbr64 
  40fc64:	55                   	push   rbp
  40fc65:	48 89 e5             	mov    rbp,rsp
  40fc68:	41 57                	push   r15
  40fc6a:	41 bf 01 00 00 00    	mov    r15d,0x1
  40fc70:	41 56                	push   r14
  40fc72:	41 55                	push   r13
  40fc74:	41 54                	push   r12
  40fc76:	53                   	push   rbx
  40fc77:	48 83 ec 38          	sub    rsp,0x38
  40fc7b:	f0 4c 0f c1 3d 7c c3 	lock xadd QWORD PTR [rip+0x1ac37c],r15        # 5bc000 <__thdid_alloc>
  40fc82:	1a 00 
	assert(ci && comp > 0);
  40fc84:	48 85 ff             	test   rdi,rdi
  40fc87:	0f 84 d7 01 00 00    	je     40fe64 <cos_initthd_alloc+0x204>
  40fc8d:	49 89 f4             	mov    r12,rsi
  40fc90:	48 85 f6             	test   rsi,rsi
  40fc93:	0f 84 cb 01 00 00    	je     40fe64 <cos_initthd_alloc+0x204>
	if (!__cos_ulk_info.toplvl) return 0;
  40fc99:	4c 8b 05 e0 9d 2f 00 	mov    r8,QWORD PTR [rip+0x2f9de0]        # 709a80 <__cos_ulk_info>
  40fca0:	49 89 fd             	mov    r13,rdi
  40fca3:	4d 85 c0             	test   r8,r8
  40fca6:	74 46                	je     40fcee <cos_initthd_alloc+0x8e>
	if (!__cos_ulk_info.curr_pg || tid % ULK_STACKS_PER_PAGE == 0) {
  40fca8:	48 8b 05 e1 9d 2f 00 	mov    rax,QWORD PTR [rip+0x2f9de1]        # 709a90 <__cos_ulk_info+0x10>
  40fcaf:	48 85 c0             	test   rax,rax
  40fcb2:	74 0a                	je     40fcbe <cos_initthd_alloc+0x5e>
  40fcb4:	41 f6 c7 0f          	test   r15b,0xf
  40fcb8:	0f 85 72 01 00 00    	jne    40fe30 <cos_initthd_alloc+0x1d0>
		__cos_ulk_info.curr_pg = cos_ulk_page_alloc(ci, __cos_ulk_info.toplvl, __cos_ulk_info.pg_frontier);
  40fcbe:	48 8b 15 d3 9d 2f 00 	mov    rdx,QWORD PTR [rip+0x2f9dd3]        # 709a98 <__cos_ulk_info+0x18>
  40fcc5:	4c 89 c6             	mov    rsi,r8
  40fcc8:	4c 89 ef             	mov    rdi,r13
  40fccb:	e8 a0 ea ff ff       	call   40e770 <cos_ulk_page_alloc>
  40fcd0:	48 89 05 b9 9d 2f 00 	mov    QWORD PTR [rip+0x2f9db9],rax        # 709a90 <__cos_ulk_info+0x10>
  40fcd7:	49 89 c0             	mov    r8,rax
		assert(__cos_ulk_info.curr_pg);
  40fcda:	48 85 c0             	test   rax,rax
  40fcdd:	0f 84 9d 01 00 00    	je     40fe80 <cos_initthd_alloc+0x220>
		__cos_ulk_info.pg_frontier += PAGE_SIZE;
  40fce3:	48 81 05 aa 9d 2f 00 	add    QWORD PTR [rip+0x2f9daa],0x1000        # 709a98 <__cos_ulk_info+0x18>
  40fcea:	00 10 00 00 
	return __mem_bump_alloc(ci, 1, 1);
  40fcee:	4c 89 ef             	mov    rdi,r13
  40fcf1:	4c 89 45 b8          	mov    QWORD PTR [rbp-0x48],r8
  40fcf5:	e8 b6 ca ff ff       	call   40c7b0 <__mem_bump_alloc.constprop.0>
  40fcfa:	49 89 c2             	mov    r10,rax
	if (!*kmem) return -1;
  40fcfd:	48 85 c0             	test   rax,rax
  40fd00:	0f 84 96 01 00 00    	je     40fe9c <cos_initthd_alloc+0x23c>
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  40fd06:	0f 01 f9             	rdtscp 
	return (long)coreid;
  40fd09:	48 89 cb             	mov    rbx,rcx
        __asm__ __volatile__("lock " PS_CAS_STR
  40fd0c:	4c 8b 45 b8          	mov    r8,QWORD PTR [rbp-0x48]
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40fd10:	49 8d 8d 58 01 00 00 	lea    rcx,[r13+0x158]
        __asm__ __volatile__("lock " PS_CAS_STR
  40fd17:	31 f6                	xor    esi,esi
  40fd19:	81 e3 ff 0f 00 00    	and    ebx,0xfff
  40fd1f:	bf 01 00 00 00       	mov    edi,0x1
		frontier = &ci->cap16_frontier[cos_cpuid()];
  40fd24:	49 8d 54 dd 28       	lea    rdx,[r13+rbx*8+0x28]
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40fd29:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  40fd30:	48 89 f0             	mov    rax,rsi
  40fd33:	f0 48 0f b1 39       	lock cmpxchg QWORD PTR [rcx],rdi
  40fd38:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40fd3b:	84 c0                	test   al,al
  40fd3d:	74 f1                	je     40fd30 <cos_initthd_alloc+0xd0>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40fd3f:	48 83 c3 04          	add    rbx,0x4
  40fd43:	4d 8b 74 dd 08       	mov    r14,QWORD PTR [r13+rbx*8+0x8]
  40fd48:	41 83 e6 03          	and    r14d,0x3
  40fd4c:	0f 84 9e 00 00 00    	je     40fdf0 <cos_initthd_alloc+0x190>
        __asm__ __volatile__("lock " PS_FAA_STR
  40fd52:	bb 01 00 00 00       	mov    ebx,0x1
  40fd57:	f0 48 0f c1 1a       	lock xadd QWORD PTR [rdx],rbx
{ l->o = 0; }
  40fd5c:	49 c7 85 58 01 00 00 	mov    QWORD PTR [r13+0x158],0x0
  40fd63:	00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  40fd67:	49 89 de             	mov    r14,rbx
	if (!*cap) return -1;
  40fd6a:	48 85 db             	test   rbx,rbx
  40fd6d:	0f 84 29 01 00 00    	je     40fe9c <cos_initthd_alloc+0x23c>
			  __compinfo_metacap(ci)->mi.pgtbl_cap << 16 | comp, kmem, ulkcap << 16 | tid);
  40fd73:	49 8b 95 08 01 00 00 	mov    rdx,QWORD PTR [r13+0x108]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40fd7a:	41 8b 45 08          	mov    eax,DWORD PTR [r13+0x8]
	__asm__ __volatile__(
  40fd7e:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  40fd82:	4c 89 d7             	mov    rdi,r10
  40fd85:	48 8b 92 40 01 00 00 	mov    rdx,QWORD PTR [rdx+0x140]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40fd8c:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  40fd8f:	05 04 00 01 00       	add    eax,0x10004
  40fd94:	48 c1 e2 10          	shl    rdx,0x10
	ret = call_cap_op(ci->captbl_cap, CAPTBL_OP_THDACTIVATE, (init_data << 16) | cap,
  40fd98:	4c 09 e2             	or     rdx,r12
  40fd9b:	48 89 d6             	mov    rsi,rdx
			  __compinfo_metacap(ci)->mi.pgtbl_cap << 16 | comp, kmem, ulkcap << 16 | tid);
  40fd9e:	4c 89 c2             	mov    rdx,r8
  40fda1:	48 c1 e2 10          	shl    rdx,0x10
	ret = call_cap_op(ci->captbl_cap, CAPTBL_OP_THDACTIVATE, (init_data << 16) | cap,
  40fda5:	4c 09 fa             	or     rdx,r15
	__asm__ __volatile__(
  40fda8:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40fdab:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40fdaf:	48 89 cd             	mov    rbp,rcx
  40fdb2:	49 b8 c8 fd 40 00 00 	movabs r8,0x40fdc8
  40fdb9:	00 00 00 
  40fdbc:	0f 05                	syscall 
  40fdbe:	66 90                	xchg   ax,ax
  40fdc0:	eb 0d                	jmp    40fdcf <cos_initthd_alloc+0x16f>
  40fdc2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40fdc8:	b9 00 00 00 00       	mov    ecx,0x0
  40fdcd:	eb 05                	jmp    40fdd4 <cos_initthd_alloc+0x174>
  40fdcf:	b9 01 00 00 00       	mov    ecx,0x1
  40fdd4:	5d                   	pop    rbp
  40fdd5:	5c                   	pop    rsp
	if (ret) BUG();
  40fdd6:	85 c0                	test   eax,eax
  40fdd8:	75 6e                	jne    40fe48 <cos_initthd_alloc+0x1e8>
	thdid_t tid = cos_thd_id_alloc();

	return __cos_thd_alloc(ci, comp, 0, tid);
}
  40fdda:	48 83 c4 38          	add    rsp,0x38
  40fdde:	4c 89 f0             	mov    rax,r14
  40fde1:	5b                   	pop    rbx
  40fde2:	41 5c                	pop    r12
  40fde4:	41 5d                	pop    r13
  40fde6:	41 5e                	pop    r14
  40fde8:	41 5f                	pop    r15
  40fdea:	5d                   	pop    rbp
  40fdeb:	c3                   	ret    
  40fdec:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  40fdf0:	4c 89 ef             	mov    rdi,r13
  40fdf3:	48 89 55 a8          	mov    QWORD PTR [rbp-0x58],rdx
  40fdf7:	4c 89 45 b0          	mov    QWORD PTR [rbp-0x50],r8
  40fdfb:	4c 89 55 b8          	mov    QWORD PTR [rbp-0x48],r10
  40fdff:	e8 3c cb ff ff       	call   40c940 <__capid_captbl_check_expand>
  40fe04:	4c 8b 55 b8          	mov    r10,QWORD PTR [rbp-0x48]
  40fe08:	4c 8b 45 b0          	mov    r8,QWORD PTR [rbp-0x50]
  40fe0c:	85 c0                	test   eax,eax
  40fe0e:	48 8b 55 a8          	mov    rdx,QWORD PTR [rbp-0x58]
  40fe12:	75 24                	jne    40fe38 <cos_initthd_alloc+0x1d8>
        __asm__ __volatile__("lock " PS_FAA_STR
  40fe14:	b8 04 00 00 00       	mov    eax,0x4
  40fe19:	f0 49 0f c1 45 18    	lock xadd QWORD PTR [r13+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40fe1f:	49 89 44 dd 08       	mov    QWORD PTR [r13+rbx*8+0x8],rax
  40fe24:	e9 29 ff ff ff       	jmp    40fd52 <cos_initthd_alloc+0xf2>
  40fe29:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  40fe30:	49 89 c0             	mov    r8,rax
	return __cos_ulk_info.curr_pg;
  40fe33:	e9 b6 fe ff ff       	jmp    40fcee <cos_initthd_alloc+0x8e>
{ l->o = 0; }
  40fe38:	49 c7 85 58 01 00 00 	mov    QWORD PTR [r13+0x158],0x0
  40fe3f:	00 00 00 00 
	if (!*cap) return -1;
  40fe43:	eb 95                	jmp    40fdda <cos_initthd_alloc+0x17a>
  40fe45:	0f 1f 00             	nop    DWORD PTR [rax]
  40fe48:	be 1b 00 00 00       	mov    esi,0x1b
  40fe4d:	bf 0f e8 41 00       	mov    edi,0x41e80f
  40fe52:	e8 29 ae ff ff       	call   40ac80 <cos_print_str>
	if (ret) BUG();
  40fe57:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40fe5e:	00 00 00 00 
  40fe62:	0f 0b                	ud2    
  40fe64:	be 2e 00 00 00       	mov    esi,0x2e
  40fe69:	bf 80 e7 41 00       	mov    edi,0x41e780
  40fe6e:	e8 0d ae ff ff       	call   40ac80 <cos_print_str>
	assert(ci && comp > 0);
  40fe73:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40fe7a:	00 00 00 00 
  40fe7e:	0f 0b                	ud2    
  40fe80:	be 2e 00 00 00       	mov    esi,0x2e
  40fe85:	bf b0 e7 41 00       	mov    edi,0x41e7b0
  40fe8a:	e8 f1 ad ff ff       	call   40ac80 <cos_print_str>
		assert(__cos_ulk_info.curr_pg);
  40fe8f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  40fe96:	00 00 00 00 
  40fe9a:	0f 0b                	ud2    
	if (__alloc_mem_cap(ci, CAP_THD, &kmem, &cap)) return 0;
  40fe9c:	45 31 f6             	xor    r14d,r14d
	return __cos_thd_alloc(ci, comp, 0, tid);
  40fe9f:	e9 36 ff ff ff       	jmp    40fdda <cos_initthd_alloc+0x17a>
  40fea4:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  40feab:	00 00 00 00 
  40feaf:	90                   	nop

000000000040feb0 <cos_captbl_alloc>:

captblcap_t
cos_captbl_alloc(struct cos_compinfo *ci)
{
  40feb0:	f3 0f 1e fa          	endbr64 
  40feb4:	55                   	push   rbp
  40feb5:	48 89 e5             	mov    rbp,rsp
  40feb8:	41 57                	push   r15
  40feba:	41 56                	push   r14
  40febc:	41 55                	push   r13
  40febe:	41 54                	push   r12
  40fec0:	53                   	push   rbx
  40fec1:	48 83 ec 18          	sub    rsp,0x18
	vaddr_t kmem;
	capid_t cap;

	printd("cos_captbl_alloc\n");

	assert(ci);
  40fec5:	48 85 ff             	test   rdi,rdi
  40fec8:	0f 84 3e 01 00 00    	je     41000c <cos_captbl_alloc+0x15c>
  40fece:	49 89 fc             	mov    r12,rdi
	return __mem_bump_alloc(ci, 1, 1);
  40fed1:	e8 da c8 ff ff       	call   40c7b0 <__mem_bump_alloc.constprop.0>
  40fed6:	49 89 c6             	mov    r14,rax
	if (!*kmem) return -1;
  40fed9:	48 85 c0             	test   rax,rax
  40fedc:	0f 84 46 01 00 00    	je     410028 <cos_captbl_alloc+0x178>
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  40fee2:	0f 01 f9             	rdtscp 
	return (long)coreid;
  40fee5:	48 89 cb             	mov    rbx,rcx
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40fee8:	49 8d 94 24 58 01 00 	lea    rdx,[r12+0x158]
  40feef:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  40fef0:	be 01 00 00 00       	mov    esi,0x1
  40fef5:	31 c9                	xor    ecx,ecx
  40fef7:	81 e3 ff 0f 00 00    	and    ebx,0xfff
		frontier = &ci->cap64_frontier[cos_cpuid()];
  40fefd:	4d 8d bc dc a8 00 00 	lea    r15,[r12+rbx*8+0xa8]
  40ff04:	00 
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40ff05:	0f 1f 00             	nop    DWORD PTR [rax]
        __asm__ __volatile__("lock " PS_CAS_STR
  40ff08:	48 89 c8             	mov    rax,rcx
  40ff0b:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  40ff10:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  40ff13:	84 c0                	test   al,al
  40ff15:	74 f1                	je     40ff08 <cos_captbl_alloc+0x58>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  40ff17:	48 83 c3 14          	add    rbx,0x14
  40ff1b:	4d 8b 6c dc 08       	mov    r13,QWORD PTR [r12+rbx*8+0x8]
  40ff20:	41 83 e5 03          	and    r13d,0x3
  40ff24:	0f 84 8e 00 00 00    	je     40ffb8 <cos_captbl_alloc+0x108>
        __asm__ __volatile__("lock " PS_FAA_STR
  40ff2a:	bb 04 00 00 00       	mov    ebx,0x4
  40ff2f:	f0 49 0f c1 1f       	lock xadd QWORD PTR [r15],rbx
{ l->o = 0; }
  40ff34:	49 c7 84 24 58 01 00 	mov    QWORD PTR [r12+0x158],0x0
  40ff3b:	00 00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  40ff40:	49 89 dd             	mov    r13,rbx
	if (!*cap) return -1;
  40ff43:	48 85 db             	test   rbx,rbx
  40ff46:	0f 84 dc 00 00 00    	je     410028 <cos_captbl_alloc+0x178>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40ff4c:	41 8b 44 24 08       	mov    eax,DWORD PTR [r12+0x8]

	if (__alloc_mem_cap(ci, CAP_CAPTBL, &kmem, &cap)) return 0;
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_CAPTBLACTIVATE, cap, __compinfo_metacap(ci)->mi.pgtbl_cap, kmem, 0))
  40ff51:	49 8b 94 24 08 01 00 	mov    rdx,QWORD PTR [r12+0x108]
  40ff58:	00 
	__asm__ __volatile__(
  40ff59:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  40ff5d:	4c 89 f7             	mov    rdi,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  40ff60:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  40ff63:	48 8b b2 40 01 00 00 	mov    rsi,QWORD PTR [rdx+0x140]
  40ff6a:	31 d2                	xor    edx,edx
	cap_no += op;
  40ff6c:	05 1e 00 01 00       	add    eax,0x1001e
	__asm__ __volatile__(
  40ff71:	48 89 29             	mov    QWORD PTR [rcx],rbp
  40ff74:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  40ff78:	48 89 cd             	mov    rbp,rcx
  40ff7b:	49 b8 90 ff 40 00 00 	movabs r8,0x40ff90
  40ff82:	00 00 00 
  40ff85:	0f 05                	syscall 
  40ff87:	90                   	nop
  40ff88:	eb 0d                	jmp    40ff97 <cos_captbl_alloc+0xe7>
  40ff8a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  40ff90:	b9 00 00 00 00       	mov    ecx,0x0
  40ff95:	eb 05                	jmp    40ff9c <cos_captbl_alloc+0xec>
  40ff97:	b9 01 00 00 00       	mov    ecx,0x1
  40ff9c:	5d                   	pop    rbp
  40ff9d:	5c                   	pop    rsp
  40ff9e:	85 c0                	test   eax,eax
  40ffa0:	75 4e                	jne    40fff0 <cos_captbl_alloc+0x140>
		BUG();

	return cap;
}
  40ffa2:	48 83 c4 18          	add    rsp,0x18
  40ffa6:	4c 89 e8             	mov    rax,r13
  40ffa9:	5b                   	pop    rbx
  40ffaa:	41 5c                	pop    r12
  40ffac:	41 5d                	pop    r13
  40ffae:	41 5e                	pop    r14
  40ffb0:	41 5f                	pop    r15
  40ffb2:	5d                   	pop    rbp
  40ffb3:	c3                   	ret    
  40ffb4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  40ffb8:	4c 89 e7             	mov    rdi,r12
  40ffbb:	e8 80 c9 ff ff       	call   40c940 <__capid_captbl_check_expand>
  40ffc0:	85 c0                	test   eax,eax
  40ffc2:	75 16                	jne    40ffda <cos_captbl_alloc+0x12a>
        __asm__ __volatile__("lock " PS_FAA_STR
  40ffc4:	b8 04 00 00 00       	mov    eax,0x4
  40ffc9:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  40ffd0:	49 89 44 dc 08       	mov    QWORD PTR [r12+rbx*8+0x8],rax
  40ffd5:	e9 50 ff ff ff       	jmp    40ff2a <cos_captbl_alloc+0x7a>
{ l->o = 0; }
  40ffda:	49 c7 84 24 58 01 00 	mov    QWORD PTR [r12+0x158],0x0
  40ffe1:	00 00 00 00 00 
	if (!*cap) return -1;
  40ffe6:	eb ba                	jmp    40ffa2 <cos_captbl_alloc+0xf2>
  40ffe8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  40ffef:	00 
  40fff0:	be 1c 00 00 00       	mov    esi,0x1c
  40fff5:	bf 08 ec 41 00       	mov    edi,0x41ec08
  40fffa:	e8 81 ac ff ff       	call   40ac80 <cos_print_str>
		BUG();
  40ffff:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410006:	00 00 00 00 
  41000a:	0f 0b                	ud2    
  41000c:	be 2f 00 00 00       	mov    esi,0x2f
  410011:	bf d8 eb 41 00       	mov    edi,0x41ebd8
  410016:	e8 65 ac ff ff       	call   40ac80 <cos_print_str>
	assert(ci);
  41001b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410022:	00 00 00 00 
  410026:	0f 0b                	ud2    
	if (__alloc_mem_cap(ci, CAP_CAPTBL, &kmem, &cap)) return 0;
  410028:	45 31 ed             	xor    r13d,r13d
  41002b:	e9 72 ff ff ff       	jmp    40ffa2 <cos_captbl_alloc+0xf2>

0000000000410030 <cos_pgtbl_alloc>:

pgtblcap_t
cos_pgtbl_alloc(struct cos_compinfo *ci, u8_t type)
{
  410030:	f3 0f 1e fa          	endbr64 
  410034:	55                   	push   rbp
  410035:	48 89 e5             	mov    rbp,rsp
  410038:	41 57                	push   r15
  41003a:	41 56                	push   r14
  41003c:	41 55                	push   r13
  41003e:	41 54                	push   r12
  410040:	53                   	push   rbx
  410041:	48 83 ec 28          	sub    rsp,0x28
	capid_t cap;
	word_t lvl = 0;

	printd("cos_pgtbl_alloc\n");

	assert(ci);
  410045:	48 85 ff             	test   rdi,rdi
  410048:	0f 84 4e 01 00 00    	je     41019c <cos_pgtbl_alloc+0x16c>
  41004e:	49 89 ff             	mov    r15,rdi
  410051:	41 89 f4             	mov    r12d,esi
	return __mem_bump_alloc(ci, 1, 1);
  410054:	e8 57 c7 ff ff       	call   40c7b0 <__mem_bump_alloc.constprop.0>
  410059:	49 89 c5             	mov    r13,rax
	if (!*kmem) return -1;
  41005c:	48 85 c0             	test   rax,rax
  41005f:	0f 84 53 01 00 00    	je     4101b8 <cos_pgtbl_alloc+0x188>
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  410065:	0f 01 f9             	rdtscp 
	return (long)coreid;
  410068:	48 89 cb             	mov    rbx,rcx
{ while (!ps_cas(&l->o, 0, 1)) ; }
  41006b:	49 8d 97 58 01 00 00 	lea    rdx,[r15+0x158]
        __asm__ __volatile__("lock " PS_CAS_STR
  410072:	be 01 00 00 00       	mov    esi,0x1
  410077:	31 c9                	xor    ecx,ecx
  410079:	81 e3 ff 0f 00 00    	and    ebx,0xfff
		frontier = &ci->cap64_frontier[cos_cpuid()];
  41007f:	4d 8d 84 df a8 00 00 	lea    r8,[r15+rbx*8+0xa8]
  410086:	00 
{ while (!ps_cas(&l->o, 0, 1)) ; }
  410087:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41008e:	00 00 
        __asm__ __volatile__("lock " PS_CAS_STR
  410090:	48 89 c8             	mov    rax,rcx
  410093:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  410098:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  41009b:	84 c0                	test   al,al
  41009d:	74 f1                	je     410090 <cos_pgtbl_alloc+0x60>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  41009f:	48 83 c3 14          	add    rbx,0x14
  4100a3:	4d 8b 74 df 08       	mov    r14,QWORD PTR [r15+rbx*8+0x8]
  4100a8:	41 83 e6 03          	and    r14d,0x3
  4100ac:	0f 84 96 00 00 00    	je     410148 <cos_pgtbl_alloc+0x118>
        __asm__ __volatile__("lock " PS_FAA_STR
  4100b2:	bb 04 00 00 00       	mov    ebx,0x4
  4100b7:	f0 49 0f c1 18       	lock xadd QWORD PTR [r8],rbx
{ l->o = 0; }
  4100bc:	49 c7 87 58 01 00 00 	mov    QWORD PTR [r15+0x158],0x0
  4100c3:	00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  4100c7:	49 89 de             	mov    r14,rbx
	if (!*cap) return -1;
  4100ca:	48 85 db             	test   rbx,rbx
  4100cd:	0f 84 e5 00 00 00    	je     4101b8 <cos_pgtbl_alloc+0x188>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4100d3:	41 8b 47 08          	mov    eax,DWORD PTR [r15+0x8]

	if (__alloc_mem_cap(ci, CAP_PGTBL, &kmem, &cap)) return 0;

	if (unlikely(type)) lvl |= PGTBL_LVL_FLAG_VM;
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_PGTBLACTIVATE, cap, __compinfo_metacap(ci)->mi.pgtbl_cap, kmem, lvl))
  4100d7:	49 8b 97 08 01 00 00 	mov    rdx,QWORD PTR [r15+0x108]
	__asm__ __volatile__(
  4100de:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  4100e2:	4c 89 ef             	mov    rdi,r13
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4100e5:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  4100e8:	48 8b b2 40 01 00 00 	mov    rsi,QWORD PTR [rdx+0x140]
	if (unlikely(type)) lvl |= PGTBL_LVL_FLAG_VM;
  4100ef:	31 d2                	xor    edx,edx
	cap_no += op;
  4100f1:	05 1c 00 01 00       	add    eax,0x1001c
  4100f6:	45 84 e4             	test   r12b,r12b
  4100f9:	0f 95 c2             	setne  dl
  4100fc:	48 c1 e2 1f          	shl    rdx,0x1f
	__asm__ __volatile__(
  410100:	48 89 29             	mov    QWORD PTR [rcx],rbp
  410103:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  410107:	48 89 cd             	mov    rbp,rcx
  41010a:	49 b8 20 01 41 00 00 	movabs r8,0x410120
  410111:	00 00 00 
  410114:	0f 05                	syscall 
  410116:	66 90                	xchg   ax,ax
  410118:	eb 0d                	jmp    410127 <cos_pgtbl_alloc+0xf7>
  41011a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410120:	b9 00 00 00 00       	mov    ecx,0x0
  410125:	eb 05                	jmp    41012c <cos_pgtbl_alloc+0xfc>
  410127:	b9 01 00 00 00       	mov    ecx,0x1
  41012c:	5d                   	pop    rbp
  41012d:	5c                   	pop    rsp
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_PGTBLACTIVATE, cap, __compinfo_metacap(ci)->mi.pgtbl_cap, kmem, lvl))
  41012e:	85 c0                	test   eax,eax
  410130:	75 4e                	jne    410180 <cos_pgtbl_alloc+0x150>
		BUG();

	return cap;
}
  410132:	48 83 c4 28          	add    rsp,0x28
  410136:	4c 89 f0             	mov    rax,r14
  410139:	5b                   	pop    rbx
  41013a:	41 5c                	pop    r12
  41013c:	41 5d                	pop    r13
  41013e:	41 5e                	pop    r14
  410140:	41 5f                	pop    r15
  410142:	5d                   	pop    rbp
  410143:	c3                   	ret    
  410144:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  410148:	4c 89 ff             	mov    rdi,r15
  41014b:	4c 89 45 b8          	mov    QWORD PTR [rbp-0x48],r8
  41014f:	e8 ec c7 ff ff       	call   40c940 <__capid_captbl_check_expand>
  410154:	4c 8b 45 b8          	mov    r8,QWORD PTR [rbp-0x48]
  410158:	85 c0                	test   eax,eax
  41015a:	75 15                	jne    410171 <cos_pgtbl_alloc+0x141>
        __asm__ __volatile__("lock " PS_FAA_STR
  41015c:	b8 04 00 00 00       	mov    eax,0x4
  410161:	f0 49 0f c1 47 18    	lock xadd QWORD PTR [r15+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  410167:	49 89 44 df 08       	mov    QWORD PTR [r15+rbx*8+0x8],rax
  41016c:	e9 41 ff ff ff       	jmp    4100b2 <cos_pgtbl_alloc+0x82>
{ l->o = 0; }
  410171:	49 c7 87 58 01 00 00 	mov    QWORD PTR [r15+0x158],0x0
  410178:	00 00 00 00 
	if (!*cap) return -1;
  41017c:	eb b4                	jmp    410132 <cos_pgtbl_alloc+0x102>
  41017e:	66 90                	xchg   ax,ax
  410180:	be 1c 00 00 00       	mov    esi,0x1c
  410185:	bf 58 ec 41 00       	mov    edi,0x41ec58
  41018a:	e8 f1 aa ff ff       	call   40ac80 <cos_print_str>
		BUG();
  41018f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410196:	00 00 00 00 
  41019a:	0f 0b                	ud2    
  41019c:	be 2f 00 00 00       	mov    esi,0x2f
  4101a1:	bf 28 ec 41 00       	mov    edi,0x41ec28
  4101a6:	e8 d5 aa ff ff       	call   40ac80 <cos_print_str>
	assert(ci);
  4101ab:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4101b2:	00 00 00 00 
  4101b6:	0f 0b                	ud2    
	if (__alloc_mem_cap(ci, CAP_PGTBL, &kmem, &cap)) return 0;
  4101b8:	45 31 f6             	xor    r14d,r14d
  4101bb:	e9 72 ff ff ff       	jmp    410132 <cos_pgtbl_alloc+0x102>

00000000004101c0 <cos_ulk_pgtbl_create>:
{
  4101c0:	f3 0f 1e fa          	endbr64 
  4101c4:	55                   	push   rbp
  4101c5:	48 89 e5             	mov    rbp,rsp
  4101c8:	41 57                	push   r15
  4101ca:	41 56                	push   r14
  4101cc:	41 55                	push   r13
  4101ce:	41 54                	push   r12
  4101d0:	53                   	push   rbx
  4101d1:	48 83 ec 48          	sub    rsp,0x48
	assert(ci && secondlvl);
  4101d5:	48 85 ff             	test   rdi,rdi
  4101d8:	0f 84 9c 03 00 00    	je     41057a <cos_ulk_pgtbl_create+0x3ba>
  4101de:	49 89 f7             	mov    r15,rsi
  4101e1:	48 85 f6             	test   rsi,rsi
  4101e4:	0f 84 90 03 00 00    	je     41057a <cos_ulk_pgtbl_create+0x3ba>
  4101ea:	49 89 fd             	mov    r13,rdi
	toplvl = cos_pgtbl_alloc(__compinfo_metacap(ci), PGTBL_TYPE_DEF);
  4101ed:	48 8b bf 08 01 00 00 	mov    rdi,QWORD PTR [rdi+0x108]
  4101f4:	31 f6                	xor    esi,esi
  4101f6:	e8 35 fe ff ff       	call   410030 <cos_pgtbl_alloc>
	*secondlvl = __bump_mem_expand_intern(__compinfo_metacap(ci), toplvl, ULK_BASE_ADDR, 0, 0);
  4101fb:	49 8b bd 08 01 00 00 	mov    rdi,QWORD PTR [r13+0x108]
  410202:	45 31 c0             	xor    r8d,r8d
  410205:	31 c9                	xor    ecx,ecx
  410207:	48 ba 00 00 00 00 80 	movabs rdx,0x7f8000000000
  41020e:	7f 00 00 
  410211:	48 89 c6             	mov    rsi,rax
	toplvl = cos_pgtbl_alloc(__compinfo_metacap(ci), PGTBL_TYPE_DEF);
  410214:	49 89 c6             	mov    r14,rax
	*secondlvl = __bump_mem_expand_intern(__compinfo_metacap(ci), toplvl, ULK_BASE_ADDR, 0, 0);
  410217:	e8 54 d1 ff ff       	call   40d370 <__bump_mem_expand_intern>
  41021c:	49 89 07             	mov    QWORD PTR [r15],rax
	if (!*secondlvl) return 0;
  41021f:	48 85 c0             	test   rax,rax
  410222:	75 14                	jne    410238 <cos_ulk_pgtbl_create+0x78>
}
  410224:	48 83 c4 48          	add    rsp,0x48
  410228:	5b                   	pop    rbx
  410229:	41 5c                	pop    r12
  41022b:	41 5d                	pop    r13
  41022d:	41 5e                	pop    r14
  41022f:	41 5f                	pop    r15
  410231:	5d                   	pop    rbp
  410232:	c3                   	ret    
  410233:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	return ci->memsrc;
  410238:	4d 8b bd 08 01 00 00 	mov    r15,QWORD PTR [r13+0x108]
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  41023f:	4d 3b bf 08 01 00 00 	cmp    r15,QWORD PTR [r15+0x108]
  410246:	0f 85 4a 03 00 00    	jne    410596 <cos_ulk_pgtbl_create+0x3d6>
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  41024c:	0f 01 f9             	rdtscp 
	return (long)coreid;
  41024f:	48 89 cf             	mov    rdi,rcx
{ while (!ps_cas(&l->o, 0, 1)) ; }
  410252:	49 8d 97 58 01 00 00 	lea    rdx,[r15+0x158]
        __asm__ __volatile__("lock " PS_CAS_STR
  410259:	be 01 00 00 00       	mov    esi,0x1
  41025e:	31 c9                	xor    ecx,ecx
  410260:	81 e7 ff 0f 00 00    	and    edi,0xfff
		frontier = &ci->cap64_frontier[cos_cpuid()];
  410266:	4d 8d a4 ff a8 00 00 	lea    r12,[r15+rdi*8+0xa8]
  41026d:	00 
{ while (!ps_cas(&l->o, 0, 1)) ; }
  41026e:	66 90                	xchg   ax,ax
        __asm__ __volatile__("lock " PS_CAS_STR
  410270:	48 89 c8             	mov    rax,rcx
  410273:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  410278:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  41027b:	84 c0                	test   al,al
  41027d:	74 f1                	je     410270 <cos_ulk_pgtbl_create+0xb0>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  41027f:	48 8d 5f 14          	lea    rbx,[rdi+0x14]
  410283:	41 f6 84 ff a8 00 00 	test   BYTE PTR [r15+rdi*8+0xa8],0x3
  41028a:	00 03 
  41028c:	0f 84 7c 02 00 00    	je     41050e <cos_ulk_pgtbl_create+0x34e>
        __asm__ __volatile__("lock " PS_FAA_STR
  410292:	bb 04 00 00 00       	mov    ebx,0x4
  410297:	f0 49 0f c1 1c 24    	lock xadd QWORD PTR [r12],rbx
{ l->o = 0; }
  41029d:	49 c7 87 58 01 00 00 	mov    QWORD PTR [r15+0x158],0x0
  4102a4:	00 00 00 00 
	return __mem_bump_alloc(ci, 1, 1);
  4102a8:	4c 89 ff             	mov    rdi,r15
  4102ab:	e8 00 c5 ff ff       	call   40c7b0 <__mem_bump_alloc.constprop.0>
  4102b0:	48 89 c7             	mov    rdi,rax
		if (pte_cap == 0 || ptemem_cap == 0) {
  4102b3:	48 85 db             	test   rbx,rbx
  4102b6:	0f 84 a2 02 00 00    	je     41055e <cos_ulk_pgtbl_create+0x39e>
  4102bc:	48 85 c0             	test   rax,rax
  4102bf:	0f 84 99 02 00 00    	je     41055e <cos_ulk_pgtbl_create+0x39e>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4102c5:	41 8b 47 08          	mov    eax,DWORD PTR [r15+0x8]
	__asm__ __volatile__(
  4102c9:	4c 8d 55 c0          	lea    r10,[rbp-0x40]
  4102cd:	ba 01 00 00 00       	mov    edx,0x1
  4102d2:	49 8b b7 40 01 00 00 	mov    rsi,QWORD PTR [r15+0x140]
  4102d9:	4c 89 d1             	mov    rcx,r10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4102dc:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  4102df:	05 1c 00 01 00       	add    eax,0x1001c
	__asm__ __volatile__(
  4102e4:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4102e7:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4102eb:	48 89 cd             	mov    rbp,rcx
  4102ee:	49 b8 08 03 41 00 00 	movabs r8,0x410308
  4102f5:	00 00 00 
  4102f8:	0f 05                	syscall 
  4102fa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410300:	eb 0d                	jmp    41030f <cos_ulk_pgtbl_create+0x14f>
  410302:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410308:	b9 00 00 00 00       	mov    ecx,0x0
  41030d:	eb 05                	jmp    410314 <cos_ulk_pgtbl_create+0x154>
  41030f:	b9 01 00 00 00       	mov    ecx,0x1
  410314:	5d                   	pop    rbp
  410315:	5c                   	pop    rsp
		if (call_cap_op(meta->captbl_cap, CAPTBL_OP_PGTBLACTIVATE, pte_cap, meta->mi.pgtbl_cap, ptemem_cap,
  410316:	85 c0                	test   eax,eax
  410318:	0f 85 11 02 00 00    	jne    41052f <cos_ulk_pgtbl_create+0x36f>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  41031e:	44 89 f0             	mov    eax,r14d
	__asm__ __volatile__(
  410321:	31 d2                	xor    edx,edx
  410323:	4c 89 d1             	mov    rcx,r10
  410326:	48 be 00 10 00 00 80 	movabs rsi,0x7f8000001000
  41032d:	7f 00 00 
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  410330:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  410333:	48 89 d7             	mov    rdi,rdx
	cap_no += op;
  410336:	05 01 00 01 00       	add    eax,0x10001
  41033b:	89 45 b4             	mov    DWORD PTR [rbp-0x4c],eax
	__asm__ __volatile__(
  41033e:	48 89 29             	mov    QWORD PTR [rcx],rbp
  410341:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  410345:	48 89 cd             	mov    rbp,rcx
  410348:	49 b8 60 03 41 00 00 	movabs r8,0x410360
  41034f:	00 00 00 
  410352:	0f 05                	syscall 
  410354:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  410358:	eb 0d                	jmp    410367 <cos_ulk_pgtbl_create+0x1a7>
  41035a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410360:	b9 00 00 00 00       	mov    ecx,0x0
  410365:	eb 05                	jmp    41036c <cos_ulk_pgtbl_create+0x1ac>
  410367:	b9 01 00 00 00       	mov    ecx,0x1
  41036c:	5d                   	pop    rbp
  41036d:	5c                   	pop    rsp
	for (pgtbl_lvl = 1; pgtbl_lvl < COS_PGTBL_DEPTH - 1; pgtbl_lvl++) {
  41036e:	48 c7 45 b8 01 00 00 	mov    QWORD PTR [rbp-0x48],0x1
  410375:	00 
	return ci->memsrc;
  410376:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  41037a:	4d 8b bd 08 01 00 00 	mov    r15,QWORD PTR [r13+0x108]
	range		 = cos_pgtbl_get_range(lvl);
  410381:	48 8b 1c c5 f0 f3 41 	mov    rbx,QWORD PTR [rax*8+0x41f3f0]
  410388:	00 
		return round_up_to_pgt2_page(vaddr);
  410389:	48 83 f8 02          	cmp    rax,0x2
  41038d:	48 b8 00 00 20 00 80 	movabs rax,0x7f8000200000
  410394:	7f 00 00 
  410397:	48 89 5d 98          	mov    QWORD PTR [rbp-0x68],rbx
  41039b:	48 bb 00 00 00 40 80 	movabs rbx,0x7f8040000000
  4103a2:	7f 00 00 
  4103a5:	48 0f 45 c3          	cmovne rax,rbx
  4103a9:	48 89 45 a0          	mov    QWORD PTR [rbp-0x60],rax
	for (addr = mem_ptr; addr < tmp_frontier; addr += range) {
  4103ad:	48 b8 00 00 00 00 80 	movabs rax,0x7f8000000000
  4103b4:	7f 00 00 
  4103b7:	48 89 45 a8          	mov    QWORD PTR [rbp-0x58],rax
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  4103bb:	4d 3b bf 08 01 00 00 	cmp    r15,QWORD PTR [r15+0x108]
  4103c2:	0f 85 ce 01 00 00    	jne    410596 <cos_ulk_pgtbl_create+0x3d6>
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  4103c8:	0f 01 f9             	rdtscp 
	return (long)coreid;
  4103cb:	48 89 ce             	mov    rsi,rcx
{ while (!ps_cas(&l->o, 0, 1)) ; }
  4103ce:	49 8d 97 58 01 00 00 	lea    rdx,[r15+0x158]
        __asm__ __volatile__("lock " PS_CAS_STR
  4103d5:	31 c9                	xor    ecx,ecx
  4103d7:	81 e6 ff 0f 00 00    	and    esi,0xfff
		frontier = &ci->cap64_frontier[cos_cpuid()];
  4103dd:	4d 8d a4 f7 a8 00 00 	lea    r12,[r15+rsi*8+0xa8]
  4103e4:	00 
{ while (!ps_cas(&l->o, 0, 1)) ; }
  4103e5:	0f 1f 00             	nop    DWORD PTR [rax]
        __asm__ __volatile__("lock " PS_CAS_STR
  4103e8:	bb 01 00 00 00       	mov    ebx,0x1
  4103ed:	48 89 c8             	mov    rax,rcx
  4103f0:	f0 48 0f b1 1a       	lock cmpxchg QWORD PTR [rdx],rbx
  4103f5:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  4103f8:	84 c0                	test   al,al
  4103fa:	74 ec                	je     4103e8 <cos_ulk_pgtbl_create+0x228>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  4103fc:	48 8d 5e 14          	lea    rbx,[rsi+0x14]
  410400:	41 f6 84 f7 a8 00 00 	test   BYTE PTR [r15+rsi*8+0xa8],0x3
  410407:	00 03 
  410409:	0f 84 a3 01 00 00    	je     4105b2 <cos_ulk_pgtbl_create+0x3f2>
        __asm__ __volatile__("lock " PS_FAA_STR
  41040f:	bb 04 00 00 00       	mov    ebx,0x4
  410414:	f0 49 0f c1 1c 24    	lock xadd QWORD PTR [r12],rbx
{ l->o = 0; }
  41041a:	49 c7 87 58 01 00 00 	mov    QWORD PTR [r15+0x158],0x0
  410421:	00 00 00 00 
	return __mem_bump_alloc(ci, 1, 1);
  410425:	4c 89 ff             	mov    rdi,r15
  410428:	e8 83 c3 ff ff       	call   40c7b0 <__mem_bump_alloc.constprop.0>
  41042d:	48 89 c7             	mov    rdi,rax
		if (pte_cap == 0 || ptemem_cap == 0) {
  410430:	48 85 db             	test   rbx,rbx
  410433:	0f 84 25 01 00 00    	je     41055e <cos_ulk_pgtbl_create+0x39e>
  410439:	48 85 c0             	test   rax,rax
  41043c:	4c 8d 55 c0          	lea    r10,[rbp-0x40]
  410440:	0f 84 18 01 00 00    	je     41055e <cos_ulk_pgtbl_create+0x39e>
		if (call_cap_op(meta->captbl_cap, CAPTBL_OP_PGTBLACTIVATE, pte_cap, meta->mi.pgtbl_cap, ptemem_cap,
  410446:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
	__asm__ __volatile__(
  41044a:	49 8b b7 40 01 00 00 	mov    rsi,QWORD PTR [r15+0x140]
  410451:	4c 89 d1             	mov    rcx,r10
  410454:	48 8d 50 01          	lea    rdx,[rax+0x1]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  410458:	41 8b 47 08          	mov    eax,DWORD PTR [r15+0x8]
  41045c:	48 89 55 90          	mov    QWORD PTR [rbp-0x70],rdx
  410460:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  410463:	05 1c 00 01 00       	add    eax,0x1001c
	__asm__ __volatile__(
  410468:	48 89 29             	mov    QWORD PTR [rcx],rbp
  41046b:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  41046f:	48 89 cd             	mov    rbp,rcx
  410472:	49 b8 88 04 41 00 00 	movabs r8,0x410488
  410479:	00 00 00 
  41047c:	0f 05                	syscall 
  41047e:	66 90                	xchg   ax,ax
  410480:	eb 0d                	jmp    41048f <cos_ulk_pgtbl_create+0x2cf>
  410482:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410488:	b9 00 00 00 00       	mov    ecx,0x0
  41048d:	eb 05                	jmp    410494 <cos_ulk_pgtbl_create+0x2d4>
  41048f:	b9 01 00 00 00       	mov    ecx,0x1
  410494:	5d                   	pop    rbp
  410495:	5c                   	pop    rsp
  410496:	85 c0                	test   eax,eax
  410498:	0f 85 91 00 00 00    	jne    41052f <cos_ulk_pgtbl_create+0x36f>
  41049e:	31 d2                	xor    edx,edx
  4104a0:	8b 45 b4             	mov    eax,DWORD PTR [rbp-0x4c]
  4104a3:	48 8b 75 a8          	mov    rsi,QWORD PTR [rbp-0x58]
  4104a7:	4c 89 d1             	mov    rcx,r10
  4104aa:	48 89 d7             	mov    rdi,rdx
  4104ad:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4104b0:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4104b4:	48 89 cd             	mov    rbp,rcx
  4104b7:	49 b8 d0 04 41 00 00 	movabs r8,0x4104d0
  4104be:	00 00 00 
  4104c1:	0f 05                	syscall 
  4104c3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  4104c8:	eb 0d                	jmp    4104d7 <cos_ulk_pgtbl_create+0x317>
  4104ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4104d0:	b9 00 00 00 00       	mov    ecx,0x0
  4104d5:	eb 05                	jmp    4104dc <cos_ulk_pgtbl_create+0x31c>
  4104d7:	b9 01 00 00 00       	mov    ecx,0x1
  4104dc:	5d                   	pop    rbp
  4104dd:	5c                   	pop    rsp
	for (addr = mem_ptr; addr < tmp_frontier; addr += range) {
  4104de:	48 8b 45 98          	mov    rax,QWORD PTR [rbp-0x68]
  4104e2:	48 01 c6             	add    rsi,rax
  4104e5:	48 89 75 a8          	mov    QWORD PTR [rbp-0x58],rsi
  4104e9:	48 39 75 a0          	cmp    QWORD PTR [rbp-0x60],rsi
  4104ed:	0f 87 c8 fe ff ff    	ja     4103bb <cos_ulk_pgtbl_create+0x1fb>
	for (pgtbl_lvl = 1; pgtbl_lvl < COS_PGTBL_DEPTH - 1; pgtbl_lvl++) {
  4104f3:	48 83 7d 90 03       	cmp    QWORD PTR [rbp-0x70],0x3
  4104f8:	48 c7 45 b8 02 00 00 	mov    QWORD PTR [rbp-0x48],0x2
  4104ff:	00 
  410500:	0f 85 70 fe ff ff    	jne    410376 <cos_ulk_pgtbl_create+0x1b6>
	return toplvl;
  410506:	4c 89 f0             	mov    rax,r14
  410509:	e9 16 fd ff ff       	jmp    410224 <cos_ulk_pgtbl_create+0x64>
		if (__capid_captbl_check_expand(ci)) goto error;
  41050e:	4c 89 ff             	mov    rdi,r15
  410511:	e8 2a c4 ff ff       	call   40c940 <__capid_captbl_check_expand>
  410516:	85 c0                	test   eax,eax
  410518:	75 31                	jne    41054b <cos_ulk_pgtbl_create+0x38b>
        __asm__ __volatile__("lock " PS_FAA_STR
  41051a:	b8 04 00 00 00       	mov    eax,0x4
  41051f:	f0 49 0f c1 47 18    	lock xadd QWORD PTR [r15+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  410525:	49 89 44 df 08       	mov    QWORD PTR [r15+rbx*8+0x8],rax
  41052a:	e9 63 fd ff ff       	jmp    410292 <cos_ulk_pgtbl_create+0xd2>
  41052f:	be 2e 00 00 00       	mov    esi,0x2e
  410534:	bf 90 e2 41 00       	mov    edi,0x41e290
  410539:	e8 42 a7 ff ff       	call   40ac80 <cos_print_str>
				assert(0); /* race? */
  41053e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410545:	00 00 00 00 
  410549:	0f 0b                	ud2    
{ l->o = 0; }
  41054b:	49 c7 87 58 01 00 00 	mov    QWORD PTR [r15+0x158],0x0
  410552:	00 00 00 00 
	return __mem_bump_alloc(ci, 1, 1);
  410556:	4c 89 ff             	mov    rdi,r15
  410559:	e8 52 c2 ff ff       	call   40c7b0 <__mem_bump_alloc.constprop.0>
  41055e:	be 2e 00 00 00       	mov    esi,0x2e
  410563:	bf 60 e2 41 00       	mov    edi,0x41e260
  410568:	e8 13 a7 ff ff       	call   40ac80 <cos_print_str>
			assert(0);
  41056d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410574:	00 00 00 00 
  410578:	0f 0b                	ud2    
  41057a:	be 2e 00 00 00       	mov    esi,0x2e
  41057f:	bf 78 ec 41 00       	mov    edi,0x41ec78
  410584:	e8 f7 a6 ff ff       	call   40ac80 <cos_print_str>
	assert(ci && secondlvl);
  410589:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410590:	00 00 00 00 
  410594:	0f 0b                	ud2    
  410596:	be 2e 00 00 00       	mov    esi,0x2e
  41059b:	bf 30 e2 41 00       	mov    edi,0x41e230
  4105a0:	e8 db a6 ff ff       	call   40ac80 <cos_print_str>
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  4105a5:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4105ac:	00 00 00 00 
  4105b0:	0f 0b                	ud2    
		if (__capid_captbl_check_expand(ci)) goto error;
  4105b2:	4c 89 ff             	mov    rdi,r15
  4105b5:	e8 86 c3 ff ff       	call   40c940 <__capid_captbl_check_expand>
  4105ba:	85 c0                	test   eax,eax
  4105bc:	75 8d                	jne    41054b <cos_ulk_pgtbl_create+0x38b>
        __asm__ __volatile__("lock " PS_FAA_STR
  4105be:	b8 04 00 00 00       	mov    eax,0x4
  4105c3:	f0 49 0f c1 47 18    	lock xadd QWORD PTR [r15+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  4105c9:	49 89 44 df 08       	mov    QWORD PTR [r15+rbx*8+0x8],rax
  4105ce:	e9 3c fe ff ff       	jmp    41040f <cos_ulk_pgtbl_create+0x24f>
  4105d3:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4105da:	00 00 00 00 
  4105de:	66 90                	xchg   ax,ax

00000000004105e0 <cos_ulk_info_init>:
{
  4105e0:	f3 0f 1e fa          	endbr64 
  4105e4:	55                   	push   rbp
  4105e5:	48 89 e5             	mov    rbp,rsp
  4105e8:	41 57                	push   r15
  4105ea:	41 56                	push   r14
  4105ec:	41 55                	push   r13
  4105ee:	41 54                	push   r12
  4105f0:	53                   	push   rbx
  4105f1:	48 83 ec 48          	sub    rsp,0x48
	assert(ci && secondlvl);
  4105f5:	48 85 ff             	test   rdi,rdi
  4105f8:	0f 84 ff 03 00 00    	je     4109fd <cos_ulk_info_init+0x41d>
  4105fe:	49 89 fd             	mov    r13,rdi
	toplvl = cos_pgtbl_alloc(__compinfo_metacap(ci), PGTBL_TYPE_DEF);
  410601:	48 8b bf 08 01 00 00 	mov    rdi,QWORD PTR [rdi+0x108]
  410608:	31 f6                	xor    esi,esi
  41060a:	e8 21 fa ff ff       	call   410030 <cos_pgtbl_alloc>
	*secondlvl = __bump_mem_expand_intern(__compinfo_metacap(ci), toplvl, ULK_BASE_ADDR, 0, 0);
  41060f:	49 8b bd 08 01 00 00 	mov    rdi,QWORD PTR [r13+0x108]
  410616:	45 31 c0             	xor    r8d,r8d
  410619:	31 c9                	xor    ecx,ecx
  41061b:	48 ba 00 00 00 00 80 	movabs rdx,0x7f8000000000
  410622:	7f 00 00 
  410625:	48 89 c6             	mov    rsi,rax
	toplvl = cos_pgtbl_alloc(__compinfo_metacap(ci), PGTBL_TYPE_DEF);
  410628:	49 89 c6             	mov    r14,rax
	*secondlvl = __bump_mem_expand_intern(__compinfo_metacap(ci), toplvl, ULK_BASE_ADDR, 0, 0);
  41062b:	e8 40 cd ff ff       	call   40d370 <__bump_mem_expand_intern>
  410630:	48 89 05 51 94 2f 00 	mov    QWORD PTR [rip+0x2f9451],rax        # 709a88 <__cos_ulk_info+0x8>
	if (!*secondlvl) return 0;
  410637:	48 85 c0             	test   rax,rax
  41063a:	75 44                	jne    410680 <cos_ulk_info_init+0xa0>
	__cos_ulk_info.pg_frontier = ULK_BASE_ADDR + __thdid_alloc * sizeof(struct ulk_invstk);
  41063c:	48 b8 00 00 00 80 7f 	movabs rax,0x7f80000000
  410643:	00 00 00 
  410646:	48 03 05 b3 b9 1a 00 	add    rax,QWORD PTR [rip+0x1ab9b3]        # 5bc000 <__thdid_alloc>
	__cos_ulk_info.toplvl = cos_ulk_pgtbl_create(ci, &__cos_ulk_info.secondlvl);
  41064d:	48 c7 05 28 94 2f 00 	mov    QWORD PTR [rip+0x2f9428],0x0        # 709a80 <__cos_ulk_info>
  410654:	00 00 00 00 
	__cos_ulk_info.pg_frontier = ULK_BASE_ADDR + __thdid_alloc * sizeof(struct ulk_invstk);
  410658:	48 c1 e0 08          	shl    rax,0x8
  41065c:	48 89 05 35 94 2f 00 	mov    QWORD PTR [rip+0x2f9435],rax        # 709a98 <__cos_ulk_info+0x18>
  410663:	be 2e 00 00 00       	mov    esi,0x2e
  410668:	bf a8 ec 41 00       	mov    edi,0x41eca8
  41066d:	e8 0e a6 ff ff       	call   40ac80 <cos_print_str>
	assert(__cos_ulk_info.toplvl);
  410672:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410679:	00 00 00 00 
  41067d:	0f 0b                	ud2    
  41067f:	90                   	nop
	return ci->memsrc;
  410680:	4d 8b bd 08 01 00 00 	mov    r15,QWORD PTR [r13+0x108]
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  410687:	4d 3b bf 08 01 00 00 	cmp    r15,QWORD PTR [r15+0x108]
  41068e:	0f 85 85 03 00 00    	jne    410a19 <cos_ulk_info_init+0x439>
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  410694:	0f 01 f9             	rdtscp 
	return (long)coreid;
  410697:	48 89 cf             	mov    rdi,rcx
{ while (!ps_cas(&l->o, 0, 1)) ; }
  41069a:	49 8d 97 58 01 00 00 	lea    rdx,[r15+0x158]
        __asm__ __volatile__("lock " PS_CAS_STR
  4106a1:	be 01 00 00 00       	mov    esi,0x1
  4106a6:	31 c9                	xor    ecx,ecx
  4106a8:	81 e7 ff 0f 00 00    	and    edi,0xfff
		frontier = &ci->cap64_frontier[cos_cpuid()];
  4106ae:	4d 8d a4 ff a8 00 00 	lea    r12,[r15+rdi*8+0xa8]
  4106b5:	00 
{ while (!ps_cas(&l->o, 0, 1)) ; }
  4106b6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4106bd:	00 00 00 
        __asm__ __volatile__("lock " PS_CAS_STR
  4106c0:	48 89 c8             	mov    rax,rcx
  4106c3:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  4106c8:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  4106cb:	84 c0                	test   al,al
  4106cd:	74 f1                	je     4106c0 <cos_ulk_info_init+0xe0>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  4106cf:	48 8d 5f 14          	lea    rbx,[rdi+0x14]
  4106d3:	41 f6 84 ff a8 00 00 	test   BYTE PTR [r15+rdi*8+0xa8],0x3
  4106da:	00 03 
  4106dc:	0f 84 af 02 00 00    	je     410991 <cos_ulk_info_init+0x3b1>
        __asm__ __volatile__("lock " PS_FAA_STR
  4106e2:	bb 04 00 00 00       	mov    ebx,0x4
  4106e7:	f0 49 0f c1 1c 24    	lock xadd QWORD PTR [r12],rbx
{ l->o = 0; }
  4106ed:	49 c7 87 58 01 00 00 	mov    QWORD PTR [r15+0x158],0x0
  4106f4:	00 00 00 00 
	return __mem_bump_alloc(ci, 1, 1);
  4106f8:	4c 89 ff             	mov    rdi,r15
  4106fb:	e8 b0 c0 ff ff       	call   40c7b0 <__mem_bump_alloc.constprop.0>
  410700:	48 89 c7             	mov    rdi,rax
		if (pte_cap == 0 || ptemem_cap == 0) {
  410703:	48 85 db             	test   rbx,rbx
  410706:	0f 84 d5 02 00 00    	je     4109e1 <cos_ulk_info_init+0x401>
  41070c:	48 85 c0             	test   rax,rax
  41070f:	0f 84 cc 02 00 00    	je     4109e1 <cos_ulk_info_init+0x401>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  410715:	41 8b 47 08          	mov    eax,DWORD PTR [r15+0x8]
	__asm__ __volatile__(
  410719:	4c 8d 55 c0          	lea    r10,[rbp-0x40]
  41071d:	ba 01 00 00 00       	mov    edx,0x1
  410722:	49 8b b7 40 01 00 00 	mov    rsi,QWORD PTR [r15+0x140]
  410729:	4c 89 d1             	mov    rcx,r10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  41072c:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  41072f:	05 1c 00 01 00       	add    eax,0x1001c
	__asm__ __volatile__(
  410734:	48 89 29             	mov    QWORD PTR [rcx],rbp
  410737:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  41073b:	48 89 cd             	mov    rbp,rcx
  41073e:	49 b8 58 07 41 00 00 	movabs r8,0x410758
  410745:	00 00 00 
  410748:	0f 05                	syscall 
  41074a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410750:	eb 0d                	jmp    41075f <cos_ulk_info_init+0x17f>
  410752:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410758:	b9 00 00 00 00       	mov    ecx,0x0
  41075d:	eb 05                	jmp    410764 <cos_ulk_info_init+0x184>
  41075f:	b9 01 00 00 00       	mov    ecx,0x1
  410764:	5d                   	pop    rbp
  410765:	5c                   	pop    rsp
		if (call_cap_op(meta->captbl_cap, CAPTBL_OP_PGTBLACTIVATE, pte_cap, meta->mi.pgtbl_cap, ptemem_cap,
  410766:	85 c0                	test   eax,eax
  410768:	0f 85 44 02 00 00    	jne    4109b2 <cos_ulk_info_init+0x3d2>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  41076e:	44 89 f0             	mov    eax,r14d
	__asm__ __volatile__(
  410771:	31 d2                	xor    edx,edx
  410773:	4c 89 d1             	mov    rcx,r10
  410776:	48 be 00 10 00 00 80 	movabs rsi,0x7f8000001000
  41077d:	7f 00 00 
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  410780:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  410783:	48 89 d7             	mov    rdi,rdx
	cap_no += op;
  410786:	05 01 00 01 00       	add    eax,0x10001
  41078b:	89 45 b4             	mov    DWORD PTR [rbp-0x4c],eax
	__asm__ __volatile__(
  41078e:	48 89 29             	mov    QWORD PTR [rcx],rbp
  410791:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  410795:	48 89 cd             	mov    rbp,rcx
  410798:	49 b8 b0 07 41 00 00 	movabs r8,0x4107b0
  41079f:	00 00 00 
  4107a2:	0f 05                	syscall 
  4107a4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  4107a8:	eb 0d                	jmp    4107b7 <cos_ulk_info_init+0x1d7>
  4107aa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4107b0:	b9 00 00 00 00       	mov    ecx,0x0
  4107b5:	eb 05                	jmp    4107bc <cos_ulk_info_init+0x1dc>
  4107b7:	b9 01 00 00 00       	mov    ecx,0x1
  4107bc:	5d                   	pop    rbp
  4107bd:	5c                   	pop    rsp
	for (pgtbl_lvl = 1; pgtbl_lvl < COS_PGTBL_DEPTH - 1; pgtbl_lvl++) {
  4107be:	48 c7 45 b8 01 00 00 	mov    QWORD PTR [rbp-0x48],0x1
  4107c5:	00 
	return ci->memsrc;
  4107c6:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  4107ca:	4d 8b bd 08 01 00 00 	mov    r15,QWORD PTR [r13+0x108]
	range		 = cos_pgtbl_get_range(lvl);
  4107d1:	48 8b 1c c5 f0 f3 41 	mov    rbx,QWORD PTR [rax*8+0x41f3f0]
  4107d8:	00 
		return round_up_to_pgt2_page(vaddr);
  4107d9:	48 83 f8 02          	cmp    rax,0x2
  4107dd:	48 b8 00 00 20 00 80 	movabs rax,0x7f8000200000
  4107e4:	7f 00 00 
  4107e7:	48 89 5d 98          	mov    QWORD PTR [rbp-0x68],rbx
  4107eb:	48 bb 00 00 00 40 80 	movabs rbx,0x7f8040000000
  4107f2:	7f 00 00 
  4107f5:	48 0f 45 c3          	cmovne rax,rbx
  4107f9:	48 89 45 a0          	mov    QWORD PTR [rbp-0x60],rax
	for (addr = mem_ptr; addr < tmp_frontier; addr += range) {
  4107fd:	48 b8 00 00 00 00 80 	movabs rax,0x7f8000000000
  410804:	7f 00 00 
  410807:	48 89 45 a8          	mov    QWORD PTR [rbp-0x58],rax
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  41080b:	4d 3b bf 08 01 00 00 	cmp    r15,QWORD PTR [r15+0x108]
  410812:	0f 85 01 02 00 00    	jne    410a19 <cos_ulk_info_init+0x439>
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  410818:	0f 01 f9             	rdtscp 
	return (long)coreid;
  41081b:	48 89 ce             	mov    rsi,rcx
{ while (!ps_cas(&l->o, 0, 1)) ; }
  41081e:	49 8d 97 58 01 00 00 	lea    rdx,[r15+0x158]
        __asm__ __volatile__("lock " PS_CAS_STR
  410825:	31 c9                	xor    ecx,ecx
  410827:	81 e6 ff 0f 00 00    	and    esi,0xfff
		frontier = &ci->cap64_frontier[cos_cpuid()];
  41082d:	4d 8d a4 f7 a8 00 00 	lea    r12,[r15+rsi*8+0xa8]
  410834:	00 
{ while (!ps_cas(&l->o, 0, 1)) ; }
  410835:	0f 1f 00             	nop    DWORD PTR [rax]
        __asm__ __volatile__("lock " PS_CAS_STR
  410838:	bb 01 00 00 00       	mov    ebx,0x1
  41083d:	48 89 c8             	mov    rax,rcx
  410840:	f0 48 0f b1 1a       	lock cmpxchg QWORD PTR [rdx],rbx
  410845:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  410848:	84 c0                	test   al,al
  41084a:	74 ec                	je     410838 <cos_ulk_info_init+0x258>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  41084c:	48 8d 5e 14          	lea    rbx,[rsi+0x14]
  410850:	41 f6 84 f7 a8 00 00 	test   BYTE PTR [r15+rsi*8+0xa8],0x3
  410857:	00 03 
  410859:	0f 84 d6 01 00 00    	je     410a35 <cos_ulk_info_init+0x455>
        __asm__ __volatile__("lock " PS_FAA_STR
  41085f:	bb 04 00 00 00       	mov    ebx,0x4
  410864:	f0 49 0f c1 1c 24    	lock xadd QWORD PTR [r12],rbx
{ l->o = 0; }
  41086a:	49 c7 87 58 01 00 00 	mov    QWORD PTR [r15+0x158],0x0
  410871:	00 00 00 00 
	return __mem_bump_alloc(ci, 1, 1);
  410875:	4c 89 ff             	mov    rdi,r15
  410878:	e8 33 bf ff ff       	call   40c7b0 <__mem_bump_alloc.constprop.0>
  41087d:	48 89 c7             	mov    rdi,rax
		if (pte_cap == 0 || ptemem_cap == 0) {
  410880:	48 85 db             	test   rbx,rbx
  410883:	0f 84 58 01 00 00    	je     4109e1 <cos_ulk_info_init+0x401>
  410889:	48 85 c0             	test   rax,rax
  41088c:	4c 8d 55 c0          	lea    r10,[rbp-0x40]
  410890:	0f 84 4b 01 00 00    	je     4109e1 <cos_ulk_info_init+0x401>
		if (call_cap_op(meta->captbl_cap, CAPTBL_OP_PGTBLACTIVATE, pte_cap, meta->mi.pgtbl_cap, ptemem_cap,
  410896:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
	__asm__ __volatile__(
  41089a:	49 8b b7 40 01 00 00 	mov    rsi,QWORD PTR [r15+0x140]
  4108a1:	4c 89 d1             	mov    rcx,r10
  4108a4:	48 8d 50 01          	lea    rdx,[rax+0x1]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4108a8:	41 8b 47 08          	mov    eax,DWORD PTR [r15+0x8]
  4108ac:	48 89 55 90          	mov    QWORD PTR [rbp-0x70],rdx
  4108b0:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  4108b3:	05 1c 00 01 00       	add    eax,0x1001c
	__asm__ __volatile__(
  4108b8:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4108bb:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4108bf:	48 89 cd             	mov    rbp,rcx
  4108c2:	49 b8 d8 08 41 00 00 	movabs r8,0x4108d8
  4108c9:	00 00 00 
  4108cc:	0f 05                	syscall 
  4108ce:	66 90                	xchg   ax,ax
  4108d0:	eb 0d                	jmp    4108df <cos_ulk_info_init+0x2ff>
  4108d2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4108d8:	b9 00 00 00 00       	mov    ecx,0x0
  4108dd:	eb 05                	jmp    4108e4 <cos_ulk_info_init+0x304>
  4108df:	b9 01 00 00 00       	mov    ecx,0x1
  4108e4:	5d                   	pop    rbp
  4108e5:	5c                   	pop    rsp
  4108e6:	85 c0                	test   eax,eax
  4108e8:	0f 85 c4 00 00 00    	jne    4109b2 <cos_ulk_info_init+0x3d2>
  4108ee:	31 d2                	xor    edx,edx
  4108f0:	8b 45 b4             	mov    eax,DWORD PTR [rbp-0x4c]
  4108f3:	48 8b 75 a8          	mov    rsi,QWORD PTR [rbp-0x58]
  4108f7:	4c 89 d1             	mov    rcx,r10
  4108fa:	48 89 d7             	mov    rdi,rdx
  4108fd:	48 89 29             	mov    QWORD PTR [rcx],rbp
  410900:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  410904:	48 89 cd             	mov    rbp,rcx
  410907:	49 b8 20 09 41 00 00 	movabs r8,0x410920
  41090e:	00 00 00 
  410911:	0f 05                	syscall 
  410913:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  410918:	eb 0d                	jmp    410927 <cos_ulk_info_init+0x347>
  41091a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410920:	b9 00 00 00 00       	mov    ecx,0x0
  410925:	eb 05                	jmp    41092c <cos_ulk_info_init+0x34c>
  410927:	b9 01 00 00 00       	mov    ecx,0x1
  41092c:	5d                   	pop    rbp
  41092d:	5c                   	pop    rsp
	for (addr = mem_ptr; addr < tmp_frontier; addr += range) {
  41092e:	48 8b 45 98          	mov    rax,QWORD PTR [rbp-0x68]
  410932:	48 01 c6             	add    rsi,rax
  410935:	48 89 75 a8          	mov    QWORD PTR [rbp-0x58],rsi
  410939:	48 39 75 a0          	cmp    QWORD PTR [rbp-0x60],rsi
  41093d:	0f 87 c8 fe ff ff    	ja     41080b <cos_ulk_info_init+0x22b>
	for (pgtbl_lvl = 1; pgtbl_lvl < COS_PGTBL_DEPTH - 1; pgtbl_lvl++) {
  410943:	48 83 7d 90 03       	cmp    QWORD PTR [rbp-0x70],0x3
  410948:	48 c7 45 b8 02 00 00 	mov    QWORD PTR [rbp-0x48],0x2
  41094f:	00 
  410950:	0f 85 70 fe ff ff    	jne    4107c6 <cos_ulk_info_init+0x1e6>
	__cos_ulk_info.pg_frontier = ULK_BASE_ADDR + __thdid_alloc * sizeof(struct ulk_invstk);
  410956:	48 b8 00 00 00 80 7f 	movabs rax,0x7f80000000
  41095d:	00 00 00 
  410960:	48 03 05 99 b6 1a 00 	add    rax,QWORD PTR [rip+0x1ab699]        # 5bc000 <__thdid_alloc>
	__cos_ulk_info.toplvl = cos_ulk_pgtbl_create(ci, &__cos_ulk_info.secondlvl);
  410967:	4c 89 35 12 91 2f 00 	mov    QWORD PTR [rip+0x2f9112],r14        # 709a80 <__cos_ulk_info>
	__cos_ulk_info.pg_frontier = ULK_BASE_ADDR + __thdid_alloc * sizeof(struct ulk_invstk);
  41096e:	48 c1 e0 08          	shl    rax,0x8
  410972:	48 89 05 1f 91 2f 00 	mov    QWORD PTR [rip+0x2f911f],rax        # 709a98 <__cos_ulk_info+0x18>
	assert(__cos_ulk_info.toplvl);
  410979:	4d 85 f6             	test   r14,r14
  41097c:	0f 84 e1 fc ff ff    	je     410663 <cos_ulk_info_init+0x83>
}
  410982:	48 83 c4 48          	add    rsp,0x48
  410986:	5b                   	pop    rbx
  410987:	41 5c                	pop    r12
  410989:	41 5d                	pop    r13
  41098b:	41 5e                	pop    r14
  41098d:	41 5f                	pop    r15
  41098f:	5d                   	pop    rbp
  410990:	c3                   	ret    
		if (__capid_captbl_check_expand(ci)) goto error;
  410991:	4c 89 ff             	mov    rdi,r15
  410994:	e8 a7 bf ff ff       	call   40c940 <__capid_captbl_check_expand>
  410999:	85 c0                	test   eax,eax
  41099b:	75 31                	jne    4109ce <cos_ulk_info_init+0x3ee>
        __asm__ __volatile__("lock " PS_FAA_STR
  41099d:	b8 04 00 00 00       	mov    eax,0x4
  4109a2:	f0 49 0f c1 47 18    	lock xadd QWORD PTR [r15+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  4109a8:	49 89 44 df 08       	mov    QWORD PTR [r15+rbx*8+0x8],rax
  4109ad:	e9 30 fd ff ff       	jmp    4106e2 <cos_ulk_info_init+0x102>
  4109b2:	be 2e 00 00 00       	mov    esi,0x2e
  4109b7:	bf 90 e2 41 00       	mov    edi,0x41e290
  4109bc:	e8 bf a2 ff ff       	call   40ac80 <cos_print_str>
				assert(0); /* race? */
  4109c1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4109c8:	00 00 00 00 
  4109cc:	0f 0b                	ud2    
{ l->o = 0; }
  4109ce:	49 c7 87 58 01 00 00 	mov    QWORD PTR [r15+0x158],0x0
  4109d5:	00 00 00 00 
	return __mem_bump_alloc(ci, 1, 1);
  4109d9:	4c 89 ff             	mov    rdi,r15
  4109dc:	e8 cf bd ff ff       	call   40c7b0 <__mem_bump_alloc.constprop.0>
  4109e1:	be 2e 00 00 00       	mov    esi,0x2e
  4109e6:	bf 60 e2 41 00       	mov    edi,0x41e260
  4109eb:	e8 90 a2 ff ff       	call   40ac80 <cos_print_str>
			assert(0);
  4109f0:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4109f7:	00 00 00 00 
  4109fb:	0f 0b                	ud2    
  4109fd:	be 2e 00 00 00       	mov    esi,0x2e
  410a02:	bf 78 ec 41 00       	mov    edi,0x41ec78
  410a07:	e8 74 a2 ff ff       	call   40ac80 <cos_print_str>
	assert(ci && secondlvl);
  410a0c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410a13:	00 00 00 00 
  410a17:	0f 0b                	ud2    
  410a19:	be 2e 00 00 00       	mov    esi,0x2e
  410a1e:	bf 30 e2 41 00       	mov    edi,0x41e230
  410a23:	e8 58 a2 ff ff       	call   40ac80 <cos_print_str>
	assert(meta == __compinfo_metacap(meta)); /* prevent unbounded structures */
  410a28:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410a2f:	00 00 00 00 
  410a33:	0f 0b                	ud2    
		if (__capid_captbl_check_expand(ci)) goto error;
  410a35:	4c 89 ff             	mov    rdi,r15
  410a38:	e8 03 bf ff ff       	call   40c940 <__capid_captbl_check_expand>
  410a3d:	85 c0                	test   eax,eax
  410a3f:	75 8d                	jne    4109ce <cos_ulk_info_init+0x3ee>
        __asm__ __volatile__("lock " PS_FAA_STR
  410a41:	b8 04 00 00 00       	mov    eax,0x4
  410a46:	f0 49 0f c1 47 18    	lock xadd QWORD PTR [r15+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  410a4c:	49 89 44 df 08       	mov    QWORD PTR [r15+rbx*8+0x8],rax
  410a51:	e9 09 fe ff ff       	jmp    41085f <cos_ulk_info_init+0x27f>
  410a56:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  410a5d:	00 00 00 

0000000000410a60 <cos_comp_alloc_with>:

int
cos_comp_alloc_with(struct cos_compinfo *ci, compcap_t comp, u32_t lid, captblcap_t ctc, pgtblcap_t ptc, vaddr_t entry, prot_domain_t protdom)
{
  410a60:	f3 0f 1e fa          	endbr64 
  410a64:	55                   	push   rbp
  410a65:	41 89 d3             	mov    r11d,edx
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_COMPACTIVATE, comp, (ctc << 16) | ptc, ((unsigned long)lid << 32) | protdom, entry)) return 1;
  410a68:	48 c1 e1 10          	shl    rcx,0x10
{
  410a6c:	49 89 f2             	mov    r10,rsi
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_COMPACTIVATE, comp, (ctc << 16) | ptc, ((unsigned long)lid << 32) | protdom, entry)) return 1;
  410a6f:	48 89 ce             	mov    rsi,rcx
{
  410a72:	4c 89 ca             	mov    rdx,r9
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_COMPACTIVATE, comp, (ctc << 16) | ptc, ((unsigned long)lid << 32) | protdom, entry)) return 1;
  410a75:	4c 09 c6             	or     rsi,r8
{
  410a78:	48 89 e5             	mov    rbp,rsp
  410a7b:	41 54                	push   r12
  410a7d:	53                   	push   rbx
  410a7e:	4c 89 d3             	mov    rbx,r10
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_COMPACTIVATE, comp, (ctc << 16) | ptc, ((unsigned long)lid << 32) | protdom, entry)) return 1;
  410a81:	48 8b 47 08          	mov    rax,QWORD PTR [rdi+0x8]
  410a85:	8b 4d 10             	mov    ecx,DWORD PTR [rbp+0x10]
  410a88:	4c 89 df             	mov    rdi,r11
  410a8b:	48 c1 e7 20          	shl    rdi,0x20
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  410a8f:	c1 e0 10             	shl    eax,0x10
  410a92:	48 09 cf             	or     rdi,rcx
	__asm__ __volatile__(
  410a95:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
	cap_no += op;
  410a99:	05 0d 00 01 00       	add    eax,0x1000d
	__asm__ __volatile__(
  410a9e:	48 89 29             	mov    QWORD PTR [rcx],rbp
  410aa1:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  410aa5:	48 89 cd             	mov    rbp,rcx
  410aa8:	49 b8 c0 0a 41 00 00 	movabs r8,0x410ac0
  410aaf:	00 00 00 
  410ab2:	0f 05                	syscall 
  410ab4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  410ab8:	eb 0d                	jmp    410ac7 <cos_comp_alloc_with+0x67>
  410aba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410ac0:	b9 00 00 00 00       	mov    ecx,0x0
  410ac5:	eb 05                	jmp    410acc <cos_comp_alloc_with+0x6c>
  410ac7:	b9 01 00 00 00       	mov    ecx,0x1
  410acc:	5d                   	pop    rbp
  410acd:	5c                   	pop    rsp
  410ace:	85 c0                	test   eax,eax
  410ad0:	0f 95 c0             	setne  al

	return 0;
}
  410ad3:	5b                   	pop    rbx
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_COMPACTIVATE, comp, (ctc << 16) | ptc, ((unsigned long)lid << 32) | protdom, entry)) return 1;
  410ad4:	0f b6 c0             	movzx  eax,al
}
  410ad7:	41 5c                	pop    r12
  410ad9:	5d                   	pop    rbp
  410ada:	c3                   	ret    
  410adb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000410ae0 <cos_comp_alloc>:

compcap_t
cos_comp_alloc(struct cos_compinfo *ci, captblcap_t ctc, pgtblcap_t ptc, vaddr_t entry, prot_domain_t protdom)
{
  410ae0:	f3 0f 1e fa          	endbr64 
  410ae4:	55                   	push   rbp
  410ae5:	48 89 e5             	mov    rbp,rsp
  410ae8:	41 57                	push   r15
  410aea:	41 56                	push   r14
  410aec:	41 55                	push   r13
  410aee:	41 54                	push   r12
  410af0:	53                   	push   rbx
  410af1:	48 83 ec 38          	sub    rsp,0x38
	return livenessid_frontier++;
  410af5:	44 8b 0d 44 b5 1a 00 	mov    r9d,DWORD PTR [rip+0x1ab544]        # 5bc040 <livenessid_frontier>
  410afc:	41 8d 41 01          	lea    eax,[r9+0x1]
  410b00:	89 05 3a b5 1a 00    	mov    DWORD PTR [rip+0x1ab53a],eax        # 5bc040 <livenessid_frontier>
	capid_t cap;
	u32_t   lid = livenessid_bump_alloc();

	printd("cos_comp_alloc\n");

	assert(ci && ctc && ptc && lid);
  410b06:	48 85 ff             	test   rdi,rdi
  410b09:	0f 84 70 01 00 00    	je     410c7f <cos_comp_alloc+0x19f>
  410b0f:	49 89 f7             	mov    r15,rsi
  410b12:	48 85 f6             	test   rsi,rsi
  410b15:	0f 84 64 01 00 00    	je     410c7f <cos_comp_alloc+0x19f>
  410b1b:	48 89 d6             	mov    rsi,rdx
  410b1e:	48 85 d2             	test   rdx,rdx
  410b21:	0f 84 58 01 00 00    	je     410c7f <cos_comp_alloc+0x19f>
  410b27:	45 85 c9             	test   r9d,r9d
  410b2a:	0f 84 4f 01 00 00    	je     410c7f <cos_comp_alloc+0x19f>
  410b30:	49 89 fc             	mov    r12,rdi
  410b33:	49 89 ce             	mov    r14,rcx
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  410b36:	0f 01 f9             	rdtscp 
	return (long)coreid;
  410b39:	49 89 cb             	mov    r11,rcx
{ while (!ps_cas(&l->o, 0, 1)) ; }
  410b3c:	48 8d 97 58 01 00 00 	lea    rdx,[rdi+0x158]
        __asm__ __volatile__("lock " PS_CAS_STR
  410b43:	31 c9                	xor    ecx,ecx
  410b45:	41 81 e3 ff 0f 00 00 	and    r11d,0xfff
		frontier = &ci->cap64_frontier[cos_cpuid()];
  410b4c:	4e 8d 94 df a8 00 00 	lea    r10,[rdi+r11*8+0xa8]
  410b53:	00 
  410b54:	bf 01 00 00 00       	mov    edi,0x1
  410b59:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  410b60:	48 89 c8             	mov    rax,rcx
  410b63:	f0 48 0f b1 3a       	lock cmpxchg QWORD PTR [rdx],rdi
  410b68:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  410b6b:	84 c0                	test   al,al
  410b6d:	74 f1                	je     410b60 <cos_comp_alloc+0x80>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  410b6f:	49 8d 5b 14          	lea    rbx,[r11+0x14]
  410b73:	4d 8b 6c dc 08       	mov    r13,QWORD PTR [r12+rbx*8+0x8]
  410b78:	41 83 e5 03          	and    r13d,0x3
  410b7c:	0f 84 8e 00 00 00    	je     410c10 <cos_comp_alloc+0x130>
        __asm__ __volatile__("lock " PS_FAA_STR
  410b82:	bb 04 00 00 00       	mov    ebx,0x4
  410b87:	f0 49 0f c1 1a       	lock xadd QWORD PTR [r10],rbx
{ l->o = 0; }
  410b8c:	49 c7 84 24 58 01 00 	mov    QWORD PTR [r12+0x158],0x0
  410b93:	00 00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  410b98:	49 89 dd             	mov    r13,rbx

	cap = __capid_bump_alloc(ci, CAP_COMP);
	if (!cap) return 0;
  410b9b:	48 85 db             	test   rbx,rbx
  410b9e:	74 5a                	je     410bfa <cos_comp_alloc+0x11a>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_COMPACTIVATE, comp, (ctc << 16) | ptc, ((unsigned long)lid << 32) | protdom, entry)) return 1;
  410ba0:	49 8b 44 24 08       	mov    rax,QWORD PTR [r12+0x8]
  410ba5:	4c 89 cf             	mov    rdi,r9
  410ba8:	49 c1 e7 10          	shl    r15,0x10
  410bac:	45 89 c0             	mov    r8d,r8d
  410baf:	48 c1 e7 20          	shl    rdi,0x20
  410bb3:	4c 09 fe             	or     rsi,r15
	__asm__ __volatile__(
  410bb6:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  410bba:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  410bbd:	c1 e0 10             	shl    eax,0x10
  410bc0:	4c 09 c7             	or     rdi,r8
	cap_no += op;
  410bc3:	05 0d 00 01 00       	add    eax,0x1000d
	__asm__ __volatile__(
  410bc8:	48 89 29             	mov    QWORD PTR [rcx],rbp
  410bcb:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  410bcf:	48 89 cd             	mov    rbp,rcx
  410bd2:	49 b8 e8 0b 41 00 00 	movabs r8,0x410be8
  410bd9:	00 00 00 
  410bdc:	0f 05                	syscall 
  410bde:	66 90                	xchg   ax,ax
  410be0:	eb 0d                	jmp    410bef <cos_comp_alloc+0x10f>
  410be2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410be8:	b9 00 00 00 00       	mov    ecx,0x0
  410bed:	eb 05                	jmp    410bf4 <cos_comp_alloc+0x114>
  410bef:	b9 01 00 00 00       	mov    ecx,0x1
  410bf4:	5d                   	pop    rbp
  410bf5:	5c                   	pop    rsp
  410bf6:	85 c0                	test   eax,eax
  410bf8:	75 58                	jne    410c52 <cos_comp_alloc+0x172>
	if (cos_comp_alloc_with(ci, cap, lid, ctc, ptc, entry, protdom)) BUG();

	return cap;
}
  410bfa:	48 83 c4 38          	add    rsp,0x38
  410bfe:	4c 89 e8             	mov    rax,r13
  410c01:	5b                   	pop    rbx
  410c02:	41 5c                	pop    r12
  410c04:	41 5d                	pop    r13
  410c06:	41 5e                	pop    r14
  410c08:	41 5f                	pop    r15
  410c0a:	5d                   	pop    rbp
  410c0b:	c3                   	ret    
  410c0c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  410c10:	4c 89 e7             	mov    rdi,r12
  410c13:	44 89 45 b8          	mov    DWORD PTR [rbp-0x48],r8d
  410c17:	48 89 75 a8          	mov    QWORD PTR [rbp-0x58],rsi
  410c1b:	4c 89 55 b0          	mov    QWORD PTR [rbp-0x50],r10
  410c1f:	44 89 4d bc          	mov    DWORD PTR [rbp-0x44],r9d
  410c23:	e8 18 bd ff ff       	call   40c940 <__capid_captbl_check_expand>
  410c28:	44 8b 4d bc          	mov    r9d,DWORD PTR [rbp-0x44]
  410c2c:	4c 8b 55 b0          	mov    r10,QWORD PTR [rbp-0x50]
  410c30:	85 c0                	test   eax,eax
  410c32:	48 8b 75 a8          	mov    rsi,QWORD PTR [rbp-0x58]
  410c36:	44 8b 45 b8          	mov    r8d,DWORD PTR [rbp-0x48]
  410c3a:	75 32                	jne    410c6e <cos_comp_alloc+0x18e>
        __asm__ __volatile__("lock " PS_FAA_STR
  410c3c:	b8 04 00 00 00       	mov    eax,0x4
  410c41:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  410c48:	49 89 44 dc 08       	mov    QWORD PTR [r12+rbx*8+0x8],rax
  410c4d:	e9 30 ff ff ff       	jmp    410b82 <cos_comp_alloc+0xa2>
  410c52:	be 1c 00 00 00       	mov    esi,0x1c
  410c57:	bf 08 ed 41 00       	mov    edi,0x41ed08
  410c5c:	e8 1f a0 ff ff       	call   40ac80 <cos_print_str>
	if (cos_comp_alloc_with(ci, cap, lid, ctc, ptc, entry, protdom)) BUG();
  410c61:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410c68:	00 00 00 00 
  410c6c:	0f 0b                	ud2    
{ l->o = 0; }
  410c6e:	49 c7 84 24 58 01 00 	mov    QWORD PTR [r12+0x158],0x0
  410c75:	00 00 00 00 00 
	if (!cap) return 0;
  410c7a:	e9 7b ff ff ff       	jmp    410bfa <cos_comp_alloc+0x11a>
  410c7f:	be 2f 00 00 00       	mov    esi,0x2f
  410c84:	bf d8 ec 41 00       	mov    edi,0x41ecd8
  410c89:	e8 f2 9f ff ff       	call   40ac80 <cos_print_str>
	assert(ci && ctc && ptc && lid);
  410c8e:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410c95:	00 00 00 00 
  410c99:	0f 0b                	ud2    
  410c9b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000410ca0 <cos_comp_alloc_shared>:

int
cos_comp_alloc_shared(struct cos_compinfo *ci, pgtblcap_t ptc, vaddr_t entry, struct cos_compinfo *ci_resources, prot_domain_t protdom)
{
  410ca0:	f3 0f 1e fa          	endbr64 
  410ca4:	55                   	push   rbp
  410ca5:	48 89 e5             	mov    rbp,rsp
  410ca8:	41 57                	push   r15
  410caa:	49 89 f7             	mov    r15,rsi
  410cad:	41 56                	push   r14
  410caf:	41 55                	push   r13
  410cb1:	41 54                	push   r12
  410cb3:	53                   	push   rbx
  410cb4:	48 83 ec 38          	sub    rsp,0x38
	compcap_t   compc;
	captblcap_t ctc = ci->captbl_cap;
  410cb8:	48 8b 77 08          	mov    rsi,QWORD PTR [rdi+0x8]

	printd("cos_compinfo_alloc_shared\n");
	assert(ptc);
  410cbc:	4d 85 ff             	test   r15,r15
  410cbf:	0f 84 a9 01 00 00    	je     410e6e <cos_comp_alloc_shared+0x1ce>
	assert(ctc);
  410cc5:	48 85 f6             	test   rsi,rsi
  410cc8:	0f 84 bc 01 00 00    	je     410e8a <cos_comp_alloc_shared+0x1ea>
	return livenessid_frontier++;
  410cce:	44 8b 0d 6b b3 1a 00 	mov    r9d,DWORD PTR [rip+0x1ab36b]        # 5bc040 <livenessid_frontier>
  410cd5:	49 89 cc             	mov    r12,rcx
  410cd8:	41 8d 41 01          	lea    eax,[r9+0x1]
  410cdc:	89 05 5e b3 1a 00    	mov    DWORD PTR [rip+0x1ab35e],eax        # 5bc040 <livenessid_frontier>
	assert(ci && ctc && ptc && lid);
  410ce2:	48 85 c9             	test   rcx,rcx
  410ce5:	0f 84 4b 01 00 00    	je     410e36 <cos_comp_alloc_shared+0x196>
  410ceb:	45 85 c9             	test   r9d,r9d
  410cee:	0f 84 42 01 00 00    	je     410e36 <cos_comp_alloc_shared+0x196>
  410cf4:	49 89 fd             	mov    r13,rdi
  410cf7:	49 89 d6             	mov    r14,rdx
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  410cfa:	0f 01 f9             	rdtscp 
	return (long)coreid;
  410cfd:	49 89 cb             	mov    r11,rcx
{ while (!ps_cas(&l->o, 0, 1)) ; }
  410d00:	49 8d 94 24 58 01 00 	lea    rdx,[r12+0x158]
  410d07:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  410d08:	bf 01 00 00 00       	mov    edi,0x1
  410d0d:	31 c9                	xor    ecx,ecx
  410d0f:	41 81 e3 ff 0f 00 00 	and    r11d,0xfff
		frontier = &ci->cap64_frontier[cos_cpuid()];
  410d16:	4f 8d 94 dc a8 00 00 	lea    r10,[r12+r11*8+0xa8]
  410d1d:	00 
{ while (!ps_cas(&l->o, 0, 1)) ; }
  410d1e:	66 90                	xchg   ax,ax
        __asm__ __volatile__("lock " PS_CAS_STR
  410d20:	48 89 c8             	mov    rax,rcx
  410d23:	f0 48 0f b1 3a       	lock cmpxchg QWORD PTR [rdx],rdi
  410d28:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  410d2b:	84 c0                	test   al,al
  410d2d:	74 f1                	je     410d20 <cos_comp_alloc_shared+0x80>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  410d2f:	49 8d 5b 14          	lea    rbx,[r11+0x14]
  410d33:	43 f6 84 dc a8 00 00 	test   BYTE PTR [r12+r11*8+0xa8],0x3
  410d3a:	00 03 
  410d3c:	0f 84 ae 00 00 00    	je     410df0 <cos_comp_alloc_shared+0x150>
        __asm__ __volatile__("lock " PS_FAA_STR
  410d42:	bb 04 00 00 00       	mov    ebx,0x4
  410d47:	f0 49 0f c1 1a       	lock xadd QWORD PTR [r10],rbx
        return inc;
  410d4c:	66 48 0f 6e c3       	movq   xmm0,rbx
  410d51:	66 49 0f 6e cf       	movq   xmm1,r15
{ l->o = 0; }
  410d56:	49 c7 84 24 58 01 00 	mov    QWORD PTR [r12+0x158],0x0
  410d5d:	00 00 00 00 00 
  410d62:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
	if (!cap) return 0;
  410d66:	48 85 db             	test   rbx,rbx
  410d69:	0f 84 49 01 00 00    	je     410eb8 <cos_comp_alloc_shared+0x218>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_COMPACTIVATE, comp, (ctc << 16) | ptc, ((unsigned long)lid << 32) | protdom, entry)) return 1;
  410d6f:	49 8b 44 24 08       	mov    rax,QWORD PTR [r12+0x8]
  410d74:	4c 89 cf             	mov    rdi,r9
  410d77:	48 c1 e6 10          	shl    rsi,0x10
  410d7b:	45 89 c0             	mov    r8d,r8d
  410d7e:	48 c1 e7 20          	shl    rdi,0x20
  410d82:	4c 09 fe             	or     rsi,r15
	__asm__ __volatile__(
  410d85:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  410d89:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  410d8c:	c1 e0 10             	shl    eax,0x10
  410d8f:	4c 09 c7             	or     rdi,r8
	cap_no += op;
  410d92:	05 0d 00 01 00       	add    eax,0x1000d
	__asm__ __volatile__(
  410d97:	48 89 29             	mov    QWORD PTR [rcx],rbp
  410d9a:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  410d9e:	48 89 cd             	mov    rbp,rcx
  410da1:	49 b8 b8 0d 41 00 00 	movabs r8,0x410db8
  410da8:	00 00 00 
  410dab:	0f 05                	syscall 
  410dad:	0f 1f 00             	nop    DWORD PTR [rax]
  410db0:	eb 0d                	jmp    410dbf <cos_comp_alloc_shared+0x11f>
  410db2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410db8:	b9 00 00 00 00       	mov    ecx,0x0
  410dbd:	eb 05                	jmp    410dc4 <cos_comp_alloc_shared+0x124>
  410dbf:	b9 01 00 00 00       	mov    ecx,0x1
  410dc4:	5d                   	pop    rbp
  410dc5:	5c                   	pop    rsp
  410dc6:	85 c0                	test   eax,eax
  410dc8:	0f 85 84 00 00 00    	jne    410e52 <cos_comp_alloc_shared+0x1b2>
	compc = cos_comp_alloc(ci_resources, ctc, ptc, entry, protdom);
	assert(compc);

	ci->comp_cap_shared = compc;
  410dce:	41 0f 11 85 70 01 00 	movups XMMWORD PTR [r13+0x170],xmm0
  410dd5:	00 
	ci->pgtbl_cap_shared = ptc;

	return 0;
}
  410dd6:	48 83 c4 38          	add    rsp,0x38
  410dda:	31 c0                	xor    eax,eax
  410ddc:	5b                   	pop    rbx
  410ddd:	41 5c                	pop    r12
  410ddf:	41 5d                	pop    r13
  410de1:	41 5e                	pop    r14
  410de3:	41 5f                	pop    r15
  410de5:	5d                   	pop    rbp
  410de6:	c3                   	ret    
  410de7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  410dee:	00 00 
		if (__capid_captbl_check_expand(ci)) goto error;
  410df0:	4c 89 e7             	mov    rdi,r12
  410df3:	44 89 45 b0          	mov    DWORD PTR [rbp-0x50],r8d
  410df7:	4c 89 55 a8          	mov    QWORD PTR [rbp-0x58],r10
  410dfb:	44 89 4d b4          	mov    DWORD PTR [rbp-0x4c],r9d
  410dff:	48 89 75 b8          	mov    QWORD PTR [rbp-0x48],rsi
  410e03:	e8 38 bb ff ff       	call   40c940 <__capid_captbl_check_expand>
  410e08:	48 8b 75 b8          	mov    rsi,QWORD PTR [rbp-0x48]
  410e0c:	44 8b 4d b4          	mov    r9d,DWORD PTR [rbp-0x4c]
  410e10:	85 c0                	test   eax,eax
  410e12:	4c 8b 55 a8          	mov    r10,QWORD PTR [rbp-0x58]
  410e16:	44 8b 45 b0          	mov    r8d,DWORD PTR [rbp-0x50]
  410e1a:	0f 85 86 00 00 00    	jne    410ea6 <cos_comp_alloc_shared+0x206>
        __asm__ __volatile__("lock " PS_FAA_STR
  410e20:	b8 04 00 00 00       	mov    eax,0x4
  410e25:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  410e2c:	49 89 44 dc 08       	mov    QWORD PTR [r12+rbx*8+0x8],rax
  410e31:	e9 0c ff ff ff       	jmp    410d42 <cos_comp_alloc_shared+0xa2>
  410e36:	be 2f 00 00 00       	mov    esi,0x2f
  410e3b:	bf d8 ec 41 00       	mov    edi,0x41ecd8
  410e40:	e8 3b 9e ff ff       	call   40ac80 <cos_print_str>
	assert(ci && ctc && ptc && lid);
  410e45:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410e4c:	00 00 00 00 
  410e50:	0f 0b                	ud2    
  410e52:	be 1c 00 00 00       	mov    esi,0x1c
  410e57:	bf 08 ed 41 00       	mov    edi,0x41ed08
  410e5c:	e8 1f 9e ff ff       	call   40ac80 <cos_print_str>
	if (cos_comp_alloc_with(ci, cap, lid, ctc, ptc, entry, protdom)) BUG();
  410e61:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410e68:	00 00 00 00 
  410e6c:	0f 0b                	ud2    
  410e6e:	be 2f 00 00 00       	mov    esi,0x2f
  410e73:	bf 28 ed 41 00       	mov    edi,0x41ed28
  410e78:	e8 03 9e ff ff       	call   40ac80 <cos_print_str>
	assert(ptc);
  410e7d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410e84:	00 00 00 00 
  410e88:	0f 0b                	ud2    
  410e8a:	be 2f 00 00 00       	mov    esi,0x2f
  410e8f:	bf 58 ed 41 00       	mov    edi,0x41ed58
  410e94:	e8 e7 9d ff ff       	call   40ac80 <cos_print_str>
	assert(ctc);
  410e99:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410ea0:	00 00 00 00 
  410ea4:	0f 0b                	ud2    
{ l->o = 0; }
  410ea6:	49 c7 84 24 58 01 00 	mov    QWORD PTR [r12+0x158],0x0
  410ead:	00 00 00 00 00 
	assert(compc);
  410eb2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  410eb8:	be 2f 00 00 00       	mov    esi,0x2f
  410ebd:	bf 88 ed 41 00       	mov    edi,0x41ed88
  410ec2:	e8 b9 9d ff ff       	call   40ac80 <cos_print_str>
  410ec7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  410ece:	00 00 00 00 
  410ed2:	0f 0b                	ud2    
  410ed4:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  410edb:	00 00 00 00 
  410edf:	90                   	nop

0000000000410ee0 <cos_compinfo_alloc>:
}

int
cos_compinfo_alloc(struct cos_compinfo *ci, vaddr_t heap_ptr, capid_t cap_frontier, vaddr_t entry,
                   struct cos_compinfo *ci_resources, prot_domain_t protdom)
{
  410ee0:	f3 0f 1e fa          	endbr64 
  410ee4:	55                   	push   rbp
	vaddr_t     last_page;
	word_t      pgtbl_lvl;
	u8_t        mem_type = PGTBL_TYPE_DEF;
	word_t      pgtbl_lvl_flag = 0;

	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  410ee5:	b8 01 00 00 80       	mov    eax,0x80000001
{
  410eea:	48 89 e5             	mov    rbp,rsp
  410eed:	41 57                	push   r15
  410eef:	41 56                	push   r14
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  410ef1:	41 be 01 00 00 00    	mov    r14d,0x1
{
  410ef7:	41 55                	push   r13
  410ef9:	49 89 fd             	mov    r13,rdi
  410efc:	41 54                	push   r12
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  410efe:	41 bc 00 00 00 00    	mov    r12d,0x0
{
  410f04:	53                   	push   rbx
  410f05:	4c 89 c3             	mov    rbx,r8
  410f08:	48 83 ec 38          	sub    rsp,0x38
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  410f0c:	80 bf 80 01 00 00 01 	cmp    BYTE PTR [rdi+0x180],0x1
{
  410f13:	48 89 55 a8          	mov    QWORD PTR [rbp-0x58],rdx
		pgtbl_lvl_flag = PGTBL_LVL_FLAG_VM;
	}

	printd("cos_compinfo_alloc\n");

	ptc = cos_pgtbl_alloc(ci_resources, mem_type);
  410f17:	4c 89 c7             	mov    rdi,r8
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  410f1a:	4c 0f 44 f0          	cmove  r14,rax
  410f1e:	ba 02 00 00 00       	mov    edx,0x2
  410f23:	48 8d 40 01          	lea    rax,[rax+0x1]
{
  410f27:	48 89 75 b0          	mov    QWORD PTR [rbp-0x50],rsi
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  410f2b:	48 0f 45 c2          	cmovne rax,rdx
  410f2f:	40 0f 94 c6          	sete   sil
{
  410f33:	48 89 4d c8          	mov    QWORD PTR [rbp-0x38],rcx
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  410f37:	40 0f b6 f6          	movzx  esi,sil
{
  410f3b:	44 89 4d c4          	mov    DWORD PTR [rbp-0x3c],r9d
	if (unlikely(ci->comp_type == COMP_TYPE_VM)) {
  410f3f:	48 89 45 b8          	mov    QWORD PTR [rbp-0x48],rax
  410f43:	b8 00 00 00 80       	mov    eax,0x80000000
  410f48:	4c 0f 44 e0          	cmove  r12,rax
	ptc = cos_pgtbl_alloc(ci_resources, mem_type);
  410f4c:	e8 df f0 ff ff       	call   410030 <cos_pgtbl_alloc>
	assert(ptc);
  410f51:	48 85 c0             	test   rax,rax
  410f54:	0f 84 3e 01 00 00    	je     411098 <cos_compinfo_alloc+0x1b8>
	ctc = cos_captbl_alloc(ci_resources);
  410f5a:	48 89 df             	mov    rdi,rbx
  410f5d:	49 89 c7             	mov    r15,rax
  410f60:	e8 4b ef ff ff       	call   40feb0 <cos_captbl_alloc>
	assert(ctc);
  410f65:	48 85 c0             	test   rax,rax
  410f68:	0f 84 46 01 00 00    	je     4110b4 <cos_compinfo_alloc+0x1d4>
	compc = cos_comp_alloc(ci_resources, ctc, ptc, entry, protdom);
  410f6e:	48 8b 4d c8          	mov    rcx,QWORD PTR [rbp-0x38]
  410f72:	44 8b 45 c4          	mov    r8d,DWORD PTR [rbp-0x3c]
  410f76:	4c 89 fa             	mov    rdx,r15
  410f79:	48 89 c6             	mov    rsi,rax
  410f7c:	48 89 df             	mov    rdi,rbx
  410f7f:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
  410f83:	e8 58 fb ff ff       	call   410ae0 <cos_comp_alloc>
	assert(compc);
  410f88:	4c 8b 55 c8          	mov    r10,QWORD PTR [rbp-0x38]
  410f8c:	48 85 c0             	test   rax,rax
	compc = cos_comp_alloc(ci_resources, ctc, ptc, entry, protdom);
  410f8f:	48 89 c1             	mov    rcx,rax
	assert(compc);
  410f92:	0f 84 38 01 00 00    	je     4110d0 <cos_compinfo_alloc+0x1f0>

	cos_compinfo_init(ci, ptc, ctc, compc, heap_ptr, cap_frontier, ci_resources);
  410f98:	48 83 ec 08          	sub    rsp,0x8
  410f9c:	4c 8b 4d a8          	mov    r9,QWORD PTR [rbp-0x58]
  410fa0:	4c 89 d2             	mov    rdx,r10
  410fa3:	4c 89 fe             	mov    rsi,r15
  410fa6:	53                   	push   rbx
  410fa7:	48 8b 5d b0          	mov    rbx,QWORD PTR [rbp-0x50]
  410fab:	4c 89 ef             	mov    rdi,r13
  410fae:	49 89 d8             	mov    r8,rbx
  410fb1:	e8 5a c7 ff ff       	call   40d710 <cos_compinfo_init>

	ci->mi.second_lvl_pgtbl_cap  = __bump_mem_expand_intern(__compinfo_metacap(ci), ci->pgtbl_cap, heap_ptr, 0, 0 | pgtbl_lvl_flag);
  410fb6:	49 8b 75 00          	mov    rsi,QWORD PTR [r13+0x0]
  410fba:	48 89 da             	mov    rdx,rbx
  410fbd:	31 c9                	xor    ecx,ecx
  410fbf:	49 8b bd 08 01 00 00 	mov    rdi,QWORD PTR [r13+0x108]
  410fc6:	4d 89 e0             	mov    r8,r12
  410fc9:	e8 a2 c3 ff ff       	call   40d370 <__bump_mem_expand_intern>
  410fce:	66 48 0f 6e cb       	movq   xmm1,rbx
  410fd3:	66 48 0f 6e c0       	movq   xmm0,rax

	/* 
	 * This is to make sure that "the address below vas_frontier has been allocated, 
	 * follow the assumption we put in cos_vasfrontier_init()"
	 */
	last_page = round_to_page(ci->vas_frontier - 1);
  410fd8:	49 8b 85 e8 00 00 00 	mov    rax,QWORD PTR [r13+0xe8]
	ci->mi.second_lvl_pgtbl_cap  = __bump_mem_expand_intern(__compinfo_metacap(ci), ci->pgtbl_cap, heap_ptr, 0, 0 | pgtbl_lvl_flag);
  410fdf:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
	last_page = round_to_page(ci->vas_frontier - 1);
  410fe3:	48 8d 50 ff          	lea    rdx,[rax-0x1]
	ci->mi.second_lvl_pgtbl_cap  = __bump_mem_expand_intern(__compinfo_metacap(ci), ci->pgtbl_cap, heap_ptr, 0, 0 | pgtbl_lvl_flag);
  410fe7:	41 0f 11 85 48 01 00 	movups XMMWORD PTR [r13+0x148],xmm0
  410fee:	00 
		return round_up_to_pgt0_page(vaddr);
  410fef:	48 b8 ff ff ff ff 7f 	movabs rax,0x7fffffffff
  410ff6:	00 00 00 
	last_page = round_to_page(ci->vas_frontier - 1);
  410ff9:	48 81 e2 00 f0 ff ff 	and    rdx,0xfffffffffffff000
		return round_up_to_pgt0_page(vaddr);
  411000:	48 01 c3             	add    rbx,rax
  411003:	48 01 d0             	add    rax,rdx

	/* If previous page is in a different second level pagetable, need to allocate */
	if (cos_pgtbl_round_up_to_page(0, last_page) != cos_pgtbl_round_up_to_page(0, heap_ptr)) {
  411006:	48 31 c3             	xor    rbx,rax
  411009:	58                   	pop    rax
  41100a:	59                   	pop    rcx
  41100b:	48 b8 00 00 00 00 80 	movabs rax,0xffffff8000000000
  411012:	ff ff ff 
  411015:	48 85 c3             	test   rbx,rax
  411018:	75 56                	jne    411070 <cos_compinfo_alloc+0x190>

	}

	/* Allocate the rest of the levels */
	for (pgtbl_lvl = 1; pgtbl_lvl < COS_PGTBL_DEPTH - 1; pgtbl_lvl++) {
		__bump_mem_expand_intern(__compinfo_metacap(ci), ptc, round_to_page(ci->vas_frontier - 1), 0, pgtbl_lvl | pgtbl_lvl_flag);	
  41101a:	49 8b bd 08 01 00 00 	mov    rdi,QWORD PTR [r13+0x108]
  411021:	4d 89 f0             	mov    r8,r14
  411024:	4c 89 fe             	mov    rsi,r15
  411027:	31 c9                	xor    ecx,ecx
  411029:	e8 42 c3 ff ff       	call   40d370 <__bump_mem_expand_intern>
  41102e:	4c 8b 45 b8          	mov    r8,QWORD PTR [rbp-0x48]
  411032:	4c 89 fe             	mov    rsi,r15
  411035:	31 c9                	xor    ecx,ecx
  411037:	49 8b 85 e8 00 00 00 	mov    rax,QWORD PTR [r13+0xe8]
  41103e:	49 8b bd 08 01 00 00 	mov    rdi,QWORD PTR [r13+0x108]
  411045:	48 8d 50 ff          	lea    rdx,[rax-0x1]
  411049:	48 81 e2 00 f0 ff ff 	and    rdx,0xfffffffffffff000
  411050:	e8 1b c3 ff ff       	call   40d370 <__bump_mem_expand_intern>
	}

	return 0;
}
  411055:	48 8d 65 d8          	lea    rsp,[rbp-0x28]
  411059:	31 c0                	xor    eax,eax
  41105b:	5b                   	pop    rbx
  41105c:	41 5c                	pop    r12
  41105e:	41 5d                	pop    r13
  411060:	41 5e                	pop    r14
  411062:	41 5f                	pop    r15
  411064:	5d                   	pop    rbp
  411065:	c3                   	ret    
  411066:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41106d:	00 00 00 
		__bump_mem_expand_intern(__compinfo_metacap(ci), ptc, round_to_page(ci->vas_frontier - 1), 0, 0 | pgtbl_lvl_flag);
  411070:	49 8b bd 08 01 00 00 	mov    rdi,QWORD PTR [r13+0x108]
  411077:	4d 89 e0             	mov    r8,r12
  41107a:	31 c9                	xor    ecx,ecx
  41107c:	4c 89 fe             	mov    rsi,r15
  41107f:	e8 ec c2 ff ff       	call   40d370 <__bump_mem_expand_intern>
		__bump_mem_expand_intern(__compinfo_metacap(ci), ptc, round_to_page(ci->vas_frontier - 1), 0, pgtbl_lvl | pgtbl_lvl_flag);	
  411084:	49 8b 85 e8 00 00 00 	mov    rax,QWORD PTR [r13+0xe8]
  41108b:	48 8d 50 ff          	lea    rdx,[rax-0x1]
  41108f:	48 81 e2 00 f0 ff ff 	and    rdx,0xfffffffffffff000
  411096:	eb 82                	jmp    41101a <cos_compinfo_alloc+0x13a>
  411098:	be 2f 00 00 00       	mov    esi,0x2f
  41109d:	bf b8 ed 41 00       	mov    edi,0x41edb8
  4110a2:	e8 d9 9b ff ff       	call   40ac80 <cos_print_str>
	assert(ptc);
  4110a7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4110ae:	00 00 00 00 
  4110b2:	0f 0b                	ud2    
  4110b4:	be 2f 00 00 00       	mov    esi,0x2f
  4110b9:	bf e8 ed 41 00       	mov    edi,0x41ede8
  4110be:	e8 bd 9b ff ff       	call   40ac80 <cos_print_str>
	assert(ctc);
  4110c3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4110ca:	00 00 00 00 
  4110ce:	0f 0b                	ud2    
  4110d0:	be 2f 00 00 00       	mov    esi,0x2f
  4110d5:	bf 18 ee 41 00       	mov    edi,0x41ee18
  4110da:	e8 a1 9b ff ff       	call   40ac80 <cos_print_str>
	assert(compc);
  4110df:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4110e6:	00 00 00 00 
  4110ea:	0f 0b                	ud2    
  4110ec:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

00000000004110f0 <cos_sinv_alloc>:

sinvcap_t
cos_sinv_alloc(struct cos_compinfo *srcci, compcap_t dstcomp, vaddr_t entry, invtoken_t token)
{
  4110f0:	f3 0f 1e fa          	endbr64 
  4110f4:	55                   	push   rbp
  4110f5:	48 89 e5             	mov    rbp,rsp
  4110f8:	41 57                	push   r15
  4110fa:	41 56                	push   r14
  4110fc:	41 55                	push   r13
  4110fe:	41 54                	push   r12
  411100:	53                   	push   rbx
  411101:	48 83 ec 28          	sub    rsp,0x28
  411105:	48 89 55 b8          	mov    QWORD PTR [rbp-0x48],rdx
	capid_t cap;

	printd("cos_sinv_alloc\n");

	assert(srcci && dstcomp);
  411109:	48 85 ff             	test   rdi,rdi
  41110c:	0f 84 40 01 00 00    	je     411252 <cos_sinv_alloc+0x162>
  411112:	49 89 f5             	mov    r13,rsi
  411115:	48 85 f6             	test   rsi,rsi
  411118:	0f 84 34 01 00 00    	je     411252 <cos_sinv_alloc+0x162>
  41111e:	49 89 fc             	mov    r12,rdi
  411121:	49 89 ce             	mov    r14,rcx
	missing_captbl_node_expand(srcci);
  411124:	e8 67 cd ff ff       	call   40de90 <missing_captbl_node_expand>
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  411129:	0f 01 f9             	rdtscp 
	return (long)coreid;
  41112c:	48 89 cf             	mov    rdi,rcx
{ while (!ps_cas(&l->o, 0, 1)) ; }
  41112f:	49 8d 94 24 58 01 00 	lea    rdx,[r12+0x158]
  411136:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  411137:	be 01 00 00 00       	mov    esi,0x1
  41113c:	31 c9                	xor    ecx,ecx
  41113e:	81 e7 ff 0f 00 00    	and    edi,0xfff
		frontier = &ci->cap64_frontier[cos_cpuid()];
  411144:	4d 8d 84 fc a8 00 00 	lea    r8,[r12+rdi*8+0xa8]
  41114b:	00 
{ while (!ps_cas(&l->o, 0, 1)) ; }
  41114c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  411150:	48 89 c8             	mov    rax,rcx
  411153:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  411158:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  41115b:	84 c0                	test   al,al
  41115d:	74 f1                	je     411150 <cos_sinv_alloc+0x60>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  41115f:	48 8d 5f 14          	lea    rbx,[rdi+0x14]
  411163:	4d 8b 7c dc 08       	mov    r15,QWORD PTR [r12+rbx*8+0x8]
  411168:	41 83 e7 03          	and    r15d,0x3
  41116c:	0f 84 86 00 00 00    	je     4111f8 <cos_sinv_alloc+0x108>
        __asm__ __volatile__("lock " PS_FAA_STR
  411172:	bb 04 00 00 00       	mov    ebx,0x4
  411177:	f0 49 0f c1 18       	lock xadd QWORD PTR [r8],rbx
{ l->o = 0; }
  41117c:	49 c7 84 24 58 01 00 	mov    QWORD PTR [r12+0x158],0x0
  411183:	00 00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  411188:	49 89 df             	mov    r15,rbx
	cap = __capid_bump_alloc(srcci, CAP_COMP);
	if (!cap) return 0;
  41118b:	48 85 db             	test   rbx,rbx
  41118e:	74 52                	je     4111e2 <cos_sinv_alloc+0xf2>
	if (call_cap_op(srcci->captbl_cap, CAPTBL_OP_SINVACTIVATE, cap, dstcomp, entry, token)) BUG();
  411190:	49 8b 44 24 08       	mov    rax,QWORD PTR [r12+0x8]
	__asm__ __volatile__(
  411195:	48 8b 7d b8          	mov    rdi,QWORD PTR [rbp-0x48]
  411199:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  41119d:	4c 89 ee             	mov    rsi,r13
  4111a0:	4c 89 f2             	mov    rdx,r14
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4111a3:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  4111a6:	05 0f 00 01 00       	add    eax,0x1000f
	__asm__ __volatile__(
  4111ab:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4111ae:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4111b2:	48 89 cd             	mov    rbp,rcx
  4111b5:	49 b8 d0 11 41 00 00 	movabs r8,0x4111d0
  4111bc:	00 00 00 
  4111bf:	0f 05                	syscall 
  4111c1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  4111c8:	eb 0d                	jmp    4111d7 <cos_sinv_alloc+0xe7>
  4111ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4111d0:	b9 00 00 00 00       	mov    ecx,0x0
  4111d5:	eb 05                	jmp    4111dc <cos_sinv_alloc+0xec>
  4111d7:	b9 01 00 00 00       	mov    ecx,0x1
  4111dc:	5d                   	pop    rbp
  4111dd:	5c                   	pop    rsp
  4111de:	85 c0                	test   eax,eax
  4111e0:	75 46                	jne    411228 <cos_sinv_alloc+0x138>

	return cap;
}
  4111e2:	48 83 c4 28          	add    rsp,0x28
  4111e6:	4c 89 f8             	mov    rax,r15
  4111e9:	5b                   	pop    rbx
  4111ea:	41 5c                	pop    r12
  4111ec:	41 5d                	pop    r13
  4111ee:	41 5e                	pop    r14
  4111f0:	41 5f                	pop    r15
  4111f2:	5d                   	pop    rbp
  4111f3:	c3                   	ret    
  4111f4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  4111f8:	4c 89 e7             	mov    rdi,r12
  4111fb:	4c 89 45 b0          	mov    QWORD PTR [rbp-0x50],r8
  4111ff:	e8 3c b7 ff ff       	call   40c940 <__capid_captbl_check_expand>
  411204:	4c 8b 45 b0          	mov    r8,QWORD PTR [rbp-0x50]
  411208:	85 c0                	test   eax,eax
  41120a:	75 38                	jne    411244 <cos_sinv_alloc+0x154>
        __asm__ __volatile__("lock " PS_FAA_STR
  41120c:	b8 04 00 00 00       	mov    eax,0x4
  411211:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  411218:	49 89 44 dc 08       	mov    QWORD PTR [r12+rbx*8+0x8],rax
  41121d:	e9 50 ff ff ff       	jmp    411172 <cos_sinv_alloc+0x82>
  411222:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411228:	be 1c 00 00 00       	mov    esi,0x1c
  41122d:	bf 78 ee 41 00       	mov    edi,0x41ee78
  411232:	e8 49 9a ff ff       	call   40ac80 <cos_print_str>
	if (call_cap_op(srcci->captbl_cap, CAPTBL_OP_SINVACTIVATE, cap, dstcomp, entry, token)) BUG();
  411237:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41123e:	00 00 00 00 
  411242:	0f 0b                	ud2    
{ l->o = 0; }
  411244:	49 c7 84 24 58 01 00 	mov    QWORD PTR [r12+0x158],0x0
  41124b:	00 00 00 00 00 
	if (!cap) return 0;
  411250:	eb 90                	jmp    4111e2 <cos_sinv_alloc+0xf2>
  411252:	be 2f 00 00 00       	mov    esi,0x2f
  411257:	bf 48 ee 41 00       	mov    edi,0x41ee48
  41125c:	e8 1f 9a ff ff       	call   40ac80 <cos_print_str>
	assert(srcci && dstcomp);
  411261:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411268:	00 00 00 00 
  41126c:	0f 0b                	ud2    
  41126e:	66 90                	xchg   ax,ax

0000000000411270 <cos_arcv_alloc>:
 * arcvcap: the rcv * endpoint that is the scheduler to be activated
 *          when the thread blocks on this endpoint.
 */
arcvcap_t
cos_arcv_alloc(struct cos_compinfo *ci, thdcap_t thdcap, tcap_t tcapcap, compcap_t compcap, arcvcap_t arcvcap)
{
  411270:	f3 0f 1e fa          	endbr64 
  411274:	55                   	push   rbp
  411275:	48 89 e5             	mov    rbp,rsp
  411278:	41 57                	push   r15
  41127a:	41 56                	push   r14
  41127c:	41 55                	push   r13
  41127e:	41 54                	push   r12
  411280:	53                   	push   rbx
  411281:	48 83 ec 38          	sub    rsp,0x38
	capid_t cap;
	int ret;

	assert(ci && thdcap && tcapcap && compcap);
  411285:	48 85 ff             	test   rdi,rdi
  411288:	0f 84 5e 01 00 00    	je     4113ec <cos_arcv_alloc+0x17c>
  41128e:	49 89 f1             	mov    r9,rsi
  411291:	48 85 f6             	test   rsi,rsi
  411294:	0f 84 52 01 00 00    	je     4113ec <cos_arcv_alloc+0x17c>
  41129a:	48 89 d6             	mov    rsi,rdx
  41129d:	48 85 d2             	test   rdx,rdx
  4112a0:	0f 84 46 01 00 00    	je     4113ec <cos_arcv_alloc+0x17c>
  4112a6:	49 89 cd             	mov    r13,rcx
  4112a9:	48 85 c9             	test   rcx,rcx
  4112ac:	0f 84 3a 01 00 00    	je     4113ec <cos_arcv_alloc+0x17c>
  4112b2:	49 89 fc             	mov    r12,rdi
  4112b5:	4d 89 c7             	mov    r15,r8
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  4112b8:	0f 01 f9             	rdtscp 
	return (long)coreid;
  4112bb:	48 89 cb             	mov    rbx,rcx
{ while (!ps_cas(&l->o, 0, 1)) ; }
  4112be:	48 8d 97 58 01 00 00 	lea    rdx,[rdi+0x158]
        __asm__ __volatile__("lock " PS_CAS_STR
  4112c5:	31 c9                	xor    ecx,ecx
  4112c7:	81 e3 ff 0f 00 00    	and    ebx,0xfff
		frontier = &ci->cap64_frontier[cos_cpuid()];
  4112cd:	4c 8d 84 df a8 00 00 	lea    r8,[rdi+rbx*8+0xa8]
  4112d4:	00 
  4112d5:	bf 01 00 00 00       	mov    edi,0x1
  4112da:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4112e0:	48 89 c8             	mov    rax,rcx
  4112e3:	f0 48 0f b1 3a       	lock cmpxchg QWORD PTR [rdx],rdi
  4112e8:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  4112eb:	84 c0                	test   al,al
  4112ed:	74 f1                	je     4112e0 <cos_arcv_alloc+0x70>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  4112ef:	48 83 c3 14          	add    rbx,0x14
  4112f3:	4d 8b 74 dc 08       	mov    r14,QWORD PTR [r12+rbx*8+0x8]
  4112f8:	41 83 e6 03          	and    r14d,0x3
  4112fc:	0f 84 86 00 00 00    	je     411388 <cos_arcv_alloc+0x118>
        __asm__ __volatile__("lock " PS_FAA_STR
  411302:	bb 04 00 00 00       	mov    ebx,0x4
  411307:	f0 49 0f c1 18       	lock xadd QWORD PTR [r8],rbx
{ l->o = 0; }
  41130c:	49 c7 84 24 58 01 00 	mov    QWORD PTR [r12+0x158],0x0
  411313:	00 00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  411318:	49 89 de             	mov    r14,rbx

	printd("arcv_alloc: tcap cap %d\n", (int)tcapcap);

	cap = __capid_bump_alloc(ci, CAP_ARCV);
	if (!cap) return 0;
  41131b:	48 85 db             	test   rbx,rbx
  41131e:	74 52                	je     411372 <cos_arcv_alloc+0x102>
	if ((ret = call_cap_op(ci->captbl_cap, CAPTBL_OP_ARCVACTIVATE, cap, thdcap | (tcapcap << 16), compcap, arcvcap))) BUG();
  411320:	49 8b 44 24 08       	mov    rax,QWORD PTR [r12+0x8]
  411325:	48 c1 e6 10          	shl    rsi,0x10
	__asm__ __volatile__(
  411329:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  41132d:	4c 89 ef             	mov    rdi,r13
  411330:	4c 09 ce             	or     rsi,r9
  411333:	4c 89 fa             	mov    rdx,r15
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411336:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  411339:	05 15 00 01 00       	add    eax,0x10015
	__asm__ __volatile__(
  41133e:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411341:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411345:	48 89 cd             	mov    rbp,rcx
  411348:	49 b8 60 13 41 00 00 	movabs r8,0x411360
  41134f:	00 00 00 
  411352:	0f 05                	syscall 
  411354:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  411358:	eb 0d                	jmp    411367 <cos_arcv_alloc+0xf7>
  41135a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411360:	b9 00 00 00 00       	mov    ecx,0x0
  411365:	eb 05                	jmp    41136c <cos_arcv_alloc+0xfc>
  411367:	b9 01 00 00 00       	mov    ecx,0x1
  41136c:	5d                   	pop    rbp
  41136d:	5c                   	pop    rsp
  41136e:	85 c0                	test   eax,eax
  411370:	75 50                	jne    4113c2 <cos_arcv_alloc+0x152>

	return cap;
}
  411372:	48 83 c4 38          	add    rsp,0x38
  411376:	4c 89 f0             	mov    rax,r14
  411379:	5b                   	pop    rbx
  41137a:	41 5c                	pop    r12
  41137c:	41 5d                	pop    r13
  41137e:	41 5e                	pop    r14
  411380:	41 5f                	pop    r15
  411382:	5d                   	pop    rbp
  411383:	c3                   	ret    
  411384:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  411388:	4c 89 e7             	mov    rdi,r12
  41138b:	48 89 75 a8          	mov    QWORD PTR [rbp-0x58],rsi
  41138f:	4c 89 4d b0          	mov    QWORD PTR [rbp-0x50],r9
  411393:	4c 89 45 b8          	mov    QWORD PTR [rbp-0x48],r8
  411397:	e8 a4 b5 ff ff       	call   40c940 <__capid_captbl_check_expand>
  41139c:	4c 8b 45 b8          	mov    r8,QWORD PTR [rbp-0x48]
  4113a0:	4c 8b 4d b0          	mov    r9,QWORD PTR [rbp-0x50]
  4113a4:	85 c0                	test   eax,eax
  4113a6:	48 8b 75 a8          	mov    rsi,QWORD PTR [rbp-0x58]
  4113aa:	75 32                	jne    4113de <cos_arcv_alloc+0x16e>
        __asm__ __volatile__("lock " PS_FAA_STR
  4113ac:	b8 04 00 00 00       	mov    eax,0x4
  4113b1:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  4113b8:	49 89 44 dc 08       	mov    QWORD PTR [r12+rbx*8+0x8],rax
  4113bd:	e9 40 ff ff ff       	jmp    411302 <cos_arcv_alloc+0x92>
  4113c2:	be 1c 00 00 00       	mov    esi,0x1c
  4113c7:	bf c8 ee 41 00       	mov    edi,0x41eec8
  4113cc:	e8 af 98 ff ff       	call   40ac80 <cos_print_str>
	if ((ret = call_cap_op(ci->captbl_cap, CAPTBL_OP_ARCVACTIVATE, cap, thdcap | (tcapcap << 16), compcap, arcvcap))) BUG();
  4113d1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4113d8:	00 00 00 00 
  4113dc:	0f 0b                	ud2    
{ l->o = 0; }
  4113de:	49 c7 84 24 58 01 00 	mov    QWORD PTR [r12+0x158],0x0
  4113e5:	00 00 00 00 00 
	if (!cap) return 0;
  4113ea:	eb 86                	jmp    411372 <cos_arcv_alloc+0x102>
  4113ec:	be 2f 00 00 00       	mov    esi,0x2f
  4113f1:	bf 98 ee 41 00       	mov    edi,0x41ee98
  4113f6:	e8 85 98 ff ff       	call   40ac80 <cos_print_str>
	assert(ci && thdcap && tcapcap && compcap);
  4113fb:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411402:	00 00 00 00 
  411406:	0f 0b                	ud2    
  411408:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41140f:	00 

0000000000411410 <cos_asnd_alloc>:

asndcap_t
cos_asnd_alloc(struct cos_compinfo *ci, arcvcap_t arcvcap, captblcap_t ctcap)
{
  411410:	f3 0f 1e fa          	endbr64 
  411414:	55                   	push   rbp
  411415:	48 89 e5             	mov    rbp,rsp
  411418:	41 57                	push   r15
  41141a:	49 89 d7             	mov    r15,rdx
  41141d:	41 56                	push   r14
  41141f:	41 55                	push   r13
  411421:	41 54                	push   r12
  411423:	53                   	push   rbx
  411424:	48 83 ec 28          	sub    rsp,0x28
	capid_t cap;

	assert(ci && arcvcap && ctcap);
  411428:	48 85 f6             	test   rsi,rsi
  41142b:	0f 94 c0             	sete   al
  41142e:	48 85 d2             	test   rdx,rdx
  411431:	0f 94 c2             	sete   dl
  411434:	08 d0                	or     al,dl
  411436:	0f 85 28 01 00 00    	jne    411564 <cos_asnd_alloc+0x154>
  41143c:	49 89 fc             	mov    r12,rdi
  41143f:	48 85 ff             	test   rdi,rdi
  411442:	0f 84 1c 01 00 00    	je     411564 <cos_asnd_alloc+0x154>
  411448:	49 89 f5             	mov    r13,rsi
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  41144b:	0f 01 f9             	rdtscp 
	return (long)coreid;
  41144e:	48 89 cb             	mov    rbx,rcx
{ while (!ps_cas(&l->o, 0, 1)) ; }
  411451:	48 8d 97 58 01 00 00 	lea    rdx,[rdi+0x158]
        __asm__ __volatile__("lock " PS_CAS_STR
  411458:	be 01 00 00 00       	mov    esi,0x1
  41145d:	31 c9                	xor    ecx,ecx
  41145f:	81 e3 ff 0f 00 00    	and    ebx,0xfff
		frontier = &ci->cap64_frontier[cos_cpuid()];
  411465:	4c 8d 84 df a8 00 00 	lea    r8,[rdi+rbx*8+0xa8]
  41146c:	00 
{ while (!ps_cas(&l->o, 0, 1)) ; }
  41146d:	0f 1f 00             	nop    DWORD PTR [rax]
        __asm__ __volatile__("lock " PS_CAS_STR
  411470:	48 89 c8             	mov    rax,rcx
  411473:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  411478:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  41147b:	84 c0                	test   al,al
  41147d:	74 f1                	je     411470 <cos_asnd_alloc+0x60>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  41147f:	48 83 c3 14          	add    rbx,0x14
  411483:	4d 8b 74 dc 08       	mov    r14,QWORD PTR [r12+rbx*8+0x8]
  411488:	41 83 e6 03          	and    r14d,0x3
  41148c:	0f 84 7e 00 00 00    	je     411510 <cos_asnd_alloc+0x100>
        __asm__ __volatile__("lock " PS_FAA_STR
  411492:	bb 04 00 00 00       	mov    ebx,0x4
  411497:	f0 49 0f c1 18       	lock xadd QWORD PTR [r8],rbx
{ l->o = 0; }
  41149c:	49 c7 84 24 58 01 00 	mov    QWORD PTR [r12+0x158],0x0
  4114a3:	00 00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  4114a8:	49 89 de             	mov    r14,rbx

	cap = __capid_bump_alloc(ci, CAP_ASND);
	if (!cap) return 0;
  4114ab:	48 85 db             	test   rbx,rbx
  4114ae:	74 4a                	je     4114fa <cos_asnd_alloc+0xea>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_ASNDACTIVATE, cap, ctcap, arcvcap, 0)) BUG();
  4114b0:	49 8b 44 24 08       	mov    rax,QWORD PTR [r12+0x8]
	__asm__ __volatile__(
  4114b5:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  4114b9:	31 d2                	xor    edx,edx
  4114bb:	4c 89 fe             	mov    rsi,r15
  4114be:	4c 89 ef             	mov    rdi,r13
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4114c1:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  4114c4:	05 13 00 01 00       	add    eax,0x10013
	__asm__ __volatile__(
  4114c9:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4114cc:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4114d0:	48 89 cd             	mov    rbp,rcx
  4114d3:	49 b8 e8 14 41 00 00 	movabs r8,0x4114e8
  4114da:	00 00 00 
  4114dd:	0f 05                	syscall 
  4114df:	90                   	nop
  4114e0:	eb 0d                	jmp    4114ef <cos_asnd_alloc+0xdf>
  4114e2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4114e8:	b9 00 00 00 00       	mov    ecx,0x0
  4114ed:	eb 05                	jmp    4114f4 <cos_asnd_alloc+0xe4>
  4114ef:	b9 01 00 00 00       	mov    ecx,0x1
  4114f4:	5d                   	pop    rbp
  4114f5:	5c                   	pop    rsp
  4114f6:	85 c0                	test   eax,eax
  4114f8:	75 40                	jne    41153a <cos_asnd_alloc+0x12a>

	return cap;
}
  4114fa:	48 83 c4 28          	add    rsp,0x28
  4114fe:	4c 89 f0             	mov    rax,r14
  411501:	5b                   	pop    rbx
  411502:	41 5c                	pop    r12
  411504:	41 5d                	pop    r13
  411506:	41 5e                	pop    r14
  411508:	41 5f                	pop    r15
  41150a:	5d                   	pop    rbp
  41150b:	c3                   	ret    
  41150c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  411510:	4c 89 e7             	mov    rdi,r12
  411513:	4c 89 45 b8          	mov    QWORD PTR [rbp-0x48],r8
  411517:	e8 24 b4 ff ff       	call   40c940 <__capid_captbl_check_expand>
  41151c:	4c 8b 45 b8          	mov    r8,QWORD PTR [rbp-0x48]
  411520:	85 c0                	test   eax,eax
  411522:	75 32                	jne    411556 <cos_asnd_alloc+0x146>
        __asm__ __volatile__("lock " PS_FAA_STR
  411524:	b8 04 00 00 00       	mov    eax,0x4
  411529:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  411530:	49 89 44 dc 08       	mov    QWORD PTR [r12+rbx*8+0x8],rax
  411535:	e9 58 ff ff ff       	jmp    411492 <cos_asnd_alloc+0x82>
  41153a:	be 1c 00 00 00       	mov    esi,0x1c
  41153f:	bf 18 ef 41 00       	mov    edi,0x41ef18
  411544:	e8 37 97 ff ff       	call   40ac80 <cos_print_str>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_ASNDACTIVATE, cap, ctcap, arcvcap, 0)) BUG();
  411549:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411550:	00 00 00 00 
  411554:	0f 0b                	ud2    
{ l->o = 0; }
  411556:	49 c7 84 24 58 01 00 	mov    QWORD PTR [r12+0x158],0x0
  41155d:	00 00 00 00 00 
	if (!cap) return 0;
  411562:	eb 96                	jmp    4114fa <cos_asnd_alloc+0xea>
  411564:	be 2f 00 00 00       	mov    esi,0x2f
  411569:	bf e8 ee 41 00       	mov    edi,0x41eee8
  41156e:	e8 0d 97 ff ff       	call   40ac80 <cos_print_str>
	assert(ci && arcvcap && ctcap);
  411573:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41157a:	00 00 00 00 
  41157e:	0f 0b                	ud2    

0000000000411580 <cos_hw_alloc>:
 * TODO: bitmap must be a subset of existing one.
 *       but there is no such check now, violates access control policy.
 */
hwcap_t
cos_hw_alloc(struct cos_compinfo *ci, u32_t bitmap)
{
  411580:	f3 0f 1e fa          	endbr64 
  411584:	55                   	push   rbp
  411585:	48 89 e5             	mov    rbp,rsp
  411588:	41 57                	push   r15
  41158a:	41 56                	push   r14
  41158c:	41 55                	push   r13
  41158e:	41 54                	push   r12
  411590:	53                   	push   rbx
  411591:	48 83 ec 18          	sub    rsp,0x18
	capid_t cap;

	assert(ci);
  411595:	48 85 ff             	test   rdi,rdi
  411598:	0f 84 1c 01 00 00    	je     4116ba <cos_hw_alloc+0x13a>
  41159e:	49 89 fc             	mov    r12,rdi
  4115a1:	41 89 f5             	mov    r13d,esi
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  4115a4:	0f 01 f9             	rdtscp 
	return (long)coreid;
  4115a7:	48 89 cb             	mov    rbx,rcx
{ while (!ps_cas(&l->o, 0, 1)) ; }
  4115aa:	48 8d 97 58 01 00 00 	lea    rdx,[rdi+0x158]
        __asm__ __volatile__("lock " PS_CAS_STR
  4115b1:	31 c9                	xor    ecx,ecx
  4115b3:	81 e3 ff 0f 00 00    	and    ebx,0xfff
		frontier = &ci->cap32_frontier[cos_cpuid()];
  4115b9:	4c 8d 7c df 68       	lea    r15,[rdi+rbx*8+0x68]
  4115be:	bf 01 00 00 00       	mov    edi,0x1
  4115c3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  4115c8:	48 89 c8             	mov    rax,rcx
  4115cb:	f0 48 0f b1 3a       	lock cmpxchg QWORD PTR [rdx],rdi
  4115d0:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  4115d3:	84 c0                	test   al,al
  4115d5:	74 f1                	je     4115c8 <cos_hw_alloc+0x48>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  4115d7:	48 83 c3 0c          	add    rbx,0xc
  4115db:	4d 8b 74 dc 08       	mov    r14,QWORD PTR [r12+rbx*8+0x8]
  4115e0:	41 83 e6 03          	and    r14d,0x3
  4115e4:	0f 84 7e 00 00 00    	je     411668 <cos_hw_alloc+0xe8>
        __asm__ __volatile__("lock " PS_FAA_STR
  4115ea:	bb 02 00 00 00       	mov    ebx,0x2
  4115ef:	f0 49 0f c1 1f       	lock xadd QWORD PTR [r15],rbx
{ l->o = 0; }
  4115f4:	49 c7 84 24 58 01 00 	mov    QWORD PTR [r12+0x158],0x0
  4115fb:	00 00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  411600:	49 89 de             	mov    r14,rbx

	cap = __capid_bump_alloc(ci, CAP_HW);
	if (!cap) return 0;
  411603:	48 85 db             	test   rbx,rbx
  411606:	74 4a                	je     411652 <cos_hw_alloc+0xd2>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_HW_ACTIVATE, cap, bitmap, 0, 0)) BUG();
  411608:	49 8b 44 24 08       	mov    rax,QWORD PTR [r12+0x8]
	__asm__ __volatile__(
  41160d:	31 d2                	xor    edx,edx
  41160f:	44 89 ee             	mov    esi,r13d
  411612:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  411616:	48 89 d7             	mov    rdi,rdx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411619:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  41161c:	05 2b 00 01 00       	add    eax,0x1002b
	__asm__ __volatile__(
  411621:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411624:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411628:	48 89 cd             	mov    rbp,rcx
  41162b:	49 b8 40 16 41 00 00 	movabs r8,0x411640
  411632:	00 00 00 
  411635:	0f 05                	syscall 
  411637:	90                   	nop
  411638:	eb 0d                	jmp    411647 <cos_hw_alloc+0xc7>
  41163a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411640:	b9 00 00 00 00       	mov    ecx,0x0
  411645:	eb 05                	jmp    41164c <cos_hw_alloc+0xcc>
  411647:	b9 01 00 00 00       	mov    ecx,0x1
  41164c:	5d                   	pop    rbp
  41164d:	5c                   	pop    rsp
  41164e:	85 c0                	test   eax,eax
  411650:	75 3e                	jne    411690 <cos_hw_alloc+0x110>

	return cap;
}
  411652:	48 83 c4 18          	add    rsp,0x18
  411656:	4c 89 f0             	mov    rax,r14
  411659:	5b                   	pop    rbx
  41165a:	41 5c                	pop    r12
  41165c:	41 5d                	pop    r13
  41165e:	41 5e                	pop    r14
  411660:	41 5f                	pop    r15
  411662:	5d                   	pop    rbp
  411663:	c3                   	ret    
  411664:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  411668:	4c 89 e7             	mov    rdi,r12
  41166b:	e8 d0 b2 ff ff       	call   40c940 <__capid_captbl_check_expand>
  411670:	85 c0                	test   eax,eax
  411672:	75 38                	jne    4116ac <cos_hw_alloc+0x12c>
        __asm__ __volatile__("lock " PS_FAA_STR
  411674:	b8 04 00 00 00       	mov    eax,0x4
  411679:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  411680:	49 89 44 dc 08       	mov    QWORD PTR [r12+rbx*8+0x8],rax
  411685:	e9 60 ff ff ff       	jmp    4115ea <cos_hw_alloc+0x6a>
  41168a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411690:	be 1c 00 00 00       	mov    esi,0x1c
  411695:	bf 68 ef 41 00       	mov    edi,0x41ef68
  41169a:	e8 e1 95 ff ff       	call   40ac80 <cos_print_str>
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_HW_ACTIVATE, cap, bitmap, 0, 0)) BUG();
  41169f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4116a6:	00 00 00 00 
  4116aa:	0f 0b                	ud2    
{ l->o = 0; }
  4116ac:	49 c7 84 24 58 01 00 	mov    QWORD PTR [r12+0x158],0x0
  4116b3:	00 00 00 00 00 
	if (!cap) return 0;
  4116b8:	eb 98                	jmp    411652 <cos_hw_alloc+0xd2>
  4116ba:	be 2f 00 00 00       	mov    esi,0x2f
  4116bf:	bf 38 ef 41 00       	mov    edi,0x41ef38
  4116c4:	e8 b7 95 ff ff       	call   40ac80 <cos_print_str>
	assert(ci);
  4116c9:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4116d0:	00 00 00 00 
  4116d4:	0f 0b                	ud2    
  4116d6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4116dd:	00 00 00 

00000000004116e0 <cos_page_bump_allocn>:

void *
cos_page_bump_allocn(struct cos_compinfo *ci, size_t sz)
{
  4116e0:	f3 0f 1e fa          	endbr64 
	assert(sz % PAGE_SIZE == 0);
  4116e4:	f7 c6 ff 0f 00 00    	test   esi,0xfff
  4116ea:	75 0a                	jne    4116f6 <cos_page_bump_allocn+0x16>
	return (void *)__page_bump_alloc(ci, sz, PAGE_SIZE);
  4116ec:	ba 00 10 00 00       	mov    edx,0x1000
  4116f1:	e9 fa b9 ff ff       	jmp    40d0f0 <__page_bump_alloc>
{
  4116f6:	55                   	push   rbp
  4116f7:	be 2f 00 00 00       	mov    esi,0x2f
  4116fc:	bf 88 ef 41 00       	mov    edi,0x41ef88
  411701:	48 89 e5             	mov    rbp,rsp
  411704:	e8 77 95 ff ff       	call   40ac80 <cos_print_str>
	assert(sz % PAGE_SIZE == 0);
  411709:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411710:	00 00 00 00 
  411714:	0f 0b                	ud2    
  411716:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41171d:	00 00 00 

0000000000411720 <cos_page_bump_allocn_aligned>:
}

void *
cos_page_bump_allocn_aligned(struct cos_compinfo *ci, size_t sz, size_t align)
{
  411720:	f3 0f 1e fa          	endbr64 
  411724:	55                   	push   rbp
  411725:	48 89 e5             	mov    rbp,rsp
	assert(sz % PAGE_SIZE == 0);
  411728:	f7 c6 ff 0f 00 00    	test   esi,0xfff
  41172e:	75 0e                	jne    41173e <cos_page_bump_allocn_aligned+0x1e>
	assert(align % PAGE_SIZE == 0);
  411730:	f7 c2 ff 0f 00 00    	test   edx,0xfff
  411736:	75 22                	jne    41175a <cos_page_bump_allocn_aligned+0x3a>

	return (void *)__page_bump_alloc(ci, sz, align);
}
  411738:	5d                   	pop    rbp
	return (void *)__page_bump_alloc(ci, sz, align);
  411739:	e9 b2 b9 ff ff       	jmp    40d0f0 <__page_bump_alloc>
  41173e:	be 2f 00 00 00       	mov    esi,0x2f
  411743:	bf b8 ef 41 00       	mov    edi,0x41efb8
  411748:	e8 33 95 ff ff       	call   40ac80 <cos_print_str>
	assert(sz % PAGE_SIZE == 0);
  41174d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411754:	00 00 00 00 
  411758:	0f 0b                	ud2    
  41175a:	be 2f 00 00 00       	mov    esi,0x2f
  41175f:	bf e8 ef 41 00       	mov    edi,0x41efe8
  411764:	e8 17 95 ff ff       	call   40ac80 <cos_print_str>
	assert(align % PAGE_SIZE == 0);
  411769:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411770:	00 00 00 00 
  411774:	0f 0b                	ud2    
  411776:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41177d:	00 00 00 

0000000000411780 <cos_page_bump_alloc>:

void *
cos_page_bump_alloc(struct cos_compinfo *ci)
{
  411780:	f3 0f 1e fa          	endbr64 
	return (void *)__page_bump_alloc(ci, sz, PAGE_SIZE);
  411784:	ba 00 10 00 00       	mov    edx,0x1000
  411789:	be 00 10 00 00       	mov    esi,0x1000
  41178e:	e9 5d b9 ff ff       	jmp    40d0f0 <__page_bump_alloc>
  411793:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41179a:	00 00 00 00 
  41179e:	66 90                	xchg   ax,ax

00000000004117a0 <cos_cap_cpy>:

}

capid_t
cos_cap_cpy(struct cos_compinfo *dstci, struct cos_compinfo *srcci, cap_t srcctype, capid_t srccap)
{
  4117a0:	f3 0f 1e fa          	endbr64 
  4117a4:	55                   	push   rbp
  4117a5:	48 89 e5             	mov    rbp,rsp
  4117a8:	41 57                	push   r15
  4117aa:	41 56                	push   r14
  4117ac:	41 55                	push   r13
  4117ae:	41 54                	push   r12
  4117b0:	53                   	push   rbx
  4117b1:	48 83 ec 28          	sub    rsp,0x28
	capid_t dstcap;

	assert(srcci && dstci);
  4117b5:	48 85 f6             	test   rsi,rsi
  4117b8:	0f 84 a6 01 00 00    	je     411964 <cos_cap_cpy+0x1c4>
  4117be:	49 89 fc             	mov    r12,rdi
  4117c1:	48 85 ff             	test   rdi,rdi
  4117c4:	0f 84 9a 01 00 00    	je     411964 <cos_cap_cpy+0x1c4>
  4117ca:	49 89 f6             	mov    r14,rsi
  4117cd:	48 89 cb             	mov    rbx,rcx
  4117d0:	83 fa 14             	cmp    edx,0x14
  4117d3:	0f 87 1f 01 00 00    	ja     4118f8 <cos_cap_cpy+0x158>
  4117d9:	b8 01 00 00 00       	mov    eax,0x1
  4117de:	89 d1                	mov    ecx,edx
  4117e0:	48 d3 e0             	shl    rax,cl
  4117e3:	a9 da 81 1f 00       	test   eax,0x1f81da
  4117e8:	0f 84 c2 00 00 00    	je     4118b0 <cos_cap_cpy+0x110>
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  4117ee:	0f 01 f9             	rdtscp 
		frontier = &ci->cap64_frontier[cos_cpuid()];
  4117f1:	81 e1 ff 0f 00 00    	and    ecx,0xfff
		break;
  4117f7:	41 bf 04 00 00 00    	mov    r15d,0x4
		frontier = &ci->cap64_frontier[cos_cpuid()];
  4117fd:	4c 8d 84 cf a8 00 00 	lea    r8,[rdi+rcx*8+0xa8]
  411804:	00 
{ while (!ps_cas(&l->o, 0, 1)) ; }
  411805:	49 8d 94 24 58 01 00 	lea    rdx,[r12+0x158]
  41180c:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  41180d:	be 01 00 00 00       	mov    esi,0x1
  411812:	31 c9                	xor    ecx,ecx
  411814:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  411818:	48 89 c8             	mov    rax,rcx
  41181b:	f0 48 0f b1 32       	lock cmpxchg QWORD PTR [rdx],rsi
  411820:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  411823:	84 c0                	test   al,al
  411825:	74 f1                	je     411818 <cos_cap_cpy+0x78>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  411827:	4d 8b 28             	mov    r13,QWORD PTR [r8]
  41182a:	41 83 e5 03          	and    r13d,0x3
  41182e:	0f 84 d4 00 00 00    	je     411908 <cos_cap_cpy+0x168>
        __asm__ __volatile__("lock " PS_FAA_STR
  411834:	4c 89 f8             	mov    rax,r15
  411837:	f0 49 0f c1 00       	lock xadd QWORD PTR [r8],rax
{ l->o = 0; }
  41183c:	49 c7 84 24 58 01 00 	mov    QWORD PTR [r12+0x158],0x0
  411843:	00 00 00 00 00 
        __asm__ __volatile__("lock " PS_FAA_STR
  411848:	49 89 c5             	mov    r13,rax

	dstcap = __capid_bump_alloc(dstci, srcctype);
	if (!dstcap) return 0;
  41184b:	48 85 c0             	test   rax,rax
  41184e:	74 4e                	je     41189e <cos_cap_cpy+0xfe>

	if (call_cap_op(srcci->captbl_cap, CAPTBL_OP_CPY, srccap, dstci->captbl_cap, dstcap, 0)) BUG();
  411850:	49 8b 46 08          	mov    rax,QWORD PTR [r14+0x8]
	__asm__ __volatile__(
  411854:	49 8b 74 24 08       	mov    rsi,QWORD PTR [r12+0x8]
  411859:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  41185d:	31 d2                	xor    edx,edx
  41185f:	4c 89 ef             	mov    rdi,r13
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411862:	83 c0 01             	add    eax,0x1
  411865:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  411868:	48 89 29             	mov    QWORD PTR [rcx],rbp
  41186b:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  41186f:	48 89 cd             	mov    rbp,rcx
  411872:	49 b8 88 18 41 00 00 	movabs r8,0x411888
  411879:	00 00 00 
  41187c:	0f 05                	syscall 
  41187e:	66 90                	xchg   ax,ax
  411880:	eb 0d                	jmp    41188f <cos_cap_cpy+0xef>
  411882:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411888:	b9 00 00 00 00       	mov    ecx,0x0
  41188d:	eb 05                	jmp    411894 <cos_cap_cpy+0xf4>
  41188f:	b9 01 00 00 00       	mov    ecx,0x1
  411894:	5d                   	pop    rbp
  411895:	5c                   	pop    rsp
  411896:	85 c0                	test   eax,eax
  411898:	0f 85 aa 00 00 00    	jne    411948 <cos_cap_cpy+0x1a8>

	return dstcap;
}
  41189e:	48 83 c4 28          	add    rsp,0x28
  4118a2:	4c 89 e8             	mov    rax,r13
  4118a5:	5b                   	pop    rbx
  4118a6:	41 5c                	pop    r12
  4118a8:	41 5d                	pop    r13
  4118aa:	41 5e                	pop    r14
  4118ac:	41 5f                	pop    r15
  4118ae:	5d                   	pop    rbp
  4118af:	c3                   	ret    
  4118b0:	a9 24 10 00 00       	test   eax,0x1024
  4118b5:	75 21                	jne    4118d8 <cos_cap_cpy+0x138>
  4118b7:	f6 c4 60             	test   ah,0x60
  4118ba:	74 3c                	je     4118f8 <cos_cap_cpy+0x158>
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  4118bc:	0f 01 f9             	rdtscp 
		frontier = &ci->cap32_frontier[cos_cpuid()];
  4118bf:	81 e1 ff 0f 00 00    	and    ecx,0xfff
		break;
  4118c5:	41 bf 02 00 00 00    	mov    r15d,0x2
		frontier = &ci->cap32_frontier[cos_cpuid()];
  4118cb:	4c 8d 44 cf 68       	lea    r8,[rdi+rcx*8+0x68]
		break;
  4118d0:	e9 30 ff ff ff       	jmp    411805 <cos_cap_cpy+0x65>
  4118d5:	0f 1f 00             	nop    DWORD PTR [rax]
  4118d8:	0f 01 f9             	rdtscp 
		frontier = &ci->cap16_frontier[cos_cpuid()];
  4118db:	81 e1 ff 0f 00 00    	and    ecx,0xfff
		break;
  4118e1:	41 bf 01 00 00 00    	mov    r15d,0x1
		frontier = &ci->cap16_frontier[cos_cpuid()];
  4118e7:	4c 8d 44 cf 28       	lea    r8,[rdi+rcx*8+0x28]
		break;
  4118ec:	e9 14 ff ff ff       	jmp    411805 <cos_cap_cpy+0x65>
  4118f1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  4118f8:	49 c7 c5 ff ff ff ff 	mov    r13,0xffffffffffffffff
  4118ff:	e9 4c ff ff ff       	jmp    411850 <cos_cap_cpy+0xb0>
  411904:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  411908:	4c 89 e7             	mov    rdi,r12
  41190b:	4c 89 45 b8          	mov    QWORD PTR [rbp-0x48],r8
  41190f:	e8 2c b0 ff ff       	call   40c940 <__capid_captbl_check_expand>
  411914:	4c 8b 45 b8          	mov    r8,QWORD PTR [rbp-0x48]
  411918:	85 c0                	test   eax,eax
  41191a:	75 14                	jne    411930 <cos_cap_cpy+0x190>
  41191c:	b8 04 00 00 00       	mov    eax,0x4
  411921:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  411928:	49 89 00             	mov    QWORD PTR [r8],rax
  41192b:	e9 04 ff ff ff       	jmp    411834 <cos_cap_cpy+0x94>
{ l->o = 0; }
  411930:	49 c7 84 24 58 01 00 	mov    QWORD PTR [r12+0x158],0x0
  411937:	00 00 00 00 00 
	if (!dstcap) return 0;
  41193c:	e9 5d ff ff ff       	jmp    41189e <cos_cap_cpy+0xfe>
  411941:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  411948:	be 1c 00 00 00       	mov    esi,0x1c
  41194d:	bf 48 f0 41 00       	mov    edi,0x41f048
  411952:	e8 29 93 ff ff       	call   40ac80 <cos_print_str>
	if (call_cap_op(srcci->captbl_cap, CAPTBL_OP_CPY, srccap, dstci->captbl_cap, dstcap, 0)) BUG();
  411957:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41195e:	00 00 00 00 
  411962:	0f 0b                	ud2    
  411964:	be 2f 00 00 00       	mov    esi,0x2f
  411969:	bf 18 f0 41 00       	mov    edi,0x41f018
  41196e:	e8 0d 93 ff ff       	call   40ac80 <cos_print_str>
	assert(srcci && dstci);
  411973:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41197a:	00 00 00 00 
  41197e:	0f 0b                	ud2    

0000000000411980 <cos_cap_cpy_at>:

int
cos_cap_cpy_at(struct cos_compinfo *dstci, capid_t dstcap, struct cos_compinfo *srcci, capid_t srccap)
{
  411980:	f3 0f 1e fa          	endbr64 
  411984:	55                   	push   rbp
  411985:	48 89 e5             	mov    rbp,rsp
  411988:	41 54                	push   r12
  41198a:	53                   	push   rbx
  41198b:	48 83 ec 10          	sub    rsp,0x10
	assert(srcci && dstci);
  41198f:	48 85 d2             	test   rdx,rdx
  411992:	0f 84 84 00 00 00    	je     411a1c <cos_cap_cpy_at+0x9c>
  411998:	49 89 f8             	mov    r8,rdi
  41199b:	48 85 ff             	test   rdi,rdi
  41199e:	74 7c                	je     411a1c <cos_cap_cpy_at+0x9c>
  4119a0:	48 89 f7             	mov    rdi,rsi

	if (!dstcap) return 0;
  4119a3:	48 85 f6             	test   rsi,rsi
  4119a6:	74 4a                	je     4119f2 <cos_cap_cpy_at+0x72>

	if (call_cap_op(srcci->captbl_cap, CAPTBL_OP_CPY, srccap, dstci->captbl_cap, dstcap, 0)) BUG();
  4119a8:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  4119ac:	48 89 cb             	mov    rbx,rcx
	__asm__ __volatile__(
  4119af:	49 8b 70 08          	mov    rsi,QWORD PTR [r8+0x8]
  4119b3:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  4119b7:	31 d2                	xor    edx,edx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4119b9:	83 c0 01             	add    eax,0x1
  4119bc:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  4119bf:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4119c2:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4119c6:	48 89 cd             	mov    rbp,rcx
  4119c9:	49 b8 e0 19 41 00 00 	movabs r8,0x4119e0
  4119d0:	00 00 00 
  4119d3:	0f 05                	syscall 
  4119d5:	0f 1f 00             	nop    DWORD PTR [rax]
  4119d8:	eb 0d                	jmp    4119e7 <cos_cap_cpy_at+0x67>
  4119da:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4119e0:	b9 00 00 00 00       	mov    ecx,0x0
  4119e5:	eb 05                	jmp    4119ec <cos_cap_cpy_at+0x6c>
  4119e7:	b9 01 00 00 00       	mov    ecx,0x1
  4119ec:	5d                   	pop    rbp
  4119ed:	5c                   	pop    rsp
  4119ee:	85 c0                	test   eax,eax
  4119f0:	75 0e                	jne    411a00 <cos_cap_cpy_at+0x80>

	return 0;
}
  4119f2:	48 83 c4 10          	add    rsp,0x10
  4119f6:	31 c0                	xor    eax,eax
  4119f8:	5b                   	pop    rbx
  4119f9:	41 5c                	pop    r12
  4119fb:	5d                   	pop    rbp
  4119fc:	c3                   	ret    
  4119fd:	0f 1f 00             	nop    DWORD PTR [rax]
  411a00:	be 1c 00 00 00       	mov    esi,0x1c
  411a05:	bf 98 f0 41 00       	mov    edi,0x41f098
  411a0a:	e8 71 92 ff ff       	call   40ac80 <cos_print_str>
	if (call_cap_op(srcci->captbl_cap, CAPTBL_OP_CPY, srccap, dstci->captbl_cap, dstcap, 0)) BUG();
  411a0f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411a16:	00 00 00 00 
  411a1a:	0f 0b                	ud2    
  411a1c:	be 2f 00 00 00       	mov    esi,0x2f
  411a21:	bf 68 f0 41 00       	mov    edi,0x41f068
  411a26:	e8 55 92 ff ff       	call   40ac80 <cos_print_str>
	assert(srcci && dstci);
  411a2b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411a32:	00 00 00 00 
  411a36:	0f 0b                	ud2    
  411a38:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  411a3f:	00 

0000000000411a40 <cos_thd_switch>:

/**************** [Kernel Object Operations] ****************/

int
cos_thd_switch(thdcap_t c)
{
  411a40:	f3 0f 1e fa          	endbr64 
  411a44:	55                   	push   rbp
  411a45:	31 d2                	xor    edx,edx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411a47:	8d 47 01             	lea    eax,[rdi+0x1]
  411a4a:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  411a4d:	48 89 d6             	mov    rsi,rdx
  411a50:	48 89 d7             	mov    rdi,rdx
  411a53:	48 89 e5             	mov    rbp,rsp
  411a56:	41 54                	push   r12
  411a58:	53                   	push   rbx
  411a59:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  411a5d:	48 89 d3             	mov    rbx,rdx
  411a60:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411a63:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411a67:	48 89 cd             	mov    rbp,rcx
  411a6a:	49 b8 80 1a 41 00 00 	movabs r8,0x411a80
  411a71:	00 00 00 
  411a74:	0f 05                	syscall 
  411a76:	66 90                	xchg   ax,ax
  411a78:	eb 0d                	jmp    411a87 <cos_thd_switch+0x47>
  411a7a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411a80:	b9 00 00 00 00       	mov    ecx,0x0
  411a85:	eb 05                	jmp    411a8c <cos_thd_switch+0x4c>
  411a87:	b9 01 00 00 00       	mov    ecx,0x1
  411a8c:	5d                   	pop    rbp
  411a8d:	5c                   	pop    rsp
	return call_cap_op(c, 0, 0, 0, 0, 0);
}
  411a8e:	5b                   	pop    rbx
  411a8f:	41 5c                	pop    r12
  411a91:	5d                   	pop    rbp
  411a92:	c3                   	ret    
  411a93:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  411a9a:	00 00 00 00 
  411a9e:	66 90                	xchg   ax,ax

0000000000411aa0 <cos_thd_wakeup>:

int
cos_thd_wakeup(thdcap_t thd, tcap_t tc, tcap_prio_t prio, tcap_res_t res)
{
  411aa0:	f3 0f 1e fa          	endbr64 
  411aa4:	55                   	push   rbp
  411aa5:	49 89 fa             	mov    r10,rdi
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411aa8:	c1 e6 10             	shl    esi,0x10
  411aab:	48 89 d7             	mov    rdi,rdx
	cap_no += op;
  411aae:	8d 86 2a 00 01 00    	lea    eax,[rsi+0x1002a]
	return call_cap_op(tc, CAPTBL_OP_TCAP_WAKEUP, thd, (prio << 32) >> 32, prio >> 32, res);
  411ab4:	48 c1 ef 20          	shr    rdi,0x20
  411ab8:	89 d6                	mov    esi,edx
{
  411aba:	48 89 e5             	mov    rbp,rsp
  411abd:	41 55                	push   r13
  411abf:	49 89 cd             	mov    r13,rcx
  411ac2:	41 54                	push   r12
	__asm__ __volatile__(
  411ac4:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  411ac8:	4c 89 ea             	mov    rdx,r13
  411acb:	53                   	push   rbx
  411acc:	4c 89 d3             	mov    rbx,r10
  411acf:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411ad2:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411ad6:	48 89 cd             	mov    rbp,rcx
  411ad9:	49 b8 f0 1a 41 00 00 	movabs r8,0x411af0
  411ae0:	00 00 00 
  411ae3:	0f 05                	syscall 
  411ae5:	0f 1f 00             	nop    DWORD PTR [rax]
  411ae8:	eb 0d                	jmp    411af7 <cos_thd_wakeup+0x57>
  411aea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411af0:	b9 00 00 00 00       	mov    ecx,0x0
  411af5:	eb 05                	jmp    411afc <cos_thd_wakeup+0x5c>
  411af7:	b9 01 00 00 00       	mov    ecx,0x1
  411afc:	5d                   	pop    rbp
  411afd:	5c                   	pop    rsp
}
  411afe:	5b                   	pop    rbx
  411aff:	41 5c                	pop    r12
  411b01:	41 5d                	pop    r13
  411b03:	5d                   	pop    rbp
  411b04:	c3                   	ret    
  411b05:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  411b0c:	00 00 00 00 

0000000000411b10 <cos_sched_sync>:

sched_tok_t
cos_sched_sync(void)
{
  411b10:	f3 0f 1e fa          	endbr64 
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  411b14:	0f 01 f9             	rdtscp 
        __asm__ __volatile__("lock " PS_FAA_STR
  411b17:	b8 01 00 00 00       	mov    eax,0x1
	static sched_tok_t stok[NUM_CPU] CACHE_ALIGNED;

	return ps_faa((unsigned long *)&stok[cos_cpuid()], 1);
  411b1c:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  411b22:	f0 48 0f c1 04 8d c0 	lock xadd QWORD PTR [rcx*4+0x709ac0],rax
  411b29:	9a 70 00 
}
  411b2c:	c3                   	ret    
  411b2d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000411b30 <cos_switch>:

int
cos_switch(thdcap_t c, tcap_t tc, tcap_prio_t prio, tcap_time_t timeout, arcvcap_t rcv, sched_tok_t stok)
{
  411b30:	f3 0f 1e fa          	endbr64 
  411b34:	55                   	push   rbp
  411b35:	49 89 fa             	mov    r10,rdi
  411b38:	49 89 f3             	mov    r11,rsi
  411b3b:	4c 89 c7             	mov    rdi,r8
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411b3e:	41 83 c2 01          	add    r10d,0x1
  411b42:	48 89 d6             	mov    rsi,rdx
  411b45:	48 89 ca             	mov    rdx,rcx
  411b48:	41 c1 e2 10          	shl    r10d,0x10
  411b4c:	48 89 e5             	mov    rbp,rsp
  411b4f:	41 54                	push   r12
	cap_no += op;
  411b51:	43 8d 04 1a          	lea    eax,[r10+r11*1]
  411b55:	53                   	push   rbx
	__asm__ __volatile__(
  411b56:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
#if defined(__x86_64__)
	return call_cap_op(c, tc, stok, prio, rcv, timeout);
  411b5a:	44 89 cb             	mov    ebx,r9d
  411b5d:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411b60:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411b64:	48 89 cd             	mov    rbp,rcx
  411b67:	49 b8 80 1b 41 00 00 	movabs r8,0x411b80
  411b6e:	00 00 00 
  411b71:	0f 05                	syscall 
  411b73:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  411b78:	eb 0d                	jmp    411b87 <cos_switch+0x57>
  411b7a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411b80:	b9 00 00 00 00       	mov    ecx,0x0
  411b85:	eb 05                	jmp    411b8c <cos_switch+0x5c>
  411b87:	b9 01 00 00 00       	mov    ecx,0x1
  411b8c:	5d                   	pop    rbp
  411b8d:	5c                   	pop    rsp
#else
	return call_cap_op(c, (stok >> 16), tc << 16 | rcv, (prio << 32) >> 32,
	                   (((prio << 16) >> 48) << 16) | ((stok << 16) >> 16), timeout);
#endif
}
  411b8e:	5b                   	pop    rbx
  411b8f:	41 5c                	pop    r12
  411b91:	5d                   	pop    rbp
  411b92:	c3                   	ret    
  411b93:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  411b9a:	00 00 00 00 
  411b9e:	66 90                	xchg   ax,ax

0000000000411ba0 <cos_sched_asnd>:

int
cos_sched_asnd(asndcap_t snd, tcap_time_t timeout, arcvcap_t srcv, sched_tok_t stok)
{
  411ba0:	f3 0f 1e fa          	endbr64 
  411ba4:	55                   	push   rbp
  411ba5:	49 89 d2             	mov    r10,rdx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411ba8:	8d 47 01             	lea    eax,[rdi+0x1]
	__asm__ __volatile__(
  411bab:	31 d2                	xor    edx,edx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411bad:	c1 e0 10             	shl    eax,0x10
  411bb0:	48 89 e5             	mov    rbp,rsp
  411bb3:	41 55                	push   r13
  411bb5:	49 89 f5             	mov    r13,rsi
	return call_cap_op(snd, 0, srcv, stok, timeout, 0);
  411bb8:	89 ce                	mov    esi,ecx
{
  411bba:	41 54                	push   r12
	__asm__ __volatile__(
  411bbc:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  411bc0:	4c 89 ef             	mov    rdi,r13
  411bc3:	53                   	push   rbx
  411bc4:	4c 89 d3             	mov    rbx,r10
  411bc7:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411bca:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411bce:	48 89 cd             	mov    rbp,rcx
  411bd1:	49 b8 e8 1b 41 00 00 	movabs r8,0x411be8
  411bd8:	00 00 00 
  411bdb:	0f 05                	syscall 
  411bdd:	0f 1f 00             	nop    DWORD PTR [rax]
  411be0:	eb 0d                	jmp    411bef <cos_sched_asnd+0x4f>
  411be2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411be8:	b9 00 00 00 00       	mov    ecx,0x0
  411bed:	eb 05                	jmp    411bf4 <cos_sched_asnd+0x54>
  411bef:	b9 01 00 00 00       	mov    ecx,0x1
  411bf4:	5d                   	pop    rbp
  411bf5:	5c                   	pop    rsp
}
  411bf6:	5b                   	pop    rbx
  411bf7:	41 5c                	pop    r12
  411bf9:	41 5d                	pop    r13
  411bfb:	5d                   	pop    rbp
  411bfc:	c3                   	ret    
  411bfd:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000411c00 <cos_asnd>:

int
cos_asnd(asndcap_t snd, int yield)
{
  411c00:	f3 0f 1e fa          	endbr64 
  411c04:	55                   	push   rbp
  411c05:	48 63 d6             	movsxd rdx,esi
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411c08:	8d 47 01             	lea    eax,[rdi+0x1]
	__asm__ __volatile__(
  411c0b:	31 f6                	xor    esi,esi
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411c0d:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  411c10:	48 89 f7             	mov    rdi,rsi
  411c13:	48 89 e5             	mov    rbp,rsp
  411c16:	41 54                	push   r12
  411c18:	53                   	push   rbx
  411c19:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  411c1d:	48 89 f3             	mov    rbx,rsi
  411c20:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411c23:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411c27:	48 89 cd             	mov    rbp,rcx
  411c2a:	49 b8 40 1c 41 00 00 	movabs r8,0x411c40
  411c31:	00 00 00 
  411c34:	0f 05                	syscall 
  411c36:	66 90                	xchg   ax,ax
  411c38:	eb 0d                	jmp    411c47 <cos_asnd+0x47>
  411c3a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411c40:	b9 00 00 00 00       	mov    ecx,0x0
  411c45:	eb 05                	jmp    411c4c <cos_asnd+0x4c>
  411c47:	b9 01 00 00 00       	mov    ecx,0x1
  411c4c:	5d                   	pop    rbp
  411c4d:	5c                   	pop    rsp
	return call_cap_op(snd, 0, 0, 0, 0, yield);
}
  411c4e:	5b                   	pop    rbx
  411c4f:	41 5c                	pop    r12
  411c51:	5d                   	pop    rbp
  411c52:	c3                   	ret    
  411c53:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  411c5a:	00 00 00 00 
  411c5e:	66 90                	xchg   ax,ax

0000000000411c60 <cos_sched_rcv>:

int
cos_sched_rcv(arcvcap_t rcv, rcv_flags_t flags, tcap_time_t timeout,
	      int *rcvd, thdid_t *thdid, int *blocked, cycles_t *cycles, tcap_time_t *thd_timeout)
{
  411c60:	f3 0f 1e fa          	endbr64 
  411c64:	55                   	push   rbp
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411c65:	8d 47 01             	lea    eax,[rdi+0x1]
	__asm__ __volatile__(
  411c68:	31 ff                	xor    edi,edi
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411c6a:	c1 e0 10             	shl    eax,0x10
  411c6d:	48 89 e5             	mov    rbp,rsp
  411c70:	41 57                	push   r15
  411c72:	49 89 cf             	mov    r15,rcx
  411c75:	41 56                	push   r14
	__asm__ __volatile__(
  411c77:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  411c7b:	4d 89 c6             	mov    r14,r8
  411c7e:	41 55                	push   r13
  411c80:	4d 89 cd             	mov    r13,r9
  411c83:	41 54                	push   r12
  411c85:	53                   	push   rbx
  411c86:	89 f3                	mov    ebx,esi
  411c88:	48 89 d6             	mov    rsi,rdx
  411c8b:	48 89 fa             	mov    rdx,rdi
  411c8e:	49 89 da             	mov    r10,rbx
  411c91:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411c94:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411c98:	48 89 cd             	mov    rbp,rcx
  411c9b:	49 b8 b0 1c 41 00 00 	movabs r8,0x411cb0
  411ca2:	00 00 00 
  411ca5:	0f 05                	syscall 
  411ca7:	90                   	nop
  411ca8:	eb 0f                	jmp    411cb9 <cos_sched_rcv+0x59>
  411caa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411cb0:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  411cb7:	eb 07                	jmp    411cc0 <cos_sched_rcv+0x60>
  411cb9:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  411cc0:	5d                   	pop    rbp
  411cc1:	5c                   	pop    rsp
  411cc2:	48 8b 55 18          	mov    rdx,QWORD PTR [rbp+0x18]
  411cc6:	48 89 1a             	mov    QWORD PTR [rdx],rbx
	unsigned long cyc       = 0;
	int           ret;

	ret = call_cap_retvals_asm(rcv, 0, flags, timeout, 0, 0, &thd_state, &cyc, thd_timeout);

	*blocked = (int)(thd_state >> (sizeof(thd_state) * 8 - 1));
  411cc9:	48 89 f2             	mov    rdx,rsi
	*thdid   = (thdid_t)(thd_state & ((1 << (sizeof(unsigned short int) * 8)) - 1));
  411ccc:	81 e6 ff ff 00 00    	and    esi,0xffff
	*blocked = (int)(thd_state >> (sizeof(thd_state) * 8 - 1));
  411cd2:	48 c1 ea 3f          	shr    rdx,0x3f
  411cd6:	41 89 55 00          	mov    DWORD PTR [r13+0x0],edx
	*cycles  = cyc;
  411cda:	48 8b 55 10          	mov    rdx,QWORD PTR [rbp+0x10]
	*thdid   = (thdid_t)(thd_state & ((1 << (sizeof(unsigned short int) * 8)) - 1));
  411cde:	49 89 36             	mov    QWORD PTR [r14],rsi
	*cycles  = cyc;
  411ce1:	48 89 3a             	mov    QWORD PTR [rdx],rdi

	if (ret >= 0 && flags & RCV_ALL_PENDING) {
  411ce4:	85 c0                	test   eax,eax
  411ce6:	78 10                	js     411cf8 <cos_sched_rcv+0x98>
  411ce8:	41 83 e2 02          	and    r10d,0x2
  411cec:	74 0a                	je     411cf8 <cos_sched_rcv+0x98>
		*rcvd = (ret >> 1);
  411cee:	89 c2                	mov    edx,eax
		ret &= 1;
  411cf0:	83 e0 01             	and    eax,0x1
		*rcvd = (ret >> 1);
  411cf3:	d1 fa                	sar    edx,1
  411cf5:	41 89 17             	mov    DWORD PTR [r15],edx
	}

	return ret;
}
  411cf8:	5b                   	pop    rbx
  411cf9:	41 5c                	pop    r12
  411cfb:	41 5d                	pop    r13
  411cfd:	41 5e                	pop    r14
  411cff:	41 5f                	pop    r15
  411d01:	5d                   	pop    rbp
  411d02:	c3                   	ret    
  411d03:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  411d0a:	00 00 00 00 
  411d0e:	66 90                	xchg   ax,ax

0000000000411d10 <cos_rcv>:

int
cos_rcv(arcvcap_t rcv, rcv_flags_t flags, int *rcvd)
{
  411d10:	f3 0f 1e fa          	endbr64 
  411d14:	55                   	push   rbp
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411d15:	8d 47 01             	lea    eax,[rdi+0x1]
	__asm__ __volatile__(
  411d18:	31 ff                	xor    edi,edi
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411d1a:	c1 e0 10             	shl    eax,0x10
  411d1d:	48 89 e5             	mov    rbp,rsp
  411d20:	41 55                	push   r13
  411d22:	49 89 d5             	mov    r13,rdx
	__asm__ __volatile__(
  411d25:	48 89 fa             	mov    rdx,rdi
  411d28:	41 54                	push   r12
  411d2a:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  411d2e:	53                   	push   rbx
  411d2f:	89 f3                	mov    ebx,esi
  411d31:	48 89 fe             	mov    rsi,rdi
  411d34:	49 89 da             	mov    r10,rbx
  411d37:	48 83 ec 18          	sub    rsp,0x18
  411d3b:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411d3e:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411d42:	48 89 cd             	mov    rbp,rcx
  411d45:	49 b8 60 1d 41 00 00 	movabs r8,0x411d60
  411d4c:	00 00 00 
  411d4f:	0f 05                	syscall 
  411d51:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  411d58:	eb 0f                	jmp    411d69 <cos_rcv+0x59>
  411d5a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411d60:	48 c7 c1 00 00 00 00 	mov    rcx,0x0
  411d67:	eb 07                	jmp    411d70 <cos_rcv+0x60>
  411d69:	48 c7 c1 01 00 00 00 	mov    rcx,0x1
  411d70:	5d                   	pop    rbp
  411d71:	5c                   	pop    rsp
	*thdid   = (thdid_t)(thd_state & ((1 << (sizeof(unsigned short int) * 8)) - 1));
  411d72:	0f b7 f6             	movzx  esi,si
	if (ret >= 0 && flags & RCV_ALL_PENDING) {
  411d75:	85 c0                	test   eax,eax
  411d77:	78 06                	js     411d7f <cos_rcv+0x6f>
  411d79:	41 83 e2 02          	and    r10d,0x2
  411d7d:	75 11                	jne    411d90 <cos_rcv+0x80>
	cycles_t    cyc;
	int         ret;
	tcap_time_t thd_timeout;

	ret = cos_sched_rcv(rcv, flags, 0, rcvd, &tid, &blocked, &cyc, &thd_timeout);
	assert(tid == 0);
  411d7f:	48 85 f6             	test   rsi,rsi
  411d82:	75 1c                	jne    411da0 <cos_rcv+0x90>

	return ret;
}
  411d84:	48 83 c4 18          	add    rsp,0x18
  411d88:	5b                   	pop    rbx
  411d89:	41 5c                	pop    r12
  411d8b:	41 5d                	pop    r13
  411d8d:	5d                   	pop    rbp
  411d8e:	c3                   	ret    
  411d8f:	90                   	nop
		*rcvd = (ret >> 1);
  411d90:	89 c2                	mov    edx,eax
		ret &= 1;
  411d92:	83 e0 01             	and    eax,0x1
		*rcvd = (ret >> 1);
  411d95:	d1 fa                	sar    edx,1
  411d97:	41 89 55 00          	mov    DWORD PTR [r13+0x0],edx
	assert(tid == 0);
  411d9b:	48 85 f6             	test   rsi,rsi
  411d9e:	74 e4                	je     411d84 <cos_rcv+0x74>
  411da0:	be 2f 00 00 00       	mov    esi,0x2f
  411da5:	bf b8 f0 41 00       	mov    edi,0x41f0b8
  411daa:	e8 d1 8e ff ff       	call   40ac80 <cos_print_str>
  411daf:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411db6:	00 00 00 00 
  411dba:	0f 0b                	ud2    
  411dbc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000411dc0 <cos_mem_aliasn_aligned>:

vaddr_t
cos_mem_aliasn_aligned(struct cos_compinfo *dstci, struct cos_compinfo *srcci, vaddr_t src, size_t sz, size_t align, unsigned long perm_flags)
{
  411dc0:	f3 0f 1e fa          	endbr64 
  411dc4:	55                   	push   rbp
  411dc5:	48 89 e5             	mov    rbp,rsp
  411dc8:	41 57                	push   r15
  411dca:	41 56                	push   r14
  411dcc:	41 55                	push   r13
  411dce:	41 54                	push   r12
  411dd0:	53                   	push   rbx
  411dd1:	48 83 ec 28          	sub    rsp,0x28
  411dd5:	48 89 55 b0          	mov    QWORD PTR [rbp-0x50],rdx
  411dd9:	48 89 4d b8          	mov    QWORD PTR [rbp-0x48],rcx
	size_t i;
	vaddr_t dst, first_dst;

	assert(srcci && dstci);
  411ddd:	48 85 f6             	test   rsi,rsi
  411de0:	0f 84 f3 00 00 00    	je     411ed9 <cos_mem_aliasn_aligned+0x119>
  411de6:	49 89 fd             	mov    r13,rdi
  411de9:	48 85 ff             	test   rdi,rdi
  411dec:	0f 84 e7 00 00 00    	je     411ed9 <cos_mem_aliasn_aligned+0x119>
	assert(sz && (sz % PAGE_SIZE == 0));
  411df2:	48 85 c9             	test   rcx,rcx
  411df5:	0f 84 c2 00 00 00    	je     411ebd <cos_mem_aliasn_aligned+0xfd>
  411dfb:	f7 c1 ff 0f 00 00    	test   ecx,0xfff
  411e01:	0f 85 b6 00 00 00    	jne    411ebd <cos_mem_aliasn_aligned+0xfd>
  411e07:	4c 89 c2             	mov    rdx,r8
	assert(align % PAGE_SIZE == 0);
  411e0a:	41 f7 c0 ff 0f 00 00 	test   r8d,0xfff
  411e11:	0f 85 de 00 00 00    	jne    411ef5 <cos_mem_aliasn_aligned+0x135>
  411e17:	49 89 f6             	mov    r14,rsi
  411e1a:	48 89 ce             	mov    rsi,rcx
  411e1d:	4c 89 cb             	mov    rbx,r9

	dst = __page_bump_valloc(dstci, sz, align);
  411e20:	e8 ab b0 ff ff       	call   40ced0 <__page_bump_valloc>
  411e25:	49 89 c7             	mov    r15,rax
	if (unlikely(!dst)) return 0;
  411e28:	48 85 c0             	test   rax,rax
  411e2b:	0f 84 87 00 00 00    	je     411eb8 <cos_mem_aliasn_aligned+0xf8>
	first_dst = dst;

	for (i = 0; i < sz; i += PAGE_SIZE, src += PAGE_SIZE, dst += PAGE_SIZE) {
  411e31:	45 31 d2             	xor    r10d,r10d
  411e34:	48 89 da             	mov    rdx,rbx
  411e37:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  411e3e:	00 00 
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411e40:	41 8b 06             	mov    eax,DWORD PTR [r14]
	__asm__ __volatile__(
  411e43:	48 8b 5d b0          	mov    rbx,QWORD PTR [rbp-0x50]
  411e47:	4b 8d 3c 3a          	lea    rdi,[r10+r15*1]
  411e4b:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  411e4f:	49 8b 75 00          	mov    rsi,QWORD PTR [r13+0x0]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411e53:	83 c0 01             	add    eax,0x1
	__asm__ __volatile__(
  411e56:	4c 01 d3             	add    rbx,r10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411e59:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  411e5c:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411e5f:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411e63:	48 89 cd             	mov    rbp,rcx
  411e66:	49 b8 80 1e 41 00 00 	movabs r8,0x411e80
  411e6d:	00 00 00 
  411e70:	0f 05                	syscall 
  411e72:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411e78:	eb 0d                	jmp    411e87 <cos_mem_aliasn_aligned+0xc7>
  411e7a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411e80:	b9 00 00 00 00       	mov    ecx,0x0
  411e85:	eb 05                	jmp    411e8c <cos_mem_aliasn_aligned+0xcc>
  411e87:	b9 01 00 00 00       	mov    ecx,0x1
  411e8c:	5d                   	pop    rbp
  411e8d:	5c                   	pop    rsp
		if (call_cap_op(srcci->pgtbl_cap, CAPTBL_OP_CPY, src, dstci->pgtbl_cap, dst, perm_flags)) return 0;
  411e8e:	85 c0                	test   eax,eax
  411e90:	75 26                	jne    411eb8 <cos_mem_aliasn_aligned+0xf8>
	for (i = 0; i < sz; i += PAGE_SIZE, src += PAGE_SIZE, dst += PAGE_SIZE) {
  411e92:	49 81 c2 00 10 00 00 	add    r10,0x1000
  411e99:	4c 39 55 b8          	cmp    QWORD PTR [rbp-0x48],r10
  411e9d:	77 a1                	ja     411e40 <cos_mem_aliasn_aligned+0x80>
	}

	return first_dst;
}
  411e9f:	48 83 c4 28          	add    rsp,0x28
  411ea3:	4c 89 f8             	mov    rax,r15
  411ea6:	5b                   	pop    rbx
  411ea7:	41 5c                	pop    r12
  411ea9:	41 5d                	pop    r13
  411eab:	41 5e                	pop    r14
  411ead:	41 5f                	pop    r15
  411eaf:	5d                   	pop    rbp
  411eb0:	c3                   	ret    
  411eb1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	if (unlikely(!dst)) return 0;
  411eb8:	45 31 ff             	xor    r15d,r15d
  411ebb:	eb e2                	jmp    411e9f <cos_mem_aliasn_aligned+0xdf>
  411ebd:	be 2f 00 00 00       	mov    esi,0x2f
  411ec2:	bf 18 f1 41 00       	mov    edi,0x41f118
  411ec7:	e8 b4 8d ff ff       	call   40ac80 <cos_print_str>
	assert(sz && (sz % PAGE_SIZE == 0));
  411ecc:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411ed3:	00 00 00 00 
  411ed7:	0f 0b                	ud2    
  411ed9:	be 2f 00 00 00       	mov    esi,0x2f
  411ede:	bf e8 f0 41 00       	mov    edi,0x41f0e8
  411ee3:	e8 98 8d ff ff       	call   40ac80 <cos_print_str>
	assert(srcci && dstci);
  411ee8:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411eef:	00 00 00 00 
  411ef3:	0f 0b                	ud2    
  411ef5:	be 2f 00 00 00       	mov    esi,0x2f
  411efa:	bf 48 f1 41 00       	mov    edi,0x41f148
  411eff:	e8 7c 8d ff ff       	call   40ac80 <cos_print_str>
	assert(align % PAGE_SIZE == 0);
  411f04:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411f0b:	00 00 00 00 
  411f0f:	0f 0b                	ud2    
  411f11:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  411f18:	00 00 00 00 
  411f1c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000411f20 <cos_mem_aliasn>:

vaddr_t
cos_mem_aliasn(struct cos_compinfo *dstci, struct cos_compinfo *srcci, vaddr_t src, size_t sz, unsigned long perm_flags)
{
  411f20:	f3 0f 1e fa          	endbr64 
	return cos_mem_aliasn_aligned(dstci, srcci, src, sz, PAGE_SIZE, perm_flags);
  411f24:	4d 89 c1             	mov    r9,r8
  411f27:	41 b8 00 10 00 00    	mov    r8d,0x1000
  411f2d:	e9 8e fe ff ff       	jmp    411dc0 <cos_mem_aliasn_aligned>
  411f32:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  411f39:	00 00 00 00 
  411f3d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000411f40 <cos_mem_alias>:
}

vaddr_t
cos_mem_alias(struct cos_compinfo *dstci, struct cos_compinfo *srcci, vaddr_t src, unsigned long perm_flags)
{
  411f40:	f3 0f 1e fa          	endbr64 
  411f44:	49 89 c9             	mov    r9,rcx
	return cos_mem_aliasn_aligned(dstci, srcci, src, sz, PAGE_SIZE, perm_flags);
  411f47:	41 b8 00 10 00 00    	mov    r8d,0x1000
  411f4d:	b9 00 10 00 00       	mov    ecx,0x1000
  411f52:	e9 69 fe ff ff       	jmp    411dc0 <cos_mem_aliasn_aligned>
  411f57:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  411f5e:	00 00 

0000000000411f60 <cos_mem_alias_at>:
	return cos_mem_aliasn(dstci, srcci, src, PAGE_SIZE, perm_flags);
}

int
cos_mem_alias_at(struct cos_compinfo *dstci, vaddr_t dst, struct cos_compinfo *srcci, vaddr_t src, unsigned long perm_flags)
{
  411f60:	f3 0f 1e fa          	endbr64 
  411f64:	55                   	push   rbp
  411f65:	48 89 d0             	mov    rax,rdx
  411f68:	48 89 e5             	mov    rbp,rsp
  411f6b:	41 54                	push   r12
  411f6d:	53                   	push   rbx
  411f6e:	48 83 ec 10          	sub    rsp,0x10
	assert(srcci && dstci);
  411f72:	48 85 d2             	test   rdx,rdx
  411f75:	74 7d                	je     411ff4 <cos_mem_alias_at+0x94>
  411f77:	49 89 f9             	mov    r9,rdi
  411f7a:	48 85 ff             	test   rdi,rdi
  411f7d:	74 75                	je     411ff4 <cos_mem_alias_at+0x94>

	if (call_cap_op(srcci->pgtbl_cap, CAPTBL_OP_CPY, src, dstci->pgtbl_cap, dst, perm_flags)) BUG();
  411f7f:	48 8b 00             	mov    rax,QWORD PTR [rax]
  411f82:	48 89 f7             	mov    rdi,rsi
  411f85:	48 89 cb             	mov    rbx,rcx
  411f88:	49 8b 31             	mov    rsi,QWORD PTR [r9]
  411f8b:	4c 89 c2             	mov    rdx,r8
  411f8e:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  411f92:	83 c0 01             	add    eax,0x1
  411f95:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  411f98:	48 89 29             	mov    QWORD PTR [rcx],rbp
  411f9b:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  411f9f:	48 89 cd             	mov    rbp,rcx
  411fa2:	49 b8 b8 1f 41 00 00 	movabs r8,0x411fb8
  411fa9:	00 00 00 
  411fac:	0f 05                	syscall 
  411fae:	66 90                	xchg   ax,ax
  411fb0:	eb 0d                	jmp    411fbf <cos_mem_alias_at+0x5f>
  411fb2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  411fb8:	b9 00 00 00 00       	mov    ecx,0x0
  411fbd:	eb 05                	jmp    411fc4 <cos_mem_alias_at+0x64>
  411fbf:	b9 01 00 00 00       	mov    ecx,0x1
  411fc4:	5d                   	pop    rbp
  411fc5:	5c                   	pop    rsp
  411fc6:	85 c0                	test   eax,eax
  411fc8:	75 0e                	jne    411fd8 <cos_mem_alias_at+0x78>

	return 0;
}
  411fca:	48 83 c4 10          	add    rsp,0x10
  411fce:	31 c0                	xor    eax,eax
  411fd0:	5b                   	pop    rbx
  411fd1:	41 5c                	pop    r12
  411fd3:	5d                   	pop    rbp
  411fd4:	c3                   	ret    
  411fd5:	0f 1f 00             	nop    DWORD PTR [rax]
  411fd8:	be 1c 00 00 00       	mov    esi,0x1c
  411fdd:	bf a8 f1 41 00       	mov    edi,0x41f1a8
  411fe2:	e8 99 8c ff ff       	call   40ac80 <cos_print_str>
	if (call_cap_op(srcci->pgtbl_cap, CAPTBL_OP_CPY, src, dstci->pgtbl_cap, dst, perm_flags)) BUG();
  411fe7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  411fee:	00 00 00 00 
  411ff2:	0f 0b                	ud2    
  411ff4:	be 2f 00 00 00       	mov    esi,0x2f
  411ff9:	bf 78 f1 41 00       	mov    edi,0x41f178
  411ffe:	e8 7d 8c ff ff       	call   40ac80 <cos_print_str>
	assert(srcci && dstci);
  412003:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41200a:	00 00 00 00 
  41200e:	0f 0b                	ud2    

0000000000412010 <cos_mem_alias_atn>:

int
cos_mem_alias_atn(struct cos_compinfo *dstci, vaddr_t dst, struct cos_compinfo *srcci, vaddr_t src, size_t sz, unsigned long perm_flags)
{
  412010:	f3 0f 1e fa          	endbr64 
  412014:	55                   	push   rbp
  412015:	48 89 e5             	mov    rbp,rsp
  412018:	41 57                	push   r15
  41201a:	41 56                	push   r14
  41201c:	49 89 d6             	mov    r14,rdx
  41201f:	41 55                	push   r13
  412021:	41 54                	push   r12
  412023:	53                   	push   rbx
  412024:	48 83 ec 18          	sub    rsp,0x18
	size_t i;
	size_t npages;

	assert(srcci && dstci);
  412028:	48 85 d2             	test   rdx,rdx
  41202b:	0f 84 c0 00 00 00    	je     4120f1 <cos_mem_alias_atn+0xe1>
  412031:	49 89 ff             	mov    r15,rdi
  412034:	48 85 ff             	test   rdi,rdi
  412037:	0f 84 b4 00 00 00    	je     4120f1 <cos_mem_alias_atn+0xe1>
	assert(sz % PAGE_SIZE == 0);
  41203d:	41 f7 c0 ff 0f 00 00 	test   r8d,0xfff
  412044:	0f 85 c3 00 00 00    	jne    41210d <cos_mem_alias_atn+0xfd>

	npages = sz / PAGE_SIZE;
	for (i=0; i < npages; i++) {
  41204a:	49 c1 e8 0c          	shr    r8,0xc
  41204e:	0f 84 8c 00 00 00    	je     4120e0 <cos_mem_alias_atn+0xd0>
  412054:	49 89 f5             	mov    r13,rsi
  412057:	49 c1 e0 0c          	shl    r8,0xc
  41205b:	48 89 cb             	mov    rbx,rcx
  41205e:	4c 89 ca             	mov    rdx,r9
  412061:	4d 8d 14 08          	lea    r10,[r8+rcx*1]
  412065:	49 29 cd             	sub    r13,rcx
  412068:	eb 12                	jmp    41207c <cos_mem_alias_atn+0x6c>
  41206a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  412070:	48 81 c3 00 10 00 00 	add    rbx,0x1000
  412077:	49 39 da             	cmp    r10,rbx
  41207a:	74 64                	je     4120e0 <cos_mem_alias_atn+0xd0>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  41207c:	41 8b 06             	mov    eax,DWORD PTR [r14]
	__asm__ __volatile__(
  41207f:	49 8b 37             	mov    rsi,QWORD PTR [r15]
  412082:	49 8d 7c 1d 00       	lea    rdi,[r13+rbx*1+0x0]
  412087:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  41208b:	83 c0 01             	add    eax,0x1
  41208e:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  412091:	48 89 29             	mov    QWORD PTR [rcx],rbp
  412094:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  412098:	48 89 cd             	mov    rbp,rcx
  41209b:	49 b8 b0 20 41 00 00 	movabs r8,0x4120b0
  4120a2:	00 00 00 
  4120a5:	0f 05                	syscall 
  4120a7:	90                   	nop
  4120a8:	eb 0d                	jmp    4120b7 <cos_mem_alias_atn+0xa7>
  4120aa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4120b0:	b9 00 00 00 00       	mov    ecx,0x0
  4120b5:	eb 05                	jmp    4120bc <cos_mem_alias_atn+0xac>
  4120b7:	b9 01 00 00 00       	mov    ecx,0x1
  4120bc:	5d                   	pop    rbp
  4120bd:	5c                   	pop    rsp
		if (call_cap_op(srcci->pgtbl_cap, CAPTBL_OP_CPY, src + i * PAGE_SIZE, dstci->pgtbl_cap, dst + i * PAGE_SIZE, perm_flags)) BUG();
  4120be:	85 c0                	test   eax,eax
  4120c0:	74 ae                	je     412070 <cos_mem_alias_atn+0x60>
  4120c2:	be 1c 00 00 00       	mov    esi,0x1c
  4120c7:	bf 28 f2 41 00       	mov    edi,0x41f228
  4120cc:	e8 af 8b ff ff       	call   40ac80 <cos_print_str>
  4120d1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4120d8:	00 00 00 00 
  4120dc:	0f 0b                	ud2    
  4120de:	66 90                	xchg   ax,ax
	}

	return 0;
}
  4120e0:	48 83 c4 18          	add    rsp,0x18
  4120e4:	31 c0                	xor    eax,eax
  4120e6:	5b                   	pop    rbx
  4120e7:	41 5c                	pop    r12
  4120e9:	41 5d                	pop    r13
  4120eb:	41 5e                	pop    r14
  4120ed:	41 5f                	pop    r15
  4120ef:	5d                   	pop    rbp
  4120f0:	c3                   	ret    
  4120f1:	be 2f 00 00 00       	mov    esi,0x2f
  4120f6:	bf c8 f1 41 00       	mov    edi,0x41f1c8
  4120fb:	e8 80 8b ff ff       	call   40ac80 <cos_print_str>
	assert(srcci && dstci);
  412100:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412107:	00 00 00 00 
  41210b:	0f 0b                	ud2    
  41210d:	be 2f 00 00 00       	mov    esi,0x2f
  412112:	bf f8 f1 41 00       	mov    edi,0x41f1f8
  412117:	e8 64 8b ff ff       	call   40ac80 <cos_print_str>
	assert(sz % PAGE_SIZE == 0);
  41211c:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412123:	00 00 00 00 
  412127:	0f 0b                	ud2    
  412129:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000412130 <cos_mem_remove>:

int
cos_mem_remove(pgtblcap_t pt, vaddr_t addr)
{
  412130:	f3 0f 1e fa          	endbr64 
  412134:	55                   	push   rbp
  412135:	be 2f 00 00 00       	mov    esi,0x2f
  41213a:	bf 48 f2 41 00       	mov    edi,0x41f248
  41213f:	48 89 e5             	mov    rbp,rsp
  412142:	e8 39 8b ff ff       	call   40ac80 <cos_print_str>
	assert(0);
  412147:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41214e:	00 00 00 00 
  412152:	0f 0b                	ud2    
  412154:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41215b:	00 00 00 00 
  41215f:	90                   	nop

0000000000412160 <cos_mem_move>:
	return 0;
}

vaddr_t
cos_mem_move(struct cos_compinfo *dstci, struct cos_compinfo *srcci, vaddr_t src)
{
  412160:	f3 0f 1e fa          	endbr64 
  412164:	55                   	push   rbp
  412165:	48 89 e5             	mov    rbp,rsp
  412168:	41 55                	push   r13
  41216a:	41 54                	push   r12
  41216c:	53                   	push   rbx
  41216d:	48 83 ec 18          	sub    rsp,0x18
	vaddr_t dst;

	assert(srcci && dstci);
  412171:	48 85 f6             	test   rsi,rsi
  412174:	0f 84 a2 00 00 00    	je     41221c <cos_mem_move+0xbc>
  41217a:	49 89 fc             	mov    r12,rdi
  41217d:	48 85 ff             	test   rdi,rdi
  412180:	0f 84 96 00 00 00    	je     41221c <cos_mem_move+0xbc>
  412186:	49 89 f5             	mov    r13,rsi
  412189:	48 89 d3             	mov    rbx,rdx

	dst = __page_bump_valloc(dstci, PAGE_SIZE, PAGE_SIZE);
  41218c:	be 00 10 00 00       	mov    esi,0x1000
  412191:	ba 00 10 00 00       	mov    edx,0x1000
  412196:	e8 35 ad ff ff       	call   40ced0 <__page_bump_valloc>
  41219b:	49 89 c2             	mov    r10,rax
	if (unlikely(!dst)) return 0;
  41219e:	48 85 c0             	test   rax,rax
  4121a1:	74 4f                	je     4121f2 <cos_mem_move+0x92>

	if (call_cap_op(srcci->pgtbl_cap, CAPTBL_OP_MEMMOVE, src, dstci->pgtbl_cap, dst, 0)) BUG();
  4121a3:	49 8b 45 00          	mov    rax,QWORD PTR [r13+0x0]
  4121a7:	49 8b 34 24          	mov    rsi,QWORD PTR [r12]
  4121ab:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  4121af:	31 d2                	xor    edx,edx
  4121b1:	4c 89 d7             	mov    rdi,r10
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4121b4:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  4121b7:	05 24 00 01 00       	add    eax,0x10024
	__asm__ __volatile__(
  4121bc:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4121bf:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4121c3:	48 89 cd             	mov    rbp,rcx
  4121c6:	49 b8 e0 21 41 00 00 	movabs r8,0x4121e0
  4121cd:	00 00 00 
  4121d0:	0f 05                	syscall 
  4121d2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4121d8:	eb 0d                	jmp    4121e7 <cos_mem_move+0x87>
  4121da:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4121e0:	b9 00 00 00 00       	mov    ecx,0x0
  4121e5:	eb 05                	jmp    4121ec <cos_mem_move+0x8c>
  4121e7:	b9 01 00 00 00       	mov    ecx,0x1
  4121ec:	5d                   	pop    rbp
  4121ed:	5c                   	pop    rsp
  4121ee:	85 c0                	test   eax,eax
  4121f0:	75 0e                	jne    412200 <cos_mem_move+0xa0>

	return dst;
}
  4121f2:	48 83 c4 18          	add    rsp,0x18
  4121f6:	4c 89 d0             	mov    rax,r10
  4121f9:	5b                   	pop    rbx
  4121fa:	41 5c                	pop    r12
  4121fc:	41 5d                	pop    r13
  4121fe:	5d                   	pop    rbp
  4121ff:	c3                   	ret    
  412200:	be 1c 00 00 00       	mov    esi,0x1c
  412205:	bf a8 f2 41 00       	mov    edi,0x41f2a8
  41220a:	e8 71 8a ff ff       	call   40ac80 <cos_print_str>
	if (call_cap_op(srcci->pgtbl_cap, CAPTBL_OP_MEMMOVE, src, dstci->pgtbl_cap, dst, 0)) BUG();
  41220f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412216:	00 00 00 00 
  41221a:	0f 0b                	ud2    
  41221c:	be 2f 00 00 00       	mov    esi,0x2f
  412221:	bf 78 f2 41 00       	mov    edi,0x41f278
  412226:	e8 55 8a ff ff       	call   40ac80 <cos_print_str>
	assert(srcci && dstci);
  41222b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412232:	00 00 00 00 
  412236:	0f 0b                	ud2    
  412238:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41223f:	00 

0000000000412240 <cos_mem_move_at>:

int
cos_mem_move_at(struct cos_compinfo *dstci, vaddr_t dst, struct cos_compinfo *srcci, vaddr_t src)
{
  412240:	f3 0f 1e fa          	endbr64 
  412244:	55                   	push   rbp
  412245:	48 89 e5             	mov    rbp,rsp
  412248:	41 54                	push   r12
  41224a:	53                   	push   rbx
  41224b:	48 83 ec 10          	sub    rsp,0x10
	assert(srcci && dstci);
  41224f:	48 85 d2             	test   rdx,rdx
  412252:	0f 84 7c 00 00 00    	je     4122d4 <cos_mem_move_at+0x94>
  412258:	49 89 f8             	mov    r8,rdi
  41225b:	48 85 ff             	test   rdi,rdi
  41225e:	74 74                	je     4122d4 <cos_mem_move_at+0x94>

	/* TODO */
	if (call_cap_op(srcci->pgtbl_cap, CAPTBL_OP_MEMMOVE, src, dstci->pgtbl_cap, dst, 0)) BUG();
  412260:	48 8b 02             	mov    rax,QWORD PTR [rdx]
  412263:	48 89 f7             	mov    rdi,rsi
  412266:	48 89 cb             	mov    rbx,rcx
  412269:	49 8b 30             	mov    rsi,QWORD PTR [r8]
  41226c:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  412270:	31 d2                	xor    edx,edx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  412272:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  412275:	05 24 00 01 00       	add    eax,0x10024
	__asm__ __volatile__(
  41227a:	48 89 29             	mov    QWORD PTR [rcx],rbp
  41227d:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  412281:	48 89 cd             	mov    rbp,rcx
  412284:	49 b8 98 22 41 00 00 	movabs r8,0x412298
  41228b:	00 00 00 
  41228e:	0f 05                	syscall 
  412290:	eb 0d                	jmp    41229f <cos_mem_move_at+0x5f>
  412292:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  412298:	b9 00 00 00 00       	mov    ecx,0x0
  41229d:	eb 05                	jmp    4122a4 <cos_mem_move_at+0x64>
  41229f:	b9 01 00 00 00       	mov    ecx,0x1
  4122a4:	5d                   	pop    rbp
  4122a5:	5c                   	pop    rsp
  4122a6:	85 c0                	test   eax,eax
  4122a8:	75 0e                	jne    4122b8 <cos_mem_move_at+0x78>

	return 0;
}
  4122aa:	48 83 c4 10          	add    rsp,0x10
  4122ae:	31 c0                	xor    eax,eax
  4122b0:	5b                   	pop    rbx
  4122b1:	41 5c                	pop    r12
  4122b3:	5d                   	pop    rbp
  4122b4:	c3                   	ret    
  4122b5:	0f 1f 00             	nop    DWORD PTR [rax]
  4122b8:	be 1c 00 00 00       	mov    esi,0x1c
  4122bd:	bf f8 f2 41 00       	mov    edi,0x41f2f8
  4122c2:	e8 b9 89 ff ff       	call   40ac80 <cos_print_str>
	if (call_cap_op(srcci->pgtbl_cap, CAPTBL_OP_MEMMOVE, src, dstci->pgtbl_cap, dst, 0)) BUG();
  4122c7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4122ce:	00 00 00 00 
  4122d2:	0f 0b                	ud2    
  4122d4:	be 2f 00 00 00       	mov    esi,0x2f
  4122d9:	bf c8 f2 41 00       	mov    edi,0x41f2c8
  4122de:	e8 9d 89 ff ff       	call   40ac80 <cos_print_str>
	assert(srcci && dstci);
  4122e3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4122ea:	00 00 00 00 
  4122ee:	0f 0b                	ud2    

00000000004122f0 <cos_thd_mod>:

/* TODO: generalize to modify all state */
int
cos_thd_mod(struct cos_compinfo *ci, thdcap_t tc, void *tlsaddr)
{
  4122f0:	f3 0f 1e fa          	endbr64 
  4122f4:	55                   	push   rbp
  4122f5:	49 89 f2             	mov    r10,rsi
  4122f8:	48 89 d6             	mov    rsi,rdx
  4122fb:	31 d2                	xor    edx,edx
  4122fd:	48 89 e5             	mov    rbp,rsp
  412300:	41 54                	push   r12
  412302:	53                   	push   rbx
  412303:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  412307:	4c 89 d3             	mov    rbx,r10
	return call_cap_op(ci->captbl_cap, CAPTBL_OP_THDTLSSET, tc, (word_t)tlsaddr, 0, 0);
  41230a:	48 8b 47 08          	mov    rax,QWORD PTR [rdi+0x8]
  41230e:	48 89 d7             	mov    rdi,rdx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  412311:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  412314:	05 06 00 01 00       	add    eax,0x10006
	__asm__ __volatile__(
  412319:	48 89 29             	mov    QWORD PTR [rcx],rbp
  41231c:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  412320:	48 89 cd             	mov    rbp,rcx
  412323:	49 b8 38 23 41 00 00 	movabs r8,0x412338
  41232a:	00 00 00 
  41232d:	0f 05                	syscall 
  41232f:	90                   	nop
  412330:	eb 0d                	jmp    41233f <cos_thd_mod+0x4f>
  412332:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  412338:	b9 00 00 00 00       	mov    ecx,0x0
  41233d:	eb 05                	jmp    412344 <cos_thd_mod+0x54>
  41233f:	b9 01 00 00 00       	mov    ecx,0x1
  412344:	5d                   	pop    rbp
  412345:	5c                   	pop    rsp
}
  412346:	5b                   	pop    rbx
  412347:	41 5c                	pop    r12
  412349:	5d                   	pop    rbp
  41234a:	c3                   	ret    
  41234b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000412350 <cos_introspect>:

/* FIXME: problems when we got to 64 bit systems with the return value */
int
cos_introspect(struct cos_compinfo *ci, capid_t cap, unsigned long op)
{
  412350:	f3 0f 1e fa          	endbr64 
  412354:	55                   	push   rbp
  412355:	49 89 f2             	mov    r10,rsi
	return call_cap_op(ci->captbl_cap, CAPTBL_OP_INTROSPECT, cap, (int)op, 0, 0);
  412358:	48 63 f2             	movsxd rsi,edx
  41235b:	31 d2                	xor    edx,edx
{
  41235d:	48 89 e5             	mov    rbp,rsp
  412360:	41 54                	push   r12
  412362:	53                   	push   rbx
  412363:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  412367:	4c 89 d3             	mov    rbx,r10
	return call_cap_op(ci->captbl_cap, CAPTBL_OP_INTROSPECT, cap, (int)op, 0, 0);
  41236a:	48 8b 47 08          	mov    rax,QWORD PTR [rdi+0x8]
  41236e:	48 89 d7             	mov    rdi,rdx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  412371:	c1 e0 10             	shl    eax,0x10
	cap_no += op;
  412374:	05 25 00 01 00       	add    eax,0x10025
	__asm__ __volatile__(
  412379:	48 89 29             	mov    QWORD PTR [rcx],rbp
  41237c:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  412380:	48 89 cd             	mov    rbp,rcx
  412383:	49 b8 98 23 41 00 00 	movabs r8,0x412398
  41238a:	00 00 00 
  41238d:	0f 05                	syscall 
  41238f:	90                   	nop
  412390:	eb 0d                	jmp    41239f <cos_introspect+0x4f>
  412392:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  412398:	b9 00 00 00 00       	mov    ecx,0x0
  41239d:	eb 05                	jmp    4123a4 <cos_introspect+0x54>
  41239f:	b9 01 00 00 00       	mov    ecx,0x1
  4123a4:	5d                   	pop    rbp
  4123a5:	5c                   	pop    rsp
}
  4123a6:	5b                   	pop    rbx
  4123a7:	41 5c                	pop    r12
  4123a9:	5d                   	pop    rbp
  4123aa:	c3                   	ret    
  4123ab:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000004123b0 <cos_tcap_alloc>:

/***************** [Kernel Tcap Operations] *****************/

tcap_t
cos_tcap_alloc(struct cos_compinfo *ci)
{
  4123b0:	f3 0f 1e fa          	endbr64 
  4123b4:	55                   	push   rbp
  4123b5:	48 89 e5             	mov    rbp,rsp
  4123b8:	41 57                	push   r15
  4123ba:	41 56                	push   r14
  4123bc:	41 55                	push   r13
  4123be:	41 54                	push   r12
  4123c0:	53                   	push   rbx
  4123c1:	48 83 ec 18          	sub    rsp,0x18
	vaddr_t kmem;
	capid_t cap;

	printd("cos_tcap_alloc\n");
	assert(ci);
  4123c5:	48 85 ff             	test   rdi,rdi
  4123c8:	0f 84 4e 01 00 00    	je     41251c <cos_tcap_alloc+0x16c>
  4123ce:	49 89 fc             	mov    r12,rdi
	return __mem_bump_alloc(ci, 1, 1);
  4123d1:	e8 da a3 ff ff       	call   40c7b0 <__mem_bump_alloc.constprop.0>
  4123d6:	49 89 c5             	mov    r13,rax
	if (!*kmem) return -1;
  4123d9:	48 85 c0             	test   rax,rax
  4123dc:	0f 84 56 01 00 00    	je     412538 <cos_tcap_alloc+0x188>
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  4123e2:	0f 01 f9             	rdtscp 
	return (long)coreid;
  4123e5:	49 89 cf             	mov    r15,rcx
{ while (!ps_cas(&l->o, 0, 1)) ; }
  4123e8:	49 8d 94 24 58 01 00 	lea    rdx,[r12+0x158]
  4123ef:	00 
        __asm__ __volatile__("lock " PS_CAS_STR
  4123f0:	bf 01 00 00 00       	mov    edi,0x1
  4123f5:	31 c9                	xor    ecx,ecx
  4123f7:	41 81 e7 ff 0f 00 00 	and    r15d,0xfff
		frontier = &ci->cap16_frontier[cos_cpuid()];
  4123fe:	4b 8d 5c fc 28       	lea    rbx,[r12+r15*8+0x28]
{ while (!ps_cas(&l->o, 0, 1)) ; }
  412403:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        __asm__ __volatile__("lock " PS_CAS_STR
  412408:	48 89 c8             	mov    rax,rcx
  41240b:	f0 48 0f b1 3a       	lock cmpxchg QWORD PTR [rdx],rdi
  412410:	0f 94 c0             	sete   al
{ while (!ps_cas(&l->o, 0, 1)) ; }
  412413:	84 c0                	test   al,al
  412415:	74 f1                	je     412408 <cos_tcap_alloc+0x58>
	if (*capsz_frontier % CAPMAX_ENTRY_SZ == 0) {
  412417:	49 83 c7 04          	add    r15,0x4
  41241b:	4f 8b 74 fc 08       	mov    r14,QWORD PTR [r12+r15*8+0x8]
  412420:	41 83 e6 03          	and    r14d,0x3
  412424:	0f 84 9e 00 00 00    	je     4124c8 <cos_tcap_alloc+0x118>
        __asm__ __volatile__("lock " PS_FAA_STR
  41242a:	ba 01 00 00 00       	mov    edx,0x1
  41242f:	f0 48 0f c1 13       	lock xadd QWORD PTR [rbx],rdx
{ l->o = 0; }
  412434:	49 c7 84 24 58 01 00 	mov    QWORD PTR [r12+0x158],0x0
  41243b:	00 00 00 00 00 
	ret = ps_faa(capsz_frontier, sz);
  412440:	49 89 d6             	mov    r14,rdx
	if (!*cap) return -1;
  412443:	48 85 d2             	test   rdx,rdx
  412446:	0f 84 ec 00 00 00    	je     412538 <cos_tcap_alloc+0x188>

	if (__alloc_mem_cap(ci, CAP_TCAP, &kmem, &cap)) return 0;
	/* TODO: Add cap size checking */
	if (call_cap_op(ci->captbl_cap, CAPTBL_OP_TCAP_ACTIVATE, (cap << 16) | __compinfo_metacap(ci)->mi.pgtbl_cap,
  41244c:	49 8b 8c 24 08 01 00 	mov    rcx,QWORD PTR [r12+0x108]
  412453:	00 
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  412454:	41 8b 44 24 08       	mov    eax,DWORD PTR [r12+0x8]
  412459:	48 c1 e2 10          	shl    rdx,0x10
	__asm__ __volatile__(
  41245d:	4c 89 ee             	mov    rsi,r13
  412460:	48 8b 99 40 01 00 00 	mov    rbx,QWORD PTR [rcx+0x140]
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  412467:	c1 e0 10             	shl    eax,0x10
	__asm__ __volatile__(
  41246a:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
	cap_no += op;
  41246e:	05 26 00 01 00       	add    eax,0x10026
  412473:	48 09 d3             	or     rbx,rdx
	__asm__ __volatile__(
  412476:	31 d2                	xor    edx,edx
  412478:	48 89 d7             	mov    rdi,rdx
  41247b:	48 89 29             	mov    QWORD PTR [rcx],rbp
  41247e:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  412482:	48 89 cd             	mov    rbp,rcx
  412485:	49 b8 a0 24 41 00 00 	movabs r8,0x4124a0
  41248c:	00 00 00 
  41248f:	0f 05                	syscall 
  412491:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  412498:	eb 0d                	jmp    4124a7 <cos_tcap_alloc+0xf7>
  41249a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4124a0:	b9 00 00 00 00       	mov    ecx,0x0
  4124a5:	eb 05                	jmp    4124ac <cos_tcap_alloc+0xfc>
  4124a7:	b9 01 00 00 00       	mov    ecx,0x1
  4124ac:	5d                   	pop    rbp
  4124ad:	5c                   	pop    rsp
  4124ae:	85 c0                	test   eax,eax
  4124b0:	75 4e                	jne    412500 <cos_tcap_alloc+0x150>
	                kmem, 0, 0))
		BUG();

	return cap;
}
  4124b2:	48 83 c4 18          	add    rsp,0x18
  4124b6:	4c 89 f0             	mov    rax,r14
  4124b9:	5b                   	pop    rbx
  4124ba:	41 5c                	pop    r12
  4124bc:	41 5d                	pop    r13
  4124be:	41 5e                	pop    r14
  4124c0:	41 5f                	pop    r15
  4124c2:	5d                   	pop    rbp
  4124c3:	c3                   	ret    
  4124c4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		if (__capid_captbl_check_expand(ci)) goto error;
  4124c8:	4c 89 e7             	mov    rdi,r12
  4124cb:	e8 70 a4 ff ff       	call   40c940 <__capid_captbl_check_expand>
  4124d0:	85 c0                	test   eax,eax
  4124d2:	75 16                	jne    4124ea <cos_tcap_alloc+0x13a>
        __asm__ __volatile__("lock " PS_FAA_STR
  4124d4:	b8 04 00 00 00       	mov    eax,0x4
  4124d9:	f0 49 0f c1 44 24 18 	lock xadd QWORD PTR [r12+0x18],rax
		*capsz_frontier = ps_faa(&ci->cap_frontier, CAPMAX_ENTRY_SZ);
  4124e0:	4b 89 44 fc 08       	mov    QWORD PTR [r12+r15*8+0x8],rax
  4124e5:	e9 40 ff ff ff       	jmp    41242a <cos_tcap_alloc+0x7a>
{ l->o = 0; }
  4124ea:	49 c7 84 24 58 01 00 	mov    QWORD PTR [r12+0x158],0x0
  4124f1:	00 00 00 00 00 
	if (!*cap) return -1;
  4124f6:	eb ba                	jmp    4124b2 <cos_tcap_alloc+0x102>
  4124f8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4124ff:	00 
  412500:	be 1c 00 00 00       	mov    esi,0x1c
  412505:	bf 48 f3 41 00       	mov    edi,0x41f348
  41250a:	e8 71 87 ff ff       	call   40ac80 <cos_print_str>
		BUG();
  41250f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412516:	00 00 00 00 
  41251a:	0f 0b                	ud2    
  41251c:	be 2f 00 00 00       	mov    esi,0x2f
  412521:	bf 18 f3 41 00       	mov    edi,0x41f318
  412526:	e8 55 87 ff ff       	call   40ac80 <cos_print_str>
	assert(ci);
  41252b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412532:	00 00 00 00 
  412536:	0f 0b                	ud2    
	if (__alloc_mem_cap(ci, CAP_TCAP, &kmem, &cap)) return 0;
  412538:	45 31 f6             	xor    r14d,r14d
  41253b:	e9 72 ff ff ff       	jmp    4124b2 <cos_tcap_alloc+0x102>

0000000000412540 <cos_tcap_transfer>:

int
cos_tcap_transfer(arcvcap_t dst, tcap_t src, tcap_res_t res, tcap_prio_t prio)
{
  412540:	f3 0f 1e fa          	endbr64 
  412544:	55                   	push   rbp
  412545:	49 89 fa             	mov    r10,rdi
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  412548:	c1 e6 10             	shl    esi,0x10
	int prio_higher = (u32_t)(prio >> 32);
	int prio_lower  = (u32_t)((prio << 32) >> 32);

	return call_cap_op(src, CAPTBL_OP_TCAP_TRANSFER, dst, res, prio_higher, prio_lower);
  41254b:	48 89 cf             	mov    rdi,rcx
	cap_no += op;
  41254e:	8d 86 27 00 01 00    	lea    eax,[rsi+0x10027]
  412554:	48 c1 ff 20          	sar    rdi,0x20
{
  412558:	48 89 e5             	mov    rbp,rsp
  41255b:	41 55                	push   r13
  41255d:	49 89 d5             	mov    r13,rdx
	return call_cap_op(src, CAPTBL_OP_TCAP_TRANSFER, dst, res, prio_higher, prio_lower);
  412560:	48 63 d1             	movsxd rdx,ecx
{
  412563:	41 54                	push   r12
	__asm__ __volatile__(
  412565:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  412569:	4c 89 ee             	mov    rsi,r13
  41256c:	53                   	push   rbx
  41256d:	4c 89 d3             	mov    rbx,r10
  412570:	48 89 29             	mov    QWORD PTR [rcx],rbp
  412573:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  412577:	48 89 cd             	mov    rbp,rcx
  41257a:	49 b8 90 25 41 00 00 	movabs r8,0x412590
  412581:	00 00 00 
  412584:	0f 05                	syscall 
  412586:	66 90                	xchg   ax,ax
  412588:	eb 0d                	jmp    412597 <cos_tcap_transfer+0x57>
  41258a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  412590:	b9 00 00 00 00       	mov    ecx,0x0
  412595:	eb 05                	jmp    41259c <cos_tcap_transfer+0x5c>
  412597:	b9 01 00 00 00       	mov    ecx,0x1
  41259c:	5d                   	pop    rbp
  41259d:	5c                   	pop    rsp
}
  41259e:	5b                   	pop    rbx
  41259f:	41 5c                	pop    r12
  4125a1:	41 5d                	pop    r13
  4125a3:	5d                   	pop    rbp
  4125a4:	c3                   	ret    
  4125a5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4125ac:	00 00 00 00 

00000000004125b0 <cos_tcap_delegate>:

int
cos_tcap_delegate(asndcap_t dst, tcap_t src, tcap_res_t res, tcap_prio_t prio, tcap_deleg_flags_t flags)
{
  4125b0:	f3 0f 1e fa          	endbr64 
  4125b4:	55                   	push   rbp
  4125b5:	49 89 fa             	mov    r10,rdi
	u32_t yield = ((flags & TCAP_DELEG_YIELD) != 0);
  4125b8:	44 89 c7             	mov    edi,r8d
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4125bb:	c1 e6 10             	shl    esi,0x10
  4125be:	d1 ef                	shr    edi,1
	cap_no += op;
  4125c0:	8d 86 28 00 01 00    	lea    eax,[rsi+0x10028]
	/* top bit is if we are dispatching or not */
	int prio_higher = (u32_t)(prio >> 32) | (yield << ((sizeof(yield) * 8) - 1));
  4125c6:	c1 e7 1f             	shl    edi,0x1f
{
  4125c9:	48 89 e5             	mov    rbp,rsp
  4125cc:	41 55                	push   r13
  4125ce:	49 89 d5             	mov    r13,rdx
	int prio_higher = (u32_t)(prio >> 32) | (yield << ((sizeof(yield) * 8) - 1));
  4125d1:	48 89 ca             	mov    rdx,rcx
{
  4125d4:	41 54                	push   r12
	int prio_higher = (u32_t)(prio >> 32) | (yield << ((sizeof(yield) * 8) - 1));
  4125d6:	48 c1 ea 20          	shr    rdx,0x20
	__asm__ __volatile__(
  4125da:	4c 89 ee             	mov    rsi,r13
{
  4125dd:	53                   	push   rbx
	int prio_higher = (u32_t)(prio >> 32) | (yield << ((sizeof(yield) * 8) - 1));
  4125de:	09 d7                	or     edi,edx
  4125e0:	4c 89 d3             	mov    rbx,r10
	int prio_lower  = (u32_t)((prio << 32) >> 32);

	return call_cap_op(src, CAPTBL_OP_TCAP_DELEGATE, dst, res, prio_higher, prio_lower);
  4125e3:	48 63 d1             	movsxd rdx,ecx
  4125e6:	48 63 ff             	movsxd rdi,edi
  4125e9:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  4125ed:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4125f0:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4125f4:	48 89 cd             	mov    rbp,rcx
  4125f7:	49 b8 10 26 41 00 00 	movabs r8,0x412610
  4125fe:	00 00 00 
  412601:	0f 05                	syscall 
  412603:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  412608:	eb 0d                	jmp    412617 <cos_tcap_delegate+0x67>
  41260a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  412610:	b9 00 00 00 00       	mov    ecx,0x0
  412615:	eb 05                	jmp    41261c <cos_tcap_delegate+0x6c>
  412617:	b9 01 00 00 00       	mov    ecx,0x1
  41261c:	5d                   	pop    rbp
  41261d:	5c                   	pop    rsp
}
  41261e:	5b                   	pop    rbx
  41261f:	41 5c                	pop    r12
  412621:	41 5d                	pop    r13
  412623:	5d                   	pop    rbp
  412624:	c3                   	ret    
  412625:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41262c:	00 00 00 00 

0000000000412630 <cos_tcap_merge>:

int
cos_tcap_merge(tcap_t dst, tcap_t rm)
{
  412630:	f3 0f 1e fa          	endbr64 
  412634:	55                   	push   rbp
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  412635:	c1 e7 10             	shl    edi,0x10
	__asm__ __volatile__(
  412638:	31 d2                	xor    edx,edx
	cap_no += op;
  41263a:	8d 87 29 00 01 00    	lea    eax,[rdi+0x10029]
	__asm__ __volatile__(
  412640:	48 89 d7             	mov    rdi,rdx
  412643:	48 89 e5             	mov    rbp,rsp
  412646:	41 54                	push   r12
  412648:	53                   	push   rbx
  412649:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  41264d:	48 89 f3             	mov    rbx,rsi
  412650:	48 89 d6             	mov    rsi,rdx
  412653:	48 89 29             	mov    QWORD PTR [rcx],rbp
  412656:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  41265a:	48 89 cd             	mov    rbp,rcx
  41265d:	49 b8 78 26 41 00 00 	movabs r8,0x412678
  412664:	00 00 00 
  412667:	0f 05                	syscall 
  412669:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  412670:	eb 0d                	jmp    41267f <cos_tcap_merge+0x4f>
  412672:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  412678:	b9 00 00 00 00       	mov    ecx,0x0
  41267d:	eb 05                	jmp    412684 <cos_tcap_merge+0x54>
  41267f:	b9 01 00 00 00       	mov    ecx,0x1
  412684:	5d                   	pop    rbp
  412685:	5c                   	pop    rsp
	return call_cap_op(dst, CAPTBL_OP_TCAP_MERGE, rm, 0, 0, 0);
}
  412686:	5b                   	pop    rbx
  412687:	41 5c                	pop    r12
  412689:	5d                   	pop    rbp
  41268a:	c3                   	ret    
  41268b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000412690 <cos_hw_attach>:

int
cos_hw_attach(hwcap_t hwc, hwid_t hwid, arcvcap_t arcv)
{
  412690:	f3 0f 1e fa          	endbr64 
  412694:	55                   	push   rbp
  412695:	49 89 d2             	mov    r10,rdx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  412698:	c1 e7 10             	shl    edi,0x10
	__asm__ __volatile__(
  41269b:	31 d2                	xor    edx,edx
	cap_no += op;
  41269d:	8d 87 2d 00 01 00    	lea    eax,[rdi+0x1002d]
	__asm__ __volatile__(
  4126a3:	48 89 d7             	mov    rdi,rdx
  4126a6:	48 89 e5             	mov    rbp,rsp
  4126a9:	41 54                	push   r12
  4126ab:	53                   	push   rbx
  4126ac:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
	return call_cap_op(hwc, CAPTBL_OP_HW_ATTACH, hwid, arcv, 0, 0);
  4126b0:	89 f3                	mov    ebx,esi
  4126b2:	4c 89 d6             	mov    rsi,r10
  4126b5:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4126b8:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4126bc:	48 89 cd             	mov    rbp,rcx
  4126bf:	49 b8 d8 26 41 00 00 	movabs r8,0x4126d8
  4126c6:	00 00 00 
  4126c9:	0f 05                	syscall 
  4126cb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  4126d0:	eb 0d                	jmp    4126df <cos_hw_attach+0x4f>
  4126d2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4126d8:	b9 00 00 00 00       	mov    ecx,0x0
  4126dd:	eb 05                	jmp    4126e4 <cos_hw_attach+0x54>
  4126df:	b9 01 00 00 00       	mov    ecx,0x1
  4126e4:	5d                   	pop    rbp
  4126e5:	5c                   	pop    rsp
}
  4126e6:	5b                   	pop    rbx
  4126e7:	41 5c                	pop    r12
  4126e9:	5d                   	pop    rbp
  4126ea:	c3                   	ret    
  4126eb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000004126f0 <cos_hw_detach>:

int
cos_hw_detach(hwcap_t hwc, hwid_t hwid)
{
  4126f0:	f3 0f 1e fa          	endbr64 
  4126f4:	55                   	push   rbp
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4126f5:	c1 e7 10             	shl    edi,0x10
	__asm__ __volatile__(
  4126f8:	31 d2                	xor    edx,edx
	cap_no += op;
  4126fa:	8d 87 2e 00 01 00    	lea    eax,[rdi+0x1002e]
	__asm__ __volatile__(
  412700:	48 89 d7             	mov    rdi,rdx
  412703:	48 89 e5             	mov    rbp,rsp
  412706:	41 54                	push   r12
  412708:	53                   	push   rbx
  412709:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
	return call_cap_op(hwc, CAPTBL_OP_HW_DETACH, hwid, 0, 0, 0);
  41270d:	89 f3                	mov    ebx,esi
  41270f:	48 89 d6             	mov    rsi,rdx
  412712:	48 89 29             	mov    QWORD PTR [rcx],rbp
  412715:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  412719:	48 89 cd             	mov    rbp,rcx
  41271c:	49 b8 30 27 41 00 00 	movabs r8,0x412730
  412723:	00 00 00 
  412726:	0f 05                	syscall 
  412728:	eb 0d                	jmp    412737 <cos_hw_detach+0x47>
  41272a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  412730:	b9 00 00 00 00       	mov    ecx,0x0
  412735:	eb 05                	jmp    41273c <cos_hw_detach+0x4c>
  412737:	b9 01 00 00 00       	mov    ecx,0x1
  41273c:	5d                   	pop    rbp
  41273d:	5c                   	pop    rsp
}
  41273e:	5b                   	pop    rbx
  41273f:	41 5c                	pop    r12
  412741:	5d                   	pop    rbp
  412742:	c3                   	ret    
  412743:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41274a:	00 00 00 00 
  41274e:	66 90                	xchg   ax,ax

0000000000412750 <cos_hw_cycles_per_usec>:

int
cos_hw_cycles_per_usec(hwcap_t hwc)
{
  412750:	f3 0f 1e fa          	endbr64 
	static int cycs = 0;

	while (cycs <= 0) cycs = call_cap_op(hwc, CAPTBL_OP_HW_CYC_USEC, 0, 0, 0, 0);
  412754:	8b 05 46 73 2f 00    	mov    eax,DWORD PTR [rip+0x2f7346]        # 709aa0 <cycs.0>
  41275a:	85 c0                	test   eax,eax
  41275c:	7f 72                	jg     4127d0 <cos_hw_cycles_per_usec+0x80>
{
  41275e:	55                   	push   rbp
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  41275f:	c1 e7 10             	shl    edi,0x10
	__asm__ __volatile__(
  412762:	31 d2                	xor    edx,edx
  412764:	48 89 e5             	mov    rbp,rsp
  412767:	41 55                	push   r13
	cap_no += op;
  412769:	44 8d af 30 00 01 00 	lea    r13d,[rdi+0x10030]
  412770:	41 54                	push   r12
  412772:	4c 8d 55 d0          	lea    r10,[rbp-0x30]
  412776:	53                   	push   rbx
  412777:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41277e:	00 00 
	__asm__ __volatile__(
  412780:	44 89 e8             	mov    eax,r13d
  412783:	48 89 d3             	mov    rbx,rdx
  412786:	48 89 d6             	mov    rsi,rdx
  412789:	48 89 d7             	mov    rdi,rdx
  41278c:	4c 89 d1             	mov    rcx,r10
  41278f:	48 89 29             	mov    QWORD PTR [rcx],rbp
  412792:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  412796:	48 89 cd             	mov    rbp,rcx
  412799:	49 b8 b0 27 41 00 00 	movabs r8,0x4127b0
  4127a0:	00 00 00 
  4127a3:	0f 05                	syscall 
  4127a5:	0f 1f 00             	nop    DWORD PTR [rax]
  4127a8:	eb 0d                	jmp    4127b7 <cos_hw_cycles_per_usec+0x67>
  4127aa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4127b0:	b9 00 00 00 00       	mov    ecx,0x0
  4127b5:	eb 05                	jmp    4127bc <cos_hw_cycles_per_usec+0x6c>
  4127b7:	b9 01 00 00 00       	mov    ecx,0x1
  4127bc:	5d                   	pop    rbp
  4127bd:	5c                   	pop    rsp
	while (cycs <= 0) cycs = call_cap_op(hwc, CAPTBL_OP_HW_CYC_USEC, 0, 0, 0, 0);
  4127be:	89 05 dc 72 2f 00    	mov    DWORD PTR [rip+0x2f72dc],eax        # 709aa0 <cycs.0>
  4127c4:	85 c0                	test   eax,eax
  4127c6:	7e b8                	jle    412780 <cos_hw_cycles_per_usec+0x30>

	return cycs;
}
  4127c8:	5b                   	pop    rbx
  4127c9:	41 5c                	pop    r12
  4127cb:	41 5d                	pop    r13
  4127cd:	5d                   	pop    rbp
  4127ce:	c3                   	ret    
  4127cf:	90                   	nop
  4127d0:	c3                   	ret    
  4127d1:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4127d8:	00 00 00 00 
  4127dc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

00000000004127e0 <cos_hw_tlb_lockdown>:

int
cos_hw_tlb_lockdown(hwcap_t hwc, unsigned long entryid, unsigned long vaddr, unsigned long paddr)
{
  4127e0:	f3 0f 1e fa          	endbr64 
  4127e4:	55                   	push   rbp
  4127e5:	49 89 f2             	mov    r10,rsi
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4127e8:	c1 e7 10             	shl    edi,0x10
  4127eb:	48 89 d6             	mov    rsi,rdx
	cap_no += op;
  4127ee:	8d 87 33 00 01 00    	lea    eax,[rdi+0x10033]
	__asm__ __volatile__(
  4127f4:	31 d2                	xor    edx,edx
  4127f6:	48 89 e5             	mov    rbp,rsp
  4127f9:	41 55                	push   r13
  4127fb:	49 89 cd             	mov    r13,rcx
  4127fe:	41 54                	push   r12
  412800:	48 8d 4d d0          	lea    rcx,[rbp-0x30]
  412804:	4c 89 ef             	mov    rdi,r13
  412807:	53                   	push   rbx
  412808:	4c 89 d3             	mov    rbx,r10
  41280b:	48 89 29             	mov    QWORD PTR [rcx],rbp
  41280e:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  412812:	48 89 cd             	mov    rbp,rcx
  412815:	49 b8 30 28 41 00 00 	movabs r8,0x412830
  41281c:	00 00 00 
  41281f:	0f 05                	syscall 
  412821:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  412828:	eb 0d                	jmp    412837 <cos_hw_tlb_lockdown+0x57>
  41282a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  412830:	b9 00 00 00 00       	mov    ecx,0x0
  412835:	eb 05                	jmp    41283c <cos_hw_tlb_lockdown+0x5c>
  412837:	b9 01 00 00 00       	mov    ecx,0x1
  41283c:	5d                   	pop    rbp
  41283d:	5c                   	pop    rsp
	return call_cap_op(hwc, CAPTBL_OP_HW_TLB_LOCKDOWN, entryid, vaddr, paddr, 0);
}
  41283e:	5b                   	pop    rbx
  41283f:	41 5c                	pop    r12
  412841:	41 5d                	pop    r13
  412843:	5d                   	pop    rbp
  412844:	c3                   	ret    
  412845:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41284c:	00 00 00 00 

0000000000412850 <cos_hw_l1flush>:

int
cos_hw_l1flush(hwcap_t hwc)
{
  412850:	f3 0f 1e fa          	endbr64 
  412854:	55                   	push   rbp
  412855:	31 d2                	xor    edx,edx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  412857:	c1 e7 10             	shl    edi,0x10
	cap_no += op;
  41285a:	8d 87 34 00 01 00    	lea    eax,[rdi+0x10034]
	__asm__ __volatile__(
  412860:	48 89 d6             	mov    rsi,rdx
  412863:	48 89 d7             	mov    rdi,rdx
  412866:	48 89 e5             	mov    rbp,rsp
  412869:	41 54                	push   r12
  41286b:	53                   	push   rbx
  41286c:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  412870:	48 89 d3             	mov    rbx,rdx
  412873:	48 89 29             	mov    QWORD PTR [rcx],rbp
  412876:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  41287a:	48 89 cd             	mov    rbp,rcx
  41287d:	49 b8 98 28 41 00 00 	movabs r8,0x412898
  412884:	00 00 00 
  412887:	0f 05                	syscall 
  412889:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  412890:	eb 0d                	jmp    41289f <cos_hw_l1flush+0x4f>
  412892:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  412898:	b9 00 00 00 00       	mov    ecx,0x0
  41289d:	eb 05                	jmp    4128a4 <cos_hw_l1flush+0x54>
  41289f:	b9 01 00 00 00       	mov    ecx,0x1
  4128a4:	5d                   	pop    rbp
  4128a5:	5c                   	pop    rsp
	return call_cap_op(hwc, CAPTBL_OP_HW_L1FLUSH, 0, 0, 0, 0);
}
  4128a6:	5b                   	pop    rbx
  4128a7:	41 5c                	pop    r12
  4128a9:	5d                   	pop    rbp
  4128aa:	c3                   	ret    
  4128ab:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000004128b0 <cos_hw_tlbflush>:

int
cos_hw_tlbflush(hwcap_t hwc)
{
  4128b0:	f3 0f 1e fa          	endbr64 
  4128b4:	55                   	push   rbp
  4128b5:	31 d2                	xor    edx,edx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4128b7:	c1 e7 10             	shl    edi,0x10
	cap_no += op;
  4128ba:	8d 87 35 00 01 00    	lea    eax,[rdi+0x10035]
	__asm__ __volatile__(
  4128c0:	48 89 d6             	mov    rsi,rdx
  4128c3:	48 89 d7             	mov    rdi,rdx
  4128c6:	48 89 e5             	mov    rbp,rsp
  4128c9:	41 54                	push   r12
  4128cb:	53                   	push   rbx
  4128cc:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  4128d0:	48 89 d3             	mov    rbx,rdx
  4128d3:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4128d6:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4128da:	48 89 cd             	mov    rbp,rcx
  4128dd:	49 b8 f8 28 41 00 00 	movabs r8,0x4128f8
  4128e4:	00 00 00 
  4128e7:	0f 05                	syscall 
  4128e9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  4128f0:	eb 0d                	jmp    4128ff <cos_hw_tlbflush+0x4f>
  4128f2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4128f8:	b9 00 00 00 00       	mov    ecx,0x0
  4128fd:	eb 05                	jmp    412904 <cos_hw_tlbflush+0x54>
  4128ff:	b9 01 00 00 00       	mov    ecx,0x1
  412904:	5d                   	pop    rbp
  412905:	5c                   	pop    rsp
	return call_cap_op(hwc, CAPTBL_OP_HW_TLBFLUSH, 0, 0, 0, 0);
}
  412906:	5b                   	pop    rbx
  412907:	41 5c                	pop    r12
  412909:	5d                   	pop    rbp
  41290a:	c3                   	ret    
  41290b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000412910 <cos_hw_tlbstall>:

int
cos_hw_tlbstall(hwcap_t hwc)
{
  412910:	f3 0f 1e fa          	endbr64 
  412914:	55                   	push   rbp
  412915:	31 d2                	xor    edx,edx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  412917:	c1 e7 10             	shl    edi,0x10
	cap_no += op;
  41291a:	8d 87 36 00 01 00    	lea    eax,[rdi+0x10036]
	__asm__ __volatile__(
  412920:	48 89 d6             	mov    rsi,rdx
  412923:	48 89 d7             	mov    rdi,rdx
  412926:	48 89 e5             	mov    rbp,rsp
  412929:	41 54                	push   r12
  41292b:	53                   	push   rbx
  41292c:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  412930:	48 89 d3             	mov    rbx,rdx
  412933:	48 89 29             	mov    QWORD PTR [rcx],rbp
  412936:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  41293a:	48 89 cd             	mov    rbp,rcx
  41293d:	49 b8 58 29 41 00 00 	movabs r8,0x412958
  412944:	00 00 00 
  412947:	0f 05                	syscall 
  412949:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  412950:	eb 0d                	jmp    41295f <cos_hw_tlbstall+0x4f>
  412952:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  412958:	b9 00 00 00 00       	mov    ecx,0x0
  41295d:	eb 05                	jmp    412964 <cos_hw_tlbstall+0x54>
  41295f:	b9 01 00 00 00       	mov    ecx,0x1
  412964:	5d                   	pop    rbp
  412965:	5c                   	pop    rsp
	return call_cap_op(hwc, CAPTBL_OP_HW_TLBSTALL, 0, 0, 0, 0);
}
  412966:	5b                   	pop    rbx
  412967:	41 5c                	pop    r12
  412969:	5d                   	pop    rbp
  41296a:	c3                   	ret    
  41296b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000412970 <cos_hw_tlbstall_recount>:

int
cos_hw_tlbstall_recount(hwcap_t hwc)
{
  412970:	f3 0f 1e fa          	endbr64 
  412974:	55                   	push   rbp
  412975:	31 d2                	xor    edx,edx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  412977:	c1 e7 10             	shl    edi,0x10
	cap_no += op;
  41297a:	8d 87 37 00 01 00    	lea    eax,[rdi+0x10037]
	__asm__ __volatile__(
  412980:	48 89 d6             	mov    rsi,rdx
  412983:	48 89 d7             	mov    rdi,rdx
  412986:	48 89 e5             	mov    rbp,rsp
  412989:	41 54                	push   r12
  41298b:	53                   	push   rbx
  41298c:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  412990:	48 89 d3             	mov    rbx,rdx
  412993:	48 89 29             	mov    QWORD PTR [rcx],rbp
  412996:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  41299a:	48 89 cd             	mov    rbp,rcx
  41299d:	49 b8 b8 29 41 00 00 	movabs r8,0x4129b8
  4129a4:	00 00 00 
  4129a7:	0f 05                	syscall 
  4129a9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  4129b0:	eb 0d                	jmp    4129bf <cos_hw_tlbstall_recount+0x4f>
  4129b2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4129b8:	b9 00 00 00 00       	mov    ecx,0x0
  4129bd:	eb 05                	jmp    4129c4 <cos_hw_tlbstall_recount+0x54>
  4129bf:	b9 01 00 00 00       	mov    ecx,0x1
  4129c4:	5d                   	pop    rbp
  4129c5:	5c                   	pop    rsp
	return call_cap_op(hwc, CAPTBL_OP_HW_TLBSTALL_RECOUNT, 0, 0, 0, 0);
}
  4129c6:	5b                   	pop    rbx
  4129c7:	41 5c                	pop    r12
  4129c9:	5d                   	pop    rbp
  4129ca:	c3                   	ret    
  4129cb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000004129d0 <cos_hw_cycles_thresh>:

int
cos_hw_cycles_thresh(hwcap_t hwc)
{
  4129d0:	f3 0f 1e fa          	endbr64 
  4129d4:	55                   	push   rbp
  4129d5:	31 d2                	xor    edx,edx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  4129d7:	c1 e7 10             	shl    edi,0x10
	cap_no += op;
  4129da:	8d 87 31 00 01 00    	lea    eax,[rdi+0x10031]
	__asm__ __volatile__(
  4129e0:	48 89 d6             	mov    rsi,rdx
  4129e3:	48 89 d7             	mov    rdi,rdx
  4129e6:	48 89 e5             	mov    rbp,rsp
  4129e9:	41 54                	push   r12
  4129eb:	53                   	push   rbx
  4129ec:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  4129f0:	48 89 d3             	mov    rbx,rdx
  4129f3:	48 89 29             	mov    QWORD PTR [rcx],rbp
  4129f6:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  4129fa:	48 89 cd             	mov    rbp,rcx
  4129fd:	49 b8 18 2a 41 00 00 	movabs r8,0x412a18
  412a04:	00 00 00 
  412a07:	0f 05                	syscall 
  412a09:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  412a10:	eb 0d                	jmp    412a1f <cos_hw_cycles_thresh+0x4f>
  412a12:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  412a18:	b9 00 00 00 00       	mov    ecx,0x0
  412a1d:	eb 05                	jmp    412a24 <cos_hw_cycles_thresh+0x54>
  412a1f:	b9 01 00 00 00       	mov    ecx,0x1
  412a24:	5d                   	pop    rbp
  412a25:	5c                   	pop    rsp
	return call_cap_op(hwc, CAPTBL_OP_HW_CYC_THRESH, 0, 0, 0, 0);
}
  412a26:	5b                   	pop    rbx
  412a27:	41 5c                	pop    r12
  412a29:	5d                   	pop    rbp
  412a2a:	c3                   	ret    
  412a2b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000412a30 <cos_hw_shutdown>:

void
cos_hw_shutdown(hwcap_t hwc)
{
  412a30:	f3 0f 1e fa          	endbr64 
  412a34:	55                   	push   rbp
  412a35:	31 d2                	xor    edx,edx
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  412a37:	c1 e7 10             	shl    edi,0x10
	cap_no += op;
  412a3a:	8d 87 32 00 01 00    	lea    eax,[rdi+0x10032]
	__asm__ __volatile__(
  412a40:	48 89 d6             	mov    rsi,rdx
  412a43:	48 89 d7             	mov    rdi,rdx
  412a46:	48 89 e5             	mov    rbp,rsp
  412a49:	41 54                	push   r12
  412a4b:	53                   	push   rbx
  412a4c:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  412a50:	48 89 d3             	mov    rbx,rdx
  412a53:	48 89 29             	mov    QWORD PTR [rcx],rbp
  412a56:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  412a5a:	48 89 cd             	mov    rbp,rcx
  412a5d:	49 b8 78 2a 41 00 00 	movabs r8,0x412a78
  412a64:	00 00 00 
  412a67:	0f 05                	syscall 
  412a69:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  412a70:	eb 0d                	jmp    412a7f <cos_hw_shutdown+0x4f>
  412a72:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  412a78:	b9 00 00 00 00       	mov    ecx,0x0
  412a7d:	eb 05                	jmp    412a84 <cos_hw_shutdown+0x54>
  412a7f:	b9 01 00 00 00       	mov    ecx,0x1
  412a84:	5d                   	pop    rbp
  412a85:	5c                   	pop    rsp
	call_cap_op(hwc, CAPTBL_OP_HW_SHUTDOWN, 0, 0, 0, 0);
}
  412a86:	5b                   	pop    rbx
  412a87:	41 5c                	pop    r12
  412a89:	5d                   	pop    rbp
  412a8a:	c3                   	ret    
  412a8b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000412a90 <cos_hw_map>:

void *
cos_hw_map(struct cos_compinfo *ci, hwcap_t hwc, paddr_t pa, unsigned int len)
{
  412a90:	f3 0f 1e fa          	endbr64 
  412a94:	55                   	push   rbp
  412a95:	48 89 e5             	mov    rbp,rsp
  412a98:	41 57                	push   r15
  412a9a:	41 56                	push   r14
  412a9c:	41 55                	push   r13
  412a9e:	41 54                	push   r12
  412aa0:	53                   	push   rbx
  412aa1:	48 83 ec 28          	sub    rsp,0x28
	size_t  sz, i;
	vaddr_t va;

	assert(ci && hwc && pa && len);
  412aa5:	48 85 ff             	test   rdi,rdi
  412aa8:	0f 84 f4 00 00 00    	je     412ba2 <cos_hw_map+0x112>
  412aae:	48 89 f3             	mov    rbx,rsi
  412ab1:	48 85 f6             	test   rsi,rsi
  412ab4:	0f 84 e8 00 00 00    	je     412ba2 <cos_hw_map+0x112>
  412aba:	49 89 d7             	mov    r15,rdx
  412abd:	48 85 d2             	test   rdx,rdx
  412ac0:	0f 84 dc 00 00 00    	je     412ba2 <cos_hw_map+0x112>
  412ac6:	85 c9                	test   ecx,ecx
  412ac8:	0f 84 d4 00 00 00    	je     412ba2 <cos_hw_map+0x112>

	sz = round_up_to_page(len);
  412ace:	89 c9                	mov    ecx,ecx
	va = __page_bump_valloc(ci, sz, PAGE_SIZE);
  412ad0:	ba 00 10 00 00       	mov    edx,0x1000
  412ad5:	49 89 fe             	mov    r14,rdi
	sz = round_up_to_page(len);
  412ad8:	48 81 c1 ff 0f 00 00 	add    rcx,0xfff
  412adf:	48 81 e1 00 f0 ff ff 	and    rcx,0xfffffffffffff000
  412ae6:	48 89 ce             	mov    rsi,rcx
  412ae9:	48 89 4d b8          	mov    QWORD PTR [rbp-0x48],rcx
	va = __page_bump_valloc(ci, sz, PAGE_SIZE);
  412aed:	e8 de a3 ff ff       	call   40ced0 <__page_bump_valloc>
  412af2:	49 89 c5             	mov    r13,rax
	if (unlikely(!va)) return NULL;
  412af5:	48 85 c0             	test   rax,rax
  412af8:	0f 84 c0 00 00 00    	je     412bbe <cos_hw_map+0x12e>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  412afe:	c1 e3 10             	shl    ebx,0x10

	for (i = 0; i < sz; i += PAGE_SIZE) {
  412b01:	45 31 d2             	xor    r10d,r10d
	__asm__ __volatile__(
  412b04:	31 d2                	xor    edx,edx
	cap_no += op;
  412b06:	8d 83 2f 00 01 00    	lea    eax,[rbx+0x1002f]
  412b0c:	89 45 b4             	mov    DWORD PTR [rbp-0x4c],eax
  412b0f:	eb 14                	jmp    412b25 <cos_hw_map+0x95>
  412b11:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  412b18:	49 81 c2 00 10 00 00 	add    r10,0x1000
  412b1f:	4c 39 55 b8          	cmp    QWORD PTR [rbp-0x48],r10
  412b23:	76 6b                	jbe    412b90 <cos_hw_map+0x100>
	__asm__ __volatile__(
  412b25:	49 8b 1e             	mov    rbx,QWORD PTR [r14]
  412b28:	8b 45 b4             	mov    eax,DWORD PTR [rbp-0x4c]
  412b2b:	4b 8d 34 2a          	lea    rsi,[r10+r13*1]
  412b2f:	4b 8d 3c 3a          	lea    rdi,[r10+r15*1]
  412b33:	48 8d 4d c0          	lea    rcx,[rbp-0x40]
  412b37:	48 89 29             	mov    QWORD PTR [rcx],rbp
  412b3a:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  412b3e:	48 89 cd             	mov    rbp,rcx
  412b41:	49 b8 58 2b 41 00 00 	movabs r8,0x412b58
  412b48:	00 00 00 
  412b4b:	0f 05                	syscall 
  412b4d:	0f 1f 00             	nop    DWORD PTR [rax]
  412b50:	eb 0d                	jmp    412b5f <cos_hw_map+0xcf>
  412b52:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  412b58:	b9 00 00 00 00       	mov    ecx,0x0
  412b5d:	eb 05                	jmp    412b64 <cos_hw_map+0xd4>
  412b5f:	b9 01 00 00 00       	mov    ecx,0x1
  412b64:	5d                   	pop    rbp
  412b65:	5c                   	pop    rsp
		if (call_cap_op(hwc, CAPTBL_OP_HW_MAP, ci->pgtbl_cap, va + i, pa + i, 0)) BUG();
  412b66:	85 c0                	test   eax,eax
  412b68:	74 ae                	je     412b18 <cos_hw_map+0x88>
  412b6a:	be 1c 00 00 00       	mov    esi,0x1c
  412b6f:	bf 98 f3 41 00       	mov    edi,0x41f398
  412b74:	e8 07 81 ff ff       	call   40ac80 <cos_print_str>
  412b79:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412b80:	00 00 00 00 
  412b84:	0f 0b                	ud2    
  412b86:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  412b8d:	00 00 00 
	}

	return (void *)va;
  412b90:	4c 89 e8             	mov    rax,r13
}
  412b93:	48 83 c4 28          	add    rsp,0x28
  412b97:	5b                   	pop    rbx
  412b98:	41 5c                	pop    r12
  412b9a:	41 5d                	pop    r13
  412b9c:	41 5e                	pop    r14
  412b9e:	41 5f                	pop    r15
  412ba0:	5d                   	pop    rbp
  412ba1:	c3                   	ret    
  412ba2:	be 2f 00 00 00       	mov    esi,0x2f
  412ba7:	bf 68 f3 41 00       	mov    edi,0x41f368
  412bac:	e8 cf 80 ff ff       	call   40ac80 <cos_print_str>
	assert(ci && hwc && pa && len);
  412bb1:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412bb8:	00 00 00 00 
  412bbc:	0f 0b                	ud2    
	if (unlikely(!va)) return NULL;
  412bbe:	31 c0                	xor    eax,eax
  412bc0:	eb d1                	jmp    412b93 <cos_hw_map+0x103>
  412bc2:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  412bc9:	00 00 00 00 
  412bcd:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000412bd0 <cos_get_second_lvl>:


/* ----- Shared Pgtbl ------ */
int
cos_get_second_lvl(struct cos_compinfo *ci, capid_t *pgtbl_cap, vaddr_t *pgtbl_addr)
{
  412bd0:	f3 0f 1e fa          	endbr64 
	if(ci->mi.second_lvl_pgtbl_cap == 0) {
  412bd4:	48 8b 87 48 01 00 00 	mov    rax,QWORD PTR [rdi+0x148]
  412bdb:	48 85 c0             	test   rax,rax
  412bde:	74 10                	je     412bf0 <cos_get_second_lvl+0x20>
		return -1;
	}
	*pgtbl_cap = ci->mi.second_lvl_pgtbl_cap;
  412be0:	48 89 06             	mov    QWORD PTR [rsi],rax
	*pgtbl_addr = ci->mi.second_lvl_pgtbl_addr;
  412be3:	48 8b 87 50 01 00 00 	mov    rax,QWORD PTR [rdi+0x150]
  412bea:	48 89 02             	mov    QWORD PTR [rdx],rax

	return 0;
  412bed:	31 c0                	xor    eax,eax
  412bef:	c3                   	ret    
		return -1;
  412bf0:	b8 ff ff ff ff       	mov    eax,0xffffffff
}
  412bf5:	c3                   	ret    
  412bf6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  412bfd:	00 00 00 

0000000000412c00 <cos_cons_into_shared_pgtbl>:

u32_t
cos_cons_into_shared_pgtbl(struct cos_compinfo *ci, pgtblcap_t top_lvl)
{
  412c00:	f3 0f 1e fa          	endbr64 
  412c04:	55                   	push   rbp
  412c05:	48 89 e5             	mov    rbp,rsp
  412c08:	41 54                	push   r12
  412c0a:	53                   	push   rbx
  412c0b:	48 83 ec 10          	sub    rsp,0x10
	if(ci->mi.second_lvl_pgtbl_cap == 0) {
  412c0f:	48 8b 9f 48 01 00 00 	mov    rbx,QWORD PTR [rdi+0x148]
  412c16:	48 85 db             	test   rbx,rbx
  412c19:	0f 84 7d 00 00 00    	je     412c9c <cos_cons_into_shared_pgtbl+0x9c>
	cap_no = (cap_no + 1) << COS_CAPABILITY_OFFSET;
  412c1f:	c1 e6 10             	shl    esi,0x10
	__asm__ __volatile__(
  412c22:	31 d2                	xor    edx,edx
  412c24:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
	cap_no += op;
  412c28:	8d 86 01 00 01 00    	lea    eax,[rsi+0x10001]
	__asm__ __volatile__(
  412c2e:	48 8b b7 50 01 00 00 	mov    rsi,QWORD PTR [rdi+0x150]
  412c35:	48 89 d7             	mov    rdi,rdx
  412c38:	48 89 29             	mov    QWORD PTR [rcx],rbp
  412c3b:	48 89 61 08          	mov    QWORD PTR [rcx+0x8],rsp
  412c3f:	48 89 cd             	mov    rbp,rcx
  412c42:	49 b8 58 2c 41 00 00 	movabs r8,0x412c58
  412c49:	00 00 00 
  412c4c:	0f 05                	syscall 
  412c4e:	66 90                	xchg   ax,ax
  412c50:	eb 0d                	jmp    412c5f <cos_cons_into_shared_pgtbl+0x5f>
  412c52:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  412c58:	b9 00 00 00 00       	mov    ecx,0x0
  412c5d:	eb 05                	jmp    412c64 <cos_cons_into_shared_pgtbl+0x64>
  412c5f:	b9 01 00 00 00       	mov    ecx,0x1
  412c64:	5d                   	pop    rbp
  412c65:	5c                   	pop    rsp
	if (call_cap_op(top_lvl, CAPTBL_OP_CONS, pte_cap, pgtbl_addr, 0, 0)) {
		assert(0); /* race? */
		return -1;
	}

	return 0;
  412c66:	45 31 c0             	xor    r8d,r8d
	if (call_cap_op(top_lvl, CAPTBL_OP_CONS, pte_cap, pgtbl_addr, 0, 0)) {
  412c69:	85 c0                	test   eax,eax
  412c6b:	75 13                	jne    412c80 <cos_cons_into_shared_pgtbl+0x80>

}
  412c6d:	48 83 c4 10          	add    rsp,0x10
  412c71:	44 89 c0             	mov    eax,r8d
  412c74:	5b                   	pop    rbx
  412c75:	41 5c                	pop    r12
  412c77:	5d                   	pop    rbp
  412c78:	c3                   	ret    
  412c79:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  412c80:	be 2f 00 00 00       	mov    esi,0x2f
  412c85:	bf b8 f3 41 00       	mov    edi,0x41f3b8
  412c8a:	e8 f1 7f ff ff       	call   40ac80 <cos_print_str>
		assert(0); /* race? */
  412c8f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  412c96:	00 00 00 00 
  412c9a:	0f 0b                	ud2    
		return -1;
  412c9c:	41 b8 ff ff ff ff    	mov    r8d,0xffffffff
  412ca2:	eb c9                	jmp    412c6d <cos_cons_into_shared_pgtbl+0x6d>
  412ca4:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  412cab:	00 00 00 
  412cae:	66 90                	xchg   ax,ax

0000000000412cb0 <args_iter.part.0.isra.0>:

/* Length of the K/V map (= 1 for a K/V with a string value) */
static int
kv_len(struct kv_entry *kv)
{
	if (!kv) return 0;
  412cb0:	48 85 ff             	test   rdi,rdi
  412cb3:	74 73                	je     412d28 <args_iter.part.0.isra.0+0x78>
	switch (kv->vtype) {
  412cb5:	8b 47 08             	mov    eax,DWORD PTR [rdi+0x8]
  412cb8:	85 c0                	test   eax,eax
  412cba:	74 54                	je     412d10 <args_iter.part.0.isra.0+0x60>
  412cbc:	83 f8 01             	cmp    eax,0x1
  412cbf:	74 0f                	je     412cd0 <args_iter.part.0.isra.0+0x20>
 * this returns the first item in the K/V store
 */
static int
kv_iter(struct kv_entry *kv, struct kv_iter *i, struct kv_entry **ent)
{
	*i = (struct kv_iter){
  412cc1:	48 89 7e 08          	mov    QWORD PTR [rsi+0x8],rdi
	if (i->start->vtype != VTYPE_ARR) return 0;
  412cc5:	31 c0                	xor    eax,eax
	*i = (struct kv_iter){
  412cc7:	48 c7 46 10 00 00 00 	mov    QWORD PTR [rsi+0x10],0x0
  412cce:	00 
	if (i->start->vtype != VTYPE_ARR) return 0;
  412ccf:	c3                   	ret    
	case VTYPE_ARR: return kv->val.arr.sz;
  412cd0:	8b 47 10             	mov    eax,DWORD PTR [rdi+0x10]
	*i = (struct kv_iter){
  412cd3:	48 89 7e 08          	mov    QWORD PTR [rsi+0x8],rdi
  412cd7:	c7 46 10 00 00 00 00 	mov    DWORD PTR [rsi+0x10],0x0
  412cde:	89 46 14             	mov    DWORD PTR [rsi+0x14],eax
	if (i->curr == i->len) return 0;
  412ce1:	85 c0                	test   eax,eax
  412ce3:	75 0b                	jne    412cf0 <args_iter.part.0.isra.0+0x40>
	switch (arg->type) {
	case ARGS_IMPL_KV:  return kv_iter(arg->d.kv_ent, &i->i.kv_i, &ent->d.kv_ent);
	case ARGS_IMPL_TAR: return tar_iter(&arg->d.tar_ent, &i->i.tar_i, &ent->d.tar_ent);
	default:            return 0;
	}
}
  412ce5:	c3                   	ret    
  412ce6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  412ced:	00 00 00 
	*ent = __kv_index(i->start, i->curr++);
  412cf0:	c7 46 10 01 00 00 00 	mov    DWORD PTR [rsi+0x10],0x1
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  412cf7:	7e 47                	jle    412d40 <args_iter.part.0.isra.0+0x90>
	return kv->val.arr.kvs[idx];
  412cf9:	48 8b 47 18          	mov    rax,QWORD PTR [rdi+0x18]
  412cfd:	48 8b 00             	mov    rax,QWORD PTR [rax]
	*ent = __kv_index(i->start, i->curr++);
  412d00:	48 89 42 08          	mov    QWORD PTR [rdx+0x8],rax
	return 1;
  412d04:	b8 01 00 00 00       	mov    eax,0x1
  412d09:	c3                   	ret    
  412d0a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	*i = (struct kv_iter){
  412d10:	48 8b 05 f9 c6 00 00 	mov    rax,QWORD PTR [rip+0xc6f9]        # 41f410 <CSWTCH.187+0x20>
  412d17:	48 89 7e 08          	mov    QWORD PTR [rsi+0x8],rdi
  412d1b:	48 89 46 10          	mov    QWORD PTR [rsi+0x10],rax
	if (i->start->vtype != VTYPE_ARR) return 0;
  412d1f:	31 c0                	xor    eax,eax
  412d21:	c3                   	ret    
  412d22:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	*i = (struct kv_iter){
  412d28:	48 c7 46 08 00 00 00 	mov    QWORD PTR [rsi+0x8],0x0
  412d2f:	00 
	if (i->start->vtype != VTYPE_ARR) return 0;
  412d30:	31 c0                	xor    eax,eax
	*i = (struct kv_iter){
  412d32:	48 c7 46 10 00 00 00 	mov    QWORD PTR [rsi+0x10],0x0
  412d39:	00 
	if (i->start->vtype != VTYPE_ARR) return 0;
  412d3a:	c3                   	ret    
  412d3b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  412d40:	31 c0                	xor    eax,eax
  412d42:	eb bc                	jmp    412d00 <args_iter.part.0.isra.0+0x50>
  412d44:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  412d4b:	00 00 00 00 
  412d4f:	90                   	nop

0000000000412d50 <args_key>:
{
  412d50:	f3 0f 1e fa          	endbr64 
  412d54:	55                   	push   rbp
  412d55:	48 89 e5             	mov    rbp,rsp
  412d58:	41 55                	push   r13
  412d5a:	49 89 f5             	mov    r13,rsi
  412d5d:	41 54                	push   r12
	switch (arg->type) {
  412d5f:	8b 07                	mov    eax,DWORD PTR [rdi]
  412d61:	85 c0                	test   eax,eax
  412d63:	74 1b                	je     412d80 <args_key+0x30>
  412d65:	45 31 e4             	xor    r12d,r12d
  412d68:	83 f8 01             	cmp    eax,0x1
  412d6b:	75 2c                	jne    412d99 <args_key+0x49>
}
  412d6d:	41 5c                	pop    r12
	case ARGS_IMPL_TAR: return tar_key(&arg->d.tar_ent, arg_len);
  412d6f:	48 83 c7 08          	add    rdi,0x8
}
  412d73:	41 5d                	pop    r13
  412d75:	5d                   	pop    rbp
	case ARGS_IMPL_TAR: return tar_key(&arg->d.tar_ent, arg_len);
  412d76:	e9 a5 07 00 00       	jmp    413520 <tar_key>
  412d7b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  412d80:	4c 8b 67 08          	mov    r12,QWORD PTR [rdi+0x8]
	if (!kv) return NULL;
  412d84:	4d 85 e4             	test   r12,r12
  412d87:	74 10                	je     412d99 <args_key+0x49>
	*key_len = strlen(kv->key);
  412d89:	4d 8b 24 24          	mov    r12,QWORD PTR [r12]
  412d8d:	4c 89 e7             	mov    rdi,r12
  412d90:	e8 ab 44 00 00       	call   417240 <strlen>
  412d95:	41 89 45 00          	mov    DWORD PTR [r13+0x0],eax
}
  412d99:	4c 89 e0             	mov    rax,r12
  412d9c:	41 5c                	pop    r12
  412d9e:	41 5d                	pop    r13
  412da0:	5d                   	pop    rbp
  412da1:	c3                   	ret    
  412da2:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  412da9:	00 00 00 00 
  412dad:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000412db0 <args_value>:
{
  412db0:	f3 0f 1e fa          	endbr64 
	switch (arg->type) {
  412db4:	8b 07                	mov    eax,DWORD PTR [rdi]
  412db6:	85 c0                	test   eax,eax
  412db8:	74 1e                	je     412dd8 <args_value+0x28>
  412dba:	83 f8 01             	cmp    eax,0x1
  412dbd:	75 11                	jne    412dd0 <args_value+0x20>
	case ARGS_IMPL_TAR: return tar_value(&arg->d.tar_ent);
  412dbf:	48 83 c7 08          	add    rdi,0x8
  412dc3:	e9 08 08 00 00       	jmp    4135d0 <tar_value>
  412dc8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  412dcf:	00 
	if (!kv) return NULL;
  412dd0:	31 c0                	xor    eax,eax
}
  412dd2:	c3                   	ret    
  412dd3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  412dd8:	48 8b 47 08          	mov    rax,QWORD PTR [rdi+0x8]
	if (!kv) return NULL;
  412ddc:	48 85 c0             	test   rax,rax
  412ddf:	74 f1                	je     412dd2 <args_value+0x22>
	switch (kv->vtype) {
  412de1:	8b 50 08             	mov    edx,DWORD PTR [rax+0x8]
  412de4:	85 d2                	test   edx,edx
  412de6:	75 e8                	jne    412dd0 <args_value+0x20>
	case VTYPE_STR: return kv->val.str;
  412de8:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
  412dec:	c3                   	ret    
  412ded:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000412df0 <args_len>:
{
  412df0:	f3 0f 1e fa          	endbr64 
	switch (arg->type) {
  412df4:	8b 07                	mov    eax,DWORD PTR [rdi]
  412df6:	85 c0                	test   eax,eax
  412df8:	74 1e                	je     412e18 <args_len+0x28>
  412dfa:	83 f8 01             	cmp    eax,0x1
  412dfd:	75 11                	jne    412e10 <args_len+0x20>
	case ARGS_IMPL_TAR: return tar_len(&arg->d.tar_ent);
  412dff:	48 83 c7 08          	add    rdi,0x8
  412e03:	e9 b8 0c 00 00       	jmp    413ac0 <tar_len>
  412e08:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  412e0f:	00 
	if (!kv) return 0;
  412e10:	31 c0                	xor    eax,eax
}
  412e12:	c3                   	ret    
  412e13:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	case ARGS_IMPL_KV:  return kv_len(arg->d.kv_ent);
  412e18:	48 8b 57 08          	mov    rdx,QWORD PTR [rdi+0x8]
	if (!kv) return 0;
  412e1c:	48 85 d2             	test   rdx,rdx
  412e1f:	74 ef                	je     412e10 <args_len+0x20>
	switch (kv->vtype) {
  412e21:	8b 4a 08             	mov    ecx,DWORD PTR [rdx+0x8]
  412e24:	b8 01 00 00 00       	mov    eax,0x1
  412e29:	85 c9                	test   ecx,ecx
  412e2b:	74 e5                	je     412e12 <args_len+0x22>
	default:        return 0;
  412e2d:	31 c0                	xor    eax,eax
	switch (kv->vtype) {
  412e2f:	83 f9 01             	cmp    ecx,0x1
  412e32:	75 de                	jne    412e12 <args_len+0x22>
	case VTYPE_ARR: return kv->val.arr.sz;
  412e34:	8b 42 10             	mov    eax,DWORD PTR [rdx+0x10]
  412e37:	c3                   	ret    
  412e38:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  412e3f:	00 

0000000000412e40 <args_iter_next>:
{
  412e40:	f3 0f 1e fa          	endbr64 
	arg->type = i->type;
  412e44:	8b 07                	mov    eax,DWORD PTR [rdi]
  412e46:	89 06                	mov    DWORD PTR [rsi],eax
	switch (i->type) {
  412e48:	85 c0                	test   eax,eax
  412e4a:	74 1c                	je     412e68 <args_iter_next+0x28>
  412e4c:	83 f8 01             	cmp    eax,0x1
  412e4f:	75 0f                	jne    412e60 <args_iter_next+0x20>
	case ARGS_IMPL_TAR: return tar_iter_next(&i->i.tar_i, &arg->d.tar_ent);
  412e51:	48 83 c6 08          	add    rsi,0x8
  412e55:	48 83 c7 08          	add    rdi,0x8
  412e59:	e9 f2 08 00 00       	jmp    413750 <tar_iter_next>
  412e5e:	66 90                	xchg   ax,ax
	switch (i->type) {
  412e60:	31 c0                	xor    eax,eax
  412e62:	c3                   	ret    
  412e63:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	if (i->start->vtype != VTYPE_ARR) return 0;
  412e68:	48 8b 4f 08          	mov    rcx,QWORD PTR [rdi+0x8]
  412e6c:	31 c0                	xor    eax,eax
  412e6e:	83 79 08 01          	cmp    DWORD PTR [rcx+0x8],0x1
  412e72:	75 2c                	jne    412ea0 <args_iter_next+0x60>
	if (i->curr == i->len) return 0;
  412e74:	48 63 57 10          	movsxd rdx,DWORD PTR [rdi+0x10]
  412e78:	3b 57 14             	cmp    edx,DWORD PTR [rdi+0x14]
  412e7b:	74 23                	je     412ea0 <args_iter_next+0x60>
	*ent = __kv_index(i->start, i->curr++);
  412e7d:	8d 42 01             	lea    eax,[rdx+0x1]
  412e80:	89 47 10             	mov    DWORD PTR [rdi+0x10],eax
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  412e83:	3b 51 10             	cmp    edx,DWORD PTR [rcx+0x10]
  412e86:	7d 20                	jge    412ea8 <args_iter_next+0x68>
  412e88:	85 d2                	test   edx,edx
  412e8a:	78 1c                	js     412ea8 <args_iter_next+0x68>
	return kv->val.arr.kvs[idx];
  412e8c:	48 8b 41 18          	mov    rax,QWORD PTR [rcx+0x18]
  412e90:	48 8b 04 d0          	mov    rax,QWORD PTR [rax+rdx*8]
	*ent = __kv_index(i->start, i->curr++);
  412e94:	48 89 46 08          	mov    QWORD PTR [rsi+0x8],rax
	return 1;
  412e98:	b8 01 00 00 00       	mov    eax,0x1
  412e9d:	c3                   	ret    
  412e9e:	66 90                	xchg   ax,ax
}
  412ea0:	c3                   	ret    
  412ea1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  412ea8:	31 c0                	xor    eax,eax
  412eaa:	eb e8                	jmp    412e94 <args_iter_next+0x54>
  412eac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000412eb0 <args_iter>:
{
  412eb0:	f3 0f 1e fa          	endbr64 
	i->type = ent->type = arg->type;
  412eb4:	8b 07                	mov    eax,DWORD PTR [rdi]
  412eb6:	89 02                	mov    DWORD PTR [rdx],eax
  412eb8:	89 06                	mov    DWORD PTR [rsi],eax
	switch (arg->type) {
  412eba:	85 c0                	test   eax,eax
  412ebc:	74 32                	je     412ef0 <args_iter+0x40>
  412ebe:	83 f8 01             	cmp    eax,0x1
  412ec1:	75 25                	jne    412ee8 <args_iter+0x38>
	case ARGS_IMPL_TAR: return tar_iter(&arg->d.tar_ent, &i->i.tar_i, &ent->d.tar_ent);
  412ec3:	48 83 c2 08          	add    rdx,0x8
  412ec7:	48 83 c6 08          	add    rsi,0x8
  412ecb:	48 83 c7 08          	add    rdi,0x8
  412ecf:	e9 7c 0b 00 00       	jmp    413a50 <tar_iter>
  412ed4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	*i = (struct kv_iter){
  412ed8:	48 c7 46 08 00 00 00 	mov    QWORD PTR [rsi+0x8],0x0
  412edf:	00 
  412ee0:	48 c7 46 10 00 00 00 	mov    QWORD PTR [rsi+0x10],0x0
  412ee7:	00 
	if (i->start->vtype != VTYPE_ARR) return 0;
  412ee8:	31 c0                	xor    eax,eax
  412eea:	c3                   	ret    
  412eeb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  412ef0:	48 8b 4f 08          	mov    rcx,QWORD PTR [rdi+0x8]
	if (!kv) return 0;
  412ef4:	48 85 c9             	test   rcx,rcx
  412ef7:	74 df                	je     412ed8 <args_iter+0x28>
	switch (kv->vtype) {
  412ef9:	8b 41 08             	mov    eax,DWORD PTR [rcx+0x8]
  412efc:	85 c0                	test   eax,eax
  412efe:	74 30                	je     412f30 <args_iter+0x80>
  412f00:	83 f8 01             	cmp    eax,0x1
  412f03:	74 13                	je     412f18 <args_iter+0x68>
	*i = (struct kv_iter){
  412f05:	48 89 4e 08          	mov    QWORD PTR [rsi+0x8],rcx
	if (i->start->vtype != VTYPE_ARR) return 0;
  412f09:	31 c0                	xor    eax,eax
	*i = (struct kv_iter){
  412f0b:	48 c7 46 10 00 00 00 	mov    QWORD PTR [rsi+0x10],0x0
  412f12:	00 
	if (i->start->vtype != VTYPE_ARR) return 0;
  412f13:	c3                   	ret    
  412f14:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	case VTYPE_ARR: return kv->val.arr.sz;
  412f18:	8b 41 10             	mov    eax,DWORD PTR [rcx+0x10]
	*i = (struct kv_iter){
  412f1b:	48 89 4e 08          	mov    QWORD PTR [rsi+0x8],rcx
  412f1f:	c7 46 10 00 00 00 00 	mov    DWORD PTR [rsi+0x10],0x0
  412f26:	89 46 14             	mov    DWORD PTR [rsi+0x14],eax
	if (i->curr == i->len) return 0;
  412f29:	85 c0                	test   eax,eax
  412f2b:	75 1b                	jne    412f48 <args_iter+0x98>
}
  412f2d:	c3                   	ret    
  412f2e:	66 90                	xchg   ax,ax
	*i = (struct kv_iter){
  412f30:	48 8b 05 d9 c4 00 00 	mov    rax,QWORD PTR [rip+0xc4d9]        # 41f410 <CSWTCH.187+0x20>
  412f37:	48 89 4e 08          	mov    QWORD PTR [rsi+0x8],rcx
  412f3b:	48 89 46 10          	mov    QWORD PTR [rsi+0x10],rax
	if (i->start->vtype != VTYPE_ARR) return 0;
  412f3f:	31 c0                	xor    eax,eax
  412f41:	c3                   	ret    
  412f42:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	*ent = __kv_index(i->start, i->curr++);
  412f48:	c7 46 10 01 00 00 00 	mov    DWORD PTR [rsi+0x10],0x1
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  412f4f:	7e 17                	jle    412f68 <args_iter+0xb8>
	return kv->val.arr.kvs[idx];
  412f51:	48 8b 41 18          	mov    rax,QWORD PTR [rcx+0x18]
  412f55:	48 8b 00             	mov    rax,QWORD PTR [rax]
	*ent = __kv_index(i->start, i->curr++);
  412f58:	48 89 42 08          	mov    QWORD PTR [rdx+0x8],rax
	return 1;
  412f5c:	b8 01 00 00 00       	mov    eax,0x1
  412f61:	c3                   	ret    
  412f62:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  412f68:	31 c0                	xor    eax,eax
  412f6a:	eb ec                	jmp    412f58 <args_iter+0xa8>
  412f6c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000412f70 <args_foreach>:

typedef void (*args_visitor_fn_t)(struct initargs *ent, void *data);

int
args_foreach(struct initargs *ent, args_visitor_fn_t fn, void *data)
{
  412f70:	f3 0f 1e fa          	endbr64 
	struct initargs_iter i;
	struct initargs curr;
	int cont;

	if (!ent) return -1;
  412f74:	48 85 ff             	test   rdi,rdi
  412f77:	0f 84 d7 00 00 00    	je     413054 <args_foreach+0xe4>
{
  412f7d:	55                   	push   rbp
  412f7e:	48 89 e5             	mov    rbp,rsp
  412f81:	41 55                	push   r13
  412f83:	41 54                	push   r12
  412f85:	49 89 d4             	mov    r12,rdx
  412f88:	53                   	push   rbx
  412f89:	48 89 f3             	mov    rbx,rsi
  412f8c:	48 83 ec 48          	sub    rsp,0x48
	i->type = ent->type = arg->type;
  412f90:	8b 07                	mov    eax,DWORD PTR [rdi]
  412f92:	89 45 a0             	mov    DWORD PTR [rbp-0x60],eax
  412f95:	89 45 c0             	mov    DWORD PTR [rbp-0x40],eax
	switch (arg->type) {
  412f98:	85 c0                	test   eax,eax
  412f9a:	0f 84 90 00 00 00    	je     413030 <args_foreach+0xc0>
  412fa0:	83 f8 01             	cmp    eax,0x1
  412fa3:	75 43                	jne    412fe8 <args_foreach+0x78>
	case ARGS_IMPL_TAR: return tar_iter(&arg->d.tar_ent, &i->i.tar_i, &ent->d.tar_ent);
  412fa5:	48 83 c7 08          	add    rdi,0x8
  412fa9:	48 8d 55 a8          	lea    rdx,[rbp-0x58]
  412fad:	48 8d 75 c8          	lea    rsi,[rbp-0x38]
  412fb1:	e8 9a 0a 00 00       	call   413a50 <tar_iter>
	for (cont = args_iter(ent, &i, &curr); cont; cont = args_iter_next(&i, &curr)) {
  412fb6:	85 c0                	test   eax,eax
  412fb8:	74 2e                	je     412fe8 <args_foreach+0x78>
  412fba:	4c 8d 6d a0          	lea    r13,[rbp-0x60]
  412fbe:	66 90                	xchg   ax,ax
		fn(&curr, data);
  412fc0:	4c 89 e6             	mov    rsi,r12
  412fc3:	4c 89 ef             	mov    rdi,r13
  412fc6:	ff d3                	call   rbx
	arg->type = i->type;
  412fc8:	8b 45 c0             	mov    eax,DWORD PTR [rbp-0x40]
  412fcb:	89 45 a0             	mov    DWORD PTR [rbp-0x60],eax
	switch (i->type) {
  412fce:	85 c0                	test   eax,eax
  412fd0:	74 26                	je     412ff8 <args_foreach+0x88>
  412fd2:	83 f8 01             	cmp    eax,0x1
  412fd5:	75 11                	jne    412fe8 <args_foreach+0x78>
	case ARGS_IMPL_TAR: return tar_iter_next(&i->i.tar_i, &arg->d.tar_ent);
  412fd7:	48 8d 75 a8          	lea    rsi,[rbp-0x58]
  412fdb:	48 8d 7d c8          	lea    rdi,[rbp-0x38]
  412fdf:	e8 6c 07 00 00       	call   413750 <tar_iter_next>
	for (cont = args_iter(ent, &i, &curr); cont; cont = args_iter_next(&i, &curr)) {
  412fe4:	85 c0                	test   eax,eax
  412fe6:	75 d8                	jne    412fc0 <args_foreach+0x50>
	}

	return 0;
}
  412fe8:	48 83 c4 48          	add    rsp,0x48
	return 0;
  412fec:	31 c0                	xor    eax,eax
}
  412fee:	5b                   	pop    rbx
  412fef:	41 5c                	pop    r12
  412ff1:	41 5d                	pop    r13
  412ff3:	5d                   	pop    rbp
  412ff4:	c3                   	ret    
  412ff5:	0f 1f 00             	nop    DWORD PTR [rax]
	if (i->start->vtype != VTYPE_ARR) return 0;
  412ff8:	48 8b 55 c8          	mov    rdx,QWORD PTR [rbp-0x38]
  412ffc:	83 7a 08 01          	cmp    DWORD PTR [rdx+0x8],0x1
  413000:	75 e6                	jne    412fe8 <args_foreach+0x78>
	if (i->curr == i->len) return 0;
  413002:	48 63 45 d0          	movsxd rax,DWORD PTR [rbp-0x30]
  413006:	3b 45 d4             	cmp    eax,DWORD PTR [rbp-0x2c]
  413009:	74 dd                	je     412fe8 <args_foreach+0x78>
	*ent = __kv_index(i->start, i->curr++);
  41300b:	8d 48 01             	lea    ecx,[rax+0x1]
  41300e:	89 4d d0             	mov    DWORD PTR [rbp-0x30],ecx
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  413011:	3b 42 10             	cmp    eax,DWORD PTR [rdx+0x10]
  413014:	7d 3a                	jge    413050 <args_foreach+0xe0>
  413016:	85 c0                	test   eax,eax
  413018:	78 36                	js     413050 <args_foreach+0xe0>
	return kv->val.arr.kvs[idx];
  41301a:	48 8b 52 18          	mov    rdx,QWORD PTR [rdx+0x18]
  41301e:	48 8b 04 c2          	mov    rax,QWORD PTR [rdx+rax*8]
	*ent = __kv_index(i->start, i->curr++);
  413022:	48 89 45 a8          	mov    QWORD PTR [rbp-0x58],rax
	for (cont = args_iter(ent, &i, &curr); cont; cont = args_iter_next(&i, &curr)) {
  413026:	eb 98                	jmp    412fc0 <args_foreach+0x50>
  413028:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41302f:	00 
  413030:	4c 8d 6d a0          	lea    r13,[rbp-0x60]
  413034:	48 8b 7f 08          	mov    rdi,QWORD PTR [rdi+0x8]
  413038:	48 8d 75 c0          	lea    rsi,[rbp-0x40]
  41303c:	4c 89 ea             	mov    rdx,r13
  41303f:	e8 6c fc ff ff       	call   412cb0 <args_iter.part.0.isra.0>
  413044:	e9 6d ff ff ff       	jmp    412fb6 <args_foreach+0x46>
  413049:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  413050:	31 c0                	xor    eax,eax
  413052:	eb ce                	jmp    413022 <args_foreach+0xb2>
	if (!ent) return -1;
  413054:	b8 ff ff ff ff       	mov    eax,0xffffffff
}
  413059:	c3                   	ret    
  41305a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000413060 <args_lkup_entry>:
 * not including a '/').  This enables this function to be used to
 * walk through the data-structure guided by a path through the k/v.
 */
int
args_lkup_entry(struct initargs *arg, char *path, struct initargs *ret)
{
  413060:	f3 0f 1e fa          	endbr64 
  413064:	55                   	push   rbp
  413065:	48 89 e5             	mov    rbp,rsp
  413068:	41 57                	push   r15
  41306a:	41 56                	push   r14
  41306c:	41 55                	push   r13
  41306e:	41 54                	push   r12
  413070:	53                   	push   rbx
  413071:	48 81 ec 88 00 00 00 	sub    rsp,0x88
	struct initargs_iter i;
	struct initargs curr, start;
	unsigned int len, cont;
	char *slash, *key = path;

	if (!arg || !key || !ret) return -1;
  413078:	48 85 ff             	test   rdi,rdi
{
  41307b:	48 89 95 58 ff ff ff 	mov    QWORD PTR [rbp-0xa8],rdx
	if (!arg || !key || !ret) return -1;
  413082:	0f 94 c0             	sete   al
  413085:	48 85 d2             	test   rdx,rdx
  413088:	0f 94 c2             	sete   dl
  41308b:	08 d0                	or     al,dl
  41308d:	0f 85 4d 01 00 00    	jne    4131e0 <args_lkup_entry+0x180>
  413093:	49 89 f4             	mov    r12,rsi
  413096:	48 85 f6             	test   rsi,rsi
  413099:	0f 84 41 01 00 00    	je     4131e0 <args_lkup_entry+0x180>
	start = *arg;
  41309f:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  4130a3:	f3 0f 6f 07          	movdqu xmm0,XMMWORD PTR [rdi]
  4130a7:	48 89 45 a0          	mov    QWORD PTR [rbp-0x60],rax
  4130ab:	0f 29 45 90          	movaps XMMWORD PTR [rbp-0x70],xmm0
	/* Iterate through the path... */
	do {
		int found = 0;

		slash = strchr(key, '/');
  4130af:	be 2f 00 00 00       	mov    esi,0x2f
  4130b4:	4c 89 e7             	mov    rdi,r12
  4130b7:	e8 34 40 00 00       	call   4170f0 <strchr>
  4130bc:	49 89 c5             	mov    r13,rax
		len = slash ? (unsigned int)(slash - key) : strlen(key);
  4130bf:	48 85 c0             	test   rax,rax
  4130c2:	0f 84 d8 01 00 00    	je     4132a0 <args_lkup_entry+0x240>
  4130c8:	89 c3                	mov    ebx,eax
  4130ca:	44 29 e3             	sub    ebx,r12d
	i->type = ent->type = arg->type;
  4130cd:	8b 45 90             	mov    eax,DWORD PTR [rbp-0x70]
  4130d0:	89 85 70 ff ff ff    	mov    DWORD PTR [rbp-0x90],eax
  4130d6:	89 45 b0             	mov    DWORD PTR [rbp-0x50],eax
	switch (arg->type) {
  4130d9:	85 c0                	test   eax,eax
  4130db:	0f 84 4f 01 00 00    	je     413230 <args_lkup_entry+0x1d0>
  4130e1:	83 f8 01             	cmp    eax,0x1
  4130e4:	0f 85 f6 00 00 00    	jne    4131e0 <args_lkup_entry+0x180>
	case ARGS_IMPL_TAR: return tar_iter(&arg->d.tar_ent, &i->i.tar_i, &ent->d.tar_ent);
  4130ea:	48 8d 95 78 ff ff ff 	lea    rdx,[rbp-0x88]
  4130f1:	48 8d 75 b8          	lea    rsi,[rbp-0x48]
  4130f5:	48 8d 7d 98          	lea    rdi,[rbp-0x68]
  4130f9:	e8 52 09 00 00       	call   413a50 <tar_iter>

		/* ...and look the key up in the KV */
		for (cont = args_iter(&start, &i, &curr) ; cont ; cont = args_iter_next(&i, &curr)) {
  4130fe:	85 c0                	test   eax,eax
  413100:	0f 84 da 00 00 00    	je     4131e0 <args_lkup_entry+0x180>
  413106:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41310d:	00 00 00 
	switch (arg->type) {
  413110:	8b 85 70 ff ff ff    	mov    eax,DWORD PTR [rbp-0x90]
  413116:	85 c0                	test   eax,eax
  413118:	74 79                	je     413193 <args_lkup_entry+0x133>
  41311a:	83 f8 01             	cmp    eax,0x1
  41311d:	0f 84 dd 00 00 00    	je     413200 <args_lkup_entry+0x1a0>
			int key_len;
			char *k = args_key(&curr, &key_len);

			if ((unsigned int)key_len == len && strncmp(k, key, len) == 0) {
  413123:	8b 95 6c ff ff ff    	mov    edx,DWORD PTR [rbp-0x94]
	default:            return NULL;
  413129:	45 31 f6             	xor    r14d,r14d
			if ((unsigned int)key_len == len && strncmp(k, key, len) == 0) {
  41312c:	39 da                	cmp    edx,ebx
  41312e:	75 19                	jne    413149 <args_lkup_entry+0xe9>
  413130:	41 89 d7             	mov    r15d,edx
  413133:	4c 89 e6             	mov    rsi,r12
  413136:	4c 89 f7             	mov    rdi,r14
  413139:	4c 89 fa             	mov    rdx,r15
  41313c:	e8 7f 41 00 00       	call   4172c0 <strncmp>
  413141:	85 c0                	test   eax,eax
  413143:	0f 84 07 01 00 00    	je     413250 <args_lkup_entry+0x1f0>
	arg->type = i->type;
  413149:	8b 45 b0             	mov    eax,DWORD PTR [rbp-0x50]
  41314c:	89 85 70 ff ff ff    	mov    DWORD PTR [rbp-0x90],eax
	switch (i->type) {
  413152:	85 c0                	test   eax,eax
  413154:	75 6a                	jne    4131c0 <args_lkup_entry+0x160>
	if (i->start->vtype != VTYPE_ARR) return 0;
  413156:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
  41315a:	83 7a 08 01          	cmp    DWORD PTR [rdx+0x8],0x1
  41315e:	0f 85 7c 00 00 00    	jne    4131e0 <args_lkup_entry+0x180>
	if (i->curr == i->len) return 0;
  413164:	48 63 45 c0          	movsxd rax,DWORD PTR [rbp-0x40]
  413168:	3b 45 c4             	cmp    eax,DWORD PTR [rbp-0x3c]
  41316b:	74 73                	je     4131e0 <args_lkup_entry+0x180>
	*ent = __kv_index(i->start, i->curr++);
  41316d:	8d 48 01             	lea    ecx,[rax+0x1]
  413170:	89 4d c0             	mov    DWORD PTR [rbp-0x40],ecx
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  413173:	3b 42 10             	cmp    eax,DWORD PTR [rdx+0x10]
  413176:	0f 8d ac 00 00 00    	jge    413228 <args_lkup_entry+0x1c8>
  41317c:	85 c0                	test   eax,eax
  41317e:	0f 88 a4 00 00 00    	js     413228 <args_lkup_entry+0x1c8>
	return kv->val.arr.kvs[idx];
  413184:	48 8b 52 18          	mov    rdx,QWORD PTR [rdx+0x18]
  413188:	48 8b 04 c2          	mov    rax,QWORD PTR [rdx+rax*8]
	*ent = __kv_index(i->start, i->curr++);
  41318c:	48 89 85 78 ff ff ff 	mov    QWORD PTR [rbp-0x88],rax
	switch (arg->type) {
  413193:	4c 8b b5 78 ff ff ff 	mov    r14,QWORD PTR [rbp-0x88]
	if (!kv) return NULL;
  41319a:	4d 85 f6             	test   r14,r14
  41319d:	74 77                	je     413216 <args_lkup_entry+0x1b6>
	*key_len = strlen(kv->key);
  41319f:	4d 8b 36             	mov    r14,QWORD PTR [r14]
  4131a2:	4c 89 f7             	mov    rdi,r14
  4131a5:	e8 96 40 00 00       	call   417240 <strlen>
  4131aa:	89 c2                	mov    edx,eax
  4131ac:	89 85 6c ff ff ff    	mov    DWORD PTR [rbp-0x94],eax
			if ((unsigned int)key_len == len && strncmp(k, key, len) == 0) {
  4131b2:	39 da                	cmp    edx,ebx
  4131b4:	0f 84 76 ff ff ff    	je     413130 <args_lkup_entry+0xd0>
  4131ba:	eb 8d                	jmp    413149 <args_lkup_entry+0xe9>
  4131bc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	switch (i->type) {
  4131c0:	83 f8 01             	cmp    eax,0x1
  4131c3:	75 1b                	jne    4131e0 <args_lkup_entry+0x180>
	case ARGS_IMPL_TAR: return tar_iter_next(&i->i.tar_i, &arg->d.tar_ent);
  4131c5:	48 8d b5 78 ff ff ff 	lea    rsi,[rbp-0x88]
  4131cc:	48 8d 7d b8          	lea    rdi,[rbp-0x48]
  4131d0:	e8 7b 05 00 00       	call   413750 <tar_iter_next>
		for (cont = args_iter(&start, &i, &curr) ; cont ; cont = args_iter_next(&i, &curr)) {
  4131d5:	85 c0                	test   eax,eax
  4131d7:	0f 85 33 ff ff ff    	jne    413110 <args_lkup_entry+0xb0>
  4131dd:	0f 1f 00             	nop    DWORD PTR [rax]
				start = curr;
				found = 1;
				break;
			}
		}
		if (!found) return -1;
  4131e0:	41 b8 ff ff ff ff    	mov    r8d,0xffffffff

		if (slash) key = slash + 1;
	} while (slash && *key != '\0');

	return -1;
}
  4131e6:	48 81 c4 88 00 00 00 	add    rsp,0x88
  4131ed:	44 89 c0             	mov    eax,r8d
  4131f0:	5b                   	pop    rbx
  4131f1:	41 5c                	pop    r12
  4131f3:	41 5d                	pop    r13
  4131f5:	41 5e                	pop    r14
  4131f7:	41 5f                	pop    r15
  4131f9:	5d                   	pop    rbp
  4131fa:	c3                   	ret    
  4131fb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	case ARGS_IMPL_TAR: return tar_key(&arg->d.tar_ent, arg_len);
  413200:	48 8d b5 6c ff ff ff 	lea    rsi,[rbp-0x94]
  413207:	48 8d bd 78 ff ff ff 	lea    rdi,[rbp-0x88]
  41320e:	e8 0d 03 00 00       	call   413520 <tar_key>
  413213:	49 89 c6             	mov    r14,rax
			if ((unsigned int)key_len == len && strncmp(k, key, len) == 0) {
  413216:	8b 95 6c ff ff ff    	mov    edx,DWORD PTR [rbp-0x94]
	case ARGS_IMPL_TAR: return tar_key(&arg->d.tar_ent, arg_len);
  41321c:	e9 0b ff ff ff       	jmp    41312c <args_lkup_entry+0xcc>
  413221:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	if (idx >= kv_len(kv) || idx < 0) return NULL;
  413228:	31 c0                	xor    eax,eax
  41322a:	e9 5d ff ff ff       	jmp    41318c <args_lkup_entry+0x12c>
  41322f:	90                   	nop
  413230:	48 8b 7d 98          	mov    rdi,QWORD PTR [rbp-0x68]
  413234:	48 8d 95 70 ff ff ff 	lea    rdx,[rbp-0x90]
  41323b:	48 8d 75 b0          	lea    rsi,[rbp-0x50]
  41323f:	e8 6c fa ff ff       	call   412cb0 <args_iter.part.0.isra.0>
  413244:	e9 b5 fe ff ff       	jmp    4130fe <args_lkup_entry+0x9e>
  413249:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
				if (strlen(key) == len) {
  413250:	4c 89 e7             	mov    rdi,r12
  413253:	89 85 54 ff ff ff    	mov    DWORD PTR [rbp-0xac],eax
  413259:	e8 e2 3f 00 00       	call   417240 <strlen>
  41325e:	44 8b 85 54 ff ff ff 	mov    r8d,DWORD PTR [rbp-0xac]
  413265:	49 39 c7             	cmp    r15,rax
  413268:	74 45                	je     4132af <args_lkup_entry+0x24f>
				start = curr;
  41326a:	66 0f 6f 8d 70 ff ff 	movdqa xmm1,XMMWORD PTR [rbp-0x90]
  413271:	ff 
  413272:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  413276:	0f 29 4d 90          	movaps XMMWORD PTR [rbp-0x70],xmm1
  41327a:	48 89 45 a0          	mov    QWORD PTR [rbp-0x60],rax
		if (slash) key = slash + 1;
  41327e:	4d 85 ed             	test   r13,r13
  413281:	0f 84 59 ff ff ff    	je     4131e0 <args_lkup_entry+0x180>
	} while (slash && *key != '\0');
  413287:	41 80 7d 01 00       	cmp    BYTE PTR [r13+0x1],0x0
		if (slash) key = slash + 1;
  41328c:	4d 8d 65 01          	lea    r12,[r13+0x1]
	} while (slash && *key != '\0');
  413290:	0f 85 19 fe ff ff    	jne    4130af <args_lkup_entry+0x4f>
  413296:	e9 45 ff ff ff       	jmp    4131e0 <args_lkup_entry+0x180>
  41329b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		len = slash ? (unsigned int)(slash - key) : strlen(key);
  4132a0:	4c 89 e7             	mov    rdi,r12
  4132a3:	e8 98 3f 00 00       	call   417240 <strlen>
  4132a8:	89 c3                	mov    ebx,eax
  4132aa:	e9 1e fe ff ff       	jmp    4130cd <args_lkup_entry+0x6d>
					*ret = curr;
  4132af:	48 8b 8d 58 ff ff ff 	mov    rcx,QWORD PTR [rbp-0xa8]
  4132b6:	66 0f 6f 95 70 ff ff 	movdqa xmm2,XMMWORD PTR [rbp-0x90]
  4132bd:	ff 
  4132be:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  4132c2:	0f 11 11             	movups XMMWORD PTR [rcx],xmm2
  4132c5:	48 89 41 10          	mov    QWORD PTR [rcx+0x10],rax
					return 0;
  4132c9:	e9 18 ff ff ff       	jmp    4131e6 <args_lkup_entry+0x186>
  4132ce:	66 90                	xchg   ax,ax

00000000004132d0 <args_type>:

args_type_t
args_type(struct initargs *ent)
{
  4132d0:	f3 0f 1e fa          	endbr64 
  4132d4:	55                   	push   rbp
  4132d5:	48 89 e5             	mov    rbp,rsp
  4132d8:	41 54                	push   r12
  4132da:	48 83 ec 08          	sub    rsp,0x8
	switch (ent->type) {
  4132de:	44 8b 27             	mov    r12d,DWORD PTR [rdi]
  4132e1:	45 85 e4             	test   r12d,r12d
  4132e4:	74 3a                	je     413320 <args_type+0x50>
  4132e6:	41 83 fc 01          	cmp    r12d,0x1
  4132ea:	75 24                	jne    413310 <args_type+0x40>
	case ARGS_IMPL_KV:  return kv_type(ent->d.kv_ent);
	case ARGS_IMPL_TAR: return tar_is_value(&ent->d.tar_ent) ? ARGS_VAL : ARGS_MAP;
  4132ec:	48 83 c7 08          	add    rdi,0x8
  4132f0:	e8 fb 03 00 00       	call   4136f0 <tar_is_value>
  4132f5:	85 c0                	test   eax,eax
  4132f7:	b8 02 00 00 00       	mov    eax,0x2
  4132fc:	44 0f 45 e0          	cmovne r12d,eax
	default:            return ARGS_ERR;
	}
}
  413300:	44 89 e0             	mov    eax,r12d
  413303:	4c 8b 65 f8          	mov    r12,QWORD PTR [rbp-0x8]
  413307:	c9                   	leave  
  413308:	c3                   	ret    
  413309:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	switch (ent->type) {
  413310:	45 31 e4             	xor    r12d,r12d
}
  413313:	44 89 e0             	mov    eax,r12d
  413316:	4c 8b 65 f8          	mov    r12,QWORD PTR [rbp-0x8]
  41331a:	c9                   	leave  
  41331b:	c3                   	ret    
  41331c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	switch (kv->vtype) {
  413320:	48 8b 47 08          	mov    rax,QWORD PTR [rdi+0x8]
	case VTYPE_STR: return ARGS_VAL;
  413324:	41 bc 02 00 00 00    	mov    r12d,0x2
	switch (kv->vtype) {
  41332a:	8b 40 08             	mov    eax,DWORD PTR [rax+0x8]
  41332d:	85 c0                	test   eax,eax
  41332f:	74 cf                	je     413300 <args_type+0x30>
  413331:	45 31 e4             	xor    r12d,r12d
  413334:	83 f8 01             	cmp    eax,0x1
  413337:	41 0f 94 c4          	sete   r12b
}
  41333b:	44 89 e0             	mov    eax,r12d
  41333e:	4c 8b 65 f8          	mov    r12,QWORD PTR [rbp-0x8]
  413342:	c9                   	leave  
  413343:	c3                   	ret    
  413344:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41334b:	00 00 00 00 
  41334f:	90                   	nop

0000000000413350 <args_get_entry_from>:

int
args_get_entry_from(char *path, struct initargs *from, struct initargs *ent)
{
  413350:	f3 0f 1e fa          	endbr64 
  413354:	49 89 f8             	mov    r8,rdi
  413357:	48 89 f7             	mov    rdi,rsi
	return args_lkup_entry(from, path, ent);
  41335a:	4c 89 c6             	mov    rsi,r8
  41335d:	e9 fe fc ff ff       	jmp    413060 <args_lkup_entry>
  413362:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  413369:	00 00 00 00 
  41336d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000413370 <args_get_from>:
}

char *
args_get_from(char *path, struct initargs *from)
{
  413370:	f3 0f 1e fa          	endbr64 
  413374:	55                   	push   rbp
  413375:	49 89 f8             	mov    r8,rdi
  413378:	48 89 f7             	mov    rdi,rsi
	return args_lkup_entry(from, path, ent);
  41337b:	4c 89 c6             	mov    rsi,r8
{
  41337e:	48 89 e5             	mov    rbp,rsp
  413381:	48 83 ec 20          	sub    rsp,0x20
	return args_lkup_entry(from, path, ent);
  413385:	48 8d 55 e0          	lea    rdx,[rbp-0x20]
  413389:	e8 d2 fc ff ff       	call   413060 <args_lkup_entry>
  41338e:	41 89 c0             	mov    r8d,eax
	struct initargs ent;

	if (args_get_entry_from(path, from, &ent)) return NULL;
  413391:	31 c0                	xor    eax,eax
  413393:	45 85 c0             	test   r8d,r8d
  413396:	75 0c                	jne    4133a4 <args_get_from+0x34>
	switch (arg->type) {
  413398:	8b 55 e0             	mov    edx,DWORD PTR [rbp-0x20]
  41339b:	85 d2                	test   edx,edx
  41339d:	74 21                	je     4133c0 <args_get_from+0x50>
  41339f:	83 fa 01             	cmp    edx,0x1
  4133a2:	74 0c                	je     4133b0 <args_get_from+0x40>

	return args_value(&ent);
}
  4133a4:	c9                   	leave  
  4133a5:	c3                   	ret    
  4133a6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4133ad:	00 00 00 
	case ARGS_IMPL_TAR: return tar_value(&arg->d.tar_ent);
  4133b0:	48 8d 7d e8          	lea    rdi,[rbp-0x18]
  4133b4:	e8 17 02 00 00       	call   4135d0 <tar_value>
}
  4133b9:	c9                   	leave  
  4133ba:	c3                   	ret    
  4133bb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  4133c0:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
	if (!kv) return NULL;
  4133c4:	48 85 c0             	test   rax,rax
  4133c7:	74 db                	je     4133a4 <args_get_from+0x34>
	switch (kv->vtype) {
  4133c9:	8b 50 08             	mov    edx,DWORD PTR [rax+0x8]
  4133cc:	85 d2                	test   edx,edx
  4133ce:	75 10                	jne    4133e0 <args_get_from+0x70>
	case VTYPE_STR: return kv->val.str;
  4133d0:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
}
  4133d4:	c9                   	leave  
  4133d5:	c3                   	ret    
  4133d6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4133dd:	00 00 00 
  4133e0:	c9                   	leave  
	if (args_get_entry_from(path, from, &ent)) return NULL;
  4133e1:	31 c0                	xor    eax,eax
}
  4133e3:	c3                   	ret    
  4133e4:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4133eb:	00 00 00 00 
  4133ef:	90                   	nop

00000000004133f0 <args_get_entry>:
 * structure, which is just a /-separated set of keys used to lookup
 * in the corresponding maps.
 */
int
args_get_entry(char *path, struct initargs *ent)
{
  4133f0:	f3 0f 1e fa          	endbr64 
  4133f4:	55                   	push   rbp
	return args_lkup_entry(from, path, ent);
  4133f5:	48 89 f2             	mov    rdx,rsi
{
  4133f8:	48 89 e5             	mov    rbp,rsp
  4133fb:	41 55                	push   r13
  4133fd:	49 89 f5             	mov    r13,rsi
	return args_lkup_entry(from, path, ent);
  413400:	48 89 fe             	mov    rsi,rdi
{
  413403:	41 54                	push   r12
  413405:	49 89 fc             	mov    r12,rdi
	return args_lkup_entry(from, path, ent);
  413408:	bf 20 60 42 00       	mov    edi,0x426020
{
  41340d:	48 83 ec 20          	sub    rsp,0x20
	return args_lkup_entry(from, path, ent);
  413411:	e8 4a fc ff ff       	call   413060 <args_lkup_entry>
	struct initargs tarroot;
	struct tar_entry *tarent;

	if (!args_get_entry_from(path, &__initargs_root, ent)) return 0;
  413416:	85 c0                	test   eax,eax
  413418:	75 0e                	jne    413428 <args_get_entry+0x38>
		.type = ARGS_IMPL_TAR,
		.d.tar_ent = *tarent
	};

	return args_get_entry_from(path, &tarroot, ent);
}
  41341a:	48 83 c4 20          	add    rsp,0x20
  41341e:	41 5c                	pop    r12
  413420:	41 5d                	pop    r13
  413422:	5d                   	pop    rbp
  413423:	c3                   	ret    
  413424:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	tarent = tar_root();
  413428:	e8 33 07 00 00       	call   413b60 <tar_root>
	if (!tarent) return -1;
  41342d:	48 85 c0             	test   rax,rax
  413430:	74 2d                	je     41345f <args_get_entry+0x6f>
		.d.tar_ent = *tarent
  413432:	8b 10                	mov    edx,DWORD PTR [rax]
  413434:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	return args_lkup_entry(from, path, ent);
  413438:	4c 89 e6             	mov    rsi,r12
  41343b:	48 8d 7d d0          	lea    rdi,[rbp-0x30]
	tarroot = (struct initargs) {
  41343f:	c7 45 d0 01 00 00 00 	mov    DWORD PTR [rbp-0x30],0x1
  413446:	89 55 d8             	mov    DWORD PTR [rbp-0x28],edx
	return args_lkup_entry(from, path, ent);
  413449:	4c 89 ea             	mov    rdx,r13
	tarroot = (struct initargs) {
  41344c:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax
	return args_lkup_entry(from, path, ent);
  413450:	e8 0b fc ff ff       	call   413060 <args_lkup_entry>
}
  413455:	48 83 c4 20          	add    rsp,0x20
  413459:	41 5c                	pop    r12
  41345b:	41 5d                	pop    r13
  41345d:	5d                   	pop    rbp
  41345e:	c3                   	ret    
	if (!tarent) return -1;
  41345f:	b8 ff ff ff ff       	mov    eax,0xffffffff
  413464:	eb b4                	jmp    41341a <args_get_entry+0x2a>
  413466:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41346d:	00 00 00 

0000000000413470 <args_get>:

char *
args_get(char *path)
{
  413470:	f3 0f 1e fa          	endbr64 
  413474:	55                   	push   rbp
	return args_lkup_entry(from, path, ent);
  413475:	48 89 fe             	mov    rsi,rdi
{
  413478:	48 89 e5             	mov    rbp,rsp
  41347b:	41 54                	push   r12
  41347d:	49 89 fc             	mov    r12,rdi
	return args_lkup_entry(from, path, ent);
  413480:	bf 20 60 42 00       	mov    edi,0x426020
  413485:	48 8d 55 b0          	lea    rdx,[rbp-0x50]
{
  413489:	48 83 ec 48          	sub    rsp,0x48
	return args_lkup_entry(from, path, ent);
  41348d:	e8 ce fb ff ff       	call   413060 <args_lkup_entry>
	if (!args_get_entry_from(path, &__initargs_root, ent)) return 0;
  413492:	85 c0                	test   eax,eax
  413494:	75 4a                	jne    4134e0 <args_get+0x70>
	switch (arg->type) {
  413496:	8b 45 b0             	mov    eax,DWORD PTR [rbp-0x50]
  413499:	85 c0                	test   eax,eax
  41349b:	74 23                	je     4134c0 <args_get+0x50>
  41349d:	83 f8 01             	cmp    eax,0x1
  4134a0:	74 0e                	je     4134b0 <args_get+0x40>
	struct initargs ent;

	if (args_get_entry(path, &ent)) return NULL;
  4134a2:	31 c0                	xor    eax,eax

	return args_value(&ent);
}
  4134a4:	4c 8b 65 f8          	mov    r12,QWORD PTR [rbp-0x8]
  4134a8:	c9                   	leave  
  4134a9:	c3                   	ret    
  4134aa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	case ARGS_IMPL_TAR: return tar_value(&arg->d.tar_ent);
  4134b0:	48 8d 7d b8          	lea    rdi,[rbp-0x48]
  4134b4:	e8 17 01 00 00       	call   4135d0 <tar_value>
}
  4134b9:	4c 8b 65 f8          	mov    r12,QWORD PTR [rbp-0x8]
  4134bd:	c9                   	leave  
  4134be:	c3                   	ret    
  4134bf:	90                   	nop
  4134c0:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
	if (!kv) return NULL;
  4134c4:	48 85 c0             	test   rax,rax
  4134c7:	74 d9                	je     4134a2 <args_get+0x32>
	switch (kv->vtype) {
  4134c9:	8b 50 08             	mov    edx,DWORD PTR [rax+0x8]
  4134cc:	85 d2                	test   edx,edx
  4134ce:	75 d2                	jne    4134a2 <args_get+0x32>
	case VTYPE_STR: return kv->val.str;
  4134d0:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
}
  4134d4:	4c 8b 65 f8          	mov    r12,QWORD PTR [rbp-0x8]
  4134d8:	c9                   	leave  
  4134d9:	c3                   	ret    
  4134da:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	tarent = tar_root();
  4134e0:	e8 7b 06 00 00       	call   413b60 <tar_root>
	if (!tarent) return -1;
  4134e5:	48 85 c0             	test   rax,rax
  4134e8:	74 ba                	je     4134a4 <args_get+0x34>
		.d.tar_ent = *tarent
  4134ea:	8b 10                	mov    edx,DWORD PTR [rax]
  4134ec:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	return args_lkup_entry(from, path, ent);
  4134f0:	4c 89 e6             	mov    rsi,r12
  4134f3:	48 8d 7d d0          	lea    rdi,[rbp-0x30]
	tarroot = (struct initargs) {
  4134f7:	c7 45 d0 01 00 00 00 	mov    DWORD PTR [rbp-0x30],0x1
  4134fe:	89 55 d8             	mov    DWORD PTR [rbp-0x28],edx
	return args_lkup_entry(from, path, ent);
  413501:	48 8d 55 b0          	lea    rdx,[rbp-0x50]
	tarroot = (struct initargs) {
  413505:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax
	return args_lkup_entry(from, path, ent);
  413509:	e8 52 fb ff ff       	call   413060 <args_lkup_entry>
	if (args_get_entry(path, &ent)) return NULL;
  41350e:	85 c0                	test   eax,eax
  413510:	75 90                	jne    4134a2 <args_get+0x32>
  413512:	eb 82                	jmp    413496 <args_get+0x26>
  413514:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41351b:	00 00 00 
  41351e:	66 90                	xchg   ax,ax

0000000000413520 <tar_key>:
	return r;
}

char *
tar_key(struct tar_entry *ent, int *str_len)
{
  413520:	f3 0f 1e fa          	endbr64 
  413524:	55                   	push   rbp
  413525:	48 89 f8             	mov    rax,rdi
  413528:	48 89 e5             	mov    rbp,rsp
  41352b:	41 55                	push   r13
  41352d:	49 89 f5             	mov    r13,rsi
  413530:	41 54                	push   r12
  413532:	53                   	push   rbx
  413533:	48 83 ec 18          	sub    rsp,0x18
	return tar_nesting(ent->nesting_lvl, ent->record->name, str_len);
  413537:	44 8b 20             	mov    r12d,DWORD PTR [rax]
  41353a:	48 8b 7f 08          	mov    rdi,QWORD PTR [rdi+0x8]
	for (i = 0 ; i < nesting_lvl ; i++) {
  41353e:	45 85 e4             	test   r12d,r12d
  413541:	7e 3d                	jle    413580 <tar_key+0x60>
  413543:	31 db                	xor    ebx,ebx
  413545:	eb 15                	jmp    41355c <tar_key+0x3c>
  413547:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41354e:	00 00 
  413550:	83 c3 01             	add    ebx,0x1
		key++;		/* one past the / */
  413553:	48 83 c7 01          	add    rdi,0x1
	for (i = 0 ; i < nesting_lvl ; i++) {
  413557:	41 39 dc             	cmp    r12d,ebx
  41355a:	74 24                	je     413580 <tar_key+0x60>
		key = strchr(key, '/');
  41355c:	be 2f 00 00 00       	mov    esi,0x2f
  413561:	e8 8a 3b 00 00       	call   4170f0 <strchr>
  413566:	48 89 c7             	mov    rdi,rax
		if (!key) return NULL;
  413569:	48 85 c0             	test   rax,rax
  41356c:	75 e2                	jne    413550 <tar_key+0x30>
}
  41356e:	48 83 c4 18          	add    rsp,0x18
  413572:	48 89 f8             	mov    rax,rdi
  413575:	5b                   	pop    rbx
  413576:	41 5c                	pop    r12
  413578:	41 5d                	pop    r13
  41357a:	5d                   	pop    rbp
  41357b:	c3                   	ret    
  41357c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	end = strchr(key, '/');
  413580:	be 2f 00 00 00       	mov    esi,0x2f
  413585:	48 89 7d d8          	mov    QWORD PTR [rbp-0x28],rdi
  413589:	e8 62 3b 00 00       	call   4170f0 <strchr>
	if (!end) *key_len = strlen(key);
  41358e:	48 8b 7d d8          	mov    rdi,QWORD PTR [rbp-0x28]
  413592:	48 85 c0             	test   rax,rax
  413595:	74 19                	je     4135b0 <tar_key+0x90>
	else      *key_len = end - key;
  413597:	48 29 f8             	sub    rax,rdi
  41359a:	41 89 45 00          	mov    DWORD PTR [r13+0x0],eax
}
  41359e:	48 83 c4 18          	add    rsp,0x18
  4135a2:	48 89 f8             	mov    rax,rdi
  4135a5:	5b                   	pop    rbx
  4135a6:	41 5c                	pop    r12
  4135a8:	41 5d                	pop    r13
  4135aa:	5d                   	pop    rbp
  4135ab:	c3                   	ret    
  4135ac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	if (!end) *key_len = strlen(key);
  4135b0:	e8 8b 3c 00 00       	call   417240 <strlen>
  4135b5:	48 8b 7d d8          	mov    rdi,QWORD PTR [rbp-0x28]
  4135b9:	41 89 45 00          	mov    DWORD PTR [r13+0x0],eax
}
  4135bd:	48 83 c4 18          	add    rsp,0x18
  4135c1:	5b                   	pop    rbx
  4135c2:	48 89 f8             	mov    rax,rdi
  4135c5:	41 5c                	pop    r12
  4135c7:	41 5d                	pop    r13
  4135c9:	5d                   	pop    rbp
  4135ca:	c3                   	ret    
  4135cb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000004135d0 <tar_value>:

char *
tar_value(struct tar_entry *ent)
{
  4135d0:	f3 0f 1e fa          	endbr64 
	if (!tar_valid(ent)) return NULL;
  4135d4:	45 31 c0             	xor    r8d,r8d
	return !(!ent || !ent->record || tar_end(ent->record));
  4135d7:	48 85 ff             	test   rdi,rdi
  4135da:	74 41                	je     41361d <tar_value+0x4d>
  4135dc:	4c 8b 47 08          	mov    r8,QWORD PTR [rdi+0x8]
  4135e0:	4d 85 c0             	test   r8,r8
  4135e3:	74 38                	je     41361d <tar_value+0x4d>
  4135e5:	4c 89 c0             	mov    rax,r8
  4135e8:	49 8d 90 00 04 00 00 	lea    rdx,[r8+0x400]
  4135ef:	eb 10                	jmp    413601 <tar_value+0x31>
  4135f1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  4135f8:	48 83 c0 01          	add    rax,0x1
  4135fc:	48 39 d0             	cmp    rax,rdx
  4135ff:	74 27                	je     413628 <tar_value+0x58>
		if (((char *)r)[i]) return 0;
  413601:	80 38 00             	cmp    BYTE PTR [rax],0x0
  413604:	74 f2                	je     4135f8 <tar_value+0x28>
	return *r->linkflag == '0' || *r->linkflag == '\0';
  413606:	41 0f b6 80 9c 00 00 	movzx  eax,BYTE PTR [r8+0x9c]
  41360d:	00 
	if (!tar_is_file(ent->record)) return NULL;
  41360e:	3c 30                	cmp    al,0x30
  413610:	74 04                	je     413616 <tar_value+0x46>
  413612:	84 c0                	test   al,al
  413614:	75 12                	jne    413628 <tar_value+0x58>

	return (char *)&ent->record[1];
  413616:	49 81 c0 00 02 00 00 	add    r8,0x200
}
  41361d:	4c 89 c0             	mov    rax,r8
  413620:	c3                   	ret    
  413621:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	if (!tar_valid(ent)) return NULL;
  413628:	45 31 c0             	xor    r8d,r8d
}
  41362b:	4c 89 c0             	mov    rax,r8
  41362e:	c3                   	ret    
  41362f:	90                   	nop

0000000000413630 <tar_value_sz>:

int
tar_value_sz(struct tar_entry *ent)
{
  413630:	f3 0f 1e fa          	endbr64 
	if (!tar_valid(ent)) return 0;
  413634:	45 31 c0             	xor    r8d,r8d
	return !(!ent || !ent->record || tar_end(ent->record));
  413637:	48 85 ff             	test   rdi,rdi
  41363a:	74 54                	je     413690 <tar_value_sz+0x60>
{
  41363c:	55                   	push   rbp
  41363d:	48 89 e5             	mov    rbp,rsp
  413640:	53                   	push   rbx
  413641:	48 83 ec 08          	sub    rsp,0x8
	return !(!ent || !ent->record || tar_end(ent->record));
  413645:	48 8b 5f 08          	mov    rbx,QWORD PTR [rdi+0x8]
  413649:	48 85 db             	test   rbx,rbx
  41364c:	74 32                	je     413680 <tar_value_sz+0x50>
  41364e:	48 89 d8             	mov    rax,rbx
  413651:	48 8d 93 00 04 00 00 	lea    rdx,[rbx+0x400]
  413658:	eb 0f                	jmp    413669 <tar_value_sz+0x39>
  41365a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  413660:	48 83 c0 01          	add    rax,0x1
  413664:	48 39 d0             	cmp    rax,rdx
  413667:	74 14                	je     41367d <tar_value_sz+0x4d>
		if (((char *)r)[i]) return 0;
  413669:	80 38 00             	cmp    BYTE PTR [rax],0x0
  41366c:	74 f2                	je     413660 <tar_value_sz+0x30>
	return *r->linkflag == '0' || *r->linkflag == '\0';
  41366e:	0f b6 83 9c 00 00 00 	movzx  eax,BYTE PTR [rbx+0x9c]
	if (!tar_is_file(ent->record)) return 0;
  413675:	3c 30                	cmp    al,0x30
  413677:	74 1f                	je     413698 <tar_value_sz+0x68>
  413679:	84 c0                	test   al,al
  41367b:	74 1b                	je     413698 <tar_value_sz+0x68>
	if (!tar_valid(ent)) return 0;
  41367d:	45 31 c0             	xor    r8d,r8d

	return oct2dec(ent->record->size);
}
  413680:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
  413684:	44 89 c0             	mov    eax,r8d
  413687:	c9                   	leave  
  413688:	c3                   	ret    
  413689:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  413690:	44 89 c0             	mov    eax,r8d
  413693:	c3                   	ret    
  413694:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	i = strnlen(oct, TAR_SZ) - 1;
  413698:	48 8d 7b 7c          	lea    rdi,[rbx+0x7c]
  41369c:	be 0c 00 00 00       	mov    esi,0xc
  4136a1:	e8 9a 3c 00 00       	call   417340 <strnlen>
  4136a6:	8d 50 ff             	lea    edx,[rax-0x1]
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  4136a9:	85 c0                	test   eax,eax
  4136ab:	74 d0                	je     41367d <tar_value_sz+0x4d>
  4136ad:	48 63 d2             	movsxd rdx,edx
  4136b0:	45 31 c0             	xor    r8d,r8d
  4136b3:	b9 01 00 00 00       	mov    ecx,0x1
  4136b8:	eb 1a                	jmp    4136d4 <tar_value_sz+0xa4>
  4136ba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
		tot = tot + (val * base);
  4136c0:	0f b6 c0             	movzx  eax,al
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  4136c3:	48 83 ea 01          	sub    rdx,0x1
		tot = tot + (val * base);
  4136c7:	0f af c1             	imul   eax,ecx
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  4136ca:	c1 e1 03             	shl    ecx,0x3
		tot = tot + (val * base);
  4136cd:	41 01 c0             	add    r8d,eax
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  4136d0:	85 d2                	test   edx,edx
  4136d2:	78 ac                	js     413680 <tar_value_sz+0x50>
		if (val > '7' || val < '0') return -1;
  4136d4:	0f b6 44 13 7c       	movzx  eax,BYTE PTR [rbx+rdx*1+0x7c]
  4136d9:	83 e8 30             	sub    eax,0x30
  4136dc:	3c 07                	cmp    al,0x7
  4136de:	76 e0                	jbe    4136c0 <tar_value_sz+0x90>
	if (i == TAR_RECORD_SIZE) return -1;
  4136e0:	41 b8 ff ff ff ff    	mov    r8d,0xffffffff
  4136e6:	eb 98                	jmp    413680 <tar_value_sz+0x50>
  4136e8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4136ef:	00 

00000000004136f0 <tar_is_value>:

int
tar_is_value(struct tar_entry *ent)
{
  4136f0:	f3 0f 1e fa          	endbr64 
	if (!tar_valid(ent)) return 0;
  4136f4:	31 c0                	xor    eax,eax
	return !(!ent || !ent->record || tar_end(ent->record));
  4136f6:	48 85 ff             	test   rdi,rdi
  4136f9:	74 3a                	je     413735 <tar_is_value+0x45>
  4136fb:	48 8b 4f 08          	mov    rcx,QWORD PTR [rdi+0x8]
  4136ff:	48 85 c9             	test   rcx,rcx
  413702:	74 31                	je     413735 <tar_is_value+0x45>
  413704:	48 89 c8             	mov    rax,rcx
  413707:	48 8d 91 00 04 00 00 	lea    rdx,[rcx+0x400]
  41370e:	eb 09                	jmp    413719 <tar_is_value+0x29>
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  413710:	48 83 c0 01          	add    rax,0x1
  413714:	48 39 d0             	cmp    rax,rdx
  413717:	74 27                	je     413740 <tar_is_value+0x50>
		if (((char *)r)[i]) return 0;
  413719:	80 38 00             	cmp    BYTE PTR [rax],0x0
  41371c:	74 f2                	je     413710 <tar_is_value+0x20>
	return *r->linkflag == '0' || *r->linkflag == '\0';
  41371e:	0f b6 91 9c 00 00 00 	movzx  edx,BYTE PTR [rcx+0x9c]
  413725:	80 fa 30             	cmp    dl,0x30
  413728:	0f 94 c0             	sete   al
  41372b:	84 d2                	test   dl,dl
  41372d:	0f 94 c2             	sete   dl
  413730:	09 d0                	or     eax,edx
  413732:	0f b6 c0             	movzx  eax,al

	return tar_is_file(ent->record);
}
  413735:	c3                   	ret    
  413736:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41373d:	00 00 00 
	if (!tar_valid(ent)) return 0;
  413740:	31 c0                	xor    eax,eax
  413742:	c3                   	ret    
  413743:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41374a:	00 00 00 00 
  41374e:	66 90                	xchg   ax,ax

0000000000413750 <tar_iter_next>:

int
tar_iter_next(struct tar_iter *i, struct tar_entry *next)
{
  413750:	f3 0f 1e fa          	endbr64 
  413754:	55                   	push   rbp
  413755:	48 89 e5             	mov    rbp,rsp
  413758:	41 57                	push   r15
  41375a:	41 56                	push   r14
  41375c:	41 55                	push   r13
  41375e:	41 54                	push   r12
  413760:	53                   	push   rbx
  413761:	48 83 ec 28          	sub    rsp,0x28
  413765:	48 89 75 c8          	mov    QWORD PTR [rbp-0x38],rsi
	struct tar_record *r;

	if (!i || !tar_valid(&i->entry)) return 0;
  413769:	48 85 ff             	test   rdi,rdi
  41376c:	0f 84 ee 00 00 00    	je     413860 <tar_iter_next+0x110>
	return !(!ent || !ent->record || tar_end(ent->record));
  413772:	4c 8b 67 08          	mov    r12,QWORD PTR [rdi+0x8]
  413776:	49 89 fe             	mov    r14,rdi
	if (!i || !tar_valid(&i->entry)) return 0;
  413779:	31 c0                	xor    eax,eax
	return !(!ent || !ent->record || tar_end(ent->record));
  41377b:	4d 85 e4             	test   r12,r12
  41377e:	0f 84 de 00 00 00    	je     413862 <tar_iter_next+0x112>
  413784:	4d 8d ac 24 00 04 00 	lea    r13,[r12+0x400]
  41378b:	00 
  41378c:	4c 89 e0             	mov    rax,r12
  41378f:	eb 14                	jmp    4137a5 <tar_iter_next+0x55>
  413791:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  413798:	48 83 c0 01          	add    rax,0x1
  41379c:	4c 39 e8             	cmp    rax,r13
  41379f:	0f 84 bb 00 00 00    	je     413860 <tar_iter_next+0x110>
		if (((char *)r)[i]) return 0;
  4137a5:	80 38 00             	cmp    BYTE PTR [rax],0x0
  4137a8:	74 ee                	je     413798 <tar_iter_next+0x48>
  4137aa:	4c 89 e0             	mov    rax,r12
  4137ad:	eb 0e                	jmp    4137bd <tar_iter_next+0x6d>
  4137af:	90                   	nop
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  4137b0:	48 83 c0 01          	add    rax,0x1
  4137b4:	4c 39 e8             	cmp    rax,r13
  4137b7:	0f 84 a3 00 00 00    	je     413860 <tar_iter_next+0x110>
		if (((char *)r)[i]) return 0;
  4137bd:	80 38 00             	cmp    BYTE PTR [rax],0x0
  4137c0:	74 ee                	je     4137b0 <tar_iter_next+0x60>
	if (!tar_valid(path) || iter == NULL || *iter == NULL) return NULL;
  4137c2:	4d 8b 7e 10          	mov    r15,QWORD PTR [r14+0x10]
  4137c6:	4d 85 ff             	test   r15,r15
  4137c9:	0f 84 91 00 00 00    	je     413860 <tar_iter_next+0x110>
  4137cf:	90                   	nop
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  4137d0:	4c 89 fb             	mov    rbx,r15
  4137d3:	4d 8d 8f 00 04 00 00 	lea    r9,[r15+0x400]
  4137da:	4c 89 f8             	mov    rax,r15
  4137dd:	eb 0a                	jmp    4137e9 <tar_iter_next+0x99>
  4137df:	90                   	nop
  4137e0:	48 83 c0 01          	add    rax,0x1
  4137e4:	49 39 c1             	cmp    r9,rax
  4137e7:	74 57                	je     413840 <tar_iter_next+0xf0>
		if (((char *)r)[i]) return 0;
  4137e9:	80 38 00             	cmp    BYTE PTR [rax],0x0
  4137ec:	74 f2                	je     4137e0 <tar_iter_next+0x90>
  4137ee:	4c 89 e0             	mov    rax,r12
  4137f1:	eb 12                	jmp    413805 <tar_iter_next+0xb5>
  4137f3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  4137f8:	48 83 c0 01          	add    rax,0x1
  4137fc:	4c 39 e8             	cmp    rax,r13
  4137ff:	0f 84 7c 00 00 00    	je     413881 <tar_iter_next+0x131>
		if (((char *)r)[i]) return 0;
  413805:	80 38 00             	cmp    BYTE PTR [rax],0x0
  413808:	74 ee                	je     4137f8 <tar_iter_next+0xa8>
	if (ent->nesting_lvl == 0) {
  41380a:	41 8b 06             	mov    eax,DWORD PTR [r14]
	end = strchr(key, '/');
  41380d:	be 2f 00 00 00       	mov    esi,0x2f
  413812:	4c 89 ff             	mov    rdi,r15
  413815:	4c 89 4d c0          	mov    QWORD PTR [rbp-0x40],r9
	if (ent->nesting_lvl == 0) {
  413819:	89 45 b4             	mov    DWORD PTR [rbp-0x4c],eax
	end = strchr(key, '/');
  41381c:	e8 cf 38 00 00       	call   4170f0 <strchr>
	if (ent->nesting_lvl == 0) {
  413821:	8b 55 b4             	mov    edx,DWORD PTR [rbp-0x4c]
  413824:	4c 8b 4d c0          	mov    r9,QWORD PTR [rbp-0x40]
  413828:	85 d2                	test   edx,edx
  41382a:	0f 85 65 01 00 00    	jne    413995 <tar_iter_next+0x245>
	return !((cmp == 0) && (end == NULL || end[1] == '\0'));
  413830:	48 85 c0             	test   rax,rax
  413833:	74 0b                	je     413840 <tar_iter_next+0xf0>
  413835:	80 78 01 00          	cmp    BYTE PTR [rax+0x1],0x0
  413839:	75 46                	jne    413881 <tar_iter_next+0x131>
  41383b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  413840:	4c 89 f8             	mov    rax,r15
  413843:	eb 0c                	jmp    413851 <tar_iter_next+0x101>
  413845:	0f 1f 00             	nop    DWORD PTR [rax]
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  413848:	48 83 c0 01          	add    rax,0x1
  41384c:	49 39 c1             	cmp    r9,rax
  41384f:	74 0f                	je     413860 <tar_iter_next+0x110>
		if (((char *)r)[i]) return 0;
  413851:	80 38 00             	cmp    BYTE PTR [rax],0x0
  413854:	74 f2                	je     413848 <tar_iter_next+0xf8>
  413856:	e9 9a 00 00 00       	jmp    4138f5 <tar_iter_next+0x1a5>
  41385b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	if (!i || !tar_valid(&i->entry)) return 0;
  413860:	31 c0                	xor    eax,eax

	next->nesting_lvl = i->entry.nesting_lvl;
	next->record = r;

	return 1;
}
  413862:	48 83 c4 28          	add    rsp,0x28
  413866:	5b                   	pop    rbx
  413867:	41 5c                	pop    r12
  413869:	41 5d                	pop    r13
  41386b:	41 5e                	pop    r14
  41386d:	41 5f                	pop    r15
  41386f:	5d                   	pop    rbp
  413870:	c3                   	ret    
  413871:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  413878:	48 83 c3 01          	add    rbx,0x1
  41387c:	49 39 d9             	cmp    r9,rbx
  41387f:	74 df                	je     413860 <tar_iter_next+0x110>
		if (((char *)r)[i]) return 0;
  413881:	80 3b 00             	cmp    BYTE PTR [rbx],0x0
  413884:	74 f2                	je     413878 <tar_iter_next+0x128>
	i = strnlen(oct, TAR_SZ) - 1;
  413886:	49 8d 7f 7c          	lea    rdi,[r15+0x7c]
  41388a:	be 0c 00 00 00       	mov    esi,0xc
  41388f:	e8 ac 3a 00 00       	call   417340 <strnlen>
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  413894:	31 ff                	xor    edi,edi
  413896:	be 01 00 00 00       	mov    esi,0x1
	i = strnlen(oct, TAR_SZ) - 1;
  41389b:	83 e8 01             	sub    eax,0x1
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  41389e:	48 63 d0             	movsxd rdx,eax
  4138a1:	83 f8 ff             	cmp    eax,0xffffffff
  4138a4:	75 21                	jne    4138c7 <tar_iter_next+0x177>
  4138a6:	eb 2c                	jmp    4138d4 <tar_iter_next+0x184>
  4138a8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4138af:	00 
		tot = tot + (val * base);
  4138b0:	0f b6 c0             	movzx  eax,al
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  4138b3:	48 83 ea 01          	sub    rdx,0x1
		tot = tot + (val * base);
  4138b7:	0f af c6             	imul   eax,esi
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  4138ba:	c1 e6 03             	shl    esi,0x3
		tot = tot + (val * base);
  4138bd:	01 c7                	add    edi,eax
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  4138bf:	85 d2                	test   edx,edx
  4138c1:	0f 88 b1 00 00 00    	js     413978 <tar_iter_next+0x228>
		if (val > '7' || val < '0') return -1;
  4138c7:	41 0f b6 44 17 7c    	movzx  eax,BYTE PTR [r15+rdx*1+0x7c]
  4138cd:	83 e8 30             	sub    eax,0x30
  4138d0:	3c 07                	cmp    al,0x7
  4138d2:	76 dc                	jbe    4138b0 <tar_iter_next+0x160>
  4138d4:	b8 00 02 00 00       	mov    eax,0x200
	return &r[n_records + 1];
  4138d9:	49 01 c7             	add    r15,rax
	for (r = *iter; r && !tar_end(r) && tar_pathcmp(path, r->name); r = tar_next_record(r)) ;
  4138dc:	e9 ef fe ff ff       	jmp    4137d0 <tar_iter_next+0x80>
  4138e1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  4138e8:	48 83 c3 01          	add    rbx,0x1
  4138ec:	49 39 d9             	cmp    r9,rbx
  4138ef:	0f 84 45 01 00 00    	je     413a3a <tar_iter_next+0x2ea>
		if (((char *)r)[i]) return 0;
  4138f5:	80 3b 00             	cmp    BYTE PTR [rbx],0x0
  4138f8:	74 ee                	je     4138e8 <tar_iter_next+0x198>
	i = strnlen(oct, TAR_SZ) - 1;
  4138fa:	be 0c 00 00 00       	mov    esi,0xc
  4138ff:	49 8d 7f 7c          	lea    rdi,[r15+0x7c]
  413903:	e8 38 3a 00 00       	call   417340 <strnlen>
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  413908:	31 f6                	xor    esi,esi
  41390a:	b9 01 00 00 00       	mov    ecx,0x1
	i = strnlen(oct, TAR_SZ) - 1;
  41390f:	83 e8 01             	sub    eax,0x1
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  413912:	48 63 d0             	movsxd rdx,eax
  413915:	83 f8 ff             	cmp    eax,0xffffffff
  413918:	75 1d                	jne    413937 <tar_iter_next+0x1e7>
  41391a:	eb 28                	jmp    413944 <tar_iter_next+0x1f4>
  41391c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		tot = tot + (val * base);
  413920:	0f b6 c0             	movzx  eax,al
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  413923:	48 83 ea 01          	sub    rdx,0x1
		tot = tot + (val * base);
  413927:	0f af c1             	imul   eax,ecx
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  41392a:	c1 e1 03             	shl    ecx,0x3
		tot = tot + (val * base);
  41392d:	01 c6                	add    esi,eax
	for (base = 1, tot = 0; i >= 0; i--, base *= 8) {
  41392f:	85 d2                	test   edx,edx
  413931:	0f 88 e9 00 00 00    	js     413a20 <tar_iter_next+0x2d0>
		if (val > '7' || val < '0') return -1;
  413937:	41 0f b6 44 17 7c    	movzx  eax,BYTE PTR [r15+rdx*1+0x7c]
  41393d:	83 e8 30             	sub    eax,0x30
  413940:	3c 07                	cmp    al,0x7
  413942:	76 dc                	jbe    413920 <tar_iter_next+0x1d0>
  413944:	b8 00 02 00 00       	mov    eax,0x200
	return &r[n_records + 1];
  413949:	4c 01 f8             	add    rax,r15
	*iter = tar_next_record(r);
  41394c:	49 89 46 10          	mov    QWORD PTR [r14+0x10],rax
	next->nesting_lvl = i->entry.nesting_lvl;
  413950:	48 8b 4d c8          	mov    rcx,QWORD PTR [rbp-0x38]
  413954:	41 8b 06             	mov    eax,DWORD PTR [r14]
	next->record = r;
  413957:	4c 89 79 08          	mov    QWORD PTR [rcx+0x8],r15
	next->nesting_lvl = i->entry.nesting_lvl;
  41395b:	89 01                	mov    DWORD PTR [rcx],eax
}
  41395d:	48 83 c4 28          	add    rsp,0x28
	return 1;
  413961:	b8 01 00 00 00       	mov    eax,0x1
}
  413966:	5b                   	pop    rbx
  413967:	41 5c                	pop    r12
  413969:	41 5d                	pop    r13
  41396b:	41 5e                	pop    r14
  41396d:	41 5f                	pop    r15
  41396f:	5d                   	pop    rbp
  413970:	c3                   	ret    
  413971:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	n_records = round_up_to_pow2(sz, TAR_RECORD_SIZE) / TAR_RECORD_SIZE;
  413978:	48 63 ff             	movsxd rdi,edi
  41397b:	48 81 c7 ff 01 00 00 	add    rdi,0x1ff
	return &r[n_records + 1];
  413982:	48 81 e7 00 fe ff ff 	and    rdi,0xfffffffffffffe00
  413989:	48 8d 87 00 02 00 00 	lea    rax,[rdi+0x200]
  413990:	e9 44 ff ff ff       	jmp    4138d9 <tar_iter_next+0x189>
	for (i = 0 ; i < nesting_lvl ; i++) {
  413995:	0f 8e a6 00 00 00    	jle    413a41 <tar_iter_next+0x2f1>
  41399b:	4d 89 fa             	mov    r10,r15
  41399e:	31 d2                	xor    edx,edx
		key = strchr(key, '/');
  4139a0:	be 2f 00 00 00       	mov    esi,0x2f
  4139a5:	4c 89 d7             	mov    rdi,r10
  4139a8:	4c 89 4d c0          	mov    QWORD PTR [rbp-0x40],r9
  4139ac:	89 55 b8             	mov    DWORD PTR [rbp-0x48],edx
  4139af:	e8 3c 37 00 00       	call   4170f0 <strchr>
		if (!key) return NULL;
  4139b4:	4c 8b 4d c0          	mov    r9,QWORD PTR [rbp-0x40]
  4139b8:	48 85 c0             	test   rax,rax
  4139bb:	0f 84 c0 fe ff ff    	je     413881 <tar_iter_next+0x131>
	for (i = 0 ; i < nesting_lvl ; i++) {
  4139c1:	8b 55 b8             	mov    edx,DWORD PTR [rbp-0x48]
		key++;		/* one past the / */
  4139c4:	4c 8d 50 01          	lea    r10,[rax+0x1]
	for (i = 0 ; i < nesting_lvl ; i++) {
  4139c8:	83 c2 01             	add    edx,0x1
  4139cb:	39 55 b4             	cmp    DWORD PTR [rbp-0x4c],edx
  4139ce:	75 d0                	jne    4139a0 <tar_iter_next+0x250>
	if (*key == '\0') return 1; /* if we have the actual directory, avoid it */
  4139d0:	80 78 01 00          	cmp    BYTE PTR [rax+0x1],0x0
  4139d4:	0f 84 a7 fe ff ff    	je     413881 <tar_iter_next+0x131>
	len = (int)(key - path);
  4139da:	4c 89 d2             	mov    rdx,r10
	cmp = strncmp(p, path, len);
  4139dd:	4c 89 fe             	mov    rsi,r15
  4139e0:	4c 89 e7             	mov    rdi,r12
  4139e3:	4c 89 4d b8          	mov    QWORD PTR [rbp-0x48],r9
	len = (int)(key - path);
  4139e7:	4c 29 fa             	sub    rdx,r15
  4139ea:	4c 89 55 c0          	mov    QWORD PTR [rbp-0x40],r10
  4139ee:	48 63 d2             	movsxd rdx,edx
	cmp = strncmp(p, path, len);
  4139f1:	e8 ca 38 00 00       	call   4172c0 <strncmp>
	return !((cmp == 0) && (end == NULL || end[1] == '\0'));
  4139f6:	4c 8b 55 c0          	mov    r10,QWORD PTR [rbp-0x40]
  4139fa:	4c 8b 4d b8          	mov    r9,QWORD PTR [rbp-0x48]
  4139fe:	85 c0                	test   eax,eax
  413a00:	0f 85 7b fe ff ff    	jne    413881 <tar_iter_next+0x131>
	end = strchr(key, '/');
  413a06:	be 2f 00 00 00       	mov    esi,0x2f
  413a0b:	4c 89 d7             	mov    rdi,r10
  413a0e:	4c 89 4d c0          	mov    QWORD PTR [rbp-0x40],r9
  413a12:	e8 d9 36 00 00       	call   4170f0 <strchr>
  413a17:	4c 8b 4d c0          	mov    r9,QWORD PTR [rbp-0x40]
  413a1b:	e9 10 fe ff ff       	jmp    413830 <tar_iter_next+0xe0>
	n_records = round_up_to_pow2(sz, TAR_RECORD_SIZE) / TAR_RECORD_SIZE;
  413a20:	48 63 c6             	movsxd rax,esi
  413a23:	48 05 ff 01 00 00    	add    rax,0x1ff
	return &r[n_records + 1];
  413a29:	48 25 00 fe ff ff    	and    rax,0xfffffffffffffe00
  413a2f:	48 05 00 02 00 00    	add    rax,0x200
  413a35:	e9 0f ff ff ff       	jmp    413949 <tar_iter_next+0x1f9>
	if (tar_end(r)) return NULL;
  413a3a:	31 c0                	xor    eax,eax
  413a3c:	e9 0b ff ff ff       	jmp    41394c <tar_iter_next+0x1fc>
	if (*key == '\0') return 1; /* if we have the actual directory, avoid it */
  413a41:	41 80 3f 00          	cmp    BYTE PTR [r15],0x0
  413a45:	0f 85 e5 fd ff ff    	jne    413830 <tar_iter_next+0xe0>
  413a4b:	e9 31 fe ff ff       	jmp    413881 <tar_iter_next+0x131>

0000000000413a50 <tar_iter>:
 * assumptions is wrong, we will skip all of those entries in a
 * directory that come *before* the directory record.
 */
int
tar_iter(struct tar_entry *ent, struct tar_iter *i, struct tar_entry *first)
{
  413a50:	f3 0f 1e fa          	endbr64 
  413a54:	49 89 f8             	mov    r8,rdi
  413a57:	48 89 f7             	mov    rdi,rsi
	return !(!ent || !ent->record || tar_end(ent->record));
  413a5a:	4d 85 c0             	test   r8,r8
  413a5d:	74 30                	je     413a8f <tar_iter+0x3f>
  413a5f:	49 8b 70 08          	mov    rsi,QWORD PTR [r8+0x8]
  413a63:	48 85 f6             	test   rsi,rsi
  413a66:	74 27                	je     413a8f <tar_iter+0x3f>
  413a68:	48 89 f0             	mov    rax,rsi
  413a6b:	48 8d 8e 00 04 00 00 	lea    rcx,[rsi+0x400]
  413a72:	eb 0d                	jmp    413a81 <tar_iter+0x31>
  413a74:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  413a78:	48 83 c0 01          	add    rax,0x1
  413a7c:	48 39 c1             	cmp    rcx,rax
  413a7f:	74 0e                	je     413a8f <tar_iter+0x3f>
		if (((char *)r)[i]) return 0;
  413a81:	80 38 00             	cmp    BYTE PTR [rax],0x0
  413a84:	74 f2                	je     413a78 <tar_iter+0x28>
	if (!tar_valid(ent)) return 0;
	if (!tar_is_dir(ent->record)) return 0;
  413a86:	80 be 9c 00 00 00 35 	cmp    BYTE PTR [rsi+0x9c],0x35
  413a8d:	74 09                	je     413a98 <tar_iter+0x48>
	i->entry    = *ent;
	i->iter_rec = ent->record;
	i->entry.nesting_lvl++;	/* look *in* the entry */

	return tar_iter_next(i, first);
}
  413a8f:	31 c0                	xor    eax,eax
  413a91:	c3                   	ret    
  413a92:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	i->entry    = *ent;
  413a98:	f3 41 0f 6f 00       	movdqu xmm0,XMMWORD PTR [r8]
	return tar_iter_next(i, first);
  413a9d:	48 89 d6             	mov    rsi,rdx
	i->entry    = *ent;
  413aa0:	0f 11 07             	movups XMMWORD PTR [rdi],xmm0
	i->iter_rec = ent->record;
  413aa3:	49 8b 40 08          	mov    rax,QWORD PTR [r8+0x8]
	i->entry.nesting_lvl++;	/* look *in* the entry */
  413aa7:	83 07 01             	add    DWORD PTR [rdi],0x1
	i->iter_rec = ent->record;
  413aaa:	48 89 47 10          	mov    QWORD PTR [rdi+0x10],rax
	return tar_iter_next(i, first);
  413aae:	e9 9d fc ff ff       	jmp    413750 <tar_iter_next>
  413ab3:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  413aba:	00 00 00 00 
  413abe:	66 90                	xchg   ax,ax

0000000000413ac0 <tar_len>:

int
tar_len(struct tar_entry *start)
{
  413ac0:	f3 0f 1e fa          	endbr64 
  413ac4:	55                   	push   rbp
  413ac5:	48 89 e5             	mov    rbp,rsp
  413ac8:	41 54                	push   r12
  413aca:	48 83 ec 38          	sub    rsp,0x38
	return !(!ent || !ent->record || tar_end(ent->record));
  413ace:	48 85 ff             	test   rdi,rdi
  413ad1:	74 34                	je     413b07 <tar_len+0x47>
  413ad3:	48 8b 4f 08          	mov    rcx,QWORD PTR [rdi+0x8]
  413ad7:	48 85 c9             	test   rcx,rcx
  413ada:	74 2b                	je     413b07 <tar_len+0x47>
  413adc:	48 89 c8             	mov    rax,rcx
  413adf:	48 8d 91 00 04 00 00 	lea    rdx,[rcx+0x400]
  413ae6:	eb 11                	jmp    413af9 <tar_len+0x39>
  413ae8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  413aef:	00 
	for (i = 0; i < TAR_RECORD_SIZE * 2; i++) {
  413af0:	48 83 c0 01          	add    rax,0x1
  413af4:	48 39 d0             	cmp    rax,rdx
  413af7:	74 0e                	je     413b07 <tar_len+0x47>
		if (((char *)r)[i]) return 0;
  413af9:	80 38 00             	cmp    BYTE PTR [rax],0x0
  413afc:	74 f2                	je     413af0 <tar_len+0x30>
	if (!tar_is_dir(ent->record)) return 0;
  413afe:	80 b9 9c 00 00 00 35 	cmp    BYTE PTR [rcx+0x9c],0x35
  413b05:	74 0c                	je     413b13 <tar_len+0x53>
	int cont = 0, cnt = 0;
	struct tar_iter i;
	struct tar_entry entry;	/* data placed in here; don't care about it for calculating len */
	for (cont = tar_iter(start, &i, &entry); cont ; cont = tar_iter_next(&i, &entry)) {
  413b07:	45 31 e4             	xor    r12d,r12d
		cnt++;
	}

	return cnt;
}
  413b0a:	44 89 e0             	mov    eax,r12d
  413b0d:	4c 8b 65 f8          	mov    r12,QWORD PTR [rbp-0x8]
  413b11:	c9                   	leave  
  413b12:	c3                   	ret    
	i->entry    = *ent;
  413b13:	f3 0f 6f 07          	movdqu xmm0,XMMWORD PTR [rdi]
	return tar_iter_next(i, first);
  413b17:	48 8d 75 c0          	lea    rsi,[rbp-0x40]
  413b1b:	48 8d 7d d0          	lea    rdi,[rbp-0x30]
	i->iter_rec = ent->record;
  413b1f:	48 89 4d e0          	mov    QWORD PTR [rbp-0x20],rcx
	i->entry    = *ent;
  413b23:	0f 29 45 d0          	movaps XMMWORD PTR [rbp-0x30],xmm0
	i->entry.nesting_lvl++;	/* look *in* the entry */
  413b27:	83 45 d0 01          	add    DWORD PTR [rbp-0x30],0x1
	return tar_iter_next(i, first);
  413b2b:	e8 20 fc ff ff       	call   413750 <tar_iter_next>
	for (cont = tar_iter(start, &i, &entry); cont ; cont = tar_iter_next(&i, &entry)) {
  413b30:	85 c0                	test   eax,eax
  413b32:	74 d3                	je     413b07 <tar_len+0x47>
  413b34:	45 31 e4             	xor    r12d,r12d
  413b37:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  413b3e:	00 00 
  413b40:	48 8d 75 c0          	lea    rsi,[rbp-0x40]
  413b44:	48 8d 7d d0          	lea    rdi,[rbp-0x30]
		cnt++;
  413b48:	41 83 c4 01          	add    r12d,0x1
	for (cont = tar_iter(start, &i, &entry); cont ; cont = tar_iter_next(&i, &entry)) {
  413b4c:	e8 ff fb ff ff       	call   413750 <tar_iter_next>
  413b51:	85 c0                	test   eax,eax
  413b53:	75 eb                	jne    413b40 <tar_len+0x80>
  413b55:	eb b3                	jmp    413b0a <tar_len+0x4a>
  413b57:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  413b5e:	00 00 

0000000000413b60 <tar_root>:
	return (unsigned int)((char *)_binary_crt_init_tar_end - (char *)_binary_crt_init_tar_start);
}

struct tar_entry *
tar_root(void)
{
  413b60:	f3 0f 1e fa          	endbr64 
	if ((char *)_binary_crt_init_tar_end - (char *)_binary_crt_init_tar_start < 512) return NULL;
  413b64:	b8 e0 9a 70 00       	mov    eax,0x709ae0
  413b69:	ba 00 00 00 00       	mov    edx,0x0
  413b6e:	48 2d e1 9a 70 00    	sub    rax,0x709ae1
  413b74:	48 3d ff 01 00 00    	cmp    rax,0x1ff
  413b7a:	b8 a0 c0 5b 00       	mov    eax,0x5bc0a0
  413b7f:	48 0f 4e c2          	cmovle rax,rdx

	return &__tar_root;
}
  413b83:	c3                   	ret    
  413b84:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  413b8b:	00 00 00 
  413b8e:	66 90                	xchg   ax,ax

0000000000413b90 <slm_sched_fprr_execution>:
struct runqueue threads[NUM_CPU];

/* No RR based on execution, yet */
void
slm_sched_fprr_execution(struct slm_thd *t, cycles_t cycles)
{ return; }
  413b90:	f3 0f 1e fa          	endbr64 
  413b94:	c3                   	ret    
  413b95:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  413b9c:	00 00 00 00 

0000000000413ba0 <slm_sched_fprr_schedule>:
	}
}

struct slm_thd *
slm_sched_fprr_schedule(void)
{
  413ba0:	f3 0f 1e fa          	endbr64 
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  413ba4:	0f 01 f9             	rdtscp 
	int i;
	struct slm_sched_thd *t;
	struct ps_list_head *prios = threads[cos_cpuid()].prio;
  413ba7:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  413bad:	48 c1 e1 09          	shl    rcx,0x9
  413bb1:	48 8d 81 00 9b 70 00 	lea    rax,[rcx+0x709b00]
  413bb8:	48 8d 91 00 9d 70 00 	lea    rdx,[rcx+0x709d00]
ps_list_head_init(struct ps_list_head *lh)
{ ps_list_ll_init(&lh->l); }

static inline int
ps_list_ll_empty(struct ps_list *l)
{ return l->n == l; }
  413bbf:	48 8b 38             	mov    rdi,QWORD PTR [rax]
#if ENABLE_DEBUG_INFO
	debug_dump_info();
#endif

	for (i = 0 ; i < SLM_FPRR_NPRIOS ; i++) {
		if (ps_list_head_empty(&prios[i])) continue;
  413bc2:	48 39 f8             	cmp    rax,rdi
  413bc5:	74 41                	je     413c08 <slm_sched_fprr_schedule+0x68>
}

static inline void
ps_list_ll_rem(struct ps_list *l)
{
	l->n->p = l->p;
  413bc7:	48 8b 0f             	mov    rcx,QWORD PTR [rdi]
  413bca:	48 8b 57 08          	mov    rdx,QWORD PTR [rdi+0x8]
	l->p->n = l->n;
	l->p = l->n = l;
  413bce:	66 48 0f 6e c7       	movq   xmm0,rdi
  413bd3:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
	l->n->p = l->p;
  413bd7:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
	l->p->n = l->n;
  413bdb:	48 89 0a             	mov    QWORD PTR [rdx],rcx
	l->p = l->n = l;
  413bde:	0f 11 07             	movups XMMWORD PTR [rdi],xmm0
		/*
		 * We want to move the selected thread to the back of the list.
		 * Otherwise fprr won't be truly round robin
		 */
		ps_list_rem_d(t);
		ps_list_head_append_d(&prios[i], t);
  413be1:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	new->n    = l->n;
  413be5:	f3 0f 7e 00          	movq   xmm0,QWORD PTR [rax]
  413be9:	66 48 0f 6e c8       	movq   xmm1,rax
  413bee:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  413bf2:	0f 11 07             	movups XMMWORD PTR [rdi],xmm0
	l->n      = new;
  413bf5:	48 89 38             	mov    QWORD PTR [rax],rdi
	new->n->p = new;
  413bf8:	48 8b 07             	mov    rax,QWORD PTR [rdi]
  413bfb:	48 89 78 08          	mov    QWORD PTR [rax+0x8],rdi

//		printc("Schedule -> %ld\n", slm_thd_from_sched(t)->tid);
		return slm_thd_from_sched(t);
  413bff:	e9 fc dd fe ff       	jmp    401a00 <slm_thd_from_sched>
  413c04:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	for (i = 0 ; i < SLM_FPRR_NPRIOS ; i++) {
  413c08:	48 83 c0 10          	add    rax,0x10
  413c0c:	48 39 c2             	cmp    rdx,rax
  413c0f:	75 ae                	jne    413bbf <slm_sched_fprr_schedule+0x1f>
	}
//	printc("Schedule -> idle\n");

	return NULL;
}
  413c11:	31 c0                	xor    eax,eax
  413c13:	c3                   	ret    
  413c14:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  413c1b:	00 00 00 00 
  413c1f:	90                   	nop

0000000000413c20 <slm_sched_fprr_block>:

int
slm_sched_fprr_block(struct slm_thd *t)
{
  413c20:	f3 0f 1e fa          	endbr64 
  413c24:	55                   	push   rbp
  413c25:	48 89 e5             	mov    rbp,rsp
	struct slm_sched_thd *p = slm_thd_sched_policy(t);
  413c28:	e8 b3 dd fe ff       	call   4019e0 <slm_thd_sched_policy>
	l->n->p = l->p;
  413c2d:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  413c30:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
	l->p = l->n = l;
  413c34:	66 48 0f 6e c0       	movq   xmm0,rax
  413c39:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
	l->n->p = l->p;
  413c3d:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
	l->p->n = l->n;
  413c41:	48 89 0a             	mov    QWORD PTR [rdx],rcx
	l->p = l->n = l;
  413c44:	0f 11 00             	movups XMMWORD PTR [rax],xmm0

	ps_list_rem_d(p);

	return 0;
}
  413c47:	31 c0                	xor    eax,eax
  413c49:	5d                   	pop    rbp
  413c4a:	c3                   	ret    
  413c4b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000413c50 <slm_sched_fprr_wakeup>:

int
slm_sched_fprr_wakeup(struct slm_thd *t)
{
  413c50:	f3 0f 1e fa          	endbr64 
  413c54:	55                   	push   rbp
  413c55:	48 89 e5             	mov    rbp,rsp
  413c58:	53                   	push   rbx
  413c59:	48 89 fb             	mov    rbx,rdi
  413c5c:	48 83 ec 08          	sub    rsp,0x8
	struct slm_sched_thd *p = slm_thd_sched_policy(t);
  413c60:	e8 7b dd fe ff       	call   4019e0 <slm_thd_sched_policy>

	assert(ps_list_singleton_d(p));
  413c65:	48 3b 00             	cmp    rax,QWORD PTR [rax]
  413c68:	75 46                	jne    413cb0 <slm_sched_fprr_wakeup+0x60>
  413c6a:	48 89 c6             	mov    rsi,rax
  413c6d:	0f 01 f9             	rdtscp 

	ps_list_head_append_d(&threads[cos_cpuid()].prio[t->priority - 1], p);
  413c70:	48 8b 43 30          	mov    rax,QWORD PTR [rbx+0x30]
	return (long)coreid;
  413c74:	81 e1 ff 0f 00 00    	and    ecx,0xfff

	return 0;
}
  413c7a:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
	ps_list_head_append_d(&threads[cos_cpuid()].prio[t->priority - 1], p);
  413c7e:	48 c1 e1 05          	shl    rcx,0x5
  413c82:	48 8d 44 01 ff       	lea    rax,[rcx+rax*1-0x1]
  413c87:	48 c1 e0 04          	shl    rax,0x4
  413c8b:	48 8b 80 08 9b 70 00 	mov    rax,QWORD PTR [rax+0x709b08]
	new->n    = l->n;
  413c92:	f3 0f 7e 00          	movq   xmm0,QWORD PTR [rax]
  413c96:	66 48 0f 6e c8       	movq   xmm1,rax
  413c9b:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  413c9f:	0f 11 06             	movups XMMWORD PTR [rsi],xmm0
	l->n      = new;
  413ca2:	48 89 30             	mov    QWORD PTR [rax],rsi
	new->n->p = new;
  413ca5:	48 8b 06             	mov    rax,QWORD PTR [rsi]
  413ca8:	48 89 70 08          	mov    QWORD PTR [rax+0x8],rsi
}
  413cac:	31 c0                	xor    eax,eax
  413cae:	c9                   	leave  
  413caf:	c3                   	ret    
  413cb0:	be 23 00 00 00       	mov    esi,0x23
  413cb5:	bf 18 f4 41 00       	mov    edi,0x41f418
  413cba:	e8 c1 6f ff ff       	call   40ac80 <cos_print_str>
	assert(ps_list_singleton_d(p));
  413cbf:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413cc6:	00 00 00 00 
  413cca:	0f 0b                	ud2    
  413ccc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000413cd0 <slm_sched_fprr_yield>:

void
slm_sched_fprr_yield(struct slm_thd *t, struct slm_thd *yield_to)
{
  413cd0:	f3 0f 1e fa          	endbr64 
  413cd4:	55                   	push   rbp
  413cd5:	48 89 e5             	mov    rbp,rsp
  413cd8:	53                   	push   rbx
  413cd9:	48 89 fb             	mov    rbx,rdi
  413cdc:	48 83 ec 08          	sub    rsp,0x8
	struct slm_sched_thd *p = slm_thd_sched_policy(t);
  413ce0:	e8 fb dc fe ff       	call   4019e0 <slm_thd_sched_policy>
  413ce5:	48 89 c6             	mov    rsi,rax
	l->n->p = l->p;
  413ce8:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  413ceb:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	l->p = l->n = l;
  413cef:	66 48 0f 6e c6       	movq   xmm0,rsi
  413cf4:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
	l->n->p = l->p;
  413cf8:	48 89 42 08          	mov    QWORD PTR [rdx+0x8],rax
	l->p->n = l->n;
  413cfc:	48 89 10             	mov    QWORD PTR [rax],rdx
	l->p = l->n = l;
  413cff:	0f 11 06             	movups XMMWORD PTR [rsi],xmm0
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  413d02:	0f 01 f9             	rdtscp 
	return (long)coreid;
  413d05:	81 e1 ff 0f 00 00    	and    ecx,0xfff

	ps_list_rem_d(p);
	ps_list_head_append_d(&threads[cos_cpuid()].prio[t->priority], p);
  413d0b:	48 c1 e1 05          	shl    rcx,0x5
  413d0f:	48 03 4b 30          	add    rcx,QWORD PTR [rbx+0x30]
}
  413d13:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
	ps_list_head_append_d(&threads[cos_cpuid()].prio[t->priority], p);
  413d17:	48 c1 e1 04          	shl    rcx,0x4
  413d1b:	48 8b 81 08 9b 70 00 	mov    rax,QWORD PTR [rcx+0x709b08]
	new->n    = l->n;
  413d22:	f3 0f 7e 00          	movq   xmm0,QWORD PTR [rax]
  413d26:	66 48 0f 6e c8       	movq   xmm1,rax
  413d2b:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  413d2f:	0f 11 06             	movups XMMWORD PTR [rsi],xmm0
	l->n      = new;
  413d32:	48 89 30             	mov    QWORD PTR [rax],rsi
	new->n->p = new;
  413d35:	48 8b 06             	mov    rax,QWORD PTR [rsi]
  413d38:	48 89 70 08          	mov    QWORD PTR [rax+0x8],rsi
}
  413d3c:	c9                   	leave  
  413d3d:	c3                   	ret    
  413d3e:	66 90                	xchg   ax,ax

0000000000413d40 <slm_sched_fprr_thd_init>:

int
slm_sched_fprr_thd_init(struct slm_thd *t)
{
  413d40:	f3 0f 1e fa          	endbr64 
  413d44:	55                   	push   rbp
	t->priority = SLM_FPRR_PRIO_LOWEST;
  413d45:	48 c7 47 30 1f 00 00 	mov    QWORD PTR [rdi+0x30],0x1f
  413d4c:	00 
{
  413d4d:	48 89 e5             	mov    rbp,rsp
	ps_list_init_d(slm_thd_sched_policy(t));
  413d50:	e8 8b dc fe ff       	call   4019e0 <slm_thd_sched_policy>
{ l->n = l->p = l; }
  413d55:	66 48 0f 6e c0       	movq   xmm0,rax
  413d5a:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  413d5e:	0f 11 00             	movups XMMWORD PTR [rax],xmm0

	return 0;
}
  413d61:	31 c0                	xor    eax,eax
  413d63:	5d                   	pop    rbp
  413d64:	c3                   	ret    
  413d65:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  413d6c:	00 00 00 00 

0000000000413d70 <slm_sched_fprr_thd_deinit>:

void
slm_sched_fprr_thd_deinit(struct slm_thd *t)
{
  413d70:	f3 0f 1e fa          	endbr64 
  413d74:	55                   	push   rbp
  413d75:	48 89 e5             	mov    rbp,rsp
	ps_list_rem_d(slm_thd_sched_policy(t));
  413d78:	e8 63 dc fe ff       	call   4019e0 <slm_thd_sched_policy>
	l->n->p = l->p;
  413d7d:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  413d80:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
	l->p = l->n = l;
  413d84:	66 48 0f 6e c0       	movq   xmm0,rax
  413d89:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
	l->n->p = l->p;
  413d8d:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
	l->p->n = l->n;
  413d91:	48 89 0a             	mov    QWORD PTR [rdx],rcx
	l->p = l->n = l;
  413d94:	0f 11 00             	movups XMMWORD PTR [rax],xmm0
}
  413d97:	5d                   	pop    rbp
  413d98:	c3                   	ret    
  413d99:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000413da0 <slm_sched_fprr_thd_update>:
	return;
}

int
slm_sched_fprr_thd_update(struct slm_thd *t, sched_param_type_t type, unsigned int v)
{
  413da0:	f3 0f 1e fa          	endbr64 
  413da4:	55                   	push   rbp
  413da5:	48 89 e5             	mov    rbp,rsp
  413da8:	41 54                	push   r12
  413daa:	53                   	push   rbx
  413dab:	48 89 fb             	mov    rbx,rdi
	switch (type) {
  413dae:	83 fe 0a             	cmp    esi,0xa
  413db1:	74 1d                	je     413dd0 <slm_sched_fprr_thd_update+0x30>
  413db3:	83 fe 0b             	cmp    esi,0xb
  413db6:	0f 84 d4 00 00 00    	je     413e90 <slm_sched_fprr_thd_update+0xf0>
  413dbc:	b8 ff ff ff ff       	mov    eax,0xffffffff
  413dc1:	83 fe 01             	cmp    esi,0x1
  413dc4:	74 6a                	je     413e30 <slm_sched_fprr_thd_update+0x90>
	}
	/* Only support priority, for now */
	default:
		return -1;
	}
}
  413dc6:	5b                   	pop    rbx
  413dc7:	41 5c                	pop    r12
  413dc9:	5d                   	pop    rbp
  413dca:	c3                   	ret    
  413dcb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	struct slm_sched_thd *p = slm_thd_sched_policy(t);
  413dd0:	e8 0b dc fe ff       	call   4019e0 <slm_thd_sched_policy>
	t->priority = prio;
  413dd5:	48 c7 43 30 00 00 00 	mov    QWORD PTR [rbx+0x30],0x0
  413ddc:	00 
	struct slm_sched_thd *p = slm_thd_sched_policy(t);
  413ddd:	48 89 c6             	mov    rsi,rax
	l->n->p = l->p;
  413de0:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  413de3:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	l->p = l->n = l;
  413de7:	66 48 0f 6e c6       	movq   xmm0,rsi
  413dec:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
	l->n->p = l->p;
  413df0:	48 89 42 08          	mov    QWORD PTR [rdx+0x8],rax
	l->p->n = l->n;
  413df4:	48 89 10             	mov    QWORD PTR [rax],rdx
	l->p = l->n = l;
  413df7:	0f 11 06             	movups XMMWORD PTR [rsi],xmm0
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  413dfa:	0f 01 f9             	rdtscp 
	return (long)coreid;
  413dfd:	81 e1 ff 0f 00 00    	and    ecx,0xfff
	ps_list_head_append_d(&threads[cos_cpuid()].prio[prio], p);
  413e03:	48 c1 e1 09          	shl    rcx,0x9
  413e07:	48 8b 81 08 9b 70 00 	mov    rax,QWORD PTR [rcx+0x709b08]
	new->n    = l->n;
  413e0e:	f3 0f 7e 00          	movq   xmm0,QWORD PTR [rax]
  413e12:	66 48 0f 6e c8       	movq   xmm1,rax
  413e17:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  413e1b:	0f 11 06             	movups XMMWORD PTR [rsi],xmm0
	l->n      = new;
  413e1e:	48 89 30             	mov    QWORD PTR [rax],rsi
	new->n->p = new;
  413e21:	48 8b 06             	mov    rax,QWORD PTR [rsi]
  413e24:	48 89 70 08          	mov    QWORD PTR [rax+0x8],rsi
		return 0;
  413e28:	31 c0                	xor    eax,eax
}
  413e2a:	5b                   	pop    rbx
  413e2b:	41 5c                	pop    r12
  413e2d:	5d                   	pop    rbp
  413e2e:	c3                   	ret    
  413e2f:	90                   	nop
		assert(v >= SLM_FPRR_PRIO_HIGHEST && v <= SLM_FPRR_PRIO_LOWEST);
  413e30:	8d 42 ff             	lea    eax,[rdx-0x1]
  413e33:	83 f8 1e             	cmp    eax,0x1e
  413e36:	0f 87 a4 00 00 00    	ja     413ee0 <slm_sched_fprr_thd_update+0x140>
		update_queue(t, v);
  413e3c:	41 89 d4             	mov    r12d,edx
	struct slm_sched_thd *p = slm_thd_sched_policy(t);
  413e3f:	e8 9c db fe ff       	call   4019e0 <slm_thd_sched_policy>
	t->priority = prio;
  413e44:	4c 89 63 30          	mov    QWORD PTR [rbx+0x30],r12
	struct slm_sched_thd *p = slm_thd_sched_policy(t);
  413e48:	48 89 c6             	mov    rsi,rax
	l->n->p = l->p;
  413e4b:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  413e4e:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	l->p = l->n = l;
  413e52:	66 48 0f 6e c6       	movq   xmm0,rsi
  413e57:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
	l->n->p = l->p;
  413e5b:	48 89 42 08          	mov    QWORD PTR [rdx+0x8],rax
	l->p->n = l->n;
  413e5f:	48 89 10             	mov    QWORD PTR [rax],rdx
	l->p = l->n = l;
  413e62:	0f 11 06             	movups XMMWORD PTR [rsi],xmm0
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  413e65:	0f 01 f9             	rdtscp 
	return (long)coreid;
  413e68:	81 e1 ff 0f 00 00    	and    ecx,0xfff
	ps_list_head_append_d(&threads[cos_cpuid()].prio[prio], p);
  413e6e:	48 c1 e1 05          	shl    rcx,0x5
  413e72:	4c 01 e1             	add    rcx,r12
  413e75:	48 c1 e1 04          	shl    rcx,0x4
  413e79:	48 8b 81 08 9b 70 00 	mov    rax,QWORD PTR [rcx+0x709b08]
	new->n    = l->n;
  413e80:	f3 0f 7e 00          	movq   xmm0,QWORD PTR [rax]
  413e84:	66 48 0f 6e d8       	movq   xmm3,rax
  413e89:	66 0f 6c c3          	punpcklqdq xmm0,xmm3
  413e8d:	eb 8c                	jmp    413e1b <slm_sched_fprr_thd_update+0x7b>
  413e8f:	90                   	nop
	struct slm_sched_thd *p = slm_thd_sched_policy(t);
  413e90:	e8 4b db fe ff       	call   4019e0 <slm_thd_sched_policy>
	t->priority = prio;
  413e95:	48 c7 43 30 1f 00 00 	mov    QWORD PTR [rbx+0x30],0x1f
  413e9c:	00 
	struct slm_sched_thd *p = slm_thd_sched_policy(t);
  413e9d:	48 89 c6             	mov    rsi,rax
	l->n->p = l->p;
  413ea0:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  413ea3:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
	l->p = l->n = l;
  413ea7:	66 48 0f 6e c6       	movq   xmm0,rsi
  413eac:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
	l->n->p = l->p;
  413eb0:	48 89 42 08          	mov    QWORD PTR [rdx+0x8],rax
	l->p->n = l->n;
  413eb4:	48 89 10             	mov    QWORD PTR [rax],rdx
	l->p = l->n = l;
  413eb7:	0f 11 06             	movups XMMWORD PTR [rsi],xmm0
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  413eba:	0f 01 f9             	rdtscp 
	return (long)coreid;
  413ebd:	81 e1 ff 0f 00 00    	and    ecx,0xfff
	ps_list_head_append_d(&threads[cos_cpuid()].prio[prio], p);
  413ec3:	48 c1 e1 09          	shl    rcx,0x9
  413ec7:	48 8b 81 f8 9c 70 00 	mov    rax,QWORD PTR [rcx+0x709cf8]
	new->n    = l->n;
  413ece:	f3 0f 7e 00          	movq   xmm0,QWORD PTR [rax]
  413ed2:	66 48 0f 6e d0       	movq   xmm2,rax
  413ed7:	66 0f 6c c2          	punpcklqdq xmm0,xmm2
  413edb:	e9 3b ff ff ff       	jmp    413e1b <slm_sched_fprr_thd_update+0x7b>
  413ee0:	be 24 00 00 00       	mov    esi,0x24
  413ee5:	bf 40 f4 41 00       	mov    edi,0x41f440
  413eea:	e8 91 6d ff ff       	call   40ac80 <cos_print_str>
		assert(v >= SLM_FPRR_PRIO_HIGHEST && v <= SLM_FPRR_PRIO_LOWEST);
  413eef:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  413ef6:	00 00 00 00 
  413efa:	0f 0b                	ud2    
  413efc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000413f00 <slm_sched_fprr_init>:

void
slm_sched_fprr_init(void)
{
  413f00:	f3 0f 1e fa          	endbr64 
  413f04:	31 f6                	xor    esi,esi
  413f06:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  413f0d:	00 00 00 
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  413f10:	0f 01 f9             	rdtscp 
	int i;

	for (i = 0 ; i < SLM_FPRR_NPRIOS ; i++) {
		ps_list_head_init(&threads[cos_cpuid()].prio[i]);
  413f13:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  413f19:	48 c1 e1 05          	shl    rcx,0x5
  413f1d:	48 01 f1             	add    rcx,rsi
	for (i = 0 ; i < SLM_FPRR_NPRIOS ; i++) {
  413f20:	48 83 c6 01          	add    rsi,0x1
		ps_list_head_init(&threads[cos_cpuid()].prio[i]);
  413f24:	48 c1 e1 04          	shl    rcx,0x4
  413f28:	48 8d 81 00 9b 70 00 	lea    rax,[rcx+0x709b00]
  413f2f:	66 48 0f 6e c0       	movq   xmm0,rax
{ l->n = l->p = l; }
  413f34:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  413f38:	0f 29 81 00 9b 70 00 	movaps XMMWORD PTR [rcx+0x709b00],xmm0
	for (i = 0 ; i < SLM_FPRR_NPRIOS ; i++) {
  413f3f:	48 83 fe 20          	cmp    rsi,0x20
  413f43:	75 cb                	jne    413f10 <slm_sched_fprr_init+0x10>
	}
}
  413f45:	c3                   	ret    
  413f46:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  413f4d:	00 00 00 
#include <cos_debug.h>

/* Override this to do initialization before idle computation */
CWEAKSYMB void slm_idle_comp_initialization(void) { return; }
  413f50:	f3 0f 1e fa          	endbr64 
  413f54:	c3                   	ret    
  413f55:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  413f5c:	00 00 00 00 

0000000000413f60 <slm_idle_iteration>:
  413f60:	f3 0f 1e fa          	endbr64 
  413f64:	c3                   	ret    
  413f65:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  413f6c:	00 00 00 00 

0000000000413f70 <slm_idle>:
/* Override this to do repetitive computation in idle */
CWEAKSYMB void slm_idle_iteration(void) { return; }

void
slm_idle(void *d)
{
  413f70:	f3 0f 1e fa          	endbr64 
  413f74:	55                   	push   rbp
  413f75:	48 89 e5             	mov    rbp,rsp
	slm_idle_comp_initialization();
  413f78:	e8 33 c6 fe ff       	call   4005b0 <slm_idle_comp_initialization>
  413f7d:	0f 1f 00             	nop    DWORD PTR [rax]

	while (1) {
		slm_idle_iteration();
  413f80:	e8 db ff ff ff       	call   413f60 <slm_idle_iteration>
	while (1) {
  413f85:	eb f9                	jmp    413f80 <slm_idle+0x10>
  413f87:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  413f8e:	00 00 

0000000000413f90 <__slm_timeout_update_idx>:
	return slm_thd_timer_policy((struct slm_thd *)a)->abs_wakeup <= slm_thd_timer_policy((struct slm_thd *)b)->abs_wakeup;
}

static void
__slm_timeout_update_idx(void *e, int pos)
{ slm_thd_timer_policy((struct slm_thd *)e)->timeout_idx = pos; }
  413f90:	f3 0f 1e fa          	endbr64 
  413f94:	55                   	push   rbp
  413f95:	48 89 e5             	mov    rbp,rsp
  413f98:	53                   	push   rbx
  413f99:	89 f3                	mov    ebx,esi
  413f9b:	48 83 ec 08          	sub    rsp,0x8
  413f9f:	e8 2c da fe ff       	call   4019d0 <slm_thd_timer_policy>
  413fa4:	89 18                	mov    DWORD PTR [rax],ebx
  413fa6:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
  413faa:	c9                   	leave  
  413fab:	c3                   	ret    
  413fac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000413fb0 <__slm_timeout_compare_min>:
{
  413fb0:	f3 0f 1e fa          	endbr64 
  413fb4:	55                   	push   rbp
  413fb5:	48 89 e5             	mov    rbp,rsp
  413fb8:	41 54                	push   r12
  413fba:	49 89 f4             	mov    r12,rsi
  413fbd:	53                   	push   rbx
	return slm_thd_timer_policy((struct slm_thd *)a)->abs_wakeup <= slm_thd_timer_policy((struct slm_thd *)b)->abs_wakeup;
  413fbe:	e8 0d da fe ff       	call   4019d0 <slm_thd_timer_policy>
  413fc3:	4c 89 e7             	mov    rdi,r12
  413fc6:	48 8b 58 08          	mov    rbx,QWORD PTR [rax+0x8]
  413fca:	e8 01 da fe ff       	call   4019d0 <slm_thd_timer_policy>
  413fcf:	48 3b 58 08          	cmp    rbx,QWORD PTR [rax+0x8]
}
  413fd3:	5b                   	pop    rbx
	return slm_thd_timer_policy((struct slm_thd *)a)->abs_wakeup <= slm_thd_timer_policy((struct slm_thd *)b)->abs_wakeup;
  413fd4:	0f 96 c0             	setbe  al
}
  413fd7:	41 5c                	pop    r12
  413fd9:	5d                   	pop    rbp
	return slm_thd_timer_policy((struct slm_thd *)a)->abs_wakeup <= slm_thd_timer_policy((struct slm_thd *)b)->abs_wakeup;
  413fda:	0f b6 c0             	movzx  eax,al
}
  413fdd:	c3                   	ret    
  413fde:	66 90                	xchg   ax,ax

0000000000413fe0 <slm_timer_quantum_expire>:
{
  413fe0:	f3 0f 1e fa          	endbr64 
  413fe4:	55                   	push   rbp
  413fe5:	48 89 e5             	mov    rbp,rsp
  413fe8:	41 56                	push   r14
  413fea:	41 55                	push   r13
  413fec:	41 54                	push   r12
  413fee:	53                   	push   rbx
  413fef:	0f 01 f9             	rdtscp 
	assert(now >= g->current_timeout);
  413ff2:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  413ff8:	48 8d 04 49          	lea    rax,[rcx+rcx*2]
  413ffc:	48 8d 34 81          	lea    rsi,[rcx+rax*4]
  414000:	48 c1 e6 07          	shl    rsi,0x7
  414004:	48 81 c6 00 ab 70 00 	add    rsi,0x70ab00
  41400b:	48 8b 96 68 06 00 00 	mov    rdx,QWORD PTR [rsi+0x668]
  414012:	48 39 fa             	cmp    rdx,rdi
  414015:	0f 87 4f 01 00 00    	ja     41416a <slm_timer_quantum_expire+0x18a>
  41401b:	49 89 fe             	mov    r14,rdi
	offset = (now - g->current_timeout) % g->period;
  41401e:	48 8b 8e 60 06 00 00 	mov    rcx,QWORD PTR [rsi+0x660]
  414025:	4c 89 f0             	mov    rax,r14
  414028:	48 29 d0             	sub    rax,rdx
  41402b:	31 d2                	xor    edx,edx
	next_timeout = now + (g->period - offset);
  41402d:	48 8d 3c 39          	lea    rdi,[rcx+rdi*1]
	offset = (now - g->current_timeout) % g->period;
  414031:	48 f7 f1             	div    rcx
	next_timeout = now + (g->period - offset);
  414034:	48 29 d7             	sub    rdi,rdx
	assert(next_timeout > now);
  414037:	49 39 fe             	cmp    r14,rdi
  41403a:	0f 83 46 01 00 00    	jae    414186 <slm_timer_quantum_expire+0x1a6>
  414040:	0f 01 f9             	rdtscp 
slm_timeout_set(cycles_t timeout)
{
	struct slm_global *g = slm_global();

	g->timeout_next = tcap_cyc2time(timeout);
	g->timer_next   = timeout;
  414043:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  414049:	ba 01 00 00 00       	mov    edx,0x1
  41404e:	66 48 0f 6e c7       	movq   xmm0,rdi
  414053:	48 8d 04 89          	lea    rax,[rcx+rcx*4]
  414057:	48 c1 e0 06          	shl    rax,0x6
  41405b:	48 85 ff             	test   rdi,rdi
	g->timer_set    = 1;
  41405e:	c7 80 fc 65 71 00 01 	mov    DWORD PTR [rax+0x7165fc],0x1
  414065:	00 00 00 
	g->timer_next   = timeout;
  414068:	48 0f 45 d7          	cmovne rdx,rdi
  41406c:	66 48 0f 6e ca       	movq   xmm1,rdx
  414071:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  414075:	0f 29 80 00 66 71 00 	movaps XMMWORD PTR [rax+0x716600],xmm0
	g->current_timeout = next_timeout;
  41407c:	48 89 be 68 06 00 00 	mov    QWORD PTR [rsi+0x668],rdi
  414083:	0f 01 f9             	rdtscp 
	while (heap_size(&g->h) > 0) {
  414086:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  41408c:	48 8d 04 49          	lea    rax,[rcx+rcx*2]
  414090:	4c 8d 2c 81          	lea    r13,[rcx+rax*4]
  414094:	49 c1 e5 07          	shl    r13,0x7
  414098:	49 81 c5 00 ab 70 00 	add    r13,0x70ab00
  41409f:	4c 89 ef             	mov    rdi,r13
  4140a2:	e8 79 27 00 00       	call   416820 <heap_size>
  4140a7:	85 c0                	test   eax,eax
  4140a9:	7e 62                	jle    41410d <slm_timer_quantum_expire+0x12d>
		tp = heap_peek(&g->h);
  4140ab:	4c 89 ef             	mov    rdi,r13
  4140ae:	e8 7d 24 00 00       	call   416530 <heap_peek>
  4140b3:	49 89 c4             	mov    r12,rax
		assert(tp);
  4140b6:	48 85 c0             	test   rax,rax
  4140b9:	74 77                	je     414132 <slm_timer_quantum_expire+0x152>
		tt = slm_thd_timer_policy(tp);
  4140bb:	48 89 c7             	mov    rdi,rax
  4140be:	e8 0d d9 fe ff       	call   4019d0 <slm_thd_timer_policy>
  4140c3:	48 89 c3             	mov    rbx,rax
		assert(tt && tt->timeout_idx > 0);
  4140c6:	48 85 c0             	test   rax,rax
  4140c9:	74 4b                	je     414116 <slm_timer_quantum_expire+0x136>
  4140cb:	8b 00                	mov    eax,DWORD PTR [rax]
  4140cd:	85 c0                	test   eax,eax
  4140cf:	7e 45                	jle    414116 <slm_timer_quantum_expire+0x136>
	return (s64_t)(g - l) > 0;
  4140d1:	48 8b 43 08          	mov    rax,QWORD PTR [rbx+0x8]
  4140d5:	4c 29 f0             	sub    rax,r14
		if (cycles_greater_than(tt->abs_wakeup, now)) break;
  4140d8:	48 85 c0             	test   rax,rax
  4140db:	7f 30                	jg     41410d <slm_timer_quantum_expire+0x12d>
		th = heap_highest(&g->h);
  4140dd:	4c 89 ef             	mov    rdi,r13
  4140e0:	e8 cb 22 00 00       	call   4163b0 <heap_highest>
		assert(th == tp);
  4140e5:	49 39 c4             	cmp    r12,rax
  4140e8:	75 64                	jne    41414e <slm_timer_quantum_expire+0x16e>
		tt->timeout_idx = -1;
  4140ea:	c7 03 ff ff ff ff    	mov    DWORD PTR [rbx],0xffffffff
		slm_thd_wakeup(th, 1);
  4140f0:	4c 89 e7             	mov    rdi,r12
  4140f3:	be 01 00 00 00       	mov    esi,0x1
		tt->abs_wakeup  = now;
  4140f8:	4c 89 73 08          	mov    QWORD PTR [rbx+0x8],r14
		slm_thd_wakeup(th, 1);
  4140fc:	e8 9f 16 00 00       	call   4157a0 <slm_thd_wakeup>
	while (heap_size(&g->h) > 0) {
  414101:	4c 89 ef             	mov    rdi,r13
  414104:	e8 17 27 00 00       	call   416820 <heap_size>
  414109:	85 c0                	test   eax,eax
  41410b:	7f 9e                	jg     4140ab <slm_timer_quantum_expire+0xcb>
}
  41410d:	5b                   	pop    rbx
  41410e:	41 5c                	pop    r12
  414110:	41 5d                	pop    r13
  414112:	41 5e                	pop    r14
  414114:	5d                   	pop    rbp
  414115:	c3                   	ret    
  414116:	be 26 00 00 00       	mov    esi,0x26
  41411b:	bf e0 f4 41 00       	mov    edi,0x41f4e0
  414120:	e8 5b 6b ff ff       	call   40ac80 <cos_print_str>
		assert(tt && tt->timeout_idx > 0);
  414125:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41412c:	00 00 00 00 
  414130:	0f 0b                	ud2    
  414132:	be 26 00 00 00       	mov    esi,0x26
  414137:	bf b8 f4 41 00       	mov    edi,0x41f4b8
  41413c:	e8 3f 6b ff ff       	call   40ac80 <cos_print_str>
		assert(tp);
  414141:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414148:	00 00 00 00 
  41414c:	0f 0b                	ud2    
  41414e:	be 26 00 00 00       	mov    esi,0x26
  414153:	bf 08 f5 41 00       	mov    edi,0x41f508
  414158:	e8 23 6b ff ff       	call   40ac80 <cos_print_str>
		assert(th == tp);
  41415d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414164:	00 00 00 00 
  414168:	0f 0b                	ud2    
  41416a:	be 26 00 00 00       	mov    esi,0x26
  41416f:	bf 68 f4 41 00       	mov    edi,0x41f468
  414174:	e8 07 6b ff ff       	call   40ac80 <cos_print_str>
	assert(now >= g->current_timeout);
  414179:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414180:	00 00 00 00 
  414184:	0f 0b                	ud2    
  414186:	be 26 00 00 00       	mov    esi,0x26
  41418b:	bf 90 f4 41 00       	mov    edi,0x41f490
  414190:	e8 eb 6a ff ff       	call   40ac80 <cos_print_str>
	assert(next_timeout > now);
  414195:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41419c:	00 00 00 00 
  4141a0:	0f 0b                	ud2    
  4141a2:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4141a9:	00 00 00 00 
  4141ad:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004141b0 <slm_timer_quantum_add>:
{
  4141b0:	f3 0f 1e fa          	endbr64 
  4141b4:	55                   	push   rbp
  4141b5:	48 89 e5             	mov    rbp,rsp
  4141b8:	41 56                	push   r14
  4141ba:	49 89 fe             	mov    r14,rdi
  4141bd:	41 55                	push   r13
  4141bf:	41 54                	push   r12
  4141c1:	49 89 f4             	mov    r12,rsi
  4141c4:	53                   	push   rbx
	struct slm_timer_thd *tt = slm_thd_timer_policy(t);
  4141c5:	e8 06 d8 fe ff       	call   4019d0 <slm_thd_timer_policy>
  4141ca:	48 89 c3             	mov    rbx,rax
  4141cd:	0f 01 f9             	rdtscp 
	*coreid = c & 0xFFF;
  4141d0:	66 81 e1 ff 0f       	and    cx,0xfff
	assert(tt && tt->timeout_idx == -1);
  4141d5:	48 85 db             	test   rbx,rbx
  4141d8:	74 44                	je     41421e <slm_timer_quantum_add+0x6e>
  4141da:	83 3b ff             	cmp    DWORD PTR [rbx],0xffffffff
  4141dd:	75 3f                	jne    41421e <slm_timer_quantum_add+0x6e>
	assert(heap_size(&g->h) < MAX_NUM_THREADS);
  4141df:	0f b7 c1             	movzx  eax,cx
  4141e2:	48 8d 14 40          	lea    rdx,[rax+rax*2]
  4141e6:	4c 8d 2c 90          	lea    r13,[rax+rdx*4]
  4141ea:	49 c1 e5 07          	shl    r13,0x7
  4141ee:	49 81 c5 00 ab 70 00 	add    r13,0x70ab00
  4141f5:	4c 89 ef             	mov    rdi,r13
  4141f8:	e8 23 26 00 00       	call   416820 <heap_size>
  4141fd:	3d c7 00 00 00       	cmp    eax,0xc7
  414202:	7f 36                	jg     41423a <slm_timer_quantum_add+0x8a>
	tt->abs_wakeup = absolute_timeout;
  414204:	4c 89 63 08          	mov    QWORD PTR [rbx+0x8],r12
	heap_add(&g->h, t);
  414208:	4c 89 f6             	mov    rsi,r14
  41420b:	4c 89 ef             	mov    rdi,r13
  41420e:	e8 6d 1f 00 00       	call   416180 <heap_add>
}
  414213:	5b                   	pop    rbx
  414214:	31 c0                	xor    eax,eax
  414216:	41 5c                	pop    r12
  414218:	41 5d                	pop    r13
  41421a:	41 5e                	pop    r14
  41421c:	5d                   	pop    rbp
  41421d:	c3                   	ret    
  41421e:	be 26 00 00 00       	mov    esi,0x26
  414223:	bf 30 f5 41 00       	mov    edi,0x41f530
  414228:	e8 53 6a ff ff       	call   40ac80 <cos_print_str>
	assert(tt && tt->timeout_idx == -1);
  41422d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414234:	00 00 00 00 
  414238:	0f 0b                	ud2    
  41423a:	be 26 00 00 00       	mov    esi,0x26
  41423f:	bf 58 f5 41 00       	mov    edi,0x41f558
  414244:	e8 37 6a ff ff       	call   40ac80 <cos_print_str>
	assert(heap_size(&g->h) < MAX_NUM_THREADS);
  414249:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414250:	00 00 00 00 
  414254:	0f 0b                	ud2    
  414256:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41425d:	00 00 00 

0000000000414260 <slm_timer_quantum_cancel>:
{
  414260:	f3 0f 1e fa          	endbr64 
  414264:	55                   	push   rbp
  414265:	48 89 e5             	mov    rbp,rsp
  414268:	41 54                	push   r12
  41426a:	53                   	push   rbx
	struct slm_timer_thd *tt = slm_thd_timer_policy(t);
  41426b:	e8 60 d7 fe ff       	call   4019d0 <slm_thd_timer_policy>
  414270:	48 89 c3             	mov    rbx,rax
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  414273:	0f 01 f9             	rdtscp 
	if (tt->timeout_idx == -1) return 0;
  414276:	83 3b ff             	cmp    DWORD PTR [rbx],0xffffffff
  414279:	74 39                	je     4142b4 <slm_timer_quantum_cancel+0x54>
	assert(heap_size(&g->h));
  41427b:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  414281:	48 8d 04 49          	lea    rax,[rcx+rcx*2]
  414285:	4c 8d 24 81          	lea    r12,[rcx+rax*4]
  414289:	49 c1 e4 07          	shl    r12,0x7
  41428d:	49 81 c4 00 ab 70 00 	add    r12,0x70ab00
  414294:	4c 89 e7             	mov    rdi,r12
  414297:	e8 84 25 00 00       	call   416820 <heap_size>
  41429c:	85 c0                	test   eax,eax
  41429e:	74 1b                	je     4142bb <slm_timer_quantum_cancel+0x5b>
	assert(tt->timeout_idx > 0);
  4142a0:	8b 33                	mov    esi,DWORD PTR [rbx]
  4142a2:	85 f6                	test   esi,esi
  4142a4:	7e 31                	jle    4142d7 <slm_timer_quantum_cancel+0x77>
	heap_remove(&g->h, tt->timeout_idx);
  4142a6:	4c 89 e7             	mov    rdi,r12
  4142a9:	e8 a2 24 00 00       	call   416750 <heap_remove>
	tt->timeout_idx = -1;
  4142ae:	c7 03 ff ff ff ff    	mov    DWORD PTR [rbx],0xffffffff
}
  4142b4:	5b                   	pop    rbx
  4142b5:	31 c0                	xor    eax,eax
  4142b7:	41 5c                	pop    r12
  4142b9:	5d                   	pop    rbp
  4142ba:	c3                   	ret    
  4142bb:	be 27 00 00 00       	mov    esi,0x27
  4142c0:	bf 80 f5 41 00       	mov    edi,0x41f580
  4142c5:	e8 b6 69 ff ff       	call   40ac80 <cos_print_str>
	assert(heap_size(&g->h));
  4142ca:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4142d1:	00 00 00 00 
  4142d5:	0f 0b                	ud2    
  4142d7:	be 27 00 00 00       	mov    esi,0x27
  4142dc:	bf a8 f5 41 00       	mov    edi,0x41f5a8
  4142e1:	e8 9a 69 ff ff       	call   40ac80 <cos_print_str>
	assert(tt->timeout_idx > 0);
  4142e6:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4142ed:	00 00 00 00 
  4142f1:	0f 0b                	ud2    
  4142f3:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  4142fa:	00 00 00 00 
  4142fe:	66 90                	xchg   ax,ax

0000000000414300 <slm_timer_quantum_thd_init>:
{
  414300:	f3 0f 1e fa          	endbr64 
  414304:	55                   	push   rbp
  414305:	48 89 e5             	mov    rbp,rsp
	struct slm_timer_thd *tt = slm_thd_timer_policy(t);
  414308:	e8 c3 d6 fe ff       	call   4019d0 <slm_thd_timer_policy>
	*tt = (struct slm_timer_thd){
  41430d:	c7 00 ff ff ff ff    	mov    DWORD PTR [rax],0xffffffff
  414313:	48 c7 40 08 00 00 00 	mov    QWORD PTR [rax+0x8],0x0
  41431a:	00 
}
  41431b:	31 c0                	xor    eax,eax
  41431d:	5d                   	pop    rbp
  41431e:	c3                   	ret    
  41431f:	90                   	nop

0000000000414320 <slm_timer_quantum_thd_deinit>:
{
  414320:	f3 0f 1e fa          	endbr64 
}
  414324:	c3                   	ret    
  414325:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41432c:	00 00 00 00 

0000000000414330 <slm_timer_quantum_init>:
	slm_timeout_set(next_timeout);
}

int
slm_timer_quantum_init(void)
{
  414330:	f3 0f 1e fa          	endbr64 
  414334:	55                   	push   rbp
  414335:	48 89 e5             	mov    rbp,rsp
  414338:	53                   	push   rbx
  414339:	48 83 ec 08          	sub    rsp,0x8
  41433d:	0f 01 f9             	rdtscp 
	return &__timer_globals[cos_coreid()];
  414340:	89 ce                	mov    esi,ecx
  414342:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  414348:	48 8d 04 49          	lea    rax,[rcx+rcx*2]
  41434c:	81 e6 ff 0f 00 00    	and    esi,0xfff
  414352:	4c 8d 04 81          	lea    r8,[rcx+rax*4]
	memset(g, 0, sizeof(struct timer_global));
  414356:	31 c0                	xor    eax,eax
  414358:	b9 d0 00 00 00       	mov    ecx,0xd0
	return &__timer_globals[cos_coreid()];
  41435d:	49 c1 e0 07          	shl    r8,0x7
  414361:	49 81 c0 00 ab 70 00 	add    r8,0x70ab00
	memset(g, 0, sizeof(struct timer_global));
  414368:	4c 89 c7             	mov    rdi,r8
  41436b:	f3 48 ab             	rep stos QWORD PTR es:[rdi],rax
  41436e:	0f 01 f9             	rdtscp 
	g->period = slm_usec2cyc(period);
  414371:	48 63 c6             	movsxd rax,esi
	return usec * slm_global()->cyc_per_usec;
  414374:	81 e1 ff 0f 00 00    	and    ecx,0xfff
	heap_init(&g->h, MAX_NUM_THREADS, __slm_timeout_compare_min, __slm_timeout_update_idx);
  41437a:	be c8 00 00 00       	mov    esi,0xc8
  41437f:	4c 89 c7             	mov    rdi,r8
	g->period = slm_usec2cyc(period);
  414382:	48 8d 14 40          	lea    rdx,[rax+rax*2]
  414386:	48 8d 1c 90          	lea    rbx,[rax+rdx*4]
  41438a:	48 8d 04 89          	lea    rax,[rcx+rcx*4]
	heap_init(&g->h, MAX_NUM_THREADS, __slm_timeout_compare_min, __slm_timeout_update_idx);
  41438e:	ba b0 3f 41 00       	mov    edx,0x413fb0
  414393:	b9 90 3f 41 00       	mov    ecx,0x413f90
  414398:	48 c1 e0 06          	shl    rax,0x6
	g->period = slm_usec2cyc(period);
  41439c:	48 c1 e3 07          	shl    rbx,0x7
  4143a0:	48 63 80 f8 65 71 00 	movsxd rax,DWORD PTR [rax+0x7165f8]
  4143a7:	48 81 c3 00 ab 70 00 	add    rbx,0x70ab00
  4143ae:	48 69 c0 10 27 00 00 	imul   rax,rax,0x2710
  4143b5:	48 89 83 60 06 00 00 	mov    QWORD PTR [rbx+0x660],rax
	heap_init(&g->h, MAX_NUM_THREADS, __slm_timeout_compare_min, __slm_timeout_update_idx);
  4143bc:	e8 1f 1d 00 00       	call   4160e0 <heap_init>
	__asm__ __volatile__("rdtsc" : "=a" (a), "=d" (d), "=c" (c) : : );
  4143c1:	0f 31                	rdtsc  
	next_timeout = slm_now() + g->period;
  4143c3:	48 8b b3 60 06 00 00 	mov    rsi,QWORD PTR [rbx+0x660]
	return ((u64_t)d << 32) | (u64_t)a;
  4143ca:	48 c1 e2 20          	shl    rdx,0x20
  4143ce:	48 09 c2             	or     rdx,rax
  4143d1:	48 01 d6             	add    rsi,rdx
	g->current_timeout = next_timeout;
  4143d4:	48 89 b3 68 06 00 00 	mov    QWORD PTR [rbx+0x668],rsi
  4143db:	0f 01 f9             	rdtscp 
	g->timer_next   = timeout;
  4143de:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  4143e4:	ba 01 00 00 00       	mov    edx,0x1
  4143e9:	66 48 0f 6e c6       	movq   xmm0,rsi
	/* 10ms */
	slm_policy_timer_init(10000);

	return 0;
}
  4143ee:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
  4143f2:	48 8d 04 89          	lea    rax,[rcx+rcx*4]
  4143f6:	48 c1 e0 06          	shl    rax,0x6
  4143fa:	48 85 f6             	test   rsi,rsi
	g->timer_set    = 1;
  4143fd:	c7 80 fc 65 71 00 01 	mov    DWORD PTR [rax+0x7165fc],0x1
  414404:	00 00 00 
	g->timer_next   = timeout;
  414407:	48 0f 45 d6          	cmovne rdx,rsi
  41440b:	66 48 0f 6e ca       	movq   xmm1,rdx
  414410:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  414414:	0f 29 80 00 66 71 00 	movaps XMMWORD PTR [rax+0x716600],xmm0
  41441b:	31 c0                	xor    eax,eax
  41441d:	c9                   	leave  
  41441e:	c3                   	ret    
  41441f:	90                   	nop

0000000000414420 <prints.isra.0>:
prints(char *s)
  414420:	55                   	push   rbp
  414421:	48 89 e5             	mov    rbp,rsp
  414424:	41 54                	push   r12
  414426:	49 89 fc             	mov    r12,rdi
  414429:	48 83 ec 08          	sub    rsp,0x8
	return cos_print_str(s, strlen(s));
  41442d:	e8 0e 2e 00 00       	call   417240 <strlen>
  414432:	4c 89 e7             	mov    rdi,r12
}
  414435:	4c 8b 65 f8          	mov    r12,QWORD PTR [rbp-0x8]
  414439:	c9                   	leave  
	return cos_print_str(s, strlen(s));
  41443a:	89 c6                	mov    esi,eax
  41443c:	e9 3f 68 ff ff       	jmp    40ac80 <cos_print_str>
  414441:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  414448:	00 00 00 00 
  41444c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000414450 <slm_sched_loop_intern>:
	return (unsigned long)g->cyc_per_usec;
}

static void
slm_sched_loop_intern(int non_block)
{
  414450:	55                   	push   rbp
  414451:	48 89 e5             	mov    rbp,rsp
  414454:	41 57                	push   r15
  414456:	41 56                	push   r14
  414458:	41 55                	push   r13
  41445a:	41 54                	push   r12
  41445c:	53                   	push   rbx
  41445d:	48 83 ec 68          	sub    rsp,0x68
  414461:	0f 01 f9             	rdtscp 
	struct slm_global *g = slm_global();
	rcv_flags_t      rfl = (non_block ? RCV_NON_BLOCKING : 0) | RCV_ALL_PENDING;
  414464:	8d 47 02             	lea    eax,[rdi+0x2]
  414467:	89 45 ac             	mov    DWORD PTR [rbp-0x54],eax
	struct slm_thd   *us = &g->sched_thd;
  41446a:	48 89 c8             	mov    rax,rcx
	struct slm_thd *t = NULL, *tn = NULL;

	/* Only the scheduler thread should call this function. */
	assert(cos_thdid() == us->tid);
  41446d:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  414473:	25 ff 0f 00 00       	and    eax,0xfff
  414478:	48 8d 04 80          	lea    rax,[rax+rax*4]
  41447c:	48 c1 e0 06          	shl    rax,0x6
	struct slm_thd   *us = &g->sched_thd;
  414480:	48 8d 98 08 65 71 00 	lea    rbx,[rax+0x716508]
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  414487:	48 89 e6             	mov    rsi,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  41448a:	48 81 e6 00 e0 ff ff 	and    rsi,0xffffffffffffe000
  414491:	48 89 5d a0          	mov    QWORD PTR [rbp-0x60],rbx
	return cos_get_thd_id();
  414495:	0f b7 b6 f0 1f 00 00 	movzx  esi,WORD PTR [rsi+0x1ff0]
	assert(cos_thdid() == us->tid);
  41449c:	48 39 b0 20 65 71 00 	cmp    QWORD PTR [rax+0x716520],rsi
  4144a3:	0f 85 1b 06 00 00    	jne    414ac4 <slm_sched_loop_intern+0x674>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  4144a9:	48 69 c9 40 01 00 00 	imul   rcx,rcx,0x140
			 * mapping ;-(
			 */
			t = slm_thd_lookup(tid);
			assert(t);
			/* don't report the idle thread or a freed thread */
			if (unlikely(t == &g->idle_thd || slm_state_is_dead(t->state))) goto pending_events;
  4144b0:	48 8d 98 80 65 71 00 	lea    rbx,[rax+0x716580]
  4144b7:	4c 8d b8 00 65 71 00 	lea    r15,[rax+0x716500]
			 */
			slm_thd_event_enqueue(t, blocked, cycles, thd_timeout);

pending_events:
			/* No events? make a scheduling decision */
			if (ps_list_head_empty(&g->event_head)) break;
  4144be:	4c 8d b0 10 66 71 00 	lea    r14,[rax+0x716610]
			if (unlikely(t == &g->idle_thd || slm_state_is_dead(t->state))) goto pending_events;
  4144c5:	48 89 5d 98          	mov    QWORD PTR [rbp-0x68],rbx
			 *
			 * Thus we process the events now, with the CS taken.
			 */
			if (slm_cs_enter(us, SLM_CS_SCHEDEVT)) continue;

			ps_list_foreach_del(&g->event_head, t, tn, thd_list) {
  4144c9:	48 05 b8 65 71 00    	add    rax,0x7165b8
  4144cf:	48 89 45 90          	mov    QWORD PTR [rbp-0x70],rax
  4144d3:	48 8d 81 00 65 71 00 	lea    rax,[rcx+0x716500]
  4144da:	48 89 45 88          	mov    QWORD PTR [rbp-0x78],rax
			pending = cos_sched_rcv(us->rcv, rfl, g->timeout_next, &rcvd, &tid, &blocked, &cycles, &thd_timeout);
  4144de:	48 8d 45 c8          	lea    rax,[rbp-0x38]
  4144e2:	49 8b 7f 28          	mov    rdi,QWORD PTR [r15+0x28]
  4144e6:	8b 75 ac             	mov    esi,DWORD PTR [rbp-0x54]
  4144e9:	48 8d 4d b4          	lea    rcx,[rbp-0x4c]
  4144ed:	50                   	push   rax
  4144ee:	48 8d 45 c0          	lea    rax,[rbp-0x40]
  4144f2:	49 8b 97 08 01 00 00 	mov    rdx,QWORD PTR [r15+0x108]
  4144f9:	4c 8d 4d b0          	lea    r9,[rbp-0x50]
  4144fd:	50                   	push   rax
  4144fe:	4c 8d 45 b8          	lea    r8,[rbp-0x48]
  414502:	e8 59 d7 ff ff       	call   411c60 <cos_sched_rcv>
			if (!tid) goto pending_events;
  414507:	48 8b 7d b8          	mov    rdi,QWORD PTR [rbp-0x48]
  41450b:	5a                   	pop    rdx
			pending = cos_sched_rcv(us->rcv, rfl, g->timeout_next, &rcvd, &tid, &blocked, &cycles, &thd_timeout);
  41450c:	89 c3                	mov    ebx,eax
			if (!tid) goto pending_events;
  41450e:	59                   	pop    rcx
  41450f:	48 85 ff             	test   rdi,rdi
  414512:	74 57                	je     41456b <slm_sched_loop_intern+0x11b>
			t = slm_thd_lookup(tid);
  414514:	e8 e7 d5 fe ff       	call   401b00 <slm_thd_lookup>
  414519:	48 89 c6             	mov    rsi,rax
			assert(t);
  41451c:	48 85 c0             	test   rax,rax
  41451f:	0f 84 b6 05 00 00    	je     414adb <slm_sched_loop_intern+0x68b>
			if (unlikely(t == &g->idle_thd || slm_state_is_dead(t->state))) goto pending_events;
  414525:	48 39 45 98          	cmp    QWORD PTR [rbp-0x68],rax
  414529:	74 40                	je     41456b <slm_sched_loop_intern+0x11b>
  41452b:	f7 40 04 fb ff ff ff 	test   DWORD PTR [rax+0x4],0xfffffffb
  414532:	74 37                	je     41456b <slm_sched_loop_intern+0x11b>
			slm_thd_event_enqueue(t, blocked, cycles, thd_timeout);
  414534:	4c 8b 4d c8          	mov    r9,QWORD PTR [rbp-0x38]
  414538:	48 8b 7d c0          	mov    rdi,QWORD PTR [rbp-0x40]
  41453c:	44 8b 45 b0          	mov    r8d,DWORD PTR [rbp-0x50]
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  414540:	0f 01 f9             	rdtscp 
	if (ps_list_singleton(t, thd_list)) ps_list_head_append(&g->event_head, t, thd_list);
  414543:	48 8d 46 58          	lea    rax,[rsi+0x58]
  414547:	48 3b 46 58          	cmp    rax,QWORD PTR [rsi+0x58]
  41454b:	0f 84 97 04 00 00    	je     4149e8 <slm_sched_loop_intern+0x598>
	t->event_info.cycles += cycles;
  414551:	48 03 7e 48          	add    rdi,QWORD PTR [rsi+0x48]
  414555:	66 49 0f 6e c9       	movq   xmm1,r9
	t->event_info.blocked = blocked;
  41455a:	44 89 46 40          	mov    DWORD PTR [rsi+0x40],r8d
	t->event_info.cycles += cycles;
  41455e:	66 48 0f 6e c7       	movq   xmm0,rdi
  414563:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  414567:	0f 11 46 48          	movups XMMWORD PTR [rsi+0x48],xmm0
			if (ps_list_head_empty(&g->event_head)) break;
  41456b:	4d 3b 36             	cmp    r14,QWORD PTR [r14]
  41456e:	0f 84 9d 01 00 00    	je     414711 <slm_sched_loop_intern+0x2c1>
  414574:	0f 01 f9             	rdtscp 
	cs = &(slm_global()->lock);
  414577:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  41457d:	48 8d 04 89          	lea    rax,[rcx+rcx*4]
  414581:	48 c1 e0 06          	shl    rax,0x6
  414585:	4c 8d a0 00 65 71 00 	lea    r12,[rax+0x716500]
		tok    = cos_sched_sync();
  41458c:	e8 7f d5 ff ff       	call   411b10 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  414591:	49 8b 34 24          	mov    rsi,QWORD PTR [r12]
  414595:	41 89 c0             	mov    r8d,eax
		if (unlikely(owner)) {
  414598:	48 89 f7             	mov    rdi,rsi
  41459b:	48 83 e7 fe          	and    rdi,0xfffffffffffffffe
  41459f:	0f 85 21 01 00 00    	jne    4146c6 <slm_sched_loop_intern+0x276>
        __asm__ __volatile__("lock " PS_CAS_STR
  4145a5:	48 8b 55 a0          	mov    rdx,QWORD PTR [rbp-0x60]
  4145a9:	48 89 f0             	mov    rax,rsi
  4145ac:	f0 49 0f b1 14 24    	lock cmpxchg QWORD PTR [r12],rdx
  4145b2:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4145b5:	84 c0                	test   al,al
  4145b7:	74 d3                	je     41458c <slm_sched_loop_intern+0x13c>
			ps_list_foreach_del(&g->event_head, t, tn, thd_list) {
  4145b9:	48 8b 45 88          	mov    rax,QWORD PTR [rbp-0x78]
  4145bd:	48 8b 80 10 01 00 00 	mov    rax,QWORD PTR [rax+0x110]
  4145c4:	4c 8d 68 a8          	lea    r13,[rax-0x58]
  4145c8:	48 8b 00             	mov    rax,QWORD PTR [rax]
  4145cb:	4c 8d 60 a8          	lea    r12,[rax-0x58]
  4145cf:	4c 3b 6d 90          	cmp    r13,QWORD PTR [rbp-0x70]
  4145d3:	0f 84 47 04 00 00    	je     414a20 <slm_sched_loop_intern+0x5d0>
  4145d9:	89 5d 80             	mov    DWORD PTR [rbp-0x80],ebx
  4145dc:	48 8b 5d 90          	mov    rbx,QWORD PTR [rbp-0x70]
	l->n->p = l->p;
  4145e0:	49 8b 55 60          	mov    rdx,QWORD PTR [r13+0x60]
	ps_list_rem(t, thd_list);
  4145e4:	49 8d 4d 58          	lea    rcx,[r13+0x58]
	*cycles  = t->event_info.cycles;
  4145e8:	49 8b 75 48          	mov    rsi,QWORD PTR [r13+0x48]
	ps_list_rem(t, thd_list);
  4145ec:	66 48 0f 6e c1       	movq   xmm0,rcx
  4145f1:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
	l->p = l->n = l;
  4145f5:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
	l->p->n = l->n;
  4145f9:	48 89 02             	mov    QWORD PTR [rdx],rax
	*blocked = t->event_info.blocked;
  4145fc:	41 8b 45 40          	mov    eax,DWORD PTR [r13+0x40]
	l->p = l->n = l;
  414600:	41 0f 11 45 58       	movups XMMWORD PTR [r13+0x58],xmm0
	memset(&t->event_info, 0, sizeof(struct event_info));
  414605:	66 0f ef c0          	pxor   xmm0,xmm0
	*blocked = t->event_info.blocked;
  414609:	89 45 b0             	mov    DWORD PTR [rbp-0x50],eax
	*timeout = t->event_info.timeout;
  41460c:	49 8b 45 50          	mov    rax,QWORD PTR [r13+0x50]
	*cycles  = t->event_info.cycles;
  414610:	48 89 75 c0          	mov    QWORD PTR [rbp-0x40],rsi
	*timeout = t->event_info.timeout;
  414614:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
	memset(&t->event_info, 0, sizeof(struct event_info));
  414618:	49 c7 45 50 00 00 00 	mov    QWORD PTR [r13+0x50],0x0
  41461f:	00 
  414620:	41 0f 11 45 40       	movups XMMWORD PTR [r13+0x40],xmm0
				/* remove the event from the list and get event info */
				slm_thd_event_dequeue(t, &blocked, &cycles, &thd_timeout);

				/* outdated event for a freed thread */
				if (unlikely(slm_state_is_dead(t->state))) continue;
  414625:	41 f7 45 04 fb ff ff 	test   DWORD PTR [r13+0x4],0xfffffffb
  41462c:	ff 
  41462d:	74 7a                	je     4146a9 <slm_sched_loop_intern+0x259>

				/* Notify the policy that some execution has happened. */
				slm_sched_execution(t, cycles);
  41462f:	4c 89 ef             	mov    rdi,r13
  414632:	e8 b9 d4 fe ff       	call   401af0 <slm_sched_execution>

				if (blocked) {
  414637:	8b 45 b0             	mov    eax,DWORD PTR [rbp-0x50]
  41463a:	85 c0                	test   eax,eax
  41463c:	0f 84 65 03 00 00    	je     4149a7 <slm_sched_loop_intern+0x557>
					assert(cycles);
  414642:	48 83 7d c0 00       	cmp    QWORD PTR [rbp-0x40],0x0
  414647:	0f 84 a5 04 00 00    	je     414af2 <slm_sched_loop_intern+0x6a2>
	assert(slm_state_is_runnable(t->state) || t->state == SLM_THD_BLOCKED);
  41464d:	41 8b 45 04          	mov    eax,DWORD PTR [r13+0x4]
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  414651:	8d 70 fe             	lea    esi,[rax-0x2]
  414654:	83 e8 01             	sub    eax,0x1
  414657:	83 f8 02             	cmp    eax,0x2
  41465a:	0f 87 28 06 00 00    	ja     414c88 <slm_sched_loop_intern+0x838>
  414660:	0f 01 f9             	rdtscp 
	return t != &g->idle_thd && t != &g->sched_thd;
  414663:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  414669:	48 69 c1 40 01 00 00 	imul   rax,rcx,0x140
  414670:	48 8d 90 80 65 71 00 	lea    rdx,[rax+0x716580]
  414677:	49 39 d5             	cmp    r13,rdx
  41467a:	0f 84 89 04 00 00    	je     414b09 <slm_sched_loop_intern+0x6b9>
  414680:	48 05 08 65 71 00    	add    rax,0x716508
  414686:	49 39 c5             	cmp    r13,rax
  414689:	0f 84 7a 04 00 00    	je     414b09 <slm_sched_loop_intern+0x6b9>
	if (likely(slm_state_is_runnable(t->state))) {
  41468f:	83 fe 01             	cmp    esi,0x1
  414692:	77 08                	ja     41469c <slm_sched_loop_intern+0x24c>
		slm_sched_block(t);
  414694:	4c 89 ef             	mov    rdi,r13
  414697:	e8 14 d4 fe ff       	call   401ab0 <slm_sched_block>
	t->properties |= SLM_THD_PROPERTY_SUSPENDED;
  41469c:	41 83 4d 00 04       	or     DWORD PTR [r13+0x0],0x4
	t->state       = SLM_THD_BLOCKED;
  4146a1:	41 c7 45 04 01 00 00 	mov    DWORD PTR [r13+0x4],0x1
  4146a8:	00 
			ps_list_foreach_del(&g->event_head, t, tn, thd_list) {
  4146a9:	49 8b 44 24 58       	mov    rax,QWORD PTR [r12+0x58]
  4146ae:	4d 89 e5             	mov    r13,r12
  4146b1:	48 8d 50 a8          	lea    rdx,[rax-0x58]
  4146b5:	49 39 dc             	cmp    r12,rbx
  4146b8:	0f 84 5f 03 00 00    	je     414a1d <slm_sched_loop_intern+0x5cd>
  4146be:	49 89 d4             	mov    r12,rdx
  4146c1:	e9 1a ff ff ff       	jmp    4145e0 <slm_sched_loop_intern+0x190>
  4146c6:	0f 01 f9             	rdtscp 
	if (!contended) {
  4146c9:	40 f6 c6 01          	test   sil,0x1
  4146cd:	75 1b                	jne    4146ea <slm_sched_loop_intern+0x29a>
	return !ps_cas(&cs->owner_contention, (unsigned long)cached, ((unsigned long)thd | !!contention));
  4146cf:	48 89 fa             	mov    rdx,rdi
  4146d2:	48 89 f0             	mov    rax,rsi
  4146d5:	48 83 ca 01          	or     rdx,0x1
  4146d9:	f0 49 0f b1 14 24    	lock cmpxchg QWORD PTR [r12],rdx
  4146df:	0f 94 c0             	sete   al
		if (__slm_cs_cas(cs, cached, owner, 1)) return 1;
  4146e2:	84 c0                	test   al,al
  4146e4:	0f 84 a2 fe ff ff    	je     41458c <slm_sched_loop_intern+0x13c>
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  4146ea:	48 8b 45 88          	mov    rax,QWORD PTR [rbp-0x78]
  4146ee:	48 8b 7f 10          	mov    rdi,QWORD PTR [rdi+0x10]
  4146f2:	31 d2                	xor    edx,edx
  4146f4:	44 89 c1             	mov    ecx,r8d
  4146f7:	48 8b 70 38          	mov    rsi,QWORD PTR [rax+0x38]
  4146fb:	e8 a0 7f ff ff       	call   40c6a0 <cos_defswitch>
			if (flags & SLM_CS_SCHEDEVT && ret == -EBUSY) return ret;
  414700:	83 f8 f0             	cmp    eax,0xfffffff0
  414703:	0f 85 83 fe ff ff    	jne    41458c <slm_sched_loop_intern+0x13c>
					slm_thd_sched_wakeup(t);
				}
			}

			slm_cs_exit(us, SLM_CS_NONE);
		} while (pending > 0);
  414709:	85 db                	test   ebx,ebx
  41470b:	0f 8f cd fd ff ff    	jg     4144de <slm_sched_loop_intern+0x8e>
  414711:	0f 01 f9             	rdtscp 
	return &__slm_global[cos_coreid()];
  414714:	89 ce                	mov    esi,ecx
	while ((ret = slm_cs_enter(&slm_global()->sched_thd, SLM_CS_SCHEDEVT))) {
  414716:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  41471c:	48 8d 1c 89          	lea    rbx,[rcx+rcx*4]
  414720:	81 e6 ff 0f 00 00    	and    esi,0xfff
  414726:	48 c1 e3 06          	shl    rbx,0x6
  41472a:	48 81 c3 08 65 71 00 	add    rbx,0x716508
  414731:	0f 01 f9             	rdtscp 
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  414734:	4c 63 e6             	movsxd r12,esi
	cs = &(slm_global()->lock);
  414737:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  41473d:	4d 69 e4 40 01 00 00 	imul   r12,r12,0x140
  414744:	4c 8d 2c 89          	lea    r13,[rcx+rcx*4]
  414748:	49 c1 e5 06          	shl    r13,0x6
  41474c:	49 81 c5 00 65 71 00 	add    r13,0x716500
  414753:	49 81 c4 00 65 71 00 	add    r12,0x716500
		tok    = cos_sched_sync();
  41475a:	e8 b1 d3 ff ff       	call   411b10 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  41475f:	49 8b 75 00          	mov    rsi,QWORD PTR [r13+0x0]
  414763:	41 89 c0             	mov    r8d,eax
		if (unlikely(owner)) {
  414766:	48 89 f7             	mov    rdi,rsi
  414769:	48 83 e7 fe          	and    rdi,0xfffffffffffffffe
  41476d:	0f 85 ef 01 00 00    	jne    414962 <slm_sched_loop_intern+0x512>
  414773:	48 89 f0             	mov    rax,rsi
  414776:	f0 49 0f b1 5d 00    	lock cmpxchg QWORD PTR [r13+0x0],rbx
  41477c:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  41477f:	84 c0                	test   al,al
  414781:	74 d7                	je     41475a <slm_sched_loop_intern+0x30a>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  414783:	e8 c8 6d ff ff       	call   40b550 <cos_defcompinfo_curr_get>
  414788:	0f 01 f9             	rdtscp 
	if (unlikely(!t)) t = &g->idle_thd;
  41478b:	48 89 c8             	mov    rax,rcx
  41478e:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  414794:	25 ff 0f 00 00       	and    eax,0xfff
	if (flags & SLM_CS_CHECK_TIMEOUT && g->timer_set) {
  414799:	4c 69 e1 40 01 00 00 	imul   r12,rcx,0x140
	if (unlikely(!t)) t = &g->idle_thd;
  4147a0:	48 69 c0 40 01 00 00 	imul   rax,rax,0x140
  4147a7:	48 05 80 65 71 00    	add    rax,0x716580
  4147ad:	48 89 85 78 ff ff ff 	mov    QWORD PTR [rbp-0x88],rax
	if (flags & SLM_CS_CHECK_TIMEOUT && g->timer_set) {
  4147b4:	49 8d 84 24 00 65 71 	lea    rax,[r12+0x716500]
  4147bb:	00 
  4147bc:	48 89 45 80          	mov    QWORD PTR [rbp-0x80],rax
	tok  = cos_sched_sync();
  4147c0:	e8 4b d3 ff ff       	call   411b10 <cos_sched_sync>
	if (flags & SLM_CS_CHECK_TIMEOUT && g->timer_set) {
  4147c5:	48 8b 5d 80          	mov    rbx,QWORD PTR [rbp-0x80]
	tok  = cos_sched_sync();
  4147c9:	41 89 c4             	mov    r12d,eax
	if (flags & SLM_CS_CHECK_TIMEOUT && g->timer_set) {
  4147cc:	83 bb fc 00 00 00 00 	cmp    DWORD PTR [rbx+0xfc],0x0
  4147d3:	74 26                	je     4147fb <slm_sched_loop_intern+0x3ab>
	__asm__ __volatile__("rdtsc" : "=a" (a), "=d" (d), "=c" (c) : : );
  4147d5:	0f 31                	rdtsc  
	return ((u64_t)d << 32) | (u64_t)a;
  4147d7:	48 c1 e2 20          	shl    rdx,0x20
  4147db:	48 09 c2             	or     rdx,rax
  4147de:	48 8b 83 00 01 00 00 	mov    rax,QWORD PTR [rbx+0x100]
  4147e5:	48 89 d7             	mov    rdi,rdx
  4147e8:	48 89 85 70 ff ff ff 	mov    QWORD PTR [rbp-0x90],rax
  4147ef:	48 29 d0             	sub    rax,rdx
		if (!cycles_greater_than(g->timer_next, now)) {
  4147f2:	48 85 c0             	test   rax,rax
  4147f5:	0f 8e 46 03 00 00    	jle    414b41 <slm_sched_loop_intern+0x6f1>
	t = slm_sched_schedule();
  4147fb:	e8 e0 d2 fe ff       	call   401ae0 <slm_sched_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  414800:	48 85 c0             	test   rax,rax
	t = slm_sched_schedule();
  414803:	48 89 c3             	mov    rbx,rax
	if (unlikely(!t)) t = &g->idle_thd;
  414806:	48 0f 44 9d 78 ff ff 	cmove  rbx,QWORD PTR [rbp-0x88]
  41480d:	ff 
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  41480e:	8b 43 04             	mov    eax,DWORD PTR [rbx+0x4]
  414811:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  414814:	83 f8 01             	cmp    eax,0x1
  414817:	0f 87 08 03 00 00    	ja     414b25 <slm_sched_loop_intern+0x6d5>
  41481d:	0f 01 f9             	rdtscp 
	struct slm_cs *cs = &(slm_global()->lock);
  414820:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  414826:	48 69 f9 40 01 00 00 	imul   rdi,rcx,0x140
  41482d:	4c 8d af 00 65 71 00 	lea    r13,[rdi+0x716500]
	while (ret != 0) {
  414834:	eb 1a                	jmp    414850 <slm_sched_loop_intern+0x400>
  414836:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41483d:	00 00 00 
        __asm__ __volatile__("lock " PS_CAS_STR
  414840:	48 89 f0             	mov    rax,rsi
  414843:	f0 49 0f b1 55 00    	lock cmpxchg QWORD PTR [r13+0x0],rdx
  414849:	0f 94 c0             	sete   al
  41484c:	84 c0                	test   al,al
  41484e:	75 58                	jne    4148a8 <slm_sched_loop_intern+0x458>
		tok    = cos_sched_sync();
  414850:	e8 bb d2 ff ff       	call   411b10 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  414855:	49 8b 75 00          	mov    rsi,QWORD PTR [r13+0x0]
  414859:	41 89 c0             	mov    r8d,eax
		if (unlikely(contention)) {
  41485c:	48 89 f2             	mov    rdx,rsi
  41485f:	83 e2 01             	and    edx,0x1
  414862:	74 dc                	je     414840 <slm_sched_loop_intern+0x3f0>
  414864:	0f 01 f9             	rdtscp 
  414867:	31 d2                	xor    edx,edx
  414869:	48 89 f0             	mov    rax,rsi
  41486c:	f0 49 0f b1 55 00    	lock cmpxchg QWORD PTR [r13+0x0],rdx
  414872:	0f 94 c0             	sete   al
	if (__slm_cs_cas(cs, cached, NULL, 0)) return 1;
  414875:	84 c0                	test   al,al
  414877:	74 d7                	je     414850 <slm_sched_loop_intern+0x400>
	ret = cos_defswitch(s->thd, curr->priority, TCAP_TIME_NIL, tok);
  414879:	48 89 c8             	mov    rax,rcx
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  41487c:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  414880:	44 89 c1             	mov    ecx,r8d
  414883:	25 ff 0f 00 00       	and    eax,0xfff
  414888:	48 8b 76 30          	mov    rsi,QWORD PTR [rsi+0x30]
  41488c:	48 69 c0 40 01 00 00 	imul   rax,rax,0x140
  414893:	48 8b b8 18 65 71 00 	mov    rdi,QWORD PTR [rax+0x716518]
  41489a:	e8 01 7e ff ff       	call   40c6a0 <cos_defswitch>
	assert(ret != -EINVAL);
  41489f:	83 f8 ea             	cmp    eax,0xffffffea
  4148a2:	0f 84 00 02 00 00    	je     414aa8 <slm_sched_loop_intern+0x658>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  4148a8:	e8 a3 6c ff ff       	call   40b550 <cos_defcompinfo_curr_get>
  4148ad:	0f 01 f9             	rdtscp 
	*coreid = c & 0xFFF;
  4148b0:	89 c8                	mov    eax,ecx
	timeout = g->timeout_next;
  4148b2:	81 e1 ff 0f 00 00    	and    ecx,0xfff
	prio = inherit_prio ? curr->priority : t->priority;
  4148b8:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
	timeout = g->timeout_next;
  4148bc:	48 69 d1 40 01 00 00 	imul   rdx,rcx,0x140
  4148c3:	66 25 ff 0f          	and    ax,0xfff
  4148c7:	49 89 cd             	mov    r13,rcx
  4148ca:	4c 8b 8a 08 66 71 00 	mov    r9,QWORD PTR [rdx+0x716608]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  4148d1:	8b 13                	mov    edx,DWORD PTR [rbx]
  4148d3:	f6 c2 0b             	test   dl,0xb
  4148d6:	0f 85 a2 02 00 00    	jne    414b7e <slm_sched_loop_intern+0x72e>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  4148dc:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  4148e0:	44 89 e1             	mov    ecx,r12d
  4148e3:	4c 89 ca             	mov    rdx,r9
  4148e6:	e8 b5 7d ff ff       	call   40c6a0 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  4148eb:	83 f8 ff             	cmp    eax,0xffffffff
  4148ee:	0f 84 0c 03 00 00    	je     414c00 <slm_sched_loop_intern+0x7b0>
	if (unlikely(ret != 0)) {
  4148f4:	85 c0                	test   eax,eax
  4148f6:	0f 84 e2 fb ff ff    	je     4144de <slm_sched_loop_intern+0x8e>
		assert(ret != -EINVAL);
  4148fc:	83 f8 ea             	cmp    eax,0xffffffea
  4148ff:	0f 84 19 04 00 00    	je     414d1e <slm_sched_loop_intern+0x8ce>
		if (ret == -EBUSY) return ret;
  414905:	83 f8 f0             	cmp    eax,0xfffffff0
  414908:	0f 84 d0 fb ff ff    	je     4144de <slm_sched_loop_intern+0x8e>
		assert(ret == -EAGAIN);
  41490e:	83 f8 f5             	cmp    eax,0xfffffff5
  414911:	0f 85 eb 03 00 00    	jne    414d02 <slm_sched_loop_intern+0x8b2>
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  414917:	0f 01 f9             	rdtscp 
	cs = &(slm_global()->lock);
  41491a:	48 89 cb             	mov    rbx,rcx
  41491d:	81 e3 ff 0f 00 00    	and    ebx,0xfff
  414923:	48 69 db 40 01 00 00 	imul   rbx,rbx,0x140
  41492a:	48 81 c3 00 65 71 00 	add    rbx,0x716500
		tok    = cos_sched_sync();
  414931:	e8 da d1 ff ff       	call   411b10 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  414936:	48 8b 33             	mov    rsi,QWORD PTR [rbx]
  414939:	41 89 c0             	mov    r8d,eax
		if (unlikely(owner)) {
  41493c:	48 89 f7             	mov    rdi,rsi
  41493f:	48 83 e7 fe          	and    rdi,0xfffffffffffffffe
  414943:	0f 85 5b 03 00 00    	jne    414ca4 <slm_sched_loop_intern+0x854>
  414949:	48 8b 4d a0          	mov    rcx,QWORD PTR [rbp-0x60]
  41494d:	48 89 f0             	mov    rax,rsi
  414950:	f0 48 0f b1 0b       	lock cmpxchg QWORD PTR [rbx],rcx
  414955:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  414958:	84 c0                	test   al,al
  41495a:	0f 85 60 fe ff ff    	jne    4147c0 <slm_sched_loop_intern+0x370>
  414960:	eb cf                	jmp    414931 <slm_sched_loop_intern+0x4e1>
  414962:	0f 01 f9             	rdtscp 
	if (!contended) {
  414965:	40 f6 c6 01          	test   sil,0x1
  414969:	75 1b                	jne    414986 <slm_sched_loop_intern+0x536>
	return !ps_cas(&cs->owner_contention, (unsigned long)cached, ((unsigned long)thd | !!contention));
  41496b:	48 89 fa             	mov    rdx,rdi
  41496e:	48 89 f0             	mov    rax,rsi
  414971:	48 83 ca 01          	or     rdx,0x1
  414975:	f0 49 0f b1 55 00    	lock cmpxchg QWORD PTR [r13+0x0],rdx
  41497b:	0f 94 c0             	sete   al
		if (__slm_cs_cas(cs, cached, owner, 1)) return 1;
  41497e:	84 c0                	test   al,al
  414980:	0f 84 d4 fd ff ff    	je     41475a <slm_sched_loop_intern+0x30a>
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  414986:	48 8b 7f 10          	mov    rdi,QWORD PTR [rdi+0x10]
  41498a:	49 8b 74 24 38       	mov    rsi,QWORD PTR [r12+0x38]
  41498f:	31 d2                	xor    edx,edx
  414991:	44 89 c1             	mov    ecx,r8d
  414994:	e8 07 7d ff ff       	call   40c6a0 <cos_defswitch>
			if (flags & SLM_CS_SCHEDEVT && ret == -EBUSY) return ret;
  414999:	83 f8 f0             	cmp    eax,0xfffffff0
  41499c:	0f 85 b8 fd ff ff    	jne    41475a <slm_sched_loop_intern+0x30a>
  4149a2:	e9 37 fb ff ff       	jmp    4144de <slm_sched_loop_intern+0x8e>
	if (unlikely(!(t->properties & SLM_THD_PROPERTY_SUSPENDED))) return 1;
  4149a7:	41 8b 45 00          	mov    eax,DWORD PTR [r13+0x0]
  4149ab:	a8 04                	test   al,0x4
  4149ad:	0f 84 f6 fc ff ff    	je     4146a9 <slm_sched_loop_intern+0x259>
	t->properties &= ~SLM_THD_PROPERTY_SUSPENDED;
  4149b3:	83 e0 fb             	and    eax,0xfffffffb
  4149b6:	41 89 45 00          	mov    DWORD PTR [r13+0x0],eax
	if (unlikely(slm_state_is_runnable(t->state))) {
  4149ba:	41 8b 45 04          	mov    eax,DWORD PTR [r13+0x4]
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  4149be:	8d 50 fe             	lea    edx,[rax-0x2]
  4149c1:	83 fa 01             	cmp    edx,0x1
  4149c4:	0f 86 8b 01 00 00    	jbe    414b55 <slm_sched_loop_intern+0x705>
	assert(t->state == SLM_THD_BLOCKED);
  4149ca:	83 e8 01             	sub    eax,0x1
  4149cd:	0f 85 8f 01 00 00    	jne    414b62 <slm_sched_loop_intern+0x712>
	t->state = SLM_THD_RUNNABLE;
  4149d3:	41 c7 45 04 03 00 00 	mov    DWORD PTR [r13+0x4],0x3
  4149da:	00 
	slm_sched_wakeup(t);
  4149db:	4c 89 ef             	mov    rdi,r13
  4149de:	e8 dd d0 fe ff       	call   401ac0 <slm_sched_wakeup>
	return 0;
  4149e3:	e9 c1 fc ff ff       	jmp    4146a9 <slm_sched_loop_intern+0x259>
	if (ps_list_singleton(t, thd_list)) ps_list_head_append(&g->event_head, t, thd_list);
  4149e8:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  4149ee:	48 69 d1 40 01 00 00 	imul   rdx,rcx,0x140
  4149f5:	48 8b 92 18 66 71 00 	mov    rdx,QWORD PTR [rdx+0x716618]
	new->n    = l->n;
  4149fc:	f3 0f 7e 02          	movq   xmm0,QWORD PTR [rdx]
  414a00:	66 48 0f 6e d2       	movq   xmm2,rdx
  414a05:	66 0f 6c c2          	punpcklqdq xmm0,xmm2
  414a09:	0f 11 46 58          	movups XMMWORD PTR [rsi+0x58],xmm0
	l->n      = new;
  414a0d:	48 89 02             	mov    QWORD PTR [rdx],rax
	new->n->p = new;
  414a10:	48 8b 56 58          	mov    rdx,QWORD PTR [rsi+0x58]
  414a14:	48 89 42 08          	mov    QWORD PTR [rdx+0x8],rax
}
  414a18:	e9 34 fb ff ff       	jmp    414551 <slm_sched_loop_intern+0x101>
  414a1d:	8b 5d 80             	mov    ebx,DWORD PTR [rbp-0x80]
  414a20:	0f 01 f9             	rdtscp 
	struct slm_cs *cs = &(slm_global()->lock);
  414a23:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  414a29:	45 31 e4             	xor    r12d,r12d
  414a2c:	4c 69 e9 40 01 00 00 	imul   r13,rcx,0x140
  414a33:	49 81 c5 00 65 71 00 	add    r13,0x716500
	while (ret != 0) {
  414a3a:	eb 14                	jmp    414a50 <slm_sched_loop_intern+0x600>
  414a3c:	48 89 f0             	mov    rax,rsi
  414a3f:	f0 49 0f b1 55 00    	lock cmpxchg QWORD PTR [r13+0x0],rdx
  414a45:	0f 94 c0             	sete   al
  414a48:	84 c0                	test   al,al
  414a4a:	0f 85 b9 fc ff ff    	jne    414709 <slm_sched_loop_intern+0x2b9>
		tok    = cos_sched_sync();
  414a50:	e8 bb d0 ff ff       	call   411b10 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  414a55:	49 8b 75 00          	mov    rsi,QWORD PTR [r13+0x0]
  414a59:	41 89 c0             	mov    r8d,eax
		if (unlikely(contention)) {
  414a5c:	48 89 f2             	mov    rdx,rsi
  414a5f:	83 e2 01             	and    edx,0x1
  414a62:	74 d8                	je     414a3c <slm_sched_loop_intern+0x5ec>
  414a64:	0f 01 f9             	rdtscp 
  414a67:	48 89 f0             	mov    rax,rsi
  414a6a:	f0 4d 0f b1 65 00    	lock cmpxchg QWORD PTR [r13+0x0],r12
  414a70:	0f 94 c0             	sete   al
	if (__slm_cs_cas(cs, cached, NULL, 0)) return 1;
  414a73:	84 c0                	test   al,al
  414a75:	74 d9                	je     414a50 <slm_sched_loop_intern+0x600>
	ret = cos_defswitch(s->thd, curr->priority, TCAP_TIME_NIL, tok);
  414a77:	48 89 c8             	mov    rax,rcx
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  414a7a:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  414a7e:	31 d2                	xor    edx,edx
  414a80:	44 89 c1             	mov    ecx,r8d
  414a83:	25 ff 0f 00 00       	and    eax,0xfff
  414a88:	48 8b 76 30          	mov    rsi,QWORD PTR [rsi+0x30]
  414a8c:	48 69 c0 40 01 00 00 	imul   rax,rax,0x140
  414a93:	48 8b b8 18 65 71 00 	mov    rdi,QWORD PTR [rax+0x716518]
  414a9a:	e8 01 7c ff ff       	call   40c6a0 <cos_defswitch>
	assert(ret != -EINVAL);
  414a9f:	83 f8 ea             	cmp    eax,0xffffffea
  414aa2:	0f 85 61 fc ff ff    	jne    414709 <slm_sched_loop_intern+0x2b9>
  414aa8:	be 23 00 00 00       	mov    esi,0x23
  414aad:	bf 98 f6 41 00       	mov    edi,0x41f698
  414ab2:	e8 c9 61 ff ff       	call   40ac80 <cos_print_str>
  414ab7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414abe:	00 00 00 00 
  414ac2:	0f 0b                	ud2    
	assert(cos_thdid() == us->tid);
  414ac4:	bf d0 f5 41 00       	mov    edi,0x41f5d0
  414ac9:	e8 52 f9 ff ff       	call   414420 <prints.isra.0>
  414ace:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414ad5:	00 00 00 00 
  414ad9:	0f 0b                	ud2    
			assert(t);
  414adb:	bf f8 f5 41 00       	mov    edi,0x41f5f8
  414ae0:	e8 3b f9 ff ff       	call   414420 <prints.isra.0>
  414ae5:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414aec:	00 00 00 00 
  414af0:	0f 0b                	ud2    
					assert(cycles);
  414af2:	bf 20 f6 41 00       	mov    edi,0x41f620
  414af7:	e8 24 f9 ff ff       	call   414420 <prints.isra.0>
  414afc:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414b03:	00 00 00 00 
  414b07:	0f 0b                	ud2    
  414b09:	be 23 00 00 00       	mov    esi,0x23
  414b0e:	bf a8 f7 41 00       	mov    edi,0x41f7a8
  414b13:	e8 68 61 ff ff       	call   40ac80 <cos_print_str>
	assert(slm_thd_normal(t));
  414b18:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414b1f:	00 00 00 00 
  414b23:	0f 0b                	ud2    
  414b25:	be 2d 00 00 00       	mov    esi,0x2d
  414b2a:	bf c0 f6 41 00       	mov    edi,0x41f6c0
  414b2f:	e8 4c 61 ff ff       	call   40ac80 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  414b34:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414b3b:	00 00 00 00 
  414b3f:	0f 0b                	ud2    
			g->timer_set = 0;
  414b41:	c7 83 fc 00 00 00 00 	mov    DWORD PTR [rbx+0xfc],0x0
  414b48:	00 00 00 
			slm_timer_expire(now);
  414b4b:	e8 c0 ce fe ff       	call   401a10 <slm_timer_expire>
  414b50:	e9 a6 fc ff ff       	jmp    4147fb <slm_sched_loop_intern+0x3ab>
		t->state = SLM_THD_RUNNABLE;
  414b55:	41 c7 45 04 03 00 00 	mov    DWORD PTR [r13+0x4],0x3
  414b5c:	00 
		return 1;
  414b5d:	e9 47 fb ff ff       	jmp    4146a9 <slm_sched_loop_intern+0x259>
  414b62:	be 23 00 00 00       	mov    esi,0x23
  414b67:	bf 70 f6 41 00       	mov    edi,0x41f670
  414b6c:	e8 0f 61 ff ff       	call   40ac80 <cos_print_str>
	assert(t->state == SLM_THD_BLOCKED);
  414b71:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414b78:	00 00 00 00 
  414b7c:	0f 0b                	ud2    
		if (t == &g->sched_thd) {
  414b7e:	0f b7 c0             	movzx  eax,ax
	timeout = g->timeout_next;
  414b81:	4c 89 c9             	mov    rcx,r9
		if (t == &g->sched_thd) {
  414b84:	48 69 c0 40 01 00 00 	imul   rax,rax,0x140
  414b8b:	48 05 08 65 71 00    	add    rax,0x716508
  414b91:	48 39 c3             	cmp    rbx,rax
  414b94:	0f 84 df 00 00 00    	je     414c79 <slm_sched_loop_intern+0x829>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  414b9a:	f6 c2 02             	test   dl,0x2
  414b9d:	0f 85 b4 00 00 00    	jne    414c57 <slm_sched_loop_intern+0x807>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  414ba3:	80 e2 01             	and    dl,0x1
  414ba6:	49 89 c9             	mov    r9,rcx
  414ba9:	0f 84 2d fd ff ff    	je     4148dc <slm_sched_loop_intern+0x48c>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  414baf:	4c 8b 53 08          	mov    r10,QWORD PTR [rbx+0x8]
  414bb3:	48 8b 7b 10          	mov    rdi,QWORD PTR [rbx+0x10]
  414bb7:	48 89 f2             	mov    rdx,rsi
  414bba:	45 89 e1             	mov    r9d,r12d
  414bbd:	49 69 c5 40 01 00 00 	imul   rax,r13,0x140
  414bc4:	4c 89 d6             	mov    rsi,r10
  414bc7:	4c 8b 80 28 65 71 00 	mov    r8,QWORD PTR [rax+0x716528]
  414bce:	e8 5d cf ff ff       	call   411b30 <cos_switch>
	if (unlikely(ret != 0)) {
  414bd3:	85 c0                	test   eax,eax
  414bd5:	0f 84 03 f9 ff ff    	je     4144de <slm_sched_loop_intern+0x8e>
		assert(ret != -EPERM);
  414bdb:	83 f8 ff             	cmp    eax,0xffffffff
  414bde:	0f 85 18 fd ff ff    	jne    4148fc <slm_sched_loop_intern+0x4ac>
  414be4:	be 2d 00 00 00       	mov    esi,0x2d
  414be9:	bf f0 f6 41 00       	mov    edi,0x41f6f0
  414bee:	e8 8d 60 ff ff       	call   40ac80 <cos_print_str>
  414bf3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414bfa:	00 00 00 00 
  414bfe:	0f 0b                	ud2    
  414c00:	0f 01 f9             	rdtscp 
	return t != &g->idle_thd && t != &g->sched_thd;
  414c03:	48 89 c8             	mov    rax,rcx
  414c06:	25 ff 0f 00 00       	and    eax,0xfff
  414c0b:	48 69 c0 40 01 00 00 	imul   rax,rax,0x140
  414c12:	48 8d 90 80 65 71 00 	lea    rdx,[rax+0x716580]
  414c19:	48 39 d3             	cmp    rbx,rdx
  414c1c:	74 0b                	je     414c29 <slm_sched_loop_intern+0x7d9>
  414c1e:	48 05 08 65 71 00    	add    rax,0x716508
  414c24:	48 39 c3             	cmp    rbx,rax
  414c27:	75 bb                	jne    414be4 <slm_sched_loop_intern+0x794>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  414c29:	49 69 c5 40 01 00 00 	imul   rax,r13,0x140
  414c30:	48 8b 5d 88          	mov    rbx,QWORD PTR [rbp-0x78]
  414c34:	45 89 e1             	mov    r9d,r12d
  414c37:	31 c9                	xor    ecx,ecx
  414c39:	31 f6                	xor    esi,esi
  414c3b:	48 8b 53 38          	mov    rdx,QWORD PTR [rbx+0x38]
  414c3f:	4c 8b 80 28 65 71 00 	mov    r8,QWORD PTR [rax+0x716528]
  414c46:	48 8b b8 18 65 71 00 	mov    rdi,QWORD PTR [rax+0x716518]
  414c4d:	e8 de ce ff ff       	call   411b30 <cos_switch>
  414c52:	e9 7c ff ff ff       	jmp    414bd3 <slm_sched_loop_intern+0x783>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  414c57:	49 69 c5 40 01 00 00 	imul   rax,r13,0x140
  414c5e:	48 8b 7b 28          	mov    rdi,QWORD PTR [rbx+0x28]
  414c62:	44 89 e1             	mov    ecx,r12d
  414c65:	4c 89 ce             	mov    rsi,r9
  414c68:	48 8b 90 28 65 71 00 	mov    rdx,QWORD PTR [rax+0x716528]
  414c6f:	e8 2c cf ff ff       	call   411ba0 <cos_sched_asnd>
  414c74:	e9 5a ff ff ff       	jmp    414bd3 <slm_sched_loop_intern+0x783>
			prio    = curr->priority;
  414c79:	48 8b 45 88          	mov    rax,QWORD PTR [rbp-0x78]
			timeout = TCAP_TIME_NIL;
  414c7d:	31 c9                	xor    ecx,ecx
			prio    = curr->priority;
  414c7f:	48 8b 70 38          	mov    rsi,QWORD PTR [rax+0x38]
  414c83:	e9 12 ff ff ff       	jmp    414b9a <slm_sched_loop_intern+0x74a>
  414c88:	be 23 00 00 00       	mov    esi,0x23
  414c8d:	bf 48 f6 41 00       	mov    edi,0x41f648
  414c92:	e8 e9 5f ff ff       	call   40ac80 <cos_print_str>
	assert(slm_state_is_runnable(t->state) || t->state == SLM_THD_BLOCKED);
  414c97:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414c9e:	00 00 00 00 
  414ca2:	0f 0b                	ud2    
  414ca4:	0f 01 f9             	rdtscp 
	if (!contended) {
  414ca7:	40 f6 c6 01          	test   sil,0x1
  414cab:	75 1a                	jne    414cc7 <slm_sched_loop_intern+0x877>
	return !ps_cas(&cs->owner_contention, (unsigned long)cached, ((unsigned long)thd | !!contention));
  414cad:	48 89 fa             	mov    rdx,rdi
  414cb0:	48 89 f0             	mov    rax,rsi
  414cb3:	48 83 ca 01          	or     rdx,0x1
  414cb7:	f0 48 0f b1 13       	lock cmpxchg QWORD PTR [rbx],rdx
  414cbc:	0f 94 c0             	sete   al
		if (__slm_cs_cas(cs, cached, owner, 1)) return 1;
  414cbf:	84 c0                	test   al,al
  414cc1:	0f 84 6a fc ff ff    	je     414931 <slm_sched_loop_intern+0x4e1>
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  414cc7:	48 8b 45 88          	mov    rax,QWORD PTR [rbp-0x78]
  414ccb:	48 8b 7f 10          	mov    rdi,QWORD PTR [rdi+0x10]
  414ccf:	31 d2                	xor    edx,edx
  414cd1:	44 89 c1             	mov    ecx,r8d
  414cd4:	48 8b 70 38          	mov    rsi,QWORD PTR [rax+0x38]
  414cd8:	e8 c3 79 ff ff       	call   40c6a0 <cos_defswitch>
			assert(ret != -EBUSY);
  414cdd:	83 f8 f0             	cmp    eax,0xfffffff0
  414ce0:	0f 85 4b fc ff ff    	jne    414931 <slm_sched_loop_intern+0x4e1>
  414ce6:	be 25 00 00 00       	mov    esi,0x25
  414ceb:	bf 80 f7 41 00       	mov    edi,0x41f780
  414cf0:	e8 8b 5f ff ff       	call   40ac80 <cos_print_str>
  414cf5:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414cfc:	00 00 00 00 
  414d00:	0f 0b                	ud2    
  414d02:	be 2d 00 00 00       	mov    esi,0x2d
  414d07:	bf 50 f7 41 00       	mov    edi,0x41f750
  414d0c:	e8 6f 5f ff ff       	call   40ac80 <cos_print_str>
		assert(ret == -EAGAIN);
  414d11:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414d18:	00 00 00 00 
  414d1c:	0f 0b                	ud2    
  414d1e:	be 2d 00 00 00       	mov    esi,0x2d
  414d23:	bf 20 f7 41 00       	mov    edi,0x41f720
  414d28:	e8 53 5f ff ff       	call   40ac80 <cos_print_str>
		assert(ret != -EINVAL);
  414d2d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  414d34:	00 00 00 00 
  414d38:	0f 0b                	ud2    
  414d3a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000414d40 <slm_ipi_event_enqueue>:
{
  414d40:	f3 0f 1e fa          	endbr64 
    return CK_RING_ENQUEUE_MPSC(slm_ipi_ringbuf, &ipi_data->ring, ipi_data->ringbuf, event);
  414d44:	4c 63 d6             	movsxd r10,esi
{
  414d47:	55                   	push   rbp
  414d48:	4d 69 d2 c0 10 00 00 	imul   r10,r10,0x10c0
  414d4f:	48 89 e5             	mov    rbp,rsp
  414d52:	53                   	push   rbx
  414d53:	48 89 fb             	mov    rbx,rdi
    void *buffer,
    const void *entry,
    unsigned int ts,
    unsigned int *size)
{
	const unsigned int mask = ring->mask;
  414d56:	45 8b 82 a4 df 70 00 	mov    r8d,DWORD PTR [r10+0x70dfa4]
  414d5d:	4d 8d 9a a8 00 00 00 	lea    r11,[r10+0xa8]
	unsigned int producer, consumer, delta;
	bool r = true;

	producer = ck_pr_load_uint(&ring->p_head);
  414d64:	49 8d 8a 64 df 70 00 	lea    rcx,[r10+0x70df64]
CK_PR_LOAD(ptr, void, void *, char, "movq")

#define CK_PR_LOAD_S(S, T, I) CK_PR_LOAD(S, T, T, T, I)

CK_PR_LOAD_S(char, char, "movb")
CK_PR_LOAD_S(uint, unsigned int, "movl")
  414d6b:	41 8b 92 64 df 70 00 	mov    edx,DWORD PTR [r10+0x70df64]
		/*
		 * The snapshot of producer must be up to date with respect to
		 * consumer.
		 */
		ck_pr_fence_load();
		consumer = ck_pr_load_uint(&ring->c_head);
  414d72:	4d 8d 8a 20 df 70 00 	lea    r9,[r10+0x70df20]
  414d79:	eb 0f                	jmp    414d8a <slm_ipi_event_enqueue+0x4a>
  414d7b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

#define CK_PR_CAS_S(S, T, I) CK_PR_CAS(S, T, T, T, I)

CK_PR_CAS_S(char, char, "cmpxchgb")
CK_PR_CAS_S(int, int, "cmpxchgl")
CK_PR_CAS_S(uint, unsigned int, "cmpxchgl")
  414d80:	89 d0                	mov    eax,edx
  414d82:	f0 0f b1 31          	lock cmpxchg DWORD PTR [rcx],esi
  414d86:	89 c2                	mov    edx,eax
		/*
		 * Only try to CAS if the producer is not clearly stale (not
		 * less than consumer) and the buffer is definitely not full.
		 */
		if (CK_CC_LIKELY((producer - consumer) < mask)) {
			if (ck_pr_cas_uint_value(&ring->p_head,
  414d88:	74 1e                	je     414da8 <slm_ipi_event_enqueue+0x68>
CK_PR_LOAD_S(uint, unsigned int, "movl")
  414d8a:	41 8b 39             	mov    edi,DWORD PTR [r9]
		if (CK_CC_LIKELY((producer - consumer) < mask)) {
  414d8d:	89 d0                	mov    eax,edx
		delta = producer + 1;
  414d8f:	8d 72 01             	lea    esi,[rdx+0x1]
		if (CK_CC_LIKELY((producer - consumer) < mask)) {
  414d92:	29 f8                	sub    eax,edi
  414d94:	41 39 c0             	cmp    r8d,eax
  414d97:	77 e7                	ja     414d80 <slm_ipi_event_enqueue+0x40>
  414d99:	8b 01                	mov    eax,DWORD PTR [rcx]
			 * Only fail if we haven't made forward progress in
			 * production: the buffer must have been full when we
			 * read new_producer (or we wrapped around UINT_MAX
			 * during this iteration).
			 */
			if (producer == new_producer) {
  414d9b:	39 c2                	cmp    edx,eax
  414d9d:	74 52                	je     414df1 <slm_ipi_event_enqueue+0xb1>
  414d9f:	89 c2                	mov    edx,eax
  414da1:	eb e7                	jmp    414d8a <slm_ipi_event_enqueue+0x4a>
  414da3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
			producer = new_producer;
		}
	}

	buffer = (char *)buffer + ts * (producer & mask);
	memcpy(buffer, entry, ts);
  414da8:	48 8b 3b             	mov    rdi,QWORD PTR [rbx]
	buffer = (char *)buffer + ts * (producer & mask);
  414dab:	41 21 c0             	and    r8d,eax
  414dae:	42 8d 0c c5 00 00 00 	lea    ecx,[r8*8+0x0]
  414db5:	00 
	memcpy(buffer, entry, ts);
  414db6:	49 89 bc 0b 00 df 70 	mov    QWORD PTR [r11+rcx*1+0x70df00],rdi
  414dbd:	00 

	/*
	 * Wait until all concurrent producers have completed writing
	 * their data into the ring buffer.
	 */
	while (ck_pr_load_uint(&ring->p_tail) != producer)
  414dbe:	49 8d 7a 60          	lea    rdi,[r10+0x60]
  414dc2:	49 8d 8a 60 df 70 00 	lea    rcx,[r10+0x70df60]
  414dc9:	44 8b 87 00 df 70 00 	mov    r8d,DWORD PTR [rdi+0x70df00]
  414dd0:	41 39 c0             	cmp    r8d,eax
  414dd3:	74 0b                	je     414de0 <slm_ipi_event_enqueue+0xa0>
  414dd5:	0f 1f 00             	nop    DWORD PTR [rax]
	__asm__ __volatile__("pause" ::: "memory");
  414dd8:	f3 90                	pause  
CK_PR_LOAD_S(uint, unsigned int, "movl")
  414dda:	8b 11                	mov    edx,DWORD PTR [rcx]
  414ddc:	39 d0                	cmp    eax,edx
  414dde:	75 f8                	jne    414dd8 <slm_ipi_event_enqueue+0x98>
CK_PR_STORE_S(uint, unsigned int, "movl", CK_CC_IMM_U32)
  414de0:	89 b7 00 df 70 00    	mov    DWORD PTR [rdi+0x70df00],esi
  414de6:	b8 01 00 00 00       	mov    eax,0x1
}
  414deb:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
  414def:	c9                   	leave  
  414df0:	c3                   	ret    
  414df1:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
  414df5:	31 c0                	xor    eax,eax
  414df7:	c9                   	leave  
  414df8:	c3                   	ret    
  414df9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000414e00 <slm_ipi_event_dequeue>:
{
  414e00:	f3 0f 1e fa          	endbr64 
    return CK_RING_DEQUEUE_MPSC(slm_ipi_ringbuf, &ipi_data->ring, ipi_data->ringbuf, event);
  414e04:	48 63 f6             	movsxd rsi,esi
  414e07:	48 69 f6 c0 10 00 00 	imul   rsi,rsi,0x10c0
	const unsigned int mask = ring->mask;
  414e0e:	8b 86 a4 df 70 00    	mov    eax,DWORD PTR [rsi+0x70dfa4]
	consumer = ring->c_head;
  414e14:	8b 96 20 df 70 00    	mov    edx,DWORD PTR [rsi+0x70df20]
  414e1a:	4c 8d 86 a8 00 00 00 	lea    r8,[rsi+0xa8]
CK_PR_LOAD_S(uint, unsigned int, "movl")
  414e21:	8b 8e 60 df 70 00    	mov    ecx,DWORD PTR [rsi+0x70df60]
	if (CK_CC_UNLIKELY(consumer == producer))
  414e27:	39 ca                	cmp    edx,ecx
  414e29:	74 25                	je     414e50 <slm_ipi_event_dequeue+0x50>
	buffer = (const char *)buffer + size * (consumer & mask);
  414e2b:	21 d0                	and    eax,edx
  414e2d:	c1 e0 03             	shl    eax,0x3
  414e30:	49 8b 84 00 00 df 70 	mov    rax,QWORD PTR [r8+rax*1+0x70df00]
  414e37:	00 
	memcpy(target, buffer, size);
  414e38:	48 89 07             	mov    QWORD PTR [rdi],rax
	ck_pr_store_uint(&ring->c_head, consumer + 1);
  414e3b:	83 c2 01             	add    edx,0x1
CK_PR_STORE_S(uint, unsigned int, "movl", CK_CC_IMM_U32)
  414e3e:	89 96 20 df 70 00    	mov    DWORD PTR [rsi+0x70df20],edx
  414e44:	b8 01 00 00 00       	mov    eax,0x1
  414e49:	c3                   	ret    
  414e4a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  414e50:	31 c0                	xor    eax,eax
}
  414e52:	c3                   	ret    
  414e53:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  414e5a:	00 00 00 00 
  414e5e:	66 90                	xchg   ax,ax

0000000000414e60 <slm_ipi_event_empty>:
{
  414e60:	f3 0f 1e fa          	endbr64 
	c = ck_pr_load_uint(&ring->c_head);
  414e64:	48 63 ff             	movsxd rdi,edi
  414e67:	48 69 ff c0 10 00 00 	imul   rdi,rdi,0x10c0
CK_PR_LOAD_S(uint, unsigned int, "movl")
  414e6e:	8b 97 20 df 70 00    	mov    edx,DWORD PTR [rdi+0x70df20]
  414e74:	8b 87 60 df 70 00    	mov    eax,DWORD PTR [rdi+0x70df60]
	return (p - c) & ring->mask;
  414e7a:	29 d0                	sub    eax,edx
  414e7c:	23 87 a4 df 70 00    	and    eax,DWORD PTR [rdi+0x70dfa4]
    return (!ck_ring_size(&ipi_data->ring));
  414e82:	0f 94 c0             	sete   al
  414e85:	0f b6 c0             	movzx  eax,al
}
  414e88:	c3                   	ret    
  414e89:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000414e90 <slm_ipi_percore_get>:
{
  414e90:	f3 0f 1e fa          	endbr64 
    return &slm_ipi_percore_data[id];
  414e94:	48 63 c7             	movsxd rax,edi
  414e97:	48 69 c0 c0 10 00 00 	imul   rax,rax,0x10c0
  414e9e:	48 05 00 df 70 00    	add    rax,0x70df00
}
  414ea4:	c3                   	ret    
  414ea5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  414eac:	00 00 00 00 

0000000000414eb0 <slm_thd_special>:
{
  414eb0:	f3 0f 1e fa          	endbr64 
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  414eb4:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  414eb7:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
	return cos_get_thd_id();
  414ebd:	0f b7 b0 f0 1f 00 00 	movzx  esi,WORD PTR [rax+0x1ff0]
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  414ec4:	0f 01 f9             	rdtscp 
	*coreid = c & 0xFFF;
  414ec7:	89 ca                	mov    edx,ecx
	if (me == g->sched_thd.tid)     return &g->sched_thd;
  414ec9:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  414ecf:	48 8d 04 89          	lea    rax,[rcx+rcx*4]
  414ed3:	66 81 e2 ff 0f       	and    dx,0xfff
  414ed8:	48 c1 e0 06          	shl    rax,0x6
  414edc:	48 8d 88 00 65 71 00 	lea    rcx,[rax+0x716500]
  414ee3:	48 39 b0 20 65 71 00 	cmp    QWORD PTR [rax+0x716520],rsi
  414eea:	74 24                	je     414f10 <slm_thd_special+0x60>
	else                            return NULL;
  414eec:	31 c0                	xor    eax,eax
	else if (me == g->idle_thd.tid) return &g->idle_thd;
  414eee:	48 39 b1 98 00 00 00 	cmp    QWORD PTR [rcx+0x98],rsi
  414ef5:	75 11                	jne    414f08 <slm_thd_special+0x58>
  414ef7:	0f b7 d2             	movzx  edx,dx
  414efa:	48 8d 04 92          	lea    rax,[rdx+rdx*4]
  414efe:	48 c1 e0 06          	shl    rax,0x6
  414f02:	48 05 80 65 71 00    	add    rax,0x716580
}
  414f08:	c3                   	ret    
  414f09:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	if (me == g->sched_thd.tid)     return &g->sched_thd;
  414f10:	0f b7 d2             	movzx  edx,dx
  414f13:	48 8d 04 92          	lea    rax,[rdx+rdx*4]
  414f17:	48 c1 e0 06          	shl    rax,0x6
  414f1b:	48 05 08 65 71 00    	add    rax,0x716508
  414f21:	c3                   	ret    
  414f22:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  414f29:	00 00 00 00 
  414f2d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000414f30 <slm_thd_init>:
{
  414f30:	f3 0f 1e fa          	endbr64 
  414f34:	55                   	push   rbp
  414f35:	48 89 e5             	mov    rbp,rsp
  414f38:	41 54                	push   r12
  414f3a:	49 89 fc             	mov    r12,rdi
  414f3d:	53                   	push   rbx
  414f3e:	48 89 d3             	mov    rbx,rdx
  414f41:	48 83 ec 10          	sub    rsp,0x10
  414f45:	48 89 75 e8          	mov    QWORD PTR [rbp-0x18],rsi
	struct cos_defcompinfo *defci     = cos_defcompinfo_curr_get();
  414f49:	e8 02 66 ff ff       	call   40b550 <cos_defcompinfo_curr_get>
  414f4e:	48 89 c7             	mov    rdi,rax
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);
  414f51:	e8 3a 66 ff ff       	call   40b590 <cos_sched_aep_get>
	memset(t, 0, sizeof(struct slm_thd));
  414f56:	49 8d 7c 24 08       	lea    rdi,[r12+0x8]
  414f5b:	4c 89 e1             	mov    rcx,r12
  414f5e:	49 c7 04 24 00 00 00 	mov    QWORD PTR [r12],0x0
  414f65:	00 
  414f66:	49 c7 44 24 70 00 00 	mov    QWORD PTR [r12+0x70],0x0
  414f6d:	00 00 
  414f6f:	48 83 e7 f8          	and    rdi,0xfffffffffffffff8
	struct cos_aep_info    *sched_aep = cos_sched_aep_get(defci);
  414f73:	49 89 c0             	mov    r8,rax
	memset(t, 0, sizeof(struct slm_thd));
  414f76:	31 c0                	xor    eax,eax
  414f78:	48 29 f9             	sub    rcx,rdi
  414f7b:	83 c1 78             	add    ecx,0x78
  414f7e:	c1 e9 03             	shr    ecx,0x3
  414f81:	f3 48 ab             	rep stos QWORD PTR es:[rdi],rax
	*t = (struct slm_thd) {
  414f84:	f3 41 0f 7e 00       	movq   xmm0,QWORD PTR [r8]
  414f89:	0f 16 45 e8          	movhps xmm0,QWORD PTR [rbp-0x18]
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  414f8d:	0f 01 f9             	rdtscp 
  414f90:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  414f96:	41 0f 11 44 24 08    	movups XMMWORD PTR [r12+0x8],xmm0
	if ((ret = slm_timer_thd_init(t))) return ret;
  414f9c:	4c 89 e7             	mov    rdi,r12
	*t = (struct slm_thd) {
  414f9f:	48 b8 ff ff ff ff ff 	movabs rax,0xffffffffffff
  414fa6:	ff 00 00 
  414fa9:	49 89 44 24 30       	mov    QWORD PTR [r12+0x30],rax
	ps_list_init(t, thd_list);
  414fae:	49 8d 44 24 58       	lea    rax,[r12+0x58]
  414fb3:	66 48 0f 6e c8       	movq   xmm1,rax
	ps_list_init(t, graveyard_list);
  414fb8:	49 8d 44 24 68       	lea    rax,[r12+0x68]
	*t = (struct slm_thd) {
  414fbd:	49 89 5c 24 18       	mov    QWORD PTR [r12+0x18],rbx
	ps_list_init(t, graveyard_list);
  414fc2:	66 48 0f 6e c0       	movq   xmm0,rax
	*t = (struct slm_thd) {
  414fc7:	41 89 4c 24 38       	mov    DWORD PTR [r12+0x38],ecx
{ l->n = l->p = l; }
  414fcc:	66 0f 6c c9          	punpcklqdq xmm1,xmm1
  414fd0:	41 c7 44 24 04 03 00 	mov    DWORD PTR [r12+0x4],0x3
  414fd7:	00 00 
  414fd9:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  414fdd:	41 0f 11 4c 24 58    	movups XMMWORD PTR [r12+0x58],xmm1
  414fe3:	41 0f 11 44 24 68    	movups XMMWORD PTR [r12+0x68],xmm0
	if ((ret = slm_timer_thd_init(t))) return ret;
  414fe9:	e8 32 ca fe ff       	call   401a20 <slm_timer_thd_init>
  414fee:	85 c0                	test   eax,eax
  414ff0:	74 0e                	je     415000 <slm_thd_init+0xd0>
}
  414ff2:	48 83 c4 10          	add    rsp,0x10
  414ff6:	5b                   	pop    rbx
  414ff7:	41 5c                	pop    r12
  414ff9:	5d                   	pop    rbp
  414ffa:	c3                   	ret    
  414ffb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  415000:	48 83 c4 10          	add    rsp,0x10
	if ((ret = slm_sched_thd_init(t))) return ret;
  415004:	4c 89 e7             	mov    rdi,r12
}
  415007:	5b                   	pop    rbx
  415008:	41 5c                	pop    r12
  41500a:	5d                   	pop    rbp
	if ((ret = slm_sched_thd_init(t))) return ret;
  41500b:	e9 70 ca fe ff       	jmp    401a80 <slm_sched_thd_init>

0000000000415010 <slm_thd_deinit>:
{
  415010:	f3 0f 1e fa          	endbr64 
  415014:	55                   	push   rbp
  415015:	48 89 e5             	mov    rbp,rsp
  415018:	53                   	push   rbx
  415019:	48 89 fb             	mov    rbx,rdi
  41501c:	48 83 ec 08          	sub    rsp,0x8
	slm_sched_thd_deinit(t);
  415020:	e8 6b ca fe ff       	call   401a90 <slm_sched_thd_deinit>
	slm_timer_thd_deinit(t);
  415025:	48 89 df             	mov    rdi,rbx
  415028:	e8 03 ca fe ff       	call   401a30 <slm_timer_thd_deinit>
	t->state = SLM_THD_DYING;
  41502d:	c7 43 04 04 00 00 00 	mov    DWORD PTR [rbx+0x4],0x4
}
  415034:	48 8b 5d f8          	mov    rbx,QWORD PTR [rbp-0x8]
  415038:	c9                   	leave  
  415039:	c3                   	ret    
  41503a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000415040 <slm_cs_enter_contention>:
{
  415040:	f3 0f 1e fa          	endbr64 
  415044:	49 89 f2             	mov    r10,rsi
  415047:	49 89 d3             	mov    r11,rdx
  41504a:	48 89 ce             	mov    rsi,rcx
  41504d:	0f 01 f9             	rdtscp 
	if (!contended) {
  415050:	45 85 c0             	test   r8d,r8d
  415053:	75 16                	jne    41506b <slm_cs_enter_contention+0x2b>
	return !ps_cas(&cs->owner_contention, (unsigned long)cached, ((unsigned long)thd | !!contention));
  415055:	48 89 f2             	mov    rdx,rsi
  415058:	4c 89 d0             	mov    rax,r10
  41505b:	48 83 ca 01          	or     rdx,0x1
  41505f:	f0 48 0f b1 17       	lock cmpxchg QWORD PTR [rdi],rdx
  415064:	0f 94 c0             	sete   al
		if (__slm_cs_cas(cs, cached, owner, 1)) return 1;
  415067:	84 c0                	test   al,al
  415069:	74 25                	je     415090 <slm_cs_enter_contention+0x50>
{
  41506b:	55                   	push   rbp
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  41506c:	4d 8b 43 30          	mov    r8,QWORD PTR [r11+0x30]
  415070:	31 d2                	xor    edx,edx
  415072:	44 89 c9             	mov    ecx,r9d
  415075:	48 8b 7e 10          	mov    rdi,QWORD PTR [rsi+0x10]
  415079:	4c 89 c6             	mov    rsi,r8
{
  41507c:	48 89 e5             	mov    rbp,rsp
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  41507f:	e8 1c 76 ff ff       	call   40c6a0 <cos_defswitch>
	if (ret) return ret;
  415084:	85 c0                	test   eax,eax
  415086:	75 05                	jne    41508d <slm_cs_enter_contention+0x4d>
	return 1;
  415088:	b8 01 00 00 00       	mov    eax,0x1
}
  41508d:	5d                   	pop    rbp
  41508e:	c3                   	ret    
  41508f:	90                   	nop
	return 1;
  415090:	b8 01 00 00 00       	mov    eax,0x1
}
  415095:	c3                   	ret    
  415096:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41509d:	00 00 00 

00000000004150a0 <slm_cs_exit_contention>:
{
  4150a0:	f3 0f 1e fa          	endbr64 
  4150a4:	49 89 f2             	mov    r10,rsi
  4150a7:	49 89 d0             	mov    r8,rdx
  4150aa:	41 89 c9             	mov    r9d,ecx
  4150ad:	0f 01 f9             	rdtscp 
  4150b0:	31 f6                	xor    esi,esi
  4150b2:	4c 89 c0             	mov    rax,r8
  4150b5:	f0 48 0f b1 37       	lock cmpxchg QWORD PTR [rdi],rsi
  4150ba:	0f 94 c0             	sete   al
	if (__slm_cs_cas(cs, cached, NULL, 0)) return 1;
  4150bd:	84 c0                	test   al,al
  4150bf:	75 0f                	jne    4150d0 <slm_cs_exit_contention+0x30>
}
  4150c1:	b8 01 00 00 00       	mov    eax,0x1
  4150c6:	c3                   	ret    
  4150c7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  4150ce:	00 00 
	ret = cos_defswitch(s->thd, curr->priority, TCAP_TIME_NIL, tok);
  4150d0:	81 e1 ff 0f 00 00    	and    ecx,0xfff
{
  4150d6:	55                   	push   rbp
	ret = cos_defswitch(s->thd, curr->priority, TCAP_TIME_NIL, tok);
  4150d7:	49 8b 72 30          	mov    rsi,QWORD PTR [r10+0x30]
  4150db:	31 d2                	xor    edx,edx
  4150dd:	48 8d 04 89          	lea    rax,[rcx+rcx*4]
  4150e1:	44 89 c9             	mov    ecx,r9d
  4150e4:	48 c1 e0 06          	shl    rax,0x6
  4150e8:	48 8b b8 18 65 71 00 	mov    rdi,QWORD PTR [rax+0x716518]
{
  4150ef:	48 89 e5             	mov    rbp,rsp
	ret = cos_defswitch(s->thd, curr->priority, TCAP_TIME_NIL, tok);
  4150f2:	e8 a9 75 ff ff       	call   40c6a0 <cos_defswitch>
	return 0;
  4150f7:	45 31 c0             	xor    r8d,r8d
	assert(ret != -EINVAL);
  4150fa:	83 f8 ea             	cmp    eax,0xffffffea
  4150fd:	74 05                	je     415104 <slm_cs_exit_contention+0x64>
}
  4150ff:	44 89 c0             	mov    eax,r8d
  415102:	5d                   	pop    rbp
  415103:	c3                   	ret    
  415104:	be 23 00 00 00       	mov    esi,0x23
  415109:	bf 98 f6 41 00       	mov    edi,0x41f698
  41510e:	e8 6d 5b ff ff       	call   40ac80 <cos_print_str>
	assert(ret != -EINVAL);
  415113:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41511a:	00 00 00 00 
  41511e:	0f 0b                	ud2    

0000000000415120 <slm_thd_block>:
{
  415120:	f3 0f 1e fa          	endbr64 
  415124:	55                   	push   rbp
  415125:	48 89 e5             	mov    rbp,rsp
	assert(t);
  415128:	48 85 ff             	test   rdi,rdi
  41512b:	74 6f                	je     41519c <slm_thd_block+0x7c>
  41512d:	0f 01 f9             	rdtscp 
	return t != &g->idle_thd && t != &g->sched_thd;
  415130:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  415136:	48 8d 04 89          	lea    rax,[rcx+rcx*4]
  41513a:	48 c1 e0 06          	shl    rax,0x6
  41513e:	48 8d 90 80 65 71 00 	lea    rdx,[rax+0x716580]
  415145:	48 39 d7             	cmp    rdi,rdx
  415148:	74 36                	je     415180 <slm_thd_block+0x60>
  41514a:	48 05 08 65 71 00    	add    rax,0x716508
  415150:	48 39 c7             	cmp    rdi,rax
  415153:	74 2b                	je     415180 <slm_thd_block+0x60>
	if (unlikely(t->state == SLM_THD_WOKEN)) {
  415155:	8b 47 04             	mov    eax,DWORD PTR [rdi+0x4]
  415158:	83 f8 02             	cmp    eax,0x2
  41515b:	74 5b                	je     4151b8 <slm_thd_block+0x98>
	assert(t->state == SLM_THD_RUNNABLE);
  41515d:	83 f8 03             	cmp    eax,0x3
  415160:	75 69                	jne    4151cb <slm_thd_block+0xab>
	if (t->properties & SLM_THD_PROPERTY_SUSPENDED) {
  415162:	8b 07                	mov    eax,DWORD PTR [rdi]
  415164:	a8 04                	test   al,0x4
  415166:	74 05                	je     41516d <slm_thd_block+0x4d>
		t->properties &= ~SLM_THD_PROPERTY_SUSPENDED;
  415168:	83 e0 fb             	and    eax,0xfffffffb
  41516b:	89 07                	mov    DWORD PTR [rdi],eax
	t->state = SLM_THD_BLOCKED;
  41516d:	c7 47 04 01 00 00 00 	mov    DWORD PTR [rdi+0x4],0x1
	slm_sched_block(t);
  415174:	e8 37 c9 fe ff       	call   401ab0 <slm_sched_block>
	return 0;
  415179:	31 c0                	xor    eax,eax
}
  41517b:	5d                   	pop    rbp
  41517c:	c3                   	ret    
  41517d:	0f 1f 00             	nop    DWORD PTR [rax]
  415180:	be 23 00 00 00       	mov    esi,0x23
  415185:	bf 48 f8 41 00       	mov    edi,0x41f848
  41518a:	e8 f1 5a ff ff       	call   40ac80 <cos_print_str>
	assert(slm_thd_normal(t));
  41518f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  415196:	00 00 00 00 
  41519a:	0f 0b                	ud2    
  41519c:	be 23 00 00 00       	mov    esi,0x23
  4151a1:	bf d0 f7 41 00       	mov    edi,0x41f7d0
  4151a6:	e8 d5 5a ff ff       	call   40ac80 <cos_print_str>
	assert(t);
  4151ab:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4151b2:	00 00 00 00 
  4151b6:	0f 0b                	ud2    
		assert(!(t->properties & SLM_THD_PROPERTY_SUSPENDED));
  4151b8:	f6 07 04             	test   BYTE PTR [rdi],0x4
  4151bb:	75 2a                	jne    4151e7 <slm_thd_block+0xc7>
		t->state = SLM_THD_RUNNABLE;
  4151bd:	c7 47 04 03 00 00 00 	mov    DWORD PTR [rdi+0x4],0x3
		return 1;
  4151c4:	b8 01 00 00 00       	mov    eax,0x1
}
  4151c9:	5d                   	pop    rbp
  4151ca:	c3                   	ret    
  4151cb:	be 23 00 00 00       	mov    esi,0x23
  4151d0:	bf 20 f8 41 00       	mov    edi,0x41f820
  4151d5:	e8 a6 5a ff ff       	call   40ac80 <cos_print_str>
	assert(t->state == SLM_THD_RUNNABLE);
  4151da:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4151e1:	00 00 00 00 
  4151e5:	0f 0b                	ud2    
  4151e7:	be 23 00 00 00       	mov    esi,0x23
  4151ec:	bf f8 f7 41 00       	mov    edi,0x41f7f8
  4151f1:	e8 8a 5a ff ff       	call   40ac80 <cos_print_str>
		assert(!(t->properties & SLM_THD_PROPERTY_SUSPENDED));
  4151f6:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4151fd:	00 00 00 00 
  415201:	0f 0b                	ud2    
  415203:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41520a:	00 00 00 00 
  41520e:	66 90                	xchg   ax,ax

0000000000415210 <slm_thd_block_cs>:
{
  415210:	f3 0f 1e fa          	endbr64 
  415214:	55                   	push   rbp
  415215:	48 89 e5             	mov    rbp,rsp
  415218:	41 57                	push   r15
  41521a:	41 56                	push   r14
  41521c:	41 55                	push   r13
  41521e:	41 54                	push   r12
  415220:	53                   	push   rbx
  415221:	48 83 ec 18          	sub    rsp,0x18
	assert(current);
  415225:	48 85 ff             	test   rdi,rdi
  415228:	0f 84 9d 02 00 00    	je     4154cb <slm_thd_block_cs+0x2bb>
  41522e:	48 89 fb             	mov    rbx,rdi
  415231:	0f 01 f9             	rdtscp 
	cs = &(slm_global()->lock);
  415234:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  41523a:	4c 8d 24 89          	lea    r12,[rcx+rcx*4]
  41523e:	49 c1 e4 06          	shl    r12,0x6
  415242:	49 81 c4 00 65 71 00 	add    r12,0x716500
		tok    = cos_sched_sync();
  415249:	e8 c2 c8 ff ff       	call   411b10 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  41524e:	49 8b 34 24          	mov    rsi,QWORD PTR [r12]
  415252:	41 89 c0             	mov    r8d,eax
		if (unlikely(owner)) {
  415255:	48 89 f7             	mov    rdi,rsi
  415258:	48 83 e7 fe          	and    rdi,0xfffffffffffffffe
  41525c:	0f 85 0e 02 00 00    	jne    415470 <slm_thd_block_cs+0x260>
  415262:	48 89 f0             	mov    rax,rsi
  415265:	f0 49 0f b1 1c 24    	lock cmpxchg QWORD PTR [r12],rbx
  41526b:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  41526e:	84 c0                	test   al,al
  415270:	74 d7                	je     415249 <slm_thd_block_cs+0x39>
	if (slm_thd_block(current)) {
  415272:	48 89 df             	mov    rdi,rbx
  415275:	e8 a6 fe ff ff       	call   415120 <slm_thd_block>
  41527a:	85 c0                	test   eax,eax
  41527c:	0f 85 4e 01 00 00    	jne    4153d0 <slm_thd_block_cs+0x1c0>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  415282:	e8 c9 62 ff ff       	call   40b550 <cos_defcompinfo_curr_get>
  415287:	0f 01 f9             	rdtscp 
	if (unlikely(!t)) t = &g->idle_thd;
  41528a:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  415290:	45 31 ff             	xor    r15d,r15d
  415293:	4c 8d 2c 89          	lea    r13,[rcx+rcx*4]
  415297:	49 c1 e5 06          	shl    r13,0x6
  41529b:	49 8d 85 80 65 71 00 	lea    rax,[r13+0x716580]
  4152a2:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
	tok  = cos_sched_sync();
  4152a6:	e8 65 c8 ff ff       	call   411b10 <cos_sched_sync>
  4152ab:	41 89 c6             	mov    r14d,eax
	t = slm_sched_schedule();
  4152ae:	e8 2d c8 fe ff       	call   401ae0 <slm_sched_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  4152b3:	48 85 c0             	test   rax,rax
	t = slm_sched_schedule();
  4152b6:	49 89 c4             	mov    r12,rax
	if (unlikely(!t)) t = &g->idle_thd;
  4152b9:	4c 0f 44 65 c8       	cmove  r12,QWORD PTR [rbp-0x38]
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  4152be:	41 8b 44 24 04       	mov    eax,DWORD PTR [r12+0x4]
  4152c3:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  4152c6:	83 f8 01             	cmp    eax,0x1
  4152c9:	0f 87 81 02 00 00    	ja     415550 <slm_thd_block_cs+0x340>
  4152cf:	0f 01 f9             	rdtscp 
	struct slm_cs *cs = &(slm_global()->lock);
  4152d2:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  4152d8:	48 8d 3c 89          	lea    rdi,[rcx+rcx*4]
  4152dc:	48 c1 e7 06          	shl    rdi,0x6
  4152e0:	4c 8d af 00 65 71 00 	lea    r13,[rdi+0x716500]
	while (ret != 0) {
  4152e7:	eb 17                	jmp    415300 <slm_thd_block_cs+0xf0>
  4152e9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  4152f0:	48 89 f0             	mov    rax,rsi
  4152f3:	f0 49 0f b1 55 00    	lock cmpxchg QWORD PTR [r13+0x0],rdx
  4152f9:	0f 94 c0             	sete   al
  4152fc:	84 c0                	test   al,al
  4152fe:	75 57                	jne    415357 <slm_thd_block_cs+0x147>
		tok    = cos_sched_sync();
  415300:	e8 0b c8 ff ff       	call   411b10 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  415305:	49 8b 75 00          	mov    rsi,QWORD PTR [r13+0x0]
  415309:	41 89 c0             	mov    r8d,eax
		if (unlikely(contention)) {
  41530c:	48 89 f2             	mov    rdx,rsi
  41530f:	83 e2 01             	and    edx,0x1
  415312:	74 dc                	je     4152f0 <slm_thd_block_cs+0xe0>
  415314:	0f 01 f9             	rdtscp 
  415317:	48 89 f0             	mov    rax,rsi
  41531a:	f0 4d 0f b1 7d 00    	lock cmpxchg QWORD PTR [r13+0x0],r15
  415320:	0f 94 c0             	sete   al
	if (__slm_cs_cas(cs, cached, NULL, 0)) return 1;
  415323:	84 c0                	test   al,al
  415325:	74 d9                	je     415300 <slm_thd_block_cs+0xf0>
	ret = cos_defswitch(s->thd, curr->priority, TCAP_TIME_NIL, tok);
  415327:	81 e1 ff 0f 00 00    	and    ecx,0xfff
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  41532d:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  415331:	31 d2                	xor    edx,edx
  415333:	48 8d 04 89          	lea    rax,[rcx+rcx*4]
  415337:	48 8b 76 30          	mov    rsi,QWORD PTR [rsi+0x30]
  41533b:	44 89 c1             	mov    ecx,r8d
  41533e:	48 c1 e0 06          	shl    rax,0x6
  415342:	48 8b b8 18 65 71 00 	mov    rdi,QWORD PTR [rax+0x716518]
  415349:	e8 52 73 ff ff       	call   40c6a0 <cos_defswitch>
	assert(ret != -EINVAL);
  41534e:	83 f8 ea             	cmp    eax,0xffffffea
  415351:	0f 84 fd 00 00 00    	je     415454 <slm_thd_block_cs+0x244>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  415357:	e8 f4 61 ff ff       	call   40b550 <cos_defcompinfo_curr_get>
  41535c:	0f 01 f9             	rdtscp 
	*coreid = c & 0xFFF;
  41535f:	89 ca                	mov    edx,ecx
	timeout = g->timeout_next;
  415361:	81 e1 ff 0f 00 00    	and    ecx,0xfff
	prio = inherit_prio ? curr->priority : t->priority;
  415367:	49 8b 74 24 30       	mov    rsi,QWORD PTR [r12+0x30]
	timeout = g->timeout_next;
  41536c:	48 8d 04 89          	lea    rax,[rcx+rcx*4]
  415370:	66 81 e2 ff 0f       	and    dx,0xfff
  415375:	49 89 c8             	mov    r8,rcx
  415378:	48 c1 e0 06          	shl    rax,0x6
  41537c:	4c 8b 88 08 66 71 00 	mov    r9,QWORD PTR [rax+0x716608]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  415383:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  415387:	a8 0b                	test   al,0xb
  415389:	0f 85 dd 01 00 00    	jne    41556c <slm_thd_block_cs+0x35c>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  41538f:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  415394:	44 89 f1             	mov    ecx,r14d
  415397:	4c 89 ca             	mov    rdx,r9
  41539a:	4c 89 45 c0          	mov    QWORD PTR [rbp-0x40],r8
  41539e:	e8 fd 72 ff ff       	call   40c6a0 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  4153a3:	4c 8b 45 c0          	mov    r8,QWORD PTR [rbp-0x40]
  4153a7:	83 f8 ff             	cmp    eax,0xffffffff
  4153aa:	0f 84 41 02 00 00    	je     4155f1 <slm_thd_block_cs+0x3e1>
	if (unlikely(ret != 0)) {
  4153b0:	85 c0                	test   eax,eax
  4153b2:	0f 85 2f 01 00 00    	jne    4154e7 <slm_thd_block_cs+0x2d7>
}
  4153b8:	48 83 c4 18          	add    rsp,0x18
  4153bc:	5b                   	pop    rbx
  4153bd:	41 5c                	pop    r12
  4153bf:	41 5d                	pop    r13
  4153c1:	41 5e                	pop    r14
  4153c3:	41 5f                	pop    r15
  4153c5:	5d                   	pop    rbp
  4153c6:	c3                   	ret    
  4153c7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  4153ce:	00 00 
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  4153d0:	0f 01 f9             	rdtscp 
	struct slm_cs *cs = &(slm_global()->lock);
  4153d3:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  4153d9:	45 31 e4             	xor    r12d,r12d
  4153dc:	48 8d 1c 89          	lea    rbx,[rcx+rcx*4]
  4153e0:	48 c1 e3 06          	shl    rbx,0x6
  4153e4:	48 81 c3 00 65 71 00 	add    rbx,0x716500
	while (ret != 0) {
  4153eb:	eb 12                	jmp    4153ff <slm_thd_block_cs+0x1ef>
  4153ed:	0f 1f 00             	nop    DWORD PTR [rax]
  4153f0:	48 89 f0             	mov    rax,rsi
  4153f3:	f0 48 0f b1 13       	lock cmpxchg QWORD PTR [rbx],rdx
  4153f8:	0f 94 c0             	sete   al
  4153fb:	84 c0                	test   al,al
  4153fd:	75 b9                	jne    4153b8 <slm_thd_block_cs+0x1a8>
		tok    = cos_sched_sync();
  4153ff:	e8 0c c7 ff ff       	call   411b10 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  415404:	48 8b 33             	mov    rsi,QWORD PTR [rbx]
  415407:	41 89 c0             	mov    r8d,eax
		if (unlikely(contention)) {
  41540a:	48 89 f2             	mov    rdx,rsi
  41540d:	83 e2 01             	and    edx,0x1
  415410:	74 de                	je     4153f0 <slm_thd_block_cs+0x1e0>
  415412:	0f 01 f9             	rdtscp 
  415415:	48 89 f0             	mov    rax,rsi
  415418:	f0 4c 0f b1 23       	lock cmpxchg QWORD PTR [rbx],r12
  41541d:	0f 94 c0             	sete   al
	if (__slm_cs_cas(cs, cached, NULL, 0)) return 1;
  415420:	84 c0                	test   al,al
  415422:	74 db                	je     4153ff <slm_thd_block_cs+0x1ef>
	ret = cos_defswitch(s->thd, curr->priority, TCAP_TIME_NIL, tok);
  415424:	81 e1 ff 0f 00 00    	and    ecx,0xfff
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  41542a:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  41542e:	31 d2                	xor    edx,edx
  415430:	48 8d 04 89          	lea    rax,[rcx+rcx*4]
  415434:	48 8b 76 30          	mov    rsi,QWORD PTR [rsi+0x30]
  415438:	44 89 c1             	mov    ecx,r8d
  41543b:	48 c1 e0 06          	shl    rax,0x6
  41543f:	48 8b b8 18 65 71 00 	mov    rdi,QWORD PTR [rax+0x716518]
  415446:	e8 55 72 ff ff       	call   40c6a0 <cos_defswitch>
	assert(ret != -EINVAL);
  41544b:	83 f8 ea             	cmp    eax,0xffffffea
  41544e:	0f 85 64 ff ff ff    	jne    4153b8 <slm_thd_block_cs+0x1a8>
  415454:	be 23 00 00 00       	mov    esi,0x23
  415459:	bf 98 f6 41 00       	mov    edi,0x41f698
  41545e:	e8 1d 58 ff ff       	call   40ac80 <cos_print_str>
  415463:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41546a:	00 00 00 00 
  41546e:	0f 0b                	ud2    
  415470:	0f 01 f9             	rdtscp 
	if (!contended) {
  415473:	40 f6 c6 01          	test   sil,0x1
  415477:	75 1b                	jne    415494 <slm_thd_block_cs+0x284>
	return !ps_cas(&cs->owner_contention, (unsigned long)cached, ((unsigned long)thd | !!contention));
  415479:	48 89 fa             	mov    rdx,rdi
  41547c:	48 89 f0             	mov    rax,rsi
  41547f:	48 83 ca 01          	or     rdx,0x1
  415483:	f0 49 0f b1 14 24    	lock cmpxchg QWORD PTR [r12],rdx
  415489:	0f 94 c0             	sete   al
		if (__slm_cs_cas(cs, cached, owner, 1)) return 1;
  41548c:	84 c0                	test   al,al
  41548e:	0f 84 b5 fd ff ff    	je     415249 <slm_thd_block_cs+0x39>
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  415494:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
  415498:	48 8b 7f 10          	mov    rdi,QWORD PTR [rdi+0x10]
  41549c:	31 d2                	xor    edx,edx
  41549e:	44 89 c1             	mov    ecx,r8d
  4154a1:	e8 fa 71 ff ff       	call   40c6a0 <cos_defswitch>
			assert(ret != -EBUSY);
  4154a6:	83 f8 f0             	cmp    eax,0xfffffff0
  4154a9:	0f 85 9a fd ff ff    	jne    415249 <slm_thd_block_cs+0x39>
  4154af:	be 25 00 00 00       	mov    esi,0x25
  4154b4:	bf 80 f7 41 00       	mov    edi,0x41f780
  4154b9:	e8 c2 57 ff ff       	call   40ac80 <cos_print_str>
  4154be:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4154c5:	00 00 00 00 
  4154c9:	0f 0b                	ud2    
  4154cb:	be 25 00 00 00       	mov    esi,0x25
  4154d0:	bf 70 f8 41 00       	mov    edi,0x41f870
  4154d5:	e8 a6 57 ff ff       	call   40ac80 <cos_print_str>
	assert(current);
  4154da:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4154e1:	00 00 00 00 
  4154e5:	0f 0b                	ud2    
		assert(ret != -EINVAL);
  4154e7:	83 f8 ea             	cmp    eax,0xffffffea
  4154ea:	0f 84 80 01 00 00    	je     415670 <slm_thd_block_cs+0x460>
		if (ret == -EBUSY) return ret;
  4154f0:	83 f8 f0             	cmp    eax,0xfffffff0
  4154f3:	0f 84 bf fe ff ff    	je     4153b8 <slm_thd_block_cs+0x1a8>
		assert(ret == -EAGAIN);
  4154f9:	83 f8 f5             	cmp    eax,0xfffffff5
  4154fc:	0f 85 e6 01 00 00    	jne    4156e8 <slm_thd_block_cs+0x4d8>
  415502:	0f 01 f9             	rdtscp 
	cs = &(slm_global()->lock);
  415505:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  41550b:	4c 8d 24 89          	lea    r12,[rcx+rcx*4]
  41550f:	49 c1 e4 06          	shl    r12,0x6
  415513:	49 81 c4 00 65 71 00 	add    r12,0x716500
		tok    = cos_sched_sync();
  41551a:	e8 f1 c5 ff ff       	call   411b10 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  41551f:	49 8b 34 24          	mov    rsi,QWORD PTR [r12]
  415523:	41 89 c0             	mov    r8d,eax
		if (unlikely(owner)) {
  415526:	48 89 f7             	mov    rdi,rsi
  415529:	48 83 e7 fe          	and    rdi,0xfffffffffffffffe
  41552d:	0f 85 59 01 00 00    	jne    41568c <slm_thd_block_cs+0x47c>
  415533:	48 89 f0             	mov    rax,rsi
  415536:	f0 49 0f b1 1c 24    	lock cmpxchg QWORD PTR [r12],rbx
  41553c:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  41553f:	84 c0                	test   al,al
  415541:	0f 85 5f fd ff ff    	jne    4152a6 <slm_thd_block_cs+0x96>
  415547:	eb d1                	jmp    41551a <slm_thd_block_cs+0x30a>
  415549:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  415550:	be 2d 00 00 00       	mov    esi,0x2d
  415555:	bf c0 f6 41 00       	mov    edi,0x41f6c0
  41555a:	e8 21 57 ff ff       	call   40ac80 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  41555f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  415566:	00 00 00 00 
  41556a:	0f 0b                	ud2    
		if (t == &g->sched_thd) {
  41556c:	0f b7 d2             	movzx  edx,dx
	timeout = g->timeout_next;
  41556f:	4c 89 c9             	mov    rcx,r9
		if (t == &g->sched_thd) {
  415572:	48 8d 14 92          	lea    rdx,[rdx+rdx*4]
  415576:	48 c1 e2 06          	shl    rdx,0x6
  41557a:	48 81 c2 08 65 71 00 	add    rdx,0x716508
  415581:	49 39 d4             	cmp    r12,rdx
  415584:	0f 84 b7 00 00 00    	je     415641 <slm_thd_block_cs+0x431>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  41558a:	a8 02                	test   al,0x2
  41558c:	0f 85 ba 00 00 00    	jne    41564c <slm_thd_block_cs+0x43c>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  415592:	49 89 c9             	mov    r9,rcx
  415595:	a8 01                	test   al,0x1
  415597:	0f 84 f2 fd ff ff    	je     41538f <slm_thd_block_cs+0x17f>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  41559d:	4b 8d 04 80          	lea    rax,[r8+r8*4]
  4155a1:	4d 8b 54 24 08       	mov    r10,QWORD PTR [r12+0x8]
  4155a6:	48 89 f2             	mov    rdx,rsi
  4155a9:	45 89 f1             	mov    r9d,r14d
  4155ac:	48 c1 e0 06          	shl    rax,0x6
  4155b0:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  4155b5:	4c 8b 80 28 65 71 00 	mov    r8,QWORD PTR [rax+0x716528]
  4155bc:	4c 89 d6             	mov    rsi,r10
  4155bf:	e8 6c c5 ff ff       	call   411b30 <cos_switch>
	if (unlikely(ret != 0)) {
  4155c4:	85 c0                	test   eax,eax
  4155c6:	0f 84 ec fd ff ff    	je     4153b8 <slm_thd_block_cs+0x1a8>
		assert(ret != -EPERM);
  4155cc:	83 f8 ff             	cmp    eax,0xffffffff
  4155cf:	0f 85 12 ff ff ff    	jne    4154e7 <slm_thd_block_cs+0x2d7>
  4155d5:	be 2d 00 00 00       	mov    esi,0x2d
  4155da:	bf f0 f6 41 00       	mov    edi,0x41f6f0
  4155df:	e8 9c 56 ff ff       	call   40ac80 <cos_print_str>
  4155e4:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4155eb:	00 00 00 00 
  4155ef:	0f 0b                	ud2    
  4155f1:	0f 01 f9             	rdtscp 
	return t != &g->idle_thd && t != &g->sched_thd;
  4155f4:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  4155fa:	48 8d 04 89          	lea    rax,[rcx+rcx*4]
  4155fe:	48 c1 e0 06          	shl    rax,0x6
  415602:	48 8d 90 80 65 71 00 	lea    rdx,[rax+0x716580]
  415609:	49 39 d4             	cmp    r12,rdx
  41560c:	74 0b                	je     415619 <slm_thd_block_cs+0x409>
  41560e:	48 05 08 65 71 00    	add    rax,0x716508
  415614:	49 39 c4             	cmp    r12,rax
  415617:	75 bc                	jne    4155d5 <slm_thd_block_cs+0x3c5>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  415619:	4b 8d 04 80          	lea    rax,[r8+r8*4]
  41561d:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]
  415621:	45 89 f1             	mov    r9d,r14d
  415624:	31 c9                	xor    ecx,ecx
  415626:	48 c1 e0 06          	shl    rax,0x6
  41562a:	31 f6                	xor    esi,esi
  41562c:	4c 8b 80 28 65 71 00 	mov    r8,QWORD PTR [rax+0x716528]
  415633:	48 8b b8 18 65 71 00 	mov    rdi,QWORD PTR [rax+0x716518]
  41563a:	e8 f1 c4 ff ff       	call   411b30 <cos_switch>
  41563f:	eb 83                	jmp    4155c4 <slm_thd_block_cs+0x3b4>
			prio    = curr->priority;
  415641:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
			timeout = TCAP_TIME_NIL;
  415645:	31 c9                	xor    ecx,ecx
  415647:	e9 3e ff ff ff       	jmp    41558a <slm_thd_block_cs+0x37a>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  41564c:	4b 8d 04 80          	lea    rax,[r8+r8*4]
  415650:	49 8b 7c 24 28       	mov    rdi,QWORD PTR [r12+0x28]
  415655:	44 89 f1             	mov    ecx,r14d
  415658:	4c 89 ce             	mov    rsi,r9
  41565b:	48 c1 e0 06          	shl    rax,0x6
  41565f:	48 8b 90 28 65 71 00 	mov    rdx,QWORD PTR [rax+0x716528]
  415666:	e8 35 c5 ff ff       	call   411ba0 <cos_sched_asnd>
  41566b:	e9 54 ff ff ff       	jmp    4155c4 <slm_thd_block_cs+0x3b4>
  415670:	be 2d 00 00 00       	mov    esi,0x2d
  415675:	bf 20 f7 41 00       	mov    edi,0x41f720
  41567a:	e8 01 56 ff ff       	call   40ac80 <cos_print_str>
		assert(ret != -EINVAL);
  41567f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  415686:	00 00 00 00 
  41568a:	0f 0b                	ud2    
  41568c:	0f 01 f9             	rdtscp 
	if (!contended) {
  41568f:	40 f6 c6 01          	test   sil,0x1
  415693:	75 1b                	jne    4156b0 <slm_thd_block_cs+0x4a0>
	return !ps_cas(&cs->owner_contention, (unsigned long)cached, ((unsigned long)thd | !!contention));
  415695:	48 89 fa             	mov    rdx,rdi
  415698:	48 89 f0             	mov    rax,rsi
  41569b:	48 83 ca 01          	or     rdx,0x1
  41569f:	f0 49 0f b1 14 24    	lock cmpxchg QWORD PTR [r12],rdx
  4156a5:	0f 94 c0             	sete   al
		if (__slm_cs_cas(cs, cached, owner, 1)) return 1;
  4156a8:	84 c0                	test   al,al
  4156aa:	0f 84 6a fe ff ff    	je     41551a <slm_thd_block_cs+0x30a>
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  4156b0:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
  4156b4:	48 8b 7f 10          	mov    rdi,QWORD PTR [rdi+0x10]
  4156b8:	31 d2                	xor    edx,edx
  4156ba:	44 89 c1             	mov    ecx,r8d
  4156bd:	e8 de 6f ff ff       	call   40c6a0 <cos_defswitch>
			assert(ret != -EBUSY);
  4156c2:	83 f8 f0             	cmp    eax,0xfffffff0
  4156c5:	0f 85 4f fe ff ff    	jne    41551a <slm_thd_block_cs+0x30a>
  4156cb:	bf 80 f7 41 00       	mov    edi,0x41f780
  4156d0:	e8 4b ed ff ff       	call   414420 <prints.isra.0>
  4156d5:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4156dc:	00 00 00 00 
  4156e0:	0f 0b                	ud2    
  4156e2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4156e8:	be 2d 00 00 00       	mov    esi,0x2d
  4156ed:	bf 50 f7 41 00       	mov    edi,0x41f750
  4156f2:	e8 89 55 ff ff       	call   40ac80 <cos_print_str>
		assert(ret == -EAGAIN);
  4156f7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4156fe:	00 00 00 00 
  415702:	0f 0b                	ud2    
  415704:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41570b:	00 00 00 00 
  41570f:	90                   	nop

0000000000415710 <slm_thd_sched_wakeup>:
{
  415710:	f3 0f 1e fa          	endbr64 
  415714:	55                   	push   rbp
  415715:	48 89 e5             	mov    rbp,rsp
	assert(t);
  415718:	48 85 ff             	test   rdi,rdi
  41571b:	74 2b                	je     415748 <slm_thd_sched_wakeup+0x38>
	if (unlikely(!(t->properties & SLM_THD_PROPERTY_SUSPENDED))) return 1;
  41571d:	8b 07                	mov    eax,DWORD PTR [rdi]
  41571f:	a8 04                	test   al,0x4
  415721:	74 41                	je     415764 <slm_thd_sched_wakeup+0x54>
	t->properties &= ~SLM_THD_PROPERTY_SUSPENDED;
  415723:	83 e0 fb             	and    eax,0xfffffffb
  415726:	89 07                	mov    DWORD PTR [rdi],eax
	if (unlikely(slm_state_is_runnable(t->state))) {
  415728:	8b 47 04             	mov    eax,DWORD PTR [rdi+0x4]
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  41572b:	8d 50 fe             	lea    edx,[rax-0x2]
  41572e:	83 fa 01             	cmp    edx,0x1
  415731:	76 38                	jbe    41576b <slm_thd_sched_wakeup+0x5b>
	assert(t->state == SLM_THD_BLOCKED);
  415733:	83 f8 01             	cmp    eax,0x1
  415736:	75 41                	jne    415779 <slm_thd_sched_wakeup+0x69>
	t->state = SLM_THD_RUNNABLE;
  415738:	c7 47 04 03 00 00 00 	mov    DWORD PTR [rdi+0x4],0x3
	slm_sched_wakeup(t);
  41573f:	e8 7c c3 fe ff       	call   401ac0 <slm_sched_wakeup>
	return 0;
  415744:	31 c0                	xor    eax,eax
}
  415746:	5d                   	pop    rbp
  415747:	c3                   	ret    
  415748:	be 23 00 00 00       	mov    esi,0x23
  41574d:	bf 98 f8 41 00       	mov    edi,0x41f898
  415752:	e8 29 55 ff ff       	call   40ac80 <cos_print_str>
	assert(t);
  415757:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41575e:	00 00 00 00 
  415762:	0f 0b                	ud2    
	if (unlikely(!(t->properties & SLM_THD_PROPERTY_SUSPENDED))) return 1;
  415764:	b8 01 00 00 00       	mov    eax,0x1
}
  415769:	5d                   	pop    rbp
  41576a:	c3                   	ret    
		t->state = SLM_THD_RUNNABLE;
  41576b:	c7 47 04 03 00 00 00 	mov    DWORD PTR [rdi+0x4],0x3
		return 1;
  415772:	b8 01 00 00 00       	mov    eax,0x1
}
  415777:	5d                   	pop    rbp
  415778:	c3                   	ret    
  415779:	be 23 00 00 00       	mov    esi,0x23
  41577e:	bf 70 f6 41 00       	mov    edi,0x41f670
  415783:	e8 f8 54 ff ff       	call   40ac80 <cos_print_str>
	assert(t->state == SLM_THD_BLOCKED);
  415788:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41578f:	00 00 00 00 
  415793:	0f 0b                	ud2    
  415795:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41579c:	00 00 00 00 

00000000004157a0 <slm_thd_wakeup>:
{
  4157a0:	f3 0f 1e fa          	endbr64 
  4157a4:	55                   	push   rbp
  4157a5:	48 89 e5             	mov    rbp,rsp
  4157a8:	41 54                	push   r12
  4157aa:	53                   	push   rbx
	assert(t);
  4157ab:	48 85 ff             	test   rdi,rdi
  4157ae:	0f 84 86 00 00 00    	je     41583a <slm_thd_wakeup+0x9a>
  4157b4:	48 89 fb             	mov    rbx,rdi
  4157b7:	0f 01 f9             	rdtscp 
	if (unlikely(t->cpuid != cos_cpuid())) {
  4157ba:	4c 63 47 38          	movsxd r8,DWORD PTR [rdi+0x38]
	return (long)coreid;
  4157be:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  4157c4:	49 39 c8             	cmp    r8,rcx
  4157c7:	0f 85 89 00 00 00    	jne    415856 <slm_thd_wakeup+0xb6>
	if (t->state == SLM_THD_WOKEN) return 1;
  4157cd:	8b 47 04             	mov    eax,DWORD PTR [rdi+0x4]
  4157d0:	83 f8 02             	cmp    eax,0x2
  4157d3:	74 5b                	je     415830 <slm_thd_wakeup+0x90>
	if (unlikely(t->state == SLM_THD_RUNNABLE || (redundant && t->state == SLM_THD_WOKEN))) {
  4157d5:	83 f8 03             	cmp    eax,0x3
  4157d8:	0f 84 2f 01 00 00    	je     41590d <slm_thd_wakeup+0x16d>
	assert(t->state == SLM_THD_BLOCKED);
  4157de:	83 f8 01             	cmp    eax,0x1
  4157e1:	0f 85 37 01 00 00    	jne    41591e <slm_thd_wakeup+0x17e>
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  4157e7:	0f 01 f9             	rdtscp 
	return t != &g->idle_thd && t != &g->sched_thd;
  4157ea:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  4157f0:	48 8d 04 89          	lea    rax,[rcx+rcx*4]
  4157f4:	48 c1 e0 06          	shl    rax,0x6
  4157f8:	48 8d 90 80 65 71 00 	lea    rdx,[rax+0x716580]
  4157ff:	48 39 d7             	cmp    rdi,rdx
  415802:	0f 84 38 01 00 00    	je     415940 <slm_thd_wakeup+0x1a0>
  415808:	48 05 08 65 71 00    	add    rax,0x716508
  41580e:	48 39 c7             	cmp    rdi,rax
  415811:	0f 84 29 01 00 00    	je     415940 <slm_thd_wakeup+0x1a0>
	t->state = SLM_THD_RUNNABLE;
  415817:	c7 47 04 03 00 00 00 	mov    DWORD PTR [rdi+0x4],0x3
	slm_sched_wakeup(t);
  41581e:	e8 9d c2 fe ff       	call   401ac0 <slm_sched_wakeup>
	t->properties &= ~SLM_THD_PROPERTY_SUSPENDED;
  415823:	83 23 fb             	and    DWORD PTR [rbx],0xfffffffb
	return slm_thd_wakeup_blked(t);
  415826:	31 c0                	xor    eax,eax
}
  415828:	5b                   	pop    rbx
  415829:	41 5c                	pop    r12
  41582b:	5d                   	pop    rbp
  41582c:	c3                   	ret    
  41582d:	0f 1f 00             	nop    DWORD PTR [rax]
  415830:	5b                   	pop    rbx
	if (t->state == SLM_THD_WOKEN) return 1;
  415831:	b8 01 00 00 00       	mov    eax,0x1
}
  415836:	41 5c                	pop    r12
  415838:	5d                   	pop    rbp
  415839:	c3                   	ret    
  41583a:	be 23 00 00 00       	mov    esi,0x23
  41583f:	bf c0 f8 41 00       	mov    edi,0x41f8c0
  415844:	e8 37 54 ff ff       	call   40ac80 <cos_print_str>
	assert(t);
  415849:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  415850:	00 00 00 00 
  415854:	0f 0b                	ud2    
		event.tid = t->tid;
  415856:	4d 69 c8 c0 10 00 00 	imul   r9,r8,0x10c0
  41585d:	4c 8b 5f 18          	mov    r11,QWORD PTR [rdi+0x18]
	const unsigned int mask = ring->mask;
  415861:	41 8b b1 a4 df 70 00 	mov    esi,DWORD PTR [r9+0x70dfa4]
  415868:	4d 8d 91 a8 00 00 00 	lea    r10,[r9+0xa8]
	producer = ck_pr_load_uint(&ring->p_head);
  41586f:	49 8d 91 64 df 70 00 	lea    rdx,[r9+0x70df64]
  415876:	41 8b 99 64 df 70 00 	mov    ebx,DWORD PTR [r9+0x70df64]
		consumer = ck_pr_load_uint(&ring->c_head);
  41587d:	4d 8d a1 20 df 70 00 	lea    r12,[r9+0x70df20]
  415884:	eb 14                	jmp    41589a <slm_thd_wakeup+0xfa>
  415886:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41588d:	00 00 00 
CK_PR_CAS_S(uint, unsigned int, "cmpxchgl")
  415890:	89 d8                	mov    eax,ebx
  415892:	f0 0f b1 3a          	lock cmpxchg DWORD PTR [rdx],edi
  415896:	89 c3                	mov    ebx,eax
			if (ck_pr_cas_uint_value(&ring->p_head,
  415898:	74 1d                	je     4158b7 <slm_thd_wakeup+0x117>
CK_PR_LOAD_S(uint, unsigned int, "movl")
  41589a:	41 8b 0c 24          	mov    ecx,DWORD PTR [r12]
		if (CK_CC_LIKELY((producer - consumer) < mask)) {
  41589e:	89 d8                	mov    eax,ebx
		delta = producer + 1;
  4158a0:	8d 7b 01             	lea    edi,[rbx+0x1]
		if (CK_CC_LIKELY((producer - consumer) < mask)) {
  4158a3:	29 c8                	sub    eax,ecx
  4158a5:	39 c6                	cmp    esi,eax
  4158a7:	77 e7                	ja     415890 <slm_thd_wakeup+0xf0>
  4158a9:	8b 02                	mov    eax,DWORD PTR [rdx]
			if (producer == new_producer) {
  4158ab:	39 c3                	cmp    ebx,eax
  4158ad:	0f 84 a9 00 00 00    	je     41595c <slm_thd_wakeup+0x1bc>
  4158b3:	89 c3                	mov    ebx,eax
  4158b5:	eb e3                	jmp    41589a <slm_thd_wakeup+0xfa>
	buffer = (char *)buffer + ts * (producer & mask);
  4158b7:	21 c6                	and    esi,eax
	while (ck_pr_load_uint(&ring->p_tail) != producer)
  4158b9:	49 8d 89 60 df 70 00 	lea    rcx,[r9+0x70df60]
	buffer = (char *)buffer + ts * (producer & mask);
  4158c0:	8d 14 f5 00 00 00 00 	lea    edx,[rsi*8+0x0]
	while (ck_pr_load_uint(&ring->p_tail) != producer)
  4158c7:	49 8d 71 60          	lea    rsi,[r9+0x60]
	memcpy(buffer, entry, ts);
  4158cb:	4d 89 9c 12 00 df 70 	mov    QWORD PTR [r10+rdx*1+0x70df00],r11
  4158d2:	00 
  4158d3:	8b 96 00 df 70 00    	mov    edx,DWORD PTR [rsi+0x70df00]
	while (ck_pr_load_uint(&ring->p_tail) != producer)
  4158d9:	39 c2                	cmp    edx,eax
  4158db:	74 0b                	je     4158e8 <slm_thd_wakeup+0x148>
  4158dd:	0f 1f 00             	nop    DWORD PTR [rax]
	__asm__ __volatile__("pause" ::: "memory");
  4158e0:	f3 90                	pause  
CK_PR_LOAD_S(uint, unsigned int, "movl")
  4158e2:	8b 11                	mov    edx,DWORD PTR [rcx]
  4158e4:	39 d0                	cmp    eax,edx
  4158e6:	75 f8                	jne    4158e0 <slm_thd_wakeup+0x140>
CK_PR_STORE_S(uint, unsigned int, "movl", CK_CC_IMM_U32)
  4158e8:	89 be 00 df 70 00    	mov    DWORD PTR [rsi+0x70df00],edi
		cos_asnd(ipi_data->ipi_thd.asnd, 1);
  4158ee:	4d 69 c0 c0 10 00 00 	imul   r8,r8,0x10c0
  4158f5:	be 01 00 00 00       	mov    esi,0x1
  4158fa:	49 8b b8 08 df 70 00 	mov    rdi,QWORD PTR [r8+0x70df08]
  415901:	e8 fa c2 ff ff       	call   411c00 <cos_asnd>
		return 0;
  415906:	31 c0                	xor    eax,eax
  415908:	e9 1b ff ff ff       	jmp    415828 <slm_thd_wakeup+0x88>
		t->state = SLM_THD_WOKEN;
  41590d:	c7 47 04 02 00 00 00 	mov    DWORD PTR [rdi+0x4],0x2
		return 1;
  415914:	b8 01 00 00 00       	mov    eax,0x1
  415919:	e9 0a ff ff ff       	jmp    415828 <slm_thd_wakeup+0x88>
  41591e:	be 23 00 00 00       	mov    esi,0x23
  415923:	bf e8 f8 41 00       	mov    edi,0x41f8e8
  415928:	e8 53 53 ff ff       	call   40ac80 <cos_print_str>
	assert(t->state == SLM_THD_BLOCKED);
  41592d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  415934:	00 00 00 00 
  415938:	0f 0b                	ud2    
  41593a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  415940:	be 23 00 00 00       	mov    esi,0x23
  415945:	bf 38 f9 41 00       	mov    edi,0x41f938
  41594a:	e8 31 53 ff ff       	call   40ac80 <cos_print_str>
	assert(slm_thd_normal(t));
  41594f:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  415956:	00 00 00 00 
  41595a:	0f 0b                	ud2    
  41595c:	be 23 00 00 00       	mov    esi,0x23
  415961:	bf 10 f9 41 00       	mov    edi,0x41f910
  415966:	e8 15 53 ff ff       	call   40ac80 <cos_print_str>
		assert(ret);
  41596b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  415972:	00 00 00 00 
  415976:	0f 0b                	ud2    
  415978:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41597f:	00 

0000000000415980 <slm_thd_wakeup_cs>:
{
  415980:	f3 0f 1e fa          	endbr64 
  415984:	55                   	push   rbp
  415985:	48 89 e5             	mov    rbp,rsp
  415988:	41 57                	push   r15
  41598a:	41 56                	push   r14
  41598c:	41 55                	push   r13
  41598e:	41 54                	push   r12
  415990:	53                   	push   rbx
  415991:	48 83 ec 18          	sub    rsp,0x18
	assert(t);
  415995:	48 85 f6             	test   rsi,rsi
  415998:	0f 84 42 02 00 00    	je     415be0 <slm_thd_wakeup_cs+0x260>
  41599e:	48 89 fb             	mov    rbx,rdi
	assert(current);
  4159a1:	48 85 ff             	test   rdi,rdi
  4159a4:	0f 84 ad 02 00 00    	je     415c57 <slm_thd_wakeup_cs+0x2d7>
  4159aa:	49 89 f5             	mov    r13,rsi
  4159ad:	0f 01 f9             	rdtscp 
	cs = &(slm_global()->lock);
  4159b0:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  4159b6:	4c 8d 24 89          	lea    r12,[rcx+rcx*4]
  4159ba:	49 c1 e4 06          	shl    r12,0x6
  4159be:	49 81 c4 00 65 71 00 	add    r12,0x716500
		tok    = cos_sched_sync();
  4159c5:	e8 46 c1 ff ff       	call   411b10 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  4159ca:	49 8b 34 24          	mov    rsi,QWORD PTR [r12]
  4159ce:	41 89 c0             	mov    r8d,eax
		if (unlikely(owner)) {
  4159d1:	48 89 f7             	mov    rdi,rsi
  4159d4:	48 83 e7 fe          	and    rdi,0xfffffffffffffffe
  4159d8:	0f 85 1e 02 00 00    	jne    415bfc <slm_thd_wakeup_cs+0x27c>
  4159de:	48 89 f0             	mov    rax,rsi
  4159e1:	f0 49 0f b1 1c 24    	lock cmpxchg QWORD PTR [r12],rbx
  4159e7:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  4159ea:	84 c0                	test   al,al
  4159ec:	74 d7                	je     4159c5 <slm_thd_wakeup_cs+0x45>
	if (slm_thd_wakeup(t, 0)) {
  4159ee:	31 f6                	xor    esi,esi
  4159f0:	4c 89 ef             	mov    rdi,r13
  4159f3:	e8 a8 fd ff ff       	call   4157a0 <slm_thd_wakeup>
  4159f8:	85 c0                	test   eax,eax
  4159fa:	0f 85 40 01 00 00    	jne    415b40 <slm_thd_wakeup_cs+0x1c0>
	struct cos_compinfo    *ci  = &cos_defcompinfo_curr_get()->ci;
  415a00:	e8 4b 5b ff ff       	call   40b550 <cos_defcompinfo_curr_get>
  415a05:	0f 01 f9             	rdtscp 
	if (unlikely(!t)) t = &g->idle_thd;
  415a08:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  415a0e:	45 31 ff             	xor    r15d,r15d
  415a11:	4c 8d 2c 89          	lea    r13,[rcx+rcx*4]
  415a15:	49 c1 e5 06          	shl    r13,0x6
  415a19:	49 8d 85 80 65 71 00 	lea    rax,[r13+0x716580]
  415a20:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
	tok  = cos_sched_sync();
  415a24:	e8 e7 c0 ff ff       	call   411b10 <cos_sched_sync>
  415a29:	41 89 c6             	mov    r14d,eax
	t = slm_sched_schedule();
  415a2c:	e8 af c0 fe ff       	call   401ae0 <slm_sched_schedule>
	if (unlikely(!t)) t = &g->idle_thd;
  415a31:	48 85 c0             	test   rax,rax
	t = slm_sched_schedule();
  415a34:	49 89 c4             	mov    r12,rax
	if (unlikely(!t)) t = &g->idle_thd;
  415a37:	4c 0f 44 65 c8       	cmove  r12,QWORD PTR [rbp-0x38]
{ return s == SLM_THD_RUNNABLE || s == SLM_THD_WOKEN; }
  415a3c:	41 8b 44 24 04       	mov    eax,DWORD PTR [r12+0x4]
  415a41:	83 e8 02             	sub    eax,0x2
	assert(slm_state_is_runnable(t->state));
  415a44:	83 f8 01             	cmp    eax,0x1
  415a47:	0f 87 8b 02 00 00    	ja     415cd8 <slm_thd_wakeup_cs+0x358>
  415a4d:	0f 01 f9             	rdtscp 
	struct slm_cs *cs = &(slm_global()->lock);
  415a50:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  415a56:	48 8d 3c 89          	lea    rdi,[rcx+rcx*4]
  415a5a:	48 c1 e7 06          	shl    rdi,0x6
  415a5e:	4c 8d af 00 65 71 00 	lea    r13,[rdi+0x716500]
	while (ret != 0) {
  415a65:	eb 19                	jmp    415a80 <slm_thd_wakeup_cs+0x100>
  415a67:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  415a6e:	00 00 
  415a70:	48 89 f0             	mov    rax,rsi
  415a73:	f0 49 0f b1 55 00    	lock cmpxchg QWORD PTR [r13+0x0],rdx
  415a79:	0f 94 c0             	sete   al
  415a7c:	84 c0                	test   al,al
  415a7e:	75 57                	jne    415ad7 <slm_thd_wakeup_cs+0x157>
		tok    = cos_sched_sync();
  415a80:	e8 8b c0 ff ff       	call   411b10 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  415a85:	49 8b 75 00          	mov    rsi,QWORD PTR [r13+0x0]
  415a89:	41 89 c0             	mov    r8d,eax
		if (unlikely(contention)) {
  415a8c:	48 89 f2             	mov    rdx,rsi
  415a8f:	83 e2 01             	and    edx,0x1
  415a92:	74 dc                	je     415a70 <slm_thd_wakeup_cs+0xf0>
  415a94:	0f 01 f9             	rdtscp 
  415a97:	48 89 f0             	mov    rax,rsi
  415a9a:	f0 4d 0f b1 7d 00    	lock cmpxchg QWORD PTR [r13+0x0],r15
  415aa0:	0f 94 c0             	sete   al
	if (__slm_cs_cas(cs, cached, NULL, 0)) return 1;
  415aa3:	84 c0                	test   al,al
  415aa5:	74 d9                	je     415a80 <slm_thd_wakeup_cs+0x100>
	ret = cos_defswitch(s->thd, curr->priority, TCAP_TIME_NIL, tok);
  415aa7:	81 e1 ff 0f 00 00    	and    ecx,0xfff
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  415aad:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  415ab1:	31 d2                	xor    edx,edx
  415ab3:	48 8d 04 89          	lea    rax,[rcx+rcx*4]
  415ab7:	48 8b 76 30          	mov    rsi,QWORD PTR [rsi+0x30]
  415abb:	44 89 c1             	mov    ecx,r8d
  415abe:	48 c1 e0 06          	shl    rax,0x6
  415ac2:	48 8b b8 18 65 71 00 	mov    rdi,QWORD PTR [rax+0x716518]
  415ac9:	e8 d2 6b ff ff       	call   40c6a0 <cos_defswitch>
	assert(ret != -EINVAL);
  415ace:	83 f8 ea             	cmp    eax,0xffffffea
  415ad1:	0f 84 ed 00 00 00    	je     415bc4 <slm_thd_wakeup_cs+0x244>
	struct cos_defcompinfo *dci = cos_defcompinfo_curr_get();
  415ad7:	e8 74 5a ff ff       	call   40b550 <cos_defcompinfo_curr_get>
  415adc:	0f 01 f9             	rdtscp 
	*coreid = c & 0xFFF;
  415adf:	89 ca                	mov    edx,ecx
	timeout = g->timeout_next;
  415ae1:	81 e1 ff 0f 00 00    	and    ecx,0xfff
	prio = inherit_prio ? curr->priority : t->priority;
  415ae7:	49 8b 74 24 30       	mov    rsi,QWORD PTR [r12+0x30]
	timeout = g->timeout_next;
  415aec:	48 8d 04 89          	lea    rax,[rcx+rcx*4]
  415af0:	66 81 e2 ff 0f       	and    dx,0xfff
  415af5:	49 89 cd             	mov    r13,rcx
  415af8:	48 c1 e0 06          	shl    rax,0x6
  415afc:	4c 8b 88 08 66 71 00 	mov    r9,QWORD PTR [rax+0x716608]
	if (unlikely(t->properties & (SLM_THD_PROPERTY_SEND | SLM_THD_PROPERTY_OWN_TCAP | SLM_THD_PROPERTY_SPECIAL))) {
  415b03:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  415b07:	a8 0b                	test   al,0xb
  415b09:	0f 85 e5 01 00 00    	jne    415cf4 <slm_thd_wakeup_cs+0x374>
	ret = cos_defswitch(t->thd, prio, timeout, tok);
  415b0f:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  415b14:	44 89 f1             	mov    ecx,r14d
  415b17:	4c 89 ca             	mov    rdx,r9
  415b1a:	e8 81 6b ff ff       	call   40c6a0 <cos_defswitch>
	if (unlikely(ret == -EPERM && !slm_thd_normal(t))) {
  415b1f:	83 f8 ff             	cmp    eax,0xffffffff
  415b22:	0f 84 52 02 00 00    	je     415d7a <slm_thd_wakeup_cs+0x3fa>
	if (unlikely(ret != 0)) {
  415b28:	85 c0                	test   eax,eax
  415b2a:	0f 85 43 01 00 00    	jne    415c73 <slm_thd_wakeup_cs+0x2f3>
}
  415b30:	48 83 c4 18          	add    rsp,0x18
  415b34:	5b                   	pop    rbx
  415b35:	41 5c                	pop    r12
  415b37:	41 5d                	pop    r13
  415b39:	41 5e                	pop    r14
  415b3b:	41 5f                	pop    r15
  415b3d:	5d                   	pop    rbp
  415b3e:	c3                   	ret    
  415b3f:	90                   	nop
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  415b40:	0f 01 f9             	rdtscp 
	struct slm_cs *cs = &(slm_global()->lock);
  415b43:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  415b49:	45 31 e4             	xor    r12d,r12d
  415b4c:	48 8d 1c 89          	lea    rbx,[rcx+rcx*4]
  415b50:	48 c1 e3 06          	shl    rbx,0x6
  415b54:	48 81 c3 00 65 71 00 	add    rbx,0x716500
	while (ret != 0) {
  415b5b:	eb 12                	jmp    415b6f <slm_thd_wakeup_cs+0x1ef>
  415b5d:	0f 1f 00             	nop    DWORD PTR [rax]
  415b60:	48 89 f0             	mov    rax,rsi
  415b63:	f0 48 0f b1 13       	lock cmpxchg QWORD PTR [rbx],rdx
  415b68:	0f 94 c0             	sete   al
  415b6b:	84 c0                	test   al,al
  415b6d:	75 c1                	jne    415b30 <slm_thd_wakeup_cs+0x1b0>
		tok    = cos_sched_sync();
  415b6f:	e8 9c bf ff ff       	call   411b10 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  415b74:	48 8b 33             	mov    rsi,QWORD PTR [rbx]
  415b77:	41 89 c0             	mov    r8d,eax
		if (unlikely(contention)) {
  415b7a:	48 89 f2             	mov    rdx,rsi
  415b7d:	83 e2 01             	and    edx,0x1
  415b80:	74 de                	je     415b60 <slm_thd_wakeup_cs+0x1e0>
  415b82:	0f 01 f9             	rdtscp 
  415b85:	48 89 f0             	mov    rax,rsi
  415b88:	f0 4c 0f b1 23       	lock cmpxchg QWORD PTR [rbx],r12
  415b8d:	0f 94 c0             	sete   al
	if (__slm_cs_cas(cs, cached, NULL, 0)) return 1;
  415b90:	84 c0                	test   al,al
  415b92:	74 db                	je     415b6f <slm_thd_wakeup_cs+0x1ef>
	ret = cos_defswitch(s->thd, curr->priority, TCAP_TIME_NIL, tok);
  415b94:	81 e1 ff 0f 00 00    	and    ecx,0xfff
	*thd        = (struct slm_thd *)(oc & (~0UL << 1));
  415b9a:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
  415b9e:	31 d2                	xor    edx,edx
  415ba0:	48 8d 04 89          	lea    rax,[rcx+rcx*4]
  415ba4:	48 8b 76 30          	mov    rsi,QWORD PTR [rsi+0x30]
  415ba8:	44 89 c1             	mov    ecx,r8d
  415bab:	48 c1 e0 06          	shl    rax,0x6
  415baf:	48 8b b8 18 65 71 00 	mov    rdi,QWORD PTR [rax+0x716518]
  415bb6:	e8 e5 6a ff ff       	call   40c6a0 <cos_defswitch>
	assert(ret != -EINVAL);
  415bbb:	83 f8 ea             	cmp    eax,0xffffffea
  415bbe:	0f 85 6c ff ff ff    	jne    415b30 <slm_thd_wakeup_cs+0x1b0>
  415bc4:	be 23 00 00 00       	mov    esi,0x23
  415bc9:	bf 98 f6 41 00       	mov    edi,0x41f698
  415bce:	e8 ad 50 ff ff       	call   40ac80 <cos_print_str>
  415bd3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  415bda:	00 00 00 00 
  415bde:	0f 0b                	ud2    
  415be0:	be 23 00 00 00       	mov    esi,0x23
  415be5:	bf 60 f9 41 00       	mov    edi,0x41f960
  415bea:	e8 91 50 ff ff       	call   40ac80 <cos_print_str>
	assert(t);
  415bef:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  415bf6:	00 00 00 00 
  415bfa:	0f 0b                	ud2    
  415bfc:	0f 01 f9             	rdtscp 
	if (!contended) {
  415bff:	40 f6 c6 01          	test   sil,0x1
  415c03:	75 1b                	jne    415c20 <slm_thd_wakeup_cs+0x2a0>
	return !ps_cas(&cs->owner_contention, (unsigned long)cached, ((unsigned long)thd | !!contention));
  415c05:	48 89 fa             	mov    rdx,rdi
  415c08:	48 89 f0             	mov    rax,rsi
  415c0b:	48 83 ca 01          	or     rdx,0x1
  415c0f:	f0 49 0f b1 14 24    	lock cmpxchg QWORD PTR [r12],rdx
  415c15:	0f 94 c0             	sete   al
		if (__slm_cs_cas(cs, cached, owner, 1)) return 1;
  415c18:	84 c0                	test   al,al
  415c1a:	0f 84 a5 fd ff ff    	je     4159c5 <slm_thd_wakeup_cs+0x45>
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  415c20:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
  415c24:	48 8b 7f 10          	mov    rdi,QWORD PTR [rdi+0x10]
  415c28:	31 d2                	xor    edx,edx
  415c2a:	44 89 c1             	mov    ecx,r8d
  415c2d:	e8 6e 6a ff ff       	call   40c6a0 <cos_defswitch>
			assert(ret != -EBUSY);
  415c32:	83 f8 f0             	cmp    eax,0xfffffff0
  415c35:	0f 85 8a fd ff ff    	jne    4159c5 <slm_thd_wakeup_cs+0x45>
  415c3b:	be 25 00 00 00       	mov    esi,0x25
  415c40:	bf 80 f7 41 00       	mov    edi,0x41f780
  415c45:	e8 36 50 ff ff       	call   40ac80 <cos_print_str>
  415c4a:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  415c51:	00 00 00 00 
  415c55:	0f 0b                	ud2    
  415c57:	be 25 00 00 00       	mov    esi,0x25
  415c5c:	bf 70 f8 41 00       	mov    edi,0x41f870
  415c61:	e8 1a 50 ff ff       	call   40ac80 <cos_print_str>
	assert(current);
  415c66:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  415c6d:	00 00 00 00 
  415c71:	0f 0b                	ud2    
		assert(ret != -EINVAL);
  415c73:	83 f8 ea             	cmp    eax,0xffffffea
  415c76:	0f 84 f8 01 00 00    	je     415e74 <slm_thd_wakeup_cs+0x4f4>
		if (ret == -EBUSY) return ret;
  415c7c:	83 f8 f0             	cmp    eax,0xfffffff0
  415c7f:	0f 84 ab fe ff ff    	je     415b30 <slm_thd_wakeup_cs+0x1b0>
		assert(ret == -EAGAIN);
  415c85:	83 f8 f5             	cmp    eax,0xfffffff5
  415c88:	0f 85 ca 01 00 00    	jne    415e58 <slm_thd_wakeup_cs+0x4d8>
  415c8e:	0f 01 f9             	rdtscp 
	cs = &(slm_global()->lock);
  415c91:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  415c97:	4c 8d 24 89          	lea    r12,[rcx+rcx*4]
  415c9b:	49 c1 e4 06          	shl    r12,0x6
  415c9f:	49 81 c4 00 65 71 00 	add    r12,0x716500
		tok    = cos_sched_sync();
  415ca6:	e8 65 be ff ff       	call   411b10 <cos_sched_sync>
	unsigned long oc = ps_load(&cs->owner_contention);
  415cab:	49 8b 34 24          	mov    rsi,QWORD PTR [r12]
  415caf:	41 89 c0             	mov    r8d,eax
		if (unlikely(owner)) {
  415cb2:	48 89 f7             	mov    rdi,rsi
  415cb5:	48 83 e7 fe          	and    rdi,0xfffffffffffffffe
  415cb9:	0f 85 3c 01 00 00    	jne    415dfb <slm_thd_wakeup_cs+0x47b>
  415cbf:	48 89 f0             	mov    rax,rsi
  415cc2:	f0 49 0f b1 1c 24    	lock cmpxchg QWORD PTR [r12],rbx
  415cc8:	0f 94 c0             	sete   al
		if (likely(!__slm_cs_cas(cs, cached, current, 0))) return 0;
  415ccb:	84 c0                	test   al,al
  415ccd:	0f 85 51 fd ff ff    	jne    415a24 <slm_thd_wakeup_cs+0xa4>
  415cd3:	eb d1                	jmp    415ca6 <slm_thd_wakeup_cs+0x326>
  415cd5:	0f 1f 00             	nop    DWORD PTR [rax]
  415cd8:	be 2d 00 00 00       	mov    esi,0x2d
  415cdd:	bf c0 f6 41 00       	mov    edi,0x41f6c0
  415ce2:	e8 99 4f ff ff       	call   40ac80 <cos_print_str>
	assert(slm_state_is_runnable(t->state));
  415ce7:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  415cee:	00 00 00 00 
  415cf2:	0f 0b                	ud2    
		if (t == &g->sched_thd) {
  415cf4:	0f b7 d2             	movzx  edx,dx
	timeout = g->timeout_next;
  415cf7:	4c 89 c9             	mov    rcx,r9
		if (t == &g->sched_thd) {
  415cfa:	48 8d 14 92          	lea    rdx,[rdx+rdx*4]
  415cfe:	48 c1 e2 06          	shl    rdx,0x6
  415d02:	48 81 c2 08 65 71 00 	add    rdx,0x716508
  415d09:	49 39 d4             	cmp    r12,rdx
  415d0c:	0f 84 b9 00 00 00    	je     415dcb <slm_thd_wakeup_cs+0x44b>
		if (t->properties & SLM_THD_PROPERTY_SEND) {
  415d12:	a8 02                	test   al,0x2
  415d14:	0f 85 bc 00 00 00    	jne    415dd6 <slm_thd_wakeup_cs+0x456>
		} else if (t->properties & SLM_THD_PROPERTY_OWN_TCAP) {
  415d1a:	49 89 c9             	mov    r9,rcx
  415d1d:	a8 01                	test   al,0x1
  415d1f:	0f 84 ea fd ff ff    	je     415b0f <slm_thd_wakeup_cs+0x18f>
			return cos_switch(t->thd, t->tc, prio, timeout, g->sched_thd.rcv, tok);
  415d25:	4b 8d 44 ad 00       	lea    rax,[r13+r13*4+0x0]
  415d2a:	4d 8b 54 24 08       	mov    r10,QWORD PTR [r12+0x8]
  415d2f:	48 89 f2             	mov    rdx,rsi
  415d32:	45 89 f1             	mov    r9d,r14d
  415d35:	48 c1 e0 06          	shl    rax,0x6
  415d39:	49 8b 7c 24 10       	mov    rdi,QWORD PTR [r12+0x10]
  415d3e:	4c 8b 80 28 65 71 00 	mov    r8,QWORD PTR [rax+0x716528]
  415d45:	4c 89 d6             	mov    rsi,r10
  415d48:	e8 e3 bd ff ff       	call   411b30 <cos_switch>
	if (unlikely(ret != 0)) {
  415d4d:	85 c0                	test   eax,eax
  415d4f:	0f 84 db fd ff ff    	je     415b30 <slm_thd_wakeup_cs+0x1b0>
		assert(ret != -EPERM);
  415d55:	83 f8 ff             	cmp    eax,0xffffffff
  415d58:	0f 85 15 ff ff ff    	jne    415c73 <slm_thd_wakeup_cs+0x2f3>
  415d5e:	be 2d 00 00 00       	mov    esi,0x2d
  415d63:	bf f0 f6 41 00       	mov    edi,0x41f6f0
  415d68:	e8 13 4f ff ff       	call   40ac80 <cos_print_str>
  415d6d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  415d74:	00 00 00 00 
  415d78:	0f 0b                	ud2    
  415d7a:	0f 01 f9             	rdtscp 
	return t != &g->idle_thd && t != &g->sched_thd;
  415d7d:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  415d83:	48 8d 04 89          	lea    rax,[rcx+rcx*4]
  415d87:	48 c1 e0 06          	shl    rax,0x6
  415d8b:	48 8d 90 80 65 71 00 	lea    rdx,[rax+0x716580]
  415d92:	49 39 d4             	cmp    r12,rdx
  415d95:	74 0b                	je     415da2 <slm_thd_wakeup_cs+0x422>
  415d97:	48 05 08 65 71 00    	add    rax,0x716508
  415d9d:	49 39 c4             	cmp    r12,rax
  415da0:	75 bc                	jne    415d5e <slm_thd_wakeup_cs+0x3de>
		ret = cos_switch(g->sched_thd.thd, 0, curr->priority, TCAP_TIME_NIL, g->sched_thd.rcv, tok);
  415da2:	4b 8d 44 ad 00       	lea    rax,[r13+r13*4+0x0]
  415da7:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]
  415dab:	45 89 f1             	mov    r9d,r14d
  415dae:	31 c9                	xor    ecx,ecx
  415db0:	48 c1 e0 06          	shl    rax,0x6
  415db4:	31 f6                	xor    esi,esi
  415db6:	4c 8b 80 28 65 71 00 	mov    r8,QWORD PTR [rax+0x716528]
  415dbd:	48 8b b8 18 65 71 00 	mov    rdi,QWORD PTR [rax+0x716518]
  415dc4:	e8 67 bd ff ff       	call   411b30 <cos_switch>
  415dc9:	eb 82                	jmp    415d4d <slm_thd_wakeup_cs+0x3cd>
			prio    = curr->priority;
  415dcb:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
			timeout = TCAP_TIME_NIL;
  415dcf:	31 c9                	xor    ecx,ecx
  415dd1:	e9 3c ff ff ff       	jmp    415d12 <slm_thd_wakeup_cs+0x392>
			return cos_sched_asnd(t->asnd, g->timeout_next, g->sched_thd.rcv, tok);
  415dd6:	4b 8d 44 ad 00       	lea    rax,[r13+r13*4+0x0]
  415ddb:	49 8b 7c 24 28       	mov    rdi,QWORD PTR [r12+0x28]
  415de0:	44 89 f1             	mov    ecx,r14d
  415de3:	4c 89 ce             	mov    rsi,r9
  415de6:	48 c1 e0 06          	shl    rax,0x6
  415dea:	48 8b 90 28 65 71 00 	mov    rdx,QWORD PTR [rax+0x716528]
  415df1:	e8 aa bd ff ff       	call   411ba0 <cos_sched_asnd>
  415df6:	e9 52 ff ff ff       	jmp    415d4d <slm_thd_wakeup_cs+0x3cd>
  415dfb:	0f 01 f9             	rdtscp 
	if (!contended) {
  415dfe:	40 f6 c6 01          	test   sil,0x1
  415e02:	75 1b                	jne    415e1f <slm_thd_wakeup_cs+0x49f>
	return !ps_cas(&cs->owner_contention, (unsigned long)cached, ((unsigned long)thd | !!contention));
  415e04:	48 89 fa             	mov    rdx,rdi
  415e07:	48 89 f0             	mov    rax,rsi
  415e0a:	48 83 ca 01          	or     rdx,0x1
  415e0e:	f0 49 0f b1 14 24    	lock cmpxchg QWORD PTR [r12],rdx
  415e14:	0f 94 c0             	sete   al
		if (__slm_cs_cas(cs, cached, owner, 1)) return 1;
  415e17:	84 c0                	test   al,al
  415e19:	0f 84 87 fe ff ff    	je     415ca6 <slm_thd_wakeup_cs+0x326>
	ret = cos_defswitch(owner->thd, curr->priority, TCAP_TIME_NIL, tok);
  415e1f:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
  415e23:	48 8b 7f 10          	mov    rdi,QWORD PTR [rdi+0x10]
  415e27:	31 d2                	xor    edx,edx
  415e29:	44 89 c1             	mov    ecx,r8d
  415e2c:	e8 6f 68 ff ff       	call   40c6a0 <cos_defswitch>
			assert(ret != -EBUSY);
  415e31:	83 f8 f0             	cmp    eax,0xfffffff0
  415e34:	0f 85 6c fe ff ff    	jne    415ca6 <slm_thd_wakeup_cs+0x326>
  415e3a:	bf 80 f7 41 00       	mov    edi,0x41f780
  415e3f:	e8 dc e5 ff ff       	call   414420 <prints.isra.0>
  415e44:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  415e4b:	00 00 00 00 
  415e4f:	0f 0b                	ud2    
  415e51:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  415e58:	be 2d 00 00 00       	mov    esi,0x2d
  415e5d:	bf 50 f7 41 00       	mov    edi,0x41f750
  415e62:	e8 19 4e ff ff       	call   40ac80 <cos_print_str>
		assert(ret == -EAGAIN);
  415e67:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  415e6e:	00 00 00 00 
  415e72:	0f 0b                	ud2    
  415e74:	be 2d 00 00 00       	mov    esi,0x2d
  415e79:	bf 20 f7 41 00       	mov    edi,0x41f720
  415e7e:	e8 fd 4d ff ff       	call   40ac80 <cos_print_str>
		assert(ret != -EINVAL);
  415e83:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  415e8a:	00 00 00 00 
  415e8e:	0f 0b                	ud2    

0000000000415e90 <slm_thd_event_reset>:
{
  415e90:	f3 0f 1e fa          	endbr64 
	memset(&t->event_info, 0, sizeof(struct event_info));
  415e94:	66 0f ef c0          	pxor   xmm0,xmm0
  415e98:	48 c7 47 50 00 00 00 	mov    QWORD PTR [rdi+0x50],0x0
  415e9f:	00 
  415ea0:	0f 11 47 40          	movups XMMWORD PTR [rdi+0x40],xmm0
}
  415ea4:	c3                   	ret    
  415ea5:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  415eac:	00 00 00 00 

0000000000415eb0 <slm_get_cycs_per_usec>:
{
  415eb0:	f3 0f 1e fa          	endbr64 
  415eb4:	0f 01 f9             	rdtscp 
	return (unsigned long)g->cyc_per_usec;
  415eb7:	81 e1 ff 0f 00 00    	and    ecx,0xfff
  415ebd:	48 8d 04 89          	lea    rax,[rcx+rcx*4]
  415ec1:	48 c1 e0 06          	shl    rax,0x6
  415ec5:	48 63 80 f8 65 71 00 	movsxd rax,DWORD PTR [rax+0x7165f8]
}
  415ecc:	c3                   	ret    
  415ecd:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000415ed0 <slm_sched_loop>:
	}
}

void
slm_sched_loop(void)
{
  415ed0:	f3 0f 1e fa          	endbr64 
  415ed4:	55                   	push   rbp
	slm_sched_loop_intern(0);
  415ed5:	31 ff                	xor    edi,edi
{
  415ed7:	48 89 e5             	mov    rbp,rsp
	slm_sched_loop_intern(0);
  415eda:	e8 71 e5 ff ff       	call   414450 <slm_sched_loop_intern>
  415edf:	90                   	nop

0000000000415ee0 <slm_sched_loop_nonblock>:
}

void
slm_sched_loop_nonblock(void)
{
  415ee0:	f3 0f 1e fa          	endbr64 
  415ee4:	55                   	push   rbp
	slm_sched_loop_intern(1);
  415ee5:	bf 01 00 00 00       	mov    edi,0x1
{
  415eea:	48 89 e5             	mov    rbp,rsp
	slm_sched_loop_intern(1);
  415eed:	e8 5e e5 ff ff       	call   414450 <slm_sched_loop_intern>
  415ef2:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  415ef9:	00 00 00 00 
  415efd:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000415f00 <slm_init>:
}

void
slm_init(thdcap_t thd, thdid_t tid)
{
  415f00:	f3 0f 1e fa          	endbr64 
  415f04:	55                   	push   rbp
  415f05:	48 89 e5             	mov    rbp,rsp
  415f08:	41 56                	push   r14
  415f0a:	41 55                	push   r13
  415f0c:	49 89 f5             	mov    r13,rsi
  415f0f:	41 54                	push   r12
  415f11:	53                   	push   rbx
  415f12:	48 83 ec 10          	sub    rsp,0x10
  415f16:	48 89 7d d8          	mov    QWORD PTR [rbp-0x28],rdi
  415f1a:	0f 01 f9             	rdtscp 
	*coreid = c & 0xFFF;
  415f1d:	41 89 ce             	mov    r14d,ecx
	return &__slm_global[cos_coreid()];
  415f20:	89 cb                	mov    ebx,ecx
	struct slm_thd *s    = &g->sched_thd;
	struct slm_thd *i    = &g->idle_thd;
	struct cos_defcompinfo *defci;
	struct cos_aep_info    *sched_aep;

	defci = cos_defcompinfo_curr_get();
  415f22:	e8 29 56 ff ff       	call   40b550 <cos_defcompinfo_curr_get>
  415f27:	66 41 81 e6 ff 0f    	and    r14w,0xfff
  415f2d:	81 e3 ff 0f 00 00    	and    ebx,0xfff
  415f33:	48 89 c7             	mov    rdi,rax
	sched_aep = cos_sched_aep_get(defci);
  415f36:	e8 55 56 ff ff       	call   40b590 <cos_sched_aep_get>

	*s = (struct slm_thd) {
		.properties = SLM_THD_PROPERTY_SPECIAL,
		.state = SLM_THD_RUNNABLE,
		.tc  = sched_aep->tc,
  415f3b:	f3 0f 6f 10          	movdqu xmm2,XMMWORD PTR [rax]
  415f3f:	f3 0f 6f 40 10       	movdqu xmm0,XMMWORD PTR [rax+0x10]
  415f44:	48 8b 00             	mov    rax,QWORD PTR [rax]
  415f47:	66 48 0f 6e c8       	movq   xmm1,rax
  415f4c:	0f 16 4d d8          	movhps xmm1,QWORD PTR [rbp-0x28]
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  415f50:	0f 01 f9             	rdtscp 
	*s = (struct slm_thd) {
  415f53:	48 63 c3             	movsxd rax,ebx
  415f56:	48 89 ce             	mov    rsi,rcx
  415f59:	4c 8b 15 50 9a 00 00 	mov    r10,QWORD PTR [rip+0x9a50]        # 41f9b0 <CSWTCH.187+0x5c0>
  415f60:	45 31 c0             	xor    r8d,r8d
  415f63:	4c 8d 24 80          	lea    r12,[rax+rax*4]
  415f67:	b9 0f 00 00 00       	mov    ecx,0xf
  415f6c:	4c 89 c0             	mov    rax,r8
  415f6f:	45 0f b7 f6          	movzx  r14d,r14w
  415f73:	49 c1 e4 06          	shl    r12,0x6
  415f77:	81 e6 ff 0f 00 00    	and    esi,0xfff
  415f7d:	49 8d 9c 24 00 65 71 	lea    rbx,[r12+0x716500]
  415f84:	00 
  415f85:	49 8d bc 24 08 65 71 	lea    rdi,[r12+0x716508]
  415f8c:	00 
  415f8d:	f3 48 ab             	rep stos QWORD PTR es:[rdi],rax
  415f90:	4d 89 94 24 08 65 71 	mov    QWORD PTR [r12+0x716508],r10
  415f97:	00 
  415f98:	0f 29 53 10          	movaps XMMWORD PTR [rbx+0x10],xmm2
  415f9c:	41 0f 29 84 24 20 65 	movaps XMMWORD PTR [r12+0x716520],xmm0
  415fa3:	71 00 
  415fa5:	89 73 40             	mov    DWORD PTR [rbx+0x40],esi
		.tid = sched_aep->tid,
		.rcv = sched_aep->rcv,
		.cpuid = cos_cpuid(),
		.priority = TCAP_PRIO_MAX
	};
	ps_list_init(s, thd_list);
  415fa8:	4b 8d 34 b6          	lea    rsi,[r14+r14*4]
  415fac:	48 c1 e6 06          	shl    rsi,0x6
	*s = (struct slm_thd) {
  415fb0:	48 c7 43 38 01 00 00 	mov    QWORD PTR [rbx+0x38],0x1
  415fb7:	00 
	ps_list_init(s, thd_list);
  415fb8:	48 8d 86 60 65 71 00 	lea    rax,[rsi+0x716560]
  415fbf:	48 89 43 68          	mov    QWORD PTR [rbx+0x68],rax
  415fc3:	48 89 43 60          	mov    QWORD PTR [rbx+0x60],rax
	ps_list_init(s, graveyard_list);
  415fc7:	48 8d 86 70 65 71 00 	lea    rax,[rsi+0x716570]
  415fce:	48 89 43 78          	mov    QWORD PTR [rbx+0x78],rax
  415fd2:	48 89 43 70          	mov    QWORD PTR [rbx+0x70],rax
	__asm__("mov %%rsp, %0;" : "=r"(curr_stk_pointer));
  415fd6:	48 89 e0             	mov    rax,rsp
	return *(long *)((curr_stk_pointer & ~(COS_STACK_SZ - 1)) + COS_STACK_SZ - offset * sizeof(unsigned long));
  415fd9:	48 25 00 e0 ff ff    	and    rax,0xffffffffffffe000
	return cos_get_thd_id();
  415fdf:	0f b7 90 f0 1f 00 00 	movzx  edx,WORD PTR [rax+0x1ff0]
	assert(s->tid == cos_thdid());
  415fe6:	66 48 0f 7e c0       	movq   rax,xmm0
  415feb:	48 39 c2             	cmp    rdx,rax
  415fee:	0f 85 cb 00 00 00    	jne    4160bf <slm_init+0x1bf>
	__asm__ __volatile__("rdtscp" : "=a"(a), "=d"(d), "=c"(c) : : );
  415ff4:	0f 01 f9             	rdtscp 

	*i = (struct slm_thd) {
  415ff7:	49 8d 94 24 80 65 71 	lea    rdx,[r12+0x716580]
  415ffe:	00 
  415fff:	4c 89 c0             	mov    rax,r8
  416002:	49 89 c9             	mov    r9,rcx
  416005:	b9 0f 00 00 00       	mov    ecx,0xf
  41600a:	48 89 d7             	mov    rdi,rdx
  41600d:	41 81 e1 ff 0f 00 00 	and    r9d,0xfff
  416014:	f3 48 ab             	rep stos QWORD PTR es:[rdi],rax
  416017:	4d 89 94 24 80 65 71 	mov    QWORD PTR [r12+0x716580],r10
  41601e:	00 
	ps_list_init(i, graveyard_list);

	ps_list_head_init(&g->event_head);
	ps_list_head_init(&g->graveyard_head);

	g->cyc_per_usec = cos_hw_cycles_per_usec(BOOT_CAPTBL_SELF_INITHW_BASE);
  41601f:	bf 24 00 00 00       	mov    edi,0x24
	*i = (struct slm_thd) {
  416024:	48 b8 ff ff ff ff ff 	movabs rax,0xffffffffffff
  41602b:	ff 00 00 
  41602e:	41 0f 11 8c 24 88 65 	movups XMMWORD PTR [r12+0x716588],xmm1
  416035:	71 00 
  416037:	48 89 83 b0 00 00 00 	mov    QWORD PTR [rbx+0xb0],rax
	ps_list_init(i, thd_list);
  41603e:	48 8d 86 d8 65 71 00 	lea    rax,[rsi+0x7165d8]
  416045:	48 89 83 e0 00 00 00 	mov    QWORD PTR [rbx+0xe0],rax
  41604c:	48 89 83 d8 00 00 00 	mov    QWORD PTR [rbx+0xd8],rax
	ps_list_init(i, graveyard_list);
  416053:	48 8d 86 e8 65 71 00 	lea    rax,[rsi+0x7165e8]
  41605a:	48 89 83 f0 00 00 00 	mov    QWORD PTR [rbx+0xf0],rax
  416061:	48 89 83 e8 00 00 00 	mov    QWORD PTR [rbx+0xe8],rax
	ps_list_head_init(&g->event_head);
  416068:	48 8d 86 10 66 71 00 	lea    rax,[rsi+0x716610]
	ps_list_head_init(&g->graveyard_head);
  41606f:	48 81 c6 20 66 71 00 	add    rsi,0x716620
	*i = (struct slm_thd) {
  416076:	4c 89 ab 98 00 00 00 	mov    QWORD PTR [rbx+0x98],r13
  41607d:	44 89 8b b8 00 00 00 	mov    DWORD PTR [rbx+0xb8],r9d
  416084:	48 89 40 08          	mov    QWORD PTR [rax+0x8],rax
  416088:	48 89 00             	mov    QWORD PTR [rax],rax
  41608b:	48 89 76 08          	mov    QWORD PTR [rsi+0x8],rsi
  41608f:	48 89 36             	mov    QWORD PTR [rsi],rsi
	g->cyc_per_usec = cos_hw_cycles_per_usec(BOOT_CAPTBL_SELF_INITHW_BASE);
  416092:	e8 b9 c6 ff ff       	call   412750 <cos_hw_cycles_per_usec>
	g->lock.owner_contention = 0;
  416097:	49 c7 84 24 00 65 71 	mov    QWORD PTR [r12+0x716500],0x0
  41609e:	00 00 00 00 00 
	g->cyc_per_usec = cos_hw_cycles_per_usec(BOOT_CAPTBL_SELF_INITHW_BASE);
  4160a3:	89 83 f8 00 00 00    	mov    DWORD PTR [rbx+0xf8],eax

	slm_sched_init();
  4160a9:	e8 c2 b9 fe ff       	call   401a70 <slm_sched_init>
	slm_timer_init();
}
  4160ae:	48 83 c4 10          	add    rsp,0x10
  4160b2:	5b                   	pop    rbx
  4160b3:	41 5c                	pop    r12
  4160b5:	41 5d                	pop    r13
  4160b7:	41 5e                	pop    r14
  4160b9:	5d                   	pop    rbp
	slm_timer_init();
  4160ba:	e9 a1 b9 fe ff       	jmp    401a60 <slm_timer_init>
  4160bf:	be 23 00 00 00       	mov    esi,0x23
  4160c4:	bf 88 f9 41 00       	mov    edi,0x41f988
  4160c9:	e8 b2 4b ff ff       	call   40ac80 <cos_print_str>
	assert(s->tid == cos_thdid());
  4160ce:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4160d5:	00 00 00 00 
  4160d9:	0f 0b                	ud2    
  4160db:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000004160e0 <heap_init>:
#endif

/* public functions */
void
heap_init(struct heap *h, int max_sz, cmp_fn_t c, update_fn_t u)
{
  4160e0:	f3 0f 1e fa          	endbr64 
  4160e4:	66 48 0f 6e c2       	movq   xmm0,rdx
  4160e9:	66 48 0f 6e c9       	movq   xmm1,rcx
  4160ee:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
	assert(h);
  4160f2:	48 85 ff             	test   rdi,rdi
  4160f5:	74 19                	je     416110 <heap_init+0x30>

	h->max_sz = max_sz + 1;
  4160f7:	83 c6 01             	add    esi,0x1
	h->e      = 1;
	h->c      = c;
	h->u      = u;
	h->data   = (void *)&h[1];
  4160fa:	48 8d 47 20          	lea    rax,[rdi+0x20]
	h->e      = 1;
  4160fe:	c7 07 01 00 00 00    	mov    DWORD PTR [rdi],0x1
	h->max_sz = max_sz + 1;
  416104:	89 77 04             	mov    DWORD PTR [rdi+0x4],esi
	h->data   = (void *)&h[1];
  416107:	48 89 47 18          	mov    QWORD PTR [rdi+0x18],rax
	h->c      = c;
  41610b:	0f 11 47 08          	movups XMMWORD PTR [rdi+0x8],xmm0
	h->data   = (void *)&h[1];
  41610f:	c3                   	ret    
{
  416110:	55                   	push   rbp
  416111:	be 24 00 00 00       	mov    esi,0x24
  416116:	bf b8 f9 41 00       	mov    edi,0x41f9b8
  41611b:	48 89 e5             	mov    rbp,rsp
  41611e:	e8 5d 4b ff ff       	call   40ac80 <cos_print_str>
	assert(h);
  416123:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41612a:	00 00 00 00 
  41612e:	0f 0b                	ud2    

0000000000416130 <heap_alloc>:
	assert(!heap_verify(h));
}

struct heap *
heap_alloc(int max_sz, cmp_fn_t c, update_fn_t u)
{
  416130:	f3 0f 1e fa          	endbr64 

	heap_init(h, max_sz, c, u);
#endif

	return h;
}
  416134:	31 c0                	xor    eax,eax
  416136:	c3                   	ret    
  416137:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41613e:	00 00 

0000000000416140 <heap_destroy>:

void
heap_destroy(struct heap *h)
{
  416140:	f3 0f 1e fa          	endbr64 
	assert(h && h->data);
  416144:	48 85 ff             	test   rdi,rdi
  416147:	74 08                	je     416151 <heap_destroy+0x11>
  416149:	48 83 7f 18 00       	cmp    QWORD PTR [rdi+0x18],0x0
  41614e:	74 01                	je     416151 <heap_destroy+0x11>
  416150:	c3                   	ret    
{
  416151:	55                   	push   rbp
  416152:	be 24 00 00 00       	mov    esi,0x24
  416157:	bf e0 f9 41 00       	mov    edi,0x41f9e0
  41615c:	48 89 e5             	mov    rbp,rsp
  41615f:	e8 1c 4b ff ff       	call   40ac80 <cos_print_str>
	assert(h && h->data);
  416164:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41616b:	00 00 00 00 
  41616f:	0f 0b                	ud2    
  416171:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  416178:	00 00 00 00 
  41617c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000416180 <heap_add>:
#endif
}

int
heap_add(struct heap *h, void *new)
{
  416180:	f3 0f 1e fa          	endbr64 
  416184:	55                   	push   rbp
  416185:	48 89 e5             	mov    rbp,rsp
  416188:	41 57                	push   r15
  41618a:	41 56                	push   r14
  41618c:	41 55                	push   r13
  41618e:	41 54                	push   r12
  416190:	53                   	push   rbx
  416191:	48 89 fb             	mov    rbx,rdi
  416194:	48 83 ec 18          	sub    rsp,0x18
	int c;

	if (h->max_sz == h->e) return -1;
  416198:	44 8b 37             	mov    r14d,DWORD PTR [rdi]
  41619b:	44 39 77 04          	cmp    DWORD PTR [rdi+0x4],r14d
  41619f:	0f 84 fd 01 00 00    	je     4163a2 <heap_add+0x222>

	debug("heap_add(%p,%d) %p\n", h, h->e, new);

	assert(!heap_verify(h));
	c          = h->e;
	h->data[c] = new;
  4161a5:	48 8b 53 18          	mov    rdx,QWORD PTR [rbx+0x18]
  4161a9:	49 63 c6             	movsxd rax,r14d
  4161ac:	48 89 f7             	mov    rdi,rsi
  4161af:	48 89 34 c2          	mov    QWORD PTR [rdx+rax*8],rsi
	h->u(new, c);
  4161b3:	44 89 f6             	mov    esi,r14d
  4161b6:	ff 53 10             	call   QWORD PTR [rbx+0x10]
	h->e++;
  4161b9:	8b 03                	mov    eax,DWORD PTR [rbx]
  4161bb:	83 c0 01             	add    eax,0x1
  4161be:	89 03                	mov    DWORD PTR [rbx],eax
	assert(c <= h->e);
  4161c0:	41 39 c6             	cmp    r14d,eax
  4161c3:	0f 8f 85 01 00 00    	jg     41634e <heap_add+0x1ce>
	assert(c > 0);
  4161c9:	45 85 f6             	test   r14d,r14d
  4161cc:	0f 8e 98 01 00 00    	jle    41636a <heap_add+0x1ea>
	while (c > 1) {
  4161d2:	41 83 fe 01          	cmp    r14d,0x1
  4161d6:	75 43                	jne    41621b <heap_add+0x9b>
  4161d8:	e9 55 01 00 00       	jmp    416332 <heap_add+0x1b2>
  4161dd:	0f 1f 00             	nop    DWORD PTR [rax]
	arr[a] = arr[b];
  4161e0:	4c 03 63 18          	add    r12,QWORD PTR [rbx+0x18]
	t      = arr[a];
  4161e4:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
	u(arr[a], a);
  4161e8:	44 89 f6             	mov    esi,r14d
	t      = arr[a];
  4161eb:	48 03 43 18          	add    rax,QWORD PTR [rbx+0x18]
	arr[a] = arr[b];
  4161ef:	49 8b 0c 24          	mov    rcx,QWORD PTR [r12]
	t      = arr[a];
  4161f3:	48 8b 10             	mov    rdx,QWORD PTR [rax]
		swap_entries(h->data, p, c, h->u);
  4161f6:	4c 8b 7b 10          	mov    r15,QWORD PTR [rbx+0x10]
	arr[a] = arr[b];
  4161fa:	48 89 08             	mov    QWORD PTR [rax],rcx
	arr[b] = t;
  4161fd:	49 89 14 24          	mov    QWORD PTR [r12],rdx
	u(arr[a], a);
  416201:	48 8b 38             	mov    rdi,QWORD PTR [rax]
  416204:	41 ff d7             	call   r15
	u(arr[b], b);
  416207:	49 8b 3c 24          	mov    rdi,QWORD PTR [r12]
  41620b:	44 89 ee             	mov    esi,r13d
  41620e:	41 ff d7             	call   r15
	while (c > 1) {
  416211:	41 83 fe 01          	cmp    r14d,0x1
  416215:	0f 84 15 01 00 00    	je     416330 <heap_add+0x1b0>
		p = c / 2;
  41621b:	49 63 ce             	movsxd rcx,r14d
		if (h->c(h->data[p], h->data[c])) break; /* done? */
  41621e:	48 8b 43 18          	mov    rax,QWORD PTR [rbx+0x18]
		p = c / 2;
  416222:	41 89 ce             	mov    r14d,ecx
  416225:	49 89 cd             	mov    r13,rcx
		if (h->c(h->data[p], h->data[c])) break; /* done? */
  416228:	4c 8d 24 cd 00 00 00 	lea    r12,[rcx*8+0x0]
  41622f:	00 
		p = c / 2;
  416230:	41 d1 fe             	sar    r14d,1
		if (h->c(h->data[p], h->data[c])) break; /* done? */
  416233:	48 8b 34 c8          	mov    rsi,QWORD PTR [rax+rcx*8]
  416237:	49 63 d6             	movsxd rdx,r14d
  41623a:	48 8d 3c d5 00 00 00 	lea    rdi,[rdx*8+0x0]
  416241:	00 
  416242:	48 89 7d c8          	mov    QWORD PTR [rbp-0x38],rdi
  416246:	48 8b 3c d0          	mov    rdi,QWORD PTR [rax+rdx*8]
  41624a:	ff 53 08             	call   QWORD PTR [rbx+0x8]
  41624d:	85 c0                	test   eax,eax
  41624f:	74 8f                	je     4161e0 <heap_add+0x60>
	assert(c <= h->e);
  416251:	8b 03                	mov    eax,DWORD PTR [rbx]
  416253:	41 39 c5             	cmp    r13d,eax
  416256:	0f 8f 2a 01 00 00    	jg     416386 <heap_add+0x206>
	l = h->e - 1;
  41625c:	83 e8 01             	sub    eax,0x1
  41625f:	89 45 c4             	mov    DWORD PTR [rbp-0x3c],eax
	while (c <= l / 2) { /* not a leaf? */
  416262:	d1 f8                	sar    eax,1
  416264:	89 45 c0             	mov    DWORD PTR [rbp-0x40],eax
  416267:	41 39 c5             	cmp    r13d,eax
  41626a:	7e 75                	jle    4162e1 <heap_add+0x161>
  41626c:	e9 cc 00 00 00       	jmp    41633d <heap_add+0x1bd>
  416271:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		if (h->c(h->data[c], h->data[n])) break; /* done? */
  416278:	48 8b 43 18          	mov    rax,QWORD PTR [rbx+0x18]
  41627c:	49 63 f7             	movsxd rsi,r15d
  41627f:	49 63 cd             	movsxd rcx,r13d
  416282:	4c 8d 24 f5 00 00 00 	lea    r12,[rsi*8+0x0]
  416289:	00 
  41628a:	4c 8d 34 cd 00 00 00 	lea    r14,[rcx*8+0x0]
  416291:	00 
  416292:	48 8b 34 f0          	mov    rsi,QWORD PTR [rax+rsi*8]
  416296:	48 8b 3c c8          	mov    rdi,QWORD PTR [rax+rcx*8]
  41629a:	ff 53 08             	call   QWORD PTR [rbx+0x8]
  41629d:	85 c0                	test   eax,eax
  41629f:	0f 85 98 00 00 00    	jne    41633d <heap_add+0x1bd>
	t      = arr[a];
  4162a5:	4c 03 63 18          	add    r12,QWORD PTR [rbx+0x18]
	arr[a] = arr[b];
  4162a9:	4c 03 73 18          	add    r14,QWORD PTR [rbx+0x18]
		swap_entries(h->data, n, c, h->u);
  4162ad:	48 8b 43 10          	mov    rax,QWORD PTR [rbx+0x10]
	arr[a] = arr[b];
  4162b1:	49 8b 36             	mov    rsi,QWORD PTR [r14]
	t      = arr[a];
  4162b4:	49 8b 0c 24          	mov    rcx,QWORD PTR [r12]
	u(arr[a], a);
  4162b8:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
	arr[a] = arr[b];
  4162bc:	49 89 34 24          	mov    QWORD PTR [r12],rsi
	u(arr[a], a);
  4162c0:	44 89 fe             	mov    esi,r15d
	arr[b] = t;
  4162c3:	49 89 0e             	mov    QWORD PTR [r14],rcx
	u(arr[a], a);
  4162c6:	49 8b 3c 24          	mov    rdi,QWORD PTR [r12]
  4162ca:	ff d0                	call   rax
	u(arr[b], b);
  4162cc:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  4162cf:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  4162d3:	44 89 ee             	mov    esi,r13d
  4162d6:	ff d0                	call   rax
	while (c <= l / 2) { /* not a leaf? */
  4162d8:	44 3b 7d c0          	cmp    r15d,DWORD PTR [rbp-0x40]
  4162dc:	7f 5f                	jg     41633d <heap_add+0x1bd>
  4162de:	45 89 fd             	mov    r13d,r15d
		left  = 2 * c;
  4162e1:	47 8d 7c 2d 00       	lea    r15d,[r13+r13*1+0x0]
		right = 2 * c + 1;
  4162e6:	45 8d 67 01          	lea    r12d,[r15+0x1]
		if (right > l) {
  4162ea:	44 39 65 c4          	cmp    DWORD PTR [rbp-0x3c],r12d
  4162ee:	7c 1b                	jl     41630b <heap_add+0x18b>
		} else if (h->c(h->data[left], h->data[right])) {
  4162f0:	48 8b 43 18          	mov    rax,QWORD PTR [rbx+0x18]
  4162f4:	49 63 cc             	movsxd rcx,r12d
  4162f7:	48 8b 34 c8          	mov    rsi,QWORD PTR [rax+rcx*8]
  4162fb:	49 63 cf             	movsxd rcx,r15d
  4162fe:	48 8b 3c c8          	mov    rdi,QWORD PTR [rax+rcx*8]
  416302:	ff 53 08             	call   QWORD PTR [rbx+0x8]
  416305:	85 c0                	test   eax,eax
  416307:	45 0f 44 fc          	cmove  r15d,r12d
		assert(n < h->e);
  41630b:	44 39 3b             	cmp    DWORD PTR [rbx],r15d
  41630e:	0f 8f 64 ff ff ff    	jg     416278 <heap_add+0xf8>
  416314:	be 23 00 00 00       	mov    esi,0x23
  416319:	bf 80 fa 41 00       	mov    edi,0x41fa80
  41631e:	e8 5d 49 ff ff       	call   40ac80 <cos_print_str>
  416323:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41632a:	00 00 00 00 
  41632e:	0f 0b                	ud2    
	assert(c <= h->e);
  416330:	8b 03                	mov    eax,DWORD PTR [rbx]
  416332:	41 bd 01 00 00 00    	mov    r13d,0x1
  416338:	e9 16 ff ff ff       	jmp    416253 <heap_add+0xd3>
	heapify(h, c);
	assert(!heap_verify(h));

	return 0;
  41633d:	31 c0                	xor    eax,eax
}
  41633f:	48 83 c4 18          	add    rsp,0x18
  416343:	5b                   	pop    rbx
  416344:	41 5c                	pop    r12
  416346:	41 5d                	pop    r13
  416348:	41 5e                	pop    r14
  41634a:	41 5f                	pop    r15
  41634c:	5d                   	pop    rbp
  41634d:	c3                   	ret    
  41634e:	be 23 00 00 00       	mov    esi,0x23
  416353:	bf 08 fa 41 00       	mov    edi,0x41fa08
  416358:	e8 23 49 ff ff       	call   40ac80 <cos_print_str>
	assert(c <= h->e);
  41635d:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  416364:	00 00 00 00 
  416368:	0f 0b                	ud2    
  41636a:	be 23 00 00 00       	mov    esi,0x23
  41636f:	bf 30 fa 41 00       	mov    edi,0x41fa30
  416374:	e8 07 49 ff ff       	call   40ac80 <cos_print_str>
	assert(c > 0);
  416379:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  416380:	00 00 00 00 
  416384:	0f 0b                	ud2    
  416386:	be 23 00 00 00       	mov    esi,0x23
  41638b:	bf 58 fa 41 00       	mov    edi,0x41fa58
  416390:	e8 eb 48 ff ff       	call   40ac80 <cos_print_str>
	assert(c <= h->e);
  416395:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41639c:	00 00 00 00 
  4163a0:	0f 0b                	ud2    
	if (h->max_sz == h->e) return -1;
  4163a2:	b8 ff ff ff ff       	mov    eax,0xffffffff
  4163a7:	eb 96                	jmp    41633f <heap_add+0x1bf>
  4163a9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

00000000004163b0 <heap_highest>:

void *
heap_highest(struct heap *h)
{
  4163b0:	f3 0f 1e fa          	endbr64 
  4163b4:	55                   	push   rbp
  4163b5:	48 89 e5             	mov    rbp,rsp
  4163b8:	41 57                	push   r15
  4163ba:	41 56                	push   r14
  4163bc:	41 55                	push   r13
  4163be:	41 54                	push   r12
  4163c0:	53                   	push   rbx
  4163c1:	48 83 ec 28          	sub    rsp,0x28
	void *r;

	if (h->e == 1) return NULL;
  4163c5:	8b 07                	mov    eax,DWORD PTR [rdi]
  4163c7:	83 f8 01             	cmp    eax,0x1
  4163ca:	0f 84 2d 01 00 00    	je     4164fd <heap_highest+0x14d>

	assert(!heap_verify(h));
	r = h->data[1];
  4163d0:	48 8b 57 18          	mov    rdx,QWORD PTR [rdi+0x18]
	debug("heap_highest(%p,%d) %p\n", h, h->e, r);

	h->e--;
  4163d4:	83 e8 01             	sub    eax,0x1
  4163d7:	49 89 ff             	mov    r15,rdi
	h->data[1] = h->data[h->e];
	h->u(h->data[1], 1);
  4163da:	be 01 00 00 00       	mov    esi,0x1
	r = h->data[1];
  4163df:	48 8b 4a 08          	mov    rcx,QWORD PTR [rdx+0x8]
	h->e--;
  4163e3:	89 07                	mov    DWORD PTR [rdi],eax
	h->data[1] = h->data[h->e];
  4163e5:	48 98                	cdqe   
  4163e7:	48 8b 04 c2          	mov    rax,QWORD PTR [rdx+rax*8]
	r = h->data[1];
  4163eb:	48 89 4d b8          	mov    QWORD PTR [rbp-0x48],rcx
	h->data[1] = h->data[h->e];
  4163ef:	48 89 42 08          	mov    QWORD PTR [rdx+0x8],rax
	h->u(h->data[1], 1);
  4163f3:	48 8b 47 18          	mov    rax,QWORD PTR [rdi+0x18]
  4163f7:	48 8b 78 08          	mov    rdi,QWORD PTR [rax+0x8]
  4163fb:	41 ff 57 10          	call   QWORD PTR [r15+0x10]
	assert(c <= h->e);
  4163ff:	45 8b 2f             	mov    r13d,DWORD PTR [r15]
  416402:	45 85 ed             	test   r13d,r13d
  416405:	0f 8e fc 00 00 00    	jle    416507 <heap_highest+0x157>
	l = h->e - 1;
  41640b:	41 8d 45 ff          	lea    eax,[r13-0x1]
  41640f:	89 45 c4             	mov    DWORD PTR [rbp-0x3c],eax
	while (c <= l / 2) { /* not a leaf? */
  416412:	d1 f8                	sar    eax,1
  416414:	89 45 c0             	mov    DWORD PTR [rbp-0x40],eax
  416417:	0f 84 c3 00 00 00    	je     4164e0 <heap_highest+0x130>
  41641d:	41 bc 01 00 00 00    	mov    r12d,0x1
  416423:	eb 6d                	jmp    416492 <heap_highest+0xe2>
  416425:	0f 1f 00             	nop    DWORD PTR [rax]
		if (h->c(h->data[c], h->data[n])) break; /* done? */
  416428:	49 8b 47 18          	mov    rax,QWORD PTR [r15+0x18]
  41642c:	49 63 fd             	movsxd rdi,r13d
  41642f:	49 63 f4             	movsxd rsi,r12d
  416432:	48 8d 1c fd 00 00 00 	lea    rbx,[rdi*8+0x0]
  416439:	00 
  41643a:	4c 8d 34 f5 00 00 00 	lea    r14,[rsi*8+0x0]
  416441:	00 
  416442:	4c 8b 04 f8          	mov    r8,QWORD PTR [rax+rdi*8]
  416446:	48 8b 3c f0          	mov    rdi,QWORD PTR [rax+rsi*8]
  41644a:	4c 89 c6             	mov    rsi,r8
  41644d:	41 ff 57 08          	call   QWORD PTR [r15+0x8]
  416451:	85 c0                	test   eax,eax
  416453:	0f 85 87 00 00 00    	jne    4164e0 <heap_highest+0x130>
	t      = arr[a];
  416459:	49 03 5f 18          	add    rbx,QWORD PTR [r15+0x18]
	arr[a] = arr[b];
  41645d:	4d 03 77 18          	add    r14,QWORD PTR [r15+0x18]
		swap_entries(h->data, n, c, h->u);
  416461:	49 8b 47 10          	mov    rax,QWORD PTR [r15+0x10]
	t      = arr[a];
  416465:	48 8b 33             	mov    rsi,QWORD PTR [rbx]
	arr[a] = arr[b];
  416468:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
	u(arr[a], a);
  41646b:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
	arr[a] = arr[b];
  41646f:	48 89 3b             	mov    QWORD PTR [rbx],rdi
	arr[b] = t;
  416472:	49 89 36             	mov    QWORD PTR [r14],rsi
	u(arr[a], a);
  416475:	44 89 ee             	mov    esi,r13d
  416478:	48 8b 3b             	mov    rdi,QWORD PTR [rbx]
  41647b:	ff d0                	call   rax
	u(arr[b], b);
  41647d:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  416480:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  416484:	44 89 e6             	mov    esi,r12d
  416487:	ff d0                	call   rax
	while (c <= l / 2) { /* not a leaf? */
  416489:	44 3b 6d c0          	cmp    r13d,DWORD PTR [rbp-0x40]
  41648d:	7f 51                	jg     4164e0 <heap_highest+0x130>
  41648f:	45 89 ec             	mov    r12d,r13d
		left  = 2 * c;
  416492:	47 8d 2c 24          	lea    r13d,[r12+r12*1]
		right = 2 * c + 1;
  416496:	41 8d 5d 01          	lea    ebx,[r13+0x1]
		if (right > l) {
  41649a:	39 5d c4             	cmp    DWORD PTR [rbp-0x3c],ebx
  41649d:	7c 1c                	jl     4164bb <heap_highest+0x10b>
		} else if (h->c(h->data[left], h->data[right])) {
  41649f:	49 8b 47 18          	mov    rax,QWORD PTR [r15+0x18]
  4164a3:	49 63 fd             	movsxd rdi,r13d
  4164a6:	48 63 f3             	movsxd rsi,ebx
  4164a9:	48 8b 34 f0          	mov    rsi,QWORD PTR [rax+rsi*8]
  4164ad:	48 8b 3c f8          	mov    rdi,QWORD PTR [rax+rdi*8]
  4164b1:	41 ff 57 08          	call   QWORD PTR [r15+0x8]
  4164b5:	85 c0                	test   eax,eax
  4164b7:	44 0f 44 eb          	cmove  r13d,ebx
		assert(n < h->e);
  4164bb:	45 39 2f             	cmp    DWORD PTR [r15],r13d
  4164be:	0f 8f 64 ff ff ff    	jg     416428 <heap_highest+0x78>
  4164c4:	be 23 00 00 00       	mov    esi,0x23
  4164c9:	bf 80 fa 41 00       	mov    edi,0x41fa80
  4164ce:	e8 ad 47 ff ff       	call   40ac80 <cos_print_str>
  4164d3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4164da:	00 00 00 00 
  4164de:	0f 0b                	ud2    
	swap_down(h, 1);
	assert(!heap_verify(h));
	h->u(r, 0);
  4164e0:	48 8b 7d b8          	mov    rdi,QWORD PTR [rbp-0x48]
  4164e4:	31 f6                	xor    esi,esi
  4164e6:	41 ff 57 10          	call   QWORD PTR [r15+0x10]

	return r;
}
  4164ea:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  4164ee:	48 83 c4 28          	add    rsp,0x28
  4164f2:	5b                   	pop    rbx
  4164f3:	41 5c                	pop    r12
  4164f5:	41 5d                	pop    r13
  4164f7:	41 5e                	pop    r14
  4164f9:	41 5f                	pop    r15
  4164fb:	5d                   	pop    rbp
  4164fc:	c3                   	ret    
	if (h->e == 1) return NULL;
  4164fd:	48 c7 45 b8 00 00 00 	mov    QWORD PTR [rbp-0x48],0x0
  416504:	00 
  416505:	eb e3                	jmp    4164ea <heap_highest+0x13a>
  416507:	be 23 00 00 00       	mov    esi,0x23
  41650c:	bf 58 fa 41 00       	mov    edi,0x41fa58
  416511:	e8 6a 47 ff ff       	call   40ac80 <cos_print_str>
	assert(c <= h->e);
  416516:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41651d:	00 00 00 00 
  416521:	0f 0b                	ud2    
  416523:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  41652a:	00 00 00 00 
  41652e:	66 90                	xchg   ax,ax

0000000000416530 <heap_peek>:

void *
heap_peek(struct heap *h)
{
  416530:	f3 0f 1e fa          	endbr64 
	if (h->e == 1) return NULL;
  416534:	83 3f 01             	cmp    DWORD PTR [rdi],0x1
  416537:	74 0f                	je     416548 <heap_peek+0x18>
	assert(!heap_verify(h));
	return h->data[1];
  416539:	48 8b 47 18          	mov    rax,QWORD PTR [rdi+0x18]
  41653d:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  416541:	c3                   	ret    
  416542:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	if (h->e == 1) return NULL;
  416548:	31 c0                	xor    eax,eax
}
  41654a:	c3                   	ret    
  41654b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000416550 <heap_adjust>:

void
heap_adjust(struct heap *h, int c)
{
  416550:	f3 0f 1e fa          	endbr64 
  416554:	55                   	push   rbp
  416555:	48 89 e5             	mov    rbp,rsp
  416558:	41 57                	push   r15
  41655a:	41 56                	push   r14
  41655c:	41 55                	push   r13
  41655e:	41 54                	push   r12
  416560:	53                   	push   rbx
  416561:	48 83 ec 18          	sub    rsp,0x18
	assert(c < h->e);
  416565:	8b 07                	mov    eax,DWORD PTR [rdi]
  416567:	39 f0                	cmp    eax,esi
  416569:	0f 8e 8d 01 00 00    	jle    4166fc <heap_adjust+0x1ac>
  41656f:	41 89 f6             	mov    r14d,esi
	assert(c > 0);
  416572:	85 f6                	test   esi,esi
  416574:	0f 8e 9e 01 00 00    	jle    416718 <heap_adjust+0x1c8>
  41657a:	48 89 fb             	mov    rbx,rdi
	while (c > 1) {
  41657d:	83 fe 01             	cmp    esi,0x1
  416580:	75 49                	jne    4165cb <heap_adjust+0x7b>
  416582:	e9 5b 01 00 00       	jmp    4166e2 <heap_adjust+0x192>
  416587:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41658e:	00 00 
	arr[a] = arr[b];
  416590:	4c 03 63 18          	add    r12,QWORD PTR [rbx+0x18]
	t      = arr[a];
  416594:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
	u(arr[a], a);
  416598:	44 89 f6             	mov    esi,r14d
	t      = arr[a];
  41659b:	48 03 43 18          	add    rax,QWORD PTR [rbx+0x18]
	arr[a] = arr[b];
  41659f:	49 8b 0c 24          	mov    rcx,QWORD PTR [r12]
	t      = arr[a];
  4165a3:	48 8b 10             	mov    rdx,QWORD PTR [rax]
		swap_entries(h->data, p, c, h->u);
  4165a6:	4c 8b 7b 10          	mov    r15,QWORD PTR [rbx+0x10]
	arr[a] = arr[b];
  4165aa:	48 89 08             	mov    QWORD PTR [rax],rcx
	arr[b] = t;
  4165ad:	49 89 14 24          	mov    QWORD PTR [r12],rdx
	u(arr[a], a);
  4165b1:	48 8b 38             	mov    rdi,QWORD PTR [rax]
  4165b4:	41 ff d7             	call   r15
	u(arr[b], b);
  4165b7:	49 8b 3c 24          	mov    rdi,QWORD PTR [r12]
  4165bb:	44 89 ee             	mov    esi,r13d
  4165be:	41 ff d7             	call   r15
	while (c > 1) {
  4165c1:	41 83 fe 01          	cmp    r14d,0x1
  4165c5:	0f 84 15 01 00 00    	je     4166e0 <heap_adjust+0x190>
		p = c / 2;
  4165cb:	49 63 ce             	movsxd rcx,r14d
		if (h->c(h->data[p], h->data[c])) break; /* done? */
  4165ce:	48 8b 43 18          	mov    rax,QWORD PTR [rbx+0x18]
		p = c / 2;
  4165d2:	41 89 ce             	mov    r14d,ecx
  4165d5:	49 89 cd             	mov    r13,rcx
		if (h->c(h->data[p], h->data[c])) break; /* done? */
  4165d8:	4c 8d 24 cd 00 00 00 	lea    r12,[rcx*8+0x0]
  4165df:	00 
		p = c / 2;
  4165e0:	41 d1 fe             	sar    r14d,1
		if (h->c(h->data[p], h->data[c])) break; /* done? */
  4165e3:	48 8b 34 c8          	mov    rsi,QWORD PTR [rax+rcx*8]
  4165e7:	49 63 d6             	movsxd rdx,r14d
  4165ea:	48 8d 3c d5 00 00 00 	lea    rdi,[rdx*8+0x0]
  4165f1:	00 
  4165f2:	48 89 7d c8          	mov    QWORD PTR [rbp-0x38],rdi
  4165f6:	48 8b 3c d0          	mov    rdi,QWORD PTR [rax+rdx*8]
  4165fa:	ff 53 08             	call   QWORD PTR [rbx+0x8]
  4165fd:	85 c0                	test   eax,eax
  4165ff:	74 8f                	je     416590 <heap_adjust+0x40>
	assert(c <= h->e);
  416601:	8b 03                	mov    eax,DWORD PTR [rbx]
  416603:	44 39 e8             	cmp    eax,r13d
  416606:	0f 8c 28 01 00 00    	jl     416734 <heap_adjust+0x1e4>
	l = h->e - 1;
  41660c:	83 e8 01             	sub    eax,0x1
  41660f:	89 45 c4             	mov    DWORD PTR [rbp-0x3c],eax
	while (c <= l / 2) { /* not a leaf? */
  416612:	d1 f8                	sar    eax,1
  416614:	89 45 c0             	mov    DWORD PTR [rbp-0x40],eax
  416617:	44 39 e8             	cmp    eax,r13d
  41661a:	7d 75                	jge    416691 <heap_adjust+0x141>
  41661c:	e9 cc 00 00 00       	jmp    4166ed <heap_adjust+0x19d>
  416621:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		if (h->c(h->data[c], h->data[n])) break; /* done? */
  416628:	48 8b 43 18          	mov    rax,QWORD PTR [rbx+0x18]
  41662c:	49 63 f7             	movsxd rsi,r15d
  41662f:	49 63 cd             	movsxd rcx,r13d
  416632:	4c 8d 24 f5 00 00 00 	lea    r12,[rsi*8+0x0]
  416639:	00 
  41663a:	4c 8d 34 cd 00 00 00 	lea    r14,[rcx*8+0x0]
  416641:	00 
  416642:	48 8b 34 f0          	mov    rsi,QWORD PTR [rax+rsi*8]
  416646:	48 8b 3c c8          	mov    rdi,QWORD PTR [rax+rcx*8]
  41664a:	ff 53 08             	call   QWORD PTR [rbx+0x8]
  41664d:	85 c0                	test   eax,eax
  41664f:	0f 85 98 00 00 00    	jne    4166ed <heap_adjust+0x19d>
	t      = arr[a];
  416655:	4c 03 63 18          	add    r12,QWORD PTR [rbx+0x18]
	arr[a] = arr[b];
  416659:	4c 03 73 18          	add    r14,QWORD PTR [rbx+0x18]
		swap_entries(h->data, n, c, h->u);
  41665d:	48 8b 43 10          	mov    rax,QWORD PTR [rbx+0x10]
	arr[a] = arr[b];
  416661:	49 8b 36             	mov    rsi,QWORD PTR [r14]
	t      = arr[a];
  416664:	49 8b 0c 24          	mov    rcx,QWORD PTR [r12]
	u(arr[a], a);
  416668:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
	arr[a] = arr[b];
  41666c:	49 89 34 24          	mov    QWORD PTR [r12],rsi
	u(arr[a], a);
  416670:	44 89 fe             	mov    esi,r15d
	arr[b] = t;
  416673:	49 89 0e             	mov    QWORD PTR [r14],rcx
	u(arr[a], a);
  416676:	49 8b 3c 24          	mov    rdi,QWORD PTR [r12]
  41667a:	ff d0                	call   rax
	u(arr[b], b);
  41667c:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  41667f:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  416683:	44 89 ee             	mov    esi,r13d
  416686:	ff d0                	call   rax
	while (c <= l / 2) { /* not a leaf? */
  416688:	44 39 7d c0          	cmp    DWORD PTR [rbp-0x40],r15d
  41668c:	7c 5f                	jl     4166ed <heap_adjust+0x19d>
  41668e:	45 89 fd             	mov    r13d,r15d
		left  = 2 * c;
  416691:	47 8d 7c 2d 00       	lea    r15d,[r13+r13*1+0x0]
		right = 2 * c + 1;
  416696:	45 8d 67 01          	lea    r12d,[r15+0x1]
		if (right > l) {
  41669a:	44 39 65 c4          	cmp    DWORD PTR [rbp-0x3c],r12d
  41669e:	7c 1b                	jl     4166bb <heap_adjust+0x16b>
		} else if (h->c(h->data[left], h->data[right])) {
  4166a0:	48 8b 43 18          	mov    rax,QWORD PTR [rbx+0x18]
  4166a4:	49 63 cc             	movsxd rcx,r12d
  4166a7:	48 8b 34 c8          	mov    rsi,QWORD PTR [rax+rcx*8]
  4166ab:	49 63 cf             	movsxd rcx,r15d
  4166ae:	48 8b 3c c8          	mov    rdi,QWORD PTR [rax+rcx*8]
  4166b2:	ff 53 08             	call   QWORD PTR [rbx+0x8]
  4166b5:	85 c0                	test   eax,eax
  4166b7:	45 0f 44 fc          	cmove  r15d,r12d
		assert(n < h->e);
  4166bb:	44 39 3b             	cmp    DWORD PTR [rbx],r15d
  4166be:	0f 8f 64 ff ff ff    	jg     416628 <heap_adjust+0xd8>
  4166c4:	be 23 00 00 00       	mov    esi,0x23
  4166c9:	bf 80 fa 41 00       	mov    edi,0x41fa80
  4166ce:	e8 ad 45 ff ff       	call   40ac80 <cos_print_str>
  4166d3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4166da:	00 00 00 00 
  4166de:	0f 0b                	ud2    
	assert(c <= h->e);
  4166e0:	8b 03                	mov    eax,DWORD PTR [rbx]
  4166e2:	41 bd 01 00 00 00    	mov    r13d,0x1
  4166e8:	e9 16 ff ff ff       	jmp    416603 <heap_adjust+0xb3>

	debug("heap_adjust(%p,%d) %p@%d\n", h, h->e, h->data[c], c);
	heapify(h, c);
	assert(!heap_verify(h));
}
  4166ed:	48 83 c4 18          	add    rsp,0x18
  4166f1:	5b                   	pop    rbx
  4166f2:	41 5c                	pop    r12
  4166f4:	41 5d                	pop    r13
  4166f6:	41 5e                	pop    r14
  4166f8:	41 5f                	pop    r15
  4166fa:	5d                   	pop    rbp
  4166fb:	c3                   	ret    
  4166fc:	be 24 00 00 00       	mov    esi,0x24
  416701:	bf a8 fa 41 00       	mov    edi,0x41faa8
  416706:	e8 75 45 ff ff       	call   40ac80 <cos_print_str>
	assert(c < h->e);
  41670b:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  416712:	00 00 00 00 
  416716:	0f 0b                	ud2    
  416718:	be 24 00 00 00       	mov    esi,0x24
  41671d:	bf d0 fa 41 00       	mov    edi,0x41fad0
  416722:	e8 59 45 ff ff       	call   40ac80 <cos_print_str>
	assert(c > 0);
  416727:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41672e:	00 00 00 00 
  416732:	0f 0b                	ud2    
  416734:	be 23 00 00 00       	mov    esi,0x23
  416739:	bf 58 fa 41 00       	mov    edi,0x41fa58
  41673e:	e8 3d 45 ff ff       	call   40ac80 <cos_print_str>
	assert(c <= h->e);
  416743:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  41674a:	00 00 00 00 
  41674e:	0f 0b                	ud2    

0000000000416750 <heap_remove>:

void *
heap_remove(struct heap *h, int c)
{
  416750:	f3 0f 1e fa          	endbr64 
  416754:	55                   	push   rbp
  416755:	48 89 e5             	mov    rbp,rsp
  416758:	41 56                	push   r14
  41675a:	41 55                	push   r13
  41675c:	41 54                	push   r12
  41675e:	53                   	push   rbx
	void *r;

	assert(c < h->e);
  41675f:	8b 07                	mov    eax,DWORD PTR [rdi]
  416761:	39 f0                	cmp    eax,esi
  416763:	7e 6f                	jle    4167d4 <heap_remove+0x84>
  416765:	41 89 f5             	mov    r13d,esi
	assert(c >= 1);
  416768:	85 f6                	test   esi,esi
  41676a:	0f 8e 80 00 00 00    	jle    4167f0 <heap_remove+0xa0>
	if (h->e == 1) return NULL;
  416770:	83 f8 01             	cmp    eax,0x1
  416773:	0f 84 93 00 00 00    	je     41680c <heap_remove+0xbc>

	assert(!heap_verify(h));
	r = h->data[c];
  416779:	48 8b 57 18          	mov    rdx,QWORD PTR [rdi+0x18]
  41677d:	48 63 de             	movsxd rbx,esi
  416780:	49 89 fc             	mov    r12,rdi
	debug("heap_remove(%p,%d) %p@%d\n", h, h->e, h->data[c], c);
	h->e--;
  416783:	83 e8 01             	sub    eax,0x1
	h->u(r, 0);
  416786:	31 f6                	xor    esi,esi
	r = h->data[c];
  416788:	4c 8b 34 da          	mov    r14,QWORD PTR [rdx+rbx*8]
	h->e--;
  41678c:	89 07                	mov    DWORD PTR [rdi],eax
	h->u(r, 0);
  41678e:	4c 89 f7             	mov    rdi,r14
  416791:	41 ff 54 24 10       	call   QWORD PTR [r12+0x10]

	if (c == h->e) {
  416796:	49 63 04 24          	movsxd rax,DWORD PTR [r12]
  41679a:	44 39 e8             	cmp    eax,r13d
  41679d:	74 29                	je     4167c8 <heap_remove+0x78>
		assert(!heap_verify(h));
		return r;
	}
	h->data[c] = h->data[h->e];
  41679f:	49 8b 54 24 18       	mov    rdx,QWORD PTR [r12+0x18]
	h->u(h->data[c], c);
  4167a4:	44 89 ee             	mov    esi,r13d
	h->data[c] = h->data[h->e];
  4167a7:	48 8b 04 c2          	mov    rax,QWORD PTR [rdx+rax*8]
  4167ab:	48 89 04 da          	mov    QWORD PTR [rdx+rbx*8],rax
	h->u(h->data[c], c);
  4167af:	49 8b 44 24 18       	mov    rax,QWORD PTR [r12+0x18]
  4167b4:	48 8b 3c d8          	mov    rdi,QWORD PTR [rax+rbx*8]
  4167b8:	41 ff 54 24 10       	call   QWORD PTR [r12+0x10]
	heap_adjust(h, c);
  4167bd:	44 89 ee             	mov    esi,r13d
  4167c0:	4c 89 e7             	mov    rdi,r12
  4167c3:	e8 88 fd ff ff       	call   416550 <heap_adjust>
	assert(!heap_verify(h));

	return r;
}
  4167c8:	5b                   	pop    rbx
  4167c9:	4c 89 f0             	mov    rax,r14
  4167cc:	41 5c                	pop    r12
  4167ce:	41 5d                	pop    r13
  4167d0:	41 5e                	pop    r14
  4167d2:	5d                   	pop    rbp
  4167d3:	c3                   	ret    
  4167d4:	be 24 00 00 00       	mov    esi,0x24
  4167d9:	bf f8 fa 41 00       	mov    edi,0x41faf8
  4167de:	e8 9d 44 ff ff       	call   40ac80 <cos_print_str>
	assert(c < h->e);
  4167e3:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  4167ea:	00 00 00 00 
  4167ee:	0f 0b                	ud2    
  4167f0:	be 24 00 00 00       	mov    esi,0x24
  4167f5:	bf 20 fb 41 00       	mov    edi,0x41fb20
  4167fa:	e8 81 44 ff ff       	call   40ac80 <cos_print_str>
	assert(c >= 1);
  4167ff:	c7 04 25 00 00 00 00 	mov    DWORD PTR ds:0x0,0x0
  416806:	00 00 00 00 
  41680a:	0f 0b                	ud2    
	if (h->e == 1) return NULL;
  41680c:	45 31 f6             	xor    r14d,r14d
  41680f:	eb b7                	jmp    4167c8 <heap_remove+0x78>
  416811:	66 66 2e 0f 1f 84 00 	data16 cs nop WORD PTR [rax+rax*1+0x0]
  416818:	00 00 00 00 
  41681c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000416820 <heap_size>:

int
heap_size(struct heap *h)
{
  416820:	f3 0f 1e fa          	endbr64 
	return h->e - 1;
  416824:	8b 07                	mov    eax,DWORD PTR [rdi]
  416826:	83 e8 01             	sub    eax,0x1
}
  416829:	c3                   	ret    

000000000041682a <memcpy>:
.global __memcpy_fwd
.hidden __memcpy_fwd
.type memcpy,@function
memcpy:
__memcpy_fwd:
	mov %rdi,%rax
  41682a:	48 89 f8             	mov    rax,rdi
	cmp $8,%rdx
  41682d:	48 83 fa 08          	cmp    rdx,0x8
	jc 1f
  416831:	72 14                	jb     416847 <memcpy+0x1d>
	test $7,%edi
  416833:	f7 c7 07 00 00 00    	test   edi,0x7
	jz 1f
  416839:	74 0c                	je     416847 <memcpy+0x1d>
2:	movsb
  41683b:	a4                   	movs   BYTE PTR es:[rdi],BYTE PTR ds:[rsi]
	dec %rdx
  41683c:	48 ff ca             	dec    rdx
	test $7,%edi
  41683f:	f7 c7 07 00 00 00    	test   edi,0x7
	jnz 2b
  416845:	75 f4                	jne    41683b <memcpy+0x11>
1:	mov %rdx,%rcx
  416847:	48 89 d1             	mov    rcx,rdx
	shr $3,%rcx
  41684a:	48 c1 e9 03          	shr    rcx,0x3
	rep
  41684e:	f3 48 a5             	rep movs QWORD PTR es:[rdi],QWORD PTR ds:[rsi]
	movsq
	and $7,%edx
  416851:	83 e2 07             	and    edx,0x7
	jz 1f
  416854:	74 05                	je     41685b <memcpy+0x31>
2:	movsb
  416856:	a4                   	movs   BYTE PTR es:[rdi],BYTE PTR ds:[rsi]
	dec %edx
  416857:	ff ca                	dec    edx
	jnz 2b
  416859:	75 fb                	jne    416856 <memcpy+0x2c>
1:	ret
  41685b:	c3                   	ret    

000000000041685c <memset>:
.global memset
.type memset,@function
memset:
	movzbq %sil,%rax
  41685c:	48 0f b6 c6          	movzx  rax,sil
	mov $0x101010101010101,%r8
  416860:	49 b8 01 01 01 01 01 	movabs r8,0x101010101010101
  416867:	01 01 01 
	imul %r8,%rax
  41686a:	49 0f af c0          	imul   rax,r8

	cmp $126,%rdx
  41686e:	48 83 fa 7e          	cmp    rdx,0x7e
	ja 2f
  416872:	77 78                	ja     4168ec <memset+0x90>

	test %edx,%edx
  416874:	85 d2                	test   edx,edx
	jz 1f
  416876:	74 70                	je     4168e8 <memset+0x8c>

	mov %sil,(%rdi)
  416878:	40 88 37             	mov    BYTE PTR [rdi],sil
	mov %sil,-1(%rdi,%rdx)
  41687b:	40 88 74 17 ff       	mov    BYTE PTR [rdi+rdx*1-0x1],sil
	cmp $2,%edx
  416880:	83 fa 02             	cmp    edx,0x2
	jbe 1f
  416883:	76 63                	jbe    4168e8 <memset+0x8c>

	mov %ax,1(%rdi)
  416885:	66 89 47 01          	mov    WORD PTR [rdi+0x1],ax
	mov %ax,(-1-2)(%rdi,%rdx)
  416889:	66 89 44 17 fd       	mov    WORD PTR [rdi+rdx*1-0x3],ax
	cmp $6,%edx
  41688e:	83 fa 06             	cmp    edx,0x6
	jbe 1f
  416891:	76 55                	jbe    4168e8 <memset+0x8c>

	mov %eax,(1+2)(%rdi)
  416893:	89 47 03             	mov    DWORD PTR [rdi+0x3],eax
	mov %eax,(-1-2-4)(%rdi,%rdx)
  416896:	89 44 17 f9          	mov    DWORD PTR [rdi+rdx*1-0x7],eax
	cmp $14,%edx
  41689a:	83 fa 0e             	cmp    edx,0xe
	jbe 1f
  41689d:	76 49                	jbe    4168e8 <memset+0x8c>

	mov %rax,(1+2+4)(%rdi)
  41689f:	48 89 47 07          	mov    QWORD PTR [rdi+0x7],rax
	mov %rax,(-1-2-4-8)(%rdi,%rdx)
  4168a3:	48 89 44 17 f1       	mov    QWORD PTR [rdi+rdx*1-0xf],rax
	cmp $30,%edx
  4168a8:	83 fa 1e             	cmp    edx,0x1e
	jbe 1f
  4168ab:	76 3b                	jbe    4168e8 <memset+0x8c>

	mov %rax,(1+2+4+8)(%rdi)
  4168ad:	48 89 47 0f          	mov    QWORD PTR [rdi+0xf],rax
	mov %rax,(1+2+4+8+8)(%rdi)
  4168b1:	48 89 47 17          	mov    QWORD PTR [rdi+0x17],rax
	mov %rax,(-1-2-4-8-16)(%rdi,%rdx)
  4168b5:	48 89 44 17 e1       	mov    QWORD PTR [rdi+rdx*1-0x1f],rax
	mov %rax,(-1-2-4-8-8)(%rdi,%rdx)
  4168ba:	48 89 44 17 e9       	mov    QWORD PTR [rdi+rdx*1-0x17],rax
	cmp $62,%edx
  4168bf:	83 fa 3e             	cmp    edx,0x3e
	jbe 1f
  4168c2:	76 24                	jbe    4168e8 <memset+0x8c>

	mov %rax,(1+2+4+8+16)(%rdi)
  4168c4:	48 89 47 1f          	mov    QWORD PTR [rdi+0x1f],rax
	mov %rax,(1+2+4+8+16+8)(%rdi)
  4168c8:	48 89 47 27          	mov    QWORD PTR [rdi+0x27],rax
	mov %rax,(1+2+4+8+16+16)(%rdi)
  4168cc:	48 89 47 2f          	mov    QWORD PTR [rdi+0x2f],rax
	mov %rax,(1+2+4+8+16+24)(%rdi)
  4168d0:	48 89 47 37          	mov    QWORD PTR [rdi+0x37],rax
	mov %rax,(-1-2-4-8-16-32)(%rdi,%rdx)
  4168d4:	48 89 44 17 c1       	mov    QWORD PTR [rdi+rdx*1-0x3f],rax
	mov %rax,(-1-2-4-8-16-24)(%rdi,%rdx)
  4168d9:	48 89 44 17 c9       	mov    QWORD PTR [rdi+rdx*1-0x37],rax
	mov %rax,(-1-2-4-8-16-16)(%rdi,%rdx)
  4168de:	48 89 44 17 d1       	mov    QWORD PTR [rdi+rdx*1-0x2f],rax
	mov %rax,(-1-2-4-8-16-8)(%rdi,%rdx)
  4168e3:	48 89 44 17 d9       	mov    QWORD PTR [rdi+rdx*1-0x27],rax

1:	mov %rdi,%rax
  4168e8:	48 89 f8             	mov    rax,rdi
	ret
  4168eb:	c3                   	ret    

2:	test $15,%edi
  4168ec:	f7 c7 0f 00 00 00    	test   edi,0xf
	mov %rdi,%r8
  4168f2:	49 89 f8             	mov    r8,rdi
	mov %rax,-8(%rdi,%rdx)
  4168f5:	48 89 44 17 f8       	mov    QWORD PTR [rdi+rdx*1-0x8],rax
	mov %rdx,%rcx
  4168fa:	48 89 d1             	mov    rcx,rdx
	jnz 2f
  4168fd:	75 0b                	jne    41690a <memset+0xae>

1:	shr $3,%rcx
  4168ff:	48 c1 e9 03          	shr    rcx,0x3
	rep
  416903:	f3 48 ab             	rep stos QWORD PTR es:[rdi],rax
	stosq
	mov %r8,%rax
  416906:	4c 89 c0             	mov    rax,r8
	ret
  416909:	c3                   	ret    

2:	xor %edx,%edx
  41690a:	31 d2                	xor    edx,edx
	sub %edi,%edx
  41690c:	29 fa                	sub    edx,edi
	and $15,%edx
  41690e:	83 e2 0f             	and    edx,0xf
	mov %rax,(%rdi)
  416911:	48 89 07             	mov    QWORD PTR [rdi],rax
	mov %rax,8(%rdi)
  416914:	48 89 47 08          	mov    QWORD PTR [rdi+0x8],rax
	sub %rdx,%rcx
  416918:	48 29 d1             	sub    rcx,rdx
	add %rdx,%rdi
  41691b:	48 01 d7             	add    rdi,rdx
	jmp 1b
  41691e:	eb df                	jmp    4168ff <memset+0xa3>

0000000000416920 <__set_thread_area>:
.text
.global __set_thread_area
.hidden __set_thread_area
.type __set_thread_area,@function
__set_thread_area:
	mov %rdi,%rsi           /* shift for syscall */
  416920:	48 89 fe             	mov    rsi,rdi
	movl $0x1002,%edi       /* SET_FS register */
  416923:	bf 02 10 00 00       	mov    edi,0x1002
	movl $158,%eax          /* set fs segment to */
  416928:	b8 9e 00 00 00       	mov    eax,0x9e
	syscall                 /* arch_prctl(SET_FS, arg)*/
  41692d:	0f 05                	syscall 
	ret
  41692f:	c3                   	ret    

0000000000416930 <sched_set_tls.cold>:
	thdcap_t thdcap = current->thd;
  416930:	48 8b 04 25 10 00 00 	mov    rax,QWORD PTR ds:0x10
  416937:	00 
  416938:	0f 0b                	ud2    

000000000041693a <sched_debug_thd_state.cold>:
	return t->state;
  41693a:	8b 04 25 04 00 00 00 	mov    eax,DWORD PTR ds:0x4
  416941:	0f 0b                	ud2    
  416943:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41694a:	00 00 00 
  41694d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000416950 <_init>:
#include <unistd.h>
#include "syscall.h"
#include "atomic.h"
#include "libc.h"

static void dummy(void) {}
  416950:	f3 0f 1e fa          	endbr64 
  416954:	c3                   	ret    
  416955:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41695c:	00 00 00 
  41695f:	90                   	nop

0000000000416960 <__funcs_on_exit>:
#include <stdlib.h>
#include <stdint.h>
#include "libc.h"

static void dummy()
{
  416960:	f3 0f 1e fa          	endbr64 
}
  416964:	c3                   	ret    
  416965:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41696c:	00 00 00 
  41696f:	90                   	nop

0000000000416970 <__lctrans_impl>:
#include <locale.h>
#include "locale_impl.h"

static const char *dummy(const char *msg, const struct __locale_map *lm)
{
  416970:	f3 0f 1e fa          	endbr64 
  416974:	48 89 f8             	mov    rax,rdi
	return msg;
}
  416977:	c3                   	ret    
  416978:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41697f:	00 

0000000000416980 <__init_ssp>:
weak_alias(dummy, _init);

extern weak hidden void (*const __init_array_start)(void), (*const __init_array_end)(void);

static void dummy1(void *p) {}
  416980:	f3 0f 1e fa          	endbr64 
  416984:	c3                   	ret    
  416985:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41698c:	00 00 00 
  41698f:	90                   	nop

0000000000416990 <__init_libc>:

#ifdef __GNUC__
__attribute__((__noinline__))
#endif
void __init_libc(char **envp, char *pn)
{
  416990:	f3 0f 1e fa          	endbr64 
  416994:	48 81 ec 58 01 00 00 	sub    rsp,0x158
  41699b:	48 89 fa             	mov    rdx,rdi
	size_t i, *auxv, aux[AUX_CNT] = { 0 };
  41699e:	31 c0                	xor    eax,eax
  4169a0:	b9 26 00 00 00       	mov    ecx,0x26
  4169a5:	4c 8d 44 24 20       	lea    r8,[rsp+0x20]
	__environ = envp;
	for (i=0; envp[i]; i++);
  4169aa:	48 83 3a 00          	cmp    QWORD PTR [rdx],0x0
	size_t i, *auxv, aux[AUX_CNT] = { 0 };
  4169ae:	4c 89 c7             	mov    rdi,r8
  4169b1:	f3 48 ab             	rep stos QWORD PTR es:[rdi],rax
	__environ = envp;
  4169b4:	48 c7 c0 b0 6f 71 00 	mov    rax,0x716fb0
  4169bb:	48 89 10             	mov    QWORD PTR [rax],rdx
	for (i=0; envp[i]; i++);
  4169be:	0f 84 a4 02 00 00    	je     416c68 <__init_libc+0x2d8>
  4169c4:	31 c0                	xor    eax,eax
  4169c6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4169cd:	00 00 00 
  4169d0:	48 89 c1             	mov    rcx,rax
  4169d3:	48 83 c0 01          	add    rax,0x1
  4169d7:	48 83 3c c2 00       	cmp    QWORD PTR [rdx+rax*8],0x0
  4169dc:	75 f2                	jne    4169d0 <__init_libc+0x40>
	libc.auxv = auxv = (void *)(envp+i+1);
  4169de:	48 8d 04 cd 10 00 00 	lea    rax,[rcx*8+0x10]
  4169e5:	00 
  4169e6:	48 01 d0             	add    rax,rdx
	for (i=0; auxv[i]; i+=2) if (auxv[i]<AUX_CNT) aux[auxv[i]] = auxv[i+1];
  4169e9:	48 8b 10             	mov    rdx,QWORD PTR [rax]
	libc.auxv = auxv = (void *)(envp+i+1);
  4169ec:	48 89 05 5d 05 30 00 	mov    QWORD PTR [rip+0x30055d],rax        # 716f50 <__libc+0x10>
	for (i=0; auxv[i]; i+=2) if (auxv[i]<AUX_CNT) aux[auxv[i]] = auxv[i+1];
  4169f3:	48 83 c0 08          	add    rax,0x8
  4169f7:	48 85 d2             	test   rdx,rdx
  4169fa:	0f 84 78 02 00 00    	je     416c78 <__init_libc+0x2e8>
  416a00:	48 83 fa 25          	cmp    rdx,0x25
  416a04:	0f 87 3e 01 00 00    	ja     416b48 <__init_libc+0x1b8>
  416a0a:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  416a0d:	48 83 c0 10          	add    rax,0x10
  416a11:	48 89 4c d4 20       	mov    QWORD PTR [rsp+rdx*8+0x20],rcx
  416a16:	48 8b 50 f8          	mov    rdx,QWORD PTR [rax-0x8]
  416a1a:	48 85 d2             	test   rdx,rdx
  416a1d:	75 e1                	jne    416a00 <__init_libc+0x70>
	__hwcap = aux[AT_HWCAP];
  416a1f:	48 8b 8c 24 a0 00 00 	mov    rcx,QWORD PTR [rsp+0xa0]
  416a26:	00 
	if (aux[AT_SYSINFO]) __sysinfo = aux[AT_SYSINFO];
  416a27:	48 8b 84 24 20 01 00 	mov    rax,QWORD PTR [rsp+0x120]
  416a2e:	00 
	libc.page_size = aux[AT_PAGESZ];
  416a2f:	48 8b 54 24 50       	mov    rdx,QWORD PTR [rsp+0x50]
	__hwcap = aux[AT_HWCAP];
  416a34:	48 89 0d fd 04 30 00 	mov    QWORD PTR [rip+0x3004fd],rcx        # 716f38 <__hwcap>
	if (aux[AT_SYSINFO]) __sysinfo = aux[AT_SYSINFO];
  416a3b:	48 85 c0             	test   rax,rax
  416a3e:	74 07                	je     416a47 <__init_libc+0xb7>
  416a40:	48 89 05 d9 04 30 00 	mov    QWORD PTR [rip+0x3004d9],rax        # 716f20 <__sysinfo>
	libc.page_size = aux[AT_PAGESZ];
  416a47:	48 89 15 2a 05 30 00 	mov    QWORD PTR [rip+0x30052a],rdx        # 716f78 <__libc+0x38>

	if (!pn) pn = (void*)aux[AT_EXECFN];
  416a4e:	48 85 f6             	test   rsi,rsi
  416a51:	0f 84 c9 01 00 00    	je     416c20 <__init_libc+0x290>
	if (!pn) pn = "";
	__progname = __progname_full = pn;
  416a57:	48 c7 c0 28 6f 71 00 	mov    rax,0x716f28
  416a5e:	48 c7 c1 30 6f 71 00 	mov    rcx,0x716f30
  416a65:	48 89 30             	mov    QWORD PTR [rax],rsi
  416a68:	48 89 31             	mov    QWORD PTR [rcx],rsi
	for (i=0; pn[i]; i++) if (pn[i]=='/') __progname = pn+i+1;
  416a6b:	0f b6 16             	movzx  edx,BYTE PTR [rsi]
  416a6e:	84 d2                	test   dl,dl
  416a70:	74 22                	je     416a94 <__init_libc+0x104>
  416a72:	48 8d 46 01          	lea    rax,[rsi+0x1]
  416a76:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  416a7d:	00 00 00 
  416a80:	80 fa 2f             	cmp    dl,0x2f
  416a83:	0f 84 d7 00 00 00    	je     416b60 <__init_libc+0x1d0>
  416a89:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  416a8c:	48 83 c0 01          	add    rax,0x1
  416a90:	84 d2                	test   dl,dl
  416a92:	75 ec                	jne    416a80 <__init_libc+0xf0>

	__init_tls(aux);
  416a94:	4c 89 c7             	mov    rdi,r8
  416a97:	e8 34 0a 00 00       	call   4174d0 <__init_tls>
	__init_ssp((void *)aux[AT_RANDOM]);
  416a9c:	48 8b bc 24 e8 00 00 	mov    rdi,QWORD PTR [rsp+0xe8]
  416aa3:	00 
  416aa4:	e8 d7 fe ff ff       	call   416980 <__init_ssp>

	if (aux[AT_UID]==aux[AT_EUID] && aux[AT_GID]==aux[AT_EGID]
  416aa9:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  416ab0:	00 
  416ab1:	48 39 44 24 78       	cmp    QWORD PTR [rsp+0x78],rax
  416ab6:	75 16                	jne    416ace <__init_libc+0x13e>
  416ab8:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  416abf:	00 
  416ac0:	48 39 84 24 88 00 00 	cmp    QWORD PTR [rsp+0x88],rax
  416ac7:	00 
  416ac8:	0f 84 82 01 00 00    	je     416c50 <__init_libc+0x2c0>
		&& !aux[AT_SECURE]) return;

	struct pollfd pfd[3] = { {.fd=0}, {.fd=1}, {.fd=2} };
  416ace:	66 0f ef c0          	pxor   xmm0,xmm0
	int r =
#ifdef SYS_poll
	__syscall(SYS_poll, pfd, 3, 0);
  416ad2:	48 89 e6             	mov    rsi,rsp
	return __cos_syscall(n, a1, a2, 0, 0, 0, 0, 0);
}

static __inline long __syscall3(long n, long a1, long a2, long a3)
{
	return __cos_syscall(n, a1, a2, a3, 0, 0, 0, 0);
  416ad5:	45 31 c9             	xor    r9d,r9d
  416ad8:	45 31 c0             	xor    r8d,r8d
	struct pollfd pfd[3] = { {.fd=0}, {.fd=1}, {.fd=2} };
  416adb:	0f 29 04 24          	movaps XMMWORD PTR [rsp],xmm0
  416adf:	31 c9                	xor    ecx,ecx
  416ae1:	ba 03 00 00 00       	mov    edx,0x3
  416ae6:	bf 07 00 00 00       	mov    edi,0x7
  416aeb:	48 c7 44 24 10 00 00 	mov    QWORD PTR [rsp+0x10],0x0
  416af2:	00 00 
  416af4:	c7 44 24 08 01 00 00 	mov    DWORD PTR [rsp+0x8],0x1
  416afb:	00 
  416afc:	c7 44 24 10 02 00 00 	mov    DWORD PTR [rsp+0x10],0x2
  416b03:	00 
  416b04:	6a 00                	push   0x0
  416b06:	6a 00                	push   0x0
  416b08:	e8 83 43 ff ff       	call   40ae90 <__cos_syscall>
#else
	__syscall(SYS_ppoll, pfd, 3, &(struct timespec){0}, 0, _NSIG/8);
#endif
	if (r<0) a_crash();
  416b0d:	41 5a                	pop    r10
  416b0f:	41 5b                	pop    r11
  416b11:	85 c0                	test   eax,eax
  416b13:	79 01                	jns    416b16 <__init_libc+0x186>
}

#define a_crash a_crash
static inline void a_crash()
{
	__asm__ __volatile__( "hlt" : : : "memory" );
  416b15:	f4                   	hlt    
	for (i=0; i<3; i++) if (pfd[i].revents&POLLNVAL)
  416b16:	f6 44 24 06 20       	test   BYTE PTR [rsp+0x6],0x20
  416b1b:	0f 85 c7 00 00 00    	jne    416be8 <__init_libc+0x258>
  416b21:	f6 44 24 0e 20       	test   BYTE PTR [rsp+0xe],0x20
  416b26:	0f 85 84 00 00 00    	jne    416bb0 <__init_libc+0x220>
  416b2c:	f6 44 24 16 20       	test   BYTE PTR [rsp+0x16],0x20
  416b31:	75 4d                	jne    416b80 <__init_libc+0x1f0>
		if (__sys_open("/dev/null", O_RDWR)<0)
			a_crash();
	libc.secure = 1;
  416b33:	c7 05 0b 04 30 00 01 	mov    DWORD PTR [rip+0x30040b],0x1        # 716f48 <__libc+0x8>
  416b3a:	00 00 00 
}
  416b3d:	48 81 c4 58 01 00 00 	add    rsp,0x158
  416b44:	c3                   	ret    
  416b45:	0f 1f 00             	nop    DWORD PTR [rax]
	for (i=0; auxv[i]; i+=2) if (auxv[i]<AUX_CNT) aux[auxv[i]] = auxv[i+1];
  416b48:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  416b4c:	48 83 c0 10          	add    rax,0x10
  416b50:	48 85 d2             	test   rdx,rdx
  416b53:	0f 85 a7 fe ff ff    	jne    416a00 <__init_libc+0x70>
  416b59:	e9 c1 fe ff ff       	jmp    416a1f <__init_libc+0x8f>
  416b5e:	66 90                	xchg   ax,ax
	for (i=0; pn[i]; i++) if (pn[i]=='/') __progname = pn+i+1;
  416b60:	48 89 01             	mov    QWORD PTR [rcx],rax
  416b63:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  416b66:	48 83 c0 01          	add    rax,0x1
  416b6a:	84 d2                	test   dl,dl
  416b6c:	0f 85 0e ff ff ff    	jne    416a80 <__init_libc+0xf0>
  416b72:	e9 1d ff ff ff       	jmp    416a94 <__init_libc+0x104>
  416b77:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  416b7e:	00 00 
	return __cos_syscall(n, a1, a2, 0, 0, 0, 0, 0);
  416b80:	6a 00                	push   0x0
  416b82:	31 c9                	xor    ecx,ecx
  416b84:	ba 02 00 00 00       	mov    edx,0x2
  416b89:	45 31 c9             	xor    r9d,r9d
  416b8c:	6a 00                	push   0x0
  416b8e:	45 31 c0             	xor    r8d,r8d
  416b91:	bf 02 00 00 00       	mov    edi,0x2
  416b96:	48 8d 35 a8 8f 00 00 	lea    rsi,[rip+0x8fa8]        # 41fb45 <CSWTCH.187+0x755>
  416b9d:	e8 ee 42 ff ff       	call   40ae90 <__cos_syscall>
		if (__sys_open("/dev/null", O_RDWR)<0)
  416ba2:	5a                   	pop    rdx
  416ba3:	59                   	pop    rcx
  416ba4:	48 85 c0             	test   rax,rax
  416ba7:	79 8a                	jns    416b33 <__init_libc+0x1a3>
  416ba9:	f4                   	hlt    
}
  416baa:	eb 87                	jmp    416b33 <__init_libc+0x1a3>
  416bac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  416bb0:	6a 00                	push   0x0
  416bb2:	48 8d 35 8c 8f 00 00 	lea    rsi,[rip+0x8f8c]        # 41fb45 <CSWTCH.187+0x755>
  416bb9:	bf 02 00 00 00       	mov    edi,0x2
  416bbe:	31 c9                	xor    ecx,ecx
  416bc0:	6a 00                	push   0x0
  416bc2:	45 31 c9             	xor    r9d,r9d
  416bc5:	45 31 c0             	xor    r8d,r8d
  416bc8:	ba 02 00 00 00       	mov    edx,0x2
  416bcd:	e8 be 42 ff ff       	call   40ae90 <__cos_syscall>
  416bd2:	5e                   	pop    rsi
  416bd3:	5f                   	pop    rdi
  416bd4:	48 85 c0             	test   rax,rax
  416bd7:	0f 89 4f ff ff ff    	jns    416b2c <__init_libc+0x19c>
	__asm__ __volatile__( "hlt" : : : "memory" );
  416bdd:	f4                   	hlt    
  416bde:	e9 49 ff ff ff       	jmp    416b2c <__init_libc+0x19c>
  416be3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  416be8:	6a 00                	push   0x0
  416bea:	45 31 c9             	xor    r9d,r9d
  416bed:	45 31 c0             	xor    r8d,r8d
  416bf0:	31 c9                	xor    ecx,ecx
  416bf2:	6a 00                	push   0x0
  416bf4:	ba 02 00 00 00       	mov    edx,0x2
  416bf9:	bf 02 00 00 00       	mov    edi,0x2
  416bfe:	48 8d 35 40 8f 00 00 	lea    rsi,[rip+0x8f40]        # 41fb45 <CSWTCH.187+0x755>
  416c05:	e8 86 42 ff ff       	call   40ae90 <__cos_syscall>
  416c0a:	41 58                	pop    r8
  416c0c:	41 59                	pop    r9
  416c0e:	48 85 c0             	test   rax,rax
  416c11:	0f 89 0a ff ff ff    	jns    416b21 <__init_libc+0x191>
  416c17:	f4                   	hlt    
  416c18:	e9 04 ff ff ff       	jmp    416b21 <__init_libc+0x191>
  416c1d:	0f 1f 00             	nop    DWORD PTR [rax]
	if (!pn) pn = (void*)aux[AT_EXECFN];
  416c20:	48 8b 84 24 18 01 00 	mov    rax,QWORD PTR [rsp+0x118]
  416c27:	00 
	if (!pn) pn = "";
  416c28:	48 85 c0             	test   rax,rax
  416c2b:	75 5b                	jne    416c88 <__init_libc+0x2f8>
	__progname = __progname_full = pn;
  416c2d:	48 c7 c2 28 6f 71 00 	mov    rdx,0x716f28
  416c34:	48 8d 05 92 8f 00 00 	lea    rax,[rip+0x8f92]        # 41fbcd <CSWTCH.187+0x7dd>
  416c3b:	48 89 02             	mov    QWORD PTR [rdx],rax
  416c3e:	48 c7 c2 30 6f 71 00 	mov    rdx,0x716f30
  416c45:	48 89 02             	mov    QWORD PTR [rdx],rax
	for (i=0; pn[i]; i++) if (pn[i]=='/') __progname = pn+i+1;
  416c48:	e9 47 fe ff ff       	jmp    416a94 <__init_libc+0x104>
  416c4d:	0f 1f 00             	nop    DWORD PTR [rax]
		&& !aux[AT_SECURE]) return;
  416c50:	48 83 bc 24 d8 00 00 	cmp    QWORD PTR [rsp+0xd8],0x0
  416c57:	00 00 
  416c59:	0f 85 6f fe ff ff    	jne    416ace <__init_libc+0x13e>
  416c5f:	e9 d9 fe ff ff       	jmp    416b3d <__init_libc+0x1ad>
  416c64:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	for (i=0; envp[i]; i++);
  416c68:	b8 08 00 00 00       	mov    eax,0x8
  416c6d:	e9 74 fd ff ff       	jmp    4169e6 <__init_libc+0x56>
  416c72:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	__hwcap = aux[AT_HWCAP];
  416c78:	48 c7 05 b5 02 30 00 	mov    QWORD PTR [rip+0x3002b5],0x0        # 716f38 <__hwcap>
  416c7f:	00 00 00 00 
	if (aux[AT_SYSINFO]) __sysinfo = aux[AT_SYSINFO];
  416c83:	e9 bf fd ff ff       	jmp    416a47 <__init_libc+0xb7>
	if (!pn) pn = (void*)aux[AT_EXECFN];
  416c88:	48 89 c6             	mov    rsi,rax
  416c8b:	e9 c7 fd ff ff       	jmp    416a57 <__init_libc+0xc7>

0000000000416c90 <__libc_start_init>:

static void libc_start_init(void)
{
  416c90:	f3 0f 1e fa          	endbr64 
  416c94:	55                   	push   rbp
  416c95:	53                   	push   rbx
  416c96:	48 83 ec 08          	sub    rsp,0x8
	_init();
  416c9a:	e8 b1 fc ff ff       	call   416950 <_init>
	uintptr_t a = (uintptr_t)&__init_array_start;
  416c9f:	48 c7 c3 20 40 42 00 	mov    rbx,0x424020
	for (; a<(uintptr_t)&__init_array_end; a+=sizeof(void(*)()))
  416ca6:	48 c7 c5 30 40 42 00 	mov    rbp,0x424030
  416cad:	48 39 eb             	cmp    rbx,rbp
  416cb0:	73 11                	jae    416cc3 <__libc_start_init+0x33>
  416cb2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
		(*(void (**)(void))a)();
  416cb8:	ff 13                	call   QWORD PTR [rbx]
	for (; a<(uintptr_t)&__init_array_end; a+=sizeof(void(*)()))
  416cba:	48 83 c3 08          	add    rbx,0x8
  416cbe:	48 39 eb             	cmp    rbx,rbp
  416cc1:	72 f5                	jb     416cb8 <__libc_start_init+0x28>
}
  416cc3:	48 83 c4 08          	add    rsp,0x8
  416cc7:	5b                   	pop    rbx
  416cc8:	5d                   	pop    rbp
  416cc9:	c3                   	ret    
  416cca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000416cd0 <libc_start_main_stage2>:
	__asm__ ( "" : "+r"(stage2) : : "memory" );
	return stage2(main, argc, argv);
}

static int libc_start_main_stage2(int (*main)(int,char **,char **), int argc, char **argv)
{
  416cd0:	f3 0f 1e fa          	endbr64 
  416cd4:	41 55                	push   r13
  416cd6:	48 63 c6             	movsxd rax,esi
  416cd9:	41 54                	push   r12
	char **envp = argv+argc+1;
  416cdb:	4c 8d 6c c2 08       	lea    r13,[rdx+rax*8+0x8]
{
  416ce0:	49 89 d4             	mov    r12,rdx
  416ce3:	55                   	push   rbp
  416ce4:	48 89 c5             	mov    rbp,rax
  416ce7:	53                   	push   rbx
  416ce8:	48 89 fb             	mov    rbx,rdi
  416ceb:	48 83 ec 08          	sub    rsp,0x8
	__libc_start_init();
  416cef:	e8 9c ff ff ff       	call   416c90 <__libc_start_init>

	/* Pass control to the application */
	exit(main(argc, argv, envp));
  416cf4:	89 ef                	mov    edi,ebp
  416cf6:	4c 89 ea             	mov    rdx,r13
  416cf9:	4c 89 e6             	mov    rsi,r12
  416cfc:	ff d3                	call   rbx
  416cfe:	89 c7                	mov    edi,eax
  416d00:	e8 8b 00 00 00       	call   416d90 <exit>
  416d05:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  416d0c:	00 00 00 
  416d0f:	90                   	nop

0000000000416d10 <__libc_start_main>:
{
  416d10:	f3 0f 1e fa          	endbr64 
  416d14:	41 55                	push   r13
  416d16:	48 63 c6             	movsxd rax,esi
  416d19:	49 89 fd             	mov    r13,rdi
  416d1c:	41 54                	push   r12
	char **envp = argv+argc+1;
  416d1e:	48 8d 7c c2 08       	lea    rdi,[rdx+rax*8+0x8]
{
  416d23:	49 89 d4             	mov    r12,rdx
  416d26:	55                   	push   rbp
	__init_libc(envp, argv[0]);
  416d27:	48 8b 32             	mov    rsi,QWORD PTR [rdx]
{
  416d2a:	48 89 c5             	mov    rbp,rax
	__init_libc(envp, argv[0]);
  416d2d:	e8 5e fc ff ff       	call   416990 <__init_libc>
	return stage2(main, argc, argv);
  416d32:	4c 89 e2             	mov    rdx,r12
  416d35:	89 ee                	mov    esi,ebp
  416d37:	4c 89 ef             	mov    rdi,r13
	__asm__ ( "" : "+r"(stage2) : : "memory" );
  416d3a:	48 8d 05 8f ff ff ff 	lea    rax,[rip+0xffffffffffffff8f]        # 416cd0 <libc_start_main_stage2>
}
  416d41:	5d                   	pop    rbp
  416d42:	41 5c                	pop    r12
  416d44:	41 5d                	pop    r13
	return stage2(main, argc, argv);
  416d46:	ff e0                	jmp    rax
  416d48:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  416d4f:	00 

0000000000416d50 <__libc_exit_fini>:
weak_alias(dummy, _fini);

extern weak hidden void (*const __fini_array_start)(void), (*const __fini_array_end)(void);

static void libc_exit_fini(void)
{
  416d50:	f3 0f 1e fa          	endbr64 
  416d54:	55                   	push   rbp
  416d55:	53                   	push   rbx
  416d56:	48 83 ec 08          	sub    rsp,0x8
	uintptr_t a = (uintptr_t)&__fini_array_end;
  416d5a:	48 c7 c3 40 40 42 00 	mov    rbx,0x424040
	for (; a>(uintptr_t)&__fini_array_start; a-=sizeof(void(*)()))
  416d61:	48 c7 c5 30 40 42 00 	mov    rbp,0x424030
  416d68:	48 39 eb             	cmp    rbx,rbp
  416d6b:	76 10                	jbe    416d7d <__libc_exit_fini+0x2d>
  416d6d:	0f 1f 00             	nop    DWORD PTR [rax]
		(*(void (**)())(a-sizeof(void(*)())))();
  416d70:	48 83 eb 08          	sub    rbx,0x8
  416d74:	31 c0                	xor    eax,eax
  416d76:	ff 13                	call   QWORD PTR [rbx]
	for (; a>(uintptr_t)&__fini_array_start; a-=sizeof(void(*)()))
  416d78:	48 39 eb             	cmp    rbx,rbp
  416d7b:	77 f3                	ja     416d70 <__libc_exit_fini+0x20>
	_fini();
}
  416d7d:	48 83 c4 08          	add    rsp,0x8
	_fini();
  416d81:	31 c0                	xor    eax,eax
}
  416d83:	5b                   	pop    rbx
  416d84:	5d                   	pop    rbp
	_fini();
  416d85:	e9 d6 fb ff ff       	jmp    416960 <__funcs_on_exit>
  416d8a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000416d90 <exit>:

weak_alias(libc_exit_fini, __libc_exit_fini);

_Noreturn void exit(int code)
{
  416d90:	f3 0f 1e fa          	endbr64 
  416d94:	55                   	push   rbp
  416d95:	89 fd                	mov    ebp,edi
	__funcs_on_exit();
  416d97:	e8 c4 fb ff ff       	call   416960 <__funcs_on_exit>
	__libc_exit_fini();
  416d9c:	e8 af ff ff ff       	call   416d50 <__libc_exit_fini>
	__stdio_exit();
  416da1:	31 c0                	xor    eax,eax
  416da3:	e8 18 59 00 00       	call   41c6c0 <__stdio_exit>
	_Exit(code);
  416da8:	89 ef                	mov    edi,ebp
  416daa:	e8 a1 0a 00 00       	call   417850 <_Exit>
  416daf:	90                   	nop

0000000000416db0 <sn_write>:
};

#define MIN(a, b) ((a) < (b) ? (a) : (b))

static size_t sn_write(FILE *f, const unsigned char *s, size_t l)
{
  416db0:	f3 0f 1e fa          	endbr64 
  416db4:	41 56                	push   r14
  416db6:	49 89 f6             	mov    r14,rsi
  416db9:	41 55                	push   r13
  416dbb:	41 54                	push   r12
  416dbd:	49 89 d4             	mov    r12,rdx
  416dc0:	55                   	push   rbp
  416dc1:	48 89 fd             	mov    rbp,rdi
  416dc4:	53                   	push   rbx
	struct cookie *c = f->cookie;
  416dc5:	4c 8b af 98 00 00 00 	mov    r13,QWORD PTR [rdi+0x98]
	size_t k = MIN(c->n, f->wpos - f->wbase);
  416dcc:	48 8b 77 38          	mov    rsi,QWORD PTR [rdi+0x38]
  416dd0:	48 8b 4f 28          	mov    rcx,QWORD PTR [rdi+0x28]
  416dd4:	49 8b 45 08          	mov    rax,QWORD PTR [r13+0x8]
	if (k) {
		memcpy(c->s, f->wbase, k);
  416dd8:	49 8b 7d 00          	mov    rdi,QWORD PTR [r13+0x0]
	size_t k = MIN(c->n, f->wpos - f->wbase);
  416ddc:	48 29 f1             	sub    rcx,rsi
  416ddf:	48 39 c1             	cmp    rcx,rax
  416de2:	48 89 cb             	mov    rbx,rcx
  416de5:	48 0f 47 d8          	cmova  rbx,rax
	if (k) {
  416de9:	48 85 db             	test   rbx,rbx
  416dec:	75 32                	jne    416e20 <sn_write+0x70>
		c->s += k;
		c->n -= k;
	}
	k = MIN(c->n, l);
  416dee:	49 39 c4             	cmp    r12,rax
  416df1:	49 0f 46 c4          	cmovbe rax,r12
  416df5:	48 89 c3             	mov    rbx,rax
	if (k) {
  416df8:	48 85 c0             	test   rax,rax
  416dfb:	75 50                	jne    416e4d <sn_write+0x9d>
		memcpy(c->s, s, k);
		c->s += k;
		c->n -= k;
	}
	*c->s = 0;
  416dfd:	c6 07 00             	mov    BYTE PTR [rdi],0x0
	f->wpos = f->wbase = f->buf;
  416e00:	48 8b 45 58          	mov    rax,QWORD PTR [rbp+0x58]
	/* pretend to succeed, even if we discarded extra data */
	return l;
}
  416e04:	5b                   	pop    rbx
	f->wpos = f->wbase = f->buf;
  416e05:	48 89 45 38          	mov    QWORD PTR [rbp+0x38],rax
  416e09:	48 89 45 28          	mov    QWORD PTR [rbp+0x28],rax
}
  416e0d:	5d                   	pop    rbp
  416e0e:	4c 89 e0             	mov    rax,r12
  416e11:	41 5c                	pop    r12
  416e13:	41 5d                	pop    r13
  416e15:	41 5e                	pop    r14
  416e17:	c3                   	ret    
  416e18:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  416e1f:	00 
		memcpy(c->s, f->wbase, k);
  416e20:	48 89 da             	mov    rdx,rbx
  416e23:	e8 02 fa ff ff       	call   41682a <memcpy>
		c->n -= k;
  416e28:	49 8b 45 08          	mov    rax,QWORD PTR [r13+0x8]
		c->s += k;
  416e2c:	49 8b 7d 00          	mov    rdi,QWORD PTR [r13+0x0]
		c->n -= k;
  416e30:	48 29 d8             	sub    rax,rbx
		c->s += k;
  416e33:	48 01 df             	add    rdi,rbx
	k = MIN(c->n, l);
  416e36:	49 39 c4             	cmp    r12,rax
		c->n -= k;
  416e39:	49 89 45 08          	mov    QWORD PTR [r13+0x8],rax
	k = MIN(c->n, l);
  416e3d:	49 0f 46 c4          	cmovbe rax,r12
		c->s += k;
  416e41:	49 89 7d 00          	mov    QWORD PTR [r13+0x0],rdi
	k = MIN(c->n, l);
  416e45:	48 89 c3             	mov    rbx,rax
	if (k) {
  416e48:	48 85 c0             	test   rax,rax
  416e4b:	74 b0                	je     416dfd <sn_write+0x4d>
		memcpy(c->s, s, k);
  416e4d:	48 89 c2             	mov    rdx,rax
  416e50:	4c 89 f6             	mov    rsi,r14
  416e53:	e8 d2 f9 ff ff       	call   41682a <memcpy>
		c->s += k;
  416e58:	49 8b 7d 00          	mov    rdi,QWORD PTR [r13+0x0]
		c->n -= k;
  416e5c:	49 29 5d 08          	sub    QWORD PTR [r13+0x8],rbx
		c->s += k;
  416e60:	48 01 df             	add    rdi,rbx
  416e63:	49 89 7d 00          	mov    QWORD PTR [r13+0x0],rdi
		c->n -= k;
  416e67:	eb 94                	jmp    416dfd <sn_write+0x4d>
  416e69:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000416e70 <vsnprintf>:

int vsnprintf(char *restrict s, size_t n, const char *restrict fmt, va_list ap)
{
  416e70:	f3 0f 1e fa          	endbr64 
  416e74:	49 89 f2             	mov    r10,rsi
  416e77:	48 81 ec 18 01 00 00 	sub    rsp,0x118
  416e7e:	48 89 d6             	mov    rsi,rdx
  416e81:	48 89 ca             	mov    rdx,rcx
	unsigned char buf[1];
	char dummy[1];
	struct cookie c = { .s = n ? s : dummy, .n = n ? n-1 : 0 };
  416e84:	4d 85 d2             	test   r10,r10
  416e87:	75 77                	jne    416f00 <vsnprintf+0x90>
	FILE f = {
  416e89:	4c 8d 4c 24 20       	lea    r9,[rsp+0x20]
  416e8e:	4c 89 d0             	mov    rax,r10
  416e91:	b9 1d 00 00 00       	mov    ecx,0x1d
	struct cookie c = { .s = n ? s : dummy, .n = n ? n-1 : 0 };
  416e96:	48 c7 44 24 18 00 00 	mov    QWORD PTR [rsp+0x18],0x0
  416e9d:	00 00 
	FILE f = {
  416e9f:	4c 89 cf             	mov    rdi,r9
	struct cookie c = { .s = n ? s : dummy, .n = n ? n-1 : 0 };
  416ea2:	4c 8d 44 24 0f       	lea    r8,[rsp+0xf]
	FILE f = {
  416ea7:	f3 48 ab             	rep stos QWORD PTR es:[rdi],rax
  416eaa:	48 8d 05 ff fe ff ff 	lea    rax,[rip+0xfffffffffffffeff]        # 416db0 <sn_write>
	struct cookie c = { .s = n ? s : dummy, .n = n ? n-1 : 0 };
  416eb1:	4c 89 44 24 10       	mov    QWORD PTR [rsp+0x10],r8
	FILE f = {
  416eb6:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  416ebb:	48 8d 44 24 0e       	lea    rax,[rsp+0xe]
  416ec0:	48 89 44 24 78       	mov    QWORD PTR [rsp+0x78],rax
  416ec5:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  416eca:	c7 84 24 ac 00 00 00 	mov    DWORD PTR [rsp+0xac],0xffffffff
  416ed1:	ff ff ff ff 
  416ed5:	c7 84 24 b0 00 00 00 	mov    DWORD PTR [rsp+0xb0],0xffffffff
  416edc:	ff ff ff ff 
  416ee0:	48 89 84 24 b8 00 00 	mov    QWORD PTR [rsp+0xb8],rax
  416ee7:	00 
	if (n > INT_MAX) {
		errno = EOVERFLOW;
		return -1;
	}

	*c.s = 0;
  416ee8:	41 c6 00 00          	mov    BYTE PTR [r8],0x0
	return vfprintf(&f, fmt, ap);
  416eec:	4c 89 cf             	mov    rdi,r9
  416eef:	e8 bc 4c 00 00       	call   41bbb0 <vfprintf>
}
  416ef4:	48 81 c4 18 01 00 00 	add    rsp,0x118
  416efb:	c3                   	ret    
  416efc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	struct cookie c = { .s = n ? s : dummy, .n = n ? n-1 : 0 };
  416f00:	49 8d 42 ff          	lea    rax,[r10-0x1]
	FILE f = {
  416f04:	4c 8d 4c 24 20       	lea    r9,[rsp+0x20]
	struct cookie c = { .s = n ? s : dummy, .n = n ? n-1 : 0 };
  416f09:	48 89 7c 24 10       	mov    QWORD PTR [rsp+0x10],rdi
  416f0e:	49 89 f8             	mov    r8,rdi
  416f11:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
	FILE f = {
  416f16:	b9 1d 00 00 00       	mov    ecx,0x1d
  416f1b:	31 c0                	xor    eax,eax
  416f1d:	4c 89 cf             	mov    rdi,r9
  416f20:	f3 48 ab             	rep stos QWORD PTR es:[rdi],rax
  416f23:	48 8d 05 86 fe ff ff 	lea    rax,[rip+0xfffffffffffffe86]        # 416db0 <sn_write>
  416f2a:	c7 84 24 ac 00 00 00 	mov    DWORD PTR [rsp+0xac],0xffffffff
  416f31:	ff ff ff ff 
  416f35:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  416f3a:	48 8d 44 24 0e       	lea    rax,[rsp+0xe]
  416f3f:	48 89 44 24 78       	mov    QWORD PTR [rsp+0x78],rax
  416f44:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  416f49:	c7 84 24 b0 00 00 00 	mov    DWORD PTR [rsp+0xb0],0xffffffff
  416f50:	ff ff ff ff 
  416f54:	48 89 84 24 b8 00 00 	mov    QWORD PTR [rsp+0xb8],rax
  416f5b:	00 
	if (n > INT_MAX) {
  416f5c:	49 81 fa ff ff ff 7f 	cmp    r10,0x7fffffff
  416f63:	76 83                	jbe    416ee8 <vsnprintf+0x78>
		errno = EOVERFLOW;
  416f65:	e8 d6 08 00 00       	call   417840 <__errno_location>
  416f6a:	c7 00 4b 00 00 00    	mov    DWORD PTR [rax],0x4b
		return -1;
  416f70:	b8 ff ff ff ff       	mov    eax,0xffffffff
  416f75:	e9 7a ff ff ff       	jmp    416ef4 <vsnprintf+0x84>
  416f7a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000416f80 <atoi>:
#include <stdlib.h>
#include <ctype.h>

int atoi(const char *s)
{
  416f80:	f3 0f 1e fa          	endbr64 
	int n=0, neg=0;
	while (isspace(*s)) s++;
  416f84:	eb 0e                	jmp    416f94 <atoi+0x14>
  416f86:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  416f8d:	00 00 00 
  416f90:	48 83 c7 01          	add    rdi,0x1
  416f94:	0f be 07             	movsx  eax,BYTE PTR [rdi]
int   toupper(int);

#ifndef __cplusplus
static __inline int __isspace(int _c)
{
	return _c == ' ' || (unsigned)_c-'\t' < 5;
  416f97:	8d 48 f7             	lea    ecx,[rax-0x9]
  416f9a:	89 c2                	mov    edx,eax
  416f9c:	83 f9 04             	cmp    ecx,0x4
  416f9f:	76 ef                	jbe    416f90 <atoi+0x10>
  416fa1:	80 fa 20             	cmp    dl,0x20
  416fa4:	74 ea                	je     416f90 <atoi+0x10>
	switch (*s) {
  416fa6:	80 fa 2b             	cmp    dl,0x2b
  416fa9:	74 4d                	je     416ff8 <atoi+0x78>
  416fab:	80 fa 2d             	cmp    dl,0x2d
  416fae:	74 68                	je     417018 <atoi+0x98>
	case '-': neg=1;
	case '+': s++;
	}
	/* Compute n as a negative number to avoid overflow on INT_MIN */
	while (isdigit(*s))
  416fb0:	8d 50 d0             	lea    edx,[rax-0x30]
  416fb3:	48 89 f9             	mov    rcx,rdi
	int n=0, neg=0;
  416fb6:	45 31 c9             	xor    r9d,r9d
	while (isdigit(*s))
  416fb9:	83 fa 09             	cmp    edx,0x9
  416fbc:	77 4d                	ja     41700b <atoi+0x8b>
	int n=0, neg=0;
  416fbe:	45 31 c0             	xor    r8d,r8d
  416fc1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		n = 10*n - (*s++ - '0');
  416fc8:	48 83 c1 01          	add    rcx,0x1
  416fcc:	43 8d 14 80          	lea    edx,[r8+r8*4]
  416fd0:	8d 70 d0             	lea    esi,[rax-0x30]
	while (isdigit(*s))
  416fd3:	0f be 01             	movsx  eax,BYTE PTR [rcx]
		n = 10*n - (*s++ - '0');
  416fd6:	01 d2                	add    edx,edx
  416fd8:	41 89 d0             	mov    r8d,edx
	while (isdigit(*s))
  416fdb:	8d 78 d0             	lea    edi,[rax-0x30]
		n = 10*n - (*s++ - '0');
  416fde:	41 29 f0             	sub    r8d,esi
	while (isdigit(*s))
  416fe1:	83 ff 09             	cmp    edi,0x9
  416fe4:	76 e2                	jbe    416fc8 <atoi+0x48>
	return neg ? n : -n;
  416fe6:	29 d6                	sub    esi,edx
  416fe8:	45 85 c9             	test   r9d,r9d
  416feb:	44 0f 44 c6          	cmove  r8d,esi
}
  416fef:	44 89 c0             	mov    eax,r8d
  416ff2:	c3                   	ret    
  416ff3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	while (isdigit(*s))
  416ff8:	0f be 47 01          	movsx  eax,BYTE PTR [rdi+0x1]
	case '+': s++;
  416ffc:	48 8d 4f 01          	lea    rcx,[rdi+0x1]
	int n=0, neg=0;
  417000:	45 31 c9             	xor    r9d,r9d
	while (isdigit(*s))
  417003:	8d 50 d0             	lea    edx,[rax-0x30]
  417006:	83 fa 09             	cmp    edx,0x9
  417009:	76 b3                	jbe    416fbe <atoi+0x3e>
  41700b:	45 31 c0             	xor    r8d,r8d
}
  41700e:	44 89 c0             	mov    eax,r8d
  417011:	c3                   	ret    
  417012:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	while (isdigit(*s))
  417018:	0f be 47 01          	movsx  eax,BYTE PTR [rdi+0x1]
	case '+': s++;
  41701c:	48 8d 4f 01          	lea    rcx,[rdi+0x1]
	while (isdigit(*s))
  417020:	8d 50 d0             	lea    edx,[rax-0x30]
  417023:	83 fa 09             	cmp    edx,0x9
  417026:	77 e3                	ja     41700b <atoi+0x8b>
	case '-': neg=1;
  417028:	41 b9 01 00 00 00    	mov    r9d,0x1
  41702e:	eb 8e                	jmp    416fbe <atoi+0x3e>

0000000000417030 <atol>:
#include <stdlib.h>
#include <ctype.h>

long atol(const char *s)
{
  417030:	f3 0f 1e fa          	endbr64 
	long n=0;
	int neg=0;
	while (isspace(*s)) s++;
  417034:	eb 0e                	jmp    417044 <atol+0x14>
  417036:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41703d:	00 00 00 
  417040:	48 83 c7 01          	add    rdi,0x1
  417044:	0f be 07             	movsx  eax,BYTE PTR [rdi]
  417047:	8d 48 f7             	lea    ecx,[rax-0x9]
  41704a:	89 c2                	mov    edx,eax
  41704c:	83 f9 04             	cmp    ecx,0x4
  41704f:	76 ef                	jbe    417040 <atol+0x10>
  417051:	80 fa 20             	cmp    dl,0x20
  417054:	74 ea                	je     417040 <atol+0x10>
	switch (*s) {
  417056:	80 fa 2b             	cmp    dl,0x2b
  417059:	74 55                	je     4170b0 <atol+0x80>
  41705b:	80 fa 2d             	cmp    dl,0x2d
  41705e:	74 70                	je     4170d0 <atol+0xa0>
	case '-': neg=1;
	case '+': s++;
	}
	/* Compute n as a negative number to avoid overflow on LONG_MIN */
	while (isdigit(*s))
  417060:	8d 50 d0             	lea    edx,[rax-0x30]
  417063:	48 89 f9             	mov    rcx,rdi
	int neg=0;
  417066:	45 31 c9             	xor    r9d,r9d
	while (isdigit(*s))
  417069:	83 fa 09             	cmp    edx,0x9
  41706c:	77 55                	ja     4170c3 <atol+0x93>
	int neg=0;
  41706e:	45 31 c0             	xor    r8d,r8d
  417071:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		n = 10*n - (*s++ - '0');
  417078:	83 e8 30             	sub    eax,0x30
  41707b:	48 83 c1 01          	add    rcx,0x1
  41707f:	4b 8d 14 80          	lea    rdx,[r8+r8*4]
  417083:	48 63 f0             	movsxd rsi,eax
	while (isdigit(*s))
  417086:	0f be 01             	movsx  eax,BYTE PTR [rcx]
		n = 10*n - (*s++ - '0');
  417089:	48 01 d2             	add    rdx,rdx
  41708c:	49 89 d0             	mov    r8,rdx
	while (isdigit(*s))
  41708f:	8d 78 d0             	lea    edi,[rax-0x30]
		n = 10*n - (*s++ - '0');
  417092:	49 29 f0             	sub    r8,rsi
	while (isdigit(*s))
  417095:	83 ff 09             	cmp    edi,0x9
  417098:	76 de                	jbe    417078 <atol+0x48>
	return neg ? n : -n;
  41709a:	48 29 d6             	sub    rsi,rdx
  41709d:	45 85 c9             	test   r9d,r9d
  4170a0:	4c 0f 44 c6          	cmove  r8,rsi
}
  4170a4:	4c 89 c0             	mov    rax,r8
  4170a7:	c3                   	ret    
  4170a8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4170af:	00 
	while (isdigit(*s))
  4170b0:	0f be 47 01          	movsx  eax,BYTE PTR [rdi+0x1]
	case '+': s++;
  4170b4:	48 8d 4f 01          	lea    rcx,[rdi+0x1]
	int neg=0;
  4170b8:	45 31 c9             	xor    r9d,r9d
	while (isdigit(*s))
  4170bb:	8d 50 d0             	lea    edx,[rax-0x30]
  4170be:	83 fa 09             	cmp    edx,0x9
  4170c1:	76 ab                	jbe    41706e <atol+0x3e>
  4170c3:	45 31 c0             	xor    r8d,r8d
}
  4170c6:	4c 89 c0             	mov    rax,r8
  4170c9:	c3                   	ret    
  4170ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	while (isdigit(*s))
  4170d0:	0f be 47 01          	movsx  eax,BYTE PTR [rdi+0x1]
	case '+': s++;
  4170d4:	48 8d 4f 01          	lea    rcx,[rdi+0x1]
	while (isdigit(*s))
  4170d8:	8d 50 d0             	lea    edx,[rax-0x30]
  4170db:	83 fa 09             	cmp    edx,0x9
  4170de:	77 e3                	ja     4170c3 <atol+0x93>
	case '-': neg=1;
  4170e0:	41 b9 01 00 00 00    	mov    r9d,0x1
  4170e6:	eb 86                	jmp    41706e <atol+0x3e>
  4170e8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4170ef:	00 

00000000004170f0 <strchr>:
#include <string.h>

char *strchr(const char *s, int c)
{
  4170f0:	f3 0f 1e fa          	endbr64 
  4170f4:	53                   	push   rbx
  4170f5:	89 f3                	mov    ebx,esi
	char *r = __strchrnul(s, c);
  4170f7:	e8 14 00 00 00       	call   417110 <__strchrnul>
	return *(unsigned char *)r == (unsigned char)c ? r : 0;
  4170fc:	31 d2                	xor    edx,edx
  4170fe:	38 18                	cmp    BYTE PTR [rax],bl
}
  417100:	5b                   	pop    rbx
	return *(unsigned char *)r == (unsigned char)c ? r : 0;
  417101:	48 0f 45 c2          	cmovne rax,rdx
}
  417105:	c3                   	ret    
  417106:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41710d:	00 00 00 

0000000000417110 <__strchrnul>:
#define ONES ((size_t)-1/UCHAR_MAX)
#define HIGHS (ONES * (UCHAR_MAX/2+1))
#define HASZERO(x) ((x)-ONES & ~(x) & HIGHS)

char *__strchrnul(const char *s, int c)
{
  417110:	f3 0f 1e fa          	endbr64 
	c = (unsigned char)c;
	if (!c) return (char *)s + strlen(s);
  417114:	89 f1                	mov    ecx,esi
{
  417116:	41 54                	push   r12
  417118:	49 89 fc             	mov    r12,rdi
	if (!c) return (char *)s + strlen(s);
  41711b:	81 e1 ff 00 00 00    	and    ecx,0xff
  417121:	75 26                	jne    417149 <__strchrnul+0x39>
  417123:	e9 c8 00 00 00       	jmp    4171f0 <__strchrnul+0xe0>
  417128:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41712f:	00 

#ifdef __GNUC__
	typedef size_t __attribute__((__may_alias__)) word;
	const word *w;
	for (; (uintptr_t)s % ALIGN; s++)
		if (!*s || *(unsigned char *)s == c) return (char *)s;
  417130:	41 0f b6 04 24       	movzx  eax,BYTE PTR [r12]
  417135:	84 c0                	test   al,al
  417137:	0f 84 ac 00 00 00    	je     4171e9 <__strchrnul+0xd9>
  41713d:	39 c8                	cmp    eax,ecx
  41713f:	0f 84 a4 00 00 00    	je     4171e9 <__strchrnul+0xd9>
	for (; (uintptr_t)s % ALIGN; s++)
  417145:	49 83 c4 01          	add    r12,0x1
  417149:	41 f6 c4 07          	test   r12b,0x7
  41714d:	75 e1                	jne    417130 <__strchrnul+0x20>
	size_t k = ONES * c;
  41714f:	48 bf 01 01 01 01 01 	movabs rdi,0x101010101010101
  417156:	01 01 01 
  417159:	4c 63 c1             	movsxd r8,ecx
	for (w = (void *)s; !HASZERO(*w) && !HASZERO(*w^k); w++);
  41715c:	49 8b 14 24          	mov    rdx,QWORD PTR [r12]
  417160:	49 b9 80 80 80 80 80 	movabs r9,0x8080808080808080
  417167:	80 80 80 
	size_t k = ONES * c;
  41716a:	4c 0f af c7          	imul   r8,rdi
	for (w = (void *)s; !HASZERO(*w) && !HASZERO(*w^k); w++);
  41716e:	48 89 d0             	mov    rax,rdx
  417171:	48 f7 d0             	not    rax
  417174:	4c 89 c6             	mov    rsi,r8
  417177:	48 31 d6             	xor    rsi,rdx
  41717a:	48 29 fa             	sub    rdx,rdi
  41717d:	48 21 d0             	and    rax,rdx
  417180:	48 89 f2             	mov    rdx,rsi
  417183:	48 f7 d6             	not    rsi
  417186:	48 29 fa             	sub    rdx,rdi
  417189:	48 21 f2             	and    rdx,rsi
  41718c:	48 09 d0             	or     rax,rdx
  41718f:	4c 85 c8             	test   rax,r9
  417192:	75 4c                	jne    4171e0 <__strchrnul+0xd0>
  417194:	48 bf ff fe fe fe fe 	movabs rdi,0xfefefefefefefeff
  41719b:	fe fe fe 
  41719e:	66 90                	xchg   ax,ax
  4171a0:	49 8b 54 24 08       	mov    rdx,QWORD PTR [r12+0x8]
  4171a5:	49 83 c4 08          	add    r12,0x8
  4171a9:	48 89 d6             	mov    rsi,rdx
  4171ac:	48 8d 04 3a          	lea    rax,[rdx+rdi*1]
  4171b0:	48 f7 d2             	not    rdx
  4171b3:	4c 31 c6             	xor    rsi,r8
  4171b6:	48 21 d0             	and    rax,rdx
  4171b9:	48 8d 14 3e          	lea    rdx,[rsi+rdi*1]
  4171bd:	48 f7 d6             	not    rsi
  4171c0:	48 21 f2             	and    rdx,rsi
  4171c3:	48 09 d0             	or     rax,rdx
  4171c6:	4c 85 c8             	test   rax,r9
  4171c9:	74 d5                	je     4171a0 <__strchrnul+0x90>
	s = (void *)w;
#endif
	for (; *s && *(unsigned char *)s != c; s++);
  4171cb:	41 0f b6 04 24       	movzx  eax,BYTE PTR [r12]
  4171d0:	84 c0                	test   al,al
  4171d2:	74 15                	je     4171e9 <__strchrnul+0xd9>
  4171d4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  4171d8:	39 c8                	cmp    eax,ecx
  4171da:	74 0d                	je     4171e9 <__strchrnul+0xd9>
  4171dc:	49 83 c4 01          	add    r12,0x1
  4171e0:	41 0f b6 04 24       	movzx  eax,BYTE PTR [r12]
  4171e5:	84 c0                	test   al,al
  4171e7:	75 ef                	jne    4171d8 <__strchrnul+0xc8>
	return (char *)s;
}
  4171e9:	4c 89 e0             	mov    rax,r12
  4171ec:	41 5c                	pop    r12
  4171ee:	c3                   	ret    
  4171ef:	90                   	nop
	if (!c) return (char *)s + strlen(s);
  4171f0:	e8 4b 00 00 00       	call   417240 <strlen>
  4171f5:	49 01 c4             	add    r12,rax
}
  4171f8:	4c 89 e0             	mov    rax,r12
  4171fb:	41 5c                	pop    r12
  4171fd:	c3                   	ret    
  4171fe:	66 90                	xchg   ax,ax

0000000000417200 <strcmp>:
#include <string.h>

int strcmp(const char *l, const char *r)
{
  417200:	f3 0f 1e fa          	endbr64 
	for (; *l==*r && *l; l++, r++);
  417204:	0f b6 17             	movzx  edx,BYTE PTR [rdi]
  417207:	0f b6 0e             	movzx  ecx,BYTE PTR [rsi]
  41720a:	b8 01 00 00 00       	mov    eax,0x1
  41720f:	38 d1                	cmp    cl,dl
  417211:	74 16                	je     417229 <strcmp+0x29>
  417213:	eb 23                	jmp    417238 <strcmp+0x38>
  417215:	0f 1f 00             	nop    DWORD PTR [rax]
  417218:	0f b6 14 07          	movzx  edx,BYTE PTR [rdi+rax*1]
  41721c:	48 83 c0 01          	add    rax,0x1
  417220:	0f b6 4c 06 ff       	movzx  ecx,BYTE PTR [rsi+rax*1-0x1]
  417225:	38 ca                	cmp    dl,cl
  417227:	75 0f                	jne    417238 <strcmp+0x38>
  417229:	84 d2                	test   dl,dl
  41722b:	75 eb                	jne    417218 <strcmp+0x18>
  41722d:	31 c0                	xor    eax,eax
	return *(unsigned char *)l - *(unsigned char *)r;
  41722f:	29 c8                	sub    eax,ecx
}
  417231:	c3                   	ret    
  417232:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	return *(unsigned char *)l - *(unsigned char *)r;
  417238:	0f b6 c2             	movzx  eax,dl
  41723b:	29 c8                	sub    eax,ecx
}
  41723d:	c3                   	ret    
  41723e:	66 90                	xchg   ax,ax

0000000000417240 <strlen>:
#define ONES ((size_t)-1/UCHAR_MAX)
#define HIGHS (ONES * (UCHAR_MAX/2+1))
#define HASZERO(x) ((x)-ONES & ~(x) & HIGHS)

size_t strlen(const char *s)
{
  417240:	f3 0f 1e fa          	endbr64 
	const char *a = s;
#ifdef __GNUC__
	typedef size_t __attribute__((__may_alias__)) word;
	const word *w;
	for (; (uintptr_t)s % ALIGN; s++) if (!*s) return s-a;
  417244:	48 89 f8             	mov    rax,rdi
  417247:	40 f6 c7 07          	test   dil,0x7
  41724b:	75 0b                	jne    417258 <strlen+0x18>
  41724d:	eb 19                	jmp    417268 <strlen+0x28>
  41724f:	90                   	nop
  417250:	48 83 c0 01          	add    rax,0x1
  417254:	a8 07                	test   al,0x7
  417256:	74 10                	je     417268 <strlen+0x28>
  417258:	80 38 00             	cmp    BYTE PTR [rax],0x0
  41725b:	75 f3                	jne    417250 <strlen+0x10>
	for (w = (const void *)s; !HASZERO(*w); w++);
	s = (const void *)w;
#endif
	for (; *s; s++);
	return s-a;
  41725d:	48 29 f8             	sub    rax,rdi
}
  417260:	c3                   	ret    
  417261:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (w = (const void *)s; !HASZERO(*w); w++);
  417268:	49 b8 ff fe fe fe fe 	movabs r8,0xfefefefefefefeff
  41726f:	fe fe fe 
  417272:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  417275:	48 be 80 80 80 80 80 	movabs rsi,0x8080808080808080
  41727c:	80 80 80 
  41727f:	4a 8d 0c 02          	lea    rcx,[rdx+r8*1]
  417283:	48 f7 d2             	not    rdx
  417286:	48 21 ca             	and    rdx,rcx
  417289:	48 85 f2             	test   rdx,rsi
  41728c:	75 26                	jne    4172b4 <strlen+0x74>
  41728e:	66 90                	xchg   ax,ax
  417290:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  417294:	48 83 c0 08          	add    rax,0x8
  417298:	4a 8d 0c 02          	lea    rcx,[rdx+r8*1]
  41729c:	48 f7 d2             	not    rdx
  41729f:	48 21 ca             	and    rdx,rcx
  4172a2:	48 85 f2             	test   rdx,rsi
  4172a5:	74 e9                	je     417290 <strlen+0x50>
  4172a7:	eb 0b                	jmp    4172b4 <strlen+0x74>
  4172a9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (; *s; s++);
  4172b0:	48 83 c0 01          	add    rax,0x1
  4172b4:	80 38 00             	cmp    BYTE PTR [rax],0x0
  4172b7:	75 f7                	jne    4172b0 <strlen+0x70>
	return s-a;
  4172b9:	48 29 f8             	sub    rax,rdi
}
  4172bc:	c3                   	ret    
  4172bd:	0f 1f 00             	nop    DWORD PTR [rax]

00000000004172c0 <strncmp>:
#include <string.h>

int strncmp(const char *_l, const char *_r, size_t n)
{
  4172c0:	f3 0f 1e fa          	endbr64 
  4172c4:	49 89 f9             	mov    r9,rdi
  4172c7:	49 89 f2             	mov    r10,rsi
	const unsigned char *l=(void *)_l, *r=(void *)_r;
	if (!n--) return 0;
  4172ca:	31 c0                	xor    eax,eax
  4172cc:	48 85 d2             	test   rdx,rdx
  4172cf:	74 60                	je     417331 <strncmp+0x71>
	for (; *l && *r && n && *l == *r ; l++, r++, n--);
  4172d1:	0f b6 07             	movzx  eax,BYTE PTR [rdi]
  4172d4:	0f b6 3e             	movzx  edi,BYTE PTR [rsi]
  4172d7:	84 c0                	test   al,al
  4172d9:	74 5d                	je     417338 <strncmp+0x78>
  4172db:	48 83 ea 01          	sub    rdx,0x1
  4172df:	40 0f 95 c6          	setne  sil
  4172e3:	40 84 ff             	test   dil,dil
  4172e6:	0f 95 c1             	setne  cl
  4172e9:	40 84 ce             	test   sil,cl
  4172ec:	74 41                	je     41732f <strncmp+0x6f>
  4172ee:	b9 01 00 00 00       	mov    ecx,0x1
  4172f3:	40 38 f8             	cmp    al,dil
  4172f6:	75 37                	jne    41732f <strncmp+0x6f>
  4172f8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4172ff:	00 
  417300:	41 0f b6 04 09       	movzx  eax,BYTE PTR [r9+rcx*1]
  417305:	41 0f b6 3c 0a       	movzx  edi,BYTE PTR [r10+rcx*1]
  41730a:	84 c0                	test   al,al
  41730c:	74 2a                	je     417338 <strncmp+0x78>
  41730e:	40 84 ff             	test   dil,dil
  417311:	40 0f 95 c6          	setne  sil
  417315:	40 38 f8             	cmp    al,dil
  417318:	41 0f 94 c0          	sete   r8b
  41731c:	44 21 c6             	and    esi,r8d
  41731f:	48 39 ca             	cmp    rdx,rcx
  417322:	41 0f 95 c0          	setne  r8b
  417326:	48 83 c1 01          	add    rcx,0x1
  41732a:	44 84 c6             	test   sil,r8b
  41732d:	75 d1                	jne    417300 <strncmp+0x40>
	return *l - *r;
  41732f:	29 f8                	sub    eax,edi
}
  417331:	c3                   	ret    
  417332:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  417338:	31 c0                	xor    eax,eax
	return *l - *r;
  41733a:	29 f8                	sub    eax,edi
  41733c:	eb f3                	jmp    417331 <strncmp+0x71>
  41733e:	66 90                	xchg   ax,ax

0000000000417340 <strnlen>:
#include <string.h>

size_t strnlen(const char *s, size_t n)
{
  417340:	f3 0f 1e fa          	endbr64 
  417344:	55                   	push   rbp
	const char *p = memchr(s, 0, n);
  417345:	48 89 f2             	mov    rdx,rsi
{
  417348:	48 89 fd             	mov    rbp,rdi
  41734b:	53                   	push   rbx
  41734c:	48 89 f3             	mov    rbx,rsi
	const char *p = memchr(s, 0, n);
  41734f:	31 f6                	xor    esi,esi
{
  417351:	48 83 ec 08          	sub    rsp,0x8
	const char *p = memchr(s, 0, n);
  417355:	e8 36 4a 00 00       	call   41bd90 <memchr>
	return p ? p-s : n;
  41735a:	48 89 c2             	mov    rdx,rax
  41735d:	48 29 ea             	sub    rdx,rbp
  417360:	48 85 c0             	test   rax,rax
  417363:	48 89 d8             	mov    rax,rbx
  417366:	48 0f 45 c2          	cmovne rax,rdx
}
  41736a:	48 83 c4 08          	add    rsp,0x8
  41736e:	5b                   	pop    rbx
  41736f:	5d                   	pop    rbp
  417370:	c3                   	ret    
  417371:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  417378:	00 00 00 
  41737b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000417380 <__init_tp>:
#include "syscall.h"

volatile int __thread_list_lock;

int __init_tp(void *p)
{
  417380:	f3 0f 1e fa          	endbr64 
  417384:	53                   	push   rbx
  417385:	66 48 0f 6e c7       	movq   xmm0,rdi
  41738a:	48 89 fb             	mov    rbx,rdi
  41738d:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
  417391:	48 83 ec 10          	sub    rsp,0x10
	pthread_t td = p;
	td->self = td;
  417395:	48 89 3f             	mov    QWORD PTR [rdi],rdi
  417398:	0f 29 04 24          	movaps XMMWORD PTR [rsp],xmm0
	int r = __set_thread_area(TP_ADJ(p));
  41739c:	e8 7f f5 ff ff       	call   416920 <__set_thread_area>
	if (r < 0) return -1;
  4173a1:	85 c0                	test   eax,eax
  4173a3:	78 77                	js     41741c <__init_tp+0x9c>
	if (!r) libc.can_do_threads = 1;
  4173a5:	74 69                	je     417410 <__init_tp+0x90>
	return __cos_syscall(n, a1, 0, 0, 0, 0, 0, 0);
  4173a7:	6a 00                	push   0x0
  4173a9:	31 d2                	xor    edx,edx
  4173ab:	45 31 c9             	xor    r9d,r9d
  4173ae:	45 31 c0             	xor    r8d,r8d
  4173b1:	6a 00                	push   0x0
  4173b3:	31 c9                	xor    ecx,ecx
  4173b5:	48 8d 35 ac fd 2f 00 	lea    rsi,[rip+0x2ffdac]        # 717168 <__thread_list_lock>
  4173bc:	bf da 00 00 00       	mov    edi,0xda
	td->detach_state = DT_JOINABLE;
  4173c1:	c7 43 40 01 00 00 00 	mov    DWORD PTR [rbx+0x40],0x1
  4173c8:	e8 c3 3a ff ff       	call   40ae90 <__cos_syscall>
	td->tid = __syscall(SYS_set_tid_address, &__thread_list_lock);
	td->locale = &libc.global_locale;
	td->robust_list.head = &td->robust_list.head;
	td->sysinfo = __sysinfo;
	td->next = td->prev = td;
  4173cd:	66 0f 6f 4c 24 10    	movdqa xmm1,XMMWORD PTR [rsp+0x10]
	td->tid = __syscall(SYS_set_tid_address, &__thread_list_lock);
  4173d3:	89 43 38             	mov    DWORD PTR [rbx+0x38],eax
	td->locale = &libc.global_locale;
  4173d6:	48 8d 05 a3 fb 2f 00 	lea    rax,[rip+0x2ffba3]        # 716f80 <__libc+0x40>
  4173dd:	48 89 83 b0 00 00 00 	mov    QWORD PTR [rbx+0xb0],rax
	td->robust_list.head = &td->robust_list.head;
  4173e4:	48 8d 83 90 00 00 00 	lea    rax,[rbx+0x90]
  4173eb:	48 89 83 90 00 00 00 	mov    QWORD PTR [rbx+0x90],rax
	td->sysinfo = __sysinfo;
  4173f2:	48 8b 05 27 fb 2f 00 	mov    rax,QWORD PTR [rip+0x2ffb27]        # 716f20 <__sysinfo>
	td->next = td->prev = td;
  4173f9:	0f 11 4b 10          	movups XMMWORD PTR [rbx+0x10],xmm1
	td->sysinfo = __sysinfo;
  4173fd:	48 89 43 20          	mov    QWORD PTR [rbx+0x20],rax
	return 0;
  417401:	58                   	pop    rax
  417402:	31 c0                	xor    eax,eax
  417404:	5a                   	pop    rdx
}
  417405:	48 83 c4 10          	add    rsp,0x10
  417409:	5b                   	pop    rbx
  41740a:	c3                   	ret    
  41740b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	if (!r) libc.can_do_threads = 1;
  417410:	c7 05 26 fb 2f 00 01 	mov    DWORD PTR [rip+0x2ffb26],0x1        # 716f40 <__libc>
  417417:	00 00 00 
  41741a:	eb 8b                	jmp    4173a7 <__init_tp+0x27>
	if (r < 0) return -1;
  41741c:	b8 ff ff ff ff       	mov    eax,0xffffffff
  417421:	eb e2                	jmp    417405 <__init_tp+0x85>
  417423:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41742a:	00 00 00 
  41742d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000417430 <__copy_tls>:
#define MIN_TLS_ALIGN offsetof(struct builtin_tls, pt)

static struct tls_module main_tls;

void *__copy_tls(unsigned char *mem)
{
  417430:	f3 0f 1e fa          	endbr64 
  417434:	41 55                	push   r13
  417436:	49 89 fd             	mov    r13,rdi
  417439:	41 54                	push   r12
  41743b:	55                   	push   rbp
  41743c:	53                   	push   rbx
  41743d:	48 83 ec 08          	sub    rsp,0x8
		memcpy(mem + p->offset, p->image, p->len);
	}
#else
	dtv = (uintptr_t *)mem;

	mem += libc.tls_size - sizeof(struct pthread);
  417441:	48 8b 05 18 fb 2f 00 	mov    rax,QWORD PTR [rip+0x2ffb18]        # 716f60 <__libc+0x20>
	mem -= (uintptr_t)mem & (libc.tls_align-1);
  417448:	4c 8b 25 19 fb 2f 00 	mov    r12,QWORD PTR [rip+0x2ffb19]        # 716f68 <__libc+0x28>
	td = (pthread_t)mem;

	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
  41744f:	48 8b 1d 02 fb 2f 00 	mov    rbx,QWORD PTR [rip+0x2ffb02]        # 716f58 <__libc+0x18>
	mem += libc.tls_size - sizeof(struct pthread);
  417456:	48 8d 84 07 20 ff ff 	lea    rax,[rdi+rax*1-0xe0]
  41745d:	ff 
	mem -= (uintptr_t)mem & (libc.tls_align-1);
  41745e:	49 f7 dc             	neg    r12
  417461:	49 21 c4             	and    r12,rax
	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
  417464:	48 85 db             	test   rbx,rbx
  417467:	74 32                	je     41749b <__copy_tls+0x6b>
  417469:	48 8d 6f 08          	lea    rbp,[rdi+0x8]
  41746d:	0f 1f 00             	nop    DWORD PTR [rax]
		dtv[i] = (uintptr_t)(mem - p->offset) + DTP_OFFSET;
  417470:	4c 89 e0             	mov    rax,r12
  417473:	48 2b 43 28          	sub    rax,QWORD PTR [rbx+0x28]
		memcpy(mem - p->offset, p->image, p->len);
  417477:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
  41747b:	4c 89 e7             	mov    rdi,r12
		dtv[i] = (uintptr_t)(mem - p->offset) + DTP_OFFSET;
  41747e:	48 89 45 00          	mov    QWORD PTR [rbp+0x0],rax
		memcpy(mem - p->offset, p->image, p->len);
  417482:	48 8b 53 10          	mov    rdx,QWORD PTR [rbx+0x10]
	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
  417486:	48 83 c5 08          	add    rbp,0x8
		memcpy(mem - p->offset, p->image, p->len);
  41748a:	48 2b 7b 28          	sub    rdi,QWORD PTR [rbx+0x28]
  41748e:	e8 97 f3 ff ff       	call   41682a <memcpy>
	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
  417493:	48 8b 1b             	mov    rbx,QWORD PTR [rbx]
  417496:	48 85 db             	test   rbx,rbx
  417499:	75 d5                	jne    417470 <__copy_tls+0x40>
	}
#endif
	dtv[0] = libc.tls_cnt;
  41749b:	48 8b 05 ce fa 2f 00 	mov    rax,QWORD PTR [rip+0x2fface]        # 716f70 <__libc+0x30>
  4174a2:	49 89 45 00          	mov    QWORD PTR [r13+0x0],rax
	td->dtv = td->dtv_copy = dtv;
	return td;
}
  4174a6:	4c 89 e0             	mov    rax,r12
	td->dtv = td->dtv_copy = dtv;
  4174a9:	4d 89 ac 24 d8 00 00 	mov    QWORD PTR [r12+0xd8],r13
  4174b0:	00 
  4174b1:	4d 89 6c 24 08       	mov    QWORD PTR [r12+0x8],r13
}
  4174b6:	48 83 c4 08          	add    rsp,0x8
  4174ba:	5b                   	pop    rbx
  4174bb:	5d                   	pop    rbp
  4174bc:	41 5c                	pop    r12
  4174be:	41 5d                	pop    r13
  4174c0:	c3                   	ret    
  4174c1:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4174c8:	00 00 00 
  4174cb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000004174d0 <__init_tls>:
#endif

extern weak hidden const size_t _DYNAMIC[];

static void static_init_tls(size_t *aux)
{
  4174d0:	f3 0f 1e fa          	endbr64 
  4174d4:	41 55                	push   r13
  4174d6:	41 54                	push   r12
  4174d8:	55                   	push   rbp
  4174d9:	53                   	push   rbx
  4174da:	48 83 ec 28          	sub    rsp,0x28
	size_t n;
	Phdr *phdr, *tls_phdr=0;
	size_t base = 0;
	void *mem;

	for (p=(void *)aux[AT_PHDR],n=aux[AT_PHNUM]; n; n--,p+=aux[AT_PHENT]) {
  4174de:	48 8b 57 28          	mov    rdx,QWORD PTR [rdi+0x28]
  4174e2:	48 8b 6f 18          	mov    rbp,QWORD PTR [rdi+0x18]
  4174e6:	48 85 d2             	test   rdx,rdx
  4174e9:	0f 84 31 03 00 00    	je     417820 <__init_tls+0x350>
  4174ef:	49 c7 c1 00 00 00 00 	mov    r9,0x0
  4174f6:	4c 8b 5f 20          	mov    r11,QWORD PTR [rdi+0x20]
  4174fa:	48 89 e8             	mov    rax,rbp
	size_t base = 0;
  4174fd:	31 c9                	xor    ecx,ecx
  4174ff:	44 8b 05 ae 4b 1a 00 	mov    r8d,DWORD PTR [rip+0x1a4bae]        # 5bc0b4 <__default_stacksize>
	for (p=(void *)aux[AT_PHDR],n=aux[AT_PHNUM]; n; n--,p+=aux[AT_PHENT]) {
  417506:	45 31 d2             	xor    r10d,r10d
	Phdr *phdr, *tls_phdr=0;
  417509:	31 db                	xor    ebx,ebx
  41750b:	4d 85 c9             	test   r9,r9
  41750e:	75 26                	jne    417536 <__init_tls+0x66>
  417510:	e9 25 02 00 00       	jmp    41773a <__init_tls+0x26a>
  417515:	0f 1f 00             	nop    DWORD PTR [rax]
		phdr = (void *)p;
		if (phdr->p_type == PT_PHDR)
			base = aux[AT_PHDR] - phdr->p_vaddr;
		if (phdr->p_type == PT_DYNAMIC && _DYNAMIC)
  417518:	83 fe 02             	cmp    esi,0x2
  41751b:	0f 84 5f 02 00 00    	je     417780 <__init_tls+0x2b0>
			base = (size_t)_DYNAMIC - phdr->p_vaddr;
		if (phdr->p_type == PT_TLS)
  417521:	83 fe 07             	cmp    esi,0x7
  417524:	0f 85 20 02 00 00    	jne    41774a <__init_tls+0x27a>
  41752a:	48 89 c3             	mov    rbx,rax
	for (p=(void *)aux[AT_PHDR],n=aux[AT_PHNUM]; n; n--,p+=aux[AT_PHENT]) {
  41752d:	4c 01 d8             	add    rax,r11
  417530:	48 83 ea 01          	sub    rdx,0x1
  417534:	74 17                	je     41754d <__init_tls+0x7d>
		if (phdr->p_type == PT_PHDR)
  417536:	8b 30                	mov    esi,DWORD PTR [rax]
  417538:	83 fe 06             	cmp    esi,0x6
  41753b:	75 db                	jne    417518 <__init_tls+0x48>
			base = aux[AT_PHDR] - phdr->p_vaddr;
  41753d:	48 89 e9             	mov    rcx,rbp
  417540:	48 2b 48 10          	sub    rcx,QWORD PTR [rax+0x10]
	for (p=(void *)aux[AT_PHDR],n=aux[AT_PHNUM]; n; n--,p+=aux[AT_PHENT]) {
  417544:	4c 01 d8             	add    rax,r11
  417547:	48 83 ea 01          	sub    rdx,0x1
  41754b:	75 e9                	jne    417536 <__init_tls+0x66>
  41754d:	45 84 d2             	test   r10b,r10b
  417550:	74 07                	je     417559 <__init_tls+0x89>
  417552:	44 89 05 5b 4b 1a 00 	mov    DWORD PTR [rip+0x1a4b5b],r8d        # 5bc0b4 <__default_stacksize>
			__default_stacksize =
				phdr->p_memsz < DEFAULT_STACK_MAX ?
				phdr->p_memsz : DEFAULT_STACK_MAX;
	}

	if (tls_phdr) {
  417559:	48 85 db             	test   rbx,rbx
  41755c:	0f 84 be 02 00 00    	je     417820 <__init_tls+0x350>
		main_tls.image = (void *)(base + tls_phdr->p_vaddr);
		main_tls.len = tls_phdr->p_filesz;
		main_tls.size = tls_phdr->p_memsz;
		main_tls.align = tls_phdr->p_align;
  417562:	48 8b 73 30          	mov    rsi,QWORD PTR [rbx+0x30]
		main_tls.image = (void *)(base + tls_phdr->p_vaddr);
  417566:	48 03 4b 10          	add    rcx,QWORD PTR [rbx+0x10]
		libc.tls_cnt = 1;
		libc.tls_head = &main_tls;
  41756a:	48 8d 05 4f fa 2f 00 	lea    rax,[rip+0x2ffa4f]        # 716fc0 <main_tls>
		main_tls.len = tls_phdr->p_filesz;
  417571:	f3 0f 6f 7b 20       	movdqu xmm7,XMMWORD PTR [rbx+0x20]
		main_tls.size = tls_phdr->p_memsz;
  417576:	48 8b 53 28          	mov    rdx,QWORD PTR [rbx+0x28]
		main_tls.image = (void *)(base + tls_phdr->p_vaddr);
  41757a:	48 89 0d 47 fa 2f 00 	mov    QWORD PTR [rip+0x2ffa47],rcx        # 716fc8 <main_tls+0x8>
		main_tls.align = tls_phdr->p_align;
  417581:	48 89 35 58 fa 2f 00 	mov    QWORD PTR [rip+0x2ffa58],rsi        # 716fe0 <main_tls+0x20>
		libc.tls_cnt = 1;
  417588:	48 c7 05 dd f9 2f 00 	mov    QWORD PTR [rip+0x2ff9dd],0x1        # 716f70 <__libc+0x30>
  41758f:	01 00 00 00 
		libc.tls_head = &main_tls;
  417593:	48 89 05 be f9 2f 00 	mov    QWORD PTR [rip+0x2ff9be],rax        # 716f58 <__libc+0x18>
		main_tls.len = tls_phdr->p_filesz;
  41759a:	0f 29 3d 2f fa 2f 00 	movaps XMMWORD PTR [rip+0x2ffa2f],xmm7        # 716fd0 <main_tls+0x10>
	}

	main_tls.size += (-main_tls.size - (uintptr_t)main_tls.image)
  4175a1:	48 01 d1             	add    rcx,rdx
		& (main_tls.align-1);
  4175a4:	48 8d 46 ff          	lea    rax,[rsi-0x1]
	main_tls.size += (-main_tls.size - (uintptr_t)main_tls.image)
  4175a8:	48 f7 d9             	neg    rcx
		& (main_tls.align-1);
  4175ab:	48 21 c1             	and    rcx,rax
	main_tls.size += (-main_tls.size - (uintptr_t)main_tls.image)
  4175ae:	48 01 ca             	add    rdx,rcx
  4175b1:	48 8d 8e f7 00 00 00 	lea    rcx,[rsi+0xf7]
  4175b8:	48 89 15 19 fa 2f 00 	mov    QWORD PTR [rip+0x2ffa19],rdx        # 716fd8 <main_tls+0x18>
#ifdef TLS_ABOVE_TP
	main_tls.offset = GAP_ABOVE_TP;
	main_tls.offset += (-GAP_ABOVE_TP + (uintptr_t)main_tls.image)
		& (main_tls.align-1);
#else
	main_tls.offset = main_tls.size;
  4175bf:	48 89 15 22 fa 2f 00 	mov    QWORD PTR [rip+0x2ffa22],rdx        # 716fe8 <main_tls+0x28>
#endif
	if (main_tls.align < MIN_TLS_ALIGN) main_tls.align = MIN_TLS_ALIGN;
  4175c6:	48 83 fe 07          	cmp    rsi,0x7
  4175ca:	77 1a                	ja     4175e6 <__init_tls+0x116>
  4175cc:	b8 07 00 00 00       	mov    eax,0x7
  4175d1:	b9 ff 00 00 00       	mov    ecx,0xff
  4175d6:	be 08 00 00 00       	mov    esi,0x8
  4175db:	48 c7 05 fa f9 2f 00 	mov    QWORD PTR [rip+0x2ff9fa],0x8        # 716fe0 <main_tls+0x20>
  4175e2:	08 00 00 00 
	libc.tls_size = 2*sizeof(void *) + sizeof(struct pthread)
#ifdef TLS_ABOVE_TP
		+ main_tls.offset
#endif
		+ main_tls.size + main_tls.align
		+ MIN_TLS_ALIGN-1 & -MIN_TLS_ALIGN;
  4175e6:	48 01 ca             	add    rdx,rcx
	libc.tls_size = 2*sizeof(void *) + sizeof(struct pthread)
  4175e9:	66 48 0f 6e de       	movq   xmm3,rsi
			MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);
		/* -4095...-1 cast to void * will crash on dereference anyway,
		 * so don't bloat the init code checking for error codes and
		 * explicitly calling a_crash(). */
	} else {
		mem = builtin_tls;
  4175ee:	4c 8d 2d 0b fa 2f 00 	lea    r13,[rip+0x2ffa0b]        # 717000 <builtin_tls>
		+ MIN_TLS_ALIGN-1 & -MIN_TLS_ALIGN;
  4175f5:	48 83 e2 f8          	and    rdx,0xfffffffffffffff8
	libc.tls_size = 2*sizeof(void *) + sizeof(struct pthread)
  4175f9:	66 48 0f 6e c2       	movq   xmm0,rdx
  4175fe:	66 0f 6c c3          	punpcklqdq xmm0,xmm3
  417602:	0f 11 05 57 f9 2f 00 	movups XMMWORD PTR [rip+0x2ff957],xmm0        # 716f60 <__libc+0x20>
	if (libc.tls_size > sizeof builtin_tls) {
  417609:	48 81 fa 68 01 00 00 	cmp    rdx,0x168
  417610:	0f 87 ca 01 00 00    	ja     4177e0 <__init_tls+0x310>
	mem += libc.tls_size - sizeof(struct pthread);
  417616:	66 49 0f 6e e5       	movq   xmm4,r13
  41761b:	49 8d ac 15 20 ff ff 	lea    rbp,[r13+rdx*1-0xe0]
  417622:	ff 
	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
  417623:	48 8b 1d 2e f9 2f 00 	mov    rbx,QWORD PTR [rip+0x2ff92e]        # 716f58 <__libc+0x18>
  41762a:	4d 8d 65 08          	lea    r12,[r13+0x8]
	mem -= (uintptr_t)mem & (libc.tls_align-1);
  41762e:	48 21 e8             	and    rax,rbp
  417631:	48 29 c5             	sub    rbp,rax
  417634:	66 48 0f 6e cd       	movq   xmm1,rbp
  417639:	66 48 0f 6e d5       	movq   xmm2,rbp
  41763e:	66 0f 6c c9          	punpcklqdq xmm1,xmm1
  417642:	66 0f 6c d4          	punpcklqdq xmm2,xmm4
  417646:	0f 29 4c 24 10       	movaps XMMWORD PTR [rsp+0x10],xmm1
  41764b:	0f 29 14 24          	movaps XMMWORD PTR [rsp],xmm2
	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
  41764f:	48 85 db             	test   rbx,rbx
  417652:	74 2f                	je     417683 <__init_tls+0x1b3>
  417654:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		dtv[i] = (uintptr_t)(mem - p->offset) + DTP_OFFSET;
  417658:	48 89 e8             	mov    rax,rbp
  41765b:	48 2b 43 28          	sub    rax,QWORD PTR [rbx+0x28]
		memcpy(mem - p->offset, p->image, p->len);
  41765f:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
  417663:	48 89 ef             	mov    rdi,rbp
		dtv[i] = (uintptr_t)(mem - p->offset) + DTP_OFFSET;
  417666:	49 89 04 24          	mov    QWORD PTR [r12],rax
		memcpy(mem - p->offset, p->image, p->len);
  41766a:	48 8b 53 10          	mov    rdx,QWORD PTR [rbx+0x10]
	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
  41766e:	49 83 c4 08          	add    r12,0x8
		memcpy(mem - p->offset, p->image, p->len);
  417672:	48 2b 7b 28          	sub    rdi,QWORD PTR [rbx+0x28]
  417676:	e8 af f1 ff ff       	call   41682a <memcpy>
	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
  41767b:	48 8b 1b             	mov    rbx,QWORD PTR [rbx]
  41767e:	48 85 db             	test   rbx,rbx
  417681:	75 d5                	jne    417658 <__init_tls+0x188>
	dtv[0] = libc.tls_cnt;
  417683:	48 8b 05 e6 f8 2f 00 	mov    rax,QWORD PTR [rip+0x2ff8e6]        # 716f70 <__libc+0x30>
	td->self = td;
  41768a:	66 0f 6f 2c 24       	movdqa xmm5,XMMWORD PTR [rsp]
	int r = __set_thread_area(TP_ADJ(p));
  41768f:	48 89 ef             	mov    rdi,rbp
	dtv[0] = libc.tls_cnt;
  417692:	49 89 45 00          	mov    QWORD PTR [r13+0x0],rax
	td->dtv = td->dtv_copy = dtv;
  417696:	4c 89 ad d8 00 00 00 	mov    QWORD PTR [rbp+0xd8],r13
	td->self = td;
  41769d:	0f 11 6d 00          	movups XMMWORD PTR [rbp+0x0],xmm5
	int r = __set_thread_area(TP_ADJ(p));
  4176a1:	e8 7a f2 ff ff       	call   416920 <__set_thread_area>
	if (r < 0) return -1;
  4176a6:	85 c0                	test   eax,eax
  4176a8:	0f 88 21 01 00 00    	js     4177cf <__init_tls+0x2ff>
	if (!r) libc.can_do_threads = 1;
  4176ae:	0f 84 0c 01 00 00    	je     4177c0 <__init_tls+0x2f0>
	td->detach_state = DT_JOINABLE;
  4176b4:	c7 45 40 01 00 00 00 	mov    DWORD PTR [rbp+0x40],0x1
  4176bb:	31 d2                	xor    edx,edx
  4176bd:	45 31 c9             	xor    r9d,r9d
  4176c0:	45 31 c0             	xor    r8d,r8d
  4176c3:	6a 00                	push   0x0
  4176c5:	31 c9                	xor    ecx,ecx
  4176c7:	48 8d 35 9a fa 2f 00 	lea    rsi,[rip+0x2ffa9a]        # 717168 <__thread_list_lock>
  4176ce:	bf da 00 00 00       	mov    edi,0xda
  4176d3:	6a 00                	push   0x0
  4176d5:	e8 b6 37 ff ff       	call   40ae90 <__cos_syscall>
	td->next = td->prev = td;
  4176da:	66 0f 6f 74 24 20    	movdqa xmm6,XMMWORD PTR [rsp+0x20]
	td->tid = __syscall(SYS_set_tid_address, &__thread_list_lock);
  4176e0:	89 45 38             	mov    DWORD PTR [rbp+0x38],eax
	td->locale = &libc.global_locale;
  4176e3:	48 8d 05 96 f8 2f 00 	lea    rax,[rip+0x2ff896]        # 716f80 <__libc+0x40>
  4176ea:	48 89 85 b0 00 00 00 	mov    QWORD PTR [rbp+0xb0],rax
	td->robust_list.head = &td->robust_list.head;
  4176f1:	48 8d 85 90 00 00 00 	lea    rax,[rbp+0x90]
  4176f8:	48 89 85 90 00 00 00 	mov    QWORD PTR [rbp+0x90],rax
	td->sysinfo = __sysinfo;
  4176ff:	48 8b 05 1a f8 2f 00 	mov    rax,QWORD PTR [rip+0x2ff81a]        # 716f20 <__sysinfo>
	td->next = td->prev = td;
  417706:	0f 11 75 10          	movups XMMWORD PTR [rbp+0x10],xmm6
	td->sysinfo = __sysinfo;
  41770a:	48 89 45 20          	mov    QWORD PTR [rbp+0x20],rax
	td->next = td->prev = td;
  41770e:	58                   	pop    rax
  41770f:	5a                   	pop    rdx
	}

	/* Failure to initialize thread pointer is always fatal. */
	if (__init_tp(__copy_tls(mem)) < 0)
		a_crash();
}
  417710:	48 83 c4 28          	add    rsp,0x28
  417714:	5b                   	pop    rbx
  417715:	5d                   	pop    rbp
  417716:	41 5c                	pop    r12
  417718:	41 5d                	pop    r13
  41771a:	c3                   	ret    
  41771b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		if (phdr->p_type == PT_DYNAMIC && _DYNAMIC)
  417720:	83 fe 02             	cmp    esi,0x2
  417723:	74 08                	je     41772d <__init_tls+0x25d>
		if (phdr->p_type == PT_TLS)
  417725:	83 fe 07             	cmp    esi,0x7
  417728:	75 62                	jne    41778c <__init_tls+0x2bc>
  41772a:	48 89 c3             	mov    rbx,rax
	for (p=(void *)aux[AT_PHDR],n=aux[AT_PHNUM]; n; n--,p+=aux[AT_PHENT]) {
  41772d:	4c 01 d8             	add    rax,r11
  417730:	48 83 ea 01          	sub    rdx,0x1
  417734:	0f 84 13 fe ff ff    	je     41754d <__init_tls+0x7d>
		if (phdr->p_type == PT_PHDR)
  41773a:	8b 30                	mov    esi,DWORD PTR [rax]
  41773c:	83 fe 06             	cmp    esi,0x6
  41773f:	75 df                	jne    417720 <__init_tls+0x250>
			base = aux[AT_PHDR] - phdr->p_vaddr;
  417741:	48 89 e9             	mov    rcx,rbp
  417744:	48 2b 48 10          	sub    rcx,QWORD PTR [rax+0x10]
		if (phdr->p_type == PT_GNU_STACK &&
  417748:	eb e3                	jmp    41772d <__init_tls+0x25d>
  41774a:	81 fe 51 e5 74 64    	cmp    esi,0x6474e551
  417750:	0f 85 d7 fd ff ff    	jne    41752d <__init_tls+0x5d>
		    phdr->p_memsz > __default_stacksize)
  417756:	48 8b 70 28          	mov    rsi,QWORD PTR [rax+0x28]
  41775a:	44 89 c7             	mov    edi,r8d
		if (phdr->p_type == PT_GNU_STACK &&
  41775d:	48 39 fe             	cmp    rsi,rdi
  417760:	0f 86 c7 fd ff ff    	jbe    41752d <__init_tls+0x5d>
			__default_stacksize =
  417766:	41 b8 00 00 80 00    	mov    r8d,0x800000
  41776c:	41 ba 01 00 00 00    	mov    r10d,0x1
  417772:	4c 39 c6             	cmp    rsi,r8
  417775:	4c 0f 46 c6          	cmovbe r8,rsi
  417779:	e9 af fd ff ff       	jmp    41752d <__init_tls+0x5d>
  41777e:	66 90                	xchg   ax,ax
			base = (size_t)_DYNAMIC - phdr->p_vaddr;
  417780:	4c 89 c9             	mov    rcx,r9
  417783:	48 2b 48 10          	sub    rcx,QWORD PTR [rax+0x10]
		if (phdr->p_type == PT_GNU_STACK &&
  417787:	e9 a1 fd ff ff       	jmp    41752d <__init_tls+0x5d>
  41778c:	81 fe 51 e5 74 64    	cmp    esi,0x6474e551
  417792:	75 99                	jne    41772d <__init_tls+0x25d>
		    phdr->p_memsz > __default_stacksize)
  417794:	48 8b 70 28          	mov    rsi,QWORD PTR [rax+0x28]
  417798:	44 89 c7             	mov    edi,r8d
		if (phdr->p_type == PT_GNU_STACK &&
  41779b:	48 39 f7             	cmp    rdi,rsi
  41779e:	73 8d                	jae    41772d <__init_tls+0x25d>
			__default_stacksize =
  4177a0:	41 b8 00 00 80 00    	mov    r8d,0x800000
  4177a6:	41 ba 01 00 00 00    	mov    r10d,0x1
  4177ac:	4c 39 c6             	cmp    rsi,r8
  4177af:	4c 0f 46 c6          	cmovbe r8,rsi
  4177b3:	e9 75 ff ff ff       	jmp    41772d <__init_tls+0x25d>
  4177b8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4177bf:	00 
	if (!r) libc.can_do_threads = 1;
  4177c0:	c7 05 76 f7 2f 00 01 	mov    DWORD PTR [rip+0x2ff776],0x1        # 716f40 <__libc>
  4177c7:	00 00 00 
  4177ca:	e9 e5 fe ff ff       	jmp    4176b4 <__init_tls+0x1e4>
  4177cf:	f4                   	hlt    
}
  4177d0:	48 83 c4 28          	add    rsp,0x28
  4177d4:	5b                   	pop    rbx
  4177d5:	5d                   	pop    rbp
  4177d6:	41 5c                	pop    r12
  4177d8:	41 5d                	pop    r13
  4177da:	c3                   	ret    
  4177db:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	return __cos_syscall(n, a1, a2, a3, a4, a5, 0, 0);
}

static __inline long __syscall6(long n, long a1, long a2, long a3, long a4, long a5, long a6)
{
	return __cos_syscall(n, a1, a2, a3, a4, a5, a6, 0);
  4177e0:	6a 00                	push   0x0
  4177e2:	b9 03 00 00 00       	mov    ecx,0x3
  4177e7:	31 f6                	xor    esi,esi
  4177e9:	49 c7 c1 ff ff ff ff 	mov    r9,0xffffffffffffffff
  4177f0:	6a 00                	push   0x0
  4177f2:	41 b8 22 00 00 00    	mov    r8d,0x22
  4177f8:	bf 09 00 00 00       	mov    edi,0x9
  4177fd:	e8 8e 36 ff ff       	call   40ae90 <__cos_syscall>
  417802:	59                   	pop    rcx
	mem += libc.tls_size - sizeof(struct pthread);
  417803:	48 8b 15 56 f7 2f 00 	mov    rdx,QWORD PTR [rip+0x2ff756]        # 716f60 <__libc+0x20>
  41780a:	49 89 c5             	mov    r13,rax
	mem -= (uintptr_t)mem & (libc.tls_align-1);
  41780d:	48 8b 05 54 f7 2f 00 	mov    rax,QWORD PTR [rip+0x2ff754]        # 716f68 <__libc+0x28>
  417814:	5e                   	pop    rsi
  417815:	48 83 e8 01          	sub    rax,0x1
  417819:	e9 f8 fd ff ff       	jmp    417616 <__init_tls+0x146>
  41781e:	66 90                	xchg   ax,ax
	main_tls.size += (-main_tls.size - (uintptr_t)main_tls.image)
  417820:	48 8b 15 b1 f7 2f 00 	mov    rdx,QWORD PTR [rip+0x2ff7b1]        # 716fd8 <main_tls+0x18>
  417827:	48 8b 0d 9a f7 2f 00 	mov    rcx,QWORD PTR [rip+0x2ff79a]        # 716fc8 <main_tls+0x8>
		& (main_tls.align-1);
  41782e:	48 8b 35 ab f7 2f 00 	mov    rsi,QWORD PTR [rip+0x2ff7ab]        # 716fe0 <main_tls+0x20>
  417835:	e9 67 fd ff ff       	jmp    4175a1 <__init_tls+0xd1>
  41783a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000417840 <__errno_location>:
#include <errno.h>
#include "pthread_impl.h"

int *__errno_location(void)
{
  417840:	f3 0f 1e fa          	endbr64 
	static int e;
	return &e;
  417844:	48 8d 05 21 f9 2f 00 	lea    rax,[rip+0x2ff921]        # 71716c <e.0>
}
  41784b:	c3                   	ret    
  41784c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000417850 <_Exit>:
#include <stdlib.h>
#include "syscall.h"

_Noreturn void _Exit(int ec)
{
  417850:	f3 0f 1e fa          	endbr64 
  417854:	53                   	push   rbx
	__syscall(SYS_exit_group, ec);
  417855:	48 63 df             	movsxd rbx,edi
	return __cos_syscall(n, a1, 0, 0, 0, 0, 0, 0);
  417858:	31 c9                	xor    ecx,ecx
  41785a:	45 31 c9             	xor    r9d,r9d
  41785d:	6a 00                	push   0x0
  41785f:	48 89 de             	mov    rsi,rbx
  417862:	45 31 c0             	xor    r8d,r8d
  417865:	31 d2                	xor    edx,edx
  417867:	6a 00                	push   0x0
  417869:	bf e7 00 00 00       	mov    edi,0xe7
  41786e:	e8 1d 36 ff ff       	call   40ae90 <__cos_syscall>
  417873:	59                   	pop    rcx
  417874:	5e                   	pop    rsi
  417875:	0f 1f 00             	nop    DWORD PTR [rax]
  417878:	6a 00                	push   0x0
  41787a:	31 d2                	xor    edx,edx
  41787c:	45 31 c9             	xor    r9d,r9d
  41787f:	45 31 c0             	xor    r8d,r8d
  417882:	6a 00                	push   0x0
  417884:	31 c9                	xor    ecx,ecx
  417886:	48 89 de             	mov    rsi,rbx
  417889:	bf 3c 00 00 00       	mov    edi,0x3c
  41788e:	e8 fd 35 ff ff       	call   40ae90 <__cos_syscall>
  417893:	58                   	pop    rax
  417894:	5a                   	pop    rdx
  417895:	eb e1                	jmp    417878 <_Exit+0x28>
  417897:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41789e:	00 00 

00000000004178a0 <pop_arg>:
	void *p;
};

static void pop_arg(union arg *arg, int type, va_list *ap)
{
	switch (type) {
  4178a0:	83 ee 09             	sub    esi,0x9
{
  4178a3:	48 89 d0             	mov    rax,rdx
	switch (type) {
  4178a6:	83 fe 11             	cmp    esi,0x11
  4178a9:	77 4d                	ja     4178f8 <pop_arg+0x58>
  4178ab:	48 8d 0d 9e 82 00 00 	lea    rcx,[rip+0x829e]        # 41fb50 <CSWTCH.187+0x760>
  4178b2:	48 63 14 b1          	movsxd rdx,DWORD PTR [rcx+rsi*4]
  4178b6:	48 01 ca             	add    rdx,rcx
  4178b9:	3e ff e2             	notrack jmp rdx
  4178bc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	break; case LLONG:	arg->i = va_arg(*ap, long long);
	break; case SIZET:	arg->i = va_arg(*ap, size_t);
	break; case IMAX:	arg->i = va_arg(*ap, intmax_t);
	break; case UMAX:	arg->i = va_arg(*ap, uintmax_t);
	break; case PDIFF:	arg->i = va_arg(*ap, ptrdiff_t);
	break; case UIPTR:	arg->i = (uintptr_t)va_arg(*ap, void *);
  4178c0:	8b 10                	mov    edx,DWORD PTR [rax]
  4178c2:	83 fa 2f             	cmp    edx,0x2f
  4178c5:	77 39                	ja     417900 <pop_arg+0x60>
  4178c7:	89 d1                	mov    ecx,edx
  4178c9:	83 c2 08             	add    edx,0x8
  4178cc:	48 03 48 10          	add    rcx,QWORD PTR [rax+0x10]
  4178d0:	89 10                	mov    DWORD PTR [rax],edx
  4178d2:	48 8b 01             	mov    rax,QWORD PTR [rcx]
  4178d5:	48 89 07             	mov    QWORD PTR [rdi],rax
	break; case DBL:	arg->f = va_arg(*ap, double);
  4178d8:	c3                   	ret    
  4178d9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	break; case LDBL:	arg->f = va_arg(*ap, long double);
  4178e0:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  4178e4:	48 8d 51 0f          	lea    rdx,[rcx+0xf]
  4178e8:	48 83 e2 f0          	and    rdx,0xfffffffffffffff0
  4178ec:	48 8d 4a 10          	lea    rcx,[rdx+0x10]
  4178f0:	48 89 48 08          	mov    QWORD PTR [rax+0x8],rcx
  4178f4:	db 2a                	fld    TBYTE PTR [rdx]
  4178f6:	db 3f                	fstp   TBYTE PTR [rdi]
	}
}
  4178f8:	c3                   	ret    
  4178f9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	break; case UIPTR:	arg->i = (uintptr_t)va_arg(*ap, void *);
  417900:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  417904:	48 8d 51 08          	lea    rdx,[rcx+0x8]
  417908:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  41790c:	48 8b 01             	mov    rax,QWORD PTR [rcx]
  41790f:	48 89 07             	mov    QWORD PTR [rdi],rax
	break; case DBL:	arg->f = va_arg(*ap, double);
  417912:	c3                   	ret    
  417913:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	break; case USHORT:	arg->i = (unsigned short)va_arg(*ap, int);
  417918:	8b 10                	mov    edx,DWORD PTR [rax]
  41791a:	83 fa 2f             	cmp    edx,0x2f
  41791d:	0f 87 55 01 00 00    	ja     417a78 <pop_arg+0x1d8>
  417923:	89 d1                	mov    ecx,edx
  417925:	83 c2 08             	add    edx,0x8
  417928:	48 03 48 10          	add    rcx,QWORD PTR [rax+0x10]
  41792c:	89 10                	mov    DWORD PTR [rax],edx
  41792e:	0f b7 01             	movzx  eax,WORD PTR [rcx]
  417931:	48 89 07             	mov    QWORD PTR [rdi],rax
	break; case CHAR:	arg->i = (signed char)va_arg(*ap, int);
  417934:	c3                   	ret    
  417935:	0f 1f 00             	nop    DWORD PTR [rax]
	break; case DBL:	arg->f = va_arg(*ap, double);
  417938:	8b 50 04             	mov    edx,DWORD PTR [rax+0x4]
  41793b:	81 fa af 00 00 00    	cmp    edx,0xaf
  417941:	0f 87 19 01 00 00    	ja     417a60 <pop_arg+0x1c0>
  417947:	89 d1                	mov    ecx,edx
  417949:	83 c2 10             	add    edx,0x10
  41794c:	48 03 48 10          	add    rcx,QWORD PTR [rax+0x10]
  417950:	89 50 04             	mov    DWORD PTR [rax+0x4],edx
  417953:	dd 01                	fld    QWORD PTR [rcx]
  417955:	db 3f                	fstp   TBYTE PTR [rdi]
	break; case LDBL:	arg->f = va_arg(*ap, long double);
  417957:	c3                   	ret    
  417958:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41795f:	00 
	break; case INT:	arg->i = va_arg(*ap, int);
  417960:	8b 10                	mov    edx,DWORD PTR [rax]
  417962:	83 fa 2f             	cmp    edx,0x2f
  417965:	0f 87 dd 00 00 00    	ja     417a48 <pop_arg+0x1a8>
  41796b:	89 d1                	mov    ecx,edx
  41796d:	83 c2 08             	add    edx,0x8
  417970:	48 03 48 10          	add    rcx,QWORD PTR [rax+0x10]
  417974:	89 10                	mov    DWORD PTR [rax],edx
  417976:	48 63 01             	movsxd rax,DWORD PTR [rcx]
  417979:	48 89 07             	mov    QWORD PTR [rdi],rax
	break; case UINT:	arg->i = va_arg(*ap, unsigned int);
  41797c:	c3                   	ret    
  41797d:	0f 1f 00             	nop    DWORD PTR [rax]
  417980:	8b 10                	mov    edx,DWORD PTR [rax]
  417982:	83 fa 2f             	cmp    edx,0x2f
  417985:	0f 87 a5 00 00 00    	ja     417a30 <pop_arg+0x190>
  41798b:	89 d1                	mov    ecx,edx
  41798d:	83 c2 08             	add    edx,0x8
  417990:	48 03 48 10          	add    rcx,QWORD PTR [rax+0x10]
  417994:	89 10                	mov    DWORD PTR [rax],edx
  417996:	8b 01                	mov    eax,DWORD PTR [rcx]
  417998:	48 89 07             	mov    QWORD PTR [rdi],rax
	break; case LONG:	arg->i = va_arg(*ap, long);
  41799b:	c3                   	ret    
  41799c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	break; case UCHAR:	arg->i = (unsigned char)va_arg(*ap, int);
  4179a0:	8b 10                	mov    edx,DWORD PTR [rax]
  4179a2:	83 fa 2f             	cmp    edx,0x2f
  4179a5:	77 79                	ja     417a20 <pop_arg+0x180>
  4179a7:	89 d1                	mov    ecx,edx
  4179a9:	83 c2 08             	add    edx,0x8
  4179ac:	48 03 48 10          	add    rcx,QWORD PTR [rax+0x10]
  4179b0:	89 10                	mov    DWORD PTR [rax],edx
  4179b2:	0f b6 01             	movzx  eax,BYTE PTR [rcx]
  4179b5:	48 89 07             	mov    QWORD PTR [rdi],rax
	break; case LLONG:	arg->i = va_arg(*ap, long long);
  4179b8:	c3                   	ret    
  4179b9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	break; case CHAR:	arg->i = (signed char)va_arg(*ap, int);
  4179c0:	8b 10                	mov    edx,DWORD PTR [rax]
  4179c2:	83 fa 2f             	cmp    edx,0x2f
  4179c5:	77 49                	ja     417a10 <pop_arg+0x170>
  4179c7:	89 d1                	mov    ecx,edx
  4179c9:	83 c2 08             	add    edx,0x8
  4179cc:	48 03 48 10          	add    rcx,QWORD PTR [rax+0x10]
  4179d0:	89 10                	mov    DWORD PTR [rax],edx
  4179d2:	48 0f be 01          	movsx  rax,BYTE PTR [rcx]
  4179d6:	48 89 07             	mov    QWORD PTR [rdi],rax
	break; case UCHAR:	arg->i = (unsigned char)va_arg(*ap, int);
  4179d9:	c3                   	ret    
  4179da:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	break; case SHORT:	arg->i = (short)va_arg(*ap, int);
  4179e0:	8b 10                	mov    edx,DWORD PTR [rax]
  4179e2:	83 fa 2f             	cmp    edx,0x2f
  4179e5:	77 19                	ja     417a00 <pop_arg+0x160>
  4179e7:	89 d1                	mov    ecx,edx
  4179e9:	83 c2 08             	add    edx,0x8
  4179ec:	48 03 48 10          	add    rcx,QWORD PTR [rax+0x10]
  4179f0:	89 10                	mov    DWORD PTR [rax],edx
  4179f2:	48 0f bf 01          	movsx  rax,WORD PTR [rcx]
  4179f6:	48 89 07             	mov    QWORD PTR [rdi],rax
	break; case USHORT:	arg->i = (unsigned short)va_arg(*ap, int);
  4179f9:	c3                   	ret    
  4179fa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	break; case SHORT:	arg->i = (short)va_arg(*ap, int);
  417a00:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  417a04:	48 8d 51 08          	lea    rdx,[rcx+0x8]
  417a08:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  417a0c:	eb e4                	jmp    4179f2 <pop_arg+0x152>
  417a0e:	66 90                	xchg   ax,ax
	break; case CHAR:	arg->i = (signed char)va_arg(*ap, int);
  417a10:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  417a14:	48 8d 51 08          	lea    rdx,[rcx+0x8]
  417a18:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  417a1c:	eb b4                	jmp    4179d2 <pop_arg+0x132>
  417a1e:	66 90                	xchg   ax,ax
	break; case UCHAR:	arg->i = (unsigned char)va_arg(*ap, int);
  417a20:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  417a24:	48 8d 51 08          	lea    rdx,[rcx+0x8]
  417a28:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  417a2c:	eb 84                	jmp    4179b2 <pop_arg+0x112>
  417a2e:	66 90                	xchg   ax,ax
	break; case UINT:	arg->i = va_arg(*ap, unsigned int);
  417a30:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  417a34:	48 8d 51 08          	lea    rdx,[rcx+0x8]
  417a38:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  417a3c:	e9 55 ff ff ff       	jmp    417996 <pop_arg+0xf6>
  417a41:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	break; case INT:	arg->i = va_arg(*ap, int);
  417a48:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  417a4c:	48 8d 51 08          	lea    rdx,[rcx+0x8]
  417a50:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  417a54:	e9 1d ff ff ff       	jmp    417976 <pop_arg+0xd6>
  417a59:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	break; case DBL:	arg->f = va_arg(*ap, double);
  417a60:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  417a64:	48 8d 51 08          	lea    rdx,[rcx+0x8]
  417a68:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  417a6c:	e9 e2 fe ff ff       	jmp    417953 <pop_arg+0xb3>
  417a71:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	break; case USHORT:	arg->i = (unsigned short)va_arg(*ap, int);
  417a78:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  417a7c:	48 8d 51 08          	lea    rdx,[rcx+0x8]
  417a80:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  417a84:	e9 a5 fe ff ff       	jmp    41792e <pop_arg+0x8e>

0000000000417a89 <fmt_fp.cold>:
  417a89:	44 8d 83 00 ff ff ff 	lea    r8d,[rbx-0x100]
  417a90:	66 0f 6e eb          	movd   xmm5,ebx
{
	char pad[256];
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
	l = w - l;
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
	for (; l >= sizeof pad; l -= sizeof pad)
  417a94:	31 c9                	xor    ecx,ecx
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417a96:	41 89 d1             	mov    r9d,edx
  417a99:	44 89 c0             	mov    eax,r8d
  417a9c:	66 0f 70 dd 00       	pshufd xmm3,xmm5,0x0
  417aa1:	66 0f 6f 15 c7 84 00 	movdqa xmm2,XMMWORD PTR [rip+0x84c7]        # 41ff70 <states+0x290>
  417aa8:	00 
  417aa9:	66 0f fe 1d af 84 00 	paddd  xmm3,XMMWORD PTR [rip+0x84af]        # 41ff60 <states+0x280>
  417ab0:	00 
  417ab1:	c1 e8 08             	shr    eax,0x8
  417ab4:	66 0f 6f 0d c4 84 00 	movdqa xmm1,XMMWORD PTR [rip+0x84c4]        # 41ff80 <states+0x2a0>
  417abb:	00 
  417abc:	83 c0 01             	add    eax,0x1
  417abf:	89 c6                	mov    esi,eax
  417ac1:	c1 ee 02             	shr    esi,0x2
  417ac4:	66 0f 6f c3          	movdqa xmm0,xmm3
  417ac8:	83 c1 01             	add    ecx,0x1
  417acb:	66 0f fe da          	paddd  xmm3,xmm2
  417acf:	44 89 ca             	mov    edx,r9d
	for (; l >= sizeof pad; l -= sizeof pad)
  417ad2:	66 0f fe c1          	paddd  xmm0,xmm1
  417ad6:	39 f1                	cmp    ecx,esi
  417ad8:	72 ea                	jb     417ac4 <fmt_fp.cold+0x3b>
  417ada:	41 89 c1             	mov    r9d,eax
  417add:	66 0f 70 c0 ff       	pshufd xmm0,xmm0,0xff
  417ae2:	41 83 e1 fc          	and    r9d,0xfffffffc
  417ae6:	66 0f 7e c1          	movd   ecx,xmm0
  417aea:	41 69 f1 00 ff ff ff 	imul   esi,r9d,0xffffff00
  417af1:	41 39 c1             	cmp    r9d,eax
  417af4:	0f 84 92 0d 00 00    	je     41888c <fmt_fp+0x86c>
  417afa:	42 8d 04 06          	lea    eax,[rsi+r8*1]
  417afe:	89 c1                	mov    ecx,eax
  417b00:	3d ff 00 00 00       	cmp    eax,0xff
  417b05:	0f 86 81 0d 00 00    	jbe    41888c <fmt_fp+0x86c>
  417b0b:	81 e9 00 01 00 00    	sub    ecx,0x100
  417b11:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  417b17:	0f 86 6f 0d 00 00    	jbe    41888c <fmt_fp+0x86c>
  417b1d:	8d 88 00 fe ff ff    	lea    ecx,[rax-0x200]
  417b23:	e9 64 0d 00 00       	jmp    41888c <fmt_fp+0x86c>
  417b28:	8d b3 00 ff ff ff    	lea    esi,[rbx-0x100]
  417b2e:	66 0f 6e f3          	movd   xmm6,ebx
  417b32:	31 c9                	xor    ecx,ecx
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417b34:	41 89 d0             	mov    r8d,edx
  417b37:	89 f0                	mov    eax,esi
  417b39:	66 0f 70 de 00       	pshufd xmm3,xmm6,0x0
  417b3e:	66 0f 6f 15 2a 84 00 	movdqa xmm2,XMMWORD PTR [rip+0x842a]        # 41ff70 <states+0x290>
  417b45:	00 
  417b46:	66 0f fe 1d 12 84 00 	paddd  xmm3,XMMWORD PTR [rip+0x8412]        # 41ff60 <states+0x280>
  417b4d:	00 
  417b4e:	c1 e8 08             	shr    eax,0x8
  417b51:	66 0f 6f 0d 27 84 00 	movdqa xmm1,XMMWORD PTR [rip+0x8427]        # 41ff80 <states+0x2a0>
  417b58:	00 
  417b59:	83 c0 01             	add    eax,0x1
  417b5c:	41 89 c1             	mov    r9d,eax
  417b5f:	41 c1 e9 02          	shr    r9d,0x2
  417b63:	66 0f 6f c3          	movdqa xmm0,xmm3
  417b67:	83 c1 01             	add    ecx,0x1
  417b6a:	66 0f fe da          	paddd  xmm3,xmm2
  417b6e:	44 89 c2             	mov    edx,r8d
	for (; l >= sizeof pad; l -= sizeof pad)
  417b71:	66 0f fe c1          	paddd  xmm0,xmm1
  417b75:	41 39 c9             	cmp    r9d,ecx
  417b78:	77 e9                	ja     417b63 <fmt_fp.cold+0xda>
  417b7a:	41 89 c0             	mov    r8d,eax
  417b7d:	66 0f 70 c0 ff       	pshufd xmm0,xmm0,0xff
  417b82:	41 83 e0 fc          	and    r8d,0xfffffffc
  417b86:	66 0f 7e c5          	movd   ebp,xmm0
  417b8a:	41 69 c8 00 ff ff ff 	imul   ecx,r8d,0xffffff00
  417b91:	41 39 c0             	cmp    r8d,eax
  417b94:	0f 84 78 0d 00 00    	je     418912 <fmt_fp+0x8f2>
  417b9a:	8d 04 31             	lea    eax,[rcx+rsi*1]
  417b9d:	89 c5                	mov    ebp,eax
  417b9f:	3d ff 00 00 00       	cmp    eax,0xff
  417ba4:	0f 86 68 0d 00 00    	jbe    418912 <fmt_fp+0x8f2>
  417baa:	81 ed 00 01 00 00    	sub    ebp,0x100
  417bb0:	81 fd ff 00 00 00    	cmp    ebp,0xff
  417bb6:	0f 86 56 0d 00 00    	jbe    418912 <fmt_fp+0x8f2>
  417bbc:	8d a8 00 fe ff ff    	lea    ebp,[rax-0x200]
  417bc2:	e9 4b 0d 00 00       	jmp    418912 <fmt_fp+0x8f2>
  417bc7:	8d 8b 00 ff ff ff    	lea    ecx,[rbx-0x100]
  417bcd:	66 0f 6e fb          	movd   xmm7,ebx
  417bd1:	45 31 c0             	xor    r8d,r8d
  417bd4:	66 0f 6f 15 94 83 00 	movdqa xmm2,XMMWORD PTR [rip+0x8394]        # 41ff70 <states+0x290>
  417bdb:	00 
  417bdc:	89 ce                	mov    esi,ecx
  417bde:	66 0f 70 df 00       	pshufd xmm3,xmm7,0x0
  417be3:	66 0f 6f 0d 95 83 00 	movdqa xmm1,XMMWORD PTR [rip+0x8395]        # 41ff80 <states+0x2a0>
  417bea:	00 
  417beb:	66 0f fe 1d 6d 83 00 	paddd  xmm3,XMMWORD PTR [rip+0x836d]        # 41ff60 <states+0x280>
  417bf2:	00 
  417bf3:	c1 ee 08             	shr    esi,0x8
  417bf6:	83 c6 01             	add    esi,0x1
  417bf9:	41 89 f1             	mov    r9d,esi
  417bfc:	41 c1 e9 02          	shr    r9d,0x2
  417c00:	66 0f 6f c3          	movdqa xmm0,xmm3
  417c04:	41 83 c0 01          	add    r8d,0x1
  417c08:	66 0f fe da          	paddd  xmm3,xmm2
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417c0c:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  417c0e:	66 0f fe c1          	paddd  xmm0,xmm1
  417c12:	45 39 c8             	cmp    r8d,r9d
  417c15:	72 e9                	jb     417c00 <fmt_fp.cold+0x177>
  417c17:	89 f0                	mov    eax,esi
  417c19:	66 0f 70 c0 ff       	pshufd xmm0,xmm0,0xff
  417c1e:	83 e0 fc             	and    eax,0xfffffffc
  417c21:	66 0f 7e c5          	movd   ebp,xmm0
  417c25:	44 69 c0 00 ff ff ff 	imul   r8d,eax,0xffffff00
  417c2c:	39 c6                	cmp    esi,eax
  417c2e:	0f 84 99 0d 00 00    	je     4189cd <fmt_fp+0x9ad>
  417c34:	42 8d 04 01          	lea    eax,[rcx+r8*1]
  417c38:	89 c5                	mov    ebp,eax
  417c3a:	3d ff 00 00 00       	cmp    eax,0xff
  417c3f:	0f 86 88 0d 00 00    	jbe    4189cd <fmt_fp+0x9ad>
  417c45:	81 ed 00 01 00 00    	sub    ebp,0x100
  417c4b:	81 fd ff 00 00 00    	cmp    ebp,0xff
  417c51:	0f 86 76 0d 00 00    	jbe    4189cd <fmt_fp+0x9ad>
  417c57:	8d a8 00 fe ff ff    	lea    ebp,[rax-0x200]
  417c5d:	e9 6b 0d 00 00       	jmp    4189cd <fmt_fp+0x9ad>
  417c62:	8d bb 00 ff ff ff    	lea    edi,[rbx-0x100]
  417c68:	66 0f 6e fb          	movd   xmm7,ebx
  417c6c:	31 f6                	xor    esi,esi
  417c6e:	66 0f 6f 15 fa 82 00 	movdqa xmm2,XMMWORD PTR [rip+0x82fa]        # 41ff70 <states+0x290>
  417c75:	00 
  417c76:	89 f9                	mov    ecx,edi
  417c78:	66 0f 70 df 00       	pshufd xmm3,xmm7,0x0
  417c7d:	66 0f 6f 0d fb 82 00 	movdqa xmm1,XMMWORD PTR [rip+0x82fb]        # 41ff80 <states+0x2a0>
  417c84:	00 
  417c85:	66 0f fe 1d d3 82 00 	paddd  xmm3,XMMWORD PTR [rip+0x82d3]        # 41ff60 <states+0x280>
  417c8c:	00 
  417c8d:	c1 e9 08             	shr    ecx,0x8
  417c90:	83 c1 01             	add    ecx,0x1
  417c93:	41 89 c8             	mov    r8d,ecx
  417c96:	41 c1 e8 02          	shr    r8d,0x2
  417c9a:	66 0f 6f c3          	movdqa xmm0,xmm3
  417c9e:	83 c6 01             	add    esi,0x1
  417ca1:	66 0f fe da          	paddd  xmm3,xmm2
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417ca5:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  417ca7:	66 0f fe c1          	paddd  xmm0,xmm1
  417cab:	41 39 f0             	cmp    r8d,esi
  417cae:	77 ea                	ja     417c9a <fmt_fp.cold+0x211>
  417cb0:	89 ce                	mov    esi,ecx
  417cb2:	66 0f 70 c0 ff       	pshufd xmm0,xmm0,0xff
  417cb7:	83 e6 fc             	and    esi,0xfffffffc
  417cba:	66 0f 7e c5          	movd   ebp,xmm0
  417cbe:	69 c6 00 ff ff ff    	imul   eax,esi,0xffffff00
  417cc4:	39 ce                	cmp    esi,ecx
  417cc6:	0f 84 a2 15 00 00    	je     41926e <fmt_fp+0x124e>
  417ccc:	01 f8                	add    eax,edi
  417cce:	89 c5                	mov    ebp,eax
  417cd0:	3d ff 00 00 00       	cmp    eax,0xff
  417cd5:	0f 86 93 15 00 00    	jbe    41926e <fmt_fp+0x124e>
  417cdb:	81 ed 00 01 00 00    	sub    ebp,0x100
  417ce1:	81 fd ff 00 00 00    	cmp    ebp,0xff
  417ce7:	0f 86 81 15 00 00    	jbe    41926e <fmt_fp+0x124e>
  417ced:	8d a8 00 fe ff ff    	lea    ebp,[rax-0x200]
  417cf3:	e9 76 15 00 00       	jmp    41926e <fmt_fp+0x124e>
  417cf8:	8d 8b 00 ff ff ff    	lea    ecx,[rbx-0x100]
  417cfe:	66 0f 6e f3          	movd   xmm6,ebx
  417d02:	45 31 c0             	xor    r8d,r8d
  417d05:	66 0f 6f 15 63 82 00 	movdqa xmm2,XMMWORD PTR [rip+0x8263]        # 41ff70 <states+0x290>
  417d0c:	00 
  417d0d:	89 ce                	mov    esi,ecx
  417d0f:	66 0f 70 c6 00       	pshufd xmm0,xmm6,0x0
  417d14:	66 0f 6f 0d 64 82 00 	movdqa xmm1,XMMWORD PTR [rip+0x8264]        # 41ff80 <states+0x2a0>
  417d1b:	00 
  417d1c:	66 0f fe 05 3c 82 00 	paddd  xmm0,XMMWORD PTR [rip+0x823c]        # 41ff60 <states+0x280>
  417d23:	00 
  417d24:	c1 ee 08             	shr    esi,0x8
  417d27:	83 c6 01             	add    esi,0x1
  417d2a:	41 89 f1             	mov    r9d,esi
  417d2d:	41 c1 e9 02          	shr    r9d,0x2
  417d31:	66 0f 6f d8          	movdqa xmm3,xmm0
  417d35:	41 83 c0 01          	add    r8d,0x1
  417d39:	66 0f fe c2          	paddd  xmm0,xmm2
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417d3d:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  417d3f:	66 0f fe d9          	paddd  xmm3,xmm1
  417d43:	45 39 c8             	cmp    r8d,r9d
  417d46:	72 e9                	jb     417d31 <fmt_fp.cold+0x2a8>
  417d48:	89 f0                	mov    eax,esi
  417d4a:	66 0f 70 c3 ff       	pshufd xmm0,xmm3,0xff
  417d4f:	83 e0 fc             	and    eax,0xfffffffc
  417d52:	66 0f 7e c5          	movd   ebp,xmm0
  417d56:	44 69 c0 00 ff ff ff 	imul   r8d,eax,0xffffff00
  417d5d:	39 c6                	cmp    esi,eax
  417d5f:	0f 84 90 0e 00 00    	je     418bf5 <fmt_fp+0xbd5>
  417d65:	42 8d 04 01          	lea    eax,[rcx+r8*1]
  417d69:	89 c5                	mov    ebp,eax
  417d6b:	3d ff 00 00 00       	cmp    eax,0xff
  417d70:	0f 86 7f 0e 00 00    	jbe    418bf5 <fmt_fp+0xbd5>
  417d76:	81 ed 00 01 00 00    	sub    ebp,0x100
  417d7c:	81 fd ff 00 00 00    	cmp    ebp,0xff
  417d82:	0f 86 6d 0e 00 00    	jbe    418bf5 <fmt_fp+0xbd5>
  417d88:	8d a8 00 fe ff ff    	lea    ebp,[rax-0x200]
  417d8e:	e9 62 0e 00 00       	jmp    418bf5 <fmt_fp+0xbd5>
  417d93:	8d b1 00 ff ff ff    	lea    esi,[rcx-0x100]
  417d99:	66 0f 6e f9          	movd   xmm7,ecx
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417d9d:	41 89 d1             	mov    r9d,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  417da0:	31 c9                	xor    ecx,ecx
  417da2:	89 f0                	mov    eax,esi
  417da4:	66 0f 70 df 00       	pshufd xmm3,xmm7,0x0
  417da9:	66 0f 6f 15 bf 81 00 	movdqa xmm2,XMMWORD PTR [rip+0x81bf]        # 41ff70 <states+0x290>
  417db0:	00 
  417db1:	66 0f fe 1d a7 81 00 	paddd  xmm3,XMMWORD PTR [rip+0x81a7]        # 41ff60 <states+0x280>
  417db8:	00 
  417db9:	c1 e8 08             	shr    eax,0x8
  417dbc:	66 0f 6f 0d bc 81 00 	movdqa xmm1,XMMWORD PTR [rip+0x81bc]        # 41ff80 <states+0x2a0>
  417dc3:	00 
  417dc4:	83 c0 01             	add    eax,0x1
  417dc7:	41 89 c0             	mov    r8d,eax
  417dca:	41 c1 e8 02          	shr    r8d,0x2
  417dce:	66 0f 6f c3          	movdqa xmm0,xmm3
  417dd2:	83 c1 01             	add    ecx,0x1
  417dd5:	66 0f fe da          	paddd  xmm3,xmm2
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417dd9:	44 89 ca             	mov    edx,r9d
	for (; l >= sizeof pad; l -= sizeof pad)
  417ddc:	66 0f fe c1          	paddd  xmm0,xmm1
  417de0:	44 39 c1             	cmp    ecx,r8d
  417de3:	72 e9                	jb     417dce <fmt_fp.cold+0x345>
  417de5:	41 89 c1             	mov    r9d,eax
  417de8:	66 0f 70 c0 ff       	pshufd xmm0,xmm0,0xff
  417ded:	41 83 e1 fc          	and    r9d,0xfffffffc
  417df1:	66 41 0f 7e c0       	movd   r8d,xmm0
  417df6:	41 69 c9 00 ff ff ff 	imul   ecx,r9d,0xffffff00
  417dfd:	41 39 c1             	cmp    r9d,eax
  417e00:	0f 84 c4 09 00 00    	je     4187ca <fmt_fp+0x7aa>
  417e06:	8d 04 31             	lea    eax,[rcx+rsi*1]
  417e09:	41 89 c0             	mov    r8d,eax
  417e0c:	3d ff 00 00 00       	cmp    eax,0xff
  417e11:	0f 86 b3 09 00 00    	jbe    4187ca <fmt_fp+0x7aa>
  417e17:	41 81 e8 00 01 00 00 	sub    r8d,0x100
  417e1e:	41 81 f8 ff 00 00 00 	cmp    r8d,0xff
  417e25:	0f 86 9f 09 00 00    	jbe    4187ca <fmt_fp+0x7aa>
  417e2b:	44 8d 80 00 fe ff ff 	lea    r8d,[rax-0x200]
  417e32:	e9 93 09 00 00       	jmp    4187ca <fmt_fp+0x7aa>
  417e37:	41 8d 86 00 ff ff ff 	lea    eax,[r14-0x100]
  417e3e:	66 41 0f 6e ee       	movd   xmm5,r14d
  417e43:	31 f6                	xor    esi,esi
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417e45:	41 89 d0             	mov    r8d,edx
  417e48:	89 c1                	mov    ecx,eax
  417e4a:	66 0f 70 c5 00       	pshufd xmm0,xmm5,0x0
  417e4f:	66 0f 6f 15 19 81 00 	movdqa xmm2,XMMWORD PTR [rip+0x8119]        # 41ff70 <states+0x290>
  417e56:	00 
  417e57:	66 0f fe 05 01 81 00 	paddd  xmm0,XMMWORD PTR [rip+0x8101]        # 41ff60 <states+0x280>
  417e5e:	00 
  417e5f:	c1 e9 08             	shr    ecx,0x8
  417e62:	66 0f 6f 0d 16 81 00 	movdqa xmm1,XMMWORD PTR [rip+0x8116]        # 41ff80 <states+0x2a0>
  417e69:	00 
  417e6a:	83 c1 01             	add    ecx,0x1
  417e6d:	41 89 c9             	mov    r9d,ecx
  417e70:	41 c1 e9 02          	shr    r9d,0x2
  417e74:	66 0f 6f d8          	movdqa xmm3,xmm0
  417e78:	83 c6 01             	add    esi,0x1
  417e7b:	66 0f fe c2          	paddd  xmm0,xmm2
  417e7f:	44 89 c2             	mov    edx,r8d
	for (; l >= sizeof pad; l -= sizeof pad)
  417e82:	66 0f fe d9          	paddd  xmm3,xmm1
  417e86:	41 39 f1             	cmp    r9d,esi
  417e89:	77 e9                	ja     417e74 <fmt_fp.cold+0x3eb>
  417e8b:	89 ce                	mov    esi,ecx
  417e8d:	66 0f 70 c3 ff       	pshufd xmm0,xmm3,0xff
  417e92:	83 e6 fc             	and    esi,0xfffffffc
  417e95:	66 41 0f 7e c1       	movd   r9d,xmm0
  417e9a:	44 69 c6 00 ff ff ff 	imul   r8d,esi,0xffffff00
  417ea1:	39 f1                	cmp    ecx,esi
  417ea3:	0f 84 9c 0c 00 00    	je     418b45 <fmt_fp+0xb25>
  417ea9:	44 01 c0             	add    eax,r8d
  417eac:	41 89 c1             	mov    r9d,eax
  417eaf:	3d ff 00 00 00       	cmp    eax,0xff
  417eb4:	0f 86 8b 0c 00 00    	jbe    418b45 <fmt_fp+0xb25>
  417eba:	41 81 e9 00 01 00 00 	sub    r9d,0x100
  417ec1:	41 81 f9 ff 00 00 00 	cmp    r9d,0xff
  417ec8:	0f 86 77 0c 00 00    	jbe    418b45 <fmt_fp+0xb25>
  417ece:	44 8d 88 00 fe ff ff 	lea    r9d,[rax-0x200]
  417ed5:	e9 6b 0c 00 00       	jmp    418b45 <fmt_fp+0xb25>
  417eda:	41 8d bd 00 ff ff ff 	lea    edi,[r13-0x100]
  417ee1:	66 41 0f 6e f5       	movd   xmm6,r13d
  417ee6:	31 c9                	xor    ecx,ecx
  417ee8:	66 0f 6f 15 80 80 00 	movdqa xmm2,XMMWORD PTR [rip+0x8080]        # 41ff70 <states+0x290>
  417eef:	00 
  417ef0:	89 f8                	mov    eax,edi
  417ef2:	66 0f 70 de 00       	pshufd xmm3,xmm6,0x0
  417ef7:	66 0f 6f 0d 81 80 00 	movdqa xmm1,XMMWORD PTR [rip+0x8081]        # 41ff80 <states+0x2a0>
  417efe:	00 
  417eff:	66 0f fe 1d 59 80 00 	paddd  xmm3,XMMWORD PTR [rip+0x8059]        # 41ff60 <states+0x280>
  417f06:	00 
  417f07:	c1 e8 08             	shr    eax,0x8
  417f0a:	8d 70 01             	lea    esi,[rax+0x1]
  417f0d:	41 89 f0             	mov    r8d,esi
  417f10:	41 c1 e8 02          	shr    r8d,0x2
  417f14:	66 0f 6f c3          	movdqa xmm0,xmm3
  417f18:	83 c1 01             	add    ecx,0x1
  417f1b:	66 0f fe da          	paddd  xmm3,xmm2
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417f1f:	89 d0                	mov    eax,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  417f21:	66 0f fe c1          	paddd  xmm0,xmm1
  417f25:	41 39 c8             	cmp    r8d,ecx
  417f28:	77 ea                	ja     417f14 <fmt_fp.cold+0x48b>
  417f2a:	89 f2                	mov    edx,esi
  417f2c:	66 0f 70 c0 ff       	pshufd xmm0,xmm0,0xff
  417f31:	83 e2 fc             	and    edx,0xfffffffc
  417f34:	66 41 0f 7e c6       	movd   r14d,xmm0
  417f39:	69 ca 00 ff ff ff    	imul   ecx,edx,0xffffff00
  417f3f:	39 d6                	cmp    esi,edx
  417f41:	0f 84 f0 10 00 00    	je     419037 <fmt_fp+0x1017>
  417f47:	01 cf                	add    edi,ecx
  417f49:	41 89 fe             	mov    r14d,edi
  417f4c:	81 ff ff 00 00 00    	cmp    edi,0xff
  417f52:	0f 86 df 10 00 00    	jbe    419037 <fmt_fp+0x1017>
  417f58:	41 81 ee 00 01 00 00 	sub    r14d,0x100
  417f5f:	41 81 fe ff 00 00 00 	cmp    r14d,0xff
  417f66:	0f 86 cb 10 00 00    	jbe    419037 <fmt_fp+0x1017>
  417f6c:	44 8d b7 00 fe ff ff 	lea    r14d,[rdi-0x200]
  417f73:	e9 bf 10 00 00       	jmp    419037 <fmt_fp+0x1017>
  417f78:	41 8d bd 00 ff ff ff 	lea    edi,[r13-0x100]
  417f7f:	66 41 0f 6e ed       	movd   xmm5,r13d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417f84:	89 c1                	mov    ecx,eax
  417f86:	66 0f 6f 15 e2 7f 00 	movdqa xmm2,XMMWORD PTR [rip+0x7fe2]        # 41ff70 <states+0x290>
  417f8d:	00 
  417f8e:	89 fa                	mov    edx,edi
  417f90:	66 0f 70 dd 00       	pshufd xmm3,xmm5,0x0
  417f95:	66 0f 6f 0d e3 7f 00 	movdqa xmm1,XMMWORD PTR [rip+0x7fe3]        # 41ff80 <states+0x2a0>
  417f9c:	00 
  417f9d:	66 0f fe 1d bb 7f 00 	paddd  xmm3,XMMWORD PTR [rip+0x7fbb]        # 41ff60 <states+0x280>
  417fa4:	00 
  417fa5:	c1 ea 08             	shr    edx,0x8
  417fa8:	8d 72 01             	lea    esi,[rdx+0x1]
	for (; l >= sizeof pad; l -= sizeof pad)
  417fab:	31 d2                	xor    edx,edx
  417fad:	41 89 f0             	mov    r8d,esi
  417fb0:	41 c1 e8 02          	shr    r8d,0x2
  417fb4:	66 0f 6f c3          	movdqa xmm0,xmm3
  417fb8:	83 c2 01             	add    edx,0x1
  417fbb:	66 0f fe da          	paddd  xmm3,xmm2
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  417fbf:	89 c8                	mov    eax,ecx
	for (; l >= sizeof pad; l -= sizeof pad)
  417fc1:	66 0f fe c1          	paddd  xmm0,xmm1
  417fc5:	44 39 c2             	cmp    edx,r8d
  417fc8:	72 ea                	jb     417fb4 <fmt_fp.cold+0x52b>
  417fca:	89 f2                	mov    edx,esi
  417fcc:	66 0f 70 c0 ff       	pshufd xmm0,xmm0,0xff
  417fd1:	83 e2 fc             	and    edx,0xfffffffc
  417fd4:	66 41 0f 7e c6       	movd   r14d,xmm0
  417fd9:	69 ca 00 ff ff ff    	imul   ecx,edx,0xffffff00
  417fdf:	39 d6                	cmp    esi,edx
  417fe1:	0f 84 91 0f 00 00    	je     418f78 <fmt_fp+0xf58>
  417fe7:	01 cf                	add    edi,ecx
  417fe9:	41 89 fe             	mov    r14d,edi
  417fec:	81 ff ff 00 00 00    	cmp    edi,0xff
  417ff2:	0f 86 80 0f 00 00    	jbe    418f78 <fmt_fp+0xf58>
  417ff8:	41 81 ee 00 01 00 00 	sub    r14d,0x100
  417fff:	41 81 fe ff 00 00 00 	cmp    r14d,0xff
  418006:	0f 86 6c 0f 00 00    	jbe    418f78 <fmt_fp+0xf58>
  41800c:	44 8d b7 00 fe ff ff 	lea    r14d,[rdi-0x200]
  418013:	e9 60 0f 00 00       	jmp    418f78 <fmt_fp+0xf58>
  418018:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41801f:	00 

0000000000418020 <fmt_fp>:
#if LDBL_MANT_DIG == 53
typedef char compiler_defines_long_double_incorrectly[9-(int)sizeof(long double)];
#endif

static int fmt_fp(FILE *f, long double y, int w, int p, int fl, int t)
{
  418020:	41 57                	push   r15
  418022:	41 56                	push   r14
  418024:	41 55                	push   r13
  418026:	41 54                	push   r12
  418028:	55                   	push   rbp
  418029:	53                   	push   rbx
  41802a:	48 81 ec 00 10 00 00 	sub    rsp,0x1000
  418031:	48 83 0c 24 00       	or     QWORD PTR [rsp],0x0
  418036:	48 81 ec 38 0e 00 00 	sub    rsp,0xe38
  41803d:	89 74 24 48          	mov    DWORD PTR [rsp+0x48],esi
  418041:	49 89 fc             	mov    r12,rdi
  418044:	45 89 c7             	mov    r15d,r8d
  418047:	89 14 24             	mov    DWORD PTR [rsp],edx
  41804a:	89 4c 24 14          	mov    DWORD PTR [rsp+0x14],ecx
	uint32_t big[(LDBL_MANT_DIG+28)/29 + 1          // mantissa expansion
		+ (LDBL_MAX_EXP+LDBL_MANT_DIG+28+8)/9]; // exponent expansion
	uint32_t *a, *d, *r, *z;
	int e2=0, e, i, j, l;
  41804e:	c7 44 24 50 00 00 00 	mov    DWORD PTR [rsp+0x50],0x0
  418055:	00 
	const char *prefix="-0X+0X 0X-0x+0x 0x";
	int pl;
	char ebuf0[3*sizeof(int)], *ebuf=&ebuf0[3*sizeof(int)], *estr;

	pl=1;
	if (signbit(y)) {
  418056:	ff b4 24 78 1e 00 00 	push   QWORD PTR [rsp+0x1e78]
  41805d:	ff b4 24 78 1e 00 00 	push   QWORD PTR [rsp+0x1e78]
  418064:	e8 37 3f 00 00       	call   41bfa0 <__signbitl>
  418069:	5a                   	pop    rdx
  41806a:	59                   	pop    rcx
  41806b:	85 c0                	test   eax,eax
  41806d:	0f 84 f5 03 00 00    	je     418468 <fmt_fp+0x448>
		y=-y;
  418073:	db ac 24 70 1e 00 00 	fld    TBYTE PTR [rsp+0x1e70]
	const char *prefix="-0X+0X 0X-0x+0x 0x";
  41807a:	48 8d 05 17 7b 00 00 	lea    rax,[rip+0x7b17]        # 41fb98 <CSWTCH.187+0x7a8>
  418081:	48 c7 44 24 30 01 00 	mov    QWORD PTR [rsp+0x30],0x1
  418088:	00 00 
  41808a:	bd 03 00 00 00       	mov    ebp,0x3
  41808f:	48 89 44 24 20       	mov    QWORD PTR [rsp+0x20],rax
  418094:	bb 03 00 00 00       	mov    ebx,0x3
  418099:	41 bd 04 00 00 00    	mov    r13d,0x4
	pl=1;
  41809f:	c7 44 24 28 01 00 00 	mov    DWORD PTR [rsp+0x28],0x1
  4180a6:	00 
		y=-y;
  4180a7:	d9 e0                	fchs   
  4180a9:	db bc 24 70 1e 00 00 	fstp   TBYTE PTR [rsp+0x1e70]
		prefix+=3;
	} else if (fl & PAD_POS) {
		prefix+=6;
	} else prefix++, pl=0;

	if (!isfinite(y)) {
  4180b0:	ff b4 24 78 1e 00 00 	push   QWORD PTR [rsp+0x1e78]
  4180b7:	ff b4 24 78 1e 00 00 	push   QWORD PTR [rsp+0x1e78]
  4180be:	e8 7d 3e 00 00       	call   41bf40 <__fpclassifyl>
  4180c3:	41 5b                	pop    r11
  4180c5:	41 5e                	pop    r14
  4180c7:	83 f8 01             	cmp    eax,0x1
  4180ca:	0f 8e 90 09 00 00    	jle    418a60 <fmt_fp+0xa40>
		out(f, s, 3);
		pad(f, ' ', w, 3+pl, fl^LEFT_ADJ);
		return MAX(w, 3+pl);
	}

	y = frexpl(y, &e2) * 2;
  4180d0:	48 8d 7c 24 50       	lea    rdi,[rsp+0x50]
  4180d5:	ff b4 24 78 1e 00 00 	push   QWORD PTR [rsp+0x1e78]
  4180dc:	ff b4 24 78 1e 00 00 	push   QWORD PTR [rsp+0x1e78]
  4180e3:	e8 d8 3e 00 00       	call   41bfc0 <frexpl>
	if (y) e2--;
  4180e8:	41 59                	pop    r9
  4180ea:	41 5a                	pop    r10
	y = frexpl(y, &e2) * 2;
  4180ec:	d8 c0                	fadd   st,st(0)
	if (y) e2--;
  4180ee:	d9 ee                	fldz   
  4180f0:	d9 c0                	fld    st(0)
  4180f2:	d9 ca                	fxch   st(2)
  4180f4:	db ea                	fucomi st,st(2)
  4180f6:	dd da                	fstp   st(2)
  4180f8:	0f 8a b2 03 00 00    	jp     4184b0 <fmt_fp+0x490>
  4180fe:	0f 85 ac 03 00 00    	jne    4184b0 <fmt_fp+0x490>

	if ((t|32)=='a') {
  418104:	45 89 fe             	mov    r14d,r15d
	if (y) e2--;
  418107:	44 8b 4c 24 50       	mov    r9d,DWORD PTR [rsp+0x50]
	if ((t|32)=='a') {
  41810c:	41 83 ce 20          	or     r14d,0x20
  418110:	41 83 fe 61          	cmp    r14d,0x61
  418114:	0f 84 b4 03 00 00    	je     4184ce <fmt_fp+0x4ae>
		pad(f, '0', l-(ebuf-estr)-(s-buf), 0, 0);
		out(f, estr, ebuf-estr);
		pad(f, ' ', w, pl+l, fl^LEFT_ADJ);
		return MAX(w, pl+l);
	}
	if (p<0) p=6;
  41811a:	8b 3c 24             	mov    edi,DWORD PTR [rsp]
  41811d:	85 ff                	test   edi,edi
  41811f:	0f 88 42 15 00 00    	js     419667 <fmt_fp+0x1647>

	if (a<z) for (i=10, e=9*(r-a); *a>=i; i*=10, e++);
	else e=0;

	/* Perform rounding: j is precision after the radix (possibly neg) */
	j = p - ((t|32)!='f')*e - ((t|32)=='g' && p);
  418125:	0f 95 44 24 38       	setne  BYTE PTR [rsp+0x38]
	if (y) y *= 0x1p28, e2-=28;
  41812a:	d9 c0                	fld    st(0)
  41812c:	d9 ca                	fxch   st(2)
  41812e:	db ea                	fucomi st,st(2)
  418130:	dd da                	fstp   st(2)
  418132:	0f 8a 39 0b 00 00    	jp     418c71 <fmt_fp+0xc51>
  418138:	0f 85 3a 0b 00 00    	jne    418c78 <fmt_fp+0xc58>
	if (e2<0) a=r=z=big;
  41813e:	d9 7c 24 4e          	fnstcw WORD PTR [rsp+0x4e]
  418142:	45 85 c9             	test   r9d,r9d
  418145:	48 8d 84 24 80 01 00 	lea    rax,[rsp+0x180]
  41814c:	00 
  41814d:	48 8d 94 24 28 1d 00 	lea    rdx,[rsp+0x1d28]
  418154:	00 
  418155:	48 0f 49 c2          	cmovns rax,rdx
  418159:	d9 05 a9 7d 00 00    	fld    DWORD PTR [rip+0x7da9]        # 41ff08 <states+0x228>
  41815f:	d9 ca                	fxch   st(2)
  418161:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
	else a=r=z=big+sizeof(big)/sizeof(*big) - LDBL_MANT_DIG - 1;
  418166:	48 89 c3             	mov    rbx,rax
  418169:	0f b7 44 24 4e       	movzx  eax,WORD PTR [rsp+0x4e]
  41816e:	80 cc 0c             	or     ah,0xc
  418171:	66 89 44 24 4c       	mov    WORD PTR [rsp+0x4c],ax
  418176:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41817d:	00 00 00 
		*z = y;
  418180:	d9 c0                	fld    st(0)
  418182:	d9 6c 24 4c          	fldcw  WORD PTR [rsp+0x4c]
  418186:	df 7c 24 08          	fistp  QWORD PTR [rsp+0x8]
  41818a:	d9 6c 24 4e          	fldcw  WORD PTR [rsp+0x4e]
		y = 1000000000*(y-*z++);
  41818e:	48 83 c3 04          	add    rbx,0x4
		*z = y;
  418192:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
  418197:	89 43 fc             	mov    DWORD PTR [rbx-0x4],eax
		y = 1000000000*(y-*z++);
  41819a:	89 c0                	mov    eax,eax
  41819c:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  4181a1:	df 6c 24 08          	fild   QWORD PTR [rsp+0x8]
  4181a5:	de e9                	fsubp  st(1),st
  4181a7:	d8 ca                	fmul   st,st(2)
	} while (y);
  4181a9:	d9 c1                	fld    st(1)
  4181ab:	d9 c9                	fxch   st(1)
  4181ad:	db e9                	fucomi st,st(1)
  4181af:	dd d9                	fstp   st(1)
  4181b1:	7a cd                	jp     418180 <fmt_fp+0x160>
  4181b3:	75 cb                	jne    418180 <fmt_fp+0x160>
  4181b5:	dd d8                	fstp   st(0)
  4181b7:	dd d8                	fstp   st(0)
  4181b9:	dd d8                	fstp   st(0)
	while (e2>0) {
  4181bb:	48 8b 6c 24 18       	mov    rbp,QWORD PTR [rsp+0x18]
  4181c0:	45 85 c9             	test   r9d,r9d
  4181c3:	0f 8e 8c 00 00 00    	jle    418255 <fmt_fp+0x235>
			*d = x % 1000000000;
  4181c9:	49 b8 53 5a 9b a0 2f 	movabs r8,0x44b82fa09b5a53
  4181d0:	b8 44 00 
  4181d3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		int sh=MIN(29,e2);
  4181d8:	b9 1d 00 00 00       	mov    ecx,0x1d
		for (d=z-1; d>=a; d--) {
  4181dd:	48 8d 7b fc          	lea    rdi,[rbx-0x4]
		int sh=MIN(29,e2);
  4181e1:	41 39 c9             	cmp    r9d,ecx
  4181e4:	41 0f 4e c9          	cmovle ecx,r9d
		for (d=z-1; d>=a; d--) {
  4181e8:	48 39 ef             	cmp    rdi,rbp
  4181eb:	72 3f                	jb     41822c <fmt_fp+0x20c>
		uint32_t carry=0;
  4181ed:	31 c0                	xor    eax,eax
  4181ef:	90                   	nop
			uint64_t x = ((uint64_t)*d<<sh)+carry;
  4181f0:	8b 37                	mov    esi,DWORD PTR [rdi]
		for (d=z-1; d>=a; d--) {
  4181f2:	48 83 ef 04          	sub    rdi,0x4
			uint64_t x = ((uint64_t)*d<<sh)+carry;
  4181f6:	48 d3 e6             	shl    rsi,cl
  4181f9:	48 01 c6             	add    rsi,rax
			*d = x % 1000000000;
  4181fc:	48 89 f2             	mov    rdx,rsi
  4181ff:	48 c1 ea 09          	shr    rdx,0x9
  418203:	48 89 d0             	mov    rax,rdx
  418206:	49 f7 e0             	mul    r8
  418209:	48 c1 ea 0b          	shr    rdx,0xb
  41820d:	48 69 c2 00 ca 9a 3b 	imul   rax,rdx,0x3b9aca00
  418214:	48 29 c6             	sub    rsi,rax
			carry = x / 1000000000;
  418217:	89 d0                	mov    eax,edx
			*d = x % 1000000000;
  418219:	89 77 04             	mov    DWORD PTR [rdi+0x4],esi
		for (d=z-1; d>=a; d--) {
  41821c:	48 39 ef             	cmp    rdi,rbp
  41821f:	73 cf                	jae    4181f0 <fmt_fp+0x1d0>
		if (carry) *--a = carry;
  418221:	85 c0                	test   eax,eax
  418223:	74 07                	je     41822c <fmt_fp+0x20c>
  418225:	89 55 fc             	mov    DWORD PTR [rbp-0x4],edx
  418228:	48 83 ed 04          	sub    rbp,0x4
		while (z>a && !z[-1]) z--;
  41822c:	48 39 dd             	cmp    rbp,rbx
  41822f:	72 10                	jb     418241 <fmt_fp+0x221>
  418231:	eb 15                	jmp    418248 <fmt_fp+0x228>
  418233:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  418238:	48 83 eb 04          	sub    rbx,0x4
  41823c:	48 39 eb             	cmp    rbx,rbp
  41823f:	76 07                	jbe    418248 <fmt_fp+0x228>
  418241:	8b 73 fc             	mov    esi,DWORD PTR [rbx-0x4]
  418244:	85 f6                	test   esi,esi
  418246:	74 f0                	je     418238 <fmt_fp+0x218>
		e2-=sh;
  418248:	41 29 c9             	sub    r9d,ecx
	while (e2>0) {
  41824b:	45 85 c9             	test   r9d,r9d
  41824e:	7f 88                	jg     4181d8 <fmt_fp+0x1b8>
  418250:	44 89 4c 24 50       	mov    DWORD PTR [rsp+0x50],r9d
	while (e2<0) {
  418255:	45 85 c9             	test   r9d,r9d
  418258:	0f 84 d3 00 00 00    	je     418331 <fmt_fp+0x311>
		int sh=MIN(9,-e2), need=1+(p+LDBL_MANT_DIG/3U+8)/9;
  41825e:	8b 04 24             	mov    eax,DWORD PTR [rsp]
			carry = (1000000000>>sh) * rm;
  418261:	4c 89 64 24 08       	mov    QWORD PTR [rsp+0x8],r12
  418266:	4c 8b 64 24 18       	mov    r12,QWORD PTR [rsp+0x18]
		int sh=MIN(9,-e2), need=1+(p+LDBL_MANT_DIG/3U+8)/9;
  41826b:	83 c0 1d             	add    eax,0x1d
  41826e:	48 69 c0 39 8e e3 38 	imul   rax,rax,0x38e38e39
  418275:	48 c1 e8 21          	shr    rax,0x21
		if (z-b > need) z = b+need;
  418279:	4c 8d 58 01          	lea    r11,[rax+0x1]
  41827d:	4e 8d 2c 9d 00 00 00 	lea    r13,[r11*4+0x0]
  418284:	00 
  418285:	0f 1f 00             	nop    DWORD PTR [rax]
		int sh=MIN(9,-e2), need=1+(p+LDBL_MANT_DIG/3U+8)/9;
  418288:	41 83 f9 f7          	cmp    r9d,0xfffffff7
  41828c:	0f 8d a6 07 00 00    	jge    418a38 <fmt_fp+0xa18>
		if (!*a) a++;
  418292:	8b 45 00             	mov    eax,DWORD PTR [rbp+0x0]
		e2+=sh;
  418295:	41 83 c1 09          	add    r9d,0x9
		int sh=MIN(9,-e2), need=1+(p+LDBL_MANT_DIG/3U+8)/9;
  418299:	b9 09 00 00 00       	mov    ecx,0x9
		for (d=a; d<z; d++) {
  41829e:	48 39 dd             	cmp    rbp,rbx
  4182a1:	0f 83 a5 07 00 00    	jae    418a4c <fmt_fp+0xa2c>
			uint32_t rm = *d & (1<<sh)-1;
  4182a7:	41 b8 01 00 00 00    	mov    r8d,0x1
			carry = (1000000000>>sh) * rm;
  4182ad:	41 ba 00 ca 9a 3b    	mov    r10d,0x3b9aca00
  4182b3:	48 89 ee             	mov    rsi,rbp
		uint32_t carry=0, *b;
  4182b6:	31 d2                	xor    edx,edx
			uint32_t rm = *d & (1<<sh)-1;
  4182b8:	41 d3 e0             	shl    r8d,cl
			carry = (1000000000>>sh) * rm;
  4182bb:	41 d3 fa             	sar    r10d,cl
			uint32_t rm = *d & (1<<sh)-1;
  4182be:	41 83 e8 01          	sub    r8d,0x1
  4182c2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4182c8:	8b 06                	mov    eax,DWORD PTR [rsi]
		for (d=a; d<z; d++) {
  4182ca:	48 83 c6 04          	add    rsi,0x4
			*d = (*d>>sh) + carry;
  4182ce:	89 c7                	mov    edi,eax
			uint32_t rm = *d & (1<<sh)-1;
  4182d0:	44 21 c0             	and    eax,r8d
			carry = (1000000000>>sh) * rm;
  4182d3:	41 0f af c2          	imul   eax,r10d
			*d = (*d>>sh) + carry;
  4182d7:	d3 ef                	shr    edi,cl
  4182d9:	01 fa                	add    edx,edi
  4182db:	89 56 fc             	mov    DWORD PTR [rsi-0x4],edx
			carry = (1000000000>>sh) * rm;
  4182de:	89 c2                	mov    edx,eax
		for (d=a; d<z; d++) {
  4182e0:	48 39 de             	cmp    rsi,rbx
  4182e3:	72 e3                	jb     4182c8 <fmt_fp+0x2a8>
		if (!*a) a++;
  4182e5:	8b 4d 00             	mov    ecx,DWORD PTR [rbp+0x0]
  4182e8:	48 8d 45 04          	lea    rax,[rbp+0x4]
  4182ec:	85 c9                	test   ecx,ecx
  4182ee:	48 0f 44 e8          	cmove  rbp,rax
		if (carry) *z++ = carry;
  4182f2:	85 d2                	test   edx,edx
  4182f4:	74 06                	je     4182fc <fmt_fp+0x2dc>
  4182f6:	89 13                	mov    DWORD PTR [rbx],edx
  4182f8:	48 83 c3 04          	add    rbx,0x4
		b = (t|32)=='f' ? r : a;
  4182fc:	41 83 fe 66          	cmp    r14d,0x66
  418300:	4c 89 e0             	mov    rax,r12
		if (z-b > need) z = b+need;
  418303:	48 89 da             	mov    rdx,rbx
		b = (t|32)=='f' ? r : a;
  418306:	48 0f 45 c5          	cmovne rax,rbp
		if (z-b > need) z = b+need;
  41830a:	48 29 c2             	sub    rdx,rax
  41830d:	4c 01 e8             	add    rax,r13
  418310:	48 c1 fa 02          	sar    rdx,0x2
  418314:	4c 39 da             	cmp    rdx,r11
  418317:	48 0f 4f d8          	cmovg  rbx,rax
	while (e2<0) {
  41831b:	45 85 c9             	test   r9d,r9d
  41831e:	0f 85 64 ff ff ff    	jne    418288 <fmt_fp+0x268>
  418324:	c7 44 24 50 00 00 00 	mov    DWORD PTR [rsp+0x50],0x0
  41832b:	00 
  41832c:	4c 8b 64 24 08       	mov    r12,QWORD PTR [rsp+0x8]
	if (a<z) for (i=10, e=9*(r-a); *a>=i; i*=10, e++);
  418331:	48 39 eb             	cmp    rbx,rbp
  418334:	0f 87 f3 08 00 00    	ja     418c2d <fmt_fp+0xc0d>
  41833a:	8b 04 24             	mov    eax,DWORD PTR [rsp]
	else e=0;
  41833d:	31 ff                	xor    edi,edi
	j = p - ((t|32)!='f')*e - ((t|32)=='g' && p);
  41833f:	31 d2                	xor    edx,edx
  418341:	41 83 fe 67          	cmp    r14d,0x67
	if (j < 9*(z-r-1)) {
  418345:	48 8b 74 24 18       	mov    rsi,QWORD PTR [rsp+0x18]
	j = p - ((t|32)!='f')*e - ((t|32)=='g' && p);
  41834a:	0f 94 c2             	sete   dl
  41834d:	23 54 24 38          	and    edx,DWORD PTR [rsp+0x38]
  418351:	29 d0                	sub    eax,edx
	if (j < 9*(z-r-1)) {
  418353:	48 89 da             	mov    rdx,rbx
  418356:	48 29 f2             	sub    rdx,rsi
  418359:	48 63 c8             	movsxd rcx,eax
  41835c:	48 c1 fa 02          	sar    rdx,0x2
  418360:	48 8d 54 d2 f7       	lea    rdx,[rdx+rdx*8-0x9]
  418365:	48 39 d1             	cmp    rcx,rdx
  418368:	0f 8d 38 0a 00 00    	jge    418da6 <fmt_fp+0xd86>
		uint32_t x;
		/* We avoid C's broken division of negative numbers */
		d = r + 1 + ((j+9*LDBL_MAX_EXP)/9 - LDBL_MAX_EXP);
  41836e:	05 00 40 02 00       	add    eax,0x24000
  418373:	48 63 d0             	movsxd rdx,eax
  418376:	89 c1                	mov    ecx,eax
  418378:	48 69 d2 39 8e e3 38 	imul   rdx,rdx,0x38e38e39
  41837f:	c1 f9 1f             	sar    ecx,0x1f
  418382:	48 c1 fa 21          	sar    rdx,0x21
  418386:	29 ca                	sub    edx,ecx
  418388:	48 63 ca             	movsxd rcx,edx
		j += 9*LDBL_MAX_EXP;
		j %= 9;
  41838b:	8d 14 d2             	lea    edx,[rdx+rdx*8]
  41838e:	29 d0                	sub    eax,edx
		d = r + 1 + ((j+9*LDBL_MAX_EXP)/9 - LDBL_MAX_EXP);
  418390:	48 8d b4 8e 04 00 ff 	lea    rsi,[rsi+rcx*4-0xfffc]
  418397:	ff 
		for (i=10, j++; j<9; i*=10, j++);
  418398:	83 f8 08             	cmp    eax,0x8
  41839b:	0f 84 10 1f 00 00    	je     41a2b1 <fmt_fp+0x2291>
  4183a1:	ba 08 00 00 00       	mov    edx,0x8
  4183a6:	29 c2                	sub    edx,eax
  4183a8:	41 89 d0             	mov    r8d,edx
  4183ab:	83 f8 07             	cmp    eax,0x7
  4183ae:	0f 84 25 1f 00 00    	je     41a2d9 <fmt_fp+0x22b9>
  4183b4:	89 d0                	mov    eax,edx
  4183b6:	d1 e8                	shr    eax,1
  4183b8:	83 f8 01             	cmp    eax,0x1
  4183bb:	0f 84 cf 08 00 00    	je     418c90 <fmt_fp+0xc70>
  4183c1:	83 f8 02             	cmp    eax,0x2
  4183c4:	0f 84 da 1e 00 00    	je     41a2a4 <fmt_fp+0x2284>
  4183ca:	83 f8 03             	cmp    eax,0x3
  4183cd:	0f 84 3c 1f 00 00    	je     41a30f <fmt_fp+0x22ef>
  4183d3:	83 f8 04             	cmp    eax,0x4
  4183d6:	0f 84 40 1f 00 00    	je     41a31c <fmt_fp+0x22fc>
  4183dc:	83 f8 05             	cmp    eax,0x5
  4183df:	0f 84 68 1f 00 00    	je     41a34d <fmt_fp+0x232d>
  4183e5:	83 f8 06             	cmp    eax,0x6
  4183e8:	0f 84 52 1f 00 00    	je     41a340 <fmt_fp+0x2320>
  4183ee:	f3 0f 7e 05 1a 7b 00 	movq   xmm0,QWORD PTR [rip+0x7b1a]        # 41ff10 <states+0x230>
  4183f5:	00 
  4183f6:	b9 00 00 8a 5d       	mov    ecx,0x5d8a0000
  4183fb:	83 f8 08             	cmp    eax,0x8
  4183fe:	0f 85 94 08 00 00    	jne    418c98 <fmt_fp+0xc78>
  418404:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		x = *d % i;
  418408:	41 89 ca             	mov    r10d,ecx
  41840b:	44 8b 0e             	mov    r9d,DWORD PTR [rsi]
  41840e:	31 d2                	xor    edx,edx
  418410:	44 89 c8             	mov    eax,r9d
  418413:	41 f7 f2             	div    r10d
  418416:	41 89 d0             	mov    r8d,edx
		/* Are there any significant digits past j? */
		if (x || d+1!=z) {
  418419:	85 d2                	test   edx,edx
  41841b:	0f 85 11 09 00 00    	jne    418d32 <fmt_fp+0xd12>
  418421:	48 8d 56 04          	lea    rdx,[rsi+0x4]
  418425:	48 39 d3             	cmp    rbx,rdx
  418428:	0f 84 4d 1e 00 00    	je     41a27b <fmt_fp+0x225b>
			long double round = 2/LDBL_EPSILON;
			long double small;
			if ((*d/i & 1) || (i==1000000000 && d>a && (d[-1]&1)))
  41842e:	a8 01                	test   al,0x1
  418430:	0f 85 85 1d 00 00    	jne    41a1bb <fmt_fp+0x219b>
  418436:	81 f9 00 ca 9a 3b    	cmp    ecx,0x3b9aca00
  41843c:	75 09                	jne    418447 <fmt_fp+0x427>
  41843e:	48 39 ee             	cmp    rsi,rbp
  418441:	0f 87 47 1d 00 00    	ja     41a18e <fmt_fp+0x216e>
  418447:	d9 05 a3 7a 00 00    	fld    DWORD PTR [rip+0x7aa3]        # 41fef0 <states+0x210>
				round += 2;
			if (x<i/2) small=0x0.8p0;
  41844d:	d9 05 a1 7a 00 00    	fld    DWORD PTR [rip+0x7aa1]        # 41fef4 <states+0x214>
			long double round = 2/LDBL_EPSILON;
  418453:	d9 05 93 7a 00 00    	fld    DWORD PTR [rip+0x7a93]        # 41feec <states+0x20c>
  418459:	d9 ca                	fxch   st(2)
  41845b:	d9 c9                	fxch   st(1)
  41845d:	e9 fb 08 00 00       	jmp    418d5d <fmt_fp+0xd3d>
  418462:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	} else if (fl & MARK_POS) {
  418468:	8b 5c 24 14          	mov    ebx,DWORD PTR [rsp+0x14]
  41846c:	f6 c7 08             	test   bh,0x8
  41846f:	0f 84 70 05 00 00    	je     4189e5 <fmt_fp+0x9c5>
  418475:	bd 03 00 00 00       	mov    ebp,0x3
  41847a:	bb 03 00 00 00       	mov    ebx,0x3
		prefix+=3;
  41847f:	48 8d 05 15 77 00 00 	lea    rax,[rip+0x7715]        # 41fb9b <CSWTCH.187+0x7ab>
  418486:	48 c7 44 24 30 01 00 	mov    QWORD PTR [rsp+0x30],0x1
  41848d:	00 00 
	pl=1;
  41848f:	c7 44 24 28 01 00 00 	mov    DWORD PTR [rsp+0x28],0x1
  418496:	00 
  418497:	41 bd 04 00 00 00    	mov    r13d,0x4
		prefix+=3;
  41849d:	48 89 44 24 20       	mov    QWORD PTR [rsp+0x20],rax
  4184a2:	e9 09 fc ff ff       	jmp    4180b0 <fmt_fp+0x90>
  4184a7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  4184ae:	00 00 
	if (y) e2--;
  4184b0:	8b 44 24 50          	mov    eax,DWORD PTR [rsp+0x50]
	if ((t|32)=='a') {
  4184b4:	45 89 fe             	mov    r14d,r15d
  4184b7:	41 83 ce 20          	or     r14d,0x20
	if (y) e2--;
  4184bb:	44 8d 48 ff          	lea    r9d,[rax-0x1]
  4184bf:	44 89 4c 24 50       	mov    DWORD PTR [rsp+0x50],r9d
	if ((t|32)=='a') {
  4184c4:	41 83 fe 61          	cmp    r14d,0x61
  4184c8:	0f 85 4c fc ff ff    	jne    41811a <fmt_fp+0xfa>
		if (t&32) prefix += 9;
  4184ce:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
  4184d3:	41 f6 c7 20          	test   r15b,0x20
  4184d7:	48 8d 41 09          	lea    rax,[rcx+0x9]
  4184db:	48 0f 44 c1          	cmove  rax,rcx
  4184df:	48 89 44 24 20       	mov    QWORD PTR [rsp+0x20],rax
		if (p<0 || p>=LDBL_MANT_DIG/4-1) re=0;
  4184e4:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  4184e7:	83 f8 0e             	cmp    eax,0xe
  4184ea:	0f 87 93 00 00 00    	ja     418583 <fmt_fp+0x563>
			while (re--) round*=16;
  4184f0:	0f 84 3f 1e 00 00    	je     41a335 <fmt_fp+0x2315>
  4184f6:	83 f8 0d             	cmp    eax,0xd
  4184f9:	0f 84 70 1e 00 00    	je     41a36f <fmt_fp+0x234f>
  4184ff:	83 f8 0c             	cmp    eax,0xc
  418502:	0f 84 a1 1e 00 00    	je     41a3a9 <fmt_fp+0x2389>
  418508:	83 f8 0b             	cmp    eax,0xb
  41850b:	0f 84 8d 1e 00 00    	je     41a39e <fmt_fp+0x237e>
  418511:	83 f8 0a             	cmp    eax,0xa
  418514:	0f 84 9a 1e 00 00    	je     41a3b4 <fmt_fp+0x2394>
  41851a:	83 f8 09             	cmp    eax,0x9
  41851d:	0f 84 bb 1c 00 00    	je     41a1de <fmt_fp+0x21be>
  418523:	83 f8 08             	cmp    eax,0x8
  418526:	0f 84 9e 1e 00 00    	je     41a3ca <fmt_fp+0x23aa>
  41852c:	83 f8 07             	cmp    eax,0x7
  41852f:	0f 84 8a 1e 00 00    	je     41a3bf <fmt_fp+0x239f>
  418535:	83 f8 06             	cmp    eax,0x6
  418538:	0f 84 a9 1e 00 00    	je     41a3e7 <fmt_fp+0x23c7>
  41853e:	83 f8 05             	cmp    eax,0x5
  418541:	0f 84 95 1e 00 00    	je     41a3dc <fmt_fp+0x23bc>
  418547:	83 f8 04             	cmp    eax,0x4
  41854a:	0f 84 c3 1e 00 00    	je     41a413 <fmt_fp+0x23f3>
  418550:	83 f8 03             	cmp    eax,0x3
  418553:	0f 84 af 1e 00 00    	je     41a408 <fmt_fp+0x23e8>
  418559:	83 f8 02             	cmp    eax,0x2
  41855c:	0f 84 9b 1e 00 00    	je     41a3fd <fmt_fp+0x23dd>
  418562:	83 f8 01             	cmp    eax,0x1
  418565:	0f 84 87 1e 00 00    	je     41a3f2 <fmt_fp+0x23d2>
  41856b:	d9 05 3f 79 00 00    	fld    DWORD PTR [rip+0x793f]        # 41feb0 <states+0x1d0>
			if (*prefix=='-') {
  418571:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  418576:	80 38 2d             	cmp    BYTE PTR [rax],0x2d
  418579:	0f 84 c0 1c 00 00    	je     41a23f <fmt_fp+0x221f>
				y+=round;
  41857f:	dc c2                	fadd   st(2),st
				y-=round;
  418581:	de ea                	fsubp  st(2),st
		estr=fmt_u(e2<0 ? -e2 : e2, ebuf);
  418583:	44 89 c9             	mov    ecx,r9d
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  418586:	4c 8d 6c 24 60       	lea    r13,[rsp+0x60]
  41858b:	48 bf cd cc cc cc cc 	movabs rdi,0xcccccccccccccccd
  418592:	cc cc cc 
		estr=fmt_u(e2<0 ? -e2 : e2, ebuf);
  418595:	f7 d9                	neg    ecx
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  418597:	4c 89 ee             	mov    rsi,r13
		estr=fmt_u(e2<0 ? -e2 : e2, ebuf);
  41859a:	41 0f 48 c9          	cmovs  ecx,r9d
  41859e:	48 63 c9             	movsxd rcx,ecx
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  4185a1:	45 85 c9             	test   r9d,r9d
  4185a4:	0f 84 a1 1b 00 00    	je     41a14b <fmt_fp+0x212b>
  4185aa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  4185b0:	48 89 c8             	mov    rax,rcx
  4185b3:	48 83 ee 01          	sub    rsi,0x1
  4185b7:	48 f7 e7             	mul    rdi
  4185ba:	48 89 c8             	mov    rax,rcx
  4185bd:	48 c1 ea 03          	shr    rdx,0x3
  4185c1:	4c 8d 04 92          	lea    r8,[rdx+rdx*4]
  4185c5:	4d 01 c0             	add    r8,r8
  4185c8:	4c 29 c0             	sub    rax,r8
  4185cb:	83 c0 30             	add    eax,0x30
  4185ce:	88 06                	mov    BYTE PTR [rsi],al
  4185d0:	48 89 c8             	mov    rax,rcx
  4185d3:	48 89 d1             	mov    rcx,rdx
  4185d6:	48 83 f8 09          	cmp    rax,0x9
  4185da:	77 d4                	ja     4185b0 <fmt_fp+0x590>
		if (estr==ebuf) *--estr='0';
  4185dc:	4c 39 ee             	cmp    rsi,r13
  4185df:	0f 84 66 1b 00 00    	je     41a14b <fmt_fp+0x212b>
		*--estr = (e2<0 ? '-' : '+');
  4185e5:	41 c1 f9 1f          	sar    r9d,0x1f
		*--estr = t+('p'-'a');
  4185e9:	48 8d 46 fe          	lea    rax,[rsi-0x2]
		*--estr = (e2<0 ? '-' : '+');
  4185ed:	41 83 e1 02          	and    r9d,0x2
		*--estr = t+('p'-'a');
  4185f1:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  4185f6:	41 8d 47 0f          	lea    eax,[r15+0xf]
		*--estr = (e2<0 ? '-' : '+');
  4185fa:	41 83 c1 2b          	add    r9d,0x2b
		*--estr = t+('p'-'a');
  4185fe:	88 46 fe             	mov    BYTE PTR [rsi-0x2],al
		*--estr = (e2<0 ? '-' : '+');
  418601:	44 88 4e ff          	mov    BYTE PTR [rsi-0x1],r9b
			*s++=xdigits[x]|(t&32);
  418605:	44 89 fe             	mov    esi,r15d
  418608:	83 e6 20             	and    esi,0x20
  41860b:	f6 44 24 14 08       	test   BYTE PTR [rsp+0x14],0x8
  418610:	0f 85 f3 15 00 00    	jne    419c09 <fmt_fp+0x1be9>
  418616:	d9 7c 24 4e          	fnstcw WORD PTR [rsp+0x4e]
  41861a:	d9 05 e0 78 00 00    	fld    DWORD PTR [rip+0x78e0]        # 41ff00 <states+0x220>
  418620:	d9 ca                	fxch   st(2)
		s=buf;
  418622:	4c 89 ea             	mov    rdx,r13
			if (s-buf==1 && (y||p>0||(fl&ALT_FORM))) *s++='.';
  418625:	bf 01 00 00 00       	mov    edi,0x1
  41862a:	48 8d 0d 9f 76 00 00 	lea    rcx,[rip+0x769f]        # 41fcd0 <xdigits>
  418631:	0f b7 44 24 4e       	movzx  eax,WORD PTR [rsp+0x4e]
  418636:	80 cc 0c             	or     ah,0xc
  418639:	66 89 44 24 4c       	mov    WORD PTR [rsp+0x4c],ax
  41863e:	eb 13                	jmp    418653 <fmt_fp+0x633>
			*s++=xdigits[x]|(t&32);
  418640:	48 89 c2             	mov    rdx,rax
		} while (y);
  418643:	d9 c1                	fld    st(1)
  418645:	d9 c9                	fxch   st(1)
  418647:	db e9                	fucomi st,st(1)
  418649:	dd d9                	fstp   st(1)
  41864b:	7a 06                	jp     418653 <fmt_fp+0x633>
  41864d:	0f 84 43 1c 00 00    	je     41a296 <fmt_fp+0x2276>
			int x=y;
  418653:	d9 c0                	fld    st(0)
  418655:	d9 6c 24 4c          	fldcw  WORD PTR [rsp+0x4c]
  418659:	db 5c 24 08          	fistp  DWORD PTR [rsp+0x8]
  41865d:	d9 6c 24 4e          	fldcw  WORD PTR [rsp+0x4e]
			y=16*(y-x);
  418661:	db 44 24 08          	fild   DWORD PTR [rsp+0x8]
			*s++=xdigits[x]|(t&32);
  418665:	48 63 44 24 08       	movsxd rax,DWORD PTR [rsp+0x8]
  41866a:	44 0f b6 1c 01       	movzx  r11d,BYTE PTR [rcx+rax*1]
			if (s-buf==1 && (y||p>0||(fl&ALT_FORM))) *s++='.';
  41866f:	48 8d 42 01          	lea    rax,[rdx+0x1]
			y=16*(y-x);
  418673:	de e9                	fsubp  st(1),st
			*s++=xdigits[x]|(t&32);
  418675:	41 09 f3             	or     r11d,esi
  418678:	44 88 1a             	mov    BYTE PTR [rdx],r11b
			y=16*(y-x);
  41867b:	d8 ca                	fmul   st,st(2)
			if (s-buf==1 && (y||p>0||(fl&ALT_FORM))) *s++='.';
  41867d:	4c 39 ea             	cmp    rdx,r13
  418680:	75 be                	jne    418640 <fmt_fp+0x620>
  418682:	44 8b 04 24          	mov    r8d,DWORD PTR [rsp]
  418686:	45 85 c0             	test   r8d,r8d
  418689:	0f 8f df 0e 00 00    	jg     41956e <fmt_fp+0x154e>
  41868f:	d9 c1                	fld    st(1)
  418691:	df e9                	fucomip st,st(1)
  418693:	41 0f 9a c0          	setp   r8b
  418697:	44 0f 45 c7          	cmovne r8d,edi
  41869b:	45 84 c0             	test   r8b,r8b
  41869e:	0f 85 ca 0e 00 00    	jne    41956e <fmt_fp+0x154e>
  4186a4:	dd d8                	fstp   st(0)
  4186a6:	dd d8                	fstp   st(0)
  4186a8:	dd d8                	fstp   st(0)
  4186aa:	eb 06                	jmp    4186b2 <fmt_fp+0x692>
  4186ac:	dd d8                	fstp   st(0)
  4186ae:	dd d8                	fstp   st(0)
  4186b0:	dd d8                	fstp   st(0)
		if (p > INT_MAX-2-(ebuf-estr)-pl)
  4186b2:	4c 89 ef             	mov    rdi,r13
  4186b5:	ba fd ff ff 7f       	mov    edx,0x7ffffffd
  4186ba:	48 2b 7c 24 28       	sub    rdi,QWORD PTR [rsp+0x28]
  4186bf:	48 63 0c 24          	movsxd rcx,DWORD PTR [rsp]
  4186c3:	48 29 fa             	sub    rdx,rdi
  4186c6:	48 89 7c 24 18       	mov    QWORD PTR [rsp+0x18],rdi
  4186cb:	48 29 ea             	sub    rdx,rbp
  4186ce:	48 39 d1             	cmp    rcx,rdx
  4186d1:	0f 8f 86 0f 00 00    	jg     41965d <fmt_fp+0x163d>
		if (p && s-buf-2 < p)
  4186d7:	4c 29 e8             	sub    rax,r13
  4186da:	49 89 fb             	mov    r11,rdi
  4186dd:	8b 34 24             	mov    esi,DWORD PTR [rsp]
  4186e0:	48 89 c7             	mov    rdi,rax
  4186e3:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
			l = (s-buf) + (ebuf-estr);
  4186e8:	44 89 d8             	mov    eax,r11d
  4186eb:	01 f8                	add    eax,edi
		if (p && s-buf-2 < p)
  4186ed:	85 f6                	test   esi,esi
  4186ef:	74 0d                	je     4186fe <fmt_fp+0x6de>
  4186f1:	48 8d 57 ff          	lea    rdx,[rdi-0x1]
  4186f5:	48 39 d1             	cmp    rcx,rdx
  4186f8:	0f 8d a5 1a 00 00    	jge    41a1a3 <fmt_fp+0x2183>
			l = (s-buf) + (ebuf-estr);
  4186fe:	c7 44 24 30 00 00 00 	mov    DWORD PTR [rsp+0x30],0x0
  418705:	00 
  418706:	31 ed                	xor    ebp,ebp
		pad(f, ' ', w, pl+l, fl);
  418708:	44 8d 34 18          	lea    r14d,[rax+rbx*1]
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41870c:	44 3b 74 24 48       	cmp    r14d,DWORD PTR [rsp+0x48]
  418711:	0f 9d 04 24          	setge  BYTE PTR [rsp]
  418715:	0f b6 04 24          	movzx  eax,BYTE PTR [rsp]
  418719:	f7 44 24 14 00 20 01 	test   DWORD PTR [rsp+0x14],0x12000
  418720:	00 
  418721:	0f 85 b5 00 00 00    	jne    4187dc <fmt_fp+0x7bc>
  418727:	84 c0                	test   al,al
  418729:	0f 85 ad 00 00 00    	jne    4187dc <fmt_fp+0x7bc>
	l = w - l;
  41872f:	44 8b 44 24 48       	mov    r8d,DWORD PTR [rsp+0x48]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  418734:	b8 00 01 00 00       	mov    eax,0x100
  418739:	be 20 00 00 00       	mov    esi,0x20
  41873e:	4c 8d bc 24 80 01 00 	lea    r15,[rsp+0x180]
  418745:	00 
  418746:	4c 89 ff             	mov    rdi,r15
	l = w - l;
  418749:	45 29 f0             	sub    r8d,r14d
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41874c:	41 39 c0             	cmp    r8d,eax
  41874f:	44 89 44 24 08       	mov    DWORD PTR [rsp+0x8],r8d
  418754:	41 0f 4e c0          	cmovle eax,r8d
  418758:	48 63 d0             	movsxd rdx,eax
  41875b:	e8 fc e0 ff ff       	call   41685c <memset>
	for (; l >= sizeof pad; l -= sizeof pad)
  418760:	44 8b 44 24 08       	mov    r8d,DWORD PTR [rsp+0x8]
  418765:	41 81 f8 ff 00 00 00 	cmp    r8d,0xff
  41876c:	0f 8e 08 1c 00 00    	jle    41a37a <fmt_fp+0x235a>
  418772:	41 8d 88 00 ff ff ff 	lea    ecx,[r8-0x100]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418779:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  41877d:	4c 89 6c 24 08       	mov    QWORD PTR [rsp+0x8],r13
  418782:	41 89 dd             	mov    r13d,ebx
  418785:	89 cb                	mov    ebx,ecx
  418787:	83 e0 20             	and    eax,0x20
  41878a:	89 c2                	mov    edx,eax
  41878c:	0f 84 e9 0d 00 00    	je     41957b <fmt_fp+0x155b>
	for (; l >= sizeof pad; l -= sizeof pad)
  418792:	89 d9                	mov    ecx,ebx
  418794:	44 89 eb             	mov    ebx,r13d
  418797:	4c 8b 6c 24 08       	mov    r13,QWORD PTR [rsp+0x8]
  41879c:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  4187a2:	7e 3f                	jle    4187e3 <fmt_fp+0x7c3>
  4187a4:	8d 81 00 e9 ff ff    	lea    eax,[rcx-0x1700]
  4187aa:	3d 00 e9 ff 7f       	cmp    eax,0x7fffe900
  4187af:	0f 86 de f5 ff ff    	jbe    417d93 <fmt_fp.cold+0x30a>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4187b5:	89 d0                	mov    eax,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  4187b7:	81 e9 00 01 00 00    	sub    ecx,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4187bd:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  4187bf:	41 89 c8             	mov    r8d,ecx
  4187c2:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  4187c8:	77 ed                	ja     4187b7 <fmt_fp+0x797>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4187ca:	85 d2                	test   edx,edx
  4187cc:	75 1d                	jne    4187eb <fmt_fp+0x7cb>
	out(f, pad, l);
  4187ce:	49 63 f0             	movsxd rsi,r8d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4187d1:	4c 89 e2             	mov    rdx,r12
  4187d4:	4c 89 ff             	mov    rdi,r15
  4187d7:	e8 44 3b 00 00       	call   41c320 <__fwritex>
  4187dc:	41 8b 14 24          	mov    edx,DWORD PTR [r12]
  4187e0:	83 e2 20             	and    edx,0x20
  4187e3:	85 d2                	test   edx,edx
  4187e5:	0f 84 46 15 00 00    	je     419d31 <fmt_fp+0x1d11>
		pad(f, '0', w, pl+l, fl^ZERO_PAD);
  4187eb:	8b 44 24 14          	mov    eax,DWORD PTR [rsp+0x14]
  4187ef:	35 00 00 01 00       	xor    eax,0x10000
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  4187f4:	a9 00 20 01 00       	test   eax,0x12000
  4187f9:	0f 85 b9 0e 00 00    	jne    4196b8 <fmt_fp+0x1698>
  4187ff:	80 3c 24 00          	cmp    BYTE PTR [rsp],0x0
  418803:	0f 85 af 0e 00 00    	jne    4196b8 <fmt_fp+0x1698>
	l = w - l;
  418809:	8b 4c 24 48          	mov    ecx,DWORD PTR [rsp+0x48]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41880d:	b8 00 01 00 00       	mov    eax,0x100
  418812:	be 30 00 00 00       	mov    esi,0x30
  418817:	4c 8d bc 24 80 01 00 	lea    r15,[rsp+0x180]
  41881e:	00 
  41881f:	4c 89 ff             	mov    rdi,r15
	l = w - l;
  418822:	44 29 f1             	sub    ecx,r14d
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  418825:	39 c1                	cmp    ecx,eax
  418827:	89 4c 24 08          	mov    DWORD PTR [rsp+0x8],ecx
  41882b:	0f 4e c1             	cmovle eax,ecx
  41882e:	48 63 d0             	movsxd rdx,eax
  418831:	e8 26 e0 ff ff       	call   41685c <memset>
	for (; l >= sizeof pad; l -= sizeof pad)
  418836:	8b 4c 24 08          	mov    ecx,DWORD PTR [rsp+0x8]
  41883a:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  418840:	0f 8e 14 1b 00 00    	jle    41a35a <fmt_fp+0x233a>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418846:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  41884a:	8d 99 00 ff ff ff    	lea    ebx,[rcx-0x100]
  418850:	83 e0 20             	and    eax,0x20
  418853:	89 c2                	mov    edx,eax
  418855:	0f 84 85 0d 00 00    	je     4195e0 <fmt_fp+0x15c0>
	for (; l >= sizeof pad; l -= sizeof pad)
  41885b:	81 fb ff 00 00 00    	cmp    ebx,0xff
  418861:	0f 8e 58 0e 00 00    	jle    4196bf <fmt_fp+0x169f>
  418867:	8d 83 00 e9 ff ff    	lea    eax,[rbx-0x1700]
  41886d:	3d 00 e9 ff 7f       	cmp    eax,0x7fffe900
  418872:	0f 86 11 f2 ff ff    	jbe    417a89 <fmt_fp.cold>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418878:	89 d0                	mov    eax,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  41887a:	81 eb 00 01 00 00    	sub    ebx,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418880:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  418882:	89 d9                	mov    ecx,ebx
  418884:	81 fb ff 00 00 00    	cmp    ebx,0xff
  41888a:	77 ee                	ja     41887a <fmt_fp+0x85a>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41888c:	85 d2                	test   edx,edx
  41888e:	0f 84 16 0e 00 00    	je     4196aa <fmt_fp+0x168a>
	for (; l >= sizeof pad; l -= sizeof pad)
  418894:	89 eb                	mov    ebx,ebp
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  418896:	85 ed                	test   ebp,ebp
  418898:	0f 8e a3 00 00 00    	jle    418941 <fmt_fp+0x921>
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41889e:	81 7c 24 30 01 01 00 	cmp    DWORD PTR [rsp+0x30],0x101
  4188a5:	00 
  4188a6:	ba 00 01 00 00       	mov    edx,0x100
  4188ab:	be 30 00 00 00       	mov    esi,0x30
  4188b0:	48 0f 42 d5          	cmovb  rdx,rbp
  4188b4:	4c 8d bc 24 80 01 00 	lea    r15,[rsp+0x180]
  4188bb:	00 
  4188bc:	4c 89 ff             	mov    rdi,r15
  4188bf:	e8 98 df ff ff       	call   41685c <memset>
	for (; l >= sizeof pad; l -= sizeof pad)
  4188c4:	81 fd ff 00 00 00    	cmp    ebp,0xff
  4188ca:	0f 8e 59 1a 00 00    	jle    41a329 <fmt_fp+0x2309>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4188d0:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  4188d4:	81 eb 00 01 00 00    	sub    ebx,0x100
  4188da:	83 e0 20             	and    eax,0x20
  4188dd:	89 c2                	mov    edx,eax
  4188df:	0f 84 c9 0c 00 00    	je     4195ae <fmt_fp+0x158e>
	for (; l >= sizeof pad; l -= sizeof pad)
  4188e5:	81 fb ff 00 00 00    	cmp    ebx,0xff
  4188eb:	7e 3e                	jle    41892b <fmt_fp+0x90b>
  4188ed:	8d 83 00 e9 ff ff    	lea    eax,[rbx-0x1700]
  4188f3:	3d 00 e9 ff 7f       	cmp    eax,0x7fffe900
  4188f8:	0f 86 2a f2 ff ff    	jbe    417b28 <fmt_fp.cold+0x9f>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4188fe:	89 d0                	mov    eax,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  418900:	81 eb 00 01 00 00    	sub    ebx,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418906:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  418908:	89 dd                	mov    ebp,ebx
  41890a:	81 fb ff 00 00 00    	cmp    ebx,0xff
  418910:	77 ee                	ja     418900 <fmt_fp+0x8e0>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418912:	85 d2                	test   edx,edx
  418914:	75 2b                	jne    418941 <fmt_fp+0x921>
	out(f, pad, l);
  418916:	48 63 f5             	movsxd rsi,ebp
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418919:	4c 89 e2             	mov    rdx,r12
  41891c:	4c 89 ff             	mov    rdi,r15
  41891f:	e8 fc 39 00 00       	call   41c320 <__fwritex>
  418924:	41 8b 14 24          	mov    edx,DWORD PTR [r12]
  418928:	83 e2 20             	and    edx,0x20
  41892b:	85 d2                	test   edx,edx
  41892d:	75 12                	jne    418941 <fmt_fp+0x921>
  41892f:	48 8b 74 24 18       	mov    rsi,QWORD PTR [rsp+0x18]
  418934:	48 8b 7c 24 28       	mov    rdi,QWORD PTR [rsp+0x28]
  418939:	4c 89 e2             	mov    rdx,r12
  41893c:	e8 df 39 00 00       	call   41c320 <__fwritex>
		pad(f, ' ', w, pl+l, fl^LEFT_ADJ);
  418941:	8b 44 24 14          	mov    eax,DWORD PTR [rsp+0x14]
  418945:	80 f4 20             	xor    ah,0x20
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  418948:	a9 00 20 01 00       	test   eax,0x12000
  41894d:	0f 85 82 00 00 00    	jne    4189d5 <fmt_fp+0x9b5>
  418953:	80 3c 24 00          	cmp    BYTE PTR [rsp],0x0
  418957:	75 7c                	jne    4189d5 <fmt_fp+0x9b5>
	l = w - l;
  418959:	8b 6c 24 48          	mov    ebp,DWORD PTR [rsp+0x48]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41895d:	b8 00 01 00 00       	mov    eax,0x100
  418962:	be 20 00 00 00       	mov    esi,0x20
  418967:	4c 8d bc 24 80 01 00 	lea    r15,[rsp+0x180]
  41896e:	00 
  41896f:	4c 89 ff             	mov    rdi,r15
	l = w - l;
  418972:	44 29 f5             	sub    ebp,r14d
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  418975:	39 c5                	cmp    ebp,eax
  418977:	0f 4e c5             	cmovle eax,ebp
  41897a:	48 63 d0             	movsxd rdx,eax
  41897d:	e8 da de ff ff       	call   41685c <memset>
	for (; l >= sizeof pad; l -= sizeof pad)
  418982:	81 fd ff 00 00 00    	cmp    ebp,0xff
  418988:	0f 8e f8 19 00 00    	jle    41a386 <fmt_fp+0x2366>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41898e:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  418992:	8d 9d 00 ff ff ff    	lea    ebx,[rbp-0x100]
  418998:	83 e0 20             	and    eax,0x20
  41899b:	0f 84 71 0c 00 00    	je     419612 <fmt_fp+0x15f2>
	for (; l >= sizeof pad; l -= sizeof pad)
  4189a1:	81 fb ff 00 00 00    	cmp    ebx,0xff
  4189a7:	7e 2c                	jle    4189d5 <fmt_fp+0x9b5>
  4189a9:	8d 93 00 e9 ff ff    	lea    edx,[rbx-0x1700]
  4189af:	81 fa 00 e9 ff 7f    	cmp    edx,0x7fffe900
  4189b5:	0f 86 0c f2 ff ff    	jbe    417bc7 <fmt_fp.cold+0x13e>
  4189bb:	81 eb 00 01 00 00    	sub    ebx,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4189c1:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  4189c3:	89 dd                	mov    ebp,ebx
  4189c5:	81 fb ff 00 00 00    	cmp    ebx,0xff
  4189cb:	77 ee                	ja     4189bb <fmt_fp+0x99b>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4189cd:	85 d2                	test   edx,edx
  4189cf:	0f 84 ae 18 00 00    	je     41a283 <fmt_fp+0x2263>
		return MAX(w, pl+l);
  4189d5:	8b 44 24 48          	mov    eax,DWORD PTR [rsp+0x48]
  4189d9:	41 39 c6             	cmp    r14d,eax
  4189dc:	41 0f 4d c6          	cmovge eax,r14d
  4189e0:	e9 36 02 00 00       	jmp    418c1b <fmt_fp+0xbfb>
	} else if (fl & PAD_POS) {
  4189e5:	89 d8                	mov    eax,ebx
  4189e7:	89 d9                	mov    ecx,ebx
  4189e9:	48 8d 15 ae 71 00 00 	lea    rdx,[rip+0x71ae]        # 41fb9e <CSWTCH.187+0x7ae>
  4189f0:	83 e0 01             	and    eax,0x1
  4189f3:	83 e1 01             	and    ecx,0x1
  4189f6:	83 f8 01             	cmp    eax,0x1
  4189f9:	48 89 4c 24 30       	mov    QWORD PTR [rsp+0x30],rcx
  4189fe:	48 19 ed             	sbb    rbp,rbp
  418a01:	48 83 c5 03          	add    rbp,0x3
  418a05:	83 f8 01             	cmp    eax,0x1
  418a08:	19 db                	sbb    ebx,ebx
  418a0a:	83 c3 03             	add    ebx,0x3
  418a0d:	83 f8 01             	cmp    eax,0x1
  418a10:	45 19 ed             	sbb    r13d,r13d
  418a13:	41 83 c5 04          	add    r13d,0x4
  418a17:	85 c0                	test   eax,eax
  418a19:	48 8d 42 fb          	lea    rax,[rdx-0x5]
  418a1d:	48 0f 45 c2          	cmovne rax,rdx
  418a21:	48 89 44 24 20       	mov    QWORD PTR [rsp+0x20],rax
  418a26:	0f 95 c0             	setne  al
  418a29:	0f b6 c0             	movzx  eax,al
  418a2c:	89 44 24 28          	mov    DWORD PTR [rsp+0x28],eax
  418a30:	e9 7b f6 ff ff       	jmp    4180b0 <fmt_fp+0x90>
  418a35:	0f 1f 00             	nop    DWORD PTR [rax]
		int sh=MIN(9,-e2), need=1+(p+LDBL_MANT_DIG/3U+8)/9;
  418a38:	44 89 c9             	mov    ecx,r9d
		if (!*a) a++;
  418a3b:	8b 45 00             	mov    eax,DWORD PTR [rbp+0x0]
  418a3e:	45 31 c9             	xor    r9d,r9d
		int sh=MIN(9,-e2), need=1+(p+LDBL_MANT_DIG/3U+8)/9;
  418a41:	f7 d9                	neg    ecx
		for (d=a; d<z; d++) {
  418a43:	48 39 dd             	cmp    rbp,rbx
  418a46:	0f 82 5b f8 ff ff    	jb     4182a7 <fmt_fp+0x287>
		if (!*a) a++;
  418a4c:	48 8d 55 04          	lea    rdx,[rbp+0x4]
  418a50:	85 c0                	test   eax,eax
  418a52:	48 0f 44 ea          	cmove  rbp,rdx
  418a56:	e9 a1 f8 ff ff       	jmp    4182fc <fmt_fp+0x2dc>
  418a5b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		if (y!=y) s=(t&32)?"nan":"NAN";
  418a60:	db ac 24 70 1e 00 00 	fld    TBYTE PTR [rsp+0x1e70]
		char *s = (t&32)?"inf":"INF";
  418a67:	44 89 fa             	mov    edx,r15d
  418a6a:	48 8d 2d 3a 71 00 00 	lea    rbp,[rip+0x713a]        # 41fbab <CSWTCH.187+0x7bb>
  418a71:	83 e2 20             	and    edx,0x20
  418a74:	48 8d 05 34 71 00 00 	lea    rax,[rip+0x7134]        # 41fbaf <CSWTCH.187+0x7bf>
  418a7b:	48 0f 44 e8          	cmove  rbp,rax
		if (y!=y) s=(t&32)?"nan":"NAN";
  418a7f:	df e8                	fucomip st,st(0)
  418a81:	7b 14                	jnp    418a97 <fmt_fp+0xa77>
  418a83:	85 d2                	test   edx,edx
  418a85:	48 8d 2d 2b 71 00 00 	lea    rbp,[rip+0x712b]        # 41fbb7 <CSWTCH.187+0x7c7>
  418a8c:	48 8d 05 20 71 00 00 	lea    rax,[rip+0x7120]        # 41fbb3 <CSWTCH.187+0x7c3>
  418a93:	48 0f 44 e8          	cmove  rbp,rax
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  418a97:	44 39 6c 24 48       	cmp    DWORD PTR [rsp+0x48],r13d
  418a9c:	0f 9e c3             	setle  bl
  418a9f:	f7 44 24 14 00 20 00 	test   DWORD PTR [rsp+0x14],0x2000
  418aa6:	00 
  418aa7:	0f 85 aa 00 00 00    	jne    418b57 <fmt_fp+0xb37>
  418aad:	84 db                	test   bl,bl
  418aaf:	0f 85 a2 00 00 00    	jne    418b57 <fmt_fp+0xb37>
	l = w - l;
  418ab5:	44 8b 4c 24 48       	mov    r9d,DWORD PTR [rsp+0x48]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  418aba:	b8 00 01 00 00       	mov    eax,0x100
  418abf:	be 20 00 00 00       	mov    esi,0x20
  418ac4:	4c 8d bc 24 80 01 00 	lea    r15,[rsp+0x180]
  418acb:	00 
  418acc:	4c 89 ff             	mov    rdi,r15
	l = w - l;
  418acf:	45 29 e9             	sub    r9d,r13d
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  418ad2:	41 39 c1             	cmp    r9d,eax
  418ad5:	44 89 0c 24          	mov    DWORD PTR [rsp],r9d
  418ad9:	41 0f 4e c1          	cmovle eax,r9d
  418add:	48 63 d0             	movsxd rdx,eax
  418ae0:	e8 77 dd ff ff       	call   41685c <memset>
	for (; l >= sizeof pad; l -= sizeof pad)
  418ae5:	44 8b 0c 24          	mov    r9d,DWORD PTR [rsp]
  418ae9:	41 81 f9 ff 00 00 00 	cmp    r9d,0xff
  418af0:	0f 8e cb 17 00 00    	jle    41a2c1 <fmt_fp+0x22a1>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418af6:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  418afa:	45 8d b1 00 ff ff ff 	lea    r14d,[r9-0x100]
  418b01:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  418b08:	83 e0 20             	and    eax,0x20
  418b0b:	89 c2                	mov    edx,eax
  418b0d:	0f 84 b5 01 00 00    	je     418cc8 <fmt_fp+0xca8>
	for (; l >= sizeof pad; l -= sizeof pad)
  418b13:	41 81 fe ff 00 00 00 	cmp    r14d,0xff
  418b1a:	7e 42                	jle    418b5e <fmt_fp+0xb3e>
  418b1c:	41 8d 86 00 e9 ff ff 	lea    eax,[r14-0x1700]
  418b23:	3d 00 e9 ff 7f       	cmp    eax,0x7fffe900
  418b28:	0f 86 09 f3 ff ff    	jbe    417e37 <fmt_fp.cold+0x3ae>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418b2e:	89 d0                	mov    eax,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  418b30:	41 81 ee 00 01 00 00 	sub    r14d,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418b37:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  418b39:	45 89 f1             	mov    r9d,r14d
  418b3c:	41 81 fe ff 00 00 00 	cmp    r14d,0xff
  418b43:	77 eb                	ja     418b30 <fmt_fp+0xb10>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418b45:	85 d2                	test   edx,edx
  418b47:	75 1d                	jne    418b66 <fmt_fp+0xb46>
	out(f, pad, l);
  418b49:	49 63 f1             	movsxd rsi,r9d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418b4c:	4c 89 e2             	mov    rdx,r12
  418b4f:	4c 89 ff             	mov    rdi,r15
  418b52:	e8 c9 37 00 00       	call   41c320 <__fwritex>
  418b57:	41 8b 14 24          	mov    edx,DWORD PTR [r12]
  418b5b:	83 e2 20             	and    edx,0x20
  418b5e:	85 d2                	test   edx,edx
  418b60:	0f 84 12 0b 00 00    	je     419678 <fmt_fp+0x1658>
		pad(f, ' ', w, 3+pl, fl^LEFT_ADJ);
  418b66:	8b 44 24 14          	mov    eax,DWORD PTR [rsp+0x14]
  418b6a:	80 f4 20             	xor    ah,0x20
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  418b6d:	a9 00 20 01 00       	test   eax,0x12000
  418b72:	0f 85 98 00 00 00    	jne    418c10 <fmt_fp+0xbf0>
  418b78:	84 db                	test   bl,bl
  418b7a:	0f 85 90 00 00 00    	jne    418c10 <fmt_fp+0xbf0>
	l = w - l;
  418b80:	8b 6c 24 48          	mov    ebp,DWORD PTR [rsp+0x48]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  418b84:	b8 00 01 00 00       	mov    eax,0x100
  418b89:	be 20 00 00 00       	mov    esi,0x20
  418b8e:	4c 8d bc 24 80 01 00 	lea    r15,[rsp+0x180]
  418b95:	00 
  418b96:	4c 89 ff             	mov    rdi,r15
	l = w - l;
  418b99:	44 29 ed             	sub    ebp,r13d
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  418b9c:	39 c5                	cmp    ebp,eax
  418b9e:	0f 4e c5             	cmovle eax,ebp
  418ba1:	48 63 d0             	movsxd rdx,eax
  418ba4:	e8 b3 dc ff ff       	call   41685c <memset>
	for (; l >= sizeof pad; l -= sizeof pad)
  418ba9:	81 fd ff 00 00 00    	cmp    ebp,0xff
  418baf:	0f 8e 18 17 00 00    	jle    41a2cd <fmt_fp+0x22ad>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418bb5:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  418bb9:	8d 9d 00 ff ff ff    	lea    ebx,[rbp-0x100]
  418bbf:	90                   	nop
  418bc0:	83 e0 20             	and    eax,0x20
  418bc3:	0f 84 37 01 00 00    	je     418d00 <fmt_fp+0xce0>
	for (; l >= sizeof pad; l -= sizeof pad)
  418bc9:	81 fb ff 00 00 00    	cmp    ebx,0xff
  418bcf:	7e 3f                	jle    418c10 <fmt_fp+0xbf0>
  418bd1:	8d 93 00 e9 ff ff    	lea    edx,[rbx-0x1700]
  418bd7:	81 fa 00 e9 ff 7f    	cmp    edx,0x7fffe900
  418bdd:	0f 86 15 f1 ff ff    	jbe    417cf8 <fmt_fp.cold+0x26f>
  418be3:	81 eb 00 01 00 00    	sub    ebx,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418be9:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  418beb:	89 dd                	mov    ebp,ebx
  418bed:	81 fb ff 00 00 00    	cmp    ebx,0xff
  418bf3:	77 ee                	ja     418be3 <fmt_fp+0xbc3>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418bf5:	85 d2                	test   edx,edx
  418bf7:	75 17                	jne    418c10 <fmt_fp+0xbf0>
	out(f, pad, l);
  418bf9:	48 63 f5             	movsxd rsi,ebp
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418bfc:	4c 89 e2             	mov    rdx,r12
  418bff:	4c 89 ff             	mov    rdi,r15
  418c02:	e8 19 37 00 00       	call   41c320 <__fwritex>
  418c07:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  418c0e:	00 00 
		return MAX(w, 3+pl);
  418c10:	8b 44 24 48          	mov    eax,DWORD PTR [rsp+0x48]
  418c14:	44 39 e8             	cmp    eax,r13d
  418c17:	41 0f 4c c5          	cmovl  eax,r13d
	}

	pad(f, ' ', w, pl+l, fl^LEFT_ADJ);

	return MAX(w, pl+l);
}
  418c1b:	48 81 c4 38 1e 00 00 	add    rsp,0x1e38
  418c22:	5b                   	pop    rbx
  418c23:	5d                   	pop    rbp
  418c24:	41 5c                	pop    r12
  418c26:	41 5d                	pop    r13
  418c28:	41 5e                	pop    r14
  418c2a:	41 5f                	pop    r15
  418c2c:	c3                   	ret    
	if (a<z) for (i=10, e=9*(r-a); *a>=i; i*=10, e++);
  418c2d:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
	j = p - ((t|32)!='f')*e - ((t|32)=='g' && p);
  418c32:	31 c9                	xor    ecx,ecx
  418c34:	41 83 fe 66          	cmp    r14d,0x66
	if (a<z) for (i=10, e=9*(r-a); *a>=i; i*=10, e++);
  418c38:	8b 55 00             	mov    edx,DWORD PTR [rbp+0x0]
	j = p - ((t|32)!='f')*e - ((t|32)=='g' && p);
  418c3b:	0f 95 c1             	setne  cl
	if (a<z) for (i=10, e=9*(r-a); *a>=i; i*=10, e++);
  418c3e:	48 29 e8             	sub    rax,rbp
  418c41:	48 c1 f8 02          	sar    rax,0x2
  418c45:	8d 3c c0             	lea    edi,[rax+rax*8]
  418c48:	b8 0a 00 00 00       	mov    eax,0xa
  418c4d:	83 fa 09             	cmp    edx,0x9
  418c50:	76 12                	jbe    418c64 <fmt_fp+0xc44>
  418c52:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  418c58:	8d 04 80             	lea    eax,[rax+rax*4]
  418c5b:	83 c7 01             	add    edi,0x1
  418c5e:	01 c0                	add    eax,eax
  418c60:	39 d0                	cmp    eax,edx
  418c62:	76 f4                	jbe    418c58 <fmt_fp+0xc38>
	j = p - ((t|32)!='f')*e - ((t|32)=='g' && p);
  418c64:	0f af cf             	imul   ecx,edi
  418c67:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  418c6a:	29 c8                	sub    eax,ecx
  418c6c:	e9 ce f6 ff ff       	jmp    41833f <fmt_fp+0x31f>
  418c71:	d9 c9                	fxch   st(1)
  418c73:	eb 05                	jmp    418c7a <fmt_fp+0xc5a>
  418c75:	0f 1f 00             	nop    DWORD PTR [rax]
  418c78:	d9 c9                	fxch   st(1)
	if (y) y *= 0x1p28, e2-=28;
  418c7a:	41 83 e9 1c          	sub    r9d,0x1c
  418c7e:	d8 0d 80 72 00 00    	fmul   DWORD PTR [rip+0x7280]        # 41ff04 <states+0x224>
  418c84:	d9 c9                	fxch   st(1)
  418c86:	44 89 4c 24 50       	mov    DWORD PTR [rsp+0x50],r9d
  418c8b:	e9 ae f4 ff ff       	jmp    41813e <fmt_fp+0x11e>
		for (i=10, j++; j<9; i*=10, j++);
  418c90:	f3 0f 7e 05 80 72 00 	movq   xmm0,QWORD PTR [rip+0x7280]        # 41ff18 <states+0x238>
  418c97:	00 
  418c98:	66 0f 7e c2          	movd   edx,xmm0
  418c9c:	66 0f 70 e0 e5       	pshufd xmm4,xmm0,0xe5
  418ca1:	66 0f 7e e0          	movd   eax,xmm4
  418ca5:	0f af d0             	imul   edx,eax
  418ca8:	8d 0c 92             	lea    ecx,[rdx+rdx*4]
  418cab:	01 c9                	add    ecx,ecx
  418cad:	41 83 e0 01          	and    r8d,0x1
  418cb1:	0f 84 51 f7 ff ff    	je     418408 <fmt_fp+0x3e8>
  418cb7:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  418cba:	01 c9                	add    ecx,ecx
  418cbc:	e9 47 f7 ff ff       	jmp    418408 <fmt_fp+0x3e8>
  418cc1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418cc8:	4c 89 e2             	mov    rdx,r12
  418ccb:	be 00 01 00 00       	mov    esi,0x100
  418cd0:	4c 89 ff             	mov    rdi,r15
  418cd3:	e8 48 36 00 00       	call   41c320 <__fwritex>
  418cd8:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
	for (; l >= sizeof pad; l -= sizeof pad)
  418cdc:	45 89 f1             	mov    r9d,r14d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418cdf:	89 c2                	mov    edx,eax
  418ce1:	83 e2 20             	and    edx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  418ce4:	41 81 fe ff 00 00 00 	cmp    r14d,0xff
  418ceb:	0f 8e 54 fe ff ff    	jle    418b45 <fmt_fp+0xb25>
  418cf1:	41 81 ee 00 01 00 00 	sub    r14d,0x100
  418cf8:	e9 0b fe ff ff       	jmp    418b08 <fmt_fp+0xae8>
  418cfd:	0f 1f 00             	nop    DWORD PTR [rax]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418d00:	4c 89 e2             	mov    rdx,r12
  418d03:	be 00 01 00 00       	mov    esi,0x100
  418d08:	4c 89 ff             	mov    rdi,r15
	for (; l >= sizeof pad; l -= sizeof pad)
  418d0b:	89 dd                	mov    ebp,ebx
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418d0d:	e8 0e 36 00 00       	call   41c320 <__fwritex>
  418d12:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  418d16:	89 c2                	mov    edx,eax
  418d18:	83 e2 20             	and    edx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  418d1b:	81 fb ff 00 00 00    	cmp    ebx,0xff
  418d21:	0f 8e ce fe ff ff    	jle    418bf5 <fmt_fp+0xbd5>
  418d27:	81 eb 00 01 00 00    	sub    ebx,0x100
  418d2d:	e9 8e fe ff ff       	jmp    418bc0 <fmt_fp+0xba0>
			if ((*d/i & 1) || (i==1000000000 && d>a && (d[-1]&1)))
  418d32:	a8 01                	test   al,0x1
  418d34:	0f 84 47 14 00 00    	je     41a181 <fmt_fp+0x2161>
				round += 2;
  418d3a:	db 2d 10 72 00 00    	fld    TBYTE PTR [rip+0x7210]        # 41ff50 <states+0x270>
			if (x<i/2) small=0x0.8p0;
  418d40:	d1 f9                	sar    ecx,1
  418d42:	44 39 c1             	cmp    ecx,r8d
  418d45:	0f 87 07 15 00 00    	ja     41a252 <fmt_fp+0x2232>
			else if (x==i/2 && d+1==z) small=0x1.0p0;
  418d4b:	0f 84 12 15 00 00    	je     41a263 <fmt_fp+0x2243>
  418d51:	d9 05 a1 71 00 00    	fld    DWORD PTR [rip+0x71a1]        # 41fef8 <states+0x218>
			else small=0x1.8p0;
  418d57:	d9 05 9f 71 00 00    	fld    DWORD PTR [rip+0x719f]        # 41fefc <states+0x21c>
			if (pl && *prefix=='-') round*=-1, small*=-1;
  418d5d:	44 8b 5c 24 28       	mov    r11d,DWORD PTR [rsp+0x28]
  418d62:	45 85 db             	test   r11d,r11d
  418d65:	74 14                	je     418d7b <fmt_fp+0xd5b>
  418d67:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  418d6c:	80 38 2d             	cmp    BYTE PTR [rax],0x2d
  418d6f:	75 0e                	jne    418d7f <fmt_fp+0xd5f>
  418d71:	dd d8                	fstp   st(0)
  418d73:	d9 c9                	fxch   st(1)
  418d75:	d9 e0                	fchs   
  418d77:	d9 c9                	fxch   st(1)
  418d79:	eb 06                	jmp    418d81 <fmt_fp+0xd61>
  418d7b:	dd d9                	fstp   st(1)
  418d7d:	eb 02                	jmp    418d81 <fmt_fp+0xd61>
  418d7f:	dd d9                	fstp   st(1)
			if (round+small != round) {
  418d81:	d8 c1                	fadd   st,st(1)
			*d -= x;
  418d83:	44 89 c8             	mov    eax,r9d
  418d86:	44 29 c0             	sub    eax,r8d
			if (round+small != round) {
  418d89:	df e9                	fucomip st,st(1)
  418d8b:	dd d8                	fstp   st(0)
  418d8d:	0f 8a 11 0f 00 00    	jp     419ca4 <fmt_fp+0x1c84>
  418d93:	0f 85 0b 0f 00 00    	jne    419ca4 <fmt_fp+0x1c84>
			*d -= x;
  418d99:	89 06                	mov    DWORD PTR [rsi],eax
		if (x || d+1!=z) {
  418d9b:	48 83 c6 04          	add    rsi,0x4
		if (z>d+1) z=d+1;
  418d9f:	48 39 f3             	cmp    rbx,rsi
  418da2:	48 0f 47 de          	cmova  rbx,rsi
	for (; z>a && !z[-1]; z--);
  418da6:	48 39 dd             	cmp    rbp,rbx
  418da9:	72 0e                	jb     418db9 <fmt_fp+0xd99>
  418dab:	eb 15                	jmp    418dc2 <fmt_fp+0xda2>
  418dad:	0f 1f 00             	nop    DWORD PTR [rax]
  418db0:	48 83 eb 04          	sub    rbx,0x4
  418db4:	48 39 eb             	cmp    rbx,rbp
  418db7:	76 09                	jbe    418dc2 <fmt_fp+0xda2>
  418db9:	44 8b 43 fc          	mov    r8d,DWORD PTR [rbx-0x4]
  418dbd:	45 85 c0             	test   r8d,r8d
  418dc0:	74 ee                	je     418db0 <fmt_fp+0xd90>
	if ((t|32)=='g') {
  418dc2:	41 83 fe 67          	cmp    r14d,0x67
  418dc6:	0f 84 53 09 00 00    	je     41971f <fmt_fp+0x16ff>
	if (p > INT_MAX-1-(p || (fl&ALT_FORM)))
  418dcc:	8b 34 24             	mov    esi,DWORD PTR [rsp]
  418dcf:	85 f6                	test   esi,esi
  418dd1:	0f 85 6d 08 00 00    	jne    419644 <fmt_fp+0x1624>
	l = 1 + p + (p || (fl&ALT_FORM));
  418dd7:	44 8b 44 24 14       	mov    r8d,DWORD PTR [rsp+0x14]
  418ddc:	b8 01 00 00 00       	mov    eax,0x1
  418de1:	41 c1 e8 03          	shr    r8d,0x3
  418de5:	41 83 e0 01          	and    r8d,0x1
  418de9:	41 01 c0             	add    r8d,eax
	if ((t|32)=='f') {
  418dec:	44 89 f8             	mov    eax,r15d
		if (e > INT_MAX-l) return -1;
  418def:	41 ba ff ff ff 7f    	mov    r10d,0x7fffffff
	if ((t|32)=='f') {
  418df5:	83 c8 20             	or     eax,0x20
		if (e > INT_MAX-l) return -1;
  418df8:	45 29 c2             	sub    r10d,r8d
	if ((t|32)=='f') {
  418dfb:	89 44 24 08          	mov    DWORD PTR [rsp+0x8],eax
  418dff:	83 f8 66             	cmp    eax,0x66
  418e02:	0f 84 b5 0d 00 00    	je     419bbd <fmt_fp+0x1b9d>
		estr=fmt_u(e<0 ? -e : e, ebuf);
  418e08:	89 fe                	mov    esi,edi
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  418e0a:	4c 8d 6c 24 60       	lea    r13,[rsp+0x60]
		estr=fmt_u(e<0 ? -e : e, ebuf);
  418e0f:	f7 de                	neg    esi
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  418e11:	4c 89 e9             	mov    rcx,r13
		estr=fmt_u(e<0 ? -e : e, ebuf);
  418e14:	0f 48 f7             	cmovs  esi,edi
  418e17:	48 63 f6             	movsxd rsi,esi
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  418e1a:	85 ff                	test   edi,edi
  418e1c:	74 52                	je     418e70 <fmt_fp+0xe50>
  418e1e:	49 b9 cd cc cc cc cc 	movabs r9,0xcccccccccccccccd
  418e25:	cc cc cc 
  418e28:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  418e2f:	00 
  418e30:	48 89 f0             	mov    rax,rsi
  418e33:	48 83 e9 01          	sub    rcx,0x1
  418e37:	49 f7 e1             	mul    r9
  418e3a:	48 89 f0             	mov    rax,rsi
  418e3d:	48 c1 ea 03          	shr    rdx,0x3
  418e41:	4c 8d 1c 92          	lea    r11,[rdx+rdx*4]
  418e45:	4d 01 db             	add    r11,r11
  418e48:	4c 29 d8             	sub    rax,r11
  418e4b:	83 c0 30             	add    eax,0x30
  418e4e:	88 01                	mov    BYTE PTR [rcx],al
  418e50:	48 89 f0             	mov    rax,rsi
  418e53:	48 89 d6             	mov    rsi,rdx
  418e56:	48 83 f8 09          	cmp    rax,0x9
  418e5a:	77 d4                	ja     418e30 <fmt_fp+0xe10>
		while(ebuf-estr<2) *--estr='0';
  418e5c:	4c 89 e8             	mov    rax,r13
  418e5f:	48 29 c8             	sub    rax,rcx
  418e62:	48 83 f8 01          	cmp    rax,0x1
  418e66:	7f 1b                	jg     418e83 <fmt_fp+0xe63>
  418e68:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  418e6f:	00 
  418e70:	48 83 e9 01          	sub    rcx,0x1
  418e74:	4c 89 e8             	mov    rax,r13
  418e77:	c6 01 30             	mov    BYTE PTR [rcx],0x30
  418e7a:	48 29 c8             	sub    rax,rcx
  418e7d:	48 83 f8 01          	cmp    rax,0x1
  418e81:	7e ed                	jle    418e70 <fmt_fp+0xe50>
		*--estr = (e<0 ? '-' : '+');
  418e83:	c1 ff 1f             	sar    edi,0x1f
		*--estr = t;
  418e86:	48 8d 41 fe          	lea    rax,[rcx-0x2]
		if (ebuf-estr > INT_MAX-l) return -1;
  418e8a:	4d 63 d2             	movsxd r10,r10d
		*--estr = t;
  418e8d:	44 88 79 fe          	mov    BYTE PTR [rcx-0x2],r15b
		*--estr = (e<0 ? '-' : '+');
  418e91:	83 e7 02             	and    edi,0x2
		if (ebuf-estr > INT_MAX-l) return -1;
  418e94:	49 29 c5             	sub    r13,rax
		*--estr = t;
  418e97:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
		*--estr = (e<0 ? '-' : '+');
  418e9c:	83 c7 2b             	add    edi,0x2b
  418e9f:	40 88 79 ff          	mov    BYTE PTR [rcx-0x1],dil
		if (ebuf-estr > INT_MAX-l) return -1;
  418ea3:	4d 39 d5             	cmp    r13,r10
  418ea6:	0f 8f b1 07 00 00    	jg     41965d <fmt_fp+0x163d>
		l += ebuf-estr;
  418eac:	45 01 e8             	add    r8d,r13d
	if (l > INT_MAX-pl) return -1;
  418eaf:	8b 4c 24 28          	mov    ecx,DWORD PTR [rsp+0x28]
  418eb3:	89 c8                	mov    eax,ecx
  418eb5:	f7 d8                	neg    eax
  418eb7:	19 c0                	sbb    eax,eax
  418eb9:	05 ff ff ff 7f       	add    eax,0x7fffffff
  418ebe:	44 39 c0             	cmp    eax,r8d
  418ec1:	0f 8c 96 07 00 00    	jl     41965d <fmt_fp+0x163d>
	pad(f, ' ', w, pl+l, fl);
  418ec7:	41 01 c8             	add    r8d,ecx
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  418eca:	44 3b 44 24 48       	cmp    r8d,DWORD PTR [rsp+0x48]
  418ecf:	0f 9d 44 24 28       	setge  BYTE PTR [rsp+0x28]
  418ed4:	0f b6 44 24 28       	movzx  eax,BYTE PTR [rsp+0x28]
	pad(f, ' ', w, pl+l, fl);
  418ed9:	44 89 44 24 38       	mov    DWORD PTR [rsp+0x38],r8d
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  418ede:	f7 44 24 14 00 20 01 	test   DWORD PTR [rsp+0x14],0x12000
  418ee5:	00 
  418ee6:	0f 85 9e 00 00 00    	jne    418f8a <fmt_fp+0xf6a>
  418eec:	84 c0                	test   al,al
  418eee:	0f 85 96 00 00 00    	jne    418f8a <fmt_fp+0xf6a>
	l = w - l;
  418ef4:	44 8b 74 24 48       	mov    r14d,DWORD PTR [rsp+0x48]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  418ef9:	b8 00 01 00 00       	mov    eax,0x100
	l = w - l;
  418efe:	44 2b 74 24 38       	sub    r14d,DWORD PTR [rsp+0x38]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  418f03:	4c 8d bc 24 80 00 00 	lea    r15,[rsp+0x80]
  418f0a:	00 
  418f0b:	41 39 c6             	cmp    r14d,eax
  418f0e:	be 20 00 00 00       	mov    esi,0x20
  418f13:	4c 89 ff             	mov    rdi,r15
  418f16:	41 0f 4e c6          	cmovle eax,r14d
  418f1a:	48 63 d0             	movsxd rdx,eax
  418f1d:	e8 3a d9 ff ff       	call   41685c <memset>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418f22:	41 8b 14 24          	mov    edx,DWORD PTR [r12]
	for (; l >= sizeof pad; l -= sizeof pad)
  418f26:	41 81 fe ff 00 00 00 	cmp    r14d,0xff
  418f2d:	0f 8e ba 13 00 00    	jle    41a2ed <fmt_fp+0x22cd>
  418f33:	45 8d ae 00 ff ff ff 	lea    r13d,[r14-0x100]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418f3a:	89 d0                	mov    eax,edx
  418f3c:	83 e0 20             	and    eax,0x20
  418f3f:	0f 84 73 05 00 00    	je     4194b8 <fmt_fp+0x1498>
	for (; l >= sizeof pad; l -= sizeof pad)
  418f45:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  418f4c:	7e 43                	jle    418f91 <fmt_fp+0xf71>
  418f4e:	41 8d 95 00 e9 ff ff 	lea    edx,[r13-0x1700]
  418f55:	81 fa 00 e9 ff 7f    	cmp    edx,0x7fffe900
  418f5b:	0f 86 17 f0 ff ff    	jbe    417f78 <fmt_fp.cold+0x4ef>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418f61:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  418f63:	41 81 ed 00 01 00 00 	sub    r13d,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418f6a:	89 d0                	mov    eax,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  418f6c:	45 89 ee             	mov    r14d,r13d
  418f6f:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  418f76:	77 eb                	ja     418f63 <fmt_fp+0xf43>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418f78:	85 c0                	test   eax,eax
  418f7a:	75 1d                	jne    418f99 <fmt_fp+0xf79>
	out(f, pad, l);
  418f7c:	49 63 f6             	movsxd rsi,r14d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418f7f:	4c 89 e2             	mov    rdx,r12
  418f82:	4c 89 ff             	mov    rdi,r15
  418f85:	e8 96 33 00 00       	call   41c320 <__fwritex>
  418f8a:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  418f8e:	83 e0 20             	and    eax,0x20
  418f91:	85 c0                	test   eax,eax
  418f93:	0f 84 3c 0c 00 00    	je     419bd5 <fmt_fp+0x1bb5>
	pad(f, '0', w, pl+l, fl^ZERO_PAD);
  418f99:	8b 44 24 14          	mov    eax,DWORD PTR [rsp+0x14]
  418f9d:	35 00 00 01 00       	xor    eax,0x10000
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  418fa2:	a9 00 20 01 00       	test   eax,0x12000
  418fa7:	0f 85 a3 00 00 00    	jne    419050 <fmt_fp+0x1030>
  418fad:	80 7c 24 28 00       	cmp    BYTE PTR [rsp+0x28],0x0
  418fb2:	0f 85 98 00 00 00    	jne    419050 <fmt_fp+0x1030>
	l = w - l;
  418fb8:	44 8b 74 24 48       	mov    r14d,DWORD PTR [rsp+0x48]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  418fbd:	b8 00 01 00 00       	mov    eax,0x100
	l = w - l;
  418fc2:	44 2b 74 24 38       	sub    r14d,DWORD PTR [rsp+0x38]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  418fc7:	4c 8d bc 24 80 00 00 	lea    r15,[rsp+0x80]
  418fce:	00 
  418fcf:	41 39 c6             	cmp    r14d,eax
  418fd2:	be 30 00 00 00       	mov    esi,0x30
  418fd7:	4c 89 ff             	mov    rdi,r15
  418fda:	41 0f 4e c6          	cmovle eax,r14d
  418fde:	48 63 d0             	movsxd rdx,eax
  418fe1:	e8 76 d8 ff ff       	call   41685c <memset>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418fe6:	41 8b 14 24          	mov    edx,DWORD PTR [r12]
	for (; l >= sizeof pad; l -= sizeof pad)
  418fea:	41 81 fe ff 00 00 00 	cmp    r14d,0xff
  418ff1:	0f 8e ec 12 00 00    	jle    41a2e3 <fmt_fp+0x22c3>
  418ff7:	45 8d ae 00 ff ff ff 	lea    r13d,[r14-0x100]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  418ffe:	83 e2 20             	and    edx,0x20
  419001:	0f 84 e9 04 00 00    	je     4194f0 <fmt_fp+0x14d0>
	for (; l >= sizeof pad; l -= sizeof pad)
  419007:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  41900e:	7e 40                	jle    419050 <fmt_fp+0x1030>
  419010:	41 8d 85 00 e9 ff ff 	lea    eax,[r13-0x1700]
  419017:	3d 00 e9 ff 7f       	cmp    eax,0x7fffe900
  41901c:	0f 86 b8 ee ff ff    	jbe    417eda <fmt_fp.cold+0x451>
  419022:	41 81 ed 00 01 00 00 	sub    r13d,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419029:	89 d0                	mov    eax,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  41902b:	45 89 ee             	mov    r14d,r13d
  41902e:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  419035:	77 eb                	ja     419022 <fmt_fp+0x1002>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419037:	85 c0                	test   eax,eax
  419039:	75 15                	jne    419050 <fmt_fp+0x1030>
	out(f, pad, l);
  41903b:	49 63 f6             	movsxd rsi,r14d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41903e:	4c 89 e2             	mov    rdx,r12
  419041:	4c 89 ff             	mov    rdi,r15
  419044:	e8 d7 32 00 00       	call   41c320 <__fwritex>
  419049:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	if ((t|32)=='f') {
  419050:	83 7c 24 08 66       	cmp    DWORD PTR [rsp+0x8],0x66
  419055:	0f 84 88 07 00 00    	je     4197e3 <fmt_fp+0x17c3>
		if (z<=a) z=a+1;
  41905b:	48 8d 45 04          	lea    rax,[rbp+0x4]
  41905f:	48 39 dd             	cmp    rbp,rbx
  419062:	48 0f 43 d8          	cmovae rbx,rax
		for (d=a; d<z && p>=0; d++) {
  419066:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  419069:	85 c0                	test   eax,eax
  41906b:	0f 88 e5 00 00 00    	js     419156 <fmt_fp+0x1136>
  419071:	48 39 eb             	cmp    rbx,rbp
  419074:	0f 86 dc 00 00 00    	jbe    419156 <fmt_fp+0x1136>
  41907a:	4c 89 e7             	mov    rdi,r12
  41907d:	48 8d 4c 24 69       	lea    rcx,[rsp+0x69]
  419082:	48 89 1c 24          	mov    QWORD PTR [rsp],rbx
  419086:	49 89 ec             	mov    r12,rbp
  419089:	66 0f 6f 05 ff 6e 00 	movdqa xmm0,XMMWORD PTR [rip+0x6eff]        # 41ff90 <states+0x2b0>
  419090:	00 
  419091:	48 89 6c 24 08       	mov    QWORD PTR [rsp+0x8],rbp
  419096:	89 c3                	mov    ebx,eax
  419098:	48 89 cd             	mov    rbp,rcx
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  41909b:	49 be cd cc cc cc cc 	movabs r14,0xcccccccccccccccd
  4190a2:	cc cc cc 
  4190a5:	49 89 ff             	mov    r15,rdi
  4190a8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4190af:	00 
			char *s = fmt_u(*d, buf+9);
  4190b0:	41 8b 34 24          	mov    esi,DWORD PTR [r12]
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  4190b4:	48 89 ef             	mov    rdi,rbp
  4190b7:	48 85 f6             	test   rsi,rsi
  4190ba:	0f 84 24 03 00 00    	je     4193e4 <fmt_fp+0x13c4>
  4190c0:	48 89 f0             	mov    rax,rsi
  4190c3:	49 89 fd             	mov    r13,rdi
  4190c6:	48 8d 7f ff          	lea    rdi,[rdi-0x1]
  4190ca:	49 f7 e6             	mul    r14
  4190cd:	48 89 f0             	mov    rax,rsi
  4190d0:	48 c1 ea 03          	shr    rdx,0x3
  4190d4:	48 8d 0c 92          	lea    rcx,[rdx+rdx*4]
  4190d8:	48 01 c9             	add    rcx,rcx
  4190db:	48 29 c8             	sub    rax,rcx
  4190de:	83 c0 30             	add    eax,0x30
  4190e1:	41 88 45 ff          	mov    BYTE PTR [r13-0x1],al
  4190e5:	48 89 f0             	mov    rax,rsi
  4190e8:	48 89 d6             	mov    rsi,rdx
  4190eb:	48 83 f8 09          	cmp    rax,0x9
  4190ef:	77 cf                	ja     4190c0 <fmt_fp+0x10a0>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4190f1:	45 8b 0f             	mov    r9d,DWORD PTR [r15]
			if (s==buf+9) *--s='0';
  4190f4:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  4190f9:	48 39 ef             	cmp    rdi,rbp
  4190fc:	0f 84 e5 02 00 00    	je     4193e7 <fmt_fp+0x13c7>
			if (d!=a) while (s>buf) *--s='0';
  419102:	4c 39 64 24 08       	cmp    QWORD PTR [rsp+0x8],r12
  419107:	0f 85 83 01 00 00    	jne    419290 <fmt_fp+0x1270>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41910d:	41 83 e1 20          	and    r9d,0x20
  419111:	0f 84 f2 02 00 00    	je     419409 <fmt_fp+0x13e9>
				if (p>0||(fl&ALT_FORM)) out(f, ".", 1);
  419117:	8b 44 24 14          	mov    eax,DWORD PTR [rsp+0x14]
  41911b:	41 89 da             	mov    r10d,ebx
  41911e:	83 e0 08             	and    eax,0x8
  419121:	09 d8                	or     eax,ebx
  419123:	0f 85 17 03 00 00    	jne    419440 <fmt_fp+0x1420>
			out(f, s, MIN(buf+9-s, p));
  419129:	49 89 eb             	mov    r11,rbp
  41912c:	45 31 d2             	xor    r10d,r10d
  41912f:	4d 29 eb             	sub    r11,r13
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419132:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
			p -= buf+9-s;
  419138:	44 89 d3             	mov    ebx,r10d
		for (d=a; d<z && p>=0; d++) {
  41913b:	49 83 c4 04          	add    r12,0x4
			p -= buf+9-s;
  41913f:	44 29 db             	sub    ebx,r11d
		for (d=a; d<z && p>=0; d++) {
  419142:	4c 39 24 24          	cmp    QWORD PTR [rsp],r12
  419146:	76 08                	jbe    419150 <fmt_fp+0x1130>
  419148:	85 db                	test   ebx,ebx
  41914a:	0f 89 60 ff ff ff    	jns    4190b0 <fmt_fp+0x1090>
  419150:	89 1c 24             	mov    DWORD PTR [rsp],ebx
  419153:	4d 89 fc             	mov    r12,r15
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  419156:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  419159:	85 c0                	test   eax,eax
  41915b:	0f 8e 95 05 00 00    	jle    4196f6 <fmt_fp+0x16d6>
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  419161:	8b 1c 24             	mov    ebx,DWORD PTR [rsp]
  419164:	81 fb 00 01 00 00    	cmp    ebx,0x100
  41916a:	0f 8f 0a 0b 00 00    	jg     419c7a <fmt_fp+0x1c5a>
  419170:	48 63 eb             	movsxd rbp,ebx
  419173:	4c 8d bc 24 80 00 00 	lea    r15,[rsp+0x80]
  41917a:	00 
  41917b:	be 30 00 00 00       	mov    esi,0x30
  419180:	48 89 ea             	mov    rdx,rbp
  419183:	4c 89 ff             	mov    rdi,r15
  419186:	e8 d1 d6 ff ff       	call   41685c <memset>
	for (; l >= sizeof pad; l -= sizeof pad)
  41918b:	81 fb 00 01 00 00    	cmp    ebx,0x100
  419191:	0f 85 6c 11 00 00    	jne    41a303 <fmt_fp+0x22e3>
  419197:	8b 1c 24             	mov    ebx,DWORD PTR [rsp]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41919a:	41 8b 14 24          	mov    edx,DWORD PTR [r12]
  41919e:	81 eb 00 01 00 00    	sub    ebx,0x100
  4191a4:	89 dd                	mov    ebp,ebx
  4191a6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4191ad:	00 00 00 
  4191b0:	89 d0                	mov    eax,edx
  4191b2:	83 e0 20             	and    eax,0x20
  4191b5:	0f 84 95 02 00 00    	je     419450 <fmt_fp+0x1430>
	for (; l >= sizeof pad; l -= sizeof pad)
  4191bb:	81 fd ff 00 00 00    	cmp    ebp,0xff
  4191c1:	76 12                	jbe    4191d5 <fmt_fp+0x11b5>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4191c3:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  4191c5:	81 ed 00 01 00 00    	sub    ebp,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4191cb:	89 d0                	mov    eax,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  4191cd:	81 fd ff 00 00 00    	cmp    ebp,0xff
  4191d3:	77 f0                	ja     4191c5 <fmt_fp+0x11a5>
	out(f, pad, l);
  4191d5:	0f b6 eb             	movzx  ebp,bl
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4191d8:	85 c0                	test   eax,eax
  4191da:	0f 84 08 05 00 00    	je     4196e8 <fmt_fp+0x16c8>
	pad(f, ' ', w, pl+l, fl^LEFT_ADJ);
  4191e0:	8b 44 24 14          	mov    eax,DWORD PTR [rsp+0x14]
  4191e4:	80 f4 20             	xor    ah,0x20
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  4191e7:	a9 00 20 01 00       	test   eax,0x12000
  4191ec:	0f 85 84 00 00 00    	jne    419276 <fmt_fp+0x1256>
  4191f2:	80 7c 24 28 00       	cmp    BYTE PTR [rsp+0x28],0x0
  4191f7:	75 7d                	jne    419276 <fmt_fp+0x1256>
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  4191f9:	b8 00 01 00 00       	mov    eax,0x100
	l = w - l;
  4191fe:	8b 6c 24 48          	mov    ebp,DWORD PTR [rsp+0x48]
  419202:	2b 6c 24 38          	sub    ebp,DWORD PTR [rsp+0x38]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  419206:	4c 8d bc 24 80 00 00 	lea    r15,[rsp+0x80]
  41920d:	00 
  41920e:	39 c5                	cmp    ebp,eax
  419210:	be 20 00 00 00       	mov    esi,0x20
  419215:	4c 89 ff             	mov    rdi,r15
  419218:	0f 4e c5             	cmovle eax,ebp
  41921b:	48 63 d0             	movsxd rdx,eax
  41921e:	e8 39 d6 ff ff       	call   41685c <memset>
	for (; l >= sizeof pad; l -= sizeof pad)
  419223:	81 fd ff 00 00 00    	cmp    ebp,0xff
  419229:	0f 8e c8 10 00 00    	jle    41a2f7 <fmt_fp+0x22d7>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41922f:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  419233:	8d 9d 00 ff ff ff    	lea    ebx,[rbp-0x100]
  419239:	83 e0 20             	and    eax,0x20
  41923c:	0f 84 3e 02 00 00    	je     419480 <fmt_fp+0x1460>
	for (; l >= sizeof pad; l -= sizeof pad)
  419242:	81 fb ff 00 00 00    	cmp    ebx,0xff
  419248:	7e 2c                	jle    419276 <fmt_fp+0x1256>
  41924a:	8d 93 00 e9 ff ff    	lea    edx,[rbx-0x1700]
  419250:	81 fa 00 e9 ff 7f    	cmp    edx,0x7fffe900
  419256:	0f 86 06 ea ff ff    	jbe    417c62 <fmt_fp.cold+0x1d9>
  41925c:	81 eb 00 01 00 00    	sub    ebx,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419262:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  419264:	89 dd                	mov    ebp,ebx
  419266:	81 fb ff 00 00 00    	cmp    ebx,0xff
  41926c:	77 ee                	ja     41925c <fmt_fp+0x123c>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41926e:	85 d2                	test   edx,edx
  419270:	0f 84 f8 0e 00 00    	je     41a16e <fmt_fp+0x214e>
	return MAX(w, pl+l);
  419276:	8b 5c 24 38          	mov    ebx,DWORD PTR [rsp+0x38]
  41927a:	8b 44 24 48          	mov    eax,DWORD PTR [rsp+0x48]
  41927e:	39 c3                	cmp    ebx,eax
  419280:	0f 4d c3             	cmovge eax,ebx
  419283:	e9 93 f9 ff ff       	jmp    418c1b <fmt_fp+0xbfb>
  419288:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41928f:	00 
			if (d!=a) while (s>buf) *--s='0';
  419290:	48 39 d7             	cmp    rdi,rdx
  419293:	0f 86 61 09 00 00    	jbe    419bfa <fmt_fp+0x1bda>
  419299:	4c 8d 5f ff          	lea    r11,[rdi-0x1]
  41929d:	48 89 f8             	mov    rax,rdi
  4192a0:	be 01 00 00 00       	mov    esi,0x1
  4192a5:	48 29 d0             	sub    rax,rdx
  4192a8:	49 39 d3             	cmp    r11,rdx
  4192ab:	48 0f 43 f0          	cmovae rsi,rax
  4192af:	48 83 e8 01          	sub    rax,0x1
  4192b3:	48 83 f8 0e          	cmp    rax,0xe
  4192b7:	0f 86 dc 09 00 00    	jbe    419c99 <fmt_fp+0x1c79>
  4192bd:	49 39 d3             	cmp    r11,rdx
  4192c0:	0f 82 d3 09 00 00    	jb     419c99 <fmt_fp+0x1c79>
  4192c6:	48 89 f0             	mov    rax,rsi
  4192c9:	49 89 fa             	mov    r10,rdi
  4192cc:	48 83 e0 f0          	and    rax,0xfffffffffffffff0
  4192d0:	49 29 c2             	sub    r10,rax
			if (s==buf+9) *--s='0';
  4192d3:	48 89 f8             	mov    rax,rdi
  4192d6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  4192dd:	00 00 00 
			if (d!=a) while (s>buf) *--s='0';
  4192e0:	0f 11 40 f0          	movups XMMWORD PTR [rax-0x10],xmm0
  4192e4:	48 83 e8 10          	sub    rax,0x10
  4192e8:	4c 39 d0             	cmp    rax,r10
  4192eb:	75 f3                	jne    4192e0 <fmt_fp+0x12c0>
  4192ed:	49 89 f2             	mov    r10,rsi
  4192f0:	48 89 f8             	mov    rax,rdi
  4192f3:	49 83 e2 f0          	and    r10,0xfffffffffffffff0
  4192f7:	4c 29 d0             	sub    rax,r10
  4192fa:	4c 39 d6             	cmp    rsi,r10
  4192fd:	74 7f                	je     41937e <fmt_fp+0x135e>
  4192ff:	4c 29 d6             	sub    rsi,r10
  419302:	4c 8d 6e ff          	lea    r13,[rsi-0x1]
  419306:	49 83 fd 06          	cmp    r13,0x6
  41930a:	76 20                	jbe    41932c <fmt_fp+0x130c>
  41930c:	49 89 fd             	mov    r13,rdi
  41930f:	48 8b 0d 7a 6c 00 00 	mov    rcx,QWORD PTR [rip+0x6c7a]        # 41ff90 <states+0x2b0>
  419316:	4d 29 d5             	sub    r13,r10
  419319:	49 89 f2             	mov    r10,rsi
  41931c:	49 83 e2 f8          	and    r10,0xfffffffffffffff8
  419320:	49 89 4d f8          	mov    QWORD PTR [r13-0x8],rcx
  419324:	4c 29 d0             	sub    rax,r10
  419327:	4c 39 d6             	cmp    rsi,r10
  41932a:	74 52                	je     41937e <fmt_fp+0x135e>
  41932c:	48 8d 70 ff          	lea    rsi,[rax-0x1]
  419330:	c6 40 ff 30          	mov    BYTE PTR [rax-0x1],0x30
  419334:	48 39 f2             	cmp    rdx,rsi
  419337:	73 45                	jae    41937e <fmt_fp+0x135e>
  419339:	48 8d 70 fe          	lea    rsi,[rax-0x2]
  41933d:	c6 40 fe 30          	mov    BYTE PTR [rax-0x2],0x30
  419341:	48 39 f2             	cmp    rdx,rsi
  419344:	73 38                	jae    41937e <fmt_fp+0x135e>
  419346:	48 8d 70 fd          	lea    rsi,[rax-0x3]
  41934a:	c6 40 fd 30          	mov    BYTE PTR [rax-0x3],0x30
  41934e:	48 39 f2             	cmp    rdx,rsi
  419351:	73 2b                	jae    41937e <fmt_fp+0x135e>
  419353:	48 8d 70 fc          	lea    rsi,[rax-0x4]
  419357:	c6 40 fc 30          	mov    BYTE PTR [rax-0x4],0x30
  41935b:	48 39 f2             	cmp    rdx,rsi
  41935e:	73 1e                	jae    41937e <fmt_fp+0x135e>
  419360:	48 8d 70 fb          	lea    rsi,[rax-0x5]
  419364:	c6 40 fb 30          	mov    BYTE PTR [rax-0x5],0x30
  419368:	48 39 f2             	cmp    rdx,rsi
  41936b:	73 11                	jae    41937e <fmt_fp+0x135e>
  41936d:	48 8d 70 fa          	lea    rsi,[rax-0x6]
  419371:	c6 40 fa 30          	mov    BYTE PTR [rax-0x6],0x30
  419375:	48 39 f2             	cmp    rdx,rsi
  419378:	73 04                	jae    41937e <fmt_fp+0x135e>
  41937a:	c6 40 f9 30          	mov    BYTE PTR [rax-0x7],0x30
  41937e:	49 89 d5             	mov    r13,rdx
  419381:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
  419388:	41 89 da             	mov    r10d,ebx
  41938b:	49 29 fd             	sub    r13,rdi
  41938e:	49 39 d3             	cmp    r11,rdx
  419391:	4c 0f 42 e8          	cmovb  r13,rax
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419395:	41 83 e1 20          	and    r9d,0x20
			if (d!=a) while (s>buf) *--s='0';
  419399:	49 01 fd             	add    r13,rdi
			out(f, s, MIN(buf+9-s, p));
  41939c:	49 89 eb             	mov    r11,rbp
  41939f:	4d 29 eb             	sub    r11,r13
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4193a2:	45 85 c9             	test   r9d,r9d
  4193a5:	0f 85 8d fd ff ff    	jne    419138 <fmt_fp+0x1118>
			out(f, s, MIN(buf+9-s, p));
  4193ab:	48 63 db             	movsxd rbx,ebx
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4193ae:	4c 89 fa             	mov    rdx,r15
  4193b1:	4c 89 ef             	mov    rdi,r13
  4193b4:	44 89 54 24 20       	mov    DWORD PTR [rsp+0x20],r10d
			out(f, s, MIN(buf+9-s, p));
  4193b9:	4c 39 db             	cmp    rbx,r11
  4193bc:	4c 89 5c 24 18       	mov    QWORD PTR [rsp+0x18],r11
  4193c1:	49 0f 4f db          	cmovg  rbx,r11
  4193c5:	48 89 de             	mov    rsi,rbx
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4193c8:	e8 53 2f 00 00       	call   41c320 <__fwritex>
  4193cd:	44 8b 54 24 20       	mov    r10d,DWORD PTR [rsp+0x20]
  4193d2:	4c 8b 5c 24 18       	mov    r11,QWORD PTR [rsp+0x18]
  4193d7:	66 0f 6f 05 b1 6b 00 	movdqa xmm0,XMMWORD PTR [rip+0x6bb1]        # 41ff90 <states+0x2b0>
  4193de:	00 
  4193df:	e9 54 fd ff ff       	jmp    419138 <fmt_fp+0x1118>
  4193e4:	45 8b 0f             	mov    r9d,DWORD PTR [r15]
			if (s==buf+9) *--s='0';
  4193e7:	c6 44 24 68 30       	mov    BYTE PTR [rsp+0x68],0x30
			if (d!=a) while (s>buf) *--s='0';
  4193ec:	4c 39 64 24 08       	cmp    QWORD PTR [rsp+0x8],r12
  4193f1:	0f 85 68 01 00 00    	jne    41955f <fmt_fp+0x153f>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4193f7:	41 83 e1 20          	and    r9d,0x20
			if (d!=a) while (s>buf) *--s='0';
  4193fb:	49 89 ed             	mov    r13,rbp
			if (s==buf+9) *--s='0';
  4193fe:	48 8d 7c 24 68       	lea    rdi,[rsp+0x68]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419403:	0f 85 0e fd ff ff    	jne    419117 <fmt_fp+0x10f7>
  419409:	4c 89 fa             	mov    rdx,r15
  41940c:	be 01 00 00 00       	mov    esi,0x1
  419411:	e8 0a 2f 00 00       	call   41c320 <__fwritex>
				if (p>0||(fl&ALT_FORM)) out(f, ".", 1);
  419416:	8b 44 24 14          	mov    eax,DWORD PTR [rsp+0x14]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41941a:	45 8b 0f             	mov    r9d,DWORD PTR [r15]
  41941d:	41 89 da             	mov    r10d,ebx
				if (p>0||(fl&ALT_FORM)) out(f, ".", 1);
  419420:	66 0f 6f 05 68 6b 00 	movdqa xmm0,XMMWORD PTR [rip+0x6b68]        # 41ff90 <states+0x2b0>
  419427:	00 
  419428:	83 e0 08             	and    eax,0x8
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41942b:	41 83 e1 20          	and    r9d,0x20
				if (p>0||(fl&ALT_FORM)) out(f, ".", 1);
  41942f:	09 d8                	or     eax,ebx
  419431:	0f 85 ee 00 00 00    	jne    419525 <fmt_fp+0x1505>
  419437:	45 31 d2             	xor    r10d,r10d
  41943a:	e9 5d ff ff ff       	jmp    41939c <fmt_fp+0x137c>
  41943f:	90                   	nop
			out(f, s, MIN(buf+9-s, p));
  419440:	49 89 eb             	mov    r11,rbp
  419443:	4d 29 eb             	sub    r11,r13
  419446:	e9 ed fc ff ff       	jmp    419138 <fmt_fp+0x1118>
  41944b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419450:	4c 89 e2             	mov    rdx,r12
  419453:	be 00 01 00 00       	mov    esi,0x100
  419458:	4c 89 ff             	mov    rdi,r15
  41945b:	e8 c0 2e 00 00       	call   41c320 <__fwritex>
  419460:	41 8b 14 24          	mov    edx,DWORD PTR [r12]
  419464:	89 d0                	mov    eax,edx
  419466:	83 e0 20             	and    eax,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  419469:	81 fd ff 00 00 00    	cmp    ebp,0xff
  41946f:	0f 86 60 fd ff ff    	jbe    4191d5 <fmt_fp+0x11b5>
  419475:	81 ed 00 01 00 00    	sub    ebp,0x100
  41947b:	e9 30 fd ff ff       	jmp    4191b0 <fmt_fp+0x1190>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419480:	4c 89 e2             	mov    rdx,r12
  419483:	be 00 01 00 00       	mov    esi,0x100
  419488:	4c 89 ff             	mov    rdi,r15
	for (; l >= sizeof pad; l -= sizeof pad)
  41948b:	89 dd                	mov    ebp,ebx
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41948d:	e8 8e 2e 00 00       	call   41c320 <__fwritex>
  419492:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  419496:	89 c2                	mov    edx,eax
  419498:	83 e2 20             	and    edx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41949b:	81 fb ff 00 00 00    	cmp    ebx,0xff
  4194a1:	0f 8e c7 fd ff ff    	jle    41926e <fmt_fp+0x124e>
  4194a7:	81 eb 00 01 00 00    	sub    ebx,0x100
  4194ad:	e9 87 fd ff ff       	jmp    419239 <fmt_fp+0x1219>
  4194b2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4194b8:	4c 89 e2             	mov    rdx,r12
  4194bb:	be 00 01 00 00       	mov    esi,0x100
  4194c0:	4c 89 ff             	mov    rdi,r15
	for (; l >= sizeof pad; l -= sizeof pad)
  4194c3:	45 89 ee             	mov    r14d,r13d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4194c6:	e8 55 2e 00 00       	call   41c320 <__fwritex>
  4194cb:	41 8b 14 24          	mov    edx,DWORD PTR [r12]
  4194cf:	89 d0                	mov    eax,edx
  4194d1:	83 e0 20             	and    eax,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  4194d4:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  4194db:	0f 8e 97 fa ff ff    	jle    418f78 <fmt_fp+0xf58>
  4194e1:	41 81 ed 00 01 00 00 	sub    r13d,0x100
  4194e8:	e9 4d fa ff ff       	jmp    418f3a <fmt_fp+0xf1a>
  4194ed:	0f 1f 00             	nop    DWORD PTR [rax]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4194f0:	4c 89 e2             	mov    rdx,r12
  4194f3:	be 00 01 00 00       	mov    esi,0x100
  4194f8:	4c 89 ff             	mov    rdi,r15
	for (; l >= sizeof pad; l -= sizeof pad)
  4194fb:	45 89 ee             	mov    r14d,r13d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4194fe:	e8 1d 2e 00 00       	call   41c320 <__fwritex>
  419503:	41 8b 14 24          	mov    edx,DWORD PTR [r12]
  419507:	89 d0                	mov    eax,edx
  419509:	83 e0 20             	and    eax,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41950c:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  419513:	0f 8e 1e fb ff ff    	jle    419037 <fmt_fp+0x1017>
  419519:	41 81 ed 00 01 00 00 	sub    r13d,0x100
  419520:	e9 d9 fa ff ff       	jmp    418ffe <fmt_fp+0xfde>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419525:	45 85 c9             	test   r9d,r9d
  419528:	0f 85 12 ff ff ff    	jne    419440 <fmt_fp+0x1420>
  41952e:	4c 89 fa             	mov    rdx,r15
  419531:	be 01 00 00 00       	mov    esi,0x1
  419536:	48 8d 3d 7e 66 00 00 	lea    rdi,[rip+0x667e]        # 41fbbb <CSWTCH.187+0x7cb>
  41953d:	89 5c 24 18          	mov    DWORD PTR [rsp+0x18],ebx
  419541:	e8 da 2d 00 00       	call   41c320 <__fwritex>
  419546:	45 8b 0f             	mov    r9d,DWORD PTR [r15]
  419549:	44 8b 54 24 18       	mov    r10d,DWORD PTR [rsp+0x18]
  41954e:	66 0f 6f 05 3a 6a 00 	movdqa xmm0,XMMWORD PTR [rip+0x6a3a]        # 41ff90 <states+0x2b0>
  419555:	00 
  419556:	41 83 e1 20          	and    r9d,0x20
  41955a:	e9 3d fe ff ff       	jmp    41939c <fmt_fp+0x137c>
			if (s==buf+9) *--s='0';
  41955f:	48 8d 7c 24 68       	lea    rdi,[rsp+0x68]
  419564:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  419569:	e9 2b fd ff ff       	jmp    419299 <fmt_fp+0x1279>
			if (s-buf==1 && (y||p>0||(fl&ALT_FORM))) *s++='.';
  41956e:	c6 42 01 2e          	mov    BYTE PTR [rdx+0x1],0x2e
  419572:	48 83 c2 02          	add    rdx,0x2
  419576:	e9 c8 f0 ff ff       	jmp    418643 <fmt_fp+0x623>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41957b:	4c 89 e2             	mov    rdx,r12
  41957e:	be 00 01 00 00       	mov    esi,0x100
  419583:	4c 89 ff             	mov    rdi,r15
  419586:	e8 95 2d 00 00       	call   41c320 <__fwritex>
  41958b:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
	for (; l >= sizeof pad; l -= sizeof pad)
  41958f:	41 89 d8             	mov    r8d,ebx
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419592:	89 c2                	mov    edx,eax
  419594:	83 e2 20             	and    edx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  419597:	81 fb ff 00 00 00    	cmp    ebx,0xff
  41959d:	0f 8e 7b 0e 00 00    	jle    41a41e <fmt_fp+0x23fe>
  4195a3:	81 eb 00 01 00 00    	sub    ebx,0x100
  4195a9:	e9 d9 f1 ff ff       	jmp    418787 <fmt_fp+0x767>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4195ae:	4c 89 e2             	mov    rdx,r12
  4195b1:	be 00 01 00 00       	mov    esi,0x100
  4195b6:	4c 89 ff             	mov    rdi,r15
	for (; l >= sizeof pad; l -= sizeof pad)
  4195b9:	89 dd                	mov    ebp,ebx
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4195bb:	e8 60 2d 00 00       	call   41c320 <__fwritex>
  4195c0:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  4195c4:	89 c2                	mov    edx,eax
  4195c6:	83 e2 20             	and    edx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  4195c9:	81 fb ff 00 00 00    	cmp    ebx,0xff
  4195cf:	0f 8f ff f2 ff ff    	jg     4188d4 <fmt_fp+0x8b4>
  4195d5:	e9 38 f3 ff ff       	jmp    418912 <fmt_fp+0x8f2>
  4195da:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4195e0:	4c 89 e2             	mov    rdx,r12
  4195e3:	be 00 01 00 00       	mov    esi,0x100
  4195e8:	4c 89 ff             	mov    rdi,r15
  4195eb:	e8 30 2d 00 00       	call   41c320 <__fwritex>
  4195f0:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
	for (; l >= sizeof pad; l -= sizeof pad)
  4195f4:	89 d9                	mov    ecx,ebx
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4195f6:	89 c2                	mov    edx,eax
  4195f8:	83 e2 20             	and    edx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  4195fb:	81 fb ff 00 00 00    	cmp    ebx,0xff
  419601:	0f 8e 85 f2 ff ff    	jle    41888c <fmt_fp+0x86c>
  419607:	81 eb 00 01 00 00    	sub    ebx,0x100
  41960d:	e9 3e f2 ff ff       	jmp    418850 <fmt_fp+0x830>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419612:	4c 89 e2             	mov    rdx,r12
  419615:	be 00 01 00 00       	mov    esi,0x100
  41961a:	4c 89 ff             	mov    rdi,r15
	for (; l >= sizeof pad; l -= sizeof pad)
  41961d:	89 dd                	mov    ebp,ebx
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41961f:	e8 fc 2c 00 00       	call   41c320 <__fwritex>
  419624:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  419628:	89 c2                	mov    edx,eax
  41962a:	83 e2 20             	and    edx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41962d:	81 fb ff 00 00 00    	cmp    ebx,0xff
  419633:	0f 8e 94 f3 ff ff    	jle    4189cd <fmt_fp+0x9ad>
  419639:	81 eb 00 01 00 00    	sub    ebx,0x100
  41963f:	e9 54 f3 ff ff       	jmp    418998 <fmt_fp+0x978>
	l = 1 + p + (p || (fl&ALT_FORM));
  419644:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  419647:	41 b8 01 00 00 00    	mov    r8d,0x1
  41964d:	83 c0 01             	add    eax,0x1
	if (p > INT_MAX-1-(p || (fl&ALT_FORM)))
  419650:	81 3c 24 fd ff ff 7f 	cmp    DWORD PTR [rsp],0x7ffffffd
  419657:	0f 8e 8c f7 ff ff    	jle    418de9 <fmt_fp+0xdc9>
			return -1;
  41965d:	b8 ff ff ff ff       	mov    eax,0xffffffff
  419662:	e9 b4 f5 ff ff       	jmp    418c1b <fmt_fp+0xbfb>
  419667:	c6 44 24 38 01       	mov    BYTE PTR [rsp+0x38],0x1
	if (p<0) p=6;
  41966c:	c7 04 24 06 00 00 00 	mov    DWORD PTR [rsp],0x6
  419673:	e9 b2 ea ff ff       	jmp    41812a <fmt_fp+0x10a>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419678:	48 8b 74 24 30       	mov    rsi,QWORD PTR [rsp+0x30]
  41967d:	48 8b 7c 24 20       	mov    rdi,QWORD PTR [rsp+0x20]
  419682:	4c 89 e2             	mov    rdx,r12
  419685:	e8 96 2c 00 00       	call   41c320 <__fwritex>
  41968a:	41 f6 04 24 20       	test   BYTE PTR [r12],0x20
  41968f:	0f 85 d1 f4 ff ff    	jne    418b66 <fmt_fp+0xb46>
  419695:	4c 89 e2             	mov    rdx,r12
  419698:	be 03 00 00 00       	mov    esi,0x3
  41969d:	48 89 ef             	mov    rdi,rbp
  4196a0:	e8 7b 2c 00 00       	call   41c320 <__fwritex>
  4196a5:	e9 bc f4 ff ff       	jmp    418b66 <fmt_fp+0xb46>
	out(f, pad, l);
  4196aa:	48 63 f1             	movsxd rsi,ecx
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4196ad:	4c 89 e2             	mov    rdx,r12
  4196b0:	4c 89 ff             	mov    rdi,r15
  4196b3:	e8 68 2c 00 00       	call   41c320 <__fwritex>
  4196b8:	41 8b 14 24          	mov    edx,DWORD PTR [r12]
  4196bc:	83 e2 20             	and    edx,0x20
  4196bf:	85 d2                	test   edx,edx
  4196c1:	0f 85 cd f1 ff ff    	jne    418894 <fmt_fp+0x874>
  4196c7:	48 8b 74 24 38       	mov    rsi,QWORD PTR [rsp+0x38]
  4196cc:	4c 89 e2             	mov    rdx,r12
  4196cf:	4c 89 ef             	mov    rdi,r13
  4196d2:	e8 49 2c 00 00       	call   41c320 <__fwritex>
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  4196d7:	8b 5c 24 30          	mov    ebx,DWORD PTR [rsp+0x30]
  4196db:	85 ed                	test   ebp,ebp
  4196dd:	0f 8f bb f1 ff ff    	jg     41889e <fmt_fp+0x87e>
  4196e3:	e9 3c f2 ff ff       	jmp    418924 <fmt_fp+0x904>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  4196e8:	4c 89 e2             	mov    rdx,r12
  4196eb:	48 89 ee             	mov    rsi,rbp
  4196ee:	4c 89 ff             	mov    rdi,r15
  4196f1:	e8 2a 2c 00 00       	call   41c320 <__fwritex>
  4196f6:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  4196fa:	83 e0 20             	and    eax,0x20
  4196fd:	85 c0                	test   eax,eax
  4196ff:	0f 85 db fa ff ff    	jne    4191e0 <fmt_fp+0x11c0>
		out(f, estr, ebuf-estr);
  419705:	48 8b 7c 24 40       	mov    rdi,QWORD PTR [rsp+0x40]
  41970a:	48 8d 74 24 60       	lea    rsi,[rsp+0x60]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41970f:	4c 89 e2             	mov    rdx,r12
		out(f, estr, ebuf-estr);
  419712:	48 29 fe             	sub    rsi,rdi
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419715:	e8 06 2c 00 00       	call   41c320 <__fwritex>
  41971a:	e9 c1 fa ff ff       	jmp    4191e0 <fmt_fp+0x11c0>
		if (!p) p++;
  41971f:	8b 0c 24             	mov    ecx,DWORD PTR [rsp]
  419722:	b8 01 00 00 00       	mov    eax,0x1
  419727:	85 c9                	test   ecx,ecx
  419729:	0f 45 c1             	cmovne eax,ecx
  41972c:	89 04 24             	mov    DWORD PTR [rsp],eax
  41972f:	89 c1                	mov    ecx,eax
		if (p>e && e>=-4) {
  419731:	39 f8                	cmp    eax,edi
  419733:	0f 8e 05 0a 00 00    	jle    41a13e <fmt_fp+0x211e>
  419739:	83 ff fc             	cmp    edi,0xfffffffc
  41973c:	0f 8c fc 09 00 00    	jl     41a13e <fmt_fp+0x211e>
			p-=e+1;
  419742:	8d 47 01             	lea    eax,[rdi+0x1]
			t--;
  419745:	41 83 ef 01          	sub    r15d,0x1
			p-=e+1;
  419749:	29 c1                	sub    ecx,eax
  41974b:	89 0c 24             	mov    DWORD PTR [rsp],ecx
		if (!(fl&ALT_FORM)) {
  41974e:	f6 44 24 14 08       	test   BYTE PTR [rsp+0x14],0x8
  419753:	0f 85 73 f6 ff ff    	jne    418dcc <fmt_fp+0xdac>
			if (z>a && z[-1]) for (i=10, j=0; z[-1]%i==0; i*=10, j++);
  419759:	be 09 00 00 00       	mov    esi,0x9
  41975e:	48 39 dd             	cmp    rbp,rbx
  419761:	73 3a                	jae    41979d <fmt_fp+0x177d>
  419763:	44 8b 43 fc          	mov    r8d,DWORD PTR [rbx-0x4]
  419767:	45 85 c0             	test   r8d,r8d
  41976a:	74 31                	je     41979d <fmt_fp+0x177d>
  41976c:	41 69 c0 cd cc cc cc 	imul   eax,r8d,0xcccccccd
  419773:	d1 c8                	ror    eax,1
  419775:	3d 99 99 99 19       	cmp    eax,0x19999999
  41977a:	0f 87 55 0c 00 00    	ja     41a3d5 <fmt_fp+0x23b5>
  419780:	31 f6                	xor    esi,esi
  419782:	b9 0a 00 00 00       	mov    ecx,0xa
  419787:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  41978a:	44 89 c0             	mov    eax,r8d
  41978d:	31 d2                	xor    edx,edx
  41978f:	83 c6 01             	add    esi,0x1
  419792:	01 c9                	add    ecx,ecx
  419794:	f7 f1                	div    ecx
  419796:	85 d2                	test   edx,edx
  419798:	74 ed                	je     419787 <fmt_fp+0x1767>
				p = MIN(p,MAX(0,9*(z-r-1)-j));
  41979a:	48 63 f6             	movsxd rsi,esi
  41979d:	48 89 d8             	mov    rax,rbx
  4197a0:	48 2b 44 24 18       	sub    rax,QWORD PTR [rsp+0x18]
  4197a5:	48 63 14 24          	movsxd rdx,DWORD PTR [rsp]
  4197a9:	48 c1 f8 02          	sar    rax,0x2
  4197ad:	48 8d 4c c0 f7       	lea    rcx,[rax+rax*8-0x9]
			if ((t|32)=='f')
  4197b2:	44 89 f8             	mov    eax,r15d
  4197b5:	83 c8 20             	or     eax,0x20
  4197b8:	83 f8 66             	cmp    eax,0x66
  4197bb:	0f 84 15 0a 00 00    	je     41a1d6 <fmt_fp+0x21b6>
				p = MIN(p,MAX(0,9*(z-r-1)+e-j));
  4197c1:	48 63 c7             	movsxd rax,edi
  4197c4:	48 01 c8             	add    rax,rcx
  4197c7:	48 29 f0             	sub    rax,rsi
  4197ca:	b9 00 00 00 00       	mov    ecx,0x0
  4197cf:	48 0f 48 c1          	cmovs  rax,rcx
  4197d3:	48 39 d0             	cmp    rax,rdx
  4197d6:	48 0f 4e d0          	cmovle rdx,rax
  4197da:	48 89 14 24          	mov    QWORD PTR [rsp],rdx
  4197de:	e9 e9 f5 ff ff       	jmp    418dcc <fmt_fp+0xdac>
		if (a>r) a=r;
  4197e3:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
			if (d!=a) while (s>buf) *--s='0';
  4197e8:	4c 8d 7c 24 69       	lea    r15,[rsp+0x69]
  4197ed:	4c 8b 15 9c 67 00 00 	mov    r10,QWORD PTR [rip+0x679c]        # 41ff90 <states+0x2b0>
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  4197f4:	49 bd cd cc cc cc cc 	movabs r13,0xcccccccccccccccd
  4197fb:	cc cc cc 
  4197fe:	66 0f 6f 05 8a 67 00 	movdqa xmm0,XMMWORD PTR [rip+0x678a]        # 41ff90 <states+0x2b0>
  419805:	00 
  419806:	4c 89 ff             	mov    rdi,r15
  419809:	48 39 e8             	cmp    rax,rbp
  41980c:	48 0f 46 e8          	cmovbe rbp,rax
	if ((t|32)=='f') {
  419810:	49 89 ee             	mov    r14,rbp
			char *s = fmt_u(*d, buf+9);
  419813:	41 8b 0e             	mov    ecx,DWORD PTR [r14]
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  419816:	48 85 c9             	test   rcx,rcx
  419819:	0f 84 8e 03 00 00    	je     419bad <fmt_fp+0x1b8d>
  41981f:	90                   	nop
  419820:	48 89 c8             	mov    rax,rcx
  419823:	48 83 ef 01          	sub    rdi,0x1
  419827:	49 f7 e5             	mul    r13
  41982a:	48 89 c8             	mov    rax,rcx
  41982d:	48 c1 ea 03          	shr    rdx,0x3
  419831:	48 8d 34 92          	lea    rsi,[rdx+rdx*4]
  419835:	48 01 f6             	add    rsi,rsi
  419838:	48 29 f0             	sub    rax,rsi
  41983b:	83 c0 30             	add    eax,0x30
  41983e:	88 07                	mov    BYTE PTR [rdi],al
  419840:	48 89 c8             	mov    rax,rcx
  419843:	48 89 d1             	mov    rcx,rdx
  419846:	48 83 f8 09          	cmp    rax,0x9
  41984a:	77 d4                	ja     419820 <fmt_fp+0x1800>
			if (d!=a) while (s>buf) *--s='0';
  41984c:	4c 39 f5             	cmp    rbp,r14
  41984f:	0f 84 fb 02 00 00    	je     419b50 <fmt_fp+0x1b30>
  419855:	48 8d 74 24 60       	lea    rsi,[rsp+0x60]
  41985a:	48 39 f7             	cmp    rdi,rsi
  41985d:	0f 86 eb 00 00 00    	jbe    41994e <fmt_fp+0x192e>
  419863:	4c 8d 47 ff          	lea    r8,[rdi-0x1]
  419867:	48 89 f8             	mov    rax,rdi
  41986a:	b9 01 00 00 00       	mov    ecx,0x1
  41986f:	48 29 f0             	sub    rax,rsi
  419872:	49 39 f0             	cmp    r8,rsi
  419875:	48 0f 43 c8          	cmovae rcx,rax
  419879:	48 83 e8 01          	sub    rax,0x1
  41987d:	48 83 f8 0e          	cmp    rax,0xe
  419881:	0f 86 d3 08 00 00    	jbe    41a15a <fmt_fp+0x213a>
  419887:	49 39 f0             	cmp    r8,rsi
  41988a:	0f 82 ca 08 00 00    	jb     41a15a <fmt_fp+0x213a>
  419890:	48 89 c8             	mov    rax,rcx
  419893:	48 89 fa             	mov    rdx,rdi
  419896:	48 83 e0 f0          	and    rax,0xfffffffffffffff0
  41989a:	48 29 c2             	sub    rdx,rax
  41989d:	48 89 f8             	mov    rax,rdi
  4198a0:	0f 11 40 f0          	movups XMMWORD PTR [rax-0x10],xmm0
  4198a4:	48 83 e8 10          	sub    rax,0x10
  4198a8:	48 39 c2             	cmp    rdx,rax
  4198ab:	75 f3                	jne    4198a0 <fmt_fp+0x1880>
  4198ad:	48 89 ca             	mov    rdx,rcx
  4198b0:	48 89 f8             	mov    rax,rdi
  4198b3:	48 83 e2 f0          	and    rdx,0xfffffffffffffff0
  4198b7:	48 29 d0             	sub    rax,rdx
  4198ba:	48 39 d1             	cmp    rcx,rdx
  4198bd:	74 78                	je     419937 <fmt_fp+0x1917>
  4198bf:	48 29 d1             	sub    rcx,rdx
  4198c2:	4c 8d 49 ff          	lea    r9,[rcx-0x1]
  4198c6:	49 83 f9 06          	cmp    r9,0x6
  4198ca:	76 19                	jbe    4198e5 <fmt_fp+0x18c5>
  4198cc:	49 89 f9             	mov    r9,rdi
  4198cf:	49 29 d1             	sub    r9,rdx
  4198d2:	48 89 ca             	mov    rdx,rcx
  4198d5:	48 83 e2 f8          	and    rdx,0xfffffffffffffff8
  4198d9:	4d 89 51 f8          	mov    QWORD PTR [r9-0x8],r10
  4198dd:	48 29 d0             	sub    rax,rdx
  4198e0:	48 39 d1             	cmp    rcx,rdx
  4198e3:	74 52                	je     419937 <fmt_fp+0x1917>
  4198e5:	48 8d 50 ff          	lea    rdx,[rax-0x1]
  4198e9:	c6 40 ff 30          	mov    BYTE PTR [rax-0x1],0x30
  4198ed:	48 39 d6             	cmp    rsi,rdx
  4198f0:	73 45                	jae    419937 <fmt_fp+0x1917>
  4198f2:	48 8d 50 fe          	lea    rdx,[rax-0x2]
  4198f6:	c6 40 fe 30          	mov    BYTE PTR [rax-0x2],0x30
  4198fa:	48 39 d6             	cmp    rsi,rdx
  4198fd:	73 38                	jae    419937 <fmt_fp+0x1917>
  4198ff:	48 8d 50 fd          	lea    rdx,[rax-0x3]
  419903:	c6 40 fd 30          	mov    BYTE PTR [rax-0x3],0x30
  419907:	48 39 d6             	cmp    rsi,rdx
  41990a:	73 2b                	jae    419937 <fmt_fp+0x1917>
  41990c:	48 8d 50 fc          	lea    rdx,[rax-0x4]
  419910:	c6 40 fc 30          	mov    BYTE PTR [rax-0x4],0x30
  419914:	48 39 d6             	cmp    rsi,rdx
  419917:	73 1e                	jae    419937 <fmt_fp+0x1917>
  419919:	48 8d 50 fb          	lea    rdx,[rax-0x5]
  41991d:	c6 40 fb 30          	mov    BYTE PTR [rax-0x5],0x30
  419921:	48 39 d6             	cmp    rsi,rdx
  419924:	73 11                	jae    419937 <fmt_fp+0x1917>
  419926:	48 8d 50 fa          	lea    rdx,[rax-0x6]
  41992a:	c6 40 fa 30          	mov    BYTE PTR [rax-0x6],0x30
  41992e:	48 39 d6             	cmp    rsi,rdx
  419931:	73 04                	jae    419937 <fmt_fp+0x1917>
  419933:	c6 40 f9 30          	mov    BYTE PTR [rax-0x7],0x30
  419937:	48 89 f0             	mov    rax,rsi
  41993a:	48 c7 c2 ff ff ff ff 	mov    rdx,0xffffffffffffffff
  419941:	48 29 f8             	sub    rax,rdi
  419944:	49 39 f0             	cmp    r8,rsi
  419947:	48 0f 42 c2          	cmovb  rax,rdx
  41994b:	48 01 c7             	add    rdi,rax
			out(f, s, buf+9-s);
  41994e:	4c 89 fe             	mov    rsi,r15
  419951:	48 29 fe             	sub    rsi,rdi
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419954:	41 f6 04 24 20       	test   BYTE PTR [r12],0x20
  419959:	0f 84 19 02 00 00    	je     419b78 <fmt_fp+0x1b58>
		for (d=a; d<=r; d++) {
  41995f:	49 8d 7e 04          	lea    rdi,[r14+0x4]
  419963:	48 3b 7c 24 18       	cmp    rdi,QWORD PTR [rsp+0x18]
  419968:	0f 87 68 01 00 00    	ja     419ad6 <fmt_fp+0x1ab6>
			if (d!=a) while (s>buf) *--s='0';
  41996e:	4c 8d 54 24 69       	lea    r10,[rsp+0x69]
  419973:	4c 8d 4c 24 60       	lea    r9,[rsp+0x60]
  419978:	4c 8b 3d 11 66 00 00 	mov    r15,QWORD PTR [rip+0x6611]        # 41ff90 <states+0x2b0>
  41997f:	66 0f 6f 05 09 66 00 	movdqa xmm0,XMMWORD PTR [rip+0x6609]        # 41ff90 <states+0x2b0>
  419986:	00 
  419987:	41 be 01 00 00 00    	mov    r14d,0x1
  41998d:	49 c7 c3 f8 ff ff ff 	mov    r11,0xfffffffffffffff8
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  419994:	49 b8 cd cc cc cc cc 	movabs r8,0xcccccccccccccccd
  41999b:	cc cc cc 
			char *s = fmt_u(*d, buf+9);
  41999e:	8b 0f                	mov    ecx,DWORD PTR [rdi]
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  4199a0:	4c 89 d6             	mov    rsi,r10
  4199a3:	48 85 c9             	test   rcx,rcx
  4199a6:	0f 84 40 02 00 00    	je     419bec <fmt_fp+0x1bcc>
  4199ac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  4199b0:	48 89 c8             	mov    rax,rcx
  4199b3:	48 83 ee 01          	sub    rsi,0x1
  4199b7:	49 f7 e0             	mul    r8
  4199ba:	48 89 c8             	mov    rax,rcx
  4199bd:	48 c1 ea 03          	shr    rdx,0x3
  4199c1:	4c 8d 2c 92          	lea    r13,[rdx+rdx*4]
  4199c5:	4d 01 ed             	add    r13,r13
  4199c8:	4c 29 e8             	sub    rax,r13
  4199cb:	83 c0 30             	add    eax,0x30
  4199ce:	88 06                	mov    BYTE PTR [rsi],al
  4199d0:	48 89 c8             	mov    rax,rcx
  4199d3:	48 89 d1             	mov    rcx,rdx
  4199d6:	48 83 f8 09          	cmp    rax,0x9
  4199da:	77 d4                	ja     4199b0 <fmt_fp+0x1990>
			if (d!=a) while (s>buf) *--s='0';
  4199dc:	48 39 fd             	cmp    rbp,rdi
  4199df:	0f 84 5b 01 00 00    	je     419b40 <fmt_fp+0x1b20>
  4199e5:	4c 39 ce             	cmp    rsi,r9
  4199e8:	0f 86 d9 00 00 00    	jbe    419ac7 <fmt_fp+0x1aa7>
  4199ee:	4c 8d 6e ff          	lea    r13,[rsi-0x1]
  4199f2:	48 89 f1             	mov    rcx,rsi
  4199f5:	4c 89 f2             	mov    rdx,r14
  4199f8:	48 89 f0             	mov    rax,rsi
  4199fb:	4c 29 c9             	sub    rcx,r9
  4199fe:	4d 39 cd             	cmp    r13,r9
  419a01:	48 0f 43 d1          	cmovae rdx,rcx
  419a05:	48 83 e9 01          	sub    rcx,0x1
  419a09:	48 83 f9 0e          	cmp    rcx,0xe
  419a0d:	0f 86 51 07 00 00    	jbe    41a164 <fmt_fp+0x2144>
  419a13:	4d 39 cd             	cmp    r13,r9
  419a16:	0f 82 48 07 00 00    	jb     41a164 <fmt_fp+0x2144>
  419a1c:	49 89 d5             	mov    r13,rdx
  419a1f:	48 89 f1             	mov    rcx,rsi
  419a22:	49 83 e5 f0          	and    r13,0xfffffffffffffff0
  419a26:	4c 29 e9             	sub    rcx,r13
  419a29:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  419a30:	0f 11 40 f0          	movups XMMWORD PTR [rax-0x10],xmm0
  419a34:	48 83 e8 10          	sub    rax,0x10
  419a38:	48 39 c1             	cmp    rcx,rax
  419a3b:	75 f3                	jne    419a30 <fmt_fp+0x1a10>
  419a3d:	48 89 d1             	mov    rcx,rdx
  419a40:	48 89 f0             	mov    rax,rsi
  419a43:	48 83 e1 f0          	and    rcx,0xfffffffffffffff0
  419a47:	48 29 c8             	sub    rax,rcx
  419a4a:	48 39 d1             	cmp    rcx,rdx
  419a4d:	74 78                	je     419ac7 <fmt_fp+0x1aa7>
  419a4f:	48 29 ca             	sub    rdx,rcx
  419a52:	4c 8d 6a ff          	lea    r13,[rdx-0x1]
  419a56:	49 83 fd 06          	cmp    r13,0x6
  419a5a:	76 19                	jbe    419a75 <fmt_fp+0x1a55>
  419a5c:	4d 89 dd             	mov    r13,r11
  419a5f:	49 29 cd             	sub    r13,rcx
  419a62:	48 89 d1             	mov    rcx,rdx
  419a65:	48 83 e1 f8          	and    rcx,0xfffffffffffffff8
  419a69:	4e 89 3c 2e          	mov    QWORD PTR [rsi+r13*1],r15
  419a6d:	48 29 c8             	sub    rax,rcx
  419a70:	48 39 ca             	cmp    rdx,rcx
  419a73:	74 52                	je     419ac7 <fmt_fp+0x1aa7>
  419a75:	48 8d 50 ff          	lea    rdx,[rax-0x1]
  419a79:	c6 40 ff 30          	mov    BYTE PTR [rax-0x1],0x30
  419a7d:	49 39 d1             	cmp    r9,rdx
  419a80:	73 45                	jae    419ac7 <fmt_fp+0x1aa7>
  419a82:	48 8d 50 fe          	lea    rdx,[rax-0x2]
  419a86:	c6 40 fe 30          	mov    BYTE PTR [rax-0x2],0x30
  419a8a:	49 39 d1             	cmp    r9,rdx
  419a8d:	73 38                	jae    419ac7 <fmt_fp+0x1aa7>
  419a8f:	48 8d 50 fd          	lea    rdx,[rax-0x3]
  419a93:	c6 40 fd 30          	mov    BYTE PTR [rax-0x3],0x30
  419a97:	49 39 d1             	cmp    r9,rdx
  419a9a:	73 2b                	jae    419ac7 <fmt_fp+0x1aa7>
  419a9c:	48 8d 50 fc          	lea    rdx,[rax-0x4]
  419aa0:	c6 40 fc 30          	mov    BYTE PTR [rax-0x4],0x30
  419aa4:	49 39 d1             	cmp    r9,rdx
  419aa7:	73 1e                	jae    419ac7 <fmt_fp+0x1aa7>
  419aa9:	48 8d 50 fb          	lea    rdx,[rax-0x5]
  419aad:	c6 40 fb 30          	mov    BYTE PTR [rax-0x5],0x30
  419ab1:	49 39 d1             	cmp    r9,rdx
  419ab4:	73 11                	jae    419ac7 <fmt_fp+0x1aa7>
  419ab6:	48 8d 50 fa          	lea    rdx,[rax-0x6]
  419aba:	c6 40 fa 30          	mov    BYTE PTR [rax-0x6],0x30
  419abe:	49 39 d1             	cmp    r9,rdx
  419ac1:	73 04                	jae    419ac7 <fmt_fp+0x1aa7>
  419ac3:	c6 40 f9 30          	mov    BYTE PTR [rax-0x7],0x30
		for (d=a; d<=r; d++) {
  419ac7:	48 83 c7 04          	add    rdi,0x4
  419acb:	48 39 7c 24 18       	cmp    QWORD PTR [rsp+0x18],rdi
  419ad0:	0f 83 c8 fe ff ff    	jae    41999e <fmt_fp+0x197e>
  419ad6:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  419adb:	48 89 c8             	mov    rax,rcx
  419ade:	48 83 c1 01          	add    rcx,0x1
  419ae2:	48 29 e8             	sub    rax,rbp
  419ae5:	48 c1 e8 02          	shr    rax,0x2
  419ae9:	4c 8d 0c 85 04 00 00 	lea    r9,[rax*4+0x4]
  419af0:	00 
  419af1:	48 8d 45 01          	lea    rax,[rbp+0x1]
  419af5:	48 39 c1             	cmp    rcx,rax
  419af8:	b8 04 00 00 00       	mov    eax,0x4
		if (p || (fl&ALT_FORM)) out(f, ".", 1);
  419afd:	8b 0c 24             	mov    ecx,DWORD PTR [rsp]
		for (d=a; d<=r; d++) {
  419b00:	4c 0f 42 c8          	cmovb  r9,rax
  419b04:	4e 8d 74 0d 00       	lea    r14,[rbp+r9*1+0x0]
		if (p || (fl&ALT_FORM)) out(f, ".", 1);
  419b09:	85 c9                	test   ecx,ecx
  419b0b:	0f 85 35 02 00 00    	jne    419d46 <fmt_fp+0x1d26>
  419b11:	f6 44 24 14 08       	test   BYTE PTR [rsp+0x14],0x8
  419b16:	0f 84 c4 f6 ff ff    	je     4191e0 <fmt_fp+0x11c0>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419b1c:	41 f6 04 24 20       	test   BYTE PTR [r12],0x20
  419b21:	0f 85 b9 f6 ff ff    	jne    4191e0 <fmt_fp+0x11c0>
  419b27:	4c 89 e2             	mov    rdx,r12
  419b2a:	be 01 00 00 00       	mov    esi,0x1
  419b2f:	48 8d 3d 85 60 00 00 	lea    rdi,[rip+0x6085]        # 41fbbb <CSWTCH.187+0x7cb>
  419b36:	e8 e5 27 00 00       	call   41c320 <__fwritex>
  419b3b:	e9 11 02 00 00       	jmp    419d51 <fmt_fp+0x1d31>
			else if (s==buf+9) *--s='0';
  419b40:	4c 39 d6             	cmp    rsi,r10
  419b43:	75 82                	jne    419ac7 <fmt_fp+0x1aa7>
  419b45:	c6 44 24 68 30       	mov    BYTE PTR [rsp+0x68],0x30
  419b4a:	e9 78 ff ff ff       	jmp    419ac7 <fmt_fp+0x1aa7>
  419b4f:	90                   	nop
  419b50:	4c 39 ff             	cmp    rdi,r15
  419b53:	0f 85 f5 fd ff ff    	jne    41994e <fmt_fp+0x192e>
  419b59:	c6 44 24 68 30       	mov    BYTE PTR [rsp+0x68],0x30
  419b5e:	be 01 00 00 00       	mov    esi,0x1
  419b63:	48 8d 7c 24 68       	lea    rdi,[rsp+0x68]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419b68:	41 f6 04 24 20       	test   BYTE PTR [r12],0x20
  419b6d:	0f 85 ec fd ff ff    	jne    41995f <fmt_fp+0x193f>
  419b73:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  419b78:	4c 89 e2             	mov    rdx,r12
		for (d=a; d<=r; d++) {
  419b7b:	49 83 c6 04          	add    r14,0x4
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419b7f:	e8 9c 27 00 00       	call   41c320 <__fwritex>
		for (d=a; d<=r; d++) {
  419b84:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  419b89:	4c 8b 15 00 64 00 00 	mov    r10,QWORD PTR [rip+0x6400]        # 41ff90 <states+0x2b0>
  419b90:	66 0f 6f 05 f8 63 00 	movdqa xmm0,XMMWORD PTR [rip+0x63f8]        # 41ff90 <states+0x2b0>
  419b97:	00 
  419b98:	0f 82 38 ff ff ff    	jb     419ad6 <fmt_fp+0x1ab6>
			char *s = fmt_u(*d, buf+9);
  419b9e:	41 8b 0e             	mov    ecx,DWORD PTR [r14]
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  419ba1:	4c 89 ff             	mov    rdi,r15
  419ba4:	48 85 c9             	test   rcx,rcx
  419ba7:	0f 85 73 fc ff ff    	jne    419820 <fmt_fp+0x1800>
			if (d!=a) while (s>buf) *--s='0';
  419bad:	48 8d 74 24 60       	lea    rsi,[rsp+0x60]
  419bb2:	4c 39 f5             	cmp    rbp,r14
  419bb5:	0f 85 a8 fc ff ff    	jne    419863 <fmt_fp+0x1843>
  419bbb:	eb 9c                	jmp    419b59 <fmt_fp+0x1b39>
		if (e > INT_MAX-l) return -1;
  419bbd:	44 39 d7             	cmp    edi,r10d
  419bc0:	0f 8f 97 fa ff ff    	jg     41965d <fmt_fp+0x163d>
		if (e>0) l+=e;
  419bc6:	41 8d 04 38          	lea    eax,[r8+rdi*1]
  419bca:	85 ff                	test   edi,edi
  419bcc:	44 0f 4f c0          	cmovg  r8d,eax
  419bd0:	e9 da f2 ff ff       	jmp    418eaf <fmt_fp+0xe8f>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419bd5:	48 8b 74 24 30       	mov    rsi,QWORD PTR [rsp+0x30]
  419bda:	48 8b 7c 24 20       	mov    rdi,QWORD PTR [rsp+0x20]
  419bdf:	4c 89 e2             	mov    rdx,r12
  419be2:	e8 39 27 00 00       	call   41c320 <__fwritex>
  419be7:	e9 ad f3 ff ff       	jmp    418f99 <fmt_fp+0xf79>
			if (d!=a) while (s>buf) *--s='0';
  419bec:	48 39 fd             	cmp    rbp,rdi
  419bef:	0f 85 f9 fd ff ff    	jne    4199ee <fmt_fp+0x19ce>
  419bf5:	e9 4b ff ff ff       	jmp    419b45 <fmt_fp+0x1b25>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419bfa:	41 83 e1 20          	and    r9d,0x20
  419bfe:	41 89 da             	mov    r10d,ebx
  419c01:	49 89 fd             	mov    r13,rdi
  419c04:	e9 93 f7 ff ff       	jmp    41939c <fmt_fp+0x137c>
  419c09:	d9 7c 24 4e          	fnstcw WORD PTR [rsp+0x4e]
  419c0d:	d9 05 ed 62 00 00    	fld    DWORD PTR [rip+0x62ed]        # 41ff00 <states+0x220>
  419c13:	d9 ca                	fxch   st(2)
		s=buf;
  419c15:	4c 89 e8             	mov    rax,r13
  419c18:	48 8d 0d b1 60 00 00 	lea    rcx,[rip+0x60b1]        # 41fcd0 <xdigits>
  419c1f:	0f b7 54 24 4e       	movzx  edx,WORD PTR [rsp+0x4e]
  419c24:	80 ce 0c             	or     dh,0xc
  419c27:	66 89 54 24 4c       	mov    WORD PTR [rsp+0x4c],dx
  419c2c:	eb 15                	jmp    419c43 <fmt_fp+0x1c23>
  419c2e:	66 90                	xchg   ax,ax
			*s++=xdigits[x]|(t&32);
  419c30:	48 89 d0             	mov    rax,rdx
		} while (y);
  419c33:	d9 c1                	fld    st(1)
  419c35:	d9 c9                	fxch   st(1)
  419c37:	db e9                	fucomi st,st(1)
  419c39:	dd d9                	fstp   st(1)
  419c3b:	7a 06                	jp     419c43 <fmt_fp+0x1c23>
  419c3d:	0f 84 69 ea ff ff    	je     4186ac <fmt_fp+0x68c>
			int x=y;
  419c43:	d9 c0                	fld    st(0)
  419c45:	d9 6c 24 4c          	fldcw  WORD PTR [rsp+0x4c]
  419c49:	db 5c 24 08          	fistp  DWORD PTR [rsp+0x8]
  419c4d:	d9 6c 24 4e          	fldcw  WORD PTR [rsp+0x4e]
			y=16*(y-x);
  419c51:	db 44 24 08          	fild   DWORD PTR [rsp+0x8]
			*s++=xdigits[x]|(t&32);
  419c55:	48 63 54 24 08       	movsxd rdx,DWORD PTR [rsp+0x8]
  419c5a:	0f b6 3c 11          	movzx  edi,BYTE PTR [rcx+rdx*1]
			if (s-buf==1 && (y||p>0||(fl&ALT_FORM))) *s++='.';
  419c5e:	48 8d 50 01          	lea    rdx,[rax+0x1]
			y=16*(y-x);
  419c62:	de e9                	fsubp  st(1),st
			*s++=xdigits[x]|(t&32);
  419c64:	09 f7                	or     edi,esi
  419c66:	40 88 38             	mov    BYTE PTR [rax],dil
			y=16*(y-x);
  419c69:	d8 ca                	fmul   st,st(2)
			if (s-buf==1 && (y||p>0||(fl&ALT_FORM))) *s++='.';
  419c6b:	4c 39 e8             	cmp    rax,r13
  419c6e:	75 c0                	jne    419c30 <fmt_fp+0x1c10>
  419c70:	c6 40 01 2e          	mov    BYTE PTR [rax+0x1],0x2e
  419c74:	48 83 c0 02          	add    rax,0x2
  419c78:	eb b9                	jmp    419c33 <fmt_fp+0x1c13>
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  419c7a:	4c 8d bc 24 80 00 00 	lea    r15,[rsp+0x80]
  419c81:	00 
  419c82:	ba 00 01 00 00       	mov    edx,0x100
  419c87:	be 30 00 00 00       	mov    esi,0x30
  419c8c:	4c 89 ff             	mov    rdi,r15
  419c8f:	e8 c8 cb ff ff       	call   41685c <memset>
	for (; l >= sizeof pad; l -= sizeof pad)
  419c94:	e9 fe f4 ff ff       	jmp    419197 <fmt_fp+0x1177>
			if (s==buf+9) *--s='0';
  419c99:	48 89 f8             	mov    rax,rdi
  419c9c:	45 31 d2             	xor    r10d,r10d
  419c9f:	e9 5b f6 ff ff       	jmp    4192ff <fmt_fp+0x12df>
				*d = *d + i;
  419ca4:	44 01 d0             	add    eax,r10d
  419ca7:	89 06                	mov    DWORD PTR [rsi],eax
				while (*d > 999999999) {
  419ca9:	3d ff c9 9a 3b       	cmp    eax,0x3b9ac9ff
  419cae:	77 2a                	ja     419cda <fmt_fp+0x1cba>
  419cb0:	e9 b1 06 00 00       	jmp    41a366 <fmt_fp+0x2346>
  419cb5:	0f 1f 00             	nop    DWORD PTR [rax]
					if (d<a) *--a=0;
  419cb8:	c7 45 fc 00 00 00 00 	mov    DWORD PTR [rbp-0x4],0x0
					(*d)++;
  419cbf:	8b 7e fc             	mov    edi,DWORD PTR [rsi-0x4]
					if (d<a) *--a=0;
  419cc2:	48 8d 4d fc          	lea    rcx,[rbp-0x4]
  419cc6:	48 89 cd             	mov    rbp,rcx
					(*d)++;
  419cc9:	8d 57 01             	lea    edx,[rdi+0x1]
  419ccc:	89 56 fc             	mov    DWORD PTR [rsi-0x4],edx
				while (*d > 999999999) {
  419ccf:	81 fa ff c9 9a 3b    	cmp    edx,0x3b9ac9ff
  419cd5:	76 24                	jbe    419cfb <fmt_fp+0x1cdb>
			if (pl && *prefix=='-') round*=-1, small*=-1;
  419cd7:	48 89 c6             	mov    rsi,rax
					*d--=0;
  419cda:	48 8d 46 fc          	lea    rax,[rsi-0x4]
  419cde:	c7 40 04 00 00 00 00 	mov    DWORD PTR [rax+0x4],0x0
					if (d<a) *--a=0;
  419ce5:	48 39 e8             	cmp    rax,rbp
  419ce8:	72 ce                	jb     419cb8 <fmt_fp+0x1c98>
					(*d)++;
  419cea:	8b 4e fc             	mov    ecx,DWORD PTR [rsi-0x4]
  419ced:	8d 51 01             	lea    edx,[rcx+0x1]
  419cf0:	89 56 fc             	mov    DWORD PTR [rsi-0x4],edx
				while (*d > 999999999) {
  419cf3:	81 fa ff c9 9a 3b    	cmp    edx,0x3b9ac9ff
  419cf9:	77 dc                	ja     419cd7 <fmt_fp+0x1cb7>
				for (i=10, e=9*(r-a); *a>=i; i*=10, e++);
  419cfb:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  419d00:	8b 55 00             	mov    edx,DWORD PTR [rbp+0x0]
  419d03:	48 29 e8             	sub    rax,rbp
  419d06:	48 c1 f8 02          	sar    rax,0x2
  419d0a:	8d 3c c0             	lea    edi,[rax+rax*8]
  419d0d:	83 fa 09             	cmp    edx,0x9
  419d10:	0f 86 89 f0 ff ff    	jbe    418d9f <fmt_fp+0xd7f>
  419d16:	b8 0a 00 00 00       	mov    eax,0xa
  419d1b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  419d20:	8d 04 80             	lea    eax,[rax+rax*4]
  419d23:	83 c7 01             	add    edi,0x1
  419d26:	01 c0                	add    eax,eax
  419d28:	39 d0                	cmp    eax,edx
  419d2a:	76 f4                	jbe    419d20 <fmt_fp+0x1d00>
  419d2c:	e9 6e f0 ff ff       	jmp    418d9f <fmt_fp+0xd7f>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419d31:	48 8b 7c 24 20       	mov    rdi,QWORD PTR [rsp+0x20]
		out(f, prefix, pl);
  419d36:	48 63 f3             	movsxd rsi,ebx
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419d39:	4c 89 e2             	mov    rdx,r12
  419d3c:	e8 df 25 00 00       	call   41c320 <__fwritex>
  419d41:	e9 a5 ea ff ff       	jmp    4187eb <fmt_fp+0x7cb>
  419d46:	41 f6 04 24 20       	test   BYTE PTR [r12],0x20
  419d4b:	0f 84 d6 fd ff ff    	je     419b27 <fmt_fp+0x1b07>
		for (; d<z && p>0; d++, p-=9) {
  419d51:	8b 14 24             	mov    edx,DWORD PTR [rsp]
  419d54:	85 d2                	test   edx,edx
  419d56:	0f 8e 84 f4 ff ff    	jle    4191e0 <fmt_fp+0x11c0>
  419d5c:	49 39 de             	cmp    r14,rbx
  419d5f:	0f 83 dd 02 00 00    	jae    41a042 <fmt_fp+0x2022>
  419d65:	4c 8d 6c 24 60       	lea    r13,[rsp+0x60]
  419d6a:	48 8d 4c 24 69       	lea    rcx,[rsp+0x69]
			while (s>buf) *--s='0';
  419d6f:	4c 8b 15 1a 62 00 00 	mov    r10,QWORD PTR [rip+0x621a]        # 41ff90 <states+0x2b0>
  419d76:	66 0f 6f 05 12 62 00 	movdqa xmm0,XMMWORD PTR [rip+0x6212]        # 41ff90 <states+0x2b0>
  419d7d:	00 
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  419d7e:	48 bd cd cc cc cc cc 	movabs rbp,0xcccccccccccccccd
  419d85:	cc cc cc 
  419d88:	41 bf 01 00 00 00    	mov    r15d,0x1
			char *s = fmt_u(*d, buf+9);
  419d8e:	41 8b 36             	mov    esi,DWORD PTR [r14]
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  419d91:	48 89 cf             	mov    rdi,rcx
  419d94:	48 85 f6             	test   rsi,rsi
  419d97:	74 3c                	je     419dd5 <fmt_fp+0x1db5>
  419d99:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  419da0:	48 89 f0             	mov    rax,rsi
  419da3:	48 83 ef 01          	sub    rdi,0x1
  419da7:	48 f7 e5             	mul    rbp
  419daa:	48 89 f0             	mov    rax,rsi
  419dad:	48 c1 ea 03          	shr    rdx,0x3
  419db1:	4c 8d 04 92          	lea    r8,[rdx+rdx*4]
  419db5:	4d 01 c0             	add    r8,r8
  419db8:	4c 29 c0             	sub    rax,r8
  419dbb:	83 c0 30             	add    eax,0x30
  419dbe:	88 07                	mov    BYTE PTR [rdi],al
  419dc0:	48 89 f0             	mov    rax,rsi
  419dc3:	48 89 d6             	mov    rsi,rdx
  419dc6:	48 83 f8 09          	cmp    rax,0x9
  419dca:	77 d4                	ja     419da0 <fmt_fp+0x1d80>
			while (s>buf) *--s='0';
  419dcc:	4c 39 ef             	cmp    rdi,r13
  419dcf:	0f 86 e9 00 00 00    	jbe    419ebe <fmt_fp+0x1e9e>
  419dd5:	4c 8d 4f ff          	lea    r9,[rdi-0x1]
  419dd9:	48 89 f8             	mov    rax,rdi
  419ddc:	4c 89 fa             	mov    rdx,r15
  419ddf:	4c 29 e8             	sub    rax,r13
  419de2:	4d 39 e9             	cmp    r9,r13
  419de5:	48 0f 43 d0          	cmovae rdx,rax
  419de9:	48 83 e8 01          	sub    rax,0x1
  419ded:	48 83 f8 0e          	cmp    rax,0xe
  419df1:	0f 86 3d 03 00 00    	jbe    41a134 <fmt_fp+0x2114>
  419df7:	4d 39 e9             	cmp    r9,r13
  419dfa:	0f 82 34 03 00 00    	jb     41a134 <fmt_fp+0x2114>
  419e00:	48 89 d0             	mov    rax,rdx
  419e03:	48 89 fe             	mov    rsi,rdi
  419e06:	48 83 e0 f0          	and    rax,0xfffffffffffffff0
  419e0a:	48 29 c6             	sub    rsi,rax
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  419e0d:	48 89 f8             	mov    rax,rdi
			while (s>buf) *--s='0';
  419e10:	0f 11 40 f0          	movups XMMWORD PTR [rax-0x10],xmm0
  419e14:	48 83 e8 10          	sub    rax,0x10
  419e18:	48 39 f0             	cmp    rax,rsi
  419e1b:	75 f3                	jne    419e10 <fmt_fp+0x1df0>
  419e1d:	48 89 d6             	mov    rsi,rdx
  419e20:	48 89 f8             	mov    rax,rdi
  419e23:	48 83 e6 f0          	and    rsi,0xfffffffffffffff0
  419e27:	48 29 f0             	sub    rax,rsi
  419e2a:	48 39 d6             	cmp    rsi,rdx
  419e2d:	74 78                	je     419ea7 <fmt_fp+0x1e87>
  419e2f:	48 29 f2             	sub    rdx,rsi
  419e32:	4c 8d 5a ff          	lea    r11,[rdx-0x1]
  419e36:	49 83 fb 06          	cmp    r11,0x6
  419e3a:	76 19                	jbe    419e55 <fmt_fp+0x1e35>
  419e3c:	49 89 fb             	mov    r11,rdi
  419e3f:	49 29 f3             	sub    r11,rsi
  419e42:	48 89 d6             	mov    rsi,rdx
  419e45:	48 83 e6 f8          	and    rsi,0xfffffffffffffff8
  419e49:	4d 89 53 f8          	mov    QWORD PTR [r11-0x8],r10
  419e4d:	48 29 f0             	sub    rax,rsi
  419e50:	48 39 f2             	cmp    rdx,rsi
  419e53:	74 52                	je     419ea7 <fmt_fp+0x1e87>
  419e55:	48 8d 50 ff          	lea    rdx,[rax-0x1]
  419e59:	c6 40 ff 30          	mov    BYTE PTR [rax-0x1],0x30
  419e5d:	49 39 d5             	cmp    r13,rdx
  419e60:	73 45                	jae    419ea7 <fmt_fp+0x1e87>
  419e62:	48 8d 50 fe          	lea    rdx,[rax-0x2]
  419e66:	c6 40 fe 30          	mov    BYTE PTR [rax-0x2],0x30
  419e6a:	49 39 d5             	cmp    r13,rdx
  419e6d:	73 38                	jae    419ea7 <fmt_fp+0x1e87>
  419e6f:	48 8d 50 fd          	lea    rdx,[rax-0x3]
  419e73:	c6 40 fd 30          	mov    BYTE PTR [rax-0x3],0x30
  419e77:	49 39 d5             	cmp    r13,rdx
  419e7a:	73 2b                	jae    419ea7 <fmt_fp+0x1e87>
  419e7c:	48 8d 50 fc          	lea    rdx,[rax-0x4]
  419e80:	c6 40 fc 30          	mov    BYTE PTR [rax-0x4],0x30
  419e84:	49 39 d5             	cmp    r13,rdx
  419e87:	73 1e                	jae    419ea7 <fmt_fp+0x1e87>
  419e89:	48 8d 50 fb          	lea    rdx,[rax-0x5]
  419e8d:	c6 40 fb 30          	mov    BYTE PTR [rax-0x5],0x30
  419e91:	49 39 d5             	cmp    r13,rdx
  419e94:	73 11                	jae    419ea7 <fmt_fp+0x1e87>
  419e96:	48 8d 50 fa          	lea    rdx,[rax-0x6]
  419e9a:	c6 40 fa 30          	mov    BYTE PTR [rax-0x6],0x30
  419e9e:	49 39 d5             	cmp    r13,rdx
  419ea1:	73 04                	jae    419ea7 <fmt_fp+0x1e87>
  419ea3:	c6 40 f9 30          	mov    BYTE PTR [rax-0x7],0x30
  419ea7:	4c 89 e8             	mov    rax,r13
  419eaa:	48 c7 c2 ff ff ff ff 	mov    rdx,0xffffffffffffffff
  419eb1:	48 29 f8             	sub    rax,rdi
  419eb4:	4d 39 e9             	cmp    r9,r13
  419eb7:	48 0f 42 c2          	cmovb  rax,rdx
  419ebb:	48 01 c7             	add    rdi,rax
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  419ebe:	41 f6 04 24 20       	test   BYTE PTR [r12],0x20
  419ec3:	0f 84 0f 02 00 00    	je     41a0d8 <fmt_fp+0x20b8>
		for (; d<z && p>0; d++, p-=9) {
  419ec9:	4d 8d 4e 04          	lea    r9,[r14+0x4]
  419ecd:	83 2c 24 09          	sub    DWORD PTR [rsp],0x9
  419ed1:	8b 2c 24             	mov    ebp,DWORD PTR [rsp]
  419ed4:	49 39 d9             	cmp    r9,rbx
  419ed7:	0f 83 65 01 00 00    	jae    41a042 <fmt_fp+0x2022>
  419edd:	85 ed                	test   ebp,ebp
  419edf:	0f 8e fb f2 ff ff    	jle    4191e0 <fmt_fp+0x11c0>
			while (s>buf) *--s='0';
  419ee5:	4c 8b 35 a4 60 00 00 	mov    r14,QWORD PTR [rip+0x60a4]        # 41ff90 <states+0x2b0>
  419eec:	66 0f 6f 05 9c 60 00 	movdqa xmm0,XMMWORD PTR [rip+0x609c]        # 41ff90 <states+0x2b0>
  419ef3:	00 
  419ef4:	41 bb 01 00 00 00    	mov    r11d,0x1
  419efa:	49 c7 c2 f8 ff ff ff 	mov    r10,0xfffffffffffffff8
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  419f01:	49 b8 cd cc cc cc cc 	movabs r8,0xcccccccccccccccd
  419f08:	cc cc cc 
			char *s = fmt_u(*d, buf+9);
  419f0b:	41 8b 31             	mov    esi,DWORD PTR [r9]
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  419f0e:	48 89 cf             	mov    rdi,rcx
  419f11:	48 85 f6             	test   rsi,rsi
  419f14:	74 3f                	je     419f55 <fmt_fp+0x1f35>
  419f16:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  419f1d:	00 00 00 
  419f20:	48 89 f0             	mov    rax,rsi
  419f23:	48 83 ef 01          	sub    rdi,0x1
  419f27:	49 f7 e0             	mul    r8
  419f2a:	48 89 f0             	mov    rax,rsi
  419f2d:	48 c1 ea 03          	shr    rdx,0x3
  419f31:	4c 8d 3c 92          	lea    r15,[rdx+rdx*4]
  419f35:	4d 01 ff             	add    r15,r15
  419f38:	4c 29 f8             	sub    rax,r15
  419f3b:	83 c0 30             	add    eax,0x30
  419f3e:	88 07                	mov    BYTE PTR [rdi],al
  419f40:	48 89 f0             	mov    rax,rsi
  419f43:	48 89 d6             	mov    rsi,rdx
  419f46:	48 83 f8 09          	cmp    rax,0x9
  419f4a:	77 d4                	ja     419f20 <fmt_fp+0x1f00>
			while (s>buf) *--s='0';
  419f4c:	4c 39 ef             	cmp    rdi,r13
  419f4f:	0f 86 d2 00 00 00    	jbe    41a027 <fmt_fp+0x2007>
  419f55:	4c 8d 7f ff          	lea    r15,[rdi-0x1]
  419f59:	48 89 fe             	mov    rsi,rdi
  419f5c:	4c 89 da             	mov    rdx,r11
  419f5f:	48 89 f8             	mov    rax,rdi
  419f62:	4c 29 ee             	sub    rsi,r13
  419f65:	4d 39 ef             	cmp    r15,r13
  419f68:	48 0f 43 d6          	cmovae rdx,rsi
  419f6c:	48 83 ee 01          	sub    rsi,0x1
  419f70:	48 83 fe 0e          	cmp    rsi,0xe
  419f74:	0f 86 b0 01 00 00    	jbe    41a12a <fmt_fp+0x210a>
  419f7a:	4d 39 ef             	cmp    r15,r13
  419f7d:	0f 82 a7 01 00 00    	jb     41a12a <fmt_fp+0x210a>
  419f83:	49 89 d7             	mov    r15,rdx
  419f86:	48 89 fe             	mov    rsi,rdi
  419f89:	49 83 e7 f0          	and    r15,0xfffffffffffffff0
  419f8d:	4c 29 fe             	sub    rsi,r15
  419f90:	0f 11 40 f0          	movups XMMWORD PTR [rax-0x10],xmm0
  419f94:	48 83 e8 10          	sub    rax,0x10
  419f98:	48 39 f0             	cmp    rax,rsi
  419f9b:	75 f3                	jne    419f90 <fmt_fp+0x1f70>
  419f9d:	48 89 d6             	mov    rsi,rdx
  419fa0:	48 89 f8             	mov    rax,rdi
  419fa3:	48 83 e6 f0          	and    rsi,0xfffffffffffffff0
  419fa7:	48 29 f0             	sub    rax,rsi
  419faa:	48 39 d6             	cmp    rsi,rdx
  419fad:	74 78                	je     41a027 <fmt_fp+0x2007>
  419faf:	48 29 f2             	sub    rdx,rsi
  419fb2:	4c 8d 7a ff          	lea    r15,[rdx-0x1]
  419fb6:	49 83 ff 06          	cmp    r15,0x6
  419fba:	76 19                	jbe    419fd5 <fmt_fp+0x1fb5>
  419fbc:	4d 89 d7             	mov    r15,r10
  419fbf:	49 29 f7             	sub    r15,rsi
  419fc2:	48 89 d6             	mov    rsi,rdx
  419fc5:	48 83 e6 f8          	and    rsi,0xfffffffffffffff8
  419fc9:	4e 89 34 3f          	mov    QWORD PTR [rdi+r15*1],r14
  419fcd:	48 29 f0             	sub    rax,rsi
  419fd0:	48 39 d6             	cmp    rsi,rdx
  419fd3:	74 52                	je     41a027 <fmt_fp+0x2007>
  419fd5:	48 8d 50 ff          	lea    rdx,[rax-0x1]
  419fd9:	c6 40 ff 30          	mov    BYTE PTR [rax-0x1],0x30
  419fdd:	49 39 d5             	cmp    r13,rdx
  419fe0:	73 45                	jae    41a027 <fmt_fp+0x2007>
  419fe2:	48 8d 50 fe          	lea    rdx,[rax-0x2]
  419fe6:	c6 40 fe 30          	mov    BYTE PTR [rax-0x2],0x30
  419fea:	49 39 d5             	cmp    r13,rdx
  419fed:	73 38                	jae    41a027 <fmt_fp+0x2007>
  419fef:	48 8d 50 fd          	lea    rdx,[rax-0x3]
  419ff3:	c6 40 fd 30          	mov    BYTE PTR [rax-0x3],0x30
  419ff7:	49 39 d5             	cmp    r13,rdx
  419ffa:	73 2b                	jae    41a027 <fmt_fp+0x2007>
  419ffc:	48 8d 50 fc          	lea    rdx,[rax-0x4]
  41a000:	c6 40 fc 30          	mov    BYTE PTR [rax-0x4],0x30
  41a004:	49 39 d5             	cmp    r13,rdx
  41a007:	73 1e                	jae    41a027 <fmt_fp+0x2007>
  41a009:	48 8d 50 fb          	lea    rdx,[rax-0x5]
  41a00d:	c6 40 fb 30          	mov    BYTE PTR [rax-0x5],0x30
  41a011:	49 39 d5             	cmp    r13,rdx
  41a014:	73 11                	jae    41a027 <fmt_fp+0x2007>
  41a016:	48 8d 50 fa          	lea    rdx,[rax-0x6]
  41a01a:	c6 40 fa 30          	mov    BYTE PTR [rax-0x6],0x30
  41a01e:	49 39 d5             	cmp    r13,rdx
  41a021:	73 04                	jae    41a027 <fmt_fp+0x2007>
  41a023:	c6 40 f9 30          	mov    BYTE PTR [rax-0x7],0x30
		for (; d<z && p>0; d++, p-=9) {
  41a027:	83 ed 09             	sub    ebp,0x9
  41a02a:	49 83 c1 04          	add    r9,0x4
  41a02e:	85 ed                	test   ebp,ebp
  41a030:	0f 8e aa f1 ff ff    	jle    4191e0 <fmt_fp+0x11c0>
  41a036:	4c 39 cb             	cmp    rbx,r9
  41a039:	0f 87 cc fe ff ff    	ja     419f0b <fmt_fp+0x1eeb>
  41a03f:	89 2c 24             	mov    DWORD PTR [rsp],ebp
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41a042:	8b 1c 24             	mov    ebx,DWORD PTR [rsp]
  41a045:	85 db                	test   ebx,ebx
  41a047:	0f 8e 93 f1 ff ff    	jle    4191e0 <fmt_fp+0x11c0>
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41a04d:	81 fb 00 01 00 00    	cmp    ebx,0x100
  41a053:	0f 8f c7 01 00 00    	jg     41a220 <fmt_fp+0x2200>
  41a059:	48 63 eb             	movsxd rbp,ebx
  41a05c:	4c 8d bc 24 80 00 00 	lea    r15,[rsp+0x80]
  41a063:	00 
  41a064:	be 30 00 00 00       	mov    esi,0x30
  41a069:	48 89 ea             	mov    rdx,rbp
  41a06c:	4c 89 ff             	mov    rdi,r15
  41a06f:	e8 e8 c7 ff ff       	call   41685c <memset>
	for (; l >= sizeof pad; l -= sizeof pad)
  41a074:	81 fb 00 01 00 00    	cmp    ebx,0x100
  41a07a:	0f 85 12 03 00 00    	jne    41a392 <fmt_fp+0x2372>
  41a080:	8b 1c 24             	mov    ebx,DWORD PTR [rsp]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a083:	41 8b 14 24          	mov    edx,DWORD PTR [r12]
  41a087:	81 eb 00 01 00 00    	sub    ebx,0x100
  41a08d:	89 dd                	mov    ebp,ebx
  41a08f:	90                   	nop
  41a090:	89 d0                	mov    eax,edx
  41a092:	83 e0 20             	and    eax,0x20
  41a095:	0f 84 55 01 00 00    	je     41a1f0 <fmt_fp+0x21d0>
	for (; l >= sizeof pad; l -= sizeof pad)
  41a09b:	81 fd ff 00 00 00    	cmp    ebp,0xff
  41a0a1:	76 12                	jbe    41a0b5 <fmt_fp+0x2095>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a0a3:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  41a0a5:	81 ed 00 01 00 00    	sub    ebp,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a0ab:	89 d0                	mov    eax,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  41a0ad:	81 fd ff 00 00 00    	cmp    ebp,0xff
  41a0b3:	77 f0                	ja     41a0a5 <fmt_fp+0x2085>
	out(f, pad, l);
  41a0b5:	0f b6 eb             	movzx  ebp,bl
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a0b8:	85 c0                	test   eax,eax
  41a0ba:	0f 85 20 f1 ff ff    	jne    4191e0 <fmt_fp+0x11c0>
  41a0c0:	4c 89 e2             	mov    rdx,r12
  41a0c3:	48 89 ee             	mov    rsi,rbp
  41a0c6:	4c 89 ff             	mov    rdi,r15
  41a0c9:	e8 52 22 00 00       	call   41c320 <__fwritex>
  41a0ce:	e9 0d f1 ff ff       	jmp    4191e0 <fmt_fp+0x11c0>
  41a0d3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  41a0d8:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
			out(f, s, MIN(9,p));
  41a0dd:	8b 0c 24             	mov    ecx,DWORD PTR [rsp]
  41a0e0:	b8 09 00 00 00       	mov    eax,0x9
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a0e5:	4c 89 e2             	mov    rdx,r12
			out(f, s, MIN(9,p));
  41a0e8:	39 c1                	cmp    ecx,eax
  41a0ea:	0f 4e c1             	cmovle eax,ecx
		for (; d<z && p>0; d++, p-=9) {
  41a0ed:	49 83 c6 04          	add    r14,0x4
			out(f, s, MIN(9,p));
  41a0f1:	48 63 f0             	movsxd rsi,eax
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a0f4:	e8 27 22 00 00       	call   41c320 <__fwritex>
		for (; d<z && p>0; d++, p-=9) {
  41a0f9:	83 2c 24 09          	sub    DWORD PTR [rsp],0x9
  41a0fd:	8b 0c 24             	mov    ecx,DWORD PTR [rsp]
  41a100:	85 c9                	test   ecx,ecx
  41a102:	0f 8e d8 f0 ff ff    	jle    4191e0 <fmt_fp+0x11c0>
  41a108:	49 39 de             	cmp    r14,rbx
  41a10b:	4c 8b 15 7e 5e 00 00 	mov    r10,QWORD PTR [rip+0x5e7e]        # 41ff90 <states+0x2b0>
  41a112:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
  41a117:	66 0f 6f 05 71 5e 00 	movdqa xmm0,XMMWORD PTR [rip+0x5e71]        # 41ff90 <states+0x2b0>
  41a11e:	00 
  41a11f:	0f 82 69 fc ff ff    	jb     419d8e <fmt_fp+0x1d6e>
  41a125:	e9 18 ff ff ff       	jmp    41a042 <fmt_fp+0x2022>
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  41a12a:	48 89 f8             	mov    rax,rdi
  41a12d:	31 f6                	xor    esi,esi
  41a12f:	e9 7b fe ff ff       	jmp    419faf <fmt_fp+0x1f8f>
  41a134:	48 89 f8             	mov    rax,rdi
  41a137:	31 f6                	xor    esi,esi
  41a139:	e9 f1 fc ff ff       	jmp    419e2f <fmt_fp+0x1e0f>
			p--;
  41a13e:	83 2c 24 01          	sub    DWORD PTR [rsp],0x1
			t-=2;
  41a142:	41 83 ef 02          	sub    r15d,0x2
			p--;
  41a146:	e9 03 f6 ff ff       	jmp    41974e <fmt_fp+0x172e>
		if (estr==ebuf) *--estr='0';
  41a14b:	c6 44 24 5f 30       	mov    BYTE PTR [rsp+0x5f],0x30
  41a150:	48 8d 74 24 5f       	lea    rsi,[rsp+0x5f]
  41a155:	e9 8b e4 ff ff       	jmp    4185e5 <fmt_fp+0x5c5>
			if (d!=a) while (s>buf) *--s='0';
  41a15a:	48 89 f8             	mov    rax,rdi
  41a15d:	31 d2                	xor    edx,edx
  41a15f:	e9 5b f7 ff ff       	jmp    4198bf <fmt_fp+0x189f>
  41a164:	48 89 f0             	mov    rax,rsi
  41a167:	31 c9                	xor    ecx,ecx
  41a169:	e9 e1 f8 ff ff       	jmp    419a4f <fmt_fp+0x1a2f>
	out(f, pad, l);
  41a16e:	48 63 f5             	movsxd rsi,ebp
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a171:	4c 89 e2             	mov    rdx,r12
  41a174:	4c 89 ff             	mov    rdi,r15
  41a177:	e8 a4 21 00 00       	call   41c320 <__fwritex>
  41a17c:	e9 f5 f0 ff ff       	jmp    419276 <fmt_fp+0x1256>
			if ((*d/i & 1) || (i==1000000000 && d>a && (d[-1]&1)))
  41a181:	81 f9 00 ca 9a 3b    	cmp    ecx,0x3b9aca00
  41a187:	75 0f                	jne    41a198 <fmt_fp+0x2178>
  41a189:	48 39 ee             	cmp    rsi,rbp
  41a18c:	76 0a                	jbe    41a198 <fmt_fp+0x2178>
  41a18e:	f6 46 fc 01          	test   BYTE PTR [rsi-0x4],0x1
  41a192:	0f 85 a2 eb ff ff    	jne    418d3a <fmt_fp+0xd1a>
			long double round = 2/LDBL_EPSILON;
  41a198:	d9 05 4e 5d 00 00    	fld    DWORD PTR [rip+0x5d4e]        # 41feec <states+0x20c>
  41a19e:	e9 9d eb ff ff       	jmp    418d40 <fmt_fp+0xd20>
			l = (p+2) + (ebuf-estr);
  41a1a3:	83 c6 02             	add    esi,0x2
  41a1a6:	44 89 d8             	mov    eax,r11d
  41a1a9:	89 f2                	mov    edx,esi
  41a1ab:	01 f0                	add    eax,esi
		pad(f, '0', l-(ebuf-estr)-(s-buf), 0, 0);
  41a1ad:	29 fa                	sub    edx,edi
  41a1af:	89 54 24 30          	mov    DWORD PTR [rsp+0x30],edx
  41a1b3:	48 63 ea             	movsxd rbp,edx
			l = (p+2) + (ebuf-estr);
  41a1b6:	e9 4d e5 ff ff       	jmp    418708 <fmt_fp+0x6e8>
			if ((*d/i & 1) || (i==1000000000 && d>a && (d[-1]&1)))
  41a1bb:	d9 05 2f 5d 00 00    	fld    DWORD PTR [rip+0x5d2f]        # 41fef0 <states+0x210>
			if (x<i/2) small=0x0.8p0;
  41a1c1:	d9 05 2d 5d 00 00    	fld    DWORD PTR [rip+0x5d2d]        # 41fef4 <states+0x214>
				round += 2;
  41a1c7:	db 2d 83 5d 00 00    	fld    TBYTE PTR [rip+0x5d83]        # 41ff50 <states+0x270>
  41a1cd:	d9 ca                	fxch   st(2)
  41a1cf:	d9 c9                	fxch   st(1)
  41a1d1:	e9 87 eb ff ff       	jmp    418d5d <fmt_fp+0xd3d>
				p = MIN(p,MAX(0,9*(z-r-1)-j));
  41a1d6:	48 89 c8             	mov    rax,rcx
  41a1d9:	e9 e9 f5 ff ff       	jmp    4197c7 <fmt_fp+0x17a7>
			while (re--) round*=16;
  41a1de:	d9 05 e4 5c 00 00    	fld    DWORD PTR [rip+0x5ce4]        # 41fec8 <states+0x1e8>
  41a1e4:	e9 88 e3 ff ff       	jmp    418571 <fmt_fp+0x551>
  41a1e9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a1f0:	4c 89 e2             	mov    rdx,r12
  41a1f3:	be 00 01 00 00       	mov    esi,0x100
  41a1f8:	4c 89 ff             	mov    rdi,r15
  41a1fb:	e8 20 21 00 00       	call   41c320 <__fwritex>
  41a200:	41 8b 14 24          	mov    edx,DWORD PTR [r12]
  41a204:	89 d0                	mov    eax,edx
  41a206:	83 e0 20             	and    eax,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41a209:	81 fd ff 00 00 00    	cmp    ebp,0xff
  41a20f:	0f 86 a0 fe ff ff    	jbe    41a0b5 <fmt_fp+0x2095>
  41a215:	81 ed 00 01 00 00    	sub    ebp,0x100
  41a21b:	e9 70 fe ff ff       	jmp    41a090 <fmt_fp+0x2070>
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41a220:	4c 8d bc 24 80 00 00 	lea    r15,[rsp+0x80]
  41a227:	00 
  41a228:	ba 00 01 00 00       	mov    edx,0x100
  41a22d:	be 30 00 00 00       	mov    esi,0x30
  41a232:	4c 89 ff             	mov    rdi,r15
  41a235:	e8 22 c6 ff ff       	call   41685c <memset>
	for (; l >= sizeof pad; l -= sizeof pad)
  41a23a:	e9 41 fe ff ff       	jmp    41a080 <fmt_fp+0x2060>
  41a23f:	d9 ca                	fxch   st(2)
				y=-y;
  41a241:	d9 e0                	fchs   
				y-=round;
  41a243:	d8 e2                	fsub   st,st(2)
				y+=round;
  41a245:	de c2                	faddp  st(2),st
  41a247:	d9 c9                	fxch   st(1)
				y=-y;
  41a249:	d9 e0                	fchs   
  41a24b:	d9 c9                	fxch   st(1)
  41a24d:	e9 31 e3 ff ff       	jmp    418583 <fmt_fp+0x563>
  41a252:	d9 05 98 5c 00 00    	fld    DWORD PTR [rip+0x5c98]        # 41fef0 <states+0x210>
			if (x<i/2) small=0x0.8p0;
  41a258:	d9 05 96 5c 00 00    	fld    DWORD PTR [rip+0x5c96]        # 41fef4 <states+0x214>
  41a25e:	e9 fa ea ff ff       	jmp    418d5d <fmt_fp+0xd3d>
			else if (x==i/2 && d+1==z) small=0x1.0p0;
  41a263:	48 8d 46 04          	lea    rax,[rsi+0x4]
  41a267:	48 39 c3             	cmp    rbx,rax
  41a26a:	0f 85 e1 ea ff ff    	jne    418d51 <fmt_fp+0xd31>
  41a270:	d9 e8                	fld1   
  41a272:	d9 e0                	fchs   
  41a274:	d9 e8                	fld1   
  41a276:	e9 e2 ea ff ff       	jmp    418d5d <fmt_fp+0xd3d>
  41a27b:	48 89 de             	mov    rsi,rbx
  41a27e:	e9 1c eb ff ff       	jmp    418d9f <fmt_fp+0xd7f>
	out(f, pad, l);
  41a283:	48 63 f5             	movsxd rsi,ebp
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a286:	4c 89 e2             	mov    rdx,r12
  41a289:	4c 89 ff             	mov    rdi,r15
  41a28c:	e8 8f 20 00 00       	call   41c320 <__fwritex>
  41a291:	e9 3f e7 ff ff       	jmp    4189d5 <fmt_fp+0x9b5>
  41a296:	dd d8                	fstp   st(0)
  41a298:	dd d8                	fstp   st(0)
  41a29a:	dd d8                	fstp   st(0)
		} while (y);
  41a29c:	48 89 d0             	mov    rax,rdx
  41a29f:	e9 0e e4 ff ff       	jmp    4186b2 <fmt_fp+0x692>
		for (i=10, j++; j<9; i*=10, j++);
  41a2a4:	f3 0f 7e 05 74 5c 00 	movq   xmm0,QWORD PTR [rip+0x5c74]        # 41ff20 <states+0x240>
  41a2ab:	00 
  41a2ac:	e9 e7 e9 ff ff       	jmp    418c98 <fmt_fp+0xc78>
  41a2b1:	41 ba 0a 00 00 00    	mov    r10d,0xa
  41a2b7:	b9 0a 00 00 00       	mov    ecx,0xa
  41a2bc:	e9 4a e1 ff ff       	jmp    41840b <fmt_fp+0x3eb>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a2c1:	41 8b 14 24          	mov    edx,DWORD PTR [r12]
  41a2c5:	83 e2 20             	and    edx,0x20
  41a2c8:	e9 78 e8 ff ff       	jmp    418b45 <fmt_fp+0xb25>
  41a2cd:	41 8b 14 24          	mov    edx,DWORD PTR [r12]
  41a2d1:	83 e2 20             	and    edx,0x20
  41a2d4:	e9 1c e9 ff ff       	jmp    418bf5 <fmt_fp+0xbd5>
		for (i=10, j++; j<9; i*=10, j++);
  41a2d9:	b9 0a 00 00 00       	mov    ecx,0xa
  41a2de:	e9 d4 e9 ff ff       	jmp    418cb7 <fmt_fp+0xc97>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a2e3:	89 d0                	mov    eax,edx
  41a2e5:	83 e0 20             	and    eax,0x20
  41a2e8:	e9 4a ed ff ff       	jmp    419037 <fmt_fp+0x1017>
  41a2ed:	89 d0                	mov    eax,edx
  41a2ef:	83 e0 20             	and    eax,0x20
  41a2f2:	e9 81 ec ff ff       	jmp    418f78 <fmt_fp+0xf58>
  41a2f7:	41 8b 14 24          	mov    edx,DWORD PTR [r12]
  41a2fb:	83 e2 20             	and    edx,0x20
  41a2fe:	e9 6b ef ff ff       	jmp    41926e <fmt_fp+0x124e>
  41a303:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  41a307:	83 e0 20             	and    eax,0x20
  41a30a:	e9 c9 ee ff ff       	jmp    4191d8 <fmt_fp+0x11b8>
		for (i=10, j++; j<9; i*=10, j++);
  41a30f:	f3 0f 7e 05 11 5c 00 	movq   xmm0,QWORD PTR [rip+0x5c11]        # 41ff28 <states+0x248>
  41a316:	00 
  41a317:	e9 7c e9 ff ff       	jmp    418c98 <fmt_fp+0xc78>
  41a31c:	f3 0f 7e 05 0c 5c 00 	movq   xmm0,QWORD PTR [rip+0x5c0c]        # 41ff30 <states+0x250>
  41a323:	00 
  41a324:	e9 6f e9 ff ff       	jmp    418c98 <fmt_fp+0xc78>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a329:	41 8b 14 24          	mov    edx,DWORD PTR [r12]
  41a32d:	83 e2 20             	and    edx,0x20
  41a330:	e9 dd e5 ff ff       	jmp    418912 <fmt_fp+0x8f2>
			while (re--) round*=16;
  41a335:	d9 05 79 5b 00 00    	fld    DWORD PTR [rip+0x5b79]        # 41feb4 <states+0x1d4>
  41a33b:	e9 31 e2 ff ff       	jmp    418571 <fmt_fp+0x551>
		for (i=10, j++; j<9; i*=10, j++);
  41a340:	f3 0f 7e 05 f8 5b 00 	movq   xmm0,QWORD PTR [rip+0x5bf8]        # 41ff40 <states+0x260>
  41a347:	00 
  41a348:	e9 4b e9 ff ff       	jmp    418c98 <fmt_fp+0xc78>
  41a34d:	f3 0f 7e 05 e3 5b 00 	movq   xmm0,QWORD PTR [rip+0x5be3]        # 41ff38 <states+0x258>
  41a354:	00 
  41a355:	e9 3e e9 ff ff       	jmp    418c98 <fmt_fp+0xc78>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a35a:	41 8b 14 24          	mov    edx,DWORD PTR [r12]
  41a35e:	83 e2 20             	and    edx,0x20
  41a361:	e9 26 e5 ff ff       	jmp    41888c <fmt_fp+0x86c>
		if (x || d+1!=z) {
  41a366:	48 83 c6 04          	add    rsi,0x4
  41a36a:	e9 8c f9 ff ff       	jmp    419cfb <fmt_fp+0x1cdb>
			while (re--) round*=16;
  41a36f:	d9 05 43 5b 00 00    	fld    DWORD PTR [rip+0x5b43]        # 41feb8 <states+0x1d8>
  41a375:	e9 f7 e1 ff ff       	jmp    418571 <fmt_fp+0x551>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a37a:	41 8b 14 24          	mov    edx,DWORD PTR [r12]
  41a37e:	83 e2 20             	and    edx,0x20
  41a381:	e9 44 e4 ff ff       	jmp    4187ca <fmt_fp+0x7aa>
  41a386:	41 8b 14 24          	mov    edx,DWORD PTR [r12]
  41a38a:	83 e2 20             	and    edx,0x20
  41a38d:	e9 3b e6 ff ff       	jmp    4189cd <fmt_fp+0x9ad>
  41a392:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  41a396:	83 e0 20             	and    eax,0x20
  41a399:	e9 1a fd ff ff       	jmp    41a0b8 <fmt_fp+0x2098>
			while (re--) round*=16;
  41a39e:	d9 05 1c 5b 00 00    	fld    DWORD PTR [rip+0x5b1c]        # 41fec0 <states+0x1e0>
  41a3a4:	e9 c8 e1 ff ff       	jmp    418571 <fmt_fp+0x551>
  41a3a9:	d9 05 0d 5b 00 00    	fld    DWORD PTR [rip+0x5b0d]        # 41febc <states+0x1dc>
  41a3af:	e9 bd e1 ff ff       	jmp    418571 <fmt_fp+0x551>
  41a3b4:	d9 05 0a 5b 00 00    	fld    DWORD PTR [rip+0x5b0a]        # 41fec4 <states+0x1e4>
  41a3ba:	e9 b2 e1 ff ff       	jmp    418571 <fmt_fp+0x551>
  41a3bf:	d9 05 0b 5b 00 00    	fld    DWORD PTR [rip+0x5b0b]        # 41fed0 <states+0x1f0>
  41a3c5:	e9 a7 e1 ff ff       	jmp    418571 <fmt_fp+0x551>
  41a3ca:	d9 05 fc 5a 00 00    	fld    DWORD PTR [rip+0x5afc]        # 41fecc <states+0x1ec>
  41a3d0:	e9 9c e1 ff ff       	jmp    418571 <fmt_fp+0x551>
			if (z>a && z[-1]) for (i=10, j=0; z[-1]%i==0; i*=10, j++);
  41a3d5:	31 f6                	xor    esi,esi
  41a3d7:	e9 c1 f3 ff ff       	jmp    41979d <fmt_fp+0x177d>
			while (re--) round*=16;
  41a3dc:	d9 05 f6 5a 00 00    	fld    DWORD PTR [rip+0x5af6]        # 41fed8 <states+0x1f8>
  41a3e2:	e9 8a e1 ff ff       	jmp    418571 <fmt_fp+0x551>
  41a3e7:	d9 05 e7 5a 00 00    	fld    DWORD PTR [rip+0x5ae7]        # 41fed4 <states+0x1f4>
  41a3ed:	e9 7f e1 ff ff       	jmp    418571 <fmt_fp+0x551>
  41a3f2:	d9 05 f0 5a 00 00    	fld    DWORD PTR [rip+0x5af0]        # 41fee8 <states+0x208>
  41a3f8:	e9 74 e1 ff ff       	jmp    418571 <fmt_fp+0x551>
  41a3fd:	d9 05 e1 5a 00 00    	fld    DWORD PTR [rip+0x5ae1]        # 41fee4 <states+0x204>
  41a403:	e9 69 e1 ff ff       	jmp    418571 <fmt_fp+0x551>
  41a408:	d9 05 d2 5a 00 00    	fld    DWORD PTR [rip+0x5ad2]        # 41fee0 <states+0x200>
  41a40e:	e9 5e e1 ff ff       	jmp    418571 <fmt_fp+0x551>
  41a413:	d9 05 c3 5a 00 00    	fld    DWORD PTR [rip+0x5ac3]        # 41fedc <states+0x1fc>
  41a419:	e9 53 e1 ff ff       	jmp    418571 <fmt_fp+0x551>
  41a41e:	44 89 eb             	mov    ebx,r13d
  41a421:	4c 8b 6c 24 08       	mov    r13,QWORD PTR [rsp+0x8]
  41a426:	e9 9f e3 ff ff       	jmp    4187ca <fmt_fp+0x7aa>

000000000041a42b <printf_core.cold>:
  41a42b:	44 8d 85 00 ff ff ff 	lea    r8d,[rbp-0x100]
  41a432:	66 0f 6e ed          	movd   xmm5,ebp
	for (; l >= sizeof pad; l -= sizeof pad)
  41a436:	31 c9                	xor    ecx,ecx
  41a438:	66 0f 6f 0d 30 5b 00 	movdqa xmm1,XMMWORD PTR [rip+0x5b30]        # 41ff70 <states+0x290>
  41a43f:	00 
  41a440:	44 89 c0             	mov    eax,r8d
  41a443:	66 0f 70 dd 00       	pshufd xmm3,xmm5,0x0
  41a448:	66 0f 6f 05 30 5b 00 	movdqa xmm0,XMMWORD PTR [rip+0x5b30]        # 41ff80 <states+0x2a0>
  41a44f:	00 
  41a450:	66 0f fe 1d 08 5b 00 	paddd  xmm3,XMMWORD PTR [rip+0x5b08]        # 41ff60 <states+0x280>
  41a457:	00 
  41a458:	c1 e8 08             	shr    eax,0x8
  41a45b:	8d 70 01             	lea    esi,[rax+0x1]
  41a45e:	41 89 f1             	mov    r9d,esi
  41a461:	41 c1 e9 02          	shr    r9d,0x2
  41a465:	66 0f 6f d3          	movdqa xmm2,xmm3
  41a469:	83 c1 01             	add    ecx,0x1
  41a46c:	66 0f fe d9          	paddd  xmm3,xmm1
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a470:	89 d0                	mov    eax,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  41a472:	66 0f fe d0          	paddd  xmm2,xmm0
  41a476:	44 39 c9             	cmp    ecx,r9d
  41a479:	72 ea                	jb     41a465 <printf_core.cold+0x3a>
  41a47b:	89 f1                	mov    ecx,esi
  41a47d:	66 0f 70 c2 ff       	pshufd xmm0,xmm2,0xff
  41a482:	83 e1 fc             	and    ecx,0xfffffffc
  41a485:	66 41 0f 7e c5       	movd   r13d,xmm0
  41a48a:	69 d1 00 ff ff ff    	imul   edx,ecx,0xffffff00
  41a490:	39 f1                	cmp    ecx,esi
  41a492:	0f 84 47 0b 00 00    	je     41afdf <printf_core+0x7bf>
  41a498:	44 01 c2             	add    edx,r8d
  41a49b:	41 89 d5             	mov    r13d,edx
  41a49e:	81 fa ff 00 00 00    	cmp    edx,0xff
  41a4a4:	0f 86 35 0b 00 00    	jbe    41afdf <printf_core+0x7bf>
  41a4aa:	41 81 ed 00 01 00 00 	sub    r13d,0x100
  41a4b1:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  41a4b8:	0f 86 21 0b 00 00    	jbe    41afdf <printf_core+0x7bf>
  41a4be:	44 8d aa 00 fe ff ff 	lea    r13d,[rdx-0x200]
  41a4c5:	e9 15 0b 00 00       	jmp    41afdf <printf_core+0x7bf>
  41a4ca:	45 8d 93 00 ff ff ff 	lea    r10d,[r11-0x100]
  41a4d1:	66 41 0f 6e eb       	movd   xmm5,r11d
  41a4d6:	45 31 c0             	xor    r8d,r8d
  41a4d9:	66 0f 6f 0d 8f 5a 00 	movdqa xmm1,XMMWORD PTR [rip+0x5a8f]        # 41ff70 <states+0x290>
  41a4e0:	00 
  41a4e1:	44 89 d6             	mov    esi,r10d
  41a4e4:	66 0f 70 dd 00       	pshufd xmm3,xmm5,0x0
  41a4e9:	66 0f 6f 05 8f 5a 00 	movdqa xmm0,XMMWORD PTR [rip+0x5a8f]        # 41ff80 <states+0x2a0>
  41a4f0:	00 
  41a4f1:	66 0f fe 1d 67 5a 00 	paddd  xmm3,XMMWORD PTR [rip+0x5a67]        # 41ff60 <states+0x280>
  41a4f8:	00 
  41a4f9:	c1 ee 08             	shr    esi,0x8
  41a4fc:	83 c6 01             	add    esi,0x1
  41a4ff:	41 89 f1             	mov    r9d,esi
  41a502:	41 c1 e9 02          	shr    r9d,0x2
  41a506:	66 0f 6f d3          	movdqa xmm2,xmm3
  41a50a:	41 83 c0 01          	add    r8d,0x1
  41a50e:	66 0f fe d9          	paddd  xmm3,xmm1
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a512:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  41a514:	66 0f fe d0          	paddd  xmm2,xmm0
  41a518:	45 39 c1             	cmp    r9d,r8d
  41a51b:	77 e9                	ja     41a506 <printf_core.cold+0xdb>
  41a51d:	41 89 f1             	mov    r9d,esi
  41a520:	66 0f 70 c2 ff       	pshufd xmm0,xmm2,0xff
  41a525:	41 83 e1 fc          	and    r9d,0xfffffffc
  41a529:	66 41 0f 7e c0       	movd   r8d,xmm0
  41a52e:	41 69 c1 00 ff ff ff 	imul   eax,r9d,0xffffff00
  41a535:	41 39 f1             	cmp    r9d,esi
  41a538:	0f 84 fa 0f 00 00    	je     41b538 <printf_core+0xd18>
  41a53e:	44 01 d0             	add    eax,r10d
  41a541:	41 89 c0             	mov    r8d,eax
  41a544:	3d ff 00 00 00       	cmp    eax,0xff
  41a549:	0f 86 e9 0f 00 00    	jbe    41b538 <printf_core+0xd18>
  41a54f:	41 81 e8 00 01 00 00 	sub    r8d,0x100
  41a556:	41 81 f8 ff 00 00 00 	cmp    r8d,0xff
  41a55d:	0f 86 d5 0f 00 00    	jbe    41b538 <printf_core+0xd18>
  41a563:	44 8d 80 00 fe ff ff 	lea    r8d,[rax-0x200]
  41a56a:	e9 c9 0f 00 00       	jmp    41b538 <printf_core+0xd18>
  41a56f:	44 8d 85 00 ff ff ff 	lea    r8d,[rbp-0x100]
  41a576:	66 0f 6e fd          	movd   xmm7,ebp
  41a57a:	31 f6                	xor    esi,esi
  41a57c:	44 89 c1             	mov    ecx,r8d
  41a57f:	66 0f 70 c7 00       	pshufd xmm0,xmm7,0x0
  41a584:	66 0f fe 05 d4 59 00 	paddd  xmm0,XMMWORD PTR [rip+0x59d4]        # 41ff60 <states+0x280>
  41a58b:	00 
  41a58c:	c1 e9 08             	shr    ecx,0x8
  41a58f:	83 c1 01             	add    ecx,0x1
  41a592:	41 89 c9             	mov    r9d,ecx
  41a595:	41 c1 e9 02          	shr    r9d,0x2
  41a599:	83 c6 01             	add    esi,0x1
  41a59c:	66 0f 6f c8          	movdqa xmm1,xmm0
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a5a0:	89 c2                	mov    edx,eax
  41a5a2:	66 0f fe 05 c6 59 00 	paddd  xmm0,XMMWORD PTR [rip+0x59c6]        # 41ff70 <states+0x290>
  41a5a9:	00 
	for (; l >= sizeof pad; l -= sizeof pad)
  41a5aa:	66 0f fe 0d ce 59 00 	paddd  xmm1,XMMWORD PTR [rip+0x59ce]        # 41ff80 <states+0x2a0>
  41a5b1:	00 
  41a5b2:	44 39 ce             	cmp    esi,r9d
  41a5b5:	72 e2                	jb     41a599 <printf_core.cold+0x16e>
  41a5b7:	89 ce                	mov    esi,ecx
  41a5b9:	66 0f 70 c1 ff       	pshufd xmm0,xmm1,0xff
  41a5be:	83 e6 fc             	and    esi,0xfffffffc
  41a5c1:	66 41 0f 7e c4       	movd   r12d,xmm0
  41a5c6:	69 c6 00 ff ff ff    	imul   eax,esi,0xffffff00
  41a5cc:	39 f1                	cmp    ecx,esi
  41a5ce:	0f 84 76 0b 00 00    	je     41b14a <printf_core+0x92a>
  41a5d4:	44 01 c0             	add    eax,r8d
  41a5d7:	41 89 c4             	mov    r12d,eax
  41a5da:	3d ff 00 00 00       	cmp    eax,0xff
  41a5df:	0f 86 65 0b 00 00    	jbe    41b14a <printf_core+0x92a>
  41a5e5:	41 81 ec 00 01 00 00 	sub    r12d,0x100
  41a5ec:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  41a5f3:	0f 86 51 0b 00 00    	jbe    41b14a <printf_core+0x92a>
  41a5f9:	44 8d a0 00 fe ff ff 	lea    r12d,[rax-0x200]
  41a600:	e9 45 0b 00 00       	jmp    41b14a <printf_core+0x92a>
  41a605:	44 8d 85 00 ff ff ff 	lea    r8d,[rbp-0x100]
  41a60c:	66 0f 6e f5          	movd   xmm6,ebp
  41a610:	31 c9                	xor    ecx,ecx
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a612:	89 c6                	mov    esi,eax
  41a614:	44 89 c2             	mov    edx,r8d
  41a617:	66 0f 70 de 00       	pshufd xmm3,xmm6,0x0
  41a61c:	66 0f 6f 0d 4c 59 00 	movdqa xmm1,XMMWORD PTR [rip+0x594c]        # 41ff70 <states+0x290>
  41a623:	00 
  41a624:	66 0f fe 1d 34 59 00 	paddd  xmm3,XMMWORD PTR [rip+0x5934]        # 41ff60 <states+0x280>
  41a62b:	00 
  41a62c:	c1 ea 08             	shr    edx,0x8
  41a62f:	66 0f 6f 05 49 59 00 	movdqa xmm0,XMMWORD PTR [rip+0x5949]        # 41ff80 <states+0x2a0>
  41a636:	00 
  41a637:	83 c2 01             	add    edx,0x1
  41a63a:	41 89 d1             	mov    r9d,edx
  41a63d:	41 c1 e9 02          	shr    r9d,0x2
  41a641:	66 0f 6f d3          	movdqa xmm2,xmm3
  41a645:	83 c1 01             	add    ecx,0x1
  41a648:	66 0f fe d9          	paddd  xmm3,xmm1
  41a64c:	89 f0                	mov    eax,esi
	for (; l >= sizeof pad; l -= sizeof pad)
  41a64e:	66 0f fe d0          	paddd  xmm2,xmm0
  41a652:	44 39 c9             	cmp    ecx,r9d
  41a655:	72 ea                	jb     41a641 <printf_core.cold+0x216>
  41a657:	89 d6                	mov    esi,edx
  41a659:	66 0f 70 c2 ff       	pshufd xmm0,xmm2,0xff
  41a65e:	83 e6 fc             	and    esi,0xfffffffc
  41a661:	66 41 0f 7e c5       	movd   r13d,xmm0
  41a666:	69 ce 00 ff ff ff    	imul   ecx,esi,0xffffff00
  41a66c:	39 d6                	cmp    esi,edx
  41a66e:	0f 84 30 0a 00 00    	je     41b0a4 <printf_core+0x884>
  41a674:	44 01 c1             	add    ecx,r8d
  41a677:	41 89 cd             	mov    r13d,ecx
  41a67a:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  41a680:	0f 86 1e 0a 00 00    	jbe    41b0a4 <printf_core+0x884>
  41a686:	41 81 ed 00 01 00 00 	sub    r13d,0x100
  41a68d:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  41a694:	0f 86 0a 0a 00 00    	jbe    41b0a4 <printf_core+0x884>
  41a69a:	44 8d a9 00 fe ff ff 	lea    r13d,[rcx-0x200]
  41a6a1:	e9 fe 09 00 00       	jmp    41b0a4 <printf_core+0x884>
  41a6a6:	41 8d 8c 24 00 e8 ff 	lea    ecx,[r12-0x1800]
  41a6ad:	ff 
  41a6ae:	81 f9 00 e9 ff 7f    	cmp    ecx,0x7fffe900
  41a6b4:	0f 87 45 01 00 00    	ja     41a7ff <printf_core.cold+0x3d4>
  41a6ba:	41 8d b4 24 00 fe ff 	lea    esi,[r12-0x200]
  41a6c1:	ff 
  41a6c2:	66 41 0f 6e f4       	movd   xmm6,r12d
  41a6c7:	45 31 c9             	xor    r9d,r9d
  41a6ca:	66 0f 6f 0d 9e 58 00 	movdqa xmm1,XMMWORD PTR [rip+0x589e]        # 41ff70 <states+0x290>
  41a6d1:	00 
  41a6d2:	89 f2                	mov    edx,esi
  41a6d4:	66 0f 70 de 00       	pshufd xmm3,xmm6,0x0
  41a6d9:	66 0f 6f 05 9f 58 00 	movdqa xmm0,XMMWORD PTR [rip+0x589f]        # 41ff80 <states+0x2a0>
  41a6e0:	00 
  41a6e1:	66 0f fe 1d b7 58 00 	paddd  xmm3,XMMWORD PTR [rip+0x58b7]        # 41ffa0 <states+0x2c0>
  41a6e8:	00 
  41a6e9:	c1 ea 08             	shr    edx,0x8
  41a6ec:	83 c2 01             	add    edx,0x1
  41a6ef:	41 89 d0             	mov    r8d,edx
  41a6f2:	41 c1 e8 02          	shr    r8d,0x2
  41a6f6:	66 0f 6f d3          	movdqa xmm2,xmm3
  41a6fa:	41 83 c1 01          	add    r9d,0x1
  41a6fe:	66 0f fe d9          	paddd  xmm3,xmm1
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a702:	89 c1                	mov    ecx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  41a704:	66 0f fe d0          	paddd  xmm2,xmm0
  41a708:	45 39 c8             	cmp    r8d,r9d
  41a70b:	77 e9                	ja     41a6f6 <printf_core.cold+0x2cb>
  41a70d:	41 89 d0             	mov    r8d,edx
  41a710:	66 0f 70 c2 ff       	pshufd xmm0,xmm2,0xff
  41a715:	41 83 e0 fc          	and    r8d,0xfffffffc
  41a719:	66 41 0f 7e c1       	movd   r9d,xmm0
  41a71e:	41 69 c0 00 ff ff ff 	imul   eax,r8d,0xffffff00
  41a725:	41 39 d0             	cmp    r8d,edx
  41a728:	0f 84 f3 11 00 00    	je     41b921 <printf_core+0x1101>
  41a72e:	01 f0                	add    eax,esi
  41a730:	41 89 c1             	mov    r9d,eax
  41a733:	3d ff 00 00 00       	cmp    eax,0xff
  41a738:	0f 86 e3 11 00 00    	jbe    41b921 <printf_core+0x1101>
  41a73e:	41 81 e9 00 01 00 00 	sub    r9d,0x100
  41a745:	41 81 f9 ff 00 00 00 	cmp    r9d,0xff
  41a74c:	0f 86 cf 11 00 00    	jbe    41b921 <printf_core+0x1101>
  41a752:	44 8d 88 00 fe ff ff 	lea    r9d,[rax-0x200]
  41a759:	e9 c3 11 00 00       	jmp    41b921 <printf_core+0x1101>
  41a75e:	44 8d 85 00 ff ff ff 	lea    r8d,[rbp-0x100]
  41a765:	66 0f 6e fd          	movd   xmm7,ebp
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a769:	89 c1                	mov    ecx,eax
  41a76b:	66 0f 6f 0d fd 57 00 	movdqa xmm1,XMMWORD PTR [rip+0x57fd]        # 41ff70 <states+0x290>
  41a772:	00 
  41a773:	44 89 c2             	mov    edx,r8d
  41a776:	66 0f 70 df 00       	pshufd xmm3,xmm7,0x0
  41a77b:	66 0f 6f 05 fd 57 00 	movdqa xmm0,XMMWORD PTR [rip+0x57fd]        # 41ff80 <states+0x2a0>
  41a782:	00 
  41a783:	66 0f fe 1d d5 57 00 	paddd  xmm3,XMMWORD PTR [rip+0x57d5]        # 41ff60 <states+0x280>
  41a78a:	00 
  41a78b:	c1 ea 08             	shr    edx,0x8
  41a78e:	8d 72 01             	lea    esi,[rdx+0x1]
	for (; l >= sizeof pad; l -= sizeof pad)
  41a791:	31 d2                	xor    edx,edx
  41a793:	41 89 f1             	mov    r9d,esi
  41a796:	41 c1 e9 02          	shr    r9d,0x2
  41a79a:	66 0f 6f d3          	movdqa xmm2,xmm3
  41a79e:	83 c2 01             	add    edx,0x1
  41a7a1:	66 0f fe d9          	paddd  xmm3,xmm1
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a7a5:	89 c8                	mov    eax,ecx
	for (; l >= sizeof pad; l -= sizeof pad)
  41a7a7:	66 0f fe d0          	paddd  xmm2,xmm0
  41a7ab:	44 39 ca             	cmp    edx,r9d
  41a7ae:	72 ea                	jb     41a79a <printf_core.cold+0x36f>
  41a7b0:	89 f1                	mov    ecx,esi
  41a7b2:	66 0f 70 c2 ff       	pshufd xmm0,xmm2,0xff
  41a7b7:	83 e1 fc             	and    ecx,0xfffffffc
  41a7ba:	66 41 0f 7e c5       	movd   r13d,xmm0
  41a7bf:	69 d1 00 ff ff ff    	imul   edx,ecx,0xffffff00
  41a7c5:	39 f1                	cmp    ecx,esi
  41a7c7:	0f 84 27 07 00 00    	je     41aef4 <printf_core+0x6d4>
  41a7cd:	44 01 c2             	add    edx,r8d
  41a7d0:	41 89 d5             	mov    r13d,edx
  41a7d3:	81 fa ff 00 00 00    	cmp    edx,0xff
  41a7d9:	0f 86 15 07 00 00    	jbe    41aef4 <printf_core+0x6d4>
  41a7df:	41 81 ed 00 01 00 00 	sub    r13d,0x100
  41a7e6:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  41a7ed:	0f 86 01 07 00 00    	jbe    41aef4 <printf_core+0x6d4>
  41a7f3:	44 8d aa 00 fe ff ff 	lea    r13d,[rdx-0x200]
  41a7fa:	e9 f5 06 00 00       	jmp    41aef4 <printf_core+0x6d4>
  41a7ff:	81 ea 00 01 00 00    	sub    edx,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a805:	89 c1                	mov    ecx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  41a807:	41 89 d1             	mov    r9d,edx
  41a80a:	81 fa ff 00 00 00    	cmp    edx,0xff
  41a810:	77 ed                	ja     41a7ff <printf_core.cold+0x3d4>
  41a812:	e9 0a 11 00 00       	jmp    41b921 <printf_core+0x1101>
  41a817:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41a81e:	00 00 

000000000041a820 <printf_core>:
	}
	return i;
}

static int printf_core(FILE *f, const char *fmt, va_list *ap, union arg *nl_arg, int *nl_type)
{
  41a820:	41 57                	push   r15
  41a822:	49 89 f2             	mov    r10,rsi
  41a825:	41 56                	push   r14
  41a827:	49 89 fe             	mov    r14,rdi
  41a82a:	41 55                	push   r13
  41a82c:	41 54                	push   r12
  41a82e:	55                   	push   rbp
  41a82f:	53                   	push   rbx
  41a830:	48 81 ec b8 01 00 00 	sub    rsp,0x1b8
  41a837:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
  41a83c:	48 89 4c 24 28       	mov    QWORD PTR [rsp+0x28],rcx
  41a841:	4c 89 44 24 20       	mov    QWORD PTR [rsp+0x20],r8
	unsigned l10n=0, fl;
	int w, p, xp;
	union arg arg;
	int argpos;
	unsigned st, ps;
	int cnt=0, l=0;
  41a846:	c7 04 24 00 00 00 00 	mov    DWORD PTR [rsp],0x0
  41a84d:	c7 44 24 08 00 00 00 	mov    DWORD PTR [rsp+0x8],0x0
  41a854:	00 
	unsigned l10n=0, fl;
  41a855:	c7 44 24 0c 00 00 00 	mov    DWORD PTR [rsp+0xc],0x0
  41a85c:	00 
		 * on overflow; otherwise %n could produce wrong results. */
		if (l > INT_MAX - cnt) goto overflow;

		/* Update output count, end loop when fmt is exhausted */
		cnt += l;
		if (!*s) break;
  41a85d:	41 0f b6 02          	movzx  eax,BYTE PTR [r10]
		cnt += l;
  41a861:	8b 3c 24             	mov    edi,DWORD PTR [rsp]
  41a864:	01 7c 24 08          	add    DWORD PTR [rsp+0x8],edi
		if (!*s) break;
  41a868:	84 c0                	test   al,al
  41a86a:	0f 84 02 05 00 00    	je     41ad72 <printf_core+0x552>

		/* Handle literal text and %% format specifiers */
		for (a=s; *s && *s!='%'; s++);
  41a870:	4d 89 d7             	mov    r15,r10
  41a873:	eb 10                	jmp    41a885 <printf_core+0x65>
  41a875:	0f 1f 00             	nop    DWORD PTR [rax]
  41a878:	41 0f b6 47 01       	movzx  eax,BYTE PTR [r15+0x1]
  41a87d:	49 83 c7 01          	add    r15,0x1
  41a881:	84 c0                	test   al,al
  41a883:	74 6b                	je     41a8f0 <printf_core+0xd0>
  41a885:	3c 25                	cmp    al,0x25
  41a887:	75 ef                	jne    41a878 <printf_core+0x58>
  41a889:	4c 89 fb             	mov    rbx,r15
  41a88c:	eb 0f                	jmp    41a89d <printf_core+0x7d>
  41a88e:	66 90                	xchg   ax,ax
		for (z=s; s[0]=='%' && s[1]=='%'; z++, s+=2);
  41a890:	48 83 c3 02          	add    rbx,0x2
  41a894:	49 83 c7 01          	add    r15,0x1
  41a898:	80 3b 25             	cmp    BYTE PTR [rbx],0x25
  41a89b:	75 06                	jne    41a8a3 <printf_core+0x83>
  41a89d:	80 7b 01 25          	cmp    BYTE PTR [rbx+0x1],0x25
  41a8a1:	74 ed                	je     41a890 <printf_core+0x70>
		if (z-a > INT_MAX-cnt) goto overflow;
  41a8a3:	41 bd ff ff ff 7f    	mov    r13d,0x7fffffff
  41a8a9:	44 2b 6c 24 08       	sub    r13d,DWORD PTR [rsp+0x8]
  41a8ae:	4d 29 d7             	sub    r15,r10
  41a8b1:	49 63 c5             	movsxd rax,r13d
  41a8b4:	49 39 c7             	cmp    r15,rax
  41a8b7:	0f 8f 2c 03 00 00    	jg     41abe9 <printf_core+0x3c9>
		l = z-a;
  41a8bd:	44 89 3c 24          	mov    DWORD PTR [rsp],r15d
		if (f) out(f, a, l);
  41a8c1:	4d 85 f6             	test   r14,r14
  41a8c4:	74 0a                	je     41a8d0 <printf_core+0xb0>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41a8c6:	41 f6 06 20          	test   BYTE PTR [r14],0x20
  41a8ca:	0f 84 70 01 00 00    	je     41aa40 <printf_core+0x220>
		if (l) continue;
  41a8d0:	45 85 ff             	test   r15d,r15d
  41a8d3:	74 2b                	je     41a900 <printf_core+0xe0>
		if (l > INT_MAX - cnt) goto overflow;
  41a8d5:	44 3b 2c 24          	cmp    r13d,DWORD PTR [rsp]
  41a8d9:	0f 8c 0a 03 00 00    	jl     41abe9 <printf_core+0x3c9>
{
  41a8df:	49 89 da             	mov    r10,rbx
  41a8e2:	e9 76 ff ff ff       	jmp    41a85d <printf_core+0x3d>
  41a8e7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41a8ee:	00 00 
		for (a=s; *s && *s!='%'; s++);
  41a8f0:	4c 89 fb             	mov    rbx,r15
		for (z=s; s[0]=='%' && s[1]=='%'; z++, s+=2);
  41a8f3:	3c 25                	cmp    al,0x25
  41a8f5:	74 92                	je     41a889 <printf_core+0x69>
  41a8f7:	eb aa                	jmp    41a8a3 <printf_core+0x83>
  41a8f9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

		if (isdigit(s[1]) && s[2]=='$') {
  41a900:	0f be 4b 01          	movsx  ecx,BYTE PTR [rbx+0x1]
  41a904:	8d 71 d0             	lea    esi,[rcx-0x30]
  41a907:	89 c8                	mov    eax,ecx
  41a909:	83 fe 09             	cmp    esi,0x9
  41a90c:	77 0a                	ja     41a918 <printf_core+0xf8>
  41a90e:	80 7b 02 24          	cmp    BYTE PTR [rbx+0x2],0x24
  41a912:	0f 84 30 03 00 00    	je     41ac48 <printf_core+0x428>
			l10n=1;
			argpos = s[1]-'0';
			s+=3;
		} else {
			argpos = -1;
			s++;
  41a918:	48 83 c3 01          	add    rbx,0x1
			argpos = -1;
  41a91c:	be ff ff ff ff       	mov    esi,0xffffffff
		}

		/* Read modifier flags */
		for (fl=0; (unsigned)*s-' '<32 && (FLAGMASK&(1U<<*s-' ')); s++)
  41a921:	44 8d 41 e0          	lea    r8d,[rcx-0x20]
  41a925:	45 31 e4             	xor    r12d,r12d
  41a928:	ba 89 28 01 00       	mov    edx,0x12889
			fl |= 1U<<*s-' ';
  41a92d:	bf 01 00 00 00       	mov    edi,0x1
		for (fl=0; (unsigned)*s-' '<32 && (FLAGMASK&(1U<<*s-' ')); s++)
  41a932:	41 83 f8 1f          	cmp    r8d,0x1f
  41a936:	76 22                	jbe    41a95a <printf_core+0x13a>
  41a938:	eb 28                	jmp    41a962 <printf_core+0x142>
  41a93a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
			fl |= 1U<<*s-' ';
  41a940:	89 f8                	mov    eax,edi
		for (fl=0; (unsigned)*s-' '<32 && (FLAGMASK&(1U<<*s-' ')); s++)
  41a942:	48 83 c3 01          	add    rbx,0x1
			fl |= 1U<<*s-' ';
  41a946:	d3 e0                	shl    eax,cl
		for (fl=0; (unsigned)*s-' '<32 && (FLAGMASK&(1U<<*s-' ')); s++)
  41a948:	0f be 0b             	movsx  ecx,BYTE PTR [rbx]
			fl |= 1U<<*s-' ';
  41a94b:	41 09 c4             	or     r12d,eax
		for (fl=0; (unsigned)*s-' '<32 && (FLAGMASK&(1U<<*s-' ')); s++)
  41a94e:	44 8d 41 e0          	lea    r8d,[rcx-0x20]
  41a952:	89 c8                	mov    eax,ecx
  41a954:	41 83 f8 1f          	cmp    r8d,0x1f
  41a958:	77 08                	ja     41a962 <printf_core+0x142>
  41a95a:	83 e9 20             	sub    ecx,0x20
  41a95d:	0f a3 ca             	bt     edx,ecx
  41a960:	72 de                	jb     41a940 <printf_core+0x120>

		/* Read field width */
		if (*s=='*') {
  41a962:	3c 2a                	cmp    al,0x2a
  41a964:	0f 85 76 01 00 00    	jne    41aae0 <printf_core+0x2c0>
			if (isdigit(s[1]) && s[2]=='$') {
  41a96a:	48 0f be 43 01       	movsx  rax,BYTE PTR [rbx+0x1]
  41a96f:	48 89 c1             	mov    rcx,rax
  41a972:	83 e8 30             	sub    eax,0x30
  41a975:	83 f8 09             	cmp    eax,0x9
  41a978:	0f 86 8a 02 00 00    	jbe    41ac08 <printf_core+0x3e8>
				l10n=1;
				nl_type[s[1]-'0'] = INT;
				w = nl_arg[s[1]-'0'].i;
				s+=3;
			} else if (!l10n) {
  41a97e:	44 8b 44 24 0c       	mov    r8d,DWORD PTR [rsp+0xc]
  41a983:	45 85 c0             	test   r8d,r8d
  41a986:	0f 85 22 01 00 00    	jne    41aaae <printf_core+0x28e>
				w = f ? va_arg(*ap, int) : 0;
				s++;
  41a98c:	48 83 c3 01          	add    rbx,0x1
				w = f ? va_arg(*ap, int) : 0;
  41a990:	44 89 fd             	mov    ebp,r15d
  41a993:	4d 85 f6             	test   r14,r14
  41a996:	74 2d                	je     41a9c5 <printf_core+0x1a5>
  41a998:	48 8b 7c 24 10       	mov    rdi,QWORD PTR [rsp+0x10]
  41a99d:	8b 07                	mov    eax,DWORD PTR [rdi]
  41a99f:	83 f8 2f             	cmp    eax,0x2f
  41a9a2:	0f 87 c8 02 00 00    	ja     41ac70 <printf_core+0x450>
  41a9a8:	89 c2                	mov    edx,eax
  41a9aa:	83 c0 08             	add    eax,0x8
  41a9ad:	48 03 57 10          	add    rdx,QWORD PTR [rdi+0x10]
  41a9b1:	89 07                	mov    DWORD PTR [rdi],eax
  41a9b3:	8b 2a                	mov    ebp,DWORD PTR [rdx]
			} else goto inval;
			if (w<0) fl|=LEFT_ADJ, w=-w;
		} else if ((w=getint(&s))<0) goto overflow;

		/* Read precision */
		if (*s=='.' && s[1]=='*') {
  41a9b5:	0f b6 0b             	movzx  ecx,BYTE PTR [rbx]
			if (w<0) fl|=LEFT_ADJ, w=-w;
  41a9b8:	85 ed                	test   ebp,ebp
  41a9ba:	79 09                	jns    41a9c5 <printf_core+0x1a5>
  41a9bc:	41 81 cc 00 20 00 00 	or     r12d,0x2000
  41a9c3:	f7 dd                	neg    ebp
		if (*s=='.' && s[1]=='*') {
  41a9c5:	80 f9 2e             	cmp    cl,0x2e
  41a9c8:	0f 85 92 00 00 00    	jne    41aa60 <printf_core+0x240>
  41a9ce:	0f be 43 01          	movsx  eax,BYTE PTR [rbx+0x1]
  41a9d2:	3c 2a                	cmp    al,0x2a
  41a9d4:	0f 85 ae 02 00 00    	jne    41ac88 <printf_core+0x468>
			if (isdigit(s[2]) && s[3]=='$') {
  41a9da:	48 0f be 43 02       	movsx  rax,BYTE PTR [rbx+0x2]
  41a9df:	48 89 c2             	mov    rdx,rax
  41a9e2:	83 e8 30             	sub    eax,0x30
  41a9e5:	83 f8 09             	cmp    eax,0x9
  41a9e8:	77 0a                	ja     41a9f4 <printf_core+0x1d4>
  41a9ea:	80 7b 03 24          	cmp    BYTE PTR [rbx+0x3],0x24
  41a9ee:	0f 84 33 03 00 00    	je     41ad27 <printf_core+0x507>
				nl_type[s[2]-'0'] = INT;
				p = nl_arg[s[2]-'0'].i;
				s+=4;
			} else if (!l10n) {
  41a9f4:	8b 7c 24 0c          	mov    edi,DWORD PTR [rsp+0xc]
  41a9f8:	85 ff                	test   edi,edi
  41a9fa:	0f 85 ae 00 00 00    	jne    41aaae <printf_core+0x28e>
				p = f ? va_arg(*ap, int) : 0;
  41aa00:	4d 85 f6             	test   r14,r14
  41aa03:	0f 84 59 03 00 00    	je     41ad62 <printf_core+0x542>
  41aa09:	48 8b 7c 24 10       	mov    rdi,QWORD PTR [rsp+0x10]
  41aa0e:	8b 07                	mov    eax,DWORD PTR [rdi]
  41aa10:	83 f8 2f             	cmp    eax,0x2f
  41aa13:	0f 87 de 02 00 00    	ja     41acf7 <printf_core+0x4d7>
  41aa19:	89 c2                	mov    edx,eax
  41aa1b:	83 c0 08             	add    eax,0x8
  41aa1e:	48 03 57 10          	add    rdx,QWORD PTR [rdi+0x10]
  41aa22:	89 07                	mov    DWORD PTR [rdi],eax
  41aa24:	44 8b 1a             	mov    r11d,DWORD PTR [rdx]
				s+=2;
			} else goto inval;
			xp = (p>=0);
  41aa27:	44 89 d8             	mov    eax,r11d
  41aa2a:	f7 d0                	not    eax
  41aa2c:	c1 e8 1f             	shr    eax,0x1f
  41aa2f:	89 44 24 18          	mov    DWORD PTR [rsp+0x18],eax
				s+=2;
  41aa33:	48 83 c3 02          	add    rbx,0x2
			xp = (p>=0);
  41aa37:	eb 32                	jmp    41aa6b <printf_core+0x24b>
  41aa39:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41aa40:	4c 89 d7             	mov    rdi,r10
		if (f) out(f, a, l);
  41aa43:	49 63 f7             	movsxd rsi,r15d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41aa46:	4c 89 f2             	mov    rdx,r14
  41aa49:	4c 89 54 24 18       	mov    QWORD PTR [rsp+0x18],r10
  41aa4e:	e8 cd 18 00 00       	call   41c320 <__fwritex>
  41aa53:	4c 8b 54 24 18       	mov    r10,QWORD PTR [rsp+0x18]
  41aa58:	e9 73 fe ff ff       	jmp    41a8d0 <printf_core+0xb0>
  41aa5d:	0f 1f 00             	nop    DWORD PTR [rax]
			s++;
			p = getint(&s);
			xp = 1;
		} else {
			p = -1;
			xp = 0;
  41aa60:	44 89 7c 24 18       	mov    DWORD PTR [rsp+0x18],r15d
			p = -1;
  41aa65:	41 bb ff ff ff ff    	mov    r11d,0xffffffff
		}

		/* Format specifier state machine */
		st=0;
  41aa6b:	45 31 c9             	xor    r9d,r9d
		do {
			if (OOB(*s)) goto inval;
			ps=st;
			st=states[st]S(*s++);
  41aa6e:	48 8d 0d 6b 52 00 00 	lea    rcx,[rip+0x526b]        # 41fce0 <states>
  41aa75:	eb 2c                	jmp    41aaa3 <printf_core+0x283>
  41aa77:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41aa7e:	00 00 
  41aa80:	45 89 c8             	mov    r8d,r9d
  41aa83:	48 98                	cdqe   
  41aa85:	48 83 c3 01          	add    rbx,0x1
  41aa89:	49 6b d0 3a          	imul   rdx,r8,0x3a
  41aa8d:	48 01 ca             	add    rdx,rcx
  41aa90:	0f b6 04 02          	movzx  eax,BYTE PTR [rdx+rax*1]
		} while (st-1<STOP);
  41aa94:	8d 50 ff             	lea    edx,[rax-0x1]
  41aa97:	83 fa 07             	cmp    edx,0x7
  41aa9a:	0f 87 b0 00 00 00    	ja     41ab50 <printf_core+0x330>
  41aaa0:	41 89 c1             	mov    r9d,eax
			if (OOB(*s)) goto inval;
  41aaa3:	0f be 03             	movsx  eax,BYTE PTR [rbx]
  41aaa6:	83 e8 41             	sub    eax,0x41
  41aaa9:	83 f8 39             	cmp    eax,0x39
  41aaac:	76 d2                	jbe    41aa80 <printf_core+0x260>
	for (; i<=NL_ARGMAX && !nl_type[i]; i++);
	if (i<=NL_ARGMAX) goto inval;
	return 1;

inval:
	errno = EINVAL;
  41aaae:	e8 8d cd ff ff       	call   417840 <__errno_location>
	return -1;
  41aab3:	c7 44 24 08 ff ff ff 	mov    DWORD PTR [rsp+0x8],0xffffffff
  41aaba:	ff 
	errno = EINVAL;
  41aabb:	c7 00 16 00 00 00    	mov    DWORD PTR [rax],0x16
overflow:
	errno = EOVERFLOW;
	return -1;
}
  41aac1:	8b 44 24 08          	mov    eax,DWORD PTR [rsp+0x8]
  41aac5:	48 81 c4 b8 01 00 00 	add    rsp,0x1b8
  41aacc:	5b                   	pop    rbx
  41aacd:	5d                   	pop    rbp
  41aace:	41 5c                	pop    r12
  41aad0:	41 5d                	pop    r13
  41aad2:	41 5e                	pop    r14
  41aad4:	41 5f                	pop    r15
  41aad6:	c3                   	ret    
  41aad7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41aade:	00 00 
	for (i=0; isdigit(**s); (*s)++) {
  41aae0:	0f be 03             	movsx  eax,BYTE PTR [rbx]
  41aae3:	44 89 fd             	mov    ebp,r15d
  41aae6:	89 c2                	mov    edx,eax
  41aae8:	83 e8 30             	sub    eax,0x30
  41aaeb:	89 d1                	mov    ecx,edx
  41aaed:	83 f8 09             	cmp    eax,0x9
  41aaf0:	76 31                	jbe    41ab23 <printf_core+0x303>
  41aaf2:	e9 ce fe ff ff       	jmp    41a9c5 <printf_core+0x1a5>
  41aaf7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41aafe:	00 00 
		if (i > INT_MAX/10U || **s-'0' > INT_MAX-10*i) i = -1;
  41ab00:	6b fd f6             	imul   edi,ebp,0xfffffff6
  41ab03:	83 ea 30             	sub    edx,0x30
  41ab06:	44 8d 87 ff ff ff 7f 	lea    r8d,[rdi+0x7fffffff]
  41ab0d:	44 39 c2             	cmp    edx,r8d
  41ab10:	7f 26                	jg     41ab38 <printf_core+0x318>
		else i = 10*i + (**s-'0');
  41ab12:	29 fa                	sub    edx,edi
  41ab14:	89 d5                	mov    ebp,edx
	for (i=0; isdigit(**s); (*s)++) {
  41ab16:	83 f8 09             	cmp    eax,0x9
  41ab19:	0f 87 c1 00 00 00    	ja     41abe0 <printf_core+0x3c0>
  41ab1f:	90                   	nop
  41ab20:	0f be d1             	movsx  edx,cl
  41ab23:	0f be 43 01          	movsx  eax,BYTE PTR [rbx+0x1]
  41ab27:	48 83 c3 01          	add    rbx,0x1
  41ab2b:	89 c1                	mov    ecx,eax
  41ab2d:	83 e8 30             	sub    eax,0x30
		if (i > INT_MAX/10U || **s-'0' > INT_MAX-10*i) i = -1;
  41ab30:	81 fd cc cc cc 0c    	cmp    ebp,0xccccccc
  41ab36:	76 c8                	jbe    41ab00 <printf_core+0x2e0>
	for (i=0; isdigit(**s); (*s)++) {
  41ab38:	83 f8 09             	cmp    eax,0x9
  41ab3b:	0f 87 a8 00 00 00    	ja     41abe9 <printf_core+0x3c9>
  41ab41:	bd ff ff ff ff       	mov    ebp,0xffffffff
  41ab46:	eb d8                	jmp    41ab20 <printf_core+0x300>
  41ab48:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41ab4f:	00 
		if (!st) goto inval;
  41ab50:	85 c0                	test   eax,eax
  41ab52:	0f 84 56 ff ff ff    	je     41aaae <printf_core+0x28e>
		if (st==NOARG) {
  41ab58:	83 f8 1b             	cmp    eax,0x1b
  41ab5b:	0f 84 fe 00 00 00    	je     41ac5f <printf_core+0x43f>
			if (argpos>=0) nl_type[argpos]=st, arg=nl_arg[argpos];
  41ab61:	83 fe ff             	cmp    esi,0xffffffff
  41ab64:	0f 84 9e 01 00 00    	je     41ad08 <printf_core+0x4e8>
  41ab6a:	48 8b 7c 24 20       	mov    rdi,QWORD PTR [rsp+0x20]
  41ab6f:	48 63 f6             	movsxd rsi,esi
  41ab72:	89 04 b7             	mov    DWORD PTR [rdi+rsi*4],eax
  41ab75:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  41ab7a:	48 c1 e6 04          	shl    rsi,0x4
  41ab7e:	66 0f 6f 24 30       	movdqa xmm4,XMMWORD PTR [rax+rsi*1]
  41ab83:	0f 29 64 24 70       	movaps XMMWORD PTR [rsp+0x70],xmm4
		if (!f) continue;
  41ab88:	4d 85 f6             	test   r14,r14
  41ab8b:	0f 84 4e fd ff ff    	je     41a8df <printf_core+0xbf>
		t = s[-1];
  41ab91:	0f be 53 ff          	movsx  edx,BYTE PTR [rbx-0x1]
  41ab95:	89 d0                	mov    eax,edx
		if (ps && (t&15)==3) t&=~32;
  41ab97:	45 85 c9             	test   r9d,r9d
  41ab9a:	74 11                	je     41abad <printf_core+0x38d>
  41ab9c:	89 d1                	mov    ecx,edx
  41ab9e:	83 e0 df             	and    eax,0xffffffdf
  41aba1:	83 e1 0f             	and    ecx,0xf
  41aba4:	0f be c0             	movsx  eax,al
  41aba7:	80 f9 03             	cmp    cl,0x3
  41abaa:	0f 44 d0             	cmove  edx,eax
		if (fl & LEFT_ADJ) fl &= ~ZERO_PAD;
  41abad:	44 89 e0             	mov    eax,r12d
  41abb0:	25 ff ff fe ff       	and    eax,0xfffeffff
  41abb5:	41 f7 c4 00 20 00 00 	test   r12d,0x2000
  41abbc:	44 0f 45 e0          	cmovne r12d,eax
		switch(t) {
  41abc0:	8d 42 bf             	lea    eax,[rdx-0x41]
  41abc3:	83 f8 37             	cmp    eax,0x37
  41abc6:	0f 87 0c 02 00 00    	ja     41add8 <printf_core+0x5b8>
  41abcc:	48 8d 0d fd 4f 00 00 	lea    rcx,[rip+0x4ffd]        # 41fbd0 <CSWTCH.187+0x7e0>
  41abd3:	48 63 04 81          	movsxd rax,DWORD PTR [rcx+rax*4]
  41abd7:	48 01 c8             	add    rax,rcx
  41abda:	3e ff e0             	notrack jmp rax
  41abdd:	0f 1f 00             	nop    DWORD PTR [rax]
		} else if ((w=getint(&s))<0) goto overflow;
  41abe0:	83 fa ff             	cmp    edx,0xffffffff
  41abe3:	0f 85 dc fd ff ff    	jne    41a9c5 <printf_core+0x1a5>
	errno = EOVERFLOW;
  41abe9:	e8 52 cc ff ff       	call   417840 <__errno_location>
	return -1;
  41abee:	c7 44 24 08 ff ff ff 	mov    DWORD PTR [rsp+0x8],0xffffffff
  41abf5:	ff 
	errno = EOVERFLOW;
  41abf6:	c7 00 4b 00 00 00    	mov    DWORD PTR [rax],0x4b
	return -1;
  41abfc:	e9 c0 fe ff ff       	jmp    41aac1 <printf_core+0x2a1>
  41ac01:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
			if (isdigit(s[1]) && s[2]=='$') {
  41ac08:	80 7b 02 24          	cmp    BYTE PTR [rbx+0x2],0x24
  41ac0c:	0f 85 6c fd ff ff    	jne    41a97e <printf_core+0x15e>
				nl_type[s[1]-'0'] = INT;
  41ac12:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
				w = nl_arg[s[1]-'0'].i;
  41ac17:	48 8b 7c 24 28       	mov    rdi,QWORD PTR [rsp+0x28]
				l10n=1;
  41ac1c:	c7 44 24 0c 01 00 00 	mov    DWORD PTR [rsp+0xc],0x1
  41ac23:	00 
				s+=3;
  41ac24:	48 83 c3 03          	add    rbx,0x3
				nl_type[s[1]-'0'] = INT;
  41ac28:	c7 84 88 40 ff ff ff 	mov    DWORD PTR [rax+rcx*4-0xc0],0xa
  41ac2f:	0a 00 00 00 
				w = nl_arg[s[1]-'0'].i;
  41ac33:	48 0f be 43 fe       	movsx  rax,BYTE PTR [rbx-0x2]
  41ac38:	48 c1 e0 04          	shl    rax,0x4
  41ac3c:	8b ac 07 00 fd ff ff 	mov    ebp,DWORD PTR [rdi+rax*1-0x300]
				s+=3;
  41ac43:	e9 6d fd ff ff       	jmp    41a9b5 <printf_core+0x195>
		for (fl=0; (unsigned)*s-' '<32 && (FLAGMASK&(1U<<*s-' ')); s++)
  41ac48:	0f be 4b 03          	movsx  ecx,BYTE PTR [rbx+0x3]
			l10n=1;
  41ac4c:	c7 44 24 0c 01 00 00 	mov    DWORD PTR [rsp+0xc],0x1
  41ac53:	00 
			s+=3;
  41ac54:	48 83 c3 03          	add    rbx,0x3
		for (fl=0; (unsigned)*s-' '<32 && (FLAGMASK&(1U<<*s-' ')); s++)
  41ac58:	89 c8                	mov    eax,ecx
			s+=3;
  41ac5a:	e9 c2 fc ff ff       	jmp    41a921 <printf_core+0x101>
			if (argpos>=0) goto inval;
  41ac5f:	83 fe ff             	cmp    esi,0xffffffff
  41ac62:	0f 84 20 ff ff ff    	je     41ab88 <printf_core+0x368>
  41ac68:	e9 41 fe ff ff       	jmp    41aaae <printf_core+0x28e>
  41ac6d:	0f 1f 00             	nop    DWORD PTR [rax]
				w = f ? va_arg(*ap, int) : 0;
  41ac70:	48 8b 57 08          	mov    rdx,QWORD PTR [rdi+0x8]
  41ac74:	48 8d 42 08          	lea    rax,[rdx+0x8]
  41ac78:	48 89 47 08          	mov    QWORD PTR [rdi+0x8],rax
  41ac7c:	e9 32 fd ff ff       	jmp    41a9b3 <printf_core+0x193>
  41ac81:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (i=0; isdigit(**s); (*s)++) {
  41ac88:	8d 50 d0             	lea    edx,[rax-0x30]
			s++;
  41ac8b:	48 83 c3 01          	add    rbx,0x1
	for (i=0; isdigit(**s); (*s)++) {
  41ac8f:	45 89 fb             	mov    r11d,r15d
  41ac92:	83 fa 09             	cmp    edx,0x9
  41ac95:	77 53                	ja     41acea <printf_core+0x4ca>
		if (i > INT_MAX/10U || **s-'0' > INT_MAX-10*i) i = -1;
  41ac97:	bf ff ff ff ff       	mov    edi,0xffffffff
  41ac9c:	eb 2d                	jmp    41accb <printf_core+0x4ab>
  41ac9e:	66 90                	xchg   ax,ax
  41aca0:	45 6b db f6          	imul   r11d,r11d,0xfffffff6
  41aca4:	83 e8 30             	sub    eax,0x30
  41aca7:	89 c2                	mov    edx,eax
  41aca9:	41 8d 8b ff ff ff 7f 	lea    ecx,[r11+0x7fffffff]
  41acb0:	44 29 da             	sub    edx,r11d
  41acb3:	39 c8                	cmp    eax,ecx
  41acb5:	0f 4f d7             	cmovg  edx,edi
	for (i=0; isdigit(**s); (*s)++) {
  41acb8:	0f be 43 01          	movsx  eax,BYTE PTR [rbx+0x1]
  41acbc:	48 83 c3 01          	add    rbx,0x1
  41acc0:	41 89 d3             	mov    r11d,edx
  41acc3:	8d 50 d0             	lea    edx,[rax-0x30]
  41acc6:	83 fa 09             	cmp    edx,0x9
  41acc9:	77 1f                	ja     41acea <printf_core+0x4ca>
		if (i > INT_MAX/10U || **s-'0' > INT_MAX-10*i) i = -1;
  41accb:	41 81 fb cc cc cc 0c 	cmp    r11d,0xccccccc
  41acd2:	76 cc                	jbe    41aca0 <printf_core+0x480>
	for (i=0; isdigit(**s); (*s)++) {
  41acd4:	0f be 43 01          	movsx  eax,BYTE PTR [rbx+0x1]
  41acd8:	48 83 c3 01          	add    rbx,0x1
		if (i > INT_MAX/10U || **s-'0' > INT_MAX-10*i) i = -1;
  41acdc:	41 bb ff ff ff ff    	mov    r11d,0xffffffff
	for (i=0; isdigit(**s); (*s)++) {
  41ace2:	8d 50 d0             	lea    edx,[rax-0x30]
  41ace5:	83 fa 09             	cmp    edx,0x9
  41ace8:	76 e1                	jbe    41accb <printf_core+0x4ab>
			xp = 1;
  41acea:	c7 44 24 18 01 00 00 	mov    DWORD PTR [rsp+0x18],0x1
  41acf1:	00 
  41acf2:	e9 74 fd ff ff       	jmp    41aa6b <printf_core+0x24b>
				p = f ? va_arg(*ap, int) : 0;
  41acf7:	48 8b 57 08          	mov    rdx,QWORD PTR [rdi+0x8]
  41acfb:	48 8d 42 08          	lea    rax,[rdx+0x8]
  41acff:	48 89 47 08          	mov    QWORD PTR [rdi+0x8],rax
  41ad03:	e9 1c fd ff ff       	jmp    41aa24 <printf_core+0x204>
			else if (f) pop_arg(&arg, st, ap);
  41ad08:	4d 85 f6             	test   r14,r14
  41ad0b:	0f 84 0c 0d 00 00    	je     41ba1d <printf_core+0x11fd>
  41ad11:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
  41ad16:	48 8d 7c 24 70       	lea    rdi,[rsp+0x70]
  41ad1b:	89 c6                	mov    esi,eax
  41ad1d:	e8 7e cb ff ff       	call   4178a0 <pop_arg>
		if (!f) continue;
  41ad22:	e9 6a fe ff ff       	jmp    41ab91 <printf_core+0x371>
				nl_type[s[2]-'0'] = INT;
  41ad27:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
				p = nl_arg[s[2]-'0'].i;
  41ad2c:	48 8b 7c 24 28       	mov    rdi,QWORD PTR [rsp+0x28]
				s+=4;
  41ad31:	48 83 c3 04          	add    rbx,0x4
				nl_type[s[2]-'0'] = INT;
  41ad35:	c7 84 90 40 ff ff ff 	mov    DWORD PTR [rax+rdx*4-0xc0],0xa
  41ad3c:	0a 00 00 00 
				p = nl_arg[s[2]-'0'].i;
  41ad40:	48 0f be 43 fe       	movsx  rax,BYTE PTR [rbx-0x2]
  41ad45:	48 c1 e0 04          	shl    rax,0x4
  41ad49:	48 8b 84 07 00 fd ff 	mov    rax,QWORD PTR [rdi+rax*1-0x300]
  41ad50:	ff 
  41ad51:	41 89 c3             	mov    r11d,eax
			xp = (p>=0);
  41ad54:	f7 d0                	not    eax
  41ad56:	c1 e8 1f             	shr    eax,0x1f
  41ad59:	89 44 24 18          	mov    DWORD PTR [rsp+0x18],eax
				s+=4;
  41ad5d:	e9 09 fd ff ff       	jmp    41aa6b <printf_core+0x24b>
  41ad62:	c7 44 24 18 01 00 00 	mov    DWORD PTR [rsp+0x18],0x1
  41ad69:	00 
				p = f ? va_arg(*ap, int) : 0;
  41ad6a:	45 89 fb             	mov    r11d,r15d
  41ad6d:	e9 c1 fc ff ff       	jmp    41aa33 <printf_core+0x213>
	if (f) return cnt;
  41ad72:	4d 85 f6             	test   r14,r14
  41ad75:	0f 85 46 fd ff ff    	jne    41aac1 <printf_core+0x2a1>
	if (!l10n) return 0;
  41ad7b:	44 8b 64 24 0c       	mov    r12d,DWORD PTR [rsp+0xc]
  41ad80:	45 85 e4             	test   r12d,r12d
  41ad83:	0f 84 94 0c 00 00    	je     41ba1d <printf_core+0x11fd>
  41ad89:	48 8b 7c 24 28       	mov    rdi,QWORD PTR [rsp+0x28]
	for (i=1; i<=NL_ARGMAX && nl_type[i]; i++)
  41ad8e:	4c 8b 4c 24 10       	mov    r9,QWORD PTR [rsp+0x10]
  41ad93:	41 b8 01 00 00 00    	mov    r8d,0x1
  41ad99:	4c 8b 54 24 20       	mov    r10,QWORD PTR [rsp+0x20]
  41ad9e:	48 83 c7 10          	add    rdi,0x10
  41ada2:	43 8b 34 82          	mov    esi,DWORD PTR [r10+r8*4]
  41ada6:	85 f6                	test   esi,esi
  41ada8:	0f 84 ca 0c 00 00    	je     41ba78 <printf_core+0x1258>
		pop_arg(nl_arg+i, nl_type[i], ap);
  41adae:	4c 89 ca             	mov    rdx,r9
	for (i=1; i<=NL_ARGMAX && nl_type[i]; i++)
  41adb1:	49 83 c0 01          	add    r8,0x1
		pop_arg(nl_arg+i, nl_type[i], ap);
  41adb5:	e8 e6 ca ff ff       	call   4178a0 <pop_arg>
	for (i=1; i<=NL_ARGMAX && nl_type[i]; i++)
  41adba:	48 83 c7 10          	add    rdi,0x10
  41adbe:	49 83 f8 0a          	cmp    r8,0xa
  41adc2:	75 de                	jne    41ada2 <printf_core+0x582>
	return 1;
  41adc4:	c7 44 24 08 01 00 00 	mov    DWORD PTR [rsp+0x8],0x1
  41adcb:	00 
  41adcc:	e9 f0 fc ff ff       	jmp    41aac1 <printf_core+0x2a1>
  41add1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		if (p < z-a) p = z-a;
  41add8:	48 8d 84 24 ab 00 00 	lea    rax,[rsp+0xab]
  41addf:	00 
  41ade0:	4c 29 d0             	sub    rax,r10
  41ade3:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  41ade8:	48 8d 35 ce 4d 00 00 	lea    rsi,[rip+0x4dce]        # 41fbbd <CSWTCH.187+0x7cd>
  41adef:	44 89 7c 24 40       	mov    DWORD PTR [rsp+0x40],r15d
  41adf4:	49 63 c3             	movsxd rax,r11d
  41adf7:	ba ff ff ff 7f       	mov    edx,0x7fffffff
  41adfc:	48 89 74 24 50       	mov    QWORD PTR [rsp+0x50],rsi
  41ae01:	48 39 44 24 30       	cmp    QWORD PTR [rsp+0x30],rax
  41ae06:	7e 0e                	jle    41ae16 <printf_core+0x5f6>
  41ae08:	44 8b 5c 24 30       	mov    r11d,DWORD PTR [rsp+0x30]
		if (p > INT_MAX-pl) goto overflow;
  41ae0d:	41 39 d3             	cmp    r11d,edx
  41ae10:	0f 8f d3 fd ff ff    	jg     41abe9 <printf_core+0x3c9>
		if (w < pl+p) w = pl+p;
  41ae16:	8b 44 24 40          	mov    eax,DWORD PTR [rsp+0x40]
  41ae1a:	44 01 d8             	add    eax,r11d
  41ae1d:	89 44 24 38          	mov    DWORD PTR [rsp+0x38],eax
  41ae21:	8b 44 24 38          	mov    eax,DWORD PTR [rsp+0x38]
  41ae25:	39 c5                	cmp    ebp,eax
  41ae27:	0f 4c e8             	cmovl  ebp,eax
  41ae2a:	89 2c 24             	mov    DWORD PTR [rsp],ebp
		if (w > INT_MAX-cnt) goto overflow;
  41ae2d:	41 39 ed             	cmp    r13d,ebp
  41ae30:	0f 8c b3 fd ff ff    	jl     41abe9 <printf_core+0x3c9>
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41ae36:	39 c5                	cmp    ebp,eax
  41ae38:	0f 9e 44 24 18       	setle  BYTE PTR [rsp+0x18]
  41ae3d:	0f b6 44 24 18       	movzx  eax,BYTE PTR [rsp+0x18]
  41ae42:	41 f7 c4 00 20 01 00 	test   r12d,0x12000
  41ae49:	0f 85 90 09 00 00    	jne    41b7df <printf_core+0xfbf>
  41ae4f:	84 c0                	test   al,al
  41ae51:	0f 85 88 09 00 00    	jne    41b7df <printf_core+0xfbf>
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41ae57:	b8 00 01 00 00       	mov    eax,0x100
  41ae5c:	41 89 ed             	mov    r13d,ebp
	l = w - l;
  41ae5f:	44 2b 6c 24 38       	sub    r13d,DWORD PTR [rsp+0x38]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41ae64:	be 20 00 00 00       	mov    esi,0x20
  41ae69:	41 39 c5             	cmp    r13d,eax
  41ae6c:	4c 8d bc 24 b0 00 00 	lea    r15,[rsp+0xb0]
  41ae73:	00 
  41ae74:	4c 89 54 24 58       	mov    QWORD PTR [rsp+0x58],r10
  41ae79:	41 0f 4e c5          	cmovle eax,r13d
  41ae7d:	4c 89 ff             	mov    rdi,r15
  41ae80:	44 89 5c 24 48       	mov    DWORD PTR [rsp+0x48],r11d
  41ae85:	48 63 d0             	movsxd rdx,eax
  41ae88:	e8 cf b9 ff ff       	call   41685c <memset>
	for (; l >= sizeof pad; l -= sizeof pad)
  41ae8d:	44 8b 5c 24 48       	mov    r11d,DWORD PTR [rsp+0x48]
  41ae92:	4c 8b 54 24 58       	mov    r10,QWORD PTR [rsp+0x58]
  41ae97:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  41ae9e:	0f 8e 37 0b 00 00    	jle    41b9db <printf_core+0x11bb>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41aea4:	41 8b 16             	mov    edx,DWORD PTR [r14]
  41aea7:	41 8d ad 00 ff ff ff 	lea    ebp,[r13-0x100]
  41aeae:	45 89 e5             	mov    r13d,r12d
  41aeb1:	45 89 dc             	mov    r12d,r11d
  41aeb4:	89 d0                	mov    eax,edx
  41aeb6:	83 e0 20             	and    eax,0x20
  41aeb9:	0f 84 b9 08 00 00    	je     41b778 <printf_core+0xf58>
	for (; l >= sizeof pad; l -= sizeof pad)
  41aebf:	45 89 e3             	mov    r11d,r12d
  41aec2:	45 89 ec             	mov    r12d,r13d
  41aec5:	81 fd ff 00 00 00    	cmp    ebp,0xff
  41aecb:	7e 53                	jle    41af20 <printf_core+0x700>
  41aecd:	8d 95 00 e9 ff ff    	lea    edx,[rbp-0x1700]
  41aed3:	81 fa 00 e9 ff 7f    	cmp    edx,0x7fffe900
  41aed9:	0f 86 7f f8 ff ff    	jbe    41a75e <printf_core.cold+0x333>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41aedf:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  41aee1:	81 ed 00 01 00 00    	sub    ebp,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41aee7:	89 d0                	mov    eax,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  41aee9:	41 89 ed             	mov    r13d,ebp
  41aeec:	81 fd ff 00 00 00    	cmp    ebp,0xff
  41aef2:	77 ed                	ja     41aee1 <printf_core+0x6c1>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41aef4:	85 c0                	test   eax,eax
  41aef6:	75 30                	jne    41af28 <printf_core+0x708>
	out(f, pad, l);
  41aef8:	49 63 f5             	movsxd rsi,r13d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41aefb:	4c 89 f2             	mov    rdx,r14
  41aefe:	4c 89 ff             	mov    rdi,r15
  41af01:	4c 89 54 24 58       	mov    QWORD PTR [rsp+0x58],r10
  41af06:	44 89 5c 24 48       	mov    DWORD PTR [rsp+0x48],r11d
  41af0b:	e8 10 14 00 00       	call   41c320 <__fwritex>
  41af10:	41 8b 06             	mov    eax,DWORD PTR [r14]
  41af13:	4c 8b 54 24 58       	mov    r10,QWORD PTR [rsp+0x58]
  41af18:	44 8b 5c 24 48       	mov    r11d,DWORD PTR [rsp+0x48]
  41af1d:	83 e0 20             	and    eax,0x20
  41af20:	85 c0                	test   eax,eax
  41af22:	0f 84 c5 08 00 00    	je     41b7ed <printf_core+0xfcd>
		pad(f, '0', w, pl+p, fl^ZERO_PAD);
  41af28:	44 89 e0             	mov    eax,r12d
  41af2b:	35 00 00 01 00       	xor    eax,0x10000
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41af30:	a9 00 20 01 00       	test   eax,0x12000
  41af35:	0f 85 cd 00 00 00    	jne    41b008 <printf_core+0x7e8>
  41af3b:	80 7c 24 18 00       	cmp    BYTE PTR [rsp+0x18],0x0
  41af40:	0f 85 c2 00 00 00    	jne    41b008 <printf_core+0x7e8>
	l = w - l;
  41af46:	44 8b 2c 24          	mov    r13d,DWORD PTR [rsp]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41af4a:	b8 00 01 00 00       	mov    eax,0x100
	l = w - l;
  41af4f:	44 2b 6c 24 38       	sub    r13d,DWORD PTR [rsp+0x38]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41af54:	4c 8d bc 24 b0 00 00 	lea    r15,[rsp+0xb0]
  41af5b:	00 
  41af5c:	41 39 c5             	cmp    r13d,eax
  41af5f:	be 30 00 00 00       	mov    esi,0x30
  41af64:	4c 89 ff             	mov    rdi,r15
  41af67:	4c 89 54 24 48       	mov    QWORD PTR [rsp+0x48],r10
  41af6c:	41 0f 4e c5          	cmovle eax,r13d
  41af70:	44 89 5c 24 40       	mov    DWORD PTR [rsp+0x40],r11d
  41af75:	48 63 d0             	movsxd rdx,eax
  41af78:	e8 df b8 ff ff       	call   41685c <memset>
	for (; l >= sizeof pad; l -= sizeof pad)
  41af7d:	44 8b 5c 24 40       	mov    r11d,DWORD PTR [rsp+0x40]
  41af82:	4c 8b 54 24 48       	mov    r10,QWORD PTR [rsp+0x48]
  41af87:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  41af8e:	0f 8e 52 0a 00 00    	jle    41b9e6 <printf_core+0x11c6>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41af94:	41 8b 16             	mov    edx,DWORD PTR [r14]
  41af97:	41 8d ad 00 ff ff ff 	lea    ebp,[r13-0x100]
  41af9e:	45 89 e5             	mov    r13d,r12d
  41afa1:	45 89 dc             	mov    r12d,r11d
  41afa4:	83 e2 20             	and    edx,0x20
  41afa7:	0f 84 8b 07 00 00    	je     41b738 <printf_core+0xf18>
	for (; l >= sizeof pad; l -= sizeof pad)
  41afad:	45 89 e3             	mov    r11d,r12d
  41afb0:	45 89 ec             	mov    r12d,r13d
  41afb3:	81 fd ff 00 00 00    	cmp    ebp,0xff
  41afb9:	7e 4d                	jle    41b008 <printf_core+0x7e8>
  41afbb:	8d 85 00 e9 ff ff    	lea    eax,[rbp-0x1700]
  41afc1:	3d 00 e9 ff 7f       	cmp    eax,0x7fffe900
  41afc6:	0f 86 5f f4 ff ff    	jbe    41a42b <printf_core.cold>
  41afcc:	81 ed 00 01 00 00    	sub    ebp,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41afd2:	89 d0                	mov    eax,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  41afd4:	41 89 ed             	mov    r13d,ebp
  41afd7:	81 fd ff 00 00 00    	cmp    ebp,0xff
  41afdd:	77 ed                	ja     41afcc <printf_core+0x7ac>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41afdf:	85 c0                	test   eax,eax
  41afe1:	75 25                	jne    41b008 <printf_core+0x7e8>
	out(f, pad, l);
  41afe3:	49 63 f5             	movsxd rsi,r13d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41afe6:	4c 89 f2             	mov    rdx,r14
  41afe9:	4c 89 ff             	mov    rdi,r15
  41afec:	4c 89 54 24 48       	mov    QWORD PTR [rsp+0x48],r10
  41aff1:	44 89 5c 24 40       	mov    DWORD PTR [rsp+0x40],r11d
  41aff6:	e8 25 13 00 00       	call   41c320 <__fwritex>
  41affb:	4c 8b 54 24 48       	mov    r10,QWORD PTR [rsp+0x48]
  41b000:	44 8b 5c 24 40       	mov    r11d,DWORD PTR [rsp+0x40]
  41b005:	0f 1f 00             	nop    DWORD PTR [rax]
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41b008:	44 39 5c 24 30       	cmp    DWORD PTR [rsp+0x30],r11d
  41b00d:	0f 8d a9 07 00 00    	jge    41b7bc <printf_core+0xf9c>
	l = w - l;
  41b013:	44 2b 5c 24 30       	sub    r11d,DWORD PTR [rsp+0x30]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41b018:	b8 00 01 00 00       	mov    eax,0x100
  41b01d:	be 30 00 00 00       	mov    esi,0x30
  41b022:	4c 89 54 24 40       	mov    QWORD PTR [rsp+0x40],r10
  41b027:	41 39 c3             	cmp    r11d,eax
  41b02a:	4c 8d bc 24 b0 00 00 	lea    r15,[rsp+0xb0]
  41b031:	00 
	l = w - l;
  41b032:	45 89 dd             	mov    r13d,r11d
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41b035:	41 0f 4e c3          	cmovle eax,r11d
  41b039:	4c 89 ff             	mov    rdi,r15
  41b03c:	48 63 d0             	movsxd rdx,eax
  41b03f:	e8 18 b8 ff ff       	call   41685c <memset>
	for (; l >= sizeof pad; l -= sizeof pad)
  41b044:	41 81 fd ff 00 00 00 	cmp    r13d,0xff
  41b04b:	4c 8b 54 24 40       	mov    r10,QWORD PTR [rsp+0x40]
  41b050:	0f 8e 4a 09 00 00    	jle    41b9a0 <printf_core+0x1180>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b056:	41 8b 16             	mov    edx,DWORD PTR [r14]
  41b059:	41 8d ad 00 ff ff ff 	lea    ebp,[r13-0x100]
  41b060:	4d 89 d5             	mov    r13,r10
  41b063:	89 d0                	mov    eax,edx
  41b065:	83 e0 20             	and    eax,0x20
  41b068:	0f 84 62 06 00 00    	je     41b6d0 <printf_core+0xeb0>
	for (; l >= sizeof pad; l -= sizeof pad)
  41b06e:	4d 89 ea             	mov    r10,r13
  41b071:	81 fd ff 00 00 00    	cmp    ebp,0xff
  41b077:	0f 8e 45 07 00 00    	jle    41b7c2 <printf_core+0xfa2>
  41b07d:	8d 95 00 e9 ff ff    	lea    edx,[rbp-0x1700]
  41b083:	81 fa 00 e9 ff 7f    	cmp    edx,0x7fffe900
  41b089:	0f 86 76 f5 ff ff    	jbe    41a605 <printf_core.cold+0x1da>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b08f:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  41b091:	81 ed 00 01 00 00    	sub    ebp,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b097:	89 d0                	mov    eax,edx
	for (; l >= sizeof pad; l -= sizeof pad)
  41b099:	41 89 ed             	mov    r13d,ebp
  41b09c:	81 fd ff 00 00 00    	cmp    ebp,0xff
  41b0a2:	77 ed                	ja     41b091 <printf_core+0x871>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b0a4:	85 c0                	test   eax,eax
  41b0a6:	0f 84 89 08 00 00    	je     41b935 <printf_core+0x1115>
		pad(f, ' ', w, pl+p, fl^LEFT_ADJ);
  41b0ac:	41 81 f4 00 20 00 00 	xor    r12d,0x2000
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41b0b3:	41 81 e4 00 20 01 00 	and    r12d,0x12000
  41b0ba:	0f 85 1f f8 ff ff    	jne    41a8df <printf_core+0xbf>
  41b0c0:	80 7c 24 18 00       	cmp    BYTE PTR [rsp+0x18],0x0
  41b0c5:	0f 85 14 f8 ff ff    	jne    41a8df <printf_core+0xbf>
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41b0cb:	b8 00 01 00 00       	mov    eax,0x100
	l = w - l;
  41b0d0:	44 8b 24 24          	mov    r12d,DWORD PTR [rsp]
  41b0d4:	44 2b 64 24 38       	sub    r12d,DWORD PTR [rsp+0x38]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41b0d9:	4c 8d bc 24 b0 00 00 	lea    r15,[rsp+0xb0]
  41b0e0:	00 
  41b0e1:	41 39 c4             	cmp    r12d,eax
  41b0e4:	be 20 00 00 00       	mov    esi,0x20
  41b0e9:	4c 89 ff             	mov    rdi,r15
  41b0ec:	41 0f 4e c4          	cmovle eax,r12d
  41b0f0:	48 63 d0             	movsxd rdx,eax
  41b0f3:	e8 64 b7 ff ff       	call   41685c <memset>
	for (; l >= sizeof pad; l -= sizeof pad)
  41b0f8:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  41b0ff:	0f 8e 0d 09 00 00    	jle    41ba12 <printf_core+0x11f2>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b105:	41 8b 06             	mov    eax,DWORD PTR [r14]
  41b108:	41 8d ac 24 00 ff ff 	lea    ebp,[r12-0x100]
  41b10f:	ff 
  41b110:	83 e0 20             	and    eax,0x20
  41b113:	0f 84 e7 05 00 00    	je     41b700 <printf_core+0xee0>
	for (; l >= sizeof pad; l -= sizeof pad)
  41b119:	81 fd ff 00 00 00    	cmp    ebp,0xff
  41b11f:	0f 8e ba f7 ff ff    	jle    41a8df <printf_core+0xbf>
  41b125:	8d 95 00 e9 ff ff    	lea    edx,[rbp-0x1700]
  41b12b:	81 fa 00 e9 ff 7f    	cmp    edx,0x7fffe900
  41b131:	0f 86 38 f4 ff ff    	jbe    41a56f <printf_core.cold+0x144>
  41b137:	81 ed 00 01 00 00    	sub    ebp,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b13d:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  41b13f:	41 89 ec             	mov    r12d,ebp
  41b142:	81 fd ff 00 00 00    	cmp    ebp,0xff
  41b148:	77 ed                	ja     41b137 <printf_core+0x917>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b14a:	85 d2                	test   edx,edx
  41b14c:	0f 85 8d f7 ff ff    	jne    41a8df <printf_core+0xbf>
	out(f, pad, l);
  41b152:	49 63 f4             	movsxd rsi,r12d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b155:	4c 89 f2             	mov    rdx,r14
  41b158:	4c 89 ff             	mov    rdi,r15
  41b15b:	e8 c0 11 00 00       	call   41c320 <__fwritex>
  41b160:	e9 7a f7 ff ff       	jmp    41a8df <printf_core+0xbf>
			if (xp && p<0) goto overflow;
  41b165:	45 85 db             	test   r11d,r11d
  41b168:	79 0b                	jns    41b175 <printf_core+0x955>
  41b16a:	f6 44 24 18 01       	test   BYTE PTR [rsp+0x18],0x1
  41b16f:	0f 85 74 fa ff ff    	jne    41abe9 <printf_core+0x3c9>
			l = fmt_fp(f, arg.f, w, p, fl, t);
  41b175:	ff 74 24 78          	push   QWORD PTR [rsp+0x78]
  41b179:	41 89 d0             	mov    r8d,edx
  41b17c:	44 89 e1             	mov    ecx,r12d
  41b17f:	44 89 da             	mov    edx,r11d
  41b182:	ff 74 24 78          	push   QWORD PTR [rsp+0x78]
  41b186:	89 ee                	mov    esi,ebp
  41b188:	4c 89 f7             	mov    rdi,r14
  41b18b:	e8 90 ce ff ff       	call   418020 <fmt_fp>
  41b190:	89 44 24 10          	mov    DWORD PTR [rsp+0x10],eax
			if (l<0) goto overflow;
  41b194:	41 5f                	pop    r15
  41b196:	5a                   	pop    rdx
  41b197:	85 c0                	test   eax,eax
  41b199:	0f 89 36 f7 ff ff    	jns    41a8d5 <printf_core+0xb5>
  41b19f:	e9 45 fa ff ff       	jmp    41abe9 <printf_core+0x3c9>
  41b1a4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
			a = fmt_x(arg.i, z, t&32);
  41b1a8:	89 d6                	mov    esi,edx
  41b1aa:	83 e6 20             	and    esi,0x20
  41b1ad:	48 8b 44 24 70       	mov    rax,QWORD PTR [rsp+0x70]
	for (; x; x>>=4) *--s = xdigits[(x&15)]|lower;
  41b1b2:	48 85 c0             	test   rax,rax
  41b1b5:	0f 84 8c 08 00 00    	je     41ba47 <printf_core+0x1227>
  41b1bb:	4c 8d 84 24 ab 00 00 	lea    r8,[rsp+0xab]
  41b1c2:	00 
  41b1c3:	48 8d 3d 06 4b 00 00 	lea    rdi,[rip+0x4b06]        # 41fcd0 <xdigits>
  41b1ca:	4d 89 c2             	mov    r10,r8
  41b1cd:	0f 1f 00             	nop    DWORD PTR [rax]
  41b1d0:	48 89 c1             	mov    rcx,rax
  41b1d3:	49 83 ea 01          	sub    r10,0x1
  41b1d7:	83 e1 0f             	and    ecx,0xf
  41b1da:	44 0f b6 0c 0f       	movzx  r9d,BYTE PTR [rdi+rcx*1]
  41b1df:	41 09 f1             	or     r9d,esi
  41b1e2:	48 c1 e8 04          	shr    rax,0x4
  41b1e6:	45 88 0a             	mov    BYTE PTR [r10],r9b
  41b1e9:	75 e5                	jne    41b1d0 <printf_core+0x9b0>
			if (arg.i && (fl & ALT_FORM)) prefix+=(t>>4), pl=2;
  41b1eb:	41 f6 c4 08          	test   r12b,0x8
  41b1ef:	0f 85 b6 07 00 00    	jne    41b9ab <printf_core+0x118b>
		prefix = "-+   0X0x";
  41b1f5:	48 8d 05 c1 49 00 00 	lea    rax,[rip+0x49c1]        # 41fbbd <CSWTCH.187+0x7cd>
		pl = 0;
  41b1fc:	44 89 7c 24 40       	mov    DWORD PTR [rsp+0x40],r15d
		prefix = "-+   0X0x";
  41b201:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
			if (xp && p<0) goto overflow;
  41b206:	45 85 db             	test   r11d,r11d
  41b209:	79 0b                	jns    41b216 <printf_core+0x9f6>
  41b20b:	f6 44 24 18 01       	test   BYTE PTR [rsp+0x18],0x1
  41b210:	0f 85 d3 f9 ff ff    	jne    41abe9 <printf_core+0x3c9>
			if (xp) fl &= ~ZERO_PAD;
  41b216:	8b 4c 24 18          	mov    ecx,DWORD PTR [rsp+0x18]
  41b21a:	44 89 e0             	mov    eax,r12d
  41b21d:	25 ff ff fe ff       	and    eax,0xfffeffff
  41b222:	85 c9                	test   ecx,ecx
  41b224:	44 0f 45 e0          	cmovne r12d,eax
			if (!arg.i && !p) {
  41b228:	48 83 7c 24 70 00    	cmp    QWORD PTR [rsp+0x70],0x0
  41b22e:	0f 94 c0             	sete   al
  41b231:	45 85 db             	test   r11d,r11d
  41b234:	75 08                	jne    41b23e <printf_core+0xa1e>
  41b236:	84 c0                	test   al,al
  41b238:	0f 85 1a 07 00 00    	jne    41b958 <printf_core+0x1138>
			p = MAX(p, z-a + !arg.i);
  41b23e:	4c 89 c6             	mov    rsi,r8
  41b241:	0f b6 c0             	movzx  eax,al
  41b244:	49 63 d3             	movsxd rdx,r11d
  41b247:	4c 29 d6             	sub    rsi,r10
  41b24a:	48 01 f0             	add    rax,rsi
  41b24d:	48 89 74 24 30       	mov    QWORD PTR [rsp+0x30],rsi
  41b252:	48 39 d0             	cmp    rax,rdx
  41b255:	48 0f 4c c2          	cmovl  rax,rdx
		if (p > INT_MAX-pl) goto overflow;
  41b259:	ba ff ff ff 7f       	mov    edx,0x7fffffff
  41b25e:	2b 54 24 40          	sub    edx,DWORD PTR [rsp+0x40]
			p = MAX(p, z-a + !arg.i);
  41b262:	41 89 c3             	mov    r11d,eax
		if (p < z-a) p = z-a;
  41b265:	48 98                	cdqe   
  41b267:	48 39 c6             	cmp    rsi,rax
  41b26a:	0f 8f 98 fb ff ff    	jg     41ae08 <printf_core+0x5e8>
  41b270:	e9 98 fb ff ff       	jmp    41ae0d <printf_core+0x5ed>
			if (arg.i>INTMAX_MAX) {
  41b275:	48 8b 4c 24 70       	mov    rcx,QWORD PTR [rsp+0x70]
  41b27a:	48 85 c9             	test   rcx,rcx
  41b27d:	0f 88 6e 07 00 00    	js     41b9f1 <printf_core+0x11d1>
			pl=1;
  41b283:	be 01 00 00 00       	mov    esi,0x1
				prefix++;
  41b288:	48 8d 05 2f 49 00 00 	lea    rax,[rip+0x492f]        # 41fbbe <CSWTCH.187+0x7ce>
			pl=1;
  41b28f:	89 74 24 40          	mov    DWORD PTR [rsp+0x40],esi
				prefix++;
  41b293:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
			} else if (fl & MARK_POS) {
  41b298:	41 f7 c4 00 08 00 00 	test   r12d,0x800
  41b29f:	75 22                	jne    41b2c3 <printf_core+0xaa3>
			} else pl=0;
  41b2a1:	41 f6 c4 01          	test   r12b,0x1
  41b2a5:	44 89 f8             	mov    eax,r15d
  41b2a8:	48 8d 15 10 49 00 00 	lea    rdx,[rip+0x4910]        # 41fbbf <CSWTCH.187+0x7cf>
  41b2af:	0f 45 c6             	cmovne eax,esi
  41b2b2:	89 44 24 40          	mov    DWORD PTR [rsp+0x40],eax
  41b2b6:	48 8d 42 fe          	lea    rax,[rdx-0x2]
  41b2ba:	48 0f 45 c2          	cmovne rax,rdx
  41b2be:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  41b2c3:	48 85 c9             	test   rcx,rcx
  41b2c6:	0f 84 9c 07 00 00    	je     41ba68 <printf_core+0x1248>
		prefix = "-+   0X0x";
  41b2cc:	4c 8d 84 24 ab 00 00 	lea    r8,[rsp+0xab]
  41b2d3:	00 
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  41b2d4:	48 be cd cc cc cc cc 	movabs rsi,0xcccccccccccccccd
  41b2db:	cc cc cc 
		prefix = "-+   0X0x";
  41b2de:	4d 89 c2             	mov    r10,r8
  41b2e1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  41b2e8:	48 89 c8             	mov    rax,rcx
  41b2eb:	49 83 ea 01          	sub    r10,0x1
  41b2ef:	48 f7 e6             	mul    rsi
  41b2f2:	48 89 c8             	mov    rax,rcx
  41b2f5:	48 c1 ea 03          	shr    rdx,0x3
  41b2f9:	48 8d 3c 92          	lea    rdi,[rdx+rdx*4]
  41b2fd:	48 01 ff             	add    rdi,rdi
  41b300:	48 29 f8             	sub    rax,rdi
  41b303:	83 c0 30             	add    eax,0x30
  41b306:	41 88 02             	mov    BYTE PTR [r10],al
  41b309:	48 89 c8             	mov    rax,rcx
  41b30c:	48 89 d1             	mov    rcx,rdx
  41b30f:	48 83 f8 09          	cmp    rax,0x9
  41b313:	77 d3                	ja     41b2e8 <printf_core+0xac8>
  41b315:	e9 ec fe ff ff       	jmp    41b206 <printf_core+0x9e6>
			a = fmt_o(arg.i, z);
  41b31a:	48 8b 44 24 70       	mov    rax,QWORD PTR [rsp+0x70]
	for (; x; x>>=3) *--s = '0' + (x&7);
  41b31f:	4c 8d 84 24 ab 00 00 	lea    r8,[rsp+0xab]
  41b326:	00 
  41b327:	4d 89 c2             	mov    r10,r8
  41b32a:	48 85 c0             	test   rax,rax
  41b32d:	74 16                	je     41b345 <printf_core+0xb25>
  41b32f:	90                   	nop
  41b330:	89 c2                	mov    edx,eax
  41b332:	49 83 ea 01          	sub    r10,0x1
  41b336:	83 e2 07             	and    edx,0x7
  41b339:	83 c2 30             	add    edx,0x30
  41b33c:	48 c1 e8 03          	shr    rax,0x3
  41b340:	41 88 12             	mov    BYTE PTR [r10],dl
  41b343:	75 eb                	jne    41b330 <printf_core+0xb10>
		prefix = "-+   0X0x";
  41b345:	48 8d 05 71 48 00 00 	lea    rax,[rip+0x4871]        # 41fbbd <CSWTCH.187+0x7cd>
		pl = 0;
  41b34c:	44 89 7c 24 40       	mov    DWORD PTR [rsp+0x40],r15d
		prefix = "-+   0X0x";
  41b351:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
			if ((fl&ALT_FORM) && p<z-a+1) p=z-a+1;
  41b356:	41 f6 c4 08          	test   r12b,0x8
  41b35a:	0f 84 a6 fe ff ff    	je     41b206 <printf_core+0x9e6>
  41b360:	4c 89 c6             	mov    rsi,r8
  41b363:	49 63 cb             	movsxd rcx,r11d
  41b366:	44 89 d8             	mov    eax,r11d
  41b369:	4c 29 d6             	sub    rsi,r10
  41b36c:	8d 56 01             	lea    edx,[rsi+0x1]
  41b36f:	48 39 ce             	cmp    rsi,rcx
  41b372:	0f 4d c2             	cmovge eax,edx
  41b375:	41 89 c3             	mov    r11d,eax
  41b378:	e9 89 fe ff ff       	jmp    41b206 <printf_core+0x9e6>
			p = MAX(p, 2*sizeof(void*));
  41b37d:	b8 10 00 00 00       	mov    eax,0x10
			fl |= ALT_FORM;
  41b382:	be 20 00 00 00       	mov    esi,0x20
			t = 'x';
  41b387:	ba 78 00 00 00       	mov    edx,0x78
			p = MAX(p, 2*sizeof(void*));
  41b38c:	41 39 c3             	cmp    r11d,eax
  41b38f:	44 0f 42 d8          	cmovb  r11d,eax
			fl |= ALT_FORM;
  41b393:	41 83 cc 08          	or     r12d,0x8
  41b397:	e9 11 fe ff ff       	jmp    41b1ad <printf_core+0x98d>
			a = arg.p ? arg.p : "(null)";
  41b39c:	4c 8b 54 24 70       	mov    r10,QWORD PTR [rsp+0x70]
  41b3a1:	48 8d 05 1f 48 00 00 	lea    rax,[rip+0x481f]        # 41fbc7 <CSWTCH.187+0x7d7>
  41b3a8:	4d 85 d2             	test   r10,r10
  41b3ab:	4c 0f 44 d0          	cmove  r10,rax
			z = a + strnlen(a, p<0 ? INT_MAX : p);
  41b3af:	45 85 db             	test   r11d,r11d
  41b3b2:	0f 88 b9 05 00 00    	js     41b971 <printf_core+0x1151>
  41b3b8:	4c 89 d7             	mov    rdi,r10
  41b3bb:	49 63 f3             	movsxd rsi,r11d
  41b3be:	4c 89 14 24          	mov    QWORD PTR [rsp],r10
  41b3c2:	e8 79 bf ff ff       	call   417340 <strnlen>
  41b3c7:	4c 8b 14 24          	mov    r10,QWORD PTR [rsp]
  41b3cb:	49 8d 14 02          	lea    rdx,[r10+rax*1]
		if (p < z-a) p = z-a;
  41b3cf:	4c 29 d2             	sub    rdx,r10
			p = z-a;
  41b3d2:	41 89 c3             	mov    r11d,eax
			fl &= ~ZERO_PAD;
  41b3d5:	41 81 e4 ff ff fe ff 	and    r12d,0xfffeffff
		if (p < z-a) p = z-a;
  41b3dc:	48 89 54 24 30       	mov    QWORD PTR [rsp+0x30],rdx
			break;
  41b3e1:	e9 02 fa ff ff       	jmp    41ade8 <printf_core+0x5c8>
			ws = arg.p;
  41b3e6:	48 8b 44 24 70       	mov    rax,QWORD PTR [rsp+0x70]
  41b3eb:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
			for (i=l=0; i<p && *ws && (l=wctomb(mb, *ws++))>=0 && l<=p-i; i+=l);
  41b3f0:	49 63 c3             	movsxd rax,r11d
  41b3f3:	48 89 c7             	mov    rdi,rax
  41b3f6:	48 85 c0             	test   rax,rax
  41b3f9:	0f 84 67 07 00 00    	je     41bb66 <printf_core+0x1346>
  41b3ff:	4c 8b 7c 24 30       	mov    r15,QWORD PTR [rsp+0x30]
  41b404:	4c 89 f6             	mov    rsi,r14
  41b407:	31 c9                	xor    ecx,ecx
  41b409:	48 8d 44 24 64       	lea    rax,[rsp+0x64]
  41b40e:	44 89 2c 24          	mov    DWORD PTR [rsp],r13d
  41b412:	41 89 ee             	mov    r14d,ebp
  41b415:	49 89 fd             	mov    r13,rdi
  41b418:	48 89 5c 24 18       	mov    QWORD PTR [rsp+0x18],rbx
  41b41d:	4c 89 fd             	mov    rbp,r15
  41b420:	48 89 c3             	mov    rbx,rax
  41b423:	49 89 f7             	mov    r15,rsi
  41b426:	44 89 64 24 38       	mov    DWORD PTR [rsp+0x38],r12d
  41b42b:	49 89 cc             	mov    r12,rcx
  41b42e:	eb 29                	jmp    41b459 <printf_core+0xc39>
  41b430:	48 89 df             	mov    rdi,rbx
  41b433:	48 83 c5 04          	add    rbp,0x4
  41b437:	e8 c4 0c 00 00       	call   41c100 <wctomb>
  41b43c:	85 c0                	test   eax,eax
  41b43e:	0f 88 8a 05 00 00    	js     41b9ce <printf_core+0x11ae>
  41b444:	4c 89 ee             	mov    rsi,r13
  41b447:	48 98                	cdqe   
  41b449:	4c 29 e6             	sub    rsi,r12
  41b44c:	48 39 f0             	cmp    rax,rsi
  41b44f:	77 0f                	ja     41b460 <printf_core+0xc40>
  41b451:	49 01 c4             	add    r12,rax
  41b454:	4d 39 ec             	cmp    r12,r13
  41b457:	73 07                	jae    41b460 <printf_core+0xc40>
  41b459:	8b 75 00             	mov    esi,DWORD PTR [rbp+0x0]
  41b45c:	85 f6                	test   esi,esi
  41b45e:	75 d0                	jne    41b430 <printf_core+0xc10>
  41b460:	4c 89 e1             	mov    rcx,r12
  41b463:	44 89 f5             	mov    ebp,r14d
  41b466:	44 8b 2c 24          	mov    r13d,DWORD PTR [rsp]
  41b46a:	48 8b 5c 24 18       	mov    rbx,QWORD PTR [rsp+0x18]
  41b46f:	44 8b 64 24 38       	mov    r12d,DWORD PTR [rsp+0x38]
  41b474:	4d 89 fe             	mov    r14,r15
			if (i > INT_MAX) goto overflow;
  41b477:	48 81 f9 ff ff ff 7f 	cmp    rcx,0x7fffffff
  41b47e:	0f 87 65 f7 ff ff    	ja     41abe9 <printf_core+0x3c9>
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41b484:	39 cd                	cmp    ebp,ecx
			p = i;
  41b486:	89 0c 24             	mov    DWORD PTR [rsp],ecx
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41b489:	0f 9e 44 24 18       	setle  BYTE PTR [rsp+0x18]
  41b48e:	0f b6 44 24 18       	movzx  eax,BYTE PTR [rsp+0x18]
  41b493:	41 f7 c4 00 20 01 00 	test   r12d,0x12000
  41b49a:	0f 85 a5 00 00 00    	jne    41b545 <printf_core+0xd25>
  41b4a0:	84 c0                	test   al,al
  41b4a2:	0f 85 9d 00 00 00    	jne    41b545 <printf_core+0xd25>
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41b4a8:	b8 00 01 00 00       	mov    eax,0x100
	l = w - l;
  41b4ad:	41 89 e8             	mov    r8d,ebp
  41b4b0:	44 2b 04 24          	sub    r8d,DWORD PTR [rsp]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41b4b4:	be 20 00 00 00       	mov    esi,0x20
  41b4b9:	41 39 c0             	cmp    r8d,eax
  41b4bc:	4c 8d bc 24 b0 00 00 	lea    r15,[rsp+0xb0]
  41b4c3:	00 
  41b4c4:	48 89 4c 24 38       	mov    QWORD PTR [rsp+0x38],rcx
  41b4c9:	41 0f 4e c0          	cmovle eax,r8d
  41b4cd:	4c 89 ff             	mov    rdi,r15
  41b4d0:	44 89 44 24 18       	mov    DWORD PTR [rsp+0x18],r8d
  41b4d5:	48 63 d0             	movsxd rdx,eax
  41b4d8:	e8 7f b3 ff ff       	call   41685c <memset>
	for (; l >= sizeof pad; l -= sizeof pad)
  41b4dd:	44 8b 44 24 18       	mov    r8d,DWORD PTR [rsp+0x18]
  41b4e2:	48 8b 4c 24 38       	mov    rcx,QWORD PTR [rsp+0x38]
  41b4e7:	41 81 f8 ff 00 00 00 	cmp    r8d,0xff
  41b4ee:	0f 8e 5c 06 00 00    	jle    41bb50 <printf_core+0x1330>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b4f4:	41 8b 06             	mov    eax,DWORD PTR [r14]
  41b4f7:	45 8d 98 00 ff ff ff 	lea    r11d,[r8-0x100]
  41b4fe:	83 e0 20             	and    eax,0x20
  41b501:	0f 84 11 03 00 00    	je     41b818 <printf_core+0xff8>
	for (; l >= sizeof pad; l -= sizeof pad)
  41b507:	41 81 fb ff 00 00 00 	cmp    r11d,0xff
  41b50e:	7e 30                	jle    41b540 <printf_core+0xd20>
  41b510:	41 8d 93 00 e9 ff ff 	lea    edx,[r11-0x1700]
  41b517:	81 fa 00 e9 ff 7f    	cmp    edx,0x7fffe900
  41b51d:	0f 86 a7 ef ff ff    	jbe    41a4ca <printf_core.cold+0x9f>
  41b523:	41 81 eb 00 01 00 00 	sub    r11d,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b52a:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  41b52c:	45 89 d8             	mov    r8d,r11d
  41b52f:	41 81 fb ff 00 00 00 	cmp    r11d,0xff
  41b536:	77 eb                	ja     41b523 <printf_core+0xd03>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b538:	85 d2                	test   edx,edx
  41b53a:	0f 84 ea 04 00 00    	je     41ba2a <printf_core+0x120a>
  41b540:	c6 44 24 18 00       	mov    BYTE PTR [rsp+0x18],0x0
			for (i=0; i<0U+p && *ws && i+(l=wctomb(mb, *ws++))<=p; i+=l)
  41b545:	45 31 ff             	xor    r15d,r15d
  41b548:	48 8d 44 24 64       	lea    rax,[rsp+0x64]
  41b54d:	48 85 c9             	test   rcx,rcx
  41b550:	0f 84 18 03 00 00    	je     41b86e <printf_core+0x104e>
  41b556:	44 89 6c 24 38       	mov    DWORD PTR [rsp+0x38],r13d
  41b55b:	49 89 cd             	mov    r13,rcx
  41b55e:	48 89 5c 24 40       	mov    QWORD PTR [rsp+0x40],rbx
  41b563:	48 8b 5c 24 30       	mov    rbx,QWORD PTR [rsp+0x30]
  41b568:	89 6c 24 30          	mov    DWORD PTR [rsp+0x30],ebp
  41b56c:	4c 89 fd             	mov    rbp,r15
  41b56f:	49 89 c7             	mov    r15,rax
  41b572:	eb 0d                	jmp    41b581 <printf_core+0xd61>
  41b574:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  41b578:	4c 39 ed             	cmp    rbp,r13
  41b57b:	0f 83 df 02 00 00    	jae    41b860 <printf_core+0x1040>
  41b581:	8b 33                	mov    esi,DWORD PTR [rbx]
  41b583:	85 f6                	test   esi,esi
  41b585:	0f 84 d5 02 00 00    	je     41b860 <printf_core+0x1040>
  41b58b:	4c 89 ff             	mov    rdi,r15
  41b58e:	48 83 c3 04          	add    rbx,0x4
  41b592:	e8 69 0b 00 00       	call   41c100 <wctomb>
  41b597:	48 63 f0             	movsxd rsi,eax
  41b59a:	48 01 f5             	add    rbp,rsi
  41b59d:	4c 39 ed             	cmp    rbp,r13
  41b5a0:	0f 87 ba 02 00 00    	ja     41b860 <printf_core+0x1040>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b5a6:	41 f6 06 20          	test   BYTE PTR [r14],0x20
  41b5aa:	75 cc                	jne    41b578 <printf_core+0xd58>
  41b5ac:	4c 89 f2             	mov    rdx,r14
  41b5af:	4c 89 ff             	mov    rdi,r15
  41b5b2:	e8 69 0d 00 00       	call   41c320 <__fwritex>
  41b5b7:	eb bf                	jmp    41b578 <printf_core+0xd58>
  41b5b9:	44 89 1c 24          	mov    DWORD PTR [rsp],r11d
			if (1) a = strerror(errno); else
  41b5bd:	e8 7e c2 ff ff       	call   417840 <__errno_location>
  41b5c2:	8b 38                	mov    edi,DWORD PTR [rax]
  41b5c4:	e8 27 09 00 00       	call   41bef0 <strerror>
  41b5c9:	44 8b 1c 24          	mov    r11d,DWORD PTR [rsp]
  41b5cd:	49 89 c2             	mov    r10,rax
  41b5d0:	e9 da fd ff ff       	jmp    41b3af <printf_core+0xb8f>
			switch(ps) {
  41b5d5:	41 83 f9 07          	cmp    r9d,0x7
  41b5d9:	0f 87 f6 f2 ff ff    	ja     41a8d5 <printf_core+0xb5>
  41b5df:	48 8d 15 ca 46 00 00 	lea    rdx,[rip+0x46ca]        # 41fcb0 <CSWTCH.187+0x8c0>
  41b5e6:	4a 63 04 82          	movsxd rax,DWORD PTR [rdx+r8*4]
  41b5ea:	48 01 d0             	add    rax,rdx
  41b5ed:	3e ff e0             	notrack jmp rax
			case JPRE: *(uintmax_t *)arg.p = cnt; break;
  41b5f0:	48 63 44 24 08       	movsxd rax,DWORD PTR [rsp+0x8]
  41b5f5:	48 8b 54 24 70       	mov    rdx,QWORD PTR [rsp+0x70]
  41b5fa:	48 89 02             	mov    QWORD PTR [rdx],rax
  41b5fd:	e9 dd f2 ff ff       	jmp    41a8df <printf_core+0xbf>
			wc[0] = arg.i;
  41b602:	48 8b 44 24 70       	mov    rax,QWORD PTR [rsp+0x70]
			wc[1] = 0;
  41b607:	c7 44 24 6c 00 00 00 	mov    DWORD PTR [rsp+0x6c],0x0
  41b60e:	00 
			for (i=l=0; i<p && *ws && (l=wctomb(mb, *ws++))>=0 && l<=p-i; i+=l);
  41b60f:	48 c7 c7 ff ff ff ff 	mov    rdi,0xffffffffffffffff
			wc[0] = arg.i;
  41b616:	89 44 24 68          	mov    DWORD PTR [rsp+0x68],eax
			arg.p = wc;
  41b61a:	48 8d 44 24 68       	lea    rax,[rsp+0x68]
  41b61f:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
			ws = arg.p;
  41b624:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  41b629:	e9 d1 fd ff ff       	jmp    41b3ff <printf_core+0xbdf>
			*(a=z-(p=1))=arg.i;
  41b62e:	48 8b 4c 24 70       	mov    rcx,QWORD PTR [rsp+0x70]
		prefix = "-+   0X0x";
  41b633:	48 8d 05 83 45 00 00 	lea    rax,[rip+0x4583]        # 41fbbd <CSWTCH.187+0x7cd>
		pl = 0;
  41b63a:	44 89 7c 24 40       	mov    DWORD PTR [rsp+0x40],r15d
			fl &= ~ZERO_PAD;
  41b63f:	41 81 e4 ff ff fe ff 	and    r12d,0xfffeffff
			break;
  41b646:	c7 44 24 38 01 00 00 	mov    DWORD PTR [rsp+0x38],0x1
  41b64d:	00 
			*(a=z-(p=1))=arg.i;
  41b64e:	4c 8d 94 24 aa 00 00 	lea    r10,[rsp+0xaa]
  41b655:	00 
  41b656:	88 8c 24 aa 00 00 00 	mov    BYTE PTR [rsp+0xaa],cl
			break;
  41b65d:	48 c7 44 24 30 01 00 	mov    QWORD PTR [rsp+0x30],0x1
  41b664:	00 00 
		prefix = "-+   0X0x";
  41b666:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
			*(a=z-(p=1))=arg.i;
  41b66b:	c7 04 24 01 00 00 00 	mov    DWORD PTR [rsp],0x1
		if (p < z-a) p = z-a;
  41b672:	44 8b 1c 24          	mov    r11d,DWORD PTR [rsp]
  41b676:	e9 a6 f7 ff ff       	jmp    41ae21 <printf_core+0x601>
		switch(t) {
  41b67b:	48 8d 05 3b 45 00 00 	lea    rax,[rip+0x453b]        # 41fbbd <CSWTCH.187+0x7cd>
  41b682:	44 89 7c 24 40       	mov    DWORD PTR [rsp+0x40],r15d
  41b687:	48 8b 4c 24 70       	mov    rcx,QWORD PTR [rsp+0x70]
  41b68c:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
  41b691:	e9 2d fc ff ff       	jmp    41b2c3 <printf_core+0xaa3>
			case HPRE: *(unsigned short *)arg.p = cnt; break;
  41b696:	48 8b 44 24 70       	mov    rax,QWORD PTR [rsp+0x70]
  41b69b:	0f b7 7c 24 08       	movzx  edi,WORD PTR [rsp+0x8]
  41b6a0:	66 89 38             	mov    WORD PTR [rax],di
  41b6a3:	e9 37 f2 ff ff       	jmp    41a8df <printf_core+0xbf>
			case HHPRE: *(unsigned char *)arg.p = cnt; break;
  41b6a8:	48 8b 44 24 70       	mov    rax,QWORD PTR [rsp+0x70]
  41b6ad:	0f b6 74 24 08       	movzx  esi,BYTE PTR [rsp+0x8]
  41b6b2:	40 88 30             	mov    BYTE PTR [rax],sil
  41b6b5:	e9 25 f2 ff ff       	jmp    41a8df <printf_core+0xbf>
			case BARE: *(int *)arg.p = cnt; break;
  41b6ba:	48 8b 44 24 70       	mov    rax,QWORD PTR [rsp+0x70]
  41b6bf:	8b 7c 24 08          	mov    edi,DWORD PTR [rsp+0x8]
  41b6c3:	89 38                	mov    DWORD PTR [rax],edi
  41b6c5:	e9 15 f2 ff ff       	jmp    41a8df <printf_core+0xbf>
  41b6ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b6d0:	4c 89 f2             	mov    rdx,r14
  41b6d3:	be 00 01 00 00       	mov    esi,0x100
  41b6d8:	4c 89 ff             	mov    rdi,r15
  41b6db:	e8 40 0c 00 00       	call   41c320 <__fwritex>
  41b6e0:	41 8b 16             	mov    edx,DWORD PTR [r14]
  41b6e3:	89 d0                	mov    eax,edx
  41b6e5:	83 e0 20             	and    eax,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41b6e8:	81 fd ff 00 00 00    	cmp    ebp,0xff
  41b6ee:	0f 8e bd 00 00 00    	jle    41b7b1 <printf_core+0xf91>
  41b6f4:	81 ed 00 01 00 00    	sub    ebp,0x100
  41b6fa:	e9 64 f9 ff ff       	jmp    41b063 <printf_core+0x843>
  41b6ff:	90                   	nop
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b700:	4c 89 f2             	mov    rdx,r14
  41b703:	be 00 01 00 00       	mov    esi,0x100
  41b708:	4c 89 ff             	mov    rdi,r15
	for (; l >= sizeof pad; l -= sizeof pad)
  41b70b:	41 89 ec             	mov    r12d,ebp
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b70e:	e8 0d 0c 00 00       	call   41c320 <__fwritex>
  41b713:	41 8b 06             	mov    eax,DWORD PTR [r14]
  41b716:	89 c2                	mov    edx,eax
  41b718:	83 e2 20             	and    edx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41b71b:	81 fd ff 00 00 00    	cmp    ebp,0xff
  41b721:	0f 8e 23 fa ff ff    	jle    41b14a <printf_core+0x92a>
  41b727:	81 ed 00 01 00 00    	sub    ebp,0x100
  41b72d:	e9 de f9 ff ff       	jmp    41b110 <printf_core+0x8f0>
  41b732:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b738:	4c 89 f2             	mov    rdx,r14
  41b73b:	be 00 01 00 00       	mov    esi,0x100
  41b740:	4c 89 ff             	mov    rdi,r15
  41b743:	4c 89 54 24 40       	mov    QWORD PTR [rsp+0x40],r10
  41b748:	e8 d3 0b 00 00       	call   41c320 <__fwritex>
  41b74d:	41 8b 16             	mov    edx,DWORD PTR [r14]
	for (; l >= sizeof pad; l -= sizeof pad)
  41b750:	4c 8b 54 24 40       	mov    r10,QWORD PTR [rsp+0x40]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b755:	89 d0                	mov    eax,edx
  41b757:	83 e0 20             	and    eax,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41b75a:	81 fd ff 00 00 00    	cmp    ebp,0xff
  41b760:	0f 8e 33 04 00 00    	jle    41bb99 <printf_core+0x1379>
  41b766:	81 ed 00 01 00 00    	sub    ebp,0x100
  41b76c:	e9 33 f8 ff ff       	jmp    41afa4 <printf_core+0x784>
  41b771:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b778:	4c 89 f2             	mov    rdx,r14
  41b77b:	be 00 01 00 00       	mov    esi,0x100
  41b780:	4c 89 ff             	mov    rdi,r15
  41b783:	4c 89 54 24 48       	mov    QWORD PTR [rsp+0x48],r10
  41b788:	e8 93 0b 00 00       	call   41c320 <__fwritex>
  41b78d:	41 8b 16             	mov    edx,DWORD PTR [r14]
	for (; l >= sizeof pad; l -= sizeof pad)
  41b790:	4c 8b 54 24 48       	mov    r10,QWORD PTR [rsp+0x48]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b795:	89 d0                	mov    eax,edx
  41b797:	83 e0 20             	and    eax,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41b79a:	81 fd ff 00 00 00    	cmp    ebp,0xff
  41b7a0:	0f 8e e5 03 00 00    	jle    41bb8b <printf_core+0x136b>
  41b7a6:	81 ed 00 01 00 00    	sub    ebp,0x100
  41b7ac:	e9 03 f7 ff ff       	jmp    41aeb4 <printf_core+0x694>
  41b7b1:	4d 89 ea             	mov    r10,r13
  41b7b4:	41 89 ed             	mov    r13d,ebp
  41b7b7:	e9 e8 f8 ff ff       	jmp    41b0a4 <printf_core+0x884>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b7bc:	41 8b 06             	mov    eax,DWORD PTR [r14]
  41b7bf:	83 e0 20             	and    eax,0x20
  41b7c2:	85 c0                	test   eax,eax
  41b7c4:	0f 85 e2 f8 ff ff    	jne    41b0ac <printf_core+0x88c>
  41b7ca:	48 8b 74 24 30       	mov    rsi,QWORD PTR [rsp+0x30]
  41b7cf:	4c 89 f2             	mov    rdx,r14
  41b7d2:	4c 89 d7             	mov    rdi,r10
  41b7d5:	e8 46 0b 00 00       	call   41c320 <__fwritex>
  41b7da:	e9 cd f8 ff ff       	jmp    41b0ac <printf_core+0x88c>
  41b7df:	41 8b 06             	mov    eax,DWORD PTR [r14]
  41b7e2:	83 e0 20             	and    eax,0x20
  41b7e5:	85 c0                	test   eax,eax
  41b7e7:	0f 85 3b f7 ff ff    	jne    41af28 <printf_core+0x708>
		out(f, prefix, pl);
  41b7ed:	48 63 74 24 40       	movsxd rsi,DWORD PTR [rsp+0x40]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b7f2:	48 8b 7c 24 50       	mov    rdi,QWORD PTR [rsp+0x50]
  41b7f7:	4c 89 f2             	mov    rdx,r14
  41b7fa:	4c 89 54 24 58       	mov    QWORD PTR [rsp+0x58],r10
  41b7ff:	44 89 5c 24 48       	mov    DWORD PTR [rsp+0x48],r11d
  41b804:	e8 17 0b 00 00       	call   41c320 <__fwritex>
  41b809:	4c 8b 54 24 58       	mov    r10,QWORD PTR [rsp+0x58]
  41b80e:	44 8b 5c 24 48       	mov    r11d,DWORD PTR [rsp+0x48]
  41b813:	e9 10 f7 ff ff       	jmp    41af28 <printf_core+0x708>
  41b818:	4c 89 f2             	mov    rdx,r14
  41b81b:	be 00 01 00 00       	mov    esi,0x100
  41b820:	4c 89 ff             	mov    rdi,r15
  41b823:	44 89 5c 24 38       	mov    DWORD PTR [rsp+0x38],r11d
  41b828:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
  41b82d:	e8 ee 0a 00 00       	call   41c320 <__fwritex>
  41b832:	41 8b 06             	mov    eax,DWORD PTR [r14]
	for (; l >= sizeof pad; l -= sizeof pad)
  41b835:	44 8b 5c 24 38       	mov    r11d,DWORD PTR [rsp+0x38]
  41b83a:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b83f:	89 c2                	mov    edx,eax
	for (; l >= sizeof pad; l -= sizeof pad)
  41b841:	45 89 d8             	mov    r8d,r11d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b844:	83 e2 20             	and    edx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41b847:	41 81 fb ff 00 00 00 	cmp    r11d,0xff
  41b84e:	0f 8e e4 fc ff ff    	jle    41b538 <printf_core+0xd18>
  41b854:	41 81 eb 00 01 00 00 	sub    r11d,0x100
  41b85b:	e9 9e fc ff ff       	jmp    41b4fe <printf_core+0xcde>
  41b860:	44 8b 6c 24 38       	mov    r13d,DWORD PTR [rsp+0x38]
  41b865:	48 8b 5c 24 40       	mov    rbx,QWORD PTR [rsp+0x40]
  41b86a:	8b 6c 24 30          	mov    ebp,DWORD PTR [rsp+0x30]
			pad(f, ' ', w, p, fl^LEFT_ADJ);
  41b86e:	41 81 f4 00 20 00 00 	xor    r12d,0x2000
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41b875:	41 81 e4 00 20 01 00 	and    r12d,0x12000
  41b87c:	75 68                	jne    41b8e6 <printf_core+0x10c6>
  41b87e:	80 7c 24 18 00       	cmp    BYTE PTR [rsp+0x18],0x0
  41b883:	75 61                	jne    41b8e6 <printf_core+0x10c6>
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41b885:	b8 00 01 00 00       	mov    eax,0x100
	l = w - l;
  41b88a:	41 89 e9             	mov    r9d,ebp
  41b88d:	44 2b 0c 24          	sub    r9d,DWORD PTR [rsp]
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  41b891:	be 20 00 00 00       	mov    esi,0x20
  41b896:	41 39 c1             	cmp    r9d,eax
  41b899:	4c 8d bc 24 b0 00 00 	lea    r15,[rsp+0xb0]
  41b8a0:	00 
  41b8a1:	44 89 4c 24 18       	mov    DWORD PTR [rsp+0x18],r9d
  41b8a6:	41 0f 4e c1          	cmovle eax,r9d
  41b8aa:	4c 89 ff             	mov    rdi,r15
  41b8ad:	48 63 d0             	movsxd rdx,eax
  41b8b0:	e8 a7 af ff ff       	call   41685c <memset>
	for (; l >= sizeof pad; l -= sizeof pad)
  41b8b5:	44 8b 4c 24 18       	mov    r9d,DWORD PTR [rsp+0x18]
  41b8ba:	45 89 cc             	mov    r12d,r9d
  41b8bd:	41 81 f9 ff 00 00 00 	cmp    r9d,0xff
  41b8c4:	0f 8e 91 02 00 00    	jle    41bb5b <printf_core+0x133b>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b8ca:	41 8b 06             	mov    eax,DWORD PTR [r14]
  41b8cd:	83 e0 20             	and    eax,0x20
  41b8d0:	74 24                	je     41b8f6 <printf_core+0x10d6>
	for (; l >= sizeof pad; l -= sizeof pad)
  41b8d2:	41 8d 94 24 00 ff ff 	lea    edx,[r12-0x100]
  41b8d9:	ff 
  41b8da:	81 fa ff 00 00 00    	cmp    edx,0xff
  41b8e0:	0f 87 c0 ed ff ff    	ja     41a6a6 <printf_core.cold+0x27b>
			l = w>p ? w : p;
  41b8e6:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  41b8e9:	39 e8                	cmp    eax,ebp
  41b8eb:	0f 4d e8             	cmovge ebp,eax
  41b8ee:	89 2c 24             	mov    DWORD PTR [rsp],ebp
			continue;
  41b8f1:	e9 df ef ff ff       	jmp    41a8d5 <printf_core+0xb5>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b8f6:	4c 89 f2             	mov    rdx,r14
  41b8f9:	be 00 01 00 00       	mov    esi,0x100
  41b8fe:	4c 89 ff             	mov    rdi,r15
	for (; l >= sizeof pad; l -= sizeof pad)
  41b901:	41 81 ec 00 01 00 00 	sub    r12d,0x100
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b908:	e8 13 0a 00 00       	call   41c320 <__fwritex>
  41b90d:	41 8b 06             	mov    eax,DWORD PTR [r14]
	for (; l >= sizeof pad; l -= sizeof pad)
  41b910:	45 89 e1             	mov    r9d,r12d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b913:	89 c1                	mov    ecx,eax
  41b915:	83 e1 20             	and    ecx,0x20
	for (; l >= sizeof pad; l -= sizeof pad)
  41b918:	41 81 fc ff 00 00 00 	cmp    r12d,0xff
  41b91f:	77 ac                	ja     41b8cd <printf_core+0x10ad>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b921:	85 c9                	test   ecx,ecx
  41b923:	75 c1                	jne    41b8e6 <printf_core+0x10c6>
	out(f, pad, l);
  41b925:	49 63 f1             	movsxd rsi,r9d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b928:	4c 89 f2             	mov    rdx,r14
  41b92b:	4c 89 ff             	mov    rdi,r15
  41b92e:	e8 ed 09 00 00       	call   41c320 <__fwritex>
  41b933:	eb b1                	jmp    41b8e6 <printf_core+0x10c6>
	out(f, pad, l);
  41b935:	49 63 f5             	movsxd rsi,r13d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b938:	4c 89 f2             	mov    rdx,r14
  41b93b:	4c 89 ff             	mov    rdi,r15
  41b93e:	4c 89 54 24 40       	mov    QWORD PTR [rsp+0x40],r10
  41b943:	e8 d8 09 00 00       	call   41c320 <__fwritex>
  41b948:	41 8b 06             	mov    eax,DWORD PTR [r14]
  41b94b:	4c 8b 54 24 40       	mov    r10,QWORD PTR [rsp+0x40]
  41b950:	83 e0 20             	and    eax,0x20
  41b953:	e9 6a fe ff ff       	jmp    41b7c2 <printf_core+0xfa2>
  41b958:	48 c7 44 24 30 00 00 	mov    QWORD PTR [rsp+0x30],0x0
  41b95f:	00 00 
  41b961:	8b 44 24 40          	mov    eax,DWORD PTR [rsp+0x40]
				a=z;
  41b965:	4d 89 c2             	mov    r10,r8
  41b968:	89 44 24 38          	mov    DWORD PTR [rsp+0x38],eax
  41b96c:	e9 01 fd ff ff       	jmp    41b672 <printf_core+0xe52>
			z = a + strnlen(a, p<0 ? INT_MAX : p);
  41b971:	4c 89 d7             	mov    rdi,r10
  41b974:	be ff ff ff 7f       	mov    esi,0x7fffffff
  41b979:	4c 89 14 24          	mov    QWORD PTR [rsp],r10
  41b97d:	e8 be b9 ff ff       	call   417340 <strnlen>
  41b982:	4c 8b 14 24          	mov    r10,QWORD PTR [rsp]
  41b986:	49 8d 14 02          	lea    rdx,[r10+rax*1]
			if (p<0 && *z) goto overflow;
  41b98a:	80 3a 00             	cmp    BYTE PTR [rdx],0x0
  41b98d:	0f 84 3c fa ff ff    	je     41b3cf <printf_core+0xbaf>
  41b993:	e9 51 f2 ff ff       	jmp    41abe9 <printf_core+0x3c9>
  41b998:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41b99f:	00 
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b9a0:	41 8b 06             	mov    eax,DWORD PTR [r14]
  41b9a3:	83 e0 20             	and    eax,0x20
  41b9a6:	e9 f9 f6 ff ff       	jmp    41b0a4 <printf_core+0x884>
			if (arg.i && (fl & ALT_FORM)) prefix+=(t>>4), pl=2;
  41b9ab:	89 d0                	mov    eax,edx
  41b9ad:	48 8d 15 09 42 00 00 	lea    rdx,[rip+0x4209]        # 41fbbd <CSWTCH.187+0x7cd>
  41b9b4:	c7 44 24 40 02 00 00 	mov    DWORD PTR [rsp+0x40],0x2
  41b9bb:	00 
  41b9bc:	c1 f8 04             	sar    eax,0x4
  41b9bf:	48 98                	cdqe   
  41b9c1:	48 01 d0             	add    rax,rdx
  41b9c4:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
  41b9c9:	e9 38 f8 ff ff       	jmp    41b206 <printf_core+0x9e6>
			if (l<0) return -1;
  41b9ce:	c7 44 24 08 ff ff ff 	mov    DWORD PTR [rsp+0x8],0xffffffff
  41b9d5:	ff 
  41b9d6:	e9 e6 f0 ff ff       	jmp    41aac1 <printf_core+0x2a1>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41b9db:	41 8b 06             	mov    eax,DWORD PTR [r14]
  41b9de:	83 e0 20             	and    eax,0x20
  41b9e1:	e9 0e f5 ff ff       	jmp    41aef4 <printf_core+0x6d4>
  41b9e6:	41 8b 06             	mov    eax,DWORD PTR [r14]
  41b9e9:	83 e0 20             	and    eax,0x20
  41b9ec:	e9 ee f5 ff ff       	jmp    41afdf <printf_core+0x7bf>
				arg.i=-arg.i;
  41b9f1:	48 f7 d9             	neg    rcx
		prefix = "-+   0X0x";
  41b9f4:	48 8d 05 c2 41 00 00 	lea    rax,[rip+0x41c2]        # 41fbbd <CSWTCH.187+0x7cd>
			pl=1;
  41b9fb:	c7 44 24 40 01 00 00 	mov    DWORD PTR [rsp+0x40],0x1
  41ba02:	00 
				arg.i=-arg.i;
  41ba03:	48 89 4c 24 70       	mov    QWORD PTR [rsp+0x70],rcx
		prefix = "-+   0X0x";
  41ba08:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
  41ba0d:	e9 ba f8 ff ff       	jmp    41b2cc <printf_core+0xaac>
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41ba12:	41 8b 16             	mov    edx,DWORD PTR [r14]
  41ba15:	83 e2 20             	and    edx,0x20
  41ba18:	e9 2d f7 ff ff       	jmp    41b14a <printf_core+0x92a>
			else return 0;
  41ba1d:	c7 44 24 08 00 00 00 	mov    DWORD PTR [rsp+0x8],0x0
  41ba24:	00 
  41ba25:	e9 97 f0 ff ff       	jmp    41aac1 <printf_core+0x2a1>
	out(f, pad, l);
  41ba2a:	49 63 f0             	movsxd rsi,r8d
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41ba2d:	4c 89 f2             	mov    rdx,r14
  41ba30:	4c 89 ff             	mov    rdi,r15
  41ba33:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
  41ba38:	e8 e3 08 00 00       	call   41c320 <__fwritex>
  41ba3d:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
  41ba42:	e9 f9 fa ff ff       	jmp    41b540 <printf_core+0xd20>
		prefix = "-+   0X0x";
  41ba47:	48 8d 05 6f 41 00 00 	lea    rax,[rip+0x416f]        # 41fbbd <CSWTCH.187+0x7cd>
	for (; x; x>>=4) *--s = xdigits[(x&15)]|lower;
  41ba4e:	4c 8d 84 24 ab 00 00 	lea    r8,[rsp+0xab]
  41ba55:	00 
		pl = 0;
  41ba56:	44 89 7c 24 40       	mov    DWORD PTR [rsp+0x40],r15d
		prefix = "-+   0X0x";
  41ba5b:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
	for (; x; x>>=4) *--s = xdigits[(x&15)]|lower;
  41ba60:	4d 89 c2             	mov    r10,r8
  41ba63:	e9 9e f7 ff ff       	jmp    41b206 <printf_core+0x9e6>
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  41ba68:	4c 8d 84 24 ab 00 00 	lea    r8,[rsp+0xab]
  41ba6f:	00 
  41ba70:	4d 89 c2             	mov    r10,r8
  41ba73:	e9 8e f7 ff ff       	jmp    41b206 <printf_core+0x9e6>
	for (; i<=NL_ARGMAX && !nl_type[i]; i++);
  41ba78:	49 8d 50 01          	lea    rdx,[r8+0x1]
  41ba7c:	49 83 f8 09          	cmp    r8,0x9
  41ba80:	0f 84 3e f3 ff ff    	je     41adc4 <printf_core+0x5a4>
  41ba86:	48 8b 74 24 20       	mov    rsi,QWORD PTR [rsp+0x20]
  41ba8b:	48 8d 04 95 00 00 00 	lea    rax,[rdx*4+0x0]
  41ba92:	00 
  41ba93:	8b 2c 96             	mov    ebp,DWORD PTR [rsi+rdx*4]
  41ba96:	85 ed                	test   ebp,ebp
  41ba98:	0f 85 10 f0 ff ff    	jne    41aaae <printf_core+0x28e>
  41ba9e:	49 83 f8 08          	cmp    r8,0x8
  41baa2:	0f 84 1c f3 ff ff    	je     41adc4 <printf_core+0x5a4>
  41baa8:	8b 5c 06 04          	mov    ebx,DWORD PTR [rsi+rax*1+0x4]
  41baac:	85 db                	test   ebx,ebx
  41baae:	0f 85 fa ef ff ff    	jne    41aaae <printf_core+0x28e>
  41bab4:	49 83 f8 07          	cmp    r8,0x7
  41bab8:	0f 84 06 f3 ff ff    	je     41adc4 <printf_core+0x5a4>
  41babe:	44 8b 5c 06 08       	mov    r11d,DWORD PTR [rsi+rax*1+0x8]
  41bac3:	45 85 db             	test   r11d,r11d
  41bac6:	0f 85 e2 ef ff ff    	jne    41aaae <printf_core+0x28e>
  41bacc:	49 83 f8 06          	cmp    r8,0x6
  41bad0:	0f 84 ee f2 ff ff    	je     41adc4 <printf_core+0x5a4>
  41bad6:	44 8b 54 06 0c       	mov    r10d,DWORD PTR [rsi+rax*1+0xc]
  41badb:	45 85 d2             	test   r10d,r10d
  41bade:	0f 85 ca ef ff ff    	jne    41aaae <printf_core+0x28e>
  41bae4:	49 83 f8 05          	cmp    r8,0x5
  41bae8:	0f 84 d6 f2 ff ff    	je     41adc4 <printf_core+0x5a4>
  41baee:	44 8b 4c 06 10       	mov    r9d,DWORD PTR [rsi+rax*1+0x10]
  41baf3:	45 85 c9             	test   r9d,r9d
  41baf6:	0f 85 b2 ef ff ff    	jne    41aaae <printf_core+0x28e>
  41bafc:	49 83 f8 04          	cmp    r8,0x4
  41bb00:	0f 84 be f2 ff ff    	je     41adc4 <printf_core+0x5a4>
  41bb06:	8b 7c 06 14          	mov    edi,DWORD PTR [rsi+rax*1+0x14]
  41bb0a:	85 ff                	test   edi,edi
  41bb0c:	0f 85 9c ef ff ff    	jne    41aaae <printf_core+0x28e>
  41bb12:	49 8d 50 07          	lea    rdx,[r8+0x7]
  41bb16:	49 83 f8 03          	cmp    r8,0x3
  41bb1a:	0f 84 a4 f2 ff ff    	je     41adc4 <printf_core+0x5a4>
  41bb20:	8b 4c 06 18          	mov    ecx,DWORD PTR [rsi+rax*1+0x18]
  41bb24:	85 c9                	test   ecx,ecx
  41bb26:	0f 85 82 ef ff ff    	jne    41aaae <printf_core+0x28e>
  41bb2c:	48 83 fa 08          	cmp    rdx,0x8
  41bb30:	0f 85 8e f2 ff ff    	jne    41adc4 <printf_core+0x5a4>
  41bb36:	8b 44 06 1c          	mov    eax,DWORD PTR [rsi+rax*1+0x1c]
  41bb3a:	85 c0                	test   eax,eax
  41bb3c:	0f 84 82 f2 ff ff    	je     41adc4 <printf_core+0x5a4>
  41bb42:	e9 67 ef ff ff       	jmp    41aaae <printf_core+0x28e>
  41bb47:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41bb4e:	00 00 
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  41bb50:	41 8b 16             	mov    edx,DWORD PTR [r14]
  41bb53:	83 e2 20             	and    edx,0x20
  41bb56:	e9 dd f9 ff ff       	jmp    41b538 <printf_core+0xd18>
  41bb5b:	41 8b 0e             	mov    ecx,DWORD PTR [r14]
  41bb5e:	83 e1 20             	and    ecx,0x20
  41bb61:	e9 bb fd ff ff       	jmp    41b921 <printf_core+0x1101>
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41bb66:	85 ed                	test   ebp,ebp
  41bb68:	0f 9e c0             	setle  al
  41bb6b:	88 44 24 18          	mov    BYTE PTR [rsp+0x18],al
  41bb6f:	41 f7 c4 00 20 01 00 	test   r12d,0x12000
  41bb76:	0f 85 f2 fc ff ff    	jne    41b86e <printf_core+0x104e>
			for (i=l=0; i<p && *ws && (l=wctomb(mb, *ws++))>=0 && l<=p-i; i+=l);
  41bb7c:	31 c9                	xor    ecx,ecx
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  41bb7e:	84 c0                	test   al,al
  41bb80:	0f 84 22 f9 ff ff    	je     41b4a8 <printf_core+0xc88>
  41bb86:	e9 e3 fc ff ff       	jmp    41b86e <printf_core+0x104e>
  41bb8b:	45 89 e3             	mov    r11d,r12d
  41bb8e:	45 89 ec             	mov    r12d,r13d
  41bb91:	41 89 ed             	mov    r13d,ebp
  41bb94:	e9 5b f3 ff ff       	jmp    41aef4 <printf_core+0x6d4>
  41bb99:	45 89 e3             	mov    r11d,r12d
  41bb9c:	45 89 ec             	mov    r12d,r13d
  41bb9f:	41 89 ed             	mov    r13d,ebp
  41bba2:	e9 38 f4 ff ff       	jmp    41afdf <printf_core+0x7bf>
  41bba7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41bbae:	00 00 

000000000041bbb0 <vfprintf>:

int vfprintf(FILE *restrict f, const char *restrict fmt, va_list ap)
{
  41bbb0:	f3 0f 1e fa          	endbr64 
  41bbb4:	41 57                	push   r15
	va_list ap2;
	int nl_type[NL_ARGMAX+1] = {0};
  41bbb6:	66 0f ef c0          	pxor   xmm0,xmm0
{
  41bbba:	41 56                	push   r14
  41bbbc:	41 55                	push   r13
  41bbbe:	49 89 f5             	mov    r13,rsi
  41bbc1:	41 54                	push   r12
  41bbc3:	55                   	push   rbp
  41bbc4:	48 89 fd             	mov    rbp,rdi
	int olderr;
	int ret;

	/* the copy allows passing va_list* even if va_list is an array */
	va_copy(ap2, ap);
	if (printf_core(0, fmt, &ap2, nl_arg, nl_type) < 0) {
  41bbc7:	31 ff                	xor    edi,edi
{
  41bbc9:	53                   	push   rbx
  41bbca:	48 81 ec 68 01 00 00 	sub    rsp,0x168
	int nl_type[NL_ARGMAX+1] = {0};
  41bbd1:	0f 29 44 24 40       	movaps XMMWORD PTR [rsp+0x40],xmm0
	va_copy(ap2, ap);
  41bbd6:	4c 8d 74 24 28       	lea    r14,[rsp+0x28]
	if (printf_core(0, fmt, &ap2, nl_arg, nl_type) < 0) {
  41bbdb:	4c 8d 44 24 40       	lea    r8,[rsp+0x40]
	int nl_type[NL_ARGMAX+1] = {0};
  41bbe0:	0f 29 44 24 50       	movaps XMMWORD PTR [rsp+0x50],xmm0
	if (printf_core(0, fmt, &ap2, nl_arg, nl_type) < 0) {
  41bbe5:	4c 8d bc 24 c0 00 00 	lea    r15,[rsp+0xc0]
  41bbec:	00 
	int nl_type[NL_ARGMAX+1] = {0};
  41bbed:	48 c7 44 24 60 00 00 	mov    QWORD PTR [rsp+0x60],0x0
  41bbf4:	00 00 
	va_copy(ap2, ap);
  41bbf6:	f3 0f 6f 0a          	movdqu xmm1,XMMWORD PTR [rdx]
	if (printf_core(0, fmt, &ap2, nl_arg, nl_type) < 0) {
  41bbfa:	4c 89 f9             	mov    rcx,r15
	va_copy(ap2, ap);
  41bbfd:	0f 11 4c 24 28       	movups XMMWORD PTR [rsp+0x28],xmm1
  41bc02:	48 8b 42 10          	mov    rax,QWORD PTR [rdx+0x10]
	if (printf_core(0, fmt, &ap2, nl_arg, nl_type) < 0) {
  41bc06:	4c 89 f2             	mov    rdx,r14
  41bc09:	4c 89 44 24 10       	mov    QWORD PTR [rsp+0x10],r8
	va_copy(ap2, ap);
  41bc0e:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
	if (printf_core(0, fmt, &ap2, nl_arg, nl_type) < 0) {
  41bc13:	e8 08 ec ff ff       	call   41a820 <printf_core>
  41bc18:	85 c0                	test   eax,eax
  41bc1a:	0f 88 42 01 00 00    	js     41bd62 <vfprintf+0x1b2>
		va_end(ap2);
		return -1;
	}

	FLOCK(f);
  41bc20:	8b 85 8c 00 00 00    	mov    eax,DWORD PTR [rbp+0x8c]
  41bc26:	c7 44 24 0c 00 00 00 	mov    DWORD PTR [rsp+0xc],0x0
  41bc2d:	00 
  41bc2e:	4c 8b 44 24 10       	mov    r8,QWORD PTR [rsp+0x10]
  41bc33:	85 c0                	test   eax,eax
  41bc35:	78 11                	js     41bc48 <vfprintf+0x98>
  41bc37:	48 89 ef             	mov    rdi,rbp
  41bc3a:	e8 f1 04 00 00       	call   41c130 <__lockfile>
  41bc3f:	4c 8b 44 24 10       	mov    r8,QWORD PTR [rsp+0x10]
  41bc44:	89 44 24 0c          	mov    DWORD PTR [rsp+0xc],eax
	olderr = f->flags & F_ERR;
  41bc48:	8b 45 00             	mov    eax,DWORD PTR [rbp+0x0]
	if (f->mode < 1) f->flags &= ~F_ERR;
  41bc4b:	8b 95 88 00 00 00    	mov    edx,DWORD PTR [rbp+0x88]
	olderr = f->flags & F_ERR;
  41bc51:	89 c1                	mov    ecx,eax
  41bc53:	83 e1 20             	and    ecx,0x20
  41bc56:	89 4c 24 10          	mov    DWORD PTR [rsp+0x10],ecx
	if (f->mode < 1) f->flags &= ~F_ERR;
  41bc5a:	85 d2                	test   edx,edx
  41bc5c:	7f 06                	jg     41bc64 <vfprintf+0xb4>
  41bc5e:	83 e0 df             	and    eax,0xffffffdf
  41bc61:	89 45 00             	mov    DWORD PTR [rbp+0x0],eax
	if (!f->buf_size) {
  41bc64:	48 83 7d 60 00       	cmp    QWORD PTR [rbp+0x60],0x0
  41bc69:	0f 84 99 00 00 00    	je     41bd08 <vfprintf+0x158>
		saved_buf = f->buf;
		f->buf = internal_buf;
		f->buf_size = sizeof internal_buf;
		f->wpos = f->wbase = f->wend = 0;
	}
	if (!f->wend && __towrite(f)) ret = -1;
  41bc6f:	48 8b 5d 20          	mov    rbx,QWORD PTR [rbp+0x20]
  41bc73:	48 85 db             	test   rbx,rbx
  41bc76:	0f 84 ee 00 00 00    	je     41bd6a <vfprintf+0x1ba>
	unsigned char internal_buf[80], *saved_buf = 0;
  41bc7c:	31 db                	xor    ebx,ebx
	else ret = printf_core(f, fmt, &ap2, nl_arg, nl_type);
  41bc7e:	4c 89 f9             	mov    rcx,r15
  41bc81:	4c 89 f2             	mov    rdx,r14
  41bc84:	4c 89 ee             	mov    rsi,r13
  41bc87:	48 89 ef             	mov    rdi,rbp
  41bc8a:	e8 91 eb ff ff       	call   41a820 <printf_core>
  41bc8f:	41 89 c4             	mov    r12d,eax
	if (saved_buf) {
  41bc92:	48 85 db             	test   rbx,rbx
  41bc95:	74 34                	je     41bccb <vfprintf+0x11b>
		f->write(f, 0, 0);
  41bc97:	31 d2                	xor    edx,edx
  41bc99:	31 f6                	xor    esi,esi
  41bc9b:	48 89 ef             	mov    rdi,rbp
  41bc9e:	ff 55 48             	call   QWORD PTR [rbp+0x48]
		if (!f->wpos) ret = -1;
  41bca1:	48 83 7d 28 00       	cmp    QWORD PTR [rbp+0x28],0x0
		f->buf = saved_buf;
  41bca6:	48 89 5d 58          	mov    QWORD PTR [rbp+0x58],rbx
		f->buf_size = 0;
		f->wpos = f->wbase = f->wend = 0;
  41bcaa:	66 0f ef c0          	pxor   xmm0,xmm0
		if (!f->wpos) ret = -1;
  41bcae:	b8 ff ff ff ff       	mov    eax,0xffffffff
		f->buf_size = 0;
  41bcb3:	48 c7 45 60 00 00 00 	mov    QWORD PTR [rbp+0x60],0x0
  41bcba:	00 
		f->wpos = f->wbase = f->wend = 0;
  41bcbb:	48 c7 45 38 00 00 00 	mov    QWORD PTR [rbp+0x38],0x0
  41bcc2:	00 
		if (!f->wpos) ret = -1;
  41bcc3:	44 0f 44 e0          	cmove  r12d,eax
		f->wpos = f->wbase = f->wend = 0;
  41bcc7:	0f 11 45 20          	movups XMMWORD PTR [rbp+0x20],xmm0
	}
	if (f->flags & F_ERR) ret = -1;
  41bccb:	8b 45 00             	mov    eax,DWORD PTR [rbp+0x0]
	f->flags |= olderr;
  41bcce:	44 8b 74 24 10       	mov    r14d,DWORD PTR [rsp+0x10]
	if (f->flags & F_ERR) ret = -1;
  41bcd3:	ba ff ff ff ff       	mov    edx,0xffffffff
  41bcd8:	a8 20                	test   al,0x20
  41bcda:	44 0f 45 e2          	cmovne r12d,edx
	f->flags |= olderr;
  41bcde:	41 09 c6             	or     r14d,eax
	FUNLOCK(f);
  41bce1:	8b 44 24 0c          	mov    eax,DWORD PTR [rsp+0xc]
	f->flags |= olderr;
  41bce5:	44 89 75 00          	mov    DWORD PTR [rbp+0x0],r14d
	FUNLOCK(f);
  41bce9:	85 c0                	test   eax,eax
  41bceb:	75 6b                	jne    41bd58 <vfprintf+0x1a8>
	va_end(ap2);
	return ret;
}
  41bced:	48 81 c4 68 01 00 00 	add    rsp,0x168
  41bcf4:	44 89 e0             	mov    eax,r12d
  41bcf7:	5b                   	pop    rbx
  41bcf8:	5d                   	pop    rbp
  41bcf9:	41 5c                	pop    r12
  41bcfb:	41 5d                	pop    r13
  41bcfd:	41 5e                	pop    r14
  41bcff:	41 5f                	pop    r15
  41bd01:	c3                   	ret    
  41bd02:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
		f->buf = internal_buf;
  41bd08:	48 8d 44 24 70       	lea    rax,[rsp+0x70]
		saved_buf = f->buf;
  41bd0d:	48 8b 5d 58          	mov    rbx,QWORD PTR [rbp+0x58]
		f->wpos = f->wbase = f->wend = 0;
  41bd11:	66 0f ef c0          	pxor   xmm0,xmm0
	if (!f->wend && __towrite(f)) ret = -1;
  41bd15:	48 89 ef             	mov    rdi,rbp
		f->buf = internal_buf;
  41bd18:	48 89 45 58          	mov    QWORD PTR [rbp+0x58],rax
	if (!f->wend && __towrite(f)) ret = -1;
  41bd1c:	41 bc ff ff ff ff    	mov    r12d,0xffffffff
		f->buf_size = sizeof internal_buf;
  41bd22:	48 c7 45 60 50 00 00 	mov    QWORD PTR [rbp+0x60],0x50
  41bd29:	00 
		f->wpos = f->wbase = f->wend = 0;
  41bd2a:	48 c7 45 38 00 00 00 	mov    QWORD PTR [rbp+0x38],0x0
  41bd31:	00 
  41bd32:	0f 11 45 20          	movups XMMWORD PTR [rbp+0x20],xmm0
  41bd36:	4c 89 44 24 18       	mov    QWORD PTR [rsp+0x18],r8
	if (!f->wend && __towrite(f)) ret = -1;
  41bd3b:	e8 70 05 00 00       	call   41c2b0 <__towrite>
  41bd40:	85 c0                	test   eax,eax
  41bd42:	0f 85 4a ff ff ff    	jne    41bc92 <vfprintf+0xe2>
  41bd48:	4c 8b 44 24 18       	mov    r8,QWORD PTR [rsp+0x18]
  41bd4d:	e9 2c ff ff ff       	jmp    41bc7e <vfprintf+0xce>
  41bd52:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	FUNLOCK(f);
  41bd58:	48 89 ef             	mov    rdi,rbp
  41bd5b:	e8 d0 04 00 00       	call   41c230 <__unlockfile>
	return ret;
  41bd60:	eb 8b                	jmp    41bced <vfprintf+0x13d>
		return -1;
  41bd62:	41 bc ff ff ff ff    	mov    r12d,0xffffffff
  41bd68:	eb 83                	jmp    41bced <vfprintf+0x13d>
	if (!f->wend && __towrite(f)) ret = -1;
  41bd6a:	48 89 ef             	mov    rdi,rbp
  41bd6d:	4c 89 44 24 18       	mov    QWORD PTR [rsp+0x18],r8
  41bd72:	41 83 cc ff          	or     r12d,0xffffffff
  41bd76:	e8 35 05 00 00       	call   41c2b0 <__towrite>
  41bd7b:	85 c0                	test   eax,eax
  41bd7d:	0f 85 48 ff ff ff    	jne    41bccb <vfprintf+0x11b>
  41bd83:	eb c3                	jmp    41bd48 <vfprintf+0x198>
  41bd85:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41bd8c:	00 00 00 
  41bd8f:	90                   	nop

000000000041bd90 <memchr>:
#define ONES ((size_t)-1/UCHAR_MAX)
#define HIGHS (ONES * (UCHAR_MAX/2+1))
#define HASZERO(x) ((x)-ONES & ~(x) & HIGHS)

void *memchr(const void *src, int c, size_t n)
{
  41bd90:	f3 0f 1e fa          	endbr64 
  41bd94:	48 89 f8             	mov    rax,rdi
	const unsigned char *s = src;
	c = (unsigned char)c;
  41bd97:	44 0f b6 d6          	movzx  r10d,sil
#ifdef __GNUC__
	for (; ((uintptr_t)s & ALIGN) && n && *s != c; s++, n--);
  41bd9b:	a8 07                	test   al,0x7
  41bd9d:	75 21                	jne    41bdc0 <memchr+0x30>
  41bd9f:	eb 2f                	jmp    41bdd0 <memchr+0x40>
  41bda1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  41bda8:	0f b6 08             	movzx  ecx,BYTE PTR [rax]
  41bdab:	44 39 d1             	cmp    ecx,r10d
  41bdae:	0f 84 7f 00 00 00    	je     41be33 <memchr+0xa3>
  41bdb4:	48 83 c0 01          	add    rax,0x1
  41bdb8:	48 83 ea 01          	sub    rdx,0x1
  41bdbc:	a8 07                	test   al,0x7
  41bdbe:	74 10                	je     41bdd0 <memchr+0x40>
  41bdc0:	48 85 d2             	test   rdx,rdx
  41bdc3:	75 e3                	jne    41bda8 <memchr+0x18>
		for (w = (const void *)s; n>=SS && !HASZERO(*w^k); w++, n-=SS);
		s = (const void *)w;
	}
#endif
	for (; n && *s != c; s++, n--);
	return n ? (void *)s : 0;
  41bdc5:	45 31 c0             	xor    r8d,r8d
}
  41bdc8:	4c 89 c0             	mov    rax,r8
  41bdcb:	c3                   	ret    
  41bdcc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	return n ? (void *)s : 0;
  41bdd0:	45 31 c0             	xor    r8d,r8d
	if (n && *s != c) {
  41bdd3:	48 85 d2             	test   rdx,rdx
  41bdd6:	74 f0                	je     41bdc8 <memchr+0x38>
  41bdd8:	0f b6 08             	movzx  ecx,BYTE PTR [rax]
  41bddb:	44 39 d1             	cmp    ecx,r10d
  41bdde:	74 53                	je     41be33 <memchr+0xa3>
		size_t k = ONES * c;
  41bde0:	48 b9 01 01 01 01 01 	movabs rcx,0x101010101010101
  41bde7:	01 01 01 
  41bdea:	49 63 fa             	movsxd rdi,r10d
		for (w = (const void *)s; n>=SS && !HASZERO(*w^k); w++, n-=SS);
  41bded:	49 b9 ff fe fe fe fe 	movabs r9,0xfefefefefefefeff
  41bdf4:	fe fe fe 
  41bdf7:	49 b8 80 80 80 80 80 	movabs r8,0x8080808080808080
  41bdfe:	80 80 80 
		size_t k = ONES * c;
  41be01:	48 0f af f9          	imul   rdi,rcx
		for (w = (const void *)s; n>=SS && !HASZERO(*w^k); w++, n-=SS);
  41be05:	48 83 fa 07          	cmp    rdx,0x7
  41be09:	77 13                	ja     41be1e <memchr+0x8e>
  41be0b:	eb 26                	jmp    41be33 <memchr+0xa3>
  41be0d:	0f 1f 00             	nop    DWORD PTR [rax]
  41be10:	48 83 ea 08          	sub    rdx,0x8
  41be14:	48 83 c0 08          	add    rax,0x8
  41be18:	48 83 fa 07          	cmp    rdx,0x7
  41be1c:	76 3d                	jbe    41be5b <memchr+0xcb>
  41be1e:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  41be21:	48 31 f9             	xor    rcx,rdi
  41be24:	4a 8d 34 09          	lea    rsi,[rcx+r9*1]
  41be28:	48 f7 d1             	not    rcx
  41be2b:	48 21 f1             	and    rcx,rsi
  41be2e:	4c 85 c1             	test   rcx,r8
  41be31:	74 dd                	je     41be10 <memchr+0x80>
{
  41be33:	49 89 c0             	mov    r8,rax
  41be36:	48 01 c2             	add    rdx,rax
  41be39:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (; n && *s != c; s++, n--);
  41be40:	41 0f b6 00          	movzx  eax,BYTE PTR [r8]
  41be44:	44 39 d0             	cmp    eax,r10d
  41be47:	0f 84 7b ff ff ff    	je     41bdc8 <memchr+0x38>
  41be4d:	49 83 c0 01          	add    r8,0x1
  41be51:	49 39 d0             	cmp    r8,rdx
  41be54:	75 ea                	jne    41be40 <memchr+0xb0>
  41be56:	e9 6a ff ff ff       	jmp    41bdc5 <memchr+0x35>
	return n ? (void *)s : 0;
  41be5b:	45 31 c0             	xor    r8d,r8d
	for (; n && *s != c; s++, n--);
  41be5e:	48 85 d2             	test   rdx,rdx
  41be61:	0f 84 61 ff ff ff    	je     41bdc8 <memchr+0x38>
  41be67:	eb ca                	jmp    41be33 <memchr+0xa3>
  41be69:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000041be70 <__strerror_l>:
static const char errmsg[] =
#include "__strerror.h"
;

char *__strerror_l(int e, locale_t loc)
{
  41be70:	f3 0f 1e fa          	endbr64 
	 * historical typo, so we just remap it. */
	if (EDQUOT==1133) {
		if (e==109) e=-1;
		else if (e==EDQUOT) e=109;
	}
	for (i=0; errid[i] && errid[i] != e; i++);
  41be74:	48 8d 0d 66 48 00 00 	lea    rcx,[rip+0x4866]        # 4206e1 <errid+0x1>
  41be7b:	31 d2                	xor    edx,edx
  41be7d:	b8 54 00 00 00       	mov    eax,0x54
  41be82:	eb 12                	jmp    41be96 <__strerror_l+0x26>
  41be84:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  41be88:	0f b6 01             	movzx  eax,BYTE PTR [rcx]
  41be8b:	48 83 c1 01          	add    rcx,0x1
  41be8f:	83 c2 01             	add    edx,0x1
  41be92:	84 c0                	test   al,al
  41be94:	74 0f                	je     41bea5 <__strerror_l+0x35>
  41be96:	39 f8                	cmp    eax,edi
  41be98:	75 ee                	jne    41be88 <__strerror_l+0x18>
	for (s=errmsg; i; s++, i--) for (; *s; s++);
  41be9a:	48 8d 3d 1f 41 00 00 	lea    rdi,[rip+0x411f]        # 41ffc0 <errmsg>
  41bea1:	85 d2                	test   edx,edx
  41bea3:	74 3b                	je     41bee0 <__strerror_l+0x70>
	for (i=0; errid[i] && errid[i] != e; i++);
  41bea5:	b9 49 00 00 00       	mov    ecx,0x49
  41beaa:	48 8d 05 0f 41 00 00 	lea    rax,[rip+0x410f]        # 41ffc0 <errmsg>
  41beb1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	for (s=errmsg; i; s++, i--) for (; *s; s++);
  41beb8:	84 c9                	test   cl,cl
  41beba:	74 0d                	je     41bec9 <__strerror_l+0x59>
  41bebc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  41bec0:	48 83 c0 01          	add    rax,0x1
  41bec4:	80 38 00             	cmp    BYTE PTR [rax],0x0
  41bec7:	75 f7                	jne    41bec0 <__strerror_l+0x50>
  41bec9:	48 8d 78 01          	lea    rdi,[rax+0x1]
  41becd:	83 ea 01             	sub    edx,0x1
  41bed0:	74 0e                	je     41bee0 <__strerror_l+0x70>
  41bed2:	0f b6 48 01          	movzx  ecx,BYTE PTR [rax+0x1]
  41bed6:	48 89 f8             	mov    rax,rdi
  41bed9:	eb dd                	jmp    41beb8 <__strerror_l+0x48>
  41bedb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	return (char *)LCTRANS(s, LC_MESSAGES, loc);
  41bee0:	48 8b 76 28          	mov    rsi,QWORD PTR [rsi+0x28]
  41bee4:	e9 27 00 00 00       	jmp    41bf10 <__lctrans>
  41bee9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000041bef0 <strerror>:
}

char *strerror(int e)
{
  41bef0:	f3 0f 1e fa          	endbr64 
static inline struct pthread *__pthread_self()
{
	struct pthread *self;
	__asm__ ("mov %%fs:0,%0" : "=r" (self) );
  41bef4:	64 48 8b 04 25 00 00 	mov    rax,QWORD PTR fs:0x0
  41befb:	00 00 
	return __strerror_l(e, CURRENT_LOCALE);
  41befd:	48 8b b0 b0 00 00 00 	mov    rsi,QWORD PTR [rax+0xb0]
  41bf04:	e9 67 ff ff ff       	jmp    41be70 <__strerror_l>
  41bf09:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000041bf10 <__lctrans>:

weak_alias(dummy, __lctrans_impl);

const char *__lctrans(const char *msg, const struct __locale_map *lm)
{
  41bf10:	f3 0f 1e fa          	endbr64 
	return __lctrans_impl(msg, lm);
  41bf14:	e9 57 aa ff ff       	jmp    416970 <__lctrans_impl>
  41bf19:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000041bf20 <__lctrans_cur>:
}

const char *__lctrans_cur(const char *msg)
{
  41bf20:	f3 0f 1e fa          	endbr64 
  41bf24:	64 48 8b 04 25 00 00 	mov    rax,QWORD PTR fs:0x0
  41bf2b:	00 00 
	return __lctrans_impl(msg, CURRENT_LOCALE->cat[LC_MESSAGES]);
  41bf2d:	48 8b 80 b0 00 00 00 	mov    rax,QWORD PTR [rax+0xb0]
  41bf34:	48 8b 70 28          	mov    rsi,QWORD PTR [rax+0x28]
  41bf38:	e9 33 aa ff ff       	jmp    416970 <__lctrans_impl>
  41bf3d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000041bf40 <__fpclassifyl>:
{
	return __fpclassify(x);
}
#elif LDBL_MANT_DIG == 64 && LDBL_MAX_EXP == 16384
int __fpclassifyl(long double x)
{
  41bf40:	f3 0f 1e fa          	endbr64 
	union ldshape u = {x};
	int e = u.i.se & 0x7fff;
  41bf44:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
  41bf49:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
	int msb = u.i.m>>63;
  41bf4e:	48 89 d1             	mov    rcx,rdx
  41bf51:	89 c6                	mov    esi,eax
	int e = u.i.se & 0x7fff;
  41bf53:	25 ff 7f 00 00       	and    eax,0x7fff
	int msb = u.i.m>>63;
  41bf58:	48 c1 e9 3f          	shr    rcx,0x3f
  41bf5c:	66 81 e6 ff 7f       	and    si,0x7fff
	if (!e && !msb)
  41bf61:	09 c8                	or     eax,ecx
  41bf63:	74 2b                	je     41bf90 <__fpclassifyl+0x50>
		 * the version with it clear. */
		if (__BYTE_ORDER == __LITTLE_ENDIAN && !msb)
			return FP_NAN;
		return u.i.m << 1 ? FP_NAN : FP_INFINITE;
	}
	if (!msb)
  41bf65:	8d 04 8d 00 00 00 00 	lea    eax,[rcx*4+0x0]
	if (e == 0x7fff) {
  41bf6c:	66 81 fe ff 7f       	cmp    si,0x7fff
  41bf71:	74 05                	je     41bf78 <__fpclassifyl+0x38>
		return FP_NAN;
	return FP_NORMAL;
}
  41bf73:	c3                   	ret    
  41bf74:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
			return FP_NAN;
  41bf78:	31 c0                	xor    eax,eax
		if (__BYTE_ORDER == __LITTLE_ENDIAN && !msb)
  41bf7a:	48 85 c9             	test   rcx,rcx
  41bf7d:	74 f4                	je     41bf73 <__fpclassifyl+0x33>
		return u.i.m << 1 ? FP_NAN : FP_INFINITE;
  41bf7f:	31 c0                	xor    eax,eax
  41bf81:	48 01 d2             	add    rdx,rdx
  41bf84:	0f 94 c0             	sete   al
}
  41bf87:	c3                   	ret    
  41bf88:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  41bf8f:	00 
		return u.i.m ? FP_SUBNORMAL : FP_ZERO;
  41bf90:	48 83 fa 01          	cmp    rdx,0x1
  41bf94:	b8 02 00 00 00       	mov    eax,0x2
  41bf99:	83 d8 ff             	sbb    eax,0xffffffff
  41bf9c:	c3                   	ret    
  41bf9d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000041bfa0 <__signbitl>:
#include "libm.h"

#if (LDBL_MANT_DIG == 64 || LDBL_MANT_DIG == 113) && LDBL_MAX_EXP == 16384
int __signbitl(long double x)
{
  41bfa0:	f3 0f 1e fa          	endbr64 
	union ldshape u = {x};
	return u.i.se >> 15;
  41bfa4:	0f b7 44 24 10       	movzx  eax,WORD PTR [rsp+0x10]
  41bfa9:	66 c1 e8 0f          	shr    ax,0xf
  41bfad:	0f b7 c0             	movzx  eax,ax
}
  41bfb0:	c3                   	ret    
  41bfb1:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41bfb8:	00 00 00 
  41bfbb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000041bfc0 <frexpl>:
{
	return frexp(x, e);
}
#elif (LDBL_MANT_DIG == 64 || LDBL_MANT_DIG == 113) && LDBL_MAX_EXP == 16384
long double frexpl(long double x, int *e)
{
  41bfc0:	f3 0f 1e fa          	endbr64 
  41bfc4:	48 83 ec 48          	sub    rsp,0x48
	union ldshape u = {x};
  41bfc8:	db 6c 24 50          	fld    TBYTE PTR [rsp+0x50]
  41bfcc:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
	int ee = u.i.se & 0x7fff;

	if (!ee) {
  41bfd1:	89 c2                	mov    edx,eax
	union ldshape u = {x};
  41bfd3:	d9 c0                	fld    st(0)
  41bfd5:	db 7c 24 20          	fstp   TBYTE PTR [rsp+0x20]
	if (!ee) {
  41bfd9:	66 81 e2 ff 7f       	and    dx,0x7fff
  41bfde:	74 40                	je     41c020 <frexpl+0x60>
  41bfe0:	dd d8                	fstp   st(0)
			x = frexpl(x*0x1p120, e);
			*e -= 120;
		} else *e = 0;
		return x;
	} else if (ee == 0x7fff) {
		return x;
  41bfe2:	db 6c 24 50          	fld    TBYTE PTR [rsp+0x50]
	int ee = u.i.se & 0x7fff;
  41bfe6:	0f b7 ca             	movzx  ecx,dx
		return x;
  41bfe9:	db 3c 24             	fstp   TBYTE PTR [rsp]
	} else if (ee == 0x7fff) {
  41bfec:	66 81 fa ff 7f       	cmp    dx,0x7fff
  41bff1:	74 1c                	je     41c00f <frexpl+0x4f>
	}

	*e = ee - 0x3ffe;
	u.i.se &= 0x8000;
  41bff3:	66 25 00 80          	and    ax,0x8000
	*e = ee - 0x3ffe;
  41bff7:	81 e9 fe 3f 00 00    	sub    ecx,0x3ffe
	u.i.se |= 0x3ffe;
  41bffd:	66 0d fe 3f          	or     ax,0x3ffe
	*e = ee - 0x3ffe;
  41c001:	89 0f                	mov    DWORD PTR [rdi],ecx
	u.i.se |= 0x3ffe;
  41c003:	66 89 44 24 28       	mov    WORD PTR [rsp+0x28],ax
	return u.f;
  41c008:	db 6c 24 20          	fld    TBYTE PTR [rsp+0x20]
  41c00c:	db 3c 24             	fstp   TBYTE PTR [rsp]
}
  41c00f:	db 2c 24             	fld    TBYTE PTR [rsp]
  41c012:	48 83 c4 48          	add    rsp,0x48
  41c016:	c3                   	ret    
  41c017:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41c01e:	00 00 
		if (x) {
  41c020:	d9 ee                	fldz   
  41c022:	d9 c9                	fxch   st(1)
  41c024:	df e9                	fucomip st,st(1)
  41c026:	dd d8                	fstp   st(0)
  41c028:	7a 1e                	jp     41c048 <frexpl+0x88>
  41c02a:	75 1c                	jne    41c048 <frexpl+0x88>
		} else *e = 0;
  41c02c:	db 6c 24 50          	fld    TBYTE PTR [rsp+0x50]
  41c030:	c7 07 00 00 00 00    	mov    DWORD PTR [rdi],0x0
  41c036:	db 3c 24             	fstp   TBYTE PTR [rsp]
}
  41c039:	db 2c 24             	fld    TBYTE PTR [rsp]
  41c03c:	48 83 c4 48          	add    rsp,0x48
  41c040:	c3                   	ret    
  41c041:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
			x = frexpl(x*0x1p120, e);
  41c048:	db 6c 24 50          	fld    TBYTE PTR [rsp+0x50]
  41c04c:	d8 0d ba 3e 00 00    	fmul   DWORD PTR [rip+0x3eba]        # 41ff0c <states+0x22c>
  41c052:	d9 c0                	fld    st(0)
  41c054:	db 3c 24             	fstp   TBYTE PTR [rsp]
	union ldshape u = {x};
  41c057:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
	if (!ee) {
  41c05c:	89 c1                	mov    ecx,eax
	union ldshape u = {x};
  41c05e:	db 7c 24 30          	fstp   TBYTE PTR [rsp+0x30]
	if (!ee) {
  41c062:	66 81 e1 ff 7f       	and    cx,0x7fff
  41c067:	74 37                	je     41c0a0 <frexpl+0xe0>
	int ee = u.i.se & 0x7fff;
  41c069:	0f b7 d1             	movzx  edx,cx
	} else if (ee == 0x7fff) {
  41c06c:	66 81 f9 ff 7f       	cmp    cx,0x7fff
  41c071:	74 75                	je     41c0e8 <frexpl+0x128>
	u.i.se &= 0x8000;
  41c073:	66 25 00 80          	and    ax,0x8000
	u.i.se |= 0x3ffe;
  41c077:	66 0d fe 3f          	or     ax,0x3ffe
  41c07b:	66 89 44 24 38       	mov    WORD PTR [rsp+0x38],ax
	return u.f;
  41c080:	db 6c 24 30          	fld    TBYTE PTR [rsp+0x30]
			*e -= 120;
  41c084:	8d 82 8a bf ff ff    	lea    eax,[rdx-0x4076]
	return u.f;
  41c08a:	db 3c 24             	fstp   TBYTE PTR [rsp]
			*e -= 120;
  41c08d:	89 07                	mov    DWORD PTR [rdi],eax
}
  41c08f:	db 2c 24             	fld    TBYTE PTR [rsp]
  41c092:	48 83 c4 48          	add    rsp,0x48
  41c096:	c3                   	ret    
  41c097:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41c09e:	00 00 
		if (x) {
  41c0a0:	d9 ee                	fldz   
  41c0a2:	db 2c 24             	fld    TBYTE PTR [rsp]
  41c0a5:	df e9                	fucomip st,st(1)
  41c0a7:	dd d8                	fstp   st(0)
  41c0a9:	7a 07                	jp     41c0b2 <frexpl+0xf2>
  41c0ab:	b8 88 ff ff ff       	mov    eax,0xffffff88
  41c0b0:	74 db                	je     41c08d <frexpl+0xcd>
			x = frexpl(x*0x1p120, e);
  41c0b2:	db 2c 24             	fld    TBYTE PTR [rsp]
  41c0b5:	d8 0d 51 3e 00 00    	fmul   DWORD PTR [rip+0x3e51]        # 41ff0c <states+0x22c>
  41c0bb:	48 83 ec 10          	sub    rsp,0x10
  41c0bf:	48 89 7c 24 28       	mov    QWORD PTR [rsp+0x28],rdi
  41c0c4:	db 3c 24             	fstp   TBYTE PTR [rsp]
  41c0c7:	e8 f4 fe ff ff       	call   41bfc0 <frexpl>
			*e -= 120;
  41c0cc:	48 8b 7c 24 28       	mov    rdi,QWORD PTR [rsp+0x28]
			x = frexpl(x*0x1p120, e);
  41c0d1:	db 7c 24 10          	fstp   TBYTE PTR [rsp+0x10]
			*e -= 120;
  41c0d5:	5a                   	pop    rdx
  41c0d6:	59                   	pop    rcx
  41c0d7:	8b 07                	mov    eax,DWORD PTR [rdi]
  41c0d9:	2d f0 00 00 00       	sub    eax,0xf0
  41c0de:	89 07                	mov    DWORD PTR [rdi],eax
  41c0e0:	eb ad                	jmp    41c08f <frexpl+0xcf>
  41c0e2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  41c0e8:	8b 07                	mov    eax,DWORD PTR [rdi]
  41c0ea:	83 e8 78             	sub    eax,0x78
  41c0ed:	89 07                	mov    DWORD PTR [rdi],eax
  41c0ef:	eb 9e                	jmp    41c08f <frexpl+0xcf>
  41c0f1:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41c0f8:	00 00 00 
  41c0fb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000041c100 <wctomb>:
#include <stdlib.h>
#include <wchar.h>

int wctomb(char *s, wchar_t wc)
{
  41c100:	f3 0f 1e fa          	endbr64 
	if (!s) return 0;
  41c104:	48 85 ff             	test   rdi,rdi
  41c107:	74 17                	je     41c120 <wctomb+0x20>
{
  41c109:	48 83 ec 08          	sub    rsp,0x8
	return wcrtomb(s, wc, 0);
  41c10d:	31 d2                	xor    edx,edx
  41c10f:	e8 6c 04 00 00       	call   41c580 <wcrtomb>
}
  41c114:	48 83 c4 08          	add    rsp,0x8
  41c118:	c3                   	ret    
  41c119:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  41c120:	31 c0                	xor    eax,eax
  41c122:	c3                   	ret    
  41c123:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41c12a:	00 00 00 
  41c12d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000041c130 <__lockfile>:
#include "stdio_impl.h"
#include "pthread_impl.h"

int __lockfile(FILE *f)
{
  41c130:	f3 0f 1e fa          	endbr64 
  41c134:	41 55                	push   r13
	int owner = f->lock, tid = __pthread_self()->tid;
	if ((owner & ~MAYBE_WAITERS) == tid)
		return 0;
  41c136:	45 31 c0             	xor    r8d,r8d
{
  41c139:	41 54                	push   r12
  41c13b:	55                   	push   rbp
  41c13c:	53                   	push   rbx
  41c13d:	64 48 8b 14 25 00 00 	mov    rdx,QWORD PTR fs:0x0
  41c144:	00 00 
  41c146:	48 83 ec 08          	sub    rsp,0x8
	int owner = f->lock, tid = __pthread_self()->tid;
  41c14a:	8b 87 8c 00 00 00    	mov    eax,DWORD PTR [rdi+0x8c]
  41c150:	8b 5a 38             	mov    ebx,DWORD PTR [rdx+0x38]
	if ((owner & ~MAYBE_WAITERS) == tid)
  41c153:	25 ff ff ff bf       	and    eax,0xbfffffff
  41c158:	39 d8                	cmp    eax,ebx
  41c15a:	0f 84 b6 00 00 00    	je     41c216 <__lockfile+0xe6>
	owner = a_cas(&f->lock, 0, tid);
  41c160:	4c 8d af 8c 00 00 00 	lea    r13,[rdi+0x8c]
	__asm__ __volatile__ (
  41c167:	44 89 c0             	mov    eax,r8d
  41c16a:	f0 0f b1 9f 8c 00 00 	lock cmpxchg DWORD PTR [rdi+0x8c],ebx
  41c171:	00 
	if (!owner) return 1;
  41c172:	85 c0                	test   eax,eax
  41c174:	0f 84 96 00 00 00    	je     41c210 <__lockfile+0xe0>
	while ((owner = a_cas(&f->lock, 0, tid|MAYBE_WAITERS))) {
  41c17a:	81 cb 00 00 00 40    	or     ebx,0x40000000
  41c180:	44 89 c0             	mov    eax,r8d
  41c183:	f0 0f b1 9f 8c 00 00 	lock cmpxchg DWORD PTR [rdi+0x8c],ebx
  41c18a:	00 
  41c18b:	89 c2                	mov    edx,eax
  41c18d:	85 c0                	test   eax,eax
  41c18f:	74 7f                	je     41c210 <__lockfile+0xe0>
  41c191:	31 ed                	xor    ebp,ebp
  41c193:	eb 1d                	jmp    41c1b2 <__lockfile+0x82>
  41c195:	0f 1f 00             	nop    DWORD PTR [rax]
  41c198:	89 d0                	mov    eax,edx
  41c19a:	f0 41 0f b1 4d 00    	lock cmpxchg DWORD PTR [r13+0x0],ecx
		if ((owner & MAYBE_WAITERS) ||
  41c1a0:	39 d0                	cmp    eax,edx
  41c1a2:	74 1e                	je     41c1c2 <__lockfile+0x92>
  41c1a4:	89 e8                	mov    eax,ebp
  41c1a6:	f0 41 0f b1 5d 00    	lock cmpxchg DWORD PTR [r13+0x0],ebx
  41c1ac:	89 c2                	mov    edx,eax
	while ((owner = a_cas(&f->lock, 0, tid|MAYBE_WAITERS))) {
  41c1ae:	85 c0                	test   eax,eax
  41c1b0:	74 5e                	je     41c210 <__lockfile+0xe0>
		    a_cas(&f->lock, owner, owner|MAYBE_WAITERS)==owner)
  41c1b2:	89 d1                	mov    ecx,edx
  41c1b4:	81 c9 00 00 00 40    	or     ecx,0x40000000
		if ((owner & MAYBE_WAITERS) ||
  41c1ba:	f7 c2 00 00 00 40    	test   edx,0x40000000
  41c1c0:	74 d6                	je     41c198 <__lockfile+0x68>
	return __cos_syscall(n, a1, a2, a3, a4, 0, 0, 0);
  41c1c2:	6a 00                	push   0x0
	__syscall(SYS_futex, addr, FUTEX_WAKE, cnt);
}
static inline void __futexwait(volatile void *addr, int val, int priv)
{
	if (priv) priv = FUTEX_PRIVATE;
	__syscall(SYS_futex, addr, FUTEX_WAIT|priv, val, 0) != -ENOSYS ||
  41c1c4:	4c 63 e1             	movsxd r12,ecx
  41c1c7:	4c 89 ee             	mov    rsi,r13
  41c1ca:	45 31 c9             	xor    r9d,r9d
  41c1cd:	6a 00                	push   0x0
  41c1cf:	4c 89 e1             	mov    rcx,r12
  41c1d2:	45 31 c0             	xor    r8d,r8d
  41c1d5:	ba 80 00 00 00       	mov    edx,0x80
  41c1da:	bf ca 00 00 00       	mov    edi,0xca
  41c1df:	e8 ac ec fe ff       	call   40ae90 <__cos_syscall>
  41c1e4:	59                   	pop    rcx
  41c1e5:	5e                   	pop    rsi
  41c1e6:	48 83 f8 da          	cmp    rax,0xffffffffffffffda
  41c1ea:	75 b8                	jne    41c1a4 <__lockfile+0x74>
  41c1ec:	6a 00                	push   0x0
  41c1ee:	31 d2                	xor    edx,edx
  41c1f0:	45 31 c9             	xor    r9d,r9d
  41c1f3:	45 31 c0             	xor    r8d,r8d
  41c1f6:	6a 00                	push   0x0
  41c1f8:	4c 89 e1             	mov    rcx,r12
  41c1fb:	4c 89 ee             	mov    rsi,r13
  41c1fe:	bf ca 00 00 00       	mov    edi,0xca
  41c203:	e8 88 ec fe ff       	call   40ae90 <__cos_syscall>
  41c208:	58                   	pop    rax
  41c209:	5a                   	pop    rdx
  41c20a:	eb 98                	jmp    41c1a4 <__lockfile+0x74>
  41c20c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	if (!owner) return 1;
  41c210:	41 b8 01 00 00 00    	mov    r8d,0x1
			__futexwait(&f->lock, owner|MAYBE_WAITERS, 1);
	}
	return 1;
}
  41c216:	48 83 c4 08          	add    rsp,0x8
  41c21a:	44 89 c0             	mov    eax,r8d
  41c21d:	5b                   	pop    rbx
  41c21e:	5d                   	pop    rbp
  41c21f:	41 5c                	pop    r12
  41c221:	41 5d                	pop    r13
  41c223:	c3                   	ret    
  41c224:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41c22b:	00 00 00 
  41c22e:	66 90                	xchg   ax,ax

000000000041c230 <__unlockfile>:

void __unlockfile(FILE *f)
{
  41c230:	f3 0f 1e fa          	endbr64 
	__asm__ __volatile__(
  41c234:	31 c0                	xor    eax,eax
  41c236:	87 87 8c 00 00 00    	xchg   DWORD PTR [rdi+0x8c],eax
	if (a_swap(&f->lock, 0) & MAYBE_WAITERS)
  41c23c:	a9 00 00 00 40       	test   eax,0x40000000
  41c241:	75 05                	jne    41c248 <__unlockfile+0x18>
  41c243:	c3                   	ret    
  41c244:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
{
  41c248:	55                   	push   rbp
  41c249:	48 8d af 8c 00 00 00 	lea    rbp,[rdi+0x8c]
	return __cos_syscall(n, a1, a2, a3, 0, 0, 0, 0);
  41c250:	b9 01 00 00 00       	mov    ecx,0x1
  41c255:	45 31 c9             	xor    r9d,r9d
  41c258:	6a 00                	push   0x0
  41c25a:	48 89 ee             	mov    rsi,rbp
  41c25d:	45 31 c0             	xor    r8d,r8d
  41c260:	ba 81 00 00 00       	mov    edx,0x81
  41c265:	6a 00                	push   0x0
  41c267:	bf ca 00 00 00       	mov    edi,0xca
  41c26c:	e8 1f ec fe ff       	call   40ae90 <__cos_syscall>
	__syscall(SYS_futex, addr, FUTEX_WAKE|priv, cnt) != -ENOSYS ||
  41c271:	59                   	pop    rcx
  41c272:	5e                   	pop    rsi
  41c273:	48 83 f8 da          	cmp    rax,0xffffffffffffffda
  41c277:	74 07                	je     41c280 <__unlockfile+0x50>
		__wake(&f->lock, 1, 1);
}
  41c279:	5d                   	pop    rbp
  41c27a:	c3                   	ret    
  41c27b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  41c280:	6a 00                	push   0x0
  41c282:	ba 01 00 00 00       	mov    edx,0x1
  41c287:	48 89 ee             	mov    rsi,rbp
  41c28a:	45 31 c9             	xor    r9d,r9d
  41c28d:	6a 00                	push   0x0
  41c28f:	45 31 c0             	xor    r8d,r8d
  41c292:	b9 01 00 00 00       	mov    ecx,0x1
  41c297:	bf ca 00 00 00       	mov    edi,0xca
  41c29c:	e8 ef eb fe ff       	call   40ae90 <__cos_syscall>
  41c2a1:	58                   	pop    rax
  41c2a2:	5a                   	pop    rdx
  41c2a3:	5d                   	pop    rbp
  41c2a4:	c3                   	ret    
  41c2a5:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41c2ac:	00 00 00 
  41c2af:	90                   	nop

000000000041c2b0 <__towrite>:
#include "stdio_impl.h"

int __towrite(FILE *f)
{
  41c2b0:	f3 0f 1e fa          	endbr64 
	f->mode |= f->mode-1;
  41c2b4:	8b 97 88 00 00 00    	mov    edx,DWORD PTR [rdi+0x88]
  41c2ba:	8d 42 ff             	lea    eax,[rdx-0x1]
  41c2bd:	09 d0                	or     eax,edx
  41c2bf:	89 87 88 00 00 00    	mov    DWORD PTR [rdi+0x88],eax
	if (f->flags & F_NOWR) {
  41c2c5:	8b 07                	mov    eax,DWORD PTR [rdi]
  41c2c7:	a8 08                	test   al,0x8
  41c2c9:	75 35                	jne    41c300 <__towrite+0x50>
	}
	/* Clear read buffer (easier than summoning nasal demons) */
	f->rpos = f->rend = 0;

	/* Activate write through the buffer. */
	f->wpos = f->wbase = f->buf;
  41c2cb:	48 8b 47 58          	mov    rax,QWORD PTR [rdi+0x58]
	f->wend = f->buf + f->buf_size;
  41c2cf:	48 8b 4f 60          	mov    rcx,QWORD PTR [rdi+0x60]
	f->rpos = f->rend = 0;
  41c2d3:	66 0f ef c0          	pxor   xmm0,xmm0
  41c2d7:	0f 11 47 08          	movups XMMWORD PTR [rdi+0x8],xmm0
	f->wend = f->buf + f->buf_size;
  41c2db:	48 01 c1             	add    rcx,rax
  41c2de:	66 48 0f 6e c8       	movq   xmm1,rax
	f->wpos = f->wbase = f->buf;
  41c2e3:	48 89 47 38          	mov    QWORD PTR [rdi+0x38],rax

	return 0;
  41c2e7:	31 c0                	xor    eax,eax
	f->wend = f->buf + f->buf_size;
  41c2e9:	66 48 0f 6e c1       	movq   xmm0,rcx
  41c2ee:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
  41c2f2:	0f 11 47 20          	movups XMMWORD PTR [rdi+0x20],xmm0
}
  41c2f6:	c3                   	ret    
  41c2f7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41c2fe:	00 00 
		f->flags |= F_ERR;
  41c300:	83 c8 20             	or     eax,0x20
  41c303:	89 07                	mov    DWORD PTR [rdi],eax
		return EOF;
  41c305:	b8 ff ff ff ff       	mov    eax,0xffffffff
  41c30a:	c3                   	ret    
  41c30b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000041c310 <__towrite_needs_stdio_exit>:

hidden void __towrite_needs_stdio_exit()
{
  41c310:	f3 0f 1e fa          	endbr64 
	__stdio_exit_needed();
  41c314:	e9 a7 03 00 00       	jmp    41c6c0 <__stdio_exit>
  41c319:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000041c320 <__fwritex>:
#include "stdio_impl.h"
#include <string.h>

size_t __fwritex(const unsigned char *restrict s, size_t l, FILE *restrict f)
{
  41c320:	f3 0f 1e fa          	endbr64 
  41c324:	41 56                	push   r14
  41c326:	41 55                	push   r13
  41c328:	49 89 f5             	mov    r13,rsi
  41c32b:	41 54                	push   r12
  41c32d:	49 89 d4             	mov    r12,rdx
  41c330:	55                   	push   rbp
  41c331:	48 89 fd             	mov    rbp,rdi
  41c334:	53                   	push   rbx
	size_t i=0;

	if (!f->wend && __towrite(f)) return 0;
  41c335:	48 8b 42 20          	mov    rax,QWORD PTR [rdx+0x20]
  41c339:	48 85 c0             	test   rax,rax
  41c33c:	0f 84 96 00 00 00    	je     41c3d8 <__fwritex+0xb8>

	if (l > f->wend - f->wpos) return f->write(f, s, l);
  41c342:	49 8b 7c 24 28       	mov    rdi,QWORD PTR [r12+0x28]
  41c347:	48 29 f8             	sub    rax,rdi
  41c34a:	4c 39 e8             	cmp    rax,r13
  41c34d:	72 49                	jb     41c398 <__fwritex+0x78>

	if (f->lbf >= 0) {
  41c34f:	41 8b 84 24 90 00 00 	mov    eax,DWORD PTR [r12+0x90]
  41c356:	00 
  41c357:	4c 89 eb             	mov    rbx,r13
  41c35a:	85 c0                	test   eax,eax
  41c35c:	79 30                	jns    41c38e <__fwritex+0x6e>
  41c35e:	4d 89 ee             	mov    r14,r13
			s += i;
			l -= i;
		}
	}

	memcpy(f->wpos, s, l);
  41c361:	4c 89 f2             	mov    rdx,r14
  41c364:	48 89 ee             	mov    rsi,rbp
  41c367:	e8 be a4 ff ff       	call   41682a <memcpy>
	f->wpos += l;
  41c36c:	4d 01 74 24 28       	add    QWORD PTR [r12+0x28],r14
	return l+i;
  41c371:	4c 89 e8             	mov    rax,r13
}
  41c374:	5b                   	pop    rbx
  41c375:	5d                   	pop    rbp
  41c376:	41 5c                	pop    r12
  41c378:	41 5d                	pop    r13
  41c37a:	41 5e                	pop    r14
  41c37c:	c3                   	ret    
  41c37d:	0f 1f 00             	nop    DWORD PTR [rax]
		for (i=l; i && s[i-1] != '\n'; i--);
  41c380:	80 7c 1d ff 0a       	cmp    BYTE PTR [rbp+rbx*1-0x1],0xa
  41c385:	48 8d 43 ff          	lea    rax,[rbx-0x1]
  41c389:	74 25                	je     41c3b0 <__fwritex+0x90>
  41c38b:	48 89 c3             	mov    rbx,rax
  41c38e:	48 85 db             	test   rbx,rbx
  41c391:	75 ed                	jne    41c380 <__fwritex+0x60>
  41c393:	eb c9                	jmp    41c35e <__fwritex+0x3e>
  41c395:	0f 1f 00             	nop    DWORD PTR [rax]
}
  41c398:	5b                   	pop    rbx
	if (l > f->wend - f->wpos) return f->write(f, s, l);
  41c399:	49 8b 44 24 48       	mov    rax,QWORD PTR [r12+0x48]
  41c39e:	4c 89 ea             	mov    rdx,r13
  41c3a1:	48 89 ee             	mov    rsi,rbp
  41c3a4:	4c 89 e7             	mov    rdi,r12
}
  41c3a7:	5d                   	pop    rbp
  41c3a8:	41 5c                	pop    r12
  41c3aa:	41 5d                	pop    r13
  41c3ac:	41 5e                	pop    r14
	if (l > f->wend - f->wpos) return f->write(f, s, l);
  41c3ae:	ff e0                	jmp    rax
			size_t n = f->write(f, s, i);
  41c3b0:	48 89 da             	mov    rdx,rbx
  41c3b3:	48 89 ee             	mov    rsi,rbp
  41c3b6:	4c 89 e7             	mov    rdi,r12
  41c3b9:	41 ff 54 24 48       	call   QWORD PTR [r12+0x48]
			if (n < i) return n;
  41c3be:	48 39 c3             	cmp    rbx,rax
  41c3c1:	77 b1                	ja     41c374 <__fwritex+0x54>
			l -= i;
  41c3c3:	4d 89 ee             	mov    r14,r13
	memcpy(f->wpos, s, l);
  41c3c6:	49 8b 7c 24 28       	mov    rdi,QWORD PTR [r12+0x28]
			s += i;
  41c3cb:	48 01 dd             	add    rbp,rbx
			l -= i;
  41c3ce:	49 29 de             	sub    r14,rbx
  41c3d1:	eb 8e                	jmp    41c361 <__fwritex+0x41>
  41c3d3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	if (!f->wend && __towrite(f)) return 0;
  41c3d8:	48 89 d7             	mov    rdi,rdx
  41c3db:	e8 d0 fe ff ff       	call   41c2b0 <__towrite>
  41c3e0:	85 c0                	test   eax,eax
  41c3e2:	75 0c                	jne    41c3f0 <__fwritex+0xd0>
	if (l > f->wend - f->wpos) return f->write(f, s, l);
  41c3e4:	49 8b 44 24 20       	mov    rax,QWORD PTR [r12+0x20]
  41c3e9:	e9 54 ff ff ff       	jmp    41c342 <__fwritex+0x22>
  41c3ee:	66 90                	xchg   ax,ax
	if (!f->wend && __towrite(f)) return 0;
  41c3f0:	31 c0                	xor    eax,eax
  41c3f2:	eb 80                	jmp    41c374 <__fwritex+0x54>
  41c3f4:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41c3fb:	00 00 00 
  41c3fe:	66 90                	xchg   ax,ax

000000000041c400 <fwrite>:

size_t fwrite(const void *restrict src, size_t size, size_t nmemb, FILE *restrict f)
{
  41c400:	f3 0f 1e fa          	endbr64 
  41c404:	41 57                	push   r15
	size_t k, l = size*nmemb;
	if (!size) nmemb = 0;
  41c406:	31 c0                	xor    eax,eax
{
  41c408:	49 89 f8             	mov    r8,rdi
  41c40b:	41 56                	push   r14
	size_t k, l = size*nmemb;
  41c40d:	49 89 f6             	mov    r14,rsi
{
  41c410:	41 55                	push   r13
	size_t k, l = size*nmemb;
  41c412:	4c 0f af f2          	imul   r14,rdx
{
  41c416:	49 89 f5             	mov    r13,rsi
  41c419:	41 54                	push   r12
  41c41b:	49 89 d4             	mov    r12,rdx
  41c41e:	55                   	push   rbp
  41c41f:	48 89 cd             	mov    rbp,rcx
  41c422:	53                   	push   rbx
  41c423:	48 83 ec 18          	sub    rsp,0x18
	if (!size) nmemb = 0;
  41c427:	48 85 f6             	test   rsi,rsi
  41c42a:	4c 0f 44 e0          	cmove  r12,rax
	FLOCK(f);
  41c42e:	8b 81 8c 00 00 00    	mov    eax,DWORD PTR [rcx+0x8c]
  41c434:	45 31 ff             	xor    r15d,r15d
  41c437:	85 c0                	test   eax,eax
  41c439:	78 15                	js     41c450 <fwrite+0x50>
  41c43b:	48 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],rdi
  41c440:	48 89 cf             	mov    rdi,rcx
  41c443:	e8 e8 fc ff ff       	call   41c130 <__lockfile>
  41c448:	4c 8b 44 24 08       	mov    r8,QWORD PTR [rsp+0x8]
  41c44d:	41 89 c7             	mov    r15d,eax
	if (!f->wend && __towrite(f)) return 0;
  41c450:	48 8b 45 20          	mov    rax,QWORD PTR [rbp+0x20]
  41c454:	48 85 c0             	test   rax,rax
  41c457:	0f 84 f3 00 00 00    	je     41c550 <fwrite+0x150>
	if (l > f->wend - f->wpos) return f->write(f, s, l);
  41c45d:	48 8b 7d 28          	mov    rdi,QWORD PTR [rbp+0x28]
  41c461:	48 29 f8             	sub    rax,rdi
  41c464:	49 39 c6             	cmp    r14,rax
  41c467:	77 67                	ja     41c4d0 <fwrite+0xd0>
	if (f->lbf >= 0) {
  41c469:	8b 85 90 00 00 00    	mov    eax,DWORD PTR [rbp+0x90]
  41c46f:	4c 89 f3             	mov    rbx,r14
  41c472:	85 c0                	test   eax,eax
  41c474:	79 49                	jns    41c4bf <fwrite+0xbf>
  41c476:	4c 89 f2             	mov    rdx,r14
	memcpy(f->wpos, s, l);
  41c479:	4c 89 c6             	mov    rsi,r8
  41c47c:	48 89 54 24 08       	mov    QWORD PTR [rsp+0x8],rdx
  41c481:	e8 a4 a3 ff ff       	call   41682a <memcpy>
	f->wpos += l;
  41c486:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
  41c48b:	48 01 55 28          	add    QWORD PTR [rbp+0x28],rdx
	k = __fwritex(src, l, f);
	FUNLOCK(f);
  41c48f:	45 85 ff             	test   r15d,r15d
  41c492:	75 6c                	jne    41c500 <fwrite+0x100>
	return k==l ? nmemb : k/size;
}
  41c494:	48 83 c4 18          	add    rsp,0x18
	return k==l ? nmemb : k/size;
  41c498:	4c 89 e0             	mov    rax,r12
}
  41c49b:	5b                   	pop    rbx
  41c49c:	5d                   	pop    rbp
  41c49d:	41 5c                	pop    r12
  41c49f:	41 5d                	pop    r13
  41c4a1:	41 5e                	pop    r14
  41c4a3:	41 5f                	pop    r15
  41c4a5:	c3                   	ret    
  41c4a6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41c4ad:	00 00 00 
		for (i=l; i && s[i-1] != '\n'; i--);
  41c4b0:	41 80 7c 18 ff 0a    	cmp    BYTE PTR [r8+rbx*1-0x1],0xa
  41c4b6:	48 8d 43 ff          	lea    rax,[rbx-0x1]
  41c4ba:	74 64                	je     41c520 <fwrite+0x120>
  41c4bc:	48 89 c3             	mov    rbx,rax
  41c4bf:	48 85 db             	test   rbx,rbx
  41c4c2:	75 ec                	jne    41c4b0 <fwrite+0xb0>
  41c4c4:	eb b0                	jmp    41c476 <fwrite+0x76>
  41c4c6:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41c4cd:	00 00 00 
	if (l > f->wend - f->wpos) return f->write(f, s, l);
  41c4d0:	4c 89 f2             	mov    rdx,r14
  41c4d3:	4c 89 c6             	mov    rsi,r8
  41c4d6:	48 89 ef             	mov    rdi,rbp
  41c4d9:	ff 55 48             	call   QWORD PTR [rbp+0x48]
	FUNLOCK(f);
  41c4dc:	45 85 ff             	test   r15d,r15d
  41c4df:	75 22                	jne    41c503 <fwrite+0x103>
	return k==l ? nmemb : k/size;
  41c4e1:	49 39 c6             	cmp    r14,rax
  41c4e4:	74 ae                	je     41c494 <fwrite+0x94>
}
  41c4e6:	48 83 c4 18          	add    rsp,0x18
	return k==l ? nmemb : k/size;
  41c4ea:	31 d2                	xor    edx,edx
}
  41c4ec:	5b                   	pop    rbx
  41c4ed:	5d                   	pop    rbp
	return k==l ? nmemb : k/size;
  41c4ee:	49 f7 f5             	div    r13
}
  41c4f1:	41 5c                	pop    r12
  41c4f3:	41 5d                	pop    r13
  41c4f5:	41 5e                	pop    r14
  41c4f7:	41 5f                	pop    r15
  41c4f9:	c3                   	ret    
  41c4fa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	FUNLOCK(f);
  41c500:	4c 89 f0             	mov    rax,r14
  41c503:	48 89 ef             	mov    rdi,rbp
  41c506:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  41c50b:	e8 20 fd ff ff       	call   41c230 <__unlockfile>
  41c510:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
  41c515:	eb ca                	jmp    41c4e1 <fwrite+0xe1>
  41c517:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41c51e:	00 00 
			size_t n = f->write(f, s, i);
  41c520:	4c 89 44 24 08       	mov    QWORD PTR [rsp+0x8],r8
  41c525:	4c 89 c6             	mov    rsi,r8
  41c528:	48 89 da             	mov    rdx,rbx
  41c52b:	48 89 ef             	mov    rdi,rbp
  41c52e:	ff 55 48             	call   QWORD PTR [rbp+0x48]
			if (n < i) return n;
  41c531:	4c 8b 44 24 08       	mov    r8,QWORD PTR [rsp+0x8]
  41c536:	48 39 c3             	cmp    rbx,rax
  41c539:	77 a1                	ja     41c4dc <fwrite+0xdc>
			l -= i;
  41c53b:	4c 89 f2             	mov    rdx,r14
	memcpy(f->wpos, s, l);
  41c53e:	48 8b 7d 28          	mov    rdi,QWORD PTR [rbp+0x28]
			s += i;
  41c542:	49 01 d8             	add    r8,rbx
			l -= i;
  41c545:	48 29 da             	sub    rdx,rbx
  41c548:	e9 2c ff ff ff       	jmp    41c479 <fwrite+0x79>
  41c54d:	0f 1f 00             	nop    DWORD PTR [rax]
	if (!f->wend && __towrite(f)) return 0;
  41c550:	48 89 ef             	mov    rdi,rbp
  41c553:	4c 89 44 24 08       	mov    QWORD PTR [rsp+0x8],r8
  41c558:	e8 53 fd ff ff       	call   41c2b0 <__towrite>
  41c55d:	85 c0                	test   eax,eax
  41c55f:	75 0f                	jne    41c570 <fwrite+0x170>
	if (l > f->wend - f->wpos) return f->write(f, s, l);
  41c561:	48 8b 45 20          	mov    rax,QWORD PTR [rbp+0x20]
  41c565:	4c 8b 44 24 08       	mov    r8,QWORD PTR [rsp+0x8]
  41c56a:	e9 ee fe ff ff       	jmp    41c45d <fwrite+0x5d>
  41c56f:	90                   	nop
	if (!f->wend && __towrite(f)) return 0;
  41c570:	31 c0                	xor    eax,eax
  41c572:	e9 65 ff ff ff       	jmp    41c4dc <fwrite+0xdc>
  41c577:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41c57e:	00 00 

000000000041c580 <wcrtomb>:
#include <wchar.h>
#include <errno.h>
#include "internal.h"

size_t wcrtomb(char *restrict s, wchar_t wc, mbstate_t *restrict st)
{
  41c580:	f3 0f 1e fa          	endbr64 
	if (!s) return 1;
  41c584:	48 85 ff             	test   rdi,rdi
  41c587:	74 7a                	je     41c603 <wcrtomb+0x83>
  41c589:	48 89 fa             	mov    rdx,rdi
  41c58c:	89 f0                	mov    eax,esi
	if ((unsigned)wc < 0x80) {
  41c58e:	83 fe 7f             	cmp    esi,0x7f
  41c591:	76 6d                	jbe    41c600 <wcrtomb+0x80>
{
  41c593:	48 83 ec 08          	sub    rsp,0x8
  41c597:	64 48 8b 0c 25 00 00 	mov    rcx,QWORD PTR fs:0x0
  41c59e:	00 00 
		*s = wc;
		return 1;
	} else if (MB_CUR_MAX == 1) {
  41c5a0:	48 8b 89 b0 00 00 00 	mov    rcx,QWORD PTR [rcx+0xb0]
  41c5a7:	48 83 39 00          	cmp    QWORD PTR [rcx],0x0
  41c5ab:	74 63                	je     41c610 <wcrtomb+0x90>
			errno = EILSEQ;
			return -1;
		}
		*s = wc;
		return 1;
	} else if ((unsigned)wc < 0x800) {
  41c5ad:	81 fe ff 07 00 00    	cmp    esi,0x7ff
  41c5b3:	0f 86 b7 00 00 00    	jbe    41c670 <wcrtomb+0xf0>
		*s++ = 0xc0 | (wc>>6);
		*s = 0x80 | (wc&0x3f);
		return 2;
	} else if ((unsigned)wc < 0xd800 || (unsigned)wc-0xe000 < 0x2000) {
  41c5b9:	8d 8e 00 20 ff ff    	lea    ecx,[rsi-0xe000]
  41c5bf:	81 f9 ff 1f 00 00    	cmp    ecx,0x1fff
  41c5c5:	0f 86 c5 00 00 00    	jbe    41c690 <wcrtomb+0x110>
  41c5cb:	81 fe ff d7 00 00    	cmp    esi,0xd7ff
  41c5d1:	0f 86 b9 00 00 00    	jbe    41c690 <wcrtomb+0x110>
		*s++ = 0xe0 | (wc>>12);
		*s++ = 0x80 | ((wc>>6)&0x3f);
		*s = 0x80 | (wc&0x3f);
		return 3;
	} else if ((unsigned)wc-0x10000 < 0x100000) {
  41c5d7:	8d 8e 00 00 ff ff    	lea    ecx,[rsi-0x10000]
  41c5dd:	81 f9 ff ff 0f 00    	cmp    ecx,0xfffff
  41c5e3:	76 4b                	jbe    41c630 <wcrtomb+0xb0>
		*s++ = 0x80 | ((wc>>12)&0x3f);
		*s++ = 0x80 | ((wc>>6)&0x3f);
		*s = 0x80 | (wc&0x3f);
		return 4;
	}
	errno = EILSEQ;
  41c5e5:	e8 56 b2 ff ff       	call   417840 <__errno_location>
  41c5ea:	c7 00 54 00 00 00    	mov    DWORD PTR [rax],0x54
	return -1;
  41c5f0:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
}
  41c5f7:	48 83 c4 08          	add    rsp,0x8
  41c5fb:	c3                   	ret    
  41c5fc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		*s = wc;
  41c600:	40 88 32             	mov    BYTE PTR [rdx],sil
		return 1;
  41c603:	b8 01 00 00 00       	mov    eax,0x1
}
  41c608:	c3                   	ret    
  41c609:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		if (!IS_CODEUNIT(wc)) {
  41c610:	8d 8e 80 20 ff ff    	lea    ecx,[rsi-0xdf80]
  41c616:	83 f9 7f             	cmp    ecx,0x7f
  41c619:	77 ca                	ja     41c5e5 <wcrtomb+0x65>
		*s = wc;
  41c61b:	88 02                	mov    BYTE PTR [rdx],al
		return 1;
  41c61d:	b8 01 00 00 00       	mov    eax,0x1
}
  41c622:	48 83 c4 08          	add    rsp,0x8
  41c626:	c3                   	ret    
  41c627:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41c62e:	00 00 
		*s++ = 0xf0 | (wc>>18);
  41c630:	89 f1                	mov    ecx,esi
		*s = 0x80 | (wc&0x3f);
  41c632:	83 e0 3f             	and    eax,0x3f
		*s++ = 0xf0 | (wc>>18);
  41c635:	c1 f9 12             	sar    ecx,0x12
		*s = 0x80 | (wc&0x3f);
  41c638:	83 c8 80             	or     eax,0xffffff80
		*s++ = 0xf0 | (wc>>18);
  41c63b:	83 c9 f0             	or     ecx,0xfffffff0
		*s = 0x80 | (wc&0x3f);
  41c63e:	88 47 03             	mov    BYTE PTR [rdi+0x3],al
		return 4;
  41c641:	b8 04 00 00 00       	mov    eax,0x4
		*s++ = 0xf0 | (wc>>18);
  41c646:	88 0f                	mov    BYTE PTR [rdi],cl
		*s++ = 0x80 | ((wc>>12)&0x3f);
  41c648:	89 f1                	mov    ecx,esi
  41c64a:	c1 f9 0c             	sar    ecx,0xc
  41c64d:	83 e1 3f             	and    ecx,0x3f
  41c650:	83 c9 80             	or     ecx,0xffffff80
  41c653:	88 4f 01             	mov    BYTE PTR [rdi+0x1],cl
		*s++ = 0x80 | ((wc>>6)&0x3f);
  41c656:	89 f1                	mov    ecx,esi
  41c658:	c1 f9 06             	sar    ecx,0x6
  41c65b:	83 e1 3f             	and    ecx,0x3f
  41c65e:	83 c9 80             	or     ecx,0xffffff80
  41c661:	88 4f 02             	mov    BYTE PTR [rdi+0x2],cl
		return 4;
  41c664:	eb 91                	jmp    41c5f7 <wcrtomb+0x77>
  41c666:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41c66d:	00 00 00 
		*s++ = 0xc0 | (wc>>6);
  41c670:	89 f1                	mov    ecx,esi
		*s = 0x80 | (wc&0x3f);
  41c672:	83 e0 3f             	and    eax,0x3f
		*s++ = 0xc0 | (wc>>6);
  41c675:	c1 f9 06             	sar    ecx,0x6
		*s = 0x80 | (wc&0x3f);
  41c678:	83 c8 80             	or     eax,0xffffff80
		*s++ = 0xc0 | (wc>>6);
  41c67b:	83 c9 c0             	or     ecx,0xffffffc0
		*s = 0x80 | (wc&0x3f);
  41c67e:	88 47 01             	mov    BYTE PTR [rdi+0x1],al
		return 2;
  41c681:	b8 02 00 00 00       	mov    eax,0x2
		*s++ = 0xc0 | (wc>>6);
  41c686:	88 0f                	mov    BYTE PTR [rdi],cl
		return 2;
  41c688:	e9 6a ff ff ff       	jmp    41c5f7 <wcrtomb+0x77>
  41c68d:	0f 1f 00             	nop    DWORD PTR [rax]
		*s++ = 0xe0 | (wc>>12);
  41c690:	89 c1                	mov    ecx,eax
  41c692:	c1 f9 0c             	sar    ecx,0xc
  41c695:	83 c9 e0             	or     ecx,0xffffffe0
  41c698:	88 0a                	mov    BYTE PTR [rdx],cl
		*s++ = 0x80 | ((wc>>6)&0x3f);
  41c69a:	89 c1                	mov    ecx,eax
		*s = 0x80 | (wc&0x3f);
  41c69c:	83 e0 3f             	and    eax,0x3f
		*s++ = 0x80 | ((wc>>6)&0x3f);
  41c69f:	c1 f9 06             	sar    ecx,0x6
		*s = 0x80 | (wc&0x3f);
  41c6a2:	83 c8 80             	or     eax,0xffffff80
		*s++ = 0x80 | ((wc>>6)&0x3f);
  41c6a5:	83 e1 3f             	and    ecx,0x3f
		*s = 0x80 | (wc&0x3f);
  41c6a8:	88 42 02             	mov    BYTE PTR [rdx+0x2],al
		return 3;
  41c6ab:	b8 03 00 00 00       	mov    eax,0x3
		*s++ = 0x80 | ((wc>>6)&0x3f);
  41c6b0:	83 c9 80             	or     ecx,0xffffff80
  41c6b3:	88 4a 01             	mov    BYTE PTR [rdx+0x1],cl
		return 3;
  41c6b6:	e9 3c ff ff ff       	jmp    41c5f7 <wcrtomb+0x77>
  41c6bb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000041c6c0 <__stdio_exit>:
	if (f->wpos != f->wbase) f->write(f, 0, 0);
	if (f->rpos != f->rend) f->seek(f, f->rpos-f->rend, SEEK_CUR);
}

void __stdio_exit(void)
{
  41c6c0:	f3 0f 1e fa          	endbr64 
  41c6c4:	55                   	push   rbp
  41c6c5:	53                   	push   rbx
  41c6c6:	48 83 ec 08          	sub    rsp,0x8
	FILE *f;
	for (f=*__ofl_lock(); f; f=f->next) close_file(f);
  41c6ca:	e8 a1 01 00 00       	call   41c870 <__ofl_lock>
  41c6cf:	48 8b 18             	mov    rbx,QWORD PTR [rax]
  41c6d2:	48 85 db             	test   rbx,rbx
  41c6d5:	74 57                	je     41c72e <__stdio_exit+0x6e>
  41c6d7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41c6de:	00 00 
	FFINALLOCK(f);
  41c6e0:	8b 83 8c 00 00 00    	mov    eax,DWORD PTR [rbx+0x8c]
  41c6e6:	85 c0                	test   eax,eax
  41c6e8:	78 08                	js     41c6f2 <__stdio_exit+0x32>
  41c6ea:	48 89 df             	mov    rdi,rbx
  41c6ed:	e8 3e fa ff ff       	call   41c130 <__lockfile>
	if (f->wpos != f->wbase) f->write(f, 0, 0);
  41c6f2:	48 8b 43 38          	mov    rax,QWORD PTR [rbx+0x38]
  41c6f6:	48 39 43 28          	cmp    QWORD PTR [rbx+0x28],rax
  41c6fa:	74 0a                	je     41c706 <__stdio_exit+0x46>
  41c6fc:	31 d2                	xor    edx,edx
  41c6fe:	31 f6                	xor    esi,esi
  41c700:	48 89 df             	mov    rdi,rbx
  41c703:	ff 53 48             	call   QWORD PTR [rbx+0x48]
	if (f->rpos != f->rend) f->seek(f, f->rpos-f->rend, SEEK_CUR);
  41c706:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
  41c70a:	48 8b 43 10          	mov    rax,QWORD PTR [rbx+0x10]
  41c70e:	48 39 c6             	cmp    rsi,rax
  41c711:	0f 84 01 01 00 00    	je     41c818 <__stdio_exit+0x158>
  41c717:	48 89 df             	mov    rdi,rbx
  41c71a:	48 29 c6             	sub    rsi,rax
  41c71d:	ba 01 00 00 00       	mov    edx,0x1
  41c722:	ff 53 50             	call   QWORD PTR [rbx+0x50]
	for (f=*__ofl_lock(); f; f=f->next) close_file(f);
  41c725:	48 8b 5b 70          	mov    rbx,QWORD PTR [rbx+0x70]
  41c729:	48 85 db             	test   rbx,rbx
  41c72c:	75 b2                	jne    41c6e0 <__stdio_exit+0x20>
	close_file(__stdin_used);
  41c72e:	48 8b 1d 3b aa 2f 00 	mov    rbx,QWORD PTR [rip+0x2faa3b]        # 717170 <__stderr_used>
	if (!f) return;
  41c735:	48 85 db             	test   rbx,rbx
  41c738:	74 3d                	je     41c777 <__stdio_exit+0xb7>
	FFINALLOCK(f);
  41c73a:	8b 83 8c 00 00 00    	mov    eax,DWORD PTR [rbx+0x8c]
  41c740:	85 c0                	test   eax,eax
  41c742:	0f 89 08 01 00 00    	jns    41c850 <__stdio_exit+0x190>
	if (f->wpos != f->wbase) f->write(f, 0, 0);
  41c748:	48 8b 43 38          	mov    rax,QWORD PTR [rbx+0x38]
  41c74c:	48 39 43 28          	cmp    QWORD PTR [rbx+0x28],rax
  41c750:	74 0a                	je     41c75c <__stdio_exit+0x9c>
  41c752:	31 d2                	xor    edx,edx
  41c754:	31 f6                	xor    esi,esi
  41c756:	48 89 df             	mov    rdi,rbx
  41c759:	ff 53 48             	call   QWORD PTR [rbx+0x48]
	if (f->rpos != f->rend) f->seek(f, f->rpos-f->rend, SEEK_CUR);
  41c75c:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
  41c760:	48 8b 43 10          	mov    rax,QWORD PTR [rbx+0x10]
  41c764:	48 39 c6             	cmp    rsi,rax
  41c767:	74 0e                	je     41c777 <__stdio_exit+0xb7>
  41c769:	48 29 c6             	sub    rsi,rax
  41c76c:	ba 01 00 00 00       	mov    edx,0x1
  41c771:	48 89 df             	mov    rdi,rbx
  41c774:	ff 53 50             	call   QWORD PTR [rbx+0x50]
	close_file(__stdout_used);
  41c777:	48 8b 1d f2 a9 2f 00 	mov    rbx,QWORD PTR [rip+0x2fa9f2]        # 717170 <__stderr_used>
	if (!f) return;
  41c77e:	48 85 db             	test   rbx,rbx
  41c781:	74 3d                	je     41c7c0 <__stdio_exit+0x100>
	FFINALLOCK(f);
  41c783:	8b 83 8c 00 00 00    	mov    eax,DWORD PTR [rbx+0x8c]
  41c789:	85 c0                	test   eax,eax
  41c78b:	0f 89 af 00 00 00    	jns    41c840 <__stdio_exit+0x180>
	if (f->wpos != f->wbase) f->write(f, 0, 0);
  41c791:	48 8b 43 38          	mov    rax,QWORD PTR [rbx+0x38]
  41c795:	48 39 43 28          	cmp    QWORD PTR [rbx+0x28],rax
  41c799:	74 0a                	je     41c7a5 <__stdio_exit+0xe5>
  41c79b:	31 d2                	xor    edx,edx
  41c79d:	31 f6                	xor    esi,esi
  41c79f:	48 89 df             	mov    rdi,rbx
  41c7a2:	ff 53 48             	call   QWORD PTR [rbx+0x48]
	if (f->rpos != f->rend) f->seek(f, f->rpos-f->rend, SEEK_CUR);
  41c7a5:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
  41c7a9:	48 8b 43 10          	mov    rax,QWORD PTR [rbx+0x10]
  41c7ad:	48 39 c6             	cmp    rsi,rax
  41c7b0:	74 0e                	je     41c7c0 <__stdio_exit+0x100>
  41c7b2:	48 29 c6             	sub    rsi,rax
  41c7b5:	ba 01 00 00 00       	mov    edx,0x1
  41c7ba:	48 89 df             	mov    rdi,rbx
  41c7bd:	ff 53 50             	call   QWORD PTR [rbx+0x50]
	close_file(__stderr_used);
  41c7c0:	48 8b 2d a9 a9 2f 00 	mov    rbp,QWORD PTR [rip+0x2fa9a9]        # 717170 <__stderr_used>
	if (!f) return;
  41c7c7:	48 85 ed             	test   rbp,rbp
  41c7ca:	0f 84 90 00 00 00    	je     41c860 <__stdio_exit+0x1a0>
	FFINALLOCK(f);
  41c7d0:	8b 85 8c 00 00 00    	mov    eax,DWORD PTR [rbp+0x8c]
  41c7d6:	85 c0                	test   eax,eax
  41c7d8:	79 56                	jns    41c830 <__stdio_exit+0x170>
	if (f->wpos != f->wbase) f->write(f, 0, 0);
  41c7da:	48 8b 45 38          	mov    rax,QWORD PTR [rbp+0x38]
  41c7de:	48 39 45 28          	cmp    QWORD PTR [rbp+0x28],rax
  41c7e2:	74 0a                	je     41c7ee <__stdio_exit+0x12e>
  41c7e4:	31 d2                	xor    edx,edx
  41c7e6:	31 f6                	xor    esi,esi
  41c7e8:	48 89 ef             	mov    rdi,rbp
  41c7eb:	ff 55 48             	call   QWORD PTR [rbp+0x48]
	if (f->rpos != f->rend) f->seek(f, f->rpos-f->rend, SEEK_CUR);
  41c7ee:	48 8b 75 08          	mov    rsi,QWORD PTR [rbp+0x8]
  41c7f2:	48 8b 45 10          	mov    rax,QWORD PTR [rbp+0x10]
  41c7f6:	48 39 c6             	cmp    rsi,rax
  41c7f9:	74 65                	je     41c860 <__stdio_exit+0x1a0>
  41c7fb:	48 29 c6             	sub    rsi,rax
  41c7fe:	48 8b 45 50          	mov    rax,QWORD PTR [rbp+0x50]
}
  41c802:	48 83 c4 08          	add    rsp,0x8
	if (f->rpos != f->rend) f->seek(f, f->rpos-f->rend, SEEK_CUR);
  41c806:	48 89 ef             	mov    rdi,rbp
}
  41c809:	5b                   	pop    rbx
	if (f->rpos != f->rend) f->seek(f, f->rpos-f->rend, SEEK_CUR);
  41c80a:	ba 01 00 00 00       	mov    edx,0x1
}
  41c80f:	5d                   	pop    rbp
	if (f->rpos != f->rend) f->seek(f, f->rpos-f->rend, SEEK_CUR);
  41c810:	ff e0                	jmp    rax
  41c812:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	for (f=*__ofl_lock(); f; f=f->next) close_file(f);
  41c818:	48 8b 5b 70          	mov    rbx,QWORD PTR [rbx+0x70]
  41c81c:	48 85 db             	test   rbx,rbx
  41c81f:	0f 85 bb fe ff ff    	jne    41c6e0 <__stdio_exit+0x20>
  41c825:	e9 04 ff ff ff       	jmp    41c72e <__stdio_exit+0x6e>
  41c82a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	FFINALLOCK(f);
  41c830:	48 89 ef             	mov    rdi,rbp
  41c833:	e8 f8 f8 ff ff       	call   41c130 <__lockfile>
  41c838:	eb a0                	jmp    41c7da <__stdio_exit+0x11a>
  41c83a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  41c840:	48 89 df             	mov    rdi,rbx
  41c843:	e8 e8 f8 ff ff       	call   41c130 <__lockfile>
  41c848:	e9 44 ff ff ff       	jmp    41c791 <__stdio_exit+0xd1>
  41c84d:	0f 1f 00             	nop    DWORD PTR [rax]
  41c850:	48 89 df             	mov    rdi,rbx
  41c853:	e8 d8 f8 ff ff       	call   41c130 <__lockfile>
  41c858:	e9 eb fe ff ff       	jmp    41c748 <__stdio_exit+0x88>
  41c85d:	0f 1f 00             	nop    DWORD PTR [rax]
}
  41c860:	48 83 c4 08          	add    rsp,0x8
  41c864:	5b                   	pop    rbx
  41c865:	5d                   	pop    rbp
  41c866:	c3                   	ret    
  41c867:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  41c86e:	00 00 

000000000041c870 <__ofl_lock>:

static FILE *ofl_head;
static volatile int ofl_lock[1];

FILE **__ofl_lock()
{
  41c870:	f3 0f 1e fa          	endbr64 
  41c874:	48 83 ec 08          	sub    rsp,0x8
	LOCK(ofl_lock);
  41c878:	48 8d 3d f9 a8 2f 00 	lea    rdi,[rip+0x2fa8f9]        # 717178 <ofl_lock>
  41c87f:	e8 1c 00 00 00       	call   41c8a0 <__lock>
	return &ofl_head;
  41c884:	48 8d 05 f5 a8 2f 00 	lea    rax,[rip+0x2fa8f5]        # 717180 <ofl_head>
}
  41c88b:	48 83 c4 08          	add    rsp,0x8
  41c88f:	c3                   	ret    

000000000041c890 <__ofl_unlock>:

void __ofl_unlock()
{
  41c890:	f3 0f 1e fa          	endbr64 
	UNLOCK(ofl_lock);
  41c894:	48 8d 3d dd a8 2f 00 	lea    rdi,[rip+0x2fa8dd]        # 717178 <ofl_lock>
  41c89b:	e9 60 02 00 00       	jmp    41cb00 <__unlock>

000000000041c8a0 <__lock>:
 * or in an equivalent formulation x is the congestion count or'ed
 * with INT_MIN as a lock flag.
 */

void __lock(volatile int *l)
{
  41c8a0:	f3 0f 1e fa          	endbr64 
	if (!libc.threads_minus_1) return;
  41c8a4:	8b 05 a2 a6 2f 00    	mov    eax,DWORD PTR [rip+0x2fa6a2]        # 716f4c <__libc+0xc>
  41c8aa:	85 c0                	test   eax,eax
  41c8ac:	0f 84 c6 01 00 00    	je     41ca78 <__lock+0x1d8>
{
  41c8b2:	41 54                	push   r12
	__asm__ __volatile__ (
  41c8b4:	31 c0                	xor    eax,eax
  41c8b6:	ba 01 00 00 80       	mov    edx,0x80000001
  41c8bb:	55                   	push   rbp
  41c8bc:	48 89 fd             	mov    rbp,rdi
  41c8bf:	53                   	push   rbx
  41c8c0:	f0 0f b1 17          	lock cmpxchg DWORD PTR [rdi],edx
  41c8c4:	89 c2                	mov    edx,eax
	/* fast path: INT_MIN for the lock, +1 for the congestion */
	int current = a_cas(l, 0, INT_MIN + 1);
	if (!current) return;
  41c8c6:	85 c0                	test   eax,eax
  41c8c8:	0f 84 a2 01 00 00    	je     41ca70 <__lock+0x1d0>
	/* A first spin loop, for medium congestion. */
	for (unsigned i = 0; i < 10; ++i) {
		if (current < 0) current -= INT_MIN + 1;
		// assertion: current >= 0
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41c8ce:	8d 88 01 00 00 80    	lea    ecx,[rax-0x7fffffff]
		if (current < 0) current -= INT_MIN + 1;
  41c8d4:	79 08                	jns    41c8de <__lock+0x3e>
  41c8d6:	89 c1                	mov    ecx,eax
  41c8d8:	81 c2 ff ff ff 7f    	add    edx,0x7fffffff
  41c8de:	89 d0                	mov    eax,edx
  41c8e0:	f0 0f b1 4d 00       	lock cmpxchg DWORD PTR [rbp+0x0],ecx
  41c8e5:	89 c1                	mov    ecx,eax
		if (val == current) return;
  41c8e7:	39 d0                	cmp    eax,edx
  41c8e9:	0f 84 81 01 00 00    	je     41ca70 <__lock+0x1d0>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41c8ef:	8d 90 01 00 00 80    	lea    edx,[rax-0x7fffffff]
		if (current < 0) current -= INT_MIN + 1;
  41c8f5:	85 c0                	test   eax,eax
  41c8f7:	79 08                	jns    41c901 <__lock+0x61>
  41c8f9:	89 c2                	mov    edx,eax
  41c8fb:	81 c1 ff ff ff 7f    	add    ecx,0x7fffffff
  41c901:	89 c8                	mov    eax,ecx
  41c903:	f0 0f b1 55 00       	lock cmpxchg DWORD PTR [rbp+0x0],edx
  41c908:	89 c2                	mov    edx,eax
		if (val == current) return;
  41c90a:	39 c1                	cmp    ecx,eax
  41c90c:	0f 84 5e 01 00 00    	je     41ca70 <__lock+0x1d0>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41c912:	8d 88 01 00 00 80    	lea    ecx,[rax-0x7fffffff]
		if (current < 0) current -= INT_MIN + 1;
  41c918:	85 c0                	test   eax,eax
  41c91a:	79 08                	jns    41c924 <__lock+0x84>
  41c91c:	89 c1                	mov    ecx,eax
  41c91e:	81 c2 ff ff ff 7f    	add    edx,0x7fffffff
  41c924:	89 d0                	mov    eax,edx
  41c926:	f0 0f b1 4d 00       	lock cmpxchg DWORD PTR [rbp+0x0],ecx
  41c92b:	89 c1                	mov    ecx,eax
		if (val == current) return;
  41c92d:	39 c2                	cmp    edx,eax
  41c92f:	0f 84 3b 01 00 00    	je     41ca70 <__lock+0x1d0>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41c935:	8d 90 01 00 00 80    	lea    edx,[rax-0x7fffffff]
		if (current < 0) current -= INT_MIN + 1;
  41c93b:	85 c0                	test   eax,eax
  41c93d:	79 08                	jns    41c947 <__lock+0xa7>
  41c93f:	89 c2                	mov    edx,eax
  41c941:	81 c1 ff ff ff 7f    	add    ecx,0x7fffffff
  41c947:	89 c8                	mov    eax,ecx
  41c949:	f0 0f b1 55 00       	lock cmpxchg DWORD PTR [rbp+0x0],edx
  41c94e:	89 c2                	mov    edx,eax
		if (val == current) return;
  41c950:	39 c1                	cmp    ecx,eax
  41c952:	0f 84 18 01 00 00    	je     41ca70 <__lock+0x1d0>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41c958:	8d 88 01 00 00 80    	lea    ecx,[rax-0x7fffffff]
		if (current < 0) current -= INT_MIN + 1;
  41c95e:	85 c0                	test   eax,eax
  41c960:	79 08                	jns    41c96a <__lock+0xca>
  41c962:	89 c1                	mov    ecx,eax
  41c964:	81 c2 ff ff ff 7f    	add    edx,0x7fffffff
  41c96a:	89 d0                	mov    eax,edx
  41c96c:	f0 0f b1 4d 00       	lock cmpxchg DWORD PTR [rbp+0x0],ecx
  41c971:	89 c1                	mov    ecx,eax
		if (val == current) return;
  41c973:	39 c2                	cmp    edx,eax
  41c975:	0f 84 f5 00 00 00    	je     41ca70 <__lock+0x1d0>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41c97b:	8d 90 01 00 00 80    	lea    edx,[rax-0x7fffffff]
		if (current < 0) current -= INT_MIN + 1;
  41c981:	85 c0                	test   eax,eax
  41c983:	0f 88 f7 00 00 00    	js     41ca80 <__lock+0x1e0>
  41c989:	89 c8                	mov    eax,ecx
  41c98b:	f0 0f b1 55 00       	lock cmpxchg DWORD PTR [rbp+0x0],edx
  41c990:	89 c2                	mov    edx,eax
		if (val == current) return;
  41c992:	39 c1                	cmp    ecx,eax
  41c994:	0f 84 d6 00 00 00    	je     41ca70 <__lock+0x1d0>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41c99a:	8d 88 01 00 00 80    	lea    ecx,[rax-0x7fffffff]
		if (current < 0) current -= INT_MIN + 1;
  41c9a0:	85 c0                	test   eax,eax
  41c9a2:	0f 88 e8 00 00 00    	js     41ca90 <__lock+0x1f0>
  41c9a8:	89 d0                	mov    eax,edx
  41c9aa:	f0 0f b1 4d 00       	lock cmpxchg DWORD PTR [rbp+0x0],ecx
  41c9af:	89 c1                	mov    ecx,eax
		if (val == current) return;
  41c9b1:	39 c2                	cmp    edx,eax
  41c9b3:	0f 84 b7 00 00 00    	je     41ca70 <__lock+0x1d0>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41c9b9:	8d 90 01 00 00 80    	lea    edx,[rax-0x7fffffff]
		if (current < 0) current -= INT_MIN + 1;
  41c9bf:	85 c0                	test   eax,eax
  41c9c1:	0f 88 d9 00 00 00    	js     41caa0 <__lock+0x200>
  41c9c7:	89 c8                	mov    eax,ecx
  41c9c9:	f0 0f b1 55 00       	lock cmpxchg DWORD PTR [rbp+0x0],edx
  41c9ce:	89 c2                	mov    edx,eax
		if (val == current) return;
  41c9d0:	39 c1                	cmp    ecx,eax
  41c9d2:	0f 84 98 00 00 00    	je     41ca70 <__lock+0x1d0>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41c9d8:	8d 88 01 00 00 80    	lea    ecx,[rax-0x7fffffff]
		if (current < 0) current -= INT_MIN + 1;
  41c9de:	85 c0                	test   eax,eax
  41c9e0:	0f 88 ca 00 00 00    	js     41cab0 <__lock+0x210>
  41c9e6:	89 d0                	mov    eax,edx
  41c9e8:	f0 0f b1 4d 00       	lock cmpxchg DWORD PTR [rbp+0x0],ecx
  41c9ed:	89 c1                	mov    ecx,eax
		if (val == current) return;
  41c9ef:	39 c2                	cmp    edx,eax
  41c9f1:	74 7d                	je     41ca70 <__lock+0x1d0>
		int val = a_cas(l, current, INT_MIN + (current + 1));
  41c9f3:	8d 90 01 00 00 80    	lea    edx,[rax-0x7fffffff]
		if (current < 0) current -= INT_MIN + 1;
  41c9f9:	85 c0                	test   eax,eax
  41c9fb:	0f 88 bf 00 00 00    	js     41cac0 <__lock+0x220>
  41ca01:	89 c8                	mov    eax,ecx
  41ca03:	f0 0f b1 55 00       	lock cmpxchg DWORD PTR [rbp+0x0],edx
		if (val == current) return;
  41ca08:	39 c1                	cmp    ecx,eax
  41ca0a:	74 64                	je     41ca70 <__lock+0x1d0>
	__asm__ __volatile__(
  41ca0c:	bb 01 00 00 00       	mov    ebx,0x1
  41ca11:	f0 0f c1 5d 00       	lock xadd DWORD PTR [rbp+0x0],ebx
		current = val;
	}
	// Spinning failed, so mark ourselves as being inside the CS.
	current = a_fetch_add(l, 1) + 1;
  41ca16:	83 c3 01             	add    ebx,0x1
  41ca19:	eb 18                	jmp    41ca33 <__lock+0x193>
  41ca1b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		if (current < 0) {
			__futexwait(l, current, 1);
			current -= INT_MIN + 1;
		}
		/* assertion: current > 0, the count includes us already. */
		int val = a_cas(l, current, INT_MIN + current);
  41ca20:	8d 9a 00 00 00 80    	lea    ebx,[rdx-0x80000000]
	__asm__ __volatile__ (
  41ca26:	89 d0                	mov    eax,edx
  41ca28:	f0 0f b1 5d 00       	lock cmpxchg DWORD PTR [rbp+0x0],ebx
  41ca2d:	89 c3                	mov    ebx,eax
		if (val == current) return;
  41ca2f:	39 c2                	cmp    edx,eax
  41ca31:	74 3d                	je     41ca70 <__lock+0x1d0>
		if (current < 0) {
  41ca33:	89 da                	mov    edx,ebx
  41ca35:	85 db                	test   ebx,ebx
  41ca37:	79 e7                	jns    41ca20 <__lock+0x180>
	return __cos_syscall(n, a1, a2, a3, a4, 0, 0, 0);
  41ca39:	6a 00                	push   0x0
	__syscall(SYS_futex, addr, FUTEX_WAIT|priv, val, 0) != -ENOSYS ||
  41ca3b:	4c 63 e3             	movsxd r12,ebx
  41ca3e:	48 89 ee             	mov    rsi,rbp
  41ca41:	45 31 c9             	xor    r9d,r9d
  41ca44:	6a 00                	push   0x0
  41ca46:	4c 89 e1             	mov    rcx,r12
  41ca49:	45 31 c0             	xor    r8d,r8d
  41ca4c:	ba 80 00 00 00       	mov    edx,0x80
  41ca51:	bf ca 00 00 00       	mov    edi,0xca
  41ca56:	e8 35 e4 fe ff       	call   40ae90 <__cos_syscall>
  41ca5b:	59                   	pop    rcx
  41ca5c:	5e                   	pop    rsi
  41ca5d:	48 83 f8 da          	cmp    rax,0xffffffffffffffda
  41ca61:	74 6d                	je     41cad0 <__lock+0x230>
			current -= INT_MIN + 1;
  41ca63:	8d 93 ff ff ff 7f    	lea    edx,[rbx+0x7fffffff]
  41ca69:	eb b5                	jmp    41ca20 <__lock+0x180>
  41ca6b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		current = val;
	}
}
  41ca70:	5b                   	pop    rbx
  41ca71:	5d                   	pop    rbp
  41ca72:	41 5c                	pop    r12
  41ca74:	c3                   	ret    
  41ca75:	0f 1f 00             	nop    DWORD PTR [rax]
  41ca78:	c3                   	ret    
  41ca79:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		if (current < 0) current -= INT_MIN + 1;
  41ca80:	89 c2                	mov    edx,eax
  41ca82:	81 c1 ff ff ff 7f    	add    ecx,0x7fffffff
  41ca88:	e9 fc fe ff ff       	jmp    41c989 <__lock+0xe9>
  41ca8d:	0f 1f 00             	nop    DWORD PTR [rax]
  41ca90:	89 c1                	mov    ecx,eax
  41ca92:	81 c2 ff ff ff 7f    	add    edx,0x7fffffff
  41ca98:	e9 0b ff ff ff       	jmp    41c9a8 <__lock+0x108>
  41ca9d:	0f 1f 00             	nop    DWORD PTR [rax]
  41caa0:	89 c2                	mov    edx,eax
  41caa2:	81 c1 ff ff ff 7f    	add    ecx,0x7fffffff
  41caa8:	e9 1a ff ff ff       	jmp    41c9c7 <__lock+0x127>
  41caad:	0f 1f 00             	nop    DWORD PTR [rax]
  41cab0:	89 c1                	mov    ecx,eax
  41cab2:	81 c2 ff ff ff 7f    	add    edx,0x7fffffff
  41cab8:	e9 29 ff ff ff       	jmp    41c9e6 <__lock+0x146>
  41cabd:	0f 1f 00             	nop    DWORD PTR [rax]
  41cac0:	89 c2                	mov    edx,eax
  41cac2:	81 c1 ff ff ff 7f    	add    ecx,0x7fffffff
  41cac8:	e9 34 ff ff ff       	jmp    41ca01 <__lock+0x161>
  41cacd:	0f 1f 00             	nop    DWORD PTR [rax]
  41cad0:	6a 00                	push   0x0
  41cad2:	31 d2                	xor    edx,edx
  41cad4:	45 31 c9             	xor    r9d,r9d
  41cad7:	45 31 c0             	xor    r8d,r8d
  41cada:	6a 00                	push   0x0
  41cadc:	4c 89 e1             	mov    rcx,r12
  41cadf:	48 89 ee             	mov    rsi,rbp
  41cae2:	bf ca 00 00 00       	mov    edi,0xca
  41cae7:	e8 a4 e3 fe ff       	call   40ae90 <__cos_syscall>
  41caec:	58                   	pop    rax
  41caed:	5a                   	pop    rdx
  41caee:	e9 70 ff ff ff       	jmp    41ca63 <__lock+0x1c3>
  41caf3:	66 2e 0f 1f 84 00 00 	cs nop WORD PTR [rax+rax*1+0x0]
  41cafa:	00 00 00 
  41cafd:	0f 1f 00             	nop    DWORD PTR [rax]

000000000041cb00 <__unlock>:

void __unlock(volatile int *l)
{
  41cb00:	f3 0f 1e fa          	endbr64 
	/* Check l[0] to see if we are multi-threaded. */
	if (l[0] < 0) {
  41cb04:	8b 07                	mov    eax,DWORD PTR [rdi]
  41cb06:	85 c0                	test   eax,eax
  41cb08:	78 06                	js     41cb10 <__unlock+0x10>
  41cb0a:	c3                   	ret    
  41cb0b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
{
  41cb10:	55                   	push   rbp
	__asm__ __volatile__(
  41cb11:	b8 ff ff ff 7f       	mov    eax,0x7fffffff
  41cb16:	48 89 fd             	mov    rbp,rdi
  41cb19:	f0 0f c1 07          	lock xadd DWORD PTR [rdi],eax
		if (a_fetch_add(l, -(INT_MIN + 1)) != (INT_MIN + 1)) {
  41cb1d:	3d 01 00 00 80       	cmp    eax,0x80000001
  41cb22:	74 29                	je     41cb4d <__unlock+0x4d>
	return __cos_syscall(n, a1, a2, a3, 0, 0, 0, 0);
  41cb24:	6a 00                	push   0x0
  41cb26:	48 89 fe             	mov    rsi,rdi
  41cb29:	b9 01 00 00 00       	mov    ecx,0x1
  41cb2e:	45 31 c9             	xor    r9d,r9d
  41cb31:	6a 00                	push   0x0
  41cb33:	45 31 c0             	xor    r8d,r8d
  41cb36:	ba 81 00 00 00       	mov    edx,0x81
  41cb3b:	bf ca 00 00 00       	mov    edi,0xca
  41cb40:	e8 4b e3 fe ff       	call   40ae90 <__cos_syscall>
	__syscall(SYS_futex, addr, FUTEX_WAKE|priv, cnt) != -ENOSYS ||
  41cb45:	59                   	pop    rcx
  41cb46:	5e                   	pop    rsi
  41cb47:	48 83 f8 da          	cmp    rax,0xffffffffffffffda
  41cb4b:	74 03                	je     41cb50 <__unlock+0x50>
			__wake(l, 1, 1);
		}
	}
}
  41cb4d:	5d                   	pop    rbp
  41cb4e:	c3                   	ret    
  41cb4f:	90                   	nop
  41cb50:	6a 00                	push   0x0
  41cb52:	ba 01 00 00 00       	mov    edx,0x1
  41cb57:	48 89 ee             	mov    rsi,rbp
  41cb5a:	45 31 c9             	xor    r9d,r9d
  41cb5d:	6a 00                	push   0x0
  41cb5f:	45 31 c0             	xor    r8d,r8d
  41cb62:	b9 01 00 00 00       	mov    ecx,0x1
  41cb67:	bf ca 00 00 00       	mov    edi,0xca
  41cb6c:	e8 1f e3 fe ff       	call   40ae90 <__cos_syscall>
  41cb71:	58                   	pop    rax
  41cb72:	5a                   	pop    rdx
  41cb73:	5d                   	pop    rbp
  41cb74:	c3                   	ret    
