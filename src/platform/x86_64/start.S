#include "multiboot2.h"

/* multiboot2 header must be contained completely within the first 32768 bytes of the OS image, and must be 64-bit aligned */
.section .text
multiboot_start:

    /* must have multiboot2 header field */
    .long MULTIBOOT2_HEADER_MAGIC
    .long MULTIBOOT_ARCHITECTURE_I386
    .long multiboot_end - multiboot_start
    .long -(MULTIBOOT2_HEADER_MAGIC + MULTIBOOT_ARCHITECTURE_I386 + (multiboot_end - multiboot_start))

    /* end tag of multiboot2 */
    .short MULTIBOOT_HEADER_TAG_END
    .short 0
    .long 8

multiboot_end:

.set STACKSIZE, 0x1000
.comm stack, STACKSIZE , 0x1000

/* 
 * grub enters 32-bit mode, so your first section should use 32-bit code.
 * jmp to 64 bit yourself from here.
 */
.code32
.global entry_point
entry_point:
    /* Prepare to enter long(64-bit) mode */

    /* close paging first */
    mov %cr0, %eax                                   
    and $0b1111111111111111111111111111111, %eax   
    mov %eax, %cr0                                

    /* test if 1G huge page is supported */
    /* some cpus don't support 1G huge page, we enable this by set qemu -cpu max */
    mov $0x80000001, %eax
    cpuid
    bt $26, %edx
    jc huge_page_enabled
    /* TODO: support for cpus which don't have 1G paging scheme here */
    jmp .

huge_page_enabled:
    /* we have to set up a temparaily page scheme to before enter long mode */
    /* we use 1G paging scheme, so only to set P4_table, P3_table */
    mov $P3_table, %eax
    or $0x01, %eax
    mov %eax, P4_table
    
    /* set kernel paging space */
    movl  $0x00000083, P3_table /* 0-1 GB vm -> 0-1 GB pm */
    movl  $0x0, (P3_table+0x08*1)
    movl  $0x0, (P3_table+0x08*2)
    movl  $0x00000083, (P3_table+0x08*3) /* 3-4 GB vm -> 0-1 GB pm */

    /* set %cr3 to the physical address of P4_table */
    mov $P4_table, %eax
    mov %eax, %cr3

    /* enable PAE-paging by setting the PAE-bit in %cr4 */
    mov %cr4, %eax
    or $(1 << 5), %eax
    mov %eax, %cr4

    /* set the long mode bit in the EFER MSR */
    mov $0xC0000080, %ecx
    rdmsr
    or $(1 << 8), %eax
    wrmsr

    /* enable paging and protected mode in cr0 */
    mov %cr0, %eax
    or $(1 << 31), %eax
    mov %eax, %cr0

    /* load GDT so we can use selectors within them */
    mov $Gdt_Ptr, %eax
    lgdt (%eax)

    /* need a jump to flush cs selector */
.code64
    mov $entry_64, %rax
    pushq $0x08
    pushq %rax
    lretq


entry_64:
    
    cli
    /* Flush data selectors */
    mov $0x10, %rax	
    mov %rax, %ds
    mov %rax, %es
    mov %rax, %fs
    mov %rax, %gs
    mov %rax, %ss

    /* set up a kernel stack for kmain */
    movabs $(stack + STACKSIZE), %rsp
    movabs $kmain, %rax
    pushq $0x08
    pushq %rax
    lretq
    jmp .


/* a simple temparaily GDT */
.align 8
.global Gdt_Table
Gdt_Table:
    .quad	0x0000000000000000	// null descriptor
    .quad	0x0020980000000000	// kernel code descriptor
    .quad 	0x0000920000000000	// kernel data descriptor
Gdt_End:

Gdt_Ptr:	
    .word	Gdt_End - Gdt_Table - 1
    .quad	Gdt_Table

/* temparaily page directory/tables */
/* need to be 4k aligned */
.align 4096

.global P4_table
P4_table:
    .fill 512, 8, 0

.global P3_table
P3_table:
    .fill 512, 8, 0

